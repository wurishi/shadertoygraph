{"ver":"0.1","info":{"id":"Xc3BDS","date":"1733428559","viewed":99,"name":"naive rays","username":"BearKirb","description":"laksjdfhlaksjdfhalsdfhalskdf","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["fas","saf","las","saskhjl","lkfa","lfda","lklh","fasljkfaslkjdfh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 Rotate(vec2 uv,float ang){\n    return vec2(uv.x*cos(ang)-uv.y*sin(ang),uv.x*sin(ang)+uv.y*cos(ang));\n}\n\nvoid Rotate( inout vec3 vector, vec2 angle )\n{\n\tvector.yz = cos(angle.y)*vector.yz\n\t\t\t\t+sin(angle.y)*vec2(-1,1)*vector.zy;\n\tvector.xz = cos(angle.x)*vector.xz\n\t\t\t\t+sin(angle.x)*vec2(-1,1)*vector.zx;\n}\nvec2 crt(vec2 coord, float bend){\n\t// put in symmetrical coords\n\tcoord = (coord - 0.5) * 2.0;\n\n\tcoord *= 1.1;\t\n\n\t// deform coords\ncoord=Rotate(coord,bend*pow(length(coord),2.0));\n\n\t// transform back to 0.0 - 1.0 space\n\tcoord  = (coord / 2.2) + 0.5;\n\n\treturn coord;\n}\n\n#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11\n\nfloat hash( uvec2 q )\n{\n    q *= uvec2(M1, M2); \n    \n    uint n = (q.x ^ q.y) * M1;\n    \n    return float(n) * (1.0/float(0xffffffffU));\n}\nvec4 textur(vec2 uv){\n  vec2 ruv=uv;\n  \n    return texture(iChannel0,ruv);\n}\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\nvec4 photoshop_desaturate(vec3 color, float factor)\n{\n\tvec3 lum = vec3(0.299, 0.587, 0.114);\n\tvec3 gray = vec3(dot(lum, color));\n\treturn vec4(mix(color, gray, factor), 1.0);\n}\nfloat sin2(float x){\n    return cos(x)<0.0?(sin(x)>0.0?-1.0:1.0):sin(x);\n}\nvec3 aces_tonemap(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.071024, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\n#define DITHER_STEPS 1.0\nint dither_matrix[64] = int[](\n    0,32,8,40,2,34,10,42,\n    48,16,56,24,50,18,58,26,\n    12,44,4,36,14,46,6,38,\n    60,28,52,20,62,30,54,22,\n    3,35,11,43,1,33,9,41,\n    51,19,59,27,49,17,57,25,\n    15,47,7,39,13,45,5,37,\n    63,31,55,23,61,29,53,21\n);\n\nvec4 posterize(vec4 col, float steps)\n{\n    return floor(col*steps)/steps;\n}\n\nvec4 nearest_palette(vec4 x)\n{\n    return posterize(x, DITHER_STEPS);\n}\n\nvec4 dither(vec4 col, vec2 uv)\n{\n    int x_m = int(uv.x) % 8;\n    int y_m = int(uv.y) % 8;\n    float M = float(dither_matrix[y_m*8+x_m])/64.;\n    \n    return nearest_palette(col+(M-.5f));\n}\nvec3 srgbToLinear(const vec3 x){\n    return 0.315206*x*((2.10545+x)*(0.0231872+x));\n}\n// curve matched using turingbot\nvec3 linearToSrgb(const vec3 x){\n    return 1.14374*(-0.126893*x+sqrt(x));\n}\n\nvec4 t(vec2 p,float m){\n    vec4 t=texture(iChannel0,p,m)+0.01;\n    return vec4(srgbToLinear(t.rgb),t.a);\n}\n\nvec4 fastBloom (vec2 p,vec2 r,float mi){\n     float mip = mi;\n    float scale = exp2(mip)*0.5;\n    vec4 c =\n        t((p+vec2(-1.5,-0.5)*scale)/r,mip)*.1+\n        t((p+vec2( 0.5,-1.5)*scale)/r,mip)*.1+\n        t((p+vec2( 1.5, 0.5)*scale)/r,mip)*.1+\n        t((p+vec2(-0.5, 1.5)*scale)/r,mip)*.1+\n        t((p)/r,mip)*.3+\n        t(p/r,0.)*.4;\n    return c*scale*9.9;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n   \n   \n    vec2 res = iResolution.xy;\n    vec2 uv=(fragCoord/res);\n\n        fragColor.rgba = textur(uv).rgba;\n\n\n\n   \n    fragColor.a=1.0;\n \n//fragColor.rgb=dither(vec4(fragColor.rgb*2.0,1.0),gl_FragCoord.xy*0.5).rgb;\n}\n\n  \n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nstruct Material\n{\n    vec3 BaseColor;\n    float Roughness;\n    float Reflectivity;\n    bool transparent;\n    float Opacity;\n    float RefractiveIndex;\n    float RefractRatio;\n};\n   void Rotate(inout vec3 vector, vec2 angle){\n\t        vector.yz = cos(angle.y)*vector.yz+sin(angle.y)*vec2(-1,1)*vector.zy;\n\t        vector.xz = cos(angle.x)*vector.xz+sin(angle.x)*vec2(-1,1)*vector.zx;\n        }\n   uint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}     \nfloat hash( float f ) {\n    const uint mantissaMask = 0x007FFFFFu;\n    const uint one          = 0x3F800000u;\n   \n    uint h = hash( floatBitsToUint( f ) );\n    h &= mantissaMask;\n    h |= one;\n    \n    float  r2 = uintBitsToFloat( h );\n    return r2 - 1.0;\n}\nvec2 hash(float seed, vec2 uv){\n    return vec2(hash(uv.y+hash(1.0+uv.x+seed++)),hash(uv.x+hash(uv.y+seed++)));\n}\nvec3 randDir(float seed, vec2 uv, vec3 norm){\n    vec3 rand=vec3(0.5);\n    float seed2=hash(uv.x+hash(uv.y+seed)+seed);\n    for(int i=0;i<100;i++){\n        rand=vec3(hash(seed2+seed++),hash(seed2+seed++),hash(seed2+seed++))*2.0-1.0;\n        if(length(rand)<=1.0) break;\n    }\n    return faceforward(rand,rand,-norm);\n}\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\nvec4 sphere (vec4 z) {\n    float r2 = dot (z.xyz, z.xyz);\n    if (r2 < 2.0)\n      z *= (1.0 / r2);\n    else z *= 0.5;\n    return z;\n  }\n  vec3 box (vec3 z) {\n    return clamp (z, -1.0, 1.0) * 2.0 - z;\n  }\n float periodic(float x,float period,float dutycycle){\n    x/=period;\n    x=abs(x-floor(x)-0.5)-dutycycle*0.5;\n    return x*period;\n  }\n\n  float core(vec3 p){\n    float radius = 0.2;\n    return length(p.xy)-radius; // xy, yz for other directions\n  }\n  const float PI = 3.14159;\n  float pModPolar(inout vec2 p, float repetitions) {\n    \n    float angle = 2.*PI/repetitions,\n          a = atan(p.y, p.x)+angle,\n          r = length(p),\n          c = floor(a / angle);\n    a = mod(a, angle) - angle / 2.0;\n    p = vec2(cos(a), sin(a)) *r ;\n    if (abs(c) >= (repetitions / 2.0)) c = abs(c);\n    return c;\n}\n\n//===================================================================//\n// below by https://iquilezles.org/articles/distfunctions/\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sMin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sMax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nmat2 rotate2D ( float r ) {\n  return mat2( cos( r ), sin( r ), -sin( r ), cos( r ) );\n}\n\n\nmat2 rot( float r ){\n  return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\n \n  float de(vec3 p0){\n    vec4 p = vec4(p0/10., 1.);\n    float escape = 0.; p=abs(p);\n    if(p.x < p.z)p.xz = p.zx;\n    if(p.z < p.y)p.zy = p.yz;\n    if(p.y < p.x)p.yx = p.xy;\n    for(int i = 0; i < 9; i++){\n      if(p.x < p.z)p.xz = p.zx;\n      if(p.z < p.y)p.zy = p.yz;\n      if(p.y < p.x)p.yx = p.xy;\n      p = abs(p);\n      p*=(2./clamp(dot(p.xyz,p.xyz),0.1,1.));\n      p.xyz-=vec3(0.5,1.8,0.9);\n    }\n    float m = 0.8;\n    p.xyz-=clamp(p.xyz,-m,m);\n    return (length(p.xyz)/p.w)*10.;\n  }\nfloat Scene(vec3 pos, inout Material currentMat){\n    vec3 oc=vec3(0.0);\n    float dat=de(pos);\n\n    currentMat=Material(vec3(0.4,0.25,0.22),1.0,0.9,false,1.0,1.0,1.0);\n\n    float ou=dat;\n    float sl=-0.85;\nif(pos.x<0.18+sl){\n  currentMat=Material(vec3(100.0,90.0,80.0)*0.17,0.1,0.9,false,1.0,1.0,1.0);  \n}\n\n    return ou;\n}\n\n      vec3 calcNormal(in vec3 pos){\n            vec2 e = vec2(1.0,-1.0)*0.0001;\n            Material ph=Material(vec3(0.0),0.0,0.0,false,0.0,0.0,0.0);\n            return normalize(\n                e.xyy*Scene(pos + e.xyy,ph) + \n        \t\te.yyx*Scene(pos + e.yyx,ph) + \n        \t\te.yxy*Scene(pos + e.yxy,ph) + \n        \t\te.xxx*Scene(pos + e.xxx,ph)\n        \t);\n        }\n\nfloat fresnel(float r0, vec3 n, vec3 i)\n{\n    float a = 1.0f - dot(n, i);\n    return r0 + (a - r0) * a*a*a*a;\n}\n vec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nfloat fbm(vec2 v){\n    v/=6.0;\nfloat ou=0.0;\nfloat mult=1.0;\nfor(int i=0;i<5;i++){\nmult*=2.71;\nou+=noise(v*mult+1000.0*hash(vec2(float(i))).x)/mult;\n}\nreturn ou/1.2+0.6;\n}\n\n        vec3 skybox(in vec3 rd){\n                 \n            rd = -rd;\n            const float SC = 1e5;\n        \n         \t// Calculate sky plane\n            float dist = (SC) / rd.y; \n            vec2 p = (dist * rd).xz;\n            p *= 1.2 / SC;\n            \n            // from iq's shader, https://www.shadertoy.com/view/MdX3Rr\n            vec3 lightDir = normalize(vec3(-.8, .15, -.3));\n            float sundot = clamp(dot(rd, lightDir), 0.0, 1.0);\n            \n            vec3 cloudCol = vec3(0.8,0.78,0.76);\n            vec3 skyCol = vec3(.46, .61, .85)*0.6 - rd.y * .1 * vec3(1., .5, 1.) + .15 * .5;\n            //vec3 skyCol = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n            skyCol = mix( skyCol, 0.85 * vec3(0.7,0.75,0.85), pow( 1.0 - max(rd.y, 0.0), 4.0 ) );\n            \n            // sun\n            vec3 sun = 0.25 * vec3(1.0, 0.7, 0.4) * pow(sundot, 5.0);\n            sun += 0.25 * vec3(1.0, 0.8, 0.6) * pow(sundot, 64.0);\n            sun += 0.2 * vec3(1.0, 0.8, 0.6) * pow(sundot, 512.0);\n            skyCol += sun;\n            \n            // clouds\n            float t = iTime * 0.005;\n            float den = fbm(vec2(p.x - t, p.y - t));\n            skyCol = mix( skyCol, cloudCol, smoothstep(.4, .8, den));\n            \n            // horizon\n            skyCol = mix( skyCol, 0.78 * vec3(.318, .334, .372), pow( 1.0 - max(rd.y, 0.0), 16.0 ) );\n            \n            return skyCol*0.02;\n        }\nvec2 randomInUnitDisk( in float seed ) {\n    vec2 h = hash(seed) * vec2(1,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r*vec2(sin(phi),cos(phi))*hash(seed+1.0);\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nvec3 aces_tonemap(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07512, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\nvec3 trace(vec2 uv,float ti){\n    Material currentMat = Material(vec3(0.0),0.0,0.0,false,0.0,0.0,0.0);\n    vec3 fragColor=vec3(0.0);\n    vec2 p=uv+vec2(hash(ti++,uv)-0.5)/1200.0;\n    \n \n    float fov = 3.5;\n    float focusDistance = 0.85;\n    float blurAmount = 0.003;\n    \n    int numReflections=1;\n    int numMarches=145;\n    \n    vec3 cameraPos=vec3(-0.6*0.9,-0.51,-0.19*0.9);\n    vec3 target=vec3(0.38,-1.3,-1.16);\n    //focusDistance=distance(cameraPos,target);\n    vec3 rayOrigin=cameraPos;\n    mat3 ca=setCamera(cameraPos,target,0.0);\n    vec3 rayDir=ca*normalize(vec3(p.xy,fov));\n    vec3 fp = rayOrigin + rayDir * focusDistance;\n    rayOrigin = rayOrigin + ca * vec3(randomInUnitDisk(ti+uv.x+hash(uv.y)), 0.)*blurAmount;\n    rayDir = normalize(fp - rayOrigin);\n    \n    \n    vec3 escapeTime=vec3(1.0);\n    for(int i=0;i<=numReflections;i++){\n    for(int i=0;i<=numMarches;i++){\n    float sdScene=Scene(rayOrigin, currentMat);\n    rayOrigin+=normalize(rayDir)*sdScene*0.7;\n    if(sdScene<0.0001||length(rayOrigin)>200.0) break;\n    }\n    float sdScene=Scene(rayOrigin,currentMat);\n    vec3 normal=calcNormal(rayOrigin);\n    if(sdScene<0.00011){\n    \n    rayOrigin+=normal*0.0001;\n    rayDir=reflect(rayDir,normal);\n    rayDir=mix(rayDir,randDir(ti++,uv,normal),currentMat.Roughness);\n    }else{\n    \n            escapeTime*=skybox(rayDir)*1.0;\n        \n        break;\n     \n    }\n    escapeTime*=fresnel(currentMat.Reflectivity,normal,rayDir)*currentMat.BaseColor;\n    }\n    fragColor.rgb=vec3(1.0)*escapeTime;    \n      return fragColor;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n   \n    vec2 uv = 8.0*(gl_FragCoord.xy-iResolution.xy*0.5)/-iResolution.y;\n    vec2 uv2 = (fragCoord.xy)/iResolution.xy;\n\n      fragColor = vec4(0.0,0.0,0.0,1.0);\n    \n vec3 c=trace(uv,float(iFrame))*1.0;\n      fragColor = vec4(c.r,c.g,c.b,1.0);\n    vec3 tex=texture(iChannel0,uv2).rgb;\n   if(iFrame>1){\n       fragColor.rgb=mix(fragColor.rgb,tex,1.0-(1.0/(float(iFrame)+2.0)));\n       }\n}","name":"Buffer A","description":"","type":"buffer"}]}