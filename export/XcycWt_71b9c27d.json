{"ver":"0.1","info":{"id":"XcycWt","date":"1732513328","viewed":49,"name":"DiamondShader3-Test","username":"adras","description":"DiamondShader3-Test","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["wave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_EDGES 24\n#define PI 3.14159265359\n#define FIGURE_COUNT 5\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord / iResolution.xy) - vec2(0.5, 0.5); \n    uv.x *= iResolution.x / iResolution.y; // Correct for aspect ratio\n    uv *= 3.5;\n\n    // Adjustable Parameters\n    const float freqMultiplier = 2.0;    // Frequency of the wave\n    const float timeMultiplier = 1.1;    // Speed of time-varying phase\n    const float amplitude = 22.15;       // Amplitude of the wave\n    const float lineThickness = 0.012;   // Line thickness\n    const float vertexMid = 1.0;         // Interpolation value for mid-point\n    const float vertexEnd = 1.0;         // Interpolation value for end-point\n    float speedX = sin(iTime)*0.15;           // Rotation speed around the X-axis\n    const float speedY = 0.18;           // Rotation speed around the Y-axis\n    const float speedZ = 0.33;           // Rotation speed around the Z-axis\n    const float initialX = radians(45.0); // Initial rotation around X-axis\n    const float initialY = radians(30.0); // Initial rotation around Y-axis\n    const float initialZ = radians(60.0); // Initial rotation around Z-axis\n    const float sizeIncrement = 0.2;     // Size increment for each figure\n\n    float time = iTime; // Current time\n\n    vec3 finalColor = vec3(0.0);\n\n    for (int figureIndex = 0; figureIndex < FIGURE_COUNT; figureIndex++) {\n        float currentSize = (1.0 + float(figureIndex) * sizeIncrement)*(sin(iTime)+1.5);\n\n        // Define 3D vertices for the double pyramid\n        vec3 vertices[6] = vec3[](\n            vec3(-vertexMid, -vertexMid, 0.0) * currentSize,  // Bottom-left of the base\n            vec3(vertexMid, -vertexMid, 0.0) * currentSize,   // Bottom-right of the base\n            vec3(vertexMid, vertexMid, 0.0) * currentSize,    // Top-right of the base\n            vec3(-vertexMid, vertexMid, 0.0) * currentSize,   // Top-left of the base\n            vec3(0.0, 0.0, vertexEnd) * currentSize,          // Top apex\n            vec3(0.0, 0.0, -vertexEnd) * currentSize          // Bottom apex\n        );\n\n        // Rotation angles (time-dependent)\n        float angleX = speedX * time + initialX;\n        float angleY = speedY * time + initialY;\n        float angleZ = speedZ * time + initialZ;\n\n        // Rotation matrices\n        mat3 rotationX = mat3(\n            1.0, 0.0, 0.0,\n            0.0, cos(angleX), -sin(angleX),\n            0.0, sin(angleX), cos(angleX)\n        );\n\n        mat3 rotationY = mat3(\n            cos(angleY), 0.0, sin(angleY),\n            0.0, 1.0, 0.0,\n            -sin(angleY), 0.0, cos(angleY)\n        );\n\n        mat3 rotationZ = mat3(\n            cos(angleZ), -sin(angleZ), 0.0,\n            sin(angleZ), cos(angleZ), 0.0,\n            0.0, 0.0, 1.0\n        );\n\n        // Combined rotation matrix\n        mat3 rotation = rotationZ * rotationY * rotationX;\n\n        // Apply rotation to vertices\n        for (int i = 0; i < 6; i++) {\n            vertices[i] = rotation * vertices[i];\n        }\n\n        // Flattened edge array (pairs of vertices)\n        vec2 edges[MAX_EDGES];\n        for (int i = 0; i < 4; i++) {\n            edges[i*2] = vertices[i].xy; \n            edges[i*2 + 1] = vertices[4].xy; // Base to top apex\n            edges[(i+4)*2] = vertices[i].xy; \n            edges[(i+4)*2 + 1] = vertices[5].xy; // Base to bottom apex\n        }\n\n        for (int i = 0; i < 4; i++) {\n            edges[(i+8)*2] = vertices[i].xy; \n            edges[(i+8)*2 + 1] = vertices[(i+1)%4].xy; // Central square\n        }\n\n        // Compute color contribution from each edge\n        for (int i = 0; i < MAX_EDGES; i += 2) {\n            vec2 start = edges[i];\n            vec2 end = edges[i + 1];\n\n            // Parametric equation for the line\n            float t = dot(uv - start, normalize(end - start)) / length(end - start);\n\n            // Interpolate along the line\n            vec2 pointOnLine = mix(start, end, clamp(t, 0.0, 1.0));\n\n            // Check if UV is close to the line\n            float d = length(uv - pointOnLine);\n            if (d < lineThickness) {\n                // Proper wave packet: f3(x) = f1(x) + f2(x)\n                float x = freqMultiplier * t;\n                float f1 = (sin(x) / (x + 1e-4)) * cos(x + timeMultiplier * time);\n                float f2 = (sin(x) / (x + 1e-4)) * cos(x - timeMultiplier * time);\n                float wave = (f1 + f2) * amplitude; // Combine and scale amplitude\n\n                // Oscillate between two colors\n                vec3 waveColor = mix(vec3(0, 0.5, 1), vec3(1.0, 0.0, 1), (wave + 1.0) / 2.0);\n                waveColor += vec3(0, 1, 1);\n\n                // Sum contribution from this wave\n                finalColor += waveColor / float(MAX_EDGES); // Normalize by MAX_EDGES\n            }\n        }\n    }\n \n    // Enhance the darker parts\n    finalColor = mix(vec3(0.0), finalColor, 3.2);\n\n    // Set final fragment color\n    fragColor = vec4(finalColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}