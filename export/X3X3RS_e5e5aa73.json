{"ver":"0.1","info":{"id":"X3X3RS","date":"1707593479","viewed":53,"name":"RayTracing: Bounce Once","username":"bluebytes","description":"Reflected color is fetched using surface normal - Approximation. (Can be fixed)\n[Cons] Incorrect reflection on cylinder:\n\n\nChrome seems to can not handle this shader well. Use of boolen flags crashes website.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","lighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n#define epsilon 0.00005\n\nstruct ObjData\n{\n    int objType;\n    bool enabled;\n    bool objReflect;\n    vec3 objPos;\n    float objSize;\n};\n\nstruct WorldData\n{\n\tvec3 wrldStartPoint;\n\tvec3 wrldSpotLight;\n\tfloat wrldSize;\n\n    ObjData objData[6];\n};\n\nvoid checkMap(vec3 point, inout vec3 color, float checksize)\n{\n    float xx = checksize, yy = checksize;\n\n    xx = fract(point.x * checksize);\n    yy = fract(point.z * checksize);\n\n    if (xx < 0.5)\n        color -= .2;\n    if (yy < 0.5)\n        color -= .2;\n}\n\nfloat Plane(const vec3 point, vec3 zpos, out vec3 color, out vec3 normal)\n{\n    color = vec3(.9);\n    float dist = point.y - (zpos.z);\n    if (dist < 0.)\n    {\n        color = vec3(.76);\n        checkMap(point, color, .6);\n        normal = vec3(0, 1, 0);\n        return dist;\n    }\n    return 10000.;\n}\n\nfloat BoxCircle(vec3 pos, vec3 point, float size, out vec3 color, out vec3 normal)\n{\n    // color = normalize(point - pos);\n    color = vec3(1, .4, .2);\n    // Invert colors at the top of spheres\n\n    // Sphere\n    normal = normalize(point - pos);\n\n    // Cylinder\n    return length(point - pos) - size;\n    float len2d = length(point.xz - pos.xz);\n    float top = point.y - pos.y;\n    vec2 dist = abs(vec2(len2d, top)) - vec2(size,size/2.);\n    return min(max(dist.x, dist.y), 0.0) + length(max(dist,0.0));\n}\n\nfloat BoxCyliner(vec3 pos, vec3 point, float size, out vec3 color, out vec3 normal)\n{\n    color = normalize(point - pos);\n    color.r = 0.;\n\n    normal = normalize(vec3(point.x - pos.x, 0, point.z - pos.z));\n    float len2d = length(point.xz - pos.xz);\n    float top = point.y - pos.y;\n    vec2 dist = abs(vec2(len2d, top)) - vec2(size *.7,size/.6);\n    return min(max(dist.x, dist.y), 0.0) + length(max(dist,0.0));\n}\n\nbool JoinTwo(float dist0, float dist1, inout vec4 fragColor, vec3 outColor0, vec3 outColor1)\n{\n    if ((dist0+dist1) < .23)\n    {\n        fragColor.xyz = mix(outColor0, outColor1, dist0/(dist0+dist1));\n        return true;\n    }\n    return false;\n}\n\nvoid Lighting(WorldData wrldData, inout vec4 color, vec3 pos, vec3 normal)\n{\n    float lgdist = length(wrldData.wrldSpotLight - pos);\n    float eyedist = length(pos - wrldData.wrldStartPoint);\n    float intensity = 1./pow(lgdist, 2.);\n    float distEffect = 5./eyedist;\n\n    // color.xyz = vec3(.5);\n    // checkMap(pos, color.xyz, .6);\n    color.xyz = mix(color.xyz, color.xyz * intensity, intensity);\n    color.xyz = mix(color.xyz, color.xyz * distEffect, distEffect);\n    // color.xyz = color.xyz * distEffect;\n    // color.xyz = vec3(clamp(dot(spotlight, pos), 0., 1.)); // vec3(intensity)\n}\n\nint rayMarching(WorldData wrldData, uint loopCount, inout vec4 fragColor, inout vec3 marchingPt, inout vec3 marchDir)\n{\n\tint passAlong = 0;\n\tfor (uint i = 0u; i < loopCount; i++)\n\t{\n        float mindis = 999999.;\n\n        for (int obj = 0; obj < 6; obj++)\n        {\n            //if (!wrldData.objData[obj].enabled)\n              //  continue;\n\n            vec3 outColor0;\n            vec3 outNormal0;\n            float dist0;\n            switch (wrldData.objData[obj].objType)\n            {\n                case 0:\n                    dist0 = BoxCircle(wrldData.objData[obj].objPos, marchingPt, wrldData.objData[obj].objSize, outColor0, outNormal0);\n                    break;\n                case 1:\n                    dist0 = BoxCyliner(wrldData.objData[obj].objPos, marchingPt, wrldData.objData[obj].objSize, outColor0, outNormal0);\n                    break;\n                default:\n                    dist0 = Plane(marchingPt, wrldData.objData[obj].objPos, outColor0, outNormal0);\n                    break;\n            }\n            float fdist0 = abs(dist0);\n            if (fdist0 < epsilon)\n            {\n                fragColor = vec4(outColor0, 1);\n                Lighting(wrldData, fragColor, marchingPt, outNormal0);\n                marchDir = outNormal0;\n                return obj;\n            }\n            mindis = min(mindis, dist0);\n        }\n\n\t\t#if 0\n\t\tif (abs(mindis) < epsilon*10.)\n\t\t{\n\t\t\tpassAlong++;\n\t\t\tif (passAlong > 10)\n\t\t\t{\n\t\t\t\tfragColor.xyz = vec3(1);\n\t\t\t\treturn -9;\n\t\t\t}\n\t\t}\n\t\t#endif\n\n\t\tmarchingPt = marchingPt + marchDir * mindis;\n\t}\n    return -1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tWorldData wrldData;\n\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\tfloat oscillation = abs(cos(iTime/3.)) / .8;\n\n\twrldData.wrldStartPoint = vec3(0, 1.5, 4. + 1.);\n\twrldData.wrldSpotLight = vec3(0, 4., -2);\n\twrldData.wrldSize = 1.0;\n\n    wrldData.objData[0].enabled = true;\n    wrldData.objData[0].objType = 0;\n\twrldData.objData[0].objPos = vec3(1. * sin(iTime), 1. * cos(oscillation) + .5, 1. * cos(iTime));\n    wrldData.objData[0].objSize = 1.0;\n    wrldData.objData[0].objReflect = true;\n\n    wrldData.objData[1].enabled = true;\n    wrldData.objData[1].objType = 1;\n\twrldData.objData[1].objPos = vec3(-2.5, 2., -3.0);\n    wrldData.objData[1].objSize = .5;\n    wrldData.objData[1].objReflect = true;\n\n    wrldData.objData[2].enabled = true;\n    wrldData.objData[2].objType = 1;\n\twrldData.objData[2].objPos = vec3(2.5, 2., -3.0);\n    wrldData.objData[2].objSize = wrldData.wrldSize;\n    wrldData.objData[2].objReflect = true;\n\n    wrldData.objData[3].enabled = true;\n    wrldData.objData[3].objType = 1;\n\twrldData.objData[3].objPos = vec3(-2.5, 1., 0.0);\n    wrldData.objData[3].objSize = wrldData.wrldSize;\n    wrldData.objData[3].objReflect = true;\n\n    wrldData.objData[4].enabled = true;\n    wrldData.objData[4].objType = 1;\n\twrldData.objData[4].objPos = vec3(2.5, 1., 0.0);\n    wrldData.objData[4].objSize = wrldData.wrldSize;\n    wrldData.objData[4].objReflect = true;\n\n    wrldData.objData[5].enabled = true;\n    wrldData.objData[5].objType = 999;\n\twrldData.objData[5].objPos = vec3(0);\n\twrldData.objData[5].objSize = wrldData.wrldSize;\n    wrldData.objData[5].objReflect = false;\n\n\tfloat dist = 0.;\n\tfragColor = vec4(130., 153., 142., 255.)/255.;\n\n\t// vec3 target = vec3(0, 0, 0);\n\n\tvec3 marchingPt = wrldData.wrldStartPoint;\n\tvec3 marchDir = normalize(vec3(uv,-1));\n\n    int hitObj = rayMarching(wrldData, 128u, fragColor, marchingPt, marchDir);\n    if (hitObj >= 0)\n    {\n        if (wrldData.objData[hitObj].objReflect)\n        {\n            // BUG: Enabling this line drops FPS dramatically\n             // wrldData.objData[hitObj].enabled = false;\n            vec4 rayTracingColor = fragColor;\n            // starter punt not to collide with same object\n            marchingPt = marchingPt + marchDir * .3;\n            rayMarching(wrldData, 40u, rayTracingColor, marchingPt, marchDir);\n            fragColor = mix(fragColor, rayTracingColor, .5);\n        }\n        else\n        {\n            vec4 rayTracingColor = vec4(0);\n            marchDir = normalize(wrldData.wrldSpotLight - marchingPt);\n            marchingPt = marchingPt + marchDir * .3;\n            int obstacle = rayMarching(wrldData, 40u, rayTracingColor, marchingPt, marchDir);\n            if (obstacle >= 0)\n            {\n                fragColor *= .5;\n            }\n        }\n    }\n}\n\n","name":"Image","description":"","type":"image"}]}