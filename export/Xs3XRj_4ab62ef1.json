{"ver":"0.1","info":{"id":"Xs3XRj","date":"1460142009","viewed":440,"name":"PRISM : Light Becoming","username":"cabbibo","description":"!!!SOUND WARNING!!!\n\nWhat happens when a light hits a prism?\n\n\nSound : @jonnyscript\nVisuals : @cabbibo / @macbooktall","likes":9,"published":1,"flags":8,"usePreview":0,"tags":["noise","sound","sdf","prism","rainbow","refract","story","timing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ALL TAKEN FROM IQs AMAZING SITE / TUTORIALS / SHADERS:\n// https://iquilezles.org/www/index.htm\n// https://www.shadertoy.com/user/iq\n// Includes code from hg_sdf library by Mercury http://mercury.sexy/hg_sdf/\n\nconst float MAX_TRACE_DISTANCE = 10.0;           // max trace distance\nfloat INTERSECTION_PRECISION = 0.001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS =400;\n\nfloat fadeIn = 0.;\nfloat fadeInTime = 2.;\nfloat lightExpanding= 0.;\nfloat lightExpandingTime = 3.;\nfloat lightDispersing= 0.;\nfloat lightDispersingTime = 3.;\n\nfloat finalPause = 0.;\nfloat finalPauseTime = 3.;\n\nfloat fadeOut= 0.;\nfloat fadeOutTime = 6.;\n\nfloat endPause = 0.;\nfloat endPauseTime = 6.;\n\nvec3 lightPos = vec3( .9 , .8 , .6 );\nvec3 lightEndPoint = vec3( 5. );\nvec3 lightStartPoint =  vec3( 0. , -.15,0. );\nvec3 camDir;\nfloat difVal;\nfloat prismSize = .7;// + cos(iTime*4.)*0.1;\n\n\nfloat impactLU[ 58 ];\n\n\n#define MOUSE_CAM\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\np = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n\n// \"Generalized Distance Functions\" by Akleman and Chen.\n// see the Paper at https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n// Macro based version for GLSL 1.2 / ES 2.0 by Tom\n\n#define GDFVector0 vec3(1, 0, 0)\n#define GDFVector1 vec3(0, 1, 0)\n#define GDFVector2 vec3(0, 0, 1)\n\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 1))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector15 normalize(vec3(1, 0, PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\n\n#define fGDFBegin float d = 0.;\n\n// Version with variable exponent.\n// This is slow and does not produce correct distances, but allows for bulging of objects.\n#define fGDFExp(v) d += pow(abs(dot(p, v)), e);\n\n// Version with without exponent, creates objects with sharp edges and flat faces\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n\n#define fGDFExpEnd return pow(d, 1./e) - r;\n#define fGDFEnd return d - r;\n\nfloat fOctahedron(vec3 p, float r) {\nfGDFBegin\nfGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\nfGDFEnd\n}\n\n\nvec3 hsv(float h, float s, float v)\n{\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat pNoise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n  \n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat triNoise3D(in vec3 p, in float spd)\n{\n    float z=1.4;\nfloat rz = 0.;\n    vec3 bp = p;\nfor (float i=0.; i<=3.; i++ )\n{\n        vec3 dg = tri3(bp*2.);\n        p += (dg+sin(iTime*4.+p*4. + cos(iTime+dg*50.))*.1*spd);\n\n        bp *= 1.8;\nz *= 1.5;\np *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n}\nreturn rz;\n}\n\nfloat posToFloat( vec3 p ){\n \n    float f = triNoise3D( p * .2, .1 );\n    return f;\n    \n}\n\n\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in vec2 m )\n{\n   // float an = 0.3 + 10.0*m.x;\n    \n    float an  = -iTime * .1 * 3.14159;\n   // vec3 pos1 = vec3(5.5*sin(an),(m.y - .5) * 4.,5.5*cos(an));\n    \n    vec3 pos1 = vec3( .1 , 3 , .1 );\n   \n   \tvec3 pos2 = vec3( 5.5 , 5 , 5 );\n    vec3 pos3 = vec3(5.5*sin(an), 2 ,5.5*cos(an));\n    \n    \n    float radius = 5.5 - 2. * (lightDispersing + finalPause)/2.;\n    vec3 pos4 = vec3(radius*sin(an), 2 ,radius*cos(an));\n    vec3 pos5 = vec3(radius*sin(an * 3. ), 1. ,radius*cos(an * 3.));\n    \n    camPos = mix( pos1 , pos2 , fadeIn );\n    camPos = mix( camPos , pos3 , lightExpanding * lightExpanding * lightExpanding );\n    camPos = mix( camPos , pos4 , (lightDispersing + finalPause)/2.  );\n    camPos = mix( camPos , pos5 , fadeOut  );\n    //camPos = pos2;\n    camTar = vec3(-0.05,0.0,0.0);\n}\n\n\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n\nvec2 opS( vec2 d1, vec2 d2 )\n{\n   return (-d1.x>d2.x) ? vec2( -d1.x , d1.y ) : d2;\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nvec2 smoothU( vec2 d1, vec2 d2, float k)\n{\n    float a = d1.x;\n    float b = d2.x;\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return vec2( mix(b, a, h) - k*h*(1.0-h), mix(d2.y, d1.y, pow(h, 2.0)));\n}\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \nreturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n \n\nvec2 prism( vec3 pos, float size ){\n    \n    pos -= vec3( 0., -.6 , 0. );\n    \n    float octDist = fOctahedron( pos  , size );\n    float planeDist = sdPlane( pos , vec4( 0., 1. , 0. , 0. ) );\n    \n    float dist = opS(  planeDist , octDist );\n    \n    return vec2( dist , 1. );\n    \n}\n\n\nvec4 grow = vec4( 1. );\n\nvec3 mapP( vec3 p )\n{\n    p.xyz += .1*sin(  (8.- lightDispersing* 3.)*p.zxy )*grow.x;\n    p.xyz += 0.20*sin((10.0- lightDispersing* 5.)*p.yzx)*grow.y ;\n    p.xyz += 0.2*sin(  12.0*p.yzx )*grow.z;\n    p.xyz += 0.10*sin( 23.0*p.yzx)*grow.w;\n    return p;\n}\n\n\nvec2 rotate(vec2 v, float a){\n\tfloat t = atan(v.y,v.x)+a;\n    float d = length(v);\n    v.x = cos(t)*d;\n    v.y = sin(t)*d;\n    return v;\n}\n\nvec2 goo( vec3 pos ){\n\n  \n    \n    vec3 nPos = mapP( pos - vec3(0., -.15 , 0.));\n    \n    difVal = length(nPos -( pos - vec3( -.5 , -.2 , 0.0) ));\n\n    float dist = length( nPos ) - (.01 + .6 * lightDispersing);\n    \n    \n    vec3 fPoint = (lightStartPoint - lightEndPoint) * lightExpanding + lightEndPoint;\n    vec2 res = opU( vec2( dist * .03 , 2.) ,vec2(sdCapsule( pos , fPoint , lightEndPoint , .01 ),3.));\n   \n    \n    \n   // dist = min( dist , 10. * sdCapsule( pos , vec3( 0. ), vec3( -4. , -1. , -4. ) , .02 ));\n    //dist = min( dist , 10. * sdCapsule( pos , vec3( 0. ), vec3( -4. , -1. , -4. ) , .02 ));\n\n    \n    return res;\n    \n    \n}\n\nvec2 lightMap( vec3 pos ){\n\n    \n   float dist =length( pos - lightPos ) - .3;\n    \n    return vec2( dist , 4. );\n    \n}\n\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos , float io ){  \n    vec2 idx =vec2(1.);\n   \n    vec2 crystal = prism( pos, prismSize );\n    vec2 flow = goo( pos   );\n    \n    if( io > 0. ){\n    \n    \treturn opU( crystal , flow);\n         \n        \n    }else{\n        \n        crystal.x = -crystal.x;\n        return opU( flow , crystal );\n      \n        \n    }\n    \n\n    \n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd  , in float io){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\nfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n  vec2 m = map( ro+rd*t , io );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax , float io )\n{\nfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<10; i++ )\n    {\nfloat h = map( ro + rd*t , io).x;\n        res = min( res, 20.*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor , float io )\n{\nfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.612*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos , io).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.5;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n#define STEPS 10\nvec3 fogCube( vec3 ro , vec3 rd , vec3 n ){\n \n    float lum = 1.;\n    \n    vec3 col = vec3( 0. );\n    for( int i = 0; i < STEPS; i++ ){\n        vec3 p = ro + rd * .1  * float( i );\n\n        lum += triNoise3D( p * .5 , 1.2);// + sin( p.y * 3. ) + sin( p.z * 5.);\n    \n       //\tcol += hsv( lum / 10. + .8 , 1. , 1. ) * ( float(STEPS) - float(i)) / float(STEPS) * lum;\n        \n        col += vec3( .2 , 0. , 0.2) * lum * lum * lum * 1. / (float( i)+1.);\n    }\n    \n    return col/float(STEPS);\n    \n    \n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos , in float io ){\n    \nvec3 eps = vec3( 0.001, 0.0, 0.0 );\nvec3 nor = vec3(\n   map( pos+eps.xyy , io ).x - map( pos-eps.xyy , io ).x,\n   map( pos+eps.yxy , io ).x - map( pos-eps.yxy , io ).x,\n   map( pos+eps.yyx , io ).x - map( pos-eps.yyx , io ).x );\nreturn normalize(nor);\n}\n\n\nvec3 noiseNormal( vec3 pos ){\n return normalize( vec3(hash(pos.x) , hash( pos.y ), hash( pos.z) ) );  \n}\n\n\n\n\nvec3 doGooCol( vec3 p , vec3 n , float id , float io ){\n  \n    vec3 lightDir = normalize(lightPos - p);\n    \n    float match = dot( lightDir , n );\n    float ao = calcAO( p , n , io );\n    \n    vec3 fNorm = normalize(noiseNormal( p * 100. ) + n);\n   \tvec3 refl = reflect( lightDir , n );\n    \n    float rMatch = dot( refl , camDir );\n    \n\n    \n    float v = length( p - vec3( 0. ) );\n    \n  \tvec3 rb = hsv( difVal * .4 + .9 , .9 , .8 );\n    \n    vec3 col = match *  vec3( 1. );\n    if( io > 0. ){\n       col *= n * .5 + .5; \n       col *= hsv( rMatch * rMatch * rMatch * 2. , .5 , 1. );\n      // col *= rb;\n       if( id == 3.){ col = vec3(1.); }\n    }else{\n     col = vec3( 1. * (1. -ao) * match );   \n        \n    }\n    \n  \n   return col; //vec3( 1. * io ) * n * .5 + .5; \n}\n\nvec3 doBGCol( vec3 p  ){\n float n =  triNoise3D( p * .1 , .3 );\n return vec3(n*n ) * 3.4;   \n}\n\n\n\nvec3 thirdTrace(vec3 p , vec3 rd ){\n    vec2 res = calcIntersection( p + rd * .01 , rd , 1. );\n    \n    vec3 col;\n    \n    if( res.y < -.5){\n    \tcol = doBGCol( p +rd * 2.);   \n    }else{\n        \n      \tvec3 p2 = p + rd *(res.x+ .01);\n    \tvec3 n = calcNormal( p2 , 1. );\n        col = doGooCol( p2 , n , res.y , 1. );\n        \n    }\n    \n    return col;\n    \n}\n\nvec3 secondTrace( vec3 p , vec3 rd , float ior ){\n \n    vec2 res = calcIntersection( p + rd * .01 , rd , -1. );\n    \n    vec3 col;\n    \n    vec3 p2 = p + rd *(res.x+ .01);\n    vec3 n = calcNormal( p2 , -1. );\n    \n    if( res.y == 2. ){\n       \n    \t\n        col = doGooCol( p2 , n , res.y , -1. ); //n * .5 + .5;\n        \n        \n    }else{\n        \n        vec3 refr = refract( rd , n , ior );\n        vec3 fPos = p2 + refr * 2.;\n        col = thirdTrace( p2 , refr ); \n        \n        \n    }\n    \n    return col;\n    \n    \n}\n\n\nvec3 doSecondColor( vec3 rd , vec3 p , vec3 n  ){\n    \n    float ior = .9;\n    float dRay = .01;\n    //First break it into rays\n    \n    vec3 rR = refract( rd , n , ior + dRay );\n    vec3 rG = refract( rd , n , ior );\n    vec3 rB = refract( rd , n , ior - dRay );\n    \n    vec3 col;\n    \n    vec3 colR = secondTrace( p , rR , ior + dRay  );\n    vec3 colG = secondTrace( p , rG , ior);\n    vec3 colB = secondTrace( p , rB , ior - dRay );\n\n    return colR * vec3( 1. , 0., 0.) + colG * vec3( 0. , 1., 0.)+ colB* vec3( 0. , 0., 1.);\n    \n    return col ;\n    \n    \n}\n\n\nvec3 doCol( float id , vec3 p , vec3 n ){\n    \n    vec3 lightDir = lightPos - p;\n    \n    float match = dot( normalize( lightDir ) , n );\n    float ao = calcAO( p , n , 1. );\n    \n    if( id < 1.95 ){\n    \tvec3 c =  doSecondColor( camDir , p , n );\n        return c; //vec3( 1. , 0.,  0.);\n        \n    }else{\n     return doGooCol( p , n , id , 1. );// - (n * .5 + .5);     \n    }\n    \n}\n\n\n\n// box rendering for title at end\nfloat inBox( vec2 p , vec2 loc , float boxSize ){\n \t\n    if( \n        p.x < loc.x + boxSize / 2. &&\n        p.x > loc.x - boxSize / 2. &&\n        p.y < loc.y + boxSize / 2. &&\n        p.y > loc.y - boxSize / 2. \n    ){\n        \n     return 1.;  \n        \n    }\n   \n    return 0.;\n     \n}\n\n\n\n\nvec2 getTextLookup( float lu ){\n    \n    float posNeg = abs( lu ) / lu;\n    \n    float x = floor( abs( lu ) / 100. );\n    float y = abs( lu ) - (x * 100.);\n    \n    y = floor( y / 10. );\n    y *= ((abs( lu ) - (x * 100.) - (y * 10. )) -.5) * 2.;\n    \n    return vec2( x * posNeg , y  );\n    \n}\n\n\nfloat impact( vec2 p  ){\n  \n\n    float f = 0.;\n    \n    for( int i = 0; i < 53; i++ ){\n    \t\n\n            float size = 10.;\n            vec2 lu = getTextLookup( impactLU[ i ] - 100. )* size;\n            f += inBox( p , vec2( iResolution / 2. ) + lu , size );       \n            \n\n \n    } \n    \n    return f;\n    \n    \n}\n\n\n\n\n\n\nvoid setUpStoryVars(){\n \n    \n    float totalTime = fadeInTime + lightExpandingTime + lightDispersingTime +finalPauseTime + fadeOutTime + endPauseTime;\n    float t = mod( iTime , totalTime );\n    \n    fadeIn = clamp( t / fadeInTime , 0. , 1. );\n    lightExpanding = clamp( (t- fadeInTime) / lightExpandingTime , 0. , 1. );\n    lightDispersing = clamp( (t - fadeInTime- lightExpandingTime ) / lightDispersingTime , 0. , 1. );\n    \n    \n    finalPause = clamp( (t - fadeInTime - lightExpandingTime - lightDispersingTime ) / finalPauseTime , 0. ,1.);\n\n    \n    fadeOut = clamp( (t - fadeInTime - lightExpandingTime - lightDispersingTime - finalPauseTime ) / fadeOutTime , 0. ,1.);\n    fadeOut = fadeOut;\n    \n    endPause = clamp( (t - fadeInTime - lightExpandingTime - lightDispersingTime - finalPauseTime -fadeOutTime ) / endPauseTime , 0. ,1.);\n\n    \n    INTERSECTION_PRECISION = .0001 + .008 * finalPause + .04 * fadeOut + .1 * endPause;\n    \n    grow = vec4( 0. ) + vec4( 1. ) * lightDispersing + vec4( 1. , 0.5 , .5 , 0.5 ) * finalPause;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // 1000 and 100 are the x positions\n    // 10 is y position\n    // 1 is y sign\n \n    \n    \n\n    \n    // P\n    impactLU[0] = -821.;\n\timpactLU[1] = -811.;\n\timpactLU[2] = -801.;\n\timpactLU[3] = -810.;\n\timpactLU[4] = -820.;\n\n\timpactLU[5] = -621.;\n\timpactLU[6] = -611.;\n\timpactLU[7] = -601.;\n    \n \n    impactLU[8] = -701.;\n    \n    // R\n    impactLU[9]  = -421.;\n\timpactLU[10] = -411.;\n\timpactLU[11] = -401.;\n\timpactLU[12] = -410.;\n\timpactLU[13] = -420.;\n\n\timpactLU[14] = -221.;\n\timpactLU[15] = -211.;\n\timpactLU[16] = -201.;\n    \n    \n    // I\n    impactLU[17] = -021.;\n\timpactLU[18] = -011.;\n\timpactLU[19] = -000.;\n\timpactLU[20] = -010.;\n\timpactLU[21] = -020.;\n    \n    // s\n    impactLU[22] = 221.;\n    impactLU[23] = 321.; \n    impactLU[24] = 421. ;\n    \n    impactLU[25] = 201.;\n    impactLU[26] = 301.; \n    impactLU[27] = 401. ;\n    \n    impactLU[28] = 220.;\n    impactLU[29] = 320.; \n    impactLU[30] = 420. ;\n    \n\timpactLU[31] = 211. ;\n\timpactLU[32] = 410. ;\n    \n    \n    // M\n    impactLU[33] = 621.;\n\timpactLU[34] = 611.;\n\timpactLU[35] = 601.;\n\timpactLU[36] = 610.;\n\timpactLU[37] = 620.;\n\n    impactLU[38] = 821.;\n\timpactLU[39] = 811.;\n\timpactLU[40] = 801.;\n\timpactLU[41] = 810.;\n\timpactLU[42] = 820.;\n    \n    impactLU[43] = 1021.;\n\timpactLU[44] = 1011.;\n\timpactLU[45] = 1001.;\n\timpactLU[46] = 1010.;\n\timpactLU[47] = 1020.;\n    \n    impactLU[48] = 721.;\n    impactLU[49] = 921.;\n    \n\n  \t//extra hooks cuz im lazy\n\timpactLU[51] = -721.;\n    impactLU[52] = -321.;\n\n    \n\n\n\nvec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    setUpStoryVars();\n    \n  \n    \n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,4.) ); // 2.0 is the lens length\n    \n    camDir = rd;\n    \n    vec2 res = calcIntersection( ro , rd , 1.  );\n\n\n    vec3 col = vec3( 0.);\n    \n\tfloat imp = impact( fragCoord.xy  );\n    \n    if( res.y > -.5 ){\n        \n        vec3 pos = ro + rd * res.x;\n        vec3 norm = calcNormal( pos , 1. );\n       \n \t\t\n        col = doCol( res.y , pos , norm );\n        \n        \n    }else{\n        \n       vec3 c = doBGCol( ro + rd * 2. );\n       col = vec3(0.);// vec3(1.)*c * c*c * 5.; \n        \n    }\n\tcol = pow( col, vec3(.792545) );\n    \n    \n    col = mix( vec3(0.) , col , fadeIn );\n    if( fadeOut > 0.){\n    vec3 titleCol =  vec3( imp ) * col * 2. * ((1.-endPause) * fadeIn);\n\n    col = mix( col , titleCol , fadeOut );\n    \n    }\n    \n    float totalTime = fadeInTime + lightExpandingTime + lightDispersingTime +finalPauseTime + fadeOutTime + endPauseTime;\n  \n    if( iTime > totalTime ){\n        col = vec3( 0. );\n    }\n\n\n    fragColor = vec4( col , 1. );\n\n\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"XsfGRr","channel":0}],"code":"// @johnnyscript, @folksatck\n\n\nfloat tau = 6.2841;\nconst float WARMUP = 2.8;\n\n\n\nfloat fadeIn = 0.;\nfloat fadeInTime = 2.;\nfloat lightExpanding= 0.;\nfloat lightExpandingTime = 3.;\nfloat lightDispersing= 0.;\nfloat lightDispersingTime = 3.;\n\nfloat finalPause = 0.;\nfloat finalPauseTime = 3.;\n\nfloat fadeOut= 0.;\nfloat fadeOutTime = 6.;\n\nfloat endPause = 0.;\nfloat endPauseTime = 6.;\n\n\nfloat standard(float x){\n\treturn pow(exp(1.), -1./2. * pow(x, 2.)) / tau;\n}\n\nfloat general(float x, float u, float s){\n\treturn (1. / s) * standard(x - u) / s;\n}\n\n\nfloat sine(float t, float f){\n    float m = 1. / f;\n\treturn sin(mod(t, m) * tau * f);\n}\n\nfloat tri(float t, float f){\n    float m = 1. / f;\n    return abs(1. - mod(mod(t,m), (1./f)) * f * 2.) * 2. - 1.;\n}\n\nfloat overtone(float t, float f, float u, float s, float m, int i){\n\tfloat x = 1.;\n    float y = 0.;\n    int z = 7;\n    for(int ii = 0; ii <= 11; ii++){\n        float g = general(x, u, s);\n    \ty += sine(t, x * f) * g;\n        x *= pow(2., m);\n    }\n    return y;\t\n}\n\nfloat quant(float v, float q){\n  return floor(v/q)*q;\n}\n\nfloat amod(float t, float c, float r, float f){\n\treturn c + (r * sine(t, f));\n}\n\n\nvoid setUpStoryVars( float time ){\n \n    \n    float totalTime = fadeInTime + lightExpandingTime + lightDispersingTime +finalPauseTime + fadeOutTime + endPauseTime;\n    float t = mod( time  , totalTime );\n    \n    fadeIn = clamp( t / fadeInTime , 0. , 1. );\n    lightExpanding = clamp( (t- fadeInTime) / lightExpandingTime , 0. , 1. );\n    lightDispersing = clamp( (t - fadeInTime- lightExpandingTime ) / lightDispersingTime , 0. , 1. );\n    \n    \n    finalPause = clamp( (t - fadeInTime - lightExpandingTime - lightDispersingTime ) / finalPauseTime , 0. ,1.);\n\n    \n    fadeOut = clamp( (t - fadeInTime - lightExpandingTime - lightDispersingTime - finalPauseTime ) / fadeOutTime , 0. ,1.);\n    fadeOut = fadeOut;\n    \n    endPause = clamp( (t - fadeInTime - lightExpandingTime - lightDispersingTime - finalPauseTime -fadeOutTime ) / endPauseTime , 0. ,1.);\n\n    \n}\n\n\n\nfloat laserSound( float time ){\n    \n            \n \tfloat t = time;// + 8. + 24.;\n    float tone = overtone(t, 11111., amod(t, 0., tau / 32., 512.), sqrt(4.), 1./2., 11);\n    float amp = 111. * amod(t, amod(t, 1.25, .05, amod(t, 9., 6., 1./36.)), .125, 24.);\n\n    \n    float s = tone * amp;\n        \n    s *= fadeIn;\n    s *= 1. - min( 1. , lightExpanding * 100. );\n    \n    return s;\n}\n\nfloat growSound( float time ){\n    \n    \n \tfloat t = time;// + 8. + 24.;\n    float tone = overtone(t, amod(t, 11100., -9499., 1./28.), amod(t, 0., tau / 8., 256.), sqrt(4.), 1./8., 11);\n\n    float amp = 111. * amod(t, amod(t, .25, .05, amod(t, 9., 6., 1./36.)), .125, 1./32.);\n\n    \n    float s = quant(tone *  amp, 1./28.);\n       \n    s *= min( 1. , lightExpanding * 1000.);\n    s += tri( t , 1220. ) * lightExpanding; \n  \n    \n    s *= 1. - min( 1. , finalPause * 10. );\n    \n    s += sin( time );\n    \n    return s;\n    \n}\n\nfloat disperseSound( float t ){\n    \n    float tone = overtone(t, amod(t, 11100. - 10550. + 33.3333, -33.3333, 1./16.7), amod(t, 0., tau, 1./256.), sqrt(7.), 1./3., 11);\n\n    float amp = 111. * amod(t, amod(t, .25, .05, amod(t, 9., 6., 1./32.)), 3., 1./128.);\n\n    \n    float s = quant(tone *  amp, 1./56.);\n    \n    s *= lightDispersing;\n    s *= 1. - min( 1. , fadeOut * 13. );\n    \n    return s;\n    \n}\n\nfloat titleSound( float t ){\n\n    float tone = overtone(t, 555., amod(t, 0., tau / 2., amod(t, 2., 12., 1./48.)), sqrt(15.), 2., 11);\n\n    float amp = 111. * amod(t, amod(t, .25, .05, amod(t, 9., 6., 1./36.)), .125, 1./24.);\n\n    \n    float s = (quant(tone, 1./48.) *  amp);\n    \n    s *= finalPause;\n    //s *= 1. - min( 1. , finalPause * 10. );\n    \n    return s;\n    \n}\n\nvec2 mainSound( in int samp, float time )\n{\n    \n    \n    float t = time - WARMUP;\n    float tt = t + 48.;\n    \n    \n    setUpStoryVars( t );\n    \n    //t = mod( t , 10. );\n\n        \n \t//float t = time + 8. + 24.;\n    float tone = overtone(t, 333., 1., sqrt(4.)/amod(t, 4., 4., -1./24.), 7./12., 7);\n    float amp = amod(t, amod(t, .25, .05, amod(t, 9., 6., 1./36.)), .125, 1./24.);\n    //return vec2((quant(tone, 1./amod(t, 48., 36., -1./24.)) *  amp));\n    \n    \n    float lS = laserSound( tt );\n    float gS = growSound( tt );\n    float dS = disperseSound( tt );\n    float tS = titleSound( tt );\n    \n    \n    float totalTime = fadeInTime + lightExpandingTime + lightDispersingTime +finalPauseTime + fadeOutTime + endPauseTime;\n  \n    vec2 sound = vec2( lS + gS + dS + tS ) * max( 0., (1. - endPause * 10.));\n    if( time > totalTime ){\n        sound = vec2( 0. );\n    }\n\n    \n    return sound * .01;\n    \n    \n    \n    \n}","name":"Sound","description":"","type":"sound"}]}