{"ver":"0.1","info":{"id":"NsSBRd","date":"1648195419","viewed":36,"name":"AW-MARTJORI-3D","username":"Joris_MARTIN","description":"Roullette anglaise","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["iut2aw3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define DIST_MIN 0.5 // minimum distance to objects\n#define DIST_MAX 30.0 // maximum distance to objects\n#define RAY_MARCH_STEPS 100\n#define RAY_MARCH_PRECI 0.001\n#define PI 3.14159265359\n\n#define KEY_LEFT 37;\n#define KEY_UP 38;\n#define KEY_RIGHT 39;\n#define KEY_DOWN 40;\n\n// Stucture pour les rayons\nstruct Ray {\n    vec3 o; // Origine\n    vec3 d; // Direction\n};\n\n// structure pour les surfaces\nstruct Surface {\n    float t; // surface distance\n    vec3 c; // surface color\n};\n\nSurface base = Surface(1e10, vec3(0.29, 0.55, 0.));\n\n// Retourne le surface la plus proche\nSurface surfaceMin(Surface s1, Surface s2)\n{\n   if (s1.t<s2.t) {\n       return s1;\n   }\n   else {\n       return s2;\n   }\n}\n\n/**\n    MANIPULATION SCÈNE 2D\n*/\nvec2 translate(in vec2 p, in vec2 t) {\n    return p - t;\n}\n\nvec2 scale(in vec2 p, in vec2 f) {\n    return p*f;\n}\n\nvec2 rotate(in vec2 p, in float a) {\n    float ca = cos(a);\n    float sa = sin(a);\n\n    return vec2(ca*p.x-sa*p.y, sa*p.x+ca*p.y);\n}\n\n/**\n    OPÉRATEUR SUR LES FONCTIONS DE DISTANCES\n*/\nfloat substract(float sd1,float sd2) {\n    return max(sd1,-sd2);\n}\n\nfloat add(float sd1,float sd2) {\n    return min(sd1,sd2);\n}\n\nfloat intersect(float sd1,float sd2) {\n    return max(sd1,sd2);\n}\n\n\n/*\n    FONCTIONS DE DISTANCES\n*/\n\n// 2D\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat sdHeart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\n\nfloat sdRoundedCross( in vec2 p, in float h )\n{\n    float k = 0.5*(h+1.0/h); // k should be const at modeling time\n    p = abs(p);\n    return ( p.x<1.0 && p.y<p.x*(k-h)+h ) ? \n             k-sqrt(dot2(p-vec2(1,k)))  :\n           sqrt(min(dot2(p-vec2(0,h)),\n                    dot2(p-vec2(1,0))));\n}\n\nfloat sdEgg( in vec2 p, in float ra, in float rb )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x);\n    float r = ra - rb;\n    return ((p.y<0.0)       ? length(vec2(p.x,  p.y    )) - r :\n            (k*(p.x+r)<p.y) ? length(vec2(p.x,  p.y-k*r)) :\n                              length(vec2(p.x+r,p.y    )) - 2.0*r) - rb;\n}\n\n// Constante dimension d'une carte\nvec2 cardDim = vec2(0.5, 1.);\n\n// Carte Coeur\nSurface heartCard( in vec2 p ) \n{\n    float b = sdBox(p, cardDim);\n    \n    vec2 newP = scale(p+vec2(0.,0.5), vec2(2., 1.2));\n    float h = sdHeart(newP);\n    \n    b = substract(b, h);\n    \n    if (b<0.) return Surface(b, vec3(1.));\n    else if (h<0.) return Surface(h, vec3(1., 0., 0.));\n    else return base;\n    \n}\n\n// Carte Carreau\nSurface tileCard( in vec2 p ) \n{\n\n    float b = sdBox(p, cardDim);\n    \n    vec2 newP = scale(p+vec2(0.,0), vec2(2., 1.5));\n    float r = sdRhombus(newP, vec2(0.5, 1.));\n    \n    b = substract(b, r);\n    \n    if (b<0.) return Surface(b, vec3(1.));\n    else if (r<0.) return Surface(r, vec3(1., 0., 0.));\n    else return base;\n    \n}\n\n// Carte Pique\nSurface pikCard( in vec2 p ) \n{\n\n    float b = sdBox(p, cardDim);\n    \n    vec2 newP = rotate(p, PI);\n    newP = scale(newP+vec2(0.,0.6), vec2(2., 1.2));\n    \n    float h = sdHeart(newP);\n    \n    vec2 bottomP = p + vec2(0., 0.7);\n    float bottom = sdRoundedCross(bottomP*vec2(3., 1.), 2.);\n    \n    float subRectToBottom = sdBox(p+vec2(0., 0.9), vec2(0.5, 0.3));\n    bottom = substract(bottom, subRectToBottom);\n    \n    h = add(h, bottom);\n    b = substract(b, h);\n    \n    if (b<0.) return Surface(b, vec3(1.));\n    else if (h<0.) return Surface(h, vec3(0.));\n    else return base;\n    \n}\n\n// Carte Pique\nSurface trefleCard( in vec2 p ) \n{\n\n    float b = sdBox(p, cardDim);\n    \n    \n    vec2 newP = rotate(p, PI);\n    \n    \n    // Première feuille\n    newP = scale(newP+vec2(0., 0.4), vec2(5., 2.));\n    float egg = sdEgg(newP, 0.6, 0.);\n    \n    // 2ème feuille\n    newP = rotate(p, PI/2.);\n    newP = scale(newP+vec2(-0.1, 0.2), vec2(2., 5.));\n    egg = add(egg, sdEgg(newP, 0.6, 0.));\n    \n    // 3ème feuille\n    newP = rotate(p, PI+PI/2.);\n    newP = scale(newP+vec2(0.1, 0.2), vec2(2., 5.));\n    egg = add(egg, sdEgg(newP, 0.6, 0.));\n    \n    // Bottom part\n    vec2 bottomP = p + vec2(0., 0.8);\n    float bottom = sdRoundedCross(bottomP*vec2(3., 0.8), 2.);\n    \n    float subRectToBottom = sdBox(p+vec2(0., 1.1), vec2(0.5, 0.4));\n    bottom = substract(bottom, subRectToBottom);\n    \n    egg = add(egg, bottom);\n    \n    b = substract(b, egg);\n    \n    if (b<0.) return Surface(b, vec3(1.));\n    else if (egg<0.) return Surface(egg, vec3(0.));\n    else return base;\n    \n}\n\n// 3D\n\nfloat sdSphere(in vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdSolidAngle(vec3 p, vec2 c, float ra)\n{\n  // c is the sin/cos of the angle\n  vec2 q = vec2( length(p.xz), p.y );\n  float l = length(q) - ra;\n  float m = length(q - c*clamp(dot(q,c),0.0,ra) );\n  return max(l,m*sign(c.y*q.x-c.x*q.y));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n  // sampling independent computations (only depend on shape)\n  float w = sqrt(r*r-h*h);\n  \n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                          abs(length(q)-r) ) - t;\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n// Base roulette\nSurface baseRoulette(in vec3 p)\n{\n    vec3 pCopy = p;\n\n    // Définition des couleurs\n    vec3 red = vec3(1. ,0., 0.);\n    vec3 black = vec3(0.);\n    vec3[] COLORS = vec3[2](red, black);\n    \n    int NB_CASE = 37;\n    \n    float dCase = 1e10;\n    vec3 color = vec3(0.);\n    \n    float angle = (360./float(NB_CASE))*PI/180.;\n    float miAngle = angle/2.;\n    \n    for (int i=0; i<NB_CASE-1; i++) {\n        \n        float d = udTriangle(\n            pCopy,\n            vec3(0., 0., 0.), \n            vec3(cos(angle-miAngle), 0., sin(angle-miAngle)), \n            vec3(cos(angle+miAngle), 0., sin(angle+miAngle))\n        );\n        \n        if (d < dCase) {\n            dCase = d;\n            color = COLORS[int(mod(float(i), 2.))];\n        }\n        \n        vec2 rotatedP = rotate(vec2(pCopy.x, pCopy.z), angle);\n        pCopy = vec3(rotatedP.x, pCopy.y, rotatedP.y);\n    }\n    \n    // Ajout de la partie verte\n    float d = udTriangle(\n        pCopy,\n        vec3(0., 0., 0.), \n        vec3(cos(angle-miAngle), 0., sin(angle-miAngle)), \n        vec3(cos(angle+miAngle), 0., sin(angle+miAngle))\n    );\n\n    if (d < dCase) {\n        dCase = d;\n        color = vec3(0., 1., 0.);\n    }\n    \n    return Surface(dCase, color);\n}\n\n// Définition de la scène\nSurface scene(in vec3 p) \n{\n    p = vec3(p.x, p.y-0.3, p.z);\n    \n    // Fait tourner la scene sur l'axe Y\n    vec2 rot = rotate(vec2(p.x, p.z), iTime*2.);\n    vec3 pRotate = vec3(rot.x, p.y, rot.y);\n    \n    // Base (carreaux)\n    Surface s = baseRoulette(pRotate);\n    \n    // Anneau Jaune\n    Surface anneau = Surface(\n        sdRoundedCylinder(pRotate, 0.43, 0.01, 0.01),\n        vec3(1., 1., 0.)\n    );\n    \n    s = surfaceMin(s, anneau);\n    \n    // Disque noir\n    Surface disk = Surface(\n        sdRoundedCylinder(pRotate, 0.40, 0.01, 0.01),\n        vec3(0.)\n    );\n    \n    s = surfaceMin(s, disk);\n    \n    // Barre verticale\n    float bar = sdVerticalCapsule(pRotate, 0.4, 0.1);\n    \n    // Lozange\n    float loz = sdOctahedron(pRotate-vec3(0., 0.35, 0.), 0.25);\n    \n    // Addition de la bare et du lozange\n    Surface xCross = Surface(add(bar, loz), vec3(1., 1., 0.));\n    \n    s = surfaceMin(s, xCross);\n    \n    // cup\n    Surface cup = Surface(\n        sdCutHollowSphere(p, 1., 0.1, 0.01),\n        vec3(0.3)\n    );\n    \n    s = surfaceMin(s, cup);\n    \n    // Roation de la boule sur Y dans l'autre sens\n    vec2 bouleRot = rotate(vec2(p.x, p.z), -iTime*4.);\n    Surface boule = Surface(\n        sdSphere(vec3(bouleRot.x, p.y, bouleRot.y)-vec3(0.92,0.05, 0.), 0.05),\n        vec3(1.)\n    );\n    \n    s = surfaceMin(s, boule);\n    \n    return s;\n}\n\nSurface fond (in vec2 p) \n{\n\n    Surface s = base;\n    \n    float i = 0.;\n    float x = -4.;\n    while (x <= 4.) {\n        float y = -4.;\n        while (y <= 4.) {\n        \n            float sens = (mod(x, 2.) == 0.) ? -iTime : iTime;\n            //sens = mod(sens, \n            //vec2 coords = p+vec2((x*1.1)*cos(iTime), (y*2.2)*cos(iTime));\n            //vec2 coords = p+vec2((x*1.1), (y*2.2)+sens*2.);\n            \n            vec2 coords = p+vec2(x*1.1, y*2.2);\n            \n            Surface[] cards = Surface[4](\n                tileCard(coords),\n                pikCard(coords),\n                heartCard(coords),\n                trefleCard(coords)\n            );\n            \n            Surface newS = cards[int(mod(i, 4.))];\n            s = surfaceMin(s, newS);\n            y++;\n            i++;\n        }\n        x++;\n    }\n    \n    return s;\n}\n// Fonction lancant le rayon et testant si le rayon touche\nSurface march(in Ray r)\n{\n    float t = DIST_MIN;\n\n    for(int i=0;i<RAY_MARCH_STEPS,t<=DIST_MAX;++i) {\n        Surface s = scene(r.o+t*r.d);\n\n        if(s.t<RAY_MARCH_PRECI) {\n            return Surface(t+s.t,s.c);\n        }\n\n        t = t+s.t;\n    }\n\n    return Surface(DIST_MAX,vec3(0.3));\n}\n\n// Fonction calculant la normal a une surface\nvec3 normalAt(in Surface s,in Ray r) {\n    const float e = 0.01;\n    vec3 p = r.o+s.t*r.d;\n    float nx = scene(vec3(p.x+e,p.y,p.z)).t-scene(vec3(p.x-e,p.y,p.z)).t;\n    float ny = scene(vec3(p.x,p.y+e,p.z)).t-scene(vec3(p.x,p.y-e,p.z)).t;\n    float nz = scene(vec3(p.x,p.y,p.z+e)).t-scene(vec3(p.x,p.y,p.z-e)).t;\n\n    return normalize(vec3(nx,ny,nz));\n}\n\nRay camRay(in vec2 p) {\n    // p is the current pixel coord, in [-5,5]\n\n    // normalized mouse position\n    vec2 m = iMouse.xy/R.y;\n    \n    // camera position\n    float DP = 11.;\n    float d = DP/4.;\n    //vec3 camPos = vec3(d*cos(6.0*m.x),DP/5.0,d*sin(6.0*m.x));\n    vec3 camPos = vec3(1.2, 1., 0.);\n\n    // target point\n    vec3 target = vec3(0.0,0.0,0.0);\n\n    // camera view vector\n    vec3 camView = normalize(target-camPos);\n\n    // camera up vector (temporary)\n    vec3 cp = vec3(0.0,1.0,0.0);\n\n    // camera right vector\n    vec3 cu = normalize(cross(camView,cp));\n\n    // camera (normalized) up vector\n    vec3 cv = normalize(cross(cu,camView));\n    \n    float fovDeg = 45.;\n    float fovRad = (fovDeg/360.)*2.*PI;\n    float zf = 1./tan(fovRad/2.);\n    \n    // view vector, including perspective (the more you multiply camView, the less fovy)\n    vec3 rd = normalize(p.x*cu + p.y*cv*(R.y/R.x) + 2.*camView);\n\n    return Ray(camPos,rd);\n}\n\nvec3 shade(in Surface surf, in Ray ray, in vec3 lumPos) {\n    // tous les vecteurs nécessaires au shading\n    vec3 n = normalAt(surf,ray);\n    vec3 l = normalize(lumPos);\n    vec3 v = ray.d;\n    vec3 r = reflect(l,n);\n    \n    // parametres du materiau\n    vec3 kd = surf.c;\n    vec3 ks = vec3(0.8);\n    float s = 20.;\n    \n    // coeficients diffus et spéculaires\n    float diff = max(dot(n,l),0.);\n    float spec = pow(max(dot(r,v),0.),s);\n    \n    return kd*diff + ks*spec;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Définition du repère entre -5 et 5\n    vec2 uv = (fragCoord / R.xy)*10.-5.;\n    \n    // Création du rayon\n    Ray ray = camRay(uv);\n    Surface s = march(ray);\n    \n    vec3 c = s.c;\n    \n    if(s.t<DIST_MAX) {\n    \n        vec3 lumPos = vec3(2.*cos(iTime), 1.5, 2.*sin(iTime));\n    \n        c = shade(s,ray, lumPos);\n        \n        // Nouveau rayon pour l'ombre.\n        vec3 newRo = ray.o + (ray.d * s.t);\n        \n        vec3 vecToLum = normalize(lumPos-newRo);\n        \n        Ray rOmbre = Ray(newRo + vecToLum*0.0001, vecToLum);\n        Surface o = march(rOmbre);\n        \n        if (o.t<DIST_MAX) {\n           c = c*0.4;\n        }\n    } else {\n        s = fond(uv);\n        c = s.c;\n    }\n    \n    fragColor = vec4(c,1.);\n}","name":"Image","description":"","type":"image"}]}