{"ver":"0.1","info":{"id":"MXsyWB","date":"1730473001","viewed":306,"name":"Spheres with pathtracing","username":"morimea","description":"Alot of spheres with pathtracing for very simple lighting/shadows.\n\n","likes":20,"published":3,"flags":48,"usePreview":0,"tags":["procedural","3d","raytracing","grid","spheres","rectangle","pathtracer"],"hasliked":0,"parentid":"dldGWj","parentname":"TEMPLATE 3d pathtracer TAA"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Created by Danil (2024+) https://github.com/danilw\n// https://mastodon.gamedev.place/@danil\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// self https://www.shadertoy.com/view/MXsyWB\n\n\n// if you look for templates - look\n// https://danilw.github.io/blog/my_shader_templates_list/\n\n\n\n// CONTROL:\n// Mouse left-right speed\n// Mouse up-down view\n\n\n\n// using\n// https://iquilezles.org/articles/intersectors/\n// palette from iq https://www.shadertoy.com/view/ll2GD3\n// rectangle voxels from Shane https://www.shadertoy.com/view/sslfz7\n// TAA from gelami https://www.shadertoy.com/view/DsfGWX\n\n\n\n// for ULTRA-WIDE monitors\n// uncomment define ULTRA_WIDE_RES_LOOPS in Common\n\n\n\n\n\n#ifdef use_dynamic_TAA\n#ifdef enable_volume\n// from https://www.shadertoy.com/view/Xltfzj\nvec4 GaussianBlur(in vec2 fragCoord, sampler2D ich)\n{\n    float Directions = 6.0;\n    float Quality = 3.0;\n    float Size = 3.0;\n    vec2 Radius = Size/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 Color = texture(ich, uv);\n    for( int i=0; i<int(Directions); i++)\n    {\n        float d=float(i)*TAU/Directions;\n\t\tfor(int j=0; j<int(Quality); j++)\n        {\n            float ti=1.0/Quality+float(j)*1.0/Quality;\n\t\t\tColor += textureLod( ich, uv+vec2(cos(d),sin(d))*Radius*ti, 0.);\t\n        }\n    }\n    Color /= Quality * Directions+1.;\n    return Color;\n}\n#endif\n#endif\n\n// volume raymarch mix color\n//----------------------------------------------\n#ifdef enable_volume\n\nvec3 raymarchVolume_image(vec3 backGround, float absorb, vec3 sunColor, float lDotV, float fogLitPercent){\n    \n    float phaseMie = hGPhase(lDotV, 0.8);\n    \n    vec3 c_fogColorLit = backGround+sunColor * phaseMie*0.5+0.0005*(0.5+sunColor*0.5);\n    const vec3 c_fogColorUnlit = vec3(0.);\n    \n    vec3 fogColor = mix(c_fogColorUnlit, c_fogColorLit, fogLitPercent*fogLitPercent*fogLitPercent);\n    return mix(fogColor, backGround, absorb);\n}\n#endif\n//----------------------------------------------\n\nvec3 ACESFilm(vec3 x);\nvec3 srgb_encode (vec3 v);\nvec3 color2agx(vec3 col);\nvec3 linearTosRGB(vec3 col)\n{\n    return mix(1.055 * pow(col, vec3(1.0 / 2.4)) - 0.055, col * 12.92, lessThan(col, vec3(0.0031308)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float timerl = load(TIMER_L, iChannel0);\n    lightDir.xz = lightDir_0.xz*MD(-3.1415926*2.*(1./75.)*(40.+timerl*0.06));\n    lightDir.y=lightDir_0.y+.5*(0.5+0.5*sin(22.*3.1415926*(1./75.)*(40.+timerl*0.06)));\n    lightDir = normalize(lightDir);\n    vec2 fc = fragCoord.xy;\n    vec3 texture_color = vec3(1.);\n#ifdef use_dynamic_TAA\n    vec3 color = texelFetch(iChannel3, ivec2(fc), 0).rgb;\n#else\n    vec3 color = texelFetch(iChannel2, ivec2(fc), 0).rgb;\n#ifdef enable_textures\n    texture_color = unpack_Unormfloat3x10(texelFetch(iChannel2, ivec2(fc), 0).a);\n#endif\n#endif\n\n#ifndef enable_textures\n#ifdef enable_volume\n    \n    // unjittering volume fog\n    vec2 halton_px_shift = vec2(load(HALTON0,iChannel0),load(HALTON1,iChannel0));\n    if(load(INPUT0,iChannel0)<1.) halton_px_shift =vec2(0.);\n    \n#ifdef use_dynamic_TAA\n    //float absorb = texelFetch(iChannel3, ivec2(fc), 0).a;\n    float absorb = GaussianBlur(fc, iChannel3).a; //additional Blur on top of TAA\n    float fogLitPercent = GaussianBlur(fc-halton_px_shift, iChannel1).a;\n    //float fogLitPercent = textureLod(iChannel1, vec2(fc-halton_px_shift)/iResolution.xy, 0.).a;\n#else\n    float absorb = textureLod(iChannel2, vec2(fc-halton_px_shift)/iResolution.xy, 0.).a;\n    float fogLitPercent = textureLod(iChannel1, vec2(fc-halton_px_shift)/iResolution.xy, 0.).a;\n#endif\n\n    vec2 uv = (fragCoord)/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    vec3 ro;\n    vec3 rd;\n    SetCamera(uv, iChannel0, ro, rd, iResolution.xy);\n    \n    vec3 sunColor = calculateSunColor(lightDir.y);\n    float lDotV = dot(rd, lightDir);\n    color = raymarchVolume_image(color, absorb, sunColor, lDotV, fogLitPercent);\n#endif\n#endif\n    \n    //color = ACESFilm(color*texture_color);\n    //color = srgb_encode(color);\n    color = color2agx(color*texture_color);\n\tfragColor = vec4(color, 1.0 );\n   \n}\n\n\n\nvec3 ACESFilm(vec3 x){\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n\nvec3 srgb_encode (vec3 v) {\n  return mix(12.92*v,1.055*pow(v,vec3(.41666))-.055,step(.0031308,v));\n}\n\n\n\n// Agx from https://www.shadertoy.com/view/cd3XWr\n#define AGX_LOOK 1\n\n// AgX\n// ->\n\n// Mean error^2: 3.6705141e-06\nvec3 agxDefaultContrastApprox(vec3 x) {\n  vec3 x2 = x * x;\n  vec3 x4 = x2 * x2;\n  \n  return + 15.5     * x4 * x2\n         - 40.14    * x4 * x\n         + 31.96    * x4\n         - 6.868    * x2 * x\n         + 0.4298   * x2\n         + 0.1191   * x\n         - 0.00232;\n}\n\nvec3 agx(vec3 val) {\n  const mat3 agx_mat = mat3(\n    0.842479062253094, 0.0423282422610123, 0.0423756549057051,\n    0.0784335999999992,  0.878468636469772,  0.0784336,\n    0.0792237451477643, 0.0791661274605434, 0.879142973793104);\n    \n  const float min_ev = -12.47393f;\n  const float max_ev = 4.026069f;\n\n  // Input transform\n  val = agx_mat * val;\n  \n  // Log2 space encoding\n  val = clamp(log2(val), min_ev, max_ev);\n  val = (val - min_ev) / (max_ev - min_ev);\n  \n  // Apply sigmoid function approximation\n  val = agxDefaultContrastApprox(val);\n\n  return val;\n}\n\nvec3 agxEotf(vec3 val) {\n  const mat3 agx_mat_inv = mat3(\n    1.19687900512017, -0.0528968517574562, -0.0529716355144438,\n    -0.0980208811401368, 1.15190312990417, -0.0980434501171241,\n    -0.0990297440797205, -0.0989611768448433, 1.15107367264116);\n    \n  // Undo input transform\n  val = agx_mat_inv * val;\n  \n  // sRGB IEC 61966-2-1 2.2 Exponent Reference EOTF Display\n  //val = pow(val, vec3(2.2));\n\n  return val;\n}\n\nvec3 agxLook(vec3 val) {\n  const vec3 lw = vec3(0.2126, 0.7152, 0.0722);\n  float luma = dot(val, lw);\n  \n  // Default\n  vec3 offset = vec3(0.0);\n  vec3 slope = vec3(1.0);\n  vec3 power = vec3(1.0);\n  float sat = 1.0;\n \n#if AGX_LOOK == 1\n  slope = vec3(0.94,0.97,1.);\n  power = vec3(.75);\n  sat = 1.15;\n#elif AGX_LOOK == 2\n  // Punchy\n  slope = vec3(1.0);\n  power = vec3(1.35, 1.35, 1.35);\n  sat = 1.4;\n#endif\n  \n  // ASC CDL\n  val = pow(val * slope + offset, power);\n  return luma + sat * (val - luma);\n}\n\n// <-\n\nvec4 toLinear(vec4 sRGB) {\n  bvec4 cutoff = lessThan(sRGB, vec4(0.04045));\n  vec4 higher = pow((sRGB + vec4(0.055))/vec4(1.055), vec4(2.4));\n  vec4 lower = sRGB/vec4(12.92);\n  \n  return mix(higher, lower, cutoff);\n}\n\nvec3 color2agx(vec3 col)\n{\n  //col = toLinear(vec4(col, 1.0)).rgb;\n\n  col = agx(col);\n  col = agxLook(col);\n  col = agxEotf(col);\n\n  return col;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// do not use this - made for this exact case\n// template with camera https://danilw.github.io/blog/my_shader_templates_list/\n\n#define iTLime (45.*0.+40.+timerl*0.06)\n\n// this exist just because Shadertoy has only 4 buffers\n\nconst vec3 start_pos_0 = vec3(2.+200., 6.5-0.1, 120.+2.+200.); \nconst vec2 start_mouse_0 = vec2(0., -3.14159265/2.);\n\n#define iTimeDelta min(iTimeDelta,1./10.)\n\nvoid store(ivec2 P, ivec2 ipx, float V, inout vec4 fc){ if(ipx==P) fc.a = V;}\n\nvec3 CameraDirInput(float timerl, float camf) {\n    return vec3(120.*sin(iTLime*(1./75.)*(3.14159265*2.))+2.+200.,120.*cos(iTLime*(1./75.)*(3.14159265*2.))+2.+200.,.1+start_pos_0.y*(1.-smoothstep(0.,1.,sqrt(camf)))).xzy;\n}\n\nvec2 render_new_minDist(in vec2 fragCoord, vec2 halton_px_shift, vec3 ro, vec2 m, float cfl) {\n\n    vec2 fc=fragCoord.xy;\n    fragCoord.xy += halton_px_shift;\n    \n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    vec3 rd;\n    SetCamera_m(uv, m, rd, iResolution.xy, cfl);\n    \n    HitInfo hit;\n    #ifdef ULTRA_WIDE_RES_LOOPS\n    int ca = +int(60.*cfl);\n    #else\n    int ca = +int(30.*cfl);\n    #endif\n\tbool rayHit = minDist(ro, rd, hit, cfl, VOX_LP+ca);\n    \n    return vec2(float(hit.obj_type)+0.5,hit.t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    ivec2 ipx = ivec2(fragCoord);\n    \n// moved because BufB moved here\n//--------------------\n    vec2 res_l = vec2(load(RES_LAST0,iChannel0),load(RES_LAST1,iChannel0));\n    bool input_registered = false;\n    bool res_ch = ivec2(res_l)!=ivec2(iResolution.xy);\n    input_registered = res_ch;\n    // resolution control\n    input_registered = input_registered||(load(ivec2(iResolution.xy)-1, iChannel0))<0.5;\n    //input_registered=true;\n    bool input_registered_TMP = input_registered;\n    \n    \n    vec3 target      = vec3(load(TARGET0, iChannel0),load(TARGET1, iChannel0),load(TARGET2, iChannel0));   \n    vec3 position    = vec3(load(POSITION0, iChannel0),load(POSITION1, iChannel0),load(POSITION2, iChannel0));\n    vec3 position_l = position;\n    \n    vec2 pm          = vec2(load(PMOUSE0, iChannel0),load(PMOUSE1, iChannel0));\n    vec3 vm          = vec3(load(VMOUSE0, iChannel0),load(VMOUSE1, iChannel0),load(VMOUSE2, iChannel0));\n    \n    float timerl = load(TIMER_L, iChannel0);\n    lightDir.xz = lightDir_0.xz*MD(-3.1415926*2.*(1./75.)*iTLime);\n    lightDir.y=lightDir_0.y+.5*(0.5+0.5*sin(22.*3.1415926*(1./75.)*iTLime));\n    lightDir = normalize(lightDir);\n    \n    bool is_init = load(INIT0, iChannel0)<1.;\n    float camf = load(CAM_F, iChannel0);\n    if (iFrame == 0 || is_init){camf=0.;}\n    float camfl = camf;\n    if(iMouse.z>0.)camf = iMouse.y/iResolution.y;\n    \n    vec3 start_pos = CameraDirInput(timerl, camf);\n    vec2 start_mouse = start_mouse_0;\n    start_mouse.x = atan(fract((1./75.)*iTLime+0.035*(1.-smoothstep(0.1,0.35,abs(fract((1./75.)*iTLime)-0.5)))*cos((1./75.)*16.*iTLime*3.14159265)))*4.*2.;\n    start_mouse.y = start_mouse.y+camf*0.82;\n    vm.xy = start_mouse.xy;\n\n    \n    if (iFrame == 0 || is_init) \n    {\n        target = start_pos;\n        position = start_pos;\n        position_l = start_pos;\n        pm = start_mouse;\n        vm.xy = start_mouse.xy;\n    }\n    \n    vec3 ptarget = target;\n    target = CameraDirInput(timerl, camf);\n\n    vec3 lp = position;\n    position += (target - position) * min(iTimeDelta,1./10.) * 2.5;\n    position.y = target.y;\n\n    \n    if(length(abs(position)-abs(lp))>0.0001)input_registered=true;\n    \n    vec3 ro = position;\n    vec2 im = vec2(0.);{\n    \tim = vm.xy;\n    }\n    //input_registered=true;\n    \n#ifdef use_dynamic_TAA\n    vec2 halton = (halton(iFrame % 360 + 1) - 0.5f);\n#else\n    vec2 halton = input_registered?vec2(0.):halton(iFrame % 360 + 1) - 0.5f;\n#endif\n    \n    fragColor.rg = render_new_minDist(fragCoord, halton, ro, im, camf);\n    fragColor.b = texelFetch(iChannel0,ipx,0).y;\n    fragColor.a = texelFetch(iChannel0,ipx,0).a;\n    \n    if(ipx==ivec2(iResolution.xy)-1){\n        fragColor.a=2.; // resolution control for pause case\n        return;\n    }\n//--------------------\n    \n    \n    float bnoise=fragColor.a;\n    if(input_registered_TMP||iFrame==0)\n    if (any(greaterThan(ipx, MEMORY_BOUNDARY))){bnoise=Bnoise(fragCoord+iDate.w*0.01);fragColor.a=bnoise;}\n    \n    if (any(greaterThan(ipx, MEMORY_BOUNDARY))) return;\n    \n    vec2 vm_l = vec2(load(VMOUSE0, iChannel0),load(VMOUSE1, iChannel0));\n    \n    if (iFrame == 0 || is_init) {\n        vm_l=start_mouse;\n        vec3 position_l=start_pos;\n        store(POSITION0, ipx, start_pos.x, fragColor); // ro\n        store(POSITION1, ipx, start_pos.y, fragColor);\n        store(POSITION2, ipx, start_pos.z, fragColor);\n        store(POSITION_last0, ipx, position_l.x, fragColor); // last_ro\n        store(POSITION_last1, ipx, position_l.y, fragColor);\n        store(POSITION_last2, ipx, position_l.z, fragColor);\n        store(TARGET0, ipx, start_pos.x, fragColor); // mouse look\n        store(TARGET1, ipx, start_pos.y, fragColor);\n        store(TARGET2, ipx, start_pos.z, fragColor);\n        store(VMOUSE0, ipx, start_mouse.x, fragColor); // virtual mouse (rotation_mat)\n        store(VMOUSE1, ipx, start_mouse.y, fragColor);\n        store(VMOUSE_last0, ipx, vm_l.x, fragColor); // last virtual mouse\n        store(VMOUSE_last1, ipx, vm_l.y, fragColor);\n        store(PMOUSE0, ipx, start_mouse.x, fragColor); // real mouse pos\n        store(PMOUSE1, ipx, start_mouse.y, fragColor);\n        store(INIT0, ipx, 2., fragColor); // is_init(0 false, 2 true)\n        store(INPUT0_timer, ipx, 0., fragColor);\n        store(RES_CHANGE, ipx, 0., fragColor); // 0 true 1 false\n        store(INPUT0, ipx, 2., fragColor); // key_pressed(0 false, 2 true) \n        store(RES_LAST0, ipx, iResolution.x, fragColor); // xy = last_resolution\n        store(RES_LAST1, ipx, iResolution.y, fragColor);\n        store(HALTON0, ipx, halton.x, fragColor);\n        store(HALTON1, ipx, halton.y, fragColor);\n        store(HALTON_last0, ipx, 0., fragColor);\n        store(HALTON_last1, ipx, 0., fragColor);\n        store(TIMER_L, ipx, 0., fragColor);\n        store(IMONC, ipx, 0., fragColor);\n        store(CAM_F, ipx, 0., fragColor);\n        store(CAM_FL, ipx, 0., fragColor);\n        return;\n    }\n    \n    \n    store(TARGET0, ipx, target.x, fragColor);\n    store(TARGET1, ipx, target.y, fragColor);\n    store(TARGET2, ipx, target.z, fragColor);\n    store(POSITION0, ipx, position.x, fragColor);\n    store(POSITION1, ipx, position.y, fragColor);\n    store(POSITION2, ipx, position.z, fragColor);\n\n    store(POSITION_last0, ipx, position_l.x, fragColor);\n    store(POSITION_last1, ipx, position_l.y, fragColor);\n    store(POSITION_last2, ipx, position_l.z, fragColor);\n    store(VMOUSE_last0, ipx, vm_l.x, fragColor);\n    store(VMOUSE_last1, ipx, vm_l.y, fragColor);\n    \n    store(VMOUSE0, ipx, vm.x, fragColor);\n    store(VMOUSE1, ipx, vm.y, fragColor);\n    \n    store(INPUT0, ipx, input_registered?2.:0., fragColor);\n    float iot = load(INPUT0_timer, iChannel0);\n    store(INPUT0_timer, ipx, input_registered?0.:iot+iTimeDelta, fragColor);\n    \n    bool imon = (load(IMONC, iChannel0)>0.5);\n    timerl+=min(iTimeDelta,1./10.)*max(0.,0.15+0.6*float(!imon)+float(imon)*2.65*(iMouse.x/iResolution.x-0.15));\n    store(TIMER_L, ipx, timerl, fragColor);\n    \n    store(IMONC, ipx, float(imon||iMouse.z>0.), fragColor);\n    \n    store(HALTON0, ipx, halton.x, fragColor);\n    store(HALTON1, ipx, halton.y, fragColor);\n    \n    vec2 halton_last = vec2(load(HALTON0,iChannel0),load(HALTON1,iChannel0));\n    store(HALTON_last0, ipx, halton_last.x, fragColor);\n    store(HALTON_last1, ipx, halton_last.y, fragColor);\n    \n    store(RES_LAST0, ipx, iResolution.x, fragColor);\n    store(RES_LAST1, ipx, iResolution.y, fragColor);\n    \n    store(RES_CHANGE, ipx, res_ch?0.:1., fragColor);\n    \n    store(CAM_F, ipx, camf, fragColor);\n    store(CAM_FL, ipx, camfl, fragColor);\n    \n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n\n\n// define this for ultra-wide screen\n// or change number of loops in define VOX_LP below\n//#define ULTRA_WIDE_RES_LOOPS\n\n\n#define AORays 8\n#define reflectionRays 6\n#define shadowRays 6\n\n#ifndef ULTRA_WIDE_RES_LOOPS\n#define VOX_LP 12\n#define VOX_LP_shd 6\n#else\n#define VOX_LP 60\n#define VOX_LP_shd 10\n#endif\n\n// edit parameters\n// ---------------\n\n// when enabled 2nd light bounce (num of rays=AORays)\n//#define sunlight_2nd_bounce\n\n//#define enable_reflections\n#define reflection_color_emi\n// edit/search PixelAcceptance to remove edge-trail from emission, closer to 1 better \n// but closer to 1 will remove all reprojection from thin edges on far - so balance\n\n// when ConeVector used in bounce light and emision light have not correct form \n// (compare to CosineWeightedSample, comment define below)\n#define use_ConeVector\n// with ConeVector better visual result\n// ConeVector distribution, look this screenshots\n// https://danilw.github.io/GLSL-howto/vulkan_sh_launcher/upl_demos/pathtracer/ray_distr1.jpg\n// https://danilw.github.io/GLSL-howto/vulkan_sh_launcher/upl_demos/pathtracer/ray_distr2.png\n\n#define use_reproject_TAA\n\n// when turned off dymanic TAA - BufD is unused\n#define use_dynamic_TAA\n\n// texture or volume, texture use single float in BufB\n// and BufC copy to self alpha, just to have less texture reads in BufD that apply albedo TAA\n// albedo addition to color moved to BufD because TAA-pixel-jitter\n//#define enable_textures\n\n// when enabled dynamic TAA - there visible \"border\" on volume-shadow and object edges\n// look enable_volume in Image - ther unjittering and TAA applied to one component\n// there is small 1-2 pixel border on object-volume, look/remove GaussianBlur\n//#define enable_volume\n\n#define volumeSteps 10\nconst float volume_fogDensity = .125;\n\nconst float camera_fov = 20.;\n#define cam_exf 60.\n\n// ---------------\n\n//#define ANGLE_loops 0\n#define ANGLE_loops min(iFrame,0)\n\n// weird Android bug fix? idk\n// https://www.shadertoy.com/view/4cGGWw\nvec4 my_texelFetch(highp sampler2D chan, ivec2 p, int l) {\n return texelFetch(chan,p,l);\n}\n#define texelFetch(a,b,c) my_texelFetch(a,b,c)\n\n\n\n#define MAX_DIST 1000.\n#define MIN_DIST .0001\n\n\n// OBJ_ is >=0, not negative\n#define OBJ_SKY 0\n#define OBJ_FLOOR 1\n#define OBJ_SPHERE_t 5\n#define OBJ_SPHERE 10\n\n\n//const vec3 lightDir = normalize(vec3(0.72155,0.514495,0.4633));\nconst vec3 lightDir_0 = normalize(vec3(1.5, .65, 1.50));\nvec3 lightDir = lightDir_0;\nmat2 MD(float a){float s = sin( a );float c = cos( a );return mat2(vec2(c, -s), vec2(s, c));}\n\n\n\nconst vec3 upVec = vec3(0.0, 1.0, 0.0);\n\n#define PI 3.141592653589793\n#define TAU 6.283185307179586\n#define c_goldenRatioConjugate 0.61803398875f\n\n\n\n// Camera related (just to have less code in buffers)\n// ---------------\nconst ivec2 MEMORY_BOUNDARY = ivec2(2, 15); //BufA reserved (and top right pixel)\n\nconst ivec2 RES_LAST0 = ivec2(0, 0);\nconst ivec2 RES_LAST1 = ivec2(0, 1);\nconst ivec2 INIT0 = ivec2(0, 2);\nconst ivec2 TARGET0 = ivec2(0, 3);\nconst ivec2 TARGET1 = ivec2(0, 4);\nconst ivec2 TARGET2 = ivec2(0, 5);\n\nconst ivec2 POSITION0 = ivec2(0, 6);\nconst ivec2 POSITION1 = ivec2(0, 7);\nconst ivec2 POSITION2 = ivec2(0, 8);\nconst ivec2 POSITION_last0 = ivec2(0, 9);\nconst ivec2 POSITION_last1 = ivec2(0, 10);\nconst ivec2 POSITION_last2 = ivec2(0, 11);\n\nconst ivec2 VMOUSE0 = ivec2(1, 0);\nconst ivec2 VMOUSE1 = ivec2(1, 1);\nconst ivec2 VMOUSE2 = ivec2(1, 2);\nconst ivec2 VMOUSE_last0 = ivec2(1, 3);\nconst ivec2 VMOUSE_last1 = ivec2(1, 4);\n\nconst ivec2 INPUT0 = ivec2(1, 5);\nconst ivec2 HALTON0 = ivec2(1, 6);\nconst ivec2 HALTON1 = ivec2(1, 7);\nconst ivec2 HALTON_last0 = ivec2(1, 8);\nconst ivec2 HALTON_last1 = ivec2(1, 9);\nconst ivec2 PMOUSE0 = ivec2(1, 10);\nconst ivec2 PMOUSE1 = ivec2(1, 11);\n\nconst ivec2 RES_CHANGE = ivec2(0, 12);\nconst ivec2 INPUT0_timer = ivec2(1, 12);\n\nconst ivec2 CAM_F = ivec2(0, 13);\nconst ivec2 CAM_FL = ivec2(1, 13);\n\nconst ivec2 TIMER_L = ivec2(1, 14);\nconst ivec2 IMONC = ivec2(0, 14);\n\n\nfloat load(ivec2 P, sampler2D self){return texelFetch(self, ivec2(P), 0).a;}\n\n// Camera\nmat3 rotationMatrix(vec2 m){\n  mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n  mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n  return rotY*rotX;\n}\n\nvoid SetCamera(vec2 uv, sampler2D caminfo, out vec3 ro, out vec3 rd, vec2 ires)\n{\n    ro = vec3(load(POSITION0,caminfo),load(POSITION1,caminfo),load(POSITION2,caminfo));\n    vec2 m = vec2(load(VMOUSE0,caminfo),load(VMOUSE1,caminfo));\n    m.y = -m.y;\n    float fov=camera_fov+cam_exf*load(CAM_F,caminfo);\n    float aspect = ires.x / ires.y;\n    float screenSize = (1.0 / (tan(((180.-fov)* (3.1415926 / 180.0)) / 2.0)));\n    rd = vec3(uv*screenSize, 1./aspect);\n    \n    //rd+=0.000001*(1.-abs(sign(rd)));\n    rd = normalize(rd);\n    rd = rotationMatrix(m) * rd;\n}\n\nvoid SetCamera_prev(vec2 uv, sampler2D caminfo, out vec3 ro, out vec3 rd, vec2 ires)\n{\n    ro = vec3(load(POSITION_last0,caminfo),load(POSITION_last1,caminfo),load(POSITION_last2,caminfo));\n    vec2 m = vec2(load(VMOUSE_last0,caminfo),load(VMOUSE_last1,caminfo));\n    m.y = -m.y;\n    float fov=camera_fov+cam_exf*load(CAM_FL,caminfo);\n    float aspect = ires.x / ires.y;\n    float screenSize = (1.0 / (tan(((180.-fov)* (3.1415926 / 180.0)) / 2.0)));\n    rd = vec3(uv*screenSize, 1./aspect);\n    \n    //rd+=0.000001*(1.-abs(sign(rd)));\n    rd = normalize(rd);\n    rd = rotationMatrix(m) * rd;\n}\n\nvoid SetCamera_m(vec2 uv, vec2 m, out vec3 rd, vec2 ires, float cfl)\n{\n    m.y = -m.y;\n    float fov=camera_fov+cam_exf*cfl;\n    float aspect = ires.x / ires.y;\n    float screenSize = (1.0 / (tan(((180.-fov)* (3.1415926 / 180.0)) / 2.0)));\n    rd = vec3(uv*screenSize, 1./aspect);\n    \n    //rd+=0.000001*(1.-abs(sign(rd)));\n    rd = normalize(rd);\n    rd = rotationMatrix(m) * rd;\n}\n\n// ---------------\n\n\n\n// ---------------\n\n// material by object id\n// remember about dFd bugs\n// ---------------\n\n\nfloat hash12(vec2 p);\nfloat hash11(float p);\nvec3 get_pal(float d, float d2, float d3);\nvoid material_OBJ_SPHERE(vec2 tidf, vec3 norm, out vec3 albedo, out vec3 emission, \n                        out float roughness, out float metalness){\n    albedo = vec3(1., 1., 1.)*1.;\n    ivec2 tid = ivec2(tidf);\n    ivec2 nldi = ivec2(-1);\n    // I love reindexing \n    // https://danilw.github.io/GLSL-howto/vulkan_sh_launcher/images_bugs/MXsyWB_reidx.png\n    if((int(tid.y)%4)>1){\n        nldi.x = tid.x;\n        nldi.y = (tid.y/4)*2+(1-(tid.y%2))*2;\n    }else{\n        nldi.x = tid.x+(tid.y%2);\n        nldi.y = (tid.y/4)*2+1;\n    }\n    float td = hash12(vec2(nldi)*1.5+5.1);\n    albedo = get_pal(td,hash12(vec2(nldi.yx)*2.5+11.1),float((nldi.x/20)%2));\n    emission = vec3(1., 5., 15.)*0.;\n    //emission = vec3(1., 5., 15.)*float(albedo.x+albedo.y>0.85)*1.;\n    roughness = 0.1931;\n    metalness = 0.321;\n}\n\nvoid material_OBJ_FLOOR(vec3 pos, vec3 norm, out vec3 albedo, out vec3 emission, \n                        out float roughness, out float metalness){\n    albedo = vec3(1.,1.,1.);\n    emission = vec3(10.,5.,0.)*0.;\n#ifdef enable_reflections\n    emission = vec3(10.,5.,0.)*1.;\n#endif\n    roughness = 0.531;\n    metalness = 0.521;\n}\n\nvec3 get_normal_OBJ_SPHERE(vec3 pos){\n    if(length(pos)<0.0001)return vec3(0.001,0.001,0.99);\n    return normalize(pos);\n}\n\nvec3 get_normal_OBJ_FLOOR(vec3 pos){\n    return vec3(0.,1.,0.);\n}\n\n// ---------------\n\n\n\n// sky\n//----------------------------------------------\n\nconst float sunAngularDiameter = 20.5;\n\nconst float sunIluminance = 2.5;\n\nconst float goldenAngle = 2.3999632297286533;\n\n// sky from https://www.shadertoy.com/view/3dlSW7\n\nfloat hGPhase(float cosTheta, const float g){\n\tfloat g2 = g * g;\n    \n    return 0.25 * (1.0 - g2) * pow(g2 - 2.0 * g * cosTheta + 1.0, -1.5);\n}\n\nvec3 calculateSunColor(float sunZenith){\n\treturn mix(vec3(1.0, 0.4, 0.05), vec3(1.0), max(sunZenith, 0.0));\n}\n\nfloat calculateSun(float lDotV){\n    const float cosRad = cos(radians(sunAngularDiameter));\n    const float sunLuminance = sunIluminance / ((1.0 - cosRad) * TAU);\n    \n    return smoothstep(cosRad,cosRad*1.001, lDotV) * sunLuminance;\n}\n\nvec3 calculateSky(vec3 background, float lDotU, float lDotV){\n    float phaseMie = hGPhase(lDotV, 0.8);\n    \n    float zenith = max(lDotU, 0.0);\n    \n    float sunZenith = lightDir.y;\n    const vec3 topCol = vec3(0.1, 0.34, 1.0);\n    const vec3 bottomCol = vec3(1.0);\n    \n    vec3 sky = mix(topCol, (bottomCol + topCol), exp2(-zenith * 8.0));\n         sky += phaseMie * exp2(-zenith * 6.0);\n    \n    vec3 absorbColor = calculateSunColor(1.0 - exp2(-zenith * 2.0));\n    \n    sky = sky * mix(absorbColor * 0.9 + 0.1, vec3(1.0), sunZenith);\n\treturn background * absorbColor + sky * sunIluminance * (1.0 - clamp(-sunZenith * 10.0, 0.0, 1.0));\t\n}\n\n//----------------------------------------------\n\n\n\n// pathtracing functions\n//----------------------------------------------\n\n// with ConeVector better visual result\n// ConeVector distribution, look this screenshots\n// https://danilw.github.io/GLSL-howto/vulkan_sh_launcher/upl_demos/pathtracer/ray_distr1.jpg\n// https://danilw.github.io/GLSL-howto/vulkan_sh_launcher/upl_demos/pathtracer/ray_distr2.png\n#ifdef use_ConeVector\n\nmat3 calculateTangentMatrix(vec3 direction){\n\tvec3 c1 = cross(direction, vec3(0.0, 0.0, 1.0));\n\tvec3 c2 = cross(direction, vec3(0.0, 1.0, 0.0));\n    \n    vec3 tangent = dot(c1, c1) > dot(c2, c2) ? c1 : c2;\n    vec3 biDir = cross(direction, tangent);\n    \n    return mat3(tangent, biDir, direction);\n}\n\nvec3 calculateConeVector(const float i, const float angularRadius, const int steps) {\n    float x = i * 2.0 - 1.0;\n    float y = i * float(steps) * 16.0 * 16.0 * goldenAngle;\n    \n    float angle = acos(x) * radians(angularRadius) * 1./PI;\n    float c = cos(angle);\n    float s = sin(angle);\n\n    return vec3(cos(y) * s, sin(y) * s, c);\n}\n\nvec3 calculateRoughSpecular(const float i, const int steps, float roughness) {\n    float r = roughness * roughness * roughness * roughness;\n    float x = (r * i) / max(1.0 - i,0.0001);\n    float y = i * float(steps) * 16.0 * 16.0 * goldenAngle;\n    //if(1.0 - i<0.)\n    //x = (r * i)*1000.;\n    float c = inversesqrt(x + 1.0);\n    float s = sqrt(x) * c;\n\n    return vec3(cos(y) * s, sin(y) * s, c);\n}\n\n#else\n\n// CosineWeightedSample\n\nfloat seed=0.;\nfloat hash11_seed()\n{\n    float p=seed;\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    seed+=1.33;\n    return fract(p);\n}\n\nvec3 ortho(vec3 v) {\n  return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);\n}\n\nvec3 getCosineWeightedSample(vec3 dir, float radius) {\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = vec2(hash11_seed(), hash11_seed());\n\tr.x = r.x * 2.0 * PI;\n\tr.y = pow(r.y, radius);\n\tfloat oneminus = sqrt(abs(1.0-r.y*r.y));\n\treturn cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;\n}\n\n\n#endif\n//----------------------------------------------\n\n// reprojection\n//----------------------------------------------\n\nvec2 pos2uv(vec3 pos, sampler2D caminfo, vec2 ires){\n    vec3 ro_old = vec3(load(POSITION_last0,caminfo),load(POSITION_last1,caminfo),load(POSITION_last2,caminfo));\n    vec2 m_old = vec2(load(VMOUSE_last0,caminfo),load(VMOUSE_last1,caminfo))*vec2(1.,-1.);\n    vec3 td = pos - ro_old;\n    if(length(td)<0.0001)return vec2(-1.);\n    vec3 dir = normalize(td) * (rotationMatrix(m_old));\n    float fov=camera_fov+cam_exf*load(CAM_FL,caminfo);\n    float aspect = ires.x / ires.y;\n    float screenSize = (1.0 / (tan(((180.-fov)* (3.1415926 / 180.0)) / 2.0)));\n    dir.z+=0.0001*(1.-abs(sign(dir.z)));\n    return dir.xy * (.5/screenSize) / dir.z ;\n}\n\nfloat distancePixel( vec2 prevFragCoord, vec3 pos, sampler2D samplerx, vec2 ires, vec3 p_ro, vec3 p_rd){\n    if(  min(ires.xy-1., prevFragCoord) != prevFragCoord\n      || max(vec2(0.)      , prevFragCoord) != prevFragCoord) return MAX_DIST;\n    \n    float prev_d = textureLod(samplerx, prevFragCoord/ires.xy,0.).b;\n    vec3 prevPos = p_ro + p_rd*prev_d;\n    return length(prevPos-pos);\n}\n\n\n#define PixelAcceptance 0.75\n#define PixelCheckDistance .75\nvec4 previousSample(vec3 ro, vec3 pos, sampler2D caminfo, sampler2D last_pos_fbo, sampler2D last_color, vec2 ires){\n    vec2 old_halton_px_shift=vec2(load(HALTON_last0,caminfo),load(HALTON_last1,caminfo));\n    vec2 prevUv = pos2uv(pos, caminfo, ires) - old_halton_px_shift/ires.y;\n    vec2 prevFragCoord = prevUv * ires.y + ires.xy/2.0;\n    \n    vec2 pfc=vec2(0.);\n    vec2 finalpfc=vec2(0.);\n    float dist, finaldist = MAX_DIST;\n    for(int x = -1; x <= 1; x++){\n        for(int y = -1; y <= 1; y++){\n            pfc = prevFragCoord + PixelCheckDistance*vec2(x, y);\n            vec2 tuv = pfc/ires.xy * 2.0 - 1.0;\n            tuv.y *= ires.y/ires.x;\n            vec3 p_ro;\n            vec3 p_rd;\n            SetCamera_prev( tuv, caminfo, p_ro, p_rd, ires);\n            dist = distancePixel(pfc, pos, last_pos_fbo, ires, p_ro, p_rd);\n            if(dist < finaldist){\n                finalpfc = pfc;\n                finaldist = dist;\n            }\n      }\n    }\n    \n    if(finaldist < ((PixelAcceptance+3.*load(CAM_F,caminfo))/ires.y)*(length(pos-ro)))\n        return textureLod(last_color, finalpfc/ires.xy,0.);\n    return vec4(0.);\n}\n\n//----------------------------------------------\n\n\n\n\n\n\n// intersection template\n//----------------------------------------------\n\nstruct HitInfo {\n    float t;\n    vec3 norm;\n    vec4 color;\n    vec3 emisson;\n    float rough;\n    float metal;\n    int obj_type;\n};\n\n\nbool PlaneIntersect(vec4 Plane, vec3 ro, vec3 rd, out float t, out vec3 norm) {\n    norm=vec3(0.,1.,0.);\n    t=-1.;\n    float dd = dot(rd, Plane.xyz);\n    if (dd == 0.0) return false;\n    float t1 = -(dot(ro, Plane.xyz) + Plane.w) / dd;\n    if (t1 < 0.0) return false;\n    norm = normalize(Plane.xyz);\n    t = t1;\n    return true;\n}\n\n\nbool SphereIntersect(vec3 SpPos, float SpRad, vec3 ro, vec3 rd, out float t, out vec3 norm) {\n    ro -= SpPos;\n\n    float A = dot(rd, rd);\n    float B = 2.0*dot(ro, rd);\n    float C = dot(ro, ro)-SpRad*SpRad;\n    float D = B*B-4.0*A*C;\n    t=-1.;\n    norm=vec3(0.,1.,0.);\n    if (D < 0.0) return false;\n\n    D = sqrt(D);\n    A *= 2.0;\n    float t1 = (-B+D)/A;\n    float t2 = (-B-D)/A;\n    if (t1 < 0.0) t1 = t2;\n    if (t2 < 0.0) t2 = t1;\n    t1 = min(t1, t2);\n    if (t1 < 0.0) return false;\n    norm = ro+t1*rd;\n    t = t1;\n    norm = normalize(norm);\n    return true;\n}\n\n\n\nvoid GroundIntersectMin(vec3 ro, vec3 rd, inout bool result, inout HitInfo hit) {\n    float tnew;\n    vec3 normnew;\n    vec4 pp=vec4(0., 1., 0., 0.);\n    if (PlaneIntersect(pp, ro+vec3(0.,0.75,0.), rd, tnew, normnew)) {\n        if (tnew < hit.t) {\n            hit.t = tnew;\n            hit.norm = normnew;\n            \n            hit.emisson = vec3(0.,0.,0.);\n            vec3 albedo;\n            material_OBJ_FLOOR(ro+rd*hit.t, hit.norm,  albedo, hit.emisson, hit.rough, hit.metal);\n            hit.color = vec4(albedo, 1.);\n            hit.obj_type = OBJ_FLOOR;\n            result = true;\n        }\n    }\n}\n/*\nvoid SphereIntersectMin(vec3 SpPos, float SpRad, vec3 ro, vec3 rd, inout bool result, inout HitInfo hit) {\n    float tnew;\n    vec3 normnew;\n    if (SphereIntersect(SpPos, SpRad, ro, rd, tnew, normnew)) {\n        if (tnew < hit.t) {\n            hit.t = tnew;\n            hit.norm = normnew;\n            vec3 albedo;\n            material_OBJ_SPHERE(vec2(1.), hit.norm,  albedo, hit.emisson, hit.rough, hit.metal);\n            hit.color = vec4(albedo, 1.);\n            hit.obj_type = OBJ_SPHERE_t;\n            result = true;\n        }\n    }\n}\n*/\n\nvec2 Box_hit(vec3 ro,vec3 rd,vec3 p0,vec3 p1)\n{\n    vec3 t0 = (mix(p1, p0, step(0., rd * sign(p1 - p0))) - ro) / rd;\n    vec3 t1 = (mix(p0, p1, step(0., rd * sign(p1 - p0))) - ro) / rd;\n    return vec2(max(t0.x, max(t0.y, t0.z)),min(t1.x, min(t1.y, t1.z)));\n}\n\nvec3 boxNormal(vec3 pos,vec3 p0,vec3 p1, vec3 bsize)\n{\n    pos = pos - (p0 + p1) / 2.;\n    vec3 arp = abs(pos) / bsize;\n    return step(arp.yzx, arp) * step(arp.zxy, arp) * sign(pos);\n}\n\nbool BoxIntersect_min_inv( in vec3 ro, in vec3 rd, vec3 opos, vec3 size, out float tN, out vec3 norm){\n    vec3 p = size*0.5+opos;\n    vec3 q = -size*0.5+opos;\n    vec2 b = Box_hit(ro, rd, p, q);\n    tN=MAX_DIST;\n    norm=vec3(0.,1.,0.);\n\n    if(b.y > MIN_DIST && b.x < b.y && b.y < MAX_DIST)\n    {\n        tN = b.y;\n        vec3 pos = ro + rd * tN;\n        norm = -boxNormal(pos, p, q, size);\n        return true;\n    }\n    return false;\n}\n\n//----------------------------------------------\n\n\nconst vec2 sccc = vec2(1., 1.73)*0.5; \n\nvec2 gridID(vec2 p){\n    vec2 ip = floor(p/sccc) + .5;\n    return ip;\n}\n\nfloat rayLineF(vec2 ro, vec2 p, vec2 n){\n    return dot(p - ro, n);\n    \n}\n\n// rectangle voxels from Shane https://www.shadertoy.com/view/sslfz7\n\n// this is modified - DO NOT USE THIS - made only for this my case - use original linked above if needed\n\nbool VoxelsIntersect_rectangle(int steps, vec2 box, float max_h, float ffix, in vec3 ro, in vec3 rd, out vec3 normal , out float tnew, out vec2 idx, out int sidx) {\n\n\n    vec4 res = vec4(1e8); // Distance, face ID and cell ID.\n    vec3 srd = sign(rd); \n    vec3 pos3 = ro; \n    \n    vec3 n1 = vec3(1, 0, 0);\n    vec3 n2 = vec3(0, 0, 1);\n    \n    float d1 = dot(rd.xz, n1.xz);\n    float d2 = dot(rd.xz, n2.xz); \n\n    if(d1<0.) n1 *= -1.;\n    if(d2<0.) n2 *= -1.;\n    \n    vec2 invN = -1./vec2(dot(rd, n1), dot(rd, n2));\n    \n    vec2 t;\n    float tT;\n    float mint = 0.;\n    int hit = 0;\n    vec2 ip = gridID(pos3.xz);\n    bool br = false;\n    for(int i = 0; i<steps; i++){\n    \n        res.zw = ip*sccc;\n        float tm = 1.;\n        if (any(greaterThan(res.zw,box*2.))||any(lessThan(res.zw,vec2(2.))))tm=-10000.;\n        float ma = max_h*tm; \n        ///float ma = (max_h-2.5)*tm; \n        vec3 ttpos3 = pos3;\n\n        if(pos3.y<ma&&tm>0.5){\n            hit = 1;\n            br = true; \n        }\n        {\n            t.x = rayLineF(pos3.xz, res.zw + n1.xz*sccc*.5, -n1.xz);\n            t.y = rayLineF(pos3.xz, res.zw + n2.xz*sccc*.5, -n2.xz);\n\n            t *= invN;\n\n            mint = min(t.x, t.y);\n\n            tT = (ma - pos3.y)/(rd.y);\n            tT = tT<0. ? 1e8 : tT;\n\n            if(tT<mint&&tm>0.5)\n            {\n                ttpos3 += rd*tT; \n                hit = 2;\n                br = true;\n            }\n        }\n        if(br){\n            res.y = hit == 2? 0. : 1.; \n            res.x = length(ttpos3 - ro);\n            //vec3 tpos = ro+rd*res.x;\n            \n            // why sphere position shifted by 0.17 I have no idea\n            // I add tpx+=vec3(0.,0.,-0.17); in BufB and C not here\n            //res.zw+=vec3(0.,0.,-0.17).xz;\n            \n            // this will be broken for rect-voxels because floor is broken\n            // works here because I do not need/use exact borders of voxel\n            idx = floor(res.zw/sccc)-floor((1./sccc)*2.); \n\n            vec2 ttpos = res.zw;\n            vec3 tnorm; float td; float otd = MAX_DIST;vec3 onorm;\n            bool tresult;bool otresult=false;\n\n            float ttnew;\n            vec3 ttnor;\n            \n            // fix for \n            // https://danilw.github.io/GLSL-howto/vulkan_sh_launcher/images_bugs/MXsyWB_rect_tile.png\n            bool tb = BoxIntersect_min_inv(ro, rd, vec3(ttpos.x,-0.5,ttpos.y), 0.5*vec3(sccc.x,1.,sccc.y)*2.*vec3(1.,10.,1.), ttnew, ttnor);\n            if(tb)\n            {\n                tresult = SphereIntersect(vec3(ttpos.x-sccc.x*0.5,-0.5,ttpos.y), sccc.x*0.5, ro, rd, td, tnorm);\n                if(tresult){if(td>ttnew){}\n                    else \n                    if(td<otd){otresult=true;otd=td;onorm=tnorm;sidx=0;}}\n                tresult = SphereIntersect(vec3(ttpos.x+sccc.x*0.5,-0.5,ttpos.y), sccc.x*0.5, ro, rd, td, tnorm);\n                if(tresult){if(td>ttnew){}\n                    else \n                    if(td<otd){otresult=true;otd=td;onorm=tnorm;sidx=1;}}\n                tresult = SphereIntersect(vec3(ttpos.x,-0.5,ttpos.y+sccc.y*0.5), sccc.x*0.5, ro, rd, td, tnorm);\n                if(tresult){if(td>ttnew){}\n                    else \n                    if(td<otd){otresult=true;otd=td;onorm=tnorm;sidx=2;}}\n                tresult = SphereIntersect(vec3(ttpos.x,-0.5,ttpos.y-sccc.y*0.5), sccc.x*0.5, ro, rd, td, tnorm);\n                if(tresult){if(td>ttnew){}\n                    else \n                    if(td<otd){otresult=true;otd=td;onorm=tnorm;sidx=3;}}\n\n            }\n            if(otresult){\n                normal = onorm;\n                tnew = otd;\n                //idx = idx;\n                //sidx = sidx;\n                return true;\n            }\n        }\n\n        pos3 += rd*mint; \n        ip = gridID(pos3.xz + srd.xz*ffix);\n        br = false;\n    }\n    \n    \n    return false;\n}\n\n\nvoid VoxelsIntersect_rectangleMin(vec3 ro, vec3 rd, inout bool result, inout HitInfo hit, float cfl, int clp) {\n    \n    float tnew;\n    vec2 idx;\n    vec3 normnew;\n    int sidx;\n\n    if(VoxelsIntersect_rectangle(clp, vec2(200.), 2., 0.00051, ro, rd, normnew, tnew, idx, sidx)){\n        if (tnew < hit.t) {\n            int tid = int(idx.x)*500*4+int(idx.y)*4+OBJ_SPHERE+sidx;\n            hit.obj_type = tid;\n            vec3 albedo;\n            material_OBJ_SPHERE(vec2((tid-OBJ_SPHERE)/(500*4),(tid-OBJ_SPHERE)%(500*4)), normnew, albedo, hit.emisson, hit.rough, hit.metal);\n            hit.color = vec4(albedo, 1.);\n            result = true;\n            hit.t = tnew;\n            hit.norm = normnew;\n        }\n    }\n}\n\n\n\n\n//----------------------------------------------\n\nbool minDist(vec3 ro, vec3 rd, out HitInfo hit, float cfl, int clp)\n{\n    hit.t = MAX_DIST;\n    hit.obj_type = OBJ_SKY;\n    hit.norm = vec3(0.,1.,0.);\n    \n    float lDotU = dot(rd, upVec);\n    float lDotV = dot(rd, lightDir);\n    \n    hit.color=vec4(calculateSky(calculateSun(lDotV)*calculateSunColor(lightDir.y), lDotU, lDotV),1.);\n    hit.emisson = vec3(0.,0.,0.);\n    bool result = false;\n\n    GroundIntersectMin(ro, rd, result, hit);\n    VoxelsIntersect_rectangleMin(ro, rd, result, hit, cfl, clp);\n\n\n    return result;\n}\n\n//----------------------------------------------\n\n\n// palette from iq https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 get_pal(float td, float td2, float td3){\n    float d1 = fract((td*73.3+td2*8.5))*0.3+0.5;\n    float d11 = fract((td*3.3+td2*12.5))*0.2+0.17;\n    float d12 = fract((td*23.3+td2*12.5))*0.2+0.25;\n    float d2 = fract((td*73.3+td2*8.5))*0.23;\n    vec3 c1 = pal( d1, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n    vec3 c11 = pal( d11, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20) );\n    vec3 c12 = pal( d12, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n    vec3 c2 = pal( d2, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20) );\n    c1=clamp(c1,0.,1.);\n    c2=clamp(c2,0.,1.);\n    c11=clamp(c11,0.,1.);\n    c12=clamp(c12,0.,1.);\n    c1 = sqrt(mix(c1,pow(c1,vec3(7.)),smoothstep(0.35,0.63,dot(c1,vec3(1.))/3.)));\n    c2 = sqrt(mix(c2,pow(c2,vec3(7.)),smoothstep(0.35,0.63,dot(c2,vec3(1.))/3.)));\n    //return c11.grb;\n    return mix(mix(c1,c2,step(td3,0.5)),pow(mix(c11.grb,c12,step(td3+td2*td,0.75)),vec3(0.35)),float(td2+td>1.54));\n}\n\n\n// noise https://www.shadertoy.com/view/7sGBzW\n// hash https://www.shadertoy.com/view/4djSRW\n\n\n// look https://www.shadertoy.com/view/4fsSRn\n// read https://arugl.medium.com/hash-noise-in-gpu-shaders-210188ac3a3e\n#define FIX_FRACT_HASH 1000.\n\nfloat hash12(vec2 p)\n{\n#ifdef FIX_FRACT_HASH\n    p = sign(p)*(floor(abs(p))+floor(fract(abs(p))*FIX_FRACT_HASH)/FIX_FRACT_HASH);\n#endif\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash11(float p)\n{\n#ifdef FIX_FRACT_HASH\n    p = sign(p)*(floor(abs(p))+floor(fract(abs(p))*FIX_FRACT_HASH)/FIX_FRACT_HASH);\n#endif\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n\n// saved in BufA as alpha\nfloat Bnoise(vec2 U) {\n    float v = 0.;\n    for (int k=0; k<9; k++)\n        v += hash12( U + vec2(k%3-1,k/3-1) ); \n    v=.9 *( 1.125*hash12(U)- v/8.) + .5;\n    //return clamp(v,0.,1.);\n    //return fract(abs(v));\n    return v < 0. ? -v : v > 1. ? 2.-v : v ;\n}\n\n// halton low discrepancy sequence, from https://www.shadertoy.com/view/wdXSW8\nvoid halton_loop(inout vec2 s, inout vec4 a){\n    const vec2 coprimes = vec2(2.0f, 3.0f);\n    a.xy = a.xy/coprimes;\n    a.zw += a.xy*mod(s, coprimes);\n    s = floor(s/coprimes);\n}\nvec2 halton (int index){\n    vec2 s = vec2(index, index);\n\tvec4 a = vec4(1,1,0,0);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    return a.zw;\n}\n\n\n\n// https://www.shadertoy.com/view/3ddfDj\nvec4 biplanar( sampler2D sam, in vec3 p, in vec3 n, vec3 dpdx, vec3 dpdy )\n{\n    n = abs(n);\n\n    // major axis (in x; yz are following axis)\n    ivec3 ma = (n.x>n.y && n.x>n.z) ? ivec3(0,1,2) :\n               (n.y>n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n    // minor axis (in x; yz are following axis)\n    ivec3 mi = (n.x<n.y && n.x<n.z) ? ivec3(0,1,2) :\n               (n.y<n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n        \n    // median axis (in x;  yz are following axis)\n    ivec3 me = ivec3(3) - mi - ma;\n    \n    // project+fetch\n    vec4 x = textureGrad( sam, vec2(   p[ma.y],   p[ma.z]), \n                               vec2(dpdx[ma.y],dpdx[ma.z]), \n                               vec2(dpdy[ma.y],dpdy[ma.z]) );\n    vec4 y = textureGrad( sam, vec2(   p[me.y],   p[me.z]), \n                               vec2(dpdx[me.y],dpdx[me.z]),\n                               vec2(dpdy[me.y],dpdy[me.z]) );\n    \n    // blend and return\n    vec2 m = vec2(n[ma.x],n[me.x]);\n    m = clamp( (m-0.5773)/(1.0-0.5773), 0.0, 1.0 );\n\n\treturn (x*m.x + y*m.y) / (m.x + m.y);\n}\n\nvec4 triplanar( sampler2D sam, in vec3 p, in vec3 n, vec3 dpdx, vec3 dpdy )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n    \n    vec3 m = pow( abs(n), vec3(8.0) );\n\treturn (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);\n}\n\n\n\n// https://www.shadertoy.com/view/Nls3Rn\n\n#define pack_Snormfloat3x10(x) uintBitsToFloat(packSnorm3x10(x))\n#define unpack_Snormfloat3x10(x) unpackSnorm3x10(floatBitsToUint(x))\n//#define pack_Unormfloat3x10(x) uintBitsToFloat(packSnorm3x10((x-0.5)*2.))\n//#define unpack_Unormfloat3x10(x) (unpackSnorm3x10(floatBitsToUint(x))/2.+0.5)\n\n// NOTE - Unormfloat3x10 above result noticeable \"jump\" when color~=0.5\n// Unormfloat3x10 will down/upscale 0.5+-0.001 to 0.5\n// look last few lines in BufB where pack_Unormfloat3x10 used for TAA feedback\n\n// As solution I use only >0 region of Snorm\n\n#define pack_Unormfloat3x10(x) uintBitsToFloat(packSnorm3x10(x))\n#define unpack_Unormfloat3x10(x) (unpackSnorm3x10(floatBitsToUint(x)))\n\nuint packSnorm3x10(vec3 x) {\n    x = clamp(x,-1., 1.) * 511.;\n    uvec3 sig = uvec3(mix(vec3(0), vec3(1), greaterThanEqual(sign(x),vec3(0))));\n    uvec3 mag = uvec3(abs(x));\n    uvec3 r = sig.xyz << 9 | mag.xyz;\n    return r.x << 22 | r.y << 12 | r.z << 2;\n}\n\nvec3 unpackSnorm3x10(uint x) {\n    uvec3 r = (uvec3(x) >> uvec3(22, 12, 2)) & uvec3(0x3FF);\n    uvec3 sig = r >> 9;\n    uvec3 mag = r & uvec3(0x1FF);\n    vec3 fsig = mix(vec3(-1), vec3(1), greaterThanEqual(sig, uvec3(1)));\n    vec3 fmag = vec3(mag) / 511.;\n    return fsig * fmag;\n}\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n\n// using pathtracer functions https://www.shadertoy.com/view/3dlSW7\n// using reprojection functions https://www.shadertoy.com/view/WdjcDd\n\n// BufB - pathtraced bounce lighting and AO with reprojection of last frame \n// BufB (alpha) save fogLitPercent or Albedo when #define enable_textures set in Common\n\n\n//----------------------------------------------\n\nfloat get_scene_intersect(vec3 ro, vec3 rd, vec3 norm, float cfl){\n    HitInfo hit;\n    //0.002 is light leak\n    return (minDist(ro+0.002*norm, rd, hit, cfl, VOX_LP_shd)?0.:1.);\n}\n\nfloat get_scene_bounce_light(vec3 ro, vec3 rd, vec3 innorm, out vec3 ndir, out vec3 albedo, out vec3 emission, out vec3 norm, float cfl){\n    HitInfo hit;\n    bool d = minDist(ro+innorm*0.002, rd, hit, cfl, VOX_LP_shd);\n    ndir=vec3(0.0001);\n    albedo=vec3(0.0);\n    emission=vec3(0.0);\n    norm = vec3(0.0001);\n    if(d){\n        ndir=ro+rd*hit.t;\n        albedo=hit.color.rgb;\n        emission=hit.emisson;\n        norm = hit.norm;\n    }\n    \n    return d?0.:1.;\n}\n\nvoid get_scene_material(bool d, vec3 pos, vec3 norm, int obj_id, out vec3 albedo, out vec3 emission, \n                        out float roughness, out float metalness){\n    albedo=vec3(0.0);\n    emission=vec3(0.0);\n    roughness=0.0001;\n    metalness=0.0001;\n    // pos+= objpos todo\n    if(d){\n        if(obj_id==OBJ_FLOOR)\n            material_OBJ_FLOOR(pos, norm, albedo, emission, roughness, metalness);\n        else if(obj_id==OBJ_SPHERE_t)\n            material_OBJ_SPHERE(vec2(0.), norm, albedo, emission, roughness, metalness);\n        else if(obj_id>=OBJ_SPHERE)\n            material_OBJ_SPHERE(vec2((obj_id-OBJ_SPHERE)/(500*4),(obj_id-OBJ_SPHERE)%(500*4)), norm, albedo, emission, roughness, metalness);\n    }\n}\n\n//----------------------------------------------\n\n\n\n\n\n// pathtracing functions\n//----------------------------------------------\n\n\n\n\nfloat calculateShadow(vec3 ro, vec3 rd, vec3 normal, float dither, int rays_shadow, float cfl){\n\tfloat shadow = 0.0;\n    float rShadowRays = 1.0 / float(rays_shadow);\n    \n#ifdef use_ConeVector\n    mat3 tbl = calculateTangentMatrix(rd);\n#endif\n\tfor (int i = 0; i < rays_shadow+ANGLE_loops; ++i){\n#ifdef use_ConeVector\n        vec3 dir = tbl * calculateConeVector((float(i) + dither) * rShadowRays, sunAngularDiameter, rays_shadow);\n#else\n        vec3 dir = normalize(rd+radians(sunAngularDiameter)*getCosineWeightedSample(lightDir,0.15));\n#endif\n        float lDotN = dot(dir, normal);\n        if (lDotN <= 0.0) continue;\n        \n        lDotN = sqrt(clamp(lDotN, 0.0, 1.0));\n        \n\t\tfloat light = sunIluminance * lDotN;\n        float rayHit = get_scene_intersect(ro, dir, normal, cfl);\n\t\t\n\t\tshadow += rayHit * light;\n\t}\n    \n    return shadow * rShadowRays;\n}\n\nvec3 calculate_bouncelight_AO(vec3 ro, vec3 rd, vec3 normal, float percentSpecular, float roughness, vec3 sunColor, float noise, float cfl){\t\n    vec3 AO = vec3(0.0);\n    const float rAORays = 1.0 / float(AORays);\n    \n#ifdef sunlight_2nd_bounce\n    vec3 bouncedLight = vec3(0.0);\n    vec3 abso = vec3(1.);\n#endif\n    \n#ifdef use_ConeVector\n    mat3 tbn = calculateTangentMatrix(normal);\n#endif\n\tfor (int i = 0; i < AORays+ANGLE_loops; ++i){\n#ifdef use_ConeVector\n\t\tvec3 dir = tbn * calculateConeVector((float(i) + noise) * rAORays, 90.0, AORays);\n#else\n\t\tvec3 dir = normalize(normal + 5.*getCosineWeightedSample(normal,0.5));\n#endif\n        float lDotN = dot(dir, normal);\n        if (lDotN <= 0.0) continue;\n        \n        lDotN = sqrt(clamp(lDotN, 0.0, 1.0));\n        float lDotU = dot(dir, upVec);\n        float lDotV = dot(dir, lightDir);\n        \n\t\tvec3 light = calculateSky(vec3(0.0), lDotU, lDotV) * lDotN;\n        \n#ifdef sunlight_2nd_bounce\n        vec3 bouncePos;\n        vec3 bounceNormal;\n        vec3 bouncedAlbedo;\n        vec3 bouncedEmissive;\n        float rayHit = get_scene_bounce_light(ro, dir, normal, bouncePos, bouncedAlbedo, bouncedEmissive, bounceNormal, cfl);\n        if(rayHit<0.5)\n        {\n            vec3 bouncedLighting = calculateShadow(bouncePos, lightDir, bounceNormal, noise, 2, cfl)*sunColor;\n            bouncedLighting += abso * (bouncedEmissive + bouncedAlbedo*bouncedLighting);\n            abso *= bouncedAlbedo;\n            bouncedLight += bouncedLighting * (1.0 - rayHit) * lDotN;\n        }\n#else\n        float rayHit = get_scene_intersect(ro, dir, normal, cfl);\n#endif\n\t\tAO += rayHit * light;\n\t}\n    \n    AO = AO * rAORays * 2./PI;\n#ifdef sunlight_2nd_bounce\n    bouncedLight = bouncedLight * rAORays;\n    AO+=bouncedLight;\n#endif\n    \n\treturn AO;\n}\n\n//----------------------------------------------\n\n// volume\n//----------------------------------------------\n#ifdef enable_volume\nfloat raymarchVolume(vec3 ro, vec3 rd, float noise, float cfl){\n    const float rSteps = 1.0 / float(volumeSteps);\n    \n    vec3 start = vec3(0.0);\n    vec3 end = ro;\n    float endDepth = length(end);\n    end /= max(endDepth,0.0001);\n    endDepth = min(length(ro), MAX_DIST);\n    end *= endDepth;\n    \n    vec3 increment = (end - start) * rSteps;\n    vec3 rayPosition = noise * increment + start;\n    \n    float fogLitPercent = 0.0f;\n    for (int i = 0; i < volumeSteps+ANGLE_loops; i++){\n        float volumetricShadow = get_scene_intersect(rayPosition + rd, lightDir, rayPosition + rd, cfl);\n        fogLitPercent = mix(fogLitPercent, volumetricShadow, 1.0 / float(i+1));\n        rayPosition +=  increment;\n     }\n    return fogLitPercent;\n}\n#endif\n//----------------------------------------------\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float timerl = load(TIMER_L, iChannel0);\n    lightDir.xz = lightDir_0.xz*MD(-3.1415926*2.*(1./75.)*(40.+timerl*0.06));\n    lightDir.y=lightDir_0.y+.5*(0.5+0.5*sin(22.*3.1415926*(1./75.)*(40.+timerl*0.06)));\n    lightDir = normalize(lightDir);\n    float camf = load(CAM_F, iChannel0);\n#ifndef use_ConeVector\n    seed = hash12(fragCoord.xy+hash21(float(iFrame%10000)*0.333)*1234.123);\n#endif\n    vec2 fc=fragCoord.xy;\n    vec2 halton_px_shift = vec2(load(HALTON0,iChannel0),load(HALTON1,iChannel0));\n    fragCoord.xy += halton_px_shift;\n\n    vec2 screen_uv = fc.xy / iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    vec3 ro;\n    vec3 rd;\n    SetCamera(uv, iChannel0, ro, rd, iResolution.xy);\n    \n    float noise=0.; \n    \n#ifdef use_ConeVector\n    // noise for ConeVector\n    \n    ivec2 ipx = ivec2(fc);\n    ivec2 reserv = ivec2(5,MEMORY_BOUNDARY.y+5);\n    ipx=ipx%(ivec2(textureSize(iChannel0,0).xy)-reserv);\n    float n0 = texelFetch(iChannel0, textureSize(iChannel0,0).xy-ipx-1, 0).a;\n    noise = fract(n0 + 0.75*float(iFrame % 264) * c_goldenRatioConjugate);\n\n    // test hash12 as noise\n    //vec2 tfc = fc.xy+hash21(float(iFrame%10000)*0.333)*iResolution.y*2.;\n    //noise = hash12(tfc);\n    \n#endif\n\n    vec2 this_id_d = texelFetch(iChannel0, ivec2(fc), 0).xy;\n    int obj_id = int(this_id_d.x);\n    vec3 pos=ro+rd*this_id_d.y;\n    \n    bool rayHit = obj_id>0;\n    vec3 normal;\n    vec3 albedo;\n    vec3 emission;\n    float rough;\n    float metal;\n    \n \n    if(obj_id==OBJ_FLOOR)normal=get_normal_OBJ_FLOOR(pos);\n    if(obj_id>=OBJ_SPHERE_t){vec3 tpx=pos-(vec3(2.,-0.485,2.+0.17)+vec3(sccc.x*0.5,0.,-sccc.y*0.5));normal=get_normal_OBJ_SPHERE(tpx);}\n    if(obj_id>=OBJ_SPHERE){\n        vec3 tpx;\n        ivec2 idx = ivec2((obj_id-OBJ_SPHERE)/(500*4),(obj_id-OBJ_SPHERE)%(500*4));\n        int sidx = idx.y%4;\n        idx.y= idx.y/4;\n        // why sphere position shifted by 0.17 I have no idea\n        //pos+=vec3(0.,0.,-0.17)*1.;\n        if(sidx<2){tpx = pos-vec3(2.+sccc.x*0.5+float(sidx*2-1)*sccc.x*0.5,-0.5,2.)-vec3(sccc.x*float(idx.x),0.,sccc.y*float(idx.y));}\n        else {tpx = pos-vec3(0.,0.,0.0)-vec3(2.+sccc.x*0.5,-0.5,2.-float((sidx%2)*2-1)*sccc.y*0.5)-vec3(sccc.x*float(idx.x),0.,sccc.y*float(idx.y));}\n        tpx+=vec3(0.,0.,-0.17);\n        normal=get_normal_OBJ_SPHERE(tpx);\n    }\n    \n    get_scene_material(rayHit, pos, normal, obj_id, albedo, emission, rough, metal);\n    \n    vec3 sunColor = calculateSunColor(lightDir.y);\n\tvec3 color_light_AO = calculate_bouncelight_AO(pos, rd, normal, metal, rough, sunColor, noise, camf);\n    \n    vec3 shadow = calculateShadow(pos, lightDir, normal, noise, shadowRays, camf)*sunColor;\n    vec3 color = mix(color_light_AO+shadow,vec3(0.),dot(emission,vec3(1.))/3.);\n    color = mix(albedo*color, emission, dot(emission,vec3(1.))/3.);\n    if (!rayHit) \n    {\n        float lDotU = dot(rd, upVec);\n        float lDotV = dot(rd, lightDir);\n        color=vec3(0.);\n        color = calculateSun(lDotV)*calculateSunColor(lightDir.y);\n        color = calculateSky(color, lDotU, lDotV);\n    }\n    \n    float fogLitPercent = 0.;\n#ifdef enable_textures\n    fogLitPercent = pack_Unormfloat3x10(triplanar( iChannel3, pos, normal, dFdx(pos), dFdy(pos) ).rgb);\n    // avoiding dfd bugs\n    if(obj_id==OBJ_SKY)fogLitPercent=pack_Unormfloat3x10(vec3(1.));\n#else\n#ifdef enable_volume\n    #ifdef use_ConeVector\n    fogLitPercent = raymarchVolume(pos - ro, ro, noise, camf);\n    #else\n    fogLitPercent = raymarchVolume(pos - ro, ro, hash11_seed());\n    #endif\n#endif\n#endif\n    \n    color = max(color, 0.0);\n    bool input_registered = load(INPUT0,iChannel0)>1.;\n    fragColor = vec4(color, fogLitPercent);\n    //protection when camera go inside of shape and intersection function may return inf or nan\n    fragColor=clamp(fragColor,0.,100.); \n#ifdef enable_textures\n    fragColor.a = fogLitPercent;\n#endif\n#ifdef use_reproject_TAA\n    // reprojection TAA\n    bool res_ch = load(RES_CHANGE,iChannel0)<0.5;\n    if(input_registered||res_ch){\n        vec4 oldCol = previousSample(ro, pos,iChannel0, iChannel0, iChannel1, iResolution.xy);\n        float factor = (oldCol.a == 0.||res_ch) ? 0. : .95;\n        fragColor.rgb = mix(fragColor.rgb, oldCol.rgb, factor);\n#ifndef enable_textures\n        fragColor.a = mix(fragColor.a, oldCol.a, factor*0.75); \n#endif\n        //fragColor.a=fogLitPercent; // to disable reproj for volumtertic shadow\n    }else\n#endif\n    // default TAA\n    {\n        vec4 backColor = texelFetch(iChannel1, ivec2(fc),0);\n        float iot = smoothstep(5.5,12.5,load(INPUT0_timer, iChannel0));\n        fragColor.rgb = mix(fragColor.rgb, backColor.rgb, (0.95+0.048*iot) * (1.-float(input_registered)));\n#ifndef enable_textures\n        fragColor.a = mix(fragColor.a, backColor.a, (0.95+0.048*iot) * (1.-float(input_registered)));\n#else\n        fragColor.a = pack_Unormfloat3x10(mix(unpack_Unormfloat3x10(fragColor.a), unpack_Unormfloat3x10(backColor.a), (0.95+0.048*iot) * (1.-float(input_registered))));\n#endif\n        \n    }\n#ifndef enable_textures\n    fragColor.a=max(fragColor.a,0.00001); // reprojection flag for previousSample in Comon, it return alpha 0. when no reprojection\n#endif\n}\n\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n\n// using https://www.shadertoy.com/view/3dlSW7\n// using https://www.shadertoy.com/view/WdjcDd\n\n// fragColor = vec4(color, absorb); // absorb for volumetric, volumetric rendered in Image\n\n//----------------------------------------------\n\n\nfloat get_scene_intersect(vec3 ro, vec3 rd, vec3 norm, float cfl){\n    HitInfo hit;\n    //0.002 is light leak\n    return (minDist(ro+0.002*norm, rd, hit, cfl, VOX_LP_shd)?0.:1.);\n}\n\nfloat get_scene_bounce_light(vec3 ro, vec3 rd, vec3 innorm, out vec3 ndir, out vec3 albedo, out vec3 emission, out vec3 norm, float cfl){\n    HitInfo hit;\n    bool d = minDist(ro+innorm*0.002, rd, hit, cfl, VOX_LP_shd);\n    ndir=vec3(0.0001);\n    albedo=vec3(0.0);\n    emission=vec3(0.0);\n    norm = vec3(0.0001);\n    if(d){\n        ndir=ro+rd*hit.t;\n        albedo=hit.color.rgb;\n        emission=hit.emisson;\n        norm = hit.norm;\n    }\n    \n    return d?0.:1.;\n}\n\nvoid get_scene_material(bool d, vec3 pos, vec3 norm, int obj_id, out vec3 albedo, out vec3 emission, \n                        out float roughness, out float metalness){\n    albedo=vec3(0.0);\n    emission=vec3(0.0);\n    roughness=0.0001;\n    metalness=0.0001;\n    // pos+= objpos todo\n    if(d){\n        if(obj_id==OBJ_FLOOR)\n            material_OBJ_FLOOR(pos, norm, albedo, emission, roughness, metalness);\n        else if(obj_id==OBJ_SPHERE_t)\n            material_OBJ_SPHERE(vec2(0.), norm, albedo, emission, roughness, metalness);\n        else if(obj_id>=OBJ_SPHERE)\n            material_OBJ_SPHERE(vec2((obj_id-OBJ_SPHERE)/(500*4),(obj_id-OBJ_SPHERE)%(500*4)), norm, albedo, emission, roughness, metalness);\n    }\n}\n\n//----------------------------------------------\n\n\n\n\n\n// pathtracing functions\n//----------------------------------------------\n\nfloat calculateFresnel(float cosTheta, float f0){\n    cosTheta = 1.0 - cosTheta;\n\tcosTheta = cosTheta * cosTheta * cosTheta * cosTheta * cosTheta;\n    \n    return cosTheta * (1.0 - f0) + f0;\n}\n\n#ifdef enable_reflections\nvec3 calculateReflection(vec3 ro, vec3 rd, vec3 normal, float percentSpecular, float roughness, vec3 totalLighting, float noise, float cfl){\t\n\n#ifdef use_ConeVector\n    mat3 tbn = calculateTangentMatrix(normal);\n#endif\n    vec3 reflection = vec3(0.0);\n    float rReflectionRays = 1.0 / float(reflectionRays);\n    float fresnel = 0.0;\n\n    for (int i = 0; i < reflectionRays+ANGLE_loops; ++i){\n#ifdef use_ConeVector\n        vec3 dir = tbn * calculateRoughSpecular(fract((float(i) + noise) * rReflectionRays), reflectionRays, roughness);\n#else\n        vec3 dir = normalize(normal + 3.5*roughness*roughness*getCosineWeightedSample(normal,0.1+0.4*roughness));\n#endif\n        dir = reflect(rd, dir);\n\n        float lDotN = dot(dir, normal);\n        float f = lDotN;\n        if (lDotN <= 0.0) continue;\n\n        float lDotU = dot(dir, upVec);\n        float lDotV = dot(dir, lightDir);\n\n        fresnel += calculateFresnel(f, percentSpecular);\n\n        vec3 light = calculateSky(vec3(0.0), lDotU, lDotV);\n        \n#ifdef reflection_color_emi\n        vec3 bouncePos;\n        vec3 bounceNormal;\n        vec3 bouncedAlbedo;\n        vec3 bouncedEmissive;\n        float rayHit = get_scene_bounce_light(ro, dir, normal, bouncePos, bouncedAlbedo, bouncedEmissive, bounceNormal, cfl);\n        reflection += rayHit * light;\n        reflection += (1.-rayHit) * bouncedEmissive;\n#else\n        float rayHit = get_scene_intersect(ro, dir, normal);\n        reflection += rayHit * light;\n#endif\n    }\n    \n    reflection = reflection * rReflectionRays;\n    fresnel = fresnel * rReflectionRays;\n\n    totalLighting = mix(totalLighting, reflection, fresnel);\n\t\n\treturn totalLighting;\n}\n#endif\n//----------------------------------------------\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float timerl = load(TIMER_L, iChannel0);\n    lightDir.xz = lightDir_0.xz*MD(-3.1415926*2.*(1./75.)*(40.+timerl*0.06));\n    lightDir.y=lightDir_0.y+.5*(0.5+0.5*sin(22.*3.1415926*(1./75.)*(40.+timerl*0.06)));\n    lightDir = normalize(lightDir);\n    float camf = load(CAM_F, iChannel0);\n#ifndef use_ConeVector\n    seed = hash12(fragCoord.xy+hash21(float(iFrame%10000)*0.333)*1234.123);\n#endif\n    vec2 fc=fragCoord.xy;\n    vec2 halton_px_shift = vec2(load(HALTON0,iChannel0),load(HALTON1,iChannel0));\n    fragCoord.xy += halton_px_shift;\n\n    vec2 screen_uv = fc.xy / iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    vec3 ro;\n    vec3 rd;\n    SetCamera(uv, iChannel0, ro, rd, iResolution.xy);\n    \n    \n    float noise=0.; \n    \n#ifdef use_ConeVector\n    // noise for ConeVector\n    \n    ivec2 ipx = ivec2(fc);\n    ivec2 reserv = ivec2(5,MEMORY_BOUNDARY.y+5);\n    ipx=ipx%(ivec2(textureSize(iChannel0,0).xy)-reserv);\n    float n0 = texelFetch(iChannel0, textureSize(iChannel0,0).xy-ipx-1, 0).a;\n    noise = fract(n0 + 0.75*float(iFrame % 264) * c_goldenRatioConjugate);\n\n    // test hash12 as noise\n    //vec2 tfc = fc.xy+hash21(float(iFrame%10000)*0.333)*iResolution.y*2.;\n    //noise = hash12(tfc);\n    \n#endif\n\n    vec2 this_id_d = texelFetch(iChannel0, ivec2(fc), 0).xy;\n    int obj_id = int(this_id_d.x);\n    vec3 pos=ro+rd*this_id_d.y;\n    \n    bool rayHit = obj_id>0;\n    vec3 normal;\n    vec3 albedo;\n    vec3 emission;\n    float rough;\n    float metal;\n    \n    if(obj_id==OBJ_FLOOR)normal=get_normal_OBJ_FLOOR(pos);\n    if(obj_id>=OBJ_SPHERE_t){vec3 tpx=pos-(vec3(2.,-0.145,2.)+vec3(sccc.x*0.5,0.,-sccc.y*0.5));normal=get_normal_OBJ_SPHERE(tpx);}\n    //if(obj_id>=OBJ_SPHERE_t){vec3 tpx=pos+vec3(0.,-0.,0.);normal=get_normal_OBJ_SPHERE(tpx);}\n\n    if(obj_id>=OBJ_SPHERE){\n        vec3 tpx;\n        ivec2 idx = ivec2((obj_id-OBJ_SPHERE)/(500*4),(obj_id-OBJ_SPHERE)%(500*4));\n        int sidx = idx.y%4;\n        idx.y= idx.y/4;\n        // why sphere position shifted by 0.17 I have no idea\n        //pos+=vec3(0.,0.,-0.17)*1.;\n        if(sidx<2){tpx = pos-vec3(2.+sccc.x*0.5+float(sidx*2-1)*sccc.x*0.5,-0.5,2.)-vec3(sccc.x*float(idx.x),0.,sccc.y*float(idx.y));}\n        else {tpx = pos-vec3(2.+sccc.x*0.5,-0.5,2.-float((sidx%2)*2-1)*sccc.y*0.5)-vec3(sccc.x*float(idx.x),0.,sccc.y*float(idx.y));}\n        tpx+=vec3(0.,0.,-0.17);\n        normal=get_normal_OBJ_SPHERE(tpx);\n    }\n    get_scene_material(rayHit, pos, normal, obj_id, albedo, emission, rough, metal);\n    \n    vec3 sunColor = calculateSunColor(lightDir.y);\n    vec3 color = texelFetch(iChannel1, ivec2(fc), 0).rgb;\n#ifdef enable_reflections\n    color = calculateReflection(pos, rd, normal, metal, rough, color, noise, camf);\n#endif\n\n\tfloat lDotU = dot(rd, upVec);\n\tfloat lDotV = dot(rd, lightDir);\n\t\n    if (!rayHit) \n    {\n        color = vec3(0.0);\n        color += calculateSun(lDotV)*calculateSunColor(lightDir.y);\n        color = calculateSky(color, lDotU, lDotV);\n    }\n    float absorb = 0.;\n    \n#ifdef enable_textures\n    absorb = texelFetch(iChannel1, ivec2(fc), 0).a;\n#else\n#ifdef enable_volume\n    float depth = length(ro-pos);\n    absorb = exp(-depth * volume_fogDensity);\n    absorb = clamp(absorb,.25,1.);\n    absorb = 1.-(1.-smoothstep(MAX_DIST-MAX_DIST*0.1,MAX_DIST,depth))*(1.-absorb);\n#endif\n#endif\n    \n    color = max(color, 0.0);\n    bool input_registered = load(INPUT0,iChannel0)>1.;\n    fragColor = vec4(color, absorb);\n    //protection when camera go inside of shape and intersection function may return inf or nan\n    fragColor.rgb=clamp(fragColor.rgb,0.,100.); \n#ifdef use_reproject_TAA\n    // reprojection TAA\n    bool res_ch = load(RES_CHANGE,iChannel0)<0.5;\n    if(input_registered||res_ch){\n        vec4 oldCol = previousSample(ro, pos,iChannel0, iChannel0, iChannel2, iResolution.xy);\n        float factor = (oldCol.a == 0.||res_ch) ? 0. : .90;\n        fragColor.rgb = mix(fragColor.rgb, oldCol.rgb, factor);\n#ifndef enable_textures\n        fragColor.a = mix(fragColor.a, oldCol.a, factor*0.75); \n#endif\n        //fragColor.a=absorb; // to disable reproj for volumtertic shadow\n    }else\n#endif\n    // default TAA\n    {\n        vec4 backColor = texture(iChannel2, screen_uv);\n        float iot = smoothstep(5.5,12.5,load(INPUT0_timer, iChannel0));\n        fragColor.rgb = mix(fragColor.rgb, backColor.rgb, (0.905+0.08*iot) * (1.-float(input_registered)));\n#ifndef enable_textures\n        fragColor.a = mix(fragColor.a, backColor.a, (0.905+0.08*iot) * (1.-float(input_registered)));\n#else\n        fragColor.a = fragColor.a; //copy BufB texture color\n#endif\n    }\n#ifndef enable_textures\n    fragColor.a=max(fragColor.a,0.00001); // reprojection flag for previousSample in Comon, it return alpha 0. when no reprojection\n#endif\n    \n}\n\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\n#ifndef use_dynamic_TAA\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    discard;\n}\n#else\n\n// from https://www.shadertoy.com/view/DsfGWX\n\n#define ENABLE_TAA\n#define TEMPORAL_REPROJECT\n\n#define VARIANCE_CLIPPING\n\n// debug\n//#define SHOW_MOTION\n//#define SHOW_DISOCCLUSION\n\n// TAA\n// alpha of this shader is unused, it used to store curr_d but hist.a used only in SHOW_DISOCCLUSION\n// when define enable_volume set - this Alpha used to filter absorb from BufC - so debug wont work here\n\n#define EPS 1e-4\n\n\n\n#define OFFSET_COUNT 4\n\nconst ivec2 off[OFFSET_COUNT] = ivec2[OFFSET_COUNT](\n \tivec2( 1,  0), ivec2( 0, -1), \n\tivec2( 0,  1), ivec2(-1,  0)\n);\n/*\n#define OFFSET_COUNT 8\n\nconst ivec2 off[OFFSET_COUNT] = ivec2[OFFSET_COUNT](\n    ivec2(-1, -1), ivec2(-1,  1), \n\tivec2( 1, -1), ivec2( 1,  1), \n\tivec2( 1,  0), ivec2( 0, -1), \n\tivec2( 0,  1), ivec2(-1,  0)\n);\n*/\n\n\nvec3 rgb2ycocg(in vec3 rgb)\n{\nreturn rgb;\n    float co = rgb.r - rgb.b;\n    float t = rgb.b + co / 2.0;\n    float cg = rgb.g - t;\n    float y = t + cg / 2.0;\n    return vec3(y, co, cg);\n}\n\n\nvec3 ycocg2rgb(in vec3 ycocg)\n{\nreturn ycocg;\n    float t = ycocg.r - ycocg.b / 2.0;\n    float g = ycocg.b + t;\n    float b = t - ycocg.g / 2.0;\n    float r = ycocg.g + b;\n    return vec3(r, g, b);\n}\n\nvec3 RGBtoYCoCg(vec3 c)\n{\nreturn c;\n    //return rgb2ycocg(c);\n    return mat3(0.25, 0.5, -0.25, 0.5, 0, 0.5, 0.25, -0.5, -0.25) * c;\n}\n\nvec3 YCoCgToRGB(vec3 c)\n{\nreturn c;\n    //return ycocg2rgb(c);\n    return mat3(1, 1, 1, 1, 0, -1, -1, 1, -1) * c;\n}\n\nvec4 clipToAABB(in vec4 cOld, in vec4 cNew, in vec4 center, in vec4 halfSize)\n{\n    vec4 r = cOld - cNew;\n    vec4 m = (center + halfSize) - cNew;\n    vec4 n = (center - halfSize) - cNew;\n    \n    if (r.x > m.x + EPS)\n\t\tr *= (m.x / r.x);\n\tif (r.y > m.y + EPS)\n\t\tr *= (m.y / r.y);\n\tif (r.z > m.z + EPS)\n\t\tr *= (m.z / r.z);\n    if (r.w > m.w + EPS)\n\t\tr.w *= (m.w / r.w);\n\n\tif (r.x < n.x - EPS)\n\t\tr *= (n.x / r.x);\n\tif (r.y < n.y - EPS)\n\t\tr *= (n.y / r.y);\n\tif (r.z < n.z - EPS)\n\t\tr *= (n.z / r.z);\n    if (r.w < n.w - EPS)\n\t\tr.w *= (n.w / r.w);\n\n\treturn cNew + r;\n}\n\nvec4 SampleTextureCatmullRom(sampler2D tex, vec2 texSize, vec2 uv)\n{\n    vec2 samplePos = uv * texSize;\n    vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n\n    vec2 f = samplePos - texPos1;\n\n    vec2 w0 = f * ( -0.5 + f * (1.0 - 0.5*f));\n    vec2 w1 = 1.0 + f * f * (-2.5 + 1.5*f);\n    vec2 w2 = f * ( 0.5 + f * (2.0 - 1.5*f) );\n    vec2 w3 = f * f * (-0.5 + 0.5 * f);\n    \n    vec2 w12 = w1 + w2;\n    vec2 offset12 = w2 / w12;\n\n    vec2 texPos0 = texPos1 - vec2(1.0);\n    vec2 texPos3 = texPos1 + vec2(2.0);\n    vec2 texPos12 = texPos1 + offset12;\n\n    texPos0 /= texSize;\n    texPos3 /= texSize;\n    texPos12 /= texSize;\n\n    vec4 result = vec4(0.0);\n    result += textureLod(tex, vec2(texPos0.x,  texPos0.y), 0.) * w0.x * w0.y;\n    result += textureLod(tex, vec2(texPos12.x, texPos0.y), 0.) * w12.x * w0.y;\n    result += textureLod(tex, vec2(texPos3.x,  texPos0.y), 0.) * w3.x * w0.y;\n\n    result += textureLod(tex, vec2(texPos0.x,  texPos12.y), 0.) * w0.x * w12.y;\n    result += textureLod(tex, vec2(texPos12.x, texPos12.y), 0.) * w12.x * w12.y;\n    result += textureLod(tex, vec2(texPos3.x,  texPos12.y), 0.) * w3.x * w12.y;\n\n    result += textureLod(tex, vec2(texPos0.x,  texPos3.y), 0.) * w0.x * w3.y;\n    result += textureLod(tex, vec2(texPos12.x, texPos3.y), 0.) * w12.x * w3.y;\n    result += textureLod(tex, vec2(texPos3.x,  texPos3.y), 0.) * w3.x * w3.y;\n\n    return result;\n}\n\nfloat distancePixel22( vec2 prevFragCoord, vec3 pos, sampler2D samplerx, vec2 ires, vec3 p_ro, vec3 p_rd){\n    if(  min(ires.xy-1., prevFragCoord) != prevFragCoord\n      || max(vec2(0.)      , prevFragCoord) != prevFragCoord) return MAX_DIST;\n    \n    float prev_d = textureLod(samplerx, prevFragCoord/ires.xy,0.).a;\n    vec3 prevPos = p_ro + p_rd*prev_d;\n    return length(prevPos-pos);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float a = .1;\n    \n    ivec2 ipx = ivec2(fragCoord);\n    \n    // adding halton_px_shift to fragCoord not needed\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    vec2 halton_px_shift = vec2(load(HALTON0,iChannel0),load(HALTON1,iChannel0));\n    float curr_d = textureLod(iChannel0, (fragCoord - halton_px_shift) / iResolution.xy, 0.).y;\n    vec4 curr_color = textureLod(iChannel2, (fragCoord - halton_px_shift) / iResolution.xy, 0.).rgba;\n    vec3 curr_texture_col = vec3(1.);\n    \n#ifdef enable_textures\n    //texelFetch because data packed\n    curr_texture_col = unpack_Unormfloat3x10(texelFetch(iChannel2, ivec2(fragCoord - halton_px_shift), 0).a);\n#endif\n    vec4 new = vec4(RGBtoYCoCg(curr_color.rgb*curr_texture_col),curr_color.a);\n\n#ifdef TEMPORAL_REPROJECT\n\n    vec3 ro;\n    vec3 rd;\n    SetCamera(uv, iChannel0, ro, rd, iResolution.xy);\n    \n    vec3 pro;\n    vec3 prd;\n    SetCamera_prev(uv, iChannel0, pro, prd, iResolution.xy);\n    \n    vec3 pos = ro + rd * curr_d;\n    \n    // adding prevUv to fragCoord not needed\n    vec2 prevUv = pos2uv(pos, iChannel0, iResolution.xy);\n    vec2 prevFragCoord = prevUv * iResolution.y + iResolution.xy/2.0;\n    vec2 puv = prevFragCoord/iResolution.xy;\n    \n    \n    //vec4 hist = texture(iChannel3, puv);\n    //vec4 hist = getTextureSmooth(iChannel3, iResolution.xy, puv);\n    vec4 hist = SampleTextureCatmullRom(iChannel3, iResolution.xy, puv);\n\n    vec4 old = vec4(RGBtoYCoCg(hist.rgb),hist.a);\n#else\n    ivec2 sp = ivec2(fragCoord);\n    vec4 old = vec4(RGBtoYCoCg(texelFetch(iChannel3, sp, 0).rgb),texelFetch(iChannel3, sp, 0).a);\n#endif\n\n#ifdef VARIANCE_CLIPPING\n    vec4 avg = new;\n    vec4 var = new * new;\n    \n    for (int i = 0; i < OFFSET_COUNT; i++)\n    {\n        vec4 tex_data = texelFetch(iChannel2, ipx + off[i], 0);\n        vec3 tex_color = vec3(1.);\n#ifdef enable_textures\n        tex_color = unpack_Unormfloat3x10(tex_data.a);\n#endif\n        vec4 tex = vec4(RGBtoYCoCg(tex_data.rgb*tex_color),tex_data.a);\n        \n        avg += tex;\n        var += tex * tex;\n    }\n    avg /= float(OFFSET_COUNT + 1);\n    var /= float(OFFSET_COUNT + 1);\n\n    vec4 sig = sqrt(max(var - avg * avg, vec4(0)));\n    \n    const float g = 1.;\n    vec4 cmin = avg - sig * g;\n    vec4 cmax = avg + sig * g;\n    \n    #if 0\n    vec4 clip = clamp(old, cmin, cmax);\n    #else\n    vec4 clip = clipToAABB(old, clamp(avg, cmin, cmax), avg, sig);\n    #endif\n    \n    old = mix(old, clip, 1.);\n#endif\n    bool res_ch = load(RES_CHANGE,iChannel0)<0.5;\n    vec4 col = iFrame != 0 && !res_ch ? mix(old, new, a) : new;\n#ifdef ENABLE_TAA\n#ifdef enable_volume\n    fragColor = vec4(YCoCgToRGB(col.rgb), col.a);\n#else\n    fragColor = vec4(YCoCgToRGB(col.rgb), curr_d);\n#endif\n    float iot = smoothstep(1.5,4.5,load(INPUT0_timer, iChannel0));\n    if(iot>0.001){\n        curr_color = textureLod(iChannel2, fragCoord / iResolution.xy, 0.).rgba;\n        curr_texture_col = vec3(1.);\n    #ifdef enable_textures\n        //texelFetch because data packed\n        curr_texture_col = unpack_Unormfloat3x10(texelFetch(iChannel2, ivec2(fragCoord), 0).a);\n    #endif\n        fragColor.rgb = mix(fragColor.rgb,curr_color.rgb*curr_texture_col,iot);\n    }\n#else\n    fragColor = vec4(texelFetch(iChannel2, ivec2(fragCoord), 0).rgb, curr_d);\n#endif\n\n\n#ifdef SHOW_DISOCCLUSION\n\n    if (puv.x < 0. || puv.x >= 1. || puv.y < 0. || puv.y >= 1. ||\n        distance(pos, (pro+prd*hist.a)) > 2.*0.1*curr_d)\n    {\n        fragColor = vec4(1, 0, 0, curr_d);\n    }\n#endif\n\n#ifdef SHOW_MOTION\n    fragColor = vec4((fragCoord/iResolution.xy - puv) * 50., 0, curr_d);\n#endif\n    fragColor.rgb=clamp(fragColor.rgb,0.,100.); // seems color can be little negative\n}\n#endif","name":"Buffer D","description":"","type":"buffer"}]}