{"ver":"0.1","info":{"id":"XfVSDD","date":"1717221718","viewed":287,"name":"Triangle DDA","username":"Xor","description":"Experimenting with non-square grids and DDA","likes":28,"published":1,"flags":0,"usePreview":1,"tags":["2d","voxel","dda"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    \"Triangle DDA\" by @XorDev\n    \n    Experimenting with non-square grids and DDA\n\n    Written for my voxel tutorial:\n    mini.gmshaders.com/p/voxels-draft\n*/\n\n//Grid scale\n#define SCALE 50.0\n//Max voxel steps\n#define MAX 100.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //2D to triangle grid\n    mat3x2 tri = mat3x2(-1,0, 0.5,0.866, 0.5,-0.866);\n    //Resolution for scaling\n    vec2 res = iResolution.xy;\n    //Mouse control or wandering light point\n    vec2 light = iMouse.z<=0.0? (1.-cos(iTime*vec2(1,1.618))*.4)*res*.5: iMouse.xy;\n    //Pixel to triangle coordinates\n    vec3 coord = (res*0.5 - fragCoord) * tri /res.y*SCALE+SCALE;\n    //Mouse to triangle coordinates\n    vec3 mouse = (res*0.5 - light    ) * tri /res.y*SCALE+SCALE;\n    //Ray direction in triangel space\n    vec3 dir = normalize(mouse - coord);\n    //Prevent division by 0 errors\n    dir += vec3(dir.x==0.0, dir.y==0.0, dir.z==0.0) * 1e-5;\n    \n    //Sign direction for each axis\n    vec3 sig = sign(dir);\n    //Step size for each axis\n    vec3 stp = sig / dir;\n    \n    //Voxel positions\n    vec3 vox = floor(coord);\n    vec3 mou = floor(mouse);\n    //Initial step sizes to the next voxel\n    vec3 dep = ((vox-coord + 0.5) * sig + 0.5) * stp;\n    \n    //Axis index\n    vec3 axi;\n    \n    //Loop iterator\n    float steps = 0.0;\n    //Loop through voxels\n    for(float i = 0.0; i<MAX; i++)\n    {\n        //Check map and stop on hit\n        if (texture(iChannel0,.71-(tri * vox)/8e2).r<.8) break;\n        //Don't cast past light source\n        if (length(vox-mou)<.5) {steps = MAX; break;}\n        \n        //Increment steps\n        steps++;\n        \n        //Select the closest voxel axis\n        axi = dep.x<dep.z? \n            ( dep.x<dep.y? vec3(1,0,0) : vec3(0,1,0) ):\n            ( dep.z<dep.y? vec3(0,0,1) : vec3(0,1,0) );\n        //Step one voxel along this axis\n        vox += sig * axi;\n        //Set the length to the next voxel\n        dep += stp * axi;\n    }\n    //Get normal\n    vec3 nor = sig*axi;\n    //Background light attenuation\n    vec3 back = vec3(1) / (1.0+length(coord - mouse) / 2e1);\n    //Draw occluders and background\n    vec3 col = mix(vec3(steps<0.5), back, steps/MAX);\n    //Colored axes grid\n    vec3 grid = max(1.0-abs(fract(coord+0.5)-0.5) * res.y / SCALE,0.0);\n    //Blend with output color\n    col = mix(col+grid*.5,grid,length(grid)*.1);\n    //Square for contrast (incorrect gamma)\n    fragColor = vec4(col*col,1);\n}","name":"Image","description":"","type":"image"}]}