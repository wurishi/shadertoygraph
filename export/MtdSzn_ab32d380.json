{"ver":"0.1","info":{"id":"MtdSzn","date":"1478488950","viewed":423,"name":"FABRIK demo #1","username":"mplanck","description":"Playing around with the realtime IK algorithm in this paper: http://www.sciencedirect.com/science/article/pii/S1524070311000178. Next version, I'll be trying constraints. Click mouse to drive IK target.","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["distancemarching","fabrik","iksolve"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Click and drag mouse to drive IK target\n// TODO: show the pick plane \n// TODO: add joint constraints\n// TODO: do something more creative with the joints - day of the tentacle perhaps\n\n// Tested on 13-inch Mac Powerbook Chrome\n// Tested on Nvidia GTX 1080 Windows 10 Chrome\n\n// **************************************************************************\n// CONSTANTS\n\n#define PI 3.14159\n#define TWO_PI 6.28318\n#define PI_OVER_TWO 1.570796\n#define ONE_OVER_PI 0.318310\n\n#define SMALL_FLOAT 0.0001\n#define BIG_FLOAT 1000000.\n\n// **************************************************************************\n// MATERIAL DEFINES\n\n#define SPHERE_MATL 1.\n#define CHAMBER_MATL 2.\n#define BOND_MATL 3.\n#define PLANE_MATL 4.\n\n#define NUM_PTS 9\n#define NUM_SEGS 8\n\n#define MAX_ITERATIONS 6\n// **************************************************************************\n// GLOBALS\n\nvec3  g_camPointAt   = vec3(0.);\nvec3  g_camOrigin    = vec3(0.);\n\nfloat g_time         = 0.;\n\nvec3  g_ldir         = vec3(.8, 1., 0.);\n\n\nstruct Arm\n{    \n    vec3 pts[NUM_PTS]; \n    float segs[NUM_SEGS];\n} g_arm;\n\n// **************************************************************************\n// UTILITIES\n\n\nfloat pow5(float v)\n{\n    float tmp = v*v;\n    return tmp*tmp*v;\n}\n\n// Rotate the input point around the y-axis by the angle given as a\n// cos(angle) and sin(angle) argument.  There are many times where  I want to\n// reuse the same angle on different points, so why do the heavy trig twice.\n// Range of outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\n\nvec3 rotateAroundYAxis( vec3 point, float cosangle, float sinangle )\n{\n    return vec3(point.x * cosangle  + point.z * sinangle,\n        point.y,\n        point.x * -sinangle + point.z * cosangle);\n}\n\n// Rotate the input point around the x-axis by the angle given as a\n// cos(angle) and sin(angle) argument.  There are many times where  I want to\n// reuse the same angle on different points, so why do the  heavy trig twice.\n// Range of outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\n\nvec3 rotateAroundXAxis( vec3 point, float cosangle, float sinangle )\n{\n    return vec3(point.x,\n        point.y * cosangle - point.z * sinangle,\n        point.y * sinangle + point.z * cosangle);\n}\n\nvec2 mergeobjs(vec2 a, vec2 b) \n{\n    if (a.x < b.x) { return a; } \n    else { return b; }\n    \n    // XXX: Some architectures have bad optimization paths\n    // that will cause inappropriate branching if you DON'T\n    // use an if statement here.\n    \n    //return mix(b, a, step(a.x, b.x)); \n}\n\n\n// Reference: http://geomalgorithms.com/a05-_intersect-1.html. Does an\n// intersection test against a plane that is assumed to be double sided and\n// passes through the plane_origin and has the specified normal. *Overkill* \n// for intersecting with the x-z plane.\n\n// Returns a vec2 where:\n//   result.x = 1. or 0. if there is a hit\n//   result.y = t such that ray_origin + t*ray_direction = intersection point\nvec2 intersect_plane(vec3 ray_origin,\n                     vec3 ray_direction,\n                     vec3 plane_normal,\n                     vec3 plane_origin)\n{\n    float ray_direction_dot_normal = dot(ray_direction, plane_normal);\n\n    float denominator = ray_direction_dot_normal;    \n    float intersected = 0.;\n\n    float t = BIG_FLOAT;\n    // If the denominator is not a really small number (positive or negative)\n    // then an intersection took place.  If it is really small, then the ray\n    // is parallel to the given plane.\n    if (abs(denominator) > SMALL_FLOAT) {\n        t = -dot(plane_normal, (ray_origin - plane_origin)) / denominator;    \n        if (t > SMALL_FLOAT) {\n            intersected = 1.;\n        }\n    }\n    return vec2(intersected, t);\n\n}\n\n// **************************************************************************\n// DISTANCE FIELDS\n\nfloat spheredf( vec3 pos, float r ) \n{\n    return length( pos ) - r;\n}\n\nfloat segmentdf( vec3 p, vec3 a, vec3 b, float r)\n{\n    \n    vec3 ba = b - a;    \n    float t = dot(ba, (p - a)) / max(SMALL_FLOAT, dot(ba, ba));\n    t = clamp(t, 0., 1.);\n    return length(ba * t + a - p) - r;\n}\n\nfloat planedf( vec3 pos, float y)\n{\n    return abs(pos.y - y);\n}\n\n// **************************************************************************\n// SCENE MARCHING\n\nvec2 armobj(vec3 p, float mr)\n{    \n\n    vec2 ballsobj = vec2(BIG_FLOAT, SPHERE_MATL);\n   \tvec3 ap = p;\n    \n    // unrolling the for loop sped things up from 21 fps to 35 fps on my\n    // 13 inch MacBook Pro, so be mindful if NUM_PTS changes.\n\n    ballsobj.x = min( ballsobj.x, spheredf(ap - g_arm.pts[0], mr));\n    ballsobj.x = min( ballsobj.x, spheredf(ap - g_arm.pts[1], mr));\n    ballsobj.x = min( ballsobj.x, spheredf(ap - g_arm.pts[2], mr));\n    ballsobj.x = min( ballsobj.x, spheredf(ap - g_arm.pts[3], mr));\n    ballsobj.x = min( ballsobj.x, spheredf(ap - g_arm.pts[4], mr));\n    ballsobj.x = min( ballsobj.x, spheredf(ap - g_arm.pts[5], mr));\n    ballsobj.x = min( ballsobj.x, spheredf(ap - g_arm.pts[6], mr));\n    ballsobj.x = min( ballsobj.x, spheredf(ap - g_arm.pts[7], mr));\n    ballsobj.x = min( ballsobj.x, spheredf(ap - g_arm.pts[8], mr));\n\n    vec2 bondsobj = vec2(BIG_FLOAT, BOND_MATL);\n\n    float br = .3 * mr;\n    bondsobj.x = min(bondsobj.x, segmentdf(ap, g_arm.pts[0], g_arm.pts[1], br));\n    bondsobj.x = min(bondsobj.x, segmentdf(ap, g_arm.pts[1], g_arm.pts[2], br));\n    bondsobj.x = min(bondsobj.x, segmentdf(ap, g_arm.pts[2], g_arm.pts[3], br));\n    bondsobj.x = min(bondsobj.x, segmentdf(ap, g_arm.pts[3], g_arm.pts[4], br));\n    bondsobj.x = min(bondsobj.x, segmentdf(ap, g_arm.pts[4], g_arm.pts[5], br));\n    bondsobj.x = min(bondsobj.x, segmentdf(ap, g_arm.pts[5], g_arm.pts[6], br));\n    bondsobj.x = min(bondsobj.x, segmentdf(ap, g_arm.pts[6], g_arm.pts[7], br));\n    bondsobj.x = min(bondsobj.x, segmentdf(ap, g_arm.pts[7], g_arm.pts[8], br));\n\n    return mergeobjs(ballsobj, bondsobj);\n}\n\nvec2 chamberobj(vec3 p)\n{\n    return vec2(15. - length(p), CHAMBER_MATL);\n}\n\nvec2 planeobj(vec3 p)\n{\n    return vec2(planedf(p, -2.), PLANE_MATL);\n}\n\n\nvec2 scenedf( vec3 p )\n{\n    vec2 obj = armobj( p, .22 );\n    \n    obj = mergeobjs(chamberobj(p), obj);\n    \n\tobj = mergeobjs(planeobj(p), obj);\n    return obj;\n}\n\n#define DISTMARCH_STEPS 40\n#define DISTMARCH_MAXDIST 20.\n\nvec2 distmarch( vec3 ro, vec3 rd, float maxd )\n{\n\n    float epsilon = 0.001;\n    float dist = 10. * epsilon;\n    float t = 0.;\n    float material = 0.;\n    for (int i=0; i < DISTMARCH_STEPS; i++) \n    {\n        if ( abs(dist) < epsilon || t > maxd ) break;\n        // advance the distance of the last lookup\n        t += dist;\n        vec2 dfresult = scenedf( ro + t * rd );\n        dist = dfresult.x;\n        material = dfresult.y;\n    }\n\n    if( t > maxd ) material = -1.0; \n    return vec2( t, material );\n}\n\n// **************************************************************************\n// SHADOWING & NORMALS\n\n#define SOFTSHADOW_STEPS 30\n#define SOFTSHADOW_STEPSIZE .1\n\nfloat calcSoftShadow( vec3 ro, \n  vec3 rd, \n  float mint, \n  float maxt, \n  float k )\n{\n    float shadow = 1.0;\n    float t = mint;\n\n    for( int i=0; i < SOFTSHADOW_STEPS; i++ )\n    {\n        if( t < maxt )\n        {\n            float h = scenedf( ro + rd * t ).x;\n            shadow = min( shadow, k * h / t );\n            t += SOFTSHADOW_STEPSIZE;\n        }\n    }\n    return clamp( shadow, 0.0, 1.0 );\n\n}\n\n#define AO_NUMSAMPLES 6\n#define AO_STEPSIZE .1\n#define AO_STEPSCALE .45\n\nfloat calcAO( vec3 p, vec3 n )\n{\n    float ao = 0.0;\n    float aoscale = 1.0;\n\n    for( int aoi=0; aoi< AO_NUMSAMPLES ; aoi++ )\n    {\n        float step = 0.01 + AO_STEPSIZE * float(aoi);\n        vec3 aop =  n * step + p;\n        \n        float d = scenedf( aop ).x;\n        ao += -(d-step)*aoscale;\n        aoscale *= AO_STEPSCALE;\n    }\n    \n    return clamp( ao, 0.0, 1.0 );\n}\n\n// **************************************************************************\n// CAMERA & GLOBALS\n\nvoid setupGlobals()\n{\n    \n    g_time = .8 * iTime - 10.;\n\n    // camera position\n    g_camOrigin = vec3(6.5, -2., 1.5);\n    \n    float rotx    = -1. * PI * .45 + .0 * g_time;\n    float cosrotx = cos(rotx);\n    float sinrotx = sin(rotx);\n    \n    float roty    = 0.;\n    float cosroty = cos(roty);\n    float sinroty = sin(roty);\n\n    // Rotate the camera around the origin\n    g_camOrigin = rotateAroundXAxis(g_camOrigin, cosrotx, sinrotx);\n    g_camOrigin = rotateAroundYAxis(g_camOrigin, cosroty, sinroty);\n\n    g_camPointAt   = vec3(0., 0., 0.);    \n\n    \n    float lroty    = .9 * g_time;\n    float coslroty = cos(lroty);\n    float sinlroty = sin(lroty);\n\n    // Rotate the light around the origin\n    g_ldir = rotateAroundYAxis(g_ldir, coslroty, sinlroty);\n\n    \n    g_arm.pts[0] = vec3(0., -2., 0.);\n    g_arm.segs[0] = .5;\n    g_arm.pts[1] = vec3(0., -1.5, 0.);\n    g_arm.segs[1] = .5;\n    g_arm.pts[2] = vec3(0., -1., 0.);\n    g_arm.segs[2] = .5;\n    g_arm.pts[3] = vec3(0., -.5, 0.);\n    g_arm.segs[3] = .5;\n    g_arm.pts[4] = vec3(0., 0., 0.);\n    g_arm.segs[4] = .5;\n    g_arm.pts[5] = vec3(0., .5, 0.);\n    g_arm.segs[5] = .5;\n    g_arm.pts[6] = vec3(0., 1., 0.);\n    g_arm.segs[6] = .5;\n    g_arm.pts[7] = vec3(0., 1.5, 0.);\n    g_arm.segs[7] = .5;\n    g_arm.pts[8] = vec3(0., 2., 0.);\n    \n}\n\nstruct CameraData\n{\n    vec3 origin;\n    vec3 dir;\n    vec2 st;\n};\n\nCameraData setupCamera( in vec2 fragCoord )\n{\n\n    // aspect ratio\n    float invar = iResolution.y / iResolution.x;\n    vec2 st = fragCoord.xy / iResolution.xy - .5;\n    st.y *= invar;\n\n    // calculate the ray origin and ray direction that represents\n    // mapping the image plane towards the scene\n    vec3 iu = vec3(0., 1., 0.);\n\n    vec3 iz = normalize( g_camPointAt - g_camOrigin );\n    vec3 ix = normalize( cross(iz, iu) );\n    vec3 iy = cross(ix, iz);\n\n    vec3 dir = normalize( st.x*ix + st.y*iy + .7 * iz );\n\n    return CameraData(g_camOrigin, dir, st);\n\n}\n\nconst float c_solve_tolerance = .01;\n\nvoid solveFABRIK(vec3 target_pt)\n{\n    // assume g_arm.p9 has been placed before the solve has happened\n    float max_reach = 0.;\n    for (int idx = 0; idx < NUM_SEGS; idx++)\n    {\n        max_reach += g_arm.segs[idx];\n    }\n        \n\tvec3 target_vec = target_pt - g_arm.pts[0];\n    float target_length = length(target_vec);\n    \n    vec3 resolve_target_pt = target_pt;\n    \n    // in the case where the target is out of reach - will need to \n    // be changed when we add constraints\n    if (target_length > max_reach)\n    {\n        g_arm.pts[NUM_PTS-1] = g_arm.pts[0] + target_vec * (max_reach/target_length);\n        \n        // optimization that causes pop\n        /*\n        float delta = 1./float(NUM_SEGS);\n        float f = delta;\n        target_vec = g_arm.pts[NUM_PTS-1] - g_arm.pts[0];\n        for (int idx = 1; idx < NUM_PTS-1; idx++)\n        {\n            g_arm.pts[idx] = g_arm.pts[0] + f * target_vec;\n            f += delta;\n        }\n\t\t*/\n        resolve_target_pt = g_arm.pts[NUM_PTS-1];\n    }\n    \n    \n    //else // solve for an IK target within reach\n    {\n        vec3 base_pt = g_arm.pts[0];\n        float dist_to_target = BIG_FLOAT;\n        \n        for(int iters = 0; iters < MAX_ITERATIONS; iters++)\n        {\n            if (c_solve_tolerance > dist_to_target) break;\n                \n            g_arm.pts[NUM_PTS-1] = target_pt;\n            // FRONT REACHING ITERATION\n            for (int idx = NUM_PTS-2; idx >= 0; idx--)\n            {\n                vec3 seg = g_arm.pts[idx+1] - g_arm.pts[idx];\n                float seg_length = length(seg);\n                g_arm.pts[idx] = g_arm.pts[idx] + seg * (1. - (g_arm.segs[idx]/seg_length));\n            }\n            \n            g_arm.pts[0] = base_pt;\n            \n            // BACK REACHING ITERATION            \n            for (int idx = 0; idx < NUM_PTS-1; idx++)\n            {\n                vec3 seg = g_arm.pts[idx] - g_arm.pts[idx+1];\n                float seg_length = length(seg);\n                g_arm.pts[idx+1] = g_arm.pts[idx+1] + seg * (1. - (g_arm.segs[idx]/seg_length));\n            }\n\t\t\t\n                \n            dist_to_target = length(resolve_target_pt - g_arm.pts[NUM_PTS-1]);\n        }\n    }    \n    \n}\n\n// **************************************************************************\n// SHADING\n\nstruct SurfaceData\n{\n    vec3 point;\n    vec3 normal;\n    vec3 basecolor;\n    float roughness;\n    float metallic;\n};\n\n#define INITSURF(p, n) SurfaceData(p, n, vec3(0.), 0., 0.)\n\nvec3 calcNormal( vec3 p )\n{\n    vec3 epsilon = vec3( 0.001, 0.0, 0.0 );\n    vec3 n = vec3(\n        scenedf(p + epsilon.xyy).x - scenedf(p - epsilon.xyy).x,\n        scenedf(p + epsilon.yxy).x - scenedf(p - epsilon.yxy).x,\n        scenedf(p + epsilon.yyx).x - scenedf(p - epsilon.yyx).x );\n    return normalize( n );\n}\n\nvoid material(float surfid,\n  inout SurfaceData surf)\n{\n    vec3 surfcol = vec3(1.);\n    if (surfid - .5 < SPHERE_MATL) \n    { \n        surf.basecolor = vec3(.97, .53, .06); \n        surf.roughness = .5;\n        surf.metallic = 1.;\n    } \n    else if (surfid - .5 < CHAMBER_MATL)\n    {\n        surf.basecolor = vec3(0.);\n        surf.roughness = 1.;\n    }\n    else if (surfid - .5 < BOND_MATL)\n    {\n        surf.basecolor = vec3(.02,.02,.05);\n        surf.roughness = .2;\n        surf.metallic = .0;\n    }\n    else if (surfid - .5 < PLANE_MATL)\n    {\n        surf.basecolor = vec3(.05,.05,.07);\n        float f = smoothstep(.1, .4, abs(mod(2. * length(surf.point), 1.) - .5));\n        surf.basecolor *= mix(1., f, .3);\n        surf.roughness = .8;\n        surf.metallic = 1.;\n    }\n\n}\n\nvec3 integrateDirLight(vec3 ldir, vec3 lcolor, SurfaceData surf)\n{\n    vec3 vdir = normalize( g_camOrigin - surf.point );\n\n    // The half vector of a microfacet model \n    vec3 hdir = normalize(ldir + vdir);\n    \n    // cos(theta_h) - theta_h is angle between half vector and normal\n    float costh = max(-SMALL_FLOAT, dot(surf.normal, hdir)); \n    // cos(theta_d) - theta_d is angle between half vector and light dir/view dir\n    float costd = max(-SMALL_FLOAT, dot(ldir, hdir));      \n    // cos(theta_l) - theta_l is angle between the light vector and normal\n    float costl = max(-SMALL_FLOAT, dot(surf.normal, ldir));\n    // cos(theta_v) - theta_v is angle between the viewing vector and normal\n    float costv = max(-SMALL_FLOAT, dot(surf.normal, vdir));\n\n    float ndl = clamp( costl, 0., 1.);\n\n    vec3 cout = vec3(0.);\n\n    if (ndl > 0.)\n    {\n        float frk = .5 + 2.* costd*costd * surf.roughness;\n        vec3 diff = surf.basecolor * ONE_OVER_PI * (1. + (frk - 1.)*pow5(1.-costl)) * (1. + (frk - 1.) * pow5(1.-costv));\n        //vec3 diff = surf.basecolor * ONE_OVER_PI; // lambert\n\n        // D(h) factor\n        // using the GGX approximation where the gamma factor is 2.\n\n        // Clamping roughness so that a directional light has a specular\n        // response.  A roughness of perfectly 0 will create light \n        // singularities.\n        float r = max(0.05, surf.roughness);\n        float alpha = r * r;\n        float denom = costh*costh * (alpha*alpha - 1.) + 1.;\n        float D = (alpha*alpha)/(PI * denom*denom); \n\n        // using the GTR approximation where the gamma factor is generalized\n        // float alpha = surf.roughness * surf.roughness;\n        // float gamma = 2.;\n        // float sinth = length(cross(surf.normal, hdir));\n        // float D = 1./pow(alpha*alpha*costh*costh + sinth*sinth, gamma);\n\n        // G(h,l,v) factor\n        float k = ((r + 1.) * (r + 1.))/8.;    \n        float Gl = costv/(costv * (1. - k) + k);\n        float Gv = costl/(costl * (1. - k) + k);\n        float G = Gl * Gv;\n\n        // F(h,l) factor\n        vec3 F0 = mix(vec3(.5), surf.basecolor, surf.metallic);\n        vec3 F = F0 + (1. - F0) * pow5(1. - costd);\n\n        vec3 spec = D * F * G / (4. * costl * costv);\n        \n        float shd = calcSoftShadow( surf.point, ldir, 0.1, 20., 6.);\n        \n        cout  += diff * ndl * shd * lcolor;\n        cout  += spec * ndl * shd * lcolor;\n    }\n\n    return cout;\n}\n\nvec3 sampleEnvLight(vec3 ldir, vec3 lcolor, SurfaceData surf)\n{\n\n    vec3 vdir = normalize( g_camOrigin - surf.point );\n\n    // The half vector of a microfacet model \n    vec3 hdir = normalize(ldir + vdir);\n    \n    // cos(theta_h) - theta_h is angle between half vector and normal\n    float costh = dot(surf.normal, hdir); \n    // cos(theta_d) - theta_d is angle between half vector and light dir/view dir\n    float costd = dot(ldir, hdir);      \n    // cos(theta_l) - theta_l is angle between the light vector and normal\n    float costl = dot( surf.normal, ldir );\n    // cos(theta_v) - theta_v is angle between the viewing vector and normal\n    float costv = dot( surf.normal, vdir );\n\n    float ndl = clamp( costl, 0., 1.);\n    vec3 cout = vec3(0.);\n    if (ndl > 0.) \n    {\n\n        float r = surf.roughness;\n        // G(h,l,v) factor\n        float k = r*r/2.;    \n        float Gl = costv/(costv * (1. - k) + k);\n        float Gv = costl/(costl * (1. - k) + k);\n        float G = Gl * Gv;\n\n        // F(h,l) factor\n        vec3 F0 = mix(vec3(.5), surf.basecolor, surf.metallic);\n        vec3 F = F0 + (1. - F0) * pow5(1. - costd);\n\n        // Combines the BRDF as well as the pdf of this particular\n        // sample direction.\n        vec3 spec = lcolor * G * F * costd / (costh * costv);\n        \n        float shd = calcSoftShadow( surf.point, ldir, 0.05, 20., 7.);\n\n        cout = spec * shd * lcolor;\n    }\n\n    return cout;\n}\n\nvec3 integrateEnvLight(SurfaceData surf)\n{\n    vec3 vdir = normalize( surf.point - g_camOrigin );    \n    vec3 envdir = reflect(vdir, surf.normal);\n    vec4 specolor = vec4(.4) * mix(texture(iChannel0, envdir),\n       texture(iChannel1, envdir),\n       surf.roughness);\n    \n    vec3 envspec = sampleEnvLight(envdir, specolor.rgb, surf);\n    return envspec;\n}\n\nvec3 shadeSurface(SurfaceData surf)\n{    \n\n    vec3 amb = surf.basecolor * .04;\n    // ambient occlusion is amount of occlusion.  So 1 is fully occluded\n    // and 0 is not occluded at all.  Makes math easier when mixing \n    // shadowing effects.\n    float ao = calcAO(surf.point, surf.normal);\n\n    vec3 bounce_ldir = normalize(vec3(-0.2, 1., 0.));\n\n    vec3 cout = vec3(0.);\n    if (dot(surf.basecolor, vec3(1.)) > SMALL_FLOAT)\n    {\n        cout  += integrateDirLight(g_ldir,  vec3(.3), surf);\n        cout  += integrateDirLight(bounce_ldir, .4 * vec3(.5, .5, 1.), surf);\n        cout  += integrateEnvLight(surf) * (1. - 3.5 * ao);\n        cout  += amb * (1. - 5.5 * ao);\n    }\n    return cout;\n\n}\n\n// **************************************************************************\n// MAIN\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n\n    setupGlobals();\n\n\n    CameraData cam = setupCamera( fragCoord );\n\n    // ----------------------------------------------------------------------\n    // FABRIK SOLVE\n    vec2 mouseTarget = iMouse.xy;\n    if (mouseTarget.x + mouseTarget.y < 1.)        \n    {\n        mouseTarget = iResolution.xy * vec2(.7, .5);\n    }\n    CameraData pickCam = setupCamera( mouseTarget );\n    vec3 cdir = normalize(g_camOrigin - g_camPointAt);\n    vec2 p = intersect_plane(pickCam.origin, pickCam.dir, cdir, g_camOrigin - 6.5 * cdir);\n    if (p.x > .5)\n    {\n        vec3 target = pickCam.origin + pickCam.dir * p.y;\n        solveFABRIK(target);\n    }        \n    \n    // ----------------------------------------------------------------------\n    // SCENE MARCHING\n\n    vec2 scenemarch = distmarch( cam.origin, \n       cam.dir, \n       DISTMARCH_MAXDIST );\n    \n    // ----------------------------------------------------------------------\n    // SHADING\n\n    vec3 scenecol = vec3(0.);\n    if (scenemarch.y > SMALL_FLOAT)\n    {\n        vec3 mp = cam.origin + scenemarch.x * cam.dir;\n        vec3 mn = calcNormal( mp );\n\n        SurfaceData currSurf = INITSURF(mp, mn);\n\n        material(scenemarch.y, currSurf);\n        scenecol = shadeSurface( currSurf );\n    }\n\n    // ----------------------------------------------------------------------\n    // POST PROCESSING\n    \n    // fall off exponentially into the distance (as if there is a spot light\n    // on the point of interest).\n    scenecol *= exp( -0.01 *(scenemarch.x*scenemarch.x - 300.));\n    \n    // brighten\n\tscenecol *= .8;\n    \n    // distance fog\n    scenecol = mix(scenecol, .02 * vec3(.4, .4, .8), smoothstep(10., 30., scenemarch.x));\n    \n    // Gamma correct\n    scenecol = pow(scenecol, vec3(0.45));\n\n    // Contrast adjust - cute trick learned from iq\n    scenecol = mix( scenecol, vec3(dot(scenecol,vec3(0.333))), -0.6 );\n\n    // color tint\n    scenecol = .5 * scenecol + .5 * scenecol * vec3(1., .8, 1.);\n    \n    fragColor.rgb = scenecol;\n    fragColor.a = 1.;\n}\n","name":"Image","description":"","type":"image"}]}