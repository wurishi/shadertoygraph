{"ver":"0.1","info":{"id":"ttVBWR","date":"1614833166","viewed":91,"name":"4D Rounded Cuboid","username":"sahemera","description":"It interested me how the sdf for the cube was the same essential algorithm as the square, so I wanted to see if it was trivial to extend that into 4d","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","4d","rotation","tesseract"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 150.\n#define SURF_DIST 0.01\n\n\nmat4 rotationMatrix(vec4 axis, float a) {\n//Attempt to adapt http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n//for a 4D matrix. This implementation is flawed (though nonetheless cool looking),\n//and discovering that was a learning opportunity for me. So I am leaving this here.\n//When we rotate in 3D space, and say, \"rotate a point around the z axis\" we are\n//instead \"rotating a point within the xy-plane, leaving Z (which is orthagonal to the x-y plane), alone.\"\nfloat s=sin(a);\nfloat c=cos(a);\nfloat oc=1.0-c;\nvec4 as=axis*s;\nmat4 p=mat4(axis.x*axis,axis.y*axis,axis.z*axis, axis.w*axis);\nmat4 q=mat4(c,-as.w,as.y,as.z,\n            as.z,c,-as.x,as.w,\n            as.w,as.x,c,-as.y,\n            -as.z,as.x,as.y,c);\nreturn p*oc+q;\n}\n\n\n//Proper rotations courtesy of user tomoe https://www.shadertoy.com/view/wsVSzc\nmat4 rotXW(float t) {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, cos(t), sin(t), 0.0,\n        0.0, - sin(t), cos(t), 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\nmat4 rotXY(float t) {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, cos(t), sin(t),\n        0.0, 0.0, - sin(t), cos(t)\n    );\n}\nmat4 rotXZ(float t) {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, cos(t), 0.0, sin(t),\n        0.0, 0.0, 1.0, 0.0,\n        0.0, - sin(t), 0.0, cos(t)\n    );\n}\nmat4 rotYZ(float t) {\n    return mat4(\n        cos(t), 0.0, 0.0, sin(t),\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        - sin(t), 0.0, 0.0, cos(t)\n    );\n}\nmat4 rotYW(float t) {\n    return mat4(\n        cos(t), 0.0, sin(t), 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        - sin(t), 0.0, cos(t), 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\nmat4 rotZW(float t) {\n    return mat4(\n        cos(t), sin(t), 0.0, 0.0,\n        - sin(t), cos(t), 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\n//adapted from iq\nfloat hypercube( vec4 p, float d)\n{\n  return length(max(abs(p) -d,0.0)); \n}\n\n//adapted from iq\nfloat sdRoundHypercuboid( vec4 p, vec4 b, float r)\n{\n    vec4 q = abs(p) - b;\n    \n    return length(max(q,0.0)) + min(max(q.x,max(q.y,max(q.z,q.w))),0.0) -r;\n}\n\n\nfloat GetDist(vec4 p) {\n    float t = iTime*2. - 5.;\n\n    mat4 R2 = mat4(1);\n    \n    //Create rotation matrix to rotate our cube\n    mat4 R = rotXW(1.0*t) * rotXY(0.25*t) * rotXZ(0.5*t) * rotYZ(1.75*t);// * rotYW(1.0*t) * rotZW(1.0*t);\n    //mat4 R = rotationMatrix(vec4(sin(iTime), 0., cos(iTime),0.), iTime/10.);\n   \n    vec4 cu = vec4(0.,1. ,6. ,0.);\n    float c = sdRoundHypercuboid(R*(p-cu),vec4(1.,1.25,1.,1.), 0.4);\n    //float c = hypercube(R*(p - cu), 1.25);\n    \n    //Wobbly, noisy floor\n    float floorDist = p.y + 0.005*sin(p.z*80.*(5. + 4.*sin(t/8.))) + sin(t)*8.*pow(sin((p.x + p.w)/20.),2.) + 0.5*sin(p.x/2. + t/2.)*sin(p.z/2. + t/3.)*cos(p.z+p.x) + 1.5;\n    \n    //Add a wall/sky so that the noisy floor looks like a floor\n    float wallDist = (p.w) + 4.0;\n    \n    float d = min(c, floorDist);\n    d = min(d, wallDist);\n    \n    return d;\n}\n\n\n//Move from the rayOrigin in the rayDistance until we collide with the scene or fly off into INF\n//RayMarch is also called Sphere Tracing because when we get the distance from each position as\n//we march along the array, that distance creates an arc or sphere around the position that defines\n//how much we will step on the next iteration.\nfloat RayMarch(vec4 rayOrigin, vec4 rayDistance)\n{\n    float distanceOrigin = 0.0018;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        //Get next point\n        vec4 p = rayOrigin + rayDistance*distanceOrigin;\n        \n        //Get distance from new point to the scene\n        float dS  = GetDist(p);\n        \n        //Add distance from new point to total distance from origin\n        distanceOrigin += dS;\n        \n        //If we have marched too far or if we are sufficiently close to scene, we're done marching\n        if(distanceOrigin > MAX_DIST || dS < SURF_DIST) break;\n    }\n    return distanceOrigin;\n}\n\n/***Gets the normal of a point to the nearest part of the scene defined by GetDist*/\nvec4 GetNormal_Generic(vec4 p) {\n    \n    vec2 epsilon = vec2(0.001, 0);\n    \n    float d = GetDist(p);\n    \n    //Get the slope by subtracting nearby points from the point and normalizing their direction\n    vec4 n = vec4(\n        d - GetDist(p - epsilon.xyyy), //*.xyy and xyx are called a \"swizzle\", just makes it faster to write\n        d - GetDist(p - epsilon.yxyy),\n        d - GetDist(p - epsilon.yyxy),\n        d - GetDist(p - epsilon.yyyx));\n        \n    return normalize(n);\n}\n\n\n//Diffuse light algorithm is defined as the dot product of a normal vector and a light vector\nfloat GetLight_Diffuse(vec4 p) {\n    \n    vec4 lightPos = vec4(0, 5, 6, 0);\n    \n    //Ray from the found scene position to the light position, normalized to [0,1]\n    vec4 lightRay = normalize(lightPos-p);\n    vec4 normalRay = GetNormal_Generic(p);\n    \n    //Dot product returns [-1:1], so cap negative numbers to 0\n    float dif = clamp(dot(normalRay, lightRay), 0.0, 1.0);\n    return dif;\n}\n\n\n//Diffuse light algorithm is defined as the dot product of a normal vector and a light vector\nfloat GetLight_Diffuse_WithShadows(vec4 p) {\n    \n    vec4 lightPos = vec4(0, 3, 1, 1);\n    \n    lightPos.xz += vec2(0., cos(2.0*iTime));\n    \n    //Ray from the found scene position to the light position, normalized to [0,1]\n    vec4 lightRay = normalize(lightPos-p);\n    vec4 normalRay = GetNormal_Generic(p);\n    \n    //Dot product returns [-1:1], so.. \"clamp\" it\n    float dif = clamp(dot(normalRay, lightRay), 0.0, 1.0);\n    \n    //Let's say we are rendering a point on the plane in the shadow of the sphere.\n    //Ray march from this point in the direction of the light to see if we collide\n    //with more scenery. If we do, reduce the diffuse lighting.\n    //\n    //Because 'p' was an output to RayMarch already, p already collides with the scene.\n    //So move p a little bit away using the normal we already found.\n    float d = RayMarch(p + normalRay*SURF_DIST, lightRay);\n    if(d < length(lightPos-p)) dif*= max(abs(d)/(length(lightPos-p)*2.),0.1);\n    \n    return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy) /iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n\n    vec4 rayOrigin = vec4(0., 1., 0., 0.);\n    vec4 rayDirection = normalize(vec4(uv.x, uv.y, 1., 0.));\n\n    float d = RayMarch(rayOrigin, rayDirection);\n    vec4 p = rayOrigin + rayDirection * d;\n    \n    float light = GetLight_Diffuse_WithShadows(p);\n    col = vec3(light);\n    col = mix(vec3(0.80,.09824,0.5658824), vec3(1.,0.98628,0.29765), col);\n    \n    // Output to screen\n    float screenGamma = 2.2;\n    vec3 colorGammaCorrected = pow(col, vec3(1.0/screenGamma));\n\tfragColor = vec4(colorGammaCorrected,1.0);\n}","name":"Image","description":"","type":"image"}]}