{"ver":"0.1","info":{"id":"tsdyDM","date":"1601063492","viewed":106,"name":"Mega High Buildings by Steven","username":"jorge2017a1","description":"Mega High Buildings by Steven","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["megahighbuildingsbysteven"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Mega High Buildings by Steven\n\n\n vec2 mouse;\n//Simple raymarching sandbox with camera\n\n//Raymarching Distance Fields\n//About https://iquilezles.org/articles/raymarchingdf\n//Also known as Sphere Tracing\n//Original seen here: http://twitter.com/#!/paulofalcao/statuses/134807547860353024\n\n//Declare functions\nvec2 ObjUnion(in vec2 d1,in vec2 d2);\nvec2 floorPlane(in vec3 p);\nvec3 color_checkers(in vec3 p);\nvec2 roundBox(in vec3 p);\nvec2 sdBox( vec3 p, vec3 b );\nvec3 color_white(in vec3 p);\nvec2 distanceField(in vec3 p);\nvec2 simpleBuilding (vec3 p, vec3 b );\nvec4 applyFog (in vec4 currColor, in vec3 ray);\nfloat maxcomp(in vec3 p );\nvec2 infiniteBuildings(in vec3 p);\nfloat sdCross( in vec3 p );\nvec2 sidewalk(vec3 p);\nvec2 tallBuilding (vec3 p, vec3 b );\nvec2 infiniteTallBuildings(in vec3 p);\nvec3 color_brick(in vec3 p);\n\n\n\n#define EPS 0.01\n#define INF 100000.0\n\n#define PHONG_SHADING 0\n#define RAYMARCH_SHADING 1\n#define TEST_SHADING 2\n\n#define SPINNING_CAMERA 0\n#define MOUSE_CAMERA 1\n#define PAN_CAMERA 2\n#define STILL_CAMERA 3\n#define AUTOPAN_CAMERA 4\n\n// mode selection\nconst int SHADING_MODE = TEST_SHADING; \nconst int CAMERA_MODE = MOUSE_CAMERA; \nvec3 E;\n\n// some simple colors\nconst vec3 COLOR_GREY = vec3(0.2,0.2,0.2);\nconst vec3 COLOR_WHITE = vec3(1.0,1.0,1.0);\nconst vec3 COLOR_BLACK = vec3(0);\nconst vec3 COLOR_WINDOW = vec3(0,0.4,0.55);\n\n//============================== UTILS ====================================//\nvec2 distanceField(in vec3 p){\n\treturn ObjUnion(floorPlane(p),ObjUnion(infiniteTallBuildings(p), infiniteBuildings(p))); // infinite boxes\n\t\n\t//vec2 test = ObjUnion(infiniteBuildingsShort(p),infiniteBuildingsTall(p)); //multiple mod patterns\n\t//return ObjUnion(floorPlane(p),test);\n}\n\nvec2 ObjUnion(in vec2 d1,in vec2 d2){\n\tif (d1.x<d2.x)\n\treturn d1;\n\telse\n\treturn d2;\n}\n\n// http://www.ozone3d.net/blogs/lab/20110427/glsl-random-generator/\nfloat rand(vec2 n)\n{\n\treturn 0.5 + 0.5 *\n\tfract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n// from IQ\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\n\n\n// =============================== OBJECTS =======================================//\n// CREDIT: https://iquilezles.org/articles/distfunctions //\n\n//floorPlane (color is determined by y-component, ie 0.0)\nvec2 floorPlane(in vec3 p){\n\treturn vec2(p.y+2.0,0);\n}\n\n// ROUNDBOX (try other objects )\n//(color is determined by y-component, ie 1.0)\nvec2 roundBox(in vec3 p){\n\treturn vec2(length(max(abs(p)-vec3(1,1,1),0.0))-0.25,1);\n}\n\n// SIGNED BOX\nvec2 sdBox( vec3 p, vec3 b ){\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return vec2(min(mc,length(max(di,0.0))), 1);\n}\n\n\n// INFINITE SIMPLE BUILDINGS RANDOm (CREDIT: H3R3)\nvec2 infiniteBuildings(in vec3 p){\n\t\n\tvec3 c = vec3(5); // how close cubes are to each other\n\t\n\tvec3 q = p;\n\t//repetition in x and z direction\n\tq.x = mod(p.x,c.x)-0.5*c.x;\n\tq.z = mod(p.z,c.z)-0.5*c.z;\n\t\n\tvec2 pos = vec2(ceil(p.x/c.x), ceil(p.z/c.z));\n\t\n\tfloat height = rand(pos)*52.0;//* 10.0 - 4.0;\n\tfloat width1 = rand(pos + 100.0) + 0.5;\n\tfloat width2 = rand(pos + 15200.0) + 0.5;\n\t\n\t//building height\n\t//vec3 k = vec3(1,height,1);\n\tvec3 k = vec3(max(0.0, width1), max(0.0, height), max(0.0, width2));\n\treturn simpleBuilding(q,k);\n}\n\n\n// SIMPLE BUILDING (white)\nvec2 simpleBuilding (vec3 p, vec3 b ){\n\tfloat body = sdBox(p,b).x;\n\t\n\tvec3 q = p;\n\tvec3 c = vec3(0.5); //0.5\n\n\tq = mod(p,c)-0.5*c;\n\t\n\tfloat cr = sdCross(q*3.0)/3.0;\n\tbody = max( body, -cr );\n\t\n\t// top \"cap\" of building\n\tfloat top = sdBox(p-vec3(0,b.y,0),vec3(b.x, b.y/25.0, b.z)).x;\n\t\n\t// some buildings have an additional top that's slightly smaller\n\tif(fract(b.y/2.0) < 0.5){\n\t\tfloat c = fract(b.y)<0.2? 10.0:fract(b.y)*30.0; //if top portion is small enough, make it longer\n\t\tfloat toptop = sdBox(p-vec3(0,b.y+b.y/25.0,0),vec3(b.x*fract(b.y), b.y/c, b.z*fract(b.y))).x;\n\t\tbody = min(body,toptop);\n\t}\n\t\n\t// make a box inside to look like windows\n\tfloat inside = sdBox(p,vec3(b.x*0.9, b.y, b.z*0.9)).x;\n\tbody = min(inside,min(body,top));\n\t\t\n\tfloat outputColor = b.y;\n\tif(body==inside)\n\t\toutputColor = 99.0; // if inside is hit, shade with window color (99.0 is just placeholder value)\n\t\t\n\t\n  return vec2(body,outputColor);\n}\n\n\n\n// INFINITE TALL BUILDINGS RANDOM\nvec2 infiniteTallBuildings(in vec3 p){\n\t\n\tvec3 c = vec3(23,0,23); // how close cubes are to each other\n\t\n\tvec3 q = p;\n\t//repetition in x and z direction\n\tq.x = mod(p.x,c.x)-0.5*c.x;\n\tq.z = mod(p.z,c.z)-0.5*c.z;\n\t\n\tvec2 pos = vec2(ceil(p.x/c.x), ceil(p.z/c.z));\n\t\n\tfloat height = rand(pos)*20.0;\n\tif (fract(height)/23.0 < 0.4) //adding some variation in height\n\t\theight = height/2.0;\n\t\t\n\tfloat width1 = rand(pos + 830.0) + 0.5;\n\tfloat width2 = rand(pos + 3333.0) + 0.5;\n\t\n\t//building height\n\n\tvec3 k = vec3(max(3.0, width1), max(22.0, height), max(2.0, width2));\n\treturn tallBuilding(q,k);\n}\n\n\n\n//TALL BUILDING (WHITE)\nvec2 tallBuilding (vec3 p, vec3 b ){\n\tfloat body = sdBox(p,b).x;\n\t\n\tvec3 q = p;\n\tvec3 c = vec3(0.5);\n\tq = mod(p,c)-0.5*c;\n\tfloat vert_bars = sdBox(q,vec3(0.1,INF,0.1)).x;\n\tbody = max(body, -vert_bars);\n\t\n\t//dividng ledge\n\tconst float ledgeheight = 0.2;\n\tfloat ledge = sdBox(p-vec3(0,b.y,0),vec3(b.x,ledgeheight,b.z)).x;\n\tbody = min(body,ledge);\n\t\n\t//2nd portion\n\tfloat body2 = sdBox(p-vec3(0,b.y+ledgeheight,0),b*vec3(0.8,0.2,0.8)).x;\n\tbody = min(body,body2);\n\t\n\t//3rd portion\n\tfloat body3 = sdBox(p-vec3(0,b.y+ledgeheight+b.y*2.2, 0), b*vec3(0.6,0.2,0.6)).x;\n\tbody = min(body3, body);\n\t\t\t    \n\t\n\treturn vec2(body,1);\n}\n\n// SD_CROSS (modified from IQ's original)\nfloat sdCross( in vec3 p ){\n\tconst float w = 0.4;\n  float da = sdBox(p.xyz,vec3(INF,w,w)).x;\n  float db = sdBox(p.yzx,vec3(w,INF,w)).x;\n  float dc = sdBox(p.zxy,vec3(w,w,INF)).x;\n  return min(da,db);\n}\n\n\n\n// ============COLORS============= //\n// Streets & Sidewalks Color\nvec3 color_streets(in vec3 p){\n\tvec2 street = fract(p.xz * 0.2 + 0.15);\n\tif ((street.x>.3) && (street.y > 0.3))\n\t\treturn vec3(.5,.8,.5);\n\telse\n\t\treturn COLOR_BLACK;\n}\n\n//Brick Color\nvec3 color_brick(in vec3 p){\t\n\tconst vec3 brickColor = vec3(0.2,0.2,0.2);\n\tconst vec3 mortarColor = vec3(0.8);\n\tconst vec2 brickSize = vec2(0.3,0.15);\n\tconst vec2 brickPct = vec2(0.9,0.85);\n\t\n\tvec2 position = (p.zy)/brickSize;\n\tvec2 useBrick = vec2(0);\n\t\n\tif(fract(position.y*0.5) > 0.5)\n\t\tposition.x += 0.5;\n\t\t\n\tposition = fract(position);\n\tuseBrick = step(position, brickPct);\n\t\n\tvec3 color =  mix(mortarColor, brickColor, useBrick.x*useBrick.y);\n\t\n\t\n\tposition = p.xy/brickSize;\n\tif(fract(position.y*0.5) > 0.5)\n\t\tposition.x += 0.5;\n\tposition = fract(position);\n\tuseBrick = step(position, brickPct);\n\tcolor = (color+mix(mortarColor, brickColor, useBrick.x*useBrick.y))/2.0;\n\t\n\treturn color;\n\t\n}\n\n// ==================== RAY MARCH =============================//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    mouse.x=0.2+0.08*cos(iTime*0.255);\n    mouse.y=0.8+0.7*sin(iTime);\n    \n\t//Camera animation\n\tvec3 U=vec3(0,1,0);//Camera Up Vector\n\tvec3 viewDest=vec3(0,0,0); //Change camere view vector here\n\t//vec3 E; //moved to global space\n\tif (CAMERA_MODE == SPINNING_CAMERA)\n\tE=vec3(-sin(iTime/10.0)*10.0,5,cos(iTime/10.0)*10.0); //spinning scene\n\telse if(CAMERA_MODE == MOUSE_CAMERA){\n\t\tfloat spin = mouse.x * 8.0; //time * 0.1 + mouse.x * 8.0;\n\t\tE=vec3(-sin(spin)*10.0, 10.0 * mouse.y, cos(spin)*10.0);//Change camera path position here\n\t}\n\telse if(CAMERA_MODE == PAN_CAMERA){\n\t\tE=vec3(-sin(1.0)*10.0,7,cos(1.0)*10.0);\n\t\tvec3 moveCamDir = normalize(vec3(E.x,0.0,E.y));\n\t\tfloat mouse_val = mouse.y-0.5;\n\t\tE+=moveCamDir*iTime*(mouse_val>0.0?mouse_val:0.0);\n\t}\n\telse if(CAMERA_MODE == STILL_CAMERA){\n\t\tE=vec3(-sin(1.0)*10.0,7,cos(1.0)*10.0);//Change camera path position here\n\t}\n\telse if (CAMERA_MODE == AUTOPAN_CAMERA){\n\t\tE=vec3(-sin(1.0)*10.0,7,cos(1.0)*10.0);\n\t\tvec3 moveCamDir = normalize(vec3(E.x,0.0,E.y));\n\t\tE+=moveCamDir*iTime;\n\t}\n\t\n\t\n\t//Camera setup\n\tvec3 C=normalize(viewDest-E);\n\tvec3 A=cross(C, U);\n\tvec3 B=cross(A, C);\n\tvec3 M=(E+C);\n\n\tvec2 vPos=2.0*gl_FragCoord.xy/iResolution.xy - 1.0; // = (2*Sx-1) where Sx = x in screen space (between 0 and 1)\n\tvec3 P=M + vPos.x*A*iResolution.x/iResolution.y + vPos.y*B; //normalize resolution in either x or y direction (ie resolution.x/resolution.y)\n\tvec3 rayDir=normalize(P-E); //normalized direction vector from Eye to point on screen\n\t\n\t//Colors\n\tconst vec4 skyColor = vec4(0.7, 0.8, 1.0, 1.0);\n\tconst vec4 sunColor = vec4 (1.0, 0.9, 0.7, 1.0);\n\t\n\t//Raymarching\n\tconst vec3 e=vec3(0.01,0,0);\n\tconst float MAX_DEPTH=170.0; //Max depth use 500\n\tconst int MAX_STEPS = 100; // max number of steps use 150\n\tconst float MIN_DIST = 0.01;\n\n\tvec2 dist=vec2(0.0,0.0);\n\tfloat totalDist=0.0;\n\tvec3 c,p,n; //c=color (used in PHONG and RAYMARCH modes), p=ray position, n=normal at any point on the surface\n\n\tint steps = 0;\n\tfor(int i=0;i<MAX_STEPS;i++){\n\t\tsteps++;\n\t\ttotalDist+=dist.x*0.7; //use smoothing constant\n\t\tp=E+rayDir*totalDist; // p = eye + total_t*rayDir\n\t\tdist=distanceField(p);\n\t\tif (abs(dist.x)<MIN_DIST) break; // break when p gets sufficiently close to object or exceeds max dist\n\t}\n\n\tvec4 finalColor = skyColor;\n\t\n\tif (totalDist<MAX_DEPTH){\n\t\t// check which color to use via the y-component\n\t\tif (dist.y==0.0) // floorPlane color\n\t\tc=color_streets(p);\n\t\telse if(dist.y==1.0) // building color\n\t\tc=COLOR_WHITE;\n\t\t\n\t\tif(SHADING_MODE==PHONG_SHADING){\n\t\t\t// compute normal at this point on the surface using a gradient vector\n\t\t\tn=normalize(\n\t\t\tvec3(\n\t\t\tdist.x-distanceField(p-e.xyy).x,\n\t\t\tdist.x-distanceField(p-e.yxy).x,\n\t\t\tdist.x-distanceField(p-e.yyx).x));\n\t\t\t\n\t\t\t//e.xyy is equal to (0.001,0.0,0.0) \n\t\t\t//e.yxy is equal to (0.0,0.001,0.0)\n\t\t\t//e.xxy is equal to (0.0,0.0,0.001)\n\n\t\t\t//simple phong LightPosition=CameraPosition\t   \n\t\t\tfloat b=dot(n,normalize(E-p));\n\t\t\tfinalColor=vec4((b*c+pow(b,8.0))*(1.0-totalDist*.01),1.0);\n\t\t}\n\t\telse if (SHADING_MODE==RAYMARCH_SHADING){\n\t\t\t//Shading based on raymarched distance\n\t\t\tfloat v = 1.0-float(steps)/float(MAX_STEPS);\n\t\t\tfloat R=v*c.r, G=v*c.g, B=v*c.b;\n\t\t\tfinalColor=vec4(R,G,B,1.0);\n\t\t}\n\t\telse if (SHADING_MODE==TEST_SHADING){\n\t\t\tvec3 sunDir = vec3(normalize(viewDest-E)); //sun comes from the camera\n\t\t\t\n\t\t\tvec3 N = normalize(vec3(\n\t\t\tdistanceField(p).x-distanceField(p-e.xyy).x,\n\t\t\tdistanceField(p).x-distanceField(p-e.yxy).x,\n\t\t\tdistanceField(p).x-distanceField(p-e.yyx).x)); //normal at point\n\t\t\t\n\t\t\tvec3 L = sunDir;\n\t\t\tvec3 V = normalize(E-p);\n\t\t\t\n\t\t\t// color info is stored in y component\n\t\t\t\n\t\t\tif(fract(dist.y) < 0.5) // building color (half of the buildings are brick)\n\t\t\t\tfinalColor=vec4(color_brick(p),1.0);\n\t\t\tif(fract(dist.y) >= 0.5)\n\t\t\t\tfinalColor = vec4(COLOR_GREY,1.0);\n\t\t\tif (dist.y==0.0) // floorPlane color\n\t\t\t\tfinalColor=vec4(c,1.0);\n\t\t\tif (dist.y == 99.0)\n\t\t\t\tfinalColor = vec4(COLOR_WINDOW,1);\n\t\t\n\t\t\t\n\t\t\t//calculate lighting: diffuse + sunlight\n\t\t\tfloat diffuseTerm = clamp(dot(V,N), 0.0, 1.0);\n\t\t\tfinalColor = mix(finalColor, sunColor, diffuseTerm*0.55);\t\t\t\n\t\t\t\n\t\t}\n\t}\n\t//apply fog\n\tvec3 r = p-E;\n\tfinalColor = applyFog(finalColor, r);\n\tfragColor = finalColor;\n}\n\n\n// Fog (credit: http://www.mazapan.se/news/2010/07/15/gpu-ray-marching-with-distance-fields/)\nvec4 applyFog (in vec4 currColor, in vec3 ray){\n\tfloat rayLength = length(ray);\n\tvec3 nRay = ray/rayLength;\n\t\n\tfloat fogAmount = 1.0-exp(-rayLength * 0.02); //0.008\n\tfloat sunAmount = 0.0;//pow( max( dot (nRay, sunDir), 0.0), 8.0);\n\t\n\tvec4 fogColor = mix(vec4(0.5,0.6,0.7,1.0), vec4(1.0,0.9,0.7,1.0), sunAmount);\n\treturn mix(currColor, fogColor, fogAmount);\n}\n","name":"Image","description":"","type":"image"}]}