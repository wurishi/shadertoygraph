{"ver":"0.1","info":{"id":"7lV3Ry","date":"1637944553","viewed":449,"name":"Random Bayer pattern blue noise","username":"NuSan","description":"Tried implementing a pseudo blue noise using a random bayer pattern\nIt's inspired by https://observablehq.com/@jobleonard/pseudo-blue-noise\nbut not exactly the same","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["bayer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nTried implementing a pseudo blue noise using a random bayer pattern\nIt's inspired by https://observablehq.com/@jobleonard/pseudo-blue-nois\nbut not exactly the same\n\nfrom top to bottom:\n- bayer pattern\n- randomized bayer pattern (indice offset)\n- randomized bayer pattern (pattern translate)\n- white noise\n\nThe bayer pattern is made with a pyramid of 2*2 base patterns\neach increasingly detailed level add it's contribution\n\nIdea of randomized bayer pattern is to randomly offset or translate the 2x2 pattern at each level\nso the pattern is randomized but each value is still only used once and close values are spread\n*/\n\n// To force one tech (1=bayer 2=offset 3=translate 4=white noise)\n//#define FORCE_TECH 3\n\n// Scene selection (1=pulse 2=gradient 3=texture)\n#define SCENE 2\n\n// to have change seed each frame\n#define RANDOM_TIME 0\n\nfloat globalgrid = 2.; // scale of the fine grid\nint subdivs = 4; // size power of the bayer grid, 4 is a 16x16 pattern (2^4=16)\nint sizex;\nint sizey;\n\nfloat time_offset=0.;\n\nvec2 rnd2(vec2 s) {\n    return fract(sin(s*212.274+s.yx*384.814)*257.274 + time_offset);\n}\n\nfloat rnd1(vec2 s) {\n    return fract(dot(sin(s*212.274+s.yx*384.814),vec2(257.274)) +time_offset);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 baseuv = fragCoord;\n    int section = int(fragCoord.y/iResolution.y*4.);\n    #ifdef FORCE_TECH\n        section = 4-FORCE_TECH;\n    #endif\n    \n    #if RANDOM_TIME\n    time_offset = fract(iTime*.1)*10.;\n    #endif\n   \n    sizex = int(pow(2.,float(subdivs)));\n    sizey = sizex;    \n    vec2 size = vec2(sizex,sizey);\n    \n    // fine grid\n    vec2 seed = floor(baseuv/globalgrid);\n    \n    // bayer grid\n    ivec2 bayer = ivec2(fract(seed/size)*size);\n      \n    int val = 0;\n    \n    // basic 2x2 bayer pattern\n    int pattern[] = int[4](0,2,3,1);\n\n    int curdiv = sizex/2;\n    int scale = 1;\n    for(int i=0;i<subdivs;++i) {\n    \n        vec2 sseed = floor(seed/float(curdiv*2));\n        // bayer pattern\n        ivec2 pos = (bayer/curdiv)%2;\n        // randomized bayer pattern (indice offset)\n        if(section<3)\n            pos += ivec2(rnd2(sseed)*2.);\n        // randomized bayer pattern (pattern translate)\n        if(section<2)\n            pos %= 2;\n        int id = pos.x+pos.y*2;\n        val += pattern[id%4] * scale;\n        \n        curdiv /= 2;\n        scale *= 4;\n    }\n    \n    float perc = float(val)/(size.x*size.y);   \n    // white noise\n    if(section<1)\n        perc=rnd1(seed);\n    \n    #ifdef SCENE\n    #if SCENE==1\n        perc = step(perc, fract(iTime*.2));\n    #elif SCENE==2\n        perc = step(perc,seed.x*globalgrid/iResolution.x);\n    #elif SCENE==3\n        perc = step(perc, texture(iChannel0, seed*globalgrid/iResolution.xy).x);\n    #endif\n    #endif\n    \n    vec3 col = vec3(perc);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}