{"ver":"0.1","info":{"id":"lcXcD8","date":"1721064668","viewed":117,"name":"HPG 2024 student competition WZ","username":"wjzhou2931","description":"Animated utah teapot with toon shading. \n\nSDF functions are from Inigo Quilez: https://iquilezles.org/articles/distfunctions/\nOther references: (https://www.shadertoy.com/view/lllyDB), (https://www.shadertoy.com/view/fsXcR8)","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf","toon","hpgconf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// USE ANY CUTOFF VALUES YOU LIKE. \n#define LIGHT_SHADE_CUTOFF 0.33\n#define DARK_SHADE_CUTOFF 0.15\nconst vec3 TEAPOT_COLOR = vec3(0.9, 0.1, 0.1);\nconst vec3 U_COLOR = vec3(0.9, 0.9, 0.9);\n\n#define EPSILON 0.0001\n#define MAX_STEPS 500\n#define MIN_DIST 0.0\n#define MAX_DIST 25.0\n\n#define AMBIENT 0.8\n#define EDGE_THICKNESS 0.015\n#define SHADES 4.0\n\nvec2 A[8];\nvec2 T[7];\nvec2 T1[5];\nvec2 T2[5];\n\nint flag = 0;\nfloat speed = 1.5;\n\n#define U(a,b) (a.x*b.y-b.x*a.y)\n\n///some tools for blend model\nvec3 Rot(vec3 p,vec3 angles)\n{\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\t    \n    return p*rotX * rotY * rotZ;\n}\n\nfloat smin(float a, float b, float k){\n    float h = clamp(.5+.5*(b-a)/k, 0., 1.);\n    return mix(b,a,h)-k*h*(1.-h);\n}\n\n//set values for teapot\nvoid SetValue(){\n    float detach = (sin(iTime*speed)>=0.0?sin(iTime*speed):0.0);\n\t// Teapot body profil (8 quadratic curves) \n\tA[0]=vec2(0,0);\n    A[1]=vec2(.64,0);\n    A[2]=vec2(.64,.03);\n    A[3]=vec2(.8,.12);\n    A[4]=vec2(.8,.3);\n    A[5]=vec2(.8,.48);\n    A[6]=vec2(.64,.9);\n    A[7]=vec2(.6,.93);\n    // Teapot top\n\tT[0]=vec2(.56,.9)+vec2(0.0, 0.3)*detach;\n    T[1]=vec2(.56,.96)+vec2(0.0, 0.3)*detach;\n    T[2]=vec2(.12,1.02)+vec2(0.0, 0.3)*detach;\n    T[3]=vec2(0,1.05)+vec2(0.0, 0.3)*detach;\n    T[4]=vec2(.16,1.14)+vec2(0.0, 0.3)*detach;\n    T[5]=vec2(.2,1.2)+vec2(0.0, 0.3)*detach;\n    T[6]=vec2(0,1.2)+vec2(0.0, 0.3)*detach;\n\t// Teapot spout (2 quadratic curves)\n\tT1[0]=vec2(1.16, .96)+vec2(0.7, 0)*detach;\n    T1[1]=vec2(1.04, .9)+vec2(0.7, 0)*detach;\n    T1[2]=vec2(1,.72)+vec2(0.7, 0)*detach;\n    T1[3]=vec2(.92, .48)+vec2(0.7, 0)*detach;\n    T1[4]=vec2(.72, .42)+vec2(0.7, 0)*detach;\n\t// Teapot handle (2 quadratic curves)\n\tT2[0]=vec2(-.6, .78)+vec2(-0.5, 0.0)*detach;\n    T2[1]=vec2(-1.16, .84)+vec2(-0.5, 0.0)*detach;\n    T2[2]=vec2(-1.16,.63)+vec2(-0.5, 0.0)*detach;\n    T2[3]=vec2(-1.2, .42)+vec2(-0.5, 0.0)*detach;\n    T2[4]=vec2(-.72, .24)+vec2(-0.5, 0.0)*detach;\n\n}\n\n///Bezier \nvec2 B(vec2 m, vec2 n, vec2 o, vec3 p) {\n\tvec2 q = p.xy;\n\tm-= q; n-= q; o-= q;\n\tfloat x = U(m, o), y = 2. * U(n, m), z = 2. * U(o, n);\n\tvec2 i = o - m, j = o - n, k = n - m, \n\t\t s = 2. * (x * i + y * j + z * k), \n\t\t r = m + (y * z - x * x) * vec2(s.y, -s.x) / dot(s, s);\n\tfloat t = clamp((U(r, i) + 2. * U(k, r)) / (x + x + y + z), 0.,1.); // parametric position on curve\n\tr = m + t * (k + k + t * (j - k)); // distance on 2D xy space\n\treturn vec2(sqrt(dot(r, r) + p.z * p.z), t); // distance on 3D space\n}\n\nfloat M(vec3 p) {\n\t\n\tp.y -= - 0.5;\n\n    // Distance to Teapot --------------------------------------------------- \n\t// precalcul first part of teapot spout\n\tvec2 h = B(T1[2],T1[3],T1[4], p);\n\tfloat a = 99., \n\t\tr = length(p), \n    // distance to teapot handle (-.06 => make the thickness) \n\t\tb = min(min(B(T2[0],T2[1],T2[2], p).x, B(T2[2],T2[3],T2[4], p).x) - .06, \n    // max p.y-.9 => cut the end of the spout \n                max(p.y - .9,\n    // distance to second part of teapot spout (abs(dist,r1)-dr) => enable to make the spout hole \n                    min(abs(B(T1[0],T1[1],T1[2], p).x - .07) - .01, \n    // distance to first part of teapot spout (tickness incrase with pos on curve) \n                        h.x * (1. - .75 * h.y) - .08)));\n\t\n    // distance to teapot body => use rotation symetry to simplify calculation to a distance to 2D bezier curve\n\tvec3 qq = vec3(r * sin(acos(p.y / r)), p.y, 0);\n    // the substraction of .015 enable to generate a small thickness arround bezier to help convergance\n    // the .8 factor help convergance  \n\tfor(int i=0;i<13;i+=2) \n    {\n\t\ta = min(a, (B(A[i], A[i + 1], A[i + 2], qq).x - .015) * .8);\n        a = min(a, (B(T[i], T[i + 1], T[i + 2], qq).x - .015) * .8);\n    }\n    // smooth minimum to improve quality at junction of handle and spout to the body\n\tfloat dTeapot = smin(a,b,.02);\n\n    return dTeapot;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat udTriangle( in vec3 v1, in vec3 v2, in vec3 v3, in vec3 p )\n{\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v13 = v1 - v3; vec3 p3 = p - v3;\n    vec3 nor = cross( v21, v13 );\n\n    return sqrt( (sign(dot(cross(v21,nor),p1)) + \n                  sign(dot(cross(v32,nor),p2)) + \n                  sign(dot(cross(v13,nor),p3))<2.0) \n                  ?\n                  min( min( \n                  dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                  dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                  dot2(v13*clamp(dot(v13,p3)/dot2(v13),0.0,1.0)-p3) )\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor) );\n}\n\nfloat opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\n//Rotation matrix\nmat3 rotate3d(float _angle)\n{\n    return mat3(1, 0, 0,\n                0, cos(_angle),-sin(_angle),\n                0, sin(_angle),cos(_angle));\n}\n\nvec3 opCheapBend(in vec3 p)\n{\n    const float k = 0.1; // or some other amount\n    float c = cos(-k*p.x);\n    float s = sin(-k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec2  xzPlaneTransform = m * vec2(p.x, p.z);\n    vec3  q = vec3(xzPlaneTransform.x, p.y, xzPlaneTransform.y);\n    return q;\n}\n\nfloat letterU(vec3 point)\n{\n    float scale = 0.2;\n    return opUnion(opUnion(opUnion(opUnion(opUnion(opUnion(\n    sdBox((point-vec3(0.25, 0.35, 0.0)) * scale, vec3(0.025, 0.05, 0.01)),\n    sdBox(point * scale, vec3(0.025, 0.025, 0.01))),\n    sdBox((point-vec3(-0.25, 0.35, 0.0)) * scale, vec3(0.025, 0.05, 0.01))),\n    udTriangle(vec3(0.02, 0.025, 0.01), vec3(0.075, 0.02, 0.01), vec3(0.02, -0.027, 0.01), point * scale)),\n    udTriangle(vec3(-0.02, 0.025, 0.01), vec3(-0.075, 0.02, 0.01), vec3(-0.02, -0.027, 0.01), point * scale)),\n    sdBox((point-vec3(0.265, 0.68, 0.0)) * scale, vec3(0.038, 0.025, 0.01))),\n    sdBox((point-vec3(-0.265, 0.68, 0.0)) * scale, vec3(0.038, 0.025, 0.01)));\n}\n\nfloat SceneSDF(vec3 point)\n{\n    float detach = (sin(iTime*speed)>=0.0?sin(iTime*speed):0.0);;\n    float dist;\n    //-0.27\n    float teapot = M(point * 0.65), U = letterU(vec3(0.0, 0.0, -1.0)*detach + (rotate3d(-0.27) * opCheapBend(point)+vec3(0.0, 0.6, -1.11)));\n    if (teapot < U)\n    {\n        dist = teapot;\n        flag = 0;\n    }\n    else\n    {\n        dist = U;\n        flag = 1;\n    }\n    return dist;\n}\n\nfloat March(vec3 origin, vec3 direction, float start, float stop, inout float edgeLength)\n{\n    float depth = start;\n    \n    for\t(int i = 0; i < MAX_STEPS; i++)\n    {\n        float dist = SceneSDF(origin + (depth * direction)); // Grab min step\n        edgeLength = min(dist, edgeLength);\n        \n        if (dist < EPSILON) // Hit\n            return depth;\n        \n        if (dist > edgeLength && edgeLength <= EDGE_THICKNESS ) // Edge hit\n            return 0.0;\n        \n        depth += dist; // Step\n        \n        if (depth >= stop) // Reached max\n            break;\n    }\n    \n    return stop;\n}\n\nvec3 RayDirection(float fov, vec2 size, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - (size / 2.0);\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 EstimateNormal(vec3 point)\n{\n    return normalize(vec3(SceneSDF(vec3(point.x + EPSILON, point.y, point.z)) - SceneSDF(vec3(point.x - EPSILON, point.y, point.z)),\n                          SceneSDF(vec3(point.x, point.y + EPSILON, point.z)) - SceneSDF(vec3(point.x, point.y - EPSILON, point.z)),\n                          SceneSDF(vec3(point.x, point.y, point.z + EPSILON)) - SceneSDF(vec3(point.x, point.y, point.z - EPSILON))));\n}\n\nmat4 LookAt(vec3 camera, vec3 target, vec3 up)\n{\n    vec3 f = normalize(target - camera);\n    vec3 s = cross(f, up);\n    vec3 u = cross(s, f);\n    \n    return mat4(vec4(s, 0.0),\n        \t\tvec4(u, 0.0),\n        \t\tvec4(-f, 0.0),\n        \t\tvec4(0.0, 0.0, 0.0, 1));\n}\n\n// NEW CODE HERE (START)\n// ORIGINAL https://www.shadertoy.com/view/XtscWS\nconst mat4 lightB2 = mat4(\n    251,166,10,165,\n    142,9,212,250,\n    7,165,250,168,\n    220,250,142,4\n)/255.;\n\nvec4 lightColorB2(vec2 fragCoord)\n{        \n    ivec2 gridPos = ivec2(fragCoord) % 4;         \n\n    float factor = lightB2[gridPos.x][3 - gridPos.y];\n\n    return vec4(vec3(factor), 1.);\n}\n\n// DARK TONE\n// diffs at [1][3], [3][1] with value of 8/255.\nconst mat4 darkB2 = mat4(\n    251,166,10,165,\n    142,9,212,8,\n    7,165,250,168,\n    220,8,142,4\n)/255.;\n    \nvec4 darkColorB(vec2 fragCoord)\n{        \n    ivec2 gridPos = ivec2(fragCoord) % 4;         \n\n    float factor = darkB2[gridPos.x][3 - gridPos.y];\n\n    return vec4(vec3(factor), 1.);\n}\n\nvec3 ComputeLighting(vec3 point, vec2 fragCoord, vec3 lightDir)\n{\n    vec3 color = vec3(AMBIENT);\n    vec3 normal = EstimateNormal(point);\n    float diffuse = dot(normal, normalize(lightDir));\n    float colorIntensity = ceil(diffuse * SHADES) / SHADES;\n    colorIntensity = max(colorIntensity, AMBIENT);  \n    \n    vec3 lightColor = flag == 0 ? TEAPOT_COLOR : U_COLOR;\n   \n    if (diffuse >= LIGHT_SHADE_CUTOFF)        \n    \tcolor = lightColor * colorIntensity;\n    else if (diffuse >= DARK_SHADE_CUTOFF) \n        color = colorIntensity * (lightColor * lightColorB2(fragCoord).xyz);\n    else\n        color = colorIntensity * (lightColor * darkColorB(fragCoord).xyz);\n        \n    float diffuseGradient = 0.5 + 0.5 * diffuse;\n    \n    vec3 textureCoords = 1.0 * point + 0.7 * vec3(floor(mod(iTime * 5.0, 3.0)));\n    float xySample = texture(iChannel0, textureCoords.xy * 0.5).r;\n    float xzSample = texture(iChannel0, textureCoords.xz).r;\n    float yzSample = texture(iChannel0, textureCoords.yz).r;\n    \n    vec3 normBlend = pow(normal, vec3(2.0));\n    normBlend = normBlend / (normBlend.x + normBlend.y + normBlend.z);\n    \n    float hatch = xySample * normBlend.z + xzSample * normBlend.y + yzSample * normBlend.x;    \n    float diffuse1StepHatch = step(-0.5 + hatch * 1.0, diffuse);\n    diffuse1StepHatch = mix(diffuse1StepHatch, diffuseGradient, 0.5);\n    \n    color = color * diffuse1StepHatch;\n    \n    return color;\n}\n\n// NEW CODE HERE (END)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ///set values for teapos\n\tSetValue();\n    vec3 viewDir = RayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 origin = vec3(sin(iTime) * 9.0, 4.0, cos(iTime) * 9.0);\n    //vec3 origin = vec3(9.0, 14.0, 9.0);\n    mat4 viewTransform = LookAt(origin, vec3(0.0), vec3(0.0, 1.0, 0.0));\n    viewDir = (viewTransform * vec4(viewDir, 0.0)).xyz;\n    \n    float edgeLength = MAX_DIST;\n    float dist = March(origin, viewDir, MIN_DIST, MAX_DIST, edgeLength);\n    \n    if (dist > MAX_DIST - EPSILON) // No hit\n    {\n        fragColor = vec4(0.6);\n        return;\n    }\n    \n    if (dist < EPSILON) // Edge hit\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    vec3 hitPoint = origin + (dist * viewDir);\n    vec3 lightDir = vec3(sin(iTime * 1.0) * 6.0, 4.0, sin(iTime * 0.7) * 5.0);\n   \n    vec3 color = ComputeLighting(hitPoint, fragCoord, lightDir);\n    \n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}