{"ver":"0.1","info":{"id":"DlsfDl","date":"1693657337","viewed":92,"name":"Maze Generator","username":"twixuss","description":"See comments for more info.","likes":24,"published":1,"flags":32,"usePreview":0,"tags":["procedural","random","generator","maze"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// All configurable parameters like size, speed and colors are in the Common tab\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n    \n    //\n    // Stack View\n    //\n    \n    if (uv.x >= 1.0) {\n        fragColor = vec4(0);\n        \n        \n        uv.x -= 1.;\n    \n        float size = float(STACK_VIEW_SIZE);\n        float cw = size*0.005; // Column width\n\n        float t = uv.x/(cw*4.0);\n        uv.x = fract(t);\n        uv.y += floor(t);\n        \n        uv.y /= size;\n        \n        fragCoord = uv * iResolution.y;\n    \n        int stackPtr = int(texelFetch(iChannel0, L_STACKPTR, 0).x);\n        if (int(fragCoord.y) <= stackPtr) {\n            ivec2 stackEntryUv = getStackValueUv(int(fragCoord.y));\n            vec4 stackEntry = vec4(texelFetch(iChannel0, stackEntryUv, 0));\n            fragColor = vec4(0);\n            \n            if(uv.x < 0.125) {\n                 fragColor.x = stackEntry.x / float(MAZE_SIZE);\n            } else if(uv.x < 0.25) {\n                fragColor.y = stackEntry.y / float(MAZE_SIZE);\n            } else if(uv.x < 0.375) {\n                fragColor.z = stackEntry.z / 24.0;\n            } else {\n                float a = 0.375 + stackEntry.w / 5.0 * 0.625;\n                if (a < uv.x && uv.x < a + 0.625/5.0)\n                    fragColor = vec4(1);\n            }\n        }\n        if (int(fragCoord.y) == stackPtr + 1)\n            fragColor = vec4(1);\n        return;\n    }\n    \n    \n    //\n    // Maze View\n    //\n    \n    // Load the cell\n    uvec4 c = uvec4(texelFetch(iChannel0, ivec2(uv * float(MAZE_SIZE)), 0));\n    \n    // Cell-relative coords\n    vec2 l = fract(uv * float(MAZE_SIZE)) - 0.5;\n    \n    // Draw the trail using connectivity mask\n    float trail = 0.;\n    float threshold = float(TRAIL_SIZE)*0.5;\n    if ((c.x & 0x1u) != 0u) {\n        if (l.x >= -threshold && abs(l.y) < threshold) {\n            trail = 1.;\n        }\n    }\n    if ((c.x & 0x2u) != 0u) {\n        if (l.y >= -threshold && abs(l.x) < threshold) {\n            trail = 1.;\n        }\n    }\n    if ((c.x & 0x4u) != 0u) {\n        if (l.x <= threshold && abs(l.y) < threshold) {\n            trail = 1.;\n        }\n    }\n    if ((c.x & 0x8u) != 0u) {\n        if (l.y <= threshold && abs(l.x) < threshold) {\n            trail = 1.;\n        }\n    }\n    \n    // Load stack top to draw a cursor\n    int stackPtr = int(texelFetch(iChannel0, L_STACKPTR, 0).x);\n    ivec2 stackTopUv = getStackValueUv(stackPtr);\n    vec4 stackTop = vec4(texelFetch(iChannel0, stackTopUv, 0));\n    \n    // Compose the final image\n    fragColor = mix(COLOR_BACKGROUND, COLOR_MAZE, float(c.y));\n    if (trail > 0.5) {\n        fragColor = COLOR_PATH;\n    }\n    if (stackPtr >= 0) {\n        if (distance(stackTop.xy, uv*float(MAZE_SIZE)-0.5) < 0.4) {\n            fragColor = COLOR_CURSOR;\n        }\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//\n// Basic maze generator.\n// \n// Algorithm:\n//\n// 1. Push random starting point onto the stack\n// 2. Get current location from top of the stack\n// 3. If there are one or more non-visited neighboring cells:\n// 3.1. Pick a random one, mark it as visited, update connectivity and push new location onto the stack.\n// 3.2. Otherwise, pop the stack.\n// 4. If stack is not empty, goto 2.\n//\n// The grid is stored in MAZE_SIZE*MAZE_SIZE square at the start of Buffer A.\n// Outside of it is stack pointer, which stores the stack size-1,\n// and a region for the stack itself.\n//\n// Data Format:\n// Grid:\n//     x:uint[0;15] - connectivity mask\n//     y:bool       - was visited\n//\n// Stack:\n//     xy:uint[0;MAZE_SIZE-1] - cell position\n//     z:uint[0;23]           - random direction offset\n//     w:uint[0;4]            - next direction index\n\n\nconst ivec2 directions[24*4] = ivec2[](\n    ivec2(0, 1), ivec2(1, 0), ivec2(0, -1), ivec2(-1, 0),\n    ivec2(0, 1), ivec2(1, 0), ivec2(-1, 0), ivec2(0, -1),\n    ivec2(0, 1), ivec2(0, -1), ivec2(1, 0), ivec2(-1, 0),\n    ivec2(0, 1), ivec2(0, -1), ivec2(-1, 0), ivec2(1, 0),\n    ivec2(0, 1), ivec2(-1, 0), ivec2(1, 0), ivec2(0, -1),\n    ivec2(0, 1), ivec2(-1, 0), ivec2(0, -1), ivec2(1, 0),\n    ivec2(1, 0), ivec2(0, 1), ivec2(0, -1), ivec2(-1, 0),\n    ivec2(1, 0), ivec2(0, 1), ivec2(-1, 0), ivec2(0, -1),\n    ivec2(1, 0), ivec2(0, -1), ivec2(0, 1), ivec2(-1, 0),\n    ivec2(1, 0), ivec2(0, -1), ivec2(-1, 0), ivec2(0, 1),\n    ivec2(1, 0), ivec2(-1, 0), ivec2(0, 1), ivec2(0, -1),\n    ivec2(1, 0), ivec2(-1, 0), ivec2(0, -1), ivec2(0, 1),\n    ivec2(0, -1), ivec2(0, 1), ivec2(1, 0), ivec2(-1, 0),\n    ivec2(0, -1), ivec2(0, 1), ivec2(-1, 0), ivec2(1, 0),\n    ivec2(0, -1), ivec2(1, 0), ivec2(0, 1), ivec2(-1, 0),\n    ivec2(0, -1), ivec2(1, 0), ivec2(-1, 0), ivec2(0, 1),\n    ivec2(0, -1), ivec2(-1, 0), ivec2(0, 1), ivec2(1, 0),\n    ivec2(0, -1), ivec2(-1, 0), ivec2(1, 0), ivec2(0, 1),\n    ivec2(-1, 0), ivec2(0, 1), ivec2(1, 0), ivec2(0, -1),\n    ivec2(-1, 0), ivec2(0, 1), ivec2(0, -1), ivec2(1, 0),\n    ivec2(-1, 0), ivec2(1, 0), ivec2(0, 1), ivec2(0, -1),\n    ivec2(-1, 0), ivec2(1, 0), ivec2(0, -1), ivec2(0, 1),\n    ivec2(-1, 0), ivec2(0, -1), ivec2(0, 1), ivec2(1, 0),\n    ivec2(-1, 0), ivec2(0, -1), ivec2(1, 0), ivec2(0, 1)\n);\n\nuint getRandomDirectionOffset(){\n    return (timerand()>>16u)%24u;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 uv = ivec2(fragCoord);\n    if (iFrame == 0) {\n        fragColor = vec4(0);\n        \n        ivec2 startCoord = START_COORD;\n        \n        // Push starting coord\n        if (uv == L_STACK)\n            fragColor = vec4(startCoord, getRandomDirectionOffset(), 0);\n        if (uv == L_STACKPTR)\n            fragColor = vec4(0, 0, 0, 0);\n            \n        // Mark starting coord as visited\n        if (uv == startCoord)\n            fragColor = vec4(0, 1, 0, 0);\n\n        return;\n    }\n    \n    fragColor = texelFetch(iChannel0, uv, 0);\n    int stackPtr = int(texelFetch(iChannel0, L_STACKPTR, 0).x);\n\n    // Slowmo\n    if ((iFrame % GENERATION_DELTATIME) != 0)\n        return;\n    \n    // We are done if stack is empty\n    if (stackPtr < 0)\n        return;\n    \n    // Get cell from top of stack\n    ivec2 stackTopUv = getStackValueUv(stackPtr);\n    ivec4 stackTop = ivec4(texelFetch(iChannel0, stackTopUv, 0));\n    \n    if (stackTop.w < 4)\n    {\n        // I tried to check all four directions in a loop here,\n        // but for some reason some cells were missed. I couldn't\n        // figure out why, so I check them one by one.\n    \n        // Get the next direction\n        ivec2 dir = directions[stackTop.z*4 + stackTop.w];\n        \n        // Update next direction index\n        if (uv == stackTopUv) {\n            fragColor.w += 1.;\n            stackTop.w += 1;\n        }\n\n        ivec2 nextUv = stackTop.xy + dir;\n\n        if (0 <= nextUv.x && nextUv.x < MAZE_SIZE && 0 <= nextUv.y && nextUv.y < MAZE_SIZE)\n        {\n            // Load neighbor cell\n            ivec4 next = ivec4(texelFetch(iChannel0, nextUv, 0));\n\n            // If not visited\n            if (next.y != 1)\n            {\n                // Mark as visited\n                if (uv == nextUv) {\n                    fragColor.y = 1.;\n                }\n                \n                // Update connectivity\n                if (uv == stackTop.xy) {\n                    if (dir == ivec2(+1,0)) fragColor.x = float(uint(fragColor.x)|1u);\n                    if (dir == ivec2(0,+1)) fragColor.x = float(uint(fragColor.x)|2u);\n                    if (dir == ivec2(-1,0)) fragColor.x = float(uint(fragColor.x)|4u);\n                    if (dir == ivec2(0,-1)) fragColor.x = float(uint(fragColor.x)|8u);\n                }\n                if (uv == nextUv.xy) {\n                    if (dir == ivec2(+1,0)) fragColor.x = float(uint(fragColor.x)|4u);\n                    if (dir == ivec2(0,+1)) fragColor.x = float(uint(fragColor.x)|8u);\n                    if (dir == ivec2(-1,0)) fragColor.x = float(uint(fragColor.x)|1u);\n                    if (dir == ivec2(0,-1)) fragColor.x = float(uint(fragColor.x)|2u);\n                }\n\n                // Push new cell\n                if (uv == L_STACKPTR) {\n                    fragColor.x += 1.;\n                }\n                if (uv == getStackValueUv(stackPtr+1)) {\n                    fragColor = vec4(nextUv, getRandomDirectionOffset(), 0);\n                }\n            }\n        }\n    }\n    else\n    {\n        // Pop the cell\n        if (uv == L_STACKPTR) {\n            fragColor.x -= 1.;\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//\n// Config\n//\n\n// NOTE: limited by buffer resolution.\n// If you make this too big, the stack, which in the worst case\n// can reach a size of MAZE_SIZE**2, can overflow and something will break.\n#define MAZE_SIZE 8\n#define START_COORD ivec2(\\\n    timerandp(0u) % uint(MAZE_SIZE), \\\n    timerandp(1u) % uint(MAZE_SIZE))\n    \n#define COLOR_BACKGROUND vec4(0.2, 0.1, 0.2, 1)\n#define COLOR_MAZE       vec4(0.2, 0.5, 0.6, 1)\n#define COLOR_PATH       vec4(0.8)\n#define COLOR_CURSOR     vec4(1.0, 0.2, 0.2, 1)\n\n#define TRAIL_SIZE 0.5\n#define STACK_VIEW_SIZE 12.0\n\n// Increase this number to slow down generation.\n#define GENERATION_DELTATIME 3\n\n// ======================================================================================================================\n\n//\n// Storage locations\n//\n\n#define L_STACKPTR ivec2(MAZE_SIZE + 0, 0)\n\n// Everyting in x+ and y+ directions is reserved for the stack.\n#define L_STACK    ivec2(MAZE_SIZE + 1, 0)\n\n// \n// Utilities\n//\n\nuint rand(uint x) {\n    const uint k = 3282017729u;\n    x *= k; x ^= k;\n    x *= k; x ^= k;\n    x *= k; x ^= k;\n    x *= k; x ^= k;\n    return x;\n}\n\n// This is not a function because iFrame is not available in common\n#define timerandp(seed) rand(uint(dot(vec3(iFrame, iDate.w, seed), vec3(123, 456, 789))))\n#define timerand() timerandp(0u)\n\nfloat u2f(uint x) {\n    x >>= 9;\n    x |= 0x3f800000u;\n    return uintBitsToFloat(x) - 1.0;\n}\n\nivec2 getStackValueUv(int stackPtr) {\n    return L_STACK+ivec2(uint(stackPtr) / 256u, uint(stackPtr) % 256u);\n}\n","name":"Common","description":"","type":"common"}]}