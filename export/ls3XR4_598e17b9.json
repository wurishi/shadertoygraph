{"ver":"0.1","info":{"id":"ls3XR4","date":"1457899031","viewed":426,"name":"Magic Orbs","username":"zackpudil","description":"WASD, SPACE and SHIFT to move around.  Mouse (click and hold) to look around.","likes":12,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","distancefields"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.1415926535897932384626433832795\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n ) {\n  return fract(sin(n)*43758.5453);\n}\n\n\nfloat noise( in vec3 x ) {\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n\n  f = f*f*(3.0-2.0*f);\n\n  float n = p.x + p.y*57.0 + 113.0*p.z;\n\n  float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                      mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                  mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                      mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n  return res;\n}\n\nfloat fbm( vec3 p ) {\n  float f = 0.0;\n\n  f += 0.5000*noise( p ); p = m*p*2.02;\n  f += 0.2500*noise( p ); p = m*p*2.03;\n  f += 0.1250*noise( p ); p = m*p*2.01;\n  f += 0.0625*noise( p );\n\n  return f/0.9375;\n}\n\n// distance fields\nfloat plane(vec3 p, vec4 n) {\n  return dot(p, n.xyz) + n.w;\n}\n\nfloat sphere(vec3 p, float radius) {\n  return length(p) - radius;\n}\n\nfloat box(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat box2(vec2 p, vec2 b) {\n  vec2 h = abs(p) - b;\n  return min(max(h.x, h.y), 0.0) + length(max(h, 0.0));\n}\n\nfloat cylinder(vec3 p, vec2 h) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// operations on distance fields\nvec2 unionRightAngle(vec2 a, vec2 b) {\n  float d = min(a.x, b.x);\n  return vec2(d, d == a.x ? a.y : b.y);\n}\n\nvec2 unionChamfer(vec2 a, vec2 b, float r) {\n  return min(min(a, b), (a - vec2(r) + b)*sqrt(0.5));\n}\n\nvec2 compliment(vec2 a, vec2 b) {\n  float d = max(-a.x, b.x);\n  return vec2(d, d == a.x ? a.y : b.y);\n}\n\n// Domain operations\nvoid rep(inout float p, float o) {\n  p = mod(p + o, o*2.0) - o;\n}\n\nvoid rep(inout vec2 p, vec2 o) {\n  p = mod(p + o, o*2.0) - o;\n}\n\nvoid mirrorLeft(inout float p, float o) {\n  p = abs(p) - o;\n}\n\nvoid mirrorLeft(inout vec2 p, vec2 o) {\n  p = abs(p) - o;\n  if(p.y > p.x) p.xy = p.yx;\n}\n\nvoid mirrorRight(inout float p, float o) {\n  p = -abs(p) + o;\n}\n\nvoid mirrorRight(inout vec2 p, vec2 o) {\n  p = -abs(p) + o;\n  if(p.y > p.x) p.xy = p.yx;\n}\n\nvoid rotateX(inout vec3 p, float a) {\n  float r = a*pi/180.0;\n  mat3 rx = mat3(1,   0,      0,\n                 0, cos(r), sin(r),\n                 0, -sin(r), cos(r));\n\n  p = rx*p;\n}\n\nvec3 sphereMaterial(vec3 p) {\n  vec3 sphereColor = vec3(1.0,fract(sin(p.x)),fract(sin(p.z)));\n  float a = atan(p.x,p.z);\n  float r = length(p.xz);\n  float f = smoothstep( 0.1, 1.0, fbm(p) );\n  float t = mod(iTime*.5, 4.0*pi);\n  sphereColor = mix( sphereColor, vec3(0.0,0.0,1.0), f );\n  f = smoothstep( 0.0, 1.0, fbm(p + t) );\n  sphereColor *= f;\n\n  f = fbm( vec3(a*7.0 + p.z,3.0*p.y,p.x)*2.0);\n  f = smoothstep( 0.2,1.0,f);\n  f *= smoothstep(0.4,1.2,p.y + 0.75*(noise(4.0*p.zyx)-0.5) );\n  sphereColor = mix( sphereColor, vec3(0.4,0.2,0.0), 0.5*f );\n\n  return sphereColor;\n}\n\nvec3 brickMaterial(vec3 p) {\n  vec3 wallColor = vec3(0.75);\n  float f = fbm( 4.0*p*vec3(1.0,9.0,0.5) );\n  wallColor = mix( wallColor, vec3(0.2,0.2,0.2)*1.7, f );\n  f = fbm( 2.0*p);\n  wallColor *= 0.7+0.3*f;\n\n  return wallColor;\n}\n\nfloat box2d(vec2 p, vec2 b) {\n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nvec3 buildingMaterial(vec3 pos, vec3 n) {\n  vec3 t = (n - pos);\n  vec2 uv = abs(n.z) > abs(n.y) ? t.xy : t.zy;\n  float r = 0.0;\n\n\tuv.x = mod(uv.x + 0.55, 1.07) - 0.545;\n\tuv.y = mod(uv.y + 0.55, 1.17) - 0.55;\n\n\tr = box2d(uv - vec2(0.0, 0.5), vec2(0.2, 0.1));\n\tr = min(r, box2d(uv - vec2(0.0, 0.23), vec2(0.15, 0.15)));\n\tr = min(r, box2d(uv - vec2(0.0, -0.14), vec2(0.42, 0.2)));\n\tr = min(r, box2d(uv - vec2(0.0, -0.51), vec2(0.3, 0.15)));\n\n\tr = min(r, box2d(uv - vec2(-0.41, 0.5), vec2(0.2, 0.1)));\n\tr = min(r, box2d(uv - vec2(-0.385, 0.23), vec2(0.225, 0.15)));\n\tr = min(r, box2d(uv - vec2(-0.52, -0.14), vec2(0.09, 0.2)));\n\tr = min(r, box2d(uv - vec2(-0.46, -0.51), vec2(0.15, 0.15)));\n\n\tr = min(r, box2d(uv - vec2(0.41, 0.5), vec2(0.2, 0.1)));\n\tr = min(r, box2d(uv - vec2(0.385, 0.23), vec2(0.225, 0.15)));\n\tr = min(r, box2d(uv - vec2(0.52, -0.14), vec2(0.09, 0.2)));\n\tr = min(r, box2d(uv - vec2(0.46, -0.51), vec2(0.15, 0.15)));\n\n\tvec3 col = vec3(0.25);\n\tif(r < 0.0) col = vec3(0.35, 0.25, 0.12)*brickMaterial(pos);\n  return col;\n}\n\nvec3 roofMaterial(vec3 pos, vec3 n) {\n  vec3 t = (n - pos);\n  vec2 uv = abs(n.z) > abs(n.y) ? t.xy : t.zy;\n\n  rep(uv.x, 0.23);\n  rep(uv.y, 0.23);\n\n  float r = box2d(uv, vec2(0.2, 0.2));\n\n  vec3 col = vec3(0.2, 0.2, 0.2);\n  if(r < 0.0) col = vec3(1, 0.2, 0.2)*brickMaterial(vec3(0.0, uv));\n\n  return col;\n}\n\nvec3 pillarMaterial(vec3 pos) {\n  vec3 col = brickMaterial(pos);\n  float f = smoothstep(0.0, 1.0, fbm(pos*48.0));\n  f = smoothstep(0.7, 0.9, f);\n\n  col = mix(col, vec3(0.2), f*0.75);\n  return col;\n}\n\nvec3 floorMaterial(vec3 p) {\n  vec3 planeColor = vec3(1.0)*mod(floor(p.z) + floor(p.x), 2.0);\n  return planeColor;\n}\n\nvec2 scene(vec3 p) {\n  vec2 planeDI = vec2(plane(p, vec4(0, 1, 0, 0)),0.0);\n  p.y -= 1.45;\n\n  rep(p.xz, vec2(13, 13));\n  mirrorLeft(p.xz, vec2(5, 5));\n  vec2 sphereDI = vec2(sphere(p + vec3(0, -1.0, 0), 0.6), 1.0);\n\n  vec3 m = p;\n  mirrorRight(m.xz, vec2(0.15, 0.15));\n  vec2 column = vec2(cylinder(m + vec3(0, 0.62, 0), vec2(0.2, 0.9)), 2.0);\n  m = p;\n  m.y += 0.53;\n  mirrorLeft(m.y, 0.82);\n  vec2 platform = vec2(box(m, vec3(0.7, 0.1, 0.7)), 2.0);\n\n  vec2 pillar = unionChamfer(platform, column, 0.1);\n  pillar = unionRightAngle(sphereDI, pillar);\n  mirrorRight(p.xz, vec2(5, 5));\n  mirrorRight(p.z, 1.5);\n  vec2 wall = vec2(box2(p.yz, vec2(1.5, 0.07)), 3.0);\n\n  m = p;\n  m.yz -= vec2(2.7, 1.05);\n  rotateX(m, 45.0);\n  vec2 roof = vec2(box2(m.yz, vec2(0.05, 1.7)), 4.0);\n  vec2 building = unionRightAngle(roof, wall);\n\n  rep(p.x, 1.5);\n  mirrorLeft(p.x, 0.55);\n  mirrorLeft(p.x, -0.2);\n  p.y += 0.3;\n  vec2 boxDI = vec2(box(p, vec3(0.6, 0.7, 0.1)), 0.0);\n  p.y -= 0.7;\n  vec2 cylinderDI = vec2(cylinder(p.xzy, vec2(0.6, 0.1)), 0.0);\n\n  vec2 windows = unionRightAngle(boxDI, cylinderDI);\n  building = compliment(windows, building);\n  building = unionRightAngle(building, pillar);\n\n  vec2 scene = unionRightAngle(planeDI, building);\n\n  return scene;\n}\n\nvec3 getNormal(vec3 p) {\n  float h = 0.0001;\n\n  vec3 x = vec3(h, 0, 0);\n  vec3 y = vec3(0, h, 0);\n  vec3 z = vec3(0, 0, h);\n\n  return normalize(vec3(\n    (scene(p + x).x - scene(p - x).x)/h,\n    (scene(p + y).x - scene(p - y).x)/h,\n    (scene(p + z).x - scene(p - z).x)/h));\n}\n\nfloat getShadow(vec3 p0, vec3 p1, float k) {\n  vec3 rd = p1;\n  float f = 1.0;\n  float t = 0.001;\n  float tmax = 10.0;\n\n  for(int i = 0; i < 100; i++) {\n    float d = scene(p0 + rd*t).x;\n    if(d < 0.0) break;\n    f = min(f, k*d/t);\n    t += d;\n    if(t >= tmax) break;\n  }\n\n  return clamp(f, 0.0, 1.0);\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n) {\n  float stepSize = 0.01;\n  float t = stepSize;\n\n  float oc = 0.0;\n  for(int i = 0; i < 10; i++) {\n    float d = scene(p + n*t).x;\n    oc += t - d;\n    t += stepSize;\n  }\n\n  return clamp(oc, 0.0, 1.0);\n}\n\nvec3 getShading(vec3 p, vec3 n, vec3 l) {\n  float ints = 0.0;\n  float shadow = getShadow(p, l, 15.5);\n  float ao = ambientOcclusion(p, n);\n\n   \tints = clamp(dot(n, l), 0.0, 1.0)*shadow;\n\n  return vec3(1.0)*ints + vec3(0.4)*(1.0 - ints)*(1.0 - ao);\n}\n\nvec2 raymarch(vec3 rayOrigin, vec3 rayDirection) {\n  float t = 0.0;\n  float m = -1.0;\n\n  for(int i = 0; i < 64; i++) {\n    vec3 p = rayOrigin + rayDirection*t;\n    vec2 s = scene(p);\n    if(s.x < 0.002) break;\n    t += s.x;\n    m = s.y;\n  }\n\n  if(t > 50.0) m = -1.0;\n  return vec2(t, m);\n}\n\nmat3 cameraMatrix() {\n    vec2 mo = -1.0 + 2.0*(iMouse.xy - abs(iMouse.zw));\n    mo.y = -mo.y;\n    vec2 rad = mo*pi/180.;\n    \n    vec2 s = sin(rad);\n    vec2 c = cos(rad);\n    \n    vec3 f = vec3(c.y*s.x, -s.y, c.y*c.x);\n    vec3 r = vec3(c.x, 0, -s.x);\n    vec3 u = normalize(cross(f, r));\n    \n    return mat3(r, u, f);\n}\n\nvec3 cameraPosition() {\n    return texture(iChannel0, vec2(0)).xyz;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = -1.0+2.0*fragCoord/iResolution.xy;\n  uv.x *= iResolution.x/iResolution.y;\n\n  vec3 ro = cameraPosition();\n  vec3 rd = cameraMatrix()*normalize(vec3(uv, 1.97));\n\n  vec2 render = raymarch(ro, rd);\n\n  if(render.y > -1.0) {\n    vec3 pos = ro + render.x*rd;\n    vec3 normal = getNormal(pos);\n    vec3 shading = getShading(pos, normal, normalize(vec3(0.8, 0.7, -0.6)));\n\n    vec3 col;\n    if(render.y == 0.0)\n      col = floorMaterial(pos);\n    else if(render.y == 1.0)\n      col = sphereMaterial(pos);\n    else if(render.y == 2.0)\n      col = pillarMaterial(pos);\n    else if(render.y == 3.0)\n      col = buildingMaterial(pos, normal);\n    else if(render.y == 4.0)\n      col = roofMaterial(pos, normal);\n\n    fragColor = vec4(pow(col*shading, vec3(0.474)), 1);\n  } else {\n    fragColor = vec4(vec3(0.25), 1.0);\n  }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float KEY_W     = 87.5/256.0;\nconst float KEY_A     = 65.5/256.0;\nconst float KEY_D     = 68.5/256.0;\nconst float KEY_S     = 83.5/256.0;\n\nconst float KEY_SP    = 32.5/256.0;\nconst float KEY_SH\t  = 16.5/256.0;\n\nconst float PI = 3.14159265359;\n\nfloat isKeyPressed(float key)\n{\n\treturn texture( iChannel1, vec2(key, 0.0) ).x;\n}\n\nmat3 cameraMatrix() {\n    vec2 mo = -1.0 + 2.0*(iMouse.xy - abs(iMouse.zw));\n    mo.y = -mo.y;\n    vec2 rad = mo*PI/180.;\n    \n    vec2 s = sin(rad);\n    vec2 c = cos(rad);\n    \n    vec3 f = vec3(c.y*s.x, -s.y, c.y*c.x);\n    vec3 r = vec3(c.x, 0, -s.x);\n    vec3 u = normalize(cross(f, r));\n    \n    return mat3(r, u, f);\n}\n\nvec3 cameraPosition() {\n    vec3 p =  texture(iChannel0, vec2(0)).xyz;\n    if(p.x == 0.0 && p.y == 0.0 && p.z == 0.0) return vec3(5.0, 2.5, -7.0);\n    \n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 cp = cameraPosition();\n    mat3 cm = cameraMatrix();\n    \n    float speed = 0.2;\n    \n    if(isKeyPressed(KEY_W) == 1.0) cp += cm[2]*speed;\n    if(isKeyPressed(KEY_S) == 1.0) cp -= cm[2]*speed;\n    if(isKeyPressed(KEY_A) == 1.0) cp -= cm[0]*speed;\n    if(isKeyPressed(KEY_D) == 1.0) cp += cm[0]*speed;\n    if(isKeyPressed(KEY_SP) == 1.0) cp += cm[1]*speed;\n    if(isKeyPressed(KEY_SH) == 1.0) cp -= cm[1]*speed;\n    \n    cp.y = max(1.0, cp.y);\n    \n    \n    fragColor = vec4(cp, 0.0);\n}","name":"Buf A","description":"","type":"buffer"}]}