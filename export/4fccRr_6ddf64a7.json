{"ver":"0.1","info":{"id":"4fccRr","date":"1730135177","viewed":50,"name":"Fork 12312321kk ivankovale 126","username":"ivankovalenko","description":"2312313v3.12222433уpochti32","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["1231313v2433pochti"],"hasliked":0,"parentid":"M3sBDj","parentname":"12312321kkkkk"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Constants\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\n\n// Rotate around a circular path\nmat2 rotate2d(float theta) {\n    float s = sin(theta), c = cos(theta);\n    return mat2(c, -s, s, c);\n}\n\n// Rotation matrix around the Y axis (for turret rotation).\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the X axis (for gun elevation).\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nstruct Surface {\n    float sd; // signed distance value\n    vec3 col; // color\n};\n\n// Box signed distance function\nSurface sdBox(vec3 p, vec3 b, vec3 offset, vec3 col, mat3 transform) {\n    p = (p - offset) * transform; // apply transformation matrix\n    vec3 q = abs(p) - b;\n    float d = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n    return Surface(d, col);\n}\n\n// Floor signed distance function\nSurface sdFloor(vec3 p, vec3 col) {\n    float d = p.y + 1.;\n    return Surface(d, col);\n}\n\n// Find the closest object\nSurface minWithColor(Surface obj1, Surface obj2) {\n    if (obj2.sd < obj1.sd) return obj2;\n    return obj1;\n}\n\n// Scene function (tank + environment)\nSurface sdScene(vec3 p, float turretAngle, float gunAngle, vec3 shotInfo) {\n    vec3 floorColor = vec3(0.5, 0.9, 0.1);\n    Surface co = sdFloor(p, floorColor);\n\n    // Tank body (center cube)\n    co = minWithColor(co, sdBox(p, vec3(1.0, 0.5, 2.0), vec3(0, 0.25, -4), vec3(0, 0.65, 0.2), identity()));\n\n    // Tank turret (rotating part)\n    mat3 turretRotation = rotateY(turretAngle); // apply turret rotation\n    co = minWithColor(co, sdBox(p, vec3(0.7, 0.4, 0.7), vec3(0.0, 1.0, -4), vec3(0.2, 0.2, 0.2), turretRotation));\n\n    // Tank cannon (attached to the turret)\n    mat3 gunRotation = rotateX(gunAngle); // apply gun elevation\n    vec3 cannonOffset = vec3(0, 0.2, 0.5);  // Offset the cannon to the front of the turret\n\n    // Чтобы вращение происходило от начала ствола, сначала сместим ствол так, чтобы его начальная точка оказалась в центре координат (0, 0, 0)\n    vec3 cannonStartPosition = vec3(0.0, 1.0, -4); // позиция начала ствола\n    vec3 cannonEndPosition = cannonStartPosition + (turretRotation * cannonOffset); // позиция конца ствола после вращения\n\n    // Применяем вращение ствола вокруг начала пушки\n    co = minWithColor(co, sdBox(p, vec3(0.1, 0.1, 1.0), cannonEndPosition, vec3(0.3, 0.2, 0.2), turretRotation * gunRotation));\n\n    // Tank tracks (left and right)\n    co = minWithColor(co, sdBox(p, vec3(1.1, 0.2, 0.5), vec3(0.0, -0.1, -3.5), vec3(0.8, 0.4, 0.4), identity())); // center tracks\n    co = minWithColor(co, sdBox(p, vec3(0.2, 0.4, 1.9), vec3(-1.2, 0.1, -4), vec3(0.2, 0.2, 0.2), identity())); // left tracks\n    co = minWithColor(co, sdBox(p, vec3(0.2, 0.4, 1.9), vec3(1.2, 0.1, -4), vec3(0.2, 0.2, 0.2), identity()));  // right tracks\n    \n    vec3 spherePosition = vec3(shotInfo.x, shotInfo.y+1.0, -4.0); // Учитываем только положение из shotInfo\n    float sphereRadius = 0.2;\n    co = minWithColor(co, Surface(sdSphere(p - spherePosition, sphereRadius), vec3(1.0, 0.5, 0.2))); // Оранжевая сфера\n\n    //tank2\n    co = minWithColor(co, sdBox(p, vec3(0.7, 0.4, 0.7), vec3(8.0, 1.0, -4), vec3(0.2, 0.2, 0.2), identity()));\n    co = minWithColor(co, sdBox(p, vec3(1.0, 0.5, 2.0), vec3(8.0, 0.25, -4), vec3(0, 0.65, 0.2), identity()));\n    co = minWithColor(co, sdBox(p, vec3(0.1, 0.1, 1.0), vec3(8.0,1.0,-3.4), vec3(0.3, 0.2, 0.2), identity()));\n    \n    co = minWithColor(co, sdBox(p, vec3(1.1, 0.2, 0.5), vec3(8.0, -0.1, -3.5), vec3(0.4, 0.4, 0.4), identity())); // center tracks\n    co = minWithColor(co, sdBox(p, vec3(0.2, 0.4, 1.9), vec3(-1.2+8.0, 0.1, -4), vec3(0.2, 0.2, 0.2), identity())); // left tracks\n    co = minWithColor(co, sdBox(p, vec3(0.2, 0.4, 1.9), vec3(9.2, 0.1, -4), vec3(0.2, 0.2, 0.2), identity()));\n    return co;\n}\n\n\n// Raymarching function\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end, float turretAngle, float gunAngle, vec3 shotInfo) {\n    float depth = start;\n    Surface co;\n\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 p = ro + depth * rd;\n        co = sdScene(p, turretAngle, gunAngle, shotInfo);\n        depth += co.sd;\n        if (co.sd < PRECISION || depth > end) break;\n    }\n\n    co.sd = depth;\n    return co;\n}\n\n// Calculate normal vector\nvec3 calcNormal(in vec3 p, float turretAngle, float gunAngle, vec3 shotInfo) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n        e.xyy * sdScene(p + e.xyy, turretAngle, gunAngle, shotInfo).sd +\n        e.yyx * sdScene(p + e.yyx, turretAngle, gunAngle, shotInfo).sd +\n        e.yxy * sdScene(p + e.yxy, turretAngle, gunAngle, shotInfo).sd +\n        e.xxx * sdScene(p + e.xxx, turretAngle, gunAngle, shotInfo).sd);\n}\n\n// Camera setup\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n    vec3 cd = normalize(lookAtPoint - cameraPos);\n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n    vec3 cu = normalize(cross(cd, cr));\n    return mat3(-cr, cu, -cd);\n}\n\n// Main function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 mouseUV = iMouse.xy / iResolution.xy; \n    vec3 backgroundColor = vec3(0.835, 1, 1);\n\n    vec3 col = vec3(0);\n    vec3 lp = vec3(0, 0.9, -4);\n    vec3 ro = vec3(0, 3, 0); \n\n    float cameraRadius = 5.0;\n    ro.yz = ro.yz * cameraRadius * rotate2d(mix(PI / 2., 0., mouseUV.y));\n    ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n    vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1));\n\n    vec3 shotInfo = texelFetch(iChannel0, ivec2(0, 1), 0).xyz;\n    vec2 turretOffset = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    vec3 tankPosRot = texelFetch(iChannel0, ivec2(0, 2), 0).xyz;\n\n    float turretAngle = turretOffset.x * 1.8;\n    float gunAngle = turretOffset.y * 0.5;\n    vec3 tankPosition = vec3(tankPosRot.xy, -4.0); // Используем координаты танка\n    float tankRotation = tankPosRot.z; // Используем угол поворота танка\n\n    Surface co = rayMarch(ro, rd, MIN_DIST, MAX_DIST, turretAngle, gunAngle, shotInfo);\n\n    if (co.sd > MAX_DIST) {\n        col = backgroundColor;\n    } else {\n        vec3 p = ro + rd * co.sd;\n        vec3 normal = calcNormal(p, turretAngle, gunAngle, shotInfo);\n        vec3 lightPosition = vec3(2, 2, 7);\n        vec3 lightDirection = normalize(lightPosition - p);\n        float dif = clamp(dot(normal, lightDirection), 0.3, 1.0);\n        col = dif * co.col + backgroundColor * 0.2;\n    }\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Rotation matrix around the Y axis (for turret rotation).\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the X axis (for gun elevation).\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Константы для клавиш\nconst int KEY_LEFT  = 65;  // A - поворот башни влево\nconst int KEY_RIGHT = 68;  // D - поворот башни вправо\nconst int KEY_UP    = 87;  // W - наклон пушки вверх\nconst int KEY_DOWN  = 83;  // S - наклон пушки вниз\nconst int KEY_SHOOT = 67;  // C - выстрел\n\n// Константы для движения танка (стрелки)\nconst int KEY_MOVE_FORWARD = 38; // Вперёд - стрелка вверх\nconst int KEY_MOVE_BACKWARD = 40; // Назад - стрелка вниз\nconst int KEY_TURN_LEFT = 37; // Поворот влево - стрелка влево\nconst int KEY_TURN_RIGHT = 39; // Поворот вправо - стрелка вправо\n\n// Позиция и угол танка\nvec3 tankPosition = vec3(0.0, 0.0, 0.0);\nfloat tankRotation = 0.0;\n\n// Позиция башни\nvec3 turretPosition = vec3(0.0, 1.0, -4.0);\n\n// Обработка клавиш для управления башней и пушкой\nvec2 handleKeyboardTurret(vec2 offset) {\n    float velocity = 1.0 / 100.0; // Скорость поворота\n    vec2 left = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x * vec2(-1, 0);\n    vec2 right = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x * vec2(1, 0);\n    vec2 up = texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).x * vec2(0, 1);\n    vec2 down = texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x * vec2(0, -1);\n    \n    offset += (left + right + up + down) * velocity;\n    return offset;\n}\n\n// Обработка клавиш для движения танка\nvoid handleKeyboardMovement() {\n    float moveSpeed = 0.05;\n    float rotationSpeed = 0.05;\n\n    float forward = texelFetch(iChannel1, ivec2(KEY_MOVE_FORWARD, 0), 0).x;\n    float backward = texelFetch(iChannel1, ivec2(KEY_MOVE_BACKWARD, 0), 0).x;\n    float turnLeft = texelFetch(iChannel1, ivec2(KEY_TURN_LEFT, 0), 0).x;\n    float turnRight = texelFetch(iChannel1, ivec2(KEY_TURN_RIGHT, 0), 0).x;\n\n    // Изменяем угол поворота танка\n    tankRotation += (turnRight - turnLeft) * rotationSpeed;\n\n    // Движение танка вперёд и назад по направлению, заданному текущим углом поворота\n    vec3 direction = vec3(sin(tankRotation), 0.0, -cos(tankRotation));\n    tankPosition += direction * (forward - backward) * moveSpeed;\n}\n\n// Функция для обработки выстрела\nvec3 handleShot(vec3 shotInfo, vec3 cannonPosition, vec3 cannonDirection) {\n    float shoot = texelFetch(iChannel1, ivec2(KEY_SHOOT, 0), 0).x;\n    float deltaTime = iTimeDelta;\n    \n    if (shoot != 0.0 && shotInfo.z == 0.0) {\n        shotInfo = cannonPosition;\n        shotInfo.z = 1.0;\n        shotInfo.xy = cannonDirection.xy;\n    } \n    else if (shotInfo.z > 0.0) {\n        float bulletSpeed = 100.0;\n        shotInfo += cannonDirection * bulletSpeed * deltaTime;\n        if (length(shotInfo - turretPosition) > 100.0) {\n            shotInfo.z = 0.0;\n        }\n    }\n    return shotInfo;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 offset = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    vec3 shotInfo = texelFetch(iChannel0, ivec2(0, 1), 0).xyz;\n    \n    // Обновляем повороты башни и пушки\n    offset = handleKeyboardTurret(offset);\n    offset.y = clamp(offset.y, -0.2, 0.39);\n\n    // Обновляем движение танка\n    handleKeyboardMovement();\n\n    // Комбинируем вращение вокруг Y для башни и вокруг X для дула\n    mat3 fullRotation = rotateY(offset.x) * rotateX(offset.y); \n    vec3 adjustedCannonPosition = turretPosition + (fullRotation * vec3(0.0, 0.0, 1.0));\n    vec3 cannonDirection = normalize(fullRotation * vec3(0.0, 0.0, 1.0));\n\n    shotInfo = handleShot(shotInfo, adjustedCannonPosition, cannonDirection);\n\n    // Сохранение состояния\n    if (int(fragCoord.x) == 0 && int(fragCoord.y) == 0) {\n        fragColor = vec4(offset, 1.0, 1.0);\n    }\n    if (int(fragCoord.x) == 0 && int(fragCoord.y) == 1) {\n        fragColor = vec4(shotInfo, 1.0);\n    }\n    if (int(fragCoord.x) == 0 && int(fragCoord.y) == 2) {\n        fragColor = vec4(tankPosition.xy, tankRotation, 1.0); // Передаем позицию танка и его поворот\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}