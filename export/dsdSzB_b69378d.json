{"ver":"0.1","info":{"id":"dsdSzB","date":"1680076867","viewed":113,"name":"Regular Polygon Animation","username":"kokodayo","description":"Animation of rotation around a positive polygon","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["2dsdf","rotationanimation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.14159265\n#define M_2_PI 6.28318531\n\nmat2 rotate2d(float _angle){\n  return mat2(cos(_angle),-sin(_angle),sin(_angle),cos(_angle));\n}\n\n// signed distance to a n-star polygon with external angle en\nfloat sdRegularPolygon(in vec2 p, in float r, in int n )\n{\n    // these 4 lines can be precomputed for a given shape\n    float an = M_PI / float(n);\n    vec2  acs = vec2(cos(an),sin(an));\n\n    p = rotate2d(an) * p;\n\n    // reduce to first sector\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    // line sdf\n    p -= r*acs;\n    p.y += clamp( -p.y, 0.0, r*acs.y);\n    return length(p)*sign(p.x);\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length(p)-r;\n}\n\nfloat sRad(float an)\n{\n    an = an - floor(an / M_2_PI) * M_2_PI;\n    an = an  < 0.0 ? an + M_2_PI : an;\n    an = an  > M_2_PI ? an - M_2_PI : an;\n    \n    return an;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float as = 4.0 / iResolution.y; //For anti-aliasing\n\n    float wi = 0.001;\n    float wi2 = 0.025;\n    vec4 backColorOutSide = vec4(0.0);\n    vec4 backColorInSide = vec4(0.4,0.0,0.0,1.0*abs(sin(iTime)));\n    vec4 color1 = vec4(0.96,0.196,0.196,1.0);\n    vec4 color2 = vec4(1.0);\n    int angelNum = 4;\n    float angle1 = radians(45.0);\n    float angle2 = (M_2_PI - angle1 * float(angelNum)) / float(angelNum);\n\n    // animate\n    int   n = int(3.0 + mod(floor(iTime*1.5),18.0));\n    bool circle = n == 20;\n    bool ifSameDirection = false;\n    \n    \n    float startAngle = iTime * 2.0;\n    \n    /*****   2D SDF calculation *****/\n    float d1, d2;\n\n    d1 = circle ? sdCircle(p, 0.7) : sdRegularPolygon(p, 0.7, n);\n    d2 = circle ? sdCircle(p, 0.5) :  sdRegularPolygon(p, 0.5, n);\n    \n    float uva = sRad(atan(p.x, p.y));\n    uva = sRad(uva - startAngle);\n    \n    float w = wi;\n    float s = uva - floor(uva / (angle1 + angle2))*(angle1 + angle2);\n\n    if(abs(d1) - wi2 < as && s < angle1)\n    {\n         w = wi2;\n    }\n\n    if(!ifSameDirection)\n    {\n        uva = sRad(uva + 2.0*startAngle);\n        s = uva - floor(uva / (angle1 + angle2))*(angle1 + angle2);\n    }\n\n    if(abs(d2) - wi2 < as && s > angle1)\n    {\n         w = wi2;\n\n    }\n    \n    vec4 lineColor = abs(d1) - w < abs(d2) - w ? color1 : color2;\n\n    vec4 backColor = d2 < 0.0 ? backColorInSide : backColorOutSide;\n    \n    float smoothD = smoothstep(as, 0.00, min(abs(d1) - w, abs(d2) - w));\n    // colorize\n    vec4 col = mix(backColor, lineColor, smoothD);\n    \n    col = mix(vec4(0.0), col, col.a);\n    \n\tfragColor = col;\n    \n}\n","name":"Image","description":"","type":"image"}]}