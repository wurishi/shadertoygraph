{"ver":"0.1","info":{"id":"sdKyWD","date":"1654905165","viewed":395,"name":"starborn","username":"Carandiru","description":"combined gravity waves with galaxy spiral, gives birth to a star.\nreference:\nhttps://www.shadertoy.com/view/NsVyzm by AmirK (Gravity Waves)\nhttps://www.shadertoy.com/view/sdVyDW by metalfinger (FrogTry)","likes":16,"published":3,"flags":0,"usePreview":0,"tags":["galaxy"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// combined gravity waves with galaxy spiral, gives birth to a star.\n// reference:\n// https://www.shadertoy.com/view/NsVyzm by AmirK (Gravity Waves)\n// https://www.shadertoy.com/view/sdVyDW by metalfinger (FrogTry)\n\n\n// Created by sebastien durand - 08/2016\n//-------------------------------------------------------------------------------------\n// Based on \"Dusty nebula 4\" by Duke (https://www.shadertoy.com/view/MsVXWW) \n// Sliders from IcePrimitives by Bers (https://www.shadertoy.com/view/MscXzn)\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//-------------------------------------------------------------------------------------\n\n\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n#define PI 3.14159265359\n#define pi PI\n\nconst float radius=0.15;\nconst float M=1.;\nconst float c=1.;\nconst float freq=2.;\nconst vec3 p10=radius*vec3(1,0,1);\nconst vec3 p20=radius*vec3(-1,0,-1);\nconst int iterations=20; //try 15 iterations for cool clitch :)\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\nvec3 getPos(vec3 p0, float time){\n    return rotateY(freq*time)*p0;\n    //return p0;\n}\n\nvec3 force3( vec3 uv, vec3 p){\n    vec3 separation=uv-p;\n    float dist=length(separation);\n    vec3 v = freq*rotateY(PI*.5)*rotateX(PI*.5)*p;\n    vec3 a = -freq*freq*p;\n    float scl=0.1;\n    \n    return scl*4.*M*dot(a,separation)/(c*c*c*dist*dist)*v; // +1./(c*c*dist)*a);\n}\n\nvec3 retardedPos(vec3 uv, vec3 p0, float time){\n    float upper =time;\n    float lower =0.;\n    float tr = time*.5;\n    int n=0;\n    vec3 retardedP=getPos(p0, tr);\n    while(n<iterations){\n        retardedP=getPos(p0, tr);\n        float dist= length(uv-retardedP);\n        if(dist/c>(time-tr)){\n            upper = tr;\n            tr=(upper+lower)*.5;\n        }else{\n            lower= tr;\n            tr=(upper +lower)*.5;\n        }if(tr<.01){\n           tr=0.;\n           break;\n        }\n        retardedP=getPos(p0, tr);\n        n++;\n    }\n    \n    return retardedP;\n}\n\nconst vec4 \n    colCenter = vec4(1.2, 1.5,1.5,.25),\n\tcolEdge = vec4(.1,.1,.2,.5),\n\tcolEdge2 = vec4(.7,.54,.3,.23),\n    colEdge3 = vec4(.6,1.,1.3,.25);\n\nconst float time = 10.;\n\nvec2 dfGalaxy(in vec3 p, in float thickness, in float blurAmout, in float blurStyle) {\n\t//return min2(spiralArm(p,                  thickness, blurAmout, blurStyle),\n    //\t\t\tspiralArm(vec3(p.z,p.y,-p.x), thickness, blurAmout, blurStyle));  \n                \n    float t = iTime*0.5f;\n        \n    vec3 p1=getPos(p10, t);\n    vec3 p2=getPos(p20, t);\n    vec3 retardedP1=retardedPos(p, p1, t);\n    vec3 retardedP2=retardedPos(p, p2, t);\n    \n    vec3 dir = force3(p1, retardedP1)+force3(p2, retardedP2);\n\n    return vec2(length(dir) * (1.618f) * 7.0f);\n}\n\nvec2 map(in vec3 p) {\n\t//R(p.xz, iMouse.x*.008*pi);\n\n    p.x += iTime * 0.01f;\n    \n    return dfGalaxy(p, 10.0f, 0.5f, 0.5f);\n}\n\n//--------------------------------------------------------------\n\n// assign color to the media\nvec4 computeColor(in vec3 p, in float density, in float radius, in float id) {\n\t// color based on density alone, gives impression of occlusion within\n\t// the media\n\tvec4 result = mix( vec4(1.,.9,.8,1.), vec4(.4,.15,.1,1.), density );\n\t// color added to the media\n\tresult *= mix( colCenter,\n                  mix(colEdge2, \n                      mix(colEdge, colEdge3, step(.08,id)), step(-.05,id)),\n                  smoothstep(.1,.8,radius) );\n\treturn result;\n}\n\n// - Ray / Shapes Intersection -----------------------\nbool sBox( in vec3 ro, in vec3 rd, in vec3 rad, out float tN, out float tF)  {\n    vec3 m = 1./rd, n = m*ro,\n    \tk = abs(m)*rad,\n        t1 = -n - k, t2 = -n + k;\n\ttN = max( max( t1.x, t1.y ), t1.z );\n\ttF = min( min( t2.x, t2.y ), t2.z );\n\treturn !(tN > tF || tF < 0.);\n}\n\nbool sSphere(in vec3 ro, in vec3 rd, in float r, out float tN, out float tF) {\n\tfloat b = dot(rd, ro), d = b*b - dot(ro, ro) + r;\n\tif (d < 0.) return false;\n\ttN = -b - sqrt(d);\n\ttF = -tN-b-b;\n\treturn tF > 0.;\n}\n\n// ---------------------------------------------------\n// Based on \"Dusty nebula 4\" by Duke (https://www.shadertoy.com/view/MsVXWW) \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {  \n\n    float bn = (textureLod(iChannel1, fragCoord.xy/1024.0f, 0.0f).r * 0.5f + 0.5f) * 17.0f/255.0f;;\n    \n   // camera\t   \n    float a = pi;\n    vec3 ro = vec3(0., (1.0f + bn) * cos(a), -sin(a)),\n         ta = vec3(0);\n\n    // camera tx\n    vec3 cw = normalize( ta-ro ),\n     \t cp = vec3( 0., 1., 0. ),\n     \t cu = normalize( cross(cw,cp) ),\n     \t cv = normalize( cross(cu,cw) );\n    vec2 q = (fragCoord.xy)/iResolution.xy,\n     \t p = -1.+2.*q;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 rd = normalize( p.x*cu + p.y*cv + cw );\n          \n\t// ld, td: local, total density \n\t// w: weighting factor\n\tfloat ld=0., td=0., w=0.;\n\n\t// t: length of the ray\n\t// d: distance function\n\tfloat d=1., t=0.;\n    \n    float h = bn;\n   \n\tvec4 sum = vec4(0);\n   \n    float min_dist=0.,  max_dist=0.,\n          min_dist2=0., max_dist2=0.;\n    \n    if(sSphere(ro, rd, 4., min_dist, max_dist)) {\n        if (sBox(ro, rd, vec3(4.,1.0,4.), min_dist2, max_dist2)) {\n        \tmin_dist = max(.1,max(min_dist, min_dist2));\n            max_dist = min(max_dist, max_dist2);\n            \n            t = step(t,min_dist) + min_dist*(t);\n\t\t\t            \n            // raymarch loop\n            vec4 col;        \n            for (int i=0; i<100; i++) {\t \n                vec3 pos = ro + t*rd;\n\n                // Loop break conditions.\n                if(td > .9 || sum.a > .99 || t > max_dist) break;\n\n                // evaluate distance function\n                vec2 res = map(pos);\n                d = max(res.x,.01); \n\t\t\t\t\n                // point light calculations\n                vec3 ldst = pos;\n                ldst.y*=1.6;\n                vec3 ldst2 = pos;\n                ldst2.y*=3.6;\n                float lDist = max(length(ldst),.1), //max(length(ldst), 0.001);\n\t\t\t\t      lDist2 = max(length(ldst2),.1);\n                // star in center\n                vec3 lightColor = (1.-smoothstep(3.,4.5,lDist*lDist))*\n                    mix(.015*vec3(1.,.5,.25)/(lDist*lDist),\n                        .02*vec3(.5,.7,1.)/(lDist2*lDist2), \n                        smoothstep(.1,2.,lDist*lDist));\n                sum.rgb += lightColor; //.015*lightColor/(lDist*lDist); // star itself and bloom around the light\n                sum.a += .003/(lDist*lDist);;\n\n                if (d<h) {\n                    // compute local density \n                    ld = h - d;\n                    // compute weighting factor \n                    w = (1. - td) * ld;\n                    // accumulate density\n                    td += w + 1./60.;\n                    // get color of object (with transparencies)\n                    col = computeColor(pos, td,lDist*2., res.y);\n                    col.a *= td;\n                    // colour by alpha\n                    col.rgb *= col.a;\n                    // alpha blend in contribution\n                    sum += col*(1.0 - sum.a);  \n                }\n  \n                //float pitch = t/iResolution.x;\n                //float dt = max(d * 0.25, .005); //pitch);\n                // trying to optimize step size near the camera and near the light source\n                t += max(d * .15 * max(min(length(ldst), length(ro)),1.0), 0.005);\n                td += .1/70.;\n                //t += dt;\n            }\n            // simple scattering\n            sum *= 1. / exp( ld * .2 )*.8 ;  \n            sum = clamp( sum, 0., 1. );\n    \t}\n    }\n        \n\t// Background color\n    //sum.rgb += vec3(clamp(2.*cos(.5*iTime),0.,.4))*(1. - sum.a)*pow(16.0*q.x*q.y*(1.-q.x)*(1.-q.y),.3);  \n \n    //Apply slider overlay\n    fragColor = vec4(sum.rgb, 1.);\n\n}","name":"Image","description":"","type":"image"}]}