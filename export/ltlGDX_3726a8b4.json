{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S.Guillitte \n\n\n\n#define time -iTime\nfloat dh = 0.;\n\n                                 \nmat2 m2 = mat2(0.8,  0.6, -0.6,  0.8);\n\nfloat noise(in vec2 p){\n\n    float res=0.;\n    float f=1.;\n\tfor( int i=0; i< 3; i++ ) \n\t{\t\t\n        p=m2*p*f+.6;     \n        f*=1.2;\n        res+=sin(p.x+sin(2.*p.y));\n\t}        \t\n\treturn res/3.;\n}\n\n\nfloat fbmabs( vec2 p ) {\n\tp *=.5;\n\tfloat f=1.;   \n\tfloat r = 0.0;\t\n    for(int i = 0;i<8;i++){\t\n\t\tr += abs(noise( p*f ))/f;       \n\t    f *=2.;\n        p-=vec2(-.01,.04)*r;\n\t}\n\treturn r;\n}\n\nfloat sea( vec2 p ) \n{\n\tfloat f=1.;   \n\tfloat r = 0.0;\t\n    for(int i = 0;i<8;i++){\t\n\t\tr += (1.-abs(noise( p*f +.9*time)))/f;       \n\t    f *=2.;\n        p-=vec2(-.01,.04)*r;\n\t}\n\treturn r/4.+.5;\n}\n\n\n\nfloat rocks(vec2 p){\n   \n    return 1.5*fbmabs(p);   \n}\n\nfloat map( vec3 p)\n{\n\tfloat d1 =p.y-.1*p.z+.2-.4*fbmabs(p.xz);\n    float d2 =p.y-.4*sea(p.xz);\n    dh = d2-d1;\n    float d = min(d1,d2);\n\treturn d;\t\n       \t\n}\n\nvec3 normalRocks(in vec2 p)\n{\n\tconst vec2 e = vec2(0.004, 0.0);\n\treturn normalize(vec3(\n\t\trocks(p + e.xy) - rocks(p - e.xy),\n        .05,//.008,\n\t\trocks(p + e.yx) - rocks(p - e.yx)\n\t\t));\n}\n\nvec3 normalSea(in vec2 p)\n{\n\tconst vec2 e = vec2(0.002, 0.0);\n\treturn normalize(vec3(\n\t\tsea(p + e.xy) - sea(p - e.xy),\n        .004,\n\t\tsea(p + e.yx) - sea(p - e.yx)\n\t\t));\n}\n\nvec3 sky(in vec2 p)\n{\t\n\treturn sin(vec3(1.7,1.5,1)+1. + .45*fbmabs(p*4.+.02*time));\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 30.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 128; i++)\n    {\n        if(h < precis*t || t > maxd) break;\n\t    h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\nvec3 transform(in vec3 p)\n{\n    \n    p.zx = p.xz;\n    p.z=-p.z;\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = vec3(0.);\n   \tvec3 rd = normalize(vec3(p, -2.));\n\tvec3 ro = vec3(0.0, 2.0, -2.+.2*time);\n    vec3 li = normalize(vec3(-2., 2., -4.));\n    ro = transform(ro);\n\trd = transform(rd);\n    \n    \n    \n    float t = march(ro, rd);\n    if(t > -0.001)\n    {\n        if(dh<0.)t-=dh;\n        vec3 pos = ro + t * rd;\n        \n        float k=rocks(pos.xz);\n        \n        vec3 nor = normalRocks(pos.xz);\n        float r = max(dot(nor, li),0.05)/2.;\n        if(dh<0.&&dh>-.1)r+=.5*exp(20.*dh);\n        \n        vec3 col1 =vec3(r*k*k, r*k, r*.8);\n        if(dh<0.05){\n        \tvec3 nor = normalSea(pos.xz);\n        \tnor = reflect(rd, nor);\n        \tcol1 += pow(max(dot(li, nor), 0.0), 5.0)*vec3(.8);\n        \tcol1 +=.2* sky(nor.yz);\n        }\n\t    col = .1+col1;\n        \n\t}\n    else //sky\n        col = sky(rd.xz*(rd.y+.2));\n    \n   \tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ltlGDX","date":"1425860036","viewed":548,"name":"Rocky coast","username":"guil","description":"A rocky coast, summertime.\nIn fact, a sum of sine wave.","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["3d","sea","rocks"],"hasliked":0,"parentid":"","parentname":""}}