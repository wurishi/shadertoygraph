{"ver":"0.1","info":{"id":"MlVXWD","date":"1484492616","viewed":1942,"name":"Chroma Key","username":"tudordot","description":"Chroma Key implementation that removes a given key color.\nUsing a user-defined range, the algorithm either removes or blends pixels in the foreground input","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["chroma","greenscreen","chromakey","removel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nchroma key algorithm used to remove the greens screen\nthis technique is nice as you can choose a color removal range.\nusing this range, the algorithm will either remove the given color\nor blend it with background\n\nbecause of this, difficult parts (ie. the sword) can either have a\ngreen-ish look or are a bit transparent (hard to catch with a lot of movement)\n*/\n//conversion between rgb and YUV\nmat4 RGBtoYUV = mat4(0.257,  0.439, -0.148, 0.0,\n                     0.504, -0.368, -0.291, 0.0,\n                     0.098, -0.071,  0.439, 0.0,\n                     0.0625, 0.500,  0.500, 1.0 );\n\n//color to be removed\nvec4 chromaKey = vec4(0.05, 0.63, 0.14, 1);\n\n//range is used to decide the amount of color to be used from either foreground or background\n//if the current distance from pixel color to chromaKey is smaller then maskRange.x we use background,\n//if the current distance from pixel color to chromaKey is bigger then maskRange.y we use foreground,\n//else, we blend them\n//playing with this variable will decide how much the foreground and background blend together\nvec2 maskRange = vec2(0.005, 0.26);\n\n//compute color distance in the UV (CbCr, PbPr) plane\nfloat colorclose(vec3 yuv, vec3 keyYuv, vec2 tol)\n{\n    float tmp = sqrt(pow(keyYuv.g - yuv.g, 2.0) + pow(keyYuv.b - yuv.b, 2.0));\n    if (tmp < tol.x)\n      return 0.0;\n   \telse if (tmp < tol.y)\n      return (tmp - tol.x)/(tol.y - tol.x);\n   \telse\n      return 1.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 fragPos =  fragCoord.xy / iResolution.xy;\n    vec4 texColor0 = texture(iChannel0, fragPos);\n    vec4 texColor1 = texture(iChannel1, fragPos);\n\n    //convert from RGB to YCvCr/YUV\n\tvec4 keyYUV =  RGBtoYUV * chromaKey;\n    vec4 yuv = RGBtoYUV * texColor0;\n\n    float mask = 1.0 - colorclose(yuv.rgb, keyYUV.rgb, maskRange);\n    fragColor = max(texColor0 - mask * chromaKey, 0.0) + texColor1 * mask;\n}\n","name":"Image","description":"","type":"image"}]}