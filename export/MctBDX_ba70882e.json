{"ver":"0.1","info":{"id":"MctBDX","date":"1733583420","viewed":184,"name":"Magmabulb","username":"BearKirb","description":"I use some simple rounding to convert an sdf to voxels.  Then apply AO \"fog\" and bloom and voila.","likes":16,"published":1,"flags":32,"usePreview":1,"tags":["raymarch","sdf","voxel","magma"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Manual bloom lol.  (For fine tuning purposes)\n    vec2 uv = (fragCoord)/iResolution.xy;\n  fragColor.rgb=vec3(0.0);\n  fragColor.rgb+=texture(iChannel0,(uv-0.5)+0.5,0.0).rgb;\n  fragColor.rgb+=texture(iChannel0,(uv-0.5)+0.5,1.0).rgb;\n  fragColor.rgb+=texture(iChannel0,uv,0.0).rgb;\n  fragColor.rgb+=texture(iChannel0,(uv-0.5)/1.005+0.5,1.0).rgb;\n  fragColor.rgb+=texture(iChannel0,(uv-0.5)/1.01+0.5,2.0).rgb*1.2;\n  fragColor.rgb+=texture(iChannel0,(uv-0.5)/1.015+0.5,3.0).rgb*1.4;\n  fragColor.rgb+=texture(iChannel0,(uv-0.5)/1.02+0.5,4.0).rgb*1.6;\n  fragColor.rgb+=texture(iChannel0,(uv-0.5)/1.025+0.5,5.0).rgb*1.8;\n  fragColor.rgb+=texture(iChannel0,(uv-0.5)/1.03+0.5,6.0).rgb*2.0;\n  fragColor.rgb/=10.0;\n  fragColor.a=1.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//https://iquilezles.org/articles/rmshadows\nfloat cubeSize=160.0;\nfloat Mand(vec3 pos) {\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n    float Bailout=2.0;\n    float Power=8.0;\n    int Iterations = 4;\n\tfor (int i = 0; i < Iterations ; i++) {\n\t\tr = length(z);\n\t\tif (r>Bailout) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\nfloat Sphere(vec3 center, float r, vec3 point){\nreturn length(center-point)-r;\n}\nfloat minMore(float t[2]){\nfloat mind = 10000000.0;\nfor(int i=0;i<t.length();i++){\nmind = min(mind,t[i]);\n}\nreturn mind;\n}\nfloat Plane( vec3 p, vec3 n, float h )\n{\n  n = normalize(n);\n  return dot(p,n) + h;\n}\nfloat Scene( vec3 pos )\n{\n  //  pos=round(pos*cubeSize)/cubeSize;\n    float f3 = Mand(pos);\n\n    return f3;\n}\nfloat Scene2( vec3 pos )\n{\n    pos=round(pos*cubeSize)/cubeSize;\n    float f3 = Mand(pos);\n\n    return f3;\n}\nvoid Rotate( inout vec3 vector, vec2 angle )\n{\n\tvector.yz = cos(angle.y)*vector.yz\n\t\t\t\t+sin(angle.y)*vec2(-1,1)*vector.zy;\n\tvector.xz = cos(angle.x)*vector.xz\n\t\t\t\t+sin(angle.x)*vec2(-1,1)*vector.zx;\n}\nfloat shadow( in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n  vec3 po=rd;\n  int breaki=0;\n  float minDist=10000.0;\n    for( int i=0; i<124; i++ )\n    {\n  \n        po -= normalize(rd-ro) * Scene(po);\n      \n    if( Scene(po)<0.001){\n        if(distance(po,ro)<0.01){\n            return 1.0;\n            }else{\n            return 0.0;\n            }\n            }\n      \n      \n    }\n        \n    return 1.0;\n}\n\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(22.987, 87.293))) *\n        43758.5453123);\n}\nvec3 calcNormal( in vec3 pos )\n{\npos=round(pos*cubeSize)/cubeSize;\n    vec2 e = vec2(1.0,-1.0)*0.01;\n    vec3 n = normalize( e.xyy*Scene2( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*Scene2( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*Scene2( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*Scene2( pos + e.xxx ) );\n\n return sign(round(n*2.0)/2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 8.0*(fragCoord-iResolution.xy*0.5)/-iResolution.x;\n vec3 ray = normalize( vec3(\n\t\t\t\t(fragCoord-iResolution.xy*.5)/iResolution.x, \n\t\t\t\t1 ) ); \n                vec3 mid=vec3(0.0,0.0,1.0);\n    vec3 pos = vec3(-0.0,0,-1.1-(-cos(iTime/7.0)*0.5+0.5)*2.3); \n    \n  \n vec3 cameraPos = pos; \n \n    vec2 angle = vec2(iTime,.3);\nangle = -vec2(-0.145,-0.12)*3.14+vec2(3.14,0.0);\n\tRotate(pos,angle);\n Rotate(mid,angle);\n\tRotate(ray,angle);\n    Rotate(cameraPos,angle);\n   \n    float minDist=100.0;\n    vec3 ao=vec3(0.0);\n   \n    for ( int i=0; i < 160; i++ )\n    {\n    \n        float h = Scene2(pos);\n    \n        if ( h < 0.001||length(cameraPos-pos)>3.5)\n        {\n          \n            break;\n        }\n           if(mod(float(i),2.0)<0.5){\n        float dn=texture(iChannel1,pos*4.0+vec3(iTime/15.0)*(sin(pos*6.0+iTime/5.0)*0.2+0.8)).r;\n       \n       Rotate(ray,(vec2(sin(dn*2.0),cos(dn*2.0))/(10.0))*mix(0.0,1.0,float(i)/160.0));\n       \n   ao+=dn*pow(texture(iChannel0,(vec2(sin(pos.y/1.0),sin(pos.x*1.0)+sin(pos.z/1.0))+iTime/300.0)*2.0).rgb*1.2,vec3(2.0))*3.5;\n   }\n        pos += ray*(h)*0.4;\n        \n    }\n    if(Scene2(pos)<0.0011){\n vec3 pre=pos;\n  pos=round(pos*cubeSize)/cubeSize;\n      vec3 lightSource = vec3(10.0*cos(iTime),10.0,10.0*sin(iTime));\n    fragColor.rgb = vec3(0.0,0.0,0.0);\n  \n     \n        vec3 normal;\n      vec3 normal2;\n  \n        normal = calcNormal(pos);\nnormal=normalize(normal);\n\n\n\t\tfloat light = (max(max(.0,dot(normal,-normalize(cameraPos-pos))),dot(normal,normalize(cameraPos-pos))));\n    \n        vec3 ballColor= vec3(0.1,0.1,0.1);\n       \n        vec3 lightCol = vec3(0.4,0.4,0.4);\n        vec3 ambient = pow(texture(iChannel0,vec2(sin(-normal.x*3.0+pos.y/3.0),sin(normal.y*3.0+pos.x/3.0)+sin(normal.z*3.0+pos.z/3.0))+iTime/300.0).rgb*1.2,vec3(2.0))*3.5;\n      \n        float dist = distance(pos,vec3(0,0,0))*1000.0-1000.0;\n        float dt=clamp((Scene2(pos*1.05)-Scene(pre)),-1.,1.)*19.0;\n          fragColor.rgb +=(light*ambient-dt)/2.0+(ao/55.0); \n\n      //fragColor.rgb=vec3(ao/200.0);\n     \n      }else{\n      fragColor=vec4(0.0,0.0,0.0,1.0);\n      }\n     \n    \n    \n \n //   fragColor.rgb = fragColor.rgb + random(ray.xy)/128.0;\n    // Output to screen\n  \n}","name":"Buffer A","description":"","type":"buffer"}]}