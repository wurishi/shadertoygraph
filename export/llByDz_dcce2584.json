{"ver":"0.1","info":{"id":"llByDz","date":"1508249811","viewed":429,"name":"Simple Linear PDE Solver","username":"riouxld","description":"Linear second order partial differential equation solver with control on the boundary condition.\nLeft click to add perturbation. You can change some things in buffer A. I'll add non-homogenous coefficient in\nthe futur.","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["procedural","wave","simulation","diffusion","advection","pde"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Linear second order partial differential equation solver with\n// control on the boundary condition\n// u_t= alpha*lap(u)-dot(v,grad(u))\n// u_tt+beta*u_t= alpha*lap(u)-dot(v,grad(u))\n// You can add perturbation by clicking on the screen\n// You can change some constant in buffer A and remove the wave component (u_tt)\n\n// for testing purpose, https://www.shadertoy.com/view/4dlczB\n\n\n// COLORMAP\nvec3 jet(float t)\n{\n    t =  0.5*(t+1.0);\n    return smoothstep(0.5,0.75,t) * vec3(1,0,0)\n         + (smoothstep(0.0,0.25,t)-(smoothstep(0.75,1.0,t))) * vec3(0,1,0);\n}\n\nvec3 gray(float t)\n{\n    t =  0.5*(t+1.0);\n    return vec3(t);\n}\nvec3 wheel(float t)\n{\n    t =  0.5*(t+1.0);\n    return clamp(abs(fract(t + vec3(1.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) -1.0, 0.0, 1.0);\n}\n\nvec3 hot(float t)\n{\n    t =  0.5*(t+1.0);\n    return vec3(smoothstep(0.00,0.33,t),\n                smoothstep(0.33,0.66,t),\n                smoothstep(0.66,1.00,t));\n}\nvec3 cool(float t)\n{\n    t =  0.5*(t+1.0);\n    return mix( vec3(0.0,1.0,1.0), vec3(1.0,0.0,1.0), t);\n}\n  \nvec3 blackbody(float t)\n{\n\tfloat Temp = 0.5*(t+1.0)*7500.0;\n    vec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    // red is positive, green is negative\n    fragColor = vec4(hot(texture(iChannel0, uv).x),1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Linear second order partial differential equation solver with\n// control on the boundary condition\n\n// unComment #define WAVE to solve damped wave equation\n// u_tt + beta*u_t = alpha*lap(u)\n// unComment #define HEAT to solve heat equation\n// u_t = alpha*lap(u)\n// unComment #define DIFFADV to solve diffuson-advection equation\n// u_t = alpha*lap(u)-dot(v,grad(u))\n// unComment #define ALL to solve a little bit of each\n// u_tt + beta*u_t = alpha*lap(u)-dot(v,grad(u))\n\n// The stability constraint will break with bad coefficient, especially when\n// there's advection. Indeed, foward Euler methods are at most conditionally stable.\n// In fact, it's always unstable for pure advection.\n// Solving implicitly would be better, but quite hard with shaders (doable, at\n// least with an iterative method but not worth it).\n// Also, incompatible boundary condition can break the simulation. \n\n\n#define WAVE\n//#define HEAT\n//#define DIFFADV\n//#define ALL\n\n//macro\n#define GetVelocity(I,J) texelFetch( iChannel0, ij+ivec2(I,J), 0 )\n\nconst float alpha = 40.0; //Diffusivity / Wave propagation speed\nconst float beta = 25.0; //Damping\n#ifdef ALL\nconst float epsilon = 250.0; //Advection, beware\n#else\nconst float epsilon = 15000.0; //Advection, beware\n#endif\nconst vec2 velocity = epsilon*normalize(vec2(1,1)); //Advection direction\nconst float r = 0.35; // Stability constraint\n\nconst float DT = 1.0/10000.0; // Ideal time-step. may vary for CFL condition\n\n\n// Constant height bumb function\nfloat bumbCyl(float p, float rad)\n{\n\treturn 1.0;\n}\n\n// Triangular bumb function\nfloat bumbTri(float p, float rad)\n{\n\treturn 0.5-abs(p/rad);\n}\n\n// Smooth bumb function\nfloat bumbGauss(float p, float rad)\n{\n\treturn exp(-rad/(rad-p*p));\n}\n\n// Smooth bumb function\nfloat init(float p)\n{\n\treturn exp(-p*0.5)*sin(100.0*p);\n}\n\n\n\n\n// Compute Gradient Centered Finite Difference\nvec2 grad(vec2 dX, float u,vec2 up1)\n{\n\treturn (up1-u)/dX;\n}\n// Compute Divergence Centered Finite Difference\nfloat div(vec2 dX, float u,vec2 up1)  \n{\n\treturn dot(up1-u,1.0/dX);\n}\n\n// Compute Laplacian Centered Finite Difference\n// Could have used the 9-point stencil but it would\n// complicate the implementention of the boundary condition.\nfloat lap(vec2 dXPow, float u,vec2 up1, vec2 um1) \n{\n\treturn dot(up1-2.0*u+um1,1.0/dXPow);\n}\n\n// SOLVE WAVE EQUATION u_tt + beta*u_t = alpha*lap(u)\nfloat solveWave(vec2 dXPow, float uold, float u,vec2 up1, vec2 um1) \n{\n\t//CFL Stability condition\n    float dt = min(DT, r*sqrt(min(dXPow.x,dXPow.y)/alpha));\n\t// Compute value of u next step (foward Euler, I know we could do better)\n    float U = 0.0;\n    \n    U += alpha*lap(dXPow, u,up1, um1);\n    U *= dt*dt;\n    \n    U += (2.0+dt*beta)*u-uold;\n    U /= 1.0+dt*beta;\n    return U;\n}\n\n// SOLVE HEAT EQUATION u_t = alpha*lap(u)\nfloat solveHeat(vec2 dXPow, float u, vec2 up1, vec2 um1) \n{\n\t//CFL Stability condition\n    float dt =  min(DT, 0.5*r*min(dXPow.x,dXPow.y)/alpha);\n\t// Compute value of u next step (foward Euler, I know we could do better)\n    float U = 0.0;\n    \n    U += alpha*lap(dXPow, u,up1, um1);\n    U *= dt;\n    \n    U += u;\n    \n    return U;\n}\n\n// SOLVE DIFFUSION ADVECTION EQUATION u_t = alpha*lap(u)-dot(v,grad(u))\nfloat solveDiffAdv(vec2 dX, vec2 dXPow, float u, vec2 up1, vec2 um1) \n{\n\t//CFL Stability condition\n    float dt = min( 0.5*r*min(dXPow.x,dXPow.y)/alpha, 2.0*r*alpha/dot(velocity,velocity));\n    dt = min(DT, dt);\n\t// Compute value of u next step (foward Euler, I know we could do better)\n    float U = 0.0;\n    \n    U -= dot(velocity, grad(dX, u, up1));\n    U += alpha*lap(dXPow, u, up1, um1);\n    U *= dt;\n    U += u;\n\n    return U;\n}\n\n// SOLVE ALL EQUATION u_tt + beta*u_t = alpha*lap(u)-dot(v,grad(u))\nfloat solveAll(vec2 dX, vec2 dXPow, float uold, float u, vec2 up1, vec2 um1) \n{\n\t//CFL Stability condition\n    float dt = min( r*sqrt(min(dXPow.x,dXPow.y)/alpha), 2.0*r*alpha/dot(velocity,velocity));\n    dt = min(DT, dt);\n\t// Compute value of u next step (foward Euler, I know we could do better)\n    float U = 0.0;\n    \n    U -= dot(velocity, grad(dX, u, up1));\n    U += alpha*lap(dXPow, u, up1, um1) ;\n    U *= dt;\n    U *= dt;\n    U += (2.0+dt*beta)*u-uold;\n    U /= 1.0+dt*beta;\n\n    return U;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n\n    // Set intial condition\n    float p =  length((fragCoord.xy - 0.5*iResolution.xy) / iResolution.x);\n    if (iFrame==0) {\n        fragColor = init(p)*vec4(1,1,0,0);\n        //fragColor = vec4(0);\n        return;\n    }\n\n    \n    // add perturbation with mouse, could be done by adding external force\n    float radius = 0.05; // compact support of perturbation\n    p = length((fragCoord.xy - iMouse.xy) / iResolution.x);   \n    if(iMouse.z > 0.0 && p < radius) {\n        fragColor = bumbTri(p, radius)*vec4(1,1,0,0);\n        return;\n    }\n\n    \n    //SOLVE NUMERICALLY\n    ivec2 ij    = ivec2(floor(fragCoord.xy));\n    float dx = 1.0/iResolution.x;\n    float dy = dx;\n    float dxpow = dx*dx;\n    float dypow = dy*dy;\n\n    // To compute finite difference approximaton\n    float uold = GetVelocity(0,0).y; // texture.y value of u last step\n    float u = GetVelocity(0,0).x; // texture.x value of u this step\n    float uip1 = GetVelocity(1,0).x;\n    float uim1 = GetVelocity(-1,0).x;\n    float ujp1 = GetVelocity(0,1).x;\n    float ujm1 = GetVelocity(0,-1).x;\n    \n    //for periodic boundary\n    float uijentry =  GetVelocity(-ij.x,0).x;\n    float uijexit =  GetVelocity(-ij.x+int(iResolution.x)-1,0).x;\n    float uijdown =  GetVelocity(0,-ij.y).x;\n    float uijtop =  GetVelocity(0,-ij.y+int(iResolution.y)-1).x;\n    \n    \n      \n    \n    //Set boundary condition (image method)\n    // For exemple, ib boundary, ui fluid near boundary, uie exterior boundary\n    // Dirichlet u = g(x) on boundary\n    // uie = 2.0*g(ib)-ui\n    // Neumann u = n.grad(h(x)) on boundary\n    // uie = dx*g(ib)+ui\n    // Periodic in comment entry = exit top = bottom\n    if (ij.x <= 0) // Left boundary\n    {\n        uim1 = -u;\n        //uim1 = uijexit;\n    }\n    if (ij.x >= int(iResolution.x)-1)  // Right boundary\n    {\n        uip1 =  -u;\n        //uip1 =  uijentry;\n    }\n    if (ij.y <= 0)  // Down boundary\n    {\n        ujm1 =  -u;\n        //ujm1 =  uijtop;\n    }\n    if (ij.y >=int(iResolution.y)-1) // Up boundary\n    {\n        ujp1 =  -u;\n        //ujp1 =  uijdown;\n    }\n\n    // Compute value of u next step (foward Euler, I know we could do better)\n    vec2 dX = vec2(dx, dy);\n    vec2 dXPow = vec2(dxpow, dypow);\n    vec2 up1 = vec2(uip1, ujp1);\n    vec2 um1 = vec2(uim1, ujm1); \n    \n    float U = 0.0;\n    #ifdef WAVE\n    \tU = solveWave(dXPow, uold, u, up1, um1);\n\t#endif\n    #ifdef HEAT\n    \tU = solveHeat(dXPow, u, up1, um1);\n\t#endif\n    #ifdef DIFFADV\n    \tU = solveDiffAdv(dX, dXPow, u, up1, um1);\n\t#endif\n    #ifdef ALL\n    \tU = solveAll(dX, dXPow, uold, u, up1, um1);\n    #endif\n    // return value of u next step and this step\n    fragColor = vec4(U,u,0,0);\n}","name":"Buf A","description":"","type":"buffer"}]}