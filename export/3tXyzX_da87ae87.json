{"ver":"0.1","info":{"id":"3tXyzX","date":"1592576881","viewed":94,"name":"1st time: Voronoi ","username":"bipinoli","description":"Learning shaders by following awesome tutorials from \"The art of code\" on youtube.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["learningshaders"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 randomNoise(vec2 uv) {\n \tfloat x = fract(sin(uv.x*342. + uv.y*721.)*6742.);\n\tfloat y = fract(cos(uv.x*721. + uv.y*261.)*9211.);\n    return vec2(x,y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord)/iResolution.xy;\n\tuv -= 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    float m = 0.;\n    float minDist = 1000.;\n    \n    if (false) {  \n        // comparing distance with all points\n        // O(n)\n        for (float i=0.; i<50.; i++) {\n            vec2 pt = sin(randomNoise(vec2(i))*iTime);\n            float d = length(pt - uv);\n            m += smoothstep(.01, .005, d);\n            if (d < minDist) {\n                minDist = d;   \n            }\n        }\n    } else {\n        // overlay grid\n        // generate center point in each grid\n        // now comparison can be done only with the neighbouring grid cells\n        // O(1)\n        \n        // 10 by 10 grid\n        uv *= 3.;\n                \n        vec2 currCell = floor(uv);\n        \n        vec2 pointWithinCurrCell = currCell + randomNoise(currCell);\n        float d = length(uv - pointWithinCurrCell);\n        if (d < minDist) {\n         \tminDist = d; \n        }\n        \n        for (float dx = -1.; dx <= 1.; dx++) {\n            for (float dy = -1.; dy <= 1.; dy++) {\n             \t// point in neighbouring grid cell\n                vec2 neighbourOrigin = currCell + vec2(dx, dy);\n                vec2 perct = randomNoise(neighbourOrigin);\n                //vec2 perct = sin(randomNoise(neighbourOrigin)*iTime)/2. + .5;\n                vec2 p = neighbourOrigin + perct;\n\t\t\t\tfloat d = length(p-uv);\n                if (d < minDist) {\n                \tminDist = d;\n                }\n            }\n        }\n    }\n    \n    \n    vec3 col = vec3(minDist);\n    col.r = m;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}