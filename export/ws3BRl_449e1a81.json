{"ver":"0.1","info":{"id":"ws3BRl","date":"1605745104","viewed":80,"name":"ps_MandelBox","username":"p_schneider","description":"This shader targets to achieve a mathematical render of Mandelbrot's Box, a fractal based on the same\nMandelbrots's Formula used to construct the well known Mandelbrot's set","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThis documentation refers to the GitHub Repo: https://github.com/pedrotrschneider/shader-fractals\n\n(PT - Br) Documentação em português começa na linha 8.\n(En) English documentation starts on line 31.\n\n(PT - Br)\nDocumentação em português:\nEste é um shader voltado para a renderização matemática da Caixa de Mandelbrot, um fractal baseado na\nmesma Relação de Mandelbrot utilizada para construir o conhecido Conjunto de Mandelbrot.\n\nPara a construção desse shader foram utilizadas diversas fontes:\nA fonte mais relevante para essa produção foi o trabalho de Inigo Quilez em fórmulas de SDFs e em\ndemonstrações de RayMarching. Todas as outras fontes que serão citadas também o citam como fonte.\n- Inigo Quilez : https://iquilezles.org​\n- Sebastian Lague: https://www.youtube.com/user/Cercopithecan\n- CodeParade: https://www.youtube.com/channel/UCrv269YwJzuZL3dH5PCgxUw\n\nEste shader está sob a licença MIT.\nCheque \"License.txt\" para detalhes sobre a licensa.\n\nInstruções para compilar:\n- Entre no site https://www.shadertoy.com\n- No canto superior direito, clique em \"new\". Você será redirecionado para uma página com uma caixa\nde texto onde voce pode escrever e uma tela.\n- Apague todo o conteúdo da caixa de texto.\n- Copie este código e cole-o diretamente na ciaxa de texto.\n- Se nada mudar, aperte \"alt\" + \"enter\" e o shader deve compilar.\n\n(En)\nEnglish documentation:\nThis shader targets to achieve a mathematical render of Mandelbrot's Box, a fractal based on the same\nMandelbrots's Formula used to construct the well known Mandelbrot's set.\n\nFor the creation of this shader, several resources were used:\nThe most relevant resource is certainly Inigo Quilez's work on SDFs (Signed Distance Fields) and his\nworks on RayMarching. All other resources also cite him as a resource.\n- Inigo Quilez : https://iquilezles.org​\n- Sebastian Lague: https://www.youtube.com/user/Cercopithecan\n- CodeParade: https://www.youtube.com/channel/UCrv269YwJzuZL3dH5PCgxUw\n\nThis shader in under the MIT license.\nRefer to \"LICENSE.txt\" for the details of the license.\n\nInstructions to compile:\n- Follow this url: https://www.shadertoy.com.\n- On the upper right portion of the screen, click on the \"new\" button. You will be redirected to a page\nwith a text box you can write on and a screen.\n- Delete all the text on the text box.\n- Copy this code and paste it on the text box.\n- If nothing happnes, press \"alt\" + \"enter\" and the shader should compile.\n*/\n\n#define MaximumRaySteps 2500\n#define MaximumDistance 200.\n#define MinimumDistance .001\n#define PI 3.141592653589793238\n\n// TRANSFORM FUNCTIONS //\n\nmat2 Rotate (float angle) {\n  float s = sin (angle);\n  float c = cos (angle);\n\n  return mat2 (c, -s, s, c);\n}\n\nvec3 R (vec2 uv, vec3 p, vec3 l, float z) {\n  vec3 f = normalize (l - p),\n    r = normalize (cross (vec3 (0, 1, 0), f)),\n    u = cross (f, r),\n    c = p + f * z,\n    i = c + uv.x * r + uv.y * u,\n    d = normalize (i - p);\n  return d;\n}\n\n// Converts a color from the HSV colorspace to RGB\nvec3 hsv2rgb (vec3 c) {\n  vec4 K = vec4 (1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs (fract (c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix (K.xxx, clamp (p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// SDF FUNCTIONS //\n// SDF sphere\nvec4 sphere (vec4 z) {\n  float r2 = dot (z.xyz, z.xyz);\n  if (r2 < 2.0)\n    z *= (1.0 / r2);\n  else z *= 0.5;\n\n  return z;\n}\n\n// SDF box\nvec3 box (vec3 z) {\n  return clamp (z, -1.0, 1.0) * 2.0 - z;\n}\n\nfloat DE0 (vec3 pos) {\n  vec2 m = iMouse.xy / iResolution.xy;\n  vec3 from = vec3 (0.0);\n  vec3 z = pos - from;\n  float r = dot (pos - from, pos - from) * pow (length (z), 2.0);\n  return (1.0 - smoothstep (0.0, 0.01, r)) * 0.01;\n}\n\nfloat DE2 (vec3 pos) {\n  vec2 m = iMouse.xy / iResolution.xy;\n  // vec3 params = vec3 (0.22, 0.5, 0.5);\n  vec3 params = vec3 (0.5, 0.5, 0.5);\n  vec4 scale = vec4 (-20.0 * 0.272321);\n  vec4 p = vec4 (pos, 1.0), p0 = p;\n  vec4 c = vec4 (params, 0.5) - 0.5; // param = 0..1\n\n  for (float i = 0.0; i < 10.0; i++) {\n    p.xyz = box (p.xyz);\n    p = sphere (p);\n    p = p * scale + c;\n  }\n\n  return length (p.xyz) / p.w;\n}\n\nfloat DE (vec3 pos) {\n\n  float d0 = DE0 (pos);\n  float d2 = DE2 (pos);\n\n  return max (d0, d2);\n}\n\n// Marches the ray in the scene\nvec4 RayMarcher (vec3 ro, vec3 rd) {\n  float steps = 0.0;\n  float totalDistance = 0.0;\n  float minDistToScene = 100.0;\n  vec3 minDistToScenePos = ro;\n  float minDistToOrigin = 100.0;\n  vec3 minDistToOriginPos = ro;\n  vec4 col = vec4 (0.0, 0.0, 0.0, 1.0);\n  vec3 curPos = ro;\n  bool hit = false;\n\n  for (steps = 0.0; steps < float (MaximumRaySteps); steps++) {\n    vec3 p = ro + totalDistance * rd; // Current position of the ray\n    float distance = DE (p); // Distance from the current position to the scene\n    curPos = ro + rd * totalDistance;\n    if (minDistToScene > distance) {\n      minDistToScene = distance;\n      minDistToScenePos = curPos;\n    }\n    if (minDistToOrigin > length (curPos)) {\n      minDistToOrigin = length (curPos);\n      minDistToOriginPos = curPos;\n    }\n    totalDistance += distance; // Increases the total distance armched\n    if (distance < MinimumDistance) {\n      hit = true;\n      break; // If the ray marched more than the max steps or the max distance, breake out\n    }\n    else if (distance > MaximumDistance) {\n      break;\n    }\n  }\n\n  float iterations = float (steps) + log (log (MaximumDistance)) / log (2.0) - log (log (dot (curPos, curPos))) / log (2.0);\n\n  if (hit) {\n    col.rgb = vec3 (0.8 + (length (curPos) / 10.0), 1.0, 0.8);\n    col.rgb = hsv2rgb (col.rgb);\n  }\n\n  col.rgb /= steps * 0.08; // Ambeint occlusion\n  col.rgb /= pow (distance (ro, minDistToScenePos), 2.0);\n  col.rgb *= 20.0;\n\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n  //uv *= 1.5;\n  vec2 m = iMouse.xy / iResolution.xy;\n\n  vec3 ro = vec3 (0, 0, -2.0); // Ray origin\n  ro.yz *= Rotate ((iTime * PI + 1.0) / 20.0); // Rotate thew ray with the mouse rotation\n  ro.xz *= Rotate (iTime * 2.0 * PI / 10.0);\n  vec3 rd = R (uv, ro, vec3 (0, 0, 1), 1.); // Ray direction (based on mouse rotation)\n\n  vec4 col = RayMarcher (ro, rd);\n\n  // Output to screen\n  fragColor = vec4 (col);\n}","name":"Image","description":"","type":"image"}]}