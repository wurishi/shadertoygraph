{"ver":"0.1","info":{"id":"7dSyWh","date":"1643397006","viewed":85,"name":"Grid(y) Perfect Pistons 3","username":"panna_pudi","description":"See [url=https://youtu.be/I8fmkLK1OKg]the tutorial video this is from[/url]","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["domainrepetition","pistons"],"hasliked":0,"parentid":"Wl3fD2","parentname":"Perfect Pistons Example 3"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork, all credits to Blackle Mori\n\n//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//In this example we extend the \"assume-the-worst\" trick to 3 dimensional domain repetition.\n\nfloat box(vec3 p, vec3 d) {\n    p = abs(p) - d;\n    return length(max(p, 0.)) + min(0., max(max(p.x,p.y),p.z));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nfloat hs;\nfloat scene(vec3 p) {\n    p = erot(p, vec3(0, 1, 0), hs * 100.);\n    float box = box(p, vec3(.4, 0.04, 0.04)) - .005;\n    return box;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvec4 traverseGrid3D( vec3 ro, vec3 rd ) {\n    const float GRID_INTERVAL = 1.;\n\n    vec3 grid = floor( ( ro + rd * 1E-2 * GRID_INTERVAL ) / GRID_INTERVAL )\n                       * GRID_INTERVAL + 0.5 * GRID_INTERVAL;\n    \n    vec3 src = ( ro - grid ) / rd;\n    vec3 dst = abs( 0.5 * GRID_INTERVAL / rd );\n    vec3 bv = -src + dst;\n    float b = min(min( bv.x, bv.y ), bv.z);\n    \n    return vec4( grid, b );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0, 0, -2);\n    vec3 rd = normalize(vec3(uv, 1.5));\n    \n    float yrot = .5;\n    float zrot = iTime*.2;\n    if (iMouse.z > 0.) {\n        yrot = clamp(1.-4.*mouse.y,-0.,3.14/2.);\n        zrot = 4.*mouse.x;\n    }\n    \n    rd = erot(rd,vec3(1,0,0),yrot);\n    ro = erot(ro,vec3(1,0,0),yrot);\n    rd = erot(rd,vec3(0,1,0),zrot);\n    ro = erot(ro,vec3(0,1,0),zrot);\n\n    float rl = 0.0;\n    vec3 rp = ro + rd * rl;\n    float dist;\n    vec3 gridCenter;\n    float lenToNextGrid = 0.0;\n    vec3 normalizeRd = normalize( rd );\n    float gridLenMultiplier = 1.0 / length( rd );\n\n    bool hit = false;\n    for (int i = 0; i < 200 && !hit; i++) {\n        if ( lenToNextGrid <= rl ) {\n            rl = lenToNextGrid;\n            rp = ro + rd * rl;\n\n            vec4 grid = traverseGrid3D( rp, normalizeRd );\n            gridCenter = grid.xyz;\n            // gridCenter.y -= sin(gridCenter.x + gridCenter.z + iTime) * 2.;\n            hs = hash(hash(gridCenter.x, gridCenter.y), gridCenter.z);\n            // rp = erot(rp, vec3(0, 0, 1), hs * 100.);\n            // rd = erot(rd, vec3(0, 0, 1), hs * 100.);\n            \n            lenToNextGrid += grid.w * gridLenMultiplier;\n        }\n        dist = scene(rp - gridCenter);\n        hit = dist*dist < 1e-6;\n        rl += dist;\n        rp += dist*rd;\n        if(distance(rp, ro) > 50.) break;\n    }\n    vec3 n = norm(rp - gridCenter);\n    vec3 r = reflect(rd, n);\n    float col = length(sin(r*2.)*.5+.5)/sqrt(3.);\n    col = col*.1 + pow(col, 6.);\n    fragColor = hit ? vec4(col) : vec4(0.03);\n    fragColor = sqrt(fragColor);\n}\n","name":"Image","description":"","type":"image"}]}