{"ver":"0.1","info":{"id":"stsfWX","date":"1654762100","viewed":386,"name":"Strawberry Milk","username":"fancyzero","description":"Sweet","likes":34,"published":1,"flags":32,"usePreview":0,"tags":["water","glass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Basic sobel filter implementation\n// Jeroen Baert - jeroen.baert@cs.kuleuven.be\n// \n// www.forceflow.be\n\n\n// Use these parameters to fiddle with settings\nfloat step = .5;\n\n\n\nfloat intensity(in vec4 color){\n\treturn sqrt((color.x*color.x)+(color.y*color.y)+(color.z*color.z)+(color.w*color.w)*1.5);\n}\n\n\n\nvec3 sobel(float stepx, float stepy, vec2 center){\n\t// get samples around pixel\n    float tleft = intensity(texture(iChannel0,center + vec2(-stepx,stepy)).xyzw);\n    float left = intensity(texture(iChannel0,center + vec2(-stepx,0)).xyzw);\n    float bleft = intensity(texture(iChannel0,center + vec2(-stepx,-stepy)).xyzw);\n    float top = intensity(texture(iChannel0,center + vec2(0,stepy)).xyzw);\n    float bottom = intensity(texture(iChannel0,center + vec2(0,-stepy)).xyzw);\n    float tright = intensity(texture(iChannel0,center + vec2(stepx,stepy)).xyzw);\n    float right = intensity(texture(iChannel0,center + vec2(stepx,0)).xyzw);\n    float bright = intensity(texture(iChannel0,center + vec2(stepx,-stepy)).xyzw);\n \n\t// Sobel masks (see http://en.wikipedia.org/wiki/Sobel_operator)\n\t//        1 0 -1     -1 -2 -1\n\t//    X = 2 0 -2  Y = 0  0  0\n\t//        1 0 -1      1  2  1\n\t\n\t// You could also use Scharr operator:\n\t//        3 0 -3        3 10   3\n\t//    X = 10 0 -10  Y = 0  0   0\n\t//        3 0 -3        -3 -10 -3\n \n    float x = tleft + 2.0*left + bleft - tright - 2.0*right - bright;\n    float y = -tleft - 2.0*top - tright + bleft + 2.0 * bottom + bright;\n    float color = sqrt((x*x) + (y*y));\n    return vec3(color,color,color);\n }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec4 color = texture(iChannel0, uv.xy);\n    vec4 color2 = texture(iChannel1, uv.xy);\n      fragColor = color2;\n\n    \n\t float sobelValue = clamp(pow(sobel(step/iResolution[0], step/iResolution[1], uv).x,2.),0.,1.);\n     fragColor = vec4(sobelValue);\n     fragColor = mix(color, color- 0.4, sobelValue);\n     \n\n     \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"struct MarchContext\n{\n    bool inside;\n};\n\n\nfloat box(in vec3 ro, in vec3 rd, in vec3 r, out vec3 nn, bool entering)\n{\n    rd += 0.0001 * (1.0 - abs(sign(rd)));\n    vec3 dr = 1.0 / rd;\n    vec3 n = ro * dr;\n    vec3 k = r * abs(dr);\n\n    vec3 pin = -k - n;\n    vec3 pout = k - n;\n    float tin = max(pin.x, max(pin.y, pin.z));\n    float tout = min(pout.x, min(pout.y, pout.z));\n    if (tin > tout)\n        return -1.;\n    if (entering)\n    {\n        nn = -sign(rd) * step(pin.zxy, pin.xyz) * step(pin.yzx, pin.xyz);\n    }\n    else\n    {\n        nn = sign(rd) * step(pout.xyz, pout.zxy) * step(pout.xyz, pout.yzx);\n    }\n    return entering ? tin : tout;\n}\n\nvec3 Refract(const vec3 I, const vec3 N, float ior) \n{ \n    float cosi = clamp(dot(I, N),-1.,1.); \n    float etai = 1.;\n    float etat = ior; \n    vec3 n = N; \n    if (cosi < 0.) \n    {\n        cosi = -cosi; \n    } else \n    {\n        float temp = etai;\n        etai = etat;\n        etat = temp;\n        n= -N; \n    } \n    float eta = etai / etat; \n    float k = 1. - eta * eta * (1. - cosi * cosi); \n    if (k < 0. )\n        return vec3(0.);\n    return eta * I + (eta * cosi - sqrt(k)) * n; \n} \n\nmat3x3 LookAt( vec3 src, vec3 target, vec3 up)\n{\n    vec3 forward = normalize(target-src);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    return mat3x3(right, up, forward);\n}\n\nfloat iSphere(in vec3 ro, in vec3 rd, in vec3 sph, in float rad) {\n \tvec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - rad*rad;\n    float t = b*b - c;\n    if( t > 0.0) \n        t = -b - sqrt(t);\n    else\n    return 99999.;\n    return t;\n\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define ZERO (min(iFrame,0))\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat mapMilkCap(vec3 pos )\n{\n    return sdRoundedCylinder(pos, 0.1,0.01, 0.1);\n}\n\n\nvec3 GetCapNormal(vec3 pos)\n{\nfloat eps = 0.002;\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*mapMilkCap(pos+eps*e);\n    }\n    return normalize(n);\n}\n\n//draw character 草莓\nvec2 sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    float m = h*h*h*0.5;\n    float s = m*k*(1.0/3.0); \n    return (a<b) ? vec2(a-s,m) : vec2(b-s,1.0-m);\n}\n\n\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\nvec2 transform( vec2 p , vec2 offset, float angle)\n{\nangle = angle/180.*3.1415926;\np += offset;\nvec2 rotated= vec2( cos(angle)*p.x -sin(angle)*p.y, sin(angle)*p.x + cos(angle)*p.y);\nreturn rotated;\n}\n\nfloat sdRoundBox( in vec2 p, in vec2 b, in vec4 r ) \n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat chineseCaoMei2(in vec2 p, float k )\n{\n\tp+=vec2(0.5,0);\n   \n\tfloat d = abs(sdRoundBox( p, vec2(0.35,0.25), vec4(0.2,0.,0.,0.) ));\n    d = sminCubic(d,abs(sdRoundBox( p, vec2(0.35,0.25), vec4(0.2,0.0,0.,0.) )),0.25).x;\n\n    \n    d = sminCubic(d,(sdUnevenCapsule(transform(p,vec2(0.5,-0.5),90.), 0.0,0.03,0.8)),k).x;\n        \n    d = sminCubic(d,(sdUnevenCapsule(transform(p,vec2(-0.1,-0.36),0.), 0.0,0.03,0.3)),k).x;\n    d = sminCubic(d,(sdUnevenCapsule(transform(p,vec2(0.3,-0.36),0.), 0.0,0.03,0.3)),k).x;\n  \n    d = sminCubic(d,(sdUnevenCapsule(transform(p,vec2(0.45,0.08),90.), 0.0,0.03,0.5)),k).x;\n    d = sminCubic(d,(sdUnevenCapsule(transform(p,vec2(0.45,-0.08),90.), 0.0,0.03,0.5)),k).x;\n    \n    d = sminCubic(d,(sdUnevenCapsule(transform(p,vec2(0.45,0.45),90.), 0.04,0.04,0.9)),k).x;\n    d = sminCubic(d,(sdUnevenCapsule(transform(p,vec2(0.,0.8),0.), 0.02,0.04,0.5)),k).x;\n    \n    p+=vec2(-2.,0.0);\n\n\td = sminCubic(d,abs(sdRoundBox( p+vec2(0.1,0.2), vec2(0.35,0.25), vec4(0.0,0.2,0.2,0.)  )),0.25).x;\n    d = sminCubic(d,abs(sdRoundBox( p+vec2(0.1,0.2), vec2(0.35,0.25), vec4(0.0,0.2,0.2,0.)  )),0.25).x;\n     d = sminCubic(d,(sdUnevenCapsule(transform(p,vec2(0.5,-0.5),90.), 0.0,0.03,0.8)),k).x;\n    d = sminCubic(d,(sdUnevenCapsule(transform(p,vec2(-0.1,-0.36),0.), 0.0,0.03,0.3)),k).x;\n    d = sminCubic(d,(sdUnevenCapsule(transform(p,vec2(0.3,-0.36),0.), 0.0,0.03,0.3)),k).x;\n    \n    d = sminCubic(d,(sdUnevenCapsule(transform(p,vec2(0.62,-0.1),30.), 0.01,0.04,0.2)),k).x;\n    d = sminCubic(d,(sdUnevenCapsule(transform(p,vec2(0.4,-0.25),90.), 0.02,0.04,0.7)),k).x;\n    \n    d = sminCubic(d,(sdUnevenCapsule(transform(p,vec2(0.7,0.2),90.), 0.02,0.04,1.2)),k).x;\n    \n    d = sminCubic(d,(sdUnevenCapsule(transform(p,vec2(0.2,-.0),150.), 0.01,0.04,0.1)),k).x;\n    d = sminCubic(d,(sdUnevenCapsule(transform(p,vec2(0.1,.3),150.), 0.01,0.04,0.1)),k).x;\n    \n      d = sminCubic(d,(sdUnevenCapsule(transform(p,vec2(-0.1,.7),20.), 0.01,0.04,0.2)),k).x;\n      d = sminCubic(d,(sdUnevenCapsule(transform(p,vec2(0.1,.7),90.), 0.01,0.04,0.2)),k).x;\n\n\n d+= (texture(iChannel2,p*0.28).x-0.5)*0.045;\n\n   \n    float alpha = smoothstep(0.03,0.029,d);\n\n\n\treturn alpha;\n}\nvec4 chineseCaoMei(in vec2 p )\n{\n\n    float a = chineseCaoMei2(p,0.06);\n    float b = chineseCaoMei2(p,0.45);\n    vec3 color = mix(vec3(1.000,0.839,0.839),vec3(0.890,0.208,0.275),a);\n    \n    color+= smoothstep(0.7,0.75,texture( iChannel2,p*1.4).x)*smoothstep(0.2,0.25,texture( iChannel2,p*0.6).x);\n    return vec4(color,b);\n}\n\nfloat milkWave(vec2 uv)\n{\n    float v = 0.;\n    for ( int i=0; i < 10; i++ )\n    {\n        vec4 seed = texelFetch( iChannel0, ivec2(i,0), 0);\n        float freq = float(i)*20.;\n        float amp = float(i)/10.;\n        v+=((sin((uv.x*0.4+seed.z)*seed.x*freq))+1.)/2.*seed.y *0.03;\n    }\n    v = (1.-smoothstep(0.2,.205,uv.y- v))*0.8;\n    return v;\n}\nfloat sampleHeight(vec3 worldPos)\n{\n    float h = 0.3 * (sin(worldPos.x * 2.+ iTime)) * (cos(worldPos.z * 1.- iTime * 1.3));\n    return h - 0.4;\n}\n\nfloat heightDy(vec3 worldPos)\n{\n    float t = iTime;\n    float x = worldPos.x;\n    float y = worldPos.z;\n    return 0.42 * sin(t + 2. * x) * sin(1.3 * t - 2.* y);\n}\n\n\nfloat heightDx(vec3 worldPos)\n{\n    float t = iTime;\n    float x = worldPos.x;\n    float y = worldPos.z;\n    return 0.42 * cos(t + 2.* x) * cos(1.3 * t - 2.0 * y);\n\n}\n\n\n\nconst vec3 absorpCoeff = vec3(2., 0.2, 0.18) * 0.5;\nconst vec3 absorpCoeff2 = vec3(1, 1, 1) * 5.1;\nconst vec3 scatterCoeff = vec3(1, 1, 1) * 0.04;\nconst float density = 1.;\nconst vec3 LIGHT_DIR = normalize(vec3(-1, -2, -1));\nconst vec3 LIGHT_COLOR = vec3(1, 1, 1);\nconst int MAIN_STEPS = 30;\nconst int STEP3 = 150;\nconst float STEP_SIZE = 0.02;\nconst vec3 BOX_BOUNDS = vec3(.8, 1.05, 1.05);\nconst vec3 MILK_BOUNDS = vec3(1., 2., 1.);\n\nfloat length6(vec3 p) { p = p * p * p; p = p * p; return pow(p.x + p.y + p.z, 1.0 / 6.0); }\n\nfloat sdTriPrism(vec3 p, vec2 h)\n{\n    vec3 q = abs(p);\n    return max(q.z - h.y, max(q.x * 0.4 + p.y * 0.5, -p.y) - h.x * 0.5);\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r)\n{\n    b-=vec3(r);\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\n}\n\n\nbool castPlane(vec3 start, vec3 dir, vec3 n, vec3 tangent, vec3 corner00, vec2 uvScale, out float t, out vec2 uv )\n{\n    t = 99999.;\n    float denom = dot(dir, -n );\n    if ( abs(denom) < 0.001 )\n        return false;\n    vec3 cp = ( start -corner00 );\n    t = dot(cp, n)/ denom;\n    if ( t < 0.01 || denom < 0.001)\n    {\n        return false;\n        }\n        \n    vec3 binormal = normalize(cross(n, tangent));\n    vec3 pos = start + dir*t;\n    \n    pos -= corner00;\n    uv.x = dot(pos, tangent);\n    uv.y = dot(pos, binormal);\n    uv *= uvScale;\n    if ( max(uv.y,uv.x) > 1. || min(uv.x, uv.y ) < -0.0 )\n        return false;\n    return true;\n}\nstruct OutputBuffer\n{\n    vec4 color;\n    vec4 light;\n    vec3 n;\n    vec3 pos;\n    \n};\n\nOutputBuffer milkPackage( vec3 rayDir, vec3 n, vec2 uv )\n{\n    OutputBuffer ret;\n    float bar1 = smoothstep(0.21,0.2,uv.y);\n    float bar2 = smoothstep(0.41,0.4,uv.y);\n    float bar3 = smoothstep(0.61,0.6,uv.y);\n    float bar4 = smoothstep(0.81,0.8,uv.y);\n    float bar5 = smoothstep(1.01,1.0,uv.y);\n    \n    vec4 c2 =vec4(1.000,0.180,0.180,0.8);\n    vec4 c1 = vec4(0.996,0.706,0.706,0.8);\n    vec4 c3 = vec4(1,1,1,0.0);\n    vec4 c = mix(c1,mix(c2,mix(c3,mix(c2,c1, bar1),bar2),bar3),bar4);\n    vec3 reflectV = normalize(reflect(rayDir,n));\n    float v = dot( reflectV, normalize(vec3(0.4,0.3,0.8)));\n     \n    float b= smoothstep(0.031,0.032, v)*smoothstep(0.06,0.059, v);\n    b += smoothstep(0.048+0.02,0.049+0.02, v)*smoothstep(0.06+0.02,0.059+0.02, v);\n    b += smoothstep(0.048-0.04,0.049-0.04, v)*smoothstep(0.06-0.04,0.059-0.04, v);\n    //float b= smoothstep(0.2,0.22, v)*smoothstep(0.31,0.3, v);\n    \n\n    ret.color = c;\n    ret.light = vec4(b,b,b,1)*vec4(0.6,0.6,0.6,1.0);\n    ret.n = n;\n    return ret;\n}\n\n\nOutputBuffer milkPackage2( vec3 rayDir, vec3 n, vec2 uv )\n{\n    OutputBuffer ret;\n\n    vec3 reflectV = normalize(reflect(rayDir,n));\n    float v = dot( reflectV, normalize(vec3(0.4,0.3,0.8)));\n    \n    float b= smoothstep(0.031,0.032, v)*smoothstep(0.06,0.059, v);\n    b += smoothstep(0.048+0.02,0.049+0.02, v)*smoothstep(0.06+0.02,0.059+0.02, v);\n    b += smoothstep(0.24,0.245, v)*smoothstep(0.31,0.3, v);\n\n     ret.color = vec4(0);\n     \n     ret.light = vec4(b,b,b,1.);\n     ret.light.xyz += vec3(pow(1.-max(0.,dot(rayDir ,-n)),2.8))*0.4;\n     ret.n = n;\n     \n     if (dot(n, vec3(1.,0.,0.)) > 0.5)\n     {\n         vec4 text  = chineseCaoMei(uv*4.0+vec2(-1.6));\n         vec4 strips = vec4(1,1,1,smoothstep(0.3,0.31,(sin(uv.x*uv.x*3.)+2.)/4.-uv.y));\n         ret.color = mix(text, text, text.a);\n         ret.color.a = max(text.a, strips.a);\n     }\n     \n     \n     //= caomei;//mix(caomei, vec4(1.,1.,1.,milkWave(uv)), caomei.a);\n    return ret;\n}\n\nOutputBuffer marchShell(vec3 start, vec3 dir, out bool hit, out vec3 hitPos, out float hitD)\n{\n    \n\n    float mt = 99999.;\n    float t;\n    vec2 uv2;\n    vec3 wpos = start;\n    bool backhit = castPlane( start, dir, normalize(vec3(-0.8,-1,0)),vec3(0,0,0.5), vec3(0.8,0.0,-1.0), vec2(1.,1./.95),t, uv2 );    \n    float backT = 9999.;\n    if ( backhit)\n    backT = t;\n    \n    bool hit1 = castPlane( start, dir, normalize(vec3(0.8,1,0)),vec3(0,0,0.5), vec3(0.0,0.6,-1.0), vec2(1.,1./.95),t, uv2 );    \n   OutputBuffer ret1 = milkPackage(dir, normalize(vec3(0.8,1,0)),uv2);\n   if ( hit1)\n    mt = min(t,mt);\n    \n    bool hit2 = castPlane( start, dir, normalize(vec3(-.8,1,0)),vec3(0,0,-0.5), vec3(0,0.6,1.0), vec2(1.,1./.95),t, uv2 );    \n    if ( hit2)\n    {\n        ret1 = milkPackage(dir, normalize(vec3(-0.8,1,0)),uv2);\n        mt = min(t,mt);\n    }\n        \n        \n        \n    bool hit3 = castPlane( start, dir, normalize(vec3(1.,0,0)),vec3(0,0,-0.5), vec3(0.75,-2.,1.0), vec2(1.,.5),t, uv2 );    \n    if ( hit3)\n    {\n        ret1 = milkPackage2(dir, normalize(vec3(1.,0,0)),uv2);        \n        mt = min(t,mt);        \n    }\n        \n    bool hit4 = castPlane( start, dir, normalize(vec3(-1.,0,0)),vec3(0,0,0.5), vec3(-0.75,-2.,-1.0), vec2(1.,.5),t, uv2 );    \n    if ( hit4)\n    {\n        ret1 = milkPackage2(dir, normalize(vec3(-1.,0,0)),uv2); \n        mt = min(t,mt);    \n     }   \n        \n        \n    bool hit5 = castPlane( start, dir, normalize(vec3(0.,0,1)),vec3(1,0,0.), vec3(-0.75,-2.,1.0), vec2(1./1.5,0.5),t, uv2 );    \n    if ( hit5)\n    {\n        ret1 = milkPackage2(dir, normalize(vec3(0.,0,1)),uv2); \n        mt = min(t,mt);        \n    }\n    \n    bool hit6 = castPlane( start, dir, normalize(vec3(0,0,-1)),vec3(-1,0,0.), vec3(.75,-2.,-1.0), vec2(1./1.5,0.5),t, uv2 );    \n    if ( hit6)\n    {\n        ret1 = milkPackage2(dir, normalize(vec3(0.,0,-1)),uv2);   \n        mt = min(t,mt);\n    }\n\n    \n     mat3x3 rot = LookAt(vec3(0.,0.,0.), vec3(-1., 1., 0.), vec3(0., 1., 0.));\n   \n   bool hit7 = false;\n     wpos = start;\n    float hitd7;\n    for (int i = 0; i < 30; i++)\n    {\n\n        \n        float d = mapMilkCap(wpos *rot+ vec3(.0, -0.63, .0));\n        hitd7 = distance(start , wpos);\n        if (d <= 0.02 && hitd7 < min(backT,mt))\n        {\n            hit7 = true;\n            vec3 n = GetCapNormal(wpos *rot+ vec3(.0, -0.63, .0));\n            float l = dot(n,normalize(vec3(1,1,0)))+2.;\n            l/=3.;\n            l = floor(l*3.)/3.;\n            ret1.color = vec4(vec3(0.408,0.824,0.851)*l,1.);\n            float l2 = (max(0.,dot(dir ,-n))+2.)/3.;\n            l2 = floor(l2*4.)/4.;\n            ret1.light.xyz += vec3(l2)*1.;\n            \n            break;\n        }\n        wpos += dir * d;\n\n    }\n\n       \n\n        \n    hitD = t;\n    hit = hit1 || hit2 || hit3 || hit4 || hit5 || hit6 || hit7;\n    hitPos = start + dir*t;\n    vec3 l = normalize(cross(dir, vec3(0,1,0)));\n    vec3 h = (l + -dir)/2.;\n    ret1.pos = hitPos;\n    //blinn-phong highlight\n    //float intensity =  pow(max(0.,dot(ret1.n, h)),5.);\n    //intensity = step(0.16,intensity)*0.5;\n    //ret1.light += vec4(intensity);\n    //ret1.light += pow(texture(iChannel1, reflect(dir,ret1.n)),vec4(100.))*0.4;\n    if ( !hit )\n    {\n        ret1.color.a = 0.;\n        ret1.light = vec4(0);\n        }\n    \n    return ret1;\n}\n\nfloat RayLineSegmentDistance(vec3 rP, vec3 rD, vec3 lS, vec3 lE)\n{\n    float bL = length(lE - lS);\n    vec3 bD = (lE - lS) / bL;\n    vec3 tD = lS - rP;\n    float aDb = dot(rD, bD);\n    float aDt = dot(rD, tD);\n    float bDt = dot(bD, tD);\n    float u = (aDt - bDt * aDb) / (1.- aDb * aDb);\n    float v = max(min(u * aDb - bDt, bL), 0.);\n    u = max(min(v * aDb + aDt, 1e6), 0.);\n    return length((rP + rD * u) - (lS + bD * v));\n}\n\nvoid marchFrame(vec3 start, vec3 dir, out bool hit, out vec3 hitPos, out float hitD)\n{\n    hit = false;\n    float w = .75;\n    float h = 0.;\n    float l = 1.;\n    vec3 c1 = vec3(w, h, l);\n    vec3 c2 = vec3(w, h, -l);\n    vec3 c3 = vec3(-w, h, l);\n    vec3 c4 = vec3(-w, h, -l);\n    vec3 c5 = vec3(w, h - 2., l);\n    vec3 c6 = vec3(w, h - 2., -l);\n    vec3 c7 = vec3(-w, h - 2., l);\n    vec3 c8 = vec3(-w, h - 2., -l);\n\n    vec3 c9 = vec3(0., 0.6, -l);\n    vec3 c10 = vec3(0., 0.6, l);\n    \n    vec3 c11 = vec3(0., 0.2, l-0.2);\n    vec3 c12 = vec3(0., 0.2, -l+0.2);\n\n    float d1 = RayLineSegmentDistance(start, dir, c1, c2);\n    float d2 = RayLineSegmentDistance(start, dir, c3, c4);\n    float d3 = RayLineSegmentDistance(start, dir, c1, c3);\n    float d4 = RayLineSegmentDistance(start, dir, c2, c4);\n\n    float d5 = RayLineSegmentDistance(start, dir, c5, c6);\n    float d6 = RayLineSegmentDistance(start, dir, c7, c8);\n    float d7 = RayLineSegmentDistance(start, dir, c5, c7);\n    float d8 = RayLineSegmentDistance(start, dir, c6, c8);\n\n    float d9 = RayLineSegmentDistance(start, dir, c1, c5);\n    float d10 = RayLineSegmentDistance(start, dir, c3, c7);\n    float d11 = RayLineSegmentDistance(start, dir, c2, c6);\n    float d12 = RayLineSegmentDistance(start, dir, c4, c8);\n\n    float d13 = RayLineSegmentDistance(start, dir, c1, c10);\n    float d14 = RayLineSegmentDistance(start, dir, c3, c10);\n    float d15 = RayLineSegmentDistance(start, dir, c2, c9);\n    float d16 = RayLineSegmentDistance(start, dir, c4, c9);\n\n    float d17 = RayLineSegmentDistance(start, dir, c9, c10);\n    \n    float da = min(d17, min(d13, min(d14, min(d5, min(d4, min(d3, min(d1, d2)))))));\n    float db = min(d15, min(d16, min(d12, min(d11, min(d6, min(d7, min(d8, min(d9, d10))))))));\n    float d = min(da, db);\n    \n    \n    d = min(d, RayLineSegmentDistance(start, dir, c1, c11));\n    d = min(d, RayLineSegmentDistance(start, dir, c3, c11));\n    d = min(d, RayLineSegmentDistance(start, dir, c10, c11));\n    \n    d = min(d, RayLineSegmentDistance(start, dir, c2, c12));\n    d = min(d, RayLineSegmentDistance(start, dir, c4, c12));\n    d = min(d, RayLineSegmentDistance(start, dir, c9, c12));\n    \n    if (d < 0.05)\n    {\n        hit = true;\n        hitD = d;\n        return;\n    }\n    return;\n\n}\n\nvoid marchSilhouette(vec3 start, vec3 dir, out bool hit, out vec3 hitPos, out float hitD)\n{\n\n     mat3x3 rot = LookAt(vec3(0.,0.,0.), vec3(-1., 1., 0.), vec3(0., 1., 0.));\n    hit = false;\n    vec3 wpos = start;\n    for (int i = 0; i < 100; i++)\n    {\n        float r = 0.1;\n\n        float d1 = sdRoundBox(wpos + vec3(0, 1., 0), BOX_BOUNDS , r);\n\n        float d2 = sdTriPrism((wpos + vec3(0, -0.225, 0)), vec2(0.80/2., 1.05 ));\n\n        float d3 = sdRoundBox(wpos + vec3(0, -0.7, 0), vec3(0.06,0.2,1.05), 0.05);\n        float d4 = sdRoundBox(wpos + vec3(0, .5, 0), vec3(.8-0.05,0.5,1.) ,0.);\n        \n        float d = min(d4,min(d3,min(d1, d2)));\n        \n        d = min(d, sdRoundedCylinder(wpos *rot+ vec3(.0, -0.6, .0), 0.12,0.011, 0.15));\n        if (d <= 0.02)\n        {\n            hit = true;\n            hitPos = wpos;\n            hitD = d;\n            return;\n\n        }\n        wpos += dir * d;\n\n    }\n    return;\n}\n\nvoid march3(vec3 start, vec3 dir, float maxLen, out bool hit1, out float opticalDepth, out vec3 hitPos1, out bool hitOther, out vec3 color)\n{\n    bool firstHit = false;\n    opticalDepth = 0.;\n    hit1 = false;\n    hitPos1 = vec3(0);\n    const float stepSize = STEP_SIZE;\n\n    float minSphereHit = 999999.;\n    vec3 minSphereCenter ;\n    for (int b = 0; b < 20; b++)\n    {\n        vec4 noise = texelFetch(iChannel1, ivec2(0, b+10), 0);\n        vec4 noise2 = texelFetch(iChannel0, ivec2(b, 11.), 0);\n        vec3 bcenter = noise2.xyz * vec3(1., 1., 1.7) + vec3(-0.4, -2, -0.85);\n        //float rand1 = noise.w;\n        //vec3 bubbleH = vec3(sin(iTime*noise2.z*10.) * 0.2, fract(iTime *mix(0.5,1.0,noise2.w)+ rand1 * 10.) * 2.5, 0.);\n        vec3 bubbleH = vec3(0.,noise.z,0.);\n        float t = iSphere(start, dir, bcenter + bubbleH, mix(0.06, 0.15, noise2.a));\n        if ( t < minSphereHit )\n        {\n            minSphereCenter =bcenter + bubbleH; \n            minSphereHit = t;\n        }\n        for (int c = 0; c < 50; c++)\n        {\n            vec4 subBubble = texelFetch(iChannel1, ivec2(c+1, b+10), 0);\n            vec3 subBubbleH = vec3(0.,subBubble.y,0.);\n            float t = iSphere(start, dir, bcenter + bubbleH, subBubble.x);\n            if ( t < minSphereHit )\n            {\n                minSphereCenter =bcenter + bubbleH; \n                minSphereHit = t;\n            }\n        }\n        \n\n    }\n    for (int i = 0; i < STEP3; i++)\n    {\n\n        vec3 wpos = start + dir * stepSize * float(i);\n        float h = sampleHeight(wpos);\n        float d = sdRoundBox(wpos, vec3(0.65, 2., .95), 0.1);\n\n        if (wpos.y < h - 0.01 && d <= 0.01)\n        {\n            if (!firstHit)\n            {\n                hitPos1 = wpos;\n                firstHit = true;\n                hit1 = true;\n            }\n            opticalDepth += STEP_SIZE;\n\n        }\n\n        if (distance(wpos, start) > minSphereHit && wpos.y < h-0.01)\n        {\n            hitOther = true;\n            vec3 sphereHitPos=start + dir*minSphereHit;\n            float ndv = dot (normalize(sphereHitPos - minSphereCenter), -dir);\n            color = mix(vec3(1.000,0.941,0.941) , vec3(0.), smoothstep(0.4,0.3,ndv)) ;\n            \n            return;\n        }\n\n\n    }\n}\n\nfloat line_segment(in vec3 p, in vec3 a, in vec3 b) {\n\tvec3 ba = b - a;\n\tvec3 pa = p - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\treturn length(pa - h * ba);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 txtUV = uv;\n\n    // vec2 dbgUV = vec2(0.5,0.5);\n    //uv = dbgUV;\n\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n    // mousePos.y=mousePos.y*0.1+0.5;\n\n    //vec3 viewdir = normalize(vec3(0.,0.,-1.));\n    vec3 cam = vec3(4., 4., 4.);\n    float near = 0.1;\n    float fov = 60.0;\n    float aspect = iResolution.y / iResolution.x;\n    float w = 2.* near / sqrt(3.);\n    float h = aspect * w;\n\n    vec3 vlt = vec3(-w / 2., -h / 2., near);\n    vec3 vrb = vec3(w / 2., h / 2., near);\n\n\n    float theta = iTime*0.5;\n    float phi = -1.4;\n\n    vec3 rayDir = vec3(mix(vlt.x, vrb.x, uv.x), mix(vlt.y, vrb.y, uv.y), near);\n    \n    rayDir = normalize(rayDir);\n    cam = vec3(cos(theta) * sin(phi),\n               cos(phi),\n                sin(theta) * sin(phi)) * 7.6;\n    mat3x3 rot = LookAt(cam, vec3(0., -0.8, 0.), vec3(0., 1., 0.));\n    rayDir = rot * rayDir;\n    \n\n    vec3 pos;\n    vec3 n;\n    float traveled;\n    vec3 local;\n    vec3 nnIn;\n    vec3 nnOut;\n    float tin = (box(cam, rayDir, vec3(1.05, 2., 1.05), nnIn, true));\n    float tout = box(cam, rayDir, vec3(1.05, 2., 1.05), nnOut, false);\n\n    vec3 lightDir = LIGHT_DIR;\n\n\n    fragColor.xyz = fract(vec3((cam + rayDir * tin).y));\n\n    \n    vec4 background = mix(vec4(1.000, 0.745, 0.722, 0), vec4(1.000,0.812,0.722,0), floor(mod((sin(uv.x*50.+iTime)*0.1 + uv.y)*4.,2.)*1.));\n\n    background.a = 10.;\n    bool hit;\n    vec3 hitPos;\n    float shellHitD;\n    OutputBuffer package = marchShell(cam, rayDir, hit, hitPos, shellHitD);\n    \n    bool shellHit = hit;\n    marchSilhouette(cam, rayDir, hit, hitPos, shellHitD);\n    if (hit)\n    {\n\n        background.xyz = mix(vec3(0.992,0.945,0.906), background.xyz, (smoothstep(0.02, 0.02, shellHitD)));\n        \n    }\n    \n    vec3 traceStart = cam+rayDir*tin;\n    if ( shellHit )\n    {\n        rayDir = refract( rayDir, package.n, 1.01);\n        //traceStart = package.pos + refract( rayDir, package.n, 1.2)*iMouse.w*0.01;\n    }\n    \n    if (tin < 0. )\n    {\n        fragColor = background;\n    }\n    else\n    {\n\n        float opticalDepth;\n        vec3 hitOtherColor;\n        bool hitOther = false;\n\n\n        march3(traceStart, rayDir, abs(tin - tout), hit, opticalDepth, hitPos, hitOther, hitOtherColor);\n\n\n\n        float absorp = exp(-opticalDepth*1.2);//clamp(0., 1., );\n        vec4 topColor = mix(vec4(1.000,0.380,0.380,0), vec4(1.000,0.000,0.000,1), absorp);\n        vec4 bottomColor = mix(vec4(0.996,0.745,0.745,0), vec4(0.996,0.824,0.824,1), absorp);\n        fragColor = mix(bottomColor, topColor, clamp((hitPos.y+2. )/1.5,0., 1. ));\n        if (hitOther)\n            fragColor.xyz = mix(fragColor.xyz, hitOtherColor, absorp);\n\n\n        if (!hit)\n        {\n            fragColor = background;\n        }\n        float hitD;\n        marchFrame(traceStart, rayDir, hit, hitPos, hitD);\n        if (hit)\n            fragColor.xyz = mix( fragColor.xyz, vec3(0.725, 0.118, 0.129),(smoothstep(0.018, 0.01, hitD)));\n            \n         fragColor = mix(fragColor, package.color, package.color.a);\n         fragColor.xyz += package.light.xyz;\n\n    }\n\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//bubbles positions\n\n  const uint k = 1103515245U;  // GLIB C\n//const uint k = 134775813U;   // Delphi and Turbo Pascal\n//const uint k = 20170906U;    // Today's date (use three days ago's dateif you want a prime)\n//const uint k = 1664525U;     // Numerical Recipes\n\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvec3 p = uvec3(fragCoord, iFrame);\n    vec3 random = hash(p);\n    vec4 current = texelFetch(iChannel0, ivec2(fragCoord),0);\n    vec4 lead = texelFetch(iChannel0, ivec2(0.,fragCoord.y),0);\n    if ( fragCoord.x <1. )\n    {\n        if (current.x <= 0. )\n        {\n            current.x = 0.1;//size\n            current.y = mix(0.5,2.0,random.x);//speed\n            current.z = 0.;\n        }\n        current.z += iTimeDelta*current.y;\n\n        if ( current.z > 2.)\n        {\n            current.x = -1.;\n        }        \n\n        fragColor = current;    \n    }\n    else\n    {\n        if ( lead.z >= 1. )\n        {\n            current.x = 0.1;\n            current.y = lead.z;\n            current.z = iTime;\n            current.w = 1.;\n            \n        }\n        if ( iTime -  current.z  > 0.1 && current.w > 0.)\n        {\n            current.x = 0.;\n            current.y = 1.;\n            current.z = 0.; \n            current.w = 0.;\n        }\n        fragColor = current;\n    }\n    \n    if ( fragCoord.x > 100.) \n    {\n        vec4 h = texelFetch(iChannel0, ivec2(vec2(fragCoord.x-100.,10.)),0);\n        vec2 uv = fragCoord/iResolution.xy;\n        fragColor = vec4(step(0.,h.z-uv.y));\n        }\n    \n    \n}\n","name":"Buffer B","description":"","type":"buffer"}]}