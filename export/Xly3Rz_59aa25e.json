{"ver":"0.1","info":{"id":"Xly3Rz","date":"1472747356","viewed":248,"name":"[SB] Balls","username":"Hadyn","description":"My first ever experiment in ray tracing... Started as a little test to see if I could get perspective projection working on my own, then expanded to include Blinn-Phong-like materials with directional lighting and shadows. Pretty happy with the results!","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \tAuthor: Hadyn Lander (SkybreakerGames.com)\n\n\tThis is my first attempt at a ray tracer!\n\n\tI've tried to build it almost entirely from scratch, based on random bits of \n\ttheory I've been exposed to over the years - with a healthy dose of guesswork \n\tand speculation thrown in for good measure...\n\n\tNoob errors doubtlessly abound, but it's been a great learning experience.\n\n\tThe comments are intended to document my experience more than anything, so\n\tthey're rather informal... and not particularly helpful.\n*/\n\n// I went a little crazy with defines. Probably moreso than would be ideal for this sort of thing.\n\n#define MAXDEPTH 6.\n#define FOGSTART 2.\n#define FOGCOLOR vec3(0.85,0.9,0.9)\n#define AMBIENTCOLOR vec3(0.05,0.1,0.1)\n#define LIGHTWRAP 1.0\n#define SUNDIR vec3(0.5,-1.0,1.0)\n#define SUNCOL vec3(1.0,0.8,0.9)\n#define SHADOWBIAS 0.01\n#define FOV 90.\n#define NUMSPHERES 6\n#define NEARPLANE 0.0001\n#define UP vec3(0.0, 1.0, 0.0)\n\nstruct SphereProperties\n{\n  vec3 position;\n  float radius;\n  vec3 color;\n  vec3 emissive;\n  vec3 spec;\n  float specPow;\n} spheres[NUMSPHERES];\n\n// This is one function I borrowed from elsewhere, because I had absolutely no idea where to start with the math.\n// Original Author: Inigo Quilez https://iquilezles.org/blog/?p=2411\nfloat sphIntersect( vec3 ro, vec3 rd, vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return MAXDEPTH+1.0;\n    h = sqrt( h );\n    // minor modification below, because it makes some other calculations easier.\n    return mix(-b - h, MAXDEPTH+1.0, step(-b - h, 0.0));\n}\n\n\n// I'm not great with matrices - I never got the whole \"there is no spoon\" thing...\n// So I borrowed this useful function from: http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 spec;\n  float specStrength;\n    //pink\n    spheres[0].position = vec3(0,0,0);\n    spheres[0].radius = 0.5;\n    spheres[0].color = vec3(1.0,0.0,0.25);\n    spheres[0].emissive = vec3(0.0,0.0,0.0);\n    spheres[0].spec = vec3(0.0,0.0,0.0);\n    spheres[0].specPow = 48.0;\n    \n    //orange\n    spheres[1].position = vec3(-0.5,0.5,-0.5);\n    spheres[1].radius = 0.15;\n    spheres[1].color = vec3(1.0,0.25,0.0);\n    spheres[1].emissive = vec3(1.0,0.25,0.0);\n    spheres[1].spec = vec3(1.0,1.0,1.0);\n    spheres[1].specPow = 128.0;\n    \n    //purple\n    spheres[2].position = vec3(0.75,0.75,-0.15);\n    spheres[2].radius = 0.35;\n    spheres[2].color = vec3(0.0,0.5,1.0);\n    spheres[2].emissive = vec3(0.35,0.0,0.0);\n    spheres[2].spec = vec3(0.5,0.0,0.0);\n    spheres[2].specPow = 16.0;\n    \n    //green\n    spheres[3].position = vec3(4,-4, 4);\n    spheres[3].radius = 5.0;\n    spheres[3].color = vec3(0.0,1.0,0.0);\n    spheres[3].emissive = vec3(0.35,0.35,0.0);\n    spheres[3].spec = vec3(0.5,0.0,0.0);\n    spheres[3].specPow = 4.0;\n    \n    //cyan\n    spheres[4].position = vec3(0.5,-0.5,0.1);\n    spheres[4].radius = 0.15;\n    spheres[4].color = vec3(0.0,0.75,1.0);\n    spheres[4].emissive = vec3(0.0,0.25,1.0);\n    spheres[4].spec = vec3(0.0,1.0,0.0);\n    spheres[4].specPow = 64.0;\n    \n    //yellow\n    spheres[5].position = vec3(-0.25,-0.25,-1.5);\n    spheres[5].radius = 0.1;\n    spheres[5].color = vec3(1.0,0.75,0.0);\n    spheres[5].emissive = vec3(0.5,0.25,0.0);\n    spheres[5].spec = vec3(0.1,0.1,0.0);\n    spheres[5].specPow = 8.0;\n    \n    \n\tvec2 uv = fragCoord.xy / iResolution.y;\n    uv -= 0.5*vec2(iResolution.x/iResolution.y, 1); // puts 0,0 in the center of the viewport\n    \n    // I'm ashamed to admit how long it took me to realise that a problem I was \n    // having with the camera was because GLSL angles are measured in radians...\n    float camDist = 1.0/tan(radians(FOV*0.5));\n    // (too long)\n    \n    vec2 mouse = vec2(0.0);    \n\tif( iMouse.z>0.0 )\n        mouse = 2.0*iMouse.xy/iResolution.y-vec2(iResolution.x/iResolution.y,1);\n    vec3 camForward = vec3(0, 0, 1);\n    camForward = mat3(rotationMatrix(UP, mouse.x*-radians(90.0))) * camForward;\n\tvec3 camRight = cross(UP, camForward);\n    camForward = mat3(rotationMatrix(camRight, mouse.y*radians(90.0))) * camForward;\n\tvec3 camUp = cross(camForward, camRight);\n    vec3 vectorToPixel = vec3(uv.xy,camDist)*NEARPLANE;\n   \tvectorToPixel = (uv.x*camRight + uv.y*camUp + camDist*camForward)*NEARPLANE;\n    \n    vec3 camPosition = vec3(0,0,-2) + vec3(0,0,0.5)*sin(iTime);// + vec3((iMouse.xy/iResolution.xy-vec2(0.5,0.5))*1.0,0.0);\n    \n    vec4 pixel = vec4(0,0,0,MAXDEPTH);\n    vec3 pixelNormal = camForward;\n    vec3 pixelPosition = camForward;\n    vec3 pixelEmissive = vec3(0,0,0);\n    \n    // Color Pass\n    for(int i = 0; i<NUMSPHERES; i++)\n    {\n        vec3 pixelDir = normalize(vectorToPixel);\n        float intersect = sphIntersect( camPosition+vectorToPixel, pixelDir, vec4(spheres[i].position,spheres[i].radius ));\n        if(intersect < pixel.w)\n        {\n            pixelPosition = camPosition+vectorToPixel+pixelDir*intersect;\n            pixelNormal = normalize(pixelPosition-spheres[i].position);\n            \n            float surfaceDot = clamp( (dot(pixelNormal,-normalize(SUNDIR))+LIGHTWRAP) / (1.0+LIGHTWRAP), 0.0, 1.0 );\n            vec3 surfaceColor = spheres[i].color*surfaceDot*SUNCOL+AMBIENTCOLOR+spheres[i].emissive;\n            pixelEmissive = spheres[i].emissive;\n          //  float specDot = clamp( dot(pixelDir-2.0*dot(pixelDir, -pixelNormal)*-pixelNormal, -normalize(SUNDIR)) , 0.0, 1.0 );\n            float specDot = pow(clamp( dot(normalize(-pixelDir-normalize(SUNDIR)), pixelNormal) , 0.0, 1.0 ), spheres[i].specPow);\n            surfaceColor += specDot*SUNCOL*spheres[i].spec;\n            \n            pixel.rgb = surfaceColor;\t//mix(pixel.rgb, surfaceColor, step(intersect, pixel.w));\n            pixel.w = intersect;\t\t//min(pixel.w, intersect);\n        }\n    }\n    \n    // Shadow Pass\n    if(pixel.w<MAXDEPTH)\n    {\n        vec3 colorMulti = vec3(1,1,1);\n     \tfor(int i = 0; i<NUMSPHERES; i++)\n        {\n            vec3 pixelDir = normalize(vectorToPixel);\n            float intersect = sphIntersect( pixelPosition, -normalize(SUNDIR), vec4(spheres[i].position,spheres[i].radius ));\n            if(intersect < MAXDEPTH)\n            {\n                colorMulti = mix(colorMulti, AMBIENTCOLOR+pixelEmissive, step(SHADOWBIAS,intersect));\n            }\n        }\n        pixel.rgb *= colorMulti;\n    }\n    \n    float fogStrength = clamp((pixel.w-FOGSTART)/(MAXDEPTH-FOGSTART), 0.0, 1.0);\n    fragColor = vec4(pixel.rgb*(1.0-fogStrength) + FOGCOLOR*fogStrength, 1.0);\n}","name":"Image","description":"","type":"image"}]}