{"ver":"0.1","info":{"id":"MlK3R3","date":"1475965730","viewed":1644,"name":"Camera with Depth of Field","username":"pyrite","description":"Simulates a camera from the sensor outwards\nPlay with lines 38->42\nfocalDis controls the distance of focus for the lens\nlenRes controls the square root of the number of points on the lens\nThe virtual lens is trimmed to a circle for bokeh reasons. \n","likes":40,"published":1,"flags":0,"usePreview":0,"tags":["blur","dof","camera","iq","tech","field","depth","new","ssaa","focus","technique","virtual"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float asphere(in vec3 ro, in vec3 rd, in vec3 sp, in float sr){ \n    // geometric solution\n    float sr2 = sr*sr;\n    vec3 e0 = sp - ro; \n    float e1 = dot(e0,rd);\n    float r2 = dot(e0,e0) - e1*e1; \n    if (r2 > sr2) return 1000.0; \n    float e2 = sqrt(sr2 - r2); \n    return e1-e2; \n}\n\n\nfloat map(in vec3 ro, in vec3 rd){ \n    return min(asphere(ro,rd,vec3(0.0,0.0,0.0), 1.5),\n               min(asphere(ro,rd,vec3(-2,0.0,0.0),1.0), \n                   min(asphere(ro,rd,vec3(0.0,-2,0.0),1.0),\n                       min(asphere(ro,rd,vec3(1.15,1.15,1.15),1.0),\n                           min(asphere(ro,rd,vec3(0.0,0.0,-2),1.0),\n                              asphere(ro,rd,vec3(3.,3.,3.),0.2))))));\n}\n\n\nvec3 ascene(in vec3 ro, in vec3 rd){\n    float t = map(ro,rd);\n    vec3 col = vec3(0);\n    if (t==1000.0){col +=0.5;}\n    \n    else {\n        vec3 loc = t*rd+ro;\n        loc = loc*0.5;\n        col =  vec3(clamp(loc.x,0.0,1.0),clamp(loc.y,0.0,1.0),clamp(loc.z,0.0,1.0));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //THIS v\n    const int lensRes = 9; //THIS <\n    const int ssaa = 1; //THIS <\n    float lensDis = 0.75; //THIS <\n    float lensSiz = 2.0; //THIS <\n    float focalDis = 11.0; //THIS <\n    //THIS ^\n    //fragcoord is the center of the pixel\n\tvec2 sensorLoc = fragCoord.xy / iResolution.x; //sets x limits from 0-1 y at same scale, center at (0.5,0.?)\n    sensorLoc = vec2(0.5, 0.5*(iResolution.y/iResolution.x)) - sensorLoc; //reverse sensor and center on (0,0)\n    \n    vec3 Z = vec3(0.0,0.0,1.0); //useful later could be hardcoded later instead\n    float t = 0.5*iTime - 5.0*iMouse.x/iResolution.x; //tau used to determine camera position\n    \n    vec3 cameraPos = 10.0*vec3(1.0*sin(3.0*t),1.0*cos(2.0*t),1.0*cos(3.0*t)); //this is not normalized\n    \n    vec3 cameraDir = -cameraPos; //this will and should be normalized\n    cameraDir = normalize(cameraDir); //normalize\n    \n    vec3 cameraX = cross(cameraDir,Z); //right dir for camera\n    cameraX = normalize(cameraX); //normalize\n    \n    vec3 cameraY = cross(cameraX,cameraDir); //up dir for camera\n    cameraY = normalize(cameraY); //normlize\n\t\n    vec3 colorTotal = vec3(0.0,0.0,0.0);//for each pixel reset the accumulated color\n    float colorCount = 0.0;\n    float lensResF = float(lensRes); //for comparing to float later\n    float focal = 1.0+lensDis/focalDis; //brings the image to focus at focalDis from the cameraPos\n    float ssaaF = float(ssaa); // for using later to save a cast.\n    float sscale = 1.0/(iResolution.x); // size of a pixel\n    float sstep = 1.0/ssaaF;\n    float sstart = sstep/2.0-0.5;\n    float lstep = 1.0/lensResF;\n    float lstart = lstep/2.0-0.5;\n    \n    for (float sx = sstart; sx < 0.5; sx += sstep){ //SSAA x direction\n    \tfor (float sy = sstart; sy < 0.5; sy += sstep){ //SSAA y direction\n            \n        \tvec2 ss = vec2(sx,sy)*sscale; //sub pixel offset for SSAA\n            vec3 sensorRel = cameraX*(sensorLoc.x+ss.x) + cameraY*(sensorLoc.y+ss.y); //position on sensor relative to center of sensor. Used once\n            vec3 sensorPos = cameraPos - lensDis*cameraDir + sensorRel; //3d position of ray1 origin on sensor\n            \t\n            for (float lx = lstart; lx < 0.5; lx+=lstep){\n        \t\tfor (float ly = lstart; ly < 0.5; ly+=lstep){\n                    \n            \t\tvec2 lensCoord = vec2(lx,ly); //fragCoord analog for lens array. lens is square\n        \t\t\tvec2 lensLoc = (lensCoord)*lensSiz; //location on 2d lens plane\n            \t\t\n                    if (length(lensLoc)<(lensSiz/2.0)){ //trim lens to circle\n                        \n                \t\tvec3 lensRel = cameraX*(lensLoc.x) + cameraY*(lensLoc.y); //position on lens relative to lens center. Used twice\n            \t\t\tvec3 lensPos = cameraPos + lensRel; // 3d position of ray1 end and ray2 origin on lens\n            \t\t\tvec3 rayDir1 = lensPos - sensorPos; //direction of ray from sensor to lens\n            \t\t\tvec3 rayDir2 = rayDir1 - focal*(lensRel); //direction of ray afer being focused by lens\n            \t\t\trayDir2 = normalize(rayDir2); //normalize after focus \n            \t\t\tvec3 color = ascene(lensPos,rayDir2); //scene returns a color\n            \t\t\tcolorTotal = colorTotal+color; //sum colors over all  points from lens\n                        colorCount += 1.0; //total number of colors added.\n                    }\n                }\n            }\n        }\n    }\n    \n    fragColor = vec4(colorTotal/colorCount - length(sensorLoc)*0.25,0.0); //slight post-processing\n}","name":"Image","description":"","type":"image"}]}