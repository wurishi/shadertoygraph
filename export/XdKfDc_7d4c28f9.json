{"ver":"0.1","info":{"id":"XdKfDc","date":"1532140811","viewed":544,"name":"Random Noise Dithering","username":"Tynach","description":"Real-time random dithering with adjustable color depth. Click on different places horizontally to choose bit depth. Far left gives 2 colors per channel, far right gives 8 per channel.\n\nCheckerboard pattern shows bit depth boundaries, and shows original.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","random","dither","gamma","lab","dithering","srgb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\nprecision highp int;\n\n#define PI 3.1415926535897932384626433832795\n\n\n/*\n * Structures\n */\n\n// Parameters for transfer characteristics (gamma curves)\nstruct transfer {\n\t// Exponent used to linearize the signal\n\tfloat power;\n\n\t// Offset from 0.0 for the exponential curve\n\tfloat off;\n\n\t// Slope of linear segment near 0\n\tfloat slope;\n\n\t// Values below this are divided by slope during linearization\n\tfloat cutoffToLinear;\n\n\t// Values below this are multiplied by slope during gamma correction\n\tfloat cutoffToGamma;\n};\n\n\n/*\n * Gamma Curve Parameters\n */\n\n// Linear gamma\nconst transfer gam10 = transfer(1.0, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 1.8; used by older Macintosh systems\nconst transfer gam18 = transfer(1.8, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.2; not linear near 0. Was defined abstractly to be used by early\n// NTSC systems, and is what Adobe RGB uses\nconst transfer gam22 = transfer(2.2, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.4; not linear near 0. Seems a popular choice among some people\n// online, so I included it. I don't think any standard uses this\nconst transfer gam24 = transfer(2.4, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.5; not linear near 0. Approximately what old Sony TVs used\nconst transfer gam25 = transfer(2.5, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.8; not linear near 0. Loosely defined gamma for European SDTV\nconst transfer gam28 = transfer(2.8, 0.0, 1.0, 0.0, 0.0);\n\n// Modern SMPTE 170M, as well as Rec. 601, Rec. 709, and a rough approximation\n// for Rec. 2020 content as well. Do not use with Rec. 2020 if you work with\n// high bit depths!\nconst transfer gam170m = transfer(1.0/0.45, 0.099, 4.5, 0.0812, 0.018);\n\n// Gamma for sRGB. Besides being full-range (0-255 values), this is the only\n// difference between sRGB and Rec. 709.\nconst transfer gamSrgb = transfer(2.4, 0.055, 12.92, 0.04045, 0.0031308);\n\n// Gamma for the CIE L*a*b* Lightness scale\nconst transfer gamLab = transfer(3.0, 0.16, 243.89/27.0, 0.08, 216.0/24389.0);\n\n\n/*******************\n *                 *\n *  User Settings  *\n *                 *\n *******************/\n\n// Gamma to use for the output\nconst transfer gamOut = gamSrgb;\n\n// Gamma to use for choosing color distribution\nconst transfer gamDist = gamLab;\n\n// The number of horizontal grid divisions for switching between grayscale and dithered\n// Also sets the max number of colors (per channel) when not using SPECIFIC (see below)\nconst float divs = 7.0;\n\n// Uncomment the next line to specify exactly how many colors to dither between per channel\n//#define SPECIFIC 1\n\n#ifdef SPECIFIC\n// How many total colors to dither between\nconst float colors = 3.0;\n#endif\n\n\n/*\n * Gamma Conversion Functions\n */\n\n// Converts RGB colors to a linear light scale\nvec3 toLinear(vec3 color, transfer trc)\n{\n\tbvec3 cutoff = lessThan(color, vec3(trc.cutoffToLinear));\n\tbvec3 negCutoff = lessThanEqual(color, vec3(-1.0*trc.cutoffToLinear));\n\tvec3 higher = pow((color + trc.off)/(1.0 + trc.off), vec3(trc.power));\n\tvec3 lower = color/trc.slope;\n\tvec3 neg = -1.0*pow((color - trc.off)/(-1.0 - trc.off), vec3(trc.power));\n\n\tcolor = mix(higher, lower, cutoff);\n\tcolor = mix(color, neg, negCutoff);\n\n\treturn color;\n}\n\n// Gamma-corrects RGB colors to be sent to a display\nvec3 toGamma(vec3 color, transfer trc)\n{\n\tbvec3 cutoff = lessThan(color, vec3(trc.cutoffToGamma));\n\tbvec3 negCutoff = lessThanEqual(color, vec3(-1.0*trc.cutoffToGamma));\n\tvec3 higher = (1.0 + trc.off)*pow(color, vec3(1.0/trc.power)) - trc.off;\n\tvec3 lower = color*trc.slope;\n\tvec3 neg = (-1.0 - trc.off)*pow(-1.0*color, vec3(1.0/trc.power)) + trc.off;\n\n\tcolor = mix(higher, lower, cutoff);\n\tcolor = mix(color, neg, negCutoff);\n\n\treturn color;\n}\n\n\n/*\n * Functions for Noise and Dithering\n */\n\n// Based on https://www.shadertoy.com/view/4tXyWN\n/*vec3 hash(vec3 seed)\n{\n\tuvec3 x = uvec3(seed);\n\tuvec3 q = 1103515245U * ( (x>>1U) ^ (x.zyx   ) );\n\tuint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) ^ (q.z<<3U) );\n\treturn vec3(float(n) * (1.0/float(0xffffffffU)));\n}*/\n\n// Based on https://www.shadertoy.com/view/4lXyWN\n/*vec3 hash(vec3 seed)\n{\n\tuvec3 x = uvec3(seed);\n\tx*=1103515245U;\n\tx = ((x>>2u)^(x.yzx>>1u)^x.zxy)*1103515245U;\n\n\treturn vec3(x)*(1.0/float(0xffffffffU));\n}*/\n\n// Interleaved gradient noise\n/*vec3 hash(vec3 seed)\n{\n\tvec2 coord = vec2(dot(vec2(1, 5.588238), seed.xz), dot(vec2(1, 5.588238), seed.yz));\n\treturn vec3(fract(52.9829189*fract(dot(vec2(0.06711056, 0.00583715), coord.xy))));\n}*/\n\n// Just use a texture\nvec3 hash(vec3 seed)\n{\n\tivec2 texRes = textureSize(iChannel1, 0);\n\tivec2 coord = ivec2(seed.xy + seed.z*vec2(157, 103)) % texRes;\n\n\treturn texelFetch(iChannel1, coord, 0).xyz;\n}\n\n// Dither between two colors by 'amount'\nvec3 dither(vec3 color1, vec3 color2, vec3 amount)\n{\n\tvec3 seed = hash(vec3(gl_FragCoord.xy, /*trunc(mod(iTime*60.0, 64.0))*/fract(iTime)*144.0));\n\tbvec3 cmix = bvec3(round(amount + seed - 0.5));\n\n\treturn mix(color1, color2, cmix);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 coord)\n{\n\tvec2 uv = coord/iResolution.xy;\n\tvec2 texRes = vec2(textureSize(iChannel0, 0));\n\tvec2 texUv = coord/texRes*min(texRes.x/iResolution.x, texRes.y/iResolution.y);\n\n\t#ifndef SPECIFIC\n\tfloat colors = floor(iMouse.x*divs/iResolution.x) + 2.0;\n\t#endif\n\n\tvec3 color = texture(iChannel0, texUv).rgb;//toGamma(vec3(0.5), gamOut);\n\n\tcolor = toLinear(color, gamOut);\n\tcolor = toGamma(color, gamDist);\n\n\tvec3 colorLo = floor(color*(colors - 1.0))/(colors - 1.0);\n\tvec3 colorHi = ceil(color*(colors - 1.0))/(colors - 1.0);\n\n\tcolor = toLinear(color, gamDist);\n\tcolorLo = toLinear(colorLo, gamDist);\n\tcolorHi = toLinear(colorHi, gamDist);\n\n\tvec3 fraction = (color - colorLo)/(colorHi - colorLo);\n\tvec3 dithered = dither(colorLo, colorHi, fraction);\n\n\tcolor = toGamma(color, gamOut);\n\tdithered = toGamma(dithered, gamOut);\n\n\tcolor = mix(color, dithered, bvec3((int(coord.x*divs/iResolution.x) + int(coord.y*divs/iResolution.x))%2));\n\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}