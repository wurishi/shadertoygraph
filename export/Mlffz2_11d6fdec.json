{"ver":"0.1","info":{"id":"Mlffz2","date":"1512483913","viewed":217,"name":"Patching Mikkel's Error Graph","username":"TimothyLottes","description":"Patching Mikkel's Error Graph - Work in Progress","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["dithering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// [TL] Work in progress patching Mikkel's error graph with prior GDC technique ...\n\n// [TL] Not hooked up yet fully.\nconst float STEPS = 8.0;\nconst float STEPS_DEC = STEPS - 1.0;\n\n//note: uniform pdf rand [0;1[\nvec2 hash22n(vec2 p)\n{\n\tp  = fract(p * vec2(5.3987, 5.4421));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec2(p.x * p.y * 95.4307, p.y * p.x * 97.5901));\n}\n\nfloat srgb2lin( float v )\n{\n    return v*v;\n}\n\n// [TL] Add inverse approximation for sRGB.\nfloat lin2srgb(float v) { return sqrt(v); }\n\n// [TL] Linear input correctly quantized to nearest non-linear step, returns linear output (designed to be correct, not optimal).\nfloat quant(float v) {\n\tfloat c = clamp(v, 0.0, 1.0);\n    v = lin2srgb(c);\n    float lo = floor(v * STEPS_DEC);\n    float hi = lo + 1.0;\n    lo /= STEPS_DEC;\n    hi /= STEPS_DEC;\n    lo = clamp(lo, 0.0, 1.0);\n    hi = clamp(hi, 0.0, 1.0);\n    lo = srgb2lin(lo);\n    hi = srgb2lin(hi);\n    float diffLo = abs(c-lo);\n    float diffHi = abs(c-hi);\n    if(diffLo < diffHi) return lo;\n    return hi; }\n\n\nfloat dither( float v, vec2 seed )\n{\n    vec2 rnd2 = hash22n(seed);\n    \n    //note: idea from https://gpuopen.com/vdr-follow-up-fine-art-of-film-grain/\n    const float quantizationSteps = STEPS;\n    float grain = (rnd2.x + rnd2.y - 1.0); // [-1;1[ triangular pdf noise\n    \n    #if 0\n\t    // [TL] Switch to different PDF.\n    \tgrain = rnd2.x * 2.0 - 1.0;\n    #endif\n    \n    // [TL] Make sure v is clamped.\n    float color = clamp(v, 0.0, 1.0);\n    \n    // [TL] Adding in corrected logic from VDR post.\n    float grainBlackLimit = 0.5 * srgb2lin(1.0/STEPS_DEC);    \n    float grainAmount = 0.75 * (1.0 - srgb2lin(1.0 - (1.0/STEPS_DEC)));\n    \n    // [TL] Focused on just getting near zero right for now ...\n    return grain * min(color + grainBlackLimit, grainAmount) + color;\n}\n\n\nfloat calc_output_tri( float ci, vec2 seed )\n{\n    ci = dither( ci, seed );\n        \n    return quant(ci);\n}\n\nfloat calc_output( float ci, vec2 seed )\n{\n    return calc_output_tri(ci,seed);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n  \n\t// create input color bands\n    float ci = uv.x * 1.5 - 0.2;\n    \n    // [TL] Turned this back on, even though it kills the <0 and >1 areas.\n    ci = clamp(ci, 0.0, 1.0);\n\n    // [TL] Want perceptual ramp so let 'ci' be non-linear, then convert to linear.\n    ci = srgb2lin(ci);\n    \n    float dx = dFdx( ci );\n    vec3 cx = vec3(ci-dx, ci, ci+dx);\n    \n    float signal = ci;\n     \n    // [TL] Fix for linear/perceptual\n    vec3 signal_quant;\n    signal_quant.x = quant(cx.x);\n    signal_quant.y = quant(cx.y);\n    signal_quant.z = quant(cx.z);\n    \n        \n    float dithersignal = calc_output( ci, fragCoord );\n    \n    float avg = 0.0;\n    const int num_samples = 4096;\n    const float w = (1.0/float(num_samples));\n    for( int i=0;i<num_samples;++i)\n    {\n        vec2 seed = fragCoord + vec2(3.0,7.0)*float(i); //note: fragCoord.xx to be pedantic\n        avg += w*calc_output( ci, seed );\n    }    \n    \n    \n    //==\n    \n \t//note: lines at 0, 1\n    if ( abs(signal-0.0)<0.001 || abs(signal-1.0)<0.001 )\n    {\n        fragColor=vec4(vec3(0.25),1); return;\n    }\n\n    \n    if ( uv.y > 0.8333 )\n    {\n        // [TL] Convert linear to non-linear for display.\n        fragColor = vec4(vec3(lin2srgb(signal)),1); return;\n    }\n    else if ( uv.y > 0.6667 )\n    {\n        // [TL] Convert linear to non-linear for display.\n        fragColor = vec4(vec3(lin2srgb(avg)),1); return;\n        \n    }\n    else if ( uv.y > 0.5 )\n    {\n        // [TL] Convert linear to non-linear for display.\n        fragColor = vec4(vec3(lin2srgb(dithersignal)),1); return;\n    }\n    else\n    {\n        vec2 luv = uv/0.45 - 0.05;\n\t\tfloat cs = step(abs(luv.y-signal), 0.0025);\n        float cq = ((signal_quant.x-luv.y)<0.0025 && (luv.y-signal_quant.z < 0.0025)) ? 1.0 : 0.0; //step(abs(luv.y-signal_quant), vec3(0.005));\n        \n        float cd = step(abs(luv.y-dithersignal), 0.005);\n        float ca = step(abs(luv.y-avg), 0.0025);\n\n        float diff = avg-signal;\n        diff *= 10.0;\n        float err = diff*0.5+0.5;\n        float ce = step(abs(luv.y-err), 0.0025);\n        \n        vec3 c = vec3(0.0);\n        //TODO: grid\n        if( abs(luv.y-0.0)<0.002 || abs(luv.y-1.0)<0.001 || abs(luv.y-0.5)<0.001 )\n            c += 0.25;\n        \n        //pure signal, undithered, unquantized\n        c += vec3(0.5) * cs; \n        \n        //quantized\n        //c += vec3(83.0/255.0,213.0/255.0,1.0) * cq;\n        \n        //average of dithered signal\n        c += vec3(1.0,211.0/255.0,0.0) * ca; \n\n        //note: error\n        c += vec3(1.0,0.0,0.0) * ce;\n        \n        \n        //dithered, quantized signal\n       \t//c += vec3(1,0,0) * cd;                    \n\n        //accumulated dithered, quantized\n        /*\n        {\n            float avgdither=0.0;\n            for(int i=0;i<64;++i)\n            {\n                vec2 seed = fragCoord + vec2(81.0,89.0)*float(i);\n                float s = calc_output( ci, seed );\n                float g = step(abs(luv.y-s), 0.0025);\n                avgdither += (1.0/64.0) * g;\n            }\n            c += avgdither;\n        }\n\t\t*/\n        \n        fragColor = vec4(vec3(c),1); return;\n    }\n    \n\tfragColor = vec4(0);\n}\n","name":"Image","description":"","type":"image"}]}