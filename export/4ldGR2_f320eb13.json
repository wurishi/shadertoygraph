{"ver":"0.1","info":{"id":"4ldGR2","date":"1470318800","viewed":136,"name":"Final circle shader","username":"The_Little_Hat","description":"working shader","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["circle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float radius = 0.15;\nfloat dist = 0.7;\n\n\nbool isEven(float x)\n{\n    if (fract(x  * 0.5) == 0.0)\n        return true;\n    else\n        return false;\n}\nfloat triangleWave(float time)\n{\n    if (isEven(floor(time)))\n    {\n    \treturn fract(time);\n    }\n    else \n    {\n        return fract(1.0-time);\n    }\n}\n\nfloat alpha_function(float time) \n{\n    float calling_function = triangleWave(time);\n    \n    \n    calling_function *= 20.0;\n    \n    \n    calling_function = clamp (calling_function, 0.0, 1.0);\n    return calling_function;\n}\n   \nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvec4 getColourAtPixel(vec2 fragCoord, vec2 fragCoord_offset, float local_time, float square_size, float random_value, float period)\n{\n    vec2 checker = floor(fragCoord.xy/square_size);\n    vec2 anything = fract(fragCoord.xy/square_size);\n\n  \tfloat seed = sin((checker.x*checker.x+12.67) * (checker.y*checker.y+14.32))*random_value;\n    float total = checker.x + checker.y;\n    //float localTime = global_time*(1.0+fract(seed));\n    //localTime += seed;\n    float radius = sin((checker.x*checker.x+1.23*random_value) * (checker.y*checker.y+2.02))*0.05+0.25;\n    float dist = 0.5-radius;\n    \n    float seed_for_position = seed + floor(local_time / period);\n    \n    \n    \n    \n\tvec2 centre_circle = vec2(sin(seed_for_position * 1.234)*dist+0.5, cos(seed_for_position * 2.345)*dist+0.5);\n\tvec2 centre_circle_coord = (centre_circle*square_size)+(square_size*checker)-fragCoord_offset;\n\tvec2 centre_circle_uv = centre_circle_coord / iResolution.xy;\n\n    float distance_2_pix = distance(centre_circle, anything);\n   \tfloat t = 1.0 - clamp ((distance_2_pix - radius)*square_size, 0.0, 1.0);\n    \n\tvec2 circle_uv = vec2(fragCoord.x / iResolution.x, distance_2_pix / radius);\n    float circle_texture = mix(0.8,1.0, texture(iChannel1, circle_uv).r);\n\n    \n    vec4 circle_colour = texture(iChannel0, centre_circle_uv)*circle_texture;\n        \n    return mix(vec4(circle_colour.bgr, 0.0),vec4(circle_colour.bgr, 1.0), t*alpha_function(2.0*local_time/period));\n    \n}\n\n#define PERIOD_OF_EACH_DOT \t\t\t\t20.0\n#define NUM_OVERLAPPING_DOTS\t\t\t50\n#define TIME_BETWEEN_DISAPPEARING_DOTS\t(PERIOD_OF_EACH_DOT / float(NUM_OVERLAPPING_DOTS))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat square_size = iResolution.x/5.0;\n    \n    vec4 colour = texture(iChannel0, uv).bgra;\n    \n    \n    float dot_time\t= iTime / TIME_BETWEEN_DISAPPEARING_DOTS;\n    float dot_floor\t= floor(dot_time);\n    float dot_fract\t= fract(dot_time);\n    \n    for (int i = NUM_OVERLAPPING_DOTS - 1; i >= 0; i--)\n    {\n        vec2 fragCoord_offset = vec2(0,0);\n        \n        float dot_index\t\t\t= dot_floor - float(i);\n        \n        \n        if (isEven(dot_index))\n        {\n            fragCoord_offset = vec2(0.5*square_size);    \n        }\n        \n        vec2 local_fragCoord = fragCoord + fragCoord_offset;\n        vec2 checker = floor(local_fragCoord.xy/square_size);\n\n        float dot_start_time\t= dot_index * TIME_BETWEEN_DISAPPEARING_DOTS;\n        float dot_time\t\t\t= iTime - dot_start_time;\n         \n        if (dot_time > 0.0)\n        {\n            float dot_time_frac = dot_time / PERIOD_OF_EACH_DOT;\n            \n            float time_before_we_appear = fract(checker.x * 24.4353 * sin(dot_index * checker.y)) *0.1;\n            float extra_time_at_the_end_when_we_are_invisible = 0.0;//clamp((fract((checker.y * 3.145674) * (cos(checker.y/dot_index))*0.25)),0.0,0.4);\n            \n            float remapped_dot_time_frac = (dot_time_frac - time_before_we_appear) * (1.0 + time_before_we_appear + extra_time_at_the_end_when_we_are_invisible);\n            \n            float remapped_dot_time = clamp(remapped_dot_time_frac, 0.0, 1.0) * PERIOD_OF_EACH_DOT;\n            \n        \t//float time_offset = 0.0 * fract(sin(float(i) + checker.x * 4.2346 + checker.y * 12.34*TIME_BETWEEN_DISAPPEARING_DOTS+2.463 * square_size));\n\n            vec4 dot_colour = getColourAtPixel(local_fragCoord, fragCoord_offset,remapped_dot_time, square_size, dot_index, PERIOD_OF_EACH_DOT);\n           \n            colour.rgb = mix(colour.rgb, dot_colour.rgb, dot_colour.a);\n        }\n    }\n    \n    fragColor = colour;\n}\n","name":"Image","description":"","type":"image"}]}