{"ver":"0.1","info":{"id":"M3y3Ww","date":"1717708208","viewed":87,"name":"Interactive Julia w/ Mandelbrot","username":"berelium","description":"This is a modification of my first shader. Did some touch up work and then also added the mandelbrot set when you have the Mouse down. The axis on-click are the 0,0 vector.\nFullscreen is recommended!","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["fractal","julia","mouse","mandelbrot","interactive","normalmap","antialiasing","complex","smooth","normalization"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Interactive Julia RGB\" by berelium. https://www.shadertoy.com/view/NlcBz8\n// 2024-06-06 19:55:01\n\n// Touched up my first shader by adding a mandelbrot view to show the relationship between the two.\n// Definitely not optimized as I didn't restart entirely, but I like the result.\n\n// Only one or the other >\n//#define RAINBOW_HSL\n//#define POP_DETAILS\n\n// Lower AA if its too computationaly expensive, or crank it yo!\n#define AA 4\nfloat ITERATIONS = 400.0; // Iterations will change the detail (lower is cheaper to compute)\nfloat zoomFactor = 1.0; // smaller for in, bigger for out\n\n// Multiply two complex numbers\nvec2 multiplyComplex( in vec2 a, in vec2 b ) {\n\treturn vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\n// Calculate the julia set (mandelbrot has a c of (0,0)\nfloat juliaSet( in vec2 z, in vec2 c ) {\n\tvec2 _z = z;\n\tfor(float i = 0.0; i < ITERATIONS; i++) {\n\t\t_z = multiplyComplex(_z, _z) + c;\n        \n\t\tfloat nDot = dot(_z, _z);\n\t\tif(nDot > 45678.0) {\n\t\t\t// Smooth iteration count borrowed from Inigo Quilez\n\t\t\tfloat sl = i - log2(log2(nDot)) + 4.0;\n\t\t\treturn sl / ITERATIONS;\n\t\t}\n\t}\n\treturn 0.0;\n}\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n// Map iter count to color\nvec3 colorMap( in float ci, in vec3 cFilter) {\n    float e = 2.0; // effect\n    float d = 10.; // damper\n    float f = ITERATIONS * e / d; // use iteration count, so as to keep same map for different iterations\n    \n#ifdef RAINBOW_HSL\n    return hsl2rgb(vec3(ci*f/d, 0.2 + ci*(5.), 0.2+ci));\n#endif\n#ifdef POP_DETAILS\n    return vec3(0.5 + 0.5*sin(2.7+ci*f + cFilter));\n#endif\n\treturn vec3(0.5 + 0.5*cos(2.7+ci*f + cFilter));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Setup screen space\n    vec2 uv = (2.0*fragCoord.xy - iResolution.xy) / iResolution.y * zoomFactor;\n    \n    \n\t// Setup mouse to be used as a C position\n\tvec2 mouse = (2.0*iMouse.xy - iResolution.xy) / iResolution.y * zoomFactor - vec2(0.55, 0.0);\n\tif (iMouse.x == 0.0 && iMouse.y == 0.0) {\n        // Some cool positions from Wikipedia (try some before you click the screen!)\n        //mouse = vec2(0.4);\n        //mouse = vec2(-0.4, 0.6);\n        //mouse = vec2(0.285, 0.01);\n        //mouse = vec2(-0.835, 0.2321);\n        // Some positions from https://www.sekinoworld.com/fractal/gallery2D.htm\n        //mouse = vec2(0.27, 0.004);\n        //mouse = vec2(0.281220509396875, 0.011380997984375);\n\t\tmouse = vec2(-0.75, 0.1234 - iTime*0.001); // animated\n\t}\n    \n    vec2 handle = uv - vec2(0.55, 0.0);\n    if(iMouse.z < 0.5) handle = mouse; \n    \n    \n    // Initial julia\n    vec3 Julia = vec3(0.0);\n\tfloat currIter = juliaSet(uv, mouse);\n\tvec3 colorFilter = vec3(1.0);\n\n\n\t// Apply anti-aliasing\n\t#if AA>1\n\t\tfloat _AA = float(AA);\n\t\tvec2 aa = 1.0 / iResolution.xy, aaUV = vec2(0.0);\n\t\tvec2 aaOffset = vec2(0.0);\n\t\tfor(float i = 0.0; i < _AA; i++) {\n\t\t\tfor(float j = 0.0; j < _AA; j++) {\n\t\t\t\taaUV = uv + aa * vec2( (i+0.5)/_AA, (j+0.5)/_AA );\n                if(iMouse.z > 0.5) aaUV.x -= 0.55;\n                \n\t\t\t\tfloat aaIter = juliaSet(aaUV, handle);\n\t\t\t\tJulia += colorMap(aaIter, colorFilter);\n\t\t\t}\n\t\t}\n\t\tJulia /= _AA * _AA;\n\t#else    \n\t\tJulia += colorMap((iMouse.z > 0.5 ? juliaSet(handle, handle) : currIter), colorFilter);\n\t#endif\n    Julia = pow(Julia, vec3(2.5));\n    \n\n\t// Apply shifting rgb color filter\n\tfloat rgbSpeed = 0.5;\n\tvec3 rgbColor = vec3(0,3,5);\n\tvec3 rgb = 0.5 + 0.5*cos(iTime*rgbSpeed+uv.xyx+rgbColor);\n\t\t\n\tvec3 colorOut = mix(Julia, rgb, 0.05);\n#ifndef RAINBOW_HSL\n\tcolorOut *= rgb;\n#endif\n\n\t// Apply bloom to image\n\tfloat bloomFactor = .25;\n\tfloat bloomStrength = 0.8;\n\tvec3 bloom = vec3(0.05) + colorMap(currIter, colorFilter);\n        bloom = mix(vec3(0.0), bloom, bloomFactor);\n        bloom *= bloomStrength;\n    \n    \n    // Add ACES Film\n    colorOut = (colorOut*(2.51*colorOut+0.03))/(colorOut*(2.43*colorOut+0.59)+0.14);\n    \n    // Update some visuals, if mouse is pressed\n    if(iMouse.z > 0.5) {\n        bloom *= 1.5;\n        colorOut = tanh(colorOut);\n    }\n\tcolorOut += bloom; // apply bloom\n    \n    \n    // Added contrast adjust\n    float contrast = 1.04;\n    colorOut = (colorOut - 0.5) * contrast + 0.5;\n\n\n\t// Apply gamma correction\n\tcolorOut = pow(colorOut, vec3(0.4545));\n    \n    \n    // If the mouse is pressed: place a dot at the mouse position & render bars at the x/y axis\n    if(iMouse.z > 0.5) {\n        float bias = 2.0 / iResolution.y;\n        float r = 10. / iResolution.y; // Changed from small magic number (0.003) to one derived from resolution, to maintain size on fullscreen.\n        colorOut = mix(colorOut, vec3(smoothstep(r, r-bias, length(handle-mouse))*5., 0., 0.), 0.25);\n        \n        float xAxis = step(-bias, handle.y) * step(handle.y, bias);\n        float yAxis = step(-bias, handle.x) * step(handle.x, bias);\n        colorOut.r += (xAxis + yAxis) * 0.35;\n    }\n\n\n    // Out to screen\n    fragColor = vec4(colorOut, 1.0);\n}","name":"Image","description":"","type":"image"}]}