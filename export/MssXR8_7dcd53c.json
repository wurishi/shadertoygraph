{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//The raycasting code is somewhat based around a 2D raycasting toutorial found here: \n//http://lodev.org/cgtutor/raycasting.html\n#define COMPARE\nconst int MAX_RAY_STEPS = 80;\nfloat sdSphere(vec3 p, float d) { return length(p) - d; } \n \nstruct AABB {\n   vec3 Min;\n   vec3 Max;\n};\nAABB aabb =AABB(vec3(-22.0),vec3(22.0));\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  \tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\t\n\tfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\t\nbool getVoxel(vec3 c) {\n\t\n\tvec3 p = c+0.5 ;\n\t\n\t\n\tp = p+mod(p,aabb.Max.x*2.0)-aabb.Max.x;\n\t//if (noise(p)>0.5){\n\treturn ( noise(p)*min(max(-sdSphere(p, aabb.Max.x+5.0), sdBox(p, aabb.Max)), -sdSphere(p, 50.0)) <0.0);\n\t//}\telse {\n\t//\treturn false;\n\t//}\n}\n\nbool raystep(inout vec3 sideDist, inout vec3 mapPos, inout vec3 mask, const vec3 deltaDist, const vec3 rayStep){\n\t#ifndef COMPARE\n\tbvec3 b1 = lessThan(sideDist.xyz, sideDist.yzx);\n\tmask = vec3(lessThanEqual(sideDist.xyz, vec3(b1)*sideDist.zxy));\n\t#else\n\tvec3 cp = step( sideDist, sideDist.yzx );\n\tmask = (cp * ( vec3(1.0 ) - cp.zxy ));\n\t#endif\n\t\n\tsideDist += mask * deltaDist;\n\tmapPos += mask * rayStep;\n\treturn getVoxel(mapPos);\n}\nvec3 gamma(vec3 col){\n\treturn pow(col, vec3(1.0 / 1.2));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime;\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tvec3 rayDir = vec3(0.0, 0.001, 1.0) + screenPos.x * vec3(1.0, 0.0, 0.0) + screenPos.y * vec3(0.0, 1.0, 0.0)* iResolution.y / iResolution.x;\n\tvec3 rayPos = vec3(0.0, 13.0, -13.0);\n\trayDir.xz = rotate2d(rayDir.xz, t);\n\trayPos.xz = rotate2d(rayPos.xz, t);\n\tvec3 mapPos = floor(rayPos);\n\tvec3 deltaDist = abs(length(rayDir)/rayDir);\n\tvec3 rayStep = sign(rayDir);\n\tvec3 sideDist = ((rayStep*((mapPos) - rayPos) + rayStep * 0.5) + 0.5) * deltaDist; \n\tvec3 mask=vec3(0.0);\n\tbool hit=false;\n\t\n\tfor (int i = 0; i < MAX_RAY_STEPS; i++) {\n\t\thit = ( hit == false ) ? raystep(sideDist, mapPos, mask, deltaDist, rayStep):true;\n\t\tif (hit) continue; // should be break really ;)\n\t}\n\tfragColor.rgb = gamma(mask/(mapPos-rotate2d(rayPos.xz, t).xyy+20.5));\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MssXR8","date":"1396956229","viewed":449,"name":"branchless float voxel","username":"Panoptics","description":"streamlined the inner loop","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["voxel"],"hasliked":0,"parentid":"","parentname":""}}