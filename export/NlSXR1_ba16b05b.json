{"ver":"0.1","info":{"id":"NlSXR1","date":"1627018114","viewed":142,"name":"Continuous Factorial (Alt.)","username":"oneshade","description":"Alternative approximation for both positive and negative values using Euler's reflection formula:\ngamma(x)gamma(1-x) = (x - 1)!(-x)! = pi/sin(pi*x)\nI think I have been incorrectly calling this gamma but the factorial is actually gamma(x-1).","likes":5,"published":3,"flags":0,"usePreview":0,"tags":["approximation","continuous","factorial","alternative","specialfunction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Using Euler's reflection formula to extend the approximation\n// here: https://www.shadertoy.com/view/stl3DS\n// to negative values. The advantage is that there aren't any loops\n// (at least explicit ones, there may be some iterative scheme in\n// the sqrt(), pow(), and sinh() functions).\n\n#define draw(d, c) color = mix(color, c, smoothstep(unit, 0.0, d))\n\nconst float e = 2.7182818284;\nconst float pi = 3.14159265359;\nconst float tau = 6.28318530718;\n\nfloat pfactorial(in float x) {\n    x += 1.0;\n    float xx = x * x;\n    return sqrt(tau / x) * pow(x / e * sqrt(x * sinh(1.0 / x) + 1.0 / (810.0 * xx * xx * xx)), x);\n}\n\nfloat factorial(in float x) {\n    float y = pfactorial(abs(x));\n    return x < 0.0 ? pi * x / (y * sin(pi * x)) : y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 8.0;\n    float unit = 16.0 / iResolution.y;\n    vec3 color = vec3(1.0);\n\n    // Grid\n    draw(abs(fract(uv.x + 0.5) - 0.5) + 0.25 * unit, vec3(0.0, 0.0, 1.0));\n    draw(abs(fract(uv.y + 0.5) - 0.5) + 0.25 * unit, vec3(0.0, 0.0, 1.0));\n    draw(abs(uv.x), vec3(1.0, 0.0, 0.0));\n    draw(abs(uv.y), vec3(1.0, 0.0, 0.0));\n\n    // Draw the function\n    vec2 y = vec2(factorial(uv.x), 0.0);\n    y.y = (factorial(uv.x + 0.001) - y.x) / 0.001;\n    draw(abs(uv.y - y.x) / sqrt(1.0 + y.y * y.y) - 0.01, vec3(0.6, 0.0, 0.8));\n\n    // Draw continuous Pascal's triangle\n    //float n = uv.x + 8.0;\n    //float k = uv.y + 4.0;\n    //float binCoeff = round(gamma(n) / (gamma(k) * gamma(n - k))); // Rounding is affordable since I'm only wanting integers\n    //color = vec3(binCoeff * 0.01);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}