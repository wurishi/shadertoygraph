{"ver":"0.1","info":{"id":"stSXDK","date":"1628616582","viewed":79,"name":"SDF Raymarching Grid Demo","username":"Pseudonymous","description":"First time writing a raymarcher. Testing lighting a virtual scene, move around camera with your mouse!","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["mouse","raymarch","sdf","lighting","hue","dotproduct"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 50\n#define MIN_DIST .001\n#define MAX_DIST 30.\n#define EPSILON .002\n\nfloat SphereSDF (vec3 point, vec3 center, float radius) {\n    return distance(point, center) - radius;\n}\n\nfloat Dist (vec3 point) {\n    \n    return max(\n        SphereSDF(point, vec3(0, 0, 1.), 3. ),\n        min(\n            max(\n                max(\n                    max(\n                        SphereSDF(point, vec3(0, 0, 1.), .5),\n                        -(distance(point.xy, vec2(0)) - .3)\n                    ),\n                    -(distance(point.xz, vec2(0, 1)) - .3)\n                ),\n                -(distance(point.yz, vec2(0, 1)) - .3)\n            ),\n            SphereSDF(point, round(point), .02)\n        )\n    );\n}\n\nvec3 estimateNormal (vec3 ray) {\n    float dist = Dist(ray);\n    return normalize(\n        vec3(\n            dist - Dist(vec3(ray.x - EPSILON, ray.y, ray.z)),\n            dist - Dist(vec3(ray.x, ray.y - EPSILON, ray.z)),\n            dist - Dist(vec3(ray.x, ray.y, ray.z - EPSILON))\n        )\n    );\n}\n\nvec3 RayMarch (vec3 ro, vec3 rd) {\n\n    float distTravelled = 0.;\n    rd = normalize(rd);\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        \n        vec3 pointAtEndOfMarchedRay = ro + rd * distTravelled;\n        float distToObj = Dist(pointAtEndOfMarchedRay);\n        \n        if (distToObj <= MIN_DIST) {\n            return pointAtEndOfMarchedRay;\n        }\n        \n        distTravelled += distToObj;\n        \n        if (distTravelled >= MAX_DIST) return vec3(-10000000.);\n    }\n    \n    return vec3(-100000.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = 2. * vec2(\n        (fragCoord.x - .5 * iResolution.x) / iResolution.y, \n        fragCoord.y / iResolution.y - .5\n        );\n    vec3 ro = vec3(0., 0., 0.);\n    //ro.x = uv.x;\n    //ro.y = uv.y;\n    \n    ro = vec3(sin(iTime), cos(iTime), -.5);\n    ro = vec3(3. * uv.x / 5. + sin(iTime), 3. * uv.y / 5. + cos(iTime), 0);\n    \n    \n    ro = vec3(\n        (iMouse.x - .5 * iResolution.x) / iResolution.y, \n        iMouse.y / iResolution.y, -.5\n    );\n    \n    \n    vec3 rd = vec3(uv.x, uv.y, 1.);\n    \n    vec3 closestPoint = RayMarch(ro, rd);\n    \n    vec3 n = estimateNormal(closestPoint);\n    \n    vec3 lightCoord = vec3(5. * cos(iTime), 3., 1. + 5. * sin(iTime));\n    \n    float lighting = dot(n, lightCoord);\n    \n    vec3 baseColor = vec3(.4 * cos(iTime) + .6, 2. * abs(fract(iTime / 3.) - .5), .3 * sin(iTime) + .7);\n    \n    baseColor = abs(normalize(closestPoint));\n    \n    vec3 col = baseColor + max(30. - distance(closestPoint, lightCoord), 0.) * lighting * .005;\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}