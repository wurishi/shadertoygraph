{"ver":"0.1","info":{"id":"ts23zy","date":"1549422003","viewed":543,"name":"Twisted Eye (Voxelmarched)","username":"Elyxian","description":"A test of a voxeltracing algorithm which combines the standard approach (eg. by Dave Hoskins here: https://www.shadertoy.com/view/4dfGz4) and a raymarching algorithm in order to traverse empty spaces quickly.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","voxel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n#define VOXELSIZE 0.05\n//#define VOXELSIZE (exp(-4.0 * (sin(iTime / 5.0) * 0.5 + 0.5)))\n\n// From IQ\nfloat sdTorus(vec3 p, vec2 t) {\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n\nfloat tower(vec3 p, vec2 t, vec3 h) {\n\t\n    vec3 q = abs(p.xzy) - h;\n    float val = sdTorus(max(q, 0.0), t) + min(max(q.x, max(q.y, q.z)), 0.0);\n    return val;\n\n}\n\nfloat distanceMap(vec3 p) {\n    \n    // Get height of terrain\n    float height = -2.8;\n    height += 0.50 * valueNoise(p.xz * 0.25 + vec2(13.4, 71.2));\n    height += 0.20 * valueNoise(p.xz * 0.50 + vec2(51.5, 41.4));\n    height += 0.10 * valueNoise(p.xz * 1.00 + vec2(23.4, 94.3));\n    \n    float dist = p.y - height;\n    dist *= 0.5;\n    \n    // Apply the sphere effect\n    float sphereRadius = 18.0;// + iTime * 0.3;\n    dist = max(dist, length(p) - sphereRadius);\n    \n    // Rings\n    int outerRingCount1 = 12;\n    float distFromCenter1 = 2.5;\n    vec2 torusParams = vec2(3.3 + 0.5 * sin(iTime / 3.0), 0.12 + 0.03 * sin(iTime));\n    \n    for (int i = 0; i < outerRingCount1; i++) {\n        float perc = float(i)/float(outerRingCount1);\n        vec3 pos = vec3(\n            distFromCenter1 * sin(2.0*PI*perc + iTime*0.1),\n            3.8 + distFromCenter1 * cos(2.0*PI*perc + iTime*0.1),\n            0.0//-5.0 * smoothstep(0.0, 1.0, -0.3 + sin(6.0*perc * 2.0*PI + iTime))\n            );\n        float tDist = tower(p - pos, torusParams, vec3(0.0));\n        dist = min(dist, tDist);\n    }   \n              \n\treturn dist;\n    \n}\n\n// Get the voxel belonging to the point p\n// Due to the fact that the p is often on the edge of a voxel in the voxeltracing algorithm,\n// the xyz step direction of the ray needs to be used to get (mostly) accurate results\nvec3 getVoxel(vec3 p, vec3 step) {\n\t\n    float eps = 0.0001;\n    vec3 voxel = floor(p / VOXELSIZE + eps * step) * VOXELSIZE;\n    return voxel;\n\n}\n\n// Voxel tracing algorithm\n// This one is adapted from Dave Hoskin's implementation: https://www.shadertoy.com/view/4dfGz4\n// That implementation (and the one by fb39ca4 here: https://www.shadertoy.com/view/4dX3zl) may be faster\n// The main advantage to this implementation is that it can make use of a distance map to\n// skip large, empty areas\nfloat voxelTrace(vec3 ro, vec3 rd) {\n    \n    // Standard raytracing parameters\n    int maxSteps = 500;\n    float maxDist = 200.0;\n    float t = 0.0;\n    bool hit = false;\n    \n    // Whether the ray is moving positively or negatively along the xyz axes\n    vec3 step = sign(rd);\n    \n    // Main raytracing loop\n    for (int i = 0; i < maxSteps; i++) {\n    \t\n        // Get the current point\n        vec3 currentPoint = ro + t * rd;\n        \n        // Get the current voxel (note that this is imperfect, and a disadvantage of this implementation)\n        //float eps = 0.01;\n        vec3 voxel = getVoxel(currentPoint, step);\n        \n        // Exit if the current voxel is solid\n        float d = distanceMap(voxel);\n        if (d <= 0.0) {\n            hit = true;\n        \tbreak;\n        }\n        \n        // Exit if the ray got too far from the origin\n        if (t > maxDist) {\n        \tbreak;\n        }\n        \n        // Get the distance (travelling along rd) until the next voxel is hit in the xyz directions\n        vec3 tNext = (voxel + VOXELSIZE * (step * 0.5 + 0.5) - currentPoint) / rd;\n        \n        // Move forward towards the next voxel, or slightly less than distance from the distance map\n        // (in order to avoid the effects of voxelising a scene), depending on which is larger\n        float tStep = min(tNext.x, min(tNext.y, tNext.z));\n        t += max(tStep, d - VOXELSIZE * 2.0);\n        \n    }\n    \n    if (hit) {\n        return t;\n    }\n    \n    return -1.0;\n    \n    \n}\n\n// From IQ: https://www.shadertoy.com/view/Xds3zN\nmat3 setCamera(vec3 ro, vec3 ta, float cr) {\n\t\n    vec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n    return mat3( cu, cv, cw );\n    \n}\n\nvec3 getDiffuse(vec3 p) {\n    \n    //vec3 col = normalize(hash33(p));\n    \n    vec3 col = vec3(0.701, 0.572, 0.368) + hash33(p) * 0.1;\n    return col;\n    \n}\n\n// A non-ideal way of getting the normal at a given point, given the direction of the ray\nvec3 getNormal(vec3 ro, vec3 rd, float t) {\n\t\n    // Get the point and the signed direction of the ray\n    vec3 p = ro + t * rd;\n    vec3 step = sign(rd);\n    \n    vec2 add = vec2(1.0, 0.0);\n    vec3 normal = vec3(0.0, 0.0, 0.0);\n    \n    // Calculate the distance in the xyz for the previous voxel\n    vec3 distNext = (getVoxel(p, step) + VOXELSIZE * (step * 0.5 + 0.5) - p) / step;\n    vec3 distPrev = vec3(VOXELSIZE) - distNext;\n    \n    // Take the minimum distance and assume that represents the edge the current point is on\n    if (distPrev.x <= distPrev.y && distPrev.x <= distPrev.z) {\n    \tnormal = vec3(-step.x, 0.0, 0.0);\n    }\n    \n    else if (distPrev.y <= distPrev.x && distPrev.y <= distPrev.z) {\n    \tnormal = vec3(0.0, -step.y, 0.0);\n    }\n    \n    else {\n    \tnormal = vec3(0.0, 0.0, -step.z);\n    }\n    \n    return normal;\n    \n}\n\nvec3 getColor(vec3 ro, vec3 rd, float t) {\n\t\n    vec3 p = ro + t * rd;\n    vec3 step = sign(rd);\n    \n    // Directional light source\n    vec3 lightDir = normalize(vec3(1.0, 2.0, -1.0));\n    //vec3 lightDir = normalize(vec3(cos(iTime), 1.0, sin(iTime)));\n    \n    // The intensity/color of light (all three values are the same for white light)\n    vec3 lightCol = vec3(1.0);\n    \n    // Applies the 'base color' of the light\n    vec3 baseLightCol = vec3(1.0, 1.0, 1.0);\n    lightCol *= baseLightCol;\n    \n    // Applies normal-based lighting\n    vec3 normal = getNormal(ro, rd, t);\n    float normalLight = saturate(dot(normal, lightDir));\n    normalLight = max(0.3, normalLight);\n    lightCol *= normalLight;\n    \n    // Gets the diffuse lighting\n    vec3 diffuse = getDiffuse(getVoxel(p, step));\n    \n    // Get the final color\n    vec3 col = lightCol * diffuse;\n    return col;\n    \n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    \n    float t = voxelTrace(ro, rd);\n    \n    vec3 col = vec3(0.0);\n    \n    if (t < 0.0) {\n    \tcol = vec3(0.9, 0.9, 0.9);\n    }\n    \n    else {\n        col = getColor(ro, rd, t);\n    }\n    \n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Normalises the fragCoord\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv - 0.5;\n    p.x *= iResolution.x/iResolution.y;\n    \n    // Gets the origin of the ray\n    vec2 mo = iMouse.xy / iResolution.xy - 0.5;\n    float hAngle = 0.0;\n    float vAngle = 0.0;\n\n    if (mo.x > -0.4) {\n        hAngle = mo.x * -8.0;\n        vAngle = mo.y * 2.0;\n    }\n    else {\n        hAngle = (iTime - 10.0) / 7.0;\n        vAngle = -0.1;\n    }\n\n    float dist = 15.0; //1.0\n    float height = 3.0;\n    vec3 ro = vec3(0.0, height, -dist);\n    ro.yz *= mm2(vAngle);\n    ro.xz *= mm2(hAngle);\n    \n    // Gets the direction of the ray\n    vec3 ta = vec3(0.0, 1.5, 0.0);\n    mat3 cam = setCamera(ro, ta, 0.0);\n    vec3 rd = normalize(cam * normalize(vec3(p, 0.8)));\n    \n    // Render the ray\n    vec3 col = render(ro, rd);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// This file just contains standard noise functions and so on.\n\n// Returns the matrix that rotates a point by 'a' radians\nmat2 mm2(in float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\n// Returns the clamped version of the input\nfloat saturate(float t) {\n    return clamp(t, 0.0, 1.0);\n}\n\n// ----------------------------\n// ------ HASH FUNCTIONS ------\n// ----------------------------\n\n// Hash functions by Dave Hoskins: https://www.shadertoy.com/view/4djSRW\n\nfloat hash11(float p) {\n    \n\tvec3 p3  = fract(vec3(p) * 0.1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n    \n}\n\nfloat hash12(vec2 p) {\n    \n\tvec3 p3  = fract(vec3(p.xyx) * 0.1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n    \n}\n\nfloat hash13(vec3 p3) {\n    \n\tp3  = fract(p3 * 0.1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n    \n}\n\nvec3 hash31(float p) {\n   \n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n\n}\n\nvec3 hash33(vec3 p3) {\n\n    p3 = fract(p3 * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n// -------------------------\n// ------ VALUE NOISE ------\n// -------------------------\n\n\nfloat valueNoise(vec2 p) {\n    \n\tvec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    f = f*f*f*(f*(f*6.0-15.0)+10.0);\n    \n    vec2 add = vec2(1.0,0.0);\n    float res = mix(\n        mix(hash12(i + add.yy), hash12(i + add.xy), f.x),\n        mix(hash12(i + add.yx), hash12(i + add.xx), f.x),\n        f.y);\n    return res;\n        \n}\n\nfloat valueNoise(vec3 p) {\n    \n\tvec3 i = floor(p);\n    vec3 f = fract(p);\n    \n    f = f*f*f*(f*(f*6.0-15.0)+10.0);\n    \n    vec2 add = vec2(1.0,0.0);\n    float res = mix(\n        mix(\n        \tmix(hash13(i + add.yyy), hash13(i + add.xyy), f.x),\n        \tmix(hash13(i + add.yxy), hash13(i + add.xxy), f.x),\n        f.y),\n        mix(\n            mix(hash13(i + add.yyx), hash13(i + add.xyx), f.x),\n        \tmix(hash13(i + add.yxx), hash13(i + add.xxx), f.x),\n        f.y),\n        f.z);\n    return res;\n        \n}","name":"Common","description":"","type":"common"}]}