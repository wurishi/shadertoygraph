{"ver":"0.1","info":{"id":"mtjcRw","date":"1691602318","viewed":98,"name":"flow curve","username":"Aite25","description":"my first shader!ohhhhhhhhhhhhhhhhhhhhhhhhhhh","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["2d","sin","curve","flow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535\n\nvec4 _LineColor = vec4(0.69,0.93,1,1);\nfloat _C1h = 0.2;\nfloat _C1r = 4.2;\nfloat _C1spd = 0.03;\nfloat _C1s = 0.7;\n\nfloat _C2h = 0.2;\nfloat _C2r = 5.22;\nfloat _C2spd = 0.02;\nfloat _C2s = 0.6;\n\nfloat _Cnf = 1.0;\n\nfloat noisemap(vec2 x) {\n    return texture(iChannel0, x*0.1).x;\n}\n\nfloat fit(float aa, float ba, float ca, float da, float ea) {\n    float newa = (aa - ba) * (ea - da) / (ca - ba) + da;\n    newa = clamp(newa, da, ea);\n    return newa;\n}\n\nvec3 hueRotate(vec3 color, float angle) {\n    vec3 luminance = vec3(0.299, 0.587, 0.114);\n    float luminanceDot = dot(color, luminance);\n    vec3 perpendicular = color - luminanceDot * luminance;\n    vec3 rotatedColor = cos(angle) * perpendicular + sin(angle) * cross(luminance, perpendicular) + luminanceDot * luminance;\n    \n    return rotatedColor;\n}\n\nfloat sin_cul(float u, float c_ratio, float c_spd, float c_height, float c_offset) {\n    return sin(u * c_ratio * sin(iTime * 0.02 * PI * 2.0 * 1.5) + \n    iTime * 2.5 * PI * 2.0 * 4.0 * c_spd + c_offset) * 0.5 * c_height + 0.5;\n}\n\nfloat createCurve(vec2 inputUV, vec2 noiseUV, float noise_factor, float flowscale, float flowspeed, float sinvalue, float c_stroke) {\n    float noisemask2 = noisemap(noiseUV * flowscale + flowspeed * iTime * 0.02 * fit(sin(iTime * 0.2 + flowspeed), -1.0, 1.0, 0.0, 1.0));\n    float noisemask1 = noisemap(vec2(noiseUV.x + fit(sin(iTime * 0.3 + flowspeed), -1.0, 1.0, 0.0, 1.0), noiseUV.y) + fract(iTime * 0.2));\n    float curve_mask = 0.0;\n\n    float sin_gap = distance(sinvalue, inputUV.y);\n    float c_thres = noisemask1 + noisemask2;\n    c_thres = c_thres * c_stroke * noise_factor;\n    if (sin_gap < c_thres) {\n        curve_mask = (c_thres - sin_gap) * 90.0 * noisemask2;\n    }\n    return curve_mask;\n}\n\nfloat ndot(vec2 a, vec2 b) {\n    return a.x * b.x - a.y * b.y;\n}\n\nfloat sdRhombus(vec2 p, vec2 b) {\n    p = abs(p);\n    float h = clamp(ndot(b - 2.0 * p, b) / dot(b, b), -1.0, 1.0);\n    vec2 factor = vec2(1.0 - h, 1.0 + h);\n    vec2 offset = 0.5 * b * factor;\n    float d = length(p - offset);\n    float signedDistance = d * sign(p.x * b.y + p.y * b.x - b.x * b.y);\n    return signedDistance;\n}\n\nfloat drawRhombus(vec2 uv, vec2 wh, float factor) {\n    vec2 baseVector = wh;\n    float signedDist = sdRhombus(uv, baseVector);\n    float rhombus = 1.0;\n    if (signedDist < 0.0) {\n        rhombus = abs(signedDist) * 90.0 * factor;\n    } else {\n        rhombus = 0.0;\n    }\n    return rhombus;\n}\n\nfloat drawRhombus2(vec2 uv, vec2 posuv, vec2 wh, float factor) {\n    return drawRhombus(uv - posuv, wh, factor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec4 positionSS = vec4(uv * 2.0 - 1.0, 0.0, 1.0);\n    vec3 positionWS = positionSS.xyz / (positionSS.w + 0.00000000001);\n    vec3 ndc = positionSS.xyz / (positionSS.w + 0.00000000001);\n    vec2 screenUV = ndc.xy;\n    vec2 screenPos = screenUV * iResolution.xy;\n\n    vec2 inputUV = uv;\n    vec4 lineclr = _LineColor;\n    lineclr.rgb = hueRotate(lineclr.rgb, sin(iTime * 2.0) * 0.3);\n    float sin1value = sin_cul(inputUV.x, _C1r, _C1spd, _C1h, 0.0);\n    float sin2value = sin_cul(inputUV.x, _C2r, _C2spd, _C2h, 5.0);\n    float noise_factor = _Cnf * 0.01;\n\n    float c1_mask = createCurve(inputUV, inputUV, noise_factor + 0.01, 1.0, 0.2, sin1value, _C1s);\n    float c2_mask = createCurve(inputUV, inputUV, noise_factor + 0.01, 0.7, 0.3, sin2value, _C2s);\n    vec4 c1_clr_r = createCurve(inputUV, vec2(inputUV.x - 0.01, inputUV.y), noise_factor, 2.0, 0.2, sin1value, _C1s) * vec4(1.0, 0.0, 0.0, 1.0) * lineclr;\n    vec4 c1_clr_g = createCurve(inputUV, inputUV, noise_factor, 2.0, 0.2, sin1value, _C1s) * vec4(0.0, 1.0, 0.0, 1.0) * _LineColor;\n    vec4 c1_clr_b = createCurve(inputUV, vec2(inputUV.x + 0.01, inputUV.y), noise_factor, 2.0, 0.2, sin1value, _C1s) * vec4(0.0, 0.0, 1.0, 1.0) * lineclr;\n    vec4 c1_clr = c1_clr_r + c1_clr_g + c1_clr_b;\n    vec4 c2_clr_r = createCurve(inputUV, vec2(inputUV.x - 0.01, inputUV.y), noise_factor, 2.5, 0.3, sin2value, _C2s) * vec4(1.0, 0.0, 0.0, 1.0) * lineclr;\n    vec4 c2_clr_g = createCurve(inputUV, inputUV, noise_factor, 2.5, 0.3, sin2value, _C2s) * vec4(0.0, 1.0, 0.0, 1.0) * _LineColor;\n    vec4 c2_clr_b = createCurve(inputUV, vec2(inputUV.x + 0.01, inputUV.y), noise_factor, 2.5, 0.3, sin2value, _C2s) * vec4(0.0, 0.0, 1.0, 1.0) * lineclr;\n    vec4 c2_clr = c2_clr_r + c2_clr_g + c2_clr_b;\n    \n    vec4 finclr;\n    finclr = c1_clr + c2_clr;\n    finclr.rgb *= _LineColor.a * 2.2;\n    finclr.a = clamp(finclr.a,0.0,1.0);\n    vec2 setuv = uv;\n    float width = 0.1 * _C1s;\n\n    float factor1 = createCurve(vec2(inputUV.x, sin1value), vec2(inputUV.x, sin1value), noise_factor, 2.0, 0.2, sin1value, _C1s);\n    float factor2 = createCurve(vec2(inputUV.x, sin2value), vec2(inputUV.x, sin2value), noise_factor, 0.7, 0.3, sin2value, _C2s);\n    float pct1 = drawRhombus2(uv, vec2(fract(iTime * 0.1 * 3.0), sin1value), vec2(width, width * 0.3), factor1);\n    float pct3 = drawRhombus2(uv, vec2(fract(iTime * 0.1 * 3.0 + 1.5), sin1value), vec2(width, width * 0.3), factor1);\n    float pct2 = drawRhombus2(uv, vec2(fract(iTime * 0.1 * 3.0), sin2value), vec2(width, width * 0.3), factor2);\n    float pct4 = drawRhombus2(uv, vec2(fract(iTime * 0.1 * 3.0 + 3.6), sin2value), vec2(width, width * 0.3), factor2);\n    vec4 pctclr = (pct1 + pct2 + pct3 + pct4) * lineclr;\n    \n    fragColor = finclr + pctclr;\n}","name":"Image","description":"","type":"image"}]}