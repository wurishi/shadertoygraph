{"ver":"0.1","info":{"id":"Dtc3zM","date":"1682564248","viewed":42,"name":"circle_C","username":"codec","description":"raymarch","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST .001\n\nfloat GetDist(vec3 p) {\n\n    vec4 s = vec4(0, 1, 6, 1);\n    \n    float d1 = length(p - s.xyz) - s.w;\n    float d2 = p.y - 0.2f;\n    \n    return min(d1,d2);\n}\n\nfloat sdTourHorizontal(vec3 p,vec2 r) {\n    \n    float d1 = length(p.xz) - r.x;\n    float d = length(vec2(p.y,d1)) - r.y;\n    return d;\n    \n}\n\nfloat sdTourVertrical(vec3 p,vec2 r,vec3 position) {\n    \n    vec3 p1 = p - position;\n    float d1 = length(p1.xy) - r.x;\n    float d = length(vec2(p1.z,d1)) - r.y;\n    return d;\n    \n}\n\nfloat sdC(vec3 p,vec2 r,vec3 position) {\n    \n    vec3 p1 = position - p;\n    \n    if(p1.x > 0. &&  dot(normalize(p1).xy,vec2(1,0))> 0.7f) {\n        return 100.;\n    }\n    \n    float d1 = length(p1.xy) - r.x;\n    float d = length(vec2(p1.z,d1)) - r.y;\n    \n    \n    return d;    \n}\n\nfloat sdD(vec3 p,vec2 r,vec3 position) {\n    \n    vec3 p1 = position - p;\n    \n    if(p1.x < 0.) {\n        return 100.;\n    }\n    \n    float d1 = length(p1.xy) - r.x;\n    float d = length(vec2(p1.z,d1)) - r.y;\n    \n    float d2 = 1000.;\n    if(( p1.y > - r.y * 5. && p1.y < r.y * 5.) && abs(p1.x) < 0.15) {\n        d2 = p1.z;\n    }\n    return min(d,d2);    \n}\n\n\nfloat RayMatch(vec3 ro,vec3 rd) {\n    \n    float dO = 0.;\n    \n    for(int i = 0; i < MAX_STEPS; ++i) {\n        vec3 p = ro + rd* dO;\n        float d1 = GetDist(p);\n        //float d1 = sdD(p,vec2(1.0,0.2),vec3(0,1,0));\n        //float d1 = sdTourVertrical(p,vec2(1.0,0.6),vec3(0,1,0));\n        dO += d1;\n        if(d1 < SURFACE_DIST || dO > MAX_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p);\n    vec2 e = vec2(.01,0);\n    vec3 N = d - vec3(\n    GetDist(p - e.xyy),\n    GetDist(p - e.yxy),\n    GetDist(p - e.yyx));\n    \n    return normalize(N);\n    \n}\n\nfloat GetLight(vec3 lightPos,vec3 p){\n\n    vec3 lightDir = normalize(lightPos - p);\n    vec3 N = GetNormal(p);\n    float dif = dot(lightDir,N);\n    dif = clamp(dif, 0.,1.);\n    //float d = RayMatch(p+N*SURFACE_DIST*2.,lightDir);\n    //if(length(lightPos - p) > d) dif *= .1;\n    \n    return dif;\n}\n\nmat3 setCamera(vec3 ro,vec3 ta) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = cross(ww, vec3(0,1.,0));\n    uu = normalize(uu);\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu,vv,ww);  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord *2./iResolution.xy - 1.);\n    \n    uv.y *= iResolution.y/ iResolution.x;\n    \n    vec3 ro = vec3(0.,2.,-10.);\n    ro += vec3( 2. * sin(iTime), 0, -2. * cos(iTime * .5));\n    vec3 ta = vec3(0,1.5,0.);\n    \n    //draw o\n    mat3 camera2World = setCamera(ro,ta);\n    vec3 rd = normalize(camera2World * vec3(uv,1.5f));\n    \n    float d = RayMatch(ro,rd);\n    \n    vec3 p = ro + d * rd;\n    \n    vec3 lightPos = vec3(0,2.,-5.);\n    \n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    float col = GetLight(lightPos,p);\n    \n    \n    \n    vec3 lightPos1 = vec3(2,0.,2); \n    vec3 lightPos2 = vec3(-2,0.,-5);\n    //col += GetLight(lightPos1,p);\n    //col += GetLight(lightPos2,p);\n    //draw c\n    \n    \n    vec3 dif = vec3(col);\n    // Time varying pixel color\n    // Output to screen\n    if (d > MAX_DIST) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    dif = mix(dif,vec3(1.0,0.5,0) ,0.7);\n    fragColor = vec4(dif, 1.0);\n}","name":"Image","description":"","type":"image"}]}