{"ver":"0.1","info":{"id":"WdcXR2","date":"1572469683","viewed":230,"name":"Dungeon Critter","username":"bembi","description":"tp2","likes":23,"published":1,"flags":32,"usePreview":0,"tags":["interactive","cartoon","animation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;    \n\tfragColor = texture(iChannel0,uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159265359\n#define TWO_PI PI * 2.\n\nvec2 translate(vec2 _st, vec2 _pos){\n    return _st - _pos;\n}\nvec2 rotate(vec2 _st, float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) \n           *_st;\n}\nvec2 scale(vec2 _st, vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y)\n           *_st;\n}\nfloat s(float speed, float range){\n    return (sin(iTime*speed)*0.5+0.5) * range;\n}\nfloat poly(vec2 uv,vec2 p, float s, float dif,float N,float a){\n    // Remap the space to -1. to 1.\n    vec2 st = p - uv ;\n    // Angle and radius from the current pixel\n    float a2 = atan(st.x,st.y)+a;\n    float r = TWO_PI/N;\n    float d = cos(floor(.5+a2/r)*r-a2)*length(st);\n    float e = 1.0 - smoothstep(s,s+dif,d);\n    return e;\n}\nfloat flame(vec2 uv, vec2 pos, float size, float tall, float phase){\n    vec2 st = uv;\n    st.y += -0.01;\n    st.x += sin(iTime*10.+phase)*((uv.y - pos.y) * 0.04) + sin(iTime*3.+phase)*((uv.y - pos.y) * 0.03);\n    st = translate(st, pos+vec2(0, -0.001));\n    st.y *= sin(iTime*5.6+phase)*0.08 + (0.3 / tall); \n    st *= 2.;\n    st = translate(st, -pos-vec2(0, -0.001));\n    return poly(st,\n        pos,\n        sin(iTime*10.)*.0005 + (0.01*size),\n        0.004, 3., 0.);\n}\nfloat eye(vec2 uv, vec2 pos, vec2 lookAt, float o, float scared){\n    vec2 st = uv;\n    float circleSides = 12.;\n    lookAt -= pos;\n    float angle = atan(lookAt.y, lookAt.x);\n    vec2 dir = vec2(cos(angle), sin(angle));\n    float blink = smoothstep(0.94, 0.99, sin(iTime*2. + o*.1));\n    \n    st = translate(st, vec2(.5));\n    st = rotate(st, sin(iTime*2.4)*.01);\n    st.y *= 1. + blink*5.; \n    st = translate(st, -vec2(.5));    \n    \n    float eyeCompo =  poly(st, pos                                 , 0.020 * (1.+ 0.001*o) * (1.+0.4*scared)                  , 0.002, circleSides, 0.)                \n         - poly(st, pos+(.007*dir) +(0.002*o)      , (0.0033+s(10.,0.001*scared) *(-0.002*o))* (5.*(1.-scared)) , 0.002,     circleSides, 0.)\n         + poly(st, pos+(.014*dir) +(0.002*o)      ,\n            0.0005 * (5.*(1.-scared))\n                * (1. + s(3., .8)\n                * s(5., .8)), //este ultimo s() necesita tener el mismo timming qye lightspot\n            0.002, circleSides, 0.)\n            * (scared*2. + 0.3);\n    \n    eyeCompo *= 1. - smoothstep(0.94, 0.99, sin(iTime*2. + o*.1));\n    \n    return eyeCompo;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    \n    // hack para el aspect ratio. todo: Pero fuckea un toque la coord de iMouse tambien...\n    uv = translate(uv, vec2(.5));\n    uv.x *= (iResolution.x/iResolution.y);\n    uv *= 0.57;\n    uv = translate(uv, -vec2(.5));\n    \n    vec2 st;\n    // true for control it with mouse\n    vec2 pos = false ? vec2(iMouse.x, 1.-iMouse.y) : vec2(sin(iTime)*0.2, sin(iTime*0.25)*0.1)+.5;\n    float closeToTorch = 1. - smoothstep(0., 0.15, distance(vec2(.5), pos));\n\n//  mist\n    float mist = sin(uv.y*8. + sin(uv.x*2.+iTime*.5 + sin(uv.y*30.5+iTime*0.001 + sin(uv.x*10.+iTime*0.5))));\n    mist = mist * mist;\n        \n//  wall\n    st = uv;\n    st.x += (1. - step(1./11., mod(st.y, 1./11.*2.))) * 0.1;\n    st.x = fract(st.x*5.);\n    st.y = fract(st.y*11.);       \n    st.x += sin(uv.x*10.+uv.y*4.) * 0.1;\n    st.y += sin(uv.y*100.+uv.x*4.) * 0.1;    \n    float wall = poly(st, vec2(.5), 0.45, 0.02, 4., 0.) * .5;\n    \n//  hole\n    st = uv;\n    st.x += sin(uv.y*20.+7.1) * 0.01;\n    st.y += sin(uv.x*20.+10.2) * 0.001;\n    st = translate(st, vec2(.5));\n    st = rotate(st, -.01);\n    st.y *= 2.3; \n    st = translate(st, -vec2(.5));\n    float hole = poly(st, vec2(.5), 0.08, 0.05, 4., 0.);\n     \n//  eyes\n    st = uv;\n    st = translate(st, vec2(.5));\n    st = rotate(st, sin(iTime*40.4)*(.04*closeToTorch));\n    st *= 1. + (0.6*closeToTorch); \n    st = translate(st, -vec2(.5));\n    vec2 face_pos = vec2(.5) + vec2(sin(iTime*40.)*(0.007*closeToTorch), sin(iTime*12.)*(0.001*closeToTorch));\n    float face = eye(st, face_pos+vec2(0.03,0.), pos, 1., closeToTorch)\n               + eye(st, face_pos+vec2(-0.03,0.), pos, 0., closeToTorch);\n    \n//  lightSpot\n    st = uv;\n    st.y += -0.02;\n    float lightSpot = poly(st, pos, \n        0.02,\n        s(3., .02) + s(5.,.02) + .27,\n        20.,\n        s(5., .2));\n        \n//  torch\n    st = uv;  \n    st = translate(st, pos);\n    st.x *= 18.;\n    st.x *= 1. + 4. * ((1.-pos.y) - (1.-uv.y));\n    st = translate(st, -pos);\n    st = translate(st, vec2(0,-0.06));\n    float torch_stick = poly(st, pos+vec2(0.,-0.1), 0.15, 0.002, 4., 0.);\n    st = uv;\n    st.y += -0.04;\n    st = translate(st, pos);\n    st.y *= 2.5; \n    st = translate(st, -pos);\n    st = translate(st, vec2(0, -.12));\n    float torch_top = poly(st, pos, 0.02, 0.01, 3., PI);\n    st = uv;\n    st = translate(st, pos);\n    st.y *= 2.; \n    st.x *= 0.42; \n    st = translate(st, -pos);\n    st.y -= 0.01;\n    float torch_top_back = poly(st, pos, .02, .0002, 20., 0.);\n    st = uv;\n    st = translate(st, pos);\n    st.y *= 2.5; \n    st.x *= 0.49; \n    st = translate(st, -pos);\n    st.y -= 0.01;\n    float torch_reflexion = poly(st, pos, .02, .002, 20., 0.);\n    \n    float torch = torch_stick + torch_top;\n        \n    \n//  fire      \n    st = uv;\n    st = translate(st, pos);\n    st *= 0.9;\n    st = translate(st, -pos);\n    float fire =\n        flame(st, pos, 1.4, .73, 0.)\n        + flame(st, pos, 2.8, .3, 4.)\n        + flame(st, pos+vec2(0.013,0), 1., .55, 10.)\n        + flame(st, pos+vec2(-0.013,0), 1., .5, 3.5)\n        + flame(st, pos+vec2(-0.02,0), .4, .5, 20.5)\n        + flame(st, pos+vec2(0.02,0), .4, .5, 20.5)\n        ;    \n\n//  ajustes y mergeo de todo lo que va a ser pasado a la grilla\n    float lightmap;\n    mist = clamp(mist, -0.1, 1.) * 0.5;\n    wall = wall+wall/2.;\n    lightmap = (wall + mist - hole*2.) * lightSpot + (lightSpot/2.) + fire; \n    \n//  dibujar grilla\n    st = uv;\n    st = fract(st*200.);    \n    float endCompo = poly(st, vec2(.5,.5), lightmap*0.5, 0.01, 10., 0.);    \n    \n//  adjustments\n    endCompo *= 0.6;\n    endCompo += (face*0.8)*lightSpot;\n    endCompo -= torch_top_back;\n    endCompo += fire*2.; //just reburn fire again without grid - multiply to cut top_back\n    endCompo -= torch*7.; // multiply to cut flames\n    endCompo += torch_reflexion*10.;\n \n \n    st = gl_FragCoord.xy / iResolution.xy; //todo: por alguna razom toque restaurar las uv, o el feedback se distorciona\n    fragColor = vec4(endCompo,\n                    texture(iChannel0, st-vec2(\n                        0.01 * (0.005 +  1.-sin(st.y*PI)),\n                        0\n                        )).r,\n                    texture(iChannel0, st-vec2(\n                        0.01 * (0.01 +  1.-sin(st.x*PI)),\n                        0\n                        )).r,\n                    1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}