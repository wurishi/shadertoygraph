{"ver":"0.1","info":{"id":"ltSczV","date":"1509546010","viewed":91,"name":"3D-Test","username":"nhoughto","description":"A 3D sphere using ray tracing. Referencing this tutorial here: http://fabricecastel.github.io/blog/2015-09-06/main.html","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","raycast","sphere","tracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// camera attributes\n// cameraDirection and cameraUp MUST be normalized\n// (ie. their length must be equal to 1)\nconst vec3 cameraPosition = vec3(0.0, 0.0, 10.0);\nconst vec3 cameraDirection = vec3(0.0, 0.0, -1.0);\nconst vec3 cameraUp = vec3(0.0, 1.0, 0.0);\n\n// ray computation vars\nconst float PI = 3.14159265359;\nconst float fov = 50.0;\nconst float fovx = PI * fov / 360.0;\nconst float S = 0.1;\nconst vec3 deltax = vec3(S ,0, 0);\nconst vec3 deltay = vec3(0 ,S, 0);\nconst vec3 deltaz = vec3(0 ,0, S);\n\nfloat distanceToNearestSurface(vec3 p){\n    return length(p) - 1.0;\n}\n\nvec3 computeSurfaceNormal(vec3 p){\n    float d = distanceToNearestSurface(p);\n    return normalize(vec3(\n    \tdistanceToNearestSurface(p + deltax)-d,\n        distanceToNearestSurface(p + deltay)-d,\n        distanceToNearestSurface(p + deltaz)-d\n    ));\n}\n\nvec3 computeLambert(vec3 p, vec3 n, vec3 l){\n    return vec3(dot(normalize(l-p), n));\n}\n                \nvec3 intersectsWithWorld(vec3 p, vec3 dir){\n  \tfloat dist = 0.0;\n    float nearest = 0.0;\n    bool hit = false;\n    for(int i = 0; i < 20; i++){\n        float nearest = distanceToNearestSurface(p + dir*dist);\n        if(nearest < 0.01){\n            vec3 hit = p + dir * dist;\n            vec3 light = vec3(100.0*sin(iTime),\n                             \t30.0 * cos(iTime),\n                              \t30.0 * cos(iTime));\n            return computeLambert(hit, computeSurfaceNormal(hit), light);\n        }\n        dist += nearest;\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n  \n    // generate the ray for this pixel\n    float fovy = fovx * iResolution.y/iResolution.x;\n    float ulen = tan(fovx);\n\tfloat vlen = tan(fovy);\n    vec2 camUV = uv*2.0 - vec2(1.0, 1.0);\n    vec3 nright = normalize(cross(cameraUp, cameraDirection));\n    vec3 pixel = cameraPosition + cameraDirection + nright*camUV.x*ulen + cameraUp*camUV.y*vlen;\n    vec3 rayDirection = normalize(pixel - cameraPosition);\n    \n\tvec3 pixelColor = intersectsWithWorld(cameraPosition, rayDirection);\n    fragColor = vec4(pixelColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}