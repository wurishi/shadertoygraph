{"ver":"0.1","info":{"id":"wls3WX","date":"1558732292","viewed":96,"name":"Raytracer test","username":"BeingBeckett","description":"test","likes":1,"published":1,"flags":1,"usePreview":0,"tags":["raytracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    sphere Ls[10];\n    Ls[0] = sphere(vec4(iMouse.xy,200,0),vec3(1,1,01));\n    sphere spheres[10];\n    spheres[0] = sphere(vec4(290,200,200,200),vec3(1.0,1,1));\n     spheres[1] = sphere(vec4(200,200,100,100),vec3(1.0,0,1));\n    Ray start = Ray(vec3(fragCoord.xy,0),normalize(vec3(fragCoord.xy,0)-vec3(200,200,-50)));\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\nvec3 col = vec3(0,0,0);\nint Cround = 0;\nint Chit  =1000 ;\n    for(int i = 0; i<spheres.length(); i++){\n    // Time varying pixel color\n    float t = SphereIntesect(spheres[i].Loc,start);\n    if(t>0.0){\n        Chit = i;\n    //col = (col*float(Cround)+GetAng(start.vel,(start.pos+start.vel*t)-vec3(200,200,200))*spheres[i].Color)/(float(Cround+1)) ;\n      //  Cround++;\n    }}\n    for(int i = 0; i<Ls.length(); i++){\n     col += (GetAng(start.vel,(start.pos+start.vel*SphereIntesect(spheres[Chit].Loc,start))-Ls[i].Loc.xyz)*spheres[Chit].Color) /50.0;}\n    fragColor = vec4(col,1.0);\n}\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    sphere spheres[10];\n    spheres[1] = sphere(vec4(200,200,200,200),vec3(1.0,1.0,0));\n    Ray start = Ray(fragRayOri,fragRayDir);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\nvec3 col = vec3(0,0,0);\nint Cround = 0;\n    for(int i = 0; i<spheres.length(); i++){\n    // Time varying pixel color\n    float t = SphereIntesect(spheres[i].Loc,start);\n    if(SphereIntesect(vec4(200.0,200,100.0,100.0),start)>0.0){\n    col = ((col*float(Cround))+GetAng(start.vel,(start.pos+start.vel*t)-vec3(200,200,120))*spheres[i].Color)/(float(Cround+1)) ;\n        Cround++;\n    }}\n    fragColor =  vec4(2.0*col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"struct Ray { vec3 pos; vec3 vel; }; \n struct sphere {vec4 Loc; vec3 Color;};\nfloat SphereIntesect(vec4 Sphere, Ray M){\n        if(distance(Sphere.xyz,M.pos)>=Sphere.w){\n    if(pow(dot(M.vel,M.pos-Sphere.xyz),2.0)-(pow(length(M.pos-Sphere.xyz),2.0)-pow(Sphere.w,2.0))>=0.0){\n        float C1 = (-(dot(M.vel,(M.pos-Sphere.xyz)))-sqrt(pow(dot(M.vel,M.pos-Sphere.xyz),2.0)-(pow(length(M.pos-Sphere.xyz),2.0)-pow(Sphere.w,2.0))));\n        float C2 = (-(dot(M.vel,(M.pos-Sphere.xyz)))+sqrt(pow(dot(M.vel,M.pos-Sphere.xyz),2.0)-(pow(length(M.pos-Sphere.xyz),2.0)-pow(Sphere.w,2.0))));\n        if(C1>=0.0&&C2>=0.0){\n        \n          return min(C1, C2);\n        }\n        else if(C1<0.0&&C2>0.0){\n            return C2;}\n        else if(C1>=0.0&&C2<0.0){\n            return C1;}\n    }};\n  return 0.0; \n}\n\nfloat PlaneIntesect(vec4 Sphere, Ray){\n    \nreturn float(1);}\nfloat GetAng();\nfloat GetAng(vec3 A,vec3 B){\nreturn acos(dot(normalize(A),normalize(B)));}\n","name":"Common","description":"","type":"common"}]}