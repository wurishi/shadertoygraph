{"ver":"0.1","info":{"id":"Wdj3Dt","date":"1550282936","viewed":383,"name":"Mipmap DOF","username":"belfry","description":"Testing cheap depth of field using mipmaps. Left side with effect enabled, right side disabled. Mouseable.","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["dof","mipmap","depthoffield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mx = iMouse.x / iResolution.x;\n    mx = mx <= 0. ? .5 : mx;\n    vec2 uv = fragCoord / iResolution.xy;\n    float m = texture(iChannel0, uv).a;\n    float ms = step(uv.x, mx);\n    float s = step(uv.x, mx - .001) + step(mx + .001, uv.x);\n    fragColor = s * textureLod(iChannel0, uv, smoothstep(5., 6., m) * 2.5 * ms);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float map(vec3 p) {\n    float b = length(p - vec3(0.4, 0., 0.)) - 1.;\n    p = mod(p, 1.) - .5;\n    return max(length(p) - .3, -b);\n}\n\nvec3 normal(vec3 p) {\n    vec2 eps = vec2(0.005, 0.);\n    float dx = map(p + eps.xyy) - map(p - eps.xyy);\n    float dy = map(p + eps.yxy) - map(p - eps.yxy);\n    float dz = map(p + eps.yyx) - map(p - eps.yyx);\n    return normalize(vec3(dx, dy, dz));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\n    float fov = radians(60.);\n    vec3 camPos = vec3(0.4, 0.3, 0.4);\n    vec3 camDir = normalize(vec3(uv, 1. / tan(fov * .5)));\n\n    vec4 di = texelFetch(iChannel0, ivec2(fragCoord) % 1024, 0);\n    float i = 0.;\n    float t = di.a * .85;\n    vec3 p;\n    bool hit = false;\n    for (; i < 500.; i++) {\n        p = camPos + t * camDir;\n        float d = map(p);\n        if (d < .001 * t) {\n            hit = true;\n            break;\n        }\n        t += d;\n        if (t > 100.)\n            break;\n    }\n    \n    if (hit) {\n        vec3 n = normalize(normal(p) + (di.rgb - .5) * .035);\n        vec3 l = normalize(vec3(1.));\n        float diff = max(0.1, dot(n, l)) * .5;\n        float spec = pow(max(0., dot(n, normalize(l - camDir))), 32.);\n        float rim = pow(1. - dot(-camDir, n), 5.) * .2;\n        vec3 c = (sin(p) * .5 + .5);\n        vec3 g = vec3(i / 250., t / 40., i / 200.);\n        fragColor = vec4(c * (diff + spec + rim + .1) + g, t);\n    } else {\n        fragColor = vec4(0.);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}