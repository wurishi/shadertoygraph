{"ver":"0.1","info":{"id":"cs2Xzy","date":"1670487804","viewed":101,"name":"Mochi Donut","username":"eltonm","description":"Move the light source with the mouse. Change the variable MODE to move the camera with the mouse.","likes":1,"published":1,"flags":0,"usePreview":1,"tags":["raymarching"],"hasliked":0,"parentid":"ddjSRh","parentname":"3D Ray Marching 2022 GIG"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 3D RAY-MARCHING CLASS DEMO!\n//\n// Numerous methods borrowed from iq articles:\n//   https://iquilezles.org/www/index.htm\n// \n// 3D signed distance functions:\n//   https://iquilezles.org/articles/distfunctions\n// \n// Shadows:\n//   https://iquilezles.org/articles/rmshadows\n// \n// Ray-marching SDFs:\n//   https://iquilezles.org/articles/raymarchingdf\n// \n// Normals for SDFs:\n//   https://iquilezles.org/articles/normalsSDF\n\nconst int MODE = 0; //if changed, the mouse will move the camera\n\nconst float SAFEMARCH = 0.95;\nconst float PI = 3.14159265359;\n\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\nvec4  opUnion(vec4 d1, vec4 d2) {\n return (d1.x < d2.x ? d1 : d2);   \n}\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, 0.,\n\t\t+.0, +.0, 1.);\n}\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\nfloat fbm(in vec3 pos) {\n    mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n    vec3 q = 8.0*pos;\n    float f  = 0.5000*noise( q ); q = m*q*2.01;\n    f += 0.2500*noise( q ); q = m*q*2.02;\n    f += 0.1250*noise( q ); q = m*q*2.03;\n    f += 0.0625*noise( q ); q = m*q*2.01;\n    return f;\n}\n\n\nfloat sdSphere( vec3 p, float r )\n{\n  return length(p)-r;\n}\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n  // sampling independent computations (only depend on shape)\n  float w = sqrt(r*r-h*h);\n  \n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                          abs(length(q)-r) ) - t;\n}\n\n// SDF and color of nearby surface.\n// .x: SDF value\n// .yzw: RGB values\nvec4 mapV4(vec3 p) {\n\n    vec4 res = vec4(100000., vec3(0.0));\n    \n    // DONUT:\n    {\n        vec3  q = rotate_x(p,-0.5);\n        vec3 c = vec3(0., -0.12, -0.32);\n        vec3 col = vec3(0.96, 0.78, 0.55);\n        //float time = iTime * 0.5; //for spinning donut, laggy\n        //if(p.y + fbm(p)*0.01 > c.y + 0.1) { col = vec3(1.0, 0.5, 0.8); }\n        for(float i = 0.; i < 12.; i++) {\n            vec3 loc = vec3(0.45*sin(i*PI/6.),0.,0.45*cos(i*PI/6.)); \n            float d = sdSphere(q-c-loc,0.15);\n            d += 0.01*fbm(q);\n            //res = opUnion(res, vec4(d, col));\n            res = vec4 (opSmoothUnion(res.x, d, 0.06), col);\n        }\n        q.y *= -1.1;\n        q.y -= 0.21;\n        for(float j = 0.; j < 12.; j++) {\n            vec3 loc = vec3(0.45*sin(j*PI/6.),0.,0.45*cos(j*PI/6.));\n            float d = sdCutHollowSphere(q-c-loc,0.13,0.,0.015);\n            res = opUnion(res, vec4(d, vec3(1.0, 0.55, 0.8)));\n            //res = vec4 (opSmoothUnion(res.x, d, 0.06), vec3(1.0, 0.5, 0.8));\n        }\n    }\n    // PLANE:\n    {\n        //float d = sdPlane(p+0.2*vec3(0.,fbm(p),0.), normalize(vec3(0.,1.,0.1)), +0.25);\n        float d = sdPlane(p, normalize(vec3(0.,0.21,0.1)), +0.25);\n        //d += 0.01*fbm(p);\n        vec3 col = mix(vec3(0.9), vec3(0.1,0.1,0.15),vec3(0.4*sin(p.x*8.+fbm(p*0.3)*15.)+0.5));\n        res = opUnion(res, vec4(d,col));\n    }       \n    \n    return res;\n}\n\n// SDF representation of our scene. Model things here.\nfloat map(vec3 p) {\n    return mapV4(p).x;\n}\n\n\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(map(p+h.xyy) - map(p-h.xyy),\n                           map(p+h.yxy) - map(p-h.yxy),\n                           map(p+h.yyx) - map(p-h.yyx) ) );\n}\n\n\n// March along ray (ro,rd) from t=tmin to tmax and return distance achieved. \nfloat raymarch(vec3 ro, vec3 rd, float tmin, float tmax) {\n\n    for(float t=tmin; t<tmax; ) {\n        vec3 rt = ro + t*rd; // position on ray\n        float d = map(rt);   // sdf at position\n        if(d<0.00001) {// hit something\n            return t;\n        }\n        t += SAFEMARCH * d;//smaller step for safety\n        if(t>=tmax) { // left screen\n            return tmax;\n        }\n    }\n    return tmax;// may need more steps\n}\n\n\n// Hard shadow. Returns how much of the light you see, on [0,1].\nfloat shadow(in vec3 ro, in vec3 rd, float tmin, float tmax) {\n    float t = raymarch(ro, rd, tmin, tmax);\n    if(t < tmax) // hit object\n        return 0.0;\n    else\n        return 1.0;\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        vec3 rt = ro + rd*t;\n        float h = map(rt);\n        if( h<0.00001 )\n            return 0.0;\n            \n        res = min( res, k*h/t );\n        t += SAFEMARCH * h;\n    }\n    return res;\n}\n\n\nvec3 render(vec3 ro, vec3 rd, float pixY) {\n\n    vec3 col = vec3(0.0);\n    vec2 m   = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    float maxt = 10.0;\n    float t = raymarch(ro, rd, 0.0, maxt);    \n    \n    if(t >= maxt) {//hit nothing\n        // set background color\n        col = vec3(0.03,0.,0.05);\n    }\n    else { // shade object\n    \n        // Intersection point info:\n        vec3 p = ro + t*rd;\n        vec3 n = calcNormal(p);\n        vec3 pCd = mapV4(p).yzw;// object/point color\n        if(n.z < 0.) { pCd = vec3(1.0, 0.5, 0.8); }\n        vec3  q = rotate_x(p,2.0);\n        \n\n        // LIGHTS!!!\n        vec3 pLight0;\n        if(MODE == 0) { pLight0 = vec3(3.*m.x, 3.*m.y, 0.5); }\n        else { pLight0 = vec3(-2., 1., 0.5); }\n        vec3 Cd0     = vec3(0.9);//light color\n        vec3 L0      = normalize(pLight0 - p); // unit vector to point light #0\n        //float S0     = shadow(p, L0, 0.01, length(pLight0-p));\n        float S0     = softshadow(p, L0, 0.01, length(pLight0-p), 15.0);\n        vec3 C0      = clamp(dot(L0,n),0.,1.) * pCd * S0;\n\n        col = C0*0.8;\n        \n        vec3 pLight1 = vec3(2.0, 0.3, 2.);\n        vec3 Cd1     = vec3(0.7,0.7,1.0);//light color\n        vec3 L1      = normalize(pLight1 - p); // unit vector to point light #0\n        //float S1     = softshadow(p, L1, 0.01, length(pLight0-p), 15.0);\n        vec3 C1      = clamp(dot(L1,n),0.,1.) * pCd;// * S1;\n\n        col += C1*Cd1*0.7;\n        \n        pLight1 = vec3(-2.0, 0.2, 2.);\n        Cd1     = vec3(1.0,0.8,0.6);//light color\n        L1      = normalize(pLight1 - p); // unit vector to point light #0\n        //float S1     = softshadow(p, L1, 0.01, length(pLight0-p), 15.0);\n        C1      = clamp(dot(L1,n),0.,1.) * pCd;\n        \n        col += C1*Cd1*0.5;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv  = fragCoord/iResolution.xy; // on [0,1]x[0,1]\n    vec2 pXY = (fragCoord-0.5*iResolution.xy)/iResolution.y; // position on screen\n    vec2 m   = (iMouse.xy-0.5*iResolution.xy)/iResolution.xy;\n    \n    // Camera setup:\n    vec3 pix = vec3(pXY, 0.0);// z=0 virtual image\n    vec3 ro;\n    if(MODE == 0) { ro = vec3(0., 0., 3.); }\n    else { ro  = vec3(sin(m.x*PI*-0.75), sin(m.y*PI*-0.75), 3.); }\n    vec3 rd  = normalize(pix - ro);\n    vec3 col = render(ro, rd, uv.y);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}