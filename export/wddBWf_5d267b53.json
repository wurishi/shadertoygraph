{"ver":"0.1","info":{"id":"wddBWf","date":"1606175257","viewed":143,"name":"checkerboard animation 10","username":"DjinnKahn","description":"for https://isohedral.ca/swirled-series/","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["checkerboard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\n\nconst int SHEET_THICKNESS = 16;\n\nconst float END_TIME = 3.6;\nconst vec3 END_POS = vec3( 7., 49., 2. * float(SHEET_THICKNESS) );\n\n\nfloat easeInOutQuad( float x ) \n{\n\treturn x < 0.5 ? 2. * x * x : 1. - pow(-2. * x + 2., 2.) / 2.;\n}\n\nfloat ease01( float t )\n{\n    t = clamp( t, 0., 1. );\n    return t*t*.5; // want slope=1 at t=1\n}\n\nfloat timelineRaw( float t )\n{\n    float ret = 0.;\n    t = mod( t, END_TIME + .2 );\n    \n    const float EASE_IN_DURATION = .4;\n    const float EASE_OUT_DURATION = .4;\n    const float LINEAR_DURATION = END_TIME - EASE_IN_DURATION - EASE_OUT_DURATION;\n    \n    ret += ease01( t / EASE_IN_DURATION ) * EASE_IN_DURATION;\n    t -= EASE_IN_DURATION;\n    if ( t <= 0. ) return ret;\n    \n    ret += min( t, LINEAR_DURATION );\n    t -= LINEAR_DURATION;\n    if ( t <= 0. ) return ret;\n    \n    ret += ( ease01( 1. ) - ease01( 1. - t / EASE_OUT_DURATION ) ) * EASE_IN_DURATION;\n    return ret;\n}\n\nfloat timeline( float t )\n{\n    return timelineRaw( t ) / timelineRaw( END_TIME ) * END_TIME;\n}\n\nvec3 rotY( vec3 p, float angle )\n{\n    return vec3( p.x * cos(angle) + p.z * sin(angle), p.y, p.x * -sin(angle) + p.z * cos(angle) );\n}\nvec3 rotX( vec3 p, float angle )\n{\n    return vec3( p.x, p.y * cos(angle) + p.z * sin(angle), p.y * -sin(angle) + p.z * cos(angle) );\n}\n\nint div( int a, int b ) { return a >= 0 ? a/b : (a-b+1)/b; }\n\nint hitLayer( vec3 pos )\n{    \n    if ( pos.z >= END_POS.z )\n        pos.xy -= END_POS.xy;\n        \n    int pattern = int(floor(pos.z/float(SHEET_THICKNESS))) == 0 ? 0 : 0;\n    if ( int(floor(pos.z/float(SHEET_THICKNESS))) == 1 ) pattern = 4;\n    \n    pos.z += float(SHEET_THICKNESS) * 10.; // just avoid negative z\n    \n    int x = int( floor( pos.x * 8. ) );\n    int y = int( floor( pos.y * 8. ) );\n    int z = int( round( pos.z ) ) % SHEET_THICKNESS;\n        \n    int i = z-4;\n    if ( i >= 0 && i < 8 )\n    \tif ( ((div(x,z)+div(y,z)*((i&1)==0?-1:1))&7) == (i+pattern)%8 ) return i&1;\n    \n    return -1;\n}\n\nfloat go( vec2 fragCoord, float t )\n{\n    vec2 uv = (fragCoord - iResolution.xy*.5) / iResolution.y;\n    if ( uv.x < -.5 || uv.x >= .5 )\n        return .2;\n    \n    float angle = t/END_TIME*2.*PI;\n    float easedAngle = easeInOutQuad(t/END_TIME)*2.*PI;\n    //float easedAngle = angle;\n    \n    float col = .4;\n    vec3 startPos = vec3( 0., 0., 0. );\n    startPos.z += easeInOutQuad( t/END_TIME ) * float(SHEET_THICKNESS)  * 2. + sin( easeInOutQuad( clamp(t,0.,1.) ) * PI ) * -6.;\n    startPos.x += (1. - cos( easedAngle )) * 3. + easeInOutQuad(t/END_TIME) * END_POS.x;\n    startPos.y += sin( easedAngle ) * 1. + easeInOutQuad(t/END_TIME) * END_POS.y;\n    //startPos.z += ( iMouse.x - iResolution.x * .5 ) * .1;\n    //startPos.xy -= ( iMouse.xy - iResolution.xy * .5 ) * .001;\n    vec3 pos = startPos;\n    vec3 dir = vec3( uv, 1. );\n    //dir = rotX( dir, (1.-cos( easedAngle )) * .9 );\n    dir = rotX( dir, sin( easedAngle*.5 ) * 1.5 );\n    dir = rotY( dir, sin( easedAngle ) * .3 );\n\n    //dir = rotX( dir, sin( angle ) * .8 );\n    //dir = rotY( dir, (1.-cos( angle )) * .3 );\n    //dir = rotX( dir, ( iMouse.y - iResolution.y * .5 ) * .01 );\n    //dir = rotY( dir, ( iMouse.x - iResolution.x * .5 ) * .01 );\n    dir /= abs(dir.z);\n    \n    if ( dir.z >= 0. )\n    \tpos += ( 1. - fract( pos.z ) ) * dir;    \n    else\n    \tpos += fract( pos.z ) * dir;   \n    \n    \n    for ( int i = 0; i < 60; i++, pos += dir )\n    {\n        int c = hitLayer( pos );\n        if ( c != -1 )\n        {\n        \tcol = float( c );        \n        \tbreak;\n        }\n    }\n    \n    float fog = 1. - pow( .98, length(pos - startPos) - 13. );\n    col = mix( col, .5, fog );   \n    //col = length(pos - startPos) * .1;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(.2,.2,.2,1.0);\n    vec2 uv = (fragCoord - iResolution.xy*.5) / iResolution.y;\n    if ( uv.x < -.5 || uv.x >= .5 )\n        return;\n    \n    float SPEED = 1.;\n    int BLUR_N = 4;\n    \n    float colSum = 0.;\n    for ( int i = 0; i < BLUR_N; i++ )\n    {    \n\t\tcolSum += go( fragCoord, ( timeline( iTime + iTimeDelta * float(i) / float(BLUR_N) ) ) * SPEED ) / float(BLUR_N);\n    }\n\n    fragColor = vec4(vec3(colSum),1.0);\n}","name":"Image","description":"","type":"image"}]}