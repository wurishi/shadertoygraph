{"ver":"0.1","info":{"id":"MfcGWX","date":"1712185367","viewed":79,"name":"Voxel AO Ground Truth","username":"chronos","description":"Computing visibility term of commonly considered voxel AO cases using numerical integration.\nNote that this ONLY considers actual occlusion, NOT bounced / reflected light, or light at all for that matter.\nOnly the fraction of rays that are not occluded.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["voxel","ao","occlusion","ambient","numerical","ground","integration","truth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define USE_COSINE_TERM 0\n#define SHOW_WALLS 1\n#define USE_SRGB 1\n\n// Use this to toggle walls on or off:\nfloat walls[4] =  float[4](1.,0.,0.,1.); // Wall on: 1 , off: 0\n\nconst float num_samples = 1000.; // for numerical integration\n\n\n\nfloat sRGBencode(float C_linear) { return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear); }\nvec3 sRGBencode(vec3 C_linear) { C_linear = clamp(C_linear, 0., 1.); return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z)); }\nfloat sRGBdecode(float C_sRGB) { return C_sRGB > 0.04045 ? (pow((C_sRGB + 0.055)/1.055, 2.4) ) : (C_sRGB / 12.92); }\nvec3 sRGBdecode(vec3 C_sRGB) { return vec3(sRGBdecode(C_sRGB.x), sRGBdecode(C_sRGB.y), sRGBdecode(C_sRGB.z)); }\n\n\nfloat hash(vec3 uv)\n{\n    uint x = floatBitsToUint(uv.x) | 1u; // 0 is a fixed point so we remove it. although this introduces duplicate 1\n    uint y = floatBitsToUint(uv.y);\n    uint z = floatBitsToUint(uv.z);\n    \n    y ^= y >> 13;\n    y ^= y << 17;\n    y ^= y >> 5;\n    y *= 0x2545F491u;\n\n    x ^= y;\n    x ^= x >> 13;\n    x ^= x << 17;\n    x ^= x >> 5;\n    x *= 0x4F6CDD1Du;\n    \n    z ^= x;\n    z ^= z >> 13;\n    z ^= z << 17;\n    z ^= z >> 5;\n    z *= 0x1D6C45F4u;\n    \n    // Shift down by 9 to use top 23 bits in mantissa\n    // Use exponent and sign bits from 0.5\n    // floatBitsToUint(.5) is a constant so that part can be pre-computed. (0x3f000000)\n    // Since the top 23 bits are shifted right, the rest (top bits) are zero and do not need to be masked out\n    // uint w = ((z>>9) & 0x007FFFFFu) | (0xFF800000u & floatBitsToUint(.5));\n    \n    uint w = (z>>9) | 0x3f000000u; // simplified version of the above commented out line\n    \n    // re-normalize from [0.5, 1) to [0, 1)\n    // This probably loses some bits, but should still be ok\n    return 2. * uintBitsToFloat(w) - 1.;\n}\n\nfloat ray_plane(vec3 ro, vec3 rd, vec3 n, vec3 p)\n{\n    // solve dot((ro-p) + rd * t, n) = 0\n    float denom = dot(rd, n);\n    if(denom == 0.) return -1.;\n    float t = dot(p-ro, n) / denom;\n    return t;\n}\n\nconst float PI = 3.14159265;\n\nvec3 rnd_dir_hemi(float rnd0, float rnd1)\n{\n    float azimuthal = 2.*PI*rnd0;\n    float zenith = asin(sqrt(rnd1));\n\n    float x = sin(zenith)*cos(azimuthal);\n    float y = cos(zenith);\n    float z = sin(zenith)*sin(azimuthal); \n    return vec3(x,y,z);\n}\n\nvec3 rot(vec3 p, vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    vec3 projected = dot(p, axis) * axis;\n    vec3 rejected  = p - projected;\n    return projected + rejected * cos(angle) + sin(angle) * cross(axis, rejected);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv    = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 mouse = (2. * iMouse.xy - iResolution.xy) / iResolution.y;\n\n    if(length(iMouse.xy) < 10.)\n        mouse = vec2(fract(iTime / 8.), 0);\n\n    vec3 color = vec3(0);\n\n    float focal = 2.;\n    vec3 rd = normalize(vec3(uv, -focal));\n\n    rd = rot(rd, vec3(1,0,0), -0.4);\n\n    float angle = mouse.x * PI * 2.;\n    rd = rot(rd, vec3(0,1,0), angle);\n\n    vec3 ro = vec3(0,1.2,0) + rot(vec3(0,0,1.8), vec3(0,1,0), angle);\n\n    vec3 n = vec3(0, 1, 0);\n    vec3 P = vec3(0);\n    float t = ray_plane(ro, rd, n, P);\n\n    // center points of the walls\n    vec3 pos[4] = vec3[4](vec3(.5, 0.5, 0.), vec3(-.5, 0.5, 0.), vec3(0.0, 0.5, .5), vec3(0.0, 0.5, -.5));\n    \n\n    float visibility = 0.;\n\n    if(t > 0.) // if we hit the plane\n    {\n        vec3 p = rd * t + ro; // compute hit position\n\n        if(abs(p.x)< .5 && abs(p.z)<.5) // if we hit the voxel surface\n        {\n            vec3 RO = p; // new ray origin from where we hit\n            \n            \n            for(float s = 0.; s < num_samples; s++)\n            {\n                float rnd0 = hash(vec3(RO.xz+iTime, 2.*s));\n                float rnd1 = hash(vec3(RO.xz+iTime, 2.*s+1.));\n\n                vec3 RD = rnd_dir_hemi(rnd0, rnd1);\n\n                #if USE_COSINE_TERM\n                float occ = max(dot(n, RD), 0.); // cos(ray, normal)\n                #else\n                float occ = 1.;\n                #endif\n                for(int i = 0; i < 4; i++)\n                {\n                    vec3 N = normalize(vec3(0.,0.5,0.) - pos[i]);\n                    float T = ray_plane(RO, RD, N, pos[i]);       // Intersect wall plane\n\n                    if(t > 0. && t < 1000.)\n                    {\n                        vec3 hit = RD * T + RO;\n\n                        vec3 diff = abs(hit - pos[i]);\n                        float d = max(max(diff.x, diff.y), diff.z);\n                        if(d < .5 && walls[i] > 0.) occ = 0.;         // if we hit a wall, we fully occlude the contriubution here\n                    }\n                }\n\n                visibility += occ  / num_samples; // Accumulate and normalize contribution of sample to the integral\n            }\n\n            /*\n            if(mouse.x < uv.x)\n            {\n                // approximation goes here!\n                float occ = 1.;\n                float strength = 0.75;\n                //occ *= mix(-p.x + .5, 1., strength) * mix(p.z + .5, 1., strength);\n                occ *= mix((p.z-p.x)/(sqrt(2.)/2.) + .5, .5, strength);\n                color = vec3(occ);\n            }\n            */\n        }\n    }\n    \n    color += visibility;\n    \n#if SHOW_WALLS\n    float nearest_hit = 9e9;\n    float farthest_hit = 0.;\n    for(int i = 0; i < 4; i++)\n    {\n        n = normalize(pos[i] - vec3(0.,0.5,0.));\n        t = ray_plane(ro, rd, n, pos[i]);\n\n        if(t > 0.)\n        {\n            vec3 p = rd * t + ro;\n\n            vec3 diff = abs(p - pos[i]);\n            float d = max(max(diff.x, diff.y), diff.z);\n            color = mix(color, vec3(1), 0.1 * float(d < .5) * walls[i]);\n            \n            nearest_hit = min(nearest_hit, t);\n            farthest_hit = max(farthest_hit, t);\n        }\n    }\n    \n    #if 0\n    // Intending to use this for rendering a height surface for visualizing the shape of the function (2D scalar field)\n    // But this requires that the visibility is computed at every ray marching step, and for the projected position, not for the current ray\n    // So would have to e.g. do the numerical integration in a separate buffer to read from.\n    float max_t = farthest_hit;\n    float max_steps = 100.;\n    float dt = max(max_t-nearest_hit, 1e-3) / max_steps;\n    for(float t = nearest_hit; t < max_t; t += dt)\n    {\n        vec3 p = ro + rd * t;\n\n        if(p.y < visibility)\n        {\n            color = mix(color, vec3(visibility), 1.); //float(abs(p.x) < 1. && abs(p.z ) < 1.);\n            break;\n        }\n    }\n    #endif\n    \n#endif\n\n    #if USE_SRGB\n    color = sRGBencode(color); //color = pow(color, vec3(1./2.2));\n    #endif\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}