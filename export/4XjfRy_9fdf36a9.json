{"ver":"0.1","info":{"id":"4XjfRy","date":"1729615584","viewed":178,"name":"purple colony","username":"nayk","description":"source from manyspce","likes":3,"published":3,"flags":1,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define iterations 13\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam;\n            p.xy*=mat2(cos(iTime*0.05),sin(iTime*0.05), -sin(iTime*0.05),cos(iTime*0.05));// the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.2-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.03,1.);\t\n}\n#define time iTime\n#define resolution iResolution.xy\n\n\n\nmat3 rotX(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(\n        1, 0, 0,\n        0, c, -s,\n        0, s, c\n    );\n}\n\nmat3 rotY(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(\n        c, 0, -s,\n        0, 1, 0,\n        s, 0, c\n    );\n}\n\nfloat random(vec2 pos) {\n    return fract(sin(dot(pos.xy, vec2(13.9898, 78.233))) * 43758.5453123);\n}\n\nfloat noise(vec2 pos) {\n    vec2 i = floor(pos);\n    vec2 f = fract(pos);\n    float a = random(i + vec2(0.0, 0.0));\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n#define NUM_OCTAVES 6\nfloat fbm(vec2 pos) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n    for (int i = 0; i < NUM_OCTAVES; i++) {\n        float dir = mod(float(i), 2.0) > 0.5 ? 1.0 : -1.0;\n        v += a * noise(pos - 0.05 * dir * time);\n\n        pos = rot * pos * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nconst float PI = 3.1415;\nconst float TWOPI = 2.0*PI;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n;\nvec2 uPos = ( gl_FragCoord.xy / resolution.y );//normalize wrt y axis\n\tuPos -= vec2((resolution.x/resolution.y)/2.0, 0.5);//shift origin to center\n\t\n\tfloat multiplier = 0.0005; // Grosseur\n\tconst float step = 0.006; //segmentation\n\tconst float loop = 80.0; //Longueur\n\tconst float timeSCale = 0.5; // Vitesse\n\t\n\tvec3 blueGodColor = vec3(0.0);\n\tfor(float i=1.0;i<loop;i++){\t\t\n\t\tfloat t = time*0.1*timeSCale-step*i*i;\n\t\tvec2 point = vec2(0.75*sin(t), 0.5*sin(t));\n\t\tpoint += vec2(0.75*cos(t*4.0), 0.5*sin(t*3.0));\n\t\tpoint /= 11. * sin(i);\n\t\tfloat componentColor= multiplier/((uPos.x-point.x)*(uPos.x-point.x) + (uPos.y-point.y)*(uPos.y-point.y))/i;\n\t\tblueGodColor += vec3(componentColor/3.0, componentColor/3.0, componentColor);\n\t}\n\t\n    \n\t\n\tvec3 color = vec3(0,0,0);\n\tcolor += pow(blueGodColor,vec3(0.1,0.3,0.8));\n    \n    \n    \n    \n    vec2 uPos4 = ( gl_FragCoord.xy / resolution.y );//normalize wrt y axis\n\tuPos4 -= vec2((resolution.x/resolution.y)/2.0, 0.5);//shift origin to center\n\t\n\n\t\n\tvec3 blueGodColor2 = vec3(0.0);\n\tfor(float i=1.0;i<loop;i++){\t\t\n\t\tfloat t = time*timeSCale-step*i;\n\t\tvec2 point = vec2(0.75*sin(t), 0.5*sin(t));\n\t\tpoint += vec2(0.75*cos(t*4.0), 0.5*sin(t*3.0));\n\t\tpoint /= 2.0;\n\t\tfloat componentColor= multiplier/((uPos.x-point.x)*(uPos.x-point.x) + (uPos.y-point.y)*(uPos.y-point.y))/i;\n\t\tblueGodColor2 += vec3(componentColor/3.0, componentColor/3.0, componentColor);\n\t}\n\t\n\tvec3 redGodColor = vec3(0.0);\n\tfor(float i=1.0;i<loop;i++){\n\t\tfloat t = time*timeSCale-step*i;\n\t\tvec2 point = vec2(0.5*sin(t*4.0+200.0), 0.75*sin(t+10.0));\n\t\tpoint += vec2(0.85*cos(t*2.0), 0.45*sin(t*3.0));\n\t\tpoint /= 2.0;\n\t\tfloat componentColor= multiplier/((uPos.x-point.x)*(uPos.x-point.x) + (uPos.y-point.y)*(uPos.y-point.y))/i;\n\t\tredGodColor += vec3(componentColor, componentColor/3.0, componentColor/3.0);\n\t}\n\t\n\tvec3 greenGodColor = vec3(0.0);\n\tfor(float i=1.0;i<loop;i++){\n\t\tfloat t = time*timeSCale-step*i;\n\t\tvec2 point = vec2(0.75*sin(t*3.0+20.0), 0.45*sin(t*2.0+40.0));\n\t\tpoint += vec2(4.35*cos(t*2.0+100.0), 0.5*sin(t*3.0));\n\t\tpoint /= 11.0;\n\t\tfloat componentColor= multiplier/((uPos.x-point.x)*(uPos.x-point.x) + (uPos.y-point.y)*(uPos.y-point.y))/i;\n\t\tgreenGodColor += vec3(componentColor/3.0, componentColor, componentColor/3.0);\n\t}\n\t\n\tfloat angle = (atan(uPos.y, uPos.x)+PI) / TWOPI;\n\tfloat radius = sqrt(uPos.x*uPos.x + uPos.y*uPos.y);\n\t\n\t\n\t\n\t\n\tvec3 color2 ;\n\tcolor2 *= blueGodColor2+redGodColor+greenGodColor;\n\tcolor2 *= 200.0;\n\tcolor2 += blueGodColor2+redGodColor+greenGodColor;\n   \n   vec2 p = (gl_FragCoord.xy * 3.0 - resolution.xy) / min(resolution.x, resolution.y);\n    p -= vec2(12.0, 0.0);\n\n    float t = 0.0, d;\n\n    float time2 = 1.0;\n\n    vec2 q = vec2(0.0);\n    q.x = fbm(p + 0.01 * time2);\n    q.y = fbm(p + vec2(1.0));\n    vec2 r = vec2(0.0);\n    r.x = fbm(p + 1.0 * q + vec2(1.7, 1.2) + 0.15 * time2);\n    r.y = fbm(p + 1.0 * q + vec2(8.3, 2.8) + 0.126 * time2);\n    float f = fbm(p + r);\n    \n    // DS: hornidev\n    vec3 color3 = mix(\n        vec3(1.0, 1.0, 2.0),\n        vec3(1.0, 1.0, 1.0),\n        clamp((f * f) * 5.5, 1.2, 15.5)\n    );\n\n    color3 = mix(\n        color3,\n        vec3(1.0, 1.0, 1.0),\n        clamp(length(q), 2.0, 2.0)\n    );\n\n    color3 = mix(\n        color3,\n        vec3(0.3, 0.2, 1.0),\n        clamp(length(r.x), 0.0, 5.0)\n    );\n\n    color3 = (f * f * f * 1.0 + 0.5 * 1.7 * 0.0 + 0.9 * f) * color3;\n\n    vec2 uv2 = gl_FragCoord.xy / resolution.xy;\n    float alpha = 50.0 - max(pow(100.0 * distance(uv.x, -1.0), 0.0), pow(2.0 * distance(uv.y, 0.5), 5.0));\n \n\t\n\tvec3 from=vec3(1.,.5,0.5);\ndir+=color*color3;\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\t\n    fragColor*=vec4(color,1.);\n       fragColor+= vec4(color3 * 1.0+color2, 1.);\n}\n\n","name":"Image","description":"","type":"image"}]}