{"ver":"0.1","info":{"id":"DdtGWN","date":"1677280017","viewed":110,"name":"particle squares","username":"grrrwaaa","description":"particle to cube","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["distance","particle"],"hasliked":0,"parentid":"mscGDN","parentname":"particles make voronoi"},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":3,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 OUT, in vec2 P )\n{\n    vec4 a = A(P);\n    vec4 p = B(P);\n    vec4 c = C(P);\n    int cx = int(c.x) % IMG_GRID;\n    int cy = int(c.x) / IMG_GRID; \n    \n    vec2 q = P-p.xy;\n    //p = vec4(R/2., sin(iTime), cos(iTime));\n    \n    float d = max(length(q)-1., 0.);\n    \n    vec2 v = normalize(p.zw);\n    float angle = atan(v.y, v.x);\n    vec2 q1 = rotate2(q, angle);\n    //d = line2(P, p.xy - s*v, p.xy + s*v);\n    \n    float size = 4.;\n    d = box2(q1, vec2(size));\n    //d = orientedBox2(q, vec2(-2.), vec2(2.), atan(v.y, v.x));\n    \n    //d = abs(d);\n    \n    vec2 tc = 0.5 + 0.5*q1/size;\n  \n    \n    //tc = tc/divs + floor(p.w*divs)/divs;\n    float divs = float(IMG_GRID);\n    tc = tc/divs + vec2(cx, cy)/divs;\n    \n    vec3 img = texture(iChannel3, tc).rgb;\n    \n   // img.rg += p.wz* 0.25;\n    \n    \n    float color = clamp(exp(-d * 2.), 0., 1.);\n    \n    float exist = clamp(exp(-d * 2.), 0., 1.);\n    OUT = vec4( img, 1.  )*exist;\n    OUT = pow(OUT, vec4(0.7));\n    \n    //OUT.rgb = a.www * hsl2rgb(vec3(0.25*dot(a.xy, vec2(1,0)), abs(a.z), 0.75));\n    \n    //OUT = c/(divs*divs);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R iResolution.xy\n#define DIM iResolution.xy\n#define A(U) texture(iChannel0, (U)/R)\n#define B(U) texture(iChannel1, (U)/R)\n#define C(U) texture(iChannel2, (U)/R)\n#define D(U) texture(iChannel3, (U)/R)\n\n#define PI 3.14159265359\n\n#define IMG_GRID 16\n\n#define norm(v) ((v)/(length(v)+1e-10))\n\n// distance of pt to 2D line segment from start to end\nfloat line2_b(vec2 pt, vec2 start, vec2 end) {\n    vec2 g = end-start, h = pt-start;\n    return length(h - g*clamp(dot(g,h)/dot(g,g), 0.0, 1.));\n}\n\n// distance from point p to the nearest point on the line a->b\nfloat line2(vec2 p, vec2 a, vec2 b) {\n    // position on line a+tb\n    float t = dot(p-a,b-a)/dot(b-a,b-a); \n    // clamp to line bounds:\n    t = clamp(t,0.,1.);\n    // nearest point:\n    vec2 n = a + t*(b-a);\n    // distance to that point:\n\treturn length(p-n);\n}\n\nfloat circle2( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat box2( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat orientedBox2( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nvec2 rotate2(vec2 p, float a) {\n    float sine = sin(a), cosine = cos(a);\n    return vec2(cosine * p.x + sine * p.y, cosine * p.y - sine * p.x);\n}\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 hash2( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n// a deterministic random number generator\nvec4 hash (float p) // Dave (Hash)kins\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx)*2.-1.;\n    \n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n// Important details:\n// - field here represents nearest particle (.xy = pos, .w = species, .y unused)\n// - the way particles advect is from a blend between real particle position and pixel position; \n//   this affects rate of particle creation/destruction\n// - there's a test for when the particles became stable, and an event to change species at this point;\n//   this keeps the churn moving, since difference in the hormone field will cause fluid velocity\n// - new species here is always determinstic: species A will always lead to species B\n\n// a trick to do continuous float positions on a pixel grid:\n// let each pixel refer to the nearest particle, storing the continuous position in .xy\n// it works so long as the particles are never nearer than one pixel to each other\n// (in that case a particle can die)\n\n// effectively several pixels may compute results for one pixel\n\n// field B represents the nearest particle to our pixel\n// B.xy is the actual particle position\n\nvoid swap (inout vec4 p, vec2 P, vec2 r) {\n    // Q is our current estimated nearest particle\n    // n is the particle at a pixel nearby\n\tvec4 n = B(P+r); \n    // if n is closer to our pixel coordinate, pick that one instead (via Q=n)\n    if (length(P-n.xy) < length(P-p.xy)) p = n;\n}\n\nvoid mainImage( out vec4 OUT, in vec2 P) {\n\n    float spd = 100.*iTimeDelta;\n\n    // FIND NEAREST PARTICLE\n    vec4 p = B(P);\n    // in each axis consider a couple of steps:\n    // if particle.xy there is actually closer to our pixel, use that particle instead\n    if (true) {\n        int d = 2;\n        for (int y=-d; y<=d; y++) {\n            for (int x=-d; x<d; x++) {\n                vec4 n = B(P+vec2(x, y));\n                if (length(P-n.xy) < length(P-p.xy)) p = n;\n            }\n        }\n    } else {\n        // cheaper but less accurate version:\n        swap(p,P,vec2(1,0));\n        swap(p,P,vec2(0,1));\n        swap(p,P,vec2(-1,0));\n        swap(p,P,vec2(0,-1));\n        swap(p,P,vec2(2,2));\n        swap(p,P,vec2(2,-2));\n        swap(p,P,vec2(-2,2));\n        swap(p,P,vec2(-2,-2));\n    }\n    // now we have our nearest particle `p`\n    \n \n    \n    // advect the particle \n    vec2 vel = p.zw;\n    \n    vel = mix(vel, A(p.xy).xy, 0.01);\n    \n    p.zw = vel;\n    \n    p.xy += vel * spd;\n    \n    //p.zw = rotate2(p.zw, 0.01);\n    \n       // is it too far?\n    if (length(P-p.xy) > 50.) {\n        p.xy = P;\n       p.zw = D(P).xy - 0.5;\n    }\n    \n    // BOUNDARY CONDITIONS\n    if ((iMouse.z>0.&&length(iMouse.xy-P)<30.)) {\n       p.xy = P;\n       p.zw = D(P).xy - 0.5;\n    }\n    \n    // BOUNDARY CONDITIONS\n    if (iFrame % 4800 == 0) {\n       p.xy = P;\n       p.zw = D(P).xy-0.5;\n    }\n    \n    OUT = p;\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// back project along the vector field to guess where we were previously:\nvec2 prev(vec2 coord) {\n    coord -= A(coord).xy*0.5;\n    coord -= A(coord).xy*0.5;\n    return coord;\n}\n\nvoid mainImage( out vec4 OUT, in vec2 P )\n{\n    float id = P.y * R.x + P.x;\n    \n    OUT = C(prev(P));\n    \n    \n    \n    //vec2 vel = vel = A(p.xy).xy;\n    //p.xy += vel * SPD;\n    \n    \n    if (int(iFrame) == 0 || int(iFrame) % int(R.x * R.y) == int(id)) {\n        OUT = vec4( mod(P.y * R.x + P.x, float(IMG_GRID*IMG_GRID)) );\n        \n        OUT = vec4( mod(hash2(P).x, float(IMG_GRID*IMG_GRID)) ); \n    }\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// back project along the vector field to guess where we were previously:\nvec4 prev(vec2 coord) {\n    coord -= A(coord).xy*0.5;\n    coord -= A(coord).xy*0.5;\n    return A(coord);\n}\n\nvoid mainImage( out vec4 OUT, in vec2 COORD )\n{\n    OUT = vec4(0);\n    \n    // past neighborhood states (per flow)\n    vec4 p = prev(COORD),\n         n = prev(COORD + vec2( 0, 1)),\n         s = prev(COORD + vec2( 0,-1)),\n         e = prev(COORD + vec2( 1, 0)),\n         w = prev(COORD + vec2(-1, 0));\n    // diffused past:\n    vec4 avg = (n+s+e+w)*0.25;\n    // ordered difference in the pressure/convergence/disorder (A.z) \n    // creates velocity in me (OUT.xy)\n    vec2 force = -0.25*vec2(e.z-w.z, n.z-s.z);\n    // new velocity derived from neighbourhood average\n    // should this be p.xy rather than avg.xy?\n    // either the velocity or the pressure should be diffused, but not both\n    float blend = 0.;  // I like blend=0 more, it gives more turbulence; 1 is more smoky\n    //OUT.xy = avg.xy + force;\n    OUT.xy = mix(p.xy, avg.xy, blend) + force; \n    \n    // variance in the velocity (A.xy) near me creates pressure/convergence/disorder in me\n    float press = -0.25*(e.x + n.y - w.x - s.y);\n    // should this be avg.z rather than p.z  ?\n    //OUT.z = p.z + press;\n    OUT.z = mix(avg.z, p.z, blend) + press;\n    \n    /*\n        This whole thing about bouncing energy between the velocity and pressure reminds me of scatter junctions in physical models!\n    */\n    \n    // mass transport\n    float transport = -0.25*(e.x*e.w - w.x*w.w + n.y*n.w - s.y*s.w);\n    // can mix between p.w and avg.w here to allow general diffusion of mass\n    // slightly unrealistic in that this can result in negative mass\n    OUT.w = mix(p.w, avg.w, 0.) + transport;\n    \n    // optional add forces\n    float d = line2(COORD, DIM/2. - DIM.y*0.2* vec2(sin(iTime*0.2),cos(iTime*0.2)), DIM/2. + DIM.y*0.4* vec2(sin(iTime*.1618),cos(iTime*.1618)));\n    if (d < 1.) {\n        //OUT = vec4(cos(iTime*PI), sin(iTime*PI), 0, 1);\n    }\n    if (iMouse.z > 0. && length(iMouse.xy - COORD) < 4.) {\n        OUT = vec4(COORD/DIM - 0.5, 0., 1.);\n    }\n    \n    vec4 particle = B(COORD);\n    OUT.xy += 0.01*particle.zw;\n    \n    // optional decays\n    // xy or z, don't need to do both\n    OUT.xy *= 0.999;\n    //OUT.z *= 0.9999;\n    //OUT.w *= 0.999;\n    \n    // boundary:\n    float b = 4.;\n    if (iFrame % 4800 == 0 || COORD.x < b || COORD.y < b || DIM.x-COORD.x < b || DIM.y-COORD.y < b) {\n        OUT = vec4(0);\n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"}]}