{"ver":"0.1","info":{"id":"X3fBWr","date":"1728268562","viewed":54,"name":"pixel art hourglass ","username":"noobdawn","description":"a simple hourglass","likes":10,"published":3,"flags":32,"usePreview":0,"tags":["2d","pixelart"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n    vec2 uv;\n    int frameInCycle = iFrame % FLIP_CYCLE_FRAMES;\n    {\n        uv = fragCoord.xy / iResolution.xy - vec2(0.5);\n        uv.x *= iResolution.x / iResolution.y;\n        if (frameInCycle > FLIP_CYCLE_FRAMES - ROTATE_FRAMES)\n        {\n            frameInCycle = frameInCycle - (FLIP_CYCLE_FRAMES - ROTATE_FRAMES);\n            uv = rotate(uv, float(frameInCycle) * PI / float(ROTATE_FRAMES));      \n        }\n        uv.x /= iResolution.x / iResolution.y;\n        uv += vec2(0.5);\n    }\n    fragColor = texture(iChannel0, uv);\n    bool wall = isWall(fragColor);\n    bool sand = isSand(fragColor);\n    bool collider = isCollider(fragColor);\n    \n    if (wall)\n        fragColor = vec4(vec3(0.95), 1.0);\n    if (sand)\n        fragColor = vec4(0.9, 0.7, 0.0, 1.0);\n    if (!collider)\n        fragColor = vec4(vec3(0.3), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n\n// 这里是将图片转义为数组\nbool[] sand_array = bool[](\n        false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,\n        false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,\n        false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,\n        false,  false,  true,   true,   true,   true,   true,   true,   true,   true,   true,   false,  false,\n        false,  false,  true,   true,   true,   true,   true,   true,   true,   true,   true,   false,  false,\n        false,  false,  false,  true,   true,   true,   true,   true,   true,   true,   false,  false,  false,\n        false,  false,  false,  false,  true,   true,   true,   true,   true,   false,  false,  false,  false,\n        false,  false,  false,  false,  false,  true,   true,   true,   false,  false,  false,  false,  false,\n        false,  false,  false,  false,  false,  false,  true,   false,  false,  false,  false,  false,  false,\n        false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,\n        false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,\n        false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,\n        false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,\n        false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,\n        false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,\n        false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,\n        false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,\n        false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,\n        false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,\n        false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,\n        false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,\n        false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false\n);\nbool[] wall_array = bool[](\n        true,   true,   true,   true,   true,   true,   true,   true,   true,   true,   true,   true,   true,\n        true,   false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  true,\n        true,   true,   true,   true,   true,   true,   true,   true,   true,   true,   true,   true,   true,\n        false,  true,   false,  false,  false,  false,  false,  false,  false,  false,  false,  true,   false,\n        false,  true,   false,  false,  false,  false,  false,  false,  false,  false,  false,  true,   false,\n        false,  true,   false,  false,  false,  false,  false,  false,  false,  false,  false,  true,   false,\n        false,  true,   false,  false,  false,  false,  false,  false,  false,  false,  false,  true,   false,\n        false,  true,   true,   false,  false,  false,  false,  false,  false,  false,  true,   true,   false,\n        false,  false,  true,   true,   false,  false,  false,  false,  false,  true,   true,   false,  false,\n        false,  false,  false,  true,   true,   false,  false,  false,  true,   true,   false,  false,  false,\n        false,  false,  false,  false,  true,   true,   false,  true,   true,   false,  false,  false,  false,\n        false,  false,  false,  false,  true,   true,   false,  true,   true,   false,  false,  false,  false,\n        false,  false,  false,  true,   true,   false,  false,  false,  true,   true,   false,  false,  false,\n        false,  false,  true,   true,   false,  false,  false,  false,  false,  true,   true,   false,  false,\n        false,  true,   true,   false,  false,  false,  false,  false,  false,  false,  true,   true,   false,\n        false,  true,   false,  false,  false,  false,  false,  false,  false,  false,  false,  true,   false,\n        false,  true,   false,  false,  false,  false,  false,  false,  false,  false,  false,  true,   false,\n        false,  true,   false,  false,  false,  false,  false,  false,  false,  false,  false,  true,   false,\n        false,  true,   false,  false,  false,  false,  false,  false,  false,  false,  false,  true,   false,\n        true,   true,   true,   true,   true,   true,   true,   true,   true,   true,   true,   true,   true,\n        true,   false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  false,  true,\n        true,   true,   true,   true,   true,   true,   true,   true,   true,   true,   true,   true,   true\n);\n\nfloat IMG_WIDTH = 13.0;\nfloat IMG_HEIGHT = 22.0;\n\nfloat BLOCK_SIZE = 4.0;\nfloat PIXEL_SIZE = 4.0;\n\nint FLIP_CYCLE_FRAMES = 540; \n// when block_size = 4, cost 480 frames\nint ROTATE_FRAMES = 60;\n\nbool isSand(in vec4 color)\n{\n    return color.y == 1.0;\n}\n\nbool isWall(in vec4 color)\n{\n    return color.x == 1.0;\n}\n\nbool isCollider(in vec4 color)\n{\n    return isSand(color) || isWall(color);\n}\n\nvec2 rotate(in vec2 v, in float a)\n{\n    return vec2(cos(a) * v.x - sin(a) * v.y, sin(a) * v.x + cos(a) * v.y);\n}\n\nvec4 sandColor = vec4(0.0, 1.0, 0.0, 1.0);\nvec4 voidColor = vec4(0.0);\nvec4 wallColor = vec4(1.0, 0.0, 0.0, 1.0);\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0)\n    {\n        fragColor = voidColor;\n        fragCoord.x -= 7.0;\n        if ((fragCoord.x < IMG_WIDTH - 7.0) && (fragCoord.y < IMG_HEIGHT))\n        {\n            bool wall = wall_array[int(fragCoord.x + fragCoord.y * IMG_WIDTH)];\n            bool sand = sand_array[int(fragCoord.x + fragCoord.y * IMG_WIDTH)];\n            if (sand)\n                fragColor = sandColor;\n            if (wall)\n                fragColor = wallColor;\n        }\n    }\n    else if (iFrame == 1)\n    {\n        vec2 uv = fragCoord.xy / iResolution.xy;\n        uv /= iResolution.xy / vec2(IMG_WIDTH, IMG_HEIGHT);\n        fragColor = texture(iChannel0, uv);\n    }\n    else if (iFrame == 2)\n    {\n        vec2 uv = fragCoord.xy / iResolution.xy;\n        uv.y = 1.0 - uv.y;\n        fragColor = texture(iChannel0, uv);    \n    }\n    else if (iFrame == 3)\n    {\n        vec2 iFragCoord = floor(fragCoord / PIXEL_SIZE) * PIXEL_SIZE;\n        vec2 center = iResolution.xy / 2.0;\n        float scaledHWidth = IMG_WIDTH * PIXEL_SIZE * BLOCK_SIZE / 2.0;\n        float scaledHHeight = IMG_HEIGHT * PIXEL_SIZE * BLOCK_SIZE / 2.0;\n        if (iFragCoord.x < center.x - scaledHWidth || iFragCoord.x > center.x + scaledHWidth ||\n            iFragCoord.y < center.y - scaledHHeight || iFragCoord.y > center.y + scaledHHeight)\n        {\n            fragColor = vec4(0.0);\n            return;\n        }\n        vec2 uv = (iFragCoord - center + vec2(scaledHWidth, scaledHHeight)) / vec2(scaledHWidth * 2.0, scaledHHeight * 2.0);\n        fragColor = texture(iChannel0, uv);\n    }\n    else\n    {\n        vec2 uv = fragCoord.xy / iResolution.xy;\n        fragColor = texture(iChannel0, uv);     \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"bool getSand(in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n    return isSand(color);\n}\n\nbool getCollider(in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n    return isCollider(color);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // FLIP\n    if (iFrame % FLIP_CYCLE_FRAMES == 0)\n        fragCoord.y = iResolution.y - fragCoord.y;\n    vec2 iFragCoord = floor(fragCoord / PIXEL_SIZE) * PIXEL_SIZE + vec2(0.5, 0.5) * PIXEL_SIZE;\n    vec2 uv = iFragCoord / iResolution.xy;\n    vec4 color;\n    if (iFrame >= 4)\n    {\n        \n    \n        color = texture(iChannel0, uv);\n        bool wall = isWall(color);\n        bool sand = isSand(color);\n        bool collider = isCollider(color);\n        fragColor = color;\n        \n        if (!collider)\n        {\n            vec2 up = iFragCoord + vec2(0.0, PIXEL_SIZE);\n            bool upSand = getSand(up);\n            if (upSand)\n                fragColor = sandColor;\n        }\n        else if (sand)\n        {\n            vec2 down = iFragCoord + vec2(0.0, -PIXEL_SIZE);\n            bool downCollider = getCollider(down);\n            if (!downCollider)\n                fragColor = voidColor;\n        }\n    }\n    else\n    {\n        color = texture(iChannel1, uv);\n        fragColor = color;\n    }\n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"bool getSand(in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n    return isSand(color);\n}\n\nbool getCollider(in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n    return isCollider(color);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 iFragCoord = floor(fragCoord / PIXEL_SIZE) * PIXEL_SIZE + vec2(0.5, 0.5) * PIXEL_SIZE;\n    vec2 uv = iFragCoord / iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n    bool wall = isWall(color);\n    bool sand = isSand(color);\n    bool collider = isCollider(color);\n    float odd = iFrame % 2 == 0 ? 1.0 : -1.0;\n    if (sand)\n    {\n        vec2 down = fragCoord + vec2(0.0, -1.0) * PIXEL_SIZE;\n        vec2 downSide = fragCoord + vec2(-odd, -1.0) * PIXEL_SIZE;\n        bool downCollider = getCollider(down);\n        bool downSideCollider = getCollider(downSide);\n        if (downCollider && !downSideCollider)\n            sand = false;\n    }\n    if (!collider)\n    {\n        fragColor = vec4(0.0, 0.0, 1.0, 0.0);\n        vec2 upSide = fragCoord + vec2(odd, 1.0) * PIXEL_SIZE;\n        vec2 side = fragCoord + vec2(odd, 0.0) * PIXEL_SIZE;\n        bool upSideSand = getSand(upSide);\n        bool sideCollider = getCollider(side);\n        if (upSideSand && sideCollider)\n            sand = true;\n    }\n    \n    fragColor = voidColor;\n    if (sand)\n        fragColor = sandColor;\n    if (wall)\n        fragColor = wallColor;\n}","name":"Buffer C","description":"","type":"buffer"}]}