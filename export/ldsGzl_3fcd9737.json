{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Hazel Quantock - 23/08/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Adjust the amount of blur (this will accept ridiculous values)\nconst float shutterDuration = 1.0/200.0;\n\n\n// Adjust the quality of blur (some GPUs will struggle)\n//const int blurSteps = 1;\n\n\n\nvec2 Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n//\tvec3 f2 = f*f; f = f*f2*(10.0-15.0*f+6.0*f2);\n\n\t// there's an artefact because the y channel almost, but not exactly, matches the r channel shifted (37,17)\n\t// this artefact doesn't seem to show up in chrome, so I suspect firefox uses different texture compression.\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec4 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 );\n\treturn mix( rg.yw, rg.xz, f.z );\n}\n\nvec4 Noise( in vec2 x )\n{\n    vec2 p = floor(x.xy);\n    vec2 f = fract(x.xy);\n\tf = f*f*(3.0-2.0*f);\n//\tvec3 f2 = f*f; f = f*f2*(10.0-15.0*f+6.0*f2);\n\n\t// there's an artefact because the y channel almost, but not exactly, matches the r channel shifted (37,17)\n\t// this artefact doesn't seem to show up in chrome, so I suspect firefox uses different texture compression.\n\tvec2 uv = p.xy + f.xy;\n\treturn textureLod( iChannel0, (uv+0.5)/256.0, 0.0 );\n}\n\n\n\nvec3 Voronoi( vec3 pos )\n{\n\tvec3 d[8];\n\td[0] = vec3(0,0,0);\n\td[1] = vec3(1,0,0);\n\td[2] = vec3(0,1,0);\n\td[3] = vec3(1,1,0);\n\td[4] = vec3(0,0,1);\n\td[5] = vec3(1,0,1);\n\td[6] = vec3(0,1,1);\n\td[7] = vec3(1,1,1);\n\t\n\tconst float maxDisplacement = .7;//.518; //tweak this to hide grid artefacts\n\t\n    vec3 pf = floor(pos);\n\n    const float phi = 1.61803398875;\n\n\tfloat closest = 12.0;\n\tvec3 result;\n\tfor ( int i=0; i < 8; i++ )\n\t{\n        vec3 v = (pf+d[i]);\n\t\tvec3 r = fract(phi*v.yzx+17.*fract(v.zxy*phi)+v*v*.03);//Noise(ivec3(floor(pos+d[i])));\n\t\tvec3 p = d[i] + maxDisplacement*(r.xyz-.5);\n\t\tp -= fract(pos);\n\t\tfloat lsq = dot(p,p);\n\t\tif ( lsq < closest )\n\t\t{\n\t\t\tclosest = lsq;\n\t\t\tresult = r;\n\t\t}\n\t}\n\treturn fract(result.xyz);//+result.www); // random colour\n}\n\n// camera function by TekF\n// compute ray from camera parameters\nvec3 GetRay( vec3 dir, float zoom, vec2 uv )\n{\n\tuv = uv - .5;\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n\tdir = zoom*normalize(dir);\n\tvec3 right = normalize(cross(vec3(0,1,0),dir));\n\tvec3 up = normalize(cross(dir,right));\n\t\n\treturn normalize(dir + right*uv.x + up*uv.y);\n}\n\n\nvec3 Sky( vec3 rayDir )\n{\n\t//return vec4(.1,.1,.2,1);\n\t\n\tfloat horizon = rayDir.y - .1*Noise(rayDir.xz*4.0).x;\n\t\n\treturn mix( vec3(1), vec3(0), fract(horizon*.7) );\n}\n\n\nconst vec3 carDims = vec3(.9,.72,2.4);\n\nfloat CarIsosurface( vec3 pos )\n{\n\tconst float smoothing = .1;\n\t\n\treturn\n\t\tlog(\n\t\t\t// intersection\n\t\t\texp((-pos.y-carDims.y)/smoothing)\n\t\t\t+ exp((pos.x-carDims.x)/smoothing)\n\t\t\t+ exp((-pos.x-carDims.x)/smoothing)\n\t\t\t+ 1.0/(\n\t\t\t\t// union\n\t\t\t\texp(-(length(pos-vec3(0,carDims.y-2.0,-.5))-2.0)/smoothing)\n\t\t\t\t+ 1.0/(\n\t\t\t\t\t// intersection\n\t\t\t\t\texp((dot(pos,vec3(0,.9992,.04))-0.2)/smoothing)\n\t\t\t\t\t+ exp((dot(pos,vec3(0,.93675,.35))-.8)/smoothing)\n\t\t\t\t\t+ exp((pos.z-carDims.z)/smoothing)\n\t\t\t\t\t+ exp((-pos.z-carDims.z)/smoothing)\n\t\t\t\t)\n\t\t\t)\n\t\t)*smoothing;\n}\n\nvec3 CarNormal( vec3 pos )\n{\n\tconst vec2 delta = vec2(.01, 0);\n\t\n\tvec3 n;\n\n// it's important this is centred on the pos, it fixes a lot of errors\n\tn.x = CarIsosurface( pos + delta.xyy ) - CarIsosurface( pos - delta.xyy );\n\tn.y = CarIsosurface( pos + delta.yxy ) - CarIsosurface( pos - delta.yxy );\n\tn.z = CarIsosurface( pos + delta.yyx ) - CarIsosurface( pos - delta.yyx );\n\treturn normalize(n);\n}\t\t\t\t\n\n\nvec3 CarShading( vec3 pos, vec3 norm, vec3 rayDir, vec3 paint )\n{\n\tvec3 lightDir = normalize(vec3(-3,2,1));\n\n\tvec3 norm2 = normalize(norm+.3*(Voronoi(pos*100.0)*2.0-1.0));\n\t\n\tif ( dot(norm2,rayDir) > 0.0 ) // we shouldn't see flecks that point away from us\n\t\tnorm2 -= 2.0*dot(norm2,rayDir)*rayDir;\n\n\n\t// diffuse layer, reduce overall contrast\n\tvec3 result = paint*.6*(pow(max(0.0,dot(norm,lightDir)),2.0)+.2);\n\n\tvec3 h = normalize( lightDir-rayDir );\n\tvec3 s = pow(max(0.0,dot(h,norm2)),50.0)*10.0*vec3(1);\n\n\tfloat rdotn = dot(rayDir,norm2);\n\tvec3 reflection = rayDir-2.0*rdotn*norm;\n\ts += Sky( reflection );\n\n\tfloat f = pow(1.0+rdotn,5.0);\n\tf = mix( .2, 1.0, f );\n\t\n\tresult = mix(result,paint*s,f);\n\t\n\t// gloss layer\n\ts = pow(max(0.0,dot(h,norm)),1000.0)*32.0*vec3(1);\n\t\n\trdotn = dot(rayDir,norm);\n\treflection = rayDir-2.0*rdotn*norm;\n\t\n\ts += Sky( reflection );\n\t\n\tf = pow(min(1.0,1.0+rdotn),5.0);\n\tf = mix( .03, 1.0, f );\n\treturn mix(result, s, f);\n}\n\n\nvec4 Car( vec3 rayStart, vec3 rayDir, vec3 paint, vec3 carPos )\n{\n\tconst float wheelRadius = .3;\n\tfloat wheelRot = carPos.z/wheelRadius;\n\n\tcarPos.y = -1.0+carDims.y; // road is at -1\n\t\n\tvec3 rs = rayStart-carPos;\n\t\n\tfloat d = dot(rs,rayDir);\n\tvec3 perp = rs - rayDir*d;\n\t\n\tconst float radius = 2.6625;//length(dim); <- this doesn't work!?\n\t\n\t// test bounding sphere\n//this is culling car in the close-ups\n//\tif ( d > -radius || length(perp) > radius )\n//\t\treturn vec4(0);\n\n\t// test bounding box\n\tvec3 a = abs((carDims+vec3(.05))/rayDir);\n\tvec3 b = (rs)/rayDir;\n\tvec3 front = -a-b;\n\tvec3 back = a-b;\n\t\n\tfloat t = max(front.x,max(front.y,front.z));\n\tfloat tb = min(back.x,min(back.y,back.z));\n\t\n\tif ( tb < 0.0 || t > tb )\n\t\treturn vec4(0);\n\t\n\tt = max(0.0,t);\n\t\n\t// ray march within the volume\n\tvec3 p = t*rayDir+rs;\n\t\n\tfloat h = 1.0;\n\tt = 0.0;\n\tfor ( int i=0; i < 50; i++ )\n\t{\n\t\tif ( h < .01 || t > tb )\n\t\t\tcontinue;\n\t\th = CarIsosurface(p+t*rayDir);\n\t\tt += h;\n\t}\n\t\n\tif ( /*h > .1 ||*/ t > tb || t < 0.0 )\n\t\treturn vec4(0);\n\t\n\tp += t*rayDir;\n\t\n\t\n\t// shading\n\tvec3 norm = CarNormal(p);\n\n\treturn vec4(CarShading( p, norm, rayDir, paint ),1);\n}\n\n\nvec4 Road( vec3 rayStart, vec3 rayDir, vec3 roadPos, vec3 roadDir )\n{\n\t// ray trace in 2D against cross-section of road\n\troadDir = normalize(roadDir);\n\trayStart -= roadPos;\n\t\n\tvec3 rs, rd;\n\trs.z = dot(roadDir,rayStart);\n\trd.z = dot(roadDir,rayDir);\n\t\n\trayStart -= roadDir*rs.z;\n\trayDir -= roadDir*rd.z;\n\t\n\tvec3 perp = cross( roadDir, vec3(0,1,0) );\n\n\trs.xy = vec2( sign(dot(perp.xz,rayStart.xz))*length(rayStart.xz), rayStart.y );\n\trd.xy = vec2( sign(dot(perp.xz,rayDir.xz))*length(rayDir.xz), rayDir.y );\n\n\t// find intersection\n\tfloat t = -rs.y/rd.y;\n\t\n\tif ( t < 0.0 )\n\t\treturn vec4(0);\n\t\n\tvec3 p = t*rd+rs;\n\n\tif ( abs(p.x) > 11.0 )\n\t\treturn vec4(0);\n\t\n\t// white lines\n\tif ( (abs(p.x) < .1 || abs(p.x-5.0) < .1 || abs(p.x+5.0) < .1) && fract(p.z/3.0) < .66 )\n\t\treturn vec4(1,1,1,1);\n\n\t// yellow lines\n\tif ( abs(abs(p.x)-10.0) < .1 )\n\t\treturn vec4(1,.9,0,1);\n\n\t// diagonals\n\tif ( abs(p.x-7.5) < 2.0 && fract((p.x+p.z)/5.0) < .1 )\n\t\treturn vec4(1);\n\t\n\treturn vec4( mix( vec3(.1), vec3(.2), Noise(p).x ), 1 );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 sum = vec4(0);\n\t\n\t//for ( int blur=0; blur < blurSteps; blur++ )\n\t{\n\t\tfloat time = iTime;// + ((Noise( ivec2(fragCoord.xy) ).x/*+float(blur))/float(blurSteps*/))*shutterDuration;\n\t\t\n\t\t// loop the animation\n\t\ttime = fract(time/22.0)*22.0;\n\t\t\n\t\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\t\n\t\tvec3 car1Pos = vec3(-4.0,0,-40.0+time*80.0);\n\t\tvec3 car2Pos = vec3(cos(time/1.0)*3.0,0,-20.0+time*80.0-12.0*sin(time/3.0));\n\t\n\t\tvec3 camPos, camDir;\n\t\tfloat camZoom;\n\t\tif ( time < 2.5 )\n\t\t{\n\t\t\tfloat camAnim = smoothstep(0.0,2.0,time);\n\t\t\tcamPos = vec3(-10,1,0)+vec3(-1,1,0)*camAnim;//20.0+time*50.0);\n\t\t\tcamDir = vec3(1,-.4,.5+.5*camAnim);\n\t\t\t//vec3 camLook = vec3(0,0,-30.0+time*76.0);\n\t\t\t//camDir = camLook-camPos;\n\t\t\tcamZoom = 1.0;\n\t\t}\n\t\telse if ( time < 6.5 )\n\t\t{\n\t\t\tcamPos = car1Pos+vec3(0,.0,1);\n\t\t\t//camDir = vec3(0,0,1);\n\t\t\tvec3 camLook = car2Pos+vec3(0,0,4);\n\t\t\tcamDir = camLook-camPos;\n\t\t\tcamZoom = 1.0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvec3 camLook = car1Pos;\n\t\t\t//camPos = camLook+mix(vec3(-carDims.x-.8,.2,.4),vec3(0,-.1,3),smoothstep(6.5,12.0,time));\n\t\t\tcamPos = camLook+vec3(cos(time/5.0),0,sin(time/5.0))*vec3(2.5,1,4.0);\n\t\t\tcamDir = camLook-camPos+vec3(0,-.3,1.5);\n\t\t\tcamZoom = mix(1.0,2.0,smoothstep(13.0,14.0,time));\n\t\t}\n\n// debug, watch the lead cars\n//camDir = -vec3(0,20,-40); camPos = vec3(0.0,0,-40.0+time*82.0) - camDir;\n\t\t\n\t\n\t\tvec3 rayDir = GetRay( camDir, camZoom, uv );\n\t\t\n\t\tvec4 result = vec4(0);\n\t\n\t\t// test things in strict depth order, so we can early-out\n/*\t\tif ( result.a < .99 )\n\t\t\tresult = Car( camPos, rayDir, vec3(.7,.3,1), vec3(-2.0,0,-160.0+time*76.0) );\n\t\t\n\t\tif ( result.a < .99 )\n\t\t\tresult = Car( camPos, rayDir, vec3(1,0,0), vec3(2.0,0,-100.0+time*78.0) );\n*/\t\t\n\t\tif ( result.a < .99 )\n\t\t\tresult = Car( camPos, rayDir, vec3(1,.1,.05), car1Pos );\n\t\t\n\t\tif ( result.a < .99 )\n\t\t\tresult = Car( camPos, rayDir, vec3(.2,.1,1), car2Pos ); //vec3(1,.9,.1)\n\t\t\n/*\t\tif ( result.a < .99 )\n\t\t\tresult = Car( camPos, rayDir, vec3(.2,0,.7), vec3(4.0,0,-40.0+time*80.0-20.0*cos(time/2.1)) );*/\n\t\t\n\t\tif ( result.a < .99 )\n\t\t\tresult = Road( camPos, rayDir, vec3(0,-1,0), vec3(0,0,1) );\n\t\n\t\tif ( result.a < .99 )\n\t\t\tresult = Road( camPos, rayDir, vec3(30,-1,0), vec3(0,0,-1) );\n\t\n\t\tif ( result.a < .99 )\n\t\t\tresult = Road( camPos, rayDir, vec3(0,-5,30), vec3(1,0,0) );\n\t\n\t\tif ( result.a < .99 )\n\t\t\tresult = Road( camPos, rayDir, vec3(0,-5,0), vec3(-1,0,0) );\n\t\n\t\tif ( result.a < .99 )\n\t\t\tresult = vec4(Sky( rayDir ),1);\n\t\t\n\t\tsum += result;\n\t}\n\n\tfragColor = sum;// /float(blurSteps);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldsGzl","date":"1377483583","viewed":1966,"name":"Metallic paint","username":"TekF","description":"Combining my fast voronoi with my \"race\" shader and isosurfaces.\nNow they just need windows and wheels...","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raymarching","voronoi","motionblur"],"hasliked":0,"parentid":"","parentname":""}}