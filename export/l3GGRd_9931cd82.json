{"ver":"0.1","info":{"id":"l3GGRd","date":"1718059514","viewed":58,"name":"Fractals Explorer ","username":"saxha","description":"3 fractals","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbrot","burningship","render"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MANDELBROT_SET (z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c)\n#define BURNING_SHIP (z = vec2(z.x*z.x - z.y*z.y, abs(2.0*z.x*z.y)) + (c*vec2(1., -1.)))\n#define TRICORN (z = vec2(z.x*z.x - z.y*z.y, -2.0*z.x*z.y) + c)\n\n#define FRACTAL BURNING_SHIP\n\n#define ABS_OUT (abs(z.x*z.y) > 16.0)\n#define DIVERGENCE (dot(z, z) > 4.0)\n#define CONVERGENCE (length(z - zn_s_1) < 0.001)\n#define DIVERGENCE_CONVERGENCE (DIVERGENCE || CONVERGENCE)\n#define ALL_OUT (CONVERGENCE || ABS_OUT)\n\n#define OUT ALL_OUT\n\n// Convert HEX color, to vec3 color\nvec3 hexToColor(int hex) {\n    float r = float((hex >> 16) & 0xFF) / 255.0;\n    float g = float((hex >> 8) & 0xFF) / 255.0;\n    float b = float(hex & 0xFF) / 255.0;\n    return vec3(r, g, b);\n}\n\n\n// Function to generate a color from a distance\nvec3 palette(float dist, vec3 interior, vec3[8] exterior) {\n    if (dist == 1.0) {\n        return interior;\n    }\n\n    float index = mod(dist * 7.0, 7.0);\n    int i = int(floor(index));\n    float t = fract(index);\n\n    vec3 color = mix(exterior[i], exterior[i+1], t);\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized coordinates\n    vec2 uv = fragCoord / iResolution.y;\n    \n    // Mapping the coordinates\n    vec2 c = uv - vec2(1.5, 0.5);\n    \n    // Parameters\n    vec2 position = vec2(-0.5, 0.0); // Center position\n    float scale = 0.2; // Zoom\n    \n    if (iMouse.z > 0.0) {\n        scale *= 30.;\n        vec2 m = iMouse.xy / iResolution.xy;\n        m = 1.-m;\n        m += vec2(-0.55, -0.5);\n        position = m * (scale*4.5);\n    }\n    \n    // Applying position and scale parameters\n    c = (c - position) / scale;\n    \n    vec2 z = vec2(0.0);\n    vec2 zn_s_1 = vec2(0.0);\n    float iter = 0.0;\n    float maxIter = 100.0;\n    \n    // Fractal algorithm\n    for(int i = 0; i < int(maxIter); i++) {\n        zn_s_1 = z;\n        FRACTAL;\n        if(OUT) {\n            break;\n        }\n        iter++;\n    }\n    \n    // Palette\n    float iterations = float(iter) / maxIter;\n    vec3 interior;\n    vec3 exterior[8];\n    interior = vec3(0.0);\n    exterior[0] = hexToColor(0xf0b6ad);\n    exterior[1] = hexToColor(0xdc8864);\n    exterior[2] = hexToColor(0xba4848);\n    exterior[3] = hexToColor(0xc75a1b);\n    exterior[4] = hexToColor(0xf7c435);\n    exterior[5] = hexToColor(0x818b2e);\n    exterior[6] = hexToColor(0x0b5227);\n    exterior[7] = hexToColor(0x85a993);\n    \n    vec3 col = palette(iterations, interior, exterior);\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}