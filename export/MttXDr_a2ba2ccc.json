{"ver":"0.1","info":{"id":"MttXDr","date":"1479160997","viewed":163,"name":"Rolled","username":"vapoi","description":"just playing around","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","simple","noisy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float fPi = 3.14159;\n\n\n// Noise part:\n    //\n    // GLSL textureless classic 2D noise \"cnoise\",\n    // with an RSL-style periodic variant \"pnoise\".\n    // Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n    // Version: 2011-08-22\n    //\n    // Many thanks to Ian McEwan of Ashima Arts for the\n    // ideas for permutation and gradient selection.\n    //\n    // Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n    // Distributed under the MIT license. See LICENSE file.\n    // https://github.com/ashima/webgl-noise\n    //\n\n    vec4 mod289(vec4 x)\n    {\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n\n    vec4 permute(vec4 x)\n    {\n      return mod289(((x*34.0)+1.0)*x);\n    }\n\n    vec4 taylorInvSqrt(vec4 r)\n    {\n      return 1.79284291400159 - 0.85373472095314 * r;\n    }\n\n    vec2 fade(vec2 t) {\n      return t*t*t*(t*(t*6.0-15.0)+10.0);\n    }\n\n    // Classic Perlin noise\n    float cnoise(vec2 P)\n    {\n      vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n      vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n      Pi = mod289(Pi); // To avoid truncation effects in permutation\n      vec4 ix = Pi.xzxz;\n      vec4 iy = Pi.yyww;\n      vec4 fx = Pf.xzxz;\n      vec4 fy = Pf.yyww;\n\n      vec4 i = permute(permute(ix) + iy);\n\n      vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n      vec4 gy = abs(gx) - 0.5 ;\n      vec4 tx = floor(gx + 0.5);\n      gx = gx - tx;\n\n      vec2 g00 = vec2(gx.x,gy.x);\n      vec2 g10 = vec2(gx.y,gy.y);\n      vec2 g01 = vec2(gx.z,gy.z);\n      vec2 g11 = vec2(gx.w,gy.w);\n\n      vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n      g00 *= norm.x;  \n      g01 *= norm.y;  \n      g10 *= norm.z;  \n      g11 *= norm.w;  \n\n      float n00 = dot(g00, vec2(fx.x, fy.x));\n      float n10 = dot(g10, vec2(fx.y, fy.y));\n      float n01 = dot(g01, vec2(fx.z, fy.z));\n      float n11 = dot(g11, vec2(fx.w, fy.w));\n\n      vec2 fade_xy = fade(Pf.xy);\n      vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n      float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n      return 2.3 * n_xy;\n    }\n\nfloat cRand(vec2 p)\n{\n    return cnoise(p) * 0.5 +\n           cnoise(p + vec2(100.3, 100.3)) * 0.4 +\n           cnoise(p + vec2(20.3, 20.3)) * 0.1;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pos = fragCoord.xy / iResolution.xy;\n    vec2 posMid = vec2(-1.0, -1.0) + 2.0 * pos; \n    float fakX = iResolution.x / iResolution.y;\n    posMid.x *= fakX;\n    pos.x *= fakX;\n    \n    float fTime = iTime * 1.0;\n\n    float vMin = 10.0;\n    float vAdd = 0.0;\n    float vTemp = 0.0;\n    \n    vec3 colMixed = vec3(0.0);\n    \n    //float posXFract = fract(pos.x * 5.0);\n    //float posXFloor = floor(pos.x * 5.0);\n    //float rndF1 = cRand(pos * 10.0);\n    \n    float rndS1;\n    float iV;\n    float xTime;\n    \n    for (int i = 0; i < 8; i++)\n    {\n        iV = float(i + 1) * fPi;\n     \t\n        rndS1 = 1.3 + cRand(12.0 * pos + \n                             9.0 * vec2(iV + 0.01 * sin(fTime * iV * 0.21 + pos.y), \n                                        iV + 0.01 * sin(fTime * iV * 0.1 + pos.x))\n                           );\n        \n        xTime = fract(rndS1 + fTime * 0.3);\n        \n        vTemp = rndS1 * 0.1 + 0.1 * sin(fTime + iV * 2.0 - abs(posMid.x * 2.0) + pos.y * 9.5);\n        vAdd += vTemp;\n        vMin = min(vMin, vTemp);\n        \t\n    }\n\n    \n    float v = smoothstep(0.0, 1.0, vAdd * 0.5 + vMin * 12.0);\n    \n    colMixed = vec3(0.7, 0.30, 0.10) * v;\n    \n    \n\tfragColor = vec4(colMixed,1.0);\n}","name":"Image","description":"","type":"image"}]}