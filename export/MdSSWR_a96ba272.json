{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Public domain\n\nconst int   MAX_ITER = 50;\nconst float MAX_DIST = 3.0;\nconst float MIN_DIST = 0.001;\n\t\nfloat dist_box(vec3 p, vec3 b)\n{\n\treturn length(max(abs(p) - b, 0.0));\n}\n\nvec2 dist(vec3 p) // returns (distance, hue)\n{\n\tp += 1.0;\n\tfloat h = 0.0;\n\tfloat d = 1.0;\n\tfloat s = 1.0;\n\tfor (int i = 0; i < 4; i++)\n    {\n\t\tp = abs(p - s);\n\t\ts *= 0.4;\n\t\tfloat di = dist_box(p, vec3(s));\n\t\tif (di < d)\n        {\n\t\t\td = di;\n\t\t\th = float(i) / 4.0 + 0.4;\n\t\t}\n\t}\n\treturn vec2(d, h);\n}\n\n// Backwards marching: raymarch from the view distance to the camera.\nvec4 intersect(vec3 ray_origin, vec3 ray_dir)\n{\n\tvec3 p = ray_origin + MAX_DIST*ray_dir; \n    vec2 d = vec2(1);\n    float td = 0.0;\n\tfor (int i = 0; i < MAX_ITER; i++)\n\t{\n        if (d.x < MIN_DIST || td > MAX_DIST)\n\t\t\tbreak;\n        \n        d = dist(p - td*ray_dir);\n        td += d.x;\n\t}\n    \n\treturn vec4(p - td*ray_dir, d.y);\n}\n\nvec3 hsv(in float h, in float s, in float v)\n{\n\treturn mix(vec3(1.0), clamp((abs(fract(h + vec3(3, 2, 1) / 3.0) * 6.0 - 3.0) - 1.0), 0.0 , 1.0), s) * v;\n}\n\nvec3 get_normal(in vec3 p)\n{\n\tvec2 e = vec2(0.0, 0.001);\n\t\n\treturn normalize(vec3(\n\t\tdist(p + e.yxx).x - dist(p - e.yxx).x,\n\t\tdist(p + e.xyx).x - dist(p - e.xyx).x,\n\t\tdist(p + e.xxy).x - dist(p - e.xxy).x));\n}\n\nvec3 get_lighting(in vec3 pos, in vec3 normal, in vec3 light, in vec3 color)\n{\n\tfloat b = max(0.0, dot(normal, light));\n\treturn b * color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst vec3 up_dir = vec3(0, 1, 0);\n\tconst vec3 cam_eye = vec3(0, 0, 0);\n\tvec3 cam_pos = vec3(sin(iTime*0.25), 0.0, cos(iTime*0.25))*1.5;\n\tvec3 cam_dir = normalize(cam_eye - cam_pos);\n\tvec3 u = normalize(cross(up_dir, cam_dir));\n\tvec3 v = cross(cam_dir, u);\n\tvec2 scr_pos = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n\tscr_pos.x *= iResolution.x / iResolution.y;\n\tvec3 ray_dir = normalize(u * scr_pos.x + v * scr_pos.y + cam_dir);\n\t\n\tvec4 h = intersect(cam_pos, ray_dir);\n    float d = dist(h.xyz).x;\n\tvec3 material = hsv(h.w, 1.0, 1.0);\n\tvec3 normal = get_normal(h.xyz);\n\tvec3 color = get_lighting(h.xyz, normal, ray_dir, material);\n\t\n\tfragColor = mix(vec4(color, 1.0), vec4(0), d);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdSSWR","date":"1410728576","viewed":253,"name":"T-Cube backwards","username":"gleurop","description":"Raymarching the T-Cube fractal backwards, aka reverse perspective.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal"],"hasliked":0,"parentid":"","parentname":""}}