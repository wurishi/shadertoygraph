{"ver":"0.1","info":{"id":"4lcGR2","date":"1470162881","viewed":170,"name":"Simple Fractal","username":"Nimthora","description":"Some simple fractal shader","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The distance at which a point is considered to have escaped\nconst float INFINITY = 1000000.0;\n\n// The number of iterations for the point to escape to infinity\nconst int ITERATIONS = 50;\n\n// A constant real component to add to the vector on each iteration\nconst float ADD_R = -0.35;\n// A constant imaginary component to add to the vector on each iteration\nconst float ADD_I = 0.61;\n\n/*\n* The complex function being applied ITERATIONS number of times\n* This function is a variant of z^2 + c\n* It calculates the square of 'coord' as normal,\n* but instead of a 2 uses a 3 to calculate b.\n* Some real and imaginary constant or variable is then added to the result.\n*/\nbool func(inout vec2 coord, in float r) {\n    // Complex multiplication: (x + yi)^2 = x^2 + 2*x*(yi) + (yi)^2\n\tfloat a = coord.x * coord.x;\n    float b = 2.5 * coord.x * coord.y; // 2 is replaced by 3, because it looks cool :)\n    float c = -(coord.y * coord.y); // i^2 = -1\n    \n    coord = vec2(a + c + r, b + ADD_I);\n    \n    // Check if the point escaped\n    if (length(coord) > INFINITY) {\n        return true;\n    }\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy);\n\n    // Get the intensity of the sound at point (0, 0).\n    float sound = texture(iChannel0, vec2(0, 0)).r;\n    // We use the sound intensity for zooming\n    float zoom = sound * 0.25 + 2.0;\n    // To keep the view centered we use an offset relative to zoom\n    vec2 offset = vec2(zoom/2.0, zoom/2.0);\n    \n    // Calculate the coordinate of the screen we will be using for the complex function\n\tvec2 coord = (fragCoord.xy / iResolution.xy * zoom) - offset;\n    \n    // We use time to change the real component addition in the function\n    float t = sin(iTime / 8.0) * 0.25;\n    \n    // We store the iteration at which a point escaped and use it for colour\n    int si = 0;\n    for (int i = 0; i < ITERATIONS; i++) {\n     \tbool escaped = func(coord, t);\n        if (escaped) {\n            si = i;\n            break;\n        }\n    }\n    \n    // We paint the colour of the escape iteration\n\tfragColor = vec4(float(si) / float(ITERATIONS/2), 0, 0, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}