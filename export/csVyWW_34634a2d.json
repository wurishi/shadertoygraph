{"ver":"0.1","info":{"id":"csVyWW","date":"1696130880","viewed":32,"name":"Tunnel Diving","username":"shaderwho","description":"included my golf version which reduced this code by a lot, for a challenge.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["psychedelic","trippy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// golfed version: void mainImage(out vec4 f,in vec2 c){vec2 b=c/iResolution.xy*vec2(11.)-vec2(6.),xy,cur;float t=iTime*2.5-floor(iTime*2.5),r=exp(t)+exp(-t),z,p,w;vec4 a=vec4(-1.);int n=12,s,i,wh;for(s=11;s<n;s++){vec2 o=vec2(float(s%2),float(s/2))/float(n);xy=b+o;cur=vec2(.7,-.24);z=10.;wh=0;for(i=50;i<580;i++){cur+=xy*0.1;xy-=vec2(sin(iTime)*.4,cos(iTime*.1)+cos(z+iTime)*.01);z+=.05;if(length(vec2(cur.x/(2.+sin(iTime*1.5)),cur.y/(2.+cos(iTime+0.25))))>1.)break;if(mod(z/200.+iTime*.015,1.)>.8){wh++;}}p=1.5*sin(10.*atan(xy.x,xy.y)+z+iTime)+.5*cos(10.*length(xy)+z-iTime);w=smoothstep(0.,1.,1.-exp(-float(wh)/10.));vec3 co=mix(vec3(p,p*.5,p*.25),vec3(1.,.5,.5),w);a+=vec4(co,1.)*vec4(7.,sin(z+iTime*.15)*.25+.25,1.,1.);}f=a/float(n);w=smoothstep(0.,1.,1.-exp(-a.a/10.));f.rgb=mix(f.rgb,vec3(12.),w);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n    {\n        // baseXY: Adjusts the tunnel size and camera direction.\n        // Modify the vec2(11) to change the tunnel size and vec2(6) to change the camera direction.\n        vec2 baseXY = fragCoord/iResolution.xy*vec2(11)-vec2(6);\n        \n        // time: Calculates the fractional part of time.\n        // It's used to create a pulsating effect in the tunnel.\n        float time = (iTime*2.5 - floor(iTime*2.5));\n        \n        // rotations: Used to create a rotation effect in the tunnel.\n        float rotations = exp(time)+exp(-time);\n        \n        // colAccum: Accumulator for color samples, used for supersampling.\n        // Initialize with vec4(-1.0) to start with a negative base.\n        vec4 colAccum = vec4(-1.0);\n        \n        // numSamples: Number of samples per pixel for supersampling.\n        // Increase for higher quality and decrease for better performance.\n        int numSamples = 12;\n        \n        for(int s = 11; s < numSamples; s++) {\n            // offset: Determines the offset for each sample in supersampling.\n            // Adjust the division value to change the sampling grid.\n            vec2 offset = vec2(float(s % 2), float(s / 2)) * (1.0 / float(numSamples));\n            \n            // xy: Adjusted coordinates for each sample.\n            vec2 xy = baseXY + offset;\n            \n            // cur: Initial position in the tunnel, can be modified to change the starting point.\n            vec2 cur = vec2(.7,-.24);\n            \n            // z: Depth variable, used to traverse through the tunnel.\n            float z = 10.0;\n            \n            // whites: Counter for the white color appearance in the tunnel.\n            int whites=0;\n            \n            // Main loop to traverse through the tunnel and calculate color.\n            // Modify the loop range to adjust the resolution and depth of the tunnel.\n            for(int i = 50; i < 580; i++) {\n                // Adjust the multiplication factor to change the speed of traversal through the tunnel.\n                cur += xy*0.1;\n                \n                // Modify these values to change the rotation and movement of the tunnel over time.\n                xy -= vec2(sin(iTime)*0.4,cos(iTime*.1)*0.5+cos(z+iTime)*0.01);\n                \n                // Increment the depth variable.\n                z += 0.05;\n                \n                // Break condition to stop traversal when a certain depth is reached.\n                if(length(vec2(cur.x/(2.0+sin(iTime*1.5)), cur.y/(2.0+cos(iTime*1.0+0.25)))) > 1.0) break;\n                \n                // Condition to increase the whites counter based on depth and time.\n                if(mod(z/200.0+iTime*0.015,1.0)>0.8) {\n                    whites+=1;\n                }\n            }\n            \n            // pattern: Generates complex, trippy patterns using sine and cosine functions.\n            // Modify the multiplication and addition factors to change the pattern's frequency and phase.\n            float pattern = 1.5 * sin(10.0 * atan(xy.x, xy.y) + z + iTime) + 0.5 * cos(10.0 * length(xy) + z - iTime);\n            \n            // whiteIntensity: Calculates the intensity of white color based on the whites variable.\n            float whiteIntensity = smoothstep(0.0, 1.0, 1.0-exp(-float(whites)/10.0));\n            \n            // col: Calculates the color of the tunnel based on the pattern and whiteIntensity.\n            vec3 col = mix(vec3(pattern, pattern * 0.5, pattern * 0.25), vec3(1.0, 0.5, 0.5), whiteIntensity);\n            \n            // Accumulates the color samples for supersampling.\n            colAccum += vec4(col,1)*vec4(7,sin(z+iTime*0.15)*0.25+0.25,1,1);\n        }\n        \n        // fragColor: Averages the color samples and assigns it to the final fragment color.\n        fragColor = colAccum / float(numSamples);\n        \n        // Adjusts the final color based on the whiteIntensity.\n        // Modify the vec3(12) to change the color mixed when white is approaching.\n        float whiteIntensity = smoothstep(0.0, 1.0, 1.0-exp(-float(colAccum.a)/10.0));\n        fragColor.rgb = mix(fragColor.rgb,vec3(12), whiteIntensity);\n    }\n","name":"Image","description":"","type":"image"}]}