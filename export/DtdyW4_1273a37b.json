{"ver":"0.1","info":{"id":"DtdyW4","date":"1699211379","viewed":40,"name":"cloud by fbm","username":"tomcat7479","description":"Rendering Cloud by Fractal Brown Motivion","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["fbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n  Rendering Cloud by Fractal Brown Motivion\n*/\n\n#define ROTATE_MATRIX mat2(0.6, -0.8, 0.8, 0.6)     \n\nvec2 fix(vec2 coord) {\n    return (2.0 * coord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nmat3 setCamera(vec3 lookAt, vec3 ro, float theta) {\n    vec3 z = normalize(lookAt - ro);\n    vec3 up = vec3(sin(theta), cos(theta), 0.0);\n    vec3 x = normalize(cross(z, up));\n    vec3 y = normalize(cross(x, z));\n    return mat3(x, y, z);\n}\n\nfloat random(in vec2 p) {\n    vec2 q = 55.1876653 * fract(p * 10.1321513);\n    return fract((q.x + q.y) * q.x * q.y);\n}\n\n// return noise value and noise gradient\nvec3 noise(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    vec2 du = 6.0 * f * (1.0 - f);\n\n    vec2 offset = vec2(1.0, 0.0);\n    float a = random(i);\n    float b = random(i + offset.xy);\n    float c = random(i + offset.yx);\n    float d = random(i + offset.xx);\n\n    float noiseV = a + (b - a) * u.x * (1.0 - u.y) + (c - a) * (1.0 - u.x) * u.y + (d - a) * u.x * u.y;\n    vec2 noiseG = du * (vec2(b - a, c - a) + (a - b - c + d) * u.yx);\n    return vec3(noiseV, noiseG);\n}\n\n// fbm\nmat2 rotateM = mat2(0.6, -0.8, 0.8, 0.6);\nfloat fbm(vec2 p) {\n    float res = 0.0;\n    float factor = 0.5;\n    for (int i = 0; i < 4; i++) {\n        vec3 noiseInfo = noise(p);\n        res += factor * noiseInfo.x;\n        p = rotateM * p * 2.0;\n        factor *= 0.5;\n    }\n    return res;\n}\n\n\nvec3 render(vec2 uv) {\n    vec3 col = vec3(0.0);\n\n    vec3 baseSkyCol = vec3(0.3, 0.5, 0.85);\n    vec3 baseGraySkyBandCol = vec3(0.7, 0.75, 0.85);\n    float cloudH = 300.0;\n    vec3 cloudCol = vec3(1.0, 0.95, 1.0);\n \n    float angle = 0.05 * iTime;\n    float r = 300.0;\n    float forward_offset = 0.01;\n    vec2 px2 = vec2(r * sin(angle), r * cos(angle));\n    vec3 lookAt = vec3(r * sin(angle + forward_offset), 0.0, r * cos(angle + forward_offset));\n    vec3 ro = vec3(px2.x, 0.0, px2.y);\n    float focus_distance = 1.0;\n    mat3 camera = setCamera(lookAt, ro, 0.0);\n    vec3 rd = normalize(camera * vec3(uv, focus_distance));\n\n    // rendering\n    // rendering sky\n    col = baseSkyCol - rd.y * rd.y * rd.y * 0.3;\n    col = mix(col, 0.85 * baseGraySkyBandCol, pow(1.0 - max(rd.y, 0.0), 4.0));\n    \n    if (rd.y > 0.0) {\n        vec2 cloudUV = ro.xz + (cloudH - ro.y) / rd.y * rd.xz;\n        col = mix(col, cloudCol, fbm(0.01 * cloudUV));\n    } else {\n        col = vec3(0.0);\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fix(fragCoord);\n    vec3 col = render(uv);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}