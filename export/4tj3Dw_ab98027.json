{"ver":"0.1","info":{"id":"4tj3Dw","date":"1429564091","viewed":694,"name":"Sauron's eye","username":"kuvkar","description":"Frodo's in trouble. Luckily Sauron obeys your mouse.","likes":40,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fire","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// noise from iq's hell shader\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z ) - 0.5;\n}\n\n////////////////// distance field functions from https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n/////////////////\n\n// Utility stuff\n#define PI 3.14159\n\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotation;\n\nconst float CORONA = 0.1;\nconst float PUPIL = 0.2;\n\n#define FIRE_RADIUS 0.04\n\nvec2 map(vec3 p)\n{\n    // Pupil\n    vec3 pp = p;\n    pp *= rotation;\n    pp.x *= 2.0;\n    pp.y *= 0.67;\n    pp -= vec3(0.0, 0.0, -0.115);\n    \n    // Coronas\n    p *= rotation;\n    \n    float x = 0.5 * (atan(p.y , p.x )) / PI;\n    float y = 0.5 * (atan(p.y , p.z )) / PI;\n    \n    float d = sdSphere(p, 0.15) * 0.3;\n    float l = length(p);\n    \n    vec3 np = vec3(x, y, -length(p) * 0.5 + iTime * 0.03);\n    float corona = abs(noise(np * 25.0));\n    \n    float corona1 = abs(noise(np * 50.0));\n    float corona2 = abs(noise(np * 75.0));\n    float corona3 = abs(noise(np * 200.0));\n    corona += corona1 * 0.5 + corona2 * 0.35 + corona3 * 0.35;\n\tcorona  *= FIRE_RADIUS;\n    \n    \n    float cor = -corona + d;\n    float ppl = sdSphere(pp, 0.08);\n    \n    \n    float m = min(ppl, cor);\n    \n    if ( m == cor)\n    {\n        return vec2(CORONA, m);\n    }\n    return vec2(PUPIL, m);\n\n}\n\n\nbool trace(in vec3 from, in vec3 rd, inout vec4 color)\n{\n    vec3 rp = from;\n    float d = 0.0;\n    color.a = 0.0;\n    bool hit = false;\n    \n    vec3 col = vec3(0.07, 0.020, 0.0115) * 0.28;\n    float dens = 1.0;\n    \n    for (int i = 0; i < 250; ++i)\n    {\n        \n        if(rp.z > 0.1)\n        {\n            return hit;\n        }\n        \n        vec2 mat = map(rp);\n        d = mat.y;\n        if ( d <= 0.0 && color.a <= 1.0)\n        {\n            hit = true;\n            float density = abs(d) * dens;\n            color.a += abs(density);\n            if (mat.x == CORONA)\n            {\n\t            color.rgb += col;\n            }\n            else if (mat.x == PUPIL)\n            {\n                color += vec4(0.0, 0.0, 0.0, 0.2);\n            }\n        }\n        rp += rd * max(d * 0.2, 0.0005);\n    }\n    \n    return hit;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 _uv = uv;\n    \n    uv -= vec2(0.5);\n    vec3 rd = vec3(uv, 1.0);\n    rd.y /= aspect;\n    rd = normalize(rd);\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse.xy -= vec2(0.5);\n    float rspeed = 20.0;\n    \n    if (iMouse.xy == vec2(0.0))\n    {\n    \tmouse.xy = vec2(0.0, 0.0);\n    }\n    float rotspeed = 4.0;\n    mouse.x += sin(iTime * 0.5 * rotspeed) * 0.015;\n    mouse.y += sin(iTime * 0.4 * rotspeed) * 0.015;\n    \n    rotation = roty(-mouse.x * rspeed);\n    rotation *= rotx(mouse.y * rspeed);\n    \n    trace(vec3(0.0, 0.0, -1.0), rd, fragColor);\n    fragColor.a = clamp(fragColor.a, 0.0, 1.0);\n    uv.y *= iResolution.y / iResolution.x;\n\n    // Background texture \n    vec4 bg = vec4(0.0);\n    for (int i = 0; i < 3; ++i)\n    {\t\n        float spd = float( (i + 1)) * iTime * 0.05;\n        vec2 c1 = vec2(uv.x, pow(_uv.y, 0.25) - spd);\n        c1.x *= pow(length(uv), 2.8) * 5.5;\n        \n        if ( i == 0)\n        {\n\t        vec4 smoke = (1.0 - fragColor.a) * texture(iChannel2, c1 * 6.0);\n\t        bg += smoke * float(i + 1) * 0.45 * vec4(0.5, 0.5, 0.3, 0.0);\n        }else\n        {\n\t        vec4 smoke = (1.0 - fragColor.a) * texture(iChannel1, c1);\n\t        bg += smoke * float(i + 1) * 0.25 * vec4(0.9, 0.3, 0.1, 0.0);\n        }\n    }\n    \n    // look colors \n    vec3 look = rotation * vec3(0.0, 0.0, -1.0);\n    float lookd = clamp(dot(look, vec3(0.0, 0.0, -1.0)), 0.0, 1.0);\n    fragColor += mix(bg, bg * vec4(0.2, 1.3, 3.5, 0.0), mix(1.0 - lookd, 1.0, 0.00));\n    \n    // \n    vec4 glow = vec4((sin(iTime * 2.0) * 0.5) * 1.5 * vec4(0.8, 0.25, 0.1, 0.0));\n    fragColor += glow * (0.5 - length(uv));\n    \n    fragColor -=  clamp(length(uv) - 0.2,  0.0, 1.0) *  (1.0 - fragColor.a) * 1.2;\n    \n    \n}","name":"","description":"","type":"image"}]}