{"ver":"0.1","info":{"id":"fltyzj","date":"1660136176","viewed":1447,"name":"parameterized crt filter","username":"whkrmrgks0","description":"feel free to use. integration to any kind of open source software is appreciated.\ncurrent parameters are optimized for FHD\n\nold simpler version with less buffers and no glow: https://www.shadertoy.com/view/7lccRf\n","likes":21,"published":1,"flags":32,"usePreview":0,"tags":["postprocessing","filter","crt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define tau 6.283184\n\n//-------notes for integration--------\n\n//Glow size\nconst float svl = 0.005;\n\n//Glow iteration\nconst float vv = 16.0;\n\n//Glow\nconst float glow = .5;\n\n//Glow threshold\nconst float thres = 0.1;\n\n//Glow gamma\nconst float gma = .8;\n\n//------------------------------------\n\nfloat hash11(float seed){\n    return fract(75.345*sin(623.3754*seed));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratcnsv = iResolution.x/1000.;\n    vec3 blr = vec3(.0);\n    vec3 clr = texture(iChannel0,uv).xyz;\n    float vzz;\n    float acc = .0;\n    for(float i=0.;i<vv;i++){\n        blr += texture(iChannel0,uv+vec2(sin(i*tau/vv),cos(i*tau/vv)/(iResolution.y/iResolution.x))*svl/ratcnsv).xyz;\n    }\n    blr /= vv;\n    blr = pow(blr,vec3(gma));\n    vec3 diff = clr-blr;\n    diff = max(vec3(.0),diff);\n    diff *= glow;\n    blr -= vec3(thres);\n    blr = max(blr,.0)*glow;\n    clr += blr;\n    //clr -= diff;\n    fragColor = vec4(clr,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define cr vec2(0.,0.)\n#define cb vec2(1.73205080757,1.)\n#define cg vec2(1.73205080757,-1.)\n\n//-------notes for integration--------\n\n//Dot size\nconst float dts = 0.0006;\n\n//Mask ratio\nconst float mrat = 1.4;\n\n//Mask AA samples\nconst float masaa = 8.0;\n\n//AA size\nconst float AAs = 0.001;\n\n//Noise size\nconst float nstr = 0.15;\n\n//CRT curvature\nconst float cus = 0.05;\n\n//CRT capacitance\nconst float capaci = 0.007;\n\n//Capacitance simulation iteration\nconst float capaiter = 9.0;\n\n//Capacitance effect strength\nconst float capastr = 3.0;\n\n//Vignette strength\nconst float vstr = 0.2;\n\n//Display margin\nconst float marginv = 0.04;\n\n//Grey zone\nconst float gz = 0.05;\n\n//Scanline count\nconst float scanline = 480.0;\n\n//------------------------------------\n\n//pixelgrid mask\nfloat grd(vec2 uv, vec2 disp){\n    uv += disp*dts*2.;\n    return clamp(min(sin((uv.x+step(sin(uv.y/dts/2.),0.)*dts*3.0)/dts),sin(uv.y/dts))-1.+mrat,.0,1.);\n}\n//PN\nvec2 hash22(vec2 seed){\n    return fract(75.345*sin(623.3754*seed));\n}\n//nonlinear distortion\nvoid pinc(vec2 uv, inout vec2 uv2, inout float mxbf){\n    uv2 = (uv*vec2(2.)-vec2(1.))*vec2(1.+marginv);\n    float L = length(uv2);\n    uv2 = normalize(uv2)*(L-(1.-L)*tanh(L*cus));//pincushion\n    vec2 uvbef = abs(uv2)-vec2(1.);//boarder\n    mxbf = max(uvbef.x,uvbef.y);\n    uv2 = (uv2+vec2(1.))*vec2(.5);//recoordination\n}\n//crt return pattern\nfloat sawtooth(float inp){\n    return inp-floor(inp);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv2;\n    float mxbf;\n    float ratcnsv = iResolution.x/1000.;//Pixel absolute compensation\n    pinc(fragCoord/iResolution.xy,uv2,mxbf);\n    vec2 ratd = vec2(uv2.x,uv2.y*iResolution.y/iResolution.x);//Aspect compensated coord\n    float brd = step(mxbf,0.);\n    float vign = 1.-pow(max(mxbf+1.,.0),1./vstr)*vstr;\n    ratd *= ratcnsv;\n    vec2 oratd = ratd;\n    vec2 noise = hash22(uv2*iTime)*nstr;\n    vec3 grid = vec3(.0);\n    for(float i=0.;i<masaa;i++){\n        grid += vec3(grd(ratd,cr+noise),grd(ratd,cg+noise),grd(ratd,cb+noise));\n        ratd = oratd+hash22(vec2(0.15634,0.15623)*i)*AAs;//AA size\n    }\n    grid/=masaa;\n    uv2.y = floor(uv2.y*scanline)/scanline;\n    vec3 bef = texture(iChannel0,uv2).xyz;\n    for(float i=0.;i<capaiter;i++){\n        bef += (bef-texture(iChannel0,vec2(sawtooth(uv2.x-capaci*i/capaiter),uv2.y)).xyz)*capastr*(1.-i/capaiter)*1./capaiter;\n    }\n    \n    /*\n    float tmp;\n    float befuv = uv2.y;\n    vec3 mask2 = vec3(.0);\n    tmp = befuv;\n    mask2 += pow(vec3(abs(sin(tmp*tau*scanline/2.+3.1415))),(1.-bef));\n    */\n    \n    bef = max(bef,vec3(gz));\n    bef = clamp(bef,vec3(.0),vec3(1.));\n    fragColor = vec4(pow(max((bef*6.)*vec3(brd*grid*vign),.0),vec3(1.))/(mrat*mrat),1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define tau 6.283184\n\n//-------notes for integration--------\n\n//Blur size second stage ease\nconst float svl = 0.0009;\n\n//Blur iteration second stage ease\nconst float vv = 8.0;\n\n//Gamma second stage ease\nconst float gma = 1.0;\n\n//------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratcnsv = iResolution.x/1000.;\n    vec3 clr = vec3(.0);\n    for(float i=0.;i<vv;i++){\n            clr += texture(iChannel0,uv+vec2(sin(i*tau/vv),cos(i*tau/vv)/(iResolution.y/iResolution.x))*svl/ratcnsv).xyz;\n    }\n    clr /= vv;\n    clr = min(clr,1.);\n    clr = pow(clr,vec3(gma));\n    fragColor = vec4(clr,1.);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\n\nThis file is part of Parameterized CRT filter by whkrmrgks0.\n\nParameterized CRT filter by whkrmrgks0 is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\n\nParameterized CRT filter by whkrmrgks0 is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License along with Parameterized CRT filter by whkrmrgks0. If not, see <https://www.gnu.org/licenses/>.\n\naug 11 2022\n\nsorry for absurd amount of magic numbers\n\ncopyright 2022 whkrmrgks0\n\n*/","name":"Common","description":"","type":"common"}]}