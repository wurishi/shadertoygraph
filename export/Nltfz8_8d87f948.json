{"ver":"0.1","info":{"id":"Nltfz8","date":"1662905933","viewed":354,"name":"Lipschitz height map","username":"Alpaga","description":"A height map is converted into a Lipschitz height map and then rendered using raymarching, with the guarantee that there is no raymarching artefact.","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","heightmap","lipschitz"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A height map is rendered using raymarching.\n// The simplest way is to use the approximate signed distance function:\n//\n// sd(p) = p.y - height(p.xz)\n//\n// (the y-axis is the vertical direction)\n// However this formula creates artifacts because this quantity may not\n// be smaller than the actual distance to the surface. The trick is to\n// multiply this formula by a small constant: \n//\n// sd(p) = F*(p.y - height(p.xz))\n//\n// If we know that the height function is L-Lipschitz, then the constant\n// F = 1/sqrt(1+L^2) will remove the artifacts.\n//\n// In this shader,\n// - Buffer A produces a height and color map,\n// - Buffer B transforms the height map to make it L-Lipschitz\n// - The height map produced by Buffer B is then rendered.\n\nconst float fov = 35.0;\nconst vec3 back = vec3(0.0,0.01,0.04);\nconst vec3 ambient = vec3(0.5);\nconst vec3 lightDirection = normalize(vec3(-1.0,2.0,0.0));\n\nconst vec2 delta = vec2(0.0,0.01);\n\nfloat sd(vec3 p) {\n    vec2 q = vec2(iResolution.y/iResolution.x,-1.0)*p.xz;\n    return F*(p.y - texture(iChannel0, q+0.5).a);\n}\n\nvec3 color(vec3 p) {    \n    vec2 q = vec2(iResolution.y/iResolution.x,-1.0)*p.xz;\n    return texture(iChannel0, q+0.5).rgb;\n}\n\nvec3 normal(vec3 p) {\n    float d = sd(p);\n    return normalize(vec3(\n        sd(p+delta.yxx),\n        sd(p+delta.xyx),\n        sd(p+delta.xxy))-d);\n}\n\nfloat march(vec3 start, vec3 dir) {\n\tfloat total = 0.0, d = 1.0;\n    float epsilon = 0.5/iResolution.y;\n    int i=0;\n    for(; i<100; i++) {\n        if(d<epsilon)\n            return total;\n        if(total>5.0)\n            return -1.0;\n        d = sd(start + total * dir);\n        total += d;\n    }\n    return -1.0;\n}\n\nfloat lightMarch(vec3 start, vec3 dir) {\n\tfloat total = 0.0, d = 1.0;\n    float epsilon = 0.5/iResolution.y;\n    float minD = 1000.0;\n    for(int i=0; i<100; i++) {\n        if(d<epsilon || total>5.0) break;\n        d = sd(start + total*dir);\n        total += d;\n        minD = min(minD,d);\n    }\n    return minD;\n}\nfloat shadow(vec3 p, vec3 toLight) {\n    float minD = lightMarch(p+0.1*toLight, toLight);\n    return smoothstep(0.0,0.05,minD);\n}\n\nvec3 rayColor(vec3 start, vec3 dir) {\n    vec3 coef = vec3(1.0);\n\n    int id;\n    float d = march(start, dir);\n    if(d<0.0) // No intersection\n        return back;\n        \n    vec3 p = start + d * dir;\n\n    vec3 normal = normal(p);\n    vec3 toEye = normalize(start - p);\n    vec3 albedo = color(p);\n\n    // Diffuse\n    vec3 diff = albedo * (ambient + max(dot(lightDirection, normal), 0.0));\n\n    // Specular\n    vec3 h = normalize(toEye + lightDirection);\n    float spec = 0.04*pow(max(dot(h,normal),0.0), 1000.0);\n\n    // Shadow\n    float sh = shadow(p, lightDirection);\n\n    vec3 color = sh*(diff + spec);\n\n    // Reflection of environment\n    // We just reflect the environment, not the pens.\n    // However, a pen can shadow the environment reflection. \n    vec3 ref = reflect(-toEye, normal);\n    sh = shadow(p, ref);\n\n    vec3 env = texture(iChannel1,ref).rgb;\n    color += 0.1 * sh * env;\n    \n    color = mix(back, color, exp(-0.5*d*d));\n    return color;\n}\n\nmat3 setupCamera(vec3 cam, vec3 center, vec3 up) {\n \tvec3 w = normalize(cam-center);\n    vec3 u = normalize(cross(up, w));\n    vec3 v = cross(w, u);\n    \n    return mat3(u,v,w);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 cam = vec3(\n        2.0*cos(0.1*iTime),\n        H+0.2+0.1*sin(iTime),\n        2.0*sin(0.1*iTime));\n    mat3 m = setupCamera(cam, vec3(0.0,H - 0.4,0.0), vec3(0.0,1.0,0.0));\n    \n    vec3 color = vec3(0.0);\n\n    vec2 uv = 2.0*(fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    vec3 pix = vec3(tan(0.5*fov*0.01745)*uv,-1.0);\n    vec3 dir = normalize(m*pix);\n\n    color = rayColor(cam, dir);\n    \n    color = pow(color, vec3(0.45));\n    fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Max height\nconst float H = 0.1;\n\n// L is the Lipschitz constant\n// F should be 1/sqrt(1+L^2) (can be smaller, but closer is more efficient)\nconst float L = 2.0;\nconst float F = 0.5;//0.447;\n\n// Examples:\n// L 1.0   2.0   3.0\n// F 0.707 0.447 0.316\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Buffer A produces color and height map.\n// Color is stored in .rgb, height is stored in .a\n// Here it just takes data from the texture in iChannel0, but\n// it could be procedural. Make sure to select \"nearest\" when\n// choosing a texture.\n\n// Undefine COLORED if the texture just contains a .r channel\n// (for instance Bayer or Gray noise)\n#define COLORED\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    #ifdef COLORED\n    vec3 tex = texture(iChannel0, uv).rgb;\n    fragColor = vec4(tex,H*dot(tex,vec3(0.333333)));\n    #else\n    float h = texture(iChannel0, uv).r;\n    fragColor = vec4(vec3(h),H*h);\n    #endif\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Here we transform the height map from Buffer A\n// into a Lipschitz height map (it takes some iterations\n// to converge). Ideally, the output height map should be the\n// L-Lipschitz upper envelope, i.e. the smallest L-Lipschitz\n// function larger than the height map. I don't know whether\n// there is a fast way of computing this envelope, so I only\n// compute an approximate version.\n\n// The approximation is that the distance between two points\n// is not the actual Euclidean distance, which would be the\n// length of the straight line between two pixels, but the\n// length of the shortest path a chess king would travel from\n// a pixel to the other. This distance can be progressively\n// computed by moving from pixels to their neighbors.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 tex = texture(iChannel0, uv);\n        \n    if(iFrame > 0) {\n        h = tex.a;\n        vec2 p = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n        for(float i=-1.0;i<1.5;i++) {\n            for(float j=-1.0;j<1.5;j++) {\n                vec2 q = (fragCoord+vec2(i,j)-0.5*iResolution.xy)/iResolution.y;\n                vec2 uvq = (fragCoord + vec2(i,j))/iResolution.xy;\n                float hq = texture(iChannel1, uvq).a;\n                if(i!=0.0 || j!=0.0) h = max(h,hq-L*length(p-q));\n            }\n        }\n    }\n    fragColor = vec4(tex.rgb,h);\n}","name":"Buffer B","description":"","type":"buffer"}]}