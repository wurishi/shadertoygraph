{"ver":"0.1","info":{"id":"mdySRW","date":"1680773933","viewed":84,"name":"Fluff Cloud","username":"sooxt98","description":"some fluffy clouds","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["cloud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0,uv); \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Sample noise at different scales to create terrain \nfloat cloud(vec2 uv){\n    const int octaves =7;\n    const float scale = .005;\n    const float speed = .02;\n    const float undulate = .0004;\n     \n    //Animate surface by moving sample \n   \t//uv+=vec2(8.123);  //render: frame with nice clouds\n   \tuv+=iTime*speed;\n\n    float power = 2.0;\n    float total = 0.0;\n    for(int i = 0; i<octaves; i++){\n        //Reduce weight of sample as scale decreases \n        float offset = undulate*iTime;\n        //float offset = undulate*iTime*.01; //render: less motion\n        total += texture(iChannel1,uv*(power*scale)+offset).r*(1.0/power);\n        power *=2.0;\n        }\n    \n    const float skyPresence = .45;\n    return smoothstep(skyPresence,1.0,total);\n}\n\n//Input:\n\t//iChannel0: lilypad mask (R), ripple height (B), water surface height (A)\n\t//iChannel1: noise (for clouds)\n//Output:\n    //RGB: the pond's surface color\n    //A: isolated and masked bright spots, to use for light shafts\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Water surface controls\n    const float normalScalar = .25;\t\t//controls normal\n    const float sNormalScalar = .90;\t//influence of water surface on normal\n    const float rNormalScalar = .05;\t//influence of ripples on normal\n    const float distortScalar = .35;\t\t//how much normal distorts sky \n    const float fov = .27;\t\t\t\t\n    const float fresnel = .95;\t\t\t//scale influence from reflection (0) to refraction (1)\n    \n    //Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //For aspect ratio independence\n    vec2 uv2 = uv;\n    uv2.x *= iResolution.x/iResolution.y;\n    \n  \t//Get normal of water surface + ripples by converting them from height\n    float pixelSize = iResolution.y * .004;\n    vec2 leftCoord = vec2(fragCoord.x-pixelSize,fragCoord.y)/iResolution.xy; \n    vec2 rightCoord = vec2(fragCoord.x+pixelSize,fragCoord.y)/iResolution.xy;\n    vec2 topCoord = vec2(fragCoord.x,fragCoord.y+pixelSize)/iResolution.xy;\n    vec2 botCoord = vec2(fragCoord.x,fragCoord.y-pixelSize)/iResolution.xy;    \n    //Sample height from the adjacent pixels (x = ripple, y = water surface)\n    vec2 left = texture(iChannel2,leftCoord).ba;\n    vec2 right = texture(iChannel2,rightCoord).ba;\n    vec2 top = texture(iChannel2,topCoord).ba;\n    vec2 bot = texture(iChannel2,botCoord).ba;\n    //Convert to intersecting vectors and find the normals\n    vec3 sVertical = vec3(0, normalScalar, sNormalScalar*(top.y-bot.y));\n    vec3 sHorizontal = vec3(normalScalar, 0, sNormalScalar*(right.y-left.y));\n    vec3 sNormal = normalize(cross(sHorizontal,sVertical));\n    vec3 rVertical = vec3(0, normalScalar, top.x-bot.x);\n    vec3 rHorizontal = vec3(normalScalar, 0, right.x-left.x);\n    vec3 rNormal = normalize(cross(rHorizontal,rVertical));\n\tvec3 normal = sNormal + rNormal * rNormalScalar;\n    \n\n    //Sky controls\n    const float sunRadius = 0.0;\n    const float rimLightThickness = .55;\n    const float glowRadius = 1.45;\n    const float feather = .21;\n    \n    //Sun\n    /*\n    vec2 sunPos = vec2(.5);\n    if(iMouse.xy!=vec2(0)){\n        sunPos = iMouse.xy/iResolution.xy;\n    }\n    sunPos.x *= iResolution.x/iResolution.y;\n\t*/\n    vec2 sunPos = (iMouse.xy==vec2(0)) ? vec2(.5) : iMouse.xy/iResolution.xy;\n\tsunPos.x *= iResolution.x/iResolution.y;\n\n    float sunDist = length(uv2-sunPos); \n    float sunMask = 0.0;\n\tif(sunDist<sunRadius)\n        sunMask = pow((1.0-sunDist/sunRadius),2.0);\n    \n\t//Clouds\n    float cloud = cloud(uv2);\n    float cloudMask = smoothstep(0.0,feather,cloud);\n\n    //Colors\n    vec3 sunColor = vec3(1.2);\n    vec3 skyColor = vec3(114,162,164)/255.0;\n    vec3 cloudRimColor = vec3(115,130,125)/255.0;\n    vec3 cloudCenterColor = vec3(255,255,255)/255.0;\n    vec3 glowColor = cloudRimColor + vec3(.31,.26,.16);\n    vec3 lighterPond = vec3(10.0 / 255.0, 95.0 / 255.0, 100.0 / 255.0);\n  \tvec3 darkerPond = vec3(5.0 / 255.0, 20.0 / 255.0, 20.0 / 255.0);\n        \n    //Light clouds based on proximity to sun\n\tfloat glowMaskWide = max(1.0 - sunDist/glowRadius, 0.0);\n    float glowMaskNarrow = max(0.0,(1.0-sunDist/sunRadius));\n    cloudCenterColor = mix(cloudCenterColor, glowColor,glowMaskWide);\n    cloudCenterColor = mix(cloudCenterColor, sunColor, max(0.0,glowMaskNarrow*.5));\n    cloudRimColor = mix(cloudRimColor,sunColor,glowMaskWide);\n    vec3 cloudColor = mix(cloudRimColor,cloudCenterColor,smoothstep(0.0,rimLightThickness,cloud));\n    \n    //Composite \n    //skyColor = mix(skyColor,sunColor,sunMask);\n    skyColor = mix(skyColor,cloudColor,cloudMask);  \n\n    \n    //Visualizations\n  \t//Normal \n    //fragColor = vec4(normal*.5+.5,1);\n    //Facing ratio \n    //fragColor = vec4(vec3(facingRatio), 1);\n    //Total internal reflection mask\n    //fragColor = vec4(vec3(tirMask), 1);\n    //Light shaft mask \n    //fragColor = vec4(vec3(lightMask), 1);\n\n    // Output to screen\n    fragColor = vec4(skyColor,cloudMask);    \n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}