{"ver":"0.1","info":{"id":"msGGzG","date":"1723301425","viewed":39,"name":"Gravity Fractal Example","username":"metabog","description":"Fractal created by the 3 body problem.\nReferenced in this article:\nhttps://boggo.substack.com/p/gravitational-fractals","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["gravity"],"hasliked":0,"parentid":"mdGGRG","parentname":"Fork The Myster metabog 969"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    vec4 cl = 2.*texel(iChannel0, pos);\n    fragColor = cl;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p-0.5), 0)\n\n//collision size\nconst float schwarz = 0.001;\n\n//https://www.shadertoy.com/view/fstSW8\nvec2 FindNearestPointOnLine(vec2 origin, vec2 end, vec2 point)\n{\n    //Get heading\n    vec2 heading = (end - origin);\n    float magnitudeMax = length(heading);\n    heading = normalize(heading);\n\n    //Do projection from the point but clamp it\n    vec2 lhs = point - origin;\n    float dotP = dot(lhs, heading);\n    dotP = clamp(dotP, 0.0f, magnitudeMax);\n    return origin + heading * dotP;\n}\n\nbool checkCollided(vec2 cp, float cr, vec2 cur, vec2 old)\n{\n    vec2 pl = FindNearestPointOnLine(old,cur,cp);\n    \n    if(length(pl-cp)<cr*2.0)\n        return true;\n    \n    return false;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 mpos = vec2(0.2,0.2);\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec2 compute_grav_pull(vec2 me, vec2 other, float mass)\n{\n    vec2 vec = other-me;\n    float d = length(vec);\n    d = max(schwarz*4.0,d);\n    vec = normalize(vec);\n    d*=0.01;\n    float pull = 1.0f/(pow(d,1.5));\n    \n    vec *= pull * mass;\n    const float G = 0.000002;\n    vec*=G;\n    \n    return vec;\n}\n\n//starting pos\nvec2 b1_start_pos = vec2(-0.1,0.0);\nvec2 b2_start_pos = vec2(0.1,0.0);\n\n\n//change these to set the starting velocities of the other bodies\nvec2 body1_start_vel = vec2(0.0,0.1);\nvec2 body2_start_vel = vec2(0.0,-0.1);\nvec2 mover_start_vel = vec2(0.1,0.0);\n\n//the masses of the bodies\nfloat b1mass = 1.0;\nfloat b2mass = 1.0;\nfloat movermass = 3.0;\n\nfloat dt = 0.1;\n\nconst float min_distance_thresh = 0.12;\n\nvoid verlet(out vec2 moverpos, out vec2 b1pos, out vec2 b2pos, out vec3 value, int maxiter)\n{\n    vec2 b1vel = body1_start_vel;// + vec2(0.0,cos(iTime*0.1)*0.01);\n    vec2 b2vel = body2_start_vel;\n    \n    //set start velocity for the tracked body to rotate slowly\n    vec2 movervel = mover_start_vel;\n     \n    //uncomment for spinny velocity\n    // + vec2(cos(iTime*0.3)*0.1,sin(iTime*0.3)*0.1);\n    \n    int iter_reached = 0;\n   \n    vec2 b1acc =     vec2(0.0,0.0);\n    vec2 b2acc =     vec2(0.0,0.0);\n    vec2 moveracc =  vec2(0.0,0.0);\n   \n    bool escaped = false;\n    float max_dist_mover = 0.0;\n    float max_dist_1 = 0.0;\n    float max_dist_2 = 0.0;\n\n    int who_collided = -1;\n\n    int iter_under_min_distance = 0;\n\n    while(iter_reached<maxiter)\n    {\n        max_dist_mover = max(max_dist_mover,length(moverpos));\n        max_dist_1 = max(max_dist_1,length(moverpos));\n        max_dist_2 = max(max_dist_2,length(moverpos));\n        //max_dist_from_a = max(max_dist_from_a,length(movervel));\n        \n        //VERLET INTEGRATION UPDATE\n        vec2 new_b1pos = b1pos + b1vel*dt + b1acc*dt*dt*0.5;\n        vec2 new_b2pos = b2pos + b2vel*dt + b2acc*dt*dt*0.5;\n        vec2 new_moverpos = moverpos + movervel*dt + moveracc*dt*dt*0.5;\n        \n        //get the new velocities\n        vec2 new_b1acc  = compute_grav_pull(b1pos, b2pos, b2mass) + compute_grav_pull(b1pos,moverpos, movermass);\n        vec2 new_b2acc  = compute_grav_pull(b2pos, b1pos, b1mass) + compute_grav_pull(b2pos,moverpos,movermass);\n        vec2 new_moveracc = compute_grav_pull(moverpos, b1pos,b1mass) + compute_grav_pull(moverpos,b2pos,b2mass);\n\n        vec2 new_b1vel = (b1vel + (b1acc + new_b1acc)*dt*0.5);\n        vec2 new_b2vel = (b2vel + (b2acc + new_b2acc)*dt*0.5);\n        vec2 new_movervel = (movervel + (moveracc + new_moveracc)*dt*0.5);\n       \n        b1acc = new_b1acc;\n        b2acc = new_b2acc;\n        moveracc = new_moveracc;\n        \n        b1vel = new_b1vel;//*0.98;\n        b2vel = new_b2vel;//*0.98;\n        movervel = new_movervel;//*0.98;\n        \n        if(true)\n        {\n            //stop conditions are colliding with one of the bodies\n            //use a form of continuous collision detection to avoid\n            //endless oscillation around a body that never actually collides with it\n            \n            if(checkCollided(b1pos,schwarz,moverpos,new_moverpos))\n            {\n                moverpos=b1pos;\n                who_collided = 0;\n                break;\n            }\n        \n            if(checkCollided(b2pos,schwarz,moverpos,new_moverpos))\n            {\n                who_collided =1;\n                moverpos=b2pos;\n                break;\n            }\n            \n            if(checkCollided(moverpos,schwarz,b1pos,new_b1pos))\n            {\n                who_collided =0;\n                moverpos=b1pos;\n                break;\n            }\n        \n            if(checkCollided(moverpos,schwarz,b2pos,new_b2pos))\n            {\n                who_collided = 1;\n                moverpos=b1pos;\n                break;\n            }\n            \n            if(checkCollided(b2pos,schwarz,b1pos,new_b1pos))\n            {\n                who_collided = 2;\n                b2pos=b1pos;\n                break;\n            }\n                \n            if(checkCollided(b1pos,schwarz,b2pos,new_b2pos))\n            {\n                who_collided = 2;\n                b2pos=b1pos;\n                break;\n            }\n        }\n      \n        float l1 = length(b1pos-b2pos);\n        float l2 = length(b1pos-moverpos);\n        float l3 = length(b2pos-moverpos);\n        float minlength = min(l1,l2);\n        minlength = min(minlength,l3);\n        if(minlength < min_distance_thresh)\n        {\n            iter_under_min_distance++;\n        }\n      \n        moverpos = new_moverpos;\n        b1pos = new_b1pos;\n        b2pos = new_b2pos;\n        iter_reached++;\n    }\n    \n    //color based on which particles ended up being closest to each other\n    int lengthidx = -1;\n    float minlength=10000.0;\n    \n    float l1 = length(b1pos-b2pos);\n    float l2 = length(b1pos-moverpos);\n    float l3 = length(b2pos-moverpos);\n    \n    if(l1<minlength)\n    {\n        lengthidx = 0;\n        minlength = l1;\n    }\n    \n    if(l2<minlength)\n    {\n        lengthidx = 1;\n        minlength = l2;\n    }\n    \n    if(l3<minlength)\n    {\n        lengthidx = 2;\n        minlength = l3;\n    }\n    \n    if(lengthidx == 0)\n      value = vec3(1.0,0.3,0.5);\n      \n    if(lengthidx == 1)\n      value = vec3(0.4,1.0,0.1);\n      \n    if(lengthidx == 2)\n      value = vec3(0.2,0.3,1.0);\n          \n    if(who_collided != -1)\n    value = vec3(0.0,0.0,0.0);\n    \n    float stability = float(iter_under_min_distance)/float(maxiter);\n    stability = smoothstep(0.0,0.06,pow(stability,1.5));\n    value *= stability;\n}\n\nvec3 doOrbit(vec2 screenpos, vec2 pos, int maxiter)\n{\n    vec2 mm = iMouse.xy;\n    mm = ((mm-iResolution.xy*0.5)/iResolution.xx);\n\n    vec2 b1pos = b1_start_pos;\n    vec2 b2pos = b2_start_pos;\n    vec2 moverpos = mm;\n\n    vec3 value;\n    verlet(moverpos,b1pos,b2pos,value, maxiter);\n    \n    float hit = 0.0;\n    \n    if(length(moverpos - screenpos)<schwarz)\n        hit=1.0;\n      \n    if(length(b1pos - screenpos)<schwarz)\n       hit=1.0;\n        \n    if(length(b2pos - screenpos)<schwarz)\n       hit=1.0;   \n        \n    return vec3(1.0,1.0,1.0) * hit*0.5;  \n}\n\nvec3 doFractal(vec2 pos, vec2 second_body_pos)\n{\n    vec3 value;\n    vec2 moverpos = pos;\n    vec2 b1pos = b1_start_pos;\n    vec2 b2pos = b2_start_pos;\n \n    verlet(moverpos,b1pos,b2pos,value,512);\n      \n    return value;    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ((fragCoord-iResolution.xy*0.5)/iResolution.xx);\n\n    vec4 cl = texel(iChannel0, fragCoord);\n    mpos =cl.zw;\n\n    float cTime = max(0.0, mod(iTime,40.0) - 1.0);\n    float zoom = exp(cTime* 0.3);\n\n    uv /= zoom;\n    \n    //cool zoom locations\n    uv += vec2(0.0045,-0.0995);\n    //uv += vec2(0.11052,0.007999);\n    \n    //do some extra sampling\n    //super expensive\n    \n    //vec3 d1 = doFractal(uv, mpos);\n    //vec3 d2 = doFractal(uv+vec2(0.0002,0.0)/zoom, mpos);\n    //vec3 d3 = doFractal(uv+vec2(-0.0002,0.0)/zoom, mpos);\n    //vec3 d4 = doFractal(uv+vec2(0.0,0.0002)/zoom, mpos);\n    //vec3 d5 = doFractal(uv+vec2(0.0,-0.0002)/zoom, mpos);\n    //vec3 d = (d2+d3+d4+d5)/5.0;\n    \n    //aliased but cheap\n    vec3 d = doFractal(uv,mpos);\n    \n    fragColor=vec4(d,1.0);\n    \n    //enable for visualising 3 body sim at mouse position\n    //vec3 orbit = doOrbit(uv,mpos,int(iTime*30.0)%512);\n    \n    //if(length(orbit)>0.0)\n    //   fragColor = vec4(orbit,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}