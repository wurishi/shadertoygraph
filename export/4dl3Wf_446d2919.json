{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//////////////////////////////////////////////////////////////////////\n//\n// \"State-less\" physics demonstration. Probably useless.\n//\n// Written by ioccc_fan, license:\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported\n//\n//////////////////////////////////////////////////////////////////////\n\n// x/z size of box (minus ball radius)\n#define size     1.0\n\n// radius of ball\n#define rad      0.1\n\n// x/z size of box \n#define dsize   (size+rad)\n\n// initial velocity in x, y, z\n#define dx0      3.0\n#define dy0     10.0\n#define dz0      1.0\n\n// accel due to gravity\n#define g        9.8     \n\n// coeff. of restitution for vertical bounces\n#define gamma    0.9     \n\n// inverse coeff. of restitution for horiz. bounces\n#define invgamma 1.6     \n\n// height at which ball \"shadow\" vanishes\n#define hmax     6.0     \n\n// height at which box walls turn black\n#define smax     4.0     \n\n#define M_PI 3.14159265\n\n// initial velocity for x/z as vector\nconst vec2 dxz0 = vec2(dx0, dz0);\n\n// magic numbers for timing:\nconst float Ty0 = 2.0*dy0/g;\nconst float ty0 = 0.5*Ty0;\nconst vec2 Txz0 = vec2(2.0*size/dxz0);\nconst vec2 txz0 = vec2(0.5*Txz0.x, 0.25*Txz0.y);\n\n//////////////////////////////////////////////////////////////////////\n// helper stuff for raytracing:\n\n// struct to track raytracing hits\nstruct hit_t {\n  float t;\n  vec3  N;\n  vec3  color;\n};\n\n// detect hitting a plane - there's got to be a way to do this with\n// fewer parameters :(\nbool plane(in vec3 o, \n           in vec3 d,\n           in vec3 N,\n           in float D,\n           in vec3 tx, \n           in vec3 ty,\n           in vec2 lo, \n           in vec2 hi,\n           in vec3 color,\n           inout hit_t res) {\n\n  float num = (D - dot(o, N));\n  float denom = dot(d, N);\n  if (num < 0.0 && denom < 0.0) { \n    float t = num / denom;\n    vec3  p = o+d*t;\n    float x = dot(p, tx);\n    float y = dot(p, ty);\n    if (x > lo.x && x < hi.x &&\n        y > lo.y && y < hi.y && t < res.t) {\n      res.t = t;\n      res.N = N;\n      res.color = color;\n      return true;\n    }\n  }\n\n  return false;\n\n}\n\n// raytrace a sphere\nbool sphere(in vec3 o,\n            in vec3 d,\n            in vec3 s,\n            in float r,\n            in vec3 color,\n            inout hit_t res) {\n\n  o -= s;\n\n  float p = -dot(o, d);\n  float q = dot(o, o) - r*r;\n\n  float D = p*p - q;\n  if (D >= 0.0) {\n    float sqrtD = sqrt(D);\n    float t = min(p+sqrtD, p-sqrtD);\n    if (t > 0.0 && t < res.t) {\n      res.t = t;\n      res.N = normalize(o + d*t);\n      res.color = color;\n      return true;\n    }\n  }\n\n  return false;\n\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// raytrace the scene\n\nvec3 raytrace(vec3 o, vec3 d, vec3 s, vec3 L) {\n  \n  hit_t res = hit_t(1e5, vec3(0), vec3(-1.0));\n\n  vec3 X = vec3(1.0, 0.0, 0.0);\n  vec3 Y = vec3(0.0, 1.0, 0.0);\n  vec3 Z = vec3(0.0, 0.0, 1.0);\n\n  vec2 wall_lo = vec2(-dsize, -rad);\n  vec2 wall_hi = vec2( dsize,  1e4);\n\n  vec3 wc = vec3(0.8, 0.8, 1.0);\n  vec3 fc = vec3(1.0, 0.9, 0.7);\n\n  if (plane(o, d,  Z, -dsize, X, Y, wall_lo, wall_hi, wc, res) ||\n      plane(o, d, -Z, -dsize, X, Y, wall_lo, wall_hi, wc, res) ||\n      plane(o, d,  X, -dsize, Z, Y, wall_lo, wall_hi, wc, res) ||\n      plane(o, d, -X, -dsize, Z, Y, wall_lo, wall_hi, wc, res) ) {\n    // fade walls out\n    vec3 p = o+res.t*d;\n    res.color *= 1.0 - p.y/smax;\n  }\n\n  if (plane(o, d,  Y, -rad, X, Z, vec2(-dsize), vec2(dsize), fc, res)) {\n    // fake shadow with incorrect lighting, whatever\n    vec3 p = o+res.t*d;\n    float d = length((p-s).xz);\n    float u = clamp(0.75*(1.0 - s.y/hmax), 0.0, 1.0);\n    res.color *= smoothstep(d, 0.0, 0.5*rad)*u + (1.0-u);\n  }\n\n  vec3 lgray = vec3(0.8);\n\n  sphere(o, d, s, rad, vec3(1.0, 0.0, 0.0), res);\n\n  if (res.color.x >= 0.0) {\n     res.color *= (clamp(dot(res.N, L), 0.0, 1.0) * 0.7 + 0.3);\n     res.color = mix(res.color, vec3(1.0), \n                     pow(clamp(dot(res.N, normalize(L-d)),0.,1.),40.0));\n     return res.color;\n  } else {\n    return vec3(0.0);\n  }\n\n}\n\n//////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n  //////////////////////////////////////////////////\n  // figure out where the ball is\n\n  vec2 txz = iTime + txz0;\n  float ty = iTime + ty0;\n\n  vec3 ball_pos = vec3(0.0);\n\n  float fy = 1.0 - (1.0-gamma)*ty/Ty0;\n\n  float lg = log(gamma);\n\n  if (fy > 1e-4) {\n\n    float n = floor( log( fy ) / lg );\n    float gn = pow(gamma, n);\n\n    float dyn = dy0 * gn;\n    ty -= Ty0 * (1.0 - gn) / (1.0 - gamma);\n\n    ball_pos.y = -0.5*g*ty*ty + dyn*ty;\n\n  }\n\n  vec2 fxz = 1.0 - (1.0 - invgamma)*txz/Txz0;\n\n  float lig = log(invgamma);\n  vec2 nxz = floor( log(fxz) / lig );\n  vec2 ign = pow(vec2(invgamma), nxz);\n  vec2 sxz = mod(nxz, 2.0)*2.0 - vec2(1.0);\n\n  txz -= Txz0 * vec2(1.0 - ign) / vec2(1.0 - invgamma);\n  vec2 dxzn = dxz0/ign;\n  ball_pos.xz = sxz*(size - txz*dxzn);\n\n  //////////////////////////////////////////////////\n  // now raytrace the scene\n\n  vec2 rot = vec2(2.0, 1.0)*M_PI*(iMouse.xy - 0.5*iResolution.xy) / iResolution.xy;\n\n  if (iMouse.x<=0.0 || iMouse.y<=0.0){\n    rot = vec2(0.0);\n  }\n\n  mat3 Ry = mat3( cos(rot.x), 0.0, -sin(rot.x),\n                  0.0, 1.0, 0.0,\n                  sin(rot.x), 0.0, cos(rot.x));\n  \n  mat3 Rx = mat3( 1.0, 0.0, 0.0,  \n                  0.0, cos(rot.y), -sin(rot.y),\n                  0.0, sin(rot.y), cos(rot.y) );\n\n  vec3 t = vec3(0.0, 1.1*size, 0.0);\n  vec3 o = t + Ry*Rx*(vec3(0.0, t.y, 6.4*size)-t);\n\n  vec3 rz = normalize(t-o);\n  vec3 rx = normalize(cross(rz, vec3(0.0, 1.0, 0.0)));\n  vec3 ry = cross(rz, rx);\n\n  float px = (fragCoord.x - iResolution.x*0.5);\n  float py = (-fragCoord.y + iResolution.y*0.5);\n\n  vec3 d = normalize( rx*px + ry*py + rz*2.25*iResolution.y );\n\n  vec3 L = Ry*Rx*normalize(vec3(-1.0, 1.0, 2.0));\n\n  fragColor.xyz = raytrace(o, d, ball_pos, L);\n  fragColor.w = 1.0;\n\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dl3Wf","date":"1380856230","viewed":1158,"name":"bounce","username":"ioccc_fan","description":"How do you do physics in a shader that can't store state?\nMouse rotates, restart is useful too. Try playing with constants ->","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","physics","hybridsystems","incorrectlighting"],"hasliked":0,"parentid":"","parentname":""}}