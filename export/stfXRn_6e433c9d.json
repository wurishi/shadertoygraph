{"ver":"0.1","info":{"id":"stfXRn","date":"1628598390","viewed":54,"name":"test couleur","username":"TFoucour","description":"test couleur\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["testcourleur"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat dot2( vec2 v ) { return dot(v,v); }\nfloat dot2( vec3 v ) { return dot(v,v); }\nfloat ndot( vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nint objId = 0;\n\nfloat ground(vec3 p)\n{\n    return p.y+1.;\n}\n\nfloat map(vec3 p){\n    objId = 0;\n    float noise = texture(iChannel0, p).a;\n\n    float d = torus(p+vec3(0., .4+sin(iTime)*.05, -1.), vec2(.7, .05));\n    d = min(d ,torus(p+vec3(0., -.6+sin(iTime)*.05, -1.), vec2(.7, .05)));\n    d = min(d, torus(p+vec3(0., -.8+sin(iTime)*.05, -1.), vec2(.7, .05)));\n    \n    d = min(d, sphere(p+ vec3(0., sin(iTime/.5)*.1, -1.), .5)*noise*.1);\n    \n    d = min(d, ground(p));\n    //d = max(d, -sphere(p+ vec3(0., 1.+sin(iTime/.5)*.1, -1.), .5));\n   return d;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ));\n}\n\nvec3 trace( vec3 ro, vec3 rd) {\n\n    vec3 p = ro;\n    objId = 0;\n    for(int i=0; i <255; i++){\n        p += rd * map(p); \n    }\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0., 0., -1.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    vec3 p = trace(ro, rd);\n    int id = objId;\n    \n    vec3 color = vec3(.1,.3,.0);\n    \n    \n    vec3 normal = calcNormal(p);\n    vec3 soleil_direction = normalize(vec3(0.5, 1., .8));\n    \n\n    // Time varying pixel color\n    vec3 col = vec3(1.);\n    if(map(p) == ground(p)){\n        col = vec3(.4, 1., 0.) * texture(iChannel0, p).a;\n    }\n    col *= max( dot(normal,soleil_direction), 0.); \n    \n    \n    col = clamp(col, vec3(0.), vec3(1.));\n    col = mix(col, vec3(1.), min(distance(p,ro)*0.1, 1.));\n    \n\n    vec3 pshadow = trace(p+normal*.1, soleil_direction);\n    if (map(pshadow) < 1.)\n        col *= 0.25;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}