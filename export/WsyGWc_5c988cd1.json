{"ver":"0.1","info":{"id":"WsyGWc","date":"1571049132","viewed":190,"name":"Phase Distortion Synth+Drums","username":"mohragk","description":"Multivoice drone syntesizer and drummachine.","likes":4,"published":1,"flags":8,"usePreview":0,"tags":["sound","audio","synth","drone","drum","drums"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n#define TAU 2. * PI\n\nfloat rand(float n){\n    return fract(sin(n*87654.321)*54321.123);\n}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n  \tfloat fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n\nvec3 saturate(vec3 a)\n{\n    return clamp(a, 0., 1.);\n}\n\nvec2 saturate(vec2 a)\n{\n    return clamp(a, 0., 1.);\n}\n\nfloat saturate(float a)\n{\n    return clamp(a, 0., 1.);\n}\n\nfloat getSkewedPhase(float phase, float skew) {\n    float warpedPhase;\n    \n    float m1;\n    float m2;\n    float b2;\n    \n    float x1 = skew;\n    float currentPhase = fract(phase);\n    \n    if (x1 <= 0.)\n        x1 = 0.00001;\n    \n    m1 = .5 / x1;\n    m2 = .5 / (1. - x1);\n    b2 = 1. - m2;\n    \n    if (currentPhase < x1) {\n        warpedPhase = m1 * currentPhase;\n    } else {\n        warpedPhase = m2 * currentPhase + b2;\n    }\n    \n    return fract(warpedPhase);\n}\n\n\n\nfloat getSaw(float phase, float skew) {\n    return cos(TAU * getSkewedPhase(phase, skew));\n}\n\nfloat getSquare(float phase, float skew) {\n    float warpedPhase;\n    warpedPhase = getSkewedPhase(2. * phase, skew) * .5;\n    \n    if (phase >= .5)\n        warpedPhase += .5;\n    \n    return cos(warpedPhase * TAU);\n}\n\nfloat getPhase (float time, float freq){\n    return fract(time * freq);\n}\n\nfloat phaseShift(float phase, float shift) {\n    return fract(phase + fract(shift));\n}\n\n\n\nfloat getLFOForSkew (float freq, float time, float A) {\n    float val = 0.5 * (cos(TAU * fract(time * freq)  ) + 1. ) * A  ;\n    \n    return map(val, 0., 1., 0.5, 1.);\n}\n\nfloat getLFO(float freq, float time, float A) {\n    float phase = fract(time * freq);\n    return sin( TAU * phase ) *  A ;\n}\n\nfloat getOffsettedFreq(float semitoneOffset, float freq) {\n    float pwr = semitoneOffset / 12.;\n    return pow(2., pwr) * freq;\n}\n\nfloat noteToFreq (float note) {\n    float term = (note - 69.) / 12.;\n    float p = pow(2., term);\n    return 440. * p;\n}\n\nfloat env(float t, float tail) {\n    float release = 1. / tail;\n    return saturate(1.0-sqrt(t)*release)*2.0;\n}\n\n\nfloat kick(float t, float note, float tail)\n    \n{\n    float release = 1. / tail;\n    \n    float f = noteToFreq(note);\n    f += f*6. * env(t, tail/8.);\n\treturn sin(t * f * TAU) * saturate(1.0-sqrt(t)*release)*2.0;\n}\n\n\nfloat hihatClosed(float t)\n{\n\treturn rand(t) * saturate(1.0-sqrt(t*13.0));\n}\n\n\nfloat snare(float t, float decay) {\n    float release = 1. / decay;\n    float ns = rand(t) * saturate(1.0-pow(t*4.0, release))*1.6;\n    float tone = kick(t, 29., decay/2.);\n\treturn (ns + tone) / 2.;\n}\n\nvec2 getVoice(float note, float detune, float time) {\n    \n    float f = noteToFreq(note);\n    f = getOffsettedFreq(detune, f);\n    \n    float gain = 0.25;\n    float lfo_f = 0.16;\n    float lfo_gain = .79;\n    \n    \n    float phase = getPhase(time, f);\n    \n    float lfo = getLFOForSkew(lfo_f, time, lfo_gain) ;\n    float signal_left  = getSaw(phase, lfo) * gain;\n    \n    \n    phase = getPhase(time, f * 1.02);\n    \n    lfo = getLFOForSkew(lfo_f, time, lfo_gain * .96);\n    float signal_right = getSquare(phaseShift(phase, 0.21), lfo) * gain;\n    \n    return vec2(signal_left, signal_right);\n    \n}\n\nvec2 synth(float time, float note) {\n    int numVoices = 3;\n    \n    vec2 signal;\n    \n    for (int i=0; i<numVoices; i++) {\n        \n        float detune =  .17 * float(i);\n        \n        if (i % 2 == 0) detune *= -1.;\n        \n        vec2 voice = getVoice(note,detune, time ) / float(numVoices);\n        signal += voice * 0.75;\n        \n    }\n    \n    return signal;\n}\n\nvec2 drumMachine(float time, float bpm) {\n    vec2 audio;\n    \n    float measure = floor(time*0.5*bpm/60.0);\n    float measure4 = floor(time*2.0*bpm/60.0);\n    float measure8 = floor(time*4.0*bpm/60.0);\n    float beatH2 = fract(time*0.5*bpm/60.0)*2.0;\n    float beat1 = fract(time*bpm/60.0);\n    float beat2 = fract(time*2.0*bpm/60.0)*0.5;\n    float beat4 = fract(time*4.0*bpm/60.0)*.25;\n    \n    { \n        audio += vec2( kick( beat1, 21., .75  ) *.63) ; \n        audio += vec2( snare(beatH2, 2.05) * .42  );\n        \n        audio += vec2( hihatClosed(beat4) * .15, hihatClosed(fract(beat4 ) ) * .13 );\n        \n        \n        float note = 39.;\n        \n        if(rand(measure4 + 0.4) > 0.73) {\n            float newNote = getOffsettedFreq(3., note);\n            audio += synth(time, newNote) * 1.3;\n        }\n        \n        audio += synth(time, note) * 1.3;\n      \n\t\t\n        \n    }\n    \n    return audio;\n    \n}\n\nvec2 mainSound( in int samp, float time )\n{\n   \n    vec2 audio;\n    float bpm = 123.15;\n    audio = drumMachine(time, bpm);\n   \n   \n    return clamp(audio * .75, -1., 1.);\n}","name":"Sound","description":"","type":"sound"}]}