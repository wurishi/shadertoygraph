{"ver":"0.1","info":{"id":"WdVXDt","date":"1575553720","viewed":2183,"name":"2D Water Ripples","username":"sapporo_dynamite","description":"2D Water Ripples\n[Control]\nRipple: Drag/Click Mouse ","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["2d","ripples","water","cell","gpgpu"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\t2D Water Ripples\n\n\tImplements 2D Water Efffects\n\n\tauthor:\n\tsapporo_dynamite/2019 \n\n\tLicense :\n\tCreative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n　　URL：\n    December 1999: 2D Water Effects jeff lander\n    Darwin 3D \n\thttp://www.darwin3d.com/gdm1999.htm\n*/\n\n/*\n2019/12/05\n  1.0.0 → 1.0.0\n    ・1st release \n\n2019/12/03\n  0.0.0 → 1.0.0\n    ・start\n\n*/\n\n// 21 - 2D Rain on texture  by Krabcode\n// https://www.shadertoy.com/view/wsdyRl\nvec3 gammaCorrection(vec3 rgb){\n    float gamma = 2.2;\n    rgb = smoothstep(0., 1., rgb);\n    return pow(max(rgb, 0.), vec3(1.0/gamma));\n}\n\nvec4 getBuffer( in vec2 fragCoord )\n{\n    if (fragCoord.x >= 0. && fragCoord.x < float(iResolution.x) && fragCoord.y >= 0. && fragCoord.y < float(iResolution.y))\n    {\n     \tvec2 uv =  (fragCoord.xy + 0.5) / vec2(iResolution.xy);\n     \treturn texture(iChannel0, uv, -100.0);\n    }\n    return vec4(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n#if 1   \n    // Output to screen\n    fragColor = getBuffer(floor(fragCoord)).rrrr + vec4(0.0, 0.0, 0.9, 1.0);\n    fragColor = min(vec4(1), fragColor);\n    fragColor = max(vec4(0), fragColor);\n    fragColor = vec4(gammaCorrection(fragColor.rgb), 1);\n#else\n    \n    // 21 - 2D Rain on texture  by Krabcode\n    // https://www.shadertoy.com/view/wsdyRl\n    float waveHeight;\n    vec4 buffers = getBuffer(floor(fragCoord));\n    waveHeight = buffers.r;\n    vec2 refractOffset = buffers.zw;;\n    vec3 col = texture(iChannel1, uv+waveHeight*refractOffset).rgb;\n    fragColor = vec4(gammaCorrection(col), 1);\n#endif    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float getPrevBuffer( in vec2 fragCoord)\n{\n    if (fragCoord.x >= 0. && fragCoord.x < float(iResolution.x) && fragCoord.y >= 0. && fragCoord.y < float(iResolution.y))\n    {\n     \tvec2 uv =  (fragCoord.xy + 0.5) / vec2(iResolution.xy);\n     \treturn texture(iChannel0, uv, -100.0).x;\n    }\n    return vec4(0.).x;\n}\n\nfloat getCurrentBuffer( in vec2 fragCoord)\n{\n    if (fragCoord.x >= 0. && fragCoord.x < float(iResolution.x) && fragCoord.y >= 0. && fragCoord.y < float(iResolution.y))\n    {\n     \tvec2 uv =  (fragCoord.xy + 0.5) / vec2(iResolution.xy);\n     \treturn texture(iChannel1, uv, -100.0).x;\n    }\n    return vec4(0.).x;\n}\n\n\n\n\nfloat disk(vec2 r, vec2 center, float radius) \n{\n\treturn 1.0 - smoothstep( radius-0.5, radius+0.5, length(r-center));\n}\n\nfloat ProcessWater(in vec2 fragCoord)\n{\n    float value = float(0.);\n    \n#if 0    \n    value += getPrevBuffer(fragCoord + vec2(-2.0, 0.0) );   \n    value += getPrevBuffer(fragCoord + vec2( 2.0, 0.0) );\n    value += getPrevBuffer(fragCoord + vec2( 0.0,-2.0) );\n    value += getPrevBuffer(fragCoord + vec2( 0.0, 2.0) );\n    value += getPrevBuffer(fragCoord + vec2(-1.0, 0.0) );\n    value += getPrevBuffer(fragCoord + vec2( 1.0, 0.0) );\n    value += getPrevBuffer(fragCoord + vec2( 0.0,-1.0) );\n    value += getPrevBuffer(fragCoord + vec2( 0.0, 1.0) );\n    value += getPrevBuffer(fragCoord + vec2(-1.0,-1.0) );\n    value += getPrevBuffer(fragCoord + vec2( 1.0,-1.0) );\n    value += getPrevBuffer(fragCoord + vec2(-1.0, 1.0) );\n    value += getPrevBuffer(fragCoord + vec2( 1.0, 1.0) );\n    value /= 6.0;\n#else\n    value += getPrevBuffer(fragCoord + vec2( 0.0,-1.0) );\n    value += getPrevBuffer(fragCoord + vec2( 0.0, 1.0) );\n    value += getPrevBuffer(fragCoord + vec2(-1.0, 0.0) );\n    value += getPrevBuffer(fragCoord + vec2( 1.0, 0.0) );\n    value *= 0.5;\n#endif    \n    \n    value -= getCurrentBuffer(fragCoord + vec2( 0.0,0.0) );\n    const float DampingFactor = 0.004;\n    value -= (value * DampingFactor);\n    return value;\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat RandomFloat (vec2 cell)\n{\n    return rand(vec2(float(iFrame)*0.123+cell.x*0.645, float(iFrame)*0.453+cell.y*0.329));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixcel = floor(fragCoord);\n    \n    vec3 col = vec3(0.0);\n    \n    if(iFrame == 0)\n    {\n        fragColor = vec4(col,1.0);\n    }\n    else {\n        if( pixcel.x > 2.0 && pixcel.x < iResolution.x - 2. && pixcel.y > 2.0 && pixcel.y < iResolution.y - 2.)\n        {\n    \t\tfragColor.x = ProcessWater(pixcel);\n            \n            float size = 4.;\n            if(iMouse.z > 0.)\n            \tfragColor.x += disk(iMouse.xy, pixcel.xy, size);\n            if(iTime<=6.0){\n                if(0.7<0.9*smoothstep(1.0,0.0,length(fragCoord.xy-iResolution.xy*0.5+vec2(sin(iTime*2.0)*50.0, cos(iTime*2.0)*100.0 ))*0.026)){\n                    fragColor.x = vec4(2.0).x * step( RandomFloat( pixcel ), 0.5);\n                }\n            }  \n        }\n        else {\n\n            fragColor.x = getPrevBuffer(pixcel);\n        }\n    }\n    \n    float offsetX = getPrevBuffer(pixcel+vec2(-1., 0.)) - getPrevBuffer(pixcel+vec2(1., 0.));\n\tfloat offsetY = getPrevBuffer(pixcel+vec2(0., -1.)) - getPrevBuffer(pixcel+vec2(0., 1.));\n    vec2  waveDisplacement = vec2(offsetX, offsetY);\n\n    fragColor.xy = min(vec2( 2), fragColor.xy);\n    fragColor.xy = max(vec2( 0), fragColor.xy);\n    fragColor.zw = waveDisplacement;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float getPrevBuffer( in vec2 fragCoord)\n{\n    if (fragCoord.x >= 0. && fragCoord.x < float(iResolution.x) && fragCoord.y >= 0. && fragCoord.y < float(iResolution.y))\n    {\n     \tvec2 uv =  (fragCoord.xy + 0.5) / vec2(iResolution.xy);\n     \treturn texture(iChannel0, uv, -100.0).x;\n    }\n    return vec4(0.).x;\n}\n\nfloat getCurrentBuffer( in vec2 fragCoord)\n{\n    if (fragCoord.x >= 0. && fragCoord.x < float(iResolution.x) && fragCoord.y >= 0. && fragCoord.y < float(iResolution.y))\n    {\n     \tvec2 uv =  (fragCoord.xy + 0.5) / vec2(iResolution.xy);\n     \treturn texture(iChannel1, uv, -100.0).x;\n    }\n    return vec4(0.).x;\n}\n\n\n\n\nfloat disk(vec2 r, vec2 center, float radius) \n{\n\treturn 1.0 - smoothstep( radius-0.5, radius+0.5, length(r-center));\n}\n\n\n \nfloat ProcessWater(in vec2 fragCoord)\n{\n    float value = vec4(0.).x;\n    \n#if 0    \n    value += getPrevBuffer(fragCoord + vec2(-2.0, 0.0) );   \n    value += getPrevBuffer(fragCoord + vec2( 2.0, 0.0) );\n    value += getPrevBuffer(fragCoord + vec2( 0.0,-2.0) );\n    value += getPrevBuffer(fragCoord + vec2( 0.0, 2.0) );\n    value += getPrevBuffer(fragCoord + vec2(-1.0, 0.0) );\n    value += getPrevBuffer(fragCoord + vec2( 1.0, 0.0) );\n    value += getPrevBuffer(fragCoord + vec2( 0.0,-1.0) );\n    value += getPrevBuffer(fragCoord + vec2( 0.0, 1.0) );\n    value += getPrevBuffer(fragCoord + vec2(-1.0,-1.0) );\n    value += getPrevBuffer(fragCoord + vec2( 1.0,-1.0) );\n    value += getPrevBuffer(fragCoord + vec2(-1.0, 1.0) );\n    value += getPrevBuffer(fragCoord + vec2( 1.0, 1.0) );\n    value /= 6.0;\n#else\n    value += getPrevBuffer(fragCoord + vec2( 0.0,-1.0) );\n    value += getPrevBuffer(fragCoord + vec2( 0.0, 1.0) );\n    value += getPrevBuffer(fragCoord + vec2(-1.0, 0.0) );\n    value += getPrevBuffer(fragCoord + vec2( 1.0, 0.0) );\n    value *= 0.5;\n#endif    \n    \n    value -= getCurrentBuffer(fragCoord + vec2( 0.0,0.0) );\n    const float DampingFactor = 0.004;\n    value -= (value * DampingFactor);\n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixcel = floor(fragCoord);\n        \n    vec3 col = vec3(0.0);\n    \n    if(iFrame == 0)\n    {\n        fragColor = vec4(col,1.0);\n    }\n    else {\n        if( pixcel.x > 2.0 && pixcel.x < iResolution.x - 2. && pixcel.y > 2.0 && pixcel.y < iResolution.y - 2.)\n        {\n    \t\tfragColor.x = ProcessWater(pixcel);  \n        }\n        else {\n\n            fragColor.x = getPrevBuffer(pixcel);\n        }\n    }\n    float offsetX = getPrevBuffer(pixcel+vec2(-1., 0.)) - getPrevBuffer(pixcel+vec2(1., 0.));\n\tfloat offsetY = getPrevBuffer(pixcel+vec2(0., -1.)) - getPrevBuffer(pixcel+vec2(0., 1.));\n    vec2  waveDisplacement = vec2(offsetX, offsetY);\n\n    fragColor.xy = min(vec2( 2), fragColor.xy);\n    fragColor.xy = max(vec2( 0), fragColor.xy);\n    fragColor.zw = waveDisplacement;\n}","name":"Buffer B","description":"","type":"buffer"}]}