{"ver":"0.1","info":{"id":"Md2fWm","date":"1500898258","viewed":465,"name":"â™« [SH17B] Cosmos","username":"patu","description":"My little contribution to the compo.","likes":9,"published":1,"flags":96,"usePreview":0,"tags":["cosmos","sh17b"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \n\n\t\n\thttp://bit.ly/shadertoy-plugin\n \n\n\n*/\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec2 p = 1. / iResolution.xy;\n    p.y = 0.;\n    vec4 orgColor = (\n        texture(iChannel0, uv)\n    \t+ texture(iChannel0,uv + p.xy)\n        \t+ texture(iChannel0,uv + p.yx)\n        \t+ texture(iChannel0,uv - p.xy)\n        \t+ texture(iChannel0,uv - p.yx)\n         \n    ) * .5;\n    \n    orgColor = mix(\n        orgColor.rgba, \n        orgColor.rgba * .2, \n        clamp(\n        \tmin(1., pow(length(uv -.5) * 1.4, 1.4)) * 1.1,\n            0.,\n            1.\n        )\n    );\n    \n    fragColor = orgColor;\n    //fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MdfXWB","filepath":"https://soundcloud.com/ashaneen/piotr-janeczek-ambient-music-for-relaxation-meditation-massage-and-sleep-album-sampler","previewfilepath":"https://soundcloud.com/ashaneen/piotr-janeczek-ambient-music-for-relaxation-meditation-massage-and-sleep-album-sampler","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0},{"id":"lsXSDB","filepath":"https://soundcloud.com/martin-klekner/pale-blue-dot","previewfilepath":"https://soundcloud.com/martin-klekner/pale-blue-dot","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define t (iChannelTime[0] * .4)\n#define FOV 100.0\n#define PI 3.14159265\n#define H(P) fract(sin(dot(P,vec2(127.1,311.7)))*43758.545)\nconst float ITERS = 12.;\n\nvec3 pal( in float t1, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t1+d) );\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat hash12(vec2 p) \n{\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat noise(vec2 p){\n\treturn fract(sin(fract(sin(p.x) * (4313.13311)) + p.y) * 3131.0011);\n}\n\nfloat noiseF( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash12( i + vec2(0.0,0.0) ), \n                     hash12( i + vec2(1.0,0.0) ), u.x),\n                mix( hash12( i + vec2(0.0,1.0) ), \n                     hash12( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat noiseFF(in vec2 uv) {\n    uv *= 5.;\n    \n \tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    \n    float f  = 0.5000*noiseF( uv ); uv = m*uv;\n    f += 0.2500*noiseF( uv ); uv = m*uv;\n    f += 0.1250*noiseF( uv ); uv = m*uv;\n    f += 0.0625*noiseF( uv ); uv = m*uv;   \n    \n    return f;\n}\n\n\nfloat length2(vec2 p) { return dot(p, p); }\nfloat worley(vec2 p) {\n\tfloat d = 1e2;\n\tfor (int xo = -1; xo <= 1; ++xo)\n\t\tfor (int yo = -1; yo <= 1; ++yo) {\n\t\t\tvec2 tp = floor(p) + vec2(xo, yo);\n\t\t\td = min(d, length2(p - tp) + noise(tp) * 1.);\n\t\t}\n\treturn 15.* exp(-2.*abs(2.*d - 1.));\n}\n\nvec3 flare(float i, vec2 uv)\n{\n    vec3 fragColor = vec3(0);\n\tvec3 flareColor = vec3(0);    \n    \n    float uvxs = abs(uv.x);\n    float uvys = abs(uv.y);\n    \n    flareColor += 1. - smoothstep(-0.05 - uvys, 0.05, uvxs);\n    flareColor += 1. - smoothstep(-0.05 - uvxs, 0.05, uvys);\n    \n    uv *= mat2(cos(PI / 4.), -sin(PI / 4.), sin(PI / 4.), cos(PI / 4.));\n    \n    uvxs = abs(uv.x * 2.);\n    uvys = abs(uv.y * 2.);\n    \n    flareColor += 1. - smoothstep(-0.05 - uvys, 0.05, uvxs);\n    flareColor += 1. - smoothstep(-0.05 - uvxs, 0.05, uvys);\n    \n    float n = hash12(vec2(i * i * 3.)) * .7 -.2;\n    if (length(uv) < .2 + n && length(uv) > .1 + n) {\n    \tflareColor += abs(1.-i / ITERS - .5) * abs(atan(-uv.x, uv.y)) * abs(sin(i)) * pow(abs(sin((n + length(uv) - 1.1 + n) * 10. * PI) * 1.1), 5.) * .1 ;//* noiseF(uv * 30.);\n        \n    } \n \treturn abs(flareColor * .4);\n}\n\n\nvoid mainImage(out vec4 F, in vec2 fragCoord) \n{\n    vec2 \n        ouv = fragCoord.xy / iResolution.xy,\n\t\tuv = ouv - .5,\n        nuv;\n    uv += sin(iTime - cos(iTime * .05 )) * .01;\n    F = abs(vec4(sin(t ) * .1, 0.1, 0.15, 2.2) * .07 * noiseF(ouv * 4. + t * .1) * .9);\n    \n    \n    uv.y /= iResolution.x / iResolution.y;\n    ouv = uv * .4 ;\n\n\t\n    for (float i = 0.; i < ITERS; i++) {\n        \n        uv = ouv;\n        float ti = mod(mod(t, ITERS) + i, ITERS) / ITERS;\n        \n        uv *= 1. - ti;\n        nuv = uv;\n        pR(uv, sin(i) * 5. + noiseFF(uv * 12.));// + t * .3 - length(uv) + i);\n        \n        float c = worley(vec2(uv.xy * 23. + 1. + i + (t) * 0.05)) * .1 * noiseF(sin(2. + i) * uv * 20.) * 2.;\n        c = clamp(c, 0.0, 1.) * 1.;\n        \n        vec3 col = pal(c, vec3(0.5, 0.,0.2),vec3(i / 16.,0.,0.5),vec3(1.0,i / 16.,0.0),vec3(0.5,0.20,0.25) );\n\t\tcol *= noiseF(nuv * 60.) + .4;\n        F.rgb = mix(F.rgb ,col, pow(abs(c * 0.12) * ti * 2., 2.));// * col;\n        \n        for (float j=0.; j<4.;j+= 1.) {\n            nuv += hash12(vec2(j /4.)) * .07;\n        F.rgb = mix(F.rgb, vec3(1.0, 1., sin(i) * .5 + 1.).rbb, \n                    flare(i, (nuv) * 32. + \n                          vec2(\n                              hash12(\n                                  vec2(\n                                      hash12(1. +vec2(i * 2.)), \n                                      hash12(1. + vec2(3./ i))\n                                  )\n                              ) - .5,\n                              hash12(\n                                  vec2(\n                                      hash12(vec2(-i * 3.)), \n                                      hash12(vec2(-9. / i))\n                                  )\n                              ) - .5\n                          ) * 3.) * ti * hash12(vec2(i) / 32.) * .2\n                         ) ; \n        }\n    }\n    \n    F = pow(F * 24.6, vec4(1.4));\n    \n    const float ITERS = 12.;\n    for (float i = 0.; i < ITERS; i++) {\n        uv = ouv;\n        \n        float ti = mod(mod(t, ITERS) + i, ITERS) / ITERS;\n        \n        uv *= 1. - ti;\n        \n        float c = noiseFF(vec2(uv.xy * 23. + 1. + i)) * 2.;\n        \n        vec3 col = pal(c, vec3(0.5,0.5,0.5),vec3(0.5,0.1,0.5),vec3(1.0,1.0,0.0),vec3(0.5,0.20,0.25) );\n\t\t\n        F.rgb += pow(abs(c * 0.1) * abs(ti) * 6., 4.) * col * pow(length(ouv) * 6., 4.) * 9.\n            * ((max(9., i) - 9.) / 2.);\n        \n    }\n    \n    //return;\n    \n    uv = fragCoord.xy / iResolution.xy - .5;\n    uv *= 1.3;\n    vec3 \n        vuv = vec3(0., 1., 0. ), // up\n    \t\n        ro = vec3(0., 0., 0.); // pos\n    \tro.y += 0.;//-13. + iMouse.w / 10.;\n    \tro.x += 0. ;\n    \tro.z += 14.;\n    \n    vec3\n        vrp =  vec3(0., 0., 0.) ,//+ ro,\n\t\t\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \trd = normalize(\n            vpn + uv.x * u * iResolution.x/iResolution.y + uv.y * cross(vpn, u)\n        ),\n        hit,\n        ord = rd;\n        \n    float flareIntensivity = 0.;\n    for (float k = 0.; k < 60.; k++) {\n        float y = (H(vec2(k))) * 10. - 5.;\n\n        vec3 flarePos =  vec3(\n            H(vec2(k * PI / 5. / 2.) + y) * 20. - 10., \n            y,\n            abs(mod((k / 200. * PI * 4.) * 15. + t * 5., 15.)) - 15.\n        );\n        \n        flarePos.xy /=  3.;\n\n        flareIntensivity += min(1., pow(abs(dot(normalize(flarePos), rd)), 1e5 + 5e4) / (flarePos.z / 15.)) * .4;        \n    }\n    \n    F += clamp(pow(flareIntensivity, 4.), 0., 1.) * .4;\n    F = clamp(F, 0.,1.);\n   // F = mix(texelFetch(iChannel1, ivec2(gl_FragCoord), 0), abs(F), .3);\n    F = mix(texture(iChannel1, fragCoord/iResolution.xy), clamp(F, 0., 1.), .3);\n}\n\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define getNormal getNormalHex\n#define V vec3\n#define W vec2\n#define F float\n#define FAR 330.\n#define INFINITY 1e32\n#define t iTime\n#define mt iChannelTime[1]\n\n#define PI 3.14159265\n#define PHI (1.618033988749895)\n\nF \n    Z = 0., \n    J = 1., \n\tvol = 0.,\n\tnoise = 0.;\n\n\n \n\n#define H(P) fract(sin(dot(P,vec2(127.1,311.7)))*43758.545)\nF n(in vec3 p) {\n    V \ti = floor(p), \n        f = fract(p), \t\n\t    u = f*f*(3.-f-f);\n    \n    W   ii = i.xy + i.z * 5. + 5.;\n    \n    #define II(a,b) H(i.xy + i.z * W(5.0) + W(a,b))\n    \n    F \tv1 = mix(mix(II(Z,Z),II(J,Z),u.x), mix(\n            II(Z,J),II(J,J),u.x), u.y);\n    \n    #define I2(a,b) H(ii + W(a,b))\n    return max(mix(v1,mix(mix(I2(Z,Z),I2(J,Z),u.x), \n        \t\tmix(I2(Z,J),I2(J,J),u.x), \n        \t\tu.y),u.z),Z);\n}\n#define A w *= .5; s *= 2.; r += w * n(s * x);\nF B(vec3 x) {\n    F \tr = Z, w = J, s = J;\n    A A A A;\n    return r;\n}\n\n#define fromRGB(a, b, c) vec3(F(a), F(b), F(c)) / 255.;\n    \nvec3 \n    light = vec3(0. ,1., 1.),\n\tlightDir,\n\tlightColour = normalize(vec3(0.5, .6, .5) ); \n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec4 texture3d (sampler2D t, vec3 p, vec3 n, float scale) {\n\tvec3 q = p * scale;\n    q = mod(q, vec3(2.));\n    q -= 1.;\n    q = fract(abs(q));\n    return \n\t\ttexture(t, q.yz) * abs (n.x) +\n\t\ttexture(t, q.zx) * abs (n.y) +\n\t\ttexture(t, q.xy) * abs (n.z);\n}\n\n\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n\nstruct geometry {\n    float dist;\n    float materialIndex;\n    float specular;\n    float diffuse;\n    vec3 color;  \n    vec3 space;\n    float mirror;\n};\n\ngeometry geoU(geometry g1, geometry g2) {\n    if (g1.dist < g2.dist) return g1;\n    return g2;\n}\n\n\n\n\ngeometry map(vec3 p) {\n    geometry box, box2;\n    vec3 bp = p;\n\n\tp.y += 2.;\n    p.x -= 8.;\n    \n    box.diffuse = 4.;\n    box.specular = 3.;\n    box.mirror = .5;\n    box.color = vec3(.8, .5, 0.3);\n  \t\n    box2 = box;\n    \n    box2.color = vec3(1.);\n    p.z = -abs(p.z -.5);\n    box2.dist = length(p + vec3(0., -2., -.2)) - 1.5;\n    box2.space = p;\n    p.y /= 2.7;\n    p.z /= .9;\n    p.x -= (sin(p.y + .6) * sign(p.x) / 2.) * .3;\n    p.z -= 2.;\n    p.x *= 1.3;\n//p.x -= min(0., p.y);\n  //  p.x = abs(p.x);\n    p.z *= 1.;\n    box.dist = length(p) - 3.;\n    box.space = p;\n    box = geoU(box, box2);\n    \n    return box;\n}\n\n\n\nfloat t_max = FAR;\nconst int MAX_ITERATIONS = 90;\n\ngeometry trace(vec3 o, vec3 d, int maxI) {\n\n    float omega = 1.;\n    float t = .01;\n    float candidate_error = INFINITY;\n    float candidate_t = t;\n    float previousRadius = 0.;\n    float stepLength = 0.;\n    float pixelRadius = //tan(radians (FOV) / 2.0) \n        1. / 250.;\n    float functionSign = map(o).dist < 0. ? -1. : +1.;\n    geometry mp;\n    \n    for (int i = 0; i < MAX_ITERATIONS; ++i) {\n        if (maxI > 0 && i > maxI) break; \n        mp = map(d * t + o);\n        float signedRadius = functionSign * mp.dist;\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 1. &&\n        (radius + previousRadius) < stepLength;\n        if (sorFail) {\n            stepLength -= omega * stepLength;\n            omega = 1.;\n        } else {\n        stepLength = signedRadius * omega;\n        }\n        previousRadius = radius;\n        float error = radius / t;\n        if (!sorFail && error < candidate_error) {\n            candidate_t = t;\n            candidate_error = error;\n        }\n        if (!sorFail && error < pixelRadius || t > t_max) break;\n        t += stepLength;\n   \t}\n    \n    mp.dist = candidate_t;\n    \n    if (\n        (t > t_max || candidate_error > pixelRadius)\n    \t) mp.dist = INFINITY;\n    \n    \n    return mp;\n}\n\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 15;\n    vec3 rd = (lp - ro); // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .05;\n    float end = max(length(rd), .01);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = map(ro + rd * dist).dist;\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k * h / dist)); \n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.0), 1.0);\n}\n\n\n//\tnormal calculation\nvec3 normal(vec3 pos) {\n    float eps=.0001, d = map(pos).dist;\n\treturn normalize(vec3(map(pos+vec3(eps,0,0)).dist-d,map(pos+vec3(0,eps,0)).dist-d,map(pos+vec3(0,0,eps)).dist-d));\n}\n\nfloat getAO(vec3 hitp, vec3 normal, float dist)\n{\n    return clamp(map(hitp + normal * dist).dist / dist, .3, 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  \n    F \tmat = 0.,\n        camShY = 0.;\n    \n    \n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n    uv *= 1.3;\n    \n    light = vec3(0., 0., 100.);        \n    float ys=  + sin(iTime) / 2. - .8;\n    vec3 \n        vuv = vec3(0., 1., 0. ), // up\n    \t\n        ro = vec3(0., 0., 0.); \n    \tro.y += ys;\n    \tro.x += 0. ;\n    \tro.z += 14.;\n    vec3\n        vrp =  vec3(0., ys, 0.) ,//+ ro,\n\t\t\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \trd = normalize(\n            vpn + uv.x * u * iResolution.x/iResolution.y + uv.y * cross(vpn, u)\n        ),\n        hit,\n        ord = rd;\n        \n\t\n    vec3 sceneColor = vec3(1.);\n    \n    geometry tr = trace(ro, rd, 90);    \n    \n    hit = ro + rd * tr.dist;\n\tvec3 ohit = hit;\n    float odist = tr.dist;\n    vec3 sn = normal(hit);\t\n    float alpha = 1.;\n\t\n    if (tr.dist < FAR) { \n            float mirror = tr.mirror;\n            vec3 refSceneColor = sceneColor;\n            rd = reflect(rd, sn);\n            sceneColor = texture3d(iChannel1, \n                                      tr.space, sn, .56).rgb;\n\n            refSceneColor = texture3d(iChannel0, \n                                      vec3(3.) + tr.space * vec3(.2, 1., 1.), sn, .246).rgb;\n\t\t\t\n            refSceneColor = mix(refSceneColor, refSceneColor.rrr, .5);\n\n            sceneColor = refSceneColor * .3;\n     \n        \n    } else {\n        sceneColor = texture(iChannel0, (uv / 2.) + .5).rgb;\n    }\n    \n    \n    fragColor = vec4(clamp(sceneColor * (1. - length(uv) / 3.5), 0.0, 1.0), 1.0);\n    fragColor = pow(fragColor, vec4(1.2));\n    fragColor.rgb = fragColor.rgb / vec3(1.3,1.2, 1.3) * 1.4;\n    fragColor.rgb = pow(fragColor.rgb * 1.4, vec3(1.1)) * 1.7 ;\n\tfragColor.a = alpha;\n}\n\n","name":"Buf B","description":"","type":"buffer"}]}