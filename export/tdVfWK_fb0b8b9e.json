{"ver":"0.1","info":{"id":"tdVfWK","date":"1608011411","viewed":229,"name":"Pack mat4 to vec4","username":"sdfgeoff","description":"Ever wanted to store a transform in a pixel? Here's one way to do so. Ended up not being as useful as I had hoped because it's hard to interpolate rotation matrices.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["buffer","pack","unpack","memory","store"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 pack_matrix(mat4 trans) {\n    // Converts a transformation matrix into a vec3 using some tricks/\n    // Yes it does lose precision, and it doesn't support scaling\n    // only rotation and translation.\n    \n    // A rotation matrix consists of three vectors and if there is no scaling\n    // we know these vectors:\n    // 1) Are unit length, so we can derive the z component from the x and y\n    // 2) Are orthognal, so we can derive the z axis from the x and y axis.\n    \n    // So all we need to store the rotation are the x and y components of\n    // the X and Y axis.\n    \n    return vec4(\n        uintBitsToFloat(packSnorm2x16(trans[0].xy)), // X axis\n        uintBitsToFloat(packSnorm2x16(trans[1].xy)), // Y axis\n        uintBitsToFloat(packHalf2x16(trans[3].xy)), // First two translation components\n        uintBitsToFloat(packHalf2x16(trans[3].zw)) // remaining translation components\n    );\n}\n\nmat4 unpack_matrix(vec4 packed) {\n    // Undoes the \"pack_matrix\" function.\n    mat4 trans = mat4(\n        vec4(unpackSnorm2x16(floatBitsToUint(packed.x)), 0.0, 0.0),\n        vec4(unpackSnorm2x16(floatBitsToUint(packed.y)), 0.0, 0.0),\n        vec4(0.0),\n        vec4(unpackHalf2x16(floatBitsToUint(packed.z)), unpackHalf2x16(floatBitsToUint(packed.w)))\n    );\n    // Derive the third component of the X and Y axis knowing that they are unit length\n    trans[0].z = sqrt(1.0 - pow(trans[0].x, 2.0) - pow(trans[0].y, 2.0));\n    trans[1].z = sqrt(1.0 - pow(trans[1].x, 2.0) - pow(trans[1].y, 2.0));\n    \n    // Derive the Z axis of the rotation matrix as it is orthogonal\n    trans[2] = vec4(cross(trans[0].xyz, trans[1].xyz), 0.0);\n\n    return trans;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}