{"ver":"0.1","info":{"id":"4fsBR2","date":"1724208774","viewed":31,"name":"CellWall3D","username":"lukejsmithluo","description":"Thanks for : https://www.shadertoy.com/view/4t2SWW\nBase On My Shader CellWall https://www.shadertoy.com/view/XX3GzX\nThis is CellWall 3D Version\nCode Need Optimize","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["colorful","cell","dynamic","cellwall"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 100.0\n#define MAX_STEPS 100\n#define SURF_DIST 1e-03\n#define PI 3.14159265359\n#define TAU (2.0*PI)\n\n//Rotation2D Function\nmat2 Rot(in float angle)\n{\n    float a = sin(angle);\n    float b = cos(angle);\n    return mat2(b, -a, a, b);\n}\n\nvec3 effect(vec2 g) \n{\n    float t = iTime * 1.5;\n    g /= 200.;\n    g.x += t * .015;\n    g.x *= sin(t * 2e-03) * cos(t * 1e-03) * g.x * 0.5;\n\tg.y -= sin(g.x + (t * 0.12 + cos(g.x) + sin(g.y))) * 0.24;\n\tvec3 c = textureLod(iChannel1, g, 4.0 * (sin(t) * 0.5 + 0.5)).xyz;\n\tc = smoothstep(c + 0.5, c, vec3(0.71));\n    return c;\n}\n\nvec4 displacement(vec3 p)\n{\n\tvec3 col = effect(p.xz);\n    \n\tcol = clamp(col, vec3(0), vec3(1.));\n    \n\tfloat dist = dot(col,vec3(0.3)); \n    \n\treturn vec4(dist,col);\n}\n\n//3D SDFs\nfloat sdSphere(in vec3 p, in float s)\n{\n    return length(p) - s;\n}\n\n//Distance Capture Function\nvec4 GetDist(in vec3 p, in vec2 uvCoord)\n{\n    //displacement scale\n    float dScale = 1.0;\n    float dist;\n\n    float x = 6.0;\n    float z =6.0;\n\n    vec4 disp = displacement(p);\n\n    float y = 1.0 - smoothstep(0.0, 1.0, disp.x) * dScale;\n\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = uvCoord;\n\n    //DynamicRadius\n    float Mask = (cos(uv.x*sin(iTime)*1.2687*2.824+iTime) * sin(uv.y*cos(iTime)*1.4228*2.42+iTime))/3.0;\n    float r = sin(0.42);\n\n    dist = sdSphere(p, (r + Mask)+5.0 - y);\n\n    return vec4(dist, disp.yzw);\n}\n\n//Calculate Normal Function\nvec3 GetNormal(in vec3 p, in float prec, in vec2 uv)\n{\n    vec3 e = vec3(prec, 0.0, 0.0);\n    vec3 n = vec3(GetDist(p + e.xyy, uv).x - GetDist(p - e.xyy, uv).x, \n                  GetDist(p + e.yxy, uv).x - GetDist(p - e.yxy, uv).x, \n                  GetDist(p + e.yyx, uv).x - GetDist(p - e.yyx, uv).x);\n    \n    return normalize(n);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in vec2 uv)\n{\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\tfor( int i=0; i<5; i++ )\n    \n\t{\n\t\tfloat hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = GetDist(aopos, uv).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n\n\treturn clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n//RayMarching Function\nfloat RayMarch(in vec3 ro, in vec3 rd, in vec2 uv,out vec3 oP)\n{\n    float t = 0.0;\n\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * t;\n        float d = GetDist(p, uv).x;\n        t += d;\n\n        oP = p;\n        if(d == MAX_DIST || d < SURF_DIST) break;\n    }\n\n    return t;\n}\n\nvec3 createAcamera(in vec3 ro, in vec2 uvCoord)\n{\n    //View Target Point Positon\n    const vec3 la = vec3(0.0);\n    const vec3 up = normalize(vec3(0.0, 1.0, 0.0));\n    //Calculate View Target Point to Light Source Point Normalize\n    vec3 ww = normalize(la - ro);\n    //Calculate Right Side Normalize\n    vec3 uu = normalize(cross(up, ww));\n    vec3 vv = (cross(ww,uu));\n    const float fov = tan(TAU / 6.0);\n\n    return normalize(-uvCoord.x*uu + uvCoord.y*vv + fov*ww);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uvCoord = (fragCoord.xy*2.0 - iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec2 m = (iMouse.xy * 2.0 - iResolution.xy)/min(iResolution.x, iResolution.y);\n\n    //Initialise\n    vec3 ro = vec3(0.0, 0.0, -12.0);\n    vec3 rd = createAcamera(ro, uvCoord);\n\n    //\n    float lIntensity = 0.6;\n    float reflIntensity = 0.6;\n    float refrAngle = 1.2;\n    float refrIntenstiy = 0.8;\n    float bIntensity = 0.35;\n    vec3 color = vec3(0.0);\n\n    //Camera Vertical Rotation\n    ro.yz *= Rot(-m.y);\n    rd.yz *= Rot(-m.y);\n    //Camera Horizontal Rotation\n    ro.xz *= Rot(-m.x);\n    rd.xz *= Rot(-m.x);\n\n    float b;\n    vec3 p = ro;\n\n    vec3 ray, cubeRay;\n\n    float d = RayMarch(ro, rd, uvCoord, p);\n\n    if(d < MAX_DIST)\n    {\n       vec3 n = GetNormal(p, 0.1, uvCoord);\n\n       b = lIntensity;\n\n       ray = reflect(rd, n);\n       cubeRay = texture(iChannel0, ray).xyz * reflIntensity;\n\n       ray = refract(ray, n, refrAngle);\n       cubeRay += texture(iChannel0, ray).xyz * refrIntenstiy;\n\n       color = cubeRay + pow(b, 15.0);\n\n       //add light effect\n       float occ = calcAO(p, n, uvCoord);\n       vec3 lightDir = normalize(vec3(-0.6, 0.7, -0.5));\n       //AO\n       float amb = clamp(0.5 + 0.5 * n.y, 0.0, 1.0);\n       //Diffuse\n       float dif = clamp(dot(n, lightDir), 0.0, 1.0);\n       //Refraction Brightness\n       float bac = clamp(dot(n, normalize(vec3(-lightDir.x, 0.0, -lightDir.z))), 0.0, 1.0) * clamp(1.0 - p.y, 0.0, 1.0);\n       //Bottom Brightness\n       float dom = smoothstep(-0.1, 0.1, cubeRay.y);\n       //Edge Brightness\n       float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n       //Specular\n       float spe = pow(clamp(dot(cubeRay, lightDir), 0.0, 1.0), 16.0);\n       \n       //add Color\n       vec3 brdf = vec3(0.0);\n       brdf += 1.20*dif*vec3(0.5373, 0.8392, 0.9333);\n       brdf += 1.20*spe*vec3(0.0, 0.7059, 0.9216)*dif;\n       brdf += 0.30*amb*vec3(0.9608, 0.8863, 0.7804)*occ;\n       brdf += 0.40*dom*vec3(0.9059, 0.7412, 0.5098)*occ;\n       brdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n       brdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n       brdf += 0.02;\n\n       color = color * brdf;\n\n       color = mix(color, vec3(0.8, 0.9, 1.0), 1.0 - exp(5e-04 * d * d));\n\n       color = mix(color, GetDist(p, uvCoord).yzw, 0.5);\n    }\n    else\n    {\n        color = texture(iChannel0, rd).xyz;\n    }\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}