{"ver":"0.1","info":{"id":"Xdsyzs","date":"1489495170","viewed":100,"name":"iland","username":"mathiassoeholm","description":"First raymarching project, code could be a lot prettier :-)\nDrag mouse to rotate the scene","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Soruces:\n// - Quilez:\n// https://iquilezles.org/articles/distfunctions\n// https://iquilezles.org/articles/rmshadows\n// - Other\n// Sample raymarching code: https://www.shadertoy.com/view/XsB3Rm\n\n#define PI 3.14159265359\n\nconst int MAX_MARCHING_STEPS = 500;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0001;\n\nmat3 rotationXY(vec2 angle)\n{\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max(sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdfSphere(vec3 p, vec3 sPos, float radius)\n{\n    return length(p - sPos) - radius;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat leaf(vec3 p)\n{\n    // Bend\n    float c = cos(-0.15*p.x);\n    float s = sin(-0.15*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    p = vec3(m*p.xy,p.z);\n    \n    float caps = sdCapsule(p, vec3(0.0, 0.0, 0.0), vec3(3.0, 0.0, 0.0), 0.05);\n    \n   \tvec3 q = p - vec3(0.5, 0.0, 0.0);\n    \n    // Mirror\n    q.z = abs(q.z) - 0.5;\n    \n    // Repeat single leaf\n    float rep = 0.22;\n    q.x = mod(q.x, rep)-rep*0.5;\n\n    // Single leaf length variance\n    float l = abs(pow(sin(p.x),2.0)+0.4);\n    q.z += 0.2/l;\n    \n    q = rotationXY(-vec2(PI*0.5, 0.0)) * q;\n    \n    vec3 scale = vec3(0.25, l, 1.0);\n    float leaf = sdTriPrism(q/scale, vec2(0.6, 0.01))*min(scale.x, min(scale.y, scale.z));\n\n    return max(p.x-2.92, max(-p.x, min(caps, leaf)));\n}\n\nfloat map(vec3 p)\n{\n    // Sand\n    float result = sdfSphere(p, vec3(0,-10.0,0), 10.0);\n\n    // I get artifacs on these things, but it's fine if I use a for loop. Why?\n    float rep = 0.5;\n    vec3 q = p;\n    q.y = mod(q.y, rep) - rep*0.5;\n    result = max(p.y-4.99, min(result, sdConeSection(q, 0.25, 0.35, 0.25)));\n    \n    // Top sphere thing (hide ugly leaf connection)\n    result = min(result, sdfSphere(p, vec3(0, 4.8, 0), 0.33));\n\n    // Leafs\n    vec3 l = vec3(0.0, 5.0, 0.0);\n    result = min(result, leaf(p - l));\n    result = min(result, leaf(rotationXY(vec2(0.0, PI/2.0))*p - l));\n    result = min(result, leaf(rotationXY(vec2(0.0, PI))*p - l));\n    result = min(result, leaf(rotationXY(vec2(0.0, PI*1.5))*p - l));\n    \n    return result;\n}\n\nfloat ambientOcclusion(vec3 p, vec3 normal)\n{\n    float d = 0.0;\n    float o = 0.0;\n \tfloat stepSize = 0.1;\n \tfloat s = 20.0;\n \n    for(float k=1.0; k<5.0; k++)\n    {\n        d = map(p+normal*k*stepSize);\n        o = (1.0/pow(2.0,k))*(k*stepSize-d);\n    }\n \n return 1.0-clamp(s*o, 0.0, 1.0);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t < maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<EPSILON )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nvec3 getRay(vec2 fragCoord, vec2 res, float fieldOfView)\n{\n    // Place (0,0) in center\n    vec2 xy = fragCoord - res/2.0;\n    float z = res.y / tan(radians(fieldOfView)/2.0);\n    \n    return normalize(vec3(xy, -z));\n}\n\nfloat shortestDist(vec3 eye, vec3 direction, float near, float far)\n{\n    float depth = near;\n    \n    for (int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        float distance = map(eye + depth*direction);\n        \n        if(distance < EPSILON)\n        {\n            return depth;\n        }\n        \n        depth += distance;\n        \n        if(depth >= far)\n        {\n            return far;\n        }\n    }\n    \n    return far;\n}\n\nint shortestDistDebugSteps(vec3 eye, vec3 direction, float near, float far)\n{\n    float depth = near;\n    \n    for (int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        float distance = map(eye + depth*direction);\n        \n        if(distance < EPSILON)\n        {\n            return i;\n        }\n        \n        depth += distance;\n        \n        if(depth >= far)\n        {\n            return i;\n        }\n    }\n    \n    return MAX_MARCHING_STEPS;\n}\n\nvec3 getColor(vec3 p)\n{\n    if(p.y < 0.0)\n    {\n        return vec3(1.0, 1.0, 0.0);\n    }\n    else\n    {\n        if(length(p.xz) > 0.36 || p.y > 4.8)\n        {\n            return vec3(0.1, 0.5, 0.1);\n        }\n        \n        return vec3(0.6, 0.3, 0.1);\n    }\n}\n\nvec3 render(vec3 p, vec3 normal, vec3 eye)\n{\n    vec3 lightDir = normalize(vec3(-1, -0.5, 0.3));\n    vec3 diffuse = vec3(1, 1, 1);\n    \n    float ao = ambientOcclusion(p, normal);\n    float shadow = softshadow(p, -lightDir, EPSILON+0.01, MAX_DIST, 40.0);\n    vec3 light = max(0.0, dot(-lightDir, normal)) * diffuse;\n    vec3 color = getColor(p);\n    \n    return ao*color * 0.5 + (vec3(0.2, 0.2, 0.2) + color*0.3 + light*0.3)*shadow;\n}\n\nvec3 getNormal(vec3 p)\n{ \n    vec3 normalSDF = vec3(\n    \tmap(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n    \tmap(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n    \tmap(vec3(p.x, p.y, p.z + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON)));\n    \n    return normalize(normalSDF);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec3 dir = getRay(fragCoord.xy, iResolution.xy, 45.0);\n\tvec3 eye = vec3(0.0, 3.0, 17.0);\n    \n    // Rotate camera\n\tmat3 rot = rotationXY( ( iMouse.xy - iResolution.xy * 0.5 ).yx * vec2( 0.01, -0.01 ) );\n\tdir = rot * dir;\n\teye = rot * eye;\n    \n    float distance = shortestDist(eye, dir, MIN_DIST, MAX_DIST);\n    \n    if(distance > MAX_DIST-EPSILON)\n    {\n        float gradient = fragCoord.y/iResolution.y;\n        vec3 color = (1.0-gradient) * vec3(1.0, 0.5, 0.6) + gradient * vec3(1.0, 0.9, 1.0);\n        fragColor = vec4(color,1.0);\n        return;\n    }\n\t\n    vec3 pos = eye+dir.xyz*distance;\n    vec3 normal = getNormal(pos);\n    \n    fragColor = vec4(render(pos, normal, eye), 1.0);\n    \n    /*int steps = shortestDistDebugSteps(eye, dir, MIN_DIST, MAX_DIST);\n    fragColor = mix(vec4(0, 0, 0, 1), vec4(1, 0, 0, 1), float((steps*10000)/(MAX_MARCHING_STEPS))/10000.0);*/\n}","name":"Image","description":"","type":"image"}]}