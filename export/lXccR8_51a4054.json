{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define maxDist 100.\n#define minDist 0.001\n#define maxSteps 100\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n\n\nfloat snoise(vec2 st) {\n    st *= 4.;\n    vec2 frst = fract(st);\n    vec2 flst = floor(st);\n    \n    vec2 bl = flst + vec2(0.,0.);\n    vec2 br = flst + vec2(1., 0.);\n    vec2 tl = flst + vec2(0., 1.);\n    vec2 tr = flst + vec2(1., 1.);\n    \n    mat2 rot = mat2(cos(iTime * 2.), -sin(iTime * 2.),\n                    sin(iTime * 2.),  cos(iTime * 2.));\n    float a = dot(rot *random2(bl), st - bl);\n    float b = dot(rot *random2(br), st - br);\n    float c = dot(rot * random2(tl), st - tl);\n    float d = dot(rot * random2(tr), st - tr);\n    \n    float v = mix(a,b, smoothstep(0., 1., frst.x));\n    float w = mix(c,d, smoothstep(0., 1., frst.x));\n    float t = mix(v,w, smoothstep(0., 1., frst.y));\n    \n    return t*0.4;\n    \n}\n\nvec2 smin(float a, float b, float k) {\n    float f1 = exp2(-k * a);\n    float f2 = exp2(-k * b);\n    return vec2(-log2(f1 + f2)/k,f2);\n}\n\n\nfloat sphereSDF(vec3 point,vec4 dim) {\n    \n    float dist = length(point - dim.xyz) - dim.w;\n    return dist;\n}\n\nfloat cubeSDF(vec3 d, vec3 c, vec3 point) {\n    vec3 q = c - point;\n    q = abs(q) - d;\n    float cube = length(max(q,0.)) + min(max(q.x,max(q.y,q.z)), 0.);\n    return cube;\n  }\n\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.4, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.1) + length(max(d,0.1));\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz * 1.),p.y * 1.)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat plane(vec3 point, float updown, float h) {\n    return  updown *  point.y + snoise(point.xz) + h;\n}\n\n\nfloat SDF(vec3 point) {\n    float objects[13];\n    objects[0] =  plane(point, 1.,0.);\n    \n    objects[1] = sdCappedCylinder((point -  vec3(0., -1., 2.)), .4, 1.3);\n    objects[2] = sdCappedCylinder((point - vec3(0., 4., 2.)), .4, 1.3);\n    objects[3] = plane(point, 1., 1.);\n    objects[6] = max(objects[1], objects[3]);\n    objects[4] = plane(point, -1., 4.);\n    objects[5] = max(objects[4], objects[2]);\n    objects[7] = sphereSDF(point, vec4(0., 1.2 + cos(iTime * 0.7) * 2.2, 2, .2));\n    objects[8] = sphereSDF(point, vec4(.5, 1.2 + sin(iTime * 0.4) * 2.2, 2, .4));\n    objects[9] = sphereSDF(point, vec4(0., 1.2 + sin(iTime * 0.6) * 2.2, 2, .3));\n    objects[10] = sphereSDF(point, vec4(0.3, 1.2 + cos(iTime * 0.7) * 2.2, 2, .4));\n    objects[11] = sphereSDF(point, vec4(-.2, 1.2 + sin(1.57  + iTime * 0.4) * 2.2, 1.7, .2));\n    objects[12] = sphereSDF(point, vec4(-0.5, 1.2 + sin(iTime * 0.3) * 2.2, 2.2, .4));\n   \n    \n    \n    float k = 6.;\n\n    float db;\n    float dmin = 1e20;\n    for (int i = 6; i < 13 ; i++) {\n    \n    \n    db = smin(dmin, objects[i],k).x;\n    dmin = db;\n    \n    \n    }\n    \n    //color.xyz = sqrt(color.xyz);\n    \n    \n    return db;\n}\n    \n\n\n\nfloat rayMarch(vec3 camPos, vec3 rd) {\n    float dO = 0.;\n    for (int i = 0; i < maxSteps; i++) {\n        vec3 point = camPos + dO * rd;\n        float dist = SDF(point);\n        dO += dist;\n        if (dO > maxDist) {\n            return 19.;\n        } \n        else if (dist < minDist) {\n            return dO;\n        }\n    }\n    \n    return dO;\n}\n\nvec3 normal(vec3 p) {\n    float dis = SDF(p);\n    vec2 e = vec2(0.01, 0.);\n    \n    vec3 n = dis - vec3(SDF(p-e.xyy),\n                        SDF(p-e.yxy),\n                        SDF(p-e.yyx)); \n    \n    return normalize(n);\n}\nvec3 light(vec3 camPos, vec3 point, vec3 sunPos) {\n    vec3 n = normal(point);\n    vec3 ld = normalize(sunPos - point);\n    float dif = dot(ld, n);\n    vec3 amb = vec3(0.75);\n    vec3 diff = vec3(dif);\n    vec3 relf = normalize(reflect(-sunPos, n));\n    float l = dot(relf, normalize(camPos - point));\n    float s = max(0.,dot(normalize(camPos - point), relf));\n    float ds = max(0., dot(diff,n));\n    ds = pow(ds, -.000);\n    s = pow(s, 1191.);\n    \n    \n    return   (s*vec3(l))*100. - .7*ds*diff + .9*amb;\n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = 1. * (gl_FragCoord.xy/iResolution.xy - vec2(0.5,0.5));\n    ;\n    float k = -0.028;\n    mat2 rot = mat2(cos(k), -sin(k),\n                    sin(k),  cos(k));\n    vec3 camPos = vec3(.0, 1.4, -4.5);\n    vec3 sunPos = vec3(0., 10., -2.);\n    \n    vec3 rd = vec3(st, .9);\n    rd.zy *= rot ;\n    float scene = rayMarch(camPos, rd);\n    vec3 point = camPos + scene * rd;\n    vec3 color = vec3(scene/1.288);\n    color = light(camPos, point, sunPos);\n\n    fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lXccR8","date":"1734707123","viewed":122,"name":"oil lava lamp","username":"mojoleg","description":"the lower part is perlin noise, and i use the smoothmin function to create smooth interactions between objects","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["noise","smoothmin"],"hasliked":0,"parentid":"","parentname":""}}