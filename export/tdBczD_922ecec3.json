{"ver":"0.1","info":{"id":"tdBczD","date":"1586194896","viewed":322,"name":"Equidistant point calculation","username":"michael0884","description":"finding the equidistant point between 2 sdf's in a direction, I need that to approximate the voronoi diagram for sdfs.","likes":6,"published":3,"flags":0,"usePreview":0,"tags":["2d","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdRoundedX( in vec2 p, in float w, in float r )\n{\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\nfloat sdHexagram( in vec2 p, in float r )\n{\n    const vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nstruct object\n{\n    vec2 p;\n    vec2 r;\n    int i;\n};\n    \nfloat sdObj(vec2 p, in object o)\n{\n    switch(o.i)\n    {\n    case 0:\n    \treturn sdBox(p - o.p, o.r);\n    case 1:\n    \treturn sdHexagram(p - o.p, o.r.x);\n    case 2:\n    \treturn sdRoundedX(p - o.p, o.r.x, o.r.y);\n    default:\n        return distance(p, o.p) - o.r.x;\n    }\n}\n\nfloat eqDist(vec2 d, in object a, in object b)\n{\n    vec2 p = a.p;\n    float td = 0.;\n    for(int i = 0; i < 10; i++)\n    {\n        float dd = sdObj(p, b) - sdObj(p, a);\n        p += dd*d;\n        td += dd;\n    }\n    return td;\n}\n\nvec2 scale(vec2 pix)\n{\n    return 0.2*(pix - iResolution.xy*0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = scale(fragCoord);\n\n    object a, b;\n    a.p = vec2(0); a.r = vec2(14,1); a.i = 2;\n    b.p = 15.*vec2(sin(0.1*iTime),1.3*cos(0.1*iTime)); b.r = vec2(5.); b.i = 1;\n    \n \tfloat de0 = sdObj(uv, a);\n    float de1 = sdObj(uv, b);\n    vec3 cc;\n    if(de0 < de1) cc = vec3(1,1.02,1.05);\n    else cc =vec3(1.05,1.02,1.);\n  \tfloat de = min(de0, de1);\n    vec2 d = normalize(scale(iMouse.xy) - a.p);\n    float dd = eqDist(d, a, b);\n    float e = exp(-sdSegment(uv, a.p, a.p + dd*d));\n\n    vec3 col = smoothstep(0.4,0.6,0.5+0.5*sin(cc*de))/de \n               + vec3(0,0,1)*exp(-abs(de1-de0))\n               + e*vec3(1,0.5,0.2);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}