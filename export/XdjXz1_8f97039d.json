{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define EPS 0.02\n#define FAR 11.0\n\nvec3 A, B, C, D;\n\nfloat base(vec3 p) {\n    p.y += 0.5;\n    return length(max(abs(p)-vec3(6.0, 0.01, 2.5), 0.0))-0.2;\n}\n\nfloat pole(vec3 p, float r, float h) {\n    vec3 q = vec3(0., h-r, 0.);\n    float alpha = clamp(dot(p,q)/dot(q,q), -1., 1.);\n    return length(p - alpha*q) - r;\n}\n\nfloat disk(vec3 p, float or, float ir, float h) {\n    float d = max(length(p*vec3(1., 2., 1.)) - or, abs(p.y)-0.5*h);\n    return max(d, -pole(p, .5, 3.));\n}\n \nvec2 dist_field(vec3 p) {\n    vec2 res; float d;\n    \n    res.x = pole(p, .3, 3.);   p.x -= 4.;\n    res.x = min(res.x, pole(p, .3, 3.)); p.x += 8.;\n    res.x = min(res.x, pole(p, .3, 3.)); p.x -= 4.;\n    res.y = 0.;\n    \n    d = disk(p-A, 1.8, .65, .4); if (d < res.x) res = vec2(d, 1.);\n    d = disk(p-B, 1.6, .65, .4); if (d < res.x) res = vec2(d, 2.);\n    d = disk(p-C, 1.4, .65, .4); if (d < res.x) res = vec2(d, 3.);\n    d = disk(p-D, 1.2, .65, .4); if (d < res.x) res = vec2(d, 4.);\n    \n    d = base(p); if (d < res.x) res = vec2(d, 6.);\n    return res;\n}\n\nvec3 normal(vec3 p) {\n    vec2 q = vec2(0., EPS);\n    return normalize(vec3(dist_field(p+q.yxx).x-dist_field(p-q.yxx).x, \n                          dist_field(p+q.xyx).x-dist_field(p-q.xyx).x,\n                          dist_field(p+q.xxy).x-dist_field(p-q.xxy).x));\n}\n\nvec3 animate(vec2 a, vec2 b) {\n    vec2 res = a;\n    \n    if (abs(b.x-a.x) > 0.0) {\n        float t = fract(iTime);\n        float k1 = (1.0-step(1.0/3.0, t));\n        float k2 = step(1.0/3.0, t)*(1.0-step(2.0/3.0, t));\n        float k3 = step(2.0/3.0, t);\n        \n        res.x = k1*a.x + k2*mix(a.x,b.x,3.0*(t-1.0/3.0))+ k3*b.x;\n    \tres.y = k1*mix(a.y, 5.0, 3.0*t) + k2*5.0 + k3*(mix(5.0, b.y, 3.0*(t-2.0/3.0)));\n    }\n    return vec3(res, 0.0);\n}\n\nvoid init() {\n    // this can be optimized, but I'm lazy\n    vec2 pathA[17], pathB[17], pathC[17], pathD[17];\n    pathA[0]  = vec2(-4,0); pathB[0]  = vec2(-4.,.5);pathC[0]  = vec2(-4,1); pathD[0]  = vec2(-4,1.5);\n    pathA[1]  = pathA[0];   pathB[1]  = pathB[0];    pathC[1]  = pathC[0];   pathD[1]  = vec2(0,0);\n    pathA[2]  = pathA[0];   pathB[2]  = pathB[0];    pathC[2]  = vec2(4,0);  pathD[2]  = pathD[1];\n    pathA[3]  = pathA[0];   pathB[3]  = pathB[0];    pathC[3]  = pathC[2];   pathD[3]  = vec2(4,.5);\n    pathA[4]  = pathA[0];   pathB[4]  = pathD[1];    pathC[4]  = pathC[2];   pathD[4]  = pathD[3];\n    pathA[5]  = pathA[0];   pathB[5]  = pathB[4];    pathC[5]  = pathC[2];   pathD[5]  = pathB[0];\n    pathA[6]  = pathA[0];   pathB[6]  = pathB[4];    pathC[6]  = vec2(0,.5); pathD[6]  = pathD[5];\n    pathA[7]  = pathA[0];   pathB[7]  = pathB[4];    pathC[7]  = pathC[6];   pathD[7]  = vec2(0,1);\n    pathA[8]  = pathC[2];   pathB[8]  = pathB[4];    pathC[8]  = pathC[6];   pathD[8]  = pathD[7];\n    pathA[9]  = pathA[8];   pathB[9]  = pathB[4];    pathC[9]  = pathC[6];   pathD[9]  = pathD[3];\n    pathA[10] = pathA[8];   pathB[10] = pathB[4];    pathC[10] = pathA[0];   pathD[10] = pathD[9];\n    pathA[11] = pathA[8];   pathB[11] = pathB[4];    pathC[11] = pathC[10];  pathD[11] = pathD[5];\n    pathA[12] = pathA[8];   pathB[12] = pathD[3];    pathC[12] = pathC[10];  pathD[12] = pathD[11];\n    pathA[13] = pathA[8];   pathB[13] = pathB[12];   pathC[13] = pathC[10];  pathD[13] = pathD[1];\n    pathA[14] = pathA[8];   pathB[14] = pathB[12];   pathC[14] = vec2(4,1);  pathD[14] = pathD[13];\n    pathA[15] = pathA[8];   pathB[15] = pathB[12];   pathC[15] = pathC[14];  pathD[15] = vec2(4,1.5);\n    pathA[16] = pathA[8];   pathB[16] = pathB[12];   pathC[16] = pathC[14];  pathD[16] = pathD[15];\n   \n    for (int i = 0; i < 16; ++i) {\n        if (i != int(mod(iTime, 16.0))) continue;\n        A = animate(pathA[i], pathA[i+1]);\n        B = animate(pathB[i], pathB[i+1]);\n        C = animate(pathC[i], pathC[i+1]);\n        D = animate(pathD[i], pathD[i+1]);\n        if (step(16.0, mod(iTime, 32.0)) == 1.0) {\n        \tA.x = -A.x; B.x = -B.x; C.x = -C.x; D.x = -D.x;\n        }\n    }\n}\n\nfloat cubeMap(vec3 p, vec3 n) {\n    vec3 gamma = vec3(2.2);\n    vec3 x = pow(texture(iChannel0, p.yz).rgb, gamma);\n    vec3 y = pow(texture(iChannel0, p.xz).rgb, gamma);\n    vec3 z = pow(texture(iChannel0, p.yx).rgb, gamma);\n    vec3 res = (abs(n.x)*x + abs(n.y)*y + abs(n.z)*z)/(abs(n.x)+abs(n.y)+abs(n.z));\n    return dot(vec3(1.0), res)/3.0;\n}\n\nfloat shadow(vec3 p, vec3 l) {\n    vec2 res; float t = 2.0*EPS, sha = 1.0;\n    for (int i = 0; i < 32; ++i) {\n        res = dist_field(p + l*t);\n        if (res.x < EPS || t > FAR) break;\n        sha = min(sha, 3.0*res.x/t);\n        t += min(0.5, 0.75*res.x);\n    }\n    return res.x < EPS ? 0.0 : clamp(sha, 0.0, 1.0);\n}\n\nfloat ambocc(vec3 p, vec3 n) {\n    float res = 0.0, delta = 5.0*EPS, power = 0.5;\n    for (int i = 1; i <= 5; ++i) {\n        res += power*(delta*float(i) - dist_field(p + delta*float(i)*n).x);\n        power *= 0.5;\n    }\n    return clamp(1.0 - 5.0*res, 0.0, 1.0);\n}\n\nvec3 shade(vec3 ro, vec3 rd, float t, float id) {\n    vec3 mat = vec3(1.0), p = ro +t*rd;\n    vec3 n = id != 5.0 ? normal(p) : vec3(0.0, 1.0, 0.0);\n    \n    vec3 y = vec3(255, 174, 65)/255.;\n    vec3 g = vec3(204, 166, 31)/255.;\n         \n    if (id == 1.0)\n    \tmat = g*cubeMap(p-A, n);\n    else if (id == 2.0)\n    \tmat = y*cubeMap(p-B, n);\n    else if (id == 3.0)\n        mat = g*cubeMap(p-C, n);\n    else if (id == 4.0)\n        mat = y*cubeMap(p-D, n);\n\telse if (id == 5.0)\n        mat = vec3(1.0)*cubeMap(0.05*p, n);\n    else\n        mat = y*cubeMap(0.1*p, n);\n    \n    vec3 l = normalize(vec3(0.25, 1.0, -0.25)), h = normalize(l-rd);\n    vec3 amb = vec3(1.0);\n    float lamb = max(0.0, dot(n, l));\n    float phong = lamb > 0.0 ?  pow(max(0.0, dot(n, h)), 15.0) : 0.0;\n    float fog = exp(-0.005*t*t);\n    float sha = shadow(p, l);\n    float rim = smoothstep(0.0, 1.0, 1.0 - dot(-rd, n));\n    float ao = ambocc(p, n);\n    vec3 col = mat*fog*ao*(.7*(0.6*amb + sha*(0.5*lamb + .4*phong)) + .35*rim);\n    return col / (col + 1.0);\n}\n\nmat3 lookAt(vec3 c, vec3 t) {\n    vec3 z = normalize(c - t);\n    vec3 x = cross(vec3(0.0, 1.0, 0.0), z);\n    vec3 y = cross(z, x);\n    return mat3(x, y, z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 res, uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    \n    vec3 ro = vec3(0., 5., 5.);\n    vec3 rd = normalize(lookAt(ro, vec3(0.0, 0.0, 0.0))*vec3(uv, -1.0));\n    init();\n    \n    float t = 0.0, pl = -(.6+ro.y)/rd.y;\n    for (int i = 0; i < 64; ++i) {\n        res = dist_field(ro + t*rd);\n        if (res.x < EPS || t > FAR) break;\n        t += min(0.75*res.x, 0.5);\n    }\n    if (pl > 0. && (pl < t || t > FAR)) {t = pl; res.y = 5.0;}\n    vec3 col = pl > 0. || res.x < EPS ? shade(ro, rd, t, res.y) : vec3(0.0);\n    col = smoothstep(0.0, .17, col);\n    col = pow(col, vec3(0.45));\n    \n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdjXz1","date":"1409262697","viewed":400,"name":"Tower of Hanoi","username":"vgs","description":"The code still needs some optimization...","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["3d","animation","tower","hanoi"],"hasliked":0,"parentid":"","parentname":""}}