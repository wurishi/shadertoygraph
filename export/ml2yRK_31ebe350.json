{"ver":"0.1","info":{"id":"ml2yRK","date":"1692032903","viewed":67,"name":"Applying Force to 3D Rotors","username":"Dominexis","description":"Made by Dominexis. Complete original work.","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nCONTROLS:\n\nArrow keys/WASD -  Rotate camera\nClick and hold - Apply rotational force to the object\nSpacebar - Lock camera to object\n\n*/\n\n\n\nconst float pi = 3.14159265;\n\nconst vec4 RotorA = normalize(vec4(0.72083,0.18611,-0.31679,0.58772));\nconst vec4 RotorB = normalize(vec4(0.75754,0.089947,0.35051,-0.54331));\n\n\n\n// Transforms a vector using a rotor\nvec3 RotTrans( in vec4 r, in vec3 v )\n{\n    return vec3(\n        (\n            (r.w*r.w + r.x*r.x - r.y*r.y - r.z*r.z)*v.x +\n            2.0*(r.y*r.x + r.w*r.z)*v.y +\n            2.0*(r.z*r.x - r.w*r.y)*v.z\n        ),\n        (\n            2.0*(r.x*r.y - r.w*r.z)*v.x +\n            (r.w*r.w - r.x*r.x + r.y*r.y - r.z*r.z)*v.y +\n            2.0*(r.z*r.y + r.w*r.x)*v.z\n        ),\n        (\n            2.0*(r.x*r.z + r.w*r.y)*v.x +\n            2.0*(r.y*r.z - r.w*r.x)*v.y +\n            (r.w*r.w - r.x*r.x - r.y*r.y + r.z*r.z)*v.z\n        )\n    );\n}\n\n// Stacks rotor transformations\nvec4 RotStack( in vec4 a, in vec4 b )\n{\n    return vec4(\n        (a.w*b.x + a.z*b.y - a.y*b.z + a.x*b.w),\n        (a.w*b.y - a.z*b.x + a.y*b.w + a.x*b.z),\n        (a.w*b.z + a.z*b.w + a.y*b.x - a.x*b.y),\n        (a.w*b.w - a.z*b.z - a.y*b.y - a.x*b.x)\n        \n    );\n}\n\n// Takes the inverse of a rotor\nvec4 RotInv( in vec4 r )\n{\n    return vec4( -r.xyz, r.w );\n}\n\n// Converts a rotor to a vector of angular velocity\nvec3 RotToVec( in vec4 r )\n{\n    float l = length(r.xyz);\n    if (l == 0.0) { l = 1.0; }\n    \n    return r.xyz/l *\n    (\n        mod(\n            2.0*atan(l, r.w)\n        + pi, 2.0*pi ) - pi\n    );\n}\n\n// Converts a vector of angular velocity to a rotor\nvec4 VecToRot( in vec3 v )\n{\n    float l = length(v);\n    float a = 0.5*l;\n    if (l == 0.0) { l = 1.0; }\n    \n    return vec4(\n        v*sin(a)/l,\n        cos(a)\n    );\n}\n\n// Converts a rotor to a rotation matrix\nmat3 RotToMat( in vec4 r )\n{\n    return mat3(\n        vec3(\n            (r.w*r.w + r.x*r.x - r.y*r.y - r.z*r.z),\n            2.0*(r.x*r.y - r.w*r.z),\n            2.0*(r.x*r.z + r.w*r.y)\n        ),\n        vec3(\n            2.0*(r.y*r.x + r.w*r.z),\n            (r.w*r.w - r.x*r.x + r.y*r.y - r.z*r.z),\n            2.0*(r.y*r.z - r.w*r.x)\n        ),\n        vec3(\n            2.0*(r.z*r.x - r.w*r.y),\n            2.0*(r.z*r.y + r.w*r.x),\n            (r.w*r.w - r.x*r.x - r.y*r.y + r.z*r.z)\n        )\n    );\n}\n\n\n\nvec4 getData( in int x, in int y )\n{\n    return texture(\n        iChannel0,\n        vec2(\n            float(x)+0.5,\n            float(y)+0.5\n        )/iResolution.xy\n    );\n}\n\nfloat getKey( in int key, in float type )\n{\n    return texture(\n        iChannel1,\n        vec2(\n            (float(key) + 0.5)/256.0,\n            type\n        )\n    ).x;\n}\n\n\n\nmat3 stretchedMat(in float x, in float y, in float z)\n{\n    return mat3(x,0.0,0.0,0.0,y,0.0,0.0,0.0,z);\n}\n\nvec4 applyObject(in vec4 old, in vec4 new)\n{\n    if (new.w < 0.0) { return old; }\n    if (old.w < 0.0) { return new; }\n    if (new.w < old.w) { return new; }\n    return old;\n}\n\nvec4 polygon( in vec3 camPos, in vec3 camRay, in vec3 polyPos, in mat3 polyRot, in vec3 tint, in vec3 light )\n{\n    polyRot = mat3(\n        polyRot[0],\n        polyRot[1],\n        normalize(cross(polyRot[0], polyRot[1]))\n    );\n\n    mat3 invPolyRot = inverse(polyRot);\n    vec3 localCamPos = invPolyRot*(camPos - polyPos);\n    vec3 localCamRay = invPolyRot*camRay;\n    \n    float dist = -1.0;\n    if (localCamRay.z != 0.0) {\n        dist = -localCamPos.z/localCamRay.z;\n    }\n    \n    vec3 point = localCamPos + localCamRay*dist;\n    if (\n        point.x < 0.0 ||\n        point.x > 1.0 ||\n        point.y < 0.0 ||\n        point.y > 1.0\n    ) {\n        dist = -1.0;\n    }\n    \n    return vec4(\n        tint*(dot(polyRot[2], light)*0.25 + 0.75),\n        dist\n    );\n}\n\nvec4 cube( in vec3 camPos, in vec3 camRay, in vec3 cubePos, in mat3 cubeRot, in vec3 tint, in vec3 light )\n{\n    vec4 color = vec4(0.0, 0.0, 0.0, -1.0);\n    color = applyObject(color, polygon(camPos, camRay, cubePos - cubeRot*vec3(0.5), mat3(cubeRot[1], cubeRot[0], cubeRot[2]), tint, light));\n    color = applyObject(color, polygon(camPos, camRay, cubePos - cubeRot*vec3(0.5), mat3(cubeRot[2], cubeRot[1], cubeRot[0]), tint, light));\n    color = applyObject(color, polygon(camPos, camRay, cubePos - cubeRot*vec3(0.5), mat3(cubeRot[0], cubeRot[2], cubeRot[1]), tint, light));\n    color = applyObject(color, polygon(camPos, camRay, cubePos + cubeRot*vec3(0.5), mat3(-cubeRot[0], -cubeRot[1], cubeRot[2]), tint, light));\n    color = applyObject(color, polygon(camPos, camRay, cubePos + cubeRot*vec3(0.5), mat3(-cubeRot[1], -cubeRot[2], cubeRot[0]), tint, light));\n    color = applyObject(color, polygon(camPos, camRay, cubePos + cubeRot*vec3(0.5), mat3(-cubeRot[2], -cubeRot[0], cubeRot[1]), tint, light));\n    return color;\n}\n\nvec4 cubeFrame( in vec3 camPos, in vec3 camRay, in vec3 cubePos, in mat3 cubeRot, in float width, in vec3 tint, in vec3 light )\n{\n    vec4 color = vec4(0.0, 0.0, 0.0, -1.0);\n    for (float i = 0.0; i < 4.0; i++) {\n        float a = mod(i,2.0)*2.0 - 1.0;\n        float b = mod(floor(i/2.0),2.0)*2.0 - 1.0;\n    \n        color = applyObject( color, cube( camPos, camRay, cubePos + cubeRot*vec3(0.0,a,b), cubeRot*stretchedMat(2.0+width,width,width), tint, light ) );\n        color = applyObject( color, cube( camPos, camRay, cubePos + cubeRot*vec3(b,0.0,a), cubeRot*stretchedMat(width,2.0+width,width), tint, light ) );\n        color = applyObject( color, cube( camPos, camRay, cubePos + cubeRot*vec3(a,b,0.0), cubeRot*stretchedMat(width,width,2.0+width), tint, light ) );\n    }\n    return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = getData(1,0).xyz;\n    mat3 orientation = RotToMat(getData(2,0));\n    \n    float fov = 1.0;\n    vec3 ray = normalize(orientation * vec3( 1.0,\n        fov * (1.0 - 2.0*fragCoord.x/iResolution.x),\n        fov * (2.0*fragCoord.y/iResolution.x - iResolution.y/iResolution.x)\n    ));\n    \n    vec3 light = vec3(0.0,0.5,1.0);\n    \n    \n    fragColor = vec4(0.0, 0.0, 0.0, -1.0);\n    \n    fragColor = applyObject( fragColor, cube( pos, ray, vec3(0.0,0.0,0.0), stretchedMat(0.1,0.1,0.1), vec3(0.0,0.0,0.0), light ) );\n    fragColor = applyObject( fragColor, cube( pos, ray, vec3(2.0,0.0,0.0), stretchedMat(4.0,0.1,0.1), vec3(1.0,0.0,0.0), light ) );\n    fragColor = applyObject( fragColor, cube( pos, ray, vec3(0.0,2.0,0.0), stretchedMat(0.1,4.0,0.1), vec3(0.0,1.0,0.0), light ) );\n    fragColor = applyObject( fragColor, cube( pos, ray, vec3(0.0,0.0,2.0), stretchedMat(0.1,0.1,4.0), vec3(0.0,0.0,1.0), light ) );\n\n    mat3 Matrix = RotToMat(getData(3,0));\n    mat3 MatrixA = RotToMat(RotorA);\n    mat3 MatrixB = RotToMat(RotorB);\n    /*\n    fragColor = applyObject( fragColor, cube( pos, ray, vec3(0.0), Matrix*3.0, vec3(1.0,0.75,0.0), light ) );\n    fragColor = applyObject( fragColor, cube( pos, ray, Matrix*vec3(0.5*(3.0+3.0+1.0),0.0,0.0), Matrix*stretchedMat(1.0,2.5,1.0), vec3(0.9,0.65,0.0), light ) );\n    \n    fragColor = applyObject( fragColor, cube( pos, ray, Matrix*vec3(0.5*(3.0+1.5),0.0,0.0), Matrix*stretchedMat(1.5,0.8,0.8), vec3(0.2,0.2,0.2), light ) );\n    fragColor = applyObject( fragColor, cube( pos, ray, Matrix*vec3(0.5*(3.0+3.0+2.0+0.2),0.9,0.0), Matrix*stretchedMat(0.2,0.5,0.5), vec3(0.2,0.2,0.2), light ) );\n    fragColor = applyObject( fragColor, cube( pos, ray, Matrix*vec3(0.5*(3.0+3.0+2.0+0.2),-0.9,0.0), Matrix*stretchedMat(0.2,0.5,0.5), vec3(0.2,0.2,0.2), light ) );\n    fragColor = applyObject( fragColor, cube( pos, ray, Matrix*vec3(0.5*(-3.0-0.3),0.0,0.0), Matrix*stretchedMat(0.3,2.5,2.5), vec3(0.2,0.2,0.2), light ) );\n    fragColor = applyObject( fragColor, cube( pos, ray, Matrix*vec3(0.5*(-1.75),0.0,0.5*(3.0+0.1)), Matrix*stretchedMat(0.75,2.5,0.1), vec3(0.2,0.2,0.2), light ) );\n    fragColor = applyObject( fragColor, cube( pos, ray, Matrix*vec3(0.5*(1.75),0.0,0.5*(3.0+0.1)), Matrix*stretchedMat(0.75,2.5,0.1), vec3(0.2,0.2,0.2), light ) );\n    fragColor = applyObject( fragColor, cube( pos, ray, Matrix*vec3(0.0,0.0,0.5*(3.0+0.1)), Matrix*stretchedMat(0.75,2.5,0.1), vec3(0.2,0.2,0.2), light ) );\n    */\n    fragColor = applyObject( fragColor, cubeFrame( pos, ray, vec3(0.0), Matrix*1.6, 0.5, vec3(1.0,0.75,0.0), light ) );\n    //fragColor = applyObject( fragColor, cubeFrame( pos, ray, vec3(0.0), RotToMat(getData(4,1))*1.6, 0.15*(1.0-cos(getData(4,0).x)), vec3(0.7,0.0,0.8), light ) );\n    \n    //fragColor = applyObject( fragColor, cubeFrame( pos, ray, Matrix*vec3(1.0), Matrix, 0.5, vec3(0.0,0.6,0.1), light ) );\n    \n    //fragColor = applyObject( fragColor, cubeFrame( pos, ray, MatrixA*vec3(1.0), MatrixA, 0.35, vec3(0.7,0.0,0.0), light ) );\n    //fragColor = applyObject( fragColor, cubeFrame( pos, ray, MatrixB*vec3(1.0), MatrixB, 0.35, vec3(0.0,0.0,0.7), light ) );\n    \n    /*\n    vec3 axis = RotToVec(getData(3,0));\n    vec3 alterAxis = normalize(vec3(axis.y, -axis.x, axis.z));\n    mat3 axisMatrix = mat3(axis, alterAxis*0.1, 0.1*normalize(cross(axis, alterAxis)));\n    fragColor = applyObject( fragColor, cube( pos, ray, axis*0.5, axisMatrix, vec3(1.0,0.75,0.0), light ) );\n    */\n    \n    \n    \n    vec4 gridColor = vec4(0.0, 0.0, 0.0, -1.0);\n    \n    float gridLineCount = 8.0;\n    float gridLineWidth = 0.1;\n    for (float i = -0.5*gridLineCount; i <= 0.5*gridLineCount; i++) {\n        gridColor = applyObject( gridColor, polygon( pos, ray, vec3(i-0.5*gridLineWidth, -0.5*gridLineCount-0.5*gridLineWidth, 0.0), stretchedMat(gridLineWidth,gridLineCount + gridLineWidth,0.0), vec3(1.0), light ) );\n    }\n    for (float i = -0.5*gridLineCount; i <= 0.5*gridLineCount; i++) {\n        gridColor = applyObject( gridColor, polygon( pos, ray, vec3(-0.5*gridLineCount-0.5*gridLineWidth, i-0.5*gridLineWidth, 0.0), stretchedMat(gridLineCount + gridLineWidth,gridLineWidth,0.0), vec3(1.0), light ) );\n    }\n    \n    if (fragColor.a < 0.0) {\n        fragColor = gridColor;\n    } else if (gridColor.a >= 0.0 && gridColor.a < fragColor.a) {\n        fragColor = vec4( 0.5*(fragColor.rgb+gridColor.rgb), gridColor.a);\n    }\n    \n    if (distance(fragCoord, iMouse.xy) < getData(5,0).x*35.0) {\n        fragColor = vec4(1.0,0.0,0.0,1.0);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\n    Rotors are defined as vec4(ryz, rzx, rxy, r0) to ensure that the index represents the axis perpendicular to the rotation.\n\n*/\n\n\n\nconst float pi = 3.14159265;\n\nconst vec4 RotorA = normalize(vec4(0.72083,0.18611,-0.31679,0.58772));\nconst vec4 RotorB = normalize(vec4(0.75754,0.089947,0.35051,-0.54331));\n\n\n\n// Transforms a vector using a rotor\nvec3 RotTrans( in vec4 r, in vec3 v )\n{\n    return vec3(\n        (\n            (r.w*r.w + r.x*r.x - r.y*r.y - r.z*r.z)*v.x +\n            2.0*(r.y*r.x + r.w*r.z)*v.y +\n            2.0*(r.z*r.x - r.w*r.y)*v.z\n        ),\n        (\n            2.0*(r.x*r.y - r.w*r.z)*v.x +\n            (r.w*r.w - r.x*r.x + r.y*r.y - r.z*r.z)*v.y +\n            2.0*(r.z*r.y + r.w*r.x)*v.z\n        ),\n        (\n            2.0*(r.x*r.z + r.w*r.y)*v.x +\n            2.0*(r.y*r.z - r.w*r.x)*v.y +\n            (r.w*r.w - r.x*r.x - r.y*r.y + r.z*r.z)*v.z\n        )\n    );\n}\n\n// Stacks rotor transformations\nvec4 RotStack( in vec4 a, in vec4 b )\n{\n    return vec4(\n        (a.w*b.x + a.z*b.y - a.y*b.z + a.x*b.w),\n        (a.w*b.y - a.z*b.x + a.y*b.w + a.x*b.z),\n        (a.w*b.z + a.z*b.w + a.y*b.x - a.x*b.y),\n        (a.w*b.w - a.z*b.z - a.y*b.y - a.x*b.x)\n        \n    );\n}\n\n// Takes the inverse of a rotor\nvec4 RotInv( in vec4 r )\n{\n    return vec4( -r.xyz, r.w );\n}\n\n// Converts a rotor to a vector of angular velocity\nvec3 RotToVec( in vec4 r )\n{\n    float l = length(r.xyz);\n    if (l == 0.0) { l = 1.0; }\n    \n    return r.xyz/l *\n    (\n        mod(\n            2.0*atan(l, r.w)\n        + pi, 2.0*pi ) - pi\n    );\n}\n\n// Converts a vector of angular velocity to a rotor\nvec4 VecToRot( in vec3 v )\n{\n    float l = length(v);\n    float a = 0.5*l;\n    if (l == 0.0) { l = 1.0; }\n    \n    return vec4(\n        v*sin(a)/l,\n        cos(a)\n    );\n}\n\n// Converts a rotor to a rotation matrix\nmat3 RotToMat( in vec4 r )\n{\n    return mat3(\n        vec3(\n            (r.w*r.w + r.x*r.x - r.y*r.y - r.z*r.z),\n            2.0*(r.x*r.y - r.w*r.z),\n            2.0*(r.x*r.z + r.w*r.y)\n        ),\n        vec3(\n            2.0*(r.y*r.x + r.w*r.z),\n            (r.w*r.w - r.x*r.x + r.y*r.y - r.z*r.z),\n            2.0*(r.y*r.z - r.w*r.x)\n        ),\n        vec3(\n            2.0*(r.z*r.x - r.w*r.y),\n            2.0*(r.z*r.y + r.w*r.x),\n            (r.w*r.w - r.x*r.x - r.y*r.y + r.z*r.z)\n        )\n    );\n}\n\n// Converts a matrix to XYZ gimbals\nvec3 MatToGimbals( in mat3 m )\n{\n    float y = atan(m[0][2], sqrt(m[0][0]*m[0][0] + m[0][1]*m[0][1]));\n    float z = -atan(m[0][1], m[0][0])*ceil(min(mod(y + pi*0.5, pi), 1.0));\n    float x = -atan(\n        m[1][2]*cos(y) - (m[1][0]*cos(z) - m[1][1]*sin(z))*sin(y),\n        m[1][1]*cos(z) + m[1][0]*sin(z)\n    );\n    return vec3(x,y,z);\n}\n\n\n\nbool isData( in vec2 fragCoord, in int x, in int y )\n{\n    return \n        int(floor(fragCoord.x)) == x &&\n        int(floor(fragCoord.y)) == y;\n}\n\nvec4 getData( in int x, in int y )\n{\n    return texture(\n        iChannel0,\n        vec2(\n            float(x)+0.5,\n            float(y)+0.5\n        )/iResolution.xy\n    );\n}\n\nfloat getKey( in int key, in float type )\n{\n    return texture(\n        iChannel1,\n        vec2(\n            (float(key) + 0.5)/256.0,\n            type\n        )\n    ).x;\n}\n\nbool isInitial()\n{\n    return getData(0,0).x <= 0.5;\n}\n\n\n\nvec4 tickRotationalVelocity()\n{\n    if (isInitial()) {\n        return vec4(0.0);\n    }\n    \n    if (getKey(32, 1.0) < 0.5) {\n        return vec4(\n            getData(2,3).xyz + (\n                vec3(\n                    0.0,\n                    getKey(40, 0.0) - getKey(38, 0.0) + getKey(83, 0.0) - getKey(87, 0.0),\n                    getKey(37, 0.0) - getKey(39, 0.0) + getKey(65, 0.0) - getKey(68, 0.0)\n                )*10.0\n                - 4.0*getData(2,3).xyz\n                - 10.0*vec3(getData(2,2).x, 0.0, 0.0)\n            )*iTimeDelta,\n            0.0\n        );\n    }\n    else {\n        return vec4(0.0);\n    }\n}\n\nvec4 tickRotation()\n{\n    if (isInitial()) {\n        return vec4(0.0, -pi*0.15, pi*0.75, 0.0);\n    }\n    \n    if (getKey(32, 1.0) < 0.5) {\n        return vec4(\n            mod(getData(2,2).x + tickRotationalVelocity().x*iTimeDelta + pi, 2.0*pi) - pi,\n            min(max(getData(2,2).y + tickRotationalVelocity().y*iTimeDelta, -0.5*pi), 0.5*pi),\n            mod(getData(2,2).z + tickRotationalVelocity().z*iTimeDelta, 2.0*pi),\n            0.0\n        );\n    }\n    else {\n        return vec4(\n            MatToGimbals(RotToMat(getData(2,0))),\n            0.0\n        );\n    }\n}\n\nvec4 tickRotorVelocity()\n{\n    if (isInitial()) {\n        return vec4(0.0);\n    }\n    \n    if (getKey(32, 1.0) < 0.5) {\n        return vec4(0.0);\n    }\n    else {\n        vec3 acceleration = RotToVec(RotStack(\n            RotStack(getData(3,0), vec4(0.0,0.0,1.0,0.0)),\n            RotInv(getData(2,0))\n        ))*10.0\n        - 4.0*getData(2,1).xyz;\n        return vec4(\n            getData(2,1).xyz\n            + acceleration*iTimeDelta,\n            0.0\n        );\n    }\n}\n\nvec4 tickRotor()\n{\n    if (getKey(32, 1.0) < 0.5) {\n        vec4 rotation = tickRotation();\n        return RotStack(\n            vec4(0.0,0.0,sin(rotation.z*0.5),cos(rotation.z*0.5)),\n            RotStack(\n                vec4(0.0,sin(rotation.y*0.5),0.0,cos(rotation.y*0.5)),\n                vec4(sin(rotation.x*0.5),0.0,0.0,cos(rotation.x*0.5))\n            )\n        );\n    }\n    else {\n        return RotStack(\n            VecToRot(tickRotorVelocity().xyz*iTimeDelta),\n            getData(2,0)\n        );\n    }\n}\n\n\n\nvec4 tickMotion()\n{\n    if (isInitial()) {\n        return vec4(20.0, 0.0, 0.0, 0.0);\n    }\n    \n    return vec4(\n        getData(1,1).xyz +\n        (\n            // Acceleration\n            RotToMat(getData(2,0))*vec3(\n                getKey(87, 0.0) - getKey(83, 0.0),\n                getKey(65, 0.0) - getKey(68, 0.0),\n                getKey(32, 0.0) - getKey(88, 0.0)\n            )*60.0\n            // Dampening\n            - 5.0*getData(1,1).xyz\n        )*iTimeDelta,\n        0.0\n    );\n}\n\nvec4 tickPosition()\n{\n    return vec4(\n        RotTrans(tickRotor(), vec3(-8.0,0.0,0.0)),\n        0.0\n    );\n}\n\n\nvec4 tickObjectRotationalVelocity()\n{\n    if (isInitial()) {\n        return vec4(0.0);\n    }\n    \n    float fov = 1.0;\n    vec3 clickPoint = vec3(\n        0.0,\n        fov * (1.0 - 2.0*iMouse.x/iResolution.x),\n        fov * (2.0*iMouse.y/iResolution.x - iResolution.y/iResolution.x)\n    );\n    if (iMouse.z < 1.0 && iMouse.w < 1.0) {\n        clickPoint = vec3(0.0);\n    };\n    vec4 rotation = tickRotor();\n    \n    vec3 acceleration = RotTrans(\n        rotation,\n        cross(\n            -clickPoint,\n            vec3(1.0,0.0,0.0)\n        )\n    )*20.0\n    - 2.0*getData(3,1).xyz\n    + vec3(0.0,0.0,1.0)*getKey(82,1.0)*(1.0-getKey(84,1.0))\n    + RotToVec(RotStack(\n        getData(4,1),\n        RotInv(getData(3,0))\n    ))*2.0*getKey(84,1.0);\n    \n    return vec4(\n        getData(3,1).xyz + acceleration.xyz*iTimeDelta,\n        0.0\n    );\n}\n\nvec4 tickObjectRotation()\n{\n    if (isInitial()) {\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    \n    // Single application linear interpolation\n    //vec4 midDiff = VecToRot(RotToVec(RotStack(RotorB, RotInv(RotorA)))*0.5);\n    //return RotStack(VecToRot(RotToVec(RotStack(RotStack(midDiff, RotorA), RotInv(midDiff)))*((1.0-cos(getData(7,0).x*pi))*0.5+0.0)), midDiff);\n    //return VecToRot(RotToVec(RotStack(RotorB, RotInv(RotorA)))*((1.0-cos(getData(7,0).x*pi))*0.25+0.5));\n    \n    /*\n    vec4 x = VecToRot(vec3(1.0,0.0,0.0)*(0.3*sin(3.0*pi*getData(6,0).x)*getData(6,0).x));\n    vec4 y = VecToRot(vec3(0.0,1.0,0.0)*(0.3*sin(3.0*pi*getData(6,0).y)*getData(6,0).y));\n    vec4 z = VecToRot(vec3(0.0,0.0,1.0)*(0.3*sin(3.0*pi*getData(6,0).z)*getData(6,0).z));\n    */\n    \n    //return RotStack( z, RotStack( y, x ) );\n    \n    // Linear interpolation between states\n    //return RotStack(VecToRot(RotToVec(RotStack(RotorB, RotInv(RotorA)))*(1.0-cos(getData(7,0).x*pi))*0.5), RotorA);\n    \n    \n    /*\n    float time1 = 0.5*(1.0-cos(min(max(iTime*2.0, pi*4.0), pi*5.0)));\n    float time2 = 0.5*(1.0-cos(min(max(iTime*2.0, pi*6.0), pi*7.0)));\n    \n    vec4 rotor2 = normalize(vec4(-0.2,0.5,0.4,0.3));\n    vec4 rotor1 = normalize(vec4(0.1,0.0,0.2,0.4));\n    rotor1 = VecToRot(RotToVec(rotor1)*time1);\n    rotor2 = VecToRot(RotToVec(rotor2)*time2);\n    return RotStack(rotor2, rotor1);\n    */\n    \n    return RotStack(VecToRot(tickObjectRotationalVelocity().xyz*iTimeDelta), getData(3,0));\n}\n\n\nvec4 tickAlignerSize()\n{\n    if (isInitial()) {\n        return vec4(0.0);\n    }\n    \n    return vec4(\n        min(max(\n            getData(4,0).x\n            + (getKey(84,1.0)*2.0 - 1.0)*5.0*iTimeDelta,\n        0.0), pi),\n        0.0,\n        0.0,\n        0.0\n    );\n}\n\nvec4 tickAlignerRotation()\n{\n    return normalize(vec4(0.3,-0.6,0.2,0.4));\n}\n\n\nvec4 tickMouseMarkerSize()\n{\n    if (isInitial()) {\n        return vec4(0.0);\n    }\n    \n    float offset = 1.0;\n    if (iMouse.z < 1.0 && iMouse.w < 1.0) {\n        offset = -1.0;\n    }\n    \n    return vec4(\n        min(max(\n            getData(5,0).x\n            + offset*30.0*iTimeDelta,\n        0.0), pi),\n        0.0,\n        0.0,\n        0.0\n    );\n}\n\n\n\nvec4 tickAxisCooldowns()\n{\n    if (isInitial()) {\n        return vec4(0.0);\n    }\n    \n    float x = getData(6,0).x;\n    float y = getData(6,0).y;\n    float z = getData(6,0).z;\n    \n    x = max(x-iTimeDelta, 0.0);\n    y = max(y-iTimeDelta, 0.0);\n    z = max(z-iTimeDelta, 0.0);\n    \n    if (getKey(88, 0.5) > 0.5) {\n        x = 1.0;\n    }\n    if (getKey(89, 0.5) > 0.5) {\n        y = 1.0;\n    }\n    if (getKey(90, 0.5) > 0.5) {\n        z = 1.0;\n    }\n    \n    return vec4(x,y,z,0.0);\n}\n\nvec4 tickLerpControl()\n{\n    if (isInitial()) {\n        return vec4(0.0, 0.0, 0.0, 0.0);\n    }\n    \n    float lerp = getData(7,0).x;\n    lerp = min(max(lerp + (getKey(77, 0.0) - getKey(78, 0.0))*iTimeDelta*1.5, 0.0), 1.0);\n    if (getKey(79, 0.5) > 0.5) {\n        lerp = 0.5;\n    }\n    \n    return vec4(lerp, 0.0, 0.0, 0.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Run function based on location of pixel\n    \n    vec4 data = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    if (isData(fragCoord,0,0)) {\n        data = vec4(1.0);\n    }\n    \n    else if (isData(fragCoord,1,0)) {\n        data = tickPosition();\n    }\n    else if (isData(fragCoord,1,1)) {\n        data = tickMotion();\n    }\n    \n    else if (isData(fragCoord,2,0)) {\n        data = tickRotor();\n    }\n    else if (isData(fragCoord,2,1)) {\n        data = tickRotorVelocity();\n    }\n    else if (isData(fragCoord,2,2)) {\n        data = tickRotation();\n    }\n    else if (isData(fragCoord,2,3)) {\n        data = tickRotationalVelocity();\n    }\n    \n    else if (isData(fragCoord,3,0)) {\n        data = tickObjectRotation();\n    }\n    else if (isData(fragCoord,3,1)) {\n        data = tickObjectRotationalVelocity();\n    }\n    \n    else if (isData(fragCoord,4,0)) {\n        data = tickAlignerSize();\n    }\n    else if (isData(fragCoord,4,1)) {\n        data = tickAlignerRotation();\n    }\n    \n    else if (isData(fragCoord,5,0)) {\n        data = tickMouseMarkerSize();\n    }\n    \n    else if (isData(fragCoord,6,0)) {\n        data = tickAxisCooldowns();\n    }\n    \n    else if (isData(fragCoord,7,0)) {\n        data = tickLerpControl();\n    }\n\n    fragColor = data;\n}","name":"Buffer A","description":"","type":"buffer"}]}