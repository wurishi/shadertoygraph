{"ver":"0.1","info":{"id":"wscyWl","date":"1601968634","viewed":121,"name":"Planet w/ Atmosphere","username":"Giraugh","description":"Planet w/ atmosphere. Using ray-sphere intersection to compute points on the atmosphere.\nUsing fractional brownian motion to generate random noise for star distribution and planet height-map.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","planet","laggy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Simplest Possible Raymarcher */\n/* By Giraugh */\n\n#define MAX_STEPS 300\n#define MAX_DIST 1000.\n#define SURF_DIST 0.0005\n#define PI 3.14159\n#define ATMO_COL_DARK vec3(.05, .05, .3)\n#define ATMO_COL_BRIGHT vec3(.6, .9, .95)\n#define SEED 370.\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nfloat fbm(vec2 uv) {\n    uv *= .02;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    float f  = 0.5000*noise( uv ); uv = m*uv;\n    f += 0.2500*noise( uv ); uv = m*uv;\n    f += 0.1250*noise( uv ); uv = m*uv;\n    f += 0.0625*noise( uv ); uv = m*uv;\n    f += 0.01125*noise( uv ); uv = m*uv;\n    f += 0.005*noise( uv ); uv = m*uv;\n    return f;\n}\n\nmat2 Rot(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(\n    \tc, -s, s, c\n    );\n}\n\n// Return the distance to the nearest point in the scene\n// from (point)\nfloat GetDist(vec3 point) {\n    // Plane SDF at y=0\n    float planeD = point.y;\n    \n    // Sphere SDF at (0, 1, 4) w/ rad 1\n    float amp = .08;\n    float freq = 31.;\n    float n1 = ((2. * fbm(freq * point.xy + SEED))-1.);\n    float n2 = ((2. * fbm(freq * point.zx + SEED))-1.);\n    float r = 1. + (n1 + n2) * amp;\n    float sphereD = length(point - vec3(0, 0, 0)) - r;\n    float oceanD = (length(point - vec3(0, 0, 0)) - .87);\n    \n    return min(sphereD, oceanD) / 2.;\n}\n\n// March a ray forwards into the scene determined by (GetDist)\n// Returns the distance the ray travelled before getting\n// below (SURF_DIST) distance from a surface or too far away \nfloat RayMarch(vec3 rayOrigin, vec3 rayDirection) {\n    float d = 0.;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = rayOrigin + rayDirection * d;\n        float d_delta = GetDist(p);\n        d += d_delta;\n        if (d > MAX_DIST || abs(d_delta) < SURF_DIST) break; \n    }\n    return d;\n}\n\n// Calculate the surface normal at (point)\n// can reduce (off) to improve accuracy\nvec3 GetNormal(vec3 point) {\n    float d = GetDist(point);\n    float off = .01;\n    vec3 n = vec3(\n    \td - GetDist(point - vec3(off,0,0)),\n        d - GetDist(point - vec3(0,off,0)),\n        d - GetDist(point - vec3(0,0,off))\n    );\n    return normalize(n);\n}\n\n// Determine degree of lighting (0 to 1) at (pos) by (lightPos)\nfloat GetLighting(vec3 point, vec3 lightPos, vec3 n) {\n    vec3 l = normalize(lightPos - point);\n    float diff = clamp(dot(l, n), 0., 1.);\n    return diff;\n}\n\n// Get specular highlight\nfloat GetLightingPhong(vec3 point, vec3 view, vec3 lightPos, float shininess) {\n\tvec3 l = normalize(lightPos - point);\n    vec3 n = GetNormal(point);\n    vec3 r = 2. * n * dot(n, l) - l;\n    \n    if (dot(n, l) < 0.0) {\n        return 0.;\n    } else {\n    \treturn .3 * pow(max(0., dot(r, normalize(-view))), shininess);\n    }\n}\n\n// Returns 1. for intersect 0. for no intersect\nfloat RaySphereIntersectLength(vec3 ro, vec3 rd, vec3 so, float r) {\n    // calculate nearest point on ray to sphere (p)\n    float t = dot(so - ro, rd);\n   \tvec3 p = ro + t * rd;\n    \n    // y is dist from sphere to nearest point\n    float y = length(so - p);\n    \n    // x is dist from intersection point to p\n    float x = sqrt(pow(r, 2.) - pow(y, 2.));\n    float w = 2. * x;\n    return w;\n}\n\nfloat RaySphereIntersectDist(vec3 ro, vec3 rd, vec3 so, float r) {\n    // calculate nearest point on ray to sphere (p)\n    float t = dot(so - ro, rd);\n   \tvec3 p = ro + t * rd;\n    \n    // y is dist from sphere to nearest point\n    float y = length(so - p);\n    \n    // x is dist from intersection point to p\n    float x = sqrt(pow(r, 2.) - pow(y, 2.));\n    \n    // Get point of intersection\n    vec3 i = ro + (t - x) * rd;\n    \n    return length(ro - i);\n}\n\nvec3 Atmosphere(vec3 ro, vec3 rd, vec3 so, float r, vec3 lightPos, float depth) {    \n    // calculate nearest point on ray to sphere (p)\n    float t = dot(so - ro, rd);\n   \tvec3 p = ro + t * rd;\n    \n    // y is dist from sphere to nearest point\n    float y = length(so - p);\n    \n    // x is dist from intersection point to p\n    float x = sqrt(pow(r, 2.) - pow(y, 2.));\n    \n    // If it doesn't intersect then no atmosphere here\n    if (y > r) {\n    \treturn vec3(0);\n    }\n    \n    // Calculate intersection width\n    float t1 = max(t - x, 0.);\n    float t2 = min(t + x, depth);\n    float w = max(0., t2 - t1) / (r / 2.);\n    \n    // Get point of intersection\n    vec3 atmoI = ro + (t - x) * rd;\n    \n    // Find point to sample light\n    // this is some hacks to spread the light out more over the sphere\n    vec3 samplePoint = ro + min(t, t2) * rd;\n    vec3 normal = normalize(samplePoint - so);\n    vec3 lightDir = normalize(lightPos - samplePoint);\n    float luminance = max(dot(lightDir, normal), 0.);\n    \n    vec3 atmoCol = mix(ATMO_COL_DARK, ATMO_COL_BRIGHT, luminance);\n    \n    return vec3(atmoCol * min(2., w * luminance));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (square) (from 0 to 1)\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n\n    // Declare camera position in terms of ray origin and direction\n    vec3 rayOrigin = vec3(0, 0, 0);\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n    \n\t// rotate the view\n    //rayOrigin.xz *= Rot(iTime);\n    float ang = 2. + iTime / 4.;\n    float viewDist = 4.;\n    rayOrigin.x += cos(ang) * viewDist;\n    rayOrigin.z += sin(ang) * viewDist;\n    \n    // look at center\n    rayDirection.xz *= Rot(ang + PI/2.);\n    \n    // RayMarch to find point\n    float dist = RayMarch(rayOrigin, rayDirection);\n    vec3 hitPoint = rayOrigin + dist * rayDirection;\n    \n    // Determine lighting\n    vec3 lightPos = vec3(-12, 6, 1);\n    vec3 normal = GetNormal(hitPoint);\n    float lighting = GetLighting(hitPoint, lightPos, normal);\n    if (dist < 50.) lighting += .01;\n\tvec3 col = vec3(0);\n    \n    // Colour Terrain\n    if (dist < 100.) {\n     \tfloat pd = length(hitPoint);\n        \n        // Grass\n        col = vec3(.2, .7, .3) * (1. - ((smoothstep(.9, .92, pd)) * .3));\n        \n        // Mountains\n        if (pd > 0.913) {\n            //col = vec3(.2, .8, .3) * .6;\n        }\n        \n        // Sand\n        if (pd <= .887) {\n            col = mix(vec3(.7, .8, .5), vec3(.2, .7, .3), smoothstep(.872, .887, pd));\n        }\n        \n        // Water\n        if (pd <= .874) {\n        \tcol = vec3(.1, .15, 1) * mix(.3, .8, (pd - .7) / .05);\n            col += 2. * GetLightingPhong(hitPoint, rayDirection, lightPos, 30.);\n        }\n    }\n    \n    col = col * lighting;\n    \n    // Atmosphere\n    vec3 atmoOrigin = vec3(0, 0, 0);\n    float atmoRadius = 1.1;\n    vec3 atmosphere = Atmosphere(\n        rayOrigin,\n        rayDirection,\n        atmoOrigin,\n        atmoRadius,\n        lightPos,\n    \tdist\n    );\n    \n    col += atmosphere;\n        \n    \n    // Stars\n    if (dist > 100.) {\n        float noiseX = fbm(rayDirection.xy * 500.);\n        float noiseY = fbm(rayDirection.yz * 500.);\n        vec2 samp = 25. * rayDirection.xy + vec2(noiseX, noiseY);\n        if (mod(samp.x, 2.) < 0.08 && mod(samp.y, 2.) < 0.05) {\n            col += vec3(.7) * max(0., sin(iTime + fbm(samp.xy) * 100.));\n        }\n    }\n    \n\t// A sun\n    if (dist > 100.) {\n        float sun = max(0., dot(rayDirection, normalize(lightPos - rayOrigin)) - 0.97);\n        col += (pow(sun, .75) * 35.) * vec3(1, .8, .6);\n        col += max(0., dot(rayDirection, normalize(lightPos - rayOrigin)) - .8) * vec3(1, .8, .6);\n    }\n    \n    // Ouput colour at full transparency\n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}