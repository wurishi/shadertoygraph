{"ver":"0.1","info":{"id":"Xf3BWX","date":"1733519604","viewed":26,"name":"curvature field 126","username":"kukovisuals","description":"Gray-Scott + curvature field","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["grayscott","curvaturefield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// A pseudo-random generator\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(27.619,57.583)))*43758.5453);\n}\n\n// Simple noise function\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    float a = hash(i);\n    float b = hash(i + vec2(1.0,0.0));\n    float c = hash(i + vec2(0.0,1.0));\n    float d = hash(i + vec2(1.0,1.0));\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(mix(a,b,u.x),mix(c,d,u.x),u.y);\n}\n\n// Approximate a curvature field from a height map\nfloat curvature(vec2 uv) {\n    float eps = 0.02;\n    float h = sin(uv.x*2.05 + iTime)*cos(uv.y*2.04 + iTime);\n    float hx1 = sin((uv.x+eps)*2.0 + iTime)*cos(uv.y*2.0 + iTime);\n    float hx2 = sin((uv.x-eps)*2.0 + iTime)*cos(uv.y*2.0 + iTime);\n    float hy1 = sin(uv.x*2.0 + iTime)*cos((uv.y+eps)*2.0 + iTime);\n    float hy2 = sin(uv.x*2.0 + iTime )*cos((uv.y-eps)*2.0 + iTime);\n    float lap = (hx1+hx2+hy1+hy2-4.0*h)/(eps*eps);\n    return lap;\n}\n\n// Gray-Scott model parameters modified by curvature:\n// U,V fields evolve with:\n// dU/dt = D_u∇²U - U*V² + F(1-U)\n// dV/dt = D_v∇²V + U*V² - (F+K)V\n// We can't truly solve PDE here without state, so we create a time-dependent pseudo-state.\nvec3 hsb2rgb(vec3 c) {\n    vec3 rgb = clamp(abs(mod(c.z*6.0+vec3(0,4,2),6.0)-3.0)-1.0,0.0,1.0);\n    rgb = rgb*rgb*(3.3-2.0*rgb); \n    return c.x*mix(vec3(1.0),rgb,c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    // Time-varying zoom and rotation\n    float angle = iTime*0.1;\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    uv = rot * uv * (1.0 + 0.2*sin(iTime*0.3));\n\n    // Compute curvature-based diffusion variations\n    float curv = curvature(uv);\n    float D_u = 0.16 + 0.08*sin(iTime*0.1);\n    float D_v = 0.08 + 0.04*cos(iTime*0.13);\n    D_u *= (1.0 + 0.5*curv);\n    D_v *= (1.0 + 0.5*curv);\n\n    // F and K vary slightly with time and position\n    float F = 0.035 + 0.005*sin(iTime*0.2+uv.x*3.0+uv.y*3.0);\n    float K = 0.062 + 0.005*cos(iTime*0.3+uv.y*3.0-uv.x*3.0);\n\n    // Pretend we have fields U and V from previous iterations by using noise and iTime\n    float t = iTime*0.01;\n    float U = 1.0 - 0.5*noise(uv*3.0 + vec2(t,t));\n    float V = 1.5*noise(uv*1.0 - vec2(t,t));\n    \n    // Simulate one pseudo-step of PDE to get patterns:\n    // We won't do a full PDE solve, just alter U,V based on some heuristic\n    // to create dynamic lines and spots.\n    float lapU = noise(uv*3.0 + vec2(t+0.1,t+0.2)) - U;\n    float lapV = noise(uv*3.0 + vec2(t+0.3,t+0.4)) - V;\n    U += (D_u*lapU - U*V*V + F*(1.0 - U))*0.5;\n    V += (D_v*lapV + U*V*V - (F+K)*V)*0.5;\n\n    // Use U and V to create color patterns\n    // Hue from U, saturation from V, brightness from mixture\n    float hue = fract(U + iTime*0.1);\n    float sat = clamp(V*0.6,0.7,0.8);\n    float bri = clamp(U,0.0,1.0);\n    vec3 color = hsb2rgb(vec3(hue,sat,bri));\n\n    // Add line patterns influenced by curvature\n    float linePattern = sin((uv.x*uv.x+uv.y*uv.y)*100.0+ iTime*1.0 + curv*10.0)*0.5+0.5;\n    color = mix(color,vec3(1.0,0.8,0.5), linePattern*0.015);\n\n    // Slight variations over time for a more organic look\n    color *= 0.9+0.1*sin(iTime+uv.x*10.0+uv.y*10.0);\n\n    fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}