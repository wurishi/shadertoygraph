{"ver":"0.1","info":{"id":"ltVfzh","date":"1541866383","viewed":148,"name":"Bluish Noise B[Signal Inspector]","username":"TinyTexel","description":"more flow-freq content than original Bluish Noise (https://www.shadertoy.com/view/MtdBzB) but more isotropic spectrum\nalso doesnt require complicated s-curve remapping and animates in a cyclic manner\n","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//more flow-freq content than Bluish Noise (https://www.shadertoy.com/view/MtdBzB) but more isotropic\n//also doesnt require complicated s-curve remapping and animates in a cyclic manner\n\n// original comments:\n//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//The noise/signal type can be changed in the Common tab\n//and the code for the signal generation is in Buffer A\n\n/*\n\tTools to help design 2D functions. Here used for noise design, but can be \n\tused for SDFs, Hashes, Image filters or any function that takes 2D input.\n\n\tThe display is as follow:\n\t\tTop left: Averaged distribution of the signal in the [0..1] range with\n\t\t\t\t  reference bars at 1/4, 1/2 and 3/4\n\n\t\tBottom left: Preview of the signal itself, coordinates are slowly moving by\n\t\t\t\t\t default, can be turned off in the Common tab\n\n\t\tTop right: First and second derivatives of a slice of the signal, to see\n\t\t\t\t   at a glance the continuity of the signal, uses horizontal (X aligned)\n\t\t\t\t   slices by default, can be switched to diagonal slices in the common tab\n\n\t\tBottom right: 2D discrete fourier transform of the input, useful to see the\n\t\t\t\t\t  signal's frequency distribution and potential anisotropy\n\n\n\t\tTo increase the size/resolution of the DFT, increase the globalSize to shrink the \n\t\tfeature size to help get a better picture over the signal's main frequqncy range\n\n\n\t\tAn interesting note regarding the noise distributions: For noises/signals with\n\t\ttoo narrow a distribution a simple smoothstep (or a more complex filter) can\n\t\tbe used as a primitive form of \"gain compression\" to flatten the distribution.\n\t\tEspecially useful when building FBM noise from narrow distributed noises \n\t\t(such as gradient noise) so that the end result isn't in a very short value range.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n#ifdef SHOW_FOURIER\n    if (q.x > 0.5)\n    {\n        vec2 dft = textureLod(iChannel1, q-vec2(0.5,0.0), 0.).xy;\n        float amp = length(dft) / SIZE; \n        col = vec3(amp);\n    }\t\n    else\n#endif\n    {\n        float n = textureLod(iChannel0, q, 0.).r;\n        col = pow(vec3(n), vec3(1.0/2.2));\n        \n        #define SHOW_1BITGRADIENT\n        #ifdef SHOW_1BITGRADIENT\n        if(q.y < 0.25)\n        col = vec3(n < q.x * 2.0 ? 0.0 : 1.0);\n        #endif\n    }\n    \n    //Distribution plot\n    float tot = 0.;\n    if (fragCoord.y> SIZE && fragCoord.x < SIZE)\n    {\n        const float bands = 60.;\n        float bt = floor(fragCoord.x*bands/SIZE);\n        float pt = (floor((fragCoord.x)*bands/SIZE)+0.5)/bands;\n        const float width = 6.;\n        for (float j = 0.; j<=width; j++)\n        for (float i = 0.; i<SIZE; i++)\n        {\n            float v = texelFetch(iChannel0, ivec2(bt+j, i + 0.5), 0).x;\n            if (abs(v-pt) < .5/bands)\n            \ttot += 1.;\n        }\n        tot /= SIZE*width;\n        col.rgb = vec3(smoothstep(0.00,1.,tot*SIZE-fragCoord.y + SIZE + 1.))*vec3(.4,.4,.5);\n        col.rgb += vec3(smoothstep(1.,0.,abs(tot*SIZE-fragCoord.y + SIZE + 0.5)))*vec3(.8,.8,.8);\n        if(fragCoord.y < (SIZE+50.))\n        {\n        \tcol.rgb = max(col.rgb, vec3(0.9,0.6,0.1)*vec3(smoothstep(1.4,0.,abs(fragCoord.x - SIZE/2.))));\n        \tcol.rgb = max(col.rgb, vec3(0.55,0.5,0.4)*vec3(smoothstep(1.4,0.,abs(abs(fragCoord.x - SIZE/2.)-SIZE/4.))));\n        }\n    }\n    \n    \n    col *= smoothstep(0.,1.7,abs(fragCoord.y-SIZE+1.));\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// bluish noise (https://www.shadertoy.com/view/MdffRN) \n// plugged into 2D Signal Inspector by nimitz (https://www.shadertoy.com/view/llKyWc)\n\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\nconst float Pi2 = Pi * 2.0;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nvec2 CmplxMul(vec2 c0, vec2 c1)\n{\n\treturn vec2(c0.x*c1.x - c0.y*c1.y, c0.y*c1.x + c0.x*c1.y);\n}\n\nvec2 CmplxMul(vec2 c0, float ang)\n{\n\tvec2 c1 = vec2(cos(ang), sin(ang));\n\n\treturn vec2(c0.x*c1.x - c0.y*c1.y, c0.y*c1.x + c0.x*c1.y);\n}\n\nvec2 SmplCircle(float s)\n{\n    return AngToVec(s * Pi2);\n}\n\n\nfloat Hash12I(vec2 uv)\n{\n    //if(iFrame > 0) return texelFetch(iChannel1, ivec2(uv), 0).x;\n    \n    uint h = WeylHash(uvec2(uv)); \n\n    return Float01(h);\n}\n\nfloat BNoiseB(vec2 uv)\n{\n    float v = Hash12I(uv);\n    \n    float v0 = Hash12I(uv + vec2(-1.0, 0.0));\n    float v1 = Hash12I(uv + vec2( 1.0, 0.0));\n    float v2 = Hash12I(uv + vec2( 0.0,-1.0));\n    float v3 = Hash12I(uv + vec2( 0.0, 1.0));\n \n    float v4 = Hash12I(uv + vec2(-1.0, 1.0));\n    float v5 = Hash12I(uv + vec2( 1.0, 1.0));\n    float v6 = Hash12I(uv + vec2( 1.0,-1.0));\n    float v7 = Hash12I(uv + vec2(-1.0,-1.0));\n    \n    #define f SmplCircle\n    vec2 vec = -(f(v0) + f(v1) + f(v2) + f(v3)) * 2.0 + f(v)*8.0;\n         vec+= -(f(v4) + f(v5) + f(v6) + f(v7)) * 1.0;\n    #undef f\n    \n    //vec = CmplxMul(vec, iTime);\n\n    float vf = 0.0;\n    \n    vf = atan(vec.x, vec.y) / Pi;\n    //vf = vf * 0.5 + 0.5;\n    vf = abs(vf); \n    //vf = fract(vf + 0.1);\n   // vf = acos(normalize(vec).x)/Pi;\n    \n    //vf = clamp(vf, 0.0, 1.0);\n    \n    return vf;  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 uv0 )\n{\n#ifdef SHOW_FOURIER\n    if(uv0.x > SIZE)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n#endif\n    \n    vec3 col = vec3(0);\n    \n    vec2 uv = uv0 - 0.5;\n    float n = BNoiseB(uv);\n    \n    col = vec3(n);\n    //col = texelFetch(iChannel0, ivec2(uv0) % 1024, 0).xxx;// proper blue noise\n    \n    //if (col.x >= 1. || col.x <= 0.) col = vec3(1,0,0); //Range check\n    //col = clamp(col, 0.0, 1.0);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//more flow-freq content than Bluish Noise (https://www.shadertoy.com/view/MtdBzB) but more isotropic\n//also doesnt require complicated s-curve remapping and animates in a cyclic manner\n\n// original comments:\n//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//Horizontal + Vertical Discrete Fourier Transform of the input \n//adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n#ifdef SHOW_FOURIER\n    if(fragCoord.x > SIZE || fragCoord.y > SIZE) return;\n    \n    for(float i = 0.; i < SIZE; i++)  \n\t{\n\t\tvec2 xn = texelFetch(iChannel0, ivec2(i, fragCoord.y), 0).rr;\n        vec2 yn = texelFetch(iChannel1, ivec2(fragCoord.x, i), 0).ba;\n\t\tvec2 ang = - 6.2831853 * (fragCoord-.5 -SIZE/2.) * i/SIZE;\n\t\tfragColor.zw += cmul(xn, ang.x);\n\t\tfragColor.xy += cmul(yn, ang.y);\n    }\n#endif\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//more flow-freq content than Bluish Noise (https://www.shadertoy.com/view/MtdBzB) but more isotropic\n//also doesnt require complicated s-curve remapping and animates in a cyclic manner\n\n// original comments:\n//2D Signal Inspector\n//by nimitz 2018 (twitter: @stormoid)\n\n//Type 1 = Orbit noise (https://www.shadertoy.com/view/4t3yDn)\n//Type 2 = Bicubic noise (https://www.shadertoy.com/view/XlVcWV)\n//Type 3 = Value noise\n//Type 4 = Gradient noise (from iq : https://www.shadertoy.com/view/XdXGW8)\n//Type 5 = Simplex noise (modified from iq's to use normalized gradients as per the original paper)\n//Type 6 = FBM (base noise can be defined in buffer A)\n#define NOISE_TYPE 1\n\n#define SCROLL_COORDS\n#define DIAGONAL_DERIVATIVES\n#define SHOW_FOURIER\n#define SIZE (floor(iResolution.y/2.25)*2.)\n\nconst float globalScale = 1.;\n\n\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c) \n{\n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u; \n}\n\n\nuint  asuint2(float x) { return x == 0.0 ? 0u : floatBitsToUint(x); }\nuvec2 asuint2(vec2 x) { return uvec2(asuint2(x.x ), asuint2(x.y)); }\nuvec3 asuint2(vec3 x) { return uvec3(asuint2(x.xy), asuint2(x.z)); }\nuvec4 asuint2(vec4 x) { return uvec4(asuint2(x.xy), asuint2(x.zw)); }\n\nfloat Float01(uint x) { return float(    x ) * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nvec2 Float01(uvec2 x) { return vec2(      x ) * (1.0 / 4294967296.0); }\nvec2 Float11(uvec2 x) { return vec2(ivec2(x)) * (1.0 / 2147483648.0); }\n\nvec3 Float01(uvec3 x) { return vec3(      x ) * (1.0 / 4294967296.0); }\nvec3 Float11(uvec3 x) { return vec3(ivec3(x)) * (1.0 / 2147483648.0); }\n\nvec4 Float01(uvec4 x) { return vec4(      x ) * (1.0 / 4294967296.0); }\nvec4 Float11(uvec4 x) { return vec4(ivec4(x)) * (1.0 / 2147483648.0); }\n\nconst uint rPhi1  = 2654435761u;\n\nconst uint rPhi2a = 3242174893u;\nconst uint rPhi2b = 2447445397u;\n\nconst uint rPhi3a = 3518319149u;\nconst uint rPhi3b = 2882110339u;\nconst uint rPhi3c = 2360945581u;\n\nconst uint rPhi4a = 3679390609u;\nconst uint rPhi4b = 3152041517u;\nconst uint rPhi4c = 2700274807u;\nconst uint rPhi4d = 2313257579u;\n\nconst uvec2 rPhi2 = uvec2(rPhi2a, rPhi2b);\nconst uvec3 rPhi3 = uvec3(rPhi3a, rPhi3b, rPhi3c);\nconst uvec4 rPhi4 = uvec4(rPhi4a, rPhi4b, rPhi4c, rPhi4d);\n\nuint  Roberts(uint  off, uint n) { return off + rPhi1 * n; }\nuvec2 Roberts(uvec2 off, uint n) { return off + rPhi2 * n; }\nuvec3 Roberts(uvec3 off, uint n) { return off + rPhi3 * n; }\nuvec4 Roberts(uvec4 off, uint n) { return off + rPhi4 * n; }\n\n#define _SEED uvec4(0xCAF0FC2Eu, 0xEA18994Au, 0x4D86D399u, 0x10EB49F0u)\n\nuvec4 PhiHash(uint  v, uint seed) { return ((v   * rPhi2a)                                                    ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec2 v, uint seed) { return ((v.x * rPhi2a) ^ (v.y * rPhi2b)                                   ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec3 v, uint seed) { return ((v.x * rPhi3a) ^ (v.y * rPhi3b) ^ (v.z * rPhi3c)                  ^ (_SEED ^ uvec4(seed))) * rPhi1; }\nuvec4 PhiHash(uvec4 v, uint seed) { return ((v.x * rPhi4a) ^ (v.y * rPhi4b) ^ (v.z * rPhi4c) ^ (v.w * rPhi4d) ^ (_SEED ^ uvec4(seed))) * rPhi1; }\n\nvec4 PhiHash01(float v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec2  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec3  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash01(vec4  v, uint seed) { return Float01(PhiHash(asuint2(v), seed)); }\n\nvec4 PhiHash11(float v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec2  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec3  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\nvec4 PhiHash11(vec4  v, uint seed) { return Float11(PhiHash(asuint2(v), seed)); }\n\n\nuint MixHash(uvec2 h)\n{\n    return ((h.x ^ (h.y >> 16u)) * rPhi2.x) ^ \n           ((h.y ^ (h.x >> 16u)) * rPhi2.y);\n}\n\nuint MixHash(uvec3 h)\n{\n    return ((h.x ^ (h.y >> 16u) ^ (h.z << 15u)) * rPhi3.x) ^ \n           ((h.y ^ (h.z >> 16u) ^ (h.y << 15u)) * rPhi3.y) ^\n           ((h.z ^ (h.y >> 16u) ^ (h.x << 15u)) * rPhi3.z);\n}\n\nuint MixHash(uvec4 h)\n{\n    return ((h.x ^ (h.y >> 16u) ^ (h.z << 15u)) * rPhi4.x) ^ \n           ((h.y ^ (h.z >> 16u) ^ (h.w << 15u)) * rPhi4.y) ^\n           ((h.z ^ (h.w >> 16u) ^ (h.x << 15u)) * rPhi4.z) ^\n           ((h.w ^ (h.x >> 16u) ^ (h.y << 15u)) * rPhi4.w);\n}\n\n// low bias version https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash(uint x)\n{\n    x ^= x >> 16u;\n    x *= 0x7feb352dU;\n    x ^= x >> 15u;\n    x *= 0x846ca68bU;\n    x ^= x >> 16u;\n\n    return x;\n}\n\nuvec2 WellonsHash(uvec2 h) { return uvec2(WellonsHash(h.x), WellonsHash(h.y)); }\nuvec3 WellonsHash(uvec3 h) { return uvec3(WellonsHash(h.x), WellonsHash(h.y), WellonsHash(h.z)); }\nuvec4 WellonsHash(uvec4 h) { return uvec4(WellonsHash(h.x), WellonsHash(h.y), WellonsHash(h.z), WellonsHash(h.w)); }\n\nuvec4 WellonsHash(uint  v, uint seed) { return WellonsHash(        v  ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec2 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec3 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash(uvec4 v, uint seed) { return WellonsHash(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\n\n// minimal bias version https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash2(uint x)\n{\n    x ^= x >> 17u;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11u;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15u;\n    x *= 0x31848babU;\n    x ^= x >> 14u;\n\n    return x;\n}\n\nuvec2 WellonsHash2(uvec2 h) { return uvec2(WellonsHash2(h.x), WellonsHash2(h.y)); }\nuvec3 WellonsHash2(uvec3 h) { return uvec3(WellonsHash2(h.x), WellonsHash2(h.y), WellonsHash2(h.z)); }\nuvec4 WellonsHash2(uvec4 h) { return uvec4(WellonsHash2(h.x), WellonsHash2(h.y), WellonsHash2(h.z), WellonsHash2(h.w)); }\n\nuvec4 WellonsHash2(uint  v, uint seed) { return WellonsHash2(        v  ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec2 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec3 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\nuvec4 WellonsHash2(uvec4 v, uint seed) { return WellonsHash2(MixHash(v) ^ (_SEED ^ uvec4(seed))); }\n\n#undef _SEED\n\n\n// https://en.wikipedia.org/wiki/Linear_congruential_generator\nuint LCG(uint x) { return x * 22695477u + 1u; }\n\nfloat Hash01(inout uint h)\n{\n    h = LCG(h);\n\n    return Float01(h * rPhi1);\n}\n\nfloat Hash11(inout uint h)\n{\n    h = LCG(h);\n\n    return Float11(h * rPhi1);\n}\n\nuint HashU(inout uint h)\n{\n    h = LCG(h);\n\n    return h * rPhi1;\n}\n\nvec2 Hash01x2(inout uint h) { return vec2(Hash01(h), Hash01(h)); }\nvec3 Hash01x3(inout uint h) { return vec3(Hash01(h), Hash01(h), Hash01(h)); }\nvec4 Hash01x4(inout uint h) { return vec4(Hash01(h), Hash01(h), Hash01(h), Hash01(h)); }\n\nvec2 Hash11x2(inout uint h) { return vec2(Hash11(h), Hash11(h)); }\nvec3 Hash11x3(inout uint h) { return vec3(Hash11(h), Hash11(h), Hash11(h)); }\nvec4 Hash11x4(inout uint h) { return vec4(Hash11(h), Hash11(h), Hash11(h), Hash11(h)); }\n\nuvec2 HashUx2(inout uint h) { return uvec2(HashU(h), HashU(h)); }\nuvec3 HashUx3(inout uint h) { return uvec3(HashU(h), HashU(h), HashU(h)); }\nuvec4 HashUx4(inout uint h) { return uvec4(HashU(h), HashU(h), HashU(h), HashU(h)); }\n","name":"Common","description":"","type":"common"}]}