{"ver":"0.1","info":{"id":"slKXWV","date":"1641558854","viewed":589,"name":"Explicit Radiosity","username":"Mathis","description":"Classic explicit radiosity with precomputed formfactors.\n\n\nUse the mouse to move the spotlight.","likes":30,"published":1,"flags":32,"usePreview":0,"tags":["global","illumination","radiosity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nExplicit radiosity with bicubic interpolation and static geometry\n    Hardware mipmaps allows for a fast gather step\n    It can integrate over a constant sky, but memory constraints in the cubemap makes this difficult to implement properly\n\nAdjustable settings\n    NRays controls how many samples we estimate the visibility. Reset the shader when updating this variable\n        to recompute the formfactors\n    MultiBounce - set to 0 to disable multibounce lighting\n\n\nControls\n    Click and hold to change the direction of the spotlight\n*/\n\nvec3 acesFilm(vec3 x) {\n    //Aces film curve\n    return clamp((x*(2.51*x+0.03))/(x*(2.43*x+0.59)+0.14),0.,1.);\n}\n\nvec4 textureBicubic(vec2 texCoords, vec4 cps) {\n    //https://stackoverflow.com/questions/13501081/efficient-bicubic-filtering-code-in-glsl\n    vec2 texSize = vec2(1024.);\n    vec2 invTexSize = vec2(I1024);\n    texCoords = texCoords - 0.5;\n    vec2 fxy = fract(texCoords);\n    texCoords -= fxy;\n    vec4 xcubic = cubic(fxy.x);\n    vec4 ycubic = cubic(fxy.y);\n    vec4 c = texCoords.xxyy + vec2 (-0.5, +1.5).xyxy;\n    vec4 s = vec4(xcubic.xz + xcubic.yw, ycubic.xz + ycubic.yw);\n    vec4 offset = c + vec4 (xcubic.yw, ycubic.yw) / s;\n    vec4 sample0 = texture(iChannel0, vec3(clamp(offset.xz,cps.xy,cps.zw)*I512-1.,1.));\n    vec4 sample1 = texture(iChannel0, vec3(clamp(offset.yz,cps.xy,cps.zw)*I512-1.,1.));\n    vec4 sample2 = texture(iChannel0, vec3(clamp(offset.xw,cps.xy,cps.zw)*I512-1.,1.));\n    vec4 sample3 = texture(iChannel0, vec3(clamp(offset.yw,cps.xy,cps.zw)*I512-1.,1.));\n    float sx = s.x / (s.x + s.y);\n    float sy = s.z / (s.z + s.w);\n    return mix(mix(sample3, sample2, sx), mix(sample1, sample0, sx), sy);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 UV=fragCoord;\n    vec3 Color=vec3(0.);\n    //Set up camera\n    vec2 Angles=vec2(PI*1.5,PI*0.48);\n    vec3 Eye=-vec3(sin(Angles.y)*vec2(cos(Angles.x),sin(Angles.x)),cos(Angles.y)).xzy;\n    vec3 Pos=vec3(0.5,0.5,0.5)-Eye*1.08;\n    vec3 Dir=normalize(vec3((fragCoord*IRES*2.-1.)*(ASPECT*CFOV),1.)*TBN(Eye));\n    //Render scene\n    vec2 LUV; Rect CRect; HIT Pixel=Render(Pos,Dir);\n    if (Pixel.i>=0) {\n        CRect=Rectangles[Pixel.i];\n        float COffset=RESOffset[Pixel.i];\n        LUV=vec2(dot(Pixel.P-CRect.p0,CRect.p1-CRect.p0)*16./CRect.dim.x+COffset,\n                 dot(Pixel.P-CRect.p0,CRect.p2-CRect.p0)*16./CRect.dim.y);\n        vec2 ClampP=vec2(COffset+0.5,0.5);\n        vec3 Integral=textureBicubic(LUV,vec4(ClampP,ClampP+CRect.dim*16.-1.)).xyz;\n            //Nearest neighbour - integral\n            //Integral=texture(iChannel0,vec3(clamp(floor(LUV)+0.5,ClampP,ClampP+CRect.dim*16.-1.)*I512-1.,1.)).xyz;\n        vec3 Emissive=vec3(0.); //textureBicubic(LUV+vec2(112.,0.),vec4(ClampP+vec2(112.,0.),ClampP+vec2(112.,0.)+CRect.dim*16.-1.)).xyz;\n            //Nearest neighbour - emissive\n            //Emissive=texture(iChannel0,vec3((clamp(floor(LUV)+0.5,ClampP,ClampP+CRect.dim*16.-1.)+vec2(112.,0.))*I512-1.,1.)).xyz;\n        //Lightsource\n        float LCR=0.05;\n        vec3 LPos=vec3(0.5,0.3,0.4);\n        vec3 MouseDir=normalize(vec3((iMouse.xy*IRES*2.-1.)*(ASPECT*CFOV),1.)*TBN(Eye));\n        vec3 LDir; HIT PP=Render(Pos,MouseDir);\n        if (PP.i<0) {\n            LDir=normalize(vec3(1.,1.75,0.));\n        } else {\n            LDir=normalize(PP.P-LPos);\n        }\n        //Visibility\n        vec3 LTP=normalize(Pixel.P-LPos);\n        float LDot=dot(LDir,LTP);\n        if (LDot>(1.-LCR)) {\n            PP=Render(LPos,LTP);\n            if (PP.D>length(Pixel.P-LPos)-I32) Emissive+=1.25*max(0.,(LDot-(1.-LCR))/LCR);\n        }\n        Color=Emissive*(0.25+0.75*Pixel.C)+Integral*Pixel.C;\n    } else {\n        //Sky\n        Color=SkyLight*0.;\n    }\n    //Color=texture(iChannel0,vec3((floor(UV*0.25)+0.5)*I512-1.,1.)).xyz; //Cubemap\n    //Output\n    fragColor=vec4(pow(acesFilm(Color),vec3(0.45)),1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Settings\nconst float NRays=4.;\nconst float FOV=0.7; //In radians\nconst vec3 SkyLight=vec3(0.2,0.45,1.);\nconst float MultiBounce=1.; //0 - single bounce, 1 - multibounce\n\n//Other vars\nconst int NRects=13;\nconst float CFOV=tan(FOV);\nconst float PI=3.141592653;\nconst float PI2=PI*2.;\nconst float IPI2=0.5/PI;\nconst float I6=1./6.;\nconst float I9=1./9.;\nconst float I16=1./16.;\nconst float I32=1./32.;\nconst float I64=1./64.;\nconst float I512=1./512.;\nconst float I1024=1./1024.;\n#define RES iResolution.xy\n#define IRES (1./iChannelResolution[1].xy)\n#define ASPECT vec2(iChannelResolution[1].x/iChannelResolution[1].y,1.)\n\nstruct HIT { float D; vec3 P; vec3 N; vec3 C; int i; };\nstruct Rect { vec3 p0; vec3 p1; vec3 p2; vec2 dim; vec3 C; };\n\nfloat RESOffset[NRects]=float[NRects](0.,16.,32.,48.,64.,80.,84.,88.,92.,96.,98.,100.,106.);\nRect Rectangles[NRects]=Rect[NRects](\n   Rect(vec3(0.),vec3(0.,0.,1.),vec3(1.,0.,0.),vec2(1.),vec3(1.)), //Floor\n       Rect(vec3(0.,1.,0.),vec3(1.,1.,0.),vec3(0.,1.,1.),vec2(1.),vec3(1.)), //Ceiling\n       Rect(vec3(0.),vec3(0.,1.,0.),vec3(0.,0.,1.),vec2(1.),vec3(1.,0.15,0.15)), //Red\n           Rect(vec3(1.,0.,0.),vec3(1.,0.,1.),vec3(1.,1.,0.),vec2(1.),vec3(0.35,0.9,0.35)), //Green\n       Rect(vec3(1.,0.,1.),vec3(0.,0.,1.),vec3(1.,1.,1.),vec2(1.),vec3(1.)), //Wall behind\n   Rect(vec3(0.5+I16,0.,0.5),vec3(0.5+I16,0.,0.75),vec3(0.5+I16,1.,0.5),vec2(0.25,1.),vec3(1.)), //LÃ¥ng stolpe\n           Rect(vec3(0.75+I16,0.,0.75),vec3(0.75+I16,0.,0.5),vec3(0.75+I16,1.,0.75),vec2(0.25,1.),vec3(1.)), //Opposite\n       Rect(vec3(0.75+I16,0.,0.5),vec3(0.5+I16,0.,0.5),vec3(0.75+I16,1.,0.5),vec2(0.25,1.),vec3(1.)), //Andra sidan\n           Rect(vec3(0.5+I16,0.,0.75),vec3(0.75+I16,0.,0.75),vec3(0.5+I16,1.,0.75),vec2(0.25,1.),vec3(1.)), //Opposite\n   Rect(vec3(0.25,0.,0.3125),vec3(0.125,0.,0.3125),vec3(0.25,1.,0.3125),vec2(0.125,1.),vec3(1.)), //Box side forw\n       Rect(vec3(0.125,0.,0.6875),vec3(0.25,0.,0.6875),vec3(0.125,1.,0.6875),vec2(0.125,1.),vec3(1.)), //Side back\n       Rect(vec3(0.25,0.,0.6875),vec3(0.25,0.,0.3125),vec3(0.25,1.,0.6875),vec2(0.375,1.),vec3(1.)),\n           Rect(vec3(0.125,0.,0.3125),vec3(0.125,0.,0.6875),vec3(0.125,1.,0.3125),vec2(0.375,1.),vec3(1.))\n   );\n\nmat3 TBN(vec3 N) {\n    vec3 Nb,Nt;\n    if (abs(N.y)>0.999) {\n        Nb=vec3(1.,0.,0.);\n        Nt=vec3(0.,0.,1.);\n    } else {\n    \tNb=normalize(cross(N,vec3(0.,1.,0.)));\n    \tNt=normalize(cross(Nb,N));\n    }\n    return mat3(Nb.x,Nt.x,N.x,Nb.y,Nt.y,N.y,Nb.z,Nt.z,N.z);\n}\n\nvec3 TBN(vec3 N, out vec3 O) {\n    O=normalize(cross(N,vec3(0.001,1.,0.)));\n    return normalize(cross(O,N));\n}\n\nvec3 RandSample(vec2 v) {\n    float theta=sqrt(v.x);\n    float phi=2.*3.14159*v.y;\n    float x=theta*cos(phi);\n    float z=theta*sin(phi);\n    return vec3(x,z,sqrt(max(0.,1.-v.x)));\n}\n\nfloat Box2(vec2 p, vec2 b) {\n    vec2 d=abs(p-b*0.5)-b*0.5;\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\nbool RectHit(vec3 p, vec3 d, Rect R, out float D, out vec3 N) {\n    N=normalize(cross(R.p1-R.p0,R.p2-R.p0));\n    float NSign=sign(dot(p-R.p0,N));\n    N=N*NSign;\n    //Plane intersection\n    float NDot=dot(N,d);\n    float PDot=dot(N,p-R.p0);\n    if (NDot>=0. || PDot<=0.) return false;\n    D=-PDot/NDot;\n    vec3 sp=p+d*D;\n    return (Box2(vec2(dot(sp-R.p0,R.p1-R.p0)/R.dim.x,dot(sp-R.p0,R.p2-R.p0)/R.dim.y),R.dim)<=0.);\n}\n\nHIT Render(vec3 Pos, vec3 Dir) {\n    //Ray tracing against geometry\n    float sd; float D=10000.; Rect Sample; vec3 sn; HIT OUT=HIT(D,vec3(0.),vec3(0.),vec3(0.),-1);\n    for (int i=0; i<NRects; i++) {\n        Sample=Rectangles[i];\n        if (RectHit(Pos,Dir,Sample,sd,sn)) {\n            if (sd<D) {\n                D=sd;\n                OUT=HIT(D,Pos+Dir*D,sn,Sample.C,i);\n            }\n        }\n    }\n    return OUT;\n}\n\nvec4 cubic(float v) {\n    vec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;\n    vec4 s = n * n * n;\n    float x = s.x;\n    float y = s.y - 4.0 * s.x;\n    float z = s.z - 4.0 * s.y + 6.0 * s.x;\n    float w = 6.0 - x - y - z;\n    return vec4(x, y, z, w);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":3,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"//Radiosity patches, visibility and mipmaps\n\nint ComputeIndex(vec2 UV) {\n    int Index=int(floor(UV.x*I16));\n    if (UV.x>80.) {\n        if (UV.x<96.) Index=5+int(floor((UV.x-80.)*0.25));\n        else if (UV.x<100.) Index=9+int(floor((UV.x-96.)*0.5));\n        else Index=11+int(floor((UV.x-100.)*I6));\n    }\n    return Index;\n}\n\nvoid ComputePN(vec2 UV, Rect CRect, int Index, out vec3 P, out vec3 N) {\n    vec2 puv=vec2(UV.x-RESOffset[Index],UV.y)*I16;\n    P=CRect.p0+normalize(CRect.p1-CRect.p0)*puv.x+normalize(CRect.p2-CRect.p0)*puv.y;\n    N=normalize(cross(CRect.p1-CRect.p0,CRect.p2-CRect.p0));\n}\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir) {\n    vec4 Output=texture(iChannel0,rayDir,0.);\n    vec2 Angles=vec2(PI*1.5,PI*0.48);\n    vec3 Eye=-vec3(sin(Angles.y)*vec2(cos(Angles.x),sin(Angles.x)),cos(Angles.y)).xzy;\n    vec3 Pos=vec3(0.5,0.5,0.5)-Eye*1.08;\n    vec2 UV; vec3 aDir=abs(rayDir);\n    if (aDir.z>max(aDir.x,aDir.y)) {\n        //Z-side\n        UV = floor(((rayDir.xy/aDir.z)*0.5+0.5)*1024.)+0.5;\n        if (rayDir.z>0.) {\n            //Positive z-side\n        } else {\n            //Negative z-side\n            UV.y+=1024.;\n        }\n        if (UV.y<16.) {\n            if (UV.x<112.) {\n                /*\n                //Path tracing reference (single bounce)\n                int Index=ComputeIndex(UV);\n                Rect CRect=Rectangles[Index];\n                vec2 puv=vec2(UV.x-RESOffset[Index],UV.y)*I16;\n                vec3 PPos=CRect.p0+normalize(CRect.p1-CRect.p0)*puv.x+normalize(CRect.p2-CRect.p0)*puv.y;\n                vec3 PN=normalize(cross(CRect.p1-CRect.p0,CRect.p2-CRect.p0));\n                vec3 L=vec3(0.);\n                vec3 SRD=RandSample(texture(iChannel3,(UV+float(iFrame)*vec2(36.,45.))*I1024).xy)*TBN(PN);\n                HIT Pixel=Render(PPos+PN*I32,SRD);\n                if (Pixel.D>9990.) {\n                    //L+=SkyLight*(SRD.y*0.5+0.5);\n                } else {\n                    Rect PRect=Rectangles[Pixel.i];\n                    float POffset=RESOffset[Pixel.i];\n                    vec2 PLUV=vec2(dot(Pixel.P-PRect.p0,PRect.p1-PRect.p0)*16./PRect.dim.x+POffset,\n                             dot(Pixel.P-PRect.p0,PRect.p2-PRect.p0)*16./PRect.dim.y);\n                    L+=texture(iChannel0,vec3(vec2(PLUV.x+112.,PLUV.y)*I512-1.,1.)).xyz;\n                }\n                Output.xyz=mix(Output.xyz,L,1./256.);\n                //*/\n                \n                //*\n                //Gather step\n                float PIndex=floor(UV.x)+floor(UV.y)*112.;\n                float SPN; vec2 MipOffset;\n                if (PIndex<1143. && iFrame>2) {\n                    if (PIndex<567.) {\n                        MipOffset=vec2(mod(PIndex,9.)*112.+8.,floor((PIndex+0.5)*I9)*16.+24.);\n                        SPN=1.;\n                    } else {\n                        MipOffset=vec2(mod(PIndex-567.,9.)*112.+8.,floor((PIndex-567.+0.5)*I9)*16.+8.);\n                        SPN=-1.;\n                    }\n                    Output=textureLod(iChannel0,vec3(MipOffset*I512-1.,SPN),4.)+\n                        textureLod(iChannel0,vec3(vec2(MipOffset.x+16.,MipOffset.y)*I512-1.,SPN),4.)+\n                        textureLod(iChannel0,vec3(vec2(MipOffset.x+32.,MipOffset.y)*I512-1.,SPN),4.)+\n                        textureLod(iChannel0,vec3(vec2(MipOffset.x+48.,MipOffset.y)*I512-1.,SPN),4.)+\n                        textureLod(iChannel0,vec3(vec2(MipOffset.x+64.,MipOffset.y)*I512-1.,SPN),4.)+\n                        textureLod(iChannel0,vec3(vec2(MipOffset.x+80.,MipOffset.y)*I512-1.,SPN),4.)+\n                        textureLod(iChannel0,vec3(vec2(MipOffset.x+96.,MipOffset.y)*I512-1.,SPN),4.);\n                } else if (PIndex<1792. && iFrame>2) {\n                    if (PIndex<1719.) {\n                        MipOffset=vec2(mod(PIndex-1143.,9.)*112.+8.,floor((PIndex-1143.+0.5)*I9)*16.+8.);\n                        SPN=1.;\n                    } else {\n                        MipOffset=vec2(mod(PIndex-1719.,9.)*112.+8.,floor((PIndex-1719.+0.5)*I9)*16.+8.);\n                        SPN=-1.;\n                    }\n                    Output=textureLod(iChannel0,vec3(SPN,MipOffset*I512-1.),4.)+\n                        textureLod(iChannel0,vec3(SPN,vec2(MipOffset.x+16.,MipOffset.y)*I512-1.),4.)+\n                        textureLod(iChannel0,vec3(SPN,vec2(MipOffset.x+32.,MipOffset.y)*I512-1.),4.)+\n                        textureLod(iChannel0,vec3(SPN,vec2(MipOffset.x+48.,MipOffset.y)*I512-1.),4.)+\n                        textureLod(iChannel0,vec3(SPN,vec2(MipOffset.x+64.,MipOffset.y)*I512-1.),4.)+\n                        textureLod(iChannel0,vec3(SPN,vec2(MipOffset.x+80.,MipOffset.y)*I512-1.),4.)+\n                        textureLod(iChannel0,vec3(SPN,vec2(MipOffset.x+96.,MipOffset.y)*I512-1.),4.);\n                }\n                //*/\n            } else if (UV.x<224.) {\n                //Painted emissive\n                int Index=ComputeIndex(vec2(UV.x-112.,UV.y));\n                Rect CRect=Rectangles[Index];\n                vec2 puv=vec2(UV.x-RESOffset[Index]-112.,UV.y)*I16;\n                vec3 PPos=CRect.p0+normalize(CRect.p1-CRect.p0)*puv.x+normalize(CRect.p2-CRect.p0)*puv.y;\n                vec3 PN=normalize(cross(CRect.p1-CRect.p0,CRect.p2-CRect.p0));\n                //Lightsource\n                float LCR=0.05;\n                vec3 LPos=vec3(0.5,0.3,0.4);\n                vec3 MouseDir=normalize(vec3((iMouse.xy*IRES*2.-1.)*(ASPECT*CFOV),1.)*TBN(Eye));\n                vec3 LDir; HIT Pixel=Render(Pos,MouseDir);\n                if (Pixel.i<0) {\n                    LDir=normalize(vec3(1.,1.75,0.));\n                } else {\n                    LDir=normalize(Pixel.P-LPos);\n                }\n                //Visibility\n                vec3 LTP=normalize(PPos-LPos);\n                float LDot=dot(LDir,LTP);\n                if (LDot>(1.-LCR)) {\n                    Pixel=Render(LPos,LTP);\n                    if (Pixel.D>length(PPos-LPos)-I32)\n                        Output.xyz=CRect.C*1.25*max(0.,(LDot-(1.-LCR))/LCR);\n                } else\n                    Output.xyz=vec3(0.);\n            }\n        } else if (UV.x<1008.) {\n            //Formfactors\n            UV.y+=-16.;\n            if (iFrame<2) {\n                //Formfactor precompute\n                int RectIndex=int(floor(UV.x/112.));\n                float PixIndex=floor(UV.y*I16)*9.+floor(UV.x/112.);\n                vec2 PixUV=vec2(mod(PixIndex,112.),floor(PixIndex/112.))+0.5; //Pixel UV\n                vec2 SUV=mod(UV,vec2(112.,16.)); //Sample uv\n                int PIndex=ComputeIndex(PixUV);\n                int SIndex=ComputeIndex(SUV);\n                if (PIndex==SIndex)\n                    Output=vec4(0.);\n                else {\n                    Rect PRect=Rectangles[PIndex];\n                    Rect SRect=Rectangles[SIndex];\n                    vec3 PPos,PN,SPos,SN;\n                    ComputePN(PixUV,PRect,PIndex,PPos,PN);\n                    ComputePN(SUV,SRect,SIndex,SPos,SN);\n                    //Compute analytic part of formfactor\n                    vec3 PTS=normalize(SPos-PPos);\n                    float PDot=dot(PN,PTS);\n                    float SDot=dot(SN,-PTS);\n                    if (SDot>0. && PDot>0.) {\n                        //Approximate visibility\n                        float V=0.;\n                        vec2 rv2; vec3 SRD; HIT Pixel;\n                        for (float r=0.; r<NRays; r++) {\n                            rv2=(texture(iChannel3,(PixUV*37.+r*vec2(157.34,203.25))*I1024).xy*0.5-1.)*I16;\n                            SRD=normalize((SPos+(SRect.p1-SRect.p0)*rv2.x+(SRect.p2-SRect.p0)*rv2.y)-PPos);\n                            Pixel=Render(PPos+PN*I32,SRD);\n                            V+=float(Pixel.i==SIndex);\n                        }\n                        V=V/NRays;\n                        //Store the formfactor/Area\n                        Output=vec4(V*PDot*SDot/(PI*dot(PPos-SPos,PPos-SPos)));\n                    } else\n                        Output=vec4(0.);\n                }\n            } else {\n                //Iterative Light*Formfactor\n                vec2 SUV=mod(UV,vec2(112.,16.));\n                Rect SRect=Rectangles[ComputeIndex(SUV)];\n                vec3 Integral=texture(iChannel0,vec3(SUV*I512-1.,1.)).xyz;\n                vec3 Emissive=texture(iChannel0,vec3((SUV+vec2(112.,0.))*I512-1.,1.)).xyz;\n                Output.xyz=(Integral*SRect.C*MultiBounce+Emissive)*Output.w;\n            }\n        }\n    } else if (aDir.x>aDir.y) {\n        //X-side\n        UV = floor(((rayDir.yz/aDir.x)*0.5+0.5)*1024.)+0.5;\n        if (rayDir.x>0.) {\n            UV.y+=2032.;\n        } else {\n            UV.y+=3056.;\n        }\n        if (iFrame<2) {\n            //Formfactors\n            int RectIndex=int(floor(UV.x/112.));\n            float PixIndex=floor(UV.y*I16)*9.+floor(UV.x/112.);\n            vec2 PixUV=vec2(mod(PixIndex,112.),floor(PixIndex/112.))+0.5; //Pixel UV\n            vec2 SUV=mod(UV,vec2(112.,16.)); //Sample uv\n            int PIndex=ComputeIndex(PixUV);\n            int SIndex=ComputeIndex(SUV);\n            if (PIndex==SIndex || PixIndex>=1792.)\n                Output=vec4(0.);\n            else {\n                Rect PRect=Rectangles[PIndex];\n                Rect SRect=Rectangles[SIndex];\n                vec3 PPos,PN,SPos,SN;\n                ComputePN(PixUV,PRect,PIndex,PPos,PN);\n                ComputePN(SUV,SRect,SIndex,SPos,SN);\n                //Compute analytic part of formfactor\n                vec3 PTS=normalize(SPos-PPos);\n                float PDot=dot(PN,PTS);\n                float SDot=dot(SN,-PTS);\n                if (SDot>0. && PDot>0.) {\n                    //Approximate visibility\n                    float V=0.;\n                    vec2 rv2; vec3 SRD; HIT Pixel;\n                    rv2=vec2(0.);\n                    SRD=normalize((SPos+(SRect.p1-SRect.p0)*rv2.x+(SRect.p2-SRect.p0)*rv2.y)-PPos);\n                    Pixel=Render(PPos+PN*I32,SRD);\n                    V+=float(Pixel.i==SIndex);\n                    //Store the formfactor/Area\n                    Output=vec4(V*PDot*SDot/(PI*dot(PPos-SPos,PPos-SPos)));\n                } else\n                    Output=vec4(0.);\n            }\n        } else {\n            //Iterative Light*Formfactor\n            vec2 SUV=mod(UV,vec2(112.,16.));\n            Rect SRect=Rectangles[ComputeIndex(SUV)];\n            vec3 Integral=texture(iChannel0,vec3(SUV*I512-1.,1.)).xyz;\n            vec3 Emissive=texture(iChannel0,vec3((SUV+vec2(112.,0.))*I512-1.,1.)).xyz;\n            Output.xyz=(Integral*SRect.C*MultiBounce+Emissive)*Output.w;\n        }\n    }\n    fragColor=Output;\n}","name":"Cube A","description":"","type":"cubemap"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Necessary for IRES in cubemap\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor=vec4(0.);\n}","name":"Buffer A","description":"","type":"buffer"}]}