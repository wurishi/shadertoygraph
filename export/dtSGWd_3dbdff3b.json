{"ver":"0.1","info":{"id":"dtSGWd","date":"1676916984","viewed":3359,"name":"Cube Falls","username":"mhnewman","description":"Procedurally generated voxel waterfall scene.\n\nTo really cook your GPU, use LIVE_ITER in the Common tab\nTime between scene changes is also in Common tab","likes":88,"published":1,"flags":32,"usePreview":1,"tags":["procedural","cube","voxel","waterfall","stream","falls"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Brute force ambient occlusion, depth of field, spherical aberration,\n// and anti aliasing using accumulation buffer.\n//\n// Based on www.shadertoy.com/view/llccD2 Brute Force Accumulation.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = pow(texture(iChannel0, fragCoord / iResolution.xy), vec4(0.7)) * 1.3;\n#if SCENE_TIME > 0\n    float t = fract(iTime / float(SCENE_TIME));\n    fragColor *= (1.0 - exp(-50.0 * t)) * (1.0 - exp(-50.0 * (1.0 - t)));\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Time in seconds between switching scenes\n// Set to 0 for switching scenes on mouse clicks\n#define SCENE_TIME 4\n\n// Iterations per frame\n// Set to 0 for accumulation over multiple frames\n#define LIVE_ITER 0\n\n//#define REDUCED_COLOR_PALETTE\n\nfloat hash1(float p) {\n\tvec2 p2 = fract(p * vec2(5.3983, 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nfloat hash1(vec2 p2) {\n    p2 = fract(p2 * vec2(5.3983, 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n    return fract(p2.x * p2.y * 95.4337);\n}\n\nfloat hash1(vec3 p3) {\n    p3 = fract(p3 * vec3(5.3983, 5.4427, 6.9371));\n    p3 += dot(p3, p3.yxz + 19.19);\n    return fract(p3.x * p3.y * p3.z);\n}\n\nvec2 hash2(float p) {\n    vec3 p3 = fract(vec3(p) * vec3(5.3983, 5.4427, 6.9371));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec2 hash2(vec3 p3) {\n\tp3 = fract(p3 * vec3(5.3983, 5.4427, 6.9371));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec4 hash4(float p) {\n    vec4 p4 = fract(vec4(p) * vec4(5.3983, 5.4427, 6.9371, 7.1283));\n    p4 += dot(p4, p4.wzxy + 33.33);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nvec4 hash4(vec2 p) {\n    vec4 p4 = fract(vec4(p.xyxy) * vec4(5.3983, 5.4427, 6.9371, 7.1283));\n    p4 += dot(p4, p4.wzxy + 33.33);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nvec4 hash4(vec3 p) {\n    vec4 p4 = fract(vec4(p.xyzx) * vec4(5.3983, 5.4427, 6.9371, 7.1283));\n    p4 += dot(p4, p4.wzxy + 33.33);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\n\nfloat noise1(float p) {\n    float i = floor(p);\n    float f = fract(p);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash1(i), hash1(i + 1.0), u);\n}\n\nfloat noise1(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(hash1(i + vec2(0.0, 0.0)), \n                   hash1(i + vec2(1.0, 0.0)), u.x),\n               mix(hash1(i + vec2(0.0, 1.0)), \n                   hash1(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\n\nfloat fbm1(float p) {\n    float f = noise1(p) - 0.5; p = 2.0 * p;\n    f += 0.5 * (noise1(p) - 0.5); p = 2.0 * p;\n    f += 0.25 * (noise1(p) - 0.5); p = 2.0 * p;\n    f += 0.125 * (noise1(p) - 0.5);\n    return f / 1.875;\n}\n\n\nconst mat2 m = mat2(1.616, 1.212, -1.212, 1.616);\n\nfloat fbm1(vec2 p) {\n    float f = noise1(p) - 0.5; p = m * p;\n    f += 0.5 * (noise1(p) - 0.5); p = m * p;\n    f += 0.25 * (noise1(p) - 0.5); p = m * p;\n    f += 0.125 * (noise1(p) - 0.5); p = m * p;\n    f += 0.0625 * (noise1(p) - 0.5);\n    return f / 1.9375;\n}\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 rotate(vec2 pos, float angle) {\n    angle *= 6.2831853;\n    float s = sin(angle);\n    float c = cos(angle);\n    mat2 rot = mat2(c, -s, s, c);\n    return rot * pos;\n}\n\nvec2 rotate(vec2 pos, float angle, float hash) {\n    return rotate(pos, angle * (2.0 * hash1(hash) - 1.0));\n}\n\nvoid waterfall(inout float ground, inout float depth, float dist, vec2 pos, float id) {\n    vec2 h = hash2(id);\n    float fall = 50.0 * (h.x - 0.5) + 20.0 * fbm1(0.03 * pos.x + 100.0 * id);\n    float sq = sqrt(dist);\n    ground += 8.0 * h.y * h.y * smoothstep(fall - 4.0 * sq, fall - 2.0 * sq, pos.y);\n    float foam = 1.0 - h.y + 0.1 * (fall - pos.y);\n    depth = mix(depth, min(depth, foam), step(pos.y, fall));\n}\n\nfloat terrain(vec2 pos, float id) {\n    vec4 h = hash4(id);\n\n    vec2 p = rotate(pos, 0.125);\n    p = rotate(p, 0.15, id + 0.01);\n\n    float width = 6.0 + 10.0 * h.x;\n    float spread = 0.03 * h.y;\n    width *= exp(-spread * p.y);\n\n    float dist = abs(p.x) - width;\n    dist = mix(dist, 7.0 * dist / width, step(dist, 0.0));\n    dist += 20.0 * fbm1(0.1 * p + 10.0 * id);\n    \n    float land = step(0.0, dist);\n    float depth = 0.5 - 0.2 * dist;\n    dist = max(dist, 0.0);\n\n    float plateau = 3.0 + 7.0 * h.z;\n    float slope = 0.1 + 1.2 * h.w;\n    float ground = plateau * (1.0 - exp(-slope * dist / plateau));\n    \n    waterfall(ground, depth, dist, rotate(p, 0.1, id + 0.11), id + 0.1);\n    waterfall(ground, depth, dist, rotate(p, 0.1, id + 0.21), id + 0.2);\n    waterfall(ground, depth, dist, rotate(p, 0.1, id + 0.31), id + 0.3);\n    waterfall(ground, depth, dist, rotate(p, 0.1, id + 0.41), id + 0.4);\n    waterfall(ground, depth, dist, rotate(p, 0.1, id + 0.51), id + 0.5);\n    waterfall(ground, depth, dist, rotate(p, 0.1, id + 0.61), id + 0.6);\n    \n    ground = floor(ground);\n\n    if (land > 0.5) {\n        ground += 1.0;\n        \n        float rocks = step(dist, 4.0 + 6.0 * fbm1(0.3 * p));\n        ground += 0.5 * rocks;\n        \n        vec2 h2 = hash2(id + 0.02);\n        float grassProb = 0.2 + 0.8 * h2.x;\n        float grassDist = 2.0 + 15.0 * h.y;\n        float grass = grassProb * smoothstep(0.0, grassDist, dist);\n        grass = step(hash1(vec3(p, id)), grass);\n        ground += 1.25 * grass;\n\n        ground = -ground;\n    } else {\n        ground += step(3.5 * depth, hash1(vec3(p, id)));\n        ground += 0.5 * clamp(depth, 0.0, 1.0);\n    }\n    \n    return ground;\n}\n\nvec4 run(vec2 pos, float id) {\n    vec4 h1 = hash4(id + 0.8);\n    float treeSpacing = 8.0 + 8.0 * h1.x;\n    float treeSize = (0.6 + 0.4 * h1.y) * treeSpacing;\n    float treeProb = 0.1 + 1.5 * h1.z;\n\n    vec4 h2 = hash4(id + 0.9);\n    float canopyBottom = 0.8 + 0.8 * h2.x;\n    float canopyTop = 0.3 + 1.2 * h2.y;\n    \n    float colorMin = pow(min(h1.w, h2.w), 1.5);\n    float colorScale = pow(max(h1.w, h2.w), 0.7) - colorMin;\n\n    vec2 block = floor(pos / treeSpacing);\n    vec2 p = pos - treeSpacing * block;\n    float treeTop = 0.0;\n    float treeBottom = 1000.0;\n    float trunkTop = 0.0;\n    float trunkBottom = 1000.0;\n    float color = 0.0;\n    for (float x = -1.0; x < 1.5; x += 1.0) {\n        for (float y = -1.0; y < 1.5; y += 1.0) {\n            vec2 offset = vec2(x, y);\n            vec2 treeId = block + offset;\n\n            vec4 h1 = hash4(vec3(treeId, id));\n            vec4 h2 = hash4(vec3(treeId, id + 0.1));\n\n            vec2 treeCenter = treeSpacing * (h1.xy + offset);\n            vec2 trunkCenter = treeSpacing * block + treeCenter;\n            float ground = terrain(trunkCenter, id);\n            \n            float radius = (0.5 + 0.5 * h2.x) * treeSize;\n            float bottom = canopyBottom * radius;\n            float top = canopyTop * radius;\n            \n            float d = distance(p, treeCenter);\n            float r = d / radius;\n            float canopy = 1.0 - r * r + 2.0 * fbm1(0.25 * pos);\n            canopy *= canopyTop * radius;\n            if (ground < -1.0 && canopy > 0.0 && treeProb > h2.y) {\n                float bottom = canopyBottom * radius;\n                ground = floor(abs(ground));\n                float treeT = floor(canopy + ground + bottom);\n                float treeB = floor(ground + bottom - 1.0);\n                float trunkT = treeT;\n                float trunkB = ground - 1.0;\n                bool isTrunk = floor(p) == floor(treeCenter) || r < 0.1;\n                bool wasTrunk = color == 0.0;\n                float treeColor = colorMin + colorScale * h2.z;\n                if (treeT > treeTop) {\n                    if (isTrunk) {\n                        trunkTop = trunkT;\n                        trunkBottom = trunkB;\n                        color = 0.0;\n                    } else {\n                        if (!wasTrunk) {\n                            trunkTop = treeTop;\n                            trunkBottom = treeBottom;\n                            color = 1.0 + floor(16.0 * fract(color));\n                        }\n                    }\n                    treeTop = treeT;\n                    treeBottom = treeB;\n                    color += treeColor;\n                } else if (!wasTrunk && treeT > trunkTop) {\n                    if (isTrunk) {\n                        trunkTop = trunkT;\n                        trunkBottom = trunkB;\n                        color = fract(color);\n                    } else {\n                        trunkTop = treeT;\n                        trunkBottom = treeB;\n                        color = fract(color) + 1.0 + floor(16.0 * treeColor);;\n                    }\n                }\n            }\n        }\n    }\n    treeBottom = clamp(treeBottom, treeTop - 16.0, treeTop - 1.0);\n    float tree = treeTop + (treeTop - treeBottom - 1.0) / 16.0;\n    \n    trunkTop = clamp(trunkTop, trunkBottom + 1.0, trunkBottom + 16.0);\n    float trunk = trunkTop + (trunkTop - trunkBottom - 1.0) / 16.0;\n    \n    return vec4(terrain(pos, id), tree, trunk, color);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pos = floor(fragCoord - 0.5 * iResolution.xy);\n\n    vec4 frame = texture(iChannel0, vec2(0.5) / iResolution.xy);\n    bool resize = abs(frame.x - iResolution.x) + abs(frame.y - iResolution.y) > 0.5;\n    \n#if SCENE_TIME == 0\n    float id = iTime;\n    bool restart = iMouse.z > 0.5 && texture(iChannel0, vec2(1.5, 0.5) / iResolution.xy).z < 0.5;\n#else\n    float id = floor(iTime / float(SCENE_TIME)) + 45.0;\n    bool restart = abs(id - frame.w) > 0.01;\n#endif\n\n    frame.xy = iResolution.xy;\n    frame.z += 1.0;;\n    fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    if (resize || restart) {\n        fragColor = run(pos, id);\n        frame.z = 1.0;\n        frame.w = id;\n    }\n\n    if (fragCoord.x < 1.0 && fragCoord.y < 1.0)\n        fragColor = frame;\n    else if (fragCoord.x < 2.0 && fragCoord.y < 1.0)\n        fragColor = iMouse;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Brute force ambient occlusion, depth of field, spherical aberration,\n// and anti aliasing using accumulation buffer.\n//\n// Based on www.shadertoy.com/view/llccD2 Brute Force Accumulation.\n// Create your scene by filling in setCamera(), voxelHit(), and voxelColor().\n\nconst float sphericalAberration = 0.1;\nconst float vignetting = 0.5;\nconst vec3 backgroundColor = vec3(0.0);\nconst int hitIter = 400;\nconst int shadeIter = 100;\n\n// Set Camera will position and aim the camera.\n//   eye := The location of the camera.\n//   center := The location at which the camera is looking.\n//   focalDist := Center of focus\n//   blurAmount := Amount of depth of field\n//   Return value := Camera focal length.\nfloat setCamera(out vec3 eye, out vec3 center, out float focalDist, out float blurAmount) {\n    float dist = 160.0;\n    focalDist = 150.0;\n    blurAmount = 0.03;    \n    \n    vec2 m = vec2(0.4, 0.55);\n#if LIVE_ITER > 0\n#if SCENE_TIME == 0\n    m.x += 0.01 * iTime;\n#else\n    float t = fract(iTime / float(SCENE_TIME));\n    m.x += 0.02 * t - 0.01;\n    dist -= 20.0 * t;\n    focalDist -= 20.0 * t;\n#endif\n#endif\n    m *= 6.283185 * vec2(1.0, 0.25);    \n    center = vec3(0.0, 0.0, 0.0);\n    eye = center + vec3(dist * sin(m.x) * sin(m.y), dist * cos(m.x) * sin(m.y), dist * cos(m.y));\n    return 6.0;\n}\n\n\n// Voxel Hit returns true if the voxel at pos should be filled.\nbool voxelHit(vec3 pos) {\n    vec4 buf = texture(iChannel0, (floor(pos.xy + 0.5 * iResolution.xy) + 0.5) / iResolution.xy);\n    bool ground = pos.z < floor(max(buf.x, -buf.x)) + 0.5;\n    float treeTop = floor(buf.y);\n    bool tree = pos.z > treeTop - floor((buf.y - treeTop) * 16.0) - 0.5 && pos.z < treeTop + 0.5 && hash1(pos + 0.1) < 0.5;\n    //bool tree = pos.z > treeTop - floor((buf.y - treeTop) * 16.0) - 0.5 && pos.z < treeTop + 0.5;\n    float trunkTop = floor(buf.z);\n    bool trunk = pos.z > trunkTop - floor((buf.z - trunkTop) * 16.0) - 0.5 && pos.z < trunkTop + 0.5;\n    return ground || tree || trunk;\n}\n\nvec3 leafColor(float id, vec2 hash) {\n    float x = id + 0.2 * hash.y - 0.1;\n    float x2 = x * x;\n    float red = 2.0 * x - x2 - 0.2;\n    float green = 0.3 + 0.5 * x - 0.8 * x2;\n    float blue = 0.0;\n    return clamp(vec3(red, green, blue), 0.0, 1.0) * (0.5 + 0.5 * hash.x);\n}\n\n// Voxel Color returns the color at pos with normal vector norm.\nvec3 voxelColor(vec3 pos, vec3 norm) {\n    vec3 p = floor(pos);\n    vec4 buf = texture(iChannel0, (floor(p.xy + 0.5 * iResolution.xy) + 0.5) / iResolution.xy);\n    vec2 h = hash2(p);\n    \n    vec3 water = mix(vec3(0.1, 0.4, 1.0), vec3(0.0, 0.2, 1.0), h.x);\n    vec3 foam = mix(vec3(1.0, 1.0, 1.0), vec3(0.5, 0.7, 1.0), h.x);\n    float depth = 2.0 * fract(buf.x);\n    depth = max(0.0, depth + (0.1 + 0.3 * hash1(p.xy)) * (p.z - floor(buf.x)));\n    water = mix(foam, water, depth);\n    \n    vec3 ground = mix(vec3(0.5, 0.3, 0.2), vec3(0.4, 0.2, 0.1), h.x);\n    vec3 rocks = mix(vec3(0.6), vec3(0.4), h.x);\n    ground = mix(ground, rocks, floor(2.0 * fract(-buf.x)));\n    \n    vec3 grass = mix(vec3(0.5, 0.9, 0.0), vec3(0.0, 0.5, 0.2), h.x);\n    ground = mix(ground, grass, floor(2.0 * fract(-2.0 * buf.x)) * step(floor(-buf.x) - 0.5, p.z));\n    vec3 color = mix(water, ground, step(buf.x, -0.5));\n    \n    vec3 tree = leafColor(fract(buf.w), h);\n    vec3 tree2 = leafColor((floor(buf.w - 1.0) + 0.5) / 16.0, h);\n    vec3 trunk = mix(vec3(0.2, 0.15, 0.1), vec3(0.1, 0.05, 0.0), h.x);\n    trunk = mix(trunk, tree2, step(1.0, buf.w));\n\n    float treeTop = floor(buf.y);\n    if (p.z < treeTop - floor((buf.y - treeTop) * 16.0) - 0.5 || p.z > treeTop + 0.5)\n        tree = trunk;\n    \n    color = mix(color, tree, step(floor(abs(buf.x)) + 0.5, p.z));\n    \n#ifdef REDUCED_COLOR_PALETTE\n    color = floor(4.0 * color + 0.5) / 4.0;\n#endif\n\n    return color;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Fill in the functions above.\n// The engine below does not need to be modified.\n////////////////////////////////////////////////////////////////////////////////\n\nfloat castRay(vec3 eye, vec3 ray, int maxIter, out float dist, out vec3 norm) {\n    vec3 pos = floor(eye);\n    vec3 ri = 1.0 / ray;\n    vec3 rs = sign(ray);\n    vec3 ris = ri * rs;\n    vec3 dis = (pos - eye + 0.5 + rs * 0.5) * ri;\n    \n    vec3 dim = vec3(0.0);\n    for (int i = 0; i < maxIter; ++i) {\n        if (pos.z < 0.0 || voxelHit(pos)) {\n            dist = dot(dis - ris, dim);\n            norm = -dim * rs;\n            return 1.0;\n        }\n    \n        dim = step(dis, dis.yzx);\n\t\tdim *= (1.0 - dim.zxy);\n        \n        dis += dim * ris;\n        pos += dim * rs;\n    }\n\n    if (ray.z < 0.0) {\n        dist = -eye.z / ray.z;\n        norm = vec3(0.0, 0.0, 1.0);\n        return 1.0;\n    }\n\treturn 0.0;\n}\n\nvec3 pass(vec2 coord, float time) {\n    vec3 eye, center;\n    float focalDist, blurAmount;\n    float zoom = setCamera(eye, center, focalDist, blurAmount);\n    \n    vec3 forward = normalize(center - eye);\n    vec3 right = normalize(cross(forward, vec3(0.0, 0.0, 1.0)));\n    vec3 up = cross(right, forward);\n\n    // Anti aliasing\n    vec2 hash = hash2(vec3(time, coord));\n    vec2 xy = (2.0 * (coord + hash - 0.5) - iResolution.xy) / iResolution.y;\n    \n    // Spherical aberration\n    xy /= cos(sphericalAberration * (1.0 + 0.3 * hash1(vec3(time, coord))) * length(xy));\n    \n    vec3 ray = normalize(xy.x * right + xy.y * up + zoom * forward);\n    \n    // Depth of field    \n    hash = hash2(vec3(time + 0.1, coord));\n    float a = sqrt(hash.x);\n    float b = a * cos(6.283185 * hash.y);\n    float c = a * sin(6.283185 * hash.y);\n\n    vec3 target = eye + ray * focalDist / dot(ray, forward);\n    eye += focalDist * blurAmount * (b * right + c * up);\n    ray = normalize(target - eye);\n    \n    // Cast Ray\n    float dist;\n    vec3 norm;\n    float hit = castRay(eye, ray, hitIter, dist, norm);\n    vec3 pos = eye + dist * ray;\n\n    vec3 color = voxelColor(pos - 0.001 * norm, norm);\n    \n    // Ambient occlusion\n    pos += 0.001 * norm;\n\n    vec3 z = norm;\n    vec3 x = normalize(cross(z, vec3(-0.36, -0.48, 0.8)));\n    vec3 y = normalize(cross(z, x));\n\n    hash = hash2(vec3(time + 0.2, coord));\n    a = sqrt(hash.x);\n    b = a * cos(6.283185 * hash.y);\n    c = a * sin(6.283185 * hash.y);\n    a = sqrt(1.0 - hash.x);\n    vec3 shadeDir = b * x + c * y + a * z;\n    float ambient = 1.0 - castRay(pos, shadeDir, shadeIter, dist, norm);\n    \n    // Sun\n    z = vec3(0.48, 0.36, 0.8);\n    x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n    y = normalize(cross(z, x));\n    \n    hash = hash2(vec3(time + 0.3, coord));\n    a = sqrt(hash.x);\n    b = a * cos(6.283185 * hash.y);\n    c = a * sin(6.283185 * hash.y);\n\n    z += 0.04 * (b * x + c * y);\n    float sun = 1.0 - castRay(pos, normalize(z), shadeIter, dist, norm);\n    \n    color *= 0.6 * ambient + 0.4 * sun;\n    return mix(backgroundColor, color, hit);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 frame = texture(iChannel0, vec2(0.5) / iResolution.xy);\n    \n    // Render pass\n\tvec3 color = pass(fragCoord, iTime);\n#if LIVE_ITER > 0\n    for (int i = 1; i < LIVE_ITER; ++i)\n        color += pass(fragCoord, iTime + float(i));\n    color /= float(LIVE_ITER);\n#endif\n    \n    // Vignetting\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    color *= vignetting * pow((1.0 - uv.x * uv.x) * (1.0 - uv.y * uv.y), 0.2) + 1.0 - vignetting;\n    \n#if LIVE_ITER == 0\n    // Accumulate color\n    vec3 oldColor = texture(iChannel1, fragCoord.xy / iResolution.xy).rgb;\n    fragColor = vec4(mix(oldColor, color, 1.0 / frame.z), 1.0);\n#else\n    fragColor = vec4(color, 1.0);\n#endif\n}\n","name":"Buffer B","description":"","type":"buffer"}]}