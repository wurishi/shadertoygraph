{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"float SDFSine( in vec2 coords )\n{\n    float v = sin(coords.x) - coords.y;\n    vec2  g = vec2(cos(coords.x), -1);\n    return abs(v)/length(g);\n}\n\nfloat SDFLine( in vec2 coords )\n{\n    float v = coords.x * 2.0 - coords.y;\n    vec2  g = vec2(2.0,-1.0);\n    return abs(v)/length(g);\n}\n\nfloat SDFQuadratic( in vec2 coords )\n{\n    float v = coords.x * coords.x - coords.y - 5.0;\n    vec2  g = vec2(2.0 * coords.x, -1.0);\n    return abs(v)/length(g);    \n}\n\nfloat SDFCubic( in vec2 coords )\n{\n    float v = coords.x * coords.x * coords.x - coords.y;\n    vec2  g = vec2(3.0 * coords.x * coords.x, -1.0);\n    return abs(v)/length(g);    \n}\n\n\nfloat SDFCircle( in vec2 coords )\n{\n    float v = coords.x * coords.x + coords.y * coords.y - 5.0;\n    vec2  g = vec2(2.0 * coords.x, 2.0 * coords.y);\n    return abs(v)/length(g); \n}\n\nvec2 OpRepeat(in vec2 p, in vec2 c)\n{\n\treturn mod(p,c)-0.5*c;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float aspectRatio = iResolution.x / iResolution.y;\n    \n    vec2 percent = ((fragCoord.xy / iResolution.xy) - vec2(0.5,0.5));\n    percent.x *= aspectRatio;\n    percent *= 16.0;\n    \n   \tfloat func = mod(iTime * 0.5, 7.0);\n    float col = 0.0;\n    \n    if (func > 6.0)\n    {\n        vec2 newPercent = OpRepeat(percent, vec2(4.75,4.75));\n        col = SDFCircle(newPercent);\n        \n        newPercent = OpRepeat(percent, vec2(5.0,5.0));\n        col = min(col, SDFCircle(newPercent));\n        \n        newPercent = OpRepeat(percent, vec2(5.25,5.25));\n        col = min(col, SDFCircle(newPercent));        \n\t}\n    else if (func > 4.0)\n    {\n        #if 0\n        col = SDFCircle(percent);\n        col *= SDFQuadratic(percent);\n        col *= SDFSine(percent);\n        col *= SDFLine(percent);\n        #else\n        col = SDFCircle(percent);\n\t\tcol = min(col, SDFCubic(percent));\n        col = min(col, SDFQuadratic(percent));\n        col = min(col, SDFSine(percent));\n        col = min(col, SDFLine(percent));\n        #endif\n    }\n    else if (func > 4.0)\n        col = SDFCircle(percent);\n    else if (func > 3.0)\n        col = SDFCubic(percent);        \n    else if (func > 2.0)\n        col = SDFQuadratic(percent);\n    else if (func > 1.0)\n    \tcol = SDFSine(percent);\n    else\n        col = SDFLine(percent);\n    \n    if (iMouse.z <= 0.0)\n        col = smoothstep(0.05,0.15,col);            \n       \n\tfragColor = vec4(col,col,col,1.0);\n}\n\n\n/*\n// gradiant function for finding G for a generic function when you can't\n// get it analytically using partial derivatives.\nvec2 Gradiant( in vec2 coords )\n{\n    vec2 h = vec2( 0.01, 0.0 );\n    return vec2( funct(coords+h.xy) - funct(coords-h.xy),\n                 funct(coords+h.yx) - funct(coords-h.yx) ) / (2.0*h.x);\n}\n*/","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdsXDX","date":"1407353005","viewed":1206,"name":"2D distance field rendering","username":"demofox","description":"Using IQ's distance estimation techniques to do some 2d rendering\nhttp://iquilezles.org/articles/distance/distance.htm\nhttp://iquilezles.org/articles/distfunctions/distfunctions.htm","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["2d","distancefield","vectorgraphics"],"hasliked":0,"parentid":"","parentname":""}}