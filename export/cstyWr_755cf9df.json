{"ver":"0.1","info":{"id":"cstyWr","date":"1694951154","viewed":67,"name":"coil","username":"Efim","description":"https://mathcurve.com/surfaces.gb/serpentin/serpentin.shtml","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","coil"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\nmat3 rotateX(float f) {\n    return mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, cos(f), -sin(f)), vec3(.0, sin(f), cos(f)));\n}\n\nmat3 rotateZ(float f) {\n    return mat3(vec3(cos(f), -sin(f), 0.0), vec3(sin(f), cos(f), 0.0), vec3(0.0, 0.0, 1.0));\n\n}\n\nmat3 rotateY(float f) {\n    return mat3(vec3(cos(f), 0.0, sin(f)), vec3(0.0, 1.0, 0.0), vec3(-sin(f), 0.0, cos(f)));\n}\n\nstruct HIT {\n    float dist;\n    vec3 nor;\n    vec3 pos;\n};\n\n#define TAU 6.28318530718\nfloat aafi(vec2 p) {\n    float fi = atan(p.y, p.x);\n    fi += step(p.y, 0.0)*TAU;\n    return fi;\n}\n\n//converts a vector on a sphere to longitude and latitude\nvec2 lonlat(vec3 p) {\n    float lon = aafi(p.xy) / TAU;\n    float lat = aafi(vec2(p.z, length(p.xy))) / PI;\n    return vec2(1.0 - lon, lat);\n}\n\nconst float dist_infin = 20.0;\nconst HIT hit_inf = HIT(dist_infin, vec3(0.0), vec3(0.0));\n#define nn 256\nconst float eps = 0.05;\nconst float kk = 0.9;\n#define nu 8.0\n\n/*\nvec3 calcSkyReflect(vec3 rd, vec3 nor, mat3 sky)\n{\n    vec3 n = nor;\n    float d = dot(rd, nor);\n    n = nor*sign(d);\n    vec3 r = reflect(rd, n);\n    vec2 fon = lonlat(sky*r); //get longitude and latitude\n    vec3 col = texture(iChannel0, fon).rgb;\n    return col;\n\n}\n*/\n\n\n\nvec3 culccolor(vec3 col_in, vec3 backcol, vec3 rd, vec3 light1, vec3 light2, vec3 nor) {\n    vec3 col = col_in;\n    float d = dot(rd, nor);\n    float pst = 1.0 - smoothstep(-0.05, -0.01, d);\n    col = mix(col, backcol, pst);\n    // if(d < -0.05)\n    //     col = backcol;\n\n    nor *= -sign(d);\n    float difu1 = dot(nor, light1);\n    float difu2 = dot(nor, light2);\n    float difu = max(difu1, difu2);\n    col *= clamp(difu, 0.5, 1.0);\n    return col;\n}\n\n\nvec4 near_dist(vec3 point, vec3 shell, out vec4 coo) {\n    float d = dist_infin;\n    vec3 nor = vec3(0.0);\n    float fi = aafi(point.xy);\n    float r = shell.x;\n    float r2 = shell.y;\n    float shift = (shell.z * TAU * nu + 2.0 * r2)/2.0;\n    \n    for(float i = 0.; i < nu; i++) {\n        float t = fi + TAU * i;\n        float z = shell.z * t - shift;\n        vec2 v1 = normalize(point.xy) * r;\n        vec3 nr = point - vec3(v1.x, v1.y, z);\n        float d2 = length(nr) - r2;\n        d2 = abs(d2);\n        if(d2 < d) {\n            d = d2;\n            nor = nr;\n            coo = vec4(r, r2, z, fi);\n        }\n    }\n\n    //if (point.x > 0.0 && point.y > 0.0)\n    {\n        float t = TAU * nu;\n        float z = shell.z * t - shift;\n        vec3 op = vec3(r, 0.0, z);\n        vec3 v1 = point - op;\n        vec2 v2 = normalize(v1.xz) * r2;\n        vec3 v3 = vec3(v2.x, 0.0, v2.y) + op;\n        vec3 nr = point - v3;\n        float d2 = length(nr);\n        if(d2 < d) {\n            d = d2;\n            nor = nr;\n        }\n    }\n\n    {\n        float z = -shift;\n        vec3 op = vec3(r, 0.0, z);\n        vec3 v1 = point - op;\n        vec2 v2 = normalize(v1.xz) * r2;\n        vec3 v3 = vec3(v2.x, 0.0, v2.y) + op;\n        vec3 nr = point - v3;\n        float d2 = length(nr);\n        if(d2 < d) {\n            d = d2;\n            nor = nr;\n        }\n    }\n\n    return vec4(nor, d*kk);\n\n}\n\n\nHIT giper3D(vec3 ro, vec3 rd, vec3 shell, out vec4 coo) {\n    float t = 0.;\n    float f = 0.;\n    float sn = 0.;\n    \n    for(int i = 0; i < nn; i++) {\n        vec3 pos = ro + rd * t;\n        vec4 d = near_dist(pos, shell, coo);\n        if(d[3] < eps) {\n            vec3 nor = normalize(d.xyz);\n            return HIT(d[3], nor, pos);\n        }\n        \n\n        t+=d[3];\n        if(t >= dist_infin)\n            return hit_inf;\n    }\n\n    return hit_inf;\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l - p), r = normalize(cross(vec3(0, 1, 0), f)), u = cross(f, r), c = f * z, i = c + uv.x * r + uv.y * u;\n    return normalize(i);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //surface (x+y+z-a)(xy+yz+zx) - kxyz = 0\n    vec3 light = normalize(vec3(0.0, 0.0, -1.0)); //light\n    vec3 light2 = normalize(vec3(0.0, 0.0, 1.0)); //light\n\n    float t =  iTime/2.0;\n    vec2 m = vec2(0.0, 0.0);\n    if  (iMouse.z > 0.0)\n    {\n        m = (-iResolution.xy + 2.0 * (iMouse.xy)) / iResolution.y;\n        t = 0.;\n    }\n    vec3 ro = vec3(0.0, 0.0, 10.5); // camera\n    ro = rotateY(-m.x * TAU) * rotateX(-m.y * PI) * ro; //camera rotation\n\n    const float fl = 1.5; // focal length\n    float dist = dist_infin;\n    \n\n    // mat3 rota = rotateZ(t)*rotateX(PI/4.0)*rotateY(PI); \n    // mat3 rota_1 = rotateY(-PI)*rotateX(-PI/4.0)*rotateZ(-t);\n    mat3 rota = rotateX(t)*rotateY(t); \n    mat3 rota_1 = rotateY(-t)*rotateX(-t);\n    \n    //mat3 sky = rotateZ(0.0)*rotateX(PI/2.0);\n\n    vec3 shell = vec3(2.0, 0.4, 1.1/TAU);\n    //vec3 shift = getShift(shell);\n    //vec3 shift = vec3(0.0);\n    vec3 col = vec3(0.7, 0.7, 0.9); // background        \n\n    vec3 tot = vec3(0.0);\n\n    #define AA 2\n    //antiblick\n    for(int m = 0; m < AA; m++) for(int n = 0; n < AA; n++) {\n            vec3 col = vec3(0.7, 0.7, 0.9); // background        \n            // pixel coordinates\n            vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n            vec2 p = (-iResolution.xy + 2.0 * (fragCoord + o)) / iResolution.y;\n            //vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n            //vec3 rd = normalize( vec3(p,fl) ); // ray direction\n            vec3 rd = GetRayDir(p, ro, vec3(0, 0., 0), fl); //ray direction\n            vec3 backcol = vec3(1.0, 0.5, 0.5);\n            vec4 coo = vec4(0.0);\n            HIT giper = giper3D(rota * (ro), rota * rd, shell, coo);\n            if(giper.dist < dist) {\n                float x = coo[3] /TAU;\n                x = fract(x);\n                float y = aafi(vec2(coo[0] - length(giper.pos.xy), giper.pos.z-coo[2])) /TAU;\n                col = texture(iChannel0, vec2(x,y)).rgb;\n                backcol = texture(iChannel1, vec2(x,y)).rgb;\n                //col = vec3(0.5, 0.5, 1.0);\n                vec3 nor = rota_1 * giper.nor;\n                col = culccolor(col, backcol, -rd, light, light2, nor);\n                //col = pow(col, vec3(0.4545));\n            }\n            tot += col;\n        }\n    //antiblick\n    tot /= float(AA * AA);\n    \n    fragColor = vec4(tot, 1.0);\n\n}\n","name":"Image","description":"","type":"image"}]}