{"ver":"0.1","info":{"id":"DlGXRw","date":"1685986745","viewed":98,"name":"Fractals, sweet fractals X","username":"TastelessPledge","description":"My first real shader\n\nModified from: https://www.youtube.com/watch?v=f4s1h2YETNY","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractal","fractals","trippy","geometry","geometric","trip","visuals"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Fractals, sweet fractals\" by TastelessPledge. https://shadertoy.com/view/mlVSzD\n// 2023-06-05 16:59:48\n\n// Fork of \"Basic shader helper functions\" by TastelessPledge. https://shadertoy.com/view/DtGXR1\n// 2023-06-05 16:26:50\n\n#define PI     3.14159\n\n// Shapes\n// Basic: https://iquilezles.org/articles/distfunctions2d/\n// Cut-up: https://iquilezles.org/articles/distgradfunctions2d/\n// Gradient: https://iquilezles.org/articles/distgradfunctions2d/\n\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    // Test values: http://dev.thi.ng/gradients/\n    // Each value = vec3(red, green, blue)\n    \n    // a: y-Offset\n    // b: Amp\n    // c: Frequency\n    // d: x-Offset (phase)\n    \n    // Oscilates c times with phase of d\n    // Scaled and biased by a and b for ccontrast and brightness\n    // If palette needs to cycle over 0..1 exactly make c = [int] * 0.5\n    // For continuity make c = [int]\n    return a + b*cos( 2.0*PI *(c*t+d) );\n}\n\nvec3 usePalette(float t) {\n    // Test values: http://dev.thi.ng/gradients/\n    vec3 a = vec3(0.5, 0.5, 2.0);\n    vec3 b = vec3(0.5, 0.2, 0.5);\n    vec3 c = vec3(2.0, 3.0, 1.0);\n    vec3 d = vec3(1.358, 0.5, 0.5);\n    \n    return palette(t, a, b, c, d);\n}\n\nfloat halfScreenValuePicker(float x, float leftVal, float rightVal) {\n    if (x < iResolution.x / 2.0) {\n        return leftVal;\n    }\n    return rightVal;\n}\n\n// Range canvas from -0.5 to 0.5\nvec2 centeredNormCanvas(vec2 fragCoord) {\n    return (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n}\n\nvec2 addSpatialRepetion(vec2 uv, float scale) {\n    return fract(uv * scale) - 0.5;\n}\n\n// pointOriginal: value of point when initilized\nfloat pointDistanceCurved(vec2 point, vec2 pointOriginal) {\n    return length(point) * exp(-length(pointOriginal));\n}\n\nfloat sinRings(float d, float t, float speed, float width) {\n    return sin(d*speed + t)/width;\n}\n\nfloat glow(float d, float intensity, float contrast) {\n    return pow(intensity / d, contrast);\n}\n\nvec3 scaleColorWithDistance(vec3 col, float d) {\n    return col * d;\n}\n\nvec3 invert(vec3 v) {\n    return vec3(1.0) - v;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat sdHeart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nfloat sdRoundedX( in vec2 p, in float w, in float r )\n{\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Range canvas from -0.5 to 0.5\n    vec2 uv = centeredNormCanvas(fragCoord);\n    // Original uv\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    // Iterate to create layers\n    // Increase limit to add more layers\n    for (float i = 0.0; i < 3.0; i++) {\n        // Add spatial repetion\n        // Non-int scalar for patterns\n        // -0.5 lines fract up with middle\n        //uv = addSpatialRepetion(uv, 1.4);\n        \n        const float timeInterval = 40.;\n        float timeTracker = iTime;\n        timeTracker = mod(timeTracker, timeInterval);\n        if (timeTracker < timeInterval / 2.) {\n            uv = addSpatialRepetion(uv, 1.4 + timeTracker * 0.01);\n        }\n        else {\n            uv = addSpatialRepetion(uv, 1.4 + (timeInterval - timeTracker) * 0.01);\n        }\n        \n        // Make X shape\n        float wi = 0.001 + 0.3*cos( iTime + 1.0 );\n        float ra = 0.01 + 0.08*sin(iTime*1.2);\n        // !!! Plus i really make it cool !!!\n        float d = sdRoundedX(uv, wi + i * 2., ra - i*2.);\n        \n        // Changes with each iteration\n        vec3 col = usePalette(length(uv0) + i*1.5 + iTime*0.2);\n        \n        // Repeating rings in different phases with scalable with\n        d = sinRings(d, iTime*0.2, 8., 5.);\n        \n        // Change brightness\n        col += vec3(0.5);\n        \n        // Inside also gives positive \n        d = abs(d);\n        \n        // Glow intensity, second: contrast\n        //d = glow(d, 0.01, 1.0);\n        d = glow(d, 0.013, 1.2);\n        \n        // Glow changes with distance\n        finalColor += scaleColorWithDistance(col, d);\n    }\n\n    // Output to screen\n    fragColor = vec4(finalColor,1.0);\n}","name":"Image","description":"","type":"image"}]}