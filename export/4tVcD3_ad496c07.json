{"ver":"0.1","info":{"id":"4tVcD3","date":"1537980384","viewed":916,"name":"Signed Distance to Polyspline","username":"nr4","description":"Filled true type glyphs. Suggestions for optimization welcome :)\nLinear version: https://www.shadertoy.com/view/MtGyW3\n","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","bezier","spline","polygon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Signed Distance to Polyspline\n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n// Update 1: Got rid of the if(.) by using step functions\n// Update 2: Removed degenerate case (it is invisible).\n\n// (Un)Comment this for different look\n#define DRAW_GEOMETRY\n// More Segments = cooler; choose min. 2\n#define N 32\n\n// Global constants\nconst vec3 c = vec3(1.,0.,-1.);\nconst float pi = acos(-1.);\n\n// Hash function\nfloat rand(vec2 a0)\n{\n    return fract(sin(dot(a0.xy, vec2(12.9898,78.233)))*43758.5453);\n}\n\n// Distance to line segment\nfloat lineseg(vec2 x, vec2 p1, vec2 p2)\n{\n    vec2 d = p2-p1;\n    return length(x-mix(p1, p2, clamp(dot(x-p1, d)/dot(d,d),0.,1.)));\n}\n\n// Distance to stroke for any object\nfloat stroke(float d, float w)\n{\n    return abs(d)-w;\n}\n\n// Standard shadertoy fill color\nvec3 col(vec2 uv, float o)\n{\n    return 0.5 + 0.5*cos(o+uv.xyx+vec3(0,2,4));\n}\n\n//distance to quadratic bezier spline with parameter t\nfloat dist(vec2 p0,vec2 p1,vec2 p2,vec2 x,float t)\n{\n    t = clamp(t, 0., 1.);\n    return length(x-pow(1.-t,2.)*p0-2.*(1.-t)*t*p1-t*t*p2);\n}\n\n//minimum distance to quadratic bezier spline\nfloat spline2(vec2 p0, vec2 p1, vec2 p2, vec2 x)\n{\n    //coefficients for 0 = t^3 + a * t^2 + b * t + c\n    vec2 E = x-p0, F = p2-2.*p1+p0, G = p1-p0;\n    vec3 ai = vec3(3.*dot(G,F), 2.*dot(G,G)-dot(E,F), -dot(E,G))/dot(F,F);\n\n\t//discriminant and helpers\n    float tau = ai.x/3., p = ai.y-tau*ai.x, q = - tau*(tau*tau+p)+ai.z, dis = q*q/4.+p*p*p/27.;\n    \n    //triple real root\n    if(dis > 0.) \n    {\n        vec2 ki = -.5*q*c.xx+sqrt(dis)*c.xz, ui = sign(ki)*pow(abs(ki), c.xx/3.);\n        return dist(p0,p1,p2,x,ui.x+ui.y-tau);\n    }\n    \n    //three distinct real roots\n    float fac = sqrt(-4./3.*p), arg = acos(-.5*q*sqrt(-27./p/p/p))/3.;\n    vec3 t = c.zxz*fac*cos(arg*c.xxx+c*pi/3.)-tau;\n    return min(\n        dist(p0,p1,p2,x, t.x),\n        min(\n            dist(p0,p1,p2,x,t.y),\n            dist(p0,p1,p2,x,t.z)\n        )\n    );\n}\n\n// Distance to specific polygon\nfloat polygon(vec2 x)\n{\n    vec2 pts[2*N];\n\tfloat ret = 1., n = 0.;\n    \n    for(float i=0.; i<float(2*N); i+=1.)\n    \tpts[int(i)] = -.5*c.xx+vec2(1.5*rand(i*c.xx)+.25*cos(rand(3.*i*c.xx)*iTime), rand(2.*i*c.xx)+.25*sin(rand(3.*i*c.xx)*iTime));\n    \n    for(int i=0; i<N/2; ++i)\n    {\n        vec2 p0 = pts[2*i], p1 = pts[2*i+1], p2 = pts[int(mod(float(2*i+2),float(N)))];\n        \n        // Compute coefficients for quadratic equation\n        float a = p2.y-2.*p1.y+p0.y, b = 2.*p1.y-2.*p0.y, C = p0.y-x.y;\n        \n        // Discriminant\n        float dis = b*b-4.*a*C;\n        \n        // Solution\n        if(dis == 0.)\n        {\n            float t = -b/2./a, \n                alpha = pow(1.-t,2.)*p0.x+2.*(1.-t)*t*p1.x+t*t*p2.x-x.x;\n            n += step(0., t)*step(t, 1.)*step(0., alpha);\n        }\n        else if(dis > 0.)\n        {\n            vec2 t = (-b*c.xx+c.xz*sqrt(dis))/2./a,\n                alpha = (c.xx-t)*(c.xx-t)*p0.x+2.*(c.xx-t)*t*p1.x+t*t*p2.x-x.x;\n            t = step(c.yy, t)*step(t, c.xx)*step(c.yy, alpha);\n            n += t.x+t.y;\n        }\n        \n        ret = min(ret, spline2(p0, p1, p2, x));\n    }\n    \n    return mix(ret, -ret, mod(n, 2.));\n}\n\n// Add objects to scene with proper antialiasing\nvec4 add(vec4 sdf, vec4 sda)\n{\n    return vec4(\n        min(sdf.x, sda.x), \n        mix(sda.gba, sdf.gba, smoothstep(-1.5/iResolution.y, 1.5/iResolution.y, sda.x))\n    );\n}\n\n// Add the polygon to a scene\nvec4 scene(vec2 x)\n{\n    vec4 sdf = vec4(polygon(x), col(x, 3.+iTime));\n    sdf = add(sdf, vec4(stroke(sdf.x, .003), col(x, 5.+iTime)));\n    return sdf;\n}\n\n// Draw everything\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.yy-.5;\n    vec4 s = scene(uv);\n\tvec3 col = \n#ifdef DRAW_GEOMETRY\n        mix(s.gba,\n#endif\n            mix(col(uv, iTime), col(uv, 1.+iTime), .5+.5*sign(s.x))\n            *smoothstep(1.5/iResolution.y, -1.5/iResolution.y, .001*sin(2.*pi*50.*s.x))\n#ifdef DRAW_GEOMETRY\n            , \n            smoothstep(-1.5/iResolution.y, 1.5/iResolution.y, s.x)\n           )\n#endif\n    \t;\n\tfragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}