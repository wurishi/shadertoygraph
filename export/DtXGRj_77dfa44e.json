{"ver":"0.1","info":{"id":"DtXGRj","date":"1672075041","viewed":143,"name":"Ray Marching v2","username":"thom_bahm","description":"Added Some displacement in 1d (left sphere); trying to do something with 3d rotation matrix (right), SLOW & weird. Not sure how to make sure the shape doesn't become very noisy in areas. Should obviously be done w/ noise instead of this.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"Dd2SD3","parentname":"Ray Marching v1"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SLOW\n\nconst int MAX_MARCHING_STEPS = 225;\nconst float MIN_DIST = 0.01;\nconst float MAX_DIST = 200.0;\nconst float EPSILON = 0.0001;\n\nvec2 uv;\n\nstruct sphere {\n    vec3 pos; //position in 3d space\n    vec3 col;\n    float r; //radius\n    float m; //mass (kg)\n};\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\n\nmat3 rotate3d(float x, float y, float z){\n    mat3 rotX = mat3(cos(x), -sin(x), 0,\n                     sin(x), cos(x), 0,\n                     0,         0,           1);\n    mat3 rotY = mat3(cos(y), 0, sin(y),\n                     0,          1,          0,\n                     -sin(y), 0, cos(y));\n    mat3 rotZ = mat3(1,          0,          0,\n                     0, cos(z), -sin(z),\n                     0, sin(z), cos(z));\n    return rotX*rotY*rotZ;\n    //return rotX*rotZ; //faster\n}\n//positions stored in sph.xyz, radius stored in sph.w\n// SDF = sqrt(P^2-C^2)-r^2\n// where P is the point to check, C = center of sphere\nfloat sphereSDF(vec3 samplePoint, sphere sph) {\n    return length(samplePoint-sph.pos) - sph.r;\n}\n\nfloat planeSDF(vec3 p) {\n    return p.y;\n}\n\nfloat sceneSDF(vec3 p) {\n    sphere sph; sph.pos = vec3(1.5, 1.0, -10.0); sph.r = 1.0; sph.col = vec3(0.1,0.5,0.8);\n    sphere sph1; sph1.pos = vec3(-1.5, 1.0, -10.0); sph1.r = 1.0;\n    // 1D displacement\n    float dfx = sin(p.x*5.0)*sin(iTime);\n    float dfy = cos(p.y*5.0)*cos(iTime);\n    float dfz = sin(p.z*5.0)*sin(iTime);\n    float disp1 =  dfx * dfy * dfz * 0.3;\n    \n    //3d rotation displacement\n    // Modulating time based on the location of the point on the sphere\n    float time = mod((iTime+1.)*1.2, p.x-p.y-p.z);\n    float dispMult = 0.015; //keep values < 0.05\n    \n    vec3 disp = vec3(dispMult)*rotate3d(p.x*time, p.y*time, p.z*time);\n    return min(planeSDF(p), min(sphereSDF(p+disp, sph), sphereSDF(p+disp1, sph1)));\n}\n\nvec3 estimateNormal(vec3 p) {\n    //using gradient of sdf by sampling points on the sphere and comparing their difference\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n//Shortest distance to surface\nfloat rayMarch(vec3 eye, vec3 marchingDirection) {\n    float depth = MIN_DIST;    \n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        //depth is the position of the current marching step\n        vec3 pos = eye + depth * marchingDirection; //pos(depth)=origin+(depth*dir)\n        //find the distance from the current point along the marching ray to the scene\n        float dist = sceneSDF(pos);\n        //increment the depth (location along marching ray) until it has passed the MAX_DIST (end of scene)\n        depth += dist;\n        if (depth > MAX_DIST || depth < EPSILON) { break; }\n    }\n    return depth;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fov = 45.0;\n    //create ray direction\n    uv = fragCoord - iResolution.xy / 2.0;\n    float z = iResolution.y / tan(radians(fov)/2.0);\n    //eye represents the ray's origin\n    vec3 eye = vec3(0.0, 1.0, -1.0);\n    vec3 dir = normalize(vec3(uv, -z));\n    \n    float dist = rayMarch(eye, dir); //find distance to scene\n    vec3 col = vec3(0.0);\n    vec3 lightPos = vec3(-4, 3, -1.0);\n    //lightPos = vec3(-10, 10, -1.0);\n\n    //lighting calculations\n    vec3 p_t = eye + dir*dist; //point along ray being marched\n    vec3 light = normalize(lightPos - p_t); //normalize lightPos-pos on scene.\n    vec3 normal = estimateNormal(p_t); //normal of (sphere)\n    float dif = dot(normal, light); //lighting more intense when normal pointing at light\n    //following code (sort of)from [TUT] RayMarching for Dummies!: https://www.shadertoy.com/view/XlGBW3\n    //shadows: raymarch from a point towards the light source.\n    float pointToSun = rayMarch(p_t, light);\n    //one way of doing it (basically if the ray shot from\n    //the point towards sun never intersects a surface, make the point dark)\n    //if (pointToSun < MAX_DIST) dif = 0.;\n    // other way: if the ray from point to sun get's intersected by the sphere\n    if (pointToSun<length(lightPos-p_t)) dif *= 0.1;\n    col = vec3(dif);\n    // gamma correction: (BigWIngs TUT)\n    col = pow(col, vec3(.4545));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}