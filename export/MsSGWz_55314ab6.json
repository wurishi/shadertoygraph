{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"struct ray\n{\n\tvec3 p;\n\tvec3 d;\n\tvec3 light;\n\tvec3 transmit;\n};\n\nstruct sphere\n{\n\tvec3 p;\n\tfloat r;\n};\n\nfloat raySphereDet(ray r, sphere s, inout float b)\n{\n\tvec3 rc = r.p-s.p;\n\tfloat c = dot(rc, rc);\n\tc -= s.r*s.r;\n\tb = dot(r.d, rc);\n\treturn b*b - c;\n}\n\nfloat rayIntersectsSphere(ray r, sphere s, inout vec3 nml, float closestHit)\n{\n\tfloat b;\n\tfloat d = raySphereDet(r, s, b);\n\tif (d < 0.0) {\n\t\treturn closestHit;\n\t}\n\tfloat t = -b - sqrt(d);\n\tfloat nd = sign(t);\n\tif (t < 0.0) {\n\t\tt += 2.0*sqrt(d);\n\t}\n\tif (t < 0.0 || t > closestHit) {\n\t\treturn closestHit;\n\t}\n\tnml = nd * normalize(s.p - (r.p + r.d*t));\n\treturn t;\n}\n\n\nvec3 shadeBg(vec3 nml)\n{\n    vec3 lightPos_ = vec3(\n        -cos(iTime)*-12.0, \n        3.5+sin(iTime*2.05)*8.0, \n        (sin(iTime)*12.0-5.4)\n    );\n    vec3 bgLight = normalize(lightPos_);\n    vec3 lightPos = bgLight * 9999.0;\n    vec3 sun = vec3(5.0, 4.0, 2.0);\n\tvec3 bgCol = vec3(0.2, 0.15, 0.1);\n\tfloat bgDiff = dot(nml, vec3(0.0, 1.0, 0.0));\n\tfloat sunPow = dot(nml, bgLight);\n\tbgCol += 0.1*sun*pow( max(sunPow, 0.0), 2.0);\n\tbgCol += 2.0*bgCol*pow( max(-sunPow, 0.0), 2.0);\n\tbgCol += max(-0.5, bgDiff)*vec3(0.25, 0.5, 0.5);\n\tbgCol += sun*pow( max(sunPow, 0.0), 256.0); //16.0+abs(bgLight.y)*256.0);\n\tbgCol += bgCol*pow( max(sunPow, 0.0), 128.0+abs(bgLight.y)*128.0);\n\treturn max(vec3(0.0), bgCol);\n}\n\nmat3 rotationXY( vec2 angle ) {\n\tfloat cp = cos( angle.x );\n\tfloat sp = sin( angle.x );\n\tfloat cy = cos( angle.y );\n\tfloat sy = sin( angle.y );\n\n\treturn mat3(\n\t\tcy     , 0.0, -sy,\n\t\tsy * sp,  cp,  cy * sp,\n\t\tsy * cp, -sp,  cy * cp\n\t);\n}\n\nbool getBit(float n, float i)\n{\n\treturn (mod(n / pow(2.0, i), 2.0) < 1.0);\n}\n\nfloat scene(inout ray r, inout vec3 nml) {\n\tfloat dist;\n\tsphere s;\n\n\t// Test a bunch of spheres for ray-sphere intersection.\n\tdist = 10000.0;\n\ts.p = vec3(0.0);\n\ts.r = 0.95;\n\tdist = rayIntersectsSphere(r, s, nml, dist);\n\ts.p = vec3(1.0, 1.0, -1.0);\n\ts.r = 0.35;\n\tdist = rayIntersectsSphere(r, s, nml, dist);\n\ts.p = vec3(1.0, -1.0, 1.0);\n\tdist = rayIntersectsSphere(r, s, nml, dist);\n\ts.p = vec3(-1.0, -1.0, -1.0);\n\tdist = rayIntersectsSphere(r, s, nml, dist);\n\ts.p = vec3(-1.0, 1.0, 1.0);\n\tdist = rayIntersectsSphere(r, s, nml, dist);\n\treturn dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\tvec2 uv = (1.0 - 2.0 * (fragCoord.xy / iResolution.xy)) * aspect;\n\n\tmat3 rot = rotationXY( vec2( iTime, iTime*0.32 ) );\n\n\tray r;\n\tr.p = vec3(uv*0.2, -3.0);\n\tr.d = normalize(vec3(uv, 1.0));\n\tr.d *= rot;\n\tr.p *= rot;\n\tr.transmit = vec3(1.0);\n\tr.light = vec3(0.0);\n\n\tfloat epsilon = 0.015;\n\tfloat rayCount=0.0, rayBounceCount=0.0;\n\tbool rayComplete = false;\n\n\t// Max number of paths shot out of camera.\n\t// Double to add a recursion level.\n\tfloat maxRays = 16.0;\n\tfloat maxBounceCount = 5.0;\n\t\n\t// Evaluate a bunch of ray segments.\n\t// Bump maxRays to 64.0, maxBounceCount to 7.0 and the ray segments to 64*7 \n\t// for some more flares.\n\tfor (int i=0; i<16*4; i++) {\n\t\t\n\t\tvec3 nml;\n\t\tfloat dist = scene(r, nml);\n\t\t\n\t\tif (dist != 10000.0) {\n\t\t\t// Move ray to surface.\n\t\t\tr.p += r.d*dist;\n\t\t\t\n\t\t\t// Fresnel term, increase reflectivity on surfaces parallel to ray.\n\t\t\tfloat f = pow(1.0 - clamp(0.0, 1.0, dot(nml, r.d)), 5.0);\n\t\t\t\n\t\t\t// Whether to reflect or refract on this step.\n\t\t\t// The idea is to generate all permutations of a reflect/refract\n\t\t\t// path by using an N-bit number where each bit determines whether\n\t\t\t// the bounce at this step reflects or refracts.\n\t\t\t//\n\t\t\t// (rayCount >> rayBounceCount) & 1\n\t\t\tif (!getBit(rayCount, rayBounceCount)) {\n\t\t\t\tr.d = reflect(r.d, nml);\n\t\t\t\t// Fade the ray by the surface's absorption.\n\t\t\t\t// Use the Fresnel term to boost reflection strength.\n\t\t\t\tr.transmit *= (1.0+f)*vec3(0.95);\n\t\t\t} else {\n\t\t\t\t// Simulate air -> something refraction.\n\t\t\t\tfloat eta = 1.000239 / 1.15; \n\t\t\t\tr.d = refract(r.d, -nml, eta);\n\t\t\t\t// Fade the ray by the volume's transmission.\n\t\t\t\t// Use the Fresnel term to reduce transmission.\n\t\t\t\tr.transmit *= (1.0-f)*vec3(1.0);\n\t\t\t}\n\t\t\t\n\t\t\trayBounceCount++;\n\t\t\tif (rayBounceCount > maxBounceCount) {\n\t\t\t\trayComplete = true;\n\t\t\t}\n\t\t\t\n\t\t\t// Offset ray to avoid double-colliding with same surface.\n\t\t\tr.p += r.d*epsilon;\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\t// Add background light to the ray.\n\t\t\tr.light += r.transmit * shadeBg(-r.d);\n\t\t\trayComplete = true;\n\t\t\t\n\t\t}\n\t\t\n\t\tif (rayComplete) {\n\t\t\t\n\t\t\trayComplete = false;\n\t\t\trayCount++;\n\t\t\t\n\t\t\t// If the ray didn't hit anything or\n\t\t\t// if we've done enough rays, quit.\n\t\t\tif (rayBounceCount == 0.0 || rayCount == maxRays) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t// Reset bounce count.\n\t\t\trayBounceCount = 0.0;\n\t\t\t\n\t\t\t// Reset ray back to camera.\n\t\t\tr.p = vec3(uv*0.2, -3.0);\n\t\t\tr.d = normalize(vec3(uv, 1.0));\n\t\t\tr.d *= rot;\n\t\t\tr.p *= rot;\n\t\t\t\n\t\t\t// Make ray transparent again.\n\t\t\tr.transmit = vec3(1.0);\n\t\t}\n\t}\n\t\n\t// Gamma curve the average ray light.\n\tfragColor = vec4(1.0 - exp(-r.light/rayCount * 2.5), 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsSGWz","date":"1385955673","viewed":913,"name":"Refractive Spheres","username":"kig","description":"Playing with tree recursion","likes":29,"published":1,"flags":0,"usePreview":0,"tags":["refraction","raytrace"],"hasliked":0,"parentid":"","parentname":""}}