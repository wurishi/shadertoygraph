{"ver":"0.1","info":{"id":"fl3fzj","date":"1663320445","viewed":83,"name":"RayMarching and SDF Learning","username":"Brandy2022","description":"参照官方案例 https://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#signed-distance-functions，学习RayMarching和SDF","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float EPSILON = 0.0001;\nfloat MIN_DIST = 0.0;\nfloat MAX_DIST = 100.0;\nint MAX_MARCHING_STEPS = 255;\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nmat4 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, c, -s, 0),\n        vec4(0, s, c, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nmat4 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, -s, 0, 0),\n        vec4(s, c, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nfloat unionSDF(float distA, float distB)\n{\n    return min(distA,distB);\n}\n\nfloat intersectSDF(float distA, float distB)\n{\n    return max(distA,distB);\n}\n\nfloat differenceSDF(float distA, float distB)\n{\n    return max(distA, -distB);\n}\n\nfloat sphereSDF(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat boxSDF(vec3 p, float size)\n{\n    vec3 d=abs(p)-size/2.0;\n    float insideDist=min(max(d.x,max(d.y,d.z)),0.0);\n    float outsideDist=length(max(d,0.0));\n    return insideDist+outsideDist;\n}\n\nfloat cylinderSDF(vec3 p , float h, float r)\n{\n    float inRadius=length(p.xz)-r;\n    float inHeight=abs(p.y)-h/2.0;\n    float inDis=min(max(inRadius, inHeight),0.0);\n    float outDis=length(max(vec2(inRadius, inHeight),0.0));\n    return inDis+outDis;\n}\n\nfloat sceneSDF(vec3 p)\n{\n    p = (rotateY(iTime/2.0) * vec4(p, 1.0)).xyz;\n\n    float cylinderH=2.0;\n    float cylinderR=0.4 + (1.0 - 0.4) * (1.0 + sin(1.7 * iTime)) / 2.0;\n    \n    vec3 cylinder2Pos = (rotateX(radians(90.0)) * vec4(p,1.0)).xyz;\n    vec3 cylinder3Pos = (rotateZ(radians(90.0)) * vec4(p,1.0)).xyz;\n    \n    float cylinder1 = cylinderSDF(p,cylinderH,cylinderR);\n    float cylinder2 = cylinderSDF(cylinder2Pos,cylinderH,cylinderR);\n    float cylinder3 = cylinderSDF(cylinder3Pos,cylinderH,cylinderR);\n    \n    float ballOffset = 0.4 + 1.0 + sin(1.7 * iTime);\n    float ballRadius = 0.3;\n    float balls = sphereSDF(p - vec3(ballOffset, 0.0, 0.0), ballRadius);\n    balls = unionSDF(balls, sphereSDF(p + vec3(ballOffset, 0.0, 0.0), ballRadius));\n    balls = unionSDF(balls, sphereSDF(p - vec3(0.0, ballOffset, 0.0), ballRadius));\n    balls = unionSDF(balls, sphereSDF(p + vec3(0.0, ballOffset, 0.0), ballRadius));\n    balls = unionSDF(balls, sphereSDF(p - vec3(0.0, 0.0, ballOffset), ballRadius));\n    balls = unionSDF(balls, sphereSDF(p + vec3(0.0, 0.0, ballOffset), ballRadius));\n    \n    float csgNut = differenceSDF(intersectSDF(sphereSDF(p, 1.2),boxSDF(p,1.8)),\n                         unionSDF(cylinder1, unionSDF(cylinder2, cylinder3)));\n                         \n    return unionSDF(balls, csgNut);\n    //return differenceSDF(sphereSDF(p, 1.2), cylinderUnion);\n    //return boxSDF(p,1.0);\n    //return cylinderSDF(p,1.0,0.5);\n}\n\nvec3 rayDirection(float fov, vec3 eye, vec2 size, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fov/2.0));\n    return normalize(vec3(xy,-z));\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 dir, float start, float end)\n{\n    float depth = start;\n    for(int i=0; i<MAX_MARCHING_STEPS;i++)\n    {\n        float dist = sceneSDF(eye + dir * depth);\n        if(dist<EPSILON)\n        {\n            return depth;\n        }\n        depth+=dist;\n        if(depth>=end)\n        {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 estimateNormal(vec3 p)\n{\n    return normalize(vec3(\n        sceneSDF(vec3(p.x+EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x-EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y+EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y-EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z+EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z-EPSILON))\n    ));\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, vec3 lightPos, vec3 LightIntensity)\n{\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos-p);\n    vec3 V = normalize(eye-p);\n    vec3 R = normalize(reflect(-L,N));\n    \n    float dotLN = dot(L,N);\n    float dotRV = dot(R,V);\n    \n    if(dotLN < 0.0)\n    {\n        return vec3(0.0,0.0,0.0);\n    }\n    if(dotRV < 0.0)\n    {\n        return LightIntensity * (k_d * dotLN);\n    }\n    return LightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye)\n{\n    vec3 ambient = 0.5 * vec3 (1.0, 0.0, 0.0);\n    vec3 color = ambient * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n     vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye, light1Pos, light1Intensity);\n    color += phongContribForLight(k_d, k_s, alpha, p, eye, light2Pos, light2Intensity);\n    return color;\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up)\n{\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(up, eye));\n    vec3 u = cross(s, f);\n    return mat4(vec4(s,0.0), vec4(u,0.0),vec4(-f,0.0),vec4(0.0,0.0,0.0,1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3(3.0, 5.0, 7.0);\n    vec3 dir=rayDirection(45.0,eye,iResolution.xy, fragCoord);\n    mat4 viewToWorld = viewMatrix(eye,vec3(0.0,0.0,0.0),vec3(0.0,1.0,0.0));\n    vec3 worldDir=(viewToWorld * vec4(dir,0.0)).xyz;\n    \n    float dist=shortestDistanceToSurface(eye, worldDir,MIN_DIST,MAX_DIST);\n    if(dist>MAX_DIST-EPSILON)\n    {\n        fragColor=vec4(0.0);\n        return;\n    }\n    \n    vec3 k_a = vec3(1.0,1.0,1.0);\n    vec3 k_d = vec3(1.0,0.0,0.0);\n    vec3 k_s = vec3(0.0,1.0,0.0);\n    float alpha=10.0;\n    vec3 p=eye+worldDir*dist;\n    vec3 color = phongIllumination(k_a, k_d, k_s, alpha, p, eye);\n    fragColor=vec4(color,1.0);\n}\n\n\n\n\n","name":"Image","description":"","type":"image"}]}