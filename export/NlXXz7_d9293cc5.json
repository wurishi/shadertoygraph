{"ver":"0.1","info":{"id":"NlXXz7","date":"1625327743","viewed":34,"name":"Smesharic","username":"Tychenko_Varvara","description":"??","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// оттенки заливки\nvec3 brown1 () { return vec3(0.3961, 0.2627, 0.1294);}\nvec3 brown2 () { return vec3(0.495, 0.37, 0.22);}\nvec3 brown3 () { return vec3(0.3, 0.2, 0.1);}\n//vec3 white () {return vec3(0.9, 0.9, 0.7);}\n//vec3 black () {return vec3(0.0, 0.0, 0.0);}\nvec3 red () {return vec3(0.590, 0.117, 0.106);}\n\n#define color1 vec3(0.5, 0.0, 0.5) // purpure\n#define color2 vec3(0.4, 0.0, 0.5) // purpure \n#define color3 vec3(0.2, 0.0, 0.3) // purpure \n#define color4 vec3(0.45, 0.3, 0.35) // purpure\n\n#define white vec3(1.0, 1.0, 1.0) \n#define black vec3(0.0, 0.0, 0.0) \n\n#define test vec3(0.9, 0.0, 0.0)\n\n\n// функция, возвращающая квадрат числа\nfloat sq(float x) {return x*x;}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = 1.0 - 2.0* fragCoord/iResolution.xy;\n    vec2 m = 1.0 - 2.0* iMouse.xy/iResolution.xy;\n     float x = p.x;\n     float y = p.y; \n   /* float mx = m.x * iResolution.x/iResolution.y;\n      float my = m.y ;\n            x/=mx;\n            y/=my; */\n    float t = iTime;         \n    vec3 col = vec3(0.0, 0.0, 0.0);\n  \n   \n    float res = 1.0 - sq(x) - sq(y - 0.2) - 0.5 ;   \n     if(res >= 0.0) col = color1;\n     \n    res = 1.0 - 9.0*sq(x + 0.7) - sq(y - 0.2) - 0.9;\n     if(res >= 0.0) col = color1; \n     \n    res = 1.0 - 2.0*sq(x - 0.7) - sq(y - 0.1) - 0.9;\n     if(res >= 0.0) col = color3;    \n     \n    res = 1.0 - sq(x - 0.7) - sq(y + 0.9) - 0.9;\n     if(res >= 0.0) col = color4;        \n  \n  \n  \n     \n     \n     float pi = 3.1415;\n   \n    if (  sin(6.0 * pi + x + y )   >= 0.0 ) col = white;\n   \n   \n   \n       // Вывод на экран\n       \n       fragColor = vec4(col,1.0);\n}\n\n\n\n\n/*\n\n// фигуры \nvec3 f1 (float x, float y) { if( max(x*x + y , x*x + y*y ) > 0.52) return vec3(0.2, 0.3, 0.4); }\n\nvec3 f2 (float x, float y, float t) { if( pow((x*x + y*y - 1.0), 3.0) - y*y*y*x*x  <= sin(t/2.0)*0.0 ) return vec3(0.8, 0.3, 0.4); }\n\nvec3 f3 (float x, float y) { \n    float F;\n    if( x != 0.0 ) F =  abs(x) * abs(cos(x)) - abs(y);\n     else F = 0.0 - abs(y);\n    \n    if (F >= 0.0)\n    return vec3(0.2, 0.3, 0.4); \n    }\n    \n// матрицы\nmat3 matx(float a){\n    return mat3( 1.0,   0.0,     0.0,\n                 0.0,   cos(a),  -sin(a),\n                 0.0,   sin(a),  cos(a)     );  }\nmat3 maty(float a){\n    return mat3( cos(a),  0.0,   sin(a),\n                 0.0,     1.0,   0.0,\n                 -sin(a), 0.0,   cos(a)   );  }\n                 \nmat3 yuv2rgb = mat3(1.0, 0.0, 1.13983,\n                    1.0, -0.39465, -0.58060,\n                    1.0, 2.03211, 0.0);\n                 \nmat3 M1 = mat3( 1.0, 0.0, 0.0,\n                0.0, 0.1, 0.0, \n                0.0, 0.0, 1.0  );   \n    \n\n\n   float fn1 = 0.15*abs(x * (y + 1.25) ) + 0.5*abs( y + 1.21) - 0.39;\n   float fn2 = x*x +y*y - 0.25; \n   float heart = pow((x*x + (y - 0.1)*(y - 0.1) - 0.1), 3.0) + y*y*y*x*x;\n \n   if (-fn2 >= 0.0) col = vec3(0.2, 0.3, 0.4);\n   if ( heart <= 0.0 ) col = vec3(0.49, 0.21, 0.42); //* rotate2d(x);\n  штука приколдесная, но, пока, бесполезная {\n   float t1 = abs(sin(t)) * 6.29; \n   if (  (1.0 + cos(t1 * x))*cos(t1 * x) - (1.0 + cos(t1 * y))*sin(t1 * y) >= 0.0) col = white;\n   }\n*/","name":"Image","description":"","type":"image"}]}