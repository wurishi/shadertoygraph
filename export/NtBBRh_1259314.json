{"ver":"0.1","info":{"id":"NtBBRh","date":"1651742856","viewed":40,"name":"Shader#11111","username":"bobrovnikova","description":"1","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["1"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define myPi 3.141592654f\n#define Eps 1e-8\n#define maxZ 100.0\n\nconst int n = 6;\nvec3 colVec[n]; //= vec3[n](vec3(0.6, 0.6, 0.9), vec3(1.0, 0.753, 0.796), vec3(0.678, 1.0, 0.184), vec3(1.0, 0.97, 0.178), vec3(1.0, 0.97, 0.178), vec3(1.0, 0.97, 0.178));\nvec3 BGcol = vec3(1.0, 1.0, 1.0);\n//float zVec[n] = float[n](3.0, 2.0, 1.0);\n\nint sizes[n] = int[n](3, 5, 4, 3, 3, 3), inds[n] = int[n](0, 3, 8, 12, 15, 17); const int m = 20;\nvec2 polygonsXY[m]; float polygonsZ[m];\nvoid initColors(out vec3 colVec[n], in float time){\n    colVec[0] = vec3(0.6, 0.6, 0.9);\n    colVec[1] = vec3(1.0, 0.753, 0.796);\n    colVec[2] = vec3(0.678, 1.0, 0.184);\n    colVec[3] = vec3(1.0+0.1*sin(0.5*time), 0.97+0.2*cos(0.5*time), 0.178+0.3*sin(0.5*time));\n    colVec[4] = vec3(1.0+0.1*sin(0.5*time), 0.97+0.2*cos(0.5*time), 0.178+0.3*sin(0.5*time));\n    colVec[5] = vec3(1.0+0.1*sin(0.5*time), 0.97+0.2*cos(0.5*time), 0.178+0.3*sin(0.5*time));\n    }\n\nvoid initPolygons(out vec2 polygonsXY[m], out float  polygonsZ[m], in float time){\n// 0 -- triangle\n    polygonsXY[0] = vec2(0.1, 0.2); polygonsZ[0] = -0.01; \n    polygonsXY[1] = vec2(0.2, 0.1); polygonsZ[1] = -0.01;\n    polygonsXY[2] = vec2(0.9, 0.9); polygonsZ[2] = -0.11;\n// 1 -- \n    polygonsXY[3] = vec2(0.3, 0.2); polygonsZ[3] = -0.06;\n    polygonsXY[4] = vec2(0.7, 0.2); polygonsZ[4] = -0.06;\n    polygonsXY[5] = vec2(0.95, 0.5); polygonsZ[5] = -0.06;\n    polygonsXY[6] = vec2(0.5, 0.9); polygonsZ[6] = -0.06;\n    polygonsXY[7] = vec2(0.05, 0.5); polygonsZ[7] = -0.06;\n// 2 -- rotated square\n    vec3 center = vec3(0.65, 0.4, -0.05); float r = 0.3;\n    int i; float j =0.0, phi = myPi/3.0;\n    float ang = 2.0*myPi/4.0; \n    vec3 tmpVec;\n    mat3 rot = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, cos(phi), sin(phi)), vec3(0.0, -sin(phi), cos(phi)) );\n    for (i = 8; i < 12; i++){\n        tmpVec = rot*(r*vec3(cos(j*ang + time), sin(j*ang + time), 0.0)); \n        polygonsXY[i] = tmpVec.xy + center.xy;\n        polygonsZ[i] = tmpVec.z + center.z;\n        j = j + 1.0;\n    }\n// 3 -- \n    polygonsXY[12] = vec2(0.2225+0.09*cos(time), 0.535+0.05*sin(time)); polygonsZ[12] = -0.14;\n    polygonsXY[13] = vec2(0.46+0.09*cos(time), 0.704+0.05*sin(time)); polygonsZ[13] = -0.053;\n    polygonsXY[14] = vec2(0.285+0.09*cos(time), 0.695+0.05*sin(time)); polygonsZ[14] = -0.057;\n    polygonsXY[15] = vec2(0.3125+0.09*cos(time), 0.806+0.05*sin(time)); polygonsZ[15] = 0.0;\n    polygonsXY[16] = vec2(0.26+0.09*cos(time), 0.657+0.05*sin(time)); polygonsZ[16] = -0.077;\n    polygonsXY[17] = vec2(0.4025+0.09*cos(time), 0.535+0.05*sin(time)); polygonsZ[17] = -0.14;\n    polygonsXY[18] = vec2(0.34+0.09*cos(time), 0.695+0.05*sin(time)); polygonsZ[18] = -0.057;\n    polygonsXY[19] = vec2(0.165+0.09*cos(time), 0.704+0.05*sin(time)); polygonsZ[19] = -0.053;\n}   \nbool inSphere(in vec2 center, in float radius, in vec2 p)\n{\n    float d = (p.x-center.x)*(p.x-center.x)+(p.y-center.y)*(p.y-center.y);\n    bool res = d<=(radius*radius);\n    return res;\n    }\n\nint leftTurn(in vec2 a, in vec2 b, in vec2 c)\n{\n    float tmp = (c.x - a.x)*(b.y - a.y) - (c.y - a.y)*(b.x - a.x);\n    if (abs(tmp) < Eps) \n        return 0;\n    else \n        return tmp > 0.0 ? 1: -1;\n}\n\n\nbool inPolygon(in int ind0, in int size, in vec2 vert[m], in vec2 p) // vertices in counter clockwise order\n{\n    bool res = leftTurn(vert[ind0 + size-1], vert[ind0], p) <= 0; int i = ind0;\n    while(res && (i < ind0 + size -1))\n    {\n        res = res && (leftTurn(vert[i], vert[i+1], p) <= 0); i++;\n    }\n    return res;\n}\n\nfloat zInPlane(in vec3 a, in vec3 b, in vec3 c, in vec2 p) // z coordinate for (x,y) point of a plane (a-b, c-b)\n{\n    vec3 nrm = cross(a-b, c-b);\n    //float D = - dot(nrm, b);\n    if (abs(nrm.z) < Eps) return a.z;\n    else return (dot(nrm, b) - nrm.x*p.x - nrm.y*p.y)/nrm.z;\n}\n\n\n// vec3 normalize(vec3), vec3 cross(vec3, vec3) are predefined\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float time = iTime, tmp; //iTime;\n    initPolygons(polygonsXY, polygonsZ, time);\n    initColors(colVec, time);\n    vec3 col = BGcol; float z = maxZ; \n    int i;\n    for (i =0; i < n; i++){\n        if ( inPolygon(inds[i], sizes[i], polygonsXY, uv) ){\n            tmp = zInPlane(vec3(polygonsXY[inds[i]].x, polygonsXY[inds[i]].y, polygonsZ[inds[i]]), \\\n            vec3(polygonsXY[inds[i]+1].x, polygonsXY[inds[i]+1].y, polygonsZ[inds[i]+1]), \\\n            vec3(polygonsXY[inds[i]+2].x, polygonsXY[inds[i]+2].y, polygonsZ[inds[i]+2]), uv);\n            if (tmp < z){\n                z = tmp; col = colVec[i]; \n            }\n        }\n    }\n    vec3 Sphere = vec3 (0.55+0.35*sin(time+2.0*uv.x), 0.55+0.35*cos(time+2.0*uv.y), 0.65+0.25*cos(time+2.0*uv.x));\n    vec2 Center = vec2 (0.4, 0.45);\n    if(inSphere(Center, 0.16, uv)){\n        uv -= Center;\n        uv.x *= iResolution.x/iResolution.y;\n        tmp = (-1.0)*sqrt(0.0256-(uv.x)*(uv.x)-(uv.y)*(uv.y));\n        if (tmp<z){\n            z = tmp; col = Sphere;\n        }\n     }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}