{"ver":"0.1","info":{"id":"XfycWh","date":"1731760879","viewed":139,"name":"Sans Undertale Polyrhythm","username":"MrHAX00","description":"Idk why i bothered making this lmao","likes":5,"published":1,"flags":8,"usePreview":0,"tags":["fm","fmsynthesis","sans","polyrhythm"],"hasliked":0,"parentid":"MctGD7","parentname":"FM Polyrhythm 2"},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float BiSmoothStep(float Center, float Distance, float UpperBlur, float LowerBlur, float Value)\n{\n    float Sum = smoothstep(Center - Distance - LowerBlur, Center - Distance, Value);\n    Sum *= smoothstep(Center + Distance + UpperBlur, Center + Distance, Value);\n    \n    return Sum;\n}\n\nconst float NoteSize = 1. / NoteCount;\nfloat SliderSDF(vec2 Point, float NoteSlider, float NoteTime)\n{\n    float NoteLowerBlur = pow(1. - NoteTime, 7.) * .2;\n    float NoteUpperBlur = pow(NoteTime, 7.) * .2;\n    \n    vec2 MinVec = vec2(-NoteSize * NoteSpacing, NoteSlider -.5 + NoteSize * NoteRoundness - NoteLowerBlur);\n    vec2 MaxVec = vec2(NoteSize * NoteSpacing, NoteSlider -.5 - NoteSize * NoteRoundness + .1 + NoteUpperBlur);\n    \n    Point.x = mod(Point.x, NoteSize) - NoteSize * .5;\n    return length(clamp(Point, MinVec, MaxVec) - Point) - NoteSize * NoteRoundness;\n}\n\nvec4 DrawSliders(vec2 uv)\n{\n    float NoteIndex = NoteCount - floor((uv.x + .5) * NoteCount) - 1.;\n    float NoteSpan = 180. / (MaxNoteHits - NoteIndex);\n    float NoteTime = fract((iTime + LoopOffset * 180.) / NoteSpan);\n    \n    float EchoTime = 1.;\n    float Echo = 0.;\n    for (float i = 0.; i < float(EchoCount); i++)\n    {\n        float Current = fract((iTime + LoopOffset * 180. - i * EchoDelay) / NoteSpan);\n        EchoTime = min(EchoTime, Current);\n        Echo = Current == EchoTime? i : Echo;\n    }\n    \n    float NoteSlider = pow(1. - (cos(NoteTime * pi * 2.) * .5 + .5), .375) * .9;\n    \n    float Note = SliderSDF(uv, NoteSlider, NoteTime);\n    float NoteColor = smoothstep(max(pow(1. - EchoTime, 10.) * .05 / (pow(1. + NoteTime, 3.)), .001), 0., Note);\n    NoteColor *= smoothstep(NoteSlider -.5 + NoteSize * NoteRoundness + .2, NoteSlider -.5 + NoteSize * NoteRoundness + .1, uv.y);\n    NoteColor *= smoothstep(NoteSlider -.5 + NoteSize * NoteRoundness - .1, NoteSlider -.5 + NoteSize * NoteRoundness, uv.y);\n    \n    vec3 NoteColor3 = hash11(NoteIndex + floor((iTime + LoopOffset * 180.) / NoteSpan) * .23) > .5? NoteColor1 : NoteColor2;\n    \n    return vec4(NoteColor3 * .8 + .2, NoteColor * .8);\n}\n\nvec3 DrawBG(vec2 uv)\n{\n    float NoteIndex = NoteCount - floor((uv.x + .5) * NoteCount) - 1.;\n    float NoteSpan = 180. / (MaxNoteHits - NoteIndex);\n    \n    float NoteTime = 1.;\n    float Echo = 0.;\n    for (float i = 0.; i < float(EchoCount); i++)\n    {\n        float Current = fract((iTime + LoopOffset * 180. - i * EchoDelay) / NoteSpan);\n        NoteTime = min(NoteTime, Current);\n        Echo = Current == NoteTime? i : Echo;\n    }\n    \n    float BGMix = BiSmoothStep(.5, pow(1. - NoteTime, 2.) * .35, .001, .001, fract(uv.x * NoteCount));\n    BGMix += BiSmoothStep(.5, .05 - NoteTime, .5, .5, fract(uv.x * NoteCount) - cos(uv.y * pi * 10. - iTime * pi) * (.25 - pow(1. - NoteTime, 10.)));\n    \n    vec3 BGRowColor = hash11(NoteIndex + floor((iTime + LoopOffset * 180.) / NoteSpan) * .23) > .5? NoteColor1 : NoteColor2;\n    vec3 BG = mix(BGRowColor * .1 + pow(1. - NoteTime, 15.), BGRowColor * .3 + pow(1. - NoteTime, 3.), BGMix);\n    float BGTransparency = pow(1. - NoteTime, 10.) * pow(.5 - uv.y, pow(1. - NoteTime, 80.) * 15.);\n    BG = mix(texelFetch(iChannel0, ivec2(fract(abs(uv)) * 2. * 1024.), 0).xyz * vec3(.05, .1, .15), BG, max(BGTransparency - pow(Echo / float(EchoCount), .8) * .5, 0.));\n    \n    return BG;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    vec4 Sliders = DrawSliders(uv);\n    vec3 BG = DrawBG(uv);\n    \n    vec3 Sum = mix(BG, Sliders.xyz, Sliders.w);\n    \n    Sum = mix(BG * .05 + .1, Sum, BiSmoothStep(0., .5, .0001, .0001, uv.x));\n    fragColor = vec4(Sum, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define C  16.35\n#define CS 17.32\n#define D  18.35\n#define DS 19.45\n#define E  20.60\n#define F  21.83\n#define FS 23.12\n#define G  24.50\n#define GS 25.96\n#define A  27.50\n#define AS 29.14\n#define B  30.87\n\n#define Octave(Octave) pow(2., Octave)\n\nfloat[] Notes = float[](\n    D * Octave(3.),\n    D * Octave(3.),\n    D * Octave(4.),\n    D * Octave(0.),\n    A * Octave(3.),\n    A * Octave(0.),\n    A * Octave(0.),\n    GS * Octave(3.),\n    GS * Octave(0.),\n    G * Octave(3.),\n    G * Octave(0.),\n    F * Octave(3.),\n    F * Octave(0.),\n    D * Octave(3.),\n    F * Octave(3.),\n    G * Octave(3.)\n);\n\nfloat FMInstrumentA(float Time, float Freq)\n{\n    Time *= pi * 2. * Freq;\n    \n    //1 <- 3 2 <- 4(4)\n    \n    float FeedbackAmount = max(1. - pow(Time * 2., .3), 0.);\n    \n    float Mod1 = cos(Time * 2.) * pi * .5;\n    float Mod2 = cos(Time + cos(Time) * pi * .5 * FeedbackAmount) * pi * .5;\n    \n    float Carrier1 = cos(Time * 2. + Mod1);\n    float Carrier2 = cos(Time * 2.0075 + Mod2);\n    \n    return (Carrier1 + Carrier2) * .3;\n}\n\nfloat FMInstrumentB(float Time, float Freq)\n{\n    Time *= pi * 2. * Freq;\n    \n    //1 2(1) 3(2) 4(3)\n    \n    float Carrier1 = cos(Time);\n    float Carrier2 = cos(Time * 1.0075 + Carrier1 * pi * .1);\n    float Carrier3 = cos(Time * 9. + Carrier2 * pi * .1) * .5;\n    float Carrier4 = cos(Time * 4. + Carrier3 * pi * .1);\n    \n    return (Carrier1 + Carrier2 + Carrier3 + Carrier4) * .1;\n}\n\nvec2 mainSound( int samp, float time )\n{\n    time += LoopOffset * 180.;\n    \n    float Sum = 0.;\n    for (float i = 0.; i < float(EchoCount); i++) {\n        float EchoTime = time - i * EchoDelay;\n        float EchoSum = 0.;\n        for (int i = 0; i < int(NoteCount); i++) {\n            float NoteSpan = 180. / (MaxNoteHits - float(i));\n            float NoteTime = mod(EchoTime, NoteSpan);\n\n            float Note = 0.;\n            if (mod(EchoTime, 90.) < 45.) { // powers of 45 are the first point where you get atleast 4 notes hitting together if you have 15 notes\n                Note = FMInstrumentA(NoteTime, Notes[i % Notes.length()]);\n            } else {\n                Note = FMInstrumentB(NoteTime, Notes[i % Notes.length()]);\n            }\n            Note *= max(1. - pow(NoteTime / NoteSpan, .3), 0.);\n\n            EchoSum += Note;\n        }\n        Sum += EchoSum / float(NoteCount) / (pow(8., i) * .5 + 2.);\n    }\n    \n    return vec2(Sum);\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"#define pi 3.14159\n\n#define MaxNoteHits 50.\n#define EchoCount 3\n#define EchoDelay 1.5\n// use this to go past 180 seconds\n#define LoopOffset 0.\n\n#define NoteCount 16.\n\n// used for visualising only\n#define NoteColor1 vec3(0., .729, .996)\n#define NoteColor2 vec3(.996, .996, 0.)\n#define NoteRoundness .2\n#define NoteSpacing .1\n\n// from https://www.shadertoy.com/view/4djSRW\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}","name":"Common","description":"","type":"common"}]}