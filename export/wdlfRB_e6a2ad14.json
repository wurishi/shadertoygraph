{"ver":"0.1","info":{"id":"wdlfRB","date":"1588551201","viewed":278,"name":"robo","username":"im_paul_hi","description":"bobo","likes":38,"published":1,"flags":0,"usePreview":0,"tags":["robo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    -design from: https://dribbble.com/shots/10707556-Another-Dimension\n    -sdf functions from iq   \n    -\n\n*/\n\n// #define AA 0.005\n#define PI 3.14159\n#define TAU 2.0 * PI\n#define gridThickness 0.05\n\nvec3 headColor = vec3(0.45,0.21,0.67);\nvec3 bgColor = vec3(0.55,0.82,0.87);\nvec3 headGooColor = vec3(0.87,0.56,0.40);\nvec3 blackOutlineColor = vec3(0.09,0.08,0.16);\nvec3 gearCol1 = vec3(0.44,0.48,0.80);\nvec3 gearCol2 = vec3(0.36,0.83,0.99);\nvec3 col = vec3(0.55,0.82,0.87);\nfloat blackOutlineWidth = 0.02;\nvec3 mixedCol = vec3(0.0);\nfloat AA = 0.005;\n\n/*********************************************************\n**********************************************************\n**********************************************************\n**********************************************************/\n\nfloat linearStep(float begin, float end, float t) {\n    return clamp((t - begin) / (end - begin), 0.0, 1.0);\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvec2 within(vec2 uv, vec4 rect) {\n    vec2 val = (uv-rect.xy)/(rect.zw-rect.xy);\n    // val.y = remap(val.y, 0.0, 1.0, 1.0, 0.0);\n    val.y = -val.y + 1.0;\n\treturn val;\n}\n\nfloat inside01(vec2 p) {\n    return step(0.0, p.x) * (1.0 - step(1.0, p.x)) * step(0.0, p.y) * (1.0 - step(1.0, p.y));\n}\n\nfloat insideY(vec2 p) {\n    return step(0.0, p.y) * (1.0 - step(1.0, p.y));\n}\n\nfloat insideX(vec2 p) {\n    return step(0.0, p.x) * (1.0 - step(1.0, p.x));\n}\n\nvoid addGrid(vec2 p, inout vec3 col) {\n    float all = inside01(p);\n    vec3 gridOutlineCol = vec3(1.0, 0.0, 0.0);\n    vec3 gridCol = vec3(0.0);\n\n    // add outline\n    float outline = step(p.x, gridThickness);\n    outline += step(1.0 - gridThickness, p.x);\n    outline += step(p.y, gridThickness);\n    outline += step(1.0 - gridThickness, p.y);\n\n    // p.y = -p.y;\n    // p.y += 1.0;\n\n    // float outline = step(0.0, p.y) * (1.0 - step(0.1, p.y));\n\n    col = mix(col, gridOutlineCol, outline * all);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvec3 returnDottedCol(vec2 p, vec3 bgCol, vec3 dotCol) {\n    vec3 dottedCol = vec3(0.0);\n\n    p *= 28.0;\n    p.x += 0.48;\n    p.y *= 2.49;\n    float yIndex = floor(p.y);\n    float xIndex = floor(p.x);\n    p = fract(p);\n\n    // float circle = smoothstep(mod1, mod2, length(p - vec2(0.5)));\n    // circle *= smoothstep(mod3, mod4, length(p - vec2(1.0, 0.0)));\n\n    float circleBool = 0.0;\n\n    float circle = smoothstep(0.3, 0.6, length(p - vec2(0.5)));\n\n    if(mod(xIndex, 2.0) == 0.0 && mod(yIndex, 2.0) == 0.0) {\n        circleBool = 0.0;\n    } else if(mod(xIndex, 2.0) != 0.0 && mod(yIndex, 2.0) == 0.0) {\n        circleBool = 1.0;\n    } else if(mod(xIndex, 2.0) == 0.0 && mod(yIndex, 2.0) != 0.0) {\n        circleBool = 1.0;\n    }\n\n    dottedCol = mix(bgCol, dotCol, (1.0 - circle) * circleBool);\n\n    return dottedCol;\n}\n\nfloat gain(float x, float k) \n{\n    float a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n    return (x<0.5)?a:1.0-a;\n}\n\nfloat expImpulse( float x, float k )\n{\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\nfloat customEase(float x, float k) {\n    return pow(x, k);\n}\n\nfloat almostIdentity( float x, float m, float n )\n{\n    if( x>m ) return x;\n    float a = 2.0*n - m;\n    float b = 2.0*m - 3.0*n;\n    float t = x/m;\n    return (a*t + b)*t*t + n;\n}\n\nfloat undulateAngle(int index, float angle, float movementScale, float offsetScale, float timeScale) {\n    float offset = float(index) * offsetScale;\n    float m = angle + sin(iTime * timeScale + offset) * movementScale;\n    return m;\n}\n\n\n\n/*********************************************************\n**********************************************************\n**********************************************************\n**********************************************************/\n\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return length(p)-r;\n}\n\nfloat sdCross( in vec2 p, in vec2 b, float r ) \n{\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    vec2  q = p - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n    return sign(k)*length(max(w,0.0)) + r;\n}\n\n\n\nfloat returnTween4Dist(vec2 p, float t, float circleRadius) {\n    // t = normalized time\n    vec2 from = vec2(0.5, 0.66);\n    vec2 to = vec2(0.5, 0.3);\n    float radius = (from.y - to.y) / 2.0;\n    float startAngle = (3.0 * PI) / 2.0;\n    float endAngle = PI;\n    float angle = map(t, 0.0, 1.0, startAngle, endAngle);\n    float angleOffset = -PI * 2.0;\n    // cycle through angle based on t\n    vec2 pos = vec2(sin(angle + angleOffset) * radius, cos(angle + angleOffset) * radius);\n    pos += 0.5;\n    float d = sdCircle(p - pos, circleRadius);\n    return d;\n}\n\nfloat returnTween5Dist(vec2 p, float t, float circleRadius) {\n    // t = normalized time\n    vec2 from = vec2(0.5, 0.32);\n    vec2 to = vec2(0.5, -0.3);\n    vec2 pos = mix(from, to, t);\n    float d = sdCircle(p - pos, circleRadius);\n    return d;\n}\n\nfloat returnTween1Dist(vec2 p, float t, float circleRadius) {\n    // t = normalized time\n    vec2 from = vec2(0.5, 1.0);\n    vec2 to = vec2(0.5, 0.66);\n    vec2 pos = mix(from, to, t);\n    float d = sdCircle(p - pos, circleRadius);\n    return d;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid makeSecondSwoop(vec2 p, inout float d, float loopTime, inout vec3 col, float time) {\n    p -= vec2(0.28, 0.02);\n    // p -= vec2(0.58, 0.02);  // debug view\n\n    for(int i = 0; i < 10; i++) {\n        float d1 = 0.0;\n        float margin = sin(float(i) + time) * 1.0;\n        float modTime = fract((time + margin) / loopTime);\n        float circleRadius = map(modTime, 0.0, 1.0, 0.0, 0.15);\n\n        if(modTime < 0.5) {\n            d1 = returnTween4Dist(p, linearStep(0.0, 0.5, modTime), circleRadius);\n        } else {\n            d1 = returnTween5Dist(p, linearStep(0.5, 1.0, modTime), circleRadius);\n        }\n       \n        // d1 = smoothstep(0.0, AA, d1);\n        // col = mix(col, vec3(1.0), 1.0 - d1);\n\n        if(i != 0) {\n            d = opSmoothUnion(d, d1, 0.04);\n        }\n    }\n}\n\nfloat returnTween2Dist(vec2 p, float t, float circleRadius) {\n    // t = normalized time\n    vec2 from = vec2(0.5, 0.66);\n    vec2 to = vec2(0.5, 0.33);\n    float radius = (from.y - to.y) / 2.0;\n    float startAngle = PI / 2.0;\n    float endAngle = (3.0 * PI) / 2.0;\n    float angle = map(t, 0.0, 1.0, startAngle, endAngle);\n    float angleOffset = -PI * 0.5;\n    // cycle through angle based on t\n    vec2 pos = vec2(sin(angle + angleOffset) * radius, cos(angle + angleOffset) * radius);\n    pos += 0.5;\n    float d = sdCircle(p - pos, circleRadius);\n    return d;\n}\n\nfloat returnTween3Dist(vec2 p, float t, float circleRadius) {\n    // t = normalized time\n    vec2 from = vec2(0.5, 0.33);\n    vec2 to = vec2(0.66, -0.1);\n    vec2 pos = mix(from, to, t);\n    float d = sdCircle(p - pos, circleRadius);\n    return d;\n}\n\nfloat sdBox( in vec2 p, in vec2 b, float r)\n{\n    vec2 d = abs(p) - (b - r);\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\n\n\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat sdRoundBox( in vec2 p, in vec2 b, in vec4 r ) \n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    \n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat dot2(in vec2 v ) { return dot(v,v); }\n\n// trapezoid / capped cone, specialized for Y alignment\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n\n\tp.x = abs(p.x);\n    vec2 ca = vec2(max(0.0,p.x-((p.y<0.0)?r1:r2)), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    \n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n\n/*********************************************************\n**********************************************************\n**********************************************************\n**********************************************************/\n\n\nvoid eye(in vec2 p, inout vec3 col) { \n    // eye lash black bottom\n    // float r = 0.06;\n  \tfloat d = sdSegment(p, vec2(0.5, 0.5), vec2(0.5, 1.04)) - 0.06;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    // eye lash color\n    // r = 0.045;\n  \td = sdSegment(p, vec2(0.5, 0.5), vec2(0.5, 1.04)) - 0.045;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.90,0.76,0.34), 1.0 - d);\n\n    // bottom outline\n    // r = 0.4;\n  \td = sdSegment(p, vec2(0.5, 0.5), vec2(0.5, 0.6)) - 0.4;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    // bottom gear\n    d = sdCircle(p - vec2(0.5, 0.51), 0.39);\n    d = smoothstep(0.0, AA, d);\n    mixedCol = mix(gearCol1, gearCol2, smoothstep(0.67, 0.83, p.x));\n    col = mix(col, mixedCol, 1.0 - d);\n\n    // add lines\n    // only where bottom gear is showing\n    float lines = smoothstep(0.076, 0.079, mod((p.x + iTime * 0.03) * 2.0, 0.1));\n    col = mix(col, vec3(0.0), lines * (1.0 - d));\n\n\n    // r = 0.4;\n    d = sdSegment(p, vec2(0.5, 0.58), vec2(0.5, 0.62)) - 0.4;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    // r = 0.39;\n    d = sdSegment(p, vec2(0.5, 0.59), vec2(0.5, 0.61)) - 0.39;\n    d = smoothstep(0.0, AA, d);\n    mixedCol = mix(vec3(0.55,0.23,0.65), vec3(0.92,0.54,0.37), smoothstep(0.18, 0.92, p.y));\n    col = mix(col, mixedCol, 1.0 - d); \n    \n    ///////////////////////////////////////////////////////////\n    // top gear\n    // black bottom of top gear\n    // r = 0.3;\n    d = sdSegment(p, vec2(0.5, 0.59), vec2(0.5, 0.66)) - 0.3;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d); \n\n    // top gear\n    d = sdCircle(p - vec2(0.5, 0.6), 0.29);\n    d = smoothstep(0.0, AA, d);\n    mixedCol = mix(vec3(0.40,0.70,0.61), vec3(0.87,0.76,0.37), 1.0 - p.x);\n    col = mix(col, mixedCol, 1.0 - d);\n\n    // top gear lines\n    lines = smoothstep(0.076, 0.079, mod((p.x - iTime * 0.03) * 2.0, 0.1));\n    col = mix(col, vec3(0.0), lines * (1.0 - d));\n\n    //black bottom of top colored gear\n    // r = 0.3;\n    d = sdSegment(p, vec2(0.5, 0.67), vec2(0.5, 0.67)) - 0.3;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d); \n\n    // r = 0.285;\n    d = sdSegment(p, vec2(0.5, 0.67), vec2(0.5, 0.67)) - 0.285;\n    d = smoothstep(0.0, AA, d);\n    mixedCol = mix(vec3(0.99,0.96,0.86), vec3(0.92,0.81,0.48), p.x);\n    col = mix(col, mixedCol, 1.0 - d); \n\n    // pupil\n    // r = 0.2;\n    d = sdSegment(p, vec2(0.5, 0.67), vec2(0.5, 0.67)) - 0.2;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d); \n\n    // iris\n    // r = 0.05;\n    d = sdSegment(p, vec2(0.5, 0.67), vec2(0.5, 0.67)) - 0.05;\n    d = smoothstep(0.0, AA, d);\n    mixedCol = mix(vec3(0.75,0.76,0.55), vec3(0.48,0.82,0.86), p.x);\n    col = mix(col, mixedCol, 1.0 - d); \n\n    // addGrid(p, col);\n}\n\nvoid head(in vec2 p, inout vec3 col) {\n\n    // black outline\n\tfloat d = sdSegment(p, vec2(0.5, 0.5), vec2(0.5, 0.0)) - 0.5;\n    d = smoothstep(0.0, AA,d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    // head goo\n    d = sdSegment(p, vec2(0.5, 0.5), vec2(0.5, 0.0)) - 0.5 * (1.0 - blackOutlineWidth);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, headGooColor, 1.0 - d);\n\n    ////////////////////////////////////////////////\n    // head black\n    // head bg outline color\n\n    float d1 = sdSegment(p, vec2(0.5, 0.5), vec2(0.5, 0.0)) - 0.44;\n    \n\n    float d2 = sdSegment(p, vec2(0.85, 0.2), vec2(0.8, 0.2)) - 0.03;\n\td = opSmoothUnion(d1, d2, 0.2);\n\t\n    \n \n    d1 = sdSegment(p, vec2(0.8,0.7), vec2(0.8,0.7)) - 0.005;\n    d = opSmoothUnion(d, d1, 0.3);\n    \n\n    d1 = sdSegment(p, vec2(0.72, 0.92), vec2(0.72, 0.92)) - 0.005;\n    d = opSmoothSubtraction(d1, d, 0.15);\n\n    d1 = sdSegment(p, vec2(0.92, 0.62), vec2(0.92, 0.62)) - 0.005;\n    d = opSmoothSubtraction(d1, d, 0.1);\n\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    \n    \n    // ////////////////////////////////////////////////\n    // head main color\n    d = sdSegment(p, vec2(0.5, 0.5), vec2(0.5, 0.0)) - 0.43;\n\n    d1 = sdSegment(p, vec2(0.85, 0.2), vec2(0.8, 0.2)) - 0.02;\n    d = opSmoothUnion(d, d1, 0.2);\n\n    d1 = sdSegment(p, vec2(0.8,0.7), vec2(0.8,0.7)) - 0.004;\n    d = opSmoothUnion(d, d1, 0.3);\n\n    d1 = sdSegment(p, vec2(0.72, 0.92), vec2(0.72, 0.92)) - 0.004;\n    d = opSmoothSubtraction(d1, d, 0.15);\n\n    d1 = sdSegment(p, vec2(0.92, 0.62), vec2(0.92, 0.62)) - 0.004;\n    d = opSmoothSubtraction(d1, d, 0.1);\n\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, headColor, 1.0 - d);\n\n    // addGrid(p, col);\n}\n\nvoid mouth(in vec2 p, inout vec3 col) {\n    float isInside = inside01(p);\n\n    // light bg\n    vec3 mixedCol = mix(vec3(0.94,0.85,0.59), vec3(1.00,0.98,0.91), p.y);\n    col = mix(col, mixedCol, isInside);\n\n    // circle black bottom\n    vec2 pMod = vec2(p.x, p.y * 0.5);\n    float d = sdCircle(pMod - vec2(0.5, -0.2), 0.37);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    // circle color\n    d = sdCircle(pMod - vec2(0.5, -0.21), 0.36);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.91,0.54,0.36), 1.0 - d);\n    \n    /////////////////////////////////////////////////////////////////////\n    // OIL\n    /////////////////////////////////////////////////////////////////\n    // oil pipe\n    d = sdSegment(p, vec2(0.75, 0.9), vec2(0.75, 0.0)) - 0.03;\n\n    // setup oilBulge1 anim\n    float loopTime = 3.0;\n    float modTime = mod(iTime, loopTime);\n    modTime = 1.0 - (modTime / loopTime); \n    float yPos = ((abs(-0.2) + abs(0.5)) * modTime) + -0.2; \n    pMod = vec2(p.x, p.y * 0.4);\n    float d1 = sdSegment(pMod, vec2(0.75, yPos), vec2(0.75, yPos)) - 0.05 * isInside;\n    d = opSmoothUnion(d, d1, 0.11);\n\n   // setup oilBulge2 anim\n    modTime = mod(iTime + 1.0, loopTime);\n    modTime = 1.0 - (modTime / loopTime);\n    yPos = ((abs(-0.2) + abs(0.5)) * modTime) + -0.2; \n    \n    // sd of oilbulge2\n    d1 = sdSegment(pMod, vec2(0.75, yPos), vec2(0.75, yPos)) - 0.03 * isInside;\n    d = opSmoothUnion(d, d1, 0.11);\n\n    // setup oilBulge3 anim\n    modTime = mod(iTime + 2.0, loopTime);\n    modTime = 1.0 - (modTime / loopTime);\n    yPos = ((abs(-0.2) + abs(0.5)) * modTime) + -0.2; \n    \n    // sd of oilbulge3\n    d1 = sdSegment(pMod, vec2(0.75, yPos), vec2(0.75, yPos)) - 0.01 * isInside;\n    d = opSmoothUnion(d, d1, 0.11);\n\n    //////////////////////////////////////////////////////////////\n    // middle oil pipe\n    d1 = sdSegment(p, vec2(0.5, 0.9), vec2(0.5, 0.0)) - 0.01;\n    d = opSmoothUnion(d, d1, 0.11);\n\n    // middle bulge 1\n    loopTime = 3.8;\n    modTime = mod(iTime, loopTime);\n    modTime = 1.0 - (modTime / loopTime);\n    yPos = ((abs(-0.2) + abs(0.5)) * modTime) + -0.2;\n    d1 = sdSegment(pMod, vec2(0.5, yPos), vec2(0.5, yPos)) - 0.01 * isInside;\n    d = opSmoothUnion(d, d1, 0.11);\n\n    // middle bulge 2\n    modTime = mod(iTime + 1.3, loopTime);\n    modTime = 1.0 - (modTime / loopTime);\n    yPos = ((abs(-0.2) + abs(0.5)) * modTime) + -0.2; \n    // bulge2Pos = vec2(0.5, yPos);\n\n    // sd of middle oilbulge2\n    d1 = sdSegment(pMod, vec2(0.5, yPos), vec2(0.5, yPos)) - 0.05 * isInside;\n    d = opSmoothUnion(d, d1, 0.11);\n\n    // setup middle oilBulge3 anim\n    modTime = mod(iTime + 2.6, loopTime);\n    modTime = 1.0 - (modTime / loopTime);\n    yPos = ((abs(-0.2) + abs(0.5)) * modTime) + -0.2; \n    \n    // sd of middle oilbulge3\n    d1 = sdSegment(pMod, vec2(0.5, yPos), vec2(0.5, yPos)) - 0.03 * isInside;\n    d = opSmoothUnion(d, d1, 0.11);\n\n    //////////////////////////////////////////////////////////\n    // TOP OIL LINE\n\n    loopTime = 3.0;\n    modTime = mod(iTime, loopTime);\n    modTime /= loopTime;\n    float m = (abs(sin(modTime * TAU)) + 0.2) * 0.3;\n    d1 = sdSegment(p, vec2(0.0, 0.96), vec2(1.0, 0.96)) - 0.04;\n    d = opSmoothUnion(d, d1, m);\n\n    //////////////////////////////////////////////\n    // SIDE OIL LINE\n    d1 = sdSegment(p, vec2(1.0, 1.0), vec2(1.0, 0.0)) - 0.015;\n    d = opSmoothUnion(d, d1, 0.11);\n\n    // draw oil\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, (1.0 - d) * isInside);\n\n}\n\nvoid nose(in vec2 p, inout vec3 col) {\n    float isInside = inside01(p);\n    float isInsideY = insideY(p);\n    float isInsideX = insideX(p);\n    vec2 modP = vec2(0.0);\n    vec3 mixedCol = vec3(0.0);\n\n    ////////////////////////////////////////////////////////\n    // hourglass black bottom - top triangle\n    float d2 = sdTriangle(p, vec2(0.48, 0.63), vec2(0.48, 0.85), vec2(1.0, 0.85));\n    // hourglass black bottom - bottom triangle\n    float d1 = sdTriangle(p, vec2(0.91, 0.39), vec2(0.52, 0.64), vec2(0.0, 0.41));\n    float d = opSmoothUnion(d1, d2, 0.14);\n    // hourglass black bottom - middle bend\n    modP = vec2(p.x, p.y * 2.0);\n    float d3 = sdCircle(modP - vec2(0.68, 1.26), 0.04);\n    d = opSmoothUnion(d, d3, 0.1);\n    // hourglass black bottom - top bend\n    d1 = sdCircle(modP - vec2(0.85, 1.64), 0.11);\n    d = opSmoothUnion(d, d1, 0.11);\n    // draw hourglass black bottom\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    //////////////////////////////////////////////////////\n    // hourglass colored - top triangle\n    d2 = sdTriangle(p, vec2(0.40, 0.63), vec2(0.47, 0.84), vec2(0.91, 0.84));\n    // hourglass colored - bottom triangle\n    d1 = sdTriangle(p, vec2(0.8645, 0.39), vec2(0.494, 0.64), vec2(0.0, 0.41));\n    d = opSmoothUnion(d1, d2, 0.14);\n    // hourglass colored - middle bend\n    modP = vec2(p.x, p.y * 2.0);\n    d3 = sdCircle(modP - vec2(0.65, 1.26), 0.01);\n    d = opSmoothUnion(d, d3, 0.16);\n    // hourglass colored - top bend\n    d1 = sdCircle(modP - vec2(0.85, 1.64), 0.09);\n    d = opSmoothUnion(d, d1, 0.11);\n    // draw hourglass colored\n    d = smoothstep(0.0, AA, d);\n    vec3 dottedCol = returnDottedCol(p, vec3(0.89,0.76,0.34), vec3(0.81,0.43,0.12));\n    col = mix(col, dottedCol, 1.0 - d);\n\n\n    ////////////////////////////////////////////////////\n    // black bottom\n    modP = vec2(p.x, p.y * 3.0);\n    // float r = 0.5;\n    d1 = sdSegment(modP, vec2(0.5, 0.9), vec2(0.5, 0.4)) - 0.5;\n    // float subtractR = 0.07;\n    d2 = sdSegment(p, vec2(0.67, -0.1), vec2(0.5, -0.1)) - 0.07;\n\n    d3 = opSmoothSubtraction(d2, d1, 0.5);\n\n    // r = 0.05;\n    d = sdSegment(p, vec2(0.93, 0.1), vec2(0.93, 0.02)) - 0.05;\n    d = opSmoothUnion(d, d3, 0.01);\n\n    // r = 0.005;\n    d1 = sdSegment(p, vec2(0.7, -0.01), vec2(1.4, -0.01)) - 0.005;\n    float loopTime = 2.0;\n    float modTime = mod(iTime, loopTime) / loopTime;\n    float smoothVal = (abs(sin(modTime * TAU))) * 0.085;\n    d = opSmoothUnion(d, d1, smoothVal * isInsideY);\n\n    // middle bottom pipe\n    // r = 0.05;\n    d2 = sdSegment(p, vec2(0.5, 0.1), vec2(0.5, -0.01)) - 0.05;\n    d = opSmoothUnion(d, d2, 0.09);\n\n    // middle bottom pipe connector\n    // r = 0.005;\n    d1 = sdSegment(p, vec2(0.4, -0.01), vec2(0.6, -0.01)) - 0.005;\n    loopTime = 2.0;\n    modTime = mod(iTime + 0.5, loopTime) / loopTime;\n    smoothVal = (abs(sin(modTime * TAU)) + 0.07) * 0.1;\n    d = opSmoothUnion(d, d1, smoothVal);\n\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    ///////////////////////////////////////////////////\n    // nose tubes\n\n    // r = 0.13;\n    vec2 pMod = vec2(p.x * 0.9, p.y * 2.5);\n    d = sdSegment(pMod, vec2(0.59, 0.69), vec2(0.59, 0.37)) - 0.13;\n    mixedCol = mix(vec3(0.40,0.36,0.67), vec3(0.35,0.84,0.99), smoothstep(0.54, 0.85, p.x));\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, mixedCol, 1.0 - d);\n\n    // nose tube bottom black\n    d = sdCircle(pMod - vec2(0.59, 0.36), 0.13);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    // nose tube middle black ring\n    loopTime = 2.0;\n    modTime = mod(iTime, loopTime) / loopTime;\n    float m = 0.06 * abs(sin(modTime * TAU)) + 0.54;\n    d = sdCircle(pMod - vec2(0.59, 0.52), 0.14);\n    d2 = sdCircle(pMod - vec2(0.59, m), 0.13);\n    d = opSubtraction(d, d2);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    // nose tube bottom color\n    d = sdCircle(pMod - vec2(0.59, 0.34), 0.12);\n    d = smoothstep(0.0, AA, d);\n    mixedCol = mix(vec3(0.58,0.28,0.56), vec3(0.90,0.53,0.37), smoothstep(0.09, 0.18, p.y));\n    col = mix(col, mixedCol, 1.0 - d);\n\n    // addGrid(p, col);\n\n}\n\nvoid upperThirdEyeOil(vec2 p, inout vec3 col, vec2 origP) {\n    float d = 0.0;\n    float d1 = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float r = 0.0;\n    vec2 modP = vec2(0.0);\n    vec2 p1 = vec2(0.0);\n    vec3 mixedCol = vec3(0.0);\n    float modTime = 0.0;\n    float loopTime = 0.0;\n    vec2 pos1 = vec2(0.0);\n    vec2 pos2 = vec2(0.0);\n    vec2 mixedPos = vec2(0.0);\n    float isWithinTrapezoid = 0.0;\n    float mask = 0.0;\n    float mask1 = 0.0;\n    float mask2 = 0.0;\n    float m = 0.0;\n    float dropOffset = 0.5;\n\n    modP = within(vec2(abs(origP.x), origP.y), vec4(-0.24, 0.61, 0.7, -0.33));\n\n    d = sdBezier(modP, vec2(0.33, 0.59), vec2(0.61, 0.57), vec2(0.7, 0.26)) - 0.02;\n    // draw base oil\n    // d = smoothstep(0.0, AA, d);\n    // col = mix(col, blackOutlineColor, 1.0 - d);\n\n    loopTime = 4.0;\n    // draw drops\n    for(int i = 0; i < 7; i++) {\n        float margin = sin(0.4 * float(i) + iTime);\n        modTime = fract((iTime + margin) / loopTime);\n        modTime = map(modTime, 0.0, 1.0, 0.2, 0.85);\n        float remap = map(modTime, 0.0, 1.0, -1.0, 1.0);\n        float y = 1.0 - pow(abs(sin(PI * remap / 2.0)), 2.0);\n        float circleRadius = map(y, 0.0, 1.0, 0.0, 0.015);\n\n        float m = 1.0 - pow(abs(modTime), 8.5);\n        vec2 pos = vec2(modTime, m);\n        pos += vec2(-0.17, -0.42);\n        d1 = sdCircle(modP - pos, circleRadius);\n\n        // d1 = smoothstep(0.0, AA, d1);\n        // col = mix(col, vec3(1.0), 1.0 - d1);\n\n        d = opSmoothUnion(d, d1, 0.035);\n    }\n\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n\n    // addGrid(modP, col);\n}\n\nvoid thirdEye(in vec2 p, inout vec3 col, vec2 origP) {\n    float d = 0.0;\n    float d1 = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float r = 0.0;\n    vec2 modP = vec2(0.0);\n    vec3 mixedCol = vec3(0.0);\n    float modTime = 0.0;\n    float loopTime = 0.0;\n    vec2 pos1 = vec2(0.0);\n    vec2 pos2 = vec2(0.0);\n    vec2 mixedPos = vec2(0.0);\n    float isWithinTrapezoid = 0.0;\n    float mask = 0.0;\n    float mask1 = 0.0;\n    float mask2 = 0.0;\n    float m = 0.0;\n    float dropOffset = 0.5;\n\n    /////////////////////\n    // THIRD EYE CIRCLES\n    ////////////////////\n    // oil line on non circle part of circles\n    d = sdSegment(p, vec2(0.5, 0.61), vec2(0.5, 0.55)) - 0.007;\n    d1 = sdCircle(p - vec2(0.5, 0.52), 0.02);\n    d = opSmoothUnion(d, d1, 0.05);\n\n    //////////////////////////////////////////\n    // circular movement drip 1\n    modP = vec2(abs(origP.x) * 2.2, origP.y * 3.0);\n    modP.x += 0.5;\n    loopTime = 3.0;\n    modTime = fract(iTime / loopTime); \n    // run normalized time through easing function\n    modTime = expImpulse(modTime, 0.5);\n    if(modTime < 0.55) {\n        m = map(modTime, 0.0, 0.55, 1.4, 0.47);\n    } else {\n        m = max(sin( (modTime - -0.72) / 0.69 ) + -0.5, (modTime - 0.582) / -0.096 * 1.098);\n    }\n    mask = step(0.68, modP.y);\n    d2 = sdCircle(modP - vec2(modTime, m), 0.05 * ((1.0 - modTime) + 0.2));\n    // mask it\n    d2 += mask;\n    d = opSmoothUnion(d, d2, 0.1);\n    \n    // drip 2\n    modP = vec2(abs(origP.x) * 2.2, origP.y * 3.0);\n    modP.x += 0.5;\n    loopTime = 3.0;\n    modTime = fract((iTime + 1.5) / loopTime); \n    // run normalized time through easing function\n    modTime = expImpulse(modTime, 0.5);\n    if(modTime < 0.55) {\n        m = map(modTime, 0.0, 0.55, 1.4, 0.47);\n    } else {\n        m = max(sin( (modTime - -0.72) / 0.69 ) + -0.5, (modTime - 0.582) / -0.096 * 1.098);\n    }\n    mask = step(0.68, modP.y);\n    d2 = sdCircle(modP - vec2(modTime, m), 0.05 * ((1.0 - modTime) + 0.2));\n    // mask it\n    d2 += mask;\n    d = opSmoothUnion(d, d2, 0.1);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    //////////////////////////////////////////////////////\n    // outer third eye (the floating one)\n    // black bottom\n    mask1 = step(0.24, p.y);\n    d = sdCircle(p - vec2(0.5, 0.25), 0.35 * mask1);\n    d1 = sdCircle(p - vec2(0.5, 0.25), 0.42 * mask1);\n    d = opSubtraction(d, d1);\n    d = smoothstep(0.0, AA, d);\n    mask = d;\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    upperThirdEyeOil(p, col, origP);\n    // colored part\n    d = sdCircle(p - vec2(0.5, 0.25), 0.36 * mask1);\n    d1 = sdCircle(p - vec2(0.5, 0.25), 0.41 * mask1);\n    d = opSubtraction(d, d1);\n    d = smoothstep(0.0, AA, d);\n    mixedCol = mix(vec3(0.91,0.65,0.36), vec3(0.92,0.54,0.36), smoothstep(0.52, 0.45, 1.0 - p.y));\n    col = mix(col, mixedCol, 1.0 - d);\n    // oil drip middle line and bottom connecting circle\n    d = sdSegment(p, vec2(0.5, 0.66), vec2(0.5, 0.61)) - 0.009;\n    d += mask;\n    d1 = sdCircle(p - vec2(0.51, 0.51), 0.11);\n    d1 += mask;\n    d = opSmoothUnion(d, d1, 0.03);\n    // circular movement drip 1\n    modP = vec2(abs(origP.x) * 3.0, origP.y * 3.0);\n    modP.x += 0.48;\n    modP.y -= 0.15;\n    loopTime = 3.0;\n    float time = iTime - 0.5;\n    modTime = fract(time / loopTime); \n    // run normalized time through easing function\n    modTime = expImpulse(modTime, 0.5);\n    m = 0.5 - pow(abs(modTime), 5.5);\n    d2 = sdCircle(modP - vec2(modTime, m), 0.05 * ((1.0 - modTime) + 0.2));\n    // mask it\n    d2 += mask;\n    d = opSmoothUnion(d, d2, 0.1);\n    // circular movement drip 2\n    modTime = fract((time + (loopTime / 2.0)) / loopTime); \n    // run normalized time through easing function\n    modTime = expImpulse(modTime, 0.5);\n    m = 0.5 - pow(abs(modTime), 5.5);\n    d2 = sdCircle(modP - vec2(modTime, m), 0.05 * ((1.0 - modTime) + 0.2));\n    // mask it\n    d2 += mask;\n    d = opSmoothUnion(d, d2, 0.1);\n    // color outer third eye oil\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n\n    // circle tips go woo woo\n    d = sdCircle(p - vec2(0.885, 0.24), 0.035);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    d = sdCircle(p - vec2(0.885, 0.24), 0.025);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.91,0.57,0.36), 1.0 - d);\n    d = sdCircle(p - vec2(0.885, 0.24), 0.015);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    \n\n    ///////////////////////////////////////////////\n    //third eye circle 5 (outer connected one to the trapezoid)\n    // inner third eye circle - black bottom\n    mask1 = step(0.24, p.y);\n    d = sdCircle(p - vec2(0.5, 0.25), 0.302 * mask1);\n    d = smoothstep(0.0, AA, d);\n    mask = d;\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    // inner third eye circle - color\n    d = sdCircle(p - vec2(0.5, 0.252), 0.292 * mask1);\n    d = smoothstep(0.0, AA, d);\n    modP = vec2(p.x * 3.9 + 0.765, p.y * 1.9);\n    col = mix(col, vec3(0.92,0.56,0.37), 1.0 - d);\n    // oil line\n    d = sdSegment(p, vec2(0.5, 0.335), vec2(0.5, 0.59)) - 0.003;\n    loopTime = 2.0;\n    // modTime = mod(iTime - dropOffset * 5.0, loopTime) / loopTime;\n    modTime = fract((iTime - 0.25) / loopTime);\n    //////////\n    modP = vec2(abs(origP.x) * 3.0, origP.y * 3.0);\n    modP.x -= -0.5;\n    modP.y += 0.25;\n    modTime = expImpulse(modTime, 0.5);\n    if(modTime < 0.5) {\n        m = map(modTime, 0.0, 0.5, 1.0, 0.5);\n        modTime = map(modTime, 0.0, 0.5, 0.4, 0.5);\n    } else {\n        m = max(-99.0 * modTime + 50.0, pow(cos(3.14 * (modTime - 0.5) / 2.0), 0.5) - 0.5);\n    }\n    d1 = sdCircle(modP - vec2(modTime, m), 0.05 * ((1.0 - modTime) + 0.2));\n    d = opSmoothUnion(d, d1, 0.1);\n    d2 = sdCircle(p - vec2(0.5, 0.43), 0.03);\n    d = opSmoothUnion(d, d2, 0.08);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, (1.0 - d) * (1.0/* - mask*/));\n    // addGrid(modP, col);\n    ///////////////////////////////////////////////\n    //third eye circle 4 (thick black)\n    // inner third eye circle - black bottom\n    d = sdCircle(p - vec2(0.5, 0.25), 0.23);\n    d = smoothstep(0.0, AA, d);\n    mask = d;\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    // // inner third eye circle - color\n    // d = sdCircle(p - vec2(0.5, 0.252), 0.20);\n    // d = smoothstep(0.0, AA, d);\n    // modP = vec2(p.x * 3.9 + 0.765, p.y * 1.9);\n    // mixedCol = returnDottedCol(modP, vec3(0.33,0.85,0.98), vec3(0.42,0.28,0.72));\n    // col = mix(col, mixedCol, 1.0 - d);\n    // // oil line\n    // d = sdSegment(p, vec2(0.5, 0.335), vec2(0.5, 0.51)) - 0.003;\n    // loopTime = 2.0;\n    // modTime = mod(-iTime - 1.0, loopTime) / loopTime;\n    // m = (0.5 - 0.3) * modTime + 0.3;\n    // d1 = sdCircle(p - vec2(0.5, m), 0.01);\n    // d = opSmoothUnion(d, d1, 0.05);\n    // d2 = sdCircle(p - vec2(0.5, 0.36), 0.03);\n    // d = opSmoothUnion(d, d2, 0.05);\n    // d = smoothstep(0.0, AA, d);\n    // col = mix(col, blackOutlineColor, (1.0 - d) * (1.0 - mask));\n    ///////////////////////////////////////////////\n    //third eye circle 3 (the dotted one)\n    // inner third eye circle - black bottom\n    d = sdCircle(p - vec2(0.5, 0.25), 0.21);\n    d = smoothstep(0.0, AA, d);\n    mask = d;\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    // inner third eye circle - color\n    d = sdCircle(p - vec2(0.5, 0.252), 0.20);\n    d = smoothstep(0.0, AA, d);\n    modP = vec2(p.x * 3.9 + 0.765, p.y * 1.9);\n    mixedCol = returnDottedCol(modP, vec3(0.33,0.85,0.98), vec3(0.42,0.28,0.72));\n    col = mix(col, mixedCol, 1.0 - d);\n    // oil line\n    d = sdSegment(p, vec2(0.5, 0.335), vec2(0.5, 0.51)) - 0.003;\n    loopTime = 2.0;\n    modTime = mod(-iTime - dropOffset * 3.0, loopTime) / loopTime;\n    m = (0.5 - 0.3) * modTime + 0.3;\n    d1 = sdCircle(p - vec2(0.5, m), 0.01);\n    d = opSmoothUnion(d, d1, 0.05);\n    d2 = sdCircle(p - vec2(0.5, 0.36), 0.03);\n    d = opSmoothUnion(d, d2, 0.05);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, (1.0 - d) * (1.0 - mask));\n    ///////////////////////////////////////////////\n    //third eye circle 2\n    // inner third eye circle - black bottom\n    d = sdCircle(p - vec2(0.5, 0.25), 0.14);\n    d = smoothstep(0.0, AA, d);\n    mask = d;\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    // inner third eye circle - color\n    d = sdCircle(p - vec2(0.5, 0.252), 0.13);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.48,0.17,0.69), 1.0 - d);\n    // oil line\n    d = sdSegment(p, vec2(0.5, 0.335), vec2(0.5, 0.51)) - 0.003;\n    loopTime = 2.0;\n    modTime = mod(-iTime - dropOffset * 2.0, loopTime) / loopTime;\n    m = (0.45 - 0.26) * modTime + 0.26;\n    d1 = sdCircle(p - vec2(0.5, m), 0.01);\n    d = opSmoothUnion(d, d1, 0.05);\n    d2 = sdCircle(p - vec2(0.5, 0.3), 0.03);\n    d = opSmoothUnion(d, d2, 0.05);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, (1.0 - d) * (1.0 - mask));\n    /////////////////////////////////////////////////\n    // third eye circle 1\n    // inner third eye circle - black bottom\n    d = sdCircle(p - vec2(0.5, 0.25), 0.09);\n    d = smoothstep(0.0, AA, d);\n    mask = d;\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    // inner third eye circle - color\n    d = sdCircle(p - vec2(0.5, 0.252), 0.08);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.91,0.54,0.36), 1.0 - d);\n    // oil line\n    d = sdSegment(p, vec2(0.5, 0.335), vec2(0.5, 0.29)) - 0.003;\n    loopTime = 2.0;\n    modTime = mod(-iTime - dropOffset * 1.0, loopTime) / loopTime;\n    m = (0.42 - 0.23) * modTime + 0.23;\n    d1 = sdCircle(p - vec2(0.5, m), 0.01);\n    d = opSmoothUnion(d, d1, 0.05);\n    d2 = sdCircle(p - vec2(0.5, 0.245), 0.03);\n    d = opSmoothUnion(d, d2, 0.05);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, (1.0 - d) * (1.0 - mask));\n    \n\n    /////////////////////////////////////////////////////////////// \n    // lower trapezoid black bottom\n    d = sdTrapezoid(p - vec2(0.48, 0.12), 0.12, 0.32, 0.12);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    // light trapezoid background\n    d = sdTrapezoid(p - vec2(0.46, 0.12), 0.14, 0.322, 0.11);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.91,0.54,0.37), 1.0 - d);\n\n    // black of trapezoid\n    d = sdTrapezoid(p - vec2(0.26, 0.12), 0.335, 0.43, 0.12);\n    // bump 1\n    loopTime = 2.0;\n    pos1 = vec2(0.76, 0.29);\n    pos2 = vec2(0.55, 0.0);\n    modTime = mod(iTime, loopTime) / loopTime;\n    mixedPos = mix(pos1, pos2, modTime);\n    d1 = sdCircle(p - mixedPos, 0.02);\n    d = opSmoothUnion(d, d1, 0.04);\n    // bump 2\n    loopTime = 2.0;\n    pos1 = vec2(0.76, 0.29);\n    pos2 = vec2(0.55, 0.0);\n    modTime = mod(iTime + 0.7, loopTime) / loopTime;\n    mixedPos = mix(pos1, pos2, modTime);\n    d1 = sdCircle(p - mixedPos, 0.02);\n    d = opSmoothUnion(d, d1, 0.04);\n    // bump 3\n    loopTime = 2.0;\n    pos1 = vec2(0.76, 0.29);\n    pos2 = vec2(0.55, 0.0);\n    modTime = mod(iTime + 1.4, loopTime) / loopTime;\n    mixedPos = mix(pos1, pos2, modTime);\n    d1 = sdCircle(p - mixedPos, 0.02);\n    d = opSmoothUnion(d, d1, 0.04);\n\n    isWithinTrapezoid = step(0.0, p.y) * (1.0 - step(0.24, p.y));\n\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, (1.0 - d) * isWithinTrapezoid);\n\n    // trapezoid small triangle\n    d = sdTriangle(p, vec2(0.59, 0.03), vec2(0.59, 0.23), vec2(0.64, 0.23));\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.35,0.85,0.98), 1.0 - d);\n\n    //////////////////////////////////////////////////////////////////////////\n    // trapezoid tube - black bottom\n    r = 0.05;\n    d = sdSegment(p, vec2(0.496, 0.24), vec2(0.496, 0.0)) - r;\n    d1 = step(0.008, p.y);\n    d = smoothstep(0.0, AA, d);\n    mask = d;\n    col = mix(col, blackOutlineColor, (1.0 - d) * d1);\n    // trapezoid tube - color\n    r = 0.043;\n    d = sdSegment(p, vec2(0.496, 0.24), vec2(0.496, 0.0)) - r;\n    d1 = step(0.008, p.y);\n    d = smoothstep(0.0, AA, d);\n    mixedCol = mix(vec3(0.41,0.36,0.68), vec3(0.42,0.72,0.90), smoothstep(0.6, 0.47, p.x));\n    col = mix(col, mixedCol, (1.0 - d) * d1);\n    // middle tube divider\n    r = 0.0005;\n    loopTime = 1.0;\n    modTime = mod(iTime, loopTime) / loopTime;\n    m = 0.1 * modTime - 0.05;\n    d3 = sdSegment(origP, vec2(m, -0.285), vec2(m, 0.5)) - r;\n    d3 = smoothstep(0.0, AA, d3);\n    col = mix(col, blackOutlineColor, (1.0 - d3) * (1.0 - mask));\n    // tube divider 1\n    r = 0.05;\n    d = sdCircle(p - vec2(0.5, 0.14), 0.06);\n    d1 = sdCircle(p - vec2(0.5, 0.15), 0.055);\n    d = opSubtraction(d, d1);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    // tube divider 2\n    r = 0.05;\n    d = sdCircle(p - vec2(0.5, 0.04), 0.06);\n    d1 = sdCircle(p - vec2(0.5, 0.05), 0.055);\n    d = opSubtraction(d, d1);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n\n\n    \n    // addGrid(modP, col);\n\n    \n}\n\nvoid littleDrop(vec2 p, inout vec3 col, float timeOffset) {\n    float loopTime = 1.0;\n    float modTime = fract((iTime + timeOffset)/loopTime);\n    float smoothFactor = map(modTime, 0.0, 1.0, 0.0, 0.17);\n    float yPos = map(modTime * modTime * modTime, 0.0, 1.0, 0.53, 0.15);\n    vec2 movingDripPos = vec2(0.51, yPos);\n\n\n    float d1 = sdCircle(p - vec2(0.51, 0.53), 0.02);\n    float d2 = sdCircle(p - movingDripPos, 0.02);\n    float d = opSmoothUnion(d1, d2, smoothFactor);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    // addGrid(p, col);\n}\n\nvoid test(vec2 p, inout vec3 col) {\n    vec2 pos = vec2(0.0, 0.0);\n    float loopTime = 3.0;\n    float modTime = fract(iTime / loopTime);\n\n    modTime = map(modTime, 0.0, 1.0, 0.0, TAU);\n    float r = 0.5;\n    pos.x = sin(modTime) * r;\n    pos.y = cos(modTime) * r;\n\n    float d = sdCircle(p - pos, 0.05);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(1.0), 1.0 - d);\n}\n\nvoid eyeOil(vec2 p, inout vec3 col) {\n    float d = 0.0;\n    float d1 = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float r = 0.0;\n    vec2 modP = vec2(0.0);\n    vec3 mixedCol = vec3(0.0);\n    float modTime = 0.0;\n    float loopTime = 0.0;\n    vec2 pos1 = vec2(0.0);\n    vec2 pos2 = vec2(0.0);\n    vec2 mixedPos = vec2(0.0);\n    float isWithinTrapezoid = 0.0;\n    float mask = 0.0;\n    float mask1 = 0.0;\n    float mask2 = 0.0;\n    float m = 0.0;\n    float dropOffset = 0.5;\n    float time = 0.0;\n    float timeScale = 0.3;\n\n    /////////////////////////////////////\n    // cluster of circles\n    /////////////////////////////////////\n    float startAngle = 0.0;\n    float margin = 0.05;\n    float circleLayoutRadius = 0.5;\n    float circleRadius = 0.02;\n    modP = within(p, vec4(-0.02, -0.02, 0.93, -0.87));\n    // modP = within(p, vec4(-0.13, 0.09, 0.93, -1.0)); \n    // rotate grid just a tad\n    modP = rotate2d(0.05) * modP;\n    // addGrid(modP, col);\n    d = sdCircle(modP - vec2(0.5), 0.02);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(1.0), 1.0 - d);\n    time = iTime * timeScale;\n\n    // DRAW CIRLCLES THROUGH TWEEN\n    loopTime = 3.0;\n    // position circles\n    for(int i = 0; i < 12; i++) {\n        float margin = sin(float(i) + time) * 1.0;\n        modTime = fract((time + margin) / loopTime);\n        float s = smoothstep(0.1, 0.3, modP.y);\n        float m = modP.y * modP.y * 1.5;\n        circleRadius = map(m, 0.0, 1.0, 0.04, 0.005);\n        circleRadius *= s;\n        // circleRadius = 0.004;\n        if(modTime < 0.333) {\n            // tween 1\n            d1 = returnTween1Dist(modP, linearStep(0.0, 0.333, modTime), circleRadius);\n        } else if(modTime < 0.666) {\n            //tween 2\n            d1 = returnTween2Dist(modP, linearStep(0.33, 0.666, modTime), circleRadius);\n        } else {\n            // tween 3\n            d1 = returnTween3Dist(modP, linearStep(0.666, 1.0, modTime), circleRadius);\n        }\n\n        if(i != 0) {\n            float smoothVal = modP.y * 0.12;\n            d = opSmoothUnion(d, d1, smoothVal);  // 0.12\n        }\n    }\n\n    // base circle\n    d1 = sdCircle(p - vec2(0.37, -0.48), 0.2);\n    d = opSmoothUnion(d, d1, 0.13);\n    // // draw oil\n    // d = smoothstep(0.0, AA, d);\n    // col = mix(col, blackOutlineColor, 1.0 - d);\n    /////////////////////////////////////////////////////////////\n    // bottom left swoop tween\n    modP = within(p, vec4(-0.43, 0.09, 0.76, -1.0));\n    timeScale = 0.3;\n    time = iTime * timeScale;\n    makeSecondSwoop(modP, d, loopTime, col, time);\n    // addGrid(modP, col);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    ///////////////////////////////////////////////////////////////////////////\n    \n    \n}\n\nvoid hat(vec2 p, inout vec3 col, vec2 origP) {\n    float d = 0.0;\n    float d1 = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float r = 0.0;\n    vec2 modP = vec2(0.0);\n    vec2 p1 = vec2(0.0);\n    vec3 mixedCol = vec3(0.0);\n    float modTime = 0.0;\n    float loopTime = 0.0;\n    vec2 pos1 = vec2(0.0);\n    vec2 pos2 = vec2(0.0);\n    vec2 mixedPos = vec2(0.0);\n    float isWithinTrapezoid = 0.0;\n    float mask = 0.0;\n    float mask1 = 0.0;\n    float mask2 = 0.0;\n    float m = 0.0;\n    float dropOffset = 0.5;\n\n    modP = within(origP, vec4(-1.0, 1.0, 1.0, -0.52));\n\n    // black bottom\n    d = sdSegment(p, vec2(0.0, -0.10), vec2(-0.26, -0.93)) - 0.76;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    // colored part\n    d = sdSegment(p, vec2(0.0, -0.10), vec2(-0.26, -0.93)) - 0.745;\n    d = smoothstep(0.0, AA, d);\n    mixedCol = returnDottedCol(vec2(p.x * 4.0, p.y * 2.0), vec3(0.91,0.75,0.34), vec3(0.82,0.44,0.12));\n    col = mix(col, mixedCol, 1.0 - d);\n\n    // addGrid(modP, col);\n\n\n}\n\nvoid crown(vec2 p, inout vec3 col, vec2 origP) {\n    float d = 0.0;\n    float d1 = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float r = 0.0;\n    vec2 modP = vec2(0.0);\n    vec2 p1 = vec2(0.0);\n    vec3 mixedCol = vec3(0.0);\n    float modTime = 0.0;\n    float loopTime = 0.0;\n    vec2 pos1 = vec2(0.0);\n    vec2 pos2 = vec2(0.0);\n    vec2 mixedPos = vec2(0.0);\n    float isWithinTrapezoid = 0.0;\n    float mask = 0.0;\n    float mask1 = 0.0;\n    float mask2 = 0.0;\n    float m = 0.0;\n    float dropOffset = 0.5;\n\n    modP = within(origP, vec4(-1.0, 1.0, 1.0, -0.52));\n\n\n    // addGrid(modP, col);\n\n    // black bottom\n    d = sdBox(modP - vec2(0.5, 0.91), vec2(0.1, 0.44), 0.0);\n    d = smoothstep(0.0, AA, d);\n    mask1 = 1.0 - d;\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    // color bg\n    d = sdBox(modP - vec2(0.5, 0.91), vec2(0.095, 0.405), 0.04);\n    d = smoothstep(0.0, AA, d);\n    mask = 1.0 - d;\n    mixedCol = mix(vec3(0.61,0.80,0.72), vec3(0.90,0.76,0.34), map(modP.y, 0.60 * abs(sin(iTime * 1.5)), 0.67, 0.0, 1.0));\n    col = mix(col, mixedCol, 1.0 - d);\n\n    // middle pipe\n    loopTime = 2.0;\n    modTime = fract((iTime + 0.05) / loopTime);\n    m = abs(sin(modTime * TAU)) * 0.02;\n    d = sdSegment(p, vec2(0.0 + m, 0.85), vec2(0.0, 0.26)) - 0.05;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    // bottom color of middle pipe\n    d = sdSegment(p, vec2(0.0, 0.57), vec2(0.0, 0.26)) - 0.04;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.90,0.63,0.34), 1.0 - d);\n\n\n    \n\n    // top circle\n    float radiusM = abs(sin(modTime * TAU)) * 0.02;\n    d = sdCircle(p - vec2(0.0, 0.85), 0.05 + radiusM);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    d = sdCircle(p - vec2(0.0, 0.85), 0.045 + radiusM);\n    d = smoothstep(0.0, AA, d);\n    mixedCol = returnDottedCol(vec2(p.x * 4.0, p.y * 2.0), vec3(0.91,0.55,0.37), vec3(0.84,0.36,0.18));\n    col = mix(col, mixedCol, 1.0 - d);\n\n    // top dotted color\n    d = sdCircle(p - vec2(0.2, 1.0), 0.15);\n    d = smoothstep(0.0, AA, d);\n    mixedCol = mix(vec3(0.73,0.78,0.61), vec3(0.44,0.80,0.92), map(p.y, 0.9, 1.0, 0.0, 1.0));\n    mixedCol = returnDottedCol(vec2(p.x * 4.0, p.y * 2.0), mixedCol, vec3(0.44,0.21,0.68));\n    col = mix(col, mixedCol, (1.0 - d) * mask);\n\n    // black under diamond\n    d = sdCircle(p - vec2(0.17, 0.67), 0.13);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, (1.0 - d) * mask);\n\n    // diamond black bottom\n    d = sdCross(origP - vec2(0.0, 0.84), vec2(0.52, 0.33), 0.37);\n    d1 = sdCross(origP - vec2(0.0, 0.84), vec2(0.52, 0.33), 0.37 - 0.05);\n    d = opSubtraction(d, d1);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, (1.0 - d) * mask);\n    // diamond white part\n    d = sdCross(origP - vec2(0.0, 0.84), vec2(0.52, 0.33), 0.36);\n    d1 = sdCross(origP - vec2(0.0, 0.84), vec2(0.52, 0.33), 0.38 - 0.05);\n    d = opSubtraction(d, d1);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(1.00,0.98,0.90), (1.0 - d) * mask);\n\n    // hat cover up part\n    // black bottom\n    d = sdSegment(p, vec2(0.0, -0.10), vec2(-0.26, -0.93)) - 0.76;\n    d1 = sdSegment(p, vec2(0.0, -0.205), vec2(-0.26, -0.93)) - 0.745;\n    d = opSubtraction(d1, d);\n    d = smoothstep(0.0, AA, d); \n    col = mix(col, blackOutlineColor, (1.0 - d) * mask);\n    // dotted color\n    d = sdSegment(p, vec2(0.0, -0.115), vec2(-0.26, -0.93)) - 0.76;\n    d1 = sdSegment(p, vec2(0.0, -0.19), vec2(-0.26, -0.93)) - 0.745;\n    d = opSubtraction(d1, d);\n    d = smoothstep(0.0, AA, d); \n    mixedCol = returnDottedCol(vec2(p.x * 4.0, p.y * 2.0), vec3(0.91,0.75,0.34), vec3(0.82,0.44,0.12));\n    col = mix(col, mixedCol, (1.0 - d) * mask);\n\n    // crown oil\n    vec2 from = vec2(0.2, 1.3);\n    vec2 to = vec2(0.2, 0.17);\n    loopTime = 4.0;\n    for(int i = 0; i < 20; i++) {\n        float time = iTime * 0.5;\n        float margin = cos(0.25 * float(i) + time);\n        modTime = fract((time + margin) / loopTime);\n        float scale = 0.01 * abs(sin(modTime * TAU * 2.0)) + 0.01;\n        pos1 = mix(from, to, modTime);\n        d1 = sdCircle(p - pos1, scale);\n\n        if(i != 0) {\n            d = opSmoothUnion(d, d1, 0.02 * abs(sin(iTime)) + 0.03); \n        } else {\n            d = d1;\n        }\n    }\n\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, (1.0 - d) * mask1);\n\n    // middle oil line circles\n    from = vec2(0.0, 1.3);\n    to = vec2(0.0, 0.17);\n    loopTime = 4.0;\n    for(int i = 0; i < 20; i++) {\n        float time = (iTime + 3.5) * 0.4;\n        float margin = cos(float(i) + time);\n        modTime = fract((time + margin) / loopTime);\n        float scale = 0.005 * abs(sin(modTime * TAU * 2.0)) + 0.005;\n        pos1 = mix(from, to, modTime);\n        d1 = sdCircle(p - pos1, scale);\n\n        if(i != 0) {\n            d = opSmoothUnion(d, d1, 0.02 * abs(sin(iTime)) + 0.01); \n        } else {\n            d = d1;\n        }\n    }\n\n    // line\n    d1 = sdSegment(p, vec2(0.0, 1.0), vec2(0.0, 0.26)) - 0.0005;\n    d = opSmoothUnion(d, d1, 0.02 * abs(sin(iTime)) + 0.01); \n\n    mask2 = mask1 * step(p.y, 0.78);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, (1.0 - d) * mask2);\n\n    // bottom circle\n    modTime = fract((iTime) / loopTime);\n    m = 0.25 + sin(modTime * TAU) * 0.02;\n    d = sdCircle(p - vec2(0.0, m), 0.05);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    d = sdCircle(p - vec2(0.0, m), 0.045);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.89,0.96,0.91), 1.0 - d);\n}\n\nvoid backClouds(vec2 p, inout vec3 col, vec2 origP) {\n    float d = 0.0;\n    float d1 = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float r = 0.0;\n    vec2 modP = vec2(0.0);\n    vec2 p1 = vec2(0.0);\n    vec3 mixedCol = vec3(0.0);\n    float modTime = 0.0;\n    float loopTime = 0.0;\n    vec2 pos1 = vec2(0.0);\n    vec2 pos2 = vec2(0.0);\n    vec2 mixedPos = vec2(0.0);\n    float isWithinTrapezoid = 0.0;\n    float mask = 0.0;\n    float mask1 = 0.0;\n    float mask2 = 0.0;\n    float m = 0.0;\n    float dropOffset = 0.5;\n\n    // top black bottom\n    vec2 pointA = vec2(0.0, 0.0);\n    vec2 pointB = vec2(2.0, 1.8);\n    d = sdSegment(p, pointA, pointB) - 0.09;\n    float h = dot(p - pointA, pointB - pointA);\n    float time = -iTime;\n    m = (0.04 + 0.04 * sin(2.0 * PI * h + (time * 2.0)/2.0));\n    m += (0.1 + 0.05 * sin(1.2 * PI * h + (time * 4.0)/10.0));\n    m += (0.01 + 0.02 * sin(2.0 * PI * h + (time * 4.0)/2.0));\n    // m += (0.01 + 0.01 * sin(6.0 * PI * h + (time * 4.0)/2.0));\n    // keep adding waves till it looks good\n    d = d - m;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    // more top black bottom\n    pointA = vec2(0.0, -0.3);\n    pointB = vec2(2.0, 1.5);\n    d = sdSegment(p, pointA, pointB) - 0.09;\n    h = dot(p - pointA, pointB - pointA);\n    time = -iTime;\n    m = (0.04 + 0.04 * sin(2.0 * PI * h + (time * 2.0)/2.0));\n    m += (0.1 + 0.05 * sin(1.2 * PI * h + (time * 4.0)/10.0));\n    m += (0.01 + 0.02 * sin(2.0 * PI * h + (time * 4.0)/2.0));\n    // m += (0.01 + 0.01 * sin(6.0 * PI * h + (time * 4.0)/2.0));\n    // keep adding waves till it looks good\n    d = d - m;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    // top color\n    pointA = vec2(0.0, 0.0);\n    pointB = vec2(2.0, 1.8);\n    d = sdSegment(p, pointA, pointB) - 0.03;\n    h = dot(p - pointA, pointB - pointA);\n    time = -iTime;\n    m = (0.04 + 0.01 * sin(2.0 * PI * h + (time * 2.0)/2.0));\n    m += (0.1 + 0.02 * sin(1.2 * PI * h + (time * 4.0)/10.0));\n    m += (0.01 + 0.03 * sin(2.0 * PI * h + (time * 4.0)/2.0));\n    // m += (0.01 + 0.01 * sin(6.0 * PI * h + (time * 4.0)/2.0));\n    // keep adding waves till it looks good\n    d = d - m;\n    d = smoothstep(0.0, AA, d);\n    mixedCol = mix(vec3(0.52,0.87,0.96), vec3(0.95,0.97,0.91), p.x);\n    col = mix(col, mixedCol, 1.0 - d);\n\n    // dotted back wave\n    pointA = vec2(0.0, -1.5);\n    pointB = vec2(2.0, 0.8);\n    d = sdSegment(p, pointA, pointB) - 0.03;\n    h = dot(p - pointA, pointB - pointA);\n    time = -iTime;\n    m = (0.04 + 0.01 * sin(2.0 * PI * h + (time * 2.0)/2.0));\n    m += (0.1 + 0.02 * sin(1.2 * PI * h + (time * 4.0)/10.0));\n    m += (0.01 + 0.03 * sin(2.0 * PI * h + (time * 4.0)/2.0));\n    m += (0.1 + 0.1 * sin(0.5 * PI * h + (time * 4.0)/2.0));\n    // m += (0.01 + 0.01 * sin(6.0 * PI * h + (time * 4.0)/2.0));\n    // keep adding waves till it looks good\n    d = d - m;\n    d = smoothstep(0.0, AA, d);\n    mixedCol = mix(col, vec3(0.90,0.76,0.34), map(origP.y, -1.0, 1.0, 0.0, 1.0));\n    mixedCol = returnDottedCol(vec2(p.x * 4.0, p.y * 2.0), mixedCol, vec3(0.81,0.58,0.46));\n    col = mix(col, mixedCol, 1.0 - d);\n\n    // black\n    // pointA = vec2(0.0, -2.0);\n    // pointB = vec2(2.0, 0.5);\n    // d = sdSegment(p, pointA, pointB) - 0.03;\n    // h = dot(p - pointA, pointB - pointA);\n    // time = -iTime + 2.0;\n    // m = (0.04 + 0.01 * sin(2.0 * PI * h + (time * 2.0)/4.0));\n    // m += (0.1 + 0.02 * sin(1.2 * PI * h + (time * 4.0)/10.0));\n    // m += (0.01 + 0.03 * sin(2.0 * PI * h + (time * 4.0)/3.0));\n    // // m += (0.01 + 0.01 * sin(6.0 * PI * h + (time * 4.0)/2.0));\n    // // keep adding waves till it looks good\n    // d = d - m;\n    // d = smoothstep(0.0, AA, d);\n    // col = mix(col, blackOutlineColor, 1.0 - d);\n\n    // back block black\n    d = sdBox(origP - vec2(0.0, -1.0), vec2(2.0, 0.5), 0.0);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    // back block color\n    d = sdBox(origP - vec2(0.0, -1.0), vec2(2.0, 0.49), 0.0);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.90,0.76,0.34), 1.0 - d);\n    // back block black\n    d = sdBox(origP - vec2(0.0, -1.05), vec2(2.0, 0.5), 0.0);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    // back block color\n    d = sdBox(origP - vec2(0.0, -1.05), vec2(2.0, 0.49), 0.0);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.90,0.76,0.34), 1.0 - d);\n    // back block black\n    d = sdBox(origP - vec2(0.0, -1.2), vec2(2.0, 0.5), 0.0);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    // back block color\n    d = sdBox(origP - vec2(0.0, -1.2), vec2(2.0, 0.49), 0.0);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.90,0.76,0.34), 1.0 - d);\n    // back block black\n    d = sdBox(origP - vec2(0.0, -1.45), vec2(2.0, 0.5), 0.0);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    // back block color\n    d = sdBox(origP - vec2(0.0, -1.45), vec2(2.0, 0.49), 0.0);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.90,0.76,0.34), 1.0 - d);\n\n    // cloud\n    pointA = vec2(0.0, -2.7);\n    pointB = vec2(2.0, 0.5);\n    d = sdSegment(p, pointA, pointB) - 0.3;\n    h = dot(p - pointA, pointB - pointA);\n    time = -iTime + 2.0;\n    m = (0.04 + 0.01 * sin(1.3 * PI * h + (time * 2.0)/4.0));\n    m += (0.1 + 0.02 * sin(1.2 * PI * h + (time * 4.0)/10.0));\n    m += (0.01 + 0.03 * sin(1.5 * PI * h + (time * 4.0)/3.0));\n    m += (0.1 + 0.05 * sin(1.0 * PI * h + (time * 4.0)/2.0));\n    // keep adding waves till it looks good\n    d = d - m;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    // cloud\n    pointA = vec2(0.0, -2.7);\n    pointB = vec2(2.0, 0.5);\n    d = sdSegment(p, pointA, pointB) - 0.29;\n    h = dot(p - pointA, pointB - pointA);\n    time = -iTime + 2.0;\n    m = (0.04 + 0.01 * sin(1.3 * PI * h + (time * 2.0)/4.0));\n    m += (0.1 + 0.02 * sin(1.2 * PI * h + (time * 4.0)/10.0));\n    m += (0.01 + 0.03 * sin(1.5 * PI * h + (time * 4.0)/3.0));\n    m += (0.1 + 0.05 * sin(1.0 * PI * h + (time * 4.0)/2.0));\n    // keep adding waves till it looks good\n    d = d - m;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.45,0.87,0.97), 1.0 - d);\n    // dottted\n    pointA = vec2(0.0, -2.8);\n    pointB = vec2(2.0, -0.24);\n    d = sdSegment(p, pointA, pointB) - 0.29;\n    h = dot(p - pointA, pointB - pointA);\n    time = -iTime + 2.0;\n    m = (0.04 + 0.01 * sin(2.0 * PI * h + (time * 2.0)/4.0));\n    m += (0.1 + 0.02 * sin(1.2 * PI * h + (time * 4.0)/10.0));\n    m += (0.01 + 0.03 * sin(2.0 * PI * h + (time * 4.0)/3.0));\n    // m += (0.01 + 0.01 * sin(6.0 * PI * h + (time * 4.0)/2.0));\n    // keep adding waves till it looks good\n    d = d - m;\n    d = smoothstep(0.0, AA, d);\n    mixedCol = mix(vec3(0.44,0.86,0.98),vec3(0.91,0.96,0.91), p.x);\n    mixedCol = returnDottedCol(vec2(p.x * 4.0, p.y * 2.0), col, vec3(0.23,0.36,0.68));\n    col = mix(col, mixedCol, 1.0 - d);\n\n    // front dark cloud - black bottom\n    pointA = vec2(0.0, -3.0);\n    pointB = vec2(2.0, -0.24);\n    d = sdSegment(p, pointA, pointB) - 0.29;\n    h = dot(p - pointA, pointB - pointA);\n    time = -iTime + 3.0;\n    m = (0.04 + 0.01 * sin(2.0 * PI * h + (time * 2.0)/2.0));\n    m += (0.1 + 0.02 * sin(1.2 * PI * h + (time * 4.0)/10.0));\n    m += (0.01 + 0.03 * sin(2.0 * PI * h + (time * 4.0)/2.0));\n    m += (0.1 + 0.1 * sin(0.5 * PI * h + (time * 4.0)/2.0));\n    // keep adding waves till it looks good\n    d = d - m;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    // front dark cloud - color\n    pointA = vec2(0.0, -3.0);\n    pointB = vec2(2.0, -0.24);\n    d = sdSegment(p, pointA, pointB) - 0.28;\n    h = dot(p - pointA, pointB - pointA);\n    time = -iTime + 3.0;\n    m = (0.04 + 0.01 * sin(2.0 * PI * h + (time * 2.0)/2.0));\n    m += (0.1 + 0.02 * sin(1.2 * PI * h + (time * 4.0)/10.0));\n    m += (0.01 + 0.03 * sin(2.0 * PI * h + (time * 4.0)/2.0));\n    m += (0.1 + 0.1 * sin(0.5 * PI * h + (time * 4.0)/2.0));\n    // keep adding waves till it looks good\n    d = d - m;\n    d = smoothstep(0.0, AA, d);\n    mixedCol = mix(vec3(0.90,0.54,0.38),vec3(0.63,0.30,0.60), 1.0 - map(p.x, 1.0, 0.48, 0.0, 1.0));\n    col = mix(col, mixedCol, 1.0 - d);\n    \n}\n\nvoid thirdEyeRays(vec2 p, inout vec3 col, vec2 origP) {\n    float d = 0.0;\n    float d1 = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float r = 0.0;\n    vec2 modP = vec2(0.0);\n    vec2 p1 = vec2(0.0);\n    vec3 mixedCol = vec3(0.0);\n    float modTime = 0.0;\n    float loopTime = 0.0;\n    vec2 pos1 = vec2(0.0);\n    vec2 pos2 = vec2(0.0);\n    vec2 mixedPos = vec2(0.0);\n    float isWithinTrapezoid = 0.0;\n    float mask = 0.0;\n    float mask1 = 0.0;\n    float mask2 = 0.0;\n    float m = 0.0;\n    float dropOffset = 0.5;\n\n    // black bottom\n    modP = vec2(p.x, p.y);\n    modP = rotate2d(-0.76) * modP;\n    d = sdBox(modP - vec2(0.1, 1.0), vec2(0.07, 0.75), -0.8);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    // color bottom\n    d = sdBox(modP - vec2(0.1, 1.0), vec2(0.06, 0.75), -0.8);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.91,0.54,0.36), 1.0 - d);\n\n    // middle black bottom\n    d = sdBox(modP - vec2(0.1, 1.0), vec2(0.03, 0.75), -0.8);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    // middle color 0.76 - 1.0\n    d = sdBox(modP - vec2(0.1, 1.0), vec2(0.018, 0.75), -0.8);\n    d = smoothstep(0.0, AA, d);\n    mixedCol = mix(vec3(0.51,0.20,0.67), vec3(0.89,0.51,0.40), map(modP.y, 0.22, 0.25 * abs(sin(iTime * 6.0)) + 0.76, 0.0, 1.0));\n    col = mix(col, mixedCol, 1.0 - d);\n}\n\nvoid backBars(vec2 p, inout vec3 col, vec2 origP) {\n    float d = 0.0;\n    float d1 = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float r = 0.0;\n    vec2 modP = vec2(0.0);\n    vec2 p1 = vec2(0.0);\n    vec3 mixedCol = vec3(0.0);\n    float modTime = 0.0;\n    float loopTime = 0.0;\n    vec2 pos1 = vec2(0.0);\n    vec2 pos2 = vec2(0.0);\n    vec2 mixedPos = vec2(0.0);\n    float isWithinTrapezoid = 0.0;\n    float mask = 0.0;\n    float mask1 = 0.0;\n    float mask2 = 0.0;\n    float m = 0.0;\n    float dropOffset = 0.5;\n\n    // black bottom\n    d = sdBox(p - vec2(0.83, 0.81), vec2(0.91, 0.07), -0.8);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    // dotted color\n    d = sdBox(p - vec2(0.83, 0.81), vec2(0.91, 0.06), -0.8);\n    d = smoothstep(0.0, AA, d);\n    mixedCol = returnDottedCol(vec2(p.x * 3.0, p.y * 3.0), vec3(0.48,0.17,0.69), vec3(0.44,0.08,0.33));\n    col = mix(col, mixedCol, 1.0 - d);\n\n    // while color\n    d = sdBox(p - vec2(0.83, 0.78), vec2(0.91, 0.03), -0.8);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(1.0), 1.0 - d);\n\n    // middle black bottom\n    d = sdBox(p - vec2(0.83, 0.81), vec2(0.91, 0.03), -0.8);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    // middle color \n    d = sdBox(p - vec2(0.83, 0.81), vec2(0.91, 0.02), -0.8);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.35,0.84,0.98), 1.0 - d);\n}\n\nvoid bg(vec2 p, inout vec3 col, vec2 origP) {\n    col = mix(col, vec3(0.90,0.76,0.34), map(origP.y, 0.39, 0.74, 0.0, 1.0));\n\n    col = mix(col, vec3(0.76,0.78,0.53), map(origP.y, -0.09, -0.59, 0.0, 1.0));\n}\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    //vec2 p = (2.0 * gl_FragCoord.xy - iResolution.xy) / iResolution.y;\n    \n\n    vec2 origP = vec2(p.x, p.y);\n    // mirror coords\n    p.x = abs(p.x);\n\n    // AA = map(sin(iTime * 3.0), -1.0, 1.0, 0.005, 0.01);\n    float m = length(p) * 0.05 * abs(sin(iTime * 1.0));\n    AA = 0.005 + m;\n    \n    bg(p, col, origP);\n    backBars(p, col, origP);\n    backClouds(p, col, origP);\n    hat(p, col, origP);\n    head(within(p, vec4(-0.75, 0.55, 0.75, -1.0)), col);\n    eyeOil(p, col);\n    mouth(within(p, vec4(-0.3, -0.75, 0.3, -1.0)), col);\n    nose(within(p, vec4(-0.1, -0.2, 0.1, -0.75)), col);   \n    crown(p, col, origP);\n    thirdEyeRays(p, col, origP);\n    thirdEye(within(p, vec4(-0.5, 0.5, 0.5, -0.29)), col, origP);  \n    littleDrop(within(origP, vec4(0.15, 0.13, 0.61, -0.37)), col, 0.3);\n    littleDrop(within(origP, vec4(-0.15, 0.13, -0.61, -0.37)), col, 0.0);\n    eye(within(p, vec4(0.13, -0.25, 0.63, -0.7)), col);\n    // test(origP, col);\n\n    fragColor = vec4(col,1.0);\n    //gl_FragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}