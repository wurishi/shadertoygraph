{"ver":"0.1","info":{"id":"NtdBDM","date":"1663171342","viewed":117,"name":"Solar system #112","username":"Denis_Kremko","description":"Simple solar system","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["solarsystem"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int TRACE_MAX_STEPS = 255;\nconst float TRACE_MAX_DIST = 10.0;\nconst float TRACE_EPSILON = 0.001;\nconst float NORMAL_EPSILON = 0.001;\nconst vec3 eye = vec3(0.0, 0.0, 5.0);\n\nconst vec4 sun_color = vec4(1.0, 1.0, 0.0, 1.0);\nconst vec4 orbit_color = vec4(0.2, 0.2, 0.2, 1.0);\n\nbool hit_sun = false;\nbool hit_orbit = false;\n\nmat3 rotateX(float val)\n{\n    float c = cos(val);\n    float s = sin(val);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float val)\n{\n    float c = cos(val);\n    float s = sin(val);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nfloat unionSDF(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\nfloat sphereSDF(in vec3 p, in vec3 c, in float r)\n{\n    return length(p - c) - r;\n}\n\nfloat centerTorusSDF(in vec3 p, in vec2 t)\n{\n    return length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n\nfloat sceneSDF(vec3 p)\n{\n    float dist = 1.0;\n    mat3 init_rotate_matrix = rotateX(2.0);\n    \n    float sin_time = sin(iTime * 0.4);\n    float cos_time = cos(iTime * 0.4);\n    \n    for (float i = 0.0; i < 9.0; i++)\n    {\n        mat3 rotate_matrix = init_rotate_matrix;\n        rotate_matrix *= rotateY(i * i);\n        \n        float orbit_radius = (2.5 - pow(0.25 * i, 0.7)) - 0.55;\n            \n        float dist_to_orbit = centerTorusSDF(p * rotate_matrix, vec2(orbit_radius, 0.01));\n        dist = unionSDF(dist, dist_to_orbit);\n            \n        if (dist_to_orbit < TRACE_EPSILON)\n        {\n            hit_orbit = true;\n            return dist;\n        }\n            \n        vec3 sphere_center = vec3(orbit_radius * cos(iTime * (i + 1.0) * 0.15), 0.0, orbit_radius * sin(iTime * (i + 1.0) * 0.15));\n        float sphere_radius = 0.033 * pow((10.0 - i), 0.5);\n        \n        dist = unionSDF(dist, sphereSDF(p * rotate_matrix, sphere_center, sphere_radius));\n    }\n    \n    float final_dist = unionSDF(dist, sphereSDF(p, vec3(0.0, 0.0, 0.0), 0.2));\n    \n    if (final_dist < TRACE_EPSILON && final_dist < dist) {\n        hit_sun = true;\n    }\n    \n    return final_dist;\n}\n\nvec3 traceSDF(vec3 from, vec3 dir, out bool hit)\n{\n    vec3 p = from;\n    float totalDist = 0.;    \n    hit = false;\n    for (int steps = 0; steps < TRACE_MAX_STEPS; steps++)\n    {\n        float dist = sceneSDF(p);\n        \n        if (dist < TRACE_EPSILON)\n        {\n            hit = true;\n            break;\n        }\n        \n        totalDist += dist;\n        if (totalDist > TRACE_MAX_DIST)\n            break;\n            \n        p += 0.9 * dir * dist;\n    }\n    \n    return p;\n}\n\nvec3 calcNormal(vec3 p, float d)\n{\n    float e = max(d * 0.5, NORMAL_EPSILON);\n    return normalize(vec3(\n        sceneSDF(p + vec3(e, 0, 0)) - sceneSDF(p - vec3(e, 0, 0)),\n        sceneSDF(p + vec3(0, e, 0)) - sceneSDF(p - vec3(0, e, 0)),\n        sceneSDF(p + vec3(0, 0, e)) - sceneSDF(p - vec3(0, 0, e))\n    ));\n}\n\n\nfloat ambientOcclusion(in vec3 pos, in vec3 normal)\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++)\n    {\n        float h = 0.01 + 0.12 * float(i) / 4.;\n        float d = sceneSDF(pos + h * normal);\n        occ += (h - d) * sca;\n        sca *= 0.95;\n        if (occ > 0.35) \n            break;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0) * (0.5 + 0.5 * normal.y);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 5.0 * (fragCoord - 0.5 * iResolution.xy) / iResolution.xy;\n    vec3 dir = normalize(vec3(uv, 0) - eye);\n    \n    bool hit = false;\n    vec3 p = traceSDF(eye, dir, hit);\n    \n    vec4 color;\n    \n    if (hit_sun) {\n        fragColor = sun_color;\n        return;\n    }\n    \n    if (hit_orbit) {\n        fragColor = orbit_color;\n        return;\n    }\n    \n    color = vec4(0.0, 0.0, 0.0, 1);\n    \n    vec3 light = vec3(0.0, 0.0, 0.0);\n    if (hit)\n    {\n        vec3 l = normalize(light - p);\n        vec3 n = calcNormal(p, 0.001);\n        float nl = max(0.0, dot(n, l));\n        \n        vec3 v = normalize(eye - p);\n        vec3 h = normalize(l + v);\n        float hn = max(0.0, dot(h, n));\n        float sp = pow(hn, 100.0);\n        \n        vec4 colorDiffuse = vec4(0.8, 0.8, 0.0, 1);\n        vec4 colorPhong = vec4(0.8, 0.8, 0.8, 1);\n        vec4 colorAbmient = vec4(0.5, 0.5, 0.5, 1);\n        \n        color += colorDiffuse * vec4(nl)\n            + colorPhong * sp\n            + .25 * colorAbmient * ambientOcclusion(p, n);\n    }\n    \n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}