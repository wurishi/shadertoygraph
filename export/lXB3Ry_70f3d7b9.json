{"ver":"0.1","info":{"id":"lXB3Ry","date":"1708574972","viewed":87,"name":"Perlin Distortion","username":"Squidz","description":"Using a Perlin noise filter to offset the texture sampling.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["perlinnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float random(float value){\n\tfloat mutator = 0.69420;\n    float _out = fract(sin(value + mutator) * 42069.80085);\n    _out = fract(sin(_out + mutator) * 95453.54515);\n    return _out;\n}\n\nvec2 random2d(float value0, float value1){\n    float mutator0 = 0.80085;\n    float mutator1 = 0.42069;\n    float val2 = dot(value0, value1);\n    return vec2(random(val2 - mutator0), random(val2 - mutator1));\n}\n\nvec3 random3d(float value0, float value1, float value2){\n    float mutator0 = 0.80085;\n    float mutator1 = 0.42069;\n    float mutator2 = 3.14159;\n    \n    float val3 = value0 * value1 * value2;\n    \n    return vec3(random(val3 - mutator0), random(val3 - mutator1), random(val3 - mutator2));\n}\n\nfloat flerp(float val0, float val1, float interpolator){\n    return ((1.0 - interpolator) * val0) + (interpolator * val1);\n}\n\nvec3 v3lerp(vec3 val0, vec3 val1, float interpolator){\n    float x = ((1.0 - interpolator) * val0.x) + (interpolator * val1.x);\n    float y = ((1.0 - interpolator) * val0.y) + (interpolator * val1.y);\n    float z = ((1.0 - interpolator) * val0.z) + (interpolator * val1.z);\n    return vec3(x,y,z);\n}\n\nfloat easeIn(float val){\n    return val * val;\n}\n\nfloat easeOut(float val){\n    return 1.0 - easeIn(1.0 - val);\n}\n\nfloat easeInOut(float val){\n    return flerp(easeIn(val), easeOut(val), val);\n}\n\nfloat gradientNoise(float value){\n    float decimal = fract(value);\n    float line0gradient = (random(floor(value)) * 2.0) - 1.0;\n    float line0point = line0gradient * decimal;\n    float line1gradient = (random(ceil(value)) * 2.0) - 1.0;\n    float line1point = line1gradient * (decimal - 1.0);\n    \n    return flerp(line0point, line1point, easeInOut(decimal));\n}\n\nfloat Perlin(vec2 value){\n    vec2 decimal = fract(value);\n    \n    vec2 x0y0direction = random2d(floor(value.x), floor(value.y)) * 2.0 - 1.0;\n    vec2 x0y1direction = random2d(floor(value.x), ceil(value.y)) * 2.0 - 1.0;\n    vec2 x1y0direction = random2d(ceil(value.x), floor(value.y)) * 2.0 - 1.0;\n    vec2 x1y1direction = random2d(ceil(value.x),ceil(value.y)) * 2.0 - 1.0;    \n    \n    float x0y0point = dot(x0y0direction, decimal - vec2(0.0,0.0));\n    float x0y1point = dot(x0y1direction, decimal - vec2(0.0,1.0));\n    float x1y0point = dot(x1y0direction, decimal - vec2(1.0,0.0));\n    float x1y1point = dot(x1y1direction, decimal - vec2(1.0,1.0));\n    \n    \n    float y0points = flerp(x0y0point, x1y0point, easeInOut(decimal.x));\n    float y1points = flerp(x0y1point, x1y1point, easeInOut(decimal.x));\n    float final = flerp(y0points, y1points, easeInOut(decimal.y));\n    \n    return final;\n}\n\nfloat Perlin3(vec3 value){\n    vec3 decimal = fract(value);//use the intergers as the grid... love this strategy\n    \n    //get some gradient vectors\n    vec3 x0y0z0direction = random3d(floor(value.x), floor(value.y), floor(value.z));\n    vec3 x0y0z1direction = random3d(floor(value.x), floor(value.y), ceil(value.z));\n    vec3 x0y1z0direction = random3d(floor(value.x), ceil(value.y), floor(value.z));\n    vec3 x0y1z1direction = random3d(floor(value.x), ceil(value.y), ceil(value.z));\n    vec3 x1y0z0direction = random3d(ceil(value.x), floor(value.y), floor(value.z));\n    vec3 x1y0z1direction = random3d(ceil(value.x), floor(value.y), ceil(value.z));\n    vec3 x1y1z0direction = random3d(ceil(value.x), ceil(value.y), floor(value.z));\n    vec3 x1y1z1direction = random3d(ceil(value.x), ceil(value.y), ceil(value.z));\n    \n    //interperet the vectors\n    float x0y0z0point = dot(x0y0z0direction, decimal - vec3(0.0,0.0,0.0));\n    float x0y0z1point = dot(x0y0z1direction, decimal - vec3(0.0,0.0,1.0));\n    float x0y1z0point = dot(x0y1z0direction, decimal - vec3(0.0,1.0,0.0));\n    float x0y1z1point = dot(x0y1z1direction, decimal - vec3(0.0,1.0,1.0));\n    float x1y0z0point = dot(x1y0z0direction, decimal - vec3(1.0,0.0,0.0));\n    float x1y0z1point = dot(x1y0z1direction, decimal - vec3(1.0,0.0,1.0));\n    float x1y1z0point = dot(x1y1z0direction, decimal - vec3(1.0,1.0,0.0));\n    float x1y1z1point = dot(x1y1z1direction, decimal - vec3(1.0,1.0,1.0));\n    \n    //lerp(smoothly) between the adjacent grids\n    float x0y0points = flerp(x0y0z0point, x0y0z1point, easeInOut(decimal.z));\n    float x0y1points = flerp(x0y1z0point, x0y1z1point, easeInOut(decimal.z));\n    float x1y0points = flerp(x1y0z0point, x1y0z1point, easeInOut(decimal.z));\n    float x1y1points = flerp(x1y1z0point, x1y1z1point, easeInOut(decimal.z));\n    \n    float x0points = flerp(x0y0points, x0y1points, easeInOut(decimal.y));\n    float x1points = flerp(x1y0points, x1y1points, easeInOut(decimal.y));\n    \n    float final = flerp(x0points, x1points, easeInOut(decimal.x));\n    \n    return final;\n}\n\nfloat bandRamp(float initialValue, float bandInterval){\n    float _out = initialValue;\n    float currentPos = 0.0;\n    float polarity = 1.0;\n    \n    for(currentPos = 0.0; currentPos <= 1.0; currentPos += bandInterval){\n        float dp = abs(initialValue - currentPos);\n        \n        if(initialValue > currentPos){\n            \n            switch(int(polarity)){\n                case 1:\n                _out = dp/bandInterval;\n                //col = v3lerp(col3, col4, easeInOut(dp/bandInterval));\n                break;\n                case -1:\n                _out = (1.0 - dp/bandInterval);\n                //col = v3lerp(col3, col4, easeInOut(1.0 - (dp/bandInterval)));\n                break;\n            };\n        };\n        \n        polarity *= -1.0;\n    };\n    \n    return(_out);\n}\n\nvec3 colourRamp(float value){\n    //set up some colours\n    vec3 col0 = vec3(1.0,1.0,1.0);//white\n    vec3 col1 = vec3(0.204,0.306,0.255);//dark green\n    vec3 col2 = vec3(0.733,0.835,0.557);//light green\n    vec3 col3 = vec3(0.15,0.0,0.0);//dark red\n    vec3 col4 = vec3(0.45, 0.0, 0.0);//less dark red\n    vec3 col5 = vec3(0.75,0.05,0.0);//orange\n    vec3 col6 = vec3(0.1, 0.0, 0.0);//very dark red\n    vec3 col7 = vec3(0.0,0.0,0.0);//black\n    vec3 col8 = vec3(0.3, 0.0, 0.0);//another red\n    \n    vec3 _out = col6;\n    \n    float interpolator = 0.0;\n    \n    float point0 = 0.8;\n    float point1 = 0.4;\n    float point2 = 0.1;\n    float point3 = 0.025;\n    \n    if(value > point0){\n        interpolator = (value - point0)/(1.0 - point0);\n        _out = v3lerp(col4, col5, interpolator);\n    } else if(value > point1){\n        interpolator = (value - point1)/(point0 - point1);\n        _out = v3lerp(col8, col4, interpolator);\n    } else if (value > point2){\n        interpolator = (value - point2)/(point1 - point2);\n        _out = v3lerp(col3, col8, interpolator);\n    }else if (value > point3){\n        interpolator = (value - point3)/(point2 - point3);\n        _out = v3lerp(col6, col3, interpolator);\n    }else{\n        interpolator = value/point1;\n        _out = v3lerp(col7, col6, interpolator);\n    };\n    \n    \n    \n    return _out;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv_up = vec2(fragCoord.x, fragCoord.y - 1.0)/iResolution.xy;\n    float frequency = 0.1;\n    float x = (uv.x + 20.0) * frequency; //the 20s are just coz the origin point is a lil uniform\n    float y = (uv.y + 20.0) * frequency * 2.0;\n    y -= iTime/15.0;\n    float y2 = (uv_up.y + 20.0) * frequency * 2.0;\n    float z = iTime/100.0;//varying z coord for more wiggles\n    //z = 0.0;\n    \n    //values for tweaking settings\n    float warpIntensity = 20.0;\n    \n    //grab a perlin noise value for this uv coord (ranges -0.5 to 0.5)\n    float perlinValue = Perlin3(vec3(x,y,z)) + 0.5;\n    //perlinValue *= 2.0;\n    //we can play some games with the perlin value to make everything look interestinger\n    float adjustedValue = bandRamp(perlinValue, 0.03);\n    \n    adjustedValue = easeInOut(adjustedValue);\n    adjustedValue = (adjustedValue - 0.5) * 2.0;\n    \n    //resample the texture from an offset provided by the perlin algorythm\n    vec2 uv_2 = vec2(fragCoord.x, fragCoord.y + (adjustedValue * warpIntensity))/iResolution.xy;\n    \n    \n    // sample from the offset position provided by perlin filter\n    vec3 col = texture(iChannel0, uv_2).rgb;\n    \n    //col = vec3(adjustedValue, adjustedValue, adjustedValue);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}