{"ver":"0.1","info":{"id":"7t3fW4","date":"1663084842","viewed":82,"name":"Polar Coordinate Curvature","username":"romeosoft","description":"Changes in the angular extent of the polar coordinate system produce the curvature of the poles.\nInstead of tensors, I use a coordinate system of my own design to calculate the curvature.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["curvature","coordinatesystem"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n                          .-''--.\n                         _`>   `\\.-'<\n                      _.'     _     '._\n                    .'   _.='   '=._   '.\n                    >_   / /_\\ /_\\ \\   _<\n                      / (  \\o/\\\\o/  ) \\\n                      >._\\ .-,_)-. /_.<\n                          /__/ \\__\\\n                            '---'  \n            \n          “If I can’t picture it, I can’t understand it.”\n*/\n// Changes in the angular extent of the polar coordinate system produce the curvature of the pole.\n// Instead of tensors, I use a coordinate system of my own design to calculate the curvature.\n// Although it is likely to fail(99.9% to fail :-D), but if it succeeds, tensor operations can be greatly simplified, \n// and may allow us to calculate General Relativity directly!\n// So why not have a try?\n\n#define real float\n#define ROT(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n#define pi 3.1415926535\n// ---------------------------------------------------------\n// Coordinate System:\n// A coordinate system in two-dimensional space \n// consists of an origin plus two orientation axes \n// ---------------------------------------------------------\nstruct coord2\n{\n   vec2 ux,uy;   // two axial unit vectors\n   float s;      // scaling[opt]\n   vec2 o;       // origin\n};\n// mul: define a vector in a coordinate system or transform a vector\nvec2 coord_mul (vec2 p, coord2 c)\n{\n\treturn c.ux * (p.x*c.s) + c.uy * (p.y*c.s) + c.o;\n}\n// \ncoord2 coord_mul2 (coord2 c1, coord2 c2)\n{\n    coord2 rc;\n    rc.ux = c1.ux * c2.ux.x + c1.uy * c2.ux.y;\n    rc.uy = c1.ux * c2.uy.x + c1.uy * c2.uy.y;\n    rc.s = c1.s * c2.s;\n    //rc.o = c1.o + c1.ux * c2.o.x + c1.uy * c2.o.y;\n    return rc;\n}\n// div: measure a vector in a coordinate system\nvec2 coord_div (vec2 p, coord2 c)\n{\n    vec2 v = p - c.o;\n    return vec2(dot(v,normalize(c.ux))/c.s, dot(v,normalize(c.uy))/c.s);\n}\ncoord2 coord_div2 (coord2 c1, coord2 c2)\n{\n    coord2 rc;\n    rc.ux = vec2(dot(c1.ux, normalize(c2.ux)), dot(c1.ux, normalize(c2.uy)));\n    rc.uy = vec2(dot(c1.uy, normalize(c2.ux)), dot(c1.uy, normalize(c2.uy)));\n    rc.o = c1.o - c2.o;\n    rc.s = c1.s/c2.s;\n    return rc;\n}\n// sub\ncoord2 coord_sub (coord2 c1, coord2 c2)\n{\n    coord2 rc;\n    rc.ux = c1.ux - c2.ux;\n    rc.uy = c1.uy - c2.uy;\n    rc.o = c1.o - c2.o;\n    rc.s = 1.;\n    return rc;\n}\n// Eigen vector just like matrix\nvec2 eigenvec(coord2 c)\n{\n    return (c.ux + c.uy) * c.s;\n}\n\n// Polar Coordinate Differential\nvoid polar_coord(out coord2 c1, float x, float y)\n{\n    //y /= 2.0*pi; // change the angle\n\tc1.ux = vec2((cos(y)), (sin(y)));\n\tc1.uy = vec2(x*(-sin(y)), x*cos(y));\n    c1.s = 1.;\n    c1.o = vec2(0.0,0.0);\n}\n// ---------------------------------------\n// mainImage\n// ---------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy - vec2(0.5,0.5)) * 2.0;\n\n    float deta = 0.01; // delta\n    coord2 c11;\n    polar_coord(c11, uv.x, uv.y); // uv.x = r, uv.y = theta\n    \n    coord2 c21;\n    polar_coord(c21, uv.x + deta, uv.y);\n    coord2 grad12 = coord_div2(c21, c11);\n    \n    coord2 c12;\n    polar_coord(c12, uv.x, uv.y + deta);\n    coord2 grad21 = coord_div2(c12, c11);\n    \n    coord2 g12 = coord_mul2(grad12,grad21);\n    coord2 g21 = coord_mul2(grad21,grad12);\n    \n    coord2 R = coord_sub(g12, g21); // related to curvature\n    \n    vec3 col = vec3(1.-cos(eigenvec(R)/(deta)), 0.0);// green for curvature.\n    \n    // Show Polar Coordinate Differential in the background.\n    vec2 deta_polar_coord = cos(coord_mul(uv, c11) * 40.0);//cos(coord_div(uv, c11) * 40.0);\n    col += vec3(deta_polar_coord.x, 0.0, deta_polar_coord.y)*0.2;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}