{"ver":"0.1","info":{"id":"fsB3zR","date":"1617296136","viewed":86,"name":"avoodoocado_raymarcher_truchet","username":"avoodoocado","description":"Raymarcher ","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat hash21(vec2 p)\n{\n    p = fract(p * vec2(231.443, 641.431));\n    p += dot(p, p+32.54);\n    return mod(fract(p.x*p.y), 1.0);\n}\n\nstruct Hit\n{\n    float dist;\n    vec3 normal;\n    vec3 color;\n};\n\nfloat distSphere(vec3 r, vec3 pos, float rad)\n{\n    return distance(pos, r) - rad;\n}\n\nHit distPlane(vec3 r, vec3 pos, vec3 normal)\n{\n    Hit hit;\n    hit.dist = r.y - pos.y;\n    hit.color = texture(iChannel2, r.xz).rgb;\n    hit.normal = texture(iChannel2, r.xz).rgb;\n    return hit;\n}\n\nHit distTruchet(vec3 r)\n{\n    vec2 f = mod(r.xz, 1.0);\n    vec2 id = floor(r.xz);\n    \n    if(hash21(id) > 0.5)\n        f.x = 1.0 - f.x;\n\n/*\n    vec2 c2d = vec2(0.5);\n    float dist = length(f - c2d);\n    c2d = c2d + normalize(f-c2d) * min(0.3, dist);\n    */\n    \n   \n    bool flipTriangle = (f.x + f.y >= 1.0);\n    bool flipSquare = (mod(id.x + id.y, 2.0) >= 1.0);\n\n    vec2 c2d = vec2(0.0);\n    c2d = vec2(flipTriangle ? 1 : 0);\n    \n    c2d = c2d + 0.5*normalize(f - c2d);\n\n    vec3 c3d = vec3(c2d.x, 0.0, c2d.y);\n    vec3 p = vec3(f.x, r.y, f.y);\n\n    vec3 color = vec3(1);\n\n    float a = 0.2*iTime;\n    \n    \n    vec2 uv = f;\n    if(flipTriangle)\n        uv = 1.0 - uv;\n        \n    uv =         \n        vec2(mod(2.0/3.1415 * (flipSquare?-1.0:1.0) * atan(uv.x/uv.y)+a, 1.0), \n            0.5 + 0.5 * 2.0/3.1415* asin(normalize(p-c3d).y));\n\n    vec2 tile = vec2(1.0, 0.5);\n\n    uv *= tile;\n\n    \n    float width = 0.1;\n    \n    color = texture(iChannel1, uv).rgb;\n\n    Hit hit;\n    \n    hit.dist = length(p-c3d) - width;\n    hit.normal = color;\n    hit.color = color;\n        \n    return hit;       \n}\n\nHit dist(vec3 r)\n{\n    Hit t0 = distTruchet(r);\n    //return t0;\n    Hit p0 = distPlane(r, vec3(0, -0.1, 0), vec3(0,1,0));\n    if(t0.dist < p0.dist)\n        return t0;\n    else return p0;\n}\n\nbool ray(vec3 r0, vec3 rd, float len, out vec3 pos, out vec3 normal, out float mind, out vec3 color)\n{ \n   vec3 r = r0;\n\n    Hit hit;\n     mind = len;\n    for(int i=0; i<100;i++)\n    {\n        hit = dist(r);\n        float d = hit.dist;\n        \n        if(mind > d)\n        mind = d;\n        \n        if(d < 0.005)\n        {\n            pos = r;\n            \n            normal = normalize(vec3(\n                dist(r+vec3(0.001,0,0)).dist,\n                dist(r+vec3(0,0.001,0)).dist,\n                dist(r+vec3(0,0,0.001)).dist) - d);\n           \n            normal = normalize(normal + 1.0*(hit.normal-0.5));\n\n            color = hit.color;\n            return true;\n        }\n        d = min(0.2, d);\n        r += rd * d;\n        if(distance(r, r0) > len)\n            return false;\n    }\n\n   return false;\n   \n}\n\nvec3 lightDir(vec3 pos, vec3 normal, vec3 color, vec3 ldir, vec3 lcol)\n{\n    vec3 spos;\n    vec3 snormal;\n    vec3 rd = -ldir;\n    float mind;\n    float start = 0.2;\n    float dist = 100.0;\n    vec3 dummy_color;\n    ray(pos+ rd*start,rd, dist, spos, snormal, mind, dummy_color);\n    \n    ldir = normalize(ldir);\n    vec3 reflected = normalize(reflect(ldir, normal));\n    \n    float shadow = smoothstep(.001,start,mind);\n\n    return vec3(shadow) * lcol * \n        (4.0*pow(max(0.0,dot(reflected, -ldir)), 12.0) +\n         (0.3+1.0*max(0.0,dot(normal, -ldir))) * color);\n}\n\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy/2.0)/iResolution.xx;\n    vec2 mouse = (iMouse.xy-iResolution.xy/2.0)/iResolution.xx;\n    float height = fragCoord.y/iResolution.y;\n\n    vec3 r0 = vec3(0,0,-1);\n    vec3 rd = vec3(uv,0) - r0;\n\n    rd = normalize(rd);\n\n    //mat4 m0 = rotationMatrix(vec3(0,1,0), -2.0*mouse.x);\n    mat4 m0 = rotationMatrix(vec3(0,1,0), 0.05*iTime);\n    //mat4 m1 = rotationMatrix(vec3(1,0,0), -2.0*mouse.y);\n    mat4 m1 = rotationMatrix(vec3(1,0,0), -.3);\n\n\n    r0 = (m1 * vec4(r0,1.0)).xyz;\n    rd = (m1 * vec4(rd,1.0)).xyz;\n\n    r0.z += -10.0 + 1.0*sin(0.5*iTime);\n    r0.y += 0.5;\n\n    r0 = (m0 * vec4(r0,1.0)).xyz;\n    rd = (m0 * vec4(rd,1.0)).xyz;\n\n    vec3 background = vec3(0.5, 0.5, 0.6);\n    vec3 col = background;\n    vec3 pos = vec3(0);\n    vec3 normal = vec3(0);\n    float mind;\n    if(ray(r0, rd, 100.0, pos, normal, mind, col))\n    { \n        col = lightDir(pos, normal, col, vec3(-1,-1,0), vec3(1.0));\n        col = mix(col, background, smoothstep(1.0, 10.0, length(pos-r0)));\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}