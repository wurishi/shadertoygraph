{"ver":"0.1","info":{"id":"Dss3D2","date":"1666867447","viewed":161,"name":"Arrow SDF L1, L2, Linf","username":"Envy24","description":"Use mouse to drag arrow pointer.\n\nOther arrows:\nhttps://www.shadertoy.com/view/4s23DG\nhttps://www.shadertoy.com/view/4tXyDn\nhttps://www.shadertoy.com/view/ldlSWj","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["sdf","distance","field","function","arrow","l1","l2","linf"],"hasliked":0,"parentid":"ddfGz2","parentname":"Distance field coloring"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define NZMX                      ( (iMouse.x+iMouse.x-R.x) / R.x )  // in range [-1.0; 1.0]\n#define NZMY                      ( (iMouse.y+iMouse.y-R.y) / R.y )  // in range [-1.0; 1.0]\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define FIELD_SCALE                 2.0\n#define PI                          3.1415926535897932\n\n/* L1 metric *\n#define METRIC(B, E) ( L1(B, E) )\n#define SEGMENT(P, B, E, R) ( segmentSDF_L1(P, B, E, R) )\n/* L2 metric */\n#define METRIC(B, E) ( L2(B, E) )\n#define SEGMENT(P, B, E, R) ( segmentSDF_L2(P, B, E, R) )\n/* Linf metric *\n#define METRIC(B, E) ( Linf(B, E) )\n#define SEGMENT(P, B, E, R) ( segmentSDF_Linf(P, B, E, R) )\n/**/\n\n#define ARROW(NDC, B, E, size) ( arrowSDF(NDC, B, E, size) )\n#define BEGIN ( LMB_IS_HOLD == true ? vec2(0) : rotateAroundZ(vec2(-1, 0), iTime*0.1) )\n#define END   ( LMB_IS_HOLD == true ? TO_CENTERED_NDC(iMouse.xy)*FIELD_SCALE : rotateAroundZ(vec2(1, 0), iTime*0.1) )\n#define R_    ( sinOSC(0., 0.1, iTime) )\n// Points after point E.\n// Calculates 3 segmentsSDF against 4 in prev version, but works slower, why?\nfloat arrowSDF2(\n    in vec2 NDC,\n    in vec2 B,\n    in vec2 E,\n    in float R)\n{\n    float len = length(B-E);\n    vec2 dir = len < 1e-7 ? vec2(1,0) : normalize(E-B),\n         //up = cross(vec3(dir, 0.), vec3(0, 0, -1)).xy,\n         up = vec2(-dir.y, dir.x),\n         C = E - dir * 0.1375,\n         U = C + up  * 0.10 * (dot(NDC, up) < 0. ? -1. : 1.);\n         E += dir * 0.1375;\n    \n    vec3 BARY = inverse(mat3(\n            U.x, U.y, 1.0,\n            C.x, C.y, 1.0,\n            E.x, E.y, 1.0)) * vec3(NDC.x, NDC.y, 1.0);\n    \n    float sign = \n        BARY.x >= 0.0 &&    \n        BARY.y >= 0.0 && \n        BARY.z >= 0.0 ?  // inside triangle?\n            -1. : 1.;\n    \n    float d = SEGMENT(NDC, U, C, 0.);\n          d = min(d, SEGMENT(NDC, U, E, 0.));\n          d = \n              len < 0.1375 ? \n                  d :\n                  min(d, SEGMENT(NDC, B, C, 0.));\n    \n    return sign*d-R;           \n}\n// Points after point E.\nfloat arrowSDF(\n    in vec2 NDC,\n    in vec2 B,\n    in vec2 E,\n    in float R)\n{\n    float len = length(B-E);\n    vec2 dir = len < 1e-7 ? vec2(1,0) : normalize(E-B),\n         //up = cross(vec3(dir, 0.), vec3(0, 0, -1)).xy,\n         up = vec2(-dir.y, dir.x),\n         C = E - dir * 0.1375, //      U--\n         U = C + up  * 0.10,   // B----C--E--E'\n         D = C - up  * 0.10;   //      D--\n         E += dir * 0.1375;\n    \n    vec3 BARY = inverse(mat3(\n            U.x, U.y, 1.0,\n            D.x, D.y, 1.0,\n            E.x, E.y, 1.0)) * vec3(NDC.x, NDC.y, 1.0);\n    \n    float sign = \n        BARY.x >= 0.0 &&    \n        BARY.y >= 0.0 && \n        BARY.z >= 0.0 ?  // inside triangle?\n            -1. : 1.;\n    \n    float d = SEGMENT(NDC, U, D, 0.);\n          d = min(d, SEGMENT(NDC, U, E, 0.));\n          d = min(d, SEGMENT(NDC, D, E, 0.));\n          d = \n              len < 0.1375 ? \n                  d :\n                  min(d, SEGMENT(NDC, B, C, 0.));\n    \n    return sign*d-R;           \n}\n// Points exactly at point E.\nfloat arrowSDF_old(\n    in vec2 NDC,\n    in vec2 B,\n    in vec2 E,\n    in float R)\n{\n    float len = length(B-E);    \n    vec2 dir = normalize(E-B),\n         //up = cross(vec3(dir, 0.), vec3(0, 0, -1)).xy,   \n         up = vec2(-dir.y, dir.x),\n         C = E - dir * 0.275, //      U--\n         U = C + up  * 0.10,  // B----C----E\n         D = C - up  * 0.10;  //      D--\n    \n    vec3 BARY = inverse(mat3(\n            U.x, U.y, 1.0,\n            D.x, D.y, 1.0,\n            E.x, E.y, 1.0)) * vec3(NDC.x, NDC.y, 1.0);\n    \n    float sign = \n        BARY.x >= 0.0 &&    \n        BARY.y >= 0.0 && \n        BARY.z >= 0.0 ?  // inside triangle?\n            -1. : 1.;\n    \n    float d = SEGMENT(NDC, U, D, 0.);\n          d = min(d, SEGMENT(NDC, U, E, 0.));\n          d = min(d, SEGMENT(NDC, D, E, 0.));\n          d = \n              len < 0.275 ? \n                  d :\n                  min(d, SEGMENT(NDC, B, C, 0.));\n    \n    return sign*d-R;           \n}\n\nvec3 colorize_field(float dist, vec3 color)\n{    \n    float F = 30., freq = F*dist, aa = 1./F, C = 0.7, amp = 0.2, width = 0.3,\n          curves_sdf = C + amp*smoothstep(4./R.y, 0., (width+cos(freq)) * aa),\n          exp_raise = 1. - exp(-4.*abs(dist));\n        \n    color = 1.0 - sign(dist) * color; // Change color if dist is negative. \n    color *= exp_raise;               // Attenuate color around edges.     \n    color *= curves_sdf;              // Add interleaved curves.\n    \n    return mix(color, vec3(1), smoothstep(6./R.y, 0., abs(dist)) );\n}\n\nvec3 add_metric_function(\n    vec2 NDC,\n    vec3 color)\n{\n    float unit = 7.0 / R.y;\n    vec2 M = rotateAroundZ(vec2(1, 0), iTime * 0.5) * 1.5;\n\n    // Add point\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(NDC - M) - 0.008));\n\n    float dist_form_point_to_box_edge = METRIC(NDC, M) - abs(ARROW(M, BEGIN, END, R_));\n    float outline = abs(dist_form_point_to_box_edge);\n    \n    // Add metric function\n    return mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, outline));\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = TO_CENTERED_NDC(SC) * FIELD_SCALE;\n    float minDist = ARROW(NDC, BEGIN, END, R_);\n    \n    vec3 color = vec3(0.15, 0.33, 0.95);\n    \n    color = colorize_field(minDist, color); \n    color = add_metric_function(NDC, color);\n    //color = mix( vec3(0), vec3(1), smoothstep(4./R.y, 0., minDist));\n\n    O = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nvec2 rotateAroundZ(vec2 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec2(\n        p.x * c - p.y * s,\n        p.y * c + p.x * s);\n}\n\nfloat L1(vec2 B, vec2 E)\n{\n    vec2 D = E - B;\n    return abs(D.x) + abs(D.y);\n}\n\nfloat L2(vec2 B, vec2 E)\n{\n    vec2 D = E - B;\n    return sqrt(D.x*D.x + D.y*D.y);\n}\n\nfloat Linf(vec2 B, vec2 E)\n{\n    vec2 D = E - B;\n    return max(abs(D.x), abs(D.y));\n}\n\n#define P(t) (S + (E - S)*t)\nfloat segmentSDF_L1(\n    vec2 NDC,\n    vec2 S,\n    vec2 E,\n    float R)\n{\n    float invD0 = 1.0 / (S.y-E.y);\n    return min(L1(P(clamp((NDC.x-S.x) / (E.x-S.x), 0.0, 1.0)), NDC), \n               min(L1(P(clamp((NDC.y+S.y) * invD0, 0.0, 1.0)), NDC),\n                   L1(P(clamp((S.y-NDC.y) * invD0, 0.0, 1.0)), NDC))) - R;\n}\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E,\n    float R)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - R;\n}\n\nfloat segmentSDF_Linf(\n    vec2 NDC,\n    vec2 S,\n    vec2 E,\n    float R)\n{\n    return min(Linf(P(clamp((S.y-S.x+NDC.x-NDC.y)/(E.x-S.x+S.y-E.y), 0.0, 1.0)), NDC), \n               Linf(P(clamp((S.y-NDC.y+S.x-NDC.x)/(S.x-E.x+S.y-E.y), 0.0, 1.0)), NDC)) - R;\n}","name":"Common","description":"","type":"common"}]}