{"ver":"0.1","info":{"id":"DlK3Wt","date":"1693491768","viewed":43,"name":"Raymarching.Template","username":"medley","description":"A raymarching template.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","template"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/***********************************************************\nThis is a basic template for an SDF-based GPU ray marcher.\nDefining any specific SDFs is left up to the developer.\nComments are provided to explain the function of the code.\nFeel free to use this wherever you see fit :)\n***********************************************************/\n\n// Here are some controls over the raymarcher.\n#define HIT_THRESH 0.005\n#define RAYMARCH_ITER 256\n\n#define PI 3.14159265358979\n\n// Represents the material of an in-world object.\nstruct Material\n{\n    vec3 albedo;\n    vec3 ambient;\n};\n\n\nMaterial mats[3] = Material[3](\n    Material(vec3(0.2,0.7,0.9),vec3(0.1,0.2,0.3)),\n    Material(vec3(0.9,0.9,0.9),vec3(0.2,0.2,0.2)),\n    Material(vec3(0.9,0.7,0.3),vec3(0.3,0.1,0.0))\n);\n\n/**\n * The signed distance field of a sphere.\n * Source: Inigo Quilez\n *\n * @param p The center point of the sphere\n * @param s The radius of the sphere\n * @return The distance to the sphere\n */\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n/**\n * Find the closer object\n *\n * @param o1 The first object to compare\n * @param o2 The second object to compare\n * @return A two-component vector containing the distance\n *         to and material of the closer object\n */\nvec2 minObj( vec2 o1, vec2 o2 )\n{\n    float d = min(o1.x,o2.x);\n    float m = o1.y * float(o1.x<o2.x) +\n              o2.y * float(o2.x<o1.x);\n    return vec2(d,m);\n}\n\n/**\n * Get the signed distance to the scene at a given point,\n * as well as the material of the closest object.\n * \n * @param pos The point to evaluate the distance at\n * @return A two-component vector containing scene\n *         distance and material index\n */\nvec2 map( vec3 pos )\n{\n    float ds = sdSphere(pos - vec3(0.0,2.0,0.0),0.5);\n    //return vec2(pos.y,1.0);\n    return minObj(vec2(ds,2.0),vec2(pos.y,1.0));\n}\n\n/**\n * Get the normal of the scene at the given point.\n * Source: Envy24 (see comments)\n *\n * @param p The point at which to evaluate the normal\n * @return The normal of the scene as a vec3\n */\nvec3 calcNormal(in vec3 P)\n{\n    const float delta = .01;          \n    // Sample distance function at hit point and three nearby points.\n    float s0 = map(P).x,\n          s1 = map(P + vec3(delta, 0, 0)).x,\n          s2 = map(P + vec3(0, delta, 0)).x,\n          s3 = map(P + vec3(0, 0, delta)).x;\n    // Calculate finite differencies.    \n    float dfdx = s1 - s0,\n          dfdy = s2 - s0,\n          dfdz = s3 - s0;\n    // Approximate gradient/normal direction.\n    return normalize(vec3(dfdx, dfdy, dfdz));\n}\n\n\n/**\n * Get the position at which a given ray intersects the scene,\n * as well as the proper material.\n *\n * @param ro   The ray origin\n * @param rd   The ray direction\n * @param tmin The near clipping plane, or minimum distance the ray must travel\n * @param tmax The far clipping plane, or maximum distance the ray can travel\n * @return A two-component vector containing the traveled\n *         distance and the material of the object hit\n */\nvec2 castRay( vec3 ro, vec3 rd, float tmin, float tmax )\n{\n    float t = tmin; // Start at the near plane\n    float m = 0.0;\n    \n    // March the ray along its direction\n    for (int i = 0; i < RAYMARCH_ITER; i++)\n    {\n        // Evaluate the distance to the scene\n        vec2 d = map(ro+rd*t);\n        \n        // Advance t according to the distance\n        t += d.x;\n        \n        // Unadvance and stop evaluating if we're below the hit threshold\n        t -= d.x * float(d.x < HIT_THRESH);\n        i += RAYMARCH_ITER * int(d.x < HIT_THRESH);\n        m = d.y * float(d.x < HIT_THRESH);\n        \n        // Stop evaluating if the t value exceeds the maximum\n        i += RAYMARCH_ITER * int(t > tmax);\n    }\n    \n    return vec2(t,m);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinate space\n    vec2 screen = fragCoord / iResolution.xy;\n    \n    // Better coordinate space\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    // Clipping planes\n    float near = 0.5;\n    float far = 100.0;\n    \n    // Set up camera and cast the ray\n    vec3 cam = vec3(0.0,2.0,-1.5);\n    vec3 dir = normalize(vec3(p,1.0));\n    vec2 res = castRay(cam, dir, near, far);\n    \n    Material mat = mats[int(res.y)];\n    \n    // Initial color albedo\n    vec3 col = mat.ambient;\n    \n    if ( res.y == 0.0 )\n    {\n        // Only use albedo for sky\n        col = mat.albedo;\n        \n        // Sky shading\n        col += vec3(1.0) * smoothstep(0.75,1.5,1.0-p.y);\n    }\n    else\n    {\n        // Ambient color\n        col = mat.ambient;\n        \n        vec3 norm = calcNormal(cam+dir*res.x);\n        \n        // Lit color\n        vec3 ld = normalize(vec3(1.0,1.0,-1.0)); // Light dir\n        vec3 lc = vec3(0.8,0.7,0.5); // Light color\n        col += mat.albedo * lc * clamp(dot(norm,ld),0.0,1.0);\n        \n        // Bounce lighting\n        float bc = 0.15; // Bounce coefficient\n        col += mat.albedo * lc * (bc * clamp(dot(norm,-ld),0.0,1.0));\n        \n        // Sky lighting\n        vec3 scol = mats[0].albedo;\n        float scoef = 0.1;\n        col += scol * scoef\n                    * clamp(dot(norm,vec3(0.0,1.0,0.0)),0.0,1.0);\n    }\n    \n    // Gamma correction\n    col = pow(col,vec3(1.0/2.2));;\n    \n    // Normal preview\n    // col = calcNormal(cam+dir*res.x) * 0.5 + 0.5;\n    \n    // Final color\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}