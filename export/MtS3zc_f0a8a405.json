{"ver":"0.1","info":{"id":"MtS3zc","date":"1431138148","viewed":238,"name":"Robot Maze","username":"hypothete","description":"AI Labyrinth","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raycasting","distf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//thx iq for distance functions: https://iquilezles.org/articles/distfunctions\n\nstruct camera {\n    vec3 position;\n    vec3 direction;\n};\n\nconst vec3 worldUp = vec3(0.0,-1.0,0.0);\nconst float minStep = 0.1;\nconst float maxStep = 90.0;\nconst float delta = 0.01;\nconst float damping = 0.9;\nconst int numSteps = 99;\n\nmat3 getViewMatrix (vec3 t, vec3 d, vec3 k)\n{\n\tvec3 z = normalize(d);\n    vec3 x = normalize(cross(d,k));\n    vec3 y = normalize(cross(z,x));\n    return mat3(x,y,z);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return q ;\n}\n\nfloat distf (vec3 pos)\n{\n    pos = opRep(pos, vec3(2.0));\n    float boxes = sdBox(pos, vec3(0.5));\n    \n    boxes = min(boxes, sdBox(pos+vec3(0.75,0,0), vec3(0.25)));\n    boxes = min(boxes, sdBox(pos+vec3(-0.75,0,0), vec3(0.25)));\n    \n    boxes = min(boxes, sdBox(pos+vec3(0,0.75,0), vec3(0.25)));\n    boxes = min(boxes, sdBox(pos+vec3(0,-0.75,0), vec3(0.25)));\n    \n    boxes = min(boxes, sdBox(pos+vec3(0,0,0.75), vec3(0.25)));\n    boxes = min(boxes, sdBox(pos+vec3(0,0,-0.75), vec3(0.25)));\n    return boxes;\n}\n\nvec3 normal (vec3 p)\n{\n    vec2 dm = vec2(delta, 0.0);\n\treturn normalize(vec3(\n    \tdistf(p+dm.xyy) - distf(p-dm.xyy),\n        distf(p+dm.yxy) - distf(p-dm.yxy),\n        distf(p+dm.yyx) - distf(p-dm.yyx)\n    ));\n}\n\nfloat castRay ( vec3 pos, vec3 dir, out vec3 norm)\n{\n    float dist = minStep;\n    for(int step = 0; step < numSteps; step++)\n    {\n        norm = pos + dir*dist;\n        float normL = distf(norm);\n        if(normL > delta || dist > maxStep){\n            dist += normL*damping;\n        }\n    }\n    return dist;\n}\n\nvec4 render(in vec2 xy)\n{\n    \n    camera myCam = camera( \n    \tvec3(0,0,2.*iTime),\n   \t\tvec3(iMouse.x/iResolution.x*3.0-1.5,iMouse.y/iResolution.y*3.0-1.5,1.0)\n\t);\n    \n    mat3 viewMatrix = getViewMatrix(myCam.position, myCam.direction, worldUp);\n\tvec3 rayDir = viewMatrix * normalize(vec3(xy, 1.0));\n    vec3 ro = vec3(0.0,0.0,0.0);\n    float didHitTerrain = castRay(myCam.position, rayDir, ro);\n    if(didHitTerrain < maxStep){\n        vec4 colToRtn = vec4(vec3(0.5),1.0);\n        vec3 nml = normal(ro);\n        vec3 textureRGB = texture(iChannel0,cross(nml,myCam.direction).xz).xyz;\n        colToRtn.xyz = textureRGB * 5./distance(myCam.position, ro); //* cross(nml,vec3(0,1,0.5));\n        return colToRtn;\n    }\n    else{\n    \treturn vec4(0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xx - 0.5;\n    fragColor = render(uv);\n}","name":"Image","description":"","type":"image"}]}