{"ver":"0.1","info":{"id":"3sjfzz","date":"1590250599","viewed":3792,"name":"Chladni plate simulation","username":"sidchou","description":"update: new version https://www.shadertoy.com/view/WlfyWn\nmy try of doing a Chladni plate simulation.\n\nany physics pro want to help me improve this dm me at ig @sid_100_days","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["simulation","physics","harmony","oscillations","chladniplate"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//new version https://www.shadertoy.com/view/WlfyWn\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec4 col = texture(iChannel3,uv);\n\n    // Output to screen\n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n#define PI 3.1415\nfloat generateWave(float d, float n);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float n = iTime/10.;\n    // n = 4.1;\n    int passes= 0;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -=.5;\n    float asp = iResolution.x/iResolution.y;\n    uv.x*=asp;\n    \n    //uv = abs(uv);\n\t//uv /= 2.;\n\t\n    //reset to 4 corner\n    //uv = vec2(0.5)-abs(uv);\n    //uv *= 2.;\n    \n    float d, col;\n    \n    const int samples = 30;\n  \n    //radio\n    col = 0.;\n\n  \n    for(int i = 0; i<samples; i++){\n            uv+=0.5;\n            uv.x-=(float(i)/float(samples));\n    \t\td = length(uv);\n   \t\t \tcol += generateWave(d, n);\n    \t\tpasses++;\n    \t\tuv-=0.5;\n\t\t\tuv.x+=(float(i)/float(samples));            \n     }\n\n    for(int i = 0; i<samples; i++){\n            uv-=0.5;\n            uv.x+=(float(i)/float(samples));\n    \t\td = length(uv);\n   \t\t \tcol += generateWave(d, n);\n    \t\tpasses++;\n    \t\tuv+=0.5;\n\t\t\tuv.x-=(float(i)/float(samples));            \n     }\n\n    for(int i = 0; i<samples; i++){\n            uv-=0.5;\n            uv.y+=(float(i)/float(samples));\n    \t\td = length(uv);\n   \t\t \tcol += generateWave(d, n);\n    \t\tpasses++;\n    \t\tuv+=0.5;\n\t\t\tuv.y-=(float(i)/float(samples));            \n    }\n\n    for(int i = 0; i<samples; i++){\n            uv+=0.5;\n            uv.y-=(float(i)/float(samples));\n    \t\td = length(uv);\n   \t\t \tcol += generateWave(d, n);\n    \t\tpasses++;\n    \t\tuv-=0.5;\n\t\t\tuv.y+=(float(i)/float(samples));            \n     }\n    \n/*\n    //liniar\n    uv -= 0.5;\n    d = length(uv.x);\n    col += generateWave(d, n);\n    passes++;\n    d = length(uv.y);\n    col += generateWave(d, n);\n    passes++;\n    uv += 0.5;\n    \n    uv += 0.5;\n    d = uv.x;\n    col += generateWave(d, n);\n    passes++;\n    d = uv.y;\n    col += generateWave(d, n);\n    passes++;\n    uv -= 0.5;\n  */ \n    \n    \n    \n\n    col /= float(passes);\n    //col /=4.;\n\t//col *= 2.;\n    //col -= 1.;\n    //col = abs(col);\n\t//col = 1.-col;\n    //col = vec4(vec2(uv),0.,0.);\n    \n    col = step(uv.x,.5)*step(-.5,uv.x)*col;\n\n    vec4 c = vec4(col*col);\n    \n    fragColor = c;\n}\n\nfloat generateWave(float d, float n){\n    //d += PI/2.;\n    d *= PI;\n    d *= 2.;\n    d *= n;\n    return 1.-abs(cos(d));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define PI 3.1415\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float n = iTime/20.;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -=.5;\n    float asp = iResolution.x/iResolution.y;\n    uv.x*=asp;\n    uv.y = step(uv.x,.5)*step(-.5,uv.x)*uv.y;\n   \tuv.x = step(uv.x,.5)*step(-.5,uv.x)*uv.x;\n    \n    //uv = abs(uv);\n\t//uv /= 2.;\n\t\n    uv = vec2(0.5)-abs(uv);\n    uv *= 2.;\n   \n    float d = length(uv);\n    \n    d += PI/2.;\n    d *= PI;\n    d *= 2.;\n    d *= n;\n    \n    \n    float d2 = length(uv.x+uv.y);\n    \n    d2 += PI/2.;\n    d2 *= PI;\n    d2 *= 2.;\n    d2 *= n;\n    \n    float d3 = length(uv.x-uv.y);\n    \n    d3 += PI/2.;\n    d3 *= PI;\n    d3 *= 2.;\n    d3 *= n;\n    \n    float d4 = uv.x;\n    \n    d4 += PI/2.;\n    d4 *= PI;\n    d4 *= 2.;\n    d4 *= n;\n    \n    float d5 = uv.y;\n    \n    d5 += PI/2.;\n    d5 *= PI;\n    d5 *= 2.;\n    d5 *= n;\n    \n    vec4 col = vec4((sin(d)*.5+.5));\n    col += vec4((sin(d2)*.5+.5));\n    col += vec4((sin(d3)*.5+.5));\n    col += vec4((sin(d4)*.5+.5));\n    col += vec4((sin(d5)*.5+.5));\n    col /= 5.;\n\tcol *= 2.;\n    col -= 1.;\n    col = abs(col);\n\tcol = 1.-col;\n    //col = vec4(vec2(uv),0.,0.);\n\n    \n    fragColor = col;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n#define PI 3.1415\nfloat generateWave(float d, float n);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float n = iTime/10.;\n    // n = 4.1;\n    int passes= 0;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -=.5;\n    float asp = iResolution.x/iResolution.y;\n    uv.x*=asp;\n    \n    float d, col;\n  \n\n    \n\t//radio\n    //edgecenter\n    uv+=vec2(0,0.5);\n    d = length(uv);\n   \tcol += generateWave(d, n);\n    passes++;\n    uv-=vec2(0,0.5);\n    \n    uv-=vec2(0,0.5);\n    d = length(uv);\n   \tcol += generateWave(d, n);\n    passes++;\n    uv+=vec2(0,0.5);\n    \n    uv+=vec2(0.5,0.);\n    d = length(uv);\n   \tcol += generateWave(d, n);\n    passes++;\n    uv-=vec2(0.5,0.);\n    \n    uv-=vec2(0.5,0.);\n    d = length(uv);\n   \tcol += generateWave(d, n);\n    passes++;\n    uv+=vec2(0.5,0.);\n    \n    //corner\n    uv+=0.5;\n    d = length(uv);\n   \tcol += generateWave(d, n);\n    passes++;\n    uv-=0.5;\n    \n    uv-=0.5;\n    d = length(uv);\n   \tcol += generateWave(d, n);\n    passes++;\n    uv+=0.5;\n    \n    uv+=vec2(0.5,-.5);\n    d = length(uv);\n   \tcol += generateWave(d, n);\n    passes++;\n    uv-=vec2(0.5,-.5);\n    \n    uv-=vec2(0.5,-.5);\n    d = length(uv);\n   \tcol += generateWave(d, n);\n    passes++;\n    uv+=vec2(0.5,-.5);\n    \n        int centerpasses = passes/2;\n    //center    \n    for(int i = 0; i<50; i++){\n       if(i > centerpasses){break;}\n    d = length(uv);\n   \tcol += generateWave(d, n)*length(uv);\n    passes++;\n    }\n    \n    /*\n    //linear\n    //edge\n    uv+=.5;\n    d = -uv.x;\n   \tcol += generateWave(d, n);\n    passes++;\n    d = -uv.y;\n   \tcol += generateWave(d, n);\n    passes++;\n    uv-=0.5;\n    \n    uv-=.5;\n    d = uv.x;\n   \tcol += generateWave(d, n);\n    passes++;\n    d = uv.y;\n   \tcol += generateWave(d, n);\n    passes++;\n    uv+=0.5;\n    \n    //corner\n    uv+=0.5;\n    d = uv.x+uv.y;\n   \tcol += generateWave(d, n);\n    passes++;\n    uv-=0.5;\n    \n    uv-=0.5;\n    d = uv.x+uv.y;\n    col += generateWave(d, n);\n    passes++;\n    uv+=0.5;\n    \n    uv+=vec2(0.5,-.5);\n    d =  -uv.x+uv.y;\n   \tcol += generateWave(d, n);\n    passes++;\n    uv-=vec2(0.5,-.5);\n    \n    uv-=vec2(0.5,-.5);\n    d = uv.x-uv.y;\n   \tcol += generateWave(d, n);\n    passes++;\n    uv+=vec2(0.5,-.5);\n    */\n    /*\n    centerpasses = (passes-centerpasses)/4;\n    //center    \n    for(int i = 0; i<50; i++){\n       if(i > centerpasses){break;}\n \td = uv.x+uv.y;\n\tcol += generateWave(d, n)*length(uv);\n    passes++;\n    d = uv.x-uv.y;\n\tcol += generateWave(d, n)*length(uv);\n    passes++;\n    d = uv.y;\n\tcol += generateWave(d, n)*length(uv);\n    passes++;\n    d = uv.x;\n\tcol += generateWave(d, n)*length(uv);\n    passes++;\n    }\n\t*/\n\n    col*=2.;\n    col /= float(passes);\n    //col /=4.;\n\t//col *= 2.;\n    //col -= 1.;\n    //col = abs(col);\n\t//col = 1.-col;\n    //col = vec4(vec2(uv),0.,0.);\n    \n    col = step(uv.x,.5)*step(-.5,uv.x)*col;\n\n    //vec4 c = vec4(step(col,0.)*col*col,step(0.,col)*col*col,0.,0.);\n    vec4 c = vec4(1.-abs(col));\n    //vec4 c = vec4(abs(col));\n    \n    fragColor = c;\n\n}\n\nfloat generateWave(float d, float n){\n    //d += PI/2.;\n    d *= PI;\n    d *= 2.;\n    d *= n;\n    return cos(d);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    float dt = .001 ;\n\n   float tex =  texture(iChannel2, fragCoord / vec2(iResolution)).r;\n    vec4 outcolor;\n       if (iFrame < 10) {\n        //init image\n        // inverse displacement map (but with numerical diffusion spuriously smoothing the map)\n        //outcolor = vec4(uv, 0, 0); \n        outcolor = vec4(tex);\n    } else {\n        //ivec2 ifc = ivec2(round(fragCoord)); \n\n        vec2 vxvy = vec2(texture(iChannel0, fragCoord / vec2(iResolution)));\n\n        vec2 newFragCoord = fragCoord - dt * vxvy * vec2(iResolution)*uv;\n\n        \n        outcolor = texture(iChannel1, newFragCoord / vec2(iResolution));\n    }\n    \n   \n   outcolor = mix(outcolor,vec4(tex),0.005);\n\n   outcolor = step(uv.x,.5)*step(-.5,uv.x)*outcolor;\n\n   outcolor = vec4(texture(iChannel0, fragCoord / vec2(iResolution)));\n\n\n   fragColor = outcolor;\n}","name":"Buffer D","description":"","type":"buffer"}]}