{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define ANIMATE\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nvec2 hash( vec2 p )\n{\n    p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn fract(sin(p)*43758.5453);\n}\nfloat julia(in vec4 p)\n{\n    const int ITR = 20;\n    vec2 z = p.xy; vec2 c = p.zw;\n    int idx = ITR;\n    for(int i = 0; i < ITR; ++i) \n    {\n        vec2 r = vec2((dot(z,z*vec2(1., -1.)))+c.x, \n                       dot(z.yx,z.xy)+c.y);\n        if(dot(r,r) > 4.)\n        {\n            idx = i;\n            break;\n        }\n        z = r;\n    }\n    float v = mod(float(idx), 50.) / 50.;\n    return length(z);\n}\nvec2 voronoi( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec2 m = vec2( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n        vec2 o = hash( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( .5*iTime + 6.2831*o );\n        #endif\t\n\t\tvec2 r = g - f + o;\n\t\tfloat d = dot(r,r);\n        if( d<m.x )\n        {\n            m.x = d;\n            m.y = hash( dot(n+g,vec2(7.0,113.0) ) );\n        }\n    }\n    return vec2( sqrt(m.x), m.y );\n}\n\n\n\nvec2 mpx(in vec2 p)\n{\n    float apc = iResolution.x/iResolution.y;\n    return vec2(2.5*apc, 2.5)*(p - vec2(.5));\n}\n\n//from: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = mpx(fragCoord.xy / iResolution.xy);\n    uv *= 1.25;\n    \n   \tvec3 col = vec3(0.); \n      \n    float j = julia(vec4(uv, vec2(sin(iTime*.1)*1.2)*voronoi(uv).xx ));\n    if(j < 2.) col += hsv2rgb(vec3((j/4.)+.15, 1., .8));\n    vec2 v = voronoi(uv);\n    col += hsv2rgb(vec3(v.y, 1., .3));\n    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdSSRR","date":"1408035117","viewed":170,"name":"Voronoi + Julia","username":"squid","description":"Playing with combining the Julia set with the Voronoi set, using iq's voronoi function. There could possibly be a better, more beautiful way, to do this","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","voronoi","julia"],"hasliked":0,"parentid":"","parentname":""}}