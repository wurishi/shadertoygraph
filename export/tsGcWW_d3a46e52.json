{"ver":"0.1","info":{"id":"tsGcWW","date":"1602869390","viewed":107,"name":"Moon Phases JLM","username":"vtgco","description":"test","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TWO_PI 6.2832\n\nbool ALIASED = false;\n\nfloat MOON_SIZE = 0.02;\nfloat BREATHING_ROOM = 0.01;\nfloat R_STEP;\n\nfloat ANTI_ALIAS_RADIUS;\nfloat ARC_ANTI_ALIAS_RADIUS;\n    \nfloat DISPLACEMENT_FACTOR;\n\nvoid setup() {\n    R_STEP = (MOON_SIZE + BREATHING_ROOM)*2.;\n    \n    float rel_moon_size = 0.02 / MOON_SIZE;\n    \n    ARC_ANTI_ALIAS_RADIUS = (0.05 * rel_moon_size);\n    ANTI_ALIAS_RADIUS = 1. - ARC_ANTI_ALIAS_RADIUS;\n    \n    ANTI_ALIAS_RADIUS *= MOON_SIZE;\n    \n    DISPLACEMENT_FACTOR = 0.01 / pow(rel_moon_size, 0.5);\n    \n}\n\nvec2 findClosestMoonCenter(vec2 point) {\n    \n    float r = length(point);\n    float theta = atan(point.y, point.x) + TWO_PI*float(point.y<0.);\n    \n    float new_r = (floor(r / R_STEP) + 0.5) * R_STEP;\n  \n    float THETA_STEP = TWO_PI / floor(new_r * TWO_PI / R_STEP);\n \n    float new_theta = (floor(theta / THETA_STEP) + 0.5) * THETA_STEP;\n    \n    \n    return vec2(cos(new_theta),sin(new_theta)) * new_r;\n}\n\n\n\nfloat withinMoon(vec2 point, vec2 center, float phase0) {  \n    vec2 p = point - center;\n    bool inside_circle = length(p) <= MOON_SIZE;\n    \n    if (!inside_circle) { return 0.0; }\n    \n    float phase = mod(phase0, 2.);\n    \n    bool color_on = false;\n    float brightness = 0.;\n    \n    bool on_dark_side = (p.x <= 0.) ^^ (phase >= 1.);\n    if (phase == 1.)\n    {\n        on_dark_side = true;\n    }\n    else if (phase == 0.) {\n        on_dark_side = false;\n    }\n    \n    bool crescent = abs(phase - 1.) <= 0.5;\n    \n    vec2 p_sub_arc = p;\n    p_sub_arc.x /= (0.5 - mod(phase, 1.)) * 2.;\n    \n    bool inside_arc = length(p_sub_arc) <= MOON_SIZE;\n\n    \n    if (crescent && (!on_dark_side && !inside_arc)) {\n        color_on = true;\n\t} \n\telse if (!crescent && (!on_dark_side || inside_arc)) {\n    \tcolor_on = true;\n\t}\n    \n    \n    if (color_on) {\n        float circle_brightness = smoothstep(MOON_SIZE, ANTI_ALIAS_RADIUS, length(p));\n        \n        float arc_brightness = 1.;\n        \n        if (on_dark_side ^^ crescent) \n        \tarc_brightness = smoothstep(0., ARC_ANTI_ALIAS_RADIUS, abs(length(p_sub_arc)-MOON_SIZE)/MOON_SIZE);\n        \n        brightness = min(circle_brightness, arc_brightness);\n        \n        if (ALIASED)\n            brightness = 1.;\n    }\n    \n    return brightness;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    setup();\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n     uv -= vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 closest_center = findClosestMoonCenter(uv);\n    \n    float new_theta = atan(closest_center.y, closest_center.x) + TWO_PI*float(closest_center.y<0.);\n    float new_r_index = (floor(length(closest_center) / R_STEP) + 0.5);\n    \n    float phase = new_theta*2./TWO_PI + new_r_index*0.25 + iTime * 0.25;\n    \n    vec3 col = vec3(0.0);\n\n    for (int i = -1; i < 2; i++) {\n        //vec2 displacement = vec2(new_r_index * new_r_index * float(i) * 0.00005;\n        vec2 displacement = float(i) * DISPLACEMENT_FACTOR * length(closest_center) * closest_center;\n        \n    \tfloat brightness = withinMoon(uv, closest_center - displacement, phase);\n        col[int(mod(3. + float(i), 3.))] += brightness;\n   \n    }\n    fragColor = vec4(col, 1.0);\n    \n}\n","name":"Image","description":"","type":"image"}]}