{"ver":"0.1","info":{"id":"XcG3Ww","date":"1712824120","viewed":44,"name":"3. Drawing Scanner animation","username":"nitish","description":"Playlist: https://www.shadertoy.com/playlist/s33cWf","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["beginner"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.141592653589793\n#define DIRECTION - 1.0\n\n#define COLOR vec4(0.349, 0.8314, 0.5725, 1.0)\n#define thickNess 5.0/iResolution.x\n\n\n\n\nfloat drawLine(vec2 p, vec2 a, vec2 b) {\n    vec2 coords = mix(a, b, clamp(distance(a, p) / distance(a, b), 0.0, 1.0));\n    \n    float d = distance(coords, p);\n    \n    d = 1.0 - thickNess + d;\n    d = floor(d);\n    d = clamp(d, 0.0, 1.0);\n    d = 1.0 - d;\n    \n    return d;\n}\n\nvec2 normalizeCoords(vec2 uv) {\n    vec2 p = uv / iResolution.xy * 2.0 - 1.0;\n    p.x = p.x * iResolution.x / iResolution.y;\n    return p;\n}\n\n// https://www.shadertoy.com/view/McVGDW\nvec4 plotAxis(vec2 uv) {\n    float xAxis = step(-thickNess, uv.y) * step(uv.y, thickNess);\n    float yAxis = step(-thickNess, uv.x) * step(uv.x, thickNess);\n    \n    uv = abs(uv);\n    \n    for(int i = 0; i <= 10; ++ i) {\n        xAxis = xAxis +\n        step(float(i) * 0.1 - thickNess, uv.x) *\n        step(uv.x, float(i) * 0.1 + thickNess) *\n        step(uv.y, 0.01);\n        \n        yAxis = yAxis +\n        step(float(i) * 0.1 - thickNess, uv.y) *\n        step(uv.y, float(i) * 0.1 + thickNess) *\n        step(uv.x, 0.01);\n    }\n    \n    return vec4(vec3(xAxis + yAxis), 1.0);\n}\n\n// https://www.shadertoy.com/view/4fV3WW\nvec4 line(vec2 uv, float linelength) {\n    \n    float stroke = 0.005;\n    \n    vec2 start = vec2(0.0, 0.0);\n    vec2 end = vec2(cos(iTime), DIRECTION * sin(iTime)) * (linelength - stroke);\n    \n    float l = drawLine(uv, start, end);\n    \n    return COLOR * l;\n}\n\n\nvec4 scanLine(vec2 uv, float lineLength) {\n    \n    //mod will %, hence restricting angle between [0, 2*PI]\n    // We are subtracting angle form by uv from iTime because we want to fade away\n    // as we move away from main line\n    float angle = mod(iTime - DIRECTION * atan(uv.y, uv.x), 2.0 * PI);\n    \n    // When angle > PI/2, return 0\n    // When angle < 0, return 1;\n    angle = smoothstep(PI / 2.0, 0.0, angle);\n    \n    // Restricting scan line inside circle\n    // when length(uv) < lineLength => inside circle, return 1\n    // when length(uv) > lineLength => outside circle, return 0;\n    // \n    // step(length(uv), lineLength) = 1.0 - step(lineLength, length(uv))\n    // We can invert the area by switching the variables inside step function\n    //\n    angle *= step(length(uv), lineLength) * 0.5;\n    \n    return COLOR * clamp(angle, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = normalizeCoords(fragCoord.xy);\n    \n    float circle = step(length(uv), 0.5);\n    \n    vec4 finalColor = vec4(0.0);\n    \n    vec4 l = line(uv, 0.5);\n    vec4 scan = scanLine(uv, 0.5);\n    \n    finalColor += l;\n    finalColor += scan;\n    \n    finalColor += clamp(vec4(circle - 0.9), 0.0, 1.0);\n    \n    fragColor =+ plotAxis(uv) + finalColor;\n}","name":"Image","description":"","type":"image"}]}