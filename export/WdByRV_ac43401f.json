{"ver":"0.1","info":{"id":"WdByRV","date":"1587696247","viewed":124,"name":"surfaces of revolution xyz","username":"benhardy","description":"just some stuff with surfaces of revolution and wrapping stuff around an axis. might make a nasty sea creature out of it.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 200.0\n#define MAX_STEPS 1000\n#define EPSILON 0.001\n#define STEP_RATIO 0.2\n\n#define ID_BOX 1\n#define ID_FLOOR 2\n#define ID_SPHERE 3\n#define ID_LATHED 4\n#define ID_TOOTH 5\n#define ID_AXIS 6\n\nfloat calcSoftshadow(in vec3 ro, in vec3 rd, in float mint, in float tmax );\n\n\nfloat box(vec3 where, vec3 dims, float padding) {\n    return length(max(abs(where)-dims,0.0)) - padding;\n}\n\nfloat box2d(vec2 where, vec2 dims, float padding) {\n    return length(max(abs(where)-dims,0.0)) - padding;\n}\n\n#define NORMAL_DELTA 0.0001\n\nvec2 sorCoords(vec3 where) {\n    float r = length(where.xy);\n    return vec2(r,where.z);\n}\n\n/**\n * x is unchanged, is still distance from YZ plane\n * y has become radius from X axis\n * z has become angle around X axis\n */\nvec3 wrapAroundZ(vec3 where) {\n    float r = where.x;\n    float t = where.y;\n    float xp = r * tan(t);\n    float yp = r;\n    return vec3(xp, yp, where.z);\n}\n\nvec3 polar(vec3 where) {\n    return vec3(where.x * cos(where.y), where.x*sin(where.y), where.z);\n}\n\nvec2 measure(vec3 where) {\n    /*\n    vec3 boxWhere = where + vec3(4,0,10);\n    float b1 = box(boxWhere, vec3(1,2,3), 0.25);\n    float b2 = box(boxWhere, vec3(2,3,1), 0.25);\n    float b3 = box(boxWhere, vec3(3,1,2), 0.25);\n    float boxes = blend(b1, blend(b2, b3, 0.25), 0.25);\n    vec2 closest = vec2(boxes, ID_BOX);\n*/\n\tvec2 closest = vec2(MAX_DIST, 0);\n/*\n    vec2 flaty = sorCoords(where - vec3(1,1,1));\n    vec2 pozzie = flaty + vec2(2, 1);\n    float spheredist = length(pozzie)-0.5;\n    \n    if (spheredist < closest.x) {\n\t    closest = vec2(spheredist, ID_BOX);\n    }\n    float plane = where.y + 4.0;\n    if (plane <= closest.x) {\n        closest = vec2(plane, ID_FLOOR);\n    }\n    \n    vec3 sphereWhere = repeat_xz(where + vec3(0,3.9,0), 1.0);\n    float sphereDist = length(sphereWhere) - 0.1;\n    if (sphereDist <= closest.x) {\n        closest = vec2(sphereDist, ID_SPHERE);\n    }\n    */\n    vec3 locally = where - vec3(1,1,-3);\n    float dz = 0.1*sin(atan(locally.y,locally.x) *PI*6.0);\n    vec2 lathed = sorCoords(locally) + vec2(-4,0);\n    //float squareBit = box2d(lathed, vec2(2,0.2),0.0); \n    float mouth = length(lathed+vec2(0,  dz-0.8)) -0.8;\n\n   \n    if (mouth < closest.x) {\n        closest = vec2(mouth, ID_LATHED);\n    }\n    \n    float surfaceRadius = 4.0;\n    float r = length(locally.xy) -surfaceRadius;\n    float along =pow(locally.z+1.0,1.1);\n    //r+=0.5*along- 1.0;\n    float t = atan(locally.y, locally.x);\n    t = cmod(t, PI/(surfaceRadius*2.0)) * surfaceRadius ;\n    // wrapped has radial symmetry around Z axis\n    vec3 wrapped = vec3(r,t,locally.z - 1.5);\n    // bend the tooth itself\n\n    float tooth = sdRoundCone(-wrapped.xzy+vec3(0,2,0), 0.05, 0.3, 2.0);\n    //tooth = blend(tooth, res, 0.3);\n    if (tooth < closest.x) {\n        closest = vec2(tooth*0.2, ID_TOOTH);\n    }\n    \n    float gums = length(vec2(tooth-0.1, mouth+0.05)) - 0.25;\n    gums = blend(gums, mouth, 0.1);\n    if (gums < closest.x) {\n        closest = vec2(gums, ID_LATHED);\n    }\n    /*\n    //locally += iTime;\n    // the z axis is a sequence of balls\n    float ballRadius = 0.2;\n    float ballInterval = 0.5;\n    vec3 ballMod = vec3(100000,100000,ballInterval);\n    vec3 zAxisPos = cmod(locally+vec3(0,0,iTime), ballMod);\n    float z_axis = sdRoundCone(zAxisPos, 0.05, 0.2, 1.5);\n    // wrap a copy of the z axis into a hoop under it\n    float hoopRadius = 5.0 / PI;\n    vec3 bentPos = locally + vec3(0,hoopRadius,-4);\n    float theta = atan(bentPos.z, bentPos.y) + iTime/hoopRadius;\n    float rad = length(bentPos.yz);\n    vec3 bent = vec3(bentPos.x, rad, theta * hoopRadius);\n    //float z_bent = length(bent.xy) - 0.1;\n    float z_bent = length(cmod(bent+vec3(0,-hoopRadius,0), ballMod)) - ballRadius;\n    \n    z_axis = min(z_axis, z_bent);\n    if (z_axis < closest.x) {\n        closest = vec2(z_axis, ID_AXIS);\n    }\n    */\n    return closest;\n}\n\nvec3 calc_surface_normal(vec3 hit) {\n\treturn normalize(vec3(\n            measure(hit+vec3(NORMAL_DELTA, 0.0, 0.0)).x - measure(hit-vec3(NORMAL_DELTA, 0.0, 0.0)).x,\n            measure(hit+vec3(0.0, NORMAL_DELTA, 0.0)).x - measure(hit-vec3(0.0, NORMAL_DELTA, 0.0)).x,\n            measure(hit+vec3(0.0, 0.0, NORMAL_DELTA)).x - measure(hit-vec3(0.0, 0.0, NORMAL_DELTA)).x\n    ));\n}\n\nvec4 paint(vec2 hit, vec3 where) {\n\n    int who = int(hit.y);\n    \n    if (who == ID_BOX) {\n        return 0.75*vec4(WHITE, 1);\n    }\n    if (who == ID_FLOOR) {\n        float level = fract(length(where));\n        return vec4(0.5 + 0.5*level/2.0, level, level, 1.0);\n    }\n    if (who == ID_SPHERE) {\n        return vec4(1,1,0.2,1.0);\n    }\n    if (who == ID_LATHED) {\n        vec3 hit = where - vec3(1,1,-3);\n        float ang = 48.0 * atan(hit.x, hit.y) / PI;\n        float lev = clamp(4.0*abs(fract(ang)*2.0-1.0)-2.0, 0.0, 1.0);\n        return vec4(0.8,0.3,0.5, 0.7) \n            * (0.8+0.10*lev*clamp(abs(hit.z)-0.1,0.0,0.7)) ;\n    }\n    if (who == ID_TOOTH) {\n        return vec4(0.9,0.85,0.75,0.7);\n    }   \n    if (who == ID_AXIS) {\n        return vec4(0.5,0.55,0.2,0.7);\n    }\n    return vec4(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3(sin(iTime*0.31)*6.0-10.0,\n                    sin(iTime*0.01)*3.0+6.0,\n                    cos(iTime*0.13)*13.0);\n    vec3 look_at = vec3(2,1,1);\n    vec3 up = Y;\n    vec3 ray = calculateRay(iResolution, fragCoord, eye, look_at, up);\n    \n    vec3 where = eye;\n    float total_dist = 0.0;\n    vec2 current;\n    int who = 0;\n    float current_dist = 0.0;\n    float best_dist = MAX_DIST;\n    for(int steps =0;steps < MAX_STEPS; steps++) {\n        current = measure(where);\n        current_dist = current.x;\n        if (current_dist < EPSILON) {\n            who = int(current.y);\n            break;\n        }\n        if (current_dist < best_dist) {\n            best_dist = current_dist;\n        }\n        total_dist += current_dist * STEP_RATIO;\n        if (total_dist > MAX_DIST) {\n            break;\n        }\n        where = eye + total_dist * ray;\n    }\n\n    vec3 fog_color = vec3(0,0,0);\n    \n    if (who == 0){\n        /*\n        float glow = clamp(1.0 - best_dist, 0.0, 1.0);\n        vec3 pink = vec3(1.0, 0.6, 0.5);\n        */\n        fragColor = vec4(0.2, 0.3, 0.4, 1.0);\n        return;\n    }\n\tvec3 hit = where;\n    vec4 the_paint = paint(current, where);\n    float fade = total_dist /MAX_DIST;\n    vec4 fog = vec4(WHITE, 1);\n    the_paint = mix(the_paint, fog, fade);\n    vec3 to_light = normalize(vec3(-10,5,-1));\n    float shadow = calcSoftshadow(hit, to_light, 0.0, total_dist);\n    vec3 surface_normal = calc_surface_normal(hit);\n    float dotty = dot(to_light, surface_normal);\n    float light_amount = max(0.0, dotty);\n    float light_fade = 1.0;\n    float ambient = the_paint.w;\n    float lighting = ambient + (1.0-ambient)  \n        * (shadow*0.5 * (1.0 + light_amount * light_fade));\n\n\tvec3 coloring = light_fade *(the_paint.xyz * lighting)\n        + fog_color * (1.0-light_fade);\n    vec3 reflected = surface_normal * 2.0 * dotty - to_light;\n    vec3 toEye = normalize(-ray);\n\tfloat specular = pow(max(0.0, dot(toEye, reflected)), 32.0);\n\tcoloring += shadow*vec3(specular, specular, specular);\n    fragColor = vec4(coloring,1.0);\n}\n\n// iq's soft shadow algo\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = measure( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_FLOAT 3.402823466e+38\n#define MIN_FLOAT 1.175494351e-38\n#define MAX_DOUBLE 1.7976931348623158e+308\n#define MIN_DOUBLE 2.2250738585072014e-308\n\n// Indicate to 'repeat' function that we don't wish to\n#define NEVER 1000000.0\n\n/**\n * Common vectors\n */\nconst vec3 ORIGIN = vec3(0,0,0);\nconst vec3 X = vec3(1,0,0);\nconst vec3 Y = vec3(0,1,0);\nconst vec3 Z = vec3(0,0,1);\n\n/**\n * Common color values\n */\nconst vec3 BLACK = vec3(0,0,0);\nconst vec3 WHITE = vec3(1,1,1);\nconst vec3 RED   = vec3(1,0,0);\nconst vec3 GREEN = vec3(0,1,0);\nconst vec3 BLUE  = vec3(0,0,1);\nconst vec3 YELLOW  = vec3(1,1,0);\nconst vec3 CYAN    = vec3(0,1,1);\nconst vec3 MAGENTA = vec3(1,0,1);\n\n/**\n * For the given 2d screen position, figure out the ray vector\n */\nvec3 calculateRay(vec3 res, vec2 screenPos, \n                  vec3 eye, vec3 look_at, vec3 up) {\n\tvec2 screen_pos = screenPos.xy / res.xy;\n    float aspect = res.y / res.x;\n    screen_pos -= 0.5;\n    screen_pos.y *= aspect;\n    vec3 look_center = normalize(look_at - eye);\n    vec3 look_right = cross(up, look_center);\n    vec3 look_up = cross(look_center, look_right);\n        \n\tvec3 newRay = normalize(look_center + screen_pos.x * look_right + screen_pos.y * look_up);\n    return newRay;\n}\n\n\n\n/*\n * Signed distance functions for object primitives\n */\nfloat sphere(vec3 where, vec3 center, float radius) {\n  return length(where - center) - radius;\n}\n\n//float torus_around_x(vec3 where, float major, float minor) {\n    \n\nfloat box( vec3 where, vec3 sizes ) {\n\treturn length(max(abs(where)-sizes,0.0));\n}\n    \n\nfloat round_box( vec3 where, vec3 sizes, float roundness ) {\n\treturn length(max(abs(where)-sizes,0.0))-roundness;\n}\n\n#define cmod(x,  r) (mod(x + 0.5 *r, r) - 0.5 * r)\n\n\nvec3 repeat(vec3 where, vec3 repetition) {\n\n    return mod(where, repetition);\n}\nvec3 repeat_x(vec3 where, float r) {\n\n    where.x = mod(where.x, r);\n    return where;\n}\nvec3 repeat_xz(vec3 where, float r) {\n\n    where.x = mod(where.x, r);\n    where.z = mod(where.z, r);\n    return where;\n}\n\n\n#define PI 3.141592653589793\nvec3 radial_symmetry_xz(vec3 where, float count) {\n    float ang = mod(atan(where.x, where.z) + PI, 2.0 *PI /count);\n    float r = length(where.xz);\n    return vec3(r *cos(ang), where.y, r * sin(ang));\n}\n\n// polynomial smooth min (k = 0.1);\nfloat blend( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*0.25/k;\n}\n\n\nint hash(int x) {\n    x = ((x >> 16) ^ x) * 0x45d9f3b;\n    x = ((x >> 16) ^ x) * 0x45d9f3b;\n    x = (x >> 16) ^ x;\n    return x;\n}\n\n// from iq's page\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}","name":"Common","description":"","type":"common"}]}