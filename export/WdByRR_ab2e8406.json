{"ver":"0.1","info":{"id":"WdByRR","date":"1585910400","viewed":310,"name":"UnderWater","username":"Hei149","description":"raymarching","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdCylinder(vec3 p, float r, float h)\n{\n    return max(length(p.xz) -r, abs(p.y) - h);\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n) * 43758.5453);\n}\n\n//Hash from iq\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 k = fract(x);\n\tk = k*k*(3.0-2.0*k);\n\t\n    float n = p.x + p.y * 57.0 + p.z * 113.0;\n\tfloat a = hash(n);\n    float b = hash(n + 1.0);\n    float c = hash(n + 57.0);\n    float d = hash(n + 58.0);\n\n    float e = hash(n + 113.0);\n    float f = hash(n + 114.0);\n    float g = hash(n + 170.0);\n    float h = hash(n + 171.0);\n\t\n    float res = mix(mix(mix(a, b, k.x), mix(c, d, k.x), k.y),\n                    mix(mix(e, f, k.x), mix(g, h, k.x), k.y),\n                k.z);\n    return res;                \n}\n#define rotate(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat map(vec3 p)\n{\n    vec3 rp = p;\n    vec2 id = floor(rp.xz / 20.0);\n    rp.xz = mod(rp.xz, 20.0) - 10.0;\n    float d = sdCylinder(rp + vec3(hash(id.x) * 20.0 - 10.0, 0.0, hash(id.y) * 20.0 - 10.), 2.0, 50.);\n    float ground = noise(p * 0.5) + noise(p) * 0.5 + noise(p * 2.0) * 0.25;\n    d = smin(d, p.y + 10.0, 5.0);\n    return d - ground;\n}\n\nvec3 norm(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\nfloat caustic(vec3 p)\n{\n    return abs(noise(p + mod(iTime, 40.0) * 2.0) - noise(p + vec3(4.0, 0.0, 4.0) + mod(iTime,40.0) * 2.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 r0 = vec3(20.0, 10.0, -20.0);\n    r0.xz *= rotate(0.58);\n\n    vec3 ww = normalize(-r0);\n    vec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n\n    vec3 rd = normalize(uu * uv.x + vv * uv.y + ww);\n\n    float d = 0.0;\n    for(int i = 0; i < 100; ++i)\n    {\n        vec3 p = r0 + d * rd;\n        float t = map(p);\n        d += t;\n        if(d > 100.0 || t < 0.001) break;\n    }\n    vec3 col = vec3(0.0);\n    vec3 p = r0 + d * rd;\n    if(d < 100.0)\n    {\n        vec3 n = norm(p);\n        vec3 ld = normalize(vec3(0.5, 1.0, -0.5));\n        float diff = max(dot(n, ld), 0.0);\n        col += diff * vec3(0.6, 0.8, 1.0);\n        col += (n.y * 0.5 + 0.5) * vec3(0.16, 0.20, 0.28);\n        float n1 = noise(p * 0.5);\n        float n2 = noise(p);\n        float n3 = noise(p * 8.);\n        col *= n1 * vec3(0.2, 1.0, 0.1) * 2.0 + n2 * vec3(2.0, 0.2, 0.1) * 2.0 + n3 * vec3(0.5, 0.5, 0.1);\n    }\n    \n    col += smoothstep(0.0, 1.0, (1.0 - caustic(p * 0.5)) * 0.5);\n    float fog = clamp(exp(-d * 0.035), 0.0, 1.0);\n    col = mix(col, vec3(0.2, 0.5, 1.0), 1.0 - fog);\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}