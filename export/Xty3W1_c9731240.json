{"ver":"0.1","info":{"id":"Xty3W1","date":"1474327957","viewed":330,"name":"Space ocean","username":"axelduch","description":"Juju","likes":4,"published":1,"flags":64,"usePreview":0,"tags":["music","light","space","ocean"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xd2GRD","filepath":"https://soundcloud.com/axel-duch/dans-le-sourire-des-oceans","previewfilepath":"https://soundcloud.com/axel-duch/dans-le-sourire-des-oceans","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"# define CLIP_FAR 1000.0\n# define STOP_THRESHOLD 0.008\n# define MAX_ITERATIONS 64\n# define PI 3.14159265359\n# define DEG_TO_RAD 3.14159265359 / 180.0\n    \nfloat dist_sphere (vec3 pos, float r) {\n    return length(pos) - r;\n}\n\nfloat dist_field (vec3 pos) {\n    float bigPlanetR = 1.35;\n    float bigPlanet = dist_sphere(pos, bigPlanetR);\n    float res = bigPlanet;\n    \n    const float l = 2.0;\n    for (float i = 8.0; i >= 0.0; i -= 0.15) {\n        vec3 imperfectionPos = vec3(pos);\n        float imperfectionR = max(0.0001 * i, 0.00001);\n        imperfectionPos.x = imperfectionR * (bigPlanetR + imperfectionR * 1.0);\n        imperfectionPos.y = (i - l) * (imperfectionR) * (bigPlanetR + imperfectionR * 1.0);\n        imperfectionPos.z -= imperfectionPos.y;\n        float imperfection = dist_sphere(imperfectionPos, imperfectionR);\n        res = min(res, imperfection);\n    }\n    \n    \n    for (float i = l; i >= 0.0; i--) {\n        vec3 smallPlanetPos = vec3(pos);\n        float smallPlanetR = min((l - i) / 70.0 + 0.04, 0.1);\n        smallPlanetPos.x += cos(-iTime * 0.7 + (i - l) * (smallPlanetR * 0.8)) * (bigPlanetR + smallPlanetR * 1.0);\n        smallPlanetPos.y += sin(-iTime * 0.3 + (i - l) * (smallPlanetR * 0.8)) * (bigPlanetR + smallPlanetR * 1.0);\n        smallPlanetPos.z -= 1.3 + smallPlanetPos.y;\n        float smallPlanet = dist_sphere(smallPlanetPos, smallPlanetR);\n        res = min(res, smallPlanet);\n    }\n    \n    for (float i = l; i >= 0.0; i--) {\n        vec3 smallPlanetPos = vec3(pos);\n        float smallPlanetR = min((l - i) / 70.0 + 0.04, 0.1);\n        smallPlanetPos.x += sin(-iTime * 0.9 + (i - l) * (smallPlanetR * 0.8)) * (bigPlanetR + smallPlanetR * 1.0);\n        smallPlanetPos.y += cos(-iTime * 0.8 + (i - l) * (smallPlanetR * 0.8)) * (bigPlanetR + smallPlanetR * 1.0);\n        smallPlanetPos.z -= 1.3 - smallPlanetPos.y;\n        float smallPlanet = dist_sphere(smallPlanetPos, smallPlanetR);\n        res = min(res, smallPlanet);\n    }\n    \n    for (float i = l; i >= 0.0; i--) {\n        vec3 smallPlanetPos = vec3(pos);\n        float smallPlanetR = min((l - i) / 70.0 + 0.04, 0.1);\n        smallPlanetPos.x += sin(-iTime * 0.3 + (i - l) * (smallPlanetR * 0.8)) * (bigPlanetR + smallPlanetR * 1.0);\n        smallPlanetPos.y += cos(-iTime * 0.1 + (i - l) * (smallPlanetR * 0.8)) * (bigPlanetR + smallPlanetR * 1.0);\n        smallPlanetPos.z -= 1.3 - smallPlanetPos.y;\n        float smallPlanet = dist_sphere(smallPlanetPos, smallPlanetR);\n        res = min(res, smallPlanet);\n    }\n    \n    for (float i = l; i >= 0.0; i--) {\n        vec3 smallPlanetPos = vec3(pos);\n        float smallPlanetR = min((l - i) / 70.0 + 0.04, 0.19);\n        smallPlanetPos.x += sin(-iTime * 0.1 + (i - l) * (smallPlanetR * 0.8)) * (bigPlanetR + smallPlanetR * 1.0);\n        smallPlanetPos.y += cos(-iTime * 0.15 + (i - l) * (smallPlanetR * 0.8)) * (bigPlanetR + smallPlanetR * 1.0);\n        smallPlanetPos.z -= 1.3 - smallPlanetPos.y;\n        float smallPlanet = dist_sphere(smallPlanetPos, smallPlanetR);\n        res = min(res, smallPlanet);\n    }\n    \n    \n    return res;\n}\n\nfloat ray_march(vec3 ro, vec3 rd) {\n    float depth = 0.0;\n    \n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n        float dist = dist_field(ro + rd * depth);\n        \n        if (dist < STOP_THRESHOLD) {\n            return depth;\n        }\n        \n        depth += dist;\n        \n        if (depth >= CLIP_FAR) {\n            return CLIP_FAR;\n        }\n    }\n    \n    return CLIP_FAR;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n\nvec3 shading(vec3 pos, vec3 n, vec3 ro, vec2 uv) {\n    vec3 lightPos = vec3(20.0, 20.0, 20.0);\n    vec3 lightColor = vec3(uv,0.5+0.5*sin(iTime));\n    \n    vec3 Normal     = vec3(uv.x, uv.y, sqrt(n.z));\n\n    float t = iTime;\n\tfloat U = 1.0-atan(Normal.z, Normal.x) / (2.0* PI);\n\tfloat V = 1.0-(atan(length(Normal.xz), Normal.y)) / PI;\n \tvec3 Ground = pow(texture(iChannel0, vec2(U - t/4.0, V)).xyz, vec3(2.22));\n    \n    lightColor = mix(lightColor, vec3(1.0), Ground);\n    \n    vec3 vl = normalize(lightPos - ro);\n    \n    float ambient = 0.8;\n    float diffuse = max(0.0, dot(vl, n));\n    \n    // specular\n    vec3 ev = normalize(pos - ro);\n    vec3 ref_ev = reflect(ev, n);\n    float specular = max(0.0, dot(vl, ref_ev));\n    \n    return lightColor * (ambient + diffuse + specular);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\t\n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rd = ray_dir(20.0 + sin(iTime * 2.0), iResolution.xy, fragCoord.xy );\n    \n    float depth = ray_march(ro, rd);\n    \n    if (depth >= CLIP_FAR) {\n    \tfragColor = vec4(vec3(0.0), 1.0);\n        fragColor = vec4(vec3(uv,0.5+0.5*sin(iTime)), 1.0);\n        return;\n    }\n    \n    \n    vec3 pos = ro + rd * depth;\n    \n    fragColor = vec4(shading(pos * 1.1, pos * 1.0, ro * 1.0, uv * 0.59), 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}