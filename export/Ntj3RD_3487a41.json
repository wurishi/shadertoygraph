{"ver":"0.1","info":{"id":"Ntj3RD","date":"1623445539","viewed":98,"name":"Galactic black hole station","username":"Willisburg","description":"A spiral of numbers from 0 to infinity, only numbers that are divisible by given criteria are drawn","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["spiralpatterns"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Finds the value of bottom right \n// corner of a ring with given depth\n// Will also find upper left corner, \n// if negative depth is given\nint calcBR(int depth)\n{\n    return 4 * depth * depth - 2 * depth;\n}\n\n// Finds the value of upper right \n// corner of a ring with given depth\n// Will also find botton left corner,\n// if negative depth is given\nint calcUR(int depth)\n{\n    int flag = depth > 0 ? 1 : 0;\n    return 4 * (depth + 1 * flag) * (depth + 1 * flag) - 4 * (depth + 1) * flag;\n}\t\n\n// Given coordinates x and y, \n// returns a value from a grid \n// spiral of numbers\nint calcNum(int x, int y) \n{\nif(x == y)\n    return calcBR(x);\nelse if(-x == y)\n    return calcUR(x);\nelse if(abs(y) > abs(x))\n    return calcBR(y) + abs(y) + x * (y<0?1:-1);\nelse\n    return calcBR(x) - abs(x) - y * (x<0?1:-1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -iResolution/2 to iResolution/2)\n    vec2 uv = fragCoord - iResolution.xy/2.0;//+ vec2(iResolution.y / 2.0, -iResolution.y / 2.0);\n    float scale = 4.0;\n    \n    // Scales pixel coordinates by a given amount\n    uv *= float(scale);\n    \n    ///CRITERIA///\n    // The criteria, have fun and test out different values\n    int criteria = int(uv.x*uv.y/(iTime*100.0));// + int(iTime*2.0);\n    \n    // Nested for loops make sure that no values \n    // are skipped when scaling up the resolution\n    for(int i = 0; i < int(scale); i+=1)\n    {\n        for(int j = 0; j < int(scale); j+=1)\n        {\n            int num = calcNum(int(uv.x)+i, int(uv.y)+j);\n            \n            // Checks whether a number is divisible by criteria\n            // if so draw it and return\n            \n            // Edit: checking whether the modulus of num divided by criteria is equal \n            // to modulus of time divided by criteria, creates a shifting effect:\n            // int(mod(-iTime*50.0, float(criteria)))\n            if(num%criteria == 0)\n            {\n                fragColor = vec4(1.0);\n                return;\n            }\n        }\n    }\n    fragColor = vec4(0.0);\n}","name":"Image","description":"","type":"image"}]}