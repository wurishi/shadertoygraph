{"ver":"0.1","info":{"id":"Ds3XRH","date":"1679711323","viewed":116,"name":"Sphere of cubes in a cube","username":"grom12345","description":"Forked from here: https://www.shadertoy.com/view/wtVyRG\nSoft shadows adopted from these: https://www.shadertoy.com/view/lsKcDD\nhttps://www.shadertoy.com/view/fsXSzj\nI use buffers to experiment with effects.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["shadow","repetition","spherical","polar"],"hasliked":0,"parentid":"cs3SR8","parentname":"Spherical  soft shadow"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 scene = texture(iChannel0, uv).rgb;\n    vec3 color = scene;\n    fragColor = vec4(pow(color, vec3(1./2.2)), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define TAU 6.28318530718 // 2 * pi\n#define PHI 1.57079632679 // pi / 2\n\n// oldschool rand() from Visual Studio\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void)  { seed=seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n\n// r: vec2(horizontal repeats, vertical repeats)\nvec3 pModSpherical(inout vec3 p, in vec2 r, float iTime) {\n    vec2 a = TAU / r, ha = 0.5 * a;\n    vec3 p1 = p;\n    p1.xz = sin(mod(atan(p1.z, p1.x) + ha.x, a.x)\n          - ha.x + vec2(PHI, 0.0)) * length(p1.xz);\n    p1.xy = sin(mod(atan(p1.y, p1.x) + ha.y, a.y)\n          - ha.y + vec2(PHI, 0.0)) * length(p1.xy);\n    p1 = p1 - vec3(2.*(1.+sin(iTime+TAU/2.+PHI))+3., .0, 0.0);\n    return p1;\n}\n\nfloat sphere(vec3 p, float r){\n    return length(p)-r;\n}\n\nfloat box(vec3 p, float r){\n    vec3 q = abs(p) - r;\n    return max(q.x, max(q.y, q.z));\n}\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat mapScene(in vec3 p, float iTime) {\n    float t = iTime*.2;\n    float c = cos(t), s = sin(t);\n    vec3 p1 = p;\n    p1.xz *= mat2(c, -s, s, c);\n    //p.yz *= mat2(c, -s, s, c);\n\n    p1 = pModSpherical(p1, vec2(33.0, 33.0), iTime);\n    float boxes = box(p1, .1*(1.+sin(iTime+PHI))+.02);\n    \n    float bbox = abs(box(p, 8.))-.1;\n    float sp = sphere(p+vec3(0, 0, 0), 0.5);\n    \n    float scene = opUnion(bbox, boxes);\n\n    return scene;\n}\n\nvec3 getNormal(in vec3 p, float iTime) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy, iTime) - mapScene(p - e.xyy, iTime),\n                          mapScene(p + e.yxy, iTime) - mapScene(p - e.yxy, iTime),\n                          mapScene(p + e.yyx, iTime) - mapScene(p - e.yyx, iTime)));\n}\n\nfloat softShadow(vec3 pp, vec3 normal, vec3 ln, float iTime){\n\n    float eps = .001;\n    int maxSteps = 100;\n    float maxRange = 10.5;\n\t\n\tvec3 start_point = pp + normal * eps*20.;\n\tfloat t = 0.f;\n\tvec3 light_dir = ln;\n\tfloat offset = mapScene(start_point, iTime);\n\tfloat step = offset;\n\tvec3 p;\n\tfloat visibility = 1.f;\n\tfloat hardness = 100.f;\n\t\n\tfor(int i = 0;i<maxSteps;i++){\n\t\tt += step;// * (0.7 + 0.3 * frand());\n\t\tif(t > maxRange)\n\t\t\tbreak;\n\t\tp = start_point + light_dir * t;\n\t\tstep = mapScene(p, iTime);\n\t\t//float v_ = hardness * step / (t + hardness * offset);\n\t\tfloat v_ = max(step - offset,.0f) * hardness / t;\n\t\tif( v_ < visibility)\n\t\t\tvisibility = v_;\n        if( visibility < eps)\n            return 0.;\n\t}\n\t\n\treturn visibility;\n\t//return 1.f;\n\t\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -.3));\n    vec3 l = vec3(0, 0, 0);\n    \n    float tt = iTime;\n    float c = cos(tt), s = sin(tt);\n    l.yz *= mat2(c, -s, s, c);\n    vec3 color;\n    float t = 0.0;\n    for (int i=0; i < 150; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p, iTime);\n        if (d < 0.001) {\n            vec3 n = getNormal(p, iTime);\n            vec3 ln = normalize(l-p);\n            float sh = softShadow(p, n, ln, iTime);\n            color = vec3(max(0.1, dot(n, ln))*sh);\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += d;\n    }\n    fragColor = vec4(color, 1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}