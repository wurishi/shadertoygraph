{"ver":"0.1","info":{"id":"DdjSWD","date":"1670348586","viewed":108,"name":"geometryShapesDemo","username":"karanbpathak","description":"geometryShapesDemo\ninspired by : https://iquilezles.org/articles/distfunctions/\nhttps://www.shadertoy.com/view/wlXSD7\n// Rotation matrix around the axis.\ninspired by https://inspirnathan.com/posts/54-shadertoy-tutorial-part-8/","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["3d","sdf","geometry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// inspired by : https://iquilezles.org/articles/distfunctions/\n\n// Rotation matrix around the X axis.\n// inspired by https://inspirnathan.com/posts/54-shadertoy-tutorial-part-8/\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat sdTorus( vec3 p, vec2 t, vec3 offset, mat3 transform)\n{\n  p = (p - offset) * transform;\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdSphere(in vec3 p, in vec3 c, float r, vec3 offset, mat3 transform)\n{\n    p = (p - offset) * transform;\n    return length(p - c) - r;\n}\nfloat sdBox(in vec3 p, in vec3 c, float r, vec3 offset, mat3 transform)\n{\n    p = (p - offset) * transform;\n    vec3 q = abs(p) - c;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPyramid( vec3 p, float h, vec3 offset, mat3 transform)\n{\n  p = (p - offset) * transform;\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.07;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\nfloat sdCone( in vec3 p, in vec2 c, float h,vec3 offset, mat3 transform )\n{\n  p = (p - offset) * transform;\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb,vec3 offset, mat3 transform )\n{\n  p = (p - offset) * transform;\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\nfloat map(in vec3 p)\n{\n    float t =  sdTorus(p,vec2(0.28,0.035),vec3(0.2,0.1,0.4), rotateX(2.14)*rotateZ(6.45));\n    t = min(t, sdBox(p, vec3(0.04,0.04,0.039), 0.001, vec3(0.1,0.28,0.35), rotateZ(0.4) * rotateX(1.24))); \n    t = min(t, sdBox(p, vec3(0.2,0.4,0.3), 0.05, vec3(-0.5,3.5,-0.1), identity()));\n    t = min(t, sdSphere(p, vec3(0.14,0.08,0.24), 0.09,vec3(0.0,-0.1,0.2), identity()));\n    t = min(t, sdSphere(p, vec3(0.14,0.1,0.24), 0.03,vec3(-0.01,0.23,0.14), identity()));\n    t = min(t, sdSphere(p, vec3(0.45,0.08,0.24), 0.02,vec3(-0.01,0.23,0.14), identity()));\n    t = min(t, sdSphere(p, vec3(0.45,0.08,0.24), 0.03,vec3(-0.04,-0.1,0.37), identity()));\n    t = min(t, sdSphere(p, vec3(0.55,-0.05,0.31), 0.02,vec3(-0.01,0.23,0.14), identity()));\n    t = min(t, sdSphere(p, vec3(0.55,-0.4,0.1), 0.035,vec3(-0.01,0.3,0.14), identity()));\n    t = min(t, sdTorus(p,vec2(0.14,0.01),vec3(0.49,0.17,0.4), rotateX(-0.2)*rotateZ(6.35)));\n    t = min(t, sdSphere(p, vec3(0.4,0.4,-0.2), 0.1,vec3(0.0,-0.1,0.2), identity()));\n    t = min(t, sdTorus(p,vec2(0.16,0.01),vec3(0.4,0.31,0.02), rotateX(0.5)*rotateZ(6.35)));\n    t = min(t, sdSphere(p, vec3(0.4,0.4,-0.2), 0.03,vec3(0.08,0.01,0.1), identity()));\n    t = min(t, sdBox(p, vec3(0.04,0.04,0.039), 0.002, vec3(0.43,-0.16,0.32), rotateZ(1.0) * rotateX(1.24)));\n    t = min(t, sdPyramid( p, 1.0, vec3(0.5,-0.18,0.08), rotateZ(-0.5)));\n    t = min(t, sdPyramid( p, 1.0, vec3(0.1,0.18,0.56), rotateX(0.5) * rotateZ(0.5)));\n    t = min(t, sdCone( p, vec2(sin(0.2),cos(0.3)), 0.3, vec3(0.4,-0.1,-0.01), rotateY(0.3) * rotateX(1.8) * rotateZ(0.3)));\n    t = min(t, sdCone( p, vec2(sin(0.2),cos(0.3)), 0.2, vec3(0.3,-0.04,0.66), rotateZ(3.3)));\n    t = min(t, sdCappedTorus(p, vec2(0.19,0.01), 0.09, 0.016,vec3(0.5,0.02,0.08), rotateZ(3.7)));\n    t = min(t, sdCappedTorus(p, vec2(0.1,0.02), 0.06, 0.011,vec3(0.5,0.03,0.56), rotateZ(1.7)));\n    return t;\n}\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.15*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - occ*1.5, 0.0, 1.0 );\n}\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 3\n#endif\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.7*iTime;\n\tvec3 ro = vec3( 1.0*cos(an), 0.2, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n    \n    \n    // render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 lig = normalize(vec3(0.6,0.2,0.4));\n            vec3 hal = normalize(lig-rd);\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            float occ = calcOcclusion( pos, nor );\n            if( dif>0.001 ) dif *= calcSoftshadow( pos, lig, 0.01, 1.0 );\n            float spe = pow(clamp(dot(nor,hal),0.0,1.0),16.0)*dif*(0.04+0.96*pow(clamp(1.0-dot(hal,-rd),0.0,1.0),5.0));\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col =  vec3(0.5,1.0,1.2)*amb*occ;\n            col += vec3(2.8,2.2,1.8)*dif;\n            \n            col *= 0.2;\n            \n            col += vec3(2.8,2.2,1.8)*spe*3.0;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}