{"ver":"0.1","info":{"id":"mtGXDK","date":"1686350863","viewed":548,"name":"Apple Vision Pro","username":"luckyballa","description":":)","likes":12,"published":1,"flags":34,"usePreview":0,"tags":["raymarching","transparency","blur","transparent","ar","lol","vision","apple","fonts","multipass","headset","glasses","icloud","visionos"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;  \n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    fragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265\n#define MAX_STEPS 24\n#define MAX_DIST 24.0\n#define SURF_DIST .002\n\n#define iTime iTime * 0.8\n#define modT (mod(iTime, 7.0) - 0.5)\n\n#define rawT min(max(modT, 0.0), 1.0)\n#define rawT2 min(max(mod((iTime - 0.35), 7.0) - 0.5, 0.0), 1.0)\n#define rawT3 min(max(mod((iTime - 0.6), 7.0) - 0.5, 0.0), 1.0)\n#define T pow(circularInOut(rawT), 3.0)\n\n\nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat smin( float a, float b, float k ) {\n    float h = max(k-abs(a-b), 0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\nfloat circularInOut(float t) {\n  return -t * (t - 2.0);\n\n}\n\nvec3 blur(sampler2D tex, vec2 uv, vec2 resolution, float radius) {\n    vec3 color = vec3(0.0);\n    vec2 texelSize = 1.0 / resolution;\n    int count = 0;\n    \n    for (float x = -radius; x <= radius; x++) {\n        for (float y = -radius; y <= radius; y++) {\n            vec2 offset = vec2(x, y) * texelSize;\n            color += texture(tex, uv + offset).rgb;\n            count++;\n        }\n    }\n\n    return color / float(count);\n}\n\nvec2 distortion(in vec2 uv, in float k1, in float k2, float t) {\n    uv = uv * 2.0 - 1.0;\t\n    vec2 dir = sign(uv);\n    uv.x = abs(uv.x);\n    uv.x -= 0.25;\n    float r2 = uv.x*uv.x + uv.y*uv.y;\n    \n    uv.x = uv.x * dir.x - step(dir.x, 0.0) * 0.5;\n    uv.x += 0.25;\n    uv *= 1.0 + k1 * r2 + k2 * r2 * r2;\n\n    uv *= 0.9 + t * 0.1;\n    uv *= 1.0 - sin(t * PI) * 0.25;    \n\n    uv = (uv * .5 + .5);\t\n    \n    return uv;\n}\n    \nfloat sdBox( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( vec2 p, float r ) { return length(p) - r; }\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nfloat dot2(vec2 p) { return dot(p, p); }\n\nvec3 rot(vec3 P, float a, vec3 A) {\n    vec3 O = dot(P, A) * A;\n    return O + (P-O) * cos(a) -  cross(A,P) * sin(a);\n}\n\nconst int c_samplesX = 13;\nconst int c_samplesY = 13;\nconst int c_halfSamplesX = c_samplesX / 2;\nconst int c_halfSamplesY = c_samplesY / 2;\n\nfloat Gaussian (float sigma, float x) {\n    return exp(-(x*x) / (2.0 * sigma*sigma));\n}\n\nvec3 BlurredPixel (in vec2 uv, sampler2D tex) {\n    float c_pixelSize = (1.0 / 512.0);\n    float c_sigmaX = 8.0;\n\tfloat c_sigmaY = 8.0;\n    \n    float total = 0.0;\n    vec3 ret = vec3(0);\n        \n    for (int iy = 0; iy < c_samplesY; ++iy)\n    {\n        float fy = Gaussian (c_sigmaY, float(iy) - float(c_halfSamplesY));\n        float offsety = float(iy-c_halfSamplesY) * c_pixelSize;\n        for (int ix = 0; ix < c_samplesX; ++ix)\n        {\n            float fx = Gaussian (c_sigmaX, float(ix) - float(c_halfSamplesX));\n            float offsetx = float(ix-c_halfSamplesX) * c_pixelSize;\n            total += fx * fy;            \n            ret += texture(tex, uv + vec2(offsetx, offsety)).rgb * fx*fy;\n        }\n    }\n    return ret / total;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    uv.y -= 1.25;\n    uv.y += pow(T, 0.6) * 1.55;\n    uv.xy *= 1.0 - max(T - 0.3, 0.0) * 0.95 + 0.35;\n   \n    vec2 eye = uv;\n    eye.x = abs(uv.x);\n    \n    eye -= vec2(0.42 - mix(rawT, T, 0.5) * 0.025, 0.085 + T * 0.125);\n    eye.y *= 1.05 + (0.5 - abs(uv.x)) * 0.5 * smoothstep(1.0, 0.8, T);\n\n    float eyeDist = length(eye) - 0.325 - pow(max(T - 0.325, 0.0001) * 1.05, 2.5) * 0.925;\n\n    vec2 top = uv;\n    top.y -= 0.1 - T * 0.1;\n    top.y *= 1.0 - smoothstep(0.8, 1.0, T) * 0.25;\n    top.x *= 0.85;\n\n    float topDist = sdSegment(top, vec2(-0.6, 0.0), vec2(0.6, 0.0)) - 0.45;\n    vec2 bottom = uv * vec2(1.0, 1.0) + vec2(0.0, 0.425 + pow(T, 4.0) * 0.2);\n    float bottomDist = length(bottom) - 0.2;\n    float finalDist = smax(bottomDist, smax(eyeDist, topDist, 0.1), 0.5);\n\n    float sinTPi = sin(T * PI - 1.);\n    float smoothStepT = smoothstep(0.25, 1.05, mix(T, rawT2, 0.025));\n    float smoothStepEye = smoothstep(0.0, 0.1, -eyeDist);\n    float fov = (max(sinTPi, 0.0) - smoothStepT * 0.875) * smoothStepEye;\n\n    float disT = fov * 0.75;\n    vec2 distUV = distortion((fragCoord / iResolution.xy), disT, disT, T * smoothStepEye);\n    vec2 abeCo = vec2(0.0721, 0.0434) * smoothstep(0.2, 0.0, -eyeDist) * 2.5 * step(0.0, -eyeDist) * max(1.0 - T, 0.01);\n    vec3 cR = texture(iChannel0, distUV - abeCo.xy).xyz;\n    vec3 cG = texture(iChannel0, distUV - abeCo.yx).xyz;\n    vec3 cB = texture(iChannel0, distUV + abeCo.xx).xyz;\n\n    vec3 texC = vec3(cR.r, cG.g, cB.b);\n    float blurT = sin(max(rawT2, 0.0) * PI) * smoothStepEye * pow(T, 0.25);\n    texC = mix(texC, BlurredPixel(distUV, iChannel0), blurT);\n    texC.xyz = mix(texC.xyz - texC.xyz * smoothstep(0.0, 0.1, length(fract(uv * 600.0) - 0.5)) * 0.15 + vec3(0.03, 0.04, 0.075), texC.xyz, smoothstep(0.2, 0.0, -eyeDist));\n\n    texC *= 1.0 - sin(pow(T, 3.0) * PI) * 0.3 * step(smoothStepEye, 0.0);\n    texC = mix(vec3(dot(texC, vec3(0.333))), texC * 1.05, max(0.666, T * smoothStepEye + 0.05));\n    \n    vec3 outC = vec3(smoothstep(0.0, 0.3, finalDist));\n    outC = mix(texC, outC, smoothstep(0.08, 0.07999 - 0.025 * T, finalDist));\n    outC = mix(outC, vec3(1.0), max(-eyeDist, 0.0) * (1.0 - T));\n    outC += smoothstep(0.0, 0.075, -finalDist) * vec3(0.3, 0.3, 0.37) * 0.175;\n    outC *= mix(1.0, 1.0 - pow(length(distUV - 0.5), 5.0), T);\n\n    float tt = smoothstep(3.0, 3.75, modT);\n\n    fragColor = vec4(outC, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define C(c) d = min(char(p.xy, 64+c).w - 0.5, d); p.x -= 0.5;\n#define S p.x -= 0.5;\nvec4 char(vec2 p, int c) \n{\n    if (p.x< .0 || p.x> 1.0 || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);    \n\n\treturn texture( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n    \n    vec2 p = fragCoord / iResolution.xy;\n    vec2 op = p - vec2(0.0, 0.075);\n    float d = 1e5;\n    vec3 res = vec3(0.0);\n    p = op;\n    p *= 16.5;\n    p.y -= 10.25;\n    p.x -= 2.5;\n    \n    C(9); C(3); C(12 + 32); C(15 + 32); C(21 + 32); C(4 + 32); S;\n    C(19); C(20 + 32); C(15 + 32); C(18 + 32); C(1 + 32); C(7 + 32); C(5 + 32);  S;\n    C(9); C(19 + 32);  S;\n    C(6); C(21 + 32); C(12 + 32); C(12 + 32); \n\n\n    res = vec3(step(0.01, d));\n    d = 1e5;\n    p = op;\n    p *= 24.0;\n    p.y -= 12.5;\n    p.x -= 3.5;\n    \n    C(16); C(8 + 32); C(15 + 32); C(20 + 32); C(15 + 32); C(19 + 32); S; \n    C(22 + 32); C(9 + 32); C(4 + 32); C(5 + 32); C(15 + 32); S;\n    C(1 + 32); C(14 + 32); C(4 + 32); S;\n    C(9); C(3); C(12 + 32); C(15 + 32); C(21 + 32); C(4 + 32); S;\n    C(4); C(18 + 32); C(9 + 32); C(22 + 32); C(5 + 32);  S;\n    C(1 + 32); C(18 + 32); C(5 + 32);  S;\n    p.y += 2.0;\n    p.x = op.x * 24.0 - 7.5;\n    C(14 + 32); C(15 + 32);  S;\n    C(12 + 32); C(15 + 32); C(14 + 32); C(7 + 32); C(5 + 32); C(18 + 32);  S;\n    C(21 + 32); C(16 + 32); C(4 + 32); C(1 + 32); C(20 + 32); C(9 + 32); C(14 + 32); C(7 + 32); \n    \n    \n    res = mix(res, vec3(0.0), step(d, 0.01));\n    d = 1e5;\n    p = op;\n    p *= 18.0;\n    p.y -= 4.25;\n    p.x -= 5.0;  \n\n    C(21); C(16 + 32); C(7 + 32); C(18 + 32); C(1 + 32); C(4 + 32); C(5 + 32);  S; \n    C(19); C(20 + 32); C(15 + 32); C(18 + 32); C(1 + 32); C(7 + 32); C(5 + 32);\n    \n    p.y += 3.1;\n    p.x = op.x * 18.0 - 7.5;\n    res = mix(res, vec3(0.0, 0.0, 1.0), step(d, 0.01));\n    d = 1e5;\n        \n    C(3); C(12 + 32); C(15 + 32); C(19 + 32); C(5 + 32);\n    \n    res = mix(res, vec3(0.0, 0.0, 1.0), step(d, 0.001));\n\n    \n    fragColor = vec4(vec3(res), 1.0 - res.r);\n\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define t smoothstep(0.5, 2.0, modT)\n#define t2 1.0 \n\nvec2 shapeDist(vec3 p, float d, float z, float h) {\n    vec2 w = vec2(d, abs(p.z - z) - h);\n    return vec2(min(max(w.x, w.y), 0.0) + length(max(w, 0.0)), 1.0);\n}\n\nvec2 shapeDist(vec3 p, float d, float z) {\n    return shapeDist(p, d, z, 0.01);\n}\n\nvec2 getDistMat(vec3 p) {\n    vec2 res = vec2(MAX_DIST, 1.0);\n    p -= vec3(0.0, 0.0, 0.0);\n    p = rot(p, PI * -0.05 * t, vec3(0.0, 1.0, 0.0));\n\n    vec3 op = p;\n    p.y += 0.28;\n    p.y = abs(p.y) - 0.175;\n    float d = sdBox(p.xy, vec2(1.075, 0.005)) ;\n    vec2 newRes = shapeDist(p , d, 0.0, 0.011);\n    res.y = newRes.x > res.x ? res.x : 1.0;\n    res.x = min(newRes.x, res.x);\n    \n    p = op;\n    d = sdBox(p.xy + vec2(0.0, 0.025), vec2(1.0, 0.715)) - 0.1;\n    newRes = shapeDist(p, d, 0.0, 0.01);\n    res.y = newRes.x > res.x ? res.y : 2.0;\n    res.x = min(newRes.x, res.x);\n   \n    \n    return res;\n}\n\nfloat getDist(vec3 p) {\n    return getDistMat(p).x;\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float matId = -1.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        vec2 res = getDistMat(p);\n        float dS = res.x;\n        dO += dS;\n        matId = res.y;\n        \n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return vec2(dO, matId);\n}\n\nvec3 normals(vec3 p, float of ) {\n    float d = getDist(p);\n    vec2 e = vec2(of, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy),\n        getDist(p-e.yxy),\n        getDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat diffuse(vec3 p, vec3 n, vec3 lp) {\n    vec3 l = normalize(lp - p);\n    float dif = clamp(dot(n, l), 0., 1.);\n\n    return dif;\n}\n\nvec4 effect(in vec2 uv, vec3 c, float tt) {\n    vec2 camUV = uv;\n    uv =((uv * iResolution.xy)-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    vec3 ro = vec3(0.0, 0.0 + sin(modT * PI) * 0.1, -mix(2.0, 4.0, t));\n    vec3 rd = normalize(vec3(uv.x, uv.y , 1.0));\n    vec3 lp =  vec3(-2.0, 2.0, -3.0);\n    vec2 d = rayMarch(ro, rd);\n    vec3 p = ro + rd * d.x;\n    vec3 n = normals(p, 0.025);\n    float dif = diffuse(p, n, lp);\n    float f =  pow(max(1.0 - dot(n, -rd), 0.0), 2.0);\n    vec3 bCol = mix(texture(iChannel0, camUV, 7.0).xyz, texture(iChannel0, camUV, 8.0).xyz, 0.5);\n    col = bCol;\n    col *= mix(dif, 1.0, 0.75);\n    vec3 oCol = vec3(0.8, 0.85, 0.925);\n    col = mix(col, oCol, 0.15);\n    \n    if (d.y == 1.) {\n        col = bCol * 0.5 + oCol * 0.375;\n    } else if (d.y == 2.) {\n        p = rot(p, PI * -0.05 * t, vec3(0.0, 1.0, 0.0));\n        vec4 popup = texture(iChannel1, (p.xy - vec2(1.05, 1.05)) * 0.5);\n        col = mix(col, popup.xyz, popup.w) + f * 0.5;\n        col += oCol * 0.2;\n    }\n\n    float l = 0.0;\n    if (d.x > MAX_DIST) { col = vec3(0.0); }\n    \n    return vec4(col, d);\n }\n\n#define SAMPLES_PER_PIXEL 2\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pixelSize = 1.0 / iResolution.xy;\n    \n    vec3 col = vec3(0.0);\n    for (int i = 0; i < SAMPLES_PER_PIXEL; ++i) {\n        for (int j = 0; j < SAMPLES_PER_PIXEL; ++j) {\n            vec2 offset = pixelSize * vec2(i, j) / float(SAMPLES_PER_PIXEL);\n            vec2 sampleUv = uv + offset;\n            float r = PI * 0.25 * sin(iTime);\n            vec3 sampleCol = texture(iChannel0, sampleUv).xyz;\n            vec4 eff = effect(sampleUv, sampleCol, rawT2);\n            sampleCol = mix(sampleCol, sampleCol * smoothstep(MAX_DIST * 0.9, MAX_DIST, eff.w) + eff.xyz, smoothstep(0.3, 0.6, rawT3 * T));\n            col += sampleCol;\n        }\n    }\n\n    col /= float(SAMPLES_PER_PIXEL * SAMPLES_PER_PIXEL);\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Buffer C","description":"","type":"buffer"}]}