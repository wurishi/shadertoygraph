{"ver":"0.1","info":{"id":"WsjSRR","date":"1552681061","viewed":136,"name":"HW 1","username":"aredosbyk","description":".","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["none"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2   // make this 2 or 3 for antialiasing, make 1 to turn if off\n#define Mandelbulb 0 // make this 1 to turn it on - makes render slower\n\n\n//------------------------------------------------------------------\n// Distance functions\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdMandelbulb(vec3 pos) {\n    float Power = 8.0;\n    \n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 15 ; i++) {\n\t\tr = length(z);\n\t\tif (r>10.0) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n//------------------------------------------------------------------\n// Operation functions\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opI( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d2 : d1;\n}\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    // sky 0\n    vec2 res = vec2( 1e10, 0.0 );\n    \n    \n    // lamp - stand 2\n    res = opU( res, opU( opU (\n        \t\t\t\tvec2(sdBox( pos-vec3(0.0, -0.05, 0.0), vec3(0.15)), 2.0),\n\t\t\t\t\t\tvec2(sdCylinder(  pos-vec3( 0.0,0.0,0.0), vec2(0.05,1.0) ), 2.0 ) ),\n                        vec2(sdCappedCone( pos-vec3( 0.0, 1.0, 0.0), 0.05, 0.05, 0.2), 2.0) ) );\n    \n    // lamp - light 3\n    res = opU( res, vec2(sdSphere(pos-vec3(0.0, 1.2, 0.0), 0.2), 3.0) );\n    \n    // torus 4\n    res = opU( res, vec2( sdBox(   pos-vec3( -2.0,0.25, 0.0), vec3(0.5,0.1, 0.5) ),4.0 ) );\n    \n#if Mandelbulb\n    // mandelbulb 7\n    res = opU( res, vec2( sdMandelbulb(   pos-vec3( 0.0,1.0, 3.0)),7.0 ) );\n#else\n    // sphere 7\n    res = opU( res, vec2( sdSphere(   pos-vec3( 0.0,0.25, 2.0), 0.2),7.0 ) );\n#endif\n    \n    // mirror 105\n    res = opU( res, vec2( sdEllipsoid( pos-vec3(2.0,1.0, 0.0), vec3(0.05, 0.65, 0.85) ), 105.0 ) );\n    \n    // lens 106\n    res = opU( res, opI(\n        \t\t\tvec2(sdSphere(pos-vec3(0.0, 1.0, -2.3), 0.6), 106.0),\n                    vec2(sdSphere(pos-vec3(0.0, 1.0, -1.7), 0.6), 106.0)) );\n    \n    \n    return res;\n}\n\nvec2 map2( in vec3 pos )\n{\n    // sky 0\n    vec2 res = vec2( 1e10, 0.0 );\n    \n    \n    // lamp - stand 2\n    res = opU( res, opU( opU (\n        \t\t\t\tvec2(sdBox( pos-vec3(0.0, -0.05, 0.0), vec3(0.15)), 2.0),\n\t\t\t\t\t\tvec2(sdCylinder(  pos-vec3( 0.0,0.0,0.0), vec2(0.05,1.0) ), 2.0 ) ),\n                        vec2(sdCappedCone( pos-vec3( 0.0, 1.0, 0.0), 0.05, 0.05, 0.2), 2.0) ) );\n    \n    // lamp - light 3\n    res = opU( res, vec2(sdSphere(pos-vec3(0.0, 1.2, 0.0), 0.2), 3.0) );\n    \n    // torus 4\n    res = opU( res, vec2( sdBox(   pos-vec3( -2.0,0.25, 0.0), vec3(0.5,0.1, 0.5) ),4.0 ) );\n    \n#if Mandelbulb\n    // mandelbulb 7\n    res = opU( res, vec2( sdMandelbulb(   pos-vec3( 0.0,1.0, 3.0)),7.0 ) );\n#else\n    // sphere 7\n    res = opU( res, vec2( sdSphere(   pos-vec3( 0.0,0.25, 2.0), 0.2),7.0 ) );\n#endif\n\n    // mirror 105\n    res = opU( res, vec2( sdEllipsoid( pos-vec3(2.0,1.0, 0.0), vec3(0.05, 0.65, 0.85) ), 105.0 ) );\n    \n    \n    return res;\n}\n\nvec2 map3( in vec3 pos )\n{\n    // sky 0\n    vec2 res = vec2( 1e10, 0.0 );\n    \n    \n    // lamp - stand 2\n    res = opU( res, opU( opU (\n        \t\t\t\tvec2(sdBox( pos-vec3(0.0, -0.05, 0.0), vec3(0.15)), 2.0),\n\t\t\t\t\t\tvec2(sdCylinder(  pos-vec3( 0.0,0.0,0.0), vec2(0.05,1.0) ), 2.0 ) ),\n                        vec2(sdCappedCone( pos-vec3( 0.0, 1.0, 0.0), 0.05, 0.05, 0.2), 2.0) ) );\n    \n    // lamp - light 3\n    res = opU( res, vec2(sdSphere(pos-vec3(0.0, 1.2, 0.0), 0.2), 3.0) );\n    \n    // torus 4\n    res = opU( res, vec2( sdBox(   pos-vec3( -2.0,0.25, 0.0), vec3(0.5,0.1, 0.5) ),4.0 ) );\n    \n#if Mandelbulb\n    // mandelbulb 7\n    res = opU( res, vec2( sdMandelbulb(   pos-vec3( 0.0,1.0, 3.0)),7.0 ) );\n#else\n    // sphere 7\n    res = opU( res, vec2( sdSphere(   pos-vec3( 0.0,0.25, 2.0), 0.2),7.0 ) );\n#endif\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\n// Tetrahedrone trick\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, inout vec3 respos)\n{\n    vec2 res = vec2(-1.0,105);\n    while (res.y > 100.0) {\n    \tres = vec2(-1.0, -1.0);\n\t\t\n        float tmin = 1.0;\n        float tmax = 200.0;\n\n        // raytrace floor plane\n        float tp1 = (0.0-ro.y)/rd.y;\n        if( tp1>0.0 )\n        {\n            tmax = min( tmax, tp1 );\n            res = vec2( tp1, 1.0 );\n        }\n\n        // raymarch primitives \n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; ++i )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                break;\n            }\n            t += h.x;\n        }\n        \n        if(res.y > 105.5) {\n        \tro = ro + rd * res.x;\n            vec3 nor = calcNormal(ro);\n            ro = ro - nor * 0.002;\n            rd = rd - nor;\n            \n            float r = 6.1;\n            float l = 0.0001;\n            float m = 0.0;\n            while (r - l > 0.001) {\n                m = (l + r) / 2.0;\n                if (map(ro + m * rd).x > 0.0) {\n                \tr = m;    \n                } else {\n                    l = m;\n                }\n            }\n            \n            ro = ro + m * rd;\n            nor = calcNormal(ro);\n            ro = ro + nor * 0.002;\n            rd = rd - nor;\n            \n            continue;\n        }\n        \n        if(res.y > 104.5) {\n        \tro = ro + rd * res.x;\n            vec3 nor = calcNormal(ro);\n            ro = ro + nor * 0.002;\n            rd = reflect(rd, nor);\n            continue;\n        }\n        \n        \n    }\n    \n    respos = ro + rd * res.x;\n    return res;\n}\n\nfloat calcFirstshadow( in vec3 pos)\n{\n    vec3 rd = normalize(pos - vec3(0.0, 1.2, 0.0));\n    vec3 ro = vec3(0.0, 1.2, 0.0) + rd * 0.2001;\n    \n    \n    float tmin = 1.0;\n    float tmax = 200.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n    }\n    \n    float t = tmin;\n    float light = 5.0;\n    float realdist = length(pos - vec3(0.0, 1.2, 0.0)) * 0.7;\n\n    // raymarch primitives   \n    for( int i=0; i<70 && t<tmax; ++i )\n    {\n        vec2 h = map2( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            if (length(ro + rd * t - pos) < 0.01) {\n                return light / (1.0 + realdist + realdist * realdist);\n            } else {\n                return 0.0;\n            }\n            break;\n        }\n        if (h.x < 0.1) {\n            light = light * h.x / 0.1;    \n        }\n        t += h.x;\n    }\n    \n    return light / (1.0 + realdist + realdist * realdist);\n}\n\nfloat calcMirrorshadow( in vec3 pos)\n{\n    if (pos.x > 2.0) {\n        return 0.0;\n    }\n    \n    vec3 rd = normalize(pos - vec3(4.0, 1.2, 0.0));\n    vec3 ro = vec3(4.0, 1.2, 0.0) + rd * 0.2001;\n    \n    \n    float tmin = 1.0;\n    float tmax = 200.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n    }\n    \n    float t = tmin;\n    float light = 5.0;\n    float realdist = length(pos - vec3(4.0, 1.2, 0.0)) * 0.7;\n\n    // raymarch primitives \n\n    for( int i=0; i<70 && t<tmax; ++i )\n    {\n        vec2 h = map3( ro+rd*t );\n        if( abs(h.x)<(0.0001*t) )\n        { \n            if (length(ro + rd * t - pos) < 0.01) {\n                return light / (1.0 + realdist + realdist * realdist);\n            } else {\n                return 0.0;\n            }\n            break;\n        }\n        if (h.x < 0.1) {\n            light = light * h.x / 0.1;    \n        }\n        t += h.x;\n    }\n    \n    return light / (1.0 + realdist + realdist * realdist);\n}\n                         \nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec3 pos = vec3(0.0);\n    vec2 res = castRay(ro,rd,pos);\n    float t= res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material   \n        if (m > 6.5) {\n            col = vec3(0.8, 0.3, 0.3);\n        } else if (m > 3.5) {\n            col = vec3(0.3, 0.3, 0.8);\n        } else if (m > 2.5) {\n            return vec3(1.0);\n        } else if (m > 1.5) {\n            col = vec3(0.1);\n        } else {\n            float f = checkersGradBox( 5.0*pos.xz );\n            col = 0.3 + f*vec3(0.1);\n        }\n\n        // lighting\n        float light = calcAO( pos, nor )/2.0 + calcFirstshadow(pos) + calcMirrorshadow(pos);\n        col = col*light;\n\n        // fog\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime;\n\n    // camera\t\n    vec3 ro = vec3( 4.6*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.6*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( -0.5, -0.4, 0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}