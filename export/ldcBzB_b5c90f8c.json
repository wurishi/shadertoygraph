{"ver":"0.1","info":{"id":"ldcBzB","date":"1525946163","viewed":278,"name":"Lavatexture","username":"ihal","description":"Lava.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["lava"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nLava texture based on Fractal Brownian motion + domain warping as described by\nhttps://thebookofshaders.com/13/\n\nThe fbm is thresholded to generate floating rocks.\n\nColorblending modes (for glow etc) are based on their implementations in Adobe Photoshop.\n*/\n\n//-------------------------------------------------\n// Define colorscheme\n//-------------------------------------------------\nconst vec3 orange = vec3(0.65, 0.37, 0);\nconst vec3 middleRed1 = vec3(.5882, .2451, .1922);\nconst vec3 middleRed2 = vec3(.8196, .3451, .3176);\n\n//-------------------------------------------------\n// Noise & random-functions\n//-------------------------------------------------\n\nfloat rand(vec2 st){\n    //https://thebookofshaders.com/13/\n    return fract(sin(dot(st,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat noise(vec2 x) {\n    //https://thebookofshaders.com/11/\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n    float y = rand(vec2(.5));\n    float a = rand(i);\n    float b = rand(i + vec2(1., 0.0));\n    float c = rand(i + vec2(0.0, 1.));\n    float d = rand(i + vec2(1., 1.));\n    vec2 u = smoothstep(0.0, 1.0, f);\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 st) {\n    //https://thebookofshaders.com/13/\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    // Loop of octaves\n    for (int i = 0; i < 10; i++) {\n        value += amplitude * noise(st);\n        st *= 2.2;\n        amplitude *= .5;\n    }\n    return value;\n}\n//-------------------------------------------------\n// Some useful functions for changing colors etc\n//-------------------------------------------------\nvec3 rgbToYuv(vec3 rgb) {\n    mat3 transformation = mat3(0.299, 0.587, 0.114, \n                               -0.14713, -0.28886, 0.436,\n                              0.615, -0.51499, -0.10001);\n    return transformation * rgb;\n}\nvec3 yuvToRgb(vec3 yuv) {\n    mat3 transformation = mat3(1.0, 0.0, 1.13983, \n                               1.0, -0.39465, -0.5806,\n                              1.0, 2.03211, 0.0);\n    return transformation * yuv;\n}\nvec3 colorDodge(vec3 color) {\n    //https://photoblogstop.com/photoshop/photoshop-blend-modes-explained\n    vec3 dodgeBy = vec3(.5, .5, .5);\n    dodgeBy = vec3(1.0, 1.0, 1.0) - dodgeBy;\n    color /= dodgeBy;\n    return color;\n}\nvec3 colorBurn(vec3 color, vec3 burnBy) {\n    color = vec3(1.0, 1.0, 1.0) - color;\n    color /= burnBy;\n    return vec3(1.0, 1.0, 1.0) - color;\n}\nvec3 colorBurn(vec3 color) {\n    return colorBurn(color, vec3(.6));\n}\nvec3 colorScreen(vec3 bgcolor, vec3 addcolor) {\n    vec3 onevector = vec3(1.0, 1.0, 1.0);\n    bgcolor = onevector - bgcolor;\n    addcolor = onevector - bgcolor;\n    return onevector - (bgcolor * addcolor);\n}\nvec3 colorMultiply(vec3 bgcolor, vec3 addcolor) {\n    return bgcolor * addcolor;\n}\nvec3 colorOverlay(vec3 bgcolor, vec3 addcolor) {\n   \tvec3 yuvBg = rgbToYuv(bgcolor);\n    if (yuvBg.x > 0.5) {\n        return colorScreen(bgcolor, addcolor);\n    }\n    else {\n        return colorMultiply(bgcolor, addcolor);\n    }    \n}\n\n//-------------------------------------------------\n// Start of lava-specific stuff\n//-------------------------------------------------\n\nfloat getFlowSpots(vec2 uv, float sizeOfTexture) {\n    //Based on https://thebookofshaders.com\n    vec2 q = vec2(0.);\n    q.x = fbm( uv + .5 * iTime); //Some wobbliness (fake heat)\n    q.y = fbm( uv + vec2(1.0));\n    \n\tfloat speed = .1;\n    float wobbliness = .02;\n    vec2 r = vec2(0.);\n    r.x = .5 * fbm(.1* (uv + 1.0*q + vec2(5.,1.2) + wobbliness*iTime) );\n    r.y = speed * iTime + 1.01 * fbm(.1 * uv + wobbliness * iTime);\n\tfloat flowFactor = fbm(sizeOfTexture * (uv + r));\n    return flowFactor;\n}\n\nfloat getFlowSpots(vec2 uv, float sizeOfTexture, float speed) {\n    //Based on https://thebookofshaders.com\n    uv.y /= 1.2;\n    //uv.x /= 1.5;\n    vec2 q = vec2(0.);\n    q.x = fbm( uv + .5 * iTime); //Some wobbliness (fake heat)\n    q.y = fbm( uv + vec2(1.0));\n    \n\t//float speed = .4;\n    float wobbliness = .05;\n    vec2 r = vec2(0.);\n    r.x = .5 * fbm(.2* (uv + 1.0 * q + vec2(5.,1.2) + wobbliness*iTime) );\n    r.y = speed * iTime + .2 * fbm(3.8 * uv + wobbliness * iTime);\n\tfloat flowFactor = fbm(1.5 * (uv + r) * .9);\n    //flowFactor = clamp(flowFactor, .4, 1.7);\n    return flowFactor;\n}\n\n//Something more interesting can be done here\nfloat getLavaStoneTexture(vec2 uv, float f) {\n    return getFlowSpots(uv, f);\n}\n\nvec3 getColorOfDots(vec2 uv, float f) {\n    vec3 flowColor = colorBurn(middleRed1, .8 * vec3(f));\n\tfloat f2 = smoothstep(.4, 1., f);\n    f2 = smoothstep(0., 1., f);\n    flowColor = mix(colorDodge(orange), flowColor, f2);\n    f = smoothstep(.4, 1., f);\n    flowColor = mix(flowColor, flowColor * .3, f);\n    flowColor = mix(flowColor, colorMultiply(flowColor, vec3(.5)), getLavaStoneTexture(uv, 94.4));\n    return flowColor;\n}\n\n//Not entirely happy with the look; looks too much like clouds rather than a fluid.\nvec3 getColorOfBackgroundFlow(vec2 uv, float f) {\n    f = 1. - sin(f);\n    vec3 flowColor = colorBurn(middleRed1, vec3(f));\n\tfloat f2 = smoothstep(.4, 1., f);\n    f2 = smoothstep(0., 1., f);\n    flowColor = mix(colorDodge(orange), flowColor, f2);\n    f = smoothstep(.2, 1., f);\n    flowColor = mix(flowColor, flowColor * .3, f);\n    //flowColor = mix(flowColor, colorMultiply(flowColor, vec3(.5)), getLavaStoneTexture(uv, 10.));\n    \n    return  flowColor;\n}\n\nvec3 addGlowOfSpots(vec2 uv, float f, vec3 flowColor) {\n    vec3 glowColor = mix(orange, flowColor, smoothstep(.7, 1., f));\n    glowColor = mix(colorDodge(glowColor), flowColor, smoothstep(.9, 1., f));\n    return mix(flowColor, glowColor, smoothstep(.1, .8, f));\n}\n\nfloat lavaEdgeAnimator(float edge, vec2 uv) {\n\tfloat edgeMovement = 0.5 * (sin(iTime/2.0 + uv.y) + 1.0) * 0.3;\n    float mySin = .7 * (sin(iTime + uv.y) + 1.0);\n    float mySin2 = .7 * (sin(iTime + uv.y + 2.1415) + 1.0);\n    edge += mySin * edgeMovement; \n    edge += mySin2 * edgeMovement;\n\treturn edge;\n}\n\nvec3 addGlowToEdges(vec2 uv, float f, vec3 flowColor) {\n    float uvScaler = iResolution.x/iResolution.y;\n    float MWF = .1 * f * getFlowSpots(uv, 30.); \n    float edges = smoothstep(0.0 + .1 * MWF, MWF * 2., uv.x) - \n        smoothstep((1. - MWF) * uvScaler, (1.0 - .1 * MWF) * uvScaler, uv.x);\n    float edges2 = smoothstep(0.0 + .1 * MWF, MWF, uv.x) - \n        smoothstep((1. - MWF * .5) * uvScaler, (1.0 - .05 * MWF) * uvScaler, uv.x);\n    edges = lavaEdgeAnimator(edges, uv);\n    edges2 = lavaEdgeAnimator(edges2, uv);\n    //flowColor = mix(orange, flowColor, clamp(edges, .0, 1.));\n    flowColor = mix(orange, flowColor, clamp(edges2, .2, 1.));\n    return mix(colorDodge(flowColor), flowColor, clamp(edges, .2, 1.));\n}\n\nfloat filterEdgesOfLava(float f, vec2 uv) {\n    //We want the floating stuff to stay out of the edges.\n    //There should be a better way to do this though!\n    float uvScaler = iResolution.x/iResolution.y;\n    float MWF = .003 + .2 * f; \n    float edges = smoothstep(0.0 + .7 * MWF, MWF, uv.x) - \n        smoothstep((1. - MWF) * uvScaler, (1.0 - .3 * MWF) * uvScaler, uv.x);\n    f = mix(1.0, f, clamp(edges, .0, 1.));\n    return f;\n}\n\nfloat filterFlowToTexture(float f, vec2 uv) {\n    f += smoothstep(.3, .5, f) * .8 * (1. - f);\n    f = smoothstep(0., 1., f);\n    f = filterEdgesOfLava(f, uv);\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n\tfloat textureFlowSpots = getFlowSpots(uv, 4.4);\n    float textureBg = getFlowSpots(uv, 2.4, .13);\n    float spotBgDivider = 1. - textureFlowSpots;\n    spotBgDivider = filterFlowToTexture(spotBgDivider, uv);\n    \n    vec3 color = mix(getColorOfBackgroundFlow(uv, textureBg), getColorOfDots(uv, textureFlowSpots), step(spotBgDivider, .5));\n\tcolor = addGlowOfSpots(uv, spotBgDivider, color);\n    color = addGlowToEdges(uv, textureFlowSpots, color);\n    \n    fragColor = vec4(color, 1.);\n    /*\n\t//PRESENTATION DEMOS\n    //Thresholded demo\n    fragColor = vec4(vec3(spotBgDivider), 1.);\n    //Background FBM + warping demo\n    fragColor = vec4(vec3(textureBg), 1.);\n    //FBM + warping demo\n    fragColor = vec4(vec3(textureFlowSpots), 1.);\n    //FBM demo\n    fragColor = vec4(vec3(fbm(uv * 5.)), 1.);\n    //Noise demo\n    fragColor = vec4(vec3(noise(uv * 5.)), 1.);\n\t*/\n}","name":"Image","description":"","type":"image"}]}