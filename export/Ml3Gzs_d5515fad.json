{"ver":"0.1","info":{"id":"Ml3Gzs","date":"1470866360","viewed":368,"name":"Overcast Sky - Variable ","username":"CaliCoastReplay","description":"2.5d clouds, using hcf's really nice Perlin noise implementation at :  https://www.shadertoy.com/view/Md3SzB\n\nMouse up/down to change the level of cloud cover.  Mouse left/right to change zoom.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","3d","noise","clouds","zoom","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Adapted from  :  https://www.shadertoy.com/view/Md3SzB\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nfloat hash21(vec2 p)\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n\t\n    return  -1.+2.*fract(sin(h)*43758.5453123);\n}\n\nvec2 hash22(vec2 p)\n{\n    p = p*mat2(127.1,311.7,269.5,183.3);\n\tp = -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n\treturn sin(p*6.283 + iTime/4.0);\n}\n\nfloat perlin_noise(vec2 p)\n{\n\tvec2 pi = floor(p);\n    vec2 pf = p-pi;\n    \n    vec2 w = pf*pf*(3.-2.*pf);\n    \n    float f00 = dot(hash22(pi+vec2(.0,.0)),pf-vec2(.0,.0));\n    float f01 = dot(hash22(pi+vec2(.0,1.)),pf-vec2(.0,1.));\n    float f10 = dot(hash22(pi+vec2(1.0,0.)),pf-vec2(1.0,0.));\n    float f11 = dot(hash22(pi+vec2(1.0,1.)),pf-vec2(1.0,1.));\n    \n    float xm1 = mix(f00,f10,w.x);\n    float xm2 = mix(f01,f11,w.x);\n    \n    float ym = mix(xm1,xm2,w.y); \n    return ym;\n   \n}\n\nfloat noise(vec2 p){\n    p *= 4.;\n\tfloat a = 1., r = 0., s=0.;\n    \n    for (int i=0; i<9; i++) {\n      r += a*perlin_noise(p); s+= a; p *= 2.00; a*=.57;\n    }\n    \n    return r/s;///(.1*3.);\n}\n\n\nvec3 sphereProject(vec2 plane)\n{\n    vec3 r;\n    plane.x -= 0.55;\n    plane.y -= 0.35;\n    float denom = (1.0 + plane.x*plane.x + plane.y*plane.y);\n    r.x = (2.0*plane.x)/denom;    \n    r.y = (2.0*plane.y)/denom;\n    r.z = (1.0 - plane.x*plane.x+plane.y*plane.y)/denom;\n    return r*1.2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy \n        * 0.6;//+sin(iTime/5.0)/9.0);\n    \n    uv *= vec2(iResolution.x/iResolution.y,1.);\n    vec3 sphere = sphereProject(uv);\n    uv = sphere.xy/2.1;\n    if (iMouse.z > 0.0)        \n    \tuv = 0.6*sphere.xy*iMouse.x/iResolution.x;\n     \n    vec2 uv2 = uv + vec2(0.12253 + iTime/210.0,0.73483-iTime/90.3);\n    vec2 uv3 = uv + vec2(0.34646 - iTime/150.3,0.46436 - iTime/180.4);\n    vec2 uv4 = uv + vec2(0.98398 - iTime/34.5,0.11242 + iTime/100.7);\n    float f = noise(uv)/1.0;\n  //  f+= noise(uv2)/2.2;\n    f+= noise(uv3)/2.45;\n    f+= noise(uv4)/0.7;\n  \n    \n    f = f*0.35+0.55;\n    \n    vec3 lightColor = vec3(0.719,0.719,1.0);\t\n    vec3 color = vec3(lightColor*f);\n    \n    vec3 hsv = rgb2hsv(color);\n    hsv.z += 0.5;\n    \n    float cloudCoverFactor = 0.01; \n    if (iMouse.z > 0.0)\n       cloudCoverFactor = (iMouse.y / iResolution.y) / 2.0 - .261;\n    hsv.z *= hsv.z * hsv.z * sqrt(hsv.z)* 2.01 * (cloudCoverFactor + 0.91);\n    bool deblue = false;\n\tif (hsv.z > 2.75)\n    {\n        hsv.z =4.7 - hsv.z/2.11;\n        hsv.z -= 0.559;\n        deblue = true;\n    }\n    else\n    {\n     //   hsv.y *= 0.9;\n        hsv.z -= 0.041;\n    }\n    //hsv.y += 0.345;\n //   \n    hsv.y *= 2.2;\n    hsv.z -= 0.01;\n    color = hsv2rgb(hsv);\n    \n   \tif (deblue)\n    {\n        color.z = color.y = color.x * .91;\n        color.x -= 0.07;\n       \n    }\n\tfragColor = vec4(color,1.0);\n  \n}","name":"Image","description":"","type":"image"}]}