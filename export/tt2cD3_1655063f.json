{"ver":"0.1","info":{"id":"tt2cD3","date":"1595599420","viewed":70,"name":"Raytracing with refraction","username":"mlaang","description":"Refraction with spheres. Clicking in the window will show the sphere with which refraction can happen.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["refraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Parameters: Incoming ray: ray origin ro, ray direction rd\n *             Sphere: centre c, radius r\n *             Where the ray origin is outside the sphere.\n *             \n * Return value: If no intersection, a negative number,\n *               Otherwise the smallest positive t such that |ro + rd*t - c|=r\n */\nfloat ray_sphere_intersection(vec3 ro, vec3 rd, vec3 c, float r) {\n    //Is there some t so that the inequality dot(ro + rd*t - c, ro + rd*t - c) < r*r\n    //is satisfied?\n    //Let d = ro - c\n    \n    vec3 d = ro - c;\n    \n    //Then we have dot(d + rd*t, d + rd*t) < r*r\n    //Expanding, we obtain:\n    //dot(d,d) + dot(rd,rd)*t^2 + 2*dot(d,rd)*t < r*r\n    //Let e = r*r - dot(d,d)\n    \n    float e = r*r - dot(d,d);\n    \n    //Then the inequality is dot(rd,rd)*t^2 + 2*dot(d,rd)*t < e\n    //rd is chosen so that dot(rd,rd) is nonzero.\n    //Thus t^2 + 2*dot(d,rd)/dot(rd,rd)*t < e/dot(rd,rd).\n    //Let f = dot(d,rd)/dot(rd,rd) and g = e/dot(rd,rd);\n    \n    float f = dot(d,rd)/dot(rd,rd),\n          g = e/dot(rd,rd);\n    \n    //Then we have\n    //t^2 + 2f*t < g.\n    //Completing the square we obtain\n    //(t + f)^2 - f^2 < g.\n    //Let h = g + f^2\n    \n    float h = g + f*f;\n    \n    //Then the inequality is (t + f)^2 < h \n    //If h < 0 there is no solution. Otherwise the solution is the smallest number t\n    //such that (t+f)^2 = h.\n    \n    if(h < 0.0)\n        return -1.0;\n    else\n        return -sqrt(h)-f; //This is the smallest root of (t+f)^2=h for the reason that\n    \t\t\t\t\t   //f is always negative: this is because f = dot(d,rd)/dot(rd,rd)\n    \t\t\t\t\t   //and therefore has the same sign as dot(d,rd). d = ro - c\n    \t\t\t\t\t   //so dot(d,rd)=dot(ro-c,rd)= -dot(c-ro,rd); and c is always in front\n    \t\t\t\t\t   //of the ray, so c-ro is in the same direction as rd.\n}\n\n/* Parameters: Incoming ray: ray origin ro, ray direction rd\n *             Plane: normal plane_normal, point on the plane, plane_point.\n * Return value: If no intersection, a negative number,\n *               Otherwise the unique t such that ro + rd*t is on the plane.\n */\nfloat ray_plane_intersection(vec3 ro, vec3 rd, vec3 plane_normal, vec3 plane_point) {\n    //Is there some t so that dot(plane_normal, plane_point) = dot(plane_normal, ro + rd*t)?\n    //If so, that t is to be returned.\n    \n    //Bilinearity immediately ensures that\n    //dot(plane_normal, plane_point) = dot(plane_normal, ro) + dot(plane_normal, rd)*t\n    //Thus\n    //(dot(plane_normal, plane_point)-dot(plane_normal,ro))/dot(plane_normal, rd) = t\n    //This simplifies to\n    //dot(plane_normal, plane_point - ro)/dot(plane_normal, rd)=t\n    \n    //A solution exists if dot(plane_normal, rd) is not zero.    \n    if(dot(plane_normal, rd) == 0.0)\n        return -1.0;\n    else\n        return dot(plane_normal, plane_point - ro)/dot(plane_normal, rd);\n}\n\n/* Parameters: Incoming ray: ray origin ro, ray direction rd\n *             Sphere: centre c, radius r\n *             Where the ray origin is outside the sphere.\n *\n * Return value: If no intersection, a negative number,\n *               Otherwise the largest positive t such that |ro + rd*t - c|=r\n */\nfloat ray_antisphere_intersection(vec3 ro, vec3 rd, vec3 c, float r) {\n    //Calculating as in a ray-sphere intersection, but choosing the other root at the end.\n       \n    vec3 d = ro - c;\n    float e = r*r - dot(d,d);\n    float f = dot(d,rd)/dot(rd,rd),\n          g = e/dot(rd,rd);\n    float h = g + f*f;\n    \n    if(h < 0.0)\n        return -1.0;\n    else\n        return sqrt(h)-f; //This is the largest root of (t+f)^2=h for the same\n                          //reason that the corresponding return value in the ray_sphere_intersection\n                          //function is the smallest root.\n}\n\n/* Parameters: Interface: Ratio of refractive index in space before interface and refractive index\n *             after interface alpha. Normal direction normal.\n *\n *             Ray direction rd\n *\n * Input ray direction is overwritten by output ray direction.\n */\nvoid refract_ray(float alpha, vec3 normal, inout vec3 rd) {\n    //The vector form of Snell's law states that\n    //eta0 * cross(rd, N) = eta1 * cross(new_rd, N).\n    //Additionally, we know that N is a convex linear combination of the negative normal\n    //and rd.\n    //Thus we obtain new_rd = alpha*rd + beta*N\n    //We immediately obtain eta0/eta1 * cross(rd, N) = alpha*cross(rd, N) + beta*cross(N,N).\n    //cross(N,N)=0 so eta0/eta1 * cross(rd, N) = alpha*cross(rd, N)\n    //and we obtain\n    //alpha = eta0/eta1 * dot(cross(rd, N), cross(rd, N)) = alpha * dot(cross(rd, N), cross(rd, N))\n    //giving\n    //alpha = eta0/eta1\n    //This is the input alpha.\n    \n    //eta0<eta1, i.e. eta0/eta1 < 1, i.e. alpha < 1 the refracted ray will be closer to the negative normal\n    //when alpha > 1 it will be closer to the positive normal.\n    //beta is to be negative when alpha < 1 and positive otherwise.\n    //When alpha > 0 it remains to choose beta so that beta <= 0 and dot(new_rd, new_rd)=1.0.\n    //dot(new_rd, new_rd) = alpha*alpha*dot(rd, rd) + 2*alpha*beta*dot(rd, N) + beta*beta*dot(N, N) = 1.0\n    //First we note that dot(rd,rd)=dot(N,N)=1.0.\n    //alpha*alpha + 2*alpha*beta*dot(rd, N) + beta*beta = 1.0\n    //Since alpha is known we can simply solve for beta\n    \n    //(beta + alpha*dot(rd,N))^2 - alpha*alpha*dot(rd,N)^2 = 1.0\n    //beta + alpha*dot(rd,N) = +-sqrt(1.0 + alpha*alpha*dot(rd, N)^2)\n    \n    //The negative root will ensure that beta will be negative\n    //beta = -sqrt(1.0 + alpha*alpha*dot(rd, N)^2) - alpha*dot(rd,N)\n    //and the positive root that beta will be positive.\n    \n    float cosine = dot(rd, normal);\n    float beta = sign(alpha - 1.0)*sqrt(1.0 + alpha*alpha*cosine*cosine) - alpha*cosine;\n    \n    rd = alpha*rd + beta*normal;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from -1.0 to 1.0) \n    vec2 uv = (2.0*fragCoord.xy - iResolution.xy)/min(iResolution.x, iResolution.y);\n\n    \n    // Camera: ray origin and direction\n    vec3 ro = vec3(0.0, 0.0, -5.0);\n    vec3 camera_direction = vec3(0.0, 0.0, 0.0) - ro;\n    vec3 rd = vec3(uv.xy, 0.0)-ro;\n    \n    //Objects\n    \n    //Large central sphere (object 0), having an antisphere on its surface.\n    vec3 c1 = vec3(0.0, 2.0*(0.7+0.3*sin(iTime)-0.5), 0.0);\n    float r1 = 0.9;\n    \n    vec3 ac1 = vec3(1.3, 2.0*(0.7+0.3*sin(iTime)-0.5), -1.0);\n    float ar1 = 1.0;\n    \n    vec3 ac2 = vec3(0.0, 2.0*(0.7+0.3*sin(iTime)-0.5), -1.0);\n    float ar2 = 0.3;\n    \n    //Smaller sphere orbiting around the large central sphere (object 1).\n    vec3 c2 = vec3(1.5*sin(iTime), 0.0, 1.5*cos(iTime));\n    float r2 = 0.2;\n    \n    //Plane (object 2).\n    vec3 plane_normal = vec3(0.0, 1.0, 0.0);\n    vec3 plane_point = vec3(0.0, -0.5, 0.0);\n    \n    //Sphere (object 3).\n    vec3 c3 = vec3(-2.5*cos(-iTime), 0.0, 2.5*sin(-iTime));\n    float r3 = 0.15;\n    \n    //Transparent sphere (object 6)\n    vec3 c4 = vec3(iMouse.x/iResolution.x - 0.5, iMouse.y/iResolution.y - 0.5, -4.0);\n    float r4 = 0.15;\n    \n    vec3 col = vec3(0.0, 0.0, 0.0),\n         multiplier = vec3(1.0, 1.0, 1.0);\n    \n    float t[7];\n    const float epsilon = 0.000001;\n    \n    for(int j = 0; j != 15; ++j) {\n        t[0] = ray_sphere_intersection(ro, rd, c1, r1);\n        t[1] = ray_sphere_intersection(ro, rd, c2, r2);\n        t[2] = ray_plane_intersection(ro, rd, plane_normal, plane_point);\n        t[3] = ray_sphere_intersection(ro, rd, c3, r3);\n        t[4] = ray_antisphere_intersection(ro, rd, ac1, ar1);\n        t[5] = ray_antisphere_intersection(ro, rd, ac2, ar2);\n        t[6] = ray_sphere_intersection(ro, rd, c4, r4);\n        \n        //In general, hits within a distance epsilon are disallowed and are to be ignored.\n        //This is because we are not nudging the intersection points to ensure that they are\n        //on the near side of the surface with which we intersect the ray, this in order\n        //to compute more exact reflections.\n        \n        //That having been said, we will now be concerned with resolving antisphere issues:\n        \n        //If the antisphere is not hit then we are not concerned with it\n        //if it is hit, however, a bunch of situations arise:\n        \n        //A hit going thorough the antisphere can hit the sphere or other objects\n        //this happens when the intersection with the antisphere lies outside the sphere\n        //and in that case the antisphere is to be ignored:\n        \n        if(t[4] > epsilon && dot(ro + rd*t[4]-c1, ro + rd*t[4]-c1) > r1*r1)\n            t[4] = -1.0;\n        \n        //Alternatively, a hit going through the antisphere can hit the concave surface\n        //defined by the antisphere. Then we must however ignore the sphere.\n        \n        if(t[4] > epsilon && dot(ro + rd*t[4]-c1, ro + rd*t[4]-c1) <= r1*r1)\n            t[0] = -1.0;\n        \n        //Finally we do it the same way for the second antisphere.\n        if(t[5] > epsilon && dot(ro + rd*t[5]-c1, ro + rd*t[5]-c1) > r1*r1)\n            t[5] = -1.0;\n        if(t[5] > epsilon && dot(ro + rd*t[5]-c1, ro + rd*t[5]-c1) <= r1*r1)\n            t[0] = -1.0;\n        \n        int chosen_object_along_ray = -1;\n        for(int i = 0; i != 7; ++i)\n            if(t[i] > epsilon)\n                chosen_object_along_ray = i;\n            \n        if(chosen_object_along_ray != -1)\n            for(int i = 0; i != 7; ++i)\n                if(t[i] < t[chosen_object_along_ray] && t[i] > epsilon)\n                    chosen_object_along_ray = i;\n                \n        vec3 intersection_point,\n             normal_component,\n             remainder,\n             new_direction;\n                \n        switch(chosen_object_along_ray) {\n            case 0:\n                //If we end up here we've hit object zero, a sphere, but not the antisphere\n                //that is part of this object.\n                    \n                intersection_point = ro + rd * t[0];\n                vec3 sphere_normal = normalize(intersection_point - c1);\n                    \n                //It is necessary to ensure that the intersection point is outside the sphere,\n                //or the next intersection of the ray may be with the sphere itself.\n            \n                //The incoming ray can be split into a component along the sphere normal and a remainder\n                \n                normal_component = sphere_normal * dot(rd, sphere_normal);\n                remainder = rd - normal_component;\n            \n                //The remainder will not be affected by being reflected\n                //But the normal component will be negated\n            \n                new_direction = remainder - normal_component;\n            \n                //We now have a new ray:\n                //with origin intersection_point and direction new_direction.\n                //We want to return the colour of whatever that hits\n            \n                ro = intersection_point;\n                rd = new_direction;\n            \n                col += (multiplier * vec3(0.0, 1.0, 0.0));\n                multiplier *= vec3(0.9, 0.9, 0.9);\n                break;\n            case 1:\n                col += (multiplier*vec3(1.0, 1.0, 1.0));\n                multiplier = vec3(0.0, 0.0, 0.0);\n                break;\n            case 2:\n                intersection_point = ro + rd * t[2];\n                \n                //The incoming ray is split into a component along the plane normal and a remainder\n            \n                normal_component = plane_normal * dot(rd, plane_normal);\n                remainder = rd - normal_component;\n            \n                //The remainder will not be affected by being reflected, but the normal component\n                //will be negated\n            \n                new_direction = remainder - normal_component;\n            \n                //We now have a new ray:\n            \n                ro = intersection_point;\n                rd = new_direction;\n            \n                col += (multiplier * vec3(0.0, 0.0, 0.7));\n                multiplier *= vec3(0.9, 0.9, 0.9);\n                break;\n            case 3:\n                col += (multiplier * vec3(1.0, 0.0, 0.0));\n                multiplier = vec3(0.0, 0.0, 0.0);\n            \n                //Because this is terminal and sets the multiplier vector to the zero vector\n                //it doesn't matter that we do not calculate a new ray.\n                break;\n            case 4:\n                //If we end up here we've hit both the antisphere and the sphere.\n                //We thus need to compute things as if though we hit the negative normal of\n                //the sphere that is the antisphere.\n                    \n                intersection_point = ro + rd * t[4];\n                   \n                vec3 antisphere_normal = -normalize(intersection_point - ac1);\n                    \n                normal_component = antisphere_normal * dot(rd, antisphere_normal);\n                remainder = rd - normal_component;\n                    \n                new_direction = remainder - normal_component;\n                    \n                ro = intersection_point;\n                rd = new_direction;\n                    \n                col += multiplier*vec3(0.0, 1.0, 0.0);\n                multiplier *= vec3(0.9, 0.9, 0.9);\n                break;\n            case 5:\n                //Here we do it the same way as above, but again\n            \n                intersection_point = ro + rd*t[5];\n                antisphere_normal = -normalize(intersection_point - ac2);\n                normal_component = antisphere_normal * dot(rd, antisphere_normal);\n                remainder = rd - normal_component;\n                new_direction = remainder - normal_component;\n                ro = intersection_point;\n                rd = new_direction;\n            \n                col += multiplier*vec3(0.0, 1.0, 0.0);\n                multiplier *= vec3(0.9, 0.9, 0.9);\n                break;\n            case 6:\n                intersection_point = ro + rd*t[6];\n                sphere_normal = normalize(intersection_point - c4);\n                refract_ray(1.0/1.9, sphere_normal, rd);\n                float s = ray_antisphere_intersection(intersection_point, rd, c4, r4);            \n                intersection_point = intersection_point + s*rd;\n                sphere_normal = normalize(intersection_point - c4);\n                refract_ray(1.9/1.0, sphere_normal, rd);\n                ro = intersection_point;\n        }\n    }\n        \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}