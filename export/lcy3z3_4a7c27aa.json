{"ver":"0.1","info":{"id":"lcy3z3","date":"1713052644","viewed":48,"name":"StylizedSky","username":"Fueredoriku","description":"Skybox demo for Red Planet Rampage\n\nCredits for part of the cloud SDF -> https://www.shadertoy.com/view/4t23RR","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","skybox","toony"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 hash( vec2 p )\n{\n    //p = mod(p, 4.0); // tile\n    p = vec2(dot(p,vec2(127.1,311.7)),\n             dot(p,vec2(269.5,183.3)));\n    return fract(sin(p)*18.5453);\n}\n\n// return distance, and cell id\nvec2 voronoi( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec2  o = hash( n + g );\n        vec2  r = g - f + o;\n\t    //vec2  r = g - f + (0.5+0.5*sin(iTime/10.+6.2831*o));\n\t\tfloat d = dot( r, r );\n        if( d<m.x )\n            m = vec3( d, o );\n    }\n\n    return vec2( sqrt(m.x), m.y+m.z );\n}\n\nvec2 wobble(vec2 position)\n{\n\tconst float frequency = 80.;\n\tconst float amount = 0.012;\n\tfloat offset = iTime/10.;\n\toffset = mod(offset, 6.283185 / frequency);\n\tposition += offset;\n\tvec2 wobble = vec2(0.0, sin(position.y * frequency) * amount);\n\tposition = position + wobble;\n\tposition -= offset;\n\treturn position;\n}\n\n\nfloat CloudGround(float pX)\n{\n\treturn 0.6*(0.5*sin(0.1*pX) + 0.5*sin(0.553*pX) + 0.7*sin(1.2*pX));\n}\n\n\nfloat CloudRound(float pX)\n{\n\treturn 0.5 + 0.25*(1.0 + sin(mod(40.0*pX, 6.283)));\n}\n\nfloat sdCutDisk( in vec2 p, in float r, in float h)\n{\n    float w = sqrt(r*r-h*h); // constant for a given shape\n    \n    p.x = abs(p.x);\n    \n    // select circle or segment\n    float s = max( (h-r)*p.x*p.x+w*w*(h+r-2.0*p.y), h*p.x-w*p.y );\n\n    return (s<0.0) ? length(p)-r :        // circle\n           (p.x<w) ? h - p.y     :        // segment line\n                     length(p-vec2(w,h)); // segment corner\n}\n\n\nfloat limited_repeated_skies( vec2 p, float offset)\n{\n\tvec2 Qt = 3.5*p;\n\toffset *= 0.5;\n\tQt.x += offset;\n\n\tfloat Xi = floor(Qt.x);\n\tfloat Xf = Qt.x - Xi -0.5;\n\n\tvec2 C;\n\tfloat Yi;\n\tfloat D = 1. - step(Qt.y,  CloudGround(Qt.x));\n\n\t// Disk:\n\tYi = CloudGround(Xi + 0.5);\n\tC = vec2(Xf, Qt.y - Yi ); \n\tD =  min(D, length(C) - CloudRound(Xi+ offset/80.0));\n\n\t// Previous disk:\n\tYi = CloudGround(Xi+1.0 + 0.5);\n\tC = vec2(Xf-1.0, Qt.y - Yi ); \n\tD =  min(D, length(C) - CloudRound(Xi+1.0+ offset/80.0));\n\n\t// Next Disk:\n\tYi = CloudGround(Xi-1.0 + 0.5);\n\tC = vec2(Xf+1.0, Qt.y - Yi ); \n\tD =  min(D, length(C) - CloudRound(Xi-1.0+ offset/80.0));\n\n\treturn min(1.0, D);\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n\n\treturn d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\n\nfloat repeatedRhombus(in vec2 position, in vec2 rhombusSize )\n{\n    const int   n = 8;\n    const float b = 6.283185/float(n);\n    float a = atan(position.y, position.x);\n    float i = floor(a/b);\n\n    float c1 = b*(i+0.0); vec2 p1 = mat2(cos(c1),-sin(c1),sin(c1), cos(c1))*position;\n    float c2 = b*(i+1.0); vec2 p2 = mat2(cos(c2),-sin(c2),sin(c2), cos(c2))*position;\n\n    return min(sdRhombus(p1/(sin(c1 + iTime/7.)), rhombusSize ), sdRhombus(p2/(sin(c2 + iTime/7.)), rhombusSize ) );\n}\n\nfloat sdStar5(in vec2 p, in vec2 id, in float r, in float rf)\n{\n    r += 0.3 - sin(iTime + sin(id.x) - cos(id.x) * 0.3)*0.2;\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 dNoise = voronoi(id);\n    p += dNoise;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nfloat mirroredStars( vec2 p, float s )\n{\n    vec2 id = round(p/s);\n    vec2  o = sign(p-s*id); // neighbor offset direction\n    \n    float d = 1e20;\n    for( int j=0; j<2; j++ )\n    for( int i=0; i<2; i++ )\n    {\n        vec2 rid = id + vec2(i,j)*o;\n        vec2 r = p - s*rid;\n        d = min( d, sdStar5(r*25., rid, 1., 0.5));\n    }\n    return d;\n}\n\n\nfloat solarSdf(in vec2 position, inout vec4 sunColor)\n{\n    float d = length(wobble(position)) - 0.27;\n    sunColor = (d > 0.0) ? sunColor : vec4(1., 0.8, 0., 1.);\n    float dShine = min(length(position) - 0.2, repeatedRhombus(position, vec2(0.6f, 0.05f)));\n    sunColor = (dShine > 0.0) ? sunColor : vec4(1., 1., 1., 1.);\n    \n    return min(d, dShine);\n}\nfloat sMax(float x, float y)\n{\n    return log(exp(x*20.) + exp(y* 6.))/20.; \n}\nfloat cloudSdf(in vec2 position, vec2 id, inout vec4 cloudColor)\n{\n    vec2 hashedId = hash(id);\n    float i = 0.5;\n    float Lt =  (iTime + hashedId.x)*(0.5  + 2.0 * i)*(1.0 + 0.1 * sin(226.0 * i)) + 17.0*i;\n    vec2 Lp = vec2(0.0, 0.3+1.5*( i - 0.5));\n    float d = sMax(limited_repeated_skies(position + Lp + hashedId, Lt ), sdCutDisk(position * 2. + vec2(0.0, 1.4 + hashedId*0.1 ), 2.0 - hashedId.x*0.002, 0.2) );\n    cloudColor = d > 0.05 ? cloudColor : vec4(0.8, 0.8,0.8,0.8);\n    cloudColor = d > 0.0 ? cloudColor : vec4(1., 1.,1.,1.);\n    \n    return d;\n}\n\nfloat mirroredClouds( vec2 p, float s, inout vec4 color )\n{\n    vec2 id = round(p/s);\n    vec2  o = sign(p-s*id); // neighbor offset direction\n    \n    float d = 1e20;\n    for( int j=0; j<2; j++ )\n    for( int i=0; i<2; i++ )\n    {\n        vec2 rid = id + vec2(i,j)*o;\n        vec2 r = p - s*rid;\n        d = min( d, cloudSdf(r*25. + vec2(0.0, 0.2), rid, color));\n    }\n    return d;\n}\n\nfloat skyBackground(in vec2 position, inout vec4 skyColor)\n{\n    float d = mirroredStars(position, 0.1);\n    skyColor = d > 0.0 ? skyColor : vec4(1.,1.,0.8,1.);\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec4 col = vec4(0.,0.,1.,1.) * (1. - uv.y*0.5); \n    \n    float d = skyBackground(uv * 0.8 + vec2(iTime*0.1, 0.0), col);\n    d = min(d, solarSdf(uv + vec2(-0.8,-0.4), col));\n    vec4 preColor = col;\n    d = min(d, mirroredClouds(uv * 0.04 + vec2(iTime/20., 0.1), 0.1 , col));\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}