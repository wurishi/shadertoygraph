{"ver":"0.1","info":{"id":"43dGzB","date":"1716716619","viewed":39,"name":"play with voronoi","username":"letbonsaibe","description":"learn voronoi \n- The art of code: https://www.youtube.com/watch?v=l-07BXzNdPw&ab_channel=TheArtofCode\n- iq:  https://iquilezles.org/articles/voronoilines/","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define animated\n\n// from https://www.shadertoy.com/view/ldl3W8\nvec2 hash22( vec2 p )\n{\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// return (distance, index)\nvec2 bruteForceVoronoi(vec2 uv, float pointCount) {\n    float t = iTime*.5;\n    float cellIdx = 0.;\n    float minDist = 100.;\n\n    for (float i = 0.; i < pointCount; i++) {\n        vec2 n = hash22(vec2(i));\n        vec2 p = sin(n*t);\n        \n        float d = length(uv-p);\n        \n        if (d < minDist) {\n            minDist = d;\n            cellIdx = i;\n        } \n    }\n    \n    return vec2(minDist, cellIdx);\n} \n\n// return (euclidean distance,  index.x, index.y)\nvec3 gridVoronoi(vec2 uv, float scale) {\n    uv *= scale;\n    vec2 gv = fract(uv) -.5;\n    gv *= 2.0;\n    vec2 id = floor(uv);\n    vec2 cid = id;\n    \n    \n    float t = iTime*.5;\n    float cellIdx = 0.;\n    float minDistance = 100.;\n    \n    for (float y =-1.; y <=1.; y++){\n    for (float x =-1.; x <=1.; x++){\n        vec2 offs = vec2(x,y);\n        vec2 n = hash22(id+offs);\n        vec2 p = offs;\n        \n        #ifdef animated\n        p += sin(n*t);\n        #else\n        p += sin(n-0.2123);\n        #endif\n        \n        \n        p = gv - 2.0*p;\n        float ed = length(p);\n        // manhattan distance\n        float md = abs(p.x) + abs(p.y);\n        \n        if (ed < minDistance){\n            minDistance = ed;\n            cid = id +offs;\n        }\n    }}\n    \n    return vec3(minDistance, cid);\n}\n\n// return (closest disance, second closest distance )\nvec2 closest12Voronoi(vec2 uv, float scale) {\n    uv *= scale;\n    vec2 gv = fract(uv) -.5;\n    gv *= 2.0;\n    vec2 id = floor(uv);\n    vec2 cid = id;\n    \n    \n    float t = iTime*.5;\n    float cellIdx = 0.;\n    vec2 cloest12Distance = vec2(100.0);\n    \n    for (float y =-1.; y <=1.; y++){\n    for (float x =-1.; x <=1.; x++){\n        vec2 offs = vec2(x,y);\n        vec2 n = hash22(id+offs);\n        vec2 p = offs;\n        #ifdef animated\n        p += sin(n*t);\n        #else\n        p += sin(n-0.2123);\n        #endif\n        \n        p = gv - 2.0*p;\n        float ed = length(p);\n        \n        if (ed < cloest12Distance.x){\n            cloest12Distance.y = cloest12Distance.x;\n            cloest12Distance.x = ed;\n        } else if (ed < cloest12Distance.y) {\n            cloest12Distance.y  = ed;\n        }\n    }}\n    \n    return cloest12Distance;\n}\n\n\n// return (closest disance, distance to edge )\nvec2 dinstance2edgeVoronoi(vec2 uv, float scale) {\n    vec2 oA, oB;\n\n\n    uv *= scale;\n    vec2 gv = fract(uv) -.5;\n    gv *= 2.0;\n    vec2 id = floor(uv);\n    vec2 cid = id;\n    \n    \n    float t = iTime*.5;\n    float cellIdx = 0.;\n    vec2 cloest12Distance = vec2(100.0);\n    \n    for (float y =-1.; y <=1.; y++){\n    for (float x =-1.; x <=1.; x++){\n        vec2 offs = vec2(x,y);\n        vec2 n = hash22(id+offs);\n        vec2 p = offs;\n        #ifdef animated\n        p += sin(n*t);\n        #else\n        p += sin(n-0.2123);\n        #endif\n        \n        p = 2.0*p - gv;\n        float ed = length(p);\n        \n        if (ed < cloest12Distance.x){\n            cloest12Distance.y = cloest12Distance.x;\n            cloest12Distance.x = ed;\n            oA = p;\n        } else if (ed < cloest12Distance.y) {\n            cloest12Distance.y  = ed;\n            oB = p;\n        }\n    }}\n    \n    float d2 = abs(dot( (oA + oB) * .5,normalize(oB-oA)));\n    \n    return vec2(cloest12Distance.x, d2);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    //vec2 v1 = bruteForceVoronoi(uv, 50.);\n    //col += v1.x;\n    \n    float scale = 1.0;\n    vec3 c = gridVoronoi(uv, scale);\n    // each piece\n    col.gb = (c.yz + vec2(5.0)) / 10.0;\n    // feature point\n\tcol += vec3(1.0,0.6,0.1)*(1.0-smoothstep( 0.0, 0.1, c.x));\n    \n\n    //vec2 cloest12Distance = closest12Voronoi(uv, scale);\n    //float d = cloest12Distance.y - cloest12Distance.x;\n    //col += 1.0 - smoothstep(0.0,0.05, d);\n\n        \n    vec2 cloest12Distance = dinstance2edgeVoronoi(uv, scale);\n    col += 1.0 - smoothstep(0.0,0.05, cloest12Distance.y) ;\n\n      \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}