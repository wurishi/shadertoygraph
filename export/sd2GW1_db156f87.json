{"ver":"0.1","info":{"id":"sd2GW1","date":"1617361983","viewed":336,"name":"Fork Neon Dance audioreactive","username":"Chaotnix","description":"forked from https://www.shadertoy.com/view/7sX3WNJust added mic input\n\noriginal description:\n\nRaymarching a heightmap with fixed steps and binary search. 2D Mandelbox fractal variation used for animated coloring.","likes":2,"published":1,"flags":4,"usePreview":0,"tags":["fractal","terrain","audioreactive"],"hasliked":0,"parentid":"7sX3WN","parentname":"Neon Dance"},"renderpass":[{"inputs":[{"id":"XdXGRr","filepath":"/presets/mic.png","previewfilepath":"/presets/mic.png","type":"mic","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float st=.025, maxdist=15.;\nvec3 ldir=vec3(0.,-1.,-1.),col=vec3(0.);\n\nmat2 rot(float a) {\n\tfloat s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nvec3 fractal(vec2 p) {\n    vec2 pos=p;\n    float d, ml=100.;\n    vec2 mc=vec2(100.);\n    p=abs(fract(p*.1)-.5);\n    vec2 c=p;\n    for(int i=0;i<8;i++) {\n        d=dot(p,p);\n        p=abs(p+1.)-abs(p-1.)-p;\n    \tp=p*-1.5/clamp(d,.5,1.)-c;\n        mc=min(mc,abs(p));\n        if (i>2) ml=min(ml*(1.+float(i)*.1),abs(p.y-.5));\n    }\n    mc=max(vec2(0.),1.-mc);\n    mc=normalize(mc)*.8;\n    ml=pow(max(0.,1.-ml),6.);\n    return vec3(mc,d*.4)*ml*(step(.7,fract(d*.1+iTime*.5+pos.x*.2)))-ml*.1;\n}\n\nfloat map(vec2 p) {\n    vec2 pos=p;\n    float t=iTime;\n    col+=fractal(p);\n    vec2 p2=abs(.5-fract(p*8.+ pow(texture(iChannel0, vec2(0.1, .25)).r, 2.0f) * 1.0f));\n\tfloat h=0.;\n    h+=sin(length(p)+t);\n    p=floor(p*pow(texture(iChannel0, vec2(0.1, .25)).r, 0.5f) * 2.0f+1.);\n    float l=length(p2*p2);\n    h+=(cos(p.x+t)+sin(p.y+t))*.5;\n    h+=max(0.,5.-length(p-vec2(18.,0.)))*1.5;\n    h+=max(0.,5.-length(p+vec2(18.,0.)))*1.5;\n    p=p*2.+.2345;\n    t*=.5;\n    h+=(cos(p.x+t)+sin(p.y+t))*pow(texture(iChannel0, vec2(0.1, .1)).r, 0.7f);\n    return h;\n}\n\nvec3 normal(vec2 p, float td) {\n\tvec2 eps=vec2(0.,.001);\n    return normalize(vec3(map(p+eps.yx)-map(p-eps.yx),2.*eps.y,map(p+eps.xy)-map(p-eps.xy)));\n}\n\nvec2 hit(vec3 p) {\n    float h=map(p.xz);\n    return vec2(step(p.y,h),h);\n}\n\nvec3 bsearch(vec3 from,vec3 dir,float td) {\n    vec3 p;\n    st*=-.5;\n    td+=st;\n    float h2=1.;\n    for (int i=0;i<20;i++) {\n        p=from+td*dir;\n        float h=hit(p).x;\n        if (abs(h-h2)>.001) {\n            st*=-.5;\n\t        h2=h;\n        }\n        td+=st;\n    }\n\treturn p;\n}\n\nvec3 shade(vec3 p,vec3 dir,float h,float td) {\n    ldir=normalize(ldir);\n\tcol=vec3(0.);\n    vec3 n=normal(p.xz,td);\n\tcol*=.25;\n    float dif=max(0.,dot(ldir,-n));\n    vec3 ref=reflect(ldir,dir);\n    float spe=pow(max(0.,dot(ref,-n)),8.);\n    return col+(dif*.5+.2+spe*vec3(1.,.8,.5))*.2;\n}\n\n\nvec3 march(vec3 from,vec3 dir) {\n\tvec3 p, col=vec3(0.);\n    float td=.5, k=0.;\n    vec2 h;\n    for (int i=0;i<600;i++) {\n    \tp=from+dir*td;\n        h=hit(p);\n        if (h.x>.5||td>maxdist) break;\n        td+=st;\n    }\n    if (h.x>.5) {\n        p=bsearch(from,dir,td);\n    \tcol=shade(p,dir,h.y,td);\n    } else {\n    }\n\tcol=mix(col,2.*vec3(mod(gl_FragCoord.y,4.)*.1),pow(td/maxdist,3.));\n    return col*vec3(.9,.8,1.);\n}\n\nmat3 lookat(vec3 dir,vec3 up) {\n\tdir=normalize(dir);vec3 rt=normalize(cross(dir,normalize(up)));\n    return mat3(rt,cross(rt,dir),dir);\n}\n\nvec3 path(float t) {\n\treturn vec3(cos(t)*5.5,1.5-cos(t)*.0,sin(t*2.))*2.5;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\tfloat t=iTime*.2;\n    vec3 from=path(t);\n    vec3 dir=normalize(vec3(uv,.7));\n    vec3 adv=path(t+.1)-from;\n    dir=lookat(adv+vec3(0.,-.2-(1.+sin(t*2.)),0.),vec3(adv.x*.1,1.,0.))*dir;\n    vec3 col=march(from, dir)*1.5;\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}