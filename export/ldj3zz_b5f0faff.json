{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"cubemap","id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"\n/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n*/\n\n//=======================================================================================\n\n#define FLT_MAX 3.402823466e+38\n\n//=======================================================================================\nstruct SMaterial\n{\n\tfloat m_diffuse;\n\tvec3 m_diffuseColor;\n\tfloat m_specular;\n\tvec3 m_specularColor;\n\tvec3 m_emissiveColor;\n\tfloat m_refraction;\n\tfloat m_refractionIndex;\n};\n\n//=======================================================================================\nstruct SCollisionInfo\n{\n\tint\t\t\tm_Id;\n\tbool\t\tm_foundHit;\n\tbool \t\tm_fromInside;\n\tfloat \t\tm_collisionTime;\n\tvec3\t\tm_intersectionPoint;\n\tvec3\t\tm_surfaceNormal;\n\tvec2\t\tm_textureCoordinates;\n\tSMaterial \tm_material;\n};\n\n//=======================================================================================\nstruct SSphere\n{\n\tint\t\t\tm_Id;\n\tvec3   \t\tm_center;\n\tfloat  \t\tm_radius;\n\tSMaterial\tm_material;\n};\n\t\n//=======================================================================================\nstruct SAxisAlignedBox\n{\n\tint\t\t\tm_Id;\n\tvec3\t\tm_pos;\n\tvec3\t\tm_scale;\n\tSMaterial\tm_material;\n};\n\t\n//=======================================================================================\nstruct SPointLight\n{\n\tvec3\t\tm_pos;\n\tvec3\t\tm_color;\n};\n\t\n//=======================================================================================\nstruct SDirLight\n{\n\tvec3\t\tm_reverseDir;\n\tvec3\t\tm_color;\n};\n\t\n//=======================================================================================\n// Scene parameters\n//=======================================================================================\n\t\n//----- settings\n#define DO_SHADOWS false // setting this to false will speed up rendering\nconst int c_maxRayBounces \t\t= 6;\n\n//----- lights\nvec3 lightAmbient = vec3(0.5,0.4,0.4);\n\n//----- macro lists\n\n// sphere primitive list\n#define SPHEREPRIMLIST PRIM(sphere1)\n\n// sphere primitive list with light primitives\n#define SPHEREPRIMLISTWITHLIGHTS SPHEREPRIMLIST PRIM(lightPoint1Sphere)\n\n// box primitive list\n#define BOXPRIMLIST PRIM(orbitBox) PRIM(orbitBox2)\n\n// point light list\n#define POINTLIGHTLIST LIGHT(lightPoint1)\n\n//=======================================================================================\nbool RayIntersectSphere (inout SSphere sphere, inout SCollisionInfo info, in vec3 rayPos, in vec3 rayDir, in int ignorePrimitiveId)\n{\n\tif (ignorePrimitiveId == sphere.m_Id)\n\t\treturn false;\n\n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.m_center;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.m_radius * sphere.m_radius;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n\n\t//not inside til proven otherwise\n\tbool fromInside = false;\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat collisionTime = -b - sqrt(discr);\n\n\t//if t is negative, ray started inside sphere so clamp t to zero and remember that we hit from the inside\n\tif(collisionTime < 0.0)\n\t{\n\t\tcollisionTime = -b + sqrt(discr);\n\t\tfromInside = true;\n\t}\n\n\t//enforce a max distance if we should\n\tif(info.m_collisionTime >= 0.0 && collisionTime > info.m_collisionTime)\n\t\treturn false;\n\n\t// set all the info params since we are garaunteed a hit at this point\n\tinfo.m_fromInside = fromInside;\n\tinfo.m_collisionTime = collisionTime;\n\tinfo.m_material = sphere.m_material;\n\n\t//compute the point of intersection\n\tinfo.m_intersectionPoint = rayPos + rayDir * info.m_collisionTime;\n\n\t// calculate the normal\n\tinfo.m_surfaceNormal = normalize(info.m_intersectionPoint - sphere.m_center);\n\t\n\t// texture coordinates are just the angular part of spherical coordiantes of normal\n\tinfo.m_textureCoordinates = vec2\n\t(\n\t\tatan(info.m_surfaceNormal.y, info.m_surfaceNormal.x) / 8.0,\n\t\tacos(info.m_surfaceNormal.z ) / 8.0\n\t);\n\t\n\t// bump mapping\n\tvec3 uaxis = normalize(cross(vec3(0.0,1.0,0.0), info.m_surfaceNormal));\n\tvec3 vaxis = normalize(cross(uaxis, info.m_surfaceNormal));\n\tmat3 mattanspace = mat3\n\t(\n\t\tuaxis,\n\t\tvaxis,\n\t\tinfo.m_surfaceNormal\n\t);\n\t\n\tfloat delta = -1.0/512.0;\n\tfloat A = texture(iChannel0, info.m_textureCoordinates + vec2(0.0, 0.0)).x;\n\tfloat B = texture(iChannel0, info.m_textureCoordinates + vec2(delta, 0.0)).x;\n    float C = texture(iChannel0, info.m_textureCoordinates + vec2(0.0, delta)).x;\n\t\n\tvec3 norm = normalize(vec3(B - A, C - A, 0.25));\n\t\n\tinfo.m_surfaceNormal = normalize(mattanspace * norm);\n\n\t// we found a hit!\n\tinfo.m_foundHit = true;\n\tinfo.m_Id = sphere.m_Id;\n\treturn true;\n}\n\n//=======================================================================================\nbool RayIntersectAABox (inout SAxisAlignedBox box, inout SCollisionInfo info, in vec3 rayPos, in vec3 rayDir, in int ignorePrimitiveId)\n{\n\tif (ignorePrimitiveId == box.m_Id)\n\t\treturn false;\n\t\n\tfloat rayMinTime = 0.0;\n\tfloat rayMaxTime = FLT_MAX;\n\t\n\t//enforce a max distance\n\tif(info.m_collisionTime >= 0.0)\n\t{\n\t\trayMaxTime = info.m_collisionTime;\n\t}\t\n\t\n\t// find the intersection of the intersection times of each axis to see if / where the\n\t// ray hits.\n\tfor(int axis = 0; axis < 3; ++axis)\n\t{\n\t\t//calculate the min and max of the box on this axis\n\t\tfloat axisMin = box.m_pos[axis] - box.m_scale[axis] * 0.5;\n\t\tfloat axisMax = axisMin + box.m_scale[axis];\n\n\t\t//if the ray is paralel with this axis\n\t\tif(abs(rayDir[axis]) < 0.0001)\n\t\t{\n\t\t\t//if the ray isn't in the box, bail out we know there's no intersection\n\t\t\tif(rayPos[axis] < axisMin || rayPos[axis] > axisMax)\n\t\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//figure out the intersection times of the ray with the 2 values of this axis\n\t\t\tfloat axisMinTime = (axisMin - rayPos[axis]) / rayDir[axis];\n\t\t\tfloat axisMaxTime = (axisMax - rayPos[axis]) / rayDir[axis];\n\n\t\t\t//make sure min < max\n\t\t\tif(axisMinTime > axisMaxTime)\n\t\t\t{\n\t\t\t\tfloat temp = axisMinTime;\n\t\t\t\taxisMinTime = axisMaxTime;\n\t\t\t\taxisMaxTime = temp;\n\t\t\t}\n\n\t\t\t//union this time slice with our running total time slice\n\t\t\tif(axisMinTime > rayMinTime)\n\t\t\t\trayMinTime = axisMinTime;\n\n\t\t\tif(axisMaxTime < rayMaxTime)\n\t\t\t\trayMaxTime = axisMaxTime;\n\n\t\t\t//if our time slice shrinks to below zero of a time window, we don't intersect\n\t\t\tif(rayMinTime > rayMaxTime)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\t\n\t//if we got here, we do intersect, return our collision info\n\tinfo.m_fromInside = (rayMinTime == 0.0);\n\tif(info.m_fromInside)\n\t\tinfo.m_collisionTime = rayMaxTime;\n\telse\n\t\tinfo.m_collisionTime = rayMinTime;\n\tinfo.m_material = box.m_material;\n\t\n\tinfo.m_intersectionPoint = rayPos + rayDir * info.m_collisionTime;\n\n\t// figure out the surface normal by figuring out which axis we are closest to\n\tfloat closestDist = FLT_MAX;\n\tint closestAxis = 0;\n\tfor(int axis = 0; axis < 3; ++axis)\n\t{\n\t\tfloat distFromPos= abs(box.m_pos[axis] - info.m_intersectionPoint[axis]);\n\t\tfloat distFromEdge = abs(distFromPos - (box.m_scale[axis] * 0.5));\n\n\t\tif(distFromEdge < closestDist)\n\t\t{\n\t\t\tclosestAxis = axis;\n\t\t\tclosestDist = distFromEdge;\n\t\t\tinfo.m_surfaceNormal = vec3(0.0,0.0,0.0);\n\t\t\tif(info.m_intersectionPoint[axis] < box.m_pos[axis])\n\t\t\t\tinfo.m_surfaceNormal[axis] = -1.0;\n\t\t\telse\n\t\t\t\tinfo.m_surfaceNormal[axis] =  1.0;\n\t\t}\n\t}\n\t\n\t// texture coordinates \n\tvec3 uaxis = vec3(1.0,0.0,0.0);\n\tvec3 vaxis = vec3(0.0,1.0,0.0);\n\t\n\tif (closestAxis == 0)\n\t{\n\t\tuaxis = vec3(0.0,1.0,0.0);\n\t\tvaxis = vec3(0.0,0.0,1.0);\n\t}\n\telse if (closestAxis == 1)\n\t{\n\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\tvaxis = vec3(0.0,0.0,1.0);\t\t\n\t}\n\t\n\tvec3 relPoint = info.m_intersectionPoint - box.m_pos;\n\tinfo.m_textureCoordinates = vec2\n\t(\n\t\tdot(relPoint, uaxis) * 0.25,\n\t\tdot(relPoint, vaxis) * 0.25\n\t);\n\t\n\t// bump mapping\n\tmat3 mattanspace = mat3\n\t(\n\t\tuaxis,\n\t\tvaxis,\n\t\tinfo.m_surfaceNormal\n\t);\n\t\n\tfloat delta = -1.0/512.0;\n\tif (box.m_Id == 4) {\n\t\tfloat A = texture(iChannel1, info.m_textureCoordinates + vec2(0.0, 0.0)).x;\n\t\tfloat B = texture(iChannel1, info.m_textureCoordinates + vec2(delta, 0.0)).x;\n    \tfloat C = texture(iChannel1, info.m_textureCoordinates + vec2(0.0, delta)).x;\n\t\tvec3 norm = normalize(vec3(B - A, C - A, 0.25));\n\t\tinfo.m_surfaceNormal = normalize(mattanspace * norm);\n\t}\n\telse {\n\t\tfloat A = texture(iChannel0, info.m_textureCoordinates + vec2(0.0, 0.0)).x;\n\t\tfloat B = texture(iChannel0, info.m_textureCoordinates + vec2(delta, 0.0)).x;\n    \tfloat C = texture(iChannel0, info.m_textureCoordinates + vec2(0.0, delta)).x;\n\t\tvec3 norm = normalize(vec3(B - A, C - A, 0.25));\n\t\tinfo.m_surfaceNormal = normalize(mattanspace * norm);\t\t\n\t}\n\t\n\t// we found a hit!\n\tinfo.m_foundHit = true;\n\tinfo.m_Id = box.m_Id;\n\treturn true;\t\n}\n\n//=======================================================================================\nvoid ApplyPointLight (inout vec3 pixelColor, in SCollisionInfo collisionInfo, in SPointLight light, in float reflectionAmount, in vec3 rayDir)\n{\n\t{\n\t\t// diffuse\n\t\tvec3 hitToLight = normalize(light.m_pos - collisionInfo.m_intersectionPoint);\n\t\tfloat dp = dot(collisionInfo.m_surfaceNormal, hitToLight);\n\t\tif(dp > 0.0)\n\t\t\tpixelColor += collisionInfo.m_material.m_diffuseColor * dp * light.m_color * collisionInfo.m_material.m_diffuse * reflectionAmount;\n\t\t\t\t\n\t\t// specular\n\t\tvec3 reflection = reflect(hitToLight, collisionInfo.m_surfaceNormal);\n\t\tdp = dot(rayDir, reflection);\n\t\tif (dp > 0.0)\n\t\t\tpixelColor += collisionInfo.m_material.m_specularColor * pow(dp, collisionInfo.m_material.m_specular) * light.m_color * reflectionAmount;\n\t}\n}\n\n//=======================================================================================\nvoid TraceRay (in vec3 rayPos, in vec3 rayDir, inout vec3 pixelColor, in int depth)\n{\n    SPointLight lightPoint1 =\n        SPointLight\n        (\n            vec3(sin(1.57 + iTime*1.5),sin(iTime*0.5),cos(1.57 + iTime*1.5)),\n            vec3(0.9,0.9,0.9)\n        );\n    \n    //----- primitives\n    SSphere lightPoint1Sphere =\n        SSphere\n        (\n            1,\t\t\t\t\t\t//id\n            lightPoint1.m_pos,\t\t//center\n            0.03,\t\t\t\t\t//radius\n            SMaterial\n            (\n                0.0,\t\t\t\t//diffuse amount\n                vec3(0.0,0.0,0.0),\t//diffuse color\n                1.0,\t\t\t\t//specular amount\n                vec3(0.0,0.0,0.0),\t//specular color\n                lightPoint1.m_color,//emissive color\n                0.0,\t\t\t\t//refraction amount\n                0.0\t\t\t\t\t//refraction index\n            )\n        );\t\n\n    SSphere sphere1 =\n        SSphere\n        (\n            2,\t\t\t\t\t\t//id\n            vec3(0.0,0.0,0.0),\t\t//center\n            0.3,\t\t\t\t\t//radius\n            SMaterial\n            (\n                1.0,\t\t\t\t//diffuse amount\n                vec3(1.0,1.0,1.0),\t//diffuse color\n                5.0,\t\t\t\t//specular amount\n                vec3(1.0,1.0,1.0),\t//specular color\n                vec3(0.0,0.0,0.0),\t//emissive color\n                0.0,\t\t\t\t//refraction amount\n                0.0\t\t\t\t\t//refraction index\t\t\t\n            )\n        );\n    \n    SAxisAlignedBox orbitBox = \n        SAxisAlignedBox\n        (\n            3,\t\t\t\t\t\t//Id\n            vec3(sin(2.0 + iTime*1.3),0.0,cos(2.0 + iTime*1.3)),\t//center\n            vec3(0.5,0.75,0.5),\t//scale\n            SMaterial\n            (\n                0.25,\t\t\t\t//diffuse amount\n                vec3(1.0,1.0,1.0),  //diffuse color\n                20.0,\t\t\t\t//specular amount\n                vec3(1.0,1.0,1.0),\t//specular color\n                vec3(0.0,0.0,0.0),\t//emissive\n                0.75,\t\t\t\t//refraction amount\n                0.9\t\t\t\t\t//refraction index\t\t\t\n            )\n        );\n    \n    SAxisAlignedBox orbitBox2 = \n        SAxisAlignedBox\n        (\n            4,\t\t\t\t\t\t//Id\n            vec3(sin(5.14 + iTime*1.3),0.0,cos(5.14 + iTime*1.3)),\t//center\n            vec3(0.5,0.75,0.5),\t//scale\n            SMaterial\n            (\n                0.25,\t\t\t\t//diffuse amount\n                vec3(1.0,1.0,1.0),  //diffuse color\n                20.0,\t\t\t\t//specular amount\n                vec3(1.0,1.0,1.0),\t//specular color\n                vec3(0.0,0.0,0.0),\t//emissive\n                0.75,\t\t\t\t//refraction amount\n                0.9\t\t\t\t\t//refraction index\t\t\t\n            )\n        );    \n    \n\tint lastHitPrimitiveId = 0;\n\tfloat colorMultiplier = 1.0; // used by reflections and refractions that aren't fully 1.0\n\t\n\tvec3 rayToCameraDir = rayDir;\n\t\n\tfor(int index = 0; index < c_maxRayBounces; ++index)\n\t{\n\t\t\n\t\tSCollisionInfo collisionInfo =\n\t\t\tSCollisionInfo\n\t\t\t(\n\t\t\t\t0,\n\t\t\t\tfalse,\n\t\t\t\tfalse,\n\t\t\t\t-1.0,\n\t\t\t\tvec3(0.0,0.0,0.0),\n\t\t\t\tvec3(0.0,0.0,0.0),\n\t\t\t\tvec2(0.0,0.0),\n\t\t\t\tSMaterial(\n\t\t\t\t\t1.0,\n\t\t\t\t\tvec3(0.0,0.0,0.0),\n\t\t\t\t\t1.0,\n\t\t\t\t\tvec3(0.0,0.0,0.0),\n\t\t\t\t\tvec3(0.0,0.0,0.0),\n\t\t\t\t\t0.0,\n\t\t\t\t\t0.0\n\t\t\t\t)\n\t\t\t);\n\n\t\t// run intersection against all objects, including light objects\t\t\n\t\t#define PRIM(x) RayIntersectSphere(x, collisionInfo, rayPos, rayDir, lastHitPrimitiveId);\n\t\tSPHEREPRIMLISTWITHLIGHTS\n\t\t#undef PRIM\n\t\t\t\n\t\t// run intersections against all boxes\n\t\t#define PRIM(x) RayIntersectAABox(x, collisionInfo, rayPos, rayDir, lastHitPrimitiveId);\n\t\tBOXPRIMLIST\n\t\t#undef PRIM\n\n\t\n\t\tif (collisionInfo.m_foundHit)\n\t\t{\t\t\t\n\t\t\tif (collisionInfo.m_Id == 4)\n\t\t\t\tcollisionInfo.m_material.m_diffuseColor = texture(iChannel1, collisionInfo.m_textureCoordinates).xyz;\n\t\t\telse\n\t\t\t\tcollisionInfo.m_material.m_diffuseColor = texture(iChannel0, collisionInfo.m_textureCoordinates).xyz;\n\t\t\t\n\t\t\t// point lights\n\t\t\t#define LIGHT(light) ApplyPointLight(pixelColor, collisionInfo, light, colorMultiplier, rayDir);\n\t\t\tPOINTLIGHTLIST\n\t\t\t#undef LIGHT\t\t\t\t\n\n\t\t\t// ambient light\n\t\t\tpixelColor += lightAmbient * collisionInfo.m_material.m_diffuseColor * collisionInfo.m_material.m_diffuse * colorMultiplier;\n\t\t\t\n\t\t\t// emissive color\n\t\t\tpixelColor += collisionInfo.m_material.m_emissiveColor * colorMultiplier;\t\t\n\t\t\t\n\t\t\t//do refraction if we should\n\t\t\tif (collisionInfo.m_material.m_refraction > 0.0)\n\t\t\t{\t\t\t\t\t\n\t\t\t\tif (collisionInfo.m_fromInside)\n\t\t\t\t\tcollisionInfo.m_surfaceNormal *= -1.0;\n\t\t\t\t\n\t\t\t\t// if we are entering a refractive object, we can't ignore it since we need to go out the back\n\t\t\t\t// side possibly.  Since we can't ignore it, we need to push a little bit past the point of\n\t\t\t\t// intersection so we don't intersect it again.\n\t\t\t\tlastHitPrimitiveId = 0;\t\t\t\t\n\t\t\t\trayPos = collisionInfo.m_intersectionPoint + rayDir * 0.001;\n\t\t\t\t\n\t\t\t\t// \n\t\t\t\trayDir = refract(rayToCameraDir, collisionInfo.m_surfaceNormal, collisionInfo.m_material.m_refractionIndex);\n\t\t\t\t\n\t\t\t\tcolorMultiplier *= collisionInfo.m_material.m_refraction;\n\t\t\t\tif (colorMultiplier < 0.1)\n\t\t\t\t\treturn;\t\t\t\t\n\t\t\t}\t\n\t\t\t// else we are done\n\t\t\telse\n\t\t\t\treturn;\n\t\t}\n\t\t// no hit means bail out\n\t\telse\n\t\t{\n\t\t\tpixelColor+= colorMultiplier * texture(iChannel2, rayDir).rgb;\n\t\t\treturn;\n\t\t}\n\t}\n\t\t\t\n}\n\n//=======================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //----- camera\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.0,0.0,0.0);\n\n    float angleX = 3.14 + 6.28 * mouse.x;\n    float angleY = (mouse.y * 3.90) - 0.4;\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 4.0;\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\n    float cameraDistance\t= 6.0;  // intuitively backwards!    \n    \n    // -----\n\tvec2 rawPercent = (fragCoord.xy / iResolution.xy);\n\tvec2 percent = rawPercent - vec2(0.5,0.5);\n\t\n\tvec3 rayPos;\n\tvec3 rayTarget;\n\t\n\t// if the mouse button is down\n\tif( iMouse.z > 0.0 ) {\n\t\trayTarget = (cameraFwd * cameraDistance)\n\t\t\t\t  + (cameraLeft * percent.x * cameraViewWidth)\n\t\t          + (cameraUp * percent.y * cameraViewHeight);\n\t\t\n\t\trayPos = cameraPos;\n\t}\n\t// else handle the case of the mouse button not being down\n\telse {\n\t\trayPos = vec3(0.0,0.0,-4.0);\n\t\tvec3 f = normalize(cameraAt - rayPos);\n\t\tvec3 l = normalize(cross(f,vec3(0.0,1.0,0.0)));\n\t\tvec3 u = normalize(cross(l,f));\n\t\t\n\t\trayTarget = (f * cameraDistance)\n\t\t\t\t  + (l * percent.x * cameraViewWidth)\n\t\t          + (u * percent.y * cameraViewHeight);\t\t\n\t}\n\t\n\tvec3 rayDir = normalize(rayTarget);\n\t\n\tvec3 pixelColor = vec3(0.0,0.0,0.0);\n\tTraceRay(rayPos, rayDir, pixelColor, 0);\n\tfragColor = vec4(pixelColor, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldj3zz","date":"1383385843","viewed":3271,"name":"RayTraced Bumpmaps","username":"demofox","description":"Using textures to modify the normals of objects used for lighting and refraction.  The boxes have a sort of frosted glass look to them.  Drag the mouse to control the camera, try switching the texture for other cool looking effects!","likes":78,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","bumpmapping"],"hasliked":0,"parentid":"","parentname":""}}