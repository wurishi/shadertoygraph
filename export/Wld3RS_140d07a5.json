{"ver":"0.1","info":{"id":"Wld3RS","date":"1576718661","viewed":244,"name":"Terrain in 3d","username":"yp3y5akh0v","description":"Terrain in 3d","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n    vec3 ro = vec3(0.5, 0.5, -2.);\n    vec3 col = vec3(0.);\n    float t = iTime;\n    \n    ro.z -= t;\n    \n    Light light = Light(vec3(0.5, 1.5, -4.), 0.06);\n    RayMarchInfo rmi = RayMarch(ro, rd, t);\n\n    vec3 p = ro + rmi.sdf * rd;\n    vec3 n = GetNormal(p, t); \n    vec3 pToL = light.p - p;\n    vec3 pToLN = normalize(pToL);\n    \n    RayMarchInfo lrmi = RayMarch(p + 0.3 * n, pToLN, t);\n    \n    col = vec3(1. / pow(length(pToL), 0.8));\n    \n    float diffuse = clamp(dot(n, pToLN), 0., 1.);\n    \n    if (lrmi.sdf < length(pToL) - light.r) {\n    \tcol *= 0.3;\n    }\n    \n    col *= diffuse;\n    \n    float fogCoef = 1. - exp(-rmi.sdf * 0.2);\n    float rxL = max(dot(rd, normalize(light.p - ro)), 0.);\n    vec3 fogCol = mix(vec3(0.53, 0.81, 0.92), vec3(0.98, 0.83, 0.64), pow(rxL, 50.));\n    \n    col = mix(col, fogCol, fogCoef);   \n    col += 0.35 * pow(rxL, 1. + pow(length(light.p - ro), 2.));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_RAY_STEPS 100\n#define EPS 0.0001\n#define PI radians(180.)\n\nfloat rand(vec2 uv) {\n    return fract(sin(dot(sin(uv), vec2(12.9898, 78.233))) * 143758.5453);\n}\n\nmat2 rot(float a) {\n\tfloat ca = cos(a);\n    float sa = sin(a);\n    return mat2(ca, -sa, sa, ca);\n}\n\nfloat noise(vec2 uv, float scale) {\n    vec2 uvs = uv * scale;\n\tvec2 id = floor(uvs);\n    vec2 q = smoothstep(0., 1., fract(uvs));\n    vec2 e = vec2(1, 0);\n     \n    float rsx = mix(rand(id), rand(id + e.xy), q.x);\n    float rnx = mix(rand(id + e.yx), rand(id + e.xx), q.x);\n    \n    return mix(rsx, rnx, q.y);\n}\n\nfloat snoise(vec2 uv, float scale, float steps) {\n\tfloat s = 0., sk = 0.; \n    for (float i = 0.; i < steps; i++) {\n        float k = pow(2., i);\n    \ts += noise(uv, scale * k) / k;\n        sk += 1. / k;\n        uv *= rot(2. * PI * (i + 1.) / steps);\n    } \n    return smoothstep(0., 1., s / sk);\n}\n\nstruct Light {\n\tvec3 p;\n    float r;\n};\n\nstruct RayMarchInfo {\n    float sdf;\n    int steps;\n};\n\nfloat SceneSdf(vec3 p, float t) {\n    float sn = 4.;\n    float stn = 6.;\n    float amp = 0.4;\n    float d = p.y - snoise(vec2(p.x, p.z - t), sn, stn) * amp;    \n    return d / sn / amp;\n}\n\nvec3 GetNormal(vec3 p, float t) {\n\tfloat d = SceneSdf(p, t);\n    vec2 e = vec2(0.001, 0.);\n    vec3 n = d - vec3(\n        SceneSdf(p - e.xyy, t),\n        SceneSdf(p - e.yxy, t),\n        SceneSdf(p - e.yyx, t)\n    );\n    \n    return normalize(n);\n}\n\nRayMarchInfo RayMarch(vec3 ro, vec3 rd, float t) {\n    int raySteps = 0;\n    vec3 end = ro;\n    float sdf = 0.;\n    for(int i = 0; i < MAX_RAY_STEPS; i++) {\n        raySteps++;\n    \tfloat d = SceneSdf(end, t);\n        if (abs(d) < EPS) {\n        \tbreak;\n        }\n        end += d * rd;\n        sdf += d;\n    }\n    return RayMarchInfo(sdf, raySteps);\n}","name":"Common","description":"","type":"common"}]}