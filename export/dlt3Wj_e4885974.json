{"ver":"0.1","info":{"id":"dlt3Wj","date":"1683154049","viewed":113,"name":"Triangle renderer","username":"Cesium_137","description":"Use mouse to control, pause it if you don't want it to rotate. Because of the way it works, you can use an obj file like this simple house I made in tinkercad. Just rename the obj file to a .txt file, open it, and edit in the vertex and face data.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","interactive","render"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float d = 3.0; //FOV; lower numbers = higher FOV\nfloat pi = 3.14159265358979323846264338;\nfloat width = 0.4;\nconst int faces = 88;\n\nfloat de( vec2 a, vec2 b, vec2 p) {\n    float px = width / iResolution.x;\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1. );\n    return (1.-smoothstep(length( pa - ba*h ),0.,px))*0.2; // 0.2 is the brightness from 0 to 1\n} //a way i came up with of connecting two points with a line that has anti-aliasing\n//edited version of FabriceNayret2's comment on https://www.shadertoy.com/view/4ljfRD\n\nfloat z(vec2 a, float theta, float r, float h){\n    return cos(a.y)*r*sin(a.x + theta) - sin(a.y)*h;\n}\n\nvec2 c(vec2 a, float theta, float r, float h){\n    return 0.2*vec2((d*r*cos(a.x + theta))/(d - z(a,theta,r,h)),(d/(d-z(a,theta,r,h)))*(r*sin(a.y)*sin(a.x + theta) + h*cos(a.y))) + vec2(.5);\n} //plots cylindrical coordinates\n\nvec2 b(vec2 a, float x, float y, float h){\n    return c(a, atan(y,x),sqrt(x*x+y*y),h);\n} // plots cartesian coordinates\n\nfloat[] xcoords = float[](-1.25,0.0,-1.0,1.0,0.0,1.25,-0.5,0.5,0.5,-0.5,-1.0,0.0,-1.25,0.0,1.0,1.25,-1.0,-1.0,1.0,0.0,0.0,1.0,1.0,-1.0,-1.0,1.0,-0.75,0.75,-0.75,-0.5,-0.5,-0.75,0.75,0.5,0.5,0.75,1.0,0.75,1.0,0.75,1.0,1.0,0.75,-0.75,0.75,0.78);\nfloat[] ycoords = float[](1.25,1.25,1.25,1.25,1.25,1.25,1.0,1.0,1.0,1.0,-1.25,-1.25,-1.25,-1.25,-1.25,-1.25,1.0,1.0,1.0,1.0,-1.0,-1.0,1.0,-1.0,-1.0,-1.0,0.75,0.75,0.75,0.75,0.75,-0.75,-0.75,0.75,0.75,0.75,0.0,0.0,0.0,-0.5,-0.5,-0.5,-0.75,-0.75,0.0,-0.5);\nfloat[] zcoords = float[](0.5,1.5,0.5,0.5,1.75,0.5,-1.0,-1.0,0.0,0.0,0.5,1.5,0.5,1.75,0.5,0.5,-1.5,0.5,-1.5,1.5,1.5,0.5,0.5,0.5,-1.5,-1.5,-1.5,-1.5,0.5,-1.0,0.0,-1.5,-1.5,0.0,-1.0,0.5,-1.5,-1.5,-0.5,-1.5,-1.5,-0.5,0.5,0.5,-0.5,-0.5);\nint[] triData1 = int[](2,1,5,4,7,18,17,19,10,14,11,23,15,14,13,12,19,16,20,20,8,5,14,12,20,20,3,12,22,19,23,27,29,29,32,25,17,17,28,27,34,21,37,37,35,35,37,23,26,40,26,9,9,22,41,10,10,35,34,34,42,23,34,29,43,43,17,17,27,27,36,38,33,46,33,36,39,39,46,46,45,45,16,3,43,29,5,5);\nint[] triData2 = int[](3,5,6,2,8,9,18,17,7,13,12,9,16,12,1,2,8,15,21,22,9,1,5,11,18,24,2,4,24,27,18,19,27,30,33,26,27,32,36,28,35,24,38,28,8,7,19,39,25,41,33,34,31,26,42,31,30,30,9,8,39,22,36,31,33,32,25,24,29,44,28,45,46,43,43,45,45,38,42,41,39,42,4,11,44,36,14,16);\nint[] triData3 = int[](1,2,2,6,19,10,7,7,18,12,13,18,12,16,11,4,23,4,22,23,23,13,13,2,24,21,11,15,26,17,20,28,30,31,25,24,32,25,35,35,36,22,28,19,7,30,39,19,33,33,41,31,10,42,26,30,7,27,8,35,22,39,31,36,32,44,24,18,44,32,45,28,40,45,46,43,38,37,41,40,42,46,6,1,36,44,16,6);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= 16./9.; //fixes stretching from the screen being a rectangle\n    uv.x -= 0.38; //shifts it right to be at the center\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec2 rot = vec2(-mouse.x * 4. - iTime / 2.,(mouse.y - 0.2) * 4.); // rot is rotation\n    float col;\n    for(int i = 0; i <= faces; i++){\n        col += de(b(rot,xcoords[triData1[i]-1],ycoords[triData1[i]-1],zcoords[triData1[i]-1]),b(rot,xcoords[triData2[i]-1],ycoords[triData2[i]-1],zcoords[triData2[i]-1]),uv);\n        col += de(b(rot,xcoords[triData2[i]-1],ycoords[triData2[i]-1],zcoords[triData2[i]-1]),b(rot,xcoords[triData3[i]-1],ycoords[triData3[i]-1],zcoords[triData3[i]-1]),uv);\n        col += de(b(rot,xcoords[triData3[i]-1],ycoords[triData3[i]-1],zcoords[triData3[i]-1]),b(rot,xcoords[triData1[i]-1],ycoords[triData1[i]-1],zcoords[triData1[i]-1]),uv);\n    }\n    fragColor = vec4(vec3(col),1.0);\n}","name":"Image","description":"","type":"image"}]}