{"ver":"0.1","info":{"id":"wllBRX","date":"1597351059","viewed":405,"name":"Bezier Explicit vs. de Casteljau","username":"fizzer","description":"Comparing the numerical precision of explicit Bezier curve evaluation versus De Casteljau method. Bottom-left is the usual implementation with calculating of factorials resulting in precision loss. Others use either DeCasteljau or cached binomials.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["bezier","precision","decasteljau","factorial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Comparing the numerical precision of explicit Bezier curve evaluation versus de Casteljau method.\n//\n// Top-Left = Using cached binomial coefficients (explained below)\n// Top-Right = Cached binomial coefficients + efficient pow() evaluation\n// Bottom-Left = Calculating factorials and running out of precision\n// Bottom-Right = Paul de Casteljau's method: https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm\n\n// Wikipedia states that the de Casteljau method is \"a numerically stable method for evaluating the curves\".\n// This implies that the original formulation is not numerically stable. I think this is probably because\n// the calculated factorials for curves of degree > 12 start to grow larger than what a 32-bit integer\n// can hold, and larger than what is representable in a 32-bit float (24 bits of precision).\n//\n// However, these factorials are only calculated as part of the binomial coefficients which generally end up\n// being easily representable in 24 bits. The set of binomial coefficients for a Bezier curve of a given\n// degree is constant, so it can be pre-computed offline with a high precision and range.\n//\n// The result is that the original formulation of the Bezier curve evaluation is just as stable as\n// de Casteljau's method at the scales that I've tried. On top of that, de Casteljau's method\n// is very slow at high degrees O(n²) compared to the original formulation's O(n).\n//\n\n\n\n// Undefine this to use a more efficient way to compute the binomial coefficient.\n// This is yet another way that the supposed precision loss in the original Bezier formulation\n// can be avoided.\n#define USE_FACTORIAL\n\n// Degree of the Bezier curve\nconst int n = 13;\n\n// Pre-computed binomial coefficients\nconst int bin13[14] = int[14](1, 13, 78, 286, 715, 1287, 1716, 1716, 1287, 715, 286, 78, 13, 1);\n\n// Control points\nvec2 control_points[n + 1];\n\n\nint factorial(int x)\n{\n\t// For values of n greater than around 12, the int datatype can't contain the result.\n    int y = 1;\n    while(x > 0)\n    {\n        y *= x;\n        x -= 1;\n    }\n    return y;\n}\n\nfloat binomialCoefficient(int n, int k)\n{\n#ifdef USE_FACTORIAL\n    // Naïve implementation using factorial.\n    return float(factorial(n)) / float(factorial(k) * factorial(n - k));\n#else\n    // Using the multiplicative formula\n    // https://en.wikipedia.org/wiki/Binomial_coefficient#Multiplicative_formula\n    float c = 1.;\n    for(int i = 1; i <= k; ++i)\n        c *= float(n + 1 - i) / float(i);\n    return c;\n#endif\n}\n\nfloat binomialCached(int n, int k)\n{\n    // Use pre-computed tables to avoid overflow during calculation\n    if(n == 13)\n    \treturn float(bin13[k]);\n    \n    return binomialCoefficient(n, k);\n}\n\n// The method which can be found on Wikipedia: https://en.wikipedia.org/wiki/B%C3%A9zier_curve\nvec2 explicitBezier(float t)\n{\n    vec2 sum = vec2(0);\n    for(int i = 0; i <= n; ++i)\n    {\n        sum += float(binomialCoefficient(n, i)) *\n            \tpow(1. - t, float(n - i)) * pow(t, float(i)) * control_points[i];\n    }\n    return sum;\n}\n\n// Method using cached binomial coefficients to avoid overflow / precision loss.\nvec2 explicitBezierCached(float t)\n{\n    vec2 sum = vec2(0);\n    for(int i = 0; i <= n; ++i)\n    {\n        sum += float(binomialCached(n, i)) *\n            \tpow(1. - t, float(n - i)) * pow(t, float(i)) * control_points[i];\n    }\n    return sum;\n}\n\n// Cached binomial coefficients, plus a reduced method of evaluating the polynomials.\nvec2 explicitBezierCachedWithoutPow(float t)\n{\n    vec2 sum = vec2(0);\n    float s = 1.0;\n    for(int i = 0; i <= n; ++i)\n    {\n        sum *= t;\n        sum += s*binomialCached(n,i)*control_points[n-i];\n        s *= 1.0-t;\n    }\n    return sum;\n}\n\nvec2 deCasteljau(float t)\n{\n    vec2 mid_points[n];\n    for(int i = 0; i < n; ++i)\n    {\n        mid_points[i] = mix(control_points[i], control_points[i + 1], t);\n    }\n    int k = n;\n    while(k > 2)\n    {\n        k -= 1;\n        for(int i = 0; i < k; ++i)\n        {\n            mid_points[i] = mix(mid_points[i], mid_points[i + 1], t);\n        }\n    }\n    return mix(mid_points[0], mid_points[1], t);\n}\n\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n// Distance to line segment\nfloat segment(vec2 p, vec2 a, vec2 b)\n{\n    return distance(p, mix(a, b, clamp(dot(p - a, b - a) / dot(b - a, b - a), 0., 1.)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.xy * 2.;\n\tvec2 uv2 = (fract(uv) - .5) * 3.5;\n    uv2.x *= iResolution.x / iResolution.y;\n\n    // Generate control points\n    for(int i = 0; i <= n; ++i)\n    {\n        control_points[i] = vec2(float(i) / float(n) * 2. - 1. + sin(float(i) * 2.3 - iTime / 2.) * .8,\n                                 (hash(vec2(i, 8)) * 2. - 1.) * .4) * 1.5;\n        control_points[i].y += sin(iTime / 3. + float(i) / 1.5);\n    }\n    \n    vec4 col = vec4(0);\n\n    col = vec4(.1 - .02 * smoothstep(0.02, 0.04, abs(fract(uv.x * iResolution.x / iResolution.y * 8.) - .5)) -\n               \t\t.02 * smoothstep(0.02, 0.04, abs(fract(uv.y * 8.) - .5)));\n    \n    col *= smoothstep(0.005, .01, min(abs(uv.y), abs(uv.x) * iResolution.x / iResolution.y));\n    \n    const int m = 64;\n    \n    float dist = 1e4;\n    \n    // Draw the Bezier curve\n    \n    vec2 prevp;\n    for(int i = 0; i <= m; ++i)\n    {\n\t\tfloat t = float(i) / float(m);\n        vec2 p;\n        \n        if(uv.x < 0.)\n        {\n            if(uv.y < 0.)\n            {\n                p = explicitBezier(t);\n            }\n            else\n            {\n                p = explicitBezierCached(t);\n            }\n        }\n        else\n        {\n            if(uv.y < 0.)\n            {\n                p = deCasteljau(t);\n            }\n            else\n            {\n                p = explicitBezierCachedWithoutPow(t);\n            }\n        }\n        \n        if(i > 0)\n            dist = min(dist, segment(uv2, prevp, p));\n\n        prevp = p;\n    }\n    \n\tcol = mix(vec4(1, .2, .2, .2), col, smoothstep(.03, .04, dist));\n    \n    // Draw control points\n    for(int i = 0; i <= n; ++i)\n       col = mix(vec4(1), col, smoothstep(.02, .03, distance(uv2, control_points[i])));\n    \n    if(uv.x < 0.)\n        col = col.argb;\n    if(uv.y < 0.)\n        col = col.barg;\n    \n    fragColor = vec4(sqrt(col.rgb), 1.0);\n}","name":"Image","description":"","type":"image"}]}