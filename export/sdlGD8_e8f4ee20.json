{"ver":"0.1","info":{"id":"sdlGD8","date":"1615894482","viewed":124,"name":"Mandelbulb attempt","username":"Krafpy","description":"An attempt to render the mandelbulb with raymarching and coloring with basic orbit trapping.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","mandelbulb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MARCH_STEPS 128.\n#define ITERATIONS 32\n#define OUTRANGE 2.\n\nmat2 rot(float a){\n\treturn mat2(cos(a), -sin(a),\n               sin(a), cos(a));\n}\n\nfloat SDF(vec3 p, out float trap){\n    p.xz *= rot(-0.5 + iTime * 0.08);\n    p.yz *= rot(-0.5 + iTime * 0.07);\n    \n    vec3 z = p;\n    float n = 8.;\n    float r = 0.;\n    float dr = 1.;\n    \n    trap = dot(z,z);\n    \n    for(int i = 0; i < ITERATIONS; i++){\n        r = length(z);\n        \n        if(r >= OUTRANGE){\n            break;\n        }\n        \n        trap = min(dot(z,z), trap);\n        \n        dr = n * pow(r, n - 1.) * dr + 1.;\n        \n        float theta = atan(z.y / z.x);\n        float phi = asin(z.z / r);\n\n        r = pow(r, n);\n        theta *= n;\n        phi *= n;\n        \n        z = r * vec3(cos(theta) * cos(phi), sin(theta) * cos(phi), sin(phi)) + p;\n    }\n    \n    return 0.5 * log(r) * r / dr;\n}\n\nfloat raymarch(vec3 ro, vec3 rd, out float i, out float trap){\n    //const float eps = 0.0001;\n    \n    vec3 p = ro;\n    \n    // check for bounding sphere\n    vec3 cl = p + rd * abs(dot(p, rd));\n    if(dot(cl, cl) >= 1.3){\n        return -1.;\n    }\n    \n    float t = 0.;\n    for(i = 0.; i < MARCH_STEPS; ++i){\n        float d = SDF(p, trap);\n        float eps = 0.0001 + 0.0001 * t;\n        if(d < eps){\n            return d;\n        }\n        t += d;\n        p += rd * d;\n    }\n    \n    return -1.;\n}\n\nvec3 coloring(float trap){\n    trap = clamp(pow(trap, 8.), 0., 1.);\n    vec3 col = mix(vec3(1., 0.81, 0.64), vec3(0.8, 0.4, 0.1), trap);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float zoom = smoothstep(0., 1., pow(sin(iTime*0.12), 2.));\n    vec3 ro = vec3(0.,0.,-2.5) + vec3(0., 0., 1.) * zoom * 1.3;\n    vec3 rd = normalize(vec3(uv, 1.));\n    \n    vec3 col = vec3(0.);\n    \n    float i;\n    float trap;\n    float d = raymarch(ro, rd, i, trap);\n    \n    if(d > 0.){\n        col = vec3(1.) * pow(1. - i / MARCH_STEPS, 4.);\n        col *= coloring(trap);\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}