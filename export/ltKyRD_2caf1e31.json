{"ver":"0.1","info":{"id":"ltKyRD","date":"1535427737","viewed":150,"name":"Correct refraction???","username":"efairbanks","description":"Trying to raymarch *just* refraction with raymarching SDFs. It's unclear to me if I've done this correctly. It looks roughly correct, but it seems to me that you'd want to counteract the refraction on exit. Does this happen implicitly?","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","refract"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 c2p(in vec2 p){return vec2(atan(p.y,p.x),length(p));}\nvec2 p2c(in vec2 p){return vec2(cos(p.x),sin(p.x))*p.y;}\nvec2 _min(vec2 a, vec2 b) {return a.x<b.x?a:b;}\nvec3 look(vec2 xy, vec3 origin, vec3 target)\n{\n    vec3 up=normalize(vec3(0.,1.,0.));\n    vec3 fwd=normalize(target-origin);\n    vec3 right=normalize(cross(fwd,up));\n    up=normalize(cross(fwd,right));\n    return normalize(fwd+right*xy.x+up*xy.y);\n}\n#define LUM 1.\n#define MAX_DISTANCE 15.\n#define MAX_STEPS 200\n#define EPSILON .00001\n#define STEP_COEF 1.\n#define M_PI 3.1415926535897932384626433832795\nfloat cube(vec3 p, vec3 s)\n{\n\tp=abs(p)-s;\n    return max(p.x,max(p.z,p.y));\n}\nvec2 map(vec3 p)\n{\n    vec3 q=p;\n    vec2 d=vec2(length(q)-0.6,0.9);\n    \n    q.xz=c2p(q.xz); q.x+=M_PI/2.; q.xz=p2c(q.xz);\n    \n    for(int i=0;i<5;i++)\n    {\n        q=abs(q);\n        q.xz=c2p(q.xz); q.x+=M_PI/6.; q.xz=p2c(q.xz);\n    }\n        \n    if(mod(iTime,4.)>2.) d=vec2(cube(q,vec3(.5)),0.1);\n    \n    d=_min(d,vec2(length(p+vec3(sin(iTime),0.,cos(iTime))*3.)-0.9,2.));\n    float m=floor(mod(length(p.xz*4.),1.)*1.1);\n    d=_min(d,vec2(max(-p.y+1.,length(p.xz)-3.),m));\n    d=_min(d,vec2(MAX_DISTANCE,4.));\n    return d;\n}\nvec3 normal(vec3 p, float epsilon)\n{\n    vec2 e=vec2(epsilon*10.,0.);\n    return normalize(vec3(\n        map(p+e.xyy).x-map(p-e.xyy).x,\n        map(p+e.yxy).x-map(p-e.yxy).x,\n        map(p+e.yyx).x-map(p-e.yyx).x\n    ));\n}\n\nvec2 march(vec3 origin,vec3 ray)\n{\n    float t=0.;\n    vec2 result=vec2(MAX_DISTANCE,0.);\n    for(int i=0;i<MAX_STEPS; i++)\n    {\n        result=map(origin+ray*t);\n        if(abs(result.x)<EPSILON||result.x>=MAX_DISTANCE) break;\n        t+=result.x>0.?abs(result.x*STEP_COEF):max(0.05,abs(result.x*STEP_COEF));\n        //t+=abs(result.x);\n    }\n    return vec2(min(t,MAX_DISTANCE),result.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord/iResolution.xy-.5)*2.;\n    uv.x=uv.x*iResolution.x/iResolution.y;   \n    vec3 camera=vec3(1.2);\n    camera=vec3(sin(iTime/1.567),sin(iTime/1.789)*.3-.3,cos(iTime/1.567))*2.;\n    vec3 ray=look(uv,camera,vec3(0.));\n    // --- //\n    float refraction=1.;\n    float emission=0.;\n    float totalDistance=0.;\n    vec3 pos=camera;\n    vec3 dir=ray;\n    for(int i=0;i<50;i++)\n    {\n        vec2 result=march(pos,dir);\n        totalDistance+=result.x;\n        if(result.y>=LUM)\n        {\n            emission+=result.y;\n            break;\n        }\n        else if(result.y==0.)\n        {\n            emission=0.;\n            refraction=0.;\n            break;\n        }\n        else\n        {\n            pos=pos+result.x*dir;\n            float ref=1.1;\n            vec3 n = normal(pos,EPSILON);\n            if (dot(n,dir) > 0.) {\n                n = -n;\n                ref = 1./ref;\n            }\n            pos -= EPSILON * n;\n            dir=normalize(refract(dir,n,1./ref));\n        }\n    }\n    // --- //\n    fragColor = vec4(vec3(refraction*emission/pow(totalDistance,.7)),1.0);\n}","name":"Image","description":"","type":"image"}]}