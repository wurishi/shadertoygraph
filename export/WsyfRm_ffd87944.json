{"ver":"0.1","info":{"id":"WsyfRm","date":"1607716211","viewed":81,"name":"KFR with ray tracing test","username":"leoriohope","description":"Use mouse to change foveated area","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float powFunc(float lr) {\n\treturn pow(lr, ALPHA);\n}\n\nfloat expFunc(float lr) {\n\treturn (exp(lr) - 1.0) / (exp(1.0) - 1.0);\n}\n\nfloat selfFunc(float lr) {\n\treturn 0.5 * lr * lr * lr * lr + 0.5 * lr * lr;\n}\n\nfloat sinFunc(float lr) {\n\treturn asin(lr) * 4.0 / TWOPI;\n}\n\n\nvec3 performGaussBlur(vec2 pos) \n{\n\tconst float PARA1 = 0.2042, PARA2 = 0.1238, PARA3 = 0.0751;\n\tvec3 fragColor11 = texture(logTexture, pos - PIXEL_SIZE).xyz;\n\tvec3 fragColor12 = texture(logTexture, pos - vec2(0.0f, PIXEL_SIZE.y)).xyz;\n\tvec3 fragColor13 = texture(logTexture, pos + vec2(PIXEL_SIZE.x, -PIXEL_SIZE.y)).xyz;\n\tvec3 fragColor21 = texture(logTexture, pos - vec2(PIXEL_SIZE.x, 0.0f)).xyz;\n\tvec3 fragColor22 = texture(logTexture, pos + vec2(0.0f, 0.0f)).xyz;\n\tvec3 fragColor23 = texture(logTexture, pos + vec2(PIXEL_SIZE.x, 0.0f)).xyz;\n\tvec3 fragColor31 = texture(logTexture, pos + vec2(-PIXEL_SIZE.x, PIXEL_SIZE.y)).xyz;\n\tvec3 fragColor32 = texture(logTexture, pos + vec2(0.0f, PIXEL_SIZE.y)).xyz;\n\tvec3 fragColor33 = texture(logTexture, pos + PIXEL_SIZE).xyz;\n\n\tvec3 fragColore1 = texture(logTexture, pos + 2.0*vec2(PIXEL_SIZE.x, 0.0f)).xyz;\n\tvec3 fragColore2 = texture(logTexture, pos + 2.0*vec2(-PIXEL_SIZE.x, 0.0f)).xyz;\n\tvec3 fragColore3 = texture(logTexture, pos + 2.0*vec2(0.0f, PIXEL_SIZE.y)).xyz;\n\tvec3 fragColore4 = texture(logTexture, pos + 2.0*vec2(0.0f, -PIXEL_SIZE.y)).xyz;\n\n\tvec3 newColor = PARA3 * (fragColor11 + fragColor13 + fragColor31 + fragColor33) +\n\t\tPARA2 * (fragColor12 + fragColor21 + fragColor23 + fragColor32) +\n\t\tPARA1 * fragColor22;\n\treturn newColor;\n}\n\nvec3 FxaaPixelShader( vec4 uv, sampler2D tex, vec2 rcpFrame) {\n    \n    vec3 rgbNW = textureLod(tex, uv.zw, 0.0).xyz;\n    vec3 rgbNE = textureLod(tex, uv.zw + vec2(1,0)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSW = textureLod(tex, uv.zw + vec2(0,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSE = textureLod(tex, uv.zw + vec2(1,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbM  = textureLod(tex, uv.xy, 0.0).xyz;\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max(\n        (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\n        FXAA_REDUCE_MIN);\n    float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n    \n    dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n          max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n          dir * rcpDirMin)) * rcpFrame.xy;\n\n    vec3 rgbA = (1.0/2.0) * (\n        textureLod(tex, uv.xy + dir * (1.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + dir * (2.0/3.0 - 0.5), 0.0).xyz);\n    vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\n        textureLod(tex, uv.xy + dir * (0.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + dir * (3.0/3.0 - 0.5), 0.0).xyz);\n    \n    float lumaB = dot(rgbB, luma);\n\n    if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;\n    \n    return rgbB; \n}\n\nvec3 FXAA(vec2 pos) {\n\tvec3 rgbNW = texture(logTexture, pos - vec2(PIXEL_SIZE.x, 0)).xyz;\n\tvec3 rgbNE = texture(logTexture, pos + vec2(PIXEL_SIZE.x, 0)).xyz;\n\tvec3 rgbSW = texture(logTexture, pos - vec2(0, PIXEL_SIZE.y)).xyz;\n\tvec3 rgbSE = texture(logTexture, pos + vec2(0, PIXEL_SIZE.y)).xyz;\n\tvec3 rgbM = texture(logTexture, pos).xyz;\n\trgbNW = rgbM;\n\n\tvec3 luma = vec3(0.299, 0.587, 0.114);\n\tfloat lumaNW = dot(rgbNW, luma);\n\tfloat lumaNE = dot(rgbNE, luma);\n\tfloat lumaSW = dot(rgbSW, luma);\n\tfloat lumaSE = dot(rgbSE, luma);\n\tfloat lumaM = dot(rgbM, luma);\n\n\tfloat lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n\tfloat lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\tfloat range = lumaMax - lumaMin;\n\n\tvec2 dir;\n\tdir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n\tdir.y = ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n\tfloat dirReduce = max(\n\t\t(lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * 0.125),\n\t\t1.0 / 128.0);\n\tfloat rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\tdir = min(vec2(FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX), dir * rcpDirMin)) * PIXEL_SIZE.xy;\n\n\tvec3 rgbA = (1.0 / 2.0) * (\n\t\ttexture(logTexture, pos + dir * (1.0 / 3.0 - 0.5)).xyz +\n\t\ttexture(logTexture, pos + dir * (2.0 / 3.0 - 0.5)).xyz);\n\tvec3 rgbB = rgbA * (1.0 / 2.0) + (1.0 / 4.0) * (\n\t\ttexture(logTexture, pos + dir * (0.0 / 3.0 - 0.5)).xyz +\n\t\ttexture(logTexture, pos + dir * (3.0 / 3.0 - 0.5)).xyz);\n\tfloat lumaB = dot(rgbB, luma);\n\n\tif ((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;\n\treturn rgbB;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat SCALE_RATIO = iMouse.z > 0.0 ? 1.0 : DEFAULT_SIGMA;\n    vec2 iRes = iResolution.xy, foveal = FOVEAL, foveal2 = FOVEAL2;\n    if (iMouse.x < 1.0) {\n        foveal = FOVEAL2;\n    }\n    // Equation (12) and (13)\n\tfloat maxL = max(\n\t\tmax(length((vec2(1, 1) - foveal) * iRes),\n\t\t\tlength((vec2(1, -1) - foveal) * iRes)\n\t\t\t),\n\t\tmax(length((vec2(-1, 1) - foveal) * iRes),\n\t\t\tlength((vec2(-1, -1) - foveal) * iRes)\n\t\t\t)\n\t\t);\n\tfloat L = log(maxL * 0.5);\n\tvec2 uv = fragCoord / iRes; \n    vec2 pq = uv * 2.0 - 1.0 - foveal;\n\tfloat r = length(pq * iRes * 0.5); \n\tfloat lr = log(r) / L;\n\tfloat theta = atan(pq.y * iRes.y, pq.x * iRes.x) + step(pq.y, 0.0) * TWOPI;\n\tfloat theta2 = atan(pq.y * iRes.y, -abs(pq.x) * iRes.x) + step(pq.y, 0.0) * TWOPI;\n    \n\tif (KERNEL_FUNCTION_TYPE < 1.0)\n\t\tlr = lr;\n\telse if (KERNEL_FUNCTION_TYPE < 2.0)\n\t\tlr = expFunc(lr);\n\telse if (KERNEL_FUNCTION_TYPE < 3.0)\n\t\tlr = sinFunc(lr);\n\telse if (KERNEL_FUNCTION_TYPE < 4.0)\n\t\tlr = powFunc(lr);\n\n\ttheta /= MAX_THETA;\n    theta2 /= MAX_THETA;\n        \n\tvec2 logCoord = vec2(lr, theta) / SCALE_RATIO;\n    vec2 logCoordGrad = vec2(lr, theta2) / SCALE_RATIO;\n    \n    if (!iApplyLogMap2)\n        logCoord = uv;\n\n\tvec3 col = textureGrad(logTexture, logCoord, dFdx(logCoordGrad), dFdy(logCoordGrad)).rgb;\n    \n#if USE_FXAA\n\tif (AdjustRegion > 1 && newCoord.y < 0.995 / SCALE_RATIO)\n\t\tcol = FXAA(logCoord);\n\telse if (length(uv - foveal2) > 0.1 && AdjustRegion > 0 && logCoord.y < 0.995 / SCALE_RATIO)\n\t\tcol = performGaussBlur(logCoord);\n#endif\n\n    float y = logCoord.y * SCALE_RATIO * iRes.y;\n    if (y > iRes.y - 1.0) {\n        col = texelFetch(logTexture, ivec2(logCoord*iResolution.xy), 0).rgb;\n    }\n\t//col = FXAA(logCoord);\n\tvec2 uv2 = uv * 2.0 - 1.0;\n    uv2.x *= iResolution.x / iResolution.y;\n    foveal.x *= iResolution.x / iResolution.y;\n\tif (length(foveal - uv2) < 0.05 && length(foveal - uv2) > 0.03)\n\t\tcol = mix(col, vec3(1.0), 0.2);\n\n\tfragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define FXAA_SPAN_MAX 8.0\n#define FXAA_REDUCE_MUL   (1.0/FXAA_SPAN_MAX)\n#define FXAA_REDUCE_MIN   (1.0/128.0)\n#define FXAA_SUBPIX_SHIFT (1.0/4.0)\n\n#define PI 3.141592653589793238\n#define TWOPI 6.283185307179586\n\n#define FOVEAL_WITH_MOUSE 1\n#define DEBUG_LOG_SPACE 0\n#define SEE_GROUNDTRUTH 0\n\n#define ALPHA 4.0\n#define DEFAULT_SIGMA 1.8\n\n#if DEBUG_LOG_SPACE\n\t#define iApplyLogMap1 true\n\t#define iApplyLogMap2 false\n#else\n    #if SEE_GROUNDTRUTH\n        #define iApplyLogMap1 (iMouse.z < 0.5)\n        #define iApplyLogMap2 (iMouse.z < 0.5)\n    #else\n        #define iApplyLogMap1 true\n        #define iApplyLogMap2 true\n    #endif\n#endif\n\n#define logTexture iChannel0\n#define AdjustRegion 2\n\n#define MOVECENTER\n\n#define MAX_THETA TWOPI\n#define PIXEL_SIZE (vec2(1,1) / iResolution.xy)\n\n#define USE_FXAA 0\n#define FXAA_EDGE_THRESHOLD_MIN (1.0/12.0)\n#define FXAA_EDGE_THRESHOLD (1.0/8.0)\n#define FXAA_SPAN_MAX     8.0\n\n#define KERNEL_FUNCTION_TYPE 3.0\n\n\n// foveal position\n#if FOVEAL_WITH_MOUSE\n    #define FOVEAL ((iMouse.xy / iResolution.xy) * 2.0 - 1.0)\n    #define FOVEAL2 (iMouse.xy / iResolution.xy)\n#else\n    #define FOVEAL vec2(0.0, 0.0)\n    #define FOVEAL2 vec2(0.5, 0.5)\n#endif\n\n\n\n#define MAX_DIST 1e10\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n// Plane \nfloat iPlane( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n              in vec3 planeNormal, in float planeDist) {\n    float a = dot(rd, planeNormal);\n    float d = -(dot(ro, planeNormal)+planeDist)/a;\n    if (a > 0. || d < distBound.x || d > distBound.y) {\n        return MAX_DIST;\n    } else {\n        normal = planeNormal;\n    \treturn d;\n    }\n}\n\n// Sphere:          https://www.shadertoy.com/view/4d2XWV\nfloat iSphere( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n               float sphereRadius ) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - sphereRadius*sphereRadius;\n    float h = b*b - c;\n    if (h < 0.) {\n        return MAX_DIST;\n    } else {\n\t    h = sqrt(h);\n        float d1 = -b-h;\n        float d2 = -b+h;\n        if (d1 >= distBound.x && d1 <= distBound.y) {\n            normal = normalize(ro + rd*d1);\n            return d1;\n        } else if (d2 >= distBound.x && d2 <= distBound.y) { \n            normal = normalize(ro + rd*d2);            \n            return d2;\n        } else {\n            return MAX_DIST;\n        }\n    }\n}\n\n// Box:             https://www.shadertoy.com/view/ld23DV\nfloat iBox( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal, \n            in vec3 boxSize ) {\n    vec3 m = sign(rd)/max(abs(rd), 1e-8);\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if (tN > tF || tF <= 0.) {\n        return MAX_DIST;\n    } else {\n        if (tN >= distBound.x && tN <= distBound.y) {\n        \tnormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n            return tN;\n        } else if (tF >= distBound.x && tF <= distBound.y) { \n        \tnormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n            return tF;\n        } else {\n            return MAX_DIST;\n        }\n    }\n}\n\n// Capped Cylinder: https://www.shadertoy.com/view/4lcSRn\nfloat iCylinder( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n                 in vec3 pa, in vec3 pb, float ra ) {\n    vec3 ca = pb-pa;\n    vec3 oc = ro-pa;\n\n    float caca = dot(ca,ca);\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    \n    float a = caca - card*card;\n    float b = caca*dot( oc, rd) - caoc*card;\n    float c = caca*dot( oc, oc) - caoc*caoc - ra*ra*caca;\n    float h = b*b - a*c;\n    \n    if (h < 0.) return MAX_DIST;\n    \n    h = sqrt(h);\n    float d = (-b-h)/a;\n\n    float y = caoc + d*card;\n    if (y > 0. && y < caca && d >= distBound.x && d <= distBound.y) {\n        normal = (oc+d*rd-ca*y/caca)/ra;\n        return d;\n    }\n\n    d = ((y < 0. ? 0. : caca) - caoc)/card;\n    \n    if( abs(b+a*d) < h && d >= distBound.x && d <= distBound.y) {\n        normal = normalize(ca*sign(y)/caca);\n        return d;\n    } else {\n        return MAX_DIST;\n    }\n}\n\n// Torus:           https://www.shadertoy.com/view/4sBGDy\nfloat iTorus( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n              in vec2 torus ) {\n    // bounding sphere\n    vec3 tmpnormal;\n    if (iSphere(ro, rd, distBound, tmpnormal, torus.y+torus.x) > distBound.y) {\n        return MAX_DIST;\n    }\n    \n    float po = 1.0;\n    \n\tfloat Ra2 = torus.x*torus.x;\n\tfloat ra2 = torus.y*torus.y;\n\t\n\tfloat m = dot(ro,ro);\n\tfloat n = dot(ro,rd);\n\n#if 1\n\tfloat k = (m + Ra2 - ra2)/2.0;\n    float k3 = n;\n\tfloat k2 = n*n - Ra2*dot(rd.xy,rd.xy) + k;\n    float k1 = n*k - Ra2*dot(rd.xy,ro.xy);\n    float k0 = k*k - Ra2*dot(ro.xy,ro.xy);\n#else\n\tfloat k = (m - Ra2 - ra2)/2.0;\n\tfloat k3 = n;\n\tfloat k2 = n*n + Ra2*rd.z*rd.z + k;\n\tfloat k1 = k*n + Ra2*ro.z*rd.z;\n\tfloat k0 = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n#endif\n    \n#if 1\n    // prevent |c1| from being too close to zero\n    if (abs(k3*(k3*k3-k2)+k1) < 0.01) {\n        po = -1.0;\n        float tmp=k1; k1=k3; k3=tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n#endif\n    \n    // reduced cubic\n    float c2 = k2*2.0 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3-k2)+k1;\n    float c0 = k3*(k3*(c2+2.0*k2)-8.0*k1)+4.0*k0;\n    \n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n\n    float Q = c2*c2 + c0;\n    float R = c2*c2*c2 - 3.0*c2*c0 + c1*c1;\n    \n    float h = R*R - Q*Q*Q;\n    float t = MAX_DIST;\n    \n    if (h>=0.0) {\n        // 2 intersections\n        h = sqrt(h);\n        \n        float v = sign(R+h)*pow(abs(R+h),1.0/3.0); // cube root\n        float u = sign(R-h)*pow(abs(R-h),1.0/3.0); // cube root\n\n        vec2 s = vec2( (v+u)+4.0*c2, (v-u)*sqrt(3.0));\n    \n        float y = sqrt(0.5*(length(s)+s.x));\n        float x = 0.5*s.y/y;\n        float r = 2.0*c1/(x*x+y*y);\n\n        float t1 =  x - r - k3; t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = -x - r - k3; t2 = (po<0.0)?2.0/t2:t2;\n\n        if (t1 >= distBound.x) t=t1;\n        if (t2 >= distBound.x) t=min(t,t2);\n\t} else {\n        // 4 intersections\n        float sQ = sqrt(Q);\n        float w = sQ*cos( acos(-R/(sQ*Q)) / 3.0 );\n\n        float d2 = -(w+c2); if( d2<0.0 ) return MAX_DIST;\n        float d1 = sqrt(d2);\n\n        float h1 = sqrt(w - 2.0*c2 + c1/d1);\n        float h2 = sqrt(w - 2.0*c2 - c1/d1);\n        float t1 = -d1 - h1 - k3; t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = -d1 + h1 - k3; t2 = (po<0.0)?2.0/t2:t2;\n        float t3 =  d1 - h2 - k3; t3 = (po<0.0)?2.0/t3:t3;\n        float t4 =  d1 + h2 - k3; t4 = (po<0.0)?2.0/t4:t4;\n\n        if (t1 >= distBound.x) t=t1;\n        if (t2 >= distBound.x) t=min(t,t2);\n        if (t3 >= distBound.x) t=min(t,t3);\n        if (t4 >= distBound.x) t=min(t,t4);\n    }\n    \n\tif (t >= distBound.x && t <= distBound.y) {\n        vec3 pos = ro + rd*t;\n        normal = normalize( pos*(dot(pos,pos) - torus.y*torus.y - torus.x*torus.x*vec3(1,1,-1)));\n        return t;\n    } else {\n        return MAX_DIST;\n    }\n}\n\n// Capsule:         https://www.shadertoy.com/view/Xt3SzX\nfloat iCapsule( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n                in vec3 pa, in vec3 pb, in float r ) {\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if (h >= 0.) {\n        float t = (-b-sqrt(h))/a;\n        float d = MAX_DIST;\n        \n        float y = baoa + t*bard;\n        \n        // body\n        if (y > 0. && y < baba) {\n            d = t;\n        } else {\n            // caps\n            vec3 oc = (y <= 0.) ? oa : ro - pb;\n            b = dot(rd,oc);\n            c = dot(oc,oc) - r*r;\n            h = b*b - c;\n            if( h>0.0 ) {\n                d = -b - sqrt(h);\n            }\n        }\n        if (d >= distBound.x && d <= distBound.y) {\n            vec3  pa = ro + rd * d - pa;\n            float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n            normal = (pa - h*ba)/r;\n            return d;\n        }\n    }\n    return MAX_DIST;\n}\n\n// Capped Cone:     https://www.shadertoy.com/view/llcfRf\nfloat iCone( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n             in vec3  pa, in vec3  pb, in float ra, in float rb ) {\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n    vec3  ob = ro - pb;\n    \n    float m0 = dot(ba,ba);\n    float m1 = dot(oa,ba);\n    float m2 = dot(ob,ba); \n    float m3 = dot(rd,ba);\n\n    //caps\n    if (m1 < 0.) { \n        if( dot2(oa*m3-rd*m1)<(ra*ra*m3*m3) ) {\n            float d = -m1/m3;\n            if (d >= distBound.x && d <= distBound.y) {\n                normal = -ba*inversesqrt(m0);\n                return d;\n            }\n        }\n    }\n    else if (m2 > 0.) { \n        if( dot2(ob*m3-rd*m2)<(rb*rb*m3*m3) ) {\n            float d = -m2/m3;\n            if (d >= distBound.x && d <= distBound.y) {\n                normal = ba*inversesqrt(m0);\n                return d;\n            }\n        }\n    }\n                       \n    // body\n    float m4 = dot(rd,oa);\n    float m5 = dot(oa,oa);\n    float rr = ra - rb;\n    float hy = m0 + rr*rr;\n    \n    float k2 = m0*m0    - m3*m3*hy;\n    float k1 = m0*m0*m4 - m1*m3*hy + m0*ra*(rr*m3*1.0        );\n    float k0 = m0*m0*m5 - m1*m1*hy + m0*ra*(rr*m1*2.0 - m0*ra);\n    \n    float h = k1*k1 - k2*k0;\n    if( h < 0. ) return MAX_DIST;\n\n    float t = (-k1-sqrt(h))/k2;\n\n    float y = m1 + t*m3;\n    if (y > 0. && y < m0 && t >= distBound.x && t <= distBound.y) {\n        normal = normalize(m0*(m0*(oa+t*rd)+rr*ba*ra)-ba*hy*y);\n        return t;\n    } else {   \n\t    return MAX_DIST;\n    }\n}\n\n// Ellipsoid:       https://www.shadertoy.com/view/MlsSzn\nfloat iEllipsoid( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n                  in vec3 rad ) {\n    vec3 ocn = ro / rad;\n    vec3 rdn = rd / rad;\n    \n    float a = dot( rdn, rdn );\n\tfloat b = dot( ocn, rdn );\n\tfloat c = dot( ocn, ocn );\n\tfloat h = b*b - a*(c-1.);\n    \n    if (h < 0.) {\n        return MAX_DIST;\n    }\n    \n\tfloat d = (-b - sqrt(h))/a;\n    \n    if (d < distBound.x || d > distBound.y) {\n        return MAX_DIST;\n    } else {\n        normal = normalize((ro + d*rd)/rad);\n    \treturn d;\n    }\n}\n\n// Rounded Cone:    https://www.shadertoy.com/view/MlKfzm\nfloat iRoundedCone( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n                    in vec3  pa, in vec3  pb, in float ra, in float rb ) {\n    vec3  ba = pb - pa;\n\tvec3  oa = ro - pa;\n\tvec3  ob = ro - pb;\n    float rr = ra - rb;\n    float m0 = dot(ba,ba);\n    float m1 = dot(ba,oa);\n    float m2 = dot(ba,rd);\n    float m3 = dot(rd,oa);\n    float m5 = dot(oa,oa);\n\tfloat m6 = dot(ob,rd);\n    float m7 = dot(ob,ob);\n    \n    float d2 = m0-rr*rr;\n    \n\tfloat k2 = d2    - m2*m2;\n    float k1 = d2*m3 - m1*m2 + m2*rr*ra;\n    float k0 = d2*m5 - m1*m1 + m1*rr*ra*2. - m0*ra*ra;\n    \n\tfloat h = k1*k1 - k0*k2;\n    if (h < 0.0) {\n        return MAX_DIST;\n    }\n    \n    float t = (-sqrt(h)-k1)/k2;\n    \n    float y = m1 - ra*rr + t*m2;\n    if (y>0.0 && y<d2) {\n        if (t >= distBound.x && t <= distBound.y) {\n        \tnormal = normalize( d2*(oa + t*rd)-ba*y );\n            return t;\n        } else {\n            return MAX_DIST;\n        }\n    } else {\n        float h1 = m3*m3 - m5 + ra*ra;\n        float h2 = m6*m6 - m7 + rb*rb;\n\n        if (max(h1,h2)<0.0) {\n            return MAX_DIST;\n        }\n\n        vec3 n = vec3(0);\n        float r = MAX_DIST;\n\n        if (h1 > 0.) {        \n            r = -m3 - sqrt( h1 );\n            n = (oa+r*rd)/ra;\n        }\n        if (h2 > 0.) {\n            t = -m6 - sqrt( h2 );\n            if( t<r ) {\n                n = (ob+t*rd)/rb;\n                r = t;\n            }\n        }\n        if (r >= distBound.x && r <= distBound.y) {\n            normal = n;\n            return r;\n        } else {\n            return MAX_DIST;\n        }\n    }\n}\n\n// Triangle:        https://www.shadertoy.com/view/MlGcDz\nfloat iTriangle( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n                 in vec3 v0, in vec3 v1, in vec3 v2 ) {\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n\n    vec3  n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n\n    if( u<0. || v<0. || (u+v)>1. || t<distBound.x || t>distBound.y) {\n        return MAX_DIST;\n    } else {\n        normal = normalize(-n);\n        return t;\n    }\n}\n\n// Sphere4:         https://www.shadertoy.com/view/3tj3DW\nfloat iSphere4( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n                in float ra ) {\n    // -----------------------------\n    // solve quartic equation\n    // -----------------------------\n    \n    float r2 = ra*ra;\n    \n    vec3 d2 = rd*rd; vec3 d3 = d2*rd;\n    vec3 o2 = ro*ro; vec3 o3 = o2*ro;\n\n    float ka = 1.0/dot(d2,d2);\n\n    float k0 = ka* dot(ro,d3);\n    float k1 = ka* dot(o2,d2);\n    float k2 = ka* dot(o3,rd);\n    float k3 = ka*(dot(o2,o2) - r2*r2);\n\n    // -----------------------------\n    // solve cubic\n    // -----------------------------\n\n    float c0 = k1 - k0*k0;\n    float c1 = k2 + 2.0*k0*(k0*k0 - (3.0/2.0)*k1);\n    float c2 = k3 - 3.0*k0*(k0*(k0*k0 - 2.0*k1) + (4.0/3.0)*k2);\n\n    float p = c0*c0*3.0 + c2;\n    float q = c0*c0*c0 - c0*c2 + c1*c1;\n    float h = q*q - p*p*p*(1.0/27.0);\n\n    // -----------------------------\n    // skip the case of 3 real solutions for the cubic, which involves \n    // 4 complex solutions for the quartic, since we know this objcet is \n    // convex\n    // -----------------------------\n    if (h<0.0) {\n        return MAX_DIST;\n    }\n    \n    // one real solution, two complex (conjugated)\n    h = sqrt(h);\n\n    float s = sign(q+h)*pow(abs(q+h),1.0/3.0); // cuberoot\n    float t = sign(q-h)*pow(abs(q-h),1.0/3.0); // cuberoot\n\n    vec2 v = vec2( (s+t)+c0*4.0, (s-t)*sqrt(3.0) )*0.5;\n    \n    // -----------------------------\n    // the quartic will have two real solutions and two complex solutions.\n    // we only want the real ones\n    // -----------------------------\n    \n    float r = length(v);\n\tfloat d = -abs(v.y)/sqrt(r+v.x) - c1/r - k0;\n\n    if (d >= distBound.x && d <= distBound.y) {\n\t    vec3 pos = ro + rd * d;\n\t    normal = normalize( pos*pos*pos );\n\t    return d;\n    } else {\n        return MAX_DIST;\n    }\n}\n\n// Goursat:         https://www.shadertoy.com/view/3lj3DW\nfloat cuberoot( float x ) { return sign(x)*pow(abs(x),1.0/3.0); }\n\nfloat iGoursat( in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n                in float ra, float rb ) {\n// hole: x4 + y4 + z4 - (r2^2)·(x2 + y2 + z2) + r1^4 = 0;\n    float ra2 = ra*ra;\n    float rb2 = rb*rb;\n    \n    vec3 rd2 = rd*rd; vec3 rd3 = rd2*rd;\n    vec3 ro2 = ro*ro; vec3 ro3 = ro2*ro;\n\n    float ka = 1.0/dot(rd2,rd2);\n\n    float k3 = ka*(dot(ro ,rd3));\n    float k2 = ka*(dot(ro2,rd2) - rb2/6.0);\n    float k1 = ka*(dot(ro3,rd ) - rb2*dot(rd,ro)/2.0  );\n    float k0 = ka*(dot(ro2,ro2) + ra2*ra2 - rb2*dot(ro,ro) );\n\n    float c2 = k2 - k3*(k3);\n    float c1 = k1 + k3*(2.0*k3*k3-3.0*k2);\n    float c0 = k0 + k3*(k3*(c2+k2)*3.0-4.0*k1);\n\n    c0 /= 3.0;\n\n    float Q = c2*c2 + c0;\n    float R = c2*c2*c2 - 3.0*c0*c2 + c1*c1;\n    float h = R*R - Q*Q*Q;\n    \n    \n    // 2 intersections\n    if (h>0.0) {\n        h = sqrt(h);\n\n        float s = cuberoot( R + h );\n        float u = cuberoot( R - h );\n        \n        float x = s+u+4.0*c2;\n        float y = s-u;\n        \n        float k2 = x*x + y*y*3.0;\n  \n        float k = sqrt(k2);\n\n\t\tfloat d = -0.5*abs(y)*sqrt(6.0/(k+x)) \n                  -2.0*c1*(k+x)/(k2+x*k) \n                  -k3;\n        \n        if (d >= distBound.x && d <= distBound.y) {\n            vec3 pos = ro + rd * d;\n            normal = normalize( 4.0*pos*pos*pos - 2.0*pos*rb*rb );\n            return d;\n        } else {\n            return MAX_DIST;\n        }\n    } else {\t\n        // 4 intersections\n        float sQ = sqrt(Q);\n        float z = c2 - 2.0*sQ*cos( acos(-R/(sQ*Q)) / 3.0 );\n\n        float d1 = z   - 3.0*c2;\n        float d2 = z*z - 3.0*c0;\n\n        if (abs(d1)<1.0e-4) {  \n            if( d2<0.0) return MAX_DIST;\n            d2 = sqrt(d2);\n        } else {\n            if (d1<0.0) return MAX_DIST;\n            d1 = sqrt( d1/2.0 );\n            d2 = c1/d1;\n        }\n\n        //----------------------------------\n\n        float h1 = sqrt(d1*d1 - z + d2);\n        float h2 = sqrt(d1*d1 - z - d2);\n        float t1 = -d1 - h1 - k3;\n        float t2 = -d1 + h1 - k3;\n        float t3 =  d1 - h2 - k3;\n        float t4 =  d1 + h2 - k3;\n\n        if (t2<0.0 && t4<0.0) return MAX_DIST;\n\n        float result = 1e20;\n             if (t1>0.0) result=t1;\n        else if (t2>0.0) result=t2;\n             if (t3>0.0) result=min(result,t3);\n        else if (t4>0.0) result=min(result,t4);\n\n        if (result >= distBound.x && result <= distBound.y) {\n            vec3 pos = ro + rd * result;\n            normal = normalize( 4.0*pos*pos*pos - 2.0*pos*rb*rb );\n            return result;\n        } else {\n            return MAX_DIST;\n        }\n    }\n}\n\n// Rounded Box:     https://www.shadertoy.com/view/WlSXRW\nfloat iRoundedBox(in vec3 ro, in vec3 rd, in vec2 distBound, inout vec3 normal,\n   \t\t\t\t  in vec3 size, in float rad ) {\n\t// bounding box\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*(size+rad);\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n    if (tN > tF || tF < 0.0) {\n    \treturn MAX_DIST;\n    }\n    float t = (tN>=distBound.x&&tN<=distBound.y)?tN:\n    \t\t  (tF>=distBound.x&&tF<=distBound.y)?tF:MAX_DIST;\n\n    // convert to first octant\n    vec3 pos = ro+t*rd;\n    vec3 s = sign(pos);\n    vec3 ros = ro*s;\n    vec3 rds = rd*s;\n    pos *= s;\n        \n    // faces\n    pos -= size;\n    pos = max( pos.xyz, pos.yzx );\n    if (min(min(pos.x,pos.y),pos.z)<0.0) {\n        if (t >= distBound.x && t <= distBound.y) {\n            vec3 p = ro + rd * t;\n            normal = sign(p)*normalize(max(abs(p)-size,0.0));\n            return t;\n        }\n    }\n    \n    // some precomputation\n    vec3 oc = ros - size;\n    vec3 dd = rds*rds;\n\tvec3 oo = oc*oc;\n    vec3 od = oc*rds;\n    float ra2 = rad*rad;\n\n    t = MAX_DIST;        \n\n    // corner\n    {\n    float b = od.x + od.y + od.z;\n\tfloat c = oo.x + oo.y + oo.z - ra2;\n\tfloat h = b*b - c;\n\tif (h > 0.0) t = -b-sqrt(h);\n    }\n\n    // edge X\n    {\n\tfloat a = dd.y + dd.z;\n\tfloat b = od.y + od.z;\n\tfloat c = oo.y + oo.z - ra2;\n\tfloat h = b*b - a*c;\n\tif (h>0.0) {\n\t  h = (-b-sqrt(h))/a;\n      if (h>=distBound.x && h<t && abs(ros.x+rds.x*h)<size.x ) t = h;\n    }\n\t}\n    // edge Y\n    {\n\tfloat a = dd.z + dd.x;\n\tfloat b = od.z + od.x;\n\tfloat c = oo.z + oo.x - ra2;\n\tfloat h = b*b - a*c;\n\tif (h>0.0) {\n\t  h = (-b-sqrt(h))/a;\n      if (h>=distBound.x && h<t && abs(ros.y+rds.y*h)<size.y) t = h;\n    }\n\t}\n    // edge Z\n    {\n\tfloat a = dd.x + dd.y;\n\tfloat b = od.x + od.y;\n\tfloat c = oo.x + oo.y - ra2;\n\tfloat h = b*b - a*c;\n\tif (h>0.0) {\n\t  h = (-b-sqrt(h))/a;\n      if (h>=distBound.x && h<t && abs(ros.z+rds.z*h)<size.z) t = h;\n    }\n\t}\n    \n\tif (t >= distBound.x && t <= distBound.y) {\n        vec3 p = ro + rd * t;\n        normal = sign(p)*normalize(max(abs(p)-size,1e-16));\n        return t;\n    } else {\n        return MAX_DIST;\n    };\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// KFR \nfloat powInvFunc(float lr) {\n\treturn pow(lr, 1.0 / ALPHA);\n}\n\nfloat expInvFunc(float lr) {\n\treturn log((exp(1.0) - 1.0) * lr + 1.0);\n}\n\nfloat selfInvFunc(float lr) {\n\treturn sqrt(sqrt(2.0 * lr + 0.25) - 0.5);\n}\n\nfloat sinInvFunc(float lr) {\n\treturn sin(lr * 4.0 / TWOPI);\n}\n\nvec2 logMap(float SCALE_RATIO, vec2 coord, vec2 iRes) {\n    vec2 foveal = FOVEAL;\n    if (iMouse.x < 1.0) {\n        foveal = FOVEAL2;\n    }\n    \n\tfloat maxL = max(\n\t\tmax(length((vec2(1, 1) - foveal) * iRes),\n\t\t\tlength((vec2(1, -1) - foveal) * iRes)\n\t\t\t),\n\t\tmax(length((vec2(-1, 1) - foveal) * iRes),\n\t\t\tlength((vec2(-1, -1) - foveal) * iRes)\n\t\t\t)\n\t\t);\n\tfloat L = log(maxL * 0.5);\n\tvec2 uv = SCALE_RATIO * coord / iRes;\n\t\n\tif (KERNEL_FUNCTION_TYPE < 1.0)\n\t\tuv.x = uv.x;\n\telse if (KERNEL_FUNCTION_TYPE < 2.0)\n\t\tuv.x = expInvFunc(uv.x);\n\telse if (KERNEL_FUNCTION_TYPE < 3.0)\n\t\tuv.x = selfInvFunc(uv.x);\n\telse if (KERNEL_FUNCTION_TYPE < 4.0)\n\t\tuv.x = powInvFunc(uv.x);\n\n    // Algorithm 2. Line 5 + 6.\n\tfloat x = exp(uv.x * L) * cos(uv.y * TWOPI);\n\tfloat y = exp(uv.x * L) * sin(uv.y * TWOPI);\n\tvec2 logCoord = vec2(x, y) + FOVEAL2 * iRes;\n    \n\treturn iApplyLogMap1 ? logCoord : (coord * SCALE_RATIO);\n}\n// KFR END\n\n\n#define INF 99999999.999\n//#define PI 3.1415926535\n#define NUM_OF_SAMPLES 20\n#define MAX_DEPTH 20\n\n//\n// random number generator by 1vx_437312114\n// https://www.shadertoy.com/view/lssBD7\n//\n\n// random number generator\nvec2 randState;\n\nfloat hash( const float n ) \n{\n     return fract(sin(n)*43758.54554213);\n}\n\nfloat rand2D()\n{\n    randState.x = fract(sin(dot(randState.xy, vec2(12.9898, 78.233))) * 43758.5453);\n    randState.y = fract(sin(dot(randState.xy, vec2(12.9898, 78.233))) * 43758.5453);\n    \n    return randState.x;\n}\n\n\n// random direction in unit sphere (for lambert brdf)\nvec3 random_in_unit_sphere()\n{\n    float phi = 2.0 * PI * rand2D();\n    float cosTheta = 2.0 * rand2D() - 1.0;\n    float u = rand2D();\n\n    float theta = acos(cosTheta);\n    float r = pow(u, 1.0 / 3.0);\n\n    float x = r * sin(theta) * cos(phi);\n    float y = r * sin(theta) * sin(phi);\n    float z = r * cos(theta);\n\n    return vec3(x, y, z);\n}\n\n\nvec3 random_in_unit_sphere_2()  // for Lambert brdf\n{\n\n    float x = rand2D() * 2. - 1.;\n    float y = rand2D() * 2. - 1.;\n    float z = rand2D() * 2. - 1.;\n\n    return normalize(vec3(x, y, z));\n}\n\n\n// ray struct\nstruct Ray \n{\n\tvec3 origin;\n    vec3 direction;\n};\n\nRay ray(vec3 origin, vec3 direction)\n{\n    Ray ray;\n    ray.origin = origin;\n    ray.direction = direction;\n    return ray;\n}\n\n\nstruct Sphere\n{\n\tvec3 center;\n    float radius;\n\n    int sphereMaterial;\n    float fuzz;\n    vec3 albedo;\n};   \n    \nSphere hittables[] = Sphere[4](\n    Sphere(vec3(0.000000, -100.500000, -1.000000), 100.000000, 1, 1., vec3(0.5, 0.3, 0.4)),\n    Sphere(vec3(0., 0., -1.), .5, 1, 0.427369, vec3(0.7, 0.1, 0.1)),\n    Sphere(vec3(-1.1, 0., -1.), .5, 2, 0., vec3(0.8, 0.8, 0.8)),\n    Sphere(vec3(1.1, 0., -1.), .5, 2, 0.2, vec3(0.4, 0.6, 0.3))\n);\n\nstruct HitInfo\n{\n\tvec3 p;  // hit position\n    vec3 normal;\n    float t;  // hit time\n\n    int hitMaterial;\n    vec3 hitAttenuation;\n    float hitFuzzy;\n};\n\n// My reflect function\nvec3 myReflect(vec3 inDirection, vec3 normal) \n{\n    // Whether this should be normalized ?\n    return inDirection - 2.*dot(inDirection, normal) * normal; // see https://raytracing.github.io/books/RayTracingInOneWeekend.html#diffusematerials 9.4\n}\n\n// 1 is lambertian; 2 is metal; 3 is dielectrics\nbool materialScatter(HitInfo info, Ray rayIn, out Ray rayOut, out vec3 attenuation)  // return whether scatter; store new ray info\n{\n    int hitMaterial = info.hitMaterial;\n    if (hitMaterial == 1){\n        rayOut.origin = info.p;\n        vec3 target = info.p + info.normal + random_in_unit_sphere();\n        rayOut.direction = target - info.p;\n        attenuation = info.hitAttenuation;\n        return true;\n    } else if (hitMaterial == 2) {\n        rayOut.origin = info.p;\n        rayOut.direction = reflect(rayIn.direction, info.normal) + info.hitFuzzy * random_in_unit_sphere();\n        attenuation = info.hitAttenuation;\n        return (dot(rayOut.direction, info.normal) > 0.);\n    }\n    return false;\n}\n\n// Check whether the ray hit the sphere and store all the hit info\nbool isHitSphere(Sphere s, Ray ray, float tMin, float tMax, out HitInfo info)\n{   \n    bool isHit = false;\n\tvec3 aMinusC = ray.origin - s.center;\n    float a = dot(ray.direction, ray.direction);\n    // float a = sqrt(length(ray.direction));\n    float bhalf = dot(ray.direction, aMinusC);\n    float b = 2. * bhalf;\n    float c = dot(aMinusC, aMinusC) - s.radius * s.radius;\n    float discriminant = b*b - 4.*a*c;\n    if (discriminant < 0.) return false;\n    float t = (-b - sqrt(discriminant)) / (2.*a);\n    if (t < tMin || t > tMax) {    // Check the min and max range of the ray\n        t = (-b + sqrt(discriminant)) / (2.*a);\n        if (t < tMin || t > tMax) return isHit;\n    }\n\n    // Set hit info\n    isHit = true;\n    info.t = t;\n    info.p = ray.origin + t*ray.direction;\n    info.normal = (info.p - s.center) / s.radius;\n    info.hitMaterial = s.sphereMaterial;\n    info.hitAttenuation = s.albedo;\n    info.hitFuzzy = s.fuzz;\n    //info.normal = vec3(1., 0., 0.);\n    return isHit;\n}\n\n// Test ray interact with all the interactable objects in the scene, and store the closest hit info into the info \nbool hitScene(Ray ray, float tMin, float tMax, out HitInfo info) \n{\n    bool hitAnything = false;\n    HitInfo tempInfo;\n    float closestHit = tMax;\n    for (int i = 0; i < hittables.length(); i++) {\n        Sphere curr = hittables[i];\n        if (isHitSphere(curr, ray, tMin, tMax, tempInfo)) {\n            hitAnything = true;\n            if (closestHit > tempInfo.t) { // Should check here! debug for a long time\n                closestHit = tempInfo.t;\n                info = tempInfo;\n            }\n        }\n    }\n    return hitAnything;\n}\n\n//Call hisScene() in this function\nvec3 rayColor(Ray ray, float tMin, float tMax) // Find the ray color 1 time.\n{\n    HitInfo info;\n    vec3 col = vec3(1.0, 1.0, 1.0);\n    //float hitTime = isHitSphere(vec3(0., 0., -2.), 0.5, ray);\n    int i = 0;\n    for (; i < MAX_DEPTH; i ++) \n    {\n        if (hitScene(ray, tMin, tMax, info)) {\n            Ray rayOut;\n            vec3 attenuation;\n            if (materialScatter(info, ray, rayOut, attenuation)) {\n                ray = rayOut;\n                col *= attenuation;\n            }\n         \n            //return 0.5*(info.normal + vec3(1));\n        } else {\n            vec3 unitDirection = normalize(ray.direction);\n            float t = 0.5*(unitDirection.y + 1.0);\n            col *= (1.0 - t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0);\n            break;  \n        }    \n    }\n    if (i == MAX_DEPTH) return vec3(0., 0., 0.);\n    return col;\n    // vec3 unitDirection = normalize(ray.direction);\n    // float t = 0.5*(unitDirection.y + 1.0);\n    // return (1.0 - t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0);   \n}\n\n// vec3 rayColor(Ray ray, float tMin, float tMax) // Find the ray color 1 time.\n// {\n//     HitInfo info;\n//     if (hitScene(ray, tMin, tMax, info))\n//     {\n//         return 0.5 * (info.mormal + vec3(1., 1., 1.));\n//     }\n//     vec3 unitDirection = normalize(ray.direction);\n//     float t = 0.5*(unitDirection.y + 1.0);\n//     return (1.0 - t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0);   \n// }\n\n// Camera\nstruct Camera\n{\n\tvec3 origin;\n    vec3 lookAt;\n    vec3 f; // forward\n    vec3 u;  // right\n    vec3 v;  // up\n    float zoom;\n};\n\nCamera camera(vec3 origin, vec3 lookAt, float zoom)\n{\n    Camera camera;\n    camera.origin = origin;\n    camera.lookAt = lookAt;\n    camera.f = normalize(camera.lookAt - camera.origin);\n    camera.u = cross(vec3(0., 1., 0.), camera.f);\n    camera.v = cross(camera.f, camera.u);\n    camera.zoom = zoom;\n    return camera;\n}\n\nRay cameraGetRay(Camera camera, float u, float v) \n{\n    vec3 origin = camera.origin;\n    vec3 direction = camera.origin + camera.zoom * camera.f + u * camera.u + v * camera.v -camera.origin;\n    return ray(origin, direction);\n}\n\n\n\nvoid mainShader( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;  // -0.5 <> 0.5\n    uv.x *= iResolution.x/iResolution.y;\n    float d = length(uv);\n    float c = smoothstep(0.1, 0.12, d);\n    \n    // https://www.shadertoy.com/view/tl23Rm  rotate camera code using mouse\n    vec2 mo = iMouse.xy == vec2(0) ? vec2(.125) : \n              abs(iMouse.xy)/iResolution.xy - .5;\n    \n\tfloat time = 64.0 + iTime*3.5;\n    vec3 ro = vec3(0., 0., 1.) + vec3( 3.5*cos(0.1*time + 0.0*mo.x), 3.3 + 0.0*mo.y, 3.5*sin(0.1*time + 0.0*mo.x) );\n\n\n    // Camera \n    Camera camera = camera(ro, vec3(0., 0., -1.), 0.6);\n    float tMin = 0.0001;\n    float tMax = INF;\n    randState = fragCoord.xy / iResolution.xy;\n\n    // Calu intersect\n    vec3 col = vec3(0., 0., 0.);\n    for (int i = 0; i < NUM_OF_SAMPLES; i++)\n    {\n        float u = (fragCoord.x + rand2D()) / iResolution.x - 0.5;\n        u *= iResolution.x/iResolution.y;\n        float v = (fragCoord.y + rand2D()) / iResolution.y - 0.5;\n        Ray ray = cameraGetRay(camera, u, v);\n        col += rayColor(ray, tMin, tMax);\n    }\n    \n    float scale = 1.0 / float(NUM_OF_SAMPLES);\n    col /= float(NUM_OF_SAMPLES);\n    col = sqrt(col);\n    \n\t\n    //if (isHitSphere(center, r, ray))\n   // {\n    \t//col = vec3(1., 0., 0.);\n    //}\n    \n    // Set the color as the ray height and apply lerp\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col, 1.);\n}\n\n// EXTERNEL SHADER END\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat SCALE_RATIO = iMouse.z > 0.0 ? 1.0 : DEFAULT_SIGMA;\n\tvec2 uv = SCALE_RATIO * fragCoord / iResolution.xy;\n\n\tif (uv.x > 1.0 || uv.y > 1.0) {\n        if (uv.y > 1.0 && uv.y < 1.0 + 1.0/iResolution.y) {\n        \tfragCoord -= iResolution.xy / SCALE_RATIO;\n        } else {\n\t\t\tdiscard;\n        }\n\t}\n\tvec2 logCoord = logMap(SCALE_RATIO, fragCoord, iResolution.xy);\n\t\n\tmainShader(fragColor, logCoord);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}