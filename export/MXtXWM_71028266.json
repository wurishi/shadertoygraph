{"ver":"0.1","info":{"id":"MXtXWM","date":"1720342891","viewed":35,"name":"Magic Ice Cube","username":"maxiie","description":"Magic Ice Cube","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["cube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.141592;\nconst float tau = 2.0*pi;\n\n//#define TIME (3.0*tau/4.0)\n#define TIME iTime/2.0\n\nconst float sphereRadius = 15.0;\nconst float camRadius = 2.0*sphereRadius;\n\nstruct hit {\n    bool didHit;\n    vec3 col;\n};\n   bool cube(vec3 p, float sz){\n    return abs(p.x)<sz&&abs(p.y)<sz&&abs(p.z)<sz;\n}\n\nhit getVoxel(vec3 p) {\n    if (cube(p,12.)&&!cube(p,8.))\n        return hit(true, vec3(p) / (sphereRadius * 2.0) + 0.6);\n    else\n        return hit(false, vec3(0,0,0));\n\n}\n\nvec3 lighting(vec3 norm, vec3 pos, vec3 rd, vec3 col) {\n    vec3 lightDir = normalize(vec3(-1.0, 3.0, -1.0));\n    float diffuseAttn = max(dot(norm, lightDir), 0.0);\n    vec3 light = vec3(1.0,0.9,0.9);\n    \n    vec3 ambient = vec3(0.2, 0.2, 0.3);\n    \n    vec3 reflected = reflect(rd, norm);\n    float specularAttn = max(dot(reflected, lightDir), 0.0);\n    \n    return col*(diffuseAttn*light*1.0 + specularAttn*light*0.6 + ambient);\n}\n\n// Voxel ray casting algorithm from \"A Fast Voxel Traversal Algorithm for Ray Tracing\" \n// by John Amanatides and Andrew Woo\n// http://www.cse.yorku.ca/~amana/research/grid.pdf\nhit intersect(vec3 ro, vec3 rd) {\n    //Todo: find out why this is so slow\n    vec3 pos = floor(ro);\n    \n    vec3 step = normalize(rd)/10.;\n    vec3 tDelta = step / rd;\n\n    \n    float tMaxX, tMaxY, tMaxZ;\n    bool last=false;\n    \n\n    vec3 norm;\n    const int maxTrace = 100;\n    vec3 col=vec3(0);\n    bool dh=false;\n    float br=1.;\n    for (int i = 0; i < maxTrace; i++) {\n        hit h = getVoxel(pos);\n        if (h.didHit) {\n            col=(br*col+h.col+sin(pos)*2.+sin(length(pos)*3.));\n            col=normalize(col);\n            dh=true;\n            br=br+1.;\n            pos+=step/20.;\n            i=0;\n            \n            \n        }\n        else pos+=step*5.;\n         \n    }\n\n \treturn hit(dh,col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    vec3 worldUp = vec3(0,1,0);\n    vec3 camPos = vec3(camRadius*sin(TIME), 10, 1.0*camRadius*cos(TIME));\n    vec3 lookAt = vec3(0,0,0);\n    vec3 camDir = normalize(lookAt - camPos);\n    vec3 camRight = normalize(cross(camDir, worldUp));\n    vec3 camUp = cross(camRight, camDir);\n    \n    vec3 filmCentre = camPos + camDir*0.3;\n    vec2 filmSize = vec2(1,iResolution.y / iResolution.x);\n    \n    vec3 filmPos = filmCentre + uv.x*filmSize.x*camRight + uv.y*filmSize.y*camUp;\n    vec3 ro = camPos;\n    vec3 rd = normalize(filmPos - camPos);\n    \n    hit h = intersect(ro, rd);    \n    if(h.didHit) {\n        fragColor = vec4(h.col*h.col*2.,1);\n    } else{\n        fragColor = vec4(0,0,0,0);\n    }\n}","name":"Image","description":"","type":"image"}]}