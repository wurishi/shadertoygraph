{"ver":"0.1","info":{"id":"tdffRj","date":"1588594847","viewed":314,"name":"Journey to Another World V.1","username":"julianlumia","description":"reimagining of an Alex grey painting:)","likes":20,"published":1,"flags":32,"usePreview":0,"tags":["tunnelthingy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//the fractal structure is a modified version of: Acient Temple by Kali\n//radial blur from jeyko: https://www.shadertoy.com/view/WlKXRR :)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n\n    float steps = 10.;\n    float scale = 0.00 + pow(length(uv - 0.5)*1.2,3.)*0.4;\n    float chromAb = pow(length(uv - 0.5),1.4)*2.1;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n    \n        scale *= 0.92;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    \n    fragColor = radial*1.; \n    \n    fragColor *= 2.0;\n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.2);\n    \n    fragColor = max(fragColor, 0.);\n    fragColor.xyz = pow(fragColor.xyz, vec3(.3,1.,1.));\n\n    fragColor *= 1. - dot(uvn,uvn)*1.8;\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define pi acos(-1.)\n\nconst int Iterations=12;\nconst float detail=.0006;\nconst float Scale=1.9999;\nvec3 lightdir=normalize(vec3(0.,-1,-1.));\n\n  float eyes3;\n\nfloat ot=0.;\nfloat det=0.;\n\nfloat hitfloor;\nfloat hitrock;\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nmat3 rotate( in vec3 v, in float angle)\n{\n float c = cos(radians(angle));\n float s = sin(radians(angle));\t\n return mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n (1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n (1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n );\n}\nfloat tt;\n\nfloat dBox(vec3 p, vec3 s)\n{\n return length (max (abs(p)-s,0.));   \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\n\nfloat g1;\nfloat g2;\nfloat g3;\nfloat g4;\nfloat g5;\n\nfloat de(vec3 pos) {\n vec3 o5 = pos;\n hitfloor=0.;\n hitrock=0.;\n vec3 p10; \n vec3 p2 = pos;\n vec3 p=pos;\n p.xz=abs(.5-mod(pos.xz,1.));\n float DEfactor=1.;\n for (int i=0; i<Iterations; i++) {\n  p = abs(p)-vec3(.452,2.,0.);  \n  float r2 = dot(p*vec3(2.,5.0,1.), p)*.2;\n  float sc=Scale/clamp(r2,sin(abs(p.y-0.5)*.5)*.50,1.);\n  p*=sc; \n  DEfactor*=sc;\n  p = p - vec3(0.5,13.,0.5);\n }\n //definition\n float d=length(p)/DEfactor-.0003;\n vec3 from=vec3(-0.049,3.059,-iTime*-0.002+0.023);\n float sep = 0.0;  \n p2.x = abs(p2.x-sep);\n from.x = abs(from.x-sep); \n p2 -= vec3(-0.32,0,.0);\n vec3 p3 =  p2;\n p2 -=from;\n float gap = .03; \n from.z = mod(from.z + gap,2. * gap) - gap;\n p2.z = mod(p2.z + gap,2. * gap) - gap;\n gap = .025;   \n from.x = mod(from.x + gap,2. * gap) - gap;\n p2.x = mod(p2.x + gap,2. * gap) - gap;\n float e;\n float   the = sin(pos.z*30.+iTime)*0.1;\n p2.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n the = sin(pos.z*20.+iTime)*0.1;\n p2.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n the = (0.2)*1.;\n p2.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n from.xz *= -mat2(cos(the), -sin(the), sin(the), cos(the));  \n p2.x=abs(p2.x)-0.001;\n float eyes2;\n for(float i=0.; i<8.; i++)    \n {\n p2 = rotate( ( vec3(0.0,1., 0. )),45.)*p2;\n p2.xz += 1.*0.006;\n float e = dBox(p2,vec3(0.004,.01,.000));\n float nose = dBox(p2,vec3(abs(sin(p2.y*100.+2.2)*2.)*0.001,(sin(p2.x*10.+2.2)*2.)*.002,abs(sin(p2.y*100.+2.2))*.003));    \n vec3 p3 =  p2;\n p3 -= vec3(-0.000,0.002,0.0001);\n p3.xz = abs(p3.xz)-.003;\n float eyes = sdRoundBox(p3,vec3(0.0019,.0013,.02),0.0001);  \n p3 -= vec3(-0.002,0.007,-0.002);\n eyes2 = dBox(p3,vec3(0.0003,.002,.0002));  \n vec3 p4 =  p2;\n p4.xz = abs(p4.xz)-0.001;\n p4 -= vec3(0.000,-0.006,0.001);\n p4.y = abs(p4.y)-0.0005;\n float mond = dBox(p4,vec3(0.002,(sin(p4.x*-200.+0.4)*4.)*.0002,.0001)); \n vec3 p5 =  p2;\n e =smin(e,mond,0.002);\n e = min(e,nose);\n float y =min(eyes2, max(e,-eyes));\n if( y  < d)\n  {\n   d=min(y*.9 ,d);\n   eyes3=eyes2;\n  }\n }   \n p10=o5-=from;\n float  gap2 = .03; \n p10.z = mod(p10.z + gap2,2. * gap2) - gap2;\n gap2 = .030; \n p10.x = mod(p10.x + gap2,2. * gap2) - gap2;\n       \n vec3 op = p10;\n  the = iTime;  \n vec3 op1 = op-vec3(-0.01,-0.025,0.);\n vec3 snakesize =vec3(.0000,0,0001.);\n op1 =op1-vec3(cos(o5.z*25.+iTime*.1-pi)*4.,sin(o5.z*25.+iTime*.5-pi)-0.0*4.,0)*0.002;\n vec2 box15 = vec2((dBox(op1-vec3(-0.00,0.000,0.), snakesize)),0.);\n box15.x += cos(o5.z*8.-iTime*1.)*0.005+sin(o5.y*.1-iTime-pi*4.)*.001;\n d=min(d,box15.x);\n g3 +=2./(0.0004+pow(abs(box15.x),1.));\n g2 +=1./(0.0004+pow(abs(eyes3),3.));\n\n\n return d;\n}\n\n\n\nvec3 normal(vec3 p) {\n vec3 e = vec3(0.0,det,0.0);\n return normalize(vec3(\n  de(p+e.yxx)-de(p-e.yxx),\n  de(p+e.xyx)-de(p-e.xyx),\n  de(p+e.xxy)-de(p-e.xxy)\n  )\n );\n\n}\n\n\n\n\nmat2 rot;\n\nvec3 raymarch(in vec3 from, in vec3 dir) \n{\n\tfloat t=iTime;\n\tfloat cc=cos(t*.03); float ss=sin(t*.03);\n    rot=mat2(cc,ss,-ss,cc);\n    vec2 lig=vec2(sin(t*2.)*.6,cos(t)*.25-.25);\n\tfloat fog,glow,d=1., totdist=glow=fog=0.;\n\tvec3 p, col=vec3(0.);\n\tfloat ref=0.;\n\tfloat steps;\n\tfor (int i=0; i<64; i++) {\n\t\tif (d>det && totdist<1.5) {\n\t\t\tp=from+totdist*dir;\n\t\t\td=de(p);\n\t\t\tdet=detail*(0.+totdist*5.);\n\t\t\ttotdist+=d; \n\t\t\tglow+=max(0.,.015-d)*exp(-totdist);\n\t\t\tsteps++;\n\t\t}\n\t}\n\tcol+=glow*vec3(0.,.9,.8)*.44;\n\treturn col; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ttt=iTime*.5;\n    vec2 uv = fragCoord.xy / iResolution.xy*2.-1.;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec2 mouse=(iMouse.xy/iResolution.xy-.5);\n\tfloat t=iTime*.15;\n\tfloat y=(cos(iTime*.2+3.)+1.);\n\tif (iMouse.z<1.) mouse=vec2(sin(t*3.)*2.,cos(t)+.5)*.04*(.9+y)*min(1.4,iTime*10.);\n\tuv+=mouse*0.5;\n    vec3 from=vec3(sin(iTime)*0.002,3.06,iTime*1.*0.05);\n    float the = sin(iTime*.2)*0.5+0.04;\n\tvec3 dir=normalize(vec3(uv*.85,1.));\n    dir.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    vec3 color=raymarch(from,dir); \n\tcolor=pow(color,vec3(1.6));\n\tcolor=mix(vec3(length(color)),color,.2)*.95;\n\tcolor*= 3.;\n\t//glow at the end of the tunnel\n\tcolor +=g3*vec3(.002)*vec3(0.,1.,.6)*.004+0.0;\n\tcolor +=g2*vec3(.001)*vec3(.0,.04,.0)*.02+0.0;\n    color+=vec3(.2,.8,.35)*pow(max(0.,.25-length(uv-vec2(0.,.03)))/.3,1.5)*.65;\n\n\tfragColor = vec4(color,1.);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}