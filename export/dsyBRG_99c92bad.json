{"ver":"0.1","info":{"id":"dsyBRG","date":"1698344272","viewed":61,"name":"[zznewclear13] *Not* WatchOS","username":"zznewclear13","description":"I want to make a scrollable ui similar to WatchOS.\nInteractable with iMouse.xy.\n\npyBlob's [url=https://www.shadertoy.com/view/fddBRS]Apple Hex Icons[/url] is also really cool.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["2d","ui","hex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// [zznewclear13] *Not* WatchOS\n// https://www.shadertoy.com/view/dsyBRG\n// I want to make a scrollable ui similar to WatchOS.\n// Interactable with iMouse.xy.\n\n// pyBlob's [url=https://www.shadertoy.com/view/fddBRS]Apple Hex Icons[/url] is also really cool.\n\nfloat getScaleFactor(float dist)\n{\n    float x = dist + pixelCount;\n    return exp(-x * x / (100.0f * pixelCount * pixelCount));\n}\n\nvec3 drawFace(vec2 inHexUV, float size)\n{\n    vec3 color = vec3(1.0f, 1.0f, 0.0f);\n    vec2 eyeUV = vec2(abs(inHexUV.x), inHexUV.y);\n    float sdEye = length(eyeUV - vec2(0.36f, 0.38f) * size);\n    float eyeSize = 0.18f * size;\n    float eyeAlpha = smoothstep(eyeSize + 1.5f, eyeSize, sdEye);\n    \n    vec2 mouthUV = vec2(inHexUV.x, -inHexUV.y);\n    float angle = 1.0f;\n    vec2 sinCosVal = vec2(sin(angle), cos(angle));\n    float sdMouth = sdArc(mouthUV, sinCosVal, 0.6f * size, 0.01f * size);\n    float mouthThickness = 0.07f * size;\n    float mouthAlpha = smoothstep(mouthThickness + 1.5f, mouthThickness, sdMouth);\n    \n    vec3 darkColor = vec3(0.05f, 0.05f, 0.10f);   \n    color = mix(color, darkColor, vec3(max(eyeAlpha, mouthAlpha)));\n\n    return color;\n}\n\nfloat drawCircle(vec2 inHexUV, vec3 rv, vec4 posRange, vec2 sizeRange)\n{\n    vec2 pos = posRange.xy + rv.xy * (posRange.zw - posRange.xy);\n    float sdCircle = length(inHexUV - pos);\n    float circleSize = sizeRange.x + rv.z * (sizeRange.y - sizeRange.x);\n    return smoothstep(circleSize + 1.5f, circleSize, sdCircle);\n}\n\nvec3 drawIdenticon(vec2 inHexUV, vec2 fHexID, float size)\n{\n    vec4 hashVal = hash42(fHexID);\n    vec3 color1 = hsv2rgb_smooth(vec3(hashVal.x, 0.8f, 0.45f));\n    vec3 color2 = hsv2rgb_smooth(vec3(hashVal.x+0.01f, 0.55f, 0.7f));\n    \n    vec3 darkColor = hsv2rgb_smooth(vec3(hashVal.y+0.4f, 0.85f, 0.1f));\n    vec3 color3 = hsv2rgb_smooth(vec3(hashVal.y+0.61f, 0.25f, 0.95f));\n    \n    // Ewwwwwwwwwwww\n    vec4 tempHash = hash42(hashVal.xz);\n    float circleAlpha1 = drawCircle(inHexUV, tempHash.zyx, vec4(-0.9f, -1.8f, 0.2f, -1.0f) * size, vec2(1.2f, 2.0f) * size);\n    tempHash = hash42(tempHash.zy);\n    float circleAlpha2 = drawCircle(inHexUV, tempHash.ywz, vec4(0.3f, -0.6f, 0.5f, 0.0f) * size, vec2(0.6f, 0.8f) * size);\n    tempHash = hash42(tempHash.wx);\n    float circleAlpha3 = drawCircle(inHexUV, tempHash.xzw, vec4(-0.2f, 0.1f, 0.2f, 0.8f) * size, vec2(0.1f, 0.6f) * size);\n\n    vec3 color = mix(darkColor, color1, circleAlpha1);\n    color = mix(color, color2, circleAlpha2);\n    color = mix(color, color3, circleAlpha3);\n    \n    return color;\n}\n\nvec4 drawIcon(vec2 inHexUV, vec2 fHexID, float size)\n{\n    float hashVal = hash42(fHexID).y;\n    vec3 color;\n    if(all(equal(fHexID, vec2(0.0f))) || hashVal > 0.99f)\n    {\n        color = drawFace(inHexUV, size);\n    }\n    else\n    {\n        color = drawIdenticon(inHexUV, fHexID, size);\n    }\n\n    float fresnelVal = pow(length(inHexUV) / size, 10.0f);\n    float dist = length(inHexUV);\n    float alpha = smoothstep(size + 1.5f, size, dist) * clamp(1.0f - fresnelVal * 0.8f, 0.0f, 1.0f);\n\n    return vec4(color, alpha);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    DECLARE_ROTATION\n\n    vec2 hexOffset = texelFetch(iChannel0, ivec2(0, 2), 0).xy;\n    vec2 hexUV = fragCoord - iResolution.xy * 0.5f + hexOffset;\n    vec2 centerHexUV = hexOffset;\n    \n    pixelCount = iResolution.y / AMOUNT;\n    float invPixelCount = 1.0f / pixelCount;\n    \n    ivec2 hexID = hexagonID(hexUV * invPixelCount, invRotMat);\n    vec2 fHexID = vec2(hexID);\n    vec2 hexCenter = hexagonCenFromID(hexID, rotMat) * pixelCount;\n    \n    vec2 toCenter = hexCenter - centerHexUV;\n    float distToCenter = length(hexCenter - centerHexUV);\n    float scaleFactor = getScaleFactor(distToCenter);\n    // This just works.\n    hexCenter = hexCenter - toCenter * scaleFactor * 0.08f;\n    \n    float size = pixelCount * 0.75f * scaleFactor;\n    vec2 inHexUV = hexUV - hexCenter;\n    vec4 alpha = drawIcon(inHexUV, fHexID, size);\n    \n    vec3 color = mix(vec3(0.01f), alpha.rgb, alpha.w);\n    color = pow(color, vec3(0.4545f));\n    fragColor = vec4(color, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define AMOUNT 10.0f\nfloat pixelCount = 1.0f;\n#define DECLARE_ROTATION float rotAngle = 0.2f;\\\n                            float sinVal = sin(rotAngle);\\\n                            float cosVal = cos(rotAngle);\\\n                            mat2 rotMat = mat2(sinVal, cosVal, cosVal, -sinVal);\\\n                            mat2 invRotMat = mat2(-sinVal, cosVal, cosVal, sinVal);\\\n\n#define SQRT_3 1.732050807\n\n// From Dave_Hoskins' Hash without Sine \n// https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n// From https://www.mvps.org/directx/articles/catmull/\nvec2 catmull_rom(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t)\n{\n    vec4 tVec = vec4(1.0f, t, t*t, t*t*t);\n    vec4 px = vec4(p0.x, p1.x, p2.x, p3.x);\n    vec4 py = vec4(p0.y, p1.y, p2.y, p3.y);\n    mat4 characterMat = mat4(0.0f, -1.0f, 2.0f, -1.0f,\n                            2.0f, 0.0f, -5.0f, 3.0f,\n                            0.0f, 1.0f, 4.0f, -3.0f,\n                            0.0f, 0.0f, -1.0f, 1.0f);\n    float xPos = 0.5f * dot(tVec, characterMat * px);\n    float yPos = 0.5f * dot(tVec, characterMat * py);  \n    return vec2(xPos, yPos);    \n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdArc( in vec2 p, in vec2 sc, in float ra, float rb )\n{\n    // sc is the sin/cos of the arc's aperture\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\n// From iq's Hexagonal Grid Traversal - 3D\n// https://www.shadertoy.com/view/WtSfWK\nint mod3( int n )\n{\n    return (n<0) ? 2-((2-n)%3) : n%3;\n}\n\n// I flipped x and y axes and scaled by 2/sqrt(3)\nivec2 hexagonID( vec2 p, mat2 rotMat) \n{\n    p.xy = rotMat * p.yx * 2.0f / SQRT_3;\n    const float k3 = SQRT_3;\n\tvec2 q = vec2( p.x, p.y*k3*0.5 + p.x*0.5 );\n\n    ivec2 pi = ivec2(floor(q));\n\tvec2  pf =       fract(q);\n    \n\tint v = mod3(pi.x+pi.y);\n\n\tint   ca = (v<1)?0:1;\n\tint   cb = (v<2)?0:1;\n    ivec2 ma = (pf.x>pf.y)?ivec2(0,1):ivec2(1,0);\n    \n\tivec2 id = pi + ca - cb*ma;\n    \n    return ivec2( id.x, id.y - (id.x+id.y)/3 );\n}\n\nvec2 hexagonCenFromID( in ivec2 id, mat2 rotMat)\n{\n    const float k3 = SQRT_3;\n    return rotMat * vec2(float(id.y)*k3, float(id.x)) * SQRT_3 / 2.0f;\n}\n\n// https://www.shadertoy.com/view/MsS3Wc\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 loadFromTexel(uint y, uint x)\n{\n    return texelFetch(iChannel0, ivec2(x, y), 0);\n}\n\nvoid saveToTexel(ivec2 iFragCoord, uint y, uint x, vec4 valueToSave, inout vec4 prevVal)\n{\n    if(iFragCoord.x == int(x) && iFragCoord.y == int(y))\n    {\n        prevVal = valueToSave;\n    }\n}\n\nvec2 getOffset(float time)\n{\n    float timeFrame = floor(time);\n    float deltaTime = fract(time);\n    \n    vec2 p0 = timeFrame == 0.0f ? vec2(0.0f) : hash21(timeFrame);\n    vec2 p1 = hash21(timeFrame + 1.0f);\n    vec2 p2 = hash21(timeFrame + 2.0f);\n    vec2 p3 = hash21(timeFrame + 3.0f);\n    vec2 hexPos = catmull_rom(p0, p1, p2, p3, deltaTime);\n\n    return (hexPos * 2.0f - 1.0f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame == 0)\n    {\n        fragColor = vec4(0.0f); return;\n    }\n    \n    ivec2 iFragCoord = ivec2(floor(fragCoord));\n    vec4 prevVal = loadFromTexel(uint(iFragCoord.y), uint(iFragCoord.x));\n      \n    vec2 mousePos = vec2(0.0f);  \n    vec2 lastSpeed = loadFromTexel(1u, 0u).xy;\n    vec2 offset = loadFromTexel(2u, 0u).xy;\n    float lastMouseDownTime = loadFromTexel(3u, 0u).x;\n    if(iMouse.z > 0.0f)\n    {    \n        mousePos = iMouse.xy;\n        vec2 lastMousePos = iMouse.w > 0.0f ? mousePos : loadFromTexel(0u, 0u).xy;\n        lastSpeed = -(mousePos - lastMousePos);\n        saveToTexel(iFragCoord, 0u, 0u, vec4(iMouse.xy, 0.0f, 0.0f), prevVal);\n        \n        lastMouseDownTime = 8.0f;       \n    }\n    \n    lastMouseDownTime -= 0.02f;\n    if(lastMouseDownTime > 0.0f)\n    {    \n        offset += lastSpeed;\n        lastSpeed *= vec2(0.95f);\n\n        pixelCount = iResolution.y / AMOUNT;\n        float invPixelCount = 1.0f / pixelCount;\n\n        DECLARE_ROTATION\n        ivec2 nearestHexagonID = hexagonID(offset * invPixelCount, invRotMat);\n        vec2 nearestHexagonCen = hexagonCenFromID(nearestHexagonID, rotMat) * pixelCount;\n        if(iMouse.z <= 0.0f && length(lastSpeed) < 0.1f * pixelCount)\n        {\n            vec2 accel = (nearestHexagonCen - offset) * 0.005f;\n            lastSpeed += accel;\n            // offset = mix(offset, nearestHexagonCen, 0.05f);\n            // lastSpeed = vec2(0.0f);\n        }\n    }\n    else\n    {   \n        offset += getOffset(-lastMouseDownTime * 0.5f);\n        lastSpeed = vec2(0.0f);\n    }\n\n    saveToTexel(iFragCoord, 1u, 0u, vec4(lastSpeed, 0.0f, 0.0f), prevVal);\n    saveToTexel(iFragCoord, 2u, 0u, vec4(offset, 0.0f, 0.0f), prevVal);\n    saveToTexel(iFragCoord, 3u, 0u, vec4(lastMouseDownTime, 0.0f, 0.0f, 0.0f), prevVal);\n    \n    fragColor = prevVal;\n}","name":"Buffer A","description":"","type":"buffer"}]}