{"ver":"0.1","info":{"id":"sstfRn","date":"1656036492","viewed":126,"name":"Fixed Point Simulated Blending","username":"jnishimu2022","description":"blending with fixed point simulation","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["blending"],"hasliked":0,"parentid":"NljfWW","parentname":"Blending example"},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Types of blending effects shown in the demo.\n// - fast zoom: global blending based on zoom ratio (e.g. 3-4s) or ellipse based blending shown here\n// - for most of the cases, camera switches (with the blending) AFTER zoom stops. This is only for .5/1/3 tap-based zoom though.\n// This shader simulates the ellipse based blending.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Compute the coordinate in the field unit.\n    vec2 xy = fragCoord - 0.5 * iResolution.xy;\t\t// Shift origin to center\n    float scale = 1.0 / iResolution.x;\n    xy = xy * scale;\t\t\t\t\t// Normalize to [-0.5, 0.5]\n    vec2 xyf = xy * 2.0;                // Normalize to [-1, 1]\n    vec2 uvw = xyf*0.5+0.5;\n    vec2 uvuw = xyf*1.05*0.5+0.5;\n\n\n    vec4 wide = texture(iChannel0, uvw) * vec4(0.1, 1.0, 0.9, 1.0);\n    vec4 uw = texture(iChannel1, uvuw) * vec4(0.9, 1.1, 0.1, 1.0);\n\n\n    // Blending part starts.\n    vec2 xy_centered = fragCoord - 0.5 * iResolution.xy;\t\t// Shift origin to center\n    vec2 xy_normalized = vec2(xy_centered.x/iResolution.x, xy_centered.y/iResolution.y);\n    float dist_normalized = length(xy_normalized * 2.0);        // [0.0, 1.0]\n    float switch_speed = 0.5;\n    float beta0 = 0.0 + abs(sin(iTime*switch_speed))*3.0;       // [0.0, 3.0]\n    float beta1 = 30.0;\n    \n    // Discrete dist_normalized\n    int dist_bpp = 16;\n    int log2lutsize = 8;\n    int lut_size = (1 << log2lutsize);\n    int log_spacing = dist_bpp - log2lutsize;\n    float spacing = float(1 << log_spacing);\n    float lut_size_1 = float(lut_size + 1);\n    \n    int dist_normalized_u16 = int(dist_normalized * float(1 << dist_bpp));\n    int dist_normalized_int0 = int(dist_normalized_u16 >> log_spacing);\n    int dist_normalized_int1 = min(dist_normalized_int0 + 1, lut_size + 1);\n    \n    float lerp_weight = float(dist_normalized_u16 - (dist_normalized_int0 << log_spacing)) / spacing;\n    float weight0 = 1.0 - 1.0 / (1.0 + exp(-beta1 * (float(dist_normalized_int0) / lut_size_1 - beta0)));\n    float weight1 = 1.0 - 1.0 / (1.0 + exp(-beta1 * (float(dist_normalized_int1) / lut_size_1 - beta0)));\n    float weight_lerp = weight0 * (1.0 - lerp_weight) + weight1 * lerp_weight;\n    \n    // This is sigmoid.\n    //float weight = 1.0 - 1.0 / (1.0 + exp(-beta1 * (dist_normalized - beta0)));\n    float weight = weight_lerp;\n\n    \n    // Simulate fixed point precision.\n    int frac_bpp = 10; // <--- looks smooth enough\n    float weight_scale = float(1 << frac_bpp);\n    int weight_fxp = int(weight_scale * weight);\n    weight = float(weight_fxp) / weight_scale;\n    //weight = 0.0f;\n    \n    // weight = weight * transparency.\n    // The transparency keeps increasing after full camera switch. \n    // So for the opposite direction (uw->wide), it should start from 1, and keeps decreasing instead.\n    float beta0_t = 0.9;\n    float beta1_t = 2.0;\n    float curr_radius = beta0;\n    float transparency = 1.0 / (1.0 + exp(-beta1_t * (curr_radius - beta0_t)));\n    weight = weight * transparency;\n    \n    int weight_fxp1 = int(weight_scale * weight);\n    weight = float(weight_fxp1) / weight_scale;\n    \n    //wide = vec4(1.0, 1.0, 1.0, 1.0);\n    //uw = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    fragColor = wide * weight + uw * (1.f - weight);\n\n}\n","name":"Image","description":"","type":"image"}]}