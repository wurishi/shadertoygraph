{"ver":"0.1","info":{"id":"clyGWK","date":"1684621437","viewed":40,"name":"oh god what have i done","username":"NikoAnimation","description":"ye","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"clGGDG","parentname":"Ray Marching Attempt #3 (wip)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// INIT VARS:\n\nvec3 camPos = vec3(0.0, 0.0, 2.0);\nvec2 camAngle = vec2(0.0, 0.0);\nfloat fov = 0.30; // <-- 90*  0-1 == 0-360\n\nfloat minDELength = 0.0001;\nfloat maxRayLength = 500.0;\nfloat maxSteps = 800.0; // had to be float so i could divide ¯\\_(ツ)_/¯\n\nvec2 lightAng = vec2(1.0, 0.0);\nfloat AOMultiplier = 2.0;\n\nfloat sphere_de(vec3 pos, vec3 objPos, float radius) {\n    return length(pos-objPos)-radius;\n}\nfloat plane_de(vec3 pos, float z) {\n    return distance(pos,vec3(pos.xy,z));\n}\n\nfloat overall_de(vec3 pos) {\n    return min( \n        plane_de(pos, 0.0),\n        sphere_de(pos, vec3(10.0, 0.0, 2.0),2.0)\n    );\n}\nvec3 get_normal(vec3 pos) {\n\tfloat dist = overall_de(pos);\n    vec2 e = vec2(.01, 0.0);\n    \n    vec3 n = dist - vec3(\n        overall_de(pos-e.xyy),\n        overall_de(pos-e.yxy),\n        overall_de(pos-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 ray_move(vec3 pos, vec3 dir, float dist) {\n    \n    /*\n    pos.x += cos(dir.x)*dist;\n    pos.y += sin(dir.x)*dist;\n    pos.z += sin(dir.y)*dist;\n    */\n    return pos + normalize(dir);\n}\nvec3 deg_to_vec(vec2 dir) { //Used to convert angle based vec2s to vec3 directions\n    vec3 pos;\n    pos.x += cos(dir.x);\n    pos.y += sin(dir.x);\n    pos.z += sin(dir.y);\n    return normalize(pos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    lightAng = vec2(iTime, 2.0);\n\n    // Calculate aspect ratio (assumes width is higher than height)\n    float aspectRatio = iResolution.x / iResolution.y;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 suv = (uv*2.0)-1.0; // Signed screen coordinates (-1 - +1)\n    suv.x *= aspectRatio; // Account for aspect ratio\n\n    // Get ray angle\n    vec3 rayPos = camPos;\n    vec2 rayAng = mod((fov*suv + camAngle)+1.0,2.0)-1.0; // mod values for correct angle\n    \n    float b = 1.0;\n    \n    float de;\n    float totalDist;\n    float steps;\n    do {\n        de = overall_de(rayPos);\n        rayPos = ray_move(rayPos, deg_to_vec(rayAng), de);\n        totalDist += de;\n        steps += 1.0;\n    } while (de > minDELength && totalDist < maxRayLength && steps < maxSteps);\n    \n    if (de < minDELength) {\n        \n        b = clamp(dot(get_normal(rayPos), deg_to_vec(lightAng)), .2, 1.0);\n        \n        \n        rayPos = ray_move(rayPos, get_normal(rayPos), minDELength*2.0);\n        rayAng = lightAng;\n        \n        totalDist = 0.0;\n        do {\n            de = overall_de(rayPos);\n            rayPos = ray_move(rayPos, deg_to_vec(rayAng), de);\n            totalDist += de;\n        } while (de > minDELength && totalDist < maxRayLength);\n        \n        if (de < minDELength) {\n            b -= .2;\n            \n            b = clamp(dot(get_normal(rayPos), deg_to_vec(lightAng)), .2, 1.0);\n        \n            //b = (dot(get_normal(rayPos), deg_to_vec(lightAng)))/1.4-(steps/maxSteps)*AOMultiplier;\n            \n            //vec3 vecRayAngle = deg_to_vec(rayAng);\n            //vec3 reflectedAng = reflect(vecRayAngle, get_normal(rayPos));\n            //b += dot(vecRayAngle, reflectedAng);\n        }\n        \n    } else {\n        b = 0.0;\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(b, b, b, 1.0);\n    //fragColor = vec4(get_normal(rayPos) ,1.0);\n}","name":"Image","description":"","type":"image"}]}