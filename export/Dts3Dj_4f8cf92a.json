{"ver":"0.1","info":{"id":"Dts3Dj","date":"1672438438","viewed":227,"name":"Intimidate 4k Intro","username":"nr4","description":"Demoscene PC-4k-Intro \"Intimidate\" by Virgill & NR4, as released at Zenta 2022 - https://www.pouet.net/prod.php?which=93180\nMusic: Virgill\nCode: NR4","likes":17,"published":1,"flags":96,"usePreview":0,"tags":["intro","4k","demoscene","demo","virgill","nr4","madtracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Intimidate - PC 4k intro by Virgill & NR4 at Zenta 2022.\n * MadTracer (Marching algorithm): Copyright (C) Virgill\n * GFX: Copyright (C) 2022 NR4 <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv = (fragCoord.xy/iResolution.xy);\n    fragColor = texture(iChannel0, uv);\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4tBSWy","filepath":"https://soundcloud.com/virgill/4klang-intimidate","previewfilepath":"https://soundcloud.com/virgill/4klang-intimidate","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n * Intimidate - PC 4k intro by Virgill & NR4 at Zenta 2022.\n * MadTracer (Marching algorithm): Copyright (C) Virgill\n * GFX: Copyright (C) 2022 NR4 <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nvec3 lpos1 = vec3(0), \n    lpos2 = vec3(0), \n    lpos3 = vec3(0, 1, 0), \n    scatter = vec3(0),\n    c = vec3(1., 0., -1.);\nfloat fsize = .2,\n    pi = 3.14159,\n    _time;\n\nvoid dmin(inout vec3 d, float x, float y, float z)\n{\n\tif(x < d.x) d = vec3(x, y, z);\n}\n\n// 3D noise function (IQ)\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p),\n        s=vec3(7, 157, 113);\n\tp-=ip;\n\tvec4 h=vec4(0, s.yz, s.y+s.z)+dot(ip, s);\n\tp=p*p*(3.-2.*p);\n\th=mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n\th.xy=mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\n// hash without sine: https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 19.19;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// method by fizzer\nvec3 hashHs(vec3 n, float seed)\n{\n    float u = hash11( 78.233 + seed),\n        v = hash11( 10.873 + seed),\n        a = 6.2831853 * v;\n    u = 2.0*u - 1.0;\n    return normalize( n + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}\n\n// 2D box distance\nfloat dbox2(vec2 x, vec2 b)\n{\n    vec2 da = abs(x)-b;\n    return length(max(da,c.yy)) + min(max(da.x,da.y),0.0);\n}\n\nvec3 palette(float scale)\n{\n    if(scale<=0.)\n        return mix(vec3(0.97,0.24,0.34), vec3(1.), clamp(scale+1.,0.,1.));\n    if(scale <= 1.)\n        return mix(vec3(0.21,0.30,0.42), vec3(1.), fract(scale));\n    if(scale <= 2.)\n        return mix(vec3(0.21,0.42,0.30), vec3(0.97,0.66,0.11), fract(scale));\n    return mix(vec3(1.00,0.94,0.41), vec3(0.97,0.66,0.11), fract(scale));\n}\n\n// Rotation in R3\nmat3 rot3(in vec3 p)\n{\n    return mat3(c.xyyy, cos(p.x), sin(p.x), 0., -sin(p.x), cos(p.x))\n        *mat3(cos(p.y), 0., -sin(p.y), c.yxy, sin(p.y), 0., cos(p.y))\n        *mat3(cos(p.z), -sin(p.z), 0., sin(p.z), cos(p.z), c.yyyx);\n}\n\nfloat menger(vec3 z0, vec3 seed){\n\tvec4 z = vec4(z0, 1.);\n    vec3 offset = vec3(.785 - .1 * z0.y, 1.53+mix(.5, .2, clamp(z0.z, 0., 1.)) * z0.y, .96 + .4 * z0.y) - .3 * seed;\n    float scale = 2.46 + .8 * hash11(_time - mod(_time, 8.)),\n        scm = scale - 1.;\n\tfor(int n = 0; n < 12; ++n) {\n\t\tz = abs(z);\n\t\tif(z.x < z.y)\n            z.xy = z.yx;\n\t\tif(z.x < z.z)\n            z.xz = z.zx;\n\t\tif(z.y < z.z)\n            z.yz = z.zy;\n        z *= scale;\n\t\tz.xyz -= offset * scm;\n\t\tif(z.z < -.5*offset.z * scm)\n            z.z += offset.z * scm;\n\t}\n\treturn (length(max(abs(z.xyz) - c.xxx, 0.)) - .05) / z.w;\n}\n\n// Paint with antialiasing\nfloat sm(in float d)\n{\n    return smoothstep(1.5/iResolution.y, -1.5/iResolution.y, d);\n}\n\n// Created by David Hoskins and licensed under MIT.\n// See https://www.shadertoy.com/view/4djSRW.\n// float->vec2 hash function\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 caleid(vec2 uv, vec2 xylow, vec2 xyup, float mirror_count)\n{\n    for(float i = 0.; i < mirror_count; i += 1.)\n    {\n        // Random evolving shit\n        vec2 p0 = mix(xylow, xyup, hash21(i)),\n            p1 = mix(xylow, xyup, hash21(i+1.31)),\n            dir = normalize(p1 - p0);\n\n        // Set up householder transformation\n        mat2 H = mat2(1.) - 2.*outerProduct(dir, dir);\n        uv = mix(p1 + H * (uv-p1), uv, sm(dot(uv-p1,dir)));\n    }\n\n    // Remove border glitch\n    vec2 duv = mod(uv, xyup-xylow),\n        uvj = round((uv-duv)/(xyup-xylow)),\n        aj = mod(uvj, 2.);\n    uv = mix(uv, xyup-uv, aj);\n    \n    return uv;\n}\n\n// Created by David Hoskins and licensed under MIT.\n// See https://www.shadertoy.com/view/4djSRW.\n// vec2->vec3 hash function\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat lfnoise(vec2 t)\n{\n    vec2 i = floor(t);\n    t = fract(t);\n    t = smoothstep(c.yy, c.xx, t);\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)), \n        v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\n\nvec3 map(vec3 p,bool flag)\n{\n    vec3 x0 = p;\n    float ja = _time - mod(_time,8.);\n    p.z += max(.03*(_time-16.), 0.);\n    p.x += .1*sin(.3*_time) + ja+ 120.*step(40.,_time);\n    p.y -= .5+.5*hash11(ja+.21);\n    p *= rot3(vec3(-.1*abs(sin(.03*_time)), 0., 0.));\n\n    vec3 d = vec3(1);\n    float s;\n\n    // Floor\n    dmin(d, .8+p.y, 0., 0.);\n    \n    // Fractal    \n    vec3 a0 = p;\n    vec2 xs = vec2(1.4);\n    a0.xz = mod(a0.xz-.5*xs, xs)-.5*xs;\n    vec2 ap = a0.xz;\n    vec2 a0j = p.xz-.5*xs-a0.xz;\n    a0.xz = caleid(a0.xz, -(.5+hash11(ja))*xs, (.5+hash11(ja+1.312))*xs, 4.);\n    \n    s = menger(a0, hash32(a0j));\n    dmin(d, s, .1,1.);\n    if(flag) scatter += 0.32*max(-(s-.1) * (4.),0.)*.36*palette(.5+.5*lfnoise(p.xz));\n    \n    // Ceil\n    s = -p.y+1.1;\n    dmin(d, s, .1,1.);\n    if(flag) scatter += 0.32*max(-(s-.1) * (8.),0.)*.36*palette(1.);\n    \n    // Glow\n    s = length(a0)-.001;\n    if(flag) scatter += 0.32*max(-(s-.9)*mix(2.,8.,.5+.5*sin(.3*_time)),0.)*.36*palette(-1.);\n\n\treturn d;\n}\n\nvec3 normal(vec3 p)\n{\n\tvec2 e = vec2(0, .0001);\n\treturn normalize(map(p,false).x-vec3(map(p - e.yxx,false).x, map(p - e.xyx,false).x, map(p - e.xxy,false).x));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    _time = mod(iTime, 98.)+8.3;\n    fragColor.rgb = c.yyy;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy,\n        uv1 = (fragCoord.xy -.5*iResolution.xy)/iResolution.y;\n\n\t// borders\n\tif(uv.y>.11 && uv.y<.89)\n\t{\n    \tfloat t1 = 0., t2 = 0.,t3=0., seed = 0.;\n\t\t\n        // camera\n\t\tvec3 ro1 = vec3(0, 0, -5.), rd1 = normalize(vec3((2.*fragCoord.xy-iResolution.xy)/iResolution.x, 1));\n//***************************************************************************************************\n// Cast ray\n//***************************************************************************************************     \n        \n        lpos1 = vec3(1.*cos(_time), .3*sin(_time), 2.+sin(.5*_time));\t\t\t// position point light 1 \n        lpos2 = vec3(1.2*cos(.3*_time), .4*sin(.4*_time), 2.+sin(.2*_time));   \t// position point light 2\n       \n        seed=uv.x*uv.y+uv.y+uv.x+fract(_time);  \n\n\t\tvec3 scol=vec3(0),m1, m2, m3,  ro2,rd2,nor1, nor2,pos1,pos2,pos3;\n\t    \n\t\tfor( int i = 0; i < 250; i++ )\n\t\t{\n            // every iteration a new seed\n            seed=32.+seed*fract(seed);\n           \t\n            // raymarch 1st pass\n           \tpos1 = ro1+rd1*t1;\t\t\n        \tm1 = map(pos1,true);\n\t\t\tt1+=min((m1.x), .01); \t// the smaller the factor, the thicker the media\n\t\t\t\n            if (m1.x<.001)\t\t// hit\n            {\n            \tscol+= palette(m1.z)*step(1., m1.y)*50.; \t\n              \tbreak;\n            }\n\n          \n\t\t\t// Raymarch direct light \n            lpos3=vec3(sin(.5*_time),1,0);\t\t\t\t// light from ceiling \n            lpos3 = mix(lpos3,hashHs(lpos3,seed),.15); \t// add randomness\n        \tpos2=pos1+lpos3*t2;\t\t\t\t\t\t\t// calculate ray direction\n            m2 = map(pos2,false);\n            t2+=min(.5*m2.x, .1);\n            \n           \tif (m2.y>=1.&&m2.z==0.) scol+= .5 +5.*m1.x*noise(7.*pos1+_time);\t// if ceiling hit\n        }\n      \n        // bounce\n\t  \tnor1 = normal(pos1);\n        m1.y=clamp(m1.y,0.,1.);\n\t\tt2=0.;\n       \tfor( int i = 1; i < 100 ; i++ )\n      \t{\n            // every iteration a new seed\n            seed=32.+seed*fract(seed);            \n\t\t\trd2 = mix(reflect(rd1,nor1),hashHs(nor1,seed),m1.y);\t// reflect depending on material\t\n            pos2 = pos1+ rd2*t2;\n\t\t\tm2 = map(pos2,false); \n            t2+=min(.2*m2.x, .1);\n            scol += palette(m2.z)*step(1., m2.y);\n       \n        }\n\n\t\tfragColor = vec4((.003*scol+0.02*scatter+1.*texture(iChannel0, uv).xyz), 0.)*.8; // with blur\n        float ja = mod(_time, 8.);\n\n        fragColor.rgb *= smoothstep(0., 0.8, ja)*smoothstep(8.,6., ja) * smoothstep(96., 95., _time);\n        fragColor = clamp(fragColor,0.,1.);\n\t}\n}","name":"Buffer A","description":"","type":"buffer"}]}