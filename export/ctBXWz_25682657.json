{"ver":"0.1","info":{"id":"ctBXWz","date":"1675887933","viewed":135,"name":"Game of Life with smooth rules","username":"ianertson","description":"Had an idea of creating game of life but with \"smooth\" rules.\nYou can use the mouse to interact with it :)","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["noise","smooth","gameoflife","gol","gameoflifes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n    I had this idea of creating game of life, but with \"smooth\" rules.\n    You can control how smooth the rules should be within the \"Common\" tab.\n    \n    Buffer A:            Simulation\n    Buffer B:            Just some post-processing effects\n    Common:              Settings you can play around with\n    Image (this tab):    Post-processing\n*/\n\n\n#define R iResolution.xy\n#define T (iTime)\n#define M_PI (3.1416)\n#define TAU (M_PI * 2.0)\n\nfloat colorDiff(vec3 a, vec3 b) { return abs(luma(a) - luma(b)); }\n\nvec3 getRaw(vec2 uv) {\n    return texelFetch(iChannel0, ivec2(uv*R.xy), 0).rgb;\n}\n\nvec3 getHealth(sampler2D tex, vec2 uv) {\n    return vec3(texture(iChannel0, uv).r);\n}\n\nfloat noiseDetect(vec2 uv, inout vec3 average) {\n    vec2 texel = 1.0 / vec2(textureSize(iChannel0, 0).xy);\n    \n    vec3 left = getHealth(iChannel0, uv+(vec2(-1.0, 0.0)*texel)).rgb;\n    vec3 right = getHealth(iChannel0, uv+(vec2(1.0, 0.0)*texel)).rgb;\n    vec3 rightDown = getHealth(iChannel0, uv+(vec2(1.0, -1.0)*texel)).rgb;\n    vec3 up = getHealth(iChannel0, uv+(vec2(0.0, 1.0)*texel)).rgb;\n    vec3 down = getHealth(iChannel0, uv+(vec2(0.0, -1.0)*texel)).rgb;\n    vec3 center = getHealth(iChannel0, uv).rgb;\n    \n    vec3 around = (left + right + up + down) / 4.0;\n    average = (left + right + up + down + center) / 5.0;\n    \n    float diffRightDown = colorDiff(right, rightDown);\n    \n    float value = colorDiff(center, around);\n    value += diffRightDown;\n    \n    return value / 2.0;\n    \n    \n}\n\nvec3 smoothEdges(vec2 uv) {\n    vec3 soft = vec3(0.0);\n    float e = noiseDetect(uv, soft);\n    vec3 orig = getHealth(iChannel0, uv).rgb;   \n    return mix(orig, soft, clamp(pow(e, 2.0)*64., 0.01, 0.7));\n}\n\n\n\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    \n    \n    vec2 uv = fc/R.xy;\n    \n   // uv.x *= (R.x / R.y);\n\n\n    uv *= ZOOM;\n  \n    \n    \n\n    \n    #if DENOISE > 0\n    col = smoothEdges(uv).rgb;\n    #else\n    col = vec3(texture(iChannel0, uv).r);\n    #endif\n    \n    if (col.r < 0.03) col = vec3(0.0);\n    \n    \n    vec3 raw = getRaw(uv);\n    \n    float id = raw.b;\n\n    \n    vec3 rgb = hashv3(vec2(id, id), id);\n    \n    col *= rgb;\n    \n    \n    col += luma(col)/TAU;\n    \n    vec2 mouse = MOUSE_POS;\n    \n    float distMouse = distance(vec2(uv.x * (R.x/R.y), uv.y), mouse);\n    \n    vec3 att = (MOVING_CIRCLE || iMouse.z > 0.01) ? max(vec3(0.2), (col / max(0.001, pow(distMouse, 2.0))) / M_PI) : vec3(0.02);\n    att = max(att, pow(col.r, 2.0)*4.0);\n \n    att += clamp(pow(violetFactor(rgb), 6.0)*40.0,0.0, M_PI)/M_PI;\n    \n    col *= att;\n    \n    \n    vec3 gam = col;\n    gam /= vec3(1.0) + gam;\n    gam = pow(gam, vec3(1.0 / 2.2));\n    col = mix(col, gam, 0.9);\n    \n    O = vec4(clamp(col, 0.0, 1.0), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define R iResolution.xy\n#define T (iTime)\n#define M_PI (3.1416)\n#define TAU (M_PI * 2.0)\n\n\nfloat initialValue(ivec2 uv) {\n    vec2 v = vec2(uv);\n    return hash2(v*0.001, fract(0.21255 + (iDate.w/1024.0))*3.212);\n\n}\n\nfloat getValueMouse(ivec2 uv) {\n   return clamp(DIST_MOUSE((vec2(uv) / R.xy)), 0.0, 1.0);\n   \n}\n\nfloat getValue(ivec2 uv) {\n    if (uv.x <= 1 || uv.y <= 1 || uv.x > int(R.x-1.) || uv.y > int(R.y-1.)) return 0.0;\n\n    float m = getValueMouse(uv);\n\n    \n    return clamp(texelFetch(iChannel0, uv, 0).r + m, 0.0, 1.0);\n}\n\nvec3 getValue3(ivec2 uv) {\n    if (uv.x <= 1 || uv.y <= 1 || uv.x > int(R.x-1.) || uv.y > int(R.y-1.)) return vec3(0.0);\n    return texelFetch(iChannel0, uv, 0).rgb;\n}\n\nint get(ivec2 uv) {\n    return int(getValue(uv) > TH);\n}\n\nfloat getf(ivec2 uv) {\n    return clamp(getValue(uv), 0.0, 1.0);\n}\n\nvec3 getf3(ivec2 uv) {\n    return getValue3(uv).xyz;\n}\n\nint countSiblings(ivec2 uv) {\n    int left = get(uv + ivec2(-1, 0));\n    int right = get(uv + ivec2(1, 0));\n    int up = get(uv + ivec2(0, 1));\n    int down = get(uv + ivec2(0, -1));\n    int topLeft = get(uv + ivec2(-1, 1));\n    int topRight = get(uv + ivec2(1, 1));\n    int botLeft = get(uv + ivec2(-1, -1));\n    int botRight = get(uv + ivec2(1, -1));\n    \n    return left + right + up + down + topLeft + topRight + botLeft + botRight;\n}\n\nfloat countSiblingsSmooth(ivec2 uv) {\n    float left = getf(uv + ivec2(-1, 0));\n    float right = getf(uv + ivec2(1, 0));\n    float up = getf(uv + ivec2(0, 1));\n    float down = getf(uv + ivec2(0, -1));\n    float topLeft = getf(uv + ivec2(-1, 1));\n    float topRight = getf(uv + ivec2(1, 1));\n    float botLeft = getf(uv + ivec2(-1, -1));\n    float botRight = getf(uv + ivec2(1, -1));\n    \n    return left + right + up + down + topLeft + topRight + botLeft + botRight;\n}\n\nvec3 strongestSibling(ivec2 uv) {\n    vec3 left = getf3(uv + ivec2(-1, 0));\n    vec3 right = getf3(uv + ivec2(1, 0));\n    vec3 up = getf3(uv + ivec2(0, 1));\n    vec3 down = getf3(uv + ivec2(0, -1));\n    vec3 topLeft = getf3(uv + ivec2(-1, 1));\n    vec3 topRight = getf3(uv + ivec2(1, 1));\n    vec3 botLeft = getf3(uv + ivec2(-1, -1));\n    vec3 botRight = getf3(uv + ivec2(1, -1));\n    \n    vec3 strongest = vec3(0.);\n    float pwr = -10.0;\n    \n    if (left.r > pwr) { strongest = left; pwr = left.r; }\n    if (right.r > pwr) { strongest = right; pwr = left.r; }\n    if (up.r > pwr) { strongest = up; pwr = left.r; }\n    if (down.r > pwr) { strongest = down; pwr = left.r; }\n    if (topLeft.r > pwr) { strongest = topRight; pwr = left.r; }\n    if (topRight.r > pwr) { strongest = topRight; pwr = left.r; }\n    if (botLeft.r > pwr) { strongest = botLeft; pwr = left.r; }\n    if (botRight.r > pwr) { strongest = botRight; pwr = left.r; }\n    \n    return strongest;\n}\n\nvec3 avgSibling(ivec2 uv) {\n    vec3 self = getf3(uv);\n    vec3 left = getf3(uv + ivec2(-1, 0));\n    vec3 right = getf3(uv + ivec2(1, 0));\n    vec3 up = getf3(uv + ivec2(0, 1));\n    vec3 down = getf3(uv + ivec2(0, -1));\n    vec3 topLeft = getf3(uv + ivec2(-1, 1));\n    vec3 topRight = getf3(uv + ivec2(1, 1));\n    vec3 botLeft = getf3(uv + ivec2(-1, -1));\n    vec3 botRight = getf3(uv + ivec2(1, -1));\n\n    \n    return (left + right + up + down + topLeft + topRight + botLeft + botRight + self) / 9.;\n}\n\n/**\n\nAny live cell with two or three live neighbours survives.\nAny dead cell with three live neighbours becomes a live cell.\nAll other live cells die in the next generation. Similarly, all other dead cells stay dead.\n*/\n\n// non-smooth method\nfloat computeNext(ivec2 uv, float m) {\n    if (iFrame < 1) return initialValue(uv);\n    if (m > 0.0001) return m;\n    int current = get(uv);\n    int siblings = countSiblings(uv);\n    if (current > 0 && (siblings == 2 || siblings == 3)) return 1.0;\n    else if (siblings == 3) return 1.0;\n    return 0.0;\n}\n\nfloat cmp(float a, float b) {\n    float diff = abs(a - b);\n   return pow(max(0.0, 1.0-smoothstep(0.0, 1.0, diff / max(a, b))), AMPLIFIER);\n   // return diff / max(1.0, max(a, b));\n   // return clamp(1.0 - diff, 0.0, 1.0);\n   // return clamp(1.0 - (diff / b), 0.0, 1.0);\n}\n\n// smooth method\nfloat computeNextSmooth(ivec2 uv, inout float siblings, float m) {\n    if (iFrame < 1) return initialValue(uv);\n    float current = clamp(getf(uv), 0.0, 1.0);\n    siblings = clamp(countSiblingsSmooth(uv), 0.0, 8.0);\n    float aliveCase = clamp(current*(cmp(siblings, 2.0)+cmp(siblings, 3.0)), 0.0, 1.0);//smoothstep(2.0, 3.0, siblings);\n    float deadCase = cmp(siblings, 3.0);//(3.0 / (3.0 + siblings)) / 5.0;\n    return max(m, mix(deadCase, aliveCase, current));\n}\n\n\n\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n\n    vec2 uv = fc/R.xy;\n    \n    fc = uv*R.xy;\n    \n    vec3 old = texelFetch(iChannel0, ivec2(fc), 0).rgb;\n    float m = getValueMouse(ivec2(fc));\n    \n   #if FRAME_CAP > 0 \n   if (iFrame % FRAME_CAP != 0) {\n        col = vec3(getf(ivec2(fc)));\n        col.b = old.b;\n        O = vec4(col, 1.0);\n        return;\n    }\n    #endif\n    \n    \n    float siblings = 0.0;\n    float realValue = computeNext(ivec2(fc), m);\n   \n   \n    float value = clamp(computeNextSmooth(ivec2(fc), siblings, m), 0.0, 1.0);\n    \n //  value = clamp(pow(value, 3.3)*4.0, 0.0, 1.0);\n    \n  //  col = vec3(value);\n  //  O = vec4(col, 1.0);\n  //  return;\n    value = mix(realValue, value, SMOOTH_FACTOR);\n    \n    value = clamp(value, 0.0, 1.0);\n    \n    col = vec3(value);\n    \n    float id = old.b;\n    \n    // Below is an attempt to transfer the particles ID's\n    // to the next cell if they die.\n    // Seems to work good enough.\n    if (iFrame < 1 && realValue > 0.001) {\n        id = noise16((uv*0.1)*ID_FREQ, 0.1*ID_FREQ, 0.2315);\n    } else if (realValue > 0.001 && (old.r < TH || id <= 0.0)) {\n        vec3 strongest = strongestSibling(ivec2(fc));\n        id = strongest.b;\n    } else if (realValue <= 0.0 && old.r < TH && value < TH) {\n        vec3 avg = avgSibling(ivec2(fc));\n        col *= clamp(siblings, 0.5, 0.8);\n    } else if (realValue > 0.01 && old.r > TH && id <= 0.0) {\n        id = noise16((uv*0.1)*ID_FREQ, 0.1*ID_FREQ, 0.2315);\n    }\n    \n    if (iFrame > 1 && old.r < TH && realValue > 0.01 && value > TH) {\n         vec3 strongest = strongestSibling(ivec2(fc));\n         id = strongest.b;\n    }\n    \n    // make sure particles outside of screen gets an ID\n    // when going fullscreen.\n    if (id <= 0.00000001) {\n        id = id = noise16(uv*0.1, 0.1, 0.2315 + cos(T));\n    }\n    \n    if (old.r < TH && m > 0.01 && value > TH) {\n        id = noise16(((uv*0.1)+((iMouse.xy/R.xy)*0.02))*ID_FREQ, 0.01*ID_FREQ, 3.91717 + fract(m*10.021254));\n    }\n    \n    col.b = id;\n    \n    // let's just make some of them die if they are too weak\n    if (value < TH) col.rg *= 0.5;\n\n    \n    O = vec4(col, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n// ======= SETTINGS ========\n\n// how zoomed in we are. (Higher value = zoom out)\n#define ZOOM (0.7)\n// how much of the \"smooth rules\" to use.\n#define SMOOTH_FACTOR 0.99\n// limit frame-rate to make things slower\n#define FRAME_CAP 0\n\n// threshold for when something is considered dead\n#define TH 0.69\n\n// how much the differential comparisons are amplified\n// lower value = less strict rules.\n// I'm not sure why, but the closer this number is to `6`, \n// the closer you get to the original strict rules.\n// In other words, if you're scaling this to 6 or above,\n// you might as well set `SMOOTH_FACTOR` to zero.\n#define AMPLIFIER 5.56\n\n// The frequency of identifier distribution\n// (Just used for coloring stuff)\n#define ID_FREQ 0.1\n\n// Set to false to disable the moving circle\n#define MOVING_CIRCLE true\n\n// Set to 1 to make things less noisy\n#define DENOISE 1\n// =========================\n\n\n#define MOUSE_PRESSURE max(float(iMouse.z > 0.01), MOVING_CIRCLE ? (0.5+(0.5*sin(T))) : 0.0)\n#define MOUSE_RADIUS ((iMouse.z > 0.01 ? 0.08 : 0.03)*MOUSE_PRESSURE)\n#define FAKE_MOUSE ((!MOVING_CIRCLE) ? vec2(0.0) : (ZOOM*(vec2(0.5*(R.x/R.y), 0.5) + (0.25*vec2(cos(T*0.5), sin(T*0.5))))))\n\n#define TRANSLATION (cos(T), sin(T))\n#define MOUSE_POS ((iMouse.z < 0.01 ? FAKE_MOUSE : ((vec2(iMouse.x * (R.x/R.y), iMouse.y)*ZOOM) / (R.xy))))\n\n\n\n#define DIST_MOUSE(UV) clamp(MOUSE_PRESSURE * (1.0-smoothstep((MOUSE_RADIUS*ZOOM)-((MOUSE_RADIUS*ZOOM)*0.5),\\\n    (MOUSE_RADIUS*ZOOM)+((MOUSE_RADIUS*ZOOM)*0.5), distance(vec2(UV.x * (R.x/R.y), UV.y), MOUSE_POS))), 0.0, 1.0)\n\n#define VIOLET (vec3(127.0, 0.0, 255.0)/255.0)\n\nfloat hash1(float x) {\n    uint y = floatBitsToUint(x + 12.);\n    uint y2 = (y >> 9u);\n    y2 ^= y2 << 13;\n    y2 ^= y2 >> 17;\n    y2 ^= y2 << 5;\n    uint n = 912229U * ((y) ^ ((y2 ^ (y<<2))>>3U));\n    return float(n) / float(0xffffffffU);\n}\n\nfloat hash2(vec2 x, float seed) {\n    seed = hash1(seed+0.91256);\n    uint hx = uint(hash1(x.x+35.1)*3921.52 + seed);\n    uint hy = uint(hash1(x.y+91.1)*3921.44 + seed);\n    uvec2 y = uvec2(floatBitsToUint(x.x+12.92815 + seed), floatBitsToUint(x.y+12.12245 + seed));\n    uint a = 912229U * (((y.x << (hx >> (hy ^ (y.x+y.y)))) ^ (y.y >> 2u)) ^ (hx ^ hy));\n    return float(a) / float(0xffffffffU);\n}\n\nfloat noise(vec2 p, float seed) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv * lv * (3.0 - 2.0 * lv);\n    float ab = mix(hash2(id, seed), hash2(id+vec2(1.0, 0.0), seed), lv.x);\n    float cd = mix(hash2(id+vec2(0.0, 1.0), seed), hash2(id+vec2(1.0, 1.0), seed), lv.x);\n    return mix(ab, cd, lv.y);\n}\n\nvec3 noisev3(vec2 p, float seed) {\n    return vec3(\n        noise(p, 13.29185+seed),\n        noise(p, 16.93811+seed),\n        noise(p, 32.42436+seed)\n    );\n}\n\nvec3 hashv3(vec2 p, float seed) {\n    return vec3(\n        hash2(p, 13.29185+seed),\n        hash2(p + vec2(0.98281, -9.2001), 16.93811+(seed/3.)),\n        hash2(p + vec2(-0.212, 1.121), 32.42436+(seed-1.9291))\n    );\n}\n\n#define NOISE_BODY(c)\\\n    float n = 0.0;\\\n    float amp = 1.0;\\\n    float div = 0.0;\\\n    for (int i = 0; i < c; i++) {\\\n        div += amp;\\\n        n += amp * noise(p*freq, seed);\\\n        freq *= 2.;\\\n        amp /= 2.0;\\\n    }\\\n    return n / div;\n\n//float noise8(vec2 p, float freq) { NOISE_BODY(8); }\nfloat noise16(vec2 p, float freq, float seed) { NOISE_BODY(16); }\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat violetFactor(vec3 color) {\n    return max(0.0, 1.0 - distance(color, VIOLET));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define R iResolution.xy\n#define T (iTime)\n#define M_PI (3.1416)\n#define TAU (M_PI * 2.0)\n\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    \n\n    vec2 uv = fc/R.xy;\n  //  uv += TRANSLATION;\n\n    \n    \n\n    \n    vec3 old = texture(iChannel1, uv).rgb;\n    \n    vec3 next = texture(iChannel0, uv).rgb;\n    col = (iFrame < 1) ? next : old;\n   // if (iMouse.z > 0.01) { old = next; }\n    \n    if (iFrame > 1) {\n        vec3 tmpOld = vec3(old.r);\n        vec3 tmpNext = vec3(next.r);\n        vec3 ma = max(tmpOld, tmpNext);\n        ma = mix(ma, old, 0.7);\n        \n        col = mix(ma, next, 0.05);\n        col = mix(col, next, clamp(luma(next), 0.0, 0.79));\n       // col = mix(ma, next, clamp(0.01 + max(0.0, 1.0 - (SMOOTH_FACTOR*2.)), 0.0, 1.0));\n        //col = mix(old, col, 0.05);\n    }\n    \n    \n    float id = next.b;\n    float health = col.r;\n    col = vec3(health);\n    \n    col.b = next.b;\n\n    \n    O = vec4(clamp(col, 0.0, 1.0), 1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}