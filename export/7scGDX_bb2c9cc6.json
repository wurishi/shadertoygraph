{"ver":"0.1","info":{"id":"7scGDX","date":"1642681121","viewed":75,"name":"path tracer implementation new","username":"okdalto","description":"custom path tracer implementation","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["pathtracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    fragColor = vec4(ACESFilm(color), 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float hash1(float seed) {\n    return fract(sin(seed += 0.1)*43758.5453123);\n}\n\nvec2 hash2(float seed) {\n    return fract(sin(vec2(seed+=0.1,seed+=0.1))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 hash3(float seed) {\n    return fract(sin(vec3(seed+=0.1,seed+=0.1,seed+=0.1))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec3 cosWeightedRandomHemisphereDirection( const vec3 n, inout float seed ) {\n  \tvec2 rv2 = hash2(seed);\n    \n\tvec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );\n\tvec3  vv = normalize( cross( uu, n ) );\n\t\n\tfloat ra = sqrt(rv2.y);\n\tfloat rx = ra*cos(6.2831*rv2.x); \n\tfloat ry = ra*sin(6.2831*rv2.x);\n\tfloat rz = sqrt( 1.0-rv2.y );\n\tvec3  rr = vec3( rx*uu + ry*vv + rz*n );\n    \n    return normalize( rr );\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define EP 0.001\n#define LIGHTSTEP 2\n\nvoid rotX(inout vec3 z, float s, float c) {\n   z.yz = vec2(c*z.y + s*z.z, c*z.z - s*z.y);\n}\n\nvoid rotY(inout vec3 z, float s, float c) {\n   z.xz = vec2(c*z.x - s*z.z, c*z.z + s*z.x);\n}\n\nvoid rotZ(inout vec3 z, float s, float c) {\n   z.xy = vec2(c*z.x + s*z.y, c*z.y - s*z.x);\n}\n\nvoid rotX(inout vec3 z, float a) {\n   rotX(z, sin(a), cos(a));\n}\nvoid rotY(inout vec3 z, float a) {\n   rotY(z, sin(a), cos(a));\n}\n\nvoid rotZ(inout vec3 z, float a) {\n   rotZ(z, sin(a), cos(a));\n}\n\nfloat sdSphere(vec3 p, float r){\n    return length(p) - r;\n}\n\nfloat fractal(vec3 p){\n    float t = 0.0;\n    vec3 offset = vec3(0.16, 0.02, 0.09);\n    for(int i = 0; i < 32; i++){\n        rotX(p, t * 0.2 + 3.1);\n        rotY(p, t * 0.6 - 2.2);\n        rotZ(p, t * 1.1 - 0.3);\n        if(p.x+p.y<0.0) p.xy = -p.yx; // fold 1\n        if(p.y+p.z<0.0) p.yz = -p.zy; // fold 2\n        if(p.z+p.x<0.0) p.zx = -p.xz; // fold 3   \n\n        p -= offset;\n        offset *= vec3(1.002, 1.02, 1.01);\n    }\n    return length(p) - 0.1;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h + texture(iChannel1, p.xz * 0.25).x * 0.6;\n}\n\nint mat = -1;\n\nfloat sdf(vec3 p){\n    float dist = fractal(p);\n    if(dist < EP){\n        mat = 0;\n    }\n    float sphere1 = sdSphere(p + vec3(-1.0, 0.6, -4.8), 0.4);\n    if(dist > sphere1){\n        dist = sphere1;\n        mat = 1;\n    }\n    float sphere2 = sdSphere(p + vec3(1.5, 0.2, -4.5), 0.2);\n    if(dist > sphere2){\n        dist = sphere2;\n        mat = 2;\n    }\n    float plane = sdPlane(p, vec3(0.0, 1.0, 0.0), 1.5);\n    if(dist > plane){\n        dist = plane;\n        mat = 0;\n    }\n    return dist;\n}\n\nvec3 getNormal(vec3 p){\n    vec2 ep = vec2(EP, 0);\n    return normalize(vec3(\n        sdf(p + ep.xyy) - sdf(p - ep.xyy),\n        sdf(p + ep.yxy) - sdf(p - ep.yxy),\n        sdf(p + ep.yyx) - sdf(p - ep.yyx)\n        ));\n}\n\nvec3 emissions[LIGHTSTEP];\nvec3 sum[LIGHTSTEP];\n\nvoid march(inout vec3 origin, inout vec3 rayDir, float seed, inout int stepNum){\n    float trvlDist = 0.0;\n    vec3 rayPos = origin;\n    \n    \n    \n    for(int i = 0; i < 120; i++){\n        float dist = sdf(rayPos);\n        if(dist < EP){\n            vec3 norm = getNormal(rayPos);\n            if(stepNum == 1){\n                float fresnel = pow(1.0 - dot(norm, rayDir), 3.0);\n                rayDir = mix(reflect(rayDir, norm), cosWeightedRandomHemisphereDirection(norm, seed), fresnel);\n            }else{\n                rayDir = cosWeightedRandomHemisphereDirection(norm, seed);\n            }\n            //rayDir = reflect(rayDir, norm);\n            //rayDir = cosWeightedRandomHemisphereDirection(norm, seed);\n            origin = rayPos + rayDir * EP * 3.0;\n            if(mat == 1){\n                emissions[stepNum] = vec3(30.0, 30.0, 50.0);\n                vec3 surfaceColor = vec3(1.0, 1.0, 1.0);\n                float ndotr = max(dot(norm, rayDir), 0.0);\n                sum[stepNum] = surfaceColor * ndotr;\n            }else if(mat == 2){\n                emissions[stepNum] = vec3(50.0, 40.0, 30.0);\n                vec3 surfaceColor = vec3(1.0, 1.0, 1.0);\n                float ndotr = max(dot(norm, rayDir), 0.0);\n                sum[stepNum] = surfaceColor * ndotr;\n            }else{\n                emissions[stepNum] = vec3(0.0, 0.0, 0.0);\n                vec3 surfaceColor = vec3(1.0, 0.9, 0.8);\n                float ndotr = max(dot(norm, rayDir), 0.0);\n                sum[stepNum] = surfaceColor * ndotr;\n            }\n            break;\n            \n        }\n        if(trvlDist > 10.0){\n            break;\n        }\n        trvlDist += dist;\n        rayPos = origin + rayDir * trvlDist;\n    }\n    stepNum ++;\n    return;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy- 0.5) * 2.0;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    float fov = 0.5;\n    float dof = 0.05;\n    \n    vec3 cameraPos = vec3(sin(0.0), -0.3, cos(0.0)) * 5.0;\n\n    vec3 targetPos = vec3(0.0, 0.4, 2.2);\n    float focusdistance = length(targetPos-cameraPos) * fov;\n    \n    vec3 up = vec3(0,1,0);\n    vec3 front = normalize(targetPos-cameraPos);\n    vec3 right = normalize(cross(up, front));\n    up = normalize(cross(front, right));\n\n    float seed = uv.x + fract(uv.y * 18753.43121412313) + fract(12.12345314312)*iTime;\n    vec3 finalCol = vec3(0.0);\n    for(int j = 0; j < 2; j++){\n        vec3 col = vec3(1.0);\n        for(int i = 0; i < LIGHTSTEP; i++){\n            emissions[i] = vec3(0.0);\n            sum[i] = vec3(0.0);\n        }\n        vec3 rayPos = cameraPos;\n\n        vec3 rand = (hash3(seed * float(j+1)) * 2.0 - 1.0);\n\n        vec3 voff = sqrt(rand.x)*(right*sin(rand.y*6.283)+up*cos(rand.z*6.283))*dof;\n        vec3 cameraPosNew = cameraPos - voff;\n        vec3 rayDir = normalize((up * uv.y) + (front) * fov + (right * uv.x) + voff*fov/focusdistance );\n\n        int stepNum = 0;\n        for(int i = 0; i < LIGHTSTEP; i++){\n            march(cameraPosNew, rayDir, seed + iTime * 1.0, stepNum);\n        }\n        for(int i = LIGHTSTEP-1; i >= 0; i--){\n            col = emissions[i] + sum[i] * col;\n        }\n        finalCol = mix(finalCol, col, 1.0f / float(j+1));\n    }\n    \n    vec3 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    //finalCol = mix(lastFrameColor, finalCol, 1.0f / float(iFrame+1));\n    \n    if(iTime < 1.0){\n        fragColor = vec4(vec3(0.0),1.0);\n    }else{\n        fragColor = vec4(finalCol,1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}