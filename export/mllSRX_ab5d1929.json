{"ver":"0.1","info":{"id":"mllSRX","date":"1675206851","viewed":149,"name":"Fast Ray Voxels v1","username":"Rugged","description":"Voxels with a distance field version one. Isn't as powerful as I was hoping there is still a lot of optimization to do and I think coupled with an octree, this would be extraordinarily powerful.\nWASD + arrow keys","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["voxels"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat waveFunction(vec3 p){\n    p.xy += mod(iTime, 12.56);\n    return (.2 * (sin(p.x) * sin(p.y))) + (.05 * sin(2. * p.x) * sin(4. * p.y) + (1. * sin(.5 * p.x))) + cos(.5 * p.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvc = 2. * (uv - .5);\n    \n    \n    vec4 col = vec4(0.);\n\n    \n    \n    \n    \n    \n    \n    \n    //get the mouse location for look direction unless mouse is not down\n    vec2 muv = iMouse.z > 0.0 ? iMouse.xy / iResolution.xy : vec2(0.5, 0.5);\n    \n        \n    \n    float screenRatio = iResolution.y / iResolution.x;\n    \n    //Setting up the ray directions and other information about the point and camera\n    //##############################################################################\n    \n    \n    //camera direction angles phi (xy plane) and theta (xz plane)\n    //float phi = radians(180.);\n    //float theta = radians(105.);\n    float phi = radians(360. * (muv.x - 1.));\n    float theta = radians(180. * (1. - muv.y));\n    \n    phi = texelFetch(iChannel1, ivec2(1, 0), 0).x;\n    theta = texelFetch(iChannel1, ivec2(1, 0), 0).y;\n\n    //get the camera direction as the basis for the rotation (each ray direction is a rotation of the camera direciton vector)\n    //it is in quarternion form here so its a vec4 instead of a vec3\n    vec4 camD = vec4(0., cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta));\n    \n    \n    \n    \n    \n    \n    vec3 p = texelFetch(iChannel1, ivec2(0), 0).xyz;\n\n    \n    \n    //rayD efficient\n    vec3 up = vec3(0., 0., 1.);\n    \n    vec3 U = normalize(cross(up, camD.yzw));\n    vec3 V = normalize(cross(camD.yzw, U));\n    \n    vec3 rayD = normalize(camD.yzw + uvc.x*U + uvc.y*V);\n    \n    \n    //###############################\n    \n    \n    \n  \n    \n    \n    col = vec4(0.);//texture(iChannel0, uv);\n    \n    // / float(iterations);\n    \n    vec2 blockSize = floor(iResolution.xy / 6.);\n    \n    vec3 p1 = p;\n    ivec2 add;\n    vec4 holdCol;\n    \n    float mixA = 1.;\n    \n    for(int i = 0; i < 200; i++){\n    \n        add = ivec2(vec2(floor(mod(p1.z, 6.)), floor(p1.z / 6.)) * blockSize);\n        \n        holdCol = texture(iChannel2, vec2(ivec2(p1.xy) + add) / iResolution.xy);\n        \n        //holdCol = length(holdCol) > 0. ? holdCol : .01 * normalize(holdCol);\n        \n        float l = length(holdCol);\n        if(p1.z > 42.){\n            l = 1.;\n        }\n        p1 += (rayD * (1. * ((hash3(p1.xy) + .5) / 1.5)));// * (length(p1 - p) + .001));\n       \n        //p1.z = min(max(p1.z, 0.), 48.);\n        \n        add = ivec2(vec2(floor(mod(p1.z, 6.)), floor(p1.z / 6.)) * blockSize);\n        \n        holdCol = texelFetch(iChannel0, ivec2(p1.xy) + add, 0);\n        \n        //col += holdCol;\n        \n        //if(p1.x < 0. || p1.x > blockSize.x || p1.y < 0. || p1.y > blockSize.y){\n        //    break;\n        //}\n        \n        if(length(holdCol) > .1){\n            col += holdCol * mixA * abs(holdCol.a);\n            mixA -= abs(holdCol.a);\n            mixA = max(mixA, 0.);\n            //break;\n        }\n        \n        //to see the ray jump through block layers\n        /*\n        if(distance(floor(vec2(p1.x + float(add.x), p1.y + float(add.y))), floor(fragCoord)) < 3.){\n            col = vec4(1., 0., 0., 1.);\n        }\n        */\n    }\n    \n    \n    //to see block layers\n    /*\n    if(floor(mod(fragCoord.x, blockSize.x)) == 0. || floor(mod(fragCoord.y, blockSize.y)) == 0. ){\n        col += vec4(1.);\n    }\n    */\n    \n    //col = texture(iChannel2, uv)/ float(iterations);\n    \n    if(length(uv.xy) > sqrt(2.) - .05){\n        col = vec4(iFrameRate / 144.0);\n    }\n    \n    if(length(uv.xy) > sqrt(2.) - .025){\n        col = vec4(.5);\n    }\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define iterations 10.\n\nfloat hash3(vec2 xy){\n    xy = mod(xy, .19);\n    float h = dot(xy.yyx, vec3(.013, 27.15, 2027.3));\n    h *= h;\n    h *= fract(h);\n    \n    return fract(h);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define cullLength 1.5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0.);\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    if(iFrame == 100){\n        col = vec4(hash3(uv), hash3(uv.yx), hash3(vec2(hash3(uv), hash3(uv.yx))), hash3(vec2(hash3(uv.yx), hash3(uv))));\n        //col.xy = uv.xx;\n        //anything that has a magnitude less than cull length gets culled\n        col *= (((length(col) - cullLength) / abs(length(col) - cullLength)) + 1.) / 2.;\n        if(mod(uv.x, 1. / 6.) > .05){\n            col = vec4(0.);\n        }\n        //col = normalize(col) * 1.5;\n        //col.a *= .2;\n        \n    }\n    else{\n        col = texture(iChannel0, uv);\n    }\n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define turnSpeed 2.\n#define moveSpeed 30.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    \n    if(iFrame == 0){\n        if(floor(fragCoord.x) == 0. && floor(fragCoord.y) == 0.){\n            col = vec4(80., 30., 10., 0.);\n        }\n        else if(floor(fragCoord.x) == 1. && floor(fragCoord.y) == 0.){\n            col = vec4(3.14, 1.5, 0., 0.);\n        }\n    }\n    \n    //get the mouse location for look direction unless mouse is not down\n    vec2 muv = iMouse.xy / iResolution.xy;//iMouse.z > 0.0 ? iMouse.xy / iResolution.xy : vec2(0.5, 0.5);\n    \n    \n    float screenRatio = iResolution.y / iResolution.x;\n    \n    //Setting up the ray directions and other information about the point and camera\n    //##############################################################################\n    \n    \n    //camera direction angles phi (xy plane) and theta (xz plane)\n    float phi = radians(360. * (1. - muv.x));\n    float theta = radians(180. * (1. - muv.y));\n    \n    \n    phi = texelFetch(iChannel0, ivec2(1, 0), 0).x;\n    theta = texelFetch(iChannel0, ivec2(1, 0), 0).y;\n\n    \n    \n    //get the camera direction as the basis for the rotation (each ray direction is a rotation of the camera direciton vector)\n    //it is in quarternion form here so its a vec4 instead of a vec3\n    vec4 camD = vec4(cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta), 0.);\n    \n    \n    \n    if(floor(fragCoord.x) == 0. && floor(fragCoord.y) == 0.){\n        vec4 camPerp = vec4(0.);\n        if(iFrame > 0){\n            vec3 tem = cross(normalize(vec3(camD.xy, 0.)), vec3(0., 0., 1.));\n            camPerp = vec4(tem, 0.);\n        }\n    \n        //if W is pressed go forwards\n        col += camD * texelFetch(iChannel1, ivec2(87, 0), 0).x * iTimeDelta * moveSpeed;\n        \n        //if S is pressed go backwards\n        col -= camD * texelFetch(iChannel1, ivec2(83, 0), 0).x * iTimeDelta * moveSpeed;\n        \n        //if A is pressed go forwards\n        col += camPerp * texelFetch(iChannel1, ivec2(65, 0), 0).x * iTimeDelta * moveSpeed;\n        \n        //if D is pressed go backwards\n        col -= camPerp * texelFetch(iChannel1, ivec2(68, 0), 0).x * iTimeDelta * moveSpeed;\n        \n    }\n    else if(floor(fragCoord.x) == 1. && floor(fragCoord.y) == 0.){\n    \n        //if UP is pressed turn up\n        col.y -= texelFetch(iChannel1, ivec2(38, 0), 0).x * iTimeDelta * turnSpeed;\n        \n        //if DOWN is pressed turn down\n        col.y += texelFetch(iChannel1, ivec2(40, 0), 0).x * iTimeDelta * turnSpeed;\n        \n        //if LEFT is pressed turn up\n        col.x -= texelFetch(iChannel1, ivec2(37, 0), 0).x * iTimeDelta * turnSpeed;\n        \n        //if RIGHT is pressed turn down\n        col.x += texelFetch(iChannel1, ivec2(39, 0), 0).x * iTimeDelta * turnSpeed;\n    }\n    \n    fragColor = col;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 col = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    \n    if(iFrame == 100){\n        col = vec4(iterations);\n    }\n    else if(iFrame < 1000){\n        if(length(texelFetch(iChannel0, ivec2(fragCoord), 0)) > .1){\n            col = vec4(0.01);\n        }\n        else{\n            float dilution = 0.015;\n            col += dilution * (texture(iChannel1, uv + vec2(.001, .001)) - texture(iChannel1, uv));\n            col += dilution * (texture(iChannel1, uv + vec2(.0, .001)) - texture(iChannel1, uv));\n            col += dilution * (texture(iChannel1, uv + vec2(-.001, .001)) - texture(iChannel1, uv));\n            col += dilution * (texture(iChannel1, uv + vec2(-.001, .0)) - texture(iChannel1, uv));\n            col += dilution * (texture(iChannel1, uv + vec2(-.001, -.001)) - texture(iChannel1, uv));\n            col += dilution * (texture(iChannel1, uv + vec2(.0, -.001)) - texture(iChannel1, uv));\n            col += dilution * (texture(iChannel1, uv + vec2(.001, -.001)) - texture(iChannel1, uv));\n            col += dilution * (texture(iChannel1, uv + vec2(.001, .0)) - texture(iChannel1, uv));\n            \n        }\n        \n    }\n    \n    \n    \n    fragColor = max(col, vec4(0.));\n}","name":"Buffer C","description":"","type":"buffer"}]}