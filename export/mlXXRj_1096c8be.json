{"ver":"0.1","info":{"id":"mlXXRj","date":"1675037478","viewed":121,"name":"Anti-repeat using rotation","username":"ianertson","description":"This is inspired by iq's:\nhttps://www.shadertoy.com/view/lt2GDd","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","texture","random","rotation","tile","repeat"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n*  Left = original\n*  Middle = randomized\n*  Right = randomized and blurred\n*\n*  --------------------------------------\n*\n*  This is inspired by iq's:\n*  https://www.shadertoy.com/view/lt2GDd\n*\n*  This is not a replacement, just wanted to see if I could do something\n*  similar but with just one texture sample call instead of 4.\n*\n*  The results are not similar at all, the \"stretching\" that you can see\n*  is not intentional, but couldn't figure out a way around it.\n*\n*  Try using the same texture that I'm using here (Organic 1) in iq's version,\n*  to see how they compare.\n*  ---------------------------------------\n*\n*  The idea:\n*\n*  1. For each texture repetition, get a random number which will be used as an angle\n*  2. Use this angle to rotate each tile randomly.\n*\n*     - Now there's a problem in which the seams between the tiles are very obvious,\n*       because of the rotation.\n*   \n*   3. Solve this problem by interpolating the rotation between the surrounding tiles.\n*   \n*      - Now there's a problem in which the UV coordinates gets distorted\n*\n*/\n\n\n#define R iResolution.xy\n#define T (iTime)\n#define M_PI (3.1416)\n#define TAU (M_PI * 2.0)\n\nfloat rand(vec2 uv) { return fract(sin(uv.x*3.2915+uv.y)*dot(uv, vec2(3.29141, 4.39215))); }\n\nmat2 rot(float a) { float s = sin(a); float c = cos(a); return mat2(c, s, -s, c); }\n\nvec3 notile(sampler2D samp, vec2 uv, float amount, float softness) {\n    vec2 id = floor(uv);\n    vec2 lv = fract(uv);\n    vec2 sv = smoothstep(0.0, 1.0, lv);\n    float angleSelf = rand(id);\n    float angleTop = rand(id + vec2(0.0, 1.0));\n    float angleRight = rand(id + vec2(1.0, 0.0));\n    float angleTopRight = rand(id+vec2(1.0, 1.0));\n    float angleX = mix(angleSelf, angleRight, sv.x);\n    float angleY = mix(angleTop, angleTopRight, sv.x);\n    float angle = mix(angleX, angleY, sv.y);\n    return textureGrad(samp, uv * rot(angle*TAU*amount),\n        dFdx(uv)*angleX*(softness/TAU), dFdy(uv)*angleY*(softness/TAU)).rgb;\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = fc/R.xy;\n    vec2 m = (iMouse.xy-0.5*R.xy)/R.y;\n    \n    uv *= 8.0;\n    vec3 colOrig = texture(iChannel0, uv).rgb;\n    vec3 colRandom = notile(iChannel0, uv, 0.05, 2.0).rgb;\n    vec3 colSmooth = notile(iChannel0, uv, 0.5, 128.0).rgb;\n    \n    //////////////////////////// Visual stuff\n    float partSize = R.x / 3.0;    \n    float middleSize = 1.0 + (0.5+(0.5*cos(T+3.14)))*(partSize);\n   \n    if (iMouse.z > 0.01) fc.x -= m.x*R.x;\n    \n    if (fc.x > (partSize*2.)+middleSize) col = colSmooth;\n    else if (fc.x > (partSize-middleSize) && fc.x < (partSize*2.0) + middleSize) col = colRandom;\n    else if (fc.x < partSize+middleSize) col = colOrig;\n    \n    \n    float thick = 4.0;\n    float c1 = (partSize*2.0) + middleSize;\n    float c2 = (partSize - middleSize);\n    \n    if ((fc.x >= c1-thick && fc.x <= c1+thick) || (fc.x >= c2-thick && fc.x <= c2+thick)) col *= 0.0;\n    \n    O = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}