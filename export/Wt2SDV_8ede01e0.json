{"ver":"0.1","info":{"id":"Wt2SDV","date":"1567154551","viewed":147,"name":"Ellipsoid Shadow Formula V3","username":"Cellulose","description":"A bit of math to calculate the 2D shadow area of an ellipsoid which is defined by principal axes and a rotation matrix.  We model the ellipsoid as a positive-definite matrix (like a gaussian level surface).\nOptimized slightly from V2.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["math"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tShadow area function.\n\t\tsize = ellipsoid dimensions\n\t\trot  = rotatin matrix.\n\t\treturns area* of ellipsoid's projection onto XY plane.\n\n\t* should multiply by pi for correct area\n*/\nfloat shadow_area(mat3 rot, vec3 size)\n{\n    // Ellipsoid shadow area with fewer multiplies\n    float\n        v00 = dot(size*rot[0], rot[0]),\n        v11 = dot(size*rot[1], rot[1]),\n        v01 = dot(size*rot[0], rot[1]);\n    return v00*v11 - v01*v01;\n}\n\nmat3 rotate(vec3 sora)\n{\n    float ang = length(sora);\n    vec3  ax = sora/((ang==0.0) ? 1.0 : ang);\n    float s = sin(ang);\n    float c = cos(ang);\n    float oc = 1.0 - c;\n    \n    return mat3(oc*ax.x*ax.x + c,       oc*ax.x*ax.y - ax.z*s,  oc*ax.z*ax.x + ax.y*s,\n                oc*ax.x*ax.y + ax.z*s,  oc*ax.y*ax.y + c,       oc*ax.y*ax.z - ax.x*s,\n                oc*ax.z*ax.x - ax.y*s,  oc*ax.y*ax.z + ax.x*s,  oc*ax.z*ax.z + c     );\n}\n\nmat3 transpose_func(mat3 m)\n{\n    return mat3(\n        m[0][0], m[1][0], m[2][0],\n        m[0][1], m[1][1], m[2][1],\n        m[0][2], m[1][2], m[2][2]);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //The size of the 3D ellipsoid, called a \"bead\" for brevity.\n    vec3 beadSize = vec3(1.0, .50, .25);\n    \n    //Mouse control vector\n    vec2 mouseSelect = 2.0 * (iMouse.xy / iResolution.xy) - vec2(1.0);\n    \n    //The orientation of the bead.\n    mat3 beadOri =\n        rotate(vec3(0.0,mouseSelect.x*-3.14,0.0)) *\n        rotate(vec3(mouseSelect.y*2.0,0.0,0.0));\n        \n    \n    //Compute a covariance matrix describing the oriented bead.\n    mat3 mBead = mat3(1.0);\n    mBead[0][0] = beadSize.x;\n    mBead[1][1] = beadSize.y;\n    mBead[2][2] = beadSize.z;\n    mBead = beadOri * mBead * transpose_func(beadOri);\n    \n    //The shadow can be described by a 2x2 covariance matrix...\n    //  This is just the XY submatrix of the bead's matrix.\n      \n    //We might use the shadow matrix directly if we weren't rendering it...\n    float mShadowDet = shadow_area(beadOri, beadSize);\n    \n    //...Except we need to use inverse matrices to do sampled rendering.\n    \n    \n    \n    //Then take the XY submatrix of that.\n    \n    mat2 mShadowInv = mat2(\n        mBead[1][1]/mShadowDet, mBead[0][1]/mShadowDet, \n        mBead[1][0]/mShadowDet, mBead[0][0]/mShadowDet);\n    \n    \n    // (this is the screen coordinate space for sampling.)\n    vec2 loc = 2.0 * (fragCoord.xy - .5*iResolution.xy) / iResolution.y;\n    \n    //Map into ellipse-space.  Are we in the shadow?\n    vec2 shadowPos = mShadowInv * loc;\n    bool inShadow = length(shadowPos) < 1.0;\n    \n    //vec3 beadPos = mBeadInv * vec3(loc, 0.0);\n    //bool inBead = (length(beadPos) < 1.0);\n    \n    fragColor = vec4(\n        (inShadow?1.0:0.0),\n        (inShadow?1.0:0.0),\n        1.5/(1.0+length(shadowPos)), 1.0);\n    \n    if (loc.x < -1.25 && (.5+.5*loc.y) < (2.0*mShadowDet)) fragColor.r = 1.0;\n    \n    //Add a grid pattern\n    fragColor.rgb += vec3((floor(4.0*loc+vec2(.03,.03))!=floor(4.0*loc-vec2(.03,.03))) ? 0.1 : 0.0);\n}","name":"Image","description":"","type":"image"}]}