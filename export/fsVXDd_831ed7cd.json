{"ver":"0.1","info":{"id":"fsVXDd","date":"1636388052","viewed":414,"name":"plane in clouds","username":"asis5528","description":"I watched porco rosso recently and thought to make this :) ...wish there was music supported","likes":24,"published":1,"flags":96,"usePreview":1,"tags":["raymarching","sdf","clouds","cloud","volumetric","fog","plane","airplane","aircraft","aeroplane","anime","stuntplane"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"ltsSWf","filepath":"https://soundcloud.com/beachhouse/on-the-sea","previewfilepath":"https://soundcloud.com/beachhouse/on-the-sea","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//with music :) https://youtu.be/nTUzzHEfhSQ \n// Email:blender5528@gmail.com Twitter:@blender5528\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\t\n    vec4 t = texture(iChannel0, uv);\n    uv *=  1.0 - uv.yx;   \n    float vig = uv.x*uv.y * 15.0;\n    vig = pow(vig, 0.525); \n    //first scene\n\tif(iTime<25.){\n\t\tfragColor = mix(vec4(t)*vig,vec4(0.0),pow(iTime/25.,2.));\n    }\n    //second scene\n     else{\n        fragColor = mix(vec4(0.),vec4(t),clamp(iTime-27.,0.,1.));\n    }\n\t\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define  velocity 2.075+pow(iTime,1.75)\n#define PI 3.1415926535\n#define HALFPI 1.57079632679\n#define TWOPI 6.28318530718\n#define AA 2\nfloat planeangle = 0.15;\nmat2 planerot;\nfloat lighting = 0.0;\nint scene = 0;\nfloat cloudexp = 0.0;\nmat2 rot1st;\nmat2 rot2nd;\nmat2 rot3rd;\nmat2 cupolarot;\n \n \nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n \nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),-0.0); \n}\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n\n\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n\nfloat noise( in vec3 x )\n{\n    return textureLod(iChannel2,x/20.,0.0).x;\n}\n\n\n\nfloat sdPlaneBody(vec3 q,float bodylen,float r1,float r2,vec3 dim1,vec3 dim2,float power)\n{\n\n     return mix( sdCappedCylinder(q.xzy/dim1,r1,bodylen),sdCappedCylinder(q.xzy/dim2,r2,bodylen),clamp(pow((q.z+bodylen)/(bodylen*2.),power),0.,1.));\n}\n//Scene for cloud volume\nfloat cloudmap(vec3 p){\n\n\n    p.y+=0.3;\n    vec3 q  = p;\n\n    float d = 100.;\n    if(p.y<1.4){\n        p.y*=1.5;\n        p.y-=0.0;\n        d = length(p+vec3(0.,-0.2,0.))-cloudexp;\n        d =max(d, -length(q.xz)+cloudexp*3.0);\n        float up = q.y+0.5;\n        up-=q.x*q.x*0.05;\n        up-=q.z*q.z*0.05;\n        float ground = up;\n        d = min(d,ground);\n        q.z+=iTime;\n        if(scene==0){\n        q.y+=velocity*0.05-2.075;}\n        //applying two layer noise to distance field\n        float n = noise(q*2.)*0.3;\n        n+=noise(q*8.)*0.3*0.3;\n        d =d*0.6+  2.*(n)-1.;\n     }\n\n      return -d;\n\n}\n\n\nfloat sdbolts(vec3 p){\n      vec3 q = p;\n   \n     float div = (TWOPI)/15.;\n     float ang = 0.;\n     q.x+=sin(ang)*0.9;\n     q.y+=cos(ang)*0.9;\n     q.z+=0.75;\n     float sp =  length(q)-0.07;\n     float an;\n     for(int i= 0;i<15;i++){\n         q = p;\n         an+=div;\n         float sz = clamp((1.+abs(floor(q.z/2.))*0.1),0.,5.);\n         q.x+=sin(an)*0.9*sz;\n         q.y+=cos(an)*0.9*sz;\n         q.z+=1.51;\n         sp = min(sp,length(q)-0.065);\n     }\n     return sp;\n}\n\nvec2 leg_part(vec3 p){\n    float m = 4.;\n    p.z+=6.65;\n    p.y+=3.0;\n    vec3 lr = p;\n     \n    if(p.z>0.){\n        lr.x = abs(lr.x)-1.5;\n        lr.y+=0.25;\n    }\n     \n    else\n     {\n         lr.y-=1.25;\n         lr*=1.75;\n     }\n     \n     lr.z = abs(lr.z)-5.5;\n     lr-=vec3(0.0,2.0,-2.0);\n     float leg = sdVerticalCapsule(lr-vec3(-0.1,-0.25,0.0),1.,0.065);\n     \n     lr-=vec3(0.0,-0.5,0.0);\n     float wheel = sdTorus(lr.zxy,vec2(0.3,0.1));\n     \n     float ball = sdEllipsoid(lr,vec3(0.15,0.25,0.25));\n     \n     if(wheel<leg){\n         leg = wheel;\n         m = 5.0;\n     }\n     \n     if(ball<leg){ leg = ball; m =4.;}\n   \n  \n    if(p.z<0.){\n         leg/=1.75;\n    }\n    return vec2(leg,m);\n}\nvec4 stunt_plane(vec3 p){\n\n\n    //Bounding box for aircraft\n    float d= min(sdRoundBox(p-vec3(0.0,0.2,-4.6),vec3(2.,1.5,5.2),0.0),sdRoundBox(p-vec3(0.0,0.0,-3.5),vec3(5.5,1.5,1.1),0.0));\n    //material variable\n    float m;\n    if(d<1.0){\n   \n \n        vec3 q = p;\n        \n        //Fan baldes\n        q.xy*=rot1st;\n        q.y-=0.8;\n        d =min(100., sdEllipsoid(q,vec3(0.1,1.2,0.05)));\n\n        q = p;\n        q.xy*=rot2nd;\n        q.y-=0.8;\n        d = min(d,sdEllipsoid(q,vec3(0.1,1.2,0.05)));\n\n        q = p;\n        q.xy*=rot3rd;\n        q.y-=0.8;\n        d = min(d,sdEllipsoid(q,vec3(0.1,1.2,0.05)));\n\n\n        //FAN motor\n        q =p;\n        float a = HALFPI;\n        q.z+=1.0;\n        float fanholder = sdVerticalCapsule(q.xzy,1.,0.5);\n        m =4.0;\n\n\n        //aircraft head\n        q.z-=0.1;\n        float head =  length(q)-1.05;\n        q.z+=0.25;\n        head = max(-p.z-1.1,head);\n        vec3 dq = q;\n        dq.x = abs(dq.x);\n        float f = min(sdVerticalCapsule(dq.xzy+vec3(-0.5,-0.3,-0.75),0.5,0.025),fanholder);\n        head = smax(f,head,0.15);\n        if(head<d) m = 1.5;\n        d = min(d,head);\n        if(fanholder<d) m = 4.;\n        d = min(d,fanholder+0.1);\n        \n        \n        \n        //aircraft body\n        float bodysize = 2.5;\n        q.z+=bodysize;\n        float body = sdPlaneBody(q,bodysize,0.7,1.0,vec3(1.,1.,1.2),vec3(1.),1.);\n        vec3 fq = p;\n        bodysize = 2.0;\n        q.z+=bodysize*2.25;\n        body = smin(body,max(-q.z-1.5,sdPlaneBody(q,bodysize,-0.15,0.7,vec3(1.,1.,5.),vec3(1.,1.,1.25),0.75)),0.09);\n\n       \n   \n        //aircraft stablizer\n        a = 0.3;\n        fq = q;\n        fq+=vec3(-0.0,-0.5,0.7);\n        fq.yz*=mat2(cos(a),sin(a),-sin(a),cos(a));\n        float radius = 0.9;\n        fq.z+=pow(abs(fq.y),3.)*0.5;\n        float stablizer = sdEllipsoid(fq,vec3(0.1,radius,radius));\n        fq = q;\n        float an;\n        fq+=vec3(13.5,0.5,3.5);\n        fq.x = abs(p.x);\n        fq.z+=sin(fq.x+2.2)*0.04;\n        float xsep = abs(q.x)-0.975;\n        vec3 flapSize = vec3(0.5,-0.45,1.0-pow(fq.x,0.25)*0.7);\n        stablizer = min(stablizer,sdRoundBox(vec3(xsep,q.y,q.z)+vec3(0.0,0.0,0.5),flapSize,0.5));\n        //setting body material\n        if(body<d){\n            m = 2.5;\n        }\n        dq = p;\n        dq+=vec3(0.0,-0.55,3.0);\n        dq.x=abs(q.x);\n        dq.x-=0.75;\n        float details = sdVerticalCapsule(dq.xzy,1.25,0.1);\n        stablizer = min(stablizer,details);\n        body = smin(body,stablizer,0.06);\n\n\n        //Aircraft cupola\n        fq = p;\n        fq.zy*=cupolarot;\n        float cupola = sdVerticalCapsule(fq.xzy-vec3(0.0,-5.,1.3),0.85,0.5);\n        body = smax(cupola,body,0.05);\n        cupola = max(abs(-fq.z-4.5)-0.075,cupola-0.04);\n        if(cupola<body) { m = 4.0; body = cupola;}\n\n\n\n     \n        //Pipes on stablizer sizde\n        float pipes = sdCappedCylinder(q-vec3(0.,1.2,1.5),0.05,0.35);\n        vec3 pq = q;\n        pq.x = abs(pq.x);\n        pq.y+=0.75;\n        an = 0.5;\n        pq.xz*=mat2(cos(an),sin(an),-sin(an),cos(an));\n        pipes = min(pipes,sdCappedCylinder(pq.xzy-vec3(1.2,0.1,.75),0.02,0.8));\n        pipes = smin(pipes,sdCappedCylinder(q.xzy-vec3(0.0,0.35,1.525),0.025,1.15),0.05);\n        if(pipes<body) m = 4.0;\n        body = smin(body,pipes,0.08);\n\n\n\n        //Ring to bind the aircraft body\n        q = p;\n        q.z+=1.5;\n        q.y-=0.;\n        float ring =sdCappedCylinder(q.xzy,1.015,0.1);\n        if(ring<body) m = 4.0;\n        body= min(ring,body);\n        \n\n        //Aircraft wings\n        q = p;\n        an = -0.15*sign(p.x);\n        q.yx*=mat2(cos(an),sin(an),-sin(an),cos(an));\n        q+=vec3(3.5,0.5,3.5);\n        q.x = abs(p.x);\n        q.z+=sin(q.x+2.2)*0.04;\n        vec3 wingsSize = vec3(5.0,-0.175-pow(q.x,0.25)*0.17,1.5-pow(q.x,0.25)*0.7);\n        float wings = sdRoundBox(q,wingsSize,0.5);\n        q.z=abs(q.z)-0.5;\n        float wingscut = sdVerticalCapsule(q.yxz-vec3(0.1,1.2,0.),3.7,0.025)-0.;\n        wings = smax(wingscut,wings,0.05);\n        if(wings<body) m = 2.5;\n        body = smin(body,wings,0.4);\n\n\n        //in first scene we render plane with legs\n        if(scene==0){\n            vec2 leg = leg_part(p);\n            if(leg.x<body){ m = leg.y; body = leg.x;}\n        }\n        \n        \n        d = smin(d,body,0.1);\n\n         \n        //bolts on ring to bind aircraft body\n        float bolts = 100.;\n        if(p.z+2.>0.0 && p.z+2. <1.){\n            bolts = sdbolts(p);\n        }\n       d = smin(d,bolts,0.01);\n\n       //Flag on end of aircraft :)\n       q = p;\n       q-=vec3(0.,0.1,-9.5);\n       float flag = sdVerticalCapsule(q.xyz,1.5,0.015);\n       q-=vec3(0.,1.3,-0.3);\n       q.x+=sin(q.z*10.+iTime*15.)*0.01;\n       if(flag<d){d = flag; m = 4.0;}\n       flag = sdRoundBox(q,vec3(0.005,0.2,0.3),0.0);\n       if(flag<d){d = flag;m=6.0;}\n      \n}\n    return vec4(d,m,0.,0.);\n\n\n}\n//Road which appears in first scene\nfloat road(vec3 p){\n     float road = sdRoundBox(p-vec3(0.,-3.+pow(p.z,2.)*0.0025,0.),vec3(15.,0.1,140.),0.1);\n     return road;\n\n}\n\n//Scene for opaque objects\nvec4 map(vec3 p){\n    float m;\n    float ground = p.y+0.3;\n    p.y+=0.1;\n    p.z-=0.5;\n    float scale = 0.1;\n    float a = 0.1;\n    p/=scale;\n    vec3 pr = p;\n    //in first scene we tilt plane lil bit to touch it on ground with legs\n    if(scene ==0){\n        pr.zy*=planerot;\n    }\n    vec4  d = stunt_plane(pr);\n    m = d.y;\n    if(scene==0){\n        float rd = road(p+vec3(0.,-0.25+velocity*0.05-2.075,0.));\n        if(rd<d.x){m = 3.0;}\n        d.x = min(d.x,rd);\n    }\n    d.x*=scale;\n   \n    \n    return vec4(d.x,m,0.,0.);\n\n\n}\n\n//scene of cupola which is transparent object\nvec4 mapCupola(vec3 p){\n\n\n    float m;\n    float scale = 0.1;\n    float d;\n    p.y+=0.1;\n    p.z-=0.5;\n    p/=scale;\n    if(scene ==0){\n        p.zy*=planerot;\n    }\n    vec3 fq = p;\n    fq.zy*=cupolarot;\n    float seatcut = sdVerticalCapsule(fq.xzy-vec3(0.0,-5.,1.3),0.85,0.5);\n    d = seatcut;\n    d*=scale;\n    return vec4(d,m,0.0,0.0);\n}\n\n\n//ray intersecting test opaque scene\nvec4 rayScene(vec3 ro,vec3 rd){\n    float t = 0.15;\n    vec4 rt;\n    for (int i =0;i<100;i++){\n        vec3 p = ro+rd*t;\n        rt = map(p);\n        float h = rt.x;\n        if(h<0.0001) break;\n        t+=h;\n        if(t>25.) {t=100.; break;}\n    \n    }\n    \n    return vec4(t,rt.y,0.,0.);\n}\n\n//Ray intersecting transparent scene\nvec4 rayTransparent(vec3 ro,vec3 rd){\n    float t = 0.0;\n    vec4 rt;\n    for (int i =0;i<100;i++){\n        vec3 p = ro+rd*t;\n        rt = mapCupola(p);\n        float h = rt.x;\n        if(h<0.0001) break;\n        t+=h;\n        if(t>25.) {t = 100.; break;}\n        \n    }\n    \n    return vec4(t,rt.y,0.,0.);\n}\n\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = map( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        \n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nvec3 calculate_normal(vec3 pos,bool m){\nconst float eps = 0.0001;\n    vec4 n = vec4(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec4 s = vec4(pos, 0.0);\n        s[i] += eps;\n        if(m)  n[i] = map(s.xyz).x;\n        else  n[i] = mapCupola(s.xyz).x;\n       \n    }\n    return normalize(n.xyz-n.w);\n}\n\n\n//Cloud volume raymarching\nvec4 volume(vec3 ro,vec3 rd,vec4 col,float z){\n\n    float t = 0.;\n    vec4 sum;\n    float stepsize = 0.065;\n    for(int i= 0;i<54;i++){\n        \n       vec3 p = ro+rd*t;\n       p.y+=0.3;\n       p.z-=0.1;\n       float h = cloudmap(p);\n       //if inside volume\n       if(h>0.001){\n       \n           vec4 c;\n           //scene one grey clouds\n           if(scene==0){\n                 c= mix(vec4(0.3,0.3,0.3,1.),mix(vec4(1.),vec4(1.2,1.2,1.5,1.),sin(iTime)*0.5+0.5),clamp(pow(p.y+0.1,0.3)*0.85-0.2,0.,0.5));\n           }\n           //scene two animated clouds color\n           else{\n                 c= mix(vec4(0.3,0.3,0.3,1.),vec4(1.2,1.,abs(sin(iTime*0.3))+0.5,1.),clamp(pow(p.y+0.35,0.3)*0.7-0.1,0.,1.));\n           }\n\n\n           sum +=vec4(h*1.25)*vec4(c)*(1.-sum.a);\n\n           //if cloud depth is greater than scene depth we stop\n           if(t>z) { break; };\n       }\n       float random;\n       //apply randomness to step when cloud distance near to scene to reduce artifact\n       if(z-t<0.5){ random= texture(iChannel3,p.xz*12.).r; }\n       float stp = (stepsize+random*.065 ) ;\n      \n       t+=stp;\n      \n    \n    }\n   //blend scene color with cloud edge(for soft edge)\n   col*=1.+sum.a;\n   sum = mix(col,clamp(sum*0.87,0.,1.)*1.5,sum.a);\n   return vec4(sum.rgb,t);\n}\nvec4 render(vec3 ro,vec3 rd){\n    //Opaque scene\n\tvec4 t = rayScene(ro,rd);\n    //Transparent scene\n    vec4 tb = rayTransparent(ro,rd);\n  \n    vec2 uv = (2.*gl_FragCoord.xy-iResolution.xy)/iResolution.y;\n    float up = 1.-uv.y;\n    //sky color\n    vec3 sk = mix(vec3(0.9,0.69,0.7)*1.0,vec3(1.0,1.0,1.0),up);\n    vec3 col = sk;\n    \n    //If opaque or transparent scene in in range\n    if((t.x>0.&&t.x<100.)||(tb.x>0.&&tb.x<100.)){\n      \tvec3 p =   ro+rd*t.x;\n        vec3 n = calculate_normal(p,true);\n        vec3 sun = vec3(-0.6,0.7,1.);\n        float occ = calcOcclusion(p,n);\n        float dif = dot(n,sun);\n   \n        //Reflection vector\n        vec3 refvec = normalize(reflect(rd,n));\n        //Fresnel factor\n        float fresnel = dot(rd,n);\n        \n        //flag material\n        if(t.y>5.5){\n            vec3 spec = texture(iChannel1,refvec,2.).rgb*vec3(0.5,0.5,0.9);\n            col = vec3(max(dif,0.))*vec3(0.6,0.5,0.9)+0.5+spec*0.5;\n            \n        }\n        \n        //tire material\n        else if(t.y>4.5){\n            vec3 spec = texture(iChannel1,refvec,2.).rgb+0.5;\n            col = dif*vec3(1.)*spec;\n            col+=0.9*spec;\n            col*=0.5;\n        }\n        \n        //metal material \n        else if(t.y>3.5){\n            vec3 spec = texture(iChannel1,refvec,1.).rgb;\n            spec = mix(vec3(0.5,0.5,0.5),spec,0.7);\n            col = spec;\n            col = clamp(col,0.,1.)*0.8;\n            col+=0.5;\n            col+=clamp(fresnel+0.5,0.,1.)*lighting*0.5;\n            col*=occ*1.;\n        }\n   \n       //road material\n       else if(t.y>2.5){\n           float shad = softshadow(p+n*0.001,normalize(sun),0.001,2.,64.);\n           p.z+=velocity*0.25;\n           float st = smoothstep(0.1,0.08,abs(p.x)+0.03)*smoothstep(0.3,0.28,(abs(fract(p.z/2.5)*2.-1.)));\n           vec3 spec = texture(iChannel1,refvec,12.).rgb*vec3(1.,0.8,0.6);\n           st=max(0.,st);\n           col = dif*0.5+(spec*0.3);\n           col = clamp(col,0.,1.)*0.8;\n           col+=clamp(fresnel+1.0,0.,1.)*0.5;\n           col+=st;\n           \n           col*=1.+shad*0.4;\n           col = mix(col,sk,smoothstep(1.25,1.5,abs(p.x)));\n           col = mix(col,sk,clamp(t.x/10.,0.,1.)); \n           \n        }\n        \n        //aircraft wrapping material\n        else{\n            //pattern\n            float rg = smoothstep(0.5,0.4,texture(iChannel2,p*2.,1.0).x);\n            vec3 spec = texture(iChannel1,refvec,0.).rgb*vec3(1.,0.8,0.6);\n            spec = mix(vec3(0.5),spec,clamp(rg,0.,1.));\n            col = vec3(0.5,0.5,0.9)*(dif+0.6)*0.6*spec;\n            col = clamp(col,0.,1.)*0.8;\n            col+=0.6;\n            col+=clamp(fresnel+0.5,0.,1.)*lighting;\n            col*=occ*1.2;\n        }\n        \n        //Transparent cupola material\n        if(tb.x>0.0&&tb.x<100.){\n            vec3 p =   ro+rd*tb.x;\n            vec3 n = calculate_normal(p,false);\n            vec3 refvec = normalize(reflect(rd,n));\n            float fresnel =dot(rd,n);\n            vec3 spec = texture(iChannel1,refvec*2.,0.).rgb*1.25;\n            //if ray hits both transparent and opaque scene\n            if(tb.x<t.x){\n               float fr1 = min(1.,fresnel+1.45);\n               col = mix(col,vec3(fr1)*spec,fr1*0.6);\n               col+=(fresnel+1.)*0.4;\n            } \n            //if ray hits only transparent scene \n            if(t.x<0.0||t.x>100.){\n               col = sk;\n               float fr1 = min(1.,fresnel+1.45);\n               col = mix(col,vec3(fr1)*spec,fr1*0.6);\n               col+=(fresnel+1.)*0.4;\n            }\n        \n    \n        }\n    \n    }\n     \n    //return final color and scene of opaque and transparent\n    return vec4(col,min(t.x,tb.x));\n\n\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //rotation angle for fan\n    float rotang; \n    vec3 ro;\n    vec3 rd;\n    //planeangle = 0.\n    vec4 col = vec4(0.);\n    float an_x = 10.*-iMouse.x/iResolution.x;\n   \tfloat an_y;\n    float off =1.2;\n    cloudexp = mod(iTime*0.5-3.1414/2.,2.)*1.-1.;\n    \n    \n    //First scene\n    if(iTime<25.){\n        rotang = velocity;\n        planerot = mat2(cos(planeangle),sin(planeangle),-sin(planeangle),cos(planeangle));\n        // planeangle=0.0;\n        an_x=-2.0;\n        an_y = -0.25+sin(iTime*0.4)*0.2; an_y+=0.4; \n    }\n           \n            \n    else{\n            \n        rotang = iTime*14.;\n        scene = 1;\n        an_y = 5.*iMouse.y/iResolution.y;\n        an_y+=0.6;\n        off = 1.0;\n    }\n            \n          \n    //Pre roation for objects      \n    cupolarot = mat2(0.988,0.1494,-0.1494,0.988);      \n    rot1st = mat2(cos(rotang-2.0754),sin(rotang-2.0754),-sin(rotang-2.0754),cos(rotang-2.0754));\n    rot2nd = mat2(cos(rotang),sin(rotang),-sin(rotang),cos(rotang));\n    rot3rd = mat2(cos(rotang+2.0754),sin(rotang+2.0754),-sin(rotang+2.0754),cos(rotang+2.0754));\n    \n    //lighting increases from first scene\n    lighting+=min(iTime/25.,1.);\n          \n  \n   \t\t\t\n    //camera anlge in x axis        \n    an_x+=sin(iTime/4.)/2.5-0.7;\n    vec3 center = vec3(0.0,0.0,0.2);\n    an_y = clamp(an_y,0.2,3.);\n    \t\t\n    ro = center+vec3(sin(an_x)*cos(an_y)*off,off*sin(an_y),cos(an_x)*off*cos(an_y));\n    //camera to center vector\n    vec3 v = normalize( center-ro);\n    //cam right vector\n    vec3 r = normalize(cross(v,vec3(0.0,1.0,0.0)));\n    //cam up vector\n    vec3 u = normalize(cross(r,v));\n\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 rr = vec2( float(m), float(n) ) / float(AA);\n        vec2 uv = (2.*(fragCoord+rr)-iResolution.xy)/iResolution.y;\n    \trd = normalize(uv.x*r+uv.y*u+1.5*v);\n        //Rendeing opaque and transparent scene\n        col += render(ro,rd);\n     }\n     col /= float(AA*AA);\n    //passing scene and it's depth to volume marching\n    vec4 cloudscene =volume(ro,rd,vec4(col),col.a);\n    col = cloudscene;\n    \n    fragColor = vec4(col);\n}","name":"Buffer A","description":"","type":"buffer"}]}