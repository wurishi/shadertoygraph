{"ver":"0.1","info":{"id":"lls3zr","date":"1535450603","viewed":210,"name":"superquadric","username":"386dx25","description":"Simple raycaster for a superquadric tensor glyph. In the code you can switch between classical raymarching and a Newton-style iteration. The latter is faster but leads to artefacts for some alpha/beta combinations (in the current implementation).","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["visualization","superquadric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Raycast a supequadric glyph (comparison of two implementation variants)\n// Max Hermann and Vitalis Wiens, Dec 2014 ({wiens,hermann}@cs.uni-bonn.de)\n\n//precision highp float;\n//precision highp int;\n\n//---[ Shading ] --------------------------------------------------------------\n\n// Phong material\nstruct Material\n{\n\tfloat ka;\tvec3 camb;  // ambient\n\tfloat kd;\tvec3 cdiff; // diffuse\n\tfloat ks;   vec3 cspec; // specular\n\tfloat phongExponent;\n};\n\n// Phong shading with some default material and constant light\nvec3 shade( vec3 N, vec3 E )\n{    \n    Material mat = Material(\n\t\t0.20, vec3(1.0,1.0,1.0),\n\t\t0.65, vec3(0.6,0.8,1.0),\n\t\t0.90, vec3(1.0,1.0,0.0), 50.0 \n\t);\n    E = normalize(E);\n    vec3 L = normalize(vec3(-1, 1, -1));\n\tvec3 H = normalize( E + L );\n\treturn  \n\t\tmat.ka * mat.camb\n\t  +\tmat.kd * mat.cdiff * max(0.0, 1.0 * dot(L,N))\n      + mat.ks * mat.cspec * pow( max(0.0,dot(H,N)), mat.phongExponent );\n}\n\n//---[ Ray & sphere intersection ]---------------------------------------------\n\n// Ray has an origin and a (normalized) direction\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n    \n// Raytracing intersection\nstruct Intersection {\n    bool valid;\n    vec3 normal;\n    vec3 pos;\n};\n\n// Raytracing intersection calculation for the bounding sphere\nIntersection intersect_unit_sphere( Ray r )\n{\n    const float radius = 1.7;\n    \n    Intersection s;\n    s.valid = true;\n    \n    // Apply pq formula\n    float denom = dot(r.dir,r.dir);\n    float p = 2.0 * dot(r.dir,r.origin) / denom;\n    float q = (dot(r.origin,r.origin) - radius*radius) / denom;\n    \n    float D = (0.5*p)*(0.5*p) - q;\n    if( D < 0.0 )\n    {\n    \ts.valid = false;\n        return s;\n    }\n    \n    // Return closer intersection\n    s.pos = r.origin + (-.5*p - sqrt(D)) * r.dir;\n    s.normal = normalize(s.pos);\n    return s;\n}\n\n// Explicit intersection calculation\nvec4 scene1( Ray r, vec3 eye )\n{\n    Intersection s = intersect_unit_sphere( r );\n    if( s.valid )\n    {\n        //float li = abs(dot(s.normal,normalize(eye)));\n        //return li * vec4(1.0,1.0,1.0,1.0);\n        //return vec4(s.normal,1.0);\n        return vec4(shade(s.normal,normalize(eye)),1.0);\n    }\n    else\n    {\n        return vec4(0.0,0.0,0.0,1.0);\n    }    \n}\n\n//---[ Superquadric implicit equation & gradient ]-----------------------------\n\n// Workaround for some WebGL implementation deficiencies\n// (Only required for specific browser/driver combinations?!)\nvoid sq_sanitize_input( inout vec3 p, inout float alpha, inout float beta )\n{  \n  #if 0\n    // On some hardware/drivers below workaround is not required?!\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    p.z = abs(p.z);\n  #else\n    // WORKAROUND: There seems to be an optimization bug when alpha/beta are integers.\n    //             Avoid this by adding some epsilon.\n    const float eps = 0.000001;\n    alpha += eps;\n    beta  += eps;\n    // WORKAROUND: pow(x,y) requires x>0 and x and y not equal 0.\n    p.x = abs(p.x) + eps;\n    p.y = abs(p.y) + eps;\n    p.z = abs(p.z) + eps;    \n  #endif    \n}\n\n// Superquadric implicit equation\nfloat sq( vec3 p, float alpha, float beta )\n{\n    sq_sanitize_input( p, alpha, beta );\n    return \n        //x*x + y*y + z*z - 1.0; \n        pow( pow(p.x,2.0/alpha) + pow(p.y,2.0/alpha), alpha/beta ) + pow(p.z,2.0/beta) - 1.0;\n}\n\n// Superquadric implicit gradient\nvec3 dsq( vec3 p, float alpha, float beta )\n{   \n    vec3 p0 = p;\n    vec3 sp = sign(p);\n    sq_sanitize_input( p, alpha, beta );\n    \n    // Chain rule (df is inner derivative for dx,dy terms)\n    vec3 dq;\n    float df = (alpha/beta)*pow( pow(p.x,2.0/alpha)+pow(p.y,2.0/alpha), (alpha/beta)-1.0);\n    dq.x = (2.0/alpha) * pow(p.x,(2.0/alpha)-1.0) * df;\n    dq.y = (2.0/alpha) * pow(p.y,(2.0/alpha)-1.0) * df;\n    dq.z = (2.0/beta)  * pow(p.z,(2.0/beta)-1.0);\n    \n    // WORKAROUND: Orient gradient as in a sphere\n   \tdq *= sp;\n    //dq = dot(dq,normalize(p))*p;\n    //dq = abs(dq)*sp;\n    return dq;\n}\n\n//---[ Distance field adapter w/ global rotation ]-----------------------------\n\n// Workaround: tranpose() not available in Shadertoy OpenglES version\nmat3 transpose2( mat3 m )\n{\n    return mat3( m[0].x, m[1].x, m[2].x,\n                 m[0].y, m[1].y, m[2].y,\n                 m[0].z, m[1].z, m[2].z );\n}\n\n// Distance function\nmat3 g_R = mat3(1.0); // Global rotation\nfloat g_alpha = 1.0;  // Global alpha parameter for superquadric\nfloat g_beta  = 1.0;  // Global beta parameter for superquadric\nfloat df( vec3 p )\n{\n    return sq( g_R * p, g_alpha, g_beta );\n}\nvec3 ddf( vec3 p )\n{\n    return transpose2(g_R) * dsq( g_R * p, g_alpha, g_beta );\n}\n\n//---[ Variant A: Raymarching ]------------------------------------------------\n\n// Stupid raycasting\nvec4 scene2( Ray r, vec3 eye )\n{       \n    // Tuned to raycast tensor glyph shape space\n    const float stepsize = 0.001; // 0.007;\n    const float maxlength = 2.8;\n    \n    // Ray marching\n    vec3 step = stepsize*r.dir;\n    const int refinement_steps = 7;\n    vec3  p; // Current point on ray traversal\n    vec3  n; // Normal at Rp\n    float s; // Scalar value at Rp\n    vec4 color = vec4(1.0,0.0,0.0,1.0);    \n    for( int i=0; i < int(maxlength/stepsize); ++i )\n    {\n        vec3 total = float(i)*stepsize * r.dir;\n        p = r.origin + total;\n        s = df( p );\n        \n        //return 0.1*vec4(s,abs(s),abs(s),1.0); // DEBUG: Show scalar field\n        \n        // Close to zero set?\n        if( abs(s) < 0.1 )\n        {\n          #if 0 // FIXME: Bisection does not really help on superquadrics?\n            //if( abs(s)>0.001 ) // Just refine if not close enough already\n            {\n                // Intersection refinement\n                float searchdir = sign(s);    // Initial step direction\n                vec3 ministep = step*.5;\n                for( int j=0; j < refinement_steps; ++j )\n                {\n                    // Binary search\n                    p += searchdir*ministep;\t\t\t\t\n                    s = df( p );\n\n                    // Move backwards until exact intersection overstepped\n                    // and vice versa\n                    if( s < 0.0 )\n                        searchdir = -1.0;\n                    else\n                        searchdir = 1.0;\n\n                    // Half stepsize\n                    ministep *= .5;\n                }\n            }\n            //if( abs(s) > 0.01 ) continue; // Sanity: Reject if we didn't get closer\n          #endif                   \n            \n          #if 0\n            // DEBUG gradient\n            float sq = df( p );\n            vec3 gradient = ddf( p );\n            float sqd = dot( gradient, r.dir );\n            return 20.0*vec4(0.05*vec3(sqd,abs(sqd),abs(sqd)),1.0); // DEBUG: Show gradient\n          #endif\n            \n            // Shading\n        \tn = normalize( ddf(p) );            \n        \tcolor = \n                //vec4( 20.0 *vec3(s,abs(s),abs(s)), 1.0 ); // DEBUG: Show distance to real isosurface\n                //vec4(n,1.0); // DEBUG: Show normals\n                vec4( shade(n,normalize(eye)), 1.0 );            \t\n            \n            // BUG: On Firefox 34.05 with a GTX 780 / driver 340.64 the \n            //      if branch seems to be optimized away and is never \n            //      executed as long as we use a return (or break) to \n            //      leave the loop!\n            //return vec4(1.0,1.0,1.0,1.0);\n            //break;\n            return color;\n        }\n    }\n    return color;\n}\n\n//---[ Variant B: Newton iteration ]-------------------------------------------\n\n// Newton raycasting (as described by Hlawitschka et al. 2008)\nvec4 scene3( Ray r, vec3 eye )\n{\n    const int maxNumSteps = 50;\n    float t = 0.0;\n    for( int i=0; i < maxNumSteps; ++i )\n    {\n        vec3 p = r.origin + t*r.dir;    \n        float sq = df( p );\n        vec3 gradient = ddf( p );\n        float sqd = dot( gradient, r.dir );\n        \n        //return vec4(sq,abs(sq),abs(sq),1.0); // DEBUG: Show scalar field\n        //return 0.4*vec4(sqd,abs(sqd),abs(sqd),1.0); // DEBUG: Show gradient\n        \n        // WORKAROUND: One should only consider gradients close to the glyph!\n        //sqd = sign(sqd) * clamp(abs(sqd), 0.001, 100.0);\n        \n        // Newton step         \n        float stepsize = 0.5 * (sq / sqd);\n        t = t - stepsize;\n        \n        //return vec4(stepsize,0.0,0.0,1.0);\n            \n        if( (sq < 0.0001) ) //|| (abs(stepsize) < 0.00001) )\n        {\n            // Shading\n        \tvec3 n = normalize( gradient );\n        \treturn\n                vec4( shade(n,normalize(eye)), 1.0 );\n                //vec4(n,1.0); // DEBUG: Show normals\n            \t//vec4(0.05*vec3(sqd,abs(sqd),abs(sqd)),1.0); // DEBUG: Show gradient\n        }   \n    }\n    \n    return vec4(0.0,1.0,0.0,1.0);\n}\n\n//---[ Camera rotation functions ]---------------------------------------------\n\nmat3 rodriguez( vec3 r, float theta )\n{\n    float s = sin(theta);\n    float c = cos(theta);\n    float t = 1.0-c;\n    return mat3(\n        \tt*r.x*r.x + c,     t*r.x*r.y - s*r.z, t*r.x*r.y + s*r.y,\n        \tt*r.x*r.y + s*r.z, t*r.y*r.y + c,     t*r.y*r.z - s*r.x,\n        \tt*r.x*r.z - s*r.y, t*r.x*r.y + s*r.x, t*r.z*r.z + c\n        );\n}\n\nmat3 Rx( float theta )\n{\n    return mat3( \n        \t   1.0,        0.0,        0.0, \n               0.0,  cos(theta), sin(theta),\n               0.0, -sin(theta), cos(theta) );\n}\n\nmat3 Ry( float theta ) \n{\n    return mat3( \n               cos(theta), 0.0, -sin(theta),\n               0.0,        1.0, 0.0,\n               sin(theta), 0.0, cos(theta) );\n}\n\nmat3 Rz( float theta )\n{\n\treturn mat3( \n               cos(theta), sin(theta),  0.0,\n              -sin(theta), cos(theta),  0.0,\n               0.0,        0.0,         1.0 );\n}\n\n//---[ Main ]------------------------------------------------------------------\n\n// Interaction mode:\n//  0 = navigate camera w/ automatic animation\n//  1 = navigate parameter space\n#define MODE 0\n// Scenes:\n//  scene1 = raytrace the bounding sphere\n//  scene2 = raycast superquadric using plain raymarching\n//  scene3 = raycast superquadric using Newton iteration\n#define SCENE scene2(r,eye);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Cast a ray through the screen\n    Ray r;\n    vec2 p0 = 2.0 * fragCoord.xy / iResolution.xy - vec2(1.0,1.0);\n    p0.x *= iResolution.x / iResolution.y;    \n    p0 *= 1.3; // Zoom out a bit\n    vec3 eye = vec3(0.0,0.0,-8.0);    \n    r.origin = vec3(p0,-2.0);\n    r.dir    = normalize(r.origin - eye);\n    \n    // Intersect with bounding sphere\n\tIntersection s = intersect_unit_sphere( r );\n    r.origin = s.pos;\n    \n    // Normalized mouse coordinate [-1,1]\n    vec2 nm = 2.0 * iMouse.xy / iResolution.xy - 1.0;\n    \n    // Mouse interaction\n  #if MODE==0\n    // Control camera, hardcoded alpha,beta\n    g_alpha = 0.1 + 3.5*(0.5+0.5*sin(1.0*iTime));\n    g_beta  = 0.1 + 3.5*(0.5+0.5*cos(2.3*iTime));\n    g_R = Ry(nm.x*1.0*3.1415)*Rx(nm.y*1.0*3.1415);     \n  #else // MODE==1\n    // Control alpha/beta, hardcoded viewing angle    \n    g_alpha = 4.0 * float(iMouse.x) / float(iResolution.x);\n    g_beta = 4.0 * float(iMouse.y) / float(iResolution.y);    \n    g_R = Rz(-0.1*3.1415)*Rx(-0.35*3.1415);\n  #endif    \n    //g_R = mat3(1.0); // DEBUG: Fixed camera\n    \n    // Estimate fragment color\n    vec4 color = vec4(0.0); // Black background\n    if( s.valid )\n        // Quadric\n    \tcolor = SCENE;\n    // Color tensor parameter space\n    vec2 ps = 4.0 * fragCoord.xy / iResolution.xy;\n    if( (ps.x < 1.0) && (ps.y < ps.x) ) \n        color = vec4( 0.5*color.rgb + 0.5*vec3(1.0,1.0,1.0), 1.0 );\n        //color = vec4(0.0,0.0,1.0,1.0);\n   \t\n    vec2 pixelSize = 1.0 / iResolution.xy;\n    if( (abs(ps.x-g_alpha)<15.0*pixelSize.x) && (abs(ps.y-g_beta)<15.0*pixelSize.y) )\n        color = vec4(1.0,1.0,1.0,1.0);\n    \t\n    fragColor = color; // scene2(r,eye);\n}","name":"Image","description":"","type":"image"}]}