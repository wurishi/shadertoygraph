{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// http://www.fractalforums.com/movies-showcase-%28rate-my-movie%29/very-rare-deep-sea-fractal-creature/\n//kali gl code rmxed\n// Colored version of https://www.shadertoy.com/view/lsjXzW\n// Edited by c.Kleinhuis for coloring, the coloring method from fragmentarium default de shader using\n// min(abs(p) as orbittrap is used, it keeps record of the closest distances to each axis, which is\n// then used to color the object, CODER COLORS used, red green and blue\n\nconst int Iterations=24;\nconst float Scale=1.27;\nconst vec3 Julia=vec3(-1.2,-1.95,-.6);\nconst vec3 RotVector=vec3(0.15,-0.75,-0.5);\nconst float RotAngle=99.;\nconst float Speed=1.3;\nconst float Amplitude=0.45;\nconst float detail=.0125;\nconst vec3 lightdir=-vec3(0.5,1.,0.5);\n\n\nvec3 orbitTrap;\n\n// EDIT: Alpha is used as Factor\nvec4 colorBase=vec4(1.0,1.0,1.0,0.5);\nvec4 colorX=vec4(1.0,.0,.0,2.0);\nvec4 colorY=vec4(0.0,1.0,0.0,2.0);\nvec4 colorZ=vec4(0.0,0.0,1.0,2.0);\n\nmat3 rot;\nfloat de(vec3 p); \n\nvec3 normal(vec3 p) {\n\tvec3 e = vec3(0.0,detail,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tde(p+e.yxx)-de(p-e.yxx),\n\t\t\tde(p+e.xyx)-de(p-e.xyx),\n\t\t\tde(p+e.xxy)-de(p-e.xxy)\n\t\t\t)\n\t\t);\t\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<48; i++ )\n    {\n        float h = de(ro + rd*t);\n\t\th = max( h, 0.0 );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.01, 0.5 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat light(in vec3 p, in vec3 dir) {\n\tvec3 ldir=normalize(lightdir);\n\tvec3 n=normal(p);\n\tfloat sh=softshadow(p,-ldir,1.,20.);\n\tfloat diff=max(0.,dot(ldir,-n));\n\tvec3 r = reflect(ldir,n);\n\tfloat spec=max(0.,dot(dir,-r));\n\treturn diff*sh+pow(spec,30.)*.5*sh+.15*max(0.,dot(normalize(dir),-n));\t\n\t\t}\n\n\n// EDIT: RETURN COLORS FROM ORBITTRAP\n// ORBITTRAP IS CLOSEST DISTANCE TO EACH AXIS\nvec3 getColor(){\n\n\tvec3 result=vec3(0.0,0.0,0.0);\n      \n    result=colorBase.xyz*colorBase.w+\n        \tcolorX.xyz*colorX.w*orbitTrap.x+\n        \tcolorY.xyz*colorY.w*orbitTrap.y+\n        \tcolorZ.xyz*colorZ.w*orbitTrap.z;\n    \n    \n    return result;\n    \n}\n\nvec4 raymarch(in vec3 from, in vec3 dir)\n{\n\tfloat st,d=1.0,col,totdist=st=0.;\n\tvec3 p;\n\tfor (int i=0; i<70; i++) {\n\tif (d>detail && totdist<50.)\n\t{\n\t\tp=from+totdist*dir;\n        // EDIT: Reset OrbitTrap for Every Call to DE\n        orbitTrap=vec3(1000.0,1000.0,1000.0);\n\t\td=de(p);\n\t\ttotdist+=d;\n\t}\n\t}\n   vec3 color;\n\tfloat backg=0.5;\n\tif (d<detail) {\n\t  \t // EDIT: a call to \"light\" would destroy our orbittrap, store it here, could be optimized ;)\n   \t\t vec3 orbitSave=orbitTrap;\n  \t\tcol=light(p-detail*dir, dir); \n\t\tcol = mix(col, backg, 1.0-exp(-.000025*pow(totdist,3.5)));\n        // EDIT: Use Light Value as factor, include light color if you wish\n\t    //EDIT restore orbittrap, and call getColor\n \t   orbitTrap=orbitSave;       \n        color=col*getColor();\n\t} else { \n\t\tcol=backg;\n\t}\n    \n    // Return Color\n    \n\treturn vec4(color,1);\n}\n\nmat3  rotationMatrix3(vec3 v, float angle)\n{\n\tfloat c = cos(radians(angle));\n\tfloat s = sin(radians(angle));\n\t\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\n// EDIIT: Initialise Rot Matrices Once for every pixel\nvoid initialiseMatrices(){\n\tvec3 ani;\n    float time=iTime*Speed;\n\tani=vec3(sin(1.),sin(time*.133),cos(time*.2))*Amplitude;\n\trot = rotationMatrix3(normalize(RotVector+ani), RotAngle+sin(time)*10.);\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // EDIT: CALL init once\n    initialiseMatrices();\n\tfloat t=iTime*.3;\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.-1.;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 from=vec3(0.,-.7,-20.);\n\tvec3 dir=normalize(vec3(uv*.7,1.));\n\t\n    // EDIT: Use 2d Matrice locally\n\tmat2 roti=mat2(cos(-.5),sin(-.5),-sin(-.5),cos(-.5));\n\tdir.yz=dir.yz*roti;\n\tfrom.yz=from.yz*roti;\n\n    fragColor = raymarch(from,dir);\n\n    \n    \n}\n\n\n\n\nfloat de(vec3 p) {\n\tp=p.zxy;\n\tfloat a=1.5+sin(iTime*.5)*.5;\n     \n\tp.xy=p.xy*mat2(cos(a),sin(a),-sin(a),cos(a));\n\tp.x*=.75;\n\t\n\tvec3 pp=p;\n\tfloat l;\n\tfor (int i=0; i<Iterations; i++) {\n\t\tp.xy=abs(p.xy);\n\t\tp=p*Scale+Julia;\n\t\tp*=rot;\n\t\tl=length(p);\n        // EDIT: Update Orbittrap in Every Iteration,\n        //here simple orbittrap of \"min\" is implemented, spherical orbittrap around sphere located at zero\n\t\t//orbitTrap=min(orbitTrap,abs(p));\n    \n        // EDIT: add an offset, spherical orbittrap around point \n\t\torbitTrap=min(orbitTrap,abs(p+(vec3(1.0,1.0,1.0))));\n        \n        //M Playing around, sinus of orbittrap makes interesting results ;)\n        //orbitTrap=min(orbitTrap,abs(sin(p)+1.0));\n\t}\n\treturn l*pow(Scale, -float(Iterations))*.9;\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sBXDh","date":"1411205034","viewed":421,"name":"This Wants Colors - Coder Colors","username":"VJSpackOMat","description":"This is a coloring of the \"This Wants Colors\" Shader\nhttps://www.shadertoy.com/view/lsjXzW\n\nWARNING: CODER COLORS USED!","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["kalifractalcolors"],"hasliked":0,"parentid":"","parentname":""}}