{"ver":"0.1","info":{"id":"NsS3z1","date":"1616915034","viewed":180,"name":"Beautiful Light Lines","username":"Yumuru","description":"Beautiful Light","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Reference\n// SDF for raymarching, gaz : https://neort.io/product/bvcrf5s3p9f7gigeevf0\n// フラグメントシェーダノイズ(Fragment Shader Noise), wgld.org : https://wgld.org/d/glsl/g007.html\n\n#define PI acos(-1.)\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define TAU atan(1.)*8.\n\n#define resolution iResolution.xy\n#define time iTime\n\nconst int   oct  = 1;\nconst float per  = 0.8;\n\nfloat interpolate(float a, float b, float x){\n    float f = (1.0 - cos(x * PI)) * 0.5;\n    return a * (1.0 - f) + b * f;\n}\n\nfloat rnd(vec2 p){\n    return fract(sin(dot(p ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat irnd(vec2 p){\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec4 v = vec4(rnd(vec2(i.x,       i.y      )),\n                  rnd(vec2(i.x + 1.0, i.y      )),\n                  rnd(vec2(i.x,       i.y + 1.0)),\n                  rnd(vec2(i.x + 1.0, i.y + 1.0)));\n    return interpolate(interpolate(v.x, v.y, f.x), interpolate(v.z, v.w, f.x), f.y);\n}\n\nfloat noise(vec2 p){\n    float t = 0.0;\n    for(int i = 0; i < oct; i++){\n        float freq = pow(2.0, float(i));\n        float amp  = pow(per, float(oct - i));\n        t += irnd(vec2(p.x / freq, p.y / freq)) * amp;\n    }\n    return t;\n}\n\nfloat snoise(vec2 p, vec2 q, vec2 r){\n    return noise(vec2(p.x,       p.y      )) *        q.x  *        q.y  +\n           noise(vec2(p.x,       p.y + r.y)) *        q.x  * (1.0 - q.y) +\n           noise(vec2(p.x + r.x, p.y      )) * (1.0 - q.x) *        q.y  +\n           noise(vec2(p.x + r.x, p.y + r.y)) * (1.0 - q.x) * (1.0 - q.y);\n}\n\nvec2 pmod(vec2 p, float n) {\n    float a=mod(atan(p.y, p.x), TAU/n)-.5*TAU/n;\n    return length(p)*vec2(sin(a),cos(a));\n}\n\nvec3 hsv(float h, float s, float v) { return ((clamp(abs(fract(h+vec3(0,2,1)/3.)*6.-3.)-1.,0.,1.)-1.)*s+1.)*v; }\n\nfloat t;\nvec3 c;\n\nfloat map(vec3 p) {\n    vec3 p_ = p;\n    p.xz *= rot(sin(time*-0.1)*PI*-2.0);\n    float h = noise(vec2(length(p)+time*0.2, (abs(atan(p.x, p.y))+abs(atan(p.y, p.z))+abs(atan(p.z, p.x))) * 2. + -time*3.0)) * 2.;\n    h = length(p)+h-time*0.2;\n    vec3 c1 = hsv(-0.2+sin(time*.3)*0.05 + fract(h) * (0.4 + sin(time)*0.1), 1., 1.);\n    c1 += -pow(0.27 / length(p), 3.2);\n    c1 += pow(0.14 / length(p)+.2, 9.2);\n    float t1 = 1. - pow(length(p)*1.4, 5.0);\n    t1 *= 1.5;\n    h = noise(vec2(length(p)+time*0.2, (abs(atan(p.x, p.y))+abs(atan(p.y, p.z))+abs(atan(p.z, p.x))) * 2. + time*3.0)) * 6.;\n    h = length(p)+h-time*0.2;\n    p = p_;\n    p.xz *= rot(-sin(time*-0.1)*PI*-2.0);\n    p.xy *= rot(cos(time*0.2)*PI*4.0);\n    p.yz *= rot(time*2.0);\n    vec3 c2 = hsv(0.15+sin(time*.3)*0.05 + fract(h) * (0.6 + sin(time)*0.1), 1., 1.);\n    c2 += p*0.3;\n    float d1 = -.5 + length(p);\n    p.xy = pmod(p.xy, 7.+sin(time)*2.0);\n    p.zy = pmod(abs(p.zy), 9.+sin(PI*0.4+time*1.4)*4.);\n    p.y -= 1.5;\n    p.y -= clamp(p.y, -.3, .6);\n    c2 *= clamp(pow(.1 / length(p.xz), 1.1), 0., 3.);\n    c2 += pow(.05 / length(p.xz), 1.2);\n    c2 = max(vec3(0.), c2);\n    float t2 = 1. - pow(length(p), 0.3)*1.0;\n    t2 *= .8;\n    t2 = max(0., t2);\n    float d2 = -.2 + length(p);\n    c = d1 < d2 ? c1 : c2;\n    t = d1 < d2 ? t1 : t2;\n    return min(d1, d2);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv=(fragCoord.xy-.5*resolution)/resolution.y;\n    vec3 rd=normalize(vec3(uv,1));\n    vec3 p=vec3(0,0,-5);\n    float d=1.,i;\n    for(;++i<99.&&d>.001;)p+=rd*(d=map(p));\n    if(d<.001)fragColor+=3./i;\n    vec3 col;\n    for(i=0.;++i<64.;) col += map(p) < 0.001 ? c*0.05*t : vec3(0.), p += rd*0.04;\n    fragColor=vec4(col,1.);\n    fragColor = min(fragColor, 1.);\n}\n\n","name":"Image","description":"","type":"image"}]}