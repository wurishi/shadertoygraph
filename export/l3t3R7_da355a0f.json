{"ver":"0.1","info":{"id":"l3t3R7","date":"1716294229","viewed":55,"name":"HOI - Shader","username":"nicowesse","description":"HOI","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","debug","toy"],"hasliked":0,"parentid":"XsyGRW","parentname":"2D SDF Toy"},"renderpass":[{"inputs":[],"outputs":[],"code":"#define TRACE_STEPS 20\n#define TRACE_RAY\n\nfloat smoothMin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nvec2 squareFrame(vec2 screenSize, vec2 coord) {\n  vec2 position = 2.0 * (coord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\nvec3 drawLine(float d, float thickness) {\n  const float aa = 3.0;\n  return vec3(smoothstep(0.0, aa / iResolution.y, max(0.0, abs(d) - thickness)));\n}\n\nvec3 drawLine(float d) {\n  return drawLine(d, 0.0025);\n}\n\nfloat drawSolid(float d) {\n  return smoothstep(0.0, 3.0 / iResolution.y, max(0.0, d));\n}\n\nvec3 drawPolarity(float d, vec2 p, float t) {\n  p += t * -0.1 * sign(d) * vec2(0, 1);\n  p = mod(p + 0.06125, 0.125) - 0.06125;\n  float s = sign(d) * 0.5 + 0.5;\n  float base = drawSolid(d);\n  float neg = sdfRectangle(p, vec2(0.045, 0.0085) * 0.5);\n  float pos = sdfRectangle(p, vec2(0.0085, 0.045) * 0.5);\n  pos = min(pos, neg);\n  float pol = mix(neg, pos, s);\n\n  float amp = abs(base - drawSolid(pol)) - 0.9 * s;\n\n  return vec3(1.0 - amp);\n}\n\nvec3 drawDistance(float d, vec2 p) {\n  float t = clamp(d * 0.95, 0.0, 1.0);\n  vec3 grad = mix(vec3(1, 0.8, 0.5), vec3(0.3, 0.8, 1), t);\n\n  float d0 = abs(1.0 - drawLine(mod(d + 0.1, 0.2) - 0.1).x);\n  float d1 = abs(1.0 - drawLine(mod(d + 0.025, 0.05) - 0.025).x);\n  float d2 = abs(1.0 - drawLine(d).x);\n  vec3 rim = vec3(max(d2 * 0.85, max(d0 * 0.25, d1 * 0.06125)));\n\n  grad -= rim;\n  grad -= mix(vec3(0.05, 0.35, 0.35), vec3(0.0), drawSolid(d));\n\n  return grad;\n}\n\n\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n  return a + b * cos(6.28318 * (c * mod(t, 1.0) + d));\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n  float t = iTime * 0.5;\n  \n  vec2 uv = squareFrame(iResolution.xy, fragCoord);\n  \n  \n  /*float d = smin\n  (\n      sdfCircle(uv - vec2(cos(t)) * vec2(0.01, 0.05), 0.5), \n      smin\n      (\n          sdfCircle(uv + vec2(sin(t + 1.134543)) * vec2(0.1, 0.05), 0.5), \n          sdfRectangle(uv + vec2(sin(t + 8.1533654)) * vec2(0.05, 0.0), vec2(0.5)),\n      0.1\n      ),\n      0.1\n  );*/\n  float d = smoothMin\n  (\n      smoothMin(\n          sdfCircle(uv - vec2(cos(t)) * vec2(0.01, 0.05), 0.4),\n          sdfCircle(uv - vec2(cos(t + 5.3684654)) * vec2(0.125, 0.01), 0.4),\n          0.1\n      ),\n      sdfCircle(uv + vec2(sin(t + 1.134543)) * vec2(0.1, 0.05), 0.4),\n      0.1\n  );\n  float d2 = expStep(d * 10., 0.98);\n  \n  vec3 col = vec3(drawDistance(d, uv.xy));\n  //col = palette(gain(abs(d * 0.5), 0.5) * 0.5 + t * -0.1, vec3(0.5), vec3(0.5), vec3(1.0), vec3(0.0, 0.33, 0.66));\n  \n  \n  col = palette\n  (\n      d2 + t * 0.1, \n      vec3(0.5), // Brightness\n      vec3(0.5), // Saturation\n      vec3(1.0), \n      vec3(0.0, 0.1, 0.2)\n  );\n\n\n  fragColor.rgb = col;\n  fragColor.a   = 1.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265359;\n\n// SDFs\nfloat sdfCircle(in vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdfEllipse(vec2 p, vec2 ab)\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\nfloat sdQuadraticCircle( in vec2 p )\n{\n    p = abs(p); if( p.y>p.x ) p=p.yx;\n\n    float a = p.x-p.y;\n    float b = p.x+p.y;\n    float c = (2.0*b-1.0)/3.0;\n    float h = a*a + c*c*c;\n    float t;\n    if( h>=0.0 )\n    {   \n        h = sqrt(h);\n        t = sign(h-a)*pow(abs(h-a),1.0/3.0) - pow(h+a,1.0/3.0);\n    }\n    else\n    {   \n        float z = sqrt(-c);\n        float v = acos(a/(c*z))/3.0;\n        t = -z*(cos(v)+sin(v)*1.732050808);\n    }\n    t *= 0.5;\n    vec2 w = vec2(-t,t) + 0.75 - t*t - p;\n    return length(w) * sign( a*a*0.5+b-1.5 );\n}\n\n// y = sin(5x + t) / 5\n// 0 = sin(5x + t) / 5 - y\nfloat sdfSine(vec2 p, float x) {\n  return p.y - sin(p.x * 5.0 + x) * 0.2;\n}\n\nfloat sdfRectangle(vec2 p, vec2 b) {\n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdfLine(vec2 p, vec2 a, vec2 b) {\n  vec2 dir = b - a;\n  return abs(dot(normalize(vec2(dir.y, -dir.x)), a - p));\n}\n\nfloat sdfSegment(vec2 p, vec2 a, vec2 b) {\n  float d = sdfLine(p, a, b);\n  float d0 = dot(p - b, b - a);\n  float d1 = dot(p - a, b - a);\n  return d1 < 0.0 ? length(a - p) : d0 > 0.0 ? length(b - p) : d;\n}\n\nfloat opRound( in float d, in float r )\n{\n  return d - r;\n}\n\nfloat opOnion( in float d, in float r )\n{\n  return abs(d) - r;\n}\n\n// Debug\n\n\n\n// Shaping\n\nfloat gain( float x, float k ) \n{\n    float a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n    return (x<0.5)?a:1.0-a;\n}\n\nfloat parabola( float x, float k )\n{\n    return pow( 4.0*x*(1.0-x), k );\n}\n\nfloat rationalBump( float x, float k )\n{\n    return 1.0/(1.0+k*x*x);\n}\n\nfloat expStep( float x, float n )\n{\n    return exp2( -exp2(n)*pow(x,n) );\n}\n\nfloat trunc_falloff( float x, float m )\n{\n    x /= m;\n    return (x-2.0)*x+1.0;\n}\n\nfloat sinc( float x, float k )\n{\n    float a = PI*(k*x-1.0);\n    return sin(a)/a;\n}\n\nfloat expSustainedImpulse( float x, float f, float k )\n{\n    float s = max(x-f,0.0);\n    return min( x*x/(f*f), 1.0+(2.0/f)*s*exp(-k*s));\n}","name":"Common","description":"","type":"common"}]}