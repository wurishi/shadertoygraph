{"ver":"0.1","info":{"id":"Ws3cD8","date":"1601461860","viewed":443,"name":"Cloud number 9","username":"bitblast","description":"Cloud number 9. In case you wondered what it looks like.\n\nFollow me on twitter: https://twitter.com/rndknd","likes":29,"published":1,"flags":32,"usePreview":0,"tags":["procedural","3d","cloud","volumetric","fog","steam"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 BOUNDS_EXTENTS = vec3(1., 1.56, .5);\n\n// Cloud params\nconst float DENSITY = 9.;\nconst float STEP_SIZE = .051;\nconst float LIGHT_STEP_SIZE = .051;\nconst float NOISE_SCALE = .9;\nconst float FALLOFF = .3;\nconst float ONE_OVER_FALLOFF = 1./FALLOFF;\nconst float ROTATION_FACTOR = .033333333;\nconst float ROTATION_FACTOR_RAD = ROTATION_FACTOR * 6.2831853;\n\n// Light params\nconst vec3 TO_LIGHT = normalize(vec3(.5,.75,-.51));\nconst vec3 LIGHT_COLOR = vec3(.98,1.,.9);\nconst float CLOUD_SCATTER_FACTOR =1.;\n\n \n// Sky params\nconst vec3 SKY_COLOR = .8* vec3(.21,.5,.96);\n\n\nconst mat3 NROT = mat3(0.4119822,  0.0587266,  0.9092974,\n  -0.6812427, -0.6428728,  0.3501755,\n   0.6051273, -0.7637183, -0.2248451);\nconst float deg2rad = 0.0174533;\n\n\nfloat torus(in vec3 p, in vec2 rs)\n{\n    vec2 q = vec2(length(p.xz)-rs.x,p.y);\n  \treturn length(q)-rs.y;\n}\n\nfloat map(in vec3 p, float time)\n{\n    float d = torus(p.xzy - vec3(0.,0.,0.66), vec2(.5, .5));\n    float bof = mix(1.,-1.,gain8(1.-abs(fract(ROTATION_FACTOR*time)-.5)*2.));\n    d = min(d,xyPlaneLine(p, vec2(0.,-1.06), vec2(bof*0.4784,.514651))-.5);\n    return d;\n}\n\nfloat noise(in vec3 p)\n{\n    p = fract(p);\n    float blend;\n    vec2 uv = three2two(p, iResolution.xy, blend);\n    vec2 smpl = texture(iChannel0,uv).xy;\n    return mix(smpl.x,smpl.y,blend);\n}\n\n\nfloat density(in vec3 p, in float time, in float dist)\n{\n    p = NROT*p;\n    float ang = ROTATION_FACTOR_RAD * time;\n    p += .8*vec3(cos(ang), 0.,sin(ang));\n    float noi = noise(p*NOISE_SCALE);\n    noi -= clamp(1.+dist*ONE_OVER_FALLOFF,0.,1.);\n    return clamp(noi, 0., 1.) * DENSITY;\n}\n\n\nfloat ltrace(in vec3 sta, in vec3 dir, in float time)\n{\n    float end = boxIntersection(sta, dir, BOUNDS_EXTENTS).y;\n    if (end <= 0.)\n        return 1.;\n    float trans = 1.;\n    float t = LIGHT_STEP_SIZE*.5;\n    for (int i = 0; i < 100; ++i)\n    //while (trans >= .01 && t < end)\n        \n    {\n        vec3 p = sta + t * dir;\n        float d = map(p, time);\n        if (d < 0.)\n        \ttrans *= exp(-density(p, time, d) * LIGHT_STEP_SIZE);\n        t += LIGHT_STEP_SIZE;\n       \tif (trans <= .02 || t >= end)\n            return trans;\n        \n    }\n    return trans;\n}\n\n\nvec4 trace(in vec3 sta, in vec3 dir, in vec3 light, in float time)\n{\n    vec2 dists = boxIntersection(sta, dir, BOUNDS_EXTENTS);\n    if (dists.y <= 0.)\n        return vec4(0.,0.,0.,0.);\n    float trans = 1.;\n    vec3 col = vec3(0.);\n    float t = max(dists.x, 0.);\n    for (int i = 0; i < 100; ++i)\n    //while (t < dists.y && trans >= .02)\n    {\n        vec3 p = sta + t * dir;\n        float d = map(p, time);\n        if (d > .001)\n            t += max(STEP_SIZE, d);\n        else\n        {\n            float den = d >=  0. ? 0. : density(p, time, d);\n            if (den > 0.05)\n            {\n                den *= STEP_SIZE;\n        \t\tcol += CLOUD_SCATTER_FACTOR * den * trans * ltrace(p, light, time) * LIGHT_COLOR;\n        \t\ttrans *= exp(-den);\n            }\n            t += STEP_SIZE;\n\t\t}\n        if (t >= dists.y || trans <= .02)\n            break;\n    }\n    return vec4(col, 1.-trans);\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 st = uv - .5;\n    float aspect = iResolution.x/iResolution.y;\n    st.x *= aspect;\n    float time = iTime;\n    \n    // Camera\n    vec3 dir = normalize(vec3(st, 3.732050)); // 30 deg vfov\n    vec3 cam = vec3(0.,0.05,-12.);\n    float ang = ROTATION_FACTOR_RAD*time;\n    float sn = sin(ang), cs = cos(ang);\n    vec3 light = TO_LIGHT;\n    mat2 lrot = mat2(cs, -sn, sn, cs);\n    light.xz = lrot * light.xz;\n    float sn2=-.5, cs2 =0.866025; // 30 deg tilt\n    mat3 mat = mat3(cs,0.,-sn,-sn2*sn,cs2,-cs*sn2,sn*cs2,sn2,cs*cs2);\n    dir = mat * dir;\n    cam = mat * cam;\n    /*cam.xz = lrot * cam.xz;\n    dir.xz = lrot * dir.xz;*/\n    \n    // Trace\n    vec4 clo = trace(cam, dir, light, time);\n    vec3 col = mix(vec3(1.),SKY_COLOR,.8+.2*(1.-(1.-uv.y)*(1.-uv.y)));\n    col = clo.xyz + (1.-clo.w) * col;\n    \n    // Post\n    col = vec3(pow(col.x, .45), pow(col.y, .45), pow(col.z, .45));\n    col = col*col*(3.-2.*col);\n    col *= 1.-.27*dot(st,st);\n    col += sin(2342.*uv.x+139.*uv.y)*0.00196078;//dither\n    \n    \n    //vec3 col=texture(iChannel0, uv).xxx;\n    //col=vec3(-map(vec3(4.*st,0.),time));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float saturate(in float f) { return clamp(f, 0.,1.); }\nvec2 saturate(in vec2 f) { return clamp(f, 0.,1.); }\nvec3 saturate(in vec3 f) { return clamp(f, 0.,1.); }\nvec4 saturate(in vec4 f) { return clamp(f, 0.,1.); }\nfloat unmix(in float a, in float b, in float t) { return (t-a)/(b-a); }\nvec2 unmix(in vec2 a, in vec2 b, in vec2 t) { return (t-a)/(b-a); }\nvec3 unmix(in vec3 a, in vec3 b, in vec3 t) { return (t-a)/(b-a); }\nvec4 unmix(in vec4 a, in vec4 b, in vec4 t) { return (t-a)/(b-a); }\n\n// axis aligned box centered at the origin, with size boxSize\nvec2 boxIntersection( in vec3 ro,in  vec3 rd, in vec3 boxSize ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    return vec2( tN, tF );\n}\n\nfloat mrand (vec3 v) {\n    return fract(sin(dot(v,\n                         vec3(12.9898,78.233,23.42345)))*43758.5453123);\n}\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat gain(float x, float k) \n{\n    float a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n    return (x<0.5)?a:1.0-a;\n}\nfloat gain4(float x) \n{\n    float pw = 2.0*((x<0.5)?x:1.0-x);\n    pw*=pw;// 2\n    pw*=pw;// 4\n    float a = 0.5*pw;\n    return (x<0.5)?a:1.0-a;\n}\nfloat gain8(float x) \n{\n    float pw = 2.0*((x<0.5)?x:1.0-x);\n    pw*=pw;// 2\n    pw*=pw;// 4\n    pw*=pw;// 8\n    float a = 0.5*pw;\n    return (x<0.5)?a:1.0-a;\n}\nfloat xyPlaneLine(vec3 point, vec2 from, vec2 to)\n{\n    vec2 del = to-from;\n    float len = length(del);\n    vec2 ndl = (1./len)*del;\n    float dt = dot(point.xy - from,ndl);\n    return length(point-vec3(from+clamp(dt,0.,len)*ndl,0.));\n}\n\nfloat remap1(in float fa, in float fb, in float ta, in float tb, in float t)\n{\n    return mix(ta, tb, (t - fa) / (fa - fb));\n}\n\nvec2 remap2(in vec2 fa, in vec2 fb, in vec2 ta, in vec2 tb, in vec2 t)\n{\n    return mix(ta, tb, (t - fa) / (fa - fb));\n}\n\nvec2 unmix2(in vec2 a, in vec2 b, in vec2 t)\n{\n    return (t-a)/(b-a);\n}\n\n\nfloat mnoise (in vec3 p, in float repeat) {\n    float mn = 99999.;\n    vec3 bas = floor(p), cur, off;\n    \n    cur = bas + vec3(-1., -1., -1.); off = cur + mrand(mod(cur, repeat)) - p; mn = min(mn, dot(off, off));\n    cur = bas + vec3(-1., -1.,  0.); off = cur + mrand(mod(cur, repeat)) - p; mn = min(mn, dot(off, off));\n    cur = bas + vec3(-1., -1.,  1.); off = cur + mrand(mod(cur, repeat)) - p; mn = min(mn, dot(off, off));\n    cur = bas + vec3(-1.,  0., -1.); off = cur + mrand(mod(cur, repeat)) - p; mn = min(mn, dot(off, off));\n    cur = bas + vec3(-1.,  0.,  0.); off = cur + mrand(mod(cur, repeat)) - p; mn = min(mn, dot(off, off));\n    cur = bas + vec3(-1.,  0.,  1.); off = cur + mrand(mod(cur, repeat)) - p; mn = min(mn, dot(off, off));\n    cur = bas + vec3(-1.,  1., -1.); off = cur + mrand(mod(cur, repeat)) - p; mn = min(mn, dot(off, off));\n    cur = bas + vec3(-1.,  1.,  0.); off = cur + mrand(mod(cur, repeat)) - p; mn = min(mn, dot(off, off));\n    cur = bas + vec3(-1.,  1.,  1.); off = cur + mrand(mod(cur, repeat)) - p; mn = min(mn, dot(off, off));\n    cur = bas + vec3( 0., -1., -1.); off = cur + mrand(mod(cur, repeat)) - p; mn = min(mn, dot(off, off));\n    cur = bas + vec3( 0., -1.,  0.); off = cur + mrand(mod(cur, repeat)) - p; mn = min(mn, dot(off, off));\n    cur = bas + vec3( 0., -1.,  1.); off = cur + mrand(mod(cur, repeat)) - p; mn = min(mn, dot(off, off));\n    cur = bas + vec3( 0.,  0., -1.); off = cur + mrand(mod(cur, repeat)) - p; mn = min(mn, dot(off, off));\n    cur = bas + vec3( 0.,  0.,  0.); off = cur + mrand(mod(cur, repeat)) - p; mn = min(mn, dot(off, off));\n    cur = bas + vec3( 0.,  0.,  1.); off = cur + mrand(mod(cur, repeat)) - p; mn = min(mn, dot(off, off));\n    cur = bas + vec3( 0.,  1., -1.); off = cur + mrand(mod(cur, repeat)) - p; mn = min(mn, dot(off, off));\n    cur = bas + vec3( 0.,  1.,  0.); off = cur + mrand(mod(cur, repeat)) - p; mn = min(mn, dot(off, off));\n    cur = bas + vec3( 0.,  1.,  1.); off = cur + mrand(mod(cur, repeat)) - p; mn = min(mn, dot(off, off));\n    cur = bas + vec3( 1., -1., -1.); off = cur + mrand(mod(cur, repeat)) - p; mn = min(mn, dot(off, off));\n    cur = bas + vec3( 1., -1.,  0.); off = cur + mrand(mod(cur, repeat)) - p; mn = min(mn, dot(off, off));\n    cur = bas + vec3( 1., -1.,  1.); off = cur + mrand(mod(cur, repeat)) - p; mn = min(mn, dot(off, off));\n    cur = bas + vec3( 1.,  0., -1.); off = cur + mrand(mod(cur, repeat)) - p; mn = min(mn, dot(off, off));\n    cur = bas + vec3( 1.,  0.,  0.); off = cur + mrand(mod(cur, repeat)) - p; mn = min(mn, dot(off, off));\n    cur = bas + vec3( 1.,  0.,  1.); off = cur + mrand(mod(cur, repeat)) - p; mn = min(mn, dot(off, off));\n    cur = bas + vec3( 1.,  1., -1.); off = cur + mrand(mod(cur, repeat)) - p; mn = min(mn, dot(off, off));\n    cur = bas + vec3( 1.,  1.,  0.); off = cur + mrand(mod(cur, repeat)) - p; mn = min(mn, dot(off, off));\n    cur = bas + vec3( 1.,  1.,  1.); off = cur + mrand(mod(cur, repeat)) - p; mn = min(mn, dot(off, off));\n    \n    return clamp(1.-.707701*sqrt(mn),0.,1.);\n}\n\nfloat fbm(in vec3 p, in float repeat, in float scale) {\n\tfloat noi = .5  * mnoise(p * 1.00 * scale, scale)\n             + .31 * mnoise(p * 2.00 * scale, 2.0 * scale)\n             + .21 * mnoise(p * 4.00 * scale, 4.0 * scale);\n    noi /= 1.02;\n    return noi;    \n}\n\n\nvec3 two2three(in vec2 uv, in vec2 res)\n{\n    vec2 rr = 8.*floor(res*.125);\n    uv *= res/rr;\n    float z = .125*floor(uv.y*8.)+0.015625*floor(uv.x*8.);\n    vec2 hp = 4./rr;\n    vec2 xy = unmix(hp, 1.-hp,fract(uv*8.));\n    return vec3(xy, z);\n}\nvec2 three2two(in vec3 p, in vec2 res, out float partialZ)\n{\n    float z64 = p.z*64.;\n    partialZ = fract(z64);\n    float enc = floor(z64)*.125;\n    vec2 ints = vec2(fract(enc),.125*floor(enc));    \n    vec2 rr = 8.*floor(res*.125);\n    vec2 ehp = .5/rr;\n    return (rr/res)*(ints+mix(ehp,.125-ehp,p.xy));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float NOISE_SCALE = 3.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 pre = texture(iChannel0, uv);\n    if (pre.w >= 0. && any(greaterThan(abs(iResolution.xy-pre.zw)*iResolution.xy, vec2(.7))))\n    {\n        // Res change;\n        pre = vec2(0.,-two2three(uv, iResolution.xy).z).xxxy; // We use w to time the reset\n    }\n    \n    if (pre.w > 0.5) // Already initialized\n    {\n        fragColor = pre;\n        return;\n    }\n    \n    pre.w -= 69./64.;\n    \n    if (pre.w <= -1.)\n    {\n        vec3 p = two2three(uv, iResolution.xy);\n        float noil = fbm(p, NOISE_SCALE, NOISE_SCALE);\n        vec3 q = p;\n        q.z = fract(q.z + 0.015625);\n        float noih = fbm(q, NOISE_SCALE, NOISE_SCALE);\n    \tfragColor = vec4(noil,noih,iResolution.xy);\n    }\n    else\n        fragColor = vec4(pre.xyzw);\n}","name":"Buffer A","description":"","type":"buffer"}]}