{"ver":"0.1","info":{"id":"XclfWn","date":"1723607017","viewed":36,"name":"atrous guided filtering","username":"Zentient","description":"WIP guided filtering for separable atrous wavelets (non separable atrous implemented here)\nHave a feeling there's a few issues with the current implementation (calculating A/B per pass?), I'll end up reading the paper in more detail. \n","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["processing","denoising","nonaverage"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RES (iResolution.xy)\nvec4 GuidedFilter( vec2 xy, float mip, sampler2D P , sampler2D I)\n{\n    vec4 meanI;\n    vec4 meanP;\n    vec4 corrI;\n    vec4 corrP;\n\n    vec4 cenI = texture(I, xy);\n    float w;\n\n    for(int i = -1; i <= 1; i++) for(int ii = -1; ii <= 1; ii++)\n    {\n        vec2 offset = exp2(mip) * vec2(i, ii) / RES;\n        vec4 tcolI = texture(I, xy + offset);  \n        vec4 tcolP = texture(P, xy + offset);\n        \n        meanI += tcolI;\n        meanP += tcolP;\n        corrI += tcolI*tcolI;\n        corrP += tcolI*tcolP;\n        \n        w++;\n    }\n    \n    meanI /= w;\n    meanP /= w;\n    corrI /= w;\n    corrP /= w;\n    \n    vec4 varI = corrI - meanI * meanI;\n    vec4 covP = corrP - meanI * meanP;\n    \n    vec4 a = covP / (varI + 0.001);\n    vec4 b = meanP - a * meanI;\n    \n    return a * cenI + b;\n}\n\nvoid mainImage( out vec4 col, in vec2 vpos )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = vpos / RES;\n\n    col = GuidedFilter( uv, 3.0, iChannel0, iChannel1);\n    if(uv.x < 0.5) col = texture(iChannel2, uv);\n    \n    col.rgb = pow(ACESFilm(col.rgb), vec3(1.0 / 2.2) );\n    //col.rgb = pow(col.rgb, vec3(1.0 / 2.2));\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define RES (iResolution.xy)\nvec4 GuidedFilter( vec2 xy, float mip, sampler2D P , sampler2D I)\n{\n    vec4 meanI;\n    vec4 meanP;\n    vec4 corrI;\n    vec4 corrP;\n\n    vec4 cenI = texture(I, xy);\n    float w;\n\n    for(int i = -1; i <= 1; i++) for(int ii = -1; ii <= 1; ii++)\n    {\n        vec2 offset = exp2(mip) * vec2(i, ii) / RES;\n        vec4 tcolI = texture(I, xy + offset);\n        vec4 tcolP = pow(texture(P, xy + offset), vec4(2.2));\n        \n        meanI += tcolI;\n        meanP += tcolP;\n        corrI += tcolI*tcolI;\n        corrP += tcolI*tcolP;\n        \n        w++;\n    }\n    \n    meanI /= w;\n    meanP /= w;\n    corrI /= w;\n    corrP /= w;\n    \n    vec4 varI = corrI - meanI * meanI;\n    vec4 covP = corrP - meanI * meanP;\n    \n    vec4 a = covP / (varI + E);\n    vec4 b = meanP - a * meanI;\n    \n    return a * cenI + b;\n}\n\nvoid mainImage( out vec4 col, in vec2 vpos )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = vpos / RES;\n    //col = pow(texture(iChannel0, uv), vec4(2.2) );\n    col.r = 1.0 / pow(0.5 * distance( mod(RES * uv, BLOCK), vec2(0.5 * BLOCK) ) + 0.1, 2.0);//GuidedFilter(uv, 0.0, iChannel0, iChannel1);\n    col.g = 1.0 / pow(0.4 * distance( mod(RES * uv, BLOCK), vec2(0.5 * BLOCK) ) + 0.1, 2.0);\n    col.b = 1.0 / pow(0.3 * distance( mod(RES * uv, BLOCK), vec2(0.5 * BLOCK) ) + 0.1, 2.0);\n    //col = round(col + 0.3);\n    //col = col / (col + 1.0);\n    col *= 0.25 + 0.75 * col;\n    \n    if(DENOISE == 1) {\n        col = pow(texture(iChannel1, uv), vec4(2.2));\n        col = -col / (col - 1.6);\n    }\n    //col = pow(texture(iChannel0, uv), vec4(2.2) ) * (0.5 + 0.5 * hash12( uv * RES ));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define RES (iResolution.xy)\nvec4 GuidedFilter( vec2 xy, float mip, sampler2D P , sampler2D I)\n{\n    vec4 meanI;\n    vec4 meanP;\n    vec4 corrI;\n    vec4 corrP;\n\n    vec4 cenI = texture(I, xy);\n    float w;\n\n    for(int i = -1; i <= 1; i++) for(int ii = -1; ii <= 1; ii++)\n    {\n        vec2 offset = exp2(mip) * vec2(i, ii) / RES;\n        vec4 tcolI = texture(I, xy + offset);\n        vec4 tcolP = texture(P, xy + offset);\n        \n        meanI += tcolI;\n        meanP += tcolP;\n        corrI += tcolI*tcolI;\n        corrP += tcolI*tcolP;\n        \n        w++;\n    }\n    \n    meanI /= w;\n    meanP /= w;\n    corrI /= w;\n    corrP /= w;\n    \n    vec4 varI = corrI - meanI * meanI;\n    vec4 covP = corrP - meanI * meanP;\n    \n    vec4 a = covP / (varI + E);\n    vec4 b = meanP - a * meanI;\n    \n    return a * cenI + b;\n}\n\nvoid mainImage( out vec4 col, in vec2 vpos )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = vpos / RES;\n\n    col = GuidedFilter( uv, 0.0, iChannel0, iChannel1);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define E 0.002\n#define BLOCK 34.0\n\n//Alternate view\n#define DENOISE 0\n//#define DENOISE 1\n\n\n//( (0.5 + 0.5 * sin(iTime)) / 100.0)\n\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\nreturn clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define RES (iResolution.xy)\nvec4 GuidedFilter( vec2 xy, float mip, sampler2D P , sampler2D I)\n{\n    vec4 meanI;\n    vec4 meanP;\n    vec4 corrI;\n    vec4 corrP;\n\n    vec4 cenI = texture(I, xy);\n    float w;\n\n    for(int i = -1; i <= 1; i++) for(int ii = -1; ii <= 1; ii++)\n    {\n        vec2 offset = exp2(mip) * vec2(i, ii) / RES;\n        vec4 tcolI = texture(I, xy + offset);  \n        vec4 tcolP = texture(P, xy + offset);\n        \n        meanI += tcolI;\n        meanP += tcolP;\n        corrI += tcolI*tcolI;\n        corrP += tcolI*tcolP;\n        \n        w++;\n    }\n    \n    meanI /= w;\n    meanP /= w;\n    corrI /= w;\n    corrP /= w;\n    \n    vec4 varI = corrI - meanI * meanI;\n    vec4 covP = corrP - meanI * meanP;\n    \n    vec4 a = covP / (varI + E);\n    vec4 b = meanP - a * meanI;\n    \n    return a * cenI + b;\n}\n\nvoid mainImage( out vec4 col, in vec2 vpos )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = vpos / RES;\n\n    col = GuidedFilter( uv, 1.0, iChannel0, iChannel1);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"#define RES (iResolution.xy)\nvec4 GuidedFilter( vec2 xy, float mip, sampler2D P , sampler2D I)\n{\n    vec4 meanI;\n    vec4 meanP;\n    vec4 corrI;\n    vec4 corrP;\n\n    vec4 cenI = texture(I, xy);\n    float w;\n\n    for(int i = -1; i <= 1; i++) for(int ii = -1; ii <= 1; ii++)\n    {\n        vec2 offset = exp2(mip) * vec2(i, ii) / RES;\n        vec4 tcolI = texture(I, xy + offset);\n        vec4 tcolP = texture(P, xy + offset);\n        \n        meanI += tcolI;\n        meanP += tcolP;\n        corrI += tcolI*tcolI;\n        corrP += tcolI*tcolP;\n        \n        w++;\n    }\n    \n    meanI /= w;\n    meanP /= w;\n    corrI /= w;\n    corrP /= w;\n    \n    vec4 varI = corrI - meanI * meanI;\n    vec4 covP = corrP - meanI * meanP;\n    \n    vec4 a = covP / (varI + E);\n    vec4 b = meanP - a * meanI;\n    \n    return a * cenI + b;\n}\n\nvoid mainImage( out vec4 col, in vec2 vpos )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = vpos / RES;\n\n    col = GuidedFilter( uv, 2.0, iChannel0, iChannel1);\n}","name":"Buffer D","description":"","type":"buffer"}]}