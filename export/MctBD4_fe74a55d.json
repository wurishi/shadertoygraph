{"ver":"0.1","info":{"id":"MctBD4","date":"1733144492","viewed":42,"name":"Fractale monderot mathematique","username":"dbelhassen9","description":"Fractale Maths projet","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["abcde"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0; // On divise les coordonnes du pixel par la taille de l'ecran, et on les transforme pour avoir des pixel negatifs, qui sera utile dans la boucle apres\n    uv.x *= iResolution.x / iResolution.y; // rapport entre la hauteur et la largeur, pour ne pas que l'image soit etiré\n\n    vec2 c = uv; // constante complexe\n    vec2 z = vec2(0.0); // Point complexe inialise a 0.0 (au milieu du tableau)\n    int count = 0;\n    int maxIterations = 100; // On limite a 100 sinon mon pc va dead ca\n\n    for (int i = 0; i < maxIterations; i++) { // Boucle qui permet de tracé monderot\n        z = vec2(\n            z.x * z.x - z.y * z.y + c.x, // calcul partit reel + constante complexe\n            2.0 * z.x * z.y + c.y // calcul partit imaginaire + constante complexe \n        );\n\n        if (length(z) > 2.0) break; // Si depasse le tableau (2.0), on s'arrete\n        count++; // sinon on continue jusqu'a maxIterations\n    }\n\n    if (count == maxIterations) {\n        fragColor = texture(iChannel0, uv * 0.5 + 0.5); // Affichage de la premiere image avec la noramlisation comme au debut\n    } else {\n        fragColor = texture(iChannel1, uv * 0.5 + 0.5); // Affichage de la deuxieme image avec la normalisation du debut\n    }\n}\n","name":"Image","description":"","type":"image"}]}