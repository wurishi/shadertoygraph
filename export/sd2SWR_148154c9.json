{"ver":"0.1","info":{"id":"sd2SWR","date":"1620078443","viewed":166,"name":"mormalize using langth  (vlllll)","username":"valalalalala","description":"This shader demonstrates 2d and 3d length approximations. The left column is the glsl length and the right the approximations. The center column shows the same mechanism with different parameters to create interesting solids. Details in the code comments.","likes":9,"published":1,"flags":16,"usePreview":0,"tags":["raymarching","approximation","length"],"hasliked":0,"parentid":"NdjXzR","parentname":"mormalize (vlllll)"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///////////////////////////////////////////////////////////////////////////\n//\n// For a lot of people, Momo the Monster was really, really, slow.\n// (https://www.shadertoy.com/view/sdXGWs)\n//\n// So I used the old school optimization trick of unrolling loops.\n// (https://www.shadertoy.com/view/fdS3WK)\n//\n// This helped some, but the performance was still not where I wanted it\n// to be.\n//\n// Looking at FABRIK, it's mosty a lot of calls to distance, length and\n// normalize, which can be expensive.\n// \n// What to do??\n//\n// A quick search turned up Rafael Baptista's\n// \"Fast Approximate Distance Functions\" for 2d\n// (https://flipcode.com/archives/Fast_Approximate_Distance_Functions.shtml)\n//\n// his code can be translated to something like:\n//\n//     p = abs( p );\n//     dot( vec2( min( p ), max( p ), vec2( .423, .987 ) );\n//\n// it makes a lot of sense as a way to approximate distances when you \n// think of the Manhattan disance as dot( p, vec2( 1. ) );\n//\n// To extend this to 3d, I order p so that x contains the min value,\n// y contains the middle value, and z contains the max value.\n//\n// I wrote a nasty bit of brute force and found a triplet of values that\n// work pretty well for 3d and found that various values produced stars\n// and other interesting shapes.\n// (code link pending cleanup)\n//\n// My length approximation for 3d is currently: \n//\n//     dot( order( abs( p ) ), vec3( .2, .4, .9 ) ).\n//\n// In this demo, you can see the true length in the left hand (red) column.\n//\n// The middle column (green) shows alernative shapes created by varying\n// the 2nd vector in the \"langth\" function over time.\n//\n// Finally on the right column (blue) shows the shapes generated using this\n// \"langth\" approxation using the magic numbers.\n//\n// The top row is a sphere, the middle row is a circle, and the bottom row\n// is a torus.\n//\n// The red, green and blue values indicated the xyz values of the current\n// vector used for the dynamic length reflected in the numeric values.\n//\n// Pressing the space key will toggle the scene to use a normalize based\n// on use either the real length function of my \"langth\" approximation.\n//\n// The scene can be rotated with the mouse.\n//\n// All in all, I think this is a pretty good and simple way to approximate\n// length without taking any square roots.\n//\n// It has the side benefit of being a very cheap way to generate some \n// interesting solids.\n//\n// Though ultimately, I'm not sure it is actually a performance gain.\n// Perhaps a more efficient \"order\" function is possible... \n//\n// Feedback welcome.\n//\n///////////////////////////////////////////////////////////////////////////\n//\n// CC0 1.0 Universal\n// https://creativecommons.org/publicdomain/zero/1.0\n//\n// by Val \"valalalalala\" GvM ðŸ’ƒ 2021\n//\n///////////////////////////////////////////////////////////////////////////\n\n// change the rate of change\n\n#define SPEED .01 * .77;\n\n// you can specify a value for the center column by changing this define \n// to be OVERRIDE instead of OVERRIDE_N\n\n#define OVERRIDE_1 vec3( .2, .5, .8 );\n#define OVERRIDE_2 vec3( .6, .7, .2 );\n\n// uncomment this to just use the built-in length everywhere... \n// to see just how gray life can be\n//#define SO_THEN___\n\n///////////////////////////////////////////////////////////////////////////\n// this toggle is controlled by the space key\nbool MORMALIZE_THIS;\n\n// this will return an ordered vector where\n// x contains the min value\n// y contains the middle value\n// z contains the max value\nvec3 order( vec3 p )  {\n    // try this... actually, this is just like cuteSort.... oh, well...\n    vec3 q = vec3( min( p.x, min( p.y, p.z ) ), .0, max( p.x, max( p.y, p.z ) ) );\n    q.y = ( p.x + p.y + p.z ) - ( q.x + q.z );\n    return q;  \n    // from https://www.shadertoy.com/view/XtVcDh , thanks Gaktan\n    // return sort3bk( p ); // this worked for me, sort3bk_cj( p ) produced artifacts\n}\n\n// this will return an ordered vector where\n// x contains the min value\n// y contains the max value\nvec2 order( vec2 p ) {\n    return vec2( min( p.x, p.y ), max( p.x, p.y ) );\n}\n\n// calculate and approximation of length using the \n// dot product of the ordered version of p and the \n// input vector q\nfloat langth( vec3 p, vec3 q ) {\n#ifdef SO_THEN___\n    return length( p );\n#endif\n    return dot( order( abs( p ) ), q );\n}\n\n// calculate and approximation of length using the \n// dot product of the ordered version of p and the \n// input vector q\nfloat langth( vec2 p, vec2 q ) {\n#ifdef SO_THEN___\n    return length( p );\n#endif\n    return dot( order( abs( p ) ), q );\n}\n\n// return a \"pretty good\" approximation of the length of p\nfloat langth( vec3 p ) {\n    return langth( p, vec3(  .2, .4, .9 ) );\n}\n\n// return a \"pretty good\" approximation of the length of p\nfloat langth( vec2 p ) {\n    return langth( p,  vec2( .423, .987 ) );\n    // derived from \n    // https://flipcode.com/archives/Fast_Approximate_Distance_Functions.shtml\n}\n\n// a bit like fract, but scale the value and clamp it\nfloat fruct( float t, float scale ) {\n    return clamp( fract( t * scale ), .27, 1. );\n}\n\n// return a vector whose components vary over time\nvec3 timely() {\n#ifdef OVERRIDE\n    return OVERRIDE;\n#endif\n    float t = iTime * SPEED;\n    return vec3( fract( t ), fruct( t, 10. ), fruct( t, 100. ) );\n}\n\n// return a crazy approximation of the length of p \n// using a variety (if not all) q values\nfloat lungth( vec3 p ) {\n    return langth( p, timely() );\n}\n\n// return a crazy approximation of the length of p \n// using a variety (if not all) q values\nfloat lungth( vec2 p ) {\n    return langth( p, timely().yz );\n}\n\n// space key toggles the real version of normal\n// or the version that use the langth approximation\n// method\nvec3 mormalize( vec3 p ) {\n    if ( MORMALIZE_THIS ) {\n        return p / langth( p ); // changing this to \"lungth\" is pretty weird\n    }\n    return p / length( p );\n}\n\n///////////////////////////////////////////////////////////////////////////\n// https://iquilezles.org/articles/distfunctions\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// modified to use langth approximation of length\nfloat sdTarus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return langth(q)-t.y;\n}\n\n// modified to use lungth approximation of length\nfloat sdTurus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return lungth(q)-t.y;\n}\n\n///////////////////////////////////////////////////////////////////////////\n// scene definition\n\nfloat map( vec3 p ) {\n    float d = 1e33;\n    \n    float r =.5;\n    float f = 1.33;\n    vec3 o = vec3( f, -f, .0 );\n    \n    vec3 x = vec3( iResolution.x / iResolution.y, 1., 1. );\n    \n    // top row\n    d = min( d, length( p - o.yxz * x ) - r  );\n    d = min( d, ( lungth( p - o.zxz * x ) - r * .5 ) *.8 );\n    d = min( d, langth( p - o.xxz * x ) - r  );\n    \n    // bottom row\n    r *= .8;\n    float i = r * .3;\n    p = p.xzy;\n    d = min( d, sdTorus( p - o.yzy * x, vec2( r, i ) )  );\n    d = min( d, sdTurus( p - o.zzy * x, vec2( r, i ) )  );\n    d = min( d, sdTarus( p - o.xzy * x, vec2( r, i ) )  );\n    \n    return d;\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nvec3 colorHit( vec3 eye, vec3 direction, float d ) {\n    vec3 p = eye + direction * d;\n    vec3 n = mapNormal( p, d );\n    vec3 color = vec3( .8 );\n    \n    // based on https://www.shadertoy.com/view/ttGfz1\n    vec3 q = sin(n*2.)*.5+.5;\n    float light = dot( q, q ) / 3.;\n    return sqrt( light * color );\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nvec3 circle( float d, float r, float s, vec3 color ) {\n    float t = .01;\n    return 1.2 * (\n        + smoothstep( r, r - t * 1., d )\n        - smoothstep( r, r - t * s, d )\n    ) * color;\n}\n\nvec3 circle( float d, float r, vec3 color ) {\n    return circle( d, r, 2.3, color );\n}\n\n// the 2d version (circles) are shown here\nvec3 colorMiss( in vec2 uv ) {\n    if ( uv.y <-.99 ) {\n        return MORMALIZE_THIS ? vec3(1.) :vec3(0.);\n    }\n\n    vec3 color = timely();\n    if ( uv.x < -.6 ) color.yz *= .0; else\n    if ( uv.x > +.6 ) color.xy *= .0; else\n    color.xz *= .0;\n    \n    \n    float radius = .3;\n    float radiuz = .02 + radius;\n    \n    float f = 1.2;\n    vec3 offset = vec3( f, -f, .0 );\n    \n    float q = .5;\n    \n    vec3 t = timely(); \n    color = digitIn( color, uv - offset.yz * 1.2, 77., t.x ); \n    color = digitIn( color, uv - offset.yz * .22, 77., t.y ); \n    color = digitIn( color, uv - offset.xz * .77, 77., t.z ); \n    \n    color -= circle( length( uv - offset.yz ), radiuz, WHITE  );\n    color -= circle( lungth( uv - offset.zz ), radiuz * q, WHITE  );\n    color -= circle( langth( uv - offset.xz ), radiuz, WHITE  );\n    \n    color += circle( length( uv - offset.yz ), radius, WHITE  );\n    color += circle( lungth( uv - offset.zz ), radius * q, WHITE  );\n    color += circle( langth( uv - offset.xz ), radius, WHITE  );\n\n    return color;\n}\n\n///////////////////////////////////////////////////////////////////////////\n// io stuff\n\n// from https://www.shadertoy.com/view/4dsGRl\nbool readKey( in int key, in bool toggle ) {\n    float keyVal = textureLod( iChannel0, vec2( (float(key)+.5)/256.0, toggle?.75:.25), 0.0 ).x;\n\treturn ( keyVal>.5 );\n}\n\nbool readKey( in int key ) {\n    return readKey( key, true );\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    MORMALIZE_THIS = !readKey( 32 );\n    fragColor = boilerPlateMain( fragCoord, iMouse, iResolution, iTime );\n}\n\n// EOF\n///////////////////////////////////////////////////////////////////////////","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/////////////////////////////////////////////////////////////////////////////\n// undefine this to disable anti aliasing \n#define AA\n\n/////////////////////////////////////////////////////////////////////////////\n// cool hack for forward declarations https://www.shadertoy.com/view/WldSRj\n#ifndef HW_PERFORMANCE\n#define _SHADERTOY_TAB_COMMON\n#endif\n\n#define normalize(x) mormalize((x))\n\nvec3 mormalize( vec3 p );\n#ifdef _SHADERTOY_TAB_COMMON\nvec3 mormalize( vec3 p ) { return p; }\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// camera settings\n\n#define CAMERA_DISTANCE 4.\n#define CAMERA_ZOOM     2.\n\n/////////////////////////////////////////////////////////////////////////////\n// try to hide the boilerplate a little\n\n/////////////////////////////////////////////////////////////////////////////\n// handy constants\n\nconst float ZED = .0;\nconst float PI  = 3.141592653589793;\nconst float TAU = 6.283185307179586;\n\nconst vec3 WHITE  = vec3( 1. );\n\n/////////////////////////////////////////////////////////////////////////////\n// ray marching\n\nconst vec3 MARCH = vec3( .0, .0001, 88. );\n\nfloat map( vec3 p );\n#ifdef _SHADERTOY_TAB_COMMON\nfloat map( vec3 p ) { return 33.44; }\n#endif\n\nfloat march( vec3 eye, vec3 direction ) { \n    float total = .0, now;\n    vec3 current = eye;\n    for( int i = 0 ; i < int( MARCH.z ) ; i++ ) {\n        total += ( now = map( current ) );\n        if ( abs( now ) < MARCH.y || total > MARCH.z ) break;\n        current += now * direction;\n    }\n    return total + MARCH.z * step( MARCH.z, total );\n}\n\n// https://suricrasia.online/demoscene/functions/\nvec3 mapNormal(vec3 p,float d) {\n    mat3 k = mat3(p,p,p) - mat3(MARCH.y*d);\n    return normalize(map(p) - vec3(map(k[0]),map(k[1]),map(k[2])) );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// miscellanous mess\n\n#define FROM_SCREEN(uv,R)  ( ( 2. * (uv) - (R).xy ) / (R).y )\n\nvec2 trig( float a ) {\n    return vec2( cos( a  * TAU ), sin( a * TAU ) );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// basic camera controls\n\n// zab,xZup,yXz | zxy:ab,zup,xz\nmat3 makeCamera( vec3 a, vec3 b, float roll ) {\n    vec3 up = vec3( trig( roll ).yx, ZED );\n\tvec3 z = normalize( b - a );\n\tvec3 x = normalize( cross( z, up ) );\n\tvec3 y = normalize( cross( x, z ) );\n\treturn mat3( x, y, z );\n}\n\nvec3 cameraEye( float viewDistance, vec4 mouse, vec3 resolution, float time ) {\n    bool mouseDown = mouse.z > -.0;\n    if ( !mouseDown ) {\n         mouse.xy = .5 * resolution.xy;\n    }\n    vec2 ms = FROM_SCREEN( mouse.xy, resolution ) *.14;\n    vec2 t = viewDistance * trig( ms.x );\n    return vec3( t.y,  viewDistance * sin( ms.y * TAU ), t.x );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// from https://www.shadertoy.com/view/WtGyWD\n\nconst int CHARACTERS[14] = int[14](31599,9362,31183,31207,23524,29671,29679,30994,31727,31719,1488,448,2,3640);\n\nfloat digitIsOn( int digit, vec2 id ) {   \n    if ( id.x < .0 || id.y < .0 || id.x > 2. || id.y > 4. ) return .0;\n    return floor( mod( float( CHARACTERS[ int( digit ) ] ) / pow( 2., id.x + id.y * 3. ), 2. ) );\n}\n\nfloat digitSign( float v, vec2 id ) {\n    return digitIsOn( 10 - int( ( sign( v ) - 1. ) * .5 ), id );\n}\n\nint digitCount( float v ) {\n    return int( floor( log( max( v, 1. ) ) / log( 10. ) ) );\n}\n\nfloat digitFirst( vec2 uv, float scale, float v, int decimalPlaces ) {\n    vec2 id = floor( uv * scale );\n\n    if ( .0 < digitSign( v, id ) ) return 1.;\n    v = abs( v );\n    \n    int digits = digitCount( v );\n    float power = pow( 10., float( digits ) );\n    \n    float offset = floor( .1 * scale );\n    id.x -= offset;\n    \n    float n;\n    for ( int i = 0 ; i < 33 ; i++, id.x -= offset , v -= power * n, power /= 10. ) {\n        n = floor( v / power );\n        if ( .0 < digitIsOn( int( n ), id ) ) return 1.;   \n        if ( i == digits ) {\n            id.x -= offset;\n            if ( .0 < digitIsOn( int( 12 ), id ) ) return 1.;\n        }  \n        if ( i >= digits + decimalPlaces ) return .0;    \n    }  \n    return .0;\n}\n\nfloat digitFirst( vec2 uv, float scale, float v ) {\n    return digitFirst( uv, scale, v, 3 );\n}\n\nvec3 digitIn( vec3 color, vec3 fontColor, vec2 uv, float scale, float v ) {\n    float f = digitFirst( uv, scale, v );\n    return mix( color, fontColor, f );\n}\n\nvec3 digitIn( vec3 color, vec2 uv, float scale, float v ) {\n    return digitIn( color, vec3(1.), uv, scale, v );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n\nvec3 colorHit( vec3 eye, vec3 direction, float d );\nvec3 colorMiss( in vec2 uv );\n#ifdef _SHADERTOY_TAB_COMMON\nvec3 colorHit( vec3 eye, vec3 direction, float d ) { return vec3( 1. ); }\nvec3 colorMiss( in vec2 uv ) { return vec3( .0 ); }\n#endif\n\nvec4 boilerCakeMain( in vec2 fragCoord, vec4 mouse, vec3 resolution, float time ) {\n    vec2 uv = FROM_SCREEN( fragCoord, resolution );\n\n    ////////////////////////////////////////////////////////////////\n\n    vec3 eye = cameraEye( CAMERA_DISTANCE, mouse, resolution, time );\n    vec3 b = vec3( ZED );\n    vec3 ab = normalize( makeCamera( eye, b, .0 ) * vec3( uv, CAMERA_ZOOM ) );\n    \n    ////////////////////////////////////////////////////////////////\n\n    float d = march( eye, ab );\n    float hit = step( d, MARCH.z * .5);\n\n    vec3 color = mix( colorMiss( uv ), colorHit( eye, ab, d ), hit );\n    //color = mix( color, vec3( .22, .11, .4 ), pow( d / MARCH.z, .33 ) * hit );\n\n    ////////////////////////////////////////////////////////////////\n    \n    return vec4( color, 1. );\n}\n\nvec4 boilerPlateMain( in vec2 f, vec4 m, vec3 r, float t ) {\n#ifndef AA\n    return boilerCakeMain( f, m, r, t );\n#else\n    vec2 o = vec2( .0, .5 );\n    return (\n        + boilerCakeMain( f, m, r, t )\n        + boilerCakeMain( f + o.xy, m, r, t )\n        //+ boilerCakeMain( f + o.yy, m, r, t )\n        + boilerCakeMain( f + o.yx, m, r, t )\n    ) * .33;\n#endif\n}\n\n// EOF\n/////////////////////////////////////////////////////////////////////////////","name":"Common","description":"","type":"common"}]}