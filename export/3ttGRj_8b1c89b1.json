{"ver":"0.1","info":{"id":"3ttGRj","date":"1577126347","viewed":125,"name":"Abstract Tree","username":"copperTones","description":"A raymarched Christmas tree, with basic lighting.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","christmas","tree","christmastree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TREE_trunk .75\n#define TREE_rings 10\n#define TREE_sepr 1.\n#define TREE_rad .5\n#define TREE_thick .2\n\n#define STAR_rad 1.\n#define STAR_fold pi/5.\n#define STAR_norm normalize(vec3(1, 1, .5))\n#define STAR_width .2\n\n#define BACKG_angle vec3(cos(pi/10.), -sin(pi/10.), 1)\n#define BACKG_a vec3(1)//vec3(.8, .2, .1)\n#define BACKG_b vec3(.9, 1, 1)//vec3(.1, .8, .3)\n\n#define MARCH_itr 200\n#define MARCH_eps 1e-4\n#define MARCH_maxl 5e1\n#define MARCH_norm vec4(MARCH_eps, MARCH_maxl, MARCH_itr, 1)\n\n#define LIGHT_pos vec3(7.5, 0, 10)\n#define LIGHT_itr 100\n#define LIGHT_eps 2.*MARCH_eps\n#define LIGHT_dir(r) normalize(LIGHT_pos - r.pos)\n#define LIGHT_dist(r) length(LIGHT_pos - r.pos)\n\nvec3 CAM_pos = vec3(0, 0, TREE_sepr*float(TREE_rings)/2.);\nmat3 CAM_mat = mat3(1);\n#define CAM_zoom .8\n\n#define rand(n, s) texture(iChannel0, vec2(n, s)/64.).x\n#define arb_mirror(x, n) (x - 2.*n*min(dot(x, n), 0.))\n#define hue(x) clamp(cos(x*pi*6.-vec3(0, 2, 4)*pi/3.)*.7+.5, 0., 1.)\n\n\nstruct Ray {\n\tvec3 pos;\n\tvec3 vel;\n};\nRay Perspective(vec2 uv) {//mostly ripped from my own unity code\n\tRay result;\n\tresult.pos = CAM_pos;\n\tresult.vel = normalize(vec3(uv, CAM_zoom));\n\tresult.vel = CAM_mat * result.vel;\n\treturn result;\n}\n\nfloat cylXY(vec3 pos, vec2 dim) {\n\tfloat dr = length(pos.xy) - dim.x;\n    float dh = abs(pos.z) - dim.y;\n    return max(dr, dh);\n}\nfloat Star(vec3 pos) {\n    pos.xy = abs(pos.xy);\n    \n    pos = arb_mirror(pos, normalize( vec3(0, -cos(4.*STAR_fold), sin(4.*STAR_fold)) ));\n    pos = arb_mirror(pos, normalize( vec3(0, -cos(2.*STAR_fold), sin(2.*STAR_fold)) ));\n    pos = arb_mirror(pos, normalize( vec3(0, -cos(STAR_fold), sin(STAR_fold)) ));\n    \n    float star = dot(pos-vec3(0, 0, STAR_rad), STAR_norm);\n    return max(star, abs(pos.x)-STAR_width);\n}\nvec2 Map(vec3 pos) {\n\tvec2 accm;\n    float td = cylXY(pos-vec3(0, 0, TREE_trunk), vec2(1, TREE_trunk)),\n        sd = Star(pos-vec3(0, 0, 2.*TREE_trunk + TREE_sepr*float(TREE_rings) ));\n    if (td < sd)\n        accm = vec2(td, -1);\n    else\n        accm = vec2(sd, -2);\n    \n    pos.z -= TREE_trunk*2.;\n    for (int i = 0; i < TREE_rings; i++) {\n        mat3 mat = euler(vec3(\n            rand(i, 0)*pi/12.,\n            rand(i, 1)*2.*pi,\n        \t0));\n        float ring = cylXY(pos*mat, vec2(TREE_rad*float(TREE_rings-i), TREE_thick));\n    \tif (accm.x > ring)\n            accm = vec2(ring, rand(i, 10));\n        pos.z -= TREE_sepr;\n    }\n    \n    return accm;\n}\nvec3 Normal(vec3 pos) {\n    #define swzl vec2(0, MARCH_eps)\n    return normalize(vec3(\n        (Map(pos+swzl.yxx) - Map(pos-swzl.yxx)).x,\n        (Map(pos+swzl.xyx) - Map(pos-swzl.xyx)).x,\n        (Map(pos+swzl.xxy) - Map(pos-swzl.xxy)).x\n    ));\n    #undef swzl\n}\nvec4 MarchMap(inout Ray ray) {//total, min, steps, mat\n\tvec4 dist = vec4(0, MARCH_maxl, 0, 0);//total, min, steps, mat\n    vec2 d = vec2(1, 0);\n    \n    for (int i = 0; i < MARCH_itr; i++) {\n        if (!(d.x > MARCH_eps && dist.x < MARCH_maxl)) break;\n    \td = Map(ray.pos);\n        dist.x += d.x;\n        if (dist.y > d.x)\n            dist.yw = d;\n        dist.z++;\n        \n        ray.pos += d.x*ray.vel;\n    }\n    dist.x = min(dist.x, MARCH_maxl);\n\treturn dist/MARCH_norm.yyzw;\n}\nvec4 MarchLight(in Ray ray) {//remaining, total, weighted min, steps\n    ray.pos += LIGHT_eps*Normal(ray.pos);\n    ray.vel = LIGHT_dir(ray);//point towards light\n    float d;\n    bool exit = false;\n    \n\tvec4 dist = vec4(-1, 0, MARCH_maxl, 0);//remaining, total, weighted min, steps\n    for (int i = 0; i < LIGHT_itr /*&& d > MARCH_eps && dist.x < MARCH_maxl*/; i++) {\n    \td = Map(ray.pos).x;\n        if (d > LIGHT_dist(ray)) {//touches light\n            d = LIGHT_dist(ray);\n            exit = true;\n        }\n        dist.y += d;\n        dist.z = min(d/dist.y, dist.z);\n        dist.w++;\n        \n        ray.pos += d*ray.vel;\n        if (exit || !(d > MARCH_eps && dist.y < MARCH_maxl)) break;\n    }\n    dist.x = LIGHT_dist(ray);\n\treturn dist/MARCH_norm.yywz;\n}\nvec3 Background(in Ray ray) {\n    vec3 pos = ray.vel;\n\tpos.x = abs(pos.x);\n    pos = arb_mirror(pos, normalize( vec3(-cos(4.*STAR_fold), sin(4.*STAR_fold), 0) ));\n    pos = arb_mirror(pos, normalize( vec3(-cos(2.*STAR_fold), sin(2.*STAR_fold), 0) ));\n    pos = arb_mirror(pos, normalize( vec3(-cos(STAR_fold), sin(STAR_fold), 0) ));\n    float star = dot(pos, normalize(BACKG_angle));\n    return mod(star, .1)<.05? BACKG_a: BACKG_b;\n}\n\nvoid mainImage(out vec4 color, vec2 coord) {\n    vec2 uv = coord - iResolution.xy/2.;\n    uv *= 2./R.x;//scale by x\n    \n    vec2 mouse = iMouse.yx/R.yx*pi*vec2(1, 2);\n    if (iMouse.xy == vec2(0))//default camera\n        mouse = vec2(1.2, -1.9);\n    CAM_mat = euler(vec3(mouse, 0));\n    CAM_pos = CAM_mat*vec3(0, 0, -10) + CAM_pos;\n    \n    Ray ray = Perspective(uv);\n    vec4 dist = MarchMap(ray);\n    vec4 light = MarchLight(ray);\n    \n    vec3 col = mix(hue(dist.w), vec3(1), .1);\n    if (dist.w == -1.)\n        col = vec3(.5, .2, 0);\n    else if (dist.w == -2.)\n        col = vec3(.8, .7, 0);\n    color.xyz = mix(\n        mix(vec3(0),\n            col,\n            light.x<.01? dot(LIGHT_dir(ray), Normal(ray.pos)): 0.),\n        Background(ray),\n        dist.x);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define pi 3.1416\n#define R iResolution//normalize axis\n\nmat3 rotX(float a) {\n\treturn mat3(1, 0, 0,\n               0, cos(a), sin(a),\n               0, -sin(a), cos(a));\n}\nmat3 rotY(float a) {\n    mat3 x = rotX(a);\n\treturn mat3(x[2].zxy, x[0].zxy, x[1].zxy);\n}\nmat3 rotZ(float a) {\n    mat3 x = rotX(a);\n\treturn mat3(x[1].yzx, x[2].yzx, x[0].yzx);\n}\nmat3 euler(vec3 ang) {\n\treturn rotZ(ang.y) * rotX(ang.x) * rotZ(ang.z);\n}","name":"Common","description":"","type":"common"}]}