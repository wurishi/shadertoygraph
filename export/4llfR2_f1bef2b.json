{"ver":"0.1","info":{"id":"4llfR2","date":"1512517675","viewed":212,"name":"Quantum wave function","username":"kobilica","description":"I don't know. This shader happened as an accident. It seems like I made some sort of rotating object.\n\nBecause frequency is dependent on time, it seems like aliasing effect here is creating effect since sinus function becomes shorter than pixels itself.\n\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["wave","function","quantum"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat curve(in vec2 p, in float fy, in float minLimit, in float maxLimit) {\n    \n    vec2 dist = vec2(0.,0.);\n    \n    if(p.x < minLimit)\n        return 0.;\n    \n    if(p.x > maxLimit)\n        return 0.;\n    \n    //dist.x = min(abs(p.x - minLimit), abs(p.x - maxLimit));\n    \n    dist.y = 1. - 75.*abs(p.y - fy);\n    \n    float d = dist.y; // min(dist.x, dist.y);\n    \n    d = clamp(d, 0., 1.);\n    \n    return d;\n}\nfloat gR = 1.61;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;   \n    \n    uv.y = uv.y - 0.5;\n    uv.y /= .5;\n    \n    float ph = 500. + 2.*iTime;\n    \n    float s0 = sin(ph - gR*ph - ph*uv.x + 6.28*uv.x) * 0.2;\n    float s1 = sin(ph*uv.x + 1.68*uv.x) * 0.2;\n    float s2 = sin(gR*ph - ph*uv.x + 13.28*uv.x) * 0.1;\n    float s3 = sin(gR*ph - ph*uv.x + 34.28*uv.x) * 0.15;\n    \n    float wave = s0 + s1 + s2 + s3;\n    \n    float value = curve(uv, -0.5 + 1.*uv.x - wave, 0., 1.);\n    \n    //if(value > 0.9999)\n    //\tvalue = 1.;\n    \n\tfragColor = vec4(vec3(value),1.0);\n}","name":"Image","description":"","type":"image"}]}