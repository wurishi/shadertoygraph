{"ver":"0.1","info":{"id":"McjGDD","date":"1704253852","viewed":30,"name":"Newton fractals","username":"megaleo","description":"Newton method generating fractals! \nThe white circles show the roots of a cubic polynomial.\n\nInspired by 3blue1brown's series\nhttps://www.youtube.com/watch?v=-RdOwhmqP5s\nhttps://www.youtube.com/watch?v=LqbZpur38nw\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal","video","zoom","newton","polynomial"],"hasliked":0,"parentid":"lcjGDD","parentname":"Complex function visualizer"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// One step of Newton-Raphson root-finding algorithm\n// The roots of the polynomial is set by the roots variable. (For now, just three roots)\nvec2 newton_step(vec2 z, mediump vec2[3] roots)\n{\n    // z += vec2(0.0, 0.5);\n    const int nRoots = roots.length();\n    \n    // Polinomial\n    vec2 Pz = cx_1;\n    for (int i=0; i<nRoots; i++)\n    {\n        Pz = cx_mul(Pz, (z - roots[i]));\n    }\n    \n    // Derivative of the polinomial\n    vec2 DPz = cx_0;\n    for (int i=0; i<nRoots; i++)\n    {\n        vec2 DPzTerm = cx_1;\n        for (int j=0; j<nRoots; j++)\n        {\n            if (i != j)\n            {\n                DPzTerm = cx_mul(DPzTerm, (z - roots[j]));\n            }\n        }\n        DPz += DPzTerm;\n    }\n    \n    return z - cx_div(Pz, DPz);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized and centralized pixel coordinates\n    float aspect_ratio = iResolution.y/iResolution.x;\n    vec2 uv = fragCoord/iResolution.x;\n    uv -= vec2(0.5, 0.5 * aspect_ratio);\n\n    const int n_iterations = 20;\n    \n    const float root_scale = 0.2;\n    const float root0Y_in = 0.3;\n    const float root0Y_out = 0.7;\n    const float dilation_0 = 0.1;\n    const float dilation_zoom = 0.01;\n    float root0Y_0 = dilation_0 * iTime;\n    float root0Y_1 = root0Y_in + dilation_zoom * (iTime - root0Y_in/dilation_0);\n    float root0Y_2 = root0Y_out + dilation_0 * (iTime - root0Y_in/dilation_0 - (root0Y_out - root0Y_in)/dilation_zoom);\n    float root0Y = 0.0;\n    if (root0Y_0 <= root0Y_in)\n    {\n        root0Y = root0Y_0;\n    } else if (root0Y_1 <= root0Y_out)\n    {\n        root0Y = root0Y_1;\n    } else if (root0Y_2 > root0Y_out)\n    {\n        root0Y = root0Y_2;\n    }\n    // Roots at the vertices of a triangle centered around the origin\n    vec2 roots[3]; \n    roots[0] = root_scale*vec2(-1.0/2.0, root0Y);\n    roots[1] = root_scale*vec2(-1.0/2.0, -root0Y); \n    roots[2] = root_scale*vec2(1.0, 0.0);\n    const int nRoots = roots.length();\n    \n    // vec2 fz = 3.0*(1.2-tanh(10.0/iTime))*uv;\n    \n    // Normalized and centralized mouse coordinates\n    // vec4 mouse = iMouse / iResolution.x;\n    // mouse.xy -= vec2(0.5, 0.5 * aspect_ratio);\n    // float scale = 1.0/(1.0 + iTime/10.0);\n    \n    const float zoom_in = root0Y_in*root_scale;\n    const float zoom_out = root0Y_out*root_scale;\n    const float zoom_dt = 0.1*root_scale;\n    const float zoom_mag = 0.9;\n    float uv_scale = 1.0 -  zoom_mag*(smoothstep(zoom_in-zoom_dt, zoom_in, roots[0].y) - smoothstep(zoom_out-zoom_dt, zoom_out, roots[0].y));\n    vec2 new_uv = uv * uv_scale;\n    \n    vec2 fz = new_uv; // First argument\n    for (int i=0; i<n_iterations; i++)\n    {\n        fz = newton_step(fz, roots);\n    }\n    vec2 fzPolar = cx_to_polar(fz);\n    vec3 col = hsb2rgb(vec3(fzPolar.y / (2.0*PI), 1.0, tanh(5.0*fzPolar.x)));\n\n    // Display roots\n    const float rootRadius = 0.005;\n    const vec3 rootColor = vec3(0.9, 0.9, 0.9); \n    for (int i=0; i<nRoots; i++)\n    {\n        if (distance(new_uv, roots[i]) < rootRadius * uv_scale)\n        {\n            col = rootColor;\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Complex Number math by julesb\n// https://github.com/julesb/glsl-util\n// Additions by Johan Karlsson (DonKarlssonSan) & me\n\n#define PI 3.1415926539\n#define cx_1 vec2(1.0, 0.0)\n#define cx_i vec2(0.0, 1.0)\n#define cx_0 vec2(0.0, 0.0)\n#define cx_mul(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)\n#define cx_div(a, b) vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)))\n#define cx_modulus(a) length(a)\n#define cx_conj(a) vec2(a.x, -a.y)\n#define cx_arg(a) atan(a.y, a.x)\n#define cx_sin(a) vec2(sin(a.x) * cosh(a.y), cos(a.x) * sinh(a.y))\n#define cx_cos(a) vec2(cos(a.x) * cosh(a.y), -sin(a.x) * sinh(a.y))\n#define cx_exp(a) exp(a.x) * vec2(cos(a.y), sin(a.y))\n\nvec2 cx_sqrt(vec2 a) {\n    float r = length(a);\n    float rpart = sqrt(0.5*(r+a.x));\n    float ipart = sqrt(0.5*(r-a.x));\n    if (a.y < 0.0) ipart = -ipart;\n    return vec2(rpart,ipart);\n}\n\nvec2 cx_tan(vec2 a) {return cx_div(cx_sin(a), cx_cos(a)); }\n\nvec2 cx_log(vec2 a) {\n    float rpart = sqrt((a.x*a.x)+(a.y*a.y));\n    float ipart = atan(a.y,a.x);\n    if (ipart > PI) ipart=ipart-(2.0*PI);\n    return vec2(log(rpart),ipart);\n}\n\nvec2 cx_mobius(vec2 a) {\n    vec2 c1 = a - vec2(1.0,0.0);\n    vec2 c2 = a + vec2(1.0,0.0);\n    return cx_div(c1, c2);\n}\n\nvec2 cx_z_plus_one_over_z(vec2 a) {\n    return a + cx_div(vec2(1.0,0.0), a);\n}\n\nvec2 cx_z_squared_plus_c(vec2 z, vec2 c) {\n    return cx_mul(z, z) + c;\n}\n\nvec2 cx_sin_of_one_over_z(vec2 z) {\n    return cx_sin(cx_div(vec2(1.0,0.0), z));\n}\n\nvec2 cx_to_polar(vec2 a) {\n    float phi = atan(a.y, a.x);\n    float r = length(a);\n    return vec2(r, phi); \n}\n    \n// Complex power\n// Let z = r(cos θ + i sin θ)\n// Then z^n = r^n (cos nθ + i sin nθ)\nvec2 cx_pow(vec2 a, float n) {\n    float angle = atan(a.y, a.x);\n    float r = length(a);\n    float real = pow(r, n) * cos(n*angle);\n    float im = pow(r, n) * sin(n*angle);\n    return vec2(real, im);\n}\n\n/////////////////\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}","name":"Common","description":"","type":"common"}]}