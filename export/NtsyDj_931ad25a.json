{"ver":"0.1","info":{"id":"NtsyDj","date":"1648721716","viewed":115,"name":"Shadow based on SDF","username":"Lumos320","description":"Shadows generated from simple illumination","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf","shadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n//sdf阈值\n#define Tmin 0.1\n#define Tmax 50.\n//最大迭代次数\n#define Traymarch 128\n//阈值精度\n#define Precision .001\n#define R 1.;\n//光照系数\n#define Ka 0.2\n//抗锯齿\n#define AA 3\n//软阴影系数\n#define K 10.\n\n// Learn more SDF functions： https://iquilezles.org/articles/distfunctions\n// Detailed explanation of soft shadow: https://iquilezles.org/articles/rmshadows\n\nvec2 fixUV(in vec2 uv)\n{\n    return (2.*uv - iResolution.xy)/ min(iResolution.x,iResolution.y);\n}\n\nfloat sdfSphere(in vec3 p)\n{\n    return length(p) - R;\n}\n\nfloat sdfPlant(in vec3 p)\n{\n    return p.y;\n}\n\n//合并sdf\nfloat map(in vec3 p)\n{\n    return min(sdfPlant(p+vec3(0.,1.,0.)),sdfSphere(p));\n}\n\nfloat rayMarching(in vec3 ro, in vec3 rd)\n{\n    //射线走的距离\n    float t = Tmin;\n    for(int i=0; i<Traymarch && t<Tmax; ++i){\n        //当前位置\n        vec3 pos = ro + t*rd;\n        float d = map(pos);\n        if(t >= Tmax) break;\n        if(d < Precision) break;\n        t += d;\n    }\n    return t;\n}\n\n//SDF的法向量\nvec3 calcNormal( in vec3  p ) \n{\n    const float h = 0.0001; // 步长\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n                      k.yyx*map( p + k.yyx*h ) + \n                      k.yxy*map( p + k.yxy*h ) + \n                      k.xxx*map( p + k.xxx*h ) );\n}\n\n//摄像机变换矩阵\nmat3 setCamera(vec3 target, vec3 cpos, float theta)\n{\n    vec3 z = normalize(target - cpos);\n    //theta是y轴绕z旋转的角度，cp能确定相机上方向\n    vec3 cp = vec3(sin(theta),cos(theta),0.);\n    vec3 x = normalize(cross(z,cp));\n    vec3 y = cross(x,z);\n\n    return mat3(x,y,z);\n}\n\n//软阴影\nfloat softshadow2( in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    for( float t=Tmin; t<Tmax; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, K*h/t );\n        t += h;\n    }\n    return res;\n}\n//优化的软阴影\nfloat softshadow( in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=Tmin; t<Tmax; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, K*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nvec3 render(vec2 uv)\n{\n    vec3 color = vec3(0.);\n    \n    //摄像机位置\n    //vec3 ro = vec3(0.,0.,-2.);\n    vec3 ro = vec3(4.*cos(iTime), 1. , 4.*sin(iTime));\n\n    //鼠标控制时\n    if(iMouse.z > 0.1){\n        //鼠标(0,1) 旋转角度(0,2pi)\n        float theta = iMouse.x/iResolution.x * 2. * PI;\n        ro = vec3(4. * cos(theta), 1., 4. * sin(theta));\n    }\n    \n    vec3 target = vec3(0.);\n    //摄像机变换矩阵\n    mat3 camera = setCamera(target, ro, 0.);\n    //方向要归一化\n    //ro是view坐标系原点，不用减\n    vec3 rd = normalize(camera * vec3(uv,1.));\n    float t = rayMarching(ro,rd);\n    \n    if(t < Tmax){\n        //光线打到的位置\n        vec3 pos = ro + t*rd;\n        vec3 normal = calcNormal(pos);\n        //设置一个光源\n        vec3 light = vec3(2.,3.,0.);\n        //漫反射\n        float diffuse = dot(normalize(light-pos), normal);\n        diffuse = clamp(diffuse,0.,1.);\n        //软阴影(能否看到光源)\n        float sd = softshadow(pos,normalize(light - pos));\n        diffuse *= sd;\n        //环境光\n        vec3 ambi = (Ka + Ka * dot(normal, vec3(0., 1., 0.)))  * vec3(0.23);\n        color = ambi  + diffuse * vec3(1.);\n    }\n    //伽马校正<1\n    return sqrt(color);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //vec2 uv = fixUV(fragCoord);\n    vec3 color = vec3(0.);\n    //抗锯齿\n    for(int i=0; i<AA; ++i){\n        for(int j=0; j<AA; ++j){\n            //偏移量在(0,1)\n            vec2 offset = 2. * (vec2(float(i),float(j))/float(AA) - 0.5);\n            vec2 uv = fixUV(fragCoord+offset);\n            color += render(uv);\n        }\n    }\n    //color归一化\n    fragColor = vec4(color/float(AA*AA),1.);\n}","name":"Image","description":"","type":"image"}]}