{"ver":"0.1","info":{"id":"M3SSW3","date":"1711124537","viewed":123,"name":"Glitchy procedural mountains 3D","username":"Mitrano","description":"Any idea why does the mountain disapears when rotating around it ?","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define MAX_NOISE_DETAILS_INDEX 6\n#define ANTIALIASING\n\n// ---- Utils ----\n\n// center of screen: (0,0)\n// dimensions: +/- 0.5 \nvoid prepare2D(out vec2 uv, in vec2 fragCoord) {\n    uv = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n}\n\nfloat noise(vec2 x) {\n    return fract(sin(dot(x, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nfloat randA(vec2 ij){\n    float u = 50. * fract(ij.x / PI);\n    float v = 50. * fract(ij.y / PI);\n\n    return noise(ij);\n}\n\nfloat randB(vec2 ij)\n{\n    return randA(vec2(ij.x+1., ij.y));\n}\n\nfloat randC(vec2 ij)\n{\n    return randA(vec2(ij.x, ij.y+1.));\n}\n\nfloat randD(vec2 ij)\n{\n    return randA(vec2(ij.x+1., ij.y+1.));\n}\n\nfloat S(float lambda) {\n    return (3. * lambda * lambda) - (2. * lambda * lambda * lambda);\n}\n\nfloat f(float x, float z){\n    float i = floor(x),\n          j = floor(z);\n\n    vec2 ij = vec2(i, j);\n    float \n        a = randA(ij), \n        b = randB(ij),\n        c = randC(ij),\n        d = randD(ij);\n\n    return a + (b-a) * S(x - i) + (c - a) * S(z-j) + (a - b - c + d) * S(x - i) * S(z - j);\n    // return sin(x) + cos(z);\n}\n\nfloat f(vec2 xy) {\n    return f(xy.x, xy.y);\n}\n\n//------------------ Unions ----------------------\n\nfloat opUnion(float d1, float d2) {\n    return min(d1, d2);\n}\n\n//------------------ Sdfs ------------------------\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdPlane(vec3 p, vec3 normal, float altitude) {\n  // n must be normalized\n  return dot(p, normal) + altitude;\n}\n\nfloat sdPlane(vec3 p, float altitude) {\n    return sdPlane(p, vec3(0.0, 1.0, 0.0), altitude);\n}\n\n// ---- Visuals ----\n\nfloat map(in vec3 pos) {\n    vec2 p = pos.xz;\n    float plane = sdPlane(pos, 0.);\n    \n    mat2 rotation = mat2(.8, -.6, .6, .8);\n    float k = 1.;\n    \n    for(int i=0; i<MAX_NOISE_DETAILS_INDEX; i++)\n    {\n        plane += k * f(p);\n        p = p * 2. * rotation;\n        k = k * .5;\n    }\n\n    return plane;\n}\n\nvec3 calcNormal(in vec3 pos) {\n    const float ep = 0.000001;\n    vec2 e = vec2(1.0, -1.0) * 0.5773;\n    return normalize(e.xyy * map(pos + e.xyy * ep) +\n        e.yyx * map(pos + e.yyx * ep) +\n        e.yxy * map(pos + e.yxy * ep) +\n        e.xxx * map(pos + e.xxx * ep));\n}\n\nfloat calcSoftshadow(in vec3 ro, in vec3 rd, float tmin, float tmax, const float k) {\n    float res = 1.0;\n    float t = tmin;\n    for(int i = 0; i < 50; i++) {\n        float h = map(ro + rd * t);\n        res = min(res, k * h / t);\n        t += clamp(h, 0.02, 0.20);\n        if(res < 0.005 || t > tmax)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n\n\n// Camera\n\n// Set up a camera looking at the scene.\n// origin - camera is positioned relative to, and looking at, this point\n// dist(ance) - how far camera is from origin\n// rotation - about x & y axes, by left-hand screw rule, relative to camera looking along +z\n// zoom- the relative length of the lens\n\nvec3 localRay;\nvoid handleCamera(out vec3 pos, out vec3 ray, in vec3 origin, in vec2 rotation, in float dist, in float zoom, in vec2 fragCoord) {\n\t// get rotation coefficients\n    vec2 c = vec2(cos(rotation.x), cos(rotation.y));\n    vec4 s;\n    s.xy = vec2(sin(rotation.x), sin(rotation.y)); // worth testing if this is faster as sin or sqrt(1.0-cos);\n    s.zw = -s.xy;\n\n\t// ray in view space\n    ray.xy = fragCoord.xy - iResolution.xy * .5;\n    ray.z = iResolution.y * zoom;\n    ray = normalize(ray);\n    localRay = ray;\n\n\t// rotate ray\n    ray.yz = ray.yz * c.xx + ray.zy * s.zx;\n    ray.xz = ray.xz * c.yy + ray.zx * s.yw;\n\n\t// position camera\n    pos = origin - dist * vec3(c.x * s.y, s.z, c.x * c.y);\n}\n\n// ---- Ray Marching ----\n\nvoid rayMarch(in int maxSteps, in vec3 rayOrigin, in vec3 rayDirection, in float distanceMin, in float distanceMax, in float delta, out float dist) {\n    dist = distanceMin;\n    for (int i = 0; i < maxSteps; i++){\n        vec3 p = rayOrigin + rayDirection * dist;\n        vec3 smallX = vec3(delta, 0., 0.);\n        vec3 smallZ = vec3(0., 0., delta);\n        float distanceToObject = min(min(map(p), map(p - smallX)), min(map(p + smallX), min(map(p - smallZ), map(p + smallZ))));\n\n        if (distanceToObject < delta || dist > distanceMax)break;\n        \n        dist += distanceToObject;\n\n        // if (distanceToObject > 2.) dist += distanceToObject;\n        // else dist += .04; // Under a threshhold, starts constant stepping\n    }\n}\n\nbool isSeeingLight(in vec3 rayOrigin, in vec3 lightDirection, in float distanceMin, in float distanceMax) {\n    float dist;\n    rayMarch(256, rayOrigin + .1 * lightDirection, lightDirection, distanceMin, distanceMax, 0.000001, dist);\n    return dist > distanceMax;\n}\n\n\n// Main\n\nvoid handleColor(in vec3 ro, in float dist, in vec3 rd, in float distanceMin, in float distanceMax, out vec3 col) {\n    if (dist > distanceMax) return;\n\n    vec3 pos = ro + dist * rd;\n    vec3 normal = calcNormal(pos);\n    vec3 lightDirection = normalize(vec3(1.0, 0.8, -0.2));\n    float light = clamp(dot(normal, lightDirection), 0.0, 1.0);\n\n    light *= isSeeingLight(pos, lightDirection, distanceMin, distanceMax) ? 1. : 0.;\n\n    // Mountains\n    col = vec3(1.) * light;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // 2D Viewport\n    vec2 uv;\n    prepare2D(uv, fragCoord); \n\n   // Camera Handling\n    vec2 cameraRotation = vec2(.7, .5) + vec2(-.35, 4.5) * (iMouse.yx / iResolution.yx);\n    vec3 rayOrigin, rayDirection;\n    vec3 cameraOrigin = vec3(0., -1.1, 0.);\n    \n    handleCamera(rayOrigin, rayDirection, cameraOrigin, cameraRotation, 5.0, 1., fragCoord);\n\n   // Ray Marching\n    float distanceMin = 1.;\n    float distanceMax = 12.;\n\n    float dist;\n    rayMarch(256, rayOrigin, rayDirection, distanceMin, distanceMax, 0.000001, dist);\n\n   // Coloring\n\n    vec3 backgroundColor = vec3(0.32, 0.95, 0.97);\n    vec3 lightColor = vec3(backgroundColor);\n\n    handleColor(rayOrigin, dist, rayDirection, distanceMin, distanceMax, lightColor);\n\n    fragColor = vec4(lightColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}