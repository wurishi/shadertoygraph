{"ver":"0.1","info":{"id":"clfyRH","date":"1690378013","viewed":45,"name":"Newton-Raphson-Bisection Poly2","username":"Envy24","description":"Rewrited version of previous solver (simplified).\nUse mouse to scan for roots.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["approximation","solver","cubic","quadratic","quartic","newton","quintic","bisection","polynomials","raphson","numeric","sextic","dekker"],"hasliked":0,"parentid":"dlsyzn","parentname":"Newton-Raphson-Bisection Poly"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCENE_SCALE               ( 2.5 )\n#define ORIGIN                    ( vec2(0, 0) )\n#define UNIT                      ( (SCENE_SCALE*3.0) / iResolution.y  )\n#define SM(x)                     ( smoothstep(UNIT, 0., x) )\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nfloat x_axis(vec2 NDC) { return SM(abs(NDC.x)); }\nfloat y_axis(vec2 NDC) { return SM(abs(NDC.y)); }\nfloat draw_func(vec2 NDC, float f, float dfdx)\n{\n    float df   = NDC.y - f;\n    return SM(abs(df) / sqrt(1.0 + dfdx * dfdx));\n}\n\n/* Polynomials (from sextic to linear) */\n#define func(x)  ( (((((  a*x +    b)*x +    c)*x +    d)*x +    e)*x + f)*x + g )\n#define deriv(x) ( ((((6.*a*x + 5.*b)*x + 4.*c)*x + 3.*d)*x + 2.*e)*x + f )\n\n//#define func(x)  ( ((((  a*x +    b)*x +    c)*x +    d)*x + e)*x + f )\n//#define deriv(x) ( (((5.*a*x + 4.*b)*x + 3.*c)*x + 2.*d)*x + e )\n\n//#define func(x)  ( (((  a*x +    b)*x +    c)*x + d)*x + e )\n//#define deriv(x) ( ((4.*a*x + 3.*b)*x + 2.*c)*x + d )\n\n//#define func(x)  ( ((  a*x +     b)*x + c)*x + d )\n//#define deriv(x) ( (3.*a*x + 2.0*b)*x + c )\n\n//#define func(x)  ( (   a*x + b)*x + c )\n//#define deriv(x) (  2.*a*x + b )\n\n//#define func(x)  ( a*x + b )\n//#define deriv(x) ( a )\n\n#define T ( iTime*0.3 )\n//#define T ( iMouse.x/iResolution.x*20. )\nfloat f(float x)\n{\n    float a = sinOSC(-1.25, 1.25, T * 0.15), b = sinOSC( -2.0,  2.0, T * 0.6), \n          c = sinOSC( -1.0,  1.0, T * 0.45), d = sinOSC( -1.0,  1.0, T * 0.25),\n          e = sinOSC( -1.0,  1.0, T * 0.17), f = sinOSC( -1.0,  1.0, T * 0.07),\n          g = sinOSC( -1.0,  1.0, T * -0.17);\n\n    return func(x);\n}\nfloat dfdx(float x)\n{\n    float a = sinOSC(-1.25, 1.25, T * 0.15), b = sinOSC( -2.0,  2.0, T * 0.6), \n          c = sinOSC( -1.0,  1.0, T * 0.45), d = sinOSC( -1.0,  1.0, T * 0.25),\n          e = sinOSC( -1.0,  1.0, T * 0.17), f = sinOSC( -1.0,  1.0, T * 0.07),\n          g = sinOSC( -1.0,  1.0, T * -0.17);\n          \n    return deriv(x);\n}\n\nfloat gs(float x) { return x >= 0. ? 1. : -1.; } // get_sign\nfloat findRootNRB(\n    float x_min,\n    float x_max)\n{\n    /* If you have troubles try to decrease tolerance */\n    const float tolerance = 1e-6; /* Desired precision. */\n    \n    // Data to track.\n    float x = x_min + (x_max - x_min) * 0.5,\n          y0 = f(x_min),\n          deriv = dfdx(x),\n          y = 9e5;\n\n    const int max_num_of_steps = 32;\n    for (int i = 0; i < max_num_of_steps; i++)\n    {                    \n        // Close enough?\n        if (abs(y) <= tolerance) { break; }\n        \n        // Make Newton-Raphson step.\n        x -= y / deriv;\n        \n        // Failed Newton-Raphson step?\n        if (x < x_min || x > x_max) // x step outside search range?\n        {\n            // Make bisection step.\n            x = x_min + (x_max - x_min) * 0.5;\n            \n            // Eval polynomial at new guess.\n            y = f(x);\n            \n            // Update bounds\n            if (gs(y0) == gs(y)) { x_min = x; }\n            else { x_max = x; }\n            \n            // Choose middle of new interval as new root guess.\n            x = x_min + (x_max - x_min) * 0.5;\n        }\n        else\n        {\n            // Eval polynomial and derivative at new guess.\n            y = f(x);\n            deriv = dfdx(x);\n            \n            // Update bounds.\n            if (gs(y0) == gs(y)) { x_min = x; }\n            else { x_max = x; }\n        }\n    }\n    \n    return x;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, false),\n         MP = iMouse.xy == vec2(0) ? \n             vec2(0) : \n             map_to_centered_ndc(iMouse.xy, SCENE_SCALE, ORIGIN, false);\n\n    float offs = MP.x,\n          x_min = -0.2 + offs,\n          x_max = 0.2 + offs,\n          x = findRootNRB(x_min, x_max);\n\n    vec3 color = (NDC.x <= x_max && NDC.x >= x_min) ? vec3(.9,.9,.9) : vec3(1.);\n         color -= draw_func(NDC, f(NDC.x), dfdx(NDC.x));\n         color -= x_axis(NDC); color -= y_axis(NDC);\n \n    /* Root */\n    color = mix(color, vec3(1, 0, 0), SM(diskSDF_L2(NDC, vec2(x, 0.0), 0.05)));\n    \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}","name":"Common","description":"","type":"common"}]}