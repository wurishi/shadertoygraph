{"ver":"0.1","info":{"id":"clyyW3","date":"1700746508","viewed":44,"name":"Simple SDF by Bearkirb","username":"BearKirb","description":"raymarch","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//https://iquilezles.org/articles/rmshadows\nfloat Sphere(vec3 center, float r, vec3 point){\nreturn length(center-point)-r;\n}\nfloat minMore(float t[4]){\nfloat mind = 10000000.0;\nfor(int i=0;i<t.length();i++){\nmind = min(mind,t[i]);\n}\nreturn mind;\n}\nfloat Plane( vec3 p, vec3 n, float h )\n{\n  n = normalize(n);\n  return dot(p,n) + h;\n}\nfloat Scene( vec3 pos )\n{\n    float f1 = Sphere(vec3(-1,-1,0),1.,pos);\n    float f2 = Sphere(vec3(1,-1,0),1.,pos);\n    float f3 = Sphere(vec3(0,0,0),1.,pos);\n    float f4 = Plane(pos, vec3(0.0,1.0,0.0), 2.0);\n    float ds[4] = float[4](f1,f2,f3,f4);\n    float tdist = minMore(ds);\n    return tdist;\n}\nvoid Rotate( inout vec3 vector, vec2 angle )\n{\n\tvector.yz = cos(angle.y)*vector.yz\n\t\t\t\t+sin(angle.y)*vec2(-1,1)*vector.zy;\n\tvector.xz = cos(angle.x)*vector.xz\n\t\t\t\t+sin(angle.x)*vec2(-1,1)*vector.zx;\n}\nfloat shadow( in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n  vec3 po=rd;\n  int breaki=0;\n  float minDist=10000.0;\n    for( int i=0; i<24; i++ )\n    {\n  \n        po -= normalize(rd-ro) * Scene(po);\n        minDist=min(minDist,Scene(po));\n  \n      \n      \n    }\n          if( Scene(po)<0.001){\n        if(distance(po,ro)<0.01){\n            return 1.0;\n            }else{\n            return minDist*1000.0;\n            }\n            }\n    return 1.0;\n}\n\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(22.987, 87.293))) *\n        43758.5453123);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 8.0*(fragCoord-iResolution.xy*0.5)/-iResolution.x;\n vec3 ray = normalize( vec3(\n\t\t\t\t(fragCoord-iResolution.xy*.5)/iResolution.x, \n\t\t\t\t1 ) ); \n    vec3 pos = vec3(0,0,-18); \n \n    vec2 angle = vec2(iTime,.3);\nangle = -(iMouse.xy/iResolution.xy-.5)*3.14;\n\tRotate(pos,angle);\n\tRotate(ray,angle);\n\n    float minDist=100.0;\n    \n    for ( int i=0; i < 100; i++ )\n    {\n        float h = Scene(pos);\n     minDist=min(minDist,h);\n        if ( h < -0.1 )\n        {\n            minDist=0.0;\n            break;\n        }\n        pos += ray*h;\n    }\n      vec3 lightSource = vec3(10.0*cos(iTime),10.0,10.0*sin(iTime));\n    fragColor.rgb = vec3(0.0,0.0,0.0);\n  \n        if ( Scene(pos) < 0.1 )\n    {\n        vec3 normal;\n        normal.x = Scene(pos+vec3(.01,0,0)) - Scene(pos-vec3(.01,0,0));\n        normal.y = Scene(pos+vec3(0,.01,0)) - Scene(pos-vec3(0,.01,0));\n        normal.z = Scene(pos+vec3(0,0,.01)) - Scene(pos-vec3(0,0,.01));\n        normal = normalize(normal);\n\n      \n\t\tfloat light = max(.0,dot(normal,normalize(lightSource-pos)));\n        vec3 ballColor= vec3(0.3,0.3,0.3);\n       \n        vec3 lightCol = vec3(1.0,1.0,1.0);\n        vec3 ambient = mix(lightCol/4.0,ballColor/4.0,0.7);\n        vec3 spec = mix(lightCol*4.0,ballColor*4.0,0.7);\n        fragColor.rgb = (light*lightCol + pow(light,80.0)*spec);\n        fragColor.rgb *= vec3(shadow(pos, lightSource));\n        fragColor.rgb += ambient; \n        \n        fragColor.rgb /= (distance(lightSource,pos)*distance(lightSource,pos)/80.0);\n    }\n    \n    fragColor.rgb = pow( fragColor.rgb, vec3(1.0/2.2) );\n    fragColor.rgb = fragColor.rgb + random(ray.xy)/128.0;\n    // Output to screen\n  \n}","name":"Image","description":"","type":"image"}]}