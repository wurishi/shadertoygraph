{"ver":"0.1","info":{"id":"4stBWf","date":"1527022126","viewed":146,"name":"Ã†ther","username":"chronos","description":"Give it some time to get going :)\nBased on my 'Generalized Abelian Sandpile' shader","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["cellular","automaton","continuous"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float SampleBuffer(ivec2 p) { return texelFetch(iChannel0, p, 0).x; }\nvec3 GetNormal(vec2 P)\n{\n    ivec2 p = ivec2(P);\n    float dx = \n        \t( SampleBuffer(p+ivec2( 1,  1)) - SampleBuffer(p+ivec2( -1,  1))\n        \t+ SampleBuffer(p+ivec2( 1,  0)) - SampleBuffer(p+ivec2( -1,  0))\n    \t\t+ SampleBuffer(p+ivec2( 1, -1)) - SampleBuffer(p+ivec2( -1, -1))\n    \t\t) / 3.;\n    \n    float dy =\n        \t( SampleBuffer(p+ivec2( 1,  1)) - SampleBuffer(p+ivec2( 1, -1))\n    \t\t+ SampleBuffer(p+ivec2( 0,  1)) - SampleBuffer(p+ivec2( 0, -1))\n    \t\t+ SampleBuffer(p+ivec2(-1,  1)) - SampleBuffer(p+ivec2( 1, -1))\n            ) / 3.;\n    \n    vec2 dxdy = vec2(dx, dy);\n    if(length(dxdy) < 0.0000001) return vec3(0.,0.,1.);\n    float dz = sqrt(abs(1.-dot(dxdy, dxdy)));\n    vec3 Normal = vec3(normalize(dxdy), dz);\n    Normal = normalize(Normal);\n    return Normal;\n}\n\n// From: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.28.6586&rep=rep1&type=pdf\n// Omega = color spiral rotation frequency\n// Phi   = color spiral rotation phase\n// Assumes 0 <= t <= 1\nvec3 pseudocolor(float t, float omega, float phi)\n{\n    const float root3 = sqrt(3.);\n\tmat3 rot = mat3(1. + root3, 1. - root3, -2., // Rotate to spiral around grayscale axis\n                    1. - root3, 1. + root3, -2.,\n                    2         , 2         ,  2);\n    float r = sqrt(1.5) * t * (1.-t); // spiral radius\n    vec3 spiral = vec3(r * sin(omega * t + phi),\n                       r * cos(omega * t + phi),\n                       root3 * t);\n\treturn rot * spiral / (2. * root3);  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = vec3(0.);\n#if NO_LIGHTING\n    vec4 buffer = texture(iChannel0, uv);\n    color = pseudocolor(buffer.r, 6.1 * buffer.a, iTime+2.);\n#else\n    vec2 Aspect = iResolution.xy / iResolution.yy;\n    \n    vec3 N = GetNormal(fragCoord);\t\t\t\t\t// Normal\n    vec3 L = normalize(vec3(cos(iTime),sin(iTime), 1.));\t// Light Vector\n    vec3 V = normalize(vec3((2. * (uv - .5) / Aspect), 1.));// View Vector\n    vec3 R = 2. * dot(N, V) * N - V;\t\t\t\t\t\t// Reflection Vector\n    vec3 H = normalize((N+V)/2.);\t\t\t\t\t\t\t// Half vector\n    vec3 ReflectionColor = texture(iChannel1, -R).rgb;\n    color = \n        vec3(0.2, .1, .05) + \n        ( ReflectionColor * (1. + .1 * vec3(0.7, 0.7, 0.3))) * dot(N, L) +\n        vec3(1., 1., 1.) * pow(dot(H, L), 20.);\n#endif\n\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float transition(float x)\n{\n    //return min(floor(x), 1.); // or (1.-step(1., x)); // original rule\n    return \n        // modified rule\n        threshold * smoothstep(threshold-threshold_smoothing, threshold+threshold_smoothing, x); \n}\n\nfloat GetInnerWeight(float offset_length)\n{\n    //return step(offset_length, inner_radius); //offset_length <= inner_radius ? 1. : 0.;\n    float eps = max( cell_smoothing, 0.0001); // Fixes smoothstep not degenerating into step for some reason\n    return 1.-smoothstep(inner_radius-eps, inner_radius+eps, offset_length);\n}\n\nfloat GetOuterWeight(float offset_length)\n{\n    float InnerWeight = GetInnerWeight(offset_length); // TODO: Optimize away unnecessary recompute\n    float eps = max(cell_smoothing, 0.0001); // Fixes smoothstep not degenerating into step for some reason\n    float w = 1.-smoothstep(outer_radius-eps, outer_radius+eps, offset_length);\n    return (1. - InnerWeight) * w; // offset_length <= float(r) ? (1.-InnerWeight) : 0.;\n}\n\nivec2 wrap(ivec2 p) { return (p + ivec2(iResolution.xy)) % ivec2(iResolution.xy); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    ivec2 p = ivec2(fragCoord.xy); \n    // Fill with toppling neighbors\n    // Nonuniform weighting, sums to 1\n    // TODO: Generalize to larger neighborhoods with more general weights, weights should be normalized to 1 (Completed)\n    // TODO: Get previous frame topple activation indication from alpha channel of neighbors,\n    //       instead of recomputing transition function for each neighbor (Completed)\n    \n    float OuterAccumulation = 0.;\n    float InnerAccumulation = 0.;\n    \n    float InnerWeightTotal = 0.;\n    float OuterWeightTotal = 0.;\n    for(int i = -r; i <= r; i++)\n    {\n     \tfor(int j = -r; j <= r; j++)\n    \t{\n            // TODO: Combine inner and outer accumulation (and Weights) into vec2 operations\n            // Keeping it like this, as it is clearer\n        \tivec2 offset = ivec2(i, j);\n            float offset_length = DISTANCE_METRIC(vec2(offset));\n            ivec2 q = wrap(p + offset);\n            vec4 NeighborSample = texelFetch(iChannel0, q, 0);\n            float NeighborActivation = NeighborSample.a;\n            float LocalAccumulation  = NeighborSample.r;\n            float InnerWeight = GetInnerWeight(offset_length); \n            float OuterWeight = GetOuterWeight(offset_length);\n            \n            OuterAccumulation += OuterWeight * NeighborActivation;\n            InnerAccumulation += InnerWeight * LocalAccumulation;\n            \n            InnerWeightTotal += InnerWeight;\n            OuterWeightTotal += OuterWeight;\n    \t}   \n    }\n\n    // TODO: Decide toppling activation based on accumulation in small radius\n    // instead of only center pixel (Completed)\n    float AnnulusActivation = (OuterAccumulation / OuterWeightTotal);\n    float DiskAccumulation  = (InnerAccumulation / InnerWeightTotal);\n    float Accumulation = (AnnulusActivation + DiskAccumulation);\n    \n    // Decide whether to topple, given by transition function\n    float Activation = transition(Accumulation);\n\n    #if FAITHFUL_UPDATE_RULE || CONTINUOUS_TIMESTEP\n    \tfloat PreviousAccumulation = texelFetch(iChannel0, p, 0).r;\n    #endif\n    \n    #if FAITHFUL_UPDATE_RULE\n    float f = (3. * AnnulusActivation + 1.*DiskAccumulation) / 9.;\n    Accumulation = mix(PreviousAccumulation, PreviousAccumulation + f - Activation, timestep);\n    \t//Accumulation = PreviousAccumulation + Accumulation/2. - Activation;\n    #else\n    \tAccumulation -= Activation;\n    #endif\n\n    //Accumulation = mix(PreviousAccumulation, Accumulation, timestep);\n\n    if(iFrame < 10 || texture( iChannel1, vec2(32.5/256.0, 0.5) ).x > 0.5) \n    {\t\n        // (Re-)initialization logic\n        Accumulation = threshold*smoothstep(1.0, 0., length(fragCoord.xy/iResolution.xx- vec2(0.5,0.3)));\n        Activation = 0.;\n    }\n\n    // TODO: Pass topple activation result to next frame via alpha channel (Completed)\n    // TODO: Pass current neighbor count, so that neighbors may calculate contribusion strength\n    //       in case of simulation being run on a bounding region substrate\n\n    vec4 State = vec4(vec3(Accumulation), Activation);\n\tfragColor = clamp(State, 0., 1.);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\n\tNew: \n\t'Faithful' (to original model) update rule removes diffusive property from \n\tpoint density accumulation, causing more intricate stable configurations,\n\tas in the original model.\n*/\n#define FAITHFUL_UPDATE_RULE 1\n\n#define CONTINUOUS_TIMESTEP 1\n\n#define USE_MOUSE 0\n#define NO_LIGHTING 1\n\n#define EUCLIDEAN(P) (length(P))\n#define CHEBYSHEV(P) (max(abs((P).x), abs(P).y))\n#define MANHATTAN(P) (abs(P).x + abs(P).y)\n\n\n#define DISTANCE_METRIC MANHATTAN\n\nconst float threshold = 0.9999;\nconst float threshold_smoothing = 0.1;\nconst float cell_smoothing = 3.0;\n\nconst float outer_radius = 10.;\nconst float inner_radius = outer_radius/2.0;\n\nconst int r = int(outer_radius)+1; // Neighbor sampling radius\n\n#if CONTINUOUS_TIMESTEP\n\tconst float timestep = 0.05;\n#endif\n\n\n\n// Various Parameter configurations:\n/* \n//Defaults\n#define DISTANCE_METRIC EUCLIDEAN\n\nconst float threshold = 0.5;\nconst float threshold_smoothing = 0.04;\nconst float cell_smoothing = 1.5;\n\nconst float outer_radius = 6.;\nconst float inner_radius = outer_radius/3.0;\n\nconst int r = int(outer_radius)+1; // Neighbor sampling radius\n*/\n\n/*\n// Regular Abelian Sandpile Model\n#define DISTANCE_METRIC MANHATTAN\n\nconst float threshold = 0.5;\nconst float threshold_smoothing = 0.00;\nconst float cell_smoothing = 0.0;\n\nconst float outer_radius = 1.;\nconst float inner_radius = outer_radius/2.0;\n\nconst int r = int(outer_radius)+1; // Neighbor sampling radius\n*/","name":"Common","description":"","type":"common"}]}