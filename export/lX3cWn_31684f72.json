{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"vec4 placeholderColor = vec4(0); // vec4(0, 0.5, 0, 1);\n\nvec4 pattern(vec2 uv) {\n    if(mod(uv.x+uv.y+100000.0, 0.5) < 0.25) return vec4(0, 1, 0, 1);\n    return vec4(1, 1, 0, 1);\n}\n\nbool isFull(int x, int y) {\n    bool a = cos(float(x)*63.8243242 + float(y)*154.4453) > 0.0;\n    bool b = sin(float(x)*1.94303 + float(y)*84.02314) > 0.0;\n    return a ^^ b;\n}\n\nvec4 innerColor(bool full) {\n    if(full) return vec4(0, 1, 0, 1);\n    return vec4(0);\n}\n\nbool getOuterEdge(vec2 uv, int x, int y, int xdif, int ydif) {\n    bool full1 = isFull(x, y);\n    bool full2 = isFull(x+xdif, y+ydif);\n    return full1 && full2;\n}\n\nbool getInnerEdge(vec2 uv, int x, int y, int xdif, int ydif) {\n    bool full1 = isFull(x, y);\n    bool full2 = isFull(x+xdif, y+ydif);\n    return full1;\n}\n\nbool getInnerCorner(vec2 uv, int x, int y, int xdif, int ydif, float radius) {\n\n    bool full = isFull(x, y);\n    bool full1 = isFull(x+xdif, y);\n    bool full2 = isFull(x, y+ydif);\n    bool cornerFull = isFull(x+xdif, y+ydif);\n    \n    if(full) {\n        if(!full1 && !full2) {\n            uv -= vec2(0.5);\n            uv -= vec2(xdif, ydif)*(0.5-radius);\n            return  uv.x*uv.x + uv.y*uv.y < radius*radius;\n        }\n        if(full1 || full2) return true;\n    }else {\n        return false;\n    }\n}\n\nbool getOuterCorner(vec2 uv, int x, int y, int xdif, int ydif, float radius) {\n\n    bool full = isFull(x, y);\n    bool full1 = isFull(x+xdif, y);\n    bool full2 = isFull(x, y+ydif);\n    bool cornerFull = isFull(x+xdif, y+ydif);\n    \n    if(full && full1 && full2) {\n        if(!cornerFull) {\n            uv -= vec2(0.5);\n            uv -= vec2(xdif, ydif)*(0.5);\n            bool finalFull = uv.x*uv.x + uv.y*uv.y > radius*radius;\n            return finalFull;\n        } else {\n            return true;\n        }\n    }else {\n        return false;\n    }\n}\n\nbool inner(vec2 uv, int x, int y, float thresh) {\n\n    int xdif = 0, ydif = 0;\n    \n    if(uv.x < thresh) xdif -= 1;\n    if(uv.x > 1.0-thresh) xdif += 1;\n    if(uv.y < thresh) ydif -= 1;\n    if(uv.y > 1.0-thresh) ydif += 1;\n    \n    if((xdif == 0) != (ydif == 0)) {\n        return getInnerEdge(uv, x, y, xdif, ydif);\n    } else if(xdif != 0 && ydif != 0) {\n        return getInnerCorner(uv, x, y, xdif, ydif, thresh);\n    }else {\n        return isFull(x, y);\n    }\n}\n\nbool outer(vec2 uv, int x, int y, int xdif, int ydif, float thresh1, float thresh2) {\n    \n    if((xdif == 0) != (ydif == 0)) {\n        return getOuterEdge(uv, x, y, xdif, ydif);\n    } else if(xdif != 0 && ydif != 0) {\n        return getOuterCorner(uv, x, y, xdif, ydif, thresh1);\n    } else {\n        vec2 nuv = uv - vec2(thresh1, thresh1);\n        nuv /= 1.0 - 2.0*thresh1;\n        return inner(nuv, x, y, thresh2);\n    }\n}\n\nbool pixelFull(vec2 uv, float thresh1, float thresh2) {\n    int x = int(floor(uv.x));\n    int y = int(floor(uv.y));\n    \n    uv = uv - vec2(x, y);\n    \n    int xdif = 0, ydif = 0;\n    \n    if(uv.x < thresh1) xdif -= 1;\n    if(uv.x > 1.0-thresh1) xdif += 1;\n    if(uv.y < thresh1) ydif -= 1;\n    if(uv.y > 1.0-thresh1) ydif += 1;\n    \n    return outer(uv, x, y, xdif, ydif, thresh1, thresh2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy/2.0)/iResolution.x;\n\n    // Time varying pixel color\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    // zoom and pan\n    uv = uv*(20.0+3.0*cos(iTime*0.9423));\n    uv += 10.0*vec2(cos(iTime*0.423493), sin(iTime*0.1294342));\n    \n    // modulate outer and inner padding (/radii)\n    float t1 = 0.05 + 0.05*sin(iTime*1.23414);\n    float t2 = 0.25 + 0.25*cos(iTime);\n    \n       // calculate color from\n    bool inside = pixelFull(uv, t1, t2);\n    bool border = inside && !pixelFull(uv, t1+0.05, t2);\n    fragColor = vec4(0, 0, 0, 1);\n    if(border) fragColor = pattern(uv); // fragColor = vec4(0, 1, 0, 1);\n    else if(inside) fragColor = pattern(uv)*0.5;\n    \n    // Output to screen\n    // fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lX3cWn","date":"1734982160","viewed":32,"name":"Rounded Grid Regions","username":"waeaves","description":"Simple enough. As a shader, render regions with rounded outlines.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["grid","rounded","regions"],"hasliked":0,"parentid":"","parentname":""}}