{"ver":"0.1","info":{"id":"3dcXW2","date":"1572964539","viewed":195,"name":"ColorBar(3 bit colors  + dither)","username":"sapporo_dynamite","description":"implemented Display halftone in 8 colors\n[mode]\n0. full color\n1. 8 color\n2. 8 color / ordered dither 4x4 ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["dither","halftone","gamma","dithering","colorbar","3bitcolors"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tColor Bar\n\n\timplemented Display halftone in 8 colors\n\n\tauthor:\n\tsapporo_dynamite/2019 \n\n\tLicense :\n\tCreative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n　　Reference：\n\n\tnorishige chiba (1991) Cによる　CGレイトレーシング サイエンス社\n\n\n\tURL:\n\tAlex Charlton — Dithering on the GPU\n\thttp://alex-charlton.com/posts/Dithering_on_the_GPU/\n*/\n\n/*\n2019/11/06   \n  1.0.0 → 1.0.1\n\t・オーダードディザ法で色の選択が間違っていた\n\n2019/11/05   \n  0.0 → 1.0.0\n\t・最初のリリース\n*/\n\nfloat getDither( in vec2 uv )\n{    \n    float x = (uv.x * iResolution.x);\n    float y = (uv.y * iResolution.y);\n    \n    int ix = int(mod(x, 4.0));\n    int iy = int(mod(y, 4.0));\n    \n    const mat4 dither = mat4( 0,  8,  2, 10, \n                             12,  4, 14,  6,\n                              3, 11,  1,  9, \n                             15,  7, 13,  5 );\n    \n    float result = 0.0;\n    \n   \n    // environment where arrays could not be used\n    // 配列が使えない環境だった orz..\n     \t if (ix == 0 && iy == 0) result = dither[0][0];\n   \telse if (ix == 1 && iy == 0) result = dither[1][0];\n   \telse if (ix == 2 && iy == 0) result = dither[2][0];\n   \telse if (ix == 3 && iy == 0) result = dither[3][0];\n   \telse if (ix == 0 && iy == 1) result = dither[0][1];\n   \telse if (ix == 1 && iy == 1) result = dither[1][1];\n   \telse if (ix == 2 && iy == 1) result = dither[2][1];\n   \telse if (ix == 3 && iy == 1) result = dither[3][1];\n   \telse if (ix == 0 && iy == 2) result = dither[0][2];\n   \telse if (ix == 1 && iy == 2) result = dither[1][2];\n   \telse if (ix == 2 && iy == 2) result = dither[2][2];\n    else if (ix == 3 && iy == 2) result = dither[3][2];\n   \telse if (ix == 0 && iy == 3) result = dither[0][3];\n   \telse if (ix == 1 && iy == 3) result = dither[1][3];\n   \telse if (ix == 2 && iy == 3) result = dither[2][3];\n   \telse if (ix == 3 && iy == 3) result = dither[3][3];\n           \n    return 1.0 - result/16.0;\n}\n\nvec3 getColor( in vec2 uv, in vec3 c, in int mode)\n{\n    if(mode == 0){\n        // full color\n        // フルカラー\n        return c;\n    }\n    else if(mode == 1) {\n        // R, G, B brightness are binarized\n        // R,G,B それぞれの輝度レベルを二値化\n        return step(vec3(0.5), c);\n    }\n    else if(mode == 2){\n        // ordered dither 4x4 \n        // オーダードディザ法\n        float d = getDither(uv);\n#if 1          \n        vec3 closestColor = step(vec3(0.5), c);\n        vec3 secondClosestColor = vec3(1.) - closestColor;\n        vec3 distance = abs(closestColor - c);\n        return mix(closestColor, secondClosestColor, step(d, distance));\n#else        \n        // クオリティーに問題あるけど 一番簡単な方法\n        return step(vec3(d), c);\n#endif        \n    }\n}\n\n\n    \nvec3 putColor( in vec2 uv, in vec3 c, int mode)\n{\n#if 1\n    // LinearToGamma\n    return  pow(getColor(uv, c, mode), vec3(1./2.2) );\n#else    \n    return  getColor(uv, c, mode);\n#endif    \n}\n\n\nvec3 hsv2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return (c.z * mix( vec3(1.0),(rgb), c.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 color0 = (vec3(1,0,1));\n    vec3 color1 = (vec3(0,1,0));\n    vec3 color2 = (vec3(0,0,1));\n    vec3 color3 = (vec3(1,0,0));\n    vec3 color4 = (vec3(1,1,0));\n    vec3 color5 = (vec3(0,1,1));\n    vec3 color6 = (vec3(1,1,1));\n    \n    vec3 col = vec3(0);\n    \n    int wait_sec=2;\n    int mode = int(mod(iTime,3.*float(wait_sec)))/wait_sec;\n    \n    // hsv\n    col = getColor( uv, hsv2rgb( vec3(uv.x,1,1)), mode);\n    \n    // グレイスケール表示\n    // dispaly grayscale\n    {\n        float bar_h = 0.08;\n        for(int i = 0; i < 7; i++)\n        {\n            if(uv.y < 1.0 - (bar_h * float(i)) && uv.y > 1.0 - (bar_h * (float(i) +1.0)))\n            {\n                if(i==0){\n                    col = mix(vec3(0), color0, uv.x);\n                }else if(i==1){\n                    col = mix(vec3(0), color1, uv.x);\n                }else if(i==2){\n                    col = mix(vec3(0), color2, uv.x);\n                }else if(i==3){\n                    col = mix(vec3(0), color3, uv.x);\n                }else if(i==4){\n                    col = mix(vec3(0), color4, uv.x);\n                }else if(i==5){\n                    col = mix(vec3(0), color5, uv.x);\n                }else if(i==6){\n                    col = mix(vec3(0), color6, uv.x);\n                }\n            }\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(putColor(uv, col, mode),1.0);\n}","name":"Image","description":"","type":"image"}]}