{"ver":"0.1","info":{"id":"MlcBRr","date":"1540572691","viewed":96,"name":"First Environment Shader","username":"Shadeyboi","description":"Dungeony Hallway?","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["environment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define repeat(v, r) (mod(v, r)-r/2.)\n\nstruct Shape{\n  float dist;\n  vec4 color;\n};\n\n\n    \n//=======================\n// Utility Functions\n//=======================\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}    \n    \n    \n// Maximum/minumum elements of a vector    \nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}    \n    \n    \nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))*46556.2);\n}\n\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n\n\nfloat pole(vec2 v, float r){\n  return length(v)-r;\n}\n\nfloat sphere(vec3 v, float r){\n  return length(v)-r;\n}\n\n\n\n\n// ============================\n// http://mercury.sexy/hg_sdf/\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\n// We can just call Union since stairs are symmetric.\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, -b, r, n);\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat fOpUnionChamfer(float a, float b, float r) {\n\treturn min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\n\n// ============================\n\n\n\nfloat mixColors(float r, float v, float z){\n  return clamp(0.5+0.5*(v-r)/z, 0., 1.);\n}\n\nfloat mixShapes(float v, float f, float r){\n  float z = mixColors(v, f, r);\n  return mix(f,v,z)-r*z*(1.-z);\n}\n\nfloat pModPolar(inout vec2 v, float r){\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x)+f*0.5;\n  float m = floor(z/f);\n  z = mod(z, f)-f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\n\n\n//=======================\n\nShape Hallway(vec3 c){\n  Shape shape;\n    vec4 color = vec4(.65);\n    vec3 a = c;\n    vec3 l = c;\n    vec3 f = c;\n    vec3 s = c;\n    vec3 co = c;\n    \n    c.z = repeat(c.z, 2.);\n    a.z = repeat(a.z, 1.5);\n    l.z = repeat(l.z, 3.);\n    f.z = repeat(f.z, 2.);\n    s.z = repeat(s.z, 3.);\n    co.z = repeat(co.z, 2.);\n    \n    c.x = abs(c.x)-.5;\n    vec4 colColor = vec4(.4, .4, .1, .9);\n    float b1 = fBox(c-vec3(0.7, .0, 0.), vec3(.2, 1.1, 0.2)); //Columns\n    float b2 = fBox(c-vec3(0.7, .8, 0.), vec3(.3, 0.1, 1.)); //Connectors\n    \n    co.x = abs(co.x)-.5;\n    co.z = abs(co.z)-.4;\n    float c1 = fBox(co-vec3(.5, -.1, -0.2), vec3(.1, .617, .1)); //Corner Cutouts\n    \n    a.xy *= rot(-a.x*.5);\n    vec4 roofColor = vec4(.5, .5, .3, 1.);\n    float b3 = fBox(a-vec3(0., 1.1, 0.), vec3(.42, .1, .8)); //Roof\n    \n    vec4 flColor = vec4(.8, .8, 0., .7);\n    float fl = fBox(f-vec3(0., -.9, 0.), vec3(1.4, .05, 1.)); //Floor\n    \n    l.yz *= rot(radians(90.));\n    vec4 lColor = vec4(1., 1., 0., 1.);\n    float lights = sdCone(l-vec3(0., 0., -.8), vec2(.7, .3));\n    \n    vec4 sColor = vec4(1., 1., 0., 1.);\n    float sOrb = sphere(s-vec3(0., .9, 0.), .05);\n    s.z = repeat(s.z, 1.2);\n    s.x = abs(s.x)-.2;\n    s.z = abs(s.z)-.3;\n    s.xz *= random(s.xz)*2.;\n    float sDrops = sphere(s-vec3(0., -.8, 0.), .01);\n    \n    shape.dist = fOpUnionStairs(b1, b2, .2, 5.);\n    shape.dist = fOpUnionChamfer(b3, shape.dist, .05);\n    shape.dist = fOpUnionStairs(shape.dist, fl, .2, 3.);\n    shape.dist = min(shape.dist, lights);\n    shape.dist = fOpUnionRound(shape.dist, sOrb, .1);\n    shape.dist = max(shape.dist, -c1);\n    shape.dist = min(shape.dist, sDrops);\n    \n    shape.color = color;\n    shape.color = mix(roofColor, colColor, mixColors(b1, b3, .5));\n    shape.color = mix(shape.color, flColor, mixColors(fl, shape.dist, .5));\n    shape.color = mix(shape.color, lColor, mixColors(lights, shape.dist, .5));\n    shape.color = mix(shape.color, sColor, mixColors(sOrb, shape.dist, .5));\n    \n  return shape;\n}\n\n\nShape map(vec3 c){\n  Shape hall = Hallway(c);\n  return hall;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n\n  \n  vec3 cam = vec3(0., 0., iTime);\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  fragColor = vec4(0.);\n\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.0001){\n      fragColor = c.color*(1.-z); // Hit  - invert pixels\n      break;\n    }\n    scene += f * c.dist;\n\n  }\n}\n","name":"Image","description":"","type":"image"}]}