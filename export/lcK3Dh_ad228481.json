{"ver":"0.1","info":{"id":"lcK3Dh","date":"1712710287","viewed":532,"name":"Magabom","username":"MonterMan","description":"My 4k executable graphics entry at Revision 2024, placed 9th out of 11, pouet page: https://www.pouet.net/prod.php?which=96633","likes":45,"published":1,"flags":32,"usePreview":0,"tags":["magabom"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    col = pow(col, vec3(0.9, 0.95, 1.0));\n    col = mix(ACESFilm(col*0.75), col, 0.3);\n    col = sqrt(col);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159265359\n#define INV_PI 0.31830988618\nuvec2 tea(uvec4 k)\n{\n    uvec2 v = uvec2(0);\n    uint delta=0x9E3779B9u;                     /* a key schedule constant */\n    uint sum = 0u;\n    for (int i=0; i<32; i++) {     /* basic cycle start */\n        sum += delta;\n        v.x += ((v.y<<4) + k.x) ^ (v.y + sum) ^ ((v.y>>5) + k.y);\n        v.y += ((v.x<<4) + k.z) ^ (v.x + sum) ^ ((v.x>>5) + k.w);\n    }                                              /* end cycle */\n    return v;\n}\n\nvec2 teaf(uvec4 k)\n{\n    return vec2(tea(k)) / vec2(0xffffffffu);\n}\n\nvec2 drawRand2(inout uvec4 state)\n{\n    vec2 result = teaf(state);\n    state.w += 1u;\n    return result;\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdEllipsoid(vec3 p, vec3 r)\n{\n    float l = length(p/r);\n    float grad = length(p/(r*r))/l;\n    return (l-1.0)/grad;\n}\n\n// TODO: this SDF is inexact, fix\nfloat sdStick(vec3 p, vec3 a, vec3 b, float r_a, float r_b)\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = clamp(dot(ab, ap) / dot(ab, ab), 0.0, 1.0);\n    return length(ap - t * ab) - mix(r_a, r_b, smoothstep(0.0,1.0,t));\n}\n\nfloat sdPyramid( vec3 p, float h )\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\nfloat sdBox2(vec2 p, vec2 dim)\n{\n    vec2 q = abs(p) - 0.5*dim;\n    return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0);\n}\n\nfloat sdCylinder(vec3 p, float h, float r)\n{\n    return sdBox2(vec2(length(p.xz), p.y), vec2(r, h));\n}\n\nfloat smin(float a, float b, float k)\n{\n    float term = max(0.0, k - abs(a - b));\n    return min(a, b) - 0.25/k*term*term;\n}\n\nfloat smax(float a, float b, float k)\n{\n    float term = max(0.0, k - abs(a - b));\n    return max(a, b) + 0.25/k*term*term;\n}\n\nmat2 rot2d(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(\n        c, -s,\n        s, c);\n}\n\nfloat opMod1(float x, float period)\n{\n    return mod(x+0.5*period, period) - 0.5*period;\n}\n\nfloat opModLim1(float x, float period, float count, out float outId)\n{\n    float k = (x+0.5*period) / period;\n    float ki = floor(k);\n    outId = ki;\n    k -= sign(ki) * min(abs(ki), count);\n    return period*k - 0.5*period;\n}\n\nvec2 opModPolar(vec2 p, float periodRadians)\n{\n    float r = length(p);\n    float theta = atan(p.y, p.x);\n    \n    theta = opMod1(theta, periodRadians);\n    \n    return vec2(cos(theta), sin(theta)) * r;\n}\n\nvec2 opModPolarLim(vec2 p, float periodRadians, float count, out float outId)\n{\n    float r = length(p);\n    float theta = atan(p.y, p.x);\n    \n    theta = opModLim1(theta, periodRadians, count, outId);\n    \n    return vec2(cos(theta), sin(theta)) * r;\n}\n\nvec2 opMod2(vec2 p, vec2 period, out vec2 outId)\n{\n    vec2 halfPeriod = 0.5*period;\n    outId = floor((p+halfPeriod)/period);\n    return mod(p+halfPeriod, period)-halfPeriod;\n}\n\nmat3 calcTBN(vec3 normal)\n{\n    vec3 tangent = normalize(cross((abs(normal.y) < 0.999)? vec3(0, 1, 0): vec3(1, 0, 0), normal));\n    vec3 bitangent = cross(normal, tangent);\n    return mat3(tangent, bitangent, normal);\n}\n\nfloat smithGeom(vec3 w, vec2 roughness)\n{\n    vec2 roughness2 = roughness*roughness;\n    float k = (roughness2.x*w.x*w.x + roughness.y*w.y*w.y) / (w.z*w.z);\n    float term = (-1.0 + sqrt(1.0 + k)) / 2.0;\n    return 1.0 / (1.0 + term);\n}\n\nvec3 sampleHemisphereCosine(vec2 rand, out float outPdf)\n{\n    float r = sqrt(rand.x);\n    float theta = 2.0 * PI * rand.y;\n    float h = sqrt(1.0-r*r);\n    outPdf = h * INV_PI;\n    return vec3(r*cos(theta), r*sin(theta), h);\n}\n\nvec3 sampleConeCosine(vec2 rand, float aperture)\n{\n    float r = aperture*sqrt(rand.x);\n    float theta = 2.0 * PI * rand.y;\n    float h = sqrt(1.0-r*r);\n    return vec3(r*cos(theta), r*sin(theta), h);\n}\n\nvec3 lambertBrdf(vec3 albedo)\n{\n    return albedo * INV_PI;\n}\n\nvec3 burleyDiffuseBrdf(vec3 albedo, float roughness, float idotn, float odotn, float idotm)\n{\n    float fd90 = 0.5 + 2.0*roughness*idotm*idotm;\n    \n    return albedo*INV_PI*(1.0 + (fd90 - 1.0)*pow(1.0 - idotn, 5.0))*\n                         (1.0 + (fd90 - 1.0)*pow(1.0 - odotn, 5.0));\n}\n\n// source: https://jcgt.org/published/0007/04/01/paper.pdf\n//         \"Sampling the GGX Distribution of Visible Normals\" by Eric Heitz\n//\n// Input Ve: view direction\n// Input alpha_x, alpha_y: roughness parameters\n// Input U1, U2: uniform random numbers\n// Output Ne: normal sampled with PDF D_Ve(Ne) = G1(Ve) * max(0, dot(Ve, Ne)) * D(Ne) / Ve.z\nvec3 sampleGGXVNDF(vec3 Ve, float alpha_x, float alpha_y, float U1, float U2)\n{\n    // Section 3.2: transforming the view direction to the hemisphere configuration\n    vec3 Vh = normalize(vec3(alpha_x * Ve.x, alpha_y * Ve.y, Ve.z));\n    // Section 4.1: orthonormal basis (with special case if cross product is zero)\n    float lensq = Vh.x * Vh.x + Vh.y * Vh.y;\n    vec3 T1 = lensq > 0.0 ? vec3(-Vh.y, Vh.x, 0) * inversesqrt(lensq) : vec3(1,0,0);\n    vec3 T2 = cross(Vh, T1);\n    // Section 4.2: parameterization of the projected area\n    float r = sqrt(U1);\n    float phi = 2.0 * PI * U2;\n    float t1 = r * cos(phi);\n    float t2 = r * sin(phi);\n    float s = 0.5 * (1.0 + Vh.z);\n    t2 = (1.0 - s)*sqrt(1.0 - t1*t1) + s*t2;\n    // Section 4.3: reprojection onto hemisphere\n    vec3 Nh = t1*T1 + t2*T2 + sqrt(max(0.0, 1.0 - t1*t1 - t2*t2))*Vh;\n    // Section 3.4: transforming the normal back to the ellipsoid configuration\n    vec3 Ne = normalize(vec3(alpha_x * Nh.x, alpha_y * Nh.y, max(0.0, Nh.z)));\n    return Ne;\n}\n\nfloat GGXNDF(vec3 wm, vec2 a)\n{\n    vec3 wm2 = wm*wm;\n    float k = wm2.x/(a.x*a.x) + wm2.y/(a.y*a.y) + wm2.z;\n    return 1.0 / (PI * a.x * a.y * k*k);\n}\n\nvec3 fresnelSchlick(vec3 f0, float idotm)\n{\n    return f0 + (1.0 - f0)*(1.0 - pow(idotm, 5.0));\n}\n\nvec3 calcSpecularBrdf(vec3 wo, vec3 wi, vec3 wm, vec2 roughness, \n                      vec3 f0)\n{\n    float D = GGXNDF(wm, roughness);\n    float G = smithGeom(wi, roughness) * smithGeom(wo, roughness);\n    vec3 F = fresnelSchlick(f0, dot(wi, wm));\n    return F * D * G / (4.0 * wo.z * wi.z + 0.0001);\n}\n\nfloat noise2(vec2 p)\n{\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    float a = hash12(ip + vec2(0, 0));\n    float b = hash12(ip + vec2(1, 0));\n    float c = hash12(ip + vec2(0, 1));\n    float d = hash12(ip + vec2(1, 1));\n    vec2 t = smoothstep(vec2(0), vec2(1), fp);\n    \n    return mix(mix(a, b, t.x),\n               mix(c, d, t.x),\n               t.y);\n}\n\nfloat fbm2(vec2 p)\n{\n    float res = 0.0;\n    float amp = 0.5;\n    for (int i = 0; i < 5; ++i)\n    {\n        res += amp * noise2(p);\n        p *= 2.0;\n        amp /= 2.0;\n    }\n    return res;\n}\n\n#define T_MAX 100.0\n\nstruct Query\n{\n    float d;\n    int id;\n};\n\n// material\n// body = 0\n// floor = 1\n// eye = 2\n// tongue = 3\n// spike = 4\n// tree trunk 6\n// tree leaves 7\n// apple 8\n// apple meat 9\n\nstruct Material\n{\n    vec3 albedo; // albedo\n    float roughness; // roughness\n    float specularW; // specularW\n    vec3 f0;\n};\n\nvoid update(inout Query query, float dist, int matId)\n{\n    if (dist < query.d)\n    {\n        query.d = dist;\n        query.id = matId;\n    }  \n}\n\nvoid updateApple(inout Query query, vec3 p, int matId, float s)\n{\n    p /= s;\n    \n    {\n        vec3 q = p;\n        q.y -= 0.2;\n        q.xy *= rot2d(4.0*q.y);\n        float dStem = sdCylinder(q, 0.1, 0.01);\n        update(query, s*dStem, 6);\n    }\n\n    p.y -= 0.3*pow(0.001+dot(p.xz, p.xz), 0.2) - 0.01;\n    float d = sdSphere(p, 0.12);\n    float botCap = (p.y + 0.095);\n    d = smax(d, -botCap, 0.02);\n    update(query, s*d, matId);\n}\n\nQuery map(vec3 p, float time)\n{\n    Query query;\n    // floor\n    query.d = p.y;\n    query.id = 1;\n        \n    // main body\n    vec3 q = p - vec3(0, 0.49, 0);\n    q.xz *= rot2d(0.6*(1.0+0.2*cos(time))*q.z);\n    q.y *= 1.05;\n    float bodyGuardDist = sdSphere(q, 1.2);\n    if (bodyGuardDist < 0.05)\n    {\n        vec3 bq = q;\n        // torso\n        bq.yz *= rot2d(1.2);\n        float d = sdEllipsoid(bq, vec3(0.4, 0.6, 0.4));\n        \n        // cheeks\n        vec3 cq = q;\n        d = smin(d, sdEllipsoid(cq-vec3(0, 0.07, -0.4), vec3(0.28, 0.16, 0.13)), 0.07);\n        \n        // arms\n        vec3 aq = q;\n        aq.x = abs(aq.x);\n        aq.x -= 0.21;\n        float dArm = sdStick(aq-vec3(0, -0.08, -0.38),\n                            vec3(0),\n                            vec3(0.05, -0.03, -0.04),\n                            0.05, 0.06);\n        d = smin(d, dArm, 0.03);\n        float dHand = sdStick(aq-vec3(0, -0.08, -0.38),\n                            vec3(0.07, -0.03, -0.04),\n                            vec3(0.03, -0.03, -0.08),\n                            0.03, 0.04);\n        d = smin(d, smin(dHand, dArm, 0.04), 0.002);\n        \n        // legs\n        vec3 lq = q;\n        lq.x = abs(lq.x) - 0.25;\n        float dLegs = sdStick(lq-vec3(0, -0.4, 0.0),\n                              vec3(0, -0.1, 0),\n                              vec3(-0.03, 0.2, 0),\n                              0.1, 0.16);\n        dLegs = smax(dLegs, -(p.y + 0.01), 0.03);\n        d = smin(d, dLegs, 0.15);\n        \n        // tail\n        vec3 taq = q - vec3(0, 0.05, 1.53);\n        taq.yz *= rot2d(0.7*(1.2 + taq.z));\n        float dTail = sdStick(taq, vec3(0, 0, -0.95), vec3(0, 0, -0.51), 0.14, 0.07);\n        d = smin(d, dTail, 0.2);\n        \n        // tail spikes\n        {\n            taq.y -= 0.085;\n            taq.z += 0.65;\n            taq.yz *= rot2d(-0.15);\n            float spikeId;\n            taq.z = opModLim1(taq.z, 0.09, 2.0, spikeId);\n            float s = 0.06 - clamp(0.01*(spikeId+3.0), 0.0, 0.055);\n            float sd = (sdPyramid(taq/s, 0.8)*s) - 0.015;\n            update(query, sd, 4);\n        }\n        \n        // mouth\n        vec3 mq = q;\n\n        mq.y += 0.01*cos(70.0*mq.x);\n        float dMouth = sdEllipsoid(mq-vec3(0, 0.05, -0.5), vec3(0.15, 0.055 + 0.01*cos(2.0*time+7.9), 0.1));\n        d = smax(d, -dMouth, 0.02);\n\n        update(query, d, 0);\n  \n        // eyes\n        vec3 eq = q;\n        eq.x = abs(eq.x) - 0.14;\n        float ed = sdEllipsoid(eq-vec3(0.02, 0.16, -0.53),\n                               vec3(0.02, 0.03, 0.015));\n        update(query, ed, 2);\n        \n        // tongue\n        vec3 tq = q;\n        float td = sdEllipsoid(tq-vec3(0, -0.04, -0.48), vec3(0.14, 0.09, 0.04));\n        td = max(td, -(p.y - 0.45));\n        update(query, td, 3);\n\n        // spikes\n        {\n            q.y += 0.52;\n            float s = 0.175;\n            float spikeId;\n            q.y *= 1.15;\n            q.yz *= rot2d(-0.5);\n            q.z -= -0.2;\n            q.yz = opModPolarLim(q.yz, 0.20, 2.0, spikeId);\n            s -= clamp(0.055*spikeId, 0.0, 0.15);\n            q -= vec3(0, 0.94, 0.0);\n            float d = (sdPyramid(q/s, 0.9)*s) - 0.035;\n            \n            update(query, d, 4);\n        }\n    }\n    else\n    {\n        update(query, bodyGuardDist, 0);\n    }\n    \n    // tree\n    {\n        vec3 q = p;\n        vec2 treeId;\n        q.xz -= vec2(3.0, 5.2);\n        q.xz *= rot2d(PI/4.5);\n        q.xz = opMod2(q.xz, vec2(4.0), treeId);\n        \n        {\n            vec3 rand = hash32(treeId);\n            \n            q.xz += vec2(0.75) * (rand.xy - 0.5);\n            q.xz *= rot2d(2.0*PI*rand.z);\n            \n            float treeH = 2.0;\n            \n            // tree trunk\n            q.xz += 0.05*sin(q.y);\n            float sdTrunk = sdCylinder(q-vec3(0,0.5,0.0), treeH, 0.5);\n            {\n                vec3 bq = q;\n                bq.xz = opModPolar(bq.xz, 1.3);\n                bq.x -= 0.5;\n                sdTrunk = smin(sdTrunk, sdStick(bq, vec3(-0.5,0.2,0),\n                                                vec3(0.15,-0.1,0),\n                                                0.1, 0.05), 0.05);\n            }\n            update(query, sdTrunk, 6);\n\n            float sdLeaves = sdSphere(q-vec3(0,treeH,0), 0.5);\n            sdLeaves = min(sdLeaves, sdSphere(q-vec3(-0.3,treeH-0.5,0), 0.55));\n            sdLeaves = min(sdLeaves, sdSphere(q-vec3(0.3,treeH-0.5,0), 0.55));\n            update(query, sdLeaves, 7);\n            \n            updateApple(query, q-vec3(-0.55,treeH-0.5,0.45), 8, 1.0);\n        }\n        \n        updateApple(query, p-vec3(0.65, 0.0, 0.0), 8, 1.0);\n\n        {\n            vec3 q = p;\n            q -= vec3(-0.03, 0.35, -0.6);\n            q.yz *= rot2d(0.6);\n            updateApple(query, q, 8, 0.7);\n            \n            q.xz *= rot2d(-0.2);\n            \n            {\n                vec3 bq = q;\n                bq.y -= 0.015*cos(100.0*bq.z);\n                float dBite = sdEllipsoid(bq-vec3(0.1,0.1,0), vec3(0.07, 0.06, 0.08));\n                query.d = max(query.d, -dBite);\n            }\n            \n            updateApple(query, q, 9, 0.66);\n            \n            {\n                vec3 bq = q;\n                bq.y -= 0.015*cos(100.0*bq.z);\n                float dBite = sdEllipsoid(bq-vec3(0.1,0.1,0), vec3(0.07, 0.06, 0.08));\n                query.d = max(query.d, -dBite);\n            }\n        }\n    }\n\n    return query;\n}\n\n// https://iquilezles.org/articles/normalsSDF/\nvec3 calc_normal( in vec3 p, float time) // for function f(p)\n{\n    const float h = 0.001;      // replace by an appropriate value\n    vec3 n = vec3(0.0);\n    for( int i=min(iFrame,0); i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*h, time).d;\n    }\n    return normalize(n);\n}\n\nfloat sdSegment1d(vec2 p, float a, float b)\n{\n    if (p.x < a)\n    {\n        return sqrt(p.y*p.y + (p.x-a)*(p.x-a));\n    }\n    if (p.x > b)\n    {\n        return sqrt(p.y*p.y + (p.x-b)*(p.x-b));\n    }\n    return p.y;\n}\n\nMaterial evalMaterial(vec3 p, vec3 n, float time, int mat_id)\n{\n    vec3 q = p;\n    q.xz *= rot2d(0.6*(1.0+0.2*cos(time))*q.z);\n\n    vec3 albedo = vec3(0.8, 0.1, 0.8);\n    float roughness = 1.0;\n    float specularW = 0.0;\n    vec3 f0 = vec3(0.02);\n    if (mat_id == 0)\n    {\n        vec3 oq = q;\n        q.x = abs(q.x);\n        q-=vec3(0.21,0.58,-0.5);\n        q.xy *= vec2(1.3, 1.7);\n\n        vec3 skinCol = vec3(0.5, 0.6, 0.9);\n        vec3 cheekCol = vec3(0.74, 0.45, 0.7);\n        albedo = mix(skinCol, cheekCol, exp(-300.*dot(q, q)));\n\n        vec3 sq = oq;\n        float backSkinDist = sdSegment1d(sq.zx, -0.1, 0.4) - 0.2;\n        backSkinDist = smin(backSkinDist, sdSegment1d(sq.zx, 0.4, 1.1) - 0.055, 0.3);\n        backSkinDist += 0.01*cos(40.0*sq.z);\n        vec3 ogAlbedo = albedo;\n        albedo = mix(albedo, vec3(0.5, 0.38, 0.8),\n                     (n.y>-0.2? 1.0: 0.0)*(1.0-smoothstep(-0.01, 0.01, backSkinDist)));\n        if (sq.y < 0.1)\n        {\n            albedo = ogAlbedo;\n        }\n        \n        specularW = 0.1;\n        roughness = 0.85;\n    }\n    if (mat_id == 1)\n    {\n        albedo = mix(vec3(0.4, 0.55, 0.2), // old grass col\n                     vec3(0.55, 0.6, 0.2), // young grass col\n                     fbm2(2.0*p.xz));\n    }\n    if (mat_id == 2)\n    {\n        albedo = vec3(0.01);\n        specularW = 0.2;\n        roughness = 0.15;\n    }\n    if (mat_id == 3)\n    {\n        albedo = vec3(0.85, 0.2, 0.3);\n    }\n    if (mat_id == 4)\n    {\n        albedo = vec3(0.5, 0.38, 0.8);\n        specularW = 0.5;\n        roughness = 0.25;\n    }\n    if (mat_id == 6)\n    {\n        albedo = vec3(0.3,0.15,0.1);\n        specularW = 0.0;\n        roughness = 1.0;\n    }\n    if (mat_id == 7)\n    {\n        albedo = vec3(0.4, 0.6, 0.2);\n        specularW = 0.0;\n        roughness = 1.0;\n    }\n    if (mat_id == 8)\n    {\n        albedo = vec3(0.9, 0.1, 0.1);\n        specularW = 0.3;\n        roughness = 0.8;\n    }\n    if (mat_id == 9)\n    {\n        albedo = vec3(0.9, 0.75, 0.5);\n        specularW = 0.1;\n        roughness = 0.8;\n    }\n    \n    Material result;\n    result.albedo = albedo;\n    result.roughness = roughness;\n    result.specularW = specularW;\n    result.f0 = f0;\n    return result;\n}\n\nvec3 calcSkyCol(vec3 rd)\n{\n    float h = max(0.0, rd.y);\n    return mix(vec3(0.4,0.6,0.9), vec3(0.75, 0.78, 0.8), exp(-5.0*h));\n}\n\nvec3 calcSunCol()\n{\n    return vec3(1.1, 0.85, 0.75);\n}\n\nfloat traceRay(vec3 ro, vec3 rd, float time, out int outMatId)\n{\n    outMatId = -1;\n    float t = 0.0;\n    for (int i = 0; i < 512 && t < T_MAX; ++i)\n    {\n        Query query = map(ro + t*rd, time);\n        float dist = query.d;\n        if (abs(dist) < 0.001)\n        {\n            outMatId = query.id;\n            break;\n        }\n        t += 0.65*dist;\n    }\n    return t;\n}\n\nvec3 renderPT(vec3 ro, vec3 rd, float time, inout uvec4 randState)\n{\n    vec3 radiance = vec3(0);\n    \n    vec3 throughput = vec3(1);\n    for (int bounce_i = 0; bounce_i < 5; ++bounce_i)\n    {\n        int matId = -1;\n        float hitT = traceRay(ro, rd, time, matId);\n        if (matId != -1)\n        {\n            vec3 hitP = ro + hitT * rd;\n            vec3 n = calc_normal(hitP, time);\n           \n            mat3 tbn = calcTBN(n);\n            mat3 invTbn = transpose(tbn);\n            vec3 wo = invTbn * -rd;\n            Material mat = evalMaterial(hitP, n, time, matId);\n            \n            // direct lighting\n            {\n                // sample direct light cone\n                vec3 l = calcTBN(normalize(vec3(0.7, 0.9, -0.8))) *\n                         sampleConeCosine(drawRand2(randState), 0.03);\n                \n                int hitMatId = -1;\n                float t = traceRay(hitP + 0.001*n, l, time, hitMatId);\n                if (t >= T_MAX)\n                {\n                    vec3 wi = invTbn * l;\n                    vec3 wm = normalize(wi + wo);\n                    vec3 brdf = vec3(0);\n                    brdf += mat.specularW * calcSpecularBrdf(wo, wi, wm,\n                                                     vec2(mat.roughness),\n                                                     mat.f0);\n                    brdf += (1.0 - mat.specularW) * \n                            burleyDiffuseBrdf(mat.albedo, mat.roughness,\n                                              wi.z, wo.z, dot(wi, wm));\n\n                    vec3 sunCol = calcSunCol();\n                    if (matId == 2)\n                    {\n                        sunCol *= 8.0;\n                    }\n                    radiance += throughput * brdf * sunCol * wi.z;\n                }\n            }\n\n            vec3 wi = vec3(0);\n            \n            if (drawRand2(randState).x < mat.specularW)\n            {\n                float alpha = mat.roughness*mat.roughness;\n                vec2 u = drawRand2(randState);\n                vec3 wm = sampleGGXVNDF(wo, alpha, alpha, u.x, u.y);\n                wi = reflect(-wo, wm);\n                \n                vec3 F = fresnelSchlick(mat.f0, dot(wi, wm));\n                throughput *= F * smithGeom(wi, vec2(alpha));\n            }\n            else\n            {\n                float pdf;\n                wi = sampleHemisphereCosine(drawRand2(randState), pdf);\n                vec3 wm = normalize(wo + wi);\n                vec3 brdf = burleyDiffuseBrdf(mat.albedo, mat.roughness,\n                                              wi.z, wo.z, dot(wi, wm));\n\n                if (abs(pdf) < 0.00001)\n                {\n                    break;\n                }\n\n                throughput *= brdf * wi.z / pdf;\n            }\n\n            ro = hitP + 0.001*n;\n            rd = tbn * wi;\n        }\n        else\n        {\n            radiance += throughput * calcSkyCol(rd);\n            break;\n        }\n    }\n    \n    return radiance;\n}\n\nvec2 sampleLens(vec2 rand)\n{\n    float r = sqrt(rand.x);\n    float theta = 2.0 * PI * rand.y;\n    return 0.5 * r * vec2(cos(theta), sin(theta));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv = 2.0 * uv - 1.0;\n    float ar = iResolution.x / iResolution.y;\n    uv.x *= ar;\n    vec2 pixelDim = vec2(2.0 * ar, 2.0) / iResolution.xy;\n    \n    uvec4 randState = uvec4(uvec2(fragCoord.xy), iFrame, 0);\n\n    vec3 ro = vec3(0.7, 0.7, -1.0);\n    ro.xz *= 0.98;\n    vec3 at = vec3(-0.04, 0.5, 0);\n\n    // DoF parameters\n    float focalDist = 0.78;\n    float aperture = 0.02;\n\n    vec3 cam_z = normalize(at - ro);\n    vec3 cam_x = normalize(cross(vec3(0, 1, 0), cam_z));\n    vec3 cam_y = cross(cam_z, cam_x);\n    mat3 camToWorld = mat3(cam_x, cam_y, cam_z);\n\n    vec2 jittered_uv = uv + sampleLens(drawRand2(randState)) * pixelDim;\n    vec3 rdLocal = normalize(vec3(jittered_uv, 1.4));\n    vec3 rd = camToWorld * rdLocal;\n\n    // apply thin lens model\n    vec3 focalP = ro + rd * (focalDist / rdLocal.z);\n    ro += camToWorld * vec3(aperture * (drawRand2(randState) - 0.5), 0.0);\n    rd = normalize(focalP - ro);\n\n    vec3 col = renderPT(ro, rd, 0.0, randState);\n    col = min(col, vec3(10.0));\n\n    vec3 prevCol = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    float sampleW = 1.0 / float(iFrame + 1);\n    col = mix(prevCol, col, sampleW);\n\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}