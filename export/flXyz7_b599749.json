{"ver":"0.1","info":{"id":"flXyz7","date":"1647626844","viewed":98,"name":"In, out and around the Sevenfold","username":"Tzapetto","description":"This fractal differs from usual kaleidoscopic fractals in that it doesn't use reflections. The copies of the fractal going around in the circle all have the same rotation direction. This is achieved with the nGonFold function.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["fractal","polar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*--------------SETTINS--------------*/\n\n#define ZOOM\n\n#define CAMERA_ROTATION\n\n#define FRACTAL_ROTATION\n\n#define MIN_ZOOM 0.005\n\n#define MAX_ZOOM 1.\n\n#define CAMERA_ROTATION_SPEED -1./3.\n\n#define CAMERA_INIT_ANGLE 0.\n\n#define FRACTAL_ROTATION_SPEED 1./5.\n\n#define FRACTAL_INIT_ANGLE 0.\n\n/*-----------------------------------*/\n\n\n#define pi 3.1415926535\n\n\n// Tranformations between polar and cartesian coordinates\nvoid toPolar(inout vec2 p) {\n    float r = length(p);\n    p.y = atan(p.y, p.x);\n    p.x = r;\n}\n\nvoid toCartesian(inout vec2 p) {\n    float c = cos(p.y);\n    float s = sin(p.y);\n    p.y = p.x * s;\n    p.x = p.x * c;\n}\n\n\n// Creates rotation matrix\nmat2x2 makeRotMatrix(float rad) {\n    float c = cos(rad), s = sin(rad);\n    return mat2x2(c, -s, s, c);\n}\n\n\n// Folds\nvoid planeFold(inout vec3 p, vec2 n, float d) {\n\tp.xy -= 2.0 * min(0.0, dot(p.xy, n) - d) * n;\n}\n\nvoid nGonFold(inout vec3 p, int n) {\n    vec2 p_t = p.xy;\n    toPolar(p_t);\n    float theta = 2.*pi / float(n);\n    p_t.y = mod(p_t.y + theta/2., theta) - theta/2.;\n    toCartesian(p_t);\n    p.xy = p_t;\n}\n\n\n// Scale, Translation, Rotation\nvoid scaleTranslate(inout vec3 p, vec2 t, float s) {\n    p.xy -= t;\n    p /= s;\n    p.z = abs(p.z);\n}\n\nvoid rot(inout vec3 p, mat2x2 r) {\n    p.xy = r * p.xy;\n}\n\n\n// Distance functions\nfloat de_circle(vec3 p, float r) {\n\treturn (length(p.xy) - r) / p.z;\n}\n\n\n// Fractal\nfloat fractalSDF(inout vec3 p, int num_it, float rotation_speed, float init_angle) {\n    mat2x2 r = makeRotMatrix(-iTime * rotation_speed - init_angle);\n    \n    float s = 0.29;\n    float reflect_d = 0.33333;\n    \n    int i;\n    for(i = 0; i < num_it; i++)\n    {   \n        nGonFold(p, 7);\n        planeFold(p, vec2(1., 0.), reflect_d);\n        scaleTranslate(p, vec2(2./3., 0.), s);\n        rot(p, r);\n    }\n    \n    float d = de_circle(p, 1.);\n    return d;\n}\n\n\n// Main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - iResolution.xy / 2.) / (min(iResolution.x, iResolution.y) / 2.);\n    \n    // Initialize values\n    float zoom = 1.;\n    float camera_rotation_speed = 0.;\n    float fractal_rotation_speed = 0.;\n    \n    // Change values using settings\n    #ifdef ZOOM\n        float t = (0.5 + 0.5*cos(iTime * 0.3));\n\n        //zoom = MIN_ZOOM + (MAX_ZOOM - MIN_ZOOM) * t;    // linear interpolation\n        zoom = pow(MIN_ZOOM, 1. - t) * pow(MAX_ZOOM, t); // log interpolation\n    #endif\n    \n    #ifdef CAMERA_ROTATION\n        camera_rotation_speed = CAMERA_ROTATION_SPEED;\n    #endif\n    \n    #ifdef FRACTAL_ROTATION\n        fractal_rotation_speed = FRACTAL_ROTATION_SPEED;\n    #endif\n    \n    // Essentially applies camera transformation\n    uv *= zoom;\n    vec3 p = vec3(uv, 1.0);\n    mat2x2 camera_r = makeRotMatrix(iTime * camera_rotation_speed + CAMERA_INIT_ANGLE);\n    rot(p, camera_r);\n    \n    // Compute SDF\n    float d = fractalSDF(p, 20, fractal_rotation_speed, FRACTAL_INIT_ANGLE);\n    \n    // Anti-aliasing\n    float pixel_size = 2. / min(iResolution.x, iResolution.y);\n    float edge_width = 0.0 * pixel_size;\n    float edge_fallof = 1. * pixel_size;\n    float normalized_d = d / zoom;\n    float col = smoothstep(edge_width + edge_fallof, edge_width, normalized_d);\n    \n    // Output to screen\n    fragColor = vec4(vec3(col),1.0);\n}","name":"Image","description":"","type":"image"}]}