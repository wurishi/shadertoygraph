{"ver":"0.1","info":{"id":"WlXfWj","date":"1597692608","viewed":200,"name":"6D Leopard","username":"snolot","description":"Test to apply triplanar mapping on sdf","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["sdf","triplanar","hair"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/************************************************************************************************\n*\n* SDF code: \n* from blackle - That's Six-Dimensional Gravy - (https://www.shadertoy.com/view/3lKGRm)\n*\n* HAIR code: \n* from pronce - 2D Fur and hair textures - (https://www.shadertoy.com/view/ttjyRc)\n*\n* TRIPLANAR code from:\n* Improved Triplanar Mapping from tux (https://www.shadertoy.com/view/lsj3z3)\n* Stochastic Triplanar Sampling from miloyip (https://www.shadertoy.com/view/3lS3Rm)\n* noise-preserving triplanar from  FabriceNeyret2  (https://www.shadertoy.com/view/3l2SDd)\n* taken from Industrial Complex  from  Shane  (https://www.shadertoy.com/view/MtdSWS)\n* N-Planar Texturing from pastasfuture (https://www.shadertoy.com/view/4sccRl)\n*\n************************************************************************************************/\n\n#define ROTATE\n#define SLICE\n#define PI 3.14159265\n\n#define R(x) fract(sin(dot(x,vec2(12.9898, 78.233))) * 43758.5453)\n\n// global parameters\nfloat HAIR_LENGTH = 60.0;\nfloat TOUSLE = 0.5;\nfloat BORDER = 1.5;\n\nfloat noise (vec2 st){\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = R(i);\n    float b = R((i + vec2(1.0, 0.0)));\n    float c = R((i + vec2(0.0, 1.0)));\n    float d = R((i + vec2(1.0, 1.0)));\n\n    vec2 u = smoothstep(0.,1.,f);\n\n    return (mix(a, b, u.x) +\n            (c - a) * u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y) * 2.0 - 1.0;\n}\n\nfloat fbm(vec2 x){\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < 5; ++i) {\n        v += a * noise(x);\n        x = rot * x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n// generate a hair patch, which is essentially just some fbm noise \n// stretched along one axis based on the rotation value a.\n// to mimic tousling of the hair a random offset is added to the \n// rotation. the hair length is derived from the actual stretch\nfloat hairpatch(vec2 u, vec2 o, float a){\n\n    a += sin(R(o) * 5.0) * TOUSLE;\n    vec2 d = vec2(1.0 / HAIR_LENGTH, .5);\n    float s = sin(a); float c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    u=m*u;\n  \n    float h = (fbm((u + o) * d * 70.0) + 1.0) / 2.0;\n     \n    h = smoothstep(0.0, 2.2, h);\n\n    return max(0.0, 1.0 - min(1.0, 1.0 - h));\n}\n\n\n// as the hair is organized in patches, each patch has some\n// smooth falloff since patches are blended together dynamically\nfloat hair(vec2 u, vec2 d, float w, float a){\n    float hr = 0.0;\n    u *= w * 4.0;\n    u += d;\n    vec2 hp = fract(u) - vec2(0.5);\n    float h = hairpatch(hp, floor(u), a);\n    return pow(h * max(1.-length(hp) * BORDER, 0.0),1.0 / 3.0);\n}\n\n// mix 9 hair patches together in order to simulate an overlapping effect\nfloat hairtexture(vec2 uv, float scale, float angle){\n    vec2 offsets[9] = vec2[9](vec2(0.), vec2(.5), vec2(-.5),\n                              vec2(.5,0.), vec2(-.5,0.),\n                              vec2(0.,.5), vec2(0.,-.5),\n                              vec2(.5,-.5), vec2(-.5,.5));\n\n    float f = 0.0;\n\n    for(int i = 0; i < 9; i++){\n        f = max(f, hair(uv, offsets[i], scale, angle));\n    } \n    \n    return smoothstep(0.0, 1.0, f);\n}\n\nvec3 hyena(vec2 uv){\n    HAIR_LENGTH = 20.0;\n    TOUSLE = 0.15;\n    BORDER = 1.5;\n    \n    float angle = (fbm(uv) + 2.0) * PI;\n    float f = hairtexture(uv, 1.0f, angle);\n    \n    // apply color look and use fbm to create darker patches\n    vec3 col = mix(vec3(0.4, 0.3, 0.25) * f * mix(2.0, 4.0, fbm(uv * 8.0)), vec3(1.0), pow(f, 4.0));\n    \n    return col;\n}\n\nvec3 leopard(vec2 uv){\n    HAIR_LENGTH = 15.0;\n    TOUSLE = 0.15;\n    BORDER = 1.5;\n    \n    float angle = (fbm(uv)-2.0) * PI * 0.25;\n    float f = hairtexture(uv, 1.0, angle);\n    \n    //generate a map that mixes between the black and yellow patches\n    float patches = min(1.0, sin(fbm(uv * 2.0) * 3.0 * PI));\n    \n    // apply both colors to the patches\n    vec3 col = mix(max(vec3(0.0), vec3(0.55, 0.37, 0.05) * f * mix(1.0, 4.0, patches)), \n                   vec3(1.0), \n                   pow(f, 4.0));\n    \n    return col;\n}\n\nvec3 woman(vec2 uv){\n    HAIR_LENGTH = 2000.0;\n    TOUSLE = 0.1;\n    BORDER = 1.25;\n    \n    float angle = (fbm(uv * 0.25)) * PI;\n    float f = hairtexture(uv * 0.5, 1.0, angle);\n    \n    // just mix in some blond strains\n    vec3 col = mix(vec3(0.8, 0.5, 0.0) * f * mix(2.0, 1.0, fbm(uv)), vec3(1.05, 0.92, 0.9), pow(f, 4.0) * 2.0);\n    \n    return col;\n}\n\n#define HAIR_FUNK(U) leopard(U)\n//#define HAIR_FUNK(U) hyena(U)\n//#define HAIR_FUNK(U) woman(U)\n\n// Wyman, Chris, and Morgan McGuire. \"Hashed alpha testing.\" \n// Proceedings of the 21st ACM SIGGRAPH Symposium on Interactive 3D Graphics and Games. ACM, 2017.\nfloat hash(vec2 p) {\n   return fract(1.0e4 * sin(17.0 * p.x + 0.1 * p.y) * (0.1 + abs(sin(13.0 * p.y + p.x))));\n}\n\nfloat hash3D(vec3 p) {\n   return hash(vec2(hash(p.xy), p.z));\n}\n\nfloat psin(float a) {\n  return 0.5 + 0.5*sin(a);\n}\n\nvec3 smin(vec3 a, vec3 b, float k) {\n  vec3 h = max(k-abs(a-b),0.)/k;\n  return min(a,b)-h*h*h*k/6.;\n}\n\nfloat obj(vec3 p) {\n\n    vec3 p1 = p;\n    #ifdef SLICE\n        vec3 p2 = vec3(asin(sin(iTime )),0,0);\n    #else\n        vec3 p2 = vec3(1,0,0);\n    #endif\n\n    #ifdef ROTATE\n    \tmat3 r11 = mat3(-0.33,-0.55,0.29,0.18,-0.055,0.24,-0.11,-0.42,-0.83);\n    \tmat3 r12 = mat3(-0.42,0.13,0.26,0.8,-0.13,0.06,-0.088,0.68,-0.29);\n    \tmat3 r22 = mat3(-0.67,-0.47,0.23,-0.07,-0.54,0.17,0.4,-0.24,0.46);\n    \tmat3 r21 = mat3(0.54,-0.29,0.31,-0.17,0.57,0.73,-0.22,-0.047,0.25);\n    #else    \n        mat3 r11 = mat3(1);\n        mat3 r12 = mat3(0);\n        mat3 r21 = mat3(0);\n        mat3 r22 = mat3(1);\n    #endif\n\n    vec3 l1s = r11*p1 + r12*p2;\n    vec3 l2s = r21*p1 + r22*p2;\n\n    vec3 l1 = smin(1.-sqrt(l1s*l1s+.1),vec3(.5),.2);\n    vec3 l2 = smin(1.-sqrt(l2s*l2s+.1),vec3(.5),.2);\n\n    \n    float cage = sqrt(dot(l1,l1)+dot(l2,l2))-.9;\n    return cage;\n}\n\nfloat scene(vec3 p) {\n    //mix the object with a smaller, space-repeated copy of itself for a more interesting surface texture\n    return mix(obj(p), obj(asin(sin(p*6.)*.8))/6.,.3);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvec3 tex3D( in vec3 pos, in vec3 normal ){\n    return  HAIR_FUNK( pos.yz )*abs(normal.x)+ \n            HAIR_FUNK( pos.xz )*abs(normal.y)+ \n            HAIR_FUNK( pos.xy )*abs(normal.z);\n}\n\nvec3 norm2(vec3 p){\n    vec3 P = vec3(-.05, .05, 0) * 0.005;\n\n    vec3 N = normalize(scene(p+P.xyy)*P.xyy+scene(p+P.yxy)*P.yxy+\n                  scene(p+P.yyx)*P.yyx+scene(p+P.xxx)*P.xxx);\n    \n    vec3 B = vec3(tex3D(p+P.xzz,N).r,tex3D(p+P.zxz,N).r,\n                  tex3D(p+P.zzx,N).r)-tex3D(p,N).r;\n    B = (B-N*dot(B,N));\n\n    return normalize(N+B*5.0);\n}\n\nvec3 triplanar(vec3 P, vec3 N){   \n    \n    vec3 Nb = max(abs(N)- vec3(0.0, 0.1, 0.0), 0.0);\n\n    float b = (Nb.x + Nb.y + Nb.z);\n    Nb /= vec3(b);\n    \n    vec3 c0 = HAIR_FUNK(P.xy).rgb * Nb.z;\n    vec3 c1 = HAIR_FUNK(P.yz).rgb * Nb.x;\n    vec3 c2 = HAIR_FUNK(P.xz).rgb * Nb.y;\n    \n    return c0 + c1 + c2;\n}\n\nvec3 triplanarB(vec3 P, vec3 N){\n    vec3 signs = sign(N);\n        \n    vec3 weights = max(abs(N) - vec3(0.0, 0.4, 0.0), 0.0);\n    weights /= max(max(weights.x, weights.y), weights.z);\n    float sharpening = 10.0;\n    weights = pow(weights, vec3(sharpening, sharpening, sharpening));\n    weights /= dot(weights, vec3(1.0, 1.0, 1.0));\n    \n    float anglep = 3.14159265/4.0;\n\n    float cosp = cos(anglep);\n    float sinp = sin(anglep);\n    \n    // Set up the 3 planar projections that we will be using\n    // first plane is rotated around z compensating for the sign of the normal\n    vec3 p1t = vec3(0.0, 0.0, 1.0);\n    vec3 p1b = vec3(-signs.x * cosp, sinp, 0.0);\n\n    // second plane is just the xz plane\n    vec3 p2t = vec3(0.0, 0.0, 1.0);\n    vec3 p2b = vec3(1.0, 0.0, 0.0);\n    \n    /// third plane is rotated around x also compensating for the sign of the normal\n    vec3 p3t = vec3(1.0, 0.0, 0.0);\n    vec3 p3b = vec3(0.0, sinp, -signs.z * cosp);\n    \n    // Perform the uv projection on to each plane\n    vec2 uvp1 = vec2(dot(P, p1t), dot(P, p1b));\n    vec2 uvp2 = vec2(dot(P, p2t), dot(P, p2b));\n    vec2 uvp3 = vec2(dot(P, p3t), dot(P, p3b));\n\n    vec3 texCol = HAIR_FUNK(uvp1) * weights.x +\n          HAIR_FUNK(uvp2) * weights.y +\n          HAIR_FUNK(uvp3) * weights.z;\n\n    return texCol;\n}\n\nvec3 triplanarC(vec2 P, vec3 N){\n    vec3 NN = vec3(P, sqrt(1.0 - dot(P, P)));\n\n    vec3 a = max(vec3(0.0), abs(NN) - sqrt(3.0)/3.0);\n    vec3 w = a / (a.x + a.y + a.z);\n    \n\n    vec2 g; // maximum projection\n    if (w.x > w.y && w.x > w.z)\n        g = NN.yz;\n    else if (w.y > w.z)\n        g = NN.xz;\n    else\n        g = NN.xy;\n\n    float pixDeriv = length(vec2(length(dFdx(NN)), length(dFdy(NN))));\n    float pixScale = 1.0 / pixDeriv;\n\n    float h = hash3D(floor(NN * pixScale));\n    \n    vec2 t;\n    if (w.z > h)\n        t = NN.xy;\n    else if (w.z + w.y > h)\n        t = NN.xz;\n    else\n        t = NN.yz;\n\n    //\n    return \n        HAIR_FUNK(t) * w.z + \n        HAIR_FUNK(t) * w.y + \n        HAIR_FUNK(t) * w.x;\n    //return textureGrad(iChannel0, t, dFdx(g), dFdy(g));\n}\n\nvec3 triplanarD(vec3 P, vec3 N){\n    vec3 c = max(abs(N)- vec3(0.0, 0.4, 0.0), 0.0);\n\n    \n    vec3 O = c.z*HAIR_FUNK(P.xy) +  c.x*HAIR_FUNK(P.yz) +  c.y*HAIR_FUNK(P.xz);\n    O +=  c.z*HAIR_FUNK(P.xy)+ c.x*HAIR_FUNK(P.yz)+ c.y*HAIR_FUNK(P.xz)  / (c.x+c.y+c.z);\n    O += .5+ ( c.z*(HAIR_FUNK(P.xy)-.5) + c.x*(HAIR_FUNK(P.yz)-.5) + c.y*(HAIR_FUNK(P.xz)-.5) ) / length(c);\n\n    return O.rgb;\n}\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 triplanarE(vec3 p, vec3 n){\n    \n    n = max(abs(n) - .2, 0.001);\n    n /= dot(n, vec3(1));\n    vec3 tx = HAIR_FUNK(p.zy).xyz;\n    vec3 ty = HAIR_FUNK(p.xz).xyz;\n    vec3 tz = HAIR_FUNK(p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n    vec2 mouse = (iMouse.xy/iResolution.xy*2.0-1.0)*2.;\n    mouse.x += iTime/6.;\n    mouse.y += iTime/10.;\n\n    mat3 rot_x = mat3( cos(-mouse.x), sin(-mouse.x), 0.0,\n                      -sin(-mouse.x), cos(-mouse.x), 0.0,\n                                0.0,          0.0, 1.0);\n    \n    mat3 rot_y = mat3( cos(-mouse.y), 0.0, sin(-mouse.y),\n                                0.0, 1.0, 0.0,\n                      -sin(-mouse.y), 0.0, cos(-mouse.y));\n    \n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-11,0,0);\n\n\tinit*=rot_y*rot_x;\n    cam*=rot_y*rot_x;\n\n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 300; i++) {\n        float dist = scene(p);\n        if (dist*dist < 0.00001) { hit = true; break; }\n        if (distance(p,init)>200.) break;\n        p+=dist*cam;\n    }\n    \n    vec3 n = norm(p);\n    \n    /////////\n    // Use this one for bump mapping but too\n    // vec3 n = norm(p);\n    ////////\n\n    vec3 r = reflect(cam,n);\n    vec3 lightdir = normalize(vec3(1));\n    float ao = smoothstep(-.5,2.,scene(p+n*2.))*.9+.1;\n    float ro = smoothstep(-.5,2.,scene(p+r*2.));\n    float ss = smoothstep(-1.,1.,scene(p+lightdir));\n    float spec = length(sin(r*3.)*0.2+0.8)/sqrt(3.);\n    float diff = length(sin(n*2.)*0.5+0.5)/sqrt(3.);\n    float fres = 1.-abs(dot(n,cam))*.98;\n\n    // TEST 1:\n   \t//vec3 col = ao*mix(ss,diff,.5)* triplanar(p * .15, n) +pow(spec,30.)*fres*5.*ro;\n    \n    // TEST 2:\n    //vec3 col = ao*mix(ss,diff,.5)* triplanarD(p * .15, n) * .5 +pow(spec,30.)*fres*5.*ro;\n    \n    // TEST 3:\n    vec3 col = ao*mix(ss,diff,.5)* triplanarE(p * .25, n) +pow(spec,20.)*fres*2.*ro;\n    //col = sqrt(clamp(col, 0., .4));\n    \n    float bg = length(sin(cam*2.5)*0.6+0.4)/sqrt(3.) ;\n  \tfragColor = hit ? vec4(sqrt(col), 1.) : vec4(vec3(pow(bg,7.))* vec3(.15, .07, .02), 1.);\n}","name":"Image","description":"","type":"image"}]}