{"ver":"0.1","info":{"id":"7sX3DS","date":"1616446755","viewed":180,"name":"Pool1984 progressive","username":"Observer","description":"Spin off of https://www.shadertoy.com/view/XlfBRH. Instead of rendering 16 samples per pixel, it just renders one pixel jittered both in position and time and accumulating all frames until you move the mouse.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","motionblur","sampling","pool"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// **** POOL1984 ****\n// Created by Observer (Bram Vader)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Spin off of https://www.shadertoy.com/view/XlfBRH. Instead of rendering \n// 16 samples per pixel, it just renders one pixel jittered both in position and \n// time and accumulating all frames until you move the mouse.\n//\n// --- original description ---\n// This shader is the result of a project that attempts to recreate the \"Pixar 1984 pool ball shot\", mentioned \n// in the paper \"Distributed Ray Tracing\" by Robert L. Cook, Thomas Porter and Loren Carpenter (1984) which can\n// be found here: https://graphics.pixar.com/library/DistributedRayTracing/.\n//\n// The principles described in this paper are used to recreate the picture, which can be found at the end of the\n// paper and also on the web page as a thumbnail.  The thumbnail, which is an image of 778x669 pixels is the best \n// quality we have, as far as I know. Another paper \"Stochastic Sampling in Computer Graphics\" by Robert L. Cook \n// (1986) contains a close-up of \"1984\" which is used as well to better reproduce a part of the environment map.\n//\n// To calculate all positions, lights, textures and animations, a C#-program Pool1984.exe was made, which can be \n// found on https://github.com/BramVader/Pool1984.\n// The most time-consuming part was creating Buffer A that contains the cubemap that reflects the environment, \n// mirrored in the balls.\n//\n// --> Image-part: Display \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texelFetch(iChannel0, max(ivec2(fragCoord), ivec2(0, 1)), 0);\n    fragColor.rgb /= fragColor.w;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// **** POOL1984 ****\n// Created by Observer (Bram Vader)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Spin off of https://www.shadertoy.com/view/XlfBRH. Instead of rendering \n// 16 samples per pixel, it just renders one pixel jittered both in position and \n// time and accumulating all frames until you move the mouse.\n//\n// --- original description ---\n// This shader is the result of a project that attempts to recreate the \"Pixar 1984 pool ball shot\", mentioned \n// in the paper \"Distributed Ray Tracing\" by Robert L. Cook, Thomas Porter and Loren Carpenter (1984) which can\n// be found here: https://graphics.pixar.com/library/DistributedRayTracing/.\n//\n// The principles described in this paper are used to recreate the picture, which can be found at the end of the\n// paper and also on the web page as a thumbnail.  The thumbnail, which is an image of 778x669 pixels is the best \n// quality we have, as far as I know. Another paper \"Stochastic Sampling in Computer Graphics\" by Robert L. Cook \n// (1986) contains a close-up of \"1984\" which is used as well to better reproduce a part of the environment map.\n//\n// To calculate all positions, lights, textures and animations, a C#-program Pool1984.exe was made, which can be \n// found on https://github.com/BramVader/Pool1984.\n// The most time-consuming part was creating Buffer A that contains the cubemap that reflects the environment, \n// mirrored in the balls.\n//\n// --> Buffer A: Cubemap\n\n// *** Drawing functions\n\n// Draws a line through p1 and p2\nfloat drawLine(in vec2 uv, in vec2 p1, in vec2 p2, in float width)\n{\n    vec2 v = p2 - p1;\n    vec2 w = uv - p1;\n\n    float c1 = dot(w, v);\n    if (c1 <= 0.0)\n        return max(distance(uv, p1) - width, 0.0);\n    float c2 = dot(v, v);\n    if (c2 <= c1)\n        return max(distance(uv, p2) - width, 0.0);\n\n    float b = c1 / c2;\n    vec2 u = p1 + b * v;\n    return max(distance(uv, u) - width, 0.0);\n}\n\n// Draws a circular arc through p1, p2 and p3\n// -- still has some artifacts\nfloat drawArc(in vec2 uv, in vec2 p1, in vec2 p2, in vec2 p3, in float width)\n{\n    vec2 a = (p1 + p2) * 0.5;\n    vec2 dv1 = vec2(p1.y - p2.y, -p1.x + p2.x);\n\n    vec2 b = (p2 + p3) * 0.5;\n    vec2 dv2 = vec2(p2.y - p3.y, -p2.x + p3.x);\n\n    float d = (dv1.y * dv2.x - dv1.x * dv2.y);\n    float t1 = ((a.x - b.x) * dv2.y + (b.y - a.y) * dv2.x) / d;\n    vec2 cntr = vec2(a.x + t1 * dv1.x, a.y + t1 * dv1.y);\n\n    if (dot(uv - p1, p2 - p1) >= 0.0 && dot(uv - p3, p2 - p3) >= 0.0)\n    {\n        return max(abs(length(uv - cntr) - length(p1 - cntr)) - width, 0.0);\n    }\n    else\n    {\n        return max(min(distance(uv, p1), distance(uv, p2)) - width, 0.0);\n    }\n}\n\n// *** Window part ***\n\n// Palmtree is a bitmap of 32x48\nint tree[] = int[] (\n    0x00003000, 0x00003C00, 0x0000FC00, 0x0000FC00, 0x01C1FC00, 0x0FC3FC00, 0x0FF1F830, 0x3FFBF96C,\n    0x7FFFFF7F, 0x7FFDFFFF, 0x3FFFF7FF, 0x2FFFFFFE, 0x03FFFFFE, 0x04FFFFE8, 0x07FFFFF0, 0x1FFFFFF0,\n    0x3FFFFFFC, 0x3FFFFFFC, 0x1FBFFFFC, 0x1F8FFFFE, 0x3F1FFFFE, 0x011FFFFA, 0x000FFA78, 0x000FFCF8,\n    0x000FF840, 0x000FF000, 0x000FF800, 0x000FFC00, 0x000FFC00, 0x000FF800, 0x000FF800, 0x0007F000,\n    0x0007F000, 0x0007E000, 0x0003E000, 0x0003E000, 0x0003E000, 0x0003E000, 0x0003E000, 0x0003E000,\n    0x0001C000, 0x0001C000, 0x0003E000, 0x0001E000, 0x0001C000, 0x0001E000, 0x0001E000, 0x0001E000\n);\n\n// Player is a bitmap of 48x60 broken into 3 32xN bitmaps\nint player1[] = int[] (\n    0x00000000, 0x00001E00, 0x0000FF80, 0x0001FFC0, 0x0007FFC0, 0x000FFFE0, 0x001FFFE0, 0x001FFFF0,\n    0x001FFFF0, 0x003FFFF0, 0x003FFFF0, 0x003FFFF0, 0x003FFFF0, 0x001FFFF8, 0x001FFFF8, 0x001FFFFC,\n    0x000FFFFC, 0x000FFFF8, 0x0007FFF8, 0x0007FFF8, 0x0003FFF0, 0x0001FFF0, 0x0001FFF0, 0x0001FFF0,\n    0x0001FFF0, 0x0000FFE0, 0x0000FF00, 0x0000FF00, 0x0000FF00, 0x0001FF00, 0x0001FF00, 0x0003FF80,\n    0x000FFF80, 0x001FFFC0, 0x003FFFC0, 0x007FFFC0, 0x007FFFE0, 0x01FFFFE0, 0x03FFFFF0, 0x03FFFFF0,\n    0x07FFFFF0, 0x0FFFFFF8, 0x1FFFFFF8, 0x1FFFFFF8, 0x1FFFFFFC, 0x3FFFFFFC, 0x3FFFFFFE, 0x3FFFFFFE,\n    0x3FFFFFFF, 0x3FFFFFFF\n);\nint player2[] = int[](\n    0x07FFFFFF, 0x07FEFFFF, 0x07FCFFFF, 0x07FCFFFF, 0x0FF8FFFF, 0x0FF8FFFF, 0x0FF8FFFF, 0x0FF8FFFF,\n    0x1FF0FFFF, 0x1FF0FFFF\n);\nint player3[] = int[](\n    0x7C000000, 0x7E000000, 0x7F000000, 0x7F800000, 0x7FC38000, 0x7FF7C000, 0x7FFFC000, 0x7FFFC000,\n    0x7FFFC000, 0x7FFFC000\n);\n\nfloat player(in vec2 uv)\n{\n    float stick =\n        step(118.0 + (116.5 - 118.0) * (uv.y - 25.4) / (237.1 - 25.4), uv.x) *\n        step(uv.x, 120.5 + (117.2 - 120.5) * (uv.y - 25.4) / (237.1 - 25.4)) *\n        step(uv.y, 237.1);\n    ivec2 iv = ivec2(vec2((uv.x - 74.6)*1.05, (204.7 - uv.y)*0.36));\n    if (iv.x >= 4 && iv.x < 35 && iv.y >= 1 && iv.y < 50)\n    {\n        return (player1[iv.y - 1] & (1 << (35 - iv.x))) > 0 ? 1.0 : stick;\n    }\n    if (iv.y >= 50 && iv.y < 60)\n    {\n        if (iv.x >= 0 && iv.x < 31)\n        {\n            return (player2[iv.y - 50] & (1 << (31 - iv.x))) > 0 ? 1.0 : stick;\n        }\n        if (iv.x >= 31 && iv.x < 48)\n        {\n            return (player3[iv.y - 50] & (1 << (61 - iv.x))) > 0 ? 1.0 : stick;\n        }\n    }\n    return stick;\n}\n\nfloat palmtrees(in vec2 uv)\n{\n    ivec2 iv = ivec2(vec2((uv.x - 207.0)*1.27, (205.0 - uv.y)*0.32));\n    if (iv.x >= 0 && iv.x < 32 && iv.y >= 0 && iv.y < 48)\n    {\n        return (tree[iv.y] & (1 << (31 - iv.x))) > 0 ? 1.0 : 0.0;\n    }\n    iv = ivec2(vec2((258.6 - uv.x)*1.28, (216.9 - uv.y)*0.30));\n    if (iv.x >= 0 && iv.x < 32 && iv.y >= 0 && iv.y < 48)\n    {\n        return (tree[iv.y] & (1 << (31 - iv.x))) > 0 ? 1.0 : 0.0;\n    }\n    return 0.0;\n}\n\n#define XIN(a,b) step(a, uv.x) * step(uv.x, b)\n#define XOUT(a,b) (step(uv.x, a) + step(b, uv.x))\n#define YIN(a,b) step(a, uv.y) * step(uv.y, b)\n#define YOUT(a,b) (step(uv.y, a) + step(b, uv.y))\n\nfloat windowPattern(in vec2 uv)\n{\n    return\n        XIN(0.0, 39.0) *( YIN(0.0, 65.0) + YIN(73.0, 237.0) ) +\n        XIN(63.0, 153.0) *( YIN(39.0, 179.0) + YIN(196.0, 255.0) ) *\n        (max( XOUT(81.0, 85.0) * XOUT(136.0, 140.0), step(uv.y, 179.0) ) ) +\n\n        XIN(158.0, 255.0) *( YIN(39.0, 212.0) + YIN(226.0, 237.0) + YIN(244.0, 255.0)) *\n        (max( XOUT(174.0, 178.0) * XOUT(229.0, 233.0), step(uv.y, 212.0) ) );\n}\n\nvec3 windowPart(in vec2 uv)\n{\n    float r = player(uv);\n    float s = palmtrees(uv);\n    float p = windowPattern(uv);\n    float q = windowPattern(uv * vec2(1.0, 1.04) - vec2(-4.0, 16.0));\n    return\n        vec3(0.34, 0.7, 0.9) * p * q * (1.0 - s - r) +\n        vec3(1.0) * (p * (1.0 - q)) * (1.0 - r);\n}\n\n// *** Sunlight part\n\nvec3 sunlightPart(in vec2 uv)\n{\n    float x1[] = float[] (0.0, 43.3, 106.5, 167.6);\n    float y1[] = float[] (0.0, 29.9, 48.5, 90.4);\n    float x2[] = float[] (26.8, 98.7, 156.7, 239.2);\n    float y2[] = float[] (20.1, 48.5, 72.2, 237.1);\n\n    vec4 d1 = vec4(0.0);\n    float d2;\n\n    // A chair (?)\n    const vec2 dv = vec2(45.0, 86.9);\n    d2 =\n        XIN(75.0, 142.3) * step(uv.y, 262.6) *\n        max(\n            step(1.0, length((uv - vec2(113.0, 263.3)) / dv)) *\n            step(length((uv - vec2(113.0, 222.5)) / dv), 1.0) +\n            step(1.0, length((uv - vec2(113.0, 200.8)) / dv)) *\n            step(length((uv - vec2(113.0, 169.7)) / dv), 1.0) +\n            step(1.0, length((uv - vec2(113.0, 148.0)) / dv)) *\n            step(length((uv - vec2(113.0, 116.9)) / dv), 1.0),\n\n            XOUT(82.9, 134.4) * YIN(0.0, 180.0)\n        );\n    d1 = d2 > d1.w ? vec4(1.0, 1.0, 0.5, 1.0) * d2 : d1;\n\n    // Sunlight projected on the wall\n    vec2 tuv = vec2(uv.x - (255.0 - uv.y) * 0.06, 255.0 - uv.y - uv.x);\n    for (int y = 0; y < 4; y++)\n    {\n        if (tuv.y >= y1[y] && tuv.y <= y2[y] && uv.y > 0.0)\n        for (int x = 0; x < 4; x++)\n        {\n            if (tuv.x >= x1[x] && tuv.x <= x2[x + y/3])\n            {\n                {\n                    d2 = x != 2 || y ==2  ? 0.3 + (y > 2 || y == 1 || x == 2 ? 0.5 : 0.0) : 0.0;\n                    d1 = d2 > d1.w ? vec4(1.0, 1.0, 0.0, 1.0) * d2 : d1;\n                }\n            }\n        }\n    }\n    return d1.rgb;\n}\n\n// *** Light spot part\nvec3 lightspotPart(in vec2 uv)\n{\n    float r = length((uv - vec2(127.0, 230.2)) / vec2(71.7, 24.4));\n    float sy = (1.0 - pow(abs(uv.x - 127.0)/127.0, 2.0)) * 188.0;\n    float s = smoothstep (sy, sy - 20.0, uv.y) * pow(uv.y / 188.0, 2.0);\n    float t =\n       min(\n        drawLine(uv, vec2(197.3, 82.7), vec2(203.5, 177.8), 2.0),\n        drawLine(uv, vec2(192.3, 82.7), vec2(27.0, 99.0), 4.0)\n      );\n    return (max(smoothstep (1.0, 0.5, r), s)\n        * (1.0 - smoothstep (6.0, 0.5, t)))\n        * vec3(1.0);\n}\n\n// *** Neon sign 1 (displaying 'Bud light')\nvec3 bud[] = vec3[](\n    vec3(10.0, 104.2, 155.3), vec3(11.0, 104.3, 109.3), vec3(12.0, 136.6, 93.3),  vec3(13.0, 143.9, 97.8),  vec3(12.0, 148.4, 104.2),\n    vec3(13.0, 149.5, 112.0), vec3(11.0, 149.5, 153.6), vec3(12.0, 145.7, 157.4), vec3(13.0, 141.9, 153.3), vec3(11.0, 141.4, 110.0),\n    vec3(12.0, 125.7, 101.7), vec3(13.0, 117.6, 113.4), vec3(11.0, 117.5, 150.9), vec3(12.0, 115.3, 155.5), vec3(13.0, 110.4, 157.0),\n    vec3(10.0, 186.9, 158.2), vec3(12.0, 194.8, 158.1), vec3(13.0, 205.2, 155.7), vec3(12.0, 213.4, 150.4), vec3(13.0, 218.6, 139.9),\n    vec3(12.0, 220.1, 122.5), vec3(13.0, 215.3, 105.0), vec3(12.0, 206.9, 96.5),  vec3(13.0, 195.5, 93.2),  vec3(11.0, 174.6, 93.2),\n    vec3(12.0, 171.2, 95.4),  vec3(13.0, 170.4, 99.3),  vec3(11.0, 170.4, 152.9), vec3(12.0, 175.5, 158.9), vec3(13.0, 181.2, 153.8),\n    vec3(11.0, 181.5, 106.6), vec3(12.0, 183.1, 103.0), vec3(13.0, 186.5, 101.1), vec3(12.0, 201.5, 103.2), vec3(13.0, 207.6, 111.7),\n    vec3(12.0, 208.6, 127.6), vec3(13.0, 203.2, 144.8), vec3(12.0, 198.5, 149.3), vec3(13.0, 193.3, 151.2), vec3(11.0, 186.7, 151.2),\n    vec3(10.0, 40.1, 159.7),  vec3(11.0, 40.1, 100.3),  vec3(12.0, 41.0, 96.4),   vec3(13.0, 44.1, 94.0),   vec3(12.0, 46.2, 93.9),\n    vec3(13.0, 48.2, 94.0),   vec3(12.0, 51.0, 95.8),   vec3(13.0, 51.9, 99.0),   vec3(11.0, 52.2, 147.2),  vec3(12.0, 53.4, 149.8),\n    vec3(13.0, 55.9, 151.2),  vec3(12.0, 62.3, 151.5),  vec3(13.0, 68.6, 150.9),  vec3(12.0, 72.6, 148.7),  vec3(13.0, 75.0, 143.7),\n    vec3(12.0, 74.2, 136.6),  vec3(13.0, 69.2, 131.5),  vec3(12.0, 65.0, 130.0),  vec3(13.0, 60.6, 129.7),  vec3(12.0, 58.1, 126.9),\n    vec3(13.0, 60.8, 123.8),  vec3(12.0, 65.8, 123.6),  vec3(13.0, 69.9, 122.8),  vec3(12.0, 75.0, 116.5),  vec3(13.0, 74.3, 106.9),\n    vec3(12.0, 71.9, 103.2),  vec3(13.0, 67.4, 101.2),  vec3(11.0, 60.5, 101.2),  vec3(12.0, 57.4, 97.9),   vec3(13.0, 60.7, 93.6),\n    vec3(11.0, 74.0, 93.6),   vec3(12.0, 78.1, 94.5),   vec3(13.0, 82.1, 97.2),   vec3(12.0, 87.9, 109.3),  vec3(13.0, 84.1, 122.2),\n    vec3(12.0, 82.0, 127.5),  vec3(13.0, 83.9, 132.8),  vec3(12.0, 87.2, 140.8),  vec3(13.0, 86.3, 150.0),  vec3(12.0, 80.2, 155.5),\n    vec3(13.0, 70.7, 157.7),  vec3(11.0, 47.6, 157.7),  vec3(20.0, 52.3, 27.6),   vec3(21.0, 29.2, 27.8),   vec3(22.0, 26.6, 29.4),\n    vec3(23.0, 25.5, 32.2),   vec3(21.0, 25.5, 70.3),   vec3(20.0, 66.4, 27.6),   vec3(21.0, 66.4, 72.7),   vec3(20.0, 115.5, 49.3),\n    vec3(21.0, 128.2, 49.3),  vec3(22.0, 130.6, 48.2),  vec3(23.0, 131.6, 45.7),  vec3(21.0, 131.6, 36.4),  vec3(22.0, 128.1, 31.3),\n    vec3(23.0, 122.3, 29.1),  vec3(22.0, 111.2, 28.0),  vec3(23.0, 100.4, 30.6),  vec3(22.0, 89.5, 53.4),   vec3(23.0, 113.8, 72.9),\n    vec3(22.0, 121.0, 71.2),  vec3(23.0, 127.1, 66.8),  vec3(20.0, 153.6, 30.1),  vec3(21.0, 153.5, 71.6),  vec3(20.0, 190.3, 31.7),\n    vec3(21.0, 190.1, 72.3),  vec3(20.0, 158.7, 51.3),  vec3(21.0, 184.0, 51.3),  vec3(20.0, 220.1, 31.9),  vec3(21.0, 220.1, 68.8),\n    vec3(20.0, 203.0, 74.4),  vec3(21.0, 236.3, 74.2),  vec3(30.0, 16.8, 177.1),  vec3(32.0, 5.5, 172.9),   vec3(33.0, 0.2, 162.1),\n    vec3(31.0, 0.0, 16.2),    vec3(32.0, 4.7, 4.9),     vec3(33.0, 16.0, 0.0),    vec3(31.0, 239.3, 0.0),   vec3(32.0, 250.6, 5.3),\n    vec3(33.0, 255.0, 17.0),  vec3(31.0, 254.6, 160.3), vec3(30.0, 153.6, 30.1),  vec3(31.0, 153.5, 71.6),  vec3(30.0, 190.3, 31.7),\n    vec3(31.0, 190.1, 72.3),  vec3(30.0, 158.7, 51.3),  vec3(31.0, 184.0, 51.3),  vec3(30.0, 220.1, 31.9),  vec3(31.0, 220.1, 68.8),\n    vec3(30.0, 203.0, 74.4),  vec3(31.0, 236.3, 74.2),  vec3(30.0, 16.8, 177.1),  vec3(32.0, 5.5, 172.9),   vec3(33.0, 0.2, 162.1),\n    vec3(31.0, 0.0, 16.2),    vec3(32.0, 4.7, 4.9),     vec3(33.0, 16.0, 0.0),    vec3(31.0, 239.3, 0.0),   vec3(32.0, 250.6, 5.3),\n    vec3(33.0, 255.0, 17.0),  vec3(31.0, 254.6, 160.3), vec3(32.0, 249.9, 172.7), vec3(33.0, 237.3, 177.2), vec3(31.0, 16.8, 177.1)\n);\n\nvec3 neonSign1(in vec2 uv)\n{\n    vec4 d1 = vec4(1E12);\n    float d2;\n    vec2 p1, p2, p3;\n    int md;\n    float width = 1.0;\n    vec3 color;\n    vec3 colors[] = vec3[] (vec3(1.0), vec3(0.04, 0.58, 0.96), vec3(0.96, 0.02, 0.0));\n    for (int n = 1; n < bud.length(); n++)\n    {\n        p1 = bud[n - 1].yz;\n        p2 = bud[n].yz;\n        md = int(bud[n].x) % 10;\n        color = colors[int(bud[n].x) / 10 - 1];\n        if (md == 1) // LineTo\n        {\n            d2 = drawLine(uv, p1, p2, width);\n        }\n        if (md == 2) // ArcTo\n        {\n            p3 = bud[n + 1].yz;\n            d2 = drawArc(uv, p1, p2, p3, width);\n        }\n        d1 = d2 < d1.w ? vec4(color, d2) : d1;\n    }\n    return d1.rgb * (smoothstep(1.2, 0.0, d1.w) + 0.45 / (d1.w * 0.2 + 1.0));\n}\n\n// *** Neon sign 2, unintelligible from a few pixels\nint sign2a[] = int[] (\n    0x00183000, 0x00387000, 0x00787000, 0x00F07380, 0x01F0FFC0, 0x07FFFF80, 0x17FFFF00, 0x7FFFFF00,\n    0x7FFF8C00, 0x7FFF0000, 0x7FE70000, 0x7CC60000, 0x78070000, 0x70070000, 0x00068000, 0x0016C000,\n    0x0013C000, 0x001FC000, 0x00078000, 0x00060000\n);\nint sign2b[] = int[] (\n    0x001C0000, 0x0CFE0FFE, 0x1FFFFFF8, 0x3FFFFFF8, 0x3FDFFFFC, 0x7B9F17FC, 0x718F07E6, 0x000000C2,\n    0x00000000, 0x58069EF6, 0x680000A0\n);\n\nvec3 neonSign2(in vec2 uv)\n{\n    ivec2 iv = ivec2(uv * vec2(32.0, -29.0) / 255.0) + ivec2(0, 28);\n    if (iv.x >= 0 && iv.x < 31)\n    {\n        if (iv.y >= 0 && iv.y < 20)\n        {\n            return (sign2a[iv.y] & (1 << (31 - iv.x))) > 0 ? vec3(0.0, 0.6, 1.0) : vec3(0.0);\n        }\n        if (iv.y >= 20 && iv.y < 28)\n        {\n            return (sign2b[iv.y-20] & (1 << (31 - iv.x))) > 0 ? vec3(1.0, 0.0, 0.0) : vec3(0.0);\n        }\n    }\n    return vec3(0.0);\n}\n\n// *** Neon sign 3, just an ellipse\nvec3 neonSign3(in vec2 uv)\n{\n    return vec3(0.04, 0.58, 0.96) * smoothstep(0.1, 0.09, abs(0.9 - length(uv / 127.0 - vec2(1.0))));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    float key = iResolution.y * 1000.0 + iResolution.x;\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    \n    if (abs(fragColor.w - key) > 0.1)\n    {\n        vec2 uv = fragCoord.xy * vec2(900.0, 600.0) / iResolution.xy - vec2(22.0, 33.0);\n        fragColor = vec4(\n            windowPart(uv) +\n            sunlightPart(uv - vec2(300.0, 0.0)) +\n            lightspotPart(uv - vec2(600.0, 0.0)) +\n            neonSign1(uv - vec2(0.0, 300.0)) +\n            neonSign2(uv - vec2(300.0, 300.0)) +\n            neonSign3(uv - vec2(600.0, 300.0)),\n            key\n       );\n   }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// **** POOL1984 ****\n// Created by Observer (Bram Vader)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Spin off of https://www.shadertoy.com/view/XlfBRH. Instead of rendering \n// 16 samples per pixel, it just renders one pixel jittered both in position and \n// time and accumulating all frames until you move the mouse.\n//\n// --- original description ---\n// This shader is the result of a project that attempts to recreate the \"Pixar 1984 pool ball shot\", mentioned \n// in the paper \"Distributed Ray Tracing\" by Robert L. Cook, Thomas Porter and Loren Carpenter (1984) which can\n// be found here: https://graphics.pixar.com/library/DistributedRayTracing/.\n//\n// The principles described in this paper are used to recreate the picture, which can be found at the end of the\n// paper and also on the web page as a thumbnail.  The thumbnail, which is an image of 778x669 pixels is the best \n// quality we have, as far as I know. Another paper \"Stochastic Sampling in Computer Graphics\" by Robert L. Cook \n// (1986) contains a close-up of \"1984\" which is used as well to better reproduce a part of the environment map.\n//\n// To calculate all positions, lights, textures and animations, a C#-program Pool1984.exe was made, which can be \n// found on https://github.com/BramVader/Pool1984.\n// The most time-consuming part was creating Buffer A that contains the cubemap that reflects the environment, \n// mirrored in the balls.\n//\n// --> Buffer B: Number textures \"1\", \"9\", \"8\", \"4\"\n\n// Thanks to IQ, see https://iquilezles.org/articles/smin\nfloat smin(in float a, in float b, in float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat one(in vec2 uv)\n{\n    float d = length((uv - vec2(131.0, 186.1)) / vec2(15.4, 9.5)) - 1.0;\n    d = min(d, length((uv - vec2(131.0, 65.1)) / vec2(15.4, 9.5)) - 1.0);\n    d = min(d, max(abs(uv.x - 131.0) / 15.4, abs(uv.y - 125.5) / 60.6) - 1.0);\n    return smoothstep(0.03, 0.0, d);\n} \n\nfloat nine(in vec2 uv)\n{\n    float d1 = 1.0 - length((uv - vec2(128.5, 162.9)) / vec2(20.2, 24.2));\n    float d2 = 1.0 - length((uv - vec2(128.8, 118.9)) / vec2(27.4, 39.2));\n    float d3 = 1.0 - max(abs(uv.x - 127.4) / 68.2, abs(uv.y - 131.4) / 37.6);\n    \n    float d = max(d1, max(d2, -d3));\n    d = max(d, length((uv - vec2(153.8, 131.5)) / vec2(28.3, 69.2)) - 1.0);\n    d = min(d, \n            min(length((uv - vec2(91.7, 92.9)) / vec2(15.7, 8.9)) - 1.0, \n                max(\n                    length((uv - vec2(126.5, 100.0)) / vec2(51.3, 44.0)) - 1.0, \n                    max(d2, d3)\n                   )\n            )\n        );\n    d = min(d, max(length((uv - vec2(129.4, 159.7)) / vec2(49.0, 42.9)) - 1.0, d1));\n    d = min(d, max(length((uv - vec2(127.5, 127.5)) / vec2(127.5, 127.5)) - 1.0, 1.0 - length((uv - vec2(127.5, 127.5)) / vec2(107.5, 107.5))));\n    \n    return smoothstep(0.001, -0.00, d);\n}    \n\nfloat eight(in vec2 uv)\n{\n    float d = length((uv - vec2(129.3, 163.5)) / vec2(49.1, 39.2)) - 1.0;\n    d = smin(d, length((uv - vec2(129.3, 97.7)) / vec2(52.8, 41.8)) - 1.0, 16.0);\n\n    d = max(d, 1.0 - length((uv - vec2(129.3, 161.9)) / vec2(17.7, 21.5)));\n    d = max(d, 1.0 - length((uv - vec2(129.3, 97.3)) / vec2(19.5, 25.2)));\n    \n    return smoothstep(0.03, 0.0, d);\n}  \n\nfloat four(in vec2 uv)\n{\n    float d = length((uv - vec2(150.5, 191.9)) / vec2(18.8, 9.5)) - 1.0;\n    d = min(d, length((uv - vec2(94.3, 102.2)) / vec2(14.9, 8.4)) - 1.0);\n    d = min(d, length((uv - vec2(168.0, 104.1)) / vec2(14.9, 6.9)) - 1.0);\n    d = min(d, length((uv - vec2(153.9, 65.9)) / vec2(15.4, 9.5)) - 1.0);\n    d = min(d, max(abs(uv.x - 153.9) / 15.4, abs(uv.y - 128.9) / 62.9) - 1.0);\n    d = min(d, max(abs(uv.x - 131.8) / 37.5, abs(uv.y - 102.2) / 8.4) - 1.0);\n\n    d = min(d, max(abs(uv.x - (120.8 + 52.4 * (uv.y - 150.0) / 89.7)) / 14.5, abs(uv.y - 149.6) / 44.8) - 1.0);\n    \n    return smoothstep(0.03, 0.0, d);\n}    \n  \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord * 512.0 / iResolution.xy;\n    \n    fragColor.rgb = vec3(\n        one(uv - vec2(0.0, 0.0)) +\n        nine(uv - vec2(256.0, 0.0)) +\n        eight(uv - vec2(0.0, 256.0)) +\n        four(uv - vec2(256.0, 256.0))\n    );\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// **** POOL1984 ****\n// Created by Observer (Bram Vader)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Spin off of https://www.shadertoy.com/view/XlfBRH. Instead of rendering \n// 16 samples per pixel, it just renders one pixel jittered both in position and \n// time and accumulating all frames until you move the mouse.\n//\n// --- original description ---\n// This shader is the result of a project that attempts to recreate the \"Pixar 1984 pool ball shot\", mentioned \n// in the paper \"Distributed Ray Tracing\" by Robert L. Cook, Thomas Porter and Loren Carpenter (1984) which can\n// be found here: https://graphics.pixar.com/library/DistributedRayTracing/.\n//\n// The principles described in this paper are used to recreate the picture, which can be found at the end of the\n// paper and also on the web page as a thumbnail.  The thumbnail, which is an image of 778x669 pixels is the best \n// quality we have, as far as I know. Another paper \"Stochastic Sampling in Computer Graphics\" by Robert L. Cook \n// (1986) contains a close-up of \"1984\" which is used as well to better reproduce a part of the environment map.\n//\n// To calculate all positions, lights, textures and animations, a C#-program Pool1984.exe was made, which can be \n// found on https://github.com/BramVader/Pool1984.\n// The most time-consuming part was creating Buffer A that contains the cubemap that reflects the environment, \n// mirrored in the balls.\n//\n// --> Buffer C: Cloth-texture\n\nconst float PI = acos(0.0) * 2.0;\n\nfloat hash12n(vec2 p) {\n    p = fract(p * vec2(5123.3987, 5151.4321));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n    return fract(p.x * p.y * 95.4323);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(\n        fragCoord.x - (fragCoord.y * 34.0 / 160.0),\n        fragCoord.y - (fragCoord.x * 64.0 / 147.0)\n    );\n    fragColor.rgb = mix(\n        vec3(0.2, 0.5, 0.2),\n        vec3(0.0, 0.3, 0.0),\n        sin(uv.x * PI + hash12n(uv.yx * 0.04) * 0.7) * cos(uv.y * PI * 1.3) * 0.5 + 0.5 + hash12n(uv * 0.01) * 0.4\n    );\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// **** POOL1984 ****\n// Created by Observer (Bram Vader)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Spin off of https://www.shadertoy.com/view/XlfBRH. Instead of rendering \n// 16 samples per pixel, it just renders one pixel jittered both in position and \n// time and accumulating all frames until you move the mouse.\n//\n// --- original description ---\n// This shader is the result of a project that attempts to recreate the \"Pixar 1984 pool ball shot\", mentioned \n// in the paper \"Distributed Ray Tracing\" by Robert L. Cook, Thomas Porter and Loren Carpenter (1984) which can\n// be found here: https://graphics.pixar.com/library/DistributedRayTracing/.\n//\n// The principles described in this paper are used to recreate the picture, which can be found at the end of the\n// paper and also on the web page as a thumbnail.  The thumbnail, which is an image of 778x669 pixels is the best \n// quality we have, as far as I know. Another paper \"Stochastic Sampling in Computer Graphics\" by Robert L. Cook \n// (1986) contains a close-up of \"1984\" which is used as well to better reproduce a part of the environment map.\n//\n// To calculate all positions, lights, textures and animations, a C#-program Pool1984.exe was made, which can be \n// found on https://github.com/BramVader/Pool1984.\n// The most time-consuming part was creating Buffer A that contains the cubemap that reflects the environment, \n// mirrored in the balls.\n//\n// --> Buffer D: Raytracer \n\n// Turn on ANIMATE to animate the ball motion\n#define ANIMATE\n\n// -------- Generated by Pool1984.exe ---------\nconst float PI = acos(0.0) * 2.0;\nconst float MINDIST = 0.001;\nconst float MAXDIST = 1000.0;\nconst float TEXTUREANGLE = 0.55;\nconst vec3 AMBIENT = vec3(0.01, 0.01, 0.01);\nconst float REFL = 0.3;\nconst float MAXITER = 2.0;\n\nconst vec3[] LIGHT_POS = vec3[] (vec3(-21.687, 5.687, 14.04), vec3(-6.194, 7.826, 19.752), vec3(17.757, 7.688, 18.836));\nconst float[] LIGHT_RAD1 = float[] (1.559, 2.419, 2.351);\nconst float[] LIGHT_RAD2 = float[] (2.422, 3.096, 3.022);\nconst vec3[] COLOR = vec3[] (vec3(1.507, 1.412, 0.187), vec3(1.432, 1.53, 1.013), vec3(0.0, 0.0, 0.0), vec3(0.902, 0.393, 0.869), vec3(1.432, 1.53, 1.013), vec3(0.388, 0.339, 0.328));\n// ------------- End of generated -------------\n\nstruct Intersection{\n    float dist; // Distance to object\n    vec3 pos; // Intersection position\n    vec3 nrm; // Surface normal\n    vec3 tnrm; // Transformed normal\n    float obj; // Object number: 0: 1-Ball, 1: 9-Ball, 2: 8-Ball, 3: 4-Ball, 4: White ball, 5: Felt\n    vec2 txtOffset; // Texture offset for number texture (Buf B)\n};\n\nstruct Ray{\n    vec3 ro;\n    vec3 rd;\n};\n\nstruct Camera{\n    vec3 from;\n    vec3 at;\n    vec3 up;\n    vec2 aper;\n\n    vec3 look;\n    vec3 hor;\n    vec3 ver;\n};\n\n// Hash function adapted from https://www.shadertoy.com/view/4tfyW4 \"Integer Hash - II\" by IQ\n\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 noiseFunc(in vec2 pos)\n{\n    uvec3 x = uvec3(uint(pos.x * 1000.0), uint(pos.y * 1000.0), iFrame);\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nmat3 RotateAxisXY(in vec3 axis, in float angle)\n{\n    float sn = sin(angle);\n    float cs = cos(angle);\n    float tc = 1.0 - cs;\n    return mat3(\n        vec3(tc * axis.x * axis.x + cs, tc * axis.x * axis.y, sn * axis.y),\n        vec3(tc * axis.x * axis.y, tc * axis.y * axis.y + cs, -sn * axis.x),\n        vec3(-sn * axis.y, sn * axis.x, cs)\n    );\n}\n\n// -------- Generated by Pool1984.exe ---------\nvec3 GetBall1Pos (in float t)\n{\n    return vec3(-0.278, 3.745, 1.0);\n}\n\nvec3 GetBall1TextureTransformation (in float t, in vec3 v)\n{\n    return v * mat3(vec3(0.019, -0.412, 0.911), vec3(-0.353, 0.85, 0.392), vec3(-0.936, -0.329, -0.129));\n}\n\nvec3 GetBall9Pos (in float t)\n{\n    return t < 0.33 ?\n        vec3(0.024, 0.731, 1.0) + t * vec3(0.19, 0.082, 0.0) / 0.33 : \n        vec3(0.214, 0.813, 1.0) + (t - 0.33) * vec3(0.177, 0.37, 0.0) / 0.67;\n}\n\nvec3 GetBall9TextureTransformation (in float t, in vec3 v)\n{\n    return t < 0.33 ?\n        v * RotateAxisXY(vec3(0.395, -0.919, 0.0), 0.207 * t / 0.33) * mat3(vec3(0.028, 0.103, 0.978), vec3(0.138, -0.994, 0.131), vec3(0.957, 0.055, 0.276)) : \n        v * RotateAxisXY(vec3(0.902, -0.433, 0.0), 0.41 * (t - 0.33) / 0.67) * mat3(vec3(0.034, 0.184, 0.978), vec3(0.134, -0.981, 0.189), vec3(0.975, 0.07, 0.089));\n}\n\nvec3 GetBall8Pos (in float t)\n{\n    return t < 0.33 ?\n        vec3(2.047, -0.078, 1.0) : \n        t < 0.735 ?\n            vec3(2.047, -0.078, 1.0) + (t - 0.33) * vec3(0.238, -0.087, 0.0) / 0.405 : \n            vec3(2.285, -0.166, 1.0);\n}\n\nvec3 GetBall8TextureTransformation (in float t, in vec3 v)\n{\n    return t < 0.33 ?\n        v * mat3(vec3(-0.29, -0.038, 0.956), vec3(0.003, -0.999, -0.038), vec3(0.957, -0.008, 0.29)) : \n        t < 0.735 ?\n            v * RotateAxisXY(vec3(-0.344, -0.939, 0.0), 0.253 * (t - 0.33) / 0.405) * mat3(vec3(-0.29, -0.038, 0.956), vec3(0.003, -0.999, -0.038), vec3(0.957, -0.008, 0.29)) : \n            v * mat3(vec3(-0.275, -0.123, 0.991), vec3(-0.008, -0.992, -0.124), vec3(0.932, -0.024, 0.055));\n}\n\nvec3 GetBall4Pos (in float t)\n{\n    return t < 0.735 ?\n        vec3(3.891, -1.358, 1.0) : \n        vec3(3.891, -1.358, 1.0) + (t - 0.735) * vec3(0.135, -0.097, 0.0) / 0.265;\n}\n\nvec3 GetBall4TextureTransformation (in float t, in vec3 v)\n{\n    return t < 0.735 ?\n        v * mat3(vec3(-0.708, 0.189, 0.681), vec3(0.127, -0.914, 0.385), vec3(0.695, 0.359, 0.623)) : \n        v * RotateAxisXY(vec3(-0.585, -0.811, 0.0), 0.166 * (t - 0.735) / 0.265) * mat3(vec3(-0.708, 0.189, 0.681), vec3(0.127, -0.914, 0.385), vec3(0.695, 0.359, 0.623));\n}\n\nvec3 GetBallwPos (in float t)\n{\n    return vec3(-2.645, -0.519, 1.0) + t * vec3(-0.028, 0.088, 0.0);\n}\n\nvec3 GetBallwTextureTransformation (in float t, in vec3 v)\n{\n    return v;\n}\n// ------------- End of generated -------------\n\nCamera GetCamera(vec2 noise) {\n    Camera camera;\n    \n    if (iMouse.z < -0.5 || (iMouse.x == 0.0 && iMouse.y == 0.0))\n    {\n        // -------- Generated by Pool1984.exe ---------\n        camera.from = vec3(0.0, 0.0, 20.0);\n        camera.at = vec3(0.0, 0.0, 0.0);\n        camera.up = vec3(0.819, 0.574, 0.0);\n        camera.aper = vec2(13.442, 11.388);\n        // ------------- End of generated -------------\n    }\n    else\n    {\n        float dst = 5.0;\n        vec2 p = iMouse.xy;\n        camera.from = vec3(\n            dst * cos(p.x * PI * 2.0 / iResolution.x) * cos(p.y * PI * 0.499 / iResolution.y),\n            dst * sin(p.x * PI * 2.0 / iResolution.x) * cos(p.y * PI * 0.499 / iResolution.y),\n            0.01 + dst * sin(p.y * PI * 0.5 / iResolution.y));\n        camera.at = vec3(0.0, 0.0, 0.5);\n        camera.up = vec3(0.0, 0.0, 1.0);\n        camera.aper = vec2(30.0);\n    }\n\n    camera.look = camera.at - camera.from;\n    float dist = length(camera.look);\n    float hsize = tan(camera.aper.x * PI / 180.0) * dist;\n    float vsize = tan(camera.aper.y * PI / 180.0) * dist;\n    if (hsize * iResolution.x / iResolution.y > vsize)\n        hsize = vsize * iResolution.x / iResolution.y;\n    else\n        vsize = hsize * iResolution.y / iResolution.x;\n    \n    camera.hor = normalize(cross(camera.look, camera.up)) * hsize;\n    camera.ver = normalize(cross(camera.hor, camera.look)) * vsize;\n    \n    float sc = 0.05;\n    camera.from += noise.x * sc * camera.hor + noise.y * sc *camera.ver;\n    camera.look = camera.at - camera.from;\n\n    return camera;\n}\n\nRay GetCameraRay(in Camera camera, in vec2 fragCoord) {\n    Ray ray;\n    ray.ro = camera.from;\n    ray.rd = normalize(camera.look +\n            (fragCoord.x / iResolution.x * 2.0 - 1.0) * camera.hor +\n            (fragCoord.y / iResolution.y * 2.0 - 1.0) * camera.ver);\n    return ray;\n}\n\nfloat GetBallIntersection(inout Intersection intsec, in Ray ray, in vec3 center, in float radius, in float minDist, in float maxDist, in float obj) {\n    vec3 ct = ray.ro - center;\n    float b = 2.0 * dot(ray.rd, ct);\n    float c = dot(ct, ct) - radius * radius;\n    float d = b * b - 4.0 * c;\n    d = mix(MAXDIST, (-b - sqrt(abs(d))) * 0.5, step(0.0, d));\n    float hit = step(minDist, d) * step(d, maxDist) * step(d, intsec.dist);\n    intsec.dist = mix(intsec.dist, d, hit);\n    intsec.pos = mix(intsec.pos, ray.ro + d * ray.rd, hit);\n    intsec.nrm = mix(intsec.nrm, (intsec.pos - center) / radius, hit);\n    intsec.obj = mix(intsec.obj, obj, hit);\n    return hit;\n}\n\nfloat GetPlaneIntersection(inout Intersection intsec, in Ray ray, in vec3 center, in vec3 normal, in float minDist, in float maxDist, in float obj) {\n    vec3 ct = ray.ro - center;\n    float d = -dot(ct, normal) / dot(ray.rd, normal);\n    float hit = step(minDist, d) * step(d, maxDist) * step(d, intsec.dist);\n    intsec.dist = mix(intsec.dist, d, hit);\n    intsec.pos = mix(intsec.pos, ray.ro + intsec.dist * ray.rd, hit);\n    intsec.nrm = mix(intsec.nrm, normal, hit);\n    intsec.obj = mix(intsec.obj, obj, hit);\n    return hit;\n}\n\nfloat GetBallShadow(in Ray ray, in vec3 center, in float radius, in float minDist, in float maxDist) {\n    vec3 ct = ray.ro - center;\n    float b = 2.0 * dot(ray.rd, ct);\n    float c = dot(ct, ct) - radius * radius;\n    float d = b * b - 4.0 * c;\n    d = mix(MAXDIST, (-b - sqrt(abs(d))) * 0.5, step(0.0, d));\n    return 1.0 - step(minDist, d) * step(d, maxDist);\n}\n\nvoid GetIntsec(in Ray ray, in float t, inout Intersection intsec) {\n    intsec.dist = MAXDIST;\n   \n    if (GetBallIntersection(intsec, ray, GetBall1Pos(t), 1.0, MINDIST, MAXDIST, 0.0) > 0.5)\n    {\n        intsec.tnrm = GetBall1TextureTransformation(t, intsec.nrm);\n        intsec.txtOffset = vec2(0.0, 0.0);\n    }\n    if (GetBallIntersection(intsec, ray, GetBall9Pos(t), 1.0, MINDIST, MAXDIST, 1.0) > 0.5)\n    {\n        intsec.tnrm = GetBall9TextureTransformation(t, intsec.nrm);\n        intsec.txtOffset = vec2(0.5, 0.0);\n    }\n    if (GetBallIntersection(intsec, ray, GetBall8Pos(t), 1.0, MINDIST, MAXDIST, 2.0) > 0.5)\n    {\n        intsec.tnrm = GetBall8TextureTransformation(t, intsec.nrm);\n        intsec.txtOffset = vec2(0.0, 0.5);\n    }\n    if (GetBallIntersection(intsec, ray, GetBall4Pos(t), 1.0, MINDIST, MAXDIST, 3.0) > 0.5)\n    {\n        intsec.tnrm = GetBall4TextureTransformation(t, intsec.nrm);\n        intsec.txtOffset = vec2(0.5, 0.5);\n    }\n    GetBallIntersection(intsec, ray, GetBallwPos(t), 1.0, MINDIST, MAXDIST, 4.0);\n    GetPlaneIntersection(intsec, ray, vec3(0.0), vec3(0.0, 0.0, 1.0), MINDIST, MAXDIST, 5.0);\n}\n\nfloat GetBallShadow(in Ray ray, in float t, in float maxDist) {\n    if (GetBallShadow(ray, GetBall1Pos(t), 1.0, MINDIST, maxDist) < 0.5)\n        return 0.0;\n    if (GetBallShadow(ray, GetBall9Pos(t), 1.0, MINDIST, maxDist) < 0.5)\n        return 0.0;\n    if (GetBallShadow(ray, GetBall8Pos(t), 1.0, MINDIST, maxDist) < 0.5)\n        return 0.0;\n    if (GetBallShadow(ray, GetBall4Pos(t), 1.0, MINDIST, maxDist) < 0.5)\n        return 0.0;\n    if (GetBallShadow(ray, GetBallwPos(t), 1.0, MINDIST, maxDist) < 0.5)\n        return 0.0;\n    return 1.0;\n}\n\n// Returns 0..4, 0..1 (0..1, 0..1 for each side - no bottom & top sides)\nvec2 DirToCube(in vec3 rd) {\n    float plane = mix(step(0.0, rd.x), step(rd.y, 0.0) + 0.5, step(abs(rd.x), abs(rd.y))) * 2.0;\n    vec2 v;\n    switch (int(plane))\n    {\n        case 0:\n            v = vec2(-rd.y / rd.x, -rd.z / rd.x);\n            break;\n        case 1:\n            v = vec2(rd.x / rd.y, rd.z / rd.y);\n            break;\n        case 2:\n            v = vec2(-rd.y / rd.x, rd.z / rd.x);\n            break;\n        case 3:\n            v = vec2(rd.x / rd.y, -rd.z / rd.y);\n            break;\n    }\n    return v * 0.5 + vec2(0.5 + plane, 0.5);\n}\n\nvec3 GetCubemapYellow(in vec2 uv) {\n    float x1[] = float[](1014.9, 762.6, 637.0, 409.6, 329.4, 261.2);\n    float y1[] = float[](123.8, 133.7, 111.7, 123.5, 122.2, 130.4);\n    float x2[] = float[](776.4, 666.0, 571.0, 466.4, 397.9, 321.8);\n    float y2[] = float[](186.5, 161.9, 175.0, 183.4, 184.2, 167.5);\n    for (int part = 0; part < 6; part++) {\n        float x = (uv.x - x1[part]) * 255.0 / (x2[part] - x1[part]);\n        if (x >= -10.0 && x <= 265.0) {\n            float y = (uv.y - y1[part]) * 255.0 / (y2[part] - y1[part]);\n            if (y >= -10.0 && y <= 265.0) {\n                return texture(iChannel0, (vec2(x, y) + vec2(22.0)) / vec2(900.0, 600.0) + vec2(float(part % 3) / 3.0, float(part / 3) / 2.0),\n                    1.0).rgb;\n            }\n        }\n    }\n    return vec3(0.0);\n}\n\nvec3 GetFabricColor(in vec2 uv) {\n    return texture(iChannel2, mod(uv * 0.08, 1.0)).rgb;\n}\n\nvec3 Render(in Ray ray, in float t, in vec3 noise) {\n    vec3 result = vec3(0.0);\n    float refl = 1.0;\n\n    for (float iter = 0.0; iter <= MAXITER; iter++)\n    {\n        Intersection intsec;\n        Ray mray, sray; // Shadow & Mirror rays\n\n        GetIntsec(ray, t, intsec);\n        int obj = -1;\n        if (intsec.dist < MAXDIST) {\n            obj = int(intsec.obj + 0.5);\n            \n            // Calculate mirror ray\n            float a = -dot(intsec.nrm, ray.rd);\n            mray.ro = intsec.pos;\n            mray.rd = ray.rd + 2.0 * a * intsec.nrm;\n\n            vec3 color = COLOR[obj];\n            if (obj < 4) // Balls with texture\n            {\n                intsec.tnrm = normalize(intsec.tnrm);\n                vec2 uv = vec2(\n                        atan(intsec.tnrm.y, intsec.tnrm.x) / TEXTUREANGLE,\n                        atan(intsec.tnrm.z, length(intsec.tnrm.xy)) / TEXTUREANGLE);\n                float c1 = step(length(uv), 1.0);\n                float c2 = step(float(intsec.obj), 1.0) * step(abs(intsec.tnrm.x), 0.5);\n                color =\n                    color * (1.0 - c1 - c2) +\n                    c1 * mix(COLOR[1], COLOR[2], texture(iChannel1, uv * 0.25 + vec2(0.25) + intsec.txtOffset).r) +\n                    c2 * COLOR[0]; // Band color is the same as of the yellow ball\n            } \n            else if (obj == 5 && iter == 0.0) // Cloth\n            {\n                color = GetFabricColor(intsec.pos.xy);\n            }\n            for (int n = 0; n < LIGHT_POS.length(); n++) {\n                vec3 ltVec1 = LIGHT_POS[n] - intsec.pos;\n                float a = noise.x * PI * 2.0;\n                float b = noise.y * PI * 2.0;\n\n                vec3 ltVec3 = ltVec1 + vec3(cos(a) * cos(b), sin(a) * cos(b), sin(b)) * LIGHT_RAD1[n];\n\n                float lightDist = length(ltVec3);\n\n                Ray sray;\n                sray.ro = intsec.pos;\n                sray.rd = ltVec3 / lightDist;\n\n                float shadow = GetBallShadow(sray, t, lightDist + 0.01);\n\n                float specInt = 0.0;\n                if (obj < 5) // All balls\n                {\n                    float k =\n                        dot(LIGHT_POS[n] - mray.ro, ltVec3) /\n                        dot(mray.rd, ltVec3);\n                    vec3 v = mray.ro + k * mray.rd - LIGHT_POS[n];\n                    specInt = k > MINDIST && k < length(ltVec1) + LIGHT_RAD2[n] ?\n                        max(0.0, min(1.0, (length(v) - LIGHT_RAD2[n]) / (LIGHT_RAD1[n] - LIGHT_RAD2[n]))) :\n                        0.0;\n                }\n                float i = max(0.0, dot(ltVec3 / lightDist, intsec.nrm)) * 0.333 * shadow;\n                float specularIntensity = specInt * shadow;\n\n                result = result + refl * (i * color + specularIntensity + AMBIENT);\n            }\n        } \n        else \n        {\n            float jitter = (1.0 - iter) * 0.1;\n            vec3 hor = normalize(cross(ray.rd, vec3(ray.rd.y, 0.0, ray.rd.x)));\n            vec3 ver = normalize(cross(hor, ray.rd));\n            \n            vec2 coord = DirToCube(ray.rd);\n            result = result + refl * GetCubemapYellow(coord * 255.0);\n        }\n        \n        // Initialize for next iteration\n        refl = obj < 5 ? REFL : 0.0;\n        if (refl < 0.1) break;\n        ray = mray;\n    }\n    return result;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //fragColor.rgb = GetCubemapYellow(vec2(fragCoord.x / iResolution.x * 1024.0, fragCoord.y / iResolution.y * 255.0));\n    //fragColor.rgb = texture(iChannel0, (fragCoord / iResolution.xy)).rgb;\n    //fragColor.rgb = texture(iChannel1, (fragCoord / iResolution.yy)).rgb;\n    //fragColor.rgb = texture(iChannel2, (fragCoord / iResolution.yy)).rgb;\n    //return;\n    fragColor = texelFetch(iChannel3, ivec2(fragCoord), 0);\n    \n    vec3 noise = noiseFunc(fragCoord);\n    Camera camera = GetCamera(noise.xy);\n  \n    #ifdef ANIMATE\n        // animation with a slight motion blur\n        float time = mod(iTime * 2.0, 2.0) - 0.2 + noise.z * 0.1;\n    #else\n        // fully blurred\n        float time = noise.z * 1.0;\n    #endif\n\n    Ray ray = GetCameraRay(camera, fragCoord + noise.xy);\n    vec3 color = Render(ray, time, noise);\n\n    ivec2 fg = ivec2(fragCoord - vec2(0.5));\n    if (fg.y == 0)\n    {\n        // Store mouse for next frame\n        fragColor = \n            fg.x == 0 ? iMouse :\n            fg.x == 1 ? iResolution.xyxy :\n            vec4(0.);\n    }\n    else\n    {\n        vec4 lastMouse = texelFetch(iChannel3, ivec2(0, 0), 0);\n        vec2 lastResolution = texelFetch(iChannel3, ivec2(1, 0), 0).xy;\n        if ((iMouse.z > .0 && distance(lastMouse.xy, iMouse.xy) > 2.0) || \n            (lastMouse.z > 0.5 && iMouse.z < 0.5) ||\n            (iResolution.x != lastResolution.x))\n        {\n            fragColor = vec4(color, 1.0);\n        }\n        else\n        {\n            fragColor = vec4(fragColor.rgb + color, fragColor.w + 1.0);\n        }\n    }\n}\n","name":"Buffer D","description":"","type":"buffer"}]}