{"ver":"0.1","info":{"id":"X3j3Dh","date":"1710920707","viewed":156,"name":"Random Bouncing Particles","username":"Delincoter","description":"The particles will move according to the initial direction as the screen refreshes, and will bounce when they hit the boundary of the collider.","likes":2,"published":3,"flags":32,"usePreview":0,"tags":["2d","random","particles","update"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//The code is taken from the video of Youtuber Sebastian Lague\n//https://www.youtube.com/watch?v=rSKMYc1CQHE\n\nfloat drawCircle(vec2 p, float Size)\n{\n    float c;\n    c = step(length(p) , Size);\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    float C;\n    \n    for(int i = 0; i < NUM; i++)\n    {\n        vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n        \n        vec2 p = texture(iChannel0, vec2(0.5+float(i)) / iResolution.xy, 0.).xy;\n        uv -= p;\n    \n        C += drawCircle(uv, particleSize);\n    }\n\n\n    fragColor = vec4(C);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Update Buffer\nvec2[NUM] positions, velocitys, direction;\n\nfloat hash(float p)\n{\n    p = p*127.13;\t\t \n    return -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    float particlesPerRow = floor(sqrt(float(NUM)));\n    float particlesPerCol = floor((float(NUM) - 1.) / particlesPerRow + 1.);\n    float spacing = particleSize * 2. + particleSpacing;\n    \n    vec2 halfBoundsSize = boundsSize * vec2(iResolution.x/iResolution.y * 0.5, 0.5) - particleSize; //Collider\n    \n    vec4 update;\n    for(int i = 0; i < NUM; i++)\n    {\n        float compare = step(1., float(iFrame));\n   \n        float x = (mod(float(i), particlesPerRow) - particlesPerRow * 0.5 + 0.5) * spacing;\n        float y = (floor(float(i) / particlesPerRow) - particlesPerCol * 0.5 + 0.5) * spacing;\n        \n        vec4 pv = texture(iChannel0, vec2((0.5+float(i)) / iResolution.x, 0.));\n        \n        direction[i] = normalize(vec2(hash(float(i)*128.21+153.81), hash(float(i)*753.89+256.37))) * initialSpeed;\n        \n        velocitys[i] = mix(direction[i], pv.zw, compare);\n        \n        positions[i] = mix(vec2(x, y),  pv.xy, compare);\n          \n    \n        positions[i] += velocitys[i] * iTimeDelta;\n        \n    \n\n        compare = step(halfBoundsSize.x, abs(positions[i].x));\n\n        positions[i].x = positions[i].x * (1.-compare) + halfBoundsSize.x * sign(positions[i].x) * compare;\n        velocitys[i].x = velocitys[i].x * (1.-compare) + velocitys[i].x * -1. * collisionDamping * compare;\n        \n    \n        compare = step(halfBoundsSize.y, abs(positions[i].y));\n\n        positions[i].y = positions[i].y * (1.-compare) + halfBoundsSize.y * sign(positions[i].y) * compare;\n        velocitys[i].y = velocitys[i].y * (1.-compare) + velocitys[i].y * -1. * collisionDamping * compare;\n    \n\n        update = fragCoord.x < float(i) ? update : vec4(positions[i], velocitys[i]);      \n    }\n    \n    \n    fragColor = update;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const int NUM = 100;\n\nconst float particleSize = 0.01;\nconst float particleSpacing = 0.;\n\nconst float initialSpeed = 1.;\n\nconst vec2 boundsSize = vec2(1.);\nconst float collisionDamping = 1.;","name":"Common","description":"","type":"common"}]}