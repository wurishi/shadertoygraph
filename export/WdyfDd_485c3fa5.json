{"ver":"0.1","info":{"id":"WdyfDd","date":"1608210215","viewed":276,"name":"Julia's Orb","username":"darkeclipz","description":"A fractal orb.\n\n - https://darkeclipz.blogspot.com/2020/12/shader-julias-orb.html","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["fractal","circle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// set to 0 or 1\n#define SIMPLE 0\n\n#define R iResolution.xy\n#define pi 3.14159\nfloat ln2 = log(2.);\nvec3 c0 = vec3(0,2,5)/255.;\nvec3 c1 = vec3(8,45,58)/255.;\nvec3 c2 = vec3(38,116,145)/255.;\nvec3 c3 = vec3(167,184,181)/260.;\nvec3 c4 = vec3(38,116,145)/255.;\n\nvec3 cmap(float t) {\n    vec3 col = vec3(0);\n    col = mix( c0,  c1, smoothstep(0. , .2, t));\n    col = mix( col, c2, smoothstep(.2, .4 , t));\n    col = mix( col, c3, smoothstep(.4 , .6, t));\n    col = mix( col, c4, smoothstep(.6,  .8, t));\n    col = mix( col, c0, smoothstep(.8, 1.,  t));\n    return col;\n}\n\nfloat julia(vec2 z, vec2 c, float n) {\n    float i = 0.;\n    for(i=0.; i < n; i++) {\n        z = abs(z);\n        z = mat2(z, -z.y, z.x) * z + c;\n        if( dot(z,z) > 4. ) break;\n    }\n    return (i - log(log(dot(z,z))/ln2)/ln2) / n;\n}\n\nvec3 ripple(float t) {\n    float a = 0.4;\n    float b = 0.92;\n    vec3 black = vec3(0);\n    vec3 white = vec3(1);\n    vec3 col = mix(black, white, t/a);\n    col = black * smoothstep(0.0, a, t) + white * smoothstep(a, b, t) + black - smoothstep(b, 1.0, t);\n\treturn 1.-col;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 1.1*(2.*fragCoord-R)/R.y;\n    float a = 0.2;\n    float b = 0.05;\n    float t = iTime/4.;\n    float t1 = a*(cos(t)*.5+.5)-a/2.;\n    float t2 = b*(cos(2.23*t)*.5 +.5)-b/2.;\n    float t3 = b*(cos(5.78*t)*.5 +.5)-b/2.;\n    float t4 = b*(cos(7.66*t)*.5 +.5)-b/2.;\n    float t5 = b*(cos(-3.14*t)*.5 +.5)-b/2.;\n    \n    // https://en.wikipedia.org/wiki/Coordinate_systems_for_the_hyperbolic_plane\n    vec2 uv2 = uv*uv;\n    vec2 uvh = vec2(uv.x / (1.0+sqrt(1.0-uv2.x-uv2.y)), \n                    uv.y / (1.0+sqrt(1.0-uv2.x-uv2.y)));\n    uvh *= mat2(cos(3.0*t1+t2), sin(2.0*t1+t3), \n                sin(3.0*t1+t4), cos(5.0*t1+t5));\n    \n    // Rendering of two Julia Burning Ship fractals.\n    vec3 col = vec3(0);\n    float f1 = julia(uvh, vec2(-0.185, 0.192), 100.+30.*t2*1.0/b+b/2.);\n    float f2 = julia(2.2*uvh, vec2(-0.144, 0.228), 70.+20.*t3*1.0/b+b/2.);\n    float f3 = julia(7.4*uvh, vec2(-0.185, 0.192), 60.);\n    float sn = f1 + f2 + f3;\n    col = cmap(fract(2.*(clamp(sn, .0, 1.) + t/4.)))\n        #if !SIMPLE\n        * (0.2 +     ripple(fract(15.*sn))) \n        * (0.2 + 0.8*ripple(fract(20.*sn + 0.5)))\n        * (0.4 + 0.6*ripple(fract(35.*sn)))\n        #endif\n        ;\n   \n    // https://stackoverflow.com/questions/9604132/how-to-project-a-point-on-to-a-sphere\n    vec3 p = vec3(uv, 0.5);\n    vec3 n = p / length(p);\n    vec3 light = vec3(3.75,3.75,8.1);\n    vec3 v = vec3(0.,0,0.5);\n\n    // shade\n    vec3 l = normalize(p - light);\n    vec3 h = normalize(v + l);\n    vec3 m_spec = vec3(0.6);\n    vec3 s_spec = vec3(232, 249, 255)/255.;\n    float m_gsl = 1.8;\n    vec3 c_spec = (m_spec * s_spec) * pow(max(-dot(n, h), 0.), m_gsl);\n    vec3 m_diff = col;\n    vec3 s_diff = vec3(1.0);\n    vec3 c_diff = (s_diff * m_diff) * max(-dot(n, l), 0.);\n    vec3 g_amb = m_diff;   \n    col = c_spec + c_diff + g_amb;  \n    \n    \n    // cut\n    col *= clamp(smoothstep(0.99, 0.97, length(uv)), 0., 1.);\n    \n    // shadow on edges\n    col *= smoothstep(1.0, 0.0, length(uv) - 0.42);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}