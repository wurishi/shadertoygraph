{"ver":"0.1","info":{"id":"clX3WX","date":"1672770723","viewed":15,"name":"Fork Tricubic t antonalog 148","username":"Antonalog","description":"Tricubic with gradient, note funny axis flippery going on for partial derivatives. \nTop row (cubic, gradient of cubic) \nBottom row (linear, central difference gradient)\nCompare the trivial implementation and the clever version that uses trilinear fetches","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["spline","bicubic","interpolation","rand","tricubic","hermit","samplingrnd"],"hasliked":0,"parentid":"cts3Rj","parentname":"Tricubic texture sampling"},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"tricubic 3Dtexture interpolation\" by FabriceNeyret2. https://shadertoy.com/view/MtjBWz\n// 2022-12-26 09:41:43\n\n// volumetric variant of  https://shadertoy.com/view/XlBBRR\n\n// Ported from here: https://gist.github.com/Fewes/59d2c831672040452aa77da6eaab2234\nvec4 textureCubic(sampler3D volume, vec3 coord)\n{\n    vec3 texSize = iChannelResolution[0].xyz;\n    \n\t// Shift the coordinate from [0,1] to [-0.5, textureSize-0.5]\n\tvec3 coord_grid = coord * texSize - 0.5;\n\tvec3 index = floor(coord_grid);\n\tvec3 t = coord_grid - index;\n\tvec3 one_minus_t = 1.0 - t;\n\n    //book has the long form, guess they saved some ops!\n    // (1-t)*(1-t)*(1-t) = (1-2t+t^2)*(1-t) = 1 - 2t + t^2 - t + t^2 - t^3 = -t^3 + 2 t^2 - 3 t + 1\n\tvec3 w0 = 1.0/6.0 * one_minus_t*one_minus_t*one_minus_t;\n\tvec3 w1 = 2.0/3.0 - 0.5 * t*t*(2.0-t);\n\tvec3 w2 = 2.0/3.0 - 0.5 * one_minus_t*one_minus_t*(2.0-one_minus_t);\n\tvec3 w3 = 1.0/6.0 * t*t*t;\n\n\tvec3 g0 = w0 + w1;\n\tvec3 g1 = w2 + w3;\n\tvec3 mult = 1.0 / texSize;\n\tvec3 h0 = mult * ((w1 / g0) - 0.5 + index); //h0 = w1/g0 - 1, move from [-0.5, textureSize-0.5] to [0,1]\n\tvec3 h1 = mult * ((w3 / g1) + 1.5 + index); //h1 = w3/g1 + 1, move from [-0.5, textureSize-0.5] to [0,1]\n\n\t// Fetch the eight linear interpolations\n\t// Weighting and fetching is interleaved for performance and stability reasons\n\tvec4 tex000 = textureLod(iChannel0, h0, 0.);\n\tvec4 tex100 = textureLod(iChannel0, vec3(h1.x, h0.y, h0.z), 0.0);\n\ttex000 = mix(tex100, tex000, g0.x); // Weigh along the x-direction\n\n\tvec4 tex010 = textureLod(iChannel0, vec3(h0.x, h1.y, h0.z), 0.0);\n\tvec4 tex110 = textureLod(iChannel0, vec3(h1.x, h1.y, h0.z), 0.0);\n\ttex010 = mix(tex110, tex010, g0.x); // Weigh along the x-direction\n\ttex000 = mix(tex010, tex000, g0.y); // Weigh along the y-direction\n\n\tvec4 tex001 = textureLod(iChannel0, vec3(h0.x, h0.y, h1.z), 0.0);\n\tvec4 tex101 = textureLod(iChannel0, vec3(h1.x, h0.y, h1.z), 0.0);\n\ttex001 = mix(tex101, tex001, g0.x); // Weigh along the x-direction\n\n\tvec4 tex011 = textureLod(iChannel0, vec3(h0.x, h1.y, h1.z), 0.0);\n\tvec4 tex111 = textureLod(iChannel0, h1, 0.0);\n\ttex011 = mix(tex111, tex011, g0.x); // Weigh along the x-direction\n\ttex001 = mix(tex011, tex001, g0.y); // Weigh along the y-direction\n\n\treturn mix(tex001, tex000, g0.z); // Weigh along the z-direction\n}\n\nvec4 textureCubicGradient(sampler3D volume, vec3 coord)\n{\n    vec3 texSize = iChannelResolution[0].xyz;\n\tvec3 mult = 1.0 / texSize;\n    \n\t// Shift the coordinate from [0,1] to [-0.5, textureSize-0.5]\n\tvec3 coord_grid = coord * texSize - 0.5 ;  \n        \n\tvec3 index = floor(coord_grid);\n\tvec3 t = coord_grid - index;\n\tvec3 one_minus_t = 1.0 - t;\n\n    vec3 tt = t * t;\n    vec3 ttt = tt * t;\n    \n    vec3 one_minus_t_all_squared = one_minus_t*one_minus_t;\n    vec3 one_minus_t_all_cubed = one_minus_t_all_squared*one_minus_t;\n    \n    //book has the long form, guess they saved some ops!\n    // (1-t)*(1-t)*(1-t) = (1-2t+t^2)*(1-t) = 1 - 2t + t^2 - t + t^2 - t^3 = -t^3 + 2 t^2 - 3 t + 1\n    vec3 w[4];\n\tw[0] = 1.0/6.0 * one_minus_t_all_cubed;\n\tw[1] = 2.0/3.0 - 0.5 * tt*(2.0-t);\n\tw[2] = 2.0/3.0 - 0.5 * one_minus_t_all_squared*(2.0-one_minus_t);\n\tw[3] = 1.0/6.0 * ttt;\n\n    //derivatives of weights\n    vec3 d[4];\n    d[0] = -0.5 * tt + t - 0.5;\n    d[1] =  1.5 * tt - 2. * t;\n    d[2] = -1.5 * tt + t + 0.5;\n    d[3] =  0.5 * tt;\n        \n    vec4 grad = vec4(0.);\n    \n    ivec3 int_index = ivec3(index) - ivec3(1);\n    \n    for (int z=0; z<4; z++) for (int y=0; y<4; y++) for (int x=0; x<4; x++)\n    {    \n        ivec3 p = ivec3(x,y,z) + int_index;\n        \n        //texelFetch doesn't wrap\n        for (int i=0; i<3; i++)\n            if (p[i] < 0) p[i] += int(iChannelResolution[0][i]);\n\n        float s = texelFetch(iChannel0, p, 0).x;\n        grad.w += s *  w[x].x *  w[y].y *  w[z].z;\n        \n        //To compute the gradient in higher dimensions,\n        //we obtain the corresponding filter kernels via the tensor product of a 1D derived cubic B-spline for the axis of derivation,\n        //and 1D (nonderived) cubic B-splines for the other axes.\n        //https://developer.nvidia.com/gpugems/gpugems2/part-iii-high-quality-rendering/chapter-20-fast-third-order-texture-filtering\n        grad.x += s *  d[x].x *  w[y].y *  w[z].z;\n        grad.y += s *  w[x].x *  d[y].y *  w[z].z;\n        grad.z += s *  w[x].x *  w[y].y *  d[z].z;      \n    }\n    \n    return grad;\n}\n\nfloat textureCubic(sampler3D volume, vec3 index, vec3 w0, vec3 w1, vec3 w2, vec3 w3)\n{\n    vec3 texSize = iChannelResolution[0].xyz;\n\n\tvec3 g0 = w0 + w1;\n\tvec3 g1 = w2 + w3;\n\tvec3 mult = 1.0 / texSize;\n\tvec3 h0 = mult * ((w1 / g0) - 0.5 + index); //h0 = w1/g0 - 1, move from [-0.5, textureSize-0.5] to [0,1]\n\tvec3 h1 = mult * ((w3 / g1) + 1.5 + index); //h1 = w3/g1 + 1, move from [-0.5, textureSize-0.5] to [0,1]\n\n\t// Fetch the eight linear interpolations\n\t// Weighting and fetching is interleaved for performance and stability reasons\n\tfloat tex000 = textureLod(iChannel0, h0, 0.).x;\n\tfloat tex100 = textureLod(iChannel0, vec3(h1.x, h0.y, h0.z), 0.0).x;\n\ttex000 = mix(tex100, tex000, g0.x); // Weigh along the x-direction\n\n\tfloat tex010 = textureLod(iChannel0, vec3(h0.x, h1.y, h0.z), 0.0).x;\n\tfloat tex110 = textureLod(iChannel0, vec3(h1.x, h1.y, h0.z), 0.0).x;\n\ttex010 = mix(tex110, tex010, g0.x); // Weigh along the x-direction\n\ttex000 = mix(tex010, tex000, g0.y); // Weigh along the y-direction\n\n\tfloat tex001 = textureLod(iChannel0, vec3(h0.x, h0.y, h1.z), 0.0).x;\n\tfloat tex101 = textureLod(iChannel0, vec3(h1.x, h0.y, h1.z), 0.0).x;\n\ttex001 = mix(tex101, tex001, g0.x); // Weigh along the x-direction\n\n\tfloat tex011 = textureLod(iChannel0, vec3(h0.x, h1.y, h1.z), 0.0).x;\n\tfloat tex111 = textureLod(iChannel0, h1, 0.0).x;\n\ttex011 = mix(tex111, tex011, g0.x); // Weigh along the x-direction\n\ttex001 = mix(tex011, tex001, g0.y); // Weigh along the y-direction\n\n\treturn mix(tex001, tex000, g0.z); // Weigh along the z-direction\n}\n\nfloat textureCubicX(sampler3D volume, vec3 index, vec3 w0, vec3 w1, vec3 w2, vec3 w3)\n{\n    vec3 texSize = iChannelResolution[0].xyz;\n\n\tvec3 g0 = w0 + w1;\n\tvec3 g1 = w2 + w3;\n\tvec3 mult = 1.0 / texSize;\n\tvec3 h0 = mult * ((w1 / g0) - 0.5 + index); //h0 = w1/g0 - 1, move from [-0.5, textureSize-0.5] to [0,1]\n\tvec3 h1 = mult * ((w3 / g1) + 1.5 + index); //h1 = w3/g1 + 1, move from [-0.5, textureSize-0.5] to [0,1]\n\n\t// Fetch the eight linear interpolations\n\t// Weighting and fetching is interleaved for performance and stability reasons\n\tfloat tex000 = textureLod(iChannel0, h0, 0.).x;\n\tfloat tex100 = textureLod(iChannel0, vec3(h1.x, h0.y, h0.z), 0.0).x;\n\ttex000 = (tex000 - tex100) * g0.x; // Weigh along the x-direction\n\n\tfloat tex010 = textureLod(iChannel0, vec3(h0.x, h1.y, h0.z), 0.0).x;\n\tfloat tex110 = textureLod(iChannel0, vec3(h1.x, h1.y, h0.z), 0.0).x;\n\ttex010 = (tex010 - tex110) * g0.x; // Weigh along the x-direction\n\ttex000 = mix(tex010, tex000, g0.y); // Weigh along the y-direction\n\n\tfloat tex001 = textureLod(iChannel0, vec3(h0.x, h0.y, h1.z), 0.0).x;\n\tfloat tex101 = textureLod(iChannel0, vec3(h1.x, h0.y, h1.z), 0.0).x;\n\ttex001 = (tex001 - tex101) * g0.x; // Weigh along the x-direction\n\n\tfloat tex011 = textureLod(iChannel0, vec3(h0.x, h1.y, h1.z), 0.0).x;\n\tfloat tex111 = textureLod(iChannel0, h1, 0.0).x;\n\ttex011 = (tex011 - tex111) * g0.x;  // Weigh along the x-direction\n\ttex001 = mix(tex011, tex001, g0.y); // Weigh along the y-direction\n\n\treturn mix(tex001, tex000, g0.z); // Weigh along the z-direction\n}\n\nfloat textureCubicY(sampler3D volume, vec3 index, vec3 w0, vec3 w1, vec3 w2, vec3 w3)\n{\n    vec3 texSize = iChannelResolution[0].xyz;\n\n\tvec3 g0 = w0 + w1;\n\tvec3 g1 = w2 + w3;\n\tvec3 mult = 1.0 / texSize;\n\tvec3 h0 = mult * ((w1 / g0) - 0.5 + index); //h0 = w1/g0 - 1, move from [-0.5, textureSize-0.5] to [0,1]\n\tvec3 h1 = mult * ((w3 / g1) + 1.5 + index); //h1 = w3/g1 + 1, move from [-0.5, textureSize-0.5] to [0,1]\n\n\t// Fetch the eight linear interpolations\n\t// Weighting and fetching is interleaved for performance and stability reasons\n\tfloat tex000 = textureLod(iChannel0, h0, 0.).x;\n\tfloat tex100 = textureLod(iChannel0, vec3(h1.x, h0.y, h0.z), 0.0).x;\n\ttex000 = mix(tex100, tex000, g0.x); // Weigh along the x-direction\n\n\tfloat tex010 = textureLod(iChannel0, vec3(h0.x, h1.y, h0.z), 0.0).x;\n\tfloat tex110 = textureLod(iChannel0, vec3(h1.x, h1.y, h0.z), 0.0).x;\n\ttex010 = mix(tex110, tex010, g0.x); // Weigh along the x-direction\n\ttex000 = (tex000 - tex010) * g0.y; // Weigh along the y-direction\n\n\tfloat tex001 = textureLod(iChannel0, vec3(h0.x, h0.y, h1.z), 0.0).x;\n\tfloat tex101 = textureLod(iChannel0, vec3(h1.x, h0.y, h1.z), 0.0).x;\n\ttex001 = mix(tex101, tex001, g0.x); // Weigh along the x-direction\n\n\tfloat tex011 = textureLod(iChannel0, vec3(h0.x, h1.y, h1.z), 0.0).x;\n\tfloat tex111 = textureLod(iChannel0, h1, 0.0).x;\n\ttex011 = mix(tex111, tex011, g0.x); // Weigh along the x-direction\n\ttex001 = (tex001 - tex011) * g0.y; // Weigh along the y-direction\n\n\treturn mix(tex001, tex000, g0.z); // Weigh along the z-direction\n}\n\n\nfloat textureCubicZ(sampler3D volume, vec3 index, vec3 w0, vec3 w1, vec3 w2, vec3 w3)\n{\n    vec3 texSize = iChannelResolution[0].xyz;\n\n\tvec3 g0 = w0 + w1;\n\tvec3 g1 = w2 + w3;\n\tvec3 mult = 1.0 / texSize;\n\tvec3 h0 = mult * ((w1 / g0) - 0.5 + index); //h0 = w1/g0 - 1, move from [-0.5, textureSize-0.5] to [0,1]\n\tvec3 h1 = mult * ((w3 / g1) + 1.5 + index); //h1 = w3/g1 + 1, move from [-0.5, textureSize-0.5] to [0,1]\n\n\t// Fetch the eight linear interpolations\n\t// Weighting and fetching is interleaved for performance and stability reasons\n\tfloat tex000 = textureLod(iChannel0, h0, 0.).x;\n\tfloat tex100 = textureLod(iChannel0, vec3(h1.x, h0.y, h0.z), 0.0).x;\n\ttex000 = mix(tex100, tex000, g0.x); // Weigh along the x-direction\n\n\tfloat tex010 = textureLod(iChannel0, vec3(h0.x, h1.y, h0.z), 0.0).x;\n\tfloat tex110 = textureLod(iChannel0, vec3(h1.x, h1.y, h0.z), 0.0).x;\n\ttex010 = mix(tex110, tex010, g0.x); // Weigh along the x-direction\n\ttex000 = mix(tex010, tex000, g0.y); // Weigh along the y-direction\n\n\tfloat tex001 = textureLod(iChannel0, vec3(h0.x, h0.y, h1.z), 0.0).x;\n\tfloat tex101 = textureLod(iChannel0, vec3(h1.x, h0.y, h1.z), 0.0).x;\n\ttex001 = mix(tex101, tex001, g0.x); // Weigh along the x-direction\n\n\tfloat tex011 = textureLod(iChannel0, vec3(h0.x, h1.y, h1.z), 0.0).x;\n\tfloat tex111 = textureLod(iChannel0, h1, 0.0).x;\n\ttex011 = mix(tex111, tex011, g0.x); // Weigh along the x-direction\n\ttex001 = mix(tex011, tex001, g0.y); // Weigh along the y-direction\n\n\treturn (tex000 - tex001) * g0.z; // Weigh along the z-direction\n}\n\nvec4 textureCubicGradientClever(sampler3D volume, vec3 coord)\n{\n    vec3 texSize = iChannelResolution[0].xyz;\n    \n\t// Shift the coordinate from [0,1] to [-0.5, textureSize-0.5]\n\tvec3 coord_grid = coord * texSize - 0.5;\n\tvec3 index = floor(coord_grid);\n\tvec3 t = coord_grid - index;\n\tvec3 one_minus_t = 1.0 - t;\n\n    vec3 tt = t * t;\n    vec3 ttt = tt * t;\n\n    //book has the long form, guess they saved some ops!\n    // (1-t)*(1-t)*(1-t) = (1-2t+t^2)*(1-t) = 1 - 2t + t^2 - t + t^2 - t^3 = -t^3 + 2 t^2 - 3 t + 1\n\tvec3 w0 = 1.0/6.0 * one_minus_t*one_minus_t*one_minus_t;\n\tvec3 w1 = 2.0/3.0 - 0.5 * tt*(2.0-t);\n\tvec3 w2 = 2.0/3.0 - 0.5 * one_minus_t*one_minus_t*(2.0-one_minus_t);\n\tvec3 w3 = 1.0/6.0 * ttt;\n\n    vec3 d0 = -0.5 * tt + t - 0.5;\n    vec3 d1 =  1.5 * tt - 2. * t;\n    vec3 d2 = -1.5 * tt + t + 0.5;\n    vec3 d3 =  0.5 * tt;\n\n    vec4 grad;\n\n    //3 x 8 trilinear taps I guess is still better than 64 x texelFetch lol.\n    \n    //x parts get the d\n    grad.x = textureCubicX(volume, index, vec3(d0.x,w0.y,w0.z), vec3(d1.x,w1.y,w1.z), vec3(d2.x,w2.y,w2.z), vec3(d3.x,w3.y,w3.z) );\n    //y parts get the d\n    grad.y = textureCubicY(volume, index, vec3(w0.x,d0.y,w0.z), vec3(w1.x,d1.y,w1.z), vec3(w2.x,d2.y,w2.z), vec3(w3.x,d3.y,w3.z) );\n    //z parts get the d\n    grad.z = textureCubicZ(volume, index, vec3(w0.x,w0.y,d0.z), vec3(w1.x,w1.y,d1.z), vec3(w2.x,w2.y,d2.z), vec3(w3.x,w3.y,d3.z) );\n    \n    grad.w = textureCubic(volume, index, w0, w1, w2, w3 );\n    return grad;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv2 = uv;\n    uv2.x *= aspect;\n    \n    vec3 V = 0.5 * vec3(uv2, 0.05 * iTime);\n    \n    if (uv.y >= 0.5)\n    {\n        if (uv.x < 0.5)\n            fragColor = vec4(textureCubic(iChannel0, V).x);\n        else\n//            fragColor = vec4(textureCubicGradient(iChannel0, V).xyz*0.5+0.5,1.);\n            fragColor = vec4(textureCubicGradientClever(iChannel0, V).xyz*0.5+0.5,1.);\n    }\n    else\n    {\n        if (uv.x < 0.5)\n            fragColor = vec4(texture(iChannel0, V).x);\n        else\n        {\n            vec3 d = vec3(0.);\n            vec3 t = vec3(1.) / iChannelResolution[0].xyz;\n            d.x = texture(iChannel0, V + vec3(t.x,0,0)).x - texture(iChannel0, V - vec3(t.x,0,0)).x;\n            d.y = texture(iChannel0, V + vec3(0,t.y,0)).x - texture(iChannel0, V - vec3(0,t.y,0)).x;\n            d.z = texture(iChannel0, V + vec3(0,0,t.z)).x - texture(iChannel0, V - vec3(0,0,t.z)).x;\n\n            fragColor.xyz = d * 0.5 + 0.5;\n        }\n    }\n    \n#if 0    \n    if (all(greaterThanEqual(V,vec3(0.))) && all(lessThanEqual(V,vec3(1.))))\n        fragColor.xyz = vec3(0,1,0);\n    else\n        fragColor.xyz = vec3(1,0,0);\n#endif\n\n//    if (uv.x>0.5) fragColor = sin(10.*fragColor);\n}\n","name":"Image","description":"","type":"image"}]}