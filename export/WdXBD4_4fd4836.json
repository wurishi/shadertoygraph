{"ver":"0.1","info":{"id":"WdXBD4","date":"1588309945","viewed":144,"name":"Day12: Interactive Bezier","username":"fluxatron","description":"Click and drag the handles!\n\nFirst attempt at using state to make an interactive demo.\n\nTotally winging the state management. I'd love suggestions on how to better manage this and also more efficient hit testing","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["interactive","state"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n\tCLICK AND DRAG THE HANDLES\n\n\tGOALS: \n\t1. Clicking on a handle interacts with it (picking)\n\t2. Can interact with all handles\n\t3. Preserve user placed handles for the session (state)\n*/\n\n\nvec4 Load(vec2 coord)\n{\n    return texelFetch(iChannel0, ivec2(coord), 0);\n}\nBezierControl LoadControl(vec2 coord)\n{\n    return DeserializeControl(Load(coord));\n}\n\n\n// TYPES //////////////////////////////////////////////////////////////////////////////////\n\nstruct BezierLook\n{\n    vec3 BezierCol;\n    vec3 HandleCol;\n    vec3 LineCol;\n    vec3 VertCol;\n    float BezierThicc;\n};\n    \nstruct Hit\n{\n    float Dist;\n    vec3 Col;\n};\n\n\n// SHAPES /////////////////////////////////////////////////////////////////////////////////\nfloat sdCircle(vec2 p, float r)\n{\n    return length(p) - r;\n}\nfloat sdLineSegment(vec2 p, vec2 a, vec2 b, float halfThicc)\n{\n    vec2 ap = p-a;\n    vec2 ab = b-a;\n    float h = clamp(dot(ap,ab)/dot(ab,ab), 0.0, 1.0); // project ap onto ab\n\treturn length(ap - ab*h) - halfThicc; // finds length of vec from p to the projection of p onto ab\n}\n\nvec2 SampleBezier(vec2 a, vec2 b, vec2 c, vec2 d, float t)\n{\n    // First degree\n    vec2 p11 = mix(a, b, t);\n    vec2 p12 = mix(b, c, t);\n    vec2 p13 = mix(c, d, t);\n\n    // Second degree\n    vec2 p21 = mix(p11, p12, t);\n    vec2 p22 = mix(p12, p13, t);\n\n    // Third degree\n    return mix(p21, p22, t);\n}\n\n\n// SCENE  /////////////////////////////////////////////////////////////////////////////////\nHit Closest(Hit a, Hit b)\n{\n    // Not sure how to be more performant as the ternary operator doesn't support structs :|\n    if (a.Dist <= b.Dist) \n    \treturn a;\n    else\n        return b;\n}\n\nHit HitSegment(vec2 p, BezierControl a, BezierControl b, BezierLook look)\n{\n    const int subdivs = 40;\n    \n    Hit hit;\n    hit.Dist = 999999.;\n    Hit newHit;\n    \n    // Vertices\n    newHit.Col = look.VertCol*0.75;\n    //newHit.Dist = sdCircle(p-a.Vertex, 0.01); hit = Closest(hit, newHit);\n    //newHit.Dist = sdCircle(p-b.Vertex, 0.01); hit = Closest(hit, newHit);\n    \n    // Control Points\n    newHit.Col = look.HandleCol*0.75;\n    newHit.Dist = sdCircle(p-a.Handle, 0.025); hit = Closest(hit, newHit);\n    newHit.Dist = sdCircle(p-b.Handle, 0.025); hit = Closest(hit, newHit);\n\n    // Lines\n    newHit.Col = look.LineCol;\n    newHit.Dist = sdLineSegment(p, a.Handle, a.Vertex, 0.); hit = Closest(hit, newHit);\n    newHit.Dist = sdLineSegment(p, b.Handle, b.Vertex, 0.); hit = Closest(hit, newHit);\n    \n\t// Cubic Bezier\n    newHit.Col = look.BezierCol;\n    vec2 last = SampleBezier(a.Vertex, a.Handle, b.Handle, b.Vertex, 0.);\n    for (int i = 1; i <= subdivs; i++)\n    {\n        float t = float(i)/float(subdivs);\n        vec2 s = SampleBezier(a.Vertex, a.Handle, b.Handle, b.Vertex, t);\n        \n       \tnewHit.Dist = sdLineSegment(p, last, s, look.BezierThicc*0.5); hit = Closest(hit, newHit);\n        \n        last = s;\n    }\n    \n    return hit;\n}\n\nvec3 Scene(vec2 p)\n{\n    BezierLook look;\n    look.BezierCol = vec3(0.8,0.2,0.4);\n    look.LineCol = vec3(1,1,1)*0.5;\n    look.HandleCol = vec3(1,1,1);\n    look.VertCol = vec3(0,0,1);\n    look.BezierThicc = 0.02;\n    \n    BezierControl s1a = LoadControl(_seg1a);\n    BezierControl s1b = LoadControl(_seg1b);\n    BezierControl s2a = LoadControl(_seg2a);\n    BezierControl s2b = LoadControl(_seg2b);\n    \n    Hit closest;\n    closest.Dist = 9999999.;\n    closest = Closest(closest, HitSegment(p, s1a, s1b, look));\n    closest = Closest(closest, HitSegment(p, s2a, s2b, look));\n    \n    return closest.Col * smoothstep(0.005,0.,closest.Dist);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.yy; // -[aspect,1] to [aspect,1]\n    vec2 uvNorm = fragCoord/iResolution.xy;                   // [0,0] to [1,1]\n    \n    vec3 col = vec3(0);\n    col = vec3(uvNorm,1) * 0.2;\n    col += Scene(uv);\n    fragColor = vec4(col,1.0);\n    \n    //fragColor = texture(iChannel0, uvNorm); // View data - 4 tiny coloured pixels :3\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\tState / Interaction Buffer\n*/\n\nvec4 Load(vec2 coord) \n{\n    return texelFetch(iChannel0, ivec2(coord), 0);\n}\nBezierControl LoadControl(vec2 coord)\n{\n    return DeserializeControl(Load(coord));\n}\n\n/*\nivec2 CoordFromIndex(int index)\n{\n    ivec2 coord;\n    coord.y = index / int(iChannelResolution[0].x);\n    coord.x = index % int(iChannelResolution[0].x);\n    return coord;\n}\n*/\n\nint IndexFromCoord(vec2 fragCoord)\n{\n    ivec2 p = ivec2(fragCoord);\n    int width = int(iChannelResolution[0].x);\n    return width * p.y + p.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Only process the range of pixels we're using for data\n    int index = IndexFromCoord(fragCoord);\n    if (index > IndexFromCoord(_lastCoord)) \n        discard;\n    \n\n    // Init data\n    if (iFrame == 0)\n    {\n        if      (index == IndexFromCoord(_seg1a)) { fragColor = SerializeControl(BezierControl(vec2(-1, 0), vec2(-1.3,-0.8))); }\n        else if (index == IndexFromCoord(_seg1b)) { fragColor = SerializeControl(BezierControl(vec2(0),     vec2(.3,-.3))); }\n        else if (index == IndexFromCoord(_seg2a)) { fragColor = SerializeControl(BezierControl(vec2(0),    -vec2(.3,-.3))); }\n        else if (index == IndexFromCoord(_seg2b)) { fragColor = SerializeControl(BezierControl(vec2(1,0),   vec2( 1.5, .7))); }\n        return;\n    }\n    \n    \n    // Get mouse state\n    bool mousePressed = iMouse.z > 0.0;\n    vec4 mouse = (2.*iMouse-iResolution.xyxy) / iResolution.yyyy; // -[aspect, 1] to [aspect, 1]\n    \n    \n    // Read this pixel state\n    vec4 data = Load(fragCoord);\n    \n    \n    // Process Input\n    if (mousePressed)\n    {\n        // Find the closest handle and keep its data coord aside for later manipulation\n        vec2 focus;\n        float closestDist = 999999.;\n        float d;\n        float hitThresh = 0.15;\n        \n        vec2 test = _seg1a;\n    \td = length(LoadControl(test).Handle - mouse.xy); if (d < hitThresh && d < closestDist) { closestDist = d; focus = test; };\n       \n        test = _seg1b;\n    \td = length(LoadControl(test).Handle - mouse.xy); if (d < hitThresh && d < closestDist) { closestDist = d; focus = test; };\n    \t\n        test = _seg2a;\n    \td = length(LoadControl(test).Handle - mouse.xy); if (d < hitThresh && d < closestDist) { closestDist = d; focus = test; };\n            \n        test = _seg2b;\n    \td = length(LoadControl(test).Handle - mouse.xy); if (d < hitThresh && d < closestDist) { closestDist = d; focus = test; };\n         \n        if (closestDist < 100. && index == IndexFromCoord(focus))\n        {\n            BezierControl c = LoadControl(focus);\n            c.Handle = mouse.xy;\n            data = SerializeControl(c);\n        }\n    }\n  \n    fragColor = data;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n// Coordinates where the data is located\nconst vec2 _seg1a = vec2(0,0);\nconst vec2 _seg1b = vec2(1,0);\nconst vec2 _seg2a = vec2(2,0);\nconst vec2 _seg2b = vec2(3,0);\nconst vec2 _lastCoord = _seg2b;\n\n\n\nstruct BezierControl\n{\n    vec2 Vertex; // Position of vertex\n    vec2 Handle; // Vector defining handle direction and length\n};\n    \nvec4          SerializeControl(BezierControl c) { return vec4(c.Vertex, c.Handle); }\nBezierControl DeserializeControl(vec4 data)     { return BezierControl(data.xy, data.zw); }\n","name":"Common","description":"","type":"common"}]}