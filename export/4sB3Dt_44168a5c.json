{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Andrew Caudwell 2014\n// @acaudwell\n\n#define MAX_RAY_STEPS 100\n#define PI 3.14159265359\n\n#define DEGREES_TO_RADIANS 0.017453292\n\n#define KIFS_ITERATIONS 12\n\nstruct KIFS {\n    vec3  offset;\n    float scale;\n    vec3  axis;\n    float angle;\n    mat4  transform;\n};\n\nKIFS KIFS_constructor(vec3 offset, vec3 axis, float angle, float scale) {\n        KIFS kifs;\n        kifs.offset = offset;\n        kifs.axis   = axis;\n        kifs.angle  = angle;\n        kifs.scale  = scale;\n        \n        return kifs;\n}\n\nmat4 calc_transform(inout KIFS kifs) {\n    float angle = kifs.angle * DEGREES_TO_RADIANS;\n\n    float c = cos(angle);\n    float s = sin(angle);\n\n    vec3 t = (1.0-c) * kifs.axis;\n\n    return mat4(\n        vec4(c + t.x * kifs.axis.x, t.y * kifs.axis.x - s * kifs.axis.z, t.z * kifs.axis.x + s * kifs.axis.y, 0.0) * kifs.scale,\n        vec4(t.x * kifs.axis.y + s * kifs.axis.z, (c + t.y * kifs.axis.y), t.z * kifs.axis.y - s * kifs.axis.x, 0.0) * kifs.scale,\n        vec4(t.x * kifs.axis.z - s * kifs.axis.y, t.y * kifs.axis.z + s * kifs.axis.x, c + t.z * kifs.axis.z, 0.0) * kifs.scale,\n        vec4(kifs.offset, 1.0)\n    );\n}\n\n#define t iTime*0.6\n\nint stage_no;\nfloat stage_t;\n\nKIFS kifs_N;\nKIFS kifs_lerp;\n\nvoid InitIFS() {\n        \n    if(stage_no >= KIFS_ITERATIONS) {\n        stage_no = KIFS_ITERATIONS-(stage_no-KIFS_ITERATIONS)-1;\n        stage_t  = 1.0-stage_t;\n    }\n        \n    // KIFS to visualize\n    kifs_N = KIFS_constructor(vec3(-1.5), normalize(vec3(-1.0)), -36.0, 1.5);\n\n    kifs_lerp.axis   = kifs_N.axis;\n    kifs_lerp.angle  = kifs_N.angle;\n\n    // interpolate scale and position offset\n    kifs_lerp.offset =kifs_N.offset * stage_t;\n    kifs_lerp.scale  = 1.0 + (kifs_N.scale-1.0) * stage_t;\n\n    // left mouse button disables interpolation\n    if(iMouse.z>0.0) {\n        kifs_lerp =kifs_N;\n    }\n        \n    kifs_N.transform    = calc_transform(kifs_N);\n    kifs_lerp.transform = calc_transform(kifs_lerp);\n}\n\n// The definitive Fractal Forums thread about this class of fractals:\n// http://www.fractalforums.com/ifs-iterated-function-systems/kaleidoscopic-%28escape-time-ifs%29/\n\nfloat scene(vec3 p) {\n\n    KIFS kifs = kifs_N;\n\n    float scale = 1.0;\n\n    for(int i=0;i<KIFS_ITERATIONS;i++) {\n\n        if(i==stage_no)kifs =kifs_lerp;\n        else if(i>stage_no) break;\n\n        // mirror on 2 axis to get a tree shape\n        p.xy = abs(p.xy);\n\n        // apply transform\n        p = (kifs.transform * vec4(p, 1.0)).xyz;\n\n        scale *=kifs.scale;\n    }\n\n    // divide by scale preserve correct distance\n    return (length(p)-2.0) / scale;\n}\n\nvec3 normal(vec3 p) {\n\n    vec2 o = vec2(0.001,0.0);\n\n    float d = scene(p);\n\n    float d1 = d-scene(p+o.xyy);\n    float d2 = d-scene(p+o.yxy);\n    float d3 = d-scene(p+o.yyx);\n\n    return normalize(vec3(d1,d2,d3));\n}\n\nfloat AO(vec3 p, vec3 normal) {\n\n    float a = 1.0;\n\n    float c = 0.0;\n    float s = 0.25;\n\n    for(int i=0; i<3; i++) {\n        c += s;\n        a *= 1.0-max(0.0, (c -scene(p + normal*c)) * s / c);\n    }\n\n    return clamp(a,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n        \n    stage_no  = int(fract(t/float(KIFS_ITERATIONS*2)) * float(KIFS_ITERATIONS*2));\n    stage_t = smoothstep(0.0, 1.0, fract(t));\n    \n    InitIFS();\n        \n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\n    vec3 dir = normalize(vec3(uv.x, uv.y * (iResolution.y/iResolution.x), 1.0));\n\n    vec3 p = vec3(0.0,0.0,-4.1);\n\n    float d = 0.0;\n\n    for(int i=0; i<MAX_RAY_STEPS; i++) {\n        d = scene(p);\n        p += d * dir;\n        if(d<0.001) break;\n    }\n\n    vec3 c = vec3(0.0);\n        \n    if(d<0.001) {\n        vec3 l = vec3(-3.0, 3.0, -3.0);\n\n        vec3 n = -normal(p-dir*0.001);\n\n        c = vec3(0.4);\n\n        c += 1.5 * (max(0.0, dot(n, normalize(l-p)))/length(l-p));\n\n        c *= AO(p, 0.5*(n+normalize(n+l)));\n    }\n        \n    fragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sB3Dt","date":"1395027593","viewed":1242,"name":"Interpolated KIFS","username":"andyalias","description":"Inter-iteration interpolation (try saying that 3 times fast) of a Kaleidoscopic IFS fractal. I think it kind of resembles cell division.\n\nPress the left mouse button to see how it looks without interpolation.","likes":33,"published":1,"flags":0,"usePreview":0,"tags":["animation","kifs","interpolation"],"hasliked":0,"parentid":"","parentname":""}}