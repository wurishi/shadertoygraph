{"ver":"0.1","info":{"id":"7lB3D1","date":"1626553347","viewed":190,"name":"ray sphere intersection __","username":"Envy24","description":"ray sphere intersection and inverse spherical mapping","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["ray","sphere","intersection","mapping","spherical","inverse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932\n#define TAU 6.2831853071795862 // 2*PI\n#define BACKGROUND (vec4(normalize(1.0 - rayDir), 1.0))\n#define R iResolution\n\n/*\n    Source: book \"An Introduction to Ray Tracing\"\n*/\nvec2 sphericalInverseMapping(\n    vec3 HPN,  /* hit point normal */\n    vec3 pole,\n    vec3 equator)\n{\n    float phi = acos(dot(-HPN, pole));\n    float theta = acos(dot(equator, HPN) / sin(phi)) / TAU;\n\n    return vec2(\n        dot(cross(pole, equator), HPN) > 0.0 ? theta : 1.0 - theta, // u\n        phi / PI);                                                  // v\n}\n\n/*\n    from wikipedia.\n*/\nvec2 sphericalUV(vec3 HPN  /* hit point normal */)\n{\n    const float inv_tau = 0.1591549430918953;\n    const float inv_pi = 0.31830988618379069;\n    return vec2(\n        0.5 + atan(HPN.x, HPN.z) * inv_tau,\n        0.5 + asin(HPN.y) * inv_pi);\n}\n\nfloat shootRayInSphere(\n    vec3 ray,\n    vec3 rayDir,\n    vec3 sphereCenter,\n    float sphereRadius)\n{\n    vec3 tmp = ray - sphereCenter;\n    \n    float a = dot(rayDir, rayDir);\n    float b = 2.0 * dot(tmp, rayDir);\n    float c = dot(tmp, tmp) - sphereRadius * sphereRadius;\n    float discriminant = b * b - 4.0 * a * c;\n    \n    if (discriminant < 0.0) { return -1.0; }\n      \n    float e = sqrt(discriminant);\n\n    float root = (-b - e) / (2.0 * a);\n\n    if (root >= 0.0) { return root; }\n\n    root = (-b + e) / (2.0 * a);\n\n    if (root >= 0.0) { return root; }\n    \n    return -1.0;\n}\n\n/*\n    Optimized as described in Ray Tracing In One Weekend.\n*/\nfloat shootRayInSphere2(\n    vec3 ray,\n    vec3 rayDir,\n    vec3 sphereCenter,\n    float sphereRadius)\n{\n    vec3 tmp = ray - sphereCenter;\n    \n    float a = dot(rayDir, rayDir);\n    float half_b = dot(tmp, rayDir);\n    float c = dot(tmp, tmp) - sphereRadius * sphereRadius;\n    float discriminant = half_b * half_b - a * c;\n    \n    if (discriminant < 0.0) { return -1.0; }\n      \n    float e = sqrt(discriminant);\n\n    float root = (-half_b - e) / a;\n\n    if (root >= 0.0) { return root; }\n\n    root = (-half_b + e) / a;\n\n    if (root >= 0.0) { return root; }\n    \n    return -1.0;\n}\n\n/*\n    branchless?\n*/\nfloat shootRayInSphere3(\n    vec3 ray,\n    vec3 rayDir,\n    vec3 sphereCenter,\n    float sphereRadius)\n{\n    vec3 tmp = ray - sphereCenter;\n    \n    float a = dot(rayDir, rayDir);\n    float half_b = dot(tmp, rayDir);\n    float c = dot(tmp, tmp) - sphereRadius * sphereRadius;\n    float sqrtDiscriminant = sqrt(half_b * half_b - a * c);\n    \n    float root0 = (-half_b - sqrtDiscriminant) / a;\n    float root1 = (-half_b + sqrtDiscriminant) / a;\n    \n    return \n        sqrtDiscriminant < 0.0 ? // any real roots?\n            -1.0 : // no hit\n            root0 >= 0.0 ? // min root is pass?\n                root0 :\n                root1 >= 0.0 ? // max root is pass?\n                    root1 :\n                        -1.0; // no hit\n}\n\n/*\n    more optimizations\n*/\nfloat shootRayInSphere4(\n    vec3 ray,\n    vec3 rayDir,\n    vec3 sphereCenter,\n    float sphereRadius)\n{\n    vec3 tmp = ray - sphereCenter;\n    \n    float half_b = dot(tmp, rayDir);\n    float c = dot(tmp, tmp) - sphereRadius * sphereRadius;\n    float discriminant = (half_b * half_b - c);\n    float sqrtDiscriminant = sqrt(discriminant);\n    \n    float root = min(-half_b - sqrtDiscriminant, -half_b + sqrtDiscriminant);\n    \n    return \n        discriminant < 0.0 ? // any real roots?\n            -1. :\n                root < 0.0 ? // behind camera?\n                    -1.:\n                    root;\n}\n\nfloat shootRayInSphere5(\n    vec3 ray,\n    vec3 ray_dir,\n    vec3 sphere,\n    float r)\n{\n    sphere -= ray; // move sphere in ray coordinate system\n    \n    // Project sphere center on ray.\n    float dist = dot(sphere, ray_dir) /  dot(ray_dir, ray_dir);\n    vec3 sphere_to_ray_proj = dist * ray_dir;\n    float len = length(sphere_to_ray_proj - sphere);\n\n    // Check length between sphere center and projected point.\n    return \n        len > r || dist < 0. ? // ray-sphere intersection\n        //len > r ? // ray-line intersection\n            -1. : // no hit\n            dist-sqrt(r*r - len*len); // distance to hit point\n}\n\nfloat vertical_lineSDF(vec2 NDC, float x0) { return abs(NDC.x-x0); }\nfloat horizontal_lineSDF(vec2 NDC, float y0) { return abs(NDC.y-y0); }\nfloat cellsSDF(vec2 NDC)\n{\n    NDC *= 16.; // Finer cells\n    NDC = fract(NDC);\n    NDC = fract(min(NDC, 1. - NDC));\n    return\n        min(vertical_lineSDF(NDC, 0.), horizontal_lineSDF(NDC, 0.));\n}\n\nvec2 my_uv(vec3 HPN)\n{\n    float phi = asin(HPN.x/HPN.z),\n          theta = acos(HPN.z);\n          \n    return vec2(phi, theta) / (2.*PI);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    /* Perspective camera with lookat (Blender). */\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n\n    float zFocalLength = 50.0; // mm.\n    vec3 camera = vec3(0.0, 0.0, 7.0);\n    camera = rotateAroundY(camera, iTime);\n\n    vec3 f = normalize(lookAt - camera);               // forward\n    vec3 r = normalize(cross(f, vec3(0.0, 1.0, 0.0))); // right\n    vec3 u = normalize(cross(r, f));                   // up     \n    \n    float size = 36.0;        // Sensor Fit: Mode = Auto.    \n    float aspectRatio = R.x / R.y;\n    float vpWidth = size;\n    float vpHeight = vpWidth / aspectRatio;\n           \n    uv.x = (uv.x * vpWidth) - vpWidth * 0.5;\n    uv.y = (uv.y * vpHeight) - vpHeight * 0.5;\n               \n    vec3 ray = camera;\n    vec3 rayDir = normalize(uv.x * r + uv.y * u + f * zFocalLength);\n    /* Perspective camera */\n\n\n    /* Sphere */\n    vec3 sphere = vec3(0.0, 0.0, -1.0);\n    vec3 pole = vec3(0.0, 1.0, 0.0);\n    vec3 equator = vec3(1.0, 0.0, 0.0);\n    float radius = 0.6;\n    /* Sphere */\n\n\n    /* Rotation */\n    sphere = rotateAroundX(sphere, iTime);\n    pole = rotateAroundX(pole, iTime);\n    equator = rotateAroundX(equator, iTime);\n    \n    sphere = rotateAroundY(sphere, iTime * 0.6);\n    pole = rotateAroundY(pole, iTime * 0.6);\n    equator = rotateAroundY(equator, iTime * 0.6);\n\n    sphere = rotateAroundZ(sphere, iTime * 0.3);\n    pole = rotateAroundZ(pole, iTime * 0.3);\n    equator = rotateAroundZ(equator, iTime * 0.3);\n    /* Rotation */\n\n\n    /* Ray tracing */\n    float t = shootRayInSphere4(ray, rayDir, sphere, radius);\n    /* Ray tracing */\n    \n    \n    /* Shading */\n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n    if (t >= 0.0) // hit ?\n    {\n        vec3 HP = ray + rayDir * t;\n        vec3 HPN = normalize(HP - sphere);\n        //vec2 sphereUV = sphericalInverseMapping(HPN, pole, equator);\n        vec2 sphereUV = sphericalUV(HPN);\n        //vec2 sphereUV = my_uv(HPN);\n        \n        /* uv as color *\n        color.x = sphereUV.x;\n        color.y = sphereUV.x;\n        /* uv as color */\n        \n        float d = cellsSDF(sphereUV);\n        //float d = length(sphereUV - vec2(1)) - 2.4;\n        //color = mix(vec4(1), vec4(0), smoothstep(32./iResolution.y, 0., d));\n        color = texture(iChannel1, sphereUV);\n    }\n    else { color = BACKGROUND; }\n    /* Shading */\n\n\n    // Output to screen\n    fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 rotateAroundX(vec3 p, float a)\n{\n    float s = sin(-a);\n    float c = cos(-a);\n\n    return vec3(\n        p.x,\n        p.y * c + p.z * s,\n        p.z * c - p.y * s);\n}\n\nvec3 rotateAroundY(vec3 p, float a)\n{\n    float s = sin(-a);\n    float c = cos(-a);\n\n    return vec3(\n        p.x * c + p.z * s,\n        p.y,\n        p.z * c - p.x * s);\n}\n\nvec3 rotateAroundZ(vec3 p, float a)\n{\n    float s = sin(-a);\n    float c = cos(-a);\n\n    return vec3(\n        p.x * c + p.y * s,\n        p.y * c - p.x * s,\n        p.z);\n}","name":"Common","description":"","type":"common"}]}