{"ver":"0.1","info":{"id":"ml2yDD","date":"1691810715","viewed":94,"name":"Weaved Churros","username":"VL","description":"2D : [url]https://www.shadertoy.com/view/DlsGDM[/url]","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define int2 vec2\n#define float2 vec2\n#define int3 vec3\n#define float3 vec3\n#define int4 vec4\n#define float4 vec4\n#define frac fract\n#define float2x2 mat2\n#define float3x3 mat3\n#define float4x4 mat4\n#define saturate(x) clamp(x,0.,1.)\n#define lerp mix\n#define CurrentTime (iTime)\n#define sincos(x,s,c) s = sin(x),c = cos(x)\n#define mul(x,y) (x*y)\n#define atan2 atan\n#define fmod mod\n#define static\n#define MaxDist 100.f\n#define SurfaceDist 0.0001f\n#define FloatMax 3.402823466e+38f\n#define raymarchDepth 200\n#define raymarchDistMax 200.f\n#define InvPI 0.318309886f\n#define PId2 1.57079632f\n#define PI 3.141592653f\n#define PI2 6.2831853f\n#define UpVector float3(0.f, 1.f, 0.f)\n#define RightVector float3(1.f, 0.f, 0.f)\n#define LookVector float3(0.f, 0.f, 1.f)\n\nfloat4 hash42(float2 p)\n{\n    float4 p4 = frac(float4(p.xyxy) * float4(154.1031, 166.1030, 178.0973, 144.1099));\n    p4 += dot(p4, p4.wzxy + 17.93);\n    return frac((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nfloat3x3 viewMatrix(float3 look)\n{\n    float3 right = normalize(cross(UpVector, look));\n    float3 up = cross(look, right);\n    return transpose(float3x3(right, up, look));\n}\n\nfloat sdf3dInfCylinder(float3 _point, float4 cylinder, float3 cylinderDirection)\n{\n    _point -= cylinder.xyz;\n    return length(_point - dot(_point, cylinderDirection) * cylinderDirection) - cylinder.w;\n}\n\nfloat sdf3dTorusV(float3 _point, float4 torus, float3 torusPlaneNormal, out float v)\n{\n    _point -= torus.xyz;\n    float projPlaneFactor = dot(_point, torusPlaneNormal);\n    float3 projPlane = _point - projPlaneFactor * torusPlaneNormal;\n    float projPlaneToTorus = length(projPlane) - torus.w;\n    float dist = sqrt(projPlaneToTorus * projPlaneToTorus + projPlaneFactor * projPlaneFactor);\n    v = acos(projPlaneToTorus / dist);\n    return dist;\n}\n\nvoid swap(inout float a, inout float b)\n{\n    float tmp = a;\n    a = b;\n    b = tmp;\n}\n\nvoid swap(inout int a, inout int b)\n{\n    int tmp = a;\n    a = b;\n    b = tmp;\n}\n\nfloat2x2 rot2D(float t)\n{\n    float s, c;\n    sincos(-t, s, c);\n    return float2x2(c, s, -s, c);\n}\n\n\nfloat drawLine(float2 uv, int left, int right, out float2 tuv, float t, float py,float sgn)\n{\n    bool flipX = false;\n    if (left == 2)\n    {\n        swap(left, right);\n        uv.x = -uv.x;\n        flipX = true;\n    }\n    \n    if (left == 0)\n    {\n        uv = mul(uv, rot2D(PI / 3.f));\n    }\n    \n    tuv.x = (uv.x + sqrt(3.f) / 2.f) * (1.f / sqrt(3.f));\n    tuv.x = frac(flipX ? -tuv.x : tuv.x);\n     \n    float s = sin(tuv.x * PI);\n    py -= s * s * t * sgn;\n    \n    tuv.y = atan2(py,uv.y);    \n    return sdf3dInfCylinder(float3(uv.x, py, uv.y), float4(0.f), float3(1.f, 0.f, 0.f));\n}\n\nfloat drawSmallArc(float2 uv, int left, int right, out float2 tuv, float t, float py, float sgn)\n{\n    bool flipY = false;\n    if (left == 2)\n    {\n        uv.y = -uv.y;\n        flipY = true;\n    }\n\n    uv.y -= 1.f;\n    \n    tuv.x = (atan2(uv.y, uv.x) + PI / 6.f) * (3.f / PI2);\n    tuv.x = frac(tuv.x);\n\n    float s = sin(tuv.x * PI), c;\n    py -= s * s * t * sgn;\n    \n    float dist = sdf3dTorusV(float3(uv.x, py, uv.y), float4(0.f,0.f,0.f, 0.5), float3(0.f, 1.f, 0.f), tuv.y);\n    tuv.y = flipY ? tuv.y : PI -tuv.y;\n    return dist;\n}\n\nfloat drawLargeArc(float2 uv, int left, int right, out float2 tuv, float t, float py, float sgn)\n{\n    bool flipX = false;\n    if (left == 1)\n    {\n        swap(left, right);\n        uv.x = -uv.x;\n        flipX = true;\n    }\n    \n    bool flipY = false;\n    if (left == 2)\n    {\n        uv.y = -uv.y;\n        flipY = true;\n    }\n    \n    uv -= float2(sqrt(3.f), 3.f) * 0.5;\n    \n    tuv.x = (atan2(uv.y, uv.x) + PI / 6.f) * (3.f / PI);    \n    tuv.x = frac(flipX ? -tuv.x : tuv.x);\n    \n    float s = sin(tuv.x * PI), c;\n    py -= s * s * t * sgn;\n\n    float dist = sdf3dTorusV(float3(uv.x, py, uv.y), float4(0.f,0.f,0.f, 1.5), float3(0.f, 1.f, 0.f), tuv.y);    \n    tuv.y = flipY ? tuv.y : PI-tuv.y;    \n    return dist;\n}\n\nfloat getPattern(float2 uv, int left, int right, out float2 tuv, float t, float py,float sgn)\n{\n    if (left + right == 2)\n        return drawLine(uv, left, right, tuv, t, py,sgn);\n    else if (left - right == 0)\n        return drawSmallArc(uv, left, right, tuv, t, py, sgn);\n    else\n        return drawLargeArc(uv, left, right, tuv, t, py, sgn);\n}\n\nfloat WeavedChurros(float3 p, float thickness, float flow)\n{\n    const float2 k = float2(1.f, sqrt(3.f));\n    \n    float2 pk = p.xz / k;\n    float2 aIdx = floor(pk);\n    float2 a = (pk - aIdx) * k - k * 0.5;\n    \n    pk = (p.xz - k * 0.5) / k;\n    float2 bIdx = floor(pk);\n    float2 b = (pk - bIdx) * k - k * 0.5;\n    \n    float2 hexUv = dot(a, a) < dot(b, b) ? a : b;\n    float2 hexIdx = dot(a, a) < dot(b, b) ? aIdx : (bIdx + 0.5);\n    float4 rand = hash42(hexIdx);\n    \n    int rot = int((rand.x + rand.y) * 0.5f * 3.f);\n    //hexUv = mul(hexUv, rot2D(PI/3.f * float(rot)));\n    \n    float hT = thickness * 0.5f;\n    float2 tuv, tuvTmp;\n    \n    int lRemain[3] = int[3]( 0, 1, 2 );\n    int rRemain[3] = int[3]( 0, 1, 2 );\n    \n    int left = int(rand.x * 3.f);\n    int right = int(rand.z * 3.f);\n    \n    hexUv *= k.y;       \n    float dist = getPattern(hexUv, lRemain[left], rRemain[right], tuv, thickness, p.y, thickness*2.);\n    \n    swap(lRemain[left], lRemain[2]);\n    swap(rRemain[right], rRemain[2]);\n    left = int(rand.y * 2.f);\n    right = int(rand.w * 2.f);\n    \n    float d1 = getPattern(hexUv, lRemain[left], rRemain[right], tuvTmp, thickness, p.y, 0.f);\n    if (dist > d1)\n    {\n        dist = d1;\n        tuv = tuvTmp;\n    }\n        \n    float d2 = getPattern(hexUv, lRemain[1 - left], rRemain[1 - right], tuvTmp, thickness, p.y, -thickness*2.);\n    if (dist > d2)\n    {\n        dist = d2;\n        tuv = tuvTmp;\n    }\n    \n    float sx = sin(tuv.x* PI2 + flow);\n    float sy = sin(abs(tuv.y) * 5.+flow*3.f);\n    return (dist - hT*0.5 - sy*sy*0.02 - sx*sx*0.08) * 0.5;\n}\n\nfloat GetSignDistance(float3 p)\n{\n     float cw = lerp(0.1, 0.5, (sin(p.x + sin(p.z)) + sin(p.z * .35)) * .25 + .5);\n     cw = 0.4;  \n    return WeavedChurros(p, cw, iTime*2.);\n}\n\nfloat RayMarching(float3 rayOrigin, float3 rayDir)\n{\n    float dist = 0.f;\n    for (int i = 0; i < raymarchDepth; ++i)\n    {\n        float3 p = rayOrigin + rayDir * dist;\n        float curr = GetSignDistance(p);\n        \n        dist += curr;\n        if (curr < SurfaceDist || dist > raymarchDistMax)\n        {\n            dist = curr < SurfaceDist ? dist : FloatMax;\n            break;\n        }\n    }\n    \n    return dist;\n}\n\nfloat3 GetSDFNormal(float3 p)\n{\n    return normalize(float3(+1.f, -1.f, -1.f) * GetSignDistance(p + float3(+1.f, -1.f, -1.f) * SurfaceDist) +\n                     float3(-1.f, -1.f, +1.f) * GetSignDistance(p + float3(-1.f, -1.f, +1.f) * SurfaceDist) +\n                     float3(-1.f, +1.f, -1.f) * GetSignDistance(p + float3(-1.f, +1.f, -1.f) * SurfaceDist) +\n                     float3(+1.f, +1.f, +1.f) * GetSignDistance(p + float3(+1.f, +1.f, +1.f) * SurfaceDist));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n\n    float3 ro = float3(0.01f, 2.f, -2.f+iTime*0.5);\n    float3 rt = float3(0.01f, 0.f, 0.f + iTime*0.5);\n    float3 rd = mul(transpose(viewMatrix(normalize(rt - ro))), normalize(float3(uv, 1.)));\n    \n    float t = RayMarching(ro, rd);    \n    \n    float3 col = float3(0.f);\n    \n    if(t < FloatMax)\n    {\n        float3 p = ro + t * rd;\n        float3 n = GetSDFNormal(p);\n\n        col = float3((dot(n,normalize(float3(0.f,1.f,-1.f)))));\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}