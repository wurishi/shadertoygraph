{"ver":"0.1","info":{"id":"Mf2GRK","date":"1704437339","viewed":28,"name":"wavyshapes","username":"matipina","description":"Following kishimisu tutorial","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["animation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Classic Perlin 2D noise\nfloat perlinNoise(vec2 P)\n{\n    // Compute the integer coordinates\n    vec2 Pi = floor(P);\n    // Compute the fractional coordinates\n    vec2 Pf = P - Pi;\n\n    // Smoothing function (fade)\n    vec2 fade = Pf * Pf * (3.0 - 2.0 * Pf);\n\n    // Hash coordinates of the 4 cube corners\n    vec2 n00 = vec2(Pi.x, Pi.y);\n    vec2 n10 = vec2(Pi.x + 1.0, Pi.y);\n    vec2 n01 = vec2(Pi.x, Pi.y + 1.0);\n    vec2 n11 = vec2(Pi.x + 1.0, Pi.y + 1.0);\n\n    // Gradient vectors from the 4 corners\n    vec2 grad00 = normalize(fract(n00 * 0.0245) * 2.0 - 1.0);\n    vec2 grad10 = normalize(fract(n10 * 0.0245) * 2.0 - 1.0);\n    vec2 grad01 = normalize(fract(n01 * 0.0245) * 2.0 - 1.0);\n    vec2 grad11 = normalize(fract(n11 * 0.0245) * 2.0 - 1.0);\n\n    // Dot products between gradients and vectors from corners to input point\n    float dot00 = dot(grad00, Pf);\n    float dot10 = dot(grad10, Pf - vec2(1.0, 0.0));\n    float dot01 = dot(grad01, Pf - vec2(0.0, 1.0));\n    float dot11 = dot(grad11, Pf - vec2(1.0, 1.0));\n\n    // Interpolation using fade function\n    vec2 interp0 = mix(vec2(dot00, dot01), vec2(dot10, dot11), fade.y);\n    float interp1 = mix(interp0.x, interp0.y, fade.x);\n\n    return interp1;\n}\n\n\n// cosine based palette, 4 vec3 params\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy)/ iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    \n    // Define the rotation angle (in radians)\n    float rotationAngle = iTime * 0.06; // Adjust the multiplier for the rotation speed\n\n    // Create a 2D rotation matrix\n    mat2 rotationMatrix = mat2(tan(rotationAngle), -sin(rotationAngle),\n                               sin(rotationAngle), tan(rotationAngle));\n                               \n    // Apply rotation to uv coordinates\n    uv = rotationMatrix * uv; \n                                       \n    \n    for (float i = 0.0; i < 5.0; i++) {\n        uv = fract(1.5 * uv) - 0.5;\n    \n        float d = length(uv) * exp(-length(uv0));\n\n\n        vec3 a = vec3(0.723, 0.308, 0.839);\n        vec3 b = vec3(0.506, 0.090, 0.837);\n        vec3 c = vec3(0.298, 0.035, 0.370);\n        vec3 e = vec3(2.498, 1.033, 5.009);\n\n        vec3 col = palette(length(uv0) + i/4. + iTime/2., a, b, c, e);\n\n        d = sin(8.0 * d + iTime)/8. + 0.1*perlinNoise(vec2(3.*d+iTime));\n        d = pow(0.01/d, 2.);\n\n        finalColor += col * d;\n    }\n\n    fragColor = vec4(finalColor, 0.0);\n}\n","name":"Image","description":"","type":"image"}]}