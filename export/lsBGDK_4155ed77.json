{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"\n\nvec4 noise(float p){return texture(iChannel0,vec2(p/iChannelResolution[0].x,.0));}\nvec4 noise(vec2 p){return texture(iChannel0,p/iChannelResolution[0].xy);}\nvec4 noise(vec3 p){float m = mod(p.z,1.0);float s = p.z-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(texture(iChannel0,p.xy/iChannelResolution[0].xy + noise(sprev).yz*21.421),texture(iChannel0,p.xy/iChannelResolution[0].xy + noise(s).yz*14.751),m);}\nvec4 noise(vec4 p){float m = mod(p.w,1.0);float s = p.w-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(noise(p.xyz+noise(sprev).wyx*3531.123420),\tnoise(p.xyz+noise(s).wyx*4521.5314),\tm);}\nvec4 noise(float p, float lod){return texture(iChannel0,vec2(p/iChannelResolution[0].x,.0),lod);}\nvec4 noise(vec2 p, float lod){return texture(iChannel0,p/iChannelResolution[0].xy,lod);}\nvec4 noise(vec3 p, float lod){float m = mod(p.z,1.0);float s = p.z-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(texture(iChannel0,p.xy/iChannelResolution[0].xy + noise(sprev,lod).yz,lod*21.421),texture(iChannel0,p.xy/iChannelResolution[0].xy + noise(s,lod).yz,lod*14.751),m);}\n\n#define t iTime\n\nvec3 flare(vec2 uv, vec2 pos, float seed, float size)\n{\n\tvec4 gn = noise(seed-1.0);\n\tgn.x = size;\n\tvec3 c = vec3(.0);\n\tvec2 p = pos;\n\tvec2 d = uv-p;\n\t\n\t\n\tc += (0.01+gn.x*.2)/(length(d));\n\t\n\tc += vec3(noise(atan(d.x,d.y)*256.9+pos.x*2.0).y*.25)*c;\n\t\n\tfloat fltr = length(uv);\n\tfltr = (fltr*fltr)*.5+.5;\n\tfltr = min(fltr,1.0);\n\t\n\tfor (float i=.0; i<20.; i++)\n\t{\n\t\tvec4 n = noise(seed+i);\n\t\tvec4 n2 = noise(seed+i*2.1);\n\t\tvec4 nc = noise (seed+i*3.3);\n\t\tnc+=vec4(length(nc));\n\t\tnc*=.65;\n\t\t\n\t\tfor (int i=0; i<3; i++)\n\t\t{\n\t\t\tfloat ip = n.x*3.0+float(i)*.1*n2.y*n2.y*n2.y;\n\t\t\tfloat is = n.y*n.y*4.5*gn.x+.1;\n\t\t\tfloat ia = (n.z*4.0-2.0)*n2.x*n.y;\n\t\t\tvec2 iuv = (uv*(mix(1.0,length(uv),n.w*n.w)))*mat2(cos(ia),sin(ia),-sin(ia),cos(ia));\n\t\t\tvec2 id = mix(iuv-p,iuv+p,ip);\n\t\t\tc[i] += pow(max(.0,is-(length(id))),.45)/is*.1*gn.x*nc[i]*fltr;\n\t\t}\n\t\t\n\t}\n\t\n\t\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy -.5;\n\tuv.x*= iResolution.x/ iResolution.y;\n\tuv *= 2.0;\n\t\n\tvec2 mouse = iMouse.xy / iResolution.xy -.5;\n\tmouse.x*= iResolution.x/ iResolution.y;\n\tmouse *= 2.0;\n\t\n\tvec3 color = vec3(.0);\n\t\n    vec2 pos;\n    if (iMouse.z < .5)\n    {\n        pos = vec2(sin(t),cos(t*.7));\n    }\n\n    else pos = mouse.xy;\n\t\n\t\tcolor += flare(uv,pos,t-mod(t,2.00),0.15)*vec3(1.9,1.9,2.4);\n\t\n\t\n\tcolor+=noise(fragCoord.xy).xyz*.01;\n\n\t\n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lsBGDK","date":"1414741906","viewed":1726,"name":"Flare Mania","username":"mu6k","description":"A follow up to my other flare shader. This one is more abstract. It draws the halos in a for loop using noise functions.","likes":39,"published":1,"flags":0,"usePreview":1,"tags":["flare2d"],"hasliked":0,"parentid":"","parentname":""}}