{"ver":"0.1","info":{"id":"mlcyDN","date":"1699318319","viewed":118,"name":"RT: AO, Metallic & Refraction","username":"Furquijos","description":"Original Intersection/traverse code from \"Introduction to Ray Tracing\" (SIGGRAPH) led by Rajesh Sharma. Following  \"RaytracingInOneWeekend\" into GLSL, generating AO, adding spheric Light and implementing Diffuse, Metallic and dielectric surfaces.\n\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","diffuse","siggraph","raytracinginoneweekend","introductiontoraytracing"],"hasliked":0,"parentid":"cttyzr","parentname":"Ray tracing AO and Spheric Light"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXX 10000000.0\n\n/*\nOriginal Intersection/traverse code from course \"Introduction to Ray Tracing\" (SIGGRAPH) led by Rajesh Sharma. \nI bring the C++ logic from \"Ray Tracing in One Weekend\" into GLSL,generating AO, adding spheric Light and implementing Diffuse, Metallic and dielectric surfaces.\nForking from my  previous ray tracing iteration https://www.shadertoy.com/view/cttyzr adding new scatter distributions (reflection and refraction)\n*/\n\n// =========================>  samples per pixel,change it as you want (the bigger the smoother and slower)\nconst int numSamples=50;\n// =========================>  Max Bounces per Ray\nconst int maxBounces=6;\n\n//////////////////////////////////////////////////////////////////////\n//Noise code from https://www.shadertoy.com/view/Nsf3Ws\nuint seed = 0u;\nvoid hash(){\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n}\nvoid initRandomGenerator(vec2 fragCoord){\n    seed = uint(fragCoord.y*iResolution.x + fragCoord.x)+uint(1)*uint(iResolution.x)*uint(iResolution.y);\n}\n\nfloat random(){\n    hash();\n    return (2.0 * float(seed)/4294967295.0) -1.0;\n}\n/////////////////////////////////////////////////////////////////////\n\n\n\nvec3 unit_vector(vec3 v) {\n    return v / length(v);\n}\n\nvec3 randomvec()\n{\n     return vec3(random(),random(),random());\n}\n\n\n////////getting random vectors above the surface adapted from RaytracingInOneWeekend\n/// Possible optimization creating an array of precaulculated unit vectors with an homogenious distribution on the sphere and randomly returning one instead of using brute force\nvec3 random_in_unit_sphere() {\n    while (true) {\n        vec3 p = randomvec();\n        if (length(p) < 1.0)\n            return p;\n    }\n}\n\nvec3 random_unit_vector() {\n    return normalize(random_in_unit_sphere());\n}\n\nvec3 random_on_hemisphere(vec3 normal) {\n    vec3 on_unit_sphere = random_unit_vector();\n    if (dot(on_unit_sphere, normal) > 0.0) // In the same hemisphere as the normal\n        return on_unit_sphere;\n    else\n        return -on_unit_sphere;\n}\n/////\n\n\n// a Light is defined by a location and a color\nstruct Light {\n    vec3 location;\n    vec3 color;\n};\n\nstruct Material {\n   //surface type 0 = Diffuse, 1 = Metallic, 2 = Dielectric\n   int surfaceType;\n   vec3 albedo;\n   float roughness;\n};\n\n\n// Sphere is defined by a center and radius and material: color\nstruct Sphere {\n\tfloat radius;\n\tvec3 center;\n    vec3 color;\n    int isLight;\n    Material material;\n};\n\n// Ray is define by an origin point and a direction vector\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n \nstruct Intersection {\n    int obj;\n    float t;\n};\n\n\nconst int NUM_SPHERE = 5;\nSphere spheres[NUM_SPHERE];\n//Light  lights[1];\n\n// Intersection code for Ray-Sphere (from https://www.shadertoy.com/view/NllGDs)    \nfloat raySphereIntersect(in Ray ray, in Sphere sphere) {\n    \n    vec3 rayToSphere = ray.origin - sphere.center;\n    float b = dot(rayToSphere, ray.direction);\n    float c = dot(rayToSphere, rayToSphere) - (sphere.radius * sphere.radius);\n\tfloat disc = b*b - c;\n    float t;\n    if (disc > 0.0) {\n        t = -b - sqrt(disc);\n        if (t > 0.0001) {\n            return t;\n        }\n        t = -b + sqrt(disc);\n        if (t > 0.0001) {\n            return t;\n        }  \n    }\n    return MAXX;\n}\n\n// Traverses the entire scene and \n// returns the objectID and the intersection point\nIntersection intersectAllObjects(Ray ray) {\n    float minT = MAXX;\n    int iSphere = -1;\n    \n    for (int i=0; i < NUM_SPHERE; i++) {\n       Sphere sphere = spheres[i];\n       \n       float t = raySphereIntersect(ray, sphere);\n         \n       if (t < minT && t >= 0.0001) {\n           // keep track of the closest sphere and intersection\n           iSphere = i;\n           minT = t;\n       }\n   }\n   \n   return Intersection(iSphere, minT);\n}\n  \n\nvoid makeScene(int f) {\n\n    Material greyDiffuse = Material(0,vec3(0.5,0.5,0.5),0.0);\n    Material whiteMetallic = Material(1,vec3(1.0,1.0,1.0),0.3);\n    Material dielectric = Material(2,vec3(1.0,1.0,1.0),0.4);\n\n\n    spheres[0] = Sphere(1.0 , vec3(0.0, 0, -7), vec3(1, 1, 0),0,greyDiffuse);\n    spheres[1] = Sphere(30.0, vec3(0.0,-31, -7), vec3(1, 1, 0),0, greyDiffuse);\n    spheres[2] = Sphere(0.5, vec3(sin(iTime)*1.3,-0.52, -7.0 + cos(iTime)*1.3), vec3(1, 1, 0),0,dielectric);\n    \n    spheres[3] = Sphere(0.5, 1.5*vec3(sin(iTime*2.0)*1.0,0.5, -5.0 + cos(iTime*2.0)*1.2), vec3(2.8, 2.8, 2.8),1,greyDiffuse);\n    spheres[4] = Sphere(0.3, vec3(sin(iTime*1.9)*2.0,-0.52, -7.0 + cos(iTime*1.9)*2.0), vec3(1, 1, 0),0,whiteMetallic);\n\n   \n}\n\nvec3 LambertScatterDistribution(vec3 xnorm){\n return  xnorm + random_unit_vector();;\n\n}\n\n\nvec3 ReflectScatterDistribution(vec3 inRayDir, vec3 xnorm){\n  return inRayDir - 2.0*dot(inRayDir,xnorm)*xnorm;\n\n}\n\n\n// Original C++ code into GLSL from RaytracingInOneWeekend book, it didn't work in my end\n vec3 RefractScatterDistribution( vec3 uv, vec3 xnorm, float etai_over_etat) {\n    float cos_theta = min(dot(-uv, xnorm), 1.0);\n    vec3 r_out_perp =  etai_over_etat * (uv + cos_theta*xnorm);\n    vec3 r_out_parallel = -sqrt(abs(1.0 - length(r_out_perp))) * xnorm;\n    return r_out_perp + r_out_parallel;\n}\n\n//I had to add this custom Refract function instead of the RaytracingInOneWeekend.\n// The GLSL reefract function worked right in Mac but it didn't in windows so I had to create this function\n//Based on the OpenGL implementation https://registry.khronos.org/OpenGL-Refpages/gl4/html/refract.xhtml\n vec3 RefractCustom( vec3 I, vec3 N, float eta) {\n\n    float k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));\n    if(k<0.0)\n    return I;\n\n       return eta * I - (eta * dot(N, I) + sqrt(k)) * N;\n}\n\n/* Original C++ code from RaytracingInOneWeekend book, it didn't work in my end\ninline vec3 refract(const vec3& uv, const vec3& n, double etai_over_etat) {\n    auto cos_theta = fmin(dot(-uv, n), 1.0);\n    vec3 r_out_perp =  etai_over_etat * (uv + cos_theta*n);\n    vec3 r_out_parallel = -sqrt(fabs(1.0 - r_out_perp.length_squared())) * n;\n    return r_out_perp + r_out_parallel;\n}\n*/\n\n vec3 ray_color(Ray r, int depth){\n \n vec3 finalColor = vec3(1.0, 1.0, 1.0);\n       \n       //This logic is a mixture from  \"Introduction to Ray Tracing\" and  \"RaytracingInOneWeekend\"\n       //I couldn't use recursivity so I did a while loop instead with breaks in the base cases\n       while(true)\n       {\n\n            // If we've exceeded the ray bounce limit, no more light is gathered.\n           \n            if (depth <= 0)\n            {\n                finalColor *= 0.0;\n                break;\n            }\n\n\n           // traverse the scene (all spheres) and find the \n           // closest intersected object and intersection point\n           Intersection intersection = intersectAllObjects(r);\n\n           int iSphere = intersection.obj;\n           float minT = intersection.t;\n\n           Sphere sphere;\n\n           if (iSphere > -1) { \n               // to get around iSphere not being constant\n               for (int i=0; i<NUM_SPHERE; i++) {\n                   if (i==iSphere) {\n                       sphere = spheres[i];\n                       break;\n                   }\n               }\n               \n               //is it a Light?\n               if(spheres[iSphere].isLight == 1)\n                   return finalColor * spheres[iSphere].color;\n               \n               \n\n\n               // hit coordinates\n               vec3 hit = r.origin + minT*r.direction;\n               // normal at the point of ray-sphere intersection\n               vec3 hitPointNormal = normalize(hit-sphere.center);\n               vec3 xnorm = hitPointNormal;\n               r.origin = hit;\n               \n               if(spheres[iSphere].material.surfaceType == 0){\n               //Lambertian distribution\n                    r.direction = LambertScatterDistribution(xnorm);\n                }\n                else if(spheres[iSphere].material.surfaceType == 1){\n                \n                \n                r.direction = ReflectScatterDistribution(r.direction,xnorm + spheres[iSphere].material.roughness *random_unit_vector());\n                }else{\n                \n                \n                    bool front_face;\n                    float ir = 1.5;\n\n                    if (dot(r.direction, xnorm) > 0.0) {\n                        // ray is inside the sphere\n                        xnorm = -xnorm;\n                        front_face = false;\n                        \n\n                    \n                    } else {\n                        // ray is outside the sphere\n                      \n                        front_face = true;\n                        ir = 1.0/ir;\n                    \n                        \n                     }\n                   \n            \n                        \n\n                     vec3 unit_direction = unit_vector(r.direction);\n     \n                     \n\n                    \n                 // r.direction = refract(r.direction, xnorm, ir);\n                  r.direction =  RefractCustom(unit_direction, normalize(xnorm), ir);\n                }\n    \n               \n               //Homogeneous distribution of rays on a hemisphere commented below\n               //r.direction = random_on_hemisphere(xnorm);                      \n               finalColor *= spheres[iSphere].material.albedo;\n              \n            } \n            else{\n             break;\n            \n            }\n             depth--;\n        }\n\n        vec3 unit_direction = normalize(r.direction);\n        float a = 0.5*(unit_direction.y + 1.0);\n        finalColor *= (1.0-a)*vec3(1.0, 1.0, 1.0) + a*vec3(0.5, 0.7, 1.0);\n        return finalColor;\n                \n }\n\n/* The main entry point:\n   * This is called for every pixel on the screen \n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   \n\n   initRandomGenerator(fragCoord);\n\n   makeScene(iFrame);\n\n   \n   float screenDepth = -2.0 - iMouse.y/iResolution.y;\n   \n   float width = iResolution.x;\n   float height = iResolution.y; \n   \n   vec3 samp = vec3(0, 0, 0);\n \n       for (int i=0; i<1*numSamples; i++) {\n           float x = fragCoord.x + random() - 0.5;\n           float y = fragCoord.y + random() - 0.5;\n\n\n           // map (0.5, w-0.5) to (-1, 1)\n           // and (0.5, h-0.5) to (-1, 1)\n           x = (x/width)*2.0 - 1.0;\n           y = (y/height)*2.0 - 1.0;\n\n           // account for the non-square window\n           float aspectRatio = width/height;\n           y = y/aspectRatio;\n\n           // ray Origin for is at (0, 0, 0)\n           vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n           // normalized ray direction\n           vec3 rayDirection = normalize(vec3(x, y, screenDepth));\n\n           Ray ray = Ray(rayOrigin, rayDirection);\n           vec3 col = vec3(1.0, 1.0, 1.0);\n\n\n           samp += ray_color(ray, maxBounces);\n\n       }\n   \n   // average all the samples per pixel\n   fragColor = vec4(samp/float(numSamples), 1.0);\n  \n  \n\n}","name":"Image","description":"","type":"image"}]}