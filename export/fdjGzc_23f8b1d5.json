{"ver":"0.1","info":{"id":"fdjGzc","date":"1617751474","viewed":84,"name":"Max Norm Cube","username":"khalladay","description":"Cube Distance Function using Max Norms","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["primitives","norm","max"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DETAIL_LEVEL 128\n#define PI 3.14159\n\n//uncomment this to switch to \"traditional\" euclidean distance functions\n#define MAX_NORM\n\nfloat max3(float a, float b, float c)\n{\n\treturn max(max(a, b), c);\n}\nfloat max_element(vec3 v)\n{\n\treturn max3(v.x, v.y, v.z);\n}\nfloat max_norm(vec3 v)\n{\n\treturn max_element(abs(v));\n}\n\n\n\nfloat sd_cube(vec3 p, float r)\n{\n\treturn max_norm(p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat map(vec3 at)\n{\n    #ifdef MAX_NORM\n\treturn sd_cube(at,3.0);\n    #else\n    return sdBox(at, vec3(3.0,3.0,3.0));\n    #endif\n}\n\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e);\n    }\n    return normalize(n);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mouseX = (-iMouse.x / iResolution.x) * 10.0;\n    \n    //xz coords for camera are a circle\n    vec3 CAM_OFFSET = 8.0 * (vec3( cos(mouseX), 0.0 , sin(mouseX) ));    \n\tvec3 CAM_UP = vec3(0.0, 1.0, 0.0);\n\tvec3 CAM_POS = vec3(0,8,0) + CAM_OFFSET;\n\tvec3 CAM_LOOKPOINT = vec3(0.0, 0.0, 0.0);\n\t\n\tvec3 lookDirection = normalize(CAM_LOOKPOINT - CAM_POS);\n\tvec3 viewPlaneU = normalize(cross(CAM_UP, lookDirection));\n\tvec3 viewPlaneV = cross(lookDirection, viewPlaneU);\n\tvec3 viewCenter = lookDirection + CAM_POS;\n\t\n    //remap uvs to -1 - +1\n\tvec2 uv = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n\n\tvec3 fragWorldPos = viewCenter + (uv.x * viewPlaneU * iResolution.x / iResolution.y) + (uv.y * viewPlaneV);\n\tvec3 camPosToFragWorld = normalize(fragWorldPos - CAM_POS);\n\n\tconst float farClip = 50.0;\n\t\n\tvec3 col = mix(vec3(0.25), vec3(0.5,0.4,0.3), fragCoord.y/iResolution.y);\n\n    float groundDist = -CAM_POS.y / camPosToFragWorld.y;\n    float debug_sd = map(CAM_POS + camPosToFragWorld*groundDist);\n    \n    if (debug_sd > 0.0)\n    {\n        col = vec3(0.85,0.85, 0.25) * fract(debug_sd);\n    }        \n    \n    float s = map(CAM_POS);\n    float dist = s;\n\tvec3 p = CAM_POS + camPosToFragWorld*s;\n    \n\tfor (int i = 0; i < DETAIL_LEVEL; ++i)\n    {\n        float s=map(p);\n        if ( s < 0.0001 )\n\t\t{\n            col = abs(calcNormal(p));\n            break;\n\t\t}\n        \n        dist += s;\n        if (dist > groundDist) break;\n\n\t\tp += camPosToFragWorld*s;\n\n    }\n    \n  \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}