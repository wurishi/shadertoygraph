{"ver":"0.1","info":{"id":"msfBzf","date":"1689000438","viewed":34,"name":"a practice of raymarching","username":"hbbdmc","description":"this is a demo of raymarcing sphere","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define hw 1.0 / iResolution.y\n#define EPS 1e-5\n\n//the sdf of sphere\nfloat sdf(vec3 p){\n    float d = length(p-vec3(0.0,0.0,1.))//the center of sphere \n    - 0.3;//the radius of sphere\n    return d;\n}\n//input is any point in space,get the normal of sdf\nvec3 getNormal(vec3 p){\n    vec2 t = vec2(0.0, EPS);\n    float base = sdf(p);\n    vec3 n = normalize(\n        vec3(\n            sdf(p + t.yxx) - base ,\n            sdf(p + t.xyx) - base,\n            sdf(p + t.xxy) - base\n            )\n        );\n     \n    return n;\n}\nvoid mainImage( out vec4 O, in vec2 C )\n{\n   vec2 uv = (C - 0.5 * iResolution.xy) * hw;\n   vec3 ray =normalize( vec3(uv,1.0));\n   vec3 o = vec3(.0);\n   float d = 0.;\n   for(float i=0.; i< 50.0; i++){//the maxium num of marching\n       float sdf = sdf(d * ray + o);\n       d = d+ sdf;\n       if(sdf < EPS){\n           break;\n       }\n   }\n   O.xyz = vec3(1.);\n   vec3 p = d * ray + o;\n   if(d>2.){//if d > the minimum distance return\n       return ;\n   }\n   vec3 normal = getNormal(p);//get the normal of surface\n   vec3 lightPos = vec3(0.8,0.8,-0.2);// the pos of light\n   vec3 lightDir = normalize(lightPos - vec3(0.0,0.0,1.));\n   vec3 lightClr = vec3(0.5);// the color of light\n   float crossNL = dot(lightDir,normal);\n   vec3 diffuse = lightClr * pow(\n           max(\n               .0,(crossNL+10.0)/11.\n               ),12.);\n\n   vec3 ambient=vec3(.8,.7,.7)*.12;//the light of environment\n   O.xyz = min(ambient + diffuse,1.);\n}","name":"Image","description":"","type":"image"}]}