{"ver":"0.1","info":{"id":"DtdGzf","date":"1682883080","viewed":67,"name":"quadratic \"bezier\" exploration","username":"jakecariello","description":"basic steps:\n- use 0-1 sine wave param of time\n- param exponent applied to what was originally a quadratic bezier curve\n- tile uv, mod the floored id, do some flips/rotations to get correct curve alignment\n- for color shift id as fn of exponent and mod id","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["simple","intro","bezier","color","tiling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ZOOM 20.\n#define PI 3.141592653589793\n\nmat2 rot2(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n// not used, but keeping here just for convenience\nfloat line(vec2 point, float slope, vec2 pos) {\n    return slope * (pos.x - point.x) + (pos.y - point.y);\n}\n\n// simple quadratic bezier special case\n// from: https://developer.nvidia.com/gpugems/gpugems3/part-iv-image-effects/chapter-25-rendering-vector-art-gpu\n// technically only a bezier if pow is 2, right??\nfloat curve(vec2 pos, float power) {\n    return pow(pos.x , power) - pos.y;\n}\n\nfloat hash21(vec2 p) {\n    p = fract(p*vec2(123.234,234.34));\n    p += dot(p, p + 213.42);\n    return fract(p.x * p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel uv (-.5 to .5)\n    vec2 uv = rot2(iTime) * (sin(iTime) + 1.5) * ZOOM *(fragCoord - .5*iResolution.xy) / iResolution.y;\n    // mouse uv (0, 1)\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    // oscillating param for \"power\" of the curve\n    // use uv magnitude to shift phase\n    float powerParam = sin(iTime / 1. + (length(uv) / 10.)); // 0 to 1;\n    \n    // along an abs val \"V\" curve (min: 1, max: 6)\n    float power = 2. * abs(powerParam - .5) + 1.;\n    \n    // when param = .5, then power = 0, so flip the coords for symmetric appearance\n    bool flipAxes = powerParam < .5;\n    if (flipAxes) {\n        uv.xy = uv.yx;\n    }\n    \n    // generate id and modulus (x, y) for each curve cell\n    vec2 id = floor(uv);\n    vec2 check = mod(id, 2.);\n    \n    // define curve space as fractional component of uv (this does the tiling)\n    vec2 st = fract(uv);\n    \n    // id offset flips for every other (x, y) id value (x, y independent of each other)\n    vec2 signs = vec2(1.);\n    if (check.x >= 1.) {\n        st.x = 1. - st.x;\n        signs.x = -1.;\n    }\n    if (check.y >= 1.) {\n        st.y = 1. - st.y;\n        signs.y = -1.;\n    }\n    \n    // calculate curve value [0, inf)\n    float c = curve(st, power);\n    \n    // shift id to be that of cell we are inside (i.e., which side of curve 0-crossing we are on)\n    // this was kind of finnicky, and i found the right combo by trial-and-error\n    id.x += sign(signs.x) * sign(c) * .5;\n    id.y -= sign(signs.y) * sign(c) * .5;\n    if (flipAxes) id.xy = id.yx; // need to flip to follow uv\n    \n    // compute cell color as function of time and id hash\n    // note that the lightness value is slightly augmented by the curve value\n    vec3 col = hsl2rgb(vec3(sin(2. * PI * (hash21(id.xy) + iTime / 20.)), 0.8, 0.7 + .2 * abs(c)));\n\n    // step to black when curve value near 0\n    col *= smoothstep(.03, .05, abs(c));\n\n    // output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}