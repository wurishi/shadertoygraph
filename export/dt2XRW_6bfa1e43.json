{"ver":"0.1","info":{"id":"dt2XRW","date":"1676469174","viewed":141,"name":"Critters with behaviour brains.","username":"DwayneBrah","description":"A stalled alife attempt. I'm sure there's a faster, better way of handling the persistant array in the buffer. It started to get very complex and I dont have much time to spend on it.\n\nI'm going to style it like a microscope view when I get the chance.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["life","sprites","memory","alife","creatures","persistant","artificiallife"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The main params are in the common tab.\n// The 'brains' are in the buffer tab.\n\n// Run out of steam while trying to create an a-life simulation.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    ar_multiplyer = vec2(iResolution.x / iResolution.y, 1.00);    \n    \n    vec4 buffer_color = texture(iChannel0, uv);\n    vec4 background_color = texture(iChannel1, uv);\n    background_color *= 0.18 * background_color;\n    \n    float time = iTime;\n    \n    // Background\n    // Debug view\n    vec4 final_color = mix(vec4(background_color), buffer_color, 0.00);\n    \n    // Whos near?\n    int row_number;\n    \n    float glow_size = (cell_size*1.55);\n    \n    float body_circle = 0.00;\n    float nearest_to_anything = 10000.00;\n    int nearest_cell_no = -1;\n    for (int cell_no = 1; cell_no < critter_max; cell_no += 1) {\n        \n        float x_location = mod(float(cell_no*gap_size-1), iResolution.x)/iResolution.x;\n        \n        row_number = int(float(cell_no*gap_size-1) / iResolution.x)+1;\n        \n        float y_location = (float(row_number*gap_size) + 0.50) / iResolution.y;\n        y_location = (float((row_number-1)*gap_size) + 0.50) / iResolution.y;\n        \n        vec2 buffer_coord = vec2(x_location, y_location);\n        vec4 buffer_color = texture(iChannel0, buffer_coord);\n        \n        vec2 cell_coord = vec2(buffer_color.r*2.00, buffer_color.g*2.00);\n        \n        float distance_any = distance(uv*ar_multiplyer, cell_coord*ar_multiplyer);\n        \n        if (distance_any < cell_size) {\n            body_circle += (cell_size-distance_any)*(1.00/cell_size);\n        }\n        \n\n        \n        // Get nearest\n        if (distance_any != 0.00 && distance_any < nearest_to_anything) {\n            nearest_to_anything = distance_any;\n            nearest_cell_no = cell_no;\n        }\n        \n    }\n    \n    int nearest_species = species_from_cell_number(nearest_cell_no);\n            \n    vec4 cell_color = vec4(0.00, 0.00, 0.00, 1.00);\n    \n    // Work out color\n    if (nearest_species == 0) { cell_color = vec4(0.20, 0.00, 0.00, 1.00); }\n    if (nearest_species == 1) { cell_color = vec4(0.00, 0.20, 0.00, 1.00); }\n    if (nearest_species == 2) { cell_color = vec4(0.00, 0.15, 0.40, 1.00); }\n    \n    // Render\n    vec4 cell_base_color = cell_color;\n    if (body_circle > cell_size) {\n        final_color = cell_base_color + (body_circle*body_circle)*0.50;\n    }\n    \n    \n\n    \n    // Output to screen\n    fragColor = vec4(final_color);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nvec2 uv;\nfloat time;\nfloat rand_seed = 1.23;\n\nfloat rand() {\n    float rn = fract(sin((uv.x+uv.y+rand_seed)*time*(time+13245.65)) * (time+47453.5453));\n    rand_seed = rn;\n    return rn;\n}\n\n// Experimantal skipping to improve performance (muted)\nbool skip_this_one(int cell_no) {\n    \n    //int process_every = 5;\n    \n    //bool skip = (mod(float(iFrame+cell_no), float(process_every)) != 0.00);\n    \n    //return(skip);\n    return(false);\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    uv = fragCoord/iResolution.xy;\n    time = iTime;\n    vec4 this_channel_color = texture(iChannel0, uv);\n    vec2 ar_multiplyer = vec2(iResolution.x / iResolution.y, 1.00);    \n\n    // Work out current critter from current coord\n    int current_x = int(floor((fragCoord.x-1.00)));\n    int current_y = int(floor((fragCoord.y-0.50)));\n    \n    int current_pixel = 0;\n    current_pixel += current_x;\n    current_pixel += int(  (float(current_y)*(iResolution.x+1.00)) / float(gap_size) );\n    \n    bool is_a_memory_pixel = (mod(float(current_x), float(gap_size))) == 0.00;\n    is_a_memory_pixel = is_a_memory_pixel && (mod(float(current_y), float(gap_size)) == 0.00);\n    \n    int cell_number = int(float(current_pixel)/2.00)+1;\n    \n    // If its a memory pixel and we don't skip, go ahead\n    if (is_a_memory_pixel && cell_number < critter_max) {\n    \n        fragColor = vec4(1.00, 0.50, 0.50, 1.00);\n        \n        if (cell_number < critter_max) {\n            \n            // Initiate if its the first frame\n            if (iFrame == 1) {\n                \n                float random_x = rand();\n                float random_y = rand();\n                float random_direction = rand()*pi*2.00;\n                float random_speed = rand()*max_speed+0.0010;\n        \n                fragColor = vec4(random_x, random_y, random_direction, random_speed*start_speed_multiplier);\n            \n            } else {\n                \n                vec2 cell_coord = vec2(this_channel_color.r, this_channel_color.g);\n                float cell_direction = this_channel_color.b;\n                float cell_speed = this_channel_color.a;\n                \n                int cell_species = species_from_cell_number(cell_number);\n                \n                // Neighbours\n                // Whos near?\n                float closeness_to_any = 0.00;\n                float direction_total = 0.00;\n                float nearest = 1000.00;\n                \n                int cells_in_range_count = 0;\n                int enemies_in_range_count = 0;\n                int friends_in_range_count = 0;\n                int cells_touching = -1;\n                \n                int nearest_species = -1;\n                int focused_species = -1;\n                \n                float nearest_touching_distance = 1000.00;\n                vec2 vector_to_nearest_touching = vec2(0.00, 0.00);\n                \n                float nearest_enemy_distance = 1000.00;\n                vec2 vector_to_nearest_enemy = vec2(0.00, 0.00);\n                \n                float nearest_friend_distance = 1000.00;\n                float direction_of_nearest_friend = 1000.00;\n                vec2 vector_to_nearest_friend = vec2(0.00, 0.00);\n                \n                if (!skip_this_one(cell_number)) {\n                \n                    // Need to alternate/skip to make faster\n                    for (int cell_no = 0; cell_no <= critter_max; cell_no += 1) {\n\n                        float x_location = mod(float(cell_no*gap_size-1), iResolution.x)/iResolution.x;\n                        int row_number = int(float(cell_no*gap_size-1) / iResolution.x);\n                        float y_location = (float(row_number*gap_size) + 0.50) / iResolution.y;\n                        vec2 buffer_coord = vec2(x_location, y_location);\n                        vec4 buffer_color = texture(iChannel0, buffer_coord);\n\n                        vec2 this_cell_coord = vec2(buffer_color.r*2.00, buffer_color.g*2.00);\n                        float this_cell_direction = buffer_color.b;\n                        int this_species = species_from_cell_number(cell_no);                  \n\n\n\n                        float distance_this = distance(cell_coord*ar_multiplyer, this_cell_coord*ar_multiplyer);\n                        if (distance_this < cell_size*2.00) {\n                            closeness_to_any += (cell_size-distance_this)*(1.00/cell_size);\n                            cells_touching++;\n                            if (nearest_touching_distance > distance_this) {\n                                nearest_touching_distance = distance_this;\n                                vector_to_nearest_touching = (this_cell_coord - cell_coord)*ar_multiplyer;\n                            }\n                            \n                        }\n\n                        // Get number of all cells in range\n                        float cell_direction = buffer_color.g;\n                        if (distance_this < range) {\n\n                            cells_in_range_count++;\n\n                            // Get number of friend cells in range\n                            if (this_species == cell_species) {\n                            \n                                friends_in_range_count++;\n                                if (nearest_friend_distance > distance_this) {\n                                    nearest_friend_distance = distance_this;\n                                    vector_to_nearest_friend = (this_cell_coord - cell_coord)*ar_multiplyer;\n                                    direction_of_nearest_friend = this_cell_direction;\n                                }                                \n                            }\n\n                        }\n                        \n                        // More range to detect an enemy\n                        if (distance_this < range*1.50) {\n                            // Get number of enemy cells in range\n                            if (this_species != cell_species) {\n                                enemies_in_range_count++;\n                                if (nearest_enemy_distance > distance_this) {\n                                    nearest_enemy_distance = distance_this;\n                                    vector_to_nearest_enemy = (this_cell_coord - cell_coord)*ar_multiplyer;\n                                }\n                            }\n                        }\n\n                        // Get nearest that is not within range of self\n                        if (distance_this > cell_size && distance_this < nearest) {\n                            nearest = distance_this;\n                            nearest_species = this_species;\n                        }\n\n                    }\n\n                }\n                \n                \n                \n                \n                \n                \n                \n                // EXPERIMENTAL BRAINS\n                // Cell mode defaults\n                bool is_moving = true;\n                bool twitch = false;\n                \n                \n                // Exclusive actions for species 0 \n                if (cell_species == 0) {\n                    \n                    // Follow friend\n                    if (friends_in_range_count > 0) {\n                        \n                        if (cell_speed < base_speed) {\n                            cell_speed += base_speed*0.10;\n                        }\n                        // change angle should be here\n                        cell_speed *= 1.10;                        \n                        \n                    };\n                    \n                    \n                }\n\n\n                // Slow down if we have two friends\n                if (friends_in_range_count >1) {\n                    cell_speed *= 0.20;\n                }\n                // Go if too crowded.\n                if (cells_in_range_count > 2) {\n                \n                    is_moving = true;\n                    \n                    if (cell_speed < base_speed) {\n                        cell_speed = base_speed;\n                    }\n                    \n                    cell_speed *= 1.20;\n                }\n                // If lonely\n                if (friends_in_range_count == 0) {\n                    \n                    if (rand() > 0.95) {\n                    \n                        if (cell_speed < base_speed) {\n                            cell_speed = base_speed;\n                        }\n                        \n                        cell_speed *= 1.20;\n                    \n                    }\n                    \n                }\n                // If an enemy is nearby\n                if (enemies_in_range_count > 0) {\n                \n                    float angle_to_nearest_enemy = getAngle(vec2(0,0), vector_to_nearest_enemy);\n                    \n                    cell_direction = angle_to_nearest_enemy+pi;\n                    \n                    if (cell_speed < base_speed) {\n                        cell_speed += base_speed*0.10;\n                    }\n                    \n                    cell_speed *= 1.10;\n                    \n                }\n                // Twitch, and turn if touching another\n                if (cells_touching > 0) {\n                \n                    if (cell_speed < base_speed) {\n                        cell_speed += base_speed*0.10;\n                    }\n                    cell_speed *= 1.20;\n                    twitch = true;\n\n                }\n                // Recoil if touching (reverse)\n                /*\n                if (cells_touching > 0) {\n                \n                    cell_speed = 0.00 - base_speed;\n                    cell_speed *= 1.20;\n                    twitch = true;\n\n                }\n                */\n                \n                \n                // Environment\n                // Just a random twitch when bored to keep things in flux\n                if (rand() > 0.99) {\n                    twitch = true;\n                }                \n                // A random movement\n                if (rand() > 0.99) {\n                    cell_speed += base_speed;\n                }                   \n                \n                // Slowdown \n                cell_speed *= 0.98;\n                if (cell_speed > max_speed) {\n                    cell_speed = max_speed;\n                };\n                \n                \n                \n                // Keep pixels persisting across frames\n                fragColor = this_channel_color;\n                \n                // Work out momentum vector\n                vec2 cell_momentum = vec2(sin(cell_direction), cos(cell_direction));\n                cell_momentum /= ar_multiplyer;\n                cell_momentum *= cell_speed;\n            \n                // Move cell\n                vec2 new_cell_coord;\n                \n                \n                if (is_moving) {\n                \n                    new_cell_coord = cell_coord + cell_momentum;\n                    \n                } else {\n                \n                    // When not moving\n                    new_cell_coord = cell_coord;\n                    \n                }\n                \n                if (twitch) {\n                \n                    float twitch_direction = rand()*pi*2.00;                    \n                    new_cell_coord += vec2(sin(twitch_direction), cos(twitch_direction)) * twitch_amount;\n                    \n                }\n                \n                // Wrap around\n                if (new_cell_coord.x < 0.00-cell_size) (new_cell_coord.x = 1.00+cell_size);\n                if (new_cell_coord.x > 1.00+cell_size) (new_cell_coord.x = 0.00-cell_size);\n                if (new_cell_coord.y < 0.00-cell_size) (new_cell_coord.y = 1.00+cell_size);\n                if (new_cell_coord.y > 1.00+cell_size) (new_cell_coord.y = 0.00-cell_size);\n                if (cell_direction > pi*2.00) {\n                    cell_direction -= pi*2.00;\n                }\n                if (cell_direction < 0.00) {\n                    cell_direction += pi*2.00;\n                }\n\n\n                vec4 resulting_properties = vec4(new_cell_coord, cell_direction, cell_speed);\n                \n                fragColor = resulting_properties;\n                \n            }\n            \n            \n            \n        }\n        \n        \n        \n        \n    } else {\n        \n        \n        fragColor = vec4(0.00, 0.00, 0.00, 1.00);\n        \n    }\n    \n    \n    \n}\n\n\n\n\n\n\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\nfloat pi = 3.14159;\nvec2 ar_multiplyer;    \n\n\nint critter_max = 500;\nfloat cell_size = 0.012;\nint gap_size = 2;\nfloat range = 0.027;\nfloat start_speed_multiplier = 0.01; \n\nint critter_count = 0;\n\n\n\nfloat max_speed = 0.002;\nfloat base_speed = 0.0003;\nfloat twitch_amount = 0.0011;\n\nint species_amount = 3;\n\nint species_from_cell_number (int cell_number) {\n    \n    int species = int( mod(float(cell_number), float(species_amount)) );\n    return (species);\n    \n}\n\nfloat getAngle(vec2 v1, vec2 v2)\n{\n    return mod( atan(v1.x,v1.y) -atan(v2.x,v2.y), pi*2.00)*2.00;\n}\n\nvoid test(inout int testint) {\n    testint = 1;\n}","name":"Common","description":"","type":"common"}]}