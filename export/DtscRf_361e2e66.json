{"ver":"0.1","info":{"id":"DtscRf","date":"1691448550","viewed":1714,"name":"GM Shaders: CRT","username":"Xor","description":"https://mini.gmshaders.com/p/gm-shaders-mini-crt","likes":81,"published":1,"flags":32,"usePreview":0,"tags":["crt","demo","tut"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Bloom pass\n    \n    \"GM Shaders: CRT\" by @XorDev\n    \n    How to create a simple CRT effect including:\n    \n    -RGB pixel cells\n    -Chromatic aberration\n    -Screen curvature\n    -Vignette\n    -Pulsing\n    -Bloom pass\n    \n    Based on my 1 pass blur:\n    https://github.com/XorDev/1PassBlur\n*/\n\n//Bloom radius in pixels\n#define BLOOM_RADIUS 16.0\n//Bloom texture samples\n#define BLOOM_SAMPLES 32.0\n//Bloom base brightness\n#define BLOOM_BASE 0.5\n//Bloom glow brightness\n#define BLOOM_GLOW 3.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    //Resolution and texel size\n    vec2 res = iResolution.xy;\n    vec2 texel = 1.0 / res;\n    \n    //Bloom total\n   \tvec4 bloom = vec4(0);\n    //Sample point\n    vec2 point = vec2(BLOOM_RADIUS, 0)*inversesqrt(BLOOM_SAMPLES);\n    for(float i = 0.0; i<BLOOM_SAMPLES; i++)\n    {\n        //Rotate by golden angle\n        point *= -mat2(0.7374, 0.6755, -0.6755, 0.7374);\n        //Compute sample coordinates from rotated sample point\n        vec2 coord = (fragCoord + point*sqrt(i)) * texel;\n        //Add bloom samples\n        bloom += texture(iChannel0, coord) * (1.0 - i/BLOOM_SAMPLES);\n    }\n    //Compute bloom average\n    bloom *= BLOOM_GLOW/BLOOM_SAMPLES;\n    //Add base sample\n    bloom += texture(iChannel0,fragCoord*texel)*BLOOM_BASE;\n    fragColor = bloom;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n    Color pass\n    \n    Based on \"Cosmic\":\n    https://www.shadertoy.com/view/msjXRK\n*/\nvoid mainImage(out vec4 O, vec2 I)\n{\n    //Clear fragcolor (hacky)\n    O *= 0.;\n    //Initialize resolution for scaling\n    vec2 r=iResolution.xy,\n    //Save centered pixel coordinates\n    p = (I-r*vec2(.53,.58))*mat2(1,-1,2,2);\n    \n    //Initialize loop iterator and arc angle\n    for(float i=0.,a;\n        //Loop 300 times\n        i++<1e1;\n        //Add with ring attenuation\n        O += 1. / (abs(length(I=p/(r+r-p).y)*3e1-i)+4e1/r.y)*\n        //Limit to arcs\n        clamp(cos(a=atan(I.y,I.x)*ceil(i*.2)+iTime*sin(i*i)+i*i),.0,.1)*\n        //Give them color\n        (cos(a-i+vec4(0,2,3,0))+1.));\n    \n    //Range fix\n    O = clamp(O,0.,1.);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n    CRT pass\n*/\n\n//RGB Mask intensity(0 to 1)\n#define MASK_INTENSITY 1.0\n//Mask size (in pixels)\n#define MASK_SIZE 12.0\n//Border intensity (0 to 1)\n#define MASK_BORDER 0.8\n\n//Chromatic abberration offset in texels (0 = no aberration)\n#define ABERRATION_OFFSET vec2(2,0)\n\n//Curvature intensity\n#define SCREEN_CURVATURE 0.08\n//Screen vignette\n#define SCREEN_VIGNETTE 0.4\n\n//Intensity of pulsing animation\n#define PULSE_INTENSITY 0.03\n//Pulse width in pixels (times tau)\n#define PULSE_WIDTH 6e1\n//Pulse animation speed\n#define PULSE_RATE 2e1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    //Resolution\n\tvec2 res = iResolution.xy;\n    //Signed uv coordinates (ranging from -1 to +1)\n\tvec2 uv = fragCoord/res * 2.0 - 1.0;\n    //Scale inward using the square of the distance\n\tuv *= 1.0 + (dot(uv,uv) - 1.0) * SCREEN_CURVATURE;\n    //Convert back to pixel coordinates\n\tvec2 pixel = (uv*0.5+0.5)*res;\n    \n    //Square distance to the edge\n    vec2 edge = max(1.0 - uv*uv, 0.0);\n    //Compute vignette from x/y edges\n    float vignette = pow(edge.x * edge.y, SCREEN_VIGNETTE);\n\t\n    //RGB cell and subcell coordinates\n    vec2 coord = pixel / MASK_SIZE;\n    vec2 subcoord = coord * vec2(3,1);\n    //Offset for staggering every other cell\n\tvec2 cell_offset = vec2(0, fract(floor(coord.x)*0.5));\n    \n    //Pixel coordinates rounded to the nearest cell\n    vec2 mask_coord = floor(coord+cell_offset) * MASK_SIZE;\n    \n    //Chromatic aberration\n\tvec4 aberration = texture(iChannel0, (mask_coord-ABERRATION_OFFSET) / res);\n    //Color shift the green channel\n\taberration.g = texture(iChannel0,    (mask_coord+ABERRATION_OFFSET) / res).g;\n   \n    //Output color with chromatic aberration\n\tvec4 color = aberration;\n    \n    //Compute the RGB color index from 0 to 2\n    float ind = mod(floor(subcoord.x), 3.0);\n    //Convert that value to an RGB color (multiplied to maintain brightness)\n    vec3 mask_color = vec3(ind == 0.0, ind == 1.0, ind == 2.0) * 3.0;\n    \n    //Signed subcell uvs (ranging from -1 to +1)\n    vec2 cell_uv = fract(subcoord + cell_offset) * 2.0 - 1.0;\n    //X and y borders\n    vec2 border = 1.0 - cell_uv * cell_uv * MASK_BORDER;\n    //Blend x and y mask borders\n    mask_color.rgb *= border.x * border.y;\n    //Blend with color mask\n\tcolor.rgb *= 1.0 + (mask_color - 1.0) * MASK_INTENSITY;  \n    \n    //Apply vignette\n    color.rgb *= vignette;\n    //Apply pulsing glow\n\tcolor.rgb *= 1.0+PULSE_INTENSITY*cos(pixel.x/PULSE_WIDTH+iTime*PULSE_RATE);\n    \n    fragColor = color;\n}","name":"Buffer B","description":"","type":"buffer"}]}