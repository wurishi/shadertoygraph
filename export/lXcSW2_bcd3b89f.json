{"ver":"0.1","info":{"id":"lXcSW2","date":"1720179345","viewed":59,"name":"Antialias check","username":"TomCarbon","description":"checking out antialias implementation in order to fix any related rendering issue.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","antialias"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const uint kAntiAlias = 4u;\nconst float kAntiAliasInv = 1. / float(kAntiAlias);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float t = iTime * 0.7;\n\n    vec3 pixel = vec3(0);\n \n    float halfX = iResolution.x / 2.0;\n    float limitX = halfX + halfX * sin(t);\n    if (iMouse.z > 0.5)\n        limitX = iMouse.x;\n\n    vec3 ro = vec3(0, 2.1 + sin(t) * 0.2, 1);\n\n    if (fragCoord.x > limitX)\n    {\n        for(uint aa = 0u; aa < kAntiAlias * kAntiAlias; ++aa)\n        {\n            vec2 aad = kAntiAliasInv * vec2(float(aa % kAntiAlias), float(aa / kAntiAlias)) - 0.5;\n            vec2 uv = (2.0 * (fragCoord + aad) - iResolution.xy) / iResolution.y;\n\n            vec3 rd = normalize(vec3(uv, -1.0));\n\n            vec3 color = getColor(ro, rd);\n\n            pixel += color;\n        }\n\n        pixel = pixel / float(kAntiAlias * kAntiAlias);\n    }\n    else if (fragCoord.x + 4.f > limitX)\n    {\n        pixel = vec3(1);\n    }\n    else\n    {\n        vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n        vec3 rd = normalize(vec3(uv, -1.0));\n\n        pixel = getColor(ro, rd);\n    }\n\n    // gamma\n    pixel = pow(pixel, vec3(1.0 / 2.2));\n\n    // vignetting\n    vec2 q = fragCoord.xy / iResolution.xy;\n    pixel *= 0.2 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.15);\n\n    // dithering\n    pixel += (1.0 / 255.0) * hash13(q.x + 23.0 * q.y + sin(t));\n\n    fragColor = vec4(pixel, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const int kMaxSteps = 255;\nconst float kMinSurface = 0.001;\nconst float kMaxDistance = 100.0;\n\nvec3 hash13(float n) { return fract(sin(vec3(n, n + 1.0, n + 2.0)) * 437158.5453123); }\n\nconst vec3 light = vec3(4.0, 8.0, 3.0);\n\n\nfloat sdSphere(vec3 p, vec4 sphere)\n{\n    return length(p - sphere.xyz) - sphere.w;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdScene(vec3 p)\n{\n    float d = p.y;\n\n    d = min(d,    sdBox(p - vec3(-4, 2, -3.5), vec3(1)));\n    d = min(d, sdSphere(p - vec3(-2, 0,  0), vec4(0, 2, -3, 0.6)));\n    d = min(d, sdSphere(p - vec3( 0, 0,  0), vec4(0, 2, -5, 2)));\n    d = min(d, sdSphere(p - vec3( 5, 0,  0), vec4(-1.5, 2, -3, 3)));\n \n    return d;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(0, 0.001);\n    \n    vec3 n = sdScene(p) - vec3( sdScene(p - e.yxx),\n                                sdScene(p - e.xyx),\n                                sdScene(p - e.xxy));\n                \n    return normalize(n);\n}\n\n\nfloat rayMarch(vec3 ro, vec3 rd, float min, float max)\n{\n    float d = min;\n    \n    for (int i = 0; i < kMaxSteps; ++i)\n    {\n        vec3 p = ro + d * rd;\n\n        float sd = sdScene(p);\n        if (sd <= kMinSurface)\n            return d;\n\n        d += sd;\n        if (d >= max)\n            return max;\n    }\n\n    return d;\n}\n\nvec3 getColor(vec3 ro, vec3 rd)\n{\n    vec3 color = vec3(0,0,1);\n\n    float d = rayMarch(ro, rd, 0.0, kMaxDistance);\n    if (d < kMaxDistance)\n    {\n        vec3 p = ro + d * rd;\n        vec3 n = getNormal(p);\n\n        color = clamp(n, 0.0, 1.0);\n\n        vec3 l = normalize(light - p);\n        float ld = length(light - p);\n        \n        float dif = dot(l, n);\n        color *= 0.2 + dif;\n\n        if (rayMarch(p + 4.0 * n * kMinSurface, l, 0.0, ld) < ld)\n            color *= 0.2;\n    }\n\n\n    return color;\n}","name":"Common","description":"","type":"common"}]}