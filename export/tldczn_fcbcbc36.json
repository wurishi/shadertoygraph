{"ver":"0.1","info":{"id":"tldczn","date":"1608404161","viewed":378,"name":"SSAO  sample","username":"Shcherbakov","description":"Screen space ambient occlusion sample from stream: https://www.youtube.com/watch?v=s9O08T9XD3g&ab_channel=GraphicsMonster","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["ssao"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere {\n    vec3 pos;\n    vec3 color;\n    float radius;\n    float specular;\n};\n    \nstruct Triangle {\n    vec3 pos[3];\n    vec3 color;\n    vec3 normal;\n    float specular;\n};\n    \nconst uint SPHERES_COUNT = 3u;\nconst uint TRIANGLES_COUNT = 2u;\nconst float FAR_INF = 1e10;\nconst vec3 SKY_COLOR = vec3(0.4, 0.4, 0.8);\nconst float EPS = 1e-3;\n\nSphere SPHERES[SPHERES_COUNT];\n\nTriangle TRIANGLES[TRIANGLES_COUNT];\n\nfloat ray_sphere_intersection(Sphere s, vec3 origin, vec3 dir) {\n    // length(origin + dir * t - s.pos) = radius\n    // dot(origin + dir * t - s.pos, origin + dir * t - s.pos) = radius ^2\n    // dot(origin - s.pos, origin - s.pos) + 2dot(origin - s.pos, dir)t + dot(dir, dir) * t^2 = radius^2\n    // dot(origin - s.pos, origin - s.pos) - radius^2 + 2dot(origin - s.pos, dir)t + t^2 = 0\n    vec3 sphereToCam = origin - s.pos;\n    float B = 2.0 * dot(sphereToCam, dir);\n    float C = dot(sphereToCam, sphereToCam) - s.radius * s.radius;\n    float Desc = B * B - 4.0 * C;\n    if (Desc < 0.0)\n        return FAR_INF;\n    float nearDist = (-B - sqrt(Desc)) / 2.0;\n    if (nearDist > 0.0)\n        return nearDist;\n    float farDist = (-B + sqrt(Desc)) / 2.0;\n    if (farDist > 0.0)\n        return farDist;\n    return FAR_INF;\n}\n\nfloat ray_sphere_intersection(vec3 sphPos, float radius, vec3 origin, vec3 dir) {\n    // length(origin + dir * t - s.pos) = radius\n    // dot(origin + dir * t - s.pos, origin + dir * t - s.pos) = radius ^2\n    // dot(origin - s.pos, origin - s.pos) + 2dot(origin - s.pos, dir)t + dot(dir, dir) * t^2 = radius^2\n    // dot(origin - s.pos, origin - s.pos) - radius^2 + 2dot(origin - s.pos, dir)t + t^2 = 0\n    vec3 sphereToCam = origin - sphPos;\n    float B = 2.0 * dot(sphereToCam, dir);\n    float C = dot(sphereToCam, sphereToCam) - radius * radius;\n    float Desc = B * B - 4.0 * C;\n    if (Desc < 0.0)\n        return FAR_INF;\n    float nearDist = (-B - sqrt(Desc)) / 2.0;\n    if (nearDist > 0.0)\n        return nearDist;\n    float farDist = (-B + sqrt(Desc)) / 2.0;\n    if (farDist > 0.0)\n        return farDist;\n    return FAR_INF;\n}\n\nfloat ray_triangle_intersection(Triangle t, vec3 origin, vec3 dir) {\n    // dot(origin + dir * d - t.pos[0], t.normal) == 0\n    // dot(origin - t.pos[0], t.normal) + dot(dir, t.normal) * d == 0\n    // d = dot(t.pos[0] - origin, t.normal) / dot(dir, t.normal);\n    float normalViewAngle = dot(dir, t.normal);\n    if (abs(normalViewAngle) < EPS)\n        return FAR_INF;\n    float d = dot(t.pos[0] - origin, t.normal) / normalViewAngle;\n    if (d < 0.0)\n        return FAR_INF;\n    vec3 hitPos = origin + dir * d;\n    vec3 edges[3] = vec3[3](\n        t.pos[1] - t.pos[0],\n        t.pos[2] - t.pos[1],\n        t.pos[0] - t.pos[2]\n    );\n    float square = length(cross(edges[0], edges[1]));\n    vec3 toHitVecs[3] = vec3[3](\n        hitPos - t.pos[0],\n        hitPos - t.pos[1],\n        hitPos - t.pos[2]\n    );\n    float testSq[3] = float[3](\n        length(cross(toHitVecs[0], edges[0])),\n        length(cross(toHitVecs[1], edges[1])),\n        length(cross(toHitVecs[2], edges[2]))\n    );\n    if (abs(square - testSq[0] - testSq[1] - testSq[2]) < EPS)\n        return d;\n    return FAR_INF;\n}\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\nconst mat3 ma = mat3( 0.60, 0.00,  0.80,\n                      0.00, 1.00,  0.00,\n                     -0.80, 0.00,  0.60 );\n\nvec4 map( in vec3 p )\n{\n    float d = sdBox(p,vec3(1.0));\n    vec4 res = vec4( d, 1.0, 0.0, 0.0 );\n\n    float ani = smoothstep( -0.2, 0.2, -cos(0.5*iTime) );\n  float off = 1.5*sin( 0.01*iTime );\n  \n    float s = 1.0;\n    for( int m=0; m<4; m++ )\n    {\n        p = mix( p, ma*(p+off), ani );\n     \n        vec3 a = mod( p*s, 2.0 )-1.0;\n        s *= 3.0;\n        vec3 r = abs(1.0 - 3.0*abs(a));\n        float da = max(r.x,r.y);\n        float db = max(r.y,r.z);\n        float dc = max(r.z,r.x);\n        float c = (min(da,min(db,dc))-1.0)/s;\n\n        if( c>d )\n        {\n          d = c;\n          res = vec4( d, min(res.y,0.2*da*db*dc), (1.0+float(m))/4.0, 0.0 );\n        }\n    }\n\n    return res;\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3  eps = vec3(.001,0.0,0.0);\n    vec3 nor;\n    nor.x = map(pos+eps.xyy).x - map(pos-eps.xyy).x;\n    nor.y = map(pos+eps.yxy).x - map(pos-eps.yxy).x;\n    nor.z = map(pos+eps.yyx).x - map(pos-eps.yyx).x;\n    return normalize(nor);\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n    vec4 res = vec4(-1.0);\n    vec4 h = vec4(1.0);\n    for( int i=0; i<64; i++ )\n    {\n    if( h.x<0.002 || t>10.0 ) break;\n        h = map(ro + rd*t);\n        res = vec4(t,h.yzw);\n        t += h.x;\n    }\n  if( t>10.0 ) res=vec4(-1.0);\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos = vec3(0, 0, -5);\n    \n    SPHERES[0].pos = vec3(0, sin(iTime) * 2.0, 4.0);\n    SPHERES[0].color = vec3(0x64, 0x56, 0x70) / 255.0;\n    SPHERES[0].radius = 0.5;\n    SPHERES[0].specular = 64.0;\n    SPHERES[1].pos = vec3(-1.5, sin(iTime + 3.14) * 2.0, 4);\n    SPHERES[1].color = vec3(0xd5, 0xb0, 0x8d) / 255.0;\n    SPHERES[1].radius = 0.5;\n    SPHERES[1].specular = 128.0;\n    SPHERES[2].pos = vec3(0, -1002, 0);\n    SPHERES[2].color = vec3(0xd5, 0xb0, 0x8d) / 255.0;\n    SPHERES[2].radius = 1000.0;\n    SPHERES[2].specular = 0.0;\n\n    TRIANGLES[0].pos = vec3[3](vec3(-5, -5, 10), vec3(-5, 5, 10), vec3(5, 5, 10));\n    TRIANGLES[0].color = vec3(0xba, 0x73, 0x38) / 255.0;\n    TRIANGLES[0].normal = vec3(0, 0, -1);\n    TRIANGLES[0].specular = 0.0;\n    TRIANGLES[1].pos = vec3[3](vec3(-5, -5, 10), vec3(5, 5, 10), vec3(5, -5, 10));\n    TRIANGLES[1].color = vec3(0xba, 0x73, 0x38) / 255.0;\n    TRIANGLES[1].normal = vec3(0, 0, -1);\n    TRIANGLES[1].specular = 0.0;\n    \n    vec3 SUN_DIR = normalize(vec3(1, -3, 1));\n    \n    const int SAMPLES_COUNT = 4;\n    vec3 fullLighting;\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.x;\n    vec3 viewVec = normalize(vec3(uv, 1.0));\n    fragColor = vec4(0.0);\n\n    float intersectionDist = FAR_INF;\n    vec3 intersectionColor;\n    vec3 intersectionPos;\n    vec3 intersectionNormal;\n    \n    vec2 screenUV = (fragCoord)/iResolution.xy;\n    vec4 gbuffer = texture(iChannel0, screenUV);\n    intersectionColor = vec3(\n        int(gbuffer.x) >> 16,\n        (int(gbuffer.x) >> 8) & 0xFF,\n        int(gbuffer.x) & 0xFF\n    ) / 255.0;\n    intersectionNormal.z = cos(gbuffer.z);\n    intersectionNormal.x = cos(gbuffer.y) * sin(gbuffer.z);\n    intersectionNormal.y = sin(gbuffer.y) * sin(gbuffer.z);\n    intersectionPos = cameraPos + gbuffer.w * viewVec;\n    \n    float ao = 0.0;\n    int RADIUS = 2;\n    for (int i = -RADIUS; i <= RADIUS; ++i) {\n        for (int j = -RADIUS; j <= RADIUS; ++j) {\n            ao += texture(iChannel1, screenUV + vec2(i, j) / iResolution.xy).x;\n        }\n    }\n    ao /= float(2 * RADIUS + 1) * float(2 * RADIUS + 1);\n\n    vec3 lighting = intersectionColor * SKY_COLOR * ao;\n\n    lighting += max(0.0, dot(intersectionNormal, -SUN_DIR)) * intersectionColor * ao;\n\n    fragColor.xyz = pow(lighting, vec3(1.0 / 2.2));\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct Sphere {\n    vec3 pos;\n    vec3 color;\n    float radius;\n    float specular;\n};\n    \nstruct Triangle {\n    vec3 pos[3];\n    vec3 color;\n    vec3 normal;\n    float specular;\n};\n    \nconst uint SPHERES_COUNT = 3u;\nconst uint TRIANGLES_COUNT = 2u;\nconst float FAR_INF = 1e10;\nconst vec3 SKY_COLOR = vec3(0.4, 0.4, 0.8);\nconst float EPS = 1e-3;\n\nSphere SPHERES[SPHERES_COUNT];\n\nTriangle TRIANGLES[TRIANGLES_COUNT];\n\nfloat ray_sphere_intersection(Sphere s, vec3 origin, vec3 dir) {\n    // length(origin + dir * t - s.pos) = radius\n    // dot(origin + dir * t - s.pos, origin + dir * t - s.pos) = radius ^2\n    // dot(origin - s.pos, origin - s.pos) + 2dot(origin - s.pos, dir)t + dot(dir, dir) * t^2 = radius^2\n    // dot(origin - s.pos, origin - s.pos) - radius^2 + 2dot(origin - s.pos, dir)t + t^2 = 0\n    vec3 sphereToCam = origin - s.pos;\n    float B = 2.0 * dot(sphereToCam, dir);\n    float C = dot(sphereToCam, sphereToCam) - s.radius * s.radius;\n    float Desc = B * B - 4.0 * C;\n    if (Desc < 0.0)\n        return FAR_INF;\n    float nearDist = (-B - sqrt(Desc)) / 2.0;\n    if (nearDist > 0.0)\n        return nearDist;\n    float farDist = (-B + sqrt(Desc)) / 2.0;\n    if (farDist > 0.0)\n        return farDist;\n    return FAR_INF;\n}\n\nfloat ray_sphere_intersection(vec3 sphPos, float radius, vec3 origin, vec3 dir) {\n    // length(origin + dir * t - s.pos) = radius\n    // dot(origin + dir * t - s.pos, origin + dir * t - s.pos) = radius ^2\n    // dot(origin - s.pos, origin - s.pos) + 2dot(origin - s.pos, dir)t + dot(dir, dir) * t^2 = radius^2\n    // dot(origin - s.pos, origin - s.pos) - radius^2 + 2dot(origin - s.pos, dir)t + t^2 = 0\n    vec3 sphereToCam = origin - sphPos;\n    float B = 2.0 * dot(sphereToCam, dir);\n    float C = dot(sphereToCam, sphereToCam) - radius * radius;\n    float Desc = B * B - 4.0 * C;\n    if (Desc < 0.0)\n        return FAR_INF;\n    float nearDist = (-B - sqrt(Desc)) / 2.0;\n    if (nearDist > 0.0)\n        return nearDist;\n    float farDist = (-B + sqrt(Desc)) / 2.0;\n    if (farDist > 0.0)\n        return farDist;\n    return FAR_INF;\n}\n\nfloat ray_triangle_intersection(Triangle t, vec3 origin, vec3 dir) {\n    // dot(origin + dir * d - t.pos[0], t.normal) == 0\n    // dot(origin - t.pos[0], t.normal) + dot(dir, t.normal) * d == 0\n    // d = dot(t.pos[0] - origin, t.normal) / dot(dir, t.normal);\n    float normalViewAngle = dot(dir, t.normal);\n    if (abs(normalViewAngle) < EPS)\n        return FAR_INF;\n    float d = dot(t.pos[0] - origin, t.normal) / normalViewAngle;\n    if (d < 0.0)\n        return FAR_INF;\n    vec3 hitPos = origin + dir * d;\n    vec3 edges[3] = vec3[3](\n        t.pos[1] - t.pos[0],\n        t.pos[2] - t.pos[1],\n        t.pos[0] - t.pos[2]\n    );\n    float square = length(cross(edges[0], edges[1]));\n    vec3 toHitVecs[3] = vec3[3](\n        hitPos - t.pos[0],\n        hitPos - t.pos[1],\n        hitPos - t.pos[2]\n    );\n    float testSq[3] = float[3](\n        length(cross(toHitVecs[0], edges[0])),\n        length(cross(toHitVecs[1], edges[1])),\n        length(cross(toHitVecs[2], edges[2]))\n    );\n    if (abs(square - testSq[0] - testSq[1] - testSq[2]) < EPS)\n        return d;\n    return FAR_INF;\n}\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\nconst mat3 ma = mat3( 0.60, 0.00,  0.80,\n                      0.00, 1.00,  0.00,\n                     -0.80, 0.00,  0.60 );\n\nvec4 map( in vec3 p )\n{\n    float d = sdBox(p,vec3(1.0));\n    vec4 res = vec4( d, 1.0, 0.0, 0.0 );\n\n    float ani = smoothstep( -0.2, 0.2, -cos(0.5*iTime) );\n  float off = 1.5*sin( 0.01*iTime );\n  \n    float s = 1.0;\n    for( int m=0; m<4; m++ )\n    {\n        p = mix( p, ma*(p+off), ani );\n     \n        vec3 a = mod( p*s, 2.0 )-1.0;\n        s *= 3.0;\n        vec3 r = abs(1.0 - 3.0*abs(a));\n        float da = max(r.x,r.y);\n        float db = max(r.y,r.z);\n        float dc = max(r.z,r.x);\n        float c = (min(da,min(db,dc))-1.0)/s;\n\n        if( c>d )\n        {\n          d = c;\n          res = vec4( d, min(res.y,0.2*da*db*dc), (1.0+float(m))/4.0, 0.0 );\n        }\n    }\n\n    return res;\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3  eps = vec3(.001,0.0,0.0);\n    vec3 nor;\n    nor.x = map(pos+eps.xyy).x - map(pos-eps.xyy).x;\n    nor.y = map(pos+eps.yxy).x - map(pos-eps.yxy).x;\n    nor.z = map(pos+eps.yyx).x - map(pos-eps.yyx).x;\n    return normalize(nor);\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n    vec4 res = vec4(-1.0);\n    vec4 h = vec4(1.0);\n    for( int i=0; i<64; i++ )\n    {\n    if( h.x<0.002 || t>10.0 ) break;\n        h = map(ro + rd*t);\n        res = vec4(t,h.yzw);\n        t += h.x;\n    }\n  if( t>10.0 ) res=vec4(-1.0);\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos = vec3(0, 0, -5);\n    \n    SPHERES[0].pos = vec3(0, sin(iTime) * 2.0, 4.0);\n    SPHERES[0].color = vec3(0x64, 0x56, 0x70) / 255.0;\n    SPHERES[0].radius = 0.5;\n    SPHERES[0].specular = 64.0;\n    SPHERES[1].pos = vec3(-1.5, sin(iTime + 3.14) * 2.0, 4);\n    SPHERES[1].color = vec3(0xd5, 0xb0, 0x8d) / 255.0;\n    SPHERES[1].radius = 0.5;\n    SPHERES[1].specular = 128.0;\n    SPHERES[2].pos = vec3(0, -1002, 0);\n    SPHERES[2].color = vec3(0xd5, 0xb0, 0x8d) / 255.0;\n    SPHERES[2].radius = 1000.0;\n    SPHERES[2].specular = 0.0;\n\n    TRIANGLES[0].pos = vec3[3](vec3(-5, -5, 10), vec3(-5, 5, 10), vec3(5, 5, 10));\n    TRIANGLES[0].color = vec3(0xba, 0x73, 0x38) / 255.0;\n    TRIANGLES[0].normal = vec3(0, 0, -1);\n    TRIANGLES[0].specular = 0.0;\n    TRIANGLES[1].pos = vec3[3](vec3(-5, -5, 10), vec3(5, 5, 10), vec3(5, -5, 10));\n    TRIANGLES[1].color = vec3(0xba, 0x73, 0x38) / 255.0;\n    TRIANGLES[1].normal = vec3(0, 0, -1);\n    TRIANGLES[1].specular = 0.0;\n    \n    vec3 SUN_DIR = normalize(vec3(1, -3, 1));\n    \n    const int SAMPLES_COUNT = 4;\n    vec3 fullLighting;\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.x;\n    vec3 viewVec = normalize(vec3(uv, 1.0));\n    fragColor = vec4(0.0);\n\n    float intersectionDist = FAR_INF;\n    vec3 intersectionColor;\n    vec3 intersectionPos;\n    vec3 intersectionNormal;\n    float intersectionSpecular;\n    for (uint i = 0u; i < SPHERES_COUNT; ++i) {\n        float hitDist = ray_sphere_intersection(SPHERES[i], cameraPos, viewVec);\n        if (hitDist < intersectionDist) {\n            intersectionDist = hitDist;\n            intersectionColor = SPHERES[i].color;\n            intersectionPos = cameraPos + viewVec * intersectionDist;\n            intersectionNormal = normalize(intersectionPos - SPHERES[i].pos);\n            intersectionSpecular = SPHERES[i].specular;\n        }\n    }\n\n    for (uint i = 0u; i < TRIANGLES_COUNT; ++i) {\n        float hitDist = ray_triangle_intersection(TRIANGLES[i], cameraPos, viewVec);\n        if (hitDist < intersectionDist) {\n            intersectionDist = hitDist;\n            intersectionColor = TRIANGLES[i].color;\n            intersectionPos = cameraPos + viewVec * intersectionDist;\n            intersectionNormal = TRIANGLES[i].normal;\n            intersectionSpecular = TRIANGLES[i].specular;\n        }\n    }\n    \n    vec4 sdf = intersect(cameraPos * 2.0 - vec3(2, -1, 0), viewVec);\n    if (sdf.x > 0.0 && sdf.x < intersectionDist) {\n        intersectionDist = sdf.x;\n        intersectionColor = vec3(1, 0, 0);\n        intersectionPos = sdf.yzw * 2.0 - vec3(2, -1, 0);\n        intersectionNormal = calcNormal(sdf.yzw);\n        intersectionSpecular = 0.0;\n    }\n    \n    fragColor.w = intersectionDist;\n    fragColor.x = float(\n        (int(intersectionColor.x * 255.0) << 16)\n        | (int(intersectionColor.y * 255.0) << 8)\n        | (int(intersectionColor.z * 255.0))\n    );\n    fragColor.y = atan(intersectionNormal.y, intersectionNormal.x);\n    fragColor.z = acos(intersectionNormal.z);\n    \n\n    vec3 lighting = intersectionColor * SKY_COLOR;\n\n    lighting += max(0.0, dot(intersectionNormal, -SUN_DIR)) * intersectionColor;\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"struct Sphere {\n    vec3 pos;\n    vec3 color;\n    float radius;\n    float specular;\n};\n    \nstruct Triangle {\n    vec3 pos[3];\n    vec3 color;\n    vec3 normal;\n    float specular;\n};\n    \nconst uint SPHERES_COUNT = 3u;\nconst uint TRIANGLES_COUNT = 2u;\nconst float FAR_INF = 1e10;\nconst vec3 SKY_COLOR = vec3(0.4, 0.4, 0.8);\nconst float EPS = 1e-3;\n\nSphere SPHERES[SPHERES_COUNT];\n\nTriangle TRIANGLES[TRIANGLES_COUNT];\n\nfloat ray_sphere_intersection(Sphere s, vec3 origin, vec3 dir) {\n    // length(origin + dir * t - s.pos) = radius\n    // dot(origin + dir * t - s.pos, origin + dir * t - s.pos) = radius ^2\n    // dot(origin - s.pos, origin - s.pos) + 2dot(origin - s.pos, dir)t + dot(dir, dir) * t^2 = radius^2\n    // dot(origin - s.pos, origin - s.pos) - radius^2 + 2dot(origin - s.pos, dir)t + t^2 = 0\n    vec3 sphereToCam = origin - s.pos;\n    float B = 2.0 * dot(sphereToCam, dir);\n    float C = dot(sphereToCam, sphereToCam) - s.radius * s.radius;\n    float Desc = B * B - 4.0 * C;\n    if (Desc < 0.0)\n        return FAR_INF;\n    float nearDist = (-B - sqrt(Desc)) / 2.0;\n    if (nearDist > 0.0)\n        return nearDist;\n    float farDist = (-B + sqrt(Desc)) / 2.0;\n    if (farDist > 0.0)\n        return farDist;\n    return FAR_INF;\n}\n\nfloat ray_sphere_intersection(vec3 sphPos, float radius, vec3 origin, vec3 dir) {\n    // length(origin + dir * t - s.pos) = radius\n    // dot(origin + dir * t - s.pos, origin + dir * t - s.pos) = radius ^2\n    // dot(origin - s.pos, origin - s.pos) + 2dot(origin - s.pos, dir)t + dot(dir, dir) * t^2 = radius^2\n    // dot(origin - s.pos, origin - s.pos) - radius^2 + 2dot(origin - s.pos, dir)t + t^2 = 0\n    vec3 sphereToCam = origin - sphPos;\n    float B = 2.0 * dot(sphereToCam, dir);\n    float C = dot(sphereToCam, sphereToCam) - radius * radius;\n    float Desc = B * B - 4.0 * C;\n    if (Desc < 0.0)\n        return FAR_INF;\n    float nearDist = (-B - sqrt(Desc)) / 2.0;\n    if (nearDist > 0.0)\n        return nearDist;\n    float farDist = (-B + sqrt(Desc)) / 2.0;\n    if (farDist > 0.0)\n        return farDist;\n    return FAR_INF;\n}\n\nfloat ray_triangle_intersection(Triangle t, vec3 origin, vec3 dir) {\n    // dot(origin + dir * d - t.pos[0], t.normal) == 0\n    // dot(origin - t.pos[0], t.normal) + dot(dir, t.normal) * d == 0\n    // d = dot(t.pos[0] - origin, t.normal) / dot(dir, t.normal);\n    float normalViewAngle = dot(dir, t.normal);\n    if (abs(normalViewAngle) < EPS)\n        return FAR_INF;\n    float d = dot(t.pos[0] - origin, t.normal) / normalViewAngle;\n    if (d < 0.0)\n        return FAR_INF;\n    vec3 hitPos = origin + dir * d;\n    vec3 edges[3] = vec3[3](\n        t.pos[1] - t.pos[0],\n        t.pos[2] - t.pos[1],\n        t.pos[0] - t.pos[2]\n    );\n    float square = length(cross(edges[0], edges[1]));\n    vec3 toHitVecs[3] = vec3[3](\n        hitPos - t.pos[0],\n        hitPos - t.pos[1],\n        hitPos - t.pos[2]\n    );\n    float testSq[3] = float[3](\n        length(cross(toHitVecs[0], edges[0])),\n        length(cross(toHitVecs[1], edges[1])),\n        length(cross(toHitVecs[2], edges[2]))\n    );\n    if (abs(square - testSq[0] - testSq[1] - testSq[2]) < EPS)\n        return d;\n    return FAR_INF;\n}\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\nconst mat3 ma = mat3( 0.60, 0.00,  0.80,\n                      0.00, 1.00,  0.00,\n                     -0.80, 0.00,  0.60 );\n\nvec4 map( in vec3 p )\n{\n    float d = sdBox(p,vec3(1.0));\n    vec4 res = vec4( d, 1.0, 0.0, 0.0 );\n\n    float ani = smoothstep( -0.2, 0.2, -cos(0.5*iTime) );\n  float off = 1.5*sin( 0.01*iTime );\n  \n    float s = 1.0;\n    for( int m=0; m<4; m++ )\n    {\n        p = mix( p, ma*(p+off), ani );\n     \n        vec3 a = mod( p*s, 2.0 )-1.0;\n        s *= 3.0;\n        vec3 r = abs(1.0 - 3.0*abs(a));\n        float da = max(r.x,r.y);\n        float db = max(r.y,r.z);\n        float dc = max(r.z,r.x);\n        float c = (min(da,min(db,dc))-1.0)/s;\n\n        if( c>d )\n        {\n          d = c;\n          res = vec4( d, min(res.y,0.2*da*db*dc), (1.0+float(m))/4.0, 0.0 );\n        }\n    }\n\n    return res;\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3  eps = vec3(.001,0.0,0.0);\n    vec3 nor;\n    nor.x = map(pos+eps.xyy).x - map(pos-eps.xyy).x;\n    nor.y = map(pos+eps.yxy).x - map(pos-eps.yxy).x;\n    nor.z = map(pos+eps.yyx).x - map(pos-eps.yyx).x;\n    return normalize(nor);\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n    vec4 res = vec4(-1.0);\n    vec4 h = vec4(1.0);\n    for( int i=0; i<64; i++ )\n    {\n    if( h.x<0.002 || t>10.0 ) break;\n        h = map(ro + rd*t);\n        res = vec4(t,h.yzw);\n        t += h.x;\n    }\n  if( t>10.0 ) res=vec4(-1.0);\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos = vec3(0, 0, -5);\n    \n    SPHERES[0].pos = vec3(0, sin(iTime) * 2.0, 4.0);\n    SPHERES[0].color = vec3(0x64, 0x56, 0x70) / 255.0;\n    SPHERES[0].radius = 0.5;\n    SPHERES[0].specular = 64.0;\n    SPHERES[1].pos = vec3(-1.5, sin(iTime + 3.14) * 2.0, 4);\n    SPHERES[1].color = vec3(0xd5, 0xb0, 0x8d) / 255.0;\n    SPHERES[1].radius = 0.5;\n    SPHERES[1].specular = 128.0;\n    SPHERES[2].pos = vec3(0, -1002, 0);\n    SPHERES[2].color = vec3(0xd5, 0xb0, 0x8d) / 255.0;\n    SPHERES[2].radius = 1000.0;\n    SPHERES[2].specular = 0.0;\n\n    TRIANGLES[0].pos = vec3[3](vec3(-5, -5, 10), vec3(-5, 5, 10), vec3(5, 5, 10));\n    TRIANGLES[0].color = vec3(0xba, 0x73, 0x38) / 255.0;\n    TRIANGLES[0].normal = vec3(0, 0, -1);\n    TRIANGLES[0].specular = 0.0;\n    TRIANGLES[1].pos = vec3[3](vec3(-5, -5, 10), vec3(5, 5, 10), vec3(5, -5, 10));\n    TRIANGLES[1].color = vec3(0xba, 0x73, 0x38) / 255.0;\n    TRIANGLES[1].normal = vec3(0, 0, -1);\n    TRIANGLES[1].specular = 0.0;\n    \n    vec3 SUN_DIR = normalize(vec3(1, -3, 1));\n    \n    const int SAMPLES_COUNT = 4;\n    vec3 fullLighting;\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.x;\n    vec3 viewVec = normalize(vec3(uv, 1.0));\n    fragColor = vec4(0.0);\n\n    float intersectionDist = FAR_INF;\n    vec3 intersectionColor;\n    vec3 intersectionPos;\n    vec3 intersectionNormal;\n    \n    vec2 screenUV = (fragCoord)/iResolution.xy;\n    vec4 gbuffer = texture(iChannel0, screenUV);\n    intersectionColor = vec3(\n        int(gbuffer.x) >> 16,\n        (int(gbuffer.x) >> 8) & 0xFF,\n        int(gbuffer.x) & 0xFF\n    ) / 255.0;\n    intersectionNormal.z = cos(gbuffer.z);\n    intersectionNormal.x = cos(gbuffer.y) * sin(gbuffer.z);\n    intersectionNormal.y = sin(gbuffer.y) * sin(gbuffer.z);\n    intersectionPos = cameraPos + gbuffer.w * viewVec;\n    \n    const int AO_SAMPLES = 64;\n    const float RADIUS = 0.5;\n    float ao = 0.0;\n    for (int i = 0; i < AO_SAMPLES; ++i) {\n        vec3 sampleDir = texture(iChannel1, vec2((float(i) + 0.5) / 64.0, 0.0)).xyz * 2.0 - 1.0;\n        if (dot(sampleDir, intersectionNormal) < 0.0) {\n            sampleDir = -sampleDir;\n        }\n        vec3 samplePos = intersectionPos + sampleDir * RADIUS;\n        vec3 toSample = samplePos - cameraPos;\n        float sampleDist = length(toSample);\n        vec3 toSampleViewVec = toSample / sampleDist;\n        vec2 sampleFrag = toSampleViewVec.xy * iResolution.x + iResolution.xy * 0.5;\n        vec2 screenUV = sampleFrag / iResolution.xy;\n        float z = texture(iChannel0, screenUV).w;\n        float rangeCheck = smoothstep(0.0, 1.0, RADIUS / abs(gbuffer.w - z));\n        ao += (z > sampleDist ? 0.0 : 1.0) * rangeCheck;\n    }\n    ao /= float(AO_SAMPLES);\n    ao = 1.0 - ao;\n    fragColor.x = ao;\n    return;\n\n    vec3 lighting = intersectionColor * SKY_COLOR * ao;\n\n    lighting += max(0.0, dot(intersectionNormal, -SUN_DIR)) * intersectionColor * ao;\n\n    fragColor.xyz = pow(lighting, vec3(1.0 / 2.2));\n    \n}","name":"Buffer B","description":"","type":"buffer"}]}