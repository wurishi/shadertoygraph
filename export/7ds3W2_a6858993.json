{"ver":"0.1","info":{"id":"7ds3W2","date":"1616602420","viewed":182,"name":"Complex Field Lines","username":"jllusty","description":"Field lines of two charges of opposite signs using a complex potential.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["complex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float pi = 4.0 * atan(1.0);\n\nvec2 mult(in vec2 a, in vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);\n}\n\n\nvec2 div(in vec2 a, in vec2 b) {\n    return mult(a,vec2(b.x,-b.y))/length(b);\n}\n\nvec2 clog(in vec2 z) {\n    return vec2(log(length(z)), atan(z.y, z.x));\n}\n\nvec2 func(in vec2 z) {\n    //return mult(z - vec2(2.0f, 0.0), div(vec2(1.0,0.0), z + vec2(sin(iTime), 0.0)));\n    return clog(z-vec2(-4.,1.)) + clog(z-vec2(0.,2.)) - mult(vec2(2.,0.), clog(z-vec2(2.,-2.)));\n}\n\nvec3 checkerboard(in vec2 uv) {\n    int parity = int(floor(uv.x)) + int(floor(uv.y));\n    if(parity % 2 == 0) {\n        return vec3(0.0);\n    }\n    else {\n        return vec3(1.0);\n    }\n}\n\n//float wrap(float x, float a) {\n//    return x - a * floor(x / a);\n//}\n\n\n// Smooth wrap.\nfloat wrap(float x, float a){\n    x -= a*floor(x/a);\n    // Smoothing factor.\n    const float sf = 16.; \n    // Rough smoothing.\n    return min(x, (1. - x)*x*16.);\n}\n\nfloat angdist(in float theta1, in float theta2) {\n    return wrap(theta2 - theta1 + pi, 2.0*pi) - pi;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 4.0*(2.0*fragCoord/iResolution.xy - 1.);\n    float aspect = iResolution.y/iResolution.x;\n    uv.x = uv.x/aspect;\n\n    // Save Pixel Position\n    vec2 pos = uv;\n\n    // Apply Function\n    uv = func(uv);\n    \n    // Get distance to closest arg(z)-isocurve\n    float n = 22.;\n    float arg = uv.y; //atan(uv.y, uv.x);\n    float gEps = 0.001;\n    float stretch = length(func(pos+vec2(gEps,gEps))-func(pos))/(sqrt(2.)*gEps);\n    float eps = 0.05;\n    float d = abs(fract(arg*n/(2.*pi)+.5)-.5)/stretch;\n    float r = length(uv);\n    //if (r >= 1.) d = d*r;\n    float c = 1. - smoothstep(eps, 2.*eps, d);\n    \n    //\n    float n1 = 22.;\n    float arg1 = uv.x-iTime/4.; //atan(uv.y, uv.x);\n    float gEps1 = 0.001;\n    float stretch1 = length(func(pos+vec2(gEps1,gEps1))-func(pos))/(sqrt(2.)*gEps1);\n    float eps1 = 0.05;\n    float d1 = abs(fract(arg1*n1/(2.*pi)+.5)-.5)/stretch1;\n    float r1 = length(uv);\n    //if (r >= 1.) d = d*r;\n    float c1 = 1. - smoothstep(eps1, 2.*eps1, d1);\n\n    // Stack onto Base Image (Contours)\n    //  background color\n    float bc = 1.0-wrap(length(uv.x-iTime),1.);\n    //  line color\n    c = max(c,c1);\n    vec3 lcol = vec3(1.0,0.0,0.0);\n    //vec3 col = (1.0 - c) * bcol + c * vec3(abs(sin(uv.x-iTime)), 0.0, 0.0);\n    vec3 col = vec3(0.);\n    if (bc > c) {\n        col = c*vec3(abs(sin(uv.x)),0.,0.);\n    } else {\n        col = bc*vec3(1.);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}