{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 Q = fragCoord / iResolution.y;\n    vec4 rec = texture(iChannel0, uv);\n    float d_seed = rec.x;\n    vec2 closest = rec.zw;\n    float t = rec.y;\n    float d = distance(closest, Q);\n    float ridgescale = 280.;\n    vec3 col = vec3(1.0) - sign(d)*viridis_quintic(t);\n    col *= (1.0 - exp(-4.0*abs(d))) * (0.8 + 0.2*cos(ridgescale*d));\n    col = mix(col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n        \n\n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(fract(closest*20.), col.x, 1.);\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"/*\nSpline optimization code detailed in https://www.shadertoy.com/view/4fyBDD\n\nHere I am trying to see if it's possible to use JFA to extract a clean distance function of a Bezier curve if I use the above optimization to\nseed the algorithm with initial \"close\" pixels that can be treated as being on the curve.\n\nIt looks like you can get away with as little as 2 Gauss Newton steps to find the \"near\" points to use as a seed for JFA to get\nnear-perfect results.\n*/\n\n\n#define NEWTON_STEPS 2\n#define DAMPING 0.0\n#define INTERVAL_FRAMES 120\n#define FRAMES_PER_JFA 5\n\n#define JFA_STEPS 10\n#define BUFFER_FRAMES 20\n#define SEED_THRESHOLD 0.002\n\nconst mat4 c_matrixCubicBez =\n    mat4(\n        1.0, 0.0,  0.0, 0.0,\n        -3.0,  3.0, 0.0,  0.0,\n\t\t3.0,  -6.0,  3.0, 0.0,\n        -1.0,  3.0,  -3.0,  1.0\n\t);\n    \nconst mat3x4 c_MatrixCubicBezDeriv = mat3x4(c_matrixCubicBez[1], c_matrixCubicBez[2] * 2., c_matrixCubicBez[3] * 3.);\nconst mat2x4 c_MatrixCubicBezSecondDeriv = mat2x4(c_matrixCubicBez[2] * 2., c_matrixCubicBez[3] * 6.);\n\nvec2 bezierSecondDerivative(in mat4x2 V, in float t) {\n    vec2 poly = vec2(1., t);\n    return V * c_MatrixCubicBezSecondDeriv * poly;\n}\n\nvec2 bezierDerivative(in mat4x2 V, in float t) {\n    vec3 poly = vec3(1., t, t*t);\n    return V * c_MatrixCubicBezDeriv * poly;\n}\n\nvec2 bezier(in mat4x2 V, in float t) {\n    vec4 poly = vec4(1., t, t*t, t*t*t);\n    return V * c_matrixCubicBez * poly;\n}\n\n\nfloat gaussNewton(in vec2 Q, in mat4x2 V) {\n    float t = 0.5;\n    \n    for (int i=0; i<NEWTON_STEPS; ++i) {\n        vec2 B = bezier(V, t);\n        vec2 Bprime = bezierDerivative(V, t);\n        \n        float denom = dot(Bprime, Bprime);\n        float num = dot(Bprime, B-Q);\n        t -= num / (denom + DAMPING);\n        t = clamp(t, 0., 1.);\n    }\n    \n    return t;\n}\n\n\n// d'image\n\n\nfloat timenoise_interp(int seed) {\n    float newtime = iTime;\n    float t = fract(newtime);\n    int t0 = int(floor(newtime));\n    int t1 = int(ceil(newtime));\n    float val0 = pcg2d(uvec2(t0, seed)).x;\n    float val1 = pcg2d(uvec2(t1, seed)).x;\n    float tt = smoothstep(1., 0., t);\n    return tt * val0 + (1.-tt) * val1;\n}\n\nfloat timenoise(int seed) {\n    return pcg2d(uvec2(iFrame / INTERVAL_FRAMES, seed)).x;\n}\n\nvec4 compare(vec4 rec1, vec4 rec2, in vec2 Q) {\n    float d1 = distance(rec1.zw, Q);\n    float d2 = distance(rec2.zw, Q);\n    float sneed = step(rec2.x, SEED_THRESHOLD);\n    float newseed = min(rec1.x, rec2.x);\n    rec2.x = d2;\n    return vec4(newseed, mix(rec1.yzw, rec2.yzw, step(d2, d1) * sneed));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    int periodFrame = iFrame % INTERVAL_FRAMES;\n    if (periodFrame < BUFFER_FRAMES) {\n        float horizscale = 2.;\n        float vertscale = 2.;\n        mat4x2 points = mat4x2(timenoise(1) / horizscale, timenoise(2) * vertscale,\n                                (timenoise(3) + 1.) /horizscale, timenoise(4) * vertscale,\n                                (timenoise(5) + 2.) /horizscale, timenoise(6) * vertscale,\n                                (timenoise(7) + 3.) /horizscale, timenoise(8) * vertscale);\n        float zoom = 0.25;\n        vec2 center = vec2(0.8, 0.5);\n        for (int i=0; i<4; ++i) {\n            points[i] -= center;\n            points[i] *= zoom;\n            points[i] += center;\n        }\n        vec2 Q = fragCoord / iResolution.y;\n\n        float t = gaussNewton(Q, points);\n        vec2 closest = bezier(points, t);\n        float d = distance(closest, Q);\n        fragColor = vec4(d, t, closest);\n        \n    } else if (periodFrame < BUFFER_FRAMES + JFA_STEPS * FRAMES_PER_JFA && (periodFrame-BUFFER_FRAMES) % FRAMES_PER_JFA == 0) {\n        vec2 Q = fragCoord / iResolution.y;\n        int jfa_index = (periodFrame - BUFFER_FRAMES) / FRAMES_PER_JFA + 1;\n        float jump = 1./float(1 << jfa_index);\n        \n        vec4 smear = texture(iChannel0, uv);\n        \n        for (int i=-1; i<=1; ++i) {\n            for (int j=-1; j<=1; ++j) {\n                if (i == 0 && j == 0) continue;\n                vec2 curroffset = vec2(0);\n                curroffset[0] = float(i);\n                curroffset[1] = float(j);\n                curroffset *= jump;\n                vec2 jumpUV = uv + curroffset;\n                if (all(lessThan(jumpUV, vec2(1.))) && all(greaterThan(jumpUV, vec2(0.)))) {\n                    vec4 other = textureLod(iChannel0, uv + curroffset, 0.);\n                    smear = compare(smear, other, Q);\n                }\n            }\n        }\n        \n        fragColor = smear;\n        \n    } else {\n        fragColor = texture(iChannel0, uv);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"outputs":[],"inputs":[],"code":"vec3 viridis_quintic( float x )\n{\n\tx = clamp( x, 0.,1. );\n\tvec4 x1 = vec4( 1.0, x, x * x, x * x * x ); // 1 x x2 x3\n\tvec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7\n\treturn vec3(\n\t\tdot( x1.xyzw, vec4( +0.280268003, -0.143510503, +2.225793877, -14.815088879 ) ) + dot( x2.xy, vec2( +25.212752309, -11.772589584 ) ),\n\t\tdot( x1.xyzw, vec4( -0.002117546, +1.617109353, -1.909305070, +2.701152864 ) ) + dot( x2.xy, vec2( -1.685288385, +0.178738871 ) ),\n\t\tdot( x1.xyzw, vec4( +0.300805501, +2.614650302, -12.019139090, +28.933559110 ) ) + dot( x2.xy, vec2( -33.491294770, +13.762053843 ) ) );\n}\n\n//https://www.shadertoy.com/view/XlGcRh\nvec2 pcg2d(in uvec2 v)\n{\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return vec2(v) * (1.0/float(0xffffffffu));\n}","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"lfyBRy","date":"1734168786","viewed":133,"name":"Spline w/ Jump Flooding","username":"ShnitzelKiller","description":"Using Jump Flooding algorithm to compute the distance to a Bezier spline, seeded using an approximation computed with a few Gauss-Newton steps to find points close to the spline.","likes":2,"published":3,"flags":32,"usePreview":0,"tags":["bezier","spline","newton","jumpflooding"],"hasliked":0,"parentid":"","parentname":""}}