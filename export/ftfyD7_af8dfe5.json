{"ver":"0.1","info":{"id":"ftfyD7","date":"1648101520","viewed":111,"name":"Oklab Testing","username":"vega","description":"Trying to get a grasp on how oklab handles hue and saturation controls. I think what I have here is wrong, but at least it's close...?","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["oklab"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// license CC0 (public domain)\n// https://creativecommons.org/share-your-work/public-domain/cc0/\n\n//////////////////////////////////////////////////////////////////////\n// sRGB color transform and inverse from \n// https://www.shadertoy.com/view/WtccD7 which is from\n// https://bottosson.github.io/posts/colorwrong/#what-can-we-do%3F\n// though still CC0 (public domain) so all good.\n\n//lsrgb = linear srgb, as required by the oklab\nvec3 srgb_from_lsrgb(vec3 x) {\n\n    vec3 xlo = 12.92*x;\n    vec3 xhi = 1.055 * pow(x, vec3(0.4166666666666667)) - 0.055;\n    \n    return mix(xlo, xhi, step(vec3(0.0031308), x));\n\n}\n\nvec3 lsrgb_from_srgb(vec3 x) {\n\n    vec3 xlo = x / 12.92;\n    vec3 xhi = pow((x + 0.055)/(1.055), vec3(2.4));\n    \n    return mix(xlo, xhi, step(vec3(0.04045), x));\n\n}\n\n// Modified slightly From the Oklab post @ https://bottosson.github.io/posts/oklab/\n// to actually be GLSL\n\nvec3 lsrgb_to_oklab(vec3 c) \n{\n  float l = 0.4122214708 * c.r + 0.5363325363 * c.g + 0.0514459929 * c.b;\n  float m = 0.2119034982 * c.r + 0.6806995451 * c.g + 0.1073969566 * c.b;\n  float s = 0.0883024619 * c.r + 0.2817188376 * c.g + 0.6299787005 * c.b;\n  \n  //  Cube root each\n  float l_ = pow(l, 1./3.);\n  float m_ = pow(m, 1./3.);\n  float s_ = pow(s, 1./3.);\n  \n  vec3 result;\n\n  result.r = 0.2104542553*l_ + 0.7936177850*m_ - 0.0040720468*s_;\n  result.g = 1.9779984951*l_ - 2.4285922050*m_ + 0.4505937099*s_;\n  result.b = 0.0259040371*l_ + 0.7827717662*m_ - 0.8086757660*s_;\n  \n  return result;\n}\n\nvec3 oklab_to_lsrgb(vec3 c) \n{\n    float l_ = c.x + 0.3963377774 * c.y + 0.2158037573 * c.z;\n    float m_ = c.x - 0.1055613458 * c.y - 0.0638541728 * c.z;\n    float s_ = c.x - 0.0894841775 * c.y - 1.2914855480 * c.z;\n\n    float l = l_*l_*l_;\n    float m = m_*m_*m_;\n    float s = s_*s_*s_;\n\n    vec3 result;\n    \n\tresult.r = +4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s;\n\tresult.g = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s;\n\tresult.b = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s;\n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    //Convert to linear srgb\n    vec3 lsrgb = lsrgb_from_srgb(col);\n    //Then to oklab\n    vec3 oklab = lsrgb_to_oklab(lsrgb);\n    \n    // Do processing in Oklab space here\n    float lightness = sin(iTime)/2.+.5; //first component is lightness (how bright?) 0 to 1\n    // keep in mind, this space is perceptual, so a deep red, when made lighter, will go orange-y\n    // yellow to get brighter\n    \n    //second componet is how green/red the color is  -.5` to .5\n    //third componet is how blue/yellow the color is -.5 to .5\n    // This is incovinent though, so to get our normal hue & saturation control we can do:\n    float hue = atan(oklab.y,oklab.z);\n    float sat = sqrt(oklab.y*oklab.y+oklab.z*oklab.z);\n    \n    //sat = 1.0;\n    //hue = iTime;\n    \n    oklab.y = sat * sin(hue);\n    oklab.z = sat * cos(hue);\n    \n    oklab.x = lightness;\n    \n    // Go back from oklab to linear srgb\n    vec3 lsrgbret = oklab_to_lsrgb(oklab);\n    // Then back from linear srgb to normal rgb\n    vec3 rgbret = srgb_from_lsrgb(lsrgbret);\n    fragColor = vec4(rgbret, 1.0);\n}","name":"Image","description":"","type":"image"}]}