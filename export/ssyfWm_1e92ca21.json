{"ver":"0.1","info":{"id":"ssyfWm","date":"1658325610","viewed":129,"name":"Hex tiles nearest path ?","username":"EisernSchild","description":"Trying to find nearest path on hex tile field. Second approach (green) should be the right one.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["math","hexagonal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Hex tiles nearest path ?\n// Copyright Â© 2022 by Denis Reischl\n// \n// SPDX-License-Identifier: MIT\n// \n// based on\n// \"Storage and addressing scheme for\n// practical hexagonal image processing\"\n// by Xiangguo Li\n//\n// and:\n// https://www.redblobgames.com/grids/hexagons/\n\n#define PI        3.141592654f\n#define PI2       6.283185307f\n#define PI_RC     0.318309886f\n#define PI2_RC    0.159154943f\n#define PIDIV2    1.570796327f\n#define PIDIV4    0.785398163f\n\n/// Cartesian to hex coordinates\nvec2 HexUV(vec2 vXy)\n{\n\t// hex coords       (u, v) = (          .5 * x + .5 * y,        y ) \n\t// hex coord scaled (u, v) = ((sqrt(3.f) * x + y) / 3.f, y / 1.5f )\n\treturn vec2( (sqrt(3.f) * vXy.x + vXy.y) / 3.f, vXy.y / 1.5f );\n}\n\n/// Hex to cartesian coordinates\nvec2 HexXY(vec2 vUv)\n{\n\t// get cartesian coords\n\treturn vec2( (vUv.x * 3.f - vUv.y * 1.5f) / sqrt(3.f), vUv.y * 1.5f );\n}\n\n// Orthographic projection : ba = (b.an)an\nvec2 ortho_proj(vec2 vA, vec2 vB)\n{\n    vec2 vAn = normalize(vA);\n    return dot(vB, vAn) * vAn;\n}\n\n// rotate 2D\nvec2 rotate(vec2 vV, float fA) \n{\n\tfloat fS = sin(fA);\n\tfloat fC = cos(fA);\n\tmat2 mR = mat2(fC, -fS, fS, fC);\n\treturn mR * vV;\n}\n\n// signed distance methods by iq\n// https://iquilezles.org/articles/distfunctions2d/\n// SPDX-License-Identifier: MIT\n//\nfloat dot2(in vec2 v ) { return dot(v,v); }\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return length(p)-r;\n}\nfloat sdRoundedX( in vec2 p, in float w, in float r )\n{\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5) - r;\n}\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n\n\tp.x = abs(p.x);\n    vec2 ca = vec2(max(0.0,p.x-((p.y<0.0)?r1:r2)), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    \n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// background helper\nfloat SimpleFloor(vec2 vPos)\n{\n\tfloat fH = 1.0;\n\tfH -= (max(sin(vPos.x * .5 + PI * .5) + cos(vPos.y * .5 - PI * 2.), 1.25) - 2.0) * 0.25;\n\treturn fH;\n}\n\n\nvoid mainImage( out vec4 cOut, in vec2 vXy )\n{\n    // get next v tile vector (absolut), get constant hex tile distance\n    vec2 vNext = HexXY(vec2(1., 1.));\n    float fTD = length(vNext);\n    \n    // get pixel coordinates, scale\n    vec2 vPt = ((vXy/iResolution.xy) - .5f) * (iResolution.xy / iResolution.y);\n    vPt *= 2. * PI2 + sin(iTime);\n    \n    // get approx. hexagonal center coords\n    vec2 vUvC = round(HexUV(vPt));\n        \n    // get approx. cartesian hex center\n    vec2 vPtC = HexXY(vUvC);\n    \n    // get local coords absolut, adjust x\n    vec2 vPtLc = abs(vPt - vPtC);\n    if (vPtLc.x > (fTD * .5)) vPtLc.x = fTD - vPtLc.x;\n    \n    // project point on constant tile vector\n    vec2 vPtN = ortho_proj(vNext, vPtLc);\n    \n    // get distance, adjust again\n    float fD = max(vPtLc.x, length(vPtN));\n    if (fD > (fTD * .5)) fD = fTD - fD;\n    \n    // draw background\n\tfloat fBg = SimpleFloor(vPt * 40.f);\n    cOut = mix(vec4(.2, .2, .2, 1.), vec4(.9, .8, 1., 1.), fBg);\n    \n    // draw hex grid on background\n    cOut = mix(cOut, vec4(1.,.5, .5, 1.), smoothstep(0.8, 0.85, fD));\n            \n    // draw 2 sample pegs in hexagonal space\n    vec2 vAA, vA = vAA = vec2(floor(mod(-iTime, 8.)) - 4., -3.), \n         vB = vec2(floor(mod( iTime, 6.)) - 3., 3.);\n         \n    float fDi = sdTrapezoid(vPt - HexXY(vA), 0.3, 0.2, 0.6 );\n    if (fDi < 0.)\n        cOut = mix(vec4(.9, .8, 1., 1.), vec4(0., 0., 0.7, 1.), 2. * (1.0 - exp(-6.0*abs(fDi))));\n    fDi = sdTrapezoid(vPt - HexXY(vB), 0.3, 0.2, 0.6 );\n    if (fDi < 0.)\n        cOut = mix(vec4(.9, .8, 1., 1.), vec4(.7, .7, 0., 1.), 2. * (1.0 - exp(-6.0*abs(fDi))));\n    \n    // try to find nearest path.. \n    \n    // 1. approach : follow x/u axis first\n    vA = vAA;\n    while ((vA.x != vB.x) || (vA.y != vB.y))\n    {\n        vec2 vC = vB - vA;\n        // prefer x/u axis\n        if (abs(vC.x) > 0.0)\n            vA.x += sign(vC.x);\n        else\n            vA.y += sign(vC.y);\n        \n        if ((vA.x != vB.x) || (vA.y != vB.y))\n        {\n            fDi = sdRoundedX(vPt - HexXY(vA), 0.25, 0.1 );\n            if (fDi < 0.)\n                cOut = vec4(1., .0, 0., 1.) * 2. * (1.0 - exp(-6.0*abs(fDi)));\n        }\n    }\n    \n    // 2. approach : try 3 (axes (0 1) (1 0) (1 1)\n    vA = vAA;\n    while ((vA.x != vB.x) || (vA.y != vB.y))\n    {\n        vec2 vC = vB - vA;\n        // (1 1)\n        if ( (abs(vC.x) == abs(vC.y)) && (sign(vC.x) == sign(vC.y)))\n            vA += sign(vC);\n        // (1 0)\n        else if (abs(vC.x) > abs(vC.y))\n            vA.x += sign(vC.x);\n        // (0 1)\n        else\n            vA.y += sign(vC.y);\n        \n        if ((vA.x != vB.x) || (vA.y != vB.y))\n        {\n            fDi = sdRoundedX(vPt - HexXY(vA), 0.25, 0.1 );\n            if (fDi < 0.)\n                cOut = vec4(.0, 1., 0., 1.) * 2. * (1.0 - exp(-6.0*abs(fDi)));\n        }\n    }\n        \n    // vignette\n    vec2 vUvN = vXy/iResolution.xy - .5;\n    float fVignette = length(vUvN) * 2.4 - (abs(vUvN.x) + abs(vUvN.y)) * .7;\n    cOut = mix(cOut, vec4(0., 0., 0., 1.), smoothstep(0.7, 1.2, fVignette));\n}","name":"Image","description":"","type":"image"}]}