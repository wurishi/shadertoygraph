{"ver":"0.1","info":{"id":"NdlGRN","date":"1615667050","viewed":95,"name":"Interleave sampling","username":"clem494949","description":"I'm trying to implement the interleave sampling from this paper: \"Global Illumination Optimization: Integrating Interleaved Sampling into\nReflective Shadow Maps and Splatting Indirect Illumination.\"","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["sampling","interleave","rsm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fourth step: process interleave sampling in each quadrant\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 quad = step(0.5, uv);\n    vec2 subquad = step(0.5, fract(uv*2.0));\n    // I don't know how to make it works with a screen res non-multiple of 4\n    // This fixes it partially\n    vec2 resNotMultipleOf4 = fract(iResolution.xy/4.0)*2.0;\n    vec2 fixedRes = iResolution.xy - 2.0*resNotMultipleOf4;\n    vec2 quarterScreen = 0.25*fixedRes/iResolution.xy;\n    \n    vec3 cmpCol = texture(iChannel1, uv).rgb;\n    \n    // Zoom out\n    uv = floor(fragCoord)/2.0/iResolution.xy;\n    // One pixel offset depending on the subquadrant\n    //uv -= subquad/iResolution.xy;\n    // Texture sampling offset\n    //uv -= quarterScreen/iResolution.xy;\n    // Sample from the corresponding quadrant\n    uv += quarterScreen * quad;\n    uv += quarterScreen * mod(floor(fragCoord),2.0);\n\n    // Snap de l'uv sur la grille\n    uv = floor(iResolution.xy*uv) / iResolution.xy + 0.5/iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n    fragColor = vec4(col.rgb,1.0);\n    //fragColor = vec4(abs(col-cmpCol).rgb,1.0);\n    //fragColor = vec4(floor(mod(uv*iResolution.xy,2.0)).xyy,1.0);\n    //fragColor = vec4(floor(mod(uv*fixedRes,2.0)).xyy,1.0);\n    //fragColor = vec4(uv.xyy,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Generate a testing texture\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.0);\n    // Colors to make sure the right pixel is sample\n    col.r = floor(mod(fragCoord.x, 2.0));\n    col.g = floor(mod(fragCoord.y, 2.0));\n    // Repeating pattern to make sure the image is reconstructed\n    col.b = mod(length(fragCoord-iResolution.xy/2.0)/iResolution.x*8.8, 1.0);\n    fragColor = vec4(col, 1.0);\n    //fragColor = vec4(uv.xxy, 1.0);\n    //fragColor = vec4(vec3(hash(uv)), 1.0);\n    //fragColor = vec4(sin(uv.x), cos(uv.y), 0.0, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// First step: process interleave sampling in each quadrant\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 quad = step(0.5, uv);\n    vec2 subquad = step(0.5, fract(uv*2.0));\n    // I don't know how to make it works with a screen res non-multiple of 4\n    // This fixes it partially\n    vec2 resNotMultipleOf4 = fract(iResolution.xy/4.0)*2.0;\n    vec2 fixedRes = iResolution.xy - 2.0*resNotMultipleOf4;\n    vec2 halfScreen = 0.5*fixedRes/iResolution.xy;\n    \n    // Zoom in\n    uv = floor(fragCoord)*2.0/iResolution.xy;\n    // One pixel offset depending on the subquadrant\n    uv += subquad/iResolution.xy;\n    // Texture sampling offset\n    uv += halfScreen/iResolution.xy;\n    // Repeat image\n    uv = mod(uv, halfScreen);\n    // Sample from the corresponding quadrant\n    uv += halfScreen*quad;\n\n    // Snap de l'uv sur la grille\n    uv = floor(iResolution.xy*uv) / iResolution.xy + 0.5/iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n    fragColor = vec4(col.rgb,1.0);\n    //fragColor = vec4(floor(mod(uv*iResolution.xy,2.0)).xyy,1.0);\n    //fragColor = vec4(floor(mod(uv*fixedRes,2.0)).xyy,1.0);\n    //fragColor = vec4(uv.xyy,1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Second step: reorder the areas\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 quad = step(0.5, uv);\n    vec2 subquad = step(0.5, fract(uv*2.0));\n    \n    uv = mod(uv, 0.25);\n    // set the quadrant to the subquadrant index\n    uv += 0.5*subquad;\n    // set the subquadrant to the quadrant index\n    uv += 0.25*quad;\n    \n    // Snap de l'uv sur la grille\n    uv = floor(iResolution.xy*uv) / iResolution.xy + 0.5/iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n    fragColor = vec4(col.rgb,1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Third step: reorder back the areas (same operation because it's an index swap)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 quad = step(0.5, uv);\n    vec2 subquad = step(0.5, fract(uv*2.0));\n    \n    uv = mod(uv, 0.25);\n    // set the quadrant to the subquadrant index\n    uv += 0.5*subquad;\n    // set the subquadrant to the quadrant index\n    uv += 0.25*quad;\n    \n    // Snap de l'uv sur la grille\n    uv = floor(iResolution.xy*uv) / iResolution.xy + 0.5/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).rgb;\n    fragColor = vec4(col.rgb,1.0);\n}","name":"Buffer D","description":"","type":"buffer"}]}