{"ver":"0.1","info":{"id":"XtdyWn","date":"1532227866","viewed":434,"name":"A Shiny Thingy","username":"Veggiebob","description":"reflections on a thingy! (my first reflections and usage of cubemaps so im happy :) :) :) ) Mouseable.","likes":10,"published":3,"flags":0,"usePreview":0,"tags":["mouse","sdf","cubemap","normal","reflect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define roughness 1. // between 0 and 1\n#define bigness 0.1\n#define EPSILON pow(10., -4.)\nfloat align (float diff, float dim){\n    if(diff>=dim){\n        return diff-dim;\n    } else {\n        return 0.;\n    }\n}\nfloat box3D (vec3 boxPos, vec3 boxSize, vec3 pos){\n    float n = align(abs(pos.x-boxPos.x), boxSize.x)+align(abs(pos.y-boxPos.y), boxSize.y);\n    n+=align(abs(pos.z-boxPos.z), boxSize.z);//just to keep the lines short\n    return n;\n}\nfloat sphere (vec3 spherePos, vec3 pos, float radius){\n    return length(pos-spherePos)-radius;\n}\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\nfloat sq (float x){\n    return x*x;\n}\nvec3 fractalColor (vec3 p, float iters){\n    vec3 c = texture(iChannel1, p).rgb;\n    for(float i = 0.; i<iters; i++){\n        c+=texture(iChannel1, p*pow(2., i)).rgb*pow(0.8, i);\n    }\n    return c;\n}\nvec2 rotate2D (vec2 p, float angle){\n    return vec2(p.x*cos(angle)-p.y*sin(angle), p.y*cos(angle)+p.x*sin(angle));\\\n}\nfloat SDF (vec3 p){\n    \n    p.xy = rotate2D(p.xy, p.z*5.+iTime);\n    p.xz = rotate2D(p.xz, p.y*5.+iTime);\n    float rad = bigness*sqrt(2.);\n    float d1 = sphere(vec3(0.), p, rad);\n    float d2 = box3D(vec3(0.), vec3(bigness)*0.36, p)-0.1;\n    float dP = d2;//cube with rounded corners\n    dP = max(dP, -sphere(vec3(0.), p, bigness*1.3));//cutout a sphere on the inside\n    float dp = 0.;\n    for(int i = 0; i<0; i++){\n        float inc = float(i);\n        vec3 pos = vec3(sin(iTime+inc), cos(iTime+inc), sin((iTime+inc)*2.));\n        float d = length(p-pos);\n        dp+=bigness*0.1/sq(d);\n        float smallSphere = sphere(pos*bigness*0.5*sq(sin(iTime*0.1)), p, bigness*0.1);\n    \tdP = min(dP, smallSphere);\n    }\n    \n   \t//optional distortion\n    dP+=length(fractalColor(p*20., 3.))*0.0001*roughness;\n    return dP;\n\t\n    //return sdCone(p, vec2(1., 1.));\n}\nvec4 trace (vec3 o, vec3 r) {\n    float t = 0.;\n    vec3 p = o;\n    for(int i = 0; i<64; i++){\n        p = o+r*t;\n        float d = SDF(p);\n        t+=d*0.5;\n    }\n    return vec4(p, t);\n}\n//Credit to Jamie Wong http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#surface-normals-and-lighting\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        SDF(vec3(p.x + EPSILON, p.y, p.z)) - SDF(vec3(p.x - EPSILON, p.y, p.z)),\n        SDF(vec3(p.x, p.y + EPSILON, p.z)) - SDF(vec3(p.x, p.y - EPSILON, p.z)),\n        SDF(vec3(p.x, p.y, p.z  + EPSILON)) - SDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\nfloat bright (vec3 c){\n    return dot(c, vec3(1.))/3.;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 mouse = iMouse.xy/iResolution.xy - vec2(0.5, 0.);\n    if(iMouse.xy == vec2(0.))mouse = vec2(0.5, 0.);\n    mouse.x*=5.;\n    mouse.y*=2.;\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv-=0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    float groundHeight = 0.;\n    float angle = mouse.x;\n    float fov = 0.5;\n    float camDist = mouse.y-0.1;\n    vec3 camera = vec3(cos(mouse.x)*camDist, 0., sin(mouse.x)*camDist);\n    vec3 ray = vec3(-cos(mouse.x+uv.x*fov)*2., uv.y, -sin(mouse.x+uv.x*fov)*2.);\n    ray = normalize(ray);\n    \n    vec4 v = trace(camera, ray);\n    vec3 col = vec3(0.);//fractalColor(v.xyz, 5.);//fractalize\n    //col*=1./length(col);//normalize\n    //vec3 randomize = fractalColor(v.xyz*1., 3.);//texture(iChannel1, v.xyz*10.).xyz-0.5; \n    vec3 normal = estimateNormal(v.xyz);\n    vec3 newRay = reflect(ray, normal);\n    col = texture(iChannel0, newRay).rgb;//+vec3(0., 0., 0.3);\n\tfloat fog = 1./(1.+pow(v.w, 10.)*0.1);\n    vec3 background = texture(iChannel0, ray).rgb;\n    col=col*fog+(1.-fog)*background;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}