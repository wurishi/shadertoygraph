{"ver":"0.1","info":{"id":"llsBD2","date":"1513465840","viewed":349,"name":"Fruit pattern 2D","username":"OskarSwierad","description":"A procedural 2D pattern of different fruit types, in a minimal vector/poster style","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["procedural","animation","distance","vector","fruit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI4 12.566370614359172\n#define PI_HALF 1.5707963267948966\n\nconst float fruitTiling = 4.0;\nconst float fruitDistanceThreshold = 0.45;\nconst float fruitTypeAnimSpeed = 1.2;\nconst float fruitTypeAnimHardness = 4.5;\nconst float edgeSoftness = 0.003;\nconst float backgroundSpeed = 0.03;\nconst float backgroundTiling = 10.0;\n\nconst vec3 colorBg[3] = vec3[](\n    vec3(0.162, 0.557, 0.096), // Apple\n    vec3(0.136, 0.483, 0.797), // Banana\n    vec3(0.010, 0.345, 0.760)  // Orange\n);\nconst vec3 colorPeel[3] = vec3[](\n\tvec3(0.406, 0.004, 0.008),\n    vec3(0.615, 0.311, 0.006),\n    vec3(0.714, 0.083, 0.0)\n);\nconst vec3 colorPulp[3] = vec3[](\n\tvec3(0.964, 0.727, 0.321),\n    vec3(0.917, 0.770, 0.215),\n    vec3(0.823, 0.313, 0.030)\n);\nconst vec3 colorSeeds[3] = vec3[](\n    vec3(0.031, 0.009, 0.003),\n    vec3(0.167, 0.092, 0.042),\n    vec3(0.974, 0.800, 0.249)\n);\n\nconst vec3 seedsCountFirstLast[3] = vec3[](\n    vec3(8.0, 5.0, 7.0),\n    vec3(5.0, 0.0, 5.0),\n    vec3(7.0, 0.0, 6.0)\n);\nvec3 seedsStartLengthThickness[3] = vec3[](\n    vec3(0.2, 0.2, 0.9),\n    vec3(0.15, 0.1, 0.6),\n    vec3(0.2, 0.2, 0.6)\n);\n\nvec3 mixThree(in vec3 valA, in vec3 valB, in vec3 valC, in float factor)\n{\n    vec2 twoFactors = vec2(factor) * 2.0 - vec2(0.0, 1.0);\n    twoFactors = clamp(twoFactors, vec2(0.0), vec2(1.0));\n    if (twoFactors.y > 0.0)\n    {\n        return mix(valB, valC, twoFactors.y);\n    }\n    else\n    {\n        return mix(valA, valB, twoFactors.x);\n    }\n}\n\nvec3 mixThree(in vec3[3] values, in float factor)\n{\n    vec2 twoFactors = vec2(factor) * 2.0 - vec2(0.0, 1.0);\n    twoFactors = clamp(twoFactors, vec2(0.0), vec2(1.0));\n    if (twoFactors.y > 0.0)\n    {\n        return mix(values[1], values[2], twoFactors.y);\n    }\n    else\n    {\n        return mix(values[0], values[1], twoFactors.x);\n    }\n}\n\nfloat remapClamped(in float rangeMin, in float rangeMax, in float newRangeMin, in float newRangeMax, in float value)\n{\n    float newVal = clamp((value - rangeMin) / (rangeMax - rangeMin), 0.0, 1.0);\n    return mix(newRangeMin, newRangeMax, newVal);\n}\n\n\nfloat polarAngle01(in vec2 uv)\n{\n    float angle = atan(uv.x, uv.y);\n    angle = remapClamped(-PI, PI, 0.0, 1.0, angle);\n    return angle;\n}\n\nvec3 background(in vec2 uv, in float fruitType)\n{\n    vec2 bgUV = uv + vec2(iTime * backgroundSpeed);\n    bgUV = (bgUV - vec2(0.5)) * backgroundTiling;\n    \n    bgUV = fract(bgUV) + vec2(0.5);\n    bgUV = floor(bgUV);\n    float mask = bgUV.x + bgUV.y;\n    mask = ceil(clamp(mask, 0.0, 1.0)) - floor(mask * 0.5);\n    mask = clamp(mask, 0.0, 1.0);\n    \n    vec3 bg = mixThree(colorBg, fruitType);\n    bg = mix(bg, vec3(0.8) * bg, mask);\n    return bg;\n        \n}\n\nvec2 appleSpace(in vec2 uv)\n{\n    // \"Perspective\" scaling. Apple I want to form is more conical than spherical\n \tfloat scaleOverV = remapClamped(-0.5, 0.4, 0.9, 1.6, uv.y);\n    vec2 outUV = uv * vec2(scaleOverV, 1.0);\n    \n    // Making it concave at the \"poles\"\n    float shape = cos(polarAngle01(uv) * PI4 + PI);\n    shape = remapClamped(-1.0, 1.0, 0.0, 1.0, shape);\n    shape = pow(shape, 0.25);\n    shape = remapClamped(0.0, 1.0, 1.5, 1.0, shape);\n    outUV *= vec2(shape);\n    \n    return outUV;\n}\n\nvec2 bananaSpace(in vec2 uv)\n{\n    // Squeezing the circle to a 6-sided polygon\n    const float sides = 6.0;\n    float shape = cos(polarAngle01(uv) * sides * PI2 + PI);\n    shape = remapClamped(-1.0, 1.0, 0.0, 1.0, shape);\n    shape = pow(shape, 1.4);\n    shape = remapClamped(0.0, 1.0, 1.1, 1.0, shape);\n    \n    // Blending back to a circle slightly\n    vec2 outUV = mix(uv, uv * vec2(shape), 0.5);\n    outUV *= vec2(1.4); // Making it smaller\n    return outUV;\n}\n\nvec2 orangeSpace(in vec2 uv)\n{\n    return uv * vec2(1.08);\n}\n\nfloat seeds(in vec2 uv, in float fruitType)\n{\n    // Offset V for apple seeds\n    float appleFactor = 1.0 - clamp(fruitType * 2.0, 0.0, 1.0);\n    uv.y += 0.077 * appleFactor;\n    \n    vec3 seedCount = mixThree(\n        seedsCountFirstLast,\n        fruitType\n    );\n    \n    vec3 seedSize = mixThree(\n        seedsStartLengthThickness,\n        fruitType\n    );\n    \n    vec2 polar = vec2(\n        fract(polarAngle01(uv) + 0.25) * seedCount.x,\n        distance(uv, vec2(0.0))\n    ); \n    \n    float seedsU = abs(fract(polar.x) - 0.5) / seedSize.z;\n    float seedsV = remapClamped(\n        seedSize.x - seedSize.y,\n        seedSize.y,\n        0.0,\n        1.0,\n        polar.y\n    );\n    vec2 seedsUV = vec2(seedsU, seedsV);\n    \n    float shape = distance(seedsUV, vec2(0.0, 0.5));\n    \n    vec2 masks = vec2(polar.x + 1.0);\n    masks = floor(masks - seedCount.yz);\n    masks = clamp(masks, vec2(0.0), vec2(1.0));\n    float seedMask = masks.x * (1.0 - masks.y);\n        \n    shape = smoothstep(\n        0.295 + edgeSoftness * 2.0,\n        0.295 - edgeSoftness * 2.0,\n        shape\n    );\n    return shape * seedMask;\n}\n\nfloat calcFruitType()\n{\n    float fruit = iTime * fruitTypeAnimSpeed;\n    vec2 waves = vec2(fruit) + vec2(0.0, PI_HALF);\n    waves = vec2(\n        sin(waves.x),\n        sin(waves.y)\n    );\n    waves *= fruitTypeAnimHardness;\n    waves = clamp(waves, -1.0, 1.0);\n    fruit = waves.x + waves.y;\n    fruit = smoothstep(-2.0, 2.0, fruit);\n    return fruit;\n}\n\nvec2 calcFruitUV(in vec2 uv, in float fruitType)\n{\n    vec2 twoFactors = vec2(fruitType) * 2.0 - vec2(0.0, 1.0);\n    twoFactors = clamp(twoFactors, vec2(0.0), vec2(1.0));\n    if (twoFactors.y > 0.0)\n    {\n        vec2 outUV = mix(\n            bananaSpace(uv),\n            orangeSpace(uv),\n            twoFactors.y\n        );\n        return outUV;\n    }\n    else\n    {\n        vec2 outUV = mix(\n            appleSpace(uv),\n            bananaSpace(uv),\n            twoFactors.x\n        );\n        return outUV;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    float fruitType = calcFruitType();\n    \n    vec2 imageUV = fragCoord.xy / vec2(iResolution.x) + vec2(0.0, -1.0);\n    vec3 bg = background(imageUV, fruitType);\n    \n\tvec2 mainUV = fragCoord.xy / vec2(iResolution.x) * vec2(1.0, -1.0);\n    mainUV = (mainUV + vec2(0.0, 0.15)) * vec2(fruitTiling);\n    float uvOddRowMask = floor(mod(mainUV.y, 2.0));\n    mainUV += vec2(mix(0.0, 0.5, uvOddRowMask), 0.0);\n    mainUV = fract(mainUV) - vec2(0.5, 0.5);\n    \n    vec2 fruitUV = calcFruitUV(mainUV, fruitType);\n    \n    float dist = distance(fruitUV, vec2(0.0, 0.0));\n    float peel = smoothstep(\n        fruitDistanceThreshold + edgeSoftness,\n        fruitDistanceThreshold - edgeSoftness,\n        dist\n    );\n    float pulp = smoothstep(\n        fruitDistanceThreshold - 0.05 + edgeSoftness,\n        fruitDistanceThreshold - 0.05 - edgeSoftness,\n        dist\n    );\n    \n    vec3 outColor = mix(bg, mixThree(colorPeel, fruitType), peel);\n    outColor = mix(outColor, mixThree(colorPulp, fruitType), pulp);\n    float seedMask = seeds(mainUV, fruitType);\n    outColor = mix(outColor, mixThree(colorSeeds, fruitType), seedMask);\n    \n    outColor = pow(outColor, vec3(0.4545)); // Gamma 2.2\n\tfragColor = vec4(outColor,1.0);\n}\n","name":"Image","description":"","type":"image"}]}