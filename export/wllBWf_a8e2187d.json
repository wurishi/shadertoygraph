{"ver":"0.1","info":{"id":"wllBWf","date":"1597964971","viewed":235,"name":"Soft Shadow","username":"hummingbird","description":"This scene showcases soft shadow casting using SDF raymarching. I am trying to use three sphere to construct a bear head lol","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf","softshadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Camera{\n\tvec3 origin;\n    vec3 target;\n    vec3 up;\n    float vfov;\n    float focal_length;\n    float aspect_ratio;\n};\n    \n    \n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat smoothUnionSDF( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat sphereSDF(vec3 p, vec3 center, float radius){\n\treturn length(p- center) - radius;\n}\n\nfloat torusSDF(  vec3 p,  vec3 center, float innerRadius, float ringWidth )\n{\n  vec3 pos = p - center;\n  vec2 q = vec2(length(pos.xy)-innerRadius,pos.z);\n  return length(q)-ringWidth;\n}\n\n\n\nfloat planeSDF(vec3 p, vec3 normal, float height){\n\treturn dot(p, normal)-height;\n\n}\n\n\nfloat sceneSDF(vec3 p){\n   float plane = planeSDF(p, vec3(0.0, 1.0, 0.0),-1.0);\n   float sphere = sphereSDF(p, vec3(0.0, 0.0, 0.0), 1.0);\n   float leftEar = sphereSDF(p, vec3(0.8, 0.5, 0.0), .6);\n   float rightEar = sphereSDF(p, vec3(-0.8, 0.5, 0.0), .6);\n   float torusArch = torusSDF(p, vec3(0.0,2,0.0), 4.0, 0.2);\n   \n   float final = smoothUnionSDF(sphere, leftEar,.1);\n   final =smoothUnionSDF(final, rightEar,.1);\n   final = smoothUnionSDF(final, torusArch, .2);\n   final = smoothUnionSDF(final, plane,.1);\n   \n   \n\n   return final;\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd,  float k )\n{\n    float res = 1.0;\n    float h = 0.0;\n    float t = 0.1;\n   for(int i = 0; i<50; i++)\n    {\n        \n        h = sceneSDF(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        if(t>=200.0){\n        \treturn res;\n        }\n        t+=h;\n        \n    }\n    return res;\n}\n\n\n\n\nvec3 getSceneNormal(vec3 p){\n\treturn normalize(vec3(sceneSDF(vec3(p.x+0.0001,p.y,p.z)) -sceneSDF(vec3(p.x-0.0001,p.y,p.z)),\n                               sceneSDF(vec3(p.x,p.y+0.0001,p.z)) -sceneSDF(vec3(p.x,p.y-0.0001,p.z)),\n                               sceneSDF(vec3(p.x,p.y,p.z+0.0001)) -sceneSDF(vec3(p.x,p.y,p.z-0.0001))                 \n                              ));\n}\n\nmat4 getViewMatrix(Camera cam){\n\tvec3 f = normalize(cam.target - cam.origin);\n    vec3 r = normalize(cross(f, cam.up));\n    vec3 u = normalize(cross(r, f));\n    \n    return mat4(\n    \tvec4(r,0.0),\n        vec4(u,0.0),\n        vec4(f,0.0),\n        vec4(cam.origin.x,cam.origin.y,cam.origin.z,1.0)\n    );\n\n}\n\nvec3 getCameraRay(vec2 uv, Camera cam){\n    float half_height = tan(radians(cam.vfov/2.0));\n    float half_width = half_height*cam.aspect_ratio; \n    vec3 lower_left = vec3(-half_width, -half_height, cam.focal_length);\n    vec4 view_plane_point = vec4(lower_left + vec3(2.0*half_width,0.0,0.0)*uv.x+vec3(0.0,2.0*half_height,0.0)*uv.y,1.0);\n    view_plane_point = getViewMatrix(cam)*view_plane_point;\n    return normalize(view_plane_point.xyz-cam.origin);\n    \n}\n\n// map from 0 -  255 to 0 - 1\nvec3 normalizedRGB(vec3 rgb){\n\treturn vec3(rgb/255.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    \n    // screen UV\n    vec2 uv = fragCoord / iResolution.xy;\n    // fragColor = vec4(uv.x, uv.y, 0.0,1.0);\n   \n    float aspect_ratio = iResolution.x / iResolution.y;\n    vec3 horizontal = vec3(2.0 * aspect_ratio,0.0,0.0);\n    vec3 vertical = vec3(0.0,2.0,0.0);\n    vec3 lower_left = vec3(-horizontal.x/2.0,-vertical.y/2.0,1.0);\n    \n    // setup camera\n    Camera cam;\n    cam.origin = vec3(cos(iTime)*10.0,2.0,sin(iTime)*10.0);\n   //\tcam.origin = vec3(0,5.0,-10);\n    cam.target = vec3(0.0,0.0,0.0);\n    cam.up = vec3(0.0,1.0,0.0);\n    cam.vfov = 30.0;\n    cam.focal_length = 1.0;\n    cam.aspect_ratio = aspect_ratio;\n    \n    // render sky\n    fragColor.xyz = vec3(0.0);\n   \n    // render scene\n    vec3 rayDir = getCameraRay(uv, cam);\n    vec3 p = cam.origin;\n    vec3 lightPos = vec3(0.0, 3.0, 5.0);\n    \n    \n    for(int i=0;i<250;i++){\n        float d = sceneSDF(p);\n        p = p+rayDir*d;\n        if(d<.001){\n            vec4 finalColor = vec4(0.0,0.0,0.0,1.0);\n            vec3 albedo = vec3(.18,.18,.18);\n            vec3 specular = vec3(1.0,1.0,1.0);\n            vec3 ambient = vec3(0.1,0.1,0.3);\n            vec3 N = getSceneNormal(p);\n           \tvec3 L = normalize(lightPos- p);\n            vec3 E = normalize(cam.origin-p);\n            vec3 H = normalize(L+E);\n            \n            float NdotH = max(dot(N,H), 0.0);\n            float NdotL = max(dot(N, L),0.0);\n            \n            float specularIntensity = pow(NdotH, 300.0);\n            \n            float shadowAtan = softshadow(p, normalize(lightPos), 16.0);\n            finalColor.xyz = (albedo * NdotL  + specular*specularIntensity)*shadowAtan+ ambient;\n            finalColor.xyz = pow(finalColor.xyz, vec3(1.0/ 2.2));\n           \n       \n        \tfragColor = finalColor;\n            return;\n        }\n    \n    } \n}","name":"Image","description":"","type":"image"}]}