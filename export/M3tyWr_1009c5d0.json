{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  // sampling independent computations (only depend on shape)\n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float k = dot(q,vec2(-b,a));\n  if( k<0.0 ) return length(q) - r1;\n  if( k>a*h ) return length(q-vec2(0.0,h)) - r2;\n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCappedCone( vec3 p, vec3 a, vec3 b, float ra, float rb )\n{\n  float rba  = rb-ra;\n  float baba = dot(b-a,b-a);\n  float papa = dot(p-a,p-a);\n  float paba = dot(p-a,b-a)/baba;\n  float x = sqrt( papa - paba*paba*baba );\n  float cax = max(0.0,x-((paba<0.5)?ra:rb));\n  float cay = abs(paba-0.5)-0.5;\n  float k = rba*rba + baba;\n  float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n  float cbx = x-ra - f*rba;\n  float cby = paba - f;\n  float s = (cbx<0.0 && cay<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(cax*cax + cay*cay*baba,\n                     cbx*cbx + cby*cby*baba) );\n}\n\nfloat sdVesicaSegment( in vec3 p, in vec3 a, in vec3 b, in float w )\n{\n    vec3  c = (a+b)*0.5;\n    float l = length(b-a);\n    vec3  v = (b-a)/l;\n    float y = dot(p-c,v);\n    vec2  q = vec2(length(p-c-y*v),abs(y));\n    \n    float r = 0.5*l;\n    float d = 0.5*(r*r-w*w)/w;\n    vec3  h = (r*q.x<d*(q.y-r)) ? vec3(0.0,r,0.0) : vec3(-d,0.0,d+w);\n \n    return length(q-h.xy) - h.z;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nvec4 opMin(vec4 l, vec4 r)\n{\n    if(l.w < r.w)\n    {\n        return l;\n    }\n    \n    return r;\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\n\n\nvec4 body(vec3 p)\n{\n   \n    float torso = opSmoothUnion(sdEllipsoid(p, vec3(.3,1.,.3)), sdEllipsoid(p + vec3(0.,0.5,0), vec3(0.25,0.6,.25)), 0.875);\n    float belt = sdTorus(p + vec3(0.,0.65,0.), vec2(0.45,0.03));\n    vec4 combined = opMin(vec4(1,0,0,torso), vec4(0.1,0.1,0.1,belt));\n    \n    return combined;\n}\n\nvec4 head(vec3 p) \n{ \n    vec4 beard = vec4(1,1,1, sdVesicaSegment(p + vec3(0,-0.2,0.45), vec3(0,0.1,0), vec3(0,2.1,0.4), 0.25));\n    vec4 nose = vec4(1,0,0, sdSphere(p + vec3(0,-1.5,0.5), 0.05));\n    \n    vec4 face = vec4(1, 0.776, 0.631, sdVesicaSegment(p + vec3(0,-1.325,0.35), vec3(0,0.1,.025), vec3(0,0.4,0.0), 0.15));\n    vec4 eyes = vec4(0,0,0, min(  sdSphere(p + vec3(0.075,-1.6,0.475), 0.015),  sdSphere(p + vec3(-0.075,-1.6,0.475), 0.015)  ));\n    \n    \n    vec4 hat = vec4(1.0,0.0,0.0, sdCappedCone(p + vec3(0,-0.72,0.15), vec3(0,1.1,0), vec3(0,1.8,0.13), 0.275, 0.01 ));\n    float hatDetails = sdCappedCone(p + vec3(0,-0.6,0.175), vec3(0,1.1,0), vec3(0,1.25,0.023), 0.3, 0.3 );\n    \n    vec4 fluff = vec4(1,1,1, min(sdSphere(p + vec3(0, -2.6, 0.), 0.075), hatDetails));\n    \n    return opMin(fluff, opMin( hat, opMin( eyes, opMin( face, opMin(beard,nose)))));\n}\n\nvec4 legs(vec3 p)\n{\n    p.x = abs(p.x);\n    \n    float leg = sdCappedCone(p + vec3(-0.15,0,0), vec3(0,-0.5,0), vec3(0,-1.75,0), 0.05, .05 );\n    \n    float foot = sdCapsule(p + vec3(-0.15,1.82,0), vec3(0,0,0), vec3(0.13,0,-0.5), 0.13);\n    \n    foot = opSmoothSubtraction(p.y + 1.82, foot , 0.15 );\n    \n    return vec4(0.1,0.1,0.1, min(leg, foot));\n}\n\nvec4 map(vec3 p)\n{\n   \n\n    float rotAmnt = iTime;\n    mat3 yRot = mat3( vec2(cos(rotAmnt), 0), -sin(rotAmnt),\n                      vec2(0,1), 0.,\n                      vec2(sin(rotAmnt), 0), cos(rotAmnt));\n\n\n\n    p = yRot * p;\n    \n     //p.x = p.x * 0.85;\n     p.z = p.z * 0.95;\n\n    vec4 result = vec4(0, 0, 0, 1000);\n    \n    result = opMin(vec4(1.,0.,0.,sdSphere(p, 0.5)), \n                   vec4(0.,1.,0.,sdSphere(p + vec3(0.0,1.0,0.0), 0.7)));\n                   \n    \n    result = opMin(body(p), head(p));\n    result = opMin(legs(p), result);\n    return result;\n}\n\nvec4 traverse(in vec3 ro, in vec3 rd)\n{\n\n    vec3 p = ro;\n    float t = 0.0;\n\n    for(int i = 0; i < 100; i++)\n    {\n        vec4 d = map(p);\n        \n        if(d.w < 0.01 || t > 300.)\n        {\n            return vec4(d.xyz, t);\n        }\n        \n        p += d.w * rd;\n        t += d.w;\n    }\n    \n    return vec4(0,0,0,5000);\n}\n\n\nvec3 calcNormal( in vec3 p )\n{\n    const float eps = 0.0001; \n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(map(p+h.xyy).w - map(p-h.xyy).w,\n                           map(p+h.yxy).w - map(p-h.yxy).w,\n                           map(p+h.yyx).w - map(p-h.yyx).w ) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n \n    vec3 col = mix(vec3(0.815,0.27,0.69) * 0.8, vec3(.2, .18, .73) * 0.8, 1.0-pow(1.0-(uv.y + 0.5), 2.0));\n    \n    vec3 ro = vec3(0,0,-6);\n    vec3 rd = normalize(vec3(uv, 1.0));\n\n    vec4 result = traverse(ro,rd);\n    \n    if(result.w < 300.0)\n    {\n        vec3 normal = calcNormal(ro + rd * result.w);\n        float rotAmnt = -iTime * 1.0;\n        mat3 yRot = mat3( vec2(cos(rotAmnt), 0), -sin(rotAmnt),\n                      vec2(0,1), 0.,\n                      vec2(sin(rotAmnt), 0), cos(rotAmnt));\n        \n        \n        vec3 lightDir = normalize(yRot * vec3(-0.4,0.8,-1));\n        vec3 reflLight = reflect(lightDir, normal);\n        float spec = clamp(dot(rd, reflLight), 0., 1.);\n        \n        vec3 diff = result.xyz * clamp(dot(normal, lightDir), 0., 1.) * 0.38;\n        vec3 specular = vec3(0.2) * pow(spec, 20.);\n        \n        col = diff + specular;\n        col += result.xyz * 0.5;\n        \n        //col = normal;\n    }\n    \n  \n\n    \n    // Output to screen\n    fragColor = vec4(col,0.1);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"M3tyWr","date":"1734972806","viewed":73,"name":"Santa - Kris","username":"kris1206","description":"Playing around before Christmas :)","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["christmas","raymarch"],"hasliked":0,"parentid":"","parentname":""}}