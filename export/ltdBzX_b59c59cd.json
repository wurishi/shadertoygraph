{"ver":"0.1","info":{"id":"ltdBzX","date":"1540572688","viewed":135,"name":"Environment Project- Ship","username":"cake7914","description":"Ship","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["ship"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define repeat(v, r) (mod(v, r)-r/2.)\n\nstruct Shape{\n  float dist;\n  vec4 color;\n};\n\n\n    \n//=======================\n// Utility Functions\n//=======================\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}    \n    \n    \n// Maximum/minumum elements of a vector    \nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}    \n    \n    \nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))*46556.2);\n}\n\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n\n\nfloat pole(vec2 v, float r){\n  return length(v)-r;\n}\n\nfloat sphere(vec3 v, float r){\n  return length(v)-r;\n}\n\n\n\n// ============================\n// http://mercury.sexy/hg_sdf/\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\n// We can just call Union since stairs are symmetric.\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, -b, r, n);\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\n\nfloat fOpTongue(float a, float b, float ra, float rb) {\n\treturn min(a, max(a - ra, abs(b) - rb));\n}\n// ============================\n\n\n\nfloat mixColors(float r, float v, float z){\n  return clamp(0.5+0.5*(v-r)/z, 0., 1.);\n}\n\nfloat mixShapes(float v, float f, float r){\n  float z = mixColors(v, f, r);\n  return mix(f,v,z)-r*z*(1.-z);\n}\n\nfloat pModPolar(inout vec2 v, float r){\n  float f = 6.28318/r;\n  float z = atan(v.y, v.x)+f*0.5;\n  float m = floor(z/f);\n  z = mod(z, f)-f*0.5;\n  v = vec2(cos(z), sin(z))*length(v);\n  return m;\n}\n\n\n//=======================\n\nShape Ship(vec3 c){\n  Shape shape;\n\n  c.z = repeat(c.z, 1.22); // Repeat\n  c.x = abs(c.x)-0.5; // Mirror\n  \n  // Ship\n  vec3 shipOffset = vec3(1.2, 0.1, 0.);\n\n  \t// Walls\n  \tvec4 sColor = vec4(.1, 0.4, 0.4, 1.);\n    //vec4 sColor = vec4(.5, .3, .1, 1.);\n  \tfloat walls = fBox(c-shipOffset, vec3(0.2, 6., 0.5));\n  \n  \t// Windows\n  \tvec4 wColor = vec4(.2, .2, .2, 1.);\n  \tfloat windows = sphere(c-shipOffset, .5);\n    \n    // Seats\n    vec4 fColor = vec4(.5, .2, .2, 1.);\n    float seats = fBox(c-vec3(0., -1.5, 0.), vec3(.5, 1., 0.));\n    \n    // Engraving\n    float engraving = fBox(c-vec3(1., 1.2, 0.), vec3(.4, .15, 4));\n    \n\n  shape.dist = fOpTongue(walls, windows, .08, .1);\n  shape.dist = min(shape.dist, seats);\n  shape.dist = max(shape.dist, -engraving);\n  \n                         \n  shape.color = mix(sColor, wColor, mixColors(windows, walls, 0.));    \n  shape.color = mix(shape.color, fColor, mixColors(seats, shape.dist, 2.));\n\n  return shape;\n}\n\n\nShape map(vec3 c){\n  Shape ship = Ship(c);\n  return ship;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n\n  \n  vec3 cam = vec3(0., 0., iTime);\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  fragColor = vec4(0.);\n\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.001){\n      fragColor = c.color*(1.-z); // Hit  - invert pixels\n      break;\n    }\n    scene += f * c.dist;\n\n\n  }\n}\n","name":"Image","description":"","type":"image"}]}