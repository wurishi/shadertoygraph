{"ver":"0.1","info":{"id":"4tcGDH","date":"1468956802","viewed":1016,"name":"[SH16C]ShaderForce: special unit","username":"Bananaft","description":"Delta Force remake. 98 is still 90s, ok?\n\nresolution is fixed, so playing fullscreen should not affect performance that much.\n\nControlls: WASD - move, click and drag to look around\n\nThat's about it. Unfortunately I run out of time. ","likes":18,"published":1,"flags":48,"usePreview":0,"tags":["game","firstperson","fps","wasd","sh16c"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv *= vec2(640.0,360.0)/iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float heightmap(vec2 pos)\n{\n   return min(1.4 - pow(texture(iChannel1, pos * 0.002,3.).r,0.5),1.)  * 35.;\n}\n\nvec2 scene(vec3 point)\n{\n \tfloat hmp = heightmap(point.xz);\n    float d = point.y + hmp;\n    return vec2(d,0.0);\n}\n\nfloat RayCast (vec3 ro,vec3 ta, int STEPS)\n{\n \tvec3 ca = ta-ro;\n\tfloat far = length(ca);\n    ca = normalize(ca);\n    \n    float distance;\n    float totalDistance = 0.0;\n    vec3 intersection; \n    \n    for(int i =0 ;  i < STEPS; ++i)\n    {\n        intersection = ro + ca * totalDistance;\n        vec2 s = scene(intersection);\n        distance = s.r;\n\n        totalDistance += distance;\n\n        if(distance <= 0.002 || totalDistance >= far)\n        {\n           break;\n        }\n    }\n    \n    return totalDistance;\n    \n}\n\n// mouselook and keyboard handling from: https://www.shadertoy.com/view/ldyGzW\n\n// keys are javascript keycode\nconst int Key_A = 65; const int Key_B = 66; const int Key_C = 67; const int Key_D = 68; const int Key_E = 69;\nconst int Key_F = 70; const int Key_G = 71; const int Key_H = 72; const int Key_I = 73; const int Key_J = 74;\nconst int Key_K = 75; const int Key_L = 76; const int Key_M = 77; const int Key_N = 78; const int Key_O = 79;\nconst int Key_P = 80; const int Key_Q = 81; const int Key_R = 82; const int Key_S = 83; const int Key_T = 84;\nconst int Key_U = 85; const int Key_V = 86; const int Key_W = 87; const int Key_X = 88; const int Key_Y = 89;\nconst int Key_Z = 90;\nconst int Key_0 = 48; const int Key_1 = 49; const int Key_2 = 50; const int Key_3 = 51; const int Key_4 = 52;\nconst int Key_5 = 53; const int Key_6 = 54; const int Key_7 = 55; const int Key_8 = 56; const int Key_9 = 57;\nconst int Key_Space = 32;\n\nfloat ReadKeyInternal( int key, bool toggle )\n{\n\treturn texture( iChannel3, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n}\n\nfloat ReadKey( int key )\n{\n\treturn ReadKeyInternal(key,false);\n}\n\nfloat ReadKeyToggle( int key )\n{\n\treturn ReadKeyInternal(key,true);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if ( int(fragCoord.y) == 0 )\n    {\n        if ( int(fragCoord.x) == 0 )\n        {\n    \n            vec4 camPos = texture( iChannel0, vec2(.5,.5)/iResolution.xy, -100.0 );\n            vec4 camRot = texture( iChannel0, vec2(1.5,.5)/iResolution.xy, -100.0 )*6.28318530718;\n            \n            float accel = 0.08;\n            \n            vec3 forward = vec3(0,0,-1)*accel;\n            vec3 right = vec3(1,0,0)*accel; // right is left, remember kids!\n            \n            forward.xz = forward.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*forward.zx;\n\t\t    right.xz = right.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*right.zx;\n            \n            float fwd  = (ReadKey(Key_W)-ReadKey(Key_S));\n            float sdw = (ReadKey(Key_D)-ReadKey(Key_A));\n            \n            camPos.xyz += fwd * forward;\n            camPos.xyz += sdw * right;\n\n            camPos.y = -1. * heightmap(camPos.xz) + 1.7;\n            \n            camPos.w = abs(fwd) + abs(sdw);\n            \n            fragColor = camPos;\n        }\n        else if ( int(fragCoord.x) <= 2 )\n        {\n            vec4 baseCamRot = texture( iChannel0, vec2(2.5,.5)/iResolution.xy, -100.0 );\n            vec4 camRot = texture( iChannel0, vec2(1.5,.5)/iResolution.xy, -100.0 );\n\n            vec2 mouseRot = (iMouse.yx/iResolution.yx-.5) * vec2(1.,-1.) * 0.5;\n            \n            camRot.w = iMouse.z;\n            \n            bool press = (camRot.w > .0);\n            bool lastPress = (baseCamRot.w > .0);\n            bool click = press && !lastPress;\n            if ( click )\n            {\n                baseCamRot.xy -= mouseRot;\n            }\n            \n            if ( press )\n            {\n                camRot.xy = baseCamRot.xy + mouseRot;\n            }\n            else\n            {\n                //update the base pos\n                baseCamRot = camRot;\n            }\n\n            baseCamRot.w = camRot.w;\n            \n            // store\n            if ( int(fragCoord.x) == 1 )\n            {\n            \tfragColor = camRot;\n            }\n            else\n            {\n            \tfragColor = baseCamRot;\n            }\n            \n    \t}\n    }\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nfloat heightmap(vec2 pos)\n{\n   return min(1.4 - pow(texture(iChannel1, pos * 0.002,3.).r,0.5),1.)  * 35.;\n}\n\nvec2 scene(vec3 point)\n{\n \tfloat hmp = heightmap(point.xz);\n    float d = point.y + hmp;\n    \n    return vec2(d,0.0);\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 weapon(vec3 point)\n{\n\t\n    vec2 d = opU(vec2(sdCapsule(point,vec3(0.,-0.3,0.),vec3(0.,-0.3,3.),0.3),612.),\n                 vec2(sdCylinder(point -vec3(0.,0.0,2.),vec2(0.12,4.2)),228.));\n    d = opU( d ,vec2( sdBox(point -vec3(0.,0.05,2.0),vec3(0.18,0.14,0.6)),228.));\n    d = opU( d ,vec2( sdBox(point -vec3(0.,0.25,5.4),vec3(0.05,0.11,0.1)),228.));\n    d = opU( d ,vec2( sdBox(point -vec3(0.,0.29,2.3),vec3(0.08,0.3,0.03)),229.));\n    d = opU( d ,vec2( sdBox(point -vec3(0.,0.29,1.8),vec3(0.08,0.3,0.03)),229.));\n    d = opU( d ,vec2( sdCylinder(point -vec3(0.,0.7,2.4),vec2(0.2,0.2)),229.));\n    d = opU( d ,vec2( sdCylinder(point -vec3(0.,0.7,1.5),vec2(0.2,0.1)),229.));\n    d = opU( d ,vec2( sdCylinder(point -vec3(0.,0.7,2.),vec2(0.17,0.4)),229.));\n    d = opU( d ,vec2( sdCylinder(point -vec3(0.,0.7,1.42),vec2(0.15,0.03)),75.));\n    return vec2(d);\n}\n\nvec2 ents(vec3 point)\n{\n  vec2 d = opU(vec2(sdCapsule(point,vec3(0.,-0.3,0.),vec3(0.,-0.3,3.),0.3),612.),\n                 vec2(sdCylinder(point -vec3(0.,0.0,2.),vec2(0.12,4.2)),228.));  \n    \n      return vec2(d);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n      \n    const vec2 res = vec2(640.0,360.0);\n    vec2 scopeCoord = fragCoord;\n    \n    const int RAY_STEPS = 128;\n    const float NEAR_CLIP = .5;\n    const float FAR_CLIP = 530.0;\n    \n    if (fragCoord.x < res.x && fragCoord.y < res.y )\n    {\n        vec4 playerPos = texture(iChannel0, vec2(.5,.5)/iResolution.xy, -100.0 );\n        vec3 origin = playerPos.xyz;\n        vec3 wp_origin = vec3(-1.2,0.8,0.);\n        \n        //360 QUICKSCOPE\n        float fov = 1.5;\n        if (playerPos.w < 0.2)\n        {\n            if (length(vec2(-500.,-180.)+fragCoord)<100.)\n            {\n                fov = 8.0;\n                scopeCoord += vec2(-180.,0.);\n            }\n        } else {\n         \torigin.y += 0.1 * sin(iTime * 20.);\n            wp_origin += vec3(-0.2 * cos(iTime * 10.),-0.1 * cos(iTime * 20.),0.);\n        }\n        \n        \n        vec2 uv = scopeCoord.xy / res * 2.0 - 1.0;\n        uv.x *= res.x / res.y;\n        \n        vec3 intersection; \n    \t\n    \tvec3 direction;\n        \n        vec4 camRot = texture( iChannel0, vec2(1.5,.5)/iResolution.xy, -100.0 )*6.28318530718;        \n        vec3 camdir = vec3(0.,0.,-1.);\n        camdir.zy = camdir.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*camdir.yz;\n    \tcamdir.xz = camdir.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*camdir.zx;\n        \n        // camera\t\n        vec3 ro = origin;\n        vec3 ta = origin + camdir;\n\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n\t\t\n          \n        // ray direction\n       direction = normalize( vec3(uv.xy,fov) );\n\n        float distance;\n        float totalDistance = NEAR_CLIP;\n        float m = 0.;\n\t\t\n        vec3 Col = vec3(1.0);\n        \n        for(int i =0 ;  i < 48; ++i) ////// Rendering weapon\n        {\n            intersection = wp_origin + direction * totalDistance;\n            vec2 s = weapon(intersection);\n            distance = s.r;\n            m = s.g;\n\t\t\ttotalDistance += distance;                    \t\n            \n            if(distance <= 0.02 || totalDistance >= 6.8) //\n            {\n                \n                break;\n            }\n        }\n               \n        float lt = clamp( -3. * intersection.x + 0.7 * intersection.y,0.3,1.);\n        \n        if (m>100.)\n        {\n            //lt = max(lt, 0.1 + texture(iChannel2,1.52 * vec2(intersection.x+intersection.y,intersection.z-intersection.x)).x);\n            lt *= lt + texture(iChannel2,1.52 * vec2(intersection.x+intersection.y,intersection.z-intersection.x)).x;\n        } else {\n        \tlt *= 3.;\n        }\n        \n        Col = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        Col *= lt;\n       \n        if (totalDistance >= 6.5)\n    \t{\t\n        \n\t\t\ttotalDistance = NEAR_CLIP;\n            direction = ca * direction;\n            \n            for(int i =0 ;  i < RAY_STEPS; ++i) ////// Rendering terrain\n            {\n                intersection = origin + direction * totalDistance;\n                intersection = floor(intersection*12.)/12.;\n                vec2 s = scene(intersection);\n                distance = s.r;\n               float gtex = texture(iChannel2, intersection.xz).r;\n                totalDistance += distance - gtex *0.4;\n\n\n                if(distance <= 0.002 || totalDistance >= FAR_CLIP) //\n                {\n                    //Col = vec3(0.,1.,0.);\n                    break;\n                }\n            }\n\t\t\t\n             float tex = texture(iChannel1, intersection.xz * 0.045).r;\n            float tex2 = texture(iChannel2,vec2(intersection.y * 0.2 - 0.4 * tex,0.66) * 0.05).r;\n            Col = vec3((0.4+0.6*tex2),(0.3+0.7*tex2),(0.2+0.8*tex2)) * mix(vec3(0.4,0.5,0.1),vec3(1.0,0.8,0.2),clamp(intersection.y * 0.06 +1.2+1.2 * (1.-tex),0.,1.));\n            \n\t//\t\tfloat tg_far = totalDistance;\n    //        float tg_dist = NEAR_CLIP;\n    //        \n    //        for(int i =0 ;  i < 96; ++i) ////// Rendering terrain\n    //        {\n    //            intersection = origin + direction * tg_dist;\n    //            vec2 s = ents(intersection);\n    //            distance = s.r;\n    //            tg_dist += distance;\n\t//\n\t//\n    //            if(distance <= 0.002 || tg_dist >= tg_far) //\n    //            {\n    //                //Col = vec3(0.,1.,0.);\n    //                break;\n    //            }\n    //        }\n            float fog = clamp(pow(max((1.-(totalDistance* 0.0015)),0.),2.2),0.,1.);\n           \n            \n            \n            Col = mix(vec3(0.12,0.38,0.6) + vec3(0.34,0.58,0.79) * clamp(pow(1.0-direction.y,2.2),0.0,1.),Col,fog);\n        }\n        vec2 csu = abs(vec2(scopeCoord.x - 320., scopeCoord.y - 180.));\n        float hud = (1.-step(1., csu.x)) * (step(12.,csu.y) - step(16. + fov * 2.,csu.y)) + (1.-step(1., csu.y)) * (step(12.,csu.x) - step(16.+ fov * 2.,csu.x)); \n      \n        Col = mix(Col, vec3(0.,1.,0.), hud);\n        \n        fragColor = vec4(Col,1.0);\n    \n    \n    \n    } else {\n    \tdiscard;\n    }\n    \n}","name":"Buf B","description":"","type":"buffer"}]}