{"ver":"0.1","info":{"id":"fl3SW4","date":"1639297500","viewed":222,"name":"Cyclic Dripstone (glsl entry)","username":"slerpy","description":"2k of raw shader released at TDF 2021\n\n[url]https://www.pouet.net/prod.php?which=90426[/url]\n\n(contains very minor post-party fixes)","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["cyclic","tdf","tokyodemofest","slerpy","dripstone"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// rotation matrix\nmat2 r(float a) {\n\tfloat s=sin(a), c=cos(a);\n\treturn mat2(c,s,-s,c);\n}\n\n// hashing function\nvec4 h(vec3 p) {\n\tvec4 p4 = fract(vec4(p.xyzx) * vec4(.1031, .1030, .0973, .1099));\n\tp4 += dot(p4, p4.wzxy+33.33);\n\treturn fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n// cyclic noise function\nvec3 N(vec3 p, float f) {\n\tvec4 acc = vec4(0);\n\tmat2 r = r(.5);\n    \n\tfor (int i=0; i<6; i++)\n        p += p, p.xy *= r, p.yz *= r, p += sin(p.yzx),\n        acc = f * acc + vec4(cross(sin(p.zxy), cos(p)), 1.);\n\t\n    return acc.xyz / acc.w;\n}\n\n// lighting function of the sphere (returns how much light should be emitted by each point on the sphere)\nvec3 L(vec3 p) {\n\tp /= length(p);\n\tfloat tt = iTime;\n\t\n    // build-up\n\tif (tt < 5.0) return .002 * vec3(1.-smoothstep(.0, 5., tt));\n\ttt -= 5.;\n\t\n    // moving line\n\tif (tt < 39.) {\n\t\tfloat c = sin(tt*acos(-1.)/3.);\n\t\tif (tt > 24.) p.x = abs(p.x);\n\t\tif (tt > 27.) p.y = abs(p.y);\n\t\tp.xz *= r(-.9*max(tt-4., 0.));\n\t\tp.xy *= r(.5*max(tt-5., 0.));\n\t\tfloat o = .4 * step(tt, 12.);\n\t\treturn vec3(step(.02+o, .5*c*c - 2.*abs(fract(iTime - .5*p.y - .5) - .5)));\n\t}\n\ttt -= 39.;\n\t\n    // rainbow lighing\n\tif (tt < 16.) {\n\t\tp.xy *= r(.3*tt);\n\t\tp.xz *= r(2.*tt);\n\t\tvec3 c = .5 + .5 * cos(tt-vec3(0,90,67));\n\t\tif (p.x < 0.) c = 1. - c;\n\t\treturn c * step(.6 + exp(-3.*tt) + exp(3.*(tt-15.5)), abs(p.x)) * 4.;\n\t}\n\ttt -= 16.;\n\t\n    // sinmix logo\n\tp.xy *= r(-.1*exp(1.3*(5. - tt + .02*h(p).x)));\n\tp.z += .82; p = sign(p);\n\treturn vec3(smoothstep(.0, 1., tt)) * step(p.x*p.y*p.z, 0.);\n}\n\n// envirement sdf function (the sphere is added separately)\nfloat E(vec3 p) {\n\tvec3 a = abs(p); a.z = p.z; a.xz -= 1.3;\n\tfloat s = 2. - max(max(a.x, a.y), a.z);\n\treturn .65 * (s + .4 * N(p, 3.2).x);\n}\n\nvoid mainImage(out vec4 C, in vec2 I) {\n\n    // init random vector\n\tvec4 rv = h(vec3(I.xy, iTime)),\n    \n    // camera movement control (rd and ro angle rotation)\n         ra = .16 * (1. - smoothstep(45., 70., iTime))\n                * cos(.02 * vec2(5,7).xxyy * (iTime + vec2(0,1).xyxy)) + vec2(0,.03).xxyy;\n\t\n    // camera setup\n    vec3 D = normalize(vec3(I.xy - .5 * (iResolution.xy + rv.xy), iResolution.y)),\n         O = vec3(0, 0, -6), p, h, col = D-D;\n\t\n    // camera rotation\n\tO.xz *= r(ra.x);\n\tD.xz *= r(ra.y);\n\tO.yz *= r(ra.z);\n\tD.yz *= r(ra.w);\n\n    // ray marching\n\tfloat m, l, t = 3.;\n\tfor(int i=0; i<70; i++) {\n\t\tp = O + D * t;\n\t\tl = length(p) - 1.;\n\t\tt += m = min(l, E(p));\n\t}\n\t\n    // compute lighting on sphere (just some msaa)\n\tif (m == l) {\n\t\tvec3 c = t * fwidth(D);\n\t\tfor(int i=0; i<32; i++) {\n\t\t\trv = fract(sin(1e3*rv)+rv.wxyz);\n\t\t\tcol += L(p + c * rv.xyz);\n\t\t}\n    }\n    \n    // compute lighting in the cave (light sampling the sphere)\n    else {\n        // compute normals\n        vec2 e  = vec2(0, .01);\n\t\tvec3 dd = normalize(p),\n             n  = normalize(m - vec3(E(p-e.yxx), E(p-e.xyx), E(p-e.xxy)));\n\t\t\n        // sample light\n\t\tfor(int i=0; i<64; i++) {\n\t\t\trv = fract(sin(1e3*rv)+rv.wxyz);\n\t\t\t\n            // choose random point on sphere\n\t\t\tfloat a = 6.283 * rv.x,\n                  b = 2. * rv.y - 1.,\n                  c = sqrt(1. - b*b),\n                  d = dot(dd, h = vec3(c * cos(a), b, c * sin(a)));\n\n            // reflect the point if it's on the wrong side of the sphere\n\t\t\tif (d < 0.) h = -h;\n            \n            // add light sample to accumulator\n\t\t\tcol += smoothstep(.2, 1., abs(d)) * L(h);\n\t\t}\n\t\t\n        // surface color\n\t\tcol *= mix(vec3(1, .6, .5), vec3(1), N(-p, 1.3)) * dot(n,-dd) / (dot(p,p));\n\t}\n\t\n    // tiny bit of post processing\n\tcol = max(col/16. - smoothstep(64., 69., iTime), 0.);\n\tC = vec4(sqrt(1.5 * col / (col+1.)), 1);\n}\n","name":"Image","description":"","type":"image"}]}