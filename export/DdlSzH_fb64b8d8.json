{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// contribute by mario8664\nfloat sdLine(vec2 p, vec2 a, vec2 b)\n{\n    vec2 ap = p - a;\n    vec2 ab = b - a;\n    float h = dot(ap, ab) / dot(ab, ab);\n    h = clamp(h, 0.0, 1.0);\n    \n    float d = length(ap - h * ab);\n    return d;\n}\n\n// contribute by mario8664\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n    ivec2 iCoord = ivec2(fragCoord);\n    vec4 data = texelFetch(iChannel0, iCoord, 0);\n    float d = 200.;\n    for( int x = 0; x < GridSize.x - 1; x++)\n    {\n        for(int y = 0; y < GridSize.y - 1; y++)\n        {\n            ivec2 o = ivec2(0, 1);\n            vec2 p0 = texelFetch(iChannel0, ivec2(x,y) + o.xx, 0).xy;\n            vec2 p1 = texelFetch(iChannel0, ivec2(x,y) + o.xy, 0).xy;\n            vec2 p2 = texelFetch(iChannel0, ivec2(x,y) + o.yy, 0).xy;\n            vec2 p3 = texelFetch(iChannel0, ivec2(x,y) + o.yx, 0).xy;\n            \n            float d0 = sdLine(uv, p0, p1);\n            float d1 = sdLine(uv, p1, p2);\n            float d2 = sdLine(uv, p2, p3);\n            float d3 = sdLine(uv, p3, p0);\n            float d4 = sdLine(uv, p0, p2);\n            float d5 = sdLine(uv, p1, p3);\n            \n            d = min(d,min(d5, min(d4, min(d0, min(d1, min(d2, d3))))));\n        }\n    }\n    \n    \n    fragColor = vec4(d < 0.001);\n}\n\n\n/*\n// my own rendering implementation\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iCoord = ivec2(fragCoord);\n    vec4 data = texelFetch(iChannel0, iCoord, 0);\n    float d = 200.;\n    for( int x = 0; x < GridSize.x; x++)\n    {\n        for(int y = 0; y < GridSize.y; y++)\n        {\n            vec2 p = texelFetch(iChannel0, ivec2(x,y), 0).xy;\n            float dd = length(fragCoord / iResolution.y - p);\n            d = min(d, dd);\n        }\n    }\n    \n    fragColor = vec4(d < 0.005);\n}\n*/","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// for a 2d particle, xy -> next position in int\n//                    zw -> previous position\n\n// spring coefficient\nconst float K = 0.1;\nconst float K3 = 0.1;\nconst float Ff = 0.01; // fiction force\nconst vec2 Gravity = vec2(0.0, -4.8);\n\n// distance at rest\nconst float R1 = 0.04; // structure\nconst float R2 = R1 * sqrt(2.0);  // shear\nconst float R3 = R1 * 2.0;  // bend\n\nvec2 offset = vec2(0.0);\n\nvec4 getParticle(in ivec2 iPos){\n    return texelFetch(iChannel0, iPos, 0);\n}\n\nvec2 getNeighbourParticle(in ivec2 iPos, in ivec2 dir)\n{\n    return texelFetch(iChannel0, iPos + dir, 0).xy;\n}\n\nvec2 hukeLaw(in vec2 locPos, in vec2 neiPos, float k, float d)\n{\n    vec2 norm = normalize(neiPos - locPos);\n    float dist = distance(neiPos, locPos);\n    return norm * k * (dist - d);\n}\n\nvec2 solve(vec2 localPos, ivec2 iPos, ivec2 dir, float k, float d)\n{\n    if (checkFixed(iPos)) return vec2(0.0);\n    vec2 neighbour = getNeighbourParticle(iPos, dir);\n    vec2 D = hukeLaw(localPos, neighbour, k, d);\n    //if(checkFixed(iPos + dir)) return D;\n    //else return 0.5 * D;\n    return D;\n}\n\nvec2 relaxation(in ivec2 iPos, in vec2 localPos)\n{\n    // Structure Spring relaxation\n    if(iPos.x > 0)               localPos += solve(localPos, iPos, ivec2(-1, 0), K, R1);\n    if(iPos.x < GridSize.x - 1)  localPos += solve(localPos, iPos, ivec2( 1, 0), K, R1);\n    if(iPos.y > 0)               localPos += solve(localPos, iPos, ivec2( 0,-1), K, R1);\n    if(iPos.y < GridSize.y - 1)  localPos += solve(localPos, iPos, ivec2( 0, 1), K, R1);\n    \n    // Shear Spring relaxation\n    if(iPos.x > 0 && iPos.y > 0) \n        localPos += solve(localPos, iPos, ivec2(-1,-1), K, R2);\n    if(iPos.x > 0 && iPos.y < GridSize.y - 1)\n        localPos += solve(localPos, iPos, ivec2(-1, 1), K, R2);\n    if(iPos.x < GridSize.x - 1 && iPos.y > 0) \n        localPos += solve(localPos, iPos, ivec2( 1,-1), K, R2);\n    if(iPos.x < GridSize.x - 1 && iPos.y < GridSize.y -1) \n        localPos += solve(localPos, iPos, ivec2( 1, 1), K, R2);\n        \n    // bend spring relaxation\n    if(iPos.x > 1) localPos += solve(localPos, iPos, ivec2(-2, 0), K3, R3);\n    if(iPos.y > 1) localPos += solve(localPos, iPos, ivec2( 0,-2), K3, R3);\n    if(iPos.x < GridSize.x - 2) localPos += solve(localPos, iPos, ivec2( 2, 0), K3, R3);\n    if(iPos.y < GridSize.y - 2) localPos += solve(localPos, iPos, ivec2( 0, 2), K3, R3);\n    \n    return localPos;\n}\n    \n\n\nvec4 simulate(in ivec2 iPos)\n{\n    vec4 particle = getParticle(iPos);\n    if(checkFixed(iPos)) // fixed particles\n    {\n        vec2 mouse = vec2(0.0);\n        // vec2 offset = vec2(0.0);\n        if (iMouse.z > 0.0)\n        {\n            vec2 down = abs(iMouse.zw);\n            mouse = (iMouse.xy - down) / iResolution.xy;\n        }\n        else{\n            offset += (iMouse.xy - abs(iMouse.zw)) / iResolution.xy;\n        }\n        \n        // set position directly\n        particle.xy = vec2(iPos.x + 12, iPos.y + 5) * R1;\n        particle.xy += mouse + offset;\n    }\n    \n    // verlet integral\n    vec2 previousPos = particle.zw;\n    vec2 currentPos = relaxation(iPos, particle.xy);\n    vec2 nextPos = currentPos\n                    + (currentPos - previousPos) * (1.0 - Ff) \n                    + Gravity * iTimeDelta * iTimeDelta;\n    //nextPos.y = max(nextPos.y, 0.1);\n    previousPos = currentPos;\n    return vec4(nextPos, previousPos);\n}\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iCoord = ivec2(fragCoord);\n    if(any(greaterThanEqual(iCoord, GridSize))) return; // simulate particles only\n    \n    if(iFrame < 2) // init position\n        fragColor = vec4(vec2(iCoord.x + 12, iCoord.y + 5).xyxy) * R1;\n    else\n        fragColor = simulate(iCoord);\n}","name":"Buffer A","description":"","type":"buffer"},{"outputs":[],"inputs":[],"code":"#define GridSize ivec2(14,17)\n\n// define a particle fixed or not\nbool checkFixed(ivec2 iPos)\n{\n    if (iPos.y == GridSize.y - 1) return true;\n    return false;\n}","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"DdlSzH","date":"1668514947","viewed":243,"name":"Cloth Sim. via verlet integral","username":"lyxnb2333","description":"Cloth Simulation using verlet integral and string relaxation.\nRendering Contributor: Mario8664","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["spring","relaxation","verlet","cloth"],"hasliked":0,"parentid":"","parentname":""}}