{"ver":"0.1","info":{"id":"MdlfW8","date":"1496061040","viewed":117,"name":"simple_raymarching","username":"phuidn","description":"A very basic raymarching algorithm.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","simple","raymarch","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MARCHING_STEPS (500)\n#define MARCH_PROXIMITY (0.005)\n#define NORMAL_TOLERANCE (0.01)\n\n\nfloat sphereSDF(vec3 point, vec3 centre, float radius)\n{\n \treturn length(point - centre) - radius;\n}\n\n\nfloat sceneSDF(vec3 point)\n{\n    float sphere2_rad = 1.05 + 1.8 * sin(iTime);\n    \n \treturn max( sphereSDF(point, vec3(0.0,0.0,0.0), 1.0),\n               -sphereSDF(point, vec3(1.0,1.0,1.0), sphere2_rad));\n}\n\nvec3 normalEstimate(vec3 point)\n{\n    vec3 dx = vec3(NORMAL_TOLERANCE, 0, 0),\n         dy = vec3(0, NORMAL_TOLERANCE, 0),\n         dz = vec3(0, 0, NORMAL_TOLERANCE);\n    \n \treturn normalize(vec3(sceneSDF(point + dx) - sceneSDF(point - dx),\n                          sceneSDF(point + dy) - sceneSDF(point - dy),\n                          sceneSDF(point + dz) - sceneSDF(point - dz)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //position of the camera\n    vec3 camera_pos = vec3(3,0,0);\n    //centre of the screen\n    vec3 screen_pos = vec3(1.8, 0, 0);\n    //total screen height\n    float screen_height = 1.333,\n          screen_width = screen_height * iResolution.x / iResolution.y;\n    \n    uv = vec2(screen_width, screen_height) * (uv - vec2(0.5, 0.5));\n    \n    vec3 px_pos = screen_pos + vec3(0, uv);\n    \n    vec3 current_pos = px_pos, \n         direction = normalize(px_pos - camera_pos);\n    \n    float current_dist = sceneSDF(current_pos),\n          max_dist = 5.0;\n    \n    for (int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n    \tcurrent_pos += direction * current_dist;\n\n        current_dist = sceneSDF(current_pos);\n        \n      \tif (current_dist < MARCH_PROXIMITY || current_dist > max_dist)\n        {\n            break;\n        }\n    }\n    \n\tif(current_dist < MARCH_PROXIMITY)\n    {\n        fragColor = vec4(0.5 * (normalEstimate(current_pos) + 1.0), 1.0);\n    }\n    else\n    {\n     \tfragColor = vec4(0.0, 0.0, 0.0, 1.0);   \n    }\n\n}","name":"Image","description":"","type":"image"}]}