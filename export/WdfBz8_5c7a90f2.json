{"ver":"0.1","info":{"id":"WdfBz8","date":"1587653475","viewed":206,"name":"Procedural landmass","username":"Krafpy","description":"Procedural landmass generation using perlin noise and voronoi.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["procedural","noise","terrain","water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n\n// decrease octaves for better performances\n#define OCTAVES 10\n\n// rotation matrix\nmat2 rot(float a){\n\treturn mat2(cos(a), -sin(a),\n               sin(a), cos(a));\n}\n\n\n// perlin noise functions\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(vec2 c){\n\treturn fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 p, float freq ){\n\tfloat unit = 1./freq;\n\tvec2 ij = floor(p/unit);\n\tvec2 xy = mod(p,unit)/unit;\n\txy = 3.*xy*xy-2.*xy*xy*xy;\n\tfloat a = rand((ij+vec2(0.,0.)));\n\tfloat b = rand((ij+vec2(1.,0.)));\n\tfloat c = rand((ij+vec2(0.,1.)));\n\tfloat d = rand((ij+vec2(1.,1.)));\n\tfloat x1 = mix(a, b, xy.x);\n\tfloat x2 = mix(c, d, xy.x);\n\treturn mix(x1, x2, xy.y);\n}\n\nfloat pnoise(vec2 p, int res){\n\tfloat persistance = .4;\n\tfloat n = 0.;\n\tfloat normK = 0.;\n\tfloat f = 4.;\n\tfloat amp = 1.;\n\tfor (int i = 0; i<res; i++){\n\t\tn+=amp*noise(p, f);\n\t\tf*=2.;\n\t\tnormK+=amp;\n\t\tamp*=persistance;\n\t}\n\tfloat nf = n/normK;\n\treturn nf*nf*nf*nf;\n}\n\n\n// height function for terrain generation\nfloat f(vec2 p){\n    return clamp(pnoise(p*0.5, OCTAVES)*0.7, 0.01, 100.); // clamp see level at 0.01\n}\n\nfloat f(float x, float y){ // overloaded method of previous function\n\treturn f(vec2(x, y));\n}\n\n// ray marching for terrain detection\n// from : https://iquilezles.org/articles/terrainmarching\nbool castRay(in vec3 ro, in vec3 rd, out float resT){\n    float dt0 = 0.005;\n    float mint = 0.25;\n    float maxt = 4.;\n    \n    float lh = 0.;\n    float ly = 0.;\n    \n    vec3 p = ro;\n    \n    float dt = dt0;\n    for(float t = mint; t < maxt; t += dt){\n    \tp = ro + rd * t;\n        float h = f(p.xz);\n        \n        if(p.y < h){\n            resT = t - dt + dt*(lh-ly)/(p.y-ly-h+lh);\n            return true;\n        }\n        lh = h;\n        ly = p.y;\n        \n        dt = dt0 + 0.005*t;\n    }\n    return false;\n}\n\n// get the normal vector for a given point on the terrain\nvec3 getNormal( in vec3 p )\n{\n    float eps = 0.001;\n    return normalize( vec3( f(p.x-eps,p.z) - f(p.x+eps,p.z),\n                            2.0f*eps,\n                            f(p.x,p.z-eps) - f(p.x,p.z+eps) ) );\n}\n\n// give a random 2d vector\nvec2 rand2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// smooth animated voronoi for water rendering\n// adapted from : https://iquilezles.org/articles/smoothvoronoi\nfloat vor(in vec2 uv){\n    vec2 p = floor(uv);\n    vec2 f = fract(uv);\n\n    float res = 8.0;\n    for( int j=-1; j<=1; j++ )\n        for( int i=-1; i<=1; i++ )\n        {\n            vec2 b = vec2( i, j );\n            vec2 pt = rand2( p + b );\n            //animate the point\n            pt = 0.5+0.5*sin(pt*6. + iTime*5.);\n            vec2  r = vec2( b ) - f + pt;\n            float d = dot( r, r );\n\n            res += 1.0/pow( d, 8.0 );\n        }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nfloat fw(float x, float y){\n    return vor(vec2(x, y)*75.)*0.0005;// only a small variation in height\n}\n\n// get the normal vector on water based on voronoi height map\nvec3 getNormalWater( in vec3 p )\n{\n    float eps = 0.001;\n    return normalize( vec3( fw(p.x-eps,p.z) - fw(p.x+eps,p.z),\n                            2.0f*eps,\n                            fw(p.x,p.z-eps) - fw(p.x,p.z+eps) ) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // pixel color\n    vec3 col = vec3(0.);\n    \n    // camera movements\n    float time = iTime * 0.01;\n    float c2 = cos(time);\n    c2 *= c2;\n    float s2 = sqrt(2.);\n    float cx = 6.*s2*sin(time)/(1.+c2);\n    float cz = 6.*s2*sin(time)*cos(time)/(1.+c2);\n\t\n    // ray\n    vec3 ro = vec3(cx, 0., cz);\n    float h = f(ro.xz);\n    ro.y = 0.5 + h;\n    vec3 rd = normalize(vec3(uv, 1.));\n    \n    // rotate the ray\n    rd.yz *= rot(0.35);\n    rd.xz *= rot(2.*sin(iTime*0.1));\n    \n    const vec3 sky = vec3(0.65, 0.6, 0.55); // sky color\n    const vec3 sun = normalize(vec3(1., 1., 0.)); // sun direction\n    \n    float t = 10.;\n    float t1; // keep track of the first distance, for the fog\n    if(castRay(ro, rd, t)){\n        t1 = t;\n        vec3 p = ro + rd * t;\n        \n        bool calcColor = true;\n        bool hitWater = false;\n        \n        vec3 nml; // normal vector\n        \n        if(p.y-0.001 <= 0.01){ // if the ray hits the water level\n            hitWater = true;\n            \n            nml = getNormalWater(p);\n            \n            rd = reflect(rd, nml); // reflect the ray\n            \n            if(castRay(p, rd, t)){ // if the ray hits the terrain again\n                p = p + rd * t;\n                hitWater = false;\n            } else {\n                calcColor = false;\n            }\n        }\n        \n        if(calcColor){ // calculate terrain coloring if the ray ends on it\n            vec3 tex1 = texture(iChannel0, p.xz*2.).rgb;\n            vec3 tex2 = texture(iChannel1, p.xz).rgb;\n\n            if(!hitWater) nml = getNormal(p);\n\n            float ud = clamp(dot(vec3(0., 1., 0.), nml), 0., 1.);\n            ud = pow(ud, 12.);\n\n            vec3 grass = vec3(0.5, 1., 0.5);\n            vec3 rock = vec3(0.6, 0.55, 0.5);\n            vec3 sand = vec3(1.2, 1.2, 0.8);\n\n            col = grass * (tex2 + tex1) / 1.5 * ud;\n            col += rock * (1.-ud) * tex1.rrr;\n\n            col = mix(col, vec3(1.), smoothstep(0.1, 0.15, p.y)*ud);\n            \n            float v = texture(iChannel0, p.xz*20.).r;\n            col = mix(sand * v, col, smoothstep(0.01, 0.0155, p.y));\n\n            float nd = clamp(dot(nml, sun), 0., 1.);\n            col *= (nd*(2.-ud));\n        } else {\n            float nd = clamp(dot(nml, sun), 0., 1.);\n            col = sky * nd;\n        }\n        \n        if(hitWater) col = mix(col, vec3(0., 0.35, 0.7), 0.1); // add blue color to water\n        \n        col = clamp(col, 0., 1.);\n        col = mix(col, sky, smoothstep(0.5, 4.5, t1)); // fog based on ray hit distance\n    } else {\n    \tcol = sky;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}