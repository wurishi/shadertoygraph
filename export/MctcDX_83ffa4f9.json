{"ver":"0.1","info":{"id":"MctcDX","date":"1731293584","viewed":77,"name":"Moroccan Amazigh Symbols","username":"Kodadi","description":"This shader generates an evolving, symmetrical pattern using a random walk influenced by smooth noise, creating dynamic, balanced visuals.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["perlinnoise","glsl","shader","symmetry","generativeart","noisefunction","proceduralanimation","realtimegraphics","dynamiccolors"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This shader generates an evolving, symmetrical pattern using a random walk influenced by smooth noise, creating dynamic, balanced visuals.\n// Each line’s position, thickness, and color change over time, producing a vibrant, continuously shifting motif.\n// The pattern stays centered, square, and undistorted across screen sizes, maintaining its harmonious look.\n// Created by Jawhar Kodadi - https://jawharkodadi.com\n\n// Fonction pour générer un bruit lisse avec un hash stable\nfloat hash11(float x) {\n    return fract(x*43758.5453123);\n}\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash11(i), hash11(i + 1.0), u);\n}\n\n// Palette de couleurs évoluant dans le temps\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n    // Inclure le temps pour faire évoluer les couleurs\n    return a + b * cos(6.28318 * (c * t + d + iTime * 0.1));\n}\n\n// Directions pour le chemin aléatoire\nconst vec2 directions[8] = vec2[8](\n    vec2(1, 0),    // droite\n    vec2(0, -1),   // haut\n    vec2(0, 1),    // bas\n    vec2(-1, 0),   // gauche\n    vec2(1, 1),    // diagonale bas droite\n    vec2(-1, -1),  // diagonale haut gauche\n    vec2(1, -1),   // diagonale haut droite\n    vec2(-1, 1)    // diagonale bas gauche\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // Calcul des coordonnées UV pour maintenir le motif carré et centré\n    float m = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / m * 2.0;\n\n    // Appliquer la symétrie\n    vec2 uvSym = abs(uv);\n\n    vec3 finalColor = vec3(0.0);\n\n    // Paramètres\n    const float maxEdges = 28.0;\n    const float gridSize = 8.0;\n    const float edgesBreak = 12.0;\n\n    vec2 pos = vec2(1.0, 1.0);\n    vec2 prevPos = pos;\n\n    // Ralentir l'animation\n    float time = iTime * 0.2; // Ajuster ce facteur pour ralentir ou accélérer\n\n    for (float i = 0.0; i < maxEdges; i += 1.0) {\n\n        // Introduire le temps dans perlinOffsetPos pour faire évoluer les positions\n        float perlinOffsetPos = i * 0.1 + iTime * 0.05;\n\n        // Pause dans le chemin à intervalles réguliers\n        if (mod(i, edgesBreak) == 0.0) {\n            // Réinitialiser la position avec du bruit\n            pos = vec2(noise(perlinOffsetPos + i * 0.4), noise(perlinOffsetPos + i * 0.5)) * gridSize;\n            prevPos = pos;\n            continue;\n        }\n\n        // Choisir une direction basée sur le bruit\n        float dirIndex = floor(noise(perlinOffsetPos) * 8.0);\n        int idx = int(mod(dirIndex, 8.0));\n        vec2 dir = directions[idx];\n\n        prevPos = pos;\n        pos += dir;\n\n        // Garder la position dans les limites de la grille\n        pos = mod(pos + gridSize, gridSize);\n\n        // Transformer les positions en coordonnées normalisées\n        vec2 p1 = (prevPos / gridSize) * 2.0 - 1.0;\n        vec2 p2 = (pos / gridSize) * 2.0 - 1.0;\n\n        // Appliquer la symétrie\n        vec2 p1Sym = abs(p1);\n        vec2 p2Sym = abs(p2);\n\n        // Calculer la distance minimale du pixel au segment de ligne\n        vec2 p = uvSym;\n        vec2 a = p1Sym;\n        vec2 b = p2Sym;\n        vec2 pa = p - a;\n        vec2 ba = b - a;\n        float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n        float d = length(pa - ba * h);\n\n        // Utiliser le temps dans l'épaisseur et la couleur\n        float perlinOffset = time + i * 0.1;\n\n        // Calculer l'épaisseur de la ligne basée sur le bruit\n        float thickness = mix(0.005, 0.05, noise(perlinOffset + i * 0.8));\n\n        // Calculer la couleur basée sur le bruit et le temps\n        float t = noise(perlinOffset + i * 0.3);\n        vec3 col = palette(t);\n\n        // Accumuler la couleur finale\n        finalColor += col * exp(-d / thickness);\n    }\n\n    fragColor = vec4(finalColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}