{"ver":"0.1","info":{"id":"4cS3Dm","date":"1704271797","viewed":15,"name":"zzzcode and phind LAG warning","username":"AIFunnyTests","description":"LAG WARNING!!","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ai"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float recursiveTetrahedron(vec3 pos) {\n   vec3 a1 = vec3(1,1,1);\n   vec3 a2 = vec3(-1,-1,1);\n   vec3 a3 = vec3(1,-1,-1);\n   vec3 a4 = vec3(-1,1,-1);\n   vec3 c;\n   int n = 0;\n   float dist, d;\n   while (n < 16) { // Number of iterations\n       c = a1; dist = length(pos-a1);\n       d = length(pos-a2); if (d < dist) { c = a2; dist=d; }\n       d = length(pos-a3); if (d < dist) { c = a3; dist=d; }\n       d = length(pos-a4); if (d < dist) { c = a4; dist=d; }\n       pos = 2.0*pos-c;\n       n++;\n   }\n   return length(pos)*pow(2.0, float(-n));\n}\n\nmat3 rotationMatrix(float angle) {\n   float s = sin(angle);\n   float c = cos(angle);\n   return mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Convert pixel coordinates to normalized coordinates\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Define camera properties\n    vec3 cameraPos = vec3(0.0, 0.0, -1.0);\n    vec3 cameraDir = normalize(vec3(uv * 2.0 - 1.0, 1.0)) * rotationMatrix(iTime);\n    cameraPos.z += sin(iTime);\n    \n    // Define fractal properties\n    float maxDistance = 1000.0;\n    float minDistance = 0.001;\n    float epsilon = 0.001;\n    \n    // Raymarching loop\n    float distance = minDistance;\n    for (int i = 0; i < 100; i++)\n    {\n        vec3 rayPos = cameraPos + distance * cameraDir;\n        \n       // Distance estimation function for the fractal\n        float dist = recursiveTetrahedron(rayPos);\n        \n        // Check if the ray has hit the fractal\n        if (dist < epsilon)\n        {\n            // Calculate shading based on distance\n            float shade = 1.0 - smoothstep(0.0, epsilon, dist);\n            \n            // Add color variation based on position\n            vec3 color = vec3(0.5 + 0.5 * sin(rayPos.x), 0.5 + 0.5 * sin(rayPos.y), 0.5 + 0.5 * sin(rayPos.z));\n            \n            // Calculate lighting\n            vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n            float diffuse = max(dot(normalize(vec3(dist, 0.0, 0.0)), lightDir), 0.0);\n            \n            // Set the color of the pixel\n            fragColor = vec4(color * shade * diffuse, 1.0);\n            return;\n        }\n        \n        // Increment the distance\n        distance += dist;\n        \n        // Break if the distance exceeds the maximum distance\n        if (distance > maxDistance)\n        {\n            break;\n        }\n    }\n    \n    // Set the background color\n    fragColor = vec4(1.0, 1.0, 0.0, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}