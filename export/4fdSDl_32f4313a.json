{"ver":"0.1","info":{"id":"4fdSDl","date":"1714624024","viewed":85,"name":"Aliasing's CRT filter","username":"aliasing","description":"Just a CRT shader designed for varying beam thickness","likes":2,"published":1,"flags":0,"usePreview":1,"tags":["retro","pixel","tv"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec2 screensize = vec2(128.0, 64.0);\nconst float brightness = 0.6;\nconst vec2 blur_radius = vec2(2., 1.25);\nconst ivec2 blur_res = ivec2(15, 5);\n\nconst vec3 masks[3] = vec3[3](\n    vec3(1.,0.,0.),\n    vec3(0.,1.,0.),\n    vec3(0.,0.,1.)\n);\nconst float PI = 3.141592;\n\nvec3 crtpixel(vec2 uv) {\n    // screen coords\n    vec2 sc = floor(uv*screensize) / screensize;\n    // pixel (within-pixel) coords\n    vec2 pc = (uv - sc) * screensize;\n    \n    vec3 pixel = texture(iChannel0, sc).rgb;\n    \n    // emulate aperture grille look, plus color bleed\n    float bright = sin(pc.y * PI)*2.-1.;\n    int mask_pos = int(pc.x * 3.0 + sc.y*screensize.y);\n    vec3 mask = masks[mask_pos % 3];\n    \n    // improve perceptual linearity...\n    // shader is designed with intentional primary clipping in mind\n    vec3 color = 0.75 / (1.5 - pixel) - 0.5;\n    \n    return color * bright * mask;\n}\n\nfloat blur_kernel_v(float t) {\n  // sine window\n  return cos(t*PI);\n}\n\nfloat blur_kernel_h(float t) {\n  // sinc window\n  float tt = PI * 2.0 * t;\n  return sin(tt) / tt;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3(0.);\n    \n    // blur filter\n    for (int x=0; x<blur_res.x; ++x) {\n      for (int y=0; y<blur_res.y; ++y) {\n         vec2 pos = vec2(x,y) / vec2(blur_res) - 0.5;\n         vec2 offset = pos * blur_radius / screensize;\n         color += crtpixel(uv + offset) * blur_kernel_h(pos.x) * blur_kernel_v(pos.y);\n      }\n    }\n\n    // Output to screen\n    fragColor = vec4(color * brightness, 1.);\n}\n","name":"Image","description":"","type":"image"}]}