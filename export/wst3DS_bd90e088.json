{"ver":"0.1","info":{"id":"wst3DS","date":"1655163912","viewed":132,"name":"Fast Cbrt","username":"remotion","description":"https://github.com/Remotion/fast_roots/blob/master/cbrt.hpp","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["root","cbrt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// https://github.com/Remotion/fast_roots/blob/master/cbrt.hpp\n\n\nfloat acbrt(in float x0) {\n    uint ix = floatBitsToUint(x0); // as_int, x can be viewed as uint.\n    uint ix0 = ix; // value with sign \n    ix = ix & 0x7fffffffu; // abs \n    float abs_x = uintBitsToFloat(ix);\n\n    ix = ix / 4u + ix / 16u;      // Approximate divide by 3.\n    ix = ix + ix / 16u;\n    ix = ix + ix / 256u;\n    ix = 0x2a5137a0u + ix;        // Initial guess.\n\n    float x = uintBitsToFloat(ix); // as_float\n    x = 0.33333333 * (2.0 * x + abs_x / (x * x));  // Newton step.\n    x = 0.33333333 * (2.0 * x + abs_x / (x * x));  // Newton step.\n    x = 0.33333333 * (2.0 * x + abs_x / (x * x));  // Newton step.\n\t\n    ix = floatBitsToUint(x); \t\n    ix = ix | (ix0 & 0x80000000u); // copysign\n    return uintBitsToFloat(ix); // as_float\n}\n\n///  cbrt \n// can also be computer slowly as  \"sign(f)*pow(abs(f), 1.0 / 3.0)\"\nfloat cbrt(float f) { // fast \n    if (f == 0.0) { return f; } // special case\n\n    // cube root approximation using bit hack for 32-bit float\n    uint u = floatBitsToUint(f); // as_uint\n    u = u & 0x7fffffffu; // abs, need to do abs here to handle negative values\n    u = u / 3u + 709921077u; // idiv, add\n    float a = uintBitsToFloat(u); // as_float\n\n    // 1 iteration cube root approximation using Halley's method\n    float a3 = a * a * a; // 2x mul\n    a = a * (a3 + f + f) / (a3 + a3 + f); // div, mul, 4x add\n     \n    // use second Halley iteration\n    // 2 iteration cube root approximation using Halley's method\n    a3 = a * a * a; // 2x mul\n    a = a * (a3 + f + f) / (a3 + a3 + f); // div, mul, 4x add\n\n    // use third Halley iteration.\n    // 3 iteration cube root approximation using Halley's method\n    a3 = a * a * a; // 2x mul\n    a = a * (a3 + f + f) / (a3 + a3 + f); // div, mul, 4x add\n\n    return a;\n}\n\nvec2 cbrt(vec2 f) { // fast \n    if (f == vec2(0.0)) { return f; } // special case\n    // cube root approximation using bit hack for 32-bit float\n    uvec2 u = floatBitsToUint(f); // need to do abs here to handle negative values\n    u = u & 0x7fffffffu; // abs \n    u = u / 3u + 709921077u; // idiv, add\n    vec2 a = uintBitsToFloat(u);\n    // 1 iteration cube root approximation using Halley's method\n    vec2 a3 = a * a * a; // 2x mul\n    a = a * (a3 + f + f) / (a3 + a3 + f); // div, mul, 4x add\n    // 2 iteration cube root approximation using Halley's method\n    a3 = a * a * a; // 2x mul\n    a = a * (a3 + f + f) / (a3 + a3 + f); // div, mul, 4x add\n    // 3 iteration cube root approximation using Halley's method\n    a3 = a * a * a; // 2x mul\n    a = a * (a3 + f + f) / (a3 + a3 + f); // div, mul, 4x add\n    return a;\n}\n\nvec3 cbrt(vec3 f) { // fast \n    if (f == vec3(0.0)) { return f; } // special case\n    // cube root approximation using bit hack for 32-bit float\n    uvec3 u = floatBitsToUint(f); // need to do abs here to handle negative values\n    u = u & 0x7fffffffu; // abs \n    u = u / 3u + 709921077u; // idiv, add\n    vec3 a = uintBitsToFloat(u);\n    // 1 iteration cube root approximation using Halley's method\n    vec3 a3 = a * a * a; // 2x mul\n    a = a * (a3 + f + f) / (a3 + a3 + f); // div, mul, 4x add\n    // 2 iteration cube root approximation using Halley's method\n    a3 = a * a * a; // 2x mul\n    a = a * (a3 + f + f) / (a3 + a3 + f); // div, mul, 4x add\n    // 3 iteration cube root approximation using Halley's method\n    a3 = a * a * a; // 2x mul\n    a = a * (a3 + f + f) / (a3 + a3 + f); // div, mul, 4x add\n    return a;\n}\n\nvec4 cbrt(vec4 f) { // fast \n    if (f == vec4(0.0)) { return f; } // special case\n    // cube root approximation using bit hack for 32-bit float\n    uvec4 u = floatBitsToUint(f); // need to do abs here to handle negative values\n    u = u & 0x7fffffffu; // abs \n    u = u / 3u + 709921077u; // idiv, add\n    vec4 a = uintBitsToFloat(u);\n    // 1 iteration cube root approximation using Halley's method\n    vec4 a3 = a * a * a; // 2x mul\n    a = a * (a3 + f + f) / (a3 + a3 + f); // div, mul, 4x add\n    // 2 iteration cube root approximation using Halley's method\n    a3 = a * a * a; // 2x mul\n    a = a * (a3 + f + f) / (a3 + a3 + f); // div, mul, 4x add\n    // 3 iteration cube root approximation using Halley's method\n    a3 = a * a * a; // 2x mul\n    a = a * (a3 + f + f) / (a3 + a3 + f); // div, mul, 4x add\n    return a;\n}\n\n// 2D function plotter ----------------------------------------------\n\n// function to sample\nfloat f(float x) {\n    //return acbrt(x);\n    return cbrt(x);   \n    //return sign(x)*pow(abs(x), 1.0 / 3.0); // slow cbrt\n    //return sqrt(abs(x));\n}\n\n// CONFIGURATION ----------------------------------------------------\n\n// function sampling range\nvec2 xRange = vec2(-8.0, 8.0);\n// drawn range of the Y axis\nvec2 yRange = vec2(-8.0, 8.0);\n\n// if true, shader will attempt scaling the plot on the Y axis automatically; if false, yRange is used\nconst bool autoYScaling = false;\n// if true, plot can be padded using the mouse\nconst bool mousePadding = true; // true\n\n// colours\nconst vec3 background = vec3(0.0, 0.05, 0.0);\nconst vec3 functionHot = vec3(0.8, 0.0, 0.0);\nconst vec3 functionCold = vec3(0.0, 0.0, 0.8);\nconst vec3 axes = vec3(0.8, 0.8, 0.8);\n\n// function plot line thickness in pixels\nconst float thickness = 2.0;\nconst float axis_thickness = 1.5;\n\nconst bool animated_point = true;\n// function plot-following dot thickness in pixels\nconst float dotThickness = 3.5;\n\n// IMPLEMENTATION ---------------------------------------------------\n\n// @return\tA vec2 containing a min (.x) and max (.y) values of the function computed via linear sampling.\nvec2 autoscale() {\n\tconst int xRes = 128;\t// FIXME: how to make this rely on iResolution.x?\n\tvec2 range = vec2(0.0);\n\tfloat x, y;\n\tfor (int i = 0; i < xRes; ++i) {\n\t\tx = xRange.x + (xRange.y - xRange.x) * (float(i) / float(xRes - 1));\n\t\ty = f(x);\n\t\trange.x = min(y, range.x);\n\t\trange.y = max(y, range.y);\n\t}\n\t// expand the range by a bit pixels for improved readability\n\treturn range * vec2(1.05);\n}\n\n// @return\tGiven relative real Y value converted to pixels.\nfloat realYToPixels(float real) {\n\treturn real / (yRange.y - yRange.x) * iResolution.y;\n}\n\n// @return\tGiven relative real X value converted to pixels.\nfloat realXToPixels(float real) {\n\treturn real / (xRange.y - xRange.x) * iResolution.x;\n}\n\n// @return\tAlpha for a pixel which is dist away for a given max allowed radius.\nfloat coverage(float dist, float radius) {\n\tradius *= 0.5;\n\treturn 1.0 - smoothstep(floor(radius), radius, dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 actualYRange = (autoYScaling) ? autoscale() : yRange;\n\t\n\t// allow padding the plot with the mouse\n\tif (mousePadding) {\n\t\txRange -= 5.0 * (iMouse.xx / (iResolution.x) - 0.5);\n\t\tactualYRange -= 5.0 * (iMouse.yy / (iResolution.y) - 0.5);\n\t}\n\t\n\tfloat x = xRange.x + (xRange.y - xRange.x) * (fragCoord.x / iResolution.x);\n\tfloat y = f(x);\n\t\n\tfloat actualY = actualYRange.x + (actualYRange.y - actualYRange.x) * (fragCoord.y / iResolution.y);\n\t\n\t// plot dot :)\n\tfloat dotX = 0.0;\n    if (animated_point) dotX = xRange.x + fract(iTime) * (xRange.y - xRange.x);\n\t// function heat\n\tfloat heat = (x - dotX) / (xRange.y - xRange.x);\n\tif (heat < 0.0) heat += 1.0;\n\tvec3 funcColour = mix(functionCold, functionHot, heat);\n\t// plot colour\n\tfloat distY = abs(y - actualY);\n\tvec4 plot = vec4(funcColour, coverage(realYToPixels(distY), thickness));\n\t// plot dot, continued\n\tfloat distX = abs(x - dotX);\n\tfloat dist = sqrt(distY * distY + distX * distX);\n\t// composition\n\tplot = mix(plot, vec4(functionHot, 1.0), coverage(realYToPixels(dist), dotThickness));\n\t\n\t// axis colour\n\tvec4 xAxis = vec4(axes, coverage(realXToPixels(abs(x)), axis_thickness));\n\tvec4 yAxis = vec4(axes, coverage(realYToPixels(abs(actualY)), axis_thickness));\n\tvec4 axis = xAxis * xAxis.a + yAxis * yAxis.a;\n\t\n\tvec4 foreground = mix(axis, plot, plot.a);\n\tfragColor = mix(vec4(background,1.0), foreground, foreground.a);\n}","name":"Image","description":"","type":"image"}]}