{"ver":"0.1","info":{"id":"ftdBWj","date":"1663646132","viewed":108,"name":"Animated Voronoi Diagram","username":"Yoshiapolis","description":"An animated Voronoi diagram using the distance metric (x^p + y^p) ^ 1/p","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","animated","distance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SEED 12.01\n#define power mod(iTime/2.,10.)\n#define INF 1000000.\n#define POINT_SIZE 5.\n#define TWO_PI 6.28318530718\n#define BORDER_SAMPLES 3.\n#define BORDER_RADIUS 3.\n#define NUM_POINTS 40\n\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\n\nfloat x(int point) { return iResolution.x * rand(SEED + float(point * 3)); }\nfloat y(int point) { return iResolution.y * rand(SEED + float(point * 3 + 1)); }\nfloat hue(int point) { return 360. * rand(SEED + float(point * 3 + 2)); }\n\nvec3 HSVtoRGB(float H, float S, float V) {\n    float s = S/100.;\n    float v = V/100.;\n    float C = s*v;\n    float X = C*(1.-abs(mod(H/60.0, 2.)-1.));\n    float m = v-C;\n    \n    vec3 rgb;\n\n    if(H >= 0. && H < 60.) rgb = vec3(C, X, 0);\n    else if(H >= 60. && H < 120.) rgb = vec3(X, C, 0);\n    else if(H >= 120. && H < 180.) rgb = vec3(0, C, X);\n    else if(H >= 180. && H < 240.) rgb = vec3(0, X, C);\n    else if(H >= 240. && H < 300.) rgb = vec3(X, 0, C);\n    else rgb = vec3(C, 0, X);\n    \n    return rgb + m;\n}\n\nfloat dist(int point, vec2 pos, float p) {\n    vec2 d = abs(vec2(x(point), y(point)) - pos.xy);\n    d = pow(d, vec2(p));\n    \n    return pow(d.x + d.y, 1.0/p);\n}\n\nfloat dist(int point, vec2 pos) { return dist(point, pos, power); }\nfloat euclideanDist(int point, vec2 pos) { return dist(point, pos, 2.); }\n\nint getClosestPoint(vec2 pos) {\n    float minDist = INF;\n    int closestPoint = 0;\n\n    for(int i = 0; i < NUM_POINTS; i ++) {\n        float dist = dist(i, pos);\n        if(dist < minDist) {\n            minDist = dist;\n            closestPoint = i;\n        }\n    }\n\n    return closestPoint;\n}\n\nfloat getBorderIntensity(int closestPoint, float closestDist) {\n    float step = TWO_PI / float(BORDER_SAMPLES);\n    float intensity = 0.;\n    \n    for(float theta = 0.; theta < TWO_PI; theta += step) {\n        vec2 samplePos = gl_FragCoord.xy + BORDER_RADIUS * vec2(cos(theta), sin(theta));\n        int sampledClosestPoint = getClosestPoint(samplePos);\n        if(sampledClosestPoint != closestPoint)\n            return 1.;\n    }\n\n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    int closestPoint = getClosestPoint(fragCoord.xy);\n    float closestDist = euclideanDist(closestPoint, fragCoord.xy);\n    float pointBlending = clamp((closestDist - POINT_SIZE)/2., 0.0, 1.0);\n    float borderBlending = clamp(getBorderIntensity(closestPoint, closestDist), 0.0, 1.0);\n    \n    const vec3 pointColor = vec3(1.0);\n    const vec3 borderColor = vec3(0.0);\n    vec3 fillColor = HSVtoRGB(hue(closestPoint), 100., 100.);\n    \n    fragColor = vec4(mix(mix(pointColor, fillColor, pointBlending), borderColor, borderBlending), 1.0);\n}","name":"Image","description":"","type":"image"}]}