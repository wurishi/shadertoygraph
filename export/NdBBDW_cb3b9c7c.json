{"ver":"0.1","info":{"id":"NdBBDW","date":"1646355164","viewed":612,"name":"Opalescent subsurface scattering","username":"Suslik","description":"A simple subsurface scattering test. Physics is similar to\n\"Extending the Disney BRDF to a BSDF with\nIntegrated Subsurface Scattering\nby B.Burley at al\"\nhttps://blog.selfshadow.com/publications/s2015-shading-course/burley/s2015_pbs_disney_bsdf_notes.pdf","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["subsurfacescattering","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    vec4 accumulated_color = texture(iChannel0, uv);\n    vec3 linear_color = accumulated_color.rgb / (1e-7f + accumulated_color.a);\n    vec3 srgb_color = pow(linear_color, vec3(1.0f / 2.2f));\n    fragColor = vec4(srgb_color, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct Coords\n{\n    vec3 pos;\n    mat3 to_global;\n};\n\nCoords BuildEulerCoords(vec3 pos, vec2 angs, float dist)\n{\n    Coords cam;\n    \n    mat3 global_from_cam;\n    global_from_cam[2] = vec3(-sin(angs.x) * cos(angs.y), sin(angs.y), cos(angs.x) * cos(angs.y));\n    global_from_cam[0] = normalize(cross(vec3(0.0f, 1.0f, 0.0f), global_from_cam[2]));\n    global_from_cam[1] = cross(global_from_cam[2], global_from_cam[0]);\n    \n    cam.to_global = global_from_cam;\n    cam.pos = pos + cam.to_global * vec3(0.0f, 0.0f, -dist);\n    return cam;\n}\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 dir;\n};\n\nRay GetCamRay(Coords cam, vec2 uv, vec2 half_fov_tan)\n{\n    vec3 local_ray = normalize(vec3((uv.x - 0.5f) * 2.0f * half_fov_tan.x,  (uv.y - 0.5f) * 2.0f * half_fov_tan.y, 1.0f));\n    Ray ray;\n    ray.dir = cam.to_global * local_ray;\n    ray.origin = cam.pos;\n    return ray;\n\n}\n\nvec3 hash33( vec3 p )\n{\n    /*float max_int = float(0xffffffffu);\n    return vec3(pcg3d(uvec3(p * 32768.0f))) / max_int;*/\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(p)*43758.5453123);\n}\n\nvec3 GetRandomSpherePoint(vec2 seed)\n{\n    vec3 point;\n    point.z = seed.x * 2.0f - 1.0f;\n    float ang = seed.y * 2.0f * 3.1415f;\n    point.xy = sqrt(max(0.0f, 1.0f - point.z * point.z)) * vec2(cos(ang), sin(ang));\n    return point;\n}\n\n//from https://iquilezles.org/articles/distfunctions\nfloat BoxSdm( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat SphereSdm(vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\nstruct VolumeData\n{\n    float albedo;\n    float scatter;\n    float refraction_index;\n    vec3 normal;\n};\n\nfloat GetSceneSdm(vec3 pos)\n{\n    return length(pos) - 0.5f + simplex3d(pos * 2.0f) * 0.5f;\n    return min(\n        BoxSdm(pos - vec3(0.0f, -0.0f, 0.0f), vec3(0.5f, 0.5f, 0.5f)),\n        /*BoxSdm(pos - vec3(0.0f, 0.5f, 0.0f), vec3(1.3f, 0.1f, 0.1f))*/SphereSdm(pos - vec3(0.0f, 0.5f, 0.0f), 0.1f));\n}\n\nVolumeData GetSceneData(vec3 pos, int wavelength_channel)\n{\n    vec3 albedo_color = vec3(0.0f, 0.5f, 0.9f) * 1.0f;\n    vec3 scatter_color = vec3(0.3f, 0.1f, 0.3f) * 25.0f;\n    /*vec3 albedo_color = vec3(0.1f, 0.8f, 0.9f) * 1.0f;\n    vec3 scatter_color = vec3(2.0f, 1.0f, 0.4f) * 5.0f;*/\n    /*vec3 albedo_color = vec3(0.0f, 0.5f, 0.9f);\n    vec3 scatter_color = vec3(0.3f, 0.05f, 0.2f) * 25.0f;*/\n    float scene_sdm = GetSceneSdm(pos);\n    VolumeData data;\n    data.refraction_index = 1.3f * (1.0f + 0.002f * float(wavelength_channel));\n    if(scene_sdm > 0.0f)\n    {\n        albedo_color = vec3(0.0f);\n        scatter_color = vec3(0.0f);\n        data.refraction_index = 1.0f;\n    }\n    data.albedo = albedo_color[wavelength_channel];\n    data.scatter = scatter_color[wavelength_channel];\n    float eps = 1e-5f;\n    data.normal = normalize(vec3(\n        GetSceneSdm(pos + vec3(eps, 0.0f, 0.0f)) - scene_sdm,\n        GetSceneSdm(pos + vec3(0.0f, eps, 0.0f)) - scene_sdm,\n        GetSceneSdm(pos + vec3(0.0f, 0.0f, eps)) - scene_sdm));\n    \n    return data;\n}\n\nvec3 GetRefractedDir(vec3 ray_dir, vec3 normal, float n1, float n2)\n{\n    vec3 refracted_ray_dir = ray_dir;\n\n    float r = n1 / max(1.0f, n2);\n    float c = -dot(ray_dir, normal);\n\n    float tmp = 1.0f - r * r * (1.0f - c * c);\n    if(tmp > 0.0f)\n    {\n        refracted_ray_dir = r * ray_dir + (r * c - sqrt(tmp)) * normal;\n    }\n    return refracted_ray_dir;\n}\n\nfloat GetReflectionCoefficient(vec3 ray_dir, vec3 normal, float refraction_ratio)\n{\n    //return saturate(f0 + pow(1.0 + clamp(dot(normalize(ray_dir), normalize(surfaceNormal)), -1.0f, 0.0f), 3.0));\n    //return 0.02f + pow(1.0 + clamp(dot(normalize(ray_dir), normalize(surfaceNormal)), -1.0f, 0.0f), 3.0) * 0.8;\n    //return 0.01f + pow(1.0 + clamp(dot(normalize(ray_dir), normalize(surfaceNormal)), -1.0f, 0.0f), 3.0) * 0.8;\n    float fZero = pow(abs((1.0f - (1.0f / refraction_ratio)) / (1.0f + (1.0f / refraction_ratio))), 2.0f);\n    float base = max(0.0f, 1.0f + dot(ray_dir, normal)); // better do the max here. (According to the OptiX source code not a bad idea as there are cases which yield artifacts if omitted.)\n    float e = pow(base, 5.0f);\n    return clamp((fZero + (1.0f - fZero) * e) * 3.0f, 0.0f, 1.0f);\n}\n\nvec3 GetEnvironmentLight(vec3 origin, vec3 dir)\n{\n    //if(dir.y > 0.95f && length(origin.xz) < 0.1f) return vec3(150.0f); else return vec3(0.0f);\n    return pow(textureLod(iChannel0, dir, 0.0f).rgb, vec3(2.2f));\n}\n\nfloat PathTrace(Ray ray, int wavelength_channel, vec2 seed)\n{\n    float step_size = 0.05f;\n    vec3 curr_dir = ray.dir;\n    vec3 curr_pos = ray.origin + curr_dir * step_size * seed.y;\n    \n    float emission = 0.0f;\n    float transparency = 1.0f;\n    float prev_refraction_index = GetSceneData(curr_pos, wavelength_channel).refraction_index;\n    \n    for(int step_index = 0; step_index < 50; step_index++)\n    {\n        vec3 next_pos = curr_pos + curr_dir * step_size;\n        VolumeData curr_data = GetSceneData(curr_pos, wavelength_channel);\n        VolumeData next_data = GetSceneData(next_pos, wavelength_channel);\n        \n        vec3 sample_hash = hash33(vec3(seed, float(step_index)));\n        vec3 refraction_normal = dot(curr_dir, curr_data.normal) > 0.0f ? -curr_data.normal : curr_data.normal;\n        float refelection_coeff = GetReflectionCoefficient(curr_dir, refraction_normal, next_data.refraction_index / curr_data.refraction_index);\n        if(abs(next_data.refraction_index - curr_data.refraction_index) > 1e-2f)\n        {\n            if(sample_hash.y < refelection_coeff)\n            {\n                curr_dir = curr_dir - dot(curr_dir, refraction_normal) * refraction_normal * 2.0f;\n            }else\n            {\n                curr_dir = GetRefractedDir(curr_dir, refraction_normal, curr_data.refraction_index, next_data.refraction_index);\n            }\n        }\n        float sample_transparency = exp(-curr_data.scatter * step_size);\n        if(sample_hash.x > sample_transparency)\n        {\n            transparency *= curr_data.albedo;\n            curr_dir = GetRandomSpherePoint(hash33(sample_hash).xy);\n        }\n        curr_pos += curr_dir * step_size;\n    }\n    return emission + GetEnvironmentLight(curr_pos, curr_dir.xyz)[wavelength_channel] * transparency;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 angs = (iMouse.xy/iResolution.xy - 0.5f) * vec2(-6.5f, 6.5f);\n\n    Coords cam = BuildEulerCoords(vec3(0.0f, 0.0f, 0.0f), angs, 2.0f);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 half_fov_tan;\n    half_fov_tan.x = 1.0f;\n    half_fov_tan.y = half_fov_tan.x * iResolution.y / iResolution.x;\n    Ray cam_ray = GetCamRay(cam, uv, half_fov_tan);\n\n    \n    vec3 pixel_hash = hash33(vec3(uv, iTime));\n    vec4 prev_color = texture(iChannel1, uv);\n    //vec4 curr_color = vec4(hash33(vec3(uv, iTime)) * vec3(uv, 1.0f), 1.0f);\n    vec4 curr_color = vec4(\n       PathTrace(cam_ray, 0, pixel_hash.xy),\n       PathTrace(cam_ray, 1, pixel_hash.yz),\n       PathTrace(cam_ray, 2, pixel_hash.zx),\n       1.0f);\n    prev_color *= (iMouse.z <= 0.0f) ? 1.0f : 0.0f;\n    fragColor = prev_color + curr_color;\n    fragColor *= 0.9f;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n// http://www.jcgt.org/published/0009/03/02/\nuvec3 pcg3d(uvec3 v) {\n\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    return v;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n","name":"Common","description":"","type":"common"}]}