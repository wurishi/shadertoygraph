{"ver":"0.1","info":{"id":"3sjyW3","date":"1587437665","viewed":108,"name":"Day6: Using buffers","username":"fluxatron","description":"Mushed together a few of my shaders into buffers to learn how they work.\n","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["buffer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 map(vec2 uv, vec2 offset)\n{\n    return (uv - offset) / vec2(0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    if (uv.y > 0.5)\n\t\tfragColor = (uv.x < 0.5) \n        \t? texture(iChannel0, map(uv, vec2(0.0, 0.5)))  // Top Left\n        \t: texture(iChannel1, map(uv, vec2(0.5, 0.5))); // Top Right\n    else\n\t\tfragColor = (uv.x < 0.5)\n        \t? texture(iChannel2, map(uv, vec2(0.0, 0.0)))  // Bot Left\n    \t\t: texture(iChannel3, map(uv, vec2(0.5, 0.0))); // Bot Right\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nstruct Vertex\n{\n    vec2 pos;\n    float radius;\n};\n    \nfloat segment(in vec2 p, vec2 a, vec2 b, out float ratio)\n{\n\tvec2 ap = p - a;\n\tvec2 ab = b - a;\n\tratio = clamp(dot(ap,ab)/dot(ab,ab), 0.0, 1.0); // Project ap onto ab. Clamp to edges of line if we project beyond it.\n\treturn length( ap - ab*ratio ); // finds length of vec from p to the projection of p onto ab\n}\n\n// returns the distance of p from the taped thicc boi line. negative length indicates p is within the shape\nfloat taperedSegment(vec2 p, vec2 ap, float ar, vec2 bp, float br)\n{\n    float ratio; // Where we are along the line [0,1]. 0 means at a and 1 means b\n    float len = segment(p, ap, bp, ratio); // Compute len from the center line running from point a to b\n    \n    float v = mix(ar, br, ratio);\n    float dist = len - v;\n        \n\treturn dist;\n}\n\n\n// Shape /////////////////////////////////////////////////////////////////////////////////////////////////\nvec3 strokeCol = vec3(0.8,0.2,0.4);\nvec3 fillCol = vec3(0.7,0.3,0.6)*0.6;\nconst int numVerts = 7;\nVertex[] shape = Vertex[] (\n    Vertex(vec2(0.25,-0.1), 2.0), // bot left 2\n    Vertex(vec2( 0.0, 0.0), 4.0), // bot left\n    Vertex(vec2( 0.0, 1.0), 2.5), // top left\n    Vertex(vec2( 0.5, 0.5), 5.0), // pivot\n    Vertex(vec2( 1.0, 1.0), 2.5), // top right\n    Vertex(vec2( 1.0, 0.0), 4.0), // bot right\n    Vertex(vec2(0.75,-0.1), 2.0)  // bot right 2\n);\n\n// Finds the distance of P from the line A to B\nvec3 drawShape(vec2 p, mat3 tform, vec3 col, bool stroke, bool fill)\n{\n    float thicc = 0.01;\n    float strokeThicc = 0.008;\n    \n    for(int i = 1; i < numVerts; i++)\n    {\n        Vertex a = shape[i-1];\n        Vertex b = shape[i];\n    \tvec2 ap = (tform * vec3(a.pos, 1)).xy;\n    \tvec2 bp = (tform * vec3(b.pos, 1)).xy;\n        \n        float dist = taperedSegment(p, ap, thicc*a.radius, bp, thicc*b.radius);\n        if (dist < strokeThicc) \n        {\t\n            // stroke\n            col = mix(col, strokeCol, vec3(stroke));\n            \n            // fill\n            if (dist < 0.0) \n            {\n            \tcol = mix(col, fillCol, vec3(fill));\n            }\n        }\n    }\n     \n    return col;\n}\n\n// Move some verts around and scale radii for funsies\nvoid updateShape()\n{\n    shape[2].pos += 0.7 * vec2(0.2*sin(iTime), 0.1*cos(iTime));\n    shape[4].pos += 0.7 * vec2(0.2*-cos(iTime), 0.1*sin(iTime));\n    \n    for (int i = 0; i < numVerts; i++)\n    {\n        shape[i].radius += sin(float(i) + iTime * (1.0 + 0.5*shape[i].radius));\n    }\n}\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////\n/** \n\tMatrix notes\n \t- These are column major.\n\t- Although written as rows, think of them transposed as columns.\n\t- Concatenate transformations in reverse order. Eg. M=T*R*S; Will evaluate left to right (duh) \n\t  but the transformation order will be Scale, Rotate then Translate.\n**/\nmat3 createTranslationMat(vec2 translation)\n{\n    return mat3(vec3(1,0,0), \n                vec3(0,1,0), \n                vec3(translation,1));\n}\nmat3 createScaleMat(vec2 scale)\n{\n    return mat3(scale.x, 0, 0,\n                0, scale.y, 0,\n                0, 0,       1);\n}\nmat3 createRotationMat(float rad)\n{\n    return mat3(cos(rad), sin(rad), 0,\n               -sin(rad), cos(rad), 0,\n                0,        0,        1);\n}\nmat3 createAffineMat(vec2 translation, float rotation, vec2 scale)\n{\n    mat3 S = mat3(createScaleMat(scale));\n    mat3 R = mat3(createRotationMat(rotation));\n    mat3 T = createTranslationMat(translation);\n    return T*R*S;\n}\n\nmat3 matTranslate(mat3 m, vec2 translation)\n{\n    return m * createTranslationMat(translation);\n}\nmat3 matRotate(mat3 m, float rad)\n{\n    return m * createRotationMat(rad);\n}\nmat3 matScale(mat3 m, float scale)\n{\n    return m * createScaleMat(vec2(scale));\n}\nmat3 matScale(mat3 m, vec2 scale)\n{\n    return m * createScaleMat(scale);\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.yy;\n    vec2 uvNorm = fragCoord/iResolution.xy;\n\n    updateShape();\n    \n    // Shape tform - moves pivot to the middle of our shape\n    mat3 shapeMat = mat3(1);\n    shapeMat = matTranslate(shapeMat, vec2(-.5,-.5));\n    \n    // Model tform - moves/rotates and squishes our model\n    mat3 modelMat = mat3(1);\n\tmodelMat = matTranslate(modelMat, vec2(aspectRatio/2., 0.5));\n    modelMat = matRotate(modelMat, sin(iTime*0.7)*0.7);\n   \tmodelMat = matScale(modelMat, 0.5 + 0.08 * vec2(sin((iTime+3.0)*3.0), cos(iTime*3.0)));\n    \n    // View tform - pan the view about\n    mat3 viewMat = mat3(1);\n    viewMat = matTranslate(viewMat, 0.05 * vec2(2.0*sin(1.2*iTime+3.0), cos(iTime+5.0)) );\n    \n    // Draw\n    vec3 col = vec3(1);\n    col = viewMat * vec3(uvNorm,1)*0.2; // Draw background\n    col = drawShape(uv, viewMat*modelMat*shapeMat, col, true, false); // fill\n    col = drawShape(uv, viewMat*modelMat*shapeMat, col, false, true); // stroke. Done in 2 passes to hide interior strokes. Could be nicer :)\n    \n    fragColor = vec4(col,1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec2 map(vec2 uv, vec2 offset)\n{\n    return (uv - offset) / vec2(0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    if (uv.y > 0.5)\n\t\tfragColor = (uv.x < 0.5) \n        \t? texture(iChannel0, map(uv, vec2(0.0, 0.5)))  // Top Left\n        \t: texture(iChannel1, map(uv, vec2(0.5, 0.5))); // Top Right\n    else\n\t\tfragColor = (uv.x < 0.5)\n        \t? texture(iChannel2, map(uv, vec2(0.0, 0.0)))  // Bot Left\n    \t\t: texture(iChannel3, map(uv, vec2(0.5, 0.0))); // Bot Right\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\nconst vec3 gamma = vec3(2.2);\n\n// Palette (RGB 2.2 color space)\nvec3 green = vec3(81.0/255.0, 201.0/255.0, 150.0/255.0);\nvec3 darkGreen = vec3(0.0/255.0, 40.0/255.0, 19.0/255.0);\nvec3 headGreen = vec3(223.0/255.0, 252.0/255.0, 226.0/255.0);\n\nfloat aspectRatio;\nvec2 uv;\nvec2 uvAspect;\n\n\nvec3 ACESFitted(vec3 color);\n\nvec3 circle(vec2 samplePoint, vec2 center, float radius)\n{\n    vec2 sampleDisp = samplePoint - center;\n    float sampleLen2 = sampleDisp.x*sampleDisp.x + sampleDisp.y*sampleDisp.y;\n    float ratio = sampleLen2 / (radius*radius);\n\n    return vec3(1.0 - min(ratio,1.0));\n}\nvec3 background()\n{\n    // Flat shade\n    vec3 col = darkGreen;\n    float intensity = 2.0;\n    \n    // Grid lines\n    {\n        float thickness = 0.003;\n        float spacing = 0.065;\n        \n        // Compute first line pos\n        float leftBound = 0.0;\n    \tfloat firstX = leftBound - fract(iTime*0.4)*spacing;\n        \n        // Vertical Grid Lines\n        for (float x = firstX; x < aspectRatio; x += spacing)\n        {\n            if (uvAspect.x > (x-thickness) && uvAspect.x < (x+thickness))\n            {\n                col += darkGreen;\n            }\n        }\n        \n\t\t// Horizontal Grid Lines\n        for (float y = 0.0; y < 1.0; y += spacing)\n        {\n            if (uvAspect.y > (y-thickness) && uvAspect.y < (y+thickness))\n            {\n                col += darkGreen;\n            }\n        }\n    }\n    \n    return col * intensity;\n}\nfloat shape(float x, float offset) // x:[0,1]\n{\n    x += offset;\n    if (x > 1.0) x -= floor(x);\n    \n    float s1 = 0.15;         // flat\n    float s2 = s1 + 0.2;     // b1\n    float s3 = s2 + 0.34;     // flat\n    float s4 = s3 + 0.1;     // b2\n    float s5 = s4 + 0.03;    // flat\n    float s6 = s5 + 0.2;     // b3\n    \n    float y = 0.0;\n    \n    if (x < s1) { return 0.0; }\n    \n    if (x < s2)\n    {\n    \treturn 0.05 - 0.05*cos((x-s1)*30.0);\n    }\n    \n    if (x < s3) { return 0.0; }\n    \n    if (x < s4)\n    {\n    \treturn 0.02 - 0.02*cos((x-s3)*60.0);\n    }\n    \n    if (x < s5) { return 0.0; }\n    \n    if (x < s6)\n    {\n    \treturn 0.3*sin((x-s5)*35.0);\n    }\n    \n    if (x > 1.0) return -.4;\n}\nfloat wrapIntensity(float sampleX, float xMax, float h)\n{\n    float v = sampleX + xMax - h; // wrap\n    if (v > xMax) v -= xMax; // clamp to [0,xMax]\n    return v/xMax; // normalize\n}\nvec3 line()\n{   \n    float repeats = 3.0;\n    float scanRate = 0.18;\n\tfloat intensity = 1.5;\n    float offset = iTime*0.1;\n    \n    vec3 col = vec3(0,0,0);\n    \n    // Calc head position\n    float x =  aspectRatio * (scanRate*iTime - floor(scanRate*iTime)); // x:[0,aspectRatio)\n\tfloat yOffset = 0.5;\n    \n    vec2 headPos = vec2(x, yOffset + shape(x * repeats/aspectRatio, offset));\n    vec2 linePos = vec2(uvAspect.x, yOffset + shape(uvAspect.x * repeats/aspectRatio, offset));\n    \n    // Line\n    float thickness = 0.015/2.0;\n    if (uv.y > linePos.y - thickness && uv.y < linePos.y + thickness)\n    {\n        col = green * pow(wrapIntensity(linePos.x, aspectRatio, headPos.x), 2.0);\n    }\n    \n    // Glowing Head\n    vec3 mask = pow(circle(uvAspect, headPos, 0.2), vec3(200.0));\n    col += 2.0 * headGreen * mask;\n    \n    return col * intensity;\n}\n\nvec3 vignette()\n{\n    float darkest = 0.00;\n    vec3 shade = circle(uvAspect, vec2(aspectRatio/2.0, 0.5), 0.85);\n    return darkest + (1.0-darkest)*shade;\n}\nvoid linearizePallete()\n{\n    green = pow(green, gamma);\n    darkGreen = pow(darkGreen, gamma);\n    headGreen = pow(headGreen, gamma);\n}\n\nvec3 flicker(vec3 col)\n{\n    return col * (1.0 + 0.03*sin(iTime*50.0) + 0.04*sin(iTime*29.0) ); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Globals\n    linearizePallete();\n    aspectRatio = iResolution.x / iResolution.y;\n    uv = (fragCoord / iResolution.xy);       // w:[0,1], h:[0,1]\n    uvAspect = (fragCoord / iResolution.yy); // w:[0,apsect], h:[0,1]\n    \n    // Set color\n    vec3 col = vec3(0,0,0);\n    col += background();\n    col += line();\n    col = flicker(col);\n    col *= vignette();\n    \n    // Post\n\tcol *= 1.5; // exposure bias\n  \tcol = ACESFitted(col); // tonemap \n    col = pow(col, 1.0/gamma); // gamma\n    \n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// ACES Tonemap: https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n\nconst mat3 ACESInputMat = mat3(\n\t0.59719, 0.07600, 0.02840, \n\t0.35458, 0.90834, 0.13383,\n\t0.04823, 0.01566, 0.83777\n);\nconst mat3 ACESOutputMat = mat3(\n\t 1.60475, -0.10208, -0.00327,\n\t-0.53108,  1.10813, -0.07276,\n\t-0.07367, -0.00605,  1.07602\n);\nvec3 RRTAndODTFit(vec3 v)\n{\n\tvec3 a = v * (v + 0.0245786f) - 0.000090537f;\n\tvec3 b = v * (0.983729f * v + 0.4329510f) + 0.238081f;\n\treturn a / b;\n}\nvec3 ACESFitted(vec3 color)\n{\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit(color);\n\tcolor = ACESOutputMat * color;\n\tcolor = clamp(color,0.0,1.0);\n\treturn color;\n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XdfGR8","channel":0}],"code":"#define MAX_STEPS 200\n#define MAX_DIST 200.0\n#define SURFACE_DIST 0.005\n\n// TYPES ///////////////////////////////////////////////////////////////////////////////////////////////////\nstruct Ray\n{\n    vec3 Origin;\n    vec3 Direction;\n};\n/*struct Material\n{\n    vec3 Color;\n};\nstruct Hit\n{\n    vec3 Point;\n    float Distance;\n    Material Material;\n};*/\nstruct Light\n{\n    vec3 Pos;\n    vec3 Color;\n    float Intensity;\n};\n    \n    \nstruct Hit\n{\n    float Dist;\n    vec3 Color;\n};\n    \n// FUNCS ///////////////////////////////////////////////////////////////////////////////////////////////////\n    \nHit GetDist(vec3 p)\n{\n    Hit closest;\n    \n    // Pivot\n    /*{\n        vec3 col = vec3(0.5,0.5,0.5);\n        vec4 shape = vec4(0,0,0, 0.25); // pos,radius\n        float dist = length(p - shape.xyz) - shape.w;\n       \n        closest.Dist = dist;\n        closest.Color = col;\n    }*/\n    \n    // Sphere X\n    {\n        vec3 col = vec3(1,0,0);\n        vec4 shape = vec4(-1.2,0,0, 0.5); // pos,radius\n        float dist = length(p - shape.xyz) - shape.w;\n       \n        //if (dist < closest.Dist)\n        {\n            closest.Dist = dist;\n        \tclosest.Color = col;\n        }\n    }\n    \n    \n    // Sphere Y\n    {\n        vec3 col = vec3(0,1,0);\n        vec4 shape = vec4(0,0,0, .5); // pos,radius\n        float dist = length(p - shape.xyz) - shape.w;\n\n        if (dist < closest.Dist)\n        {\n            closest.Dist = dist;\n            closest.Color = col;\n        }\n    }\n    \n    // Sphere Z\n    {\n        vec3 col = vec3(0,0,1);\n        vec4 shape = vec4(1.2,0,0, .5); // pos,radius\n        float dist = length(p - shape.xyz) - shape.w;\n\n        if (dist < closest.Dist)\n        {\n            closest.Dist = dist;\n            closest.Color = col;\n        }\n    }\n    \n    // Plane\n    {\n        vec3 col = vec3(.5,.5,.5);\n        float dist = p.y+0.5; // ground at y=0\n\n        if (dist < closest.Dist)\n        {\n            closest.Dist = dist;\n            closest.Color = col;\n        }\n    }\n    \n    return closest;\n}\n\nHit RayMarch(Ray r)\n{\n    Hit lastHit;\n    float totalDist = 0.0;\n    \n    for (int i=0; i<MAX_STEPS; i++)\n    {\n        vec3 p = r.Origin + totalDist*r.Direction;\n        lastHit = GetDist(p);\n        totalDist += lastHit.Dist;\n        if (totalDist < SURFACE_DIST || totalDist > MAX_DIST) \n            break;\n    }\n    \n    lastHit.Dist = totalDist;\n    \n    return lastHit;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p).Dist;\n    float offset = 0.01;\n    vec3 n = d - vec3(\n        GetDist(p - vec3(offset,0,0)).Dist,\n        GetDist(p - vec3(0,offset,0)).Dist,\n        GetDist(p - vec3(0,0,offset)).Dist\n        );\n    \n    return normalize(n);\n}\n\nvec3 GetLight(vec3 p, Light light)\n{\n    vec3 lightNormal = normalize(light.Pos-p);\n    vec3 surfNormal = GetNormal(p);\n    \n    // Light\n    float strength = clamp(dot(surfNormal, lightNormal), 0., 1.);\n\n    // Shadow\n    Ray shadow;\n    shadow.Origin = p + surfNormal*SURFACE_DIST*2.;\n    shadow.Direction = lightNormal;\n    if(RayMarch(shadow).Dist < length(light.Pos-p)) strength = 0.0;\n    \n    return light.Intensity * light.Color * strength;\n}\n\nvec3 ACESFitted(vec3 color);\n\n\n// MAIN ////////////////////////////////////////////////////////////////////////////////////////////////////\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.yy; // map to center:(0, 0), topright:(aspect/2, 0.5)\n    \n    // Camera\n    Ray r;\n    r.Origin = vec3(0,0.75,-5);\n    r.Direction = normalize(vec3(uv.x, uv.y-0.25, 2));\n    \n    \n    // Hit scene\n    Hit hit = RayMarch(r);\n    vec3 p = r.Origin + r.Direction*hit.Dist; // intersection point\n    \n    \n    // Direct Light\n    vec3 directLight = vec3(0);\n    {\n        Light l1;\n        l1.Pos = vec3(0, 2, 0) + 5.0 * vec3(sin(iTime), 1.0, cos(iTime));\n        l1.Color = vec3(1.0,0.6,0.5);\n        l1.Intensity = 1.0;\n\n        Light l2;\n        l2.Pos = vec3(5, 5, -5);\n        l2.Color = vec3(1.0,0.7,0.5);\n        l2.Intensity = 0.5;\n\n        directLight += hit.Color * GetLight(p, l1);\n    \t//directLight += GetLight(p, l2);\n    }\n    \n    \n    // Ambient Light\n    vec3 ambient = hit.Color * 0.8*vec3(0.02,0.02,0.08);\n    \n    \n    // Compose colour\n    vec3 col = ambient + vec3(directLight);\n    \n    \n    // Post\n    col *= 1.0; // exposure bias\n  \tcol = ACESFitted(col); // tonemap \n   \tcol = pow(col, vec3(1.0/2.2)); // gamma\n    \n    \n\tfragColor = vec4(col,1.0);\n}\n\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// ACES Tonemap: https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\nconst mat3 ACESInputMat = mat3(\n\t0.59719, 0.07600, 0.02840, \n\t0.35458, 0.90834, 0.13383,\n\t0.04823, 0.01566, 0.83777\n);\nconst mat3 ACESOutputMat = mat3(\n\t 1.60475, -0.10208, -0.00327,\n\t-0.53108,  1.10813, -0.07276,\n\t-0.07367, -0.00605,  1.07602\n);\nvec3 RRTAndODTFit(vec3 v)\n{\n\tvec3 a = v * (v + 0.0245786f) - 0.000090537f;\n\tvec3 b = v * (0.983729f * v + 0.4329510f) + 0.238081f;\n\treturn a / b;\n}\nvec3 ACESFitted(vec3 color)\n{\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit(color);\n\tcolor = ACESOutputMat * color;\n\tcolor = clamp(color,0.0,1.0);\n\treturn color;\n}\n","name":"Buffer D","description":"","type":"buffer"}]}