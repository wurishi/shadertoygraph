{"ver":"0.1","info":{"id":"43sczl","date":"1726566815","viewed":16,"name":"DoCuboidsDreamOfEllipticSweep","username":"MackFitz","description":"A happy accident while I learn by trying to mess with/break everything to see what happens. Not very far, very confused but I'm hooked. Move mouse left and right to spin.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["interactive","experiment","broken","accident"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define Pi  3.14159265359\n\nconst float cubeSize = 0.75; // Declare the size of the cube as a variable\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(length(q/20.), 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat map(vec3 p, out vec3 evalpt) {\n  evalpt = p; // Store the local position after transformations\n  return sdBox(p, vec3(cubeSize));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y; // Basic uv definition\n\n  float mouseX = (iMouse.x / iResolution.x) * 2.0 - 1.0; // Normalize mouse position to [-1, 1]\n\n  // Define camera position in spherical coordinates\n  float radius = 3.0;\n  float angle = mouseX * Pi; // Rotate around the y-axis based on mouseX\n  vec3 target = vec3(0.0); // Center of the cube\n  vec3 ro = vec3(sin(angle) * radius, 0.0, cos(angle) * radius); // Camera position in spherical coordinates\n\n  // Calculate the ray direction\n  vec3 forward = normalize(target - ro); // Forward direction\n  vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward)); // Right direction\n  vec3 up = cross(forward, right); // Up direction\n  vec3 rd = normalize(forward + uv.x * right + uv.y * up); // Ray direction\n\n  vec3 col = vec3(0.0); // declare default\n\n  float t = 0.0; // Total distance travelled\n  vec3 p = ro; // Declare p outside the loop\n  vec3 evalpt; // Declare evalpt to store the transformed position\n\n  for (int i = 0; i < 80; i++) {\n    p = ro + rd * t; // Position along the ray (in the XYZ?)\n    float d = map(p, evalpt); // Current distance and local position\n    t += d; // Total distance, updated by current distance\n\n    if (d < 0.001 || t > 100.0) break; // Short for both; encapsulate both conditions in a single ()\n  }\n\n  if (t < 100.0) { // Color based on local position within the cube\n    col = vec3(\n    (evalpt.x + cubeSize) / (2.0 * cubeSize),\n    (evalpt.y + cubeSize) / (2.0 * cubeSize),\n    (evalpt.z + cubeSize) / (2.0 * cubeSize)); // Gradient for front, back, top, and bottom\n  } else {\n    col = vec3(0.2, 0.3, 0.4); // Static background color if ray hits nothing\n  }\n\n  fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}