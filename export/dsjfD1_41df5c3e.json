{"ver":"0.1","info":{"id":"dsjfD1","date":"1689691099","viewed":43,"name":"Raymarching bouncing balls","username":"rozanski","description":"Simple raymarching shader with bouncing balls and an animated camera","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/** Constants **/ \n\n#define PI 3.14159265359\n\nconst vec3 red = vec3(1.0, 0.0, 0.0);\nconst vec3 green = vec3(0.0, 1.0, 0.0);\nconst vec3 white = vec3(1.0);\n\n/** Scene config */\n\n#define ROTATE_CAMERA 1\n#define ANIMATE_BALLS 1\n#define ANIMATE_LIGHTING 1\n\n#define LIGHT_INTENSITY 0.8\n#define FOG_INTENSITY 3.0\n\n#define DRAW_ORIGIN_SPOT 0\n\n/** SDF Functions */\n\nfloat sphereSDF(in vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\n// Approximates a circle on the floor by drawing a very thin cylinder.\nfloat circleSDF(in vec3 p, vec3 center, float radius) {\n    float d = length(p.xz - center.xz) - radius;\n    \n    d = max(d, p.y + 0.999);\n    \n    return d;\n}\n\nvec4 minWithColor(in vec4 a, in float d, vec3 color) {\n    if (a.x < d) { return a; }\n    return vec4(d, color);\n}\n\n/** Materials */\n\n// From https://stackoverflow.com/a/28382834\nvec3 checkerboard(in vec3 p) {\n    const float size = 1.0; \n    float result = mod(floor((1.0 / size) * p.x) + floor((1.0 / size) * p.z), 2.0);\n    float tile = max(sign(result), 0.0);\n    \n    return vec3(tile);\n}\n\n/** Scene */\n\nvec4 scene(in vec3 p) {\n    vec4 result = vec4(1e20, vec3(0.0));\n    \n#if ANIMATE_BALLS\n    vec3 sphere1Pos = vec3(-2.0 + sin(iTime), abs(sin(iTime * 4.0)), cos(iTime)); \n    vec3 sphere2Pos = vec3(2.0 + sin(iTime), abs(cos(iTime * 4.0)), -cos(iTime));\n#else\n    vec3 sphere1Pos = vec3(-2.0, 0.0, 0.0); \n    vec3 sphere2Pos = vec3(2.0, 0.0, 0.0);\n#endif\n    \n    result = minWithColor(result, sphereSDF(p, sphere1Pos, 1.0), red);\n    result = minWithColor(result, sphereSDF(p, sphere2Pos, 1.0), green);\n    result = minWithColor(result, p.y + 1.0, checkerboard(p));\n    \n#if DRAW_ORIGIN_SPOT\n    // For debugging\n    result = minWithColor(result, circleSDF(p, vec3(0.0), 0.5), red);\n#endif \n\n    return result;\n}\n\n/** Raymarching */\n\n// Encodes distance in x component and color in yzw components.\nvec4 raymarch(in vec3 ro, in vec3 rd) {\n    float distanceTravelled = 0.0;\n    \n    for (int i = 0; i < 256; ++i) {\n        vec3 p = ro + distanceTravelled * rd;\n        vec4 result = scene(p);\n        float distance = result.x;\n        vec3 color = result.yzw;\n        if (distance < 0.001) {\n            return vec4(distanceTravelled, color);\n        }\n        \n        if (distanceTravelled > 100.0) {\n            break;\n        }\n        \n        distanceTravelled += distance;\n    }\n    \n    return vec4(0.0, vec3(0.0));\n}\n\n/** Lighting */\n\n// From https://iquilezles.org/articles/normalsSDF/\nvec3 calcNormal(in vec3 p)\n{\n    const float eps = 0.0001;\n    const vec2 h = vec2(eps,0);\n    return normalize(vec3(scene(p + h.xyy).x - scene(p - h.xyy).x,\n                          scene(p + h.yxy).x - scene(p - h.yxy).x,\n                          scene(p + h.yyx).x - scene(p - h.yyx).x));\n}\n\n// Code by Inigo Quilez - see https://www.shadertoy.com/view/dsjfRh\nfloat calcShadow(in vec3 ro, in vec3 rd, float k)\n{\n    float res = 1.0;\n    float t = 0.01;\n    for(int i = 0; i < 150; i++)\n    {\n        vec3 pos = ro + t*rd;\n        float h = scene(pos).x;\n        res = min(res, k * max(h,0.0) / t);\n        if (res < 0.0001) break;\n        t += clamp(h,0.01,0.5);\n    }\n\n    return res;\n}\n\n/** Main */\n\nvec3 render(in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy) {\n    vec3 color = vec3(0.0);\n    vec4 result = raymarch(ro, rd);\n    vec3 p = ro + result.x * rd;\n\n#if ANIMATE_LIGHTING\n    vec3 light = vec3(sin(iTime) * 2.0, 2.0, 0.0);\n#else\n    const vec3 light = vec3(0.0, 5.0, 0.0);\n#endif\n\n    vec3 l = normalize(light - p);\n    vec3 normal = calcNormal(p);\n\n    float distance = length(light - p);\n    float decayFactor = 1.0 - LIGHT_INTENSITY;\n    \n    // add exponential falloff for light.\n    float intensity = pow(1.0 - decayFactor, distance);\n    float diffuse = clamp(dot(normal, l), 0.0, 1.0) * intensity;\n    \n    // clamp the shadow coefficient to 0.1...1.0 to make shadows lighter.\n    float shadow = clamp(calcShadow(p + normal * 0.1, light, 0.7), 0.1, 1.0);\n    float fog = 1.0 - exp(-0.0002 * pow(result.x, FOG_INTENSITY));\n    \n    // set emission color and blend with fog\n    color = mix(result.yzw, color, fog); \n    \n    // apply diffuse and shadow effects\n    color = color * diffuse * shadow;\n    \n    return color;\n}\n\n\n// Camera setup code by Inigo Quilez - see https://www.shadertoy.com/view/Xds3zN\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv =          (cross(cu,cw));\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n#if ROTATE_CAMERA \n    float cameraAngle = iTime / 1.5;\n#else\n    const float cameraAngle = 0.0;\n#endif\n\n    // Camera setup code by Inigo Quilez\n    vec3 ta = vec3(5.0 * sin(cameraAngle), 1.0, 5.0 * cos(cameraAngle));\n    vec3 ro = ta + vec3(PI * sin(cameraAngle), PI / 2.0, PI * cos(cameraAngle));\n    // camera-to-world transformation\n    mat3 ca = setCamera(ro, ta, 0.0);\n    \n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    // focal length\n    const float fl = 2.0;\n    \n    // ray direction\n    vec3 rd = ca * normalize( vec3(p,fl) );\n\n    // ray differentials\n    vec2 px = (2.0 * (fragCoord + vec2(1.0, 0.0)) - iResolution.xy) / iResolution.y;\n    vec2 py = (2.0 * (fragCoord + vec2(0.0, 1.0)) - iResolution.xy) / iResolution.y;\n    vec3 rdx = ca * normalize(vec3(px,fl));\n    vec3 rdy = ca * normalize(vec3(py,fl));\n        \n    vec3 color = render(ro, rd, rdx, rdy);\n    \n    // gamma correction\n    color = pow(color, vec3(1.0 / 2.2));\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}