{"ver":"0.1","info":{"id":"Wslcz7","date":"1584719169","viewed":313,"name":"Bullet Train","username":"spalmer","description":"From a vague idea reminiscent of an old Unreal Tournament level called [b][i]High Speed[/i][/b], where you ride on a fast-moving train.  Good place to experiment with scrolling terrain, camera shake, and motion blur.","likes":12,"published":1,"flags":48,"usePreview":0,"tags":["raymarch","scene"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGzn","filepath":"/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","previewfilepath":"/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","type":"music","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define Noise iChannel0\n#define BufferC iChannel2\n#define SoundCloud iChannel3\n\n// TODO Sound tab :)  kick the SoundCloud in iChannel3 for now.  It won't autoplay.\n\n// this entire thing started off as https://shadertoy.com/view/tlGXDK\n// and kind of got out of control.  Went off the rails, so to speak.\n// Still needs quite a bit of material and model detail work,\n// atmo is weak, perf is greatly harmed by all the antialiasing/motionblur hackery\n// hopefully I can get it working better but good enough to show I guess\n\n// signed distance\n\nfloat dbox(float p)\n{\n    return abs(p) - 1.;\n}\n\n\n// iq's, mostly\nfloat dseg(vec3 q, vec3 a, vec3 b)\n{\n    q -= a; b -= a;\n    return length(q - b * clamp(dot(q, b) / dot(b, b), 0., 1.));\n}\n\nfloat dslab(vec2 q, vec2 n)\n{\n    return dbox(dot(q, n));\n}\n\nfloat dslab(vec3 q, vec3 n)\n{\n    return dbox(dot(q, n));\n}\n\nfloat dball(vec3 p)\n{\n    return length(p) - 1.;\n}\n\nfloat dbox(vec2 q, vec2 e)\n{\n    float d = -3.4e38;\n    d = max(d, dslab(q, vec2(e.x, 0)));\n    d = max(d, dslab(q, vec2(0, e.y)));\n    if (d >= 0.)\n        d = length(max(abs(q) - e, 0.));\n    return d;\n}\n// honestly I just threw this box fn together from scratch, iq's is better\nfloat dbox(vec3 q)\n{\n    float d = -3.4e38;\n    d = max(d, dslab(q, vec3(1, 0, 0)));\n    d = max(d, dslab(q, vec3(0, 1, 0)));\n    d = max(d, dslab(q, vec3(0, 0, 1)));\n    if (d >= 0.)\n        d = length(max(abs(q) - 1., 0.));\n    return d;\n}\n\nfloat dboxround(vec3 q)\n{\n    const float r = .5, s = 1. - r;\n    return dbox(q / s) * s - r;\n}\n\nfloat skyDepthHack(float rdy, float focus)\n{\n    focus = clamp(focus, 0., 1.);\n    rdy *= focus;\n    return 16e4 * (rdy < 0.\n\t    ? exp2(8. * (rdy + .0)) \n    \t: 1. - .55 * rdy \n    \t);\n}\n\nvec3 skyColor(vec3 rd, float d, float focus) // rd = ray dir, d = depth\n{\n    // uses focus to blur the horizon\n    float od = skyDepthHack(rd.y, focus); // optical depth\n    od = min(od, d); // take scene depth into account\n    float lv = dot(sunDir, rd);\n    return (\n        1. - exp2(-fogRayleigh * od * phaseHG(lv, 0.))\n        + 1. - exp2(-fogMie * od * phaseHG(lv, -.6))\n        ); // * sunColor;\n}\n\n// lod transition helper\nfloat lodshape(float dshape, float dlod, float fade)\n{\n    float b = dlod;\n    if (b >= fade) return dlod;\n    if (b <= 0.) return dshape;\n    return mix(dshape, dlod, b / fade);\n}\n\nfloat dbridge(vec3 q)\n{\n    return dbox(q.yz - vec2(6.,.988*trackloop), vec2(1.1,6.));\n}\n\nfloat dtrack(vec3 q)\n{\n    q.y -= .8;\n    if (dot(q.xy, q.xy) > 64.) return length(q.xy) - .2;\n    vec3 p = q;\n    p.x = abs(p.x) - .8;\n    vec3 r = p;\n    r.x -= 5.;\n    r.y = max(0., abs(r.y - 1.)-3.); // not too tall or will clip by track/train LOD cylinder\n    r.z = mod(r.z, 32.) - 16.;\n    p.y *= .8;\n    q.y += .5;\n    q.z = 1. - mod(q.z, 2.); //fract(q.z); //\n    q.x = max(0., abs(q.x) - 1.5);\n    float d = 1e9;\n    d = min(d, length(r) - .15); // 'posts' - FIXME not colored right\n    d = min(d, length(q) - .2); // ties\n    d = min(d, length(p.xy) - .2); // rails\n    return d; \n}\n\nfloat dwheel(vec3 p)\n{\n    float yz = max(0., length(p.yz) - .4);    \n    return length(vec2(p.x, yz)) - .12; // a poofed disc\n}\n\n// a train!  sort of.  needs details\nfloat dtrain(vec3 q)\n{\n    float trainlen = 10.;\n    q.y -= 2.5;\n    if (dot(q.xy, q.xy) > 4.) return length(q.xy) - 1.;\n\tq.z = mod(q.z, trainlen);\n    if (q.z < 0.) q.z += trainlen;\n    q.z = abs(q.z - .5*trainlen);\n    vec3 p = q;\n    vec3 s = q;\n    s.z = abs(s.z - .25*trainlen);\n    s.y += 1.1;\n    s.x = abs(s.x) - .6;\n    q.z = max(0., q.z - .5*trainlen + 2.);\n    p.z = max(0., p.z - .5*trainlen + 1.1);\n    p.y += .9;\n    p.y = max(0., abs(p.y) + .9);\n    return min(dboxround(q), min(dbox(p), dwheel(s)));\n    return dboxround(q);\n}\n\nfloat velocity = 0.; // main speed, so it can change over time\nfloat ssmblur = 0.; // for motion blur on only the non-moving environment, not the fast stuff the camera is attached to\n\nvec3 sceneScroll()\n{\n    return vec3(0,0,trackloop * fract(iTime * velocity / trackloop) + ssmblur);\n}\n// I don't actually like the curvature, but I disliked the canyon being perfectly straight even more\nvec3 wiggleWorld(vec3 q)\n{\n    float z = q.z - iTime * velocity; // / trackloop;\n    // careful, it's such a hack that if you use too much it looks a little weird\n    float w = 12. * sin(.01*z);\n    q.x -= w;\n\treturn q;\n}\n\nfloat hillheight(vec2 q)\n{\n    // ALU sinus \"hills\"\n    // now it's the main terrain heightmap\n    float e = 1.; //e = min(q.y, 1. - q.y);\n    e = min(e, (max(0., abs(q.x) - 2.5)) / 512.);\n    e = max(0., e);\n    // gawdawful hack - my apologies, but it's getting the job done for now\n    vec4 j = sin(.08*vec4(1,1.2,2.1,2)*vec4(q,q) + vec4(0,.5*pi,0,.5*pi));\n    float h = .7 * j.x * j.y + .3 * j.z * j.w;\n    #if 0 // too slow; sinewaves are pretty slow\n    if (abs(q.x) > 8.) {\n    \tvec4 k = vec4(0);\n        k = sin(.33*vec4(1,1.2,2.1,2)*vec4(q,q) + vec4(0,.5*pi,0,.5*pi));\n    \th += .1 * k.x * k.y + .04 * k.z * k.w;\n    }\n    #endif\n    h = h * .5 + .5;\n    #if 0 // augmented w a little texture - sucks and is slow\n    float hnz = texture(Noise, q.xy * .006).x;\n    hnz += .4 * texture(Noise, q.yx * .015).x;\n    hnz = clamp(hnz, 0., 1.);\n    hnz = 1. - hnz; hnz *= hnz; hnz = 1. - hnz; // sqrsgn\n    h += hnz * .1;\n    #endif\n    float c = exp2(-canyon * e);\n    //h += 1. - c; //h = mix(1., h, c);\n    h *= 1. - c;\n    h += 2.5 * e + .01;\n    // FIXME this clipping is fairly noticeable, didn't think it was that bad before, but..\n    return clamp(h, 0., 1.);\n}\n\nfloat dscenery(vec3 q)\n{\n    vec3 qh = q;\n    qh += sceneScroll();\n    qh.z = mod(qh.z, trackloop);\n    float dplane = qh.y;\n    float dhills = dplane - hillheight(qh.xz) * displ;\n    float dover = dbridge(qh);\n    float dtrk = dtrack(qh);\n    float d = min(min(dplane, dhills), min(dover, dtrk));\n    return d;\n}\n\n// show train, over a scrolling scene, which makes train appear to move.\nfloat sceneDistance(vec3 q)\n{\n    float dscene = dscenery(q);\n    float dt = dtrain(q);\n    return min(dscene, dt);\n}\n\nfloat AntialiasPosition(vec3 q)\n{ // TODO must be a better way to do this without auto derivatives\n    return fwidth(q.x) + fwidth(q.y) + fwidth(q.z);\n}\n\n// TODO may merge with sceneMaterial so it can adjust the normal per-material\n\n// on blog page iq mentions using IZERO and a loop over an array to\n// prevent compiler inlining 4 loose calls, saving much compilation time.\n// iq's looped simplex gradient, excellent!\n// https://iquilezles.org/articles/normalsSDF\nvec3 sceneNormal(vec3 q, float h)\n{\n    vec3 n = vec3(0);\n    int i = 0;\n    i = IZERO;\n    for (; i < 4; ++i) {\n        vec3 e = vec3((ivec3(i+3, i, i+i)&2) - 1);\n        n += sceneDistance(q + e * h) * e;\n    }\n    return normalize(n);\n}\n\nvec3 sceneMaterial(vec3 q, float blur)\n{\n    // simple grey plastic is fine for the train and just about everything for now\n    vec3 albedo = diffuseColor;\n    // plane sinegrid + texture\n    vec2 t = q.xy - vec2(0,2.45);\n    if (q.y <= 1e-2 || dot(t, t) > 7.4\n     && fract((q + sceneScroll()).z / trackloop) < .976) { //dbridge(q + sceneScroll()) < .1) {\n        vec3 qh = q + sceneScroll();\n        albedo = vec3(.4,.5,.3)\n        \t+ .1 * sin(qh.x) * sin(qh.z)\n        \t\t* exp2(-1.2 * blur)\n        \t+ .05 * sin(4.*qh.x) * sin(8.*qh.z)\n        \t\t* exp2(-1.8 * blur)\n        \t;\n        //albedo *= texture(iChannel0, qh.xz / iChannelResolution[0].y).rgb;\n    }\n   \treturn albedo;\n}\n// really this entire material system is pathetic, needs major work\nvoid sceneSurface(int uniformzero\n      , vec3 phit, inout float t\n      , out vec3 albedo, out vec3 n, out float datmo)\n{\n    float blur = AntialiasPosition(phit);\n    bool is_hit = (t >= 0.);\n    float dsky = hatmo / depthscale;\n    datmo = t;\n    bool sky = !is_hit || t > dsky;\n    albedo = vec3(1);\n    if (sky) {\n        datmo = hatmo;\n        albedo = vec3(0);\n        n *= -0.;\n        t = dsky; \n    } else { // hit sdf, so render it over bg, lit\n\t\tconst float normal_precisionb = .06,\n            normal_precisions = 0.001;\n    \tfloat h = normal_precisionb + normal_precisions\n        * t\n        * sqrt(1./3.) // .5773\n        * (1. + 128.*blur) // antialiasing, band limit TODO tuning!! maybe need iResolution?\n        ;\n    \tn = sceneNormal(phit, h);\n      \talbedo = sceneMaterial(phit, blur); // HACK material is only albedo atm\n    \t// t sent for future reflection/shadow ray generation\n    \tdatmo *= depthscale;\n    }\n}\n\n\nvec3 sceneAtmosphere(vec3 c, vec3 ro, vec3 rd, float t, float lv, float datmo)\n{\n    datmo = min(datmo, hatmo);\n    c *= exp2(-1e-4*cext*datmo); // extinction\n    c += skyColor(rd, datmo, 1.);\n    vec3 tfog = cfog * (1. - exp2(-fogdensity*max(0., datmo - fognear)));\n    float bfog = phaseHG(lv, -.2); //mix(pow(max(lv * .5 + .5, 0.), 2.), 1., .875);\n    c += bfog * tfog; // fog\n  #if 0 // old hacks\n    float afog = mix(pow(max(lv * .5 + .5, 0.), 2.), 1., .875);\n    float nfog = pow(max(lv, 0.), miepowhack); // fake phase function\n    vec3 cfog = 1. - exp2(-1e-4*csky*datmo);\n    vec3 mfog = 1. - exp2(-1e-4*cmie*datmo);\n    vec3 ad = abs(rd);\n    c += afog * cfog; // inscatter\n    c += nfog * mfog; // fake mie\n  #endif\n    return c;\n}\n\n\nRay3 queryRay;\n\nvec3 queryAt(float t) \n{\n    vec3 q = queryRay.o + queryRay.d * t;\n    //q.y += t * .1 * (1. - abs(queryRay.d.y)); // fake globe curvature with distance - causes self-shadow problems currently\n    q = wiggleWorld(q);\n    return q;\n}\n\n// the parametric function of the ray;\n// given global queryRay and given index along it,\n// compute position along ray p and return sdf(p)\nfloat sdfQueryRay(float t)\n{\n    return sceneDistance(queryAt(t));\n}\n\n// a single iteration of a linear bracketed root finder algorithm aka regula falsi;\n// Linearly interpolate the position of a root between two known values on either side\n// returns mix factor to use between original two points\n// v0 = sdf(x0) and v1 = sdf(x1), then xRoot ~= mix(x0, x1, FalsePositionEstimate(v0, v1))\n// x0 and x1 *must* bracket the root, so v0 and v1 must have opposite signs or be zero.\n// takes two samples from field and returns interpolation factor between them where zero is likely to be found\nfloat FalsePositionEstimate(float v0, float v1)\n{\n\tfloat l = v0 - v1; \n\treturn abs(l) < 1e-24 ? .5 : v0 / l;\n}\n\nvec2 sdfqrFalsePositionStep(inout float x0, inout float x1, inout float v0, inout float v1)\n{\n    float u = FalsePositionEstimate(v0, v1);\n    float x = mix(x0, x1, u); // new guess\n    float d = sdfQueryRay(x); // NOTE function is hardcoded.  maybe I can make a small enough part of this into a macro.\n\tif (d < 0. == v0 < 0.)\n        v0 = d, x0 = x;\n\telse\n        v1 = d, x1 = x;\n    return vec2(x, d);\n}\n// result.x should then be between input x0 and x1, and closer than either.\n// result.y is the function's value at the new point result.x\n// on exit, either x0 or x1 will now contain the return value.x, and the extent should have shrunk.\n// post-result bracketing situation *should* be an improvement.\n// at some point you can stop calling it, and just use the midpoint of the remaining bracket.\n\n// now all that remains is to call it, perhaps repeatedly, until satisfied\n\n// usually even a few iterations does wonders.\nfloat sdfqrFalsePosition(inout float p0, inout float p1, inout float v0, inout float v1, int niter, float tol)\n{\n\tfloat x;\n    for (int i = niter; i-- > 0; ) {\n        vec2 r = sdfqrFalsePositionStep(p0, p1, v0, v1);\n        x = r.x;\n        if (abs(r.y) < tol) break;\n    }\n    return x;\n}\n\n// t is ray index into queryRay\n// d should be sdfQueryAt(t)\n// ot is t at prior step\n// od is d at prior step aka sdfQueryAt(ot)\n// r is a scale factor relating progress along t to the d value; usually somewhere around .9 works well for sdfs.\n// a is a minimum step size and determines the fine structure scale where details won't be skipped.\nvoid sdfQueryRayStep(inout float t, inout float d, inout float ot, inout float od, float i, float r) //, float a)\n{\n    float t0 = t, d0 = d; // copy input values for later\n    float p = .5 * d / od;\n    float s = 1e-4 + d * r;\n    t += s; // t += max(s, a); // TODO a better function of the available data\n    d = sdfQueryRay(t);\n    ot = t0, od = d0;\n}\n\nfloat sdfqrRayMarch(vec3 ro, vec3 rd, float rate, float thresh, int iter)\n{\n    queryRay.o = ro, queryRay.d = rd;\n    float rit = 1. / float(iter);\n    float ret = -1.; // \"missed\". see isMiss.\n    float t = .0, t1 = -1e-9, d = sdfQueryRay(t);\n    float d1 = d + 1e-9; // d1 is just a wild guess at the value of sdfQueryRay(t1); shouldn't matter a whole lot but does influence the size of the first step, probably.\n    do {\n        if (abs(d) <= thresh * t) { //if (d <= thresh) {\n        \t//t = sdfqrFalsePosition(t, t1, d, d1, 4, 9e-4);\n            t = max(t, 0.);\n            ret = t;\n            break;\n        }\n        sdfQueryRayStep(t, d, t1, d1, float(iter)*rit, rate); //, 9e-4); //1e-3); //5e-4); //\n    } while (iter-- > 0);\n    if (rd.y < 0. && ret < 0.) ret = min(depthlimit, mix(t, ro.y / -rd.y, .1)); // rescue rays that should definitely have hit the ground\n    return ret;\n}\n\n\n// TODO need tmax arg, limit max trace distance; really, lo, hi range would be nice\nfloat raymarch(vec3 ro, vec3 rd, int nsteps)\n{\n    return sdfqrRayMarch(ro, rd, 1.04, .002, nsteps);\n}\n\nfloat rayshadow(vec3 ro, vec3 rd, int nsteps)\n{\n    // use different step scaling and hit distance tolerance for shadows\n    float t = sdfqrRayMarch(ro, rd, 1.2, .02, nsteps);\n    return t >= 0. ? 0. : 1.; // hard shadows atten\n}\n\n\n\n// basic plasticky BRDF\nvec4 LightingBlinnPhong(vec3 n, vec3 v, vec3 L, vec3 albedo, float d, float satten)\n{\n    float amb = clamp(0.5 + 0.5 * n.y, 0., 1.); // less coming from down; makes hemispherical ambient\n    float lv = clamp(dot(L, n) * satten, 0., 1.); // n dot l\n    vec3 h = normalize(v + L);\n\n\tfloat dl = mix(lv, amb, ambient); //amb * ambient + dif * (1. - ambient); // how much diffuse+ambient lighting\n\tvec3 c = dl * albedo;\n    \n    float spec = pow(clamp(dot(h, n), 0., 1.), specularity);\n    spec *= lv * specularity * .038; // should mul by n*l and power, divide by 8*pi\n//    float reflectivity = 0.5;\n    // TODO reflections - should do another scene trace\n    //   vec3 ref = reflect(-rd, n);\n    //    vec3 crefl = texture(iChannel0, ref).rgb;\n\tc += spec * specularColor;\n    return vec4(c, 1);\n}\n\n\n// p is fragment world pos, v is view dir (toward eye), n is surf normal, t is distance from p to camera plane\n// lv is dot(-L,v), albedo is diffuse/ambient color, datmo is (fake scaled) frag depth\n// returns premultiplied alpha color c of lit fragment\nvec3 sceneLight(vec3 p, vec3 v, vec3 n, float t, float lv, vec3 albedo, float datmo)\n{\n    float satten = 1.;\n  #if SHADOWS\n    float nl = dot(n, sunDir);\n    if (nl > 0.) {\n\t    int nshadowsteps = IZERO + 16 + int(quality * 6.); //12; //18; //24; //20; //32; //28; //\n        float ssd = t * ssscale + 1.;\n\t    p += ssd * ssnbias * n + ssd * sslbias * nl * sunDir; // self-shadow bias hacks        \n\t    satten = rayshadow(p, sunDir, nshadowsteps); // HACK disable shadows til I figure out the lighting problem\n    } else satten = 0.;\n  #endif\n    // TODO DFAO\n\treturn LightingBlinnPhong(n, v, sunDir, albedo, t, satten).rgb;\n}\n\n// raymarch to find termination depth when ray hits solid object\nfloat sceneDepth(vec3 ro, vec3 rd)\n{\n    int nsteps = 32 + int(quality * 64.); //64; //96; //128; //160; //192; //256; //32; //\n    //if (iResolution.y > 800.) nsteps -= 24; // help fullscreen perf out\n    nsteps += IZERO; // HACK prevent unwise compiler loop unrolling; can't do in Common because uniforms aren't directly accessible there\n    float d = raymarch(ro, rd, nsteps);\n    if (!(d >= 0.)) { \n        d = ro.y / -rd.y;\n        if (!(d >= 0.)) \n            d = -1.; //hatmo / depthscale; // TODO 'dome'\n    }\n    return d;\n}\n// lens flares from https://shadertoy.com/view/3lG3Wh\nfloat shapeBokeh(vec2 q)\n{\n    q = abs(q); // may as well, symmetry usually makes things easier for even sided shapes\n    float r; // overall shape\n    //r = dot(q,q) - .25; // round - squared metric\n    // FIXME with a better hexagon function I could round them off better\n    r = max(q.y, dot(q, vec2(.86602,.5))) - .5; // hexagon\n    r = max(0., r);\n\tr *= 6.; // focus / blur - larger makes more crisp\n    return exp2(-r); // fade\n}\n\n// kludge\nvec3 Hue(float h)\n{\n    return .5+.5*cos((h+vec3(0,1,2)/3.)*tau);\n}\n    \n// both V and L are in view space\nvec3 LensFlares(vec3 V, vec3 L)\n{ \n\tfloat vl = dot(V, L);\n\tvl = max(vl, 0.); // per-pixel is not as useful but is used to keep flares away from actual light source so it doesn't blow out detail on sun\n\tfloat fl = L.z;\n\tfl = max(fl, 0.); // do not show flares when camera aimed more than 90 degrees away from light\n\tfloat rl = sqrt(fl); // much more visible\n\tvec3 c = vec3(0);\n\tconst int nflares = 12 + int(quality * 12.);\n\tconst float rnf = 1. / float(nflares - 1);\n\tfor (int i = 0; i < nflares; ++i) {\n\t\tfloat si = float(i) * rnf;\n\t\tfloat xs = 8. * ((i & 3) == 0 ? -1. : 1.); // distribution favors front side\n        // FIXME I want a big one right at 0.  until I can get one here, I'll just hack one in the main fn\n\t\tfloat x = .05 + pow(si, 4.) * xs; // index along arc between L dir (0) and F dir (1) of this flare\n\t\tif (abs(x - 1.) < .166) continue; // just don't draw them if they happen to randomly be distributed near 1.0; they're so annoying! wish there was some better way to ensure this; have had no luck fading them out.\n\t\tfloat fhash = rand(si * 55.) * .5 + .5; // why the extra bias?\n\t\tfloat dotrescale = 3.; // larger numbers make flares smaller FIXME need inverted parameterization for scale\n\t\tfloat shrink = 0.;\n\t\tshrink += pow(fhash, 6.) * (rl + 1.);\n\t\tshrink = min(1., shrink + .5 * (1. - rl));\n\t\tdotrescale *= shrink * 24. + 1.; // some are smaller\n\t\tvec2 q = (V.xy - L.xy * (1. - x)) * dotrescale;\n\t\tvec3 cdot = vec3(1);\n\t    // each spot gets its own custom tint\n\t\tcdot = Hue(si * phi * tau);\n\t\tcdot = mix(cdot, vec3(1), .5); // desaturate hack\n        // FIXME seems like they need some rotation; just ain't right for them all to be screen-aligned always.\n\t\tfloat lfs = shapeBokeh(q);\n\t\tcdot *= lfs;\n\t\t// max may work better than add here; idea is to prevent stacked overlapped flares at sun\n        // from blowing out quite so much - but then don't need to divide by nflares below.\n        // but add is more realistic.  If you can balance it!\n\t\tc += cdot; //c = max(c, cdot); //\n\t}\n    //c *= rnf;\n    vec2 k = V.xy - L.xy; // relative light source itself\n//    c = max(c, shapeBokeh(8.*k) * .01); // the actual light flare at index 0.\n//    c = max(c, shapeBokeh(4.*k) * .02); // bigger.\n//    c = max(c, shapeBokeh(2.*k) * .04); // another bigger one\n//    c = max(c, shapeBokeh(1.*k) * .06); // another even bigger one faded out more\n\tc *= rl;\n//\tc *= 1 - pow(vl, 16); // HACK fade out on rays looking directly at light (so can see sun behind)\n\tc *= vec3(1,.9,.8) * flareBright;\n\treturn c;\n}\n\nvec3 RenderScene(vec3 ro, vec3 rd, float time, out float d)\n{\n    vec3 c = vec3(0);\n    d = sceneDepth(ro, rd);\n    float datmo;\n    vec3 albedo, normal;\n    vec3 hitp = ro + rd * d;\n    vec3 lhit = hitp;\n    hitp = queryAt(d);\n    sceneSurface(IZERO, hitp, d, albedo, normal, datmo);\n    float lv = dot(sunDir, rd); // factor of all fog and eye glare lighting\n    c = sceneLight(lhit, -rd, normal, d, lv, albedo, datmo);\n    c = sceneAtmosphere(c, ro, rd, d, lv, datmo);\n    return c;\n}\n\nvec2 StoQ(vec2 s, vec2 r)\n{\n\treturn (s + s - r) / r.y;\n}\n\nvec3 camRayDir(vec2 p, vec2 r)\n{\n    vec2 q = StoQ(p, r);\n    const float hfovy = pi/4.;\n    return viewRayDir(q, hfovy);\n}\n\n// idk about this \"run the ray marcher and lighting in a loop\" style of\n// SSAA antialiasing but it's better than nothing.\nvec3 Render(vec2 fragCoord, float nz, vec2 r, int ss, Ray3 camera)\n{\n    mat3 iview = cameraMatrix(camera.d);\n    float iss = 1. / float(ss);\n    vec3 o = vec3(0);\n    float mblur = 0.;\n    #if MOTION_BLUR\n    mblur = 1./iFrameRate; //iTimeDelta is too jerky with browser paranoia on timer resolution\n    mblur *= velocity * speedexag;\n    #endif\n    for (int i = ss; i-- > 0; ) {\n        float f = float(i) * iss;\n        f = fract(f + nz);\n        vec2 fc = fragCoord; // fragcoord subpixel\n        fc += .7 * sqrt(f) * cossin(pi*phi*2.*(f+.1*iTime)); // vogel disc jitter - temporal\n        // could add some extra angular defocus using iResolution\n        // TODO camera shake depending on distance to origin from campos.xy\n\t    vec3 ro, rd, vd;\n    \tvd = camRayDir(fc, r);\n\t    ro = camera.o, rd = normalize(iview * vd);\n    \tro += .15 * nz * rd;\n        ssmblur = mblur * f; // motion blur based on moving camera\n\t    float d;\n\t    o.rgb += RenderScene(ro, rd, iTime, d);\n    }\n    o.rgb *= iss;\n    if (dot(camera.d, sunDir) > 0.) {\n    // really need camera shadow on these flares\n    // FIXME do not want to pay for tracing sun shadows for every pixel.  \n    // Can this be done in BufferC?\n\t    float cfs = rayshadow(camera.o + sunDir * .05, sunDir, IZERO + 6); //-1.; //\n    // no sense supersampling the lens flares, but then we must recompute a single ray dir in view space and transform light to view also\n\t    o.rgb += cfs * LensFlares(normalize(camRayDir(fragCoord, r)), normalize(sunDir * iview));\n    // FIXME not actually digging the additive blending, it just doesn't look right to me somehow.\n    // the glare should block details in what's behind it!\n    }\n    return o;\n}\n\nvoid mainRender(out vec4 o, vec2 p, float j) //, vec3 ro, vec3 rd)\n{\n    velocity = min(speed, iTime * .1 + .5); // speed up over time\n    //vec3 camera_pos = cameraPosition (BufferC)\n    //   , camera_dir = cameraDirection(BufferC);\n\tRay3 camera = cameraRay(BufferC);\n    float anim = velocity*iTime;\n  #if CAMERA_MOTION    \n    if (iMouse.z < 0. || length(iMouse.xy) <= 1.) {\n        camera.o += 3.*sin(vec3(.02,-.01,.03)*9.*iTime) + vec3(0,.5,0);\n    \tcamera.d = normalize(camera.d + sin(.2*vec3(2.03,-1,0)*iTime)*vec3(.7,.5,0)); // look around\n    }\n  #endif\n  #if CAMERA_SHAKE\n    vec3 shake = (.6*sin(vec3(1.2,1.4,1.6)*anim) - sin(vec3(1.5,1.3,1.1)*8.*iTime))\n                   * .005 * sqrt(velocity) * exp2(-.01*dot(camera.o.xy, camera.o.xy)); // camera shake near track\n                   \n    camera.o += shake * .6;\n    camera.d = normalize(camera.d + shake * .4);\n  #endif\n  #if 1 // keep within sensible area\n    camera.o.y = max(camera.o.y, abs(camera.o.x)-1.);\n    camera.o.x = clamp(camera.o.x, -20., 20.);\n    camera.o.y = clamp(camera.o.y, 1.25, 25.);\n  #endif\n    camera.o -= wiggleWorld(camera.o) - camera.o;\n    vec3 c = Render(p, j\n              , iResolution.xy\n              , max(1, supersamples - int(step(600.,iResolution.y) + step(800.,iResolution.y)))\n              , camera);\n    o = vec4(c, 1);\n}\n\nvoid mainPost(inout vec4 o, float j) //, vec3 ro, vec3 rd)\n{\n    vec3 c = o.rgb;\n    //c *= .9; // white balance/exposure correction; not really supposed to do before gamma, but as part of tonemapping, but oh well\n    c = pow(c, vec3(1.0/2.2)); // to sRGB\n//    c = sqrt(max(vec3(0.),c)); // really fake gamma\n    c += vec3(.75/256. * j); // dither quantization bands\n    o = vec4(c, 1);\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    float j = texelFetch(iChannel0, ivec2(p) & 1023, 0).x; //rand(p); // blue noise is better\n    mainRender(o, p, j); //, ro, rd);\n    mainPost(o, j); //, ro, rd);\n}\n\n#if 0\n// TODO VR main - idk how I'd test though\n// I believe the trick is to transform ro and rd to main avatar space\n// it's pretty much exactly the same as mainCube so maybe can test that way\n// if shadertoy.com detects the magic identifier it will complain if the \n// prototype isn't actually available, so must hide it for now til I'm ready.\nvoid main/**/VR(out vec4 o, vec2 p, vec3 ro, vec3 rd)\n{\n    float j = rand(p);\n    mainRender(o, p); //, ro, rd);\n    mainPost(o, p); //, ro, rd);\n}\n#endif\n\n#if 0 // code from BufferA ... was removed.  had pebbles in iChannel2 and noise in iChannel3\n\n// compute terrain into BufferA on first frames\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    //if ((uint(iFrame) & 1023u) >= 2u) // periodically recompute so I don't have to rewind so often\n        discard; // no change to terrain after computed both double buffers\n    \n    vec3 c = pow(texture(iChannel2, p / iResolution.xy).rgb, vec3(2.2));\n\n    vec2 q = tscale * p / iResolution.y;\n    \n    float h = 0.;\n    h += texture(iChannel3, q   ).x;\n    h += texture(iChannel3, q*2.).x/2.;\n    h += texture(iChannel3, q*4.).x/4.;\n  //  h += texture(iChannel3, q*8.).x/8.;\n  //  h *= .7;\n     h = h * .3 + .7;\n    float e = max(0., min(p.y, iResolution.y - p.y) / iResolution.y);\n    e = min(e, min(p.x, iResolution.x - p.x) * .5 / iResolution.x);\n    h *= 1. - exp2(-canyon * e);\n  //  h = 1. - exp2(-e);\n    //h *= .4 + length(c); // Lumi?\n  //  h = 0.; // HACK flat\n    o = vec4(c,h);\n}\n\n#endif\n\n\n#if 0 // old Image when the main render was in BufferD\n// display BufferD\n// TODO post fx\n// FIXME until post fx are in doing meaningful work,\n// BufferD tab is just wasting time and could be\n// done here in Image tab\n// I would almost do the lens flares here, but didn't want to\n// duplicate any more camera code into Common than necessary\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    o = texelFetch(BufferD, ivec2(p), 0);\n//    o = texelFetch(BufferA, ivec2(p), 0); o.rgb *= o.a; o.rgb = vec3(o.a);\n//    o = texelFetch(BufferC, ivec2(p), 0);\n//    o.rgb *= 1.0;\n//    o.rgb = pow(o.rgb, vec3(1.0/2.2)); // to sRGB\n    o.rgb = sqrt(max(vec3(0.), o.rgb)); // really fake gamma\n    float j = rand(p);\n    o.rgb += vec3(.75/256. * j); // dither quantization bands\n    o.a = 1.;\n}\n#endif\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// most configurable options here\n// btw do not leave the Common tab selected while viewing the toy\n// as it seems to cause major fps stutters!\n\n#define DEBUG_MODE 0\n#define NON_DEBUG (!(DEBUG_MODE!=0))\n#define CAMERA_MOTION NON_DEBUG\n#define CAMERA_SHAKE NON_DEBUG\n#define MOTION_BLUR NON_DEBUG\n#define SHADOWS 1\n\n\nconst float\n, quality = .5 //1. //.3 //0. // master quality knob, controls many scalability features\n, speed = mix(.1, 48., float(NON_DEBUG)) // maximum velocity\n, trackloop = 1024. // how long is the track before it loops\n, displ = 32. // terrain vertical displacement\n, tscale = .5 // something about terrain scale\n, canyon = 24. // affects slope of canyon walls\n, speedexag = 4. // speed exaggeration, for motion blur\n;\n\nconst float pi = 3.141592, tau = 2.*pi\n    , phi = (sqrt(5.)+1.)*.5;        // golden angle\n\nconst int supersamples = 3 + int(quality * 2.); //4; //3; //1; //2; //6; //8; // for SSAA antialiasing\nconst vec3 sunDir = normalize(vec3(.2,.5,.866));\nconst float ambient = .06; // FIXME seems too bright with the fake depth fog but need some to fill in lack of GI\n// these aren't energy conserving and aren't PBR at all actually, just some HACK for now\nconst float specularity = 16.; // power\nconst vec3 specularColor = vec3(.5);\nconst float sslbias = .2, ssnbias = .1, ssscale = .05; // self-shadow bias and depth scale hacks\t    \nconst vec3 diffuseColor = vec3(.8);\nconst float hatmo = 85000.; // air extinct distance\nconst float depthscale = 120.; //1200.; //12.; // fog exaggeration for horizon look mostly, affects sun also though\nconst float depthlimit = 2400.; //hatmo * ; //\nconst float flareBright = .7;\nconst vec3 \n      cext = vec3(.7,1.2,1.8)\n    , cfog = 1.*vec3(.5,.7,.9)\n    //, cmie = .32*vec3(.36,.14,.02)\n    //, csky = vec3(.1,.2,.5)\n    ;\nconst float \n  fognear = 1e4 // HACK push fog away\n//, miepowhack = 1. //2. //\n, fogdensity = 5e-4\n; // 'mss' of different parts of air; hand tweaked, not measured, though.  base 2, not e.\nconst vec3 fogRayleigh = vec3(.8e-4, 1.9e-4, 4.7e-4) * 1.; //vec3(5.8e-6, 13.5e-6, 33.1e-6) * 1.44; // / log(2.); // Rayleigh RGB coefficients, 1/m units, base e, also convert base e to base 2\nconst vec3 fogMie = vec3(1.1e-5, .6e-5, .3e-5) * .5; // Mie RGB coefficients - I just made these up, but they're basically orange\n\n#define IZERO min(0, iFrame)\n\n// buffer mapping logic, could wrap to subsequent rows\nint slotid(ivec2 loc) { return loc.x; }\nivec2 slotloc(int id) { return ivec2(id, 0); }\n\nvec4 loadValue(sampler2D buf, int slot_id)\n{\n    return texelFetch(buf, slotloc(slot_id), 0);\n}\n\n\n// channel allocations can't be done in Common,\n// as the defines for the iChannel# samplers have not yet been set.\n// but we can allocate the slots within BufferC at least.\n\nconst int slotCameraPosition = 0;\nconst int slotCameraForward  = 1;\nconst int slotDesiredForward = 2;\nconst int slotMouseOld       = 3; // iMouse from prior frame\nconst int slotCount          = 4;\n\n// e^(i*tau*r)\nvec2 cossin(float r)\n{\n    return sin(vec2(r + .5*pi, r));\n}\n\n// cheap rotation transform on p by s=(cos(a),sin(a))\nvoid rot(inout vec2 p, vec2 s) \n{\n\tp = p * s.x + vec2(p.y, -p.x) * s.y;\n} // then can rot(q.xz, cossin(a))\n\n// build a 3x3 camera orientation matrix given forward direction vector, assuming up is +Y\nmat3 cameraMatrix(vec3 camFwd)\n{\n    vec3 w = normalize(camFwd)\n       , u = normalize(cross(vec3(0., 1., 0.), w))\n       , v = normalize(cross(w, u));\n    return mat3(u, v, w);\n} // inverse view matrix\n// then just transform by pw = iview * pv;\n\n// implements inverse proj matrix transform (postclip to view dir)\n// with hfovy in radians\nvec3 viewRayDir(vec2 q, float hfovy)\n{\n\treturn normalize(vec3(q, 1./sin(hfovy)));\n}\n\nstruct Ray3\n{\n    vec3 o, d; // origin and direction vectors\n};\n\n// refactored to Common; complicated by BufferC isn't available directly!\nvec3 cameraPosition(sampler2D BufC) \n{\n    return loadValue(BufC, slotCameraPosition).xyz;\n}\n\nvec3 cameraDirection(sampler2D BufC) \n{\n    return loadValue(BufC, slotCameraForward).xyz;\n}\n\nRay3 cameraRay(sampler2D BufC)\n{\n    return Ray3(cameraPosition(BufC), cameraDirection(BufC));\n}\n\n// see https://shadertoy.com/view/tdKSWW\nfloat rand(float x)\n{\n    // sine provides good decorrelation and as a bonus includes its own range reduction\n    // see https://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner\n    x = sin(x*7.);\n    x *= 43708.8672;\n    x = fract(x);\n    return x;\n}\n\nfloat rand(vec2 x) \n{ \n    return rand(dot(x, vec2(11.07,10.71)));\n}\n\n// \"Real Time Rendering of Atmospheric Scattering Effects for Flight Simulators\" by Ralf Stokholm Nielsen\n// can be found at http://www2.imm.dtu.dk/pubdb/views/edoc_download.php/2554/pdf/imm2554.pdf\n// g is asymmetry parameter, corresponds to amount of back- or front-scattering depending on sign\n// the Henyey-Greenstein phase function to approximate Mie scattering as an ellipse\n// with g set to 0 it should be almost identical to phaseRayleigh\n// Nielsen says hg is (1-g^2) / 4 / π / (1 + g^2 - 2*cos(θ))^(3/2)\n// I'm fairly sure that was a misprint?! which I corrected later... agh\n// pbrt and ocean optics both basically have the same correction but different sign than I use\nfloat phaseHG(float costheta, float g) // phaseHenyeyGreenstein\n{\n\tfloat p = 1. + g * (g + 2. * costheta);\n\tfloat pn32 = inversesqrt(p*p*p); //pow(p, -1.5); //\n\treturn .25/pi * (1. - g)*(1. - g) * pn32;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Debug Camera from https://shadertoy.com/view/WlVGDh\n\n// BufferC controls the state, mostly the camera location+direction\n// but wound up needing old mouse state and, for smoothing,\n// the desired facing direction.\n\n#define BufferC   iChannel2\n#define Keyboard  iChannel3\n\nconst float moverate = 8.0;\nconst float turnratemouse = .02;\nconst float turnratekbd = 2.6;\n\n\nvec3 desiredDirection() \n{\n    return loadValue(BufferC, slotDesiredForward).xyz;\n}\n\nvec4 oldMouse() \n{\n    return loadValue(BufferC, slotMouseOld);\n}\n\nbool asleep(vec2 mouse) // in shadertoy.com shader browser thumbnail? \n{\n    return dot(mouse, mouse) <= 2.;\n}\n\n// read keyboard key, return 1.0 if down\n// ultimately want to do differencing of negatives from positives\nfloat key(int vk) // key down state value as a float fraction\n{\n    float s = loadValue(Keyboard, vk).x; // read keyboard key state from texture\n    return step(.5, s); // test if down\n}\n\nconst int\n  KEY_SPACE = 32\n, KEY_CTRL  = 17 // DO NOT use control generally as when held, bad things can happen to our window or tab\n, KEY_SHIFT = 16\n, KEY_C     = 67\n// https://en.wikipedia.org/wiki/Arrow_keys#WASD_keys\n, KEY_W     = 87\n, KEY_A     = 65\n, KEY_S     = 83\n, KEY_D     = 68\n// in DVORAK it's ,AOE, in AZERTY it's ZQSD\n, KEY_Z     = 90 // but Image tab is using it for showing depth FIXME\n, KEY_Q     = 81\n, KEY_O     = 79\n, KEY_E     = 69\n, KEY_COMMA = 188 //188 JS, 44 ASCII\n, KEY_X     = 88 // used by Image tab; should keys move to Common tab?\n#if 0 // AZERTY ZQSD\n, KEY_FW    = KEY_Z\n, KEY_LF    = KEY_Q\n, KEY_BW    = KEY_S\n, KEY_RT    = KEY_D\n#elif 0 // DVORAK ,AOE\n, KEY_FW    = KEY_COMMA\n, KEY_LF    = KEY_A\n, KEY_BW    = KEY_O\n, KEY_RT    = KEY_E\n#else // QWERTY\n, KEY_FW    = KEY_W\n, KEY_LF    = KEY_A\n, KEY_BW    = KEY_S\n, KEY_RT    = KEY_D\n#endif\n, KEY_UW    = KEY_SPACE\n, KEY_DW    = KEY_C  // anything but control!\n, KEY_LEFT  = 37 // arrow keys for lookaround\n, KEY_RIGHT = 39\n, KEY_UP    = 38\n, KEY_DOWN  = 40\n;\n\nvec3 cameraMovement(bool shift)\n{\n    vec3 campos = cameraPosition(BufferC);\n    float\n      fw = key(KEY_FW)\n    , bw = key(KEY_BW)\n    , lf = key(KEY_LF)\n    , rt = key(KEY_RT)\n    , up = key(KEY_UW)\n    , dn = key(KEY_DW);\n    vec3 camfwd = cameraDirection(BufferC);\n    //if (asleep(iMouse.xy)) fw = .5; // automate forward\n    //if (asleep(iMouse.xy)) campos = -4. * camfwd + objectpos; // orbit // * objectscale\n    mat3 camori = cameraMatrix(camfwd);\n    vec3 cammove = vec3(rt-lf, up-dn, fw-bw) * iTimeDelta * moverate;\n    if (shift) cammove *= 4.0; // shift key for speed boost\n    campos += camori * cammove;\n    const float camradius = .04;\n    //vec3 normal = sceneNormal(campos, 1e-7, IZERO);\n    //float cdist = sceneDistance(campos);\n    //campos += normal * -min(cdist - camradius, .0); // collision with sdf\n    campos.y = max(campos.y, abs(campos.x)-1.);\n    campos.x = clamp(campos.x, -20., 20.);\n    campos.y = min(campos.y, 25.);\n    return campos;\n}\n\nvec3 cameraSteering(bool shift)\n{\n    vec3 desiredRot = desiredDirection();\n    vec4 oMouse = oldMouse();\n    bool lmb = iMouse.z >= 0.;\n    bool olmb = oMouse.z >= 0.;\n    float shiftmod = shift ? .5 : 1.; // shift actually slows rotation down\n    vec2 orbit = vec2(0);\n    if (asleep(iMouse.xy)) {\n    \t//orbit = vec2(.15*iTimeDelta, 0);   // slow spin\n\t} else {\n    \tif (lmb && olmb) {\n\t        vec2 m = iMouse.xy - oMouse.xy;\n    \t    orbit += m * turnratemouse * shiftmod;\n    \t} \n    \t{\n    \t\tfloat aL = key(KEY_LEFT), aR = key(KEY_RIGHT), aU = key(KEY_UP), aD = key(KEY_DOWN);\n\t        vec2 m = vec2(aR - aL, aU - aD);\n    \t    orbit += m * iTimeDelta * turnratekbd * shiftmod;\n        }\n    }\n    if (dot(orbit,orbit) != 0.) {\n        rot(desiredRot.xz, vec2(cossin(orbit.x)));\n        vec2 vr = vec2(1.,desiredRot.y);\n        rot(vr, cossin(-orbit.y));\n        desiredRot.xz *= max(1e-1f, vr.x); // do not flip signs here!\n        desiredRot.y = vr.y;\n  \t\tdesiredRot = normalize(desiredRot);\n    }\n    return desiredRot;\n}\n\n// smoothing filter\nvec3 cameraSmoothing()\n{\n    vec3 camfwd = cameraDirection(BufferC);\n    vec3 desiredFwd = desiredDirection();\n    camfwd = normalize(mix(desiredFwd, camfwd, exp2(-64.*iTimeDelta)));\n    return camfwd;\n}\n\n// a debugging fly camera using keyboard WASD + mouse + C/space\n// stores camera position,aim,etc. into c as a \n// color coded vector suitable for output to buffer\nvoid debugFlyCamera(out vec4 c, vec2 p)\n{    \n    ivec2 ip = ivec2(p);\n    c = loadValue(BufferC, ip.x); // passthru by default\n    bool shift = key(KEY_SHIFT) > .5;\n    bool init = iFrame < 3; //iFrame == 0; // thumbnail issues\n    switch (slotid(ip)) {\n      case slotCameraPosition: {\n \t    c.xyz = init ? vec3(-2.0,6.1,-33.5) : cameraMovement(shift);            \n        break;\n      }\n      case slotCameraForward: {\n        c.xyz = init ? vec3(0.,0.,1.) : cameraSmoothing();\n        break;\n      }\n      case slotDesiredForward: {\n        c.xyz = init ? vec3(0.,0.,1.) : cameraSteering(shift);\n        break;\n      }\n      case slotMouseOld: {\n        c = iMouse;\n        break;\n      }\n      default:\n        break;\n    }\n}\n\n// output to Buffer C\nvoid mainImage(out vec4 c, vec2 p)\n{    \n    if (p.y >= 1. && int(p.x) >= slotCount) discard;\n    //if (p.y >= 1. || p.x >= float(slotCount)) return; // ignore most pixels - otherwise using an entire buffer is really bad\n    debugFlyCamera(c, p);\n}\n\n\n\n","name":"Buffer C","description":"","type":"buffer"}]}