{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"music","id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Andrew Caudwell 2014\n// @acaudwell\n\n// use iTime if WebAudio synchronization is broken in your browser (what's the deal firefox?)\n//#define TIME iTime\n#define TIME iChannelTime[0]\n\n#define MAX_RAY_STEPS 75\n#define PI 3.14159265359\n#define SCENE_COUNT 6\n\nvec2 sequence[SCENE_COUNT];\n\nint sceneNo(out float elapsed) {\n\n\tfloat time = TIME;\n\t\n\tfloat total = 0.0;\n\n\tsequence[0] = vec2(1.0, 0.0);\n\tsequence[1] = vec2(2.0, 8.4);\n\tsequence[2] = vec2(3.0, 17.0);\n\tsequence[3] = vec2(4.0, 34.0);\n\tsequence[4] = vec2(5.0, 38.0);\n\tsequence[5] = vec2(6.0, 55.0);\n\n\t// loop\n\tif(time>63.5) {\n\t\ttime = mod(time, 63.5) + sequence[1].y;\t\n\t}\n\t\n\tfor(int i=SCENE_COUNT-1;i>=0;i--) {\n\t\tfloat t = sequence[i].y;\n\t\tif(time>t) {\n\t\t\telapsed = time-t;\n\t\t\treturn int(sequence[i].x);\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nfloat scene_t = 0.0;\nint scene_no = 0;\nfloat t = 0.0;\n\nvoid calcScene() {\n\tscene_no = sceneNo(scene_t);\n\tt = scene_t * 3.0;\n}\n\nfloat cube(vec3 p, float c) {\n    return length(max(abs(p)-c,0.0));\n}\n\nfloat sphereLoop(vec3 p, float size, float gap) {\n\n\tfloat mn = 100.0;\n\t\n\tvec3 p0 = p;\n\t\n\tfloat f = sin(t);\n\t\n\tfloat seed = 0.0;\n\t\n\tfor(int i=0;i<5;i++) {\n\t\tseed += gap;\n\t\t\n\t\tvec3 c = vec3(\n\t\t\tsin(seed+t)*3.0,\n\t\t\tmax(-1.0,sin(seed+t*2.0)*1.05),\n\t\t\tcos(seed+t)*3.0\n\t\t);\n\n\t\tp = p0-c;\n\n\t\tfloat pp = dot(p,p);\n\n\t\tmn = min(mn, pp);\n\t}\n\t\n\tfloat d = sqrt(mn);\n\t\n\treturn d - size;\n}\n\nfloat sphereWave(vec3 p, float size, float gap, float freq, float offset) {\n\n\tfloat mn = 100.0;\n\t\n\tvec3 p0 = p;\n\t\n\tfloat f = sin(t);\n\t\n\tfloat seed = 0.0;\n\t\n\tfor(int i=0;i<5;i++) {\n\t\tseed += gap;\n\t\t\n\t\tvec3 c = vec3(\n\t\t\t-gap+seed,\n\t\t\tmax(-1.0,sin(seed*freq + offset)*1.05),\n\t\t\t0.0\n\t\t);\n\n\t\tp = p0-c;\n\n\t\tfloat pp = dot(p,p);\n\n\t\tmn = min(mn, pp);\n\t}\n\t\n\tfloat d = sqrt(mn);\n\t\n\treturn d - size;\n}\n\n\n\nfloat groundPlane(vec3 p, vec2 offset) {\n     vec2 m = vec2(4.2,4.2);\n\t p.y  += 3.7;\n     p.xz = mod(p.xz + offset - 0.5*m,m) - 0.5*m;\n\n\t// a bunch of cubes next to each other\n    return cube(p,2.0)-0.2;\n}\n\nfloat scene(vec3 p) {\n\t\n    float s = 1000.0;\n\tvec2 ground_offset;\n\t\n\t\n\tif(scene_no==2) {\n\t\tfloat gap  = 2.0;\t\n\t\tfloat size = 0.5;\n\t\tfloat freq = PI*0.5;\n\n\t\tvec3 p2 = p;\n\t\tp2.x += -32.0 + t*2.5;\n\t\tp2.x += +12.0;\n\t\tp2.x = abs(p2.x-12.0);\n\t\tp2.x = abs(p2.x-4.0);\n\t\tp2.x = abs(p2.x-4.0);\n\t\tp2.x = abs(p2.x-4.0);\n\t\t\n\t\ts = sphereWave(p2, size, gap, freq, t*2.0);\n\t}\t\t\n\t\n\tif(scene_no==3 || scene_no==6) {\n\t\t\n\t\tvec3 p2 = p;\n\t\t\t\t\n\t\tfloat size = 0.5;\n\t\tfloat gap;\n\t\tfloat freq;\n\n\t\tgap  = 0.5;\n\t\tfreq = 1.0;\n\t\t\n\t\tp2.x = abs(p2.x);\n\t\t\n\t\t// smoke and mirrors\n\t\tfor(int i=0;i<3;i++) {\n\t\t\tp2.x = abs(p2.x-2.0);\n\t\t}\n\t\tp2.y = -abs(p2.y-1.5)+1.5;\n\t\t\n\t\tif(scene_no==7) {\n\t\t\tsize = gap = max(sin(t)*0.5,0.25);\n\t\t}\t\n\t\t\n\t\ts = sphereWave(p2, size, gap, freq, t*2.0);\n\t}\n\t\n\tif(scene_no==4 || scene_no==5) {\n\t\tvec3 p2 = p;\n\t\t\n\t\tfloat size = 0.5;\n\t\t\n\t\tif(scene_no==5) {\n\t\t\tsize =  max(sin(t)*0.5,0.25);\n\t\t}\n\t\t\n\t\ts = sphereLoop(p2, size, size);\t\t\n\t\t\n\t}\n\t\n\tif(scene_no<3) {\n\t\tground_offset = vec2( t * 2.0, 0.0);\n\t} else {\n\t\tground_offset = vec2(cos(t)*3.0, -sin(t)*3.0);\t\t\n\t}\n\n\t\n\tfloat g = groundPlane(p, ground_offset);\n\t\n    return min(s,g);\n}\n\nvec3 normal(vec3 p) {\n\n    vec2 o = vec2(0.00001,0.0);\n\n\tfloat d = scene(p);\n\t\n    float d1 = d-scene(p+o.xyy);\n    float d2 = d-scene(p+o.yxy);\n    float d3 = d-scene(p+o.yyx);\n\n    return normalize(vec3(d1,d2,d3));\n}\n\nfloat ao(vec3 p, vec3 normal) {\n\n    float a = 1.0;\n\n\tfloat c = 0.0;\n    float s = 0.2;\n\n    for(int i=0; i<3; i++) {\n\t    c += s;\n        a *= 1.0-max(0.0, (c -scene(p + normal*c)) * s / c);\n    }\n\n    return a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\t\n\tcalcScene();\n\t\n\tfloat fov = scene_no>2 ? 0.5 + cos(iChannelTime[0])*0.25 : 0.5;\n\t\n    vec3 dir = normalize(vec3(uv.x, uv.y * (iResolution.y/iResolution.x), fov));\n\n    vec3 cam = vec3(0.0,1.0,-6.0);\n\n\tvec3 p = cam;\n\t\n    for(int i=0; i<MAX_RAY_STEPS; i++) {\n        p += scene(p) * dir;\n    }\n\t\n    vec3 n = -normal(p-dir*0.00001);\n\n    vec3 l = vec3(0.0,0.707,-0.707);\n\t\n\t// ground \n    vec3 c = vec3(0.5);\n\n\t// spheres\t\n\tif(p.y>-1.45&&p.z<3.0) c = vec3(1.0, 0.5,0.25);\n\t\n\t// sphere colours (has no effect on ground)\n\tif(scene_no==3) c = c.zyx;\n\tif(scene_no==4) c = c.yzx;\n\tif(scene_no==5) c = c.zxy;\n\tif(scene_no==6) c = c.xzy;\n \n\t// ambient occlusion shadows\n\tc *= ao(p, normalize(n+l));\n\n\t// lighting\n\tc += max(0.0, pow(dot(n, l), 3.0))*0.5 - length(p) * 0.024;\n\n\t// sky\t\n    if(p.y>10.0) {\n\t\tc = (0.8-pow(uv.y,3.0*uv.y)) * vec3(0.5,1.0,1.0);\n    }\n\t\n    fragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsX3zM","date":"1391509687","viewed":945,"name":"Spheres on a Plane","username":"andyalias","description":"Bouncing spheres on a scrolling plane synchronized to the song '8-bit Mentality'.\n\nPartly inspired by the classic Atari ST '3D Doc Demo' by TCB.","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","spheres","synchronization","bouncing"],"hasliked":0,"parentid":"","parentname":""}}