{"ver":"0.1","info":{"id":"3lXyD8","date":"1591899091","viewed":188,"name":"Noise Experiment","username":"tepSHATOY","description":"Basic experiment on noise. From top to down: function we want to approximate, quantized, dithered with bayer, dithered with WhiteNoise, dithered with VlachosNoise, dithered with IGN, dithered with BlueNoise","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Simple noise experiment to dither function with noise and quantize into binary value\n// Other people have done more advanced stuff:\n// * dithering: Color Banding Removal - https://www.shadertoy.com/view/MslGR8\n// * Valve's Screen Space Dither - https://www.shadertoy.com/view/4dcSRX\n// * Blue Noise Dissolve - https://www.shadertoy.com/view/MdGfDz\n\n// Hash without Sine by David Hoskins.\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Quantize(float x, float bitDepth)\n{\n    float bucketSize = 1.0 / pow(2.0, bitDepth);\t// 1 / (2^bit_depth)\n    float maxValue = pow(2.0, bitDepth) - 1.0;\t\t// 2^bit_depth - 1\n    return floor(x / bucketSize) / maxValue;            \n}\n\n// Procedural Bayer Matrix by patapom\n// https://www.shadertoy.com/view/Mlt3z8\n// Generates the basic 2x2 Bayer permutation matrix:\n\n//  [1 2]\n//  [3 0]\n// Expects _P in [0,1]\nfloat B2( vec2 _P ) {\n//    return ((_P.y << 1) + _P.x + 1) & 3;\t<= This would fare much better than modulos and floors :(\n    return mod( 2.0*_P.y + _P.x + 1.0, 4.0 );\n}\n\nfloat B4( vec2 _P ) {\n    vec2\tP1 = mod( _P, 2.0 );\t\t\t\t\t// (P >> 0) & 1\n    vec2\tP2 = floor( 0.5 * mod( _P, 4.0 ) );\t\t// (P >> 1) & 1\n    return 4.0*B2(P1) + B2(P2);\n}\n\n// Noise function that returns 0..1\nfloat InterleavedGradientNoise(vec2 screenPos)\n{\n    const vec3 magic = vec3( 0.06711056, 0.00583715, 52.9829189 );\n    return fract( magic.z * fract( dot( screenPos, magic.xy ) ) );\n}\n\n// http://alex.vlachos.com/graphics/Alex_Vlachos_Advanced_VR_Rendering_GDC2015.pdf\nvec3 VlachosNoise( vec2 vScreenPos )\n{\n\t// Iestyn's RGB dither (7 asm instructions) from Portal 2 X360, slightly modified for VR\n\t//vec3 vDither = vec3( dot( vec2( 171.0, 231.0 ), vScreenPos.xy + iTime ) );\n    vec3 vDither = vec3( dot( vec2( 171.0, 231.0 ), vScreenPos.xy ) );\n    vDither.rgb = fract( vDither.rgb / vec3( 103.0, 71.0, 97.0 ) );\n    return vDither;\n}\n                       \nfloat BlueNoise( vec2 screenPos )\n{\n    return texture( iChannel0, screenPos / iChannelResolution[0].xy ).r;\n}\n\n// Remap uniform to triangle, output [0,1]\n// https://www.shadertoy.com/view/MslGR8\nfloat RemapTri( const float v )\n{\n    float r2 = 0.5 * v;\n    float f1 = sqrt( r2 );\n    float f2 = 1.0 - sqrt( r2 - 0.25 );    \n    return (v < 0.5) ? f1 : f2;\n}\n\n// output [-1,1]\n// https://www.shadertoy.com/view/llVGzG\nfloat RemapTri2(float n)\n{\n    float origin = n * 2.0 - 1.0;\n    float v = origin / sqrt(abs(origin));\n    v = max(-1.0, v);\n    v -= sign(origin);\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pos = ( fragCoord.xy / iResolution.xy );\n    \n    float x = pos.x;\n    \n    // function we want to approximate\n    //float fx = x;\t\t\t\t\t\t// linear:     f(x) = x\n    //float fx = x * x;\t\t\t\t\t// quadratic:  f(x) = x*x\n    float fx = 3.0*x*x - 2.0*x*x*x;\t\t// smoothstep: f(x) = 3*x*x - 2*x*x*x\n\n    // To dither we basically want\n    //    fx < 0.5 + noise ? 0.0 : 1.0\n    //\n    // Noise should range from [-0.5, 0.5]\n    // If noise function produces 0..1 this can simply be\n    //    fx < 0.5 + (noise - 0.5) ? 0.0 : 1.0\n    //    fx < noise ? 0.0 : 1.0\n    \n    if (pos.y > 6.0/7.0)\n    {        \n        fx = fx;\n    }\n    else if (pos.y > 5.0/7.0)\n    {\n        //fx = Quantize(fx, 1.0);\n        fx = fx < 0.5 ? 0.0 : 1.0;\n    }\n    else if (pos.y > 4.0/7.0)\n    {\n        // Bayer\n        float bayerNoise = B4(fragCoord.xy) / 15.0;\n        fx = fx < bayerNoise ? 0.0 : 1.0;\n    }\n    else if (pos.y > 3.0/7.0)\n    {\n        float whiteNoise = hash12(fragCoord.xy);\n        fx = fx < whiteNoise ? 0.0 : 1.0;\n    }\n    else if (pos.y > 2.0/7.0)\n    {        \n        float ignNoise = InterleavedGradientNoise(fragCoord.xy);\n        fx = fx < ignNoise ? 0.0 : 1.0;\n    }\n    else if (pos.y > 1.0/7.0)\n    {\n        float vNoise = VlachosNoise(fragCoord.xy).r;\n        fx = fx < vNoise ? 0.0 : 1.0;\n    }\n\telse\n    {\n        float blueNoise = BlueNoise(fragCoord.xy);\n        //#ifdef ANIMATE_NOISE\n        //\tconst float kGoldenRatioConjugate = 0.61803398875;\n        //\tblueNoise = fract(blueNoise + float(iFrame%64) * kGoldenRatioConjugate);\n        //#endif\n        fx = fx < blueNoise ? 0.0 : 1.0;\n    }\n    \n    fragColor = vec4(fx, fx, fx, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}