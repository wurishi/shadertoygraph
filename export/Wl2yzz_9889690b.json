{"ver":"0.1","info":{"id":"Wl2yzz","date":"1609751316","viewed":144,"name":"Animated app icon","username":"MartinRGB","description":"Animated app icon\nby Matt Dayton","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["animatedappiconbymattdayton"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 100.\n\n#define ENABLE_RADIAL_BLUR true\n\nvec4 blurEffect( sampler2D sourceImage, vec2 inUV, vec2 innerPoint ){\n    \n    float u_slot1 = (sin(iTime*2.) + 1.)/2.;\n    \n    vec2 targetVector = innerPoint - inUV;\n    float shineFactor = 1. - length(targetVector) / sqrt(1.); //0.005 + 0.5 * u_slot1\n    //shineFactor = 0.5 + u_slot1*0.5;\n    \n    //shineFactor*= (sin(iTime) +1.)/2.;\n    \n    vec4 result = texture(sourceImage, inUV);\n    \n    // Turn on to overlay blur over texture\n    bool textureOverlay = true;\n    \n    if(!textureOverlay)\n    \tresult = vec4(0.0);\n    \n    if(ENABLE_RADIAL_BLUR)\n        for(float dist = 0.0; dist < 1.0; dist += 2. / STEPS){\n\n            result += texture(sourceImage, inUV + targetVector * dist*1.) * shineFactor / STEPS;\n\n        }\n    else\n        result = texture(sourceImage,inUV);\n    \n    result.w = 1.;\n    return result;\n    \n}\n\n// Move mouse around to set inner point of radial blur!\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Normalized inner point of radial blur\n    vec2 innerPoint = iMouse.xy / iResolution.xy; //vec2((sin(iTime)+1.)/2.,0.5);\n\n    //innerPoint = vec2(0.5 + 0.25*sin(iTime),0.5);\n    //fragColor = blurEffect(iChannel0, uv, innerPoint);\n    fragColor = texture(iChannel0,uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float map(float value, float inMin, float inMax, float outMin, float outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\nfloat roundRect(vec2 p, vec2 size, float radius) {\n  vec2 d = abs(vec2(p.x,p.y)) - vec2(size.x,size.y);\n  d.y /= iResolution.x/iResolution.y;  \n    \n  return min(max(d.x, d.y), 0.0) + length(max(d,0.0))- radius;\n}\n\nfloat smoothedge(float v) {\n    return smoothstep(0.0, 1.0 / iResolution.x, v);\n}\n\nfloat smoothedge1(float v,float before,float after) {\n    return smoothstep(before, after, v);\n}\n\n\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( ab.x > ab.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = min(0.999,(ry/sqrt(rm-rx) + 2.0*g/rm - m)/2.0);\n    }\n    \n    float si = sqrt( 1.0 - co*co );\n    vec2 r = ab * vec2(co,si);\n    return length(r-p) * sign(p.y-r.y);\n}\n\n\n//#define USE_APPROXIMATION\n#define PI 3.1415926\n// See: https://iquilezles.org/articles/ellipsoids\nfloat sdEllipsoidApproximated( in vec2 p, in vec2 r ) \n{\n    // # funny method \n    //r = r*0.01 + 0.15;\n    //r = vec2(pow(r.x,0.5),pow(r.y,0.5));\n    //r =  r + 0.1;\n    \n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nvec4 ringImage( in float radius,in float borderWidth,in vec2 pos,in float radians,float blur,vec3 blurColor)\n{\n\tvec2 uv = -.5 + 1.0 * gl_FragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    uv -= pos;\n\t\n    vec2 m = iMouse.xy/iResolution.xy;\n\tm.x *= iResolution.x/iResolution.y;\n    \n\t\n    #ifdef USE_APPROXIMATION\n\tfloat d = sdEllipsoidApproximated( uv, vec2(radius + 0.003  - (((sin(iTime*2.))+1.)/2.*radius),radius));\n    d = sdEllipsoidApproximated(uv,vec2(radius - map(sin(radians),-1.,1.,0.003,0.001+radius)+0.0012 ,radius ));\n    #else\n    float d = sdEllipse(uv,vec2(radius - map(sin(radians),-1.,1.,0.003,0.001+radius)+0.0012 ,radius )); // map(sin(iTime*2. + radians),-1.,1.,0.003,0.001+radius)\n    //d = sdEllipse(uv,vec2(radius - 0.003,radius));\n    #endif\n    \n    \n    #ifdef USE_APPROXIMATION\n \tfloat r = 1.0-smoothstep(borderWidth-borderWidth/2. ,borderWidth+borderWidth/2. ,abs(d));\n    float rBlur = 1.0-smoothstep(borderWidth-borderWidth/2.*blur ,borderWidth+borderWidth/2.*blur ,abs(d));\n    #else\n    float r = 1.0-smoothstep(borderWidth-borderWidth/2. ,borderWidth+borderWidth/2. ,abs(d));\n    float rBlur = 1.0-smoothstep(borderWidth-borderWidth/2.*blur ,borderWidth+borderWidth/2.*blur ,abs(d));\n    #endif\n    \n    vec4 col,colBlur;\n    \n    r = smoothedge1(r,0.2,1.);\n    \n\tcol = vec4(r);\n\tcolBlur = vec4(blurColor,pow(rBlur,1.5));\n    \n    \n    if(col.a <= 0.001){\n        col = vec4(1.,1.,1.,0.);\n    }\n    else{\n        //col = mix(vec4(vec3(1.,0.,0.),1.),col,col.a);\n        \n    }\n    \n    //col += colBlur;\n    col = mix(colBlur,col,col.a);\n    \n\treturn col; //1.0 -abs(d)\n}\n\n#define TAU 6.2831852\n#define MOD3 vec3(.1031,.11369,.13787)\n#define BLACK_COL vec3(16,21,25)/255.\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat simplex_noise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n        \n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\nvec4 ringFluid(in vec2 fragCoord){\n    vec2 uv = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n    uv *= 3.8;\n    \n    float a = sin(atan(uv.y, uv.x));\n    float am = abs(a-.5)/14.;\n    float l = length(uv);                         \n    \n    float m1 = clamp(.418/smoothstep(.0, 1.75, l), 0., 1.);\n    float m2 = clamp(.418/smoothstep(.42, 0., l), 0., 1.);\n    //float s1 = (simplex_noise(vec3(uv*2., 1. + iTime*1.525))*(max(1.0 - l*1.75, 0.)) + .9);\n    //float s2 = (simplex_noise(vec3(uv*1., 15. + iTime*1.525))*(max(.0 + l*1., .025)) + 1.25);\n    //float s3 = (simplex_noise(vec3(vec2(am, am*100. + iTime*3.)*.15, 30. + iTime*.525))*(max(.0 + l*1., .25)) + 1.5);\n    \n    float s1,s2,s3;\n    \n    s1 = texture(iChannel0,vec2(uv.x*2.,1.*(1. + iTime*1.525))).x*max(1.0 - l*1.75, 0.)+.9;\n    s2 = texture(iChannel0,vec2(15. + iTime*1.525,uv.y)).y*max(.0 + l*1., .025) + 1.25;\n    s3 = texture(iChannel0,vec2(am, am*100. + iTime*3.)*.15).z * (max(.0 + l*1., .25)) + 1.5;\n    \n    s1 = texture(iChannel0,vec2(uv.x*2.,1.*(1. + iTime*1.525))).x*max(1.0 - l*1.75, 0.)+.9;\n    s2 = texture(iChannel0,vec2(15. + iTime*1.525,uv.y)).y*max(.0 + l*1., .025) + 1.25;\n    s3 = texture(iChannel0,vec2(am, am*100. + iTime*3.)*.15).z * (max(.0 + l*1., .25)) + 1.5;\n    \n    \n    s3 *= smoothstep(0.0, .43345, l);  \n    //float s3 = 1.;\n    \n    float sh = smoothstep(0.15, .35, l);\n    \n    \n    float m = m1*m1*m2 * ((s1*s2*s3) * (1.5-l)) * sh;\n    //m = clamp(m, 0., 1.);\n    \n    //vec3 col = mix(BLACK_COL, (0.5 + 0.5*cos(iTime+uv.xyx*3.+vec3(0,2,4))), m);\n\t\n    vec3 col = vec3(1.,0.,0.)*m;\n    vec3 col2 = mix(BLACK_COL, (0.5 + 0.5*cos(iTime*4. + 3.14*0.25 +uv.xyx*3.+vec3(0,2,4))), m);\n    \n    vec3 finCol = mix(col,col2,sin(iTime));\n    \n    \n    if(l> 4.2/4.2){\n       return vec4(0.,0.,0.,0.);\n    }\n    else{\n       return vec4(col2,1.- l);\n    }\n \n    \n}\n\n\nvec4 drawObjectColor(in vec2 uv,in vec2 fragCoord){\n    vec4 color;\n    vec4 colorR3;\n    \n    float u_slot1 = (sin(iTime*2.) + 1.)/2.;\n    float u_slot2 = (cos(iTime) + 1.)/2.;\n    u_slot2 = 1.;\n    u_slot1 = 0.;\n    float u_slot3 = 0.;\n    \n    vec3 blurColor = vec3(1.5);\n    vec3 blueColor = vec3(0.,0.,1.);\n    blurColor = mix(blurColor,blueColor,1.);\n    \n    float blurRadius = 5. + 4.*u_slot1;\n    colorR3 = ringImage(0.050 - u_slot1*0.048+ 0.04*u_slot2,0.02,vec2(0.,0.) + vec2(u_slot1*0.3,0.),PI*1.5 - PI*u_slot1,blurRadius*u_slot3,blurColor);\n    \n    vec4 ringFluid = ringFluid(fragCoord);\n\n    color = mix(color,ringFluid,ringFluid.a);\n    color = mix(color,colorR3,colorR3.a);\n   \n    \n    //color = mix(colorAdd,color,1. - u_slot1);\n    //color = colorAdd;\n    \n    return color;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec4 baseColor = vec4(117./255.,127./255.,143./255.,1.);\n    float d = roundRect(uv - vec2(0.5, 0.5), vec2(0.04, 0.07),0.06);\n    vec4 rectColor = vec4(vec3(smoothedge(d)),1. - smoothedge(d));\n    rectColor.rgb = vec3(39./255.,38./255.,56./255.);\n    baseColor = mix(baseColor,rectColor,rectColor.a);\n    \n    vec4 color = drawObjectColor(uv,fragCoord);\n    color = mix(baseColor,color,color.a);\n    \n    fragColor =  color;\n}","name":"Buffer A","description":"","type":"buffer"}]}