{"ver":"0.1","info":{"id":"Xl2XW3","date":"1446936777","viewed":166,"name":"AA circle","username":"fx","description":"Test for a fake anti-aliased circle.\nSet MOVE to 1.0 or more to test aliasing with movement.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["circle","aa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define NB_ROWS 3.0\n#define SPACE 10.0\n#define MOVE 0.0\n#define MSAA_SAMPLES 4\n//#define COMPARE_TO_MSAA\n\nfloat circle_step(vec2 center, vec2 pos, float radius)\n{\n    return step(length(center-pos), radius);\n}\n\nfloat circle_lerp(vec2 center, vec2 pos, float radius, float falloff)\n{\n    float d = length(center-pos) - radius;\n    d *= falloff;\n    return 1.0-clamp(d, 0.0, 1.0);\n}\n\nfloat smooth(float t)\n{\n    return t*t*(3.0 - 2.0*t);\n}\n\nfloat circle_smooth(vec2 center, vec2 pos, float radius, float falloff)\n{\n    float d = circle_lerp(center, pos, radius, falloff);\n    \n    return smooth(d);\n}\n\nfloat circle_avg(vec2 center, vec2 pos, float radius, float falloff)\n{\n \tvec4 d = vec4(\n        length(center-vec2( 0.5, 0.5)-pos),\n        length(center-vec2( 0.5,-0.5)-pos),\n        length(center-vec2(-0.5,-0.5)-pos),\n        length(center-vec2(-0.5, 0.5)-pos));\n    \n    float m = min(min(d.x, d.y), min (d.z, d.w));\n    float M = max(max(d.x, d.y), max (d.z, d.w));\n    \n    float avgd = 0.5*(m+M) - radius;\n    //float avgd = (d.x+d.y+d.z+d.w)*0.25 - radius;\n    avgd *= falloff;\n    \n    return 1.0-clamp(avgd, 0.0, 1.0);\n}\n\nfloat circle_avg_smooth(vec2 center, vec2 pos, float radius, float falloff)\n{\n    float d = circle_avg(center, pos, radius, falloff);\n    \n    return smooth(d);\n}\n\nfloat circle_msaa(vec2 center, vec2 pos, float radius)\n{\n    float size = 1.0 / float(MSAA_SAMPLES-1);\n    float avgd = 0.0;\n    for (int x=0; x<MSAA_SAMPLES; x++)\n    {\n        for (int y=0; y<MSAA_SAMPLES; y++)\n        {\n            vec2 subpos = pos + vec2(-0.5 + float(x)*size, -0.5 + float(y)*size);\n    \t\tfloat d = length(center-subpos)-radius;\n            avgd += d;\n        }\n    }\n    avgd /= float(MSAA_SAMPLES*MSAA_SAMPLES);\n    \n    return 1.0-clamp(avgd, 0.0, 1.0);\n}\n\n\nfloat r = floor(((iResolution.y-SPACE)/NB_ROWS - SPACE)*0.5);\nfloat idx = 0.0;\nfloat div = floor(iResolution.y / (2.0*r+SPACE));\nvec2 center = vec2(r+SPACE, r+SPACE);\n\nvoid animate()\n{\n    center += 0.5*MOVE*SPACE*vec2(1.0+sin(iTime*MOVE), 0.0);\n}\n\nvoid next()\n{\n    idx++;\n    vec2 pos = vec2(floor(idx/div), mod(idx, div));\n    center = pos*(2.0*r+SPACE)+r+SPACE;\n    animate();\n}\n\n#ifdef COMPARE_TO_MSAA\n#define NEXT_AND_COMPARE() p -= circle_msaa(center, pos, r); next();\n#else\n#define NEXT_AND_COMPARE() next();\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord;\n    \n    float p = 0.0;\n    animate();\n    \n    p += circle_lerp(center,pos, r, 0.5);\n    NEXT_AND_COMPARE();\n    p += circle_lerp(center, pos, r, 1.0);\n    NEXT_AND_COMPARE();\n    p += circle_lerp(center, pos, r, 2.0);\n    NEXT_AND_COMPARE();\n    p += circle_smooth(center, pos, r, 0.5);\n    NEXT_AND_COMPARE();\n    p += circle_smooth(center, pos, r, 1.0);\n    NEXT_AND_COMPARE();\n    p += circle_smooth(center, pos, r, 2.0);\n    NEXT_AND_COMPARE();\n    p += circle_avg(center, pos, r, 0.5);\n    NEXT_AND_COMPARE();\n    p += circle_avg(center, pos, r, 1.0);\n    NEXT_AND_COMPARE();\n    p += circle_avg(center, pos, r, 2.0);\n    NEXT_AND_COMPARE();\n    p += circle_avg_smooth(center, pos, r, 0.5);\n    NEXT_AND_COMPARE();\n    p += circle_avg_smooth(center, pos, r, 1.0);\n    NEXT_AND_COMPARE();\n    p += circle_avg_smooth(center, pos, r, 2.0);\n    NEXT_AND_COMPARE();\n    \n    p += circle_msaa(center, pos, r);\n    next();\n    next();\n    p += circle_step(center, pos, r);\n    \n\t#ifdef COMPARE_TO_MSAA\n    // to \"enhance\" comparison result\n    p = pow(abs(p), 0.1);\n    #endif\n    fragColor = vec4(p, p, 0, 1);\n}","name":"","description":"","type":"image"}]}