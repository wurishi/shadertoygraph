{"ver":"0.1","info":{"id":"DssGRn","date":"1665574692","viewed":132,"name":"Rolling sine","username":"ChunderFPV","description":"Just some trig stuff.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["wave","sine","trigonometry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCALE 5.0\n#define PI radians(180.0)\n#define TAU (PI*2.0)\n#define CS(a) vec2(cos(a), sin(a))\n#define curve(v,w) smoothstep(w*fwidth(v), 0.0, abs(v))\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    return length(pa - ba*h);\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n    vec2 R = iResolution.xy;\n    vec4 m = iMouse; m.xy = m.xy*2.0/R-1.0; // ±1x, ±1y\n    float z = (m.z > 0.0) ? pow(1.0-abs(m.y), 2.0*sign(m.y)): 1.0; // zoom from mouse y\n    vec2 sc = (XY-0.5*R)/R.y*SCALE*z; // screen coords\n    float x = sc.x;\n    float y = sc.y;\n    float t = iTime+(m.x*TAU);\n    float px = length(fwidth(sc)*0.7);\n    \n    vec3 c = vec3(0); // background\n    \n    // xy grid\n    vec2 xyg = abs(fract(vec2(sc.x+t, sc.y)+0.5)-0.5)/fwidth(sc);\n    c = mix(c, vec3(0.06), 1.0-min(min(xyg.x, xyg.y), 1.0));\n    \n    c += pow(max(0.0, 1.0-abs(y)), 2.0/px)*0.6; // x axis\n    if (x < 0.0) c.r += curve(sin(PI+x+t)-y+1.0, 1.0); // sine of x\n    if (x < 0.0) c.gb += curve(cos(PI+x+t)-y+1.0, 1.0); // cosine of x\n    \n    // line to sine\n    float l2s = sdLine(sc, vec2(0.0, 1.0), vec2(0.0, 1.0-sin(t)));\n    c.r += max(0.0, 1.0-smoothstep(0.0, px, l2s));\n    \n    // line to cosine\n    float l2c = sdLine(sc, vec2(0.0, 1.0), vec2(0.0, 1.0-cos(t)));\n    c.gb += max(0.0, 1.0-smoothstep(0.0, px, l2c));\n    \n    // unit circle on x\n    vec2 ucc = vec2(sc.x, sc.y-1.0); // unit circle coords\n    ucc *= mat2(cos(t), -sin(t), sin(t), cos(t)); // rotate\n    float ucr = length(ucc); // unit circle radius\n    c = max(c, pow(min(ucr, 1.0/ucr), 2.0/px)*0.4);\n    \n    // unit circle diameter\n    float ucd = sdLine(ucc, vec2(0.0, -1.0), vec2(0.0, 1.0));\n    c = max(c, (1.0-smoothstep(0.0, px*2.0, ucd))*0.25);\n    \n    // arc length\n    if (atan(x, y-1.0)+PI < abs(mod(t, TAU)))\n        c.g += pow(min(ucr, 1.0/ucr), 1.0/px)*0.6;\n    \n    // sine circle\n    vec2 sinc = vec2(ucc.x-0.5, ucc.y); // coords\n    float sinr = length(sinc)*2.0; // radius\n    c.r += pow(min(sinr, 1.0/sinr), 1.0/px)*0.6;\n    \n    // cosine circle\n    vec2 cosc = vec2(ucc.x, ucc.y+0.5); // coords\n    float cosr = length(cosc)*2.0; // radius\n    c.gb += pow(min(cosr, 1.0/cosr), 1.0/px)*0.6;\n    \n    RGBA = vec4(exp(log(c)/2.2), 1.0);\n}","name":"Image","description":"","type":"image"}]}