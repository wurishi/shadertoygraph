{"ver":"0.1","info":{"id":"tscfzs","date":"1605821855","viewed":205,"name":"Walking donuts","username":"sylvain69780","description":"Had a lot of fun using the polar symetry.\nYou can play with it ! \nChange ITEMS_COUNT, size of the Capped Torus DONUT_SIZE, change for another SDF in line 233 ...\nHere I managed to make a constant length arc of elements.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["polar","symmetry","walk"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Walking donuts\n    --------------\n    \n    You can find here a capped polar domain repetition function.\n    This allows the walking animation.\n    You are encouraged to modify the code and have fun.\n\n    References\n\n    Distance functions - IQ\n    https://iquilezles.org/articles/distfunctions\n    Rotational symmetry - IQ\n    https://www.shadertoy.com/view/XtSczV\n    \n    Live Coding \"Sphere Gears\" - Part 1 - IQ\n    https://youtu.be/sl9x19EnKng?t=1745\n\n    RayMarching starting point - BigWIngs\n    https://shadertoy.com/view/WtGXDD\n    https://www.youtube.com/watch?v=2dzJZx0yngg    \n\n*/\n\n#define PI 3.14159265\n#define TAU 6.283185\n#define PHI (1.618033988749895)\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\n#define sat(x) clamp(x, 0., 1.)\n\n#define ITEMS_COUNT 13\n#define DONUT_SIZE .12\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat remap01(float a, float b, float t) {\n\treturn sat((t-a)/(b-a));\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// Mercury's hg_sdf library.\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions/2.)) c = abs(c);\n    return c;\n}\n\n\n// simple function if you have all objets identical (no need to manage an ID)\nvec3 opRepPolar(vec3 p,float radius,float sectors) {\n    float angle = TAU/sectors;\n    float sector = round(atan(p.z,p.x)/angle);\n    p.xz *= Rot(-angle*sector);\n    p.x -= radius;\n    return p;\n}\n\n// odd number of sectors with aperture\nvec3 opRepPolarOdd(vec2 p,float radius,int sectors,float aperture) {\n    float angle = (TAU-aperture)/float(2*sectors+1);\n    p *= Rot(-float(sectors)*angle); // move to first sector\n    float at=atan(p.y,p.x); \n    int sector = clamp(int(round(at/angle)),-sectors,sectors); \n    p *= Rot(-angle*float(sector));\n    p.x -= radius;\n    return vec3(p,sector+sectors);\n}\n\n// even number of sectors with aperture\nvec3 opRepPolarEven(vec2 p,float radius,int sectors,float aperture) {\n    float angle = (TAU-aperture)/float(2*sectors);\n    p *= Rot(-float(sectors-1)*angle); // move to first sector\n    float at=atan(p.y,p.x);   \n    if ( at < -PI+angle*.5 ) at = at+TAU; // manage atan discontinuity split \n    int sector = clamp(int(round(at/angle)),-sectors+1,sectors); \n    p *= Rot(-angle*float(sector));\n    p.x -= radius;\n    return vec3(p,sector+sectors-1);\n}\n///// bottom up versions\n// odd number of sectors with aperture\nvec3 opRepPolarOddBU(vec2 p,float radius,int sectors,float aperture) {\n    float angle = (TAU-aperture)/float(2*sectors+1);\n    p *= Rot(float(sectors)*angle); // move to first sector\n    float at=atan(p.y,p.x); \n    int sector = clamp(int(round(at/angle)),-sectors,sectors); \n    p *= Rot(-angle*float(sector));\n    p.x -= radius;\n    return vec3(p,sector+sectors);\n}\n\n// even number of sectors with aperture\nvec3 opRepPolarEvenBU(vec2 p,float radius,int sectors,float aperture) {\n    float angle = (TAU-aperture)/float(2*sectors);\n    p *= Rot(float(sectors)*angle); // move to first sector\n    float at=atan(p.y,p.x);   \n    if ( at < -PI+angle*.5 ) at = at+TAU; // manage atan discontinuity split \n    int sector = clamp(int(round(at/angle)),-sectors+1,sectors); \n    p *= Rot(-angle*float(sector));\n    p.x -= radius;\n    return vec3(p,sector+sectors-1);\n}\n\n\nvec3 opRepPolar(vec2 p,float radius,int sectors,float aperture) {\n    return\n        sectors % 2 == 0 ?  \n        opRepPolarEven(p,radius,sectors / 2,aperture) :\n\t    opRepPolarOdd(p,radius,sectors / 2,aperture);\n}\n\nvec3 opRepPolarBU(vec2 p,float radius,int sectors,float aperture) {\n    p=-p;\n    return\n        sectors % 2 == 0 ?  \n        opRepPolarEvenBU(p,radius,sectors / 2,aperture) :\n\t    opRepPolarOddBU(p,radius,sectors / 2,aperture);\n}\n\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nvec2 sdRepBox(vec3 p) {\n    vec3 r;  // transform in xy id in z\n    vec3 q;\n    float id;\n    float time = T*0.5;\n    \n    float l=4.;\n    float sz=l/ float(ITEMS_COUNT);\n    float a=(PI*(1.+1./float(ITEMS_COUNT-1)))*cos(-time*PI);\n    q=p;\n    \n    bool headup = fract(time*.5) > .5;\n    float stride = l*(1.-1./float(ITEMS_COUNT))/PI;\n    q.x-=stride; // center\n     q.x-=-2.*fract(time)*stride; // follow\n     // a = 0.0;\n    if ( headup ) {    \n        // straight\n        if ( abs(a) < 0.01 ) {\n            id=clamp(round((q.y)/sz),0.,float(ITEMS_COUNT-1));\n            q.y = q.y-sz*id; // repetion\n        } else if ( a >0.) {\n        // bend right\n            float ll = l/a;\n            r=opRepPolar(vec2(-q.x+ll,q.y),ll,ITEMS_COUNT,TAU-a);\n            id=r.z;\n            q=vec3(-r.x,r.y,q.z);\n        } else {\n        // bend left\n            float ll = -l/a;\n            r=opRepPolar(vec2(q.x+ll,q.y),ll,ITEMS_COUNT,TAU+a);\n            id=r.z;\n            q=vec3(r.x,r.y,q.z);\n        }\n    } else {\n        // straight\n        if ( abs(a) < 0.01 ) {\n            q.xy=-q.xy;\n            q.y-=-l+sz;\n            id=clamp(round((q.y)/sz),0.,float(ITEMS_COUNT-1));\n            q.y = q.y-sz*id; // repetion\n            // id-=float(ITEMS_COUNT)+1.0;\n        } else if ( a >0.0) {\n        // bend right\n            float ll = l/a;\n            r=opRepPolarBU(vec2(-q.x-ll,q.y),ll,ITEMS_COUNT,TAU-a);\n            id=r.z;\n            q=vec3(-r.x,r.y,q.z);\n        } else {\n        // bend left\n            float ll = -l/a;\n            r=opRepPolarBU(vec2(q.x-ll,q.y),ll,ITEMS_COUNT,TAU+a);\n            id=r.z;\n            q=vec3(r.x,r.y,q.z);\n        }\n    }\n    \n    \n    float d = sdCappedTorus(q.zxy-vec3(0.,0.,0.0),vec2(sin(2.),cos(2.)),.4,DONUT_SIZE);\n\t// float d = sdTorus(q,vec2(.4,DONUT_SIZE));\n    // float d = sdHexPrism(q.zxy,vec2(0.4,DONUT_SIZE))-.02;\n    // float d = sdOctahedron(q,0.4); \n    // float d = length(q)-0.4; // sphere\n    return vec2(d,id);\n}\n\nvec2 GetDist(vec3 p) {\n    vec2 dm = sdRepBox(p-vec3(0.0,0.0-1.9,0.0));\n    return dm;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, inout vec3 gc) {\n\tfloat dO=0.;\n    vec2 dm;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        dm = GetDist(p);\n        // Ripped from Shaw\n        float at = .03 / (1. + dm.x * dm.x * 100.);\n        vec3 gcc = vec3(1., .5, 0.); // hsv2rgb(vec3(Hash(dm.y),0.8,1.)); // \n        gc += gcc * at;       \n        float dS = dm.x;\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return vec2(dO,dm.y);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(f,vec3(0,1,0))),\n        u = cross(r,f),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 1.5, 3.8);\n    if ( iMouse.x > .0 ) {\n       ro.yz *= Rot(-m.y*3.14);\n       ro.xz *= Rot(-m.x*6.2831);\n    }\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    vec3 gc = vec3(0);\n    vec2 dm = RayMarch(ro, rd,gc);\n    \n    if(dm.x<MAX_DIST) {\n    \tvec3 p = ro + rd * dm.x;\n    \tvec3 n = GetNormal(p);\n        \n        vec3  sun_lig = normalize( vec3(0.2, 0.35, 0.5) );        \n    \tfloat dif = clamp(dot( n, sun_lig ), 0.0, 1.0 )+.05;\n        vec3  sun_hal = normalize( sun_lig-rd );\n\t\tfloat sun_spe = pow(clamp(dot(n,sun_hal),0.0,1.0),8.0)*dif*(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n        float sun_sha = 1. ; //step(-RayMarch(p+0.01*n, sun_lig).x,-MAX_DIST);\n        col += 1.*sun_spe*vec3(8.10,6.00,4.20)*sun_sha;\n//        vec3 c = hsv2rgb(vec3(Hash(dm.y),0.8,1.)); // random colors\n        vec3 c=vec3(0.5); // *dm.y/float(ITEMS_COUNT);\n        if ( dm.y == 0.0 ) c=vec3(1.0,0.0,0.0);\n        if ( dm.y == float(ITEMS_COUNT-1) ) c=vec3(0.0,0.0,1.0);\n        // c=vec3(0.,0.,1.);\n        // blinking\n        // c *= 1. +1.8*S(.95,1.0,abs(sin(dm.y/PI+iTime*1.)));  // S(2.,0.,abs(dm.y-fract(iTime)*float(ITEMS_COUNT)));\n    \tcol += dif*c*(sun_sha*.9+.1);  \n        \n    } else { col = vec3(.1+.01*Hash21(uv))*(.5-abs(uv.y));}\n    col+=gc;   \n    col = sqrt(col);\t// gamma correction\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}