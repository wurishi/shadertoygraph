{"ver":"0.1","info":{"id":"X32SD3","date":"1711156723","viewed":100,"name":"Lode Style Voxel DDA 3D","username":"chronos","description":" Following the naming conventions in \"Lode's Computer Graphics Tutorial\"\n https://lodev.org/cgtutor/raycasting.html","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["ray","raycast","tutorial","visualization","voxel","dda","cast","diagram","lode"],"hasliked":0,"parentid":"MXSXWK","parentname":"Lode Style Voxel DDA Ray Caster"},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n        Lode Style Voxel DDA 3D by chronos\n    \n    --------------------------------------------------------------------------------------\n    \n        Took the previous voxel DDA implementation to the next dimension!\n\n        Let me know if you spot any issues! I don't handle the case where components of rayDir can be zero,\n        so that is a potential TODO, but I haven't seen any issues with that yet.\n\n        For this version I wanted to have a solid (-ish) foundation to build upon,\n        so this is purposefully fairly verbose, and not compressed / optimized at all.\n        I'll save that for another shader! :)\n\n        // self link: https://www.shadertoy.com/view/X32SD3\n        \n        // See also:\n            \"Artifact fixed voxel DDA\" by  DapperCore: https://www.shadertoy.com/view/X3SXDy\n            \"Artifact fixed voxel DDA with AO\" by  DapperCore: https://www.shadertoy.com/view/M3SXWV\n\n            \"Branchless Voxel Raycasting\" by fb39ca4: https://www.shadertoy.com/view/4dX3zl\n            \"DDA Voxel UV Mapping \" by BeljihnWahfl: https://www.shadertoy.com/view/ddyXDt\n        \n            There are also a huge amount of minecraft-like voxel shaders you can search for :P\n        \n        This shader is not based on any of the above shaders (this isn't branchless at all),\n        but is rather an extension of my previous shader to 3D, which in turn is based \n        on the common inspiration for the aforementioned shaders, namely the Lode tutorial\n        found here: https://lodev.org/cgtutor/raycasting.html\n\n*/\n\nfloat voxelmap(vec3 p) // voxel map\n{\n    p = floor(p) + 0.5 - vec3(0, 10., 0);\n    float result = (length(vec2(p.x, abs(length(p.yz) - 10.))) - 4.);\n    return result;\n}\n\nvec3 rot(vec3 p, vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    vec3 proj = dot(p, axis) * axis;\n    return proj + cos(angle) * (p-proj) + sin(angle) * cross(axis, p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =  (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse_release = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    vec2 mouse_press = (2.*abs(iMouse.zw)-iResolution.xy)/iResolution.y;\n\n    vec2 mouse = mouse_release;\n    \n    if(length(iMouse.xy) < 10.)\n    {\n        mouse_release = vec2(cos(iTime*.5), sin(iTime*.5));\n        mouse_press = vec2(0);\n    }\n\n    vec3 color = vec3(0);\n    \n    // Camera setup\n    \n    float focal = 1.;\n    \n    vec3 pos = vec3(0., 0, 0.);          // Start / camera position\n    vec3 rayDir = (vec3(uv,-focal));     // Direction to cast ray    \n    \n    float angle = iTime;\n    \n    rayDir = rot(rayDir, vec3(0,0,1), angle/2.);\n    \n    pos -= vec3(0., 10., 0.);\n    pos = rot(pos, vec3(1,0,0), angle);\n    pos += vec3(0., 10., 0.);\n    \n    rayDir = rot(rayDir, vec3(1,0,0), angle);\n    \n    vec3 rayDirNorm = normalize(rayDir);\n\n    // DDA setup\n\n    vec3 map = floor(pos);           // integer cell coordinate of initial / current cell\n\n    vec3 stepDir=vec3(0);            // step sign +/- 1\n    vec3 sideDist=vec3(9e9);         // initial distance to cell sides, then relative difference between traveled sides\n    \n    #if 1\n    vec3 deltaDist = 1./abs(rayDir); // ray length required to step from one cell border to the next in x, y and z directions\n    #else\n    vec3 deltaDist = 1./abs(rayDirNorm); // ray length required to step from one cell border to the next in x, y and z directions\n    #endif\n    \n    float side=0.;\n\n    if(rayDir.x < 0.)\n    {\n        stepDir.x = -1.; // left\n        sideDist.x = (pos.x - map.x) * deltaDist.x;\n    }\n    else\n    {\n        stepDir.x = 1.; // right\n        sideDist.x = (map.x+1. - pos.x) * deltaDist.x;\n    }\n    \n    if(rayDir.y < 0.)\n    {\n        stepDir.y = -1.; // down\n        sideDist.y = (pos.y - map.y) * deltaDist.y;\n    }\n    else\n    {\n        stepDir.y = 1.; // up\n        sideDist.y = (map.y+1. - pos.y) * deltaDist.y;\n    }\n    \n    if(rayDir.z < 0.)\n    {\n        stepDir.z = -1.; // front\n        sideDist.z = (pos.z - map.z) * deltaDist.z;\n    }\n    else\n    {\n        stepDir.z = 1.; // back\n        sideDist.z = (map.z+1. - pos.z) * deltaDist.z;\n    }\n    \n    // DDA marching \n    \n    for(int i = 0; i < 50; i++)\n    {\n        // Decide which way to go!\n        if(sideDist.x <= sideDist.y && sideDist.x <= sideDist.z)\n        {\n            sideDist.x += deltaDist.x; // Add time until next hit in x direction \n            map.x += stepDir.x; // step right/left\n            side = 0.; // yz wall\n        }\n        else if(sideDist.y <= sideDist.z && sideDist.y <= sideDist.x)\n        {\n            sideDist.y += deltaDist.y; // Add time until next hit in y direction \n            map.y += stepDir.y; // step up/down\n            side = 1.; // xz wall\n        }\n        else\n        {\n            sideDist.z += deltaDist.z; // Add time until next hit in z direction \n            map.z += stepDir.z; // step front/back\n            side = 2.; // xy wall\n        }\n        if(voxelmap(map) > 0.) // Did we hit anything? if so, we are done!\n            break;\n    }\n\n    color = vec3(0);\n    \n    // color[int(side)] = 1.; color *= 0.; // debug sides\n    \n    //vec3 n = vec3[3](vec3(1,0,0), vec3(0,1,0), vec3(0,0,1))[int(side)];\n    vec3 n = vec3(side==0., side==1., side==2.);\n    vec3 p = map + .5 - stepDir*.5;\n\n    // Solve ray plane intersection equation: dot(n, ro + t * rd - p = 0.\n    // for t :\n    float t = (dot(n, p) - dot(n, pos)) / dot(n, rayDirNorm);\n    \n    vec3 hit = pos + rayDirNorm * t;\n\n    vec2 texCoord = fract(vec2[3](hit.yz, hit.xz, hit.xy)[int(side)]);\n    \n    if(side == 0.)\n        color = pow(texture(iChannel0, texCoord).rgb, vec3(2.2));\n    else if(side == 1.)\n        color = pow(texture(iChannel1, texCoord).rgb, vec3(2.2));\n    else\n        color = pow(texture(iChannel2, texCoord).rgb, vec3(2.2));\n\n    color = pow(color, vec3(1./2.2));\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"precision highp float;","name":"Common","description":"","type":"common"}]}