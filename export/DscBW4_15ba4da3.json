{"ver":"0.1","info":{"id":"DscBW4","date":"1697148084","viewed":187,"name":"Liquid DOS","username":"studiobloom","description":"issa liquid DOS monitor:)","likes":6,"published":1,"flags":2,"usePreview":0,"tags":["retro","distortion","crt","glitch","analog"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Impactful Parameters\nfloat timeMultiplier = 3.;        // Adjusts speed of the time-based effects\nvec2 gridScale = vec2(3., 5.);    // Adjusts scale of the grid\nfloat patternMultiplier = 1.3;    // Adjusts intensity of the pattern\nfloat threshold = 0.3;            // Adjusts intensity threshold for the digit\nvec3 brightness = vec3(0.9);       // Adjusts brightness of the visual\n\nfloat time;\n\n// generate a noise value for a given point p\nfloat noise(vec2 p) {\n    return sin(p.x * 10.) * sin(p.y * (3. + sin(time / 11.))) + .2; \n}\n\n// generate a 2x2 rotation matrix\nmat2 rotate(float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\n// Fractal Brownian Motion function\nfloat fbm(vec2 p, float luminance) {\n    p *= 1.0 + luminance;\n    float f = 0.;\n    float amp = .5;\n    for(int i = 0; i < 3; i++) {\n        mat2 modify = rotate((time + luminance * 10.) / 50. * float(i * i));\n        f += amp * noise(p);\n        p = modify * p;\n        p *= 2.;\n        amp /= 2.2;\n    }\n    return f;\n}\n\n// generate a pattern based on noise\nfloat pattern(vec2 p, out vec2 q, out vec2 r, float luminance) {\n    q = vec2(fbm(p + vec2(1.), luminance), fbm(rotate(.1 * time) * p + vec2(1.), luminance));\n    r = vec2(fbm(rotate(.1) * q + vec2(0.), luminance), fbm(q + vec2(0.), luminance));\n    return fbm(p + 1. * r, luminance);\n}\n\n// generate a visual representation of a digit based on noise\nfloat digit(vec2 p, float luminance) {\n    vec2 grid = gridScale * 15.;\n    vec2 s = floor(p * grid) / grid;\n    p = p * grid;\n    vec2 q, r;\n    float intensity = pattern(s / 10., q, r, luminance) * patternMultiplier - 0.03;\n    p = fract(p);\n    p *= vec2(1.2, 1.2);\n    float x = fract(p.x * 5.);\n    float y = fract((1. - p.y) * 5.);\n    int i = int(floor((1. - p.y) * 5.));\n    int j = int(floor(p.x * 5.));\n    int n = (i-2)*(i-2)+(j-2)*(j-2);\n    float f = float(n)/16.;\n    float isOn = intensity - f > threshold ? 1. : 0.;\n    return p.x <= 1. && p.y <= 1. ? isOn * (0.2 + y*4./5.) * (0.75 + x/4.) : 0.;\n}\n\n// color for a given point p\nvec3 getColor(vec2 p, float luminance) {\n    float bar = mod(p.y + time * 20., 1.) < 0.2 ?  1.4  : 1.;\n    float middle = digit(p, luminance);\n    float off = 0.002;\n    float sum = 0.;\n    for (float i = -1.; i < 2.; i += 1.) {\n        for (float j = -1.; j < 2.; j += 1.) {\n            sum += digit(p + vec2(off * i, off * j), luminance);\n        }\n    }\n    return brightness * middle + sum/10. * vec3(0., 1., 0.) * bar;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    time = iTime / timeMultiplier;\n    vec4 webcamColor = texture(iChannel0, fragCoord / iResolution.xy);\n    float luminance = dot(webcamColor.rgb, vec3(0.299, 0.587, 0.114));\n    vec2 p = fragCoord / iResolution.xy;\n    vec3 col = getColor(p, luminance);\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}