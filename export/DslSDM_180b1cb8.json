{"ver":"0.1","info":{"id":"DslSDM","date":"1669067050","viewed":2371,"name":"Quadtree ReSTIR GI","username":"Mathis","description":"My last implementation of quadtree GI was bad, so this is an attempt at improving it.\nScene is scaled to the viewport, reset the time if you change the resolution.\n\nPaint diffuse/emissive geometry with the mouse. More controls in Image.","likes":74,"published":1,"flags":48,"usePreview":0,"tags":["gi","global","illumination","quadtree","restir","reservoir"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nReSTIR GI using quadtrees\n    There is no spatial denoiser -> the viewport will be a bit noisy\n    Maximum resolution is 1024^2, otherwise the scene is scaled to the viewport resolution\n        Reset the timer if the resolution is changed\n    Rays are accelerated using a quadtree\n        Hardware mipmaps are used\n        Press V to visualize the LODS\n    Dynamic scene\n        Paint your own scene using the mouse\n            r/d/e defines removal/emissive/diffuse\n            1-5 defines the brush radius\n        Some geometry are animated: click on a to enable/disable them\n    ReSTIR\n        Light finally responds fast to changes in the scene\n        Reservoirs in 2D are smaller and easier to store\n        Color blending problem: W is the average of 3 color channels\n            The weights in every color channel are generally different from each\n            other which results in colors replacing each other instead of mixing (ex red and green)\n\n\nControls:\n    Use your mouse to paint new geometry in the scene\n    Key R:     Remove geometry\n    Key D:     Create geometry: diffuse\n    Key E:     Create geometry: emissive\n    Key 1-5:   Change painting radius to 2^(n-1)\n    Key V:     Visualize quadtree\n    Key A:     Disable/enable animated geometry\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 Color = vec3(0.);\n    vec4 Inter = texture(iChannel0,vec2(1.5,0.5)*IRES);\n    if (max(fragCoord.x,fragCoord.y)<1024.) {\n        //Inside the scene\n        if (Inter.y==0.) {\n            //Visualize path tracing\n            vec4 SceneInfo = texture(iChannel3,vec3(-1.,fragCoord*I512-1.));\n            if (SceneInfo.w>0.5) {\n                //Geometry\n                if (SceneInfo.x>1.) {\n                    //Emissive\n                    Color = SceneInfo.xyz-1.;\n                } else {\n                    //Diffuse\n                    vec4 SC = texture(iChannel2,fragCoord*IRES);\n                    Color = SC.xyz;\n                }\n            } else {\n                //Air pixel\n                Color = texture(iChannel2,fragCoord*IRES).xyz;\n            }\n        } else {\n            //Visualize the scene and the quadtree\n            float CLOD = START_LOD;\n            float Size = pow(2.,START_LOD);\n            float ISize = pow(0.5,START_LOD);\n            //Iteration\n            vec2 LUV = (floor(fragCoord*ISize)+0.5)*Size;\n            for (float i=0.; i<START_LOD; i++) {\n                if (textureLod(iChannel3,vec3(-1.,LUV*I512-1.),CLOD).w==0.) {\n                    break;\n                }\n                CLOD -= 1.;\n                Size *= 0.5;\n                ISize *= 2.;\n                LUV = (floor(fragCoord*ISize)+0.5)*Size;\n            }\n            //Output\n            Color = vec3((START_LOD-CLOD)/9.);\n        }\n    }\n    //Return\n    fragColor=vec4(pow(1.-exp(-1.4*Color),vec3(0.45)),1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Settings\nconst float START_LOD = 9.;\nconst float M_CLAMP_T = 10.;\nconst float ReservoirScale = 4.;\nconst float IReservoirScale = 1./ReservoirScale;\nconst vec3 SkyColor = vec3(0.6,0.85,1.)*1.25;\nconst vec3 SunColor = vec3(1.,0.7,0.2)*10.;\n#define SecondBounce\n\n//Other vars\nconst float I256 = 1./256.;\nconst float I512 = 1./512.;\nconst float I1024 = 1./1024.;\nconst float PI = 3.141592653;\nconst float PI2 = PI*2.;\nconst float IPI2 = 0.5/PI;\n#define RES iChannelResolution[0].xy\n#define IRES (1./iChannelResolution[0].xy)\n\nvec3 SampleSky(vec2 d) {\n    return SkyColor*max(0.,2.*d.y-1.); //+pow(max(0.,dot(d,normalize(vec2(1.,0.7)))),10.)*SunColor;\n}\n\nfloat LineDF(vec2 p, vec2 a, vec2 b) {\n    //Distance Field\n    vec2 ba = b-a;\n    float k = dot(p-a,ba)/dot(ba,ba);\n    return length((a+clamp(k,0.,1.)*(b-a))-p);\n}\n\nfloat BoxDF(vec2 p, vec2 b) {\n    vec2 d = abs(p-b*0.5)-b*0.5;\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\nfloat boxfar2(vec2 origin, vec2 dir, vec2 bmin, vec2 bmax) {\n    //Returns the far side of a 2D box\n    vec2 tMin = (bmin-origin)*dir;\n    vec2 tMax = (bmax-origin)*dir;\n    vec2 t2 = max(tMin,tMax);\n    return min(t2.x,t2.y);\n}\n\nvec2 box2(vec2 origin, vec2 dir, vec2 bmin, vec2 bmax) {\n    //Returns the near and far side of a 2D box\n    vec2 tMin = (bmin-origin)*dir;\n    vec2 tMax = (bmax-origin)*dir;\n    vec2 t1 = max(tMin,tMax);\n    vec2 t2 = min(tMin,tMax);\n    return vec2(max(t2.x,t2.y),min(t1.x,t1.y));\n}\n\nvec2 boxNormal(vec2 origin, vec2 dir, vec2 bmin, vec2 bmax) {\n    vec2 tMin=(bmin-origin)*dir;\n    vec2 tMax=(bmax-origin)*dir;\n    vec2 t1=min(tMin,tMax);\n    vec2 t2=max(tMin,tMax);\n    vec2 signdir = -(max(vec2(0.),sign(dir))*2.-1.);\n    if (t1.x>t1.y) return vec2(signdir.x,0.);\n    else return vec2(0.,signdir.y);\n}\n\nvec2 Rotate(vec2 p, float ang) {\n    float c=cos(ang), s=sin(ang);\n    return vec2(p.x*c-p.y*s,p.x*s+p.y*c);\n}\n\n//Bad vec2/vec3 to float functions\nvec3 FloatToVec3(float v, float scale) {\n    float x = fract(v);\n    float y = floor(mod(v,100.))*0.01;\n    float z = floor(v*0.01)*0.01;\n    return vec3(x,y,z)*scale;\n}\n\nfloat Vec3ToFloat(vec3 v, float invscale) {\n    v = min(v*invscale,vec3(0.999));\n    return v.x+floor(v.y*100.)+floor(v.z*100.)*100.;\n}\n\nvec2 FloatToMAngle(float v) {\n    return vec2(floor(v),fract(v)*PI2);\n}\n\nfloat MAngleToFloat(vec2 ma) {\n    return ma.x+min(0.99999,ma.y*IPI2);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Stores vars\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = texture(iChannel0,fragCoord*IRES);\n    if (fragCoord.y<1.) {\n        if (fragCoord.x<1.) {\n            //Store mouse\n            if (iFrame<2) {\n                Output = vec4(-1.);\n            } else {\n                if (iMouse.z>0.) {\n                    //Mouse clicked\n                    if (Output.x<0.) {\n                        //First frame\n                        Output = iMouse.xyxy;\n                    } else {\n                        //Later frames\n                        Output = vec4(iMouse.xy,Output.xy);\n                    }\n                } else {\n                    Output=vec4(-1.);\n                }\n            }\n        } else if (fragCoord.x<2.) {\n            //Geometry type\n            if (iFrame<2) {\n                Output = vec4(1.,0.,1.,0.0001);\n            } else {\n                //Keyboard input\n                if (texelFetch(iChannel1,ivec2(69,1),0).x>0.) {\n                    //Key E\n                    Output.x = 2.;\n                } else if (texelFetch(iChannel1,ivec2(68,1),0).x>0.) {\n                    //Key D\n                    Output.x = 1.;\n                } else if (texelFetch(iChannel1,ivec2(82,1),0).x>0.) {\n                    //Key R\n                    Output.x = 0.;\n                }\n            }\n            //Visualize quadtree\n            if (texelFetch(iChannel1,ivec2(86,1),0).x>0.) {\n                Output.y = 1.-Output.y;\n            }\n            //Radius\n            if (texelFetch(iChannel1,ivec2(49,1),0).x>0.) {\n                Output.z = 1.;\n            } else if (texelFetch(iChannel1,ivec2(50,1),0).x>0.) {\n                Output.z = 2.;\n            } else if (texelFetch(iChannel1,ivec2(51,1),0).x>0.) {\n                Output.z = 4.;\n            } else if (texelFetch(iChannel1,ivec2(52,1),0).x>0.) {\n                Output.z = 8.;\n            } else if (texelFetch(iChannel1,ivec2(53,1),0).x>0.) {\n                Output.z = 16.;\n            }\n            //Dynamic geometry bool\n            Output.w += ((Output.w>=0.)?iTimeDelta:0.);\n            if (texelFetch(iChannel1,ivec2(65,1),0).x>0.) {\n                Output.w = -Output.w;\n            }\n        } else if (fragCoord.x<3.) {\n            //Frames\n            if (iFrame<1) {\n                //Initial frame\n                Output = vec4(0.);\n            } else if (textureSize(iChannel2,0).x>1) {\n                //Texture loaded\n                Output = vec4(1.,Output.y+1.,0.,0.);\n            }\n        } else if (fragCoord.x<4.) {\n            //Resolution\n            Output = vec4(iChannelResolution[0].xy,Output.xy);\n        }\n    }\n    fragColor = Output;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Temporal ReSTIR\n\nvec4 TraceQuadTree(vec2 P, vec2 D, inout vec2 UV) {\n    //Traces a ray through the quad tree\n    vec2 IDir = 1./D;\n    float FAR = boxfar2(P,IDir,vec2(0.5),vec2(1023.5));\n    float t = 0.; float LFar=FAR; vec2 cp,fp; vec2 bb; vec4 C;\n    float LOD = START_LOD;\n    float LS = pow(2.,LOD);\n    float ILS = pow(0.5,LOD);\n    for (int i=0; i<128; i++) {\n        if (t>FAR) break;\n        if (t>LFar && LOD<START_LOD) {\n            LOD = LOD+1.;\n            LS *= 2.;\n            ILS *= 0.5;\n            fp = floor(cp*ILS)*LS;\n            LFar = boxfar2(P,IDir,fp,fp+LS);\n        }\n        cp = P+D*t;\n        fp = floor(cp*ILS)*LS;\n        C = textureLod(iChannel3,vec3(1.,(fp+0.5*LS)*I512-1.),LOD);\n        bb = box2(P,IDir,fp,fp+LS);\n        if (C.w>0. && ((bb.x>=0. && bb.y>bb.x) || BoxDF(cp-fp,vec2(LS))<=0.)) {\n            if (LOD==0.) {\n                UV = fp+0.5;\n                return vec4(C.xyz,bb.x);\n            } else if (LOD>0.) {\n                LFar = bb.y;\n                LOD -= 1.;\n                LS *= 0.5;\n                ILS *= 2.;\n                continue;\n            }\n        }\n        t = bb.y+0.01;\n    }\n    //Return\n    return vec4(-1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = vec4(0.);\n    vec3 NLight = vec3(0.);\n    float Frame = texture(iChannel0,vec2(2.5,0.5)*IRES).y;\n    if (Frame>0.5 && max(fragCoord.x,fragCoord.y)<1024.) {\n        //Inside the scene\n        vec4 Attr = texture(iChannel3,vec3(1.,fragCoord*I512-1.));\n        if (Attr.w>0.5) {\n            //Geometry\n            Output = vec4(Attr.xyz,-1.);\n        } else {\n            //Air pixels\n            vec2 RUV;\n            vec4 LR = texture(iChannel1,fragCoord*IRES);\n            if (iFrame%3==0) {\n                //Sample validation\n                vec2 MA = FloatToMAngle(LR.z);\n                vec2 RDir = vec2(cos(MA.y),sin(MA.y));\n                vec4 RHit = TraceQuadTree(fragCoord,RDir,RUV);\n                float PTDist = 10000.;\n                if (RHit.w>-0.5) {\n                    //Geometry\n                    PTDist = RHit.w;\n                    if (RHit.x>1.) {\n                        //Emissive\n                        NLight += RHit.xyz-1.;\n                    } else {\n                        //Second bounce\n                        #ifdef SecondBounce\n                        vec2 SNor = boxNormal(fragCoord,1./RDir,RUV-0.5,RUV+0.5);\n                        float SRA = texture(iChannel2,(RUV+MA.y*157.1278)*I1024).y*PI;\n                        vec2 SRDir = normalize(sin(SRA)*SNor+cos(SRA)*vec2(-SNor.y,SNor.x));\n                        vec2 SRUV;\n                        vec4 SRHit = TraceQuadTree(RUV+SNor,SRDir,SRUV);\n                        if (SRHit.w>-0.5) NLight += ((SRHit.x>1.)?SRHit.xyz-1.:vec3(0.))*0.5;\n                        else NLight += SampleSky(SRDir)*0.5;\n                        NLight *= RHit.xyz;\n                        #endif\n                    }\n                } else {\n                    //Sky\n                    NLight += SampleSky(RDir);\n                }\n                //Sample test\n                if (length(FloatToVec3(LR.x,ReservoirScale)-NLight)>0.1) {\n                    //Invalid sample\n                    Output = vec4(Vec3ToFloat(NLight,IReservoirScale),PTDist,MAngleToFloat(vec2(1.,MA.y))*0.+LR.y,LR.w);\n                } else {\n                    //Valid sample\n                    Output = LR;\n                }\n            } else {\n                //Temporal ReSTIR\n                vec2 RandUV = (fragCoord+Frame*vec2(67.293,73.475))*I1024;\n                float RA = (texture(iChannel2,RandUV).y*255.+texture(iChannel2,RandUV).x)*I256*PI2;\n                vec2 RDir = vec2(cos(RA),sin(RA));\n                vec4 RHit = TraceQuadTree(fragCoord,RDir,RUV);\n                float PTDist = 10000.;\n                if (RHit.w>-0.5) {\n                    //Geometry\n                    PTDist = RHit.w;\n                    if (RHit.x>1.) {\n                        //Emissive\n                        NLight += RHit.xyz-1.;\n                    } else {\n                        //Second bounce\n                        #ifdef SecondBounce\n                        vec2 SNor = boxNormal(fragCoord,1./RDir,RUV-0.5,RUV+0.5);\n                        float SRA = texture(iChannel2,(RUV+RA*157.1278)*I1024).y*PI;\n                        vec2 SRDir = normalize(sin(SRA)*SNor+cos(SRA)*vec2(-SNor.y,SNor.x));\n                        vec2 SRUV;\n                        vec4 SRHit = TraceQuadTree(RUV+SNor,SRDir,SRUV);\n                        if (SRHit.w>-0.5) NLight += ((SRHit.x>1.)?SRHit.xyz-1.:vec3(0.))*0.5;\n                        else NLight += SampleSky(SRDir)*0.5;\n                        NLight *= RHit.xyz;\n                        #endif\n                    }\n                } else {\n                    //Sky\n                    NLight += SampleSky(RDir);\n                }\n                //Update reservoir\n                if (LR.w<-0.5) {\n                    //New reservoir\n                    LR = vec4(Vec3ToFloat(NLight,IReservoirScale),PTDist,MAngleToFloat(vec2(1.,RA)),1.);\n                } else {\n                    //Old reservoir\n                    float Rand1 = (texture(iChannel2,RandUV).z*255.+texture(iChannel2,RandUV*1.478).z)/256.;\n                    float w = max(0.,dot(NLight,vec3(0.3333))); //Target pdf\n                    vec2 MA = FloatToMAngle(LR.z);\n                    MA.x = min(MA.x,M_CLAMP_T-1.); //Clamping\n                    vec3 LLight = FloatToVec3(LR.x,ReservoirScale);\n                    float Rw = max(0.,dot(LLight,vec3(0.3333)))*MA.x*LR.w+w; //R.w += w\n                    if (Rand1<w/max(0.0001,Rw)) {\n                        //New sample\n                        LLight = NLight;\n                        MA.y = RA;\n                        LR.x = Vec3ToFloat(NLight,IReservoirScale);\n                        LR.y = PTDist;\n                    }\n                    MA.x += 1.; //M += 1\n                    float p_hat = max(0.,dot(LLight,vec3(0.3333))); //p hat\n                    LR.w = Rw/max(0.0001,MA.x*p_hat); //Update W\n                    LR.z = MAngleToFloat(MA);\n                }\n                //Output\n                Output = LR;\n            }\n        }\n    } else Output = vec4(0.,0.,0.,-1.);\n    //Return\n    fragColor = Output;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//Spatial ReSTIR\n\nvec4 TraceQuadTree(vec2 P, vec2 D, inout vec2 UV) {\n    //Traces a ray through the quad tree\n    vec2 IDir = 1./D;\n    float FAR = boxfar2(P,IDir,vec2(0.5),vec2(1023.5));\n    float t = 0.; float LFar=FAR; vec2 cp,fp; vec2 bb; vec4 C;\n    float LOD = START_LOD;\n    float LS = pow(2.,LOD);\n    float ILS = pow(0.5,LOD);\n    for (int i=0; i<128; i++) {\n        if (t>FAR) break;\n        if (t>LFar && LOD<START_LOD) {\n            LOD = LOD+1.;\n            LS *= 2.;\n            ILS *= 0.5;\n            fp = floor(cp*ILS)*LS;\n            LFar = boxfar2(P,IDir,fp,fp+LS);\n        }\n        cp = P+D*t;\n        fp = floor(cp*ILS)*LS;\n        C = textureLod(iChannel3,vec3(1.,(fp+0.5*LS)*I512-1.),LOD);\n        bb = box2(P,IDir,fp,fp+LS);\n        if (C.w>0. && ((bb.x>=0. && bb.y>bb.x) || BoxDF(cp-fp,vec2(LS))<=0.)) {\n            if (LOD==0.) {\n                UV = fp+0.5;\n                return vec4(C.xyz,bb.x);\n            } else if (LOD>0.) {\n                LFar = bb.y;\n                LOD -= 1.;\n                LS *= 0.5;\n                ILS *= 2.;\n                continue;\n            }\n        }\n        t = bb.y+0.01;\n    }\n    //Return\n    return vec4(-1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = vec4(0.);\n    //Diffuse spatial ReSTIR\n    vec4 Attr = texture(iChannel3,vec3(1.,fragCoord*I512-1.));\n    if (Attr.w<0.5) {\n        //Air pixel\n        //Reservoir\n        vec4 CR = texture(iChannel1,fragCoord*IRES);\n        vec3 CLight = FloatToVec3(CR.x,ReservoirScale);\n        vec2 CMA = FloatToMAngle(CR.z);\n        float CRw = max(0.,dot(CLight,vec3(0.3333)))*CMA.x*CR.w;\n        //Stochastic reprojection\n        int NSamples = 8;\n        float SpatialRadius = 1.+texture(iChannel2,(fragCoord*(1.+mod(float(iFrame)*3.67,3.768)))*IRES).z*14.;\n        float AngleDelta = 6.28318530718/float(NSamples);\n        float CAngle = texture(iChannel2,(fragCoord*2.446+mod(float(iFrame)*2.44,512.))*I1024).x*AngleDelta;\n        float Jacobian,wnew,np_hat; vec2 SUV,WUV,SRand,MA,SRDir,HitPos; vec3 SLight; vec4 SAttr,SR;\n        for (int s=0; s<NSamples; s++) {\n            //For all spatial reservoirs\n            CAngle += AngleDelta;\n            SUV = floor(fragCoord+vec2(sin(CAngle),cos(CAngle))*SpatialRadius)+0.5;\n            if (BoxDF(SUV,iResolution.xy)>=0.) continue;\n            SAttr = texture(iChannel3,vec3(1.,SUV*I512-1.));\n            if (SAttr.w>0.5) continue; //Geometry pixel\n            SR = texture(iChannel1,SUV*IRES);\n            MA = FloatToMAngle(SR.z);\n            SLight = FloatToVec3(SR.x,ReservoirScale);\n            //Reservoir visibility\n            SRDir = vec2(cos(MA.y),sin(MA.y));\n            HitPos = SUV+SRDir*SR.y;\n            if (abs(TraceQuadTree(fragCoord,normalize(HitPos-fragCoord),WUV).w-length(HitPos-fragCoord))>0.1) continue;\n            //Accumulation\n            Jacobian = 1.;\n            np_hat = max(0.,dot(SLight,vec3(0.3333)));\n            wnew = np_hat*MA.x*SR.w*max(0.0001,Jacobian);\n            CRw += wnew;\n            vec2 rUV = SUV+mod(float(iFrame),2048.)*vec2(3.683,4.887);\n            float Randv = (texture(iChannel2,rUV*1.3*I1024).z*255.+texture(iChannel2,(rUV*2.4)*I1024).z)/256.;\n            if (Randv<wnew/max(0.0001,CRw)) {\n                CLight = SLight;\n                CR.y = SR.y;\n                CMA.y = MA.y;\n            }\n            CMA.x += MA.x;\n        }\n        //Bias correction\n        float Z = CMA.x;\n        float bias_p_hat = max(0.,dot(CLight,vec3(0.3333)));\n        CR.w = CRw/max(0.0001,Z*bias_p_hat);\n        //Output\n        Output = vec4(Vec3ToFloat(CLight,IReservoirScale),CR.y,MAngleToFloat(CMA),CR.w);\n    } else {\n        //Geometry pixel\n        Output = vec4(0.,0.,0.,-1.);\n    }\n    fragColor = Output;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//Temporal accumulation\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = texture(iChannel3,fragCoord*IRES)*((iFrame<1)?0.:1.);\n    //Current reservoir\n    vec4 CRT = texture(iChannel1,fragCoord*IRES);\n    if (CRT.w<-0.5) {\n        Output = vec4(0.,0.,0.,-1.);\n    } else {\n        if (Output.w<-0.5) Output = vec4(0.,0.,0.,0.);\n        vec2 CMA = FloatToMAngle(CRT.z);\n        vec4 CRS = texture(iChannel2,fragCoord*IRES);\n        vec3 NLight = FloatToVec3(CRS.x,ReservoirScale)*CRS.w;\n        //3x3 clamping\n        vec3 Min = vec3(10000.);\n        vec3 Max = vec3(0.);\n        for (float x=-1.; x<1.5; x++) {\n            for (float y=-1.; y<1.5; y++) {\n                vec4 CRS = texture(iChannel2,(fragCoord+vec2(x,y))*IRES);\n                vec3 SLight = FloatToVec3(CRS.x,ReservoirScale)*CRS.w;\n                Min = min(Min,SLight);\n                Max = max(Max,SLight);\n            }\n        }\n        Output.xyz = clamp(Output.xyz,Min,Max);\n        //Accumulation\n        Output = vec4((Output.xyz*Output.w+NLight)/(Output.w+1.),min(8.,Output.w+1.));\n    }\n    fragColor = Output;\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"//Scene storage\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir) {\n    vec4 Output = texture(iChannel3,rayDir);\n    float Frame = texture(iChannel0,vec2(2.5,0.5)*IRES).y;\n    vec4 Inter = texture(iChannel0,vec2(1.5,0.5)*IRES);\n    vec2 UV; vec3 aDir = abs(rayDir);\n    if (aDir.x>aDir.y) {\n        //X-side\n        UV = floor(((rayDir.yz/aDir.x)*0.5+0.5)*1024.)+0.5;\n        vec2 SUV = UV*IRES.y;\n        float LDF,df;\n        if (rayDir.x>0. && BoxDF(UV,iChannelResolution[0].xy)<0.) {\n            //Scene\n            if (Frame<1.5 || length(iChannelResolution[0].xy-texture(iChannel0,vec2(3.5,0.5)*IRES).zw)>0.5) {\n                //Static geometry\n                Output = vec4(0.);\n                //Content round box\n                if (BoxDF(SUV-vec2(0.125,0.55),vec2(0.075,0.02))-IRES.y*3.<0.) Output = vec4(vec3(0.99,0.1,0.1),1.);\n                    if (length(SUV-vec2(0.2,0.5))<0.03) Output = vec4(3.6,2.4,1.6,1.);\n                //Normal curve emissive and diffuse\n                float fx = SUV.x-(IRES.y/IRES.x)*0.5;\n                float fy = SUV.y-0.02;\n                df = abs(0.2*exp(-fx*fx*12.)-fy);\n                if (df<IRES.y*2.) Output = vec4(1.01+mix(vec3(0.,0.5,2.),vec3(2.,0.7,0.),1.-UV.x*IRES.x),1.);\n                df = abs(0.04+0.2*exp(-fx*fx*12.)-fy);\n                if (df<IRES.y*2. && abs(fract(SUV.x*7.)-0.5)>0.2) Output = vec4(vec3(0.5),1.);\n                //Mandelbrot\n                vec4 MOutput = vec4(0.);\n                fx = (SUV.x-0.9)*3.;\n                fy = (SUV.y-0.7)*3.;\n                float tmpz = fx;\n                float rfx = 0.707*(fx+fy);\n                float rfy = 0.707*(-tmpz+fy);\n                tmpz = 0.;\n                float zr = 0.;\n                float zi = 0.;\n                for (int Iter=0; Iter<100; Iter++) {\n                    if (zr*zr+zi*zi>4.) break;\n                    tmpz = zr;\n                    zr = zr*zr-zi*zi+rfx;\n                    zi = 2.*zi*tmpz+rfy;\n                }\n                if (zr*zr+zi*zi<4.) {\n                    MOutput = vec4(vec3(0.9),1.);\n                }\n                //Carving the mandelbrot\n                MOutput.w *= float(BoxDF(vec2(fx,fy)-vec2(-0.4,-0.4),vec2(0.5))-0.07>0.);\n                if (length(vec2(fx+0.15,fy+0.15))<0.06) Output = vec4(vec3(1.6,2.5,1.6),1.);\n                if (MOutput.w>0.5) Output = MOutput;\n                //Red/Green box\n                if (max(BoxDF(SUV-vec2(1.2,0.3),vec2(0.3)),-BoxDF(SUV-vec2(1.21,0.31),vec2(0.28,0.5)))<0.)\n                    Output = vec4(vec3(0.99),1.);\n                if (BoxDF(SUV-vec2(1.3,0.325),vec2(0.1,0.01))<0.) Output = vec4(vec3(3.),1.); //Emissive\n                    if (BoxDF(SUV-vec2(1.21,0.31),vec2(0.01,0.29))<0.) Output = vec4(vec3(0.99,0.1,0.1),1.); //Red\n                    if (BoxDF(SUV-vec2(1.48,0.31),vec2(0.01,0.29))<0.) Output = vec4(vec3(0.05,0.99,0.05),1.); //Green\n                    if (LineDF(SUV,vec2(1.3,0.4),vec2(1.4,0.5))<0.015) Output = vec4(vec3(0.99),1.);\n                        if (LineDF(SUV,vec2(1.35,0.55),vec2(1.425,0.425))<0.015) Output = vec4(vec3(0.99),1.);\n                        if (LineDF(SUV,vec2(1.25,0.6),vec2(1.45,0.6))<0.005) Output = vec4(vec3(0.99),1.);\n                //Randomness\n                if (BoxDF(SUV-vec2(1.15,0.675),vec2(0.5,0.4))<0.025) {\n                    vec2 Rand2 = texture(iChannel2,(SUV-vec2(1.15,0.65))*0.05).yz;\n                    if (Rand2.x>0.55) Output = vec4(vec3(0.99)+((Rand2.y>0.89)?0.:0.),1.);\n                    if (length(SUV-vec2(1.3,0.815))<0.01) Output = vec4(vec3(3.,1.2,1.2),1.);\n                        if (length(SUV-vec2(1.44,0.835))<0.01) Output = vec4(vec3(1.1,3.2,3.2),1.);\n                }\n            } else {\n                //Update scene\n                if (Inter.w>0.) {\n                    //Dynamic geometry\n                    //Circle with holes (small)\n                    df = length(SUV-vec2(0.85,0.65))-0.04;\n                    if (df>0. && df<IRES.y*3.) {\n                        if (fract(atan(SUV.x-0.85,SUV.y-0.65)*0.95+0.25+Inter.w)<0.5) Output.w = 1.;\n                        else Output = vec4(0.);\n                    }\n                    //Round box\n                    float tmpx = 0.3+sin(Inter.w*1.5)*0.125;\n                    if (abs(BoxDF(SUV-vec2(0.1,0.5),vec2(0.4))-0.05)<IRES.y*2.) Output = vec4(vec3(0.99),1.);\n                    if (abs(SUV.x-tmpx)<0.05 && abs(SUV.y-0.95)<IRES.y*3.) Output = vec4(0.);\n                    //Rotating round box\n                    vec2 RUV = SUV-vec2(0.3,0.725); RUV = Rotate(RUV,Inter.w);\n                    if (length(RUV)<0.075+IRES.y*5.) {\n                        if (LineDF(RUV,vec2(-0.075,0.),vec2(0.075,0.))-IRES.y*5.<0.) Output = vec4(vec3(0.99),1.);\n                        else Output = vec4(0.);\n                    }\n                }\n                float Radius = 4.;\n                if (iMouse.z>0.) {\n                    LDF = LineDF(UV,texture(iChannel0,vec2(0.5)*IRES).zw,iMouse.xy);\n                    if (LDF<Inter.z) {\n                        if (Inter.x<0.5) {\n                            //Remove geometry\n                            Output = vec4(0.);\n                        } else {\n                            //Diffuse or emissive\n                            Output = vec4(((Inter.x<1.5)?vec3(0.99):vec3(2.)),1.);\n                        }\n                    }\n                }\n            }\n        } else {\n            //Copy of scene\n            Output = texture(iChannel3,vec3(-rayDir.x,rayDir.yz));\n        }\n    }\n    fragColor = Output;\n}","name":"Cube A","description":"","type":"cubemap"}]}