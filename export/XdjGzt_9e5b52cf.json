{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define time (iTime * 0.5)\n\n#define dithering\t\t\t3.00\n#define antialiasing\t\t1.00\n\n#define samples 32\n\n#define brightness\t1.5\n#define gamma\t\t1.0\n\n//#define noise\n#define crossEyeStereo\n#define nonlinearPerspective\n#define ditherMode\n\nstruct material {\n\tvec3 color;\n\tvec3 light;\n\tfloat diffusion;\n};\n\nstruct hit {\n\tvec3 p;\n\tvec3 n;\n\tfloat t;\n\tmaterial m;\n};\n\nhit plane (const in vec3 v, float f, const in material m, const in vec3 p, const in vec3 d) {\n\tfloat t = (f - dot (v, p)) / dot (v, d);\n\t\n\thit h;\n\t\n\th.p = p + d * t;\n\th.n = faceforward (v, v, d);\n\th.t = t;\n\th.m = m;\n\t\n\treturn h;\n}\n\nhit sphere (const in vec3 v, float f, const in material m, const in vec3 p, const in vec3 d) {\n\tvec3 rp = p - v;\n\t\n\tfloat b = dot (d, rp);\n\tfloat c = dot (rp, rp) - f*f;\n\t\n\tfloat g = b*b - c;\n\t\n\thit h;\n\th.t = -1.0;\n\t\n\tif (g < 0.0)\n\t\treturn h;\n\t\n\tfloat root = sqrt (g);\n\tfloat t = -root - b;\n\t\n\tif (t < 0.0)\n\t\tt = root - b;\n\t\n\th.p = p + d * t;\n\th.n = (h.p - v) / f;\n\th.n = faceforward (h.n, h.n, d);\n\th.t = t;\n\th.m = m;\n\t\n\treturn h;\n}\n\nvoid add (const in hit c, inout hit h) {\n\tif(c.t > 0.0 && c.t < h.t)\n\t\th = c;\n}\n\nhit scene (const in vec3 p, const in vec3 d) {\n\thit h;h.t = 1e20;\n\t\n\tfloat c = sin (time * 2.0) * 0.5 + 1.5;\n\t\n\tmaterial m1 = material (vec3 ( 1.0, 1.0, 1.0), vec3 ( 0.0, 0.0, 0.0), 0.5);\n\tmaterial m2 = material (vec3 ( 0.8, 0.5, 0.2), vec3 ( 0.0, 0.0, 0.0), 0.1);\n\tmaterial m3 = material (vec3 ( 0.2, 0.5, 0.8), vec3 ( 0.0, 0.0, 0.0), 0.1);\n\tmaterial m4 = material (vec3 ( 0.2, 0.2, 0.2), vec3 ( 0.0, 0.0, 0.0), 0.1);\n\tmaterial m5 = material (vec3 ( 1.0, 1.0, 1.0), vec3 ( 1.0, 1.0, 1.0), 0.1);\n\tmaterial m6 = material (vec3 ( 1.0, 0.0, 0.0), vec3 ( 0.0, 0.0, 0.0), 0.1);\n\t\n\tadd (sphere\t(vec3 (0,0,0), 0.5, m2, p, d), h);\n\tadd (sphere\t(vec3 (c,0,0), 0.5, m3, p, d), h);\n\t\n\tadd (plane\t(vec3 (1,0,0), 4.0, m1, p, d), h);\n\tadd (plane\t(vec3 (1,0,0),-4.0, m1, p, d), h);\n\tadd (plane\t(vec3 (0,1,0), 3.0, m1, p, d), h);\n\tadd (plane\t(vec3 (0,1,0),-0.5, m4, p, d), h);\n\tadd (plane\t(vec3 (0,0,1), 4.0, m6, p, d), h);\n\tadd (plane\t(vec3 (0,0,1),-4.0, m5, p, d), h);\n\t\n\treturn h;\n}\n\nfloat seed1;\nfloat rndValue () {\n\t//seed1 = seed1 / 31.0 + fract (sin (seed1 * 101.0) * 131.0);\n\tseed1 = fract (seed1 * 31.01);\n\treturn seed1;\n}\nvec2 rndUnit2D () {\n\tfloat angle = rndValue () * 6.28318530718;\n\treturn vec2 (sin (angle), cos (angle));\n}\nvec2 rnd2D () {\n\tfloat radius = sqrt (rndValue ());\n\treturn rndUnit2D () * radius;\n}\nvec3 rndUnit3D () {\n\tfloat z = rndValue () * 2.0 - 1.0;\n\tvec2 xy = rndUnit2D () * sqrt (1.0 - z*z);\n\treturn vec3 (xy, z);\n}\n\nvec3 dir (const in vec3 n, const in vec3 d, const in float p) {\n\tvec3 f = normalize (cross (n, rndUnit3D ()));\n\tvec3 r = cross (f, n);\n\tvec2 disc = rnd2D ();\n\tfloat z = sqrt (1.0 - dot (disc, disc));\n\treturn f * disc.x + r * disc.y + n * z;\n}\n\nvec3 rayColor (const in vec3 p, const in vec3 d) {\n\t#ifdef noise\n\tseed1 = fract (seed1 + d.x + d.y + d.z);\n\t#endif\n\t\n\thit h;\n\tvec3 p1 = p;\n\tvec3 d1 = d;\n\t\n\tvec3 light = vec3 (0);\n\tvec3 color = vec3 (1);\n\tfor (int i = 0; i < 3; i++) {\n\t\th = scene (p1, d1);\n\t\tlight += h.m.light * color;\n\t\tcolor *= h.m.color;\n\t\t\n\t\td1 = dir (h.n, d1, h.m.diffusion);\n\t\tp1 = h.p + d1 * 0.001;\n\t}\n\t\n\treturn light;\n}\n\nvec3 rayDirection (const in vec3 r, const in vec3 u, const in vec3 f, const in float fov, in vec2 cr) {\n\tvec2 rs = cr * 3.14159 * fov;\n\tvec2 sn = sin (rs);\n\tvec2 cs = cos (rs);\n\t\n\t#ifdef nonlinearPerspective\n\treturn normalize (r * sn.x + u * sn.y + f * cs.x * cs.y);\n\t#else\n\treturn normalize (r * cr.x * 4.0 * fov + u * cr.y * 4.0 * fov + f);\n\t#endif\n}\n\nvoid camera (inout vec3 right, inout vec3 up, inout vec3 forward, inout vec3 p, inout vec2 cr) {\n\tforward = normalize (forward);\n\tright = normalize (cross (up, forward));\n\tup = normalize (cross (forward, right));\n\t\n\t#ifdef crossEyeStereo\n\tfloat s = sign (cr.x);\n\tcr.x = (cr.x - s * 0.25);\n\tp -= right * s / iResolution.x * 200.0;\n\t#endif\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t#ifdef ditherMode\n\tseed1 = 2.0 + mod (fragCoord.x * 2.0 + fragCoord.y, dithering * 2.0);\n\t#else\n\tseed1 = 2.0 + mod (fragCoord.x, dithering) + mod (fragCoord.y, dithering) * dithering;//by TekF\n\t#endif\n\t\n\tvec2 cr = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.x;\n\tvec3 p = vec3 (sin (time) * 2.0, sin (time) * 0.5 + 0.3, cos (time) * 2.0);\n\n\tvec3 right, up = vec3 (0,1,0), forward = vec3 (0,0.25,0)-p;\n\tcamera (right, up, forward, p, cr);\n\t\n\tvec3 color = vec3 (0);\n\tfor (int i = 0; i < samples; i++) {\n\t\tvec3 d = rayDirection (right, up, forward, 0.5, cr + rnd2D () / iResolution.x * antialiasing);\n\t\t\n\t\tcolor += rayColor (p, d);\n\t}\n\tcolor = pow (color / float (samples), vec3 (gamma));\n\tfloat v = dot (cr, cr) * 3.0;\n\tfragColor = vec4 (color / (1.0 + v*v) * brightness, 0.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdjGzt","date":"1392336074","viewed":809,"name":"Dithered","username":"DiLemming","description":"asd","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["3d","pathtracing"],"hasliked":0,"parentid":"","parentname":""}}