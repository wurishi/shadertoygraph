{"ver":"0.1","info":{"id":"mlfSRn","date":"1674260184","viewed":92,"name":"Semi-Discretized Gyroid Surface","username":"myth0genesis","description":"A gyroid with semi-discretized angle calculations. There is still curvature on the surface and the distance is butchered, but I don't remember at all how I came up with the math for this, so I'm not sure where to go from here ¯\\_(ツ)_/¯","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["ray","raymarch","march","gyroid","discretized"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2023 myth0genesis\n\nconst int maxstps = 120;\nconst float maxdst = 100.0;\nconst float mindst = 0.001;\nconst float pi = 3.1415927410125732421875;\nconst float tau = 6.283185482025146484375;\n\nmat2 rot2D(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s,\n                s,  c);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat gyroidSDF2(vec3 p, float scale, float offset, float divFac) {\n    float dfi = 1.0 / floor(divFac);\n    p *= scale;\n    p /= dfi;\n    vec3 pf = floor(p);\n\tvec3 a = sin(dfi * tau * pf);\n\tvec3 b = sin(dfi * tau * (pf + 1.0));\n\tvec3 c = cos(dfi * tau * pf.yzx);\n\tvec3 d = cos(dfi * tau * (pf.yzx + 1.0));\n\tvec3 f = (b - a) * (p - pf) + a;\n\tvec3 g = (d - c) * (p.yzx - pf.yzx) + c;\n\treturn dot(f, g) / scale - offset;\n}\n\nfloat map(vec3 pos) {\n    float box = sdBox(pos, vec3(2.0));\n    float gyr = gyroidSDF2(pos, 0.5, 0.0, 8.0) * 0.15;\n    return max(gyr, box);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n\tfloat dO = 0.0;\n    \n    for(int i = 0; i < maxstps; i++) {\n    \tvec3 p = ro + rd * dO;\n        float dS = map(p);\n        dO += dS;\n        if(dO > maxdst || abs(dS) < mindst) break;\n    }\n    \n    return dO;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(.001, 0.0);\n    vec3 n = map(p) - \n        vec3(map(p - e.xyy), map(p - e.yxy), map(p - e.yyx));\n    \n    return normalize(n);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\tvec2 m = -iMouse.xy / iResolution.xy;\n\n    vec3 ro = vec3(0.0, 3.0, -7.0);\n    mat2 rmxz = rot2D(m.x * tau);\n    mat2 rmyz = rot2D(m.y * tau + pi);\n    ro.yz *= rmyz;\n    ro.xz *= rmxz;\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n    rd.yz *= rot2D(0.4);\n    rd.yz *= rmyz;\n    rd.xz *= rmxz;\n    vec3 col = vec3(0.0);\n   \n    float d = rayMarch(ro, rd);\n\n    if(d < maxdst) {\n        vec3 p = ro + rd * d;\n        vec3 n = getNormal(p);\n\n        float dif = dot(n, normalize(vec3(-2.0, 2.0, 0.5))) * 0.5 + 0.5;\n        col = vec3(dif * 0.5);\n    }\n    \n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}