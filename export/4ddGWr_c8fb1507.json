{"ver":"0.1","info":{"id":"4ddGWr","date":"1449055123","viewed":1753,"name":"Palette Quantization & Dithering","username":"104","description":"Quantizing to a 64-color palette (4 values for each RGB component) and low resolution. 8x8 ordered dither using Bayer array texture. L/R split shows dithered vs. original image. Top/Bottom shows dithered vs. raw quantized. Mouse controls split.","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["palettedithering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// for a dramatic display of the value of dithering,\n// use these settings.\n//const float PaletteRGBSize = 2.;// only 1 bit per R G B (8-color palette)\n//const float ResolutionDivisor = 1.;// 1 pixel = 1 pixel, the finest visible.\n\n\nconst float PaletteRGBSize = 4.;// number of values possible for each R, G, B.\nconst float ResolutionDivisor = 2.;\n\n//#define USE_BAYER4x4\n#define USE_BAYER8x8\n//#define USE_NOISE\n//#define USE_ANIM_NOISE\n\n//----------------------------------------------------------------------------\n\n\nfloat quantize(float inp, float period)\n{\n    return floor((inp+period/2.)/period)*period;\n}\nvec2 quantize(vec2 inp, vec2 period)\n{\n    return floor((inp+period/2.)/period)*period;\n}\n\n\n//----------------------------------------------------------------------------\nfloat bayer4x4(vec2 uvScreenSpace)\n{\n\tvec2 bayerCoord = floor(uvScreenSpace/ResolutionDivisor);\n    bayerCoord = mod(bayerCoord, 4.);\n    const mat4 bayerMat = mat4(\n    1,9,3,11,\n    13,5,15,7,\n    4,12,2,10,\n    16,8,14,6) / 16.;\n    int bayerIndex = int(bayerCoord.x + bayerCoord.y * 4.);\n    if(bayerIndex == 0) return bayerMat[0][0];\n    if(bayerIndex == 1) return bayerMat[0][1];\n    if(bayerIndex == 2) return bayerMat[0][2];\n    if(bayerIndex == 3) return bayerMat[0][3];\n    if(bayerIndex == 4) return bayerMat[1][0];\n    if(bayerIndex == 5) return bayerMat[1][1];\n    if(bayerIndex == 6) return bayerMat[1][2];\n    if(bayerIndex == 7) return bayerMat[1][3];\n    if(bayerIndex == 8) return bayerMat[2][0];\n    if(bayerIndex == 9) return bayerMat[2][1];\n    if(bayerIndex == 10) return bayerMat[2][2];\n    if(bayerIndex == 11) return bayerMat[2][3];\n    if(bayerIndex == 12) return bayerMat[3][0];\n    if(bayerIndex == 13) return bayerMat[3][1];\n    if(bayerIndex == 14) return bayerMat[3][2];\n    if(bayerIndex == 15) return bayerMat[3][3];\n\n    return 10.;// impossible\n}\n\nfloat bayer8x8(vec2 uvScreenSpace)\n{\n    return texture(iChannel1, uvScreenSpace/(ResolutionDivisor*8.)).r;\n}\n\nvec3 getSceneColor(vec2 uv)\n{\n    return texture(iChannel0, uv).rgb;\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;// 0-1\n    \n    // space between values of the dest palette\n    vec3 quantizationPeriod = vec3(1./(PaletteRGBSize-1.));\n    \n\tvec2 uvPixellated = floor(fragCoord / ResolutionDivisor)*ResolutionDivisor;\n    \n    // original color panel---------------------\n    vec3 originalCol = getSceneColor(uv);\n    \n    // dithered panel---------------------\n    vec3 dc = getSceneColor(uvPixellated / iResolution.xy);\n    // apply bayer matrix, perturbing the original color values.\n#ifdef USE_BAYER4x4\n    dc += (bayer4x4(fragCoord)-.5)*(quantizationPeriod);\n#endif\n#ifdef USE_BAYER8x8\n\tdc += (bayer8x8(fragCoord)-.5)*(quantizationPeriod);\n#endif\n#ifdef USE_NOISE\n\tdc += (rand(uvPixellated)-.5)*(quantizationPeriod);\n#endif\n#ifdef USE_ANIM_NOISE\n\tdc += (rand(vec2(rand(uvPixellated),iDate.w))-.5)*(quantizationPeriod);\n#endif\n    // quantize color to palette\n    dc = vec3(\n        quantize(dc.r, quantizationPeriod.r),\n        quantize(dc.g, quantizationPeriod.g),\n        quantize(dc.b, quantizationPeriod.b)\n            );\n   \n    // quantize to palette (raw quantization panel)---------------------\n    vec3 qc = getSceneColor(uvPixellated / iResolution.xy);\n    qc = vec3(\n        quantize(qc.r, quantizationPeriod.r),\n        quantize(qc.g, quantizationPeriod.g),\n        quantize(qc.b, quantizationPeriod.b)\n            );\n\n\n    // framing and post\n    float ySplit = (iMouse.y > 0.0 ? iMouse.y / iResolution.y : 0.3);\n    float xSplit = .7;\n    if(iMouse.x > 0.) xSplit = iMouse.x / iResolution.x;\n    if(uv.x > xSplit)\n\t    fragColor = vec4(originalCol, 1);\n    else\n    {\n        if(uv.y > ySplit)\n\t\t    fragColor = vec4(dc, 1);\n        else\n\t\t    fragColor = vec4(qc, 1);\n    }\n\n    float f = abs(uv.x - xSplit);\n    fragColor.rgb *= smoothstep(.00,.005, f);\n    f = abs(uv.y - ySplit);\n    if(uv.x < xSplit)\n\t    fragColor.rgb *= smoothstep(.00,.005, f);\n}\n\n\n\n\n\n","name":"","description":"","type":"image"}]}