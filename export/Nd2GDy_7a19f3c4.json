{"ver":"0.1","info":{"id":"Nd2GDy","date":"1617901981","viewed":40,"name":"Ambient_Occlusion","username":"Drysmall","description":"Ambient Occlusion","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["cis561hw9"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Intersection{\n    float t;\n    vec3 color;\n    vec3 position;\n    int objectIdx;\n};\n\nvec3 rotateAroundY(vec3 p, float a){\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nfloat plane(vec3 pos, vec4 nor){\n  return dot(pos, nor.xyz) + nor.w;\n}\n\nfloat box(vec3 pos, vec3 b){\n  return length(max(abs(pos) - b, 0.0));\n}\n\nconst int RAY_STEPS = 512;\nconst float FOVY = 3.14156926 * 0.25;\nconst int OCCLUSION_SAMPLES = 512;\nconst float OCCLUSION_DISTANCE = 0.15;\nconst float K_VALUE = 2.;\n\n#define BACKWALL_SDF plane(pos, vec4(0., 0., -1., 5.))\n#define BACKWALL_ID 0\n\n#define LEFTWALL_SDF plane(pos, vec4(1., 0., 0., 5.))\n#define LEFTWALL_ID 1\n\n#define RIGHTWALL_SDF plane(pos, vec4(-1., 0., 0., 5.))\n#define RIGHTWALL_ID 2\n\n#define CEILING_SDF plane(pos, vec4(0., -1., 0., 7.5))\n#define CEILING_ID 3\n\n#define FLOOR_SDF plane(pos, vec4(0., 1., 0., 2.5))\n#define FLOOR_ID 4\n\n#define BOX1_SDF box(rotateAroundY(pos + vec3(-2., 0.5, -3.), -30. * 3.1415926 / 180.0), vec3(1.5, 3., 1.5))\n#define BOX1_ID 5\n\n#define BOX2_SDF box(rotateAroundY(pos + vec3(2., 1., -0.75), 15. * 3.1415926 / 180.0), vec3(1.5, 1.5, 1.5))\n#define BOX2_ID 6\n\nfloat mySceneT(vec3 pos){\n    float t = BACKWALL_SDF;\n    \n    t = min(t, LEFTWALL_SDF);\n    t = min(t, RIGHTWALL_SDF);\n    t = min(t, CEILING_SDF);\n    t = min(t, FLOOR_SDF);\n    t = min(t, BOX1_SDF);\n    t = min(t, BOX2_SDF);\n    \n    return t;\n}\n\nvec3 computeNormal(vec3 pos){\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize(vec3(mySceneT(pos + epsilon.yxx) - mySceneT(pos - epsilon.yxx),\n                          mySceneT(pos + epsilon.xyx) - mySceneT(pos - epsilon.xyx),\n                          mySceneT(pos + epsilon.xxy) - mySceneT(pos - epsilon.xxy)));\n}\n\nvoid myScene(vec3 pos, out float t, out int obj){\n    t = BACKWALL_SDF;\n    obj = BACKWALL_ID;\n    float tempT;\n    \n    if ((tempT = LEFTWALL_SDF) < t){\n        t = tempT;\n        obj = LEFTWALL_ID;\n    }\n    if ((tempT = RIGHTWALL_SDF) < t){\n        t = tempT;\n        obj = RIGHTWALL_ID;\n    }\n    if ((tempT = FLOOR_SDF) < t){\n        t = tempT;\n        obj = FLOOR_ID;\n    }\n    if ((tempT = CEILING_SDF) < t){\n        t = tempT;\n        obj = CEILING_ID;\n    }\n    if ((tempT = BOX1_SDF) < t){\n        t = tempT;\n        obj = BOX1_ID;\n    }\n    if ((tempT = BOX2_SDF) < t){\n        t = tempT;\n        obj = BOX2_ID;\n    }\n}\n\nvoid rayMarch(vec3 origin, vec3 dir, out float t, out int objHit){\n    t = 0.001;\n    \n    for (int i = 0; i < RAY_STEPS; i++){\n        float m;\n        vec3 pos = origin + t * dir;\n        \n        myScene(pos, m, objHit);\n        if (m < 0.01){\n            return;\n        }\n        t += m;\n    }\n    \n    t = -1.;\n    objHit = -1;\n}\n\nvec3 computeMaterials(int objHit, vec3 pos, vec3 nor, vec3 lightVec, vec3 view){\n    float lambert = dot(-lightVec, nor);\n    \n    switch (objHit){\n        case BACKWALL_ID:\n        return vec3(1., 1., 1.) * lambert;\n        break;\n        case LEFTWALL_ID:\n        return vec3(0, 1., 0) * lambert;\n        break;\n        case RIGHTWALL_ID:\n        return vec3(1., 0, 0) * lambert;\n        break;\n        case CEILING_ID:\n        return vec3(1., 1., 1.) * lambert;\n        break;\n        case FLOOR_ID:\n        return vec3(1., 1., 1.) * lambert;\n        break;\n        case BOX1_ID:\n        return vec3(1., 1., 1.) * lambert;\n        break;\n        case BOX2_ID:\n        return vec3(1., 1., 1.) * lambert;\n        break;\n        case -1:\n        return vec3(0., 0., 0.);\n        break;\n    }\n}\n\nfloat ambientOcclusion(vec3 pos, vec3 nor, float k){\n    float total_ambientOcclusion = 0.;\n    \n    for (float i = 0.; i < 5.; i++){\n        total_ambientOcclusion += 1. / pow(2., i) * (i * OCCLUSION_DISTANCE\n                               - mySceneT(pos + nor * i * OCCLUSION_DISTANCE));\n    }\n    \n    return 1. - k * total_ambientOcclusion;\n}\n\nIntersection sdf(vec3 dir, vec3 eye){\n    float t;\n    int objHit;\n    \n    rayMarch(eye, dir, t, objHit);\n\n    vec3 m_intersection = eye + t * dir;\n    vec3 nor = computeNormal(m_intersection);\n    vec3 lightPos = vec3(0., 4., -1.);\n    vec3 lightDir = normalize(m_intersection - lightPos);\n    \n    vec3 color = ambientOcclusion(m_intersection, nor, K_VALUE) *\n                 computeMaterials(objHit, m_intersection, nor,\n                 lightDir, normalize(eye - m_intersection));\n\n    return Intersection(t, color, m_intersection, objHit);\n}\n\n\nvec3 rayCast(vec3 eye, vec3 ref, vec2 ndc){\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, vec3(0., 1., 0.)));\n    vec3 U = normalize(cross(R, F));\n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / iResolution.y;\n    \n    return normalize(ref + ndc.x * H + ndc.y * V - eye);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - vec2(1.0, 1.0);\n    \n    vec3 eye = vec3(0, 3, -15);\n    vec3 ref = vec3(0, 2, 0);\n    \n    vec3 rayDir = rayCast(eye, ref, uv);\n    Intersection m_intersection = sdf(rayDir, eye);\n \n    fragColor = 0.9 * vec4(m_intersection.color, 1.0);\n}","name":"Image","description":"","type":"image"}]}