{"ver":"0.1","info":{"id":"lXlXzn","date":"1709107429","viewed":87,"name":"Sierpinski Shine","username":"TotallyReal","description":"Zooming into a Sierpinski triangle","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["fractal","sierpinski"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float s2 = 1.41421356237; // sqrt(2)\n\nfloat sierpinski(vec2 p){\n    p -= floor(p);\n    \n    float d = 1.;\n    float inside = 1.;\n    \n    \n    for (int i=0; i<10; i++){\n        // Break the unit square [0,1]^2 into two triangles, the bottom left and top right.\n        // For points in the top right triangle, find the distance from the edges:\n        float d1 = (p.x + p.y - 1.)/s2;\n        float d2 = 1. - p.x;\n        float d3 = 1. - p.y;\n        float dTri = max(min(d1, min(d2,d3)),0.);\n        \n        // tried to make the transition smooth... \n        float r = max(1.-dTri*(5.-float(i)/2.), 0.)*(1.-float(i)/200.);\n        // once a point is outside the Sierpinski triangle, don't change its color\n        d *= inside*r*r*r + (1.-inside);\n        \n        // Track if p is inside the Sierpinski triangle in the next iteration\n        inside *= step(p.x+p.y, 1.);\n        \n        // go to the next iteration\n        p *= 2.;\n        p -= floor(p);\n    }\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // normalize coordinates.\n    vec2 p = fragCoord.xy / iResolution.y;\n    \n    float scale = pow(2., 1. + fract(iTime));\n    \n    float d = mix(sierpinski(p/(scale*2.)), sierpinski(p/scale), fract(iTime));\n    \n    fragColor = vec4(d*d*d*d*d, d, sqrt(d), 1.);    \n}","name":"Image","description":"","type":"image"}]}