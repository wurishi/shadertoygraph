{"ver":"0.1","info":{"id":"DsdfDs","date":"1697782230","viewed":97,"name":"Redondo Game Shader","username":"rubixcom","description":"3D game rendering part of my circular chess-like game available at: https://redondo.web.app. video: https://www.youtube.com/watch?v=9P1O13ZfkeA\n\nBased on techniques described by IQ as well as my own dodgy optimisations.\n\n","likes":13,"published":1,"flags":1,"usePreview":0,"tags":["game"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Experiment at creating a circular board game based on techiques described here: \n// https://iquilezles.org/articles/raymarchingdf/\n// https://iquilezles.org/articles/rmshadows/\n// https://iquilezles.org/articles/distfunctions/\n\n#define maxSteps 50\n#define shadowSteps 10\n#define reflectionSteps 20\n\n#define LIGHTS 1\n#define SHADOWS 1\n#define REFLECTIONS 1\n\n#define M_PI 3.1415926535897932384626433832795\n#define BLANK_OBJECT_FIX 1\n#define NO_SHAPE 0.0\n#define RINGS 4\n#define SECTORS 16\n#define SHAPE_SIZE (1.0 / float(RINGS))\n#define DIST_SCALE (0.375 * float(RINGS))\n\n\nconst vec4 lightColor = vec4(1.0,.75,0.6,0.0); \nconst vec4 lightColor2 = vec4(0.0,1.0,0.6,0.0);\nconst vec4 lightColor3 = vec4(0.75,0.0,1.0,0.0);\n\nvec3 rayVector(in vec3 position, in vec3 target, in vec2 fragCoord)\n{\n    vec3 eye = normalize(target - position);\n    vec3 up = vec3(0., 1., 0.);\n    vec3 right = cross(eye, up);\n    up = cross(eye,right);\n\n    mat3 cameraMatrix = mat3(right.x, up.x, eye.x,\n                \t\t\t right.y, up.y, eye.y,\n                \t\t\t right.z, up.z, eye.z);\n\n    vec2 uv = fragCoord.xy / iResolution.xy - vec2(.5);\n    uv.x = uv.x * iResolution.x/iResolution.y;\n    uv.y = -uv.y;\n    float focalDistance = 2.;\n    return (normalize(vec3(uv.x,uv.y,focalDistance)) * cameraMatrix) * .5;\n}\n\nvec4 textureBall (in vec2 pos)\n{\n\treturn vec4(step(.5,fract((pos.x+pos.y)*4.)));\n}\n\nvec4 checkersGradBox( in vec2 p)\n{\n    float ang = M_PI + atan(p.x,p.y);\n    float dist = length(p.xy) * DIST_SCALE;\n    int ii = int(float(SECTORS/2) * ang / M_PI);\n    int jj = RINGS - int(dist);\n    return jj >= 0 && jj < RINGS ? vec4(0.01) + (mod(float(ii+jj), 2.0) == 1.0 ? .6 : .2): vec4(0.0);\n}\n    \nvec4 shade(in vec3 pos, in vec3 normal, in vec3 cameraVector, in vec3 lightPos, in vec4 lightColor, in vec4 surface)\n{\n    vec3 light = normalize(lightPos - pos);\n    float dotlight = dot(normal,light);\n\n    vec3 cameraReflected = normalize(reflect(cameraVector,normal));\n    float spec = 0.0;\n    if (dot(cameraReflected,light) < 0.0)\n        spec = min(1.0,pow(dot(cameraReflected,light),2.0));\n    return (surface\n        * vec4(0.2+dotlight) * lightColor\n        + vec4(0.5*spec)) * 10.0/length(lightPos - pos); // Sphere color\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n    return m*0.57735027;\n}\n\n\nfloat map( in vec3 pos)\n{\n    vec2 res = vec2( pos.y, 0.1 );\n\n    float ang = M_PI + atan(pos.x,pos.z);\n    float dist = length(pos.xz);\n    int ii = clamp(int(float(SECTORS/2) * ang / M_PI), 0, SECTORS-1);\n    int jj = clamp(RINGS - int(dist * DIST_SCALE), 0, RINGS-1);\n\n    float ang2 = (float(ii) + .5) * M_PI / float(SECTORS/2);\n    float dist2 = (float(jj - RINGS) - .5) / DIST_SCALE;\n    vec3 posC = vec3(dist2*sin(ang2), SHAPE_SIZE, dist2*cos(ang2));\n\n    float v = pos.y;\n    if (jj == 1 && (ii != 3 && ii != 10)) {\n        v = sdSphere( pos-posC, SHAPE_SIZE );\n    } else if (jj == 0) {\n        v = sdCappedCone( pos-posC, SHAPE_SIZE, SHAPE_SIZE, 0.1 );\n    } else if (jj == 2 && (ii == 10)) {\n        v = sdOctahedron( pos-posC, SHAPE_SIZE );\n    }\n    \n    vec3 posS = vec3(-1.6*cos(sin(iTime*1.5)),SHAPE_SIZE,1.6*sin(sin(iTime*1.5)));\n\n    return min(v, min(sdOctahedron( pos-posS, SHAPE_SIZE ), pos.y));\n}\n\n\nvec3 normal(in vec3 p, in vec3 pm)\n{\n\tif (p.y < 0.1)\n\t{\n\t\treturn vec3(0.,1.,0.);\n\t}\n\telse\n\t{\n\t\treturn normalize(pm);\n\t}\n}\n\nvec4 textured(in vec3 p)\n{\n\tif (p.y < 0.1)\n\t{\n\t\treturn checkersGradBox( p.xz);\n\t}\n\telse if (p.x < 0.0)\n\t{\n\t\treturn vec4(1.0);//textureBall( p.xz);\n\t}\n\telse if (p.x > 0.0)\n\t{\n\t\treturn vec4(0.2);//textureBall( p.xz);\n\t}\n}\n\nfloat shadow(in vec3 ro, in vec3 rd, in vec3 shapeLoc, in vec3 lightPos)\n{\n\tfloat res = 1.0;\n\tfloat t = 0.1;\n    for(int i = 1; i < shadowSteps; ++i)\n    {\n\t\tvec3 p = ro + rd * t;\n\t\tfloat h = map(p);\n\t\tif ( h < 0.001 )\n\t\t\treturn 0.001;\n\t\t\n\t\tres = min( res, 4. * h / t);\n\t\tt += clamp(h, 0.0, 0.1);\n\t}\n\t\n\treturn res;\n}\n\nvec3 normal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n                      e.yyx*map( pos + e.yyx ) + \n                      e.yxy*map( pos + e.yxy ) + \n                      e.xxx*map( pos + e.xxx ) );\n}\n    \nvec4 reflection(in vec3 ro, in vec3 rd, in vec3 shapeLoc, in mat3 rotation, in vec3 lights[3])\n{\n    vec4 color = vec4(0.0);\n\n    float t = 0.01;\n    for(int i = 0; i < reflectionSteps; ++i)\n    {\n        vec3 p = ro + rd * t;\n        \n\t\tfloat d = map(p);\n        if(d < 0.0001)\n        {\n\t\t\tvec3 normal = normal(p); vec4 texc = textured(p);\n\n\t\t\tcolor = (0.0\n#if (LIGHTS >= 1)\n\t\t\t\t+ shade(p, normal, -rd, lights[0], lightColor, texc)\n#endif\n#if (LIGHTS >= 2)\n\t\t\t    + shade(p, normal, -rd, lights[1], lightColor2, texc)\n#endif\n#if (LIGHTS >= 3)\n                + shade(p, normal, -rd, lights[2], lightColor3, texc)\n#endif\n\t\t\t) / float(LIGHTS);\n            break;\n        }\n\n        t += clamp(d, 0.0, 0.1);\n    }\n\n    return color;\n}\n\nvec4 march(in vec3 ro, in vec3 rd, in vec3 shapeLoc, in mat3 rotation, in vec3 lights[3])\n{\n    vec4 color = vec4(0.0);\n\n    float t = ((SHAPE_SIZE*2.0) - ro.y) / rd.y; // Start on top of shape\n    for(int i = 0; i < maxSteps; ++i)\n    {\n        vec3 p = ro + rd * t;\n\n\t\tfloat d = map(p);\n        if (d <= 0.01)\n        {\n\t\t\tvec3 normal = normal(p); vec4 texc = textured(p);\n\n            vec3 cameraReflected = normalize(reflect(rd, -normal));\n\n\t\t\tcolor = (0.0\n#if (LIGHTS >= 1)\n\t\t\t\t+ shade(p, normal, -rd, lights[0], lightColor, texc)\n\t#ifdef SHADOWS\n\t\t\t\t* shadow(p, normalize(lights[0]-p), shapeLoc, lights[0])\n\t#endif\n#endif\n#if  (LIGHTS >= 2)\n\t\t\t\t+ shade(p, normal, -rd, lights[1], lightColor2, texc)\n\t#ifdef SHADOWS\n\t\t\t\t* shadow(p, normalize(lights[1]-p), shapeLoc, lights[1])\n\t#endif\n#endif\n#if  (LIGHTS >= 3)\n\t\t\t\t+ shade(p, normal, -rd, lights[2], lightColor3, texc)\n\t#ifdef SHADOWS\n\t\t\t\t* shadow(p, normalize(lights[2]-p), shapeLoc, lights[2])\n\t#endif\n#endif\n\t\t\t) / float(LIGHTS)\n#ifdef REFLECTIONS\n\t\t\t+ .5*reflection(p, cameraReflected, shapeLoc, rotation, lights)\n#endif\n\t\t\t;\n\t\t\tbreak;\n        }\n\n        t += clamp(d, 0.0, 0.1);\n    }\n    return color;\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    vec3 shapeLoc = vec3(3.0,1.8,3.0);\n    vec3 lights[3];\n#if (LIGHTS >= 1)\n\tlights[0] = //vec3(-cameraLoc.x, 3.*cameraLoc.y, -cameraLoc.z);\n\t\tvec3(3. + 4.0 * sin(iTime*2.), 16.0 + 8.0 * sin(0.4*iTime) , 3.+4.0 * cos(2.*iTime));\n#endif\n#if (LIGHTS >= 2)\n\tlights[1] = vec3(3. + 4.0 * sin(iTime*3.), 4.0 + 4.0 * sin(0.2*iTime) , 3.+8.0 * cos(3.*iTime));\n#endif\n#if (LIGHTS >= 3)\n\tlights[2] = vec3(3. + 8.0 * sin(iTime*4.), 4.0 + 4.0 * sin(0.1*iTime) , 3.+4.0 * cos(4.*iTime));\n#endif\n    \n    mat3 rotation = mat3(1.0, 0.0, 0.,\n                  1.0,1.0, 0.,\n                   0.,0.,1.);\n    \n    ro *= 3.;\n    ro.y += 6.;\n    \n    fragColor = march(ro, rd, shapeLoc, rotation, lights);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 shapeLoc = vec3(3.0,1.8,3.0);\n    vec3 cameraLoc = vec3(10.0 * sin(-iTime*.4), 5.0, 10.0 * cos(-iTime*.4));\n    vec3 cameraTarget = vec3(0.0);\n    vec3 lights[3];\n#if (LIGHTS >= 1)\n\tlights[0] = //vec3(-cameraLoc.x, 3.*cameraLoc.y, -cameraLoc.z);\n\t\tvec3(6.0 * sin(iTime*.4), 6.0 , 6.0 * cos(iTime*.4));\n#endif\n#if (LIGHTS >= 2)\n\tlights[1] = vec3(6.0 * sin(iTime*.4+ 2.0*M_PI/3.0), 6.0 , 6.0 * cos(iTime*.4+ 2.0*M_PI/3.0));\n#endif\n#if (LIGHTS >= 3)\n\tlights[2] = vec3(6.0 * sin(iTime*.4+ 4.0*M_PI/3.0), 6.0 , 6.0 * cos(iTime*.4+ 4.0*M_PI/3.0));\n#endif\n    \n    vec3 ro = cameraLoc;\n    vec3 rd = rayVector(cameraLoc, cameraTarget, fragCoord);\n\n    mat3 rotation = mat3(cos(iTime*5.),-sin(iTime*5.), 0.,\n                  sin(iTime*5.),cos(iTime*5.), 0.,\n                   0.,0.,1.);\n\n    \n    fragColor = march(ro, rd, shapeLoc, rotation, lights);\n}\n","name":"Image","description":"","type":"image"}]}