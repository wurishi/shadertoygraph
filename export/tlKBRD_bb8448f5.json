{"ver":"0.1","info":{"id":"tlKBRD","date":"1614012707","viewed":298,"name":"Simple Jelly Quads","username":"kastorp","description":"move quads with mouse\n","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["physics","softbody","springdamper"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Simple Jelly Quad by Kastorp\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float d =10.;\n    vec3 col =  vec3(0.1,0.1,0.2);\n\n    for(int i=0;i<NC;i++)\n    {\n        NL=getNL(i);\n        L=.9/float(NL);\n        vec2[6] polygon;\n        vec2 b=vec2(0.);\n        for(int j=0;j<NL;j++)\n        {\n            polygon[j]=getPos(ch,ivec2(i,j)).xy;\n            b+= polygon[j]/float(NL);\n        }\n\n             \n        if(length(p-b)<L*1.5)\n        {\n            \n            d=sdPolygon(p, polygon,NL);\n            if(d <0.)  col  =fract(vec3(0.2,0.4,0.7)*float(i+1));\n            col = mix( col, vec3(1), 1.0-smoothstep(0.0,0.015,abs(d)) );\n        }\n        \n    }\n    col = mix( col, vec3(1,1,1), smoothstep(-0.02,.02,min(-scene(p,S).x,0. )));\n    \n\t\n    if(iMouse.z>0.) col = mix( col, vec3(1,1,0), 1.0-smoothstep(0.03,.06,length(M-p)) );\n    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 Q, in vec2 U )\n{\n    if(U.x>float(N.x) || U.y>float(N.y)) return;\n     \n    setup( U, ch,  iResolution);\n    if (iFrame==0 ) init(iResolution); \n    else update(ch, iResolution, iMouse);\n\n   Q=vec4(pos,vel);\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define NC 50 //number of polygons \n#define COLLISION //unstable with triangles\n\n//----------------------------------\n\n// Iq's:\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2d( in vec2 v0, in vec2 v1) { return v0.x*v1.y - v0.y*v1.x; }\nfloat sdPolygon( in vec2 p, in vec2[6] v ,int num)\n{\n    \n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 cond = bvec3( p.y>=v[i].y,  p.y <v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }  \n    return s*sqrt(d);\n}\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec2 w = abs(p)-b;\n    vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);\n    float g = max(w.x,w.y);\n    vec2  q = max(w,0.0);\n    float l = length(q);\n    return vec3(   (g>0.0)?l  :g,\n                s*((g>0.0)?q/l:((w.x>w.y)?vec2(1,0):vec2(0,1))));\n}\nvec3 sdgCircle( in vec2 p, in float r ) \n{\n    float d = length(p);\n    return vec3( d-r, p/d );\n}\nvec3 sdgMin( in vec3 a, in vec3 b )\n{\n    return (a.x<b.x)?a:b;\n}\n//from jessifin (https://www.shadertoy.com/view/lslXDf)\nvec4 bary(vec2 p,vec2 a, vec2 b, vec2 c) \n{\n    vec2 v0 = b - a, v1 = c - a, v2 = p - a;\n    float inv_denom = 1.0 / (v0.x * v1.y - v1.x * v0.y)+1e-9;\n    float v = (v2.x * v1.y - v1.x * v2.y) * inv_denom;\n    float w = (v0.x * v2.y - v2.x * v0.y) * inv_denom;\n    float u = 1.0 - v - w;   \n    vec3 k =  abs(vec3(u,v,w));\n    return k.x+k.y+k.z>1.001?vec4(k,0.):vec4(k,k.x+k.y+k.z);\n}\n\n\nvec2 prj(vec2 v, vec2 s){return v* dot(v,s)/dot(s,s);}\n\nvec3 scene(vec2 pos,vec2 s)\n{\n    vec3 bg= -sdgBox(pos, s-.01 );\n    bg= sdgMin(bg, sdgCircle(pos-vec2(s.x/2.,0.), s.y/4. ));\n    //bg= sdgMin(bg, sdgBox(pos-s/2., s/4. ));\n    return bg;\n}\n\n//------------------------------------------------------------------\n//Physics simulation\n\n#define N ivec2(NC,6)\n#define PI2 6.283\n#define S vec2(iResolution.x/iResolution.y,1)\n#define M (2.0* iMouse.xy-iResolution.xy)/iResolution.y\n#define getPos(a, p) texelFetch(a, ivec2(p), 0)\n#define ch iChannel1\n\nconst float gravity = 0.00010; \nconst float dt=1.;\nconst float stiffness=0.05;\nconst float damping=0.3;\n\nvec2 pos,vel;\nivec2 c;\nint NL;\nfloat L;\n\nint getNL(int i) {\n    return 4;// 5+ (i%2);\n}\nvoid sd(vec2 posdif,vec2 veldif, float edgelen)\n{\n    vel += normalize(posdif)*(length(posdif)-edgelen)*stiffness; // spring\n    if(dot(veldif,veldif)!=0.)  vel +=normalize(posdif)*( dot(normalize(posdif),veldif)*damping); // damper\n}\n\n#ifdef COLLISION\n//current vertex hits an external edge\nvoid coll_vertex(inout vec4 v,vec4 ve1,vec4 ve2, vec4 c)\n{\n    vec4 k=bary(v.xy,ve1.xy,ve2.xy,c.xy); \n    vec2 vl=(ve1.zw*k.x +ve2.zw*k.y)/(k.x+k.y) -v.zw;\n    if(k.w>0.) v= vec4(                \n           (ve1.xy *k.x+ ve2.xy *k.y)/(k.x+k.y) -c.xy *.0002,  \n          \n           prj(v.zw,ve1.xy-ve2.xy) + vl - prj(vl,ve1.xy-ve2.xy)\n          \n        );\n}\n\n//an external vertex hits current  edge\nvoid coll_edge(inout vec4 v,vec4 vn,vec4 ve, vec4 c)\n{\n    vec4 k=bary(ve.xy,v.xy,vn.xy,c.xy);\n    vec2 vl=(ve.zw-v.zw)*k.x/(k.y+k.x);\n    if(k.w>0.) v= vec4(\n            v.xy-   ((v.xy *k.x+ vn.xy *k.y)/(k.x+k.y)-ve.xy )+   c.xy*0.0002,\n             vl +v.zw\n            //prj(v.zw,v.xy-vn.xy)*.9  +( vl - prj(vl,v.xy-vn.xy))*1. + prj(vl,v.xy-vn.xy)*.1   //not working...tunnelling           \n        );\n}\n// edges intersect (NOT USED, UNSTABLE)\nvoid coll_edge_edge(inout vec4 v,vec4 vn, vec4 vo,vec4 ve1,vec4 ve2)\n{\n    vec2 b = (v-vn).xy, d =(ve2-ve1).xy, c= (ve1 - v).xy;\n    float cp=cross2d(b,d);\n    if (abs(cp)<0.00001) return;\n\n    float t = cross2d(c,d) / cp, u = cross2d(c,b) / cp;\n    if (t < 0. || t > 1. || u < 0. || u > 1.) return;\n\n    vec2 x = v.xy + t * b;\n    v.zw -= (ve1.zw*(1.-u) + ve2.zw*u)*(1.-t)*.2;\n}\n//object centers are too close and vertex is in between\nvoid coll_center(inout vec4 v,vec4 vo, vec4 vce,float d)\n{\n    if(length((vo-vce).xy)<d &&length((v-vce).xy)<d ) v.zw += (vo-vce).xy*(d-length((vo-vce).xy))*.2;\n}\n#endif\n\n\nvoid setup(vec2 U,sampler2D ch, vec3 iResolution)\n{\n     c = ivec2(U);\n     vec4 data= getPos(ch, c);\n     pos = data.xy;\n     vel = data.zw;\n     NL=getNL(c.x);\n     L=.9/float(NL);\n}\n\nvoid init(vec3 iResolution)\n{\n        float d =float(c.x),sz=floor(2./.3);\n\n        pos = vec2(-.8) *S + vec2(floor(d/sz),mod(d,sz))*.3\n            +sin(\n            vec2(c.y )*(PI2/float(NL))+vec2(0,PI2/4.)\n            )*.12  ;\n        vel = vec2(0.);\n}\n\nvoid update( sampler2D ch, vec3 iResolution,vec4 iMouse)\n{\n\n        vec4 v[6],b=vec4(0.);\n        for(int j=0;j<NL;j++)\n        {\n            v[j]=getPos(ch,  ivec2(c.x,(c.y+j)%NL ));\n            b+= v[j]/float(NL);                \n        }\n        \n                  \n        sd(v[1].xy -pos,v[1].zw -vel,L);\n        sd(v[NL-1].xy -pos,v[NL-1].zw -vel,L);\n        //if(NL==3) sd((v[2]+v[1]).xy*.5 -pos,(v[2]+v[1]).zw*.5 -vel,L*.87); \n        if(NL==4) sd(v[2].xy -pos,v[2].zw -vel,L*1.41); \n        if(NL==5) {sd(v[NL-2].xy -pos,v[NL-2].zw -vel,L*1.615);sd(v[2].xy -pos,v[2].zw -vel,L*1.615); }\n        if(NL==6) {sd(v[NL-2].xy -pos,v[NL-2].zw -vel,L*1.73);sd(v[2].xy -pos,v[2].zw -vel,L*1.73); }\n \n        #ifdef COLLISION\n        //collisions:\n        for(int i=0;i<NC;i++) if(i!=c.x)\n        {\n            int NL2=getNL(i);\n            vec4 ve[6],be=vec4(0.);\n            for(int j=0;j<NL2;j++)\n            {\n                ve[j]=getPos(ch,ivec2(i,j));\n                be+= ve[j]/float(NL2);                \n            }\n                                       \n            vec4 data=vec4(pos,vel);              \n            for(int j=0;j<NL2;j++)\n            {\n                const float CD[4]=  float[4](.8,1.,1.5,1.7);\n                coll_edge(data,v[NL-1], ve[j],  b);\n                coll_edge(data,v[1], ve[j],  b);\n                coll_vertex(data, ve[j], ve[(j+1)&(NL2-1)],  be);\n                coll_center(data,b,be,min(CD[NL-3],CD[NL2-3])*L);\n                //coll_edge_edge(data,v[NL-1],  b,ve[j], ve[(j+1)&(NL-1)]);\n                //coll_edge_edge(data,v[1],  b,ve[j], ve[(j+1)&(NL-1)]);\n            }\n            pos=data.xy;vel=data.zw;\n        }\n        #endif\n        \n        vel=clamp(vel,-0.02,.02);\n        pos += vel*dt;\n        \n        vel.y -= gravity; // gravity\n        \n\n        if(iMouse.z>0.&& length(M-pos)<L*.5) vel+=normalize(M-pos)*.01;\n                \n        //border collision (todo: check also edge collision)\n        vec3 bg= scene(pos,S);     \n        if(bg.x<0.) \n        \n        {\n            vel=reflect(vel,bg.yz)*.95;\n            pos.xy-=bg.x* bg.yz;\n            \n        }\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 Q, in vec2 U )\n{\n    if(U.x>float(N.x) || U.y>float(N.y)) return;\n     \n    setup( U, ch,  iResolution);\n    if (iFrame==0 ) init(iResolution); \n    else update(ch, iResolution, iMouse);\n\n   Q=vec4(pos,vel);\n\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 Q, in vec2 U )\n{\n    if(U.x>float(N.x) || U.y>float(N.y)) return;\n     \n    setup( U, ch,  iResolution);\n    if (iFrame==0 ) init(iResolution); \n    else update(ch, iResolution, iMouse);\n\n   Q=vec4(pos,vel);\n\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 Q, in vec2 U )\n{\n    if(U.x>float(N.x) || U.y>float(N.y)) return;\n     \n    setup( U, ch,  iResolution);\n    if (iFrame==0 ) init(iResolution); \n    else update(ch, iResolution, iMouse);\n\n   Q=vec4(pos,vel);\n\n}","name":"Buffer D","description":"","type":"buffer"}]}