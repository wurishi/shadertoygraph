{"ver":"0.1","info":{"id":"Dt3BW7","date":"1701276791","viewed":51,"name":"starlight  in space","username":"nayk","description":"copy past","likes":1,"published":1,"flags":1,"usePreview":0,"tags":["light","stars","cosmos","universe"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* original https://www.shadertoy.com/view/lsyXDK https://www.shadertoy.com/view/lslyRn*/\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000\n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n\n#define DITHERING\n#define BACKGROUND\n\n\n\n#define DITHERING\n#define BACKGROUND\n\n//#define TONEMAPPING\n\n//-------------------\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n// iq's noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\nf = f*f*(3.0-2.0*f);\nvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\nvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\nreturn 1. - 0.82*mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm( vec3 p )\n{\n   return noise(p*.06125)*.5 + noise(p*.125)*.25 + noise(p*.25)*.125 + noise(p*.4)*.2;\n}\n\nfloat Sphere( vec3 p, float r )\n{\n    return length(p)-r;\n}\n\n//==============================================================\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n//--------------------------------------------------------------\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 4.; // size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge); // pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n    float n = 1.-mod(iTime * 0.1,-1.); // noise amount\n    float iter = 2.0;\n    for (int i = 0; i < 8; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter; // abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n\nfloat VolumetricExplosion(vec3 p)\n{\n    float final = Sphere(p,4.);\n    final += noise(p*20.)*.4;\n    final += SpiralNoiseC(p.zxy*fbm(p*10.))*2.5; //1.25;\n\n    return final;\n}\n\nfloat map(vec3 p)\n{\nR(p.xz, iMouse.x*0.008*pi+iTime*0.1);\n\nfloat VolExplosion = VolumetricExplosion(p/(1.+mod(iTime * 0.1,-1.)))*(1.+mod(iTime * 0.1,-1.)); // scale\n   \nreturn abs(VolExplosion)+0.07;\n}\n//--------------------------------------------------------------\n\n// assign color to the media\nvec3 computeColor( float density, float radius )\n{\n// color based on density alone, gives impression of occlusion within\n// the media\nvec3 result = mix( vec3(1.0,0.9,0.8), vec3(0.4,0.15,0.1), density );\n\n// color added to the media\nvec3 colCenter = 7.*vec3(0.8,1.0,1.0);\nvec3 colEdge = 1.5*vec3(0.48,0.53,0.5);\nresult *= mix( colCenter, colEdge, min( (radius+.05)/.9, 1.15 ) );\n\nreturn result;\n}\n\nbool RaySphereIntersect(vec3 org, vec3 dir, out float near, out float far)\n{\nfloat b = dot(dir, org);\nfloat c = dot(org, org) - 8.;\nfloat delta = b*b - c;\nif( delta < 0.0)\nreturn false;\nfloat deltasqrt = sqrt(delta);\nnear = -b - deltasqrt;\nfar = -b + deltasqrt;\nreturn far > 0.0;\n}\n\n// Applies the filmic curve from John Hable's presentation\n// More details at : http://filmicgames.com/archives/75\nvec3 ToneMapFilmicALU(vec3 _color)\n{\n_color = max(vec3(0), _color - vec3(0.004));\n_color = (_color * (6.2*_color + vec3(0.5))) / (_color * (6.2 * _color + vec3(1.7)) + vec3(0.06));\nreturn pow(_color, vec3(2.2));\n}\n\nfloat cheap_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n//get coords and direction\nvec3 dir=rd;\nvec3 from=ro;\n\n//volumetric rendering\nfloat s=0.1,fade=1.;\nvec3 v=vec3(0.);\nfor (int r=0; r<volsteps; r++) {\nvec3 p=from+s*dir*.5;\np = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\nfloat pa,a=pa=0.;\nfor (int i=0; i<iterations; i++) {\np=abs(p)/dot(p,p)-formuparam;\n            p.xy*=mat2(cos(iTime*0.02),sin(iTime*0.02),-sin(iTime*0.02),cos(iTime*0.02));// the magic formula\na+=abs(length(p)-pa); // absolute sum of average change\npa=length(p);\n}\n\na*=a*a; // add contrast\nif (r>6) fade*=1.1; // dark matter, don't render near\n//v+=vec3(dm,dm*.5,0.);\nv+=fade;\nv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\nfade*=distfading; // distance fading\ns+=stepsize;\n}\nv=mix(vec3(length(v)),v,saturation); //color adjust\nfragColor = vec4(v*.03,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//get coords and direction\nvec2 uv=fragCoord.xy/iResolution.xy-.5;\nuv.y*=iResolution.y/iResolution.x;\nvec3 dir=vec3(uv*zoom,iTime*0.001);\n   float anim = sin(iTime * 12.0) * 0.1 + 1.0;  \nfloat time=iTime*speed+.25;\n\n   const float KEY_1 = 49.5/256.0;\nconst float KEY_2 = 50.5/256.0;\nconst float KEY_3 = 51.5/256.0;\n    float key = 0.0;\n \n   \n// ro: ray origin\n// rd: direction of the ray\nvec3 rd = normalize(vec3((fragCoord.xy-0.5*iResolution.xy)/iResolution.y, 1.));\nvec3 ro = vec3(0., 0., -6.+key*1.6);\n   \n// ld, td: local, total density\n// w: weighting factor\nfloat ld=0., td=0., w=0.;\n  float t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + 0.57)) * 2.2;\nfloat si = sin(t);\nfloat co = cos(t);\nmat2 ma = mat2(co, si, -si, co);\n   \n     ro.xy*=ma;\n      dir.xy*=ma;\n// t: length of the ray\n// d: distance function\nfloat d=1., t2=0.;\n   \n    const float h = 0.1;\n   \nvec4 sum = vec4(0.0);\n   \n    float min_dist=0.0, max_dist=0.0;\n\n    if(RaySphereIntersect(ro, rd, min_dist, max_dist))\n    {\n       \nt2 = min_dist*step(t2,min_dist);\n   \n// raymarch loop\n    for (int i=0; i<86; i++)\n{\n\nvec3 pos = ro + t2*rd;\n \n// Loop break conditions.\n   if(td>0.9 || d<0.11*t2 || t2>10. || sum.a > 0.99 || t2>max_dist) break;\n       \n        // evaluate distance function\n        float d = map(pos);\n       \n        // point light calculations\n        vec3 ldst = vec3(0.0)-pos;\n        float lDist = max(length(ldst), 0.001);\n\n        // the color of light\n        vec3 lightColor=vec3(0.55,0.5,0.55);\n       \n        sum.rgb+=(vec3(0.17,0.15,1.00)/(lDist*lDist*15.)/100.); // star itself\n        sum.rgb+=(lightColor/exp(lDist*lDist*lDist*.08)/30.); // bloom\n       \nif (d<h)\n{\n// compute local density\nld = h - d;\n           \n            // compute weighting factor\nw = (1. - td) * ld;\n     \n// accumulate density\ntd += w + 1./200.;\n\nvec4 col = vec4( computeColor(td,lDist), td );\n           \n            // emission\n            sum += sum.a * vec4(sum.rgb, 0.0) * 0.2 / lDist;\n           \n// uniform scale density\ncol.a *= 0.2;\n// colour by alpha\ncol.rgb *= col.a;\n// alpha blend in contribution\nsum = sum + col*(1.0 - sum.a);  \n       \n}\n     \ntd += 1./70.;\n\n        #ifdef DITHERING\n       \n        vec2 uvd = uv;\n        uvd.y*=120.;\n        uvd.x*=280.;\n        d=abs(d)*(.8+0.08*texture(iChannel2,vec2(uvd.y,-uvd.x+0.5*sin(4.*iTime+uvd.y*4.0))).r);\n        #endif\n\n        // trying to optimize step size\n        t2 += max(d * 0.1 * max(min(length(ldst),length(ro)),0.1), 0.01);\n\n}\n   \n    // simple scattering\n    sum *= 1. / exp( ld * 0.2 ) * 0.8;\n       \n    sum = clamp( sum, 0.0, 1.0 );\n   \n    sum.xyz = sum.xyz*sum.xyz*(3.0-2.0*sum.xyz);\n   \n}\n   \n    #ifdef BACKGROUND\n    // stars background\n    if (td<.8)\n    {\n        vec3 stars = vec3(noise(rd*500.0)*0.5+0.5);\n        vec3 starbg = vec3(0.0);\n       \n        sum.xyz += starbg;\n    }\n#endif\n   \n    #ifdef TONEMAPPING\n    fragColor = vec4(ToneMapFilmicALU(sum.xyz),1.0);\n#else\n    fragColor = vec4(sum.xyz,1.0);\n#endif\n \nvec3 from=vec3(1.,.5,0.5);\nfrom+=vec3(time*2.,time,-2.);\nfrom.z+=fract(iTime*.11);\n\nmainVR(fragColor, fragCoord, from, dir);\n       fragColor*= vec4(cheap_star(uv,anim) * vec3(0.55,0.5,0.55)*0.15, 1.0);\n       fragColor+= vec4(sum.xyz,1.0);\n         \n}\n\n","name":"Image","description":"","type":"image"}]}