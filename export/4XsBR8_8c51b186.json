{"ver":"0.1","info":{"id":"4XsBR8","date":"1728016667","viewed":16,"name":"Trippy Orbit","username":"CalebS","description":"Two circles orbiting the center of a gradient pulse effect.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["cool"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SPEED 1.0\n#define DISTORTION_STRENGTH 0.2\nconst vec3 COLOR1 = vec3(0.2, 0.3, 0.8);\nconst vec3 COLOR2 = vec3(0.8, 0.3, 0.2);\n\nconst float ORBIT_RADIUS = 0.75;\nconst float ORBIT_SPEED = 0.75;\nconst float INNER_ORBIT_RADIUS = 0.125;\nconst float INNER_ORBIT_SPEED = 2.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalizes the UV coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n\n    // Correct aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Calculate distance from the center\n    float dist = length(uv);\n\n    // Time used for pulsing\n    float time = iTime * SPEED;\n    \n    // Distorts the UV coordinates\n    float distortion = sin(dist * time) * DISTORTION_STRENGTH;\n    vec2 distortedUV = uv + distortion * normalize(uv);\n\n    // Creates a radial gradient\n    float gradient = smoothstep(0.0, 1.0, dist);\n    \n    // Mixes two colors\n    vec3 color = mix(COLOR1, COLOR2, gradient);\n\n    // Adds a pulsing effect\n    color *= 0.8 + 10.0 * sin(10.0 * dist - time);\n    \n    // Positions the center circle\n    vec2 centerCirc = vec2(0.0, 0.0);\n    \n    // Calculates position for third circle\n    vec2 outerOrbitPos = vec2(cos(time * ORBIT_SPEED) * ORBIT_RADIUS, sin(time * ORBIT_SPEED) * ORBIT_RADIUS);\n    \n    // Calculates position for second circle\n    vec2 innerOrbitPos = outerOrbitPos + vec2(cos(-time * INNER_ORBIT_SPEED) * INNER_ORBIT_RADIUS, sin(-time * INNER_ORBIT_SPEED) * INNER_ORBIT_RADIUS);\n    \n    // Determines distance\n    float outerDist = length(uv - outerOrbitPos);\n    float innerDist = length(uv - innerOrbitPos);\n    \n    // Checks if the fragment is within the radius\n    if (outerDist < 0.05)\n    {\n        color = vec3(1.0, 0.0, 0.0);\n    }\n    \n    // Checks if the fragment is within the radius\n    if (innerDist < 0.03)\n    {\n        color = vec3(0.0, 1.0, 0.0);\n    }\n\n    // Outputs the final color\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}