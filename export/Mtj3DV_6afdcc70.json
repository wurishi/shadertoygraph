{"ver":"0.1","info":{"id":"Mtj3DV","date":"1434666173","viewed":1140,"name":"space egg","username":"mattz","description":"what will happen when it hatches?","likes":33,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","space","stars","spherical","glowy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"/* space egg, by mattz\n   License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n   Found a couple of nice uses for spherical voronoi textures in 2D & 3D. \n   See https://www.shadertoy.com/view/MtBGRD for technical details.\n\n   Note the code below is not as nice or pretty as the linked shader MtBGRD.\n   Please consider that one the \"reference implementation\".\n\n */\n\n\n/* Magic angle that equalizes projected area of squares on sphere. */\n#define MAGIC_ANGLE 0.868734829276 // radians\n\nconst float warp_theta = MAGIC_ANGLE;\nfloat tan_warp_theta = tan(warp_theta);\n\n/* Bunch o' globals. */\nconst float farval = 1e5;\nconst vec3 tgt = vec3(0);\nconst vec3 cpos = vec3(0,0,4.0);\nconst int rayiter = 60;\nconst float dmax = 20.0;\nvec3 L = normalize(vec3(-0.7, 1.0, 0.5));\nmat3 Rview;\nconst float nbumps = 6.0;\nconst float bump_pow = 2.0;\nconst float bump_scale = 18.0;\n\n\n/* Return a permutation matrix whose first two columns are u and v basis \n   vectors for a cube face, and whose third column indicates which axis \n   (x,y,z) is maximal. */\nmat3 getPT(in vec3 p) {\n\n    vec3 a = abs(p);\n    float c = max(max(a.x, a.y), a.z);    \n    vec3 s = c == a.x ? vec3(1.,0,0) : c == a.y ? vec3(0,1.,0) : vec3(0,0,1.);\n    s *= sign(dot(p, s));\n    vec3 q = s.yzx;\n    return mat3(cross(q,s), q, s);\n\n}\n\n/* For any point in 3D, obtain the permutation matrix, as well as grid coordinates\n   on a cube face. */\nvoid posToGrid(in float N, in vec3 pos, out mat3 PT, out vec2 g) {\n    \n    // Get permutation matrix and cube face id\n    PT = getPT(pos);\n    \n    // Project to cube face\n    vec3 c = pos * PT;     \n    vec2 p = c.xy / c.z;      \n    \n    // Unwarp through arctan function\n    vec2 q = atan(p*tan_warp_theta)/warp_theta; \n    \n    // Map [-1,1] interval to [0,N] interval\n    g = (q*0.5 + 0.5)*N;\n    \n}\n\n\n/* For any grid point on a cube face, along with projection matrix, \n   obtain the 3D point it represents. */\nvec3 gridToPos(in float N, in mat3 PT, in vec2 g) {\n    \n    // Map [0,N] to [-1,1]\n    vec2 q = g/N * 2.0 - 1.0;\n    \n    // Warp through tangent function\n    vec2 p = tan(warp_theta*q)/tan_warp_theta;\n\n    // Map back through permutation matrix to place in 3D.\n    return PT * vec3(p, 1.0);\n    \n}\n\n\n/* Return whether a neighbor can be identified for a particular grid cell.\n   We do not allow moves that wrap more than one face. For example, the \n   bottom-left corner (0,0) on the +X face may get stepped by (-1,0) to \n   end up on the -Y face, or, stepped by (0,-1) to end up on the -Z face, \n   but we do not allow the motion (-1,-1) from that spot. If a neighbor is \n   found, the permutation/projection matrix and grid coordinates of the \n   neighbor are computed.\n*/\nbool gridNeighbor(in float N, in mat3 PT, in vec2 g, in vec2 delta, out mat3 PTn, out vec2 gn) {\n\n    vec2 g_dst = g.xy + delta;\n    vec2 g_dst_clamp = clamp(g_dst, 0.0, N);\n\n    vec2 extra = abs(g_dst_clamp - g_dst);\n    float esum = extra.x + extra.y;\n \n    if (max(extra.x, extra.y) == 0.0) {\n        PTn = PT;\n        gn = g_dst;\n        return true;\n    } else if (min(extra.x, extra.y) == 0.0 && esum < N) {\n        vec3 pos = PT * vec3(g_dst_clamp/N*2.0-1.0, 1.0 - 2.0*esum/N);\n        PTn = getPT(pos);\n        gn = ((pos * PTn).xy*0.5 + 0.5) * N;\n        return true;\t        \n    } else {\n        return false;\n    }\n    \n\n}\n\n\n/* Return squared great circle distance of two points projected onto sphere. */\nfloat sphereDist2(vec3 a, vec3 b) {\n\t// Fast-ish approximation for acos(dot(normalize(a), normalize(b)))^2\n    return 2.0-2.0*dot((a),(b));\n}\n\n\n/* From https://www.shadertoy.com/view/Xd23Dh */\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n                  dot(p,vec2(269.5,183.3)), \n                  dot(p,vec2(419.2,371.9)) );\n    return fract(sin(q)*43758.5453);\n}\n\n/* Magic bits. */\nvoid voronoi(in vec3 pos, in float N,\n             out vec4 pd1, out vec4 pd2) {\n\n    mat3 PT;\n    vec2 g;\n\n    // Get grid coords\n    posToGrid(N, pos, PT, g);   \n    \n    pd1 = vec4(farval);\n    pd2 = vec4(farval);\n\n    // Move to center of grid cell for neighbor calculation below.\n    g = floor(g) + 0.5;\n    \n    // For each potential neighbor\n    for (float u=-1.0; u<=1.0; ++u) {\n        for (float v=-1.0; v<=1.0; ++v) {\n            \n            vec2 gn;\n            mat3 PTn;\n\n            // If neighbor exists\n            if (gridNeighbor(N, PT, g, vec2(u,v), PTn, gn)) {\n                \n                float face = dot(PTn[2], vec3(1.,2.,3.));\n                \n                // Perturb based on grid cell ID\n                gn = floor(gn);\n                vec3 rn = hash3(gn*0.123 + face);\n                gn += 0.5 + (rn.xy * 2.0 - 1.0)*0.5;\n\n                // Get the 3D position\n                vec3 pos_n = normalize(gridToPos(N, PTn, gn));                \n                \n                vec4 pd = vec4(pos_n, sphereDist2(pos, pos_n));\n                                                            \n                // See if new closest point (or second closest)\n                if (pd.w < pd1.w) {\n                    pd2 = pd1;\n                    pd1 = pd;\n                } else if (pd.w < pd2.w) {\n                    pd2 = pd;\n                }\n                \n            }\n        }\n    }       \n\n}\n\n\n/* Rotate about x-axis */\nmat3 rotX(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0, 0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\n\n/* Rotate about y-axis */\nmat3 rotY(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n\n}\n\n/* Distance to egg */\nfloat map(in vec3 pos) {\t\n\n    float d = length(pos)-1.0;\n    \n    vec4 pd1, pd2;    \n\n    if (abs(d) < 0.5) {\n        pos = normalize(pos);\n        voronoi(pos, nbumps, pd1, pd2);        \n        pd1.w = pow(pd1.w, bump_pow);  \n        pd2.w = pow(pd2.w, bump_pow);\n        d += bump_scale * (pd1.w - pd2.w);\n    }\n    \n    return d;\n\n}\n\n\n/* IQ's normal calculation. */\nvec3 calcNormal( in vec3 pos ) {\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy) - map(pos-eps.xyy),\n        map(pos+eps.yxy) - map(pos-eps.yxy),\n        map(pos+eps.yyx) - map(pos-eps.yyx) );\n    return normalize(nor);\n}\n\n\n/* IQ's distance marcher, more or less. */\nfloat castRay( in vec3 ro, in vec3 rd, in float maxd ) {\n\n    const float precis = 0.002;   \n    float h=2.0*precis;\n\n    float t = 0.0;\n\n    for( int i=0; i<rayiter; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) continue;//break;\n        t += h;\n        h = map( ro+rd*t );\n       \n    }    \n    \n    return t > maxd ? -1.0 : t;\n\n}\n\n\nvec3 fakeBlackBody(float t) {\n    \n    return (t < 0.3 ?\n            mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 0.0), t/0.3) :\n            t < 0.7 ?\n            mix(vec3(1.0, 1.0, 0.0), vec3(1.0), (t-0.3)/0.4) :\n            mix(vec3(1.0), vec3(0.5, 0.5, 1.0), (t-0.7)/0.3));\n    \n}\n\nvec3 star(vec3 pos, vec4 pd, float scl) {\n    \n    vec3 rn = hash3(pd.xy+pd.z);\n    vec3 k = 0.3*fakeBlackBody(rn.z) + 0.7;\n                \n    float s = exp(-sqrt(scl*pd.w/0.000004));\n                \n    return k*s*2.0*pow(rn.x,5.0);\n\n}\n\nvec3 stars(in vec3 rd, in float scl) {\n    vec4 pd1, pd2;\n    rd = normalize(rd);\n    voronoi(rd, 50.0, pd1, pd2);    \n    return star(rd, pd1, scl) + star(rd, pd2, scl);\n}\n    \nfloat bisectorDistance(vec3 p, vec3 a, vec3 b) {\n    vec3 n1 = cross(a,b);\n    vec3 n2 = normalize(cross(n1, 0.5*((a)+(b))));\n    return abs(dot(p, n2));             \n}\n\nvec3 shade( in vec3 ro, in vec3 rd ){\n\n    float t = castRay(ro, rd, dmax);        \n\n    vec3 c;\n    vec4 pd1, pd2;\n\n\n    if (t < 0.0) {\n\n        c = stars(rd, 1.5);\n\n    } else {        \n\n        vec3 pos = ro + t*rd;\n        vec3 n = calcNormal(pos);\n        \n        pos = normalize(pos);\n        \n        vec4 pd1, pd2;\n        voronoi(pos, nbumps, pd1, pd2);    \n        float d = bisectorDistance(pos, pd1.xyz, pd2.xyz);\n        \n        vec3 color = vec3(0.25, 0.23, 0.28);        \n       \n        vec3 diffamb = (0.9*clamp(dot(n,L), 0.0, 1.0)+0.1) * color;\n        vec3 R = 2.0*n*dot(n,L)-L;\n        float spec = 0.5*pow(clamp(-dot(R, rd), 0.0, 1.0), 20.0);\n        c = diffamb + spec*vec3(1.0, 0.8, 0.9);\n        \n\t\tc += 0.15*stars(reflect(rd, n), 0.5);\n        \n        vec3 k1 = rotX(iTime*0.7) * (rotY(iTime*0.3)*vec3(0, 0, 1.0));\n        vec3 k2 = rotX(iTime*1.3) * (rotY(iTime*0.9)*vec3(0, 0, 1.0));\n        \n        float p = abs(dot(pos, k1)) * (1.0 -abs(dot(pos, k2)));\n        p = 0.5 * p + 0.5;\n        p *= 0.8 + 0.2*sin(iTime);\n\n        c += exp(-pow(d,0.5)/0.12)*vec3(0.8, 0.4, 0.45)*p;\n\n    }\n\n    return c;\n\n    \n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = (fragCoord.xy - .5*iResolution.xy) * 0.8 / (iResolution.y);\n\n    vec3 rz = normalize(tgt - cpos),\n        rx = normalize(cross(rz,vec3(0,1.,0))),\n        ry = cross(rx,rz);\n\n    float t = iTime;\n         \n    float thetay = -t * 0.15;\n    float thetax = t * 0.05;        \n\n    if (max(iMouse.x, iMouse.y) > 20.0) { \n        thetax = (iMouse.y - .5*iResolution.y) * 5.0/iResolution.y; \n        thetay = (iMouse.x - .5*iResolution.x) * -10.0/iResolution.x; \n    }\n\n    Rview = mat3(rx,ry,rz)*rotX(thetax)*rotY(thetay);        \n  \n    vec3 rd = Rview*normalize(vec3(uv, 1.)),\n        ro = tgt + Rview*vec3(0,0,-length(cpos-tgt));\n\n    fragColor.xyz = shade(ro, rd);\n\n\n}\n","name":"Image","description":"","type":"image"}]}