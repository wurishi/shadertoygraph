{"ver":"0.1","info":{"id":"DdVfRG","date":"1698335149","viewed":35,"name":"stone pawn","username":"Efim","description":"https://iquilezles.org/articles/distfunctions/","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["chess","pawn","distfunctions"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define TAU 6.283185\n\nconst float dist_infin = 4.0;\n#define nn 256\nconst float eps = 0.001;\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n//https://iquilezles.org/articles/distfunctions/\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xy), p.z );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xy)-2.0*ra+rb, abs(p.z) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n//https://iquilezles.org/articles/smin/\n// polynomial smooth min 1 (k=0.1)\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat aafi(vec2 p) {\n    float fi = atan(p.y, p.x);\n    fi += step(p.y, 0.0)*TAU;\n    return fi;\n}\n\n\nfloat map( in vec3 pos )\n{\n    vec3 pos1 = pos - vec3(0., 0., 0.3);\n    float d1 = sdSphere(pos1 - vec3(0., 0., -.85), 0.2);\n    float d2 = sdEllipsoid(pos1 - vec3(0., 0.0, -0.65), vec3(0.3, 0.3, 0.05));\n    d1 = smin(d1, d2, 0.02);\n    d2 = sdCappedCone(pos1-vec3(0.0, 0.0, -0.4), 0.2, 0.15, 0.22);\n    d1 = smin(d1, d2, 0.04);\n    d2 = sdRoundedCylinder(pos1 - vec3(0.0, 0.0, 0.0), 0.17, 0.05, 0.15);\n    d1 = smin(d1, d2, 0.02);\n    d2 = sdEllipsoid(pos1 - vec3(0., 0.0, 0.), vec3(0.5, 0.5, 0.2));\n    d1 = smin(d1, d2, 0.05);\n    d2 = sdRoundedCylinder(pos1 - vec3(0.0, 0.0, 0.17), 0.25, 0.01, 0.02);\n    d1 = smin(d1, d2, 0.02);\n    \n    \n    float yy = aafi(vec2(pos.x, pos.y)) /TAU;\n    float xx = fract(pos.z);\n    vec3 tx = texture(iChannel0, vec2(xx, yy)).rgb;\n    \n    float dd = 0.02*dot(tx, vec3(0.06, 0.08, .9));\n    return d1 + dd;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    const float h = 0.0001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map(pos + k.xyy*h ) + \n                      k.yyx*map(pos + k.yyx*h ) + \n                      k.yxy*map(pos + k.yxy*h ) + \n                      k.xxx*map(pos + k.xxx*h ) );\n}\n\nstruct HIT\n{\n    float dist;\n    vec3 nor;\n    vec3 pos;\n};\nconst HIT hit_inf = HIT(dist_infin, vec3(0.0), vec3(0.0));\n\nHIT giper3D(vec3 ro, vec3 rd)\n{\n    float t  = 0.;\n    for (int i = 0; i < nn; i++)\n    {\n        vec3 pos = ro + rd*t;\n        float h = map(pos);\n        if (h < eps || t >= dist_infin)\n            break;\n        t += h;  \n    }    \n\n    if (t >= dist_infin)\n        return hit_inf;\n      \n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal(pos);\n    return HIT(t, nor, pos);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\n\nmat3 rotateX(float f)\n{\n    return mat3(\n    vec3(1.0,    0.0,      0.0),\n    vec3(0.0,\t cos(f),  -sin(f)), \t\n\tvec3(.0, sin(f), cos(f))\n    );\n}\n\n\nmat3 rotateZ(float f)\n{\n    return mat3(\n    vec3(cos(f),    -sin(f),  0.0),\n    vec3(sin(f),\t cos(f),  0.0), \t\n\tvec3(0.0, 0.0, 1.0)\n    );\n    \n}\n\n\nmat3 rotateY(float f)\n{\n    return mat3(\n    vec3(cos(f), 0.0,  sin(f)),\n    vec3(0.0,\t 1.0,  0.0), \t\n\tvec3(-sin(f), 0.0, cos(f))\n    );\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 light = normalize(vec3(0.0, 1.0, 1.0)); //light\n    vec3 light2 = normalize(vec3(0.0, 1.0, -1.0)); //light\n    float t = iTime;\n    vec2 m = vec2(0.0, 0.0);\n    if  (iMouse.z > 0.0)\n    {\n        m = (-iResolution.xy + 2.0*(iMouse.xy))/iResolution.y;\n        t = 0.;\n    }\n    vec3 ro = vec3(0.0, 0.0, 1.8); // camera\n    ro = rotateY(-m.x*TAU)*rotateX(-m.y*PI)*ro; //camera rotation\n    \n    \n    const float fl = 1.5; // focal length\n    float dist = dist_infin;\n    mat3 rota  = rotateX(PI/2.0)*rotateZ(t)*rotateX(-t);\n    mat3 rota_1  = rotateX(t)*rotateZ(-t)*rotateX(-PI/2.0);\n    \n    vec3 tot = vec3(0.0);\n    \n    \n    //antiblick\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        vec3 rd = GetRayDir(p, ro, vec3(0,0.,0), fl); //ray direction\n        vec3 col = vec3(0.5, 0.5, 0.7);\n        \n        HIT giper = giper3D(rota*ro, rota*rd);\n        if (giper.dist < dist)\n        {\n            vec3 nor = rota_1*giper.nor;\n            float dif = clamp( dot(nor,light), 0.2, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,light2);\n            float yy = aafi(vec2(giper.pos.x, giper.pos.y)) /TAU;\n            float xx = fract(giper.pos.z);\n            vec3 tx = texture(iChannel0, vec2(xx, yy)).rgb;\n            \n            col = tx*amb + tx*dif;\n        }\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    }\n    //antiblick\n    tot /= float(AA*AA);\n    fragColor = vec4(tot,1.0);\n}","name":"Image","description":"","type":"image"}]}