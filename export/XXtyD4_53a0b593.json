{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":3,"type":"buffer","id":"XdfGR8","filepath":"/media/previz/buffer03.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec4 info = texture(iChannel0, uv);\n    vec4 blur = texture(iChannel3, uv);\n    \n    float circle = info.x;\n    float light = info.y;\n    float exists = info.z;\n    \n    float hue = gradientHue(circle);\n    float totalLight = blur.x + blur.y;\n     \n    vec3 rgb1 = HSLToRGB(vec3(hue, 0.2, exists * 0.1));\n    vec3 rgb2 = HSLToRGB(vec3(hue, 0.2, totalLight));\n    vec3 rgb3 = HSLToRGB(vec3(hue, 0.2, light * 0.5));\n    \n    fragColor = vec4(rgb1 + rgb2 + rgb3, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"#define N 25.0\n#define MIN_L 0.005\n#define MAX_L 0.9\n#define WIDTH 0.90\n#define PI 3.14159265359\n\n#define TOTAL_TIME 30.0\n#define TOTAL_ROTATES 30.0\n\nfloat getAngleDif(float angle, float ANGLE) {\n    float a = angle / 2.0 / PI;\n    float A = ANGLE / 2.0 / PI;\n    return fract(A - a) * 2.0 * PI;\n}\n\nfloat HueToRGB(float f1, float f2, float hue) {\n\tif (hue < 0.0)\n\t\thue += 1.0;\n\telse if (hue > 1.0)\n\t\thue -= 1.0;\n\tfloat res;\n\tif ((6.0 * hue) < 1.0)\n\t\tres = f1 + (f2 - f1) * 6.0 * hue;\n\telse if ((2.0 * hue) < 1.0)\n\t\tres = f2;\n\telse if ((3.0 * hue) < 2.0)\n\t\tres = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n\telse\n\t\tres = f1;\n\treturn res;\n}\n\nvec3 HSLToRGB(vec3 hsl) {\n\tvec3 rgb;\n\t\n\tif (hsl.y == 0.0)\n\t\trgb = vec3(hsl.z);\n\telse\n\t{\n\t\tfloat f2;\n\t\t\n\t\tif (hsl.z < 0.5)\n\t\t\tf2 = hsl.z * (1.0 + hsl.y);\n\t\telse\n\t\t\tf2 = (hsl.z + hsl.y) - (hsl.y * hsl.z);\n\t\t\t\n\t\tfloat f1 = 2.0 * hsl.z - f2;\n\t\t\n\t\trgb.r = HueToRGB(f1, f2, hsl.x + (1.0/3.0));\n\t\trgb.g = HueToRGB(f1, f2, hsl.x);\n\t\trgb.b = HueToRGB(f1, f2, hsl.x - (1.0/3.0));\n\t}\t\n\treturn rgb;\n}\n\nfloat gradientHue(float x) {\n    float A = 30.0 / 360.0;\n    float B = 260.0 / 360.0;\n    return A + (B - A) * x;\n}\n\nfloat gaussian(float x, float sigma) {\n    return exp(-0.5 * (x * x) / (sigma * sigma)) / (sigma * sqrt(6.28318530718));\n}\n","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[],"code":"vec4 getColor(vec2 uv) {\n    float l = length(uv);\n    float d = (l - MIN_L) / (MAX_L - MIN_L);\n    \n    float y = fract(d * N);\n    float i = floor(d * N) + 1.0;\n    \n    y = y / WIDTH;\n    if (d <= 0.0 || d >= 1.0 || y >= 1.0) {\n        return vec4(i / N, 0.0, 0.0, 1.0);\n    }\n    \n    float angle = atan(-uv.x, -uv.y) + PI;\n    \n    float ANGLE = (TOTAL_ROTATES - i + N) * (iTime / TOTAL_TIME) * 2.0 * PI;\n    \n    float dif = getAngleDif(angle, ANGLE);\n    \n    float LIGHT = smoothstep(3.0, 0.0, dif);\n    if (dif < 0.0) {\n        LIGHT = 0.0;\n    }\n    \n    LIGHT = pow(LIGHT, 3.0);\n    \n    return vec4(i / N, LIGHT, 1.0, 0.0);\n}\n\nvec4 getColor2(vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = uv - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 2.0;\n    \n    return getColor(uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 color = vec4(0.0);\n\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            vec2 fragCoord2 = fragCoord + vec2(i, j) * 0.3333;\n            color += getColor2(fragCoord2);\n        }\n    }\n    \n    fragColor = color / 9.0;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"4sXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define STEPSIZE (1.0 / 800.0)\n#define STEP vec2(0.0, STEPSIZE)\n\nfloat blur(vec2 uv, int x, float sigma, vec4 coef) { \n    float totalLight = 0.0;\n    float totalWeight = 0.0;\n\n    for (int i = -x; i <= x; i++) {\n        float weight = gaussian(float(i) * STEPSIZE, sigma);\n        vec4 tex = texture(iChannel0, uv + STEP * float(i));\n        \n        float light = dot(tex, coef);\n        \n        totalLight += light * weight;\n        totalWeight += weight;\n      \n    }\n    \n    return totalLight / totalWeight;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n\n    fragColor = vec4(\n        blur(uv, 48, 0.03, vec4(0.0, 1.0, 0.0, 0.0)),\n        blur(uv, 4, 0.005, vec4(0.0, 1.0, 0.0, 0.0)),\n        0.0, \n        0.0\n    );\n}\n","name":"Buffer C","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XdfGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define STEPSIZE (1.0 / 800.0)\n#define STEP vec2(STEPSIZE, 0.0)\n\nfloat blur(vec2 uv, int x, float sigma, vec4 coef) { \n    float totalLight = 0.0;\n    float totalWeight = 0.0;\n\n    for (int i = -x; i <= x; i++) {\n        float weight = gaussian(float(i) * STEPSIZE, sigma);\n        vec4 tex = texture(iChannel0, uv + STEP * float(i));\n        \n        float light = dot(tex, coef);\n        \n        totalLight += light * weight;\n        totalWeight += weight;\n      \n    }\n    \n    return totalLight / totalWeight;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n\n    fragColor = vec4(\n        blur(uv, 48, 0.03, vec4(1.0, 0.0, 0.0, 0.0)),\n        blur(uv, 4, 0.005, vec4(0.0, 1.0, 0.0, 0.0)),\n        0.0, \n        0.0\n    );\n}\n","name":"Buffer D","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"XXtyD4","date":"1735088258","viewed":110,"name":"Polyrhythms Visualized ","username":"Yarodash","description":"attempt to recreate\nhttps://www.youtube.com/watch?v=lsAlFKXAMjM","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["polyrhythms"],"hasliked":0,"parentid":"","parentname":""}}