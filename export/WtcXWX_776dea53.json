{"ver":"0.1","info":{"id":"WtcXWX","date":"1581785555","viewed":341,"name":"Grid glow experiment","username":"rodgzilla","description":"glow on grid experiment","likes":4,"published":3,"flags":0,"usePreview":0,"tags":["raymarching","glow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time .7 * iTime\n#define ZPOS -10.\n\nfloat PI = acos(-1.);\n\nfloat wave(float tempo) {\n    return .5 * sin(time * tempo) + .5;\n}\n\nmat2 rot2d(float a) {\n    float c = cos(a), s = sin(a);\n    \n    return mat2(c, s, -s, c); \n}\n\nvec3 kifs(vec3 p) {\n    float s = 1.;\n//    float t = floor(time) + smoothstep(.0, 1., fract(time));\n  \tfloat t = time * .3;\n    for (float i = 0.; i < 1.; i++) {\n        p.xy *= rot2d(t);\n        p.yz *= rot2d(.9 * t + i * .7);\n        p = abs(p);\n        p -= s;\n//        s *= .6 + .2 * sin(time / 1.5);\n        s *= .7;\n    }\n    \n    return p;\n}\n\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat tube(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot(ab, ab);\n//    t = clamp(t, 0., 1.);\n    vec3 c = a + ab * t;\n    \n    return length(p - c) - r;\n}\n\nvec3 rep(vec3 p, vec3 r) {\n    vec3 q = mod(p, r) - .5 * r;\n    \n    return q;\n}\n\nfloat at = 0.;\nfloat map(vec3 p) {\n//    p.xy *= rot2d(cos(time) * sin(p.z / 3.));\n    vec3 rawP = p;\n//    p = kifs(p);\n    p = rep(p, vec3(1. + wave(.65), 2. + wave(.6), 1.5 + wave(.7)));\n    \n    float d = 5000.;\n\n//    d = min(d, sphere(p, 1.));\n    d = min(d, tube(p, vec3(0, -2, 0), vec3(0, 2, 0), .1));\n    d = min(d, tube(p, vec3(-2, 0, 0), vec3(2, 0, 0), .1));\n    d = min(d, tube(p, vec3(0, 0, 2), vec3(0, 0, -2), .1));\n//    d = max(d, -sphere(rawP, 10.));\n    \n    at += .05 / (.1 + 5. * d);\n    \n    return d;\n}\n\nvec3 glow = vec3(0);\nfloat rm(vec3 ro, vec3 rd) {\n    float d = 0.;\n    \n    for (int i = 0; i < 300; i++) {\n        vec3 p = ro + d * rd;\n        float ds = map(p);\n        \n        if (ds < 0.01 || ds > 100.) {\n            break;\n        }\n        \n        d += ds * .5;\n//        glow += .015 * at * vec3(.8, .5 * sin(time / 1.) + .5, .5 * cos(time / 5.) + .5);\n        glow += .001 * at * vec3(.8, wave(.5) * cos(.1 * p.z), 0);\n    }\n    \n    return d;\n}\n\nvec3 normal(vec3 p){\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 n = normalize(map(p) - vec3(\n        map(p - e.xyy),\n        map(p - e.yxy),\n        map(p - e.yyx)\n    ));\n  \n   return n;                 \n}\n\nfloat light(vec3 p) {\n    vec3 lp = vec3(0, 0, ZPOS);\n    vec3 tl = lp - p;\n    vec3 tln = normalize(tl);\n    vec3 n = normal(p);\n    float dif = dot(n, tln);\n    float d = rm(p + .01 * n, tln);\n    \n    if (d < length(tl)) {\n        dif *= .1;\n    }\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec3 ro = vec3(0, 0, ZPOS);\n    vec3 rd = normalize(vec3(uv, 1.));\n    float d = rm(ro, rd);\n\tvec3 p = ro + d * rd;\n    float dif = light(p);\n    \n    vec3 col = dif * glow;\n//    vec3 col = vec3(dif);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}