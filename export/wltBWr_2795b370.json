{"ver":"0.1","info":{"id":"wltBWr","date":"1612556003","viewed":184,"name":"Colored Chain 3D","username":"Kamoshika","description":"https://twitter.com/kamoshika_vrc/status/1357750673769590784\nhttps://twitter.com/kamoshika_vrc/status/1357265102471266307","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","torus","chain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 hsv2rgb(float h, float s, float v) {\n    vec3 res = fract(h+vec3(0,2,1)/3.);\n    res = abs(res*6.-3.)-1.;\n    res = clamp(res, 0., 1.);\n    res = (res-1.)*s+1.;\n    res *= v;\n    return res;\n}\n\nfloat exp2Fog(float dist, float density) {\n    float s = dist * density;\n    return exp(-s*s);\n}\n\nfloat sdTorus(vec3 p) {\n    return length(vec2(length(p.zx) - 0.3, p.y)) - 0.02;\n}\n\n// This also works.\n// q = q.y > q.x ? q.yxz : q;\n// q = q.y > q.z ? q.xzy : q;\n// q = q.z > q.x ? q.zyx : q;\n// float d = sdTorus(q - vec3(0.5, 0., 0.5));\n// d = min(d, sdTorus(q.zxy - vec3(0., 0.5, 0.)));\n\nfloat dist(vec3 p) {\n    vec3 q = abs(fract(p) - 0.5);\n    q = q.x > q.z ? q.zyx : q;\n    if(q.y > 0.5 - q.x)q.xy = 0.5 - q.yx; // add\n    if(q.y > 0.5 - q.z)q.yz = 0.5 - q.zy; // add\n    float d = sdTorus(q);\n    d = min(d, sdTorus(q.yxz + vec3(0, 0, -0.5)));\n    //d = min(d, sdTorus(q + vec3(-0.5, -0.5, -0.5))); // no need\n    //d = min(d, sdTorus(q.xzy + vec3(0, -0.5, -0.5))); // no need\n    return d;\n}\n\nvec3 objColor(vec3 p) {\n    vec3 col = vec3(0);\n    vec3 q = abs(fract(p) - 0.5);\n    float th = 0.01;\n    float s = 0.8;\n    float v = 1.;\n    \n    if(sdTorus(q) < th) {\n        col = hsv2rgb(1./6., s, v);\n    } else if(sdTorus(q + vec3(-0.5, -0.5, -0.5)) < th) {\n        col = hsv2rgb(2./6., s, v);\n    } else if(sdTorus(q.xzy + vec3(0, -0.5, -0.5)) < th) {\n        col = hsv2rgb(3./6., s, v);\n    } else if(sdTorus(q.yxz + vec3(0, 0, -0.5)) < th) {\n        col = hsv2rgb(4./6., s, v);\n    } else if(sdTorus(q.xzy + vec3(-0.5, 0, 0)) < th) {\n        col = hsv2rgb(5./6., s, v);\n    } else if(sdTorus(q.yxz + vec3(-0.5, -0.5, 0)) < th) {\n        col = hsv2rgb(6./6., s, v);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord*2.-iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 col = vec3(0);\n    \n    vec3 cPos = vec3(0., 0.5, 0.);\n    cPos += vec3(-1, -1, -1)*fract(iTime*0.3);\n    vec3 cDir = normalize(vec3(0.3, 0, -1.));\n    vec3 up = vec3(0, 1, 0);\n    vec3 cSide = normalize(cross(cDir, up));\n    vec3 cUp = normalize(cross(cSide, cDir));\n    \n    vec3 ray = normalize(p.x*cSide + p.y*cUp + cDir*2.);\n    \n    vec3 rPos = cPos;\n    float d = 0.;\n    float count = 0.;\n    for(int i=0; i<99; i++){\n        d = dist(rPos);\n        if(d < 0.0001){\n            break;\n        }\n        rPos += ray * d;\n        count++;\n    }\n    \n    if(d < 0.1) {\n        vec3 base = objColor(rPos);\n        col = base * 20. / count;\n    }\n    \n    float fog = exp2Fog(length(rPos-cPos), 0.1);\n    col = mix(vec3(1), col, fog);\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}