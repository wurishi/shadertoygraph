{"ver":"0.1","info":{"id":"Dddczj","date":"1695823626","viewed":23,"name":"Konod's CRT Screen","username":"Konod","description":"A CRT screen simulation.\nYou can compare with the original video by dragging your mouse on the screen.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["crt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define RES min(iResolution.x, iResolution.y)\n#define PI 3.1415926536\n#define SQRT3 1.73205081f\n\nvec3 getVideo(vec2 uv) {\n    vec2 correctUV = uv*min(iResolution.x, iResolution.y)*.5f/iResolution.xy + .5f;\n    vec3 sRGBPixel = texture(iChannel0, correctUV).xyz;\n    return pow(sRGBPixel, vec3(2.2f));\n}\n\n//CRT color grid section. For more details: https://www.shadertoy.com/view/md3yRj\nfloat Gaussian(vec2 P, float sigma, float amplitude) {\n    return amplitude*exp(-dot(P,P)/sigma);\n}\n\nfloat UnitGaussianCircle(vec2 uv, vec2 center, float radius) {\n    return Gaussian(uv - center, radius, SQRT3/sqrt(PI * radius));\n}\n\n//This method uses the properties of hexagonal tiling.\n//The grid is in a rectangural tile of size (2, 2*sqrt(3))/dim.\n//len is the size of the circles relative to the grid.\n//Here they are defined by a gaussian, but if they where proper circles they would be tangent at len = 0.57735027f.\nfloat HexagonGrid(vec2 uv) {\n    float len = .5f;//0.57735027f;\n    vec2 uvCentered = mod(uv, vec2(2.f, 2.f*SQRT3));\n    if (uvCentered.x > 1.f) uvCentered.x = 2.f - uvCentered.x;\n    if (uvCentered.y > SQRT3) uvCentered.y = 2.f*SQRT3 - uvCentered.y;\n    float o = UnitGaussianCircle(uvCentered, vec2(0.f, 0.f), len);\n    o +=UnitGaussianCircle(uvCentered, vec2(1.f, SQRT3), len);\n    return o;\n}\nvec3 RGBHexagonGrid(vec2 uv) {\n    uv *= 1.f * RES;\n    vec3 o;\n    o.r = HexagonGrid(uv);\n    o.g = HexagonGrid(uv + vec2(0.f, 0.6666666f * SQRT3));\n    o.b = HexagonGrid(uv + vec2(0.f, 1.3333333f * SQRT3));\n    return o;\n} \n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    fragColor = vec4(0.f);\n    \n    float transitionWidth = 0.005f;\n    float section = (fragCoord.x - iMouse.x)/iResolution.x;\n    if(section < -transitionWidth) {\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    }\n    \n    if (section > transitionWidth) {\n        vec2 uv = (2.*fragCoord - iResolution.xy)/RES;\n        uv *= 1. + pow(abs(uv.yx)/vec2(6.f, 6.f), vec2(2.f, 2.f));\n\n        // Clearing overflows\n        vec2 insideScreen = smoothstep( .03, .0, abs(uv)-iResolution.xy/RES);\n        vec3 col = getVideo(uv) * insideScreen.x * insideScreen.y;\n\n\n        vec3 screenColorGrid = RGBHexagonGrid(uv);\n        if (fwidth(length(screenColorGrid)) > .01) {\n            for (int i = 0; i < 9; i++) {\n                vec2 offset = vec2(i%3 - 1, i/3 - 1)*0.333f;\n                screenColorGrid += RGBHexagonGrid(uv + offset/RES);\n                if (i == 3) i++;\n            }\n            screenColorGrid /= 9.0;\n        }\n\n        col *= screenColorGrid;    \n\n        // Output to screen with gamma correction\n        fragColor = vec4(pow(col, vec3(1.f/2.2f)),1.0);\n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"}]}