{"ver":"0.1","info":{"id":"Dd2fRh","date":"1689459197","viewed":46,"name":"Quadratic sandpiles","username":"Vectornaut","description":"This shader shows the Laplacian of an integer-valued function on a square grid, which in some cases represents the final state of an Abelian sandpile. Click and drag to see different functions.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sandpile"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// this shader shows the Laplacian of an integer-valued function on a square\n// grid, which in some cases represents the final state of an Abelian sandpile\n//\n//   Levine, Pegden, and Smart. The Apollonian structure of integer\n//   superharmonic matrices (doi:10.4007/annals.2017.186.1.1)\n//\n// although it uses floating point arithmetic, its output will be correct as\n// long as i've written it carefully enough (a big if), your GPU meets the\n// IEEE-754 floating point standard (also possibly a big if), and the numerators\n// and denominators of the numbers it uses don't get too large (we're talking\n// millions)\n//\n//   https://randomascii.wordpress.com/2017/06/19/sometimes-floating-point-math-is-perfect/\n//   https://blog.demofox.org/2017/11/21/floating-point-precision/\n//\n// errors are shown using special colors:\n//\n//   green (0, 1, 0) means a non-integer between -2 and 3. if you see this, either\n//   i or your GPU has screwed up the floating-point arithmetic\n//\n//   cyan (0, 1, 1) means a number below -2 or above 3. if it's an integer, you can\n//   see its value by adding more tests to the \"color by pile height\" function\n//\n//\n\n// the integer-valued function given by rounding the quadratic form A/div up to\n// the nearest integer. to avoid rounding issues during the calculation, we\n// return div times the desired output\nfloat cquad(mat2 A, float div, vec2 u) {\n  float f = dot(u, A*u);\n  return f + div - mod(f, div);\n}\n\n// the laplacian of the rounded quadratic function described above\nfloat pile(mat2 A, float div, vec2 u) {\n  const mat2 e = mat2(1.);\n  return cquad(A, div, u + e[0]) + cquad(A, div, u - e[0]) + cquad(A, div, u + e[1]) + cquad(A, div, u - e[1]) - 4.*cquad(A, div, u);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // choose a fraction, which will represent an integer quadratic form\n  float p;\n  float q;\n  if (iMouse.x < 0.25*iResolution.x) {\n    p = 1.;\n    q = 3.;\n  } else if (iMouse.x < 0.5*iResolution.x) {\n    p = 1.;\n    q = 4.;\n  } else if (iMouse.x < 0.75*iResolution.x) {\n    p = 3.;\n    q = 4.;\n  } else {\n    p = 2.;\n    q = 5.;\n  }\n  \n  // choose a scale factor\n  float scale = 1.;\n  if (iMouse.z > 0.) scale = ceil(4.*iMouse.y/iResolution.y);\n  \n  // write down a scaled integer quadratic form\n  vec4 v = vec4(1., p*q, 0., 1.);\n  float div = scale*q*q;\n  mat2 A = 0.5*mat2(v.w + v.x, v.y, v.y, v.w - v.x);\n  \n  // find screen point\n  const float view = 25.;\n  float small_dim = min(iResolution.x, iResolution.y);\n  vec2 u = round((view / small_dim) * (2.*fragCoord - iResolution.xy));\n  \n  // color by pile height\n  float h = pile(A, div, u);\n  vec3 color = vec3(0., 1., 0.);\n  if (h == -2.*div) {\n    color = vec3(0.2, 0., 0.5);\n  } else if (h == -div) {\n    color = vec3(0.5, 0., 0.6);\n  } else if (h == 0.) {\n    color = vec3(0.9, 0., 0.5);\n  } else if (h == div) {\n    color = vec3(1., 0.5, 0.);\n  } else if (h == 2.*div) {\n    color = vec3(1., 1., 0.);\n  } else if (h == 3.*div) {\n    color = vec3(1., 1., 0.9);\n  } else if (h < -2.*div || 3.*div < h) {\n    color = vec3(0., 1., 1.);\n  }\n  fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}