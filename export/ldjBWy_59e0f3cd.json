{"ver":"0.1","info":{"id":"ldjBWy","date":"1502056034","viewed":133,"name":"aasdgasdafasdg","username":"jnalanko","description":"aaaaa","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat opTx( vec3 p, mat4 m )\n{\n    vec3 q = (inverse(m)*vec4(p,1)).xyz;\n    return sdBox(q,vec3(1,2,1));\n}\n\n\nfloat sdf(vec3 p){\n\t//return sqrt(p.z*p.z + p.y*p.y) - 1.0;   \n    //return sdBox(p,vec3(1,2,1));\n    //return opTx(p, rotationMatrix(vec3(1,1,1), iTime));\n    mat4 m = rotationMatrix(vec3(1,1,1), iTime);\n    vec3 rep = vec3(10,10,10);\n    p = mod(p,rep)-0.5*rep; // Repeat\n    p = (inverse(m)*vec4(p,1)).xyz; // Rotate\n    return max(-sdSphere(p,1.8),sdBox(p,vec3(1.0 + sin(iTime),2,1)));\n}\n\nvec3 get_normal(vec3 pos)\n{\n\tvec3 eps = vec3(0.01,0,0);\n\treturn normalize(vec3(\n\t\tsdf(pos + eps.xyy) - sdf(pos - eps.xyy),\n\t\tsdf(pos + eps.yxy) - sdf(pos - eps.yxy),\n\t\tsdf(pos + eps.yyx) - sdf(pos - eps.yyx)\n\t));\n}\n\n// Clamped dot\nfloat cdot(vec3 a, vec3 b){\n    return max(0.0,dot(a,b));\n}\n\nvec3 filmicToneMapping(vec3 color)\n{\n\tcolor = max(vec3(0.), color - vec3(0.004));\n\tcolor = (color * (6.2 * color + .5)) / (color * (6.2 * color + 1.7) + 0.06);\n\treturn color;\n}\n\nvec3 gamma(vec3 c) {\n\treturn pow(c, vec3(1.6/2.2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Fix coordinate system\n    float aspect_ratio = 16.0/9.0;\n\tvec2 pixel_pos = fragCoord.xy / iResolution.xy; // [0,1]\n    pixel_pos -= vec2(0.5,0.5); // [-1/2, 1/2]\n    pixel_pos *= vec2(2,2); // [-1,1]\n    pixel_pos.x *= aspect_ratio;\n    \n    vec3 v_0 = vec3(cos(0.5*iTime)*10.0,sin(0.5*iTime)*15.0, 5.0 - iTime*10.0); // Camera position\n    mat4 camera_roll = rotationMatrix(vec3(0,0,-1), 0.0);\n    mat4 camera_pitch = rotationMatrix(vec3(1,0,0), -atan(0.5*cos(iTime))*0.4);\n    mat4 camera_yaw = rotationMatrix(vec3(0,1,0), 0.0);\n    \n    // Raymarch\n    vec3 ray = normalize(vec3(pixel_pos.x, pixel_pos.y,-1));\n    ray = (camera_yaw * camera_pitch * camera_roll * vec4(ray,1)).xyz;\n    \n    vec3 pos = v_0;\n    for(int step = 0; step < 50; step++){\n  \t\tpos += ray * sdf(pos)*0.8;\n    }\n    \n    // Phong: k_s * cos(alpha)^q * intensity / r^2\n    float sun_intensity = 5.0;\n    vec3 background = vec3(0.01,0.01,0.01);\n    //vec3 sun = vec3(30.0 * sin(iTime),20,30.0*cos(iTime));\n    vec3 sun = v_0 + vec3(0,10,-20);\n    float k_s = 1.0; // Specular coefficient\n    float q = 2.0; // Specular exponent\n    \n    vec3 diffuse_color = vec3(0.2,0.8,0.4);\n    vec3 ambient_color = vec3(0.6,1,0.6);\n    vec3 specular_color = vec3(0.7,1,0.7);\n    \n    if(sdf(pos) > 0.05) // No hit\n        fragColor = vec4(background,1);\n    else{\n        vec3 surface = pos;\n        vec3 normal = get_normal(surface);\n        vec3 l = surface - sun; // Sun to surface\n        float intensity_at_surface = sun_intensity / dot(l,l); // Inverse square decay\n        \n    \tvec3 l_prime = l + 2.0*dot(l,normal)*normal;\n        vec3 to_camera = v_0 - surface;\n        float cos_angle = cdot(-l_prime, to_camera)/(length(l_prime) * length(to_camera));\n        vec3 specular = specular_color * k_s * pow(cos_angle,q) * intensity_at_surface;\n        vec3 diffuse = diffuse_color * 0.2 * cdot(normal, -l) * intensity_at_surface;\n        vec3 ambient = ambient_color * 0.01;\n        vec3 light = vec3(clamp(diffuse + specular + ambient,0.0,1.0));\n        float fogfactor = clamp(length(pos-v_0)/200.0,0.0,1.0);\n        //fogfactor = 0.0;\n        vec3 finallight = vec3(light.x, light.y, light.z);\n        finallight = mix(finallight, background, fogfactor);\n        finallight = gamma(filmicToneMapping(finallight));\n        fragColor = vec4(finallight,1);\n    }\n\n}\n\n","name":"Image","description":"","type":"image"}]}