{"ver":"0.1","info":{"id":"dt2Gzy","date":"1673502794","viewed":146,"name":"kawase pencil map fork 1","username":"vinvinvin","description":"Complete caustic from a thin lens. Supposed to generate a LUT for Depth of Field near/far focus chromatic aberration, so the code isn't golfed in any way, for better readability. \n\n","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["ray","spectrum","lens","siggraph","wavelength"],"hasliked":0,"parentid":"XlccWN","parentname":"pencil map"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = texelFetch(iChannel0,ivec2(fragCoord.xy),0);\n    fragColor.rgb /= fragColor.a;\n\n   \n    fragColor.a = 1.;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\ny = lens thickness\n \n      |\\\n______|_\\.\n  ▲   |  \\   . \n  x   |   |      .\n  ▼   |   |          .\n------|---|-----------------\n      |<y>|\n      |   |\n      |  /\n      | /\n      |/\n\nangle of sphere normal to ___ line: phi1\nangle of sphere normal to ___ line after refraction: phi2\nresulting angle between ___ and . . . . line: phi2-phi1 = phi\n\nresulting slope for f(t)=y_intercept + slope * t : -tan(phi)\n\nlens is always fitted to screen height\n\n\n*/\n\n#define IOR_AIR 1.00239\n#define LENS_THICKNESS 0.07 //0 means flat, 1.0 means half circle\n#define OBSERVABLE_RANGE 1.0 //multiplier of 2*focal length (avg)\n\n   \n    \n    #define NUM_RAYS 80\t//amount of rays per lambda\t\n \t#define NUM_LAMBDAS 20\t//amount of considered wavelengths\n\n\n#define MODE 2 //1 = max, 2 = mean\n#define HALF 1\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\nvec3 spectral_zucconi6 (float w)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n\nfloat plot(float f, float y)\n{\n    float v = f - y;\n    v /= length(vec2(dFdx(v), dFdy(v)));\n    return clamp(1.0 - abs(v)*0.5, 0., 1.);\n}\n\nfloat IOR_from_lambda(float lambda)\n{\n    float B = 1.7280;\n    float C = 0.01342; \n    float nm_to_um = 0.001;\n   \treturn B + C / (lambda * lambda * nm_to_um * nm_to_um); \n}\n\nfloat refraction_phi_from_x(float x, float ior)\n{\n    float phi1 = asin(x);//angle of light to normal of sphere (inside sphere)\n    float phi2 = asin(ior / IOR_AIR * x /*sin(phi1)*/ ); //angle of light to normal of sphere (after refract)\n    float phi = phi2-phi1;\n    return phi;    \n}\n\nfloat get_focal_length(float ior)\n{\n    float x = sqrt(2.*LENS_THICKNESS - LENS_THICKNESS*LENS_THICKNESS); \n    float phi = refraction_phi_from_x(x, ior); \n    return 1.0/tan(phi);\n}\n\n\n//finds the curve that outlines the entire pattern\n//so it can be stretched to not waste texels - it's going\n//to be a LUT, after all\nfloat get_best_scale(vec2 uv)\n{\n    float scale = 0.0;\n    \n  \tfor(int i = 0; i <= 3; i++)\n    {\n        float lambda = mix(400.,700., float(i) / 3.); //using it as index directly doesn't work?\n        float IOR_GLASS_from_lambda = IOR_from_lambda(lambda);\n        for(int j = 0; j <= 90; j++)\n        {\n            float y = mix(0.,1.,float(j) / 90.0);\n            float x = y * sqrt(2.*LENS_THICKNESS - LENS_THICKNESS*LENS_THICKNESS); \n            float phi = refraction_phi_from_x(x, IOR_GLASS_from_lambda); \n            float slope = abs(-tan(phi) * uv.x);          \n            scale = max(scale, abs(slope - y));\n        } \n    }\n  \n   \treturn scale;\n}\n\nuint HashWang( uint a )\n{\n\ta = (a ^ 61u) ^ (a >> 16u);\n\ta = a + (a << 3u);\n\ta = a ^ (a >> 4u);\n\ta = a * 0x27d4eb2du;\n\ta = a ^ (a >> 15u);\n\treturn a;\n}\n\nuint HashHugo( uint n )\n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;    \n    \n    return n;\n}\n\nuint Rand( inout uint seed )\n{\n    seed += 13u;\n    return HashWang( seed );\n}\n\nfloat FRand( inout uint seed )\n{\n    uint urand = Rand( seed );    \n    const uint mantissaMask = (0xffffffffu) >> ( 32u - 23u );\n    return fract(float(urand & mantissaMask) / float(mantissaMask)); \n   // return uintBitsToFloat( (urand & mantissaMask) | (127u << 23u) );\n}\n\nvec2 FRand2( inout uint seed )\n{\n    return vec2( FRand( seed ), FRand( seed ) );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float middle_focal_length = 0.5 * get_focal_length(IOR_from_lambda(400.0)) \n                             + 0.5 * get_focal_length(IOR_from_lambda(700.0));\n    \n    uv.x *= middle_focal_length * 2.; //so the avg focal plane is exactly at uv.x == 0.5\n    \n    uv.x *= OBSERVABLE_RANGE;    \n   \tvec3 color =vec3(0.0);      \n\n#if(HALF == 1)\n    uv.y = 0.5 - uv.y * 0.5;\n    \n#endif\n    \n    float scale = get_best_scale(uv) * 1.1;\n   \tuv.y = uv.y * 2.0 - 1.0;\n    uv.y *= scale;\n   \tuv.y = uv.y * 0.5 + 0.5;\n    \n    \n   \tuint pixelSeed = uint(fragCoord.x)^uint(fragCoord.y);\n    vec2 jitter = vec2((pixelSeed^uint(iFrame*7))&0xffU,((pixelSeed^uint(iFrame*29))/5U)&0xffU)/float(0x100U) - .5;\n \n    uint seed = uint( iTime * 23.456 ) + uint(fragCoord.x *23.45f) * 12326u + uint(fragCoord.y * 36.43) * 42332u;\n   \tjitter = FRand2(seed);\n    jitter = fract(jitter);\n    \n    vec3 normalize_color = vec3(0.0);\n    \n    float increment = (700.0 - 400.0) /float(NUM_LAMBDAS);\n    for(float lambda = 400. + increment * jitter.x; lambda < 700.; lambda += increment)\n    {            \n    \t//Hard crown glass K5 wikipedia, cauchy eq.\n    \tfloat IOR_GLASS_from_lambda = IOR_from_lambda(lambda);\n        \n        vec3 ray_color = spectral_zucconi6(lambda);\n#if(MODE == 1)        \n\t\tnormalize_color = max(normalize_color, ray_color);\n#endif\n#if(MODE == 2)        \n\t\tnormalize_color += ray_color;\n#endif       \n    \tfor(float i = 0.; i < float(NUM_RAYS); i++)\n    \t{\n        \tfloat y_intercept = float(i + fract(jitter.y))/float(NUM_RAYS);\n            \n            y_intercept = y_intercept * 2. - 1.;\n        \n        \n        \t//thickness = 1-cos(asin(y intercept)) <=> x = sqrt(2*thickness - thickness^2               \n        \tfloat x = y_intercept * sqrt(2.*LENS_THICKNESS - LENS_THICKNESS*LENS_THICKNESS);        \n \n            float phi = refraction_phi_from_x(x, IOR_GLASS_from_lambda);            \n        \tfloat slope = -tan(phi) * uv.x;            \n           \tfloat line = plot(uv.y * 2.0 - 1.0 - y_intercept, slope);  \n#if(MODE == 1)                       \n           \tcolor = max(color, ray_color * line);\n#endif\n#if(MODE == 2)                       \n           \tcolor += ray_color * line;\n#endif\n    \t}\n    }\n    \n    color /= normalize_color  / max(max(normalize_color.r, normalize_color.b), normalize_color.g); \n\n    #if(MODE == 2)                       \n    color /= float(NUM_RAYS) / scale;\n    color = 1. - exp2(-color * 9.0);\n#endif  \n\n    \n    fragColor = vec4(color, 1.0);    \n    \n    if ( iFrame > 0 )\n    {\n        // vec4 maxcolor =  max(fragColor, texelFetch(iChannel0,ivec2(fragCoord.xy),0));\n        // vec4 addcolor = fragColor +texelFetch(iChannel0,ivec2(fragCoord.xy),0);\n        // fragColor = mix(addcolor,maxcolor,vec4(0.992));\n        // fragColor += texelFetch(iChannel0,ivec2(fragCoord.xy),0);\n        fragColor = max(fragColor, texelFetch(iChannel0,ivec2(fragCoord.xy),0));\n    }    \n\n    \n    if( texture( iChannel1, vec2(82.5/256.0, 0.5) ).x > 0.0) fragColor = vec4(0.);\n    \n    \n    \n}","name":"Buffer A","description":"","type":"buffer"}]}