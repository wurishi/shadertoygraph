{"ver":"0.1","info":{"id":"WlSBRy","date":"1606759719","viewed":133,"name":"pong23","username":"edwardbraed","description":"Just a pong game.\ncontrol: 'W / S' - right racket, 'up / down' - left racket, 'Space' - play/stop, \"Escape\" - reset score.\nComment \"UD_CONTROL\", for control with left/right keys","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["game","pong"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 aspect = calcAspect(iResolution.xy);\n    vec2 center = vec2(0.5) * aspect;\n    vec2 pos = uv * aspect;\n    \n    GameState s = loadState(iChannel1);\n    \n    vec2 lRacketPos = vec2(hrSize.x, s.rps[0]) * aspect;\n    vec2 rRacketPos = vec2(1.0 - hrSize.x, s.rps[1]) * aspect;\n    \n    vec2 ballPos = s.bp * aspect;\n    \n    float val = 0.0;\n    \n    //- draw left racket ----------\n    vec2 plr = (lRacketPos - (hrSize * aspect));\n    vec2 elr = (plr + rSize * aspect);\n    val += float((pos.x > plr.x) && \n                 (pos.y > plr.y) &&\n                 (pos.x < elr.x) && \n                 (pos.y < elr.y));\n    \n    //- draw right racket ----------\n    vec2 prr = (rRacketPos - (hrSize * aspect));\n    vec2 err = (prr + rSize * aspect);\n    val += float((pos.x > prr.x) && \n                 (pos.y > prr.y) &&\n                 (pos.x < err.x) && \n                 (pos.y < err.y));\n\t\n    \n    //- draw ball ------------------\n    vec2 pb = (ballPos - (bSize * 0.5));\n    vec2 eb = (pb + bSize);\n    val += float((pos.x > pb.x) && \n                 (pos.y > pb.y) &&\n                 (pos.x < eb.x) && \n                 (pos.y < eb.y));\n    \n    val += 0.15 * (float(pos.y > (aspect.y - lSize)) + float(pos.y < lSize) + \n                   float(pos.x < 0.5 + hlSize && pos.x > 0.5 - hlSize) * \n                   float(int(pos.y / (aspect.y / 50.0)) % 2));\n    \n    //- draw score -----------------\n    \n    val = drawNumber(val, pos, vec2(0.55, 0.87) * aspect, vec2(0.05,0.1) * aspect, s.score[0]);\n    val = drawNumber(val, pos, vec2(0.40, 0.87) * aspect, vec2(0.05,0.1) * aspect, s.score[1]);\n    \n    // Output to screen\n    fragColor = vec4(val);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#ifdef UD_CONTROL\n    #define LEFT_UP_BTN 87\n    #define LEFT_DWN_BTN 83\n    #define RIGHT_UP_BTN 38\n\t#define RIGHT_DWN_BTN 40\n#else\n    #define LEFT_UP_BTN 65\n    #define LEFT_DWN_BTN 68\n    #define RIGHT_UP_BTN 37\n\t#define RIGHT_DWN_BTN 39\n#endif\n\n#define RESET_BTN 27\n#define SPACE_BTN 32\n\nbool hitR(vec2 bp, float rp, float r)\n{\n    vec2 lra1 = vec2(r * (r - rSize.x),         rp - hrSize.y); \n    vec2 lra2 = vec2((1.0 - r) * rSize.x + (r), rp + hrSize.y);\n\n    return bp.x > lra1.x && bp.y > lra1.y &&\n           bp.x < lra2.x && bp.y < lra2.y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    GameState s = loadState(iChannel1);\n    \n///- input processing -/////////////////////////////////////////\n    \n    float abtn = texelFetch(iChannel0, ivec2(LEFT_UP_BTN,  0), 0).x;\n    float dbtn = texelFetch(iChannel0, ivec2(LEFT_DWN_BTN, 0), 0).x;\n    \n    float lbtn = texelFetch(iChannel0, ivec2(RIGHT_UP_BTN,   0), 0).x;\n    float rbtn = texelFetch(iChannel0, ivec2(RIGHT_DWN_BTN,  0), 0).x;\n    \n    float sbtn = texelFetch(iChannel0, ivec2(SPACE_BTN,     0), 0).x;\n    float ebtn = texelFetch(iChannel0, ivec2(RESET_BTN,     0), 0).x;\n    \n    //- rackets move --------------------\n    float lVal = float(abtn > 0.0) * 1.0 + float(dbtn > 0.0) * -1.0;\n    float rVal = float(lbtn > 0.0) * 1.0 + float(rbtn > 0.0) * -1.0;\n    \n    s.rvs[0] = s.rvs[1] = float(iFrame % 3) - 1.0;\n    //s.rvs[1] = rVal;\n    \n    s.rps[0] = clamp(s.rps[0] + lVal * rSpeed * iTimeDelta, hrSize.y, 1.0 - hrSize.y);\n    s.rps[1] = clamp(s.rps[1] + rVal * rSpeed * iTimeDelta, hrSize.y, 1.0 - hrSize.y);\n    \n    //- begin/end playing ---------------\n    if(sbtn > 0.0 && (s.time + 0.3) < iTime)\n    {\n    \tif(s.play > 0.0)\n        {\n        \ts.play = 0.0;\n            s.bp   = vec2(0.5);\n        }\n        else\n        {\n        \ts.play = 1.0;\n            float rv = sign((float(iFrame % 2) - 0.5));\n            s.bv   = vec2(rv, 0.0);\n        }\n        s.time = iTime;\n    }\n    \n    //- reset game -----------------------\n    if(ebtn > 0.0)\n    {\n        s.play = 0.0;\n        s.rps = s.bp = vec2(0.5);\n        s.score = vec2(0.0);\n    }\n    \n///- ball move processing -//////////////////////////////////////\n    \n    if(s.play > 0.0)\n    {\n    \ts.bp += s.bv * bSpeed * iTimeDelta;\n        bvec2 hrs = bvec2(hitR(s.bp, s.rps[0], 0.0), hitR(s.bp, s.rps[1], 1.0));\n        if(hrs[0] || hrs[1])\n        {\n           s.bv = vec2(-s.bv.x, (s.rvs[0] * float(hrs[0]) + s.rvs[1] * float(hrs[1])) );\n           s.bp.x = float(s.bp.x < rSize.x) * rSize.x +\n                    float(s.bp.x > 1.0 - rSize.x) * (1.0 - rSize.x);\n        }\n        else if(s.bp.y < 0.0 || s.bp.y > 1.0)\n        {\n            s.bv = vec2(s.bv.x, -s.bv.y);\n            s.bp.y = float(s.bp.y < 0.0) * hbSize + \n                     float(s.bp.y > 1.0) * (1.0 - hbSize);\n        }\n        else if((s.bp.x < 0.0 || s.bp.x > 1.0))\n        {\n        \ts.score[int(!(s.bp.x < 0.0)) + \n                    int(s.bp.x > 1.0)] += 1.0;\n            s.play = 0.0;\n            s.bp   = vec2(0.5);\n        }   \n    }\n    else if(s.score.x + s.score.y < 1.0)\n        s.rps = s.bp = vec2(0.5);\n    \n    s.rvs[0] = mix(s.rvs[0], 0.0, dSpeed * iTimeDelta);\n    s.rvs[1] = mix(s.rvs[1], 0.0, dSpeed * iTimeDelta);\n    \n    //----------------------------------------------------------\n    fragColor = saveState(s, ivec2(fragCoord));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//- common settings ---------------------\n\nconst vec2  rSize  = vec2(0.03, 0.25); // rackets size\nconst float bSize  = 0.013;            // ball size\nconst float lSize  = 0.004;            // lines size\nconst float rSpeed = 0.9;              // rackets speed\nconst float bSpeed = 0.7;              // ball speed\nconst float dSpeed = 0.4;              // direction decay speed\n\n// comment me, for control keys left/right\n#define UD_CONTROL\n\n//---------------------------------------\n//- not for user edit.. -----------------\n//---------------------------------------\n\nconst vec2  hrSize = rSize * 0.5;\nconst float hbSize = bSize * 0.5;\nconst float hlSize = lSize * 0.5;\n\nstruct GameState\n{\n    float play;  // 'is playing' flag\n    float time;  // last timestamp\n    vec2  score; // score of rackets\n    vec2  rps;   // rackets positions\n    vec2  bp;    // ball    position\n    vec2  rvs;   // rackets vectors\n    vec2  bv;    // ball    vector\n};\n\n// s0) pixel[0,0] = [float play, float time, vec2 scores]\n// s1) pixel[1,0] = [vec2  rps,  vec2 bp                ]\n// s2) pixel[2,0] = [vec2  rvs,  vec2 bv                ]\nvec4 saveState(GameState state, ivec2 fragCoord)\n{\n    vec4 result = vec4(0.0);\n    \n    result.x += float(fragCoord.x == 0) * float(state.play);\n    result.y += float(fragCoord.x == 0) * float(state.time);\n    result.z += float(fragCoord.x == 0) * float(state.score[0]);\n    result.w += float(fragCoord.x == 0) * float(state.score[1]);\n    \n    result.x += float(fragCoord.x == 1) * state.rps[0];\n    result.y += float(fragCoord.x == 1) * state.rps[1];\n    result.z += float(fragCoord.x == 1) * state.bp.x;\n    result.w += float(fragCoord.x == 1) * state.bp.y;\n    \n    result.x += float(fragCoord.x == 2) * state.rvs[0];\n    result.y += float(fragCoord.x == 2) * state.rvs[1];\n    result.z += float(fragCoord.x == 2) * state.bv.x;\n    result.w += float(fragCoord.x == 2) * state.bv.y;\n    \n    return result;\n}\n\nGameState loadState(sampler2D iChannel)\n{\n    vec4 s0 = texelFetch(iChannel, ivec2(0,0), 0);\n    vec4 s1 = texelFetch(iChannel, ivec2(1,0), 0);\n    vec4 s2 = texelFetch(iChannel, ivec2(2,0), 0);\n\n    return GameState(s0.x, s0.y, s0.zw, s1.xy, s1.zw, s2.xy, s2.zw);\n}\n\nvec2 calcAspect(vec2 iRes)\n{\n    vec2 aspect = vec2(float(iRes.x < iRes.y) * iRes.x / iRes.y,\n\t\t\t\t\t   float(iRes.y < iRes.x) * iRes.y / iRes.x);\n    aspect.x += float(aspect.x == 0.0);\n    aspect.y += float(aspect.y == 0.0);\n    return aspect;\n}\n\nfloat drawNumber(float bck, vec2 uv, vec2 pos, vec2 sz, float num)\n{\n    const vec4 glyphs[] = vec4[50]( \n           vec4(1,1,1,1),vec4(1,0,0,1),vec4(1,0,0,1),vec4(1,0,0,1),vec4(1,1,1,1),  // 0\n           vec4(0,0,1,0),vec4(0,1,1,0),vec4(0,0,1,0),vec4(0,0,1,0),vec4(0,0,1,0),  // 1\n           vec4(1,1,1,1),vec4(0,0,0,1),vec4(1,1,1,1),vec4(1,0,0,0),vec4(1,1,1,1),  // 2\n           vec4(1,1,1,1),vec4(0,0,0,1),vec4(1,1,1,1),vec4(0,0,0,1),vec4(1,1,1,1),  // 3 \n           vec4(1,0,0,1),vec4(1,0,0,1),vec4(1,1,1,1),vec4(0,0,0,1),vec4(0,0,0,1),  // 4\n           vec4(1,1,1,1),vec4(1,0,0,0),vec4(1,1,1,1),vec4(0,0,0,1),vec4(1,1,1,1),  // 5\n           vec4(1,1,1,1),vec4(1,0,0,0),vec4(1,1,1,1),vec4(1,0,0,1),vec4(1,1,1,1),  // 6\n           vec4(1,1,1,1),vec4(0,0,0,1),vec4(0,0,1,0),vec4(0,1,0,0),vec4(0,1,0,0),  // 7\n           vec4(1,1,1,1),vec4(1,0,0,1),vec4(1,1,1,1),vec4(1,0,0,1),vec4(1,1,1,1),  // 8\n           vec4(1,1,1,1),vec4(1,0,0,1),vec4(1,1,1,1),vec4(0,0,0,1),vec4(1,1,1,1)); // 9  \n    vec2 pt = (uv - pos) * (vec2(1.0) / sz);\n    int x = int(num * 5.0 + 5.0 * (1.0 - pt.y));\n    int y = int(4.0 * pt.x);\n    float v = glyphs[x][y] * float(pt.x < 1.0) * float(pt.y < 1.0) * \n              float(uv.x > pos.x) * float(uv.y > pos.y);\n    \n\treturn mix(bck, 1.0, v);\n}","name":"Common","description":"","type":"common"}]}