{"ver":"0.1","info":{"id":"lcdyDM","date":"1732295980","viewed":232,"name":"Clay Shooter","username":"NAME_REDACTED","description":"Clay pigeon shooting game. 4 game modes, 4 shot types, and up to 4 players. Recommended to play in fullscreen. Post your high score!","likes":23,"published":1,"flags":32,"usePreview":0,"tags":["game","interactive","shooter","arcade","gun","multiplayer","shooting","clay","pigeon","skeet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* ---===Clay Shooter Game===---\nClick anywhere to start. Clays will launch automatically.\nClick the mouse to fire a shot at the point on the screen.\nGame settings as well as explanation of scoring rules are on the Common page.\nHave fun!\n*/\n\n#define MOUNTAINS_AA //enables antialiasing on mountains\n#define OBJ_AA //antialiasing on objects\n\n#define DISPLAY iChannel2, iResolution.y, fragCoord\n\n//const vec3[] bbc = vec3[] (vec3(1.), vec3(1.,.1,0.), vec3(1.), vec3(1.,.9,0.), vec3(1.), vec3(.15,.2,1.), vec3(1.));\n\nconst vec3 skeetShape = vec3(SKEET_SIZE, SKEET_SIZE * 0.4, SKEET_SIZE);\nint numSkeet;\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, z));\n}\n\nmat3 setCamera( in vec3 dir)\n{\n\tvec3 cw = (dir);\n\tvec3 cp = vec3(0.0, 1.0, 0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 getRayIq(vec2 fragCoord)\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    // camera\t\n    vec3 ta = camera;\n    vec3 dir = lookDir * vec3(1.,1.,1.);\n    // camera-to-world transformation\n    mat3 ca = setCamera(dir);\n    // focal length\n    const float fl = 4.;\n\n    // ray direction\n    vec3 rd = ca * normalize( vec3(p,fl) );\n    return normalize(rd);\n}\n\n#define GRASS0 vec3(.1, 1.2, .3)\n#define GRASS1 vec3(.4, .8, .1)\n#define GRASS2 vec3(.02, .5, .1)\nvec3 getGround(vec3 ray, float skyTime)\n{\n    vec3 color;\n    if (skyTime < .5) {\n        color = mix(GRASS0, GRASS1, skyTime * 2.);\n    } else {\n        color = mix(GRASS1, GRASS2, (skyTime - .5) * 2.);\n    }\n    vec2 tc = (ray.xz - camera.xz) / (ray.y - .1) * .15; //texture coord\n    return texture(iChannel1, tc).r * color;\n}\n\n//stolen from https://www.shadertoy.com/view/Xlf3Rj\nfloat terrain(float x) {\n\tfloat w=0.;\n\tfloat a=1.;\n\tw+=sin(x*.3521)*4.;\n\tfor (int i=0; i<5; i++) {\n\t\tx=x*1.53562+22.1091;\n\t\tw+=sin(x)*a;\t\t\n\t\ta*=.5;\n\t}\n\treturn .2+w*.015;\t\n}\n\nvec4 getMountains(vec3 ray, float skyTime)\n{\n    vec2 pos = ray.xy * -2.;\n    float t = terrain(pos.x * 25.);\n    #ifdef MOUNTAINS_AA\n      float s = smoothstep(0.,.0025,pos.y+t);\n    #else\n      float s=step(0.,pos.y+t);\n    #endif\n    float m = texture(iChannel3, pos.xy).g + \n        texture(iChannel3, pos.xy * 2.).r * .5;\n    float py = pos.y * 5.-t;\n    vec3 color;\n    if (skyTime < .5) {\n        //color = mix(vec3(1.), vec3(1.,.7,.7), skyTime * 2.);\n        color = vec3(1.) - vec3(0.,.33,.3) * skyTime * 2.;\n    } else {\n        color = mix(vec3(1.,.67,.67), vec3(.4,.4,.5), (skyTime - .5) * 2.);\n    }\n    \n    vec3 col = vec3(.03, .17, .26) + color * (m * py * py);\n    return vec4(col, s);\n}\n\n#define STAR_LAYERS 3\nvec3 stars(vec2 uv)\n{\n    vec2 uvm = (1. + uv) * 192.; //initial cell size, furthest layer\n    float sm = .35; //layer brightness\n    float ex = -32.; //inverse sharpness\n    vec3 result = vec3(0.);\n    for (int i = 0; i < STAR_LAYERS; i++) \n    {\n        vec4 samp = texelFetch(iChannel1, ivec2(uvm) % 256, 0);\n        float star = length(fract(uvm) - .5 - (samp.rg - .5) * .9);\n        float t = exp(ex * star) * samp.a * sm;\n        result += (samp.rgb + 1.25) * t;\n        uvm *= .25;\n        sm *= 3.;\n        ex *= 2.5;\n    }\n    //return pow(star, 40.);\n    //return smoothstep(.98, 1., star);\n    return min(result, 1.);\n}\n\n#define SKY_HI0 vec3(0., .3, 1.)\n#define SKY_LO0 vec3(.6, .8, 1.)\n#define SKY_HI1 vec3(.3, .15, .4)\n#define SKY_LO1 vec3(1., .1, .4)\n#define SKY_HI2 vec3(0)\n#define SKY_LO2 vec3(.01, .02, .03)\nvec3 getSky(vec3 ray, float skyTime)\n{\n    vec3 skyHi, skyLo;\n    if (skyTime < .5) {\n        skyHi = mix(SKY_HI0, SKY_HI1, skyTime * 2.);\n        skyLo = mix(SKY_LO0, SKY_LO1, skyTime * 2.);\n    } else {\n        skyHi = mix(SKY_HI1, SKY_HI2, (skyTime - .5) * 2.);\n        skyLo = mix(SKY_LO1, SKY_LO2, (skyTime - .5) * 2.);\n    }\n    vec3 sky = mix(skyLo, skyHi, ray.y * 3.);\n    if (skyTime > .5) sky = mix(sky, vec3(stars(ray.xy)), (skyTime - .5) * 2.);\n    return sky;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat bird(vec2 p) {\n\tp.y+=pow(abs(p.x),2.)*20.*(.2+sin(iTime*20.));\n\tfloat s=step(0.003-abs(p.x)*.1,abs(p.y));\t\n\treturn min(s,step(0.005,length(p+vec2(0.,.0015))));\n}\n\n//ray pos, object pos\nvec4 renderShot(vec3 rp, vec4 op)\n{\n    vec4 rgba;\n    vec2 drp = op.xy - rp.xy;\n    float odist = length(op.xyz);\n    float drpd = length(drp);\n    #if SHOT_TYPE == 3\n      float bs;\n      if (op.a == 1.)\n          bs = 5.;\n      else { //bird boom\n          bs = op.a - 1.;\n          bs = sqrt(bs) * 10.;\n          }\n    #else\n      float bs = (odist * BULLET_SPREAD + BULLET_SIZE);\n    #endif\n    float dist = drpd - bs;\n    if (dist < 0.) {\n      #if SHOT_TYPE == 3 // bird shot\n        if (op.a == 1.) {\n            float b = bird(drp * -.025);\n            vec3 bc = vec3(dot(drp,drp));\n            rgba = vec4(bc, 1. - b);\n        } else {\n            float pa1 = op.a - .75;\n            float samp_size = pa1 * pa1 * 200.; //calc expanding texture\n            float sm = (cos(drpd / (op.a * 5.))); //compress texture at edges to look like ball\n            vec2 offs = vec2(0., pa1 * .02); //texture begins rising after some time\n            vec2 texpos = drp / (samp_size * sm) + offs; //calc final texture pos\n            float pat1 = textureLod(iChannel1, texpos, 0.).r; //low texture\n            float pat2 = pat1 + textureLod(iChannel1, texpos * 2., 0.).r * .5\n               + textureLod(iChannel1, texpos * 4., 0.).r * .25;\n            float fade = 2.5 - op.a; //fadeout over time\n            float a = (dist * -.5 / op.a); //fade toward edges\n            a = min(1.,(a + pat1) * a); //multiply by low texture to give billowed edges\n            vec3 col = fireColor(pat2 * fade); //high texture for color\n            rgba = vec4(col, clamp(a * (.2+fade), 0., 1.)); //apply alpha\n        }\n      #elif SHOT_TYPE == 0 //slug\n        float fade = (odist * .02 + .01);\n        rgba = vec4(vec3(1.), 1. / fade);        \n      #else //normal shot\n        vec4 tex = textureLod(iChannel3, drp * 30. / odist, 0.);\n        float pat = step(.3 + odist * .0035,tex.r);\n        //pat = step(1.- 1. / odist, pat);\n        //pat = pow(pat, 1.+sqrt(odist));\n        //pat *= pat * pat;\n        float a = dist * -15.;//sqrt(dist * -3.);\n        //float fade = .5;// (odist * odist + .01);\n        rgba = vec4(vec3(.8), clamp(pat * a, 0., 1.));        \n      #endif\n    }\n    return rgba;\n}\n\nvec4 renderSkeet(vec3 rp, vec4 p, int index)\n{\n    vec4 rgba;\n    float s_size;\n    if (p.a > 1.) { //skeet is exploding\n        s_size = (p.a - 1.) * 20. + 1.;\n    } else\n        s_size = 1.;\n\n    vec3 drp = rp - p.xyz;\n    //#if GAME_TYPE == 3\n    //  float dist = sdSphere(drp, SKEET_SIZE);\n    //#else\n      float dist = sdEllipsoid(drp, skeetShape * s_size);\n    //#endif\n    if (dist < 0.) {\n      /*\n      #if GAME_TYPE == 3\n        float alpha = sign(-dist);\n        float cl = cos(drp.y*2.3);\n        float m = drp.x * 2. / sqrt(abs(cl));\n        vec3 col = bbc[int(mod((m+(iTime+float(index))*2.),6.))];\n        rgba = vec4(col, alpha);       \n      #else\n      */\n        if (p.a > 1.) {\n            float w = textureLod(iChannel3, drp.xy * 3. / s_size, 0.).r;\n            float fadeout = max(0., 1. - (p.a - 1.));\n            dist = length(drp.xy * vec2(1., 2.4));\n            float alpha = (w * w) * fadeout / (.15 + dist * dist);\n            if (drp.y > 0.)\n                rgba = vec4(SKEET_COLOR0,alpha);\n            else\n                rgba = vec4(SKEET_COLOR1,alpha);\n        } else {\n          float dy = drp.y * (3. / SKEET_SIZE) - (p.y / p.z) * (1.-drp.x*drp.x*(2. / SKEET_SIZE));\n          #ifdef OBJ_AA\n            float alpha = clamp(dist * -40.,0.,1.);\n            vec3 col = mix(SKEET_COLOR0, SKEET_COLOR1, clamp(dy * -10. + .5,0.,1.));\n            rgba = vec4(col,alpha);\n          #else\n            float alpha = sign(-dist);\n            rgba = vec4(dy > 0. ? SKEET_COLOR0 : SKEET_COLOR1, alpha);\n          #endif\n        }\n      //#endif\n    }\n    return rgba;\n}\n\nvec3[] camoPat = vec3[] (vec3(0.54, 0.49, 0.22), vec3(0.32, 0.22, 0.04), vec3(0.24, 0.31, 0.08),\n    vec3(0.18, 0.1, 0), vec3(0.));\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int[16] buf;\n\n    //get game data\n    //vec4 roundState = getVar(ROUND_STATE);\n    vec4 gameState = getVar(GAME_STATE);\n    vec4 frameData = getVar(FRAME_DATA);\n    int curPlayer = int(gameState.y);\n    if (gameState.x == GS_ENDRND) {\n        curPlayer--;\n        if (curPlayer == -1) { curPlayer = NUM_PLAYERS - 1; gameState.a--; }\n    }\n    vec4 scoreState = getVar(SCORE_INDEX + curPlayer);\n    numSkeet = int(frameData.x);\n    float skyTime = float(gameState.a) / float(TOTAL_GAMES);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 ray = getRay(fragCoord, iResolution.xy);\n    //vec3 ray = getRayIq(fragCoord);\n    //fragColor = vec4(fract(ray * 10.), 1.);\n    //return;\n    \n    //render background\n    if (ray.y < 0.) {\n        fragColor.xyz = getGround(ray, skyTime);\n    }\n    else {\n        fragColor.xyz = getSky(ray, skyTime);\n        vec4 m = getMountains(ray * 2. + vec3(.1,-.09,0.), skyTime);\n        m.a *= .5;\n        vec4 m2 =getMountains(ray, skyTime);\n        m = mix(m,m2,m2.a);\n        fragColor.xyz = mix(fragColor.xyz, m.xyz, m.a);\n    }\n    \n    //intro text\n    if (iTime < 2. && gameState.x == GS_WAITSTART) {\n        float fontSize = iResolution.y * .3;\n        SET_WORD4(buf,_C,_L,_A,_Y);\n        float k = drawTextScaled(DISPLAY, buf, 4, fontSize, \n            iResolution.xy * (vec2(.5 - fontSize / iResolution.x * 1.15,.25)));\n        SET_WORD(buf, int[] (_S,_H,_O,_O,_T,_E,_R), 7);\n        k += drawTextScaled(DISPLAY, buf, 7, fontSize, \n            iResolution.xy * (vec2(.5 - fontSize / iResolution.x * 1.85,.48)));\n        \n        /*\n        //gradient text\n        const vec4 grad2 = vec4(0.,1.,1.,1.);\n        const vec4 grad1 = vec4(.7, 0., 1., 1.);\n        float m = sin(ray.y * 22.);\n        fragColor = mix(fragColor, mix(grad2,grad1,m*m), k);\n        */\n        /*\n        //fire text\n        vec2 uv2 = uv - vec2(0., iTime * .1);\n        float m = textureLod(iChannel1, uv2 * .25, 0.).r + \n            textureLod(iChannel1, uv2 * .5, 0.).r * .5 + \n            textureLod(iChannel1, uv2, 0.).r * .25;\n        vec3 col = fireColor(m * 1.5);\n        fragColor = mix(fragColor, vec4(col,1.), k);\n        */\n        //camo text\n        vec2 uv2 = uv - vec2(.015,.01) * iTime;\n        float m = textureLod(iChannel1, uv2 * .125, 0.).r\n            + textureLod(iChannel1, uv2 * .25, 0.).r * .5;\n            //+ textureLod(iChannel1, uv2 * .5, 0.).r * .25;\n        vec3 col = camoPat[int(m * 5.) % 5];\n        fragColor = mix(fragColor, vec4(col,1.), k);\n\n        //outline\n        k = (k - k * k) * 3.;\n        fragColor = mix(fragColor, vec4(0.,0.0,0.,1.), k);\n        return;\n    }\n    \n    if (gameState.x == GS_WAITSTART) //wait for user to click to begin\n    {\n        SET_WORD6(buf,_P,_L,_A,_Y,_E,_R);\n        float fontSize = iResolution.y * .15;\n        float k = drawTextScaled(DISPLAY, buf, 6, fontSize,\n            iResolution.xy * (vec2(.5 - fontSize / iResolution.x * 1.9, .25)));\n        buf[0] = CHAR_0 + curPlayer + 1;\n        k += drawTextScaled(DISPLAY, buf, 1, fontSize,\n            iResolution.xy * (vec2(.5 + fontSize / iResolution.x * 1.25, .25)));    \n        fragColor = mix(fragColor, vec4(1.), k);\n        SET_WORD5(buf,_S,_T,_A,_R,_T);\n        fontSize = iResolution.y * .3;\n        k = drawTextScaled(DISPLAY, buf, 5, fontSize, iResolution.xy * (vec2(.5 - fontSize / iResolution.x * 1.25,.35)));\n        fragColor = mix(fragColor, vec4(0.,0.0,0.,1.), k * 2.);\n        fragColor = mix(fragColor, vec4(1.,0.1,0.,1.), k);\n        return;\n    } else if (gameState.x == GS_GAMEOVER) //---display game over screen----\n    {\n        SET_WORD4(buf,_G,_A,_M,_E);\n        float fontSize = iResolution.y * .15;\n        float k = drawTextScaled(DISPLAY, buf, 4, fontSize,\n            iResolution.xy * (vec2(.5 - fontSize / iResolution.x * 2., .1)));\n        SET_WORD4(buf,_O,_V,_E,_R);\n        k += drawTextScaled(DISPLAY, buf, 4, fontSize,\n            iResolution.xy * (vec2(.5 + fontSize / iResolution.x * .2, .1)));\n        //note: plId must be float otherwise weird shit happens\n        float plOffs = floor(iResolution.y / 128.) - 1.;\n        float plId = floor((iResolution.y - fragCoord.y) / 64.) - plOffs;\n        //int plId = int((1. - uv.y) * 7.) - 2;\n        int scorePos = int(iResolution.x / 64.) - 6;\n        int lineNo = int(plId + plOffs);\n        if (plId > -1. && plId < float(NUM_PLAYERS))\n        {\n            SET_WORD6(buf,_P,_L,_A,_Y,_E,_R);\n            k += drawText(DISPLAY, buf, 6, ivec2(scorePos, lineNo));\n                //iResolution.xy * (vec2(.5 - fontSize / iResolution.x * 2.8, uvy)));\n            buf[0] = CHAR_0 + int(plId) + 1;\n            k += drawText(DISPLAY, buf, 1, ivec2(scorePos + 7, lineNo));\n                //iResolution.xy * (vec2(.5 + fontSize / iResolution.x * .5, uvy)));   \n            buf[0] = 0x3A;\n            k += drawText(DISPLAY, buf, 1, ivec2(scorePos + 8, lineNo));\n                //iResolution.xy * (vec2(.5 + fontSize / iResolution.x * .85, uvy)));\n            scoreState = getVar(SCORE_INDEX + int(plId));\n            #if GAME_TYPE == 2\n              int score = int(scoreState.x * 2. - scoreState.y);\n            #else\n              int score = int(scoreState.w);\n            #endif\n            k += printInt(DISPLAY, score, ivec2(scorePos + 10, lineNo));\n        }\n\n        fragColor = mix(fragColor, vec4(1.), k);\n        return;\n    }\n    //render each object from furthest to nearest\n    vec4 bullet = getVar(BULLET_STATE);\n    float endDist = 999.;\n    for (int i = 0; i <= numSkeet; i++)\n    {\n        vec3 rp, crp;\n        vec4 pos;\n        int sidx = -1;\n        float dist;\n        float cDist = 0.;\n        vec4 spos;\n        //test bullet\n        pos = bullet;\n        dist = length(pos.xyz - camera);\n        if (pos.a > 0. && dist < endDist) { //start with bullet pos if it's alive\n            spos = pos;\n            cDist = dist;\n            sidx = 0;\n        }\n        //test skeet\n        for (int j = 0; j < numSkeet; j++)\n        {\n            pos = getVar(SKEET_INDEX + j * 2);\n            if (pos.a > 0.) { //obj is alive\n                dist = distance(pos.xyz, camera);\n                //figure out which one to render - furthest one that is closer than last rendered\n                if (dist > cDist && dist < endDist) {\n                    spos = pos;\n                    cDist = dist;\n                    sidx = j + 1;\n                }\n            }\n        } //next obj\n        //render the chosen one\n        if (cDist > 0.) {\n            vec3 rp = ray * cDist + camera;\n            vec4 color;\n            if (sidx == 0) {\n                color = renderShot(rp, spos);\n            } else {\n                color = renderSkeet(rp, spos, sidx);\n                #ifdef ENABLE_TRAINER\n                  vec4 sv = getVar(SKEET_INDEX + (sidx - 1) * 2 + 1);\n                  float it = cDist / BULLET_SPEED; //impact time\n                  sv += (SKEET_DRAG * length(sv.xyz) - BULLET_DRAG * BULLET_SPEED) * it * .5; //compensate drag\n                  sv.y -= (GRAVITY - 9.78) * it * .5; //compensate gravity\n                  vec3 tp = spos.xyz + sv.xyz * it; //project position\n                  vec3 mp = tp / vec3(1.025, 1.035,1.); //compensate distance compensation\n                  float td = distance(ray * distance(mp, camera) + camera, mp);\n                  if (abs(td - .1) < .02)\n                      color = vec4(1.,0.,0., 1.);\n                #endif\n            }\n            fragColor.rgb = mix(fragColor.rgb, color.rgb, color.a);\n            endDist = cDist;\n        } else { break; } //no more objects to render\n    } //next i\n    \n    //render some text\n    #if GAME_TYPE == 2\n      int score = int(scoreState.x * 2. - scoreState.y);\n    #else\n      int score = int(scoreState.a);\n    #endif\n    //write \"SCORE:\"\n    SET_WORD6(buf,_S,_C,_O,_R,_E,0x3A);\n    float text = drawText(DISPLAY, buf, 6, ivec2(0,0));\n    text += printInt(DISPLAY, score, ivec2(7,0));\n    #if GAME_TYPE == 3\n      SET_WORD6(buf,_B,_O,_N, _U, _S, 0x3A);\n      text += drawText(DISPLAY, buf, 6, ivec2(0,1));\n      text += printInt(DISPLAY, int(scoreState.x+1.), ivec2(6,1));\n      buf[0] = _X; text += drawText(DISPLAY, buf, 1, ivec2(8,1));\n      text += printInt(DISPLAY, numSkeet, ivec2(9,1));\n    #else\n      SET_WORD5(buf,_A,_C,_C,37,0x3A);\n      text += drawText(DISPLAY, buf, 5, ivec2(0,1));\n      text += printInt(DISPLAY, int(scoreState.x / scoreState.y * 100.), ivec2(5,1));\n    #endif \n  #if GAME_TYPE > 1 //print round timer\n    if (gameState.x == GS_PLAY) {\n        float tr = frameData.w - iTime;\n        text += printInt(DISPLAY, int(tr), ivec2(0,2));\n        buf[0] = 0x3A;\n        text += drawText(DISPLAY, buf, 1, ivec2(2,2));\n        text += printInt(DISPLAY, int(fract(tr)*60.), ivec2(3,2));\n    }\n  #endif\n    //text += printInt(DISPLAY, numSkeet, ivec2(0,3)); //hits\n    //text += printInt(DISPLAY, int(scoreState.y), ivec2(4,3)); //shots\n    //text += printInt(DISPLAY, int(scoreState.z), ivec2(8,3)); //missed\n    fragColor = mix(fragColor, vec4(1.), text);\n    \n    /*\n    vec4 b = getVar(BULLET_STATE);\n    vec4 d = getVar(SKEET_INDEX + 1);\n    vec4 p = getVar(SKEET_INDEX);\n    vec4 fs = getVar(FRAME_DATA);\n    float dt = iTime - fs.x;\n    //float dist1 = pToL(p.xyz, b.xyz, d.xyz * dt); //point-to-line distance\n    //float dist2 = b.a;\n    //float dist2 = length(p.xyz-b.xyz); //point to point distance\n    //print position\n    float k = printFloat(DISPLAY, p.x, ivec2(9,0));\n    k += printFloat(DISPLAY, p.y, ivec2(9,1));\n    k += printFloat(DISPLAY, p.z, ivec2(9,2));\n    k += printFloat(DISPLAY, p.a, ivec2(9,3));\n    //print bullet pos\n    //v = getVar(BULLET_STATE + 1);\n    k += printFloat(DISPLAY, d.x, ivec2(18,0));\n    k += printFloat(DISPLAY, d.y, ivec2(18,1));\n    k += printFloat(DISPLAY, d.z, ivec2(18,2));\n    k += printFloat(DISPLAY, d.a, ivec2(18,3));\n    //print dist\n    //k += printFloat(DISPLAY, dist1, ivec2(4,4));\n    //k += printFloat(DISPLAY, dist2, ivec2(4,5));\n\n    if (k > 0.) fragColor =mix(fragColor, vec4(1.), k);\n    */\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//defs for var pointers\n#define varCurPlayer gameState.y\n#define varRoundNum gameState.z\n#define varNumSkeet frameData.x\n#define varLaunchTime frameData.w\n\n#if GAME_TYPE == 1\n  ivec2 rndGame = ivec2(0);\n#endif\n\nint[] NUM_SKEET_SPORT = int[] (1,1,1,2,2,2,3,3,3,3,4);\nint[] NUM_SKEET_GOLF = int[] (1,2,1,2,3,2,4,3,4);\n\n//please disregard the following mess\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (int(fragCoord.y) == 0) {\n        int idx = int(fragCoord.x);\n        \n        //get all the variables we will need\n        vec4 frameData = getVar(FRAME_DATA);\n        vec4 gameState = getVar(GAME_STATE);\n        int curPlayer = int(gameState.y);\n        vec4 scoreState = getVar(SCORE_INDEX+curPlayer);\n        vec4 bullet = getVar(BULLET_STATE);\n        vec4 bullet_vel = getVar(BULLET_VEL);\n        //handle game state\n        if (gameState.x == GS_WAITSTART)\n        {\n            if (iMouse.z > 0.) // user clicked down, so wait for release\n                gameState.x = GS_WAITCLK;\n            if (idx == GAME_STATE)\n                fragColor = gameState;\n            else if (idx < SKEET_INDEX) //reset all skeet states to 0\n                fragColor = getVar(idx);\n            return;\n        } else if (gameState.x == GS_WAITCLK)\n        {\n            if (iMouse.z < 0.) { // user unclicked, so begin game\n                gameState.x = GS_PLAY; varRoundNum = -1.;\n                #if GAME_TYPE == 1\n                  if (rndGame == ivec2(0)) rndGame = ivec2(iMouse.xy); //initialize random game\n                #endif\n            }\n            if (idx == GAME_STATE)\n                fragColor = gameState;\n            else\n                fragColor = getVar(idx);\n            return;\n        } else if (gameState.x == GS_ENDRND)\n        {\n            if (iTime > varLaunchTime) {\n                gameState.x = GS_WAITSTART;\n            }\n            if (idx == GAME_STATE)\n                fragColor = gameState;\n            else if (idx > BULLET_VEL)\n                fragColor = getVar(idx);\n            return;\n        } else if (gameState.x == GS_GAMEOVER)\n        {\n            if (idx > BULLET_STATE && idx < SKEET_INDEX)\n                fragColor = getVar(idx);\n            return;\n        }\n        int roundNumber = int(varRoundNum);\n        int numSkeet = int(varNumSkeet);\n        \n        //check if this is a launch frame\n        #if GAME_TYPE > 1\n            bool doLaunch = iTime > varLaunchTime;\n        #else\n            bool doLaunch = true;\n            if (numSkeet > 0) {\n            for (int i = 0; i < numSkeet; i++)\n            {\n                vec4 sk = getVar(i * 2 + SKEET_INDEX);\n                if (sk.w > 0. && sk.y > 0.) { doLaunch = false; break; }\n            } }\n        #endif\n        if (doLaunch) { //set number of skeet for this round\n            #if GAME_TYPE == 0 //sport rules\n              if (roundNumber < TOTAL_ROUNDS)\n                  numSkeet = NUM_SKEET_SPORT[int(gameState.z)];\n              else\n                  numSkeet = 0;\n            #elif GAME_TYPE == 1 //golf rules\n              if (roundNumber < TOTAL_ROUNDS)\n                  numSkeet = int(texelFetch(iChannel1, \n                      rndGame + ivec2(roundNumber, int(gameState.w)) % 256, 0).r * 3.99 + 1.);\n              else\n                  numSkeet = 0;\n            #else //speed scoring, juggling rules\n                numSkeet = int(gameState.w) + 1;\n            #endif\n        }\n        if (idx >= numSkeet * 2 + SKEET_INDEX) { fragColor = vec4(0.); return; }\n\n        //compute sum stuff\n        float dt = iTimeDelta;\n        int rounds = int(frameData.y);\n        bool doShot = (iMouse.z > 0.) && (iTime > frameData.z) && (rounds > 0);\n        float rnd = hash(iTime + iMouse.x + iMouse.y + float(idx/2) * 7.363);\n        float rndDir = sin(rnd*6.28);\n        float bs = BULLET_SIZE + length(bullet.xyz) * BULLET_SPREAD + SKEET_SIZE;\n\n        if (idx >= SKEET_INDEX)\n        {   //update mobs\n            vec4 pos, vel;\n            if ((idx&1)==0) {\n                //update position\n                pos = getVar(idx); vel = getVar(idx + 1);\n                \n                if (pos.w > 0. && pos.y > 0.) //mob is alive\n                {\n                  #if GAME_TYPE != 3\n                    //check for contact w/ bullet\n                    if (bullet.w > 0. && pos.w == 1. &&\n                      testHit(pos.xyz, bullet.xyz, bullet_vel.xyz * dt, bs))  {\n                        pos.w = 1.02;\n                    }\n                    else if (pos.w > 1.) { //test if mob is in decay state\n                        pos.w += dt; //increase state value to show clay breaking apart\n                        if (pos.w > 2.) pos.w = 0.; //dead, 1 second after being hit\n                    }\n                  #endif\n                  pos.xyz += vel.xyz * dt;\n                }\n                #if GAME_TYPE > 1\n                  else doLaunch = true;\n                #endif\n                //check if it's time to launch another\n                if (doLaunch)\n                {\n                  #if GAME_TYPE == 3\n                    pos = vec4(rndDir * 3., .25, 10., 1.);\n                  #else\n                    pos = vec4(rndDir * 10., .25, 5., 1.); //launch pos\n                  #endif\n                }\n                fragColor = pos; return;\n            } else { //update skeet velocity\n                vel = getVar(idx); //pos = getVar(idx-1);\n                vel.y -= GRAVITY * dt;\n                vel -= SKEET_DRAG * vel * abs(vel) * dt;\n                #if GAME_TYPE == 2 //if game mode is time trial, automatically relaunch if it's dead\n                    pos = getVar(idx - 1);\n                    if (pos.w == 0. || pos.y <= 0.) doLaunch = true;\n                #elif GAME_TYPE == 3 //if game mode is juggle, then test for hit and bounce skeet\n                    pos = getVar(idx - 1);\n                    if (pos.y <= 0.) \n                    {   doLaunch = true; \n                    } else {\n                        if (bullet.a == 1. && testHit(pos.xyz, bullet.xyz, bullet_vel.xyz * dt, bs))  {\n                            //calculate which direction to bound\n                            //float bp = pos.x - lAtP(pos.xyz, bullet.xyz, bullet_vel.xyz).x;\n                            float bp = pos.x - (bullet.x + bullet_vel.x * dt);\n                            vel.xyz = vec3(bp * 5., vel.y*-.9 + 3., vel.z);\n                        }\n                    }\n                #endif\n                if (doLaunch) //launch another\n                {\n                    #if GAME_TYPE == 3 //special launch speed for juggle mode\n                      vel = vec4( normalize(  //launch velocity\n                        vec3(rndDir * -.25, hash((iTime+float(idx))*1.5163) * 1.25 + 1., .3) )\n                        * 10., 0.);\n                    #else\n                      vel = vec4( normalize(  //launch velocity\n                        vec3(rndDir * -.7, hash((iTime+float(idx))*1.5163) * 1.25 + 1., 2.5) )\n                        * LAUNCH_SPEED, 0.);\n                    #endif\n                }                   \n                fragColor = vel; \n            }\n        } else if (idx < FRAME_DATA) //update bullet\n        {   \n            if ((idx)==0) { //update position\n                #if GAME_TYPE == 3 //juggle game\n                  //need to disable bullet after initial hit, otherwise it may be counted twice\n                  if (bullet.w > 0.) {\n                      for (int i = 0; i < numSkeet; i++) {\n                          vec4 pos = getVar(i * 2 + SKEET_INDEX);\n                          if (testHit(pos.xyz, bullet.xyz, bullet_vel.xyz * dt, bs))  {\n                              bullet.w = 0.; //disable bullet after hit\n                          }\n                      }\n                  }\n                #endif\n                bullet += bullet_vel * dt;\n                //check if we need to shoot another bullet\n                if (doShot)\n                {\n                    bullet = vec4(0., 1.75, 1., 1.); //start pos\n                }\n                fragColor = bullet;\n            } else { //update velocity\n              #if SHOT_TYPE == 3 //check for impact, set vel.w to 1. to make bird explode\n                if (bullet.w == 1.) {\n                    //float bl = BULLET_SIZE + length(bullet.xyz) * BULLET_SPREAD + SKEET_SIZE;\n                    for (int i = 0; i < numSkeet; i++) {\n                        vec4 pos = getVar(i * 2 + SKEET_INDEX);\n                        if (pos.w == 1.02) //any skeet was impacted last frame\n                        { bullet_vel.w = 1.; //set bird to go boom\n                          bullet_vel.xyz *= .75;\n                        }\n                    }\n                }\n                if (bullet.w > 1.) bullet_vel.y += 5. * dt; //explosion drifting upwards\n                else if (bullet.w == 1.) bullet_vel += normalize(bullet_vel) * BULLET_ACCEL;\n              #else //normal shot\n                bullet_vel.y -= 9.78 * dt;\n                bullet_vel -= BULLET_DRAG * bullet_vel * dt; //drag increases with speed\n              #endif\n                //check if we need to shoot another bullet\n                if (doShot)\n                {\n                    vec3 ray = getRay(iMouse.xy, iResolution.xy);\n                    ray.xy *= vec2(1.025, 1.035); //compensate for distance\n                  #if SHOT_TYPE != 3\n                    ray.y += 1.5 / BULLET_SPEED; //compensate for gravity\n                  #endif\n                    //float yy = ray.y - .3;\n                    //ray.xy *= (1. + (ray.x * ray.x + yy * yy));\n                    //ray = normalize(ray);\n                    bullet_vel = vec4(ray * BULLET_SPEED, 0.); //start pos, start time\n                }\n                fragColor = bullet_vel;\n            }\n        } else if (idx == FRAME_DATA) //last frame time, shots remaining, time to next shot, time for next launch\n        {\n            if (doShot) {\n                frameData.z = iTime + SHOT_COOLDOWN; //reset shot timer\n                rounds = rounds - 1; //lose a round\n            }\n            if (doLaunch) {\n              #if GAME_TYPE > 1\n                rounds = 600;\n              #else\n                rounds = 6;\n              #endif\n                if (roundNumber < TOTAL_ROUNDS - 1)\n                    varLaunchTime = iTime + LAUNCH_INTERVAL;\n                else\n                    varLaunchTime = iTime + 1.5; //set delay before next player can start\n            }\n            varNumSkeet = float(numSkeet);\n            frameData.y = float(rounds);\n            fragColor = frameData;\n            \n        } else if (idx == GAME_STATE)//game state, current player, current round #, current game #\n        {\n            if (doLaunch) {\n                roundNumber++;\n                if (roundNumber >= TOTAL_ROUNDS) { //this round finished\n                    curPlayer++; //next player\n                    if (curPlayer < NUM_PLAYERS) //reset game state for next player\n                    {\n                        gameState.x = GS_ENDRND; //set gamestate to delay before restart\n                    } else { //move to next game\n                        gameState.w++; //increment game #\n                        if (gameState.w >= float(TOTAL_GAMES)) { //end of play\n                            gameState.x = GS_GAMEOVER;\n                        } else\n                            gameState.x = GS_ENDRND;\n                        curPlayer = 0;\n                    }\n                    varCurPlayer = float(curPlayer);\n                }\n                varRoundNum = float(roundNumber);\n            } else {\n\n            }\n            fragColor = gameState;\n            \n        } else if (idx == SCORE_INDEX + curPlayer) //total hits, total shots, total missed skeet, final score\n        {\n            if (doShot) scoreState.y++; //increment shots\n            if (doLaunch) {\n                //apply score\n                #if GAME_TYPE == 0 //sport rules\n                    float score = scoreState.x;\n                #elif GAME_TYPE == 1 //golf rules\n                    //count missed skeet\n                    for (int i = 0; i < 4; i++) {\n                        vec4 pos = getVar(i * 2 + SKEET_INDEX);\n                        if (pos.w == 1.) scoreState.z++;\n                    }\n                    float score = scoreState.y + scoreState.z - scoreState.x;\n                #elif GAME_TYPE == 2 //time trial\n                    float score = scoreState.x * 2. - scoreState.y;\n                #elif GAME_TYPE == 3 //juggling\n                    float score = scoreState.w;\n                #endif\n                scoreState.w = score;\n            } else {\n              #if GAME_TYPE == 3\n                for (int i = 0; i < numSkeet; i++) {\n                    vec4 pos = getVar(i * 2 + SKEET_INDEX);\n                    if (pos.y < 0.) { scoreState.x = 0.; }\n                    else if (pos.w > 0. && bullet.w > 0. && testHit(pos.xyz, bullet.xyz, bullet_vel.xyz * dt, bs)) {\n                        scoreState.x++;\n                        scoreState.w += scoreState.x * float(numSkeet); //increment score\n                    }\n                }\n              #else\n                for (int i = 0; i < numSkeet; i++) {\n                    vec4 pos = getVar(i * 2 + SKEET_INDEX);\n                    if (pos.w == 1.02) //skeet <a> will be this value for exactly 1 frame\n                        scoreState.x++; //increment hits\n                }\n              #endif\n            }\n            fragColor = scoreState;\n        } else { //preserve other score states\n            fragColor = getVar(idx);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//game settings\n#define NUM_PLAYERS 1 // 1-4 players\n#define GAME_TYPE 0 // 0 = sport, 1 = golf, 2 = time trial, 3 = skeet juggling\n#define SHOT_TYPE 1 // 0 = slug, 1 = buckshot, 2 = skeet shot, 3 = bird shot\n//#define ENABLE_TRAINER //shows you where to shoot. turn this on if you find it difficult to get the hang of it.\n\n/* ---How to play---\nClick the screen to start. Clays will be automatically launched. Click the screen to shoot\nin that direction. Remember to lead your target.\n\nEach game consists of a number of rounds. Players rotate at the end of each round.\nFinal scores are displayed at the end of the game. Restart the shader to start a new game.\n\n---Game Rules---\nSPORT: 25 total skeet are launched each round, with number of skeet per launch increasing throughout.\n    Your score for the round is the total number of skeet hit at the end of round. 25 is a perfect score.\n    There are 4 rounds, for a max score of 100.\n    \nGOLF: There are 9 launches per round. Par for each launch is the number of skeet launched.\n    The number of skeet per launch is random each round, but will be the same for each player.\n    You earn -1 point for each skeet hit, and penalized +1 point for each shot taken. \n    Any skeet that hit the ground will be added to the score penalty.\n    Three rounds are played, and final scores tallied at end of game. Lowest score wins.\n    \nTIME TRIAL: 4 rounds, 30 seconds per round. Try to hit as many skeet as you can. When a skeet is hit or lands\n    on the ground, a new one is immediately launched. Number of skeet in the air increase with each round.\n    You get 1 point for each skeet hit, and lose a point for each missed shot.\n    Players rotate each round. High score at the end wins.\n    \nJUGGLING: Three 45-second rounds. Keep the clay bouncing in the air as long as possible. Score bonus is increased\n    for each additional hit until it hits the ground. Number of active skeet increases each round,\n    but so does the bonus multiplier.\n*/\n\n//physics settings\n#define SKEET_DRAG vec4(.01, .03, .01, 0.) //atmospheric drag\n#define LAUNCH_SPEED 23. //(increased from realistic to compensate for camera zoom)\n\n//game parameters\n#if GAME_TYPE == 0 //sport mode\n    #define SKEET_COLOR0 vec3(1.,.4,0.)\n    #define SKEET_COLOR1 vec3(0.)\n    #define TOTAL_ROUNDS 11\n    #define TOTAL_GAMES 4\n    #define LAUNCH_INTERVAL 6.\n    #define SHOT_COOLDOWN .6\n    #define GRAVITY 3.\n    #define SKEET_SIZE .33 //(realistic is .11)\n#elif GAME_TYPE == 1 //gold mode\n    #define SKEET_COLOR0 vec3(.9,.85,.8)\n    #define SKEET_COLOR1 vec3(.8,.8,.75)\n    #define TOTAL_ROUNDS 9\n    #define TOTAL_GAMES 4\n    #define LAUNCH_INTERVAL 6.\n    #define SHOT_COOLDOWN .6\n    #define GRAVITY 3.\n    #define SKEET_SIZE .33\n#elif GAME_TYPE == 2 //time trial\n    #define SKEET_COLOR0 vec3(1.,.75,.3)\n    #define SKEET_COLOR1 vec3(.5,.35,.1)\n    #define TOTAL_ROUNDS 1\n    #define TOTAL_GAMES 4\n    #define LAUNCH_INTERVAL 30.\n    #define SHOT_COOLDOWN .6\n    #define GRAVITY 3.\n    #define SKEET_SIZE .33\n#else //juggling\n    #define SKEET_COLOR0 vec3(.5,1.,.6)\n    #define SKEET_COLOR1 vec3(.4,.3,.5)\n    #define TOTAL_ROUNDS 1\n    #define TOTAL_GAMES 3\n    #define LAUNCH_INTERVAL 45.\n    #define SHOT_COOLDOWN .3\n    #define GRAVITY (9.78 - float(numSkeet) * 2.)\n    #define SKEET_SIZE .5\n#endif\n\n//variable indices\n#define BULLET_STATE 0\n#define BULLET_VEL 1\n#define FRAME_DATA 2 //skeet this round, shots remaining, time to next shot, time for next launch\n#define GAME_STATE 3 //game state, current player, current round #, current game #\n#define SCORE_INDEX 4 //total hits, total shots, total missed skeet, player score - (indices 5 - 8 correspond to up to 4 players)\n#define SKEET_INDEX 8\n\n//constants\n#define GS_WAITSTART 0.\n#define GS_WAITCLK 1.\n#define GS_PLAY 2.\n#define GS_ENDRND 3.\n#define GS_GAMEOVER 4.\n\n#if SHOT_TYPE == 0 //slug\n    #define BULLET_SPEED 350.\n    #define BULLET_SPREAD 0.0015 //realistically no spread for slug, but we'll make it a little easier\n    #define BULLET_DRAG .002\n    #define BULLET_SIZE 0.035\n#elif SHOT_TYPE == 1 //buck shot\n    #define BULLET_SPEED 140.\n    #define BULLET_SPREAD 0.0071 //1 meter spread @ 140m distance (realistic is 1/25 to 1/40)\n    #define BULLET_DRAG .005\n    #define BULLET_SIZE 0.0254\n#elif SHOT_TYPE == 2 //skeet shot\n    #define BULLET_SPEED 70.\n    #define BULLET_SPREAD 0.01428 //1 meter spread @ 70m distance (realistic is 1/25 to 1/40)\n    #define BULLET_DRAG .005\n    #define BULLET_SIZE 0.0254 //(about an inch, fairly realistic)\n#else //bird shot\n    #define BULLET_SPEED 33.\n    #define BULLET_SPREAD 0.\n    #define BULLET_SIZE 1.5\n    #define BULLET_ACCEL 1. //bird accelerates 1 m/s^2\n#endif\n\nconst vec3 FORWARD = vec3(0.,0.,1.);\nconst vec3 UP = vec3(0.,1.,0.);\nconst vec3 RIGHT = vec3(1., 0., 0.);\nconst vec3 camera = vec3(0., 2., 0.);\nconst vec3 lookDir = normalize(vec3(0.,.19,1.));\n\n//vec3 gameState, frameData, p1, dp1, p2, dp2, b, db;\n\n#define getVar(varIndex) texelFetch(iChannel0, ivec2(varIndex, 0), 0)\n\nfloat hash(float p) { p = fract(p * 0.319671); p *= p + 7.5; p *= p + p; return fract(p); }\n\nfloat pToL(vec3 v, vec3 a, vec3 ab)\n{\n    vec3 b = a + ab;\n    vec3 av = v - a;\n    if (dot(av, ab) <= 0.) return length(av);\n    vec3 bv = v - b;\n    if (dot(bv, ab) >= 0.) return length(bv);\n    \n    return length(cross(ab, av)) / length(ab);\n}\n\nvec3 lAtP(vec3 v, vec3 x1, vec3 x2x1)\n{\n    vec3 x2 = x1 + x2x1;\n    vec3 vx1 = v - x1;\n    \n    float t = dot(vx1,x2x1)/(x2x1.x * x2x1.x + x2x1.y * x2x1.y * x2x1.z * x2x1.z);\n    \n    return x1 + x2x1 * t;\n}\n\n#define testHit(p,x1,d,radius) pToL(p,x1,d)<radius\n\n// Helper function generating a rotation matrix around the axis by the angle\nmat3 createRotationMatrixAxisAngle(vec3 axis, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n  return mat3(\n    oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, \n    oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, \n    oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c\n  );\n}\n\n// Helper function that generates camera ray based on UV\nvec3 getRay(vec2 fragCoord, vec2 resolution) {\n  vec2 uv = ((fragCoord.xy / resolution.xy) * 2.0 - 1.0) * vec2(resolution.x / resolution.y, 1.0);\n  vec3 proj = normalize(vec3(uv.x, uv.y, 3.5)); //z-value = zoom (default 1.75)\n    //look forward\n    return \n        createRotationMatrixAxisAngle(RIGHT, lookDir.y)\n      //* createRotationMatrixAxisAngle(FORWARD, iTime)\n      * proj;\n}\n\nvec3 fireColor(float c)\n{\n    float g,b;\n    g = c - .75;\n    b = c - 1.5;\n    return vec3(c,g,b);\n}\n//------Text Rendering Stuff------\n//shortcut to letters, these are the character position in the \"Font 1\" texture\n#define _A 0x41\n#define _B 0x42\n#define _C 0x43\n#define _D 0x44\n#define _E 0x45\n#define _F 0x46\n#define _G 0x47\n#define _H 0x48\n#define _I 0x49\n#define _J 0x4A\n#define _K 0x4B\n#define _L 0x4C\n#define _M 0x4D\n#define _N 0x4E\n#define _O 0x4F\n#define _P 0x50\n#define _Q 0x51\n#define _R 0x52\n#define _S 0x53\n#define _T 0x54\n#define _U 0x55\n#define _V 0x56\n#define _W 0x57\n#define _X 0x58\n#define _Y 0x59\n#define _Z 0x5A\n#define CHAR_0 0x30\n#define CHAR_DOT 46\n#define SHIFT 32 //add to shift u-case to l-case\n\n//a few shortcuts for setting up to 6-letter words\n#define SET_WORD2(buf,a,b) buf[0]=a; buf[1]=b;\n#define SET_WORD3(buf,a,b,c) buf[0]=a; buf[1]=b; buf[2]=c;\n#define SET_WORD4(buf,a,b,c,d) buf[0]=a; buf[1]=b; buf[2]=c; buf[3]=d;\n#define SET_WORD5(buf,a,b,c,d,e) buf[0]=a; buf[1]=b; buf[2]=c; buf[3]=d; buf[4]=e;\n#define SET_WORD6(buf,a,b,c,d,e,f) buf[0]=a; buf[1]=b; buf[2]=c; buf[3]=d; buf[4]=e; buf[5]=f;\n#define SET_WORD(dest,src,cnt) for (int _i=0;_i<cnt;_i++) dest[_i]=src[_i];\n\n//draws text at the user-provided font size in pixels\nfloat drawTextScaled(sampler2D fontBuffer, float screenHeight, vec2 fragCoord, int[16] glyphs, int digCount, float fontSize, vec2 pos)\n{\n    //shift and flip coord\n    fragCoord = vec2(fragCoord.x - pos.x, screenHeight - (fragCoord.y + pos.y));\n    vec2 coord = fragCoord / fontSize;\n    coord.x *= 2.;\n    if (coord.x > 0. && coord.y > 0. && coord.y < 1.)\n    {\n        int index = int(coord.x);\n        if (index < digCount)\n        {\n            int value = glyphs[index];\n            ivec2 lookup = ivec2(value & 15, value / 16);\n            vec2 texCoord = vec2(lookup) / 16. + (fract(coord) + vec2(.5,0.)) / vec2(32.,16.);\n            return textureLod(fontBuffer, texCoord, 0.).x;\n        }\n    }\n    return 0.;\n}\n\n//draws text at the original font's size at a given pixel\nfloat drawText(sampler2D fontBuffer, float screenHeight, vec2 fragCoord, int[16] glyphs, int digCount, ivec2 pos)\n{\n    //shift and flip coord\n    ivec2 pixel = ivec2(int(fragCoord.x) - pos.x * 32, int(screenHeight - fragCoord.y) - pos.y * 64);\n    if (pixel.x > 0 && pixel.y > 0 && pixel.y < 64)\n    {\n        int index = pixel.x / 32;\n        if (index < digCount)\n        {\n            int value = glyphs[index];\n            ivec2 cr = ivec2(value & 15, value / 16); //get row, column for index\n            ivec2 texCoord = cr * 64 + (pixel & ivec2(31,63)) + ivec2(16, 0);\n            return texelFetch(fontBuffer, texCoord, 0).x;\n        }\n    }\n    return 0.;\n}\n\nconst float log10 = log(10.);\nconst float epsilon = 1.19e-07;\nint[16] glyphs;\nfloat printFloat(sampler2D fontBuffer, float screenHeight, vec2 fragCoord, float num, ivec2 screenPos)\n{\n    int glyph = 0;\n    int digitPos = int(fragCoord.x / 32.) - screenPos.x; //digit pos @ this position\n    int digit = digitPos;\n    if (digit < 0 || digit > 7) return 0.; //outside digit range\n    if (num < 0.) { //handle negative numbers\n        if (digit == 0) { \n            glyph = 0x2d;\n        } else {\n            num = -num;\n            digit--;\n        }\n    }\n    if (glyph == 0) { //normal case\n        screenPos = ivec2(screenPos.x + digitPos, screenPos.y);\n        digit -= int(log(num)/log10);\n        if (digit == 1) {\n            glyph = CHAR_DOT;\n        } else if (digit > 1)\n        {\n            digit--;\n        }\n        if (glyph == 0) {\n            float p = pow(10., float(digit));\n            float dig = num * p;\n            int digitVal = int(dig)%10;\n            glyph = CHAR_0 + digitVal;\n        }\n    }\n    glyphs[0] = glyph;\n    return drawText(fontBuffer, screenHeight, fragCoord, glyphs, 1, screenPos);\n}\n\nfloat printInt(sampler2D fontBuffer, float screenHeight, vec2 fragCoord, int num, ivec2 screenPos)\n{\n    int glyph = 0;\n    int digitPos = int(fragCoord.x / 32.) - screenPos.x; //digit pos @ this position\n    int digit = digitPos;\n    int digitCount;\n    if (num == 0)\n        digitCount = 0;\n    else\n        digitCount = int(log(float(abs(num)))/log10+.01);\n        \n    if (num < 0) { //handle negative numbers\n        if (digit == 0) { \n            glyph = 0x2d;\n        } else {\n            num = -num;\n            digit--;\n        }\n    }\n    if (digit < 0 || digit > digitCount) return 0.; //outside digit range\n\n    if (glyph == 0) { //normal case\n        screenPos = ivec2(screenPos.x + digitPos, screenPos.y);\n        float p = pow(10., float(digit - digitCount));\n        int digitVal;\n        if (p == 0.) {\n            digitVal = 0;\n        } else {\n            int dig = int(float(num) * p);\n            digitVal = (dig)%10;\n        }\n        glyph = CHAR_0 + digitVal;\n    }\n    glyphs[0] = glyph;\n    return drawText(fontBuffer, screenHeight, fragCoord, glyphs, 1, screenPos);\n}","name":"Common","description":"","type":"common"}]}