{"ver":"0.1","info":{"id":"fdjcDW","date":"1643544825","viewed":156,"name":"improved glow technique","username":"vanilin","description":"another version of glowing effect implementation","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","glow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n\n\n#define MAX_ITERATIONS 60\n#define SMALL_DISTANCE 0.01\n#define INFINITE_DISTANCE 80.0\n\nstruct Surface{\n    vec4 color;\n    vec4 glow;\n    float distance;\n};\n\nmat3 getRotationY(float angle) {\n    float cosine = cos(angle);\n    float sine = sin(angle);\n    return mat3(\n        cosine, 0.0,   sine,\n         -sine, 0.0, cosine,\n           0.0, 0.0,     1.0\n    );\n}\n\nmat3 getRotationX(float angle) {\n    float cosine = cos(angle);\n    float sine = sin(angle);\n    return mat3(\n        1.0,    0.0,    0.0,\n        0.0, cosine,  -sine,\n        0.0,   sine, cosine\n    );\n}\n\nfloat regularUnion(vec2 distances){\n    return min(distances.x, distances.y);\n}\n\nfloat smoothUnion(vec2 distances, float smoothness)\n{\n    float degree = max(smoothness-abs(distances.x-distances.y), 0.0);\n    float minimalDistance = min(distances.x, distances.y);\n    return minimalDistance - pow(degree, 2.0) / smoothness * 0.25;\n}\n\nfloat smoothModifier = 0.8;\nfloat glowDistance = 1.4;\nfloat glowModifier = 0.04;\n\nSurface getDistance(vec3 point){\n    float speed = iTime / 2.0;\n    vec3 baseCenter = vec3(0.0, 0.0, -16.0);\n    float baseRadius = 3.0;\n    vec4 baseColor = vec4(0.2, 0.05, 0.7, 1.0);\n    vec4 baseGlow = vec4(0.0);\n    float smoothDistance = length(point - baseCenter) - baseRadius;\n    vec3 unitFromCenter = getRotationX(speed) * getRotationY(speed) * normalize(point - baseCenter) * baseRadius;\n    smoothDistance -= baseRadius / 4.0 - cos(unitFromCenter.x) * cos(unitFromCenter.y) * cos(unitFromCenter.z) * 0.3;\n    for (int index = 1; index <= 6; index++){\n        float state =  speed * float(index) * 0.6;\n        float x = sin(state + float(index - 3) * 2.0);\n        float y = cos(state + float(index - 3) * 2.0);\n        y *= 2.0 * x;\n        float z = sin((state + float(index - 3) * 2.0) * 3.14) + 1.0;\n        vec3 center = baseCenter + vec3(x * 2.0, y, z) * baseRadius * (cos(speed) * 0.1 + 1.0);\n        float radius = baseRadius / 2.0 - float(index) / 8.0;\n        vec3 fromCenter = point - center;\n        float distanceToSurface = length(fromCenter) - radius;\n        vec4 color = mix(vec4(0.5, 0.0, 0.2, 1.0), vec4(0.0, 0.2, 0.5, 1.0), 0.5 + float(index) / 12.0);\n        if ((index == 1 || index == 3 || index == 6) && distanceToSurface  < glowDistance){\n            vec2 projection = point.xy - center.xy;\n            baseGlow = mix(color * glowModifier, baseGlow, abs(distanceToSurface) / glowDistance);\n        }else{\n            color *= mod(fromCenter.x - fromCenter.y, 0.2) < 0.1 ? 1.0 : 0.5;\n        }\n        baseColor = mix(baseColor, color, 0.5 + clamp(smoothDistance - distanceToSurface, -0.5, 0.5));\n        smoothDistance = smoothUnion(vec2(smoothDistance, distanceToSurface), smoothModifier);\n    }\n\n    return Surface(baseColor, baseGlow, smoothDistance);\n\n}\n\nvec3 getNormal(vec3 point){\n    vec2 unit = vec2(0.01, 0.0);\n    float distanceToSurface = getDistance(point).distance;\n    return normalize(vec3(distanceToSurface) - vec3(\n    getDistance(point - unit.xyy).distance,\n    getDistance(point - unit.yxy).distance,\n    getDistance(point - unit.yyx).distance\n    ));\n}\n\nSurface rayMarch(vec3 view, vec3 direction){\n    float distance = 0.0;\n    vec4 color = vec4(0.0);\n    vec4 glow = vec4(0.0);\n    bool trigger = false;\n    for (int index = 0; index < MAX_ITERATIONS ; index++){\n        vec3 point = view + direction * distance;\n        Surface surface = getDistance(point);\n        color = surface.color;\n        distance += surface.distance;\n        if (length(surface.glow) > 0.0){\n            glow += surface.glow;\n        }\n        if (surface.distance < -SMALL_DISTANCE && !trigger){\n            trigger = true;\n        }\n        if (distance > INFINITE_DISTANCE || (trigger && surface.distance > SMALL_DISTANCE)){\n            break;\n        }\n    }\n    return Surface(color, glow, distance);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float speed = iTime / 2.0;\n    vec3 point = vec3((fragCoord.xy - 0.5 * iResolution.xy)/iResolution.y, -1.0f);\n    vec3 view = vec3(vec2(0.0), 0.0);\n    vec3 direction = normalize(point - view);\n    vec3 lightDirection = normalize(vec3(cos(speed), 2.0, 1.0) * 8.0 - point);\n    Surface object = rayMarch(view, direction);\n    fragColor = vec4(0.06, 0.0, 0.18, 1.0) * dot(lightDirection, normalize(vec3(point.xy, abs(length(point.xy) + 0.1))));\n    if (object.distance < INFINITE_DISTANCE){\n        vec3 pointOnSurface = view + direction * object.distance;\n        float light = clamp(dot(\n        lightDirection,\n        getNormal(pointOnSurface)\n        ), 0.1, 1.0);\n        fragColor = object.color * pow(light, 2.0);\n    }\n    if (length(object.glow) > 0.0){\n        fragColor += object.glow;\n    }\n}","name":"Image","description":"","type":"image"}]}