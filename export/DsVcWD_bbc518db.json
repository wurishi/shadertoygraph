{"ver":"0.1","info":{"id":"DsVcWD","date":"1696982803","viewed":96,"name":"Helix Distance (Exact)","username":"VL","description":"I haven't yet proven that this method converges to the global minimum, but it seems to do so.\n[url]https://www.desmos.com/calculator/0u7jsniq0x[/url]\nJittering problem fixed.\nClick to see uv.\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define int2 vec2\n#define float2 vec2\n#define int3 vec3\n#define float3 vec3\n#define int4 vec4\n#define float4 vec4\n#define frac fract\n#define float2x2 mat2\n#define float3x3 mat3\n#define float4x4 mat4\n#define saturate(x) clamp(x,0.,1.)\n#define lerp mix\n#define CurrentTime (iTime)\n#define sincos(x,s,c) s = sin(x),c = cos(x)\n#define mul(x,y) (x*y)\n#define atan2 atan\n#define fmod mod\n#define static\n#define MaxDist 100.f\n#define SurfaceDist 0.0001f\n#define PI 3.1415926535898\n\nfloat2 helixUv ;\n\n//H(t) = (r*cos(t), c*t, r*sin(t))\n//r >= 0 & c != 0\n//f(t) = ||P - H(t)||^2 - (P.x^2 + P.y^2 + P.z^2 + r^2) = -2*r*(P.x*cos(t) + P.z*sin(t)) - 2*c*P.y*t + c^2*t^2\nfloat DistHelix(float3 p, float r, float c)\n{                      \n    p.y = fmod(p.y, PI * 2.f * c);\n    float th = atan2(p.z, p.x);\n    float l = length(p.xz);\n    \n    float m2rl = -2.f * r * l;\n    float m2y = -2.f * p.y; \n\n    float t = p.y / c; //2*c*P.y - 2*c^2*t = 0    \n    \n    const float d2 = 1.f / 2.f;\n    float Pi_d2n = PI * d2;\n    for (int i = 0; i < 3; i++)\n    {    \n        float tp = t + Pi_d2n;\n        float ctp = c * tp; //c*(t_n + pi/2^n)       \n        float fp = m2rl * cos(th - tp) + ctp * (ctp + m2y); //f(t_n + pi/2^n)\n\n        float tm = t - Pi_d2n;\n        float ctm = c * tm; //c*(t_n - pi/2^n)       \n        float fm = m2rl * cos(th - tm) + ctm * (ctm + m2y);  //f(t_n - pi/2^n)\n\n        t = fm < fp ? tm : tp;\n        Pi_d2n *= d2;\n    }\n\n    for (int i = 0 ; i < 3; ++i)\n    {\n        vec3 v = vec3(r*cos(t), c*t, r*sin(t));\n        vec3 dv = vec3(-v.z, c, v.x);\n        vec3 ddv = vec3(-v.x, 0, -v.z);\n        float dH2 = -2. * dot(p - v, dv);\n        float ddH2 = 2. * (c*c + p.x*v.x + p.z*v.z);\n        t -= dH2 / ddH2;\n    }\n    \n    helixUv.y = t/(PI*2.0);\n    \n    float3 v = float3(r*cos(t), c*t, r*sin(t));\n    float3 dv = normalize(float3(-v.z, c, v.x));\n    float3 pv = p-v;\n    float len = length(pv);    \n\n    float3 ta = cross(float3(0.,1.0,0.), dv);\n    float3 cta = cross(dv,ta);\n    pv = r > 0. ? mul(transpose(float3x3(cta, dv, ta)), pv) : pv;\n    helixUv.x = (atan2(pv.z,pv.x)/PI + 1.0)*0.5;\n        \n    return len;\n}\n\nfloat R = 0.0;\nfloat C = 0.0;\nfloat T = 0.0;\n\nfloat2x2 rot2D(float t)\n{\n    float s, c;\n    sincos(t, s, c);\n    return float2x2(c, s, -s, c);\n}\n\nfloat GetDist(float3 ray)\n{\n    //ray.xz = mul(rot2D(iTime),ray.xz);\n    float d1 = DistHelix(ray, R, C)-0.15;\n    float d2 = length(ray - float3(R*cos(T), C*T, R*sin(T))) - 0.25;\n    \n    if(d1 < d2)\n    {\n        return d1;\n    }\n    else\n    {\n        helixUv = float2(0.);\n        return d2;\n    }\n}\n\nfloat RayMarching(float3 origin, float3 dir)\n{\n\tfloat hitDist = 0.f;\n\tfor (int i = 0; i < 200; ++i)\n\t{\n\t\tfloat3 ray = origin + dir * hitDist;\n\t\tfloat curr = GetDist(ray);\n\t\thitDist += curr;\n\t\tif (curr < SurfaceDist || hitDist > MaxDist)\n\t\t{\n\t\t\thitDist = curr < SurfaceDist ? hitDist : MaxDist;\n\t\t\tbreak;\n\t\t}\n\t}\n    \n    \n\treturn hitDist;\n}\n\nfloat3 GetNormal1(float3 ray)\n{\n\tfloat d = GetDist(ray);\n\tfloat3 n = float3( d,d,d ) -\n\t\tfloat3( GetDist(ray - float3(SurfaceDist, 0.f, 0.f)),\n\t\t\tGetDist(ray - float3(0.f, SurfaceDist, 0.f)),\n\t\t\tGetDist(ray - float3(0.f, 0.f, SurfaceDist)) );\n\n\treturn normalize(n);\n}\n\nfloat3 GetNormal2(float3 p)\n{\n    return normalize(float3(+1.f, -1.f, -1.f) * GetDist(p + float3(+1.f, -1.f, -1.f) * SurfaceDist) +\n                     float3(-1.f, -1.f, +1.f) * GetDist(p + float3(-1.f, -1.f, +1.f) * SurfaceDist) +\n                     float3(-1.f, +1.f, -1.f) * GetDist(p + float3(-1.f, +1.f, -1.f) * SurfaceDist) +\n                     float3(+1.f, +1.f, +1.f) * GetDist(p + float3(+1.f, +1.f, +1.f) * SurfaceDist));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.f*(fragCoord.xy/iResolution.xy)-1.f;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    R = 10.0 + sin(iTime)*10.0;\n    C = 0.3;\n    T = iTime;\n    \n    float3 rayOrigin = float3(0.f, C*T, -R -1.5f);          \n    float3 rayDir = normalize(float3(uv, 1.f));\n    \n    float march = RayMarching(rayOrigin, rayDir);\n    float3 rayPoint = rayOrigin + rayDir * march;\n    float3 normal = GetNormal1(rayPoint);\n\n    float time = iTime;\n    vec3 col = march != MaxDist ? float3(dot(normal,-normalize(float3(0.,0.8,1.)))) : vec3(0.f);    \n\n    if(iMouse.z > 0.)\n        col *= float3(helixUv,0.0);\n        \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}