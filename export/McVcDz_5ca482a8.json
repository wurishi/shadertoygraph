{"ver":"0.1","info":{"id":"McVcDz","date":"1731754423","viewed":41,"name":"Refractive FBM Ball","username":"Peregrine","description":"Written during the SESSION 2024 demoparty shader jam... which I wasn't really attending, since I didn't realize that I wasn't connected until the very end. *facepalm*\nExperimenting with refraction over my old moire effect.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarchingrefractionfbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define T iTime\n#define IOR 2. //crystal ball!\n#define EPSILON 0.001\n#define MAX_DIST 20.\n\n#define fft(f) texture(iChannel0, vec2(f)).x\n#define q(s) (s * de(p + s, hollow))\n\n// hello, konnichiwa people\n// it's past 9 a.m. here in paris, france and i haven't slept enough\n// let's see what i can do for your enjoyment!\n\nfloat fbm(vec2 p) {\n  float f = 0.;\n  float frequency = 4.;\n  float amplitude = .8;\n    \n  for (int i = 0 ; i < 8; i++) {\n    f += texture(iChannel1, p * frequency).x * amplitude;\n    amplitude *= .5;\n    frequency *= 1.79;\n  }\n\n  return f;\n}\n\nfloat de(vec3 p, float hollow) {\n  float d = MAX_DIST;\n  float period = floor(mod(T * .5, 4.)) + 1.;\n  float s1 = length(p) - .1;\n  s1 -= 1. * fft(.02);\n  s1 -= 1.1 * fbm((vec2(p.x/(1.-p.z), p.y/(1.-p.z)) + T/2.) * .0002 * period);\n  float s2 = length(p) - .1;\n  s2 -= 1. * fft(.01);\n  s2 -= 1.1 * fbm((vec2(p.x/(1.-p.z), p.y/(1.-p.z)) + T/2.) * .0006 * period);\n  \n  d = min(d, min(s1, s2));\n  return d * hollow;\n}\n\nstruct Raymarching {\n  bool hit;\n  vec3 p, n;\n  float i, td, id, hollow;\n};\n\nRaymarching march(vec3 ro, vec3 rd, float steps, float hollow) {\n  Raymarching r;\n  r.hit = false;\n  r.p = ro;\n  r.td = 0.;\n  r.hollow = hollow;\n  \n  for(r.i = 0.; r.i < steps && r.td < MAX_DIST; r.i++) {\n    r.p = ro + r.td * rd;\n    float d = de(r.p, hollow);\n    if(d < EPSILON) {\n      r.hit = true;\n      break;\n    }\n    r.td += d;\n  }\n  \n  return r;\n}\n\n// one of my earliest bits of GLSL\nvec2 lissajous(float a, float b, float speed) {\n  return vec2(\n    sin(a * T * speed),\n    cos(b * T * speed)\n  );\n}\n\nvec3 moire(vec2 p) {\n  vec2 focus1 = lissajous(3., 2., .1),\n       focus2 = lissajous(5., 4., .1);\n  int ring_width = 4;\n  float scale = 100.;\n  \n  int interference = int(scale * distance(focus1, p))\n                   ^ int(scale * distance(focus2, p));\n  interference /= ring_width;\n  interference %= 2;\n  return (interference == 0) ? vec3(0.) : vec3(.1);\n }\n\nvec3 normal(vec3 p, float hollow) {\n  vec2 e = EPSILON * vec2(1., -1.);\n  return normalize(q(e.xyy) + q(e.yxy) + q(e.yyx) + q(e.xxx));\n}  \n\nfloat ambient_occlusion(vec3 p, vec3 n, float hollow) {\n  float dist = 0.17,\n        occlusion = 1.;\n  for(int i = 0; i < 10; i++) {\n    occlusion = min(occlusion, de(p + dist * n, hollow)/dist);\n    dist *= .6;\n  }\n  \n  return max(occlusion, 0.);\n}\n\nfloat soft_shadow(vec3 ro, vec3 rd, float softness, float hollow) {\n  float s = 1.,\n        t = 0.;\n  for(int i = 0; i < 40; i++) {\n    float dist = de(ro + rd * t, hollow);\n    s = min(s, .5 + (.5 * dist)/(softness * t));\n    if(s < 0.) break;\n    t += dist + .0001;\n  }\n  \n  s = max(s, 0.);\n  return s * s * (3. - (2. * s));\n}\n\nfloat shade(Raymarching r, vec3 rd, vec3 lo, float hollow) {\n  vec3 ld = normalize(lo - r.p),\n       hv = normalize(ld - rd);\n  float ambient = 0.0025,\n        occlusion = ambient_occlusion(r.p, r.n, hollow),\n        shadow = soft_shadow(r.p, ld, .15, hollow),\n        diffuse = max(0., dot(ld, r.n)),\n        specular = pow(max(0., dot(hv, r.n)), 128.),\n        fresnel = 1. - abs(dot(rd, r.n));\n  return ambient + diffuse * occlusion * shadow + fresnel + specular * shadow;\n}\n \nvec3 render(vec2 uv) {\n  vec2 offset = .2 * vec2(fft(0.05), fft(.5));\n  vec3 c = vec3(0.),\n       ro = vec3(0., 0., -5.),\n       rd = normalize(vec3(uv, 1.)),\n       lo = vec3(cos(T), sin(T), -1.) * 2.;\n  \n  c.r = moire(uv + offset).r;\n  c.g = moire(uv).g;\n  c.b = moire(uv - offset).b;\n  \n  Raymarching r = march(ro, rd, 128., 1.);\n  if (r.hit) {\n    vec3 tint = vec3(.5, .15, .9);\n    r.n = normal(r.p, 1.);\n    c += tint * shade(r, rd, lo, 1.);\n    vec3 ro_in = r.p - 2. * EPSILON * r.n,\n         rd_in = refract(rd, r.n, 1./IOR);\n    Raymarching r_in = march(ro_in, rd_in, 64., -1.);\n    if (r_in.hit) {\n      r_in.n = normal(r_in.p, -1.);\n      c += tint * shade(r_in, rd_in, lo, -1.);\n      vec3 ro_out = rd_in.p - 2. * EPSILON * r_in.n,\n           rd_out = refract(rd_in, r_in.n, IOR);\n      c += moire(uv + rd_out.xy);\n    }\n  }\n  \n  c *= exp(-5. * length(uv));\n  return c;\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.x;\n  vec3 c = render(uv);\n  c = pow(c, vec3(1./2.2));\n  fragColor = vec4(c, 1.);\n}","name":"Image","description":"","type":"image"}]}