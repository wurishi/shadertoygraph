{"ver":"0.1","info":{"id":"3lSXWw","date":"1565974497","viewed":232,"name":"Implicit 2d shapes and functions","username":"yudemente","description":"2d implicit functions for square, torus, ball and square with rounded edges","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["shapes","implicit","signeddistance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float dist_axis(vec2 center, float radius, vec2 p, int axis)\n{\n\treturn min(\n\t\tabs(center[axis] + radius - p[axis]),\n\t\tabs(center[axis] - radius - p[axis])\n\t);\n}\n\nfloat euclidean_distance_ball(vec2 p, vec2 center, float radius)\n{\n\tvec2 diff = p - center;\n\treturn sqrt(dot(diff, diff)) - radius;\n}\n\nfloat manhatan_distance_ball(vec2 p, vec2 center, float radius)\n{\n\tvec2 diff = p - center;\n\treturn max(abs(diff.x), abs(diff.y)) - radius;\n}\n\nfloat euclidean_distance_square(vec2 p, vec2 center, float radius)\n{\n\tvec2 d = abs(p) - radius;\n\tvec2 t = max(d, 0.0);\n\treturn sqrt(dot(t, t)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat abs_diff_sum_distance_ball(vec2 p, vec2 center, float radius)\n{\n\tvec2 diff = abs(p - center);\n\treturn diff.x + diff.y - radius;\n}\n\nbool in_range(float x, float a, float b)\n{\n\treturn x >= a && x <= b;\n}\n\nbool is_inside_cross(vec2 center, float radius, vec2 p)\n{\n\treturn in_range(p.x, center.x - radius, center.x + radius)\n\t\t|| in_range(p.y, center.y - radius, center.y + radius);\n}\n\nfloat euclidean_distance_rounded_square(vec2 p, vec2 center, float radius, float round_radius)\n{\n    radius = radius - round_radius;\n\tvec2 d = abs(p) - radius;\n\tvec2 t = max(d, 0.0);\n\treturn sqrt(dot(t, t)) - round_radius + min(max(d.x, d.y), 0.0);\n}\n\nfloat euclidean_distance_torus(vec2 p, vec2 center, float r, float R)\n{\n\tvec2 diff = p - center;\n\tfloat tmp = (sqrt(dot(p, p)) - R);\n\treturn tmp*tmp - r*r;\n}\n\nfloat euclidean_distance_ellipse(vec2 f1, vec2 f2, float a, vec2 p)\n{\n    vec2 r1 = f1 - p;\n    vec2 r2 = f2 - p;\n    return sqrt(dot(r1, r1)) + sqrt(dot(r2, r2)) - 2.*a;\n}\n\nfloat bounce(float min, float max)\n{\n    return min + (sin(iTime) + 2.0)/2.0 * (max-min);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Normalized pixel coordinates (from 0 to 1)\n\tfloat tmp = min(iResolution.x, iResolution.y);\n\tvec2 uv = fragCoord/tmp - iResolution.xy/(2.0*tmp);\n\t\n\tvec3 color = vec3(1.0, 1.0, 1.0);\n\tvec3 bcolor = vec3(1.0, 0.0, 0.0);\n\tvec2 center = vec2(0.0, 0.0);\n\tfloat radius = 0.25;\n\tfloat max_dist = 0.5;\n\t\n\t// Output to screen\n\t//fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\n\t// float d = euclidean_distance_ball(uv, center, radius);\n\t/* float d = manhatan_distance_ball(uv, center, radius); */\n\t/* float d = euclidean_distance_square(uv, center, radius); */\n\t/* float d = euclidean_distance_torus(uv, center, 0.1, radius); */\n   \t// float d = abs_diff_sum_distance_ball(uv, center, radius);\n    // float d = euclidean_distance_rounded_square(\n\t// \tuv,\n\t//\tcenter,\n\t//\tradius,\n\t//\t(sin(iTime) + 1.0)/2.0*radius\n\t//);\n    float d = euclidean_distance_ellipse(\n        vec2(-1.5*radius, 0.0), vec2(+1.5*radius, 0.0),\n        bounce(1., 2.)*radius,\n        uv\n    );\n\t\n\n\tfloat ba = 1.0 - clamp(abs(d)/max_dist, 0.0, 1.0);\n\tba = pow(ba, 128.0);\n\tfloat i = (d + max_dist)/(2.0*max_dist);\n\t\n\tcolor = color*clamp(i, 0.0, 1.0);\n\tfragColor = vec4(bcolor*ba + color*(1.0 - ba), 1.0);\n}","name":"Image","description":"","type":"image"}]}