{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"float dis=.5;\nfloat width=.1;\nfloat blur=.1;\n\n#define PI 3.14159265358979323846\n#define e  2.71828182845904523\n\nfloat N21(vec2 p){\n    return fract(sin(p.x * 100. + p.y * 6574.) * 5647.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat sdHeart(vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nvec2 rotate(in vec2 pos, in float theata) {\n    return vec2(pos.x * cos(theata) - pos.y * sin(theata), pos.y * cos(theata) + pos.x * sin(theata));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=.5;\n    vec2 pos=vec2(0.5*(iResolution.x/iResolution.y),.5);\n    uv.x=(iResolution.x/iResolution.y)*uv.x; \n    uv*=10.;\n    pos*=10.;\n\n    vec3 col = vec3(0.2, 0.2, 0.75);   \n    \n    vec2 o=uv;\n    float angle=atan(o.y,o.x);\n    float l=length(o);\n    float offset=(log(l)/log(e*5.)+(angle/(2.*PI))*dis);\n    float circles=mod(offset-iTime * 0.2,dis);\n    col -= (smoothstep(circles-blur,circles,width)-smoothstep(circles,circles+blur,width));   \n    \n    if (sin(N21(uv.xx + 0.3 * uv.y) + iTime) > 0.5) {\n        col *= vec3(1.0, 0.3, 0.3);\n    }\n    \n   \n    bool lighten = false;\n    \n    for (float i = 0.0; i < 18.0; i++) {\n        if (sdTriangleIsosceles(uv - vec2(i - 8.5, sin(iTime + i) * 0.5 + 2.0), vec2(0.5, 2.0)) < 0.1) {\n            lighten = true;\n        } else if (sdTriangleIsosceles(uv * vec2(1.0, -1.0) - vec2(i - 8.5, sin(iTime + i) * 0.5 + 2.), vec2(0.5, 2.0)) < 0.1) {\n            lighten = true;\n        }\n    }\n    \n    float valSin = sin(uv.x + iTime - 1.) * 0.5;\n    float ofs = sign(sin((uv.x + iTime) * PI * (1./3.)));\n    float heartVal =  sdHeart(vec2(mod(uv.x + iTime, 3.0) - 1.5, uv.y * ofs + sin(iTime) * 0.5 + 0.5) / 2.0 + vec2(0.0, 0.5));\n    \n    if (valSin > uv.y + 3.8 || valSin > -uv.y + 3.8 || heartVal < 0.0) {\n       lighten = true;\n    }\n \n    if (lighten) {\n        col *= vec3(1.5);\n    } \n     \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XfGfzw","date":"1734365373","viewed":23,"name":"hearts and spiral","username":"noxfy","description":"ddasd","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["asdds"],"hasliked":0,"parentid":"","parentname":""}}