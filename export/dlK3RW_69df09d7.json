{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"mic","id":"XdXGRr","filepath":"/presets/mic.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"  // Adapted from https://www.shadertoy.com/view/4dVXDt\n  \n  \n  // Use Microphone or Noise\n  #define USEMIC\n  \n  // 3 color modes\n  #define COLOR_MODE 3 // 1-3\n \n  \n  #define AMP_FACT 0.2\n  #define uRingsN 18\n  #define uWidth 0.2\n  #define uSize 0.2\n  \n  #ifdef USEMIC\n   #define IN_DATA   iChannel1\n   #define NOISE_AMP 0.2\n  #else\n   #define IN_DATA   iChannel0\n   #define NOISE_AMP 0.0\n  #endif\n  \n  const vec4 kHue = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  #define hue2rgb(h) clamp(abs(fract(vec3(h) + kHue.xyz) * 6.0 - kHue.www) - kHue.xxx, 0.0, 1.0)\n  #define _hls2rgb(x,y,z) z + y * (clamp(abs(mod(x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0) - 0.5) * (1.0 - abs(2.0 * z - 1.0))\n  #define hsv2rgb(x,y,z) z * mix(kHue.xxx, clamp(abs(fract(vec3(x) + kHue.xyz) * 6.0 - kHue.www) - kHue.xxx, 0.0, 1.0), y)\n  #define hsl2rgb(x,y,z) z * mix(kHue.xxx, clamp(abs(fract(vec3(x) + kHue.xyz) * 6.0 - kHue.www) - kHue.xxx, 0.0, 1.0), (1.0 - abs(2.0 * y - 1.0)))\n  \n\n  float waves(vec2 coord, vec2 coordMul1, vec2 coordMul2, vec2 phases, vec2 timeMuls) {\n      return 0.5 * (sin(dot(coord, coordMul1) + timeMuls.x * iTime + phases.x) + cos(dot(coord, coordMul2) + timeMuls.y * iTime + phases.y));\n  }\n  \n  const vec2 noiseDir1 = vec2(1.0, 0.0019);\n  const vec2 noiseDir2 = vec2(1.0, 0.8000);\n  \n  float ringMultiplier(vec2 uv, float amp, float phase, float off, float power) {\n    vec3 noise1 = texture(IN_DATA, noiseDir1 * phase            ).rgb;\n    vec3 noise2 = texture(iChannel0, noiseDir2 - noiseDir1 * phase).rgb;\n    vec2 d = vec2(off, 0.5);\n    d.x += 0.6 * waves(\n      uv,\n      vec2( 1.9 + 0.4 * noise1.r, 1.9 + 0.4 * noise1.g ) * 3.3,\n      vec2( 5.7 + 1.4 * noise1.b, 5.7 + 1.4 * noise2.r ) * 2.8,\n      vec2( noise1.r - noise2.r,  noise1.g + noise2.b  ) * 5.0,\n      vec2( 1.1 )\n    );\n    d.y += 0.4 * waves(\n      uv,\n      vec2( -1.7 - 0.9 * noise2.g,  1.7 + 0.9 * noise2.b ) * 3.1,\n      vec2(  5.9 + 0.8 * noise1.g, -5.9 - 0.8 * noise1.b ) * 3.7,\n      vec2( noise1.g + noise2.g,    noise1.b - noise2.r  ) * 5.0,\n      vec2( -0.9 )\n    );\n    float a = noise1.x * NOISE_AMP + 0.6 * (abs(d.x) + abs(d.y));\n    vec2 duv = uv + normalize(d) * a * amp * AMP_FACT;\n    return smoothstep( -power, power, pow(abs(length(duv) - uSize), noise1.x * noise2.x));\n  }\n  \n  \n  vec3 getColor(vec2 uv, float s){\n    return vec3(\n      dot(uv, vec2(cos(iTime + s), sin(iTime -s))),\n      dot(uv, vec2(cos(iTime + 1.75* s),sin(iTime +s))),\n      dot(uv, vec2(sin(iTime + s)))\n    );\n  }\n  \n  \n  \n  vec3 hue(vec2 uv, float h, float speed){\n    return vec3(0.5) + hue2rgb(h + (dot(uv,vec2(0.5)) + iTime) * speed);  \n  }\n  \n  void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 vuv = fragCoord/iResolution.xx;\n    vec2 uv = vec2( 0.5, 0.260 ) - vuv;\n    vec3 color = vec3( 1.0 );\n    float power = pow( uWidth * 0.1, uWidth );\n    float size = uSize * 0.38;\n    \n #if (COLOR_MODE == 1)\n    vec3 t1 = getColor(uv, 2.), t2 = 1. - getColor(uv, -2.1);\n #elif (COLOR_MODE == 2)\n    vec3 t1 = .65 - hue(uv, 0.6, 0.005), t2 = .72 - hue(uv.yx, 0.8, 0.05);\n #elif (COLOR_MODE == 3)\n    vec3 t1 = 1. - vec3(0.1, 0.5, 0.7), t2 = 1. - vec3(0.8, 0.1, 0.8);\n #else\n    vec3 t1 = 1. - vec3(0.9, 0.5, 0.3), t2 = 1. - vec3(0.8, 0.1, 0.2);\n #endif\n \n    float xoff = 0.5 * (0.9 * cos(iTime * 0.6 + 1.1) + 0.4 * cos(iTime * 2.4));\n    for (int i = 0; i < uRingsN; i++) {\n      float frac = float(i) / float(uRingsN);\n      float amp = ringMultiplier(uv,\n                                 0.1 + pow(frac, 3.0) * 0.7,\n                                 pow(1.0 - frac, uWidth) * 0.09 + iTime * 0.0001,\n                                 xoff,\n                                 power);\n      color *= mix(mix(t1, t2, pow(frac, 3.0)), vec3(1.0), pow(amp, 2.5));\n    }\n    color = 1. - color;\n    fragColor = vec4(color, length(color));\n  }","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":true,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"dlK3RW","date":"1683670179","viewed":20,"name":"PlasmaMic","username":"diasgc","description":"rings","likes":0,"published":1,"flags":4,"usePreview":0,"tags":["rings"],"hasliked":0,"parentid":"","parentname":""}}