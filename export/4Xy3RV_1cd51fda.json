{"ver":"0.1","info":{"id":"4Xy3RV","date":"1717874370","viewed":70,"name":"SYS$HORIZON The Finals: Season 2","username":"Zaba","description":"The main menu for The Finals by Embark Studios during Season 2, and the season as a whole, was digitally-inspired and vaporwave in style. \nExcuse WIP port from Shader Editor for Android. \nSee comments for more information. \nFeedback welcome.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["remake","background","digital","synth","games","vaporwave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//// Zaba 2024\n//// SYS$HORIZON The Finals: Season 2\n////\n//// The main menu for The Finals by Embark Studios during\n//// Season 2, and the season as a whole, was digitally-\n//// inspired and vaporwave in style. Season 2 ran from\n//// 14 March to 12 June, 2024.\n//// \n//// Excuse the porting from Shader Editor for Android where\n//// special uniforms made this a suitable wallpaper. I\n//// learned GLSL by toying with Shader Editor and, as is\n//// known, every graphics context has its own peculiarities\n//// and learning curve.\n//// \n//// This is my first ShaderToy shader.\n//// \n//// Work-in-progress\n//// - REFACTOR: Finish cleanup of port from Shader Editor\n////   for Android\n////   - TODO: Correct fov, uvs; fix post-processing\n////   - TODO: Reimplement interactivity (mouse VS. multi-\n////     touch, sensors, volume, etc.)\n////   - TODO: Reimplement photons\n//// - FEAT: Cloudy fog\n//// - FEAT: Rising-voxel grid-prisms along horizon\n////   background\n\nvec3 reflection(vec2 p, vec2 coord, vec2 fov) {\n  vec3 c = vec3(0);\n  vec2 uv = coord.xy / R.xy;\n  #ifdef IS_INTERACTIVE\n    uv.y = 1.0 - uv.y - (HORIZON + PANE_Z * 4.) / fov.y;\n  #else\n    uv.y = 1.0 - uv.y - (HORIZON + PANE_Z * 4.);\n  #endif\n  float factor = \n    smoothstep(0., HORIZON, p.y - HORIZON) // Fade at top near horizon.\n    * (2.5 - 2. * p.y); // Fade as distance grows downward.\n  c += 0.85 * factor * texture(iChannel0, uv).rgb;\n  return clamp(c, vec3(0), vec3(1));\n}\n\nvoid postProcess(inout vec3 c, vec2 p, vec2 coord, vec2 fov) {\n  // Backbuffer reflection on grid plane.\n  #ifdef DO_REFLECTION\n    c = screen(c, 0.25 * (1. + H) * reflection(p, coord, fov));\n  #endif\n  // Black fade in.\n  #ifdef DO_INTRO\n    if (iFrame > 1) c = mix(\n      vec3(0), c,\n      pow(clamp(float(iFrame) / INTRO_FRAMES, 0., 1.), 3.)\n    );\n  #endif\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = UV;\n  vec2 fov = FOV; // Modifies uv.\n  vec3 c = texture(iChannel0, fragCoord.xy / R.xy).rgb;\n  postProcess(c, uv, fragCoord, fov);\n  fragColor = vec4(c, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float sky(vec2 p) { return max(0., -(HORIZON - SKY_FADE - p.y)); }\n\nfloat fog(vec2 p, float e) {\n  float f = 0.;\n  if (p.y < HORIZON) {\n    f = pow(smoothstep(-HORIZON, HORIZON, p.y), 6.);\n  } else {\n    f = pow(smoothstep(1.5, HORIZON, p.y), 3.);\n  }\n  return pow(f, e);\n}\n\nfloat stars(float iTime, vec2 p, float count, float radius) {\n  vec2 id = floor(p * count);\n  vec2 f = fract(p * count + vec2(0.5 * id.y, 0)) - 0.5;\n  float m = 0.;\n  if (rand(id.yx + vec2(0.117, 0.2)) > 0.97) {\n    float star = abs(\n      (0.1 / length(f) - radius) // Size.\n      * (-0.25 + rand(id) * sin(3. * T) * cos(T)) // Brightness.\n    );\n    m += star * star;\n    m = clamp(m * (-p.y + 0.1), 0., 1.);\n  }\n  return m;\n}\n\nvec3 grid(vec2 p, float count, float zOffset, vec2 scaler, vec3 thickness) {\n  p = (p + vec2(0, zOffset)) / (p.y * scaler);\n  p = fract(count * p);\n  float grid = 1. - smoothstep(0.0, thickness.x, p.x)\n    * smoothstep(0.0, thickness.x, 1.0 - p.x)\n    * smoothstep(0.0, thickness.y, p.y)\n    * smoothstep(0.0, thickness.y, 1.0 - p.y);\n  float glow = 1. - smoothstep(0.0, 15.0 * thickness.y, 1.0 - p.y)\n    * smoothstep(0.0, 3. * thickness.x, p.x)\n    * smoothstep(0.0, 3. * thickness.x, 1.0 - p.x) ;\n  return mix(\n    C_PLANE + 0.25 * H,\n    H == vec3(0) ? C_GRID : H,\n    pow(grid, thickness.z)\n  ) + 0.25 * (C_PURPLE + H) * glow;\n}\n\nvec3 pane(vec2 p, float offset, vec2 size, float skew, vec3 color, float opacity) {\n  float z = PANE_Z;\n  #ifdef DO_INTRO\n    z += 0.1 * (1.0 - clamp(float(iFrame) / INTRO_FRAMES, 0., 1.));\n  #endif\n  float pane = sdParallelogram(p + vec2(offset, size.y - HORIZON - z), size, skew);\n  pane = step(0., -900. * pane);\n  if (pane > 0.) return opacity * color * pane * clamp(max(0., -p.y + HORIZON + z), 0., 1.);\n  return vec3(0);\n}\n\n/*\n// Range t from 0 to 1. Make count odd.\nvec3 photons(vec2 p, float t, float count, float offset, vec3 size, float mode) {\n  //vec2 gp = p * count;\n  vec2 id = floor(p * count);\n  id = vec2(0);\n  //if (abs(id.x) > 0.5 * count || id.y > 0.) return vec3(0);\n  //gp = fract(gp) - 0.5;\n\n  vec2 start = vec2(-0.1 * (0.5 * count - id.x), 2);\n  start = vec2(0, 2);\n  vec2 target = vec2(0, -0.25);\n  target = mix(target, vec2(-1, -2), pow(smoothstep(0.75, 1., t), 2.));\n\n  float scaler = mix(1., 3., clamp(t / 0.75, 0., 1.)) // Overall scale down as t grows (\"Z depth\").\n    * mix(1., 2., smoothstep(0.55, 1., t)); // More dramaric scale down as t passes curve.\n\n  vec2 persp = 1. / mix(\n    vec2(1, abs(p.y)),\n    vec2(1),\n    smoothstep(0.6, 1., t)\n  );\n\n  p = scaler * (p - persp * mix(start, target, t));\n  p = mix(p, rot(p, -0.56), smoothstep(0.75, 0.99, t));\n\n  vec2 f = fract(p * count) - 0.5;\n  //id = floor(p * count);\n  //p = vec2(f.x, p.y * count);\n\n  float photon = sdCap(p, size.x, size.y, size.z);\n  photon = min(1., max(0., mode == 0. ? (-1. / photon) : (mode * photon)));\n  float r = rand(vec2(id.x, 0.117));\n  vec3 col = r < 0.33 ? C_PHO_PINK : r < 0.66 ? C_PHO_YELL : C_PHO_BLUE;\n  return photon * col;\n////\n  vec2 ground = (p + vec2(0, -2) + 2. * t * vec2(0, 2. - HORIZON - PANE_Z)) / (p.y * vec2(3, 1));\n  vec2 upright = ((rot(p + vec2(0, -HORIZON) + (2. * (t - 0.5)) * vec2(1.2, 2.), -0.54))) / 0.25;// / (0.015 * count * size);\n  vec2 path = t < 0.5 ? ground : upright;\n  //if (t > 0.5 && t < 0.525) path = mix(ground, upright, 0.75 + t) ;//clamp((t - 0.6) / 0.15, 0., 1.));\n\n  vec2 guv = count * path;\n  id = floor(guv);\n  f = fract(guv) - 0.5;\n\n  if (abs(id.x) < count) {//0.5 * count) {\n    vec2 off = vec2(0, offset * 2. * (-0.5 + rand(vec2(id.x))));\n    float //photon = length(vec2(f.x, path.y * count) - off) - size.x;\n    photon = sdCap(vec2(f.x, path.y * count) - off, size.x, size.y, size.z);\n    photon = min(1., max(0., mode == 0. ? (-1. / photon) : (mode * photon)));\n    float r = rand(vec2(id.x, 0.117));\n    vec3 col = r < 0.33 ? C_PHO_PINK : r < 0.66 ? C_PHO_YELL : C_PHO_BLUE;\n    return photon * col;\n  }\n  return vec3(0);\n}\n\nvec3 trailPhotons(float iTime, vec2 uv, float speed, float offset, float count, vec3 size) {\n  #ifdef DO_PHOTON_PAUSE\n    if (mod(floor(speed * T + offset), 2.) == 1.) return vec3(0);\n  #endif\n  vec3 c = vec3(0);\n  float t = speed * T + offset;\n  float tt = sin(PI * pow(fract(t), 0.5));\n  float off = 6. + 10. * tt * tt * tt;\n\n  vec3 photon = photons(uv, fract(t), count, off,\n    size + vec3(0, 0, 3. * pow(smoothstep(0.7, 1., fract(t)), 2.)),\n    0.\n  );\n  c += photon;\n  photon = photons(uv + vec2(0.0, -0.0),\n    fract(t), count, off,\n    size + vec3(0.05, 0.05, 0.05 + 3. * pow(smoothstep(0.7, 1., fract(t)), 2.)),\n    -5.\n  );\n  c = screen(c, 2. * photon);\n  return c;\n}\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = UV;\n  vec2 fov = FOV; // Modifies uv.\n  \n  // Sky, stars, and ground plane.\n  vec3 c = mix(vec3(0.01), C_PURPLE + H, sky(uv));\n  c = screen(c, (vec3(1) - H) * stars(T, uv, 40., 0.25));\n  if (uv.y > HORIZON) c = grid(\n    uv, 3.1, 1.5, // uv, gridCount, zOffset\n    vec2(3.15, 2), // scaler\n    vec3(0.02, 0.04, 5.) // x, y: thickness, z: density\n  );\n  // Standard then noisey fog.\n  c = mix(c, 0.05 * c + 0.95 * C_FOG + H, fog(uv, 4.));\n  c -= 0.025 * fog(uv + 0.2 * rand(uv + sin(0.25 * T)), 10.);\n  // Background stacked parallelograms.\n  float w = 0.;\n  float skewer = 0.;\n  #ifdef DO_INTRO\n    w = 0.25 * sin(1.571 + 1.571 * pow(clamp(float(iFrame) / INTRO_FRAMES, 0., 1.), 0.5));\n  #endif\n  c += pane(uv, 0.3 + 0.2 * sin(0.125 * T), vec2(0.30 + w, 1.), 0.6 - skewer, C_PURPLE + H, 0.3);\n  c += pane(uv, 0.6 + 0.2 * cos(0.1 * T),   vec2(0.30 + w, 1.), 0.6 - skewer, C_PURPLE + H, 0.3);\n  c += pane(uv, 0.3 + 0.1 * (1. + sin(0.075 * T)), vec2(0.20 + w, 1.), 0.6 - skewer, C_PANE + H, 0.8);\n  c += pane(uv, 0.4 + 0.1 * sin(100. + 0.175 * T), vec2(0.15 + w, 1.), 0.6 - skewer, C_PANE + H, 1.1);\n  c += pane(uv, 0.3 + 0.05 * sin(200. + 0.25 * T), vec2(0.15 + w, 1.), 0.6 - skewer, C_PANE + H, 1.1);\n\n  fragColor = vec4(c, 1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//// Flags.\n//#define IS_INTERACTIVE\n//#define DO_HUE_SHIFT\n#define DO_INTRO\n#define DO_REFLECTION\n//#define DO_PHOTON_PAUSE\n\n//// Parameters.\n#define SKY_FADE     0.4\n#define HORIZON      0.1 // Greater than 0, less than ~0.5.\n#define PANE_Z       0.05\n#define INTRO_FRAMES 100.\n//#define PHOTON_SPEED 0.3\n\n//// Colors.\n#define C_PLANE  vec3(0.025, 0, 0.05)\n#define C_FOG    vec3(0.3, 0, 0.5)\n#define C_PANE   vec3(0.5, 0.1, 0.5)\n#define C_PURPLE vec3(0.5, 0, 1)\n#define C_GRID   vec3(0.9, 0, 0.7)\n\n//#define C_PHO_PINK vec3(0.9, 0.3, 0.75)\n//#define C_PHO_YELL vec3(1, 1, 0.4)\n//#define C_PHO_BLUE vec3(0.2, 0.4, 1)\n\n//// Constants.\n#define PI 3.14159265\n#define PI2 1.57079633\n\n//// Macros.\n#define M   iMouse\n#define R   iResolution\n#define UV  (0.5 * R.xy - fragCoord.xy) / min(R.x, R.y)\n#define FOV zoom(uv, M.xy / R.xy, iFrame < 1 ? 1. : clamp(float(iFrame) / INTRO_FRAMES, 0., 1.))\n\n#ifdef IS_INTERACTIVE\n  #define T (50. * M.x / R.x + iTime)\n#else\n  #define T iTime\n#endif\n\n#ifdef DO_HUE_SHIFT\n  #define H (M.z > 0.0 ? 0.5 * vec3(M.xy / R.xy, sin(0.5 * T)) : vec3(0))\n#else\n  #define H vec3(0)\n#endif\n\n//// Utilities.\n\n// Screen blend mode for colors [a] and [b].\n#define screen(a, b) (a + b * (1. - a))\n\n// Pseudo-random float out based on vec2 [seed] in.\nfloat rand(vec2 seed) { return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453); }\n\n// Rotate point [p] by [a] radians.\nvec2 rot(vec2 p, float a) {\n  float s = sin(a), c = cos(a);\n  mat2 m = mat2(c, s, -s, c);\n  return p * m;\n}\n\n// Control FOV to zoom scene during intro or interaction.\n//\n// Control zoom with vec2 [i]. Intro progress value is [t].\n// Calculates and returns the FOV vec2 by which the inout\n// [p] is multiplied first.\nvec2 zoom(inout vec2 p, vec2 i, float t) {\n  vec2 fov = vec2(1);\n  #ifdef DO_INTRO\n    fov = vec2(0.5) + vec2(tan(0.5 * -cos(PI * t)));\n  #endif\n  #ifdef IS_INTERACTIVE\n    fov += vec2(0.25) + i.y;\n    p.x += -0.4 + i.x;\n    //p = rot(p, PI * -i.y);\n    fov = rot(rot(fov, 0.5 * PI * i.y), -PI * i.x); // Inversion.\n  #endif\n  #if defined IS_INTERACTIVE || defined DO_INTRO\n    p *= fov;\n  #endif\n  return fov;\n}\n\n//// SDFs and CSG.\n\n// From Inigo Quilez (License: MIT).\n//\n// Signed distance of vec2 [p] from a parallelogram defined\n// by width and height [size] and [skew] angle in radians.\nfloat sdParallelogram(vec2 p, vec2 size, float skew) {\n  vec2 e = vec2(skew, size.y);\n  p = (p.y < 0.0) ? -p : p;\n  vec2 w = p - e;\n  w.x -= clamp(w.x, -size.x, size.x);\n  vec2 d = vec2(dot(w, w), -w.y);\n  float s = p.x * e.y - p.y * e.x;\n  p = (s < 0.0) ? -p : p;\n  vec2 v = p - vec2(size.x, 0);\n  v -= e * clamp(dot(v, e) / dot(e, e), -1.0, 1.0);\n  d = min(d, vec2(dot(v, v), size.x * size.y - abs(s)));\n  return sqrt(d.x) * sign(-d.y);\n}\n\n// From Inigo Quilez (License: MIT).\n//\n// Signed distance of vec2 [p] from a capsule defined by\n// height [h] and radii [r1], [r2].\nfloat sdCap(vec2 p, float r1, float r2, float h) {\n  p.x = abs(p.x);\n  float b = (r1 - r2) / h;\n  float a = sqrt(1. - b * b);\n  float k = dot(p, vec2(-b, a));\n  if (k < 0.) return length(p) - r1;\n  if (k > a * h) return length(p - vec2(0., h)) - r2;\n  return dot(p, vec2(a, b)) - r1;\n}\n","name":"Common","description":"","type":"common"}]}