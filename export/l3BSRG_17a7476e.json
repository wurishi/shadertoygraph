{"ver":"0.1","info":{"id":"l3BSRG","date":"1710734017","viewed":70,"name":"Implicit surfaces","username":"Rogolop","description":"Viewer for implicit surfaces (works decently for low degree algebraic singularities)\n- Rotate with mouse, hold down E to zoom in\n- Change surface by editing the first line\n","likes":8,"published":1,"flags":16,"usePreview":0,"tags":["3d","plot","implicit","viewer","sruface"],"hasliked":0,"parentid":"M3jXD1","parentname":"3D implicit test 3"},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define shape 51\n\n// Perspective or orthographic camera (0-1)\n#define perspective 1\n// Surface cloring modes (1-8)\n#define colorMode 4\n// Surface decoration pattern (0-8)\n#define surfacePattern 8\n// Background / environment (0-7)\n#define background 5\n// (0-1)\n#define showBoundingCube 1\n// (0-3)\n#define shading 2\n\nconst float boundingBoxRadius = 1.01;\nconst vec2 initMouse = vec2(0.1,0.);\n\n// Numerical solver settings\nconst int subdivisions = 100;\nconst int maxIter = 5;\nconst float EPS = 1e-5;\nconst float fEPS = 1e-6; // <- CHANGE THIS IF noisy surface / \"swollen\" singularity\n\n////////////////////////////////////////////////////////////////////////////////\n\n// Error codes / debug colors\n// bright yellow\n#define BINGO vec3(1.,1.,0.)\n// black\n#define NOBOUNDHIT vec3(0.,0.,0.)\n// greenish blue\n#define MAXITERREACHED vec3(0.,0.7,0.7)\n// olive\n#define MAXDISTREACHED vec3(0.7,0.7,0.)\n// pink\n#define ESCAPEDBOUNDS vec3(0.7,0.,0.7)\nconst vec3 NOHIT = vec3(0.2, 0., 0.6);\n\n// Keyboard input\n#define checkKey(key) ( texture(iChannel1, vec2(key, 0.25)).x > 0.5 )\nconst float KEY_E     = 69.5/256.0;\n\n// Utils\n#define PI 3.14159265359\n#define cubemap(dir) ( texture(iChannel0, vec3(dir.x, dir.z, dir.y)).rgb )\nfloat max3(float a, float b, float c) { return max(max(a,b),c); }\nfloat smax(float a, float b) {\n    float alpha = 20.0;\n    return (a*exp(a*alpha) + b*exp(b*alpha)) / (exp(a*alpha)+exp(b*alpha));\n}\nfloat smax3(float a, float b, float c) { return smax(smax(a,b),c); }\nfloat infinityNorm(vec3 v) { v = abs(v); return max3(v.x,v.y,v.z); }\n\n////////////////////////////////////////////////////////////////////////////////\n\n// Implicit equation of the surface\nfloat f(vec3 pos) {\n    float scale = 1.;\n    vec3 center = vec3(0.);\n    switch (shape) {\n        case 20: scale = 7.; break;\n        case 21: scale = 3.; break;\n        case 22: scale = 1.5; break;\n        case 26: scale = 0.8; center = vec3(0.,0.,-0.4); break;\n        case 27: scale = 4.; break;\n        case 28: scale = 1.5; break;\n        case 29: scale = 1.5; center = vec3(0.,0.,1.); break;\n        case 30: scale = 2.; break;\n        case 31: scale = 2.; break;\n        case 33: scale = 7.; break;\n        case 35: scale = 2.; break;\n        case 37: scale = 1.25; break;\n        case 41: scale = 2.; break;\n        case 42: scale = 3.; break;\n        case 43: scale = 2.; break;\n        case 46: scale = 3.2; break;\n        case 50: scale = 3.; break;\n        case 51: scale = 0.9; center = vec3(0.,0.3,0.); break;\n    }\n    float x = pos.x*scale + center.x;\n    float y = pos.y*scale + center.y;\n    float z = pos.z*scale + center.z;\n    pos = vec3(x,y,z);\n    float x2 = x*x;\n    float x3 = x*x2;\n    float x4 = x*x3;\n    float y2 = y*y;\n    float y3 = y*y2;\n    float y4 = y*y3;\n    float z2 = z*z;\n    float z3 = z*z2;\n    float z4 = z*z3;\n    float R, R2, r, r2, term, v, v2, t, t2, t3;\n    \n    switch (shape) {\n    case 1: return x; // plane\n    case 2: return x*x + y*y + z*z - 1.; // sphere\n    case 3: return -(x*x + y*y + z*z - 1.); // inside out sphere\n    case 4: return infinityNorm(pos)-1.; // cube\n    case 5: return x*y - z; // hyperbolic paraboloid\n    case 6: return x*x-y*y*y; // cusp sheet\n    case 7: return x*x-y*y*(y+1.); // nodal cubic sheet\n    case 8: return x*x; // double plane\n    case 9: return (x*x-z)*(y*y+z); // parabolic sheets tangent at 1 point\n    case 10: return (x*x-z)*(x*x+z); // parabolic sheets tangent at 1 line\n    case 11: return x*y*z; // coordinate planes\n    case 12: return x*x+y*y-z*z; // cone\n    case 13: return x*x+y*y-0.9*z*z-0.04; // one-sheet hyperboloid\n    case 14: return x*x+y*y-0.9*z*z+0.04; // two-sheet hyperboloid\n    case 15: return x*x-y*y*z; // Whitney umbrella\n    case 16: return x*x+y*y*z; // Whitney umbrella upside down\n    case 17: // swallowtail\n        return -4.*x3*y2-27.*y4-16.*z*x4-128.*z2*x2-144.*z*y2*x-256.*z3;\n    case 18: // torus\n        R = 0.8; r = 0.45;\n        term = (x2+y2+z2+R*R-r*r); return term*term - 4.*R*R*(x2+y2);\n    case 19: // gyroid\n        return sin(x*4.)*cos(y*4.)+sin(y*4.)*cos(z*4.)+sin(z*4.)*cos(x*4.);\n    case 20: // mucube\n        return smax3(sin(x)*sin(y),sin(y)*sin(z),sin(z)*sin(x));\n    case 21: // tetrahedral surface\n        return (x2+y2+z2)*(x2+y2+z2)+8.*x*y*z-10.*(x2+y2+z2)+25.;\n    case 22: // Kummer surface\n        v = 1.2; v2 = v*v;\n        return (3.-v2)*(x2+y2+z2-v2)*(x2+y2+z2-v2)-\n            (3.*v2-1.)*(1.-z-x*sqrt(2.))*(1.-z+x*sqrt(2.))*(1.+z+y*sqrt(2.))*\n            (1.+z-y*sqrt(2.));\n    case 23: return -x3-y2-z2; // A2 (--)\n    case 24: return x3+y2-z2; // A2 (+-)\n    case 25: return x2+x*z2+y2*z; // Hunt D5\n    case 26: return -0.8*(2.*x3-6.*x*y2)+1.*z3+0.8*z2; // Cayley 2\n    case 27: return 4.*(x2+y2+z2-13.)*(x2+y2+z2-13.)*(x2+y2+z2-13.)+27.*(3.*x2+y2-4.*z2-12.)*(3.*x2+y2-4.*z2-12.); // Hunt's surface\n    case 28: return x2*y2+y2*z2+z2*x2-2.*x*y*z; // Steiner's roman surface\n    case 29: // Boy's surface\n        return 64.*(1.-z)*(1.-z)*(1.-z)*z3-\n            48.*(1.-z)*(1.-z)*z2*(3.*x2+3.*y2+2.*z2)+\n            12.*(1.-z)*z*(\n                27.*(x2+y2)*(x2+y2)-\n                24.*z2*(x2+y2)+\n                36.*sqrt(2.)*y*z*(y2-3.*x2)+\n                4.*z4)+\n            (9.*x2+9.*y2-2.*z2)*(\n                -81.*(x2+y2)*(x2+y2)-\n                72.*z2*(x2+y2)+\n                108.*sqrt(2.)*x*z*(x2-3.*y2)+4.*z4);\n    case 30: // Bohemian star\n        r = 1.; float r2 = r*r;\n        return y4*((x2+y2+z2)*(x2+y2+z2)-4.*r2*(x2+z2))-16.*r2*x2*z2*(y2-r2);\n    case 31: // Bohemian dome\n        return 2.*x2*y2-2.*x2*z2+x4-4.*y2+2.*y2*z2+y4+z4;\n    case 32: // Periodic rounded cubes\n        return sin(x*4.)*sin(y*4.)+sin(y*4.)*sin(z*4.)+sin(z*4.)*sin(x*4.);\n    case 33: // Periodic incomplete spheres\n        return (0.5-mod(x,1.))*(0.5-mod(x,1.))+(0.5-mod(y,1.))*(0.5-mod(y,1.))+(0.5-mod(z,1.))*(0.5-mod(z,1.))-0.4;\n    case 34: return z2*(-z+1.)-x2-y2; // revolution of nodal cubic\n    case 35: // genus 2 surface\n        return 2.*y*(y2-3.*x2)*(1.-z2) + (x2+y2)*(x2+y2) - (9.*z2-1.)*(1.-z2);\n    case 36: // Equipotential surface of point charges\n        vec3 p1 = vec3(-0.3,-0.3,-0.3);\n        vec3 p2 = vec3(-0.3,+0.3,+0.3);\n        vec3 p3 = vec3(+0.3,-0.3,+0.3);\n        vec3 p4 = vec3(+0.3,+0.3,-0.3);\n        v = 7.+3.*asin(0.9*asin(sin(iTime))/PI*2.)/PI*2.;\n        return -v+1./distance(pos,p1)+1./distance(pos,p2)+1./distance(pos,p3)+1./distance(pos,p4);\n    case 37: // 3 tori\n        R = 1.; r = 0.2; R2 = R*R; v = 0.01;\n        term = (x2+y2+z2+R*R-r*r); term = term*term;\n        return (term-4.*R2*(x2+y2))*(term-4.*R2*(x2+z2))*(term-4.*R2*(y2+z2))-v;\n    case 38: // 3d astroid v2\n        r = 1.; r2 = r*r;\n        return (x2+y2+z2-r2)*(x2+y2+z2-r2)*(x2+y2+z2-r2)+27.*r2*(x2*y2+y2*z2+z2*x2);\n    case 39: // 3d astroid v2\n        return pow(x2,1./3.)+pow(y2,1./3.)+pow(z2,1./3.)-1.;\n    case 40: // blowup (compressed z)\n        return x - 7.*y*z/(1.-z2);\n    // https://www.imaginary.org/gallery/herwig-hauser-classic\n    case 41: return (x2+y2)*(x2+y2)*(x2+y2)-x2*y2*(4.*z2+1.);\n    case 42: return -6.*x2+2.*x4+y2*z2;\n    case 43: return x2*z2+z4-y2-z3;\n    case 44: return -x2+y2*z2+z3;\n    case 45: return 1.*(x2+y2)*z4-(1.-x2-y2-z2)*(1.-x2-y2-z2)*(1.-x2-y2-z2);\n    case 46: return x2*y*z+x2*z2+2.*y3*z+3.*y3;\n    case 47: return 3.*(x2+z2)-(1.-y2)*(1.-y2)*(1.-y2);\n    case 48: return z*y-x2;\n    case 49: return y3*y2-x*z;\n    case 50: return x2 - z4 + y*x2*z2;\n    case 51: // deformation E7 into four A1's (Greuel, Lossen, Shustin, Introduction to Singularities and Deformations)\n        t = 0.4*(1.+asin(sin(iTime))/PI*2.); t2=t*t; t3=t*t2;\n        return x2 - (-z + sqrt(4.*t3/27.))*(z2-y2*(-y+t*1.2));\n    }\n    return 1.;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nstruct Intersection {\n  bool intersects;\n  float start;\n  float end;\n};\n\n// Ray intersection (only forward) with cube of \"radius\" b centered at origin\n// Source: adapted from https://tavianator.com/2011/ray_box.html\nIntersection boxIntersection(vec3 pos, vec3 dir, vec3 b) {\n    vec3 invDir = 1./dir;\n    \n    float t1 = (-b.x - pos.x)*invDir.x;\n    float t2 = (b.x - pos.x)*invDir.x;\n    \n    float tmin = min(t1, t2);\n    float tmax = max(t1, t2);\n    \n    t1 = (-b.y - pos.y)*invDir.y;\n    t2 = (b.y - pos.y)*invDir.y;\n    \n    tmin = max(tmin, min(t1, t2));\n    tmax = min(tmax, max(t1, t2));\n    \n    t1 = (-b.z - pos.z)*invDir.z;\n    t2 = (b.z - pos.z)*invDir.z;\n    \n    tmin = max(tmin, min(t1, t2));\n    tmax = min(tmax, max(t1, t2));\n    \n    if (tmin > tmax || tmax < 0.) return Intersection(false, 0., 0.);\n    tmin = max(tmin, 0.);\n    tmax = max(tmax, 0.);\n    return Intersection(true, tmin, tmax);\n}\n\nvec3 gradf(vec3 pos) {\n    return vec3(f(pos+vec3(EPS,0.,0.)) - f(pos-vec3(EPS,0.,0.)),\n                f(pos+vec3(0.,EPS,0.)) - f(pos-vec3(0.,EPS,0.)),\n                f(pos+vec3(0.,0.,EPS)) - f(pos-vec3(0.,0.,EPS))\n                )  / (2.*EPS);\n}\n\nvec3 raycast(vec3 pos, vec3 dir) {\n    //float dist = 0.;\n    float F;\n    float dfdl;\n    float dl;\n    \n    Intersection I = boxIntersection(pos, dir, vec3(boundingBoxRadius));\n    if (!I.intersects) return NOBOUNDHIT;\n    // move to intersection start point\n    //dl = I.start;\n    //pos += dir*dl;\n    //dist += dl;\n    \n    vec3 left = pos + I.start * dir;\n    vec3 right = pos + I.end * dir;\n    \n    float invdubdiv = 1./float(subdivisions);\n    float substep = (I.end-I.start)/float(subdivisions);\n    float q, l;\n    for (int i=0; i < subdivisions; i++) {\n        q = (float(i)+0.5)*invdubdiv;\n        pos = mix(left, right, q);\n        F = f(pos);\n        if (abs(F) < fEPS) return pos;\n        // Newton step\n        dfdl = (f(pos+EPS*dir) - f(pos-EPS*dir)) / (2.*EPS);\n        dl = -F/dfdl;\n        l = dl;\n        //if (F < 0.) return BINGO;\n        pos += dl*dir;\n        // try to find root in this interval\n        for (int i=0; i < maxIter; i++) {\n            if (infinityNorm(pos)>boundingBoxRadius) break;\n            F = f(pos);\n            if (abs(F) < fEPS) return pos;\n            if (abs(l) > substep) break;\n            // Newton step\n            dfdl = (f(pos+EPS*dir) - f(pos-EPS*dir)) / (2.*EPS); // directional derivative along ray\n            dl = -F/dfdl;\n            l += dl;\n            pos += dl*dir;\n\n            //if (dl < -0.0 && (abs(F) > 0.01)) dl = 0.01;\n            //dl = min(dl, 0.1);\n        }\n    }\n    \n    return NOHIT;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.*(fragCoord-iResolution.xy/2.)/iResolution.y; // contains [-1,1]^2\n    vec3 col = vec3(0.);\n    \n    // Camera rays\n    vec3 camPos = vec3(4.,0.,0.);\n    vec3 camDir = - normalize(camPos);\n    vec3 rayPos, rayDir;\n    float zoom = 1.;\n    if (checkKey(KEY_E)) zoom = 0.5;\n    float fov = 0.4*zoom;\n    float fov_ortho = 1.5*zoom;\n    #if perspective\n        // perspective cam\n        rayPos = camPos;\n        rayDir = normalize(camDir + fov*vec3(0., uv.x, uv.y));\n    #else\n        // orthographic cam\n        rayPos = camPos + fov_ortho*vec3(0., uv.x, uv.y);\n        rayDir = camDir;\n    #endif\n    // for perspective background in orthographic mode\n    vec3 cubemapDir = normalize(camDir + fov*vec3(0., uv.x, uv.y));\n    \n    // Mouse-controlled rotation\n    vec2 mouse = iMouse.xy == vec2(0.,0.) ? initMouse : (iMouse.xy/iResolution.xy - 0.5);\n    float yaw = clamp(- mouse.x * 2.*PI * 1., -PI,PI);\n    float pitch = clamp( mouse.y * PI * 1.2, -PI*0.5, PI*0.5);\n    // pitch and yaw rotations (column-wise matrices)\n    mat3 rot = mat3(cos(yaw), sin(yaw), 0., -sin(yaw), cos(yaw), 0., 0., 0., 1.);\n    rot = rot * mat3(cos(pitch), 0., -sin(pitch), 0., 1., 0., sin(pitch), 0., cos(pitch));\n    // apply\n    camPos = rot*camPos;\n    camDir = rot*camDir;\n    rayPos = rot*rayPos;\n    rayDir = rot*rayDir;\n    cubemapDir = rot*cubemapDir;\n    \n    //cubemapDir = vec3(cubemapDir.x, cubemapDir.z, cubemapDir.y);\n    \n    vec3 hitPoint = raycast(rayPos, rayDir);\n    \n    if (hitPoint == BINGO) { fragColor = vec4(BINGO,1.0); return; }\n    //if (hitPoint == NOHIT) { fragColor = vec4(NOHIT,1.0); return; }\n    //if (hitPoint == NOBOUNDHIT) { fragColor = vec4(NOBOUNDHIT,1.0); return; }\n    //if (hitPoint == ESCAPEDBOUNDS) { fragColor = vec4(ESCAPEDBOUNDS,1.0); return; }\n    //if (hitPoint == MAXDISTREACHED) { fragColor = vec4(MAXDISTREACHED,1.0); return; }\n    //if (hitPoint == MAXITERREACHED) { fragColor = vec4(MAXITERREACHED,1.0); return; }\n    \n    if (hitPoint == NOBOUNDHIT  || hitPoint == NOHIT || hitPoint == ESCAPEDBOUNDS || hitPoint == MAXITERREACHED) {\n        //fragColor = vec4(vec3(0.2),1.0); return;\n        \n        #if background==1\n        col = vec3(0.2);\n        \n        #elif background==2\n        col = vec3(0.5);\n        \n        #elif background==3\n        col = vec3(0.8);\n        \n        #elif background==4\n        col = vec3(1.);\n        \n        #elif background==5\n        // Real life environment\n        col = 1. * cubemap(cubemapDir);\n        \n        #elif background==6\n        // Stylized sky\n        if (cubemapDir.z > 0.) {\n            col = mix(vec3(0.7,1.,1.), vec3(0.5,0.7,0.9), sqrt(cubemapDir.z));\n        } else {\n            col = mix(vec3(0.5,0.6,0.7),vec3(0.3,0.3,0.3),asin(-cubemapDir.z));\n        }\n        \n        #elif background==7\n        // Sphere slices\n        \n        //col = mix(vec3(0.2), vec3(0.7,1.,1.), clamp(0.5+4.*dot(normalize(cubemapDir),normalize(vec3(0.,0.,1.))), 0., 1.));\n        col = vec3(0.4);\n        \n        float linewidthSky = 0.003;\n        float gridStepSky = 0.2;\n        float gridAlpha = 0.3;\n        col = mix(col,vec3(1.,0.,0.),gridAlpha*(1.-step(linewidthSky,mod(asin(cubemapDir.x)+linewidthSky/2.,gridStepSky))));\n        col = mix(col,vec3(0.,1.,0.),gridAlpha*(1.-step(linewidthSky,mod(asin(cubemapDir.y)+linewidthSky/2.,gridStepSky))));\n        col = mix(col,vec3(0.,0.,1.),gridAlpha*(1.-step(linewidthSky,mod(asin(cubemapDir.z)+linewidthSky/2.,gridStepSky))));\n        \n        #else\n        col = vec3(0.);\n        \n        #endif\n        \n        #if showBoundingCube\n        // darken bounding cube\n        if (hitPoint != NOBOUNDHIT) { col *= vec3(0.7); }\n        #endif\n\n        fragColor = vec4(col,1.0); return;\n    }\n    \n    \n    vec3 grad = gradf(hitPoint+1.1*EPS*(-rayDir));\n    float s = -sign(dot(grad,rayDir));\n    \n    // -- Color\n    \n    #if colorMode==1\n    // one color per side\n    col = mix(vec3(0.,0.7,1.),vec3(1.,0.5,0.),0.5+0.5*s);\n    \n    #elif colorMode==2\n    // by distance to camera\n    float hue = 3.*length(hitPoint - camPos);\n    col = 0.5+0.5*vec3(cos(hue),cos(hue+2.*PI/3.),cos(hue+4.*PI/3.));\n    col /= length(col)*0.7;\n    \n    #elif colorMode==3\n    // by normal direction\n    col = 0.65+0.35*grad/infinityNorm(grad);\n    \n    #elif colorMode==4\n    // by normal direction per side\n    col = 0.65+0.35*s*grad/infinityNorm(grad);\n    \n    #elif colorMode==5\n    // by location in space\n    col = 0.1 + 0.8*(boundingBoxRadius+hitPoint)/2.;\n    \n    #elif colorMode==6\n    // by z coordinate\n    float hue = 2.*PI*(0.5+0.5*(hitPoint.z/boundingBoxRadius));\n    col = 0.5+0.5*vec3(cos(hue),cos(hue+2.*PI/3.),cos(hue+4.*PI/3.));\n    //col = mix(vec3(0.,0.6,0.7),vec3(1.,0.5,0.),clamp(0.5+0.5*hitPoint.z,0.,1.));\n    //col /= infinityNorm(col)*1.1;\n    col /= length(col)*0.7;\n    \n    #elif colorMode==7\n    // gray\n    col = vec3(0.8);//vec3(0.5+0.1*dot(s*grad,vec3(0.,0.,1.)));\n    \n    #elif colorMode==8\n    // white\n    col = vec3(1.);\n    \n    #endif\n    col = clamp(col, 0., 1.);\n    \n    // -- Surface pattern\n    float gridStep = 0.081;\n    float linewidth = 0.1*gridStep;\n    \n    #if surfacePattern==1\n    // Colored coordinate planes\n    col = mix(col,vec3(1.,0.,0.),0.2*(1.-step(linewidth,mod(hitPoint.x+linewidth/2.,gridStep))));\n    col = mix(col,vec3(0.,1.,0.),0.2*(1.-step(linewidth,mod(hitPoint.y+linewidth/2.,gridStep))));\n    col = mix(col,vec3(0.,0.,1.),0.2*(1.-step(linewidth,mod(hitPoint.z+linewidth/2.,gridStep))));\n    \n    #elif surfacePattern==2\n    // additive transparent black coordinate planes\n    col = mix(col,vec3(0.),0.2*(1.-step(linewidth,mod(hitPoint.x+linewidth/2.,gridStep))));\n    col = mix(col,vec3(0.),0.2*(1.-step(linewidth,mod(hitPoint.y+linewidth/2.,gridStep))));\n    col = mix(col,vec3(0.),0.2*(1.-step(linewidth,mod(hitPoint.z+linewidth/2.,gridStep))));\n    \n    #elif surfacePattern==3\n    // combined transparent black displaced coordinate planes\n    col = mix(col,vec3(0.),0.2*(1.-min(min(\n                step(linewidth,mod(hitPoint.x+linewidth/2.+gridStep/2.,gridStep)),\n                step(linewidth,mod(hitPoint.y+linewidth/2.+gridStep/2.,gridStep))),\n                step(linewidth,mod(hitPoint.z+linewidth/2.+gridStep/2.,gridStep)))));\n    \n    #elif surfacePattern==4\n    // gyroid\n    gridStep *= 0.3;\n    col = mix(col,vec3(0.),0.2*(1.-step(0.2,abs(\n        sin(hitPoint.x/gridStep)*cos(hitPoint.y/gridStep)+\n        sin(hitPoint.y/gridStep)*cos(hitPoint.z/gridStep)+\n        sin(hitPoint.z/gridStep)*cos(hitPoint.x/gridStep)))));\n    \n    #elif surfacePattern==5\n    // mucube (not as expected)\n    col = mix(col,vec3(0.),0.2*(1.-step(0.1,abs(smax3(\n        sin(hitPoint.x/gridStep)*sin(hitPoint.y/gridStep),\n        sin(hitPoint.y/gridStep)*sin(hitPoint.z/gridStep),\n        sin(hitPoint.z/gridStep)*sin(hitPoint.x/gridStep))))));\n    \n    #elif surfacePattern==6\n    // spheres\n    col = mix(col,vec3(0.),0.2*(1.-step(0.2,(0.5-mod(hitPoint.x/gridStep,1.))*(0.5-mod(hitPoint.x/gridStep,1.))+\n        (0.5-mod(hitPoint.y/gridStep,1.))*(0.5-mod(hitPoint.y/gridStep,1.))+\n        (0.5-mod(hitPoint.z/gridStep,1.))*(0.5-mod(hitPoint.z/gridStep,1.)))));\n    \n    #elif surfacePattern==7\n    // 3D checkerboard\n    col = mix(col,vec3(0.),0.1*mod(floor(hitPoint.x/gridStep)+floor(hitPoint.y/gridStep)+floor(hitPoint.z/gridStep),2.));\n    \n    #elif surfacePattern==8\n    // 3D checkerboard shifted\n    col = mix(col,vec3(0.),0.1*mod(floor(0.51+hitPoint.x/gridStep)+floor(0.51+hitPoint.y/gridStep)+floor(0.51+hitPoint.z/gridStep),2.));\n    \n    #endif\n    \n    // -- Shading\n    \n    float kAmbient = 0.6;\n    float kDiffuse = 0.6;\n    float kSpecular = 0.;\n    float kEnvironment = 0.1;\n    float shininess = 26.;\n    vec3 iAmbient = vec3(1.);\n    vec3 iDiffuse = vec3(1.);\n    vec3 iSpecular = vec3(1.);\n    vec3 L = normalize(vec3(0.,0.,1.)); // surface to light\n    vec3 N = normalize(s*grad); // normal\n    vec3 R = 2.*dot(L,N)*N - L; // reflected\n    vec3 V = -rayDir; // viewer\n    vec3 refl = 2.*dot(V,N)*N - V; // environment reflection\n    \n    #if shading==1||shading==2\n    // Phong shading\n    vec3 I = kAmbient*iAmbient*col +\n          kDiffuse*col*iDiffuse*max(0.,dot(L,N)) +\n          kSpecular*iSpecular*pow(max(0.,dot(R,V)),shininess);\n    \n        #if shading==2\n        // Environment reflections\n        //I += cubemap(refl);\n        //I += col*cubemap(refl);\n        I += kEnvironment*exp(5.*(cubemap(refl)-1.)); // exponential to simulate HDR environment\n        #endif\n    col = I;\n    \n    #elif shading==3\n    // Light from camera only\n    vec3 J = col*mix(0.2,1.,clamp(dot(-rayDir,N),0.,1.));\n    col = J;\n    \n    #endif\n    \n    \n    col = clamp(col, 0., 1.);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}