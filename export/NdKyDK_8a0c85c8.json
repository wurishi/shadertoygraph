{"ver":"0.1","info":{"id":"NdKyDK","date":"1655656627","viewed":96,"name":"Cubic SDF With L1 Metric","username":"Envy24","description":"Cubic Curve SDF With L1 Metric.\nhttps://www.desmos.com/calculator/mkkpftyxxx","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf","cube","space","cubic","metric","root","l1","vieta"],"hasliked":0,"parentid":"NdycWV","parentname":"Quadratic SDF With L1 Metric"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define NZMX                      ( (iMouse.x+iMouse.x-R.x) / R.x )  // in range [-1.0; 1.0]\n#define NZMY                      ( (iMouse.y+iMouse.y-R.y) / R.y )  // in range [-1.0; 1.0]\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n\nfloat L1(vec2 B, vec2 E)\n{\n    return abs(E.x - B.x) + abs(E.y - B.y);\n}\n\n#define Y(x) (s*x*x*x+n*x*x+m*x+k)\nfloat cubicSDF_L1(\n    vec2 NDC,\n    float s,\n    float n,\n    float m,\n    float k)\n{\n    float inv6s = 1. / (6.*s);\n    float D0 = 4.*n*n-12.*s*(m+1.);\n    float D1 = 4.*n*n-12.*s*(m-1.);\n    \n    float x0 = NDC.x;\n    vec2 C0 = vec2(x0, Y(x0));  \n    float minDist = L1(C0, NDC);\n        \n    if (D0 >= 0.0)\n    {\n        float sqrtD0 = sqrt(D0);\n        float x1 = (-2.*n+sqrtD0)*inv6s;\n        float x2 = (-2.*n-sqrtD0)*inv6s;\n        vec2 C1 = vec2(x1, Y(x1));\n        vec2 C2 = vec2(x2, Y(x2));\n        minDist = min(minDist, L1(C1, NDC));\n        minDist = min(minDist, L1(C2, NDC));\n    }\n    \n    if (D1 >= 0.0)\n    {\n        float sqrtD1 = sqrt(D1);\n        float x3 = (-2.*n+sqrtD1)*inv6s;\n        float x4 = (-2.*n-sqrtD1)*inv6s;\n        vec2 C3 = vec2(x3, Y(x3));\n        vec2 C4 = vec2(x4, Y(x4));\n        minDist = min(minDist, L1(C3, NDC));\n        minDist = min(minDist, L1(C4, NDC));\n    }\n     \n    float coef[4] = float[4](\n        s, n, m, k-NDC.y\n    );\n\n    vec2 x[3];\n        \n    int num = solveCubicVieta(x, coef);\n\n    for (int i = 0; i < num; ++i)\n    {\n        vec2 C = vec2(x[i].x, Y(x[i].x));\n\n        minDist = min(minDist, L1(C, NDC));\n    }\n\n    float R = sinOSC(0.0, 0.5, iTime); // thickness;\n    return minDist - R;\n}\n\n/* IQ coloring scheme */\nvec3 colorize_field(float dist, vec3 color)\n{\n    // Change color if dist is negative.\n    color = 1.0 - sign(dist) * color;\n    \n    // Attenuate color around edges.\n\tcolor *= 1.0 - exp(-4.0 * abs(dist));\n    \n    // Add interleaved \"lines\".\n\tcolor *= 0.7 + 0.2 * cos(30.0 * dist);\n    \n    // Add white edges.\n    return mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 6./R.y, abs(dist)));\n}\n\nvec3 add_metric_box(\n    vec2 NDC,\n    float s,\n    float n,\n    float m,\n    float k,\n    vec3 color)\n{\n    float unit = 7.0 / R.y;\n\n    vec2 M = \n        LMB_IS_HOLD ?\n            TO_CENTERED_NDC(iMouse.xy) * 2.5 :\n            rotateAroundZ(vec2(1, 0), iTime * 0.25) * 1.5;\n            //vec2(0);\n            \n    // Add point\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(NDC - M) - 0.008));\n\n    float dist_form_point_to_box_edge = L1(NDC, M) - abs(cubicSDF_L1(M, s, n, m, k));\n    float outline = abs(dist_form_point_to_box_edge);\n    \n    // Add metric box\n    return mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, outline));\n}\n/* IQ coloring scheme */\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    float s = sinOSC(-4.0, 4.0, iTime * 0.2);\n    float n = sinOSC(-4.0, 4.0, iTime * 0.4);\n    float m = sinOSC(-4.0, 4.0, iTime * 0.8);\n    float k = 0.0;\n    \n    vec2 NDC = TO_CENTERED_NDC(SC) * 2.5;\n    float minDist = cubicSDF_L1(NDC, s, n, m, k);\n    \n    // Blending.\n    vec3 color = colorize_field(minDist, vec3(0.1, 0.4, 0.7));\n    color = add_metric_box(NDC, s, n, m, k, color);\n\n    O = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define TAU                         6.2831853071795862\n\n/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nvec2 rotateAroundZ(vec2 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec2(\n        p.x * c - p.y * s,\n        p.y * c + p.x * s);\n}\n\n/*\n    Calculates cube root with Newton-Raphson method.\n*/\nfloat cubeRoot(const float x)\n{\n    float xc = x;\n    float xxc = x * x;\n\n    for (int i = 0; i < 2; ++i)\n    {\n        xc = (2.0 * xc + x / xxc) * 0.33333333333333331;\n        xxc = xc * xc;\n    }\n\n    return xc;\n}\n\n/*\n    Return value:\n        1 - one real, two complex roots;\n        2 - three real roots, but root[1] == root[2];\n        3 - three real roots.\n*/\nint solveCubicVieta(\n    inout vec2[3] roots,\n    in float[4] coef)\n{\n    float oneThird = 0.33333333333333331;\n\n    float a = coef[1] / coef[0];\n    float b = coef[2] / coef[0];\n    float c = coef[3] / coef[0];\n\n    float Q = (a * a - 3.0 * b) / 9.0;\n    float R = (2.0 * a * a * a - 9.0 * a * b + 27.0 * c) / 54.0;\n\n    float S = Q * Q * Q - R * R;\n\n    if (S > 0.0)\n    {\n        float phi = oneThird * acos(R / sqrt(Q * Q * Q));\n        float Re = -2.0 * sqrt(Q);\n\n        roots[0].x = Re * cos(phi) - a * oneThird;\n        roots[0].y = 0.0;\n        roots[1].x = Re * cos(phi + TAU * oneThird) - a * oneThird;\n        roots[1].y = 0.0;\n        roots[2].x = Re * cos(phi - TAU * oneThird) - a * oneThird;\n        roots[2].y = 0.0;\n\n        return 3;\n    }\n\n    if (S < 0.0 && Q > 0.0)\n    {\n        float phi = oneThird * acosh(abs(R) / sqrt(Q * Q * Q));\n        float signR = R < 0.0 ? -1.0 : 1.0;\n\n        float sqrtQ = sqrt(Q);\n        float Re = signR * sqrtQ * cosh(phi);\n        float Im = sqrtQ * sinh(phi);\n        float sqrt3 = 1.7320508075688772;\n\n        roots[0].x = -2.0 * Re - a * oneThird;\n        roots[0].y = 0.0;\n        roots[1].x = Re - a * oneThird;\n        roots[1].y = sqrt3 * Im;\n        roots[2].x = Re - a * oneThird;\n        roots[2].y = -sqrt3 * Im;\n\n        return 1;\n    }\n\n    if (S < 0.0 && Q < 0.0)\n    {\n        float phi = oneThird * asinh(abs(R) / sqrt(abs(Q * Q * Q)));\n        float signR = R < 0.0 ? -1.0 : 1.0;\n\n        float sqrtQ = sqrt(abs(Q));\n        float Re = signR * sqrtQ * sinh(phi);\n        float Im = sqrtQ * cosh(phi);\n        float sqrt3 = 1.7320508075688772;\n\n        roots[0].x = -2.0 * Re - a * oneThird;\n        roots[0].y = 0.0;\n        roots[1].x = Re - a * oneThird;\n        roots[1].y = sqrt3 * Im;\n        roots[2].x = Re - a * oneThird;\n        roots[2].y = -sqrt3 * Im;\n\n        return 1;\n    }\n    \n    if (Q == 0.0)\n    {\n        float Re = -cubeRoot(c - a * a * a / 27.0) - a / 3.0;\n        float Im = sqrt(abs(a - 3.0 * Re) * (a + Re) - 4.0 * b) * 0.5;\n\n        roots[0].x = Re;\n        roots[0].y = 0.0;\n        roots[1].x = -(a + Re) * 0.5;\n        roots[1].y = Im;\n        roots[2].x = -(a + Re) * 0.5;\n        roots[2].y = Im;\n\n        return 1;\n    }\n\n    float signR = R < 0.0 ? -1.0 : 1.0;\n    float Re = signR * sqrt(Q);\n\n    roots[0].x = -2.0 * Re - a * oneThird;\n    roots[0].y = 0.0;\n    roots[1].x = Re - a * oneThird;\n    roots[1].y = 0.0;\n    roots[2] = roots[1];\n\n    return 2;\n}","name":"Common","description":"","type":"common"}]}