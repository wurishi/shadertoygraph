{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Want to pixel peep, use 0 for no-zoom, 1=1:2x2, 2=1:4x4\n#define ZOOM 0\n\n// CONFIGURATION OPTIONS\n// =====================\n// Grille direction (0=horz, 1=vert)\n#define DBM_V 0\n// Grille (0=monochome, 1=chromatic)\n#define DBM_C 0\n\n// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \n//\n//                              SHADERTOY WRAPPER\n//\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \n// DBM does a fixed 2x2 up-sample, designed for flat panel displays\n// See the DBM source in the middle for more information\n// Cut that middle section out to use\n// Panels are exposure matched (since DBM cuts exposure a little)\n// ------\n// PANELS\n// ------\n// Left ..... Standard bilinear\n// Middle ... DBM\n// Right .... 1:2x2 nearest (aka integer scaling)\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \n// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \n//                              JUNKY DBM INTERFACE\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \n// Used for emulation of sRGB->linear reads and for store\nfloat SelF1(float a,float b,bool p){return p?b:a;}\nbool GtF1(float a,float b){return a>b;}\n// To sRGB\nfloat SrgbEncF1(float c){vec3 j=vec3(0.0031308*12.92,12.92,1.0/2.4);\n vec2 k=vec2(1.055,-0.055);\n return clamp(j.x,c*j.y,pow(c,j.z)*k.x+k.y);}\n// To linear\nfloat SrgbDecF1(float c){vec3 j=vec3(0.04045,1.0/12.92,2.4);\n vec2 k=vec2(1.0/1.055,0.055/1.055);\n return SelF1(c*j.y,pow(c*k.x+k.y,j.z),GtF1(c,j.x));}\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \n#define DBM_SHADERTOY 1\n// This must return linear data (not perceptual) else algorithm won't work\nvec3 DbmTex(vec2 p){vec3 c;\n #if 1\n  // [DEBUG] For testing a scrolling texture\n  p.x+=float(uint(iTime*60.0))/float(textureSize(iChannel0,0).x);\n #endif\n c=textureLod(iChannel0,p,0.0).rgb;\n // Shadertoy lacks sRGB to linear, so must emulate that\n // Take this as an example of how not to do this fast\n c.x=SrgbDecF1(c.x);c.y=SrgbDecF1(c.y);c.z=SrgbDecF1(c.z);return c;}\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \n// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n\n\n\n\n//|||||||||||||||||||||||||||||||||||||::|||||||||||||||||||||||||||||||||||||||\n//|||||||||||||||||||||||||||||||||||||::|||||||||||||||||||||||||||||||||||||||\n//=====================================||=======================================\n//\n//                             ..  ..\n//                     ........::  ::........  ::..::..::\n//                     OO      OO  OO      OO  OO  OO  OO\n//                     OOooooooOO  OOooooooOO  OO  OO  OO\n//\n//                              ___    by\n//                               |imothy Lottes                          \n//\n//-------------------------------------::--------------------------------------- \n// MIT NO ATTRIBUTION\n// ==================\n// Copyright 2024 Timothy Lottes\n// ------------------\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so.\n// ------------------\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//=====================================||=======================================\n//|||||||||||||||||||||||||||||||||||||::|||||||||||||||||||||||||||||||||||||||\n//=====================================||=======================================\n//                               DBM VERSION 1.0\n//-------------------------------------::--------------------------------------- \n// The 'DBM' is short for '[D]ou[B]ling [M]onitor'\n// CRT-stylized image doubler (2x on each axis, 4x area)\n//-------------------------------------::--------------------------------------- \n// THE PURPOSE\n// ===========\n// This is an alternative to simply doing 1:2x2 integer scaling\n// Hids square pixel artifacts while retaining perceptual sharpness\n// It works just like a CRT which is pushed to slight horizontal undersampling\n// This does a 1:2 scale on axis, but uses a 3:1 pixel period grille\n//-------------------------------------::--------------------------------------- \n// FLAT-PANEL PROBLEMS\n// ===================\n// Fixed near {even,odd} patterns can cause panel artifacts \n// Artifacts are caused by the 'dot inversion' in panel's pixel control circuit\n// Where the polarity of pixels alternates to reduce flicker and cross-talk\n// So flat signals get destructive (canceling) polarity inversion\n// But signals that match the polarity inversion can catastrophically overload\n// -------------------\n// This uses a 3-pixel period pattern for the grille to avoid polarity problems\n// Also this does a subtractive grille\n// It pushes energy out of 1-pixel instead of towards 1-pixel\n// This tends to be a lot more stable on flat panels\n//-------------------------------------::--------------------------------------- \n// SCALING ALIGNMENT\n// =================\n// +---+  |       |\n// | E |  |   T   | ... Texel is centered on even scanlines\n// +---+  |       |     For sharpest output\n// | o |  +-------+ ... Odd scanlines get a fixed 50% blend\n// +---+  |       |     The axis this is applied to depends on DBM_V\n// | E |  |   T   |\n// +---+  |       |\n// | o |  +-------+\n// +---+  |       |\n//-------------------------------------::--------------------------------------- \n// MIMIMAL EXPOSURE CHANGE\n// =======================\n// Simply applying a mask by multiply would darken the whole image\n// This instead linearly redistributes intensity away from masked areas\n// And applies a very minor multiply mask so white retains some hint of masking\n//=====================================||=======================================\n//|||||||||||||||||||||||||||||||||||||::|||||||||||||||||||||||||||||||||||||||\n//=====================================||=======================================\n//                                CONFIGURATIONS\n//-------------------------------------::---------------------------------------\n// KNOBS\n// =====\n// DBM_B\n//  Final brightness\n//  Going too small and the output gets too dark\n//  Going closer to 1 would remove too much mask on white output\n// =====\n// DBM_C\n//  Set {1=color, 0=monochrome} grille pattern\n// =====\n// DBM_M\n//  Maximum energy distribution as a function of neighbor pixels\n//  Range {0=off, to 1.0=maximum}\n//  Using too much in 'color' cases can result in panel output problems\n// =====\n// DBM_V\n//  Set {1=vertical, 0=horizontal} grille pattern\n//=====================================||=======================================\n // These are not designed to be changed for spatial scaling\n // But one might want to adjust the DBM_B when mixed with rolling BFI\n #ifndef DBM_B\n  #define DBM_B (1.0-1.0/16.0)\n #endif\n #define DBM_M 0.75\n//-------------------------------------::---------------------------------------\n // These are configurable\n #ifndef DBM_C \n  #define DBM_C 0\n #endif\n #ifndef DBM_V\n  #define DBM_V 0\n #endif\n//|||||||||||||||||||||||||||||||||||||::|||||||||||||||||||||||||||||||||||||||\n//=====================================||=======================================\n//                                 PORTABILITY\n//-------------------------------------::---------------------------------------\n// The callback\n//  DbmH3 DbmTex(DbmF2 c) - Returns (half if possible) RGB texture lookup\n//                          Fixed to LOD=0\n//                          THIS MUST RETURN LINEAR DATA!!!!!!!!!!!!!!!!!\n//                          Else none of the DBM logic will work right\n//-------------------------------------::---------------------------------------\n// Sorry only time to do the SHADERTOY interface, but regular GLSL/HLSL is easy\n//=====================================||=======================================\n#ifdef DBM_GLSL\n#endif\n//=====================================||=======================================\n#ifdef DBM_HLSL\n#endif \n//=====================================||=======================================\n#ifdef DBM_SHADERTOY\n // This is a junky GLSL interface (no half support, etc)\n #define DbmF1 float\n #define DbmF2 vec2\n #define DbmF4 vec4\n #define DbmI1 uint\n #define DbmI2 uvec2\n #define DbmP1 bool\n//-------------------------------------::---------------------------------------\n // No 16-bit support so just override using float\n #define DbmH1 float\n #define DbmH3 vec3\n #define DbmH4 vec4\n//-------------------------------------::---------------------------------------\n // General portable instruction intrinsics\n #define DbmAddH3(a,b) ((a)+(b))\n #define DbmAddI1(a,b) ((a)+(b))\n #define DbmAndI1(a,b) ((a)&(b))\n #define DbmCvtF2I2(a) DbmF2(a)\n #define DbmFmaF2(a,b,c) ((a)*(b)+(c))\n #define DbmFmaF4(a,b,c) ((a)*(b)+(c))\n #define DbmFmaH3(a,b,c) ((a)*(b)+(c))\n #define DbmFractF2(a) fract(a)\n #define DmbGeP1F1(a,b) ((a)>=(b))\n #define DmbLeP1F1(a,b) ((a)<=(b))\n #define DbmMaxH3(a,b) max(a,b)\n #define DbmMulH3(a,b) ((a)*(b))\n #define DbmSatH3(a) clamp(a,DbmH3(0.0),DbmH3(1.0))\n #define DbmSelH1(a,b,c) ((c)?(b):(a))\n#endif //DBM_SHADERTOY \n//|||||||||||||||||||||||||||||||||||||::|||||||||||||||||||||||||||||||||||||||\n//=====================================||=======================================\n//                                SHADER ENTRY\n//-------------------------------------::---------------------------------------\n// This returns the linear color space output\n// This could be faster perhaps in the 'DBM_C=0' case\n//  if one wants to rewrite everything in CS and output 3 pixels/lane\n//=====================================||=======================================\nDbmH3 Dbm(\nDbmI2 g, // Global integer pixel coordinate for output\nDbmF2 kRcp2Img, // 1/(2*inputImageSizeInPixels)\nDbmF2 kHalfRcpImg, // 0.5/inputImageSizeInPixels\nDbmF2 kQutrRcpImg){ // 0.25/inputImageSizeInPixels\n//-------------------------------------::--------------------------------------- \n// SAMPLING\n// ========\n// Even output pixels are on texel centers (when using kHalfRcpImg)\n//      :\n//   |--e--|--o--|--e--|--o--|\n//      :     :     :     :\n//   ---t-----|-----t-----|---\n//            :\n// Odd output pixels are 50% between two texels\n// --------\n// This does 5 bilinear fetches in a horizontal span {a,b,c,d,e}\n// For the nearest 5 output pixels centered around 'c' (the target output)\n//-------------------------------------::---------------------------------------\n DbmF2 gg=DbmCvtF2I2(g);\n #if DBM_V==0\n  // Using standard bilinear on Y\n  // Because it removes the hot pixel in the grille problem\n  // Using fixed bilinear (sharper) on X\n  DbmF2 p=DbmFmaF2(gg,kRcp2Img,DbmF2(kHalfRcpImg.x,kQutrRcpImg.y));\n #else\n  DbmF2 p=DbmFmaF2(gg,kRcp2Img,DbmF2(kQutrRcpImg.x,kHalfRcpImg.y));\n #endif\n DbmH3 a,b,c,d,e;\n #if DBM_V\n  // Want the values for nearby outputs\n  DbmF4 pABDE=DbmFmaF4(DbmF4(-2.0,-1.0,1.0,2.0),kRcp2Img.xxxx,p.xxxx);\n  // Should match up to NSA form on later AMD HW\n  a=DbmTex(DbmF2(pABDE.x,p.y));\n  b=DbmTex(DbmF2(pABDE.y,p.y));\n  c=DbmTex(p);\n  d=DbmTex(DbmF2(pABDE.z,p.y));\n  e=DbmTex(DbmF2(pABDE.w,p.y));\n #else\n  DbmF4 pABDE=DbmFmaF4(DbmF4(-2.0,-1.0,1.0,2.0),kRcp2Img.yyyy,p.yyyy);\n  a=DbmTex(DbmF2(p.x,pABDE.x));\n  b=DbmTex(DbmF2(p.x,pABDE.y));\n  c=DbmTex(p);\n  d=DbmTex(DbmF2(p.x,pABDE.z));\n  e=DbmTex(DbmF2(p.x,pABDE.w));\n #endif\n//-------------------------------------::--------------------------------------- \n// REORDERING\n// ==========\n// This needs spans of 3 filtered texels around the primary grille column\n// In order to do energy redistribution correctly\n// Naming the 3x1's as 'UVW' where 'V' is the primary grille column\n// ----------\n// A B C D E\n// - - - - -\n// . r R r .  <-- centered on R \n// . . g G g\n// b B b . . \n// - - - - -\n// r R r . . \n// . g G g .  <-- centered on G\n// . . b B b\n// - - - - -\n// . . r R r\n// g G g . .\n// . b B b .  <-- centered on B \n//-------------------------------------::--------------------------------------- \n // Using integer mod here would be slow\n //  R--|--G--|--B--|--R\n //  0  :  1  :  2  :  3\n //  0  : 1/3 : 2/3 : 3/3\n //    1/6   3/6   5/6   7/6\n //  |--R--|--G--|--B--|\n gg=DbmFractF2(DbmFmaF2(DbmF2(1.0/3.0),gg,DbmF2(1.0/6.0)));\n #if DBM_V\n  DbmP1 isR=DmbLeP1F1(gg.x,DbmF1(1.0/3.0));\n  DbmP1 isB=DmbGeP1F1(gg.x,DbmF1(2.0/3.0));\n #else\n  DbmP1 isR=DmbLeP1F1(gg.y,DbmF1(1.0/3.0));\n  DbmP1 isB=DmbGeP1F1(gg.y,DbmF1(2.0/3.0));\n #endif\n DbmH3 u;\n DbmH3 v;\n DbmH3 w;\n #if DBM_C\n  // Do {isG,isR} case first\n  u.r=DbmSelH1(a.r,b.r,isR);\n  u.g=DbmSelH1(b.g,c.g,isR);\n  u.b=DbmSelH1(c.b,a.b,isR);\n  v.r=DbmSelH1(b.r,c.r,isR);\n  v.g=DbmSelH1(c.g,d.g,isR);\n  v.b=DbmSelH1(d.b,b.b,isR);\n  w.r=DbmSelH1(c.r,d.r,isR);\n  w.g=DbmSelH1(d.g,e.g,isR);\n  w.b=DbmSelH1(e.b,c.b,isR);\n  // Do {isR|G,isB} case\n  u.r=DbmSelH1(u.r,c.r,isB);\n  u.g=DbmSelH1(u.g,a.g,isB);\n  u.b=DbmSelH1(u.b,b.b,isB);\n  v.r=DbmSelH1(v.r,d.r,isB);\n  v.g=DbmSelH1(v.g,b.g,isB);\n  v.b=DbmSelH1(v.b,c.b,isB);\n  w.r=DbmSelH1(w.r,e.r,isB);\n  w.g=DbmSelH1(w.g,c.g,isB);\n  w.b=DbmSelH1(w.b,d.b,isB);\n #else\n  // All channels just grab whatever the G locations are\n  u.r=DbmSelH1(b.r,c.r,isR);\n  u.g=DbmSelH1(b.g,c.g,isR);\n  u.b=DbmSelH1(b.b,c.b,isR);\n  v.r=DbmSelH1(c.r,d.r,isR);\n  v.g=DbmSelH1(c.g,d.g,isR);\n  v.b=DbmSelH1(c.b,d.b,isR);\n  w.r=DbmSelH1(d.r,e.r,isR);\n  w.g=DbmSelH1(d.g,e.g,isR);\n  w.b=DbmSelH1(d.b,e.b,isR);\n  //\n  u.r=DbmSelH1(u.r,a.r,isB);\n  u.g=DbmSelH1(u.g,a.g,isB);\n  u.b=DbmSelH1(u.b,a.b,isB);\n  v.r=DbmSelH1(v.r,b.r,isB);\n  v.g=DbmSelH1(v.g,b.g,isB);\n  v.b=DbmSelH1(v.b,b.b,isB);\n  w.r=DbmSelH1(w.r,c.r,isB);\n  w.g=DbmSelH1(w.g,c.g,isB);\n  w.b=DbmSelH1(w.b,c.b,isB);\n #endif\n//-------------------------------------::--------------------------------------- \n// ENERGY REDISTRIBUTION\n//-------------------------------------::--------------------------------------- \n // Redistrbute energy from 'v' into both 'uw'\n // Drop brightness first\n u=DbmMulH3(u,DbmH3(DBM_B));\n v=DbmMulH3(v,DbmH3(DBM_B));\n w=DbmMulH3(w,DbmH3(DBM_B));\n // Limit by whatever pixel would clip first\n DbmH3 uw=DbmMaxH3(u,w);\n // Allowed maximum is at most half of 'v' because its going to two pixels\n DbmH3 m=DbmSatH3(DbmFmaH3(v,DbmH3(DBM_M*0.5),uw));\n // Change for {u,w}\n m=DbmAddH3(m,-uw);\n u=DbmAddH3(m,u);\n w=DbmAddH3(m,w);\n v=DbmFmaH3(DbmH3(-2.0),m,v);\n//-------------------------------------::--------------------------------------- \n// COLLECT FINAL OUTPUT\n// ====================\n// Each of the {r,R,r} and so on maps to {u,v,w}\n// Need the 'C' centers\n// --------------------\n//     C    \n// - - - - -\n// . r R r .  <-- centered on R \n// . . g G g\n// b B b . . \n// - - - - -\n// r R r . . \n// . g G g .  <-- centered on G\n// . . b B b\n// - - - - -\n// . . r R r\n// g G g . .\n// . b B b .  <-- centered on B \n//-------------------------------------::--------------------------------------- \n DbmH3 o;\n #if DBM_C\n  // Do {isG,isR} case first\n  o.r=DbmSelH1(w.r,v.r,isR);\n  o.g=DbmSelH1(v.g,u.g,isR);\n  o.b=DbmSelH1(u.b,w.b,isR);\n  // Do {isR|G,isB} case\n  o.r=DbmSelH1(o.r,u.r,isB);\n  o.g=DbmSelH1(o.g,w.g,isB);\n  o.b=DbmSelH1(o.b,v.b,isB);\n #else\n  // No color separation case\n  o.r=DbmSelH1(v.r,u.r,isR);\n  o.g=DbmSelH1(v.g,u.g,isR);\n  o.b=DbmSelH1(v.b,u.b,isR);\n  //\n  o.r=DbmSelH1(o.r,w.r,isB);\n  o.g=DbmSelH1(o.g,w.g,isB);\n  o.b=DbmSelH1(o.b,w.b,isB);\n #endif\n return o;}\n\n\n\n\n\n// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n//. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \n//\n//                                SHADERTOY ENTRY\n//\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n // Setup compute shader emulation\n DbmI2 g=DbmI2(fragCoord);\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \n #if ZOOM\n  g>>=DbmI2(ZOOM);\n #endif\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \n // Constants for DBM\n DbmF2 kRcp2Img   =vec2(1.0 )/(vec2(2.0)*vec2(textureSize(iChannel0,0)));\n DbmF2 kQutrRcpImg=vec2(0.25)/(vec2(1.0)*vec2(textureSize(iChannel0,0)));\n DbmF2 kHalfRcpImg=vec2(0.5 )/(vec2(1.0)*vec2(textureSize(iChannel0,0)));\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \n // Offset for     fixed bilinear\n DbmF2 kFix=vec2(0.5)/(vec2(1.0)*vec2(textureSize(iChannel0,0)));\n // Offset for non-fixed bilinear\n DbmF2 kBad=vec2(0.5)/(vec2(2.0)*vec2(textureSize(iChannel0,0)));\n // Yes these are the same as the others, but for debug these are separate\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \n // Panels\n DbmF2 panel=DbmF2(iResolution.x*0.25,iResolution.x*0.75);\n DbmH4 c=DbmH4(0.0); \n if(fragCoord.x<panel.x){\n  // Bad-bilinear\n  DbmF2 p=DbmFmaF2(DbmCvtF2I2(g),kRcp2Img,kBad);\n  c.rgb=DbmTex(p)*DbmH3(DBM_B);}\n else if(fragCoord.x<panel.y){\n  // This technique\n  c.rgb=Dbm(g.xy,kRcp2Img,kHalfRcpImg,kQutrRcpImg);}\n else{\n  // 1:2x2 nearest\n  // This works because 'even' is on texel\n  g&=DbmI2(~1);\n  DbmF2 p=DbmFmaF2(DbmCvtF2I2(g),kRcp2Img,kFix);\n  c.rgb=DbmTex(p)*DbmH3(DBM_B);}\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \n // Black bar the divides \n DbmF2 bar2=abs(fragCoord.xx-panel);\n DbmF1 bar1=min(bar2.x,bar2.y);\n if(bar1<4.0)c.rgb*=0.0;\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \n // Output to screen\n c.r=SrgbEncF1(c.r);\n c.g=SrgbEncF1(c.g);\n c.b=SrgbEncF1(c.b);\n fragColor=vec4(c.rgb,1.0);}\n \n \n ","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lfcBDs","date":"1733784418","viewed":438,"name":"LottesDBM","username":"TimothyLottes","description":"Fixed 1:2x2 image CRT-like scaling algorithm","likes":9,"published":1,"flags":0,"usePreview":1,"tags":["scaling","dbm"],"hasliked":0,"parentid":"","parentname":""}}