{"ver":"0.1","info":{"id":"3lfSR4","date":"1562172074","viewed":673,"name":"Curves and Blocks","username":"fizzer","description":"Some differently-shaped voxels with a pencil hatching effect, and some 'perfect' temporal anti-aliasing due to the fact that deformation due to camera motion (vertical scrolling) is linear.","likes":43,"published":1,"flags":32,"usePreview":0,"tags":["voxels","pencil","hatching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    fragColor.a = 1.;\n    \n    // Clamp, Gamma, Dither\n    fragColor.rgb = pow(clamp(fragColor.rgb, 0., 1.), vec3(1. / 2.2)) +\n        \t\t\ttexelFetch(iChannel2, ivec2(fragCoord) & 1023, 0).rgb / 200.;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat trace(vec3 ro, vec3 rd, out vec3 n)\n{\n    vec3 rp = ro, cp, rp2 = rp, lrp = rp;\n    float d = 1e4;\n\n    int hitid = 0;\n    float prevmint = 0.;\n    n = vec3(0, 0, 1);\n\n    // Voxel traversal\n    for(int i = 0; i < 20; ++i)\n    {      \n        rp = rp2;\n        cp = floor(rp + sign(rd) * 1e-4);\n\n        vec3 t = ((cp + max(sign(rd), 0.0)) - ro) / rd;\n        float mint = min(t.x, min(t.y, t.z));\n\n        float id = floor(hash(cp.x + cp.y * 57.0 + cp.z * 199.) * 130.);\n\n        if(id < 32.)\n        {\n            // Cylinder position and orientation\n            vec3 q = vec3(mod(id, 2.), mod(floor(id / 2.), 2.), mod(floor(id / 4.), 2.));\n\n            vec3 sc = vec3(1, 0, 1);\n\n            if(mod(id / 8., 2.) > .5)\n                sc = sc.yzx;\n\n            if(mod(id / 16., 2.) > .5)\n                sc = sc.yzx;\n\n            vec2 t = intersectSphere((ro - cp - q) * sc, rd * sc, vec3(0), 1.);\n\n            if(t.x < t.y && t.x > prevmint && t.y > mint)\n                n = normalize((ro + rd * t.x - cp - q) * sc);\n\n            // Clip cylinder to voxel cube\n            t.x = max(t.x, prevmint);\n            t.y = min(t.y, mint);\n\n            if(t.x < t.y)\n            {\n                // Hit cylinder\n                rp2 = ro + t.x * rd;\n                hitid = 2;\n                break;\n            }\n        }\n        else if(id < 35.)\n        {\n            // Hit cube\n            hitid = 1;\n            break;\n        }\n\n\t\t// Step to next voxel\n        n = step(t, t.yzx) * step(t, t.zxy) * sign(-rd);\n        rp2 = ro + mint * rd;\n        prevmint = mint;\n    }\n    \n    return distance(rp2, ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Jitter for anti-aliasing\n    fragCoord += .8 * (texelFetch(iChannel0, ivec2(fragCoord + float(iFrame) * 99.) & 255, 0).xy * 2. - 1.);\n\n    vec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    uv.y += iTime / 6.;\n\n    vec3 ro = vec3(uv.xy * 4., 0.0);\n    vec3 rd = vec3(0, 0, -1);\n\n    rd = rotX(-.3) * rd;\n    rd = rotY(-.2) * rd;\n\n    vec3 n = vec3(0, 0, 1);\n\n    float t = trace(ro, rd, n);\n    \n    // Store normal in RGB\n    fragColor.rgb = normalize(n);\n\n\tvec3 ld = normalize(vec3(1,1,2.5));\n    vec3 rp = ro + rd * t + n * 1e-4;\n    float st = trace(rp, ld, n);\n    \n    // For the directional shadow, the hit distance is simply multiplied\n    // by some large-ish value, to force the shading to be darker for those pixels.\n    if(st < 40. && (rp + ld * st).z < -.999)\n        t *= 6.;\n    \n    // Store ray hit distance in W\n    fragColor.w = t;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\nvec2 intersectSphere(vec3 ro, vec3 rd, vec3 org, float rad)\n{\n   float a = dot(rd, rd);\n   float b = 2. * dot(rd, ro - org);\n   float c = dot(ro - org, ro - org) - rad * rad;\n   float desc = b * b - 4. * a * c;\n   if (desc < 0.)\n      return vec2(1, 0);\n\n   return vec2((-b - sqrt(desc)) / (2. * a), (-b + sqrt(desc)) / (2. * a));\n}\n\nmat3 rotX(float a)\n{\n    return mat3(1., 0., 0.,\n                0., cos(a), sin(a),\n                0., -sin(a), cos(a));\n}\n\nmat3 rotY(float a)\n{\n    return mat3(cos(a), 0., sin(a),\n                0., 1., 0.,\n                -sin(a), 0., cos(a));\n}\n\nfloat hash(float n)\n{\n    return fract(sin(n) * 43758.5453);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 e = vec2(2.e-3, 0);\n    float aspect = iResolution.y / iResolution.x;\n    \n    // Sample multiple pixels to do an edge-detection effect\n    vec4 nc = textureLod(iChannel0, uv, 0.);\n    vec4 n0 = textureLod(iChannel0, uv + e.xy * aspect, 0.);\n    vec4 n1 = textureLod(iChannel0, uv + e.yx, 0.);\n    vec4 n2 = textureLod(iChannel0, uv - e.xy * aspect, 0.);\n    vec4 n3 = textureLod(iChannel0, uv - e.yx, 0.);\n\n    // Edge shadowing term\n    float sh = smoothstep(0.,.6, max(length(n3 - nc),\n                   max(length(n2 - nc), max(length(n0 - nc), length(n1 - nc)))));\n\n    fragColor.rgb = vec3(1. - sh * .15) * (.7 + .2 * smoothstep(0.145, .85, nc.x + nc.y));\n    \n    // Depth / shadow darkening\n    fragColor.rgb *= exp(-nc.w * .08);\n\n    // Reproject previous frame (due to vertical scrolling)\n    float scrollOffset = iTime / 12.;\n    float prevScrollOffset = texelFetch(iChannel2, ivec2(0), 0).a;\n    vec2 prevUv = uv - vec2(0, prevScrollOffset - scrollOffset);\n    vec3 prevCol = textureLod(iChannel2, prevUv, 0.).rgb;\n    float weight = all(greaterThan(prevUv, vec2(0))) && all(lessThan(prevUv, vec2(1))) ? 1.0 : 0.0;\n\n    // First frame must have zero blending weight\n    if(iFrame < 2)\n        weight = 0.;\n\n    uv.y += scrollOffset;\n\n    fragColor.rgb *= mix(.15, 1., 1. - (1. - fragColor.r) * textureLod(iChannel1, uv * 7., 0.).r);\n    fragColor.rgb *= mix(.2, 1., 1. - pow(1. - fragColor.r, 1.5) * textureLod(iChannel1, .2 + uv * 17., 1.).r);\n\n    // Colouration\n    fragColor.rgb *= vec3(1., .95, .9) * 1.2;\n\n    // Blend reprojected previous frame to smoothen temporaly\n    fragColor.rgb = mix(fragColor.rgb, prevCol, .9 * weight);\n\n    // Store the vertical scroll position from this frame\n    fragColor.a = scrollOffset;\n}\n","name":"Buffer B","description":"","type":"buffer"}]}