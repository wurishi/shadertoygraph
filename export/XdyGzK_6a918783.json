{"ver":"0.1","info":{"id":"XdyGzK","date":"1455484498","viewed":541,"name":"Bezier Distance Field","username":"davidp","description":"Signed distance fields for bezier curves.\n\nUses code ripped from the following:\nhttps://www.shadertoy.com/view/XdB3Ww\nhttps://www.shadertoy.com/view/MtS3Dy\nhttps://www.shadertoy.com/view/ltXSDB","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["bezier","distance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Via: https://www.shadertoy.com/view/XdB3Ww\n//\n//Find roots using Cardano's method. http://en.wikipedia.org/wiki/Cubic_function#Cardano.27s_method\n#define EPSILON 1e-8\n#define PI 3.14159265358979\n\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat testCross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat signBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{ \n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0, \n        step(testCross(A, B, p) * testCross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * testCross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 solveCubic(float a, float b, float c)\n{\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a bezier curve\nfloat sdBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{    \n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec3 t = clamp(solveCubic(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis * signBezier(A, B, C, p);\n}\n\n\nint findRoots(float a, float b, float c, float d, out float r[3])\n{\n\tif (abs(a) > EPSILON)\n\t{\n\t\tfloat z = 1.0/a;\n\t\tfloat d3 = 1.0/3.0;\n\t\tfloat d27 = 1.0/27.0;\n\t\ta = b*z;\n\t\tb = c*z;\n\t\tc = d*z;\n\t\tfloat p = b-a*a*d3;\n\t\tfloat q = a*(2.0*a*a-9.0*b)*d27+c;\n\t\tfloat ppp = p*p*p;\n\t\tfloat D = q*q+4.0*ppp*d27;\n\t\tfloat delta = -a*d3;\n\t\tif (D > EPSILON)\n\t\t{\n\t\t\tz = sqrt(D);\n\t\t\tfloat u = (-q+z)*0.5;\n\t\t\tfloat v = (-q-z)*0.5;\n\t\t\tu = sign(u)*pow(abs(u),d3);\n\t\t\tv = sign(v)*pow(abs(v),d3);\n\t\t\tr[0] = u+v+delta;\n\t\t\treturn 1;\n\t\t}\n\t\telse if (D < -EPSILON)\n\t\t{\n\t\t\tfloat u = sqrt(-p*d3)*2.0;\n\t\t\tfloat v = acos(-sqrt(-27.0/ppp)*q*0.5)*d3;\n\t\t\tr[0] = u*cos(v)+delta;\n\t\t\tr[1] = u*cos(v+2.0*PI*d3)+delta;\n\t\t\tr[2] = u*cos(v+4.0*PI*d3)+delta;\n\t\t\treturn 3;\n\t\t}\t\t\n\t\telse\n\t\t{\n\t\t\tq = sign(q)*pow(abs(q)*0.5,d3);\n\t\t\tr[0] = 2.0*-q+delta;\n\t\t\tr[1] = q+delta;\n\t\t\treturn 2;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (abs(b) <= EPSILON && abs(c) > EPSILON)\n\t\t{\n\t\t\tr[0] = -d/c;\n\t\t\treturn 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfloat D = c*c-4.0*b*d;\n\t\t\tfloat z = 1.0/(2.0*b);\n\t\t\tif (D > EPSILON)\n\t\t\t{\n\t\t\t\tD = sqrt(D);\n\t\t\t\tr[0] = (-c-D)*z;\n\t\t\t\tr[1] = (-c+D)*z;\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\telse if (D > -EPSILON)\n\t\t\t{\n\t\t\t\tr[0] = -c*z;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nvec2 getPositionOnBezierCurve(float t, vec2 p0, vec2 p1, vec2 p2) \n{\n\tfloat fOneMinusT = 1.0-t;\n\treturn fOneMinusT*fOneMinusT*p0+2.0*t*fOneMinusT*p1+t*t*p2;\n}\n\n// How to resolve the equation below can be seen on this image.\n// http://www.perbloksgaard.dk/research/DistanceToQuadraticBezier.jpg\nfloat calculateDistanceToQuadraticBezier(vec2 p, vec2 p0, vec2 p1, vec2 p2) \n{\n\tvec2 A = p1-p0;\n\tvec2 B = p2-p1-A;\n\tvec2 C = p-p0;\n\tfloat a = -dot(B,B);\n\tfloat b = -3.0*dot(A,B);\n\tfloat c = dot(C,B)-2.0*dot(A,A);\n\tfloat d = dot(C,A);\n\tfloat r[3];\n\tfindRoots(a,b,c,d,r);\n\tfloat dist = distance(p,getPositionOnBezierCurve(clamp(r[0],0.0,1.0),p0,p1,p2));\n\tdist = min(dist, distance(p,getPositionOnBezierCurve(clamp(r[1],0.0,1.0),p0,p1,p2)));\n\tdist = min(dist, distance(p,getPositionOnBezierCurve(clamp(r[2],0.0,1.0),p0,p1,p2)));\n\treturn dist;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 percent = ((fragCoord.xy / iResolution.xy) - vec2(0.25,0.5));\n    percent.x *= aspectRatio;\n    \n    vec2 mouse = (iMouse.xy / iResolution.xy);// - vec2(0.25,0.5);\n    \n    vec2 A = vec2(0.1,0.1);\n    vec2 B = length(iMouse.xy) > 0.0 ? mouse : vec2(0.5, 0.9);\n    vec2 C = vec2(0.9,0.5);\n    vec2 D = vec2(0.9, 0.9);\n    vec2 E = vec2(0.75, 0.75);\n    \n    float d1, d2, d3;\n    \n    if (fract(iTime) > 0.5) {\n        vec2 p = fragCoord.xy / iResolution.xy; //(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \td1 = sdBezier(A, B, C, p);\n    \td2 = sdBezier(C, B, D, p);\n    \td3 = sdBezier(E, B, A, p);\n        \n        float d = 1.0 - max(d1, max(d2, d3));\n    \td = min(d, step(d, 0.90));\n        \n        fragColor = vec4(d,d,d,1.0);// - sign(d)*vec4(0.1,0.4,0.7,1.0);\n    \t//fragColor *= (1.0 - exp(-4.0*abs(d))) * (0.8 + 0.2*cos(140.*d));\n    \t//fragColor = mix(fragColor, vec4(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n        \n    } else {\n    \n    \tA.xy *= iResolution.xy;\n    \tB.xy *= iResolution.xy;\n    \tC.xy *= iResolution.xy;\n    \tD.xy *= iResolution.xy;\n    \tE.xy *= iResolution.xy;\n        \n    \td1 = calculateDistanceToQuadraticBezier(fragCoord.xy, A, B, C);\n    \td2 = calculateDistanceToQuadraticBezier(fragCoord.xy, C, B, D);\n   \t\td3 = calculateDistanceToQuadraticBezier(fragCoord.xy, E, B, A);\n        \n        d1 = 1.0 - (d1 * 0.01);\n    \td2 = 1.0 - (d2 * 0.01);\n    \td3 = 1.0 - (d3 * 0.01);\n    \n    \tfloat d = 0.0;\n    \n    \td = max(d1, max(d2, d3));\n    \td = min(d, step(d, 0.90));\n    \tfragColor = vec4(d,d,d,1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}