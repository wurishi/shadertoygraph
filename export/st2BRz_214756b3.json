{"ver":"0.1","info":{"id":"st2BRz","date":"1651868337","viewed":50,"name":"grafika-hf2 leadas","username":"xedves","description":"grafika hf2\nA feltöltött program lefutott. 1 pont.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["hazi"],"hasliked":0,"parentid":"fllfDX","parentname":"grafika-hf2 v2"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.141592654;\n\nuniform float frame;\nuniform mat4 viewMat;\n\nstruct Material {\n\tvec3 ka, kd, ks;\n\tfloat  shininess;\n\tvec3 F0;\n\tint rough, reflective;\n};\n\nstruct Hit {\n\tfloat t;\n\tvec3 position, normal;\n\tMaterial mat;\n};\n\nMaterial rough;\n\n//konzi alapjan\nvec4 quat(vec3 axis, float angle) {\n    return vec4(axis * sin(angle / 2.), cos(angle / 2.));\n}\n\nvec4 quatInv(vec4 q) {\n    return vec4(-q.xyz, q.w);\n}\n\nvec4 quatMul(vec4 q1, vec4 q2) {\n    return vec4(\n        q1.w * q2.xyz + q2.w * q1.xyz + cross(q1.xyz, q2.xyz),\n        q1.w * q2.w - dot(q1.xyz, q2.xyz)\n    );\n}\n\nvec3 quatRot(vec4 q, vec3 p) {\n    vec4 qInv = quatInv(q);\n    return quatMul(quatMul(q, vec4(p, 0)), qInv).xyz;\n}\n\nHit findBestHit(Hit hit1, Hit hit2) {\n    Hit bestHit;\n    bestHit.t = -1.;\n    float t1 = hit1.t;\n    float t2 = hit2.t;\n    vec3 normal1 = hit1.normal;\n    vec3 normal2 = hit2.normal;\n    \n    if (t1 < 0.0 && t2 < 0.0) {\n        return bestHit;\n    } else if (t2 < 0.0) {\n        bestHit.normal = normal1;\n        bestHit.t = t1;\n        bestHit.mat = hit1.mat;\n        //return t1;\n    } else if (t1 < 0.0) {\n        bestHit.normal = normal2;\n        bestHit.t = t2;\n        bestHit.mat = hit2.mat;\n        //return t2;\n    } else {\n        if (t1 < t2) {\n            bestHit.normal = normal1;\n            bestHit.t = t1;\n            bestHit.mat = hit1.mat;\n            //return t1;\n        } else {\n            bestHit.normal = normal2;\n            bestHit.t = t2;\n            bestHit.mat = hit2.mat;\n            //return t2;\n        }\n    }\n    return bestHit;\n}\n\n//konzi alapjan\nHit intersectSphere(vec3 origin, vec3 rayDir, vec3 center, float radius, out vec3 normal) {\n    Hit hit;\n    hit.t = -1.;\n    \n    vec3 oc = origin - center;\n    float a = dot(rayDir, rayDir);\n    float b = 2.0 * dot(oc, rayDir);\n    float c = dot(oc, oc) - radius * radius;\n    float disc = b * b - 4. * a * c;\n    if (disc < 0.0) {\n        return hit;\n    }\n    float t = (-b - sqrt(disc)) / (2. * a);\n    vec3 hitPos = origin + rayDir * t;\n    \n    normal = normalize(hitPos - center);\n    hit.t = t;\n    hit.position = hitPos;\n    hit.normal = normal;\n    hit.mat = rough;\n    return hit;\n}\n\nHit intersectParaboloid(vec3 origin, vec3 rayDir, vec3 center, out vec3 normal) {\n    Hit hit;\n    hit.t = -1.;\n    \n    vec3 oc = origin - center;\n    /*https://github.com/playbar/OM3D/blob/6611fdd0073ee405d3f12e64937ed81f7208996c/3DObjectManipulation/3rdparty/pbrt/shapes/paraboloid.cpp*/\n    float height = 2.;\n    //konzi alapjan\n    float a = dot(rayDir.xz, rayDir.xz);\n    float b = 2.0 * dot(oc.xz, rayDir.xz) - rayDir.y;\n    float c = dot(oc.xz, oc.xz) - oc.y;\n    float disc = b * b - 4. * a * c;\n    if (disc < 0.0) {\n        return hit;\n    }\n    float t1 = (-b - sqrt(disc)) / (2. * a);\n    float t2 = (-b + sqrt(disc)) / (2. * a);\n    \n    vec3 hitPos1 = origin + rayDir * t1;\n    vec3 hitPos2 = origin + rayDir * t2;\n    \n    if (hitPos1.y > height + center.y)\n        t1 = -1.0;\n    if (hitPos2.y > height + center.y)\n        t2 = -1.0;\n    \n    \n    float t;\n    vec3 hitPos;\n    if (t1 < 0.0 && t2 < 0.0) {\n        t = -1.0;\n    } else if (t2 < 0.0) {\n        t = t1;\n        hitPos = hitPos1;\n    } else if (t1 < 0.0) {\n        t = t2;\n        hitPos = hitPos2;\n    } else {\n        if (t1 < t2) {\n            t = t1;\n            hitPos = hitPos1;\n        } else {\n            t = t2;\n            hitPos = hitPos2;\n        }\n    }\n    \n    normal = cross(vec3(1., 2.*hitPos.x, 0.), vec3(0., 2.*hitPos.z, 1.));\n    normal = normalize(normal);\n    \n    hit.t = t;\n    hit.position = hitPos;\n    hit.normal = normal;\n    hit.mat = rough;\n    hit.mat.kd = vec3(.3,.3,.3);\n    hit.mat.ka = hit.mat.kd*PI;\n    return hit;\n}\n\nHit intersectPlaneCyl(vec3 origin, vec3 rayDir, vec3 point, float radius, vec3 normal) {\n    Hit hit;\n    hit.t = -1.;\n    float t = dot(point - origin, normal) / dot(rayDir, normal);\n    vec3 hitPos = origin + rayDir * t;\n    if (length(hitPos - point) < radius) {\n        hit.t = t;\n        hit.normal = normal;\n    }\n    return hit;\n}\n\n//konzi alapjan\nHit intersectCylinder(vec3 origin, vec3 rayDir, vec3 center, float radius, float height, out vec3 normal) {\n    Hit hit;\n    hit.t = -1.;\n    \n    vec2 oc = origin.xz - center.xz;\n    float a = dot(rayDir.xz, rayDir.xz);\n    float b = 2.0 * dot(oc, rayDir.xz);\n    float c = dot(oc, oc) - radius * radius;\n    float disc = b * b - 4. * a * c;\n    if (disc < 0.0) {\n        return hit;\n    }\n    float t1 = (-b - sqrt(disc)) / (2. * a);\n    float t2 = (-b + sqrt(disc)) / (2. * a);\n    vec3 hitPos1 = origin + rayDir * t1;\n    vec3 hitPos2 = origin + rayDir * t2;\n    if (hitPos1.y < center.y || hitPos1.y > height + center.y)\n        t1 = -1.0;\n    if (hitPos2.y < center.y || hitPos2.y > height + center.y)\n        t2 = -1.0;\n    \n    float t;\n    vec3 hitPos;\n    if (t1 < 0.0 && t2 < 0.0) {\n        t = -1.0;\n    } else if (t2 < 0.0) {\n        t = t1;\n        hitPos = hitPos1;\n    } else if (t1 < 0.0) {\n        t = t2;\n        hitPos = hitPos2;\n    } else {\n        if (t1 < t2) {\n            t = t1;\n            hitPos = hitPos1;\n        } else {\n            t = t2;\n            hitPos = hitPos2;\n        }\n    }\n    \n    normal = hitPos - center;\n    normal.y = 0.0;\n    normal = normalize(normal);\n    \n    hit.t = t;\n    hit.normal = normal;\n    \n    vec3 capNormal = vec3(0, 1, 0);\n    Hit capHit = intersectPlaneCyl(origin, rayDir, vec3(center.x, center.y+height, center.z) , radius, capNormal);\n    \n    hit = findBestHit(hit, capHit);\n    \n    hit.position = hitPos;\n    hit.mat = rough;\n    return hit;\n}\n\nHit intersectPlane(vec3 origin, vec3 rayDir, vec3 point, vec3 normal) {\n    Hit hit;\n    hit.t = dot(point - origin, normal) / dot(rayDir, normal);\n    hit.position = vec3(0);\n    hit.mat = rough;\n    hit.mat.kd = vec3(.3, 0.2, 0.1);\n    hit.mat.ka = hit.mat.kd * PI;\n    hit.normal = vec3(0,1,0);\n    return hit;\n}\n\n\nHit intersectWorld(vec3 origin, vec3 rayDir) {\n    float time = frame / 60.0;\n    \n    \n    Hit hit;\n    hit.t = -1.;\n    \n    vec3 cyl1Normal;\n    vec3 sphNormal;\n    vec3 sph2Normal;\n    vec3 sph3Normal;\n    vec3 baseNormal;\n    vec3 cyl2Normal;\n    vec3 paraNormal;\n    vec3 sph1orig = vec3(0);\n    vec3 sph2orig = vec3(0, 2.2, 0);\n    vec3 sph3orig = vec3(0, 5.2, 0);\n    vec3 cyl1orig = vec3(0, 0, 0);\n    vec3 cyl2orig = vec3(0, 2.4, 0);\n    vec3 paraorig = vec3(0, 5.4, 0);\n    \n    //sph1\n    vec4 q = quat(normalize(vec3(1, 3, 2)), iTime-30.+80.5);\n    vec3 rotOrigin = quatRot(q, origin-sph1orig) + sph1orig;\n    vec3 rotRayDir = quatRot(q, rayDir);\n    Hit sphHit;\n    sphHit = intersectSphere(rotOrigin, rotRayDir, sph1orig, 0.35, sphNormal);\n    sphNormal = sphHit.normal;\n    sphNormal = quatRot(quatInv(q), sphNormal);\n    sphHit.normal = sphNormal;\n\n    \n    //plane\n    vec3 planeNormal = vec3(0, 1, 0);\n    //float tPlane = intersectPlane(origin, rayDir, vec3(0, -.7, 0), planeNormal);\n    Hit planeHit;\n    planeHit = intersectPlane(origin, rayDir, vec3(0, -.7, 0), planeNormal);\n    planeNormal = planeHit.normal;\n    planeHit.normal = planeNormal;\n    \n    //cyl1\n    //float tCyl = intersectCylinder(rotOrigin, rotRayDir, cylorig, 0.25, 2.0, cylNormal);\n    Hit cyl1Hit;\n    cyl1Hit = intersectCylinder(rotOrigin, rotRayDir, cyl1orig, 0.2, 2., cyl1Normal);\n    cyl1Normal = cyl1Hit.normal;\n    cyl1Normal = quatRot(quatInv(q), cyl1Normal);\n    cyl1Hit.normal = cyl1Normal;\n    \n    //sph2\n    vec4 q2 = quat(normalize(vec3(1, 3, 2)), iTime-40.+80.);\n    vec3 rotOrigin2 = quatRot(q2, rotOrigin-sph2orig) + sph2orig;\n    vec3 rotRayDir2 = quatRot(q2, rotRayDir);\n    Hit sph2Hit;\n    sph2Hit = intersectSphere(rotOrigin2, rotRayDir2, sph2orig, 0.35, sph2Normal);\n    sph2Normal = sph2Hit.normal;\n    sph2Normal = quatRot(quatInv(q2), sph2Normal);\n    sph2Normal = quatRot(quatInv(q), sph2Normal);\n    sph2Hit.normal = sph2Normal;\n    \n    //cyl2\n    //float tCyl2 = intersectCylinder(rotOrigin2, rotRayDir2, cyl2orig, 0.25, 2., cyl2Normal);\n    Hit cyl2Hit;\n    cyl2Hit = intersectCylinder(rotOrigin2, rotRayDir2, cyl2orig, 0.2, 3., cyl2Normal);\n    cyl2Normal = cyl2Hit.normal;\n    cyl2Normal = quatRot(quatInv(q2), cyl2Normal);\n    cyl2Normal = quatRot(quatInv(q), cyl2Normal);\n    cyl2Hit.normal = cyl2Normal;\n    \n    //sph3\n    vec4 q3 = quat(normalize(vec3(1, -2, 1)), iTime-9.+80.);\n    vec3 rotOrigin3 = quatRot(q3, rotOrigin2-sph3orig)+sph3orig;\n    vec3 rotRayDir3 = quatRot(q3, rotRayDir2);\n    Hit sph3Hit;\n    sph3Hit = intersectSphere(rotOrigin3, rotRayDir3, sph3orig, 0.35, sph3Normal);\n    sph3Normal = sph3Hit.normal;\n    sph3Normal = quatRot(quatInv(q3), sph3Normal);\n    sph3Normal = quatRot(quatInv(q2), sph3Normal);\n    sph3Normal = quatRot(quatInv(q), sph3Normal);\n    sph3Hit.normal = sph3Normal;\n    \n    //base\n    //float tBase = intersectCylinder(origin, rayDir, vec3(0, -.5, 0), 2., .2, baseNormal);\n    Hit baseHit;\n    baseHit = intersectCylinder(origin, rayDir, vec3(0, -.5, 0), 2., .3, baseNormal);\n    baseNormal = baseHit.normal;\n    \n    //paraboloid\n    Hit paraHit;\n    paraHit = intersectParaboloid(rotOrigin3, rotRayDir3, paraorig, paraNormal);\n    paraNormal = paraHit.normal;\n    //float tPara = intersectParaboloid(rotOrigin3, rotRayDir3, paraorig, paraNormal);\n    paraNormal = quatRot(quatInv(q3), paraNormal);\n    paraNormal = quatRot(quatInv(q2), paraNormal);\n    paraNormal = quatRot(quatInv(q), paraNormal);\n    paraHit.normal = paraNormal;\n    \n    Hit bestHit = findBestHit(cyl1Hit, sphHit);\n    bestHit = findBestHit(bestHit, sph2Hit);\n    bestHit = findBestHit(bestHit, baseHit);\n    bestHit = findBestHit(bestHit, cyl2Hit);\n    bestHit = findBestHit(bestHit, sph3Hit);\n    bestHit = findBestHit(bestHit, paraHit);\n    bestHit = findBestHit(bestHit, planeHit);\n\n    hit = bestHit;\n    return hit;\n}\n\n// kamera kezeles: https://www.shadertoy.com/view/tscGWM\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //float time = iFrame / 60.0;\n    vec3 lightPos = vec3(0, 5.7, 0 );\n    vec3 lightPos2 = vec3(0, 10, 3 );\n    \n    vec3 kd = vec3(.1, .1, .1);\n    vec3 ks = vec3(.7, .8, .9);\n    rough.ka = kd * PI;\n    rough.kd = kd;\n    rough.ks = ks;\n    rough.shininess = 50.;\n    rough.rough = 1;\n    rough.reflective = 0;\n    \n    \n    // Define the roation speed. Set to 0 to disable\n    const float ROTATION_SPEED = 0.6;\n    \n    // Define the orbit radius\n    const float ORBIT_RADIUS = 8.0;\n    \n    // Define the epsilon value for closeness to be considered a hit\n    const float EPSILON = 0.005;\n    // Define the center of the SDF\n    vec3 sdf_center = vec3(0.0, 0.0, 0.0);\n \n    // Calculate the starting angles for the orbit\n    float theta = iTime * ROTATION_SPEED;\n    \n    // Take some mouse input\n    vec4 mouse = iMouse / iResolution.xyxx;\n    \n    // If the mouse is being held down\n    if (mouse.z > 0.0)\n    {\n        // convert the mouse input to angles\n        theta = mouse.x * 2.0 * 3.14159;\n    }\n    \n    // Define an orbital path based on time\n    vec3 orbit = vec3(cos(theta), 0, sin(theta));\n    \n    // Cacluate the normal of the path. Since its a circle, it will just\n    // be back down into the center\n    vec3 normal = -normalize(orbit);\n    \n    // Calculate the tangent of the path\n    // A circle consists of <cost, sint>, which when differentiated yields\n    // <-sint, cost>. since z is already sint, and x is already cost, the equation\n    // is as follows.\n    vec3 tangent = normalize(vec3(-normal.z, 0.0, normal.x));\n    \n\t// Calculate the UV coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Convert the UV coordinates to a range between -1 and 1\n    vec2 range = uv*2.0 - vec2(1.0,1.0);\n    \n    // Define the Camera position\n    vec3 cam_pos = orbit*ORBIT_RADIUS;\n    cam_pos.y = 3.;\n    \n    // Define the forward, up, and right vectors (needs rework)\n    vec3 forward = normal;\n    vec3 up = -normalize(cross(normal, tangent));\n    vec3 right = tangent;\n        \n    // Calculate the aspect ratio of the screen\n    float aspect = float(iResolution.y) / float(iResolution.x);\n    \n    float fov = PI / 2.;\n    \n    // Calculate the ray as a normalized combination of the forward, right, and up vectors.\n    // Note that the purely forward + horizonal combination yield vectors 45 degrees outward\n    // for a 90 degree field of view. This may be updated with a fov option\n    vec3 rayDir = normalize(forward + range.x*right + range.y*up*aspect);\n    //rayDir.z *= -tan(fov / 2.0);\n    \n    //vec3 origin = vec3(0, 10, 20);\n    vec3 origin = cam_pos;\n    \n    //vec3 rayDir = normalize(vec3(uv * 2. - 1., -tan(fov / 2.0)));\n    \n    //vec3 normal;\n    \n    Hit worldHit = intersectWorld(origin, rayDir);\n    float t = worldHit.t;\n    normal = worldHit.normal;\n    if (dot(normal, rayDir) > 0.0) {\n        normal *= -1.;\n    }\n    \n    vec3 hitPos = origin + rayDir * t;\n    \n    \n    vec3 sph1orig = vec3(0);\n    vec3 sph2orig = vec3(0, 2.2, 0);\n    vec3 sph3orig = vec3(0, 5.2, 0);\n    vec4 q1 = quat(normalize(vec3(1, 3, 2)), iTime-30.+80.5);\n    vec4 q2 = quat(normalize(vec3(1, 3, 2)), iTime-40.+80.);\n    vec4 q3 = quat(normalize(vec3(1, -2, 1)), iTime-9.+80.);\n\n    lightPos = quatRot(quatInv(q3), lightPos - sph3orig) + sph3orig;\n    lightPos = quatRot(quatInv(q2), lightPos - sph2orig) + sph2orig;\n    lightPos = quatRot(quatInv(q1), lightPos - sph1orig) + sph1orig;\n    \n    \n    vec3 toLight = lightPos - hitPos;\n    float distToLight = length(toLight);\n    toLight /= distToLight;\n    \n    vec3 toLight2 = lightPos2 - hitPos;\n    float distToLight2 = length(toLight2);\n    toLight2 /= distToLight2;\n    \n    vec3 outC = vec3(0);\n    vec3 La = vec3(0.4, 0.3, 0.3);\n    vec3 Le = vec3(3,3,3);\n    \n    if (t > 0.0) {\n        outC += worldHit.mat.ka * La;\n        float cosTheta = max(dot(toLight, normal), 0.0);\n\n        Hit lightHit = intersectWorld(hitPos + normal * 0.0001, toLight);\n        float lightT = lightHit.t;\n\n        \n        float lightIntensity = 200.0;\n        if (lightT > 0.0 && lightT < distToLight) {\n            lightIntensity = 0.0;\n        }\n        else {\n            //konzi alapjan\n            outC += worldHit.mat.kd * cosTheta / pow(distToLight, 2.0) * lightIntensity;\n            vec3 halfway = normalize(-rayDir + toLight);\n            float cosDelta = dot(normal, halfway);\n            if (cosDelta > 0.)\n                outC += worldHit.mat.ks * Le * pow(cosDelta, worldHit.mat.shininess);\n        }\n        \n        //l2\n        cosTheta = max(dot(toLight2, normal), 0.0);\n        lightHit = intersectWorld(hitPos + normal * 0.0001, toLight2);\n        lightT = lightHit.t;\n        lightIntensity = 150.0;\n        if (lightT > 0.0 && lightT < distToLight2) {\n            lightIntensity = 0.0;\n        }\n        else {\n            outC += worldHit.mat.kd * cosTheta / pow(distToLight2, 2.0) * lightIntensity;\n            vec3 halfway = normalize(-rayDir + toLight2);\n            float cosDelta = dot(normal, halfway);\n            if (cosDelta > 0.)\n                outC += worldHit.mat.ks * Le * pow(cosDelta, worldHit.mat.shininess);\n        }\n        \n        \n        fragColor = vec4(outC,1);\n    } else {\n        fragColor = vec4(La, 1);\n    }\n    \n}","name":"Image","description":"","type":"image"}]}