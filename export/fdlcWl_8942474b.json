{"ver":"0.1","info":{"id":"fdlcWl","date":"1642905459","viewed":181,"name":"Sea of Mandel Ball'ish Boxes","username":"pb","description":"mandelbox with particular parameters that yield nice hollowed out structures with reflecting sides","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["3d","fractal","reflections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//philip.bertani@gmail.com\n//Gaussian blur (not dependent on distance) to reduce aliasing \n\n//gaussian_kernel_one_stdev\nfloat[] gk1s = float[] (\n        0.003765,0.015019,0.023792,0.015019,0.003765,\n        0.015019,0.059912,0.094907,0.059912,0.015019,\n        0.023792,0.094907,0.150342,0.094907,0.023792,\n        0.015019,0.059912,0.094907,0.059912,0.015019,\n        0.003765,0.015019,0.023792,0.015019,0.003765 );\n        \n        \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    //size of one texel in iChannel0\n    vec2 texel = 1./iResolution.xy;\n\n    vec4 total_color;\n    \n    for (int i=0;i<5;i++){\n        float fi = float(i)-2.;\n        for (int j=0;j<5;j++){ \n            float fj = float(j)-2.;\n            vec4 color = texture(iChannel0, \n                uv + vec2( texel.x*fi,texel.y*fj )  );\n            total_color += color * gk1s[i*5 + j];\n        }\n    }\n    \n    fragColor = total_color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//20220701 - some changes, increased FPS\n\nfloat     objid = 0.0;\nvec3      ifs_color;\nfloat     inf = 1e6;\nfloat     too_small = 1e-6;\nint       num_iter;\nvec3      ro;\n\nfloat params[33] = float[33] (\n-0.10,9.00,-0.3,0.00,0.00,-1.10,0.10,0.00,0.00,\n0.00,0.00,0.00,0.00,-0.40,0.00,0.00,3.00,0.00,\n0.00,0.00,-4.00,2.00,1.00,0.20,0.20,-0.01,-5.40,\n0.00,0.20,0.60,0.00,0.10,0.00\n);\n\n\nfloat de(vec3 p) {\n\n    vec4 q = vec4(p, 1.);\n\n    q.xz = mod(q.xz + 2.1, 4.2) - 2.1;\n    q.xyz -= 1.0;\n\n    int max_iter = int(params[1]);\n    num_iter = 0;\n\n    for(int i = 0; i < 8; i++) {\n        \n \n        clamp (q, -inf, inf);\n\n        q.xyz = abs(q.xyz + (1.+params[32])*1.0) - (1.+params[32])*1.0*(1.+q.xyz/50.*(1.+params[19]));\n\n        if ( abs(q.x) < too_small ) q.x = sign(q.x) * too_small;\n        if ( abs(q.y) < too_small ) q.y = sign(q.y) * too_small;\n        if ( abs(q.z) < too_small ) q.z = sign(q.z) * too_small;\n\n        q /= clamp(dot(q.xyz, q.xyz), 0.4+params[2], 1.0+params[3]);\n        q *= 1.18 * (1.+params[4]);\n\n        q *= 1. + (params[30])*q.y;\n        \n        num_iter = i;\n    }\n    \n    float div = 1. + params[12];\n\n    clamp( q, -inf, inf );\n\n    ifs_color = (1. + params[31]*float(num_iter) )* vec3( cos(q.x/div), cos(q.y/div), cos(q.z/div) );\n\n    float d1 = p.y + 6.1 + params[26];  // floor\n\n    if ( abs(q.w) < too_small ) q.w = sign(q.w) * too_small;\n    float d2 = length( max( abs(q.xyz) - vec3(1.2+params[5],1.2+params[6], 1.2+params[18]), 0.0) )/q.w;\n     \n    objid = 0.0;\n    if ( d1 < d2 ) objid = 1.;  //floor\n    return min(d1 , d2);\n}\n\nfloat raymarch(vec3 ro, vec3 rd, float mx) {\n    float t = 0.0;\n     \n    float eps = .0001;\n    \n    for(int i = 0; i < 200; i++) {\n        float d = de(ro + rd*t);\n        if (d < eps || t >= mx) break;\n        t += d*0.7;\n        eps *= (1.+d/3.);\n    }\n    return t;\n}\n\n//got this phong from one of IQs shaders\nvec3 phong(\n  in vec3 pt,\n  in vec3 prp,\n  in vec3 normal,\n  in vec3 light,\n  in vec3 color,\n  in float spec,\n  in vec3 ambLight)\n{\n   vec3 lightv=normalize(light-pt);\n   float diffuse=dot(normal,lightv);\n   vec3 refl=-reflect(lightv,normal);\n   vec3 viewv=normalize(prp-pt);\n   float specular=pow(max(dot(refl,viewv),0.0),spec+params[20]);\n   return (max(diffuse,0.0)+ambLight)*color + specular;\n}\n\nvec3 normal(vec3 p) {\n    vec2 h = vec2(0.001 + params[25], 0.0);\n    vec3 n = vec3(\n        de(p + h.xyy) - de(p - h.xyy),\n        de(p + h.yxy) - de(p - h.yxy),\n        de(p + h.yyx) - de(p - h.yyx));\n    \n    // strange that there is the potential for inf problems here but this got\n    // rid of the last square black blobs\n    return clamp(normalize(n),-inf,inf);\n}\n\nfloat ao(vec3 p, vec3 n) {\n    float o = 0.0, s = 0.010, w = 1.0;\n    \n    int max_iter = int(params[17]);\n    for(int i = 0; i < 50; i++) {\n     \n        if (i > max_iter) break;\n        float d = de(p + n*s);\n        o += (s - d)*w;\n        w *= 0.90;\n        s += s/float(i + 1);\n    }\n    \n    return clamp(1.0 - o, 0.0, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0);\n  \n    vec3 light_dir = vec3( 1.0, 0.0, 1.0) + ro;\n    vec3 color     = vec3( params[27], params[28], params[29]);\n    float specular_power = 12.;\n    vec3 ambient_light = vec3(.3, .3, .3);\n    vec3 floor_color = .3*vec3(0.,.1,.3);\n    vec3 prime_ifs_color = vec3(0. ,0., 0.);\n\n    float t = raymarch(ro, rd, 200.0);\n    if(t < 200.0) {\n\n        vec3 pos = ro + rd*t;\n\n        vec3 nor = normal(pos);\n\n        float ambient_occlusion = 1.;  //ao(pos, nor);\n           \n        vec3 cf = phong( pos, ro, nor, light_dir, color, specular_power, ambient_light);       \n\n        col = ambient_occlusion * cf * (1.-objid); //lazy way of excluding floor\n\n        col += .3 * floor_color * objid;  // if it is the floor then add a bit of floor color to every pixel\n\n        float global_light_mult = exp(-(1.+params[13])*t*t/40.);\n\n        //ifs_color = mix( vec3(0), ifs_color, global_light_mult );\n        //col += params[15]*ifs_color * (1.-objid); \n        //col += .4*ifs_color * (1.-objid);\n\n        if (params[21] > 0. ) {\n            // first reflection\n            vec3 pos2 = ro + rd*.999*t; \n            vec3 ref = reflect(rd, nor);\n            float tt = raymarch( pos2, ref, 150.);\n\n            if ( tt < 150.) {\n\n                color = vec3(.1,.1,.2);\n                vec3 ppos = pos2 + ref*.999*tt;\n                vec3 nnor = normal(ppos);\n                vec3 rref = reflect(ref, nnor);\n                vec3 cf2 = phong( ppos, ro, nnor, light_dir, color, specular_power, ambient_light); \n                col += params[23] * cf2 * (1.-objid);                    \n                col += params[23] * .3 * objid*floor_color;\n                col += params[23] * params[15] * ifs_color; \n                \n              if (params[21] > 1.) {\n              \n                //second reflection\n                color = vec3(.1,.2,.2);\n                vec3 pos3 = pos2  + ref*.999*tt;\n                float ttt = raymarch( pos3, rref, 80.);\n                if (ttt < 80. ) {\n                   vec3 pppos = pos3 + rref * ttt;\n                   vec3 nnnor = normal(pppos);\n                   vec3 cf3 = phong( pppos, ro, nnnor, light_dir, color, specular_power, ambient_light);\n                   col += params[24] * cf3 * (1.-objid); \n                   col += params[24] * .1 * objid * floor_color; \n                   col += params[24] * params[15]*ifs_color; \n\n                }\n\n              }\n\n            }\n        }\n\n        col = global_light_mult * col;\n  \n    }\n        \n    return clamp(col, 0., 1.);\n}\n\nmat3 rot(float a) {\n\n    float ca = cos(a);\n    float sa = sin(a);\n\n    return mat3( vec3(ca, 0.,-sa),\n                 vec3(0., 1., 0.),\n                 vec3(sa, 0., ca)  );   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    float angle = 3.14159265 / 4. + iTime/8.;\n\n    ro = vec3( 0., 0., 2. -  iTime/2. );\n \n    float  focal_point = -2.;\n    vec3 rd =  rot(angle) * normalize(vec3(uv,focal_point));\n\n    vec3 color = render(ro, rd);\n    \n    color = pow(abs(color), vec3(.6));\n   \n    fragColor = vec4( clamp(color,0.,1.) ,  1.);\n\n   \n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}