{"ver":"0.1","info":{"id":"lXjXDc","date":"1711274185","viewed":90,"name":"SDF Illustrator inflate effect","username":"aidanwyber","description":"Trying to emulate the 3D \"inflate\" effect in Adobe Illustrator with a custom SDF for polygons.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","sdf","polygon","illustrator","inflate"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nAdobe Illustrator 3D inflate effect for 2D polygons\n\nWorks by multiplying SDFs of the polygon line segments.\nDrag mouse to show the inflatePoly function.\n\nAidan Wyber March 2024\n*/\n\n#define AA 2\n#define t iTime*2.\n#define PI 3.14159\n#define nmc(x) (-cos(x)*0.5+0.5)\n\n#define N 5 // number of points in the polygon, can also be a const int\n\nfloat dot2(in vec2 v) { return dot(v,v); }\nfloat cross2d(in vec2 v0, in vec2 v1) { return v0.x * v1.y - v0.y * v1.x; }\nfloat circleMap(in float x) { return sqrt(1. - (x - 1.) * (x - 1.)); }\n\n// from iq:\n// https://www.shadertoy.com/view/wdBXRW\n// iquilezles.org/articles/distfunctions2d\n// used only for determining the polygon mask in polyMask()\nfloat sdPolygon( in vec2 p, in vec2[N] v) {\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\nfloat polyMask(in vec2 p, in vec2[N] poly) {\n    float sdPoly = sdPolygon(p, poly);\n    return sdPoly < 0. ? 1. : 0.;\n}\n\n// from iq\n// https://www.shadertoy.com/view/3tdSDj\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b ) {\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\nfloat triArea(in vec2 a, in vec2 b, in vec2 c) {\n    // (b[X] - a[X]) * (c[Y] - a[Y]) - (c[X] - a[X]) * (b[Y] - a[Y])\n    return 0.5 * ((b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y));\n}\n\nfloat inflatePoly(in vec2 uv, in vec2[N] poly) {\n    const int n = poly.length();\n    \n    // calc polygon centroid\n    // from: https://gis.stackexchange.com/questions/164267/how-exactly-is-the-centroid-of-polygons-calculated\n    vec2 centroidd = vec2(0.);\n    float areaSum = 0.;\n    for (int i = 1; i < n - 1; i++) {\n        vec2 triCentroid = (poly[0] + poly[i] + poly[i+1]) / 3.;\n        float triArea = triArea(poly[0], poly[i], poly[i+1]);\n        areaSum += triArea;\n        centroidd += triCentroid * triArea;\n    }\n    centroidd /= areaSum;\n       \n    float inflateCentroid = 1.;\n    for (int i = 0; i < n; i++) {\n        int nexti = i + 1 == n ? 0 : i + 1;\n        float udSegment = udSegment(centroidd, poly[i], poly[nexti]);\n        inflateCentroid *= udSegment;\n    }     \n    \n    float inflate = 1.;\n    for (int i = 0; i < n; i++) {\n        int nexti = i + 1 == n ? 0 : i + 1;\n        float udSegment = udSegment(uv, poly[i], poly[nexti]);\n        inflate *= udSegment;\n    }\n   \n    \n    inflate /= inflateCentroid;\n    \n    //return circleMap(inflate * 0.6);\n    return inflate * 0.8;\n}\n\nvec3 inflateNormal(in vec2 uv, in vec2[N] poly) {\n    float e = 0.0001;\n    vec2 h = vec2(e, 0.);\n    float f = inflatePoly(uv, poly);\n    return normalize(\n        vec3(\n            inflatePoly(uv + h.xy, poly) - f,\n            inflatePoly(uv + h.yx, poly) - f,\n            e*2.\n        )\n    );\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2[] poly = vec2[N](\n        //vec2(0.1, 0.1),\n        //vec2(0.15, 0.7),\n        //vec2(0.6, 0.9),\n        //vec2(0.9, 0.5),\n        //vec2(0.5, 0.1)\n        vec2(0.1 + 0.12 * cos(-0.40*t), 0.9 + 0.1 * sin(+0.80*t)) * 0.8 + 0.1,\n        vec2(0.9 + 0.13 * cos(+0.50*t), 0.9 + 0.1 * sin(-0.70*t)) * 0.8 + 0.1,\n        vec2(0.9 + 0.10 * cos(-0.60*t), 0.1 + 0.1 * sin(+0.60*t)) * 0.8 + 0.1,\n        vec2(0.4 + 0.08 * cos(+0.70*t), 0.1 + 0.1 * sin(-0.50*t)) * 0.8 + 0.1,\n        vec2(0.1 + 0.10 * cos(-0.80*t), 0.1 + 0.1 * sin(+0.40*t)) * 0.8 + 0.1\n    );\n    \n    //const vec3 sun = normalize(vec3(-0.7, -1, 1.5));\n    vec3 sun = normalize(vec3(cos(t*0.2), sin(t*0.2), 0.5));\n    float highlightPow = 300.;\n\n    vec3 aaCol = vec3(0.);\n    for (int AAx = 0; AAx < AA; AAx++) {\n        for (int AAy = 0; AAy < AA; AAy++) {\n            vec2 aa = vec2(AAx, AAy) / float(AA) / iResolution.xy;\n            \n            vec2 uv = fragCoord/iResolution.xy + aa;\n\n            float polyMask = polyMask(uv, poly);\n            float inflate = inflatePoly(uv, poly);\n            vec3 inflateNormal = inflateNormal(uv, poly);\n\n            float spec = clamp(dot(inflateNormal, sun), 0., 1.);\n            float spec2 = clamp(dot(inflateNormal, sun.zyx), 0., 1.);\n            float highlight = pow(spec, highlightPow) + pow(spec2, highlightPow);\n\n            vec3 bgCol = vec3(0., 1., 0.5);\n            \n            float darkness = 0.3;\n            bgCol *= mix(1. - darkness, 1., clamp(dot(inflateNormal, sun), 0., 1.));\n            const vec3 polyCol = vec3(1.0, 0.2, 0.);\n\n            vec3 poly = mix(bgCol * 0., polyCol, 1. - (1. - spec) * (1. - spec2) * darkness);\n            poly = mix(poly, vec3(1.), highlight);\n\n            vec3 col = mix(bgCol, poly, polyMask);\n            \n            if (iMouse.z > 0. && uv.x > iMouse.x/iResolution.x) \n                col = vec3(inflate);\n            \n            aaCol += col;\n        }\n    }\n    aaCol /= float(AA * AA);\n    \n    fragColor = vec4(aaCol, 1.0);\n}","name":"Image","description":"","type":"image"}]}