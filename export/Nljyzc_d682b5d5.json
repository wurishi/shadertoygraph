{"ver":"0.1","info":{"id":"Nljyzc","date":"1650031822","viewed":256,"name":"Fast night sky","username":"stduhpf","description":"star field thing (no bloom)","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["stars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define MILKY_WAY //noticable performance hit when enabled (but still pretty fast)\n\nfloat hash31(vec3 p){ \n  \n    return fract(sin(dot(p,vec3(10.9898,70.233,40.6474)))*45758.5433);\n}\n\nfloat starnoise(vec3 rd){ //rd needs to be normalized\n    const vec3 amps = vec3(.6,.45,.15); //sum>1 for scaling \n    const vec4 cs = vec4(3./5.,4./5.,5./13.,12./13.); //cos and sines using paythagorean triplets\n    const mat3 arbitrartyRotAndScale = mat3(dot(amps,vec3(1,cs.x,cs.z)),amps.z*cs.w,amps.y*cs.y,\n                                        -cs.w*amps.z,dot(amps,vec3(1.,1.,cs.z)), 0,\n                                        -cs.y*amps.y,0,dot(amps,vec3(1,cs.x,1.)));\n                                         \n    float c = 0.;\n    vec3 p = rd*300.;\n\tfor (float i=0.;i<4.;i++)\n    {\n        vec3 q = fract(p)-.5;\n        vec3 id = floor(p);\n        float c2 = smoothstep(.25,0.,dot(q,q));\n        c2 *= step(hash31(id),.02-i*i*0.002);\n        c += c2;\n        p = p*arbitrartyRotAndScale;\n    }\n    c*=c;\n    \n    //giroid-based intensity variation\n    float g = dot(sin(rd*12.12),cos(rd.yzx*4.512));\n    float d=smoothstep(-3.14159265359,-.9,g)*.5+.5*smoothstep(-.3,1.,g);\n    c*=d*d*.5+d*.5;\n    return c*c;\n}\n\n#ifdef MILKY_WAY\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx)-.5;\n\n}\n\nfloat simplex(vec3 p){\n    const float F = .33333333333;//(sqrt(n+1)-1)/n\n    const float G = .16666666667;//(1-1/sqrt(n+1))/n\n    \n    vec3 b = floor(p+dot(p,vec3(F)));\n    vec3 d = p - b + dot(b,vec3(G));\n    vec3 test = step(d,d.yzx);\n    \n    vec3 v1 = (1.-test)*test.zxy;  \n    vec3 v2 = 1.-test*(1.-test.zxy);\n    \n    vec3 g1 = hash33(b);\n    vec3 g2 = hash33(b+v1);\n    vec3 g3 = hash33(b+v2);\n    vec3 g4 = hash33(b+1.);\n    \n    vec3 d2 = d - v1 + G;\n    vec3 d3 = d - v2 + F;\n    vec3 d4 = d - .5;\n    \n    vec4 dots = vec4(dot(d,g1),dot(d2,g2),dot(d3,g3),dot(d4,g4));\n    \n    vec4 g = max(.5-vec4(dot(d,d),dot(d2,d2),dot(d3,d3),dot(d4,d4)),0.);\n    g*=g;\n    return (64.*dot(g*g,dots));\n}\n\nfloat fbm(vec3 p){\n    p+=simplex(p-.3*simplex(p+p.yzx))*.5;\n    return simplex(p)*.75+.25*simplex(p.zxy*2.);\n}\n\nfloat milkyWay(vec3 rd){\n    rd = (rd.zxy+rd.yzx)/sqrt(2.);\n    vec3 rds = rd*rd;\n    \n    float glow =  exp2(-rds.y*8.)*exp2(-rds.z*90.)*max(rd.x,0.);\n    glow*=glow;\n    \n    float cloud = smoothstep(smoothstep(0.,.25*exp2(-rds.y*4.),abs(rd.z)),1.,fbm(rd*10.)*.5+.5);\n    \n    glow*=exp2(-cloud*cloud*8.);\n    \n    return glow*.0125;\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 2.-cos(iTime*.2);\n    vec2 m = acos(-1.)*mix(vec2(-1,-.5),vec2(1,.5),iMouse.xy/iResolution.xy);\n    \n    float cx = cos(m.y),sx=sin(m.y);\n    mat3 rx = mat3(1,0,0,0,cx,sx,0,-sx,cx);\n        \n    float cy = cos(m.x),sy=sin(m.x);\n    mat3 ry = mat3(cy,0,sy,0,1,0,-sy,0,cy);\n    \n    \n    vec3 rd = normalize(vec3(fragCoord-iResolution.xy*.5,zoom*iResolution.y))*rx*ry;\n    \n    float l = starnoise(rd)\n    #ifdef MILKY_WAY\n    +milkyWay(rd)\n    #endif\n    ;\n\n    fragColor = vec4(sqrt(l));\n}","name":"Image","description":"","type":"image"}]}