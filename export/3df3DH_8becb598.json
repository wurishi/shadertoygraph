{"ver":"0.1","info":{"id":"3df3DH","date":"1545962873","viewed":185,"name":"GS Rubber Floor with Shadows","username":"slimyfrog","description":"GS Second experiment with soft shadows and some optimizations to ray marching","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["shadows","checkers","smoothmin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DISTANCE   20.0\n#define MIN_DISTANCE    0.001\n#define PI \t\t\t    3.142\n#define PI2 \t\t   (PI/2.0)\n#define SPHERE_HEIGHT\t0.55\n#define AMBIENT_COLOR    vec3(0.38,0.29f,0.9f)\n// smooth min from iq\nfloat smoothmin( float a, float b)\n{\n    float h = max( 1.0-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*h*(1.0/6.0);\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nfloat planeDf(vec3 p)\n{    \n    return p.y; // implied p.y - 0.0 where 0.0 is plane height\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nfloat sphereDf(vec3 p, vec3 spherePos, float radius)\n{\n    return length(spherePos + p) - radius;\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nfloat boxDf( vec3 p, vec3 boxPos, vec3 size )\n{\n  vec3 d = abs(p + boxPos) - size;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nfloat sceneDf(vec3 p)\n{\n    float sphereDist = sin(iTime * 0.2) * 10.0;\n    //sphere positions\n    vec3 sp1 = vec3(sin(iTime) * sphereDist,SPHERE_HEIGHT, cos(iTime)* sphereDist);\n    vec3 sp2 = vec3(sin(iTime + PI2)* sphereDist,SPHERE_HEIGHT, cos(iTime +PI2)* sphereDist);\n    vec3 sp3 = vec3(sin(iTime + PI)* sphereDist,SPHERE_HEIGHT, cos(iTime+PI)* sphereDist);\n    vec3 sp4 = vec3(sin(iTime + PI2*3.0)* sphereDist,SPHERE_HEIGHT, cos(iTime+PI2*3.0)* sphereDist);\n    \n    float dist = smoothmin(\n        sphereDf(p, sp1, 1.0), \n        sphereDf(p, sp2, 1.0));\n    dist = smoothmin(\n        sphereDf(p, sp3, 1.0), \n        dist);\n    dist = smoothmin(\n        sphereDf(p, sp4 , 1.0), \n        dist);\n    dist = smoothmin(dist, planeDf(p));\n    \n    dist = smoothmin(dist, boxDf(p, vec3(0), vec3(1)));\n    return dist;\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nvec3 calcNormal(vec3 p)\n{\n    float e = 0.01f;\n    \n    vec3 normal;\n    normal.x = sceneDf(vec3(p.x + e,p.y,p.z)) - sceneDf(vec3(p.x - e, p.y, p.z));\n    normal.y = sceneDf(vec3(p.x,p.y + e,p.z)) - sceneDf(vec3(p.x, p.y - e, p.z));\n    normal.z = sceneDf(vec3(p.x,p.y,p.z + e)) - sceneDf(vec3(p.x, p.y, p.z - e));\n    \n    return normalize(normal);\n}\n\n// odd/even checker pattern\nfloat checkers( in vec3 p )\n{\n    return int(50.0+p.x)%2 != int(50.0+p.z)%2 ? 1.0 : 0.0;\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nfloat calcShadow(vec3 pt, vec3 dir)\n{\n    float shade = 1.0;\n\tfloat t = 0.02;\n    while(t < 5.0)\n    {\n        float dist = sceneDf(pt + dir * t);\n        t += dist;\n        shade = min(shade, 5.0 * dist/t);\n        if (dist <= 0.001){\n            break;\n        }\n    }\n    return shade;\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nvec3 processLighting(vec3 baseColor, vec3 eyePos, vec3 surfacePoint)\n{\n\tconst vec3 ambientLight =AMBIENT_COLOR;\n    \n    vec3 diffuseDir = normalize(vec3(1,-0.75, -1));\n    float diffuseIntensity = 0.7f;\n    \n    float shaded = calcShadow(surfacePoint, -diffuseDir);\n    vec3 normal = calcNormal(surfacePoint);\n    \n    vec3 e = normalize(eyePos);\n    vec3 r = normalize(reflect(diffuseDir,normal));\n\tfloat specular =  pow(max(dot(r,e),0.0),8.0);\n\tspecular = clamp(specular, 0.0, 1.0);\n                 \n    float diffDot = max(dot(-diffuseDir, normal), 0.0);\n        \n    vec3 color = baseColor * (ambientLight +  (diffDot * vec3(0.8,0.8,0.6) + specular) * shaded);\n    return color;\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nvec3 marchRay(vec3 eyePos,vec3 dir)\n{\n    vec3 color =  AMBIENT_COLOR * 1.5;\n    float t = 0.001;\n    while(t < MAX_DISTANCE)\n    {\n        vec3 currentPoint = eyePos + (t * dir);\n        float dist = sceneDf(currentPoint);\n        if(dist <= MIN_DISTANCE)\n        {\n            color = processLighting(vec3(checkers(currentPoint)), eyePos, currentPoint);\n            break;\n        }\n        t += dist;\n    }\n    return color;\n}\n\n\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera\t\n\tvec3 eye = vec3( sin(iTime * 0.2) * 7.0, 3.0, cos(iTime * 0.2) * 7.0 );\n    vec3 lookat = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 forward = normalize( lookat - eye );\n    vec3 right = normalize( cross(forward,vec3(0.0,1.0,0.0) ) );\n    vec3 up = normalize( cross(right, forward));\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    // create view ray\n    vec3 dir = normalize( p.x*right + p.y*up + 3.5*forward );\n       \n    vec3 color = marchRay(eye, dir);\n    vec3 grayscale = vec3(dot(color, vec3(0.25, 0.7, 0.05)));\n    \n    fragColor = vec4(mix(color, grayscale, sin(iTime)),1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}