{"ver":"0.1","info":{"id":"wlsSzr","date":"1562275658","viewed":688,"name":"3D particles concept","username":"jaszunio15","description":"Simple concept of 3D particles.\n\nShader License: CC BY 3.0\nAuthor: Jan Mróz (jaszunio15)","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["3d","particles","particlesystem"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Shader License: CC BY 3.0\n//Author: Jan Mróz (jaszunio15)\n\n//Random point from [rootUV] to [rootUV + 1.0]\nvec2 particleCoordFromRootUV(vec2 rootUV)\n{\n    return rotate(vec2(0.0, 1.0), TIME * 3.0 * (hash12(rootUV) - 0.5)) * (0.5 - PARTICLE_SIZE) + rootUV + 0.5;\n}\n\n//particle shape\nfloat particleFromParticleUV(vec2 particleUV, vec2 uv)\n{\n \treturn 1.0 - smoothstep(PARTICLE_SIZE/2.0, PARTICLE_SIZE, length(particleUV - uv));   \n}\n\n//grid based particle layer\nfloat particlesLayer(vec2 uv, float seed)\n{\n   \tuv = uv + hash21(seed) * 10.0;\n    vec2 rootUV = floor(uv);\n    vec2 particleUV = particleCoordFromRootUV(rootUV);\n    float particles = particleFromParticleUV(particleUV, uv);\n    return particles;\n}\n\nfloat layerScaleFromIndex(float index)\n{\n \treturn index * SIZE_MOD; \n}\n\nfloat layeredParticles(vec2 screenUV, vec3 cameraPos)\n{\n    screenUV *= FOV;\n\tfloat particles = 0.0;\n    float alpha = 1.0;\n    float previousScale = 0.0;\n    float targetScale = 1.0;\n    float scale = 0.0;\n    \n    //Painting layers from front to back\n    for (float i = 0.0; i < LAYERS_COUNT; i += 1.0)\n    {\n        //depth offset\n        float offset = fract(cameraPos.z);\n        \n        //blending back and front\n        float blend = smoothstep(0.0, FRONT_BLEND_DISTANCE, i - offset + 1.0);\n        blend *= smoothstep(0.0, -BACK_BLEND_DISTANCE, i - offset + 1.0 - LAYERS_COUNT);\n        \n        float fog = mix(alpha * ALPHA_MOD, alpha, offset) * blend;\n        \n        targetScale = layerScaleFromIndex(i + 1.0);\n        \n        //dynamic scale - depends on depth offset\n        scale = mix(targetScale, previousScale, offset);\n        \n        //adding layer\n     \tparticles += particlesLayer(screenUV * scale + cameraPos.xy, floor(cameraPos.z) + i) * fog;\n        alpha *= ALPHA_MOD;\n        previousScale = targetScale;\n    }\n    \n    return particles;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.x;\n    \n    //smooth camera movement\n \tvec3 cameraPos = vec3(cos(TIME * 0.096) * 60.0,\n                          cos(TIME * 0.06 + 1.0) * 30.0, \n                          -cos(TIME * 0.4 + 1.0) * 10.0);\n\t\n    float particles = layeredParticles(uv, cameraPos);\n    fragColor = vec4(particles);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define LAYERS_COUNT 14.0\n#define SIZE_MOD 1.2\n#define ALPHA_MOD 0.9\n#define FRONT_BLEND_DISTANCE 1.0\n#define BACK_BLEND_DISTANCE 4.0\n#define PARTICLE_SIZE 0.08\n#define FOV 1.0\n\n#define TIME (iTime * 0.4)\n\nfloat hash12(vec2 x)\n{\n \treturn fract(sin(dot(x, vec2(43.5287, 41.12871))) * 523.582);   \n}\n\nvec2 hash21(float x)\n{\n \treturn fract(sin(x * vec2(24.0181, 52.1984)) * 5081.4972);   \n}\n\nvec2 rotate(vec2 point, float angle)\n{\n \tfloat s = sin(angle);\n    float c = cos(angle);\n    return point * mat2(s, c, -c, s);\n}","name":"Common","description":"","type":"common"}]}