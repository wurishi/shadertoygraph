{"ver":"0.1","info":{"id":"4cy3W1","date":"1712672454","viewed":46,"name":"screen border","username":"romeosoft","description":"Generates a beautiful screen border using mathematical functions.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["screen","ui"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n                          .-''--.\n                         _`>   `\\.-'<\n                      _.'     _     '._\n                    .'   _.='   '=._   '.\n                    >_   / /_\\ /_\\ \\   _<\n                      / (  \\o/\\\\o/  ) \\\n                      >._\\ .-,_)-. /_.<\n                          /__/ \\__\\\n                            '---'  \n            \n          “If I can’t picture it, I can’t understand it.”\n*/\n// power interpolation\nreal blend(real a, real b, real t, real power)\n{\n    return mix(a, b, pow(t, power));\n}\n// segment boundary value\nreal seg2(vec2 v, vec2 m, vec2 M)\n{\n    real x = v.x*0.5 + pi/8.0;\n    real y = v.y*0.9;\n    return  1.5 - blend(0.0, 0.7, sin(x*4.0)*cos(y*4.0),0.125);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy;\n    \n    vec2 pp = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    float eyer = 2.0;\n    float eyea = -((iMouse.x) / iResolution.x) * pi * 2.0;\n    float eyef = ((iMouse.y / iResolution.y)-0.24) * pi * 2.0;\n    \n\tvec3 cam = vec3(\n        eyer * cos(eyea) * sin(eyef),\n        eyer * cos(eyef),\n        eyer * sin(eyea) * sin(eyef));\n    \n    ROT(cam.xz, (0.25) * (iTime + 15.0));\n    \n\tvec3 front = normalize(- cam);\n\tvec3 left = normalize(cross(normalize(vec3(0.0,1,-0.01)), front));\n\tvec3 up = normalize(cross(front, left));\n\tvec3 v = normalize(front*1.5 + left*pp.x + up*pp.y);\n    \n    vec3 p = cam;\n    \n    float dt = 0.1;\n    vec3 cor = vec3(0.0);\n    vec3 o1 = vec3(1.0,0.0, -0.0);\n    vec3 o2 = vec3(0.0,-1.0,0.0);\n    vec3 o3 = vec3(-0.0,0.0,1.0);\n    \n    for(int i = 0; i < 100; i ++)\n    {\n        p += v * dt;\n     \n        float r1 = length(p-o1);\n        float r2 = length(p-o2);\n        float r3 = length(p-o3);\n        \n        vec3 f = \n        normalize(o1-p)*(1. / (r1*r1)) + \n        normalize(o2-p)*(.25 / (r2*r2)) +\n        normalize(o3-p)*(.125 /(r3*r3));\n       \n        cor += (f) * 0.01;\n    }\n    \n    vec4 color = vec4(sin(cor*10.0),1.0);\n    \n    crd2 c1 = coord(vec2(0.89,0.5),vec2(1.,0.), 1.15); // Coordinate System\n    \n    real sd = 0.0;\n    {\n         vec2 p = crd_div(uv, c1);\n         real b = seg2(p, vec2(-0.45), vec2(0.45));\n                             \n         sd = max(sd, b); \n    }\n    real lum = pow(sd, 100.0+10.0 * sin(iTime*0.001));\n    fragColor = vec4(0.5 * sin(lum*0.01)) + (1.0 - clamp(lum, 0.0, 1.0)) * color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define real float\n#define ROT(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n#define pi 3.1415926535\n#define crd2 coord2\n// ---------------------------------------------------------\n// Coordinate System 2D\n// C++ version : \n// https://github.com/panguojun/Coordinate-system-transformation\n// ---------------------------------------------------------\nstruct coord2\n{\n   vec2 ux,uy;   // two axial unit vectors\n   real s;       // scaling[opt]\n   vec2 o;       // origin\n};\ncrd2 coord(vec2 _o, vec2 _ux, real _s)\n{\n    crd2 c; c.ux = _ux;c.uy = vec2(-_ux.y, _ux.x);c.o = _o; c.s = _s;\n    return c;\n}\n// mul: define a vector in a coordinate system\nvec2 crd_mul (vec2 p, coord2 c)\n{\n\treturn c.ux * (p.x*c.s) + c.uy * (p.y*c.s) + c.o;\n}\n// div: measure a vector in a coordinate system\nvec2 crd_div (vec2 p, crd2 c)\n{\n    vec2 v = p - c.o;\n    return vec2(dot(v,c.ux)/c.s, dot(v,c.uy)/c.s);\n}\n// rot: rotate the coord\ncrd2 crd_rot (crd2 c, real ang)\n{\n    ROT(c.ux, ang);\n    ROT(c.uy, ang);\n    return c;\n}\n// ---------------------------------------------------------\n// Boundary SD\n// ---------------------------------------------------------\nreal seg(real x, real m, real M)\n{\n    if(x < m || x > M)\n        return 0.0;\n    return max(x - m,M - x);\n}","name":"Common","description":"","type":"common"}]}