{"ver":"0.1","info":{"id":"NljXzm","date":"1628273375","viewed":1347,"name":"Kaleidoscopic tiling","username":"felipetovarhenao","description":"Kaleidoscopic tiling using shaping functions and tile rotations","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["kaleidoscope","tiling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Author: Felipe Tovar-Henao [www.felipe-tovar-henao.com]\n    Description: Kaleidoscopic tiling using shaping functions and tile rotations.\n*/\n\n#define u_resolution iResolution\n#define u_time iTime\n\nfloat fold(in float x) {\n    return abs(mod(x+1.0,2.0)-1.0);\n}\n\nfloat camel_ramp(in float x, in float s) {\n    float y = fract(x);\n    return floor(x) + pow(0.5 - (0.5 * cos(6.28318530718*y) * cos(3.14159265359*y)), s);\n}\n\nfloat cosine_ramp(in float x, in float s) {\n    float y = cos(fract(x)*3.14159265359);\n    return floor(x) + 0.5 - (0.5*pow(abs(y), 1.0/s)*sign(y));\n}\n\nfloat bump_ramp(in float x, in float s) {\n    float y = fract(x);\n    return floor(x) + pow(y, exp(s*y));\n}\n\nvec2 rotate2D(in vec2 vUV, in float theta) {\n    vec2 r = vec2(cos(theta), sin(theta));\n    return vUV * mat2(r.x, -r.y, r.y, r.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 vUV = fragCoord.xy / u_resolution.xy;\n    vUV -= 0.5;\n    float aspect = u_resolution.x / u_resolution.y;\n    vUV.x *= aspect;\n    float theta = cosine_ramp(u_time * 0.075, 2.0);\n    vUV = rotate2D(abs(vUV+vec2(0.15*aspect, 0.0))*3.7, theta);;\n    vec2 vUVA = mod(vUV, max(vec2(0.1), mod(abs(fract(vUV)*2.3 - fract(vUV+0.3) + 0.2), 2.0)));    \n    vUV = mix(vUV, vUVA, fold(theta));\n    vUV = vec2(fold(vUV.x), fold(vUV.y));\n    vec2 fUV = fract(vUV);\n    vec2 iUV = floor(vUV);\n    float dx = length(iUV-0.5);\n    fUV = rotate2D(fUV, cosine_ramp(u_time*0.3, 2.0));\n\n    float s = fold(u_time*0.4)*2.0 + 2.0;\n    float border = dx * 0.05 + 0.25;\n    float x1 = camel_ramp(fUV.x,s) * border;\n    float y1 = camel_ramp(fUV.y,s) * border;\n \n    float edge = 0.015;\n    float bottom = smoothstep(edge,0.0, abs(x1-fUV.y));\n    float top = smoothstep(edge,0.0, abs(x1+(1.0-border)-fUV.y));\n    float left = smoothstep(edge,0.0, abs((1.0-border)+y1-fUV.x));\n    float right = smoothstep(edge, 0.0, abs(y1-fUV.x));\n\n    float tile = clamp(top+bottom+left+right, 0.0, 1.0);\n    tile = smoothstep(0.0, 1.0, tile);\n    float len = length(vec2(x1, y1)*1.2);\n\n    vec3 color = vec3(0.0);\n    vec3 c1a = vec3(0.9412, 0.5725, 0.5725);\n    vec3 c1b = vec3(0.9216, 0.4275, 0.4196);\n    vec3 c1 = tile * mix(c1a, c1b, fold(u_time*0.125));\n    color = clamp(color-c1, 0.0, 1.0) + c1;\n    \n    vec3 c2a = vec3(0.5294, 0.6784, 0.8039);\n    vec3 c2b = vec3(0.3922, 0.4627, 0.5804);\n    vec3 c2 = bump_ramp(fold(len*13.0 + (sin(0.3*u_time + vUV.x) * 3.0)), 3.5) * mix(c2a, c2b, fold(u_time * 0.2));\n    c2 = smoothstep(0.0,1.0,c2);\n    color = clamp(color-c2, 0.0, 1.0) + c2;\n    vec3 shade = clamp(1.0-color, 0.0, 1.0) * vec3(0.098, 0.098, 0.1098);\n    color = clamp(color-shade, 0.0, 1.0) + shade;\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}