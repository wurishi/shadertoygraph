{"ver":"0.1","info":{"id":"fslyDS","date":"1642630706","viewed":150,"name":"Toy holographic element","username":"KylBlz","description":"This is just for fun, I wanted to know what the holographic surface would look like.\nkeyboard controls (WASD LShift space mouse) but disable animation first.\nSimply set the eyebox closer for bigger FOV (Image tab, line 8)\n","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["optical","toy","holographic","element"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 0.5;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 asp = vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 ndc = uv * 2.0 - 1.0;\n    \n    vec3 eb = vec3(0.0, 0.0, -1.0);\n    \n    // get current cam\n\tvec3 l = textureLod(iChannel1, POS / iResolution.xy, 0.0).xyz,\n\t\t o = textureLod(iChannel1, ROT / iResolution.xy, 0.0).xyz,\n         d = rotateXY(normalize(vec3(ndc * asp, 1.0)), o.xy);\n    \n    vec3 ro = l + vec3(0.1*sin(iTime),0.0,-1.0); // vec3(0.0);\n    vec3 rd = d; // normalize(vec3(ndc * asp, 1.0));\n    \n    // holographic plane\n    vec3 hpl = vec3(0.0, 0.0, 1.5);\n    vec3 hpu, hpv, hpn = vec3(0.0, 0.0, -1.0);\n    basis(hpn, hpu, hpv);\n    \n    // imaging plane\n    vec3 ipl = vec3(0.0, 1.5, 0.0);\n    vec3 ipu, ipv, ipn = vec3(0.0, 0.0, 1.0);\n    basis(ipn, ipu, ipv);\n    \n    // trace holographic plane, bounded [-1,1]\n    float ht = tracePlane(ro, rd, hpl, hpn);\n    vec3 hl = ro + rd * ht;\n    vec3 hd = hpl - hl;\n    vec2 hndc = vec2(dot(hd, hpu), dot(hd, hpv));\n    vec2 huv = hndc * 0.5 + 0.5;\n    \n    if (ht < 0.0 || any(greaterThan(hndc, vec2(1.0))) || any(lessThan(hndc, vec2(-1.0)))) {\n        \n        // try to render image plane\n        float it = tracePlane(ro, rd, ipl, ipn);\n        vec3 il = ro + rd * it;\n        vec3 id = ipl - il;\n        vec2 indc = vec2(dot(id, ipu), -dot(id, ipv));\n        vec2 iuv = indc * 0.5 + 0.5;\n        \n        if (it < 0.0 || any(greaterThan(indc, vec2(1.0))) || any(lessThan(indc, vec2(-1.0)))) {\n            fragColor = vec4(0.0);\n            return;\n        }\n        fragColor = texture(iChannel0, iuv);\n        return;\n    }\n    \n    // map from holographic plane to imaging plane\n    vec3 ipt = ipl + ipu * hndc.x + ipv * hndc.y;\n    vec3 id = ipl - ipt;\n    vec2 indc = vec2(dot(id, ipu), -dot(id, ipv));\n    vec2 iuv = indc * 0.5 + 0.5;\n    \n    // incoming and outgoing rays\n    vec3 e2h = normalize(eb - hl);\n    vec3 h2i = normalize(ipt - hl);\n    // holographic 'normal'\n    vec3 hn = slerp(e2h, h2i, 0.5);\n    \n    // trace reflected ray to verify\n    vec3 rfl = reflect(rd, hn);\n    float rt = tracePlane(hl, rfl, ipl, ipn);\n    vec3 rl = hl + rfl * rt;\n    vec3 dr = ipl - rl;\n    vec2 rndc = vec2(dot(dr, ipu), -dot(dr, ipv));\n    vec2 ruv = rndc * 0.5 + 0.5;\n\n    // ghetto hack, replace with refraction of wavelengths even though its reflection\n    vec2 chroma = (rndc - indc) * 0.1;\n    float blur = clamp(dot(chroma, chroma) * 15000.0, 0.0, 10.0);\n\n    // sample image texture\n    vec4 colr = vec4(textureLod(iChannel0, ruv - chroma, blur).r, 0.0, 0.0, 0.3333333);\n    vec4 colg = vec4(0.0, textureLod(iChannel0, ruv         , blur).g, 0.0, 0.3333333);\n    vec4 colb = vec4(0.0, 0.0, textureLod(iChannel0, ruv + chroma, blur).b, 0.3333333);\n    \n    // quackulate distortion\n    vec2 dist = min(smoothstep(0.4, 0.5, fract(ruv * 25.0)), 1.0 - smoothstep(0.5, 0.6, fract(ruv * 25.0)));\n    \n    fragColor = vec4(0.0);\n    // mix between distortion and image\n    fragColor += mix( // col,\n        mix(colr + colg + colb, vec4(vec3(0.05), 1.0), sqrt(blur)*0.316228),\n        vec4(dist.xyx, 1.0) + vec4(abs(hn), 0.0),\n        pow(0.5+0.5*sin(time), 2.0)\n    );\n    \n    // view the image\n    fragColor /= fragColor.a;\n    \n    // view the holographic element\n    //fragColor.rgb = abs(hn);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_ACCELERATION  16.\n#define MAX_VELOCITY      4.\n#define FRICTION          8.\n\n#define VALUE_VELOCITY    0\n#define VALUE_POSITION    1\n#define VALUE_ROTATION    2\n#define VALUE_MOUSE       3\n\nconst vec2 KEY_W \t = vec2(87.5 / 256., 0.),\n    \t   KEY_S \t = vec2(83.5 / 256., 0.),\n    \t   KEY_A \t = vec2(65.5 / 256., 0.),\n    \t   KEY_D \t = vec2(68.5 / 256., 0.),\n\t\t   KEY_LEFT  = vec2(37.5 / 256., 0.),\n\t\t   KEY_UP    = vec2(38.5 / 256., 0.),\n\t\t   KEY_RIGHT = vec2(39.5 / 256., 0.),\n\t\t   KEY_DOWN  = vec2(40.5 / 256., 0.),\n    \t   KEY_SHIFT = vec2(16.0 / 256., 0.),\n    \t   KEY_SPACE = vec2(32.0 / 256., 0.);\n\nconst vec4 INIT_POS = vec4(0.0, 0.0, 0.05, 0.0),\n    \t   INIT_VEL = vec4(0.0, 0.0, 0.0, 0.0),\n    \t   INIT_ROT = vec4(0.0, 0.0, 0.0, 0.0),\n    \t   INIT_MOU = vec4(0.0, 0.0, 0.0, 0.0);\n\nvec3 vRotateY(vec3 p, float angle) {\n    float c = cos(angle), s = sin(angle);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n\nvec3 getAcceleration() {\n    return vec3(\n        texture(iChannel1, KEY_D).x - texture(iChannel1, KEY_A).x + texture(iChannel1, KEY_RIGHT).x - texture(iChannel1, KEY_LEFT).x,\n        texture(iChannel1, KEY_SPACE).x - texture(iChannel1, KEY_SHIFT).x,\n        texture(iChannel1, KEY_W).x - texture(iChannel1, KEY_S).x + texture(iChannel1, KEY_UP).x - texture(iChannel1, KEY_DOWN).x\n    );\n}\n\nvec4 getValue(int a) {\n    vec2 q = vec2(float(a) + 0.5, 0.0) / iResolution.x;\n    return texture(iChannel0, q);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (fragCoord.y > 1.) discard;\n    \n    int a = int(fragCoord.x);\n    float q = fragCoord.x / iResolution.x;\n    vec4 value = texture(iChannel0, vec2(q, 0.));\n    \n    // set initial values\n    if (iFrame == 0) {\n        if (a == VALUE_ROTATION) {\n            value = INIT_ROT;\n        } else if (a == VALUE_MOUSE) {\n            value = INIT_MOU;\n        } else if (a == VALUE_VELOCITY) {\n            value = INIT_VEL;\n        } else if (a == VALUE_POSITION) {\n            value = INIT_POS;\n        }\n    }\n    \n    if (a == VALUE_ROTATION && iMouse.z > 0.) {\n        vec4 mouse = 2.0 * abs(iMouse) / iResolution.y;\n        vec4 rot = getValue(VALUE_MOUSE);\n        value.x = clamp(mouse.y - mouse.w + rot.x, -HPI, HPI);\n        value.y = mouse.x - mouse.z + rot.y;\n        \n    } else if (a == VALUE_MOUSE && iMouse.z < 0.) {\n        value = getValue(VALUE_ROTATION);\n        \n    } else if (a == VALUE_VELOCITY) {\n        float rot = getValue(VALUE_ROTATION).y;\n        vec3 acc = vRotateY(getAcceleration(), rot);\n        value.xyz += acc * MAX_ACCELERATION * iTimeDelta;\n        float speed = length(value.xyz);\n        // limit speed\n        if (speed > MAX_VELOCITY) {\n            value.xyz *= MAX_VELOCITY / speed;\n        } else if (speed > FRICTION * iTimeDelta) {\n            value.xyz *= (speed - FRICTION * iTimeDelta) / speed;\n        } else {\n            value.xyz = vec3(0.0, 0.0, 0.0);\n        }\n    \n    } else if (a == VALUE_POSITION) {\n        vec3 velocity = getValue(VALUE_VELOCITY).xyz;\n        value.xyz += velocity * iTimeDelta;\n        // collision detection?\n        if (value.y < -0.5) value.y = -0.5;\n\n    }\n    \n    fragColor = vec4(value);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float\teps = 0.001,     ieps = 0.999,   zfar = 50.0,       FOV = 1.5,\n            HPI = 1.5707963, PI = 3.1415926, TWOPI = 6.2831853, SQRT2 = 1.4142136, SC45 = 0.7071068;\nconst vec2\t  VEL = vec2(0.5, 0.5),   POS = vec2(1.5, 0.5),   ROT = vec2(2.5, 0.5),   MOU = vec2(3.5, 0.5);\nconst vec2\tL_VEL = vec2(4.5, 0.5), L_POS = vec2(5.5, 0.5), L_ROT = vec2(6.5, 0.5), L_MOU = vec2(7.5, 0.5);\n\nvec3 rotateXY(in vec3 p, in vec2 angle) {\n\tvec2 c = cos(angle), s = sin(angle);\n    vec3 o = p;\n\to.yz *= mat2(c.x, s.x, -s.x, c.x); \n    o.xz *= mat2(c.y, s.y, -s.y, c.y);\n\treturn o;\n}\n\nvoid basis(in vec3 n, out vec3 f, out vec3 r) {\n    float s = (n.z >= 0.0)? 1.0: -1.0;\n    float a = 1.0 / (s + n.z);\n    float b = -n.x*n.y*a;\n    f = vec3(1.0 - n.x*n.x*a*s, b*s, -n.x*s);\n    r = vec3(b, s - n.y*n.y*a, -n.y);\n}\n\nvec3 slerp(in vec3 start, in vec3 end, in float percent) {\n\tfloat dt = dot(start, end),\n        theta = acos(dt)*percent;\n\treturn start*cos(theta) + normalize(end - start*dt)*sin(theta);\n}\n\nfloat tracePlane(in vec3 ro, in vec3 rd, in vec3 pl, in vec3 pn) {\n    return dot(pn, pl - ro) / dot(pn, rd);\n}\n","name":"Common","description":"","type":"common"}]}