{"ver":"0.1","info":{"id":"Dl2cWV","date":"1692312471","viewed":22,"name":"00GraphicsClassLesson02_ex0","username":"foodini","description":"I'm teaching an intro to computer graphics. This is one of the class examples.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["graphicsintro"],"hasliked":0,"parentid":"DlByDh","parentname":"00GraphicsClassLesson02"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.141592653589793;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // fragCoord comes in as the x,y index into the pixel array of the screen. In other\n    // words, its scale depends upon the screen resolution. It's most convenient to think\n    // of pixels' locations in terms of their relative positions. This scales the screen\n    // to range from 0.0 to 1.0 in both dimensions.\n    vec2 uv = fragCoord/(iResolution.xy - vec2(1.0, 1.0));\n\n    // By leaving this out we're leaving the (0.0, 0.0) point at the lower left.\n    //uv *= 2.0;\n    //uv -= 1.0;\n    \n    // The pixels in the image now go from <0.0, 0.0> at the bottom left to\n    // <1.0, 1.0> at the top right. This means our pixels are squashed. Going up\n    // by one pixel incrases y by more than going right by one increases x. Rescale\n    // in the y direction to compensate. This means that the top right is no\n    // longer <1.0, 1.0>. It's more like <1.0, 0.65>, though it depends on your screen\n    // resolution.\n    float aspect_ratio = iResolution.y/iResolution.x;\n    uv.y *= aspect_ratio;\n \n    // set the default background color, black:\n    fragColor.rgb = vec3(0.0);\n    \n    // The constants I'm multiplying iTime by are arbitrary. They're just to make the\n    // balls move at different velocities.\n    vec2 xy_red = vec2(mod(iTime*0.13,  1.0), mod(iTime*0.19, aspect_ratio));\n    vec2 xy_grn = vec2(mod(iTime*0.43,  1.0), mod(iTime*0.07, aspect_ratio));\n    vec2 xy_blu = vec2(mod(iTime*0.371, 1.0), mod(iTime*0.22, aspect_ratio));\n    \n    // We could just draw a flat-shaded circle by setting the intensity to max if the\n    // pixel is within a certain radius of the circle's centerpoint:\n    if(length(xy_red - uv) < 0.2)\n        fragColor.r = 1.0;\n     \n    // Or we could make the brightness depend upon how close the pixel is to the center:\n    float l = length(xy_grn - uv);\n    fragColor.g = 1.0-l;\n    \n    // Maybe that green blob is taking up too much space. We can make it more focused:\n    l = length(xy_blu - uv);\n    fragColor.b = pow(1.1-l, 10.0);\n}","name":"Image","description":"","type":"image"}]}