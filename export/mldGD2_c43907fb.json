{"ver":"0.1","info":{"id":"mldGD2","date":"1683951845","viewed":57,"name":"quilt2LKG","username":"holophone3d","description":"Turns a quilt into a LKG ready image \nInstructions in the shader to load the texture in javascript console, otherwise shader will just be a black screen.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["lkg"],"hasliked":0,"parentid":"Dl3GDj","parentname":"3ds lightfield LKG WIP"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nINSTRUCTIONS:\nLOAD THE TEXTURE BELOW TO RUN THE SHADER:\n\nThe idea is to call directly the SetTexture function found in Shadertoy js code \n(https://www.shadertoy.com/view/lsGGDd)\n\nHere is how to loads the three textures needed for this shader:\n - Open the javascript console of your browser:\n\t\t\t\t   Mac      /     Windows\n\tChrome:  cmd + opt + J  /  ctrl + shift J\n\tFirefox: cmd + opt + K  /  ctrl + shift K\n    Edge:          na         /  ctrl + shift J   \n\n- Then copy the following lines in the console:\n\ngShaderToy.SetTexture(0, {mSrc:'https://i.imgur.com/NRtqvf7.jpeg', mType:'texture', mID:1, mSampler:{ filter: 'nearest', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n\n- hit return to execute and load the textures.\n\n-Important Note: Texture filtering must be set to nearest (or maybe linear), but mipmap completly does not work at all\n\nCode is ported from here:\nhttps://github.com/Looking-Glass/LookingGlassCoreSDK/blob/master/HoloPlayCore/include/HoloPlayShaders.h\n\nObligatory license details:\n\nBy using, copying, or modifying this code in any way, you agree to the terms of\nhttps://github.com/Looking-Glass/HoloPlayCoreSDK/blob/master/LICENSE.txt\n\nThe contents of this file are not open source and should not be merged into\ncodebases with licenses that conflict with the HoloPlay SDK License. In those\ncases, please include HoloPlayShadersOpen.h instead.\n\n*/\n// LKG calibration data  (put your LKG data here)\nconst float width = 1536.0f;\nconst float height = 2048.0f;\nconst float dpi = 324.0f;\nconst float slope = -7.198658892370121;\nconst float center = 0.5990424947346542;\nconst float pitch = 52.57350593130944;\nconst int invView = 1;\nconst float displayAspect = 0.75;\nconst int ri = 0;\nconst int bi = 2;\n\n// Quilt data (defaults)\nvec3 tile = vec3(5.0,9.0,1.0); //cols, rows, total views (will be computed)\nfloat quiltAspect = 1.0; // default - cols/rows (will be computed)\nvec2 viewPortion = vec2(1.0,1.0);\nint overscan = 0; \nint quiltInvert = 0;\n\n// Show raw quilt image \nint debug = 0;\n\nvec2 texArr(vec3 uvz)\n{\n    // decide which section to take from based on the z.\n    float x = (mod(uvz.z, tile.x) + uvz.x) / tile.x;\n    float y = (floor(uvz.z / tile.x) + uvz.y) / tile.y;\n    return vec2(x, y) * viewPortion.xy;\n}\n\n// recreate CG clip function (clear pixel if any component is negative)\nvoid clip(vec3 toclip)\n{\n    if (any(lessThan(toclip, vec3(0,0,0)))) discard;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 texCoords = fragCoord.xy/iResolution.xy;\n    // update computed LKG values from calibration data\n    float subp = 1.0f / (3.0f * width);\n    float tilt = height / (width * slope);\n    float adjusted_pitch = pitch * (width / dpi) * sin(atan(abs(slope)));\n    // update computed quilt values\n    tile.z = tile.x*tile.y;\n    quiltAspect = tile.y/tile.x;\n    \n    if(debug == 1)\n    {\n        fragColor = texture(iChannel0, texCoords.xy);\n    }\n    else\n    {\n        float invert = 1.0;\n        if (invView + quiltInvert == 1) invert = -1.0;\n        vec3 nuv = vec3(texCoords.xy, 0.0);\n        nuv -= 0.5;\n        float modx = clamp(step(quiltAspect, displayAspect) * step(float(overscan), 0.5) + step(displayAspect, quiltAspect) * step(0.5, float(overscan)), 0., 1.);\n        nuv.x = modx * nuv.x * displayAspect / quiltAspect + (1.0-modx) * nuv.x;\n        nuv.y = modx * nuv.y + (1.0-modx) * nuv.y * quiltAspect / displayAspect;\n        nuv += 0.5;\n        clip (nuv);\n        clip (1.0-nuv);\n        vec4 rgb[3];\n        for (int i=0; i < 3; i++)\n        {\n            nuv.z = (texCoords.x + float(i) * subp + texCoords.y * tilt) * adjusted_pitch - center;\n            nuv.z = mod(nuv.z + ceil(abs(nuv.z)), 1.0);\n            nuv.z *= invert;\n            nuv.z *= tile.z;\n            vec3 coords1 = nuv;\n            vec3 coords2 = nuv;\n            coords1.y = coords2.y = clamp(nuv.y, 0.005, 0.995);\n            coords1.z = floor(nuv.z);\n            coords2.z = ceil(nuv.z);\n            vec4 col1 = texture(iChannel0, texArr(coords1));\n            vec4 col2 = texture(iChannel0, texArr(coords2));\n            rgb[i] = mix(col1, col2, nuv.z - coords1.z);\n        }\n        fragColor = vec4(rgb[ri].r, rgb[1].g, rgb[bi].b, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}