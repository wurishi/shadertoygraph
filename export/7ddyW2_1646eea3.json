{"ver":"0.1","info":{"id":"7ddyW2","date":"1654238515","viewed":144,"name":"Maxwell 2D as ripples in 3D","username":"Amirk","description":"Maxwells equations as before. This time visualised as 3D ripples. Switch \"ABSORBING = true\" to turn on the absorbing boundary -condition. Move with mouse. Sorry if it's a bit slow.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["refraction","maxwell","electrodynamics"],"hasliked":0,"parentid":"NddyRs","parentname":"Maxwell Absorbing Boundary"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITER 350.\n#define MAX_DIST 2.\n#define SURF .001\n#define PI 3.1416\nvec3 col=vec3(0); \n\n\nmat2 Rot(float a){\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}\n\nvec3 getRayDir(vec2 uv, vec3 ro,vec3 lookAt, float zoom){\n\n    vec3 f= normalize(lookAt-ro);\n    vec3 r= normalize(cross(vec3(0,1,0),f));\n    vec3 u= cross(f,r);\n    vec3 i= ro+f*zoom+uv.x*r+uv.y*u;\n    \n    return normalize( i-ro);\n}\n\n\nfloat sdBox(vec3 p , vec3 s){\n\nreturn  length(max( abs(p)-s,.0));\n}\n\nfloat Plane(vec3 p){\n    vec3 s= vec3(2.*.7,0.0,1.);\n\n    s*=.5;\n    p= abs(p)-s;\n\n    return length(max(p,0.))-.0;\n}\n\nfloat getDist(vec3 p){\n   \n    float dist =Plane(p);\n    if(dist<MAX_DIST){\n        //bumpmap:\n        vec2 planeCoords=vec2((p.x+1.)/2.,p.z+.5);\n        float displacement= sign(p.y)*5.*atan(8.*texture(iChannel0, planeCoords).r);\n        dist-=displacement;\n    }\n    \n    //conservative stepsize:\n    dist*=.2;\n    \n    return dist-.001;\n}\n\n\nvec3 getNormal(vec3 p){\n  vec2 e= vec2(.01,0);\n   float d=getDist(p);\n   vec3 n = d-vec3(getDist(p- e.xyy),getDist(p- e.yxy),getDist(p- e.yyx));\n   \n   return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO=0.;\n    float i=0.;\n    while(i<MAX_ITER){\n         vec3 p= ro+dO*rd;\n\n         float dS=getDist(p);\n\n         dO+=dS;\n  \n      if(dO>MAX_DIST||dS<SURF) break;\n  \n      i++;\n      }\n      \n      float halo= pow(2.*i/MAX_ITER,2.);\n      col+=vec3(halo)*vec3(0.4,0.2,1);\n\n      return dO;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec2 m = (iMouse.xy-.5)/iResolution.xy;\n\n    \n    //camera: \n    float zoom= 1.;//smoothstep(-1.,3.,iTime);\n\n    vec3 ro= vec3(-.65,.15,.0);\n    ro.xz*=Rot(PI/2.);\n\n    if(sign(iMouse.z)>0.){\n        ro.yz*=Rot(-(m.y-.5)*PI);\n        ro.xz*=Rot(-(m.x-.5)*PI);\n    }\n    \n    \n    vec3 lookAt=vec3(0);\n    \n    vec3 rd= getRayDir(uv, ro, lookAt,zoom);\n\n    float d= RayMarch(ro,rd);\n    \n    \n     if(d<MAX_DIST){//if we hit the object:\n       \n          vec3 p= ro+ d*rd;\n          vec3 n=getNormal(p);\n       \n          vec2 planeCoords=vec2((p.x+1.)/2.,p.z+.5);\n          float ez= texture(iChannel0, planeCoords).r*200.;\n         \n          float d=length(vec2(p.x*2.,p.z));\n          er=1.+(erObs-1.)* smoothstep(radius+boundaryThickness,radius,d);\n          //ur=1.+(urObs-1.)* smoothstep(radius+boundaryThickness,radius,d);\n         \n          col+= 3.*color(2.7*ez)*(er);\n          \n          float dif= dot(n, normalize(vec3(1,1,7)))*.5+.5;\n          col*=dif*dif;\n         \n    }\n    \n    fragColor = vec4(col,1.);\n}\n    \n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//this Buffer updates magnetic field H with curls of E with buffer B\n\nivec2 per(int px, int py){\n  ivec2 r = ivec2(iResolution.xy);\n  ivec2 p=ivec2(px,py);\n  \n  return p = (p+r) % r; \n}\n\n    //We store Ez as col.r and Hx,Hy as col.g, col.b\n\nfloat Ez(int i, int j){\n    return texelFetch(iChannel0, per(i,j),0).r;\n}\nfloat Hx(int i, int j){\n    return texelFetch(iChannel0, per(i,j),0).g;\n}\nfloat Hy(int i, int j){\n    return texelFetch(iChannel0, per(i,j),0).b;\n}\n\n\nvoid ECurls(int i,int j){\n     ExCurl=  (Ez(i,j+1)-Ez(i,j))/dz;\n     EyCurl= -(Ez(i+1,j)-Ez(i,j))/dz;\n}\n\n//this integrated curl term is needed for perfectly absorbing boundary:\nvoid IntegrateExCurl(int i,int j){\n    if(iFrame<2000){ \n        IntegratedExCurl= ExCurl+100000000.*texelFetch(iChannel1,ivec2(i,j),0).a;\n        HX+= mHx3(float(i)/iResolution.x)*IntegratedExCurl;\n        }\n    else //to avoid numerical instability we cut it of after some time:\n         IntegratedExCurl=0.;\n     \n}\n\nvoid updateH(int i,int j){\n    float x =float(i)/iResolution.x;\n    HX=Hx(i,j) + mHx2(x)* ExCurl;\n    HY=mHy1(x)*Hy(i,j) + mHy2(x)* EyCurl;\n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec3 col = vec3(0);\n    \n    int i=int(fragCoord.x);\n    int j=int(fragCoord.y);\n    \n    \n    //define smooth obstacle:\n    float d=length((vec2(i,j)-iResolution.xy*0.5)*vec2(2.,1.));\n    er+= (erObs-er)*smoothstep(iResolution.y*radius+boundaryThickness,iResolution.y*radius,d);\n    //ur+= (urObs-ur)*smoothstep(iResolution.y*radius+boundaryThickness,iResolution.y*radius,d);\n\n  \n    ECurls(i,j);\n    //for the absorbing boundary:\n    if(ABSORBING)\n        IntegrateExCurl(i,j);\n\n    //\"Totalfield-Scatteredfield method:\n    //creating a plane wave by modifying the curl:\n    if(i==sourceLoc-1&&iFrame<500) EyCurl += Esource(dt*float(iFrame))/dz; \n    \n    //update H:\n    updateH(i,j);\n    \n    \n    //store fields in color channels:\n    col.rgb=vec3(Ez(i,j),HX,HY);\n    \n    //we store the integrated curl in alpha channel:\n    fragColor = vec4(col,.000000001*IntegratedExCurl);\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const bool ABSORBING = false;\n\n//speed of light c:\n const float  c = 1.; \n //grid cell size:\n const float dz= 0.1;\n //relative permittivity:\n float er = 1.0;\n //relative permeability:\n float ur = 1.0;\n //timestep is chosen so that one grid cell is traversed in excatly two time steps. \n //First time step is to update H, the second to update E.\n #define dt dz/(2.0*c)\n //some precalculations:\n  \n #define sourceLoc int(iResolution.x/2.7)\n \n //smoothing factor of the obstacle boundary:\n float boundaryThickness=.01;\n float erObs=3.;\n float urObs=1.; \n float radius=0.40;\n\n\n\nfloat EX,EY,EZ,DZ, HX, HY,ExCurl,EyCurl,HzCurl, IntegratedExCurl;\n\n\nfloat sx(float x){\n    if(ABSORBING){\n        //absorbing boundary width scale:\n        float bndWidth=0.30;\n        //return e0*(smoothstep(bndWidth,0.0,x*x)+smoothstep(bndWidth,0.,(1.-x)*(1.-x)))/(8.*dt);\n        float f=4./(bndWidth*bndWidth*bndWidth);\n        return max(0.,f*(bndWidth-x)*(bndWidth-x)*(bndWidth-x))\n        +max(0.,f*(bndWidth-(1.-x))*(bndWidth-(1.-x))*(bndWidth-(1.-x)));\n        }\n    else\n        return 0.;\n    }\n\n//float mHx0(int i){return 1./dt;} \n//float mHx1(int i){return 1.;} \nfloat mHx2(float i){return -c*dt/ur;} \nfloat mHx3(float i){return -c*dt*dt*sx(i);} \n\nfloat mHy0(float i){return 1./dt+sx(i)/(2.);} \nfloat mHy1(float i){return (2.-sx(i)*dt)/(2.+sx(i)*dt);} \nfloat mHy2(float i){return -c*2.*dt/(2.+sx(i)*dt)/ur;} \n\n//float mDz0(int i){return 1./dt+sx(i)/(2.*e0);} \nfloat mDz1(float i){return 1.;} \nfloat mDz2(float i){return c*2.*dt/(2.+sx(i)*dt);}\n\n//float mEz1() {return 1./er;}\n\n\n//a gaussian pulse, E term:\nfloat Esource(float time){ \n    if(time<200.*dt)\n        return .001*exp(-(time-dt*100.0)*(time-dt*100.0)*.5);\n    else\n        return .001*exp(-(time-dt*210.0)*(time-dt*210.0)*8.);\n\n\n}\n//a gaussian pulse, H term:\nfloat Hsource(float time){ \n       //there is this phase shift in H wave, since H field \"lives time dt/2 ahead\" of E field.\n       float phase =dz/(2.*c)+dt/2.;\n       float amp=-1.; //-sqrt(er/ur);\n       if(time<200.*dt) \n           return .001*amp*exp(-(time-dt*100.0+phase)*(time-dt*100.0+phase)*.5); \n       else\n           return .001*amp*exp(-(time-dt*210.0+phase)*(time-dt*210.0+phase)*8.);\n\n\n}\n\n\nvec3 color(float t)\n{\n vec3 col;\n col.r = 0.5-0.5*cos(2.*3.1416*(1.5*t+1.9));\n col.g = 0.5-0.5*cos(2.*3.1416*(.9*t+.15));\n col.b = 0.5-0.5*cos(2.*3.1416*(1.7*t+.2));\n return col;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//this Buffer updates electric field E with curls of H using buffer A\n\n\n//periodic boundary:\n ivec2 per(int px, int py){\n  ivec2 r = ivec2(iResolution.xy);\n  ivec2 p=ivec2(px,py);\n  \n  return p = (p+r) % r; \n}\n\n\n    //We store Ez as col.r and Hx,Hy as col.g, col.b\n\nfloat Ez(int i, int j){ \n    return texelFetch(iChannel0, per(i,j),0).r;\n}\n\nfloat Hx(int i, int j){\n    return texelFetch(iChannel0, per(i,j),0).g;\n}\n\nfloat Hy(int i, int j){\n    return texelFetch(iChannel0, per(i,j),0).b;\n}\n\n\n\nvoid HzCurls(int i,int j){\n     HzCurl=((Hy(i,j)-Hy(i-1,j))-(Hx(i,j)-Hx(i,j-1)))/dz;\n}\n\nvoid updateD(int i,int j){\n    float x= float(i)/iResolution.x;\n    DZ=mDz1(x)*Ez(i,j)*er + mDz2(x)* HzCurl;\n}\n\nvoid updateE(){\n    EZ= DZ / er;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 col = vec3(0);\n    \n    int i=int(fragCoord.x);\n    int j=int(fragCoord.y);\n        \n    //define smooth obstacle:\n    float d=length((vec2(i,j)-iResolution.xy*0.5)*vec2(2.,1.));\n    er=1.+ (erObs-1.)*smoothstep(iResolution.y*radius+boundaryThickness,iResolution.y*radius,d);\n    //ur=1.+ (urObs-1.)*smoothstep(iResolution.y*radius+boundaryThickness,iResolution.y*radius,d);\n    \n    HzCurls(i,j);    \n    //\"Totalfield-Scatteredfield method:\n    //input source plane wave by modifying the curl:\n    if(i==sourceLoc&& iFrame<500) HzCurl -= Hsource(dt*float(iFrame))/dz; \n    \n    //update E:\n    updateD(i,j);\n    updateE();    \n    \n   \n    \n    //store fields in color channels:\n    col.rgb=vec3(EZ,Hx(i,j),Hy(i,j));\n    fragColor = vec4(col,1.);\n}","name":"Buffer B","description":"","type":"buffer"}]}