{"ver":"0.1","info":{"id":"fljGRh","date":"1623345606","viewed":70,"name":"Genuine Cellular 2D","username":"GenuineIntelligence","description":"A genuine implementation for cellular noise.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["noise","cellular","genuine"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Copyright Â© 2021 Cavalier Arthur, Jonchier Theo, Tricard Thibault\n    This work is free. You can redistribute it and/or modify it under the\n    terms of the Do What The Fuck You Want To Public License, Version 2,\n    as published by Sam Hocevar. See the COPYING file or http://www.wtfpl.net/ \n    for more details.\n*/\n\n/** INPUT PARAMETERS */\n#define SCALE 0.01\n\n\n\n/** @brief Generates a random value [0, 1] */\nfloat random_1_1(float p)\n{\n    return fract(cos(p*89.42)*343.42);\n}\n\n/** @brief Generates a random point for which coordinates are comprised between 0 and 1 */\nvec2 random_2_2(vec2 p)\n{\n    return vec2(random_1_1(p.x*23.62-300.0+p.y*34.35),random_1_1(p.x*45.13+256.0+p.y*38.89));\n}\n\n/** @brief Return the distance to the closest cell. */\nfloat cellularNoise(vec2 pos)\n{   \n\n    // Find the square coordinates in which our sample position lies\n    vec2 sampleSquare = floor(pos);\n\n    // Initialize the distance to the closest cell as a huge number.\n    float minDistance = 10000000.0;\n\n    // For each neighbor square in grid coordinante:\n    //     - Generate a random position within the square.\n    //     - Compute the distance between our sample position\n    //       and the genarated random point (+ square coordinate)\n    //     - Keep the minimal distance between the computed one and\n    //       the current one.\n    for(int i = -1 ; i <= 1 ; i++){\n        for(int j = -1 ; j <=1 ; j++){       \n            // Compute the neighbor square position\n            vec2 neighborSquare = sampleSquare + vec2(i, j);\n            \n            // Generate a position for the neighbor square\n            vec2 cellCenter = random_2_2(neighborSquare);\n            \n            // Compute the distance between our sample point \n            float dist = length(cellCenter + neighborSquare - pos);\n            \n            // Keep the smallest distance.\n            minDistance = min(minDistance, dist);\n        }\n    }\n    \n    return minDistance;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord * SCALE;\n    float d = cellularNoise(pos);\n    fragColor = vec4(d ,d ,d ,1.0);\n}","name":"Image","description":"","type":"image"}]}