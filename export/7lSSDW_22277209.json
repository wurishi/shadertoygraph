{"ver":"0.1","info":{"id":"7lSSDW","date":"1627923591","viewed":283,"name":"Please Stand By...","username":"golffin","description":"Stapled together a bunch of functions from various shaders in order to learn about them and GLSL in general. The code is not cleaned in any way. ","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["text","crt"],"hasliked":0,"parentid":"4sBfRd","parentname":"Shader Text for beginners"},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Playing around and getting familiar with shaders.\n// \n// Stapled together the following shaders to get this one:\n//\n// Shader Text for beginners - https://www.shadertoy.com/view/4sBfRd\n// SMPTE color bars - https://www.shadertoy.com/view/XlGXRz\n// CRT Turn off - https://www.shadertoy.com/view/XlSczy\n// Meta CRT - Single Pass - https://www.shadertoy.com/view/NljGR1\n// MattiasCRT - https://www.shadertoy.com/view/Ms23DR\n// glitch2 - https://www.shadertoy.com/view/4dXBW2\n\n#define C(c) U.x-=.5; O+= char(U,64+c)\n#define glitchlen 32.\n#define timescale 1.\n#define PI 3.141592654\n\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\nconst int NUM_SAMPLES = 10;\nconst float RCP_NUM_SAMPLES_F = 1.0 / float(NUM_SAMPLES);\n\n\n// Needed for turn off effect\nconst vec4 FADE_COLOR = vec4(0.02f, 0.02f, 0.02f, 1.0f);\nconst float TURN_OFF_TIME = 1.0f;\nconst float SCALE_SPEED = 1.5f;\n\n\n// Hash Functions\n\n// From: Hash without Sine by Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\n\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n// Math Functions\n\nfloat sat( float t ) {\n\treturn clamp( t, 0.0, 1.0 );\n}\n\nvec2 sat( vec2 t ) {\n\treturn clamp( t, 0.0, 1.0 );\n}\n\n//remaps inteval [a;b] to [0;1]\nfloat remap  ( float t, float a, float b ) {\n\treturn sat( (t - a) / (b - a) );\n}\n\n//note: /\\ t=[0;0.5;1], y=[0;1;0]\nfloat linterp( float t ) {\n\treturn sat( 1.0 - abs( 2.0*t - 1.0 ) );\n}\n\nvec3 spectrum_offset( float t ) {\n    float t0 = 3.0 * t - 1.5;\n\treturn clamp( vec3( -t0, 1.0-abs(t0), t0), 0.0, 1.0);\n    /*\n\tvec3 ret;\n\tfloat lo = step(t,0.5);\n\tfloat hi = 1.0-lo;\n\tfloat w = linterp( remap( t, 1.0/6.0, 5.0/6.0 ) );\n\tfloat neg_w = 1.0-w;\n\tret = vec3(lo,1.0,hi) * vec3(neg_w, w, neg_w);\n\treturn pow( ret, vec3(1.0/2.2) );\n*/\n}\n\n//note: [0;1]\nfloat rand( vec2 n ) {\n  return fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n//note: [-1;1]\nfloat srand( vec2 n ) {\n\treturn rand(n) * 2.0 - 1.0;\n}\n\nfloat mytrunc( float x, float num_levels )\n{\n\treturn floor(x*num_levels) / num_levels;\n}\n\nvec2 mytrunc( vec2 x, float num_levels )\n{\n\treturn floor(x*num_levels) / num_levels;\n}\n\nvec3 PulseIntegral( vec3 x, float s1, float s2 )\n{\n    // Integral of function where result is 1.0 between s1 and s2 and 0 otherwise        \n\n    // V1\n    //if ( x > s2 ) return s2 - s1;\n\t//else if ( x > s1 ) return x - s1;\n\t//return 0.0f; \n    \n    // V2\n    //return clamp( (x - s1), 0.0f, s2 - s1);\n    //return t;\n    \n    return clamp( (x - s1), vec3(0.0f), vec3(s2 - s1));\n}\n\nfloat PulseIntegral( float x, float s1, float s2 )\n{\n    // Integral of function where result is 1.0 between s1 and s2 and 0 otherwise        \n\n    // V1\n    //if ( x > s2 ) return s2 - s1;\n\t//else if ( x > s1 ) return x - s1;\n\t//return 0.0f; \n    \n    // V2\n    //return clamp( (x - s1), 0.0f, s2 - s1);\n    //return t;\n    \n    return clamp( (x - s1), (0.0f), (s2 - s1));\n}\n\n\n\n// Step 1 - Make the CRT warped effect\n\nvec2 screenDistort(in vec2 uv){\n\tuv = (uv - 0.5) * 2.0;\n\tuv *= 1.1;\t\n\tuv.x *= 1.0 + pow((abs(uv.y) / 5.0), 2.0);\n\tuv.y *= 1.0 + pow((abs(uv.x) / 4.0), 2.0);\n\tuv  = (uv / 2.0) + 0.5;\n\tuv =  uv *0.92 + 0.04;\n\treturn uv;\n}\n\n// Step 2 - Make the colored bars + \"Please stand by\" text\n\n// Black box behind text\nfloat sdBox( in vec2 pos, in vec2 cen, in vec2 size )\n{\n    vec2 d = abs(pos - cen) - size;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\n// SMPTE Colorbars\nvoid colorbars( out vec4 fragColor, in vec2 fragCoord )\n{\n    float br = 0.75; // a less popular SMPTE version uses 1.0\n\n\tvec2 st = fragCoord.xy/iResolution.xy;\n\n\tbool sev1 = bool( step(st.x, 1.0/7.0) );\n\tbool sev2 = bool( step(st.x, 2.0/7.0) );\n\tbool sev3 = bool( step(st.x, 3.0/7.0) );\n\tbool sev4 = bool( step(st.x, 4.0/7.0) );\n\tbool sev5 = bool( step(st.x, 5.0/7.0) );\n\tbool sev6 = bool( step(st.x, 6.0/7.0) );\n\n\tbool row1 = !bool( step(st.y, 0.3333) );\n\tbool row2 = !bool( step(st.y, 0.25) );\n\n\t/////////////////////////////////////////\n\t// R : 0.75  1.0            1.0  1.0      \n\t// G : 0.75  1.0  1.0  1.0                \n\t// B : 0.75       1.0       1.0       1.0\n\t/////////////////////////////////////////\n\tfloat top_red =   br * float((sev6 && !sev4) || sev2 );\n\tfloat top_green = br * float(sev4);\n\tfloat top_blue =  br * float(!sev6 || (sev5 && !sev4) || (sev3 && !sev2) || sev1 );\n\n\t/////////////////////////////////////////\n\t// R :           1.0                 0.75      \n\t// G :                     1.0       0.75                \n\t// B : 1.0       1.0       1.0       0.75\n\t/////////////////////////////////////////\n\tfloat mid_red =   0.075*float( (sev6 && !sev5)||(sev4 && !sev3)||(sev2 && !sev1) ) + br * float(!sev6 || (sev3 && !sev2) );\n\tfloat mid_green = 0.075*float( (sev6 && !sev5)||(sev4 && !sev3)||(sev2 && !sev1) ) + br * float(!sev6 || (sev5 && !sev4) );\n\tfloat mid_blue =  0.075*float( (sev6 && !sev5)||(sev4 && !sev3)||(sev2 && !sev1) ) + br * float(!sev6 || (sev5 && !sev4) || (sev3 && !sev2) || sev1);\n\n\t///////////////////////\n\t// R: 0.00  1.0  0.22\n\t// G: 0.24  1.0  0.00\n\t// B: 0.35  1.0  0.5\n\t/////////////////////// \n\tbool fourth1 = bool( step(st.x, 1.0*(5.0/7.0)/4.0 ));\n\tbool fourth2 = bool( step(st.x, 2.0*(5.0/7.0)/4.0 ));\n\tbool fourth3 = bool( step(st.x, 3.0*(5.0/7.0)/4.0 ));\n\tbool fourth4 = bool( step(st.x, (5.0/7.0) ));\n\n\tbool littleThird1 = bool( step(st.x, 5.0/7.0 + 1.0/7.0/3.0) );\n\tbool littleThird2 = bool( step(st.x, 5.0/7.0 + 1.0/7.0/3.0*2.0) );\n\tbool littleThird3 = bool( step(st.x, 5.0/7.0 + 1.0/7.0/3.0*3.0) );\n\n\tfloat bottom_red =                         float(fourth2 && !fourth1) + 0.22*float(fourth3 && !fourth2) + 0.075*float(fourth4 && !fourth3) + 0.075*float(littleThird2 && !littleThird1) + 0.15*float(littleThird3 && !littleThird2) + 0.075*float(!sev6);\n\tfloat bottom_green = 0.24*float(fourth1) + float(fourth2 && !fourth1)                                   + 0.075*float(fourth4 && !fourth3) + 0.075*float(littleThird2 && !littleThird1) + 0.15*float(littleThird3 && !littleThird2) + 0.075*float(!sev6);\n\tfloat bottom_blue =  0.35*float(fourth1) + float(fourth2 && !fourth1) + 0.5*float(fourth3 && !fourth2)  + 0.075*float(fourth4 && !fourth3) + 0.075*float(littleThird2 && !littleThird1) + 0.15*float(littleThird3 && !littleThird2) + 0.075*float(!sev6);\n\n\tfragColor = vec4(top_red*float(row1)   + mid_red*float(row2 && !row1) + bottom_red*float(!row2), \n\t                 top_green*float(row1) + mid_green*float(row2 && !row1) + bottom_green*float(!row2), \n\t                 top_blue*float(row1)  + mid_blue*float(row2 && !row1) + bottom_blue*float(!row2),1.);\n}\n\n// Text helper\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\tvec4 col = textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n    return col.xxxx;\n}\n\n// Put together the color bars and text\nvec4 pleaseStandBy( in vec2 uv, in float time)\n{\n    vec4 O = vec4(0.0);\n    //vec2 uv = fragCoord/iResolution.y;\n    vec2 fragCoord = uv * iResolution.y;\n    colorbars(O, fragCoord);\n    \n    O *= step(0., sdBox(uv, vec2(0.87,.5), vec2(0.6,0.15)) );\n    \n    vec2 position = vec2(.3,.45);\n    float FontSize = 8.;\n    vec2 U = ( uv - position)*64.0/FontSize;\n    \n    float tS = sin(time);\n    float tC = cos(time);\n    \n    C(16 + int( step(20.,time)*floor(10.*tS) ) );\n    C(12 + int( step(22.,time)*floor(4.*tC - 35.) ) );\n    C(5 + int( step(24.,time)*floor(3.*tC + tS + 23.) ) );\n    C(1 + int( step(25.,time)*floor(4.*tC + 2.*tS) ) );\n    C(19 + int( step(26.,time)*floor(6.*tC + 3.*tS) ) );\n    C(5 + int( step(27.,time)*floor(7.*tC + 4.*tS - 25.) ) );\n    C(-32 + int( step(27.5,time)*floor(8.*tC + 3.*tS) ) );\n    C(19 + int( step(27.7,time)*floor(2.*tC + 7.*tS + 40.) ) );\n    C(20 + int( step(27.8,time)*floor(3.*tC + 10.*tS) ) );\n    C(1 + int( step(28.,time)*floor(4.*tC + 2.*tS + 22.) ) );\n    C(14 + int( step(28.05,time)*floor(5.*tC + 1.*tS - 17.) ) );\n    C(4 + int( step(28.1,time)*floor(7.*tC + 4.*tS) ) );\n    C(-32 + int( step(28.15,time)*floor(1.*tC + 5.*tS + 10.) ) );\n    C(2 + int( step(28.2,time)*floor(5.*tC + 2.*tS) ) );\n    C(25 + int( step(28.2,time)*floor(2.*tC + 4.*tS) ) );\n    //O = O.xxxx;\n    return O;\n}\n\n\n// Step 3 - Start glitching the image\nvec4 glitchDistort(in vec2 uv, in float time){\n    vec4 fragColor = vec4(0.);\n    float aspect = iResolution.x / iResolution.y;\n    \n\tfloat GLITCH = clamp((time - 5.)/10.,0.,2.);// + iMouse.x / iResolution.x;\n    \n    float rdist = length( (uv - vec2(0.5,0.5))*vec2(aspect, 1.0) )/1.4;\n    GLITCH *= rdist;\n    \n\tfloat gnm = sat( GLITCH );\n\tfloat rnd0 = rand( mytrunc( vec2(time, time), 6.0 ) );\n\tfloat r0 = sat((1.0-gnm)*0.7 + rnd0);\n\tfloat rnd1 = rand( vec2(mytrunc( uv.x, 10.0*r0 ), time) ); //horz\n\tfloat r1 = 1.0f - sat( (1.0f-gnm)*0.5f + rnd1 );\n\t//float r1 = 0.5 - 0.5 * gnm + rnd1;\n\tr1 = 1.0 - max( 0.0, ((r1<1.0) ? r1 : 0.9999999) ); //note: weird ass bug on old drivers\n\tfloat rnd2 = rand( vec2(mytrunc( uv.y, 40.0*r1 ), time) ); //vert\n\tfloat r2 = sat( rnd2 );\n\n\tfloat rnd3 = rand( vec2(mytrunc( uv.y, 10.0*r0 ), time) );\n\tfloat r3 = (1.0-sat(rnd3+0.8)) - 0.1;\n\n\tfloat pxrnd = rand( uv + time );\n\n\tfloat ofs = 0.05 * r2 * GLITCH * ( rnd0 > 0.5 ? 1.0 : -1.0 );\n\tofs += 0.5 * pxrnd * ofs;\n\n\tuv.y += 0.1 * r3 * GLITCH;\n    \n\tvec4 sum = vec4(0.0);\n\tvec3 wsum = vec3(0.0);\n\tfor( int i=0; i<NUM_SAMPLES; ++i )\n\t{\n\t\tfloat t = float(i) * RCP_NUM_SAMPLES_F;\n\t\tuv.x = uv.x + ofs * t;\n\t\tvec4 samplecol = pleaseStandBy( uv, time );\n\t\tvec3 s = spectrum_offset( t );\n\t\tsamplecol.rgb = samplecol.rgb * s;\n\t\tsum += samplecol;\n\t\twsum += s;\n\t}\n\tsum.rgb /= wsum;\n\tsum.a *= RCP_NUM_SAMPLES_F;\n    \n\tfragColor.a = sum.a;\n\tfragColor.rgb = sum.rgb;\n    \n    return fragColor;\n    \n\n}\n\n\n// Step 4 - Turn off TV effect\nvec4 turnOffBuild(in vec2 uv, in float effectTime){\n    float onePixelScale = (iResolution.y - 1.0f) / iResolution.y;\n    \n    float time = mod(effectTime, (1.0f / SCALE_SPEED) + 1.0f + TURN_OFF_TIME);\n    time = clamp(time - TURN_OFF_TIME, 0.0, (1.0f / SCALE_SPEED) + 1.0f);\n    \n    float scaleTime = clamp(time * SCALE_SPEED, 0.0f, onePixelScale);\n    float fadeTime = clamp(time - onePixelScale / SCALE_SPEED, 0.0f, 1.0f);\n    \n    vec2 scaledUV = vec2(\n        (uv.x - 0.5f) * (1.0f - scaleTime) + 0.5f,\n        (uv.y - 0.5f) / (1.0f - scaleTime) + 0.5f\n    );\n    \n    vec4 rv = vec4(scaledUV, scaleTime, fadeTime);\n    \n    return rv;\n}\n\nvec4 turnOffTV(in vec4 incolor, in vec2 uv, in float scaleTime, in float fadeTime){\n    \n    vec4 outcolor = incolor + vec4(scaleTime, scaleTime, scaleTime, 0);\n    float fadeOutLevel = 1.0f - fadeTime;\n    float cropPixel = min(\n        clamp(\n            sign(\n                abs(scaleTime / 2.0f - 0.5) \n                - abs(uv.y - 0.5f)\n            )\n            , 0.0f, 1.0f\n        ), \n        clamp(\n            sign(\n                1.0f - fadeTime\n                - abs(uv.x - 0.5f)\n            ),\n            0.0f, \n            1.0f\n        )\n    );\n    \n    outcolor = mix(\n        FADE_COLOR, \n        mix(FADE_COLOR, outcolor, fadeOutLevel), \n        cropPixel\n    );\n    \n    return outcolor;\n}\n\n\n// Step 5 - Show the smiley faces at the end\nvec2 index2(in float indd){\n    vec2 rci = vec2(0.);\n    rci.x = mod(indd, 14.);\n    rci.y = floor(indd / 14.);\n    return rci;\n}\n\nvec4 PostBreak(in vec2 fragCoord, in float timei )\n{\n    if (timei < 0.){\n        return vec4(0.);\n    }\n    vec4 O = vec4(0.0);\n    vec2 uv = fragCoord/iResolution.y;\n    //uv.y -= 1.0;\n    vec2 position = vec2(0.,0.);\n    float FontSize = 8.;\n    \n    \n    vec2 U = ( uv - position)*64.0/FontSize;\n    \n    vec2 UR = mod(U, vec2(1.));\n    \n    float curInd = floor(clamp(timei*20., 0., 140.));\n    vec2 ii = index2(curInd);\n    \n    if ( ( (U.x <= (ii.x + 1.)) && (U.y <= (ii.y + 1.)) ) || ((U.y < ii.y) && (U.x < 14.)) ){\n        O += char(UR, 285)*vec4(1., fract(uv),1.);\n    }\n    return O;\n}\n\n\n// Post Processing Effects to give it that CRT look\n\nvec3 Bayer( vec2 vUV, vec2 vBlur )\n{\n    vec3 x = vec3(vUV.x);\n    vec3 y = vec3(vUV.y);           \n\n    x += vec3(0.66, 0.33, 0.0);\n    y += 0.5 * step( fract( x * 0.5 ), vec3(0.5) );\n        \n    //x -= 0.5f;\n    //y -= 0.5f;\n    \n    x = fract( x );\n    y = fract( y );\n    \n    // cell centered at 0.5\n    \n    vec2 vSize = vec2(0.16f, 0.75f);\n    \n    vec2 vMin = 0.5 - vSize * 0.5;\n    vec2 vMax = 0.5 + vSize * 0.5;\n    \n    vec3 vResult= vec3(0.0);\n    \n    vec3 vResultX = (PulseIntegral( x + vBlur.x, vMin.x, vMax.x) - PulseIntegral( x - vBlur.x, vMin.x, vMax.x)) / min( vBlur.x, 1.0);\n    vec3 vResultY = (PulseIntegral(y + vBlur.y, vMin.y, vMax.y) - PulseIntegral(y - vBlur.y, vMin.y, vMax.y))  / min( vBlur.y, 1.0);\n    \n    vResult = min(vResultX,vResultY)  * 5.0;\n        \n    //vResult = vec3(1.0);\n    \n    return vResult;\n}\n\nvec3 GetPixelMatrix( vec2 vUV )\n{\n    vec2 dx = dFdx( vUV );\n    vec2 dy = dFdy( vUV );\n    float dU = length( vec2( dx.x, dy.x ) );\n    float dV = length( vec2( dx.y, dy.y ) );\n    if (dU <= 0.0 || dV <= 0.0 ) return vec3(1.0);\n    return Bayer( vUV, vec2(dU, dV) * 5.0);\n}\n\nfloat Scanline( float y, float fBlur )\n{   \n    float fResult = sin( y * 10.0 ) * 0.45 + 0.55;\n    return mix( fResult, 1.0f, min( 1.0, fBlur ) );\n}\n\n\nfloat GetScanline( vec2 vUV )\n{\n    vUV.y *= 0.25;\n    vec2 dx = dFdx( vUV );\n    vec2 dy = dFdy( vUV );\n    float dV = length( vec2( dx.y, dy.y ) );\n    if (dV <= 0.0 ) return 1.0;\n    return Scanline( vUV.y, dV * 1.3 );\n}\n\nvec2 kScreenRsolution = vec2(480.0f, 576.0f);\n\nfloat InterferenceHash(float p)\n{\n    float hashScale = 0.1031;\n\n    vec3 p3  = fract(vec3(p, p, p) * hashScale);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat InterferenceSmoothNoise1D( float x )\n{\n    float f0 = floor(x);\n    float fr = fract(x);\n\n    float h0 = InterferenceHash( f0 );\n    float h1 = InterferenceHash( f0 + 1.0 );\n\n    return h1 * fr + h0 * (1.0 - fr);\n}\n\n\nfloat InterferenceNoise( vec2 uv )\n{\n\tfloat displayVerticalLines = 483.0;\n    float scanLine = floor(uv.y * displayVerticalLines); \n    float scanPos = scanLine + uv.x;\n\tfloat timeSeed = fract( iTime * 123.78 );\n    \n    return InterferenceSmoothNoise1D( scanPos * 234.5 + timeSeed * 12345.6 );\n}\n    \nvec4 turnIntoScreen( in vec3 vUVW, in vec4 inputColor )\n{   \n    vec3 vAmbientEmissive = vec3(0.1);\n    vec3 vBlackEmissive = vec3(0.02);\n    float fBrightness = 1.75;\n    vec2 vResolution = vec2(480.0f, 576.0f);\n    vec2 vPixelCoord = vUVW.xy * vResolution;\n    \n    vec3 vPixelMatrix = GetPixelMatrix( vPixelCoord );\n    float fScanline = GetScanline( vPixelCoord );\n      \n    vec2 vTextureUV = vUVW.xy;\n    //vec2 vTextureUV = vPixelCoord;\n    vTextureUV = floor(vTextureUV * vResolution * 2.0) / (vResolution * 2.0f);\n \n    float iNoise = InterferenceNoise( vTextureUV );\n    float iHash = InterferenceHash(vTextureUV.y * 100.0 + fract(iTime * 1234.0) * 12345.0);\n\n    float noiseIntensity = 0.1;\n    \n    //vTextureUV.x += (iHash * 2.0f - 1.0f) * 0.025f * noiseIntensity;\n           \n    vec2 vSampleUV = vTextureUV;\n    //vSampleUV.y = 1.0 - vSampleUV.y;\n    \n    vec3 vPixelEmissive = inputColor.rgb;\n        \n    vPixelEmissive = vPixelEmissive * vPixelEmissive;\n        \n    vPixelEmissive = clamp( vPixelEmissive + (iNoise - 0.5) * 2.0 * noiseIntensity, 0.0, 1.0 );\n    \n\tvec3 vResult = (vPixelEmissive * fBrightness + vBlackEmissive) * vPixelMatrix * fScanline + vAmbientEmissive;\n    \n    if( any( greaterThanEqual( vUVW.xy, vec2(1.0) ) ) || any ( lessThan( vUVW.xy, vec2(0.0) ) ) || ( vUVW.z > 0.0 ) )\n    {\n        return vec4(0.);\n    }\n    \n    return vec4(vResult, 1.);\n    \n}\n\nfloat SmoothMin( float a, float b, float k )\n{\n\t//return min(a,b);\n    \n    //float k = 0.06;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n\nvec3 Tonemap( vec3 x )\n{\n#if 0\n    \n    vec3 luminanceCoeffsBT709 = vec3( 0.2126f, 0.7152f, 0.0722f );\n    float f = dot( x, luminanceCoeffsBT709 );\n    x /= f;        \n    f = 1.0f - exp(-f);    \n    x *= f;    \n    x = mix( x, vec3(f), f*f );\n    \n    return x;\n#else       \n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n\n    return ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e );    \n#endif    \n}\n\n\nfloat GetVignetting( const in vec2 vUV, float fScale, float fPower, float fStrength )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0) * fScale;\n\t\n\tfloat fDist = max( 0.0, 1.0 - length( vOffset ) );\n    \n\tfloat fShade = 1.0 - pow( fDist, fPower );\n    \n    fShade = 1.0 - fShade * fStrength;\n\n\treturn fShade;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Need bunch of UVs for the different effects\n    vec2 tUV = fragCoord.xy / iResolution.xy;\n    tUV = screenDistort(tUV);\n    fragCoord = tUV * iResolution.xy;\n    \n    \n\tvec2 uv = fragCoord / iResolution.y;\n    vec2 vUV = fragCoord.xy / iResolution.xy;\n    vec3 sUVW = vec3(vUV,-1.);\n    \n    // All the different times needed\n    float tvOffED = (1.0f / SCALE_SPEED) + 1.0f + TURN_OFF_TIME;\n    float tvOffTime = glitchlen + tvOffED;\n    \n    // Animation time\n    float time = mod(iTime*timescale, tvOffTime + 17.);\n    \n    float tvOffET = clamp(time - glitchlen, 0., tvOffED);\n    float postBreakT = time - tvOffTime - 2.0f;\n    \n    // Make the screen\n    vec4 tvoff = vec4(uv, 0., 0.);\n\tif (time > tvOffTime){\n        fragColor = PostBreak(fragCoord, postBreakT);\n    }else{\n        if (tvOffET > 0.){\n            tvoff = turnOffBuild(uv, tvOffET);\n        }\n        fragColor = glitchDistort(tvoff.xy, time);\n        if (tvOffET > 0.){\n            fragColor = turnOffTV(fragColor, vUV, tvoff.z,  tvoff.w);\n        }\n    }\n    \n    // Post-Processing\n    fragColor = turnIntoScreen(sUVW, fragColor);\n    \n    float fExposure = 2.0f;\n    \n    fragColor.rgb *= fExposure;\n    \n    float fShade = GetVignetting( vUV, 0.6, 0.75, 1.0 );\n    \n    fragColor.rgb *= fShade;\n    \n    fragColor.rgb = Tonemap( fragColor.rgb );  \n    \n    \n}","name":"Image","description":"","type":"image"}]}