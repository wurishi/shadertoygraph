{"ver":"0.1","info":{"id":"wdGXR1","date":"1574904084","viewed":168,"name":"Raymarch Garbage","username":"okelly4408","description":"just some raymarching heavily taken from other peoples' work. ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 20.\n#define MIN_DIST .001\n#define MAX_ITER 100\n\nconst vec3 BOX = vec3(0.5);\nconst float eps = 0.0001;\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0. ).yx;\t\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm (in vec3 p)\n{\n    float f = 0.0;\n    float freq = 1.0;\n    for (int i = 0; i < 4; i++)\n    {\n        float n = noise(p * freq) / freq;\n        f += n;\n        freq *= 2.0;\n    }\n    return f;\n}\n  \nfloat sdSphere(vec3 p, vec3 c, float r) {\n    \n    return length(p - c) - (r + fbm((p * noise(p + iTime)) * 2.0));\n}\n\nfloat map(in vec3 p){\n    return sdSphere(p, vec3(0.0), 4.0);\n}\nvec3 sNormal(in vec3 p){\n    float e = 0.001;\n    float d = map(p);\n    float xd = map(p+vec3(e,0,0));\n    float yd = map(p+vec3(0,e,0));\n    float zd = map(p+vec3(0,0,e));\n    vec3 n = (vec3(xd,yd,zd)-d)/e;\n    return n;\n}\nfloat castRay(vec3 ro, vec3 rd){\n    float t = 0.0; // marching distance on ray\n    for(int i=0; i<MAX_ITER; i++){\n        vec3 p = ro + t*rd; // marching point\n        float h = map(p);\t// hit distance\n        if(h<MIN_DIST) break;\n        t+=h;\n        if(t>MAX_DIST) break;\n    }\n    if(t>MAX_DIST) t = -1.0;\n    return t;\n}\nvec3 camera(in vec2 uv, in vec3 ro, vec3 ta, float fd){\n    vec3 up = vec3(0,1,0); // global up vector\n    vec3 ww = normalize(ta-ro); // direction to the target\n    vec3 uu = normalize(cross(ww, up)); // camera right direction\n    vec3 vv = normalize(cross(uu, ww)); // camera up direction\n    \n    vec3 rd = normalize(uv.x*uu + uv.y*vv + fd*ww); // camera direction to uv\n    return rd;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5);\n    uv.x *= iResolution.x/iResolution.y;\n\n    float a = 10.0 * iMouse.x/iResolution.x;\n    float taDist = 2.0; // target distance\n    vec3 ro = vec3( 8.0 * sin(a ), 7.0, 8.0* cos(a)); // camera origin\n    vec3 ta = vec3(0,0,0); // target\n    \n    vec3 rd = camera(uv, ro, ta, 1.0);\n    float t = castRay(ro, rd);\n    vec3 col = vec3(0.0);\n    if (t > 0.0) {\n        vec3 pos = ro + t*rd;\n        vec3 normal = sNormal(pos);\n        col = normal + (0.2 * dot(normal, normalize(vec3(0.0, -1., -1.))));\n    }\n    // Time varying pixel color\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}