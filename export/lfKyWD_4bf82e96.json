{"ver":"0.1","info":{"id":"lfKyWD","date":"1731919203","viewed":289,"name":"Marble Race in Truchet City","username":"vrc_yue","description":"This is my first work with glsl\nSubmitted to SESSIONS 2024\n\nIt was created using the following works as reference.\n2d truchet traveler by abje\nGlow City by mhnewman\nMountainBytes: PPPP 4KiB Windows by mrange & virgill\nfont_logging  by kinankomoti ","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","truchet","city","race"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi acos(-1.)\nconst float tau=6.283185;\n#define rot(spin)mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n\n// 以下の値を変えるとコースやレースが変わります\n// Changing the following values will change the course and race.\nconst float COURCEID = 217.;\n\nconst bool ONGRID = false;\nconst bool ONRACEORDER = false;\nconst bool ONDRAWCENTER=false;\n\nconst float onBoardCameraProb=.3;\nconst bool onBoardCamera=false;\nconst bool backCamera=false;\n\nconst int RACERNUM = 8;\n\n//LAPDATA\nconst float ALLLAP = 50.;\nconst float BEFORELAP = 5.;\nconst float STARTLAP = 1.;\nconst float AFTERLAP = 5.;\nconst float ENDLAP = 5.;\nconst float RACELAP = ALLLAP - BEFORELAP - AFTERLAP - ENDLAP;\n\n// スタート時の逆流を防ぐ応急処理\nfloat extraMileage = 1.75;\n\nfloat progress;\nfloat beforeProgress;\nfloat startProgress;\nfloat finishProgress;\n\nconst float marbleSize = .008;\nconst float roadWidth = .1;\n\nconst float cityHeight = 0.05;\nconst float cityScale = 32.;\n\n#define STARTPOSITION vec2(0.,0.)\n#define INITIALPOS vec2(0.,.5)+STARTPOSITION\n#define INITIALDIR vec2(1.,0.)\n\nconst float fogDensity=1.5;\nconst float fogDistance=0.1;\nconst vec3 fogColor=vec3(.34,.37,.4);\n\nconst float windowSize=.3/cityScale;\nconst float windowDivergence=.2/cityScale;\nconst vec3 windowColor=vec3(.1,.2,.5);\n\nconst float streetDistance=.015;\nconst vec3 streetColor=vec3(4.,8.,10.);\n\nconst float beaconProb=.003;\nconst float beaconFreq=.6;\nconst vec3 beaconColor=vec3(1.5,.2,0.);\nconst vec3 beaconGreenColor=vec3(.2,1.5,0.);\n\nconst vec3 roadGlow=vec3(1,.3,.2)*2E-5;\n\nvec4 RACERNUMCOLOR[8]=vec4[](\n    vec4(1.,0.,0.,1.),// Red\n    vec4(0.,1.,0.,1.),// Green\n    vec4(0.,0.,1.,1.),// Blue\n    vec4(1.,1.,0.,1.),// Yellow\n    vec4(1.,0.,1.,1.),// Magenta\n    vec4(0.,1.,1.,1.),// Cyan\n    vec4(.5,.5,.5,1.),// Gray\n    vec4(1.,1.,1.,1.)// White\n);\n\n//   _ __   ___ (_)___  ___ \n//  | '_ \\ / _ \\| / __|/ _ \\\n//  | | | | (_) | \\__ \\  __/\n//  |_| |_|\\___/|_|___/\\___|\n\nfloat hash1(vec2 p2){\n    p2=fract(p2*vec2(5.3983,5.4427));\n    p2+=dot(p2.yx,p2.xy+vec2(21.5351,14.3137));\n    return fract(p2.x*p2.y*95.4337);\n}\n\nfloat hash1(vec2 p2,float p){\n    vec3 p3=fract(vec3(5.3983*p2.x,5.4427*p2.y,6.9371*p));\n    p3+=dot(p3,p3.yzx+19.19);\n    return fract((p3.x+p3.y)*p3.z);\n}\n\nvec2 hash2(vec2 p2){\n    vec3 p3=fract(vec3(5.3983*p2.x,5.4427*p2.y,6.9371*p2.x));\n    p3+=dot(p3,p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash2(vec2 p2,float p){\n    vec3 p3=fract(vec3(5.3983*p2.x,5.4427*p2.y,6.9371*p));\n    p3+=dot(p3,p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash3(vec2 p2){\n    vec3 p3=fract(vec3(p2.xyx)*vec3(5.3983,5.4427,6.9371));\n    p3+=dot(p3,p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat noise1(vec2 p){\n    vec2 i=floor(p);\n    vec2 f=fract(p);\n    vec2 u=f*f*(3.-2.*f);\n    return mix(mix(hash1(i+vec2(0.,0.)),\n    hash1(i+vec2(1.,0.)),u.x),\n    mix(hash1(i+vec2(0.,1.)),\n    hash1(i+vec2(1.,1.)),u.x),u.y);\n}\n\nfloat Hash21(vec2 p){\n    p=fract(p*vec2(234.24,234.535));\n    p+=dot(p,p+34.23+COURCEID);\n    return fract(p.x*p.y);\n}\n\n// Simplex 2D noise\nvec3 permute(vec3 x){return mod(((x*34.)+1.)*x,289.);}\n\nfloat snoise(vec2 v){\n    const vec4 C=vec4(.211324865405187,.366025403784439,\n    -.577350269189626,.024390243902439);\n    vec2 i=floor(v+dot(v,C.yy));\n    vec2 x0=v-i+dot(i,C.xx);\n    vec2 i1;\n    i1=(x0.x>x0.y)?vec2(1.,0.):vec2(0.,1.);\n    vec4 x12=x0.xyxy+C.xxzz;\n    x12.xy-=i1;\n    i=mod(i,289.);\n    vec3 p=permute(permute(i.y+vec3(0.,i1.y,1.))\n    +i.x+vec3(0.,i1.x,1.));\n    vec3 m=max(.5-vec3(dot(x0,x0),dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)),0.);\n    m=m*m;\n    m=m*m;\n    vec3 x=2.*fract(p*C.www)-1.;\n    vec3 h=abs(x)-.5;\n    vec3 ox=floor(x+.5);\n    vec3 a0=x-ox;\n    m*=1.79284291400159-.85373472095314*(a0*a0+h*h);\n    vec3 g;\n    g.x=a0.x*x0.x+h.x*x0.y;\n    g.yz=a0.yz*x12.xz+h.yz*x12.yw;\n    return 130.*dot(m,g);\n}\n\n//   _____           _   \n//  |  ___|__  _ __ | |_ \n//  | |_ / _ \\| '_ \\| __|\n//  |  _| (_) | | | | |_ \n//  |_|  \\___/|_| |_|\\__|\n// kinankomoti font_logging https://www.shadertoy.com/view/mdVSWz\n#define FontWidth 8\n#define FontHeight 8\n#define LineMaxLength 40\n\nivec2 font_data[94]=ivec2[](\n    //0\n    ivec2(0x00000000,0x00000000),//space\n    \n    //1~10\n    ivec2(0x7e91897e,0x00000000),//0\n    ivec2(0x01ff4121,0x00000000),//1\n    ivec2(0x71898543,0x00000000),//2\n    ivec2(0x6e919142,0x00000000),//3\n    ivec2(0x08ff4838,0x00000000),//4\n    ivec2(0x8e9191f2,0x00000000),//5\n    ivec2(0x0e91916e,0x00000000),//6\n    ivec2(0xc0b08f80,0x00000000),//7\n    ivec2(0x6e91916e,0x00000000),//8\n    ivec2(0x6e919162,0x00000000),//9\n    \n    //11~36\n    ivec2(0x1e11110e,0x00000001),//a\n    ivec2(0x0e11117f,0x00000000),//b\n    ivec2(0x0a11110e,0x00000000),//c\n    ivec2(0x7f11110e,0x00000000),//d\n    ivec2(0x0815150e,0x00000000),//e\n    ivec2(0x48483f08,0x00000000),//f\n    ivec2(0x3e494930,0x00000000),//g\n    ivec2(0x0708087f,0x00000000),//h\n    ivec2(0x012f0900,0x00000000),//i\n    ivec2(0x5e111102,0x00000000),//j\n    ivec2(0x000b047f,0x00000000),//k\n    ivec2(0x017f4100,0x00000000),//l\n    ivec2(0x0807080f,0x00000007),//m\n    ivec2(0x0708080f,0x00000000),//n\n    ivec2(0x06090906,0x00000000),//o\n    ivec2(0x1824243f,0x00000000),//p\n    ivec2(0x3f242418,0x00000000),//q\n    ivec2(0x0010081f,0x00000000),//r\n    ivec2(0x0012150d,0x00000000),//s\n    ivec2(0x11113e10,0x00000000),//t\n    ivec2(0x0f01010e,0x00000000),//u\n    ivec2(0x000e010e,0x00000000),//v\n    ivec2(0x010e010e,0x0000000f),//w\n    ivec2(0x0a040a11,0x00000011),//x\n    ivec2(0x3e090930,0x00000000),//y\n    ivec2(0x00191513,0x00000000),//z\n    \n    //36~63\n    ivec2(0x7f88887f,0x00000000),//A\n    ivec2(0x6e9191ff,0x00000000),//B\n    ivec2(0x4281817e,0x00000000),//C\n    ivec2(0x7e8181ff,0x00000000),//D\n    ivec2(0x919191ff,0x00000000),//E\n    ivec2(0x909090ff,0x00000000),//F\n    ivec2(0x4685817e,0x00000000),//G\n    ivec2(0xff1010ff,0x00000000),//H\n    ivec2(0x0081ff81,0x00000000),//I\n    ivec2(0x80fe8182,0x00000000),//J\n    ivec2(0x413608ff,0x00000000),//K\n    ivec2(0x010101ff,0x00000000),//L\n    ivec2(0x601060ff,0x000000ff),//M\n    ivec2(0x0c1060ff,0x000000ff),//N\n    ivec2(0x7e81817e,0x00000000),//O\n    ivec2(0x609090ff,0x00000000),//P\n    ivec2(0x7f83817e,0x00000001),//Q\n    ivec2(0x619698ff,0x00000000),//R\n    ivec2(0x4e919162,0x00000000),//S\n    ivec2(0x80ff8080,0x00000080),//T\n    ivec2(0xfe0101fe,0x00000000),//U\n    ivec2(0x0e010ef0,0x000000f0),//V\n    ivec2(0x031c03fc,0x000000fc),//W\n    ivec2(0x340834c3,0x000000c3),//X\n    ivec2(0x300f30c0,0x000000c0),//Y\n    ivec2(0xe1918d83,0x00000081),//Z\n    \n    //63~\n    ivec2(0x00007d00,0x00000000),//!\n    ivec2(0x60006000,0x00000000),//\"\n    ivec2(0x3f123f12,0x00000012),//#\n    ivec2(0x52ff5224,0x0000000c),//$\n    ivec2(0x33086661,0x00000043),//%\n    ivec2(0x374d5926,0x00000001),//&\n    ivec2(0x00006000,0x00000000),//'\n    ivec2(0x0081423c,0x00000000),//(\n    ivec2(0x003c4281,0x00000000),//)\n    ivec2(0x00143814,0x00000000),//*\n    ivec2(0x00103810,0x00000000),//+\n    ivec2(0x00020100,0x00000000),//,\n    ivec2(0x08080808,0x00000000),//-\n    ivec2(0x00000100,0x00000000),//.\n    ivec2(0x30080601,0x00000040),///\n    ivec2(0x00240000,0x00000000),//:\n    ivec2(0x00240200,0x00000000),//;\n    ivec2(0x41221408,0x00000000),//<\n    ivec2(0x00141414,0x00000000),//=\n    ivec2(0x08142241,0x00000000),//>\n    ivec2(0xa999423c,0x0000007c),//@\n    ivec2(0x008181ff,0x00000000),//[\n    ivec2(0x06083040,0x00000001),//\\\n    ivec2(0x00000000,0x00000000),//] 何故か表示されない\n    ivec2(0x00ff8181,0x00000000),//]\n    ivec2(0x20402010,0x00000010),//^\n    ivec2(0x01010101,0x00000000),//_\n    ivec2(0x40408080,0x00000000),//`\n    ivec2(0x41413608,0x00000000),//{\n    ivec2(0x00ff0000,0x00000000),//|\n    ivec2(0x08364141,0x00000000),//}\n    ivec2(0x08101008,0x00000010)//~\n    \n);\n\nvec3 font(vec2 uv,int id){\n    vec2 uv1=uv;\n    uv=uv*8.;\n    ivec2 texel=ivec2(uv);\n    int bit_offset=texel.x*FontWidth+texel.y;\n    \n    int s,t;\n    s=font_data[id].x;\n    t=font_data[id].y;\n    \n    int tex=0;\n    \n    if(bit_offset<=31){\n        s=s>>bit_offset;\n        s=s&0x00000001;\n        tex=s;\n    }\n    else{\n        t=t>>(bit_offset-32);\n        t=t&0x00000001;\n        tex=t;\n    }\n    \n    tex=(abs(uv1.x-.5)<.5&&abs(uv1.y-.5)<.5)?tex:0;\n    return vec3(tex);\n}\n\n\n//           _  __ \n//   ___  __| |/ _|\n//  / __|/ _` | |_ \n//  \\__ \\ (_| |  _|\n//  |___/\\__,_|_|  \nbool drawCircle(vec2 uv,vec2 pos){\n    float posPoint=.075-length(pos-uv);\n    return ceil(posPoint)==1.;\n}\n\nfloat calculateGridLine(vec2 uv,float grid_size,float line_width){\n    \n    // グリッドの線を計算\n    float line_x=step(grid_size-line_width,mod(uv.x-line_width/2.,grid_size));\n    float line_y=step(grid_size-line_width,mod(uv.y-line_width/2.,grid_size));\n    \n    float line=line_x+line_y;\n    \n    return line;\n}\n\nfloat sdSphere(vec3 p,float r)\n{\n    return length(p)-r;\n}\n\n//    ____ _____ _     _     \n//   / ___| ____| |   | |    \n//  | |   |  _| | |   | |    \n//  | |___| |___| |___| |___ \n//   \\____|_____|_____|_____|\nint getcell(vec2 pos){\n    return int(floor(Hash21(mod(pos,vec2(64.)))*3.));\n}\n\nfloat passedCellNum(float mileage){\n    return floor(mileage);\n}\n\nstruct TruchetData{\n    vec2 pos;\n    vec2 dir;\n    vec2 floorpos;\n};\n\nTruchetData allSkippedData[128];\nint lastSkippedDataIndex;\n\n#define EXTRACELL 5.\nvoid setSkipTruchetData(vec2 pos,vec2 dir, vec2 floorpos, float mileage){\n    for(float i=0.;i<passedCellNum(RACELAP) + EXTRACELL;i++){\n        // for(float i=0.;i<floor(fract(time*.01)*100.);i++){\n        pos+=dir*.5;// centerPosがタイルの中央に乗る\n        int celltype=getcell(floorpos);//現在の位置のセルタイプを取得\n        \n        // セルタイプが0の場合、左に曲がるよう方向を転換\n        if(celltype==0){\n            dir=dir.yx;\n        // セルタイプが1の場合、右に曲がるよう方向を転換\n        }else if(celltype==1){\n            dir=-dir.yx;\n        }\n        // セルタイプが2の場合、方向を変えずに進むため方向転換無し\n        \n        floorpos+=dir;// 現在のタイル位置を次のタイル位置に更新\n        pos+=dir*.5;// centerPosが次のタイルの端に乗る\n\n        allSkippedData[int(i)]=TruchetData(pos,dir,floorpos);\n    }\n}\n\nvec2 getCachedSkipTruchetPos(inout vec2 pos,inout vec2 dir,inout vec2 floorpos, float mileage){\n    int index = int(passedCellNum(mileage));\n    TruchetData data=allSkippedData[index];\n    pos=data.pos;\n    dir=data.dir;\n    floorpos=data.floorpos;\n    return pos;\n}\n\nvec4 getNowOnTruchetPos(inout vec2 pos,inout vec2 dir,inout vec2 floorpos,float mileage,float sidePosition){\n    float multiplier=1.;\n\n    int celltype=getcell(floorpos);\n    vec2 nextDir;\n    if(celltype==0){\n        nextDir=dir.yx;\n    }else if(celltype==1){\n        nextDir=-dir.yx;\n    }\n\n    float corner=dir.x*nextDir.y-dir.y*nextDir.x;\n\n    // 仕組みがわからないですが観察結果から、横移動の場合は左が逆転する\n    float side = 1.;\n    if(dir.x!=0.) side = -1.;\n\n\n    // affectが正なら右に移動\n    float affect = sidePosition*(roadWidth*5.);\n    //　左回転\n    if(0.<corner){\n        pos+=dir.yx * affect * .5 * side;\n        multiplier=1.+affect;\n    }\n    //　右回転\n    if(corner<0.){\n        pos+=dir.yx * affect * .5 * side;\n        multiplier=1.-affect;\n    }\n    // 直進\n    if(corner==0.){\n        //dirのy,xを入れ替えたものに、xに-1をかけたものが左になる\n        pos+=dir.yx * vec2(1,-1) * affect * .5;\n    }\n\n    \n\n    // mileageに応じて位置調整\n    pos+=dir*sin(fract(mileage)*pi*.5)*.5 * multiplier;\n\n    vec2 dirForRacingObject=dir;\n    if(celltype==0){\n        dirForRacingObject*=rot(dot(abs(dir),vec2(-1.,1.))*fract(mileage)*pi*.5);\n        dir=dir.yx;\n    }else if(celltype==1){\n        dirForRacingObject*=rot(dot(abs(dir),vec2(1.,-1.))*fract(mileage)*pi*.5);\n        dir=-dir.yx;\n    }\n    pos+=dir*(.5-cos(fract(mileage)*pi*.5)*.5) * multiplier;\n    return vec4(pos,dirForRacingObject);\n}\n\n//   ____                     \n//  |  _ \\ __ _  ___ ___ _ __ \n//  | |_) / _` |/ __/ _ \\ '__|\n//  |  _ < (_| | (_|  __/ |   \n//  |_| \\_\\__,_|\\___\\___|_|   \nstruct Racer{\n    vec2 pos;\n    vec2 dirForRacingObject;\n    vec4 color;\n    float ID;\n    float mileage;\n};\n\nRacer createRacerFromTruchet(float mileage,float sidePosition, vec4 color, float ID){\n    vec2 racerPos;\n    vec2 dir;\n    vec2 floorpos;\n    racerPos=getCachedSkipTruchetPos(racerPos,dir,floorpos,mileage);\n    vec4 getNowOnTruchetPosResult = getNowOnTruchetPos(racerPos,dir,floorpos,mileage,sidePosition);\n    return Racer(getNowOnTruchetPosResult.xy,getNowOnTruchetPosResult.zw,color,ID, mileage);\n}\n\n\n//   ____             _\n//  / ___|  ___  _ __| |_\n//  \\___ \\ / _ \\| '__| __|\n//   ___) | (_) | |  | |_\n//  |____/ \\___/|_|   \\__|\n// バブルソートで任意の数の構造体配列をソートする関数\nvoid bubbleSort(inout Racer arr[RACERNUM],int size){\n    for(int i=0;i<size-1;i++){\n        for(int j=0;j<size-i-1;j++){\n            if(arr[j].mileage<arr[j+1].mileage){\n                // 値を入れ替える\n                Racer temp=arr[j];\n                arr[j]=arr[j+1];\n                arr[j+1]=temp;\n            }\n        }\n    }\n}\n\n//   ____                      \n//  / ___|  ___ ___ _ __   ___ \n//  \\___ \\ / __/ _ \\ '_ \\ / _ \\\n//   ___) | (_|  __/ | | |  __/\n//  |____/ \\___\\___|_| |_|\\___|\nfloat getRoadOrCity(vec2 block, float roadWidth){\n    // ■ タイルごとのUV生成\n    vec2 flooruv=floor(block);\n    vec2 uvOfTile=block-flooruv-.5;\n    int celltype=getcell(flooruv.xy);\n\n    // ■ 道の描画\n    //uvから道のもとになるlenを作る\n    vec2 uvOfTileForRoad=uvOfTile;\n    if(celltype==0)uvOfTileForRoad*=vec2(1.,-1.);\n    uvOfTileForRoad*=step(0.,uvOfTileForRoad.x+uvOfTileForRoad.y)*2.-1.;\n    float len;\n    if(celltype==2){\n        len=min(abs(uvOfTileForRoad.x),abs(uvOfTileForRoad.y));\n    }else{\n        len=length(uvOfTileForRoad-.5)-.5;\n    }\n\n    //道を描画\n    float roadSize=(abs(len)-roadWidth)*iResolution.y*.1;\n    float clampedRoad=clamp(roadSize,0.,1.);\n\n    return clampedRoad;\n}\n\n// inspired by Glow City mhnewman https://www.shadertoy.com/view/XlsyWB\n#define NOHIT 0.\n#define HIT_CITY 1.\n#define HIT_ROAD 2.\n\nstruct CityResult{\n    float distance;\n    float beacon;\n    float face;\n    float hittedTarget;\n    float distanceFromEye;\n    vec3 hitPos;\n};\n\nCityResult cityRay(vec3 eye,vec3 ray){\n    eye.xyz = eye.xzy;\n    ray.xyz = ray.xzy;\n    vec2 block=floor(eye.xy*cityScale)/cityScale;\n    vec3 ri=1./ray;\n    vec3 rs=sign(ray);\n    vec3 side=.5+.5*rs;\n    vec2 ris=ri.xy*rs.xy;\n    vec2 dis=(block-eye.xy+.5/cityScale+rs.xy*.5/cityScale)*ri.xy;\n    \n    float hit=0.;\n    float beacon=0.;\n\n    vec3 resultPos;\n\n    float dist=500.;\n    float face=0.;\n    \n    for(int i=0;i<150;++i){\n        // 高さの計算を元に戻し、建物ごとにランダム化\n        // 面の交差判定を安定させるために、1/3スケールに調整\n        vec2 lo0=vec2(block+.01/cityScale);// 面の下端を調整\n        vec2 loX=vec2(.3,.3)/cityScale;\n        vec2 hi0=vec2(block+.69/cityScale);// 面の上端を調整\n        vec2 hiX=vec2(.3,.3)/cityScale;\n        float height=(.5+hash1(block))*(2.+4.*pow(noise1(.1*block),2.5))*cityHeight;\n        float clampedRoad=getRoadOrCity(block,roadWidth);\n        height *= clampedRoad;\n        \n        dist=500.;\n        face=0.;\n        \n        // ビルの各面について交差判定を行う\n        for(int j=0;j<int(float(3)*clampedRoad);++j){\n        // for(int j=0;j<1;++j){\n            float top=height*(1.-.1*float(j));\n            vec3 lo=vec3(lo0+loX*hash2(block,float(j)),0.);\n            vec3 hi=vec3(hi0+hiX*hash2(block,float(j)+.5),top);\n            \n            vec3 wall=mix(hi,lo,side);// 交差面の位置\n            vec3 t=(wall-eye)*ri;\n            \n            vec3 dim=step(t.zxy,t)*step(t.yzx,t);\n            float maxT=dot(dim,t);\n            float maxFace=1.-dim.z;\n            \n            resultPos=eye+maxT*ray;\n            if(resultPos.z<0.0){\n                return CityResult(dist,beacon,face,HIT_ROAD,length(resultPos-eye),resultPos.xzy);\n            }\n            dim+=step(lo,resultPos)*step(resultPos,hi);// 面内判定\n            if(dim.x*dim.y*dim.z>.5&&maxT<dist){\n                dist=maxT;\n                face=maxFace;\n            }\n        }\n            \n        vec2 h=hash2(block);\n        if(h.x<beaconProb){\n            vec3 center=vec3(block+.5/cityScale,height);\n            float t=dot(center-eye,ray);\n            if(t<dist){\n                vec3 p=eye+t*ray;\n                float fog=(exp(-p.z/fogDistance)-exp(-eye.z/fogDistance))/ray.z;\n                fog=exp(fogDensity*fog);\n                \n                t=distance(center,p);\n                fog*=smoothstep(1.,.5,cos(tau*(beaconFreq*iTime+h.y)));\n                beacon+=fog*pow(clamp(1.-t*25.0,0.,1.),4.);\n            }\n        }\n\n        // スタートシグナル\n        if(0. < beforeProgress && startProgress < 1.){\n            int index=int(passedCellNum(0.));\n            TruchetData data=allSkippedData[index];\n            vec2 startLine = floor(data.pos*cityScale)/cityScale;\n            \n            if(startLine.x - roadWidth + 1./cityScale < block.x\n             && block.x < startLine.x + roadWidth * (beforeProgress+0.2) - 1./cityScale\n             && startLine.y + 0.25 < block.y\n             && block.y< startLine.y+.25+2./cityScale\n             ){\n                vec3 center=vec3(block+.5/cityScale,.03);\n                float t=dot(center-eye,ray);\n                if(t<dist){\n                    vec3 p=eye+t*ray;\n                    float fog=(exp(-p.z/fogDistance)-exp(-eye.z/fogDistance))/ray.z;\n                    fog=exp(fogDensity*fog);\n                    t=distance(center,p);\n                    beacon+=fog*pow(clamp(1.-t*25.,0.,1.),4.)*10.;\n                }\n            }\n        }\n\n        // ゴールポイント\n        int index=int(passedCellNum(RACELAP + extraMileage));\n        TruchetData data=allSkippedData[int(index)];\n        vec2 startLine=floor(data.pos*cityScale)/cityScale;\n\n        if(startLine.x-roadWidth<block.x\n            &&block.x<startLine.x+roadWidth\n            &&block.y<startLine.y+roadWidth\n            &&startLine.y-roadWidth<block.y){\n            vec3 center=vec3(block+.5/cityScale,.03);\n            float t=dot(center-eye,ray);\n            if(t<dist){\n                vec3 p=eye+t*ray;\n                float fog=(exp(-p.z/fogDistance)-exp(-eye.z/fogDistance))/ray.z;\n                fog=exp(fogDensity*fog);\n                t=distance(center,p);\n                beacon+=fog*pow(clamp(1.-t*3.,0.,1.),4.);\n            }\n        }\n        \n        if(dist<400.){\n            return CityResult(dist,beacon,face,HIT_CITY,length(resultPos-eye),resultPos.xzy);\n        }\n        \n        vec2 dim=step(dis.xy,dis.yx);\n        dis+=dim*ris/cityScale;\n        block+=dim*rs.xy/cityScale;\n    }\n\n    if(ray.z<0.){\n        return CityResult(-eye.z*ri.z,beacon,0.,1.,1000.,(eye+1000.*ray).xzy);\n    }\n        \n    return CityResult(0.,beacon,0.,NOHIT,0.,vec3(0.));\n}\n\nCityResult cityScene(vec3 ro,vec3 rd,inout vec4 returnColor){\n    float dist=-(ro.y)/rd.y;// 右はri\n    vec2 hit1=ro.xz+rd.xz*dist;\n    // ■ シティの描画\n    CityResult cityResult=cityRay(ro,rd);\n    // vec3 p=ro+cityResult.distance*rd;\n    vec3 p=cityResult.hitPos;\n\n    vec2 block=floor(p.xz*cityScale)/cityScale;\n    vec3 window=floor(p/windowSize);\n    float x=hash1(block,window.x);\n    float y=hash1(block,window.y);\n    float z=hash1(block,window.z);\n    vec3 color=windowColor+windowDivergence*(hash3(block)-.5);\n    color*=smoothstep(.1,.9,fract(2.5*(x*y*z)));\n\n    vec3 streetLevel=streetColor*exp(-p.y/streetDistance);\n    color+=streetLevel;\n    color=clamp(mix(.25*streetLevel,color,cityResult.face),0.,1.);\n\n    float fog=(exp(-p.y/fogDistance)-exp(-ro.y/fogDistance))/rd.y;\n    fog=exp(fogDensity*fog);\n    color=mix(fogColor,color,fog);\n\n    color=mix(fogColor,color,clamp(cityResult.hittedTarget,0.,1.));\n    vec3 tmpBeaconColor=beaconColor;\n    if(0. < startProgress && startProgress < 1.) tmpBeaconColor = beaconGreenColor; \n    color+=cityResult.beacon*tmpBeaconColor;\n    returnColor=vec4(color,1.);\n\n    // ■ タイルごとのUV生成\n    vec2 flooruv=floor(hit1);\n    vec2 uvOfTile=hit1-flooruv-.5;\n    int celltype=getcell(flooruv.xy);\n\n    // ■ 道の描画\n    // inspired by MountainBytes: PPPP 4KiB Windows mrange & virgill https://www.shadertoy.com/view/lX2GzD\n    //uvから道のもとになるlenを作る\n    vec2 uvOfTileForRoad=uvOfTile;\n    if(celltype==0)uvOfTileForRoad*=vec2(1.,-1.);\n    uvOfTileForRoad*=step(0.,uvOfTileForRoad.x+uvOfTileForRoad.y)*2.-1.;\n\n    float len;\n    float dashed;\n    float dashLineSize=.1;\n    float dashLineRatio=.3;\n    if(celltype==2){\n        len=min(abs(uvOfTileForRoad.x),abs(uvOfTileForRoad.y));\n        dashed=step(fract((uvOfTileForRoad.x+uvOfTileForRoad.y)/dashLineSize),dashLineRatio);\n    }else{\n        len=length(uvOfTileForRoad-.5)-.5;\n        float polar=atan(uvOfTileForRoad.x-.5,uvOfTileForRoad.y-.5)/(pi*2.)+.5;\n        dashed=step(fract(polar/dashLineSize*4.),dashLineRatio);\n    }\n\n    //道を描画\n    float roadSize=(abs(len)-roadWidth)*iResolution.y*.1;\n    float lineSize=.1;\n    float clampedRoad=clamp(roadSize,0.,1.);\n    if(cityResult.hittedTarget==HIT_ROAD){\n        bool is1Load=false;\n        \n        //bpは普通の線\n        //lenは点線\n        float bp;\n        if(is1Load){\n            bp=abs(len)-.2;//1road\n        }\n        else{\n            float centerSideLine=abs(len)-.01;\n            returnColor+=vec4(roadGlow/(centerSideLine*centerSideLine)*lineSize,1.);\n            bp=abs(len)-.085;//2road\n            len=abs(len)-.05;//2road\n        }\n        \n        vec3 glowIntensity=roadGlow/((len*len))*lineSize;\n        returnColor+=vec4(glowIntensity*dashed,1.);\n        \n        float baseGlowIntensity=.25/(bp*bp)*lineSize;\n        returnColor+=vec4(baseGlowIntensity*roadGlow,1.);\n    }\n\n    return cityResult;\n}\n\nRacer allRacers[RACERNUM];\n\nstruct BallResult{\n    float distance;\n    int racerNum;\n    float distanceFromEye;\n    vec3 hitPos;\n};\n\nBallResult scene(vec3 p){\n    // ■ レーサーの描画\n    float minD=1000.;\n    int racerNum=-1;\n    for(int i=0;i<RACERNUM;i++){\n        float d=sdSphere(p-vec3(allRacers[i].pos.x,marbleSize,allRacers[i].pos.y),marbleSize);\n        if(d<minD){\n            minD=d;\n            racerNum=i;\n        }\n    }\n    return BallResult(minD,racerNum,0.,p);\n}\n\n\n// レイマーチングによる距離探査\nBallResult rayMarch(vec3 ro, vec3 rd, inout vec3 hitPos){\n    float t=0.;\n    float tolerance=.001;\n    // 近景\n    for(int i=0;i<50;i++){\n        hitPos=ro+rd*t;\n        BallResult sr=scene(hitPos);\n        if(sr.distance<tolerance){\n            return BallResult(sr.distance,sr.racerNum,length(hitPos-ro),hitPos);\n            //  vec2(t,KINKEI);// ヒット時\n        }\n        t+=sr.distance;\n    }\n    return BallResult(1000.,-1,length(hitPos-ro),hitPos);\n}\n\nBallResult ballScene(vec3 ro,vec3 rd,inout vec3 hitPos, out vec4 color){\n    BallResult sr = rayMarch(ro,rd,hitPos);\n\n    vec2 o=vec2(.001,0);   \n    vec3 n=normalize(vec3(\n            scene(sr.hitPos+o.xyy).distance-scene(sr.hitPos-o.xyy).distance,\n            scene(sr.hitPos+o.yxy).distance-scene(sr.hitPos-o.yxy).distance,\n            scene(sr.hitPos+o.yyx).distance-scene(sr.hitPos-o.yyx).distance\n        ));\n    // balls\n    float fresnel=pow(1.-dot(-rd,n),5.);\n    fresnel=mix(.5,1.,fresnel);\n    \n    ro=sr.hitPos+n*.0015;\n    rd=reflect(rd,n);\n    \n    CityResult bounceCr = cityScene(ro,rd,color);\n    color *=fresnel;\n    return sr;\n}\n\n//    ____                               \n//   / ___|__ _ _ __ ___   ___ _ __ __ _ \n//  | |   / _` | '_ ` _ \\ / _ \\ '__/ _` |\n//  | |__| (_| | | | | | |  __/ | | (_| |\n//   \\____\\__,_|_| |_| |_|\\___|_|  \\__,_|\nstruct Camera{\n    vec3 ro;\n    vec3 rd;\n};\n\nvec3 createRd(in vec2 fragCoord, vec3 forward){\n    vec3 right=normalize(cross(forward,vec3(0.,1.,0.)));\n    vec3 up=cross(right,forward);\n    vec2 xy=2.*fragCoord-iResolution.xy;\n    float zoom=3.;\n    zoom*=iResolution.y;\n    vec3 rd=normalize(xy.x*-right+xy.y*up+zoom*forward);\n    return rd;\n}\n\nCamera makeCamera(in vec2 fragCoord, float time, bool isStarting, vec3 hashedValue, bool isFinished){\n\n    // ■ 画面全体のUV\n    vec2 realUV=(fragCoord.xy*2.-iResolution.xy)/iResolution.y;\n\n    vec3 h=hashedValue;\n    bool onBoardCamera=h.x<onBoardCameraProb;\n    bool backCamera=h.y<onBoardCameraProb;\n    int racerNum=int(h.z*float(RACERNUM));\n    \n    // オンボードカメラ\n    if(!isFinished&&!isStarting&&onBoardCamera){\n        float isBack=1.;\n        if(backCamera)isBack=-1.;\n        \n        vec2 center2d=allRacers[racerNum].pos;\n\n        vec2 dirForRacingObject=allRacers[racerNum].dirForRacingObject;\n\n        vec3 ro=vec3(center2d.x-dirForRacingObject.x*.05*isBack,.05,center2d.y-dirForRacingObject.y*.04*isBack);\n\n        vec2 tmpUV=vec2(-realUV.x,realUV.y);\n        vec3 rd=normalize(vec3(tmpUV-vec2(0.,.5),1.));\n        rd.xz*=mat2(vec2(-dirForRacingObject.y,dirForRacingObject.x),dirForRacingObject)*isBack;\n        return Camera(ro,rd);\n    }\n\n\n    vec2 center2d=allRacers[racerNum].pos;\n    if(isFinished){\n        int index=int(passedCellNum(RACELAP + extraMileage));\n        TruchetData data=allSkippedData[index];\n        center2d=data.pos;\n    } \n    \n\n    // roの定義\n    vec3 center=vec3(center2d.x,.1,center2d.y);\n\n    vec2 m=vec2(.01*iTime,.5+sin(.02*iTime)*.2);\n    if(iMouse.z>0.)m=iMouse.xy/iResolution.xy;\n    m*=tau*vec2(1.,.25);\n    float cameraDist=2.;\n    vec3 mouseFix=vec3(\n        cameraDist*sin(m.x)*sin(m.y),\n        cameraDist*cos(m.y),\n        cameraDist*cos(m.x)*sin(m.y));\n\n    //　固定カメラ\n    bool isKoteiCamera=backCamera&&!onBoardCamera;\n    if(!isFinished&&!isStarting&&isKoteiCamera){\n        int index=int(passedCellNum(allRacers[racerNum].mileage));\n        TruchetData data=allSkippedData[index+1];\n        center=vec3(data.pos.x,.1,data.pos.y);\n        mouseFix=vec3(\n            roadWidth*sin(m.x)*sin(m.y),\n            roadWidth*cos(m.y),\n            roadWidth*cos(m.x)*sin(m.y));\n        vec3 ro = center+mouseFix;\n        vec3 target =vec3(allRacers[racerNum].pos.x,marbleSize,allRacers[racerNum].pos.y);\n        vec3 forward = normalize(target-ro);\n        return Camera(ro,createRd(fragCoord,forward));\n    }\n\n\n    vec3 ro=center+mouseFix;\n\n    if(isStarting){\n        int index=int(passedCellNum(0.));\n        TruchetData data=allSkippedData[index];\n        center=vec3(data.pos.x,.0,data.pos.y);\n        ro = center + vec3(data.dir.x,0.3,data.dir.y) + mouseFix*0.05;\n    }\n\n    // rdの定義\n    vec3 forward=normalize(center-ro);\n    vec3 rd=createRd(fragCoord,forward);\n    \n    \n\n    return Camera(ro,rd);\n}\n\n//   __  __    _    ___ _   _ \n//  |  \\/  |  / \\  |_ _| \\ | |\n//  | |\\/| | / _ \\  | ||  \\| |\n//  | |  | |/ ___ \\ | || |\\  |\n//  |_|  |_/_/   \\_\\___|_| \\_|\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 floorpos=STARTPOSITION;\n    vec2 initialPos=INITIALPOS;\n    vec2 dir=INITIALDIR;// 初期の方向 以降最初はx=1の方向に進む前提のコード\n    \n    // ■ 時間の設定\n    float gameSpeed = iTime * 0.75;\n    float time = fract(gameSpeed / (ALLLAP)) * (ALLLAP);\n    float raceTime = BEFORELAP < time ? time - BEFORELAP: 0.;\n    progress = raceTime / RACELAP;\n    beforeProgress = clamp(time/(BEFORELAP),0.,1.);\n    startProgress = clamp((raceTime/STARTLAP),0.,1.);\n    finishProgress = clamp((time-(ALLLAP-AFTERLAP-ENDLAP))/AFTERLAP,0.,1.);\n    // ■ トルシェのデータの生成\n    setSkipTruchetData(initialPos,dir,floorpos,time);\n    \n    \n    // ■ レーサーの生成\n    for(int i=0;i<RACERNUM;i++){\n        float noiseVert=snoise(vec2(time*.01+COURCEID,float(i+1)*100.))*3.*progress-2.;\n        float noiseSide=snoise(vec2(time*.1+COURCEID,float(i+1)*10.*COURCEID))*.25;\n        float normalMileage = raceTime + noiseVert + extraMileage;\n        normalMileage = min(normalMileage, floor(RACELAP + extraMileage));\n        float normalSidePosition = noiseSide;\n\n        float beforeMileage = float(i) / float(RACERNUM) * 0.25;\n        float beforeSidePosition = (i % 2 == 0) ? 0.2 : -0.2;\n\n        // スタート時に徐々にスタート\n        float mileage = mix(beforeMileage, normalMileage, startProgress);\n        float sidePosition = mix(beforeSidePosition, normalSidePosition, startProgress);\n\n        allRacers[i]=createRacerFromTruchet(mileage,sidePosition,RACERNUMCOLOR[i],54321.);\n    }\n    bubbleSort(allRacers,RACERNUM);\n\n    // ランダム値\n    vec3 h=hash3(floor(vec2(time/3.))+COURCEID);\n    int racerNum=int(h.z*float(RACERNUM));\n\n    // ■ カメラの生成\n    Camera camera = makeCamera(fragCoord, raceTime, startProgress*2.<1., h, 0.<finishProgress);\n    vec3 ro=camera.ro;\n    vec3 rd=camera.rd;\n\n    // ■ レイキャスティング\n    float dist=-(ro.y)/rd.y; // 右はri\n    vec2 hit1=ro.xz+rd.xz*dist;\n\n    //       _             _   ____                     _\n    //   ___| |_ __ _ _ __| |_|  _ \\ _ __ __ ___      _(_)_ __   __ _\n    //  / __| __/ _` | '__| __| | | | '__/ _` \\ \\ /\\ / / | '_ \\ / _` |\n    //  \\__ \\ || (_| | |  | |_| |_| | | | (_| |\\ V  V /| | | | | (_| |\n    //  |___/\\__\\__,_|_|   \\__|____/|_|  \\__,_| \\_/\\_/ |_|_| |_|\\__, |\n    //                                                          |___/\n\n    // 空の描画\n    fragColor=vec4(fogColor,1);\n\n    // ■ シティの描画\n    CityResult cityResult = cityScene(ro,rd,fragColor);\n        \n    // ■ レーサーの描画\n    vec3 hitPos;\n    vec4 bounceColor;\n    BallResult sr=ballScene(ro,rd,hitPos,bounceColor);\n    if(sr.racerNum!=-1&&sr.distanceFromEye<cityResult.distanceFromEye){\n        fragColor=mix(bounceColor*3.,allRacers[sr.racerNum].color,.4);\n        // fragColor=allRacers[sr.racerNum].color;\n    }\n\n\n\n    //       _      _                 \n    //    __| | ___| |__  _   _  __ _ \n    //   / _` |/ _ \\ '_ \\| | | |/ _` |\n    //  | (_| |  __/ |_) | |_| | (_| |\n    //   \\__,_|\\___|_.__/ \\__,_|\\__, |\n    //                          |___/ \n\n    // ■グリッドの描画\n    float grid=calculateGridLine(hit1,1.,.02);\n    if(ONGRID) fragColor=mix(fragColor,vec4(0., 0.0, 1.0, 1.0),grid);\n\n\n    // // ■ スタートポジションは色を反転\n    // if(0.<hit1.x && hit1.x<1. && 0.<hit1.y && hit1.y<1.){\n    //     fragColor=vec4(1.,0.,0.,1.);\n    //     return;\n    //     // fragColor=1.-fragColor;\n    // }\n\n    //                       _             \n    //    _____   _____ _ __| | __ _ _   _ \n    //   / _ \\ \\ / / _ \\ '__| |/ _` | | | |\n    //  | (_) \\ V /  __/ |  | | (_| | |_| |\n    //   \\___/ \\_/ \\___|_|  |_|\\__,_|\\__, |\n    //                               |___/ \n\n\n\n    // ■ 画面UVの作成\n    vec2 uvForScreen=fragCoord/iResolution.x;\n    \n    // ■ mapの描画\n    if(.75<uvForScreen.x && .4<uvForScreen.y){\n        vec2 baseUV = (fragCoord.xy*2.-iResolution.xy+vec2(-.75,-.75)*iResolution.xy)/iResolution.x;\n        vec2 gameUV=8.*baseUV+allRacers[racerNum].pos;//3dでは不要\n        float mapRoadWidth=.15;\n        float mapClampedRoad = getRoadOrCity(gameUV,mapRoadWidth);\n\n        fragColor=mix(vec4(0),vec4(1),mapClampedRoad);\n        for(int i=RACERNUM-1;0<=i;i--){\n            if(drawCircle(gameUV,allRacers[i].pos)){\n                    fragColor=allRacers[i].color;\n            }\n        }   \n    }\n\n   \n\n    // ■　順位の描画\n    if(uvForScreen.x<0.15){\n        uvForScreen*=40.;\n        int lineNum=int(floor((uvForScreen.y)/1.2));\n        \n        ivec2 index=ivec2(uvForScreen/vec2(.8,1.2));\n        uvForScreen.x=mod(uvForScreen.x,.8);\n        uvForScreen.y=mod(uvForScreen.y,1.2);\n        int max_char = 1;\n        int raceOrderInIndex=15-lineNum;\n        if(0 <= raceOrderInIndex && raceOrderInIndex <= RACERNUM){\n              // 順序\n            if(0==index.x)fragColor=vec4(font(uvForScreen,raceOrderInIndex+1),1.);\n\n            // 色\n            if(1 == index.x){\n                fragColor=allRacers[raceOrderInIndex-1].color;\n            }\n            // Interval表示\n            // 先頭\n            if(raceOrderInIndex == 1){\n                if(2==index.x)fragColor=vec4(0.,0.,0.,1.);\n                if(3==index.x)fragColor=vec4(0.,0.,0.,1.);\n                if(4==index.x)fragColor=vec4(font(uvForScreen,45),1.);\n                if(5==index.x)fragColor=vec4(font(uvForScreen,50),1.);\n                if(6==index.x)fragColor=vec4(font(uvForScreen,56),1.);\n            }\n            else{ //　先頭以外\n                float interval = allRacers[raceOrderInIndex-2].mileage - allRacers[raceOrderInIndex-1].mileage;\n                if(2==index.x)fragColor=vec4(font(uvForScreen,73),1.);\n                if(3==index.x)fragColor=vec4(font(uvForScreen,int(interval+1.)),1.);\n                if(4==index.x)fragColor=vec4(font(uvForScreen,76),1.);\n                if(5==index.x)fragColor=vec4(font(uvForScreen,int(fract(interval)*10.+1.)),1.);\n                if(6==index.x)fragColor=vec4(font(uvForScreen,int(fract(interval*10.)*10.+1.)),1.);\n            }\n\n            //選択中のレーサーの色を反転\n            if(raceOrderInIndex-1 == racerNum && 2 <= index.x && index.x <= 6){ \n                fragColor=1.0-fragColor;\n            }\n\n            // ラップ数表示\n            if(raceOrderInIndex==0){\n                raceTime=min(raceTime+extraMileage,RACELAP);\n                int lap10=int(fract(raceTime*.01)*10.);\n                int lap1=int(fract(raceTime*.1)*10.);\n                if(0==index.x)fragColor=vec4(0.,0.,0.,1.);\n                if(1==index.x)fragColor=vec4(font(uvForScreen,lap10+1),1.);\n                if(2==index.x)fragColor=vec4(font(uvForScreen,lap1+1),1.);\n                if(3==index.x)fragColor=vec4(font(uvForScreen,77),1.);\n                int niketame=int(fract(RACELAP*.01)*10.);\n                int hitoketame=int(fract(RACELAP*.1)*10.);\n                if(4==index.x)fragColor=vec4(font(uvForScreen,niketame+1),1.);\n                if(5==index.x)fragColor=vec4(font(uvForScreen,hitoketame+1),1.);\n                if(6==index.x)fragColor=vec4(0.,0.,0.,1.);\n            }\n\n\n        }\n    }\n\n    // 終了後暗転\n    if(0.<finishProgress){\n        fragColor=mix(clamp(fragColor,0.,1.),vec4(0.),finishProgress);\n        return;\n    }\n}\n","name":"Image","description":"","type":"image"}]}