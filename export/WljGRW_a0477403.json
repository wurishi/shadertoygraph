{"ver":"0.1","info":{"id":"WljGRW","date":"1730628888","viewed":123,"name":"Bouncing Hexagonal Cubes","username":"msingdahl","description":"Hexagonal cube pattern with bouncing cubes","likes":15,"published":3,"flags":0,"usePreview":0,"tags":["hexgridcubeswallpaperanimatedprocedural"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hexSection = 3.1475/3.;\nfloat lightSide = .425;\nfloat darkSide = .2;\nfloat topSide = .7;\nvec3 lineColor = vec3(.02);\nvec3 bouncingCubeColor = vec3(.012);\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) \n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat distanceToSegment( in vec2 p, in vec2 a, in vec2 b ) \n{\n    //Iq's function\n\tvec2 pa = p-a;\n\tvec2 ba = b-a;\n\tfloat h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n\treturn length( pa - ba*h );\n}\n\nfloat hexDist(vec2 p) \n{\n \tp = abs(p);\n    float c = dot(p, normalize(vec2(1,1.73)));\n    c = max(c,p.x);\n    \n    return c;\n}\n\nfloat hex(in vec2 p) \n{\n    \n    p = abs(p);\n    \n    // Below is equivalent to:\n    //return max(p.x*.5 + p.y*.866025, p.x); \n\n    return max(dot(p, vec2(1.,1.73)*.5), p.x); // Hexagon.   \n}\n\n\nhighp float rand(vec2 co) \n{\n    co = vec2(int(co.x/.5),int(co.y/.865));\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\n\nhighp vec4 hexCoords(vec2 uv, out vec2 gv) \n{\n \thighp vec2 r = vec2(1, 1.73);\n    highp vec2 h = r*.5;   \n    highp vec2 a = mod(uv, r) - h;\n    highp vec2 b = mod(uv - h, r) - h;\n    \n    gv = dot(a, a) < dot(b,b) ? a : b;\n    \n    float x = atan(gv.x, gv.y);\n    float y = .5 - hex(gv);\n    highp vec2 id = uv - gv;\n    \n    return vec4(x,y,id.x,id.y);\n}\n\nvoid drawCube(inout vec3 col,vec2 hc) \n{\n    \n    if(abs(hc.x) < hexSection)\t{col = vec3(topSide);}\n    else if(-hc.x < hexSection)\t{col = vec3(darkSide);}\n    else if(hc.x < hexSection)\t{col = vec3(lightSide);}   \n}\n\nfloat weightTowardsCenter(vec2 id) \n{\n    \n    return length(id-vec2(300)) * 0.025;\n}\n\nbool isBouncing(vec2 id) \n{\n    if(rand(id) * weightTowardsCenter(id) < floor(iTime*15.) * .001)\n        return true;\n        \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy - .5 * iResolution.xy)/iResolution.y;    \n    float scale = 6. + min(floor(iTime/3.) * 4., 16.);\n\tuv*= scale;\n    uv += 300.;\n    uv += max(iTime - 16., 0.) * vec2(1.,1.73)/2.;\n    \n    float p = scale/min(iResolution.x,iResolution.y);\n   \tvec2 gv = fract(uv);\n  \n    vec4 hc = hexCoords(uv,gv);\n \tvec2 ogv = gv;\n    vec2 oid = hc.zw;\n    vec2 id = hc.zw;\n    \n    vec3 col = vec3(0);\n    //bouncingCubeColor = palette(length(oid-vec2(300)) * 22.21, vec3(.05,.95,0.35), vec3(.1,.1,.75),vec3(5.125,.3,.5),vec3(.2,.2,.0));\n    float lines = 1.;\n    \n  \tif(isBouncing(id))\n    {       \n        uv.y += 0.04 + (.45 * (sin(rand(id) * 5. + (iTime * 2. * ((iMouse.y/iResolution.y) +.5 )) * 5.) * .5+ .5));\n        hc = hexCoords(uv, gv);\n        id = hc.zw;       \n   \t\tdrawCube(col, hc.xy);\n        \n        if(oid != id)\n        {\n            oid = id;\n            \n            if(!isBouncing(oid))\n                lines -= smoothstep(1.0-p*2., 1.0+p*2., (hexDist(ogv) * 2.) + .02);\n        } else \n        {     \n            id += vec2(ogv.x < .0 ? -.5 :.5,-.865);\n\n            if(!isBouncing(id))\n                lines -= smoothstep(1.0-p*2., 1.0+p*2., (hexDist(ogv) * 2.) + .02);\n        }\n    }\n    else\n    {     \n        drawCube(col, hc.xy);\n    }\n          \t\n    //draw Y lines \n    lines -= smoothstep(1.0-p, 1.0+p,1. - (distanceToSegment(gv,vec2(0.),vec2(sin(hexSection),cos(hexSection))*.6) - .02));\n    lines -= smoothstep(1.0-p, 1.0+p,1. - (distanceToSegment(gv,vec2(0.),vec2(sin(-hexSection),cos(-hexSection))*.6) - .02));\n    lines -= smoothstep(1.0-p, 1.0+p,1. - (distanceToSegment(gv,vec2(0.),vec2(0.,-1.)) - .02));\n    //draw hex outline\n    lines -= smoothstep(1.0-p*2., 1.0+p*2., (hexDist(gv) * 2.) + .04);\n    lines = clamp(lines,0.,1.);                   \n   \n    if(isBouncing(oid))\n    {\n        float initialGlow = clamp(1. - (((iTime*15.*.001) - (rand(oid) * weightTowardsCenter(oid)))*50.)*.2,0.,1.);\n        initialGlow = clamp(pow(initialGlow,30.)*10.,0.,5.);\n        col *= bouncingCubeColor + vec3(1.,.7, 0.)*initialGlow;\n    }\n    \n    col *= lines;\n    col += (1. - lines) * lineColor;\n    col = pow(col, vec3(1.0 / 2.2));\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}