{"ver":"0.1","info":{"id":"Xd3SDM","date":"1459568015","viewed":206,"name":"Red bowl","username":"martk","description":"Bowl type of thing.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","raymarch","light","softshadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ZMAX 50.0\n#define EP 0.01\n#define ITER 50\n\n\nvoid rotate(inout vec2 p, float ang) {\n    \n    float c = cos(ang), s = sin(ang);\n    p = vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n//////////////////////////////////\n//https://iquilezles.org/articles/distfunctions\n//////////////////////////////////\n//subtract\nfloat opS( float d1, float d2 ) {\n    \n    return max(-d1,d2);\n}\n\n//intersection\nfloat opI( float d1, float d2 ) {\n    \n    return max(d1,d2);\n}\n\n//union\nfloat opU( float d1, float d2 ) {\n    \n    return min(d1,d2);\n}\n///////////////////////////////\n///////////////////////////////\n\n//weird sphere\nfloat sph(vec3 m,float r) {\n    \n    rotate(m.xy,iTime/8.);\n    rotate(m.yz,iTime/8.);\n    rotate(m.xz,iTime/8.);\n    \n    float d = sin(iTime)/10.+0.9;\n    float bumps = sin(d*m.x)*\n        \t\t  sin(d*m.y)*\n        \t\t  sin(d*m.z);\n    \n    return length(m) - r + bumps;\n}\n\nfloat map(vec3 m) {\n        \n    //top\n    float top = sph(m,10.);\n       \n    //subtract the top from the bottom to\n    //get the bowl type of thing\n    m.y-=11.;\n    float ng =opS(sph(m/.83,20.)*.83,top);\n\tm.y+=12.;\n  \n    //put the ball in the middle\n    return opU(ng,sph(m/.1,30.)*.1);\n  \n}\n\n//soft shadow function, pretty much a copy paste from\n//https://www.shadertoy.com/view/Xds3zN\nfloat softshadow( in vec3 ro, in vec3 rd) {\n    \n\tfloat res = 1.0;\n    float t = 0.02;\n    for(int i = 0; i < 8; ++i)\n    {\n\t\tfloat h = map(ro + rd * t);\n        res = min(res, 8. * h / t);\t\n        t += clamp(h, 0.02, 0.1);\n        if(h < 0.001 || t > 2.5) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 getNormal(vec3 v) {\n \n    vec3 e = vec3(EP,0.,0.);\n    return normalize(vec3(\n    \tmap(v + e.xyy) - map(v - e.xyy),\n    \tmap(v + e.yxy) - map(v - e.yxy),\n    \tmap(v + e.yyx) - map(v - e.yyx)\n    ));\n    \n}\n\n\nfloat march(vec3 o,vec3 r,out vec3 m) {\n \n    float t = 0.0;\n        \n    for(int i=0;i<ITER;i++) {\n            \n    \tm = o + r*t;\n        float d = map(m);\n        \n        if(d < EP) {\n            break;\n        }\n        else{\n        \tt+=d;\n            if(t>=ZMAX){break;}\n        }\n    }\n    \n    return t;\n}\n\n\n\nvec3 render(vec3 cameraPos, vec3 ray,vec3 lightPos) {\n    \n    vec3 pos;\n\tfloat t = march(cameraPos,ray,pos);\n    \n    if(t<ZMAX){\n    \n    \tvec3 normal = getNormal(pos);\n    \n    \tvec3 lightRay = normalize(pos-lightPos);\n    \tfloat diffuse = max(0.0, dot(normal,-lightRay));\n \n    \tvec3 reflectionDirection = reflect(lightRay, normal);\n    \tfloat spectral = pow(max(dot(reflectionDirection,-ray), 0.0), 10.0);\n    \n    \n    \tvec3 diff = vec3(1.0,0.0,0.0)*diffuse;\n    \tvec3 spec = vec3(1.0,1.0,1.0)*spectral;\n    \tvec3 ambi = vec3(0.4,0.0,0.0);\t\n        \n        float sshadow = softshadow(pos,lightPos);\n    \n        diff *=sshadow;\n        spec *=sshadow;\n        \n        \n        //makes things close appear brighter\n        float f = 1.0 / (1.0 + t*t*0.002);\n        \n    \treturn (diff+spec+ambi)*f;\n    }\n    else {\n        \n        //the background\n    \treturn vec3(.2,.2,.2);   \n    }\n}\n\nvec3 getRayDir(vec2 screenPos, vec3 origin, vec3 lookAt, vec3 up, float fov) {\n    \n    vec3 d = normalize(lookAt-origin);\n    vec3 rayRight = normalize(cross(d, up));\n    \n    return normalize(screenPos.x*rayRight + screenPos.y*up + \n                     1.0/tan(radians(fov/2.0)) * d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 cameraPos = vec3(0.0, 4.,30);\n\tvec3 cameraUp = vec3(0.0, 1.0, 0.0);\n\tvec3 cameraLookAt = vec3(0.0, -40, -180.0);\n    \n\tvec2 origin = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    vec3 lightPos = vec3(sin(iTime)*50., 30, cos(iTime)*70.);\n    vec3 ray = getRayDir(origin, cameraPos, cameraLookAt, cameraUp, 25.0);       \n    \n    fragColor = vec4(render(cameraPos,ray,lightPos),1.0);\n\n    \n\t\n}","name":"Image","description":"","type":"image"}]}