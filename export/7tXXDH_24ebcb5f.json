{"ver":"0.1","info":{"id":"7tXXDH","date":"1625657845","viewed":586,"name":"simplex_flames","username":"skaplun","description":"Yet another fire. Simplex-noise-based this time","likes":33,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","flame","fire","volumetric","simplex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float scene(vec3 p, float h, inout vec2 offset, bool calculateOffset){\n    float yFactor = p.y;\n    float time = iTime * 2.;\n    if(calculateOffset)\n        offset = vec2(fbm1x(yFactor, time), fbm1x(yFactor + 78.233, time))\n          \t   * smoothstep(-1., 2., yFactor);\n    p -= vec3(offset.x, h, offset.y);\n    return sdCone(p, vec2(.9, .33), 4.);\n}\n\nfloat inner(vec3 p, vec2 offset){\n   vec3 mp = p;\n   mp.xz -= offset;\n   \n   \n   mp *= 2.;\n   mp.y *= max(.25 - p.y, .4) * .5;\n   mp.y -= iTime * 2.5;\n   \n   vec4 sn = snoise(mp * rotateY(fbm1x(p.y, iTime * .75)));\n   float h = 1.;\n   return distance(sn.w, max(scene(p, h, offset, false), 0.) * 2.);\n}\n\n#define MAX_MARCHING_STEPS 128\nvec3 march(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    vec2 offset;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = scene(eye + depth * marchingDirection, 2., offset, true);\n        if (dist < MIN_FLOAT) {\n            return vec3(depth, offset);\n        }\n        depth += dist;\n        if (depth >= end) {\n            return vec3(end, 0., 0.);\n        }\n    }\n    return vec3(end, 0., 0.);\n}\n\nconst float MAX_DIST = 100.;\n#define CLR_BLUE vec3(0.000,0.082,0.702)\n#define CLR_PURPLE vec3(0.427,0.020,0.478)\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec3 color = vec3(0.);\n    float a = (iResolution.x - iMouse.x) * .05;\n    vec3 eye = vec3(8. * sin(a), 0., 8. * cos(a));\n    vec3 viewDir = rayDirection(45., iResolution.xy, fragCoord);\n    vec3 worldDir = viewMatrix(eye, vec3(0., .4, 0.), vec3(0., 1., 0.)) * viewDir;\n    float baseDist;\n    if(plane_hit(eye, worldDir, vec3(0., -1., 0.), vec3(0., -1., 0.), baseDist)){\n    \tvec3 p = eye + worldDir * baseDist;\n        float f = mod(floor(p.z) + floor(p.x), 2.);\n        color = f * vec3(.3) * smoothstep(8., 2., length(p));\n    }else{\n    \tbaseDist = MAX_FLOAT;\n    }\n    \n    Ray camRay = Ray(eye, worldDir);\n    HitRecord rec;\n\n    vec3 dist = march(camRay.origin, camRay.dir, 0., MAX_DIST);\n    if (dist.x < MAX_DIST - MIN_FLOAT && dist.x < baseDist) {\n        float t = dist.x;\n        for(int i=0; i<MAX_MARCHING_STEPS; i++)\t{\n            vec3 curSamplePoint = eye + worldDir * t;\n            color += mix(CLR_PURPLE, CLR_BLUE, smoothstep(0., .2 * (4. - curSamplePoint.y), length(curSamplePoint.xz)))  * smoothstep(.05, 0., inner(curSamplePoint, dist.yz)) * (1. + .5 * fbm1x(curSamplePoint.y, iTime * 20.));\n            t += .0066;\n        }\n    }\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MIN_FLOAT 1e-6\n#define MAX_FLOAT 1e6\n\nstruct Ray{ vec3 origin, dir;};\nstruct HitRecord{ float t; vec3 p;};\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nmat3 lookAt(in vec3 eye, in vec3 tar, in float r){\n    vec3 cw = normalize(tar - eye);// camera w\n    vec3 cp = vec3(sin(r), cos(r), 0.);// camera up\n    vec3 cu = normalize(cross(cw, cp));// camera u\n    vec3 cv = normalize(cross(cu, cw));// camera v\n    return mat3(cu, cv, cw);\n}\n\nbool plane_hit(in vec3 ro, in vec3 rd, in vec3 po, in vec3 pn, out float dist) {\n    float denom = dot(pn, rd);\n    if (denom > MIN_FLOAT) {\n        vec3 p0l0 = po - ro;\n        float t = dot(p0l0, pn) / denom;\n        if(t >= MIN_FLOAT && t < MAX_FLOAT){\n\t\t\tdist = t;\n            return true;\n        }\n    }\n    return false;\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nfloat sixth = 0.1666666666666667;\nfloat third = 0.3333333333333333;\n\nvec4 permute (vec4 v) { return mod((v * 34.0 + 1.0) * v, 289.0); }\nvec4 taylor (vec4 v) { return 1.79284291400159 - v * 0.85373472095314; }\n\nvec4 snoise(vec3 v) {\n\n    vec3 i  = floor(v + dot(v, vec3(third)));\n    vec3 p1 = v - i + dot(i, vec3(sixth));\n\n    vec3 g = step(p1.yzx, p1.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n\n    vec3 p2 = p1 - i1 + sixth;\n    vec3 p3 = p1 - i2 + third;\n    vec3 p4 = p1 - 0.5;\n    \n    vec4 ix = i.x + vec4(0.0, i1.x, i2.x, 1.0);\n    vec4 iy = i.y + vec4(0.0, i1.y, i2.y, 1.0);\n    vec4 iz = i.z + vec4(0.0, i1.z, i2.z, 1.0);\n\n    vec4 p = permute(permute(permute(iz)+iy)+ix);\n\n    vec4 r = mod(p, 49.0);\n\n    vec4 x_ = floor(r / 7.0);\n    vec4 y_ = floor(r - 7.0 * x_); \n\n    vec4 x = (x_ * 2.0 + 0.5) / 7.0 - 1.0;\n    vec4 y = (y_ * 2.0 + 0.5) / 7.0 - 1.0;\n\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n\n    vec4 s0 = floor(b0) * 2.0 + 1.0;\n    vec4 s1 = floor(b1) * 2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n    vec3 g1 = vec3(a0.xy, h.x);\n    vec3 g2 = vec3(a0.zw, h.y);\n    vec3 g3 = vec3(a1.xy, h.z);\n    vec3 g4 = vec3(a1.zw, h.w);\n\n    vec4 n = taylor(vec4(dot(g1,g1),dot(g2,g2),dot(g3,g3),dot(g4,g4)));    \n\n    vec3 n1 = g1 * n.x;\n    vec3 n2 = g2 * n.y;\n    vec3 n3 = g3 * n.z;\n    vec3 n4 = g4 * n.w;\n\n    vec4 m = vec4(dot(p1,p1),dot(p2,p2),dot(p3,p3),dot(p4,p4));\n    \n    vec4 m1 = max(0.6 - m, 0.0);\n    vec4 m2 = m1 * m1;\n    vec4 m3 = m2 * m1;\n    vec4 m4 = m2 * m2;\n    \n    vec3 q1 = -6.0 * m3.x * p1 * dot(p1, n1) + m4.x * n1;\n    vec3 q2 = -6.0 * m3.y * p2 * dot(p2, n2) + m4.y * n2;\n    vec3 q3 = -6.0 * m3.z * p3 * dot(p3, n3) + m4.z * n3;\n    vec3 q4 = -6.0 * m3.w * p4 * dot(p4, n4) + m4.w * n4;\n     \n    vec3 q = q1+q2+q3+q4;\n    \n    vec4 t = vec4(dot(p1,n1),dot(p2,n2),dot(p3,n3),dot(p4,n4));\n    \n    return (42.0 * vec4(q, dot(m4, t)));\n    \n}\n\nfloat fbm1x(float x, float time){\n\tfloat amplitude = 1.;\n    float frequency = 1.;\n    float y = sin(x * frequency);\n    float t = time * -2.;\n    y += sin(x*frequency*2.1 + t)*4.5;\n    y += sin(x*frequency*1.72 + t*1.121)*4.0;\n    y += sin(x*frequency*2.221 + t*0.437)*5.0;\n    y += sin(x*frequency*3.1122+ t*4.269)*2.5;\n    y *= amplitude * 0.06;\n    return y;\n}\n\nfloat sdCone(vec3 p, vec2 c, float h){\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\n\n\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k)\n{\n    return log(exp(k*a)+exp(k*b))/k;\n}","name":"Common","description":"","type":"common"}]}