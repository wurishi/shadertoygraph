{"ver":"0.1","info":{"id":"cs3BDs","date":"1697744327","viewed":33,"name":"Inf__","username":"3t13nn3","description":"Inf__","likes":1,"published":1,"flags":64,"usePreview":0,"tags":["inf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sdGRS","filepath":"https://soundcloud.com/d-tailsss/kylie","previewfilepath":"https://soundcloud.com/d-tailsss/kylie","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Facteur d'anti-aliasing. Mettez à 1 si cela fonctionne lentement.\n#define AntiAliasingFactor 1.0\n\n// Mettez à 1 pour ajouter des saignements de couleur.\n#define ColorBleeding 1\n\n#define Pi 3.141592\n\n// Structure pour stocker les propriétés d'un matériau\nstruct Material\n{\n    float depth; // Profondeur\n    vec3 color; // Couleur\n    vec3 bleeding; // Saignement de couleur\n    float ambientOcclusion; // Occlusion ambiante\n};\n\n// Fonction pour calculer la distance à un cube\nfloat cube(in vec3 point, in vec3 size, float rounding)\n{\n    point = abs(point) - (size - rounding);\n    return length(max(point, 0.)) - rounding;\n}\n\n// Fonction pour mapper une valeur\nfloat map(float i, float constant, float linear, float quadratic)\n{\n    // Fonction de mappage de distance\n    return 1. - 1. / (constant + linear * i + quadratic * i * i);\n}\n\n// Fonction pour fusionner deux matériaux\nMaterial UnionOperation(in Material a, in Material b)\n{\n    float maxDepth = max(a.depth, b.depth);\n    float ambientOcclusion = map(maxDepth, 1., 1.4, 7.2);\n    maxDepth = map(maxDepth, 1., .7, 1.8);\n    \n    return Material(\n        min(a.depth, b.depth),\n        a.depth < b.depth ? a.color : b.color,\n        a.bleeding * mix(a.depth > b.depth ? a.color : b.color, vec3(1.), maxDepth), // Calcul du saignement de couleur\n        a.ambientOcclusion * ambientOcclusion // Calcul de l'occlusion ambiante\n    );\n}\n\nMaterial scene(in vec3 point)\n{\n    vec3 translatedPoint = point;\n    vec3 baseLight = vec3(.25);\n    \n    Material plan = Material(cube(point - vec3(0., -101., 0.), vec3(100.), .0), vec3(1., 1., 1.), baseLight, 1.);\n    \n    // Apply transformations for object 1\n    translatedPoint = point;\n    \n    translatedPoint = fract(point) - 0.5;\n    //translatedPoint -= vec3(0, 1., -1.);\n    Material c = Material(cube(translatedPoint, vec3(.25), .125), vec3(0.318,0.608,0.384), baseLight, 1.);\n\n    // Combine objects using the Uop function\n    Material result = UnionOperation(plan, c);\n\n    return result;\n}\n\n\nvec3 computeNormal(in vec3 point)\n{\n    vec2 epsilon = vec2(.01, .0);\n    float depth = scene(point).depth;\n    vec3 normal = depth - vec3(scene(point - epsilon.xyy).depth, scene(point - epsilon.yxy).depth, scene(point - epsilon.yyx).depth);\n    return normalize(normal);\n}\n\n#define MAX_RAY_STEPS 255\n#define MIN_HIT_DISTANCE .01\n#define MAX_TRACE_DISTANCE 64.\n\n// Fonction qui effectue la marche du rayon\nMaterial rayMarch(in vec3 origin, in vec3 direction)\n{\n    float rayDistance = 0.0;\n    for (int step = 0; step < MAX_RAY_STEPS; step++)\n    {\n        Material hit = scene(origin + direction * rayDistance);\n        rayDistance += hit.depth;\n        if (hit.depth < MIN_HIT_DISTANCE)\n        \treturn Material(rayDistance, hit.color, hit.bleeding, hit.ambientOcclusion);\n        if (rayDistance > MAX_TRACE_DISTANCE)\n            break;\n    }\n    return Material(rayDistance, vec3(-1.), vec3(-1.), -1.);\n}\n\nvec3 computeCameraDirection(in vec2 screenCoordinates, in vec3 cameraPosition, in vec3 targetPosition)\n{\n    vec3 forward = normalize(cameraPosition - targetPosition);\n    vec3 right = normalize(cross(vec3(0., 1., 0.), forward));\n    vec3 up = cross(forward, right);\n    return right * screenCoordinates.x + up * screenCoordinates.y - forward;\n}\n\n\n#define background_color vec3(3., 3., 3.)  // Couleur du fond\n#define object_color vec3(1.5, 2.1, 3.)  // Couleur de l'objet\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screen_position = fragCoord;  // Position du fragment sur l'écran\n    vec3 final_color;  // Couleur finale du fragment\n\n    for (float sample_y = 0.; sample_y < AntiAliasingFactor; sample_y++)\n    {\n        for (float sample_x = 0.; sample_x < AntiAliasingFactor; sample_x++)\n        {\n            vec2 sample_offset = vec2(sample_x, sample_y) / AntiAliasingFactor - .5; // Offset pour l'échantillonnage\n            vec2 normalized_uv = (screen_position - sample_offset - iResolution.xy * .5) / iResolution.y; // Coordonnées normalisées\n\n            // Position de la caméra\n            //vec3 camera_position = vec3(sin(Pi * iTime * .1) * 2., 1., cos(Pi * iTime * .1) * 2.) * 6.;\n            vec3 camera_position = vec3(cos(iTime/10.)* 4., 4.8, -10. + iTime);\n            // Cible de la caméra\n            vec3 camera_target = vec3(cos(iTime) * 4., 4.8, + iTime);\n            // Direction de la caméra\n            vec3 camera_direction = computeCameraDirection(normalized_uv, camera_position, camera_target);\n\n            // Couleur de fond\n            vec3 background = mix(background_color, object_color, camera_direction.y * .5 + .5);\n\n            vec3 fragment_color = vec3(0.); // Couleur du fragment\n\n            Material object_material = rayMarch(camera_position, camera_direction); // Matériau de l'objet\n\n            // Si le rayon a touché (toutes les composantes ne sont pas -1)\n            if (object_material.ambientOcclusion >= 0.)\n            {\n                vec3 intersection_point = camera_position + camera_direction * object_material.depth;\n                vec3 surface_normal = computeNormal(intersection_point);\n\n                background = mix(background_color, object_color, surface_normal.y * .5 + .5) / Pi;\n                          \n                fragment_color += background;\n                ////\n                vec3 r = reflect(camera_direction, surface_normal);\n\n                float dif = dot(surface_normal, normalize(vec3(sin(iTime) * 8., 10.8, -10. + iTime))) * 0.5 + 0.5;\n                float spec = pow(max(dot(r, normalize(vec3(sin(iTime / 8.) * 50., 50. + abs(sin(iTime)) * 50., -10. + sin(iTime) * 10.))), 0.0), 20.) / 3.;\n\n                fragment_color = (fragment_color * dif + vec3(spec));\n                fragment_color *= object_material.color * object_material.ambientOcclusion * .5;\n                ////\n                \n                #if ColorBleeding\n                fragment_color *= object_material.bleeding;\n                #endif\n                \n            }\n            else\n            {\n                fragment_color = background / Pi;\n            }\n\n\n            final_color += fragment_color;\n        }\n    }\n\n    final_color /= AntiAliasingFactor * AntiAliasingFactor;\n\n    fragColor = vec4(sqrt(final_color), 1.);\n}\n","name":"Image","description":"","type":"image"}]}