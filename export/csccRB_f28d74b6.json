{"ver":"0.1","info":{"id":"csccRB","date":"1695161836","viewed":120,"name":"delicate stars","username":"OscarSaharoy","description":"My go at a star shader :)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["stars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define POLE_SENTINEL vec3(-1)\n#define UP vec3(0, 1, 0)\n#define PI 3.14159\n\nfloat saturate( float x ) {\n\treturn clamp( x, 0., 1. );\n}\n\nvec3 saturate( vec3 v ) {\n\treturn clamp( v, 0., 1. );\n}\n\nfloat hash11(float p) {\n\tp = 27.2772 * fract(p);\n\tp += 27.2772;\n\tp *= p;\n\treturn fract(p);\n}\n\nvec2 hash12(float p) {\n\tvec2 p2 = fract(vec2(p) * vec2(536.1031, 465.1030));\n\tp2 += dot(p2, p2.yx+33.33);\n\treturn fract((p2.xy+p2.yy)*p2.yx);\n}\n\n\n\nvec3 dirToCellUV( vec3 dir,\n\t\tfloat bandOffset, float cellOffset ) {\n\n\tfloat bandHeight = 0.08;\n\tfloat phi = acos( dot( UP, dir ) );\n\tfloat band = floor( phi / bandHeight ) \n\t\t       * bandHeight + bandOffset * bandHeight;\n\n\tfloat areaMiddle = bandHeight * bandHeight;\n\tfloat topHeight = cos( band );\n\tfloat bottomHeight = cos( band + bandHeight );\n\tfloat bandArea = 2. * PI \n\t\t\t\t   * ( topHeight - bottomHeight );\n\tfloat divisions = floor( bandArea / areaMiddle );\n\n\tfloat theta = atan( -dir.x, -dir.z ) + PI;\n\tfloat cellLength = 2. * PI / divisions;\n\tfloat cell = floor( theta / cellLength ) \n\t\t\t   * cellLength + cellOffset * cellLength;\n\n\tvec3 cellCoords = vec3(band, cell, 0.); \n\n\tif( band < 1.5 * bandHeight || band > PI - 2.5 * bandHeight  )\n\t\treturn POLE_SENTINEL;\n\n\tfloat phic = (phi - band) / bandHeight;\n\tfloat thetac = (theta - cell) / cellLength;\n\n\tif(cellOffset < 0. && theta < cellLength)\n\t\tcell += divisions * cellLength;\n    if(cellOffset > 0. && theta > 2.*PI - cellLength)\n\t\tcell -= divisions * cellLength;\n\n\tvec3 celluv = vec3(\n\t\tphic - .5,\n\t\tthetac - .5,\n\t\thash11( hash11(band) + cell )\n\t);\n\n\treturn celluv;\n}\n\nvec3 starFunction( vec3 celluv ) {\n\n\tvec2 jitter = hash12(celluv.z) * 3. - 1.5;\n\tfloat scale = 0.00002 * ( 1. - pow( length(jitter) / 2.12, 0.06 ) ) * pow(celluv.z, 5.);\n\tfloat r = length(celluv.xy + jitter);\n\n\treturn saturate(\n\t\tvec3( scale / pow(r, 1.8) - 0.00 ) / 0.2\n\t);\n}\n\nvec3 starLight( vec3 viewDir ) {\n\n    vec3 light = vec3(0);\n\n\tfor( float bo=-1.; bo<1.1; ++bo)\n\tfor( float co=-1.; co<1.1; ++co) {\n\n\t\tvec3 celluv = dirToCellUV( \n\t\t\tviewDir, bo, co );\n\n\t\tif( celluv == POLE_SENTINEL )\n\t\t\tcontinue;\n\n\t\tlight += starFunction( celluv );\n\t}\n\n    return light * vec3(1, 1, 1) * 10.;\n}\n\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec3 light = vec3(0);\n\n    vec2 p = ( fragCoord - iResolution.xy * .5 )\n            / min(iResolution.x, iResolution.y) * 2.;\n    vec3 rd = normalize(vec3( p.x, p.y, -2. ));\n    rd = ( rotationMatrix( vec3(1), iTime/25. ) * vec4(rd, 1.0) ).xyz;\n\n    light += starLight(rd);\n    \n\t// gamma correction\n    light = pow(light , vec3(1. / 2.2));\n\n    fragColor = vec4(light,1.0);\n}","name":"Image","description":"","type":"image"}]}