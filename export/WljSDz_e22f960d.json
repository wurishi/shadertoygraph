{"ver":"0.1","info":{"id":"WljSDz","date":"1565624363","viewed":111,"name":"PowerCube001","username":"Hirai_worthless","description":"coloring & lighting are difficult.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265;\n//use for differential\nconst float EPS = 0.001;\n\n\nstruct traceData{\n\tvec3 normal;\n    float t;\n    float nearestt;\n    float nearestd;\n    int objectId;\n};\n//common function\nmat2 genRot(float val){\n\treturn mat2(cos(val), -sin(val),\n               sin(val), cos(val));\n}\n\nfloat rand (float x){\n    x = fract(sin(x*416.31434));\n    x = fract(sin(x*234.41523));\n    x = fract(sin(x*235.51424));\n\treturn x;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nvec3 pmod(vec3 p,float c){\n    float tmp = PI * 2. / c;\n\tfloat l = length(p.xy);\n    float theta = atan(p.y/p.x);\n    theta = mod(theta,PI * 2. / c);\n    return vec3(l * cos(theta), l * sin(theta),p.z);\n    \n}\n\n\n//Common SDF\n\nfloat sphere(vec3 p,vec3 o,float r){\n\treturn length(p - o) - r;\n}\n\nfloat cylinder(vec2 p,vec2 o,float r){\n\treturn length(p - o) - r;\n}\n\nfloat cube(vec3 p,vec3 o,vec3 s){\n    float x = abs(p.x - o.x) - s.x/2.;\n    float y = abs(p.y - o.y) - s.y/2.;\n    float z = abs(p.z - o.z) - s.z/2.;\n    return max(x,max(y,z));\n}\n\nfloat line(vec3 p,vec3 q1,vec3 q2,float r){\n\tfloat t = clamp(\n    \tdot(q2 - p,q2 -q1)/dot(q2-q1,q2-q1),\n    \t0.,\n        1.\n    );\n    vec3 q = t * q1 + (1. - t) * q2;\n    return length(q - p) - r;\n}\n\n\n//Gathering SDF\nfloat cubeSize = 1.5;\nfloat fractSize = 4.;\nfloat map(vec3 p){\n    p = (fract(p / fractSize + 0.5)-0.5) * fractSize;\n\tfloat biggerC = cube(p,vec3(0.),vec3(cubeSize));\n    float smallerBelt = max(0.1 - abs(p.x),\n                            max(0.1 - abs(p.y),\n                               0.1 - abs(p.z)));\n    float smallerCube = cube(p,vec3(0.),vec3(cubeSize - 0.3));\n    float result = max(biggerC,smallerBelt);\n    result = min(result,smallerCube);\n    return result;\n}\n\n//Getting Normal\n\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(EPS, 0.0, 0.0)) - map(p + vec3(-EPS,  0.0,  0.0)),\n        map(p + vec3(0.0, EPS, 0.0)) - map(p + vec3( 0.0, -EPS,  0.0)),\n        map(p + vec3(0.0, 0.0, EPS)) - map(p + vec3( 0.0,  0.0, -EPS))\n    ));\n}\n\n//Setting CameraPos\nvec3 Camera(float t){\n    vec3 c =vec3(0.,0.,-2.0);\n\tc += vec3(1.5,1.5,iTime * 2.);\n    return c;\n}\n\n//Setting Ray\nvec3 Ray(vec2 uv, float z){\n\tvec3 ray = normalize(vec3(uv,z));\n    ray.xy *= genRot(iTime/4.);\n    ray.xz *= genRot(iTime/4.);\n    return ray;\n}\n\n//Tracing Ray\n\ntraceData trace (vec3 o, vec3 r){\n    traceData result;\n\tfloat t = 0.0;\n    float nearestd = 100000000.0;\n    float nearestt = 1000000.0;\n    vec3 p = vec3(0.0,0.0,0.0);\n    \n    for(int i = 0; i < 256; ++i){\n        p = o + r * t;\n        float d = map(p);\n        nearestt = d < nearestd ? t + d * 0.15 : nearestt;\n        nearestd = min(nearestd,d);\n        t += d * 0.15;\n    }\n    result.normal = getNormal(p);\n    result.nearestd = nearestd;\n    result.nearestt = nearestt;\n    result.t = t;\n    return result;\n}\n\n//Making color\nvec3 getColor(vec3 o,vec3 r,traceData data){\n    float t = data.t;\n    float Nt = data.nearestt;\n    float Nd = data.nearestd;\n    bool isLight = Nd < 1. \n        && abs(Nt - t) > 0.001\n        ;\n    float fog = 1.0 / (1.0 + t * t * 0.025);\n    float a = dot(data.normal,r);\n    vec3 p = o + r * t;\n    vec3 Np = o + r * Nt;\n\tvec3 q = (fract(p / fractSize + 0.5)-0.5) * fractSize;\n\tfloat at = atan(r.y/r.x)/PI + 0.5;\n    vec3 ccol = vec3(sin(at * PI + iTime), 1. - sin(at * PI + iTime),sin(p.z -iTime) + 0.1);\n    vec3 Nccol = vec3(sin(at * PI + iTime), 1. - sin(at * PI + iTime),sin(Np.z -iTime) + 0.1);\n    vec3 fc = vec3(0.05);\n    \n    fc = mix(fc,vec3(1.),1. + a*1.5);\n        Nccol = mix(Nccol,vec3(0.0) ,smoothstep(-0.25,0.75,sin(Np.z * 0.05 * PI + iTime * 2.)));\n    \tfc += isLight ? Nccol/(Nd * Nd) : vec3(0.);\n    fc = mix(vec3(0.05),fc,fog);\n    ccol = mix(ccol,vec3(0.0) ,smoothstep(-0.25,0.75,sin(p.z * 0.05 * PI + iTime * 2.)));\n\n    \n    fc += max(abs(q.x),max(abs(q.y),abs(q.z))) < cubeSize/2. - 0.1\n        ? ccol * 1.5 : vec3(0.);\n    \n    //fc = vec3(fog);\n    return fc;\n}\n\n//Drawing\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //set canvas\n    vec2 uv = fragCoord.xy /iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //set camera and ray\n    vec3 r = Ray(uv,1.2);\n    vec3 o = Camera(iTime);\n    \n    //trace ray\n    traceData data = trace(o,r);\n    vec3 fc = getColor(o,r,data) ;\n\t//fc = vec3(fog);\n    // Output to screen\n    fragColor = vec4(fc,1.0);\n}","name":"Image","description":"","type":"image"}]}