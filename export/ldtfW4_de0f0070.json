{"ver":"0.1","info":{"id":"ldtfW4","date":"1525212202","viewed":441,"name":"Extrapolating SDF","username":"mv","description":"Middle: true signed distance\nLower left: cast ray towards center of box, add distance to box and sample\nLower right: distance to circle-circle intersection\nUpper left: distance to bounding box + distance at box\nUpper right: distance to projection at box\n\n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sdf","extrapolation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tWhen you have a voxelized signed distance field of some mesh you might want to extend \n    the distance field outside the bounding box of your voxels. This shader explores this\n\tconcept for pixels instead of voxels, but the techniques are analogous.\n\n\tThe main idea is to project your sample point onto the bounding box of the voxel set\n    then use the information at that point to approximate the distance at the sample point.\n\n\tA big problem comes when there is a cusp in the distance field. This is the points where\n    the distance from two different parts of a mesh is exactly the same. When you extrapolate\n\tyou do not know at which side of any cusps your sample points are, resulting in a \n\tdiscontinuous distance field outside the bounding box.\n\n\tOne idea [lower right] is to use the gradient at the intersection with the bounding box to extrapolate \n\tthe point on the surface of mesh, and use the distance to that point as the distance \n\tapproximation. This works very well except for when there is a cusp. \n\n\tAnother idea [upper right] is to find the intersection between two circles that are close by and next\n\tto the bounding box, then use the distance from the intersection point to the sample point\n\tas your approximation. This also has problems for cusps, but works excellently otherwise.\n\n\tA third and simpler idea [upper left] is to simply take the distance from the sample point to\n\tthe bounding box and add it to the distance at the bounding box. This creates a \n\tcontinuous distance field and works alright with cusps, but is far less accurate the\n\tfurther out you go. Perhaps another distance norm would work better than the\n\tEuclidian?\n\n\tA fourth idea [lower left] is to cast a ray towards the center of the bounding box\n\tand find the intersection of the ray and the bounding box, then add the distance to the \n\tbox intersection and the distance at the intersection. \n\n\t\n\tAre there better options? The discontinuities seems like a no-go, so the third or fourth approach \n\tseems like the best option right now. If one could predict/estimate the cusps, then\n\tI imagine that any of the first two solutions would be a lot better. \n\n\n\tSee https://kosmonautblog.wordpress.com/2017/05/09/signed-distance-field-rendering-journey-pt-2/ \n\tfor some discussions of these techniques. \n*/\n\n\n#define BOX_DIMENSIONS vec2(2.0, 1.2)\n\nfloat sdDisk(vec2 p, vec2 c, float r) {\n \treturn length(p - c) - r;   \n}\n\nfloat sdRect( vec2 p, vec2 b ) {\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdFunc(vec2 p) {     \n    float d1 = sdDisk(p, vec2(0.0, 0.5), 0.2);\n    float d2 = sdDisk(p, vec2(0.0, -0.5), 0.2);\n    float d3 = sdDisk(p, vec2(1.5, 0.0), 0.1);\n    float d4 = sdDisk(p, vec2(-1.5, 0.0), 0.1);\n    return min(min(d1,d2), min(d3, d4));\n\n}\n\nvec2 gradient(vec2 p) {\n    float eps = 1.0e-3;\n    float s = sdFunc(p);\n \treturn vec2(sdFunc(p+vec2(eps, 0.0)) - s, sdFunc(p+vec2(0.0, eps)) - s);\n}\n\nvec3 get_color(float sd) {\n    float w = 2.5*fwidth(sd);\n\tfloat s = smoothstep(-w, w, 1.0/8.0*sin(8.0*3.1416*sd));\n    return vec3(s);\n}\n\nfloat lower_left(vec2 uv) {\n    // Suggested by Quinchilion\n    // Finds the intersection with the box along a ray towards its center\n    // Returns distance at this intersection + distance to it\n    vec2 ray_orig = uv;\n    vec2 ray_dir = normalize(-uv);\n    \n    vec2 minx = (-BOX_DIMENSIONS - ray_orig) / ray_dir;\n    vec2 maxx = (BOX_DIMENSIONS - ray_orig) / ray_dir;\n    float t = max(min(minx.x, maxx.x), min(minx.y, maxx.y));\n    vec2 sample_uv = ray_orig + ray_dir * t;\n    \n    float sd_inter = sdFunc(sample_uv);\n    \n    return sd_inter + t; \n}\n\nfloat lower_right(vec2 uv) {\n    // gradient projection\n    vec2 uv_clamped = clamp(uv, -BOX_DIMENSIONS, BOX_DIMENSIONS);\n    float sd_clamped = sdFunc(uv_clamped);\n    vec2 grad_clamped = gradient(uv_clamped);\n    \n    return  length(uv - (uv_clamped - normalize(grad_clamped)*sd_clamped));\n}\n\nfloat upper_left(vec2 uv) {\n    // distance to bounding box + distance at bounding box\n    vec2 uv_clamped = clamp(uv, -BOX_DIMENSIONS, BOX_DIMENSIONS);\n\tfloat sd_clamped = sdFunc(uv_clamped);\n    \n    //return sd_clamped + abs(uv.x - uv_clamped.x) + abs(uv.y - uv_clamped.y);\n    return sd_clamped + length(uv - uv_clamped);\n}\n\nfloat upper_right(vec2 uv) {\n    // circle-circle intersection. \n    vec2 uv_clamped = clamp(uv, -BOX_DIMENSIONS, BOX_DIMENSIONS);\n    \n    vec2 p0 = uv_clamped;\n    vec2 p1 = uv_clamped + 0.001*normalize(uv_clamped - uv);\n\n    float r0 = sdFunc(p0);\n    float r1 = sdFunc(p1);\n\n    float d = length(p1 - p0);\n\n    float a = (r0*r0 - r1*r1 + d*d)/(2.0*d);\n\n    vec2 p2 = p0 + (a/d)*(p1 - p0);\n\n    float h = sqrt(max(r0*r0 - a*a, 0.0));\n    vec2 p3 = p2 + (h/d)*vec2(p1.y - p0.y, p0.x - p1.x);\n\n    return length(p3 - uv);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord.xy - iResolution.xy)/iResolution.yy;\n    uv *= 3.0;\n           \n    if (sdRect(uv, BOX_DIMENSIONS) < 0.0) {\n        // inside bounding box, show true distance\n        fragColor = vec4(get_color(sdFunc(uv)), 1.0);\n    } else {\n        // outside bounding box, use different techniques based on quadrant\n        \n        if (uv.y < 0.0) {\n        \tif (uv.x < 0.0) {\n                fragColor = vec4(get_color(lower_left(uv)), 1.0);\n            } else {\n                fragColor = vec4(get_color(lower_right(uv)), 1.0);\n            }\n        } else {\n            if (uv.x < 0.0) {\n                fragColor = vec4(get_color(upper_left(uv)), 1.0);\n            } else {\n                fragColor = vec4(get_color(upper_right(uv)), 1.0);\n            }\n        }\n        \n        // separators\n        if (abs(uv.x) < 0.01) {\n         \tfragColor.xyz = vec3(1.0, 0.0 ,0.0);   \n        }\n        if (abs(uv.y) < 0.01) {\n         \tfragColor.xyz = vec3(1.0, 0.0 ,0.0);   \n        }\n    }\n    \n    // outline bounding box\n    if (abs(sdRect(uv, BOX_DIMENSIONS)) < 0.01) {\n        fragColor.xyz = vec3(1.0, 0.0, 0.0);\n    } \n    \n    // highlight inside of objects\n    if (sdFunc(uv) < 0.0) {\n        fragColor.xyz = vec3(0.5);\n    }\n}","name":"Image","description":"","type":"image"}]}