{"ver":"0.1","info":{"id":"MccSRM","date":"1714307162","viewed":143,"name":"Endless Glow","username":"Hyeve","description":"this is not what i intended to make when i started this shader but oh well lol","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarching","space","glow","stars","planets"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 CHROMA_OFFSET = vec4(0.0);\n\nvec4 read(vec2 uv) {\n    float r = texture(iChannel0, uv + CHROMA_OFFSET.xy).x;\n    float g = texture(iChannel0, uv).y;\n    float b = texture(iChannel0, uv + CHROMA_OFFSET.zw).z;\n    return vec4(r, g, b, 1.0);\n}\n\nvec4 fxaa(vec2 frag) {\n    //Manually minified FXAA antialiasing\n    \n    const float CONTRAST_THRESHOLD = 0.05;\n    const float RELATIVE_CONTRAST_THRESHOLD = 0.5;\n    const float OFFSETS[10] = float[10]( 1., 1., 1., 1.5, 2., 2., 2., 3., 4., 5. );\n    \n    #define re(x) read((x)/iResolution.xy)\n    #define lu(x) (x.r*.2126+x.g*.7152+x.b*.0722)\n    #define rl(x) lu(re((x)))\n    #define r(x, y) rl(frag+vec2(x,y))\n    \n    float M = r(0,0),N =r(0,1),NE=r(1,1),E =r(1,0),SE=r(1,-1),S =r(0,-1),SW=r(-1,-1),W =r(-1,0),NW=r(-1,1),\n    LC=min(N,min(E,min(S,min(W,M)))),HC=max(N, max(E, max(S, max(W, M)))),CT=HC-LC;\n    if(CT<max(CONTRAST_THRESHOLD,RELATIVE_CONTRAST_THRESHOLD*HC)) return re(frag);\n    \n    float LA = smoothstep(0.,1.,clamp(0.,1., abs((2.*(N+E+S+W)+NE+NW+SE+SW)*(1./12.)-M)/CT));\n\tbool IH = abs(N+S-2.*M)*2.+abs(NE+SE-2.*E)+abs(NW+SW-2.*W)>abs(E+W-2.*M)*2.+abs(NE+NW-2.*N)+abs(SE+SW-2.*S);\n    \n    float PL=IH?N:E,NL=IH?S:W,PG=abs(PL-M),NG=abs(NL-M),DR=1.,GR,OL;\n\n    OL=PL;GR=PG;\n\tif (PG<NG) {DR=-1.0;OL=NL;GR=NG;}\n\n    vec2 EF=frag,ES=vec2(0,1);EF.x+=.5*DR;\n    if(IH){EF.y+=.5*DR;ES=vec2(1,0);}\n    \n    float EL=(M+OL)*.5,GT=GR*.25;\n\tvec2 PF=EF+ES,NF=EF-ES,FO=vec2(0.);\n\tfloat PLD=rl(PF)-EL,NLD=rl(NF)-EL;\n\tbool PE=abs(PLD)>=GT,NED=abs(NLD)>=GT;\n    int i;\n    for(i=0;i<10&&!PE;i++){PF+=ES*OFFSETS[i];PLD=rl(PF)-EL;PE=abs(PLD)>=GT;}\n    for(i=0;i<10&&!NED;i++){NF-=ES*OFFSETS[i];NLD=rl(NF)-EL;NED=abs(NLD)>=GT;}\n    \n    float PD=PF.y-frag.y,ND=frag.y-NF.y,MD,EB=0.,BL;\n\tif(IH){PD=PF.x-frag.x;ND=frag.x-NF.x;}\n    MD=min(PD,ND);\n    bool DS=PD<=ND?PLD>=0.:NLD>=0.;\n\tif(DS!=(M-EL>=0.))EB=0.5-MD/(PD+ND);\n    BL=max(LA*LA,EB)*DR;\n\n\tif(IH)FO.y+=BL;\n\telse FO.x+=BL;\n    \n    return re(frag+FO);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    CHROMA_OFFSET = vec4(-1, -1, -1, 1) * length((fragCoord - 0.5 * iResolution.xy) / iResolution.y) * 0.005;\n    fragColor = fxaa(fragCoord);\n    //fragColor = read(fragCoord / iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float TIME; //Global time, usually modulo'd to loop ever few minutes\nbool LIGHTING_PASS = false; //True while doing lighting effects\n\n//--------- GENERAL CONSTANTS ---------\nconst float FPS_MULTIPLIER = 1.0; //Decrease this if you need the performance\nconst float SPEED_MULTIPLIER = 1.0; //Mess with how fast the shader time runs!\n                                    \nconst float MAX_SCENE_DEPTH = 128.; //Minor performance impact\nconst int MAX_SCENE_STEPS = 256; //Medium performance impact\nconst int MAX_SURFACES = 20; //Major performance impact with transparent/reflective surfaces\nconst float MAX_SHADOW_DIST = 64.; //Minor performance impact if shadows are used\nconst int MAX_SHADOW_STEPS = 64; //Medium performance impact if shadows are used\nconst float HIT_DIST = 1e-4; //Minor-Medium performace impact (dependent on geometry)\n\nconst float OFFSET_DIST = HIT_DIST * 2.; //For transparent object surfaces and normal calculations\nconst float SKIP_DIST = OFFSET_DIST * 3.; //For rays passing through transparent surfaces\n\nconst float VIGNETTE_STRENGTH = 0.1;\nconst float VIGNETTE_POWER = 5.;\n\nconst float GAMMA = 1.5;\n//--------- ----------------- ---------\n\n\n\n//--------- LIGHTING PARAMATERS ---------\nvec3 LIGHT_POS = vec3(0, 0, -500);\nvec3 LIGHT_COLOR = vec3(1.0, 1.0, 1.0);\nfloat LIGHT_BRIGHTNESS = 1.0;\n\nvec3 AMBIENT_COLOR = vec3(1.0, 1.0, 1.0);\nfloat AMBIENT_BRIGHTNESS = 0.;\n\nfloat FOG_ONSET = 100.;\nfloat FOG_SMOOTH = 28.;\nfloat FOG_POWER = 1.8;\n\nfloat AO_DIST = 12.;\nfloat AO_POWER = 0.;\n\nfloat SHADOW_SOFTNESS = 0.05;\nfloat SHADOW_STRENGTH = 0.0;\n\nfloat SUBSURF_DIST = 4.;\nfloat SUBSURF_BRIGHTNESS = 0.8;\n\nfloat UMBRA_POINT = 0.1;\nfloat UMBRA_CONTRAST = 0.7;\n\nint SURFACE_SKIPS = 1; //Skips rendering surfaces after passing into a transparent object - fakes backface culling.\n//--------- --------- --------- ---------\n\n\n\n//--------- MISC PARAMETERS ---------\nvec4 TONEMAP_VALUES = vec4(0.8, 1., 0.6, 999.); //Contrast, brightness, lift, quantization steps.\nvec4 TONEMAP_HUESAT = vec4(1.5, 0.5, 1.2, 1.5); //Controls hue and sat shifting based on brightness.\n\nvec3 GLOW = vec3(0.); //For raymarching-accumulated fake glow.\n//--------- --------------- ---------\n\n\n\n//--------- SURFACE PARAMATERS ---------\nvec3 COLOR = vec3(1.,0.8,0.5);\nfloat GLOSS = 1.;\nfloat SPECULAR = 1.;\nfloat OPACITY = 1.0; //Opacity must be < 1 for refraction or reflection to have any effect.\nfloat REFRACTION = 1.05; //Refraction < 0 results in reflection instead.\nfloat BACKGROUND_REFLECTION = 0.2; //Blurry reflections of background only\nvec3 NORMAL_ROTATIONS = vec3(0.0); //Normal mapping effect\nfloat MATERIAL_ID = -1.0;\n//--------- ------------------ ---------\n\n\n\n\n//--------- SCENE CONTROL FUNCTIONS ---------\nfloat scene(vec3 pos)\n{\t\n    vec3 starfield = pos + vec3(2.5, 2.5, TIME * 15.);\n    starfield.yx *= angle(starfield.z * 0.03 + TIME * 0.05);\n    vec3 id = quantize(starfield + 2.5, 5.);\n    float idh = hash(id.x + id.y * 1.1 + id.z * 1.2);\n    starfield = repeat_inf(starfield, vec3(5.));\n    float size = idh > 0.99 ? 0.3 : 0.;\n    float scene_dist = length(starfield) - size;\n    \n    vec3 ppos1 = pos - vec3(80., 35., 100.);\n    ppos1 = rotate(ppos1, vec3(TIME * 0.05));\n    float planet = length(ppos1) - 40.;\n    \n    vec3 ppos2 = pos - vec3(-80., -35., 90.);\n    ppos2 = rotate(ppos2, vec3(-TIME * 0.05 + 10.));\n    float planet2 = length(ppos2) - 30.;\n    \n    float planets = min(planet, planet2);\n    \n    vec3 ppos = planet < planet2 ? ppos1 : ppos2;\n    \n    scene_dist = min(scene_dist, planet);\n    scene_dist = min(scene_dist, planet2);\n    \n    \n    if(!LIGHTING_PASS) {\n        bool planet = abs(scene_dist - planets) < 0.05;\n        MATERIAL_ID = planet ? 0. : 1.;\n        if(!planet) {\n            AMBIENT_BRIGHTNESS = 2.;\n            COLOR = vec3(1.);\n            GLOW += exp(-scene_dist * 5.) * vec3(normalize(pos * pos) * 0.1 + 0.1);\n        }\n        AMBIENT_BRIGHTNESS = 0.;\n        COLOR = vec3(0.1);\n        NORMAL_ROTATIONS = vec3(noise(ppos.x + sin(ppos.y * 0.1) * 0.1) );\n    }\n    \n   \n    \n    \n    \n    if(OPACITY < 1.) scene_dist = abs(scene_dist) - OFFSET_DIST;\n\n\treturn scene_dist;\n}\n\nvec4 foreground(vec2 uv, vec3 scene_col) {\n\n    float border = step(0., 0.05-abs(abs(uv.y+sin(uv.x*3.+TIME)*0.01)-0.53));\n    border += step(0., 0.05-abs(abs(uv.x+sin(uv.y*3.+TIME)*0.01)-0.9));\n    \n    float swirl = pow(abs(uv * angle(length(uv*8.)+TIME)).x*1.2, 5.);\n\n\n    float result = min(border + swirl, 1.);\n\n    return vec4(scene_col + result, 1.);\n}\n\nvec3 background(vec3 dir, float blur) {\n    dir = rotate(dir, vec3(TIME * 0.05));\n    float mx = dir.x*0.5+0.5;\n    float my = length(cos(dir.xy*vec2(5.1,4.9))*0.5);\n    float mz = dir.y * 0.5 + 0.5;\n    vec3 colA = bezier(vec3(0.502,0.000,0.502), vec3(0.5, 0.3, 1.0), vec3(0.2, 0.7, 1.0), vec3(0.), mx);\n    vec3 colB = bezier(vec3(0., 0.2, 0.2), vec3(0.2, 0., 0.2), vec3(0.2, 0., 0.), my);\n    vec3 col = mix(colA,colB,0.35);\n    return bezier(0.5*colB, 1.0*col*col, 1.5*col, mz);\n}\n\nvec3 camera_path() {\n    return vec3(0, 0, -20);\n}\n\nvec3 camera_look(vec2 uv) {\n    return normalize(vec3(uv, 1));\n}\n\nvec2 uv(vec2 frag, vec2 res) {\n    return centered_uv(frag, res);\n}\n//--------- ----------------------- ---------\n\n\n\n\n//--------- RENDERING FUNCTIONS ---------\nvec2 raymarch(vec3 ray_origin, vec3 ray_dir, float surf_dist, float max_dist, int max_steps) {\n    float current_dist = 0.;\n    float min_dist = max_dist;\n    \n    for(int i = 0; i < max_steps; i++) {\n        float scene_dist = scene(ray_origin + ray_dir * current_dist);\n        current_dist += scene_dist;\n\n        if(scene_dist < min_dist && current_dist < max_dist) min_dist = scene_dist;\n        if(scene_dist < surf_dist || scene_dist > max_dist) break;\n    }\n\n    return vec2(current_dist, min_dist);\n}\n\n\nvec3 light_semirealistic(vec3 hit_pos, vec3 normal, vec3 mapped_normal, vec3 ray_dir) {\n    vec3 light_dir = normalize(LIGHT_POS - hit_pos);\n    vec3 reflection_dir = reflect(ray_dir, mapped_normal);\n\n    float diffuse = dot(mapped_normal, light_dir);\n    if(diffuse > 0.) diffuse = UMBRA_POINT + pow(diffuse, 1.0 - UMBRA_CONTRAST) * (1. - UMBRA_POINT);\n    else diffuse = UMBRA_POINT - pow(abs(diffuse), 1.0 + UMBRA_CONTRAST) * UMBRA_POINT;\n    diffuse = max(diffuse * LIGHT_BRIGHTNESS, AMBIENT_BRIGHTNESS);\n    \n    vec3 diffuse_color = COLOR;\n    vec3 light_color = mix(AMBIENT_COLOR, LIGHT_COLOR, diffuse);\n   \n    float reflected_diffuse = dot(reflection_dir, light_dir) * 0.5 + 0.5;\n    diffuse += pow(reflected_diffuse,  1.0 + SPECULAR * 50.) * SPECULAR; \n\n    vec3 background_reflection = background(reflection_dir, 1.0 - BACKGROUND_REFLECTION);\n    diffuse_color = mix(diffuse_color, background_reflection * COLOR, BACKGROUND_REFLECTION);\n    \n    float glossiness = (dot(ray_dir, mapped_normal) * 0.5 + 0.5) * GLOSS;\n    vec3 gloss_color = background(reflection_dir, 1.0 - glossiness) * 2.0;\n    diffuse_color = mix(diffuse_color, gloss_color, glossiness);\n    \n    //does not work (properly) on transparent objects\n    if(SUBSURF_BRIGHTNESS > 0.) {\n        float subsurf_level = pow(max(scene(hit_pos + light_dir * SUBSURF_DIST) / SUBSURF_DIST, 0.), 1.5);\n        diffuse = max(diffuse, subsurf_level * SUBSURF_BRIGHTNESS);\n    }\n\n    if(AO_POWER > 0.) {\n        float occlusion = raymarch(hit_pos + normal * 0.005, normal, 1e-3, AO_DIST, 12).x;            \n        diffuse *= pow(clamp(occlusion / AO_DIST, 1e-5, 1.), AO_POWER);\n    }\n\n    if(SHADOW_STRENGTH > 0.) {\n       float min_dist = raymarch(hit_pos + normal * SHADOW_SOFTNESS, light_dir, 1e-3, MAX_SHADOW_DIST, MAX_SHADOW_STEPS).y;\n       float occlusion = clamp(min_dist / SHADOW_SOFTNESS, 0.0, 1.);\n       diffuse *= occlusion * SHADOW_STRENGTH + (1.0 - SHADOW_STRENGTH);\n    }\n    \n    return recolor(diffuse_color, diffuse, light_color, TONEMAP_HUESAT, TONEMAP_VALUES);\n}\nvec4 calc_lighting(vec3 hit_pos, vec3 normal, vec3 mapped_normal, vec3 ray_dir, float total_dist)\n{\n    vec3 background_col = background(ray_dir, 0.0);\n    \n    if(total_dist > MAX_SCENE_DEPTH) {\n        vec3 result = background_col + GLOW;\n        result *= max(max(result.r, max(result.g, result.b)), 1.);\n        return vec4(result, 1.);\n    }\n    \n    vec3 result = light_semirealistic(hit_pos, normal, mapped_normal, ray_dir);\n  \n    result += GLOW;\n    result *= max(max(result.r, max(result.g, result.b)), 1.);\n    \n    float fog = pow(min(max(total_dist - FOG_ONSET, 0.0) * (1.0 / FOG_SMOOTH), 1.0), FOG_POWER);\n    result = mix(result, background_col, fog); \n    \n    return vec4(result, OPACITY);\n}\n\nvec3 calc_normal(vec3 pos) {\n    mat3 k = mat3(pos, pos, pos) - mat3(OFFSET_DIST);\n    return normalize(scene(pos) - vec3(scene(k[0]), scene(k[1]), scene(k[2])));\n}\n\nvec4 render(vec2 frag, vec2 res, float real_time)\n{\n    TIME = mod(real_time, 100.);\n    \n    vec2 uv = uv(frag, res);\n    vec3 ray_origin = camera_path();\n    vec3 ray_dir = camera_look(uv);\n    \n    int skip_count = 0;\n    float total_dist = 0.;\n    vec4 final_color = vec4(0);\n    \n    vec3 first_surface_normal = vec3(0, 0, 1);\n    float first_surface_depth = 1000.;\n    float first_surface_id = -1.0;\n    \n    for(int i = 0; i < MAX_SURFACES; i++)\n    {\n        float dist = raymarch(ray_origin, ray_dir, HIT_DIST, MAX_SCENE_DEPTH, MAX_SCENE_STEPS).x;\n        vec3 hit_pos = ray_origin + ray_dir * dist;\n        total_dist += dist;\n \n        \n        vec3 normal = calc_normal(hit_pos);\n        \n        if(i == 0 && total_dist < MAX_SCENE_DEPTH) {\n            first_surface_depth = total_dist;\n            first_surface_normal = normal;\n            first_surface_id = MATERIAL_ID;\n        }\n        \n        vec3 mapped_normal = rotate(normal, NORMAL_ROTATIONS);\n        mapped_normal = dot(mapped_normal, -ray_dir) > 0. ? mapped_normal : reflect(mapped_normal, ray_dir);\n        \n        \n        float refraction = i % 2 == 0 ? 1. / REFRACTION : REFRACTION;\n        vec3 new_ray = refract(ray_dir, mapped_normal, refraction);\n        if(REFRACTION < 0. || length(new_ray) == 0.) new_ray = reflect(ray_dir, mapped_normal);\n       \n        LIGHTING_PASS = true;\n        vec4 color = calc_lighting(hit_pos, normal, mapped_normal, ray_dir, total_dist);\n        LIGHTING_PASS = false;\n        \n        ray_origin = hit_pos - normal * (REFRACTION < 0. ? -SKIP_DIST : SKIP_DIST);\n        ray_dir = new_ray;\n    \n\t  \tif(skip_count < 1) final_color += vec4(color.rgb * color.a, color.a) * (1. - final_color.a);\n\t  \tif(final_color.a >= 1.) break;\n        \n        skip_count = skip_count == 0 ? REFRACTION < 0. ? 0 : SURFACE_SKIPS : skip_count - 1;\n    }\n    \n    \n    final_color /= final_color.a; //Fix any < 1. alphas\n\t \n    if(VIGNETTE_STRENGTH > 0.) final_color *= 1. - pow(length(uv), VIGNETTE_POWER) * VIGNETTE_STRENGTH;\n    \n    vec3 color = clamp(pow(final_color, vec4(1.0 / GAMMA)).rgb, vec3(5e-2), vec3(3.95));\n    \n    vec4 fg = foreground(uv, color);\n    color = mix(color, fg.rgb, fg.a);\n    \n    float packed_color = pack3(color, 4.0);\n    float packed_normal = pack_normal(first_surface_normal);\n    \n    if(first_surface_depth > MAX_SCENE_DEPTH) first_surface_depth = MAX_SCENE_DEPTH;\n    \n    return vec4(packed_color, packed_normal, first_surface_depth, first_surface_id);\n}\n//--------- ------------------- ---------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(mod(float(iFrame), 1.0 / FPS_MULTIPLIER) < 1. || iFrame < 5) {\n        vec4 data = render(fragCoord.xy, iResolution.xy, iTime * SPEED_MULTIPLIER);\n        fragColor = data;\n    }   \n    else fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//Consts\n\n#define PI 3.1415926535\n#define TAU (PI * 2.0)\n#define DEGS_TO_RADS 0.01745329\n\n//\"Generic\" functions\n\n//Rotation matrix for an angle in radians\n#define angle(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\n//Splits a value into hard-edge segments. B = steps per 1 unit\n#define quantize(value, steps) (floor((value)*(steps))/(steps))\n\n//Repeats a range with a given spacing an infinite number of times\n#define repeat_inf(value, space) (value - space*round(value / space))\n\n//Maths\nfloat hash(float value) {\n    return fract(sin((value) * 12.9898) * 43758.5453123);\n}\n\nfloat hash(vec2 value) {\n    return fract(sin(dot(value,vec2(127.1,311.7)))*43758.545);\n}\n\nfloat hash(vec3 value) {\n    return hash(value.xz*value.zy);\n}\n\nfloat noise(float value) {\n    float i = floor(value), f = fract(value);\n    return mix(hash(i - 0.5), hash(i + 0.5), f);\n}\n\nfloat clamp_3way(float start, float new, vec4 ranges) {\n    if(start < ranges.x) return clamp(new, ranges.z, ranges.x);\n    if(start > ranges.y) return clamp(new, ranges.y, ranges.w);\n    return clamp(new, ranges.x, ranges.y);\n}\n\nuint to_bits(float value, uint range, int offset) {\n    return uint(value * float(range)) << offset;\n}\n\nfloat from_bits(uint bits, uint range, int offset) {\n    return float((bits >> offset) & range) * (1./float(range)); //Avoid division by zero\n}\n\nfloat pack4(vec4 value, float value_max)\n{\n    return uintBitsToFloat(\n      to_bits(value.x / value_max, 255u, 0) \n    | to_bits(value.y / value_max, 255u, 8) \n    | to_bits(value.z / value_max, 255u, 16) \n    | to_bits(value.w / value_max, 255u, 24)\n    );\n}\n\nvec4 unpack4(float value, float value_max)\n{\n    uint packed = floatBitsToUint(value);\n    return vec4(\n    from_bits(packed, 255u, 0) * value_max, \n    from_bits(packed, 255u, 8) * value_max, \n    from_bits(packed, 255u, 16) * value_max, \n    from_bits(packed, 255u, 24) * value_max\n    );\n}\n\nfloat pack3(vec3 value, float value_max)\n{\n    return uintBitsToFloat(\n      to_bits(value.x / value_max, 1023u, 0) \n    | to_bits(value.y / value_max, 1023u, 10) \n    | to_bits(value.z / value_max, 1023u, 20)\n    );\n}\n\nvec3 unpack3(float value, float value_max)\n{\n    uint packed = floatBitsToUint(value);\n    return vec3(\n    from_bits(packed, 1023u, 0) * value_max, \n    from_bits(packed, 1023u, 10) * value_max, \n    from_bits(packed, 1023u, 20) * value_max\n    );\n}\n\n\n\nfloat pack_normal(vec3 value)\n{\n    value = value * 0.5 + 0.5; \n    uint sign_bit = uint(sign(value.z + 1e-5) < 0. ? 0u : 1u) << 30;\n    return uintBitsToFloat(to_bits(value.x, 0x7fffu, 0) | to_bits(value.y, 0x7fffu, 15) | sign_bit);\n}\n\nvec3 unpack_normal(float value)\n{\n    uint packed = floatBitsToUint(value);\n    uint sign_bit = (packed >> 30) & 0x7fffu;\n    vec3 result = vec3(from_bits(packed, 0x7fffu, 0), from_bits(packed, 0x7fffu, 15), 0.) * 2. - 1.;\n    result.z = sqrt(1.0 - min(dot(result.xy, result.xy), 1.0)) * (sign_bit == 0u ? 1.0 : -1.0);\n    return result;\n}\n\nvec2 centered_uv(vec2 frag, vec2 res) {\n    return vec2(frag.xy - .5 * res.xy) / res.y;\n}\n\nvec3 rotate(vec3 a, vec3 r) {\n    a.zy *= angle(r.x);\n    a.xz *= angle(r.y);\n    a.yx *= angle(r.z);\n    return a;\n}\n\nfloat luma(vec3 col) {\n    return col.r * 0.2126 + col.g * 0.7152 + col.b * 0.0722;\n}\n\nvec3 normalize_luma(vec3 col) {\n    return col / luma(col);\n}\n\nvec3 rgb_to_hsv(vec3 col) {\n    vec4 k = vec4(0., -1./3., 2./3., -1.),\n    p = mix(vec4(col.bg, k.wz), vec4(col.gb, k.xy), step(col.b, col.g)),\n    q = mix(vec4(p.xyw, col.r), vec4(col.r, p.yzx), step(p.x, col.r));\n    \n    float d = q.x - min(q.w, q.y);\n    \n    return vec3(abs(q.z + (q.w - q.y) / (6. * d)), d / (q.x), q.x);\n}\n\n\nvec3 hsv_to_rgb(vec3 col) {\n    vec4 k = vec4(1., 2./3., 1./3., 3.);\n    vec3 p = abs(fract(col.xxx + k.xyz) * 6. - k.www);\n    return col.z * mix(k.xxx, clamp(p - k.xxx, 0., 1.), col.y);\n}\n\n//My tonemapping function. Does a pass through HSV and back to adjust hue, sat, & value\n\n//Hue/Sat params:\n//XY = Hue shift by value, X = exponent, Y = strength\n//ZW = Sat shift by value, Z = exponent, W = strength\n\n//Value params:\n//X = Contrast (value exponent)\n//Y = Intensity (value multiplier)\n//Z = Brightness (value gain)\n//W = Quantization (Number of colour steps)\n\nvec3 recolor(vec3 base_color, float diffuse, vec3 light_color, vec4 hs_params, vec4 v_params) {\n\n  vec3 base_hsv = rgb_to_hsv(base_color);\n  vec3 tinted_hsv = rgb_to_hsv(base_color * light_color);\n  \n  float value = quantize(pow(max(diffuse * base_hsv.z + v_params.z, 0.), v_params.x)*v_params.y, v_params.w);\n \n  float hueShiftLow = pow(max(0.5 - value * 0.5,0.), hs_params.x);\n  float hueShiftHigh = -pow(max(value * 0.5 - 0.5, 0.), hs_params.x);\n  float hueShiftDir = mix(-1., mix(1., -1., smoothstep(0.69, 0.75, base_hsv.x)), smoothstep(0.17, 0.22, base_hsv.x));\n  float hueShift = (hueShiftLow + hueShiftHigh) * hs_params.y * hueShiftDir;\n  float hue = fract(clamp_3way(tinted_hsv.x, tinted_hsv.x + hueShift, vec4(0.17, 0.69, -0.31, 1.17)));\n  \n  float satShiftLow = pow(max(0.5 - value * 0.5, 0.), hs_params.z) * hs_params.w;\n  float satShiftHigh = -pow(max(value * 0.5 - 0.5, 0.), hs_params.z) * hs_params.w;\n  float sat = clamp(tinted_hsv.y + (satShiftLow + satShiftHigh) * step(1e-3, tinted_hsv.y), 0., 1.);\n\n  return hsv_to_rgb(vec3(hue, sat, value));\n}\n\nvec3 bezier(vec3 a, vec3 b, vec3 c, float v) {\n    return mix(mix(a, b, v), mix(b, c, v), v);\n}\n\nvec3 bezier(vec3 a, vec3 b, vec3 c, vec3 d, float v) {\n    return mix(bezier(a, b, c, v),bezier(b, c, d, v), v);\n}\n\nvec3 bezier(vec3 a, vec3 b, vec3 c, vec3 d, vec3 e, float v) {\n    return mix(bezier(a, b, c, d, v),bezier(b, c, d, e, v), v);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define ONE_PIXEL vec2(1.0 / iResolution.xy)\n#define TO_RELATIVE(x) (x * iResolution.y / 500.)\n\nvec4 read_data(vec2 uv, vec2 pixel_offset) {\n    return texture(iChannel0, uv + pixel_offset * ONE_PIXEL);\n}\n\nfloat edge_detect(vec2 uv, float range) {\n\n    vec4 center = texture(iChannel0, uv);\n    float rrange = TO_RELATIVE(range);\n    ivec2 irange = ivec2(ceil(rrange));\n    float edgeness = 0.0;\n    \n    for(int x = -irange.x; x < irange.x; x++) {\n        for(int y = -irange.y; y < irange.y; y++) {\n            vec2 offset = vec2(x, y);\n            vec4 data = read_data(uv, offset);\n            \n            if(data.w != center.w) {\n                float pix_dist = length(offset);\n                edgeness = max(edgeness, 1.0 - (pix_dist - rrange));\n            }\n        }\n    }\n    \n    return edgeness;\n}\n\nvec4 process(vec2 uv) {\n    vec4 data = texture(iChannel0, uv);\n    vec3 color = unpack3(data.x, 4.);\n    vec3 normal = unpack_normal(data.y);\n    \n    float edges = edge_detect(uv, 1.0);\n    \n    vec4 col = vec4(clamp(color, vec3(.01), vec3(.99)), 1.0);\n    \n    return col + col * edges;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = process(fragCoord / iResolution.xy);\n}","name":"Buffer B","description":"","type":"buffer"}]}