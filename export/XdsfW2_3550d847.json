{"ver":"0.1","info":{"id":"XdsfW2","date":"1498179399","viewed":2170,"name":"Generative Bismuth Crystal","username":"amagitakayosi","description":"It was so difficult to me... I'll write a blog post here: https://fand.github.io/webgl-study/?id=46","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author : @amagitakayosi\n\nprecision mediump float;\nuniform float time;\nuniform vec2  mouse;\nuniform vec2  resolution;\n\nconst float PI = 3.1415926535897932384626433;\nconst int LOOP = 90;\nconst int INNER_LOOP = 5;\n\nvec2 squareFrame(vec2 screenSize) {\n  vec2 position = 2.0 * (gl_FragCoord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\nmat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nvec3 getRay(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {\n  mat3 camMat = calcLookAtMatrix(origin, target, 0.0);\n  return normalize(camMat * vec3(screenPos, lensLength));\t\n}\n\nvec2 map(vec3 p);\n\nvec2 calcRayIntersection(vec3 rayOrigin, vec3 rayDir, float maxd, float precis, float reduction) {\n  float latest = precis * 2.0;\n  float dist   = +0.0;\n  float type   = -1.0;\n  vec2  res    = vec2(-1.0, -1.0);\n\n  for (int i = 0; i < LOOP; i++) {\n    if (latest < precis || dist > maxd) break;\n\n    vec2 result = map(rayOrigin + rayDir * dist);\n\n    latest = result.x;\n    type   = result.y;\n    dist  += latest * reduction;\n  }\n\n  if (dist < maxd) {\n    res = vec2(dist, type);\n  }\n\n  return res;\n}\n\nvec3 calcNormal(vec3 pos) {\n  float eps = 0.1;\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n  return normalize( v1 * map( pos + v1*eps ).x +\n                    v2 * map( pos + v2*eps ).x +\n                    v3 * map( pos + v3*eps ).x +\n                    v4 * map( pos + v4*eps ).x );\n}\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 rotate(in vec2 v, in float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    return m * v;\n}\n\nfloat t() {\n    return (iTime + 3.) * 1.;\n}\n\nfloat random (in float x) {\n    return fract(sin(x *  13456.234));\n}\n\nfloat random (in vec2 p) {\n    return fract(sin(dot(p, vec2(34556.,67892.))));\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = smoothstep(0., 1., f);\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm (in vec2 p) {\n    return (\n        noise(p * 2.) +\n        noise(p * 4.) +\n        noise(p * 8.)\n    );\n}\n\nvec2 opU(in vec2 p, in vec2 q) {\n    return p.x < q.x ? p : q;\n}\n\nvec2 sdBox(in vec3 p) {\n    return vec2(\n        length(max(abs(p) - 2., 0.0)),\n        noise(vec2(noise(p.xy * p.z * .25 + sin(time * 2.)))) * .4\n    );\n}\n\nvec2 sdSwirl(in vec3 p) {\n    p.xy = rotate(p.xy, t());\n    p.z = p.z * 1.2 -2.;\n\n    float c = noise(vec2(noise(p.xy * .3), p.z * .3));\n\n    // Random distortion\n    p.x += noise(p.xy * 10.) * .03;\n    p.y += noise(p.xy * 10. + .3) * .03;\n\n    float d = 99999.;\n\n    for (int i = 0; i < INNER_LOOP; i++) {\n        float fi = float(i);\n        vec3 pi = p;\n        p.xy = rotate(p.xy, fi * PI * .5);\n\n        pi.x *= clamp(1. - fi * random(fi * 4.) * .4, .3,.7);\n        pi.y *= clamp(1. - fi * random(fi * 5.) * .4, .3,.7);\n\n        pi.x += clamp((1. - fi * random(fi + 1.)) * .4 + fi * .3, .7, 1.7);\n        pi.y += clamp((1. - fi * random(fi + 2.)) * .4 + fi * .3, .7, 1.7);\n        pi.z -= (3. - fi) + fi * 2.0;\n\n        pi *= 3.5;\n        float di = min(\n            pi.z + 2. - floor(abs(pi.y)),\n            pi.z + 2. - floor(abs(pi.x))\n        );\n\n        di = max(di, -min(\n            pi.z + 2. - floor(abs(pi.y * .7)),\n            pi.z + 2. - floor(abs(pi.x * .7))\n        ));\n\n        // Create binding box\n        float ti = clamp(mod(t(), 2.) - fi * .2, 0., 2.);\n        float tt = floor(ti * 20.) * .1;\n        di = max(di, length(max(abs(pi / 3.) - tt, 0.0)));\n\n        d = min(d, di);\n    }\n\n    d -= .1;\n\n    return vec2(d, c);\n}\n\nvec2 map(vec3 p) {\n    p.yz = rotate(p.zy, .2 * PI + t());\n    p.xy = rotate(p.xy, .2 * PI + t());\n    vec2 v = sdBox(p);\n\n    v = opU(v, sdSwirl(p));\n    p.yz = rotate(p.yz, PI);\n    v = opU(v, sdSwirl(p));\n\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){    \n    vec2 p = (fragCoord.xy * 2. - resolution) / min(iResolution.x, iResolution.y);\n    vec3 color;\n\n    vec3 rayOrigin = vec3(0., 0., 40.);\n    rayOrigin.xz = rotate(rayOrigin.xz, t() * 1.0);\n\n    vec3 rayTarget = vec3(0, 0, 0);\n    vec3 rayDirection = getRay(rayOrigin, rayTarget, squareFrame(iResolution.xy), 2.);\n\n    vec3 ambient = vec3(.4, .7, .5);\n    vec3 lightDir1 = normalize(vec3(-1., 2.3, 10.));\n    vec3 light1 = vec3(-.4, .7, 1.) * 1.2;\n    vec3 lightDir2 = normalize(vec3(3.,  -3., 3.));\n    vec3 light2 = vec3(.8, .8, 6.) * 1.2;\n\n    vec3 lightDir3 = vec3(0, 0., 40.);\n    vec3 light3 = vec3(.9, .3, .5) * .7;\n\n    vec2 collision = calcRayIntersection(rayOrigin, rayDirection, 70., 0.0001, .3);\n    if (collision.x > -.5) {\n        vec3 pos = rayOrigin + rayDirection * collision.x;\n        vec3 normal = normalize(calcNormal(pos));\n\n        vec3 c = ambient;\n\n        float diff1 = clamp(dot(lightDir1, normal), 0., 1.0);\n        float phong1 = pow(max(dot(reflect(lightDir1, normal), rayOrigin), 0.0), .8);\n        c += light1 * diff1 + phong1 * 1.3;\n\n        float diff2 = clamp(dot(lightDir2, normal), 0., 1.0);\n        float phong2 = pow(max(dot(reflect(lightDir2, normal), rayOrigin), 0.0), .8);\n        c += light2 * diff2 + phong2 * 1.3;\n\n        float diff3 = clamp(dot(lightDir3, normal), 0., 1.0) * 9.9;\n        float phong3 = pow(max(dot(reflect(lightDir3, normal), rayOrigin), 0.0), .3);\n        c += light3 * diff3 + phong3;\n\n        float d = length(rayOrigin - pos) + 1.;\n        c *= 30. / (d * d);\n\n        c += hsv2rgb(vec3(collision.y, 1, 1)) * .3;\n\n        color = c;\n    }\n    else {\n        float c = 1.5 - length(p *.5);\n        color = vec3(c);\n    }\n    color += vec3(p.x * .1, p.y * .1, 1.);\n    fragColor = vec4(color, 1);\n}\n\n\n\n\n","name":"Image","description":"","type":"image"}]}