{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"const float rad = 0.25;\nconst vec2 mid = vec2(0.5);\nconst ivec2 reps = ivec2(8, 8);\nconst float angle = 45.0;\nconst float RADIANS = angle * 0.0174532;\n// rotation matrix\nmat2 rot = mat2(vec2(cos(RADIANS), -sin(RADIANS)), vec2(sin(RADIANS), cos(RADIANS)));\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t// the uv.. we are calling it p for pixel\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\t// account for non square image aspect\n\tp.y *= float(iResolution.y )/ float(iResolution.x);\n\t//rotating the whole scene\t\n\tp *= rot;\n\t\n\t\n\t// q is just an offset - .5\n\tvec2 q = p - vec2(0.5, 0.5);\n\t\n\t\n\t//=====================\n\t// wave\n\t//=====================\n\t\n\t// creates a repeating 0-1 range\n\tvec2 repeat = vec2(fract(q.x * float(reps.x)), fract(q.y * float(reps.y)) );\t\n\t\n\t// holds the color\n\tvec3 col = vec3(1.0, 1.0, 1.0);\n\t\n\tvec2 distFromMid = repeat - mid;\n\t\n\t// drawing circles based on distance from center of each cell\n\tfloat dist = length(distFromMid);\n\t// aliased method\n\t//float circ = dist < rad ? 1.0 : 0.0;\n\t// anti-aliased\n\tfloat sharpness = 50.;\n\tfloat circ = rad * sharpness - dist * sharpness;\n\t// for black on white, subtract rad from dist\n\t\n\tcol *= vec3(circ);\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldXSRs","date":"1407776865","viewed":645,"name":"polka dots","username":"meetar","description":"polka dots","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["dotsbasic"],"hasliked":0,"parentid":"","parentname":""}}