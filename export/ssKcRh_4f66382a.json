{"ver":"0.1","info":{"id":"ssKcRh","date":"1654840443","viewed":106,"name":"Comic neko","username":"pnly","description":"cat pixel art","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2dpixelart"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 bg = vec3(84.0 / 255.0, 54.0 / 255.0, 99.0 / 255.0);\n\nconst vec3 colors[8] = vec3[8](\n    vec3(1.0, 1.0, 1.0),\n    vec3(0.88, 0.32, 0.32),\n    vec3(0.96, 0.66, 0.24),\n    vec3(0.96, 0.84, 0.24),\n    vec3(0.4, 0.8, 0.6),\n    vec3(0.4, 0.73, 0.8),\n    vec3(0.67, 0.4, 0.8),\n    vec3(0.55, 0.35, 0.65)\n);\n\nconst ivec2 size = ivec2(12, 20);\n\n// 000000000000\n// 001000001000\n// 001000001000\n// 001000001000\n// 001000001000\n// 011100011100\n// 010100010100\n// 010111110100\n// 110011100110\n// 100000000010\n// 100000000010\n// 100100010010\n// 100100010010\n// 100100010010\n// 100100010010\n// 100100010010\n// 100000000010\n// 110000000110\n// 011111111100\n// 001111111000\n\n// pack binary into 32bit int\nconst int neko_stroke_map[] = int[](\n    0x00020820,\n    0x82082087,\n    0x1C5145F4,\n    0xCE680280,\n    0x29129129,\n    0x12912912,\n    0x802C067F,\n    0xC3F80000\n);\n\n// 000000000000\n// 001000001000\n// 001000001000\n// 001000001000\n// 001000001000\n// 011100011100\n// 011100011100\n// 011111111100\n// 111111111110\n// 111111111110\n// 111111111110\n// 111111111110\n// 111111111110\n// 111111111110\n// 111111111110\n// 111111111110\n// 111111111110\n// 111111111110\n// 011111111100\n// 001111111000\n\nconst int neko_fill_map[] = int[](\n    0x00020820,\n    0x82082087,\n    0x1C71C7FC,\n    0xFFEFFEFF,\n    0xEFFEFFEF,\n    0xFEFFEFFE,\n    0xFFEFFE7F,\n    0xC3F80000\n);\n\nint getBit(int[8] map, int index)\n{\n    return (map[index / 32] >> (31 - index % 32)) & 1;\n}\n\nint getNeko(int index)\n{\n    int stroke = getBit(neko_stroke_map, index);\n    int fill = getBit(neko_fill_map, index);\n    return fill * 2 - stroke;\n}\n\nfloat smooth_floor(float x, float k) {\n    return (tanh(k * (mod(x, 1.0) - 1.0 / 2.0)) + 1.0) / 2.0 + floor(x);\n}\n\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nconst vec2 tile_size = vec2(14.0, 24.0);\n\nvec2 slide_uv(vec2 uv, float moving) {\n    float chi = mod(floor(uv.x / tile_size.x), 2.0);\n    return uv - vec2(0, chi * moving);\n}\n\nfloat derive_k(vec2 uv) {\n    vec2 basis = mod(uv, tile_size);\n    ivec2 ibasis = ivec2(basis);\n    ivec2 c = min(ibasis, size - 1);\n    int i = c.x + (size.y - c.y - 1) * size.x;\n    return float(getNeko(i));\n}\n\nvec4 neko(vec2 uv, float moving) {\n    vec2 slided_uv = slide_uv(uv, moving);\n    float k = derive_k(slided_uv);\n    ivec2 index = ivec2(floor(slided_uv / tile_size));\n    float color_index = floor(rand(vec2(index)) * 7.9 + 0.1);\n    vec3 color = colors[int(color_index)];\n    float special = max(-1.0 * color_index + 1.0, 0.0);\n    float special_k = 2.0 * (k - 1.0) * (k - 1.0) - 2.0;\n    return vec4(max(color * min(k + special * special_k, 1.0), 0.0), min(k, 1.0));\n}\n\nvec4 shadow_neko(vec2 uv, float moving) {\n    vec2 slided_uv = slide_uv(uv, moving);\n    float k = derive_k(slided_uv);\n    return vec4(vec3(0.0), min(k, 1.0));\n}\n\nvec4 blend(vec4 color, vec4 base) {\n    return color * color.a + base * (1.0 - color.a);\n}\n\nconst vec2 pixel_size = vec2(0.05, 0.025);\n\nconst mat3 transform = mat3(0.89, -0.58, 0.0, 0.16, 0.98, 0.0, 0.0, 0.0, 1.0);\n\nconst vec2 shadow_offset = vec2(-0.7, 2.1);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec2 uv_scaled = ((vec3(uv, 1.0) * transform).xy - iTime * 0.05) / pixel_size;\n    float t = iTime * 0.5;\n    float slide = smooth_floor(t, 20.0);\n    float moving = tile_size.y / 2.0 + tile_size.y * slide;\n    float up = max(-1.0 * pow(4.0 * mod(t, 1.0) - 2.5, 4.0) + 1.0, 0.0);\n    vec4 neko_layer = neko(uv_scaled, moving);\n    vec4 shadow_neko_layer = shadow_neko(uv_scaled + shadow_offset, moving);\n\n    // Output to screen\n    fragColor = vec4(bg, 1.0);\n    fragColor = blend(shadow_neko_layer, fragColor);\n    fragColor = blend(neko_layer, fragColor);\n}\n","name":"Image","description":"","type":"image"}]}