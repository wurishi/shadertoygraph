{"ver":"0.1","info":{"id":"ldByDW","date":"1493038585","viewed":161,"name":"IIS 3D Loxodromic - Parabolic Ex","username":"soma_arc","description":"Render the orbit of spheres with Iterated Inversion System.\nLoxodromic <--> Parabolic\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal","inversion","schottky"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nCreated by soma_arc - 2017\nThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n\tvec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n\t// implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                 fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nfloat scene(in float t, in float w, in float s){\n    return clamp(t - w, 0.0, s) / s;  \n}\n\nfloat expEasingIn(float t){\n    return pow( 2., 13. * (t - 1.) );\n}\nfloat expEasingOut(float t) {\n\treturn -pow( 2., -10. * t) + 1.;\n}\n\nfloat circEasingInOut(float t){\n\tt /= .5;\n\tif (t < 1.) return -.5 * (sqrt(1. - t*t) - 1.);\n\tt -= 2.;\n\treturn .5 * (sqrt(1. - t*t) + 1.);\n}\n\nfloat circEasingIn(float t){\n\treturn -  (sqrt(1. - t*t) - 1.);\n}\n\nmat4 pivoting(mat4 mat, int k){\n    const int n = 3;\n    int col = k;\n    float maxValue = abs(mat[k][k]);\n    for(int i = k+1; i < n ; i++){\n        if(abs(mat[i][k]) > maxValue){\n            col = i;\n            maxValue = abs(mat[i][k]);\n        }\n    }\n    if(k != col){\n        vec4 tmp = mat[col];\n        mat[col] = mat[k];\n        mat[k] = tmp;\n    }\n    return mat;\n}\n\nvec4 makeSphereFromPoints(const vec3 p1,\n                          const vec3 p2,\n                          const vec3 p3,\n                          const vec3 p4){\n    mat4 p = mat4(vec4(p1, 0), vec4(p2, 0),\n                  vec4(p3, 0), vec4(p4, 0));\n    mat4 coefficient = mat4(vec4(1), vec4(1), vec4(1), vec4(0));\n    \n    for(int i = 0 ; i < 3 ; i++){\n        coefficient[i][0] = 2. * (p[i + 1][0] - p[i][0]);\n\t    coefficient[i][1] = 2. * (p[i + 1][1] - p[i][1]);\n\t    coefficient[i][2] = 2. * (p[i + 1][2] - p[i][2]);\n\t    coefficient[i][3] = -(p[i][0] * p[i][0] + p[i][1] * p[i][1] + p[i][2] * p[i][2])+\n\t        p[i + 1][0] * p[i + 1][0] + p[i + 1][1] * p[i + 1][1] + p[i + 1][2] * p[i + 1][2];\n    }\n\n    // Gaussian elimination\n    // Implementation is based on http://www.slis.tsukuba.ac.jp/~fujisawa.makoto.fu/cgi-bin/wiki/index.php?%A5%D4%A5%DC%A5%C3%A5%C8%C1%AA%C2%F2\n    // forward elimination\n    const int n = 3;\n    for(int k = 0; k < n - 1; k++){\n        coefficient = pivoting(coefficient, k);\n\n        float vkk = coefficient[k][k];\n        for(int i = k+1; i < n; i++){\n            float vik = coefficient[i][k];\n            for(int j = k; j < n + 1; ++j){\n                coefficient[i][j] = coefficient[i][j]-vik *(coefficient[k][j]/vkk);\n            }\n        }\n    }\n\n    // back substitution\n    \n    coefficient[n-1][n] = coefficient[n-1][n]/coefficient[n-1][n-1];\n    for(int i = n-2; i >= 0; i--){\n        float acc = 0.0;\n        for(int j = i+1; j < n; j++){\n            acc += coefficient[i][j]*coefficient[j][n];\n        }\n        coefficient[i][n] = (coefficient[i][n] - acc)/coefficient[i][i];\n    }\n    \n    vec3 center = vec3(coefficient[0][3], \n                       coefficient[1][3],\n                       coefficient[2][3]);\n    float r = distance(center, p1);\n    return vec4(center, r);\n}\n\nvec3 sphereInvert(vec3 pos, vec4 sphere){\n\tvec3 diff = pos - sphere.xyz;\n    float d = length(diff);\n\treturn (diff * sphere.w * sphere.w)/(d * d) + sphere.xyz;\n}\n\nconst float RT_3 = sqrt(3.);\nvec4 sphereInvertOnSphere(vec4 invertSphere, vec4 genSphere){\n    float r = invertSphere.w;\n    float coeffR = r * RT_3 / 3.;\n    vec3 p1 = sphereInvert(invertSphere.xyz + vec3(coeffR),\n                           genSphere);\n    vec3 p2 = sphereInvert(invertSphere.xyz + vec3(-coeffR), \n                           genSphere);\n    vec3 p3 = sphereInvert(invertSphere.xyz + vec3(coeffR, -coeffR, - coeffR),\n                           genSphere);\n    vec3 p4 = sphereInvert(invertSphere.xyz + vec3(coeffR, coeffR, - coeffR),\n                           genSphere);\n    return makeSphereFromPoints(p1, p2, p3, p4);\n}\n\n\nconst float EPSILON = 0.0001;\nconst float PI = 3.14159265;\nconst float PI_2 = 3.14159265 / 2.;\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n  float imagePlane = (height * .5) / tan(fov * .5);\n  vec3 v = normalize(target - eye);\n  vec3 xaxis = normalize(cross(v, up));\n  vec3 yaxis =  normalize(cross(v, xaxis));\n  vec3 center = v * imagePlane;\n  vec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));\n  return normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));\n}\n\nconst vec4 K = vec4(1.0, .666666, .333333, 3.0);\nvec3 hsv2rgb(float h, float s, float v){\n  vec3 p = abs(fract(vec3(h) + K.xyz) * 6.0 - K.www);\n  return v * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), s);\n}\n\nbool intersectBox(vec3 rayOrg, vec3 rayDir, vec3 boxMin, vec3 boxMax,\n                  out float hit0, out float hit1, out bool inBox) {\n\tfloat t0 = -1000000.0, t1 = 1000000.0;\n    hit0 = t0;\n    hit1 = t1;\n    inBox = false;\n    vec3 tNear = (boxMin - rayOrg) / rayDir;\n    vec3 tFar  = (boxMax - rayOrg) / rayDir;\n    \n    if (tNear.x > tFar.x) {\n        float tmp = tNear.x;\n        tNear.x = tFar.x;\n        tFar.x = tmp;\n    }\n    \n    t0 = max(tNear.x, t0);\n    t1 = min(tFar.x, t1);\n\n    \n    if (tNear.y > tFar.y) {\n        float tmp = tNear.y;\n        tNear.y = tFar.y;\n        tFar.y = tmp;\n    }\n    t0 = max(tNear.y, t0);\n    t1 = min(tFar.y, t1);\n\n    if (tNear.z > tFar.z) {\n        float tmp = tNear.z;\n        tNear.z = tFar.z;\n        tFar.z = tmp;\n    }\n    t0 = max(tNear.z, t0);\n    t1 = min(tFar.z, t1);\n\n    if (t0 <= t1 && 0. < t1) {\n        if(t0 < 0.) inBox = true;\n        hit0 = t0;\n        hit1 = t1;\n        return true;\n    }\n    return false;\n}\n\nbool intersectSphere(vec4 sphere,\n                     vec3 rayOrigin, vec3 rayDir, \n                     inout float minDist,\n                     inout vec3 intersection, inout vec3 normal){\n  \tvec3 v = rayOrigin - sphere.xyz;\n  \tfloat b = dot(rayDir, v);\n  \tfloat c = dot(v, v) - sphere.w * sphere.w;\n  \tfloat d = b * b - c;\n  \tif(d >= 0.){\n    \tfloat s = sqrt(d);\n    \tfloat t = -b - s;\n    \tif(t <= EPSILON) t = -b + s;\n    \tif(EPSILON < t && t < minDist){\n      \t\tintersection = (rayOrigin + t * rayDir);\n      \t\tminDist = t;\n            normal = normalize(intersection - sphere.xyz);\n      \t\treturn true;\n    \t}\n  \t}\n  \treturn false;\n}\n\nconst vec4 baseSphere = vec4(0, 60, 180, 125);\n\nconst float schottkyRad = 300.;\nvec4 schottky1 = vec4(300, 300, 0, schottkyRad) + vec4(baseSphere.xyz, 0);\nvec4 schottky2 = vec4(300, -300, 0, schottkyRad)+ vec4(baseSphere.xyz, 0);\nvec4 schottky3 = vec4(-300, 300, 0, schottkyRad)+ vec4(baseSphere.xyz, 0);\nvec4 schottky4 = vec4(-300, -300, 0, schottkyRad)+ vec4(baseSphere.xyz, 0);\nvec4 schottky5 = vec4(0, 0, 424.26, schottkyRad)+ vec4(baseSphere.xyz, 0);\nvec4 schottky6 = vec4(0, 0, -424.26, schottkyRad)+ vec4(baseSphere.xyz, 0);\n\nvec4 S1 = vec4(0, 695, 555, 500);\nvec4 S2 = vec4(0, 695, 500, 660);\nvec4 S1d; //I_S1(S2)\nint maxIterations = 0;\nconst int MAX_KLEIN_ITARATION = 30;\nfloat distIIS(vec3 pos, out float loopNum){\n    pos -= vec3(0, 0, 0);\n  \tfloat dr = 1.;\n  \tbool loopEnd = true;\n  \tfloat scalingFactor= .08;\n  \tloopNum = 0.;\n  \tfor(int i = 0 ; i < MAX_KLEIN_ITARATION ; i++){\n  \t\tif(i >= maxIterations) break;\n        loopEnd = true;\n    \tif(distance(pos, S1.xyz) < S1.w){\n            vec3 diff0 = (pos - S1.xyz);\n            dr *= S1.w * S1.w / dot(diff0, diff0);\n      \t\tpos = sphereInvert(pos, S1);\n\n            diff0 = (pos - S2.xyz);\n            dr *= S2.w * S2.w / dot(diff0, diff0);\n            pos = sphereInvert(pos, S2);\n            loopEnd = false;\n            loopNum++;\n        }else if(distance(pos, S1d.xyz) >= S1d.w){\n            vec3 diff0 = (pos - S2.xyz);\n            dr *= S2.w * S2.w / dot(diff0, diff0);\n            pos = sphereInvert(pos, S2);\n            \n            diff0 = (pos - S1.xyz);\n            dr *= S1.w * S1.w / dot(diff0, diff0);\n            pos = sphereInvert(pos, S1);\n            loopEnd = false;\n            loopNum++;\n        }\n        if(distance(pos, schottky1.xyz) < schottky1.w){\n      \t\tvec3 diff = (pos - schottky1.xyz);\n      \t\tdr *= schottky1.w * schottky1.w / dot(diff, diff);\n      \t\tpos = sphereInvert(pos, schottky1);\n      \t\tloopEnd = false;\n      \t\tloopNum++;\n    \t}else if(distance(pos, schottky2.xyz) < schottky2.w){\n      \t\tvec3 diff = (pos - schottky2.xyz);\n      \t\tdr *= schottky2.w * schottky2.w / dot(diff, diff);\n      \t\tpos = sphereInvert(pos, schottky2);\n      \t\tloopEnd = false;\n      \t\tloopNum++;\n    \t}else if(distance(pos, schottky3.xyz) < schottky3.w){\n      \t\tvec3 diff = (pos - schottky3.xyz);\n      \t\tdr *= schottky3.w * schottky3.w / dot(diff, diff);\n      \t\tpos = sphereInvert(pos, schottky3);\n      \t\tloopEnd = false;\n      \t\tloopNum++;\n    \t}else if(distance(pos, schottky4.xyz) < schottky4.w){\n      \t\tvec3 diff = (pos - schottky4.xyz);\n      \t\tdr *= schottky4.w * schottky4.w / dot(diff, diff);\n      \t\tpos = sphereInvert(pos, schottky4);\n      \t\tloopEnd = false;\n      \t\tloopNum++;\n    \t}else if(distance(pos, schottky5.xyz) < schottky5.w){\n      \t\tvec3 diff = (pos - schottky5.xyz);\n      \t\tdr *= schottky5.w * schottky5.w / dot(diff, diff);\n      \t\tpos = sphereInvert(pos, schottky5);\n      \t\tloopEnd = false;\n      \t\tloopNum++;\n    \t}else if(distance(pos, schottky6.xyz) < schottky6.w){\n      \t\tvec3 diff = (pos - schottky6.xyz);\n      \t\tdr *= schottky6.w * schottky6.w / dot(diff, diff);\n      \t\tpos = sphereInvert(pos, schottky6);\n      \t\tloopEnd = false;\n      \t\tloopNum++;\n    \t}\n    \tif(loopEnd == true) break;\n    }\n\n    return (distance(pos, baseSphere.xyz) - baseSphere.w) / abs(dr) * scalingFactor;\n}\n\nvec3 getNormal(const vec3 p){\n\tconst vec2 d = vec2(1., 0.);\n    float loopNum;\n\treturn normalize(vec3(distIIS(p + d.xyy, loopNum) - distIIS(p - d.xyy, loopNum),\n                          distIIS(p + d.yxy, loopNum) - distIIS(p - d.yxy, loopNum),\n                          distIIS(p + d.yyx, loopNum) - distIIS(p - d.yyx, loopNum)));\n}\n\n\nconst vec3 LIGHT_DIR = normalize(vec3(1, 1, 0));\nconst vec3 AMBIENT_FACTOR = vec3(.1);\nfloat transparent = 0.4;\nvoid renderGenerators(vec3 eye, vec3 rayDir, \n                      inout vec4 l, inout float minDist){\n\tvec3 intersection, normal;\n    minDist = 999999.;\n\tfloat S1dDist;\n    bool hitS1d = intersectSphere(S1d, eye, rayDir, \n                     \t\t\t  minDist, intersection, normal);\n    if(hitS1d){\n    \tvec3 mcol = vec3(0., 0, 0.7);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, transparent);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l; \n    }\n    S1dDist = minDist;\n    \n    minDist = 999999.;\n    bool hitS2 = intersectSphere(S2, eye, rayDir, \n                     \t\t\t  minDist, intersection, normal);\n    if(hitS2){\n    \tvec3 mcol = vec3(0., 0.7, 0.);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, transparent);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l; \n    }\n    \n    minDist = 999999.;\n    bool hitS1 = intersectSphere(S1, eye, rayDir, \n                     \t\t\t minDist, intersection, normal);\n    if(hitS1){\n    \tvec3 mcol = vec3(0.7, 0., 0.);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, transparent);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l; \n    }\n  \n\t\n    minDist = 999999.;\n    bool hitS = intersectSphere(schottky1, eye, rayDir, \n                     \t\t\tminDist, intersection, normal);\n    if(hitS){\n    \tvec3 mcol = vec3(1.);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, transparent);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l; \n    }\n    minDist = 999999.;\n    hitS = intersectSphere(schottky2, eye, rayDir, \n                     \t\t\tminDist, intersection, normal);\n    if(hitS){\n    \tvec3 mcol = vec3(1.);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, transparent);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l; \n    }\n    minDist = 999999.;\n    hitS = intersectSphere(schottky3, eye, rayDir, \n                     \t\t\tminDist, intersection, normal);\n    if(hitS){\n    \tvec3 mcol = vec3(1.);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, transparent);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l; \n    }\n    minDist = 999999.;\n    hitS = intersectSphere(schottky4, eye, rayDir, \n                     \t\t\tminDist, intersection, normal);\n    if(hitS){\n    \tvec3 mcol = vec3(.7);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, transparent);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l; \n    }\n    \n    minDist = 999999.;\n    hitS = intersectSphere(schottky5, eye, rayDir, \n                     \t\t\tminDist, intersection, normal);\n    if(hitS){\n    \tvec3 mcol = vec3(1.);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, transparent);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l; \n    }\n    minDist = 999999.;\n    hitS = intersectSphere(schottky6, eye, rayDir, \n                     \t\t\tminDist, intersection, normal);\n    if(hitS){\n    \tvec3 mcol = vec3(.7);\n        mcol = clamp(dot(normal, LIGHT_DIR), 0., 1.) * mcol + \n               AMBIENT_FACTOR * mcol;\n        vec4 col = vec4(mcol, transparent);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l; \n    }    \n    \n    minDist = S1dDist;\n}\n\nint MAX_MARCH = 800;\nvec3 calcColor(float time, vec3 eye, vec3 rayDir){\n  \tvec4 l = vec4(0);\n\n    vec3 rayPos = eye;\n    float dist;\n    float rayLength = 0.;\n    bool hit = false;\n    float loopNum;\n    \n    \n    float minDist = 99999.;\n    if(transparent > 0.01)\n\t\trenderGenerators(eye, rayDir, l, minDist);\n    \n    float t0, t1;\n    bool inBox;\n    vec3 bboxMin = vec3(-3000, -5000, -1000);\n    vec3 bboxMax = vec3(3000, 1000, 5000);\n    bool hitBBox = intersectBox(eye, rayDir, bboxMin, bboxMax, t0, t1, inBox);\n    if(hitBBox == false) return l.rgb;\n    //if(hitBBox ) return vec3(1);\n\n    if(!inBox){\n    \trayLength = t0;\n        rayPos = eye + rayDir * rayLength;\n    }\n    for(int i = 0 ; i < MAX_MARCH ; i++) {\n        if(rayLength > t1) break;\n    \tdist = distIIS(rayPos, loopNum);\n        \n        //dist = distance(rayPos, S1d.xyz) - S1d.w;\n        rayLength += dist;\n        rayPos = eye + rayDir * rayLength;\n        if(dist < .2){\n          \thit = true;\n            break;\n        }\n    }\n    //if(hit && rayLength < minDist) l = vec4(0);\n    \n    if(hit){\n        vec3 mCol;\n    \tif(loopNum == 0.)\n        \tmCol = hsv2rgb(0.33, 1., .77);\n    \telse\n        \tmCol = hsv2rgb(0.0 + loopNum * 0.12 , 1., 1.);\n        vec3 normal = getNormal(rayPos);\n        vec3 diffuse =  clamp(dot(normal, LIGHT_DIR), 0., 1.) * mCol;\n    \tvec3 ambient = mCol * AMBIENT_FACTOR;\n\n        vec4 col = vec4(diffuse + ambient, 1.);\n        col.rgb *= col.a;\n        l = (1.0f - l.a)*col + l;\n    }\n    \n  \treturn l.rgb;\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\n\nconst vec3 up = vec3(0, 1, 0);\nfloat fov = radians(60.);\n\nconst float SAMPLE_NUM = 1.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float t = mod(iTime, PI * 12.);\n\n    float start = 1.;\n    float dur = 2.;\n    maxIterations = int(mix(0., 15., (scene(t, start, dur))));\n    \n    start += dur + 1.;\n    dur = 2.; \n    float r = mix(4000., 1000., (scene(t, start, dur)));\n    \n    start += dur + 2.;\n    dur = 1.;    \n\tschottky1.w = mix(0., schottkyRad, circEasingIn(scene(t, start, dur)));\n   \tschottky2.w = mix(0., schottkyRad, circEasingIn(scene(t, start + dur, dur)));\n\tschottky3.w = mix(0., schottkyRad, circEasingIn(scene(t, start + 2. * dur, dur)));\n\tschottky4.w = mix(0., schottkyRad, circEasingIn(scene(t, start + 3. * dur, dur)));\n    schottky5.w = mix(0., schottkyRad, circEasingIn(scene(t, start + 4. * dur, dur)));\n\tschottky6.w = mix(0., schottkyRad, circEasingIn(scene(t, start + 5. * dur, dur)));\n\tdur = dur * 6.;\n    \n    start += dur + 6.;\n    dur = 2.; \n    r += mix(0., 3000., (scene(t, start, dur)));\n    \n    start += dur + 8.;\n    dur = 1.;\n  \tschottky1.w -= mix(0., schottkyRad, circEasingIn(scene(t, start, dur)));\n   \tschottky2.w -= mix(0., schottkyRad, circEasingIn(scene(t, start + dur * .5, dur)));\n\tschottky3.w -= mix(0., schottkyRad, circEasingIn(scene(t, start + 2. * dur * .5, dur)));\n\tschottky4.w -= mix(0., schottkyRad, circEasingIn(scene(t, start + 3. * dur * .5, dur)));\n    schottky5.w -= mix(0., schottkyRad, circEasingIn(scene(t, start + 4. * dur * .5, dur)));\n\tschottky6.w -= mix(0., schottkyRad, circEasingIn(scene(t, start + 5. * dur * .5, dur)));\n\tdur = dur * 6. * .5;\n    \n\tstart += dur + 1.;\n    dur = 3.;\n    maxIterations -= int(mix(0., 15., (scene(t, start, dur))));\n    \n    vec3 center = vec3(0, 695, 800);\n    vec3 target = center - vec3(0, 500., 0);\n\n    S1.z += 115. * sin(t) * sin(t);\n    S1d = sphereInvertOnSphere(S1, S2);\n    vec3 eye = vec3(r * sin(t), 500., \n                    r * cos(t) ) + center;\n  \tvec3 sum = vec3(0);\n    \n  \tfor(float i = 0. ; i < SAMPLE_NUM ; i++){\n    \tvec2 coordOffset = vec2(.5);//rand2n(gl_FragCoord.xy, i);\n    \tvec3 ray = calcRay(eye, target, up, fov,\n        \t               iResolution.x, iResolution.y,\n            \t           gl_FragCoord.xy + coordOffset);\n          \n    \tsum += calcColor(t, eye, ray);\n\t}\n\tvec3 col = (sum/SAMPLE_NUM);\n\n\tfragColor = vec4(gammaCorrect(col), 1.);\n}","name":"Image","description":"","type":"image"}]}