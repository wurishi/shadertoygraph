{"ver":"0.1","info":{"id":"3dSSDK","date":"1554906675","viewed":169,"name":"black hole simulator","username":"Jontte","description":"simple gravity equation + euler integration","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat unioni(float d1, float d2) {\n\treturn min(d1, d2);\n}\nfloat diffi( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n\nvec3 g_color;\nfloat g_distance;\nvoid merge(float test_distance, vec3 test_color)\n{\n    if (test_distance < g_distance) {\n    \tg_distance = test_distance;\n        g_color = test_color;\n    } \n}\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nfloat rand(vec3 co)\n{\n    return fract(sin(dot(co, vec3(59.319, 61.30, 67))) * 103.0);\n}\n\nmat2 rota(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\nfloat box( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec3 ORIGIN = vec3(0,0,10);\n\nfloat scene(vec3 p)\n{\n    g_distance = 1e9;\n    g_color = vec3(0.2);\n    \n    //g_distance = min(g_distance, length(p-ORIGIN) - 0.2);\n    \n    vec3 diff = p - ORIGIN;\n    diff.yz *= rota(-0.14);\n    \n    diff.xz *= rota(sin(iTime)*0.2);\n    diff.yz *= rota(sin(iTime*0.3)*0.2);\n    \n    // add disc\n    g_distance = min(g_distance,\n\t\tdiffi(\n            sdRoundedCylinder(diff, 1.5, 0.5*0.0, 0.2 ),\n            sdRoundedCylinder(diff, 3.0, 0.0, 0.02 )\n            \n        )\n    );\n    \n    g_color = vec3(5.5,0.3,0.01) * 10.0 * 0.2 * \n\t\tvec3(1.1+sin(\n            atan(diff.x,diff.z)*5.0 + iTime * 5.0\n            -length(diff)*2.0\n        ) * 1.0);\n    \n\treturn g_distance;\n}\nvec3 normal(vec3 p) {\n    float d = scene(p);\n    vec3 eps = vec3(0.2, 0.0, 0.0);\n\treturn normalize(vec3(\n    \tscene(p + eps - d),\n    \tscene(p + eps.yxy - d),\n    \tscene(p + eps.yyx - d)\n    ));\n}\n\n\nvec3 trace(vec2 coord) {\n\n\tvec3 ray = normalize(vec3(coord*0.5, 1));\n    \n    vec3 pos = vec3(0);\n    float d = 0.0;\n    bool hit = false;\n    float dist = 0.0;\n    \n    float STEP = 0.01;\n    float K = mix(0.0, 0.005, sin(float(iTime)*0.5)*0.5+0.5);\n    \n    g_color = vec3(0.0,0.0,0.0);\n    for(int i=0; i<3000; ++i)\n    {\n    \tdist = scene(pos);\n        if (dist < 0.0) {\n        \thit = true;\n            break;\n        }\n        \n        vec3 d = (ORIGIN - pos);\n        float dl = length(d);\n        \n        ray += K * d/(dl*dl*dl);\n        ray = normalize(ray);\n        pos += ray * STEP;\n        \n    }\n    \n    if (length(ORIGIN-pos) < 1e-2) {\n        hit = true;\n    \tg_color = vec3(0.0,0.0,0);//*normal(pos);\n    }\n    else {\n    }\n    \n   \tvec3 lights = vec3(0.1); // ambient\n    \n    if (hit) {\n            \n            \n\t\t/*vec3 n = normal(pos);\n        \n        vec3 lightdir = vec3(-1,1,-1);\n        \n        lights += max(dot(n, normalize(lightdir)), 0.0) * vec3(1.0, 10.0, 1.0); // directional\n        \n        vec3 halfvec = normalize(-ray + lightdir);\n        \n        lights += pow(max(dot(n, normalize(halfvec)), 0.0),32.0) * vec3(10000); // specular    \n        */\n    }\n    else {\n        g_color = texture(iChannel0, ray).rgb * 5.0;\n    }\n    \n    // fog\n    \n    //return vec3(0.0);\n    return g_color * lights; //mix(vec3(0.005), g_color * lights, exp(-d*0.1));\n}\n\nvec3 vignette(vec3 color, vec2 coord) {\n    return color * smoothstep(1.0, 0.0, max(length(coord)-1.5,0.0)*2.0);\n}\n\nvec3 gamma(vec3 c) {\n\treturn pow(c, vec3(1.0/2.2));\n}\n\nvec3 filmicToneMapping(vec3 color)\n{\n\tcolor = max(vec3(0.), color - vec3(0.004));\n\tcolor = (color * (6.2 * color + .5)) / (color * (6.2 * color + 1.7) + 0.06);\n\treturn color;\n}\n\nvec3 tonemap(vec3 c) {\n    // more tonemappers: https://www.shadertoy.com/view/lslGzl\n    return filmicToneMapping(c);\n\t//return c / (c + 1.0);\n    //return c;\n}\n\n\nvec3 stack(vec2 coord) {\n    \n    vec3 color = trace(coord);\n    \n    color = tonemap(color);\n    color = vignette(color, coord);\n    color = gamma(color);\n\t\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n    uv.x = uv.x * iResolution.x / iResolution.y;\n\tfragColor = vec4(stack(uv * 2.0),1.0);\n}","name":"Image","description":"","type":"image"}]}