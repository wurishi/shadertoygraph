{"ver":"0.1","info":{"id":"ctdBDn","date":"1701158773","viewed":84,"name":"Realtime FFT of Generated Sound","username":"foodini","description":"Before too long, I'll have this a bit better modularized and added to my \"Tools\" series. I may take a scenic route through the process of creating a \"mod player\" with visualization first, though.","likes":1,"published":1,"flags":40,"usePreview":0,"tags":["fourier"],"hasliked":0,"parentid":"dtycWm","parentname":"Fourier Hell"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nTakes a little 'splainin'...\n\nI run an FFT on whatever audio is being generated. To minimize the work, the output of the FFT\nis stored with 4 results to a pixel in the lower-left few pixels of the screen. The reason to\npack them into a rectangular block is to take advantage of the way threading is generally done\non hardware. Hardware usually assumes that locationally similar pixels will do similar things,\nso the grouping tends to be done in squares of pixels. If one pixel in that group is going to\nbe doing a bunch of batshit insane work - like computing an FFT - it's best that all of them\nare doing the same batshit insane thing.\n\nIf I were to have every pixel at the bottom row of Buffer A do the FFT work, it is likely that\nI would end up doing 4 times as much work. I really can't explain it because I don't understand\ngrouping very well. However, I did see a huge speedup (about 12x) by packing pixels in this way\nand by grouping 4 outputs to a pixel.\n\nAnyway. I'll be using this to write a visualizer for my \"Mod Tracker\" before too long.\n\nmainImage is just an example of how you'd use the buffer generated by BufferA. The bottom few\npixels (counted by block_height) are the pixels that output FFT results. Everything above that\nis the previous (iResolution.y - block_height) frames of FFT spectral data. The red channel\ncontains the raw FFT output, which will contains values between 0.0 and bufflen/2.0. The green\nchannel scales this to have a range between 0.0 and 1.0, but in practice, it is VERY hard to\nget a 1.0 out of it. A tone that is an exact harmonic of the FFT base frequency, at full\nvolume, will be unlikely to come back as a 1.0. You'll have to decide how you'll want to\nscale it. I'd suggest something like pow(texel.g, some_fraction). The blue channel is just a\ncool effect. It shows you the max recent green value, with a per-frame decay.\n\n*/\n\n// Check out http://dev.thi.ng/gradients/ (Due to my color deficiencies, I\"m not using it now.)\nvec3 palette(float pos) {\n    pos = min(pos, max(1.0, pos));\n\n    const vec3 a = vec3(0.50, 0.39, 0.47);\n    const vec3 b = vec3(0.50, 0.61, 0.53);\n    const vec3 c = vec3(0.96, 1.26, 1.62);\n    const vec3 d = vec3(-0.48, 0.36, 0.60);\n\n    return b*cos(tau * (c * pos + d)) + a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float separation_point = iResolution.y / 4.0;\n    fragColor = vec4(0.0);\n    if(fragCoord.y < separation_point) {\n        ivec2 tex_coord = ivec2(fragCoord.x, separation_point - fragCoord.y + float(block_height));\n        fragColor.rgb = palette(sqrt(texelFetch(iChannel0, tex_coord, 0).g));\n    } else {\n        vec4 spectral_data = texelFetch(iChannel0, ivec2(fragCoord.x, block_height), 0);\n        float height_here = (fragCoord.y - separation_point) / iResolution.y;\n        fragColor.rb = vec2(height_here < sqrt(spectral_data.g) ? 0.5 : 0.0);\n        if(abs(height_here - sqrt(spectral_data.b)) < 0.005) {\n            fragColor.g = 1.0;\n        }\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float pi = 3.14159265357;\nconst float tau = 2.0 * 3.14159265357;\n\n// The bottom-left of the buffer will have a block_width X block_height area of pixels\n// that store the result of computation. The reason to do this instead of just using\n// the bottom row of pixels is that your hardware likely groups together \"threads\" of\n// pixels by physical proximity. I'll try to explain later.\nconst int block_width =  4; // MUST BE A POWER OF 2!!!\nconst int block_height = 8; // MUST BE A POWER OF 2!!!\n\nfloat instrument(float freq, float t) {\n\n    t = mod(t, 3.0);\n    //return sin(80.0 * t * tau);\n    \n    float envelope = smoothstep(0.0, 0.01, t) * exp(-0.7*t);\n    \n    return 1.0  * sin(880.0 * t * tau + sin(660.0*tau*t)) * envelope;\n}\n\n\n#define complex vec2\n#define real x\n#define imag y\n\n// Multiplied by 4 because there are 4 buffers.\n// Multiplied by 2 because only the lower half of the results are useful.\n//   This means we need to compute a buffer that is twice as long as we can output.\nconst int bufflen = 4 * 2 * block_width * block_height;  // MUST BE A POWER OF 2!!!\ncomplex complex_buffers[4*bufflen];\nconst int main_buff_id = 0;\nconst int out_buff_id = 1;\nconst int scratch_buff_id = 2;\nconst int twiddles_buff_id = 3;\n\nstruct complex_ptr {\n  int buffer_id;\n  int offset;\n};\n\n\ncomplex ptr_get(complex_ptr ptr, int deref) {\n  return complex_buffers[ptr.buffer_id*bufflen + ptr.offset+deref];\n}\n\ncomplex ptr_get(complex_ptr ptr) {\n  return complex_buffers[ptr.buffer_id*bufflen + ptr.offset];\n}\n\nvoid ptr_put(complex_ptr ptr, int deref, complex c) {\n  complex_buffers[ptr.buffer_id*bufflen + ptr.offset+deref] = c;\n}\n\nvoid ptr_put(complex_ptr ptr, complex c) {\n  complex_buffers[ptr.buffer_id*bufflen + ptr.offset] = c;\n}\n\ncomplex_ptr ptr_add(complex_ptr ptr, int offset) {\n  complex_ptr retval;\n  retval.buffer_id = ptr.buffer_id;\n  retval.offset = ptr.offset + offset;\n\n  return retval;\n}\n\n\n#define ptr_incr(ptr, _offset) do{(ptr).offset += (_offset);}while(false)\n\ncomplex from_polar(float r, float theta) {\n    return vec2(r * cos(theta), r * sin(theta));\n}\n\n#define magnitude(c) (length(c))\n#define add(left, right) ((left) + (right))\n#define sub(left, right) ((left) - (right))\n\ncomplex mult(complex left, complex right) {\n    return complex(\n        left.x*right.x - left.y*right.y,\n        left.x*right.y + left.y*right.x);\n}\n\n\nvoid FFT_calculate(complex_ptr x, complex_ptr X, complex_ptr scratch, complex_ptr twiddles) {\n    int k, m, n;\n    int skip;\n    bool evenIteration = (bufflen & 0x55555555) != 0;\n    complex_ptr E, Xp, Xp2, Xstart;\n\n    E = x;\n    n = 1;\n    while(n < bufflen) {\n        //WHY IS THIS A GLSL COMPILE ERROR?\n        //Xstart = (evenIteration) ? (scratch) : X;\n        if(evenIteration) {\n            Xstart = scratch;\n        } else {\n            Xstart = X;\n        }\n        skip = bufflen/(2 * n);\n        Xp = Xstart;\n        Xp2 = ptr_add(Xstart, bufflen/2);\n        for(k = 0; k != n; k++) {\n          complex tmp = ptr_get(twiddles, k*skip);\n          float tim = tmp.imag;\n          float tre = tmp.real;\n          for (m = 0; m != skip; ++m) {\n            complex_ptr D = ptr_add(E, skip);\n\n            complex d = ptr_get(D);\n            float dre = d.real * tre - d.imag * tim;\n            float dim = d.real * tim + d.imag * tre;\n\n            complex e = ptr_get(E);\n            tmp.real = e.real + dre;\n            tmp.imag = e.imag + dim;\n            ptr_put(Xp, tmp);\n\n            tmp.real = e.real - dre;\n            tmp.imag = e.imag - dim;\n            ptr_put(Xp2, tmp);\n\n            ptr_incr(Xp, 1);\n            ptr_incr(Xp2, 1);\n            ptr_incr(E, 1);\n          }\n          ptr_incr(E, skip);\n        }\n        E = Xstart;\n        evenIteration = !evenIteration;\n        n *= 2;\n    }\n}\n\n\nvoid FFT_get_twiddle_factors(complex_ptr twiddles) {\n    int k;\n    while(k < bufflen) {\n        ptr_put(twiddles, k, from_polar(1.0, -tau*float(k)/float(bufflen)));\n        k++;\n    }\n}\n\n\nvoid FFT_simple() {\n    complex_ptr x; x.buffer_id = main_buff_id; x.offset = 0;\n    complex_ptr outs; outs.buffer_id = out_buff_id; outs.offset = 0;\n    complex_ptr scratch; scratch.buffer_id = scratch_buff_id; scratch.offset = 0;\n    complex_ptr twiddles; twiddles.buffer_id = twiddles_buff_id; twiddles.offset = 0;\n    FFT_get_twiddle_factors(twiddles);\n\n    FFT_calculate(x, outs, scratch, twiddles);\n}\n\n\nvoid gen_waveform(float t, float sample_rate) {\n  int i=0;\n  float timespan = 1.0/40.0; // Should give me a clean line at 440Hz\n  while(i<bufflen) {\n    float dt = timespan*float(i)/float(bufflen);\n    //float amplitude = sin(float(3.1415926 * 2.0 * 20.0*float(i))/float(N));\n    float amplitude = instrument(440.0, t + dt);\n    float real = -amplitude*cos(t + tau * dt);\n    float imag = amplitude*sin(t + tau * dt);\n    complex_buffers[main_buff_id*bufflen + i] = complex(real,imag);\n    \n    i++;\n  }\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat tex_lookup(float f) {\n    f /= iResolution.x;\n    f *= float(bufflen) * 0.5;\n    int i = int(f);\n    int val_index = i / 4;\n    int val_offset = i % 4;\n    int x = val_index % block_width;\n    int y = val_index / block_width;\n    \n    vec4 texel = texelFetch(iChannel0, ivec2(x,y), 0);\n    float t0;\n    switch(val_offset) {\n        case 0: t0 = texel.x; break;\n        case 1: t0 = texel.y; break;\n        case 2: t0 = texel.z; break;\n        case 3: t0 = texel.w; break;\n    }\n    \n    i++;\n    val_index = i/4;\n    val_offset = i%4;\n    x = val_index % block_width;\n    y = val_index / block_width;\n    \n    texel = texelFetch(iChannel0, ivec2(x,y), 0);\n    float t1;\n    switch(val_offset) {\n        case 0: t1 = texel.x; break;\n        case 1: t1 = texel.y; break;\n        case 2: t1 = texel.z; break;\n        case 3: t1 = texel.w; break;\n    }\n    \n    float blend = fract(f);\n    return (1.0 - blend) * t0 + blend * t1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float half_bufflen = float(bufflen/2);\n    fragColor = vec4(0.0);\n    if(fragCoord.y > float(block_height) + 1.0) {\n        ivec2 prev = ivec2(fragCoord) - ivec2(0,1);\n        fragColor = texelFetch(iChannel0, prev, 0);\n        \n    } else if(fragCoord.y > float(block_height)) {\n        // This is a bit tricky. The results of the FFT pass are stored in .xyzw values\n        // in a (block_width X block_height) set of pixels in the lower left of the image.\n        // We have to figure out which value corresponds to this pixel location.\n        fragColor.r = tex_lookup(fragCoord.x);\n        fragColor.g = fragColor.r / float(bufflen);\n        ivec2 prev_location = ivec2(fragCoord.x, fragCoord.y);\n        fragColor.b = max(fragColor.g, texelFetch(iChannel0, prev_location, 0).b * 0.85);\n    } else if(fragCoord.x < float(block_width)) {\n        gen_waveform(iTime, iSampleRate);\n        FFT_simple();\n        complex_ptr c_ptr;\n        c_ptr.buffer_id = out_buff_id;  \n        \n        int offset = (int(fragCoord.y) * block_width + int(fragCoord.x)) * 4;\n        c_ptr.offset = int(offset);\n\n        fragColor.r = magnitude(ptr_get(c_ptr));\n        c_ptr.offset++;\n        fragColor.g = magnitude(ptr_get(c_ptr));\n        c_ptr.offset++;\n        fragColor.b = magnitude(ptr_get(c_ptr));\n        c_ptr.offset++;\n        fragColor.a = magnitude(ptr_get(c_ptr));    \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec2 mainSound( int samp, float time )\n{\n    return vec2(instrument(440.0, time));\n\n}","name":"Sound","description":"","type":"sound"}]}