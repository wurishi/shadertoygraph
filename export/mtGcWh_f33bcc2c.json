{"ver":"0.1","info":{"id":"mtGcWh","date":"1700159697","viewed":102,"name":"Hall of Mirrors w/attenuation","username":"MV10","description":"Added border attenuation to soften the edges.","likes":11,"published":1,"flags":0,"usePreview":1,"tags":["mirror","aftereffects","hallofmirrors"],"hasliked":0,"parentid":"dsSGWm","parentname":"Hall of Mirrors"},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Faithful remake of the deleted \"Hall of Mirrors\" effect by Red Giant\n// Recreated by MysteryPancake\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Number of images to display\n\tint images = 33;\n\t// Scale factor per image\n\tfloat scale = 0.9 + cos(iTime * 2.0) * 0.1;\n\t// Rotation per image in degrees\n\tfloat rotation = sin(iTime * 0.5) * 45.0;\n\t// Position offset per image in normalized coordinates (0-1)\n\tvec2 offset = iMouse.z > 0.0 ? vec2(iMouse.xy / iResolution.xy) : 0.5 + vec2(cos(iTime), sin(iTime)) * 0.5;\n\n\n\t// mv10 - border attenuation\n\t// 0.1 = small center, 0.9 = nearly no border\n\tfloat center_size = 0.6; \n\n\n\tfloat rad = radians(-rotation);\n\tvec2 uv = fragCoord / iResolution.xy;\n\tfragColor = vec4(0.0);\n\n\tfor (int i = 0; i < images; ++i) {\n\t\t// SCALING: Offset, apply scale, reset offset\n\t\tvec2 pos = uv - offset;\n\t\tpos /= pow(scale, float(i));\n\t\tpos += offset;\n\n\t\t// ROTATION\n\t\tfloat theta = rad * float(i);\n\t\tfloat cs = cos(theta);\n\t\tfloat sn = sin(theta);\n\t\t// Offset to center, fix aspect ratio\n\t\tpos -= vec2(0.5);\n\t\tpos *= iResolution.xy;\n\t\t// Rotate coordinate space\n\t\tpos = vec2(pos.x * cs - pos.y * sn, pos.x * sn + pos.y * cs);\n\t\t// Reset aspect ratio, reset offset\n\t\tpos /= iResolution.xy;\n\t\tpos += vec2(0.5);\n\n\t\t// Prevent out of bounds bugs, could also be done with clamp\n\t\tif (pos.x >= 0.0 && pos.x <= 1.0 && pos.y >= 0.0 && pos.y <= 1.0) {\n\t\t\tvec4 color = texture(iChannel0, pos);\n\n            // mv10 - border attenuation\n            if(i > 0)\n            {\n\t\t\t\tvec2 fade_coords = 1.0 - smoothstep(vec2(center_size), vec2(1.0), abs(2.0 * pos - 1.0));\n\t\t\t\tfloat fade_factor = fade_coords.x * fade_coords.y;\n\t\t\t\tcolor = mix(vec4(0), color, fade_factor);\n            }\n\n            // Alpha blending, see shadertoy.com/view/msSGDm for working example\n            fragColor = color + (1.0 - color.a) * fragColor;\n\t\t}\n\t}\n}","name":"Image","description":"","type":"image"}]}