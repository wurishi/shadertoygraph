{"ver":"0.1","info":{"id":"WtsBRX","date":"1606197155","viewed":109,"name":"Rock Planet","username":"romeosoft","description":"Rock Planet","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["rockplanet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ROT(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\nconst float pi = 3.1415926;\n\nconst vec3 \n    c1 = vec3(0.04, 0.02, 0.3),\n\tc2 = vec3(0.12, 0.06,1.25);\nconst vec3 \n    c3 = vec3(0.06, 0.1, 0.5),\n\tc4 = vec3(0.10, 0.10,0.9);\n\nconst float R = 0.625;\nconst float R1 = R * 1.25;\n\nfloat time;\n\n//--------------------------------------------------------------\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n//--------------------------------------------------------------\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 0.739513;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n    float n = 0.0;\t// noise amount\n    float iter = 1.0;\n    for (int i = 0; i < 8; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n\nfloat SpiralNoise3D(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    for (int i = 0; i < 5; i++)\n    {\n        n += (sin(p.y*iter) + cos(p.x*iter)) / iter;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;\n        iter *= 1.33733;\n    }\n    return n;\n}\n\nfloat NebulaNoise(vec3 p)\n{\n   float final = p.y + 4.5;\n    final -= SpiralNoiseC(p.xyz);   // mid-range noise\n    final += SpiralNoiseC(p.zxy*0.5123+100.0)*4.0;   // large scale features\n    final -= SpiralNoise3D(p);   // more large scale features, but 3d\n\n    return final;\n}\n\nfloat map(vec3 p) \n{\n\t#ifdef ROTATION\n\tR(p.xz, iMouse.x*0.008*pi+iTime*0.1);\n\t#endif\n    \n\tfloat NebNoise = abs(NebulaNoise(p/0.5)*0.5);\n    \n\treturn NebNoise+0.03;\n}\n//--------------------------------------------------------------\n// iq's noise\n//--------------------------------------------------------------\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n//--------------------------------------------------------------\n// hsv and rgb\n//--------------------------------------------------------------\nvec3 RGB2HSV(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n\tvec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 HSV2RGB(vec3 c)\n{\n      vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n      vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n      return c.z * mix(K.xxx, (p - K.xxx), c.y);\n}\n//--------------------------------------------------------------\n\nvec3 getSaturnCor(float r, vec3 p, vec3 camray, float dc)\n{\n    float dr = (r - R1);\n   // ROT(p.xz, (0.1) * (iTime + 15.0));\n    \n    float nz = 0.65;\n    \n    float h = dc * 0.08;\n    float h0 = 0.25;\n    float n = min(4., floor(log2(h0 / h)));\n    h=h0;\n    for(float i = 1.; i <= n; i +=1.0)\n    {\n        float w = i*100.;\n        nz += (noise(p*w) - 0.5) * h;\n        h /= 2.0;\n    }\n    vec3 cor0 = mix(c3,c4,nz);\n    \n    vec3 cor = mix(cor0, vec3(0.), dr / (1.-R1));\n    \n    return HSV2RGB(cor);\n}\n\n//--------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    vec2 pp = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    float eyer = 2.0;\n    float eyea = -((iMouse.x + 80.5) / iResolution.x) * pi * 2.0;\n    float eyef = ((iMouse.y / iResolution.y)-0.24) * pi * 2.0;\n    \n\tvec3 cam = vec3(\n        eyer * cos(eyea) * sin(eyef),\n        eyer * cos(eyef),\n        eyer * sin(eyea) * sin(eyef));\n    \n    //ROT(cam.xz, (0.25) * (iTime + 15.0));\n    \n\tvec3 front = normalize(- cam);\n\tvec3 left = normalize(cross(normalize(vec3(0.25,1,-0.01)), front));\n\tvec3 up = normalize(cross(front, left));\n\tvec3 v = normalize(front*1.75 + left*pp.x + up*pp.y);\n    \n    vec3 p = cam;\n    \n    float dt = 0.005;\n    vec3 cor = vec3(0.0);\n    \n    \n    for(int i = 0; i < 800; i ++)\n    {\n\t\tfloat r = length(p);\n        float dr = map(p*10.) * 0.01;\n        if(r > R+dr)\n        { \n            dt = mix(0.002,0.005,smoothstep(0.,0.05,abs(p.y * r))); // To be smooth\n            vec3 np = p + (v) * dt;\n            \n            vec3 rp = np;\n            ROT(rp.xz, (0.1) * (iTime + 15.0));\n     \t\tvec3 dp1=rp-vec3(0.95,0.0,1.11);\n            vec3 dp2=rp-vec3(-0.85,0.0,1.11);\n            if(length(dp1) < 0.025)\n            {\n                cor = mix(mix(vec3(0.10, 0.10,0.0),vec3(0.80, 0.80,0.5),1.5 * noise(p*180.))*0.8*(normalize(dp1).z), cor, cor.r * 2.); \n            \tbreak;\n            }\n            else if(length(dp2) < 0.025)\n            {\n                cor = mix(mix(vec3(0.20, 0.20,0.0),vec3(0.80, 0.80,0.85),1.5 * noise(p*900.))*0.8*(normalize(dp2).z), cor, cor.r * 2.); \n            \tbreak;\n            }\n            p = np;\n        }\n        else\n        {  \n            float dr = map(p*25.) * 0.005;\n            if(r < R-dr)\n            { \n                cor = mix(getSaturnCor(r, p, front,length(p-cam))*0.8*(normalize(p).z)*(dr*20.), cor, cor.r * 2.);\n                break;\n            }\n            cor = mix(cor, getSaturnCor(r, p, front,length(p-cam))*0.5, 0.005);\n            if(cor.r > 0.9)\n                break;\n            p = p + (v) * dt;\n        }\n    }\n    fragColor = vec4(cor,1.0);\n}","name":"Image","description":"","type":"image"}]}