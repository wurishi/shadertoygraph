{"ver":"0.1","info":{"id":"mtdyWN","date":"1699242339","viewed":108,"name":"This crimson cloud","username":"akoylasar","description":"An example of real-time rendering of a volumetric object as found in literature. The sky is based primarily on the article \"PhotorealisticReal-Time OutdoorLight Scattering\" (Hoffman, Preetham). \nNote: Optimisation wasn't the focus here.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["sky","volumetric","physicallybased","vre"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2023-2023 Fouad Valadbeigi (akoylasar@gmail.com)\n\n// From https://www.shadertoy.com/view/4djSRW by Dave_Hoskins\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yxx) * p3.zyx);\n}\n\n// From Jorge Jimenez\nfloat InterleavedGradientNoise(vec2 pixel, int frame) \n{\n    pixel += (float(frame) * 5.588238f);\n    return fract(52.9829189f * fract(0.06711056f*float(pixel.x) + 0.00583715f*float(pixel.y)));  \n}\n\n// ++++++++++++++++++++++++++++++++++++ Common ++++++++++++++++++++++++++++++++++++\n#define PI 3.141592653589793\n#define UP vec3(0., 1., 0.)\n#define RAD_TO_DEG 57.295779513082321\n#define FOUR_PI 12.566370614359173\n#define THREE_OVER_SIXTEEN_PI 0.059683103659461\n#define PI_CUBED 31.00627668029982\n#define TAN_36 0.726542528005361\n\nfloat saturate(float x) {\n    return clamp(x, 0., 1.);\n}\n\nfloat remap(float x, float x0, float x1, float y0, float y1) {\n    return y0 + (((x - x0) / (x1 - x0)) * (y1 - y0));\n}\n\nvec3 gradient(vec3 v) {\n    vec3 w = hash33(v) * 2. - 1.;\n    return normalize(w);\n}\n\nvec3 hermite(vec3 x) {\n    vec3 x2 = x * x;\n    return 3. * x2 - 2. * x2 * x;\n}\n\nfloat perlin(vec3 p, float freq) {\n    vec3 q = floor(p);\n    vec3 f = p - q;\n    \n    vec3 g000 = gradient(mod(q, freq));\n    vec3 g001 = gradient(mod(q + vec3(0., 0., 1.), freq));\n    vec3 g010 = gradient(mod(q + vec3(0., 1., 0.), freq));\n    vec3 g011 = gradient(mod(q + vec3(0., 1., 1.), freq));\n    vec3 g100 = gradient(mod(q + vec3(1., 0., 0.), freq));\n    vec3 g101 = gradient(mod(q + vec3(1., 0., 1.), freq));\n    vec3 g110 = gradient(mod(q + vec3(1., 1., 0.), freq));\n    vec3 g111 = gradient(mod(q + vec3(1., 1., 1.), freq));\n\n    float n000 = dot(g000, f);\n    float n001 = dot(g001, f - vec3(0., 0., 1.));\n    float n010 = dot(g010, f - vec3(0., 1., 0.));\n    float n011 = dot(g011, f - vec3(0., 1., 1.));\n    float n100 = dot(g100, f - vec3(1., 0., 0.));\n    float n101 = dot(g101, f - vec3(1., 0., 1.));\n    float n110 = dot(g110, f - vec3(1., 1., 0.));\n    float n111 = dot(g111, f - vec3(1., 1., 1.));\n\n    vec3 t = hermite(f);\n    float nx00 = mix(n000, n100, t.x);\n    float nx01 = mix(n001, n101, t.x);\n    float nx10 = mix(n010, n110, t.x);\n    float nx11 = mix(n011, n111, t.x);\n\n    float nxy0 = mix(nx00, nx10, t.y);\n    float nxy1 = mix(nx01, nx11, t.y);\n    \n    return mix(nxy0, nxy1, t.z);\n}\n\nfloat perlinFbm(vec3 p, in float freq, int octaves) {\n    float s = 0.;\n    float weight = 1.;\n    for (int o = 0; o < octaves; o++) {\n        s += weight * perlin(p * freq, freq);\n        freq *= 2.;\n        weight *= .5;\n    }\n    return s;\n}\n\nstruct Ray {\n    vec3 o;\n    vec3 d;\n};\n\nstruct AABB {\n    vec3 lo;\n    vec3 hi;\n};\n\nfloat rayAABB(Ray ray, AABB box, out float tmin, out float tmax) {\n    vec3 invD = vec3(1.) / ray.d;\n    vec3 t0_ = (box.lo - ray.o) * invD;\n    vec3 t1_ = (box.hi - ray.o) * invD;\n    vec3 t0 = min(t0_, t1_);\n    vec3 t1 = max(t0_, t1_);\n    tmin = max(max(t0.x, t0.y), t0.z);\n    tmax = min(min(t1.x, t1.y), t1.z);\n    return step(0., tmax - tmin);\n}\n\n// Phase functions: https://www.desmos.com/calculator/uz7eqfgmyl\n\n// The Henyey-Greenstein phase function used in paper \"A Practical Analytic Model for Daylight\"\n// Negative values of g will cause most of the light to be scattered in the forward direction, and positive\n// values will cause most of it to be scattered backwards (for most particles, g should be negative \n// and increase in magnitude when the particle size increases).\n// cos_theta: dot(viewDir, lightDir)\nfloat HG_p(float cos_theta, float g) {\n    return pow(1. - g, 2.) / pow(1. + g * g - 2. * g * cos_theta, 1.5) / FOUR_PI;\n}\n\nfloat HG(float cos_theta, float g) {\n    float g2 = g * g;\n    return (1. - g2) / pow(1. + g2 - 2. * g * cos_theta, 1.5) / FOUR_PI;\n}\n\n// cos_theta: dot(viewDir, lightDir)\nfloat rayleigh(float cos_theta) {\n    return THREE_OVER_SIXTEEN_PI * (1. + cos_theta * cos_theta);\n}\n\nvoid getRay(vec2 p, vec3 origin, vec3 target, float tanHalfFovy, out Ray ray) {\n    vec3 w = normalize(target - origin);\n    vec3 u = normalize(cross(w, UP));\n    vec3 v = cross(u, w);\n    float f = .5 / tanHalfFovy;\n    ray.d = normalize(f * w + p.x * u + p.y * v);\n    ray.o = origin;\n}\n\n\nfloat sunIntensity(float vDotUp) {\n    const float E = 5.0E3;\n    // Empirical, change for whatever else\n    float x = acos(clamp(vDotUp, 0., 1.));\n    return E * max(0., (-pow(.3 * x + .44, 2.) + .86));\n}\n\n// ++++++++++++++++++++++++++++++++++++ End Common ++++++++++++++++++++++++++++++++++++\n\n// ++++++++++++++++++++++++++++++++++++ Sky ++++++++++++++++++++++++++++++++++++\n\n// Total scattering coeffs for air and haze from \"A Practical Analytic Model for Daylight\" at https://courses.cs.duke.edu/fall01/cps124/resources/p91-preetham.pdf\n// Total scattering coeff for air for wave-lengths (650, 570, 475)nm.\n// lambda: wave-lengths we're interested in\nvec3 total_sc_air(vec3 lambda) {\n    vec3 sc;\n#if 0 // we precalculate this as precision here isn't enough. https://shorturl.at/bdrBV\n    vec3 n = vec3(1.0003); // n: Refractive index of air in visible spectrum.\n    vec3 N = vec3(2.545E25); // N: Number of molecules per unit volume for air at 228.15K and 1013mb.\n    vec3 p_n = vec3(0.035); // Standard depolarization factor for air.\n    sc = 8. * PI_CUBED * pow(n * n - 1., vec3(2.)) / (3. * N * pow(lambda, vec3(4.)));\n    sc *= (6. + 3. * p_n) / (6. - 7. * p_n);\n#else\n    sc = vec3(6.95E-06, 1.18E-05, 2.44E-05);\n#endif\n    return sc;\n}\n\n// Total scattering coeff for haze for wave-lengths (650, 570, 475)nm.\nvec3 total_sc_haze(vec3 lambda, float turbidity) {\n    float c = (turbidity * .6544 - .6510) * 1.0E-16; // Concentration factor varying with turbidity\n    vec3 sc;\n#if 0 // we precalculate this as precision here isn't enough. https://shorturl.at/fvGPR\n    vec3 K = vec3(.685, .679, .669); // respectively for wave-lengths (650, 570, 475)nm.\n    vec3 v = 4.; // Junge's exponent for sky.\n    sc = .434 * c * PI * pow(2. * PI / lambda, v - 2.) * K;\n#else\n    sc = vec3(8.72696E+13, 1.12491E+14, 1.59602E+14) * c;\n#endif\n    return sc;\n}\n\n// As proposed by \"Photorealistic Real-Time Outdoor Light Scattering\" at https://renderwonk.com/publications/gdm-2002/GDM_August_2002.pdf\nvoid getCoeffs(out vec3 beta_ex_air, out vec3 beta_ex_haze, \n               out vec3 beta_sc_air, out vec3 beta_sc_haze) {\n    const vec3 lambda = vec3(650., 570., 475.);\n    beta_sc_air = total_sc_air(lambda); \n    const float turbidity = .995;\n    beta_sc_haze = total_sc_haze(lambda, turbidity); // vec3(2.0E-5, 3.0E-5, 4.0E-5);\n    beta_ex_air = beta_sc_air; // beta_ab_air is negligable air molecules have a smaller size than the wave-length of visible light.\n    beta_ex_haze = beta_sc_haze; // beta_ab_haze can vary from 0 to 5.0E-5 and so negligable in practice.\n}\n\nconst float OPTICAL_LENGHT_AIR_ZENITH = 8400.; // m \nconst float OPTICAL_LENGHT_HAZE_ZENITH = 1250.; // m\n\n// cos_theta_s: dot(ray.d, up).\n// s_air optical length of air at given angle.\n// s_haze optical length of haze at given angle.\nvoid opticalLength(float cos_theta_s, inout float s_air, inout float s_haze) {\n    float c = max(cos_theta_s, 0.);\n    float theta_s = acos(c);\n    float f = 1. / (c + .15 * pow(93.885 - theta_s * RAD_TO_DEG, -1.253));\n    s_air = OPTICAL_LENGHT_AIR_ZENITH * f;\n    s_haze = OPTICAL_LENGHT_HAZE_ZENITH * f;\n}\n\nvec3 renderSky(Ray ray, vec3 sunDir, float E) {\n    float cos_theta = dot(ray.d, sunDir);\n    \n    vec3 beta_ex_air, beta_ex_haze;\n    vec3 beta_sc_air, beta_sc_haze;\n    getCoeffs(beta_ex_air, beta_ex_haze, beta_sc_air, beta_sc_haze);\n    \n    // dot(ray.d, -sunDir) flip because assumption is that sunDir is calculated from point on ray to the sun (at \"infinite\" distance). \n    float c = -cos_theta;\n    vec3 beta_sc_air_theta = beta_sc_air * rayleigh(.5 * -c + .5); // flipping again on this one to better match that of HG see https://www.desmos.com/calculator/uz7eqfgmyl\n    vec3 beta_sc_haze_theta = beta_sc_haze * HG_p(c, -1.03);\n    \n    vec3 beta_sc_theta = beta_sc_air_theta + beta_sc_haze_theta;\n    vec3 beta_ex = beta_ex_air + beta_ex_haze;\n    \n    float s_air, s_haze;\n    opticalLength(ray.d.y, s_air, s_haze);\n\n    vec3 F_ex_haze = exp(-beta_ex * s_haze); // haze \"dome\" contains air molecules as well.\n    vec3 F_ex_air = exp(-beta_ex_air * (s_air - s_haze));\n    \n    vec3 L_in = E * beta_sc_theta / beta_ex * (1. - F_ex_haze);\n    L_in *= beta_sc_air_theta / beta_ex_air * (1. - F_ex_air) * F_ex_haze;\n\n    vec3 F_ex = F_ex_haze * F_ex_air;\n    const float sunDiskDiameter = 0.9998;\n    float sunDisk = smoothstep(sunDiskDiameter, sunDiskDiameter + 0.0004, cos_theta);\n    vec3 L0 = E * vec3(sunDisk);\n    \n    return L0 * F_ex + L_in; // in-scattered radiance.\n}\n\n// ++++++++++++++++++++++++++++++++++++ End Sky ++++++++++++++++++++++++++++++++++++\n\n// ++++++++++++++++++++++++++++++++++++ Volume ++++++++++++++++++++++++++++++++++++\nconst int MAX_SAMPLES_ALONG_RAY = 32;\nconst int MAX_SAMPLES_ALONG_LIGHT = 10;\n\n#define WAVELENGTH_DEPENDENT // Meaning that the absorptiona and scattering affect different wavelengths differently.\n#define ANIMATE_DENSITY\n\n#ifdef WAVELENGTH_DEPENDENT\n#define FLOAT vec3\n#else\n#define FLOAT float\n#endif\n\n// These values have are not necessarily phyically correct. \n#ifdef WAVELENGTH_DEPENDENT\nconst vec3 sigma_a = vec3(0., 10., 10.);\nconst vec3 sigma_s = vec3(2., 0., 0.);\nconst vec3 sigma_t = sigma_a + sigma_s;\n#else\nconst float sigma_a = 0.;\nconst float sigma_s = 1.;\nconst float sigma_t = sigma_a + sigma_s;\n#endif\n\nconst float goldenRatio = 1.61803398875;\n\nfloat x2(float x) {\n    return sqrt(2. * x - x * x);\n}\n\n// Play with me!\nfloat density(vec3 p) {\n    // Inspired by https://www.shadertoy.com/view/3sffzj\n    vec2 q = p.xz - vec2(.5);\n    float d = .42 * x2(max(0., 1. - length(4. * q)));\n    q = p.xz - vec2(.5, .3);\n    d = max(d, .37 * x2(max(0., 1. - length(5. * q))));\n    q = p.xz - vec2(.5, .64);\n    d = max(d, .33 * x2(max(0., 1. - length(4.8 * q))));\n    \n    float r = pow(d, .75);\n    float h = p.y;\n    d *= saturate(remap(h, .75 * r, r, 1., 0.));\n    d *= saturate(remap(h, 0., .25 * (1. - d), 0., 1.));\n    \n#ifdef ANIMATE_DENSITY\n    p += .01 * iTime;\n#endif\n    float n0 = .5 * perlinFbm(p * 4., 4., 3) + .5;\n    d = saturate(remap(d, .05 * n0, 1., 0., 1.));\n\n    float n1 = .5 * perlinFbm(p * 6., 4., 4) + .5;\n    d = saturate(remap(d, .25 * n1, 1., 0., 1.));\n\n    return 50. * d;\n}\n\n// Play with me!\nvec3 emissive(vec3 p) {\n    return vec3(0.);\n}\n\n// Play with me!\nvec3 ambient(vec3 p) {\n    return vec3(.6, 0., 0.);\n}\n\nvec3 getSampleIncomingLight(in AABB volume, vec3 E, vec3 sunDir, vec3 p, float phase) {\n    // Cast a ray from sample point in the direction of light.\n    Ray lightRay;\n    lightRay.d = sunDir;\n    lightRay.o = p;\n    float tminLight = 1e7; float tmaxLight = -1e7;\n    float hit1 = rayAABB(lightRay, volume, tminLight, tmaxLight);\n    \n    if (hit1 < 1.) return vec3(0.);\n    \n    float du = tmaxLight / float(MAX_SAMPLES_ALONG_LIGHT); // Ignore tmin as we're inside volume.\n    vec3 stp = sunDir * du;\n\n    // Sample density along the light ray to find out attenuation of incoming light Li (due to absorption and out-scattering) reaching our sample point (taken at current position).\n    // Various methods can be used to approximate this. Brute-force approach is used here.\n    float tau = 0.;\n    vec3 q = p;\n    for (int j = 0; j < MAX_SAMPLES_ALONG_LIGHT; j++) {\n        tau += density(q);\n        q += stp;\n    }\n    FLOAT sampled_sigma_t = tau * sigma_t;\n    FLOAT beer = FLOAT(exp(-sampled_sigma_t * du));\n    // FLOAT powder = FLOAT(1.) - FLOAT(exp(-2. * sampled_sigma_t * du)); // Ignore here but, suggested by \"Real-Time Volumetric Cloudscapes\" by Andrew Schneider in GPU Pro 7 4.1 \n    return E * beer * phase;\n}\n\nvec3 renderCloud(in AABB volume, in Ray ray, float tmin, float tmax, vec3 background, vec3 sunDir, vec3 E, float noise) {\n    float dt = (tmax - tmin) / float(MAX_SAMPLES_ALONG_RAY);\n\n    vec3 L0 = background;\n    vec3 Lo = vec3(0.);\n    // Calculated taking absorption(sigma_a) and out-scattering(sigma_s) into account.\n    FLOAT attenuation = FLOAT(1.);\n    \n    // dot(ray.d, -sunDir) flip because assumption is that sunDir is calculated from point on ray to the sun (at \"infinite\" distance). \n    float cos_theta = dot(ray.d, -sunDir);\n    \n    // The probability of the ray of light to scatter in towards the eye. Capturing in-scattering contribution.\n    // Different phase functions can be used here.\n    float G = .2;\n    float phase = HG(cos_theta, G);\n    \n    float t = tmin + noise * dt;\n    vec3 p = ray.o + t * ray.d;\n    for (int i = 0; i < MAX_SAMPLES_ALONG_RAY; i++) {\n        vec3 Li = vec3(0.);\n        float d = density(p);\n        if (d > 0.) {\n            // (densitry * sigma_s/sigma_t) models non-homogeneous scattering(in/out)/extinction coeff. respectively.\n            FLOAT sampled_sigma_t = sigma_t * d;\n            FLOAT sampled_sigma_s = sigma_s * d;\n            \n            FLOAT beer = exp(-sampled_sigma_t * dt);\n            attenuation *= beer;\n            \n            // This integral can be calculated analytically as suggested in \"Physically Based Sky, Atmosphereand Cloud Rendering in Frostbite\" 5.6\n            Li = ambient(p) + getSampleIncomingLight(volume, E, sunDir, p, phase);\n            Li *= sampled_sigma_s;\n        }\n\n        Lo += (emissive(p) + Li) * attenuation;\n        if (length(attenuation) <= .001) break;\n        \n        t += dt;\n        p = ray.o + t * ray.d;\n    }\n    Lo *= dt;\n    \n    vec3 radiance = L0 * attenuation + Lo;\n    return radiance;\n}\n\n// ++++++++++++++++++++++++++++++++++++ End Volume ++++++++++++++++++++++++++++++++++++\n\nvec3 scene(Ray ray, float noise) {\n    AABB volume;\n    volume.lo = vec3(0.); \n    volume.hi = volume.lo + vec3(1.);\n    \n    vec3 sunDir = normalize(vec3(0., 1., -1.));\n    float sunE = sunIntensity(sunDir.y); // dot(sunDir, UP);\n    \n    vec3 sky = renderSky(ray, sunDir, sunE);\n    \n    float tmin = 1e7; float tmax = -1e7;\n    float hit0 = rayAABB(ray, volume, tmin, tmax);\n    \n    vec3 col = vec3(0.);\n    if (hit0 > 0.) {\n        col += renderCloud(volume, ray, tmin, tmax, sky, sunDir, vec3(sunE / 25.), noise);\n    } else {\n        col += sky;\n    }\n    \n    // Tone-mapping\n    col = col / (vec3(1.) + col);\n    // Gamma correction\n    col = pow(col, vec3(1. / 2.2));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord - iResolution.xy * .5) / iResolution.yy; // y in [-.5, .5]\n    Ray ray;\n    vec2 m = iMouse.xy / iResolution.xy;\n    float y = .6;\n#if 0 // Change to control viewing from up or down with mouse.\n    y = m.y;\n#endif\n    float t = -4. * PI * (m.x - .5) + PI * .5;\n    getRay(p, 1.1 * vec3(sin(t), -2. * (y - .5), cos(t)) + vec3(.5), vec3(.5, .25, .5), tan(35.), ray);\n    \n    // As suggested in https://blog.demofox.org/2020/05/10/ray-marching-fog-with-blue-noise/ and implemented in https://www.shadertoy.com/view/\n#if 1\n    float noise = texture(iChannel0, fragCoord / 1024.0).r;\n    noise = fract(noise + float(iFrame) * goldenRatio);\n#else\n    float noise = InterleavedGradientNoise(fragCoord, iFrame);\n#endif\n    \n    vec3 col = scene(ray, noise);\n    //vec3 col = vec3(density(vec3(fragCoord.x / iResolution.y, 0., fragCoord.y / iResolution.y)));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}