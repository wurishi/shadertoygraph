{"ver":"0.1","info":{"id":"NsSyRt","date":"1643960681","viewed":220,"name":"Psychedelics ","username":"bitblast","description":"Some simple experiments which turned out a little bit psychedelic ","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["simple","psychedelic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Gaussian blur from https://www.shadertoy.com/view/Xltfzj\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float Pi = 6.28318530718; // Pi*2\n    \n    // GAUSSIAN BLUR SETTINGS {{{\n    float Directions = 16.0; // BLUR DIRECTIONS (Default 16.0 - More is better but slower)\n    float Quality = 3.0; // BLUR QUALITY (Default 4.0 - More is better but slower)\n    float Size = 8.0; // BLUR SIZE (Radius)\n    // GAUSSIAN BLUR SETTINGS }}}\n   \n    vec2 Radius = Size/iResolution.xy;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Pixel colour\n    vec4 Color = texture(iChannel0, uv);\n    \n    // Blur calculations\n    for( float d=0.0; d<Pi; d+=Pi/Directions)\n    {\n\t\tfor(float i=1.0/Quality; i<=1.0; i+=1.0/Quality)\n        {\n\t\t\tColor += texture( iChannel0, uv+vec2(cos(d),sin(d))*Radius*i);\t\t\n        }\n    }\n    \n    // Output to screen\n    Color /= Quality * Directions - 15.0;\n    fragColor =  .8 * Color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nfloat hash( uint n ) \n{   // integer hash copied from Hugo Elias\n\tn = (n<<13U)^n; \n    n = n*(n*n*15731U+789221U)+1376312589U;\n    return float(n&uvec3(0x0fffffffU))/float(0x0fffffff);\n}\n\n\n\n// Basic noise\nfloat bnoise( in float x )\n{\n    // setup    \n    float i = floor(x);\n    float f = fract(x);\n    float s = sign(fract(x/2.0)-0.5);\n    \n    // use some hash to create a random value k in [0..1] from i\n  //float k = hash(uint(i));\n  //float k = 0.5+0.5*sin(i);\n    float k = fract(i*.1731);\n\n    // quartic polynomial\n    return s*f*(f-1.0)*((16.0*k-4.0)*f*(f-1.0)-1.0);\n}\n\n// Traditional gradient noise\nfloat gnoise( in float p )\n{\n    uint  i = uint(floor(p));\n    float f = fract(p);\n\tfloat u = f*f*(3.0-2.0*f);\n\n    float g0 = hash(i+0u)*2.0-1.0;\n    float g1 = hash(i+1u)*2.0-1.0;\n    return 2.4*mix( g0*(f-0.0), g1*(f-1.0), u);\n}\n\nvec3 hsv2rgb(vec3 c){\n\tvec4 K=vec4(1.,2./3.,1./3.,3.);\n\treturn c.z*mix(K.xxx,clamp(abs(fract(c.x+K.xyz)*6.-K.w)-K.x, 0., 1.0),c.y);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int COUNT = 3;\nconst float SPEED = .1;\nconst float SIZE_COUNT = 30.;\n\nconst vec2 CENTER[3] = vec2[](\n    vec2(0.0, 0.5),\n    vec2(-.5, -0.5),\n    vec2(0.5, -0.5)\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord;\n    \n    float prod = 1.0;\n    float mn = 1.0;\n    float mx = 0.0;\n    float sz = max(iResolution.x, iResolution.y) / SIZE_COUNT;\n    for (int i = 0; i < COUNT; ++i)\n    {\n        float t = iTime * SPEED;\n        float fi = float(i);\n        vec2 center = CENTER[i];\n        center += 1. * vec2(gnoise(123.0 + fi * 1391.13 + t), gnoise(23.0 + fi * 13091.79 + t));\n        center = (0.5 + 0.5 * center) * iResolution.xy;\n        float val = fract(length(p - center) / sz);\n        prod *= val;\n        mn = min(mn, val);\n        mx = max(mx, val);\n    }\n\n    vec3 col = vec3(sqrt(prod), mn, mx);\n    col.xyz = hsv2rgb(col.xyz);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}