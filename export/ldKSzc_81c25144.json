{"ver":"0.1","info":{"id":"ldKSzc","date":"1465852298","viewed":155,"name":"First RayMarcher - Bombshell93","username":"bombshell93","description":"still learning, thinking of using marching techniques for a voxel engine in browser, for the sake of fiddling","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\n#define MAX_STEPS 128\n#define MIN_DIST 0.01\n#define FAR_PLANE 512.0\n#define FRAME_CLAMP 1000.0\n#define AO_RES_COUNT 8\n#define AO_DISTANCE 2.0\n#define SHADOW_RES_COUNT 8\n#define eye vec3(0.0, -24.0, 0.0)\n#define forward vec3(0.0, 1.0, 0.0)\n#define right vec3(1.0, 0.0, 0.0)\n#define up vec3(0.0, 0.0, 1.0)\n#define focal 2.0\n#define frame (float(iFrame) - FRAME_CLAMP * floor(float(iFrame) / FRAME_CLAMP)) / FRAME_CLAMP\n#define ambientLightColor vec3(0.14, 0.1, 0.2);\n#define lightANormal normalize(vec3(0.4, -0.4, 0.8))\n#define lightAColor vec3(0.2, 0.2, 0.2)\n#define lightBNormal normalize(vec3(cos(frame * PI * 4.0), 1.0, sin(frame * PI * 4.0)))\n#define lightBColor vec3(0.8, 0.8, 0.8)\n\nfloat opU(float d1, float d2) {\n    return min(d1, d2);\n}\n\nvec3 opTranslate(vec3 p, vec3 t) {\n    return p - t;\n}\n\nfloat sdPlane(vec3 p, vec3 n) {\n    return dot(p, n);\n}\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\nfloat sceneDistance(vec3 p) {\n    float res = sdSphere(\n        opTranslate(p, vec3(0.0, 1.0, 0.0)), 1.0);\n    res = opU(sdSphere(\n        opTranslate(p, vec3(frame * 120.0 - 60.0, 9.0, cos(frame * PI * 4.0) * 8.0)), 8.0), res);\n    res = opU(sdPlane(\n        opTranslate(p, vec3(0.0, 0.0, -2.0)), up), res);\n    res = opU(sdBox(\n        opTranslate(p, vec3(cos(frame * PI * 2.0) * 12.0, sin(frame * PI * 2.0) * 12.0, -1.0)), vec3(1.0, 1.0, 1.0)), res);\n    return res;\n}\n\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        sceneDistance(p + vec3(MIN_DIST, 0.0, 0.0)) -\n        sceneDistance(p - vec3(MIN_DIST, 0.0, 0.0)),\n        sceneDistance(p + vec3(0.0, MIN_DIST, 0.0)) -\n        sceneDistance(p - vec3(0.0, MIN_DIST, 0.0)),\n        sceneDistance(p + vec3(0.0, 0.0, MIN_DIST)) -\n        sceneDistance(p - vec3(0.0, 0.0, MIN_DIST))\n                     ));\n}\n\nfloat getAO(vec3 p, vec3 n) {\n    float ao = 1.0;\n    for (int i = 0; i < AO_RES_COUNT; i++) {\n        float s = float(i + 1) / float(AO_RES_COUNT);\n        float is = 1.0 - s;\n        float l = AO_DISTANCE * s;\n        float res = 1.0 - clamp(sceneDistance(p + n * l), 0.0, l) / l;\n        ao -= res / float(AO_RES_COUNT);\n    }\n    return ao;\n}\n\nfloat getShadow(vec3 p, vec3 n, float d) {\n    float ao = 1.0;\n    for (int i = 0; i < AO_RES_COUNT; i++) {\n        float s = float(i + 1) / float(AO_RES_COUNT);\n        float is = 1.0 - s;\n        float l = d * s;\n        float res = 1.0 - clamp(sceneDistance(p + n * l), 0.0, l) / l;\n        ao -= res / float(AO_RES_COUNT);\n    }\n    return ao;\n}\n\nvec3 getLight(vec3 p, vec3 n) {\n    vec3 surface = ambientLightColor;\n    vec3 lightA = lightAColor * clamp(dot(n, lightANormal), 0.0, 1.0);\n    lightA *= getShadow(p, lightANormal, 16.0);\n    surface += clamp(lightA, 0.0, 1.0);\n    vec3 lightB = lightBColor * clamp(dot(n, lightBNormal), 0.0, 1.0);\n    lightB *= getShadow(p, lightBNormal, 16.0);\n    surface += clamp(lightB, 0.0, 1.0);\n    return clamp(surface, 0.0, 1.0);\n}\n\nvec3 render(vec3 o, vec3 f) {\n    float l = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = o + f * l;\n        float d = sceneDistance(p);\n        if (d < MIN_DIST || (i >= MAX_STEPS - 1 && d < MIN_DIST * 2.0)) {\n            vec3 n = getNormal(p);\n            float ao = getAO(p, n);\n            vec3 light = getLight(p, n);\n            return light * (ao * 0.4 + 0.6) * ((FAR_PLANE - l) / FAR_PLANE);\n        }\n        l += d + MIN_DIST;\n    }\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy * 2.0 / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 p = eye + forward * focal + right * uv.x + up * uv.y;\n    vec3 f = normalize(p - eye);\n\tfragColor = vec4(render(p, f), 1.0);\n}","name":"Image","description":"","type":"image"}]}