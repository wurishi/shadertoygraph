{"ver":"0.1","info":{"id":"WsXczH","date":"1584103816","viewed":189,"name":"The core of mandelbox fractal","username":"Cewein","description":"a fly trought the core of the mandel box fractal","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","fractal","color","fog","realtime"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MARCHING_STEP 256\n\n/////\n// SDF Operation function\n/////\n\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return q;\n}\n\n/////\n// Scene and primitive SDF function\n/////\n\nvoid sphereFold(inout vec3 z, inout float dz)\n{\n\tfloat r2 = dot(z,z);\n\tif (r2 < 0.5)\n    { \n\t\tfloat temp = 2.0;\n\t\tz *= temp;\n\t\tdz*= temp;\n\t}\n    else if (r2 < 1.0)\n    { \n\t\tfloat temp = 1.0 / r2;\n\t\tz *= temp;\n\t\tdz*= temp;\n\t}\n}\n\nvoid boxFold(inout vec3 z, inout float dz)\n{\n\tz = clamp(z, -1.0, 1.0) * 2.0 - z;\n}\n\nfloat DE(vec3 z)\n{\n    float scale = 3.0;\n\tvec3 offset = z;\n\tfloat dr = 1.0;\n\tfor (int n = 0; n < 10; n++)\n    {\n\t\tboxFold(z,dr);\n\t\tsphereFold(z,dr);\n        z = scale * z + offset;\n        dr = dr * abs(scale) + 0.0;\n\t}\n\tfloat r = length(z);\n\treturn r / abs(dr);\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n\n  \n    float res = DE(samplePoint);\n    //res += sdPlane(-0.5, vec4(0.,1.,0.,1.));\n    return res;\n   \n}\n\n\n/////\n// Ray function\n/////\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget, float fov)\n{\n    // Calculate camera's \"orthonormal basis\", i.e. its transform matrix components\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n     \n    float fPersp = 0.5 / tan(radians(fov)/ 2.0);\n    vec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n \n    return vDir;\n}\n\nvec3 rayDir(float fov, vec2 size, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - size/2.0;\n    float z = size.y * 0.5 / tan(radians(fov)/ 2.0);\n    return normalize(vec3(xy,-z));\n}\n\nvec2 normalizeScreenCoords(vec2 screenCoord)\n{\n    vec2 result = 2.0 * (screenCoord/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    return result;\n}\n\n/////\n// Marching function\n/////\n\nfloat march(vec3 pos, vec3 direction, float start, float end, inout int i)\n{\n    float depth = start;\n    for(i = 0; i < MARCHING_STEP; i++)\n    {\n        float dist =  sceneSDF(pos + direction * depth);\n        if(dist < 0.0001f)\n        {\n            return depth;\n        }\n        depth += dist;\n        if(depth >= end)\n            return end;\n    }\n    return depth;\n}\n\n\n/////\n// Main function\n/////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 at = vec3(0, 0, 0);\n    vec2 uv = normalizeScreenCoords(fragCoord);\n    vec3 pos = vec3(cos(iTime/10.) * 1.75 ,sin(iTime/15.),sin(iTime/10.) * 1.75);\n    \n    int i = 0;\n    \n    vec3 dir = getCameraRayDir(uv, pos, at, 45.f);\n    \n    float dist = march(pos, dir, 0.01f,400.f, i);\n    vec3 col = vec3(dist);\n\n    col = vec3(0.75 + sin(iTime/10.), 0.515, 0.053 + cos(iTime/10.)) * float(i)/float(MARCHING_STEP);\n    \n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}