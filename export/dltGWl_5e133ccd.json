{"ver":"0.1","info":{"id":"dltGWl","date":"1683467448","viewed":778,"name":"subsurface lighting model","username":"Poisson","description":"A subsurface scattering (sss) lut lighting model\nFeatures: lambert, preintegrated sss, blinn, ggx, roughness, schlick fresnel, ior","likes":69,"published":1,"flags":0,"usePreview":1,"tags":["3d","raytracing","sss","raytracer","ray","volume","sphere","volumetric","specular","scattering","subsurface","aa","brdf","skin","scatter","ggx","human","bsdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// top -> skin material with variable sss radius\n// bottom -> leave material with variable sss radius\n\n#define AA 3 // antialiasing\n\n// ray sphere intersection function\n// thanks to iq: https://iquilezles.org/articles/intersectors/\nfloat sphIntersect(vec3 ro, vec3 rd, vec3 ce, float ra) {\n    vec3 oc = ro - ce;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - ra*ra;\n    float h = b*b - c;\n    \n    if(h<0.) return -1.;\n    return -b - sqrt(h);\n}\n\n// intersection function\nfloat intersect(vec3 ro, vec3 rd, float tmax, out vec3 on, out int oid) {\n    float t = tmax;\n    \n    for (int i=0; i<10; i++) {\n        vec3 ce = vec3((i%5)*2-4, i/5*2-1, 0); // sphere center\n        float h = sphIntersect(ro, rd, ce, .95);\n        if (h>0. && h<t) {\n            on = normalize(ro-ce + rd*h); // normal\n            oid = i;\n            t = h;\n        }\n    }\n\n    return t<tmax ? t : -1.;\n}\n\n// my subsurface scattering lighting model\n// lambert + preintegrated sss + blinn ggx + shlick\n\n// type -> type of diffusion model\n// n -> normal\n// l -> light direction\n// rd -> ray direction\n// kl -> light color\n// kd -> diffuse color\n// ks -> subsurface color\n// ksr -> subsurface radius\n// km -> roughness / microfacet amount\n// kn -> refraction index\nvec3 lighting(int type, vec3 n, vec3 l, vec3 rd, vec3 kl, vec3 kd, vec3 ks, vec3 ksr, float km, float kn) {\n    float ndl = dot(n, l); // diffuse lambert / N⋅L\n    float pndl = clamp( ndl, 0., 1.), // positive ndl\n          nndl = clamp(-ndl, 0., 1.); // negative ndl\n          \n    // subsurface scattering\n    vec3 sss;\n    if (type==0) // exponential\n        sss = .2 * pow(vec3(1.-pndl), 3./(ksr+.001)) * \n                   pow(vec3(1.-nndl), 3./(ksr+.001));\n    else // gaussian         \n        sss = .2 * exp(-3.*(nndl + pndl)/(ksr+.001));\n   \n    vec3 h = normalize(l - rd); // half vector\n    float ndh = dot(n, h); // N⋅H\n    \n    // ggx / Trowbridge and Reitz specular model approximation\n    float g = ndh*ndh * (km*km - 1.) + 1.;\n    float ggx = km*km / (3.141592*g*g);\n\n    // shlick approximation\n    float fre = 1.+dot(rd, n); // fresnel\n    // fresnel amount\n    float f0 = (kn-1.)/(kn+1.);\n          f0 = f0*f0;\n    float kr = f0 + (1.-f0)*(1.-km)*(1.-km) * pow(fre, 5.); // reflectivity\n\n    return kl*(pndl*(kd + kr*ggx) + kd*ks*ksr*sss); // diffuse + sss + specular\n}\n\n// rendering\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = vec3(.5+.5*rd.y)*.025; // background\n    \n    vec3 n; int id;\n    float t = intersect(ro, rd, 1e10, n, id);\n    \n    if (t>0.) {\n        vec3 p = ro + rd*t; // hit point\n                                \n        vec3 difCol;\n        vec3 sssCol;\n        vec3 sssRad;\n        float sssDif;\n        float rou;\n        float ior;\n        int type;\n                \n        int row = id/5;\n        if (row==1) { // skin material\n            difCol = vec3(.6,.45,.25);\n            sssCol = vec3(.75);\n            sssRad = float(id%5)/3.*vec3(1,.25,.04);\n            rou = .1;\n            ior = 1.5;\n            type = 1;\n        } else { // leave material\n            difCol = vec3(.5,.6,.2);\n            sssCol = vec3(.6);\n            sssRad = float(id%5)/3.*vec3(.6,1,.06);\n            rou = .1;\n            ior = 1.5;\n            type = 1;\n        }\n                        \n        col = lighting(type, n,          normalize(vec3(1,1,1)), rd,   vec3(1), difCol, sssCol, sssRad, rou, ior) + // key light\n              lighting(type, n, normalize(vec3(-1,.4,.5)-.1*ro), rd, vec3(.25), difCol, sssCol, sssRad, rou, ior);  // rim light\n    }\n        \n    return col;\n}\n\n// camera function\nmat3 setCamera(vec3 ro, vec3 ta) {\n    vec3 w = normalize(ta - ro); // forward vector\n    vec3 u = normalize(cross(w, vec3(0,1,0))); // up vector\n    vec3 v = cross(u, w); // side vector\n    return mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized mouse coordinates\n    vec2 mo = (iMouse.xy - .5*iResolution.xy)/iResolution.y;\n\n    float an = .6*iTime + mo.x*3.141592; // camera xz rotation\n    vec3 ro = 18.*vec3(sin(an),0,cos(an)); // ray origin\n    vec3 ta = vec3(0); // target\n    mat3 ca = setCamera(ro, ta); // camera matrix\n    \n    vec3 tot = vec3(0);\n    for (int m=0; m<AA; m++)\n    for (int n=0; n<AA; n++) {\n        vec2 off = vec2(m,n) / float(AA) - .5; // AA offset\n        vec2 p = (fragCoord+off - .5*iResolution.xy) / iResolution.y;\n        \n        vec3 rd = ca * normalize(vec3(p,3)); // ray direction\n        vec3 col = render(ro, rd); // render\n                \n        col = 1.9*col/(.8+2.5*col); // tonemapping\n        col = pow(col, vec3(.4545)); // gamma correction\n        \n        tot += col;\n    }\n    tot /= float(AA*AA);\n    \n    // vignette\n    vec2 q = fragCoord/iResolution.xy;\n    tot *= .3+.7*pow(16. * q.x*q.y*(1.-q.x)*(1.-q.y), .1);\n\n    // output\n    fragColor = vec4(tot,1.0);\n}","name":"Image","description":"","type":"image"}]}