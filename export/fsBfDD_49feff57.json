{"ver":"0.1","info":{"id":"fsBfDD","date":"1646297665","viewed":451,"name":"You Can Draw This!","username":"GraphXDoses","description":"Recreation of an inspirational image I found online.\nYou can find it here: [url]https://www.instagram.com/p/CZGVt4rluZM/?utm_medium=copy_link[/url]","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["space","vector","reproduction","shuttle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Numericals\nconst float PI              = acos(-1.);\nconst int   N               = 5;\nconst float PORTHOLE_RADIUS = 0.384318;\nconst float MOON_RADIUS     = 0.1886;\n\n// Macros\n#define saturate(x) clamp(x, 0., 1.)\n#define nlerp(t0, t1, t) saturate((t-t0)/(t1-t0))\n#define hexToRGB(c) vec3(c >> 16, (c >> 8) & 255, c & 255) / 255.\n#define gamma(fc, p) vec3(pow(fc.r, p), pow(fc.g, p), pow(fc.b, p))\n\n// Colors\nconst vec3 BG_COLOR         = hexToRGB(0x14083e);\nconst vec3 MOONLIGHT        = hexToRGB(0xD7584B);\nconst vec3 FG_CLOUDS_COLOR  = hexToRGB(0x5644aa);\nconst vec3 BG_CLOUDS_COLOR  = hexToRGB(0x392885);\nconst vec3 TANK_LIGHT_COLOR = hexToRGB(0xfe692f);\nconst vec3 TANK_DARK_COLOR  = hexToRGB(0xbe296a);\nconst vec3 TANK_DIM_COLOR   = hexToRGB(0xcd3727);\n\n// pos.x | pos.y | radius | type (circle / rhombus cross)\nconst vec4 STARSLIST[6] = vec4[6](\n    vec4( -0.226219, 0.140216, 0.00653, 0. ),\n    vec4( 0.180735, -0.004926, 0.00653, 0. ),\n    vec4( 0.128233, 0.255306, 0.00653, 0. ),\n    vec4( -0.104637, 0.267436, 0.0248, 1. ),\n    vec4( -0.216575, 0.007798, 0.0248, 1. ),\n    vec4( 0.225164, 0.137904, 0.0428, 1. )\n);\n\n// Structures\nstruct SpaceShuttle\n{\n    float tank;\n    float miscParts;\n    float shadow;\n    float colorGradient;\n    float wakeHalo;\n    float wakeSDF;\n    vec2  position;\n};\n\nstruct LunarObject\n{\n    float body;\n    float craters;\n    vec2  position;\n};\n\nstruct StarArray\n{\n    float bodies;\n    float radiance;\n};\n\nstruct CloudArray\n{\n    float[2] formation;\n    float[2] shadow;\n    vec2[2]  position;\n};\n\n// Utility Functions\nvoid toMask(inout float sdf) { sdf = saturate(smoothstep(fwidth(sdf), -fwidth(sdf), sdf)); }\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat cro( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nmat2 rotationMatrix(float a) { float c = cos(a), s = sin(a); return mat2( c, -s, s,  c ); }\n\nfloat smin(float a, float b, float k) {\n    float h = saturate(0.5 + 0.5*(a-b)/k);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat expSustainedImpulse( float x, float f, float k )\n{\n    float s = max(x-f,0.0);\n    return min( x*x/(f*f), 1.+(2.0/f)*s*exp(-k*s));\n}\n\n// SDF's\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = saturate( dot(pa,ba)/dot(ba,ba) );\n    return length( pa - ba*h );\n}\n\nfloat sdPolygon( in vec2[N] v, in vec2 cs )\n{\n    float d = dot(cs-v[0],cs-v[0]);\n    float s = 1.0;\n    for( int i=0, j=N-1; i<N; j=i, i++ )\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w =    cs - v[i];\n        vec2 b = w - e*saturate( dot(w,e)/dot(e,e) );\n        d = min( d, dot(b,b) );\n        bvec3 c = bvec3(cs.y>=v[i].y,cs.y<v[j].y,e.x*w.y>e.y*w.x);\n        if( all(c) || all(not(c)) ) s*=-1.0;\n    }\n    return s*sqrt(d);\n}\n\nfloat sdBox( in vec2 cs, in vec2 size )\n{\n    vec2 d = abs(cs)-size;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdBezier( in vec2 cs, in vec2 A, in vec2 B, in vec2 C )\n{\n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - cs;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n    float kz = kk * dot(d,a);\n\n    float res = 0.0;\n    float sgn = 0.0;\n\n    float p  = ky - kx*kx;\n    float q  = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float p3 = p*p*p;\n    float q2 = q*q;\n    float h  = q2 + 4.0*p3;\n\n    if( h>=0.0 )\n    {   // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n\n        #if 0\n        if( abs(p)<0.001 )\n        {\n            float k = p3/q;\n            x = vec2(k,-k-q);\n        }\n        #endif\n\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = saturate( uv.x+uv.y-kx );\n        vec2  q = d+(c+b*t)*t;\n        res = dot2(q);\n    \tsgn = cro(c+2.0*b*t,q);\n    }\n    else\n    {   // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = saturate( vec3(m+m,-n-m,n-m)*z-kx );\n        vec2  qx=d+(c+b*t.x)*t.x; float dx=dot2(qx), sx = cro(c+2.0*b*t.x,qx);\n        vec2  qy=d+(c+b*t.y)*t.y; float dy=dot2(qy), sy = cro(c+2.0*b*t.y,qy);\n        if( dx<dy ) { res=dx; sgn=sx; } else {res=dy; sgn=sy; }\n    }\n\n    return sqrt( res )*sign(sgn);\n}\n\nfloat sdHalfMoon(vec2 cs, float d, float ra, float rb )\n{\n    cs.y = abs(cs.y);\n\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(cs.x*b-cs.y*a) > d*d*max(b-cs.y,0.0) )\n    {\n        return length(cs-vec2(a,b));\n    }\n\n    return max( (length(cs          )-ra),\n               -(length(cs-vec2(d,0))-rb));\n}\n\nfloat sdRhombus( in vec2 cs, in vec2 size )\n{\n    cs = abs(cs);\n\n    float h = clamp( ndot(size-2.0*cs,size)/dot(size,size), -1.0, 1.0 );\n    float d = length( cs-0.5*size*vec2(1.0-h,1.0+h) );\n\treturn d * sign( cs.x*size.y + cs.y*size.x - size.x*size.y );\n}\n\nfloat sdPie( in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p-c*clamp(dot(p,c),0.0,r)); // c=sin/cos of aperture\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\n// Helper Functions\nfloat Nosecone(in vec2 cs, in float scale, in float bevel)\n{\n    scale -= bevel;\n    vec2 pts[3] = vec2[3](\n        vec2(1.0, 0.0)*scale,\n        vec2(1.0, 1.3857)*scale,\n        vec2(0.0, 2.1765)*scale\n    );\n\n    vec2 p = cs-vec2(0., bevel);\n\n    p.x = abs(p.x);\n    p.y = (step(0., p.y)) * p.y;\n\n    float bz = sdBezier(p, pts[0], pts[1], pts[2])-bevel;\n\n    p = cs;\n\n    float bbox = sdBox(p-vec2(0., 0.1), vec2(pts[0].x+0.1, 0.1));\n    return max(bz, bbox);\n}\n\nfloat Boosters(in vec2 cs)\n{\n    cs.x = abs(cs.x);\n    float body = sdSegment(cs, vec2(0.06829, 0.079), vec2(0.06829, -0.17))-0.033,\n    cone = Nosecone(cs-vec2(0.06829, 0.079), 0.033, 0.);\n\n    return min(body, cone);\n}\n\n// Object Designing Functions\nvoid FormClouds( in vec2 cs, inout CloudArray obj )\n{\n\n    obj.position[0] = mix(vec2(0., -.25), vec2(0), expSustainedImpulse( nlerp(2.8, 3.5, mod(iTime, 10.)) , 0.74, 10.));\n    obj.position[1] = mix(vec2(0., -.25), vec2(0), expSustainedImpulse( nlerp(2.8, 3.95, mod(iTime, 10.)) , 0.74, 10.));\n\n    vec3 arr[10] = vec3[10](\n        vec3(-0.224562, -0.313225, 0.0975),\n        vec3(-0.081899, -0.38081, 0.0975),\n        vec3(0.031943, -0.311784, 0.0975),\n        vec3(0.164519, -0.341613, 0.0975),\n        vec3(0.32713, -0.2918, 0.12205),\n        vec3(-0.32579, -0.235356, 0.10509),\n        vec3(-0.175382, -0.28159, 0.10509),\n        vec3(0.007227, -0.240088, 0.10509),\n        vec3(0.160689, -0.191561, 0.087916),\n        vec3(0.244249, -0.254446, 0.087916)\n    );\n\n    int zIndex = 0;\n    obj.formation[0] = length(cs-obj.position[0]-arr[0].xy)-arr[0].z;\n    obj.formation[1] = length(cs-obj.position[1]-arr[5].xy)-arr[5].z;\n    obj.shadow[0] = (cs.y+0.38) * 1./0.166;\n    obj.shadow[1] = (cs.y+0.3) * 1./0.166;\n\n    for (int i=1; i<10; i++)\n    {\n        if (i == 5) continue;\n        zIndex = int(i>4);\n        obj.formation[zIndex] = min(obj.formation[zIndex], length(cs-obj.position[zIndex]-arr[i].xy)-arr[i].z);\n    }\n    toMask(obj.formation[0]);\n    toMask(obj.formation[1]);\n}\n\nvoid FormStars( in vec2 cs, in float res, inout StarArray obj )\n{\n    const vec2 nScale = vec2(0.213, 0.977);\n    float v, h, sc, k = 22.789;\n\n    for (int i=0; i<6; i++)\n    {\n        if (STARSLIST[i].w == 0.)\n        {\n            h = length(cs-STARSLIST[i].xy) - STARSLIST[i].z;\n        } else {\n            if( i==3 )\n            {\n                obj.radiance = length(cs-STARSLIST[i].xy);\n            } else {\n                obj.radiance = min(obj.radiance, length(cs-STARSLIST[i].xy));\n            }\n\n            sc = expSustainedImpulse(nlerp(3., 4.+0.75*float(i-3), mod(iTime, 10.)), 0.3, 10.);\n\n            v = sdRhombus(cs-STARSLIST[i].xy, nScale.xy * STARSLIST[i].z*sc);\n            h = sdRhombus(cs-STARSLIST[i].xy, nScale.yx * STARSLIST[i].z*sc);\n            h = smin(h, v, k * STARSLIST[i].z * 0.01);\n        }\n\n        obj.bodies = i == 0 ? h : min(obj.bodies, h);\n    }\n\n    obj.bodies = 1. - smoothstep(-(1./res)*4., (1./res)*4., obj.bodies);\n    obj.radiance   = (1. - smoothstep(0., 0.15, obj.radiance)) * 0.5;\n}\n\nvoid FormMoon( in vec2 cs, inout LunarObject obj )\n{\n    obj.position = mix(vec2(0.206, 0.3475)*1.5, vec2(0.206, 0.3475), nlerp(1.75, 2.75, mod(iTime, 10.)));\n    vec2 d1 = vec2(0.9248, -0.3803);\n    float l1 = length(obj.position.xy) - MOON_RADIUS;\n    float c = length(cs-obj.position) - MOON_RADIUS;\n\n    obj.position.xy = normalize(obj.position.xy) * l1;\n    obj.body = sdSegment(cs, obj.position.xy-d1*.3, obj.position.xy+d1*.3);\n\n    obj.body = (1. - smoothstep(0., 0.16, obj.body))*length(obj.position.xy)*5.;\n    obj.body = saturate(obj.body);\n    toMask(c);\n    obj.body *= c;\n\n    vec3 pos[3] = vec3[3](\n        vec3(0.090, 0.310, -1.1),\n        vec3(0.206, 0.267, -4.25),\n        vec3(0.164, 0.194, -4.25)\n    );\n    vec2 tp;\n\n    for (int i=0; i<3; i++)\n    {\n        tp = cs;\n        tp -= pos[i].xy;\n        tp *= rotationMatrix(pos[i].z);\n        if (i == 0)\n        {\n            obj.craters = sdHalfMoon(tp, 0.008, 0.029/2., 0.029/2.);\n        } else {\n            obj.craters = min(obj.craters, sdHalfMoon(tp, 0.008, 0.029/2., 0.029/2.));\n        }\n    }\n    toMask(obj.craters);\n}\n\n\n\nvoid FormShuttle(in vec2 cs, in float res, inout SpaceShuttle obj)\n{\n    obj.position = mix(vec2(0., -.7), vec2(0), nlerp(0.75, 1.75, mod(iTime, 10.)));\n    cs -= obj.position;\n    //obj.colorGradient = saturate((cs.y+0.07)*1./0.286);\n    obj.colorGradient = saturate(pow(cs.y+0.12, 2.)*10.);\n\n    float offset = 0.04;\n    vec2 WING_PROFILE[5] = vec2[5](\n        vec2(0.141, -0.224)  - vec2(offset, offset/2.),\n        vec2(0.141, -0.164)  - vec2(offset, offset/2.),\n        vec2(0.,   -0.0372)  - vec2(0., offset + offset/2.),\n        vec2(-0.141, -0.164) + vec2(offset, -offset/2.),\n        vec2(-0.141, -0.224) + vec2(offset, -offset/2.)\n    );\n\n    float wings = sdPolygon(WING_PROFILE, cs)-offset,\n    boosters = Boosters(cs),\n    cone = Nosecone(cs-vec2(0., 0.145), 0.053, 0.01),\n    bbox = sdBox(cs, vec2(0.15, 0.224));\n\n    obj.tank = sdSegment(cs, vec2(0., 0.145), vec2(0., -0.104)) - 0.053;\n    obj.tank = min(obj.tank, cone);\n    cone = Nosecone(cs-vec2(0., 0.018), 0.035, 0.01);\n    wings = max(wings, bbox);\n    obj.miscParts = sdSegment(cs, WING_PROFILE[2], vec2(0., 0.018)) - 0.035;\n    obj.miscParts = smin(wings, obj.miscParts, offset/2.);\n    obj.miscParts = min(cone, obj.miscParts);\n    boosters = max(boosters, -(min(obj.miscParts, obj.tank)-.01));\n\n    obj.shadow = obj.tank+0.005;\n    toMask(obj.shadow);\n    toMask(obj.tank);\n    obj.shadow *= smoothstep(-(1./res)*6., (1./res)*6., cs.x);\n    obj.miscParts = min(obj.miscParts, boosters);\n    toMask(obj.miscParts);\n\n    cs.y = clamp(cs.y, -0.4, 1.);\n\n    float wake = sdSegment(cs, vec2(0., -PORTHOLE_RADIUS), vec2(0., -0.2)) -0.006*pow(cs.y+.9, -5.);\n    obj.wakeSDF = wake;\n\n    float lowPressWake = sdSegment(cs, vec2(0., -PORTHOLE_RADIUS), vec2(0., -0.2)) -0.006*pow(cs.y+1.28, -20.);\n    obj.wakeHalo = max(length(cs), lowPressWake);\n    obj.wakeHalo = smoothstep(PORTHOLE_RADIUS, 0., obj.wakeHalo)*step(0., cs.x);\n    toMask(lowPressWake);\n    toMask(wake);\n    obj.wakeHalo *= 1.-lowPressWake;\n    obj.wakeHalo *= wake * 0.65;\n}\n\nfloat FormWord(in vec2 cs, in float word, in int id)\n{\n    float scale = 15.;\n    cs *= scale;\n    vec2 p = cs;\n    float bb, c, thickness = 4e-3*scale;\n    if (id == 0)\n    {\n        // Y\n        p.x += 1.2;\n        bb = sdBox(p, vec2(0.5));\n        p.x = abs(p.x);\n        c = sdSegment(p, vec2(0.55, 0.68), vec2(0., 0.));\n        c = min(c, sdSegment(p, vec2(0), vec2(0., -0.55)));\n        c = max(abs(c) - thickness, bb);\n        word = min(word, c);\n\n        // O\n        p = cs;\n        bb = sdBox(p, vec2(0.5));\n        c = length(p)-.5+thickness;\n        c = max(abs(c) - thickness, bb);\n        word = min(word, c);\n\n        // U\n        p = cs;\n        p.x -= 1.2;\n        bb = sdBox(p, vec2(0.5));\n        c = sdSegment(p, vec2(0., 1.), vec2(0., -.0))-.5+thickness;\n        c = max(abs(c) - thickness, bb);\n        word = min(word, c);\n    } else if (id == 1) {\n        // C\n        p.x += 1.;\n        bb = sdBox(p, vec2(0.5));\n        p *= rotationMatrix(-PI/2.);\n        c = length(p)-.5+thickness*2.;\n        c = max(-c, sdPie(p, vec2(sin(PI*3./4.), cos(PI*3./4.)), 0.5));\n        c = max(c, bb);\n        word = min(word, c);\n\n        // A\n        p = cs;\n        bb = sdBox(p, vec2(0.5));\n        p.x = abs(p.x);\n        c = sdSegment(p, vec2(0.5, -0.7), vec2(0., 0.5))-thickness;\n        c = min(c, sdSegment(p, vec2(0.25, -0.2), vec2(0., -0.2))-thickness);\n        c = max(c, bb);\n        word = min(word, c);\n\n        // N\n        p = cs;\n        p.x -= 1.2;\n        bb = sdBox(p, vec2(0.5));\n        p.x = abs(p.x);\n        c = sdSegment(p, vec2(0.5-thickness, -.5), vec2(0.5-thickness, .5))-thickness;\n        p.x = cs.x-1.2;\n        c = min(c, sdSegment(p, vec2(-0.5, 0.55), vec2(0.5, -0.55))-thickness);\n        c = max(c, bb);\n        word = min(word, c);\n    } else if (id == 2) {\n        // D\n        p.x += 1.7;\n        bb = sdBox(p, vec2(0.45, 0.5));\n        c = sdSegment(p, vec2(0), vec2(-0.5, 0.))-.5+thickness;\n        c = max(c, bb);\n        word = min(word, abs(c)-thickness);\n\n        // R\n        p = cs;\n        p.x += 0.5;\n        bb = sdBox(p, vec2(0.4, 0.5));\n        c = sdSegment(p, vec2(0.18, 0.25), vec2(-0.5, 0.25))-.25+thickness/2.;\n        c = max(c, bb);\n        word = min(word, abs(c)-thickness);\n        bb = sdBox(p, vec2(0.4+thickness, 0.5));\n        c = max(-c, sdSegment(p, vec2(-0.4, 0.25), vec2(-0.4, -0.55))-thickness);\n        c = min(c, sdSegment(p, vec2(0.1, 0.), vec2(0.4, -0.55))-thickness);\n        c = max(c, bb);\n        word = min(word, c);\n\n        // A\n        p = cs;\n        p.x -= 0.5;\n        bb = sdBox(p, vec2(0.5));\n        p.x = abs(p.x);\n        c = sdSegment(p, vec2(0.5, -0.7), vec2(0., 0.5))-thickness;\n        c = min(c, sdSegment(p, vec2(0.25, -0.2), vec2(0., -0.2))-thickness);\n        c = max(c, bb);\n        word = min(word, c);\n\n        // W\n        p = cs;\n        p.x -= 1.7;\n        bb = sdBox(p, vec2(0.675, 0.5));\n        p.x = abs(p.x);\n        c = sdSegment(p, vec2(0.3, -0.45), vec2(0., 0.5))-thickness;\n        c = min(c, sdSegment(p, vec2(0.3, -0.45), vec2(0.6, 0.5))-thickness);\n        c = max(c, bb);\n        word = min(word, c);\n    } else if (id == 3) {\n        // T\n        p.x += 1.5;\n        bb = sdBox(p, vec2(0.45, 0.5));\n        c = sdSegment(p, vec2(-0.5, 0.5-thickness), vec2(0.5, 0.5-thickness))-thickness;\n        c = min(c, sdSegment(p, vec2(0., -0.7), vec2(0., 0.5))-thickness);\n        c = max(c, bb);\n        word = min(word, c);\n\n        // H\n        p = cs;\n        p.x += 0.5;\n        bb = sdBox(p, vec2(0.45, 0.5));\n        p.x = abs(p.x);\n        c = sdSegment(p, vec2(0.45-thickness, 0.5), vec2(0.45-thickness, -0.5))-thickness;\n        c = min(c, sdSegment(p, vec2(0.45-thickness, thickness), vec2(0., thickness))-thickness);\n        c = max(c, bb);\n        word = min(word, c);\n\n        // I\n        p = cs;\n        p.x -= 0.4;\n        bb = sdBox(p, vec2(0.45, 0.5));\n        c = sdSegment(p, vec2(0., 0.5), vec2(0., -0.5))-thickness;\n        c = max(c, bb);\n        word = min(word, c);\n\n        // S\n        c = 1.;\n        p = cs;\n        p.x -= 1.1;\n        bb = sdBox(p, vec2(0.5));\n        vec2 pts[9] = vec2[9](\n            vec2(0.356, 0.317),\n            vec2(-0.1, 0.589-thickness/1.4),\n            vec2(-0.30, 0.348-(thickness/2.)),\n            vec2(-0.42, 0.02+thickness/3.),\n            vec2(0., 0.+thickness/3.),\n            vec2(0.48, 0.+thickness/3.),\n            vec2(0.35, -0.323+thickness/2.),\n            vec2(0., -0.615)+thickness/2.,\n            vec2(-0.41, -0.3)+thickness/2.\n        );\n        int i = 0;\n        c = min(c, abs(sdBezier(p, pts[0], pts[1], pts[2]))-thickness);\n        c = min(c, abs(sdBezier(p, pts[2], pts[3], pts[4]))-thickness);\n        c = min(c, abs(sdBezier(p, pts[4], pts[5], pts[6]))-thickness);\n        c = min(c, abs(sdBezier(p, pts[6], pts[7], pts[8]))-thickness);\n        bb = max(bb, -sdPie(p+vec2(0.5, 0.47), vec2(sin(PI/4.75), cos(PI/4.75)), 0.4));\n        p.y *= -1.;\n        bb = max(bb, -sdPie(p+vec2(-0.45, 0.52), vec2(sin(PI/6.75), cos(PI/6.75)), 0.4));\n        c = max(c, bb);\n        word = min(word, c);\n    }\n    return word;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - .5*iResolution.xy)/iResolution.y;\n    fragColor = vec4(1);\n\n    uv.y -= 0.05;\n    float sc = 2.2;\n\n    vec2 p = uv * sc,\n    ip  = floor((p+vec2(0., 0.075))*vec2(1., 0.8))+0.5,\n    center = vec2(-0.021683, 0.017097);\n    p -= ip;\n    p -= (center*(floor(ip+.5)-.5));\n\n    if(abs(ip.x) <= 1. && abs(ip.y) <= 1.)\n    {\n\n        LunarObject moon;\n        SpaceShuttle ss;\n        StarArray stars;\n        CloudArray clouds;\n\n        FormMoon(p, moon);\n        FormClouds(p, clouds);\n        FormShuttle(p, iResolution.x, ss);\n        FormStars(p, iResolution.x, stars);\n\n        float o = length(p) - PORTHOLE_RADIUS;\n\n        o = smin(ss.wakeSDF, -o, 0.07);\n        o = smoothstep(-(1./iResolution.x)*4., (1./iResolution.x)*4., o);\n        o = saturate(o);\n\n        ip.y = -ip.y + 1.;\n        if (ip.x < -1. || ip.x > 1. || ip.y < -1. || ip.y > 2.) ip *= 0.;\n        float pidx = 2.*ip.y + ip.x;\n\n        float word = 1.;\n        word = mix(word, FormWord(uv+vec2(0.25+center.x*1.3, 0.), word, 0), nlerp(pidx, pidx+1.5, mod(iTime, 10.)));\n        word = mix(word, FormWord(uv-vec2(0.25+center.x*1.3, 0.), word, 1), nlerp(pidx, pidx+1.5, mod(iTime, 10.)));\n        word = mix(word, FormWord(uv+vec2(0.25+center.x*1.3, 0.5-center.y*2.), word, 2), nlerp(pidx, pidx+1.5, mod(iTime, 10.)));\n        word = mix(word, FormWord(uv+vec2(-0.25-center.x/1.8, 0.5-center.y*2.), word, 3), nlerp(pidx, pidx+1.5, mod(iTime, 10.)));\n        word = 1.-smoothstep(-(1./iResolution.x)*20., (1./iResolution.x)*20., word);\n        word = saturate(word);\n\n        // Rendering\n        fragColor.rgb = mix(fragColor.rgb, BG_COLOR, o * nlerp(0.5, 1., mod(iTime, 10.)));\n        fragColor.rgb = mix(\n            fragColor.rgb, MOONLIGHT,\n            moon.body * o * float(pidx > 1.)\n        );\n        fragColor.rgb = mix(\n            fragColor.rgb,\n            BG_COLOR*.8,\n            moon.craters * o * nlerp(3., 4., mod(iTime, 10.)) * float(pidx > 2.)\n        );\n        fragColor.rgb = mix(\n            fragColor.rgb,\n            mix(BG_CLOUDS_COLOR, BG_COLOR, saturate(1.-clouds.shadow[1]) *\n            nlerp(5., 6., mod(iTime, 10.)) * float(pidx > 3.)),\n            clouds.formation[1] * o * float(pidx > 2.)\n        );\n        fragColor.rgb = mix(\n            fragColor.rgb,\n            mix(FG_CLOUDS_COLOR, BG_COLOR, saturate(1.-clouds.shadow[0]) *\n            nlerp(5., 6., mod(iTime, 10.)) * float(pidx > 3.)),\n            clouds.formation[0] * o * float(pidx > 2.)\n        );\n        fragColor.rgb = mix(\n            fragColor.rgb,\n            mix(TANK_DARK_COLOR, TANK_LIGHT_COLOR, ss.colorGradient),\n            ss.tank * o\n        );\n        fragColor.rgb = mix(\n            fragColor.rgb,\n            mix(TANK_DARK_COLOR, TANK_DIM_COLOR, ss.colorGradient),\n            ss.shadow * nlerp(1.75, 2.75, mod(iTime, 10.)) * float(pidx > 1.)\n        );\n        fragColor.rgb = mix(\n            fragColor.rgb, vec3(0),\n            ss.wakeHalo * nlerp(3., 4., mod(iTime, 10.)) * float(pidx > 2.)\n        );\n        fragColor.rgb = mix(fragColor.rgb, vec3(1), ss.miscParts);\n        fragColor.rgb = mix(\n            fragColor.rgb, FG_CLOUDS_COLOR,\n            stars.radiance*o*nlerp(5., 6., mod(iTime, 10.)) * float(pidx > 3.)\n        );\n        fragColor.rgb = mix(\n            fragColor.rgb, vec3(1),\n            stars.bodies * nlerp(3., 3.5, mod(iTime, 10.)) * float(pidx > 2.)\n        );\n\n        fragColor.rgb = mix( fragColor.rgb, BG_COLOR, word );\n\n        fragColor.rgb = gamma(max(fragColor.rgb, 0.), 0.75);\n        fragColor.rgb = mix(fragColor.rgb, vec3(1), nlerp(9.5, 10., mod(iTime, 10.)));\n    }\n}","name":"Image","description":"","type":"image"}]}