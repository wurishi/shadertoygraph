{"ver":"0.1","info":{"id":"tdlXWH","date":"1551212932","viewed":74,"name":"отражение и тени (дополнение №1)","username":"nirvanabc","description":"дополнение к основной части №1","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","shadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RSAMPLES 32\n\nfloat sphere(vec3 rp, vec3 c, float r)\n{\n\treturn distance(rp,c)-r + 0.3 * sin(iTime);\n}\n\nfloat cube( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nvec4 map(vec3 rp)\n{\n\tvec4 d;\n\tvec4 sp = vec4( vec3(0.168, 0.19, 0.40), sphere(rp, vec3(1.90,0.0,0.0), 1.30) );\n    vec4 sp2 = vec4( vec3(0.8, 0.3, 0.2), sphere(rp, vec3(1.0,3.30,0.0), 1.30) );\n\tvec4 py = vec4( vec3(0.17,0.35,0.1), rp.y+1.0 );\n\td = (sp.a < py.a) ? sp : py;\n    d = (d.a < sp2.a) ? d : sp2;\n\treturn d;\n}\n\nvec3 normal(vec3 rp)\n{\n    vec3 eps = vec3( 0.002 ,0.0,0.0);\n\treturn normalize( vec3(\n           map(rp+eps.xyy).a - map(rp-eps.xyy).a,\n           map(rp+eps.yxy).a - map(rp-eps.yxy).a,\n           map(rp+eps.yyx).a - map(rp-eps.yyx).a ) );\n\n}\n\nfloat softShadow(vec3 ro, vec3 lp)\n{\n\tvec3 rd = normalize(lp-ro);\n\tfloat tmax = distance(lp,ro);\n\tfloat res = 1.0;\n    float t = 0.1;\n\tfor(int i = 0; i<256; i++ )\n\t{\n        if(t>=tmax) break;\n\t\tfloat d = map(ro+rd*t).a;\n\t\tif(d < 0.001) return 0.0;\n\t\tres = min(res, 8.0*d);\n\t\tt += d;\n\t}\n\treturn res;\n}\n\nfloat ao(vec3 ro, vec3 norm, float k)\n{\n    float res = 0.01;\n    float f = 0.1;\n    for(int i = 1; i<6; i++)\n    {\n        vec3 rp = ro + f*float(i)*norm;\n     \tres+=(1.0/pow(2.0,float(i)))*(f*float(i)-map(rp).a);    \n    }\n\treturn 1.0-k*res;\n}\n\n\nvec3 lp(void){\n    // позиция источника света\n    return vec3(1.50,5.0,3.0);\n}\n\n\nvec3 lp1(void){\n    // позиция второго источника света\n    return vec3(0.0,5.0,2.0);\n}\n\nvec3 reflection(vec3 rro, vec3 rd, vec3 n, vec3 ro, float x)\n{\n\trd = normalize(reflect(rd,n));\n\tvec3 res = vec3(1.0,1.0,0.8);\n\tfloat tmax = 10.0;\n    float t = 0.1;\n    vec3 rp = rro;\n    vec4 d = vec4(res, 1.0);\n\tfor(int i = 0; i<256; i++ )\n\t{\n        if(t>=tmax) break;\n        // отражение\n\t\trp = rro+rd*t;\n\t\td = map(rp);\n\t\tif(d.a < 0.001) \n\t\t{\t\t\n\t\t\tbreak;\n\t\t}\n\t\tt+=d.a;\n\t}\n    if(d.a < 0.001) \n\t{\t\t\n    \tfloat ks = 0.9;\n\t\tfloat kd = 0.5;\t\t\n\t\tfloat ka = 0.2;\n        float a = 3.0;\n\t\tfloat aof = 5.0;\n        float ss = 1.0;\n\t\t\t\n\t\tvec3 l = normalize(lp()-rp);          \n\t\tvec3 n = normal(rp);\t\t\t\t\n\t\tvec3 v = normalize(ro-rp);\n        vec3 h = normalize(l+v);\n        \n        // добавляем второй источник света\n        vec3 l1 = normalize(lp1()-rp);\n        \n\t\t\t\n\t\tfloat illumination  = ka*ao(rp,n, aof) \t\t\t\t\n\t\t\t\t\t\t\t+ max(kd*dot(l,n),0.0)\n                            + max(ks*pow(dot(n,h),a),0.0);\n        \n        illumination += ss*softShadow(rp, lp());\n\t\tillumination += ss*softShadow(rp, lp1());\n        \n\t\tres = d.rgb*illumination;\n\t}\n\treturn res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 p = uv*2.0-1.0;\n\tp.x*=iResolution.x/iResolution.y;\t\n\tfloat f = -7.0;\n    \n    // цвет фона\n    vec3 col = vec3(0.13,0.1,0.14);\n\n\tvec3 ro = vec3(0.0,0.0,f-1.19);\n\tvec3 rd = normalize(vec3(p,f)-ro);\n\tvec3 rp;\n\tfloat tmax = 60.0;\n\tfloat t = 0.0;\n    vec4 d = vec4(col, 1.0);\n\tfor(int i = 0; i<256; i++)\n\t{\n        if(t >= tmax) break;\n\t\trp = ro+rd*t;\n\t\td = map(rp);\n\t\tif(d.a < 0.0001)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tt += d.a;\n\t}\n\tif(d.a < 0.0001)\n    {\n   \t\tfloat ks = 0.5;\t\t//specular reflection constant\n\t\tfloat kd = 0.5;\t\t//diffuse reflection constant\n\t\tfloat ka = 0.4;\t\t//ambient reflection constant\n\t\tfloat a = 5.0;\t\t//shininess constant\n\t\tfloat aof = 5.0;\t//ambient occlusion amount\n\t\tfloat rf = 1.0;\t\t//reflection amount\n        float ss = 1.0;\n\t\t\t\n\t\tvec3 l = normalize(lp()-rp);          //surface to light vector\n\t\tvec3 n = normal(rp);\t\t\t\t//surface normal vector\n\t\tvec3 v = normalize(ro-rp);\t\t\t//surface to camera vector\n        vec3 h = normalize(l+v);\t\t\t//the \"half way vector\"\n\t\t\t\n\t\tfloat illumination  = ka*ao(rp,n, aof) \t\t\t\t//add ambient light\n\t\t\t\t\t\t\t+ max(kd*dot(l,n),0.0) \t\t\t//add diffuse light\n\t\t\t\t\t\t\t+ max(ks*pow(dot(n,h),a),0.0);\t//add specular light\n        \n        illumination += ss*softShadow(rp, lp());\n\t\tillumination += ss*softShadow(rp, lp1());\n        vec3 ref = vec3(0.0);\n        \n        for(int j = 1; j<RSAMPLES+1; j++)\n        {\n            ref+=reflection(rp,rd,n,ro,float(j));\n        }\n        ref/=float(RSAMPLES);\n\t\tcol = d.rgb*(illumination+ref);\n    }\n\n\tfragColor = vec4(col,1.0);\t\n}","name":"Image","description":"","type":"image"}]}