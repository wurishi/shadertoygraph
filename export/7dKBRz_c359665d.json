{"ver":"0.1","info":{"id":"7dKBRz","date":"1657767584","viewed":264,"name":"It's Pizza Time","username":"chickenlegs","description":"Rendering pIzzas using mod repetition following the \"Patterns\" guide in the book of shaders (https://thebookofshaders.com/09/).","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["repetition","spiderman","pizza"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926538\n\n//// Comparison functions\nfloat gt(float v1, float v2)\n{\n    return step(v2,v1);\n}\n\nfloat lt(float v1, float v2)\n{\n    return step(v1, v2);\n}\n\nfloat s_lt(float v1, float v2, float e)\n{\n    return smoothstep(v1-e, v1+e, v2);\n}\n\n//// Shapes functions\nfloat circle_df(vec2 xy, vec2 pos)\n{\n    float d = distance(xy, pos);\n    //float d = dot(xy-pos, xy-pos)*2.; // Cheaper distance function but will require more epsilon if using with smoothstep\n    return d;\n}\n\nfloat s_circle(vec2 xy, vec2 pos, float r, float e)\n{\n    float d = circle_df(xy, pos);\n    return s_lt(d, r, e);\n}\n\nfloat rectangle_df(vec2 p, float w, float h)\n{\n    vec2 b = vec2(w, h);\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat s_rectangle(vec2 xy, vec2 pos, float w, float h, float roundness, float e) // roundness == 0 means no roundess, roundness == 1 means full roundess\n{\n    h = h/2.;\n    w = w/2.;\n    float r = clamp(roundness, 0., 1.)*w;\n    float d = rectangle_df(xy-pos, w-r, h-r);\n    return s_lt(d, r, e);\n}\n\nfloat triangle_df(vec2 xy, vec2 pos, float l)\n{\n    vec2 p = (xy-pos)/l;\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat s_triangle(vec2 xy, vec2 pos, float l, float roundness, float e) // roundness == 0 means no roundess, roundness == 1 means full roundess\n{\n    float r = clamp(roundness, 0., 1.)*l;\n    float d = triangle_df(xy, pos, l);\n    return clamp(s_lt(d, r, e*2.)*2., 0., 1.);\n}\n\n\n//// Rotation function\nvec2 rotate(vec2 vec, float a)\n{\n    return vec2(vec.x*cos(a)-vec.y*sin(a), vec.x*sin(a)+vec.y*cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Getting values\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    // Setting up view port\n    float zoom = 10.;\n    vec2 zoomCenter = vec2(0., 0.);\n    float viewPortCenter = 0.5;\n    float ratio = iResolution.y/iResolution.x;\n    \n    // Establishing screen xy values\n    vec2 xy = (uv - viewPortCenter) * zoom + zoomCenter;\n    xy = vec2(xy.x, xy.y*ratio);\n    \n    // Establishing mouse xy values\n    mouse = (mouse - viewPortCenter) * zoom + zoomCenter;\n    mouse.y *= ratio;\n    \n    // Width of a single pixel \n    float pixel = zoom / iResolution.x;\n    vec3 col = vec3(0.);\n    \n    // Creating the mod repitition\n    xy = rotate(xy, PI/4.);\n    \n    float rep = 0.5;\n    float time = iTime*3.;\n    xy.x += gt(mod(xy.y+rep, 2.), 1.)*lt(mod(time, 2.), 1.)*time;\n    xy.y += gt(mod(xy.x+rep, 2.), 1.)*gt(mod(time, 2.), 1.)*time;\n    xy = mod(xy+rep, rep*2.)-rep;\n    \n    xy = rotate(xy, iTime*2.);\n    \n    // Crust\n    float crust = s_rectangle(xy, vec2(0, -0.25), 0.75, 0.25, 0.3, pixel);\n    col.r += crust;\n    col.g += crust/2.;\n    \n    // Bread\n    float bread = s_triangle(xy, vec2(0), .25, 0.5, pixel*2.);\n    col.rgb -= bread;\n    col.rg += bread*2.;\n    \n    // Toppings\n    float toppings = s_circle(  mod(xy+vec2(0.01,0.1), 0.3)  , vec2(0.1), 0.1, pixel)*bread;\n    col.rgb -= toppings;\n    col.r += toppings;\n\n    fragColor = vec4(col,1);\n}\n","name":"Image","description":"","type":"image"}]}