{"ver":"0.1","info":{"id":"llVyz1","date":"1535640496","viewed":741,"name":"Warp Glow","username":"belfry","description":"Domain warp glow.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Anti-Aliasing. Pointless with artefacts due to stepsize being too large.\n// \"aa 1.\" is off \n// \"aa 2.\" is on \n#define aa 1.\n\nvec2 vnoise(vec2 v, float s) {\n    vec2 g = v / s;\n    g = floor(g) * s;\n    vec2 ld = hash22(g);\n    vec2 rd = hash22(g + vec2(s, 0.));\n    vec2 lu = hash22(g + vec2(0., s));\n    vec2 ru = hash22(g + s);\n    g = fract(v / s);\n    g = smoothstep(0., 1., g);\n    return mix(mix(ld, rd, g.x), mix(lu, ru, g.x), g.y);\n}\n\nvec2 fbm(vec2 v) {\n    float t = 0.;\n    vec2 n = vec2(0.);\n    for (float s = 1.; s > 0.02; s *= 0.5) {\n        t += s;\n    \tn += vnoise(v, s) * s;\n    }\n    return n / t;\n}\n\nfloat primitive(vec3 p, float r) {\n    vec3 a = abs(p) - r * .75;\n    return smin(max(a.x, max(a.y, a.z)), length(p) - r, .1);\n}\n\nvec2 sdf(vec3 p) {\n    p -= vec3(1.3, 5.6, 2.0);\n    \n    vec2 obj = vec2(10000., -1.);\n    for (float i = 0.; i < 7.; i++) {\n        p = abs(p);\n        p -= vec3(1.7, 1.75, 2.781);\n        float a = 4.9 - length(p) * 0.2;\n        p.xy = mat2(cos(a), sin(a), -sin(a), cos(a)) * p.xy;\n        a = 1. + dot(p, p) * .005;\n        p.yz = mat2(cos(a), sin(a), -sin(a), cos(a)) * p.yz;\n        \n        float d = primitive(p, 6.2 / (9.3 - i));\n        obj = vec2(smin(d, obj.x, .2), mix(i, obj.y, clamp(d / obj.x, 0., 1.)));\n    }\n    \n    return obj;\n}\n\nvec3 gradient(vec3 p) {\n    vec2 eps = vec2(0.02, 0.);\n    float dx = sdf(p + eps.xyy).x - sdf(p - eps.xyy).x;\n    float dy = sdf(p + eps.yxy).x - sdf(p - eps.yxy).x;\n    float dz = sdf(p + eps.yyx).x - sdf(p - eps.yyx).x;\n    return normalize(vec3(dx, dy, dz));\n}\n\nbool trace(vec3 pos, vec3 dir, out vec3 p, out float i, out float t, out vec2 obj) {\n    t = 0.;\n    for(i = 0.; i < 400.; i++) {\n        p = t * dir + pos;\n        obj = sdf(p);\n        if (abs(obj.x) < 0.005 * t)\n            return true;\n        t += obj.x * .25;\n        if (t > 100.)\n            break;\n    }\n    return false;\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n, float steps, float dist) {\n    float ao = 0.;\n    for (float i = 1.; i <= steps; i++) {\n        float t = i / steps * dist;\n        ao += sdf(p + n * t).x / t;\n    }\n    return clamp(ao / steps, 0., 1.);\n}\n\nfloat translucency(vec3 p, vec3 n, float steps, float dist) {\n    float ao = 0.;\n    for (float i = 1.; i <= steps; i++) {\n        float t = i / steps * dist;\n        ao += -sdf(p - n * t).x / t;\n    }\n    return 1. - clamp(ao / steps, 0., 1.);\n}\n\nvec3 draw(vec3 p, vec3 dir, float i, float t, vec2 obj, vec2 uv) {\n    vec3 normal = gradient(p);\n    vec3 lightDir = normalize(vec3(cos(1.), 1., sin(1.)));\n    float diffuse = max(0., dot(lightDir, normal)) * .4;\n    float specular = pow(max(0., dot(normalize(lightDir - dir), normal)), 16.) * .8 * obj.y / 7.;\n    float rim = pow(1. - abs(dot(normal, -dir)), 5.) * .5;\n    float ao = ambientOcclusion(p, normal, 3., .3);\n    float trans = translucency(p, normal, 3., .3) * .5 * smoothstep(1., .2, obj.y / 10.);\n    vec3 lighting = trans * vec3(1., 0.7, 0.) \n        + ao * .15 + \n        diffuse * vec3(1., 1., 0.) + \n        + (rim + specular) * vec3(0., 1., .8);\n    vec3 col = vec3(1. - t / 30., .5 - t / 60., smoothstep(0.2, 1., obj.y / 5.));\n    vec2 s = uv + fbm(vec2(i / 350., t / 30.));\n    vec2 h = fbm(s - iTime * .15);\n    h = fbm(s + h - .5 + iTime * .01);\n    h = fbm(s + h - .5);\n    return clamp(col * lighting + i / 70. * (h.x) * vec3(1., 0.7, 0.), 0., 1.);\n}\n\nvec3 reflection(vec3 pos, vec3 dir, vec3 normal, vec2 uv) {\n    dir = reflect(dir, normal);\n    float i, t;\n    vec2 obj;\n    vec3 p;\n    bool hit = trace(pos + dir * .05, dir, p, i, t, obj);\n    return hit ? draw(p, dir, i, t, obj, uv) : vec3(0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\tvec3 c = vec3(0.);\n    for (float k = 0.; k < aa; k++) {\n        for (float l = 0.; l < aa; l++) {\n        \tvec3 dir = normalize(vec3(uv + vec2(l, k) / aa / iResolution.y, 1. / tan(radians(60.) * .5)));\n            float a = iTime * .1 -10.;\n            vec3 camPos = vec3(0., 0., sin(a) * 4.);\n            dir.xz = mat2(cos(a), sin(a), -sin(a), cos(a)) * dir.xz;\n\n            float i, t;\n            vec2 obj;\n            vec3 p;\n            bool hit = trace(camPos, dir, p, i, t, obj);\n            vec3 col = hit ? draw(p, dir, i, t, obj, uv) : vec3(0.);\n            vec3 normal = gradient(p);\n            vec3 r = reflection(p, dir, normal, uv);\n            c += mix(col * (1. + r * .5), col, 1. - pow(abs(dot(normal, -dir)), 5.));\n    \t}\n    }\n    \n    \n    fragColor = vec4(c / (aa * aa), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// taken from: https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// taken from: https://www.shadertoy.com/view/4djSRW\n//#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n//#define HASHSCALE1 .1031\n#define HASHSCALE1 443.8975\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}","name":"Common","description":"","type":"common"}]}