{"ver":"0.1","info":{"id":"XtVSWw","date":"1484584073","viewed":194,"name":"OJ - Fibber 28, scene 4","username":"rammoskar","description":"Full demo: https://www.youtube.com/watch?v=kw5uLHZiRpY","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["3dpills"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat sdTorus62( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length6(q)-t.y;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b) //, float k )\n{\n\tfloat k = 0.1;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smink( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\n\n\n\n#define MAT_S4_FLOOR 10.0\n#define MAT_S4_MIRROR 11.0\n\n\n#define EPS 0.01\n\n\n\nvec2 un(vec2 a, vec2 b)\n{\n\treturn a.x < b.x ? a : b;\n}\n\nvec2 sun(vec2 a, vec2 b)\n{\n\tfloat sm = smin(a.x,b.x);\n\tfloat ca = abs(sm -a.x);\n\tfloat cb = abs(sm -b.x);\n\t\n\treturn ca < cb ? vec2(sm, a.y) : vec2(sm, b.y);\n}\n\nvec2 sunk(vec2 a, vec2 b, float k)\n{\n\tfloat sm = smink(a.x,b.x, k);\n\tfloat m = min(a.x, b.x);\n\tfloat ca = abs(sm -a.x);\n\tfloat cb = abs(sm -b.x);\n\t\n\treturn ca < cb ? vec2(sm, a.y) : vec2(m, b.y);\n}\n\n\nvec2 unn(vec2 a, float dis, float mat)\n{\n\treturn a.x < dis ? a : vec2(dis, mat);\n}\n\n\n\nmat3 rot(float x, float y, float z)\n{\n\tfloat cx = cos(x);\n\tfloat sx = sin(x);\n\tfloat cy = cos(y);\n\tfloat sy = sin(y);\n\tfloat cz = cos(z);\n\tfloat sz = sin(z);\n\tmat3 xm = mat3(1, 0, 0,\n\t\t\t\t\t0, cx, -sx,\n\t\t\t\t\t0, sx, cx);\n\tmat3 ym = mat3(cy, 0, sy,\n\t\t\t  \t\t0, 1, 0,\n\t\t\t  \t\t-sy, 0, cy);\n\tmat3 zm = mat3(cz, -sz, 0,\n\t\t\t\t\tsz, cz, 0,\n\t\t\t\t\t0, 0, 1);\n\treturn xm * ym * zm; //inverse(xm * ym * zm);\n}\n\n\n\n\n\n\n\n\n\n\nbool inRefraction = false;\n\n\n\n\n\n\n\nvec2 scene(vec3 p, vec3 rd)\n{\n\tfloat t = mod(iTime, 30.0);\n\tvec2 res = vec2(99999, -1);\n\tvec3 s = vec3(1);\n\tvec3 q = mod(p, s) - 0.5 * s;\n\tivec3 n = ivec3(floor(p / s));\n\t\n\tfloat roomDis = -sdBox(vec3(n) - vec3(0.0, 5.0, 0.0), vec3(15.0, 5.0, 15.0));\n\tif (roomDis < 0.0) {\n\t\tfloat box = sdBox(q, vec3(0.5));\n\t\tbox = max(box, -sphere(q, 0.55 + 0.05 *  sin(t + float(n.x + n.z + n.y))));\n\t\tres = un(res, vec2(box, MAT_S4_FLOOR));\n\t} else {\n\t\tvec3 d = (s * 0.5 -  sign(rd)* q) / abs(rd);\n\t\tfloat b = min(d.x, min(d.y, d.z));\n\t\tfloat a = max(roomDis - 1.73, b + EPS); // TODO 1.73 kan vara for mycket \n\t\tres = un(res, vec2(max(EPS, a), -1));\n\t}\n\t\n\t//Mirrors\n\t { //if (roomDis > 0)\n\t\tvec3 s = vec3(5, 20, 5);\n\t\tvec3 q = mod(p - vec3(0, -8, 0), s) - 0.5 * s;\n\t\tvec3 n = vec3(floor(p / s));\n\t\tvec3 bot = vec3(0.4 * sin(n.x + t* 0.5), -1, 0.4 * cos(n.z + t * 0.5));\n\t\tfloat mdis = sdCapsule(q, bot , -bot, 0.6);\n\t\t//mdis = smin(mdis, sdTorus62(q, vec2(0.7, 0.2)));\n\t\tres = un(res, vec2(mdis, MAT_S4_MIRROR));\n\t}\n\treturn res;\n}\n\n\nvec3 getNormal(vec3 p, vec3 rd, vec3 ro)\n{\n    vec3 normal;\n    vec3 ep = vec3(0.01, 0, 0);\n    normal.x = scene(p + ep.xyz, rd).x - scene(p - ep.xyz, rd).x;\n    normal.y = scene(p + ep.yxz, rd).x - scene(p - ep.yxz, rd).x;\n    normal.z = scene(p + ep.yzx, rd).x - scene(p - ep.yzx, rd).x;\n    return normalize(normal);\n}\n\n\nfloat specular(vec3 normal, vec3 light, vec3 viewdir, float s)\n{\n\tfloat nrm = (s + 8.0) / (3.1415 * 8.0);\n\tfloat k = max(0.0, dot(viewdir, reflect(light, normal)));\n    return  pow(k, s);\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat shadow(in vec3 ro, in vec3 rd, float mint, float maxt, float shadowAmbient)\n{\n    for( float t=mint; t < maxt; )\n    {\n        float h = scene(ro + rd*t, rd).x;\n        if( h<0.01 )\n            return shadowAmbient;\n        t += h;\n    }\n    return 1.0;\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt )\n{\n\tfloat res = 1.0;\n    float t = mint;\n   for( float t=mint; t < maxt; )\n    {\n\t\tvec2 res = scene( ro + rd*t, rd );\n\t\tfloat h = res.x;\n\t\tfloat m = res.y;\n\t\tif (m  > 0.0) {\n       \t res = min( res, h );\n\t\t}\n\t\tt += h;\n        if( h<0.01 || t>maxt ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec3 eye = vec3(0);\n\tvec3 light = vec3(0);\n\tvec3 tar = vec3(0);\n\tbool waterRefract = false;\n\tfloat lightInvSize = 0.5;\n\tfloat shadowAmbient = 0.3;\n\tfloat lightIntensity = 0.004;\n\tbool lightCollision = false;\n\t\n\tfloat refJumpDistance = 0.02;\n\tbool shadows = true;\n\tconst int imax = 600;\n\tfloat tmax = 800.0;\n\tvec3 skyColor = vec3(0);\n\tbool cubicDis = false;\n\tvec3 rollV = vec3(0, 1, 0);\n\tfloat t = mod(iTime, 30.0);\n    eye = vec3(0.0, 2.0 + sin(t * 0.1) * 0.3 + 1.0 * smoothstep(6.0, 20.0, t), -12.0 + t * 0.3);\n    float st = clamp(t * 0.4, 0.0, 3.1415);\n    tar = eye + vec3(0, 0, 1); // sin(t * 0.3) * 0.2 -sin(st) - cos(st)\n    light = vec3(3, 9, -14);\n    shadowAmbient = 0.7;\n    const int jumps = 10;\n    shadows = false;\n    rollV = normalize(vec3(cos(t * 0.4), sin(t * 0.4), 0));\n\tvec3 dir = normalize(tar - eye);\n\tvec3 right = normalize(cross(rollV, dir)); //vec3(0, 1, 0)\n \tvec3 up = cross(dir, right);\n    \n    float u = (fragCoord.x / iResolution.x) * 2.0 - 1.0;\n    float v = ((fragCoord.y / iResolution.y) * 2.0 - 1.0) * (iResolution.y/iResolution.x); \n\n    vec3 color = skyColor;//vec3(0.3);\n      \n    t = 0.0;\n    //vec3 ro = eye + forward * 1 + right * u + up * v;\n\tvec3 ro = eye;\n\tvec3 rd = normalize(dir + right*u + up*v);\n\t\n\tfloat ref = 1.0;\n\tfloat lightAura = 0.0;\n\t float breakVar = 0.0;\n\tfor(int j = 0; j < jumps; ++j)\n    {\n        if (breakVar > 0.5) {\n            break;\n        }\n    \tt = 0.0;\n    \t for(int i = 0; i < imax; ++i)\n   \t\t {\n             if (t >= tmax) {\n             \tbreak;\n             }\n\t        vec3 p = ro + rd * t;\n\t        vec2 dm = scene(p, rd);\n\t        float d = dm.x;\n\t        float m = dm.y;\n\t\t\t\n\t\t\t\n\t        if(d < EPS || i == imax || t >= tmax) //d < 0.001 \n\t        {\n\t        \t//float ls = 50.0;\n\t        \t//vec3 lp = ls * floor(p/ls) + ls/2;\n\t        \t//light = vec3(0, -13, lp.z); //10 * sin(tick + lp.z)\n\t        \tvec3 x0 = light;\n\t        \tvec3 x1 = ro;\n\t        \tvec3 x2 = ro + rd;\n\t        \tfloat ldis = pow(length(cross(x2 - x1, x1 - x0)), 2.0) / pow( distance(x2, x1), 2.0); \n\t        \tvec3 normal = getNormal(p, rd, ro);\n\t\t\t\t\n\t\t\t\tvec3 invLight = normalize(light - p);\n\t        \tfloat diffuse = max(0.,dot(invLight, normal));\n\t        \tvec3 refrd = reflect(rd, normal);\n\t        \t\n\n\t        \tvec3 n = floor(p);\n\t\t\t\tvec3 c = vec3(0.5);\n\t\t\t\tif (m == MAT_S4_FLOOR) {\n\t\t\t\t\tc = vec3(1, 0, 0.5 /*texture(noiseP, vec2(p.x, p.z + p.y)).x*/);\n\t\t\t\t} else if (m == MAT_S4_MIRROR) {\n\t\t\t\t\tc = vec3(1);\n\t\t\t\t} \n\t        \t\n                c = 0.7*c* (1.0 + diffuse);\n              \n                c += specular(normal, -invLight, normalize(eye - p), 70.0);\n\n\t            \n\t            float dis = length(light - p);\n\t            float disFact = 1.0 / (1.0 + lightIntensity*dis*dis * (cubicDis ? dis : 1.0 ));\n\t            c *= disFact;\n\t\t\t\t\n\t\t\t\t\t        \t\n\t        \tfloat tl = -dot(x1 - x0, x2 - x1)/pow(distance(x2,x1),2.0);\n\t        \tif(tl > 0.0 && ((lightCollision && distance(eye, light) < distance(eye, p)) || !lightCollision)){\n\t        \t\tlightAura = max(lightAura, 1.0/(0.01 + lightInvSize*ldis));\n\t        \t}\n\t\t\t\t//color = applyFog(color, distance(eye, p), rd, vec3(0, 0, 1), p);\n\n\t\t\t\tcolor = mix(color, c, ref);\n\t\t\t\t\n\t\t\t\t\n                rd = reflect(rd, normal);\n                ro = p + rd*refJumpDistance;\n\t\t\t\n\n\t\t\t\t\n\t           \n\n\t        \t\n\t        \t if (m == MAT_S4_MIRROR) {\n\t        \t\tref = 0.9;\n\t        \t} else {\n\t\t        \tref = 0.0;\n\t        \t}\n\t        \tif (ref <= 0.01) {\n\t\t\t\t\tbreakVar = 1.0;\t        \t\t\n\t        \t}\n\t           \tbreak;\n\t        }\n\t\n\t        t += d;\n    \t}\n    }\n    \n    fragColor = vec4(color + vec3(lightAura),  1.0); \n}\n\n\n  ","name":"Image","description":"","type":"image"}]}