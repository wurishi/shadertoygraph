{"ver":"0.1","info":{"id":"MdKXzW","date":"1463313879","viewed":381,"name":"Squaring the sphere","username":"Hodgman","description":"Mapping a sphere to a rectangle\n\nDefault view: Sphere normals for each UV coord - black horizon.\n\nClick for ray-traced sphere:\ntop half - front side.\nbottom half - back side.\nleft half - UV's.\nleft 5% - UV resolution.\nright half - encoding error.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["spheremap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SQUARE_THE_CIRCLE 1\n#define GBUFFER_QUANTIZE 65536\n\nfloat Sphere(vec3 ray, vec3 dir, vec3 center, float radius)\n{\n\tvec3 rc = ray-center;\n\tfloat c = dot(rc, rc) - (radius*radius);\n\tfloat b = dot(dir, rc);\n\tfloat d = b*b - c;\n\tfloat t = -b - sqrt(abs(d));\n\tfloat st = step(0.0, min(t,d));\n\treturn mix(-1.0, t, st);\n}\n\nvec3 TraceSphere( vec2 ndc )\n{\n    float aspect = iResolution.x/iResolution.y;\n\tvec2 uv = ndc * vec2(aspect, 1.0);\n\tvec3 ro = vec3(0.0, 0.0, -3.0);\n\tvec3 rd = normalize(vec3(uv, 1.0));\n\tvec3 p = vec3(0.0, 0.0, 0.0);\n\tfloat t = Sphere(ro, rd, p, 2.0);\n\treturn mix(vec3(-100.),normalize(p - (ro+rd*t)), step(0.,t));\n}\n\nvec3 NdcToSphereNormal( vec2 ndc )\n{\n#if SQUARE_THE_CIRCLE\n    vec2 c = normalize(ndc);\n    ndc *= max(abs(c.x), abs(c.y));\n    vec2 uv = ndc * .5 + .5;\n    uv = clamp(uv, vec2(0), vec2(1));\n#else\n    vec2 uv = ndc * .5 + .5;\n#endif\n    //vec2 uv2 = uv*uv; float t = dot(-4.*uv2 + 4.*uv, vec2(1.));\n    vec2 uv4 = 4.*uv; float t = dot(uv4 - uv4 * uv, vec2(1.));\n\tfloat s = 2.*sqrt(t - 1.);\n    vec3 p;\n    p.xy = s * (uv*2.-1.);\n    p.z = 2.*t - 3.;\n    return (p);\n}\n\nvec2 SphereNormalToUv( vec3 n )\n{\n\tvec3 b = n+vec3(0., 0., 1.);\n\tfloat p = 2.*sqrt(dot(b,b));\n\tvec2 uv = n.xy/p + .5;\n#if SQUARE_THE_CIRCLE\n\tvec2 ndc = uv*2.-1.;\n    \n    vec2 c = normalize(ndc);\n    ndc /= max(abs(c.x), abs(c.y));\n    \n    uv = ndc * .5 + .5;\n    uv = clamp(uv, vec2(0), vec2(1));\n#endif\n    return uv;\n}\n\nvec3 Heat( float sum )\n{\n    float error = log2(sum*pow(2.,18.));\n    vec3 c = vec3(0);\n    c =  mix(c, vec3(.25,0,0.5), clamp(error,0.,1.));//purple\n    c =  mix(c, vec3(0,0,1), clamp(error-1.,0.,1.));//blue\n    c =  mix(c, vec3(0,1,1), clamp(error-2.,0.,1.));//teal\n    c =  mix(c, vec3(0,1,0), clamp(error-4.,0.,1.));//green\n    c =  mix(c, vec3(1,1,0), clamp(error-8.,0.,1.));//yellow\n    c =  mix(c, vec3(1,0,0), clamp(error-16.,0.,1.));//red\n    c =  mix(c, vec3(1,1,1), clamp(error-24.,0.,1.));//white\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 ndc = uv*2.-1.;\n    \n    vec3 nScale = vec3(1);\n\tif( iMouse.y / iResolution.y < .5 )\n        nScale = vec3(1., 1., -1.);\n    \n\tif( iMouse.x / iResolution.x < .5 )\n    {\n        if( iMouse.z > 0. )\n\t\t{\n        \tvec3 n = TraceSphere(ndc) * nScale;\n    \t    uv = SphereNormalToUv(n);\n#if GBUFFER_QUANTIZE\n        uv = floor( uv * float(GBUFFER_QUANTIZE) + 0.5 ) / float(GBUFFER_QUANTIZE);\n#endif\n            if( iMouse.x / iResolution.x < .05 )\n            \tuv = 1.0-abs(vec2(fwidth(uv.x), fwidth(uv.y)))*0.5*max(iResolution.x,iResolution.y);\n\t\t\tfragColor = vec4( uv, 0., 1. );\n\t\t}\n\t\telse\n\t\t{\n            vec3 n = NdcToSphereNormal(ndc);\n            vec3 c = n*.5+.5;\n            c = mix( c, vec3(0,0,0), clamp(1.-abs(n.z)*100.,0.,1.) );\n\t\t\tfragColor = vec4( c, 1. );\n\t\t}\n    }\n    else\n    {\n       \tvec3 n = TraceSphere(ndc) * nScale;\n    \tuv = SphereNormalToUv(n);\n#if GBUFFER_QUANTIZE\n        uv = floor( uv * float(GBUFFER_QUANTIZE) + 0.5 ) / float(GBUFFER_QUANTIZE);\n#endif\n        ndc = uv * 2. -1.;\n        vec3 n2 = NdcToSphereNormal(ndc);\n        \n        float sum = dot(abs(n-n2),vec3(1));\n\t\tfragColor = vec4( Heat(sum), 1. );\n    }\n}\n","name":"Image","description":"","type":"image"}]}