{"ver":"0.1","info":{"id":"4tBXWV","date":"1446417419","viewed":213,"name":"MaxNorm Box Tracer","username":"florian","description":"Equivalent of a \"sphere tracer\" in 2d but with max-norm distance.\nSo it is a box tracer, tracing from mouse coord to center of the screen.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["chebyshev","maxnorm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"/*\n\nEquivalent of a \"sphere tracer\" in 2d but with max-norm distance.\nSo it is a box tracer, tracing from mouse coord to center of the screen.\n\nWhile as spheres are great and simple for many things math and ALU,\nboxes love memory better (see the reliable voxelization usecase http://gamma.cs.unc.edu/RECONS/maxnorm.pdf).\nI'm sure there can be further exploitation of these properties.\n\nAll the functions can be most likely simplified further but that's not the point right now.\n\n@rianflo\n\n*/\n\nfloat lengthMaxNorm(vec2 p)\n{\n    return max(abs(p.x), abs(p.y));\n}\n\nfloat distanceMaxNorm(vec2 a, vec2 b)\n{\n    return lengthMaxNorm(b-a);\n}\n\nfloat sdmCircle(vec2 p, vec2 c, float r)\n{\n    c = c-p;\n    float t = -c.y*c.y - c.x*c.x + 2.0*r*r;\n    float s = 2.0*c.x*c.y;\n    float v0 = 0.5*(sqrt(s + t) + c.x + c.y);\n    float v1 = 0.5*(-sqrt(s + t) + c.x + c.y);\n    float v2 = 0.5*(-sqrt(-s + t) - c.x + c.y);\n    float v3 = 0.5*(sqrt(-s + t) - c.x + c.y);\n    \n    float d0 = abs(v0);\n    float d1 = abs(v1);\n    float d2 = abs(v2);\n    float d3 = abs(v3);\n    \n    float d4 = lengthMaxNorm(c+vec2(r, 0.0));\n    float d5 = lengthMaxNorm(c+vec2(0.0, r));\n    float d6 = lengthMaxNorm(c-vec2(r, 0.0));\n    float d7 = lengthMaxNorm(c-vec2(0, r));\n    \n    // hack for sign\n    float sgn = sign(length(c)-r);\n    \n    return sgn * min(min(min(min(min(min(min(d0, d1), d2), d3), d4), d5), d6), d7);\n}\n\nfloat sdmSquare(vec2 p, vec2 c, float r)\n{\n    return distanceMaxNorm(p, c) - r;\n}\n\nfloat getDistance(vec2 p)\n{\n    float d = sdmCircle(p, vec2(0.0), 0.5);\n    return min(d, sdmSquare(p, vec2(0.3, 0.45), 0.3));\n}\n\nfloat rayBoxFarCoeff(vec2 ro, vec2 rd, in vec2 lb, in vec2 ub)\n{\n    vec2 inv_d = 1.0/rd;\n    float t1 = (lb.x - ro.x)*inv_d.x;\n    float t2 = (ub.x - ro.x)*inv_d.x;\n    float t3 = (lb.y - ro.y)*inv_d.y;\n    float t4 = (ub.y - ro.y)*inv_d.y;\n    float tmax = min(max(t1, t2), max(t3, t4));\n    return tmax;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n    vec2 m = (-iResolution.xy + 2.0 * iMouse.xy) / iResolution.y;\n\n    float d = getDistance(p);\n    float o = 0.0;\n    \n    vec2 rp = m;\n    vec2 rd = normalize(0.1*m - m);\n    \n    for (int i=0; i<16; i++)\n    {\n        float sd = getDistance(rp);\n        o += 1.0-smoothstep(0.0, 0.005, abs(sdmSquare(p, rp, sd)));\n        if (abs(sd) < 0.005)\n        {\n            break;\n        }\n        float t = rayBoxFarCoeff(rp, rd, rp-sd, rp+sd);\n        rp += rd *t;\n    }\n    \n    fragColor = vec4(d, o, 1.0-smoothstep(0.0, 0.005, d), 0.0);\n}","name":"","description":"","type":"image"}]}