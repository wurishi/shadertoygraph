{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"int isSinking = 0;\nfloat sinkTimer = -1.0;\n\nvoid parseSinkInfo() {\n    isSinking = int(texelFetch(iChannel0, SINK_CASE, 0).x);\n    sinkTimer = texelFetch(iChannel0, SINK_CASE, 0).y;\n}\n\n//волны\nfloat FloorSDF(vec3 p) {\n    float waveHeight = 0.1 * sin(5.0 * p.x + iTime) * sin(5.0 * p.z + iTime * 0.8);\n    float d = p.y + 1.0 + waveHeight;\n    return d;\n}\n\nfloat SimpleSphereSDF( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n//корпус корабля\nfloat SphereSDF( vec3 p, float r, float h, float t ) { \n    float w = sqrt(r * r - h * h);\n    vec2 q = vec2(length(p.xz), p.y);\n    return ((h * q.x < w * q.y) ? length(q - vec2(w, h)) : abs(length(q) - r)) - t;\n}\n\n//палуба\nfloat deckSDF( vec3 p, float r, float h )\n{\n  float w = sqrt(r*r-h*h);\n  vec2 q = vec2( length(p.xz), -p.y );\n  float s = max( (h-r)*q.x*q.x+w*w*(h+r-2.0*q.y), h*q.x-w*q.y );\n  return (s<0.0) ? length(q)-r :\n         (q.x<w) ? h - q.y     :\n                   length(q-vec2(w,h));\n}\n\n//мачта\nfloat MastSDF( vec3 p, float h, float r ) { \n    p.y -= clamp(p.y, 0.0, h);\n    return length(p) - r;\n}\n   \n//флаг \n float flagSDF(vec3 p, vec3 a, vec3 b, vec3 c) {\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross(ba, ac);\n\n    return sqrt((sign(dot(cross(ba, nor), pa)) +\n                 sign(dot(cross(cb, nor), pb)) +\n                 sign(dot(cross(ac, nor), pc)) < 2.0) ?\n                 min(min(dot(ba * clamp(dot(ba, pa) / dot(ba, ba), 0.0, 1.0) - pa,\n                              ba * clamp(dot(ba, pa) / dot(ba, ba), 0.0, 1.0) - pa),\n                         dot(cb * clamp(dot(cb, pb) / dot(cb, cb), 0.0, 1.0) - pb,\n                              cb * clamp(dot(cb, pb) / dot(cb, cb), 0.0, 1.0) - pb)),\n                         dot(ac * clamp(dot(ac, pc) / dot(ac, ac), 0.0, 1.0) - pc,\n                              ac * clamp(dot(ac, pc) / dot(ac, ac), 0.0, 1.0) - pc)) :\n                 dot(nor, pa) * dot(nor, pa) / dot(nor, nor));\n}\n \n\n// Пушка кораблика \nfloat shipGunSDF(vec3 p, vec3 turretCenter, vec3 pos, vec3 size, float yaw, float pitch) {\n    vec3 gunPos = p - turretCenter;\n\n    // Применение поворота башни\n    gunPos.xz = mat2(cos(yaw), -sin(yaw), sin(yaw), cos(yaw)) * gunPos.xz;\n\n    // Применение наклона пушки\n    gunPos.yz = mat2(cos(pitch), -sin(pitch), sin(pitch), cos(pitch)) * gunPos.yz;\n\n    // Возвращаем пушку обратно на смещенную позицию\n    gunPos -= pos;\n\n    return length(max(abs(gunPos) - size, 0.0));\n}\n\n\n\n//Движение снаряда\nfloat bulletSDF(vec3 p, vec3 pos) {\n    if (shotTime < 0.0) return 1000.0; // Если не выстрелено, возвращаем большое расстояние\n\n\n//Расчет позиции снаряда с течением времени\n    return length(p - pos) - defaultProjectile.radius;\n}\n\n\n\n// Дистанционное поле для всей сцены\nfloat map(vec3 p, out int surfaceType) {\n\n\n    vec3 flagOffset = vec3(0, 0.7, 0.3);\n    vec3 posLeft = vec3(sin(iTime) * 8.0, -0.2, -15);\n    vec3 posRight = vec3(0.0, -0.2, -3);\n    vec3 aLeft = posLeft + flagOffset + vec3(0.1, 1.3, 0);\n    vec3 bLeft = posLeft + flagOffset + vec3(1.1, 0.1, -0.25);\n    vec3 cLeft = posLeft + flagOffset + vec3(0.05, 0.1, -0.1);\n    vec3 aRight = posRight + flagOffset + vec3(-0.2, 2., 0);\n    vec3 bRight = posRight + flagOffset + vec3(2.2, 0.2, -0.5);\n    vec3 cRight = posRight + flagOffset + vec3(-0.1, 0.2, -0.2);\n    \n    float dPlayerFlag = flagSDF(p + vec3(-0.3, 0.1, -3.), aRight, bRight, cRight);\n    float dGround = FloorSDF(p); \n    float dlayerdeck = deckSDF(p+ vec3(-0.0, 0.2, -0.1), 1.8 ,0.0);\n    float dPlayershipBody = SphereSDF(p,  2., 0. , 0.);\n    float dPlayerTurret = MastSDF(p+vec3(0., 1., 0.),3., 0.2);\n    float dPlayerRealTurret = SimpleSphereSDF(p+vec3(1.,0.,0.), .9);\n    float dPlayerGun = shipGunSDF(p + vec3(1.15, -0.2, -0.1), player.turret.position, player.turret.gun.position, player.turret.gun.size * 3., -turretYaw, gunPitch);\n    \n    float dBullet = bulletSDF(p + vec3(1.15, -0.2, -0.1), bulletPos);\n    \n    float dEnemyFlag = flagSDF(p + vec3(4.7, 0.1, 4.), aRight, bRight, cRight);\n    float dEnemyshipBody = SphereSDF(p + vec3(6., 0., 10.), 2., 0. , 0.);\n    float dEmnydeck = deckSDF(p+ vec3(6.0, 0.2, 10.), 1.8 ,0.0);\n    float dEnemyTurret = MastSDF(p + vec3(6., 1., 10.),3., 0.2);\n    float dEnemyGun = shipGunSDF(p+ vec3(6., 1., 20.), enemy.turret.position, enemy.turret.gun.position, enemy.turret.gun.size, PI, 0.);\n    \n    float dEplision = 1000000.0;\n    if (isSinking > 0) {\n        if (iTime - sinkTimer < 1.) {\n            dEplision = SimpleSphereSDF(p + vec3(6., 0., 10.), (iTime - sinkTimer) * 5.);\n            float dlowerEplision = SimpleSphereSDF(p + vec3(6., 0., 10.), (iTime - sinkTimer) * 5. - 0.5);\n            dEplision = opSmoothSubtraction(dlowerEplision, dEplision, 0.1);\n        }\n        else if (iTime - sinkTimer > 1. && iTime - sinkTimer < 2.) {\n            dEnemyFlag = 1000000.0;\n            dEnemyshipBody = 1000000.0;\n            dEmnydeck = 1000000.0;\n            dEnemyFlag = 1000000.0;\n            dEnemyTurret = 1000000.0;\n            dEnemyGun = 1000000.0;\n            \n            dEplision = SimpleSphereSDF(p + vec3(6., 0., 10.), 5.);\n            dGround = opSmoothSubtraction(dEplision, dGround, 0.1);\n            dEplision = 1000000.0;\n        }\n        else {\n            dEnemyFlag = 1000000.0;\n            dEnemyshipBody = 1000000.0;\n            dEmnydeck = 1000000.0;\n            dEnemyFlag = 1000000.0;\n            dEnemyTurret = 1000000.0;\n            dEnemyGun = 1000000.0;\n        }\n    }\n\n    float dPlayership = min(dPlayershipBody, min(dPlayerTurret, dPlayerGun)); // Находим ближайшее расстояние к кораблю игрока\n    float dEnemyship  = min(dEnemyshipBody, min(dEnemyTurret, dEnemyGun));    // Находим ближайшее расстояние к кораблю противника\n\n\n    float minDist = min(dEnemyship, min(dPlayership, dBullet));\n    minDist = min(minDist, dGround);\n    minDist = min(minDist, dlayerdeck);\n    minDist = min(minDist, dEmnydeck);\n    minDist = min(minDist, dEnemyFlag);\n    minDist = min(minDist, dPlayerFlag);\n    minDist = min(minDist, dPlayerRealTurret);\n    minDist = min(minDist, dEplision);\n    \n\n\n    if (minDist == dPlayershipBody)      surfaceType = 1; // Корпус корабля игрока\n    else if (minDist == dGround)         surfaceType = 10;\n    else if (minDist == dlayerdeck)      surfaceType = 11;\n    else if (minDist == dEmnydeck)       surfaceType = 12;\n    else if (minDist == dPlayerTurret)   surfaceType = 2; // Башня игрока\n    else if (minDist == dPlayerGun)      surfaceType = 3; // Пушка игрока\n    else if (minDist == dBullet)         surfaceType = 4; // Снаряд\n    else if (minDist == dEnemyshipBody)  surfaceType = 5; // Корпус моего корабля\n    else if (minDist == dEnemyTurret)    surfaceType = 6; // Башня вражеского корабля\n    else if (minDist == dPlayerFlag)     surfaceType = 8; // flag\n    else if (minDist == dEnemyFlag)      surfaceType = 13;\n    else if (minDist == dPlayerRealTurret)     surfaceType = 14;\n    //else if (minDist == dEplision)       surfaceType = 15;\n    \n  \n    return minDist;\n}\n\n\n\n\n// Вычисление нормали к поверхности с помощью градиента\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    int ignore;\n    return normalize(vec3(\n        map(p + e.xyy, ignore) - map(p - e.xyy, ignore),\n        map(p + e.yxy, ignore) - map(p - e.yxy, ignore),\n        map(p + e.yyx, ignore) - map(p - e.yyx, ignore)\n    ));\n}\n\n// Функция для освещения\nfloat lighting(vec3 p, vec3 lightDir) {\n    vec3 normal = calcNormal(p);\n    return max(dot(normal, lightDir), 0.0);\n}\n\n\n// Основная функция\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    parseBufferA(iChannel0);\n    parseSinkInfo();\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Камера\n    vec3 ro = vec3(0, 2, 10); // Позиция камеры\n    vec3 rd = normalize(vec3(uv, -1.0)); // Направление луча\n    vec3 lightDir = vec3(0.5, 1.0, 1.0);\n\n    // Трассировка\n    float t = 0.0;\n    int surfaceType = 0;\n    vec3 p = ro;\n    for (int i = 0; i < 100; i++) {\n        float d = map(p, surfaceType);\n        if (d < 0.001) break; // Попадание в объект\n        t += d;\n        p = ro + rd * t; // Продвижение луча\n        if (t > 50.0) break; // Ограничение дальности\n    }\n\n    // Раскраска\n    if (t < 50.0) {\n\n        float shade = lighting(p, lightDir);\n   \n        // Пример цвета в зависимости от типа поверхности\n        vec3 color = vec3(0.0);\n        if (surfaceType == 1) color = vec3(0.5, 0.3, 0.3); // Корпус игрока\n        else if (surfaceType == 2) color = vec3(0.6, 0.4, 0.4); // Башня игрока\n        else if (surfaceType == 3) color = vec3(10.0, 0.8, 0.0); // Пушка игрока\n        else if (surfaceType == 5) color = vec3(0.5, 0.3, 0.3); // Корпус игрока\n        else if (surfaceType == 6) color = vec3(0.6, 0.4, 0.4); // Башня игрока\n        else if (surfaceType == 7) color = vec3(0.0, 0.0, 0.8); // Пушка игрока\n        else if (surfaceType == 4) color = vec3(1.0, 0.0, 0.9);\n        else if (surfaceType == 11) color = vec3(0.5,0.3,0.3)*0.5;\n        else if (surfaceType == 12) color = vec3(0.5,0.3,0.3)*0.5;\n        else if (surfaceType == 8) color = vec3(1.0, 0.0, 0.0) / shade;\n        else if (surfaceType == 13) color = vec3(1.0, 0.0, 0.0) / shade;\n        else if (surfaceType == 14) color = vec3(0.5, 0.5, 0.5);\n       // else if (surfaceType == 15) color = vec3(1., 0., 0.);\n        else color = vec3(0.0, 0.0, 1.0);\n        \n        color*=shade;\n        fragColor = vec4(color, 1.0);\n        if (surfaceType == 15) fragColor =vec4(color, 0.0);\n       \n    } else {\n        fragColor = vec4(SKY_COLOR, 1.0); // Фон\n    }\n        \n}\n","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"// GLOBAL SETTINGS\n#define SKY_COLOR vec3(0.5, 0.8, 1.0)\n#define BALLISTIC_ROUNDS\n//#define EXPLOSION_ROUNDS\n\n// CONSTANTS\n#define PI 3.14159265359\n\n// BUFFER_A COORDINATS MAP\n#define TURRET_CASE            ivec2(0, 0)\n#define BULLET_POS_CASE        ivec2(1, 0)\n#define BULLET_VELOCITY_CASE   ivec2(1, 1)\n#define JAVELIN_CASE           ivec2(5, 0)\n#define SINK_CASE              ivec2(6, 0)\n\nfloat angleToPI(float angle) {\n    return angle * PI ;\n}\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\n\nfloat turretYaw = 0.0; // Угол поворота башни\nfloat gunPitch = 0.0;   // Угол подъёма пушки башни\n\n\n\n// Позиция и скорость снаряда\nvec3  bulletPos = vec3(0.0);\nvec3  bulletVelocity = vec3(0.0);\nfloat shotTime = -1.0; // Время последнего выстрела\nfloat javelinStartDistance = 0.0;\n\nvoid getBulletData(sampler2D channel) {\n    bulletPos      = texelFetch(channel, BULLET_POS_CASE, 0).xyz;\n    bulletVelocity = texelFetch(channel, BULLET_VELOCITY_CASE, 0).xyz;\n    shotTime       = texelFetch(channel, BULLET_VELOCITY_CASE, 0).a;\n    javelinStartDistance = texelFetch(channel, BULLET_VELOCITY_CASE, 0).x;\n}\nvoid getTurretData(sampler2D channel) {\n    turretYaw = texelFetch(channel, TURRET_CASE, 0).x;\n    gunPitch   = texelFetch(channel, TURRET_CASE, 0).y;\n}\nvoid parseBufferA(sampler2D channel) {\n    getBulletData(channel);\n    getTurretData(channel);\n  \n}\n\n\n\n// MATH FUNCS\nint modInt(int a, int b) {\n    return a - (a/b)*b;\n}\n\n\n\n// ships\nstruct turretProjectile {\n    vec3 color;\n    float radius;\n    float startingSpeed;\n    float maxSpeed;\n    float gravity;\n    float explosionRadius;\n};\nstruct shipGun {\n    vec3 color;\n    vec3 position;\n    vec3 size;\n    turretProjectile projectile;\n};\nstruct shipTurret {\n    vec3 color;\n    vec3 position;\n    float size;\n    float rotationSpeed;\n    vec3 maxAngles;\n    shipGun gun;\n};\nstruct shipBody {\n    vec3 color;\n    vec3 position;\n    vec3 size;\n};\nstruct ship {\n    uint teamID;\n    float speed;\n    shipTurret turret;\n    shipBody body;\n};\nvec3 javelinStartVelocity = vec3(0.0, 0.0, 0.0);\nconst turretProjectile defaultProjectile = turretProjectile(vec3(1.0,0.0,0.0), 0.3, 0.5, 1.0, 2.0, 0.5);\nconst shipGun blueTeamGun                = shipGun(vec3(0.5,0.5,1.0), vec3(0.0, 0.05, 0.25), vec3(0.05, 0.05, 0.25), defaultProjectile);\nconst shipTurret blueTeamTurret          = shipTurret(vec3(0.5,0.5,1.0), vec3(0.0, 0.25, 0.0), 0.15, 0.05, vec3(90.0, 90.0, 10.0), blueTeamGun);\nconst shipBody blueTeamshipBody          = shipBody(vec3(0.0,0.0,1.0), vec3(0.0, 0.1, 0.0), vec3(0.2, 0.1, 0.3));\nconst ship blueTeamship                  = ship(1u, 1.0, blueTeamTurret, blueTeamshipBody);\n\nconst shipGun redTeamGun                 = shipGun(vec3(1.0,0.0,0.5), vec3(0.0, 0.05, 0.25), vec3(0.05, 0.05, 0.25), defaultProjectile);\nconst shipTurret redTeamTurret           = shipTurret(vec3(1.0,0.0,0.5), vec3(0.0, 0.25, 10.0), 0.15, 0.05, vec3(90.0, 30.0, 10.0), redTeamGun);\nconst shipBody redTeamTankBody           = shipBody(vec3(1.0,0.0,0.0), vec3(0.0, 0.1, 10.0), vec3(0.2, 0.1, 0.3));\nconst ship redTeamship                   = ship(1u, 1.0, redTeamTurret, redTeamTankBody);\n\nconst ship player                        = blueTeamship;\nconst ship enemy                         = redTeamship;","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// INPUT CONSTANTS\n//// ARROWS\n    const int KEY_LEFT  = 37; \n    const int KEY_UP    = 38;\n    const int KEY_RIGHT = 39;\n    const int KEY_DOWN  = 40;\n\n//// WASD\n    const int KEY_W = 87;\n    const int KEY_A = 65;\n    const int KEY_S = 83;\n    const int KEY_D = 68;\n    \n////SPACE\n    const int SPACE_KEY = 32;\n    int sinkEnemy = 0;\n    float sinkTimer = -1.0;\n\n// Функция для инициализации снаряда (выстрел)\nvoid fireBullet() {\n    vec3 gunBasePos = player.turret.position; // Позиция мачты\n    \n    vec3 gunTipOffset =  vec3(0.0, 0.0, player.turret.gun.size.z + defaultProjectile.radius);\n    \n    // Создание матрицы для наклона пушки\n    mat3 rotationMatrix = mat3(\n        cos(-turretYaw), 0.0, sin(-turretYaw),\n        0.0, 1.0, 0.0,\n        -sin(-turretYaw), 0.0, cos(-turretYaw)\n    ) * mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(-gunPitch), -sin(-gunPitch),\n        0.0, sin(-gunPitch), cos(-gunPitch)\n    );\n    bulletPos = gunBasePos + rotationMatrix * (gunTipOffset + player.turret.gun.position);\n    \n    // Установка начальной скорости в направлении пушки\n    bulletVelocity = normalize(rotationMatrix * gunTipOffset) * defaultProjectile.startingSpeed; // Скорость снаряда\n    #ifdef AUTOAIM\n        bulletVelocity += javelinStartVelocity;\n    #endif\n    shotTime = iTime; // Установка времени выстрела\n}\n\n// Обработка вращения\nvoid updateTurretRotation() {\n    float input_var;\n    input_var = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).r - texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).r\n              + texelFetch(iChannel1, ivec2(KEY_D, 0), 0).r - texelFetch(iChannel1, ivec2(KEY_A, 0), 0).r;\n    input_var = clamp(input_var, -1.0f, 1.0f); \n    float maxYawAngle = angleToPI(player.turret.maxAngles.x);\n    turretYaw = clamp(turretYaw + blueTeamTurret.rotationSpeed * input_var, -maxYawAngle, maxYawAngle);\n    \n    input_var = texelFetch(iChannel1, ivec2(KEY_S, 0), 0).r - texelFetch(iChannel1, ivec2(KEY_W, 0), 0).r\n              + texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).r - texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).r;\n    input_var = clamp(input_var, -1.0f, 1.0f);\n    gunPitch = clamp(gunPitch + blueTeamTurret.rotationSpeed * input_var, -angleToPI(player.turret.maxAngles.y), angleToPI(player.turret.maxAngles.z));\n}\n\nvoid handleFire() {\n    if (texelFetch(iChannel1, ivec2(SPACE_KEY, 1), 0).r == 1.)\n        fireBullet();\n}\n\n\nvoid updateInputData() {\n    updateTurretRotation();\n    handleFire();\n}\n\n\nbool checkProjectileCollision() {\n    vec3 bulletCurrentPos = bulletPos;\n    //if (bulletCurrentPos.y < -1.35) {\n    //    return true;\n    //}\n    float minDist = distance(bulletCurrentPos,  vec3(-6., 0., -10));\n    //minDist = min(minDist, distance(bulletCurrentPos, vec3(6., -1., 10.)));\n\n    return (minDist < 2.);\n}\n\n\nvoid parseSinkInfo() {\n    sinkEnemy = int(texelFetch(iChannel0, SINK_CASE, 0).x);\n    sinkTimer = texelFetch(iChannel0, SINK_CASE, 0).y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    parseBufferA(iChannel0);    \n    parseSinkInfo();\n    \n    if (shotTime > 0.0) {\n        float gTime = (iTime - shotTime);\n        #ifdef BALLISTIC_ROUNDS\n            vec3 acceleration = vec3(0.0, defaultProjectile.gravity, 0.0);\n            bulletVelocity -= acceleration * iTimeDelta * vec3(0.0, 1.0, 0.0) * gTime;\n          \n        #endif\n        \n        #ifdef AUTOAIM\n            vec3 targetPos = enemy.body.position;\n            vec3 javelinDirection = normalize(bulletPos - targetPos);\n            if (gTime < 0.01) {\n                javelinStartDistance = distance(bulletPos, targetPos);\n            }\n            float javelinCurDistance = distance(bulletPos, targetPos);\n            bulletVelocity = bulletVelocity - javelinDirection * gTime * 0.1;\n            \n        #endif\n        \n        bulletPos += bulletVelocity;\n        if (sinkEnemy == 0) {\n            if (checkProjectileCollision()) {\n            shotTime = -1.0;\n            sinkTimer = iTime;\n            sinkEnemy = 1;\n        }\n        }\n        \n    }\n    updateInputData();\n    \n    if (ivec2(fragCoord) == TURRET_CASE)\n        fragColor = vec4(turretYaw, gunPitch,0.0,1.0);\n    else if (ivec2(fragCoord) == BULLET_POS_CASE) {\n        fragColor = vec4(bulletPos, 1.0);\n        }\n    else if (ivec2(fragCoord) == BULLET_VELOCITY_CASE) {\n        fragColor = vec4(bulletVelocity, shotTime);\n    }\n    else if (ivec2(fragCoord) == SINK_CASE) {\n        fragColor = vec4(sinkEnemy, sinkTimer, 0., 0.);\n    }\n\n}","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":true,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"XcyBzh","date":"1734093165","viewed":24,"name":"BardakovaNika_CG_HW2","username":"nikbard","description":"BardakovaNika_CG","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["hw2"],"hasliked":0,"parentid":"","parentname":""}}