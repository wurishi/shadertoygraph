{"ver":"0.1","info":{"id":"4sKczK","date":"1522631936","viewed":78,"name":"Circle of light","username":"aachatz","description":"Trying to make a ball of light circle around a static canvas","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["light","circle","shader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Define constant\n    float circleRadius = 0.01;\n    float circleRotationSpeed = 3.0;\n    float rotationDiameterFactor = 4.0;\n    float aspectRatioXY = 1.0;\n    float aspectRatioYX = 1.0;\n    \n    // Used to fix aspect ratios\n    if(iResolution.x > iResolution.y){\n        aspectRatioXY = iResolution.x/iResolution.y;\n    } else {\n\t\taspectRatioYX = iResolution.y/iResolution.x;\n    }\n\n    // Get current uv coordinate\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Define a background colour\n    vec4 col = vec4(0.2, 0.1, 0.9, 1.0);\n    \n    // Define colour of light\n    vec3 light = vec3(1.0,1.0,1.0);\n    \n    // Define center point for circle\n    float circleCenterX = ((uv.x - 0.5) - (sin(iTime * circleRotationSpeed)) \n                           / rotationDiameterFactor);\n    \n    float circleCenterY = ((uv.y - 0.5) - (tan(iTime * circleRotationSpeed)) \n                           / rotationDiameterFactor);\n    \n    // Fix aspect ratio only when we want to draw\n    circleCenterX *= aspectRatioXY;\n\tcircleCenterY *= aspectRatioYX;\n    \n    // Calculate current position based on uv\n    float currentPosition = pow(circleCenterX, 2.0) + pow(circleCenterY, 2.0);\n    \n    if(currentPosition <= circleRadius){\n        \n        // Set to colour of light\n\t\tfloat radiusAlpha = abs((circleRadius - currentPosition)/circleRadius);\n\t\tcol = vec4(light, 0.0);\n    }\n    \n    // Output to screen\n    fragColor = col;\n    fragColor.a = 0.4;\n}","name":"Image","description":"","type":"image"}]}