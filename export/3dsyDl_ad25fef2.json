{"ver":"0.1","info":{"id":"3dsyDl","date":"1585847521","viewed":159,"name":"Ray Marching Hello World","username":"Ractive","description":"learn from http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 200\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat boxSDF(vec3 p, vec3 size) {\n    vec3 d = abs(p) - (size / 2.0);\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat cubeSDF( vec3 p)\n{\n  vec3 q = abs(p) - 1.;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat cylinderSDF(vec3 p, float h, float r) {\n    float inOutRadius = length(p.xy) - r;\n    float inOutHeight = abs(p.z) - h/2.0;\n    float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);\n\n    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat ballOffset(float offset){\n    return 0.4 + 1.0 + sin(1.7 * iTime+offset*3.1415926);\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n    samplePoint = rotateY(iTime / 2.0) * samplePoint;\n    \n    float cylinderRadius = 0.4 + (1.0 - 0.4) * (1.0 + sin(1.7 * iTime)) / 2.0;\n    float cylinder1 = cylinderSDF(samplePoint, 2.0, cylinderRadius);\n    float cylinder2 = cylinderSDF(rotateX(radians(90.0)) * samplePoint, 2.0, cylinderRadius);\n    float cylinder3 = cylinderSDF(rotateY(radians(90.0)) * samplePoint, 2.0, cylinderRadius);\n    \n    float cube = boxSDF(samplePoint, vec3(1.8, 1.8, 1.8));\n    \n    float sphere = sphereSDF(samplePoint, 1.2);\n\n    float ballRadius = 0.3;\n    \n    float balls = sphereSDF(samplePoint - vec3(ballOffset(1.), 0.0, 0.0), ballRadius);\n    balls = unionSDF(balls, sphereSDF(samplePoint + vec3(ballOffset(1.), 0.0, 0.0), ballRadius));\n    balls = unionSDF(balls, sphereSDF(samplePoint - vec3(0.0, ballOffset(2.), 0.0), ballRadius));\n    balls = unionSDF(balls, sphereSDF(samplePoint + vec3(0.0, ballOffset(2.), 0.0), ballRadius));\n    balls = unionSDF(balls, sphereSDF(samplePoint - vec3(0.0, 0.0, ballOffset(3.)), ballRadius));\n    balls = unionSDF(balls, sphereSDF(samplePoint + vec3(0.0, 0.0, ballOffset(3.)), ballRadius));\n\n    \n    float csgNut = differenceSDF(intersectSDF(cube, sphere),\n                         unionSDF(cylinder1, unionSDF(cylinder2, cylinder3)));\n    \n    return unionSDF(balls, csgNut);\n}\n\nfloat GetDist(vec3 p) {\n    \n    float planeDist = p.y+1.8;\n    float fScene=sceneSDF(vec3(p.x,p.y-1.,p.z));\n\n    float n=min(planeDist,fScene);\n    return n;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 phongContribForLight(vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n                         \n    vec3 k_a = vec3(0.2, 0.2, 0.2);\n    vec3 k_d = vec3(1, 1, 1);\n    vec3 k_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    vec3 N = GetNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = clamp(dot(L, N),0.,1.);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, shininess));\n}\n\nvec3 phongIllumination(vec3 p, vec3 eye) {\n    vec3 k_a = vec3(0.2, 0.2, 0.2);\n    const vec3 ambientLight = 0.6 * vec3(1.0, 0.8, 1.0);\n    vec3 color = ambientLight * k_a*1.;\n    \n    vec3 light1Pos = vec3(2.0 * sin(iTime),\n                          2.0,\n                          2.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.3, 0.4, 0.9);\n    \n    color += phongContribForLight(p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.7, 0.4, 0.3);\n    \n    color += phongContribForLight(p, eye,\n                                  light2Pos,\n                                  light2Intensity);  \n    vec3 light3Pos = vec3(0.0 * sin(0.37 * iTime),\n                          -2.0 * cos(0.37 * iTime),\n                          -2.0);\n    vec3 light3Intensity = vec3(0.7, 0.4, 0.3);\n    \n    color += phongContribForLight(p, eye,\n                                  light3Pos,\n                                  light3Intensity);    \n                                  \n    return color;\n}\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 3, 3);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 lightPos2 = vec3(0, 1, 3);\n    lightPos2.xz += vec2(sin(iTime+1.), cos(iTime+1.))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 l2 = normalize(lightPos2-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    if(d<length(lightPos2-p)) dif +=clamp(dot(n, l2), 0., 1.)*.1;\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 1, -5);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float dif = GetLight(p);\n    col=phongIllumination(p,ro);\n    //col = vec3(dif);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}