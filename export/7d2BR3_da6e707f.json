{"ver":"0.1","info":{"id":"7d2BR3","date":"1646795395","viewed":330,"name":"Smith BSDF Clearcoat","username":"LeeTheDev","description":"A clear-coat Smith microsurface BSDF implementation using the Trowbridge-Reitz distribution. This is very intensive, but it is unbiased which is nice.","likes":5,"published":1,"flags":48,"usePreview":1,"tags":["specular","brdf","diffuse","smith","bsdf"],"hasliked":0,"parentid":"fsjfzV","parentname":"Smith BSDF"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nPress \"M\" to reset accumulation without turning on/off the furnace test. \nPress \"D\" to turn on/off the transmittance within the clear coat interface. \nPress up arrow to disable or enable the furnace test. \nPress down arrow to make the white furnace test into environment lighting and vice versa.\nPress left arrow to enable colored spheres for environment lighting and furnace test.\nPress right arrow to enable metal spheres. (Only works for the environment lighting and furnace test)\n\nCertain settings from my other BSDF implementations are not supported here just yet\n*/\n\n/*\n    From here.\n\n    https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n*/\nconst mat3x3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\nconst mat3x3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v) {\n    vec3 a = v * (v + 0.0245786f) - 0.000090537f;\n    vec3 b = v * (0.983729f * v + 0.4329510f) + 0.238081f;\n    return a / b;\n}\n\nvec3 ACESFitted(vec3 color) {\n    color = color * ACESInputMat;\n    color = RRTAndODTFit(color);\n    color = color * ACESOutputMat;\n    color = saturate(color);\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = ACESFitted(texture(iChannel0, uv).rgb);\n         col = LinearToSrgb(col);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define _square(x) (x*x)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define rcp(x) (1.0 / x)\n#define log10(x) (log2(x) / log2(10.0))\n#define coneAngleToSolidAngle(x) (tau*(1.0 - cos(x)))\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_M = 77;\nconst int KEY_D = 68;\n\nconst float pi = radians(180.0);\nconst float tau = radians(360.0);\nconst float rpi = 1./acos(-1.);\nconst float hpi = acos(0.);\nconst float phi = sqrt(5.) * .5 + .5;\nconst float pi4 = 12.5663706;\nconst float pidiv2 = pi * 0.5;\nconst float piSquared = pi*pi;\nconst float goldenAngle = tau / (phi + 1.0);\n\nconst vec3 lumacoeff_rec709 = vec3(0.2125, 0.7154, 0.0721);\n\nfloat square(in float x) {\n    return _square(x);\n}\n\nvec3 square(in vec3 x) {\n    return _square(x);\n}\n\nfloat cube(in float x) {\n    return x * x * x;\n}\n\nvec3 LinearToSrgb(vec3 linear) {\n    vec3 SRGBLo = linear * 12.92;\n    vec3 SRGBHi = (pow(abs(linear), vec3(1.0/2.4)) * 1.055) - 0.055;\n    vec3 SRGB = mix(SRGBHi, SRGBLo, step(linear, vec3(0.0031308)));\n    return SRGB;\n}\n\nvec3 SrgbToLinear(vec3 color) {\n    vec3 linearRGBLo = color / 12.92;\n    vec3 linearRGBHi = pow((color + 0.055) / 1.055, vec3(2.4));\n    vec3 linearRGB = mix(linearRGBHi, linearRGBLo, step(color, vec3(0.04045)));\n    return linearRGB;\n}\n\nvec2 sincos(float x) { return vec2(sin(x), cos(x)); }\n\nmat2 Rotate(float a) {\n    vec2 m;\n    m.x = sin(a);\n    m.y = cos(a);\n\treturn mat2(m.y, -m.x,  m.x, m.y);\n}\n\nvec2 Rotate(vec2 vector, float angle) {\n\tvec2 sc = sincos(angle);\n\treturn vec2(sc.y * vector.x + sc.x * vector.y, sc.y * vector.y - sc.x * vector.x);\n}\n\nvec3 Rotate(vec3 vector, vec3 axis, float angle) {\n\t// https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula\n\tvec2 sc = sincos(angle);\n\treturn sc.y * vector + sc.x * cross(axis, vector) + (1.0 - sc.y) * dot(axis, vector) * axis;\n}\n\nvec3 Rotate(vec3 vector, vec3 from, vec3 to) {\n\t// where \"from\" and \"to\" are two unit vectors determining how far to rotate\n\t// adapted version of https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula\n\n\tfloat cosTheta = dot(from, to);\n\tif (abs(cosTheta) >= 0.9999) { return cosTheta < 0.0 ? -vector : vector; }\n\tvec3 axis = normalize(cross(from, to));\n\n\tvec2 sc = vec2(sqrt(1.0 - cosTheta * cosTheta), cosTheta);\n\treturn sc.y * vector + sc.x * cross(axis, vector) + (1.0 - sc.y) * dot(axis, vector) * axis;\n}\n\nmat3 GetRotationMatrix(vec3 from, vec3 to) {\n\tfloat cosine = dot(from, to);\n\n\t//float tmp = SignExtract(cosine);\n\tfloat tmp = cosine < 0.0 ? -1.0 : 1.0;\n\t\t\ttmp = 1.0 / (tmp + cosine);\n\n\tvec3 axis = cross(to, from);\n\tvec3 tmpv = axis * tmp;\n\n\treturn mat3(\n\t\taxis.x * tmpv.x + cosine, axis.x * tmpv.y - axis.z, axis.x * tmpv.z + axis.y,\n\t\taxis.y * tmpv.x + axis.z, axis.y * tmpv.y + cosine, axis.y * tmpv.z - axis.x,\n\t\taxis.z * tmpv.x - axis.y, axis.z * tmpv.y + axis.x, axis.z * tmpv.z + cosine\n\t);\n}\n\nmat3 GetRotationMatrix(vec3 unitAxis, float angle) {\n    float cosine = cos(angle);\n\n    vec3 axis = unitAxis * sin(angle);\n    vec3 tmp = unitAxis - unitAxis * cosine;\n\n    return mat3(\n        unitAxis.x * tmp.x + cosine, unitAxis.x * tmp.y - axis.z, unitAxis.x * tmp.z + axis.y,\n        unitAxis.y * tmp.x + axis.z, unitAxis.y * tmp.y + cosine, unitAxis.y * tmp.z - axis.x,\n        unitAxis.z * tmp.x - axis.y, unitAxis.z * tmp.y + axis.x, unitAxis.z * tmp.z + cosine\n    );\n}\n\nfloat minof(vec2 x) { \n    return min(x.x, x.y); \n}\nfloat minof(vec3 x) { \n    return min(min(x.x, x.y), x.z); \n}\nfloat minof(vec4 x) { \n    x.xy = min(x.xy, x.zw); return min(x.x, x.y); \n}\n\nfloat maxof(vec2 x) { \n    return max(x.x, x.y); \n}\nfloat maxof(vec3 x) { \n    return max(max(x.x, x.y), x.z); \n}\nfloat maxof(vec4 x) { \n    x.xy = max(x.xy, x.zw); return max(x.x, x.y); \n}\n\nvec3 GenerateUnitVector(vec2 hash) {\n    hash.x *= tau; hash.y = hash.y * 2.0 - 1.0;\n    return vec3(vec2(sin(hash.x), cos(hash.x)) * sqrt(saturate(1.0 - hash.y * hash.y)), hash.y);\n}\n\nvec3 GenerateCosineVector(vec3 vector, vec2 xy) {\n    vec3 dir = GenerateUnitVector(xy);\n\n    if(vector + dir == vec3(0.0)) {\n        return vector;\n    } else {\n        return normalize(vector + dir);\n    }\n}\n\nvec2 RSI(vec3 pos, vec3 dir, float radius) {\n    float radiusSquared = square(radius);\n    float posDotDir = dot(pos, dir);\n    float endDist = posDotDir*posDotDir + radiusSquared - dot(pos, pos);\n\n    if(endDist < 0.0) return vec2(-1.0);\n\n    endDist = sqrt(endDist);\n    vec2 ret = -posDotDir + vec2(-endDist, endDist);\n\n    return ret;\n}\n\nbool IntersectSphere(in vec3 rayPosition, in vec3 rayDirection, in float radius, out float dist) {\n    vec2 sphereDists = RSI(rayPosition, rayDirection, radius);\n    \n    if(sphereDists.x > 0.001) {\n        dist = sphereDists.x;\n        return true;\n    } else {\n        dist = sphereDists.y;\n        if(dist < 0.001) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n}\n\nint LinePlaneIntersection(\n    vec3 Lo, vec3 Lv,\n    vec3 Po, vec3 Pn,\n    out float t\n) {\n    float NdotV = dot(Pn, Lv);\n    float NdotO = dot(Pn, Lo - Po);\n    if (NdotV == 0.0) {\n        if (NdotO == 0.0) {\n            return 2;\n        } else {\n            return 0;\n        }\n    }\n\n    t = NdotO / -NdotV;\n\n    return 1;\n}\n\nint RayPlaneIntersection(\n    vec3 Ro, vec3 Rv,\n    vec3 Po, vec3 Pn,\n    out float t\n) {\n    int tmp = LinePlaneIntersection(Ro, Rv, Po, Pn, t);\n    if (tmp == 1 && t < 0.0) {\n        return 0;\n    }\n    \n    if (dot(Rv, Pn) > 0.0) { return 0; }\n\n    return tmp;\n}\n\nuvec3 pcg3d(uvec3 v) {\n    // http://www.jcgt.org/published/0009/03/02/\n\tv = v*1664525u + 1013904223u;\n\tv.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n\tv ^= v >> 16u;\n\tv.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n\treturn v;\n}\nuvec4 pcg4d(uvec4 v) {\n\tv = v*1664525u + 1013904223u;\n\tv.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n\tv ^= v >> 16u;\n\tv.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n\treturn v;\n}\n\n// https://nullprogram.com/blog/2018/07/31/\nuint lowbias32(uint x) {\n\tx ^= x >> 16;\n\tx *= 0x7feb352du;\n\tx ^= x >> 15;\n\tx *= 0x846ca68bu;\n\tx ^= x >> 16;\n\treturn x;\n}\n\nuint randState;\nvoid InitRand(uint seed) { randState = lowbias32(seed); }\nuint RandNext() { return randState = lowbias32(randState); }\n#define RandNext2() uvec2(RandNext(), RandNext())\n#define RandNext3() uvec3(RandNext2(), RandNext())\n#define RandNext4() uvec4(RandNext3(), RandNext())\n#define RandNextF() (float(RandNext()) / float(0xffffffffu))\n#define RandNext2F() (vec2(RandNext2()) / float(0xffffffffu))\n#define RandNext3F() (vec3(RandNext3()) / float(0xffffffffu))\n#define RandNext4F() (vec4(RandNext4()) / float(0xffffffffu))\n\n//Complex numbers and functions\nstruct complexFloat {\n\tfloat r;\n\tfloat i;\n};\n\ncomplexFloat complexAdd(complexFloat a, complexFloat b) {\n\tcomplexFloat c;\n\tc.r=a.r+b.r;\n\tc.i=a.i+b.i;\n\treturn c;\n}\n\ncomplexFloat complexAdd(float a, complexFloat b) {\n\tcomplexFloat c;\n\tc.r=a+b.r;\n\tc.i= +b.i;\n\treturn c;\n}\n\ncomplexFloat complexAdd(complexFloat a, float b) {\n\tcomplexFloat c;\n\tc.r=a.r+b;\n\tc.i=  a.i;\n\treturn c;\n}\n\ncomplexFloat complexSub(complexFloat a, complexFloat b) {\n\tcomplexFloat c;\n\tc.r=a.r-b.r;\n\tc.i=a.i-b.i;\n\treturn c;\n}\n\ncomplexFloat complexSub(complexFloat a, float b) {\n\tcomplexFloat c;\n\tc.r=a.r-b;\n\tc.i=  a.i;\n\treturn c;\n}\n\ncomplexFloat complexSub(float a, complexFloat b) {\n\tcomplexFloat c;\n\tc.r=a-b.r;\n\tc.i= -b.i;\n\treturn c;\n}\n\ncomplexFloat complexMul(complexFloat a, complexFloat b) {\n\tcomplexFloat c;\n\tc.r=a.r*b.r-a.i*b.i;\n\tc.i=a.i*b.r+a.r*b.i;\n\treturn c;\n}\n\ncomplexFloat complexMul(float x, complexFloat a) {\n\tcomplexFloat c;\n\tc.r=x*a.r;\n\tc.i=x*a.i;\n\treturn c;\n}\n\ncomplexFloat complexMul(complexFloat x, float a) {\n\tcomplexFloat c;\n\tc.r=x.r*a;\n\tc.i=x.i*a;\n\treturn c;\n}\n\ncomplexFloat complexSquare(complexFloat x) {\n    return complexMul(x, x);\n}\n\ncomplexFloat complexConjugate(complexFloat z) {\n\tcomplexFloat c;\n\tc.r=z.r;\n\tc.i = -z.i;\n\treturn c;\n}\n\ncomplexFloat complexDiv(complexFloat a, complexFloat b) {\n\tcomplexFloat c;\n\tfloat r,den;\n\tif (abs(b.r) >= abs(b.i)) {\n\t\tr=b.i/b.r;\n\t\tden=b.r+r*b.i;\n\t\tc.r=(a.r+r*a.i)/(den);\n\t\tc.i=(a.i-r*a.r)/(den);\n\t} else {\n\t\tr=b.r/b.i;\n\t\tden=b.i+r*b.r;\n\t\tc.r=(a.r*r+a.i)/(den);\n\t\tc.i=(a.i*r-a.r)/(den);\n\t}\n\treturn c;\n}\n\nfloat complexAbs(complexFloat z) {\n\treturn sqrt(z.r*z.r + z.i*z.i);\n}\n\ncomplexFloat complexSqrt(complexFloat z) {\n\tcomplexFloat c;\n\tfloat x,y,w,r;\n\tif ((z.r == 0.0) && (z.i == 0.0)) {\n\t\tc.r=0.0;\n\t\tc.i=0.0;\n\t\treturn c;\n\t} else {\n\t\tx=abs(z.r);\n\t\ty=abs(z.i);\n\t\tif (x >= y) {\n\t\t\tr=y/x;\n\t\t\tw=sqrt(x)*sqrt(0.5*(1.0+sqrt(1.0+r*r)));\n\t\t} else {\n\t\t\tr=x/y;\n\t\t\tw=sqrt(y)*sqrt(0.5*(r+sqrt(1.0+r*r)));\n\t\t}\n\t\tif (z.r >= 0.0) {\n\t\t\tc.r=w;\n\t\t\tc.i=z.i/(2.0*w);\n\t\t} else {\n\t\t\tc.i=(z.i >= 0.0) ? w : -w;\n\t\t\tc.r=z.i/(2.0*c.i);\n\t\t}\n\t\treturn c;\n\t}\n}\n\ncomplexFloat complexExp(complexFloat z) {\n\treturn complexMul(exp(z.r), complexFloat(cos(z.i), sin(z.i)));\n}\n\ncomplexFloat complexLog(complexFloat z) {\n    return complexFloat(0.5 * log(z.r * z.r + z.i * z.i), atan(z.i, z.r));\n}\n\ncomplexFloat complexSinh(complexFloat z) {\n    return complexFloat(sinh(z.r) * cos(z.i), cosh(z.r) * sin(z.i));\n}\ncomplexFloat complexCosh(complexFloat z) {\n    return complexFloat(cosh(z.r) * cos(z.i), sinh(z.r) * sin(z.i));\n}\n\ncomplexFloat complexSin(complexFloat z) {\n\tz = complexDiv(complexSub(complexExp(complexMul(complexFloat(0.0, 1.0), z)), complexExp(complexMul(complexFloat(0.0, -1.0), z))), complexFloat(0.0, 2.0));\n    return z;\n}\ncomplexFloat complexCos(complexFloat z) {\n\tz = complexDiv(complexAdd(complexExp(complexMul(complexFloat(0.0, 1.0), z)), complexExp(complexMul(complexFloat(0.0, -1.0), z))), complexFloat(2.0, 0.0));\n    return z;\n}\ncomplexFloat complexArgument(complexFloat z) {\n  return complexFloat(atan(z.i, z.r), 0.0);\n}\ncomplexFloat complexArcsin(complexFloat z) {\n  return complexDiv(\n\t  complexLog(\n\t\t  complexAdd(\n\t\t\t  complexMul(complexFloat(0.0, 1.0), z), \n\t\t\t  complexMul(\n\t\t\t\t  sqrt(\n\t\t\t\t\t  complexAbs(\n\t\t\t\t\t\t  complexSub(1.0, complexSquare(z))\n\t\t\t\t\t\t)\n\t\t\t\t\t),\n\t\t\t  complexExp(\n\t\t\t\t  complexMul(\n\t\t\t\t\t  complexFloat(0.0, 0.5), \n\t\t\t\t\t  complexArgument(\n\t\t\t\t\t\t  complexSub(1.0, complexSquare(z))\n\t\t\t\t\t  \t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t), \n\t\tcomplexFloat(0.0, 1.0)\n\t);\n}\n\ncomplexFloat vectorToComplex(vec2 z) {\n\treturn complexFloat(z.x, z.y);\n}\n\ncomplexFloat SnellsLaw(complexFloat theta_i, complexFloat n_i, complexFloat n_t) {\n    return complexArcsin(complexMul(complexDiv(n_i, n_t), complexSin(theta_i)));\n}\n\ncomplexFloat r_s(complexFloat theta_i, complexFloat theta_t, complexFloat n_i, complexFloat n_t) {\n    return complexDiv(\n        complexSub(complexMul(n_i, complexCos(theta_i)), complexMul(n_t, complexCos(theta_t))),\n        complexAdd(complexMul(n_i, complexCos(theta_i)), complexMul(n_t, complexCos(theta_t)))\n    );\n}\ncomplexFloat t_s(complexFloat theta_i, complexFloat theta_t, complexFloat n_i, complexFloat n_t) {\n    return complexDiv(\n        complexMul(2.0, complexMul(n_i, complexCos(theta_i))),\n        complexAdd(complexMul(n_i, complexCos(theta_i)), complexMul(n_t, complexCos(theta_t)))\n    );\n}\ncomplexFloat r_p(complexFloat theta_i, complexFloat theta_t, complexFloat n_i, complexFloat n_t) {\n    return complexDiv(\n        complexSub(complexMul(n_t, complexCos(theta_i)), complexMul(n_i, complexCos(theta_t))),\n        complexAdd(complexMul(n_t, complexCos(theta_i)), complexMul(n_i, complexCos(theta_t)))\n    );\n}\ncomplexFloat t_p(complexFloat theta_i, complexFloat theta_t, complexFloat n_i, complexFloat n_t) {\n    return complexDiv(\n        complexMul(2.0, complexMul(n_i, complexCos(theta_i))),\n        complexAdd(complexMul(n_t, complexCos(theta_i)), complexMul(n_i, complexCos(theta_t)))\n    );\n}\n\nfloat FresnelNonPolarized_R(in float cosTheta, in complexFloat n1, in complexFloat n2) {\n    complexFloat thetaI = complexFloat(acos(cosTheta), 0.0);\n    complexFloat thetaT = SnellsLaw(thetaI, n1, n2);\n\n    float Rs = square(complexAbs(r_s(thetaI, thetaT, n1, n2)));\n    float Rp = square(complexAbs(r_p(thetaI, thetaT, n1, n2)));\n\n    return saturate((Rs + Rp) * 0.5);\n}\n\nfloat FresnelNonPolarized_T(in float cosTheta, in complexFloat n1, in complexFloat n2) {\n    complexFloat thetaI = complexFloat(acos(cosTheta), 0.0);\n    complexFloat thetaT = SnellsLaw(thetaI, n1, n2);\n\n    if(complexAbs(complexSin(thetaT)) > 1.0) {\n        return 0.0;\n    }\n\n    float Ts = square(complexAbs(t_s(thetaI, thetaT, n1, n2)));\n    float Tp = square(complexAbs(t_p(thetaI, thetaT, n1, n2)));\n\n    complexFloat cosThetaI = complexCos(thetaI);\n    complexFloat cosThetaT = complexCos(thetaT);\n\n    float beamRatio = complexAbs(complexDiv(complexMul(n2, cosThetaT), complexMul(n1, cosThetaI)));\n\n    return saturate(beamRatio * (Ts + Tp) * 0.5);\n}\n\ncomplexFloat phase_change(complexFloat wavelength, float thickness, complexFloat theta_2) {\n    // not entirely sure this is correct yet\n    complexFloat path_length_wavelengths = complexDiv(complexMul(complexFloat(thickness, 0.0), complexCos(theta_2)), wavelength);\n    complexFloat path_length_phase_radians = complexMul(tau, path_length_wavelengths);\n    return complexExp(complexMul(complexFloat(0.0, 1.0), path_length_phase_radians));\n}\n\nvoid thin_film_amplitudes(\n    float incident_angle,\n    float incident_wavelength,\n    float thickness,\n    complexFloat n_1, // media on current side\n    complexFloat n_2, // media of thin film\n    complexFloat n_3, // media on other side\n    out complexFloat apparent_amplitude_s_reflected,\n    out complexFloat apparent_amplitude_p_reflected,\n    out complexFloat apparent_amplitude_s_transmitted,\n    out complexFloat apparent_amplitude_p_transmitted\n) {\n    // Wave propagation direction changes in the different media according to Snell's law\n    complexFloat theta_1 = complexFloat(incident_angle, 0.0);\n    complexFloat theta_2 = SnellsLaw(theta_1, n_1, n_2);\n    complexFloat theta_3 = SnellsLaw(theta_1, n_1, n_3);\n\n    // Wavelength also changes in the different media in a similar manner\n    complexFloat wavelength_1 = complexFloat(incident_wavelength, 0.0);\n    complexFloat wavelength_2 = complexMul(complexDiv(n_1, n_2), wavelength_1);\n    complexFloat wavelength_3 = complexMul(complexDiv(n_1, n_3), wavelength_1);\n\n    // compute wave amplitudes\n    complexFloat propagation_phase_change = phase_change(wavelength_2, thickness, theta_2);\n\n    complexFloat amplitude_s_incident_1_2    = complexFloat(1.0, 0.0);\n    complexFloat amplitude_s_reflected_1_2   = complexMul(amplitude_s_incident_1_2, r_s(theta_1, theta_2, n_1, n_2));\n    complexFloat amplitude_s_transmitted_1_2 = complexMul(amplitude_s_incident_1_2, t_s(theta_1, theta_2, n_1, n_2));\n    complexFloat amplitude_p_incident_1_2    = complexFloat(1.0, 0.0);\n    complexFloat amplitude_p_reflected_1_2   = complexMul(amplitude_p_incident_1_2, r_p(theta_1, theta_2, n_1, n_2));\n    complexFloat amplitude_p_transmitted_1_2 = complexMul(amplitude_p_incident_1_2, t_p(theta_1, theta_2, n_1, n_2));\n\n    complexFloat r_s_2_3 = r_s(theta_2, theta_3, n_2, n_3);\n    complexFloat t_s_2_3 = t_s(theta_2, theta_3, n_2, n_3);\n    complexFloat r_p_2_3 = r_p(theta_2, theta_3, n_2, n_3);\n    complexFloat t_p_2_3 = t_p(theta_2, theta_3, n_2, n_3);\n\n    complexFloat amplitude_s_incident_2_3    = complexMul(amplitude_s_transmitted_1_2, propagation_phase_change);\n    complexFloat amplitude_s_reflected_2_3   = complexMul(amplitude_s_incident_2_3, r_s_2_3);\n    complexFloat amplitude_s_transmitted_2_3 = complexMul(amplitude_s_incident_2_3, t_s_2_3);\n    complexFloat amplitude_p_incident_2_3    = complexMul(amplitude_p_transmitted_1_2, propagation_phase_change);\n    complexFloat amplitude_p_reflected_2_3   = complexMul(amplitude_p_incident_2_3, r_p_2_3);\n    complexFloat amplitude_p_transmitted_2_3 = complexMul(amplitude_p_incident_2_3, t_p_2_3);\n\n    complexFloat r_s_2_1 = r_s(theta_2, theta_1, n_2, n_1);\n    complexFloat t_s_2_1 = t_s(theta_2, theta_1, n_2, n_1);\n    complexFloat r_p_2_1 = r_p(theta_2, theta_1, n_2, n_1);\n    complexFloat t_p_2_1 = t_p(theta_2, theta_1, n_2, n_1);\n\n    apparent_amplitude_s_reflected   = amplitude_s_reflected_1_2;\n    apparent_amplitude_s_transmitted = amplitude_s_transmitted_2_3;\n    apparent_amplitude_p_reflected   = amplitude_p_reflected_1_2;\n    apparent_amplitude_p_transmitted = amplitude_p_transmitted_2_3;\n\n    complexFloat coeff_s_reflected   = complexMul(complexMul(r_s_2_1, r_s_2_3), complexMul(propagation_phase_change, propagation_phase_change));\n    complexFloat coeff_p_reflected   = complexMul(complexMul(r_p_2_1, r_p_2_3), complexMul(propagation_phase_change, propagation_phase_change));\n    complexFloat coeff_s_transmitted = complexMul(complexMul(r_s_2_3, r_s_2_1), complexMul(propagation_phase_change, propagation_phase_change));\n    complexFloat coeff_p_transmitted = complexMul(complexMul(r_p_2_3, r_p_2_1), complexMul(propagation_phase_change, propagation_phase_change));\n\n    complexFloat tmp_s_reflected = complexDiv(complexMul(amplitude_s_reflected_2_3, propagation_phase_change), complexSub(1.0, coeff_s_reflected));\n    complexFloat tmp_p_reflected = complexDiv(complexMul(amplitude_p_reflected_2_3, propagation_phase_change), complexSub(1.0, coeff_p_reflected));\n    complexFloat tmp_s_transmitted = complexDiv(complexMul(complexMul(complexMul(amplitude_s_reflected_2_3, propagation_phase_change), r_s_2_1), propagation_phase_change), complexSub(1.0, coeff_s_transmitted));\n    complexFloat tmp_p_transmitted = complexDiv(complexMul(complexMul(complexMul(amplitude_p_reflected_2_3, propagation_phase_change), r_p_2_1), propagation_phase_change), complexSub(1.0, coeff_p_transmitted));\n\n    apparent_amplitude_s_reflected   = complexAdd(apparent_amplitude_s_reflected,   complexMul(tmp_s_reflected,   t_s_2_1));\n    apparent_amplitude_p_reflected   = complexAdd(apparent_amplitude_p_reflected,   complexMul(tmp_p_reflected,   t_p_2_1));\n    apparent_amplitude_s_transmitted = complexAdd(apparent_amplitude_s_transmitted, complexMul(tmp_s_transmitted, t_s_2_3));\n    apparent_amplitude_p_transmitted = complexAdd(apparent_amplitude_p_transmitted, complexMul(tmp_p_transmitted, t_p_2_3));\n}\n\nfloat FresnelThinFilmInterferenceReflected(in float cosTheta, in float thickness, in float lambda, in complexFloat n0, in complexFloat n1, in complexFloat n2) {\n    complexFloat apparent_amplitude_s_reflected;\n    complexFloat apparent_amplitude_p_reflected;\n    complexFloat apparent_amplitude_s_transmitted;\n    complexFloat apparent_amplitude_p_transmitted;\n    thin_film_amplitudes(acos(cosTheta), lambda, thickness, n0, n1, n2, apparent_amplitude_s_reflected, apparent_amplitude_p_reflected, apparent_amplitude_s_transmitted, apparent_amplitude_p_transmitted);\n    return saturate((square(complexAbs(apparent_amplitude_s_reflected)) + square(complexAbs(apparent_amplitude_p_reflected))) / 2.0);\n}\n\nfloat FresnelThinFilmInterferenceTransmitted(in float cosTheta, in float thickness, in float lambda, in complexFloat n0, in complexFloat n1, in complexFloat n2) {\n    complexFloat apparent_amplitude_s_reflected;\n    complexFloat apparent_amplitude_p_reflected;\n    complexFloat apparent_amplitude_s_transmitted;\n    complexFloat apparent_amplitude_p_transmitted;\n    thin_film_amplitudes(acos(cosTheta), lambda, thickness, n0, n1, n2, apparent_amplitude_s_reflected, apparent_amplitude_p_reflected, apparent_amplitude_s_transmitted, apparent_amplitude_p_transmitted);\n\n    //Transmittance requires extra work to make sure things work correctly.\n\n    complexFloat theta_0 = complexFloat(acos(cosTheta), 0.0);\n    complexFloat theta_1 = SnellsLaw(theta_0, n0, n1);\n    complexFloat theta_2 = SnellsLaw(theta_0, n0, n2);\n\n    if(complexAbs(complexSin(theta_1)) > 1.0 || complexAbs(complexSin(theta_2)) > 1.0) {\n        return 0.0;\n    }\n\n    complexFloat cosThetaI = complexCos(theta_0);\n\n    complexFloat cosThetaT_1 = complexCos(theta_1);\n    complexFloat cosThetaT_2 = complexCos(theta_2);\n\n    float beamRatio = complexAbs(complexDiv(complexMul(n2, cosThetaT_2), complexMul(n0, cosThetaI)));\n\n    return saturate(beamRatio * (square(complexAbs(apparent_amplitude_s_transmitted)) + square(complexAbs(apparent_amplitude_p_transmitted))) / 2.0);\n}\n\n/*\n    BSDF Stuff\n*/\nfloat P1(float h) {\n    float value = (h >= -1.0 && h <= 1.0) ? 0.5 : 0.0;\n\n    return value;\n}\n\nfloat C1(float h) {\n    float value = min(1.0, max(0.0, 0.5 * (h + 1.0)));\n\n    return value;\n}\n\nfloat InvC1(float U) {\n    float h = max(-1.0, min(1.0, 2.0 * U - 1.0));\n\n    return h;\n}\n\nfloat Alpha_I(in vec3 wi, in vec2 alpha) {\n    float inverseSinTheta2 = 1.0 / (1.0 - square(wi.z));\n    float cosPhi2 = wi.x * wi.x * inverseSinTheta2;\n    float sinPhi2 = wi.y * wi.y * inverseSinTheta2;\n    float alpha_i = sqrt(cosPhi2 * alpha.x * alpha.x + sinPhi2 * alpha.y * alpha.y);\n    return alpha_i;\n}\n\nfloat P22(in vec2 slope, in vec2 alpha) {\n    if (any(equal(alpha, vec2(0.0)))) { return 0.0; }\n\tfloat tmp = 1.0 + square(slope.x)/square(alpha.x) + square(slope.y)/square(alpha.y);\n\tfloat value = 1.0 / (pi * alpha.x * alpha.y) / (tmp * tmp);\n\treturn value;\n}\n\nfloat Smith_Lambda(in vec3 wi, in vec2 alpha) {\n    if(wi.z > 0.9990) {\n        return 0.0;\n    }\n    if(wi.z < -0.9990) {\n        return -1.0;\n    }\n\n    float theta_I = acos(wi.z);\n    float a = 1.0 / tan(theta_I) / Alpha_I(wi, alpha);\n\n    float value = 0.5 * (-1.0 + sign(a) * sqrt(1.0 + 1.0/square(a)));\n    \n    return value;\n}\n\nfloat ProjectedArea(in vec3 wi, in vec2 alpha) {\n    if(wi.z > 0.9990) {\n        return 1.0;\n    }\n    if(wi.z < -0.9990) {\n        return 0.0;\n    }\n\n    float theta_I = acos(wi.z);\n    float sinTheta_I = sin(theta_I);\n\n    float alphaI = Alpha_I(wi, alpha);\n\n    float value = 0.5 * (wi.z + sqrt(square(wi.z) + square(sinTheta_I) * square(alphaI)));\n\n    return value;\n}\n\nvec2 SampleP22_11(in float theta_I, in vec2 U) {\n    vec2 slope;\n\n    if(theta_I < 0.0001) {\n        float r = sqrt(U.x/(1.0-U.x));\n        float phi = tau * U.y;\n        slope = vec2(r * cos(phi), r * sin(phi));\n\n        return slope;\n    }\n\n    float sinTheta_I = sin(theta_I);\n    float cosTheta_I = cos(theta_I);\n    float tanTheta_I = tan(theta_I);\n\n    float slope_I = cosTheta_I/sinTheta_I;\n\n    float projectedArea = 0.5 * (cosTheta_I + 1.0);\n    if(projectedArea < 0.0001 || projectedArea != projectedArea) {\n        return vec2(0.0);\n    }\n\n    float c = 1.0 / projectedArea;\n\n    float A = 2.0 * U.x / cosTheta_I / c - 1.0;\n    float B = tanTheta_I;\n    float tmp = 1.0 / (square(A) - 1.0);\n\n    float D = sqrt(max(0.0, square(B) * square(tmp) - (square(A) - square(B)) * tmp));\n    vec2 slopeX = vec2(B*tmp - D, B*tmp + D);\n    slope.x = (A < 0.0 || slopeX.y > 1.0 / tanTheta_I) ? slopeX.x : slopeX.y;\n\n    float U2;\n    float S;\n\n    if(U.y > 0.5) {\n        S = 1.0;\n        U2 = 2.0 * (U.y - 0.5);\n    } else {\n        S = -1.0;\n        U2 = 2.0  * (0.5 - U.y);\n    }\n    float z = (U2 * (U2 * (U2 * 0.27385 - 0.73369)+0.46341)) / (U2 * (U2 * (U2 * 0.093073+0.309420) - 1.000000) + 0.597999);\n    slope.y = S * z * sqrt(1.0 + square(slope.x));\n\n    return slope;\n}\n\nfloat D(in vec3 wm, in vec2 alpha) {\n    if(wm.z <= 0.0) {\n        return 0.0;\n    }\n    vec2 slope = -vec2(wm.x, wm.y) / wm.z;\n\n    float value = P22(slope, alpha);\n    return value / pow(normalize(wm).z, 4.0);\n}\n\nfloat D_wi(in vec3 wi, in vec3 wm, in vec2 alpha) {\n    if(wm.z <= 0.0) {\n        return 0.0;\n    }\n    float pa = ProjectedArea(wi, alpha);\n    if(pa == 0.0) {\n        return 0.0;\n    }\n    float c = 1.0 / pa;\n\n    float value = c * max(0.0, dot(wi, wm)) * D(wm, alpha);\n    return value;\n}\n\nvec3 SampleD_wi(in vec3 wi, in vec2 U, in vec2 alpha) {\n    vec3 wi_11 = normalize(vec3(alpha.x * wi.x, alpha.y * wi.y, wi.z));\n\n    vec2 slope_11 = SampleP22_11(acos(wi_11.z), U);\n\n    float phi = atan(wi_11.y, wi_11.x);\n    float cosPhi = normalize(wi_11.xy).x;\n    float sinPhi = normalize(wi_11.xy).y;\n    vec2 slope = vec2(cosPhi * slope_11.x - sinPhi * slope_11.y, sinPhi * slope_11.x + cosPhi * slope_11.y);\n    slope *= alpha;\n\n    if(slope.x != slope.x || isinf(slope.x)) {\n        if(wi.z > 0.0) {\n            return vec3(0.0, 0.0, 1.0);\n        } else {\n            return normalize(vec3(wi.x, wi.y, 0.0));\n        }\n    }\n\n    vec3 wm = normalize(vec3(-slope.x, -slope.y, 1.0));\n\n    return wm;\n}\n\nvec3 SampleD(in vec2 U, in vec2 alpha) {\n    vec2 slope = SampleP22_11(0.0, U);\n\n    slope *= alpha;\n\n    if(slope.x != slope.x || isinf(slope.x)) {\n        return vec3(0.0, 0.0, 1.0);\n    }\n\n    vec3 wm = normalize(vec3(-slope.x, -slope.y, 1.0));\n\n    return wm;\n}\n\nfloat G_1(in vec3 wi, in vec2 alpha, in float h0) {\n    if(wi.xy == vec2(0.0)) {\n        return 1.0;\n    }\n    if(wi.z <= 0.0) {\n        return 0.0;\n    }\n\n    float C1_h0 = C1(h0);\n    float lambda = Smith_Lambda(wi, alpha);\n    float value = pow(C1_h0, lambda);\n\n    return value;\n}\n\nfloat G_1(in vec3 wi, in vec2 alpha) {\n    if(wi.xy == vec2(0.0)) {\n        return 1.0;\n    }\n    if(wi.z <= 0.0) {\n        return 0.0;\n    }\n\n    float lambda = Smith_Lambda(wi, alpha);\n    float value = 1.0 / (1.0 + lambda);\n\n    return value;\n}\n\nfloat SampleHeight(in vec3 wr, in vec2 alpha, in float hr, in float U) {\n    if(wr.z > 0.9999) {\n        return 1e35;\n    }\n    if(wr.z < -0.9999) {\n        float value = InvC1(U * C1(hr));\n        return value;\n    }\n    if(abs(wr.z) < 0.0001) {\n        return hr;\n    }\n\n    float G1 = G_1(wr, alpha, hr);\n\n    if(U > 1.0 - G1) {\n        return 1e35;\n    }\n\n    float h = InvC1(\n        C1(hr) / pow(1.0 - U, 1.0 / Smith_Lambda(wr, alpha))\n    );\n\n    return h;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    vec3  src    = texture(iChannel0, rayDir).rgb;\n    float srcLum = dot(src, lumacoeff_rec709);\n    vec3 hdriHACK = src * (1.0 + srcLum * 2.8);\n\n    fragColor = texelFetch(iChannel1, ivec2(KEY_DOWN, 2), 0).x > 0.9 ? vec4(1.0) : vec4(hdriHACK * 0.5, 1.0);\n}","name":"Cube A","description":"","type":"cubemap"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SCATTERING_EVENTS 40\n\nfloat HemisphericalAlbedo(in float n) {\n    /*\n        From: http://www.eugenedeon.com/project/hitchhikers/\n    */\n    float n2 = square(n);\n    float T_1 = (4.0 * (2.0 * n + 1.0)) / (3.0 * square(n + 1.0));\n    float T_2 = ((4.0 * cube(n) * (n2 + 2.0 * n - 1.0)) / (square(n2 + 1.0) * (n2 - 1.0))) - \n               ((2.0 * n2 * (n2 + 1.0) * log(n)) / square(n2 - 1.0)) +\n               ((2.0 * n2 * square(n2 - 1.0) * log((n * (n+1.0)) / (n-1.0))) / cube(n2 + 1.0));\n    return saturate(1.0 - 0.5 * (T_1 + T_2));\n}\n\nfloat HemisphericalFresnelAlbedo(float eta) {\n    if (eta < 1.0) {\n        return 1.0 - eta * eta * (1.0 - HemisphericalAlbedo(1.0 / eta));\n    } else {\n        return HemisphericalAlbedo(eta);\n    }\n}\n\nfloat HemisphericalFresnelAlbedo_Integral(in complexFloat n1, in complexFloat n2) {\n    //This is a slightly more accurate version of the above functions that supports complex index of refraction\n    float albedo = 1.0;\n    uint N = 4u; //This should be fine\n    for(uint i = 0u; i < N; ++i) {\n        //Calculate Hemispherical albedo through brute force integration\n        float nDotV = 1.0 - RandNext2F().x; //This is equivalent to nDotV here.\n        float fresnel = FresnelNonPolarized_R(\n                            nDotV,\n                            n1,\n                            n2\n                        );\n        albedo -= fresnel * (2.0 * nDotV) / float(N);\n    }\n    \n    return albedo;\n}\n\nconst complexFloat n1 = complexFloat(1.00028, 0.0);\nconst complexFloat n2 = complexFloat(1.44000, 0.0);\nconst complexFloat n3 = complexFloat(1.73000, 0.0);\n\nvec3 f0ToIOR(in vec3 f0) {\n\tf0 = sqrt(f0);\n\tf0 *= 0.99999; // Prevents divide by 0\n\tvec3 IOR = (1.0 + f0) / (1.0 - f0);\n\treturn 1.00029 * IOR;\n}\n\nvec3 IORTof0(in vec3 ior, in float n1) {\n\tvec3 sqrtf0 = (ior - n1) / (ior + n1);\n\treturn square(sqrtf0);\n}\n\nvec3 ImprovedSchlick(float cosTheta, vec3 n, float k) {\n    return (square(n - 1.0) + 4.0 * n * pow(1.0 - cosTheta, 5.0) + square(k)) / (square(n + 1.0) + square(k));\n}\n\nvec3 SamplePhaseFunction(in vec3 direction, in vec3 normal, inout vec3 throughput, in vec3 albedo, in complexFloat n1, in complexFloat n2) {\n    if(texelFetch(iChannel1, ivec2(KEY_RIGHT, 2), 0).x > 0.9) {\n        //Schlick metal\n        //This is better for testing clearcoat than a perfect mirror is\n        \n        vec3 f0 = vec3(184, 82, 51) / 255.0;\n        \n        vec3 ior = f0ToIOR(f0);\n        \n        f0 = IORTof0(ior, n1.r);\n\n        ior = f0ToIOR(f0);\n        \n        vec3 fresnel = ImprovedSchlick(dot(normal, direction), ior, n1.i);\n\n        throughput *= fresnel;\n\n        return reflect(-direction, normal);\n    } else {\n        float fresnel_R = FresnelNonPolarized_R(dot(normal, direction), n1, n2);\n        float fresnel_T = FresnelNonPolarized_T(dot(normal, direction), n1, n2);\n\n        float albedoLum = dot(albedo, lumacoeff_rec709);\n        float totalLum = albedoLum * fresnel_T + fresnel_R;\n        float specBounceProbability = fresnel_R / totalLum; //Probability that we do specular or diffuse reflection\n        bool specularBounce = specBounceProbability > RandNextF();\n\n        if(specularBounce) {\n            //Calculate specular reflection\n            throughput /= specBounceProbability;\n\n            throughput *= fresnel_R;\n\n            return reflect(-direction, normal);\n        } else {\n            //Calculate diffuse reflection\n            throughput /= 1.0 - specBounceProbability;\n\n            float energyConservationFactor = 1.0 - HemisphericalFresnelAlbedo(n2.r / n1.r);\n\n            throughput *= fresnel_T;\n\n            throughput /= energyConservationFactor;\n\n            vec3 newDirection = GenerateCosineVector(normal, RandNext2F());\n\n            throughput *= albedo;\n\n            float fresnelL_T = FresnelNonPolarized_T(dot(normal, newDirection), n1, n2);\n\n            throughput *= fresnelL_T;\n\n            return newDirection;\n        }\n    }\n}\n\nvec3 SampleBSDF_Smith(in vec3 incomingDirection, inout vec3 throughput, in vec3 albedo, in vec2 alpha, in complexFloat n1, in complexFloat n2) {\n    int scatteringOrder = 0;\n    float hr = 1.0 + InvC1(0.999);\n    float hrCC = 1.0 + InvC1(0.999);\n\n    vec2 clearCoatRoughness = vec2(0.1, 0.1);\n    while(scatteringOrder <= SCATTERING_EVENTS) {\n        float U = RandNextF();\n\n        vec3 wm = SampleD_wi(-incomingDirection, RandNext2F(), alpha);\n        hr = SampleHeight(incomingDirection, alpha, hr, U);\n\n        if(hr == 1e35) {\n            break;\n        }\n\n        incomingDirection = SamplePhaseFunction(-incomingDirection, wm, throughput, albedo, n1, n2);\n\n        if(hr != hr || incomingDirection.z != incomingDirection.z) {\n            return vec3(0, 0, 1);\n        }\n\n        scatteringOrder++;\n    }\n\n    if(throughput != throughput) {\n        throughput = vec3(0.0);\n    }\n\n    if(scatteringOrder > SCATTERING_EVENTS) {\n        throughput = vec3(0.0);\n    }\n\n    return incomingDirection;\n}\n\nvec3 SampleDielectricPhase(\n        in vec3 direction, \n        inout vec3 throughput,\n        in vec2 alpha, \n        inout bool outside,\n        inout complexFloat n1,\n        inout complexFloat n2\n    ) {\n    vec3 wm = outside ? SampleD_wi(direction, RandNext2F(), alpha) : -SampleD_wi(-direction, RandNext2F(), alpha);\n\n    complexFloat tempN1 = n1;\n    complexFloat tempN2 = n2;\n\n    if(!outside) {\n        n1 = tempN2;\n        n2 = tempN1;\n    }\n\n    float fresnel_R = FresnelNonPolarized_R(dot(wm, direction), n1, n2);\n    float fresnel_T = FresnelNonPolarized_T(dot(wm, direction), n1, n2);\n    float albedoLum = dot(vec3(1.0), lumacoeff_rec709);\n    float totalLum = albedoLum * fresnel_T + fresnel_R;\n    float specBounceProbability = fresnel_R / totalLum;\n\n    bool specularBounce = specBounceProbability > RandNextF();\n\n    if(specularBounce) {\n        //Calculate specular reflection\n\n        throughput /= specBounceProbability;\n\n        throughput *= fresnel_R;\n\n        return reflect(-direction, wm);\n    } else {\n        //Calculate refraction\n\n        outside = !outside; //We are no longer outside the object\n\n        throughput /= 1.0 - specBounceProbability;\n\n        throughput *= fresnel_T;\n        throughput *= vec3(1.0);\n\n        return refract(-direction, wm, n1.r / n2.r);\n    }\n}\n\nvec3 SampleRefractBSDF_Smith(\n        in vec3 incomingDirection, \n        inout vec3 throughput,\n        in vec2 alpha, \n        inout bool outside,\n        in complexFloat n1,\n        in complexFloat n2\n    ) {\n    int scatteringOrder = 0;\n    float hr = 1.0 + InvC1(0.999);\n    \n    outside = incomingDirection.z < 0.0;\n\n    if (!outside) { hr = -hr; }\n\n    while(scatteringOrder <= SCATTERING_EVENTS) {\n        float U = RandNextF();\n        hr = outside ? SampleHeight(incomingDirection, alpha, hr, U) : -SampleHeight(-incomingDirection, alpha, -hr, U);\n\n        if(hr == 1e35 || hr == -1e35) {\n            break;\n        }\n\n        scatteringOrder++;\n\n        incomingDirection = SampleDielectricPhase(-incomingDirection, throughput, alpha, outside, n1, n2);\n\n        if(hr != hr || incomingDirection.z != incomingDirection.z) {\n            return vec3(0, 0, 1);\n        }\n    }\n\n    if(scatteringOrder > SCATTERING_EVENTS) {\n        throughput = vec3(0.0);\n    }\n\n    return incomingDirection;\n}\n\nconst int maxPathSegments = 60;\nconst int mediaCount = 3;\nconst int interfaceCount = mediaCount - 1;\n\nvec3 SampleInterface(\n        in vec3 incomingDirection, \n        inout vec3 throughput, \n        in vec3 albedo, \n        in vec2 alpha[interfaceCount], \n        in int cInterface,\n        in complexFloat n[mediaCount]\n    ) {\n    if(cInterface == interfaceCount - 1) {\n        //Bottom interface\n        return SampleBSDF_Smith(incomingDirection, throughput, albedo, alpha[interfaceCount - 1], n[mediaCount - 2], n[mediaCount - 1]);\n    } else {\n        bool outside = true;\n\n        return SampleRefractBSDF_Smith(incomingDirection, throughput, alpha[cInterface], outside, n[cInterface], n[cInterface + 1]);\n    }\n}\n\nvec3 SampleBSDF_Layered(in vec3 incomingDirection, inout vec3 throughput, in vec3 albedo, in vec2 alpha) {\n    int currentInterface = (incomingDirection.z < 0.0) ? 0 : interfaceCount - 1;\n    \n    vec3 newDirection = incomingDirection;\n    vec3 t[mediaCount] = vec3[mediaCount](\n        vec3(1.0),\n        vec3(0.1, 0.6, 0.9) * 4.0,\n        vec3(1.0)\n    );\n    complexFloat n[mediaCount] = complexFloat[mediaCount](\n        complexFloat(1.00028, 0.0),\n        complexFloat(1.45000, 0.0),\n        complexFloat(1.41000, 0.0)\n    );\n    vec2 alphaI[interfaceCount] = vec2[interfaceCount](\n        vec2(0.0),\n        alpha\n    );\n    int iteration = 0;\n    do {\n        iteration++;\n        if(iteration > maxPathSegments) break; //Prevent an infinite loop\n\n        newDirection = SampleInterface(\n            newDirection, \n            throughput, \n            albedo, \n            alphaI,\n            currentInterface,\n            n\n        );\n\n        if (newDirection.z > 0.0) {\n            if(currentInterface != 0) {\n                vec3 transmittance = pow(saturate(t[currentInterface]), vec3(1.0 / abs(newDirection.z)));\n                if(texelFetch(iChannel1, ivec2(KEY_D, 2), 0).x > 0.9) {\n                    transmittance = vec3(1.0);\n                }\n                throughput *= transmittance;\n            }\n            --currentInterface;\n        } else if (newDirection.z < 0.0) {\n            if(currentInterface != interfaceCount - 1) {\n                vec3 transmittance = pow(saturate(t[currentInterface + 1]), vec3(1.0 / abs(newDirection.z)));\n                if(texelFetch(iChannel1, ivec2(KEY_D, 2), 0).x > 0.9) {\n                    transmittance = vec3(1.0);\n                }\n                throughput *= transmittance;\n            }\n\n            ++currentInterface;\n        } else {\n            // should never be reached\n            // could extract the sign bit instead to avoid this\n            break;\n        }\n    } while (currentInterface >= 0 && currentInterface < interfaceCount);\n    \n    return newDirection;\n}\n\nvoid DoEnvironmentShading(in vec3 rayDirection, in vec3 sphereOrigin, in float roughness, inout vec3 result, inout bool hit, in vec2 coord) {\n    float hitDist;\n\n    vec3 albedo = SrgbToLinear(texelFetch(iChannel1, ivec2(KEY_LEFT, 2), 0).x > 0.9 ? vec3(1.0) : vec3(1.0, 0.7, 0.5));\n    if(IntersectSphere(sphereOrigin, rayDirection, 0.3, hitDist)) {\n        hit = true;\n        vec3 normals = normalize(sphereOrigin + rayDirection * hitDist);\n        mat3 tbnMatrix = GetRotationMatrix(vec3(0.0, 0.0, 1.0), normals);\n\n        mat3 tbnMatrix2 = GetRotationMatrix(tbnMatrix[2], normals) * tbnMatrix;\n        vec3 viewDirection   = rayDirection * tbnMatrix2;\n             viewDirection.z = sign(dot(rayDirection, tbnMatrix[2])) * abs(viewDirection.z);\n\n        vec3 throughput = vec3(1.0);\n        bool outside = true;\n        rayDirection = tbnMatrix2 * SampleBSDF_Layered(viewDirection, throughput, albedo, vec2(roughness));\n\n        result = SrgbToLinear(texture(iChannel2, rayDirection).rgb) * throughput;\n    } else if(!hit) {\n        result = SrgbToLinear(texture(iChannel2, rayDirection).rgb);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitRand(uint(fragCoord.x) + uint(iResolution.x) * (uint(fragCoord.y) + uint(iResolution.y) * uint(iFrame)));\n\n    vec2 textureCoordinate = gl_FragCoord.st * rcp(iResolution.xy);\n    \n    vec2 uv  = (gl_FragCoord.st * rcp(iResolution.xy)) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 aa = (RandNext2F() - 0.5) * rcp(iResolution.xy);\n\n    vec3 rayDirection = normalize(vec3((vec2(uv.x, uv.y) + aa) * tan(radians(6.0)), 1.0));\n    \n    vec3 sphereOrigin = vec3(0.0, 0.0, -10.0);\n    vec3 color = vec3(0.0);\n\n    bool hit = false;\n\n    DoEnvironmentShading(rayDirection, sphereOrigin + vec3(1.0, 0.0, 0.0), 0.0, color, hit, textureCoordinate);\n    DoEnvironmentShading(rayDirection,                       sphereOrigin, 0.5, color, hit, textureCoordinate);\n    DoEnvironmentShading(rayDirection, sphereOrigin - vec3(1.0, 0.0, 0.0), 1.0, color, hit, textureCoordinate);\n    \n    color = max(color, 0.0);\n    \n    float frames = texture(iChannel0, gl_FragCoord.st * rcp(iResolution.xy)).a;\n    vec3 previousColor = texture(iChannel0, gl_FragCoord.st * rcp(iResolution.xy)).rgb;\n\n    bool KeyM = texelFetch(iChannel1, ivec2(KEY_M, 1), 0).x > 0.9;\n    bool KeyD = texelFetch(iChannel1, ivec2(KEY_D, 1), 0).x > 0.9;\n    bool KeyUp = texelFetch(iChannel1, ivec2(KEY_UP, 1), 0).x > 0.9;\n    bool KeyDown = texelFetch(iChannel1, ivec2(KEY_DOWN, 1), 0).x > 0.9;\n    bool KeyLeft = texelFetch(iChannel1, ivec2(KEY_LEFT, 1), 0).x > 0.9;\n    bool KeyRight = texelFetch(iChannel1, ivec2(KEY_RIGHT, 1), 0).x > 0.9;\n\n    if(KeyM || KeyD || KeyUp || KeyDown || KeyLeft || KeyRight) {\n        frames = 1.0;\n        previousColor = vec3(0.0);\n    }\n    \n    color = mix(previousColor, color, 1.0 / (frames += 1.0));\n    \n    fragColor = vec4(color, frames);\n}","name":"Buffer A","description":"","type":"buffer"}]}