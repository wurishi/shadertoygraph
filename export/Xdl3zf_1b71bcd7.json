{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/* \n * I used https://iquilezles.org/articles/distfunctions for finding geometry functions.\n * I also used https://www.shadertoy.com/view/4ssGzS for inspiration.\n * Made by Emil SandstÃ¸\n */\n\n#define MAX_RAYMARCH_ITER 128\n#define PI 3.14159265359\n#define MAX_SPHERE_FLAKE_ITER 4\n\n#define SPHEREFLAKE 1.0\n\nconst float precis = 0.001;\n\n//Find the shortest distance from a point to a point in the sphere.\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\n\nvec3 rotateX(in vec3 p, float a) {\n\tfloat c = cos(a); float s = sin(a);\n\treturn vec3(p.x, c * p.y - s * p.z, s * p.y + c * p.z);\n}\n\nvec3 rotateY(vec3 p, float a) {\n\tfloat c = cos(a); float s = sin(a);\n\treturn vec3(c * p.x + s * p.z, p.y, -s * p.x + c * p.z);\n}\n\nvec3 rotateZ(vec3 p, float a) {\n\tfloat c = cos(a); float s = sin(a);\n\treturn vec3(c * p.x - s * p.y, s * p.x + c * p.y, p.z);\n}\n\n// Setup a rotation matrix from an arbitrary axis.\n// Axis must be a unit vector.\nmat3 setupRotate(vec3 axis, float theta)\n{\n\tfloat s = sin(theta);\n\tfloat c = cos(theta);\n\n\tfloat a = 1.0 - c;\n\tfloat ax = a * axis.x;\n\tfloat ay = a * axis.y;\n\tfloat az = a * axis.z;\n\n\treturn mat3(ax*axis.x + c, ax*axis.y + axis.z*s, ax*axis.z - axis.y*s,\n\t\t\t\tay*axis.x - axis.z*s, ay*axis.y + c, ay*axis.z + axis.x*s,\n\t\t\t\taz*axis.x + axis.y*s, az*axis.y - axis.x*s, az*axis.z + c);\n}\n\nvec3 rotateCamera(vec3 ray_start, vec3 ray_dir, vec3 cameraTarget) \n{\n\tray_dir.x = ray_dir.x;\n\tvec3 target = normalize(cameraTarget - ray_start);\n\tfloat angY = atan(target.z, target.x);\n\tray_dir = rotateY(ray_dir, PI/2.0 - angY);\n\tfloat angX = atan(target.y, target.z);\n\tray_dir = rotateX(ray_dir, -angX);\n\treturn ray_dir;\n}\n\nvec2 mapSphereFlake(vec3 p, out vec3 finalP)\n{\n\tmat3 rotMat = setupRotate(vec3(0.0, 1.0, 0.0), iTime * 0.5);\n\tp = rotMat * p;\n\t\n\tfloat currentRadius = 45.0;\n\tvec2 result = vec2(SPHEREFLAKE, sdSphere(p, currentRadius));\n\tfinalP = p;\n\t\n\tfloat finalRadius = currentRadius;\n\tfor(int i = 0;i < MAX_SPHERE_FLAKE_ITER;i++)\n\t{\n\t\tcurrentRadius /= 3.0;\n\t\t\n\t\t//It was faster to unroll the loop on my AMD Radeon HD 7970.\n\t\t//But I still gets around 20 FPS.\n\t\tvec3 pos;\n\t\tpos = vec3(finalRadius, 0.0, 0.0);\n\t\tpos += p;\n\t\t\t\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(currentRadius, 0.0, 0.0), currentRadius));\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(-currentRadius, 0.0, 0.0), currentRadius));\n\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(0.0, currentRadius, 0.0), currentRadius));\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(0.0, -currentRadius, 0.0), currentRadius));\n\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(0.0, 0.0, currentRadius), currentRadius));\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(0.0, 0.0, -currentRadius), currentRadius));\n\n\t\tpos = vec3(-finalRadius, 0.0, 0.0);\n\t\tpos += p;\n\t\t\t\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(currentRadius, 0.0, 0.0), currentRadius));\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(-currentRadius, 0.0, 0.0), currentRadius));\n\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(0.0, currentRadius, 0.0), currentRadius));\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(0.0, -currentRadius, 0.0), currentRadius));\n\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(0.0, 0.0, currentRadius), currentRadius));\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(0.0, 0.0, -currentRadius), currentRadius));\n\n\t\tpos = vec3(0.0, finalRadius, 0.0);\n\t\tpos += p;\n\t\t\t\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(currentRadius, 0.0, 0.0), currentRadius));\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(-currentRadius, 0.0, 0.0), currentRadius));\n\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(0.0, currentRadius, 0.0), currentRadius));\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(0.0, -currentRadius, 0.0), currentRadius));\n\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(0.0, 0.0, currentRadius), currentRadius));\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(0.0, 0.0, -currentRadius), currentRadius));\n\n\t\tpos = vec3(0.0, -finalRadius, 0.0);\n\t\tpos += p;\n\t\t\t\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(currentRadius, 0.0, 0.0), currentRadius));\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(-currentRadius, 0.0, 0.0), currentRadius));\n\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(0.0, currentRadius, 0.0), currentRadius));\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(0.0, -currentRadius, 0.0), currentRadius));\n\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(0.0, 0.0, currentRadius), currentRadius));\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(0.0, 0.0, -currentRadius), currentRadius));\n\n\t\tpos = vec3(0.0, 0.0, finalRadius);\n\t\tpos += p;\n\t\t\t\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(currentRadius, 0.0, 0.0), currentRadius));\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(-currentRadius, 0.0, 0.0), currentRadius));\n\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(0.0, currentRadius, 0.0), currentRadius));\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(0.0, -currentRadius, 0.0), currentRadius));\n\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(0.0, 0.0, currentRadius), currentRadius));\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(0.0, 0.0, -currentRadius), currentRadius));\n\n\t\tpos = vec3(0.0, 0.0, -finalRadius);\n\t\tpos += p;\n\t\t\t\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(currentRadius, 0.0, 0.0), currentRadius));\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(-currentRadius, 0.0, 0.0), currentRadius));\n\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(0.0, currentRadius, 0.0), currentRadius));\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(0.0, -currentRadius, 0.0), currentRadius));\n\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(0.0, 0.0, currentRadius), currentRadius));\n\t\tresult.y = min(result.y, sdSphere(pos + vec3(0.0, 0.0, -currentRadius), currentRadius));\n\t\t\n\t\tfinalRadius += currentRadius * 2.0;\n\t}\n\n\tresult.y += sin(2.0 * p.x) * sin(2.0 * p.y) * sin(2.0 * p.z);\n\t\n\treturn result;\n}\n\n// Find the intersection points between the rays and objects in our scene, so that we can shade them.\n// The x coordinate of the returned vector corresponds to the object type.\nvec2 mapScene(vec3 p, out vec3 finalP)\n{\n\treturn mapSphereFlake(p, finalP);\n}\n\n// Returns the type of object hit.\nfloat rayMarch(vec3 rayStart, vec3 rayDir, out float dist, out vec3 currentRayPos, out vec3 finalRayPos, out int iterations)\n{\n\tdist = 0.0;\n\tvec2 mapDist;\n\n\tfor(int i = 0;i < MAX_RAYMARCH_ITER;i++)\n\t{\n\t\tcurrentRayPos = rayStart + rayDir * dist;\n\t\tmapDist = mapScene(currentRayPos, finalRayPos);\n\t\tif(mapDist.y < precis)\n\t\t{\n\t\t\titerations = i;\n\t\t\treturn mapDist.x;\n\t\t}\n\t\tdist += mapDist.y;\n\t}\n\n\treturn -1.;\n}\n\nvec3 moveCamera(vec3 ray_start) \n{\n\tray_start += vec3(0.0, 0.0, -400.);\n\treturn ray_start;\n}\n\nvec4 render(vec3 screen)\n{\t\n\tvec4 outColor = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 diffColor = vec4(1.0, 1.0, 1.0, 1.0);\n\tvec3 rayOrigin = vec3(0.0, 0.0, -2.0);\n\tvec3 rayStart = moveCamera(rayOrigin);\n\n\tvec3 cameraTarget = vec3(0.0, 0.0, -1.0); \n\tvec3 rayDir = rotateCamera(rayOrigin, normalize(screen - rayOrigin), cameraTarget);\n\t\n\tfloat dist;\n\tvec3 rayPos;\n\tvec3 finalRayPos;\n\tint iterations;\n\tfloat objectID = rayMarch(rayStart, rayDir, dist, rayPos, finalRayPos, iterations);\n\n\tif(objectID > 0.0)\n\t{\n\t\toutColor = vec4(0.0, float(iterations) / 32.0, abs(rayPos.x) / 80.0 + abs(rayPos.y) / 120.0 - 0.4, 1.0);\n\t}\n\t\n\treturn outColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2((fragCoord.x - iResolution.x *.5) / iResolution.y, (fragCoord.y - iResolution.y *.5) / iResolution.y);\n\tfragColor = render(vec3(uv, 0.0));\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xdl3zf","date":"1376007776","viewed":478,"name":"SphereIntense","username":"Tapped","description":"I tried to implement sphere flake, but ended up with this, which i found pretty cool.\nThis \"fractal\" is very GPU intensive, because of the amount of square roots. You can try to lower the iterations.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["spherefractal"],"hasliked":0,"parentid":"","parentname":""}}