{"ver":"0.1","info":{"id":"XffGWM","date":"1703103644","viewed":44,"name":"gradient sphere 53","username":"vssense","description":"gradient sphere with generated buffer","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float R = 0.7;\nconst float frequency = 10.0;\nconst float eps = 0.001;\n\nfloat sdf(vec3 pos, float time)\n{\n    vec2 polar = vec2(\n        atan(pos.z, pos.x),\n        atan(pos.x * pos.x + pos.z * pos.z, -pos.y)\n    );\n    \n    return length(pos) - R - sin(polar.x * frequency + polar.y * frequency + time) * 0.04;\n}\n\nvec3 GetTriplanarWeights(vec3 n, vec3 power)\n{\n    vec3 w = abs(n);\n    w = pow(w, power);\n\n    return w / (w.x + w.y + w.z);\n}\n\nvec3 CalcNormal(vec3 pos)\n{\n    float dx1 = sdf(pos + vec3(eps, 0, 0), iTime);\n    float dx2 = sdf(pos - vec3(eps, 0, 0), iTime);\n    float dy1 = sdf(pos + vec3(0, eps, 0), iTime);\n    float dy2 = sdf(pos - vec3(0, eps, 0), iTime);\n    float dz1 = sdf(pos + vec3(0, 0, eps), iTime);\n    float dz2 = sdf(pos - vec3(0, 0, eps), iTime);\n    \n    return normalize(vec3(dx1 - dx2, dy1 - dy2, dz1 - dz2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    const float MIN_DIST = 0.01;\n    const float MAX_DIST = 110.0;\n    const int MAX_ITER = 32;\n    \n    vec2 uv = fragCoord.xy / iResolution.yy * 2.0;\n    vec3 start_pos = vec3(uv.x-1.0, uv.y-1.0, 0.0);\n    vec3 camera = vec3(0.0, 0.0,-100.0);\n    vec3 direction = normalize(start_pos - camera);\n\n    vec3 pos = start_pos + vec3(-R, 0.0, -1);\n    \n    float d = 0.0;\n    \n    for(int i = 0; i < MAX_ITER; i++) {\n        d = sdf(pos, iTime);\n        pos += direction * d;\n        \n        if (d < MIN_DIST || d > MAX_DIST) break;\n    }\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    if (d <= MIN_DIST) {\n        vec3 normal = CalcNormal(pos);\n        vec3 tws = GetTriplanarWeights(normal, vec3(2.0));\n        \n        vec3 cx = texture(iChannel1, pos.yz*.5+.5).rgb;\n        vec3 cy = texture(iChannel1, pos.zx*.5+.5).rgb;\n        vec3 cz = texture(iChannel1, pos.xy*.5+.5).rgb;\n        vec3 tdiff = tws.x * cx + tws.y + cy + tws.z * cz;\n\n        color = tdiff;\n    } else {\n        color = texture(iChannel0, uv).xyz;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = normalize(vec4(cos(iTime) * cos(fragCoord.x * fragCoord.x / 100000.0),\n                               cos(iTime) * sin(fragCoord.y * fragCoord.y / 100000.0),\n                               cos(iTime) * cos(fragCoord.x * fragCoord.y / 100000.0), 1.0));\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}