{"ver":"0.1","info":{"id":"7ssGDj","date":"1616598710","viewed":189,"name":"Fork Cube lines doomedclou 672 W","username":"doomedcloud","description":"Layers sorted and support transparency and self-intersection-transparency (include reflections)\nAntialiasing is only dFd. (with some dFd fixes around edges)\n\ncineshader support [url]https://cineshader.com/view/NslGRN[/url]","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","intersection","art","cineshader"],"hasliked":0,"parentid":"NslGRN","parentname":"Cube lines"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Danil (2021+) https://twitter.com/AruGL\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// self https://www.shadertoy.com/view/NslGRN\n\n// using iq's intersectors: https://iquilezles.org/articles/intersectors\n// using https://www.shadertoy.com/view/ltKBzG\n// using https://www.shadertoy.com/view/tsVXzh\n// using https://www.shadertoy.com/view/WlffDn\n// using https://www.shadertoy.com/view/WslGz4\n\n// uncomment for Animation 1\n//#define ANIM\n\n#define tshift 53.\n\n#define curvature 0.5\n// uncomment for Animation 2\n//#define curvature (0.001+1.5-1.5*smoothstep(0.,8.5,mod((iTime+tshift)*0.44,20.))*(1.-smoothstep(10.,18.5,mod((iTime+tshift)*0.44,20.))))\n\n// uncommenting curvature(to not const above) make compilation on Angle 15+ sec\n\n// reflect back side\n//#define backside_refl\n\n// Camera with mouse\n//#define MOUSE_control\n\n// min(iFrame,0) does not speedup compilation in ANGLE\n#define ANGLE_loops 0\n\n\n// this shader discover Nvidia bug with arrays https://www.shadertoy.com/view/NslGR4\n// use DEBUG with BUG, BUG trigger that bug and one layer will be white on Nvidia in OpenGL\n//#define DEBUG\n//#define BUG\n\n#define FDIST 0.3\n#define PI 3.1415926\n#define GROUNDSPACING 0.5\n#define GROUNDGRID 0.5\n#define BOXDIMS vec3(0.75, 0.75, 1.25)\n\n#define IOR 1.33\n\nmat3 rotx(float a){float s = sin(a);float c = cos(a);return mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, c, s), vec3(0.0, -s, c));  }\nmat3 roty(float a){float s = sin(a);float c = cos(a);return mat3(vec3(c, 0.0, s), vec3(0.0, 1.0, 0.0), vec3(-s, 0.0, c));}\nmat3 rotz(float a){float s = sin(a);float c = cos(a);return mat3(vec3(c, s, 0.0), vec3(-s, c, 0.0), vec3(0.0, 0.0, 1.0 ));}\n\nvec3 fcos(vec3 x) {\n    vec3 w = fwidth(x);\n    return cos(x) * smoothstep(3.14 * 2.0, 0.0, w);\n}\n\n// rename to fcos\nvec3 fcos2( vec3 x){return cos(x);}\n\nvec3 getColor(vec3 p)\n{\n    // dFd fix, dFd broken on borders, but it fix only top level dFd, self intersection has border\n    if (length(p) > 0.99)return vec3(0.);\n    p = abs(p);\n\n    p *= 01.25;\n    p = 0.5 * p / dot(p, p);\n#ifdef ANIM\n    p+=0.2*iTime;\n#endif\n\n    float t = (0.13) * length(p);\n    vec3 col = vec3(0.3, 0.4, 0.5);\n    col += 0.12 * fcos(6.28318 * t * 1.0 + vec3(0.0, 0.8, 1.1));\n    col += 0.11 * fcos(6.28318 * t * 3.1 + vec3(0.3, 0.4, 0.1));\n    col += 0.10 * fcos(6.28318 * t * 5.1 + vec3(0.1, 0.7, 1.1));\n    col += 0.10 * fcos(6.28318 * t * 17.1 + vec3(0.2, 0.6, 0.7));\n    col += 0.10 * fcos(6.28318 * t * 31.1 + vec3(0.1, 0.6, 0.7));\n    col += 0.10 * fcos(6.28318 * t * 65.1 + vec3(0.0, 0.5, 0.8));\n    col += 0.10 * fcos(6.28318 * t * 115.1 + vec3(0.1, 0.4, 0.7));\n    col += 0.10 * fcos(6.28318 * t * 265.1 + vec3(1.1, 1.4, 2.7));\n    col = clamp(col, 0., 1.);\n \n    return col;\n}\n\nvoid calcColor(vec3 ro, vec3 rd, vec3 nor, float d, float len, int idx, bool si, float td, out vec4 colx,\n               out vec4 colsi)\n{\n\n    vec3 pos = (ro + rd * d);\n#ifdef DEBUG\n    float a = 1. - smoothstep(len - 0.15, len + 0.00001, length(pos));\n    if (idx == 0)colx = vec4(1., 0., 0., a);\n    if (idx == 1)colx = vec4(0., 1., 0., a);\n    if (idx == 2)colx = vec4(0., 0., 1., a);\n    if (si)\n    {\n        pos = (ro + rd * td);\n        float ta = 1. - smoothstep(len - 0.15, len + 0.00001, length(pos));\n        if (idx == 0)colsi = vec4(1., 0., 0., ta);\n        if (idx == 1)colsi = vec4(0., 1., 0., ta);\n        if (idx == 2)colsi = vec4(0., 0., 1., ta);\n    }\n#else\n    float a = 1. - smoothstep(len - 0.15*0.5, len + 0.00001, length(pos));\n    //a=1.;\n    vec3 col = getColor(pos);\n    colx = vec4(col, a);\n    if (si)\n    {\n        pos = (ro + rd * td);\n        float ta = 1. - smoothstep(len - 0.15*0.5, len + 0.00001, length(pos));\n        //ta=1.;\n        col = getColor(pos);\n        colsi = vec4(col, ta);\n    }\n#endif\n}\n\n// xSI is self intersect data, fade to fix dFd on edges\nbool iBilinearPatch(in vec3 ro, in vec3 rd, in vec4 ps, in vec4 ph, in float sz, out float t, out vec3 norm,\n                    out bool si, out float tsi, out vec3 normsi, out float fade, out float fadesi)\n{\n    vec3 va = vec3(0.0, 0.0, ph.x + ph.w - ph.y - ph.z);\n    vec3 vb = vec3(0.0, ps.w - ps.y, ph.z - ph.x);\n    vec3 vc = vec3(ps.z - ps.x, 0.0, ph.y - ph.x);\n    vec3 vd = vec3(ps.xy, ph.x);\n    t = -1.;\n    tsi = -1.;\n    si = false;\n\n    float tmp = 1.0 / (vb.y * vc.x);\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = va.z * tmp;\n    float e = 0.0;\n    float f = 0.0;\n    float g = (vc.z * vb.y - vd.y * va.z) * tmp;\n    float h = (vb.z * vc.x - va.z * vd.x) * tmp;\n    float i = -1.0;\n    float j = (vd.x * vd.y * va.z + vd.z * vb.y * vc.x) * tmp - (vd.y * vb.z * vc.x + vd.x * vc.z * vb.y) * tmp;\n\n    float p = dot(vec3(a, b, c), rd.xzy * rd.xzy) + dot(vec3(d, e, f), rd.xzy * rd.zyx);\n    float q = dot(vec3(2.0, 2.0, 2.0) * ro.xzy * rd.xyz, vec3(a, b, c)) + dot(ro.xzz * rd.zxy, vec3(d, d, e)) +\n              dot(ro.yyx * rd.zxy, vec3(e, f, f)) + dot(vec3(g, h, i), rd.xzy);\n    float r =\n        dot(vec3(a, b, c), ro.xzy * ro.xzy) + dot(vec3(d, e, f), ro.xzy * ro.zyx) + dot(vec3(g, h, i), ro.xzy) + j;\n\n    if (abs(p) < 0.000001)\n    {\n        float tt = -r / q;\n        if (tt <= 0.)\n            return false;\n        t = tt;\n        // normal\n\n        vec3 pos = ro + t * rd;\n        vec3 grad =\n            vec3(2.0) * pos.xzy * vec3(a, b, c) + pos.zxz * vec3(d, d, e) + pos.yyx * vec3(f, e, f) + vec3(g, h, i);\n        norm = -normalize(grad);\n        return true;\n    }\n    else\n    {\n        float sq = q * q - 4.0 * p * r;\n        if (sq < 0.0)\n        {\n            return false;\n        }\n        else\n        {\n            float s = sqrt(sq);\n            float t0 = (-q + s) / (2.0 * p);\n            float t1 = (-q - s) / (2.0 * p);\n            float tt1 = min(t0 < 0.0 ? t1 : t0, t1 < 0.0 ? t0 : t1);\n            float tt2 = max(t0 > 0.0 ? t1 : t0, t1 > 0.0 ? t0 : t1);\n            float tt0 = tt1;\n            if (tt0 <= 0.)\n                return false;\n            vec3 pos = ro + tt0 * rd;\n            // black border on end of circle and self intersection with alpha come because dFd\n            // uncomment this to see or rename fcos2 to fcos\n            //sz+=0.3; \n            bool ru = step(sz, length(pos)) > 0.5;\n            if (ru)\n            {\n                tt0 = tt2;\n                pos = ro + tt0 * rd;\n            }\n            if (tt0 <= 0.)\n                return false;\n            bool ru2 = step(sz, length(pos)) > 0.5;\n            if (ru2)\n                return false;\n\n            // self intersect\n            if ((tt2 > 0.) && ((!ru)) && !(step(sz, length(ro + tt2 * rd)) > 0.5))\n            {\n                si = true;\n                fadesi=s;\n                tsi = tt2;\n                vec3 tpos = ro + tsi * rd;\n                // normal\n                vec3 tgrad = vec3(2.0) * tpos.xzy * vec3(a, b, c) + tpos.zxz * vec3(d, d, e) +\n                             tpos.yyx * vec3(f, e, f) + vec3(g, h, i);\n                normsi = -normalize(tgrad);\n            }\n            \n            fade=s;\n            t = tt0;\n            // normal\n            vec3 grad =\n                vec3(2.0) * pos.xzy * vec3(a, b, c) + pos.zxz * vec3(d, d, e) + pos.yyx * vec3(f, e, f) + vec3(g, h, i);\n            norm = -normalize(grad);\n\n            return true;\n        }\n    }\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat segShadow( in vec3 ro, in vec3 rd, in vec3 pa, float sh )\n{\n    float dm = dot(rd.yz,rd.yz);\n    float k1 = (ro.x-pa.x)*dm;\n    float k2 = (ro.x+pa.x)*dm;\n    vec2  k5 = (ro.yz+pa.yz)*dm;\n    float k3 = dot(ro.yz+pa.yz,rd.yz);\n    vec2  k4 = (pa.yz+pa.yz)*rd.yz;\n    vec2  k6 = (pa.yz+pa.yz)*dm;\n    \n    for( int i=0; i<4 + ANGLE_loops; i++ )\n    {\n        vec2  s = vec2(i&1,i>>1);\n        float t = dot(s,k4) - k3;\n        \n        if( t>0.0 )\n        sh = min(sh,dot2(vec3(clamp(-rd.x*t,k1,k2),k5-k6*s)+rd*t)/(t*t));\n    }\n    return sh;\n}\n\nfloat boxSoftShadow( in vec3 ro, in vec3 rd, in vec3 rad, in float sk ) \n{\n\tvec3 rdd = rd;\n\tvec3 roo = ro;\n\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN<tF && tF>0.0) return 0.0;\n    \n    float sh = 1.0;\n    sh = segShadow( roo.xyz, rdd.xyz, rad.xyz, sh );\n    sh = segShadow( roo.yzx, rdd.yzx, rad.yzx, sh );\n    sh = segShadow( roo.zxy, rdd.zxy, rad.zxy, sh );\n    sh = clamp(sk*sqrt(sh),0.0,1.0);\n    return sh*sh*(3.0-2.0*sh);\n}\n\nfloat box(in vec3 ro, in vec3 rd, in vec3 r, out vec3 nn, bool entering)\n{\n    vec3 dr = 1.0 / rd;\n    vec3 n = ro * dr;\n    vec3 k = r * abs(dr);\n\n    vec3 pin = -k - n;\n    vec3 pout = k - n;\n    float tin = max(pin.x, max(pin.y, pin.z));\n    float tout = min(pout.x, min(pout.y, pout.z));\n    if (tin > tout)\n        return -1.;\n    if (entering)\n    {\n        nn = -sign(rd) * step(pin.zxy, pin.xyz) * step(pin.yzx, pin.xyz);\n    }\n    else\n    {\n        nn = sign(rd) * step(pout.xyz, pout.zxy) * step(pout.xyz, pout.yzx);\n    }\n    return entering ? tin : tout;\n}\n\nvec3 bgcol(in vec3 rd)\n{\n    return mix(vec3(0.01), vec3(0.595, 0.53, .7976), 1. - pow(abs(rd.z+0.25), 1.3));\n}\n\nvec3 background(in vec3 ro, in vec3 rd , vec3 l_dir)\n{\n    float t = (-BOXDIMS.z - ro.z) / rd.z;\n    vec3 bgc = bgcol(rd);\n    if (t < 0.)\n        return bgc;\n    vec2 uv = ro.xy + t * rd.xy;\n    float shad = boxSoftShadow((ro + t * rd), normalize(l_dir+vec3(0.,0.,1.))*rotz(PI*0.65) , BOXDIMS, 1.5);\n    float aofac = smoothstep(-0.95, .75, length(abs(uv) - min(abs(uv), vec2(0.45))));\n    aofac = min(aofac,smoothstep(-0.65, 1., shad));\n    float lght=max(dot(normalize(ro + t * rd+vec3(0.,-0.,-5.)), normalize(l_dir-vec3(0.,0.,1.))*rotz(PI*0.65)), 0.0);\n    vec3 col = mix(vec3(0.4), vec3(0.7535, 0.7346, .9342), lght*lght* aofac+ 0.05) * aofac;\n    return mix(col*length(col)*0.8,bgc,smoothstep(7.,10.,length(uv)));\n}\n\n#define swap(a,b) tv=a;a=b;b=tv\n\nvec4 insides(vec3 ro, vec3 rd, vec3 nor_c, vec3 l_dir, out float tout)\n{\n    tout = -1.;\n    vec3 trd=rd;\n\n    vec3 col = vec3(0.);\n\n    float pi = 3.1415926;\n\n    if (abs(nor_c.x) > 0.5)\n    {\n        rd = rd.xzy * nor_c.x;\n        ro = ro.xzy * nor_c.x;\n    }\n    else if (abs(nor_c.z) > 0.5)\n    {\n        l_dir *= roty(pi);\n        rd = rd.yxz * nor_c.z;\n        ro = ro.yxz * nor_c.z;\n    }\n    else if (abs(nor_c.y) > 0.5)\n    {\n        l_dir *= rotz(-pi * 0.5);\n        rd = rd * nor_c.y;\n        ro = ro * nor_c.y;\n    }\n\n\n    float bil_size = 1.;\n    vec4 ps = vec4(-bil_size, -bil_size, bil_size, bil_size) * curvature;\n    vec4 ph = vec4(-bil_size, bil_size, bil_size, -bil_size) * curvature;\n    \n    vec4 [3]colx=vec4[3](vec4(0.),vec4(0.),vec4(0.));\n    vec3 [3]dx=vec3[3](vec3(-1.),vec3(-1.),vec3(-1.));\n    vec4 [3]colxsi=vec4[3](vec4(0.),vec4(0.),vec4(0.));\n    int [3]order=int[3](0,1,2);\n\n    for (int i = 0; i < 3 + ANGLE_loops; i++)\n    {\n        if (abs(nor_c.x) > 0.5)\n        {\n            ro *= rotz(-pi * (1. / float(3)));\n            rd *= rotz(-pi * (1. / float(3)));\n        }\n        else if (abs(nor_c.z) > 0.5)\n        {\n            ro *= rotz(pi * (1. / float(3)));\n            rd *= rotz(pi * (1. / float(3)));\n        }\n        else if (abs(nor_c.y) > 0.5)\n        {\n            ro *= rotx(pi * (1. / float(3)));\n            rd *= rotx(pi * (1. / float(3)));\n        }\n        vec3 normnew;\n        float tnew;\n        bool si;\n        float tsi;\n        vec3 normsi;\n        float fade;\n        float fadesi;\n\n        if (iBilinearPatch(ro, rd, ps, ph, bil_size, tnew, normnew, si, tsi, normsi, fade, fadesi))\n        {\n            if (tnew > 0.)\n            {\n                vec4 tcol, tcolsi;\n                calcColor(ro, rd, normnew, tnew, bil_size, i, si, tsi, tcol, tcolsi);\n                if (tcol.a > 0.0)\n                {\n                    {\n                        vec3 tvalx = vec3(tnew, float(si), tsi);\n                        dx[i]=tvalx;\n                    }\n#ifdef DEBUG\n                    colx[i]=tcol;\n                    if (si)colxsi[i]=tcolsi;\n#else\n\n                    float dif = clamp(dot(normnew, l_dir), 0.0, 1.0);\n                    float amb = clamp(0.5 + 0.5 * dot(normnew, l_dir), 0.0, 1.0);\n\n                    {\n                        vec3 shad = vec3(0.32, 0.43, 0.54) * amb + vec3(1.0, 0.9, 0.7) * dif;\n                        float ta = clamp(length(tcol.rgb),0.,1.);\n                        tcol=clamp(tcol*tcol*2.,0.,1.);\n                        vec4 tvalx =\n                            vec4((tcol.rgb*shad*1.4 + 3.*(vec3(1.,0.21,0.11)*tcol.rgb)*clamp(1.-(amb+dif),0.,1.)), min(tcol.a,ta));\n                        tvalx.rgb=clamp(2.*tvalx.rgb*tvalx.rgb,0.,1.);\n                        tvalx*=(min(fade*5.,1.));\n                        colx[i]=tvalx;\n                    }\n                    if (si)\n                    {\n                        dif = clamp(dot(normsi, l_dir), 0.0, 1.0);\n                        amb = clamp(0.5 + 0.5 * dot(normsi, l_dir), 0.0, 1.0);\n                        {\n                            vec3 shad = vec3(0.32, 0.43, 0.54) * amb + vec3(1.0, 0.9, 0.7) * dif;\n                            float ta = clamp(length(tcolsi.rgb),0.,1.);\n                            tcolsi=clamp(tcolsi*tcolsi*2.,0.,1.);\n                            vec4 tvalx =\n                                vec4(tcolsi.rgb * shad + 3.*(vec3(1.,0.21,0.11)*tcolsi.rgb)*clamp(1.-(amb+dif),0.,1.), min(tcolsi.a,ta));\n                            tvalx.rgb=clamp(2.*tvalx.rgb*tvalx.rgb,0.,1.);\n                            tvalx.rgb*=(min(fadesi*5.,1.));\n                            colxsi[i]=tvalx;\n                        }\n                    }\n#endif\n                }\n            }\n        }\n    }\n    // transparency logic and layers sorting \n    float a = 1.;\n    if (dx[0].x < dx[1].x){{vec3 swap(dx[0], dx[1]);}{int swap(order[0], order[1]);}}\n    if (dx[1].x < dx[2].x){{vec3 swap(dx[1], dx[2]);}{int swap(order[1], order[2]);}}\n    if (dx[0].x < dx[1].x){{vec3 swap(dx[0], dx[1]);}{int swap(order[0], order[1]);}}\n\n    tout = max(max(dx[0].x, dx[1].x), dx[2].x);\n\n    if (dx[0].y < 0.5)\n    {\n        a=colx[order[0]].a;\n    }\n\n#if !(defined(DEBUG)&&defined(BUG))\n    \n    // self intersection\n    bool [3] rul= bool[3](\n        ((dx[0].y > 0.5) && (dx[1].x <= 0.)),\n        ((dx[1].y > 0.5) && (dx[0].x > dx[1].z)),\n        ((dx[2].y > 0.5) && (dx[1].x > dx[2].z))\n    );\n    for(int k=0;k<3;k++){\n        if(rul[k]){\n            vec4 tcolxsi = vec4(0.);\n            tcolxsi=colxsi[order[k]];\n            vec4 tcolx = vec4(0.);\n            tcolx=colx[order[k]];\n\n            vec4 tvalx = mix(tcolxsi, tcolx, tcolx.a);\n            colx[order[k]]=tvalx;\n\n            vec4 tvalx2 = mix(vec4(0.), tvalx, max(tcolx.a, tcolxsi.a));\n            colx[order[k]]=tvalx2;\n        }\n    }\n\n#endif\n\n    float a1 = (dx[1].y < 0.5) ? colx[order[1]].a : ((dx[1].z > dx[0].x) ? colx[order[1]].a : 1.);\n    float a2 = (dx[2].y < 0.5) ? colx[order[2]].a : ((dx[2].z > dx[1].x) ? colx[order[2]].a : 1.);\n    col = mix(mix(colx[order[0]].rgb, colx[order[1]].rgb, a1), colx[order[2]].rgb, a2);\n    a = max(max(a, a1), a2);\n    return vec4(col, a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float osc = 0.5;\n    vec3 l_dir = normalize(vec3(0., 1., 0.));\n    //l_dir *= rotz(0.5);\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    float mouseY = 1.0 * 0.5 * PI;\n#ifdef MOUSE_control\n    mouseY = (1.0 - 1.15 * iMouse.y / iResolution.y) * 0.5 * PI;\n    if(iMouse.y < 1.)\n#endif\n    mouseY = PI*0.49  * 0.55 * PI*99.01;\n    float mouseX = -2.*PI-0.25*(iTime+tshift);\n#ifdef MOUSE_control\n    mouseX+=-(iMouse.x / iResolution.x) * 2. * PI;\n#endif\n    \n    vec3 eye = 4. * vec3(cos(mouseX) * cos(mouseY), sin(mouseX) * cos(mouseY), sin(PI*0.49  * 1.4 * PI));\n    vec3 w = normalize(-eye);\n    vec3 up = vec3(0., 0., 1.);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n\n    vec3 rd = normalize(w * FDIST + uv.x * u + uv.y * v);\n\n    vec3 ni;\n    float t = box(eye, rd, BOXDIMS, ni, true);\n    vec3 ro = eye + t * rd;\n    vec2 coords = ro.xy * ni.z/BOXDIMS.xy + ro.yz * ni.x/BOXDIMS.yz + ro.zx * ni.y/BOXDIMS.zx;\n    float fadeborders = (1.-smoothstep(0.915,1.05,abs(coords.x)))*(1.-smoothstep(0.915,1.05,abs(coords.y)));\n\n    if (t > 0.)\n    {\n        float ang = -iTime * 0.33;\n        vec3 col = vec3(0.);\n        float R0 = (IOR - 1.) / (IOR + 1.);\n        R0 *= R0;\n\n        vec2 theta = vec2(0.);\n        vec3 n = vec3(cos(theta.x) * sin(theta.y), sin(theta.x) * sin(theta.y), cos(theta.y));\n\n        vec3 nr = n.zxy * ni.x + n.yzx * ni.y + n.xyz * ni.z;\n        vec3 rdr = reflect(rd, nr);\n        vec3 reflcol = background(ro, rdr, l_dir);\n\n        vec3 rd2 = refract(rd, nr, 1. / IOR);\n\n        float accum = 1.;\n        vec3 no2 = ni;\n        vec3 ro_refr = ro;\n\n        vec4 [2] colo = vec4[2](vec4(0.),vec4(0.));\n\n        for (int j = 0; j < 2 + ANGLE_loops; j++)\n        {\n            float tb;\n            vec2 coords2 = ro_refr.xy * no2.z + ro_refr.yz * no2.x + ro_refr.zx * no2.y;\n            vec3 eye2 = vec3(coords2, -1.);\n            vec3 rd2trans = rd2.yzx * no2.x + rd2.zxy * no2.y + rd2.xyz * no2.z;\n\n            rd2trans.z = -rd2trans.z;\n            vec4 internalcol = insides(eye2, rd2trans, no2, l_dir, tb);\n            if (tb > 0.)\n            {\n                internalcol.rgb *= accum;\n                colo[j]=internalcol;\n            }\n\n            if ((tb <= 0.) || (internalcol.a < 1.))\n            {\n                float tout = box(ro_refr, rd2, BOXDIMS, no2, false);\n                no2 = n.zyx * no2.x + n.xzy * no2.y + n.yxz * no2.z;\n                vec3 rout = ro_refr + tout * rd2;\n                vec3 rdout = refract(rd2, -no2, IOR);\n                float fresnel2 = R0 + (1. - R0) * pow(1. - dot(rdout, no2), 1.3);\n                rd2 = reflect(rd2, -no2);\n\n#ifdef backside_refl\n                if((dot(rdout, no2))>0.5){fresnel2=1.;}\n#endif\n                ro_refr = rout;\n                ro_refr.z = max(ro_refr.z, -0.999);\n\n                accum *= fresnel2;\n            }\n        }\n        float fresnel = R0 + (1. - R0) * pow(1. - dot(-rd, nr), 5.);\n        col = mix(mix(colo[1].rgb * colo[1].a, colo[0].rgb, colo[0].a)*fadeborders, reflcol, pow(fresnel, 1.5));\n        col=clamp(col,0.,1.);\n        float cineshader_alpha = 0.;\n        cineshader_alpha = clamp(0.15*dot(eye,ro),0.,1.);\n        fragColor = vec4(col, cineshader_alpha);\n    }\n    else\n    {\n        fragColor = vec4(background(eye, rd, l_dir), 0.15);\n    }\n}\n","name":"Image","description":"","type":"image"}]}