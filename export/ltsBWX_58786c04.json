{"ver":"0.1","info":{"id":"ltsBWX","date":"1514018509","viewed":153,"name":"a tiny self exam","username":"cailuming","description":"Try different geometries and compute their normals and do the texture mapping .But the star is bend,I don't know why","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["texture","normal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","previewfilepath":"/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FAR 128\n#define PI 3.1415926\n#define BIAS 1e-15\nstruct Ray{\n   vec3 o;\n   vec3 d;\n};\n   \nmat3 rotateX(float a){\n    float c= cos(a);\n    float s= sin(a);\n    \n    return mat3(\n        1,0,0,\n        0,c,s,\n        0,-s,c);\n}\n\nmat3 rotateY(float a){\n    float c= cos(a);\n    float s= sin(a);\n    \n    return mat3(\n        c,0,s,\n        0,1,0,\n        -s,0,c);\n}\n\nmat3 rotateZ(float a){\n    float c= cos(a);\n    float s= sin(a);\n    \n    return mat3(\n        c,s,0,\n        -s,c,0,\n        0,0,1);\n}\n\nfloat textureMap(vec3 p){\n    float arc =atan(p.y,p.z+BIAS);\n    float len =length(p);\n    float freq =texture(iChannel0,vec2(0,0)).y;\n    float v =0.04/sin(arc+len+2.*freq+iTime);\n    \n    return v;\n}\n\n\nfloat textureMap1(vec3 p){\n    float arc =atan(p.y,p.z+BIAS);\n    float len =0.543211+0.4*sin(7.*(p.y+sin(5.*arc)));\n   \n    float v =0.25/len;\n    \n    return v;\n}\n\nfloat textureMap2(vec3 p){\n    float arc =atan(p.y,p.z+BIAS);\n    float len =0.4*sin(4.*p.y+0.3*cos(10.*p.x));\n    \n    float v =0.25/len;\n    \n    return v;\n}\n\nfloat textureMap3(vec3 p){\n    p=mod(p,1.2)-0.6;\n    float arc =atan(p.z,p.x+BIAS);\n    float l=length(p);\n    float len =l*sin(3.*arc);\n    \n    float v =0.2122/len;\n     \n    return v;\n}\n\n\nvec4 drawObjA(vec3 pr,vec3 lightPos,vec3 center){ \n   vec3 p =pr-center;\n  \n   p*=rotateY(PI*0.2-iTime);\n  \n   \n   float u = atan(p.z,p.x+BIAS);\n   \n   float a=5.*cos(2.*u);\n   float b=0.21*sin(4.*u);\n   float s =1.5;\n   float r= s*(1.+b*sin(a*p.y));\n   float ru = s*0.8*(cos(4.*u)*sin(a*p.y)+0.2*sin(4.*u)*cos(2.*cos(2.*u)*p.y*(-4.*sin(2.*u))));  \n   float ry = s*b*a*cos(a*p.y);  \n  \n   vec3 polor =vec3(r*cos(u),clamp(p.y,-2.,2.),r*sin(u));\n    \n   vec3 pu =vec3(-r*sin(u)+ru*cos(u),0,r*cos(u)+ru*sin(u));\n   vec3 pv =vec3(ry*cos(u),1,ry*sin(u));\n    \n   vec3 norm =normalize(cross(pu,pv));\n   vec3 ldir =normalize(lightPos-polor);\n   \n   norm*=rotateY(PI*0.2+iTime);\n   \n   float nl =dot(norm,ldir);\n   \n   return  vec4(length(p-polor)-0.4,nl,textureMap(p),0);\n   \n}\n\nvec4 drawObjB(vec3 pr,vec3 lightPos,vec3 center){ \n   vec3 p =pr-center;\n  \n   p*=rotateY(PI*0.2-iTime);\n  \n   float u = atan(p.z,p.x+BIAS);\n   \n   float a=1.7;\n   float b=0.3;\n  \n   float r= 1.+b*sin(a*p.y);\n   float ry = b*a*cos(a*p.y);  \n  \n   vec3 polor =vec3(r*cos(u),clamp(p.y,-2.,2.),r*sin(u));\n    \n   vec3 pu =vec3(-r*sin(u),0,r*cos(u));\n   vec3 pv =vec3(ry*cos(u),1,ry*sin(u));\n    \n   vec3 norm =normalize(cross(pu,pv));\n   vec3 ldir =normalize(lightPos-polor);\n   \n   norm*=rotateY(PI*0.2+iTime);\n   float nl =dot(norm,ldir);\n   \n   return  vec4(length(p-polor)-0.4,nl,textureMap1(p),1);\n   \n}\n\nvec4 drawObjC(vec3 pr,vec3 lightPos,vec3 center){ \n   vec3 p =pr-center;\n  \n   \n   float u = atan(p.y,p.x+BIAS);\n   float v = abs(acos(dot(normalize(p),vec3(0,0,1))));\n   \n   float a=dot(vec3(0,1,0),normalize(p));\n   float b=0.3;\n  \n   float r= 1.+a;\n    \n    p.y*=0.7;\n   \n    vec3 polor =vec3(r*cos(u)*sin(v),r*sin(u)*sin(v),r*cos(v));\n    \n   vec3 pu =vec3(-r*sin(u)*sin(v),r*cos(u)*sin(v),0);\n   vec3 pv =vec3(r*cos(u)*cos(v),r*sin(u)*cos(v),-r*sin(v));\n    \n   vec3 norm =normalize(cross(pu,pv));\n   vec3 ldir =normalize(lightPos-polor);\n   \n   float nl =dot(norm,ldir);\n   \n   return  vec4(length(p-polor)-0.4,nl,textureMap2(p),2);\n   \n}\n\nvec4 drawGround(vec3 pr,vec3 lightPos,vec3 center){ \n   vec3 p =pr-center;\n  \n   \n   float u = atan(p.y,p.x+BIAS);\n   float v = abs(acos(dot(normalize(p),vec3(0,0,1))));\n   \n   float a=dot(vec3(0,1,0),normalize(p));\n     \n   vec3 polor =vec3(p.x,-3.,p.z);\n   \n   vec3 norm =vec3(0,1,0);\n   vec3 ldir =normalize(lightPos-polor);\n   \n   float nl =dot(norm,ldir);\n   \n   return  vec4(length(p-polor)-0.1,nl,textureMap3(p),3);\n   \n}\n\nvoid drawSky(vec3 pr,vec3 center,out vec3 col){ \n   \n   vec3 p=pr-center;\n   float u = atan(p.y,p.x+BIAS);\n  \n   float len =length(p.xy);\n   float d = abs(dot(vec3(0,1,0),p));\n   float d1 = abs(dot(vec3(1,0,0),p));\n   // clip the star\n   d+=pow(len,3.+sin(iTime));\n   d1+=pow(len,2.+cos(iTime));\n   \n   float v =.06/len;  \n   v=pow(v,2.);\n   // blend the star\n   v+=0.01/(d);\n   v+=0.01/(d1);\n   \n    \n   col=vec3(v*0.6,v*(sin(iTime)*0.3+0.8),v*(cos(iTime)*0.5+0.7)); \n    \n}\n\nvec4 map(vec3 p,vec3 lightPos){\n    vec4 ref=vec4(1000);\n    vec4 temp=vec4(0);\n    \n    p*=rotateX(PI*0.01);\n    \n  \n       temp=drawObjA(p,lightPos,vec3(-5.,0,0));\n       if(ref.x>temp.x){\n          ref=temp;\n       }\n       temp=drawObjB(p,lightPos,vec3(1.,0,1));\n    \n       if(ref.x>temp.x){\n          ref=temp;\n       }\n       \n       temp=drawObjC(p,lightPos,vec3(10.*cos(iTime),0,5.*sin(iTime)));\n    \n       if(ref.x>temp.x){\n          ref=temp;\n       }\n       \n       temp=drawGround(p,lightPos,vec3(0,0,0));\n       \n       if(ref.x>temp.x){\n          ref=temp;\n       }\n    \n    \n    return ref;\n   \n}\n\n\nvec4 rayHit(Ray ray,vec3 lightPos){\n   float t=0.;\n   int isHit =0;\n   vec3 p= vec3(0);\n   \n   vec4 dis = vec4(0);\n   \n   for(int i=0;i<FAR;i++){\n        p=ray.o+t*ray.d;\n       \n        dis =map(p,lightPos);\n        if(dis.x<=0.005){\n            dis.y=clamp(dis.y,0.2,1.);\n            isHit=1;\n            break;\n        }\n        \n        if(dis.x>=20.){\n           isHit=0;\n           \n           break;\n        }\n        \n        t+=dis.x;\n    }\n    \n    \n    return vec4(isHit,dis.y,dis.z,dis.w);\n    \n}\n\nvec3 getColorByID(int id){\n    if(id==0){\n        return vec3(1.,0,0.2);\n    }else if(id==1){\n        return vec3(0.2,1,0.2);\n    \n    }else if(id==2){\n        return vec3(1,1,0.2);\n    \n    }else if(id==3){\n        return vec3(0.2,0.2,1);\n    \n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy-vec2(0.5);\n    float aspect = iResolution.x/iResolution.y;\n    vec3 screenP = vec3(uv.x*aspect,uv.y,-10);\n    vec3 eye =vec3(0,-0.1,-11);\n    vec3 col  =vec3(0);\n    vec3 lightPos =vec3(sin(iTime)*10.,0,cos(iTime)*10.);\n    float freq =texture(iChannel0,vec2(0,0)).y;\n    \n    Ray ray;\n    ray.o= eye;\n    ray.d= normalize(screenP-eye);\n  \n    ray.d*=rotateY(PI*0.1*sin(iTime*0.5));\n    vec4 hit=rayHit(ray,lightPos);\n     \n    if(hit.x<=0.){\n       hit.yz=vec2(0);\n       drawSky(ray.o+ray.d,vec3(0,freq*0.5,0),col);\n    }\n    \n    hit.y+=pow(hit.y,30.);\n    hit.z=clamp(pow(hit.z,2.)*hit.y,0.,1.);\n    \n    \n    col+=vec3(hit.y*0.7*sin(iTime),hit.y*cos(iTime)*0.7,hit.y*0.2);\n    col+=vec3(hit.z)*getColorByID(int(hit.w));\n    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}