{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// Naive realtime path tracer, cc-by-nc-sa 2013.05, Ivan 'w23' Avdeev, http://w23.ru\n// My first attempt at path tracing.\n// I didn't read any papers on the topic, because I'm stupid and don't understand those,\n// so this may be a not real path-tracer but some <s>retarded</s>related technique.\n\n// Ray sampling is straightforward random, there's no importance sampling or other\n// optimizations whatsoever, so this baby is very slow and noisy, don't do that.\n\n// Also, I have no idea how to make an efficient PRNG in GLSL, so there are sometimes\n// visible sampling artefacts, especially when SAMPLES count is low (or very high).\n\n// Version history:\n//  v.05 - 2013.05.16 ( 13:44) - removed isection_t; fixed reflections\n//  v.04 - 2013.05.15 ( 14:20) - material stack removed; it's now official: i am retarded\n//  v.03 - 2013.05.14 ( 22:58) - fix for missing spheres on windows\n//  v.02 - 2013.05.13 (~23:00) - fix for osx black screen and speed\n//  v.01 - 2013.05.13 (~02:00) - removed spheres by default to fix crashes on windows.\n//  v.00 - 2013.05.13 (~01:00) - first release\n\n// Some facts:\n// Unroll is 1.5x faster on osx.\n// Unroll is 1.5x slower on linux.\n// Not unrolling breaks on windows.\n#define UNROLL 1\n\n// Number of rays shot per pixel\n// More rays result in prettier and less noisy image, but at a performance cost.\n// 16 samples give bearable image at 20fps on gtx 460 in preview window and 5 fps in fullhd\n// If you get errors or a black screen, try to reduce this number.\n#define SAMPLES 16\n\n// Number of bounces ray make until it's killed \n#define REFLECTIONS 4\n\n// Various limits\n#define SCENE_RADIUS 100.\n#define INFINITY 31337.\n#define ISEC_EPSILON .01\n\n// A tiny step to give ray a chance to escape when reflecting\n#define REFLECT_EPSILON .01\n\n// Useful to tweak global time in a single place\nfloat t;\n\n// A typical ray has an origin and a direction\nstruct ray_t { vec3 origin, dir; };\n\t\n// A material\nstruct material_t {\n\t// \"color\" is a color that an object will emit back when lit\n\t// \"emission\" is a color that the object emits by itself\n\tvec3 color, emission;\n\t// \"specular\" is a [0..1] coefficient of \"directionality\" of reflected ray.\n\t// 0 = a ray will reflect in random direction, 1 = no random, exact reflection\n\t// in other words, 0 - pure diffuse material, 1 - mirror\n\tfloat specular;\n};\n\n// A plane has a normal and offset. A plane is also a nice object with material.\nstruct plane_t {\n\tvec3 normal;\n\tfloat offset;\n\tmaterial_t material;\n};\n// Why am I writing comments for such trivial things?!\nstruct sphere_t {\n\tvec3 center;\n\t// square of a radius\n \tfloat radius2;\n\tmaterial_t material;\n};\n\n// The objects we have.\nplane_t planes[6];\nsphere_t spheres[2];\n\n// Initialize objects\nvoid init_stuff() {\n\t// X = -1 plane, diffuse orange\n\tplanes[0] = plane_t(vec3( 1.,0.,0.), 1.,material_t(vec3(1.,.5,.2),vec3(0.),.2));\n\t// X = 1, diffuse green\n\tplanes[1] = plane_t(vec3(-1.,0.,0.), 1.,material_t(vec3(.5,1.,.2),vec3(0.),.2));\n\t// Y = -1, diffuse blue\n\tplanes[2] = plane_t(vec3(0., 1.,0.), 1.,material_t(vec3(.2,.5,1.),vec3(0.),.2));\n\t// Y = 1, white emitter (lamp)\n\tplanes[3] = plane_t(vec3(0.,-1.,0.), 1.,material_t(vec3(1.,1.,1.),vec3(1.),.2));\n\t// Z = -1, a slighly fuzzy mirror \n\tplanes[4] = plane_t(vec3(0.,0., 1.), 1.,material_t(vec3(1.,1.,1.),vec3(0.),.9));\n\t// Z = 1, diffuse white\n\tplanes[5] = plane_t(vec3(0.,0.,-1.), 1.,material_t(vec3(1.,1.,1.),vec3(0.),.2));\n\t\n\t// pure mirror sphere in the center\n\tspheres[0] = sphere_t(vec3(.3*sin(t),-.1, 0.),.04,material_t(vec3(1.),vec3(.0),1.));\n\t\n\t// flying white diffuse sphere that is also a small lamp\n\tspheres[1] = sphere_t(vec3(.8*cos(t*1.7), .9*cos(t*.4), .8*sin(t)),.01,material_t(vec3(.2),vec3(.8),.3));\n\t\n\t// or a black hole!\n\tif (iMouse.z > 0.) spheres[1].material.color = spheres[1].material.emission = vec3(-4.);\n}\n\n// OH I AM SOOOO RANDOM\nfloat hash(float x) {\n \treturn fract(sin(x)*265871.1723);\n}\n\n// Intersect a plane with a ray\n// This is trivial, go get a pen and do it yourself.\nfloat isec_plane(in ray_t ray, in plane_t plane) {\n \tfloat ND = -dot(plane.normal, ray.dir);\n \tif (ND < ISEC_EPSILON) return INFINITY;\n \tfloat t = (dot(plane.normal, ray.origin) + plane.offset) / ND;\n \tif (t < 0.) return INFINITY;\n \treturn t;\n}\n\n// Intersect a sphere with a ray\n// Also trivial, but I didn't consider any funny cases like being inside a sphere\nfloat isec_sphere(in ray_t ray, in sphere_t sphere) {\n\tvec3 v = sphere.center - ray.origin;\n\tfloat b = dot(v, ray.dir);\n\tfloat c = dot(v, v) - sphere.radius2;\n\tfloat det2 = b * b - c;\n\tif (det2 < 0.) return INFINITY;\n\tfloat t = b - sqrt(det2);\n\tif (t < 0.) return INFINITY;\n\treturn t;\n}\n\n// Make a ray using normalized pixel position, eye position and focus point\nray_t lookAtDir(in vec3 uv_dir, in vec3 pos, in vec3 at) {\n\tvec3 f = normalize(at - pos);\n\tvec3 r = cross(f, vec3(0.,1.,0.));\n\tvec3 u = cross(r, f);\n\treturn ray_t(pos, normalize(uv_dir.x * r + uv_dir.y * u + uv_dir.z * f));\n}\n\n// Ð’Ñ‹Ñ‚Ð¸Ñ€Ð°Ð¹Ñ‚Ðµ Ð½Ð¾Ð³Ð¸\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    t = iTime * .7;\n\tinit_stuff();\n\t\n\t// Calculate normalized and aspect-corrected pixel position \n\tfloat aspect = iResolution.x / iResolution.y;\n\tvec2 uv = (fragCoord.xy / iResolution.xy * 2. - 1.) * vec2(aspect, 1.);\n  \n\t// Calculate main eye ray\n\tray_t oray;\n\tif (iMouse.z > 0.) {\n\t\t// Don't mind me i r pretty controls\n\t\tvec2 click = iMouse.zw / iResolution.xy * 2. - 1.;\n\t\tvec2 pos = iMouse.xy / iResolution.xy * 2. - 1.;\n\t\tvec2 dif = click - pos;\n\t\tvec3 origin = .8*vec3(cos(click.x), 0., sin(click.x));\n\t\tvec3 at = origin + vec3(sin(3.*dif.x), pos.y * 2., cos(3.*dif.x));\n\t\toray = lookAtDir(normalize(vec3(uv, 2.)), origin, at);\n\t} else {\n\t\toray = lookAtDir(normalize(vec3(uv, 2.)),\n\t\t\t\t\t\t .9*vec3(cos(t), .8*sin(t*.7), sin(t)),\n\t\t\t\t\t\t (spheres[0].center+spheres[1].center)*.5);\n\t}\n\n\t// Where all the rays will end up accumulated to\n\tvec3 sumcolor = vec3(0.);\n\n\t// A pathetic attempt at seeding some randomness\n\tfloat seed = float(t)*.24 + fragCoord.x + fragCoord.y;\n\n\t// For all pixel samples\n\tfor (int samplei = 0; samplei < SAMPLES; ++samplei) {\n\t\t// This is ridiculous and no fun, but I don't know better :(\n\t\tseed += float(samplei);\n\n\t\t// Start with primary eye ray\n\t\tray_t ray = oray;\n\n\t\t// color coefficient for current bounce segment\n\t\tvec3 kcolor = vec3(1.);\n\n\t\t// For all bounces/reflections\n\t\tfor (int i = 0; i < REFLECTIONS; ++i) {\n\t\t\t// Current and new intersections and materials. Current is set to infinity.\n\t\t\tfloat cp = INFINITY, np;\n\t\t\tvec3 n = vec3(0.);\n\t\t\tmaterial_t cm, nm;\n\n#if !UNROLL // Broken on win32/firefox\n\t\t\t// For all planes\n\t\t\tfor (int j = 0; j < 6; ++j) {\n\t\t\t\t// Find intersecion\n\t\t\t\tni = isec_plane(ray, planes[j]);\n\t\t\t\t// If it is closer than the current one, accept as the new current\n\t\t\t\tif (ni.path < ci.path) { ci = ni; cm = planes[j].material; }\n\t\t\t}\n\n\t\t\t// Same for all spheres\n\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\tni = isec_sphere(ray, spheres[j]);\n        \t\tif (ni.path < ci.path) { ci = ni; cm = spheres[j].material; }\n      \t\t}\n#else //if UNROLL\n#define PLANESECT(idx) np=isec_plane(ray,planes[idx]);if(np<cp){cp=np;cm=planes[idx].material;n=planes[idx].normal;}\n\t\t\tPLANESECT(0);\n\t\t\tPLANESECT(1);\n\t\t\tPLANESECT(2);\n\t\t\tPLANESECT(3);\n\t\t\tPLANESECT(4);\n\t\t\tPLANESECT(5);\n#define TR(l) (ray.origin + l * ray.dir)\n\t\t\tvec3 newpos = TR(cp);\n#define SPHERESECT(idx) np=isec_sphere(ray,spheres[idx]);if(np<cp){cp=np;cm=spheres[idx].material;newpos=TR(cp);n=normalize(newpos-spheres[idx].center);}\n\t\t\tSPHERESECT(0);\n\t\t\tSPHERESECT(1);\n#endif\n\t\t\t// If the current interseciont doesn't exist, everything is lost\n\t\t\t// commented out in v.02. consequences are:\n\t\t\t// (a) black screen on osx is fixed on non-unrolled stuff\n\t\t\t// (b) speed on osx is improved ~30%\n\t\t\t// Why's that is still a mystery to me.\n\t\t\t// Go home, GLSL, you are drunk!\n\t\t\t//if (cp > SCENE_RADIUS) break;\n\n\t\t\t// collect emission with current coefficient\n\t\t\tsumcolor += kcolor * cm.emission;\n\t\t\t\n\t\t\t// all following bounces will be affected by current material's color\n\t\t\tkcolor *= cm.color;\n\n\t\t\t// Make a random vector\n\t\t  \tvec3 nvec = normalize(vec3(hash(seed+=newpos.x),\n\t\t\t\t\t\t\t \t\t   hash(seed+=newpos.y),\n\t\t\t\t\t\t\t \t\t   hash(seed+=newpos.z))*2. - vec3(1.));\n\t\t\t// Make it point to the same hemisphere as a current intersetion's normal\n\t\t\t// (\\todo DOES THIS REALLY WORK?!?!)\n\t\t\tnvec *= dot(nvec, n);\n\n\t\t\t// Construct a new reflected ray.\n\t\t\t// Specular is used to lerp between correct reflection and random nonsense.\n\t\t\tray.dir = mix(nvec, reflect(ray.dir, n), cm.specular);\n\n\t\t\t// New ray's origin is set just a bit outside of intersection point, so\n\t\t\t// that the new ray is not immediately intersects at the same point.\n\t\t\tray.origin = newpos + n * REFLECT_EPSILON;\n\t\t} // for all bounces\n\t} // for all samples\n\n\t// We're done, weight accumulated pixel and write it to users' eyes\n\t// (\\todo do I need to gamma-correct here? I know nothing about gamma correction, but\n\t//        everyone else seem to do it. Oh what to do!)\n\tfragColor = vec4(pow(max(vec3(0.), sumcolor) / float(SAMPLES), vec3(.7)), 1.);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdfGW8","date":"1368381999","viewed":1450,"name":"wat tracing","username":"w23","description":"A dramatic story in source comments.","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","reflections","pathtracing"],"hasliked":0,"parentid":"","parentname":""}}