{"ver":"0.1","info":{"id":"XdBBWm","date":"1500574981","viewed":119,"name":"Cage I","username":"zaiyugi","description":"Raymarched scene with a moving light and soft shadows.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// zshore\n#define MAX_ITERATIONS 256\n#define MAX_LIGHT_ITERATIONS 128\n#define M_PI 3.1415926535897932384626433832795\n\nfloat deg2rad = M_PI / 180.0;\nfloat rad2deg = 180.0 / M_PI;\n\nvec3 light_p = vec3(0.0, 100.0, 0.0); \nvec3 light_n = vec3(0.0, -1.0, 0.0);\nvec3 light_C = vec3(255.0, 153.0, 102.0) / 255.0;\n\nfloat epsilon = 0.0003;\n\nfloat sdf(vec3 p)\n{\n    vec3 c = vec3(3.0);\n    vec3 q = mod(p, c) - 0.5 * c;\n    \n    float d1 = length(q) - 1.7;\n    \n    q = p + vec3(0.0, 88.3, 0.0);\n    vec3 d = abs(q) - vec3(250.0, 100.0, 250.0);\n    float d2 = min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n    \n    float d3 = length(p) - 12.0;\n    \n    return max( -d3, max(-d1, d2) );\n}\n\nvec3 getNormal(vec3 p)\n{\n    float h = epsilon;\n    return normalize(vec3(\n        sdf(p + vec3(h, 0, 0)) - sdf(p - vec3(h, 0, 0)),\n        sdf(p + vec3(0, h, 0)) - sdf(p - vec3(0, h, 0)),\n        sdf(p + vec3(0, 0, h)) - sdf(p - vec3(0, 0, h))\n        ));\n}\n\nfloat shadow(vec3 r0, vec3 rd, float mint, float maxt, float k)\n{\n    float t = mint;\n    float res = 1.0;\n    for( int i = 0; i < MAX_LIGHT_ITERATIONS; ++i )\n    {\n        if( t >= maxt )\n            break;\n\n        float h = sdf(rd*t + r0);\n        if(h < epsilon/3.0)\n            return 0.0;\n\n        res = min( res, k * h / t );\n        t += h;\n    }\n    return res;\n}\n\nvec3 shade(vec3 p, float dist)\n{\n    vec3 mcol = vec3(0.5, 0.25, 0.5);\n\n    // Top Light\n    vec3 ro = light_p;\n    vec3 rd = normalize(p - ro);\n\n    float shadowFactor = 0.0;\n    if( acos(dot(rd, light_n))*rad2deg < 15.0 )\n        shadowFactor = shadow( p, -rd, epsilon, length(p - ro), 192.0 );\n\n    vec3 lcol = light_C;\n    vec3 scol = lcol * mcol;\n\n    vec3 N = getNormal(p);\n    vec3 toLgt = normalize(light_p - p);\n    float Id = dot( N, toLgt );\n    vec3 H = normalize(toLgt + -rd);\n    float Is = pow( dot(H, N), 50.0 );\n\n    scol = scol * Id;\n    scol += vec3(1.0) * Is;\n    scol = clamp(scol, 0.0, 1.0);\n\n    return scol * shadowFactor;\n}\n\nvec3 raymarch(vec3 r0, vec3 rd)\n{\n    float t = 0.0;\n\n    vec3 p;\n    for(int i = 0; i < MAX_ITERATIONS; ++i)\n    {\n        p = rd * t + r0;\n        float d = sdf(p);\n        if(d < epsilon)\n            break;\n\n        t += d;\n    }\n\n    vec3 color = shade(p, t);\n    \n    float b = 0.01;\n    float fogStrength = 1.0 - exp(-t * b);\n    color = mix(color, vec3(0.5, 0.6, 0.7), fogStrength);\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect_ratio = iResolution.x / iResolution.y;\n\tvec2 p_uv = fragCoord.xy / iResolution.xy;\n    p_uv = p_uv * 2.0 - 1.0;\n\n    float angle = iTime * 0.04 * M_PI;\n    float focal_length = 1.0 / tan( 37.5 * deg2rad );\n\n    light_p.y = sin(iTime * M_PI * 0.4) * 40.0 + 30.0;\n\n    vec3 eye = vec3(11.25 * cos(angle), 0.0, 11.25 * sin(angle));\n\n    vec3 focus = vec3(0.0, -5.0, 0.0);\n    vec3 view = normalize(focus - eye);\n\n    vec3 up = vec3(0.0, 1.0, 0.0);\n\n    vec3 right = vec3(cos(angle + M_PI / 2.0), 0.0, sin(angle + M_PI / 2.0));\n\n    vec3 rd = normalize(view * focal_length + up * p_uv.y + right * p_uv.x * aspect_ratio);\n    vec3 color = raymarch(eye, rd);\n\n    fragColor = vec4( color, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}