{"ver":"0.1","info":{"id":"7sjcWy","date":"1644074812","viewed":297,"name":"Liminal Spaces","username":"playbyan1453","description":"Not sure if this liminal space for me it feel like it is the thing I'm looking for, I have obession to this lately.","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","pathtracing","liminal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Buffer A Doing the impressive work\n// Buffer B export in hdr\n\n// Changelog 2022/2/11 5:58 PM GMT+7:\n// - michael0884's Blue Noise\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord.xy), 0).xyz;\n    // Tonemapping\n    col = pow(col/(col+1.0), vec3(0.5));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Basic Settings to play with\n#define iter 1024\n#define epsilon 1e-4\n#define tmax 1e2\n#define bounces 2u\n\n#define depthoffield\n#define bloom\n\n// SDF And Ray Marcher\n// SDF by iq\nfloat cubeSDF(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)),0.0);\n}\n\nfloat cylinderSDF(vec3 p, float h, float r) {\n    vec2 d = abs(vec2(length(p.yz), p.x)) - vec2(h, r);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n//Scene\nfloat map(vec3 p, out int mat) {\n    float c = 8.0;\n    vec3 a = p;\n    a.xz-= vec2(0.5 * c);\n    a.xz = mod(a.xz + 0.5 * c, c) - 0.5 * c;\n    vec3 b = p;\n    b.xz = mod(b.xz + 0.5 * c, c) - 0.5 * c;\n    float wall = cubeSDF(a, vec3(0.5, 1, 0.5));\n    float ground = min(p.y + 1.0, -p.y + 1.0);\n    float lamp = cylinderSDF(b-vec3(0, 0.95, 0), 0.25, 1.0);\n    // float sphere = length(p - vec3(0,-0.75, 0)) - 0.25;\n    float t = min(min(wall, ground), lamp);\n    \n    // Material ID system \n    mat = t == ground ? 0 :\n          t == wall   ? 1 :\n       // t == sphere ? 2 :\n          t == lamp   ? 2 : -1;\n    return t;\n}\n\n// Iq Normal Tetrahedron technique\n// https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p) {\n    const float e = epsilon;\n    int x;\n    const vec2 h = vec2( e,-e);\n    return normalize(h.xyy*map(p + h.xyy, x)+\n                     h.yyx*map(p + h.yyx, x)+\n                     h.yxy*map(p + h.yxy, x)+\n                     h.xxx*map(p + h.xxx, x));\n}\n\nfloat raymarch(vec3 ro, vec3 rd, out int mat) {\n    float t = epsilon * 10.0;\n    for(int i = 0; i < iter; i++) {\n        float d = map(ro + rd * t, mat);\n        t += d;\n        if(d < epsilon || t > tmax) break;\n    }\n    return t;\n}\n\n// Path Tracer Originally by Monterman\n// https://www.shadertoy.com/view/4dyBRK\nstruct material {\n    vec3 albedo;\n    float specular;\n    float metalness;\n    float roughness;\n    bool emission;\n};\n\n// Grid pattern by iq\nfloat grid(vec2 p) {\n    vec2 i = step(fract(p), vec2(1.0 / 20.0));\n    return (1.0-i.x)*(1.0-i.y);\n}\n\n// Hash functions by markjarzynski:\n// https://www.shadertoy.com/view/XlGcRh\nuint baseHash(uvec2 p) {\n    uvec2 state = ((p * 747796405u) ^ p.yx) + 2891336453u;\n\tuint word = ((state.x >> ((state.y >> 28u) + 4u)) ^ state.y) * 277803737u;\n\treturn (word >> 28u) ^ word;\n}\n\n// Blue Hash Function by michael0884:\n// https://www.shadertoy.com/view/wltcRS\nivec2 px;\n\nvec4 baseBlueHash(inout float seed) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=0.1, seed+=0.1)));\n    uvec2 rz = uvec2(n, n * 48271u) & uvec2(0x7fffffffu);\n    ivec2 p = (px + ivec2((rz >> 5u) % 0x0fffffffu)) % 1024;\n    return abs(2.0 * fract(texelFetch(iChannel1, p, 0) + 1.61803398 * seed) - 1.0);\n}\n\nfloat hash1(inout float seed) {\n    return baseBlueHash(seed).x;\n}\n\nvec2 hash2(inout float seed) {\n    return baseBlueHash(seed).xy;\n}\n\n// Fizzer's lambert without tangent: http://www.amietia.com/lambertnotangent.html\nvec3 lambertDistrib(vec3 nor, inout float seed) {\n    vec2 uv = hash2(seed) * vec2(2.0, 6.2831853) - vec2(1, 0);\n    vec3 spherePoint = vec3(sqrt(1.0 - uv.x * uv.x) * vec2(cos(uv.y), sin(uv.y)), uv.x);\n    return normalize(nor + spherePoint);\n}\n\n// Random in disk\nvec2 randInUnitDisk(inout float seed) {\n    vec2 uv = hash2(seed) * vec2(1.0, 6.2831853);\n    return sqrt(uv.x) * vec2(sin(uv.y), cos(uv.y));\n}\n\nvec3 pathtrace(vec3 ro, vec3 rd, inout float seed) {       \n    vec3 col = vec3(0);\n    vec3 atten = vec3(1);\n    vec3 nor;\n    float tf;\n    // Added 2 more bounces in case 0 bounces results no output\n    for(uint i = 0u; i < bounces+2u; i++) {\n        float tmin = tmax;\n        material mat;\n        int matid;\n        float t = raymarch(ro, rd, matid);\n        if(i == 0u) tf = t;\n        if(t > epsilon && tmin > t) {\n            tmin = t;\n            nor = normal(ro + rd * t);\n            vec3 albedo = matid == 0 ? mix(vec3(0), vec3(0.95), grid((ro+rd*t).xz)) : vec3(0);\n                 albedo = matid == 1 ? mix(vec3(0.95), vec3(0), smoothstep(-0.6,-0.6999, (ro+rd*t).y)) : albedo;\n            mat = material(matid == 2 ? vec3(10) : albedo, 0.005, 0.0, 0.05, matid == 2);\n        }\n        if(tmin > epsilon && tmin < tmax) {\n            if(mat.emission) col += atten * mat.albedo;\n            atten *= mat.albedo;\n            \n            ro = ro + rd * tmin;\n            rd = lambertDistrib(nor, seed);\n        } else break; // There is no sky just void\n    }\n    // Fog?\n    col = mix(vec3(1), col, exp(-tf * 0.01 - 0.1));\n    return col;\n}\n\n// Camera Matrix Inspired by iq\nmat3 cam(vec3 at, vec3 ro) {\n    vec3 z = normalize(at - ro);\n    vec3 x = normalize(cross(vec3(0, 1, 0), z));\n    vec3 y = cross(z, x);\n    return mat3(x, y, z);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/max(iResolution.x, iResolution.y);\n    px = ivec2(fragCoord);\n    float seed = float(baseHash(uvec2(0) + uint(iFrame)))/float(0xffffffffu);\n    vec2 rnd = randInUnitDisk(seed);\n    uv += 1.5 * rnd / max(iResolution.x, iResolution.y);\n    \n    #ifdef bloom\n    float r = hash1(seed);\n          r = log2(1.0 - r * r);\n    uv += rnd * (r * r) / max(iResolution.x, iResolution.y);\n    #endif\n    \n    vec3 at = vec3(0, 0, 0);\n    vec3 ro = vec3(0, 0,-6);\n    mat3 ca = cam(at, ro);\n    vec3 rd = ca * normalize(vec3(uv, 1));\n    \n    #ifdef depthoffield\n    // DOF correct focus plane\n    vec3 p = normalize(at - ro);\n    float d = -(dot(p, ro - p) + 6.8);\n    float t = -(dot(ro, p) + d) / dot(rd, p);\n    vec3 fp = ro + rd * t;\n    ro += ca * vec3(rnd, 0) * 0.04;\n    rd = normalize(fp - ro);\n    #endif\n    \n    vec3 prev_col = texelFetch(iChannel0, ivec2(fragCoord.xy), 0).xyz;\n    vec3 col = pathtrace(ro, rd, seed);\n    \n    fragColor = vec4((prev_col * float(iFrame) + col) / float(iFrame + 1), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// HDR export in OpenEXR format file by clicking image icon on bottom right\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord.xy), 0).xyz;\n    \n    // Color Grading (in linear space)\n    col = max(col*vec3(0.761, 0.890, 1.000), 0.0);\n    \n    // Vignette by Ippokratis : https://www.shadertoy.com/view/lsKSWR\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv *= 1.0 - uv;\n    col *= pow(uv.x*uv.y * 15.0, 0.25);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}