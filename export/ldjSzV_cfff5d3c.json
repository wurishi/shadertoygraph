{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define PI 3.14159\n\n// You can play with these defines ! :D\n// 05/08/17: Fixed inverse and transpose already defined (were those added recently?)\n\n#define SHOW_LIGHT\n#define SHADOW\n#define REFLEXION\n#define COOKTORRANCE\n#define NORMALMAPPING_TEST\n\n// Yeap, that s really dirty\n#ifdef COOKTORRANCE \n\t#define phong cookTorrance\n#endif\n\n//#define MULTISAMPLING\n#define SAMPLES 4\n\n#define MOTIONBLUR_SAMPLES 1.0\n//#define MOTIONBLUR_SAMPLES 4.0\n\n#define SPHERE_LIGHT\nconst float LightDefaultRadius = 0.5;\n\n#define LIGHTS_COUNT 3\n\n//#define GAMMA\nconst vec3 Gamma = vec3(2.0, 2.0, 2.0);\n\nstruct Material\n{\n    int type;\n    float reflectivity;\n    \n    vec3 diffuse;\n    \n    // Cook-Torrance\n    float roughness;\n    float fresnelReflectance;\n    float diffuseReflection;\n    \n    // Blinn-Phong\n    float specular;\n    \n    vec4 infos;\n    vec2 uv;\n};\n    \nstruct Plane\n{\n    vec3 p;\n    vec3 n;\n};\n\nstruct Sphere\n{\n    vec3 c;\n    float r;\n};\n    \nSphere makeSphere(vec3 c, float r) { Sphere s; s.c = c; s.r = r; return s; }\n\nstruct Ray\n{\n    vec3 o;\n    vec3 d;\n    float m;\n};\n    \nstruct Output\n{\n    vec3 p;\n    vec3 n;\n    float d;\n    Material m;\n};\n    \nstruct Light\n{\n    vec3 color;\n    vec3 position;\n    #ifdef SPHERE_LIGHT\n    float radius;\n    #endif\n};\n\nLight Lights[LIGHTS_COUNT];\n\n\nmat2 rot2d(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c,-s,\n\t\t\t\ts, c);\n}\n\nvec3 rotateX(vec3 p, float a)\n{\n\tfloat sa = sin(a);\n\tfloat ca = cos(a);\n\treturn vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n\tfloat sa = sin(a);\n\tfloat ca = cos(a);\n\treturn vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nmat4 rot(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nmat3 _transpose(mat3 i)\n{\n    return mat3(i[0].x, i[1].x, i[2].x,\n                i[0].y, i[1].y, i[2].y,\n                i[0].z, i[1].z, i[2].z);\n}\n\nfloat det(mat2 m)\n{\n    return m[0].x * m[1].y - m[1].x * m[0].y;\n}\n\nfloat det(mat3 m)\n{\n    return m[0].x * det(mat2(m[1].yz, m[2].yz)) -\n           m[1].x * det(mat2(m[0].yz, m[2].yz)) +\n           m[2].x * det(mat2(m[0].yz, m[1].yz));\n}\n\nmat3 _inverse(mat3 m)\n{\n    float d = det(m);\n    if(d == 0.0)\n        return mat3(1.0);\n    return (1.0 / d) * mat3(\n        vec3(det(mat2(m[1].yz, m[2].yz)), det(mat2(m[2].yz, m[0].yz)), det(mat2(m[0].yz, m[1].yz))),\n        vec3(det(mat2(m[2].xz, m[1].xz)), det(mat2(m[0].xz, m[2].xz)), det(mat2(m[1].xz, m[0].xz))),\n        vec3(det(mat2(m[1].xy, m[2].xy)), det(mat2(m[2].xy, m[0].xy)), det(mat2(m[0].xy, m[1].xy))));\n}\n\nvec3 tangentToWorldSpace(vec3 v, vec3 n)\n{   \n\tvec3 tang = normalize(v);\t\n\tvec3 bitang = normalize(cross(n, tang));\n\ttang = normalize(cross(bitang, n));\n    \n    return normalize((tang * v.x) + (bitang * v.y) + (n * v.z));\n}\n\nvec2 sphereUV(vec3 p, vec3 c)\n{\n    vec3 d = normalize(c - p);\n    if(d.z == 0.0) return vec2(0.0, 0.0);\n    return vec2(0.5 + atan(d.x, d.z)/(2.0 * PI),\n                0.5 - asin(d.y)/PI);\n}\n\n//////////////////////////////////////////////////////////////\n// FROM https://www.shadertoy.com/view/4ss3W7\n\nfloat luminance(vec3 c)\n{\n\treturn dot(c, vec3(.2126, .7152, .0722));\n}\n\nvec3 normal(vec2 t, sampler2D tx, vec2 txsize, float depth)\n{    \n#define OFFSET_X 0.3\n#define OFFSET_Y 0.3\n    float R = abs(luminance(texture(tx, t + vec2( OFFSET_X,0) / txsize).xyz));\n\tfloat L = abs(luminance(texture(tx, t + vec2(-OFFSET_X,0) / txsize).xyz));\n\tfloat D = abs(luminance(texture(tx, t + vec2(0, OFFSET_Y) / txsize).xyz));\n\tfloat U = abs(luminance(texture(tx, t + vec2(0,-OFFSET_Y) / txsize).xyz));\n  \n\tfloat X = (L-R) * .5;\n\tfloat Y = (U-D) * .5;\n\n\treturn normalize(vec3(X, Y, 1. / depth));\n}\n\n//////////////////////////////////////////////////////////////\n\nbool tracePlane(Plane p, Ray r, inout Output o)\n{\n    float d = dot(r.o, p.p);\n    \n    float l = dot(p.n, (p.p - r.o)) / dot(p.n, r.d);\n    \n    vec3 h = r.o + l * r.d;\n        \n   \tif(l < 0.0 || l > o.d || l > r.m)\n        return false;\n     \n    // Hit\n    o.p = h;\n    o.n = p.n;\n    o.d = abs(l);\n    o.m = Material(1, 0.1, vec3(0.0), 0.8, 0.4, 0.1, 0.0, vec4(0.0), vec2(0.0));\n    \n    return true;\n}\n\nbool traceSphere(Sphere s, Ray r, inout Output o)\n{\t\n    vec3 d = r.o - s.c;\n\t\n\tfloat a = dot(r.d, r.d);\n\tfloat b = dot(r.d, d);\n\tfloat c = dot(d, d) - s.r * s.r;\n\t\n\tfloat g = b*b - a*c;\n\t\n\tif(g > 0.0)\n    {\n\t\tfloat dis = (-sqrt(g) - b) / a;\n\t\tif(dis > 0.0 && dis < o.d)\n        {\n\t\t\to.p = r.o + r.d * dis;\n\t\t\to.n = (o.p - s.c) / s.r;\n            o.d = dis;\n            o.m = Material(0, 0.15, vec3(0.0), 0.2, 0.9, 0.5, 64.0, vec4(s.c, 0.0), vec2(0.0));\n            return true;\n\t\t}\n\t}\n    return false;\n}\n\nbool traceScene(Ray r, inout Output o, float time)\n{\n    Sphere s;\n    bool b = false;\n    \n    b = tracePlane(Plane(vec3(0.0, -5.0, 0.0), vec3(0.0, 1.0, 0.0)), r, o) || b;\n    \n    s = makeSphere(vec3(0.0), 2.0);\n    b = traceSphere(s, r, o) || b;\n    \n    const float count = 4.0;\n    const int spherecount = 8;\n    const float sizedec = 0.9;\n    const float speeddec = 1.15;\n    float d = PI/(count/2.0);\n    \n    for(float i = 0.0; i < count; ++i)\n    {\n        float size = 0.5;\n    \tfloat speed = 0.5;\n        for(float j = 0.0; j < float(spherecount); ++j)\n        {\n        \ts = makeSphere((4.0 + j*1.0) * vec3(cos(time * speed + i*d), \n                                                0.0, \n                                                sin(time * speed + i*d)), size);\n        \tb = traceSphere(s, r, o) || b;\n            size *= sizedec;\n            speed *= speeddec;\n        }\n    }\n    \n    return b;\n}\n\nbool traceScene(Ray r, inout Output o)\n{\n    return traceScene(r, o, iTime);\n}\n\n#ifndef COOKTORRANCE\n\nvec3 phong(Light li, vec3 p, vec3 rd, vec3 n, in Material mat)\n{   \n    vec3 color = vec3(0.0);\n    vec3 l = li.position - p;\n    \n    #ifdef SPHERE_LIGHT\n    vec3 r = reflect(rd, n);\n    vec3 centerToRay = dot(l,n) * r - l;\n    vec3 closestPoint = l + centerToRay * clamp(li.radius / length(centerToRay), 0.0, 1.0);\n    l = normalize(closestPoint);\n    #else\n    l = normalize(l);\n    #endif\n    \n    float lambertTerm = dot(n,l);\n    if(lambertTerm > 0.0)\n    {\t\t\n        // Diffuse Term\n        color += li.color * mat.diffuse * lambertTerm;\t\n\n        // Specular Term\n        if(mat.specular > 0.0)\n        {\n            vec3 e = normalize(rd);\n            vec3 r = reflect(l, n);\n            float specular = pow( max(dot(r, e), 0.0), mat.specular);\n            color += li.color * specular;\n        }\n    }\n    \n    return color;\n}\n\nvec3 phong(vec3 p, vec3 rd, vec3 n, in Material mat)\n{\n    vec3 color = mat.diffuse; // \"Ambiant\" Term\n    \n    for(int i = 0; i < LIGHTS_COUNT; ++i)\n    {\n    \tcolor += phong(Lights[i], p, rd, n, mat);\n    }\n    return color;\n}\n\n#else\n\n// FROM http://ruh.li/GraphicsCookTorrance.html\nvec3 cookTorrance(Light li, vec3 p, vec3 rd, vec3 n, in Material m)\n{\n    // set important material values\n    float roughnessValue = m.roughness; // 0 : smooth, 1: rough\n    float F0 = m.fresnelReflectance; // fresnel reflectance at normal incidence\n    float k = m.diffuseReflection; // fraction of diffuse reflection (specular reflection = 1 - k)\n    vec3 lightColor = li.color;\n    \n    // interpolating normals will change the length of the normal, so renormalize the normal.\n    vec3 normal = normalize(n);\n    \n    vec3 lightDirection = li.position - p;\n       \n    #ifdef SPHERE_LIGHT\n    vec3 r = reflect(rd, n);\n    vec3 centerToRay = dot(lightDirection, n) * r - lightDirection;\n    vec3 closestPoint = lightDirection + centerToRay * clamp(li.radius / length(centerToRay), 0.0, 1.0);\n    lightDirection = normalize(closestPoint);\n    #else\n    lightDirection = normalize(l);\n    #endif\n    \n    // do the lighting calculation for each fragment.\n    \n    float NdotL = max(dot(normal, lightDirection), 0.000001);\n    \n    float specular = 0.0;\n    if(NdotL > 0.0)\n    {\n        vec3 eyeDir = normalize(-rd);\n\n        // calculate intermediary values\n        vec3 halfVector = normalize(lightDirection + eyeDir);\n        float NdotH = max(dot(normal, halfVector), 0.000001); \n        float NdotV = max(dot(normal, eyeDir), 0.000001); // note: this could also be NdotL, which is the same value\n        float VdotH = max(dot(eyeDir, halfVector), 0.0);\n        float mSquared = roughnessValue * roughnessValue;\n        \n        // geometric attenuation\n        float NH2 = 2.0 * NdotH;\n        float g1 = (NH2 * NdotV) / VdotH;\n        float g2 = (NH2 * NdotL) / VdotH;\n        float geoAtt = min(1.0, min(g1, g2));\n     \n        // roughness (or: microfacet distribution function)\n        // beckmann distribution function\n        float r1 = 1.0 / ( 4.0 * mSquared * pow(NdotH, 4.0));\n        float r2 = (NdotH * NdotH - 1.0) / (mSquared * NdotH * NdotH);\n        float roughness = r1 * exp(r2);\n        \n        // fresnel\n        // Schlick approximation\n        float fresnel = pow(1.0 - VdotH, 5.0);\n        fresnel *= (1.0 - F0);\n        fresnel += F0;\n        \n        specular = (fresnel * geoAtt * roughness) / (NdotV * NdotL * 3.14);\n    }\n    \n    return lightColor * NdotL * (k + specular * (1.0 - k));\n}\n\nvec3 cookTorrance(vec3 p, vec3 rd, vec3 n, in Material m)\n{\n    vec3 color = m.diffuse;\n    \n    for(int i = 0; i < LIGHTS_COUNT; ++i)\n    {\n    \tcolor += cookTorrance(Lights[i], p, rd, n, m);\n    }\n    \n    return color;\n}\n\n#endif\n\nvec3 background(in vec3 d)\n{\n    return texture(iChannel0, d).rgb;\n}\n\nfloat falloff( float r, float R)\n{\n\tfloat x = clamp(r / R, 0.0, 1.0);\n\tfloat y = (1.0 - x * x);\n\treturn y * y * y;\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid sparkle(out vec3 c, vec2 center, vec2 tmp, float offset)\n{\n    vec2 v;\n    vec2 v1 = (tmp - center) * vec2(6.0/PI, 1.0);\n    vec2 v2 = (1.0 - tmp - center) * vec2(6.0/PI, 1.0);\n\n    float l = length(v1); \n    if(length(v2) < l)\n    {\n        l = length(v2);\n        v = v2;\n    } else {\n        v = v1;\n    }\n\n    if(l < 0.06 && (l/0.1 - mod(iTime + offset, 1.0)) > 0.0 &&\n       (l/0.1 - mod(iTime + offset, 1.0)) < 0.15)\n        c = vec3(1.0 - 10.0 * l);\n}\n\nvec3 diffuse(inout Output o)\n{\n    if(o.m.type == 0)\n    {\n        const float str = 0.5;\n        vec3 c = str * texture(iChannel1, o.m.uv).xyz;\n        \n        #ifdef BLUE_BACK\n        vec2 tmp = sphereUV(o.p, o.m.infos.xyz);\n        if(length(tmp - vec2(0.32, 0.45)) > 0.1 && dot(c, c) > (str * str * 0.8) * 3.0)\n        {\n            c = vec3(0.11, 0.22, 0.48) * 0.8 + 0.2 * texture(iChannel3, tmp).xxx;\n            \n            #ifdef HORRIBLE_SPARKLES\n            for(float i = 0.0; i < 3.0; ++i)\n            \tfor(float j = 0.0; j < 3.0; ++j)\n            \t\tsparkle(c, vec2(rand(vec2(i + 64.0, j)), rand(vec2(j + 53.0, i))), tmp, rand(vec2(i, j)));\n       \t\t#endif\n        }\n        #endif\n        \n        return c;\n        \n        //return 0.3 * texture(iChannel1, sphereUV(o.p, o.infos.xyz)).xyz;\n    } else if(o.m.type == 1) {\n        return 0.5 * texture(iChannel2, o.m.uv).xyz;\n    } else {\n        return vec3(1.0, 0.0, 0.0);\n    }\n}\n\nvec3 shadow(in Ray r, in Output o)\n{\n    vec3 add = o.m.diffuse;\n    for(int i = 0; i < LIGHTS_COUNT; ++i)\n    {\n        Ray shadowray;\n        Output shadowoutput;\n        vec3 l = Lights[i].position - o.p;\n        \n        #ifdef SPHERE_LIGHT\n        vec3 re = reflect(r.d, o.n);\n        vec3 centerToRay = dot(l, o.n) * re - l;\n        vec3 closestPoint = l + centerToRay * clamp(Lights[i].radius / length(centerToRay), 0.0, 1.0);\n    \tl = normalize(closestPoint);\n        #else\n        l = normalize(l);\n        #endif\n        \n        shadowray.o = o.p + 0.01 * l;\n        shadowray.d = l;\n        shadowray.m = 100.0;\n        shadowoutput.d = length(Lights[i].position - o.p);\n        if(!traceScene(shadowray, shadowoutput))\n        {\n            add += phong(Lights[i], o.p, r.d, o.n, o.m);\n        }\n    }\n    return add;\n}\n\nvec3 getColor(in Ray r, inout Output o)\n{\n    if(o.m.type == 0)\n    {\n        o.m.uv = sphereUV(o.p, o.m.infos.xyz);\n        \n        // Nyan!\n        float frame = floor(mod(12.0 * iTime, 6.0));\n        o.m.uv.x = clamp(clamp(2.0 * o.m.uv.x * 40.0 / 256.0, 0.0, 1.0) + frame * 40.0/256.0, frame * 40.0 / 256.0, (frame + 1.0) * 40.0 / 256.0);\n        o.m.uv.y = 1.0 - o.m.uv.y;\n\n        #ifdef NORMALMAPPING_TEST\n        // Nyan! Normal Mapping! (Or Not.)\n        o.n = tangentToWorldSpace(normal(o.m.uv, iChannel1, vec2(256.0, 32.0), 2.0), o.n);\n        #endif\n    } else if(o.m.type == 1) {\n        o.m.uv = vec2(0.5) + o.p.xz / 30.0;\n\n        #ifdef NORMALMAPPING_TEST\n        o.n = tangentToWorldSpace(normal(o.m.uv, iChannel2, vec2(512.0), 20.0).xyz, o.n);\n        #endif\n    }\n    \n    o.m.diffuse = diffuse(o);\n    \n    #ifdef SHADOW\n    return shadow(r, o);\n    #else\n    return phong(o.p, r.d, o.n, o.m);\n    #endif\n}\n\nvec3 trace(Ray r, float time)\n{\n    vec3 rgb = vec3(0.0);\n    \n    #ifdef SHOW_LIGHT\n    Output outlight;\n    float minl = 100.0;\n    for(int i = 0; i < LIGHTS_COUNT; ++i)\n    {\n    \toutlight.d = 100.0;\n        #ifdef SPHERE_LIGHT\n        float radius = Lights[i].radius;\n        #else\n        const float radius = 0.3;\n        #endif\n        \n        Sphere Light = makeSphere(Lights[i].position, radius);\n        if(traceSphere(Light, r, outlight))\n        {\n            float d = abs(dot(r.d, outlight.n));\n            rgb += Lights[i].color * d * d * d;\n        }\n        \n        minl = min(minl, outlight.d);\n    }\n\t#endif\n    \n    Output o;\n    o.d = 100.0;\n    if(traceScene(r, o, time))\n    {\n        #ifdef SHOW_LIGHT\n        if(o.d < minl) rgb = vec3(0.0);\n        #endif \n\n        rgb += getColor(r, o);\n\n        #ifdef REFLEXION\n        // Could use Cook-Torrance parameters\n        // and some kind of blur based on them...\n        if(o.m.reflectivity > 0.0)\n        {\n            Ray refray;\n            refray.d = reflect(r.d, o.n);\n            refray.o = o.p + 0.01 * refray.d;\n            refray.m = 100.0;\n            Output refout;\n            refout.d = 100.0;\n            if(traceScene(refray, refout, time))\n            {\n                rgb += o.m.reflectivity * getColor(refray, refout);\n            } else {\n                rgb += o.m.reflectivity * background(refray.d);\n            }\n        }\n        #endif\n    } else {\n        rgb += background(r.d);\n    } \n\t\n    return rgb;\n}\n\nvec3 trace(Ray r)\n{\n    return trace(r, iTime);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pixel = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    \n    #if LIGHTS_COUNT > 0\n    Lights[0].color = vec3(1.0, 0.5, 0.5);\n    Lights[0].position = 4.5 * vec3(cos(iTime), cos(1.2 * iTime), sin(iTime));\n    #ifdef SPHERE_LIGHT\n    Lights[0].radius = LightDefaultRadius;\n    #endif\n    #endif\n    \n    #if LIGHTS_COUNT > 1\n    Lights[1].color = vec3(0.8, 1.0, 0.8);\n    Lights[1].position = 4.5 * vec3(cos(0.5*iTime), sin(2.0 * iTime), sin(0.5*iTime));\n    Lights[1].position.xz *= 1.5;\n    #ifdef SPHERE_LIGHT\n    Lights[1].radius = LightDefaultRadius;\n    #endif\n    #endif\n    \n    #if LIGHTS_COUNT > 2\n    Lights[2].color = vec3(0.8, 0.8, 1.0);\n    Lights[2].position = 4.5 * vec3(cos(0.8*iTime), 0.8 * sin(3.0 * iTime), sin(0.8*iTime));\n    Lights[2].position.xz *= 2.0;\n    #ifdef SPHERE_LIGHT\n    Lights[2].radius = LightDefaultRadius;\n    #endif\n    #endif\n    \n\tfloat asp = iResolution.x / iResolution.y;\n\tRay r;\n    r.m = 100.0;\n\tr.d = normalize(vec3(asp * pixel.x, pixel.y, -5.0));\n\tr.o = vec3(0.0, 0.0, 30.0);\n    \n    vec2 um = (iMouse.xy / iResolution.xy-.5);\n    um.x *= 8.0;\n    um.y = clamp(um.y, -0.5, 0.1);\n\tr.o = rotateX(r.o, um.y);\n\tr.d = rotateX(r.d, um.y);\n\tr.o = rotateY(r.o, um.x);\n\tr.d = rotateY(r.d, um.x);\n    \n    vec3 rgb = vec3(0.0);\n    \n    #ifdef MULTISAMPLING\n    //TODO\n    vec3 rd = r.d;\n    r.d += dFdx(r.d)/2.0;\n    r.d = normalize(r.d);\n    for(int i = 0; i < SAMPLES; i++)\n    {\n        for(float j = 0.0; j < MOTIONBLUR_SAMPLES; ++j)\n        {\n        \trgb += trace(r, iTime - 0.005 * j) / MOTIONBLUR_SAMPLES / float(SAMPLES);\n        }\n        r.d *= mat3(rot(rd, 2.0 * PI / float(SAMPLES)));\n    }\n    #else\n    for(float j = 0.0; j < MOTIONBLUR_SAMPLES; ++j)\n    {\n        rgb += trace(r, iTime - 0.005 * j) / MOTIONBLUR_SAMPLES;\n    }\n    #endif\n    \n    // Nice transitions <3\n    #ifdef GAMMA\n    float Duration = 2.0;\n    float x = falloff(mod(iTime, Duration), 1.0);\n    float phase = mod(iTime, 4.0 * Duration);\n    if(phase < Duration)\n        x = x - 1.0;\n    else if(phase < 2.0 * Duration)\n        x = - x;\n    else if(phase < 3.0 * Duration)\n        x = 1.0 - x;\n    else if(phase > 3.0 * Duration)\n        x = x;\n\n    if(pixel.x > x)\n        rgb = pow(rgb, 1.0 / Gamma);\n    #endif    \n        \n   \tfragColor.rgb = rgb;\n    fragColor.a = 1.0;\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldjSzV","date":"1414234693","viewed":313,"name":"RayTracing Nyan!","username":"Senryoku","description":"Just playing with raytracing (learning purpose).\nRayTracing, Brute force Motion Blur (really brutal...), well, everything is pretty rough...\nAny input is more than welcome!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","lighting","motionblur","shadows","reflections","multisampling"],"hasliked":0,"parentid":"","parentname":""}}