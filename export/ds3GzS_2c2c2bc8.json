{"ver":"0.1","info":{"id":"ds3GzS","date":"1677473079","viewed":186,"name":"Sunshine flight","username":"ianertson","description":"Use the mouse to look around :)","likes":11,"published":1,"flags":48,"usePreview":1,"tags":["3d","raytracing","raytracing","raymarching","terrain","raymarch","rays","airplane","pbr","flight","flying"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 getColor(vec2 uv) { return texture(iChannel0, uv).rgb; }\n\n\nvec3 blurx(vec2 uv) {\n  vec3 col = vec3(0.0);\n  const int filterSize = 8;\n  const int halfFilterSize = filterSize / 2;\n\n  const int start = -halfFilterSize;\n  const int end = -halfFilterSize + filterSize;\n\n  float shadow = 0.0;\n  vec2 texelSize = 1.0 / vec2(textureSize(iChannel0, 0).xy);\n  int count = 0;\n  for(int x = start; x < end; ++x)\n  {\n      for(int y = start; y <= end; ++y)\n      {\n         vec3 next = texture(iChannel0, uv + (vec2(x, y) * texelSize)).rgb;\n         col += next;\n         count += 1;\n      }\n  }\n\n  col /= float(count);\n  return col;\n}\n\n\nfloat estimateNoise(vec3 col, vec2 uv) {\n    vec2 e = vec2(1.0) / R.xy;\n    vec3 a = vec3(\n        luma(getColor(uv + vec2(e.x, 0))),\n        luma(getColor(uv + vec2(0, e.y))),\n        luma(getColor(uv + vec2(e.x, e.y)))\n    );\n    \n    float l = luma(col);\n    float n1 = abs(l - ((a.x+a.y+a.z)/3.));\n    float n2 = abs(a.x - a.y);\n    float n3 = abs(a.x - a.z);\n    float n4 = abs(a.y - a.z);\n    float n5 = fwidth(l);\n    \n    float n = (n1+n2+n3+n4+n5)/5.0;\n    return clamp(n*M_PI, 0.0, 1.0);\n}\n\nvec3 shade(vec2 uv) {\n    vec3 col = getColor(uv);\n    float depth = texture(iChannel0, uv).a;\n    float noiseEst = estimateNoise(col, uv);\n    \n    vec3 smo = blurx(uv);\n    col = mix(col, smo, clamp(smoothstep(0.3, 1.0, depth), 0.0, 0.9));\n    col = mix(col, smo, noiseEst*noiseEst);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = fc/R.xy;\n    \n    col = shade(uv);\n    \n    O = vec4(clamp(col, 0.0, 1.0), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define R (iResolution.xy)\n#define T (iFrame <= 1 || iTime <= 0.0002 ? 14.25 : iTime)\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n#define SAMPLE(var, id_) if (var < dist) { id = id_; dist = var; }\n#define TEXTURE_SIGNATURE in vec2 uv, in vec3 p, inout Material m\n\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nmat2 rot(float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\nvec3 fixNormal(vec3 wn, vec3 n, float mixf) {\n    vec3 t = cross(wn, vec3(0, 1, 0));\n    vec3 b = vec3(0.0);\n    if (abs(length(t)) == 0.0) t = cross(wn, vec3(0, 0, 1));\n    t = normalize(t);\n    b = normalize(cross(wn, t));\n    mat3 tbn = mat3(t, b, -wn);\n    n = normalize((tbn)*n);\n    return normalize(mix(wn, n, mixf*max(0.1, dot(wn, n))));\n}\n\nstruct Object {\n    vec3 p;\n    vec4 q;\n};\n\n#define NEW_OBJECT Object(vec3(0.0), vec4(0, 0, 0, 1))\n\nstruct Material {\n    float rough;\n    float spec;\n    float metallic;\n};\n\n#define NEW_MATERIAL Material(1.0, 1.0, 0.0)\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    vec2 uv;\n    float d;\n    int id;\n    Material m;\n    Object o;\n};\n\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), vec2(0.0), FAR, 0, NEW_MATERIAL, NEW_OBJECT)\n\nstruct Light {\n    vec3 p;\n    vec3 d;\n    vec3 c;\n    float s;\n    int type;\n};\n\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n\nvec3 getLightDir(in Light light, in vec3 p) {\n    switch (light.type) {\n        case LIGHT_AMBIENT: return normalize(light.p); break;\n        case LIGHT_POINT: return normalize(light.p - p); break;\n        case LIGHT_DIR: return normalize(light.d); break;\n    }\n    return vec3(0.0);\n}\n\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = cdot(n, L);\n    \n    switch (light.type) {\n        case LIGHT_AMBIENT: return light.c * NdotL * light.s; break;\n        case LIGHT_POINT: return light.c * NdotL *\n            (pow(light.s, 2.0) / max(0.001, pow(distance(light.p, p), 2.0))); break;\n        case LIGHT_DIR: return light.c * light.s * smoothstep(0.8, 1.0, dot(\n            normalize(light.p - p),\n            L\n        ));break;\n    }\n    \n    return vec3(0.0);\n}\n\nvec2 boxUv(in vec3 p, in vec3 n) {\n    vec2 uv = vec2(0.0);\n    uv = mix(uv, p.xy, round(adot(n, vec3(0, 0, 1))));\n    uv = mix(uv, p.xz, round(adot(n, vec3(0, 1, 0))));\n    uv = mix(uv, p.zy, round(adot(n, vec3(1, 0, 0))));\n    return uv;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return smin(a, b, -k);\n}\n\nvec3 smin(vec3 a, vec3 b, float k) {\n    vec3 h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nvec3 smax(vec3 a, vec3 b, float k) {\n    return smin(a, b, -k);\n}\n\nfloat sclamp(float v, float mi, float ma, float k) {\n    return smax(mi, smin(ma, v, k), k);\n}\n\nfloat sabs(float a, float k) {\n    return smax(-a, a, k);\n}\n\nvec3 smix(vec3 a, vec3 b, float fa, float fb, float k) {\n return mix(\n      a * smoothstep(0., max(fb-fa, 0.0), fa),\n      b * smoothstep(0., max(fa-fb, 0.0), fb),\n      k\n  );\n}\n\nvec3 pointMat(vec3 p, mat4 m) {\n    return (vec4(p, 1.0) * m).xyz;\n}\nvec3 pointQuat(vec3 v, vec4 q){ \n\treturn v + 2.0*cross(cross(v, q.xyz ) + q.w*v, q.xyz);\n}\n\nmat4 quatMat(vec4 q)\n{\n    float xx = q.x * q.x;\n    float xy = q.x * q.y;\n    float xz = q.x * q.z;\n    float xw = q.x * q.w;\n\n    float yy = q.y * q.y;\n    float yz = q.y * q.z;\n    float yw = q.y * q.w;\n\n    float zz = q.z * q.z;\n    float zw = q.z * q.w;\n\n    mat4 result = mat4(1.0);\n    result[0][0] = 1.0 - 2.0 * (yy + zz);\n    result[1][0] = 2.0 * (xy - zw);\n    result[2][0] = 2.0 * (xz + yw);\n    result[3][0] = 0.0;\n\n    result[0][1] = 2.0 * (xy + zw);\n    result[1][1] = 1.0 - 2.0 * (xx + zz);\n    result[2][1] = 2.0 * (yz - xw);\n    result[3][1] = 0.0;\n\n    result[0][2] = 2.0 * (xz - yw);\n    result[1][2] = 2.0 * (yz + xw);\n    result[2][2] = 1.0 - 2.0 * (xx + yy);\n    result[3][2] = 0.0;\n\n    result[0][3] = 0.0;\n    result[1][3] = 0.0;\n    result[2][3] = 0.0;\n    result[3][3] = 1.0;\n\n    return result;\n}\n\nvec4 quatFor(vec3 dir, vec3 up)\n{\n    if (abs(length(dir)) <= 0.000002) return vec4(0, 0, 0, 1);\n    vec3 axis = normalize(cross(up, dir));\n    float angle = acos(dot(dir, up));\n    float halfAngle = angle * 0.5;\n    float s = sin(halfAngle);\n    vec4 q = vec4(axis * s, cos(halfAngle));\n    return normalize(q);\n}\nvec4 quatMul(vec4 q1, vec4 q2) {\n    vec4 q = vec4(0, 0, 0, 1);\n    q.x = (q1.w * q2.x) + (q1.x * q2.w) + (q1.y * q2.z) - (q1.z * q2.y);\n    q.y = (q1.w * q2.y) - (q1.x * q2.z) + (q1.y * q2.w) + (q1.z * q2.x);\n    q.z = (q1.w * q2.z) + (q1.x * q2.y) - (q1.y * q2.x) + (q1.z * q2.w);\n    q.w = (q1.w * q2.w) - (q1.x * q2.x) - (q1.y * q2.y) - (q1.z * q2.z);\n    return normalize(q);\n}\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n    vec3 camForward = normalize(point - ro);\n    vec3 camRight = -normalize(cross(camForward, vec3(0, 1, 0)));\n    vec3 camUp = -normalize(cross(camRight, camForward));\n    vec3 screenCenter = ro + camForward * 1.;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\n\nfloat notzero(float v) {\n  return (abs(v) <= 0.0 ? 0.001 : v);\n}\n\nvec3 notzero(vec3 v) {\n\n  return vec3(notzero(v.x), notzero(v.y), notzero(v.z));\n}\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = M_PI * denom * denom;\n\n    return nom / notzero(max( denom, 0.000001 ));\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) *\n                  pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\n\n\nvec3 EnvBRDFApprox(vec3 specularColor, float roughness, float ndotv) {\n  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * ndotv)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  return specularColor * AB.x + AB.y;\n}\n\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nfloat GeometrySchlickGGX(float NdotV, float k)\n{\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / notzero(denom);\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float k)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx1 = GeometrySchlickGGX(NdotV, k);\n    float ggx2 = GeometrySchlickGGX(NdotL, k);\n\n    return ggx1 * ggx2;\n}\n\nfloat microfacetDistribution(float roughness, float NdotH)\n{\n    float roughnessSq = roughness * roughness;\n    float f = (NdotH * roughnessSq - NdotH) * NdotH + 1.0;\n    return roughnessSq / notzero((M_PI * f * f) + 0.00001);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// taken from https://www.shadertoy.com/view/ldGGzV\n\n#define MOVE_SPEED 10.\n#define PI 3.14159\n\nconst float KEY_W = 87.5 / 256.0;\nconst float KEY_A = 65.5 / 256.0;\nconst float KEY_S = 83.5 / 256.0;\nconst float KEY_D = 68.5 / 256.0;\nconst float KEY_SHIFT = 16.0;\nconst float KEY_SPACE = 32.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = texture(iChannel1, vec2(0.)).xyz;\n    if(iFrame == 0) pos = vec3(0.,0.,0.);\n    \n    switch (int(fragCoord.x)) {\n        case 0: {\n            float mx = iMouse.xy == vec2(0.) ? 0. : ((iMouse.x / iResolution.x) * 2. - 1.) * 360.;\n            float speed = MOVE_SPEED * iTimeDelta;\n\n            speed *= 1.; //+ 2. * texture(iChannel0,vec2(KEY_SHIFT,0.)).r;\n\n            speed *= 3.0;\n\n            float forwardBackward =\n            texture(iChannel0, vec2(KEY_W, 0.)).r -\n            texture(iChannel0, vec2(KEY_S, 0.)).r;\n\n            float leftRight =\n            texture(iChannel0, vec2(KEY_A, 0.)).r -\n            texture(iChannel0, vec2(KEY_D, 0.)).r;\n\n            float s = sin(radians(mx));\n            float c = cos(radians(mx));\n\n            pos.x += speed * (forwardBackward * s - leftRight * c);\n            pos.z += speed * (forwardBackward * c + leftRight * s);\n        \n        }; break;\n        case 1: {\n            pos = texelFetch(iChannel1, ivec2(1, 0), 0).xyz;\n            float space = texelFetch(iChannel0, ivec2(KEY_SPACE, 0), 0).r;\n            float shift = texelFetch(iChannel0, ivec2(KEY_SHIFT, 0), 0).r;\n            \n            pos.y += space * 0.2;\n            pos.y -= shift * 0.2;\n        \n        }; break;\n    }\n    \n    \n    \n    fragColor = vec4(pos, 0.);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define NEAR 0.003\n#define FAR 100.0\n#define STEPS 100\n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_BOX 2\n\n#define ID_CRAFT_BODY 3\n#define ID_CRAFT_WING 4\n#define ID_CRAFT_NOSE 5\n#define ID_CRAFT_ENGINE 6\n\n#define WALK 0\n\n#define CENTER vec3(16, 20., 16)\n\n#define FLY_TIME (T * 10.)\n\nObject getCraft() {\n  vec3 p = vec3(0., 4., 0.) + CENTER;\n  p.z += FLY_TIME;\n  vec4 q = vec4(0, 0, 0, 1);\n\n  float a = radians(-45.);\n  q = vec4(0, sin(a), 0, cos(a));\n\n  float ang = radians(mix(-5., 5., 0.5 + (0.5 * sin(T))));\n\n  vec4 q2 = vec4(0., 0., sin(ang), cos(ang));\n\n  q = quatMul(q2, q);\n\n  return Object(p, q);\n}\n\nfloat rand(in vec2 p, in float seed) {\n  vec2 p2 = fract((p + seed) * 10.0238123) * 24.982815;\n  float r1 = fract(dot(p, p2));\n  return fract(cos((r1 + seed) * 6.23938) *\n               dot(p, vec2(24.9382815, 33.29381215)));\n}\n\nvec3 hash(in vec2 p, in float seed) {\n  return textureLod(iChannel3, (p + (seed * 5.019923156)) / 256., 0.0).xyz;\n}\n\nvec3 snoise(in vec2 p, in float seed) {\n  vec2 id = floor(p);\n  vec2 lv = fract(p);\n  lv = lv * lv * (3.0 - 2.0 * lv);\n\n  return mix(\n      mix(hash(id, seed), hash(id + vec2(1, 0), seed), lv.x),\n      mix(hash(id + vec2(0, 1), seed), hash(id + vec2(1, 1), seed), lv.x),\n      lv.y);\n}\n\nvec3 snoise(in vec2 p, in float seed, in float freq) {\n  float div = 0.0;\n  float amp = 1.0;\n  vec3 n = vec3(0.0);\n#define ADV                                                                    \\\n  n += amp * snoise(p * freq, seed);                                           \\\n  div += amp;                                                                  \\\n  amp /= 2.0;                                                                  \\\n  freq *= 2.0;\n  ADV;\n  ADV;\n  ADV;\n  ADV;\n#undef ADV\n  return n / div;\n}\n\nvec3 snoise6(in vec2 p, in float seed, in float freq) {\n  float div = 0.0;\n  float amp = 1.0;\n  vec3 n = vec3(0.0);\n#define ADV                                                                    \\\n  n += amp * snoise(p * freq, seed);                                           \\\n  div += amp;                                                                  \\\n  amp /= 2.0;                                                                  \\\n  freq *= 2.0;\n  ADV;\n  ADV;\n  ADV;\n  ADV;\n  ADV;\n  ADV;\n#undef ADV\n  return n / div;\n}\n\nvec3 noise(in vec2 p, in float seed, in float freq) {\n  float div = 0.0;\n  float amp = 1.0;\n  vec3 n = vec3(0.0);\n#define ADV                                                                    \\\n  n += amp * hash(p * freq, seed);                                             \\\n  div += amp;                                                                  \\\n  amp /= 2.0;                                                                  \\\n  freq *= 2.0;\n  ADV;\n  ADV;\n  ADV;\n  ADV;\n#undef ADV\n  return n / div;\n}\n\nvec3 noise6(in vec2 p, in float seed, in float freq) {\n  float div = 0.0;\n  float amp = 1.0;\n  vec3 n = vec3(0.0);\n#define ADV                                                                    \\\n  n += amp * hash(p * freq, seed);                                             \\\n  div += amp;                                                                  \\\n  amp /= 2.0;                                                                  \\\n  freq *= 2.0;\n  ADV;\n  ADV;\n  ADV;\n  ADV;\n  ADV;\n  ADV;\n#undef ADV\n  return n / div;\n}\n\nfloat cylSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n  vec3 ab = b - a;\n  vec3 ap = p - a;\n  float t = dot(ab, ap) / dot(ab, ab);\n  vec3 c = a + t * ab;\n  float x = length(p - c) - r;\n  float y = (abs(t - 0.5) - 0.5) * length(ab);\n  float e = length(max(vec2(x, y), 0.0));\n  float i = min(max(x, y), 0.0);\n  return e + i;\n}\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n  p = abs(p) - s;\n  return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat sphereSDF(in vec3 p, in float r) { return length(p) - r; }\n\nfloat coneSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n\n  vec3 dir = normalize(b - a);\n  float len = length(b - a);\n\n  r *= max(0.0, 1.0 - clamp(dot(p, b), 0.0, 1.0));\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  float l = length(pa - ba * h) - r;\n\n  float d = l;\n\n  vec3 pp = p * len * dir;\n  d = max(d, -(min(p.y * dir.y, min(p.x * dir.x, p.z * dir.z))) - 0.02);\n\n  return d;\n}\n\nfloat groundSDF(in vec3 p) {\n  if (p.y >= 32.)\n    return p.y;\n    \n  p.y += 1.1;\n  vec3 base = snoise6(p.xz, 0.842165, 0.4);\n  vec3 mountains = snoise6(p.xz, 2.222315, 0.05);\n  float valleys = pow(base.y, 2.0) * 3.;\n\n  float h = 0.0;\n\n  float m = pow((mountains.x + mountains.y + mountains.z) / 3., 4.0) * 3.;\n\n  h += smoothstep(0.3, 4.0, m * 7.) * 20.;\n  h -= smoothstep(0.1, 4.0, valleys) * 4.;\n\n  float d = p.y - h * 0.8;\n  return d / 2.2;\n}\n\nfloat craftSDF(in vec3 point, inout int id) {\n  float dist = FAR;\n  float body = FAR;\n  float wing = FAR;\n  float tailWing = FAR;\n  float engine = FAR;\n\n  Object craft = getCraft();\n\n  point = pointQuat(point, craft.q);\n\n  vec3 siz = vec3(10., vec2(1.));\n\n  {\n    vec3 size = siz;\n    vec3 p = point;\n\n    float tail = smoothstep(1., 4.0, max(0.0, -p.x - 2.));\n    p.y -= tail * 2.;\n    size.y -= tail / 1.6;\n    size.y = smoothstep(4.0, 0.5, max(0.0, -p.x / 2.));\n\n    body = cylSDF(p - vec3(-size.x / 2., size.y, 0), vec3(0, 0, 0),\n                  vec3(size.x, 0, 0), size.y);\n    float head = coneSDF(p - vec3(size.x / 2., size.y, 0.), vec3(0, 0, 0),\n                         vec3(0.7, 0, 0), size.y);\n\n    float taper =\n        smoothstep(0.5, 6., max(0.0, abs(p.y) - max(0.0, -p.x / 2.))) * 0.8;\n    body -= taper;\n    head -= taper;\n\n    body = smin(body, head, 0.01);\n  }\n\n  vec3 wingSize = vec3(1.2, 0.16, 2.7);\n\n  {\n    vec3 size = siz;\n    vec3 p = point;\n    p.z = abs(p.z);\n    p.x -= 0.5;\n\n    wingSize.x = smoothstep(10.0, 1.5, p.z);\n    p.x += smoothstep(0.0, 9.0, abs(p.z)) * 2.;\n\n    wing = boxSDF(p - vec3(0., wingSize.y + size.y / 2.,\n                           abs(-(size.z + wingSize.z))),\n                  wingSize) -\n           0.05;\n  }\n\n  {\n    vec3 size = siz;\n    vec3 p = point;\n\n    vec3 wingSize = vec3(1.0, 0.86, 0.2);\n    p.y -= smoothstep(0., 10.0, -p.x) * 2.;\n    p.y += 1.;\n    p.x -= 0.49;\n    wingSize.y -= smoothstep(-6., 0.0, p.x);\n\n    tailWing = boxSDF(p - vec3((-(size.x / 2.)) + wingSize.x / 2.,\n                               size.y + wingSize.y * 2., 0.),\n                      wingSize) -\n               0.06;\n  }\n\n  {\n    vec3 size = siz;\n    vec3 p = point;\n    p.z = abs(p.z);\n    float engineR = 0.7;\n    vec3 enginePos = vec3(0, (size.y / 2.) - engineR, abs(-wingSize.z));\n    engine = cylSDF(p - enginePos, vec3(0, 0, 0), vec3(1, 0, 0), engineR);\n\n    engine = mix(engine, sphereSDF(p - enginePos, engineR),\n                 smoothstep(0.1, 2.0, max(0.0, -p.x + 1.)));\n\n    float engineHole =\n        sphereSDF((p - enginePos) - vec3(0.6, 0.0, 0.0), engineR * 0.9);\n\n    engine = smax(engine, -engineHole, 0.05);\n  }\n\n  body = smin(body, tailWing, 0.4);\n  SAMPLE(body, ID_CRAFT_BODY);\n  SAMPLE(wing, ID_CRAFT_WING);\n  SAMPLE(tailWing, ID_CRAFT_WING);\n  SAMPLE(engine, ID_CRAFT_ENGINE);\n\n  return dist / 1.1;\n}\n\nfloat getDist(inout Data data, in vec3 p) {\n  // p -= CENTER;\n  float dist = FAR;\n  int id = ID_NONE;\n\n  float ground = groundSDF(p);\n  //  float box = boxSDF(p-vec3(0, 0.5, 0), vec3(0.5));\n  int craftId = 0;\n  Object oCraft = getCraft();\n  float craft = craftSDF(p - oCraft.p, craftId);\n\n  SAMPLE(ground, ID_GROUND);\n  // SAMPLE(box, ID_BOX);\n\n  if (craft <= dist) {\n    data.o = oCraft;\n  } else {\n    data.o = NEW_OBJECT;\n  }\n  SAMPLE(craft, craftId);\n\n  data.id = id;\n\n  return dist;\n}\n\nbool march(inout Data data, in vec3 ro, in vec3 rd) {\n  float dist = 0.0;\n\n  for (int i = ZERO; i < STEPS; i++) {\n    vec3 p = ro + rd * dist;\n    float next = getDist(data, p);\n    dist += next;\n    if (abs(next) <= (NEAR * (1.0 + dist * 0.5)))\n      break;\n    if (abs(dist) >= FAR)\n      return false;\n  }\n\n  vec3 p = ro + rd * dist;\n  vec2 e = vec2(data.id == ID_GROUND ? 0.1 : 0.001, 0.0);\n  vec3 n = normalize(getDist(data, p) - vec3(getDist(data, p - e.xyy),\n                                             getDist(data, p - e.yxy),\n                                             getDist(data, p - e.yyx)));\n  data.p = p;\n  data.n = n;\n  data.d = dist;\n  data.uv = boxUv(pointQuat(p - data.o.p, data.o.q), pointQuat(n, data.o.q));\n\n  return true;\n}\n\nfloat getShadow(in vec3 ro, in vec3 rd, in float near, in float far) {\n  float dist = 0.0;\n\n  Data data = NEW_DATA;\n  far = min(far, FAR);\n\n  for (int i = ZERO; i < STEPS; i++) {\n    vec3 p = ro + rd * dist;\n    float next = getDist(data, p);\n    dist += next;\n    if (abs(next) <= NEAR)\n      break;\n    if (abs(dist) >= far)\n      return 1.0;\n  }\n\n  return clamp(abs(dist) / (0.02 + abs(near)), 0.0, 0.77);\n}\n\n//#define DEBUG_TEXTURE brickTexture\n/*\nvec3 brickTexture(TEXTURE_SIGNATURE) {\n  vec3 col = vec3(0.0);\n\n  float tile = 4.0;\n  vec2 uuv = uv * tile;\n\n  float iy = floor(uuv.y);\n\n  uuv.x += (iy / (tile / 2.));\n\n  vec2 id = floor(uuv);\n  vec2 lv = fract(uuv);\n  vec2 alv = abs(lv * 2.0 - 1.0);\n\n  vec3 c1 = rgb(106, 60, 48);\n  vec3 c2 = rgb(100, 49, 34);\n  vec3 c3 = rgb(137, 88, 86);\n  vec3 c4 = rgb(64, 29, 20);\n  vec3 c5 = rgb(188, 176, 135);\n\n  float r1 = rand(id, 2.92913);\n  float r2 = rand(id * 3.2931, 4.444291);\n  float r3 = rand(id * 6.62235, 9.923354);\n  float r4 = rand(id + r1, r1 + r2 + r3 + 3.3333);\n\n  col = mix(mix(mix(c1, c2, r1), c3, r3), c4, r4);\n\n  vec3 hf = noise6(uv, 3.3291254, 32.0);\n  vec3 lf = noise6(uv / 2., 11.29885, 8.);\n  vec3 grain = textureLod(iChannel3, uv, 0.0).xyz;\n  vec3 hf3 = abs(reflect(cross(grain, hf), lf));\n  vec3 lf2 = abs(abs(lf - hf3) - hf);\n\n  float thick =\n      (((0.01 + (hf.x / 16.) + (lf.z / 24.)) / 2.) + (grain.x / 30.)) *\n      (0.5 + (0.5 * grain.y));\n  float g = max(0.0, floor(max(alv.x, alv.y) + thick));\n\n  float gx = smoothstep(0.4, 0.9, alv.x - 0.2);\n  float gy = smoothstep(0.4, 0.9, alv.y - 0.2);\n  float gs = mix(gx, gy, max(0.0, gy - gx));\n\n  g *= (0.5 + (0.5 * lf.x));\n  gs = mix(gs, gs * grain.y, lf.x);\n\n  col = mix(col, ((c5 + grain.y / 2.)) / 1.3,\n            clamp(g * (hf3.z + hf3.y + hf3.x + (lf.x / 3.)), 0.0, 1.0));\n  col = mix(col, col * col, gs);\n\n  col = mix(col, col * col, hf3.x * lf.y);\n\n  float cracks = smoothstep(0.02, 0.1, lf2.x);\n\n  col = mix(col, col * c5, cracks * grain.x * lf.z);\n\n  m.spec = clamp((g + (gs * 0.3)) + ((pow(cracks, 3.0) * lf.x) / 3.), 0.0, 1.0);\n\n  // return vec3(gs);\n\n  return col;\n}\n*/\n//#define DEBUG_TEXTURE alumTexture\n\nvec3 alumTexture(TEXTURE_SIGNATURE) {\n  vec3 col = vec3(0.0);\n\n  vec3 c1 = rgb(193, 193, 195);\n  vec3 c2 = rgb(236, 236, 236);\n  vec3 c3 = rgb(186, 185, 191);\n  vec3 c4 = rgb(161, 161, 161);\n\n  vec3 mf = noise(uv, 0.837821, 10.0);\n  vec3 hf = noise(uv, 1.289845, 62.0);\n  vec3 lf = snoise6(uv, 0.332156, 0.6);\n  vec3 lf2 = noise6(uv * 0.5, 0.993215, 0.1);\n  vec3 grain = textureLod(iChannel3, uv * 2., 0.0).xyz;\n  vec3 n = abs(normalize(reflect(3.0 * cross(hf, mf), grain)));\n\n  float stripeShift = cos(fract((uv.x + mf.z * 0.25) * 10.) * 6.28) * mf.x;\n  float stripes = fract((uv.y + stripeShift * 0.01) * 48.);\n\n  col = mix(mix(mix(c1, c2, mf.x), c3, mf.y), c4, mf.z);\n\n  col = mix(col, c4 * stripes, (n.x * n.x * n.x) / 6.);\n\n  col = mix(col, vec3(0.989221), (grain.x * grain.x) / 2.);\n\n  vec3 stripeCol = mix(mix(mix(c1, c2, hf.x), c3, hf.y), c4, hf.z);\n\n  col = mix(col, stripeCol * stripes, stripes * lf.x * lf.x * lf.x * lf.x);\n\n  vec3 rust1 = rgb(149, 49, 13);\n  vec3 rust2 = rgb(130, 80, 44);\n  vec3 rust3 = rgb(219, 191, 166);\n  vec3 rust4 = rgb(106, 83, 76);\n  vec3 rust = mix(mix(mix(rust1, rust2, n.x), rust3, n.y), rust4, n.z);\n\n  // rust *= stripeCol*stripes*n.x;\n\n  float rustF = stripes * clamp((n.x + (lf.y * lf.y * lf.y)) *\n                                    pow((lf2.x + lf2.y) * 0.6, 4.0) * 6.,\n                                0.0, 1.0);\n  col = mix(col, rust, rustF);\n  // col += pow(lf.y, 6.0)*9.;\n\n  // col = mix(col, vec3((mf.x+hf.x+lf.x+grain.x+n.x)/5.),\n  // clamp((grain.x*hf.x)*(0.5+(0.5*stripes)), 0.0, 1.0));\n  m.spec = clamp(luma(col) - rustF, 0.0, 1.0);\n  m.rough = clamp((rustF + lf.y) / 2., 0.1, 1.0);\n  m.metallic = luma(col);\n  return clamp(col, 0.0, 1.0);\n}\n\nvec3 forestGrassTexture(TEXTURE_SIGNATURE) {\n  uv += 12.;\n  //  uv *= 2.;\n  vec3 col = vec3(0.0);\n  vec3 grass1 = rgb(96, 108, 51);\n  vec3 grass2 = rgb(49, 67, 26);\n  vec3 grass3 = rgb(127, 138, 77);\n  vec3 grass4 = rgb(155, 156, 98);\n\n  vec3 dirt1 = rgb(147, 128, 111);\n  vec3 dirt2 = rgb(176, 154, 135);\n  vec3 dirt3 = rgb(98, 84, 58);\n  vec3 dirt4 = rgb(109, 91, 71);\n\n  vec3 grain1 = textureLod(iChannel3, uv, 0.0).xyz;\n  vec3 lf = snoise6(uv, 0.3281512, 3.);\n  vec3 region = snoise6(uv, 0.987371, 9.0);\n  vec3 hf = noise6(uv, 1.8234715, 24.0);\n  vec3 grain2 = abs(reflect(grain1, hf));\n\n  vec3 grass = mix(mix(mix(grass1, grass2, grain1.x), grass3, grain1.y), grass4,\n                   grain1.z);\n  vec3 dirt =\n      mix(mix(mix(dirt1, dirt2, grain2.x), dirt3, grain2.y), dirt4, grain2.z);\n\n  grass = mix(grass, grass2, clamp(pow(grain1.x * lf.y, 2.) * 2., 0.0, 1.0));\n\n  float grassR = pow(region.x, 2.);\n  float dirtR =\n      clamp(pow(abs(region.y - region.z) * 2., 2.) + pow(lf.z, 3.0), 0.0, 1.0);\n  dirtR *= max(0.0, 1.0 - (grassR * 0.9));\n\n  dirtR = smoothstep(0.12, 0.2, dirtR);\n\n  grassR *= max(0.0, 1.0 - (dirtR));\n\n  col = mix(grass, dirt * dirtR, max(0.0, dirtR - grassR));\n\n  col = mix(col, col * col, dirtR / 2.);\n\n  vec3 grain3 = abs(cross(grain2, reflect(lf, hf)));\n  col = mix(col, dirt2, pow(clamp(grain3.y * 2. * lf.x, 0.0, 1.0), 2.));\n  col = mix(col, col * col, clamp(abs(lf.z - lf.x) * 2.2, 0.0, 1.0));\n\n  col = mix(col, col * grain1.y, clamp(abs(region.z - lf.y) * 2., 0.0, 1.0));\n\n  m.spec = clamp(max(0.0, (dirtR * grain3.z) - grassR) / 7.,\n                 grain1.x * grain3.y, 1.0) *\n           clamp(lf.z * 3., 0.0, 1.0);\n  return col;\n}\n\nvec3 metalTexture(TEXTURE_SIGNATURE) {\n  vec3 col = vec3(0.0);\n\n  vec3 alt = noise(uv, 5.4591, 9.4);\n  vec3 grain = textureLod(iChannel3, uv * 2., 0.0).rgb;\n\n  vec3 c1 = rgb(77, 103, 132);\n  vec3 c2 = rgb(117, 115, 116);\n  vec3 c3 = rgb(149, 144, 150);\n\n  col = mix(col, c1, pow(alt.x, 2.0));\n  col = mix(col, c2, pow(alt.y, 2.0));\n  col = mix(col, c3, pow(alt.z, 2.0));\n\n  col = mix(col, max(c1, max(c2, c3)), pow(grain.x, 3.0));\n\n  m.spec = alt.x;\n  m.rough = clamp(alt.y + grain.x, 0.05, 1.0);\n\n  return col;\n}\n\nvec3 getAlbedoGround(inout Data data) {\n  vec2 uv = data.uv;\n  vec3 p = data.p;\n  vec3 col = forestGrassTexture(uv, p, data.m);\n\n  /*\n     vec3 bump = vec3(0.0);\n     float e = 0.02;\n     float z = 0.4;\n     bump = normalize(luma(col) - vec3(\n         luma(forestGrassTexture(uv + vec2(e, 0), p, data.m)),\n         luma(forestGrassTexture(uv + vec2(0, e), p, data.m)),\n         z\n     ));\n     bump = fixNormal(data.n, bump, 0.9);\n\n     data.n = bump;\n    */\n  return col;\n}\n\n/*\nvec3 getAlbedoBox(inout Data data) {\n  vec2 uv = data.uv;\n  vec3 p = data.p;\n  vec3 col = brickTexture(uv, p, data.m);\n  return col;\n}*/\n\nfloat srange(float v, float ma, float th, vec2 ab) {\n  float s = smoothstep(ab.x, ab.y, v - ma);\n  s -= smoothstep(ab.x, ab.y, v - (ma + th));\n  return clamp(s, 0.0, 1.0);\n}\n\nvec3 getAlbedoCraftBody(inout Data data) {\n  vec2 uv = data.uv;\n  vec3 p = pointQuat(data.p - CENTER,\n                     data.o.q); // pointQuat(data.p - data.o.p, data.o.q);\n  vec3 col = alumTexture(uv, p, data.m);\n\n  float s1 = srange(p.y, 5.0, 0.1, vec2(0.0, 0.05));\n  float s2 = srange(p.y, 5.2, 0.1, vec2(0.0, 0.05));\n\n  // float dside = round(adot(data.n, vec3(0, 0, 1)));\n  float f = 1.0; // float(p.x > -4. && p.x < 5.);// * dside;\n\n  col += s1 * f;\n  col += s2 * f;\n  // col += clamp(s, 0.0, 1.0);\n\n  return col;\n}\n\nvec3 getAlbedoCraftWing(inout Data data) {\n  vec2 uv = data.uv;\n  vec3 p = data.p;\n  vec3 col = alumTexture(uv, p, data.m);\n\n  //    if (p.x > -0.02 && p.x < 0.02) col += 1.0;\n\n  return col;\n}\n\nvec3 getAlbedoCraftEngine(inout Data data) {\n  vec2 uv = data.uv;\n  vec3 p = data.p - vec3(0, CENTER.y, 0);\n  vec3 col = metalTexture(uv, p, data.m);\n\n  vec3 bump = vec3(0.0);\n  float e = 0.01;\n  float z = 0.5;\n  bump = normalize(luma(col) -\n                   vec3(luma(metalTexture(uv + vec2(e, 0), p, data.m)),\n                        luma(metalTexture(uv + vec2(0, e), p, data.m)), z));\n  bump = fixNormal(data.n, bump, 0.5);\n  data.n = bump;\n\n  return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n  switch (data.id) {\n  case ID_GROUND:\n    return getAlbedoGround(data);\n    break;\n/*  case ID_BOX:\n    return getAlbedoBox(data);\n    break;*/\n  case ID_CRAFT_BODY:\n    return getAlbedoCraftBody(data);\n    break;\n  case ID_CRAFT_WING:\n    return getAlbedoCraftWing(data);\n    break;\n  case ID_CRAFT_ENGINE:\n    return getAlbedoCraftEngine(data);\n    break;\n  }\n\n  return vec3(0.77);\n}\n\nvec3 getSky(in vec3 ro, in vec3 rd, in Light light) {\n  vec3 col = vec3(0.0);\n  vec2 uv = rd.xz / rd.y;\n  vec3 blue = vec3(0.3, 0.56, 0.8);\n\n  float dotup = cdot(rd, vec3(0, 1, 0));\n\n  col = pow(blue, vec3(1.0 + (dotup * 2.)));\n\n  float time = T * 0.2;\n\n  vec2 shift = vec2(cos(time), sin(time));\n  uv += sin(shift * 6.) * 0.01;\n\n  vec3 lf1 = noise6(uv + shift, 0.03291895, 0.9);\n  vec3 hf1 = noise6(uv - (shift * 0.2), 1.2321956,\n                    16.0 + mix(0.0, 1., pow(lf1.z, 2.0)));\n  vec3 mixer = noise6(uv + sin(shift), 0.11111223, 0.9);\n\n  time *= mix(1.0, 0.9, smoothstep(0.3, 1., mixer.y * mixer.x));\n\n  time += adot(lf1, hf1);\n\n  float mixf = mix(mixer.x, mixer.y, 0.5 + (0.5 * sin(time)));\n\n  float low = mix(lf1.x, lf1.y, 0.5 + (0.5 * cos(time)));\n  float high = mix(hf1.x, hf1.y, 0.5 + (0.5 * sin(time)));\n\n  vec3 lfi = noise6(uv + shift, 0.53928111, 1.0);\n  float inv = pow(mix(lfi.x, lfi.y, 0.5 + (0.5 * cos(time))), 2.0);\n\n  float clouds = mix(low, high, mixf);\n\n  clouds = mix(clouds, 0.0, inv);\n  clouds = pow(clouds, 3.0);\n  \n  clouds *= clamp(dotup*40., 0.0, 1.0);\n\n  col = mix(col + clouds, mix(col, vec3(1.0), clouds),\n            0.5 + (0.5 * cos(time + low + high + inv)));\n\n  return col;\n}\n\nvec3 lightEffect(in vec3 ro, in vec3 rd, in Light light, in Data data) {\n    vec3 col = vec3(0.0);\n    vec3 L = getLightDir(light, ro);\n    float VdotL = cdot(rd, L);\n    \n    float depth = data.d / FAR;\n    col += light.c * light.s * pow(VdotL, 16.) * clamp(smoothstep(0.01, 1.0, depth), 0.1, 1.0);\n    return col;\n}\n\nvec3 forEachLight(inout Data data, in Light light, in vec3 ro, in vec3 rd) {\n  vec3 albedo = getAlbedo(data);\n  vec3 diffuse = albedo / M_PI;\n  vec3 p = data.p;\n  vec3 n = data.n;\n  vec3 L = getLightDir(light, p);\n  vec3 ref = reflect(L, n);\n  float VdotR = cdot(rd, ref);\n  float spec = data.m.spec * pow(VdotR, 32.0);\n  vec3 att = getLightAtt(light, p, n);\n  float shadow =\n      getShadow(p + (n * NEAR * 2.), L, data.d,\n                light.type == LIGHT_AMBIENT ? FAR : distance(light.p, p));\n\n  vec3 normal = data.n;\n  vec3 f0 = vec3(0.04);\n\n  float roughness = data.m.rough;\n  float metallic = data.m.metallic;\n  f0 = mix(f0, diffuse, metallic);\n  vec3 viewdir = rd;\n  vec3 H = normalize(L + viewdir);\n  vec3 reflectDir = reflect(L, normal);\n\n  float NdotL = max(dot(normal, L), 0.0);\n  float NdotH = clamp(dot(normal, H), 0.000001, 1.0);\n  float HdotV = clamp(dot(H, viewdir), 0.000001, 1.0);\n  float VdotL = max(dot(viewdir, L), 0.0);\n  float NdotV = abs(dot(normal, viewdir));\n\n  vec3 fresnel = fresnelSchlick(HdotV, f0);\n  float D = microfacetDistribution(roughness, NdotH);\n  float S = DistributionGGX(normal, H, roughness);\n  float G = GeometrySmith(normal, viewdir, L, roughness);\n  float Fsd = (4.0 * NdotV * NdotL);\n  vec3 specularity = (fresnel * S * G * D) / notzero(Fsd);\n  vec3 kd = vec3(1.0) - specularity;\n  kd *= 1.0 - metallic;\n\n  return (diffuse + spec + specularity) * att * shadow;\n}\n\n#define NUM_LIGHTS 1\n\nvec3 render(inout Data data, in vec3 ro, in vec3 rd, inout float dist) {\n  vec3 col = vec3(0.0);\n  dist = FAR;\n  float dotup = cdot(rd, vec3(0, 1, 0));\n  Light lights[NUM_LIGHTS];\n  lights[0] = Light(vec3(1, 2, -3), vec3(0.0), vec3(0.97, 0.79, 0.69), 2.0,\n                    LIGHT_AMBIENT);\n\n  float mixf = 1.0;\n  for (int j = ZERO; j < 2; j++) {\n    if (march(data, ro, rd)) {\n      vec3 normal = data.n;\n      vec3 indirectSpecular = vec3(1.0);\n      if (j <= 0) {\n        dist = min(dist, data.d);\n      } else {\n        vec3 f0 = vec3(0.04);\n        f0 = mix(f0, col, data.m.metallic);\n        float roughness = data.m.rough;\n        float NdotV = abs(dot(normal, rd)) + 0.000001;\n        vec3 envBRDF = EnvBRDFApprox(vec3(0.2), pow(roughness, 2.0), NdotV);\n        vec3 F = fresnelSchlickRoughness(NdotV, f0, roughness);\n        vec3 rdir = reflect(rd, normal);\n        indirectSpecular = vec3(1.0) * (F * envBRDF.x + envBRDF.y);\n      }\n\n      for (int i = ZERO; i < NUM_LIGHTS; i++) {\n        Light light = lights[i];\n        col += forEachLight(data, light, ro, rd) * mixf * indirectSpecular;\n        col += lightEffect(ro, rd, light, data) * mixf;\n      }\n\n      if (data.m.rough >= 0.999)\n        break;\n\n      rd = reflect(rd, normal);\n      ro = data.p + (data.n * NEAR * 2.);\n      mixf /= 2.0;\n      mixf *= max(0.0, 1.0 - data.m.rough);\n    } else {\n      // dist = FAR;\n      col += getSky(ro, rd, lights[0]) * mixf;\n      col += lightEffect(ro, rd, lights[0], data) * mixf;\n      break;\n    }\n  }\n\n  float depth = dist / FAR;\n\n  col += smoothstep(0.3, 1.0, depth) * max(0.0, 1.0 - dotup) *\n         cdot(rd, vec3(0, -1, 0));\n\n  col += smoothstep(0.4, 1.0, abs((1.0 / (ro + rd)).y)) * depth * depth;\n\n  return col;\n}\n\nvoid getRay(in vec2 uv, in vec4 m, inout vec3 ro, inout vec3 rd) {\n  ro = vec3(0, 1, -4.0);\n  rd = normalize(vec3(uv.xy, 1.0));\n\n  Object craft = getCraft();\n\n#if WALK\n  vec3 walk = texelFetch(iChannel0, ivec2(0, 0), 0).xyz;\n  vec3 fly = texelFetch(iChannel0, ivec2(1, 0), 0).xyz;\n\n  ro += walk;\n  ro.y += fly.y;\n\n  rd.yz *= rot(m.y * TAU);\n  rd.xz *= rot(m.x * TAU);\n#else\n\n  bool control = false;\n\n  if ((abs(m.x) > 0.0001 || abs(m.y) > 0.0001) && m.z > 0.01) {\n    ro = vec3(0, 0, craft.p.z - FLY_TIME);\n    ro.z = -16.; // vec3(0, 0, -16.);\n    ro.yz *= rot(m.y * TAU);\n    ro.xz *= rot(m.x * TAU);\n\n    rd.yz *= rot(m.y * TAU);\n    rd.xz *= rot(m.x * TAU);\n    ro.y -= 3.;\n    ro.y += craft.p.y / 2.;\n    ro.z += 4.;\n    control = true;\n\n  } else {\n\n    ro.z -= 6.0;\n    ro.y += craft.p.y - 10.;\n  }\n\n  ro.z -= 4.;\n\n  ro += CENTER;\n  // ro.xz -= vec2(cos(T), sin(T))*6.;\n\n  if (!control) {\n    ro.xz = CENTER.xz + (vec2(cos(T * 0.5), sin(T * 0.5)) * 20.);\n    ro.y -= (0.5 + (0.5 * cos(T))) * 6.;\n  }\n  ro.z += FLY_TIME;\n  rd = look(uv, craft.p - vec3(0, -4.5 + cos(T), 0), ro);\n\n#endif\n\n  ro.y = max(CENTER.y + 1., ro.y);\n}\n\nvoid mainImage(out vec4 O, in vec2 fc) {\n  vec3 col = vec3(0.0);\n  vec4 m = iMouse;\n  vec2 uv = (fc - 0.5 * R.xy) / R.y;\n  m.xy = (m.xy - 0.5 * R.xy) / R.y;\n\n  vec3 ro = vec3(0.0);\n  vec3 rd = vec3(0.0);\n  getRay(uv, m, ro, rd);\n  Data data = NEW_DATA;\n  float dist = FAR;\n\n#ifdef DEBUG_TEXTURE\n  Material ma = NEW_MATERIAL;\n  col += DEBUG_TEXTURE(fc.xy / R.xy, ro + rd, ma);\n#else\n  col += render(data, ro, rd, dist);\n  col += (col*col*luma(col));\n  col /= vec3(1.0) + col;\n  col = pow(col, vec3(1.0 / 2.2));\n#endif\n\n  O = vec4(clamp(col, 0.0, 1.0), dist / FAR);\n}","name":"Buffer A","description":"","type":"buffer"}]}