{"ver":"0.1","info":{"id":"lcXyR4","date":"1720817539","viewed":23,"name":"Realistic Film Grain Rendering","username":"Mynx","description":"Adaptation of https://www.ipol.im/pub/art/2017/192/article_lr.pdf\nSource: https://github.com/alasdairnewson/film_grain_rendering_gpu/\n\nWARNING: the naive version they shared is pretty expensive!","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["film","grain","filmgrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_SAMPLES 100 // number of monte carlo samples\n\nuint wang_hash(uint seed)\n{\n\tseed = (seed ^ 61u) ^ (seed >> 16u);\n\tseed *= 9u;\n\tseed = seed ^ (seed >> 4u);\n\tseed *= 668265261u;\n\tseed = seed ^ (seed >> 15u);\n\treturn (seed);\n}\n\nuint cellseed(uint x, uint y, uint offset)\n{\n\tconst uint period = 65536u; // 65536 = 2^16\n\tuint s = (( y % period) * period + (x % period)) + offset;\n\tif (s == 0u)\n\t\ts = 1u;\n\treturn(s);\n}\n\nvoid srand(inout uint p, uint seed)\n{\n    uint s = seed;\n    p = wang_hash(s);\n}\n\nuint rand(inout uint p)\n{\n\t// linear congruential generator: procudes correlated output. Similar patterns are visible\n\t// p.state = 1664525u * p.state + 1013904223u;\n\t// Xorshift algorithm from George Marsaglia's paper\n\tp ^= (p << 13u);\n\tp ^= (p >> 17u);\n\tp ^= (p << 5u);  \n\treturn (p);\n}\n\nfloat rand_uniform_0_1(inout uint p)\n{\n    return float(rand(p)) / float(4294967295u);\n}\n\nfloat rand_gaussian_0_1(inout uint p)\n{\n    // Box-Muller method for generating standard Gaussian variate\n    float u = rand_uniform_0_1(p);\n    float v = rand_uniform_0_1(p);\n    return (sqrt(-2.0 * log(u)) * cos(2.0 * pi * v));\n}\n\nvec2 rand_gaussian2(inout uint p)\n{\n    // Box-Muller method for generating standard Gaussian variate\n    float u = rand_uniform_0_1(p);\n    float v = rand_uniform_0_1(p);\n\n\tvec2 randOut;\n\t//sqrt(-2.0 * log(u)) * vec2(cos(2.0 * pi * v), sin(2.0 * pi * v)))\n\trandOut.x = sqrt(-2.0 * log(u)) * cos(2.0 * pi * v);\n\trandOut.y = sqrt(-2.0 * log(u)) * sin(2.0 * pi * v);\n    return (randOut);\n}\n\nuint rand_poisson(inout uint prngstate, float lambda, float expLambda)\n{\n\t// Inverse transform sampling\n\tfloat u = rand_uniform_0_1(prngstate);\n\t\n\tuint x = 0u;\n\t\n\t//float prod = exp(-lambda); // this should be passed as an argument if used extensively with the same value lambda\n\tfloat prod = expLambda;\n\tfloat sum = prod;\n\twhile ( (u > sum) && (x < uint(floor(10000.0f * lambda))))\n\t{\n\t\tx = x + 1u;\n\t\tprod = prod * lambda / float(x);\n\t\tsum = sum + prod;\n\t}\n\treturn (x);\n}\n\nfloat sqDistance(float x1, float y1, float x2, float y2)\n{\n\treturn((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint offsetRand = wang_hash(uint(iFrame));// uint(iTime * 1000.0);\n    \n    float x = fragCoord.x;\n    float y = fragCoord.y;\n\n    float normalQuantile = 3.0902f;//2.3263;\t//standard normal quantile for alpha=0.999\n    float logNormalQuantile;\n    float grainRadiusSq = grainRadius * grainRadius;\n    float currRadius, currGrainRadiusSq;\n    float mu, sigma, sigmaSq;\n    float maxRadius = grainRadius;\n\n    float out_w = iResolution.x;\n    float out_h = iResolution.y;\n    float xA = 0.0;\n    float xB = iChannelResolution[0].x;\n    float yA = 0.0;\n    float yB = iChannelResolution[0].y;\n\n    float ag = 1.0f / ceil(1.0f / grainRadius);\n    float sX = (out_w - 1.0f) / (xB - xA); \n    float sY = (out_h - 1.0f) / (yB - yA);\n\n    //calculate the mu and sigma for the lognormal distribution\n    if (grainSigma > 0.0)\n    {\n        sigma = sqrt(log((grainSigma / grainRadius) * (grainSigma / grainRadius) + 1.0f));\n        sigmaSq = sigma * sigma;\n        mu = log(grainRadius) - sigmaSq / 2.0f;\n        logNormalQuantile = exp(mu + sigma * normalQuantile);\n        maxRadius = logNormalQuantile;\n    }\n\n    float pixOut = 0.0;\n    float u;\n\n    //conversion from output grid (xOut,yOut) to input grid (xIn,yIn)\n    //we inspect the middle of the output pixel (1/2)\n    //the size of a pixel is (xB-xA)/nOut\n    x = xA + (x) * ((xB - xA) / (out_w));\n    y = yA + (y) * ((yB - yA) / (out_h));\n\n    // Simulate Poisson process on the 4 neighborhood cells of (x,y)\n    uint pMonteCarlo;\n    uint p;\n    srand(pMonteCarlo, 2016u * offsetRand);\n\n    float  uMax = 2.0;\n    float epsilon = 1e-5;\n\n    int nMonteCarlo = NUM_SAMPLES;\n    for (int i = 0; i < nMonteCarlo; i++)\n    {\n        float xGaussian = rand_gaussian_0_1(pMonteCarlo);\n        float yGaussian = rand_gaussian_0_1(pMonteCarlo);\n\n        xGaussian = x + sigmaFilter * (xGaussian) / sX;\n        yGaussian = y + sigmaFilter * (yGaussian) / sY;\n\n        vec3 src_im_sxsy = texelFetch(iChannel0, ivec2(max(floor(xGaussian),0.0), max(floor(yGaussian),0.0)), 0).rgb;\n        u = src_im_sxsy.x;\n        u = u/(uMax+epsilon);\n        float lambda = -((ag*ag)/( pi*(grainRadiusSq + grainSigma*grainSigma) )) * log(1.0f-u);\n\n        //determine the bounding boxes around the current shifted pixel\n        uint minX = uint(floor((xGaussian - maxRadius) / ag));\n        uint maxX = uint(floor((xGaussian + maxRadius) / ag));\n        uint minY = uint(floor((yGaussian - maxRadius) / ag));\n        uint maxY = uint(floor((yGaussian + maxRadius) / ag));\n\n        bool ptCovered = false; // used to break all for loops\n        for(uint ncx = minX; ncx <= maxX; ncx++) // x-cell number\n        {\n            if(ptCovered == true)\n                break;\n\n            for(uint ncy = minY; ncy <= maxY; ncy++) // y-cell number\n            {\n                if(ptCovered == true)\n                    break;\n                float cellCornerX = ag * float(ncx);\n                float cellCornerY = ag * float(ncy);\n\n                uint seed = cellseed(ncx, ncy, offsetRand);\n                srand(p, seed);\n\n                // Compute the Poisson parameters for the pixel that contains (x,y)\n                vec3 src_im_sxsy = texelFetch(iChannel0, ivec2(max(floor(xGaussian), 0.0), max(floor(yGaussian), 0.0)), 0).rgb;\n                u = src_im_sxsy.x;\n\n                // using the LUT approach here\n                vec2 lambaLUT = texture(iChannel1, vec2(u, 0.5)).xy;\n\t\t\t\tfloat currLambda = lambaLUT.x;\n                float currExpLambda = lambaLUT.y;\n                /*float currLambda = lambda;\n                float currExpLambda = exp(-lambda);\n                if((floor(cellCornerX) != floor(xGaussian)) || (floor(cellCornerY) != floor(yGaussian)))\n                {\n                    vec3 src_im_temp = texelFetch(iChannel0, ivec2(max(floor(cellCornerX),0.0), max(floor(cellCornerY),0.0)), 0).rgb;\n                    // Compute the Poisson parameters for the pixel that contains (x,y)\n                    u = src_im_temp.x;\n                    u = u/(uMax+epsilon);\n                    currLambda = -((ag*ag)/( pi*(grainRadiusSq + grainSigma*grainSigma))) * log(1.0f-u);\n                    currLambda = exp(-lambda);\n                }*/\n                \n\n                uint Ncell = rand_poisson(p, currLambda,currExpLambda);\n                for(uint k = 0u; k < Ncell; k++)\n                {\n                    //draw the grain centre\n                    float xCentreGrain = cellCornerX + (ag)*(rand_uniform_0_1(p));\n                    float yCentreGrain = cellCornerY + (ag)*(rand_uniform_0_1(p));\n\n                    //draw the grain radius\n                    if (grainSigma>0.0)\n                    {\n                        //draw a random Gaussian radius, and convert it to log-normal\n                        currRadius = min(exp(mu + sigma*rand_gaussian_0_1(p)),maxRadius);\n                        currGrainRadiusSq = currRadius*currRadius;\n                    }\n                    else\n                        currGrainRadiusSq = grainRadiusSq;\n\n                    // test distance\n                    if(sqDistance(xCentreGrain, yCentreGrain, xGaussian, yGaussian) < currGrainRadiusSq)\n                    {\n                        pixOut = pixOut + 1.0;\n                        ptCovered = true;\n                        break;\n                    }\n                }\n            }\n        }\n        ptCovered = false;\n    }\n\n    pixOut = pixOut / float(nMonteCarlo);\n\n    fragColor = vec4(pixOut,pixOut,pixOut,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_GREY_LEVEL 255\n#define EPSILON_GREY_LEVEL 0.1\n\nconst float pi = 3.141592;\n\nconst float grainRadius = 0.15f;\nconst float grainSigma = 0.0;\nconst float sigmaFilter = 0.8f;","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Labma LUT\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float u = uv.x + EPSILON_GREY_LEVEL / float(MAX_GREY_LEVEL);\n\n\tfloat ag = 1.0 / ceil(1.0 / grainRadius);\n    float ag2 = ag * ag;\n    float muR = grainRadius;\n    float muR2 = muR * muR;\n    float sigmaR = grainSigma;\n    float sigmaR2 = sigmaR * sigmaR;\n\tfloat lambdaTemp = -(ag2 / (pi * (muR2 + sigmaR))) * log(1.0 - u);\n\n    fragColor = vec4(lambdaTemp, exp(-lambdaTemp), 1.0, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}