{"ver":"0.1","info":{"id":"DsjBD1","date":"1689675669","viewed":83,"name":"Carbon shader","username":"stduhpf","description":"Inspired by https://www.shadertoy.com/view/cd2fR1","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["material","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RESIN // transparent dielectric \"coating\" (comment for \"raw\" fibers)\nconst float resin_f0 = 0.04652; //reflectivity of the resin (at 0% of incidence)\nconst float resin_roughness = .04; //rougness of the resin coating\n\nconst float PI = acos(-1.);\nconst float TAU = PI+PI;\n\nmat3 getBasis(vec3 nor){\n    bool t = 1.-abs(nor.z)>.00001;\n    if(!t)\n        nor=nor.zxy;\n    vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)/(1.0+nor.z);\n    vec3 uu = vec3( tc.x, tc.z, -nor.x );\n    vec3 vv = vec3( tc.z, tc.y, -nor.y );\n    \n    return t?mat3(uu,vv,nor):mat3(uu.yzx,vv.yzx,nor.yzx);\n}\n\n\nfloat D_GGX_A(vec3 n, const vec3 h, float at, float ab) { //anisotropic\n    vec3 hh = inverse(getBasis(n))*h; //should probably be precomputed\n    float d = hh.z;\n    float ToH = hh.x;\n    float BoH = hh.y;\n    float a2 = at * ab;\n    vec3 v = vec3(ab * ToH, at * BoH, a2 * d);\n    float v2 = dot(v, v);\n    float w2 = a2 / v2;\n    return a2 * w2 * w2 * (1.0 / PI);\n}\n\nfloat ggxMaskingShadowing(vec3 n, vec3 d, vec3 l, float a){\n    // TODO: anisotropic masking/shadowing\n    a*=a;\n    float dotNL = dot(n,l);\n    float dotND = dot(n,d);\n    float denomA = dotNL * sqrt(a + (1.0f - a) * dotND * dotND);\n    float denomB = dotND * sqrt(a + (1.0f - a) * dotNL * dotNL);\n\n    return 2.0f * dotND * dotNL / (denomA + denomB);\n}\n\nfloat cook_Torrence(vec3 n,vec3 v,vec3 l,float rx, float ry){\n    vec3 h = normalize(v+l);\n    // if(dot(l,n)<=0.)return 0.;\n    float fres = 1.;\n    return fres*D_GGX_A(n,h,rx,ry)*ggxMaskingShadowing(n,v,l,(rx+ry)*.5)/(4.*dot(n,l)*dot(n,v)) ;\n}\n\n\nfloat Schlick(float f0, float cosTheta){\n    return f0+(1.-f0)*pow(1.-cosTheta,5.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord\n    +texture(iChannel1,fragCoord/iChannelResolution[1].xy).xy //avoid moirÃ©\n    -iResolution.xy*.5)/iResolution.y;\n\n    vec3 ro = vec3(0.,10.,0.);\n    vec3 rd = normalize(vec3(uv,.5));//vec3(uv,sqrt(1.-dot(uv,uv)));\n\n    vec2 m = iMouse.z==0.?vec2(PI*.5,PI-.3):vec2(PI,PI)*iMouse.xy/iResolution.xy;\n    vec3 ld = normalize(vec3(sin(PI-m.y),cos(PI-m.y)*vec2(sin(m.x),cos(m.x))).zxy);\n    \n    if(rd.y<0.){\n        uv = (ro-ro.y*rd/rd.y).xz;\n        uv = mod(uv*1.,400.);\n        ivec2 id = ivec2(uv);\n        vec2 luv = fract(uv);\n        int celltype = ((id.x+id.y)%4+4)%4;\n\n        int orient = celltype/2%2;\n\n        float w = luv[orient];\n        float l = luv[1-orient]*.5+float(celltype%2)*.5;\n        \n        vec2 roughness = vec2(.3+.2*texture(iChannel0,vec2(w,float(id[orient])*PI)).r,.2);\n        \n        const float bumpHeight = .025;\n        float depth = sin(l*PI)*bumpHeight;\n        float deriv = cos(l*PI)*PI*bumpHeight;\n        vec3 n = normalize(vec3(-deriv*float(orient),1,-deriv*float(1-orient)));\n\n        float absorb = sqrt(sin(l*PI))*.8+.2; //fake ao/dirtiness\n        const float albedo = .68; //how much light gets reflected by the material and isn't turned into heat\n        \n        float ref = albedo*(cook_Torrence(n,-rd,ld,roughness[orient],roughness[1-orient])/TAU)*max(dot(n,ld),0.);\n        ref = absorb*ref;\n#ifdef RESIN\n        n = vec3(0,1,0);\n        float resin_ref = (cook_Torrence(n,-rd,ld,resin_roughness,resin_roughness)/TAU)*max(dot(n,ld),0.);\n        ref = mix(ref,resin_ref,Schlick(resin_f0,-rd.y));\n#endif\n        fragColor = vec4(ref);\n    }else{\n        vec3 diff = rd-ld;\n        fragColor = vec4(.000001/dot(diff,diff*length(diff)));\n    }\n    fragColor = pow(max(fragColor,0.),vec4(1./2.2));\n\n}","name":"Image","description":"","type":"image"}]}