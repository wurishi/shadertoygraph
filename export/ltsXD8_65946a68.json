{"ver":"0.1","info":{"id":"ltsXD8","date":"1436512194","viewed":257,"name":"raytracing demo","username":"zephmann","description":"raytracing demo for freddev","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"const float eps = 0.0001;\n\n// a point and a directional light\nvec3 dl = normalize(vec3(-1.0, -1.0, 1.0));\nvec3 pl = vec3(5.0, 10.0, -5.0);\n\n// ground normal and point in plane\nvec3 gn = vec3(0.0, 1.0, 0.0);\nvec3 gp = vec3(0.0, 0.0, 0.0);\nvec3 gc = vec3(0.6);\n\n// first sphere\nvec3 sp1 = vec3(-3.0, 2.0, 0.0);\nfloat sr1 = 9.0;\nvec3 sc1 = vec3(0.8, 0.1, 0.7);\n\n// second sphere\nvec3 sp2 = vec3(3.0, 3.0, 2.0);\nfloat sr2 = 16.0;\nvec3 sc2 = vec3(0.0);//vec3(0.1, 0.6, 0.8);\n\n// ray plane intersection\n// returns the length along the ray to the point of intersection\n// returns -1.0 if the ray misses the object\nfloat ground(vec3 ro, vec3 rd) {\n    float t = -1.0;\n    \n    float denom = dot(gn, rd);\n    \n    if(abs(denom) > eps) {\n        float tt = dot((gp- ro), gn) / denom;\n        \n        if(tt > 0.0)\n        \tt = tt;\n    }\n    \n    return t;\n}\n\n// ray sphere intersection\n// returns the length along the ray to the point of intersection\n// returns -1.0 if the ray misses the object\nfloat sphere(vec3 ro, vec3 rd, vec3 sp, float sr) {\n    float t = -1.0;\n    \n    vec3 l = sp - ro;\n    float tca = dot(l, rd);\n    float d2 = dot(l, l) - tca*tca;\n    \n    if(d2 <= sr) {\n        float thc = sqrt(sr - d2);\n        \n        float t0 = tca - thc;\n        float t1 = tca + thc;\n        \n        if(t0 > t1) {\n            float temp = t0;\n            t1 = t0;\n            t0 = temp;\n        }\n        \n        t = t0 < 0.0 ? t0 : t0;\n    }\n    \n    return t;\n}\n\n// calc the surface shading\n// nn is the normalized normal\n// p is the intersection point\n// i is the direction from the camera\n// sc is the surface's base color\nvec3 shade(vec3 nn, vec3 p, vec3 i, vec3 sc) {\n    float amb = 0.1;\n    \n    vec3 l = vec3(0.0);\n    \n    // switch between point and directional lights\n    if(true)\n    \tl = normalize(pl - p);\n    else\n    \tl = -dl;\n    \n    float diff = max(dot(nn, l), 0.0);\n    \n    vec3 h = normalize((-i + l) * 0.5);\n    float spec = max(dot(nn, h), 0.0);\n    spec = pow(spec, 100.0);\n    \n    return sc * (diff + amb) + vec3(spec);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get the screen space coords of our pixel\n    // map from (0, width, 0, height) to (-1, 1, -1, 1)\n    float delta = 2.0 / iResolution.y;\n    vec2 uv = ((fragCoord.xy - iResolution.xy*0.5) * delta);\n    \n    vec3 fc = vec3(0.0);  // stores the final surface color\n    \n    float sinTime = sin(iTime * 0.25);\n    float cosTime = cos(iTime * 0.25);\n    \n    // 4x4 supersampling to try to reduce aliasing\n    for(float j = 0.0; j < 16.0; j++) {\n        \n        float rs = 1.0; // reflection contribution\n    \n        // offset the camera direction for the super sampling\n        float tempx = mod(j, 4.0);\n        float tempy = floor(j * 0.25);\n        tempx = (tempx*0.333 - 0.5) * delta;\n        tempy = (tempy*0.333 - 0.5) * delta;\n        \n        // define camera origin and ray direction for pixel\n        vec3 ro = vec3(sinTime * 35.0, 7.0 + sinTime, cosTime * -35.0);\n        vec3 rd = normalize(vec3(uv.x + tempx, uv.y + tempy - 0.75, 5.0));\n        \n        // rotate the direction\n        tempx = rd.x;\n        rd.x = cosTime*rd.x - sinTime*rd.z;\n        rd.z = cosTime*rd.z + sinTime*tempx;\n\n        // for loop for the ray depth\n        float t;\n        int index;\n        for(int i = 0; i < 4; i++) {\n\n            // if we are still reflecting light\n            if(rs > 0.05) {\n                t = 1000000.0;\n                index = -1;\n\n                // check ground intersection\n                float temp = ground(ro, rd);\n                if( temp > eps && temp < t) {\n                    t = temp;\n                    index = 0;\n                }\n\n                // check our sphere\n                temp = sphere(ro, rd, sp1, sr1);\n                if(temp > eps && temp < t) {\n                    t = temp;\n                    index = 1;\n                }\n\n                temp = sphere(ro, rd, sp2, sr2);\n                if(temp > eps && temp < t) {\n                    t = temp;\n                    index = 2;\n                }\n\n                // we hit something, so calc surface color\n                if(index > -1) {\n                    vec3 p = ro + rd * t;\n                    vec3 nn = vec3(0.0);\n\n                    vec3 surf = vec3(0.0);\n\n                    // shade the ground plane\n                    if(index == 0) {\n                        nn = gn;\n\n                        surf = shade(gn, p, rd, gc);\n\n                        if(mod(floor(p.x * 0.25),2.0) != mod(floor(p.z * 0.25),2.0)) {\n                            surf = vec3(0.1);\n                        }\n\n                        surf *= rs;\n\n                        rs *= 0.1;\n                    }\n\n                    // shade the first \"plastic\" sphere\n                    else if(index == 1) {\n                        nn = normalize(p - sp1);\n\n                        surf = shade(nn, p, rd, sc1) * rs;\n\n                        rs *= 0.1;\n                    }\n\n                    // shade the second \"mirror\" sphere\n                    else if(index == 2) {\n                        nn = normalize(p - sp2);\n\n                        surf = shade(nn, p, rd, sc2) * rs;\n                        rs *= 0.9;\n                    }\n\n                    // add our current surface color to the final color\n                    fc += surf;\n\n                    // calculate the reflected ray's direction and origin\n                    rd = normalize(rd - 2.0*nn*dot(nn, rd));\n                    ro = p;\n\n                }\n\n                // we missed, stop tracing\n                else {\n                    float temp = max(rd.y, 0.15);\n                    fc += vec3(temp, temp, 1.0) * rs;\n                    rs = 0.0;\n                }\n            }\n        }\n    }\n    \n    // average all the samples contributions\n    fc *= 0.0625;\n    \n    fragColor = vec4(fc, 1.0);\n    \n    // uncomment to check uvs\n    //fragColor = vec4(uv, 0.0, 1.0);\n}","name":"","description":"","type":"image"}]}