{"ver":"0.1","info":{"id":"dtdyDr","date":"1699105037","viewed":75,"name":"Box3D Inters. or Dist. (FAILED)","username":"kastorp","description":"this cannot work in 3D, I need to use another approach with line/box distance","likes":10,"published":1,"flags":16,"usePreview":0,"tags":["intersection","rectangle","distance","box"],"hasliked":0,"parentid":"dldcR8","parentname":"Rect Intersection or Distance"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Box3D Intersection or Distance\n//\n// mouseable\n//space=parallel boxes\n//\n//----------------------------------------\n\n\nvec3 erot(vec3 p, vec4 ax) {\n    return mix(dot(p,ax.xyz)*ax.xyz,p,cos(ax.w))+sin(ax.w)*cross(ax.xyz,p);\n}\n\n#define seg(  pa,  ba ) length( pa - (ba)*clamp( dot(pa,ba)/dot(ba,ba), 0., 1. ) ) \n\n#if 1\n#define gBox( p, b ) sign(p)*(max(abs(p)-b,0.))\n#define dBox( p, b ) (length(max(abs(p)-b+.002,0.)) -.002)  //normal trick \n#else\nfloat dBox( in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.z,max(d.x,d.y)),0.0);\n}\n\nvec3 gBox( in vec3 p, in vec3 b)\n{\n    vec3 w = abs(p)-b;\n    float g = max(max(w.x,w.y),w.z);\n    if(g>0.) return sign(p)*(max(abs(p)-b,0.));\n    else return  sign(p)* step(w.yzx,w)*step(w.zxy,w);\n}\n#endif\n\nvec3 va,vb,a,b,La,Lb;\nvec4 ra,rb;\nbool intersect ;\n\nvoid getDist(){\n    const float EPS=.0;\n    mat3 rota = mat3(erot(vec3(1,0,0),ra),erot(vec3(0,1,0),ra),erot(vec3(0,0,1),ra));\n    mat3 rotb = mat3(erot(vec3(1,0,0),rb),erot(vec3(0,1,0),rb),erot(vec3(0,0,1),rb));\n     //brute force, evaluate 8 vertexes for each box   \n    float da=1e5, db=1e5;\n    for(float x=-1.;x<=1.;x+=2.) for(float y=-1.;y<=1.;y+=2.) for(float z=-1.;z<=1.;z+=2.)\n    {\n        vec3 va2= a+  (La* vec3(x,y,z))*rota,\n             vb2= b+  (Lb* vec3(x,y,z))*rotb;\n        float da2= dBox(rotb*(va2-b),Lb),\n              db2= dBox(rota*(vb2-a),La);\n        if(da2< da) { va=va2; da=da2;} \n        if(db2< db) { vb=vb2; db=db2;}\n    }     \n       \n    vec3  ga= gBox(rotb*(va-b),Lb),  \n          gb= gBox(rota*(vb-a),La);  \n    vec3  vab =va-ga*rotb, // closest point to VA\n          vba =vb-gb*rota; // closest point to VB   \n    float dc = length(ga)-length(gb);   \n    \n    if(abs(dc)<EPS && length(vb-vab)>EPS){vb+=(vab-vb)*.5;va+=(vba-va)*.5;} \n    else if(dc<=0.) vb=vab;\n    else va=vba;\n    \n    intersect= min(length(ga),length(gb))<=0.\n    || length(va-a)>length(vb-a)|| length(vb-b)>length(va-b) ;  //this check doesn't work always in 3d\n} \n\nvec4 mmin(vec4 a, float b ,vec3 c){return a.x<b?a:vec4(b,c);}\nvec4  mapScene( vec3 p )\n{\n   vec4 m =vec4(1000.,0,0,0);    \n   m=mmin(m,seg(p-va,vb-va) -.01,vec3(0.,.5,0));  \n   m=mmin(m,length(p-va) -.02,vec3(1.,1,0));\n   m=mmin(m,length(p-vb) -.02,vec3(1.,1,0));\n   float da=dBox(erot(p-a,ra),La),\n         db=dBox(erot(p-b,rb),Lb);\n   m =mmin(m,da,intersect? vec3(1,.5,.5):vec3(1,0,0)*(.5+.5*cos(db*200.) ));\n   m =mmin(m,db,intersect? vec3(.5,.5,1):vec3(0,0,1)*( .5+.5*cos(da*200.) ));\n   return m;\n}\n\n\nvec3 getNormal(in vec3 p) {\n    vec3 n=vec3(0.);\n    for(int i=min(iFrame,0);i<=2;i++){\n        vec3 e=  0.001* ((i==0)?vec3(1,0,0):(i==1)?vec3(0,1,0):vec3(0,0,1));\n        for(float j=-1.;j<=1.;j+=2.) n+= j*e* mapScene(p + j* e).x ;\n    }\n    return normalize(n);\n \n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t\t r = normalize(cross(vec3(0, 0, 1), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\nvoid mainImage(out vec4 O, in vec2 I) {\n    vec2 uv = (I - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 m=(iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n    O = vec4(.5, .5, .5, 1.0);\n      \n    a= iMouse.z>0.?  vec3(m.x,-m.y,m.y):vec3(-.2,0,0); \n    b=vec3(.2,0,0);\n    La=vec3(.2,.1,.05); \n    Lb=vec3(.2,.1,.05);\n    float tm = //  9.5253; \n              //34.66;//here fails...\n              iTime;\n    ra= vec4(normalize(vec3(1,1,0)),0.5*tm);\n    rb= vec4(normalize(vec3(0,1,1)),tm);\n    if(texelFetch(iChannel0,ivec2(32,2),0).x>.5)rb=ra;\n    \n    getDist();\n  \n    vec3 ro = vec3(0,1.,1. )*.6;\n    vec3 rd = getRayDir( ro,vec3(0),uv);\n      \n    float t = 0.0;\n    for (float iters=0.0; iters < 40.0; iters++) {\n        vec3 p = ro + rd * t;   \n        vec4 m = mapScene(p);\n        if (m.x < 0.001) {\n            vec3 n = getNormal(p);\n            vec3 l = vec3(-0.5, 0.888, 0.58);\n\n            O.rgb +=m.yzw;\n            O.rgb *= max(0.2, dot(n, l));\n            break;\n        }\n        if (t > 50.0) {\n            break;\n        }\n        t += m.x;\n    }\n}\n","name":"Image","description":"","type":"image"}]}