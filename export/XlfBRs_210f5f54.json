{"ver":"0.1","info":{"id":"XlfBRs","date":"1512837424","viewed":980,"name":"PulseLife","username":"chronos","description":"SmoothLifeL + wave equation. Give it some time to settle :)\nClick and hold in place for a while to shoot gliders with strands\nSee https://www.shadertoy.com/view/XtdSDn for more on smoothlifeL","likes":38,"published":1,"flags":48,"usePreview":0,"tags":["2d","wave","life","cellular","equation","smooth","automaton","differential"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 CellColor = vec3(0.2, 0.2, 0.2);\nconst vec3 RingColor = vec3(0.0, 0.2, 0.2);\nconst vec3 DiskColor = vec3(0.0, 0.0, 0.0);\n\nconst vec3 waveprimary   = vec3(0.0, 0.75, 1.0);\nconst vec3 wavesecondary = vec3(1., 0.75, 0.5);\nconst vec3 wavetertiary  = vec3(0.75, 0.5, 0.25);\n\nconst vec3 positivepulse = vec3(1.5, 0.5, 0.);\nconst vec3 negativepulse = vec3(0., .5, 1.);\n\nconst float pulseintensity = 1.0;\n\nvec3 pulsemix(float pulse)\n{\n    float width = 0.8;\n    return\n    smoothstep(-width,  width, pulse) * positivepulse +\n    smoothstep( width, -width, pulse) * negativepulse;\n}\n\nvec4 debug_wave(vec4 wave)\n{\n    // green -> out of bounds\n    vec4 colout = vec4(positivepulse, 0) * wave.x - vec4(negativepulse, 0) * wave.x;\n    return clamp(2.*colout, 0., 1.) + vec4(.0, step(1., abs(wave.x)), 0., 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 buffer = texture(iChannel0, uv);\n    \n    vec3 color = 1.0*(buffer.x * CellColor + buffer.y * RingColor + buffer.z * DiskColor);\n    \n    float c = 1.0 - buffer.z;\n    float c2 = 1. - texture(iChannel0, uv + .5/iResolution.xy).y;\n    color += vec3(.6, .85, 1.)*max(c2*c2 - c*c, 0.)*4.;\n    \n    vec3 waves = (1.-buffer.x) * texture(iChannel1, uv).xyz;\n    vec3 w = vec3(0.3, 0.5, 0.5) * abs(waves);    \n    vec3 wavecolor = w.x * waveprimary + w.y * wavesecondary + w.y * wavetertiary;\n    \n    vec4 innerwave = texture(iChannel2, uv);\n    vec3 pulsecolor =  pulseintensity * pulsemix(innerwave.x)  * color.b;\n\tfragColor = vec4(0.4 * color + wavecolor + pulsecolor, 1.0);\n    //fragColor = debug_wave(innerwave);\n    fragColor.a = 1.;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n//Conventions:\n// x component = outer radius / ring\n// y component = inner radius / disk\n/*\n   _\n /   \\\n|  O  |\n \\ _ /\n*/\nconst float PI = 3.14159265;\nconst float dt = 0.30;\n\n\nconst vec2 r = vec2(10.0, 3.0);\n\n// SmoothLifeL rules\nconst float b1 = 0.257;\nconst float b2 = 0.336;\nconst float d1 = 0.365;\nconst float d2 = 0.549;\n\nconst float alpha_n = 0.028;\nconst float alpha_m = 0.147;\n/*------------------------------*/\n\n//const float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\n//const float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\nconst float KEY_SPACE  = 32.5/256.0;\n\n\n// 1 out, 3 in... <https://www.shadertoy.com/view/4djSRW>\n#define MOD3 vec3(.1031,.11369,.13787)\nfloat hash13(vec3 p3) {\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.x + p3.y)*p3.z);\n}\n\n\n/* ---------------- Sigmoid functions ------------------------------------ */\n\n// TODO: reduce unnecessary parameters (remove arguments, use global consts)\n\nfloat sigmoid_a(float x, float a, float b) {\n    return 1.0 / (1.0 + exp(-(x - a) * 4.0 / b));\n}\n\n// unnecessary \nfloat sigmoid_b(float x, float b, float eb) {\n    return 1.0 - sigmoid_a(x, b, eb);\n}\n\nfloat sigmoid_ab(float x, float a, float b, float ea, float eb) {\n    return sigmoid_a(x, a, ea) * sigmoid_b(x, b, eb);\n}\n\nfloat sigmoid_mix(float x, float y, float m, float em) {\n    return x * (1.0 - sigmoid_a(m, 0.5, em)) + y * sigmoid_a(m, 0.5, em);\n}\n\n/* ----------------------------------------------------------------------- */\n\n// SmoothLifeL\nfloat transition_function(vec2 disk_ring) {\n    return sigmoid_mix(sigmoid_ab(disk_ring.x, b1, b2, alpha_n, alpha_n),\n                       sigmoid_ab(disk_ring.x, d1, d2, alpha_n, alpha_n), disk_ring.y, alpha_m\n                      );\n}\n\n// unnecessary (?)\nfloat ramp_step(float steppos, float t) {\n    return clamp(t-steppos+0.5, 0.0, 1.0);\n}\n\n// unnecessary\nvec2 wrap(vec2 position) { return fract(position); }\n\n// Computes both inner and outer integrals\n// TODO: Optimize. Much redundant computation. Most expensive part of program.\nvec2 convolve(vec2 uv) {\n    vec2 result = vec2(0.0);\n    for (float dx = -r.x; dx <= r.x; dx++) {\n        for (float dy = -r.x; dy <= r.x; dy++) {\n            vec2 d = vec2(dx, dy);\n            float dist = length(d);\n            vec2 offset = d / iResolution.xy;\n            vec2 samplepos = wrap(uv + offset);\n            //if(dist <= r.y + 1.0) {\n                float weight = texture(iChannel0, samplepos).x;\n            \tresult.x += weight * ramp_step(r.y, dist) * (1.0-ramp_step(r.x, dist));\t\n            \t\n            //} else if(dist <= r.x + 1.) {\n                //float weight = texture(iChannel0, uv+offset).x;\n\t\t\t\tresult.y += weight * (1.0-ramp_step(r.y, dist));\n            //}\n        }\n    }\n    return result;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0.0);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Compute inner disk and outer ring area.\n    vec2 area = PI * r * r;\n    area.x -= area.y;\n    /* -------------------------------------*/\n    \n    // TODO: Cleanup.\n    color = texture(iChannel0, uv).xyz;\n    vec2 normalized_convolution = convolve(uv.xy).xy / area;\n    float dfdt =  dt * (2.0 * transition_function(normalized_convolution) - 1.0);\n    color.x = color.x + dfdt;\n    color.yz = normalized_convolution;\n    color = clamp(color, 0.0, 1.0);\n    \n    // Set initial conditions. TODO: Move to function / cleanup\n    if(iFrame < 10 || texture( iChannel2, vec2(KEY_SPACE,0.5) ).x > 0.5) {\n        color = vec3(hash13(vec3(fragCoord, iFrame)) - texture(iChannel1, uv).x + 0.5);\n    }\n    \n    if(iMouse.z > 0.) {\n        float dst = length((fragCoord.xy - iMouse.xy)/iResolution.xx);\n        if(dst <= (r.x)/iResolution.x) {\n        \tcolor.x = step((r.y+1.5)/iResolution.x, dst) * (1.0 - step(r.x/iResolution.x, dst));\n        }\n    }\n    \n    // Inspect transition function. TODO: Move to function / ifdef\n    if(texture( iChannel2, vec2(KEY_DOWN, 5.0/3.0) ).x > 0.5) {\n        color = vec3(transition_function(uv));\n    }\n    \n    if(texture( iChannel2, vec2(KEY_UP, 0.5)).x > 0.5) {\n    \tcolor = vec3(0.0);\n    }\n    \n    fragColor = vec4(color, dfdt);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Exterior wave field\n\nfloat pulse(float center, float width, float x)\n{\n    return smoothstep(center-width/2., center, x) * smoothstep(center+width/2., center, x);\n}\n\nfloat lookup(vec2 p)\n{\n    return texelFetch(iChannel0, ivec2(mod(p, iResolution.xy)), 0).r;\n}\n\nfloat laplacian(vec2 p)\n{\n    float c = lookup(p);               // Center\n    float u = lookup(p+vec2( 0.,-1.)); // Up\n    float d = lookup(p+vec2( 0., 1.)); // Down\n    float l = lookup(p+vec2(-1., 0.)); // Left\n    float r = lookup(p+vec2( 1., 0.)); // Right\n    return (u + d + l + r) / 4. - c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy;\n    vec2 uv = p / iResolution.xy;\n    vec2 aspect = vec2(1., iResolution.y / iResolution.x);\n    \n    \n    vec4 prev = texelFetch(iChannel0, ivec2(p), 0);\n    float f_prev  = prev.r;\n    float df_prev = prev.g;\n    float ddf_prev = prev.b;\n    \n    float ddf = laplacian(p);\n    float df = df_prev + 1.5 * ddf;\n    \n    float f = f_prev + df;\n    f *= 0.99;\n    \n    float life = abs(texture(iChannel1, uv).x);\n    df += life * .1;\n    if(life > 0.96)\n    {\n        float b = smoothstep(0., 1., 1.-life);\n        df *= b; //1.-b;\n        f  *= b; //1.-b;\n    }\n    \n    \n    \n    fragColor = vec4(f, df, ddf, 1.0);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Interior wave field\n\nconst float laplacianradius = 4.;\nconst float liferadius = 4.;\n\nfloat pulse(float center, float width, float x)\n{\n    return smoothstep(center-width/2., center, x) * smoothstep(center+width/2., center, x);\n}\n\nvec3 lookup(vec2 p)\n{\n    return texelFetch(iChannel0, ivec2(mod(p, iResolution.xy)), 0).rgb;\n}\n\nvec3 lookuplife(vec2 p)\n{\n    return texelFetch(iChannel1, ivec2(mod(p, iResolution.xy)), 0).rgb;\n}\n\nvec3 lookuptest(vec2 p)\n{\n    return texture(iChannel2, p/iResolution.xy).rgb;\n}\n\nvec4 convolve(vec2 p, float size) {\n    vec3 sum = vec3(0.0);\n    float totalweight = 0.;\n    for (float dx = -size; dx <= size; dx++) {\n        for (float dy = -size; dy <= size; dy++) {\n            vec2 d = vec2(dx, dy);\n            float dist = length(d);\n            float weight = 1.;\n            sum += weight * lookup(p + d);\n            totalweight += weight;\n        }\n    }\n    return vec4(sum, totalweight);\n}\n\nvec4 convolvelife(vec2 p, float size) {\n    vec3 sum = vec3(0.0);\n    float totalweight = 0.;\n    for (float dx = -size; dx <= size; dx++) {\n        for (float dy = -size; dy <= size; dy++) {\n            vec2 d = vec2(dx, dy);\n            float dist = length(d);\n            float weight = 1.;\n            sum += weight * lookuplife(p + d);\n            totalweight += weight;\n        }\n    }\n    return vec4(sum, totalweight);\n}\n\nvec4 convolvetest(vec2 p, float size) {\n    vec3 sum = vec3(0.0);\n    float totalweight = 0.;\n    for (float dx = -size; dx <= size; dx++) {\n        for (float dy = -size; dy <= size; dy++) {\n            vec2 d = vec2(dx, dy);\n            float dist = length(d);\n            float weight = smoothstep(size, 0., dist);\n            sum += weight * lookuptest(p + d);\n            totalweight += weight;\n        }\n    }\n    return vec4(sum, totalweight);\n}\n\nfloat wideLaplacian(vec2 p)\n{\n    vec4 mask = convolve(p, laplacianradius);\n    return  -lookup(p).r + mask.r / mask.a;\n}\n\n#define smoothconvolve 1\n\nconst float wavespeed = 0.1;\n//const float wavespeed = 0.0125;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy;\n    vec2 uv = p / iResolution.xy;\n    vec2 aspect = vec2(1., iResolution.y / iResolution.x);\n    \n\n    vec4 prev = texelFetch(iChannel0, ivec2(p), 0);\n    float f_prev  = prev.r;\n    float df_prev = prev.g;\n    float ddf_prev = prev.b;\n\n    \n    float ddf = wideLaplacian(p);\n    float df = df_prev + 1.5 * ddf;\n    \n    float f = f_prev + df * wavespeed;\n    //f *= 0.99;\n    \n// Using the smoothly varying area samples of the 'life' buffer\n// here is the key to smooth waves across the strands\n#if smoothconvolve\n    vec4 convlife = convolvelife(p, liferadius);\n    float life = abs(convlife.r / convlife.a);\n#else\n    float life = abs(texture(iChannel1, uv).x);\n#endif    \n    \n    float nolife = 1.-life;\n    float dlife = life - prev.a;\n    \n    float l = nolife;\n    \n\tdf -= 1. * dlife; // life changing state creates waves\n    \n    // restrict interior waves to life\n    if(l > 0.95)\n    {\n        float b = smoothstep(0., 1., 1.-l);\n        df *= b;\n        f  *= b;\n    }\n\n    fragColor = vec4(f, df, ddf, life);\n    //vec4 outtest = convolvetest(p, 3.);\n    //fragColor = vec4(outtest.rgb / outtest.a, 1.);\n    //fragColor = vec4(lookuptest(p), 1.);\n}","name":"Buf C","description":"","type":"buffer"}]}