{"ver":"0.1","info":{"id":"Xf3Szj","date":"1714123631","viewed":44,"name":"Sine2","username":"navcon","description":"Sine","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["calm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\n\n\nconst float PI = 3.141592;\n\nstruct params {\n    float amplitude;\n    float stretch;\n    float phase;\n    float speed;\n    float power;\n    vec3 color;\n};\n\n\nconst int sins_count = 6;\n\nfloat hline, vline, hdot, vdot;\nfloat amplitude;\n\nparams sin_params[sins_count];\nfloat sins[sins_count];\nfloat sinheads[sins_count];\n\nbool between(float low, float value, float high) {\n    return low < value && value < high;\n}\n\nvec3 blend(vec3 one, vec3 two, float factor) {\n    return factor * two + (1.0 - factor) * one;\n}\n\nfloat blend(float one, float two, float factor) {\n    return factor * two + (1.0 - factor) * one;\n}\n\nfloat calcSin(params sin_params, float x){\n\treturn sin_params.amplitude\n                    * sin(sin_params.stretch * x\n                    + sin_params.phase * PI\n                    + sin_params.speed * iTime)\n                    + 0.1 * sin(0.2*time + 1.8 * x);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord.xy / resolution.xy;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Base Background Color\n    vec3 col = vec3(0,0,0.8);\n    \n    \n    // Create Larger BG-Grid\n    hline = mod(fragCoord.y, 70.0);\n    vline = mod(fragCoord.x + 15.0*iTime, 70.0);\n    \n    // Create Smaller BG-Dot-Grid\n    hdot = mod(fragCoord.y, 30.0);\n    vdot = mod(fragCoord.x + 6.0 * iTime, 30.0);\n\n    col *= (hdot < 4.0 && vdot <4.0) ? vec3(.6) : vec3(0.4);\n\n    col += between(2.0, hline, 3.0) || between(2.0, vline, 3.0) ? vec3(.1) : vec3(0);\n\n    col += hline < 5.0 && vline < 5.0 ? vec3(.1) : vec3(0);\n\n    col *= 0.35;\n    col += vec3(0,0.2,0.4);\n\n    amplitude = 0.2 + 0.1 * sin(0.4*iTime + 1.1 * uv.x);\n\n    vec3 blue = vec3(0,0.8,1);\n\n    \n\n    //                     amplitude, stretch, phase, speed, power, color\n    \n    // Colorful Curves\n    /*\n    sin_params[0] = params(amplitude, 1.0, 0.0      , 0.2, 16.0 + 4.0*uv.x, vec3(1.0,0.1,0.1));\n    sin_params[1] = params(amplitude, 1.0, 1.0 / 3.0, 0.2, 24.0 + 4.0*uv.x, vec3(0.5,0.5,0.1));\n    sin_params[2] = params(amplitude, 1.0, 2.0 / 3.0, 0.2, 16.0 + 4.0*uv.x, vec3(0.1,1.0,0.1));\n    sin_params[3] = params(amplitude, 1.0, 3.0 / 3.0, 0.2, 24.0 + 4.0*uv.x, vec3(0.1,0.5,0.5));\n    sin_params[4] = params(amplitude, 1.0, 4.0 / 3.0, 0.2, 16.0 + 4.0*uv.x, vec3(0.1,0.1,1.0));\n    sin_params[5] = params(amplitude, 1.0, 5.0 / 3.0, 0.2, 24.0 + 4.0*uv.x, vec3(0.5,0.1,0.5));\n    */\n\n\n    // monochrome Curves\n    sin_params[0] = params(amplitude, 1.0, 0.0      , 0.24, 16.0 + 24.0*uv.x, 0.15*blue);\n    sin_params[1] = params(amplitude, 1.1, 1.0 / 3.0, 0.20, 24.0 + 24.0*uv.x, 0.20*blue);\n    sin_params[2] = params(amplitude, 1.0, 2.0 / 3.0, 0.21, 16.0 + 24.0*uv.x, 0.30*blue);\n    sin_params[3] = params(amplitude, 1.2, 3.0 / 3.0, 0.16, 24.0 + 24.0*uv.x, 0.40*blue);\n    sin_params[4] = params(amplitude, 1.0, 4.0 / 3.0, 0.14, 16.0 + 24.0*uv.x, 0.50*blue);\n    sin_params[5] = params(amplitude, 1.3, 5.0 / 3.0, 0.18, 18.0 + 24.0*uv.x, 0.65*blue);\n  \n    // Create new \"layer\" for all the sine-waves and \"snakeheads\"\n    vec3 sinelayer = vec3(0,0,0);\n    \n    // For each Sine-Wave:\n    //   Create new \"layer\" (currentCol),\n    //   Calculate current Pixels vertical distance to sine-wave, \n    //   Add \"snakehead\",\n    //   Add current Layer to sinelayer.\n    //\n    for(int i = 0; i < sins_count; i++) {\n        \n        // Create new \"layer\"\n        vec3 currentCol = vec3(0,0,0);\n        \n        // Calculate color / intensity of color for current sine wave at the current time\n        vec3 sincol = sin_params[i].color * (0.9 + 0.2 * sin(iTime * 0.1 + float(i)));\n        //vec3 sincol = vec3(1,1,1) * 0.2;\n        \n        \n        // Calculate Sine-Power based on distance along x-axis\n        //sin_params[i].power = 12.0 + 80.0 * pow(uv.x, 4.0);\n        //sin_params[i].power *= 0.8 + 0.2 * sin(iTime);\n        sin_params[i].power = 40.0;\n        \n        // Calculate current Sine wave at the current distance along x-axis\n        sins[i] = 0.5 + calcSin(sin_params[i], uv.x);\n        \n        // Calculate position of \"Snakehead\"\n        sinheads[i] = 0.7\n                        + 0.10 * sin(0.05* iTime + 0.7 * float(i))\n                        + 0.05 * sin(0.1* iTime + 0.3 * float(i));\n\n        // Create Curve for the Brightness of the Sine-Curve based on current x-axis\n        float hori = 0.1 * pow(uv.x, 2.0) + 0.9;\n\n        vec2 sinhead_position = vec2(sinheads[i], (0.5 + calcSin(sin_params[i], sinheads[i])));\n\n        // If we are to the right of the \"snakehead\" of the current sine-wave\n        if (uv.x > sinheads[i]) {\n        \t\n            //hori -= clamp((uv.x - sinheads[i]) * 20.0, 0.01, .95);\n            \n            // Set Brightness for Sine-Wave to zero for it to not get rendered beyond the \"snakehead\"\n        \thori = 0.0;\n        \t\n            // Add glow around the sine-wave                                  \n            currentCol += clamp( pow( 1.0 - distance(uv, sinhead_position), sin_params[i].power), 0.0, 1.0) * sincol;\n            \n        }\n        \n        \n        \n        // Add Sine-Wave to current Layer\n        currentCol += clamp( pow( (1.0 - abs(uv.y - sins[i])), sin_params[i].power ) * hori, 0.0, 1.0) * sincol;\n        \n        \n        // Add a little more color to the \"Snakehead\"\n        currentCol *= 1.0 + 0.25 * clamp(1.0 - distance(sinhead_position, uv)*10.0, 0.0, 1.0);\n        currentCol += sincol * clamp(pow(1.0 - distance(sinhead_position, uv) * 10.0, 3.0) , 0.0, 1.0);\n        currentCol += sincol * clamp(pow(1.0 - distance(sinhead_position, uv) * 120.0, 3.0) , 0.0, 0.2);\n        currentCol *= 0.8 + .25 * clamp(1.0 - distance(sinhead_position, uv) * 19.0, 0.0, 1.5);\n        \n        \n        // Add current Layer to sinelayer\n        sinelayer += currentCol;\n    }\n    \n    //col = blend(col, sinelayer, 0.5);\n    //col = blend(vec3(0,0,0), col, clamp(.2+ length(sinelayer), 0.4, 1.0));\n    col *= 0.7;\n    col = blend(col, sinelayer * 2.0, 0.5);\n    \n    // Output to screen\n    //col = blend(col, col.zxy, 0.3);\n\n    float blendTime = 0.05 * iTime;\n\n    col = clamp(sin(blendTime), 0.0, 1.0) * col\n        + clamp(sin(blendTime + 2.0 * PI / 3.0), 0.0, 1.0) * col.zyx\n        + clamp(sin(blendTime + 4.0 * PI / 3.0), 0.0, 1.0) * col.xzy;\n    \n    \n    // Vignette\n    float minDistToBorder = min(min(fragCoord.x, fragCoord.y), min(iResolution.x - fragCoord.x, iResolution.y - fragCoord.y));\n    col *= clamp(blend(0.4, 1.0, pow(minDistToBorder / 80.0, 0.2)), 0.0, 1.0);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}