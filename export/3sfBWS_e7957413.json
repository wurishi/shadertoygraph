{"ver":"0.1","info":{"id":"3sfBWS","date":"1588915283","viewed":123,"name":"FXAA to hide discontinuities?","username":"mosaic","description":"Left is no FXAA, right is FXAA enabled \nThere's probably a better way to do this","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/4dfGDj\n// FXAA by Dave Hoskins, FXAA algorithm from NVIDIA :)\n// http://developer.download.nvidia.com/assets/gamedev/files/sdk/11/FXAA_WhitePaper.pdf\n\n#define FXAA_SPAN_MAX\t8.0\n#define FXAA_REDUCE_MUL 1.0/8.0\n#define FXAA_REDUCE_MIN 1.0/128.0\n\n//========================================================================================\nfloat Hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n//========================================================================================\nfloat Noise( in vec2 x )\n{\n\t\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\t\n   \tf = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    float res = mix(mix( Hash(n+  0.0), Hash(n+  1.0),f.x),\n                    mix( Hash(n+ 57.0), Hash(n+ 58.0),f.x),f.y);\n    return res;\n}\n\n//========================================================================================\nvec3 hsv(in float h) \n{\n\tif (h > .45 && h < .55) return vec3(1.0);\n\tvec3 rgb = clamp((abs(fract(h + vec3(3, 2, 1) / 3.0) * 6.0 - 3.0) - 1.0), 0.0 , 1.0);\n\treturn sqrt(rgb);\n}\n\n//========================================================================================\nvec3 old(vec2 p)\n{\n\tfloat t= sin(iTime*.03)*1.5;\n\tmat2 m = mat2(cos(t), sin(t), -sin(t), cos(t));\n\tp*= m;\n\tvec2 b = vec2(.6, .6);\n\tvec2 d = abs(p) - b;\n  \tfloat f = min(max(d.x, d.y),0.0) + length(max(d,0.0));\n\tfloat pix = Noise(p*20.0)*.29;\n\tif (f < pix && f > -pix) return hsv(Noise(p*33.0));\n\telse return vec3(0.0, 0.0, .0);\n}\n\nvec3 Box(vec2 uv)\n{\nfloat time1 = iTime/2.0;\n    float scale = 5.0;\n    vec2 col = (uv.yx*scale*(1.0+sin(uv.x+time1/10.)/2.0));\n    vec2 col2;\n    for(float i = 1.0; i < 4.0; i++){\n        uv += ceil(col+tan((col.x+col.y))/5.0);\n        col -= sin(uv.x+time1/10.);\n        col2 = (col2+col)/(i*i);\n    }\n    \n    // Output to screen\n    return vec3(col.y,col2.x,0.5);\n\n}\n\n\n\n//========================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\n\tif (abs(uv.x) < 3.0/iResolution.x) \n\t{\n\t\t// Centre line...\n\t\tfragColor = vec4(0.2, 0.0, 0.2, 1.0);\n\t\treturn;\n\t}\n\tif (uv.x < 0.0) \n\t{\n\t\t// No FXAA on left...\n\t\tuv.x = -uv.x;\n\t\tfragColor = vec4(Box(uv), 1.0);\n\t\treturn;\n\t}\n\tvec2 add = vec2(1.0) / iResolution.xy;\n\t\t\t\n\tvec3 rgbNW = Box(uv+vec2(-add.x, -add.y));\n\tvec3 rgbNE = Box(uv+vec2( add.x, -add.y));\n\tvec3 rgbSW = Box(uv+vec2(-add.x,  add.y));\n\tvec3 rgbSE = Box(uv+vec2( add.x,  add.y));\n\tvec3 rgbM  = Box(uv);\n\t\n\tvec3 luma\t = vec3(0.299, 0.587, 0.114);\n\tfloat lumaNW = dot(rgbNW, luma);\n\tfloat lumaNE = dot(rgbNE, luma);\n\tfloat lumaSW = dot(rgbSW, luma);\n\tfloat lumaSE = dot(rgbSE, luma);\n\tfloat lumaM  = dot(rgbM,  luma);\n\t\n\tfloat lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n\tfloat lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\t\n\tvec2 dir;\n\tdir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n\tdir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\t\n\t\n\tfloat dirReduce = max(\n\t\t(lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\t  \n\tfloat rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n\t\n\n\tdir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n\t\t  max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n\t\t  dir * rcpDirMin)) * add;\n\n\t\t\n\tvec3 rgbA = (1.0/2.0) * (Box(uv + dir * (1.0/3.0 - 0.5)) +\n\t\t\t\t\t\t\t Box(uv + dir * (2.0/2.0 - 0.5)));\n\t\n\tvec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) *\n\t\t(Box(uv.xy + dir * (0.0/3.0 - 0.5)) +\n\t\t Box(uv.xy + dir * (3.0/3.0 - 0.5)));\n\t\n\tfloat lumaB = dot(rgbB, luma);\n\tif((lumaB < lumaMin) || (lumaB > lumaMax))\n\t{\n\t\tfragColor.xyz=rgbA;\n\t}else\n\t{\n\t\tfragColor.xyz=rgbB;\n\t}\n}","name":"Image","description":"","type":"image"}]}