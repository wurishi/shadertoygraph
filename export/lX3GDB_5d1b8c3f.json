{"ver":"0.1","info":{"id":"lX3GDB","date":"1716939181","viewed":190,"name":"Two-Way CCD","username":"luckyballa","description":"My attempt at Two-Way Continuous Collision Handling \nhttps://arxiv.org/pdf/2211.04045\n\nI would be thankful if anyone could check math for me :)","likes":4,"published":1,"flags":0,"usePreview":1,"tags":["collision","simulation","detection","optimization","paper","continuous","ccd","gaussseidel","lcp","pgs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Given an intersection-free state X and a state Y, \n// the idea is to find an intersection-free state X+1 that is as close as possible to Y.\n\n// To solve this, some form of CCD is typically needed, \n// but classical methods involve solving cubic equations, \n// which are prone to floating-point errors and can be computationally expensive.\n\n// The paper suggests a two-way approach, solving the problem iteratively. \n// This involves a backward step that starts at Y and marches towards the constraint resolution of X, \n// producing Y_l by solving a Linear Complementarity Problem (LCP). \n// This is followed by a forward step that marches from X_l to Y_l with a safe step size, which guarantees a penetration-free state.\n\nvec4 update_distance(vec2 point, vec2 colliders[NUM_C], out float min_dist) {\n    min_dist = 99999.0;\n    vec4 min_edge = vec4(0.0);\n\n    for (int i = 0; i < NUM_C - 1; ++i) {\n        vec2 c0 = colliders[i];\n        vec2 c1 = colliders[i + 1];\n        float dist = sd_segment(point, c0, c1);\n\n        if (dist < min_dist) {\n            min_dist = dist;\n            min_edge = vec4(c0, c1);\n        }\n    }\n    return min_edge;\n}\n\nfloat contact_vertex_constraint_cost(vec2 x, vec2 c0, vec2 c1) {\n    vec2 uv;\n    vec2 closest_point = closest_point_on_line(x, c0, c1, uv);\n    float distance_to_closest = length(x - closest_point);\n    if (distance_to_closest != 0.0 && distance_to_closest < ACTIVATION_THRESHOLD) {\n        vec2 normal = (x - closest_point) / distance_to_closest;\n\n        vec2 r0 = x + (ACTIVATION_THRESHOLD - distance_to_closest) * normal;\n        float initial_area = triangle_area(x, c0, c1);\n        float target_area = triangle_area(r0, c0, c1);\n\n        float area_ratio = (target_area / initial_area) - 1.0;\n        return area_ratio;\n    } else {\n        return 0.0;\n    }\n}\n\nfloat contact_edge_constraint_cost(vec2 c, vec2 xi, vec2 xj) {\n    if (xj == vec2(-1.0, -1.0)) return 0.0;\n\n    vec2 uv;\n    vec2 closest_point = closest_point_on_line(c, xi, xj, uv);\n    float distance_to_closest = length(c - closest_point);\n    if (distance_to_closest != 0.0 && distance_to_closest < ACTIVATION_THRESHOLD) {\n        vec2 normal = (c - closest_point) / distance_to_closest;\n\n        vec2 ri = xi + (ACTIVATION_THRESHOLD - distance_to_closest) * normal * uv.x;\n        vec2 rj = xj + (ACTIVATION_THRESHOLD - distance_to_closest) * normal * uv.y;\n\n        float initial_area = triangle_area(c, xi, xj);\n        float target_area = triangle_area(c, ri, rj);\n\n        float area_ratio = (target_area / initial_area) - 1.0;\n        return area_ratio;\n    } else {\n        return 0.0;\n    }\n}\n\n\nfloat edge_length_constraint_cost(vec2 x0, vec2 x1, vec2 y0, vec2 y1) {\n    if (x1 == vec2(-1.0, -1.0) || y1 == vec2(-1.0, -1.0)) return 0.0;\n\n    float current_length = distance(x0, x1);\n    float target_length = distance(y0, y1);\n    if (target_length != 0.0) {\n        float length_ratio = current_length / target_length;\n        float cost = length_ratio - MAX_VIOLATION_RATIO;\n        return cost;\n    } else {\n        return 0.0;\n    }\n}\n\nvec2 contact_vertex_constraint_jacobian(vec2 x, vec2 c0, vec2 c1) {\n    vec2 dx = vec2(EPSILON, 0.0);\n    vec2 dy = vec2(0.0, EPSILON);\n\n    float cost_x_plus_dx = contact_vertex_constraint_cost(x + dx, c0, c1);\n    float cost_x_minus_dx = contact_vertex_constraint_cost(x - dx, c0, c1);\n    float cost_x_plus_dy = contact_vertex_constraint_cost(x + dy, c0, c1);\n    float cost_x_minus_dy = contact_vertex_constraint_cost(x - dy, c0, c1);\n\n    float jacobian_x = (cost_x_plus_dx - cost_x_minus_dx) / (2.0 * EPSILON);\n    float jacobian_y = (cost_x_plus_dy - cost_x_minus_dy) / (2.0 * EPSILON);\n\n    return vec2(jacobian_x, jacobian_y);\n}\n\nvec2 contact_edge_constraint_jacobian(vec2 c, vec2 xi, vec2 xj) {\n    if (xj == vec2(-1.0, -1.0)) return vec2(0.0);\n\n    vec2 dx = vec2(EPSILON, 0.0);\n    vec2 dy = vec2(0.0, EPSILON);\n\n    float cost_x_plus_dx = contact_edge_constraint_cost(c + dx, xi, xj);\n    float cost_x_minus_dx = contact_edge_constraint_cost(c - dx, xi, xj);\n    float cost_x_plus_dy = contact_edge_constraint_cost(c + dy, xi, xj);\n    float cost_x_minus_dy = contact_edge_constraint_cost(c - dy, xi, xj);\n\n    float jacobian_x = (cost_x_plus_dx - cost_x_minus_dx) / (2.0 * EPSILON);\n    float jacobian_y = (cost_x_plus_dy - cost_x_minus_dy) / (2.0 * EPSILON);\n\n    return vec2(jacobian_x, jacobian_y);\n}\n\nvec2 edge_length_constraint_jacobian(vec2 x0, vec2 x1, vec2 y0, vec2 y1) {\n    vec2 dx = vec2(EPSILON, 0.0);\n    vec2 dy = vec2(0.0, EPSILON);\n\n    float cost_x_plus_dx = edge_length_constraint_cost(x0 + dx, x1, y0, y1);\n    float cost_x_minus_dx = edge_length_constraint_cost(x0 - dx, x1, y0, y1);\n    float cost_x_plus_dy = edge_length_constraint_cost(x0 + dy, x1, y0, y1);\n    float cost_x_minus_dy = edge_length_constraint_cost(x0 - dy, x1, y0, y1);\n\n    float jacobian_x = (cost_x_plus_dx - cost_x_minus_dx) / (2.0 * EPSILON);\n    float jacobian_y = (cost_x_plus_dy - cost_x_minus_dy) / (2.0 * EPSILON);\n\n    return vec2(jacobian_x, jacobian_y);\n}\n\n\nfloat calculate_lambda(vec2 J, float c, vec2 y1_minus_xl) {\n    float rhs = c + dot(J, y1_minus_xl);\n    return max(0.0, rhs / (max(1e-6, dot(J, J))));\n}\n\nvec2 backward_step(vec2 x_l, vec2 y_l, vec2 y_1, vec4 closest_edge, vec4 x_neighbors, vec4 y_neighbors) {\n    vec2 y1_minus_xl = y_1 - x_l;\n\n    vec2 J_contact = contact_vertex_constraint_jacobian(x_l, closest_edge.xy, closest_edge.zw);\n    float c_contact = contact_vertex_constraint_cost(x_l, closest_edge.xy, closest_edge.zw);\n    float lambda_contact = calculate_lambda(J_contact, c_contact, y1_minus_xl);\n\n    vec2 contacts_direction = lambda_contact * J_contact;\n\n    // Pairs of closest edge vetices and neighbor edges\n    vec4 pairs[4] = vec4[](\n        vec4(closest_edge.xy, x_neighbors.xy),\n        vec4(closest_edge.zw, x_neighbors.xy),\n        vec4(closest_edge.xy, x_neighbors.zw),\n        vec4(closest_edge.zw, x_neighbors.zw)\n    );\n\n    for (int i = 0; i < 4; ++i) {\n        vec4 p = pairs[i];\n        vec2 J_contact_i = contact_edge_constraint_jacobian(p.xy, x_l, p.zw);\n        float c_contact_i = contact_edge_constraint_cost(p.xy, x_l, p.zw);\n        float lambda_contact_i = calculate_lambda(J_contact_i, c_contact_i, y1_minus_xl);\n        contacts_direction += lambda_contact_i * J_contact_i;\n    }\n\n    vec2 J_edge0 = edge_length_constraint_jacobian(x_l, x_neighbors.xy, y_1, y_neighbors.xy);\n    float c_edge0 = edge_length_constraint_cost(x_l, x_neighbors.xy, y_1, y_neighbors.xy);\n    float lambda_edge0 = calculate_lambda(J_edge0, c_edge0, y1_minus_xl);\n\n    vec2 J_edge1 = edge_length_constraint_jacobian(x_l, x_neighbors.zw, y_1, y_neighbors.zw);\n    float c_edge1 = edge_length_constraint_cost(x_l, x_neighbors.zw, y_1, y_neighbors.zw);\n    float lambda_edge1 = calculate_lambda(J_edge1, c_edge1, y1_minus_xl);\n\n    vec2 edges_direction = lambda_edge0 * J_edge0 + lambda_edge1 * J_edge1;\n\n    return y_1 - (contacts_direction + edges_direction);\n}\n\nvec2 forward_step(vec2 x_l, inout float r_l, vec2 step_direction, float cd) {\n    float damping = 0.5;\n    float step_size = min(0.5 * damping * cd, 1.0) / length(step_direction);\n    vec2 updated_x_l = x_l + step_size * step_direction;\n    r_l = r_l * (1.0 - step_size);\n    \n    return updated_x_l;\n}\n\nvec2[NUM_X] solve(vec2 initial_positions[NUM_X], vec2 target_positions[NUM_X], vec2 colliders[NUM_C], int iterations) {\n    vec2 next_positions[NUM_X];\n    vec2 current_positions[NUM_X];\n    float closest_distances[NUM_X];\n    float termination_values[NUM_X];\n\n    for (int i = 0; i < NUM_X; ++i) {\n        next_positions[i] = target_positions[i];\n        current_positions[i] = initial_positions[i];\n        closest_distances[i] = 999999.0;\n        termination_values[i] = 1.0;\n    }\n\n    for (int iter = 0; iter < iterations; iter++) {\n        for (int i = 0; i < NUM_X; i++) {\n            vec2 x_l = current_positions[i];\n            vec2 y_l = next_positions[i];\n            vec2 y_1 = target_positions[i];\n            float r_l = termination_values[i];\n\n            if (r_l < TERMINATION_THRESHOLD) continue;\n\n            float min_dist;\n            vec4 cvcd = update_distance(x_l, colliders, min_dist);\n            closest_distances[i] = min_dist;\n\n            vec4 current_neighbors = vec4(\n                i == NUM_X - 1 ? vec2(-1.0) : current_positions[i + 1],\n                i == 0 ? vec2(-1.0) : current_positions[i - 1]\n            );\n            vec4 next_neighbors = vec4(\n                i == NUM_X - 1 ? vec2(-1.0) : target_positions[i + 1],\n                i == 0 ? vec2(-1.0) : target_positions[i - 1]\n            );\n\n            y_l = backward_step(x_l, y_l, y_1, cvcd, current_neighbors, next_neighbors);\n            next_positions[i] = y_l;\n\n            current_positions[i] = forward_step(x_l, r_l, y_l - x_l, min_dist);\n            termination_values[i] = r_l;\n        }\n    }\n    \n    return current_positions;\n}\n\n\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    vec2 uv = (frag_coord - 0.5 * iResolution.xy) / iResolution.y + 0.5;\n\n    vec2 start_positions[NUM_X];\n    vec2 new_positions[NUM_X];\n    vec2 colliders[NUM_C];\n\n    for (int i = 0; i < NUM_X; i++) {\n        start_positions[i] = vec2(mix(-0.1, 1.1, float(i) / float(NUM_X)), 0.75);\n        new_positions[i] = vec2(mix(0.1, 0.9, float(i) / float(NUM_X)), 0.25);\n    }\n\n    for (int i = 0; i < NUM_C; i++) {\n        colliders[i] = vec2(mix(0.3, 0.7, float(i) / float(NUM_C)), 0.5 + sin((float(i) / float(NUM_C - 1)) * PI * 4.0) * 0.05);\n    }\n\n    vec2 updated_positions[NUM_X] = solve(start_positions, new_positions, colliders, (min((iFrame / 10) % 16, 8)));\n\n    vec3 col = vec3(0.8);\n\n    col = process_segments(uv, start_positions, col, vec3(1.0, 1.0, 1.0));\n    col = process_segments(uv, colliders, col, vec3(0.5));\n    col = process_segments(uv, new_positions, col, vec3(0.0, 0.0, 0.0));\n    col = process_segments(uv, updated_positions, col, vec3(1.0, 0.5, 0.0));\n\n    frag_color = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define NUM_X 8\n#define NUM_C 4\n\n#define EPSILON 1e-5\n#define PI 3.1415926535\n\n#define ACTIVATION_THRESHOLD 0.0333\n#define MAX_VIOLATION_RATIO 1.1\n#define TERMINATION_THRESHOLD 0.1\n\nfloat sd_segment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    vec2 r = pa - ba * h;\n    return length(r);\n}\n\nvec2 closest_point_on_line(vec2 p, vec2 e0, vec2 e1, out vec2 uv) {\n    vec2 segment_vector = e1 - e0;\n    vec2 point_vector = p - e0;\n    float projection = clamp(dot(point_vector, segment_vector) / dot(segment_vector, segment_vector), 0.0, 1.0);\n    vec2 closest_point = e0 + projection * segment_vector;\n    uv = vec2(projection, 1.0 - projection);\n    return closest_point;\n}\n\nfloat triangle_area(vec2 a, vec2 b, vec2 c) {\n    vec2 ab = b - a;\n    vec2 ac = c - a;\n    return abs(ab.x * ac.y - ab.y * ac.x) / 2.0;\n}\n\nvec2 triangle_area_grad(vec2 a, vec2 b, vec2 c, vec2 w) {\n    if (w == a) {\n        return vec2((b.y - c.y) / 2.0, (c.x - b.x) / 2.0);\n    } else if (w == b) {\n        return vec2((c.y - a.y) / 2.0, (a.x - c.x) / 2.0);\n    } else { // w == c\n        return vec2((a.y - b.y) / 2.0, (b.x - a.x) / 2.0);\n    }\n}\n\n\nvec3 process_segments(in vec2 uv, in vec2 points[NUM_X], vec3 c, vec3 color) {\n    float d = 99999.0;\n    for (int i = 0; i < NUM_X - 1; i++) {\n        float dist = sd_segment(uv, points[i], points[i + 1]);\n        d = min(d, dist);\n        d = min(d, length(uv - points[i]) - 0.01);\n        d = min(d, length(uv - points[i + 1]) - 0.01);\n    }\n    return mix(color, c, smoothstep(0.0, 0.001, d - 0.002));\n}\n\nvec3 process_segments(in vec2 uv, in vec2 points[NUM_C], vec3 c, vec3 color) {\n    float d = 99999.0;\n    for (int i = 0; i < NUM_C - 1; i++) {\n        float dist = sd_segment(uv, points[i], points[i + 1]);\n        d = min(d, dist);\n        d = min(d, length(uv - points[i]) - 0.01);\n        d = min(d, length(uv - points[i + 1]) - 0.01);\n    }\n    return mix(color, c, smoothstep(0.0, 0.001, d - 0.002));\n}\n\n\n\n\n\n/*\n// analytical derivatives\n\n/*\nvec2 contact_vertex_constraint_jacobian(vec2 x, vec2 c0, vec2 c1) {\n    vec2 uv;\n    vec2 closest_point = closest_point_on_line(x, c0, c1, uv);\n    float distance_to_closest = length(x - closest_point);\n    \n    if (distance_to_closest == 0.0 || distance_to_closest >= ACTIVATION_THRESHOLD) {\n        return vec2(0.0);\n    }\n    \n    vec2 normal = (x - closest_point) / distance_to_closest;\n    vec2 r0 = x + (ACTIVATION_THRESHOLD - distance_to_closest) * normal;\n\n    float initial_area = triangle_area(x, c0, c1);\n    float target_area = triangle_area(r0, c0, c1);\n\n    float area_ratio = (target_area / initial_area) - 1.0;\n\n    // Derivative of the area_ratio with respect to x\n    vec2 d_area_ratio_dx = (triangle_area_grad(r0, c0, c1, x) * (1.0 / initial_area) - \n                            triangle_area_grad(x, c0, c1, x) * (target_area / (initial_area * initial_area)));\n\n    return d_area_ratio_dx;\n}\n\nvec2 contact_edge_constraint_jacobian(vec2 c, vec2 xi, vec2 xj) {\n    if (xj == vec2(-1.0, -1.0)) return vec2(0.0);\n\n    vec2 uv;\n    vec2 closest_point = closest_point_on_line(c, xi, xj, uv);\n    float distance_to_closest = length(c - closest_point);\n    \n    if (distance_to_closest == 0.0 || distance_to_closest >= ACTIVATION_THRESHOLD) {\n        return vec2(0.0);\n    }\n    \n    vec2 normal = (c - closest_point) / distance_to_closest;\n    vec2 ri = xi + (ACTIVATION_THRESHOLD - distance_to_closest) * normal * uv.x;\n    vec2 rj = xj + (ACTIVATION_THRESHOLD - distance_to_closest) * normal * uv.y;\n\n    float initial_area = triangle_area(c, xi, xj);\n    float target_area = triangle_area(c, ri, rj);\n\n    float area_ratio = (target_area / initial_area) - 1.0;\n\n    // Derivative of the area_ratio with respect to c\n    vec2 d_area_ratio_dc = (triangle_area_grad(c, ri, rj, c) * (1.0 / initial_area) - \n                            triangle_area_grad(c, xi, xj, c) * (target_area / (initial_area * initial_area)));\n\n    return d_area_ratio_dc;\n}\n\nvec2 edge_length_constraint_jacobian(vec2 x0, vec2 x1, vec2 y0, vec2 y1) {\n    if (x1 == vec2(-1.0, -1.0) || y1 == vec2(-1.0, -1.0)) return vec2(0.0);\n\n    float current_length = distance(x0, x1);\n    float target_length = distance(y0, y1);\n\n    if (target_length == 0.0) {\n        return vec2(0.0);\n    }\n\n    float length_ratio = current_length / target_length;\n    float cost = length_ratio - MAX_VIOLATION_RATIO;\n\n    // Derivative of the cost with respect to x0\n    vec2 d_cost_dx0 = (x0 - x1) / (target_length * current_length);\n\n    return d_cost_dx0;\n}\n*/","name":"Common","description":"","type":"common"}]}