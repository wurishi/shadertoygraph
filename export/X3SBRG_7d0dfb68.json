{"ver":"0.1","info":{"id":"X3SBRG","date":"1729570949","viewed":25,"name":"3cylinder_sdf_test","username":"doomsky","description":"3 cylinder cross shape","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n\nmat3 rotateX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        1, 0, 0,\n        0, c, -s,\n        0, s, c\n    );\n}\n\nmat3 rotateY(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, 0, s,\n        0, 1, 0,\n        -s, 0, c\n    );\n}\n\nmat3 rotateZ(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, -s, 0,\n        s, c, 0,\n        0, 0, 1\n    );\n}\n    \n\nfloat cylinderX(vec3 p, float r, float h) {\n    return max(abs(p.y) - h, length(p.xz) - r);\n}\n\nfloat cylinderY(vec3 p, float r, float h) {\n    return max(abs(p.x) - h, length(p.yz) - r);\n}\n\nfloat cylinderZ(vec3 p, float r, float h) {\n    return max(abs(p.z) - h, length(p.xy) - r);\n}\n\nfloat sdf(vec3 p) {\n    mat3 rot = rotateX(iTime * 0.5) * rotateY(iTime * 0.3) * rotateZ(iTime * 0.7);\n    p = rot * p;\n    float r = 0.5;\n    float h = 1.0;\n    \n    float cx = cylinderX(p, r, h);\n    float cy = cylinderY(p, r, h);\n    float cz = cylinderZ(p, r, h);\n    \n    return max(cx, max(cy, cz));\n}\n\nvec3 calcNormal(in vec3 p) {\n    const vec2 h = vec2(EPSILON, 0);\n    return normalize(vec3(\n        sdf(p + h.xyy) - sdf(p - h.xyy),\n        sdf(p + h.yxy) - sdf(p - h.yxy),\n        sdf(p + h.yyx) - sdf(p - h.yyx)\n    ));\n}\n\n/**\n * 中心位于原点半径为1的球体的符号距离函数定义\n */\nfloat sphereSDF(vec3 samplePoint) {\n    return length(samplePoint) - 1.0;\n}\n\n/**\n * 用SDF描述场景\n */\nfloat sceneSDF(vec3 samplePoint) {\n    //return sphereSDF(samplePoint);\n    return sdf(samplePoint);\n}\n\n/**\n * 返回最短距离函数\n * \n * eye: 射线的起点，可理解为相机\n * marchingDirection: 射线的标准化方向向量\n * start: 从相机开始的最短距离\n * end: 最远距离\n */\nvec4 shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn vec4(eye + depth * marchingDirection, dist);\n        }\n        depth += dist;\n        if (depth >= end) {\n            return vec4(0, 0, 0, end);\n        }\n    }\n    return vec4(0, 0, 0, end);\n}\n            \n\n/**\n * 返回相机的标准化方向向量\n * \n * fieldOfView: 垂直视野的角度\n * size: 输出图像的分辨率\n * fragCoord: 输出图像中的像素坐标\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //vec3 ro = vec3(1.5 * sin(iTime), 1.5 * cos(iTime), -5);\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = rayDirection(45.0, iResolution.xy, fragCoord);\n    \n    vec4 result = shortestDistanceToSurface(ro, rd, MIN_DIST, MAX_DIST);\n    \n    vec3 col = vec3(0);\n    if (result.w < 50.0) {\n        vec3 p = result.xyz;\n        vec3 n = calcNormal(p);\n        vec3 lightDir = normalize(vec3(1, 1, 1));\n        \n        float diff = clamp(dot(n, lightDir), 0.0, 1.0);\n        float spec = pow(clamp(dot(reflect(-lightDir, n), -rd), 0.0, 1.0), 32.0);\n        \n        col = vec3(1, 0, 0) * diff + vec3(1) * spec;\n        //col = vec3(1, 0, 0);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}