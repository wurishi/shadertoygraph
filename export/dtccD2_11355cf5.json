{"ver":"0.1","info":{"id":"dtccD2","date":"1699650488","viewed":44,"name":"Clump of cells","username":"rfkjqrokad","description":"Generates a clump of cells using a mix of voronoi and worley noise. The cells can be individually customized. Fairly efficient and seems very fast.\n\nThe cell noise function conveinently generates normal values for that point as well.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","worley","cells","clump"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n\n\nvec2 rotate(vec2 vec, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    mat2 rotationMatrix = mat2(c, -s, s, c);\n    return rotationMatrix * vec;\n}\n\nfloat hash(vec3 p3) {\n    //this is from https://www.shadertoy.com/view/4djSRW\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yxx) * p3.zyx).x;\n\n}\n\nfloat achnoise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 fr = smoothstep(0.0, 1.0, fract(x));\n    vec3 LBZ = p + vec3(0.0, 0.0, 0.0);\n    vec3 LTZ = p + vec3(0.0, 1.0, 0.0);\n    vec3 RBZ = p + vec3(1.0, 0.0, 0.0);\n    vec3 RTZ = p + vec3(1.0, 1.0, 0.0);\n\n    vec3 LBF = p + vec3(0.0, 0.0, 1.0);\n    vec3 LTF = p + vec3(0.0, 1.0, 1.0);\n    vec3 RBF = p + vec3(1.0, 0.0, 1.0);\n    vec3 RTF = p + vec3(1.0, 1.0, 1.0);\n\n    float l0candidate1 = hash(LBZ);\n    float l0candidate2 = hash(RBZ);\n    float l0candidate3 = hash(LTZ);\n    float l0candidate4 = hash(RTZ);\n\n    float l0candidate5 = hash(LBF);\n    float l0candidate6 = hash(RBF);\n    float l0candidate7 = hash(LTF);\n    float l0candidate8 = hash(RTF);\n\n    float l1candidate1 = mix(l0candidate1, l0candidate2, fr[0]);\n    float l1candidate2 = mix(l0candidate3, l0candidate4, fr[0]);\n    float l1candidate3 = mix(l0candidate5, l0candidate6, fr[0]);\n    float l1candidate4 = mix(l0candidate7, l0candidate8, fr[0]);\n\n\n    float l2candidate1 = mix(l1candidate1, l1candidate2, fr[1]);\n    float l2candidate2 = mix(l1candidate3, l1candidate4, fr[1]);\n\n\n    float l3candidate1 = mix(l2candidate1, l2candidate2, fr[2]);\n\n    return l3candidate1;\n}\n\nfloat snoise(vec3 p) {\n\n    float a = achnoise(p);\n    float b = achnoise(p + 120.5);\n    return (a + b) * 0.5;\n}\n\n\nfloat getSmoothNoiseAt(vec3 pos, int layers, float periodExpo,\n    float persistance) {\n\n    float total = 0.;\n    float frequency = 1.;\n    float amplitude = 1.;\n    float maxValue = 0.; // Used for normalizing result to 0.0 - 1.0\n\n    for (int i = 0; i < layers; i++) {\n        total += snoise(pos * frequency) * amplitude;\n\n        maxValue += amplitude;\n\n        amplitude *= persistance;\n        frequency *= periodExpo;\n    }\n\n    return (total / maxValue) * 2. - 1.;\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n\nfloat minkowskiDistance(vec2 a, float p) {\n    return pow(pow(abs(a.x), p) + pow(abs(a.y), p), 1.0 / p);\n}\n\nfloat manhattanDistance(vec2 a) {\n    // Assuming a and b are vectors of the same length\n    return abs(a.x) + abs(a.y);\n}\n\n// vec3[0] = normal.xyz\n// vec3[1] = vec3(pointCenterX, pointCenterY, cellID)\nvec3[2] cellNoise(float minDist, float seed, vec2 pos, float time, float scale, float limits, float size) {\n\n    float distToCenter = length(pos);\n    vec2 i_pos = floor(pos * scale); // grid pos of position\n    vec2 f_pos = pos * scale - i_pos; // position inside of grid\n\n    vec2 intersectPos = vec2(0);\n    vec2 cellCenter = vec2(0);\n    float start = minDist;\n    bool found = false;\n    float cellID = 0.;\n    for (int y = -1; y <= 1; y++) {\n        for (int x = -1; x <= 1; x++) {\n            vec2 neighbor = vec2(float(x), float(y));\n\n            vec2 grid = neighbor + i_pos;\n            if (length(grid) > limits * scale)\n                continue;\n\n            vec2 point = random2(grid);\n\n            point = 0.5 + 0.5 * sin(time + 6.2831 * point);\n\n            vec2 diff = neighbor + point - f_pos;\n\n            float dist = length(diff) / size;\n\n\n            if (dist < minDist) {\n                //minDist = dist;\n                float v = 1.0 + 0.6 * getSmoothNoiseAt(vec3(diff * 2., 0.), 1, 2.0, 0.5);\n                minDist = pow(dist, v);\n                found = true;\n                intersectPos = diff; // point relative to dome center\n                cellCenter = grid + point;\n                cellID = grid.x * 100. + grid.y;\n            }\n\n        }\n    }\n\n    vec3 arr[2];\n    arr[0] = vec3(0);\n    arr[1] = vec3(0);\n    if (!found)\n        return arr;\n        \n    vec2 noisePos = rotate(intersectPos, sin(cellID + time / 5. * 3.14));\n\n    float value = sqrt(1.0 - (minDist * minDist));\n    float cellDetail = 1.0 + 0.25 *\n        getSmoothNoiseAt(vec3(noisePos.x * 12.0, noisePos.y * 12.0, cellID + time / 3.0), 2, 3.0, 0.5);\n\n    arr[0] = vec3(intersectPos, value * cellDetail);\n    arr[1] = vec3(cellCenter, cellID);\n\n    return arr;\n}\n\nvec3 calculateSpecular(vec3 normal, vec3 lightDir, vec3 viewDir, float shininess, float e) {\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float specular = max(dot(viewDir, reflectDir), 0.0);\n    specular = pow(specular, e);\n    return shininess * specular * vec3(1.0); // You can multiply by a specular color if needed\n}\n\nvec3 getColorNoise(float seed, float intensity) {\n    vec3 col = 1.0 + (cos(-seed/5.+vec3(0,2,4))) * intensity;\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1) so that 0,0 is center\n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y; // fix aspect ratio\n    float ar = 1.0 / iResolution.y;\n\n    float worleyScale = 5.;\n    const float worleyLimits = 1.f;\n    const float worleyMinDist = 0.8f;\n    const vec3 lightDirection = vec3(1., -1., 1.0);\n    float worleyTime = iTime / 1.;\n    const float worleySize = 1.0;\n    \n    // get celldata for this point\n    vec3[2] cellVectors = cellNoise(worleyMinDist, 1234., uv, worleyTime, worleyScale, worleyLimits, worleySize);\n    vec3 normal = cellVectors[0];\n    float cellValue = normal.z; // not technically height but it works\n    float cellID = cellVectors[1].z;\n    \n    // if it is near enough to center to render\n    if(cellValue > 0.) {\n        vec3 col = (0.5 + 0.5*cos(-iTime/5.+vec3(0,2,4))) * 0.75;\n    \n        \n        float lambertian = 0.5 + 0.5 * max(dot(normal, lightDirection) + 1.0, 0.0); // lambertian lighting\n        vec3 colorNoise = getColorNoise(cellID, 0.1 * (1.7-length(col))); // this modifies their color slightly for each cell\n        vec3 specular = calculateSpecular(\n            normal, lightDirection, vec3(0, 0, 1), 0.001, 8.);\n       \n        //col = vec3(0.1, 0.6, 0.8);\n        col *= colorNoise; \n        col *= lambertian; // apply lighting\n        col *= cellValue; // add a bit more depth\n        col += specular; // make it shiny\n\n        fragColor = vec4(col, 1.0);\n    }\n    else {\n        fragColor = vec4(vec3(0), 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}