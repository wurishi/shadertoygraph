{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"music","id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//My first attempt to raytracing.\n//Done following the live by IÃ±igo Quilez stream at http://youtu.be/9g8CdctxmeU\n//Thanks a lot for sharing your knowledge.\n\n//Light setup\nvec3 light;\n//vec3 light = vec3(1.0 + iMouse.x, iMouse.y, -4.0);\nfloat light_range = 10.0;\n\nfloat shadow_factor = 1.0;\n\n//Object setup\nvec4 sph1 = vec4( 0.0, 1.0, 0.0, 1.0);\nvec4 sph2 = vec4( 2.0, 1.5, -1.0, 1.5);\n//Functions \n\nfloat iSphere(in vec3 ro, in vec3 rd, in vec4 sph)\n{\n\t//sphere at origin has equation |xyz| = r\n\t//sp |xyz|^2 = r^2.\n\t//Since |xyz| = ro + t*rd (where t is the parameter to move along the ray),\n\t//we have ro^2 + 2*ro*rd*t + t^2 - r2. This is a quadratic equation, so:\n\tvec3 oc = ro - sph.xyz; //distance ray origin - sphere center\n\t\n\tfloat b = 2.0 * dot(oc, rd);\n\tfloat c = dot(oc, oc) - sph.w * sph.w; //sph.w is radius\n\tfloat h = b*b - 4.0 * c; //Commonly known as delta. The term a is 1 so is not included.\n\tif(h < 0.0) \n\t\treturn -1.0;\n\tfloat t = (-b - sqrt(h)) / 2.0; //Again a = 1.\n\n\treturn t;\n}\n\n//Get sphere normal.\nvec3 nSphere(in vec3 pos, in vec4 sph )\n{\n\treturn (pos - sph.xyz)/sph.w;\n}\n\n//Intersection with plane.\nfloat iPlane(in vec3 ro, in vec3 rd)\n{\n\t\n\t\n\t//Plane equation, y = 0 = ro.y + t * rd.y;\n\tfloat t = (-ro.y / rd.y);\n\treturn t;\n}\n\n//Get plane normal.\nvec3 nPlane(in vec3 pos)\n{\n\treturn vec3(0.0, 1.0, 0.0);\n}\n\n//Check if the pixel is in shadow.\nvoid inShadow(in vec3 hitpoint)\n{\n\tfloat resT = 1000.0;\n\t\n\tvec3 rd = normalize(light - hitpoint);\n\t\n\tfloat tsph1 = iSphere(hitpoint, rd, sph1);\n\tfloat tsph2 = iSphere(hitpoint, rd, sph2); //Invisible sphere casting shadow\n\tfloat tpla = iPlane(hitpoint , rd); //Intersect with a plane.\n\t\n\tfloat sph1shdw = 1.0;\n\tfloat sph2shdw = 1.0;\n\tif(tsph1 > 0.001 && tsph1 < resT)\n\t{\n\t\t//vec3 occluder = hitpoint + tsph * rd;\n\t\tsph1shdw = smoothstep(0.2, 1.0, smoothstep(0.0, 20.0,length(light - hitpoint)));\n\t\t//shadow_factor = max(0.2, 2.0 * length(light - hitpoint) / length(occluder - hitpoint));\n\t}\n\tif(tsph2 > 0.001 && tsph2 < resT)\n\t{\n\t\tsph2shdw = smoothstep(0.0, 1.0, smoothstep(0.0, 20.0, length(light - hitpoint) * 0.6));\n\t\t//vec3 occluder = hitpoint + tsph * rd;\n\t\t//shadow_factor = smoothstep(0.2, shadow_factor,  smoothstep(0.0, 20.0, length(light - hitpoint)));\n\t\t//shadow_factor = max(0.2, 2.0 * length(light - hitpoint) / length(occluder - hitpoint));\n\t}\n\tif(tpla > 0.5 && tpla < resT)\n\t{\n\t\t//vec3 occluder = hitpoint + tsph * rd;\n\t\t//shadow_factor = smoothstep(0.0, 20.0, length(light - hitpoint)) * 0.6;\n\t}\n\t\n\tshadow_factor = min(shadow_factor, min(sph1shdw, sph2shdw));\n}\n\nfloat intersect(in vec3 ro, in vec3 rd, out float resT)\n{\n\tresT = 1000.0;\n\tfloat id = -1.0;\n\tfloat tsph = iSphere(ro, rd, sph1); //Intersect with a sphere.\n\tfloat tsph2 = iSphere(ro, rd, sph2); //Intersect with a sphere.\n\tfloat tpla = iPlane(ro , rd); //Intersect with a plane.\n\t\n\tif(tsph > 0.0)\n\t{\n\t\tid = 1.0;\n\t\tresT = tsph;\n\t\t//inShadow(ro + resT * rd);\n\t}\n\tif(tsph2 > 0.0 && tsph2 < resT)\n\t{\n\t\tid = 3.0;\n\t\tresT = tsph2;\n\t\t//inShadow(ro + resT * rd);\n\t}\n\tif(tpla > 0.0 && tpla < resT)\n\t{\n\t\tid = 2.0;\n\t\tresT = tpla;\n\t\t\n\t}\n\tinShadow(ro + resT * rd);\n\treturn id;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tlight = vec3(cos(iTime) * 5.0, 5.0 + cos(iTime) * 2.0, 5.0);//normalize( vec3(0.57703));\n\n\t\n\t//pixel coordinates from 0 to 1\n\tvec2 uv = (fragCoord.xy / iResolution.xy);\n\t\n\t//Move the sphere\n\tsph1.x = 0.5 * cos(iTime * 10.0) * texture(iChannel1, mod(vec2(iChannelTime[1]), 1.0)).x;\n\t//sph1.z = 0.5 * sin(iTime)* texture(iChannel1, mod(vec2(iChannelTime[1]), 1.0)).y;\n\t\n\t//generate a ray with origin ro and direction rd\n\tvec3 ro = vec3(0.0, 0.5, 3.0);\n\tvec3 rd = normalize(vec3( (-1.0+2.0*uv) * vec2(1.78, 1.0), -1.0));\n\n\t//intersect the ray with scene\n\tfloat t;\n\tfloat id = intersect(ro, rd, t);\n\t\n\tvec3 col = vec3(0.7); \n\t//Need some lighting and, so, normals.\n\tif(id > 0.5 && id < 1.5)\n\t{\n\t\t//If we hit the spehere\n\t\tvec3 pos = ro + t*rd;\n\t\tvec3 nor = nSphere(pos, sph1);\n\t\tfloat dif = max(0.0, dot(nor, normalize(light - pos))); //diffuse.\n\t\t\n\t\tfloat attenuation = 1.0 - smoothstep(0.0, light_range, length(light - pos));\n\t\tdif *= attenuation;\n\t\t\n\t\tfloat ao = 0.5 + 0.5 * nor.y;\n\t\t//ao = 0.5 * (dot(nor, nPlane(pos)) + 1.0); complete formula. The one above is simplified.\n\t\tcol = vec3(0.9, 0.8, 0.6) * dif * ao + vec3(0.1, 0.2, 0.4) * ao;\n\t}\n\telse if(id > 1.5 && id < 2.5)\n\t{\n\t\t//If we hit the plame\n\t\t//t += clamp(-1.0, 0.0, 0.2 + 0.8 * cos(iChannelTime[1])) + uv.x + uv.y * 2.0 + cos(iTime);\n\t\tvec3 pos = ro + t * rd;\n\t\tvec3 nor = nPlane( pos );\n\t\t//float dif = max(0.0, dot(nor, light));\n\t\t\n\t\tfloat amb = min(smoothstep( 0.0, 2.0 * sph1.w, length(pos.xz - sph1.xz) ),\n\t\t\t\t\t\tsmoothstep( 0.0, 2.0 * sph2.w, length(pos.xz - sph2.xz) ));\n\t\tcol = vec3(amb * 0.7  * texture(iChannel0, mod(vec3(ro + rd * t).xz, 0.0) + vec2(cos(iTime), iTime)).xyz);\n\t}\n\telse if(id > 2.5)\n\t{\n\t\t//If we hit the spehere\n\t\tvec3 pos = ro + t*rd;\n\t\tvec3 nor = nSphere(pos, sph1);\n\t\tfloat dif = max(0.0, dot(nor, normalize(light - pos))); //diffuse.\n\t\t\n\t\tfloat attenuation = 1.0 - smoothstep(0.0, light_range, length(light - pos));\n\t\tdif *= attenuation;\n\t\t\n\t\tfloat ao = 0.5 + 0.5 * nor.y;\n\t\t//ao = 0.5 * (dot(nor, nPlane(pos)) + 1.0); complete formula. The one above is simplified.\n\t\tcol = vec3(0.7, 0.5, 0.8) * dif * ao + vec3(0.1, 0.2, 0.4) * ao;\n\t}\n\tcol *= shadow_factor;\n\t\n\tcol = sqrt(col);\n\t\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lds3zn","date":"1361891684","viewed":620,"name":"Ray tracing test","username":"MarkSkyzoid","description":"Just my first attemp to raytracing.\nI came up with a simple shadowing technique that seems to work (probably widely used, but I didn't any research about it), though it suffers acne.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","simple"],"hasliked":0,"parentid":"","parentname":""}}