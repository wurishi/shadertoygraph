{"ver":"0.1","info":{"id":"MXXcR4","date":"1725906504","viewed":34,"name":"Cup of soup","username":"AstronomicTelescope","description":"A cup of borsch.\nCouldn't make the cup orange :(\nBut the light source is orange. That is great!","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3  eye      = vec3 ( 0, 0, 5 );\nconst vec3  light    = vec3  ( 0.0, 3.0, 5.0 );\nconst int   maxSteps = 70;\nconst float eps      = 0.01;\nconst float pi    = 3.1415926;\n\nconst vec3  cupClr  = vec3 ( 1, 0.3, 0 );\nconst vec3 soupClr = vec3(0.6, 0.2, 0);\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, s, 0),\n        vec3(-s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\nfloat smin ( float a, float b, float k )\n{\n\tfloat res = exp ( -k*a ) + exp ( -k*b );\n\treturn -log ( res ) / k;\n}\n\nfloat sdCutSphere( vec3 p, float r, float h )\n{\n  // sampling independent computations (only depend on shape)\n  float w = sqrt(r*r-h*h);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float s = max( (h-r)*q.x*q.x+w*w*(h+r-2.0*q.y), h*q.x-w*q.y );\n  return (s<0.0) ? length(q)-r :\n         (q.x<w) ? h - q.y     :\n                   length(q-vec2(w,h));\n}\n\n// Функция не работает...\nfloat sdDiff(float srcdist, float subdist) {\n    // Представим себе летящий луч, пересекающий фигуры.\n    // -->->- src ->D>- sub\n    //   Норм, возвращаем src.\n    // -->->- src = sub\n    //   Не понятно :( :( :( Не понятно, беру с лекции.\n    // -->->- sub ->D>- dst\n    //   Возвращаем dst.\n    // Ограничение -- вся фигура sub лежит в src,\n    //   т.к. мы продвигаемся по лучу до окончания фигуры\n  \n   return max(-subdist, srcdist);\n}\n/*\nfloat sdf ( in vec3 p, in mat3 m )\n{\n   vec3 q = m * p;\n   \n   float base = sdDiff(sdCutSphere(q, 1.0, -1.0), sdCutSphere(q, 1.0, 0.3));\n   float inner = sdCutSphere(q, 0.9, -0.9);\n   float result = sdDiff(base, inner);\n   return sdCutSphere(q, 1.0, 0.3);\n}\n*/\n\n\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n  // sampling independent computations (only depend on shape)\n  float w = sqrt(r*r-h*h);\n  \n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                          abs(length(q)-r) ) - t;\n}\n\nfloat sdCappedTorus( vec3 p, vec2 sc, float ra, float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdf ( in vec3 p, in mat3 m, out vec3 clr )\n{\n   //m = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n   vec3 realpnt = m * p;\n   float base = sdCutHollowSphere(realpnt, 1.0, 0.4, 0.1);\n   \n   float result = base;\n\n   // Дополнительно вращаем экран, чтобы получить \n   //   разрвернутую фигуру.\n   mat3 rotViewHandle1 = rotateZ(0.5 * pi);\n   vec3 offsetViewHandle1 = vec3(0.0, -1.0, 0.0);\n   realpnt = rotViewHandle1 * m * p + offsetViewHandle1;\n   float handle1 = sdCappedTorus(realpnt, vec2(1.0, 0.0), 0.3, 0.05);\n   result = min(result, handle1);\n\n   // Дополнительно вращаем экран, чтобы получить \n   //   разрвернутую фигуру.\n   mat3 rotViewHandle2 = rotateZ(-0.5 * pi);\n   vec3 offsetViewHandle2 = vec3(0.0, -1.0, 0.0);\n   realpnt = rotViewHandle2 * m * p + offsetViewHandle2;\n   float handle2 = sdCappedTorus(realpnt, vec2(1.0, 0.0), 0.3, 0.05);\n   result = min(result, handle2);\n   \n   mat3 rotViewSoup = rotateX(pi);\n   realpnt = rotViewSoup * m * p;\n   // Заполняется снова за 5 секунд.\n   float soup = sdCutSphere(realpnt, 1.0, max(0.0, sin(iTime * 2.0 * pi / 5.0)));\n   if (soup < result) {\n       clr = soupClr;\n   } else {\n       clr = cupClr;\n   }\n   result = min(result, soup);\n   \n   return result;\n}\n\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m, out vec3 clr )\n{\n\tvec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = false;\n\t\n\tfor ( int steps = 0; steps < maxSteps; steps++ )\n\t{\n\t\tfloat\tdist = sdf ( p, m, clr );\n        \n\t\tif ( dist < 0.01 )\n\t\t{\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttotalDist += dist;\n\t\t\n\t\tif ( totalDist > 10.0 )\n\t\t\tbreak;\n\t\t\t\n\t\tp += dist * dir;\n\t}\n\t\n\treturn p;\n}\n\nvec3 generateNormal ( vec3 z, float d, in mat3 m )\n{\n    float e   = max (d * 0.5, eps );\n    vec3 clr = vec3(0.0, 0.0, 0.0);\n    float dx1 = sdf(z + vec3(e, 0, 0), m, clr);\n    float dx2 = sdf(z - vec3(e, 0, 0), m, clr);\n    float dy1 = sdf(z + vec3(0, e, 0), m, clr);\n    float dy2 = sdf(z - vec3(0, e, 0), m, clr);\n    float dz1 = sdf(z + vec3(0, 0, e), m, clr);\n    float dz2 = sdf(z - vec3(0, 0, e), m, clr);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\nconst float roughness = 0.2;\nconst vec3  r0   = vec3 ( 1.0, 0.92, 0.23 );\nconst float gamma = 2.2;\nconst float FDiel = 0.04;\t\t// Fresnel for dielectrics\n\nvec3 fresnel ( in vec3 f0, in float product )\n{\n\tproduct = clamp ( product, 0.0, 1.0 );\t\t// saturate\n\t\n\treturn mix ( f0, vec3 (1.0), pow(1.0 - product, 5.0) );\n}\n\nfloat D_blinn(in float roughness, in float NdH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float n = 2.0 / m2 - 2.0;\n    return (n + 2.0) / (2.0 * pi) * pow(NdH, n);\n}\n\nfloat D_beckmann ( in float roughness, in float NdH )\n{\n\tfloat m    = roughness * roughness;\n\tfloat m2   = m * m;\n\tfloat NdH2 = NdH * NdH;\n\t\n\treturn exp( (NdH2 - 1.0) / (m2 * NdH2) ) / (pi * m2 * NdH2 * NdH2);\n}\n\nfloat D_GGX ( in float roughness, in float NdH )\n{\n\tfloat m  = roughness * roughness;\n\tfloat m2 = m * m;\n\tfloat NdH2 = NdH * NdH;\n\tfloat d  = (m2 - 1.0) * NdH2 + 1.0;\n\t\n\treturn m2 / (pi * d * d);\n}\n\nfloat G_schlick ( in float roughness, in float nv, in float nl )\n{\n    float k = roughness * roughness * 0.5;\n    float V = nv * (1.0 - k) + k;\n    float L = nl * (1.0 - k) + k;\n\t\n    return 0.25 / (V * L);\n}\n\nfloat G_neumann ( in float nl, in float nv )\n{\n\treturn nl * nv / max ( nl, nv );\n}\n\nfloat G_klemen ( in float nl, in float nv, in float vh )\n{\n\treturn nl * nv / (vh * vh );\n}\n\nfloat G_default ( in float nl, in float nh, in float nv, in float vh )\n{\n\treturn min ( 1.0, min ( 2.0*nh*nv/vh, 2.0*nh*nl/vh ) );\n}\n\nvec4 cookTorrance ( in vec3 p, in vec3 n, in vec3 l, in vec3 v, in vec3 clr )\n{\n    vec3  h    = normalize ( l + v );\n\tfloat nh   = dot (n, h);\n\tfloat nv   = dot (n, v);\n\tfloat nl   = dot (n, l);\n\tfloat vh   = dot (v, h);\n    float metallness = 1.0;\n    vec3  base  = pow ( clr, vec3 ( gamma ) );\n    vec3  F0    = mix ( vec3(FDiel), clr, metallness );\n\t\n\t\t\t// compute Beckman\n   \tfloat d = D_beckmann ( roughness, nh );\n\n            // compute Fresnel\n    vec3 f = fresnel ( F0, nv );\n\t\n            // default G\n    float g = G_default ( nl, nh, nv, vh );\n\t\n\t\t\t// resulting color\n\tvec3  ct   = f*(0.25 * d * g / nv);\n\tvec3  diff = max(nl, 0.0) * ( vec3 ( 1.0 ) - f ) / pi;\n\tfloat ks   = 0.5;\n\n\treturn vec4 ( pow ( diff * base + ks * ct, vec3 ( 1.0 / gamma ) ), 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n        // Normalized pixel coordinates (from 0 to 1)\n    bool hit;\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n    // Повернем кружку дном вниз. Просто добавим к mouse.x так,\n    //   чтобы картинка повернулась по y на pi.\n    //   Поведение прокрутки не изменится, почти все значения\n    //   синуса все так же будут пробегаться (все бы, почти все,\n    //   пробегались, если бы была формула pi * mouse.y).\n    mouse.y += pi / 6.0; // Повернем кружку дном вниз :)\n    mat3 m     = rotateX ( 6.0*mouse.y ) * rotateY ( 6.0*mouse.x);\n    vec2 scale = 9.0 * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n\tvec3 dir   = normalize ( vec3 ( uv, 0 ) - eye );\n    vec4 color = vec4 ( 0, 0, 0, 1 );\n    \n    vec3 clr = vec3(0, 0, 0);\n    vec3 p     = trace ( eye, dir, hit, m, clr );\n\n\n\tif ( hit )\n\t{\n\t\tvec3  l  = normalize        ( light - p );\n        vec3  v  = normalize        ( eye - p );\n\t\tvec3  n  = generateNormal   ( p, 0.001, m );\n\t\tfloat nl = max ( 0.0, dot ( n, l ) );\n        vec3  h  = normalize ( l + v );\n        float hn = max ( 0.0, dot ( h, n ) );\n        float sp = pow ( hn, 150.0 );\n\t\t\n        color = cookTorrance ( p, n, l, v, clr );\n\t} \n\n        // Output to screen\n    fragColor = color * 3.0;\n}\n\n\n","name":"Image","description":"","type":"image"}]}