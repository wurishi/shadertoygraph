{"ver":"0.1","info":{"id":"lsc3zS","date":"1450471985","viewed":192,"name":"Learning 2 March Like a Ray","username":"megaloler","description":"i'm\nlearning :'D\nthis is my third attempt from scratch and apply newly learned things\ni still have a lot to learn >v>","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","test","ray","raymarch","experiment","marching","learning","march","learn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"float dstSphere(vec3 p, vec3 spherePos, float radius)\n{\n    return distance(p, spherePos) - radius;\n}\n\nfloat dstBox(vec3 p, vec3 boxPos, vec3 boxSiz)\n{\n    vec3 dst = abs(p - boxPos) - boxSiz;\n    return length(max(vec3(0.0), dst)) + min(0.0, max(dst.x, max(dst.y, dst.z)));\n}\n\nfloat dstPlane(vec3 p, vec3 planePos, vec3 dir)\n{\n    vec3 rp = p - planePos;\n    return dot(rp, dir);\n}\n\nfloat dstFld(vec3 p)\n{\n    // the scene is described here\n    float dst;\n    dst =          dstSphere(p, vec3(0.0, 0.6, 3.0), 0.5);\n    dst = min(dst, dstSphere(p, vec3(1.0, -0.7, 1.0), 0.5));\n    dst = min(dst, dstSphere(p, vec3(-1.0, 0.0, 2.0), 0.5));\n    dst = min(dst,    dstBox(p, vec3(-2.0, 3.0, 5.0), vec3(1.0, 0.2, 0.5)));\n    dst = min(dst,    dstBox(p, vec3(-1.0, -0.5, 0.3), vec3(0.4, 0.3, 0.1)));\n    dst = min(dst,  dstPlane(p, vec3(0.0, -1.0, 0.0), normalize(vec3(0.0, 1.0, 0.0))));\n    return dst;\n}\n\nfloat castRay(in vec3 ro, in vec3 rd,\n              out vec3 pos,\n              inout vec4 matCol, inout float matRfl)\n{\n    // ray casting vars\n    const int maxIts = 256;\n    float epsilon = 0.001;\n    \n    float t = 0.0;\n    for(int i = 0; i < maxIts; i++)\n    {\n        vec3 p = ro + rd * t;\n        float dst = dstFld(p);\n        if(dst <= epsilon)\n        {\n            // it hit something\n            pos = p;\n            return t;\n        }\n        // march forth!\n        t += dst;\n    }\n    \n    // it hit nothing\n    return -1.0;\n}\n\nvec4 interpolate(vec4 v1, vec4 v2, float weight)\n{\n    vec4 rng = v2 - v1;\n    vec4 prc = weight * rng;\n    return v1 + prc;\n}\n\nvec3 normal(vec3 pos)\n{\n    vec3 eps = vec3(0.01, 0.0, 0.0);\n    vec3 n = vec3(dstFld(pos + eps.xyy) - dstFld(pos - eps.xyy),\n                  dstFld(pos + eps.yxy) - dstFld(pos - eps.yxy),\n                  dstFld(pos + eps.yyx) - dstFld(pos - eps.yyx));\n    return normalize(n);\n}\n\nfloat shadow(vec3 pos, vec3 lightPos, float shadowHardness)\n{\n    // shadow vars\n    const int maxIts = 256;\n    float epsilon = 0.001;\n    \n    float dis = distance(lightPos, pos);\n    vec3 dir = normalize(lightPos - pos);\n    float res = 1.0;\n    float t = 0.1;\n    for(int i = 0; i < maxIts; i++)\n    {\n        if(t >= dis) break;\n        vec3 p = pos + dir * t;\n        float d = dstFld(p);\n        if(d <= epsilon) return 0.0;\n        res = min(res, shadowHardness * d / t);\n        t += d;\n    }\n    \n    return res;\n}\n\nvec3 light(vec3 pos, vec3 lightPos, vec3 lightCol, float intensity, float hard)\n{\n    vec3 n = normal(pos);\n    vec3 lightDir = normalize(lightPos - pos);\n    float dp = dot(n, lightDir);\n    float attenuation = pow(distance(lightPos, pos), 2.0);\n    float shdw = shadow(pos, lightPos, hard);\n    return lightCol * max(dp, 0.0) / attenuation * intensity * shdw;\n}\n\nvec3 lighting(vec3 pos)\n{\n    // the lighting setup of the scene is described here\n    vec3 col = vec3(0.0, 0.0, 0.0); // ambient light\n    col += light(pos, vec3(4.0, 3.0, -5.0), vec3(1.0, 0.95, 0.5), 40.0, 4.0);\n    col += light(pos, vec3(-7.0, 1.0, 5.0), vec3(0.7, 0.85, 1.0), 30.0, 4.0);\n    col += light(pos, vec3(200.0, 500.0, 100.0), vec3(1.0, 1.0, 1.0), 100000.0, 16.0);\n    return col;\n}\n\nvec4 render(vec3 ro, vec3 rd)\n{\n    // render vars\n    vec4 skyCol = vec4(0.6, 0.9, 1.0, 0.0);\n    float fogNear = 2.0;\n    float fogFar = 32.0;\n    //int maxRefRec = 4;\n    \n    //if(rec >= maxRefRec) return skyCol;\n    \n    // cast dat ray\n    // collect material properties and distance ray traveled\n    vec4 matCol = vec4(1.0);\n    float matRfl = 0.5;\n    vec3 pos;\n    float dst = castRay(ro, rd, pos, matCol, matRfl);\n    \n    // compute a color\n    if(dst == -1.0 || dst >= fogFar) return skyCol;\n    vec4 col = vec4(1.0);\n    \n    // apply lighting\n    col *= vec4(lighting(pos), 1.0);\n    \n    // calculate reflection\n    //vec4 refCol = render(pos, normal(pos), rec + 1);\n    \n    // mix in reflection\n    //col = interpolate(col, refCol, matRfl);\n    \n    // apply material color\n    col *= matCol;\n    \n    // apply fog\n    float fog = 0.0;\n    if(dst > fogNear)\n    {\n        float fogRng = fogFar - fogNear;\n        float fogDpth = dst - fogNear;\n        fog = fogDpth / fogRng;\n    }\n    col = interpolate(col, skyCol, fog);\n    \n    // return final color calculation\n    return col;\n}\n\nvec2 pixels2Units(vec2 coords)\n{\n    vec2 uv = coords.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // convert pixel coordinates to unit coordinates for mouse\n    vec2 mouse = iMouse.xy == vec2(0.0) ? vec2(0.0) : pixels2Units(iMouse.xy);\n    \n    // camera stuff\n    vec3 camPos = vec3(0.0, 0.0, -1.0);\n    vec3 camXDir = vec3(1.0, 0.0, 0.0);\n\tvec3 camYDir = vec3(0.0, 1.0, 0.0);\n    float focLen = 1.0;\n    \n    // anti aliasing\n    const int superSample = 2;\n    vec4 col = vec4(0.0);\n    for(int y = 0; y < superSample; y++)\n    {\n        for(int x = 0; x < superSample; x++)\n        {\n            // offset of subpixel from actual pixel\n            vec2 subPixOff = vec2(x, y) / float(superSample);\n            \n            // convert pixel coordinates to unit coordinates\n            vec2 uv = pixels2Units(fragCoord.xy + subPixOff.xy);\n            \n\t\t\t// ray stuff\n            vec3 ro = camPos;\n            vec3 pixForward = focLen * normalize(cross(camXDir, camYDir));\n            vec3 pixX = uv.x * camXDir;\n            vec3 pixY = uv.y * camYDir;\n            vec3 pixPos = ro + pixForward + pixX + pixY;\n            vec3 rd = normalize(pixPos - ro);\n            \n            // compute pixel\n            col += render(ro, rd);\n        }\n    }\n    \n    // average and output subpixel sum\n    fragColor = col / float(superSample * superSample);\n}","name":"","description":"","type":"image"}]}