{"ver":"0.1","info":{"id":"wdffzS","date":"1588743531","viewed":191,"name":"Day14: Cubic Patch (4x Faster)","username":"fluxatron","description":"My attempts to make my Day13 shader run faster. Thanks to all who gave me pointers! \nhttps://www.shadertoy.com/view/wslBDM\n\nSee the benchmarking notes in code for my journey.\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["bezier","cubic","patch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DIMX_VERTS 3\n#define DIMZ_VERTS 7\n\n#define MAX_STEPS 50\n#define MAX_DIST 50.0\n#define SURFACE_DIST 0.005\n\n\n/* Benchmarking notes\n\n    DIM_VERTS  Compile time  Fps     Res       Notes:\n    4          5.0s          ~27-30  1200x675  Baseline performance\n    4          5.6s          ~34-37  1200x675  Removed _vert array. New tri stripping algo.\n\t4          0.7s          ~38-40  1200x675  Removed _tris array. Sampling bezier and building tris at dist calculation time. Less sqrts.\n\t4          0.6s          ~50     1200x675  Removed 7 mat3*vec3 by rotating camera instead of patch.\n\t4          0.6s          ~52     1200x675  Factorized the BezierSample() fn. 2-3fps maybe.\n\t4          0.8s          ~70-103 1200x675  Bounds test of surface controls avoids many triangle mesh tests\n\t3x5        0.8s          ~85-118 1200x675  More tesseltation where detail is required. 3x5=15 verts vs 4x4=16. Greater perceived detail.\n\t3x5        0.5s          ~85-125 1200x675  Using normal computing technique from iq and co. to improve compile times\n\t\n\tRunning 4x faster now but I've a few optimisations to go\n*/\n\n\n// TYPES ///////////////////////////////////////////////////////////////////////////////////////////////////\n\nstruct Tri\n{\n    vec3 a, b, c;\n};\n\nstruct Ray\n{\n    vec3 Origin;\n    vec3 Direction;\n};\n/*struct Material\n{\n    vec3 Color;\n};\n*/\nstruct Light\n{\n    vec3 Pos;\n    vec3 Color;\n    float Intensity;\n};\n    \nstruct Hit\n{\n    float Dist;\n    vec3 Color;\n};\n\nstruct BezierControl\n{\n    vec3 Vertex; // Position of vertex\n    vec3 Handle; // Vector defining handle direction and length\n};\n    \n    \n// DATA ///////////////////////////////////////////////////////////////////////////////////////////////////\n    \nconst int DIMX_SEGS = DIMX_VERTS-1;\nconst int DIMZ_SEGS = DIMZ_VERTS-1;\n\nBezierControl _leftA;\nBezierControl _leftB;\nBezierControl _rightA;\nBezierControl _rightB;\n\n\n// ACES Tonemap: https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl ////////////////////////////////////\nconst mat3 ACESInputMat  = mat3(0.59719, 0.07600, 0.02840,    0.35458, 0.90834, 0.13383,    0.04823, 0.01566, 0.83777);\nconst mat3 ACESOutputMat = mat3(1.60475, -0.10208, -0.00327, -0.53108, 1.10813, -0.07276,  -0.07367, -0.00605,  1.07602);\nvec3 RRTAndODTFit(vec3 v) { return (v * (v + 0.0245786) - 0.000090537) / (v * (0.983729 * v + 0.4329510) + 0.238081); }\nvec3 ACESFitted(vec3 color) { return clamp(ACESOutputMat * RRTAndODTFit(ACESInputMat * color), 0.0, 1.0); }\n\n    \n// SHAPES ////////////////////////////////////////////////////////////////////////////////////////////////\n\n// udTriangle/sdBox/sdCapsule - https://iquilezles.org/articles/distfunctions\nfloat dot2(vec3 v) { return dot(v,v); }\nfloat udTriangle(vec3 p, vec3 a, vec3 b, vec3 c)\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n\treturn //sqrt(\n       (sign(dot(cross(ba,nor),pa)) +\n\t\tsign(dot(cross(cb,nor),pb)) +\n\t\tsign(dot(cross(ac,nor),pc))<2.0)\n\t\t?\n            min( min(\n            dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n            dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n            dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n\t\t:\n\t\t\tdot(nor,pa)*dot(nor,pa)/dot2(nor);// );\n}\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdSphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nstruct Bound3\n{\n    vec3 mMin;\n    vec3 mMax;\n};\n\n\n// AABB of controls\nvec3 ComponentMin(in vec3 a, in vec3 b)\n{\n    return vec3(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z));\n}\nvec3 ComponentMax(in vec3 a, in vec3 b)\n{\n    return vec3(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z));\n}\nBound3 BezierControlAABB(in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3)\n{\n    return Bound3(ComponentMin(p0, ComponentMin(p1, ComponentMin(p2, p3))),\n                  ComponentMax(p0, ComponentMax(p1, ComponentMax(p2, p3)))\n                 );\n}\n\n\nvec3 SampleBezier(in vec3 a, in vec3 b, in vec3 c, in vec3 d, in float t)\n{\n    // Factorized the shit outta it\n\tfloat t2 = t*t;\n\tfloat t3 = t2*t;\n    return t3*(3.0*(b - c) + d - a) + 3.0*(t2*(a + c - 2.0*b) + t*(b - a)) + a;\n   \n    /*\n    // First degree\n    vec3 p11 = mix(a, b, t);\n    vec3 p12 = mix(b, c, t);\n    vec3 p13 = mix(c, d, t);\n\n    // Second degree\n    vec3 p21 = mix(p11, p12, t);\n    vec3 p22 = mix(p12, p13, t);\n\n    // Third degree\n    return mix(p21, p22, t);\n\t*/\n}\n\n\n// SCENE ///////////////////////////////////////////////////////////////////////////////////////////////////\nHit GetDist(vec3 p)\n{\n    Hit closest; // TODO try combining vec4(color, dist) and see if mix speeds up intersections\n    closest.Dist = 999999.;\n    closest.Color = vec3(1);\n    \n    // Plane\n    {\n        float d = p.y+0.6;\n        if (d < closest.Dist)\n        {\n            closest.Dist = d;\n            closest.Color = vec3(.5,.5,.5);\n        }\n    }\n\n    // Verts\n    /*{\n\t\tfloat r = 0.02;\n        float d = 9999999.;\n        d = min(sdSphere(p-_leftA.Vertex, r), d);\n        d = min(sdSphere(p-_leftB.Vertex, r), d);\n        d = min(sdSphere(p-_rightA.Vertex, r), d);\n        d = min(sdSphere(p-_rightB.Vertex, r), d);\n        \n        if (d < closest.Dist)\n        {\n            closest.Dist = d;\n            closest.Color = vec3(0.2,0.2,1);\n        }\n    }*/\n    \n   \n    \n    // Mesh bounding box test\n    {\n        // Dist to AABB\n        Bound3 bL = BezierControlAABB(_leftA.Vertex, _leftA.Handle, _leftB.Vertex, _leftB.Handle);\n        Bound3 bR = BezierControlAABB(_rightA.Vertex, _rightA.Handle, _rightB.Vertex, _rightB.Handle);\n        vec3 bMin = ComponentMin(bL.mMin, bR.mMin);\n        vec3 bMax = ComponentMax(bL.mMax, bR.mMax);\n        vec3 bCen = 0.5*(bMin+bMax);\n    \tvec3 bDim = 0.5*(bMax-bMin);\n        float dBox = sdBox(p-bCen, bDim);\n        \n         \n\t\t// Draw bounds\n\t\t/*\n\t\tif (dBox < closest.Dist)\n        {\n            closest.Dist = dBox;\n            closest.Color = vec3(1,1,0);\n        }        \n\t\tdBox = min(sdSphere(p-bMin, 0.1), dBox);\n        if (dBox < closest.Dist)\n        {\n            closest.Dist = dBox;\n            closest.Color = vec3(1,0,1);\n        }\n\n        dBox = min(sdSphere(p-bMax, 0.1), dBox);\n        if (dBox < closest.Dist)\n        {\n            closest.Dist = dBox;\n            closest.Color = vec3(0,1,1);\n        }\n\t\t*/\n       \n        \n        if (dBox < closest.Dist)\n        {\n            // Handles\n            {\n                float rHandle = 0.03;\n                float rRod = 0.01;\n                float d = 9999999.;\n                d = min(sdSphere(p-_leftA.Handle, rHandle), d);\n                d = min(sdSphere(p-_leftB.Handle, rHandle), d);\n                d = min(sdSphere(p-_rightA.Handle, rHandle), d);\n                d = min(sdSphere(p-_rightB.Handle, rHandle), d);\n\n                d = min(sdCapsule(p, _leftA.Vertex, _leftA.Handle, rRod), d);\n                d = min(sdCapsule(p, _leftB.Vertex, _leftB.Handle, rRod), d);\n                d = min(sdCapsule(p, _rightA.Vertex, _rightA.Handle, rRod), d);\n                d = min(sdCapsule(p, _rightB.Vertex, _rightB.Handle, rRod), d);\n\n                if (d < closest.Dist)\n                {\n                    closest.Dist = d;\n                    closest.Color = vec3(1);\n                }\n            }\n            \n            // Mesh\n            {\n                const vec3 color = vec3(1);\n\n                // Generate Tris\n\n                /* Sample bezier points for quad\n\n                  lt=a  rt=c\n                ^ |   / |\n                | |  /  |\n                | | /   |\n                V lb=b  rb=d\n                  U --->          */             \n\n                int index = 0;\n                float dTri=9999999.;\n\n                vec3 leftBot  = SampleBezier(_leftA.Vertex,  _leftA.Handle,  _leftB.Handle,  _leftB.Vertex,  0.);\n                vec3 rightBot = SampleBezier(_rightA.Vertex, _rightA.Handle, _rightB.Handle, _rightB.Vertex, 0.);\n\n                float rowStep = 1./float(DIMZ_SEGS);\n                float colmStep = 1./float(DIMX_SEGS);\n                for (int row = 1; row <= DIMZ_SEGS; row++)\n                {\n                    // Sample the bezier curve on the far left and right of this entire row. V coord.\n                    float top = float(row)*rowStep;\n                    vec3 leftTop  = SampleBezier(_leftA.Vertex,  _leftA.Handle,  _leftB.Handle,  _leftB.Vertex,  top);\n                    vec3 rightTop = SampleBezier(_rightA.Vertex, _rightA.Handle, _rightB.Handle, _rightB.Vertex, top);\n\n                    for (int colm = 1; colm <= DIMX_SEGS; colm++)\n                    {\n                        // Interpolate the row's bezier samples for the quad we're in. U Coord.\n                        float left = float(colm-1)*colmStep;\n                        float right = float(colm)*colmStep;\n\n                        // TODO EZ-OPTIMISE - Cache the left values outside of the loop to reduce computation\n                        vec3 a = mix(leftTop, rightTop, left);  // top left\n                        vec3 b = mix(leftBot, rightBot, left);  // bot left\n                        vec3 c = mix(leftTop, rightTop, right); // top right\n                        vec3 d = mix(leftBot, rightBot, right); // bot right\n\n                        // Depth test triangles\n                        dTri = min(udTriangle(p, a, b, c), dTri);\n                        dTri = min(udTriangle(p, c, b, d), dTri);\n                    }\n\n                    // Store this top sample for use as bottom in the next row\n                    leftBot = leftTop;\n                    rightBot = rightTop;\n                }\n\n                // I removed teh sqrt from udTriangle, so i must do it here!\n                dTri = sqrt(dTri) - 0.01;\n                if (dTri < closest.Dist)\n                {\n                    closest.Dist = dTri;\n                    closest.Color = color;\n                }\n            }\n        }\n    }\n    \n    return closest;\n}\n\n\n#define ZERO (min(iFrame,0))\nvec3 GetNormal(vec3 p)\n{\n    // Normal technique from iq: https://www.shadertoy.com/view/Xds3zN - I think this speeds up compile time by avoiding inlining of GetDist 4 times.\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*GetDist(p + 0.0005*e).Dist;\n    }\n    return normalize(n);\n    \n    /*float d = GetDist(p).Dist;\n    float offset = 0.01;\n    vec3 n = d - vec3(\n        GetDist(p - vec3(offset,0,0)).Dist,\n        GetDist(p - vec3(0,offset,0)).Dist,\n        GetDist(p - vec3(0,0,offset)).Dist\n        );\n  \n    return normalize(n);*/\n}\n\nHit RayMarch(Ray r)\n{\n    Hit lastHit;\n    float totalDist = 0.0;\n    \n    for (int i=0; i<MAX_STEPS; i++)\n    {\n        vec3 p = r.Origin + totalDist*r.Direction;\n        lastHit = GetDist(p);\n        totalDist += lastHit.Dist;\n        \n        if (totalDist < SURFACE_DIST || totalDist > MAX_DIST) \n            break;\n    }\n    \n    lastHit.Dist = totalDist;\n    \n    return lastHit;\n}\n\nvec3 GetLight(vec3 p, Light light)\n{\n    vec3 PL = light.Pos-p;\n    float PLLen = length(PL);\n    \n    vec3 lightNormal = PL/PLLen;\n    vec3 surfNormal = GetNormal(p);\n    \n    // Light\n    float strength = clamp(dot(surfNormal, lightNormal), 0., 1.);\n    float attenuation = 1. / max(PLLen*PLLen, 0.001);\n\n    // Shadow\n    Ray shadow;\n    shadow.Origin = p + surfNormal*SURFACE_DIST*2.;\n    shadow.Direction = lightNormal;\n    if(RayMarch(shadow).Dist < PLLen) strength = 0.0;\n    \n    return light.Intensity * light.Color * strength * attenuation;\n}\n\nmat3 RotateXZ(float rad)\n{\n    float cosr = cos(rad);\n    float sinr = sin(rad);\n    return mat3(\n        cosr,  0,  sinr,\n        0,     1,  0,\n        -sinr, 0,  cosr);\n}\n\n\n// MAIN ////////////////////////////////////////////////////////////////////////////////////////////////////\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.yy; // map to center:(0, 0), topright:(aspect/2, 0.5)\n    \n    // Define control points\n    {\n        float py = 0.35;\n        float px = -1.;\n        \n        _leftA = BezierControl(vec3(px, py,  1), vec3(px, py+.1, 0.5) + vec3(0, 0.2*cos(iTime*1.3 + 0.5), 0)); \n        _leftB = BezierControl(vec3(px, py, -1), vec3(px, py+.1,-0.5) + vec3(0, 0.2*sin(iTime*1.3 + 0.5), 0));\n        \n        px = 1.;\n        _rightA = BezierControl(vec3(px, py,  1), vec3(px,-.3,-.2) + vec3(0, 0.2*sin(iTime), 0)); \n        _rightB = BezierControl(vec3(px, py, -1), vec3(px, .4,-.2) + vec3(0, 0.2*cos(iTime), 0));\n    }\n   \n      \n    // Camera\n    Ray camera;\n    mat3 R = RotateXZ(iTime*0.2 + 0.7);\n    camera.Origin = R * vec3(0, 1.3, -3.1);\n    camera.Direction = R * normalize(vec3(uv.x, uv.y-0.7, 1.5));\n    \n    \n    // Hit scene\n    Hit hit = RayMarch(camera);\n    vec3 p = camera.Origin + camera.Direction*hit.Dist; // intersection point\n    \n    \n    // Direct Light\n    vec3 directLight = vec3(0);\n    {\n        Light l1;\n        l1.Pos = vec3(0, 2, 0) + 5.0;\n        l1.Color = vec3(1.0,0.6,0.5);\n        l1.Intensity = 50.0;\n        directLight += hit.Color * GetLight(p, l1);\n    }\n    \n    \n    // Ambient Light\n    vec3 ambient = hit.Color * 0.8*vec3(0.02,0.02,0.08);\n    \n    \n    // Compose colour\n    vec3 col = ambient + vec3(directLight);\n    \n    \n    // Post\n    //col *= 1.0; // exposure bias\n  \tcol = ACESFitted(col); // tonemap \n   \tcol = pow(col, vec3(.454)); // gamma\n\n    \n\tfragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}