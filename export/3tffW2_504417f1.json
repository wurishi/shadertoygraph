{"ver":"0.1","info":{"id":"3tffW2","date":"1601332409","viewed":874,"name":"Path tracing with MIS","username":"raziel","description":"A path-tracer with multiple importance sampling straight out of http://www.pbr-book.org/. Might be some bugs in there, but for the moment I'm satisfied with it. TODO: BTDF.","likes":5,"published":1,"flags":48,"usePreview":1,"tags":["pathtrace","pathtracing","sampling","sampling","tracing","mis","brdf","tracer","path","pbr","bsdf","multiple","importance","importance","pdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* A path-tracer with multiple importance sampling straight out of http://www.pbr-book.org/. \nIt implements the theory of a few chapters in the book, and while the book does offer \nliterate programming code snippets, I thought it might still be useful to see it actually \nworking in a shader in ShaderToy. Comments with links to the relevant book chapters are \nincluded in the code. Path-tracing with MIS can be also compared with non-PBR, non-MIS\npath tracer as described by demofox in his awesome series of blog posts which motivated me \nto work on this*/\n\n// --- https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilmicTonemap(vec3 x) {\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    color = ACESFilmicTonemap(color);\n    color = linearToSRGB(color);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* A path-tracer with multiple importance sampling straight out of http://www.pbr-book.org/. \nIt implements the theory of a few chapters in the book, and while the book does offer \nliterate programming code snippets, I thought it might still be useful to see it actually \nworking in a shader in ShaderToy. Comments with links to the relevant book chapters are \nincluded in the code. Path-tracing with MIS can be also compared with non-PBR, non-MIS\npath tracer as described by demofox in his awesome series of blog posts which motivated me \nto work on this*/\n\nstruct Material {\n    vec3 albedo;\n    vec3 emissive;\n    float metalness;\n    vec3 reflectance;\n    float roughness;\n    vec3 etaI;\n    vec3 etaT;\n    vec3 k;\n    int fresnelType;\n};\n    \nMaterial createMaterial() {\n    Material m;\n    m.albedo = vec3(0.0);\n    m.emissive = vec3(0.0);\n    m.metalness = 0.0;\n    m.reflectance = vec3(0.0);\n    m.roughness = 0.0;\n    \n    return m;\n}\n\nstruct RayHit {\n    vec3 position;\n    vec3 normal;\n    vec3 tangent;\n    float t;\n    Material material;\n    vec3 wo;\n    int lightId;\n};\n    \nRayHit createRayHit(in vec3 wo) {\n    RayHit h;\n    h.position = vec3(0.0);\n    h.normal = vec3(0.0);\n    h.tangent = vec3(0.0);\n    h.t = kMaxRayTravelDistance;\n    h.wo = wo;\n    h.lightId = 2;\n    return h;\n}\n    \nstruct Object {\n    mat4 world;\n    mat4 worldInv;\n    vec4 data;\n};\nObject gObjects[kNumObjects];\n    \nstruct Light {\n    mat4 world;\n    mat4 worldInv;\n\tvec3 Le;\n    float radius;\n};\nLight gLights[kNumLights];\n    \nbool intersectSphere(\n    in vec3 rayOrigin, \n    in vec3 rayDirection,\n    in vec4 sphere,\n    inout RayHit res\n) {\n    vec3 oc = rayOrigin - sphere.xyz;\n    float b = dot(rayDirection, oc);\n    float c = dot(oc, oc) - sphere.w * sphere.w;\n    if (c > 0.0 && b > 0.0) {\n        return false;\n    }\n    \n    float delta = b * b - c;\n    if (delta < 0.0) {\n        return false;\n    }\n    \n    bool fromInside = false;\n\tfloat x = -b - sqrt(delta);\n    if (x < 0.0) {\n        fromInside = true;\n        x = -b + sqrt(delta);\n    }\n    \n\tif (x > kMinRayTravelDistance && x < res.t) {\n        res.t = x;\n        res.position = rayOrigin + rayDirection * x;\n        res.normal = normalize(res.position - sphere.xyz) * (fromInside ? -1.0f : 1.0f);\n        res.tangent = normalize(orthogonal(res.normal));\n        return true;\n    }\n       \n    return false;\n}\n    \n\n// --- thanks iq, https://iquilezles.org/articles/boxfunctions\nbool intersectBox(\n    in vec3 rayOrigin, \n    in vec3 rayDirection,\n    in mat4 boxTransform, \n    in mat4 boxTransformInv, \n    in vec3 boxHalfLength,\n    inout RayHit res\n) {\t\t\t\t \n    vec3 rayDirBox = (boxTransform * vec4(rayDirection, 0.0)).xyz;\n    vec3 rayOriginBox = (boxTransform * vec4(rayOrigin, 1.0)).xyz;\n\n    vec3 invDir = 1.0 / rayDirBox;\n    vec3 s = vec3(\n        (rayDirBox.x < 0.0) ? 1.0 : -1.0,\n        (rayDirBox.y < 0.0) ? 1.0 : -1.0,\n        (rayDirBox.z < 0.0) ? 1.0 : -1.0\n    );\n    vec3 t0 = invDir * (-rayOriginBox + s * boxHalfLength);\n    vec3 t1 = invDir * (-rayOriginBox - s * boxHalfLength);\n\n    float tmax = max(max(t0.x, t0.y), t0.z);\n    float tmin = min(min(t1.x, t1.y), t1.z);\n\t\n    if (tmax > tmin || tmin < 0.0) {\n        return false;\n    }\n    \n    vec3 p = rayOriginBox + rayDirBox * tmax;\n    vec3 pw = (boxTransformInv * vec4(p, 1.0)).xyz;\n    tmax = length(pw - rayOrigin);\n    \n    if (tmax < res.t) {\n        res.t = tmax;\n        res.position = pw;\n\n        if (t0.x > t0.y && t0.x > t0.z) { \n            res.normal = boxTransformInv[0].xyz * s.x;\n        } else if (t0.y > t0.z) { \n            res.normal = boxTransformInv[1].xyz * s.y;\n        } else { \n            res.normal = boxTransformInv[2].xyz * s.z;\n        }\n        res.tangent = normalize(orthogonal(res.normal));\n        return true;\n    }\n\n    return false;\n}\n\nint getPattern(float pos0, float pos1) {\n    int counter = int((32.0)) & 255;\n    int shift = int(pos0 * 16.0) & 7 + int(pos1 * 16.0) & 7;\n    return (counter >> shift) & 1;\n}\n\nvoid initScene() {\n    gObjects[kObjectBackWall].world = translation(vec3(-2.25, -8.3, 10.0));\n    gObjects[kObjectBackWall].worldInv = inverse(gObjects[0].world);\n    gObjects[kObjectBackWall].data = vec4(5.8, 2.1, 0.1, 0.0);\n        \n    gObjects[kObjectGroundFloor].world = translation(vec3(0.0, -10.5, 0.0));\n    gObjects[kObjectGroundFloor].worldInv = inverse(gObjects[kObjectGroundFloor].world);\n    gObjects[kObjectGroundFloor].data = vec4(50.0, 0.1, 10.0, 0.0);\n    \n    gObjects[kObjectSmallBox].world = translation(vec3(-1.5, -10.2, 7.5)) * rotation(normalize(vec3(0.0, 1.0, 0.0)), kPI * 0.45);\n    gObjects[kObjectSmallBox].worldInv = inverse(gObjects[kObjectSmallBox].world);\n    gObjects[kObjectSmallBox].data = vec4(0.2, 0.2, 0.2, 0.0);\n    \n    gObjects[kObjectMediumSphere].world = translation(vec3(-0.85, -10.05, 7.0)) * rotation(normalize(vec3(0.0, 1.0, 0.0)), kPI * 0.5);\n    gObjects[kObjectMediumSphere].worldInv = inverse(gObjects[kObjectMediumSphere].world);\n\tgObjects[kObjectMediumSphere].data = vec4(0.3, 0.3, 0.3, 0.0);\n    \n    gObjects[kObjectBigSphere].world = translation(vec3(0.0, -9.9, 6.0)) * rotation(normalize(vec3(0.0, 1.0, 0.0)), kPI * 0.55);\n    gObjects[kObjectBigSphere].worldInv = inverse(gObjects[kObjectBigSphere].world);\n   \tgObjects[kObjectBigSphere].data = vec4(0.4, 0.4, 0.4, 0.0);\n    \n    gLights[kLightSmall].world = translation(vec3(-0.7, -10.1, 6.1));\n    gLights[kLightSmall].worldInv = inverse(gLights[kLightSmall].world);\n    gLights[kLightSmall].Le = vec3(0.6) * vec3(20.0);\n    gLights[kLightSmall].radius = 0.1;\n    \n    gLights[kLightBig].world = translation(vec3(0.0, -10.1, 9.0));\n    gLights[kLightBig].worldInv = inverse(gLights[kLightBig].world);\n    gLights[kLightBig].Le = vec3(0.309, 0.274, 0.670) * vec3(50.0);\n    gLights[kLightBig].radius = 0.3;\n}\n\nvoid scene(in vec3 rayOrigin, in vec3 rayDir, inout RayHit hit) {\n    Object backWall = gObjects[kObjectBackWall];\n    if (intersectBox(rayOrigin, rayDir, backWall.worldInv, backWall.world, backWall.data.xyz, hit)) {\n        hit.material = createMaterial();\n        vec3 hitPos = rayOrigin + rayDir * hit.t;\n        int pattern = getPattern(hitPos.y, hitPos.x);\n        \n#if defined(NON_PBR)\n        hit.material.albedo = vec3(0.309, 0.274, 0.670);\n#else\n        hit.material.reflectance = vec3(1.0);\n        hit.material.albedo = vec3(0.309, 0.274, 0.670);\n        hit.material.etaI = vec3(kIORAir);\n        hit.material.etaT = vec3(kIORDielectric);\n        hit.material.fresnelType = kFresnelTypeDielectric;\n        hit.material.roughness = pattern > 0 ? 0.1 : 0.5;\n       \thit.material.k = vec3(0.0);\n        hit.lightId = -1;\n#endif\n    }\n   \n    Object groundFloor = gObjects[kObjectGroundFloor];\n    if (intersectBox(rayOrigin, rayDir, groundFloor.worldInv, groundFloor.world, groundFloor.data.xyz, hit)) {\n        hit.material = createMaterial();\n        vec3 hitPos = rayOrigin + rayDir * hit.t;\n        int pattern = getPattern(hitPos.z, hitPos.x);\n        \n#if defined(NON_PBR)        \n        hit.material.albedo = vec3(0.349, 0.294, 0.396);\n#else\n        hit.material.reflectance = vec3(1.0);\n        hit.material.albedo = vec3(0.349, 0.294, 0.396);\n        hit.material.etaI = vec3(kIORAir);\n        hit.material.etaT = vec3(kIORDielectric);\n        hit.material.fresnelType = kFresnelTypeDielectric;\n        hit.material.roughness = 0.2;\n       \thit.material.k = vec3(0.0);\n        hit.lightId = -1;\n#endif\n    }    \n    \n    Object smallBox = gObjects[kObjectSmallBox];  \n    if (intersectBox(rayOrigin, rayDir, smallBox.worldInv, smallBox.world, smallBox.data.xyz, hit)) {\n        hit.material = createMaterial();\n#if defined(NON_PBR)\n        hit.material.albedo = vec3(0.349, 0.294, 0.396);\n        hit.material.roughness = 0.3;\n        hit.material.metalness = 0.2;\n        hit.material.reflectance = vec3(0.02);\n#else\n        hit.material.reflectance = vec3(1.0);\n        hit.material.albedo = vec3(0.349, 0.294, 0.396);\n        hit.material.etaI = vec3(kIORAir);\n        hit.material.etaT = vec3(kIORDielectric);\n        hit.material.fresnelType = kFresnelTypeDielectric;\n        hit.material.roughness = 0.5;\n       \thit.material.k = vec3(0.0);\n        hit.lightId = -1;\n#endif\n    }    \n    \n    Object mediumSphere = gObjects[kObjectMediumSphere];\n    if (intersectSphere(rayOrigin, rayDir, vec4(mediumSphere.world[3].xyz, mediumSphere.data.x), hit)) {\n        hit.material = createMaterial();\n#if defined(NON_PBR)\n        hit.material.albedo = vec3(0.349, 0.294, 0.396);\n        hit.material.roughness = 0.5;\n        hit.material.metalness = 0.2;\n        hit.material.reflectance = vec3(0.02);\n#else\n        hit.material.reflectance = vec3(1.0);\n        hit.material.albedo = vec3(0.349, 0.294, 0.396);\n        hit.material.etaI = vec3(kIORAir);\n        hit.material.etaT = vec3(kIORDielectric);\n        hit.material.fresnelType = kFresnelTypeDielectric;\n        hit.material.roughness = 0.15;\n       \thit.material.k = vec3(0.0);\n        hit.lightId = -1;\n#endif\n    } \n    \n    Object bigSphere = gObjects[kObjectBigSphere];\n    if (intersectSphere(rayOrigin, rayDir, vec4(bigSphere.world[3].xyz, bigSphere.data.x), hit)) {\n#if defined(NON_PBR)\n        hit.material = createMaterial();\n        hit.material.albedo = vec3(0.349, 0.294, 0.396);\n        hit.material.roughness = 0.1;\n        hit.material.metalness = 0.8;\n        hit.material.reflectance = vec3(0.8);\n#else\n        hit.material.reflectance = vec3(1.0);\n        hit.material.albedo = vec3(0.0);\n        hit.material.etaI = vec3(kIORAir);\n        // --- thanks to https://github.com/ospray/ospray for averaging spectral samples \n\t\t// --- from https://refractiveindex.info/ to provide an eta and a k for gold\n        hit.material.etaT = vec3(0.07, 0.37, 1.5);\n        hit.material.fresnelType = kFresnelTypeConductor;\n        hit.material.roughness = 0.15;\n       \thit.material.k = vec3(3.7, 2.3, 1.7);\n        hit.lightId = -1;\n#endif\n    } \n    \n    Light smallLight = gLights[kLightSmall];    \n    if (intersectSphere(rayOrigin, rayDir, vec4(smallLight.world[3].xyz, smallLight.radius), hit)) {\n        hit.material = createMaterial();\n        hit.material.emissive = smallLight.Le;\n        hit.lightId = kLightSmall;\n    }\n    \n    Light bigLight = gLights[kLightBig];\n    if (intersectSphere(rayOrigin, rayDir, vec4(bigLight.world[3].xyz, bigLight.radius), hit)) {\n        hit.material = createMaterial();\n        hit.material.emissive = bigLight.Le;\n        hit.lightId = kLightBig;\n    }\n}\n\n// --- https://blog.demofox.org/2020/05/25/casual-shadertoy-path-tracing-1-basic-camera-diffuse-emissive/\nvec3 pathTrace(in vec3 rayOrigin, in vec3 rayDir, in uint rng) {\n    vec3 L = vec3(0.0);\n    vec3 T = vec3(1.0);\n    \n    vec3 ro = rayOrigin;\n    vec3 rd = rayDir;\n    for (int i = 0; i < kNumBouncesRT; ++i) {\n        RayHit hit = createRayHit(rd);\n    \tscene(ro, rd, hit);    \n        \n        if (hit.t == kMaxRayTravelDistance) {\n            break;\n        }\n        \n        ro = (ro + hit.t * rd) + hit.normal * kNormalThreshold;\n        \n        float specular = (randomFloat01(rng) < hit.material.metalness) ? 1.0 : 0.0;\n        vec3 rdDiff = normalize(hit.normal + randomUnitVec(vec2(randomFloat01(rng), randomFloat01(rng))));\n        vec3 rdSpec = reflect(rd, hit.normal);\n        rdSpec = normalize(mix(rdSpec, rdDiff, hit.material.roughness * hit.material.roughness));\n        rd = mix(rdDiff, rdSpec, specular); \n        \n        L += hit.material.emissive * T;\n        T *= mix(hit.material.albedo, hit.material.reflectance, specular);\n    }\n      \n    return L;\n}\n\nfloat conePdf(in float cosThetaMax) {\n    return 1.0 / (2.0 * kPI * (1.0 - cosThetaMax));\n}\n\nfloat spherePdf(in mat4 world, in float radius, in vec3 refP) {\n    vec3 ppc = refP - world[3].xyz;\n    float ppcLeSq = dot(ppc, ppc);\n    float sinThetaMax2 = radius * radius / ppcLeSq;\n    float cosThetaMax = sqrt(max(0.0, 1.0 - sinThetaMax2));\n    return conePdf(cosThetaMax);\n}\n\n// --- http://www.pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/Sampling_Light_Sources.html#x2-SamplingSpheres\n// --- sample direction over the solid angle subtended by the sphere with respect to a point\n// --- this ensures we sample points on the sphere that are visible, avoiding points on its back\nvoid sampleSphere(in mat4 world, in float radius, in vec3 refP, in vec2 xi, out vec3 posS, out vec3 nrmS) {\n    vec3 center = (world * vec4(0.0, 0.0, 0.0, 1.0)).xyz;\n    vec3 cToP = normalize(center - refP);\n    vec3 cToPS, cToPT;\n    buildCoordinateSystem(cToP, cToPS, cToPT);\n    \n    vec3 ppc = refP - center;\n    float ppcLeSq = dot(ppc, ppc);\n    float sinThetaMax2 = radius * radius / ppcLeSq;\n    float cosThetaMax = sqrt(max(0.0, 1.0 - sinThetaMax2));\n    \n    float cosTheta = (1.0 - xi.x) + cosThetaMax * xi.x;\n    float sinTheta = sqrt(max(0.0, 1.0 - cosTheta * cosTheta));\n    float phi = xi.y * 2.0 * kPI;\n    \n    float dc = length(ppc);\n\tfloat ds = dc * cosTheta - sqrt(max(0.0, radius * radius - dc * dc * sinTheta * sinTheta));\n\tfloat cosAlpha = (dc * dc + radius * radius - ds * ds) / (2.0 * dc * radius);\n\tfloat sinAlpha = sqrt(max(0.0, 1.0 - cosAlpha * cosAlpha));\n    \n    vec3 n = directionFromSphericalCoordsAndBasis(sinAlpha, cosAlpha, phi, -cToPS, -cToPT, -cToP);\n    vec3 p = radius * n;\n    \n    posS = (world * vec4(p, 1.0)).xyz;\n    nrmS = (world * vec4(n, 0.0)).xyz;\n}\n\nvec3 sampleCosineWeightedHemisphere(in vec2 xi) {\n    float cosTheta2 = 1.0 - xi.x;\n    float cosTheta = sqrt(cosTheta2);\n    float sinTheta = sqrt(max(0.0, 1.0 - cosTheta2));\n    float phi = 2.0 * kPI * xi.y;\n\n    return directionFromSphericalCoords(sinTheta, cosTheta, phi);\n}\n\nvec3 sampleLight(in Light light, in int lightId, in RayHit hit, in vec2 xiLight, inout vec3 wi, inout float pdf) {\n    vec3 Li = vec3(0.0);\n    \n    vec3 posL = vec3(0.0);\n    vec3 nrmL = vec3(0.0);\n    \n    if (lightId != kLightEnv) {\n        sampleSphere(light.world, light.radius, hit.position, xiLight, posL, nrmL);\n        wi = normalize(posL - hit.position);\n        pdf = spherePdf(light.world, light.radius, hit.position);\n        Li = dot(nrmL, -wi) > 0.0 ? light.Le : vec3(0.0);\n    } else {\n        // --- infinite area light aka environment map\n    \twi = sampleCosineWeightedHemisphere(xiLight);\n        // --- compute pdf for cosine weighted hemisphere based on whether wi and wo are in same hemisphere\n        // --- see Lambertian brdf sampling also\n        pdf = dot(wi, hit.normal) * dot(hit.wo, hit.normal) > 0.0 ? abs(dot(wi, hit.normal)) * kInvPI : 0.0;\n        Li = srgbToLinear(texture(iChannel2, wi).rgb) * kEnvMapFactor;\n    }\n    \n    return Li;\n}\n\n// --- http://www.pbr-book.org/3ed-2018/Reflection_Models/Specular_Reflection_and_Transmission.html#FresnelReflectance\nfloat fresnelDielectric(in vec3 etaI, in vec3 etaT, in float cosThetaI) {\n    cosThetaI = clamp(cosThetaI, -1.0, 1.0);\n    float ni = etaI.x;\n    float nt = etaT.x;\n    bool entering = cosThetaI > 0.0;\n\tif (!entering) {\n        float tmp = ni;\n        ni = nt;\n        nt = tmp;\n    \tcosThetaI = abs(cosThetaI);\n\t}\n    \n    // --- Snell's law to get sine of thetaT\n    float sinThetaI = sqrt(max(0.0, 1.0 - cosThetaI * cosThetaI));\n\tfloat sinThetaT = ni / nt * sinThetaI;\n    // --- total internal reflection\n    if (sinThetaT >= 1.0) {\n    \treturn 1.0;\n    }\n    \n    float cosThetaT = sqrt(max(0.0, 1.0 - sinThetaT * sinThetaT));\n    float Rparl = ((nt * cosThetaI) - (ni * cosThetaT)) / ((nt * cosThetaI) + (ni * cosThetaT));\n    float Rperp = ((ni * cosThetaI) - (nt * cosThetaT)) / ((ni * cosThetaI) + (nt * cosThetaT));\n    return (Rparl * Rparl + Rperp * Rperp) * 0.5;\n}\n\n// --- https://seblagarde.wordpress.com/2013/04/29/memo-on-fresnel-equations/\nvec3 fresnelConductor(in vec3 etaI, in vec3 etaT, in vec3 k, in float cosThetaI) {\n    cosThetaI = clamp(cosThetaI, -1.0, 1.0);\n    vec3 eta = etaT / etaI.x;\n    vec3 etaK = k / etaI.x;\n    float cosTheta2 = cosThetaI * cosThetaI;\n    vec3 t = 2.0 * eta * cosThetaI;\n\n    vec3 t0 = eta * eta + etaK * etaK;\n    vec3 t1 = t0 * cosTheta2;\n    vec3 Rs = (t0 - t + cosTheta2) / (t0 + t + cosTheta2);\n    vec3 Rp = (t1 - t + 1.0) / (t1 + t + 1.0);\n\n    return 0.5 * (Rp + Rs);\n}\n\n// --- use approximated Trowbridge-Reitz as can be found in Unreal for D and G\nfloat ggxD(in Material m, in vec3 wh) {\n    float alpha = m.roughness * m.roughness;\n    float alpha2 = alpha * alpha;\n    float cosTheta2 = wh.z * wh.z;\n    float n = cosTheta2 * (alpha2 - 1.0) + 1.0;\n    return alpha2 / (kPI * n * n);\n}\n\nfloat ggxG1(in vec3 w, in float k) {\n    return w.z / (w.z * (1.0 - k) + k);\n}\n\nfloat ggxG(in Material m, in vec3 wo, in vec3 wi) {\n    float k = ((m.roughness + 1.0) * (m.roughness + 1.0)) / 8.0;\n    return ggxG1(wo, k) * ggxG1(wi, k);\n}\n\nfloat ggxPdf(in Material m, in vec3 wo, in vec3 wh) {\n    return ggxD(m, wh) * abs(wh.z);\n}\n\n// --- steps required to sample pdfs\n// --- 1.http://www.pbr-book.org/3ed-2018/Color_and_Radiometry/Working_with_Radiometric_Integrals.html\n// --- 2.http://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration/Sampling_Random_Variables.html (The Inversion Method)\n// --- 3.http://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration/Transforming_between_Distributions.html\n// --- 4.http://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration/2D_Sampling_with_Multidimensional_Transformations.html\n// --- 5.???\n// --- 6.profit\n\n// --- https://agraphicsguy.wordpress.com/2015/11/01/sampling-microfacet-brdf/\nvec3 sampleGgxWh(in Material m, in vec3 wo, in vec2 xi) {\n    float alpha = m.roughness * m.roughness;\n    float phi = 2.0 * kPI * xi.x;\n    float cosTheta2 = (1.0 - xi.y) / ((alpha * alpha - 1.0) * xi.y + 1.0);\n  \tfloat cosTheta = sqrt(cosTheta2);\n    float sinTheta = sqrt(max(0.0, 1.0 - cosTheta2));\n    vec3 wh = directionFromSphericalCoords(sinTheta, cosTheta, phi);\n    if (!sameHemisphere(wo, wh)) {\n        wh = -wh;\n    }\n    return wh;\n}\n\n// --- http://www.pbr-book.org/3ed-2018/Reflection_Models/Microfacet_Models.html#TheTorrancendashSparrowModel\nvec3 brdfTorranceSparrow(in Material bsdf, in vec3 wo, in vec3 wi) {\n    float cosThetaO = absCosTheta(wo);\n    float cosThetaI = absCosTheta(wi);\n    vec3 wh = wi + wo;\n    if (cosThetaO == 0.0 || cosThetaI == 0.0) {\n        return vec3(0.0);\n    }\n    if (all(equal(wh, vec3(0.0)))) {\n        return vec3(0.0);\n    }\n    \n    wh = normalize(wh);\n    vec3 F = vec3(0.0);\n    if (bsdf.fresnelType == kFresnelTypeDielectric) {\n        F = vec3(fresnelDielectric(bsdf.etaI, bsdf.etaT, dot(wi, wh)));\n    } else if (bsdf.fresnelType == kFresnelTypeConductor) {\n        F = fresnelConductor(bsdf.etaI, bsdf.etaT, bsdf.k, dot(wi, wh));\n    }\n    \n    return bsdf.reflectance * ggxD(bsdf, wh) * ggxG(bsdf, wo, wi) * F / (4.0 * cosThetaI * cosThetaO);\n}\n\n// --- http://www.pbr-book.org/3ed-2018/Reflection_Models/Lambertian_Reflection.html\nvec3 brdfLambertian(in Material bsdf, in vec3 wo, in vec3 wi) {\n    return bsdf.albedo * kInvPI;\n}\n\nfloat pdfTorranceSparrow(in Material bsdf, in vec3 wo, in vec3 wi) {\n    if (!sameHemisphere(wo, wi)) {\n        return 0.0;\n    }\n    \n    vec3 wh = normalize(wi + wo);\n    // --- convert half-angle pdf to incoming vector pdf\n    return ggxPdf(bsdf, wo, wh) / (4.0 * dot(wo, wh));\n}\n\nfloat pdfLambertian(in Material bsdf, in vec3 wo, in vec3 wi) {\n    return sameHemisphere(wo, wi) ? abs(wi.z) * kInvPI : 0.0;\n}\n\nvec3 evalBsdf(in RayHit hit, in vec3 wiW) {\n    vec3 wi = vec3(0.0);\n    vec3 wo = vec3(0.0);\n    \n    vec3 t = hit.tangent;\n    vec3 n = hit.normal;\n    vec3 b = cross(t, n);\n    wi = worldToBsdfFrame(wiW, t, b, n);\n    wo = worldToBsdfFrame(hit.wo, t, b, n);\n    \n    bool isConductor = hit.material.fresnelType == kFresnelTypeConductor;\n    \n    vec3 f = vec3(0.0);\n    f = brdfTorranceSparrow(hit.material, wo, wi);\n    if (!isConductor) {\n    \tf += brdfLambertian(hit.material, wo, wi);\n    }\n    \n    return f;\n}\n\nfloat evalPdf(in RayHit hit, in vec3 wiW) {\n    vec3 wi = vec3(0.0);\n    vec3 wo = vec3(0.0);\n    \n    vec3 t = hit.tangent;\n    vec3 n = hit.normal;\n    vec3 b = cross(t, n);\n    wi = worldToBsdfFrame(wiW, t, b, n);\n    wo = worldToBsdfFrame(hit.wo, t, b, n);\n    \n    bool isConductor = hit.material.fresnelType == kFresnelTypeConductor;\n    \n    float pdf = 0.0;\n    pdf = pdfTorranceSparrow(hit.material, wo, wi);\n    if (!isConductor) {\n    \tpdf += pdfLambertian(hit.material, wo, wi);\n        pdf *= 0.5;\n    }\n    return pdf;\n}\n\n// --- http://www.pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/Sampling_Reflection_Functions.html\nvec3 sampleTorranceSparrowBrdf(in Material bsdf, in vec3 wo, inout vec3 wi, in vec2 xi, inout float pdf) {\n   \tvec3 wh = sampleGgxWh(bsdf, wo, xi);\n    wi = reflect(-wo, wh);\n    if (!sameHemisphere(wo, wi)) {\n        return vec3(0.0);\n    }\n    pdf = ggxPdf(bsdf, wo, wh) / (4.0 * dot(wo, wh));\n    return brdfTorranceSparrow(bsdf, wo, wi);\n}\n\n// --- http://www.pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/Sampling_Reflection_Functions.html#fragment-Cosine-samplethehemisphereflippingthedirectionifnecessary-0\nvec3 sampleLambertianBrdf(in Material bsdf, in vec3 wo, inout vec3 wi, in vec2 xi, inout float pdf) {\n    wi = sampleCosineWeightedHemisphere(xi);\n    if (wo.z < 0.0) {\n        wi.z *= -1.0;\n    }\n    pdf = pdfLambertian(bsdf, wo, wi);\n    \n    return brdfLambertian(bsdf, wo, wi);\n}\n\nvec3 sampleBsdf(in RayHit hit, in vec3 xiBsdf, inout vec3 wiW, inout float pdf) {\n    vec3 t = hit.tangent;\n    vec3 n = hit.normal;\n    vec3 b = cross(t, n);\n    \n    vec3 wi = vec3(0.0);\n    vec3 wo = worldToBsdfFrame(hit.wo, t, b, n);\n    \n    int bxdfToSample = min(int(floor(xiBsdf.x * float(kNumBxDFs))), kNumBxDFs - 1);\n    bool isConductor = hit.material.fresnelType == kFresnelTypeConductor;\n    if (isConductor) {\n        bxdfToSample = 1;\n    }\n    \n    pdf = 0.0;\n    vec3 f = vec3(0.0);\n    if (bxdfToSample == 0) {\n        f = sampleLambertianBrdf(hit.material, wo, wi, xiBsdf.yz, pdf);\n    } else {\n    \tf = sampleTorranceSparrowBrdf(hit.material, wo, wi, xiBsdf.yz, pdf);\n    }\n    if (pdf == 0.0) {\n        return vec3(0.0);\n    }\n    wiW = bsdfFrameToWorld(wi, t, b, n);\n    \n    if (!isConductor) {\n        if (bxdfToSample == 0) {\n            pdf += pdfTorranceSparrow(hit.material, wo, wi);\n            pdf *= 0.5;\n            f += brdfTorranceSparrow(hit.material, wo, wi);\n        } else {\n            pdf += pdfLambertian(hit.material, wo, wi);\n            pdf *= 0.5;\n            f += brdfLambertian(hit.material, wo, wi);\n        }\n    }\n    \n    return f;\n}\n\nvec3 directLighting(in RayHit hit, in Light light, in vec2 xiLight, in vec3 xiScattering, in uint rng, in int lightId) {\n    vec3 Ld = vec3(0.0);\n    \n    vec3 wi;\n    float lightPdf = 0.0, scatteringPdf = 0.0;\n    \n    // --- sample light source with MIS\n    {\n    \tvec3 Li = sampleLight(light, lightId, hit, xiLight, wi, lightPdf);\n        if (lightPdf > 0.0 && any(greaterThan(Li, vec3(0.0))))\n        {\n            // --- compute BSDF of surface for our light sample\n            vec3 f = evalBsdf(hit, wi) * abs(dot(wi, hit.normal));\n            scatteringPdf = evalPdf(hit, wi);\n            if (any(greaterThan(f, vec3(0.0)))) {\n                // --- determine visibility of light\n                RayHit shadowHit = createRayHit(wi);\n                scene(hit.position + hit.normal * kNormalThreshold, wi, shadowHit);\n                if (shadowHit.lightId == lightId) {\n                    // --- if visible add its radiance contribution\n                    float weight = powerHeuristic(1.0, lightPdf, 1.0, scatteringPdf);\n                    Ld += f * Li * weight / lightPdf;\n                }\n            }\n        }\n    }\n    \n    // --- sample BSDF with MIS\n    {\n        vec3 f = vec3(0.0);\n        f = sampleBsdf(hit, xiScattering, wi, scatteringPdf);\n        f *= abs(dot(wi, hit.normal));\n        if (any(greaterThan(f, vec3(0.0))) && scatteringPdf > 0.0) {\n            // --- add light contribution across sampled wi\n            // --- we can reuse light pdf since it's not dependent on wi\n            float weight = powerHeuristic(1.0, scatteringPdf, 1.0, lightPdf);\n            RayHit shadowHit = createRayHit(wi);\n            scene(hit.position + hit.normal * kNormalThreshold, wi, shadowHit);\n            if (shadowHit.lightId == lightId) {\n                vec3 Li = vec3(0.0);\n                if (lightId != kLightEnv) {\n                \tLi = dot(shadowHit.normal, -wi) > 0.0 ? light.Le : vec3(0.0);\n                } else {\n                    Li = srgbToLinear(texture(iChannel2, wi).rgb) * kEnvMapFactor;\n                }\n                if (any(greaterThan(Li, vec3(0.0)))) {\n                     Ld += f * Li * weight / scatteringPdf;\n                }\n            }\n        }\n    }\n    \n    return Ld;\n}\n\nvec3 uniformSampleOneLight(in RayHit hit, in uint rng) {\n    float xi = randomFloat01(rng);\n    int lightIdx = min(int(xi * float(kNumLights)), kNumLights - 1);\n    int arrayId = clamp(lightIdx, 0, 1); // --- 2 is environment map\n    Light light = gLights[arrayId];\n    vec2 xiLight = vec2(randomFloat01(rng), randomFloat01(rng));\n    vec3 xiScattering = vec3(randomFloat01(rng), randomFloat01(rng), randomFloat01(rng));\n        \n    return float(kNumLights) * directLighting(hit, light, xiLight, xiScattering, rng, lightIdx);\n}\n\n// --- http://www.pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/Path_Tracing.html\nvec3 pathTracePBR(in vec3 rayOrigin, in vec3 rayDir, in uint rng) {\n    vec3 L = vec3(0.0);\n    vec3 beta = vec3(1.0); // --- path throughput weight\n    \n    vec3 ro = rayOrigin;\n    vec3 rd = rayDir;\n    for (int bounces = 0; ; ++bounces) {\n        RayHit hit = createRayHit(-rd);\n    \tscene(ro, rd, hit); \n        \n        if (bounces == 0) {\n            // --- possibly add emitted light at first intersection\n            if (hit.t != kMaxRayTravelDistance) {\n                L += dot(hit.normal, -rd) > 0.0 ? beta * hit.material.emissive : vec3(0.0);\n            }\n        }\n        \n        if (hit.t == kMaxRayTravelDistance || bounces > kPathTracingMaxDepth) {\n            break;\n        }\n        \n        // --- radiance from direct lighting for the current path\n        L += beta * uniformSampleOneLight(hit, rng);\n        \n        // --- sample BSDF to build next path\n        vec3 f = vec3(0.0);\n        vec3 wi = vec3(0.0);\n        float pdf = 0.0;\n        vec3 xi = vec3(randomFloat01(rng), randomFloat01(rng), randomFloat01(rng));\n        f = sampleBsdf(hit, xi, wi, pdf);\n        if (!any(greaterThan(f, vec3(0.0))) || pdf == 0.0) {\n    \t\tbreak;\n        }\n\t\tbeta *= f * abs(dot(wi, hit.normal)) / pdf;\n        \n        ro = hit.position + hit.normal * kNormalThreshold;\n        rd = wi;\n        \n        // --- russian roulette\n        if (bounces > 3) {\n            // --- not exactly luminance =(\n            float Y = max(beta.r, max(beta.g, beta.b));\n    \t\tfloat q = max(0.05, 1.0 - Y);\n            if (randomFloat01(rng) < q) {\n        \t\tbreak;\n            }\n    \t\tbeta /= 1.0 - q;\n\t\t}\n    }\n    \n    return L;\n}\n\nvec3 trace(in vec3 rayOrigin, in vec3 rayDir, in uint rng) {\n#if defined(NON_PBR)\n    return pathTrace(rayOrigin, rayDir, rng);\n#elif defined(PBR)\n    return pathTracePBR(rayOrigin, rayDir, rng);\n#endif\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    uint rngState = uint(uint(fragCoord.x) * uint(1337) + uint(fragCoord.y) * uint(9897) + uint(iFrame) * uint(28721)) | uint(1);\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec3 cameraPos = vec3(-1.0, -8.0, 1.0);\n    vec3 cameraUp = normalize(vec3(0.0, /*0.5*/0.6, 0.2));\n    vec3 cameraRight = vec3(1.0, 0.0, 0.0);\n    vec3 cameraForward = -normalize(cross(cameraUp, cameraRight));\n    float focalLength = 4.1;\n    \n    initScene();\n    \n#if defined(STRATIFIED_SAMPLING)\n    vec3 color = vec3(0.0);\n    \n    float dx = 1.0 / float(STRATIFIED_SAMPLING_DX);\n    float dy = 1.0 / float(STRATIFIED_SAMPLING_DY);\n    for (int y = 0; y < STRATIFIED_SAMPLING_DY; ++y) {\n        for (int x = 0; x < STRATIFIED_SAMPLING_DX; ++x) {\n            vec2 offset = vec2(\n                (float(x) + randomFloat01(rngState)) * dx, \n                (float(y) + randomFloat01(rngState)) * dy\n            );\n            \n            vec2 rayTarget = 2.0 * ((fragCoord.xy + offset) / iResolution.xy) - 1.0;\n            rayTarget.x *= iResolution.x / iResolution.y;\n    \t\tvec3 rayDir = normalize(cameraForward * focalLength + cameraRight * rayTarget.x + cameraUp * rayTarget.y);\n    \t\tcolor += trace(cameraPos, rayDir, rngState);\n        }\n    }\n    color *= 1.0 / (float(STRATIFIED_SAMPLING_DX) * float(STRATIFIED_SAMPLING_DY));\n#else\n    vec2 rayTarget = (fragCoord.xy + vec2(randomFloat01(rngState), randomFloat01(rngState))) / iResolution.xy;\n    rayTarget = 2.0 * rayTarget - 1.0;\n    rayTarget.x *= iResolution.x / iResolution.y;\n        \n    vec3 rayDir = normalize(cameraForward * focalLength + cameraRight * rayTarget.x + cameraUp * rayTarget.y);\n    \n    vec3 color = trace(cameraPos, rayDir, rngState);\n#endif\n    \n#if defined(DEBUG_SINGLE_FRAME)\n    fragColor = vec4(color, 1.0);\n#else\n    bool space = (texture(iChannel1, vec2(32.5 / 256.0, 0.25)).x > 0.1);\n    \n    vec4 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy);\n    float alpha = (space || lastFrameColor.a == 0.0) ? 1.0 : 1.0 / (1.0 + (1.0 / lastFrameColor.a));\n    color = mix(lastFrameColor.rgb, color, alpha);\n    \n    fragColor = vec4(color, alpha);\n#endif    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define STRATIFIED_SAMPLING\n#define STRATIFIED_SAMPLING_DX 3\n#define STRATIFIED_SAMPLING_DY 3\n\n//#define DEBUG_SINGLE_FRAME\n\n//#define NON_PBR\n#define PBR\n\nconst float kMinRayTravelDistance = 0.1;\nconst float kMaxRayTravelDistance = 10000.0;\nconst float kFOVDeg = 90.0;\nconst float kPI = 3.14159265359;\nconst float k2PI = 2.0f * kPI;\nconst float kInvPI = 0.3183099;\nconst float kInv2PI  = 0.15915494309;\nconst float kInv4PI  = 0.07957747154;\nconst int kNumBouncesRT = 8;\nconst float kNormalThreshold = 0.01;\nconst int kNumObjects = 7;\nconst int kNumLights = 3;\n\nconst int kPathTracingMaxDepth = 4;\n\nconst int kObjectBackWall = 0;\nconst int kObjectGroundFloor = 1;\nconst int kObjectSmallBox = 2;\nconst int kObjectMediumSphere = 3;\nconst int kObjectBigSphere = 4;\nconst int kObjectSmallLight = 5;\nconst int kObjectBigLight = 6;\n\nconst int kLightSmall = 0;\nconst int kLightBig = 1;\nconst int kLightEnv = 2;\n\nconst int kFresnelTypeDielectric = 0;\nconst int kFresnelTypeConductor = 1;\n\nconst float kIORAir = 1.00029;\nconst float kIORDielectric = 1.333;\n\nconst float kEnvMapFactor = 0.25;\n\nconst int kNumBxDFs = 3;\n\nvec3 isLessThan(vec3 f, float value) {\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f\n    );\n}\n\nvec3 linearToSRGB(vec3 rgb) {     \n    return mix(\n        pow(rgb, vec3(1.0 / 2.4)) * 1.055 - 0.055,\n        rgb * 12.92,\n        isLessThan(rgb, 0.0031308)\n    );\n}\n\nvec3 srgbToLinear(vec3 rgb) {\n    rgb = clamp(rgb, 0.0, 1.0);\n    \n    return mix(\n        pow(((rgb + 0.055) / 1.055), vec3(2.4)),\n        rgb / 12.92,\n        isLessThan(rgb, 0.04045)\n\t);\n}\n\n// --- http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint wangHash(inout uint seed) {\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat randomFloat01(inout uint state) {\n    return float(wangHash(state)) / 4294967296.0;\n}\n \nvec3 randomUnitVec(in vec2 xi) {\n    float z = xi.x * 2.0 - 1.0;\n    float a = xi.y * k2PI;\n    float r = sqrt(1.0 - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nmat4 rotation(in vec3 axis, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    float omc = 1.0 - c;\n    return mat4(\n    \tc + axis.x * axis.x * omc, axis.x * axis.y * omc - axis.z * s, axis.x * axis.z * omc + axis.y * s, 0.0,\n       \taxis.y * axis.x * omc + axis.z * s, c + axis.y * axis.y * omc, axis.y * axis.z * omc - axis.x * s, 0.0,\n        axis.z * axis.x * omc - axis.y * s, axis.z * axis.y * omc + axis.x * s, c + axis.z * axis.z * omc, 0.0,\n        0.0, 0.0, 0.0, 1.0\n        \n    );\n}\n\nmat4 translation(in vec3 t) {\n    return mat4(\n    \t1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        t.x, t.y, t.z, 1.0 \n    );\n}\n\n// --- http://lolengine.net/blog/2013/09/21/picking-orthogonal-vector-combing-coconuts\nvec3 orthogonal(vec3 v) {\n    return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y);\n}\n\n// --- http://www.pbr-book.org/3ed-2018/Geometry_and_Transformations/Vectors.html#CoordinateSystem\nvoid buildCoordinateSystem(in vec3 v1, inout vec3 v2, inout vec3 v3) {\n    if (abs(v1.x) > abs(v1.y))\n    {\n        v2 = vec3(-v1.z, 0.0, v1.x) / sqrt(v1.x * v1.x + v1.z * v1.z);\n    }\n    else\n    {\n        v2 = vec3(0.0, v1.z, -v1.y) / sqrt(v1.y * v1.y + v1.z * v1.z);\n    }\n    v3 = cross(v1, v2);\n}\n\nvec3 directionFromSphericalCoordsAndBasis(in float sinTheta, in float cosTheta, in float phi, in vec3 x, in vec3 y, in vec3 z) {\n\t return sinTheta * cos(phi) * x + sinTheta * sin(phi) * y + cosTheta * z; \n}\n\nvec3 directionFromSphericalCoords(float sinTheta, float cosTheta, float phi) {\n    return vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n}\n\nvec3 worldToBsdfFrame(in vec3 v, in vec3 t, in vec3 b, in vec3 n)\n{\n    return vec3(dot(v, t), dot(v, b), dot(v, n));\n}\n\nvec3 bsdfFrameToWorld(in vec3 v, in vec3 t, in vec3 b, in vec3 n) {\n    return vec3(t.x * v.x + b.x * v.y + n.x * v.z,\n                t.y * v.x + b.y * v.y + n.y * v.z,\n                t.z * v.x + b.z * v.y + n.z * v.z\n    );\n}\n\n// --- in BSDF frame\nfloat absCosTheta(in vec3 w) { \n    return abs(w.z); \n}\n\nbool sameHemisphere(in vec3 v1, in vec3 v2) {\n    return v1.z * v2.z > 0.0;\n}\n\n// --- http://www.pbr-book.org/3ed-2018/Monte_Carlo_Integration/Importance_Sampling.html#PowerHeuristic\nfloat powerHeuristic(in float nf, in float fPdf, in float ng, in float gPdf) {\n    float f = nf * fPdf, g = ng * gPdf;\n    return (f * f) / (f * f + g * g);\n}\n\n","name":"Common","description":"","type":"common"}]}