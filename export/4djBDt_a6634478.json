{"ver":"0.1","info":{"id":"4djBDt","date":"1502808879","viewed":712,"name":"toon-ish shader","username":"ghost","description":"My attempt at a toon shader -- performs a posterize effect, followed by an edge overlay effect\n","likes":3,"published":1,"flags":16,"usePreview":1,"tags":["toon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define THRESHOLD .5 // edge threshold\n#define LEVELS 10    // number of posterization levels\n#define RADIUS 5     // kuwahara window \n\n/*\n * Posterization is the result of reducing the number of colors \n * in an image. I.e., if you try to view a 24-bit color image in\n * and old 16 color CRT monitor the screen will render a \n * \"posterized\" version of the image \n * http://www.cs.umb.edu/~jreyes/csit114-fall-2007/project4/filters.html#posterize\n */\nvec3 posterize(vec3 c)\n{\n    // Split up each of the color channels into ranges\n    float range = 1./float(LEVELS);\n    float colors[LEVELS];\n    \n    // Assign each range to a specified value \n    // For now set it to the mean\n    for(int i=0; i<LEVELS;i++) {\n        colors[i] = ((float(i)*range)+(float(i+1)*range))/2.;\n    }\n    \n    ivec3 v = ivec3(int(floor(c.r/range)),\n                    int(floor(c.g/range)),\n                    int(floor(c.b/range)));\n    \n    \n\tc.r=colors[v.x];\n    c.g=colors[v.y];\n    c.b=colors[v.z];\n    \n    //c = floor(c * float(LEVELS))/float(LEVELS);;\n  \n    return c; \n}\n\n/*\n * Sobel operator:\n * Convolve image with horizontal and vertical filters\n * that calculates the image gradient (directional change in the\n * intensity or color) thereby detecting an edge \n */\nvec3 edge(vec2 uv, vec2 s) \n{   \n    // Sobel convolution kernels in the horizational \n    // and vertical directions\n    mat3 h = mat3(-1,-2,-1, // first col h[0]\n                   0,0,0,\n                   1,2,1);\n     \n    mat3 v = mat3(1,0,-1,\n                  2,0,-2,\n                  1,0,-1);\n    \n    // populate neighboring pixel box with neighboring pixels\n    mat3 b;\n    for (float i=0.; i<3.; i++) {\n        for (float j=0.; j<3.; j++) {\n            vec4 t = texture(iChannel0,uv + \n                             vec2((i-1.)*s.x,(1.-j)*s.y));\n            b[int(i)][int(j)] = length(t); \n        }\n    }\n\n    // Convolve\n    // Process can be described as \"sliding the kernel over the input image\"\n    //   For each position of the kernel, we multiply the overlapping values \n    //   of the kernel and image together, and add up the results.\n    //   This sum of products will be the value of the output image at the \n    //   point in the input image where the kernel is centered\n    float gx = dot(h[0], b[0]) + dot(h[1], b[1]) + dot(h[2], b[2]);\n    float gy = dot(v[0], b[0]) + dot(v[1], b[1]) + dot(v[2], b[2]);\n\n    // magnitude of gradient\n    float magnitude = clamp(sqrt((gx*gx) + (gy*gy)),0.,.9);\n    \n    if (magnitude >= THRESHOLD)\n        return vec3(0, 0, 0);\n    else\n        return vec3(1, 1, 1);   \n}\n\n// helper func to find min std dev\nvoid findMin(float s, inout float min_sigma, vec4 m, out vec4 c)\n{\n    if (s < min_sigma) {\n        min_sigma = s;\n        c = vec4(m);\n    }\n}\n\n/*\n * Inspired by non-photorealistic techniques, \n * I originally wanted to implement a \n * watercolor/brush-stroke shader...\n * Read some things decided I maybe didn't have time\n * for that -- I found a cool kuwahara filter implementation\n * https://www.shadertoy.com/view/MsXSz4\n *  who is the source of this...not me :) \n * https://en.wikipedia.org/wiki/Kuwahara_filter\n */\nvec4 kuwahara(vec2 uv, vec2 s)\n{        \n    // size of region\n    float size = pow(float(RADIUS + 1),2.);\n\n    vec4 m0,m1,m2,m3,s0,s1,s2,s3;\n    m0 = m1 = m2 = m3 = s0 = s1 = s2 = s3 = vec4(0.0);\n\n    vec4 c;\n\n    // 4 square regions with RADIUS pixels\n    for (int j = -RADIUS; j <= 0; ++j)  {\n        for (int i = -RADIUS; i <= 0; ++i)  {\n            c = texture(iChannel0, uv + vec2(i,j) * s);\n            m0 += c; // mean\n            s0 += c * c; //std dev\n        }\n    }\n\n    for (int j = -RADIUS; j <= 0; ++j)  {\n        for (int i = 0; i <= RADIUS; ++i)  {\n            c = texture(iChannel0, uv + vec2(i,j) * s);\n            m1 += c;\n            s1 += c * c;\n        }\n    }\n\n    for (int j = 0; j <= RADIUS; ++j)  {\n        for (int i = 0; i <= RADIUS; ++i)  {\n            c = texture(iChannel0, uv + vec2(i,j) * s);\n            m2 += c;\n            s2 += c * c;\n        }\n    }\n\n    for (int j = 0; j <= RADIUS; ++j)  {\n        for (int i = -RADIUS; i <= 0; ++i)  {\n            c = texture(iChannel0, uv + vec2(i,j) * s);\n            m3 += c;\n            s3 += c * c;\n        }\n    }\n    \n    // calculate mean & std dev\n    m0 /= size;\n    s0 = abs(s0 / size - m0 * m0);\n    m1 /= size;\n    s1 = abs(s1 / size - m1 * m1);\n    m2 /= size;\n    s2 = abs(s2 / size - m2 * m2);\n    m3 /= size;\n    s3 = abs(s3 / size - m3 * m3);\n    \n    // find min std dev \n    // set output to corresponding mean\n    float min_sigma = 1e+2;   \n    \n    float ms = s0.r + s0.g + s0.b;\n    findMin(ms,min_sigma,m0,c);\n    \n    ms = s1.r + s1.g + s1.b;\n    findMin(ms,min_sigma,m1,c);\n    \n    ms = s2.r + s2.g + s2.b;\n    findMin(ms,min_sigma,m2,c);\n    \n    ms = s3.r + s3.g + s3.b;\n    findMin(ms,min_sigma,m3,c);\n    \n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 s = vec2(1./iResolution.x, 1./iResolution.y);\n    vec3 c = texture(iChannel0, uv).xyz ;\n\n    c = kuwahara(uv,s).xyz;  \n    //c = posterize(c);\n    c *= edge(uv,s);\n      \n    //animate -- comment out to see filters alone\n    c = mix(texture(iChannel0, uv).xyz, c, clamp(0.5+0.5*sin(iTime), 0.,1.));\n    \n    fragColor = vec4(c,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}