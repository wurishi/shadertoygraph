{"ver":"0.1","info":{"id":"7ll3zS","date":"1665766408","viewed":175,"name":"Cat Volleyball","username":"magician0809","description":"Cat Volleyball","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["cat","pbr","volleyball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define LIGHT_DIR normalize(vec3(-1.0, 1.0, -1.0))\n#define LIGHT_COL vec3(1.0, 1.0, 1.0)\n#define GRID_SIZE 2.0\n#define RAY_LEN 32.0\n\nCamera GetCamera()\n{\n    vec3 forward;\n    if (iMouse.z > 0.5)\n    {\n        forward = MouseRotation(iMouse.xy, iResolution.xy);\n    }\n    else\n    {\n        const float speed = 0.125;\n        forward.y = sin(0.618 * speed * iTime) * 0.35;\n        forward.xz = vec2(-sin(iTime * speed), cos(iTime * speed));\n        forward = normalize(forward);\n    }\n    Camera cam;\n    cam.forward = forward;\n    cam.up = vec3(0.0, 1.0, 0.0);\n    cam.position = -(GRID_SIZE * 2.0) * cam.forward;\n    cam.aspect = iResolution.x / iResolution.y;\n    cam.fieldOfView = 60.0;\n    return cam;\n}\n\nvec3 GetFogColor(vec3 rd)\n{\n    return mix(vec3(0.0), vec3(1.0), rd.y * 0.5 + 0.5);\n}\n\nfloat GetFogIntensity(float t, float start, float decay)\n{\n    t = clamp((t - start) / (1.0 - start), 0.0, 1.0);\n    return 1.0 - pow(1.0 - pow2(t), decay);\n}\n\nvec4 SampleVolleyball(vec3 dirVec)\n{\n    vec2 uv0 = dirVec.xy;\n    vec2 uv1 = dirVec.yz;\n    vec2 uv2 = dirVec.zx;\n    uv0.x = (uv0.x * 0.3 + 0.5) * sign(dirVec.z) + iTime * -0.125 * 2.5;\n    uv1.x = (uv1.x * 0.3 + 0.5) * sign(dirVec.x) + iTime * -0.125 * 2.5;\n    uv2.x = (uv2.x * 0.3 + 0.5) * sign(dirVec.y) + iTime * -0.125 * 2.5;\n    uv0.y = (uv0.y * 0.8 + 0.5);\n    uv1.y = (uv1.y * 0.8 + 0.5);\n    uv2.y = (uv2.y * 0.8 + 0.5);\n    vec4 col0 = texture(iChannel0, uv0);\n    vec4 col1 = texture(iChannel0, uv1);\n    vec4 col2 = texture(iChannel0, uv2);\n    col0.rgb = pow(col0.rgb, vec3(2.2));\n    col1.rgb = pow(col1.rgb, vec3(2.2));\n    col2.rgb = pow(col2.rgb, vec3(2.2));\n    //col0 *= pow2(dirVec.z);\n    //col1 *= pow2(dirVec.x);\n    //col2 *= pow2(dirVec.y);\n    col0 *= smoothstep(0.577350, 0.6, abs(dirVec.z)) * smoothstep(0.577350, 0.55, abs(dirVec.y));\n    col1 *= smoothstep(0.577350, 0.6, abs(dirVec.x)) * smoothstep(0.577350, 0.55, abs(dirVec.z));\n    col2 *= smoothstep(0.577350, 0.6, abs(dirVec.y)) * smoothstep(0.577350, 0.55, abs(dirVec.x));\n    return col0 + col1 + col2;\n}\n\nvoid SampleMaterial(vec3 normal, out vec3 diffuse, out vec3 specular, out float roughness)\n{\n    vec4 mainTex = SampleVolleyball(normal);\n    //vec3 albedo = mainTex.rgb;\n    vec3 albedo = mix(vec3(1.0, 0.1, 0.2), mainTex.rgb, mainTex.a);\n    float metallic = smoothstep(1.0, 0.0, mainTex.b);\n    MetallicSteup(albedo, metallic, diffuse, specular);\n    roughness = max(1.0 - mainTex.r, 0.04);\n}\n\nvec4 sdSphere(vec3 pos, vec4 sphere, out vec3 normal)\n{\n    pos -= sphere.xyz;\n    float len = length(pos);\n    float sd = len - sphere.w;\n    normal = sign(sd) * pos / len;\n    return vec4(sd * normal, sd);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, vec2 range, vec4 sphere, out vec3 normal)\n{\n    float t = range.x;\n    for (int i = 0; i < 100; ++i)\n    {\n        vec3 pos = ro + rd * t;\n\n        vec3 guvw = fract(pos / GRID_SIZE + 0.5);\n        vec3 gpos = (guvw - 0.5) * GRID_SIZE;\n\n        vec4 sd = sdSphere(gpos, sphere, normal);\n        if (abs(sd.w) < 0.001) return t;\n        if (t > range.y) break;\n        float dt = abs(sd.w);\n        t += dt;\n    }\n    return -1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    \n    vec4 sphere = vec4(0.0, 0.0, 0.0, 0.5);\n    \n    Camera cam = GetCamera();\n    vec2 texelSize = 1.0 / iResolution.xy;\n    vec2 uvScreen = fragCoord * texelSize;\n\n    AA_BEGIN(2, uv, uvScreen)\n    \n        vec3 col0 = vec3(0);\n        vec3 ro = cam.position;\n        vec3 rd = MakeWorldRay(uv, cam);\n\n        vec3 hitNormal = vec3(0.0);\n        float hitDist = RayMarch(ro, rd, vec2(0.75, RAY_LEN), sphere, hitNormal);\n        if (hitDist > 0.0)\n        {\n            vec3 diffuse, specular;\n            float roughness;\n            SampleMaterial(hitNormal, diffuse, specular, roughness);\n            vec3 sphCol = vec3(0.0);\n            sphCol += DirectRadiance(hitNormal, -rd, LIGHT_DIR, LIGHT_COL, diffuse, specular, roughness);\n            sphCol += IndirectRadiance(iChannel1, 256., hitNormal, -rd, diffuse, specular, roughness);\n\n            float t = hitDist / RAY_LEN;\n            col0 = mix(sphCol, GetFogColor(rd), GetFogIntensity(t, 0.1, 0.5));\n        }\n        else\n        {\n            col0 = GetFogColor(rd);\n        }\n    \n    AA_END(col, col0)\n\n    col = pow(col, vec3(1.0 / 2.2));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n//============================================================ Macro\n\n#define E (2.71828182846)\n#define PI (3.14159265359)\n#define HALF_PI (PI * 0.5)\n#define DOUBLE_PI (PI * 2.0)\n\n#define AA_BEGIN(aa,uv,uv0) const int AA=aa; \\\n    for(int aj=0;aj<AA;++aj)for(int ai=0;ai<AA;++ai){ \\\n    vec2 uv=uv0;uv+=vec2(dFdx(uv.x),dFdy(uv.y))*((vec2(ai,aj)+.5)/float(AA)-.5);\n#define AA_END(col,col0) col.rgb+=(col0).rgb/float(AA*AA);}\n\n//============================================================ Common\n\nfloat pow2(float x) {return x * x;}\nfloat pow3(float x) {return x * x * x;}\nfloat pow4(float x) {return pow2(x) * pow2(x);}\nfloat pow5(float x) {return pow4(x) * x;}\n\nbool GetKeyDown(sampler2D keyMap, int keyCode)\n{\n    return texture(keyMap, vec2((float(keyCode) + 0.5) / 256.0, 0.25)).x >= 0.5;\n}\n\nbool GetKeyToggle(sampler2D keyMap, int keyCode)\n{\n    return texture(keyMap, vec2((float(keyCode) + 0.5) / 256.0, 0.75)).x >= 0.5;\n}\n\n//============================================================ Camera\n\nstruct Camera\n{\n    vec3 position;\n    vec3 forward;\n    vec3 up;\n    float aspect;\n    float fieldOfView;\n};\n\nmat3 LookAt(vec3 forward, vec3 up)\n{\n    mat3 m;\n    m[2] = forward;\n    m[0] = normalize(cross(up, m[2]));\n    m[1] = cross(m[2], m[0]);\n    return m;\n}\n\nvec3 MakeViewRay(vec2 uv, Camera cam)\n{\n    vec3 ray = vec3(uv, 1.0);\n    ray.xy = ray.xy * 2.0 - 1.0;\n    ray.x *= cam.aspect;\n    ray.xy *= tan(radians(cam.fieldOfView * 0.5));\n    return normalize(ray);\n}\n\nvec3 MakeWorldRay(vec2 uv, Camera cam)\n{\n    vec3 ray = MakeViewRay(uv, cam);\n    return LookAt(cam.forward, cam.up) * ray;\n}\n\nvec3 MouseRotation(vec2 screenPos, vec2 screenSize)\n{\n    vec2 muv = screenPos / screenSize;\n    muv = muv * 2.0 - 1.0;\n    muv.x *= screenSize.x / screenSize.y;\n    muv *= vec2(PI, HALF_PI);\n    muv.y = clamp(muv.y, -0.99 * HALF_PI, 0.99 * HALF_PI);\n    vec4 rot = vec4(cos(muv.x), sin(muv.x), cos(muv.y), sin(muv.y));\n    return normalize(vec3(rot.y * rot.z, rot.w, rot.x * rot.z));\n}\n\n//============================================================ PBR\n\nvoid MetallicSteup(vec3 albedo, float metallic, out vec3 diffuse, out vec3 specular)\n{\n    diffuse = albedo * (1.0 - metallic);\n    specular = mix(vec3(0.04), albedo, metallic);\n}\n\nfloat Geometry(float NoV, float NoL, float k)\n{\n    float gv = 0.5 / (NoV * (1.0 - k) + k);\n    float gl = 0.5 / (NoL * (1.0 - k) + k);\n    return gv * gl;\n}\n\nfloat Distribution(float NoH, float alpha)\n{\n    float a2 = alpha * alpha;\n    float denom = NoH * NoH * (a2 - 1.0) + 1.0;\n    return a2 / (denom * denom);\n}\n\nvec3 Fresnel(float NoV, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow5(1.0 - NoV);\n}\n\nvec3 DirectSpecular(float NoV, float NoL, float NoH, float HoV, vec3 F0, float roughness)\n{\n    float alpha = roughness * roughness;\n    float G = Geometry(NoV, NoL, pow2(alpha + 1.0) / 8.0);\n    float D = Distribution(NoH, alpha);\n    vec3 F = Fresnel(HoV, F0);\n    return G * D * F;\n}\n\nvec3 DirectRadiance(vec3 normal, vec3 viewDir, vec3 lightDir, vec3 lightCol, vec3 diffuse, vec3 specular, float roughness)\n{\n    vec3 halfDir = normalize(viewDir + lightDir);\n    float NoV = max(dot(normal, viewDir), 0.0);\n    float NoL = max(dot(normal, lightDir), 0.0);\n    float NoH = max(dot(normal, halfDir), 0.0);\n    float HoV = max(dot(halfDir, viewDir), 0.0);\n    vec3 radiance = diffuse;\n    radiance += DirectSpecular(NoV, NoL, NoH, HoV, specular, roughness);\n    radiance *= NoL * lightCol;\n    return radiance;\n}\n\nvec3 IndirectSpecular(samplerCube envMap, float mapSize, vec3 normal, vec3 viewDir, vec3 specular, float roughness)\n{\n    vec3 reflDir = reflect(-viewDir, normal);\n    float NoV = max(dot(normal, viewDir), 0.0);\n    vec3 F = Fresnel(NoV, specular);\n    float sigma = pow2(roughness) / (1.0 + roughness);\n\tfloat lod = 1.0 + log2(sigma * mapSize);\n    return F * pow(textureLod(envMap, reflDir, lod).rgb, vec3(2.2));\n}\n\nvec3 IndirectRadiance(samplerCube envMap, float mapSize, vec3 normal, vec3 viewDir, vec3 diffuse, vec3 specular, float roughness)\n{\n    vec3 radiance = vec3(0.0);\n    radiance += IndirectSpecular(envMap, mapSize, normal, viewDir, specular, roughness);\n    radiance += diffuse * pow(textureLod(envMap, normal, log2(mapSize)).rgb, vec3(2.2));\n    return radiance;\n}\n","name":"Common","description":"","type":"common"}]}