{"ver":"0.1","info":{"id":"7lffRr","date":"1650463221","viewed":47,"name":"zyq_ball_2","username":"zhouyongqiang","description":"ball","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//球的有距离函数\nfloat shpereSDF(vec3 p)\n{\n\n    return length(p) - 1.0;\n}\n\n//torus\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdBox( vec3 p)\n{\n  vec3 b = vec3(1.0, 1.0,1.0);\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat mySDF(vec3 p)\n{\n    float distA = sdBox(p);\n    float distB = shpereSDF(p + vec3(-1.5, 0.0, 0.0));\n    float distC = shpereSDF(p + vec3(1.5, 0.0, 0.0));\n    float distD = shpereSDF(p + vec3(0.0,0.0, 1.5));\n    float distE = shpereSDF(p + vec3(0.0,0.0, -1.5));\n    return  unionSDF(unionSDF(unionSDF(unionSDF(distA, distB), distC),distD),distE);\n}\n\n\nvec3 getNormalForSDF(vec3 pos)\n{\n    const float step = 0.01;\n    const vec3 dx = vec3(step, 0.0, 0.0);\n    const vec3 dy = vec3(0.0, step, 0.0);\n    const vec3 dz = vec3(0.0, 0.0, step);\n    \n    return normalize(\n    vec3(\n        mySDF(pos + dx) - mySDF(pos - dx),\n        mySDF(pos + dy) - mySDF(pos - dy),\n        mySDF(pos + dz) - mySDF(pos - dz)\n        )\n    );\n}\nvec3 getNormalForSDF_simple(vec3 pos)\n{\n    return pos;\n}\n\n//是否射线跟踪到物体\nbool raycastObj(vec3 camPos, vec3 viewdir, out vec3 collisionPos, out vec3 normal)\n{\n    float t = 0.0;\n    float maxDis = 50.0;\n    vec3 pos;\n    float dis;\n    while(t < maxDis)\n    {\n        pos = camPos + viewdir * t;\n        dis = mySDF(pos);\n        if(dis < 0.001) //在sdf边界上\n        {\n            break;\n        }\n        t += min(abs(dis), 0.5);\n        if(t > maxDis)\n            break;\n    }\n    \n    if(t >= maxDis)\n        return false;\n  \n    //此时camPos+t*dir在sdf内部或者边界上\n    \n    //求出准确的射线与sdf的碰撞点\n    float a = t - 0.2;\n    float b = t + 0.2;\n    float eps = 0.01;\n    int i = 0;\n    while(dis > eps && i < 20)\n    {\n        t = (a + b) / 2.0;\n        pos = camPos + viewdir * t;\n        dis = mySDF(pos);\n        if(dis > 0.0)\n        {\n            a = t;\n        }\n        i ++;\n    }\n    \n    //此时碰撞点为pos = camPos + viewDir * t\n    collisionPos = pos;\n    \n    //求出sdf上的法线\n    normal = getNormalForSDF(pos);\n    \n    return true;\n}\n\n//获取绕y轴旋转的矩阵\nmat3x3 getRotateYMat(float deg)\n{\n    float a00 = cos(deg);\n    float a02 = sin(deg);\n    float a20 = -a02;\n    float a22 = a00;\n    return mat3x3(\n        a00, 0., a02,\n        0., 1., 0.,\n        a20, 0., a22\n    );\n}\n\nfloat saturate(float v)\n{\n    if(v < 0.0)return 0.0;\n    if(v > 1.0) return 1.0;\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy* 2.0 - 1.0;\n    float radio = iResolution.x / iResolution.y;\n    uv.x *= radio;\n\n    vec3 cameraPos = vec3(0.0, 0.0, -4.0);\n    \n    float camera_Near_width = 2.0;\n    float camera_Near_height = 2.0;\n    float camera_near = 1.0;\n   //获取摄像机射出的光线\n   vec3 gridPos = cameraPos;\n   gridPos.x += camera_Near_width * uv.x;\n   gridPos.y += camera_Near_height * uv.y;\n   gridPos.z += camera_near;\n   //旋转动画\n   float deg = iTime * 1.0;\n   mat3x3 rotate = getRotateYMat(deg);\n   cameraPos = rotate * cameraPos;\n   gridPos = rotate * gridPos;\n   vec3 viewDir = normalize(gridPos - cameraPos);\n\n   //对视线进行光线跟踪\n   vec3 collisionPos;\n   vec3 normal = vec3(0.0, 0.0, 0.0);\n   bool catch = raycastObj(cameraPos, viewDir, collisionPos, normal);\n   \n   if(catch)\n   {\n       //phone光照模型\n       vec3 diffuse = vec3(1.0);\n       vec3 lightPos = vec3(5.0, 5.0, -6.0);\n       vec3 lightDir = normalize(lightPos);\n       vec3 lightColor = vec3(0.7);\n       vec3 embient = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n       vec3 color = diffuse * lightColor * saturate(dot(lightDir , normal));\n       color = floor((color + 0.3) * 2.0) / 2.0;\n       \n       //高光反射模型\n       float gross = 50.0;\n       vec3 specularColor = vec3(1.0);\n       vec3 halfDir = normalize(viewDir + lightPos);\n       vec3 specular =  pow(saturate(dot(halfDir,normal)), gross) * specularColor * lightColor;\n       //specular = floor((specular * 5.3) * 2.0) / 2.0;\n       \n       fragColor = vec4(color + embient + specular, 1.0);\n       \n       //卡通化\n       color = fragColor.xyz;\n       fragColor.xyz = color;\n   }\n   else\n   {\n       fragColor = vec4(0.0);\n   }\n}","name":"Image","description":"","type":"image"}]}