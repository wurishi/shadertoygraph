{"ver":"0.1","info":{"id":"7sdSzH","date":"1632682860","viewed":196,"name":" Cast Voxels March Sub-Objects 2","username":"jt","description":"Based on [url]https://www.shadertoy.com/view/4dX3zl[/url] Branchless Voxel Raycasting by fb39ca4 -\nadded different ray-[b]marched[/b] subobjects & in this variant near & far bounding-box hit-positions are reconstructed directly from the DDA.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","raycasting","voxel","fork","dda","textured","subobjects"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/7sdSzH Cast Voxels March Sub-Objects 2\n// Extending https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting by fb39ca4\n// (with loop optimization by kzy), DDA based on http://lodev.org/cgtutor/raycasting.html\n// by adding raymarched subobjects & reconstructing bounding-box hit-positions from DDA (jt).\n\n// tags: 3d, raymarching, raycasting, voxel, dda, textured, subobjects, fork\n\n// Warning:\n// I suspect there are a few corner-cases where the bounding-distances are wrong,\n// resulting the shader to stall when looking at the grid from certain angles.\n// (Added maximal iterations counter - does that fix this issue?)\n\nfloat sdSphere(vec3 p, float d)\n{\n    return length(p) - d;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdMixed(vec3 p, int id)\n{\n    if(id == 0) return sdSphere(p, 0.5);\n    if(id == 1) return sdBox(p, vec3(0.4));\n    return 0.0;\n}\n\nbool getVoxel(ivec3 c) {\n    vec3 p = vec3(c) + vec3(0.5);\n    float d = max(-sdSphere(p, 7.5), sdBox(p, vec3(6.0)));\n    //float d = min(max(-sdSphere(p, 7.5), sdBox(p, vec3(6.0))), -sdSphere(p, 25.0));\n    return d < 0.0;\n}\n\n#define PI 3.1415926\n\nfloat checker(vec3 p)\n{\n    //return step(0.5, length(1.0 - abs(2.0 * fract(p) - 1.0))); // dots\n    return step(0.0, sin(PI * p.x + PI/2.0)*sin(PI *p.y + PI/2.0)*sin(PI *p.z + PI/2.0));\n    //return step(0.0, sin(p.x)*sin(p.y)*sin(p.z));\n}\n\nmat2 rotate(float t)\n{\n    return mat2(vec2(cos(t), sin(t)), vec2(-sin(t), cos(t)));\n}\n\n#define MAX_ITER 200u\n#define MAX_DIST 1000.0\n#define EPSILON 0.001\n\n// raymarch subobject\nfloat march(vec3 ro, vec3 rd, float tmin, float tmax, int id)\n{\n    uint i;\n    float t;\n    for(i = 0u, t = tmin; i < MAX_ITER, t < tmax; i++)\n    {\n        float h = sdMixed(ro + rd * t, id);\n        if(h < EPSILON)\n            return t;\n        t += h;\n    }\n    return MAX_DIST;\n}\n\n// https://iquilezles.org/articles/normalsSDF tetrahedron normals\nvec3 normal( vec3 p, int id )\n{\n    const float h = EPSILON;\n    const vec2 k = vec2(1,-1);\n    return normalize(k.xyy * sdMixed(p + k.xyy * h, id) +\n                     k.yyx * sdMixed(p + k.yyx * h, id) +\n                     k.yxy * sdMixed(p + k.yxy * h, id) +\n                     k.xxx * sdMixed(p + k.xxx * h, id));\n}\n\nvec4 process_subobject(vec3 ro, vec3 rd, float tmin, float tmax, int id)\n{\n    float d = march(ro, rd, tmin, tmax, id);\n    vec3 n = normal(ro + rd * d, id);\n    return vec4(n, d);\n}\n\n// \"The raycasting code is somewhat based around a 2D raycasting toutorial found here:\n//  http://lodev.org/cgtutor/raycasting.html\" (fb39ca4)\n\n#define MAX_RAY_STEPS 64\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenPos = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    screenPos.x *= iResolution.x / iResolution.y;\n    vec3 rayDir = vec3(screenPos.x, screenPos.y, 2.0);\n    vec3 rayPos = vec3(0.0, 0.0,-20.0);\n\n    mat2 S = mat2(vec2(0.0, 1.0), vec2(-1.0, 0.0));\n    rayPos.yz = S * rayPos.yz;\n    rayDir.yz = S * rayDir.yz;\n\n    mat2 R = rotate(iTime / 5.0);\n    rayPos.xy = R * rayPos.xy;\n    rayDir.xy = R * rayDir.xy;\n    \n    rayDir = normalize(rayDir);\n\n    vec3 color = vec3(0.0);\n    vec4 result = vec4(vec3(0.0), MAX_DIST);\n\n    {\n        vec3 deltaDist = 1.0 / abs(rayDir);\n        ivec3 rayStep = ivec3(sign(rayDir));\n        bvec3 mask0 = bvec3(false);\n        ivec3 mapPos0 = ivec3(floor(rayPos + 0.));\n        vec3 sideDist0 = (sign(rayDir) * (vec3(mapPos0) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist;\n\n        //for (int i = 0; i < MAX_RAY_STEPS; i++)\n        for (int i = min(iFrame,0); i < MAX_RAY_STEPS; i++) // prevent unrolling loop to avoid crash on windows\n        {\n            // Core of https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting\n            bvec3 mask1 = lessThanEqual(sideDist0.xyz, min(sideDist0.yzx, sideDist0.zxy));\n            vec3 sideDist1 = sideDist0 + vec3(mask1) * deltaDist;\n            ivec3 mapPos1 = mapPos0 + ivec3(vec3(mask1)) * rayStep;\n\n            if (getVoxel(mapPos0))\n            {\n                // reconstruct near & far bounding-box hit-positions from previous & current state of DDA.\n                //vec2 bounds = vec2(length(vec3(mask0) * (sideDist0 - deltaDist)) / length(rayDir), length(vec3(mask1) * (sideDist1 - deltaDist)) / length(rayDir)); // rayDir not normalized\n                vec2 bounds = vec2(length(vec3(mask0) * (sideDist0 - deltaDist)), length(vec3(mask1) * (sideDist1 - deltaDist))); // rayDir already normalized\n                if(min(abs(mapPos0.x), min(abs(mapPos0.y),abs(mapPos0.z))) > 5) // explicit sky-box (letting loop run-out without hitting a wall causes blocky artifacts)\n                    break;\n                //result = process_subobject(rayPos - vec3(mapPos0) - vec3(0.5), rayDir, bounds.x, bounds.y, i > 10 ? 1 : 0);\n                result = process_subobject(rayPos - vec3(mapPos0) - vec3(0.5), rayDir, bounds.x, bounds.y, texture(iChannel0, 0.1 * vec3(mapPos0)).x < 0.5 ? 0 : 1);\n                if(result.w > 0.0 && result.w < bounds.y)\n                {\n                    color = vec3(1.0);\n                    //color *= 0.5 + 0.5 * normalize(result.xyz);\n                    vec3 dst = rayPos + rayDir * result.w;\n                    //color *= texture(iChannel0, dst).xyz;\n                    color *= vec3(0.5 + 0.5 * checker(dst));\n\n                    vec3 fogcolor = vec3(0.25, 0.4, 0.5); // fog\n                    //vec3 fogcolor = vec3(0.75, 0.6, 0.3); // smog\n                    color *= mix(fogcolor, color, exp(-result.w * result.w / 200.0)); // fog for depth impression & to suppress flickering\n\n                    break;\n                }\n            }\n            \n            sideDist0 = sideDist1;\n            mapPos0 = mapPos1;\n        }\n    }\n\n    vec3 ambient = vec3(0.1);\n    vec3 lightdir = normalize(vec3(3.0, 2.0, 1.0));\n    color *= mix(ambient, vec3(1.0), clamp(dot(lightdir, result.xyz), 0.0, 1.0));\n\n    fragColor.rgb = sqrt(color);\n}\n","name":"Image","description":"","type":"image"}]}