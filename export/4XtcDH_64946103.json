{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"//\n// right-hand rule, z+ direction towards viewer.\n//\n#define MAX_MARCHING_STEPS 255\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define PRECISION 0.001\n#define COLOR_BACKGROUND vec3(0.55, 0.23, 0.71)\n#define PI 3.1415926\n\n\n// Sphere tracing...\nvec2 rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float id = -1.;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    vec2 res = map(p);\n    float d = res.x;\n    id = res.y;\n    if (d < PRECISION || depth > MAX_DIST) break;\n    depth += d;\n  }\n\n  return vec2(depth, id);\n}\n\n\nvec3 render(vec3 ro, vec3 rd, vec2 uv) {\n    vec3 col = COLOR_BACKGROUND;\n\n    vec2 res = rayMarch(ro, rd);\n    float d = res.x; // signed distance value\n    if (d > MAX_DIST) return col; // render background color since ray hit nothing\n\n    float id = res.y; // id of object\n\n    vec3 p = ro + rd * d; // point on sphere or floor we discovered from ray marching\n    vec3 normal = calcNormal(p);\n    vec3 lightPosition = vec3(2, 2, 7);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    // vec4 textureFloor = texture(iChannel0, uv); floor texture determined by uv. this will make floot texture move while camera moving.\n    vec4 textureFloor = texture(iChannel0, p.xz);\n\n    float dif = clamp(dot(normal, lightDirection), 0.3, 1.);\n\n    // if (id > 0.) col = dif * vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0));\n    if (id > 0.) col = dif * vec3(1. + textureFloor.xyz * mod(floor(p.x) + floor(p.z), 2.0));\n    // if (id > 0.) col = dif * textureFloor.xyz;\n    if (id > 1.) col = dif * vec3(0, .8, .8);\n    if (id > 2.) col = dif * vec3(1, 0.58, 0.29);\n\n    col += COLOR_BACKGROUND * 0.2; // add a bit of the background color to blend objects more with the scene\n\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5; // map (0, 0) to the center of screen\n    uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    m -= 0.5;\n    \n    // vec2 offset = texelFetch(iChannel1, ivec2(0, 0), 0).xy; // 2D keyboard move\n    vec3 offset = texelFetch(iChannel1, ivec2(0, 0), 0).xyz; // 3D keyboard move\n    vec3 camera_origin = vec3(0., 0., 5);\n    // camera_origin += vec3(offset, 0); // 2D keyboard move\n    camera_origin += offset; // 3D keyboard move\n    vec3 ray_direction = normalize(vec3(uv, -1)); // assume the viewport frame is at z = -2 (1 unit far from camera origin) \n    ray_direction *= rotateY(-m.x) * rotateX(m.y);\n    // ray_direction *= rotateX(PI);\n    vec3 col = render(camera_origin, ray_direction, uv);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"// SDF shape defined here\n\n\nfloat SDFSphere(vec3 p, vec3 c, float r)\n{\n    return length(p - c) - r;\n}\n\nfloat SDFFloor(vec3 p) {\n  return p.y + 1.;\n}\n\n\n// find the nearest SDF object, return its SDF value.\nfloat SDFScene(vec3 p)\n{\n    float sphereLeft = SDFSphere(p, vec3(-2, 0, -1), 1.);\n    float sphereRight = SDFSphere(p, vec3(2, 0, -1), 1.);\n    float res = min(sphereLeft, sphereRight);\n    return min(res, SDFFloor(p));\n}\n\n\n// different shapes \"union\". \nvec2 opU( vec2 d1, vec2 d2 )\n{\n  return (d1.x < d2.x) ? d1 : d2; // the x-component is the signed distance value\n}\n\n\n// More common usage:\n// Use map() to get minimum SDF value and the hit object's ID;\n// Then, assign color by ID when rendering.\n\n// return the smallest SDF value and its corresponding ID.\nvec2 map(vec3 p) {\n  vec2 res = vec2(1e10, 0.); // ID = 0\n  vec2 flooring = vec2(SDFFloor(p), 0.5); // ID = 0.5\n  vec2 sphereLeft = vec2(SDFSphere(p, vec3(-2.5, 0, -2), 1.), 1.5); // ID = 1.5\n  vec2 sphereRight = vec2(SDFSphere(p, vec3(2.5, 0, -2), 1.), 2.5); // ID = 2.5\n\n  res = opU(res, flooring);\n  res = opU(res, sphereLeft);\n  res = opU(res, sphereRight);\n  return res; // the y-component is the ID of the object hit by the ray\n}\n\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    float r = 1.; // radius of sphere\n    return normalize(\n      e.xyy * map(p + e.xyy).x +\n      e.yyx * map(p + e.yyx).x +\n      e.yxy * map(p + e.yxy).x +\n      e.xxx * map(p + e.xxx).x);\n}\n\n// more precise gradient\nvec3 calcNormal2(vec3 p) {\n  float e = 0.0005; // epsilon\n  float r = 1.; // radius of sphere\n  return normalize(vec3(\n    map(vec3(p.x + e, p.y, p.z)).x - map(vec3(p.x - e, p.y, p.z)).x,\n    map(vec3(p.x, p.y + e, p.z)).x - map(vec3(p.x, p.y - e, p.z)).x,\n    map(vec3(p.x, p.y, p.z  + e)).x - map(vec3(p.x, p.y, p.z - e)).x\n  ));\n}\n\n// rotate\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_W = 87;\nconst int KEY_S = 83;\nconst int KEY_A = 65;\nconst int KEY_D = 68;\nconst int KEY_Q = 81;\nconst int KEY_E = 69;\n\nconst float velocity = 1. / 100.; // This will cause offset to change by 0.01 each time an arrow key is pressed\n\nvec2 handleKeyboard(vec2 offset) {\n\n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n    vec2 left = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x * vec2(-1, 0);\n    vec2 up = texelFetch(iChannel1, ivec2(KEY_UP,0), 0).x * vec2(0, 1);\n    vec2 right = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x * vec2(1, 0);\n    vec2 down = texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x * vec2(0, -1);\n\n    offset += (left + up + right + down) * velocity;\n\n    return offset;\n}\n\nvec3 handleKeyboard3D(vec3 offset) \n{\n    vec3 left = texelFetch(iChannel1, ivec2(KEY_A, 0), 0).x * vec3(-1, 0, 0);\n    vec3 right = texelFetch(iChannel1, ivec2(KEY_D, 0), 0).x * vec3(1, 0, 0);\n    vec3 up = texelFetch(iChannel1, ivec2(KEY_Q, 0), 0).x * vec3(0, 1, 0);\n    vec3 down = texelFetch(iChannel1, ivec2(KEY_E, 0), 0).x * vec3(0, -1, 0);\n    vec3 front = texelFetch(iChannel1, ivec2(KEY_W, 0), 0).x * vec3(0, 0, -1);\n    vec3 back = texelFetch(iChannel1, ivec2(KEY_S, 0), 0).x * vec3(0, 0, 1);\n    offset += (left + right + up + down + front + back) * velocity;\n    return offset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Return the offset value from the last frame (zero if it's first frame)\n    vec3 offset = texelFetch( iChannel0, ivec2(0, 0), 0).xyz;\n\n    // Pass in the offset of the last frame and return a new offset based on keyboard input\n    // offset = handleKeyboard(offset); // 2D\n    offset = handleKeyboard3D(offset);\n\n    // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n    // fragColor = vec4(offset, 0, 0); // 2D\n    fragColor = vec4(offset, 0);\n}","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":true,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"4XtcDH","date":"1735026071","viewed":34,"name":"learn Ray marching basic","username":"MadDonkey","description":"Learn the basic ray marching method on ShaderToy.\nAlso an example about how to utilize different miscs by channel!\nPress WASDQE to move like 3D camera.","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""}}