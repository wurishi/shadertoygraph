{"ver":"0.1","info":{"id":"wlXczS","date":"1592325862","viewed":50,"name":"1st time: value noise","username":"bipinoli","description":"Learning from the amazing:\nhttps://www.shadertoy.com/user/BigWIngs\n\nFollowing his youtube tutorials: \"The art of code\" (https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["learningshaders"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float randomNoise(vec2 uv) {\n\treturn fract(sin(uv.x*500. + uv.y*521.)*1251.);\n}\n\nfloat noise(vec2 uv) {\n \t// idea:\n    // 1: generate a grid\n    // 2: for each cell in a grid\n    //    \t1. put random values at vertices of the grid\n    //\t\t2. smoothly interpolate values inside the grid\n    \n    vec2 insideGrid = fract(uv*10.); // [0-1] -> linear\n    vec2 gridId = floor(uv*10.);\n    \n\tinsideGrid = smoothstep(0., 1., insideGrid); // [0-1] -> non-linear \n    \n    float vBottomLeft = randomNoise(gridId);\n    float vTopLeft = randomNoise(gridId + vec2(0., 1.));\n    float vBottomRight = randomNoise(gridId + vec2(1., 0.));\n    float vTopRight = randomNoise(gridId + vec2(1., 1.));\n    \n    float interpolatedValue1 = mix(vBottomLeft, vTopLeft, insideGrid.y);\n    float interpolatedValue2 = mix(vBottomRight, vTopRight, insideGrid.y);\n    float interpolatedValue = mix(interpolatedValue1, interpolatedValue2, insideGrid.x);\n    \n    return interpolatedValue;  \n}\n\n\nfloat superimposedNoise(vec2 uv) {\n    // lets superimpose multiple harmonics of the noise for \n    // better result\n    float freq = .4;\n    float amp = 1.;\n    \n    float c = noise(uv*freq) * amp; // fundamental\n    c += noise(uv*freq*2.) * amp/2.; // 2nd harmonics\n    c += noise(uv*freq*4.) * amp/4.; // 4th harmonics\n    c += noise(uv*freq*8.) * amp/8.; // 8th harmonics\n    c += noise(uv*freq*16.) * amp/16.; // 16th harmonics\n    c += noise(uv*freq*32.) * amp/32.; // 32nd harmonics\n    c += noise(uv*freq*64.) * amp/64.; // 64th harmonics\n    \n    //normalize c\n    c /= 2.;\n    \n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n   \n\tuv.x += fract(iTime * 0.04);\n    \n    float c = superimposedNoise(uv);\n    \n    vec3 col = vec3(c);\n    //col.gb = insideGrid;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}