{"ver":"0.1","info":{"id":"MlKBzm","date":"1542151418","viewed":233,"name":"Infinite Spheres (Bare-bones)","username":"hackerpoet","description":"Bare-bones ray marcher for drawing infinite spheres.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["spheres","raymarcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int max_iters = 500;\nfloat max_dist = 1000.0;\nvec3 bg_col = vec3(0.8, 0.8, 1.0);\nvec3 fg_col = vec3(1.0, 1.0, 0.6);\n\n/**\n * Rotation matrix from angles\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, s),\n        vec3(0, -s, c)\n    );\n}\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n//the signed distance field function\n//used in the ray march loop\nfloat sdf(vec3 p) {\n    //a sphere of radius 1.\n    return length( p ) - 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n//1 : retrieve the fragment's coordinates\n\tvec2 uv = ( fragCoord.xy / iResolution.xy ) * 2.0 - 1.0;\n\t//preserve aspect ratio\n\tuv.x *= iResolution.x / iResolution.y;\n\n\n//2 : camera position and ray direction\n\tvec3 pos = vec3( 2.0, 2.0,-20.);\n\tvec3 dir = normalize( vec3( uv, 3.0 ) );\n\n    vec2 mos = (iMouse.xy / iResolution.xy) - vec2(0.5);\n    pos = rotateY(iTime / 6.0) * pos;\n    dir = rotateY(mos.x * 3.0) * rotateX(mos.y * 3.0) * dir;\n    \n//3 : ray march loop\n    //ip will store final color\n\tvec3 col = bg_col;\n\n\t//variable step size\n\tfloat t = 0.0;\n    int i = 0;\n\tfor(; i < max_iters; i++) {\n        //update position along path\n        vec3 ip = pos + dir * t;\n\n        //gets the shortest distance to the scene\n        float m = 4.0;\n        ip = abs(mod(ip - m*0.5, m) - m*0.5);\n\t\tfloat d = sdf( ip );\n\n        //break the loop if the distance was too small\n        //this means that we are close enough to the surface\n        if (d < 0.01) {\n            float a = float(i) / float(max_iters);\n            float diffuse = dot(ip, vec3(0.6, 0.8, 0.0))*0.5 + 0.5;\n            col = fg_col * diffuse * (1.0 - a) + bg_col * a;\n            break;\n        }\n\n\t\t//increment the step along the ray path\n\t\tt += d;\n\n        //break if too far\n        if (t > max_dist) {\n            break;\n        }\n\t}\n        \n\n//4 : apply color to this fragment\n\tfragColor = vec4(col, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}