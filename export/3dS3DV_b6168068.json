{"ver":"0.1","info":{"id":"3dS3DV","date":"1549980664","viewed":114,"name":"Complex Plotter","username":"Rinku","description":"Plots a complex function.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["math"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The input is a complex number with the x-axis as the real\n// part and the y-axis as the imaginary part.\n//\n// The output number is displayed by a color where\n// hue is the argument and the brightness is the magnitude.\n\n// -----------------------------------------------------------\n\n// Constants\nconst float pi = 3.14159265359;\nconst float pi2 = 2.0 * 3.14159265359;\nconst float piD3 = 3.14159265359 / 3.0;\n\n// -----------------------------------------------------------\n\n// Viewport\n\n// X scale\nconst float Xs = 3.0;\n// X offset\nconst float Xo = 0.0;\n// Y scale\nconst float Ys = 2.0;\n// Y offset\nconst float Yo = 0.0;\n\nconst mat3 view = mat3\n(\n\tXs ,0.0,Xo,\n    0.0,Ys ,Yo,\n    0.0,0.0,1.0\n);\n\n// -----------------------------------------------------------\n\n// Math operations for complex numbers\n\nvec2 CxMul(vec2 a, vec2 b)\n{\n    return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n}\n\nvec2 CxSquare(vec2 a)\n{\n    return vec2(a.x*a.x - a.y*a.y, 2.0*a.x*a.y);\n}\n\nvec2 CxCon(vec2 a)\n{\n    return vec2(a.x,-a.y);\n}\n\nfloat CxAbs(vec2 a)\n{\n    return sqrt(dot(a,a));\n}\n\nfloat CxPhase(vec2 a)\n{\n    return mod(atan(a.y,a.x),pi2);\n}\n\nvec2 CxPolarize(vec2 a)\n{\n    return vec2(CxPhase(a),CxAbs(a));\n}\n\nvec2 CxDiv(vec2 a, vec2 b)\n{\n    return CxMul(a,CxCon(b))/dot(b,b);\n}\n\nvec2 CxExp(vec2 a)\n{\n    return exp(a.x)*vec2(cos(a.y),sin(a.y));\n}\n\nvec2 CxLog(vec2 a)\n{\n    a = CxPolarize(a);\n    return vec2(log(a.y),a.x);\n}\n\nvec2 CxPow(vec2 a, vec2 b)\n{\n    return CxExp(CxMul(CxLog(a),b));\n}\n\n// -----------------------------------------------------------\n\n// Engine\n\nvec3 h1(float h)\n{\n    return vec3\n    (\n        clamp(abs(3.0-h/piD3) - 1.0,0.0,1.0),\n        clamp(2.0 - abs(2.0-h/piD3),0.0,1.0),\n        clamp(2.0 - abs(4.0-h/piD3),0.0,1.0)\n    );\n}\n\nvec3 h2(float h)\n{\n    return vec3\n    (\n        (1.0 + cos(h))/2.0,\n        (1.0 + cos(h - 2.0*piD3))/2.0,\n        (1.0 + cos(h - 4.0*piD3))/2.0\n    );\n}\n\nvec3 v1(vec3 a, float v)\n{\n    a *= 1.0 - abs(2.0*v-1.0);\n    \n    if(v > 0.5) a += vec3(2.0*v - 1.0);\n    \n    return clamp(a,0.0,1.0);\n}\n\nvec3 v2(vec3 a,float v)\n{\n    vec3 r = vec3(v*v);\n    r-= 2.0*v*(v-1.0)*a;\n    return r;\n}\n\n// Color from hue and value\nvec3 Color(float h,float v)\n{\n    // H gives a color from hue\n    // H1 is sharper\n    // H2 is smoother\n    vec3 a = h2(h);\n    \n    // V modifies the brightness off a color generated by H\n    // V1 is sharper\n    // V2 is smoother\n    return v1(a,v);\n}\n\nvec3 ComplexColor(vec2 a)\n{\n    a = CxPolarize(a);\n    return Color(a.x,1.0 - 1.0/(1.0 + a.y));\n}\n\n// Gets mouse coordinates\nvec2 m()\n{\n    vec2 M = 2.0*(iMouse.xy/iResolution.xy-0.5);\n    return (vec3(M,1.0) * view).xy;\n    \n}\n\n// -----------------------------------------------------------\n\n\n// This is the function used for plotting.\n// Feel free to change it.\nvec2 f(vec2 x)\n{\n    vec2 x2 = x-m();\n    vec2 x3 = x-vec2(cos(iTime),sin(iTime));\n    \n    vec2 v = CxDiv(x3,x2);\n    return CxMul(x,v);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = (vec3(uv,1.0) * view).xy;\n\t\n    vec2 p = f(uv);\n    \n    vec3 col = ComplexColor(p);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}