{"ver":"0.1","info":{"id":"Xd2yRK","date":"1492958740","viewed":444,"name":"Fake Caustics - But yellow","username":"Niels_Dewitte","description":"Caustics fake based on wave distance value and color remapping.","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["2d","fake","caustics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int AMOUNT_OF_ORBS = 24;\n\nfloat Distance(vec2 pos1, vec2 pos2){\n \treturn sqrt(pow(pos1.x - pos2.x,2.0) + pow(pos1.y - pos2.y,2.0));   \n}\n\nfloat SemiRandom(float i){\n\treturn fract(pow((i + 105449.0) * 50023.0, 0.479) * 4.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0, 1.0, 1.0, 1);\n    \n    //Go over all points\n    for(int i = 0; i < AMOUNT_OF_ORBS; i++){\n        \n        //time offset based movement of the points\n        float offsetx = float(i * 110) \t* SemiRandom(float(i + 56846)) + sin(float(i * 5117)) * 80.0;\n        float offsety = float(i * 20) \t* SemiRandom(float(i + 12358)) + sin(float(i * 1248)) * 10.0; \n        \n        float posx = iTime * iResolution.x / 5.2 * (SemiRandom(float(i + 123))-0.4) + offsetx;\n        float posy = iTime * iResolution.y / 5.2 * (SemiRandom(float(i + 123))-0.4) + offsety;\n            \n        //points around the area\n       \tvec2 posxplus \t= vec2(mod(posx, iResolution.x) + iResolution.x\t, mod(posy, iResolution.y));\n        vec2 posyplus \t= vec2(mod(posx, iResolution.x) \t\t\t\t, mod(posy, iResolution.y)+ iResolution.y);\n        vec2 posWrap \t= vec2(mod(posx, iResolution.x)\t\t\t\t\t, mod(posy, iResolution.y));\n        vec2 posxmin \t= vec2(mod(posx, iResolution.x) - iResolution.x\t, mod(posy, iResolution.y));\n    \tvec2 posymin \t= vec2(mod(posx, iResolution.x)\t\t\t\t\t, mod(posy, iResolution.y)- iResolution.y);\n        \n        vec2 posxpyp   \t= vec2(mod(posx, iResolution.x) + iResolution.x\t, mod(posy, iResolution.y)+ iResolution.y);\n        vec2 posxmym   \t= vec2(mod(posx, iResolution.x) - iResolution.x\t, mod(posy, iResolution.y)- iResolution.y);\n        vec2 posxpym\t= vec2(mod(posx, iResolution.x) + iResolution.x\t, mod(posy, iResolution.y)- iResolution.y);\n        vec2 posxmyp   \t= vec2(mod(posx, iResolution.x) - iResolution.x\t, mod(posy, iResolution.y)+ iResolution.y);\n        \n        float size = 8.0 + sin(float(i)) * 1.8;\n        \n        //Find lowest distance\n        float d = 20000.0;\n        d = min(d, Distance(fragCoord.xy, posWrap));\n        d = min(d, Distance(fragCoord.xy, posxplus));\n        d = min(d, Distance(fragCoord.xy, posyplus));\n        d = min(d, Distance(fragCoord.xy, posxmin));\n        d = min(d, Distance(fragCoord.xy, posymin));\n        \n        d = min(d, Distance(fragCoord.xy, posxpyp));\n        d = min(d, Distance(fragCoord.xy, posxmym));\n        d = min(d, Distance(fragCoord.xy, posxpym));\n        d = min(d, Distance(fragCoord.xy, posxmyp));\n        \n        //Distance ramp\n        float fadeDist = iResolution.y * 0.52;\n        if(d < fadeDist)\n        {\n            d /= fadeDist;\n           \tvec4 color = vec4(\n                1.0 * (d), \n                1.0 * (d),\n                1.0 * (d), \n                1);\n            \n            fragColor = min(fragColor, color);\n        }\n    }\n    \n    //Recoloring\n    //Play around with these\n    vec4 multiColor = \t\tvec4(0.92, \t0.72, \t0.8, \t1);\n    vec4 addColor =\t\t\tvec4(0.25, \t0.18, \t0.1, \t1);\n    vec4 backGroundAdd = \tvec4(0.2,\t0.12,\t0.01,\t1);\n    \n    fragColor *= multiColor;\n    fragColor += addColor;\n    \n    fragColor.x = pow(fragColor.x, 4.0);\n    fragColor.y = pow(fragColor.y, 4.2);\n    fragColor.z = pow(fragColor.z, 6.1);\n    \n    fragColor += backGroundAdd;\n    \n}","name":"Image","description":"","type":"image"}]}