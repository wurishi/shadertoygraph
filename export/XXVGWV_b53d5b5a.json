{"ver":"0.1","info":{"id":"XXVGWV","date":"1718253267","viewed":39,"name":"ColorMarching","username":"JohnShadow","description":"Here's my try at \"color marching.\" Where I tried to ray march over color, just to find out I don't have to.\nHere's a work in progress version of the fuller algorithm. I'm still working out the kinks.\nhttps://www.shadertoy.com/view/M3V3D3","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","gi","colorbleed","colormarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define orbit 10.0\n#define depth 200\n#define shadowFallOff 5.0\nfloat sdfSphere(vec3 a)\n{\n    return length(a) - 1.0;\n}\nfloat sdfPlain(vec3 a, vec3 normal)\n{\n \treturn abs(dot(a, normal));\n}\nvec3 normalSphere(vec3 position)\n{\n\treturn normalize(position);\n}\nvec3 normalPlain(vec3 position)\n{\n\treturn vec3(0, 1, 0);\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat map(vec3 position)\n{\n    return min(sdfPlain(position, vec3(0,1,0)), min(sdfSphere(position), sdfSphere(position + vec3(0, -1, 2.0))));\n}\nvec3 colorMap(vec3 position, vec3 lightDirection)\n{\n    // This algorithm takes a normal feild (which can be pre baked).\n    // Then it uses the distance feild along with the normal to then figure out\n    // \"if this ray + direction were a sample, would it be in shadow?\"\n    // It then uses that to figure out diffuse information.\n    vec3 an = normalSphere(position);\n    vec3 bn = normalPlain(position);\n    vec3 cn = normalSphere(position + vec3(0, -1, 2.0));\n    float ad = sdfSphere(position);\n    float bd = sdfPlain(position, vec3(0,1,0));\n    float cd = sdfSphere(position + vec3(0, -1, 2.0));\n    return ((vec3(1.0, 1.0, 1.0) * max(dot(an, lightDirection),0.))/(ad * ad + 1.0) + \n           (vec3(0.5, 0.2, 0.1) * max(dot(bn, lightDirection),0.))/(bd * bd + 1.0) + \n           (vec3(0.1, 0.1, 1.0) * max(dot(cn, lightDirection),0.))/(cd * cd + 1.0));\n}\nvec3 getnormal (vec3 p)\n{\n const float eps = 0.001;\n \n return normalize\n ( vec3\n \t( map(p + vec3(eps, 0, 0) ) - map(p - vec3(eps, 0, 0)),\n \t  map(p + vec3(0, eps, 0) ) - map(p - vec3(0, eps, 0)),\n\t  map(p + vec3(0, 0, eps) ) - map(p - vec3(0, 0, eps))\n \t)\n );\n}\nvec4 march(vec3 start, vec3 direction)\n{\n    vec3 position = start;\n    float fd = 0.0, cd = 0.0;\n    for(int i = 0; i < depth; ++i)\n    {\n        cd = map(position);\n        position += direction * cd;\n        fd += cd;\n     \tif(cd < 0.0001)\n            return vec4(position, fd);\n    }\n    return vec4(position, 0.0);\n}\nvec4 shadowMarch(vec3 start, vec3 direction)\n{\n    vec3 position = start;\n    float fd = 0.0, cd = 0.0;\n    vec3 color = vec3(0.0);\n    float depthf = float(depth);\n    int i = 0;\n    for(i = 0; i < depth; ++i)\n    {\n        cd = map(position) * 0.5;\n        //Sum colors and dot products over light direction ray to \"fake\" some color bleed.\n        color += colorMap(position, direction);\n        position += direction * cd;\n        fd += cd;\n     \tif(cd < 0.0001)\n            return vec4(color/float(i + 1), 1.0);\n        if(fd > 1000.0)\n            return vec4(color/float(i + 1), 0.0);\n    }\n    return vec4(color/float(i + 1), 0.0);\n}\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = (-1.0 + 2.0*fragCoord.xy / iResolution.xy) * vec2(iResolution.x/iResolution.y, 1.0)*2.;\n\t\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n\tvec3 ori = vec3(-orbit, 5.0, -orbit);\n    mat4 viewToWorld = viewMatrix(ori, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 dir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    vec3 normal, color;\n    \n    // Time varying pixel color\n    vec4 hit = march(ori, dir);\n    if(hit.w != 0.0)  \n    {\n        vec3 lightDir = normalize(vec3(cos(iTime), 1.0, sin(iTime)));\n        normal = getnormal(hit.xyz);\n        vec4 shadowMarch = shadowMarch(hit.xyz + normal * 0.0025, lightDir);\n        //subtract out shadows from color and mix some of it back so there's light in the shadows.\n        color = colorMap(hit.xyz + normal * 0.0025, lightDir);\n        color = mix(color, color - shadowMarch.xyz, 0.92);\n    }\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}