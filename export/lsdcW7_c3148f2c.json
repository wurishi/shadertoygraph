{"ver":"0.1","info":{"id":"lsdcW7","date":"1519205175","viewed":487,"name":"Menger spline tour","username":"utak3r","description":"Really nice layered variation of a Menger Sponge, designed by Shane, flying through a Catmull-Rom spline.\nFor more info, read the description in the code itself.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*!\n * <info>\n *\n * Menger Sponge Tour - flight along the Catmull-Rom spline\n * \n * This really nice layered variation of a Menger Sponge\n * was designed by Shane: https://www.shadertoy.com/view/ldyGWm\n * \n * Also the lighting is from him. It's unusual, but... that's why I like it :)\n * So I only tweaked it a bit and parameterized it, as I'm usually working \n * in Synthclipse. The most tweaks went to shadowing, as it was giving some bad \n * artifatcs, like circles.\n *\n * The flight is done using an 8-points path. This path is looped, and calculated\n * using Catmull-Rom spline.\n * There's a problem with some segments combinations, though. It can result in a jump -\n * and maybe even in a completely black frame :/ if you can see, what's wrong, please note me.\n * \n * If you want, you can watch the high quality render with some music here:\n * https://youtu.be/Wcl7td4yXfA\n *\n * </info>\n */\n\n\n// Flight speed. Total duration will be 8*flightSpeed.\nconst float flightSpeed = 0.125; //! slider[0.1, 0.25, 2]\n// Field of view\nconst float FOV = 2.; //! slider[0.5, 2, 4]\n// Gamma correction\nconst float Gamma = .75; //! slider[0.1, 0.8, 3.0]\n// Darker parts of panels texturing\nconst vec3 darkColor = vec3(.329,.078,.5); //! color[.4, .2, .1]\n// Fog distance\nconst float fogDistance = 24.; //! slider[10, 24, 100]\n// Fog color\nconst vec3 fogColor = vec3(1.,0.,.12); //! color[1, 0, 0.12]\n// Light position\nconst float lightDistance = -.15; //! slider[-2, -.15, 2]\n// AO iterations\nconst int aoIterations = 5; //! slider[1, 5, 10]\n// Shadow light\nconst float shadowLight = .45; //! slider[0, 0.5, 1]\n\n\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n )\n{\n    n = max(n*n, 0.001); // n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );\n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// Smooth minimum function. There are countless articles, but IQ explains it best here:\n// https://iquilezles.org/articles/smin\nfloat sminP( float a, float b, float smoothing ){\n\n    float h = clamp( 0.5+0.5*(b-a)/smoothing, 0.0, 1.0 );\n    return mix( b, a, h ) - smoothing*h*(1.0-h);\n}\n\n// This layered Menger sponge is stolen from Shane\n// https://www.shadertoy.com/view/ldyGWm\n// Just modified it a bit, but its main construction is his idea - and I love it :)\nfloat map(vec3 q)\n{\n \tvec3 p = abs(fract(q/3.)*3. - 1.5);\n \tfloat d = min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1. + .04;\n\n    p =  abs(fract(q) - .5);\n \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./3. + .05);\n\n    p =  abs(fract(q*2.)*.5 - .25);\n \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - .5/3. - .015);\n\n    p =  abs(fract(q*3./.5)*.5/3. - .5/6.);\n\n    return max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./27. - .015);\n}\n\n// Raymarching\nfloat trace(vec3 ro, vec3 rd){\n\n    float t = 0., d;\n    for(int i=0; i< 48; i++){\n        d = map(ro + rd*t);\n        if (d <.0025*t || t>fogDistance) break;\n        t += d;\n    }\n    return t;\n}\n\n// Reflections\nfloat refTrace(vec3 ro, vec3 rd)\n{\n    float t = 0., d;\n    for(int i=0; i< 16; i++){\n        d = map(ro + rd*t);\n        if (d <.0025*t || t>fogDistance) break;\n        t += d;\n    }\n    return t;\n}\n\n// Tetrahedral normal (from IQ)\nvec3 normal(in vec3 p)\n{\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.003, -0.003);\n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\n// Ambient occlusion, for that self shadowed look.\n// XT95 came up with this particular version. Very nice.\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calculateAO(in vec3 p, in vec3 n)\n{\n\tfloat ao = 0.0, l;\n\tconst float falloff = 1.;\n\n    const float maxDist = 1.;\n    for(float i=1.; i<float(aoIterations)+.5; i++){\n\n        l = (i + hash(i))*.5/float(aoIterations)*maxDist;\n        ao += (l - map( p + n*l ))/ pow(1. + l, falloff);\n    }\n\n    return clamp( 1.-ao/float(aoIterations), 0., 1.);\n}\n\n// Soft shadows.\n// Its params are very sensitive and can cause\n// some really bad artifacts.\nfloat softShadow(vec3 ro, vec3 lp, float k)\n{\n    const int maxIterationsShad = 32;\n\n    vec3 rd = (lp-ro); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.002;\n    float end = max(length(rd), 0.001);\n    float stepDist = end/float(maxIterationsShad);\n\n    rd /= end;\n\n    for (int i=0; i < maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        dist += clamp(h, 0.0001, 0.2);\n\n        // Early exit\n        if (h < 0.00001 || dist > end) break;\n    }\n\n    // Light the shadows up\n    return min(max(shade, 0.) + shadowLight, 1.0);\n}\n\nvec3 camPathTable[8];\nvoid setCamPath()\n{\n    const float mainCorridor = 2.82*2.;\n\n    // right now it's only through the main corridors.\n    // it'd be nice to enter also the smaller ones, too :)\n    camPathTable[0] = vec3(0, 0, 0);\n    camPathTable[1] = vec3(0, 0, mainCorridor);\n    camPathTable[2] = vec3(0, -mainCorridor, mainCorridor);\n    camPathTable[3] = vec3(mainCorridor, -mainCorridor, mainCorridor);\n    camPathTable[4] = vec3(mainCorridor, -mainCorridor, 0);\n    camPathTable[5] = vec3(0, -mainCorridor, 0);\n    camPathTable[6] = vec3(-mainCorridor, -mainCorridor, 0);\n    camPathTable[7] = vec3(-mainCorridor, 0, 0);\n}\n\n/*\n * http://graphics.cs.ucdavis.edu/education/CAGDNotes/Catmull-Rom-Spline/Catmull-Rom-Spline.html\n * f(x) = [1, t, t^2, t^3] * M * [P[i-1], P[i], P[i+1], P[i+2]]\n */\nvec3 catmullRomSpline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t)\n{\n\tvec3 c1,c2,c3,c4;\n\n\tc1 = p1;\n\tc2 = -0.5*p0 + 0.5*p2;\n\tc3 = p0 + -2.5*p1 + 2.0*p2 + -0.5*p3;\n\tc4 = -0.5*p0 + 1.5*p1 + -1.5*p2 + 0.5*p3;\n\n\treturn (((c4*t + c3)*t + c2)*t + c1);\n}\n\nvec3 camPath(float t)\n{\n\t// Capacity of path points table\n\tconst int aNum = 8;\n\n\t// Loop to aNum\n    t = fract(t/float(aNum))*float(aNum);\n\n    // Segment number\n    int segNum = int(floor(t));\n    // Segment portion [0..1]\n    float segTime = t - float(segNum);\n\n    // Catmull-Rom spline needs surrounding control points,\n    // so we're looping the path, making every point has enough neighbours.\n    if (segNum == 0) return catmullRomSpline(camPathTable[aNum-1], camPathTable[0], camPathTable[1], camPathTable[2], segTime);\n    if (segNum == aNum-2) return catmullRomSpline(camPathTable[aNum-3], camPathTable[aNum-2], camPathTable[aNum-1], camPathTable[0], segTime);\n    if (segNum == aNum-1) return catmullRomSpline(camPathTable[aNum-2], camPathTable[aNum-1], camPathTable[0], camPathTable[1], segTime);\n\n   \treturn catmullRomSpline(camPathTable[int(segNum)-1], camPathTable[int(segNum)], camPathTable[int(segNum)+1], camPathTable[int(segNum)+2], segTime);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 u = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\tfloat speed = iTime * flightSpeed;\n\tsetCamPath();\n\n    vec3 ro = camPath(speed); // Camera position\n    vec3 lk = camPath(speed + .5);  // Look At\n    vec3 lp = camPath(speed + lightDistance); // Light position.\n\n    // Camera vectors\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0, -fwd.x));\n    vec3 up = (cross(fwd, rgt));\n\n    vec3 rd = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n\n    // Initiate the scene color to black.\n    vec3 col = vec3(0);\n\n    float t = trace(ro, rd);\n\n    // Lighting is completely taken from Shane.\n    if (t < fogDistance)\n    {\n        vec3 sp = ro + rd*t; // Surface position.\n        vec3 sn = normal(sp); // Surface normal.\n        vec3 ref = reflect(rd, sn); // Reflected ray.\n\n\t\tconst float ts = 2.; // Texture scale.\n        vec3 oCol = tex3D(iChannel0, sp*ts, sn); // Texture color at the surface point.\n\n\n        // Darker toned paneling.\n        vec3 q = abs(mod(sp, 3.) - 1.5);\n        if (max(max(q.x, q.y), q.z) < 1.063) oCol = oCol*darkColor;\n\n        // Bringing out the texture colors a bit.\n        oCol = smoothstep(0.0, 1.0, oCol);\n\n        float sh = softShadow(sp, lp, 16.); // Soft shadows.\n        float ao = calculateAO(sp, sn); // Self shadows.\n\n        vec3 ld = lp - sp; // Light direction.\n        float lDist = max(length(ld), 0.001); // Light to surface distance.\n        ld /= lDist; // Normalizing the light direction vector.\n\n        float diff = max(dot(ld, sn), 0.); // Diffuse component.\n        float spec = pow(max(dot(reflect(-ld, sn), -rd), 0.), 12.); // Specular.\n        //float fres = clamp(1.0 + dot(rd, sn), 0.0, 1.0); // Fresnel reflection term.\n\n        float atten = 1.0 / (1.0 + lDist*0.25 + lDist*lDist*.1); // Attenuation.\n\n\n        // Secondary camera light, just to light up the dark areas a bit more. It's here just\n        // to add a bit of ambience, and its effects are subtle, so its attenuation\n        // will be rolled into the attenuation above.\n        diff += max(dot(-rd, sn), 0.)*.45;\n        spec += pow(max(dot(reflect(rd, sn), -rd), 0.), 12.)*.45;\n\n        // Based on Eiffie's suggestion. It's an improvement, but I've commented out,\n        // for the time being.\n        //spec *= curve(sp);\n\n\n\t\t// REFLECTION BLOCK.\n        //\n        // Cheap reflection: Not entirely accurate, but the reflections are pretty subtle, so not much\n        // effort is being put in.\n        float rt = refTrace(sp + ref*0.1, ref); // Raymarch from \"sp\" in the reflected direction.\n        vec3 rsp = sp + ref*rt; // Reflected surface hit point.\n        vec3 rsn = normal(rsp); // Normal at the reflected surface.\n\n        vec3 rCol = tex3D(iChannel0, rsp*ts, rsn); // Texel at \"rsp.\"\n        q = abs(mod(rsp, 3.) - 1.5);\n        if (max(max(q.x, q.y), q.z)<1.063) rCol = rCol*vec3(.7, .85, 1.);\n        // Toning down the power of the reflected color, simply because I liked the way it looked more.\n        rCol = sqrt(rCol);\n        float rDiff = max(dot(rsn, normalize(lp-rsp)), 0.); // Diffuse at \"rsp\" from the main light.\n        rDiff += max(dot(rsn, normalize(-rd-rsp)), 0.)*.45; // Diffuse at \"rsp\" from the camera light.\n\n        float rlDist = length(lp - rsp);\n        float rAtten = 1./(1.0 + rlDist*0.25 + rlDist*rlDist*.1);\n        rCol = min(rCol, 1.)*(rDiff + vec3(.5, .6, .7))*rAtten; // Reflected color. Not accurate, but close enough.\n        //\n    \t// END REFLECTION BLOCK.\n\n\n        // Combining the elements above to light and color the scene.\n        col = oCol*(diff + vec3(.5, .6, .7)) + vec3(.5, .7, 1)*spec*2. + rCol*0.25;\n\n\n        // Shading the scene color, clamping, and we're done.\n        col = min(col*atten*sh*ao, 1.);\n\n    }\n\n    // Fadeout to a fog\n    col = mix(col, fogColor, smoothstep(0., fogDistance - 15., t));\n\n    // Last corrections\n\tcol = pow(clamp(col, 0.0, 1.0), vec3(1.0 / Gamma));\n    fragColor = vec4(col, 1.0);\n\n}\n","name":"Image","description":"","type":"image"}]}