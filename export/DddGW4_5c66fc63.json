{"ver":"0.1","info":{"id":"DddGW4","date":"1677285036","viewed":112,"name":"Hexagonal Belousov-Zhabotinsky","username":"petrakat","description":"ldsfhgsjdkfgs","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["cellularautomata"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float DARKNESS_FOR_HEXES = 0.5;\n\nconst float RESOLUTION = 5.0;\n\nivec2 pxToHex(vec2 px) {\n    float sqrt3 = sqrt(3.0);\n    \n    float x = px.x / (RESOLUTION * sqrt3);\n    float y = px.y / (RESOLUTION * sqrt3);\n    \n    float tmp = floor(x + sqrt3 * y + 1.0);\n    int q = int((floor(2.0 * x + 1.0) + tmp) / 3.0);\n    int r = int((tmp + floor(-x + sqrt3 * y + 1.0)) / 3.0);\n    \n    return ivec2(q, r);\n}\n\nvec2 hexToPx(ivec2 hex) {\n    float sqrt3 = sqrt(3.0);\n\n    // I'm not sure why I need the -hex.y here\n    vec2 xy = vec2(\n        sqrt3 * float(hex.x - hex.y) + sqrt3/2.0 * float(hex.y),\n        1.5 * float(hex.y)\n    );\n    return xy * RESOLUTION;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 movieSample = texture(iChannel1, fragCoord / iResolution.xy).rgb;\n\n    ivec2 hex = pxToHex(fragCoord);\n    vec2 pxAgain = hexToPx(hex);\n    \n    vec3 movieHexSample = texture(iChannel1, pxAgain / iResolution.xy).rgb;\n    \n    float brightness = (movieSample.r + movieSample.g + movieSample.b) / 3.0;\n    if (brightness < DARKNESS_FOR_HEXES) {\n        vec2 hexRes = iResolution.xy / RESOLUTION;\n        vec2 st = vec2(float(hex.x) / hexRes.x, float(hex.y) / hexRes.y);\n    \n        float bzVal = texture(iChannel0, st).r / 100.0;\n        \n        float t = brightness / DARKNESS_FOR_HEXES;\n        float mixAmt = (1.0 - t) * (1.0 - t) * (1.0 - t);\n        vec3 col = mix(\n            movieSample, \n            vec3(bzVal) * DARKNESS_FOR_HEXES, \n            vec3(mixAmt));\n        fragColor = vec4(col, 1.0);\n    } else {\n        fragColor = vec4(movieSample, 1.0);\n    }\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Does the BZ sim\n// https://www.redblobgames.com/grids/hexagons/#map-storage\n// just throw away the extra space I suppose\n// Store in the R channel, between 0 and 1 waugh\n//  \n//  ##\n// #X#\n// ##\n\nconst float THRESHOLD = 100.0;\nconst float INFECTION_PROGRESSION = 1.0;\nconst float ILL_INFLUENCE = 1.0;\nconst float INFECTED_INFLUENCE = 1.0;\n\nfloat bz(vec2 px) {    \n    vec2 res = iResolution.xy;\n\n    float self = texture(iChannel0, px/res).r;\n\n    float illCount = 0.0;\n    float infectedCount = 0.0;\n    float sum = self;\n    for (float dx = -1.0; dx <= 1.0; dx++)\n        for (float dy = -1.0; dy <= 1.0; dy++) {\n            if (dx == -dy) continue;\n             \n            vec2 npos = (px + vec2(dx, dy)) / res;\n            float neighbor = texture(iChannel0, npos).r;\n            if (neighbor >= THRESHOLD)\n                illCount += 1.0;\n            else if (neighbor > 0.0)\n                infectedCount += 1.0;\n                \n            sum += neighbor;\n        }\n        \n    \n    float result = 0.0;\n    if (self >= THRESHOLD) {\n        result = 0.0;\n    } else if (self > 0.0) {\n        result = min(\n            trunc(sum / 7.0 + INFECTION_PROGRESSION),\n            THRESHOLD\n        );\n    } else {\n        result = trunc(infectedCount / INFECTED_INFLUENCE)\n            + trunc(illCount / ILL_INFLUENCE);\n    }\n    \n    return result;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {    \n    if (iFrame <= 3) {\n        float rand = fract(43758.5453123 \n            * sin(dot(fragCoord.xy/iResolution.xy, vec2(12.9898,78.233))));\n        fragColor = vec4(vec3(rand * THRESHOLD), 1.0);\n    } else {\n        float rawBZ = bz(fragCoord);\n        fragColor = vec4(vec3(rawBZ), 1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}