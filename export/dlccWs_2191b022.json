{"ver":"0.1","info":{"id":"dlccWs","date":"1699828537","viewed":119,"name":"Fast 2D Indirect Path-Marching","username":"TwentySeven","description":"I was bored and accidentally made indirect lighting","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["light","indirect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define noisestep 16\n#define marchstep 64\n#define zoom 16.\nvec3 colorizer(vec2 p){\n    \nreturn \n((p.x>11.9)?vec3(.8,.2,.2):vec3(0,0,0))+\n((p.x<-11.9)?vec3(.2,.8,.2):vec3(0,0,0))+\n((p.x>-11.9&&p.x<11.9)?vec3(1,1,1):vec3(0,0,0))+\n((p.y>11.9)?vec3(1):vec3(0))+\n((box(p,vec2(11,13))<0.)?vec3(1):vec3(0))+\n((p.x<-12.0&&p.x>12.0)?vec3(1,1,1):vec3(0,0,0))\n;\n}\nfloat GetSceneDistance(vec2 point){\nvec2 mo = (iMouse.xy - .5*iResolution.xy)/zoom;\n    vec3 set1 = vec3(-6., -9, 1.); // (xyz, radius)\n    vec3 set2 = vec3(7, -9, 3.); // (xyz, radius)\n    vec3 set3 = vec3(-10, -9, 0.5); // (xyz, radius)\n    \n    float Block = box(point-set1.xy,vec2(3));\n\n    float Sphere = length(point - set2.xy)-set2.z;\n\n    float Cut = box(point-set3.xy,vec2(8,2.));\n    float ceiling =box(point-vec2(0,12),vec2(64,2.));\n    float hole = box(point - vec2(0,11),vec2(8,4.1));\n\n    float d =min(Sphere,Block); \n    float sky = box(point,vec2(12));\n     float G = max(max(min(d,-sky),-Cut),point.y-13.);\n     return min(max(min(G,ceiling),-hole),box(point-mo,vec2(1)));\n     \n     \n     ;}\nfloat RayMarch(vec2 ray_origin, vec2 ray_dir){\n    float d = 0.;\n    \n    for(int i = 0; i < marchstep; i++)\n    {\n        vec2 p = ray_origin + ray_dir * d;\n    \n        float ds = GetSceneDistance(p); \n        d += ds; \n        if(d > 200. || ds < 0.01) \n            break;  // hit object or out of scene\n    }\n    return d; \n}\nvec2 GetNormal(vec2 point){\n    \n    float d = GetSceneDistance(point); \n    vec2 e = vec2(0.001, 0); \n    vec2 n = d - vec2(\n        GetSceneDistance(point - e.xy),\n        GetSceneDistance(point - e.yx)\n    );\n    \n    return normalize(n); \n}\nfloat Shadow( in vec2 ro, in vec2 rd, float mint, float maxt){\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<marchstep && t<maxt; i++ )\n    {\n        float h = GetSceneDistance(ro + t*rd);\n        res = min( res, h );\n        t += clamp(h, 0.1, 1.);\n        if( res<-0.0 || t>maxt ) break;\n    }\n    if(res<-0.0){\n    res=0.;}\n    else{res=1.;}\n    return (res);\n}\nfloat AO( in vec2 pos, in vec2 nor ){\n\tfloat occ = 0.0;\n    float sca = 1.0;\n  \n        float h = 0.5;\n        float d = GetSceneDistance( pos + (nor*h) );\n        sca *= 0.5;\n    occ += (h-d)*sca;\n    \n    \n    return smoothstep(0.,1.,clamp( 1.0 - 1.5*occ, 0.0, 1.0 ));    \n}\nvec3 diffusion(vec2 pos,vec2 dir, float d,vec2 n, vec2 p,vec2 lpos,vec2 ldir, vec3 color, bool bounce){\n    if(bounce==true)\n    pos =pos+dir*d;\n\n\n    \n    d = RayMarch(pos, dir);\n    p = (pos) + (d) * (dir);\n    n=GetNormal(p);\n    vec3 result = clp(Shadow(lpos,ldir,d,200.))*clp(AO(p,n))*clp(colorizer(p));\nif(length(d)>19.) result = skycol;\nreturn result;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\nfloat d;vec2 p;vec2 n;vec3 color;\n\nvec2 dir;vec2 pos;\nvec2 lightpos;vec2 lightdir;\n\nvec3 indirect;\nvec3 direct;\nvec3 col ;\n\nvec2 k,k2;\n\n    fragColor = vec4(0);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5*iResolution.xy)/zoom;\n    vec2 mo = (iMouse.xy - .5*iResolution.xy)/zoom;\n    for(int J=0;J<noisestep;J++){\n    k = (hash(vec3(uv,iTime/30000.+float(J)))-0.5);\n    k2 = (hash(vec3(uv,iTime/30000.-float(J)))-0.5);\n   \n   pos = uv;\n    dir =k2;\n\n     float solid = clp(GetSceneDistance(pos));\n     d = RayMarch(pos, dir);\n     p = pos + d * dir; \n     n = normalize(GetNormal(p)+k);\n     color =clp(colorizer(pos)); \n dir=k2+n;\n\n\n\n   lightpos = p;\n   lightdir =normalize(vec2(sin(iTime/4.)/2.+(k.x/8.),1.));\n   \n   indirect = diffusion(pos,dir,d,n,p,lightpos,lightdir,color,true);\n   direct = diffusion(pos,dir,d,n,p,uv,lightdir,color,false);\n    \n\ncol =\n//indirect;\ndirect;\n//(((indirect/2.)+direct)/2.);\n\n\n    // Output to screen\n    fragColor += vec4(col+((color)*step(solid,0.)),1.0)/float(noisestep);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 hash(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1689031));\n    p3 += dot(p3, p3.yzx+168.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat box( vec2 p, vec2 b ){\n  vec2 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\nfloat sphere(vec2 p, float r) {\n\n    //a sphere of radius 1.\n    return length(p) - r;\n}\nfloat clp(float a){\nreturn clamp(0.,1.,a);\n}\nvec3 clp(vec3 a){\nreturn clamp(a,0.01,1.);\n}\nvec3 skycol = vec3(.53,.81,.92);","name":"Common","description":"","type":"common"}]}