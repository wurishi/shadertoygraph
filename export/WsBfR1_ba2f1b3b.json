{"ver":"0.1","info":{"id":"WsBfR1","date":"1589622306","viewed":165,"name":"the golden temple","username":"mdb","description":"first ray march algorithm","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FOV=65.;\nconst vec3 camPos = vec3(0.,2.,1.01);\nconst vec3 target = vec3(0.,5.,0.);\nconst vec3 lightPos = vec3(-100,-100,-100);\n\nconst float PI=3.14159263;\n\nstruct Ray {vec3 origine; vec3 direction;bool touche;float dist;float steps;vec3 contact;};\n\nconst float minDistance = 0.02;\nconst float maxDistance = 100.;\nconst float maxStep = 500.;\nconst bool reflection = true;\nconst float coefReflection = 0.5;\nconst int maxReflection = 3;\nconst float shinesse = 100.;\nconst float coefShadow = 0.8;\nconst float shadowDiffustion = 32.;\nconst vec3 objectColor = vec3(0.984,0.753,0.255);//1.0,0.77647,0.21568\n\n//function\nfloat maxcomp(vec3 p){return max(p.x,max(p.y,p.z));}\nvec3 translate(vec3 z, vec3 v){return v+z;}\n    \n//function for distances to choose\n//https://iquilezles.org/articles/distfunctions\nfloat plan(vec3 z){\n    float hight = -0.5;\n    return abs(z.y-hight)-0.2;\n}\nfloat sphereField(vec3 z){\n    z.xz = mod(z.xz,1.)-0.5;\n    return length(z) - 0.3;\n}\nfloat sphere(vec3 z,float r){\n    return length(z) - r;\n}\nfloat torus( vec3 z, vec2 dim ) {\n        vec2 q = vec2(length(z.xy) - dim.x, z.z);\n        return length(q) - dim.y;\n}\nfloat box(vec3 z, vec3 dim) {//Width, Height, Depth\n        vec3 d = abs(z) - dim;\n        return min(maxcomp(d),0.0) + length(max(d,0.0));\n}\nfloat cylinder( vec3 p, float h, float r ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n} \nfloat colum(vec3 z,vec3 dim ){\n    const float k = 0.5; // or some other amount\n    float c = cos(k*z.y);\n    float s = sin(k*z.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*z.xz,z.y);\n    return box(q,dim);\n}\nfloat sculpture(vec3 z){\n{\n    float k = 0.2*sin(iTime/3.);\n    float c = cos(k*z.y);\n    float s = sin(k*z.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*z.xz,z.y);\n    return torus(q.xzy,vec2(2.5,1.));\n}\n}\n\n\n//smouth min to blend material\nfloat smin( float a, float b, float k )\n{\n    if (k <=0.)return min(a,b);\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n////////////////////////////////////////////////////////////////////\n\n\n//test distance estimator\nfloat DE(vec3 z){\n    \n    float smouth = clamp(5.-iTime*0.3,-0.1,20.);\n    float res;\n    float base = box( z, vec3(26.,2.,26.)) ;\n    z=translate(z,vec3(0.,clamp(24.-iTime*2.,0.,24.),0.));\n    z=translate(z,vec3(0.,-2.,0.));\n    res = cylinder( z, 9.,0.3);\n    res = smin(res,cylinder( z, 8.5,0.6),smouth);\n    res = smin(res,cylinder( z, 8.,0.9),smouth);\n    z=translate(z,vec3(0.,-5.9,0.));\n    for(float i =1.;i<10.;i++){\n        vec3 p=translate(z,vec3(cos(2.*PI*i/9.)*7.,0.,sin(2.*PI*i/9.)*7.));\n    \tres = smin(res,colum(p,vec3(0.5,0.5,5.)),smouth);\n    }\n    z=translate(z,vec3(0.,-3,0.));\n    float dome = max(abs(sphere(z,8.))-0.1,-box(z-vec3(0.,-2.5,0.),vec3(9.,4.,9.)));\n    res = min(res,torus( z.xzy, vec2(7.,0.3)));\n    z=translate(z,vec3(0.,-1.6,0.));\n    res = min(res,max(cylinder( z, 8.2,0.2),-cylinder( z, 7.8,0.22)));\n    z=translate(z,vec3(0.,-6.,0.));\n    res= min(res,torus( z.xzy, vec2(2.5,0.2)));\n    dome = max(dome,-cylinder( z, 2.5,0.6));\n    res=smin(dome,res,smouth);\n    res=smin(res,base,smouth);\n    z+=vec3(0.,12.,0.);\n    res=smin(res,sculpture(z),smouth);\n    return res;\n    }\n\n\n\n\n\n//////////////////////////////////////////////////////////////////\n//do the ray marching prosses\nRay shootRay(Ray ray)\n{\t\n    ray.touche=false;\n    ray.steps=0.;\n    float dist = 0.;\n    vec3 p;\n    for( float ste=0.; ste<maxStep; ste++){\n        p = ray.origine+ray.direction*dist;\n        float delta=DE(p);\n        dist += delta;\n        \n        if(abs(delta)<minDistance) {\n        \tray.touche = true;\n            break;\n        }\n        if(dist>maxDistance) break; \n        ray.steps+=1.;\n    }\n    ray.dist=dist;\n    ray.contact=p;\n    return ray;\n}\n//comput normal with gradiant\nvec3 normal(vec3 pos){\n    float off=0.001;\n    return normalize(vec3(DE(pos+vec3(off,0,0))-DE(pos-vec3(off,0,0)),\n                     \t  DE(pos+vec3(0,off,0))-DE(pos-vec3(0,off,0)),\n                          DE(pos+vec3(0,0,off))-DE(pos-vec3(0,0,off))));            \n}\n//get the differents light information\nvec2 light(Ray ray){\n    vec3 n = normal(ray.contact);\n    vec3 dirLight=normalize(ray.contact-lightPos);\n    float diffuseLight = max(0.2, dot(n,dirLight));\n        \n    float spectacular = pow(max(0.,dot(n,-normalize(ray.origine+lightPos))),shinesse);\n    \n    return vec2(diffuseLight,spectacular);   \n} \n\nfloat getShadow( Ray ray ) {\n    ray.direction = normalize(ray.contact-lightPos);\n    ray.origine = ray.contact+minDistance*2.*ray.direction;\n    float res = 1.0;\n    float dist=minDistance*2.;\n    float maxd = length(ray.contact-lightPos);\n    for( float t=minDistance*2.; t<maxStep; t++)\n    {\n        float h = DE(ray.origine + ray.direction*dist);\n        if( h<minDistance )\n            return 1.0;\n        res = min( res, shadowDiffustion*h/dist );\n        dist += h;\n        if (dist>maxd)break;\n    }\n    return 1.-res;\n}\n\n\n//return the color of the pixel\nvec4 getColor(Ray ray){\n    vec3 col= vec3(0.);\n    vec3 mask = vec3(1.);\n    for(int i=1; i <= maxReflection; i++){\n        ray = shootRay(ray);\n        if (!ray.touche){\n            col += 2.*mask*texture(iChannel0,ray.direction).xyz;\n            return vec4(col, 1.);\n        }\n        vec3 n = normal(ray.contact);\n        \n        float ao = 0.2*DE(ray.contact + n*0.4)/0.4;\n        vec3 ambiant = objectColor * ao;\n        \n        vec3 diffuse = objectColor*max(0., -dot(normalize(lightPos - ray.origine), n));\n        float shadow = 1.-coefShadow*getShadow(ray);\n        \n        float costheta = -dot(n, ray.direction);\n        float f = min(1., 0.1 + 2.*pow(1.0 - clamp(costheta, 0.0, 1.0), 3.0));\n        \n        col += mask * (diffuse * shadow * (1. - f) + ambiant);\n        mask *= f;\n        ray.direction = reflect(ray.direction, n);\n        ray.origine = ray.contact+n*minDistance*2.;\n    }\n\n\treturn vec4(col,1.);\n}\n   \n//create the new ray    \nRay rayFromCam(vec3 pos, vec3 ta, vec2 fragcoord)\n{\n    vec3 dir0 = normalize(ta - pos);\n    vec3 vUp = vec3(0.0, 1.0, 0.0);\n    fragcoord*=FOV/90.;\n\n    vec3 vRight = normalize(cross(dir0, vUp));\n    vUp = cross(vRight, dir0);\n    vec3 dir = normalize( vRight * fragcoord.x + vUp * fragcoord.y + dir0);\n    Ray ray;\n    ray.origine=pos;\n    ray.direction=dir;\n    return ray;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    float angle = iTime/5.;\n    float dis = 30.*pow((cos(angle/2.)+1.)/2.,4.)+6.;\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    float ratio = iResolution.x/iResolution.y;\n\tuv.x*=ratio;\n    \n    vec3 p = vec3(cos(angle),0.5,sin(angle))*dis+target;\n    Ray ray = rayFromCam(p, target, uv);\n    vec3 dir = ray.direction;\n    ray = shootRay(ray);\n    \n    vec4 col = getColor(ray);\n    col = 1. - exp(-col);\n    col = col*col*(3. - 2.*col);\n    // Output to screen\n    fragColor = vec4(col);\n}","name":"Image","description":"","type":"image"}]}