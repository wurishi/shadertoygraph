{"ver":"0.1","info":{"id":"4tKGzy","date":"1475246893","viewed":155,"name":"Ray Tracying Basic Shapes","username":"kala7a","description":"Raytracying of basic shapes\n\nStill to be done:\n- Add more types of light\n- Add better reflections\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","triangle","shadow","sphere","plane"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision mediump float;\nprecision mediump int;\n\n#define ASPECT_RATIO (iResolution.x / iResolution.y)\n\n// Transform UVs from [0..1] to [-1..1] space\nvec2 normalizeUVs(vec2 uvs)\n{\n\treturn uvs * 2.0 - 1.0;\n}\n\nstruct Triangle\n{\n    vec3 v0;\n    vec3 v1;\n    vec3 v2;\n};\n\nstruct Sphere\n{\n\tvec3 pos;\n\tfloat r;\n    float ior;\n};\n    \nstruct Plane\n{\n    vec3 point;\n    vec3 n;\n};\n    \nstruct Light\n{\n    vec3 dir;\n};\n\n#define SPHERES_COUNT 2\nSphere spheres[2];\n\n#define PLANES_COUNT 1\nPlane planes[1];\n\n#define LIGHTS_COUNT 3\nLight lights[3];\n\n#define TRIANGLES_COUNT 2\nTriangle triangles[2];\n\nvoid initializePlanes()\n{\n    planes[0].point = vec3(0.05, -0.17, 0.0) * 400.0;\n    planes[0].n = normalize(vec3(0.00, 1.00, 0.0));\n}\n\nvoid initializeSpheres()\n{\n    spheres[0].pos = vec3(0.0, 0.0, 0.0) * 400.0;\n    spheres[0].r   = 64.0;\n\n    spheres[1].pos = vec3(0.1, 0.3, 0.0) * 400.0;\n    spheres[1].r   = 32.0;\n}\n\nvoid initializeLights()\n{\n    lights[0].dir = normalize(vec3(-0.7, -0.4, 1.0));\n    lights[1].dir = normalize(vec3(0.5, -0.5, 0.0));\n    lights[2].dir = normalize(vec3(-0.5, -0.4, -1.0));\n}\n\nvoid initializeTriangles()\n{\n    triangles[0].v0 = vec3(1.0, sin(iTime), -1.0) * 400.0;\n    triangles[0].v1 = vec3(-1.0, sin(iTime), -1.0) * 400.0;\n    triangles[0].v2 = vec3(0.0, sin(iTime), 1.0) * 400.0;\n    \n    triangles[1].v0 = vec3(0.1, 0.3, 0.0) * 400.0;\n    triangles[1].v1 = vec3(0.0, 0.0, 0.0) * 400.0;\n    triangles[1].v2 = vec3(-0.1, 0.3, 0.0) * 400.0;\n}\n\n// Formula:\n// http://www.cs.virginia.edu/~gfx/Courses/2003/ImageSynthesis/papers/Acceleration/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf\nbool getTriangleIntersection(vec3 ray, vec3 origin, Triangle t, out vec3 intersection, out vec3 n)\n{\n    vec3 edge1, edge2, tvec, pvec, qvec;\n    float det, inv_det;\n    float u, v;\n    \n    edge1 = t.v1 - t.v0;\n    edge2 = t.v2 - t.v0;\n    tvec = origin - t.v0;\n    pvec = cross(ray, edge2);\n    qvec = cross(tvec, edge1);\n    \n    det = dot(pvec, edge1);\n    \n    if (det > -0.00001 && det < 0.00001)\n        return false;\n\n    inv_det = 1.0 /det;\n    \n    u = dot(pvec, tvec) * inv_det;\n    \n    if (u < 0.0 || u > 1.0)\n        return false;\n\n    v = dot(qvec, ray) * inv_det;\n    \n    if (v < 0.0 || u + v > 1.0)\n        return false;\n        \n    float distToIntersection = dot(qvec, edge2) * inv_det;\n    \n    if (distToIntersection < 0.0)\n        return false;\n    \n    intersection = origin - distToIntersection * ray;\n    n = normalize(cross(edge1, edge2) * normalize(det));\n    \n    return true;\n    \n}\n\nbool getSphereIntersection(vec3 ray, vec3 origin, Sphere s, out vec3 intersection, out vec3 n)\n{\n    bool res = false;\n    vec3 originToCenter = s.pos - origin;\n    float projLength = dot(originToCenter, ray);\n    if (projLength > 0.0)\n    {\n        vec3 rayProj = ray * projLength;\n        float distanceToRay = length(rayProj - originToCenter);\n\n        float r = s.r;\n        if (distanceToRay < r)\n        {\n            float distToIntersection = projLength - sqrt(r * r - distanceToRay * distanceToRay);\n            intersection = origin + distToIntersection * ray;\n            n = normalize(intersection - s.pos);\n            res = true;\n        }\n    }\n    return res;\n}\n                        \nbool getPlaneIntersection(vec3 ray, vec3 origin, Plane p, out vec3 intersection, out vec3 n)\n{\n    float angleRayToPlane = dot(ray, p.n);\n    if (angleRayToPlane != 0.0)\n    {\n        float distToIntersection = dot((origin - p.point), p.n) / angleRayToPlane;\n        if (distToIntersection < -0.1)\n        {\n            intersection = origin - distToIntersection * ray;\n            n = p.n;\n            \n            return true;\n        }\n    }\n    \n    return false;\n}\n\nbool getNearestIntersection(vec3 ray, vec3 origin, out vec3 intersection, out vec3 n)\n{\n    vec3 shapeIntersection;\n    vec3 shapeN;\n    float nearestIntersection = 1000000000.0;\n    bool res = false;\n\n    for (int i = 0; i < PLANES_COUNT; i++)\n    {\n        bool hasIntersection = getPlaneIntersection(ray, origin, planes[i], shapeIntersection, shapeN);\n        if (hasIntersection)\n        {\n            float distanceToIntersection = length(shapeIntersection - origin);\n            if (distanceToIntersection < nearestIntersection)\n            {\n                nearestIntersection = distanceToIntersection;\n                intersection = shapeIntersection;\n                n = shapeN;\n                res = true;\n            } \n        }\n    }\n    for (int i = 0; i < SPHERES_COUNT; i++)\n    {\n        bool hasIntersection = getSphereIntersection(ray, origin, spheres[i], shapeIntersection, shapeN);\n        if (hasIntersection)\n        {\n            float distanceToIntersection = length(shapeIntersection - origin);\n            if (distanceToIntersection < nearestIntersection)\n            {\n                nearestIntersection = distanceToIntersection;\n                intersection = shapeIntersection;\n                n = shapeN;\n                res = true;\n            } \n        }\n    }\n    for (int i = 0; i < TRIANGLES_COUNT; i++)\n    {\n        bool hasIntersection = getTriangleIntersection(ray, origin, triangles[i], shapeIntersection, shapeN);\n        if (hasIntersection)\n        {\n            float distanceToIntersection = length(shapeIntersection - origin);\n            if (distanceToIntersection < nearestIntersection)\n            {\n                nearestIntersection = distanceToIntersection;\n                intersection = shapeIntersection;\n                n = shapeN;\n                res = true;\n            } \n        }\n    }\n    \n    return res;\n}\n\nvec3 getCameraPos(float time)\n{\n    mat3 rot = mat3(\n        vec3(cos(time), 0.0, -sin(time)),\n        vec3(0.0,       1.0,  0.0),\n        vec3(sin(time), 0.0,  cos(time)));\n    return rot * vec3(800.0, 100.0, 1000.0);\n}\n\nvec3 getViewDirection(vec3 cameraPos)\n{\n    return normalize(vec3(0.0) - cameraPos);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2  offset      = normalizeUVs(fragCoord.xy / iResolution.xy);\n\tvec3  cameraPos   = getCameraPos(iTime);\n\tvec3  cameraView  = getViewDirection(cameraPos);\n\tvec3  cameraUp    = vec3(0.0, 1.0,  0.0);\n\tvec3  cameraRight = cross(cameraView, cameraUp);\n\tfloat cameraNear  = 3.0;\n    \n    initializeSpheres();\n    initializePlanes();\n    initializeLights();\n    initializeTriangles();\n\t\n\tvec3 ray = normalize(cameraRight * offset.x * ASPECT_RATIO + cameraUp * offset.y + cameraView * cameraNear);\n\n    vec3 intersection = vec3(0.0);\n    vec3 n = vec3(0.0);\n    float shadow = 1.0;\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    for (int k = 0; k < 6; k++)\n    {\n        if (getNearestIntersection(ray, cameraPos, intersection, n))\n        {\n            for (int i = 0; i < LIGHTS_COUNT; i++)\n            {\n                vec3 newIntersection = vec3(0.0);\n                vec3 newN = vec3(0.0);\n                if (getNearestIntersection(-lights[i].dir, intersection, newIntersection, newN))\n                {\n                    shadow *= 0.3;\n                }    \n          }\n            cameraPos = intersection;\n            ray = reflect(ray, n);\n        }\n        else\n        {\n            fragColor = texture(iChannel0, normalize(ray+intersection*0.0001)) * shadow;\n            break;\n        }\n    }\n}","name":"Image","description":"","type":"image"}]}