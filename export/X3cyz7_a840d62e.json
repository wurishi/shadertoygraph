{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define PI 3.14159265358979\n#define TWO_PI 6.28318530718\n\n\n// Simple 2D hash function\nfloat hash2D(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Smoothstep/fade\nfloat fade(float t) {\n    return t * t * (3.0 - 2.0 * t);\n}\n\n// 1D periodic noise with adjustable amplitude\nfloat periodicNoise(float x, float period, float amplitude) {\n    float angle = TWO_PI * (x / period);\n\n    // Map onto unit circle\n    float cx = cos(angle);\n    float sy = sin(angle);\n\n    // Integer lattice in 2D\n    float ix = floor(cx);\n    float iy = floor(sy);\n\n    // Fractional part within the cell\n    float fx = fract(cx);\n    float fy = fract(sy);\n\n    // Fade curves\n    float u = fade(fx);\n    float v = fade(fy);\n\n    // Four corners\n    float v00 = hash2D(vec2(ix,     iy    ));\n    float v10 = hash2D(vec2(ix+1.0, iy    ));\n    float v01 = hash2D(vec2(ix,     iy+1.0));\n    float v11 = hash2D(vec2(ix+1.0, iy+1.0));\n\n    // Bilerp in [0,1]\n    float valX0 = mix(v00, v10, u);\n    float valX1 = mix(v01, v11, u);\n    float val   = mix(valX0, valX1, v);\n\n    // Remap [0,1] -> [-1,1], then scale by amplitude\n    val = 2.0 * val - 1.0;\n    return val * amplitude;\n}\n\nfloat fBm(float x, float period) {\n    float total = 0.0;\n    float amp   = .4;\n    float freq  = 1.0;\n\n    for (int i = 0; i < 15; i++) {\n        total += periodicNoise(x * freq, period * freq, amp);\n        freq  *= 2.0;\n        amp   *= 0.5;\n    }\n    return total; // Might be in [-2,2] for 4 octaves\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float speed= 1.;\n    \n    // Center the coordinates around (0, 0)\n    uv -= 0.5;\n    \n    // Adjust aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float angle = atan(uv.y,uv.x);\n    float f=1.;\n\n\n    // Circle radius\n    float r = .2+\n            .1*fBm(1.*angle+ 0.*iTime,2.*PI)*sin(4.*iTime + 3.*fBm(1.*angle+ 0.*iTime,2.*PI));\n\n    // Compute length from the center\n    float l = length(uv);\n\n    // Create a threshold for the circle\n    float col = 1.-step(r, l);\n\n    // Output to screen\n    fragColor = vec4(0., col, 0.0, 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"X3cyz7","date":"1734853534","viewed":21,"name":"hello shadertoy!","username":"mrjonjonjon","description":"my first shader :3","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["blob"],"hasliked":0,"parentid":"","parentname":""}}