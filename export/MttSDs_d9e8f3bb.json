{"ver":"0.1","info":{"id":"MttSDs","date":"1482286599","viewed":537,"name":"Simplex Grid","username":"ptrgags","description":"Learned how to skew space from squares into sets of two equilateral triangles.\n\nClick and drag to pan around.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["2d","rhombus","skew","transformations","rhombi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415\n\n/* \n * skew spacee from squares into rhombi.\n * Essentially we are rotating the y-axis\n * 60 degrees counterclockwise while keeping\n * the x-axis still. \n * \n * Transform derivation: screen(x, y) -> skewed(x', y')\n * x' = x - ycos(60°)\n * y' =     ysin(60°)\n * \n * Inverse (the transform we want): skewed(x', y')\n * y = y'csc(60°)\n * x = x' + ycos(60°)\n *   = x' + y'cos(60°)csc(60°)\n *   = x' + y'cot(60°)\n */\n\nvec2 rhombi(vec2 point) {\n    mat2 transform = mat2(\n        1.0, 0.0,\n        //cot(60°), csc(60°)\n        1.0 / tan(PI / 3.0), 1.0 / sin(PI / 3.0)\n    );\n    return transform * point;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse_uv = iMouse.xy / iResolution.xy;\n    \n    //screen space -> uv space\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //Fix aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //Pan around with the mouse\n    uv += mouse_uv;\n    \n    //How many rhombus-shaped cells to make\n    float num_boxes = 10.0;\n    \n    //skew space\n    uv = rhombi(uv);\n    \n    //Scale up space from [0.0, 1.0] -> [0.0, num_boxes]\n    uv *= num_boxes;\n    \n    //Get the (x, y) indices of the box.\n    //box as in container. these 'boxes' are rhombi!\n    vec2 box = floor(uv);\n    \n    //Get the UV coordinates within the current rhombus\n    vec2 box_uv = fract(uv);\n    //One triangle in the rhombus is full color, the other\n    //is dark.\n    float brightness = step(box_uv.x, box_uv.y);\n    \n    //Color each box a different color\n\tfragColor = brightness * vec4(box / num_boxes, 0.0, 1.0);\n}","name":"Image","description":"","type":"image"}]}