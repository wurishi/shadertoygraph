{"ver":"0.1","info":{"id":"Nl2Xz1","date":"1627104404","viewed":215,"name":"BZ with Hex Tiling 2d","username":"Yusef28","description":"You can reset with spacebar after going full screen\nResources\n[url]https://discovery.ucl.ac.uk/id/eprint/17241/1/17241.pdf[/url]\n[url]https://scipython.com/blog/simulating-the-belousov-z[/url]\n","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["tiling","hex","coloring","belousovzhabotinsky","hexagonal","belousov","zhabotinsky","bz"],"hasliked":0,"parentid":"NtsXDs","parentname":"Quick Belousov-Zhabotinsky"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n//The most important tweaks I had to make after adding hex were\n//1.I had to add a skaling factor and really play around with it\n//2.In the end I needed the skale to be based on resolution for \n//changing to full screen etc\n//3.I needed to use idB-0.5 so that I didn't have two sets\n//of coordinates with the same values\n//4. in buffer A near the end I do this: abcT = abcAlt*0.5 + abcT*0.5;\n//which I saw somewhere else. That means I take half of the new\n//value and half of the old which basically slows down the movement.\n//You can go higher like abcT = abcAlt*0.9 + abcT*0.1;\n//but things look less like a BZ as you do that.\n//5. Had to increase rnd(uv + vec2(3904.3,254.)),\n//since it was below the full screen resolution for \n//all three rnd functions meaning we get repetion\n//6. an I played with the gamma/beta/alpha to make things a bit\n//more interesting\n//7.and color to try and keep things fresh.\n\n\n//Press spacebar to reset if you go fullscreen\n\nvec3 hexTexture(vec2 uv)\n{\n    float skale = iResolution.x/10.;\n\tvec2 u = uv*skale/3.;\n    vec2 s = vec2(1.,1.732);\n    \n    vec2 a = mod(u,s)*2.-s;\n    vec2 idA = floor(u/s);\n    vec2 b = mod(u+s*.5,s)*2.-s;\n    vec2 idB = floor((u+s*.5)/s);\n    \n    float la = length(a);\n    float lb = length(b);\n    \n    u = la < lb ? a : b;\n    vec2 idSeed = la < lb ? idA : idB-0.5;\n   \n       \n    vec3 col = texture(iChannel0, idSeed/skale/2.).gba;\n   // col = mix(vec3(0.), 0.5+0.5*cos(vec3(1.,2.,4.)/2. + col.rrr*2.), abs(col.rrr*2.-1.));\n    float id = rnd(idSeed);\n    \n    vec2 st = abs(u);\n    float q = max(st.x, dot(st,normalize(s)));\n    float f = smoothstep(0.1,0.2,1.0-q);\n    return col*f;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates 0 (from to 1)\n    vec2 uv = (fragCoord.xy)/iResolution.y;\n    \n    vec3 col = hexTexture(uv);\n   // col = mix(col, 0.5+0.5*cos(vec3(4.,2.,1.) - 10000.), col.r);\n    //texture(iChannel0, uv/2.).rgb;\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n//nice keyboard reset fuction from:https://www.shadertoy.com/view/XtcGD2\nbool reset() {\n    return texture(iChannel2, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n \n//Mooors Nachbarschaft\nvec3 count(vec2 p, vec2 off){ \n\n    vec3 cnt = vec3(0.);\n    vec2 m = iResolution.xy;\n   \n    for(float i = -1.; i <= 1.; i+=1.){\n        for(float j = -1.; j <= 1.; j+=1.){\n        \n            off = vec2(i,j)/iResolution.xy;\n            \n            vec2 st = p + off;\n            \n            //not this lol\n           //st.x = mod(st.x, iResolution.x);\n            //st.y = mod(st.y, iResolution.y);\n            \n            cnt += texture( iChannel0, fract(st) ).rgb;\n            }\n        }\n   \n   \n    return cnt;\n    \n}\n\nvoid mainImage( out vec4 data, in vec2 fragCoord )\n{\n    vec2 off = 1./iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    if(iFrame == 0 || reset()){\n    \n       vec3 abc = \n       \n      vec3( \n       rnd(uv + vec2(39040.3,25000.)),\n       rnd(uv),\n       rnd(uv + vec2(-10340.3,-10004.))\n       \n       );\n     \n       data = vec4(abc,1.);\n             \n    }\n    \n    else{\n        vec3 abcAlt = texture( iChannel0, uv).rgb;\n        vec3 abc = count(uv,off)/9.;\n        vec3 abcT;\n        \n        //you can turn one or two of these up to 1.2, 1.5 etc\n        //check full screen (reset with spacebar in fullscreen)\n        //to see if anything happens on the larger scale\n        \n        float alpha = 1.2;\n        float beta = 1.;\n        float gamma = 1.;\n        \n        abcT.x = abc.x + abc.x*(abc.y*alpha - abc.z*gamma);\n        abcT.y = abc.y + abc.y*(abc.z*beta - abc.x*alpha);\n        abcT.z = abc.z + abc.z*(abc.x*gamma - abc.y*beta);\n        \n        abcT = abcAlt*0.7 + abcT*0.3;\n        data = vec4(clamp(abcT,0.,1.),1.);\n\n    }\n\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float rnd(vec2 id){\n    return fract(sin(id.x*12.99+id.y*800.+40.)*51343.);\n}\n","name":"Common","description":"","type":"common"}]}