{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// An attempt at learning the basics... Raymarching, terrain intersection, \n// generating normals, creating lights. All of this is super rough, as I just \n// trying to get the basic concepts. It actally looks really cool if you \n// turn the ray steps down to 10 or 15\n\n\nconst int RAY_STEPS = 400;\nconst float MIN_DIST = 0.5;\nconst float NORM_SEARCH_DIST = 0.5;\nconst float SPEED = 0.55;\nconst vec3 LIGHT = vec3(0.15, .22, 0.3);\n\n\n// using animated sin and cos to make a floor terrain\nvec3 intersectFloor(const vec3 test){ \n\tfloat sinHeight = sin((test.z + iTime * -SPEED * 2.0) * 0.5);\n\tfloat cosHeight = cos(test.x + iTime * -SPEED);\n\tfloat bigWave = sin((test.z + iTime * -SPEED * 6.0) * 0.15) * 2.8;\n\treturn vec3(test.x, max(sinHeight, cosHeight) + bigWave, test.z);\n}\n\n// make a triangle by sampling the depth at 3 points, \n// then get the cross product;\nvec3 calculateFloorNormal(const vec3 base ) {\n\tvec3 A = intersectFloor(base);\n\tvec3 B = intersectFloor(vec3(base.x + NORM_SEARCH_DIST, base.yz));\n\tvec3 C = intersectFloor(vec3(base.xy, base.z + NORM_SEARCH_DIST));\n\treturn normalize(cross(C - A, B - A));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t// uv coord\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\t// camera stuff\n\tvec3 camPos = vec3(15.0, 8.0,15.0);\n\tvec3 camNorm = vec3(0.653, 0.383, 0.653);\n\t// camera attributes\n\tfloat camNear = 10.0;\n\tfloat camFar = 45.0;\n\tfloat camHFOV = 65.0;\n\tfloat camVFOV = 35.0;\n\t// camera matrix\n\tvec3 camXAxis = cross(vec3(0.0, 1.0, 0.0), camNorm);\n\tcamXAxis =  normalize(camXAxis);\n\tvec3 camYAxis = cross(camNorm, camXAxis);\n\tmat3 camRotMat = mat3(camXAxis, camYAxis, camNorm);\n\t\n\t//ray vector\n\tvec3 raySt = vec3(0.0, 0.0, -camNear);\n\tfloat nearW = tan(camHFOV * .5 * .01745) * abs(camNear);\n\traySt.x = (nearW * uv.s * 2.0) - nearW;\n\tfloat nearH = tan(camVFOV * .5 * .01745) * abs(camNear);\n\traySt.y = (nearH * uv.t * 2.0) - nearH;\n\t// run the ray through the cameras rotation matrix, and add it's position\n\traySt = (camRotMat * raySt) + camPos;\n\tvec3 rayDir = normalize(raySt - camPos);\n\tvec3 rayInc = rayDir * ((abs(camFar) - abs(camNear)) / float(RAY_STEPS));\n\t\n\t// march\n\tvec3 result = vec3(1.0, 0.0, 1.0);\n\tvec3 curPos = raySt;\n\tfor (int i = 0; i < RAY_STEPS; ++i) {\n\t\tif (i == RAY_STEPS - 1) {\n\t\t\tresult = mix(vec3(0.15, 0.15, 0.15), vec3(0.6, 0.05, 0.8), uv.t);\t\t\t\n\t\t}\n\t\tif (distance(curPos, intersectFloor(curPos)) < MIN_DIST) {\n\t\t\t// getting a depth map of sorts?\n\t\t\tfloat dist = float(i) / float(RAY_STEPS) * .75;\n\t\t    vec3 depth = vec3(1.0 - dist);\n\t\t\t// find surface normal\n\t\t\tvec3 norm = calculateFloorNormal(curPos);\n\t\t\t// use dot product to find angle between light and floor..\n\t\t\t// The light seems upside down for some reason?\n\t\t\tfloat lightAngle =  dot(norm, LIGHT) * 2.0;\n\t\t\tresult = vec3(0.15, 0.85, 0.2) * lightAngle;\n\t\t\t// trying to do specularity, but this doesnt work very well\n\t\t\tresult += pow(lightAngle, 35.25) * 60000.0;\n\t\t\t// mixing depth against background color to make a fog effect\n\t\t\tresult =   mix(result, vec3(0.6, 0.05, 0.8), clamp(1.0 - depth * 1.5, 0.0, 1.0));\n\t\t\tbreak;\n\t\t}\n\t\tcurPos += rayInc;\n\t}\n\t\n\n\tfragColor = vec4(result, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sXXD7","date":"1401951749","viewed":256,"name":"Terrain, Light, Fog, Hello World","username":"villain749","description":"Another super basic attempt at learning the basics... Raymarching, terrain intersection, generating normals, creating lights. All of this is super rough, as I just trying to get the basic concepts.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["terrain","raymarch","helloworld","light","fog"],"hasliked":0,"parentid":"","parentname":""}}