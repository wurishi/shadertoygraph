{"ver":"0.1","info":{"id":"DllBz8","date":"1693498557","viewed":43,"name":"FXAA-LCD","username":"LCDShader","description":"fxaa抗锯齿","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["fxaa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define EDGE_STEP_COUNT 10\n#define EDGE_GUESS 8.0f\n#define EDGE_STEPS 1.0f, 1.5f, 2.0f, 2.0f, 2.0f, 2.0f, 2.0f, 2.0f, 2.0f, 4.0f\nconst float edgeSteps[EDGE_STEP_COUNT] = float[EDGE_STEP_COUNT]( EDGE_STEPS );\n\nfloat _ContrastThreshold = 0.0312f;\nfloat _RelativeThreshold = 0.063f;\nfloat _SubpixelBlending = 1.0f;\n\n// 0 1 2\n// 3 4 5\n// 6 7 8\nconst vec3 grayNol=vec3(0.213,0.715,0.072);\n\nfloat GetValue(vec3 color)\n{\n    return dot(color,grayNol);\n\n}\n\n\nvec3 IsSawtTest(sampler2D tex, vec2 pos,float step_x,float step_y)\n{\n      float value_up= GetValue(texture(tex,vec2(pos.x,pos.y+step_y)).rgb);\n   float value_left= GetValue(texture(tex,vec2(pos.x-step_x,pos.y)).rgb);\n   float value_right= GetValue(texture(tex,vec2(pos.x+step_x,pos.y)).rgb);\n   float value_down= GetValue(texture(tex,vec2(pos.x,pos.y-step_y)).rgb);\n   float value_center= GetValue(texture(tex,pos).rgb);\n\n   float value_min = min(value_center, min(min(value_left, value_right), min(value_up, value_down)));\n   float value_max = max(value_center, max(max(value_left, value_right), max(value_up, value_down)));\n\n   float value_range=value_max-value_min;\n   float threshold=max(_ContrastThreshold, _RelativeThreshold * value_max);\n\n   if(value_range<threshold)\n   return texture(tex,pos).rgb;\n\n   \n   float value_up_left= GetValue(texture(tex,vec2(pos.x-step_x,pos.y+step_y)).rgb);\n   float value_up_right= GetValue(texture(tex,vec2(pos.x+step_x,pos.y+step_y)).rgb);\n   float value_down_left= GetValue(texture(tex,vec2(pos.x-step_x,pos.y-step_y)).rgb);\n   float value_down_right= GetValue(texture(tex,vec2(pos.x+step_x,pos.y-step_y)).rgb);\n\n   //计算水平和垂直方向的平均梯度变化\n   float edge_horizontal=\n   abs(value_up_left+value_up_right-2.0*value_up)+\n   abs(value_left+value_right-2.0*value_center)*2.0+\n   abs(value_down_left+value_down_right-2.0*value_down);\n   float edge_vertical=\n   abs(value_up_left+value_down_left-2.0*value_left)+\n   abs(value_up+value_down-2.0*value_center)*2.0+\n   abs(value_up_right+value_down_right-2.0*value_right);\n   //变化较小的方向就是锯齿的方向\n   bool is_horizontal=(edge_horizontal<=edge_vertical);\n   \n    //判断点在锯齿在点的那一边\n   float value_1=is_horizontal?value_down:value_down_left;\n   float value_2=is_horizontal?value_up:value_down_right;\n   float gradient_1=value_1-value_center;\n   float gradient_2=value_2-value_center;\n\n  float step_length=is_horizontal?step_y:step_x;\n   bool gradient_dir=abs(gradient_1)>=abs(gradient_2);\n\n   float value_local_average=0.0;\n   float gradient_scale=0.0;;\n\n\n    if(gradient_dir)\n    {\n        step_length=-step_length;\n        value_local_average=0.5*(value_1+value_center);\n        gradient_scale=0.25*abs(gradient_1);\n       \n    }\n    else\n    {\n        value_local_average=0.5*(value_2+value_center);\n        gradient_scale=0.25*abs(gradient_2);\n    }\n    //沿着点到锯齿的方向偏移0.5，避免无法找到边界。\n    vec2 uv=pos;\n    vec2 offset=vec2(0.0);\n   if(is_horizontal)\n   {\n    uv.y+=step_length*0.5;\n    offset.x=step_x;\n   }\n   else\n   {\n    uv.x+=step_length*0.5;\n    offset.y=step_y;\n   }\n\n    //沿着锯齿的方向寻找边界点\n    vec2 uv_1=uv-offset*edgeSteps[0];\n    vec2 uv_2=uv+offset*edgeSteps[0];\n\n    float end_1= GetValue(texture(tex,uv_1).rgb)-value_local_average;\n    float end_2= GetValue(texture(tex,uv_2).rgb)-value_local_average;\n\n    bool reach_1=abs(end_1)>=gradient_scale;\n    bool reach_2=abs(end_2)>=gradient_scale;\n     \n     for(int i=1;i<EDGE_STEP_COUNT;i++)\n     {\n        if(!reach_1)\n        {\n            uv_1-=offset*edgeSteps[i];\n            end_1= GetValue(texture(tex,uv_1).rgb)-value_local_average;\n            reach_1=abs(end_1)>=gradient_scale;\n        }\n        if(!reach_2)\n        {\n            uv_2+=offset*edgeSteps[i];\n            end_2= GetValue(texture(tex,uv_2).rgb)-value_local_average;\n            reach_2=abs(end_2)>=gradient_scale;\n        }\n        if(reach_1&&reach_2)\n        {\n            break;\n        }\n\n     }\n\n    if(!reach_1)\n    {\n        uv_1-=offset*EDGE_GUESS;\n    }\n    if(!reach_2)\n    {\n        uv_2+=offset*EDGE_GUESS;\n    }\n    \n    float distance_1=is_horizontal?(pos.x-uv_1.x):(pos.y-uv_1.y);\n    float distance_2=is_horizontal?(uv_2.x-pos.x):(uv_2.y-pos.y);\n    \n    //以查找的边界点来进行偏移\n\tbool select_end=distance_1<distance_2;\n    bool is_gradient_smaller=value_center<=value_local_average;\n    bool is_blend=((select_end?end_1:end_2)<=0.0)!=is_gradient_smaller;\n\n    float final_end_offset=0.0;\n    //若采样点的亮度变化和当前点一致，则无需采样\n    if(is_blend)\n    {\n        float final_distance=min(distance_1,distance_2);\n        float distance_range=distance_1+distance_2;\n        final_end_offset=-final_distance/distance_range+0.5;\n    }\n\n    //以周围亮度值进行偏移\n    float value_average=(value_up_left+value_up_right+value_down_left+value_down_right+\n    2.0*value_left+2.0*value_up+2.0*value_right+2.0*value_down)/12.0;\n    float sub_pixe_offset_1=clamp(abs(value_average-value_center)/value_range,0.0,1.0);\n\n    float sub_pixe_offset_2=smoothstep(0.0,1.0,sub_pixe_offset_1);\n\n    float final_value_offset=sub_pixe_offset_2*sub_pixe_offset_2*_SubpixelBlending;\n\n    //取较大的偏移\n\tfloat final_offset=max(final_end_offset,final_value_offset);\n    \n    vec2 final_uv=pos;\n    if(is_horizontal)\n    {\n        final_uv.y+=final_offset*step_length;\n    }\n    else\n    {\n        final_uv.x+=final_offset*step_length;\n    }\n    \n    return texture(tex,final_uv).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 rcpFrame = 1./iResolution.xy;\n  \tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float splitCoord = iMouse.x;\n    \n    vec3 col=vec3(0.0);\n    \n    if( uv.x < splitCoord/iResolution.x ) {\n\t   \n        if(uv.x<0.5)\n        {\n            col =texture(iChannel0,uv).rgb;\n        }\n        else\n        {\n           col =IsSawtTest(iChannel0, uv,rcpFrame.x ,rcpFrame.y );\n        }\n     \n    } \n    else \n    {\n\t    col = texture( iChannel0, uv ).xyz;\n    }\n     if (abs(fragCoord.x - splitCoord) < 1.0) {\n\t\tcol.x = 1.0;\n\t}\n\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 NormalizeSpace(vec2 uv)\n{\n    return (uv - vec2(0.3*iResolution.x,0.5*iResolution.y)) / iResolution.y;\n}\n\nvec2 NormalizeSpace1(vec2 uv)\n{\n    return (uv - vec2(0.7*iResolution.x,0.5*iResolution.y)) / iResolution.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvTex = fragCoord/iResolution.xy;\n    vec2 uv=vec2(0.0);\n    if(uvTex.x<0.5)\n    {\n        uv = NormalizeSpace(fragCoord);\n    }\n    else\n    {\n       uv = NormalizeSpace1(fragCoord);\n    }\n           \n    float c = step(length(uv), 0.25);   \n    \n    fragColor = vec4(c, c, c, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}