{"ver":"0.1","info":{"id":"mlyyWz","date":"1700463228","viewed":59,"name":"20231116","username":"wwwww","description":"hash and ......","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["hash"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n\nfloat hash(float n) {\n  return fract(sin(n) * 43758.5453123);\n}\n\nfloat hash(vec2 p) {\n  return fract(sin(dot(p, vec2(91.3458, 47.9898))) * 43758.5453123);\n}\n\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6;\n  float a = 10.51;\n  float b = 0.13;\n  float c = 1.93;\n  float d = 0.19;\n  float e = 0.14;\n  return clamp((v * (a * v + b)) / (v * (c * v + d) + e), 0.0, 1.0);\n}\n\nvec3 godray(vec3 bg, vec3 r) {\n  float x = atan(r.x, r.z); \n  float y = acos(r.y) - 3.14159 * 0.5;   \n  \n  x *= 0.5;\n  y *= 0.5;\n    \n  vec3 col = bg * (1.0 + y);\n    \n  float t = iTime + hash(r.xy); // 光線の方向にランダム性を追加\n\n  float a = sin(r.x);\n    \n  float beam = clamp(sin(10.0 * x + a * y * 5.0 + t), 0.0, 1.0);\n  beam *= clamp(sin(7.0 * x + a * y * 3.5 - t), 0.0, 1.0);\n    \n  float beam2 = clamp(sin(42.0 * x + a * y * 21.0 - t), 0.0, 1.0);\n  beam2 *= clamp(sin(34.0 * x + a * y * 17.0 + t), 0.0, 1.0);\n    \n  beam += beam2;\n  \n  col += beam * 0.25 * sqrt(bg);\n  return col;\n}\n\nvoid mainImage(out vec4 O, vec2 C) {\n  O = vec4(0);\n  vec3 p, q, r = iResolution, d = normalize(vec3((C * 2. - r.xy) / r.y, 1.));  \n\n  for (float i = 0., a, s, e, g = 0.; ++i < 110.;) {\n    float randomOffset = hash(vec2(i, iTime));\n    p = g * d + vec3(randomOffset * 0.1);\n    p.z += iTime * 6.5;\n    \n    a = 10. + randomOffset * 2.;\n    p = mod(p - a, a * 2.) - a;\n    s = 6. + randomOffset * 1.2;\n\n    for (int j = 0; j++ < 8;) {\n      p = .3 - abs(p);\n\n      p.x < p.z ? p = p.zyx : p;\n      p.z < p.y ? p = p.xzy : p;\n\n      s *= e = 1.4 + sin(iTime * .234) * .1;\n      p = abs(p) * e - vec3(5. + sin(iTime * .3 + .5 * tan(iTime * .3)) * 3., 120, 8. + cos(iTime * .2) * 5.);\n    }\n    g += e = length(p.yz) / s;\n    g += e = length(p.yx) / s;\n    O.xyz += mix(vec3(1), H(g * .1), sin(.8)) * 1. / e / 8e3;\n  }\n\n  vec3 godrayEffect = godray(O.xyz, normalize(vec3((C * 2.0 - iResolution.xy) / iResolution.y, 1.0)));\n  O.xyz = mix(O.xyz, godrayEffect, 0.5);\n  O.xyz = aces_approx(O.xyz);\n}\n","name":"Image","description":"","type":"image"}]}