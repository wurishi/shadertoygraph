{"ver":"0.1","info":{"id":"cstyR2","date":"1695249515","viewed":73,"name":"AA Pitfall: Blurred Lines","username":"Real_NC","description":"Some discussion of pitfalls of post-processing AA, and explaining why some post-processing AA look so fuzzy.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["lines","antialiasing","aa","srgb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    A common issue with post-processing antialiasing is the tendency for edges to be feathered to 2px wide.\n    The top of the image shows two lines and the bottom of the image shows these lines correctly rendered\n    in 1/16th resolution. This demonstration shows that the 1px gray edge comes from the sharp line, and\n    the 2px gray edge comes from a line which is blurred. This makes many AA algorithms look too fuzzy\n    (or, as Dave Hoskins put it, \"like a dog licked the screen\"). Most post-processing AA methods use a \n    local or global piecewise approximation of edge geometry to attempt to determine what the image should\n    look like. It is often the case that two adjacent pixels will predict that the edge goes through\n    both pixels leading to a 2px edge blur (left). It would be ideal to find a prediction where the edge\n    definition is agreed upon for all adjacent pixels: keeping sharp edges sharp.\n*/\n\n#define S sin(iTime)*.1*u.y\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec2 R = iResolution.xy, // uv, rounding for pixelation on the bottom half\n    u = (\n    ((U.y*2. < R.y) ? round(U*.25)*8. : U * 2.)\n    - R) / R.x;\n    \n    O = R.x*(vec4(abs(u.x + S - step(0., u.x)*.6 + .3)) - 0.05)*.5; // Linear tent line approximation, 1px slope\n    \n    if (min(u.x,u.y) < 0.) O *= .25; // just some approximations of the different methods the lines represent\n    if (max(u.x,u.y) < 0.) O *= .5;\n    \n    O += .5;\n    O = pow(1. - O, vec4(1./2.2)); // gamma correction - important when comparing AA methods\n    if (int(U.y) == int(R.y/2.)) O = vec4(1,0,0,0); // red line\n}","name":"Image","description":"","type":"image"}]}