{"ver":"0.1","info":{"id":"fsVcR3","date":"1655294912","viewed":107,"name":"Moving Stochasitc Voronoi Tiling","username":"LoganOracio","description":"i guess i'm not 100% sure\nIt's probably crap too, it does something weird when I set my \"stochastic_factor\" to higher values, as if it was sampling from a mipmap or something, idk","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["stochastic"],"hasliked":0,"parentid":"NdVcWW","parentname":"Stochasitc Voronoi Tiling"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    fragColor = texture(iChannel0,uv*.9);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"uint murmurHash12(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\nfloat hash12(vec2 src) {\n    uint h = murmurHash12(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\nuvec3 murmurHash33(uvec3 src) {\n    const uint M = 0x5bd1e995u;\n    uvec3 h = uvec3(1190494759u, 2147483647u, 3559788179u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\nvec3 hash33(vec3 src) {\n    uvec3 h = murmurHash33(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\nfloat lerp(float x, float y, float v)\n{\n    if(v<=0.0) return x;\n    else if(v>=1.0) return y;\n    else\n    { \n        return (y - x) * (((v * 6.0 - 15.0) * v + 10.0) * v * v * v) + x;\n    }\n}\nvec2 random_gradient(vec2 uv)\n{\n    float angle = hash12(uv)*2.0*3.14159265358979;\n    return vec2(cos(angle),sin(angle));\n}\nfloat dot_gradient(vec2 i, vec2 uv)\n{\n    vec2 d = uv - i;\n    vec2 grad = random_gradient(vec2(i.x,i.y));\n    return d.x*grad.x + d.y*grad.y;\n}\nfloat pnoise(vec2 uv)\n{\n    vec2 fr = fract(uv);\n    vec2 fl = floor(uv);\n    \n    float n0 = dot_gradient(fl,uv);\n    float n1 = dot_gradient(fl+vec2(1.0,0.0),uv);\n    float o0 = lerp(n0,n1,uv.x-fl.x);\n    \n    n0 = dot_gradient(fl+vec2(0.0,1.0),uv);\n    n1 = dot_gradient(fl+vec2(1.0,1.0),uv);\n    float o1 = lerp(n0,n1,uv.x-fl.x);\n    \n    return lerp(o0,o1,uv.y-fl.y);\n}\nmat2 rotate(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\nvec3 pnoise3(vec2 uv)\n{\n    return vec3(pnoise(uv+479.156),pnoise(uv),pnoise(uv-732.156));\n}\n\nvec2 cell_uv(vec3 pp, float jitter, float rotation, vec2 scale, vec3 offset, float stochastic_factor, float voronoi_deformation, float voronoi_deformation_scale) {\n    vec3 thiscell = floor(pp) + 0.5;\n    float dist2nearest = 100000.;\n    vec3 coordinates_nearest = thiscell + hash33(thiscell)* jitter*vec3(1.,1.,0.)  - 0.5;\n    \n    vec3 last_r = hash33(pp);\n    int i,j,k;\n    for(i = -1; i <= 1; i += 1)\n       for(j = -1; j <= 1; j += 1)\n            for(k = -1; k <= 1; k += 1) {\n              vec3 testcell = thiscell + vec3(i,j,k);\n              vec3 rand = hash33(testcell);\n              vec3 ppp = testcell + (rand * jitter)*vec3(1.,1.,1.) - 0.5;\n              float dist = distance(pp+pnoise3(pp.xy*voronoi_deformation_scale)*voronoi_deformation, ppp);\n\n              last_r = hash33(last_r+vec3(iFrame));\n              if(dist/(dist+dist2nearest) < (last_r.x-.5)*stochastic_factor+.5)\n                {\n                 dist2nearest = distance(pp, ppp);\n                 coordinates_nearest = ppp;\n                 }\n              }\n    vec3 r = pnoise3(coordinates_nearest.xy);\n    vec2 pos = (scale*r.y+1.)*((coordinates_nearest-pp).xy*rotate(6.28318530718*rotation*r.x));\n    r = offset*pnoise3(coordinates_nearest.xy+vec2(100.0));\n    return vec2(pos.x+r.x,pos.y+r.y);\n}\n\n#define OFF vec2(.0003,.0009)\n#define scale 2.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv += float(iFrame)*OFF;\n    uv *= scale;\n    vec2 c = cell_uv(vec3(uv,0.),1.2,0.0,vec2(.5),vec3(10.),.03,.6,4.5);\n    c += .5;\n    c*=.8;\n    \n    fragColor = mix(texture(iChannel0,vec2(c.x,c.y)),texture(iChannel1,fragCoord/iResolution.xy+OFF),.98);\n    if (iFrame < 2)\n        fragColor = texture(iChannel0,vec2(c.x,c.y));\n    //fragColor = vec4(c,0.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}