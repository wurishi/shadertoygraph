{"ver":"0.1","info":{"id":"3sjBDz","date":"1589847251","viewed":580,"name":"Fresnel Equations Demonstration","username":"RaySoldier","description":"I used the Fresnel Equations to create a realistic rendering of a glass sphere.\n\nNote: This is a progressive renderer, meaning that you must reset the time for any changes you make to take effect.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","reflection","refraction","glass","fresnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    fragColor = vec4(texture(iChannel0, uv).rgb, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define N_AIR 1.0\n#define N_GLASS 1.5\n\n// Calculate the intersection points of a line and the unit sphere.\n\nfloat calcIntersectionPoint1(vec3 o, vec3 l){\n    float dotlo = dot(l, o);\n    float det = dotlo * dotlo - dot(o, o) + 1.0;\n    \n    if(det < 0.0){\n        return -1.0;\n    }else{\n        return -dotlo - sqrt(det);\n    }\n}\n\nfloat calcIntersectionPoint2(vec3 o, vec3 l){\n    float dotlo = dot(l, o);\n    float det = dotlo * dotlo - dot(o, o) + 1.0;\n    \n    if(det < 0.0){\n        return -1.0;\n    }else{\n        return -dotlo + sqrt(det);\n    }\n}\n\n// Convert screen position to ray direction\n\nvec3 calcFrust(vec2 uv, vec3 u, vec3 f, float fov){\n    \n    vec3 r = normalize(cross(f, u));\n    u = normalize(cross(r, f));\n    \n    return normalize(normalize(f)/fov + uv.x * r + uv.y * u);\n}\n\n// Use incident angle to calculate the reflectance of the surface (the portion of light that reflect of that surface at that angle)\n\nfloat reflectance(float incidence, float n1, float n2){\n    \n    float cosIncident = cos(incidence);\n    float cosRefract = n1/n2 * sin(incidence);\n    \n    if(cosRefract > 1.0) return 1.0; // total internal reflection\n    \n    cosRefract = sqrt(1.0 - cosRefract * cosRefract);\n    \n    float Rs = (n1*cosIncident - n2 * cosRefract)/(n1*cosIncident + n2 * cosRefract);\n    Rs = Rs*Rs;\n    \n    float Rp = (n1 * cosRefract - n2 * cosIncident)/(n1*cosRefract + n2 * cosIncident);\n    Rp = Rp*Rp;\n    \n    return mix(Rs, Rp, 0.5);\n}\n\n// Calculate the refracted ray direction using snell's law\n\nvec3 snellsLaw(vec3 i, vec3 n, float mu){\n    \n    float det = 1.0 - mu*mu * dot(n, i) * dot(n, i);\n    \n    if(det < 0.0) return vec3(0.0);\n    \n    return sqrt(det) * n + mu * (i - n * dot(n, i));\n    \n}\n\nvec4 raytrace(vec2 uv){\n    \n    float uv_rand_x = texture(iChannel1, vec2(float(iFrame) / 10.001, float(iFrame) / 10.001) + uv).x;\n    float uv_rand_y = texture(iChannel1, vec2(float(iFrame) / 10.001, float(iFrame) / 10.001) + uv + vec2(0.0, 0.1)).x;\n    \n    vec3 o = vec3(-3, 0, 0);\n    vec3 d = calcFrust(uv + vec2(uv_rand_x, uv_rand_y)/iResolution.xy, vec3(0, 1, 0), vec3(1, 0, 0), 1.0);\n    \n    float mul = 1.0;\n    \n    for(int n = 0; n < 50; n++){\n        \n        float dist;\n        \n        if(n == 0){\n    \t\tdist = calcIntersectionPoint1(o, d);\n        }else{\n    \t\tdist = calcIntersectionPoint2(o, d);\n        }\n        \n        if(dist < 0.000001){\n    \t\treturn vec4(texture(iChannel2, d).rgb, mul);\n        }\n        \n        vec3 hitPoint = o + d*dist;\n        vec3 normal = normalize(hitPoint);\n        \n        \n        o = hitPoint;\n            \n        float dotND = dot(normal, d);\n        \n        float rand = texture(iChannel1, vec2(float(n) / 20.0 + float(iFrame) / 10.001, float(iFrame) / 10.001) + uv).x;\n        //float rand = texture(iChannel1, vec2(float(n) / 20.0f, 0.0f) + uv).x;\n        \n        //return vec4(rand);\n        \n        if(rand > 0.5){\n            \n        \tfloat angle = acos(abs(dotND));\n        \n        \tfloat ref;\n        \tif(dotND > 0.0){\n        \t    ref = reflectance(angle, N_GLASS, N_AIR); // internal reflection\n        \t}else{\n        \t    ref = reflectance(angle, N_AIR, N_GLASS); // external reflection\n        \t}\n          \t  \n            d = reflect(d, normal);\n            mul *= ref;\n            \n        }else{\n\n            vec3 dir;\n            \n        \tif(dotND > 0.0){\n        \t    dir = snellsLaw(d, normal, N_GLASS/N_AIR);\n        \t}else{\n        \t    dir = snellsLaw(d, normal, N_AIR/N_GLASS);\n        \t}\n            \n            if(dot(dir, dir) <= 0.1) return vec4(0.0);\n            \n        \tfloat angle = acos(abs(dot(dir, normal)));\n            \n        \tfloat ref;\n            \n        \tif(dotND > 0.0){\n                \n        \t    ref = reflectance(angle, N_AIR, N_GLASS); // refraction in -> out\n        \t}else{\n        \t    ref = reflectance(angle, N_GLASS, N_AIR); // refraction out -> in\n        \t}\n            \n            d = dir;\n            \n            mul *= 1.0 - ref;\n        }\n    }\n    \n    return vec4(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord * 2.0 - iResolution.xy)/iResolution.y;\n    \n    vec4 currentColor = raytrace(uv);\n    \n    if(iFrame == 0){\n        \n    \tfragColor = currentColor;\n        return;\n    }\n    \n    vec4 prevColor = texture(iChannel0, fragCoord/iResolution.xy);\n    vec3 color = mix(prevColor.rgb, currentColor.rgb, currentColor.w/prevColor.w);\n    \n    fragColor = vec4(color, currentColor.w + prevColor.w);\n}","name":"Buffer A","description":"","type":"buffer"}]}