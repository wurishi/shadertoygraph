{"ver":"0.1","info":{"id":"4dfBWn","date":"1495537242","viewed":2707,"name":"Graph scope","username":"grinist","description":"A quickly hacked branch from https://www.shadertoy.com/view/Mdsfz7 for more oscilloscope-like visual. Mouse x controls refresh rate.\nPlease refer to the original for the point about fixed line width graph. This one just borks things, sorry for the spam.","likes":50,"published":3,"flags":0,"usePreview":0,"tags":["oscilloscope","graph","heartbeat"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A quickly hacked branch from https://www.shadertoy.com/view/Mdsfz7\n\n// The values below control the rendering, knock yourself out.\n#define AA_FALLOFF 1.2\t\t\t// AA falloff in pixels, must be > 0, affects all drawing\n#define GRID_WIDTH 0.1\t\t\t// grid line width in pixels, must be >= 0\n#define CURVE_WIDTH\t10.0\t\t// curve line width in pixels, must be >= 0\n\n#define FUNC_SAMPLE_STEP 0.08\t// function sample step size in pixels\n\n#define SCOPE_RATE 0.5\t\t\t// default oscilloscope refresh rate\n\nfloat pp; \t\t\t// pixel pitch in graph units\n\nfloat sinc(float x)\n{\n    return (x == 0.0) ? 1.0 : sin(x) / x;\n}\n\nfloat triIsolate(float x)\n{\n    return abs(-1.0 + fract(clamp(x, -0.5, 0.5)) * 2.0);\n}\n\n// Probably not a healthy heart\nfloat heartbeat(float x)\n{\n    float prebeat = -sinc((x - 0.4) * 40.0) * 0.6 * triIsolate((x - 0.4) * 1.0);\n    float mainbeat = (sinc((x - 0.5) * 60.0)) * 1.2 * triIsolate((x - 0.5) * 0.7);\n    float postbeat = sinc((x - 0.85) * 15.0) * 0.5 * triIsolate((x - 0.85) * 0.6);\n    return (prebeat + mainbeat + postbeat) * triIsolate((x - 0.625) * 0.8); // width 1.25\n}\n\n// The function to be drawn\nfloat func(float x)\n{\n    return 0.5 * heartbeat(mod((x + 0.25), 1.3));\n}\n\n// AA falloff function, trying lerp instead of smoothstep.\nfloat aaStep(float a, float b, float x)\n{\n    // lerp step, make sure that a != b\n    x = clamp(x, a, b);\n    return (x - a) / (b - a);\n}\n\n// Alphablends color\nvoid blend(inout vec4 baseCol, vec4 color, float alpha)\n{\n    baseCol = vec4(mix(baseCol.rgb, color.rgb, alpha * color.a), 1.0);\n}\n\n// Draws a gridline every stepSize\nvoid drawGrid(inout vec4 baseCol, vec2 xy, float stepSize, vec4 gridCol)\n{\n\tfloat hlw = GRID_WIDTH * pp * 0.5;\n    float mul = 1.0 / stepSize;\n\tvec2 gf = abs(vec2(-0.5) + fract((xy + vec2(stepSize) * 0.5) * mul));\n\tfloat g = 1.0 - aaStep(hlw * mul, (hlw + pp * AA_FALLOFF) * mul, min(gf.x, gf.y));\n    blend(baseCol, gridCol, g);\n}\n\n// Draws a circle\nvoid drawCircle(inout vec4 baseCol, vec2 xy, vec2 center, float radius, vec4 color)\n{\n    float r = length(xy - center);\n    float c = 1.0 - aaStep(0.0, radius + pp * AA_FALLOFF, r);\n    blend(baseCol, color, c * c);\n}\n\n// Draws explicit function of x defined in func(x)\nvoid drawFunc(inout vec4 baseCol, vec2 xy, vec4 curveCol)\n{\n    // samples the function around x neighborhood to get distance to curve\n    float hlw = CURVE_WIDTH * pp * 0.5;\n    \n    // cover line width and aa\n    float left = xy.x - hlw - pp * AA_FALLOFF;\n    float right = xy.x + hlw + pp * AA_FALLOFF;\n    float closest = 100000.0;\n    for (float x = left; x <= right; x+= pp * FUNC_SAMPLE_STEP)\n    {\n        vec2 diff = vec2(x, func(x)) - xy;\n        float dSqr = dot(diff, diff);\n        closest = min(dSqr, closest);\n    }\n    \n\tfloat c = 1.0 - aaStep(0.0, hlw + pp * AA_FALLOFF, sqrt(closest));\n\tblend(baseCol, curveCol, c * c * c);\n}\n\nmat2 rotate2d(float angle)\n{\n    float sina = sin(angle);\n    float cosa = cos(angle);\n    return mat2(cosa, -sina,\n                sina, cosa);\n}\n\n// Finds the next smaller power of 10\nfloat findMagnitude(float range)\n{\n    float l10 = log(range) / log(10.0);\n    return pow(10.0, floor(l10));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // graph setup\n\tfloat aspect = iResolution.x / iResolution.y;\n    float z = 0.0;\n\t// comment out disable zoom:\n    z = sin(iTime * 0.3) * 1.2;\n    \n    float graphRange = 0.4 + pow(1.2, z * z * z);\n\tvec2 graphSize = vec2(aspect * graphRange, graphRange);\n    vec2 graphCenter = vec2(0.5, 0.1);\n\tvec2 graphPos = graphCenter - graphSize * 0.5;\n\n    vec2 xy = graphPos + uv * graphSize;\t// xy = current graph coords\n    pp = graphSize.y / iResolution.y;\t\t// pp = pixel pitch in graph units\n    \n    // comment out to disable rotation:\n   \txy = rotate2d(sin(iTime * 0.1) * 0.2) * (xy - graphCenter) + graphCenter;\n\n    // background\n    float t = length(0.5 - uv) * 1.414;\n    t = t * t * t;\n\tvec4 col = mix(vec4(0.1, 0.25, 0.35, 1.0), vec4(0.02, 0.05, 0.07, 1.0), t);\n    \n\t// grid\n    float range = graphSize.y * 2.0;\n    //float mag = findMagnitude(range);\n    drawGrid(col, xy, 0.1, vec4(1.0, 1.0, 1.0, 0.1));\n\tdrawGrid(col, xy, 0.5, vec4(1.0, 1.0, 1.0, 0.1));\n\tdrawGrid(col, xy, 1.0, vec4(1.0, 1.0, 1.0, 0.4));\n\n\tfloat rate = SCOPE_RATE;\n    if (iMouse.z > 0.0)\n    {\n        rate = iMouse.x / iResolution.x;\n        rate = pow(2.0, mix(-3.0, 3.0, rate));\n    }\n    \n    // curve, magic scope coloring thing thrown in for hecks\n    float pulse = fract(iTime * rate) * 4.0 - 1.5;\n    float fade = pulse - xy.x;\n    if (fade < 0.0) fade += 4.0;\n    fade *= 0.25;\n    fade = clamp(fade / rate, 0.0, 1.0);\n    fade = 1.0 - fade;\n    fade = fade * fade * fade;\n    fade *= step(-1.5, xy.x) * step(xy.x, 2.5);\n    vec4 pulseCol = vec4(0.0, 1.0, 0.7, fade * 1.5);\n    drawFunc(col, xy, pulseCol);\n    pulseCol.a = 1.5;\n    drawCircle(col, xy, vec2(pulse, func(pulse)), CURVE_WIDTH * pp, pulseCol);\n    \n\tfragColor = col;\n}","name":"Image","description":"","type":"image"}]}