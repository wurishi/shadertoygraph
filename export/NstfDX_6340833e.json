{"ver":"0.1","info":{"id":"NstfDX","date":"1657339821","viewed":86,"name":"3D-Perlin","username":"nelsonkuang","description":"Play With 3D Perlin Noice","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["noise","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// My version of 3D Perlin noise \n// References\n// https://wallisc.github.io/rendering/2020/05/02/Volumetric-Rendering-Part-1.html\n// https://blog.csdn.net/candycat1992/article/details/50346469\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float PI = 3.1415926535897932384626433832795;\nconst mat3 m3 = mat3(0.00, 0.80, 0.60, -0.80, 0.36, -0.48, -0.60, -0.48, 0.64);\n\nstruct Material {\n  vec3 ambientColor; // k_a * i_a\n  vec3 diffuseColor; // k_d * i_d\n  vec3 specularColor; // k_s * i_s\n  float alpha; // shininess\n};\n\nstruct Surface {\n  int id; // id of object\n  float sd; // signed distance value from SDF\n  Material mat; // material of object\n};\n\nMaterial gold() {\n  vec3 aCol = 0.5 * vec3(0.7, 0.5, 0);\n  vec3 dCol = 0.6 * vec3(0.7, 0.7, 0);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial silver() {\n  vec3 aCol = 0.4 * vec3(0.8);\n  vec3 dCol = 0.5 * vec3(0.7);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial checkerboard(vec3 p) {\n  vec3 aCol = vec3(1. + 0.7 * mod(floor(p.x) + floor(p.z), 2.0)) * 0.3;\n  vec3 dCol = vec3(0.3);\n  vec3 sCol = vec3(0);\n  float a = 1.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\n// Rotation matrix around the X axis.\n/*\nc = cos(theta)\ns = sin(theta)\n\nc, -s, 0\ns, c, 0\n0, 0, 1\n*/\nmat3 rotateX(float theta) {\n  float c = cos(theta);\n  float s = sin(theta);\n  return mat3(vec3(1, 0, 0), vec3(0, c, -s), vec3(0, s, c));\n}\n\n// Rotation matrix around the Y axis.\n/*\nc = cos(theta)\ns = sin(theta)\n\nc, 0, s\n0, 1, 0\n-s, 0, c\n*/\nmat3 rotateY(float theta) {\n  float c = cos(theta);\n  float s = sin(theta);\n  return mat3(vec3(c, 0, s), vec3(0, 1, 0), vec3(-s, 0, c));\n}\n\n// Rotation matrix around the Z axis.\n/*\nc = cos(theta)\ns = sin(theta)\n\nc, -s, 0\ns, c, 0\n0, 0, 1\n*/\nmat3 rotateZ(float theta) {\n  float c = cos(theta);\n  float s = sin(theta);\n  return mat3(vec3(c, -s, 0), vec3(s, c, 0), vec3(0, 0, 1));\n}\n\n// Identity matrix.\n/*\n1, 0, 0\n0, 1, 0\n0, 0, 1\n*/\nmat3 identity() {\n  return mat3(vec3(1, 0, 0), vec3(0, 1, 0), vec3(0, 0, 1));\n}\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\n/*\nSurface IDs:\n1. Floor\n2. Box\n*/\nSurface sdFloor(vec3 p, float offset, Material mat) {\n  float d = p.y - offset;\n  return Surface(1, d, mat);\n}\n\n// 第一个参数 p，就是采样的点，第二个参数 b，是一个类型为 vec3 的变量，表示盒子的边界。\n// 使用 x、y 和 z 元素控制盒子的长、宽、高。如果它们的值相同，就可以得到一个正方形盒子。\nSurface sdBox(vec3 p, vec3 b, vec3 offset, Material mat, mat3 transform, vec3 transformOrigin) {\n  p = (p - offset) * transform - transformOrigin;\n  vec3 q = abs(p) - b;\n  float d = length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n  return Surface(2, d, mat);\n}\n\n// x ^ 2 + y ^ 2 + z ^ 2 = r ^ 2\nSurface sdSphere(vec3 p, float r, vec3 offset, Material mat, mat3 transform, vec3 transformOrigin) {\n  p = (p - offset) * transform - transformOrigin;\n  return Surface(3, length(p) - r, mat);\n}\n\nSurface opUnion(Surface obj1, Surface obj2) {\n  if(obj2.sd < obj1.sd)\n    return obj2; // The sd component of the struct holds the \"signed distance\" value\n  return obj1;\n}\n\nSurface sdSmoothUnion(Surface obj1, Surface obj2, float k) {\n  float d1 = obj1.sd;\n  float d2 = obj2.sd;\n\n  Material mat = obj1.mat;\n\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n\n  return Surface(4, mix(d2, d1, h) - k * h * (1.0 - h), mat);\n}\n\nfloat hash1(float n) {\n  return fract(n * 17.0 * fract(n * 0.3183099));\n}\n\n// Chris' version of Perlin noise.\nfloat noise(in vec3 x) {\n  vec3 p = floor(x);\n  vec3 w = fract(x);\n\n  vec3 u = w * w * w * (w * (w * 6.0 - 15.0) + 10.0);\n\n  float n = p.x + 317.0 * p.y + 157.0 * p.z;\n\n  float a = hash1(n + 0.0);\n  float b = hash1(n + 1.0);\n  float c = hash1(n + 317.0);\n  float d = hash1(n + 318.0);\n  float e = hash1(n + 157.0);\n  float f = hash1(n + 158.0);\n  float g = hash1(n + 474.0);\n  float h = hash1(n + 475.0);\n\n  float k0 = a;\n  float k1 = b - a;\n  float k2 = c - a;\n  float k3 = e - a;\n  float k4 = a - b - c + d;\n  float k5 = a - c - e + g;\n  float k6 = a - b - e + f;\n  float k7 = -a + b + c - d + e - f - g + h;\n\n  return -1.0 + 2.0 * (k0 + k1 * u.x + k2 * u.y + k3 * u.z + k4 * u.x * u.y + k5 * u.y * u.z + k6 * u.z * u.x + k7 * u.x * u.y * u.z);\n}\n\nvec2 hash22(vec2 p) {\n  p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n\n  return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\n// My version of Perlin noise \n// Reference: https://blog.csdn.net/candycat1992/article/details/50346469\nfloat perlinNoise(in vec3 p) {\n  vec3 pi = floor(p); // 晶格的顶点\n  vec3 pf = fract(p); // 输入的一个点\n\n  // vec2 w = pf * pf * (3.0 - 2.0 * pf); // 缓和曲线是 s(t)=3t^2 − 2t^3\n  vec3 w = (6.0 * pf * pf - 15.0 * pf + 10.0) * pf * pf * pf; // 缓和曲线是 s(t)=6t^5−15t^4+10t^3 = (6 * t * t - 15 * t + 10) * t * t * t\n\n  // 找到和它相邻的那些晶格顶点\n  // “伪随机”的梯度向量\n  vec3 grad01 = vec3(hash22(pi.xy + vec2(0.0, 0.0)), hash1(pi.z + 0.0));\n  vec3 grad02 = vec3(hash22(pi.xy + vec2(1.0, 0.0)), hash1(pi.z + 0.0));\n  vec3 grad03 = vec3(hash22(pi.xy + vec2(0.0, 1.0)), hash1(pi.z + 0.0));\n  vec3 grad04 = vec3(hash22(pi.xy + vec2(1.0, 1.0)), hash1(pi.z + 0.0));\n  vec3 grad05 = vec3(hash22(pi.xy + vec2(0.0, 0.0)), hash1(pi.z + 1.0));\n  vec3 grad06 = vec3(hash22(pi.xy + vec2(1.0, 0.0)), hash1(pi.z + 1.0));\n  vec3 grad07 = vec3(hash22(pi.xy + vec2(0.0, 1.0)), hash1(pi.z + 1.0));\n  vec3 grad08 = vec3(hash22(pi.xy + vec2(1.0, 1.0)), hash1(pi.z + 1.0));\n\n  // 计算该点到各个晶格顶点的距离向量\n  vec3 d01 = pf - vec3(0.0, 0.0, 0.0);\n  vec3 d02 = pf - vec3(1.0, 0.0, 0.0);\n  vec3 d03 = pf - vec3(0.0, 1.0, 0.0);\n  vec3 d04 = pf - vec3(1.0, 1.0, 0.0);\n  vec3 d05 = pf - vec3(0.0, 0.0, 1.0);\n  vec3 d06 = pf - vec3(1.0, 0.0, 1.0);\n  vec3 d07 = pf - vec3(0.0, 1.0, 1.0);\n  vec3 d08 = pf - vec3(1.0, 1.0, 1.0);\n\n  // 距离向量分别与顶点上的梯度向量做点乘，得到2^n个点乘结果\n  float res01 = dot(grad01, d01);\n  float res02 = dot(grad02, d02);\n  float res03 = dot(grad03, d03);\n  float res04 = dot(grad04, d04);\n  float res05 = dot(grad05, d05);\n  float res06 = dot(grad06, d06);\n  float res07 = dot(grad07, d07);\n  float res08 = dot(grad08, d08);\n\n  // 使用缓和曲线（ease curves）来计算它们的权重和\n  float res1234 = mix(mix(res01, res02, w.x), mix(res03, res04, w.x), w.y);\n  float res5678 = mix(mix(res05, res06, w.x), mix(res07, res08, w.x), w.y);\n  float res = mix(res1234, res5678, w.z);\n\n  return res;\n}\n\n// 分形布朗运动FBM(Fractal Brown Motion)\n// https://iquilezles.org/articles/fbm/\nfloat fbm_4(in vec3 x) {\n  float f = 2.0;\n  float s = 0.5;\n  float a = 0.0;\n  float b = 0.5;\n  for(int i = min(0, iFrame); i < 4; i++) {\n    float n = perlinNoise(x);\n    a += b * n;\n    b *= s;\n    x = f * m3 * x;\n  }\n  return a;\n}\n\n// Reference: https://blog.csdn.net/candycat1992/article/details/50346469\nfloat noiseSum(vec3 p) {\n  float f = 0.0;\n  p = p * 4.0;\n\n  for(int i = min(0, iFrame); i < 4; i++) {\n    f += 1.0000 / float(i + 1) * perlinNoise(p);\n    p = 2.0 * p;\n  }\n\n  return f;\n}\n\n// 对噪声返回值进行了取绝对值操作\n// 由于进行了绝对值操作，因此会在0值变化处出现不连续性，形成一些尖锐的效果。通过合适的颜色叠加，我们可以用这种噪声来模拟火焰、云朵这些物体。Perlin把这个公式称为turbulence（湍流？），因为它看起来挺像的。\nfloat noiseSumAbs(vec3 p) {\n  float f = 0.0;\n  p = p * 7.0;\n  for(int i = min(0, iFrame); i < 4; i++) {\n    f += 1.0000 / float(i + 1) * abs(perlinNoise(p));\n    p = 2.0 * p;\n  }\n\n  return f;\n}\n\n// 在之前turbulence公式的基础上使用了一个关于表面x分量的正弦函数\nfloat noiseSumAbsSin(vec3 p) {\n  float f = 0.0;\n  p = p * 7.0;\n  for(int i = min(0, iFrame); i < 4; i++) {\n    f += 1.0000 / float(i + 1) * abs(perlinNoise(p));\n    p = 2.0 * p;\n  }\n\n  return sin(f + p.x / 32.0);\n}\n\nSurface sdScene(vec3 p) {\n  vec3 fbmCoord = (p + 2.0 * vec3(iTime, 0.0, iTime)) / 1.5f;\n\n  Surface floorObj = sdFloor(p, -1., checkerboard(p));\n  Surface leftSphereObj = sdSphere(p, 5.6, vec3(-8.0, 2.0 + 20.0 * sin(iTime), -1), silver(), identity(), vec3(0)); // identity\n  Surface midSphereObj = sdSphere(p, 5.6, vec3(8.0, 8.0 + 12.0 * cos(iTime), 3), silver(), identity(), vec3(0));\n  Surface rightSphereObj = sdSphere(p, 8., vec3(5.0 * sin(iTime), 3.0, 0), silver(), identity(), vec3(0));\n\n  Surface co = sdSmoothUnion(leftSphereObj, midSphereObj, 3.0);\n  co = sdSmoothUnion(co, rightSphereObj, 3.0);\n  // co.sd += 7.0 * fbm_4(fbmCoord / 3.2);\n  // co.sd += noiseSum(fbmCoord / 10.2);\n  // co.sd += 7.0 * noiseSumAbs(fbmCoord / 3.2);\n  co.sd += noiseSumAbsSin(fbmCoord / 30.2);\n\n  co = opUnion(co, floorObj);\n\n  return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n  Surface co; // closest object\n\n  for(int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = sdScene(p);\n    depth += co.sd;\n    if(co.sd < PRECISION || depth > end)\n      break;\n  }\n\n  co.sd = depth;\n\n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n  vec2 e = vec2(1., -1.) * .0005; // epsilon\n  return normalize(e.xyy * sdScene(p + e.xyy).sd +\n    e.yyx * sdScene(p + e.yyx).sd +\n    e.yxy * sdScene(p + e.yxy).sd +\n    e.xxx * sdScene(p + e.xxx).sd);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n  vec3 up = vec3(0, 1, 0);\n  vec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n  vec3 cr = normalize(cross(up, cd)); // camera right\n  vec3 cu = normalize(cross(cd, cr)); // camera up\n\n  return mat3(-cr, cu, -cd); // 如果把 cr 改为 -cr，就可以把相机看向相反方向了。看上去红与蓝交换了位置。\n  // 使用任何一种相机模式来定义观察目标点，都需要好好地了解你使用坐标轴的规则。你可以调整 cr，cu 或者 cd 来制造一些有趣的效果。\n  // 请确保射线方向 rd 调整到之前的 -1。\n\n  // return mat3(-cr, cu, abs(cos(iTime)) * -cd); // 在 z 轴上产生一个快速拉伸的弹弓效果。这样也许可以用来表示弯曲效果？\n}\n\nvec3 phong(vec3 lightDir, vec3 normal, vec3 rd, Material mat) {\n  // ambient\n  vec3 ambient = mat.ambientColor;\n\n  // diffuse\n  float dotLN = clamp(dot(lightDir, normal), 0., 1.);\n  vec3 diffuse = mat.diffuseColor * dotLN;\n\n  // specular\n  float dotRV = clamp(dot(reflect(lightDir, normal), -rd), 0., 1.);\n  vec3 specular = mat.specularColor * pow(dotRV, mat.alpha);\n\n  return ambient + diffuse + specular;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n  vec2 mouseUV = iMouse.xy / iResolution.xy; // Range: <0, 1>\n\n  vec3 backgroundColor = vec3(.835, 1, 1);\n\n  vec3 col = vec3(0);\n\n  // vec3 lp = vec3(0, 0, 0); // lookat point (aka camera target)\n  vec3 lp = vec3(0, .5, -4); // lookat point - middle box\n  // vec3 lp = vec3(-4, 0.5, -4); // lookat point - left box\n  // vec3 lp = vec3(4, 0.5, -4); // lookat point - right box\n\n  // vec3 ro = vec3(0, 0, 5); // ray origin that represents camera position\n  // vec3 ro = vec3(cos(iTime), sin(iTime) + 0.1, 3);\n  // vec3 ro = vec3(0, 0.5, 0); // ray origin that represents camera position\n\n  // at a higher position. It's like we're a news reporter flying around in a helicopter.\n  vec3 ro = vec3(0, 5, 0);\n\n  // the camera spinning around the scene because it's following a circular path, but it's still looking at the green cube using our lookat point.\n  // 参考公式：https://www.desmos.com/calculator/5emxoibru1?lang=zh-CN\n  // float cameraRadius = 10.;\n  // ro.x = cameraRadius * cos(iTime) + lp.x; // convert x-component to polar and add offset\n  // ro.z = cameraRadius * sin(iTime) + lp.z; // convert z-component to polar and add offset\n\n  float cameraRadius = 3.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(PI / 2., 0., mouseUV.y)); // remap mouseUV.y to <pi/2, 0> range\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z); // remap mouseUV.x to <-pi, pi> range\n\n  // vec3 rd = normalize(vec3(uv, -1)); // ray direction\n  // rd *= rotateX(sin(iTime) * 0.5); // 上下摆动相机（pitch），角度在 -0.5 到 0.5 之间\n  // rd *= rotateY(sin(iTime) * 0.5); // 左右摆动相机（yaw），应用 rotateY函数，左右摆动角度在 -0.5 到 0.5 之间\n  // rd *= rotateZ(sin(iTime) * 0.5); // 侧面摆动相机（roll），需要应用 rotateZ 函数。是不是像滚筒洗衣机一样，角度在 -0.5 到 0.5 之间\n  // rd *= rotateY(sin(iTime) * PI); // 我们同样也可以在 PI 和负 PI 之间沿着 yaw 旋转，这样就能完成 360 度的旋转\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction，如果 -1 改为 1 就是反向的\n\n  Surface co = rayMarch(ro, rd, MIN_DIST, MAX_DIST); // closest object\n\n  if(co.sd > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.sd; // point on sphere or floor we discovered from ray marching\n    vec3 normal = calcNormal(p);\n\n      // light #1\n    vec3 lightPosition1 = vec3(-8, -6, -5);\n    vec3 lightDirection1 = normalize(lightPosition1 - p);\n    float lightIntensity1 = 0.9;\n\n      // light #2\n    vec3 lightPosition2 = vec3(1, 1, 1);\n    vec3 lightDirection2 = normalize(lightPosition2 - p);\n    float lightIntensity2 = 0.5;\n\n      // final color of object\n    col = lightIntensity1 * phong(lightDirection1, normal, rd, co.mat);\n    col += lightIntensity2 * phong(lightDirection2, normal, rd, co.mat);\n  }\n\n  // Output to screen\n  fragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"}]}