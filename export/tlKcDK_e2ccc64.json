{"ver":"0.1","info":{"id":"tlKcDK","date":"1611836895","viewed":145,"name":"2-pass DT","username":"ming","description":"Compare the outcome to use the 2-pass DT from here:\nhttps://www.shadertoy.com/view/WtVGDK\n\nThe search range is bounded by the resolution for fewer texture fetches.\n","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["2d","jfa","dt"],"hasliked":0,"parentid":"WlGyR3","parentname":"Jump Flooding DT"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Original shader https://www.shadertoy.com/view/4syGWK\n// Buffer A - conduct 2-pass DT iterations\n// Buffer B - cache the results for the last pass in each iteration\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // calculate the distance to the nearest neighbour\n    ivec2 tc = ivec2(fragCoord + 0.5);\n    \n    float d = load0(tc).r / 64.0;\n    \n    d = pow(d, 0.4545);\n    \n    store(fragColor,vec4(d,d,d,0.0));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat computeDistance(vec2 uv, vec2 dir, int size)\n{\n    float d = 0.;\n    for (int i = 1; i < size; i+=1)\n    {\n        vec2 s_uv = vec2(uv) + float(i) * dir;\n        \n        float val = 0.0;\n        if (s_uv.y >= 0.0 || s_uv.y < 1.0)\n            val = texture(iChannel0, s_uv).a;\n            \n        if(val == 0.0) \n            break;\n        \n        d += 1.0;\n    }\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pass = pass_id();\n    \n    if (pass == 0.0) {\n        // init\n        vec2 uv = sprite_uv(fragCoord, iResolution.xy, iTime * 5.0);\n        vec4 color = texture(iChannel1, uv);\n        \n        // store the coordinate for non-empty pixels, otherwise zero\n        float lum = grayscale(color.rgb);\n        if (lum < 0.5)\n            store(fragColor, vec4(0.0));\n        else\n            store(fragColor, vec4(1.0));\n        \n    } else if (pass == 1.0) {\n        // compute distant in y direction\n        vec2 uv = fragCoord / iResolution.xy;\n        vec2 texelSize = 1.0 / iResolution.xy;\n\n        vec4 buffer = texture(iChannel0, uv);\n        float dy = buffer.a;\n        if(dy != 0.0)\n        {\n            int size = int(iResolution.y) / 2;\n            vec2 dir = vec2(0.0, texelSize.y);\n            \n            int down = int(iResolution.y - fragCoord.y);\n            int up = int(fragCoord.y);\n            \n            float dy1 = computeDistance(uv, dir, size);\n            float dy2 = computeDistance(uv, -dir, size);\n\n            // also pre-multiply and save the sign\n            dy = dy1 < dy2 ? dy1 * dy1 : -dy2 * dy2;\n        }\n\n        store(fragColor, vec4(dy, buffer.g, buffer.b, buffer.a));\n        \n    } else {\n        // compute the distance in x from y\n        vec2 uv = fragCoord / iResolution.xy;\n        vec2 texelSize = 1.0 / iResolution.xy;\n        vec4 buffer = texture(iChannel0, uv);\n\n        int x = int(fragCoord.x);\n        vec2 delta;\n        float minDist = 1e+10;\n        for (int i = 0; i < int(iResolution.x); i++)\n        {\n            float dx = float(x - i);\n            float dy2 = texture(iChannel0, vec2(float(i) * texelSize.x, uv.y)).r;\n            float d = dx * dx + abs(dy2);\n            \n            if(minDist > d)\n            {\n                minDist = d;\n                delta = vec2(dx, dy2);\n            }\n        }\n        minDist = sqrt(minDist);\n        \n        delta.x *= -1.0;\n        delta.y = sign(delta.y) * sqrt(abs(delta.y));\n\n        store(fragColor, vec4(minDist, delta.x, delta.y, buffer.a));\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define pass_id() mod(float(iFrame),3.0);\n#define last_pass_id 2.0\n\nvec2 sprite_uv( in vec2 coord, in vec2 resolution, in float time )\n{\n    vec2 uv = coord / resolution.xy;\n    uv.x = clamp(uv.x * resolution.x / resolution.y - 0.3, 0.0, 1.0);\n    float ww = 40.0/256.0;\n    return floor(mod(time, 6.0)) * vec2(ww,0.0) + vec2(ww,1.0) * uv;\n}\n\n\nvoid store(out vec4 t, vec4 v) {\n    t = v;\n}\n\nvec4 load(sampler2D channel, vec2 res, ivec2 p) {\n    vec2 uv = (vec2(p)-0.5) / res;\n    return texture(channel, uv);\n}\n\n#define load0(p) load(iChannel0, iChannelResolution[0].xy, p)\n#define load1(p) load(iChannel1, iChannelResolution[1].xy, p)\n\nfloat grayscale(vec3 color)\n{\n    return dot(color, vec3(0.299, 0.587, 0.114));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pass = pass_id();\n    \n    ivec2 tc = ivec2(fragCoord + 0.5);\n    \n    if (pass == last_pass_id) {\n        // update from Buffer A in every last pass in each iteration\n        store(fragColor,load0(tc));\n    }\n    else {\n        // otherwise keeps Buffer B's cached results\n        store(fragColor, load1(tc));\n    }\n}\n","name":"Buffer B","description":"","type":"buffer"}]}