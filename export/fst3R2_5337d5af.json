{"ver":"0.1","info":{"id":"fst3R2","date":"1630230827","viewed":59,"name":"project stochastics round 2","username":"Dusty","description":"noise everywhere!","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["experiment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ---------------------------------------------------------------------------\n// project stochastics round 2\n//\n// continuing goal: \n//\n//   approximate an ideal noise function,\n//   that reveals no visual correlations,\n//   when sampled at regular intervals,\n//   everywhere!\n//\n//   efficiency is still of only secondary consideration\n//\n//   diving in and generalizing now\n//   almost to the point of an actual noise() function\n//\n// NOTES\n//\n//   lehmer()     known as lehmer hash, or lehmer cipher, or lehmer rng\n//\n//       the analogy I like to use is that it can be viewed as a function of a \n// _pile_shuffle_ of a very large (4 billion cards) abstract deck of cards .. \n//\n//                it answers the question:\n//                  where does the card that was in position #h go after \n//                  doing this pile shuffle once?\n//\n//  it is both good and bad that lehmer() is a simple singular multiplication \n//  by an odd constant with good properties\n//\n//  the good is that it is efficient\n//  the bad is that bitwise information only propagates \"upwards\"\n// \n//  lox() is a 2-operation shuffle that bitwise propagates \"downwards\"\n//\n//  note that all bijective transforms of a machine word can be viewed as some kind\n//  of shuffling - its shuffling all the way down - addition is a cut of the deck - \n//  multiplication is a pile shuffle - bitwise rolling is a faro shuffle!\n// ---------------------------------------------------------------------------\n// lehmer shuffle (bijective) propgates information towards the MSBs\n\nuint LEHMER(uint h)   { return 0xCC2BFE9Du * h; }\nuvec2 LEHMER(uvec2 h) { return 0xCC2BFE9Du * h; } \nuvec3 LEHMER(uvec3 h) { return 0xCC2BFE9Du * h; }\nuvec4 LEHMER(uvec4 h) { return 0xCC2BFE9Du * h; }\n\n// ---------------------------------------------------------------------------\n// XOR shuffle (bijective) propgates information towards the LSBs\n\nuint LOX(uint h)        { return h ^ (h >> 16); }\nuvec2 LOX(uvec2 h)      { return h ^ (h >> 16); }\nuvec3 LOX(uvec3 h)      { return h ^ (h >> 16); }\nuvec4 LOX(uvec4 h)      { return h ^ (h >> 16); }\n\n// ---------------------------------------------------------------------------\n// key handling - the keys themselves could get a minor preshuffle (bijective)\n\nuint KEYBITS(float k) {return floatBitsToUint(k);} //{ return LOX(LEHMER(floatBitsToUint(k))); }\nuvec2 KEYBITS(vec2 k) {return floatBitsToUint(k);} //{ return LOX(LEHMER(floatBitsToUint(k))); }\nuvec3 KEYBITS(vec3 k) {return floatBitsToUint(k);} //{ return LOX(LEHMER(floatBitsToUint(k))); }\nuvec4 KEYBITS(vec4 k) {return floatBitsToUint(k);} //{ return LOX(LEHMER(floatBitsToUint(k))); }\n\n// ---------------------------------------------------------------------------\n// interprets as uniformly distributed in the range 0.0 <= x < 1.0, loses 8-bits\n\nfloat UNIFORM(uint h) { return float(h & 0xffffffu) * (1.0 / float(0x1000000)); }\nvec2 UNIFORM(uvec2 h) { return vec2(h & 0xffffffu) * (1.0 / float(0x1000000)); }\nvec3 UNIFORM(uvec3 h) { return vec3(h & 0xffffffu) * (1.0 / float(0x1000000)); }\nvec4 UNIFORM(uvec4 h) { return vec4(h & 0xffffffu) * (1.0 / float(0x1000000)); }\n\n// ---------------------------------------------------------------------------\n// sufficient decorrelation is called a hash here, yet it too is a shuffle\n\nuint HASH(uint h, vec2 key)\n{ uvec2 k = KEYBITS(key);\n  h = LOX(LEHMER(h + k.x)); // cut-shuffle-shuffle\n  h = LOX(LEHMER(h + k.y)); // cut-shuffle-shuffle\n  return LEHMER(LOX(LEHMER(h))); // shuffle-shuffle-shuffle\n}\n\nuvec2 HASH(uvec2 h, vec2 key)\n{ uvec2 k = KEYBITS(key);\n  h = LOX(LEHMER(h + k.x));\n  h = LOX(LEHMER(h + k.y));\n  return LEHMER(LOX(LEHMER(h)));\n}\n\nuvec3 HASH(uvec3 h, vec2 key)\n{ uvec2 k = KEYBITS(key);\n  h = LOX(LEHMER(h + k.x));\n  h = LOX(LEHMER(h + k.y));\n  return LEHMER(LOX(LEHMER(h)));\n}\n\nuvec4 HASH(uvec4 h, vec2 key)\n{ uvec2 k = KEYBITS(key);\n  h = LOX(LEHMER(h + k.x));\n  h = LOX(LEHMER(h + k.y));\n  return LEHMER(LOX(LEHMER(h)));\n}\n\n// handy\n\nuint  HASH1(vec2 key) { return HASH(2u, key); }\nuvec2 HASH2(vec2 key) { return HASH(uvec2(3u, 5u), key); }\nuvec3 HASH3(vec2 key) { return HASH(uvec3(7u, 11u, 13u), key); }\nuvec4 HASH4(vec2 key) { return HASH(uvec4(17u, 19u, 23u, 29u), key); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = floor(fragCoord + 100.0 * vec2(cos(0.1 * sqrt(iTime)), sin(0.1 * sqrt(iTime))) * iTime);\n    vec3 c = UNIFORM(HASH3(p));\n    fragColor = vec4(c*c,1.0);\n}","name":"Image","description":"","type":"image"}]}