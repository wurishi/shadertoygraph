{"ver":"0.1","info":{"id":"ttBfDK","date":"1599865370","viewed":232,"name":"Three-body","username":"rockmanx","description":"Phong Shading test\n\nTheory: https://disigns.wordpress.com/portfolio/shadertoy-glsl-demos/","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","phong","raycast","shadow","ball","bouncing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//////////////////// Learning Reference ////////////////////////// \n// ray_match algorithm: https://typhomnt.github.io/Files/MSIAM_TP4__Ray_Marching.pdf\n// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n// https://iquilezles.org/articles/distfunctions\n// https://stackoverflow.com/questions/34050929/3d-point-rotation-algorithm/34060479\n// https://learnopengl.com/Getting-started/Camera\n// https://www.geertarien.com/blog/2017/07/30/breakdown-of-the-lookAt-function-in-OpenGL/\n// https://www.desmos.com/calculator\n\n#define NEAR_PLANE \t-1.5\n#define MARCH_STEPS 300\n#define GRADIANCE \t0.0001\n#define MARCH_NEAR \t0.001\n#define MARCH_FAR \t20.0\n#define PI     \t\t3.14159265\n\n//////////////////// Signed Distance Functions ////////////////////////// \nfloat sphereSDF(in vec3 pos, in vec3 offset, in float radius)\n{\n\treturn length(pos-offset) - radius;\n}\n\nfloat planeSDF(in vec3 pos, in float height)\n{\n\treturn pos.y - height;\n}\n\nfloat boundingBoxSDF( in vec3 pos, in vec3 b, in float e, in vec3 offset, in vec3 rotate)\n{\n    pos = pos - offset; // offsset to new position\n   \tpos = euler_rotate(pos, rotate.x, rotate.y, rotate.z);\n\tvec3 p = abs(pos)-b;\n\tvec3 q = abs(p+e)-e;\n\treturn min(min(\n\tlength(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n\tlength(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n\tlength(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nvec2 sceneSDF(in vec3 pos)\n{\n    // scene discription using SDFs\n    float sphere1_radius = 0.12;\n    vec3  sphere1_location = vec3(0.0, 0.1, -0.7*sin(2.0*iTime));\n    \n    float sphere2_radius = 0.12;\n    vec3  sphere2_location = vec3(-0.7*cos(2.0*iTime), 0.1, 0.0);\n    \n    float bb_radius = 0.1;\n    float t = fract(2.0*iTime/PI);\n    vec3  bb_location = vec3(0.0, 4.2*t*(1.0-t)-0.3, 0.0);\n    \n    vec3  bounding_box_size = vec3(0.3, 0.3, 0.3);\n    vec3  bounding_box_location = vec3(0.0, 0.1, 0.0);\n    vec3  bounding_box_rotation = vec3(0.0, iTime, 0.0);\n    float bounding_box_thickness = 0.01;\n    \n    float plane_height = -0.35;\n    \n    // SDF objects\n    float sphere1_sdf = sphereSDF(pos, sphere1_location, sphere1_radius);\n    float sphere2_sdf = sphereSDF(pos, sphere2_location, sphere2_radius);\n    float bb_sdf = sphereSDF(pos, bb_location, bb_radius);\n    float plane_sdf = planeSDF(pos, plane_height);\n    float bounding_box_sdf = boundingBoxSDF( pos, bounding_box_size, bounding_box_thickness, bounding_box_location, bounding_box_rotation);\n    \n    // object ID\n    float object_ID = 1.0;\n    if (bb_sdf<bounding_box_sdf && bb_sdf<sphere1_sdf && bb_sdf<sphere2_sdf && bb_sdf<plane_sdf)\n    {\n    \tobject_ID = 2.0;\n    }\n    if (sphere1_sdf<bounding_box_sdf && sphere1_sdf<bb_sdf && sphere1_sdf<sphere2_sdf && sphere1_sdf<plane_sdf)\n    {\n    \tobject_ID = 3.0;\n    }\n    if (sphere2_sdf<bounding_box_sdf && sphere2_sdf<bb_sdf && sphere2_sdf<sphere1_sdf && sphere2_sdf<plane_sdf)\n    {\n    \tobject_ID = 4.0;\n    }\n    \n    // put sdf objects in the scene\n    float roundness = 0.15;\n    float scene_sdf = plane_sdf;\n    scene_sdf = smin(scene_sdf, bounding_box_sdf, roundness);\n    scene_sdf = smin(scene_sdf, sphere1_sdf, roundness);\n    scene_sdf = smin(scene_sdf, sphere2_sdf, roundness);\n    scene_sdf = smin(scene_sdf, bb_sdf, roundness);\n    return vec2(scene_sdf, object_ID);\n}\n\n//////////////////// rendering helper functions //////////////////////////\n// normal\nvec3 calcNormal(in vec3 pos)\n{\n    // calculate the normal by approximating SDF change in delta. \n    float e = GRADIANCE;\n    vec3 normal = vec3(sceneSDF(vec3(pos.x + e, pos.y, pos.z)).x - sceneSDF(vec3(pos.x - e, pos.y, pos.z)).x,\n                       sceneSDF(vec3(pos.x, pos.y + e, pos.z)).x - sceneSDF(vec3(pos.x, pos.y - e, pos.z)).x,\n                       sceneSDF(vec3(pos.x, pos.y, pos.z + e)).x - sceneSDF(vec3(pos.x, pos.y, pos.z - e)).x);\n\treturn normalize(normal);\n}\n\n// ray match\nvec2 castRay(in vec3 camera_pos, vec3 ray_dir)\n{   \n    //ray match\n    float material = -1.0;\n    float depth = 0.0;\n    for (int i = 0; i<MARCH_STEPS; i++)\n    {\n    \tvec3 sample_pos = camera_pos + depth*ray_dir;   \n        vec2 scene_sdf = sceneSDF( sample_pos );\n        float h = scene_sdf.x;\n        material = scene_sdf.y;\n        if (h < MARCH_NEAR) break;          \n        depth += h;\n        if (h > MARCH_FAR) break;\n    }\n    \n    if (depth>MARCH_FAR)\n    {\n    \tdepth = -1.0;\n    }\n    \n    return vec2(depth,material);\n}\n\nfloat castSoftShadow(in vec3 ray_ori, in vec3 ray_dir, float sharpness)\n{\n\tfloat res = 1.0;\n    float depth = 0.01;\n    sharpness = clamp(1.0, 100.0, sharpness);\n    \n    for (int i = 0; i< MARCH_STEPS; i++)\n    {\n    \tvec3 sample_pos = ray_ori + depth*ray_dir;\n        float dist = sceneSDF( sample_pos ).x;\n        res = min(res, sharpness*dist/depth);\n        if (dist < MARCH_NEAR) break;\n        depth += dist;\n        if (dist > MARCH_FAR) break;\n    }\n    return res;\n}\n\n//////////////////// output //////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Center Origin p\n    vec2 p = (2.0*fragCoord -iResolution.xy)/iResolution.y;    \n    \n    // camera settings\n    float camera_y = 1.0-iMouse.y/iResolution.y;\n    float camera_x = 0.5-iMouse.x/iResolution.x;\n    vec3 camera_pos = vec3(2.0*camera_x, 2.0*camera_y , 1.3);\n    vec3 camera_tar = vec3(0.0, 0.3, 0.0);\n    \n    // camera space\n    vec3 camera_w = normalize(camera_tar- camera_pos);\n    vec3 camera_u = normalize(cross(camera_w, vec3(0.0, 1.0, 0.0)));\n    vec3 camera_v = normalize(cross(camera_u,camera_w));\n\n    // world space to camera space projection.\n    vec3 ray_hit = normalize(p.x*camera_u + p.y*camera_v + NEAR_PLANE*(-camera_w));  \n    vec3 ray_dir = normalize(ray_hit);\n    \n    // light setting\n    vec3 sun_light_pos = vec3(sin(iTime), 0.5 + 0.01*sin(2.0*iTime), abs(cos(0.5*iTime)));\n    vec3 sun_light_col = vec3(1.0, 0.8, 0.5);\n    vec3 sky_light_pos = vec3(0.0, 1.0, 0.0);\n    vec3 sky_light_col = vec3(0.65, 0.75, 0.9);\n    vec3 sky_light_gray = vec3(0.8, 0.8, 0.8);\n    vec3 ambient_col = vec3(0.2, 0.03, 0.15); \n    vec3 base_col1 = vec3(0.2, 0.2, 0.18);\n    vec3 base_col2 = vec3(0.09, 0.2, 0.4);\n    vec3 base_col3 = vec3(0.2, 0.4, 0.09);\n    vec3 base_col4 = vec3(0.4, 0.09, 0.2);\n    float specular_exp = 5.0;\n    \n    // coefficient \n    float diff_coef = 1.2;\n    float aimb_coef = 0.6;\n    float spec_coef = 2.0; \n    \n    // ray match\n    vec2 ray_cast_info = castRay(camera_pos, ray_dir);\n    float depth = ray_cast_info.x;\n    float material = ray_cast_info.y;\n    \n    // defualt sky color gradience\n    vec3 col = mix(sky_light_col, sky_light_gray, exp(-3.0*p.y));\n    \n    // the object is hit by the ray\n    if (depth > 0.0) \n    {\n        // get sampling point and normal\n        vec3 sample_pos = camera_pos + depth*ray_dir;\n        vec3 norm = calcNormal( sample_pos );  \n        \n        // calculate N*L\n        vec3 sun_light_dir = normalize(sun_light_pos - sample_pos);        \n        float sun_N_dot_L = clamp( dot (norm, sun_light_dir), 0.0, 1.0);\n        \n        vec3 sky_light_dir = normalize(sky_light_pos);\n        float sky_N_dot_L = clamp( dot (norm, sky_light_dir), 0.0, 1.0);\n        \n        // shadow\n        float shade = castSoftShadow(sample_pos, sun_light_dir, 70.0); \n        \n        // diffuse\n        vec3 diffuse = sun_N_dot_L*sun_light_col* shade + sky_N_dot_L*sky_light_col; \n        \n        // calculate specular R*V\n        vec3 view_dir = normalize(camera_pos - sample_pos);\n        vec3 refelct_dir = 2.0*(sun_N_dot_L)*norm - sun_light_dir;\n        float R_dot_V = clamp( dot (refelct_dir, view_dir), 0.0, 1.0);\n        vec3 specular = pow(R_dot_V, specular_exp) * sun_light_col;    \n        \n        // phong lighting equation = ambient + diffuse + spec\n    \tvec3 light_col = ambient_col * aimb_coef + diffuse * diff_coef + specular * spec_coef;\n        \n        // apply material color\n        if(material == 2.0)\n        {\n            col = base_col2* light_col;\n        }\n        else if (material == 3.0)\n        {\n            col = base_col3* light_col;\n        }\n        else if (material == 4.0)\n        {            \n        \tcol = base_col4* light_col;\n        }else\n        {\n        \tcol = base_col1* light_col;\n        }\n        \n        // gammar correction\n        col = pow(col, vec3(0.4545));        \n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//////////////////// Custom Math Functions ////////////////////////// \n// rotation matrix\nvec3 euler_rotate(in vec3 pos, in float pitch, in float roll, in float yaw)\n{\n    // rotation matrix\n    float cosa = cos(yaw);\n    float sina = sin(yaw);\n    \n    float cosb = cos(pitch);\n    float sinb = sin(pitch);\n    \n    float cosc = cos(roll);\n    float sinc = sin(roll);    \n    \n\tfloat Axx = cosa*cosb;\n    float Axy = cosa*sinb*sinc - sina*cosc;\n    float Axz = cosa*sinb*cosc + sina*sinc;\n    \n    float Ayx = sina*cosb;\n    float Ayy = sina*sinb*sinc + cosa*cosc;\n    float Ayz = sina*sinb*cosc - cosa*sinc;\n    \n    float Azx = -sinb;\n    float Azy = cosb*sinc;\n    float Azz = cosb*cosc;\n    \n    // apply rotation to pos.\n    return vec3(Axx*pos.x + Axy*pos.y + Axz*pos.z,\n    \t\t\tAyx*pos.x + Ayy*pos.y + Ayz*pos.z,\n                Azx*pos.x + Azy*pos.y + Azz*pos.z);\n}\n\n// smoooth min\nfloat smin(in float a, in float b, float k)\n{\n\tfloat h = max(k -abs(a-b), 0.0);\n    return min(a,b) - h*h/(k*4.0);    \n}","name":"Common","description":"","type":"common"}]}