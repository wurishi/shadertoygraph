{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// tribute to Escher's \"Depth\"\n// @simesgreen\n// v1.1 - fewer iterations, fixed lighting\n\n// CSG operations\nfloat _union(float a, float b)\n{\n    return min(a, b);\n}\n\nfloat _union(float a, float b, inout float m, float nm)\n{\n\tbool closer = (a < b);\n\tm = closer ? m : nm;\n\treturn closer ? a : b;\n}\n\nfloat intersect(float a, float b)\n{\n    return max(a, b);\n}\n\nfloat difference(float a, float b)\n{\n    return max(a, -b);\n}\n\n// primitive functions\n// these all return the distance to the surface from a given point\n\nfloat box(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) +\n    \t   length(max(d,0.0));\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n\n// transforms\nvec3 rotateX(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    vec3 r;\n    r.x = p.x;\n    r.y = ca*p.y - sa*p.z;\n    r.z = sa*p.y + ca*p.z;\n    return r;\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    vec3 r;\n    r.x = ca*p.x + sa*p.z;\n    r.y = p.y;\n    r.z = -sa*p.x + ca*p.z;\n    return r;\n}\n\n// distance to scene\nfloat scene(vec3 p, inout float m)\n{\n   float d;\n   m = 0.0; // material\n\n   p.z -= iTime;\n\t\n   // repeat\n   p += vec3(1.5);\n   p = mod(p, 3.0);\n   p -= vec3(1.5);\n\t\n   p.x = abs(p.x);\t// mirror in x\n\t\n   // body\n//   d = sphere(p, 1.0);\n   //d = sphere(p*vec3(4.0, 4.0, 1.0), 1.0)*0.25;\n\tfloat s = 4.0 + smoothstep(0.5, -1.0, p.z)*2.0;\t// taper\n\td = sphere(p*vec3(s, s, 1.0), 1.0) / 6.0;\n\n   // mouth\n   d = difference(d, box(p - vec3(0.0, 0.0, 1.0), vec3(0.2, 0.01, 0.2)));\n   //d = difference(d, sphere(p*vec3(1.0, 10.0, 1.0) - vec3(0.0, 0.0, 0.95), 0.15)*0.1);\n\n   // fins\n   float f;\n   f = box(p, vec3(1.2, 0.02, 0.2));\n   f = _union(f, box(p, vec3(0.02, 1.2, 0.2)));\n   f = intersect(f, sphere(p - vec3(0.0, 0.0, -1.8), 2.0));\n   f = difference(f, sphere(p - vec3(0, 0, -0.5), 0.5));\n   f = difference(f, sphere(p - vec3(1.2-0.4, 0, -0.2-0.7), 0.8));\n   //f = difference(f, sphere(p - vec3(-1.2+0.4, 0, -0.2-0.7), 0.8));\n\t\n   //d = _union(f, d);\n   d = _union(d, f, m, 3.0);\n\n   // tail\n   f = sphere(p*vec3(1.0, 1.0, 0.5) + vec3(0, 0, 0.5), 0.25);\n   f = intersect(box(p + vec3(0.0, 0.0, 1.0), vec3(0.02, 0.5, 0.5)), f);\n   f = difference(f, sphere(p*vec3(1.0, 1.0, 0.5) + vec3(0, 0, 0.75), 0.2));\n   //d = _union(d, f);\n   d = _union(d, f, m, 3.0);\n\t\n   //d = _union(d, box(p + vec3(0.0, 0.0, 1.0), vec3(0.02, 0.25, 0.25)));\n   //d = difference(d, sphere(p + vec3(0.0, 0.0, 1.25), 0.25));\n\n   // eyes\n   d = _union(d, sphere(p-vec3(0.08, 0.08, 0.85), 0.06), m, 1.0);\n   d = _union(d, sphere(p-vec3(0.1, 0.1, 0.88), 0.03), m, 2.0);\n\n   //d = _union(d, sphere(p-vec3(-0.08, 0.08, 0.85), 0.06), m, 1.0);\n   //d = _union(d, sphere(p-vec3(-0.1, 0.1, 0.88), 0.03), m, 2.0);\n\t\t\n   return d;\n}\n\n// calculate scene normal\nvec3 sceneNormal( in vec3 pos )\n{\n    float eps = 0.001;\n    vec3 n;\n\tfloat m;\n\tfloat d = scene(pos, m);\n    n.x = scene( vec3(pos.x+eps, pos.y, pos.z), m ) - d;\n    n.y = scene( vec3(pos.x, pos.y+eps, pos.z), m ) - d;\n    n.z = scene( vec3(pos.x, pos.y, pos.z+eps), m ) - d;\n    return normalize(n);\n}\n\n// ambient occlusion approximation\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 3;\n    const float delta = 0.5;\n\n    float a = 0.0;\n    float weight = 1.0;\n\tfloat m;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta;\n        a += weight*(d - scene(p + n*d, m));\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\n// smooth pulse\nfloat pulse(float a, float b, float w, float x)\n{\n    return smoothstep(a, a + w, x) - smoothstep(b - w, b, x);\n}\n\n// lighting\nvec3 shade(vec3 pos, vec3 n, vec3 eyePos, float m)\n{\n    const vec3 l = vec3(0.577, 0.577, 0.577);\n    const float shininess = 100.0;\n\n    //vec3 l = normalize(lightPos - pos);\n    vec3 v = normalize(eyePos - pos);\n    vec3 h = normalize(v + l);\n    float ndotl = dot(n, l);\n    float spec = max(0.0, pow(max(0.0, dot(n, h)), shininess)) * float(ndotl > 0.0);\n    //float diff = max(0.0, ndotl);\n    float diff = 0.5+0.5*ndotl;\n\n    float fresnel = pow(1.0 - dot(n, v), 5.0);\n    //float ao = ambientOcclusion(pos, n);\n\t\n\t//float edge = scene(pos+n*0.05) - scene(pos);\n\t//edge *= 50.0;\n\t//edge = smoothstep(0.0, 0.02, edge);\n\n    vec3 color = vec3(0.9, 0.5, 0.1);\n#if 1\n\t// lines\n\tpos.z -= iTime;\n\t\n   \tpos += vec3(1.5);\n   \tpos = mod(pos, 3.0);\n   \tpos -= vec3(1.5);\n\n  \t// stripes\n    //float sx = pulse(0.0, 0.5, 0.1, fract(pos.t*15.0));\n\tfloat sx = pulse(0.0, 0.5, 0.1, fract(atan(pos.y, pos.x)*2.0));\n\n    //float w = 0.5;\n    float w = smoothstep(0.4, -0.5, pos.y)*1.0;\n    float sz = 1.0 - pulse(0.0, w, 0.1, fract(pos.z*15.0)) * ((w > 0.1) ? 1.0 : 0.0);\n\n    //vec3 color = mix(vec3(1.0), vec3(0.9, 0.5, 0.1), sx) * sz;\n\tif (m==0.0) {\n\t\t// body\n\t\tcolor = mix(vec3(1.0), color, sx) * sz;\n\t\t//color *= sz;\t\n\t} else if (m==3.0) {\n\t\t// fins\n\t\tcolor *= pulse(0.0, 1.0, 0.1, fract(pos.x*10.0));\n\t\tcolor *= pulse(0.0, 1.0, 0.1, fract(pos.y*10.0));\n\t\tpos.z += pos.x*pos.x*0.3 + pos.y*pos.y*0.3;\n\t\tcolor *= pulse(0.0, 1.0, 0.1, fract(pos.z*10.0));\n\t}\n#else\n\n#endif\n\t// eyes\n\tif (m==1.0) {\n\t\tcolor = vec3(1.0, 1.0, 1.0);\n\t} else if (m==2.0) {\n\t\tcolor = vec3(0.0, 0.0, 0.0);\n\t}\n\t\n    //return vec3(diff*ao) * color + vec3(spec + fresnel*0.5);\n//    return vec3(diff*ao) * color + vec3(spec);\n    return vec3(diff)*color + vec3(spec + fresnel*0.5);\n//\treturn n*0.5+0.5;\n//\treturn vec3(edge);\n//  return vec3(diff);\n//  return vec3(ao);\n//  return vec3(fresnel);\n}\n\n// trace ray using sphere tracing\nvec3 trace(vec3 ro, vec3 rd, out bool hit, inout float m)\n{\n    const int maxSteps = 64;\n    const float hitThreshold = 0.01;\n\tconst float minStep = 0.0001;\n    hit = false;\n    vec3 pos = ro;\n    for(int i=0; i<maxSteps; i++)\n    {\n\t\tif (!hit) {\n\t\t\tfloat d = scene(pos, m);\n\t\t\t//d = max(d, minStep);\n\t\t\tif (d < hitThreshold) {\n\t\t\t\thit = true;\n\t\t\t\t//return pos;\n\t\t\t}\n\t\t\tpos += d*rd;\n\t\t}\n    }\n    return pos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixel = (fragCoord.xy / iResolution.xy)*2.0-1.0;\n\n    // compute ray origin and direction\n    float asp = iResolution.x / iResolution.y;\n    vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -3.0));\n    vec3 ro = vec3(0.0, 0.0, 2.5);\n\n\tfloat rx = -0.5 + (iMouse.y / iResolution.y)*3.0;\t\n\tfloat ry = 0.3 -(iMouse.x / iResolution.x)*6.0;\n\try += iTime*0.1;\n\t\n    ro = rotateX(ro, rx);\n    ro = rotateY(ro, ry);\n    rd = rotateX(rd, rx);\n    rd = rotateY(rd, ry);\n\n    // trace ray\n    bool hit;\n\tfloat m;\n    vec3 pos = trace(ro, rd, hit, m);\n\n\tconst vec3 fogColor = vec3(1.0, 1.0, 0.8);\n    vec3 rgb = fogColor;\n\tif(hit) {\n        // calc normal\n        vec3 n = sceneNormal(pos);\n        // shade\n        rgb = shade(pos, n, ro, m);\n    }\n\n \t// fog\n   \tfloat d = length(pos)*0.07;\n   \tfloat f = exp(-d*d);\n\n   \t// vignetting\n   \t//rgb *= 0.5+0.5*smoothstep(2.0, 0.5, dot(pixel, pixel));\n\t\n\t//fragColor=vec4(rgb, 1.0);\n   \tfragColor=vec4(mix(fogColor, rgb, f), 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Mdl3zn","date":"1361960898","viewed":1549,"name":"depth","username":"simesgreen","description":"Tribute to Escher's \"Depth\"","likes":48,"published":1,"flags":0,"usePreview":0,"tags":["distancefieldreproduction"],"hasliked":0,"parentid":"","parentname":""}}