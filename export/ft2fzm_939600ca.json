{"ver":"0.1","info":{"id":"ft2fzm","date":"1652088570","viewed":83,"name":"Invisible Spectra 2","username":"freemeson","description":"Extension of colors to outside the visible spectrum by adding noise. The bow is created by a doppler shift","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["spectrum","colors","hue","doppler","wavelength"],"hasliked":0,"parentid":"fd2yD3","parentname":"Invisible spectrum of colors"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 hueToRGB(float hue)\n{\n    // https://www.shadertoy.com/view/ll2cDc\n\n\treturn vec3(.5 + .5 * clamp( 1.3*cos(-0.3 + 6.28 * hue + vec3(0,0.66666*6.28, 0.3333*6.28)), -1.0, 1.0));\n//I treat (hue+1.0) to be proportional to wavelength\n//approximate colors\n//red is hue = 0.05\n//green is 0.38\n//blue is 0.71\n\n}\n\nfloat PHI = 1.61803398874989484820459;  // Î¦ = Golden Ratio   \n\nfloat gold_noise(in vec2 xy, in float seed){\n       return fract(tan(distance(xy*PHI, xy)*seed*333.0)*xy.x);\n}\n\nfloat gold_noise(in vec3 randSeed){\n       return fract(tan(distance(randSeed.xy*PHI, randSeed.xy)*randSeed.z*2323.0)*randSeed.x);\n}\n\n\nfloat dopplerShift(float hue, float factor){\n\tfloat freq = 1.0/(hue+1.0); \n\t//hue=1/freq-1\n\tfloat freqDoppl = freq*factor;\n\tfloat hueDoppl = 1.0/freqDoppl - 1.0;\n\treturn hueDoppl;\n}\n\nfloat DopplerShift(float wl, float factor){\n    return (wl+1.0)/ (factor-wl-1.0);    \n}\n\nvec3 wideSpectrum(float hue,in vec2 xy, in float seed) {\n\tif (hue<0.0) {\n\t\tvec3 red = hueToRGB(0.0);\n\t    float noise = (1.0-exp(10.0*hue))*gold_noise(vec3(xy, seed));\n\t\t\n\t\treturn exp(2.0*hue)*(red-noise*red);\n    }\n\tif (hue>0.8) {\n\t\tvec3 violet =  hueToRGB(0.8);//*exp(-0.1*(hue-0.8));\n\t\tvec3 antiViolet = hueToRGB(0.8)*(1.0-exp(-0.2*(hue-0.8)));\n\t\tfloat noise = gold_noise(vec3(xy, seed));\n\t\treturn (violet+pow(hue, 2.0)*(noise-0.5  )*vec3(0.0, 0.0, 1.0)   +1.2*(1.0 -exp(-0.14*(hue-0.8) ))*vec3(1.0))*pow(hue+0.2, 1.4) ;\n    }\n\n\n\treturn hueToRGB(hue);\n}\n\nvec3 rgbDoppler( in vec3 color, float factor ){\n    return vec3(1.0);\n}\n\nvec3 wideSpectrumOK(float hue,in vec2 xy, in float seed) {\n\tif (hue<0.0) {\n\t\tvec3 red = hueToRGB(0.0);\n\t    float noise = (1.0-exp(10.0*hue))*gold_noise(vec3(xy, seed));\n\t\t\n\t\treturn exp(2.0*hue)*(red-noise*red);\n    }\n\tif (hue>0.8) {\n\t\tvec3 violet =  hueToRGB(0.8)*exp(-0.1*(hue-0.8));\n\t\tvec3 noiseViolet = hueToRGB(0.8)*(1.0-exp(-0.2*(hue-0.8)));\n\t\tfloat noise = gold_noise(vec3(xy, seed));\n\t\treturn violet+noise*noiseViolet + 0.8*(1.0 -exp(-0.1*(hue-0.8) ))*vec3(1.0);\n    }\n\n\n\treturn hueToRGB(hue);\n}\n\nvec3 wideSpectrum2(float hue, in vec2 xy, in float seed) {\n\tif (hue<0.0) {\n\t\tvec3 red = hueToRGB(0.0);\n\t    float noise = (-hue)*gold_noise(xy, seed);\n\t\t\n\t\treturn red-noise*red;\n    }\n\tif (hue>0.8) {\n\t\tvec3 violet =  hueToRGB(0.8);\n\t\tvec3 antiViolet = 1.0 - violet;\n\t\tfloat noise = gold_noise(xy, seed);\n\t\treturn violet+(exp(-0.3*noise)*(1.0-exp(-0.2*(hue-0.8))) )*antiViolet;\n        \n    }\n\n\n\treturn hueToRGB(hue);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //frequency scan [-1e5, 1e5]\n    //vec3 col = wideSpectrum( exp(10.0*uv.x-5.0)-1.0, uv.xy, iTime );\n    //wavelength scan [0, 9]\n    //vec3 col = wideSpectrum( 10.0*uv.x-1.0, uv.xy, iTime );\n    \n    //doppler factor [1/50, 50] vs wavelength \n    vec3 col = wideSpectrum( dopplerShift(10.0*uv.x-1.0, exp(4.*(uv.y-0.5)) ), uv.xy, iTime );\n    \n    //vec3 col = wideSpectrum( dopplerShift(exp(10.0*uv.x-5.0)-1.0, exp(4.*(uv.y-0.5)) ), uv.xy, iTime );\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}