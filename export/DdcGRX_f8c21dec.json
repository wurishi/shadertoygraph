{"ver":"0.1","info":{"id":"DdcGRX","date":"1677603353","viewed":110,"name":"Sky Dome","username":"googl4","description":"approximation for indirect lighting","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sky"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* changelog:\n  2023/03/08\n    Add ground reflection and idle animation (thanks for pointing that out Fabrice)\n*/\n\n#define DEG_TO_RAD ( 1.0 / 57.296 )\n\nvec3 view_dir = normalize( vec3( 0, 0.6, 1 ) );\nfloat fov = 80.0 * DEG_TO_RAD;\n\n//vec3 sun_dir = normalize( vec3( 0.1, 0.1, 0.8 ) );\nfloat cloud_density = 0.2;\n\nvec3 sky_blue = vec3( 0.3, 0.6, 1.0 );\nvec3 sunset_orange = vec3( 1.0, 0.7, 0.4 );\n\nvec3 ground_colour = vec3( 0.02, 0.1, 0.04 );\n\nvec3 up = vec3( 0, 1, 0 );\n\nvec3 get_sky_colour( vec3 view_ray, vec3 sun_dir ) {\n    float VdotS = dot( view_ray, sun_dir );\n    float VdotU = dot( view_ray, up );\n    float SdotU = dot( sun_dir, up );\n    \n    float ground_occlusion = smoothstep( -0.05, 0.05, VdotU );\n    float sunset_factor = 1.0 - smoothstep( -0.05, 0.3, SdotU );\n    float horizon_factor = 1.0 - max( VdotU, 0.0 );\n    horizon_factor *= horizon_factor * horizon_factor;\n    float night_factor = smoothstep( -0.1, 0.1, SdotU );\n    \n    vec3 sun_col = mix( vec3( 1 ), sunset_orange, sunset_factor );\n    vec3 sky_col = mix( sky_blue, sunset_orange, sunset_factor * horizon_factor );\n    \n    vec3 cloud_col = mix( vec3( 1 ), vec3( 0.4 ), cloud_density );\n    sky_col = mix( sky_col, cloud_col, cloud_density );\n    sun_col = mix( sun_col, cloud_col, cloud_density * cloud_density );\n    \n    float night_factor2 = night_factor * night_factor;\n    \n    sun_col *= night_factor;\n    sky_col *= night_factor2;\n    ground_colour *= night_factor2;\n    \n    float VdotS_m0 = max( VdotS, 0.0 );\n    vec3 col = mix( mix( sky_col, sun_col, pow( VdotS_m0, 2.0 + sunset_factor * 2.0 ) ), ground_colour, 1.0 - ground_occlusion );\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 im = iMouse.xy;\n\n    if( iMouse.xy == vec2( 0 ) ) {\n        float t = iTime * 0.1;\n        im = ( vec2( cos( t ), sin( t ) ) * 0.5 + 0.5 ) * iResolution.xy;\n    }\n\n    float sun_elevation = \n        ( im.y / iResolution.y )\n        * ( 100.0 * DEG_TO_RAD )\n        - ( 10.0 * DEG_TO_RAD );\n    float sun_angle =\n        ( 1.0 - im.x / iResolution.x )\n        * ( 180.0 * DEG_TO_RAD )\n        - ( 90.0 * DEG_TO_RAD );\n    vec3 sun_dir = normalize( vec3( \n        sin( sun_angle ) * cos( sun_elevation ),\n        sin( sun_elevation ),\n        cos( sun_angle ) * cos( sun_elevation )\n    ) );\n\n    // calculate view ray\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    float aspect_ratio = iResolution.x / iResolution.y;\n\n    float view_uv_scale = tan( fov / 2.0 );\n    \n    vec3 view_right = cross( view_dir, up );\n    vec3 view_up = cross( view_dir, view_right );\n    \n    vec2 view_scale = vec2(\n        ( uv.x * 2.0 - 1.0 ) * view_uv_scale * aspect_ratio,\n        -( uv.y * 2.0 - 1.0 ) * view_uv_scale\n    );\n    \n    vec3 view_ray = normalize(\n        view_right * view_scale.x +\n        view_up * view_scale.y +\n        view_dir\n    );\n    \n    vec3 col = get_sky_colour( view_ray, sun_dir );\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}