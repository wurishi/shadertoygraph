{"ver":"0.1","info":{"id":"WtlGzM","date":"1555902693","viewed":133,"name":"Mandelbrot in 191chars (172 too)","username":"camilo","description":"First shader (and Mandelbrot) I write. The equation for Mandelbrot is very simple, so I thought it would be a good \"hello world\" to get a grasp of how it feels to write a shader. It is however a very crappy Mandelbrot, so I code golfed it to feel better.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbrot","codegolf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This is the first time I use ShaderToy!\n// Also first time I write an actual shader. I had touched some basic Three.js canvas code before.\n// Moreover, it's the first time I write a Mandelbrot.\n// Many firsts and what motivated me is watching Art of Code's (BigWIngs) awesome YT channel.\n// Visually it kinda sucks though, so I code golfed it as a minor redeeming quality.\nvoid mainImage(out vec4 p,vec2 c)\n{\n    vec2 r=iResolution.xy,m,u=(c/r-vec2(.6,.5))*r/r.y/.4,t;float e=1.,i;\n   \tfor(;i++<=99.;)if(length(t=vec2((m=t+u).x*m.x-m.y*m.y,2.*m.x*m.y))>2.)e=i/99.;p=vec4(e);\n}\n\n\n////////////////////// If you're curious about what each part does read on: //////////////////////\n//\n//     vec2 r=iResolution.xy,m,u=(c/r-vec2(.6,.5))*r/r.y/.4,t;\n// I declared several vec2's together to make it smaller.\n// Since I use iResolution.xy more than once, I made it a variable.\n// u (uv) is offset to the center and proportional to the viewport (so that a circle looks right)\n// t is the iteration we'll do later and m is the imaginary number we'll use.\n//\n//     float e=1.,i;\n// e is the end color. i is the iteration. Both are floats so that they're declared together.\n// \n//     for(;i++<=99.;)if(length(t=vec2((m=t+u).x*m.x-m.y*m.y,2.*m.x*m.y))>2.)e=i/99.;\n// We loop a 100 times through a recursive process of squaring a complex number + the uv coord.\n// I assign variables while using them: t=vec2((m=t+uv)...\n// Squaring the complex number is all that mathsy mess here: .x*m.x-m.y*m.y,2.*m.x*m.y\n// Here's the formula for squaring a complex number: a^2 - b^2 + 2abi\n// And here's what that would look like as a function:\n//     vec2 complexSquare(vec2 c) { return vec2(c.x*c.x-c.y*c.y,2.*c.x*c.y); }\n// So we check if after that that loop the length of the complex number is >2.\n// If so, we set the end color to a 100th of the iteration count to get there (for shading).\n\n// Extra code golfed version, 172 chars:\n// void mainImage(out vec4 p,vec2 c)\n//{\n//  vec2 r=iResolution.xy,m,u=(c/r-.5)*r/r.y/.4,t;\n//  for(float i;i++<=99.;)if(length(t=vec2((m=t+u).x*m.x-m.y*m.y,2.*m.x*m.y))>2.)p=vec4(i/66.);\n//}","name":"Image","description":"","type":"image"}]}