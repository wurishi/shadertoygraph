{"ver":"0.1","info":{"id":"McKyWc","date":"1732498556","viewed":78,"name":"hexy julia 2","username":"pb","description":"bifurcations, trifurcations, n-furcations, koch snowflake for certain param,  use the mouse maybe","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal"],"hasliked":0,"parentid":"McGcW3","parentname":"hexy julia"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define too_small 1e-4\n\nmat2 rot(float a) {\n    return mat2(cos(a),-sin(a),sin(a),cos(a));\n}\n\nfloat[] sc = float[] (1.,1.,4.,3.,2.,1.2,1.,1.);\nfloat[] mixf = float[] (1.,1.,1.,1.,1.,1.,1.,1.);\nfloat[] jp = float[] (-.07002,-1.71,-.83,-.022,-1.6,-1.5,.7,.6);\nfloat[] dum = float[] (1.,-1.,1.,-1.,1.,-1.,1.,-1.);\n\n//abs(z^3) + c yields hexagonal symmetry\n\nvoid mainImage0( out vec4 O, vec2 u )\n{\n    float tt = mod(iTime,24.);\n    int ii = int(mod(tt/3.,8.));\n\n    vec2  R =  iResolution.xy, m=iMouse.xy, z,\n          U = ( u+u - R )/ R.y * sc[ii] ,\n          M = iMouse.z>0.\n          ? vec2( 1. - iMouse.x / R.x * 3.2, 0) \n          : vec2( jp[ii], 0);\n          \n    float i = 0.;\n    \n    z=U;  //Julia set: input is each pixel coordinate\n\n    z *= rot( iTime/3. * dum[ii] );\n    \n    float inf = 1e6;\n    for ( O *= 0. ; i++ < 25. && dot(z,z) < inf; ) {\n   \n        float x2 = z.x*z.x;\n        float y2 = z.y*z.y;\n                        \n        float z3_re = x2*z.x - 3.0*z.x*y2;\n        float z3_im = -y2*z.y + 3.0*x2*z.y;\n        float z3_modsq = max(z3_re*z3_re + z3_im*z3_im, too_small);\n\n        vec2 v = vec2( z3_re, z3_im );\n        \n        z = (1.-mixf[ii])*abs(v)\n            +mixf[ii]*abs(v)/z3_modsq  \n            + M;\n                \n    }\n    \n    if (dot(z,z) < inf) {\n        //only interested in points that stay bounded\n        vec2 cc = sin( log( abs(z) ) * vec2(.26,.1) ) ;\n        cc *= cc;\n        \n        float aa = atan(z.y,z.x);\n        aa = sin(aa*.15);\n        aa *= aa;\n    \n        vec3 ccc =  vec3(1.5,.6,.3)*cc.x \n                    + vec3(.6,.5,2.)*cc.y\n                    + vec3(.6,.7,0)*aa\n                    ;\n                    \n        O = vec4(ccc,0);\n        O = O*O*(3.-2.*O);  //this makes colors more vibrant\n       \n    }\n\n\n}\n\n//FabriceNeyret2 antialiasing trick\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n        //O.b++;                        // uncomment to see where the oversampling occurs\n    }\n}\n","name":"Image","description":"","type":"image"}]}