{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float _zoom = zooming; //(iMouse.y / iResolution.y)*100.0;\n\n    vec2 pixPos = vec2(fract(fragCoord/_zoom));\n    ivec2 zoom = ivec2(fragCoord/_zoom);\n    \n    // Output to screen\n    point p = getPoint(texelFetch(iChannel0, zoom, 0));\n\n    fragColor = vec4(p.height)*vec4(0.310,0.443,0.490,0.0);\n    \n    // pixel water\n    /*\n    if (p.height > 1.0)\n    {\n        fragColor = vec4(0.275,0.384,0.427,0.0);\n    } \n    else if (p.height > 0.7)\n    {\n        fragColor = vec4(0.376,0.541,0.604,0.0);\n    }   \n    else if (p.height > 0.1)\n    {\n        fragColor = vec4(0.404,0.592,0.659,0.0);\n    }\n    else\n    {\n        fragColor = vec4(0.0);\n    }\n    */\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"// from paint streams\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define sizer 256.0\n// set to 256 width\n#define zooming iResolution.x/sizer\n//#define zooming 1.0\n\n// from paint\n#define fluid_rho 0.5\nfloat Pf(float rho)\n{\n    return 0.05*rho*(rho/fluid_rho - 3.0);\n}\n\nfloat G(vec2 x)\n{\n    float norm_squared = dot(x, x);\n    float result = 0.0;\n    float radius_squared = 1.5; // assuming a unit radius for the kernel\n    if (norm_squared < radius_squared)\n    {\n        result = 1.0 - norm_squared / radius_squared;\n    }\n    return mix(result, exp(-dot(x,x)), 0.65);\n}\n\n// Dave's hash function\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Created by nilrem\nhighp uint packUnorm(mediump uvec4 a) {\n    return uint( (a.x << 24)\n               | (a.y << 16)\n               | (a.z << 8 )\n               | (a.w << 0 ) ); }\nmediump uvec4 unpackUnorm(highp uint a) {\n    return uvec4( (a & 0xFF000000u) >> 24\n                , (a & 0x00FF0000u) >> 16\n                , (a & 0x0000FF00u) >> 8\n                , (a & 0x000000FFu) >> 0   ); }\nfloat packUnorm(  vec4  a) { return uintBitsToFloat(packUnorm(uvec4(round(clamp(a, 0., 1.)*255.)))); }\nvec4  unpackUnorm(float a) { return vec4(unpackUnorm(floatBitsToUint(a))) / 255.; }\nfloat packSnorm(  vec4  a) { return uintBitsToFloat(packUnorm(uvec4(round(clamp(a, -1., 1.)*127.5+127.5)))); }\nvec4  unpackSnorm(float a) { return clamp((vec4(unpackUnorm(floatBitsToUint(a))) - 127.5) / 127.5, -1., 1.); }\n\n// this is contains the graph for the particals\nstruct point\n{\n    float height;\n    vec2 velocity;\n    vec2 position;\n};\n\npoint getPoint(vec4 info)\n{\n    point p;\n    p.height = info.r;\n    p.velocity = unpackSnorm(info.g).xy;\n    //p.position = vec2(0.0);\n    p.position = unpackUnorm(info.b).xy;\n    \n    return p;\n}\n\nvec4 savePoint(point p)\n{\n    vec4 info;\n    \n    info.r = p.height;\n    info.g = packSnorm(vec4(p.velocity, 0.0, 0.0));\n    info.b = packUnorm(vec4(p.position, 0.0, 0.0));\n    \n    return info;\n}\n\nfloat getNext(vec2 dx, vec2 pos, point p, float s)\n{\n    // get height contribution with no slope\n    vec2 dif = -dx;\n    \n    // make sure that the function does not fall out of bounds\n    vec2 n = min(abs(dif), 1.0);\n    \n    vec2 then = (2.0 * n - 3.0) * n * n + 1.0;\n    \n    float height = then.x*then.y*p.height;\n    \n    // boundries\n    float numCells = 9.0;\n    \n    // need to fix these because they dont always work\n    \n    // corner case\n    if (pos.y == 10.0 && (pos.x == 10.0 || pos.x == sizer - 10.0))\n        numCells = 4.0;\n    // edge case\n    else if (pos.y == 10.0 || pos.x == 10.0 || pos.x == sizer - 10.0)\n        numCells = 6.0;\n    else if (pos.y < 10.0 || pos.x < 10.0 || pos.x > sizer - 10.0)\n        return 0.0;\n    \n    return mix(height, p.height / numCells, s);\n}","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 pos = ivec2(fragCoord.xy);\n    \n    point p;\n    p.height = 0.0;\n    p.velocity = vec2(0.0);\n    \n    point pCenter = getPoint(texelFetch(iChannel0, pos, 0));\n    \n    vec2 prePos = p.position;\n    \n    // for calculating the forces\n    vec2 F = vec2(0.0);\n    vec3 avgV = vec3(0.0);\n    \n    float nextPoint = 0.0;\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        ivec2 tpos = pos + ivec2(i, j);\n        \n        point p_ = getPoint(texelFetch(iChannel0, tpos, 0));\n        \n        // smoothing amount\n        // subtract by an amount here! Important makes the fluid more particlly   \n        float s = clamp((p_.height)/6.0, 0.0, 0.8);\n        \n         vec2 dx = (vec2(pos) + p.position) - (vec2(tpos) + p_.position + p_.velocity);\n        \n        // pos one is the new center point pos\n        // pos two is the point that will add to this one\n        nextPoint = getNext(dx, vec2(pos), p_, s);\n        \n        // multipy new velocity by the mass that each cell contribues\n        p.height += nextPoint;\n        p.velocity += p_.velocity * nextPoint;\n        p.position += p_.position * nextPoint;\n        \n        // now calculate forces on fluid        \n        float avgP = 0.5*p_.height*(Pf(pCenter.height) + Pf(p_.height));\n        float Gdx = G(dx);\n        F -= 0.5*Gdx*avgP*dx;\n        avgV += p_.height*Gdx*vec3(p_.velocity,1.);\n    }\n    \n    // normalize the velocity baced on mass\n    if (p.height > 0.0)\n    {\n        p.velocity = p.velocity / p.height;\n        p.position = p.position / p.height;\n    }\n    \n    avgV.xy /= avgV.z*2.0;\n\n    //viscosity\n    F -= 0.0*p.height*(avgV.xy - p.velocity);\n    \n    // force from mouse\n    if (distance(fragCoord, vec2(iMouse.xy/(zooming))) < 20.0 && iMouse.z > 1.0 || (iMouse.x < 0.1 && distance(fragCoord, vec2(iResolution.xy/2.0/(zooming))) < 20.0))\n    {\n        vec2 newF = (fragCoord - vec2(iMouse.xy/(zooming))) / 1000.0;\n        \n        F.x += -newF.y + newF.x/1.0;\n        F.y += newF.x + newF.y/1.0;\n        \n        p.height += 0.01;\n    }\n    \n    p.velocity -= (F/p.height) * 2.0 + vec2(0.0, 0.005);\n    \n    p.velocity += (hash22(fragCoord + iTime) - 0.5) / 8.0;\n    \n    // make sure that the velocity does not exceed the limit\n    p.velocity = clamp(p.velocity, -2.0, 2.0); // sometimes it is infinite\n    float vel = length(p.velocity);\n    p.velocity /= (vel > 1.0)?vel:1.0;\n    \n    // hard\n    if (pos.y <= 10)\n    {\n        p.velocity.y = 0.0;\n    }\n\n    if (pos.x <= 10)\n    {\n        p.velocity.x = 0.0;\n    }\n    \n    if (pos.x >= int(sizer) - 10)\n    {\n        p.velocity.x = 0.0;\n    }\n    \n    fragColor = savePoint(p);\n}","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"4XyGWD","date":"1734303301","viewed":63,"name":"W/ Position data","username":"capslpop","description":"Another old one that I am making public.","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["hermite"],"hasliked":0,"parentid":"XcVXRt","parentname":"Fork Fluid Sim #1"}}