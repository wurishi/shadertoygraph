{"ver":"0.1","info":{"id":"tdcSWN","date":"1571968759","viewed":251,"name":"FVM - Smooth Union","username":"dfactor","description":"Another try of Functional Voxel Modeling with MSAA","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf","csg","normal","fvm","mdi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Old variant\n/*float circle(vec2 uv, vec2 center, float radius) {\n    return (uv.x-center.x)*(uv.x-center.x) + (uv.y-center.y)*(uv.y-center.y) - radius*radius;\n}*/\n\nfloat circle(vec2 uv, vec2 center, float radius) {\n    return length(uv-center)*length(uv-center) - radius*radius;\n}\n\nfloat line(vec2 uv, vec2 a, vec2 b) {\n    return ((b.y-a.y)*uv.x + (a.x-b.x)*uv.y + (b.x*a.y-a.x*b.y))/sqrt((b.x-a.x)*(b.x-a.x)+(b.y-a.y)*(b.y-a.y));\n}\n\nfloat sum(float a, float b, float alpha) {\n    return (a+b+sqrt(a*a + b*b - 2.0*alpha*a*b))*(1.0/(1.0+alpha));\n}\n\nfloat mul(float a, float b, float alpha) {\n    return (a+b-sqrt(a*a + b*b - 2.0*alpha*a*b))*(1.0/(1.0+alpha));\n}\n\n// Smooth multiply\n// https://iquilezles.org/articles/smin\nfloat sminCubic( float a, float b, float k ) {\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n// Our FV model\nfloat map(vec2 uv, float alpha) {\n    vec2 pos1 = vec2(-cos(iTime*1.5)/1.5, -sin(iTime*1.5)/1.5);\n    vec2 pos2 = vec2(sin(iTime)/3.0, cos(iTime)/3.0);\n    vec2 pos3 = vec2(0.0, -sin(iTime*2.0)/6.0);\n    \n    /*return mul(\n        circle(uv, vec2(0.,0.), 0.3),\n        mul(\n            circle(uv, pos1, 0.3),\n            circle(uv, pos2, 0.3),\n            alpha),\n        alpha\n    );*/\n    \n    return sminCubic(\n    \tcircle(uv, vec2(0.,0.), 0.3),\n        sminCubic(\n            circle(uv, pos1, 0.3),\n            circle(uv, pos2, 0.3),\n            0.2\n        ),\n        0.2\n    );\n}\n\n// Faster MDI\nvec4 mdi_v2(vec2 uv1, vec2 uv2, vec2 uv3, float value1, float value2, float value3) {\n    vec2 a2 = uv3 - uv1;\n    vec2 b2 = uv2 - uv1;\n    \n    vec3 a3 = vec3(a2.x, a2.y, value1-value3);\n    vec3 b3 = vec3(b2.x, b2.y, value2-value1);\n    \n    vec3 Nxyz = cross(a3, b3);\n    \n    float D = uv1.x*(uv2.y*value3-uv3.y*value2)-uv2.x*(uv1.y*value3-uv3.y*value1)+uv3.x*(uv1.y*value2-uv2.y*value1);\n    \n    vec4 N = normalize(vec4(Nxyz, D));\n    \n    int flag1 = 0;\n    int flag2 = 0;\n    int flag3 = 0;\n    if (value1>=0.0) flag1 = 1;\n    if (value2>=0.0) flag2 = 1;\n    if (value3>=0.0) flag3 = 1;\n    \n    int flag_sum = flag1 + flag2 + flag3;\n    if (flag_sum < 2) return (N + vec4(1.,1.,1.,1.)) / 2.; //fit to [0;1]\n    return vec4(0.5, 0.5, 1.0, 0.0); //+Z normal\n}\n\nvec4 calcImage(vec2 uv, float alpha) {\n    vec2 uv1 = uv;\n    vec2 uv2 = vec2(uv.x, uv.y+0.005);\n    vec2 uv3 = vec2(uv.x+0.005, uv.y);\n    \n    float value1 = map(uv1, alpha);\n    float value2 = map(uv2, alpha);\n    float value3 = map(uv3, alpha);\n    \n    return mdi_v2(uv1, uv2, uv3, value1, value2, value3);\n}\n\nvec4 render(vec2 uv, float alpha) {\n    float offset = iResolution.x / iResolution.y / 512.0;\n    \n    return (\n        calcImage(uv-offset*vec2(-0.5,-0.5), alpha) +\n        calcImage(uv-offset*vec2(-0.5,0.5), alpha) +\n        calcImage(uv-offset*vec2(0.5,-0.5), alpha) +\n        calcImage(uv-offset*vec2(0.5,0.5), alpha)\n    )/4.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 vUV = fragCoord.xy / iResolution.xy;\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x / iResolution.y;\n\n    vec4 value = render(vWindow, 0.0);\n    vec3 col = vec3(value.x, value.y, value.z);\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}