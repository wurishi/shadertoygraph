{"ver":"0.1","info":{"id":"XcGcR3","date":"1732159322","viewed":174,"name":"Planet Trace","username":"Rugged","description":"Planet trace.","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["ray","planet","atmosphere","trace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 tileSample(vec2 uv){\n    vec2 right = vec2(.5, 0.);\n    vec2 up = vec2(.0, .5);\n    vec4 c0 = texture(iChannel0, uv);\n    vec4 c1 = texture(iChannel0, uv + right);\n    vec4 c2 = texture(iChannel0, uv - right);\n    vec4 c3 = texture(iChannel0, uv + up);\n    vec4 c4 = texture(iChannel0, uv - up);\n    \n    \n    \n    return .2 * (c0 + c1 + c2 + c3 + c4);\n}\n\n\n\nvec4 sampleSurface(vec3 p){\n    \n    vec4 col = texture(iChannel1, (CartToSph(p).yz / 6.28) + pi / 4.);\n    \n    vec3 brownColor = vec3(0.8, 0.5, 0.5);\n    float bcL2 = dot(brownColor, brownColor);\n    \n    float a = 1. - (bcL2 - dot(col.rgb, brownColor));\n    a = clamp(0., 1., a);\n    a *= a * a * a;\n    //a = max(floor(a + .1), 0.);\n    \n    vec4 groundColor = vec4(0.502, .4, .18, 1.);\n    vec4 oceanColor = vec4(0.0, 0.2, 0.49, 1.) * .3;\n    \n    col = mix(oceanColor, groundColor, a);\n    \n    return col;\n    \n}\n\nfloat sampleClouds(vec3 p){\n    \n    vec2 angs = CartToSph(p).yz / (1. * pi);\n    \n    \n    float a = tileSample(angs + vec2(iTime * .001, 0.)).r;\n    \n    a -= .1;\n    a = max(a, 0.);\n    \n    return a * a;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 prop = iResolution.xy / iResolution.x;\n    vec2 uvc = prop * (2. * (uv - 0.5));\n    vec2 uvcHat = normalize(uvc);\n    \n    vec4 col = vec4(0.);\n    \n    \n    \n    float oneThird = 1. / 3.;\n    float root3 = sqrt(3.);\n    vec3 rayD = vec3(sqrt(1. - (oneThird * dot(uvc, uvc))), uvc.x / root3, uvc.y / root3);\n    \n    \n    float phi = .3 * (iTime + 10.);\n    phi -= halfPi;\n    float theta = .5 * (iTime + 10.);\n    \n    //phi = 1.5 * pi;\n    //theta = 0.;\n    theta = .4 * sin(theta);\n    \n    float camCL = -3. * (.2 * sin(iTime * .5) + 1.);\n    vec3 camC = camCL * vec3(1., 0., 0.);\n    vec3 camForward = vec3(1., 0., 0.);\n    vec3 camUp = vec3(0., 0., 1.);\n    vec3 camRight = vec3(0., -1., 0.);\n    \n    \n    \n    rayD = rotate3D(rayD, phi, theta);\n    \n    camC = rotate3D(camC, phi, theta);\n    camUp = rotate3D(camUp, phi, theta);\n    camRight = rotate3D(camRight, phi, theta);\n    camForward = rotate3D(camForward, phi, theta);\n    \n    \n    vec3 lightDir = normalize(vec3(1., 0., 0.));\n    vec3 p = camC;\n    \n    vec3 pHat = vec3(0.);\n    float shadow = 0.;\n    float atmoShadow = 0.;\n    float lightDot = 0.;\n    float lightDotScaled = 0.;\n    \n    float l = 0.;\n    float l2 = 0.;\n    \n    float delta = 1. / 80.;\n    \n    //cloud colors\n    vec4 atC1 = vec4(.6, .7, 1., 1.);\n    vec4 atC2 = vec4(.85, .5, .1, 1.);\n    float colorFactor;\n    \n    //float cloudAmount = 0.;\n    //vec4 deltaClouds = vec4(0.);\n    \n    //star stuff\n    float starL2;\n    vec3 starC = 10. * -lightDir;\n    vec3 toStar;\n    vec3 toStarHat;\n    \n    \n    vec3 starD = inverseRotate3D(normalize(starC - camC), phi, theta);\n    vec2 starScreenLoc = vec2(root3 * starD.y, root3 * starD.z);//1.57 * vec2(-dot(starCamSpace, camRight), dot(starCamSpace, camUp)) / dot(starCamSpace, camForward);\n    vec2 starScreenLocHat = normalize(starScreenLoc);\n    \n    vec2 starToUVC = uvc - starScreenLoc;\n    float starToUVCL2 = dot(starToUVC, starToUVC);\n    vec2 starToUVCHat = starToUVC / sqrt(starToUVCL2);\n    \n    float flareAngle = atan(uvc.y, uvc.x);\n    \n    float flareAngularValue = hillFunction(starToUVCHat.y / starToUVCHat.x, 0.5, 50.);\n    float flareRadialValue = hillFunction(length((2. * uvc) - starScreenLoc), 0.4, 500.)\n                            +hillFunction(length((1.5 * uvc) - starScreenLoc), 0.2, 500.)\n                            +hillFunction(length((1.1 * uvc) - starScreenLoc), 0.05, 500.);\n    float flareValue = flareRadialValue + flareAngularValue;\n    \n    vec4 surfaceColor = vec4(0.);\n    \n    \n    for(int i = 0; i < 1000; i++){\n        \n        p += rayD * (0.01 + (.01 * hash3(p.xy)));\n        \n        l2 = dot(p, p) + .00001;\n        l = sqrt(l2);\n        \n        pHat = p / l;\n        \n        lightDotScaled = dot(p, -lightDir) - .05;\n        lightDot = lightDotScaled / l;\n        \n        shadow = max(lightDot, 0.);\n        \n        \n        atmoShadow = ((.7 - abs(lightDotScaled)) / l) + (max(lightDot, -.5) / (l2));\n        atmoShadow /= max((p.z * p.z + .4), 1.);\n        \n        \n        //add atmosphere\n        colorFactor = pow(max(atmoShadow - .0, 0.), .5);\n        col += atmoShadow * delta * mix(atC2, atC1, colorFactor) * NegativeScatteringPotential(l, .9, 5000.) * 250.;//AtmosphereDensity(l, .93, 50.);\n        \n        if(l < .91){\n            //deltaClouds = sampleClouds(p) * mix(atC2, vec4(1.), colorFactor) * atmoShadow * 1.;\n            //cloudAmount += length(deltaClouds);\n            col += sampleClouds(p) * mix(atC2, vec4(1.), colorFactor) * atmoShadow * 1.5;\n            \n        }\n        \n        if(l < 0.9){\n            surfaceColor = sampleSurface(p);\n            col += surfaceColor * shadow;// * (1. - min(cloudAmount, 1.));\n            break;\n        }\n        \n        toStar = starC - p;\n        starL2 = dot(toStar, toStar);\n        toStarHat = toStar / sqrt(starL2);\n        \n        \n        //star \n        col += .0005 / (starL2);\n        \n        \n        \n        \n    }\n    \n    vec3 camToStarHat = normalize(starC - camC);\n    \n    //check if star is behind planet\n    float planetRayL2 = pointRayDist(camToStarHat, camC, vec3(0.));\n    planetRayL2 = max(sign(planetRayL2 - (.9 * .9)), 0.);\n    \n    //star flare\n    col += .1 * flareValue * max(dot(camForward, camToStarHat), 0.) * planetRayL2;\n    \n    \n    \n    \n    //reflection\n    vec3 reflection = normalize(camForward - (2. * (pHat * dot(pHat, camForward))));\n    float rValue = min(dot(reflection, -lightDir), 1.);\n    float waterProminence = (surfaceColor.b / surfaceColor.g);\n    \n    if(l2 < 1.1 && rValue > .0){\n        col += max((waterProminence * .06) * hillFunction(rValue, 1., 40.), 0.);\n    }\n    \n    \n    \n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define pi 3.1415926535897932\n#define halfPi 1.57079632679\n\nfloat hash3(vec2 xy){\n    xy = mod(xy, .19);\n    float h = dot(xy.yyx,vec3(.013, 27.15, 2027.3));\n    h *= h;\n    h *= fract(h);\n    \n    return fract(h);\n}\n\n\nvec2 rotate(vec2 v, float theta){\n    mat2 rot;\n    rot[0] = vec2(cos(theta), -sin(theta));\n    rot[1] = vec2(sin(theta), cos(theta));\n    \n    \n    return rot * v;\n}\n\nvec3 rotate3D(vec3 v, float phi, float theta){\n    mat3 rot = mat3(\n        vec3( cos(phi)*cos(theta), -sin(phi), cos(phi)*sin(theta)),\n        vec3( sin(phi)*cos(theta), cos(phi), sin(phi)*sin(theta)),\n        vec3( -sin(theta), 0., cos(theta))\n    );\n    \n    \n    return rot * v;\n}\nvec3 inverseRotate3D(vec3 v, float phi, float theta){\n    mat3 rot = mat3(\n        vec3( cos(phi)*cos(theta), -sin(phi), cos(phi)*sin(theta)),\n        vec3( sin(phi)*cos(theta), cos(phi), sin(phi)*sin(theta)),\n        vec3( -sin(theta), 0., cos(theta))\n    );\n    \n    mat3 inv = inverse(rot);\n    \n    return inv * v;\n}\n\nfloat cloudNoise1(vec2 frag, float scale){\n    \n    frag *= scale;\n    \n    frag = floor(frag);\n    \n    frag += 1000.0f;\n    \n    vec2 frag2 = rotate(frag, frag.y);\n    vec2 frag3 = rotate(frag, frag.x);    \n    \n    \n    \n    return fract(frag2.y - frag3.x);// * frag2.y;\n}\n\n\nvec3 CartToSph(vec3 c){\n    float r = length(c);\n    return vec3(r, atan(c.y, c.x), acos(c.z / r));\n}\n\n\nfloat AtmosphereDensity(float r, float R, float a){\n    float x = r - R;\n    return 1. / (1. + (a * (x * x)));\n}\n\n//this is the negative potential function if you consider \n// the AtmosphereDensity as a field strength\n//The negative of the potential function is proportional to the\n// energy at a point, or in this case, the amount of light scattered\nfloat NegativeScatteringPotential(float r, float R, float a){\n    float r1 = r - R;\n    float roota = sqrt(a);\n    return (1. / (roota)) * (halfPi - atan(r1 * roota));\n    \n}\n\n\nfloat pointRayDist(vec3 rayD, vec3 rayO, vec3 p){\n    vec3 toP = p - rayO;\n    \n    \n    float d = dot(rayD, toP);\n    \n    float l2 = dot(toP, toP) - (d * d);\n    \n    return l2;\n}\n\nfloat hillFunction(float x, float x0, float a){\n    float r = x - x0;\n    return 1. / (1. + (a * (r * r)));\n}","name":"Common","description":"","type":"common"}]}