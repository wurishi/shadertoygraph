{"ver":"0.1","info":{"id":"XctGW7","date":"1713054635","viewed":37,"name":"again mandelbrot ( but a blob )","username":"Bestenfalls","description":"lot to do here, but later... play the iMouse","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test","mandelbrot","fraktal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ITERATIONS 12 // Number of iterations for fractal calculation\n#define ZOOM_SPEED 0.01 // Speed of zooming\n\n// Function to map distance value to a colorful gradient\nvec3 getColor(float dist) {\n    vec3 color;\n\n    // Define colors\n    vec3 color1 = vec3(0.0, 0.0, 0.5); // Dark Blue\n    vec3 color2 = vec3(0.0, 0.5, 1.0); // Light Blue\n    vec3 color3 = vec3(0.0, 0.8, 0.0); // Green\n    vec3 color4 = vec3(1.0, 0.8, 0.0); // Yellow\n    vec3 color5 = vec3(1.0, 0.0, 0.0); // Red\n\n    // Interpolate between colors based on distance value\n    if (dist < 0.2) {\n        color = mix(color1, color2, smoothstep(0.0, 0.2, dist * 5.0));\n    } else if (dist < 0.4) {\n        color = mix(color2, color3, smoothstep(0.2, 0.4, (dist - 0.2) * 5.0));\n    } else if (dist < 0.6) {\n        color = mix(color3, color4, smoothstep(0.4, 0.6, (dist - 0.4) * 5.0));\n    } else if (dist < 0.8) {\n        color = mix(color4, color5, smoothstep(0.6, 0.8, (dist - 0.6) * 5.0));\n    } else {\n        color = color5;\n    }\n\n    return color;\n}\n\n\nvec3 rotate(vec3 p, vec2 r) {\n    float s1 = sin(r.x);\n    float c1 = cos(r.x);\n    float s2 = sin(r.y);\n    float c2 = cos(r.y);\n\n    p.yz = vec2(p.y * c1 - p.z * s1, p.z * c1 + p.y * s1);\n    p.xz = vec2(p.x * c2 - p.z * s2, p.z * c2 + p.x * s2);\n\n    return p;\n}\n\nfloat mandelbulb(vec3 z, float power) {\n    float dr = 1.0;\n    float r = 0.0;\n\n    for (int i = 0; i < ITERATIONS; i++) {\n        r = length(z);\n        if (r > 8.0) break;\n\n        float theta = acos(z.z / r);\n        float phi = atan(z.y, z.x);\n        dr = pow(r, power - 1.0) * power * dr + 1.0;\n\n        float zr = pow(r, power);\n        theta = theta * power;\n        phi = phi * power;\n\n        z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n        z += vec3(0.5, 0.5, -1.0);\n    }\n\n    return 0.5 * log(r) * r / dr;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Interactive controls for zoom, rotation, and variation\n    float zoom = 1.0 + iMouse.z * ZOOM_SPEED;\n    vec2 rotation = vec2(iMouse.x / iResolution.x * 6.2831, iMouse.y / iResolution.y * 3.1415);\n    float variation = 8.0 + iMouse.w / iResolution.y * 16.0;\n\n    vec3 camera = vec3(0.0, 0.0, 3.0 / zoom);\n    vec3 target = vec3(0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 forward = normalize(target - camera);\n    vec3 right = normalize(cross(forward, up));\n\n    vec3 ro = rotate(camera, rotation);\n    vec3 rd = normalize(rotate(vec3(uv - 0.5, 1.0), rotation));\n\n    float dist = 0.0;\n    vec3 pos = ro;\n\n    for (int i = 0; i < 128; i++) {\n        dist = mandelbulb(pos, variation);\n        pos += dist * rd;\n    }\n\n    // Get fractal color from distance value\n    vec3 fractalColor = getColor(dist);\n\n    // Calculate motion effect for the background\n    float motionX = sin(iTime * 0.5) * 0.1; // Adjust speed and intensity as needed\n    float motionY = cos(iTime * 0.5) * 0.1; // Adjust speed and intensity as needed\n\n    // Offset UV coordinates based on motion effect\n    vec2 backgroundUV = uv + vec2(motionX, motionY);\n\n    // Sample background color using offset UV coordinates\n    vec3 backgroundColor = texture(iChannel0, backgroundUV).rgb;\n\n    // Blend fractal color with background color\n    vec3 finalColor = mix(fractalColor, backgroundColor, 0.5); // Adjust blend factor as needed\n\n    // Output final color\n    fragColor = vec4(finalColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}