{"ver":"0.1","info":{"id":"tl3yWf","date":"1610011952","viewed":121,"name":"Glassball","username":"denosya","description":"reflect, refract, fresnel, glass","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["codingdojo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float GLASS = 1.5;\nconst float WATER = 1.33;\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n};\n\nvec3 animate(vec3 ray);\nbool intersectSphere(in vec3 origin, in vec3 ray, in Sphere sphere, out vec3 col1, out vec3 col2);\n\n\n///////////////////////////////\n// your work here \n///////////////////////////////\nvec4 render(in Sphere sphere, in vec3 p, in vec3 origin, in vec3 ray, in vec3 lightSource) {\n\n    vec3 normal = normalize(p - sphere.center);\n    vec3 reflection = reflect(ray, normal);\n    vec4 reflection_pixel = texture(iChannel0, animate(reflection));\n    \n    vec3 refraction = refract(ray, normal, 1.0/GLASS);\n    \n    vec3 p2 = p + 2.0 * refraction * dot(sphere.center - p, refraction);\n    vec3 normal2 = normalize(sphere.center - p2);\n\tvec3 ray2 = refract(refraction, normal2, GLASS);                  \n    \n    vec4 refraction_pixel = texture(iChannel0, animate(ray2));    \n    \n    float fresnel = -dot(ray, normal);\n    \n    return mix(reflection_pixel, refraction_pixel, fresnel);\n}\n\n\n///////////////////////////////\n// do not modifiy under this\n///////////////////////////////\nbool intersectSphere(in vec3 origin, in vec3 ray, in Sphere sphere, out vec3 col1, out vec3 col2) {\n\n    vec3 p1 = origin + ray * dot(ray, sphere.center - origin);\n\n    float H = length(p1-sphere.center);    \n    float h = sqrt(sphere.radius*sphere.radius - H*H);\n    \n    col1 = p1 - ray * h;\n    col2 = p1 + ray * h;    \n    \n    return H<sphere.radius;\n}\n\nvec3 animate(vec3 ray) {\n\n    float c = cos(iTime*0.1);\n    float s = sin(iTime*0.1);\n\n    mat3 rotation = mat3(vec3(c, 0.0, s), vec3(0.0, 1.0, 0.0), vec3(-s, 0.0, c));\n\n    return ray * rotation;\n}\n\nvec4 run(in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord / iResolution.xy) - 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 eye = vec3(0);\n    vec3 ray = normalize(vec3(uv, 1.0));    \n    vec3 light = vec3(5.0*cos(iTime*0.5), 3.0, 0.0);\n    vec3 p1, p2;\n\n    Sphere sphere = Sphere(vec3(0.0, 0.0, 8.0), 2.0);\n    \n    if(intersectSphere(eye, ray, sphere, p1, p2)) {\n        return render(sphere, p1, eye, ray, light);\n    }\n    else {\n        return texture(iChannel0, animate(ray));\n    }\n}\n    \n#define SUPERSAMPLING\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    \n    #ifdef SUPERSAMPLING\n    // 3x3 supersampling\n    for(float dx=-0.5; dx<=0.5; dx+=0.5) {\n    \tfor(float dy=-0.5; dy<=0.5; dy+=0.5) {\n            fragColor += run(fragCoord + vec2(dx, dy));\n        }\n    }\n    \n    fragColor /= 9.0;\n    \n    #else\n    fragColor = run(fragCoord);\n    #endif\n} \n    \n\n    \n    \n","name":"Image","description":"","type":"image"}]}