{"ver":"0.1","info":{"id":"4cffzr","date":"1723217586","viewed":102,"name":"SmoothStepLife","username":"chronos","description":"Smoothlife, but using just smoothstep for sigmoid, step and ramp functions.","likes":17,"published":1,"flags":48,"usePreview":0,"tags":["game","automata","life","cellular","smoothstep","smooth","ca","of","automaton","smoothlife","gol","smoothlifel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    SmoothStepLife by chronos\n    ---------------------------------------------------------------------------\n    \n    Smoothlife, but using just smoothstep for sigmoid, step and ramp functions.\n    \n    See also my previous smoothlife shaders\n\n    Smoothlife(L): https://www.shadertoy.com/view/XtdSDn\n    WaveLife: https://www.shadertoy.com/view/XlsfRX\n    PulseLife: https://www.shadertoy.com/view/XlfBRs\n\n    ---------------------------------------------------------------------------\n    self link: https://www.shadertoy.com/view/4cffzr\n    ---------------------------------------------------------------------------\n*/\n\n\nconst float slide_speed = 0.025;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv+iTime*slide_speed).rrr;\n    \n    // Inspect transition function by holding spacebar\n    if(texture(iChannel3, vec2(32./256., 0)).r > 0.5)\n    {\n        col*= 0.1;  col += transition(uv.x, uv.y);\n        col.rg+=smoothstep(0.95, 1., fract(uv.xy*12.));\n    }\n    \n    fragColor = vec4(pow(col, vec3(1./2.2)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float transition(float inner, float outer)\n{\n    // Birth range\n    float b0 = 6./24.;\n    float b1 = 8./24.;\n\n    // Survival range\n    float s0 = 9./24.;\n    float s1 = 13./24.;\n    \n    // smoothstep half-widths\n    float db = 1./70.;\n    float ds = 1./27.;\n\n    float b = smoothstep(b0-db, b0+db, inner) * smoothstep(b1+db, b1-db, inner);\n    float s = smoothstep(s0-ds, s0+ds, inner) * smoothstep(s1+ds, s1-ds, inner);\n        \n    return mix(b,s, smoothstep(0.425, 0.575, outer));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nconst float PI = 3.14159265;\n\nconst float outer_radius = 9.;\nconst float inner_radius = 3.;\n\nconst float inner_area = PI * inner_radius * inner_radius;\nconst float outer_area = PI * outer_radius * outer_radius - inner_area;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    \n    if(iFrame == 0)\n    {\n        float hash = fract(31415.9265 * sin(dot(fragCoord.xy, vec2(1.61803398875, 31.14159265))));\n        fragColor.r = pow(hash, .75)\n            * smoothstep(0., 100., length(fragCoord-iResolution.xy/2.))\n            * smoothstep(1000., 100., length(fragCoord-iResolution.xy/2.))\n            ;\n        return;\n    }\n\n    float outer = 0.;\n    float inner = 0.;\n    \n    const int N = 10;\n    for(int i = -N; i <= N; i++)\n    for(int j = -N; j <= N; j++)\n    {\n        vec2 ij = vec2(i,j);\n        vec4 bufA = texelFetch(iChannel0, ivec2(mod(fragCoord+ij +iResolution.xy, iResolution.xy)), 0);\n        \n        float d = length(ij);\n        \n        float inner_weight = smoothstep(inner_radius + .75, inner_radius - .75, d);\n        float outer_weight = smoothstep(outer_radius + .75, outer_radius - .75, d) * (1.-inner_weight);\n        \n        outer += bufA.r * outer_weight;\n        inner += bufA.r * inner_weight;\n    }\n    \n    inner /= inner_area;\n    outer /= outer_area;\n    \n    float dt = 0.3;\n    \n    vec4 bufA = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    float prev_state = bufA.r;\n    float new_state = prev_state + dt * (2. * transition(outer, inner) - 1.);\n        \n    new_state = clamp(new_state, 0., 1.);\n    \n    fragColor.r = new_state;\n}","name":"Buffer A","description":"","type":"buffer"}]}