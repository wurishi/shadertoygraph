{"ver":"0.1","info":{"id":"DslXzS","date":"1669132401","viewed":102,"name":"Mandelbrot + Julia sets shader","username":"17gcook","description":"Cool Shape","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["complexiteration"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define sectionDiv 1\n\nivec2 getVectorSection(vec2 fragCoord){\n    return ivec2(fragCoord/(iResolution.xy/float(sectionDiv)));\n}\n\nivec2 getVectorSection(int time){\n    return ivec2(time % sectionDiv, (time % (sectionDiv*sectionDiv))/sectionDiv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n   float scale = 1.0/pow(1.5, texelFetch(iChannel0, ivec2(2,0),0).x/4.0);\n   float offset = 0.0;\n   \n   //fragColor = vec4(0.0,0.0,0.0,0.0);\n       \n   vec2 centre = vec2(texelFetch(iChannel0, ivec2(0,0),0).x,texelFetch(iChannel0, ivec2(1,0),0).x);\n   \n   /*for( float m=0.0; m<1.0; m+=1.0/float(AA) )\n   for( float n=0.0; n<1.0; n+=1.0/float(AA) )\n   {\n       vec2 uv = ((fragCoord.xy + vec2(n, m))/iResolution.xy)*2.0 - 1.0;\n\n       float aspectRatio = iResolution.y / iResolution.x;\n       uv.y = aspectRatio * uv.y;\n\n       uv *= (scale*4.0);\n       uv += centre;\n       \n       fragColor += getColor(uv)/(float(AA*AA));\n   }*/\n   \n   fragColor = texelFetch(iChannel2, ivec2(fragCoord), 0);\n   if(getVectorSection(int(texelFetch(iChannel0, ivec2(4,0),0).x) % (sectionDiv * sectionDiv)) == getVectorSection(fragCoord)){\n       //fragColor = vec4(1.0,0.0,0.0,1.0);\n   }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float[4] values = float[4](0.0,0.0,0.0,0.0);\n\nfloat setVariable(int bufferAddress, float value);\nfloat readVariable(int bufferAddress);\nfloat readVariable2(int bufferAddress);\n\nbool isKeyPressed(int key)\n{\n\treturn texelFetch(iChannel1, ivec2(key,0), 0 ).x > 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.y < 1.0 && int(fragCoord.x) < 5)\n    {\n        float scale = 1.0/pow(1.5, texelFetch(iChannel0, ivec2(2,0),0).x/4.0);\n        \n        int x = int(fragCoord.x);\n        \n        values[0]=readVariable(x);\n        values[1]=readVariable2(x);\n        \n        float slow = 1.0;\n                \n        if(isKeyPressed(16)){\n            slow = 0.2;\n        }\n        \n        if(isKeyPressed(37) && x == 0){\n            values[0] -= 0.1 * scale * slow;\n        }\n        \n        if(isKeyPressed(39) && x == 0){\n            values[0] += 0.1 * scale * slow;\n        }\n        \n        if(isKeyPressed(38) && x == 1){\n            values[0] += 0.1 * scale * slow;\n        }\n        \n        if(isKeyPressed(40) && x == 1){\n            values[0] -= 0.1 * scale * slow;\n        }\n        \n        if(isKeyPressed(32) && x == 2){\n            values[0] += 1.0 * slow;\n        }\n        \n        if(isKeyPressed(13) && x == 2){\n            values[0] -= 1.0 * slow;\n        }\n        if(x == 4){\n            values[0] += 1.0;\n        }\n        \n        if(iMouse.z > 0.0 && x == 3){\n           \n           float scale = 1.0/pow(1.5, texelFetch(iChannel0, ivec2(2,0),0).x/4.0);\n           vec2 centre = vec2(texelFetch(iChannel0, ivec2(0,0),0).x,texelFetch(iChannel0, ivec2(1,0),0).x);\n\n           vec2 mousePos = (iMouse.xy/iResolution.xy)*2.0 - 1.0;\n   \n           float aspectRatio = iResolution.y / iResolution.x;\n           mousePos.y = aspectRatio * mousePos.y;\n\n           mousePos *= (scale*4.0);\n           mousePos += centre;\n           values[0] = mousePos.x;\n           values[1] = mousePos.y;\n        }\n\n        fragColor = vec4(values[0], values[1], values[2], values[3]);\n    }\n}\n\nfloat readVariable(int bufferAddress)\n{\n    return texelFetch(iChannel0, ivec2(bufferAddress,0),0).x;\n}\nfloat readVariable2(int bufferAddress)\n{\n    return texelFetch(iChannel0, ivec2(bufferAddress,0),0).y;\n}\n\nfloat setVariable(int bufferAddress, float value)\n{\n    return values[bufferAddress] = value;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float iterateMandelbrot(vec2 startValue, vec2 c);\nvec2 squareImaginary(vec2 number);\nint maxIterationsInt = 127;\nfloat maxIterations = 127.0;\nbool isManuelJuliaSetInput = true;\nvec2 manualValue = vec2(-0.125,0.75);\nbool mandelBrotdefault = false;\nbool weirdShitWithMandelBrot = false;\n#define AA 1\n#define sectionDiv 1\n\n//https://github.com/python/cpython/blob/main/Objects/complexobject.c\nvec2 _Py_c_prod(vec2 a, vec2 b)\n{\n    vec2 r;\n    r.x = a.x*b.x - a.y*b.y;\n    r.y = a.x*b.y + a.y*b.x;\n    return r;\n}\n\n//https://github.com/python/cpython/blob/main/Objects/complexobject.c\n vec2 c_powu(vec2 x, int n)\n{\n    vec2 r, p;\n    int mask = 1;\n    r = vec2(1.0,0.0);\n    p = x;\n    while (mask > 0 && n >= mask) {\n        if ((n & mask) != 0)\n            r = _Py_c_prod(r,p);\n        mask <<= 1;\n        p = _Py_c_prod(p,p);\n    }\n    return r;\n}\n\n//https://github.com/python/cpython/blob/main/Objects/complexobject.c\nvec2 powerComplex(vec2 a, vec2 b){\n    vec2 r;\n    float vabs,len,at,phase;\n    if (b.x == 0. && b.y == 0.) {\n        r.x = 1.;\n        r.y = 0.;\n    }\n    else if (a.x == 0. && a.y == 0.) {\n        //if (b.y != 0. || b.x < 0.)\n            //errno = EDOM;\n        r.x = 0.;\n        r.y = 0.;\n    }\n    else {\n        vabs = length(a);\n        len = pow(vabs,b.x);\n        at = atan(a.y, a.x);\n        phase = at*b.x;\n        if (b.y != 0.0) {\n            len /= exp(at*b.y);\n            phase += b.y*log(vabs);\n        }\n        r.x = len*cos(phase);\n        r.y = len*sin(phase);\n    }\n    return r;\n}\n\n// Official HSV to RGB conversion\nvec3 hsv2rgb(in vec3 c) {\n    vec3 rgb = clamp(\n        abs(mod(c.x*6.0+vec3(0., 4., 2.), 6.) - 3.) - 1.,\n        0.0, 1.0);\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec4 getColor(vec2 uv)\n{\n    //maxIterationsInt = int(iTime * 20.0);\n    //maxIterations = iTime * 20.0;\n   float scale = 1.0/pow(1.5, texelFetch(iChannel0, ivec2(2,0),0).x/4.0);\n   vec2 centre = vec2(texelFetch(iChannel0, ivec2(0,0),0).x,texelFetch(iChannel0, ivec2(1,0),0).x);\n\n   bool isNonDefaultSet = iMouse.z > 0.0;\n   bool isMandelBrot = isNonDefaultSet ? !mandelBrotdefault : mandelBrotdefault;\n   vec2 mousePos = (iMouse.xy/iResolution.xy)*2.0 - 1.0;\n   \n   float time = iTime * 0.025;\n   \n   float angle = float((time*10.0))/10.0;\n   float dist = 0.7 - (time/200.0);\n   \n   manualValue = vec2((-0.5*cos(time))-(0.25*cos(2.0*time)),(0.5*sin(time))+(0.25*sin(2.0*time)));\n   //manualValue = vec2((-0.25*cos(time))-1.0,(0.25*sin(time)));\n   //manualValue = vec2((-0.09*cos(time))-0.125,(0.09*sin(time))+0.75);\n   // (0.125,3*sqrt(3)/8)\n   \n   float aspectRatio = iResolution.y / iResolution.x;\n   mousePos.y = aspectRatio * mousePos.y;\n\n   mousePos *= (scale*4.0);\n   mousePos = texelFetch(iChannel0, ivec2(3,0),0).xy;\n   \n   if(distance(uv, isManuelJuliaSetInput ? manualValue : mousePos) < 0.04 * scale){\n       return vec4(1.0,1.0,1.0,1.0);\n   }\n   \n   int escapeTime = int(iterateMandelbrot(!isMandelBrot ? uv : weirdShitWithMandelBrot ? mousePos : vec2(0,0), !isMandelBrot ? (isManuelJuliaSetInput ? manualValue : mousePos) : uv));\n   \n   if(escapeTime < maxIterationsInt){\n       float colourStartVal = 1.0 - log(float(escapeTime % 256)) / log(256.0);\n       return vec4(hsv2rgb(vec3(log(colourStartVal),1.0,1.0)),1.0);\n   }else{\n       return vec4(0.0,0.0,0.0,1.0);\n   }\n}\n\nivec2 getVectorSection(vec2 fragCoord){\n    return ivec2(fragCoord/(iResolution.xy/float(sectionDiv)));\n}\n\nivec2 getVectorSection(int time){\n    return ivec2(time % sectionDiv, (time % (sectionDiv*sectionDiv))/sectionDiv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n   float scale = 1.0/pow(1.5, texelFetch(iChannel0, ivec2(2,0),0).x/4.0);\n   float offset = 0.0;   \n   \n   vec2 centre = vec2(texelFetch(iChannel0, ivec2(0,0),0).x,texelFetch(iChannel0, ivec2(1,0),0).x);\n   \n   if(getVectorSection(int(texelFetch(iChannel0, ivec2(4,0),0).x) % (sectionDiv * sectionDiv)) == getVectorSection(fragCoord)){\n       fragColor = vec4(0.0,0.0,0.0,0.0);\n       for( float m=0.0; m<1.0; m+=1.0/float(AA) )\n       for( float n=0.0; n<1.0; n+=1.0/float(AA) )\n       {\n           vec2 uv = ((fragCoord.xy + vec2(n, m))/iResolution.xy)*2.0 - 1.0;\n\n           float aspectRatio = iResolution.y / iResolution.x;\n           uv.y = aspectRatio * uv.y;\n\n           uv *= (scale*4.0);\n           uv += centre;\n\n           fragColor += getColor(uv)/(float(AA*AA));\n       }\n   }else{\n       fragColor = texelFetch(iChannel2, ivec2(fragCoord), 0);\n   }\n   \n   //fragColor += texelFetch(iChannel0, ivec2(3,0),0).y / 5.0;\n}\n\nvec2 squareImaginary(vec2 number){\n\treturn vec2(\n\t\tpow(number.x,2.0)-pow(number.y,2.0),\n\t\t(2.0*number.x*number.y)\n\t);\n}\n\nvec2 cubeImaginary(vec2 number){\n    float i = number.y;\n    float z = number.x;\n    return vec2(\n           (z * z * z)-(3.0*z*i*i),\n           (3.0*z*z*i) - i*i*i\n     );\n}\n\nfloat iterateMandelbrot(vec2 startValue, vec2 c){\n\tvec2 z = startValue;\n\tfor(int i=0;i<maxIterationsInt;i++){\n\t\tz = squareImaginary(z) + c;\n\t\tif(length(z)>2.0){\n            return float(i);\n        }\n\t}\n\treturn maxIterations;\n}","name":"Buffer B","description":"","type":"buffer"}]}