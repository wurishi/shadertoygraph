{"ver":"0.1","info":{"id":"mstfDH","date":"1697472535","viewed":38,"name":"Loading V1","username":"BAKON","description":"Just experimenting","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["circles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//Circle\nvec3 sdfCircle(vec2 uv, float r, vec2 offset, int SphereIndex) {\n    float x = uv.x - offset.x;\n    float y = uv.y - offset.y;\n    \n    float d = length(vec2(x, y)) - r;\n    \n    if(SphereIndex >-1 && SphereIndex < 3)\n    { return d > 0. ? vec3(0.) : vec3(0.1, 0.1, 0.1);}\n    \n    if(SphereIndex > 2 && SphereIndex < 6 )\n    {return d > 0. ? vec3(0.) : vec3(0.4, 0.4, 0.4);}\n    \n    if(SphereIndex > 5 && SphereIndex < 9 )\n    {return d > 0. ? vec3(0.) : vec3(0.7, 0.7, 0.7);}\n    \n    return d > 0. ? vec3(0.) : vec3(1.0, 1.0, 1.0);//background and sphere color\n}\n//Main Function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  vec2 uv = fragCoord/iResolution.xy;\n  uv -= 0.5; //UV coordinate location\n  uv.x *= iResolution.x/iResolution.y;//Fixes sphere stretching\n  \n  const int AmountOfSpheres = 12;\n\n  vec2 offset[AmountOfSpheres];\n  \n  float DistanceBetweenSpheres = 0.5;\n  \n  for(int i = 0; i< AmountOfSpheres; i++)\n  {\n  offset[i] += vec2(sin(iTime*2. + DistanceBetweenSpheres)*0.2, cos(iTime*2. + DistanceBetweenSpheres)*0.2);\n  \n  DistanceBetweenSpheres += 0.5;\n  }\n   \n  vec3 col[AmountOfSpheres];\n  \n  for(int i = 0; i < AmountOfSpheres; i++){\n  col[i] += sdfCircle(uv,0.04,offset[i],i);  \n  }\n  \n  vec3 colmain = vec3(0.0);\n  \n  for(int i = 0; i < AmountOfSpheres; i++)\n  {\n  colmain += col[i];\n  }\n  \n  \n  fragColor = vec4(colmain, 1.0);\n \n}\n","name":"Image","description":"","type":"image"}]}