{"ver":"0.1","info":{"id":"XcjBzK","date":"1725206288","viewed":87,"name":"Riding Inside the Mirror Gyroid","username":"Peregrine","description":"2024-07-06, my favorite to date, a ride inside a reflective gyroid, made for the FieldFX jam.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","gyroid","ride","refllection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define t (2. * iTime)\n#define PI 3.14159265358979\n#define TAU (2. * PI)\n#define EPSILON  .01\n#define MAX_DIST 100.\n\n#define min2(a,b) (a.x < b.x ? a : b)\n#define max2(a,b) (a.x > b.x ? a : b)\n#define pos(n) ((n) * .5 + .5)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nvec3 cos_palette(vec3 a, vec3 b, vec3 c, vec3 d, float x) {\n  return a + b * cos(TAU * (c * x + d));\n}\n\nvec3 palette(float x) {\n  return cos_palette(vec3(.5), vec3(.5), vec3(1., 1., .5), vec3(.8, .9, .3), x);\n}\n\nvec2 path(float x) {\n  return vec2(\n    2. * sin(.2 * x),\n    2. * cos(.15 * x)\n  );\n}\n\nfloat gyroid(vec3 p, float scale) {\n  return dot(scale * sin(p), scale * cos(p.yzx));\n}\n\nvec2 sdf(vec3 p) {\n  vec2 di = vec2(MAX_DIST, -1.);\n  p.xy -= path(p.z);\n  float tunnel = length(p.xy) - 3.;\n  tunnel += sin(.8 * p.x) * sin(.9 * p.y) * sin(.8 * p.z) * .1;\n  float gyr = gyroid(p, pos(sin(.4 * t)) * .3 + .5);\n  gyr = abs(gyr) - pos(sin(.5 * t)) * .2 - .1;\n  gyr = max(gyr, -tunnel);\n  di = min2(di, vec2(gyr, 1.));\n  return di;\n}\n\nvec2 trace(vec3 ro, vec3 rd, int steps) {\n  vec3 p = ro;\n  vec2 di = vec2(-1.);\n  float td = 0.;\n  for (int i = 0; i < steps && td < MAX_DIST; i++) {\n    di = sdf(p);\n    if (di.x < EPSILON)\n      return vec2(td, di.y);\n    p += di.x * rd;\n    td = distance(ro, p);\n  }\n  return vec2(-1.);\n}\n\nvec3 get_normal(vec3 p) {\n  vec2 e = EPSILON * vec2(1., -1.);\n  return normalize(\n    e.xyy * sdf(p + e.xyy).x +\n    e.yxy * sdf(p + e.yxy).x +\n    e.yyx * sdf(p + e.yyx).x +\n    e.xxx * sdf(p + e.xxx).x\n  );\n}\n\nfloat diffuse(vec3 p, vec3 n, vec3 lo) {\n  return max(0., dot(normalize(lo - p), n));\n}\n\nfloat specular(vec3 rd, vec3 n, vec3 lo) {\n  return pow(max(0., dot(normalize(rd + lo), n)), 128.);\n}\n\nvec3 get_camera(vec2 uv, vec3 ro, vec3 ta) {\n  vec3 f = normalize(ta - ro),\n       r = normalize(cross(vec3(0., 1., 0.), f)),\n       u = cross(r, f);\n  return normalize(f + uv.x * r + uv.y * u);\n}\n\nvec3 render(vec2 uv) {\n  vec3 ro = vec3(1., 1., 1.5 * t),\n       ta = ro + vec3(0., 0., 1.);\n  ro.xy += path(ro.z);\n  ta.xy += path(ta.z);\n  vec3 rd = get_camera(uv, ro, ta);\n  vec2 swivel = path(ta.z);\n  rd.xy *= rot(swivel.x/32.);\n  rd.yz *= rot(swivel.y/16.);\n  vec3 lo = ta,\n       c  = vec3(0.);\n  vec2 tdi = trace(ro, rd, 128);\n  if (tdi.x > 0.) {\n    vec3 p = ro + rd * tdi.x,\n         n = get_normal(p);\n    c = palette(p.z * .1) * (diffuse(p, n, lo) + specular(rd, n, lo));\n    vec3 ro_refl = p + 2. * EPSILON * n,\n         rd_refl = normalize(reflect(rd, n));\n    vec2 tdi_refl = trace(ro_refl, rd_refl, 64);\n    if (tdi_refl.x > 0.) {\n      vec3 p_refl = ro_refl + rd_refl * tdi_refl.x,\n           n_refl = get_normal(p_refl);\n      c += palette(p_refl.z * .1) * (diffuse(p_refl, n_refl, lo) + specular(rd_refl, n_refl, lo));\n    }\n  }\n  return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = vec2(2. * fragCoord.xy - iResolution.xy)\n            / max(iResolution.x, iResolution.y);\n\tvec3 c = vec3(0.);\n  \n    c = render(uv);\n  \n\tfragColor = vec4(c, 1.);\n}","name":"Image","description":"","type":"image"}]}