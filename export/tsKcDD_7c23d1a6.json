{"ver":"0.1","info":{"id":"tsKcDD","date":"1602917316","viewed":296,"name":"Segment Tracing Cost Comparison","username":"aeva","description":"Left to right: @yuchengzhong's segment trace, common sphere trace, @breakin's segment trace variant.\nBlue = low cost.\nRed = high cost.\nWhite = cost exceeds sphere trace max cost.\nGreen = ran out of iterations.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["sdf","segment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst int MaxIterations = 100;\nconst int MaxCost = MaxIterations * 13;\nconst float AlmostZero = 0.00001;\nconst float GoodEnough = 0.01; // Distance threshold to mark green when we run out of iterations or cost.\n\n// enums\n#define VIS_DEPTH 1\n#define VIS_COST 2\n#define VIS_ERROR 3\n#define VIS_LOOPS 4\n#define SHAPE_SPHERE 1\n#define SHAPE_CUBE 2\n#define SHAPE_SWIRLING_TERROR 3\n#define FN_SPHERE_TRACE 0\n#define FN_SEGMENT_TRACE_1 1\n#define FN_SEGMENT_TRACE_2 2\n\n// this sets visualization mode\n#define VIS_MODE VIS_COST\n\n// this sets the shape function\n#define SHAPE SHAPE_SWIRLING_TERROR\n\n// these control the panel behavior\n#define LHS_FN FN_SEGMENT_TRACE_1\n#define MID_FN FN_SPHERE_TRACE\n#define RHS_FN FN_SEGMENT_TRACE_2\n#define PANELS 3\n\n#define SHOW_TEXT 1\n#define STRLEN 26\n#define String int[STRLEN]\n\n// some preset strings\n#define TEXT_SEGMENT_TRACING int[4](0xE0A0904, 0x140F09, 0x8061205, 0xFF0A0F0C)\n#define TEXT_BASIC_SPHERE_TRACING int[5](0xC130603, 0x11040008, 0x912090B, 0x6120500, 0xA0F0C08)\n#define TEXT_YUCHENGZHONGS_VARIANT int[6](0x15170200, 0xF090B08, 0x100B180A, 0x13010A0F, 0x12061600, 0x140F060C)\n#define TEXT_BREAKINS_VARIANT int[5](0x12070200, 0xC0D0609, 0x13010F, 0xC120616, 0xFF140F06)\n#define TEXT_NONE -1\n\n// label setup\n#define LHS_TEXT1 TEXT_SEGMENT_TRACING\n#define LHS_TEXT2 TEXT_YUCHENGZHONGS_VARIANT\n#define MID_TEXT1 TEXT_BASIC_SPHERE_TRACING\n#define MID_TEXT2 TEXT_NONE\n#define RHS_TEXT1 TEXT_SEGMENT_TRACING\n#define RHS_TEXT2 TEXT_BREAKINS_VARIANT\n\n\nconst vec4 MissColor = vec4(0.1, 0.1, 0.1, 1.0);\nconst float TravelStart = 1.0;\nconst float TravelEnd = 1000.0;\nconst float LipschitzGridSize = 0.4;\nconst float GlobalBounds = 1.25;\nfloat Scene(vec3 View);\n\n\nint Cost = 0;\nint Loops = 0;\n\n\nbool SphereTrace(vec3 RayDir, out vec3 Position, out float Dist, out bool bGaveUp)\n{\n    float Traveled = TravelStart;\n    int i;\n    for (i = 0; i < MaxIterations && Traveled < TravelEnd && Cost < MaxCost; ++i)\n    {\n        Loops = i;\n    \tPosition = RayDir * Traveled;\n        Dist = Scene(Position);\n\t\tTraveled += abs(Dist);\n        if (Dist < AlmostZero)\n        {\n            bGaveUp = false;\n            return true;\n        }\n    }\n    bGaveUp = i == MaxIterations && Dist < GoodEnough;\n    return false;\n}\n\n\n// BEGIN code adapted from https://www.shadertoy.com/view/WdKczW\nvec3 Gradient(vec3 Point)\n{\n    vec3 X = vec3(1.0,0.0,0.0) * AlmostZero;\n    vec3 Y = vec3(0.0,1.0,0.0) * AlmostZero;\n    vec3 Z = vec3(0.0,0.0,1.0) * AlmostZero;\n    vec3 High = vec3(Scene(Point + X), Scene(Point + Y), Scene(Point + Z));\n    vec3 Low = vec3(Scene(Point - X), Scene(Point - Y), Scene(Point - Z));\n\treturn (High - Low) / (2.0 * AlmostZero);\n}\nfloat LipschitzBoundz1(vec3 Start, vec3 End, vec3 RayDir)\n{\n    vec3 StartGradient = Gradient(Start);\n    vec3 EndGradient = Gradient(End);\n    float fds = abs(dot(StartGradient, RayDir));\n    float fde = abs(dot(EndGradient, RayDir));\n    return max(max(fds, fde), AlmostZero);\n}\nbool SegmentTrace1(vec3 RayDir, out vec3 Position, out float Dist, out bool bGaveUp)\n{\n\tfloat Traveled = TravelStart;\n\tfloat Span = LipschitzGridSize;\n    int i;\n\tfor (i = 0; i < MaxIterations && Traveled < TravelEnd && Cost < MaxCost; i++)\n\t{\n\t\tLoops = i;\n        Position = RayDir * Traveled;\n        Dist = Scene(Position);\n        if (Dist < AlmostZero)\n        {\n            bGaveUp = false;\n            return true;\n        }\n            \n\t\tvec3 SegmentEnd = RayDir * (Traveled + Span);\n        float LocalBounds = LipschitzBoundz1(Position, SegmentEnd, RayDir);\n\n\t\tSpan = min(Span, abs(Dist) / LocalBounds);\n        Span = max(Span, abs(Dist) / GlobalBounds);\n\t\tif (Span >= 0.0)\n\t\t{\n\t\t\tTraveled += max(Span, AlmostZero);\n\t\t}\n        Span = min(Span, LipschitzGridSize);\n\t}\n    bGaveUp = (i == MaxIterations || Cost >= MaxCost) && Dist < GoodEnough;\n    return false;\n}\n// END\n                   \n\n// BEGIN code adapted from https://www.shadertoy.com/view/wdGyDD\nfloat AbsDirectionalGradient(vec3 Point, vec3 RayDir)\n{\n    return abs(Scene(Point + RayDir * AlmostZero) - Scene(Point - RayDir * AlmostZero)) / (2.0 * AlmostZero);\n}\nfloat LipschitzBoundz2(vec3 Start, vec3 End, vec3 RayDir)\n{\n    float fds = AbsDirectionalGradient(Start, RayDir);\n    float fde = AbsDirectionalGradient(End, RayDir);\n    return max(max(fds, fde), AlmostZero);\n}\nbool SegmentTrace2(vec3 RayDir, out vec3 Position, out float Dist, out bool bGaveUp)\n{\n\tfloat Traveled = TravelStart;\n\tfloat Span = LipschitzGridSize;\n    int i;\n\tfor (i = 0; i < MaxIterations && Traveled < TravelEnd && Cost < MaxCost; i++)\n\t{\n        Loops = i;\n        Position = RayDir * Traveled;\n        Dist = Scene(Position);\n        if (Dist < AlmostZero)\n        {\n            bGaveUp = false;\n            return true;\n        }\n            \n\t\tvec3 SegmentEnd = RayDir * (Traveled + Span);\n        float LocalBounds = LipschitzBoundz2(Position, SegmentEnd, RayDir);\n\n\t\tSpan = min(Span, abs(Dist) / LocalBounds);\n        Span = max(Span, abs(Dist) / GlobalBounds);\n\t\tif (Span >= 0.0)\n\t\t{\n\t\t\tTraveled += max(Span, AlmostZero);\n\t\t}\n        Span = min(Span, LipschitzGridSize);\n\t}\n    bGaveUp = (i == MaxIterations || Cost >= MaxCost) && Dist < GoodEnough;\n    return false;\n}\n// END\n\n\nbool RayMarch(int Fn, vec3 RayDir, out vec3 Position, out float Dist, out bool bGaveUp)\n{\n    switch(Fn)\n    {\n        case FN_SEGMENT_TRACE_1:\n        return SegmentTrace1(RayDir, Position, Dist, bGaveUp);\n        \n        case FN_SEGMENT_TRACE_2:\n        return SegmentTrace2(RayDir, Position, Dist, bGaveUp);\n        \n        default:\n        return SphereTrace(RayDir, Position, Dist, bGaveUp);\n    }\n}\n\n\nfloat Sphere(vec3 Local, float Radius)\n{\n\treturn length(Local) - Radius;\n}\n\n\nfloat Box(vec3 Local, vec3 Bounds)\n{\n\tvec3 Dist = abs(Local) - Bounds;\n\treturn length(max(Dist, 0.0)) + min(max(Dist.x, max(Dist.y, Dist.z)), 0.0);\n}\n\n\nfloat Sphube(vec3 Local, float Alpha)\n{\n\treturn mix(Sphere(Local, 1.0), Box(Local, vec3(1.0)), Alpha);\n}\n\n\nfloat Gloop(vec3 Point, float Scale)\n{\n\treturn sin(Scale * Point.x) * sin(Scale * Point.y) * sin(Scale * Point.z);\n}\n\n\nfloat Union(float LHS, float RHS)\n{\n\treturn min(LHS, RHS);\n}\n\n\nfloat Subtract(float LHS, float RHS)\n{\n    return max(LHS, -RHS);\n}\n\n\nfloat Intersection(float LHS, float RHS)\n{\n\treturn max(LHS, RHS);\n}\n\n\nvec3 Twist(vec3 Point, float Intensity)\n{\n\tfloat C = cos(Intensity * Point.z);\n\tfloat S = sin(Intensity * Point.z);\n\tmat2  M = mat2(C, -S, S, C);\n\treturn vec3(M * Point.xy, Point.z);\n}\n\n\nfloat StressTestShape(vec3 Local)\n{\n#if SHAPE == SHAPE_CUBE\n\treturn Box(Local, vec3(1.0));\n#elif SHAPE == SHAPE_SPHERE\n\treturn Sphere(Local, 1.0);\n#else\n\tvec3 BoxLocal = Local;\n\tconst float Repeat = 0.5;\n    BoxLocal.z -= sin(iTime * -1.1) * 0.5 + 0.5;\n\tBoxLocal.z = mod(BoxLocal.z + 0.5 * Repeat, Repeat) - 0.5 * Repeat;\n\tLocal = Twist(Local, length(Local.xy) * 5.0);\n\tfloat Dist = Sphube(Local, 0.5);\n\tDist = Intersection(Dist, Gloop(Local, 10.0));\n\tDist = Subtract(Dist, Box(BoxLocal, vec3(2.0, 2.0, Repeat * 0.3)));\n\treturn Dist;\n#endif\n}\n\n\nvec2 Rotate2D(vec2 Point, float Radians)\n{\n\tvec2 SinCos = vec2(sin(Radians), cos(Radians));\n\treturn vec2(\n\t\tSinCos.y * Point.x + SinCos.x * Point.y,\n\t\tSinCos.y * Point.y - SinCos.x * Point.x);\n}\n\n\nvec3 RotateX(vec3 Point, float Radians)\n{\n\tvec2 Rotated = Rotate2D(Point.yz, Radians);\n\treturn vec3(Point.x, Rotated.xy);\n}\n\n\nfloat Scene(vec3 Point)\n{\n    Cost++;\n\tPoint = RotateX(Point, 8.0 * 0.017453292519943295);\n\tPoint -= vec3(0.0, 3.1, -1.5);\n    Point.z -= sin(iTime) * 0.5 + 0.5;\n\treturn StressTestShape(Point);\n}\n\n\nvec3 GetRayDir(vec2 FragCoord, vec2 Resolution, float FOV)\n{\n    float Aspect = Resolution.y / Resolution.x;\n    vec2 NDC = FragCoord / iResolution.xy * 2.0 - 1.0;\n    vec2 Angle = NDC * vec2(FOV, FOV * Aspect) * 0.5;\n    vec3 RayDir = vec3(sin(radians(Angle)), 0.0).xzy;\n    RayDir.y = sqrt(1.0 - (RayDir.x * RayDir.x) - (RayDir.z * RayDir.z));\n    return RayDir;\n}\n\n\nbool LineTest(float X, float Split)\n{\n    return distance(X, iResolution.x * Split) < 1.0;\n}\n\n\nvec4 PrintInner(ivec2 Area, ivec2 Pixel, int GlyphIndex)\n{\n    if (GlyphIndex < 0xFF && Pixel.x >= 0 && Pixel.y >= 0 && Pixel.x < Area.x && Pixel.y < Area.y)\n    {\n        int GlyphsPerRow = int(floor(iResolution.x)) / 8;\n        if (GlyphIndex >= 0)\n        {\n        \tivec2 Glyph = ivec2(GlyphIndex % GlyphsPerRow, GlyphIndex / GlyphsPerRow);\n\t\t\tvec2 UV = vec2(0.5 + vec2(Glyph * 8 + (Pixel % 8))) / iResolution.xy;\n        \treturn vec4(texture(iChannel0, UV).rgb, 1.0);\n        }\n    }\n\treturn vec4(0.0);\n}\n\n\nint UnpackChar(int Packed, int SubIndex)\n{\n   return (Packed >> (SubIndex * 8)) & 0xFF;\n}\n\n\nvec4 Print(vec2 fragCoord, ivec2 LowerLeft, int Line)\n{\n    return vec4(0.0);\n}\nvec4 Print(vec2 fragCoord, ivec2 LowerLeft, int[4] Line)\n{\n    ivec2 Area = ivec2(128, 8);\n    ivec2 Pixel = ivec2(floor(fragCoord)) - LowerLeft;\n    int CharIndex = Pixel.x / 8;\n    int GlyphIndex = UnpackChar(Line[abs(CharIndex / 4) % 4], CharIndex % 4);\n    return PrintInner(Area, Pixel, GlyphIndex);\n}\nvec4 Print(vec2 fragCoord, ivec2 LowerLeft, int[5] Line)\n{\n    ivec2 Area = ivec2(160, 8);\n    ivec2 Pixel = ivec2(floor(fragCoord)) - LowerLeft;\n    int CharIndex = Pixel.x / 8;\n    int GlyphIndex = UnpackChar(Line[abs(CharIndex / 4) % 5], CharIndex % 4);\n    return PrintInner(Area, Pixel, GlyphIndex);\n}\nvec4 Print(vec2 fragCoord, ivec2 LowerLeft, int[6] Line)\n{\n    ivec2 Area = ivec2(192, 8);\n    ivec2 Pixel = ivec2(floor(fragCoord)) - LowerLeft;\n    int CharIndex = Pixel.x / 8;\n    int GlyphIndex = UnpackChar(Line[abs(CharIndex / 4) % 6], CharIndex % 4);\n    return PrintInner(Area, Pixel, GlyphIndex);\n}\n\n\nvoid mainImage(out vec4 FragColor, in vec2 FragCoord)\n{\n    vec3 RayDir = GetRayDir(FragCoord.xy, iResolution.xy, 45.0);\n    vec3 Position;\n    float Dist;\n    bool bHit = false;\n#if PANELS == 2\n    bool bDrawLine = LineTest(FragCoord.x, 0.5);\n    const float LeftSplit = 2.0;\n#elif PANELS == 3\n\tbool bDrawLine = LineTest(FragCoord.x, 1.0 / 3.0) || LineTest(FragCoord.x, 2.0 / 3.0);\n    const float LeftSplit = 3.0;\n#endif \n    \n    if (bDrawLine)\n    {\n        FragColor = vec4(1.0);\n        return;\n    }\n    \n    bool bGaveUp;\n    float Panel;\n    if (FragCoord.x < iResolution.x / LeftSplit)\n    {\n        Panel = 0.0;\n        bHit = RayMarch(LHS_FN, RayDir, Position, Dist, bGaveUp);\n    }\n#if PANELS == 3\n\telse if (FragCoord.x < iResolution.x * 2.0 / 3.0)\n    {\n        Panel = 1.0;\n        bHit = RayMarch(MID_FN, RayDir, Position, Dist, bGaveUp);\n    }\n#endif\n    else\n    {\n        Panel = 2.0;\n        bHit = RayMarch(RHS_FN, RayDir, Position, Dist, bGaveUp);\n    }\n   \n    \n    if (bHit)\n    {\n#if VIS_MODE == VIS_DEPTH\n\t\tfloat Depth = length(Position);\n        float Near = 2.0;\n\t\tfloat Far = 7.0;\n\t\tfloat Range = Far - Near;\n        float Fnord = 1.0 - (max(Depth - Near, 0.0) / Range);\n        FragColor = vec4(vec3(pow(Fnord, 2.2)), 1.0);\n#elif VIS_MODE == VIS_COST\n\t\tvec3 Hot = vec3(1.0, 0.0, 0.0);\n        vec3 Cold = vec3(0.0, 0.0, 1.0);\n        if (Cost <= MaxIterations)\n        {\n        \tfloat Alpha = float(Cost) / float(MaxIterations);\n        \tFragColor = vec4(mix(Cold, Hot, Alpha), 1.0);\n        }\n        else\n        {\n            FragColor = vec4(1.0);\n        }\n#elif VIS_MODE == VIS_LOOPS\n\t\tvec3 Hot = vec3(1.0, 0.0, 0.0);\n        vec3 Cold = vec3(0.0, 0.0, 1.0);\n        float Alpha = float(Loops) / float(MaxIterations);\n\t\tFragColor = vec4(mix(Cold, Hot, Alpha), 1.0);\n#elif VIS_MODE == VIS_ERROR\n\t\tvec3 Hot = vec3(1.0, 0.0, 0.0);\n        vec3 Cold = vec3(0.0, 0.0, 1.0);\n        float Alpha = Dist / AlmostZero;\n        FragColor = vec4(mix(Cold, Hot, Alpha), 1.0);\n#endif\n    }\n    else\n    {\n        if (bGaveUp)\n        {\n            FragColor = vec4(0.0, 1.0, 0.0, 1.0);\n        }\n        else\n        {\n        \tFragColor = MissColor;\n        }\n    }\n#if SHOW_TEXT\n    int Margin = min(max(int(floor(iResolution.x / float(PANELS))) - 2 - (26 * 8), 0), 8);\n    \n    ivec2 Anchor1 = ivec2(\n        Margin + int(floor(iResolution.x * (Panel / float(PANELS)))),\n    \tint(floor(iResolution.y)) - 16);\n    ivec2 Anchor2 = Anchor1 - ivec2(0, 8);\n    \n    vec4 Text;\n    if (Panel == 0.0)\n    {\n        Text = Print(FragCoord, Anchor1, LHS_TEXT1);\n        Text += Print(FragCoord, Anchor2, LHS_TEXT2);\n    }\n    else if (Panel == 1.0)\n    {\n        Text = Print(FragCoord, Anchor1, MID_TEXT1);\n        Text += Print(FragCoord, Anchor2, MID_TEXT2);\n    }\n    else\n    {\n        Text = Print(FragCoord, Anchor1, RHS_TEXT1);\n        Text += Print(FragCoord, Anchor2, RHS_TEXT2);\n    }\n    FragColor.rgb = mix(FragColor.rgb, Text.rgb, Text.a);\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define GLYPH_COUNT 25\nconst int GLYPHS[50] = int[50](0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFBF3F3FF, 0xFFE3F98D, 0x8D99C3FF, 0xFFC19999, 0xC199C1FF, 0xFFC19F9F, 0xC3F983FF, 0xFFE7E7E7, 0xE7E781FF, 0xFF839983, 0x9FC3FFFF, 0xFFC19999, 0xC1F9F9FF, 0xFF83F9F9, 0xF983FFFF, 0xFFC3F981, 0x99C3FFFF, 0xC39F8399, 0x9983FFFF, 0xFF999999, 0xC1F9F9FF, 0xFFC3E7E7, 0xE3FFE7FF, 0xFF99C9E1, 0xC9D9F9FF, 0xFF9C9C94, 0x80C8FFFF, 0xFF999999, 0x99C1FFFF, 0xFFC39999, 0x99C3FFFF, 0xF9F9C199, 0x99C1FFFF, 0xFFF9F9F9, 0x99C1FFFF, 0xFFC18FC3, 0xF183FFFF, 0xFFCFE7E7, 0xE781E7FF, 0xFF839999, 0x9999FFFF, 0xFFE7C399, 0x9999FFFF, 0xC39F8399, 0x9999FFFF, 0xFF81F3E7, 0xCF81FFFF);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 Coord = ivec2(floor(fragCoord));\n    int GlyphsPerRow = int(floor(iResolution.x)) / 8;\n    int RowsNeeded = int(ceil(float(GLYPH_COUNT) / float(GlyphsPerRow)));\n    ivec2 Cell = (Coord / 8) % ivec2(GlyphsPerRow, RowsNeeded);\n    int CharCode = (Cell.y * GlyphsPerRow + Cell.x) % GLYPH_COUNT;\n    ivec2 Pixel = ivec2(Coord.x % 8, Coord.y % 8);\n    Pixel.y = (7 - Pixel.y) % 4;\n    int GlyphHalf = (Coord.y / 4) % 2;\n    int GlyphIndex = CharCode * 2 + GlyphHalf;\n    int Glyph = GLYPHS[GlyphIndex];\n    int Mask = 1 << (Pixel.y * 8 + Pixel.x);\n    if ((Glyph & Mask) == 0)\n    {\n       \tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    else\n    {\n\t   \tfragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}