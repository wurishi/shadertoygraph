{"ver":"0.1","info":{"id":"4ctGRj","date":"1711897197","viewed":39,"name":"Final TP","username":"Samuix","description":"Animated 3D Sphere & 3D GEOMETRIC FORM in Chess Ground and black sky with Raycasting and raytracing and light source and shadow casting and antialiasing and blur and depth of field","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","sphere","geometry","s","lightsource","hadow","blurraycasting","shadowcasting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const bool RAYTRACING_ON = true;\nconst bool DEPTH_OF_FIELD_ON = false;\n\nconst int WITHOUT_ANTIALIASING = 0;\nconst int STOCHASTIC_ANTIALIASING = 1;\nconst int GRID_ANTIALIASING = 2;\n\nconst int ANTIALIASING_MODE = GRID_ANTIALIASING;\n\n\n//Material\nstruct Material\n{\n    float Ka;\n    float Kd;\n    float Ks;\n    float Kn;\n};\n\n//Light\nstruct LightInfo\n{\n    vec3 position;\n    vec3 color;\n    float intensity;\n};\n    \nfloat depth = 1.0;\n\n//camera parameters\nvec3 cameraPos = vec3(6,4,-5);\nconst vec3 cameraTarget = vec3(3,1,-8);\nconst float cameraFovY = 80.0; // Note: angle is degree\nconst float cameraFocusDistance = 7.;\nconst float cameraApperture = 0.25;\n\n//Sphere parameters\nvec3 spherePos = cameraTarget + vec3(0,1,2);\nconst float sphereRadius = 1.0;\nconst vec3 sphereCol = vec3(1,0,0);\nconst Material sphereMat = Material(0.2,0.7,1.0,50.0);\nconst int sphereId = 1;\n\n//Light parameters\nconst vec3 ambiantCol = vec3(0,0,1); // blue\n\n//Light 1 (original)\nconst vec3 lightCol1 = vec3(1,1,1); // white\nvec3 lightPos1 = vec3(8,10,-12);\nconst float lightIntensity1 = 0.8;\n\n//Light 2\nconst vec3 lightCol2 = vec3(1.0, 1.0, 0.5); // white/yellow\nvec3 lightPos2 = vec3(3.0, 10.0, 1.0);\nconst float lightIntensity2 = 0.3;\n\nconst int NB_LIGHTS = 2;\n\nLightInfo lights[NB_LIGHTS];\n\n//Sky parameters\nconst vec3 skyCol = vec3(0);\nconst int skyId = 0;\n\n//Plane parameters\nconst vec3 planePos = vec3(0.0, 0.1, 0.0);\nconst vec3 planeNormal = vec3(0.0, 1.0, 0.0);\nconst vec3 planeCol1 = vec3(1.0, 1.0, 1.0);\nconst vec3 planeCol2 = vec3(0.4, 0.4, 0.4);\nconst Material planeMat = Material(0.2,1.0,0.2,5.0);\nconst int planeId = 2;\n\n// Anti-aliasing\n//Tracing parameter\nconst int PIXEL_SAMPLING_GRID_SIZE = 10;\nconst int PIXEL_SAMPLING_SIZE = 5;\n\n// Raytracing\nstruct ShadeInfo\n{\n    vec3 shadedCol;\n    float Ks;\n};\n    \nconst int MAX_NB_BOUNCES = 8;\n\n// Motion Blur\nconst int TIME_SAMPLING_SIZE = 5;\nconst float TIME_SAMPLING_OFFSET_MAX = 0.075;\n\n//CSG parameters\nconst vec3 csgSphere1Pos = cameraTarget + vec3(-1.125,2,0);\nconst float csgSphere1Radius = 1.4;\nconst vec3 csgSphere2Pos = cameraTarget + vec3(1.125,2,0);\nconst float csgSphere2Radius = 1.4;\nconst vec3 csgSphere3Pos = cameraTarget + vec3(0,2.5,0);\nconst float csgSphere3Radius = 0.5;\nconst vec3 csgSphere4Pos = cameraTarget + vec3(0,2.4,-0.5);\nconst float csgSphere4Radius = 0.5;\nconst vec3 csgCol1 = vec3(1.0,0.5,0.0); //orange\nconst vec3 csgCol2 = vec3(0.4,1.0,1.0); //light cyan\nconst vec3 csgCol3 = vec3(1.0,0.0,1.0); //magenta\nconst vec3 csgCol4 = vec3(5.0,5.0,0.0); //hyper yellow\nconst Material csgMat = Material(0.2,1.0,0.1,90.0);\nconst int csgId = 3;\n\nint subObjectIdC = 0;\n\n\n//##############################################################################################\n\n\n\n// Taken from https://www.shadertoy.com/view/Xt23Ry\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\n\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n\nfloat randomBetween(float minVal, float maxVal)\n{\n    float randNum = fract(sin(dot(gl_FragCoord.xyz + iTime, vec3(12.9898, 78.233, 45.5432))) * 43758.5453);\n    return mix(minVal, maxVal, randNum);\n}\n//---------------------------------------------------------------------------------------------\n\nfloat raySphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float sphereRadius, out vec3 intersecS, out vec3 normalS)\n{    \n    vec3 diff = rayPos - spherePos;\n    \n    float a = dot(rayDir,rayDir);\n    float b = 2.0 * dot(diff,rayDir);\n    float c = dot(diff,diff) - sphereRadius * sphereRadius;\n    \n    // second degrÃ©\n    float delta = b*b - 4.0*a*c;\n    \n    if(delta >= 0.0)\n    {\n        float sDelta = sqrt(delta);\n        float x1 = (-b - sDelta) / (2.0 * a);\n        float x2 = (-b + sDelta) / (2.0 * a);\n        \n        intersecS = rayPos + x1 * rayDir;\n        normalS = normalize(intersecS - spherePos);\n        \n        return x1;\n    }\n    \n    return -1.0;\n}\n \n//----------------------------------------------------------------------------------------------\n \n// NOTE: planeNormal must be a unit-vector!\nfloat rayPlane(    vec3 rayPos    ,     vec3 rayDir, vec3 planePos, vec3 planeNormal,\n               out vec3 intersecPt, out vec3 normal)\n{\n    if(dot(rayDir,planeNormal)!=0.0)\n    {\n        float t = dot(planePos - rayPos,planeNormal)/dot(rayDir,planeNormal);\n        \n        intersecPt = rayPos + t * rayDir;\n        normal = planeNormal;\n        \n        return t;\n    }\n    return -1.0;\n}\n \n//----------------------------------------------------------------------------------------------\n\n float rayCSG(vec3 rayPos, vec3 rayDir, out vec3 intersecPt, out vec3 normal, out int subObjectId)\n{\n    // Our example CSG object is defined like this:\n    //  ((sphere1 AND sphere2) OR sphere3) - sphere4)\n\t\n    float distIn, distOut;\n    distIn = -1.0;\n    distOut = -1.0;\n    \n    //Sphere 1\n    vec3 diff1 = rayPos - csgSphere1Pos;\n    \n    float a1 = dot(rayDir,rayDir);\n    float b1 = 2.0 * dot(diff1,rayDir);\n    float c1 = dot(diff1,diff1) - csgSphere1Radius * csgSphere1Radius;\n    \n    float delta1 = b1*b1 - 4.0*a1*c1;\n    float distIN1, distOUT1;\n    \n    if(delta1 >= 0.0)\n    {\n        float sDelta1 = sqrt(delta1);\n        float x1_1 = (-b1 - sDelta1) / (2.0 * a1);\n        float x2_1 = (-b1 + sDelta1) / (2.0 * a1);\n        distIN1 = x1_1;\n        distOUT1 = x2_1;\n    }\n    else\n    {\n        distIN1 = -1.0;\n        distOUT1 = -1.0;\n    }\n    \n    //Intersection Sphere 2\n    vec3 diff2 = rayPos - csgSphere2Pos;\n    \n    float a2 = dot(rayDir,rayDir);\n    float b2 = 2.0 * dot(diff2,rayDir);\n    float c2 = dot(diff2,diff2) - csgSphere2Radius * csgSphere2Radius;\n    \n    float delta2 = b2*b2 - 4.0*a2*c2;\n    float distIN2, distOUT2;\n    \n    if(delta2 >= 0.0)\n    {\n        float sDelta2 = sqrt(delta2);\n        float x1_2 = (-b2 - sDelta2) / (2.0 * a2);\n        float x2_2 = (-b2 + sDelta2) / (2.0 * a2);\n        distIN2 = x1_2;\n        distOUT2 = x2_2;\n    }\n    else\n    {\n        distIN2 = -1.0;\n        distOUT2 = -1.0;\n    }\n    \n    //Intersection Sphere 3\n    vec3 diff3 = rayPos - csgSphere3Pos;\n    \n    float a3 = dot(rayDir,rayDir);\n    float b3 = 2.0 * dot(diff3,rayDir);\n    float c3 = dot(diff3,diff3) - csgSphere3Radius * csgSphere3Radius;\n    \n    float delta3 = b3*b3 - 4.0*a3*c3;\n    \n    float distIN3, distOUT3;\n    \n    if(delta3 >= 0.0)\n    {\n        float sDelta3 = sqrt(delta3);\n        float t13 = (-b3 - sDelta3) / (2.0 * a3);\n        float t23 = (-b3 + sDelta3) / (2.0 * a3);\n        distIN3 = t13;\n        distOUT3 = t23;\n    }\n    else\n    {\n        distIN3 = -1.0;\n        distOUT3 = -1.0;\n    }\n    \n    //Intersection Sphere 4\n    vec3 diff4 = rayPos - csgSphere4Pos;\n    \n    float a4 = dot(rayDir,rayDir);\n    float b4 = 2.0 * dot(diff4,rayDir);\n    float c4 = dot(diff4,diff4) - csgSphere4Radius * csgSphere4Radius;\n    \n    float delta4 = b4*b4 - 4.0*a4*c4;\n    \n    float distIN4, distOUT4;\n    \n    if(delta4 >= 0.0)\n    {\n        float sDelta4 = sqrt(delta4);\n        float t14 = (-b4 - sDelta4) / (2.0 * a4);\n        float t24 = (-b4 + sDelta4) / (2.0 * a4);\n        distIN4 = t14;\n        distOUT4 = t24;\n    }\n    else\n    {\n        distIN4 = -1.0;\n        distOUT4 = -1.0;\n    }\n    \n    //Sphere1 AND Sphere2\n    \n    if((distOUT1 < distIN2) || (distOUT2 < distIN1))\n    {\n        distIn = -1.0;\n    \tdistOut = -1.0;\n    }\n    else\n    {\n        distIn = max(distIN1,distIN2);\n        distOut = min(distOUT1,distOUT2);\n        if(distIn == distIN1)\n        {\n        \tsubObjectId = 1;\n            intersecPt = rayPos + distIn * rayDir;\n        \tnormal = normalize(intersecPt - csgSphere1Pos);\n        }\n        else\n        {\n            subObjectId = 2;\n            intersecPt = rayPos + distIn * rayDir;\n        \tnormal = normalize(intersecPt - csgSphere2Pos);\n        }\n    }\n    \n    //(Sphere1 AND Sphere2) OR Sphere3\n    if(distIn > 0.0 && distIN3 > 0.0)\n    {\n        distIn = min(distIn,distIN3);\n        distOut = max(distOut, distOUT3);\n        if(distIn == distIN3)\n        {\n        \tsubObjectId = 3;\n            intersecPt = rayPos + distIn * rayDir;\n        \tnormal = normalize(intersecPt - csgSphere3Pos);\n        }\n    }\n    else\n    {\n        distIn = max(distIn,distIN3);\n        distOut = max(distOut, distOUT3);\n        if(distIn > 0.0)\n        {\n        \tif(distIn == distIN3)\n        \t{\n        \t\tsubObjectId = 3;\n        \t    intersecPt = rayPos + distIn * rayDir;\n        \t\tnormal = normalize(intersecPt - csgSphere3Pos);\n       \t\t}\n        }\n        else\n        {\n            distIn = -1.0;\n    \t\tdistOut = -1.0;\n            subObjectId = 0;\n        }\n    }\n    \n    //((Sphere1 AND Sphere2) OR Sphere3) - Sphere4\n    if(distIn > 0.0 && distIN4 > 0.0)\n    {\n        if(distIn < distIN4)\n        {\n            distOut = distIN4;\n        }\n        else\n        {\n            if(distOut > distOUT4)\n            {\n            \tdistIn = distOUT4;\n            \tsubObjectId = 4;\n            \tintersecPt = rayPos + distIn * rayDir;\n        \t\tnormal = normalize(intersecPt - csgSphere4Pos);\n            }\n            else\n            {\n                distIn = -1.0;\n            }\n        }\n    }\n    else\n    {\n        if(distIn < 0.0)\n        {\n            distIn = -1.0;\n    \t\tdistOut = -1.0;\n            subObjectId = 0;\n        }\n        else\n        {\n            distOut = distIN4;\n        }\n    }\n    \n    if(distIn >= 0.0)\n        return distIn;\n    \n    subObjectId = 0;\n    \n    return -1.0;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvoid computeCameraRayFromPixel( in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n    rayPos = cameraPos; // from where the ray starts\n    float f = 1./tan(radians(cameraFovY)/2.);\n\n    //axes of the camera\n    vec3 cz = normalize(cameraTarget - cameraPos); // camera looking at, on the z axe so -> its the z axe for the rayDir\n    vec3 cx = normalize(cross(cz,vec3(0,1,0))); // X axe determined by a temporary axe and cross product\n    vec3 cy = normalize(cross(cz,cx)); // Y axe calculed by cross product\n    \n    // focal distance\n    \n    // rayPos -> where the ray start (from the cam)\n\n   // pixCoord = vec2(f*pixCoord.x/,f*pixCoord.y)\n    //rayDirpixCoord\n    vec3 PO = f*cz;\n    vec3 OS = pixCoord.x*cx - pixCoord.y*cy;\n    \n    rayDir = normalize(PO + OS);\n}\n\n//----------------------------------------------------------------------------------------------\n\n// Phong with multiples lights\nvec3 computePhongShadingML(vec3 objectCol, Material objectMat,float shadowFactor, vec3 N, vec3 L, vec3 R, vec3 V, LightInfo light)\n{\n    vec3 Ia = ambiantCol * objectMat.Ka / float(NB_LIGHTS);\n    vec3 Id = light.color * light.intensity * objectCol * objectMat.Kd * max(dot(L,N),0.0);\n    vec3 Is = light.color * light.intensity * objectMat.Ks * pow(max(dot(R,V),0.0),objectMat.Kn);\n\n    float shadowSpec = shadowFactor < 1.0 ? 0.0 : 1.0;    \n    vec3 I = Ia + (Id * shadowFactor) + (Is * shadowSpec);\n    \n    return I;\n}\n\nvec3 computePhongShading(vec3 objectCol, Material objectMat,  float shadowFactor, vec3 N, vec3 L, vec3 R, vec3 V)\n{\n    vec3 Ia = ambiantCol * objectMat.Ka;\n    vec3 Id = lightCol1 * objectCol * objectMat.Kd * max(dot(L,N),0.0);\n    vec3 Is = lightCol1 * objectMat.Ks * pow(max(dot(R,V),0.0),sphereMat.Kn);\n    //vec3 Is = vec3(0.,0.,0.);\n\n    float shadowSpec = shadowFactor < 1.0 ? 0.0 : 1.0;    \n    vec3 I = Ia + (Id * shadowFactor) + (Is * shadowSpec);\n    \n    return I;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvoid AnimateScene(float time)\n{\n    // Animate the sphere position\n    const float pi           = 3.1415926535;\n    const float rs           = 2.0;\n    const float spr          = 5.0;\n    float       as           = 2.0 * pi * time / spr;\n\t    // NOTE: at time=0, the sphere position is the same than the default one defined at\n    \t//       the top of this source code.\n    spherePos = cameraTarget + rs * vec3(-sin(as), 0.0, cos(as)) + vec3(0,1,0);\n    \n    // Animate the light position\n    // NOTES: - light will move up and down from height of 1 to 20.\n    //        - again we made our formula so that the position is the default one at time=0.\n    lightPos1 += vec3(0, 10.5 + 9.5 * cos(time) - 10., 0);\n    \n    // Animate the camera\n    // NOTE: again we made our formula so that the position is the default one at time=0.\n    float targetDist = length(cameraTarget - cameraPos);\n    cameraPos -= vec3(0, 0, targetDist);\n    cameraPos += targetDist*vec3(sin(time),max(sin(time*0.5),0.),cos(time));\n}\n\n//----------------------------------------------------------------------------------------------\n\n/*\nvec2 apply_transform(vec2 point)\n{\n    //return vec2((iResolution.x/2.0 - point.x)/ratio, (iResolution.y/2.0 - point.y)/ratio);\n    return vec2((iResolution.x/2.0 - point.x)/iResolution.y, (iResolution.y/2.0 - point.y)/iResolution.y);\n}\n*/\n\n vec2 apply_transform(vec2 point){\n    point = (2.*point.xy - iResolution.xy)/iResolution.y;\n    return vec2(point.x,point.y);\n}\n\n//----------------------------------------------------------------------------------------------\n\n// The aim of this routine is to find the nearest intersection the ray has with ALL the objects\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir,\n                                 out int objectId, out vec3 intersecI, out vec3 normalI)\n{\n\t// Test ray-sphere intersection and get the intersection point and associated normal\n\n    float distNearest  = 9999999999.0;\n    objectId = skyId;\n\n    vec3 intersecCSG, normalCSG;\n    float distCSG = rayCSG(rayPos, rayDir, intersecCSG, normalCSG, subObjectIdC);\n    if (distCSG > 0.0 &&  distCSG < distNearest)\n    {\n        objectId  =   csgId;\n\t    intersecI = intersecCSG;\n        normalI =   normalCSG;\n        distNearest = distCSG;\n    }\n    \n    vec3 intersecS, normalS;\n    float distSphere = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    if(distSphere > 0.0 && distSphere < distNearest)\n    {\n        objectId = sphereId;\n        intersecI = intersecS;\n        normalI = normalS;\n        distNearest = distSphere;\n    }\n    \n    vec3 intersecP, normalP;\n    float distPlane = rayPlane(rayPos, rayDir, planePos, planeNormal, intersecP, normalP);\n    if (distPlane > 0.0 && distPlane < distNearest)\n    {\n        objectId = planeId;\n        intersecI = intersecP;\n        normalI = normalP;\n        distNearest = distPlane;\n    }\n    \n    if (objectId == skyId)\n        distNearest = -1.0;\n    \n    return distNearest;\n}\n//----------------------------------------------------------------------------------------------\n\nvec3 getSphereColorAtPoint(vec3 pt)\n{\n    return sphereCol;\n}\n\n//----------------------------------------------------------------------------------------------\n \n// pt is assumed to be on the plane surface\nvec3 getPlaneColorAtPoint(vec3 pt)\n{\n    return mod(floor(pt.x*0.5) + floor(pt.z*0.5),2.0) < 1.0 ? planeCol1 : planeCol2;\n}\n \n \n//----------------------------------------------------------------------------------------------\n\nvec3 getCSGColorAtPoint(vec3 pt)\n{\n    switch(subObjectIdC)\n    {\n        case 1:\n        \treturn csgCol1;\n        case 2:\n        \treturn csgCol2;\n        case 3:\n        \treturn csgCol3;\n        case 4:\n        \treturn csgCol4;\n        default:\n        \treturn vec3(3);\n    }\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat)\n{\n    switch(objectId)\n    {\n        case 0:\n        \treturn skyCol;\n        \tbreak;\n        case 1:\n        \tobjectMat = sphereMat;\n        \treturn getSphereColorAtPoint(pt);\n        \tbreak;\n        case 2:\n        \tobjectMat = planeMat;\n        \treturn getPlaneColorAtPoint(pt);\n        \tbreak;\n        case 3:\n        \tobjectMat = csgMat;\n        \treturn getCSGColorAtPoint(pt);\n    }\n}\n\n//---------------------------------------------------------------------------------------------\n\nfloat getShadowFactorAtPoint(vec3 I, vec3 N, Material objectMat, vec3 L, float distL)\n{\n    float offset = 0.00001f;\n\n    vec3  shadowRayStart = I + offset * N;\n    vec3  shadowRayDir = L;\n    int   falseInt;\n    vec3  falseVec, falseVec2;\n    float shadowRes = computeNearestIntersection(shadowRayStart, shadowRayDir,\n                                                 falseInt, falseVec, falseVec2);\n                                                 \n    float shadowFactor = (shadowRes < 0.0 || shadowRes >= distL) ? 1.0 : objectMat.Ka;\n    \n    return shadowFactor;\n}\n\n//---------------------------------------------------------------------------------------------\n\nvoid depthField(out vec3 rayDir, out vec3 rayPos, vec2 fragCoord) {\n    // Calculate random offsets for depth of field effect\n    float u = rand(fragCoord);\n    float v = rand(vec2(fragCoord.y, fragCoord.x));\n    vec2 apertureOffset = (vec2(u, v) * 2.0 - 1.0) * cameraApperture;\n    \n    vec3 cameraUp = vec3(0.0, 1.0, 0.0);\n    vec3 cameraFront = normalize(cameraTarget - cameraPos);\n    vec3 cameraRight = normalize(cross(cameraFront, cameraUp));\n    cameraUp = normalize(cross(cameraRight, cameraFront));\n\n\n\n    // Calculate focal point on camera ray\n    vec3 focalPoint = rayPos + rayDir * cameraFocusDistance / dot(rayDir, cameraFront);\n    \n    // Calculate new ray position and direction with depth of field effect\n    rayPos += cameraRight * apertureOffset.x + cameraUp * apertureOffset.y;\n    rayDir = normalize(focalPoint - rayPos);\n}\n//---------------------------------------------------------------------------------------------\n\nvec3 RaytraceAtPixelCoord(vec2 fragCoord)\n{\n    // Compute the ray to be casted through the pixel towards the 3D scene\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(fragCoord, rayPos, rayDir);\n     if(DEPTH_OF_FIELD_ON) depthField(rayDir, rayPos, fragCoord);\n\n    ShadeInfo infos[MAX_NB_BOUNCES];    \n    int nbBounces = 0;\n    \n    while (nbBounces < MAX_NB_BOUNCES)\n    {\n        // Test ray-objetcs intersections and find the nearest one\n        // (with its associated intersection point and normal at the object surface)\n        int  objectId;\n        vec3 intersecI, normalI;\n        float distI = computeNearestIntersection(rayPos, rayDir, objectId, intersecI, normalI);\n\n        // We did not hit any object, so we have the sky color (here: black)\n        if (distI <= 0.0f)\n        {\n            infos[nbBounces].shadedCol = skyCol;\n            infos[nbBounces].Ks = 0.0f;\n            break;\n        }\n\n        Material objectMat;\n        vec3 objectCol = getObjectColorAtPoint(objectId, intersecI, objectMat);\n\n        vec3 tempResColor = vec3(0.0, 0.0, 0.0);\n\n        // unit-vector going from the surface point toward the camera \n        vec3 V = -normalize(rayDir);\n        \n        for(int i=0;i<NB_LIGHTS;i++)\n        {\n            // unit-vector going from the surface point toward the light\n            vec3 L = lights[i].position - intersecI;\n            float distL = length(L);\n            L = normalize(L);\n\n            // unit-vector of the reflection direction of the light at the surface point\n            vec3 R = normalize(2.0*normalI*dot(normalI,L)-L);\n\n            // Find the factor of light attenuation that results\n            // from the intersection point being visible from the light source or in shadow.\n        \tfloat shadowFactor = getShadowFactorAtPoint(intersecI, normalI, objectMat, L, distL);\n\n            // Apply the shading to the points that are on the object surface and seen by the camera\n    \t\t//Phong shading to get the color of the surface point\n    \t\ttempResColor += computePhongShadingML(objectCol, objectMat, shadowFactor, normalI, L, R, V, lights[i]);\n        }\n        \n\n        // Store the information we gathered for that surface point (Phong shading for example)\n        infos[nbBounces].shadedCol = tempResColor;\n        infos[nbBounces].Ks = objectMat.Ks;\n        \n        // Bounce from the surface towards the reflected direction of the ray\n        float offset = 0.00001f;\n        rayPos = intersecI + offset*normalI;\n        rayDir = normalize(2.0*dot(normalI,V)*normalI - V);\n        \n        nbBounces++;\n\n    }\n\n    vec3 resCol = vec3(0.0f,0.0f,0.0f);\n    \n    while( nbBounces >= 0)\n    {\n        resCol = infos[nbBounces].shadedCol + infos[nbBounces].Ks * resCol;\n        nbBounces--;\n    }\n        \n    return resCol;\n}\n\n//---------------------------------------------------------------------------------------------\n\nvec3 RaycastAtPixelCoord(vec2 fragCoord)\n{\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(fragCoord, rayPos, rayDir);\n    if(DEPTH_OF_FIELD_ON) depthField(rayDir, rayPos, fragCoord);\n\n    int objectId;\n    vec3 intersecI, normalI;\n    \n    // Test ray-sphere intersection and get the intersection point and associated normal\n    float distI = computeNearestIntersection(rayPos, rayDir, objectId, intersecI, normalI);\n    \n    // We did not hit the sphere, so we have the sky color (here: black)\n    if(distI <= 0.0)\n        return skyCol;\n        \n    Material objectMat;\n    vec3 objectCol = getObjectColorAtPoint(objectId, intersecI, objectMat);\n    \n    vec3 resCol = vec3(0.0, 0.0, 0.0);\n\n    // unit-vector going from the surface point toward the camera \n    vec3 V = -normalize(rayDir);\n    \n    for(int l = 0; l < NB_LIGHTS; l++)\n    {\n        LightInfo currentLight = lights[l];\n        // unit-vector going from the surface point toward the light\n        vec3 L = currentLight.position - intersecI;\n        float distL = length(L);\n        L = normalize(L);\n        \n        // unit-vector of the reflection direction of the light at the surface point\n        vec3 R = normalize(2.0*normalI*dot(normalI,L)-L);\n\n        // Find the factor of light attenuation that results\n        // from the intersection point being visible from the light source or in shadow.\n        float shadowFactor = getShadowFactorAtPoint(intersecI, normalI, objectMat, L, distL);\n\n        //Phong shading to get the color of the surface point\n        resCol += computePhongShadingML(objectCol, objectMat, shadowFactor, normalI, L, R, V, currentLight);\n    }\n    \n    return resCol;\n}\n\n//---------------------------------------------------------------------------------------------\n\n//De facto \"noise\" function, modified to supply two values\n//Taken from: https://www.shadertoy.com/view/4dGXW1\nvec2 noise2(vec2 location, vec2 delta)\n{\n    const vec2 c = vec2(12.9898,78.233);\n    const float m = 43758.5453;\n    return vec2(\n        fract(sin(dot(location + delta, c)) * m),\n        fract(sin(dot(location + vec2(delta.y,delta.x),c)) * m)\n        );\n}\n\n//---------------------------------------------------------------------------------------------\n\nbool CheckTime(float currentTime, float targetTime) {\n    if(currentTime >= targetTime) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\n\n//---------------------------------------------------------------------------------------------\n\n\nvec3 RaycastOrRaytrace(bool raytraceON, vec2 fragCoord)\n{\n    if(RAYTRACING_ON)\n    {\n        return RaytraceAtPixelCoord(fragCoord);\n    }\n    else\n    {\n        return RaycastAtPixelCoord(fragCoord);\n    }\n                \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    AnimateScene(time*1.0f);\n   \n    lights[0].position = lightPos1;\n    lights[0].color = lightCol1;\n    lights[0].intensity = lightIntensity1;\n    lights[1].position = lightPos2;\n    lights[1].color = lightCol2;\n    lights[1].intensity = lightIntensity2;  \n\n    fragCoord = apply_transform(fragCoord.xy);\n    vec3 resCol = vec3(0.0f, 0.0f, 0.0f);\n    \n    vec2 offset = vec2(0.0f, 0.0f);\n    \n    float aliasingFactor = 1.0;\n\n    // Switch Mode for antialising\n    switch(ANTIALIASING_MODE)\n    {\n        case STOCHASTIC_ANTIALIASING :\n        \n            for (int i=0; i < PIXEL_SAMPLING_SIZE; i++) \n            {\n                float fi = float(i);\n                vec2 delta =  vec2(fi, fi);\n                vec2 n = noise2( fragCoord , delta);\n                offset = vec2(n.x/iResolution.x, n.y/iResolution.y);\n                \n                resCol += RaycastOrRaytrace(RAYTRACING_ON, fragCoord + offset);\n            }\n            aliasingFactor = float(PIXEL_SAMPLING_SIZE);\n        break;\n        \n        case GRID_ANTIALIASING :\n        \n            for (int i=0; i < PIXEL_SAMPLING_GRID_SIZE; i++) \n            {\n                for (int j=0; j < PIXEL_SAMPLING_GRID_SIZE; j++) \n                {\n                    float fi = float(i);\n                    float fj = float(j);\n                    float num = fi/(float(PIXEL_SAMPLING_GRID_SIZE)*iResolution.x);\n                    float den = fj/(float(PIXEL_SAMPLING_GRID_SIZE)*iResolution.y);\n                    vec2 offset = vec2(num, den);\n                    \n                    resCol += RaycastOrRaytrace(RAYTRACING_ON, fragCoord + offset);\n                }\n            }\n            aliasingFactor = float(PIXEL_SAMPLING_GRID_SIZE * PIXEL_SAMPLING_GRID_SIZE);\n\n        break;\n        default :\n            resCol += RaycastOrRaytrace(RAYTRACING_ON, fragCoord);\n            \n        break;\n    }\n        \n    resCol /= aliasingFactor;\n    fragColor = vec4(resCol,1);\n}\n","name":"Image","description":"","type":"image"}]}