{"ver":"0.1","info":{"id":"7lK3Wz","date":"1637533137","viewed":157,"name":"Blue(ish) noise","username":"chronos","description":"pseudorandom blue noise based on using a high pass filter on white noise.\nThe kernel should have an approximately linear ramp in frequency space,\nTherefore the convolution kernel should be a squared sinc function.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["noise","random","number","prng","generation"],"hasliked":0,"parentid":"7tKGDR","parentname":"Blue(ish) PRNG Noise"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define INSPECT_KERNEL 0\n\nfloat sample_noise(vec2 p)\n{\n    vec3  inputs = vec3( p, iTime ); // Spatial and temporal inputs\n    float rand   = random( inputs ); // Random per-pixel value\n    return 2. * rand - 1.;\n}\n\nfloat blue( vec2 p )\n{\n    vec2 pixel_pos = floor(p);\n\n    float pixel_sum = 0.;\n    float total_weight = 0.;\n\n    for(int i = -r; i<=r; i++)\n    {\n        for(int j = -r; j<=r; j++)\n        {\n            vec2 offset = vec2(i, j);\n            float weight = kernel(offset);\n            pixel_sum += weight * sample_noise(pixel_pos + offset);\n            total_weight += weight;\n        }\n    }\n\n    float conv_result = pixel_sum / total_weight;\n   \n    if(p.x < iMouse.x)\n    {\n       if(p.y < iMouse.y)\n       {\n            return conv_result;\n       }\n       return sample_noise(pixel_pos);\n    }\n    \n    return sample_noise(pixel_pos) - conv_result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    #if INSPECT_KERNEL\n        vec2 pix = fragCoord - iResolution.xy/2.;\n        fragColor = vec4(kernel(pix));\n    #else\n        vec2 uv = fragCoord / iResolution.xy;\n        \n        float noise = (blue(fragCoord) + 1. ) * .5;\n        \n        if(fragCoord.x > .95 * iResolution.x)\n            fragColor = vec4(vec3(step(noise, fragCoord.y/iResolution.y)), 1.);\n        else\n            fragColor = vec4(vec3(noise), 1.);\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n\n// https://en.wikipedia.org/wiki/Fourier_transform#Square-integrable_functions,_one-dimensional\n\n//https://en.wikipedia.org/wiki/Triangular_function\nfloat tri(float x)\n{\n    return max(1.-abs(x), 0.);\n}\n\n// https://en.wikipedia.org/wiki/Sinc_function\nfloat sinc(float x)\n{\n    return (x == 0.) ? 1. : sin(PI * x) / (PI * x);\n}\n\n// fourier transform of tri(a * x)\n// https://www.wolframalpha.com/input/?i=fourier+transform+sinc%28x%29%5E2\nfloat fourier_tent(float a, float x)\n{\n    return pow(sinc(x * a), 2.) / abs(a);\n}\n\nconst int r = 15; // filter window radius\nconst float ramp_slope = 0.12;//(1./float(r));\n\n// Note, this kernel is a low pass filter,\n// a squared sinc filter supposed to be the fourier transform of a radial tent function\n// we subtract it from the center pixel after the convolution to get a high pass\n// but we could subtract this kerel from the delta function (offset == ivec(0,0))\n// to get the high pass filter directly\n// then it should be equivalent to a clamped absolute value function, if my reading on\n// wikipedia is correct.\n\n// After trying it, the problem occurs that the center pixel no longer survives\n// the weight normalization step after the convolution, for that, we would have\n// to scale the center pixel by the total weight of the rest of the kernel to compensate\n// which i do not pre-calculate, so going with this approach instead is simpler.\n\n\nfloat kernel(vec2 offset)\n{\n    float t = length(offset);\n    float disc = step(t, float(r));\n    return fourier_tent(ramp_slope, t) * disc;\n}\n\n\n\n// Copied code below from:\n// https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n\n// Chronos edit: inputs changed and \n// luma remapped to range -1 to 1 instead of 0 to 1,\n// otherwise identical to reference\n\n/*\n    static.frag\n    by Spatial\n    05 July 2013\n*/\n\n\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n\n\n// Pseudo-random value in half-open range [0:1].\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }","name":"Common","description":"","type":"common"}]}