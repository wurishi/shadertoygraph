{"ver":"0.1","info":{"id":"4llXW2","date":"1439826050","viewed":1407,"name":"three planes","username":"tly","description":"another escher shader, \"three intersecting planes\".","likes":32,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","escher","planes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"const float PI = 3.14156;\n\nstruct Ray{\n\tvec3 p,v;\n};\n\nfloat hash2 (vec2 p) {\n\treturn fract(sin(p.x*15.0 + p.y*35.7)*49379.37);\t\n}\n\nfloat noise2(vec2 p){\n\tvec2 iP = floor(p);\n\tvec2 fP = fract(p);\n\t\n\treturn mix(\n\t\tmix(hash2(iP + vec2(0,0)),hash2(iP + vec2(0,1)),fP.y),\n\t\tmix(hash2(iP + vec2(1,0)),hash2(iP + vec2(1,1)),fP.y),\n\t\tfP.x\n\t);\n}\n\nvec3 rotateY(in vec3 v, in float a) {\n\treturn vec3(cos(a)*v.x + sin(a)*v.z, v.y,-sin(a)*v.x + cos(a)*v.z);\n}\n\nvec3 rotateX(in vec3 v, in float a) {\n\treturn vec3(v.x,cos(a)*v.y + sin(a)*v.z,-sin(a)*v.y + cos(a)*v.z);\n}\n\nfloat box(vec3 p,vec3 boxPos,vec3 boxSize){\n    vec3 d = abs(p-boxPos)-boxSize;\n    return max(d.x,max(d.y,d.z));\n}\n\nfloat boxplane(vec3 p){\n    vec3 p0 = p;\n\tp0.xz = fract(p0.xz);\n    vec3 p1 = p;\n    p1.xz = fract(p1.xz - 0.5);\n    return max(\n    \tmin(\n        \tbox(p0,vec3(0.5,0,0.5), vec3(0.25,0.02,0.25)),\n        \tbox(p1,vec3(0.5,0,0.5), vec3(0.25,0.02,0.25))\n    \t),\n        box(p,vec3(0,0,48.76),vec3(1.24,1,50))\n    );\n}\n\nfloat scene(vec3 p){\n    float plane1 = boxplane(p);\n    \n    vec3 x = normalize(vec3(-1,sqrt(2.0),1));\n    vec3 y = normalize(vec3(-1,0,-1));\n    vec3 z = normalize(vec3(-1,-sqrt(2.0),1));\n    \n    float plane2 = boxplane(mat3(x,y,z) * p);\n    float plane3 = boxplane(mat3(-x,y,z) * p);\n    \n\treturn min(plane1,min(plane2,plane3));\n}\n\n//thanks inigo ;)\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    scene(pos+eps.xyy) - scene(pos-eps.xyy),\n\t    scene(pos+eps.yxy) - scene(pos-eps.yxy),\n\t    scene(pos+eps.yyx) - scene(pos-eps.yyx));\n\treturn normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = ( fragCoord.xy / iResolution.xy ) - 0.5;\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 p = 1.71 * vec3(0,1.07,-1.5);\n    vec3 ray = normalize(vec3(uv.xy,0.9));\n    \n    vec2 rotation = vec2(sin(0.75 * iTime),sin(iTime));\n    rotation = 0.2 * sign(rotation) * pow(abs(rotation),vec2(7.0));\n    \n    p = rotateY(rotateX(p,rotation.x), rotation.y);\n    ray = rotateX(ray,-0.5);\n    ray = rotateY(rotateX(ray,rotation.x), rotation.y);\n\n    const int MAX_STEPS = 100;\n\t\n    vec3 normal = vec3(0,0,0);\n    for(int i= 0; i < MAX_STEPS; i++){\n    \tfloat d = scene(p);\n   \n        if(d < 0.0001){\n            normal = calcNormal(p);\n            break;\n        }\n        p+= d * ray;\n    }\n    \n    vec3 sunRay = normalize(vec3(1,1,-0.7));\n    \n\tfragColor = vec4(\n        mix(\n            mix(0.3,1.0,max(0.0,dot(normal,sunRay))) * vec3(0.1,0.6,0.9) ,\n        \tvec3(0.6,0.1,0.1),\n            smoothstep(10.0,25.0,length(p))\n        ) + 0.15 *(noise2(fragCoord.xy) - 0.5)\n        ,1);\n    \n}","name":"","description":"","type":"image"}]}