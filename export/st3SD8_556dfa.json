{"ver":"0.1","info":{"id":"st3SD8","date":"1639003139","viewed":109,"name":"The Empath and the Jerk","username":"chronos","description":"Had to code this up after watching Dave Ackley's video on Robust Local Synchronization.\nhttps://www.youtube.com/watch?v=oXiqMGhn9rk","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["automata","cellular","ca","automaton","async","robust","synchronize"],"hasliked":0,"parentid":"st3XzM","parentname":"Syncronize Async CA"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ring buffer type CA algorithm for communication / synchronization\n// based on Dave Ackley's video on Robust Local Synchronization:\n// https://www.youtube.com/watch?v=oXiqMGhn9rk\n\n// Simulation code in Buffer A tab\n// Helper struct + functions in Common tab\n// Display in this tab\n\n// rules (see video):\n// \n// blue -> red -> yellow -> green\n\n// if upstream all agrees copy upstate\n// if downstream all agrees copy downstate\n// otherwise do nothing\n\n// only look at upstream and downstream neighbors\n\n// if no upstream or no downstream then the node is either a tail node or a head node\n// ( i.e is on edge, then the node is either an 'empath', who tries to match, or a 'jerk' who tries to mismatch states)\n\n// head node upstate different from downstate\n// tail node wants upstate equal to downstate\n// middle node wants upstate to match upstream and downstate to match downstream \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 tex = texture(iChannel0, uv);\n    state myState = toState(tex);\n    \n    vec3 color = vec3(0);\n    \n    if(!myState.upstate && !myState.downstate) color = vec3(0,0,1);\n    if(!myState.upstate && myState.downstate)  color = vec3(1,0,0);\n    if(myState.upstate && !myState.downstate)  color = vec3(1,1,0);\n    if(myState.upstate && myState.downstate)   color = vec3(0,1,0);\n    if(myState.edge) color = vec3(.5);\n    \n    fragColor = vec4(color.rgb, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n\n    state myState = toState(texelFetch(iChannel0, ivec2(fragCoord), 0));\n    \n    float random = hash(vec3(fragCoord, iFrame));\n    \n    if(iFrame < 10)\n    {\n        myState = toState(vec4(1,1,0,1));\n        \n        float l = length(uv);\n        myState.edge = (l > .66 || l < 0.33);\n    }\n    else if(!myState.edge)\n    {        \n        bool bShouldUpdateThisFrame = random > 0.5;\n        \n        if(bShouldUpdateThisFrame)\n        {\n    \n            vec4 upstream1 = texelFetch(iChannel0, (ivec2(fragCoord) + ivec2(1,0))%ivec2(iResolution.xy), 0);\n            vec4 upstream2 = texelFetch(iChannel0, (ivec2(fragCoord) + ivec2(0,1))%ivec2(iResolution.xy), 0);\n\n            vec4 downstream1 = texelFetch(iChannel0, (ivec2(fragCoord) + ivec2(-1,0))%ivec2(iResolution.xy), 0);\n            vec4 downstream2 = texelFetch(iChannel0, (ivec2(fragCoord) + ivec2(0,-1))%ivec2(iResolution.xy), 0);\n\n            state u1 = toState(upstream1);\n            state u2 = toState(upstream2);\n            state d1 = toState(downstream1);\n            state d2 = toState(downstream2);\n\n            bool bIsTail = d1.edge && d2.edge && !myState.edge;\n            bool bIsHead = u1.edge && u2.edge && !myState.edge;\n            bool bIsMiddle = !bIsTail && !bIsHead && !myState.edge;\n\n            bool bAllUpstreamAgreesOnUpstate = u1.upstate == u2.upstate || (u1.edge || u2.edge);\n            bool bAllDownstreamAgreesOnDownstate = d1.downstate == d2.downstate || (d1.edge || d2.edge);\n\n            // first copy upstream or downstream states\n\n            if( (bIsHead || bIsMiddle) && bAllDownstreamAgreesOnDownstate)\n            {\n                if(!d1.edge) myState.downstate = d1.downstate;\n                else if(!d2.edge) myState.downstate = d2.downstate;\n            }\n\n            if( (bIsTail || bIsMiddle) && bAllUpstreamAgreesOnUpstate)\n            {\n                if(!u1.edge) myState.upstate = u1.upstate;\n                else if(!u2.edge) myState.upstate = u2.upstate;\n            }\n\n            // make upstate opposite downstate\n            if(bIsHead)\n            {\n                myState.upstate = !myState.downstate;\n            }\n\n            // make downstate same as upstate\n            if(bIsTail)\n            {\n                myState.downstate = myState.upstate;\n            }\n        }\n        \n    }   \n    \n    vec4 color = fromState(myState);\n    fragColor = color;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"struct state\n{\n    bool upstate;\n    bool downstate;\n    bool edge;\n};\n\nvec4 fromState(state s)\n{\n    return vec4(s.upstate ? 1. : 0., s.downstate ? 1. : 0., s.edge ? 1. : 0., 1.);\n}\n\nstate toState(vec4 v)\n{\n    state s;\n    s.upstate = v.r == 1.;\n    s.downstate = v.g == 1.;\n    s.edge = v.b == 1.;\n    return s;\n}\n\n\n\nfloat hash( vec3 fragXY_Frame ) \n{\n    uvec3 p = uvec3(fragXY_Frame);\n    uint n = ( p.x + 1920U*p.y + (1920U*1080U)*(p.z));\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}","name":"Common","description":"","type":"common"}]}