{"ver":"0.1","info":{"id":"4tKXWt","date":"1487966757","viewed":312,"name":"Lonely Island","username":"ZeBestNickname","description":"But not like the band","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["noise","water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX 150\n#define EPSILON 0.01\n#define L -4.0\n#define MAXWAVE 3.0\n#define WATERN vec3(0, 1, 0)\n#define WATERC vec4(0, 0.5, 0.65, 1)\n#define MAX_MARCH_DIST 200.0\n#define WATERI 1.3333\n#define LIGHTDIR vec3(-1, -1, -1)\n#define TDIF vec4(0.5, 0.2, 0.1, 1.0)\n#define TSPEC 0.1\n#define EXTRUDE_ITERATIONS 50\n#define SKY_COL vec4(0.4, 0.6, 0.8, 1.0)\n#define PI 3.14159\n\nfloat hash(vec2 uv){\n    uv.xy *= vec2(12.9898,78.233);\n    vec2 lookup = vec2(sin(uv.x), sin(uv.y));\n    return 2.0 * textureLod(iChannel0, lookup, 0.0).x - 1.0;\n}\n\nfloat noise(vec2 uv, float oct){\n    vec2 tl = floor(uv / oct) * oct;\n    vec2 tr = tl + vec2(oct, 0.0);\n    vec2 bl = tl + vec2(0.0, oct);\n    vec2 br = tl + vec2(oct, oct);\n    \n    vec2 t = (uv - tl) / oct;\n    t = t*t*(3.0 - 2.0 * t);\n    \n    return oct * mix(mix(hash(tl), hash(tr), t.x), mix(hash(bl), hash(br), t.x), t.y);\n}\n\nfloat height(vec2 uv){\n    float div = 0.0;\n    float start = 4.0;\n    float final = 0.0;\n    \n    vec2 direction[4];\n    direction[0] = vec2(1.0, 1.0);\n    direction[1] = vec2(-1.0, 1.0);\n    direction[2] = vec2(1.0, 1.0);\n\tdirection[3] = vec2(1.0, -1.0);\n    \n    int dir_idx = 0;\n    \n    for(int i = 0; i < 10; ++i){\n    \tdiv += start;\n        \n        float offset_mul = (start + 2.0) / 2.0;\n        \n        vec2 dir = dir_idx > 0 ? dir_idx > 1 ? dir_idx > 2 ? direction[3] : direction [2] : direction[1] : direction[0];\n        float oct_val = noise(uv + (iTime * offset_mul * dir), start);\n        \n        final += oct_val;\n        \n        start /= 2.0;\n        dir_idx = int(mod(float(dir_idx) + 1.0, 4.0) + 0.5);\n        \n    }\n    return final / div;\n}\n\nfloat terrain(vec3 p){\n    vec2 center = vec2(0.0, 20.0);\n    \n    float oct = 16.0;\n    float div = 0.0;\n    float final = 0.0;\n    \n    \n    for(int i = 0; i < 8; ++i){\n    \tdiv += oct;\n        \n        final += abs(noise(p.xz, oct));\n\n        oct /= 2.0;\n    }\n    \n    float mag = 10.0 / max(1.0, min(100.0, sqrt(length(p.xz - center)) ) );\n    \n    float h = (final / div) * mag;\n    \n    return p.y - (h - 7.0);\n}\n\nfloat circleSDF(vec3 p, vec3 c, float rad){\n\treturn length(p - c) - rad;\n}\n\nfloat scene(vec3 p, out int object){\n    object = -1;\n    \n    float d = terrain(p);\n    if(d <= EPSILON){\n    \tobject = 0;\n    }\n    return d;\n}\n\nvec3 normal(vec3 p, float d){\n\tvec3 px = vec3(p.x + EPSILON, p.yz);\n    vec3 py = vec3(p.x, p.y + EPSILON, p.z);\n    vec3 pz = vec3(p.xy, p.z + EPSILON);\n    \n    int holder;\n    \n    vec3 offset_d = vec3(scene(px, holder), scene(py, holder), scene(pz, holder));\n    \n    return normalize(offset_d - d);\n}\n\nbool march(vec3 dir, vec3 origin, out vec3 final_sample_pt, out float d, out int object){\n\tfloat rl = scene(dir + origin, object);\n    \n    for(int i = 0; i < MAX; ++i){\n        final_sample_pt = dir * rl + origin;\n        d = scene(final_sample_pt, object);\n        \n        if(d < EPSILON){\n            return true;\n        }\n\n        rl += d;\n        \n        if(rl > MAX_MARCH_DIST){\n            break;\n        }\n    }\n    \n    return false;\n}\n\nvec3 refractRay(vec3 ray, vec3 normal, float eta){\n    float k = 1.0 - eta * eta * (1.0 - dot(normal, ray) * dot(normal, ray));\n    if (k < 0.0)\n        return vec3(0.0, 0.0, 0.0);\n    else\n        return normalize(eta * ray - (eta * dot(normal, ray) + sqrt(k)) * normal);\n    return refract(normal, ray, eta);\n}\n\n\n\nvoid marchScene(vec3 dir, vec3 origin, out vec3 final_sample_pt, out float d, out vec4 c){\n    int object;\n\n    bool hit_scene = march(dir, origin, final_sample_pt, d, object);\n    \n    float sky_t = dot(normalize(final_sample_pt), vec3(0, 1, 0));\n    sky_t = clamp(sky_t + 0.5, 0.0, 1.0); \n    sky_t = sky_t * sky_t * (3.0 - 2.0 * sky_t);\n    \n    c = sky_t * SKY_COL + (1.0 - sky_t) * vec4(1.0, 1.0, 1.0, 1.0);\n        \n    if(hit_scene)\n    {\n        vec3 n = normal(final_sample_pt, d);\n        vec3 light_dir = normalize(LIGHTDIR);\n        \n\t\tfloat dp = clamp(dot(normal(final_sample_pt, d), -light_dir) + 0.2, 0.2, 1.0);\n        vec4 scene_diffuse = dp * TDIF;\n        \n        vec3 brdf = reflect(dir, n);\n        float s = max(0.0, pow(dot(brdf, light_dir), 4.0));\n        vec4 specular = TSPEC * vec4(s, s, s, 0.0);\n        \n        c = scene_diffuse + specular;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float smaller = min(iResolution.x, iResolution.y);\n    float x_half = iResolution.x / (smaller * 2.0);\n    float y_half = iResolution.y / (smaller * 2.0);\n    \n    vec3 origin = vec3(0.0, 0.0, 0.0);\n    \n    vec3 ray = normalize(vec3(fragCoord.xy / smaller - vec2(x_half, y_half), 1.0));\n    \n    vec3 final;\n    float d;\n\n    marchScene(ray, origin, final, d, fragColor);\n    \n    float timer = iTime;\n    \n    if(final.y < L + MAXWAVE){\n        float level = L + MAXWAVE;\n        float ray_t = dot(vec3(0, level, 0), WATERN) / dot(ray, WATERN);\n        vec3 intersect = ray_t * ray;\n        \n        vec2 sample_pos;\n        float b;\n        \n        for(int i = 0; i < EXTRUDE_ITERATIONS; ++i){\n            sample_pos = (intersect.xz / 2.0);\n            b = height(sample_pos) * MAXWAVE;\n            \n            float dif = (level - L) - b;\n            \n            vec3 new_ray = (ray_t + dif) * ray;\n            \n\t\t\tlevel -= dif / 10.0;\n            \n            float new_ray_t = dot(vec3(0, level, 0), WATERN) / dot(ray, WATERN);\n        \tintersect = new_ray_t * ray;\n            \n        }\n        \n        \n        if(length(intersect) > length(final) && length(intersect) < 100.0){\n            return;\n        }\n        \n        float offset = 0.1;\n        float west = height(sample_pos + vec2(-offset, 0.0));\n        float east = height(sample_pos + vec2(offset, 0.0));\n        float north = height(sample_pos + vec2(0.0, offset));\n        float south = height(sample_pos + vec2(0.0, -offset));\n        \n        vec3 n = normalize(vec3(east - west, 2.0 * offset, north - south));\n        \n        vec3 light_dir = normalize(LIGHTDIR);\n        float acc_water = length(intersect - final);\n        \n        vec3 brdf = reflect(ray, n);\n        \n        //waterc\n        float dp = dot(light_dir, brdf);\n        float dp2 = dot(-light_dir, brdf);\n        float specular = max(0.0, pow(dp, 5.0));\n        fragColor = 0.1 * vec4(specular, specular, specular, 1.0) + 0.5 * WATERC * min(1.0, max(0.0, dp2) + 0.5);\n        \n        vec3 rp;\n        float rd;\n        vec4 reflect_c;\n        \n        marchScene(brdf, intersect, rp, rd, reflect_c);\n        \n        if(rp.y < intersect.y){\n        \treflect_c = vec4(0, 0, 0, 1);\n        }\n\n        vec3 refp;\n        float refd;\n        vec3 refract_ray = refractRay(ray, n, 1.0 / WATERI);\n        vec4 refract_c;\n        \n        marchScene(refract_ray, intersect, rp, rd, refract_c);\n        refract_c *= 1.0 / (min(sqrt(max(1.0, acc_water)), 5.0) );\n        \n        float fresnel = pow(clamp(dot(n, -ray), 0.0, 1.0), 3.0);\n        \n        fragColor += mix(reflect_c, refract_c, 1.0 - fresnel);\n    }\n}","name":"Image","description":"","type":"image"}]}