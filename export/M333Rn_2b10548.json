{"ver":"0.1","info":{"id":"M333Rn","date":"1715970490","viewed":75,"name":"Another Rock Paper Scissors CA","username":"ademdj12","description":"another ca but applying the rules one chunk at a time","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["cell","cellularautomata"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 p(float x) {\n    float v = pow(sin(3.14*x), 2.);\n    return v * vec3(.5, .75*v, .5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texelFetch(iChannel0, ivec2(fragCoord),0).xyz;\n    float c = color.x + color.y * 2.0 + color.z * 4.0;\n    c = c / 7.0;\n    fragColor = vec4(p(c),0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define width 5\n// speed variable is only for visualising so if you plan to use this remove it\n\n#define cwidth 4\n\nvec4 getCell(sampler2D channel,vec2 coord){\n    return texelFetch(channel, ivec2(coord), 0);\n}\n\nvec4 getNeighbour(sampler2D channel,vec2 coord, vec2 offset){\n    return texelFetch(channel, ivec2(coord + offset), 0);\n}\n\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n// calculating local chunk uv \n    vec2 chunk_uv = vec2(int(fragCoord.x) % (width), int(fragCoord.y) % (width));\n    chunk_uv = chunk_uv / float(width);\n    \n    // current active chunk control variable\n    int chunk_step = iFrame % (cwidth*cwidth);\n    \n    // calculating chunk coord\n    vec2 chunk_coord = vec2(\n        floor(fragCoord.x / float(width)),\n        floor(fragCoord.y / float(width))\n    );\n    \n    // local coord in chunk \n    vec2 local_coord = vec2(\n        int(chunk_coord.x) % cwidth,\n        int(chunk_coord.y) % cwidth\n\n    );\n    // conveting local_coord to base dim\n    float local_2_base = local_coord.x + local_coord.y * float(cwidth);\n    \n    // active chunk flag\n    bool current_active = int(local_2_base) == chunk_step;  \n    \n    // your logic\n    if(current_active){\n        vec4 currentVal = getCell(iChannel0,fragCoord);\n\n        vec4 neighbourhoodSum = getNeighbour(iChannel0, fragCoord, vec2(-1.0, -1.0))\n                            + getNeighbour(iChannel0, fragCoord, vec2(-1.0,  0.0))\n                            + getNeighbour(iChannel0, fragCoord, vec2(-1.0,  1.0))\n                            + getNeighbour(iChannel0, fragCoord, vec2( 0.0, -1.0))\n                            + getNeighbour(iChannel0, fragCoord, vec2( 0.0,  1.0))\n                            + getNeighbour(iChannel0, fragCoord, vec2( 1.0, -1.0))\n                            + getNeighbour(iChannel0, fragCoord, vec2( 1.0,  0.0))\n                            + getNeighbour(iChannel0, fragCoord, vec2( 1.0,  1.0));\n\n        if (currentVal.r > 0.5 && neighbourhoodSum.g >= 3.0) {\n            fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n        } else if (currentVal.g > 0.5 && neighbourhoodSum.b >= 3.0) {\n            fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n        } else if (currentVal.b > 0.5 && neighbourhoodSum.r >= 3.0) {\n            fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        } else if (currentVal.r > 0.5) {\n            fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        } else if (currentVal.g > 0.5) {\n            fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n        } else if (currentVal.b > 0.5) {\n            fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n        }\n    }else{\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n    \n    // random init\n    if(iFrame == 0){\n        float b = rand(fragCoord);\n        if(b < 0.2){\n            fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        }else if(b >= 0.2 && b < 0.7){\n            fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n        }else if(b >= 0.7){\n            fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n        }\n    }\n    \n    \n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define width 10\n// speed variable is only for visualising so if you plan to use this remove it\n\n#define cwidth 4\n\nvec4 getCell(sampler2D channel,vec2 coord){\n    return texelFetch(channel, ivec2(coord), 0);\n}\n\nvec4 getNeighbour(sampler2D channel,vec2 coord, vec2 offset){\n    return texelFetch(channel, ivec2(coord + offset), 0);\n}\n\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n// calculating local chunk uv \n    vec2 chunk_uv = vec2(int(fragCoord.x) % (width), int(fragCoord.y) % (width));\n    chunk_uv = chunk_uv / float(width);\n    \n    // current active chunk control variable\n    int chunk_step = (-iFrame - 1) % (cwidth*cwidth);\n    \n    // calculating chunk coord\n    vec2 chunk_coord = vec2(\n        floor(fragCoord.x / float(width)),\n        floor(fragCoord.y / float(width))\n    );\n    \n    // local coord in chunk \n    vec2 local_coord = vec2(\n        int(chunk_coord.x) % cwidth,\n        int(chunk_coord.y) % cwidth\n\n    );\n    // conveting local_coord to base dim\n    float local_2_base = local_coord.x + local_coord.y * float(cwidth);\n    \n    // active chunk flag\n    bool current_active = int(local_2_base) == chunk_step;  \n    \n    // your logic\n    if(current_active){\n        vec4 currentVal = getCell(iChannel0,fragCoord);\n\n        vec4 neighbourhoodSum = getNeighbour(iChannel0, fragCoord, vec2(-1.0, -1.0))\n                            + getNeighbour(iChannel0, fragCoord, vec2(-1.0,  0.0))\n                            + getNeighbour(iChannel0, fragCoord, vec2(-1.0,  1.0))\n                            + getNeighbour(iChannel0, fragCoord, vec2( 0.0, -1.0))\n                            + getNeighbour(iChannel0, fragCoord, vec2( 0.0,  1.0))\n                            + getNeighbour(iChannel0, fragCoord, vec2( 1.0, -1.0))\n                            + getNeighbour(iChannel0, fragCoord, vec2( 1.0,  0.0))\n                            + getNeighbour(iChannel0, fragCoord, vec2( 1.0,  1.0));\n\n        if (currentVal.r > 0.5 && neighbourhoodSum.g >= 3.0) {\n            fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n        } else if (currentVal.g > 0.5 && neighbourhoodSum.b >= 3.0) {\n            fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n        } else if (currentVal.b > 0.5 && neighbourhoodSum.r >= 3.0) {\n            fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        } else if (currentVal.r > 0.5) {\n            fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        } else if (currentVal.g > 0.5) {\n            fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n        } else if (currentVal.b > 0.5) {\n            fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n        }\n    }else{\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n    \n    \n    \n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define width 20\n// speed variable is only for visualising so if you plan to use this remove it\n\n#define cwidth 4\n\nvec4 getCell(sampler2D channel,vec2 coord){\n    return texelFetch(channel, ivec2(coord), 0);\n}\n\nvec4 getNeighbour(sampler2D channel,vec2 coord, vec2 offset){\n    return texelFetch(channel, ivec2(coord + offset), 0);\n}\n\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n// calculating local chunk uv \n    vec2 chunk_uv = vec2(int(fragCoord.x) % (width), int(fragCoord.y) % (width));\n    chunk_uv = chunk_uv / float(width);\n    \n    // current active chunk control variable\n    int chunk_step = (iFrame + 2) % (cwidth*cwidth);\n    \n    // calculating chunk coord\n    vec2 chunk_coord = vec2(\n        floor(fragCoord.x / float(width)),\n        floor(fragCoord.y / float(width))\n    );\n    \n    // local coord in chunk \n    vec2 local_coord = vec2(\n        int(chunk_coord.x) % cwidth,\n        int(chunk_coord.y) % cwidth\n\n    );\n    // conveting local_coord to base dim\n    float local_2_base = local_coord.x + local_coord.y * float(cwidth);\n    \n    // active chunk flag\n    bool current_active = int(local_2_base) == chunk_step;  \n    \n    // your logic\n    if(current_active){\n        vec4 currentVal = getCell(iChannel0,fragCoord);\n\n        vec4 neighbourhoodSum = getNeighbour(iChannel0, fragCoord, vec2(-1.0, -1.0))\n                            + getNeighbour(iChannel0, fragCoord, vec2(-1.0,  0.0))\n                            + getNeighbour(iChannel0, fragCoord, vec2(-1.0,  1.0))\n                            + getNeighbour(iChannel0, fragCoord, vec2( 0.0, -1.0))\n                            + getNeighbour(iChannel0, fragCoord, vec2( 0.0,  1.0))\n                            + getNeighbour(iChannel0, fragCoord, vec2( 1.0, -1.0))\n                            + getNeighbour(iChannel0, fragCoord, vec2( 1.0,  0.0))\n                            + getNeighbour(iChannel0, fragCoord, vec2( 1.0,  1.0));\n\n        if (currentVal.r > 0.5 && neighbourhoodSum.g >= 3.0) {\n            fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n        } else if (currentVal.g > 0.5 && neighbourhoodSum.b >= 3.0) {\n            fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n        } else if (currentVal.b > 0.5 && neighbourhoodSum.r >= 3.0) {\n            fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        } else if (currentVal.r > 0.5) {\n            fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        } else if (currentVal.g > 0.5) {\n            fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n        } else if (currentVal.b > 0.5) {\n            fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n        }\n    }else{\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n    \n    \n    \n    \n    \n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"#define width 40\n// speed variable is only for visualising so if you plan to use this remove it\n\n#define cwidth 4\n\nvec4 getCell(sampler2D channel,vec2 coord){\n    return texelFetch(channel, ivec2(coord), 0);\n}\n\nvec4 getNeighbour(sampler2D channel,vec2 coord, vec2 offset){\n    return texelFetch(channel, ivec2(coord + offset), 0);\n}\n\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n// calculating local chunk uv \n    vec2 chunk_uv = vec2(int(fragCoord.x) % (width), int(fragCoord.y) % (width));\n    chunk_uv = chunk_uv / float(width);\n    \n    // current active chunk control variable\n    int chunk_step = (-iFrame - 3) % (cwidth*cwidth) ;\n    \n    // calculating chunk coord\n    vec2 chunk_coord = vec2(\n        floor(fragCoord.x / float(width)),\n        floor(fragCoord.y / float(width))\n    );\n    \n    // local coord in chunk \n    vec2 local_coord = vec2(\n        int(chunk_coord.x) % cwidth,\n        int(chunk_coord.y) % cwidth\n\n    );\n    // conveting local_coord to base dim\n    float local_2_base = local_coord.x + local_coord.y * float(cwidth);\n    \n    // active chunk flag\n    bool current_active = int(local_2_base) == chunk_step;  \n    \n    // your logic\n    if(current_active){\n        vec4 currentVal = getCell(iChannel0,fragCoord);\n\n        vec4 neighbourhoodSum = getNeighbour(iChannel0, fragCoord, vec2(-1.0, -1.0))\n                            + getNeighbour(iChannel0, fragCoord, vec2(-1.0,  0.0))\n                            + getNeighbour(iChannel0, fragCoord, vec2(-1.0,  1.0))\n                            + getNeighbour(iChannel0, fragCoord, vec2( 0.0, -1.0))\n                            + getNeighbour(iChannel0, fragCoord, vec2( 0.0,  1.0))\n                            + getNeighbour(iChannel0, fragCoord, vec2( 1.0, -1.0))\n                            + getNeighbour(iChannel0, fragCoord, vec2( 1.0,  0.0))\n                            + getNeighbour(iChannel0, fragCoord, vec2( 1.0,  1.0));\n\n        if (currentVal.r > 0.5 && neighbourhoodSum.g >= 3.0) {\n            fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n        } else if (currentVal.g > 0.5 && neighbourhoodSum.b >= 3.0) {\n            fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n        } else if (currentVal.b > 0.5 && neighbourhoodSum.r >= 3.0) {\n            fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        } else if (currentVal.r > 0.5) {\n            fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        } else if (currentVal.g > 0.5) {\n            fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n        } else if (currentVal.b > 0.5) {\n            fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n        }\n    }else{\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n    \n    \n    \n    \n    \n}","name":"Buffer D","description":"","type":"buffer"}]}