{"ver":"0.1","info":{"id":"wsS3Dz","date":"1548659837","viewed":802,"name":"Synthetic Dreams","username":"agral","description":"Living the 80's dream","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["synthetic","dreams"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n#define TAU 6.2832\n\n// We're dreaming in neon, baby, and here's every color of that dream:\nvec3 clSkyViolet = vec3(0.106, 0.078, 0.282);\nvec3 clSkyWarmViolet = vec3(0.298, 0.196, 0.388);\nvec3 clSunBase = vec3(0.788, 0.188, 0.729);\nvec3 clSunTip = vec3(0.890, 0.627, 0.675);\nvec3 clGroundBlack = vec3(0.063, 0.051, 0.078);\nvec3 clNetRed = vec3(0.996, 0.058, 0.150);\nvec3 clStarCore = vec3(0.824, 0.769, 0.925);\nvec3 clStarWarm = vec3(0.991, 0.671, 0.246);\nvec3 clHorizonLight = vec3(0.409, 0.292, 0.852);\n\nvec3 pixelColor;\n\nfloat horizonY = 0.6;\nfloat netBaseWidth = 0.005;\nfloat persp_horizon = 0.3;\nfloat sunIrradiance = 9.0;\nvec3 blend(vec3 clA, vec3 clB, float kappa)\n{\n    return vec3(kappa * clA.r + (1.0 - kappa) * clB.r,\n                \t\t   kappa * clA.g + (1.0 - kappa) * clB.g,\n                \t\t   kappa * clA.b + (1.0 - kappa) * clB.b);\n}\n\nvoid drawStar(vec2 fragCoord, float x, float y, float radius, float period, float perturbance)\n{\n    float nx = x * iResolution.x;\n    float ny = y * iResolution.y;\n    float R = 0.01 * radius * iResolution.x;\n\n    float distToCenterSquared = (fragCoord.x - nx) * (fragCoord.x - nx) + (fragCoord.y - ny) * (fragCoord.y - ny);\n    if ( distToCenterSquared < 1.5 * R )\n    {\n        vec3 starColor = blend(clStarCore, clStarWarm, sin(TAU * iTime / period + perturbance));\n        pixelColor = blend(starColor, pixelColor, cos(distToCenterSquared / R));\n    }\n}\n\nvoid drawParallaxLine(vec2 fragCoord, float x1, float y1, float x2, float y2, float width)\n{\n    float a = (y2 - y1) / (x2 - x1);\n    float b = y1 - a * x1;\n    float nx = fragCoord.x / iResolution.x;\n    float ny = fragCoord.y / iResolution.y;\n    \n    // If the point lies within {width} of line (along X axis), it belongs to this line.\n    // Calculates the X index of the point having the same Y coord as curent pixel,\n    // but belonging on the line):\n    float lineX = (ny - b) / a;\n    \n    if (abs(lineX - nx) < width)\n    {\n        pixelColor = clNetRed;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 sun = vec2(iResolution.x / 2.0, iResolution.y);\n    float sunRadius = 0.12 * iResolution.x;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Draws the road:\n    if (uv.y < horizonY)\n    {\n        pixelColor = clGroundBlack;\n        float p = 1.0 - (0.36 * uv.y / horizonY);\n        \n        // Horizontal parts of the net:\n        for (float y = 0.0 - 0.2 * fract(iTime); y < 1.0; y += 0.2)\n        {\n            if (abs(uv.y - (p*y)) < 2.0 * p * netBaseWidth)\n            {\n                float kappa = cos(120.0 * (uv.y - (p*y)));\n                pixelColor = blend(clNetRed, clGroundBlack, kappa);\n            }\n            \n            if (abs(uv.y - (p*y)) < (p*netBaseWidth))\n            {\n                pixelColor = clNetRed;\n            }\n        }\n        \n        // Vertical parts of the net:\n        \n        // This approach is the best I could do using fake-depth method,\n        // the lines are still curved. Iterative (*slow*) approach will have to be used instead.\n        \n        /*float norm_x = mod(200.0 * (uv.x - 0.5) * (1.0 + (0.7 * uv.y)), 30.0);\n        if (norm_x <= 1.0)\n        {\n            pixelColor = blend(clNetRed, clGroundBlack, 0.9);\n        }\n\t\t*/\n        for (float offset = -0.49; offset < 0.51; offset += 0.05)\n        {\n        \tdrawParallaxLine(fragCoord, 0.5 + offset, horizonY, 0.5 + (6.0 * offset), 0.0, netBaseWidth);\n        }\n    }\n    \n    // Draws the sky\n    else\n    {\n        float distSunCenterSquared =\n            ((fragCoord.x - sun.x) * (fragCoord.x - sun.x)) + ((fragCoord.y - sun.y) * (fragCoord.y - sun.y));\n        float sunRadiusSquared = sunRadius * sunRadius;\n        \n        // Determines the final color of the sky (after Sun's irradiation):\n        pixelColor = clSkyViolet;\n        if ((distSunCenterSquared > sunRadiusSquared) &&\n                (distSunCenterSquared < sunIrradiance * sunRadiusSquared))\n        {\n            pixelColor = blend(clSkyViolet, clSkyWarmViolet,\n                    (distSunCenterSquared / (sunIrradiance * sunRadiusSquared)));\n        }\n        \n        // Draws the sun:\n        float sunTipY = sun.y;\n        float sunBaseY = sunTipY - sunRadius;\n\t\tfloat sunPeriod = 9.0;\n        \n        if (distSunCenterSquared < sunRadiusSquared)\n        {\n            \n            if (uv.y != (iResolution.y - 0.5 * sunRadius))\n            {\n                float drag = (1.0 - uv.y) * 1000.0 + 10.0;\n                if (mod(drag, 50.0) >= 5.0)\n                {\n                    float z = 0.45 * cos(TAU * iTime / sunPeriod);\n                    vec3 baseColor = blend(clNetRed, clSunBase, z);\n            \t    float kappa = (fragCoord.y - sunBaseY) / (iResolution.y - sunBaseY);\n                    \n            \t    pixelColor = blend(clSunTip, baseColor, kappa);\n                }\n            }\n        }\n        \n        // Draws a highlight below the horizon line:\n        else if (uv.y - horizonY < 0.05)\n        {\n            vec3 clHorizon = blend(clNetRed, clHorizonLight, 0.21 * sin(TAU * iTime / 7.0));\n            pixelColor = blend(pixelColor, clHorizon, (uv.y - horizonY) / 0.05);\n        }\n        \n        drawStar(fragCoord, 0.02, 0.96, 3.0, 10.0, 0.5);\n        drawStar(fragCoord, 0.11, 0.72, 2.0, 11.0, 0.3);\n        drawStar(fragCoord, 0.15, 0.74, 1.5, 15.0, 0.4);\n        drawStar(fragCoord, 0.16, 0.88, 1.7, 8.0, 0.2);\n        drawStar(fragCoord, 0.23, 0.75, 1.5, 9.5, 0.5);\n        drawStar(fragCoord, 0.24, 0.85, 3.0, 12.0, 1.0);\n        drawStar(fragCoord, 0.35, 0.98, 1.5, 10.0, 0.8);\n        drawStar(fragCoord, 0.38, 0.81, 1.0, 9.0, 0.5);\n        drawStar(fragCoord, 0.68, 0.81, 1.2, 10.0, 0.4);\n        drawStar(fragCoord, 0.76, 0.87, 0.8, 11.3, 0.2);\n        drawStar(fragCoord, 0.78, 0.73, 0.9, 11.5, 0.1);\n        drawStar(fragCoord, 0.81, 0.83, 1.6, 9.7, 0.6);\n        drawStar(fragCoord, 0.85, 0.76, 1.2, 8.7, 0.1);\n        drawStar(fragCoord, 0.88, 0.86, 1.0, 9.2, 0.2);\n        drawStar(fragCoord, 0.92, 0.70, 1.1, 11.3, 0.9);\n        drawStar(fragCoord, 0.93, 0.79,  0.7, 10.4, 1.0);\n        drawStar(fragCoord, 0.935, 0.93, 0.9, 8.8, 0.7);\n        drawStar(fragCoord, 0.95, 0.98, 0.8, 10.9, 0.6);\n        drawStar(fragCoord, 0.98, 0.85, 1.1, 14.3, 0.8);\n    }\n    \n    fragColor = vec4(pixelColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}