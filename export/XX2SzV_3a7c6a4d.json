{"ver":"0.1","info":{"id":"XX2SzV","date":"1710827628","viewed":201,"name":"Shiny Fractal IFS","username":"Fuergu","description":"Press to display depth map.\nFractal IFS, you can change cubemap in BufferB, where the main image is rendered.\nI  use BufferC to maker efractiontimes and fractal_depth adaptative.\nBut if FPS on your PC is under 25fps, the quality will get worse and worse.","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["3d","material"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*converge depth map and color map, to create lense blur*/\n\nfloat calculateClearness(float depth, float center, float range) {\n    float lowerBound = center - range;\n    float upperBound = center + range;\n    float clearness = 0.;\n    if (depth<lowerBound)\n    clearness = smoothstep(1.,0., depth/lowerBound);\n    if (depth>upperBound)\n    clearness = smoothstep(0.,1., map(depth,upperBound,1.,0.,1.));\n    return clearness;\n}\nvec3 blur( int index, vec2 fragCoord )\n{\n    //https://xorshaders.weebly.com/tutorials/blur-shaders-5-part-2\n      vec2 uv = fragCoord/iResolution.xy;\n    // GAUSSIAN BLUR SETTINGS {{{\n    float Directions = 10.; // BLUR DIRECTIONS (Default 16.0 - More is better but slower)\n    float Quality = 4.0; // BLUR QUALITY (Default 4.0 - More is better but slower)\n    float Size = Blur; // BLUR SIZE (Radius)\n    // GAUSSIAN BLUR SETTINGS }}}\n    vec3 Color = vec3(0.);\n    if(index == 0)\n    Color = texture( iChannel0,uv).rgb;\n    if(index == 1)\n    Color = texture( iChannel1,uv).rgb;\n    \n    vec2 Radius = Size/iResolution.xy;\n   \n    // Blur calculations\n    for( float d=0.0; d<TAU; d+=TAU/Directions)\n    {\n\t\tfor(float i=1.0/Quality; i<=1.0; i+=1.0/Quality)\n        {\n            if(index == 0)\n\t\t\tColor += texture( iChannel0, uv+vec2(cos(d),sin(d))*Radius*i).rgb;\t\t\n            if(index == 1)\n\t\t\tColor += texture( iChannel1, uv+vec2(cos(d),sin(d))*Radius*i).rgb;\t\t\n        }\n    }\n    Color /= Quality * Directions - 15.0;\n    return Color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    vec3 meanColor  = blur(0,fragCoord);\n    float depth = texture(iChannel1,uv).r;\n    float clearness = calculateClearness(depth,(clearDistance-minDistance)/(maxDistance-minDistance),DOF/(maxDistance-minDistance));\n    fragColor.rgb = col*(1.-clearness) + meanColor*clearness;\n    //fragColor.rgb =meanColor;\n    if (iMouse.z>0.)\n    fragColor = vec4(vec3(clearness), 1.0f);\n    fragColor.rgb = pow(fragColor.rgb,vec3(1.2));\n    //fragColor = vec4(col, 1.0f);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define Attenuation .01\n#define Dispersion 0.06\n\n#define FresnelReflection vec3(1.000,0.808,0.761)\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n#define S smoothstep\n#define T iTime\nconst float zoom = .1;\nconst float minDistance = 20.;\nconst float maxDistance = 60.;\nconst float clearDistance = 5.;\nconst float DOF = 8.;\nconst float Blur = 10.;\nfloat object(vec3 p, int index)\n{\n    if (index == 5){\n     p = abs(p)-vec3(1.4);\n     return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n    }\n    float c = cos(PI/5.),s = sqrt(0.75-c*c);\n    float size0 = .5;\n    vec3 n = vec3(-.5,-c,s);\n    //fold plane\n    p = abs(p);\n    p -= 2.*min(0.,dot(p,n))*n;\n    p.xy = abs(p.xy);\n    p -= 2.*min(0.,dot(p,n))*n;\n    p.xy = abs(p.xy);\n    p -= 2.*min(0.,dot(p,n))*n;\n    if (index==1){  p.yx = abs(p.xy); size0 = 1.5;  }\n    if (index==2){  p.xz = abs(p.yz); size0 = 1.5;  }\n    if (index==3){  p.zx = abs(p.xz); size0 = .5;size0 =.75;    }\n    if (index==4){  p.xz = abs(p.zy); size0 = .5;size0 = .3;   }\n    p -= 2.*min(0.,dot(p,n))*n;\n    return p.z-size0;\n}\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n  // sampling independent computations (only depend on shape)\n  float w = sqrt(r*r-h*h);\n  \n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                          abs(length(q)-r) ) - t;\n}\nfloat map(float value, float inMin, float inMax, float outMin, float outMax) {\n    return (value - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;\n}\n\nvec3 smoothstep3(vec3 a, vec3 b, float x)\n{\n    vec3 result;\n    result.x = smoothstep(a.x, b.x, x);\n    result.y = smoothstep(a.y, b.y, x);\n    result.z = smoothstep(a.z, b.z, x);\n    return result;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*depth map*/\nfloat sdBoxFrame(vec3 p, vec3 b, float e) {\n    p = abs(p) - b;\n    vec3 q = abs(p + e) - e;\n    return min(min(\n        length(max(vec3(p.x, q.y, q.z), 0.0)) + min(max(p.x, max(q.y, q.z)), 0.0),\n        length(max(vec3(q.x, p.y, q.z), 0.0)) + min(max(q.x, max(p.y, q.z)), 0.0)),\n        length(max(vec3(q.x, q.y, p.z), 0.0)) + min(max(q.x, max(q.y, p.z)), 0.0));\n}\n\nfloat fractal(vec3 p) {\n    float fractal_depth = texture(iChannel3, vec2(1.)).z;\n    float d = sdBoxFrame(p, vec3(0.5), 0.01); \n    for (int i = 0; i < int(fractal_depth); i++) {\n        if (i == 1) p = abs(p) * (3.1 + 0.1 * sin(iTime)) - 2.2;\n        else p = abs(p) * 3.0 - 1.0 + 0.2 * cos(iTime);\n        if (i == 1) d = sdBoxFrame(p, vec3(0.8), 0.08);\n        d = min(d, sdBoxFrame(p, vec3(0.5), 0.08));\n    }\n\n    return d;\n}\n\nfloat GetDist(vec3 p) {\n    p *= 0.1;\n    p.xz *= Rot(T * 0.2);\n    p.xy *= Rot(T * 0.2);\n    \n    p.x -= (iTime / 2.0);\n    p = mod(p, 1.5) - 1.5 / 2.0;\n    float d = fractal(p);\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float side) {\n    float dO = 0.0;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = GetDist(p) * side;\n        dO += dS;\n        if (dO > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    \n    return dO;\n}\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    m=vec2(185.,400.)/vec2(800,450);\n\n    vec3 ro = vec3(0., zoom, 0.);\n    ro.yz *= Rot(-m.y*PI*1.2+1.);\n    ro.xz *= Rot(-m.x*TAU);\n    m = iMouse.xy/iResolution.xy;\n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    \n    float depth = RayMarch(ro, rd, 1.0);\n    \n    vec3 color = vec3(depth / MAX_DIST);\n    \n    fragColor = vec4(color, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*color map*/\nfloat sdBoxFrame(vec3 p, vec3 b, float e) {\n    p = abs(p) - b;\n    vec3 q = abs(p + e) - e;\n    return min(min(\n        length(max(vec3(p.x, q.y, q.z), 0.0)) + min(max(p.x, max(q.y, q.z)), 0.0),\n        length(max(vec3(q.x, p.y, q.z), 0.0)) + min(max(q.x, max(p.y, q.z)), 0.0)),\n        length(max(vec3(q.x, q.y, p.z), 0.0)) + min(max(q.x, max(q.y, p.z)), 0.0));\n}\n\nfloat fractal(vec3 p) {\n    float fractal_depth = texture(iChannel3, vec2(1.)).z;\n    float d = sdBoxFrame(p, vec3(0.5), 0.01); \n    for (int i = 0; i < int(fractal_depth); i++) {\n        if (i == 1) p = abs(p) * (3.1 + 0.1 * sin(iTime)) - 2.2;\n        else p = abs(p) * 3.0 - 1.0 + 0.2 * cos(iTime);\n        if (i == 1) d = sdBoxFrame(p, vec3(0.8), 0.08);\n        d = min(d, sdBoxFrame(p, vec3(0.5), 0.08));\n    }\n\n    return d;\n}\n\nfloat GetDist(vec3 p) {\n    p*=.1;\n    p.xz *= Rot(T*.2);\n    p.xy *= Rot(T*.2);\n    \n    p.x-=(iTime/2.);\n    p = mod(p, 1.5)-1.5/2.;\n    float d = fractal(p);\n    return d;\n    \n}\n\nfloat RayMarch(vec3 ro, vec3 rd,float side) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p)*side;\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.01, 0.);\n    vec3 n = GetDist(p) - \n        vec3(GetDist(p-e.xyy), GetDist(p-e.yxy),GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    m=vec2(185.,400.)/vec2(800,450);\n\n    vec3 ro = vec3(0., zoom, 0.);\n    ro.yz *= Rot(-m.y*PI*1.2+1.);\n    ro.xz *= Rot(-m.x*TAU);\n    m = iMouse.xy/iResolution.xy;\n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = texture(iChannel0,rd).rgb;\n   \n    float d = RayMarch(ro, rd,1.);//raymarch outside the object\n    \n\n   \n    \n    float IOR = 1.5;\n    \n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        vec3 refOutside = texture(iChannel0,r).rgb;\n        vec3 rdIn = refract(rd,n,1./IOR);\n\n    \n    //fresnel\n    vec3 fresnelColor =1.02*vec3(dot(normalize(ro),n)); \n    //vec3 fresnel = vec3(pow(vec3(dot(rd,n))+1.,vec3(.5)));\n    vec3 fresnel = vec3(0.);\n    fresnel = vec3(pow(vec3(dot(rd,n))+1.,normalize(FresnelReflection)));\n    \n    vec3 reflTex = vec3(0.);\n    vec3 reflTexCurrent = vec3(0.);\n    vec3 pEnter = vec3(0.);\n    vec3 pExit = vec3(0.);\n    vec3 glassColor = vec3(1.);\n    float opticalDistence = 0.;\n    float opticalDistance = 0.;\n    float ReflectTimes = texture(iChannel3, vec2(1.)).y;\n    //multiple times reflection inside\n    for (int i=1;i<=int(ReflectTimes);i++){\n        pEnter = p-n*SURF_DIST*3.;\n        float dInside_current = RayMarch(pEnter, rdIn,-1.);\n        pExit = pEnter + rdIn * dInside_current;\n        vec3 nExit = -GetNormal(pExit);\n        \n        //red\n        vec3 rdOut = refract(rdIn,nExit,IOR-1.5*Dispersion);\n        if(dot(rdOut,rdOut)==0.) rdOut = reflect(rdIn,nExit);\n        reflTexCurrent.r = texture(iChannel0,rdOut).r*glassColor.r;\n        //green\n        rdOut = refract(rdIn,nExit,IOR);\n        if(dot(rdOut,rdOut)==0.) rdOut = reflect(rdIn,nExit);\n        reflTexCurrent.g = texture(iChannel0,rdOut).g*glassColor.g;\n        //blue\n        rdOut = refract(rdIn,nExit,IOR+Dispersion);\n        if(dot(rdOut,rdOut)==0.) rdOut = reflect(rdIn,nExit);\n        reflTexCurrent.b = texture(iChannel0,rdOut).b*glassColor.b;\n        \n        \n        //attenuation\n        opticalDistance += dInside_current;\n        float attenuation = exp(-opticalDistance*Attenuation);\n        reflTex += reflTexCurrent*attenuation*pow(.3,float(i-1));\n      \n\n        col = mix(reflTex,refOutside,fresnel*.8);\n        \n        //update\n        rdIn = rdOut;  pEnter = pExit;\n       } \n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// This buffer keeps track of the screen resolution and adapts the number of samples\n// per frame depending on hardware(fps) performaces.\n// It enables Buffer A & B to invalidate previously computed samples in case the screen is\n// resized.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n\tvec2 uv = fragCoord/iResolution.xy;\n    const float KEY_SPACE = 32.5/256.0;\n    vec4 prevParams = texture(iChannel0, uv);\n    bool spacePressed = (texture(iChannel2, vec2(KEY_SPACE, 0.25)).x > 0.1);\n    \n    //refractiontimes\n    if (iFrame == 0||spacePressed||iMouse.w>0.) \n        prevParams.y = 4.;\n    \n    //fractal_depth\n    if (iFrame == 0||spacePressed||iMouse.w>0.) \n        prevParams.z = 8.;\n        \n    fragColor = vec4( 0.,\n                      prevParams.y,\n                      prevParams.z, \n                      1.);\n    \n    // Adaptative samples per frame, updates each 20 frames\n    if (fragColor.w > 0.5 && iFrame%20 == 0) {\n        if (iFrameRate >= 25.0) {\n            fragColor.y = clamp(round(prevParams.y+1.),2.,8.);\n        } else if (iFrameRate <= 15.0 && prevParams.y>=2.) {\n            fragColor.y = clamp(round(prevParams.y-1.),2.,8.);\n            \n        }\n    }\n    \n    if (fragColor.w > 0.5 && iFrame%20 == 0) {\n        if (iFrameRate >= 25.0) {\n            fragColor.z = clamp(round(prevParams.z+1.),2.,10.);\n        } else if (iFrameRate <= 15.0 && prevParams.z>=1.) {\n            fragColor.z = clamp(round(prevParams.z-1.),2.,10.);\n            \n        }\n    }\n    \n    \n}\n","name":"Buffer C","description":"","type":"buffer"}]}