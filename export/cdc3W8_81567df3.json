{"ver":"0.1","info":{"id":"cdc3W8","date":"1723798833","viewed":14,"name":"SphereRendering","username":"nako","description":"test for camera rendering","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Camera {\n    vec3 pos;\n    vec3 target;\n    vec2 size; // width, height\n    float width;\n    float aspect;\n    float workingDistance; //distance from camera to projection plane\n    float fov; //field of view;\n};\n\nCamera initCamera(Camera cam){\n    cam.pos = vec3(0., 0., 100.);\n    cam.target = vec3(0., 0., 0.);\n    cam.size = vec2(80., 50.) ;\n    cam.aspect = cam.size[1]/cam.size[0];\n    return cam;\n}\n\nstruct Sphere{\n    vec3 pos;\n    vec3 col;\n    float radius;\n};\n\nSphere initSphere(Sphere s, vec3 pos, vec3 col, float radius){\n    s.pos = pos;\n    s.col = col;\n    s.radius = radius;\n    return s;\n}\n\nstruct directionalLight{\n    vec3 direction;\n    float strength;\n};\n\ndirectionalLight initLight(directionalLight l){\n    l.direction = vec3(-1., -1., -1.);\n    l.strength = .5;\n    return l;\n}\n\nstruct pointLight{\n    vec3 pos;\n    float strength;\n};\n\npointLight initLight(pointLight l){\n    l.pos = vec3(50., 50., 100);\n    l.strength = 1.;\n    return l;\n}\n\nfloat getDistance(vec3 pos, Sphere s){\n    return distance(pos, s.pos) - s.radius;\n}\n\nvec3 getNormal(vec3 pos, Sphere s){\n    return normalize(pos - s.pos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 bgCol = vec3(0.);\n    Camera cam;\n    cam = initCamera(cam);\n    Sphere s1;\n    s1 = initSphere(s1, vec3(-10.*sin(iTime)-30.,0.,0.), vec3(1.,0.,0.), 25.);\n    Sphere s2;\n    s2 = initSphere(s2, vec3(10.*sin(iTime)+30.,0.,0.), vec3(0.,1.,0.), 25.);\n    directionalLight dl;\n    dl = initLight(dl);\n    pointLight pl;\n    pl = initLight(pl);\n    \n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    //vec2 pixPos = cam.target.xy + cam.size*uv;\n    vec3 ray = normalize(vec3(uv, -1.));\n    \n    vec3 col = bgCol;\n    float t=0.;\n    Sphere s;\n    for(int i=0; i < 99; i++){\n        vec3 pos = cam.pos + t*ray;\n        float dist1 = getDistance(pos, s1);\n        float dist2 = getDistance(pos, s2);\n        if (dist1 < 0.001){\n            s = s1;\n        }\n        else if(dist2 < 0.001){\n            s = s2;\n        }\n        else{\n            t += min(dist1, dist2);\n            continue;\n        }\n            col = s.col;\n            vec3 normal = getNormal(pos, s);\n            //float diffuse = dot(normal, dl.direction)*dl.strength;\n            \n            float diffuse = dot(-1.*normal, normalize(pos-pl.pos))*pl.strength;\n            col *= diffuse;\n            vec3 ray = normalize(vec3(uv, -1.));\n            float specular = dot(-1.*normal,  normalize(ray + normalize(pos-pl.pos)));\n            specular = pow(clamp(specular, 0.0, 1.0), 50.0)*pl.strength;\n            col += specular;\n            break;\n        \n    }\n    \n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"}]}