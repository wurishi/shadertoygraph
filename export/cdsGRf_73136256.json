{"ver":"0.1","info":{"id":"cdsGRf","date":"1666738835","viewed":125,"name":"Ray Marching - Azavier","username":"azavier","description":"Learning to march dem rays sucker","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TEXTURE_MAX_STEPS 100\n#define TEXTURE_MAX_DISTANCE 100.\n#define TEXTURE_SURFACE_DISTANCE 0.01\n\n#define SHADOW_MAX_STEPS 65\n#define SHADOW_MAX_DISTANCE 50.\n#define SHADOW_SURFACE_DISTANCE 0.1\n\n#define AA 1\n\n#define PI 3.1415926538\n\n// Structs\n\nstruct Material {\n  vec3 albedo;\n  float roughness;\n};\nMaterial defaultMaterial = Material(vec3(1), 1.);\nMaterial matteRed = Material(vec3(1, 0, 0), 1.);\nMaterial matteGreen = Material(vec3(0, 1, 0), 1.);\nMaterial matteBlue = Material(vec3(0, 0, 1), 1.);\n\nstruct Sphere {\n  vec4 worldData;\n  Material material;\n};\n\nstruct Box {\n  vec3 worldDataP;\n  vec3 worldDataD;\n  Material material;\n};\n\nstruct RoundedBox {\n  vec3 worldDataP;\n  vec4 worldDataD;\n  Material material;\n};\n\n// SDF functions\n\nfloat SignedSphereDistance(vec3 position, Sphere sphere) { return length(position - sphere.worldData.xyz) - sphere.worldData.w; }\n\nfloat SignedBoxDistance(vec3 position, Box box) { return length(max(abs(position - box.worldDataP) - box.worldDataD, vec3(0))); }\n\nfloat SignedRoundedBoxDistance(vec3 position, RoundedBox box, float r) { return SignedBoxDistance(position, Box(box.worldDataP, box.worldDataD.xyz - box.worldDataD.w, box.material)) - box.worldDataD.w; }\n\n// marching functions\n\n// https://iquilezles.org/articles/smin/\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5*(b - a)/k, 0., 1.);\n  return mix(b, a, h) - k*h*(1. - h);\n}\n\nvec4 SceneDistance(vec3 position) { \n  // SceneDistance returns the closest distance to any object in the scene.\n  // In other words, this is where we build the scene at!\n  vec4 sceneDistance = vec4(0, 0, 0, TEXTURE_MAX_DISTANCE);\n  \n  /// SPHERES \\\\\\\n  \n  Sphere[] spheres = Sphere[]( // Normal spheres\n    Sphere(vec4(1.4, 1, 0, 1), matteRed),\n    Sphere(vec4(3, 0.5, 0, 0.5), matteRed)\n  );\n  Sphere[] negSpheres = Sphere[]( // Inverted spheres for cutting away\n    Sphere(vec4(1.4, 1.5, -0.5, 0.75), defaultMaterial)\n  );\n  \n  for(int i = 0; i < spheres.length(); i++) { // Normal sphere loop\n    float sphereDistance = SignedSphereDistance(position, spheres[i]);\n    \n    // Sphere color\n    if(sphereDistance < sceneDistance.w) sceneDistance.xyz = spheres[i].material.albedo;\n    \n    sceneDistance.w = smin(sphereDistance, sceneDistance.w, 0.5);\n  }\n  for(int i = 0; i < negSpheres.length(); i++) { // Inverted sphere loop\n    float sphereDistance = SignedSphereDistance(position, negSpheres[i]);\n    \n    sceneDistance.w = smin(-sphereDistance, sceneDistance.w, -0.2);\n  }\n  \n  /// BOXES \\\\\\\n  \n  RoundedBox[] boxes = RoundedBox[](\n    RoundedBox(vec3(-1.5, 1.5, 0), vec4(1, 1.5, 1, 0.1), matteGreen),\n    RoundedBox(vec3(-1.5, 0.5, -2), vec4(0.6, 0.5, 2, 0.), matteBlue)\n  );\n  RoundedBox[] negBoxes = RoundedBox[](\n    RoundedBox(vec3(-1.5, 1, -3), vec4(0.9, 0.5, 0.6, 0.3), defaultMaterial),\n    RoundedBox(vec3(-1.5, 2.5, -2), vec4(0.3, 1, 4, 0.2), defaultMaterial)\n  );\n  \n  for(int i = 0; i < boxes.length(); i++) {\n    float boxDistance = SignedRoundedBoxDistance(position, boxes[i], boxes[i].worldDataD.w);\n    \n    // Box color\n    if(boxDistance < sceneDistance.w) sceneDistance.xyz = boxes[i].material.albedo;\n    \n    sceneDistance.w = smin(boxDistance, sceneDistance.w, 0.2);\n  }\n  for(int i = 0; i < negBoxes.length(); i++) {\n    float boxDistance = SignedRoundedBoxDistance(position, negBoxes[i], negBoxes[i].worldDataD.w);\n    \n    sceneDistance.w = smin(-boxDistance, sceneDistance.w, -0.05);\n  }\n\n  /// GROUND \\\\\\\n  \n  // Ground color. set to position.y to indicate that the distance to the ground is the height of the camera. So the ground is y=0\n  if(position.y < sceneDistance.w) sceneDistance.xyz = defaultMaterial.albedo;\n  \n  sceneDistance.w = min(position.y, sceneDistance.w);\n\n  return sceneDistance;\n}\n\nvec4 RayMarch(vec3 rayOrigin, vec3 rayDirection) {\n  vec4 rayDistance;\n  \n  for(rayDistance.w = 0.; rayDistance.w < TEXTURE_MAX_DISTANCE; ) {\n    vec4 sceneDistance = SceneDistance(rayOrigin + rayDirection*rayDistance.w);\n      \n    if(sceneDistance.w < TEXTURE_SURFACE_DISTANCE) {\n      rayDistance.xyz = sceneDistance.xyz;\n      break;\n    }\n      \n    rayDistance.w += sceneDistance.w;\n  }\n\n  return rayDistance;\n}\n\n// surface functions\n\nvec3 SurfaceNormal(vec3 surfacePoint) {\n  vec2 delta = vec2(0.0001, 0);\n\n  vec3 normal = vec3(0);\n  normal.x = SceneDistance(surfacePoint - delta.xyy).w;\n  normal.y = SceneDistance(surfacePoint - delta.yxy).w;\n  normal.z = SceneDistance(surfacePoint - delta.yyx).w;\n  // normal is now the vector representing a nudge of our input vector in distance space (the gradient).\n  normal = SceneDistance(surfacePoint).w - normal;\n  // invert our local \"down\" vector (the gradient) to get the local \"up\" vector (the normal).\n\n  return normalize(normal);\n}\n\nfloat SurfaceShadow(vec3 surfacePoint, vec3 surfaceNormal, vec3 lightsourceDirection, float penumbra) {\n  float lightsourceDistance = length(lightsourceDirection);\n    \n  float surfaceLight = 1.;\n      \n  float rayDistance;\n  for(int i = 0; i < SHADOW_MAX_STEPS; i++) {\n    float sceneDistance = SceneDistance(surfacePoint+surfaceNormal*0.007 + lightsourceDirection*rayDistance).w;\n    \n    if(sceneDistance < 0. || rayDistance > SHADOW_MAX_DISTANCE) break;\n    \n    surfaceLight = min(surfaceLight, smoothstep(0., 1., penumbra*sceneDistance/rayDistance));\n    rayDistance += sceneDistance;\n  }\n  \n  return min(max(surfaceLight, 0.01), 1.);\n}\n\nfloat SurfaceLight(vec3 surfacePoint) {\n  vec3 lightsourcePosition = vec3(0, 4, 0);\n  lightsourcePosition.xz += vec2(sin(iTime), cos(iTime))*4.; // Rotating light\n\n  vec3 lightDirection = normalize(lightsourcePosition - surfacePoint); // Pointing to the lightsource\n  vec3 surfaceNormal = SurfaceNormal(surfacePoint); // Surface normal\n  \n  // Surface Shadows\n  float surfaceLight = clamp(dot(surfaceNormal, lightDirection), 0., 1.); // Diffuse lighting\n\n  // Shadow Casting\n  surfaceLight *= SurfaceShadow(surfacePoint, surfaceNormal, lightDirection, 9.5);\n\n  return surfaceLight;\n}\n\n// drawing the scene\n\n// https://www.shadertoy.com/view/tlKSzK\nvec3 LookAt(vec2 uv, vec3 rayOrigin, vec3 lookPoint){\n    vec3 toVec = normalize(lookPoint-rayOrigin),\n         r = normalize(cross(toVec, vec3(0,1,0))),\n         upVector = cross(r, toVec),\n         c = rayOrigin + toVec,\n         i = c - r*uv.x + upVector*uv.y;\n    \n    return normalize(i-rayOrigin);\n}\n\n\nvec3 PixelColor(vec2 uv) {\n  vec3 surfaceColor;\n  \n  /// CAMERA \\\\\\\n  \n    vec3 rayOrigin = vec3(2, 4, 2);\n    rayOrigin.xz += 5.*vec2(sin(iTime), cos(iTime));\n  \n    vec3 rayDirection = LookAt(uv, rayOrigin, vec3(0, 0, 0));\n    \n  /// SURFACE \\\\\\\n  \n    vec4 sceneDistance = RayMarch(rayOrigin, rayDirection);\n    \n    vec3 surfacePoint = rayOrigin + rayDirection*sceneDistance.w;\n    vec3 surfaceNormal = SurfaceNormal(surfacePoint);\n  \n  /// LIGHTING \\\\\\\n    \n    vec3 surfaceAlbedo = sceneDistance.xyz;\n    float surfaceLighting = SurfaceLight(surfacePoint);\n  \n  return surfaceAlbedo * surfaceLighting;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n  vec3 pixelColor = vec3(0);\n  \n  #if AA > 1\n    vec2 AAO;\n    const float AA_INCREMENT = 1./float(AA);\n    \n    for(AAO.x = -0.5; AAO.x < 0.5; AAO.x += AA_INCREMENT) {\n      for(AAO.y = -0.5; AAO.y < 0.5; AAO.y += AA_INCREMENT) {\n        pixelColor += PixelColor(uv+AAO/iResolution.y);\n      }\n    }\n    pixelColor /= float(AA*AA);\n  #else\n    pixelColor += PixelColor(uv);\n  #endif\n  \n  // Output to screen, apply light gamma-correction (sqrt)\n  fragColor = vec4(sqrt(clamp(pixelColor, 0., 1.)), 1);\n}","name":"Image","description":"","type":"image"}]}