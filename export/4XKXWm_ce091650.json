{"ver":"0.1","info":{"id":"4XKXWm","date":"1720038479","viewed":53,"name":"Heightmap + Jump Flooding","username":"guhcalm","description":"Pre-computing height, normals, and coast distance by jump flooding","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["heightmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PrecomputedHeightmap(uv) texture(iChannel0, uv).w\n#define PrecomputedNormalmap(uv) (texture(iChannel0, uv).rgb * 2. - 1.)\nfloat JumpFlooding(vec2 uv) {\n  float wavesDistance = length(texture(iChannel1, uv).xy);\n  float coastDepth = smoothstep(0., 1., smoothstep(0., 1., clamp(wavesDistance, 0., 15.) / 15.));\n  if (wavesDistance == 0.) return 0.;\n  return abs(sin(wavesDistance - iTime * 2.));\n}\n\nvoid mainImage(out vec4 Pixel, in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  \n  float height = PrecomputedHeightmap(uv);\n  vec3 normal = PrecomputedNormalmap(uv);\n  float jumpFlooding = JumpFlooding(uv);\n  \n  if (uv.x < .33) Pixel = vec4(vec3(height), 1);\n  else if (uv.x < .66) Pixel = vec4(normal, 1);\n  else Pixel = vec4(vec3(jumpFlooding), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define GammaExpansion(color) pow(vec3(color), vec3(2.2))\n#define GammaCompression(color) pow(vec3(color), vec3(1. / 2.2))\n#define saturate(value) clamp(value, 0., 1.)\n\nconst float PLANET_RADIUS = 1.5;\nconst float OCEAN_RADIUS = PLANET_RADIUS - .06;\n\nstruct Ray { vec3 origin; vec3 direction; };\nstruct Geometry { float distance; vec3 position; vec3 normal; };\nstruct Light { vec3 direction; vec3 color; };\nconst float PI = 3.14159265359;\nconst float EPSILON = .001;\nconst float INFINITY = 1. / 0.;\nconst int PATH_TRACE_STEPS = 100;\nLight SUN = Light(normalize(vec3(-1, 1, -1)), vec3(1));\n\nfloat seed;\nfloat random() { return fract(sin(seed += .1) * 4568.7564); }\nfloat random(vec2 uv) { return fract(sin(dot(uv, vec2(127.1, 311.7))) * 4568.7564); }\nvec3 RandomVectorOnHemisphere(vec3 normal) {\n  float u = random();\n  float v = random();\n  float a = 6.283185 * v;\n  float b = u * 2. - 1.;\n  vec3 random = vec3(sqrt(1. - b * b) * vec2(cos(a), sin(a)), b);\n  return normalize(random * sign(dot(normal, random)));\n}\n\nvec2 sphereToUv(vec3 direction) {\n  float phi = atan(direction.z, direction.x);\n  float theta = acos(direction.y);\n  float u = (phi + PI) / (2.0 * PI);\n  float v = theta / PI;\n  return vec2(u, 1. - v);\n}\nvec3 uvToSphere(vec2 uv) {\n  float phi = (uv.x * 2.0 * PI) - PI;\n  float theta = PI * (1.0 - uv.y);\n  float x = sin(theta) * cos(phi);\n  float y = cos(theta);\n  float z = sin(theta) * sin(phi);\n  return vec3(x, y, z);\n}\n\nRay Camera(in vec2 uv, vec3 origin, vec3 target, float aspect, float focalLength) {\n  vec3 ndc = vec3(uv * 2.0 - 1.0, 1.0);\n  const float fov = (60.0 * PI / 180.0);\n  const vec3 up = vec3(0, 1, 0);\n  float f = tan(fov / 2.0);  \n  vec3 screen = vec3(ndc.x * aspect * f, ndc.y * f, ndc.z / f);  \n  float d = sqrt(1.0 + screen.x * screen.x + screen.y * screen.y);\n  float u = screen.x / (screen.z + d * focalLength);\n  float v = screen.y / (screen.z + d * focalLength);\n  vec3 paniniScreen = normalize(vec3(u, v, 1.0));\n  vec3 w = normalize(target - origin);\n  vec3 uAxis = normalize(cross(w, up));\n  vec3 vAxis = normalize(cross(uAxis, w)); \n  return Ray(origin, normalize(mat3(uAxis, vAxis, w) * paniniScreen));\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* Pre-Computing Heightmap */\nfloat N31(vec3 p) { return fract(cos(p.x*25013.+p.y*3539.+p.z*751.)*39863.); }\n\nfloat SmoothNoise3D(vec3 p) {\n  vec3 lv = fract(p);\n  vec3 id = floor(p);\n  lv = lv*lv*(3.-2.*lv);\n    \n  float fbl = N31(id+vec3(0,0,0));\n  float fbr = N31(id+vec3(1,0,0));\n  float fb = mix(fbl, fbr, lv.x);\n    \n  float ftl = N31(id+vec3(0,1,0));\n  float ftr = N31(id+vec3(1,1,0));\n  float ft = mix(ftl, ftr, lv.x);\n    \n  float bbl = N31(id+vec3(0,0,1));\n  float bbr = N31(id+vec3(1,0,1));\n  float bb = mix(bbl, bbr, lv.x);\n    \n  float btl = N31(id+vec3(0,1,1));\n  float btr = N31(id+vec3(1,1,1));\n  float bt = mix(btl, btr, lv.x);\n    \n  float f = mix(fb, ft, lv.y);\n  float b = mix(bb, bt, lv.y);\n    \n  return mix(f,b, lv.z);\n}\n\nfloat SmoothNoise3DDetail(vec3 p) {\n    float c = SmoothNoise3D(p*4.);\n    c += SmoothNoise3D(p*8.)*.5;\n    c += SmoothNoise3D(p*16.)*.25;\n    c += SmoothNoise3D(p*32.)*.125;\n    c += SmoothNoise3D(p*64.)*.0625;\n    c += SmoothNoise3D(p*128.)*.03125;\n    return c/(2.-0.03125);\n}\n\nfloat Heightmap(vec3 direction) {\n  float ws = SmoothNoise3D(direction * 4.);\n  float ns = .1 + SmoothNoise3D(direction*64.)*.5 + SmoothNoise3D(direction*128.)*.25;\n  return ((1. - 4. * (ws * ns)) * .2);\n}\n\nfloat PlanetSDF(vec3 position) {\n  vec3 normal = - normalize(position);\n  float height = Heightmap(normalize(position));\n  return length(position) - (PLANET_RADIUS - height);\n}\n\n#define SDF(p) PlanetSDF(p)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  if (iFrame > 1) discard;\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec3 direction = uvToSphere(uv);\n  Ray camera = Ray(direction * 4.5, -direction);\n  \n  float height = Heightmap(direction);\n  vec3 position = direction * (PLANET_RADIUS - height);\n  vec2 e = vec2(.001, 0);\n  vec3 normal = normalize(vec3(\n    SDF(position + e.xyy) - SDF(position - e.xyy),\n    SDF(position + e.yxy) - SDF(position - e.yxy),\n    SDF(position + e.yyx) - SDF(position - e.yyx)\n  ));\n  \n  fragColor = vec4(normal * .5 + .5, height);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/* Jump Flooding on Heightmap */\n\nvec4 JumpFlooding(ivec2 ij, float seed) {\n  const int STEP_FRAMES = 30;\n  const int N = 9;  \n  int jump_size = (1 << N) >> min(iFrame/STEP_FRAMES, N); \n  float current_dist = 9e9;\n  vec2 current_offset = vec2(0);\n  float current_fill = 0.;\n  if(iFrame == 0) return vec4(0, 0, 0, seed);\n  for(int x = -1; x <= 1; ++x)\n  for(int y = -1; y <= 1; ++y) {\n    ivec2 jump = jump_size * ivec2(x,y);\n    ivec2 coord = ij + jump;\n    if(coord.x < 0 || coord.y < 0 || coord.x >= int(iResolution.x) || coord.y >= int(iResolution.y)) continue;\n    vec4 samp = texelFetch(iChannel1, coord, 0);\n    bool samp_fill = samp.a >= 1.;\n    vec2 samp_offset = samp.rg;\n    vec2 candidate_offset = vec2(jump) + samp_offset;\n    float candidate_dist = length(candidate_offset);\n    if (candidate_dist <= current_dist && samp_fill) {\n      current_dist = candidate_dist;\n      current_offset = candidate_offset;\n      current_fill = 1.;\n    }\n  }\n  return vec4(current_offset, 0., current_fill);\n}\n\n#define PrecomputedHeightmap(uv) texture(iChannel0, uv).w\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  if (iFrame > 600) discard;\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  ivec2 ij = ivec2(fragCoord);\n  float height = PrecomputedHeightmap(uv);\n  float seed = ((PLANET_RADIUS - height) <= OCEAN_RADIUS) ? 0. : 1.;\n  fragColor = JumpFlooding(ij, seed);\n}","name":"Buffer B","description":"","type":"buffer"}]}