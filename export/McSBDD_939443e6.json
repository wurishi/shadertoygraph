{"ver":"0.1","info":{"id":"McSBDD","date":"1724938811","viewed":31,"name":"Desert columns used","username":"KivuSupremeKing","description":"some test of noise, repetition and lights using the iq tutorials. I wanted to make a stone-like pillar.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"lcSBDD","parentname":"Base for future shaders"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nfloat getR(vec3 p)\n{\n    vec2 uv = p.xy + p.yz * 3. + p.zx * 2.;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    float f = 0.;\n\tf  = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n\n\n\tf = 0.5 + 0.5*f;\n\t\n\treturn f;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBoxCorner( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return -1. * (min(q.x, 0.) + min(q.y, 0.) + min(q.z, 0.));\n}\n\nfloat sdRoundBox( vec3 p, vec3 b , float r)\n{\n  float d = sdBox(p, b - vec3(r)) - r * getR(p) * (1.5 + sdBoxCorner(p, b));\n  return d;\n}\n\nfloat map(in vec3 pos)\n{\n    vec3 p = pos;\n    float s = 2.;\n    \n    pos.x = pos.x - s * round(pos.x / s);\n    pos.z = pos.z - s * round(pos.z / s);\n    \n    float d = sdRoundBox(pos - vec3(0., -0.2, 0.), vec3(.2, .4, 0.25), 0.005);\n    float d3 = sdRoundBox(pos - vec3(0., -0.2, 0.), vec3(.25, .4, 0.2), 0.01);\n    float d4 = sdRoundBox(pos - vec3(0., 0., 0.), vec3(.2, 2., 0.2), 0.005);\n    float d5 = sdBox(pos - vec3(0., 2., 0.), vec3(.25, .05, 0.25));\n    \n    pos = p;\n    float d2 = pos.y + .3;\n    \n    return min(min(min(min(d, d2), d3), d4), d5);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(0.0001, 0.);\n    return normalize(vec3(map(pos+e.xyy)-map(pos-e.xyy),\n                          map(pos+e.yxy)-map(pos-e.yxy),\n                          map(pos+e.yyx)-map(pos-e.yyx)));\n}\n\nfloat castRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for (int i = 0; i < 100; i++)\n    {\n        vec3 pos = ro + rd*t;\n        \n        float h = map(pos);\n        \n        if (h < 0.001) break;\n        \n        t += h;\n        if (t >= 20.) break;\n    }\n    if (t > 20.)\n        t = 0.;\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float an = 10. * iMouse.x / iResolution.x;\n\n\n    //raymarching\n    vec3 ta = vec3(0., .0, 0.); //target point\n    vec3 ro = ta + vec3(1.2*sin(an), 0.0, 1.2*cos(an));\n    \n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0., 1., 0.))); // find side\n    vec3 vv = normalize(cross(uu, ww)); //find up\n    \n    vec3 rd = normalize(vec3(uv.x*uu + uv.y*vv + 1.8*ww)); // -1.5 is the near plane position\n    \n    \n    vec3 skyCol = vec3(.4, .75, 1.) - .7*rd.y;\n    skyCol = mix(skyCol, vec3(.7, .75, .8), exp(-10. * rd.y));\n    vec3 col = skyCol;\n    \n    float t = castRay(ro, rd);\n    \n    if (t > 0.) {\n        vec3 pos = ro + rd*t;\n        vec3 normal = calcNormal(pos);\n        vec3 mate = vec3(0.18);\n        \n        vec3 sun_dir = normalize(vec3(.0, .6, .2));\n        float sun_dif = clamp(dot(normal, sun_dir), 0., 1.);\n        float sun_sha = step( castRay(pos + normal * 0.001, sun_dir), 0.0);\n        float sky_dif = clamp(0.5 + 0.5 * dot(normal, vec3(0., 1., 0.)), 0., 1.);\n        float bou_dif = clamp(0.5 + 0.5 * dot(normal, vec3(0., -1., 0.)), 0., 1.);\n        \n        col = mate*vec3(7., 5., 3.) * sun_dif * sun_sha;\n        col += mate*vec3(0.5, .8, 0.9) * sky_dif;\n        col += mate*vec3(0.7, .3, 0.2) * bou_dif;\n    }\n    \n    \n    col = pow(col, vec3(0.4545));\n    \n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}