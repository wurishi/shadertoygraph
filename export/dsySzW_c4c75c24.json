{"ver":"0.1","info":{"id":"dsySzW","date":"1680778737","viewed":41,"name":"dyson_sphere","username":"chabilechab","description":"sphere de dyson","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sun"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// screen resolution\n#define R iResolution.xy\n\n// minimum distance to objects\n#define DIST_MIN 2.\n\n// maximum distance to objects\n#define DIST_MAX 50.0\n\n// max number of steps for the ray-marching\n#define RAY_MARCH_STEPS 100\n\n// consider hit if we reach this distance\n#define RAY_MARCH_PRECI 0.0001\n\n// for ray direction computation\n#define PI 3.14159265359\n\n// ray structure\nstruct Ray {\n    vec3 o; // origin\n    vec3 d; // direction\n};\n\nstruct Surface {\n    float t; // surface distance\n    vec3 c;\n};\n// noise functions\nfloat Hash1d(float u)\n{\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x),\n             mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x),\n             mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\nfloat saturate(float a) { return clamp(a, 0.0, 0.0); }\n\nfloat RustNoise3D(vec3 p)\n{\n    float n = 0.0;\n    float iter = 1.0;\n    float pn = noise(p*0.125);\n    pn += noise(p*0.25)*0.5;\n    pn += noise(p*0.5)*0.25;\n    pn += noise(p*1.0)*0.125;\n    for (int i = 0; i < 7; i++)\n    {\n        //n += (sin(p.y*iter) + cos(p.x*iter)) / iter;\n        float wave = saturate(cos(p.y*0.25 + pn) - 0.998);\n       // wave *= noise(p * 0.125)*1016.0;\n        n += wave;\n        p.xy += vec2(p.y, -p.x) * 0.71;\n        p.xy *=  1.0 / sqrt(1.0 + 0.71*0.71);\n        p.xz += vec2(p.z, -p.x) * 0.71;\n        p.xz *= 1.0 / sqrt(1.0 + 0.71*0.71);\n        iter *= 1.4733;\n    }\n    return n*500.0;\n}\n\n// rotation  \nmat3 rotateX(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// besoin pour le soleil \nvec4 sdSphere(vec3 p, float r, vec3 offset, vec3 col )\n{\n  float d = length(p - offset) - r;\n  return vec4(d, col);\n}\n\n// besoin pour les anneaux de ma sphere\nvec4 sdLink( vec3 p , vec3 offset , vec3 col , mat3 rotate)\n{\np = p*rotate;\nfloat le = 2.;\nfloat r1 = 2.;\nfloat r2 = 0.2;\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.6), p.z );\n  \n  float d = length(vec2(length(q.xy)-r1,q.z)) - r2;\n  return vec4(d,col);\n}\n\nvec4 minWithColor(vec4 obj1, vec4 obj2) {\n  if (obj2.x < obj1.x) return obj2;\n  return obj1;\n}\n\nvec4 sdScene(vec3 p) {\n\n        //variation sphere\n    vec3 t = (p+iTime)*3.;\n    float d = (cos(t.x)*cos(t.y)*cos(t.z)/8.);\n\n        // rotation speed variation\n        \n        float speed1 = cos(iTime*3.);\n        float speed2 = sin(iTime*2.);\n\n  vec4 sphere = sdSphere(p , 1., vec3(-0., 0.5, -2), vec3(0.8888, 0.19, 0.1) )+d;\n  vec4 sLink = sdLink(p+0.1,vec3(-0., 0.5, -2.5),vec3(0., .8, .8),rotateX(iTime*3.)*rotateY(iTime*5.));\n  vec4 sLink2 = sdLink(p,vec3(-0.3, 0.5, -2),vec3(0, .8, .8),rotateZ(speed2)*rotateY(speed2)*rotateX(speed2));\n  vec4 sLink3 = sdLink(p,vec3(-0.3, 0.5, -2),vec3(0, .8, .8),rotateZ(speed1)*rotateY(speed1)*rotateX(speed1));\n\n  \n  vec4 co = minWithColor(sphere, sLink); // co = closest object containing \"signed distance\" and color \n  vec4 co2 = minWithColor(co, sLink2);\n  vec4 co3 = minWithColor(co2, sLink3); \n\n  return co3;\n}\n\nvec4 rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n  vec4 co; // closest object\n\n  for (int i = 0; i < RAY_MARCH_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = sdScene(p);\n    depth += co.x;\n    if (co.x < RAY_MARCH_PRECI || depth > end) break;\n  }\n  \n  vec3 col = vec3(co.yzw);\n\n  return vec4(depth, col);\n}\n\n\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    return normalize(\n      e.xyy * sdScene(p + e.xyy).x +\n      e.yyx * sdScene(p + e.yyx).x +\n      e.yxy * sdScene(p + e.yxy).x +\n      e.xxx * sdScene(p + e.xxx).x);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord / R.xy)*2.-1.;\n    vec2 m = iMouse.xy/R.y;\n    // camera position\n    float DP = 18.;\n    float d = 7.;\n\n  vec3 backgroundColor = vec3(0., 0., 0.);\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0.4*m.x, 0., 7.*m.x); // ray origin that represents camera position\n  //vec3 ro = vec3(0.2*cos(3.*m.x),0.,d*cos((PI/1.)+7.*m.x) );\n  //vec3 ro = vec3(d*cos(4.3*m.x),DP/6.,d*cos((PI/2.)+4.0*m.x) );\n  vec3 rd = normalize(vec3(uv, -1.)); // ray direction\n\n  vec4 co = rayMarch(ro, rd, DIST_MIN, DIST_MAX); // closest object\n\n  if (co.x > DIST_MAX) {\n    col = backgroundColor; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.x; // point on sphere or floor we discovered from ray marching\n    vec3 normal = calcNormal(p);\n    vec3 lightPosition = vec3(2, 2, 7);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    // Calculate diffuse reflection by taking the dot product of \n    // the normal and the light direction.\n    float dif = clamp(dot(normal, lightDirection), 0.5, 1.);\n\n    // Multiply the diffuse reflection value by an orange color and add a bit\n    // of the background color to the sphere to blend it more with the background.\n    col = dif * co.yzw + backgroundColor * .2;\n  }\n//vec4 col2 = texture(iChannel0,uv) ;\n//col2 +=vec4(col,1.);\nvec4 col2 = vec4(col,1.);\n  // Output to screen\n  fragColor = vec4(col2);\n}","name":"Image","description":"","type":"image"}]}