{"ver":"0.1","info":{"id":"sdK3Ry","date":"1631764072","viewed":175,"name":"less complicated hexagon grid","username":"HaleyHalcyon","description":"a","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["grid","hexagon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Instead of generating regular hexagons right away,\n// it generates a hexagon made of 45 degree angles\n// after squishing the input coordinates to get the right proportions.\n// This resulting hexagon will be 2 units wide and 4 units tall,\n// and tiles diagonally at coordinate offset (1, 3).\n\n// square root of 3 because hexagon stuff\n#define SQRT3 (1.7320508)\n\n// converts rgb hex code to a vec3\n#define HEX(x) (vec3((x >> 16) & 255, (x >> 8) & 255, x & 255) / 255.)\n\n// calculate the distance from the center of a hexagon\nfloat hex(vec2 uv) {\n    // loop around to tile\n    uv = abs(\n        mod(\n            uv + vec2(1.0, 3.0),\n            vec2(2.0, 6.0)\n        ) - vec2(1.0, 3.0)\n    );\n    // return whichever is closer:\n    // distance towards the top right side,\n    // or distance towards the right side\n    // (i.e. absolute value of x coordinate)\n    return max(\n        (uv.x + uv.y) / 2.,\n        uv.x\n    );\n}\n\nfloat map(float minv, float maxv, float x) {\n    if (minv == maxv) {return step(minv, x);}\n    return clamp(0., 1., (x - minv) / (maxv - minv));\n}\n\n// map the range [0, 1) to stripes of colors\n// you can change the number of colors by changing the constant here\n// and adding more colors and thresholds\n#define COLOR_COUNT 4\n// mixing sharpness. set to 0.0 to make it pixely\n#define BLEND_FACT 0.02\nvec3 colorize(float value) {\n    const vec3 color[COLOR_COUNT] = vec3[](\n        HEX(0x000000),\n        HEX(0x300060),\n        HEX(0x8000C0),\n        HEX(0xFF66FF)\n    );\n    const float thres[COLOR_COUNT] = float[](\n        0.0, // ignored\n        0.5,\n        0.8,\n        0.95\n    );\n    // loop around\n    value = fract(value);\n    // i don't like using for loops, but it's the best way\n    // i could think of to adapt to any number of colors.\n    vec3 color_out = mix(\n        color[COLOR_COUNT - 1],\n        color[0],\n        map(0.0, BLEND_FACT, value)\n    );\n    for (int i = 1; i < COLOR_COUNT; i++) {\n        if (value > thres[i]) {\n            color_out = mix(\n                color[i - 1],\n                color[i],\n                map(thres[i], thres[i] + BLEND_FACT, value)\n            );\n        } else {\n            return color_out;\n        }\n    }\n    return color_out;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // makes it loop\n    float time = fract(iTime / 2.);\n    // Scales coords so that the diagonals are all a known distance from center\n    vec2 uv = ( 2.* fragCoord - iResolution.xy ) / length(iResolution.xy);\n    // Scales coords to the right proportions, and also scale the hexagons down\n    uv *= vec2(1., SQRT3) * 8.;\n    \n    // time changing colors\n    vec3 col = colorize(\n        // i make 2 rectangle grids, because 1 triangle grid is too hard\n        min(\n            // grid with a hexagon centered at the screen\n            hex(uv),\n            // grid with 4 hexagons surrounding the center\n            hex(uv + vec2(1.0, 3.0))\n        // and finally make the colors shift outward with time\n        ) * 0.5 - time\n    );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}