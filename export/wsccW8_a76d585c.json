{"ver":"0.1","info":{"id":"wsccW8","date":"1600816751","viewed":113,"name":"Sdf Dice test","username":"purrrcy","description":"sdf, dice","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 diePos() {\n    return vec3(0.0, -1.2 + 4.2 * abs(sin(iTime * 2.0)), 0.0);\n}\n\nvec3 dieRot() {\n    return vec3(0.1 * iTime, 2.2 * iTime, 1.2 * iTime); \n}\n    \n\nIntersection trace(vec3 rayOrigin, vec3 rayDirection, float startDepth) {\n    \n    float depth = startDepth;\n    \n    Sdf closest = Sdf(vec3(0.), 0., 0.);\n\n    for (int j = 0; j < 8; ++j) {        \n        for (int i = 0; i < 8; ++i) {\n\n            vec3 marched = rayOrigin + rayDirection * depth;\n\n            Sdf sky = sdfSky(marched);\n            Sdf ground = sdfPlane(marched, vec3(0., 1., 0.), -2.);\n            Sdf sphere = sdfDiceD6(marched, diePos(), 1.4, dieRot());\n\n            closest = sky;\n            closest = pickClosest(closest, sphere);\n            closest = pickClosest(closest, ground);\n\n            depth += closest.dist;\n        }\n\t    if ((closest.dist * closest.dist) < 0.0000001) {\n\t    \treturn Intersection(closest.normal, depth, closest.material);\n    \t}\n    }\n\n    return Intersection(closest.normal, depth, closest.material);\n}\n\nfloat traceShadow(vec3 rayOrigin, vec3 rayDirection, float startDepth) {\n    \n    float distanceToClosest = 100.;\n    float depth = startDepth;\n    float material = 0.;\n    vec3 normal = vec3(0.);\n    \n    for (int i = 0; i < 16; ++i) {\n\n\t\tvec3 marched = rayOrigin + rayDirection * depth;\n\n        Sdf sphere = sdfDiceD6(marched, diePos(), 1.4, dieRot());\n\n        Sdf closest = sphere;\n        \n        depth += closest.dist;\n        distanceToClosest = mix(distanceToClosest, closest.dist, step(closest.dist, distanceToClosest));\n    }    \n      \n    return distanceToClosest;\n}\n\n\nvec3 skyColor(vec3 direction) {\n    vec3 bg = mix(vec3(0.6, 0.7, .8), vec3(0.7, 0.8, .9), direction.y);\n    vec3 sun = mix(vec3(0.), vec3(0.3, 0.2, 0.), direction.x);\n \n\treturn bg + sun;\n}\n\nvec3 colorAtSurface(SurfaceIntersection surf) {\n    const vec3 Cspec = vec3(1., .9, .8);\n\n    //do a single pass SDF soft shadow ray light lookup\n    float distanceToClosest = traceShadow(surf.origin, surf.lightDirection, 1.5);\n    float shadowing = 0.1 + 0.9 * smoothstep(0.1, 0.25, distanceToClosest);\n    \n    vec3 spec = vec3(pow(surf.NdotH, 256.));\n    vec3 directLight = spec * Cspec * shadowing; \n    vec3 indirectLight = mix(skyColor(surf.normal) * 0.2,\n                             vec3(shadowing), \n                             surf.NdotL);\n    \n\treturn directLight + indirectLight;\n}\n\nvec3 colorAt(vec3 rayOrigin, vec3 rayDirection) {\n\n    \n    //find intersection in scene\n    Intersection intersection = trace(rayOrigin, rayDirection, 0.01);\n    if (intersection.material < 1.) {\n    \treturn skyColor(rayDirection);\n    }\n    SurfaceIntersection surf = surface(intersection, rayOrigin, rayDirection);\n    vec3 F = Fresnel(vec3(1.), vec3(1.5, 1.4, 1.5), surf.NdotV);\n    // Fudge in some ground albedo\n\tF += pow(intersection.depth * 0.01, 2.);\n    \n    vec3 T = (1. - F);\n\n    vec3 color = colorAtSurface(surf) * T;\n    Intersection refIntersection = trace(surf.origin, surf.reflectionDirection, .5);\n    if (refIntersection.material < 1.) {\n        color += skyColor(surf.reflectionDirection) * F;\n    } else {\n    \tSurfaceIntersection refSurf = surface(refIntersection, surf.origin, surf.reflectionDirection);\n    \tcolor += colorAtSurface(refSurf) * F;\n    }\n        \n    return color;\n}\n\nvec3 colorAtScreenCoord(vec2 uv) {\n    vec3 ray = normalize(vec3(uv, -1.4));\n    ray = rotateX(ray, -.55 + (iMouse.y / iResolution.y) * 0.75);\n    \n    vec3 origin = vec3(0., 4., 5.);\n    origin = rotateY(origin, -4. * (iMouse.x / iResolution.x) + 2.);\n    ray = rotateY(ray, -4. * (iMouse.x / iResolution.x) + 2.);\n    \n\treturn colorAt(origin, normalize(ray));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2. * (fragCoord.xy / iResolution.xy) - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 color = vec3(0.);\n    // do a silly spiral pattern AA\n    const int spp = 5; \n    const float sppF = 1. / float(spp);\n    for (int i = 0; i < spp; ++i) {\n        float rad = 3.141592 * (float(i) * 2.1 * sppF);\n        vec2 offset = float(i) * (sppF * 3. / iResolution.x) * vec2(cos(rad), sin(rad));\n\t    color += colorAtScreenCoord(uv + offset) * sppF;\n    }\n\tfragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"struct Sdf {\n    vec3 normal;\n    float dist;\n    float material;\n};\n\nvec3 rotateX(vec3 v, float rad) {\n\tfloat c = cos(rad);\n    float s = sin(rad);\n    return vec3(v.x, v.y * c - v.z * s, v.y * s + v.z * c);\n}\n\nvec3 rotateY(vec3 v, float rad) {\n\tfloat c = cos(rad);\n    float s = sin(rad);\n    return vec3(v.x * c + v.z * s, v.y, -v.x * s + v.z * c);\n}\n\nvec3 rotateZ(vec3 v, float rad) {\n\tfloat c = cos(rad);\n    float s = sin(rad);\n    return vec3(v.x * c - v.y * s, v.x * s + v.y * c, v.z);\n}\n \nSdf pickClosest(Sdf a, Sdf b) {\n    float aOrB = step(b.dist, a.dist);\n    return Sdf(mix(a.normal, b.normal, aOrB),\n               mix(a.dist, b.dist, aOrB),\n               mix(a.material, b.material, aOrB));\n}\n\nSdf pickFartherest(Sdf a, Sdf b) {\n    float aOrB = 1. - step(b.dist, a.dist);\n    return Sdf(mix(a.normal, b.normal, aOrB),\n               mix(a.dist, b.dist, aOrB),\n               mix(a.material, b.material, aOrB));\n}\n    \nSdf sdfSky(vec3 point) {\n    float d = length(point);\n\treturn Sdf(point, 60. - d, 0.);\n}\n\nSdf sdfSphere(vec3 point, vec3 origin, float radius) {\n    vec3 po = point - origin;\n    float d = length(po);\n\treturn Sdf(po / d, d - radius, 1.);\n}\n\nSdf sdfBox(vec3 point, vec3 origin, vec3 bounds) {\n    vec3 po = point - origin;\n    vec3 absPo = abs(po);\n\tvec3 q = absPo - bounds;\n  \tfloat d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    vec3 n;\n  \n    float maxPo = max(absPo.x, max(absPo.y, absPo.z));\n    if (abs(po.x) >= maxPo) {\n        n = normalize(vec3(po.x, 0.0, 0.0));\n    }\n    else if (abs(po.y) >= maxPo) {\n        n = normalize(vec3(0.0, po.y, 0.0));\n    }\n    else if (abs(po.z) >= maxPo) {\n        n = normalize(vec3(0.0, 0.0, po.z));\n    }\n    \n\treturn Sdf(n, d, 1.);\n}\n\nSdf sdfDiceD6(vec3 point, vec3 origin, float radius, vec3 rot) {\n    vec3 po = point - origin;\n    po = rotateX(po, rot.x);\n    po = rotateY(po, rot.y);\n    po = rotateZ(po, rot.z);\n    Sdf sphere = sdfSphere(po, vec3(0.0), radius);\n    Sdf box = sdfBox(po, vec3(0.0), vec3(radius * 0.73));\n    // CSG intersection\n    Sdf sdf = pickFartherest(sphere, box);\n    sdf.normal = rotateZ(sdf.normal, -rot.z);\n    sdf.normal = rotateY(sdf.normal, -rot.y);\n    sdf.normal = rotateX(sdf.normal, -rot.x);\n    return sdf;\n}\n\n\nSdf sdfPlane(vec3 point, vec3 normal, float D) {\n    float d = dot(point, normal) - D;\n\treturn Sdf(normal, d, 1.);\n}\n\nstruct Intersection {\n    vec3 normal;\n    float depth;\n    float material;\n};\n\nvec3 Fresnel(vec3 n1, vec3 n2, float NdotV) {\n\tvec3 R0 = (n1 - n2) / (n1 + n2);\n    R0 = R0 * R0;\n    return R0 + (vec3(1.) - R0) * pow(1. - NdotV, 5.);\n}\n\nstruct SurfaceIntersection {\n    vec3 normal;\n    vec3 origin;\n    vec3 reflectionDirection;\n    \n    vec3 lightDirection;\n\n    float NdotL;\n    float NdotV;\n    float HdotL;\n    float HdotV;\n    float NdotH;\n    float LdotR;\n\n};\n\nSurfaceIntersection surface(Intersection i, vec3 rayOrigin, vec3 rayDirection) {\n    const vec3 L = normalize(vec3(3., 2., .0));\n\n    vec3 V = -rayDirection;\n    vec3 H = normalize(L + V);\n\tvec3 R = reflect(rayDirection, i.normal);\n\treturn SurfaceIntersection(i.normal,\n                               rayOrigin + rayDirection * i.depth,\n                               R,\n                               L,\n\t\t\t\t   \t\t\t   max(0., dot(i.normal, L)),\n                   \t\t\t   max(0., dot(i.normal, V)),\n                   \t\t\t   max(0., dot(H, L)),\n                   \t\t\t   max(0., dot(H, V)),\n                               max(0., dot(i.normal, H)),\n                   \t\t\t   max(0., dot(L, R)));\n}\n","name":"Common","description":"","type":"common"}]}