{"ver":"0.1","info":{"id":"stGSRV","date":"1641103369","viewed":383,"name":"Pathfinding","username":"komrad36","description":"- CLICK AND DRAG to move destination\n- SPACE to restart pathfind\n- G to generate random wall configuration\n- C to clear all walls\n- R to reset start and destination\n- CLICK AND DRAG while holding:\n- W to paint walls\n- E to erase walls\n- S to move start","likes":25,"published":1,"flags":48,"usePreview":0,"tags":["pathfinding","path","pathfind","undirected","pathsearch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(vec3(0.82), 1.0);\n    uint size = min(uint(iResolution.x) / kCols, uint(iResolution.y) / kRows);\n    uvec2 xy = uvec2(fragCoord.x, iResolution.y - fragCoord.y);\n    if (any(greaterThanEqual(xy, size * uvec2(kCols, kRows))))\n        return;\n    uvec2 cell = xy / size;\n    uvec2 border = xy % size;\n    border = min(border, size - border);\n    float b = float(min(border.x, border.y));\n    vec4 f = texelFetch(iChannel0, ivec2(cell), 0);\n    vec2 f1 = texelFetch(iChannel1, ivec2(cell), 0).xy;\n    uvec4 t = uvec4(floatBitsToUint(f.x), floatBitsToUint(f.y), floatBitsToUint(f.z), floatBitsToUint(f.w));\n    uvec2 t1 = uvec2(floatBitsToUint(f1.x), floatBitsToUint(f1.y));\n    bool wall = bool(t.x);\n    uint dist = t.y;\n    uint maxDist = t1.x;\n    bool onPath = bool(t1.y);\n    uvec2 start = uvec2((t.w & 0x7fffu) % kCols, (t.w & 0x7fffu) / kCols);\n    uvec2 end = uvec2(((t.w >> 15u) & 0x7fffu) % kCols, ((t.w >> 15u) & 0x7fffu) / kCols);\n    fragColor.xyz = vec3(0.0);\n    fragColor.xyz = dist != 1u << 31 ? vec3(float(dist) / float(maxDist), 0.0, 0.0) : fragColor.xyz;\n    fragColor.xyz = cell == start ? vec3(0.0, 1.0, 0.0) : fragColor.xyz;\n    fragColor.xyz = cell == end ? vec3(1.0, 0.2, 1.0) : fragColor.xyz;\n    fragColor.xyz = onPath ? vec3(0.0, 0.0, 1.0) : fragColor.xyz;\n    fragColor.xyz = wall ? vec3(0.5) : fragColor.xyz;\n    fragColor.xyz = b <= 0.05 * float(size) ? vec3(0.0) : fragColor.xyz;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define F2U(x) floatBitsToUint(x)\n#define U2F(x) uintBitsToFloat(x)\n\nconst uint kCells = kRows * kCols;\nconst float kCellScalar = pow(float(kCells), 0.25);\nconst uint kBlocks = (kCells + 31u) >> 5u;\n\n// fractional representation of sqrt(2) - 1\nconst uint kNumer = 80782u;\nconst uint kDenom = 195025u;\n\n// some devices do not mod large uints correctly\nuint Umod(uint n, uint d)\n{\n    return ((((n >> 16u) % d) << 16u) | (n & 0xFFFFu)) % d;\n}\n\nint Rand(inout uint s, int a, int b)\n{\n\tuint x = s;\n\tx ^= x << 13u;\n\tx ^= x >> 17u;\n\tx ^= x << 5u;\n    s = x;\n    return a + int(Umod(x, uint(b - a + 1)));\n}\n\nbool GenerateWalls(uvec2 xy, uint s, uint iStart, uint iEnd)\n{\n    uint pWalls[kBlocks];\n    for (uint i = 0u; i < kBlocks; ++i)\n        pWalls[i] = 0u;\n\n    int numWalls = Rand(s, int(9.9*kCellScalar), int(10.4*kCellScalar));\n    \n    for (int iWall = 0; iWall < numWalls; ++iWall)\n    {\n        // pick start point\n        uint x = uint(Rand(s, 0, int(kCols - 1u)));\n        uint y = uint(Rand(s, 0, int(kRows - 1u)));\n        \n        // pick direction and prepare traversal\n        int signedDx = Rand(s, -7, 7);\n        int signedDy = Rand(s, -7, 7);\n        int dx = abs(signedDx);\n        int dy = -abs(signedDy);\n        int sx = signedDx > 0 ? 1 : -1;\n        int sy = signedDy > 0 ? 1 : -1;\n        int err = dx + dy;\n        dx <<= 1;\n        dy <<= 1;\n        int allowWall = 0;\n        for (;;)\n        {\n            uint i = y * kCols + x;\n\n            // break if hit edge, hit wall, or small termination probability\n            if (x >= kCols || y >= kRows\n                || (allowWall == 0 && (pWalls[i >> 5] & (1u << (i & 31u))) != 0u)\n                || Rand(s, 0, 1000) < int(155.0/kCellScalar))\n                break;\n\n            pWalls[i >> 5u] |= 1u << (i & 31u);\n\n            // advance wall\n            x += err > 0 ? uint(sx) : 0u;\n            y += err > 0 ? 0u : uint(sy);\n            err += err > 0 ? dy : dx;\n\n            // change direction if small probability\n            if (Rand(s, 0, 1000) < int(1005.0/kCellScalar))\n            {\n                bool updateX = Rand(s, 0, 1000) < 500;\n                int newD = Rand(s, -7, 7);\n                signedDx = updateX ? newD : signedDx;\n                signedDy = updateX ? signedDy : newD;\n                dx = abs(signedDx);\n                dy = -abs(signedDy);\n                sx = signedDx > 0 ? 1 : -1;\n                sy = signedDy > 0 ? 1 : -1;\n                err = dx + dy;\n                dx <<= 1;\n                dy <<= 1;\n                allowWall = 3;\n            }\n            allowWall = max(allowWall - 1, 0);\n        }\n    }\n    \n    pWalls[iStart >> 5u] &= ~(1u << (iStart & 31u));\n    pWalls[iEnd >> 5u] &= ~(1u << (iEnd & 31u));\n    uint i = xy.y * kCols + xy.x;\n    return (pWalls[i >> 5u] & (1u << (i & 31u))) != 0u;\n}\n\nvoid EvalNeighbor(bool diag, uint x, uint y, inout uint f, inout uint parent, inout bool updated)\n{\n    if (x < kCols && y < kRows)\n    {\n        vec2 v = texelFetch(iChannel0, ivec2(x, y), 0).xy;\n        bool wall = bool(F2U(v.x));\n        uint dist = F2U(v.y);\n        if (!wall)\n        {\n            uint candidateF = dist + (diag ? kNumer + kDenom : kDenom);\n            if (candidateF < f)\n            {\n                f = candidateF;\n                parent = y * kCols + x;\n                updated = true;\n            }\n        }\n    }\n}\n\nuint Pathfind(uint x, uint y, inout uint parent, inout bool updated)\n{\n    uint f = F2U(texelFetch(iChannel0, ivec2(x, y), 0).y);\n    EvalNeighbor( true, x - 1u, y - 1u, f, parent, updated);\n    EvalNeighbor(false, x     , y - 1u, f, parent, updated);\n    EvalNeighbor( true, x + 1u, y - 1u, f, parent, updated);\n    EvalNeighbor(false, x - 1u, y     , f, parent, updated);\n    EvalNeighbor(false, x + 1u, y     , f, parent, updated);\n    EvalNeighbor( true, x - 1u, y + 1u, f, parent, updated);\n    EvalNeighbor(false, x     , y + 1u, f, parent, updated);\n    EvalNeighbor( true, x + 1u, y + 1u, f, parent, updated);\n    return f;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    uvec2 xy = uvec2(fragCoord.x, fragCoord.y);\n    if (any(greaterThanEqual(xy, uvec2(kCols, kRows))))\n        return;\n\n    vec4 f = texelFetch(iChannel0, ivec2(xy), 0);\n    uvec4 t = uvec4(F2U(f.x), F2U(f.y), F2U(f.z), F2U(f.w));\n    uint size = min(uint(iResolution.x) / kCols, uint(iResolution.y) / kRows);\n    uvec2 mouseCell = uvec2(iMouse.x, iResolution.y - iMouse.y) / size;\n    bool mouseDown = iMouse.z > 0.0 && all(lessThan(mouseCell, uvec2(kCols, kRows)));\n    bool mouseWall = bool(F2U(texelFetch(iChannel0, ivec2(mouseCell), 0).x));\n    bool eraseWall = mouseDown && texelFetch(iChannel1, ivec2(69, 0), 0).x != 0.0;\n    bool placeWall = mouseDown && !eraseWall && texelFetch(iChannel1, ivec2(87, 0), 0).x != 0.0;\n    bool moveStart = mouseDown && !eraseWall && !placeWall && texelFetch(iChannel1, ivec2(83, 0), 0).x != 0.0;\n    bool moveEnd = mouseDown && !eraseWall && !placeWall && !moveStart;\n    bool restart = false;\n    bool wall = bool(t.x);\n    uint iStart = t.w & 0x7fffu;\n    uint iEnd = (t.w >> 15) & 0x7fffu;\n    uint iMouse = mouseCell.y * kCols + mouseCell.x;\n    uint i = xy.y * kCols + xy.x;\n    if (iFrame == 0)\n    {\n        iStart = kDefaultStartY * kCols + kDefaultStartX;\n        iEnd = kDefaultEndY * kCols + kDefaultEndX;\n        wall = GenerateWalls(xy, 203556u, iStart, iEnd);\n        restart = true;\n    }\n    if (texelFetch(iChannel1, ivec2(82, 0), 0).x != 0.0)\n    {\n        uint iNewStart = kDefaultStartY * kCols + kDefaultStartX;\n        uint iNewEnd = kDefaultEndY * kCols + kDefaultEndX;\n        bool newEndIsWall = F2U(texelFetch(iChannel0, ivec2(kDefaultEndX, kDefaultEndY), 0).x) != 0u;\n        restart = iNewStart != iStart || (iNewEnd != iEnd && newEndIsWall);\n        iStart = iNewStart;\n        iEnd = iNewEnd;\n        if (min(i - iStart, i - iEnd) == 0u)\n            wall = false;\n    }\n    if (moveStart && !mouseWall && iMouse != iStart)\n    {\n        iStart = iMouse;\n        restart = true;\n    }\n    if (moveEnd && !mouseWall)\n    {\n        iEnd = iMouse;\n    }\n    if (placeWall)\n    {\n        if (all(lessThan(xy - mouseCell, uvec2(2))) && i != iStart && i != iEnd)\n            wall = true;\n        restart = true;\n    }\n    if (eraseWall)\n    {\n        if (xy == mouseCell)\n            wall = false;\n        restart = true;\n    }\n    if (texelFetch(iChannel1, ivec2(67, 1), 0).x != 0.0)\n    {\n        wall = false;\n        restart = true;\n    }\n    if (iFrame != 0 && texelFetch(iChannel1, ivec2(71, 1), 0).x != 0.0)\n    {\n        wall = GenerateWalls(xy, floatBitsToUint(iTime), iStart, iEnd);\n        restart = true;\n    }\n    if (texelFetch(iChannel1, ivec2(32, 1), 0).x != 0.0)\n    {\n        restart = true;\n    }\n\n    t.x = wall ? 1u << 30u : 0u;\n    bool updated = false;\n    t.y = Pathfind(xy.x, xy.y, t.z, updated);\n    if (restart)\n    {\n        t.y = i == iStart ? 0u : 1u << 31;\n        t.z = 1u << 31;\n        updated = true;\n    }   \n    t.w = (1u << 30) | (updated ? 1u << 31 : 0u) | (iEnd << 15u) | iStart;\n    fragColor = vec4(U2F(t.x), U2F(t.y), U2F(t.z), U2F(t.w));\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const uint kRows = 50u;\nconst uint kCols = 80u;\n\nconst uint kDefaultStartX = 11u;\nconst uint kDefaultStartY = 8u;\n\nconst uint kDefaultEndX = (kCols - 1u) - kDefaultStartX;\nconst uint kDefaultEndY = (kRows - 1u) - kDefaultStartY;\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    uvec2 xy = uvec2(fragCoord.x, fragCoord.y);\n    if (any(greaterThanEqual(xy, uvec2(kCols, kRows))))\n        return;\n    \n    uint updated = 0u;\n    uint maxDist = 0u;\n    for (uint y = 0u; y < kRows; ++y)\n    {\n        for (uint x = 0u; x < kCols; ++x)\n        {\n            uint dist = floatBitsToUint(texelFetch(iChannel0, ivec2(x, y), 0).y);\n            if (dist != 1u << 31 && dist > maxDist)\n                maxDist = dist;\n            updated |= floatBitsToUint(texelFetch(iChannel0, ivec2(x, y), 0).w);\n        }\n    }\n\n    bool onPath = false;\n    if (!bool(updated >> 31u))\n    {\n        uint t = floatBitsToUint(texelFetch(iChannel0, ivec2(0), 0).w);\n        uint start = t & 0x7fffu;\n        uint x = ((t >> 15u) & 0x7fffu) % kCols;\n        uint y = ((t >> 15u) & 0x7fffu) / kCols;\n        uint i = xy.y * kCols + xy.x;\n        uint parent = floatBitsToUint(texelFetch(iChannel0, ivec2(x, y), 0).z);\n        for (uint j = 0u; parent != 1u << 31 && parent != start && j < kRows * kCols; ++j)\n        {\n            onPath = parent == i ? true : onPath;\n            parent = floatBitsToUint(texelFetch(iChannel0, ivec2(parent % kCols, parent / kCols), 0).z);\n        }\n    }\n    fragColor = vec4(uintBitsToFloat(maxDist), onPath ? 1.0 : 0.0, 0.0, 1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}