{"ver":"0.1","info":{"id":"MfcGR2","date":"1711892200","viewed":42,"name":"TP3 Ombres","username":"LiQiye","description":"HardShadow + SoftShadow + Ambiant Occlusion","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["shadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Modeling - 2024.02.06\n// Eric Galin\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 Rz(float a)\n{\n  float sa=sin(a);float ca=cos(a);\n  return mat3(ca,sa,0.,-sa,ca,0.,0.,0.,1.);\n}\n\nstruct Ray {\nvec3 ro; // Ray origin\nvec3 rd; // Direction\n};\n\nstruct N{\n  float dist;\n  vec3 normal;\n};\n\nvec3 changeLength(vec3 v,float len){\n  return (len/length(v))*v;\n}\n// Compute a point on the ray\n// ray : Ray\n// t   : depth\nvec3 Point(Ray ray,float t)\n{\n  return ray.ro+t*ray.rd;\n}\n\n// Compute the ray\n//     m : Mouse position\n//     p : Pixel\nRay CreateRay(vec2 m,vec2 p)\n{\n  float a=3.*3.14*m.x; \n  float le=3.5;\n  \n  // Origin\n  vec3 ro=vec3(35.,0.,10.)*Rz(a);\n  \n  // Target point\n  vec3 ta=vec3(0.,0.,3.);\n  \n  // Orthonormal frame\n  vec3 w=normalize(ta-ro);\n  vec3 u=normalize(cross(w,vec3(0.,0.,1.)));\n  vec3 v=normalize(cross(u,w));\n  vec3 rd=normalize(p.x*u+p.y*v+le*w);\n  return Ray(ro,rd);\n}\n\n\nvec3 getNormal(vec3 CommonPoint, vec3 r, vec3 s) {\n    vec3 rb = r - CommonPoint;\n    vec3 sb = s - CommonPoint;\n    return cross(rb, sb);\n}\n\n\n\nfloat sqr(float a){\n  return a*a;\n}\n\nvec3 getNormal(vec3 d1, vec3 d2) {\n    vec3 n = cross(d1, d2); \n    n = normalize(n); \n    float length_d1 = length(d1);\n    return n * length_d1;\n}\n\nvec3 getNormalTowards(vec3 a,vec3 b,vec3 c,vec3 posDot){\n  vec3 v1=a-b;\n  vec3 v2=c-b;\n  vec3 normal=getNormal(v1,v2);\n  vec3 vpos=posDot-b;\n  if(dot(vpos,normal)<0.0){\n    normal*=-1.;\n  }\n  return normal;\n}\n\nvec3 getNormalTowards(vec3 a,vec3 normal,vec3 posDot){\n  vec3 vpos=posDot-a;\n  if(dot(vpos,normal)<0.0){\n    normal*=-1.;\n  }\n  return normal;\n}\n\nvec3 getNormalOpp(vec3 a,vec3 b,vec3 c,vec3 posDot){\n  vec3 v1=a-b;\n  vec3 v2=c-b;\n  vec3 normal=getNormal(v1,v2);\n  vec3 vpos=posDot-b;\n  if(dot(vpos,normal)>0.0){\n    normal*=-1.;\n  }\n  return normal;\n}\n\nvec3 getNormalOpp(vec3 a,vec3 normal,vec3 posDot){\n  vec3 vpos=posDot-a;\n  if(dot(vpos,normal)>0.0){\n    normal*=-1.;\n  }\n  return normal;\n}\n\nbool abovePlane(vec3 point,vec3 planePoint,vec3 normal){\n  vec3 v=point-planePoint;\n  return dot(v,normal)>=0.0;\n}\n\nvec3 getNormal(vec3 v) {\n    float l = length(v);  \n    vec3 n = cross(vec3(1, 0, 0),v);  \n    if (length(n) < 0.01) {  \n        n = cross(v, vec3(0, 0, 1));\n    }\n    return changeLength(n,l);  \n}\n\nfloat getAngleDegrees(vec3 v1, vec3 v2) {\n    return degrees(acos(dot(v1, v2) / (length(v1) * length(v2))));\n}\nfloat getAngleRadians(vec3 v1, vec3 v2) {\n    return radians(acos(dot(v1, v2) / (length(v1) * length(v2))));\n}\n\nvec3 getProjectionVector(vec3 v, vec3 u) {\n  u=normalize(u);\n  return dot(v,u)*u;\n}\n\nvec3 getRejectionVector(vec3 v, vec3 u) {\n  return v-getProjectionVector(v,u);\n}\n\nbool isBetweenPoints(vec3 p,vec3 a,vec3 b){\n    vec3 u1 = normalize(b - a);\n    vec3 PA=p-a;\n    float proja=dot(PA,u1);\n    vec3 PB=p-b;\n    float projb=dot(PB,u1);\n    return proja*projb<0.;\n}\n\nbool inCircleAxe(vec3 p,vec3 center,vec3 normal,float radius){\n  vec3 v=p-center;\n  vec3 rejection=getRejectionVector(v,normal);\n  return length(rejection)<=radius;\n}\n// Operators\n\n// Union\n// a,b : field function of left and right sub-trees\nN Union(N a,N b)\n{\n  if(a.dist>b.dist)return b;\n  else return a;\n}\n\n// Union, extension to four sub-trees\n// a,b,c : field function of left and right sub-trees\nfloat Union(float a,float b,float c,float d)\n{\n  return min(min(a,b),min(c,d));\n}\n\n// Difference\n// a,b : field function of left and right sub-trees\nN Difference(N a,N b)\n{\n  if(a.dist>-b.dist){\n    return a;\n  }\n  else {b.dist*=-1.0;\n  b.normal*=-1.0;\n  }\n  return b;\n}\n\nN Intersect(N a,N b){\n  if(a.dist>b.dist)return a;\n  else return b;\n}\n\n\n\n\n// Primitives\n\n// Sphere\n// p : point\n// c : center of skeleton\n// r : radius\nN Sphere(vec3 p,vec3 c,float r)\n{\n  return N(length(p-c)-r,normalize(p-c));\n}\n\n//distance à un segment\nN Segment(vec3 p, vec3 a, vec3 b) {\n    float distA=distance(p,a);\n    vec3 u1 = normalize(b - a);\n    vec3 PA=p-a;\n    float proja=dot(PA,u1);\n    if(isBetweenPoints(p,a,b)){\n      vec3 vec=getRejectionVector(p-a,u1);\n        return N(length(vec),vec);\n    }\n    else{\n      float distB=distance(p,b); \n      if(distA<distB){\n        return N(distA,p-a);\n      }\n      else return N(distB,p-b);\n    } \n}\n\nN signedPlane(vec3 p,vec3 c, vec3 normal) {\n  vec3 cp=p-c;\n  float resDot=dot(cp,normal);\n  float len=length(getProjectionVector(cp,normal));\n  if(resDot>=0.){\n    return N(len,normal);\n  }\n  else return N(-len,normal);\n}\n//Renvoie un plan sans épaisseur\nN Plane(vec3 p, vec3 c, vec3 normal) {\n  vec3 pc=p-c;\n  return N(length(getProjectionVector(pc,normal)),normal);\n}\n\n//Renvoie un plan très fin\nN ThinPlane(vec3 p, vec3 c, vec3 normal){\n  return N(Plane(p,c,normal).dist-0.5,normal);\n}\n\n//Distance à un segment avec épaisseur\nN Capsule(vec3 p, vec3 center1, vec3 center2, float radius) {\n  N caps=Segment(p,center1,center2);\n  caps.dist-=radius;\n  return caps;\n}\n\n\nN Disc(vec3 p, vec3 center, vec3 normal, float radius) {\n  vec3 hypotenuse=p-center;\n  if(inCircleAxe(p,center,normal,radius)){\n      return Plane(p,center,normal);\n  }\n  vec3 parallel=getRejectionVector(hypotenuse,normal);\n   return N(distance(p,center+changeLength(parallel,radius)),normal); \n}\n//Distance à un disque si en dehors des 2 points sinon au segment-radius;\nN Cylinder(vec3 p, vec3 center1, vec3 center2, float radius) { \n    vec3 axis = center1 - center2;\n    if(isBetweenPoints(p,center1,center2)){\n      N a= Segment(p,center1,center2);\n      a.dist-=radius;\n      return a;\n    }\n    else {\n      N b=Disc(p,center1,axis,radius);\n      N c=Disc(p,center2,-axis,radius);\n      if(b.dist<c.dist){\n        return N(b.dist-0.01,b.normal);\n      }\n      else return N(c.dist-0.01,c.normal);\n    }\n}\n\n// Potential field of the object\n// p : point\nN object(vec3 p)\n{\n\n  N cyl=Cylinder(p,vec3(0,0,2),vec3(2,0,10),3.);\n  N b=Sphere(p,vec3(1,2,6),4.5);\n  N v=Difference(cyl,b);\n  N caps=Capsule(p,vec3(3,3,6),vec3(3,-3,6),2.);\n  v=Union(caps,v);\n  v=Union(v,\n    ThinPlane(p,vec3(0.,0.,-1.),vec3(0.,0.0,1.0))\n  );\n  \n  return v;\n}\n\nfloat Shadow(vec3 p,vec3 lightPoint){\n    vec3 dir=p-lightPoint;\n    float dist=distance(p,lightPoint);\n    bool hit=false;\n    float minStep=0.25;\n    vec3 advancement=lightPoint;\n    float longueur;\n    while(distance(advancement,lightPoint)<dist){\n      longueur=object(advancement).dist;\n      if(longueur<-0.01){\n        hit=true;\n        break;\n      }\n      else advancement+=changeLength(dir,max(longueur,minStep));\n    }\n    if(hit)return 0.0;\n    else return 1.0;\n}\n\nvec3 Fibonacci(int nbPts, int index) {\n    float goldenRatio = (1.0 + sqrt(5.0)) / 2.0;\n    float theta = 2.0 * 3.14 * float(index) / goldenRatio;\n    float phi = acos(1.0 - 2.0 * float(index) / float(nbPts));\n    return vec3(cos(theta) * sin(phi), sin(theta) * sin(phi), cos(phi));\n}\n\n//returns all the points within the hemisphere\nvec3 Hemisphere(int nbPts,int index){\n  return normalize(Fibonacci(nbPts,index));\n}\n\n\nfloat SoftShadow(vec3 p, vec3 lightPoint, float radius) {\n    int nbPts = 50;\n    int nbHits = 0;\n    for (int i = 0; i < nbPts; ++i) {\n        vec3 a = changeLength(Fibonacci(nbPts, i), radius);\n        if (Shadow(p, lightPoint + a) > 0.1) { // Assuming Shadow returns a float between 0.0 and 1.0\n            nbHits++;\n        }\n    }\n    return float(nbHits) / float(nbPts);\n}\n\nfloat Occlusion(vec3 p, vec3 normal) {\n    int nbPts = 50;\n    int nbHits = 0;\n    int nbSup=0;\n    for (int i = 0; i < nbPts; ++i) {\n        vec3 a =changeLength(Hemisphere(nbPts, i),3.);\n        if (dot(normal, a) > 0.0){\n          nbSup++;\n          if(Shadow(p, p + a) > 0.0) {\n            nbHits++;\n          }\n        }\n    }\n    return 1.-(float(nbHits)) / float(nbSup);\n}\n\n// Analysis of the scalar field\n\nconst int Steps=200;// Number of steps\nconst float Epsilon=.01;// Marching epsilon\n\n// Object normal\n// p : point\nvec3 ObjectNormal(vec3 p)\n{\n  const float eps=.001;\n  vec3 n;\n  N v=object(p);\n  n.x=object(vec3(p.x+eps,p.y,p.z)).dist-v.dist;\n  n.y=object(vec3(p.x,p.y+eps,p.z)).dist-v.dist;\n  n.z=object(vec3(p.x,p.y,p.z+eps)).dist-v.dist;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// ray : Ray \n// e : Maximum distance\n// h : hit\n// s : Number of steps\nfloat SphereTrace(Ray ray,float e,out bool h,out int s)\n{\n  h=false;\n  \n  // Start at the origin\n  float t=0.;\n  \n  for(int i=0;i<Steps;i++)\n  {\n    s=i;\n    vec3 p=Point(ray,t);\n    float v=object(p).dist;\n    // Hit object\n    if(v<0.)\n    {\n      h=true;\n      break;\n    }\n    // Move along ray\n    t+=max(Epsilon,v);\n    // Escape marched too far away\n    if(t>e)\n    {\n      break;\n    }\n  }\n  return t;\n}\n\n// Lighting\n\n// Background color\n// d : Ray direction\nvec3 Background(vec3 d)\n{\n  return mix(vec3(.45,.55,.99),vec3(.65,.69,.99),d.z*.5+.5);\n}\n\n// Shading and lighting\n// p : Point\n// n : Normal at point\n// e : Eye direction\nvec3 Shade(vec3 p,vec3 n,vec3 e)\n{\n  // Point light\n  const vec3 lp=vec3(10.,20.,30.);\n  \n  // Light direction to point light\n  vec3 l=normalize(lp-p);\n  N obj=object(p);\n  // Ambient color\n  vec3 ambient=.25+.25*Background(n);\n  \n  // Shadow computation\n  float shadow=Occlusion(p,obj.normal)+SoftShadow(p,lp,5.);\n  // Phong diffuse\n  vec3 diffuse=.35*clamp(dot(n,l),0.,1.)*vec3(1.,1.,1.);\n  \n  // Specular\n  vec3 r=reflect(e,n);\n  vec3 specular=.15*pow(clamp(dot(r,l),0.,1.),35.)*vec3(1.,1.,1.);\n  vec3 c=ambient+shadow*(diffuse+specular);\n  return c;\n}\n\n// Image\nvoid mainImage(out vec4 color,in vec2 pxy)  \n{\n  // Pixel\n  vec2 pixel=(-iResolution.xy+2.*pxy)/iResolution.y;\n\n  // Mouse\n  vec2 m=iMouse.xy/iResolution.xy;\n  \n  // Camera\n  Ray ray=CreateRay(m,pixel);\n  \n  \n  // Hit and number of steps\n  bool hit;\n  int s;\n  \n   // Trace ray\n float t=SphereTrace(ray,75.,hit,s);\n  \n  // Shade background\n  vec3 rgb=Background(ray.rd);\n  \n  if(hit)\n  {\n    // Position\n    vec3 p=Point(ray,t);\n    \n    // Compute normal\n    vec3 n=ObjectNormal(p);\n    \n    // Shade object with light\n    rgb=Shade(p,n,ray.rd);\n  }\n    \n  color=vec4(rgb,1.);\n}\n","name":"Image","description":"","type":"image"}]}