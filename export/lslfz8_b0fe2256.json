{"ver":"0.1","info":{"id":"lslfz8","date":"1494913984","viewed":511,"name":"Harris corner detector2","username":"c_z_y","description":"Harris corner detector\nhttps://en.wikipedia.org/wiki/Corner_detection","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["2d","computervision"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat boost = 10.0;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float h = texture(iChannel0,uv).x*boost;\n    float g = texture(iChannel1,uv).a;\n    \n    fragColor = vec4(h+g,g,g,1.0);\n    \n    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\ncaculate Partial derivative in u and u direction.\n\noutput as rgba buffer, which \nr = square derivative in u direction\ng = square derivative in v direction\nb = (derivative in u ) * (derivative in v)\na = gray value of origin image\n\n*/\n\n\nfloat[3] FilterForDerivat = float[3](-1.0,0.0,1.0); \n\nfloat gray(vec4 color)\n{\n\tfloat _gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));\n    return _gray;\n}\n\nvec4 filterHorizon(vec2 uv,vec2 uvPixelSize)\n{\n\tvec4 color1 = texture(iChannel0,uv-vec2(uvPixelSize.x,0.0));\n    vec4 color2 = texture(iChannel0,uv+vec2(uvPixelSize.x,0.0));\n    return -color1+color2;\n}\nvec4 filterVertical(vec2 uv,vec2 uvPixelSize)\n{\n    vec4 color1 = texture(iChannel0,uv-vec2(0.0,uvPixelSize.y));\n    vec4 color2 = texture(iChannel0,uv+vec2(0.0,uvPixelSize.y));\n    return -color1+color2;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvPixelSize =  1.0 / iResolution.xy;\n    vec4 origin = texture(iChannel0,uv);\n    \n    vec4 Cx = filterHorizon(uv,uvPixelSize);\n    vec4 Cy = filterVertical(uv,uvPixelSize);\n    \n    float Ix = gray( Cx );\n    float Iy = gray(Cy );\n    float Ixy = Ix*Iy;\n    fragColor.xyz = vec3(Ix*Ix,Iy*Iy,Ixy);\n    fragColor.a = gray(origin);\n}\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n/*\n\nmake gaussian smooth on the Partial derivative.\n\ngaussian kernal = 5 x 5\n \n\n*/\n\n\n\n\nfloat[] gaussian = float[](.003, .013, .022, .013, .003,\n            .013, .059, .097, .059, .013,\n            .022, .097, .159, .097, .022,\n            .013, .059, .097, .059, .013,\n            .003, .013, .022, .013, .003);\nint gaussianKernelSize = 5;\n\nvec4 gaussianFilter(vec2 uv)\n{\n\n    vec4 sumValue=vec4(0.0);\n    vec4 c;float g; \n\n    sumValue += textureLodOffset(iChannel0,uv,0.0,ivec2(-2,-2))*gaussian[0];\n    sumValue += textureLodOffset(iChannel0,uv,0.0,ivec2(-1,-2))*gaussian[1];\n    sumValue += textureLodOffset(iChannel0,uv,0.0,ivec2(-0,-2))*gaussian[2];\n    sumValue += textureLodOffset(iChannel0,uv,0.0,ivec2(+1,-2))*gaussian[3];\n    sumValue += textureLodOffset(iChannel0,uv,0.0,ivec2(+2,-2))*gaussian[4];\n    sumValue += textureLodOffset(iChannel0,uv,0.0,ivec2(-2,-1))*gaussian[5];\n    sumValue += textureLodOffset(iChannel0,uv,0.0,ivec2(-1,-1))*gaussian[6];\n    sumValue += textureLodOffset(iChannel0,uv,0.0,ivec2(-0,-1))*gaussian[7];\n    sumValue += textureLodOffset(iChannel0,uv,0.0,ivec2(+1,-1))*gaussian[8];\n    sumValue += textureLodOffset(iChannel0,uv,0.0,ivec2(+2,-1))*gaussian[9];\n    sumValue += textureLodOffset(iChannel0,uv,0.0,ivec2(-2,-0))*gaussian[10];\n    sumValue += textureLodOffset(iChannel0,uv,0.0,ivec2(-1,-0))*gaussian[11];\n    sumValue += textureLodOffset(iChannel0,uv,0.0,ivec2(-0,-0))*gaussian[12];\n    sumValue += textureLodOffset(iChannel0,uv,0.0,ivec2(+1,-0))*gaussian[13];\n    sumValue += textureLodOffset(iChannel0,uv,0.0,ivec2(+2,-0))*gaussian[14];\n    sumValue += textureLodOffset(iChannel0,uv,0.0,ivec2(-2,+1))*gaussian[15];\n    sumValue += textureLodOffset(iChannel0,uv,0.0,ivec2(-1,+1))*gaussian[16];\n    sumValue += textureLodOffset(iChannel0,uv,0.0,ivec2(-0,+1))*gaussian[17];\n    sumValue += textureLodOffset(iChannel0,uv,0.0,ivec2(+1,+1))*gaussian[18];\n    sumValue += textureLodOffset(iChannel0,uv,0.0,ivec2(+2,+1))*gaussian[19];\n    sumValue += textureLodOffset(iChannel0,uv,0.0,ivec2(-2,+2))*gaussian[20];\n    sumValue += textureLodOffset(iChannel0,uv,0.0,ivec2(-1,+2))*gaussian[21];\n    sumValue += textureLodOffset(iChannel0,uv,0.0,ivec2(-0,+2))*gaussian[22];\n    sumValue += textureLodOffset(iChannel0,uv,0.0,ivec2(+1,+2))*gaussian[23];\n    sumValue += textureLodOffset(iChannel0,uv,0.0,ivec2(+2,+2))*gaussian[24];    \n    \n    return sumValue;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    fragColor = gaussianFilter(uv);\n    fragColor.a = texture(iChannel0,uv).a;\n}\n","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*\ncaculate corner as red pixel.\nswitch evaluate methode through define \"EvalValue\" :\n\n//use harris methode\n#define EvalValue Harris  \n\n //use ShiTomasi methode \n#define EvalValue ShiTomasi\n\nplase change threshold after changing methode.\n*/\n\n#define EvalValue ShiTomasi\n\n\n\nfloat threshold = 0.0005;//0.000008\nfloat alpha = 0.04;\n\nfloat Harris(float Ix2, float Iy2 , float Ixy ,float aa)\n{\n\tfloat _trace = Ix2+Iy2;\n    float det = Ix2*Iy2-Ixy*Ixy;    \n    float h = (det) - aa*(_trace)*(_trace); \n    return h;\n}\nfloat ShiTomasi(float Ix2, float Iy2 , float Ixy ,float aa)\n{\n    /*\n    float a = 1.0;\n    float b = Ix2+Iy2;\n    float c = Ix2*Iy2-Ixy*Ixy;\n    float sq = sqrt(b*b-4.0*c);\n    \n    float n1 = (b+sq)/(2.0);\n    float n2 = (b-sq)/(2.0);\n\t*/\n    \n    float T = Ix2+Iy2;\n    float D = Ix2*Iy2-Ixy*Ixy;\n    \n    float sq = sqrt(T*T/4.0-D);\n    \n    float n1 = T*0.5+sq;\n    float n2 = T*0.5-sq;\n    \n    return min(n1,n2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvPixelSize =  1.0 / iResolution.xy;\n    vec4 t = texture(iChannel0,uv);\n    \n    float Ix2 = t.x;\n    float Iy2 = t.y;\n    float Ixy = t.z;\n    \n   \n    \n    float h = EvalValue(Ix2,Iy2,Ixy,alpha);    \n    \n    //fragColor.rgb = vec3(step(threshold,h));\n    fragColor.rgb = vec3(step(threshold,h));\n    fragColor.a = 1.0;\n}\n","name":"Buf C","description":"","type":"buffer"}]}