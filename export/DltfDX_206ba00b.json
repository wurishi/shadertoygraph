{"ver":"0.1","info":{"id":"DltfDX","date":"1708726013","viewed":19,"name":"Fermi Mause y zoom","username":"Leolios","description":"Superficie de Fermi mejorada, visión con mause","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fermisuface"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Parámetros de raymarching\nconst float MAX_DIST = 10.0;\nconst float EPSILON = 0.001;\nconst int MAX_STEPS = 500;\nconst float PI = 3.14159265359;\n\n// Parámetros de la cámara\nfloat zoom = 1.0;\nvec3 camPos = vec3(4.0, 5.0, 5.0);\n\n// Función que evalúa la ecuación de la superficie de Fermi\nfloat fermiSurface(vec3 k) {\n    return -2.0 * sin(sin(tan(cos(k.x)))) - 2.0 * sin(sin(sin(cos(k.y)))) - 2.0 * sin(sin(cos(k.z))) - 2.8;\n}\n\n// Función de raymarching para encontrar la intersección con la superficie de Fermi\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float depth = 1.10;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 pos = ro + rd * depth;\n        float dist = fermiSurface(pos);\n        if (abs(dist) < EPSILON) {\n            return depth;\n        }\n        depth += dist;\n        if (depth >= MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n    return MAX_DIST;\n}\n\n// Función de normal para la iluminación\nvec3 getNormal(vec3 p) {\n    const vec2 h = vec2(EPSILON, 1.0);\n    return normalize(vec3(\n        fermiSurface(p + h.xyy) - fermiSurface(p - h.xyy),\n        fermiSurface(p + h.yxy) - fermiSurface(p - h.yxy),\n        fermiSurface(p + h.yyx) - fermiSurface(p - h.yyx)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Control de zoom con el botón izquierdo del ratón\n    if (iMouse.z > 0.10) {\n        zoom = mix(zoom, 1.5, 0.01); // Zoom in, ajuste en la velocidad de zoom\n    } else {\n        zoom = mix(zoom, 7.0, 0.81); // Zoom out, ajuste en la velocidad de zoom\n    }\n    \n    // Coordenadas normalizadas de los píxeles y orientación de la cámara\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / (iResolution.y * zoom);\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    // Calcula la dirección de la cámara basada en la posición del ratón\n    vec3 camDir = normalize(vec3(mouse.x - 0.5, mouse.y - 0.5, 1.0));\n    vec3 camTarget = camPos + camDir;\n    vec3 w = normalize(camTarget - camPos);\n    vec3 u = normalize(cross(vec3(0.0, 1.0, 0.0), w));\n    vec3 v = cross(w, u);\n    vec3 rd = normalize(uv.x * u + uv.y * v + w);\n\n    // Ejecuta raymarching\n    float dist = rayMarch(camPos, rd);\n    if (dist < MAX_DIST) {\n        vec3 pos = camPos + rd * dist;\n        vec3 normal = getNormal(pos);\n        \n        // Simulación de reflexión para un efecto de cristal\n        vec3 reflectDir = reflect(rd, normal);\n        vec3 refractDir = refract(rd, normal, 1.66 / 1.5); // Índice de refracción para el cristal\n        vec3 reflectColor = vec3(0.6, 0.6, 00.0); // Color de reflexión\n        \n        // Puedes ajustar los colores de reflexión y refracción como desees\n        vec3 refractColor = vec3(0.5, 1.0, 1.0); // Color de refracción\n        \n        // Combinación de colores basada en el ángulo de visión (Fresnel)\n        float fresnel = pow(1.0 - max(dot(rd, normal), 0.10), 3.0);\n        vec3 color = mix(refractColor, reflectColor, fresnel);\n        \n        fragColor = vec4(color, 1.0);\n    } else {\n        fragColor = vec4(0.1, 0.0, 0.0, 1.0); // Fondo más realista (negro)\n    }\n}\n","name":"Image","description":"","type":"image"}]}