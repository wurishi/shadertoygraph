{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"/*\n\tFull Scene Radial Blur\n\t----------------------\n\n\tRadial blur - as a postprocessing effect - is one of the first things I considered doing \n\twhen the multipass system came out. I've always loved this effect. Reminds me of the early \n\tdemos from Aardbei et al. \n\n\tAnyway, Shadertoy user, Passion, did a really cool radial blur on a field of spheres that\n\tinspired me to do my own. Radial blurs are pretty straight forward, but it was still\n    helpful to have Passion's version as a guide. \n\n    As for the radial blur process, there's not much to it. Start off at the pixel position, \n    then radiate outwards gathering up pixels with decreased weighting. The result is a\n\tblurring of the image in a radial fashion, strangely enough. :)\n\n\tInspired by:\n\n\tBlue Dream - Passion\n\thttps://www.shadertoy.com/view/MdG3RD\n\n\tRadial Blur - IQ\n\thttps://www.shadertoy.com/view/4sfGRn\n\n\tRays of Blinding Light - mu6k\n\thttps://www.shadertoy.com/view/lsf3Dn\n\n*/\n\n// The radial blur section. Shadertoy user, Passion, did a good enough job, so I've used a\n// slightly trimmed down version of that. By the way, there are accumulative weighting \n// methods that do a slightly better job, but this method is good enough for this example.\n\n\n// Radial blur samples. More is always better, but there's frame rate to consider.\nconst float SAMPLES = 24.; \n\n\n// 2x1 hash. Used to jitter the samples.\nfloat hash( vec2 p ){ return fract(sin(dot(p, vec2(41, 289)))*45758.5453); }\n\n\n// Light offset.\n//\n// I realized, after a while, that determining the correct light position doesn't help, since \n// radial blur doesn't really look right unless its focus point is within the screen boundaries, \n// whereas the light is often out of frame. Therefore, I decided to go for something that at \n// least gives the feel of following the light. In this case, I normalized the light position \n// and rotated it in unison with the camera rotation. Hacky, for sure, but who's checking? :)\nvec3 lOff(){    \n    \n    vec2 u = sin(vec2(1.57, 0) - iTime/1.);\n    mat2 a = mat2(u, -u.y, u.x);\n    \n    vec3 l = normalize(vec3(1.5, 1., -0.5));\n    l.xz = a * l.xz;\n    l.xy = a * l.xy;\n    \n    return l;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // Screen coordinates.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Radial blur factors.\n    //\n    // Falloff, as we radiate outwards.\n    float decay = 0.69; \n    // Controls the sample density, which in turn, controls the sample spread.\n    float density = 0.1; \n    // Sample weight. Decays as we radiate outwards.\n    float weight = 0.1; \n    \n    // Light offset. Kind of fake. See above.\n    vec3 l = lOff();\n    \n    // Offset texture position (uv - .5), offset again by the fake light movement.\n    // It's used to set the blur direction (a direction vector of sorts), and is used \n    // later to center the spotlight.\n    //\n    // The range is centered on zero, which allows the accumulation to spread out in\n    // all directions. Ie; It's radial.\n    vec2 tuv =  uv - .5 - l.xy*.95;\n    \n    // Dividing the direction vector above by the sample number and a density factor\n    // which controls how far the blur spreads out. Higher density means a greater \n    // blur radius.\n    vec2 dTuv = tuv*density/SAMPLES;\n    \n    // Grabbing a portion of the initial texture sample. Higher numbers will make the\n    // scene a little clearer, but I'm going for a bit of abstraction.\n    vec4 col = texture(iChannel0, uv.xy)*0.25;\n    \n    // Jittering, to get rid of banding. Vitally important when accumulating discontinuous \n    // samples, especially when only a few layers are being used.\n    uv += dTuv*(hash(uv.xy + fract(iTime))*4. - 1.);\n    \n    // The radial blur loop. Take a texture sample, move a little in the direction of\n    // the radial direction vector (dTuv) then take another, slightly less weighted,\n    // sample, add it to the total, then repeat the process until done.\n    for(float i=0.; i < SAMPLES; i++){\n    \n        uv -= dTuv;\n        col += texture(iChannel0, uv) * weight;\n        weight *= decay;\n        \n    }\n    \n    // Multiplying the final color with a spotlight centered on the focal point of the radial\n    // blur. It's a nice finishing touch... that Passion came up with. If it's a good idea,\n    // it didn't come from me. :)\n    col *= (1. - dot(tuv, tuv)*.35);\n    \n    // Smoothstepping the final color, just to bring it out a bit, then applying some \n    // loose gamma correction.\n    fragColor = sqrt(smoothstep(0., 1., col));\n    \n    // Bypassing the radial blur to show the raymarched scene on its own.\n    //fragColor = sqrt(texture(iChannel0, fragCoord.xy / iResolution.xy));\n}\n\n","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// The scene itself. Not much commenting, since this is mainly about the radial blur,\n// plus a lot of it is rudimentary.\n\n#define FAR 200.\n\n// Hash.\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tpl( sampler2D t, in vec3 p, in vec3 n ){\n   \n    n = max(abs(n), 0.001);\n    n /= (n.x + n.y + n.z );  \n\tp = (texture(t, p.yz)*n.x + texture(t, p.zx)*n.y + texture(t, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// A simple, cheap but visually effective sinusoid based lattice. The downside to building\n// a scene with transcendentals is the honing difficulty, but the logarithmic based\n// \"Logarithmmic Bisection\" tracing method counters that.\nfloat map(in vec3 p){\n   \n    // A few small bumps to put on the surface.\n    float bump = (dot(sin(p*24. - cos(p.yzx*36.)), vec3(.015)));\n    \n    // Perturbing the surface slightly, prior to construction.\n    p += sin(p*8. + 3.14159)*.1;\n    \n    // The main surface. A weird, molecular looking lattice.\n    float n = dot(sin(p*2.), cos(p.yzx*2.));\n    \n \t// Clamping the surface value, and adding the bumps.\n    //return (clamp(0., -1.1, n) + 1.1)/1.1 + bump;\n    return (min(n, 0.) + 1.1)/1.1 + bump;\n    \n}\n\n \n// Ambient occlusion, for that self shadowed look.\n// XT95 came up with this particular version. Very nice.\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat cao( in vec3 p, in vec3 n, float maxDist )\n{\n\tfloat ao = 0.0, l;\n\tconst float nbIte = 6.0;\n\tconst float falloff = 1.5;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i + hash(i))*.5/nbIte*maxDist;\n        ao += (l - map( p + n*l ))/ pow(1. + l, falloff);\n    }\n\t\n    return clamp( 1.-ao/nbIte, 0., 1.);\n}\n\n// Tetrahedral normal, courtesy of IQ.\nvec3 nr(in vec3 p)\n{  \n    vec2 e = vec2(-1, 1)*.001;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n// A trimmed down version of Nimitz's \"Log Bisecion\" method. Very effective on\n// difficult to hone in on things like weird, transcendental surfaces.\n// Worth studying, if you're not familiar with it.\n//\n// Log-Bisection Tracing - Nimitz\n// https://www.shadertoy.com/view/4sSXzD\nfloat logBisectTrace( in vec3 ro, in vec3 rd){\n\n\n    float t = 0., told = 0., mid, dn;\n    float d = map(rd*t + ro);\n    float sgn = sign(d);\n\n    for (int i=0; i<64; i++){\n\n        // If the threshold is crossed with no detection, use the bisection method.\n        // Also, break for the usual reasons. Note that there's only one \"break\"\n        // statement in the loop. I heard GPUs like that... but who knows?\n        if (sign(d) != sgn || d < 0.001 || t > FAR) break;\n \n        told = t;\n        \n        // Branchless version of the following:  \n        // if(d>1.) t += d*.5; else t += log(abs(d) + 1.1)*.5;\n        t += step(d, 1.)*(log(abs(d) + 1.1)*.5 - d*.5) + d*.5;\n       \n        d = map(rd*t + ro);\n    }\n    \n    // If a threshold was crossed without a solution, use the bisection method.\n    if (sign(d) != sgn){\n    \n        // Based on suggestions from CeeJayDK, with some minor changes.\n\n        dn = sign(map(rd*told + ro));\n        \n        vec2 iv = vec2(told, t); // Near, Far\n\n        // 6 iterations seems to be more than enough, for most cases...\n        // but there's an early exit, so I've added a couple more.\n        for (int ii=0; ii<8; ii++){ \n            //Evaluate midpoint\n            mid = dot(iv, vec2(.5));\n            float d = map(rd*mid + ro);\n            if (abs(d) < 0.001)break;\n            // Suggestion from movAX13h - Shadertoy is one of those rare\n            // sites with helpful commenters. :)\n            // Set mid to near or far, depending on which side we're on.\n            iv = mix(vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn));\n        }\n\n        t = mid; \n        \n    }\n\n    return min(t, FAR);\n}\n\n// Shadows.\nfloat sha(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int maxIterationsShad = 16; \n\n    float dist = start;\n    float stepDist = end/float(maxIterationsShad);\n\n    for (int i=0; i<maxIterationsShad; i++){\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist));\n\n        dist += clamp(h, 0.02, 0.16);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if ((h)<0.001 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.) + 0.1, 1.0); \n}\n\n// Grey scale.\nfloat gr(vec3 p){ return dot(p, vec3(0.299, 0.587, 0.114)); }\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 db( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.1, 0);\n    // Gradient vector, constructed with offset greyscale texture values.\n    vec3 g = vec3( gr(tpl(tx, p - e.xyy, n)), gr(tpl(tx, p - e.yxy, n)), gr(tpl(tx, p - e.yyx, n)));\n    \n    g = (g - gr(tpl(tx,  p , n)))/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n// Camera path. Arranged to coincide with the frequency of the lattice.\nvec3 camPath(float t){\n  \n    return vec3(-sin(t), sin(t) + .75, t*2. + .5);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n\t// Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\t\n    vec3 o = camPath(iTime); // Camera position, doubling as the ray origin.\n    vec3 lk = camPath(iTime + .1);  // \"Look At\" position.\n    vec3 l = o + vec3(0.1, 1., -1.5); // Light position, somewhere near the moving camera.\n\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; // FOV - Field of view.\n    vec3 fwd = normalize(lk-o);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    // Unit direction ray.\n    vec3 r = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    // Lens distortion.\n    //vec3 r = fwd + FOV*(u.x*rgt + u.y*up);\n    //r = normalize(vec3(r.xy, (r.z - length(r.xy)*.5)));\n    \n    \n    // Rotate the camera using Fabrice's simplified rotation matrix.\n    u = sin(vec2(1000.57, 1) - iTime/20.); // Reusing \"u.\"\n    mat2 a = mat2(u, -u.y, u.x);\n    r.xz = a * r.xz;\n    r.xy = a * r.xy;\n\n    // Nimitz's fancy surface intersection formula.\n    float t = logBisectTrace(o, r);\n\n    // Initialize the scene color to zero.\n    vec3 col = vec3(0);\n    \n    // If the surface is hit, light it up.\n    if(t<FAR){\n    \n        // Position and normal.\n        vec3 p = o + r*t, n = nr(p);\n        \n        // Texture bump the normal.\n        float sz = 1./1.;\n        n = db(iChannel0, p*sz, n, .03/(1. + t/FAR));\n\n\n        l -= p; // Light to surface vector. Ie: Light direction vector.\n        float d = max(length(l), 0.001); // Light to surface distance.\n        l /= d; // Normalizing the light direction vector.\n        \n        // Ambient occlusion and shadowing.\n        float ao =  cao(p, n, 40.);\n        float sh = sha(p, l, 0.004, d, 4.);\n        \n        // Diffuse, specular, fresnel. Only the latter is being used here.\n        //float di = max(dot(l, n), 0.);\n        float sp = pow(max( dot( reflect(r, n), l ), 0.0 ), 8.); // Specular term.\n        float fr = clamp(1.0 + dot(r, n), 0.0, 1.0); // Fresnel reflection term.\n        \n        // Texturing the surface with some tri-planar mapping..\n        vec3 tx = tpl( iChannel0, p*sz, n);\n\n\t\t// Very simple coloring. Fresnel and texture combination. Radial blurs like simplicity. :)\n        col = tx*fr*4.;\n        col *= 1./(1. + d*.125 + d*d*.05)*ao*sh;\n\n        \n    }\n\n    vec3 bg = vec3(1, .56, .3);\n    col = mix(clamp(col, 0., 1.), bg, smoothstep(0., FAR-20000., t));\n    fragColor = vec4(col, 1.);\n    \n    \n}","name":"Buffer A","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XsXGR8"}],"inputs":[],"code":"/*\n\n\tOldschool Tube\n\t--------------\n\n\tAn oldschool tube effect, with a few extra lines to bump it and light it up. Virtually no \n\tdifferent in concept to the more compact, minimal character versions.\n\n\tAiekick asked about cylindrically wrapping a pattern - like Voronoi - onto a cyclinder, so \n\tI thought I'd put a simple example together and post it privately... However, I got a little \n\tcarried away adding window dressing. It's still not particularly interesting, but I liked\n\tthe simple rendering style, so thought I'd release it publicly.\n\n\tHaving said that, one minor point of interest is that the edging is done in the bump routine.\n\tMost edging examples are raymarched and involved normal-based edge calculations, but this\n\tshows that you can have edging on the bump mapped part of the scene too. There are much more\n\tinteresting applications, and I'll give an example at a later date.\n\n\n\tCreated in repsonse to the following:\n\n    Voro Tri Tunnel - aiekick\n    https://www.shadertoy.com/view/XtGGWy\n\n\tA rough explanation of the oldschool tunnel effect:\n\n\tTraced Minkowski Tube - Shane\n    https://www.shadertoy.com/view/4lSXzh\n\n    // Another example.\n\tLuminescent Tiles - Shane\n\thttps://www.shadertoy.com/view/MtSXRm\n\n*/\n\n// 2D rotation. Always handy. Angle vector, courtesy of Fabrice.\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p, float w) { \n\n    // The Voronoi pattern needs to be repeatable. Hence the \"mod\" line below.\n    p = mod(p, w);\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(41, 289)));\n    return fract(vec2(262144, 32768)*n)*.9 + .1; \n    \n    // Animated.\n    //p = fract(vec2(262144, 32768)*n); \n    // Note the \".45,\" insted of \".5\" that you'd expect to see. When edging, it can open \n    // up the cells ever so slightly for a more even spread. In fact, lower numbers work \n    // even better, but then the random movement would become too restricted. Zero would \n    // give you square cells.\n    //return sin( p*6.2831853 + iTime )*.45 + .5; \n    \n}\n\n\nfloat vx;\n// 2D 2nd-order Voronoi: Obviously, this is just a rehash of IQ's original. I've tidied\n// up those if-statements. Since there's less writing, it should go faster. That's how \n// it works, right? :)\n//\nfloat Voronoi(in vec2 p, float w){\n    \n    \n\tvec2 g = floor(p), o; p -= g;\n\t\n\tvec3 d = vec3(1.4142); // 1.4, etc. \"d.z\" holds the distance comparison value.\n    \n\tfor(int y=-1; y<=1; y++){\n\t\tfor(int x=-1; x<=1; x++){\n            \n\t\t\to = vec2(x, y);\n            o += hash22(g + o, w) - p;\n            \n\t\t\td.z = length(o);//(dot(o, o)); \n            \n            // More distance metrics.\n            //o = abs(o);\n            //d.z = mix(max(abs(o.x)*.866025 + o.y*.5, -o.y), dot(o, o), .2);//\n            //d.z = max(abs(o.x)*.866025 - o.y*.5, o.y);\n            //d.z = max(abs(o.x) + o.y*.5, -(o.y)*.8660254);\n            //d.z = max(o.x, o.y);\n            //d.z = (o.x*.7 + o.y*.7);\n            \n            d.y = max(d.x, min(d.y, d.z));\n            d.x = min(d.x, d.z); \n                       \n\t\t}\n\t}\n \t\t\t\t\t \n\td/=1.4142;\n    \n    vx = d.x;\n    \n    d = smoothstep(0., 1., d);\n\n    \n    return max(d.y/1.333 - d.x, 0.)*1.333;\n    \n   \n    //return d.y - d.x;\n    \n}\n\nfloat objID;\n\n// The bump mapping function.\nfloat bumpFunction(in vec3 p){\n    \n    // Stock standard cylindrical mapping. This line here is pretty much\n    // where all the oldschool tunnel examples stem from.\n    vec2 uv = vec2(atan(p.y, p.x)/6.2832, p.z/8.);\n    \n    float c = Voronoi(uv*16., 16.);\n\n    objID = 0.;\n\n    // The web section. Comment it out, if you're not sure what it does.\n    if(c<.15) { c = abs(max(c, 0.01) - .3), objID = 1.; }\n    \n    return c;\n   \n}\n\n\n// Standard function-based bump mapping function, with some edging added to the mix.\nvec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor, inout float edge){\n    \n    vec2 e = vec2(2.5/iResolution.y, 0);\n    \n    float f = bumpFunction(p); \n    \n    // Samples about the hit point in each of the axial directions.\n    float fx = bumpFunction(p - e.xyy); // Same for the nearby sample in the X-direction.\n    float fy = bumpFunction(p - e.yxy); // Same for the nearby sample in the Y-direction.\n    float fz = bumpFunction(p - e.yyx); // Same for the nearby sample in the Y-direction.\n\n    // Samples from the other side.\n    float fx2 = bumpFunction(p + e.xyy); // Same for the nearby sample in the X-direction.\n    float fy2 = bumpFunction(p + e.yxy); // Same for the nearby sample in the Y-direction.\n    float fz2 = bumpFunction(p + e.yyx); // Same for the nearby sample in the Y-direction.\n    \n    // We made three extra function calls, so we may as well use them. Taking measurements\n    // from either side of the hit point has a slight antialiasing effect.\n    vec3 grad = (vec3(fx - fx2, fy - fy2, fz - fz2))/e.x/2.;   \n\n    // Using the samples to provide an edge measurement.\n    edge = abs(fx + fy + fz + fx2 + fy2 + fz2 - 6.*f);\n    //edge = abs(fx + fx2 - f*2.) + abs(fy + fy2 - f*2.)+ abs(fz + fz2 - f*2.);\n    edge = smoothstep(0., 1., edge/e.x);\n          \n    grad -= n*dot(n, grad);          \n                      \n    return normalize( n + grad*bumpfactor );\n\t\n}\n\n\n// The second function. This adds the swirly noise patterns to the webbing.\nfloat bumpFunction2(in vec3 p){\n    \n    float c = n3D(p*16.); // Noise value.\n    \n    c = fract(c*4.); // Producing some repeat noise contour rings... Bad description. :)\n    \n    return min(c, c*(1. - c)*4.); // Smooth \"fract.\" It's an old trick.\n   \n}\n\n// A second function-based bump mapping function.\nvec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor){\n    \n    vec2 e = vec2(2.5/iResolution.y, 0);\n    float f = bumpFunction2(p); \n    \n    float fx = bumpFunction2(p - e.xyy); // Same for the nearby sample in the X-direction.\n    float fy = bumpFunction2(p - e.yxy); // Same for the nearby sample in the Y-direction.\n    float fz = bumpFunction2(p - e.yyx); // Same for the nearby sample in the Y-direction.\n    \n    vec3 grad = (vec3(fx, fy, fz )-f)/e.x; \n          \n    grad -= n*dot(n, grad);          \n                      \n    return normalize( n + grad*bumpfactor );\n}\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\n    \n    // Unit direction ray. Coyote's elegant version. So obvious, yet it never occurred\n    // to me... or most others, it seems. :)\n    vec3 rd = normalize(vec3(fragCoord - iResolution.xy*0.5, iResolution.y));\n    \n    rd.xy = rot(iTime*0.25)*rd.xy; // Look around, just to show it's a 3D effect.\n    rd.xz = rot(iTime*0.125)*rd.xz;\n    \n    // Ray origin.\n    vec3 ro = vec3(0.0, 0.0, iTime);\n    \n    // Screen color. Initialized to black.\n    vec3 col = vec3(0);\n\n\tconst float rad = 1.; // Initial cylinder radius.\n\n    // Distance fromt the ray origin to the cylinder layer surface point. It's a cut down\n    // version of a traced cylinder with its center fixed to the Z axis.\n    float sDist = rad/max( length(rd.xy), 0.001 );\n\n    // Surface position.\n    vec3 sp = ro + rd*sDist;\n\n    // Surface normal.\n    vec3 sn = normalize(vec3(-sp.xy, 0.)); // Cylinder normal.\n\n    // Bumpmapping (the Voronoi part) with some edge calculations included.\n    float edge;\n    sn = doBumpMap( sp, sn, .75, edge);\n    \n    // The object ID is calculated in the bump function. We save it here. Zero is the bulbous\n    // portion that gets lit up and one is the webbing.\n    float svObjID = objID;\n    \n    // Secondary bump pattern on the webbing. Done separately, so as not to interfere\n    // with the edge calculations.\n    if(svObjID>.5) sn = doBumpMap( sp, sn, .003);\n    \n    // Some rough noise sprinkles. Note that a 3D noise function is being used. You could also\n    // cylindrically map a 2D noise function, but I thought this was less hassle.\n    vec3 tex = vec3(1)*n3D(fract(sp)*292.);\n    vec3 objCol = smoothstep(.1, .9, tex)*.8 + 1.;\n    \n    \n    if(svObjID<.5) objCol *= vec3(.45, .425, .5); // The bulbs. Using a slightly darker tone.\n    else objCol *= vec3(.68, .64, .75); // The Voroni web portion.\n    \n    // Alternative: Egyptian look - gold and turquoise... or lapis lazuli, for the purists. :)\n    //if(svObjID>.5) objCol *= vec3(1, .75, .4)*.75;\n    //else objCol *= vec3(.5, .7, 1);\n\n    // Lighting.\n    //\n    // The light. Placed near the ray origin, camera, etc. We're looking down both ends of the\n    // tunnel, so it helps to keep the light near the camera. A better alternative is to have \n    // two lights on either side, but I'm trying to keep it simple.\n    vec3 lp = ro + vec3(0, .5, 0);\n    vec3 ld = lp - sp; // Light direction.\n    float dist = max(length(ld), 0.001); // Distance from light to the surface.\n    ld /= dist; // Use the distance to normalize \"ld.\"\n\n    // Light attenuation, based on the distance above.\n    float atten = 1.5/(1. + dist*.05 + dist*dist*0.075);\n    \n    // Use the bump texture to darken the crevices. Comment it out to see its effect.\n    atten *= bumpFunction(sp)*.9 + .1;//getGrey(texCol(iChannel0, sp))*.5 + .5;\n\n\n    float diff = max(dot(ld, sn), 0.); // Diffuse light value.\n    diff = pow(diff, 8.)*0.66 + pow(diff, 16.)*0.34;  // Ramping it up.\n    \n    float spec = pow(max(dot(reflect(ld, sn), rd), 0.), 8.); // Specular light value.\n    \n    /////\n    // The blinking light section. All of it is made up.\n    // Basically, we're adding a unit refracted vector to the hit position, then passing it into a\n    // cylindrically mapped Voronoi function, smoothing, then colorizing.\n    vec3 ref = sp + refract(rd, sn, 1./1.6);\n    vec2 tuv = vec2(atan(ref.y, ref.x)/6.2832, ref.z/8.);\n    float c2 = Voronoi(tuv*4. - vec2(1, .5)*iTime, 4.);\n    c2 = smoothstep(0.8, 1., 1.-vx);\n        \n    vec3 elec = (objCol*.7 + .3)*pow(min(vec3(1.5, 1, 1)*c2, 1.), vec3(1,  3, 8)); // Fiery coloring.\n        \n    if (svObjID<.5) objCol += elec*8.; // Add a lot of the color to the bulbs.\n    else objCol += elec*2.; // Add a little to the webbing.\n    //////////\n    \n\n    // Using the values above to produce the layer color.\n    col += (objCol*(diff*vec3(1, .97, .92)*2. + 0.25) + vec3(1, .6, .2)*spec*2.)*atten;// + env*atten;\n\n    // Adding some fake reflection to the walls.\n    ref = reflect(rd, sn);\n    float rc = n3D(ref*2.);\n    col += col*smoothstep(.3, 1., rc)*4.*atten;\n    \n    // Darkening the edges. Without it, the scene would lose its mild cartoony look.\n    col *= 1. - edge*.7;\n    \n    \n    //col = mix(col, vec3(2, 1.5, 1).zyx, 1. - exp(-.002*sDist*sDist)); // Blue fog, if you prefer.\n    col = mix(col, vec3(0), 1. - exp(-.002*sDist*sDist)); // Extra fog at the end of the tunnel.\n    \n    // Gamma correction.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.);\n}","name":"Buffer B","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"4cGfWd","date":"1734628889","viewed":127,"name":"neon ray Fork","username":"firebreathzz","description":"Applying some God rays, post process, to a simple raymarched scene. Inspired by Passion's \"Blue Dream\" ... and a lot of old demos. :)","likes":3,"published":3,"flags":32,"usePreview":0,"tags":["raymarching","blur","radial","godrays"],"hasliked":0,"parentid":"fllSRM","parentname":"neon ray"}}