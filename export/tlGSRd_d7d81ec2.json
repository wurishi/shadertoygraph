{"ver":"0.1","info":{"id":"tlGSRd","date":"1583449180","viewed":74,"name":"Raymarching in modulo space","username":"leocaus","description":"Raymarching in modulo spaces","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["rm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int MAX_STEPS = 1000;\nfloat SURF_DIST = .01;\nfloat MAX_DIST = 1000.;\nvec3 modv = vec3(8., 8., 8.);\n\n\nvec3 world2modSpace(vec3 p){\n\t\n    \n    if(modv.x > 0.){\n    \tp.x = mod(p.x-modv.x/2., modv.x)-modv.x/2.;\n    }\n    \n    if(modv.y > 0.){\n    \tp.y = mod(p.y-modv.y/2., modv.y)-modv.y/2.;\n    }\n    \n    if(modv.z > 0.){\n    \tp.z = mod(p.z-modv.z/2., modv.z)-modv.z/2.;\n    }\n    \n    \n\treturn p;\n}\n\nvec3 world2cellSpace(vec3 p){\n\t\n    vec3 i = vec3(0);\n    \n    if(modv.x > 0.){\n    \ti.x = floor((p.x+modv.x/2.)/modv.x);\n    }\n    if(modv.y > 0.){\n    \ti.y = floor((p.y+modv.y/2.)/modv.y);\n    }\n    if(modv.z > 0.){\n    \ti.z = floor((p.z+modv.z/2.)/modv.z);\n    }\n    \n    \n\treturn i;\n}\n\nvec3 rotateVec3(vec3 v, float thet, float phi){\n\tvec3 v1 = vec3(v.x*cos(thet)-v.y*sin(thet), v.x*sin(thet)+v.y*cos(thet), v.z);\n    \n    return vec3(v1.x*cos(phi)-v1.z*sin(phi), v1.y , v1.x*sin(phi)+v1.z*cos(phi));\n}\n\nfloat distToSphere(vec3 p, vec3 sc, float r){\n    vec3 D = p-sc;\n    float L = length(D);   \n    return L-r;\n}\n\nfloat getDist(vec3 p){\n    p = world2modSpace(p);\n    \n\tfloat dS1 = distToSphere(p, vec3 (0.,0.,0.), 1.);\n\t//float dS1 = 100.;\n    float dS2 = distToSphere(p, vec3 (1.5*cos(iTime),1.5*sin(iTime),0.), 1.0);\n    return min(dS1,min(1000.,1000.));\n}\n\nvec3 getNormal(vec3 p){\n    \n    float d = getDist(p);\n\t\n    vec3 n = vec3(0.);\n    vec2 e = vec2(.01,0.);\n    \n    if(d < 2.*SURF_DIST){\n    \tn = d - vec3(getDist(p-e.xyy),getDist(p-e.yxy),getDist(p-e.yyx));\n        n = normalize(n);\n    }\n\treturn n;\n}\n\nfloat RayMarch(vec3 rp, vec3 rd){\n\t\n    float dO = 0.;\n    \n    for(int i = 0; i<MAX_STEPS; i++){\n    \tvec3 p = rp+rd*dO;\n        float d = getDist(p);\n        \n        dO += d;\n        \n        if(dO > MAX_DIST || d < SURF_DIST) break;\n        \n    }\n  \t\n    return dO;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{ \n    float t = iTime;\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/(iResolution.x*0.5);\n    vec3 cp = vec3(t,3.,3.);\n    vec3 cd = normalize(vec3(1.0, 0.2*cos(t/5.), 0.2*sin(t/5.)));\n    vec3 cu = normalize(vec3(0.,0.,1.));\n    \n    float fov = 45.*3.1415/360.;\n    float dov = 1./tan(fov);\n    \n    vec3 cx = normalize(cross(cu, cd));\n    vec3 cy = normalize(cross(cd, cx));\n    \n    vec3 rd = normalize(dov*cd+uv.x*cx+uv.y*cy);\n    \n    float d = RayMarch(cp, rd);\n    \n    vec3 n = getNormal(cp+rd*d);\n\t\n    vec3 i = world2cellSpace(cp+rd*d);\n    \n    // Output to screen\n    fragColor = vec4(abs(rotateVec3(n, length(i)+t ,length(i)+t)),1.);\n    \n}\n","name":"Image","description":"","type":"image"}]}