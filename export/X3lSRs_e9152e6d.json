{"ver":"0.1","info":{"id":"X3lSRs","date":"1709843506","viewed":75,"name":"Ants (Help Needed)","username":"beemerwt","description":"A bunch of ants that (should be) randomly crawling the inside of a colony.\nAny help would be greatly appreciated!\n\nTODO:\nRotation to face the correct direction","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["signeddistancefield","help","ants"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec2[83] edges = vec2[83](\n    vec2(0.36, 0.31),\n    vec2(0.342813, 0.317813),\n    vec2(0.305, 0.335),\n    vec2(0.267188, 0.352188),\n    vec2(0.25, 0.36),\n    vec2(0.210938, 0.36),\n    vec2(0.170898, 0.36),\n    vec2(0.125, 0.36),\n    vec2(0.079102, 0.36),\n    vec2(0.039063, 0.36),\n    vec2(0, 0.36),\n    vec2(-0.025, 0.345),\n    vec2(-0.05, 0.33),\n    vec2(-0.06875, 0.322188),\n    vec2(-0.11, 0.305),\n    vec2(-0.15125, 0.287813),\n    vec2(-0.17, 0.28),\n    vec2(-0.184062, 0.269062),\n    vec2(-0.215, 0.245),\n    vec2(-0.245937, 0.220938),\n    vec2(-0.26, 0.21),\n    vec2(-0.274063, 0.1975),\n    vec2(-0.305, 0.17),\n    vec2(-0.335938, 0.1425),\n    vec2(-0.35, 0.13),\n    vec2(-0.3625, 0.11125),\n    vec2(-0.39, 0.07),\n    vec2(-0.4175, 0.02875),\n    vec2(-0.43, 0.01),\n    vec2(-0.434687, -0.024375),\n    vec2(-0.439492, -0.059609),\n    vec2(-0.445, -0.1),\n    vec2(-0.450508, -0.140391),\n    vec2(-0.455312, -0.175625),\n    vec2(-0.46, -0.21),\n    vec2(-0.452188, -0.224063),\n    vec2(-0.435, -0.255),\n    vec2(-0.417812, -0.285937),\n    vec2(-0.41, -0.3),\n    vec2(-0.392812, -0.3125),\n    vec2(-0.355, -0.34),\n    vec2(-0.317187, -0.3675),\n    vec2(-0.3, -0.38),\n    vec2(-0.27, -0.39),\n    vec2(-0.24, -0.4),\n    vec2(-0.207188, -0.4),\n    vec2(-0.173555, -0.4),\n    vec2(-0.135, -0.4),\n    vec2(-0.096445, -0.4),\n    vec2(-0.062812, -0.4),\n    vec2(-0.03, -0.4),\n    vec2(-0.008125, -0.392188),\n    vec2(0.014297, -0.38418),\n    vec2(0.04, -0.375),\n    vec2(0.065703, -0.36582),\n    vec2(0.088125, -0.357812),\n    vec2(0.11, -0.35),\n    vec2(0.135, -0.334375),\n    vec2(0.160625, -0.318359),\n    vec2(0.19, -0.3),\n    vec2(0.219375, -0.281641),\n    vec2(0.245, -0.265625),\n    vec2(0.27, -0.25),\n    vec2(0.284063, -0.235938),\n    vec2(0.315, -0.205),\n    vec2(0.345937, -0.174063),\n    vec2(0.36, -0.16),\n    vec2(0.370937, -0.145938),\n    vec2(0.395, -0.115),\n    vec2(0.419062, -0.084063),\n    vec2(0.43, -0.07),\n    vec2(0.43625, -0.040312),\n    vec2(0.442656, -0.009883),\n    vec2(0.45, 0.025),\n    vec2(0.457344, 0.059883),\n    vec2(0.46375, 0.090313),\n    vec2(0.47, 0.12),\n    vec2(0.462187, 0.140312),\n    vec2(0.445, 0.185),\n    vec2(0.427812, 0.229687),\n    vec2(0.42, 0.25),\n    vec2(0.39, 0.28),\n    vec2(0.36, 0.31)\n);\n\nconst int num_ants = 12;\nconst int num_edges = 83;\n\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\nfloat rand( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\n\nfloat sdf_circle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return length(vec2(x, y)) - r;\n}\n\nfloat sdf_line(vec2 p, vec2 a, vec2 b) {\n  float h = min(1.0f, max(0.0f, dot(p - a, b - a) / dot(b - a, b - a)));\n  return length(p - a - (b - a) * h);\n}\n\nvec2 rotate(vec2 uv, float th) {\n  return mat2(vec2(cos(th), sin(th)), vec2(-sin(th), cos(th))) * uv;\n}\n\nvec3 single_ant(vec2 uv, vec2 center, float rotation, float scale) { \n  vec3 col = vec3(0.);\n\n  float RADIUS = 1. / 10. * scale;\n  float LEG_THICKNESS = 1./5. * RADIUS;\n  float ANTENNA_THICKNESS = 1./10. * RADIUS;\n  float HALF_RADIUS = RADIUS / 2.;\n\n  vec2 Lo = rotate(vec2(LEG_THICKNESS, 0), rotation + iTime * 10.0); // leg offset\n  vec2 Le = rotate(vec2(0, -RADIUS - HALF_RADIUS), rotation); // leg end\n\n  vec2 Hc = center + rotate(vec2(-RADIUS - RADIUS, 0.0f), rotation); // Head center\n  float head = sdf_circle(uv, RADIUS, Hc);\n  float headleg = sdf_line(uv, Hc + Lo, Hc + Lo + Le) - LEG_THICKNESS;\n\n  vec2 Sa = Hc - rotate(vec2(HALF_RADIUS, 0), rotation);\n  vec2 Sb = Sa + rotate(vec2(0, RADIUS + (RADIUS / 3.)), rotation);\n  vec2 Ab = Sb - rotate(vec2(HALF_RADIUS, -HALF_RADIUS), rotation);\n\n  float stem = sdf_line(uv, Sa, Sb) - ANTENNA_THICKNESS;\n  float antennae = sdf_line(uv, Sb, Ab) - ANTENNA_THICKNESS;\n\n  vec2 Ac = center + vec2(0.0f, 0.0f); // Abdomin center\n  float abdomin = sdf_circle(uv, RADIUS, Ac);\n  float abdominleg = sdf_line(uv, Ac, Ac + Le + Lo) - LEG_THICKNESS;\n\n  vec2 Tc = center + rotate(vec2(RADIUS + RADIUS, 0.0f), rotation); // Thorax center\n  float thorax = sdf_circle(uv, RADIUS, Tc);\n  float thoraxleg = sdf_line(uv, Tc - Lo, Tc - Lo + Le) - LEG_THICKNESS;\n\n  col = mix(vec3(0, 1, 0), col, step(0., stem));\n  col = mix(vec3(0, 1, 0), col, step(0., antennae));\n\n  col = mix(vec3(0, 1, 0), col, step(0., head));\n  col = mix(vec3(0, 1, 0), col, step(0., headleg));\n  col = mix(vec3(0, 1, 0), col, step(0., abdomin));\n  col = mix(vec3(0, 1, 0), col, step(0., abdominleg));\n  col = mix(vec3(0, 1, 0), col, step(0., thorax));\n  col = mix(vec3(0, 1, 0), col, step(0., thoraxleg));\n\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    uv -= 0.5;\n    uv = vec2(-1.0f * uv.x, uv.y);\n    \n    float colony = sdf_circle(uv, 100. / 800., vec2(0.));\n    \n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i < num_edges - 1; i++) {\n        float line = sdf_line(uv,  edges[i], edges[i + 1]) - 0.002;\n        col = mix(vec3(1., 0., 1.), col, step(0., line));\n    }\n\n\tfor (int i = 0; i < num_ants; i++) {\n        // Unique Ant Coefficient\n\t\tfloat uac = float(i);\n\n\t\t// get direction from the unique ant coefficient (-1 or 1)\n\t\tfloat direction = sign(rand(uac) * 2.0 - 1.0);\n\n\t\t// get the ant's progress\n\t\tfloat progress = abs(mod(uac + (direction * (iTime + 100. * uac)), float(num_edges - 1)));\n\t\tint edgeIndex = int(progress);\n\t\tfloat edgeProgress = clamp(progress - float(edgeIndex), 0., 1.);\n\n\t\t// Find the edge based on the ant's progress\n\t\tvec2 edge = edges[edgeIndex];\n\t\tvec2 nextEdge = edges[edgeIndex + int(direction)];\n\n\t\t// get the rotation from the direction of the two edges\n\t\tfloat rot = atan(nextEdge.y - edge.y, nextEdge.x - edge.x);\n\t\tvec2 pos = mix(edge, nextEdge, (direction * edgeProgress));\n\n\t\t// TODO Fix the ones that are moving \"forward\" (direction = 1.0)\n\t\t//\tto be flipped on the y axis\n        \n\t\trot += (direction - 1.0) * radians(90.0);\n\t\tcol += single_ant(uv, pos, rot, 0.15);\n\t}\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}