{"ver":"0.1","info":{"id":"MfVcDz","date":"1731753573","viewed":82,"name":"Value noise fractal","username":"mujtaba8086","description":"For [url=https://gameidea.org/short-posts/value-noise/]value noise[/url] tutorial. It is alternative to [url=https://gameidea.org/short-posts/perlin-noise/]perlin noise[/url] if imperfection dont matter.","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["procedural","perlinnoise","texture","perlin","valuenoise","proceduralnoise","value"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat random(vec2 st) {\n  return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n// Smooth interpolation between values using mix\nfloat valueNoise(vec2 uv) {\n    vec2 i = floor(uv);      // Integer grid coordinates\n    vec2 f = fract(uv);      // Fractional part\n\n    // Random values at the four corners of the cell\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth interpolation for x and y using Hermite curve (smoothstep)\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    // Interpolate values along the x and y axis\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.y;\n    uv *= 16.0;  // Scale to increase the frequency of the noise\n\n    // Function to hash the integer grid coordinates to random values\n\n\n\n\n    // Generate fractal noise with multiple octaves\n    float noise = 0.0;\n    float scale = 1.0;\n    float amplitude = .50;\n\n    for (int i = 0; i < 5; i++) {  // 5 octaves\n        noise += valueNoise(uv * scale) * amplitude;\n        scale *= 2.0;\n        amplitude *= 0.5;\n    }\n\n    // Set color based on the noise\n    fragColor = vec4(vec3(noise), 1.0);\n}","name":"Image","description":"","type":"image"}]}