{"ver":"0.1","info":{"id":"3dcfzn","date":"1604186809","viewed":202,"name":"Tau Ceti Spectrum rendering 2","username":"TomF","description":"A test of a more advanced TauCeti/Academy rendering technique for a ZX Spectrum\n\nExample of the original by Pete Cooke:\nhttps://www.youtube.com/watch?v=z3p_PoeSLYI&t=14m17s","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["retro","rendering","spectrun"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// 0 = three-shade shading.\n// 1 = original TauCeti style two-shade rendering.\n#define TWO_SHADE 0\n\n// 0 = fancy new non-circular rendering (doesn't really work well)\n// 1 = original TauCeti style only-circles rendering.\n#define FORCE_CIRCULAR 0\n\n// 0 = native PC resolution\n// 1 = Spectrum-style monchrome with dither\n#define SPECCY_REZ 1\n\n// 0 = no debug info.\n// 1 = debug info.\n#define DEBUG_MODE 0\n\n// 0 = no lightning\n// 1 = lightning!\n#define LIGHTNING 1\n\n\n\n// Shapes are made of a series of horizontal slices.\n// Each slice has a Y coordinate.\n// Slices are listed top (positive Y) to bottom (negative Y).\n// Adjacent slices may have the same Y but different widths,\n// and this will produce a discontinuity as expected.\n//\n// Each slice has a brightness that is for the section below it.\n// Negative numbers mean self-illuminated.\n// Positive numbers mean lit by the sun. (1.0 = full)\n//\n// Each slice has eight segments, forming a full circle,\n// one for each of the eight directions around a circle.\n// First direction is directly ahead, the rest are clockwise.\n// Each segment is:\n//  - a width at the start of the segment - interpolated to the start of the next segment\n//  - a depth the sgement starts at\n//  - a depth the sgement end at\n// Negative widths are valid! Self-intersection will look strange.\n// Each width also has a start depth and an end depth, which are the\n// start & end depths at which the kissing tangent hits the shape during\n// that segment. These are only used for lighting of course.\n\nconst int ShapeSliceSize = (2+8*3);\n\n#if 0\nfloat[] Shape = \nfloat [](\n    // Round top.\n     3.0,  1.0,\t  5.0,0.0,0.0, 5.0,0.0,0.0, 5.0,0.0,0.0, 5.0,0.0,0.0, 5.0,0.0,0.0, 5.0,0.0,0.0, 5.0,0.0,0.0, 5.0,0.0,0.0, \n     2.0,  -1.0,  6.0,0.0,0.0, 6.0,0.0,0.0, 6.0,0.0,0.0, 6.0,0.0,0.0, 6.0,0.0,0.0, 6.0,0.0,0.0, 6.0,0.0,0.0, 6.0,0.0,0.0, \n     1.5,  0.5,\t  6.0,0.0,0.0, 6.0,0.0,0.0, 6.0,0.0,0.0, 6.0,0.0,0.0, 6.0,0.0,0.0, 6.0,0.0,0.0, 6.0,0.0,0.0, 6.0,0.0,0.0, \n     0.0,  0.5,\t  4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, \n    // Circular column biased towards the front.\n     0.0,  0.7,   2.0,0.0,0.7, 1.7,0.7,1.0, 1.0,1.0,0.7, 0.3,0.7,0.0, 0.0,0.0,-0.7, 0.3,-0.7,-1.0, 1.0,-1.0,-0.7, 1.7,-0.7,0.0,\n    -1.0,  0.7,   2.0,0.0,0.7, 1.7,0.7,1.0, 1.0,1.0,0.7, 0.3,0.7,0.0, 0.0,0.0,-0.7, 0.3,-0.7,-1.0, 1.0,-1.0,-0.7, 1.7,-0.7,0.0,\n    // a square-section middle\n    -1.0,  0.7,   3.0,-3.0,0.0, 4.2426,0.0,3.0, 3.0,-3.0,0.0, 4.2426,0.0,3.0, 3.0,-3.0,0.0, 4.2426,0.0,3.0, 3.0,-3.0,0.0, 4.2426,0.0,3.0, \n    -2.0,  0.7,   4.0,-4.0,0.0, 5.7,0.0,4.0, 4.0,-4.0,0.0, 5.7,0.0,4.0, 4.0,-4.0,0.0, 5.7,0.0,4.0, 4.0,-4.0,0.0, 5.7,0.0,4.0, \n    // Then round off the front\n    -2.0,  1.0,   5.7,0.0,0.0, 5.7,0.0,4.0, 4.0,-4.0,0.0, 5.7,0.0,4.0, 4.0,-4.0,0.0, 5.7,0.0,4.0, 4.0,-4.0,0.0, 5.7,0.0,0.0, \n    -4.0,  1.0,   5.7,0.0,0.0, 5.7,0.0,4.0, 4.0,-4.0,0.0, 5.7,0.0,4.0, 4.0,-4.0,0.0, 5.7,0.0,4.0, 4.0,-4.0,0.0, 5.7,0.0,0.0, \n    // And back to a circle.\n    -4.0,  1.0,   5.7,0.0,0.0, 5.7,0.0,0.0, 5.7,0.0,0.0, 5.7,0.0,0.0, 5.7,0.0,0.0, 5.7,0.0,0.0, 5.7,0.0,0.0, 5.7,0.0,0.0, \n    -5.0,  1.0,   5.7,0.0,0.0, 5.7,0.0,0.0, 5.7,0.0,0.0, 5.7,0.0,0.0, 5.7,0.0,0.0, 5.7,0.0,0.0, 5.7,0.0,0.0, 5.7,0.0,0.0, \n    -5.0,  0.0,   0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0\n);\nconst int ShapeSlices = 12;\n#else\n// Let's make a tank!\n// TODO: allow turret to rotate independently of the bottom!\n//       Should be pretty simple. Although could just do it with two separate\n//       \"sprites\" drawn on top of each other.\nfloat[] Shape = \nfloat [](\n    // Commander's cupola.\n     3.3,  0.7,   2.0,0.0,0.7, 1.7,0.7,1.0, 1.0,1.0,0.7, 0.3,0.7,0.0, 0.0,0.0,-0.7, 0.3,-0.7,-1.0, 1.0,-1.0,-0.7, 1.7,-0.7,0.0,\n     3.0,  0.7,   2.0,0.0,0.7, 1.7,0.7,1.0, 1.0,1.0,0.7, 0.3,0.7,0.0, 0.0,0.0,-0.7, 0.3,-0.7,-1.0, 1.0,-1.0,-0.7, 1.7,-0.7,0.0,\n    // Round turret top\n     3.0,  1.0,\t 2.8,0.0,0.0, 2.8,0.0,0.0, 2.8,0.0,0.0, 2.8,0.0,0.0, 2.8,0.0,0.0, 2.8,0.0,0.0, 2.8,0.0,0.0, 2.8,0.0,0.0, \n     2.5,  1.0,\t 3.6,0.0,0.0, 3.6,0.0,0.0, 3.6,0.0,0.0, 3.6,0.0,0.0, 3.6,0.0,0.0, 3.6,0.0,0.0, 3.6,0.0,0.0, 3.6,0.0,0.0, \n     2.0,  1.0,  4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, \n    // Pointy barrel, still with round rear, and sloping back down to round.\n     2.0,  1.0,  10.0,0.0,7.07, 7.07,7.07,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,-7.07, 7.07,-7.07,0.0, \n     1.0,  1.0,  10.0,0.0,7.07, 7.07,7.07,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,-7.07, 7.07,-7.07,0.0, \n     1.0,  1.0,  4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, \n     0.5,  1.0,  4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, \n    // Narrow neck.   \n     0.5,  0.5,\t  3.0,0.0,0.0, 3.0,0.0,0.0, 3.0,0.0,0.0, 3.0,0.0,0.0, 3.0,0.0,0.0, 3.0,0.0,0.0, 3.0,0.0,0.0, 3.0,0.0,0.0, \n     0.0,  0.5,\t  3.0,0.0,0.0, 3.0,0.0,0.0, 3.0,0.0,0.0, 3.0,0.0,0.0, 3.0,0.0,0.0, 3.0,0.0,0.0, 3.0,0.0,0.0, 3.0,0.0,0.0, \n    // The bottom is mainly retangle-shaped in cross-section, but with the tread shape.\n     0.0,  1.0,   4.0,-4.0,0.0, 5.7,0.0,4.0, 4.0,-4.0,0.0,  5.7,0.0,4.0,  4.0,-4.0,0.0, 5.7,0.0,4.0, 4.0,-4.0,0.0,  5.7,0.0,4.0, \n    -0.3,  1.0,   5.0,-4.0,0.7, 6.4,0.7,5.0, 4.0,-5.0,-0.7, 6.4,-0.7,4.0, 5.0,-4.0,0.7, 6.4,0.7,5.0, 4.0,-5.0,-0.7, 6.4,-0.7,4.0, \n    -1.0,  1.0,   6.0,-4.0,1.4, 7.1,1.4,6.0, 4.0,-6.0,-1.4, 7.1,-1.4,4.0, 6.0,-4.0,1.4, 7.1,1.4,6.0, 4.0,-6.0,-1.4, 7.1,-1.4,4.0, \n    -2.0,  1.0,   6.0,-4.0,1.4, 7.1,1.4,6.0, 4.0,-6.0,-1.4, 7.1,-1.4,4.0, 6.0,-4.0,1.4, 7.1,1.4,6.0, 4.0,-6.0,-1.4, 7.1,-1.4,4.0, \n    -3.5,  1.0,   4.0,-4.0,0.0, 5.7,0.0,4.0, 4.0,-4.0,0.0,  5.7,0.0,4.0,  4.0,-4.0,0.0, 5.7,0.0,4.0, 4.0,-4.0,0.0,  5.7,0.0,4.0, \n    \n    -5.0,  0.0,   0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0\n    -5.0,  0.0,   0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0\n    -5.0,  0.0,   0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0\n);\nconst int ShapeSlices = 16;\n#endif\n\n\n\n// Returns the right-hand \"width\" for a viewer at a given heading from the shape,\n// and the depth at which it hits.\nvec2 CalculateSliceHeadingWidth ( int SliceNum, float Heading )\n{\n#if FORCE_CIRCULAR\n    return vec2 ( Shape[SliceNum*ShapeSliceSize+2], 0.0 );\n#else\n    // If the viewer is at heading 0.25, then the\n    // right-hand edge will be determined by the\n    // forward-facing part of the shape.\n    float WidthBlend = 8.0 * (Heading - 0.25);\n    if ( WidthBlend < 0.0 )\n    {\n        WidthBlend += 8.0;\n    }\n    int WidthIndex0 = int(floor(WidthBlend));\n    int WidthIndex1 = (WidthIndex0 + 1) & 7;\n    WidthIndex0 *= 3;\n    WidthIndex1 *= 3;\n    WidthBlend = fract(WidthBlend);\n    \n    // Widths are interpolated from one sgement to the next.\n    float WidthS0 = Shape[SliceNum*ShapeSliceSize+2+WidthIndex0];\n    float WidthS1 = Shape[SliceNum*ShapeSliceSize+2+WidthIndex1];\n    float Width = WidthS0 + WidthBlend * ( WidthS1 - WidthS0 );\n    \n    // Depths are interpolated, but the start and end are internal to each segment\n    float DepthS0 = Shape[SliceNum*ShapeSliceSize+3+WidthIndex0];\n    float DepthS1 = Shape[SliceNum*ShapeSliceSize+4+WidthIndex0];\n    float Depth = DepthS0 + WidthBlend * ( DepthS1 - DepthS0 );\n    \n    return vec2 ( Width, Depth );\n#endif\n}\n\n\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n#if SPECCY_REZ\n    // Real speccy rez is 256*192, but it aliases badly,\n    // and is the wrong aspect ratio, so tweak it a bit.\n    const vec2 SpecRez = vec2 ( 160.0, 90.0 );\n    uv = uv * SpecRez;\n    uv = floor ( uv );\n    int DitherX = (1 & int(uv.x));\n    int DitherY = (1 & int(uv.y));\n    uv = uv / SpecRez;\n#endif    \n    vec2 ndc = 2.0*uv - 1.0;\n    float AspectRatio = iResolution.y / iResolution.x;\n\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+ndc.xyx+vec3(0,2,4));\n#if SPECCY_REZ\n    col = vec3 ( 0.0, 0.0, 0.0 );\n#endif\n   \n    \n    vec3 CamPos = vec3 ( 0.0, 0.0, 0.0 );\n    // I like headings to be from 0.0 to 1.0, clockwise\n    float CamHeading = fract((iMouse.x/iResolution.x)*2.0);\n    CamPos.y = 10.0f * (0.5-fract((iMouse.y/iResolution.y)*2.0+0.5));\n    \n    float SunHeading = fract(iTime*0.01 + 0.125);\n    \n    float SunBrightness = 1.0;\n#if LIGHTNING\n    // Slightly quantise time...\n    float qTime = floor(iTime * 7.0);\n    if ( nrand(vec2(0.0,qTime)) < 0.05 )\n    {\n        SunBrightness = 2.0;\n        col *= 2.0;\n#if SPECCY_REZ\n        if ( DitherX != DitherY )\n        {\n\t    \tcol = vec3 ( 1.0, 1.0, 1.0 );\n        }\n#endif\n    }\n#endif    \n    \n    float ShapeHeading = fract(iTime*0.1);\n    //ShapeHeading = 0.125;\n    \n    vec3 ShapePos = vec3 ( 0.0, 0.0, 20.0 );\n    \n    float tanHFov = 0.5;\n    vec2 tanFov = vec2 ( tanHFov, tanHFov * AspectRatio );\n   \n\n    \n    vec3 CenterPos = ShapePos - CamPos;\n    float TwoPi = 2.0*3.1415927;\n    vec2 sincosH = vec2(sin(CamHeading*TwoPi),cos(CamHeading*TwoPi));\n    vec3 CamCenterPos = vec3(\n        sincosH.y * CenterPos.x - sincosH.x * CenterPos.z,\n        CenterPos.y,\n        sincosH.x * CenterPos.x + sincosH.y * CenterPos.z);\n\n    float CamSunHeading = fract(SunHeading-CamHeading);\n    \n    // Shades are 2 = fully lit, 1 = half lit, 0 = unlit.\n    // The actual colour will be determined by the segment's brightness/characteristics.\n    int ShadeL = 0;\n    int ShadeM = 0;\n    int ShadeR = 0;\n    \n    float ColourBlendL = 0.0;\n    float ColourBlendR = 0.0;\n    \n    // These are the headings of the L and R visible terminator lines\n    // between the lit sections, *in shape space*.\n    float ShapeHeadingSun = SunHeading-ShapeHeading;\n    float ShapeHeadingLightL = 0.0;\n    float ShapeHeadingLightR = 0.0;\n    \n#if TWO_SHADE\n    // 2-shade rendering - shape has two sides -\n    // the lit one facing the sun and the unlit one facing away\n    // Only CamBlendL and ColourLeft/Right are used here.\n    if ( CamSunHeading < 0.5 )\n    {\n        // Sun to the right\n    \tShadeL = 1;\n        ShadeR = 2;\n    \tColourBlendL = 1.0f-((CamSunHeading - 0.0) * 4.0);\n        \n        ShapeHeadingLightL = ShapeHeadingSun + 0.5;\n    }\n    else\n    {\n        // Sun to the left\n    \tShadeL = 2;\n        ShadeR = 1;\n    \tColourBlendL = 1.0f-((CamSunHeading - 0.5) * 4.0);\n        \n        ShapeHeadingLightL = ShapeHeadingSun;\n    }\n#else\n    // 2-shade rendering - shape has four sides -\n    // the lit one facing the sun, the unlit one facing away,\n    // and the half-lit ones in between.\n    float TempHeading = fract(CamSunHeading + 0.125);\n    if ( TempHeading < 0.25 )\n    {\n        // Looking at back side\n    \tShadeL = 1;\n    \tShadeM = 0;\n        ShadeR = 1;\n    \tColourBlendL = 0.0f-(TempHeading * 4.0);\n        ColourBlendR = ColourBlendL + 1.0;\n        \n        ShapeHeadingLightR = ShapeHeadingSun + 0.125 + 0.5;\n        ShapeHeadingLightL = ShapeHeadingLightR + 0.25;        \n    }\n    else if ( TempHeading < 0.5 )\n    {\n        // Sun on the right\n    \tShadeL = 0;\n    \tShadeM = 1;\n        ShadeR = 2;\n    \tColourBlendL = 1.0f-(TempHeading * 4.0);\n        ColourBlendR = ColourBlendL + 1.0;\n\n        ShapeHeadingLightR = ShapeHeadingSun + 0.125 + 0.25;\n        ShapeHeadingLightL = ShapeHeadingLightR + 0.25;        \n    }\n    else if ( TempHeading < 0.75 )\n    {\n        // Looking at lit side\n    \tShadeL = 1;\n    \tShadeM = 2;\n        ShadeR = 1;\n    \tColourBlendL = 2.0f-(TempHeading * 4.0);\n        ColourBlendR = ColourBlendL + 1.0;\n        \n        ShapeHeadingLightR = ShapeHeadingSun + 0.125;\n        ShapeHeadingLightL = ShapeHeadingLightR + 0.25;        \n    }\n    else\n    {\n        // Sun on left\n    \tShadeL = 2;\n    \tShadeM = 1;\n        ShadeR = 0;\n    \tColourBlendL = 3.0f-(TempHeading * 4.0);\n        ColourBlendR = ColourBlendL + 1.0;\n\n        ShapeHeadingLightR = ShapeHeadingSun + 0.125 - 0.25;\n        ShapeHeadingLightL = ShapeHeadingLightR + 0.25;        \n\t}\n#endif\n    \n    // ColourBlend are currently just a linear -1...0...1 ramp\n    // which is not physically correct, so \"sineify\" them\n    float ColourDepthL = cos ( ColourBlendL * 3.1415927 * 0.5 );\n    float ColourDepthR = cos ( ColourBlendR * 3.1415927 * 0.5 );\n    ColourBlendL = sin ( ColourBlendL * 3.1415927 * 0.5 );\n    ColourBlendR = sin ( ColourBlendR * 3.1415927 * 0.5 );\n    \n    // Which widths in each slice are we looking at for each side of the shape?\n    float CamShapeHeading = fract(ShapeHeading-CamHeading);\n    float CamShapeHeadingL = fract(CamShapeHeading - 0.5);\n    float CamShapeHeadingR = fract(CamShapeHeading);\n    \n    ShapeHeadingLightL = fract(ShapeHeadingLightL);\n    ShapeHeadingLightR = fract(ShapeHeadingLightR);\n    \n    \n    \n    // We don't apply any perspective within the shape,\n    // just to its center, so we can immediately calculate the width & height of the ray from the current pixel.\n    // World-space position WorldPos.xyz will map to NDC:\n    // Ndc.xy = CamPos.xy / CamPos.z * tanFov;\n    // So if we assume WorldPos.z, we can reverse that to find the WorldPos.xy\n    float CamZ = CamCenterPos.z;\n    vec2 CamPixelPos = ndc * CamZ * tanFov;\n    vec2 ObjPos = CamPixelPos - CamCenterPos.xy;\n\n    vec3 ColourLeft  = vec3 ( 0.0, 0.0, 0.0 );\n    vec3 ColourMid   = ColourLeft;\n    vec3 ColourRight = ColourLeft;\n    \n    if ( CamZ > 0.0 )\n    {\n        // This would be done by scanline rendering, starting at the top one and scanning down using deltas.\n        // But obviously we have to do it strangely in a pixel shader.\n        float WidthL = 0.0;\n        float WidthR = 0.0;\n        float ColourWidthL = 0.0;\n        float ColourWidthR = 0.0;\n        if ( ObjPos.y > float(Shape[0]) )\n        {\n            // Off the top.\n        }\n        else\n        {\n            for ( int SliceNum = 0; SliceNum < ShapeSlices-1; SliceNum++ )\n            {\n                if ( ObjPos.y > Shape[SliceNum*ShapeSliceSize+ShapeSliceSize] )\n                {\n                    // This is the correct segment\n                    float ShapeY0    = Shape[SliceNum*ShapeSliceSize+0];\n                    float ShapeY1    = Shape[SliceNum*ShapeSliceSize+ShapeSliceSize];\n                    float ShapeShade = Shape[SliceNum*ShapeSliceSize+1];\n                    \n                    vec2 Shape0L = -CalculateSliceHeadingWidth ( SliceNum, CamShapeHeading - 0.5 );\n                    vec2 Shape0R =  CalculateSliceHeadingWidth ( SliceNum, CamShapeHeading );\n                    vec2 Shape1L = -CalculateSliceHeadingWidth ( SliceNum+1, CamShapeHeading - 0.5 );\n                    vec2 Shape1R =  CalculateSliceHeadingWidth ( SliceNum+1, CamShapeHeading );\n                    \n                    vec2 Light0L =  -CalculateSliceHeadingWidth ( SliceNum, ShapeHeadingLightL );\n                    vec2 Light0R =   CalculateSliceHeadingWidth ( SliceNum, ShapeHeadingLightR );\n                    vec2 Light1L =  -CalculateSliceHeadingWidth ( SliceNum+1, ShapeHeadingLightL );\n                    vec2 Light1R =   CalculateSliceHeadingWidth ( SliceNum+1, ShapeHeadingLightR );\n                    \n                    // Transform the (width,depth) pairs we got for\n                    // light intersections into horizontal offsets.\n                    // ColourDepthL is cos(angle), ColourBlendL is sin(angle)\n                    float LightOffset0L = -ColourDepthL * Light0L.y - ColourBlendL * Light0L.x;\n                    float LightOffset0R =  ColourDepthR * Light0R.y + ColourBlendR * Light0R.x;\n                    float LightOffset1L = -ColourDepthL * Light1L.y - ColourBlendL * Light1L.x;\n                    float LightOffset1R =  ColourDepthR * Light1R.y + ColourBlendR * Light1R.x;                   \n                    \n                    // Now lerp vertically.\n                    float HeightLerp = (ObjPos.y - ShapeY0)/(ShapeY1 - ShapeY0);\n                    \n                    WidthL = Shape0L.x + HeightLerp * ( Shape1L.x - Shape0L.x );\n                    WidthR = Shape0R.x + HeightLerp * ( Shape1R.x - Shape0R.x );\n                    ColourWidthL = LightOffset0L + HeightLerp * ( LightOffset1L - LightOffset0L );\n                    ColourWidthR = LightOffset0R + HeightLerp * ( LightOffset1R - LightOffset0R );\n\n                    // Right now the \"shade\" thing isn't implemented, except for \n                    // making stuff fully lit.\n                    if ( ShapeShade < -0.1 )\n                    {\n                        // Self-illuminated.\n                    \tColourLeft  = vec3(1.0,1.0,1.0);\n                        ColourMid   = vec3(1.0,1.0,1.0);\n                        ColourRight = vec3(1.0,1.0,1.0);\n                    }\n                    else\n                    {\n                        //ShapeShade *= SunBrightness;\n                        // This looks nicer...\n                        ShapeShade += 0.25*(SunBrightness-1.0);\n                        \n                        int ShadeShift = int(floor(5.0 * (1.0-ShapeShade)));\n#if SPECCY_REZ\n                        int DitherShade = 0 + DitherX*2;\n                        if ( DitherY == 0 )\n                        {\n                            DitherShade = 3 - DitherX*2;\n                        }\n                        \n                        vec3 ColourOn = vec3 ( 1.0, 1.0, 1.0 );\n                        vec3 ColourOff = vec3 ( 0.0, 0.0, 0.0 );\n\n                        ColourLeft  = ( ShadeL*2-ShadeShift > DitherShade ) ? ColourOn : ColourOff;\n                        ColourMid   = ( ShadeM*2-ShadeShift > DitherShade ) ? ColourOn : ColourOff;\n                        ColourRight = ( ShadeR*2-ShadeShift > DitherShade ) ? ColourOn : ColourOff;\n                        \n#else\n                        vec3 Colours[] = vec3[] (\n                            vec3(0.2,0.2,0.2),\n                            vec3(0.4,0.4,0.15),\n                            vec3(0.6,0.6,0.1),\n                            vec3(0.8,0.8,0.05),\n                            vec3(1.0,1.0,0.0)\n                        );\n                        \n                        ColourLeft  = Colours[max(0,ShadeL*2-ShadeShift)];\n                        ColourMid   = Colours[max(0,ShadeM*2-ShadeShift)];\n                        ColourRight = Colours[max(0,ShadeR*2-ShadeShift)];\n#endif\n                    }\n                    break;\n                }\n            }\n            if (( ObjPos.x>WidthL ) && ( ObjPos.x<WidthR ))\n            {\n#if TWO_SHADE\n                if ( ObjPos.x>(ColourWidthL) )\n                {\n                    col = ColourRight;\n                }\n                else\n                {\n                    col = ColourLeft;\n                }\n#else\n                if ( ObjPos.x>ColourWidthR )\n                {\n                    col = ColourRight;\n                }\n                else if ( ObjPos.x>ColourWidthL )\n                {\n                    col = ColourMid;\n                }\n                else\n                {\n                    col = ColourLeft;\n                }\n#endif               \n            }\n            #if DEBUG_MODE\n            else\n            {\n                if ( ( ObjPos.x > 0.0 ) && ( ObjPos.x<ColourWidthR ) )\n                {\n                    col = vec3(1.0,0.0,0.0);\n                }\n                else if ( ( ObjPos.x < 0.0 ) && ( ObjPos.x>ColourWidthL ) )\n                {\n                    col = col = vec3(0.0,1.0,0.0);\n                }                \n            }\n            #endif\n        }\n    }\n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}