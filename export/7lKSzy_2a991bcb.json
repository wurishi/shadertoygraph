{"ver":"0.1","info":{"id":"7lKSzy","date":"1640957225","viewed":294,"name":"NURBS Curve","username":"PrzemyslawZaworski","description":"Third degree NURBS curve with four control points and eight knot vectors. Each control point is: x, y, z, weight.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["tutorial","bezier","curve","nurbs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float Line( vec2 p, vec2 a, vec2 b )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h );\n    return smoothstep(0.01, 0.001, d);\n}\n\n// L. Piegl, W. Tiller, \"The NURBS Book\", Springer Verlag, 1997\n// http://nurbscalculator.in/\nvec3 NurbsCurve( vec4 cps[4], int cpsLength, float knots[8], int knotsLength, float u )\n{\n    const int degree = 3;\n    for (int t = 0; t < cpsLength; t++) cps[t].xyz *= cps[t].w;\n    int index = 0;\n    vec4 p = vec4(0.0);\n    int n = knotsLength - degree - 2;\n    if (u == (knots[n + 1])) index = n;\n    int low = degree;\n    int high = n + 1;\n    int mid = int(floor((float(low) + float(high)) / 2.));\n    for (int i = 0; i < 12; i++) // unroll while loop manually\n    {\n        if (u < knots[mid] || u >= knots[mid + 1])\n        {\n            if (u < knots[mid])\n                high = mid;\n            else\n                low = mid;\n            mid = int(floor((float(low) + float(high)) / 2.0));\n        }\n    }\n    index = mid;\n    float N[degree + 1];\n    float left[degree + 1];\n    float right[degree + 1];\n    float saved = 0.0, temp = 0.0;\n    N[0] = 1.0;\n    for (int j = 1; j <= degree; j++)\n    {\n        left[j] = (u - knots[index + 1 - j]);\n        right[j] = knots[index + j] - u;\n        saved = 0.0f;\n        for (int r = 0; r < j; r++)\n        {\n            temp = N[r] / (right[r + 1] + left[j - r]);\n            N[r] = saved + right[r + 1] * temp;\n            saved = left[j - r] * temp;\n        }\n        N[j] = saved;\n    }\n    for (int i = 0; i <= degree; i++) p += cps[index - degree + i] * N[i];\n    return (p.w != 0.) ? p.xyz / p.w : p.xyz;\n}\n            \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;   \n    vec4[] controlPoints = vec4[] \n    (\n        vec4(-1.0, -1.0, 0.0, 1.0), \n        vec4(-0.5,  1.0, 0.0, 1.0), \n        vec4( 0.5, -1.0, 0.0, 1.0), \n        vec4( 1.0,  1.0, 0.0, 1.0)\n    );\n    float[] knots = float[] (0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0);\n    const int vertexCount = 64;\n    float color = 0.0;\n    vec2[vertexCount] evaluation;\n    for (int i = 0; i < vertexCount; i++)\n    {\n        float u = float(i) / float(vertexCount - 1);\n        vec3 p = NurbsCurve (controlPoints, controlPoints.length(), knots, knots.length(), u);\n        evaluation[i] = p.xy;\n    }\n    for (int i = 0; i < (vertexCount - 1); i++)\n    {\n        color = color + Line(uv, evaluation[i], evaluation[i+1]);\n    }\n    fragColor = vec4(color);\n}","name":"Image","description":"","type":"image"}]}