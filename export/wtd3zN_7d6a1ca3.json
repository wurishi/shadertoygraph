{"ver":"0.1","info":{"id":"wtd3zN","date":"1575839990","viewed":78,"name":"ball and cube","username":"Anskiere","description":"-","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime\n\nconst float maxDist = 200.;\nconst float planeDist = 2.;\n\nfloat sin01(float x)\n{\n    return sin(x) * 0.5 + 0.5;\n}\n\nfloat cos01(float x)\n{\n    return cos(x) * 0.5 + 0.5;\n}\n\nvec3 lightPos()\n{\n    return vec3(1,1,1);\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp((a - b)/k + 0.5, 0., 1.);\n    float m = h * (1. - h) * 0.5 * k;\n    float r = mix(a, b, h) - m;\n    return r;\n}\n\nvec3 cameraPos()\n{\n    float t = time * 0.1;\n\n    vec3 res = vec3(\n        sin(t) * 10.,\n        4.,\n        -cos(t) * 10.);\n\n    return res;\n}\n\nvec3 getRay(vec2 uv)\n{\n    vec3 cam = cameraPos();\n    vec3 origin = vec3(0, 0, 0);\n    vec3 look = normalize(origin - cam);\n    vec3 upGlob = vec3(0,1,0);\n    vec3 right = normalize(cross(upGlob, look));\n    vec3 camUp = normalize(-cross(right, look));\n\n    vec3 p = cam + camUp * uv.y + right * uv.x;\n    p += look * planeDist;\n\n    vec3 res = p - cam;\n    return normalize(res);\n}\n\nfloat getSphere(vec3 p, float size, vec3 origin)\n{\n    return length(p - origin) - size;\n}\n\nfloat getSphere(vec3 p, float size)\n{\n    return getSphere(p, size, vec3(0,0,0));\n}\n\nfloat getCube(vec3 p, float size)\n{\n    p = abs(p);\n    return max(max(p.x, p.y), p.z) - size;\n}\n\nfloat getInfCylinder(vec3 p, float size)\n{\n    float l = length(vec3(p.x, p.y, 0)) - size;\n    return l;\n}\n\nfloat getFractalCube(vec3 p, int iter)\n{\n    return 0.;\n}\n\nfloat getPlane(vec3 p)\n{\n    return p.y;\n}\n\nfloat inter(float a, float b)\n{\n    return max(a, b);\n}\n\nfloat un(float a, float b)\n{\n    return min(a, b);\n}\n\nfloat diff(float a, float b)\n{\n    return max(a, -b);\n}\n\nfloat getCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat getSd(vec3 p)\n{\n    float sd = getSphere(p + vec3(0,cos(time),0)*2., 0.5);\n    float sd2 = getSphere(p + vec3(cos(time*1.23),0,0)*2., 0.5);\n    \n    float cyld = getInfCylinder(p, 0.9);\n    float cd = getCube(p, 1.);    \n    cd = diff(cd, cyld);\n    \n    float res = smin(cd, sd, 1.);\n    res = smin(res, sd2, 1.);\n\n    return res;\n}\n\nvec3 calculateNormal(vec3 p)\n{\n    const float delta = 0.005;\n    vec3 grad;\n    grad.x =\n        getSd(vec3(p.x + delta, p.y, p.z)) -\n        getSd(vec3(p.x - delta, p.y, p.z));\n\n    grad.y =\n        getSd(vec3(p.x, p.y + delta, p.z)) -\n        getSd(vec3(p.x, p.y - delta, p.z));\n\n    grad.z =\n        getSd(vec3(p.x, p.y, p.z + delta)) -\n        getSd(vec3(p.x, p.y, p.z - delta));\n\n    return normalize(grad);\n}\n\nfloat raymarch(vec3 sp, vec3 ray)\n{\n    float depth = 0.;\n\n    for(int i = 0; i < 100; i++)\n    {\n        vec3 p = sp + ray * depth;\n        float dist = getSd(p);\n\n        if (dist <= 0.01)\n            return depth;\n\n        depth += dist;\n\n        if (depth >= maxDist)\n            return maxDist;\n    }\n\n    return maxDist;\n}\n\nfloat getShadow(vec3 p)\n{\n    vec3 lp = lightPos();\n    float ld = length(lp - p);\n    vec3 ray = normalize(lp - p);\n    float d = raymarch(p + ray*0.2, ray);\n    float res = smoothstep(0.1,1., d);\n    res = res * 0.3 + 0.7;\n    return res;\n}\n\nfloat getSpec(vec3 refRay, vec3 l)\n{\n    float x = dot(refRay, l);\n\n    x = clamp(x,0.,1.);\n    x = pow(x, 10.);\n\n    return x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x /= iResolution.y / iResolution.x;\n    //  vec3 ray = normalize(vec3(uv, 0) - cameraPos());\n    vec3 ray = getRay(uv);\n    vec3 camPos = cameraPos();\n    float d = raymarch(camPos, ray);\n    float inf = step(1., maxDist - d);\n    vec3 col = vec3(0.1);\n\n    if (d > 30.)\n    {\n        vec3 x = texture(iChannel0, ray).rgb;\n        fragColor = vec4(x,0);\n        return;\n    }\n\n    vec3 intP = cameraPos() + d*ray;\n    vec3 n = calculateNormal(intP);\n    vec3 lightDir = normalize(vec3(1));\n    float dd = dot(n, lightDir);\n    float shadow = getShadow(intP);\n\n    dd = dd *.5 +.5;\n    //dd = floor(dd * 4.)/4.;\n    // dd = fract(dd + time*3.);\n\n    vec3 res = col * dd * inf;// * shadow ;\n\n    vec3 refRay = reflect(ray, n);\n    vec3 refl = texture(iChannel0, refRay).rgb;\n\n    float frenel = 1.-clamp(dot(n,-ray),0.,1.);\n    frenel = smoothstep(.1, 1., frenel);\n    frenel = frenel*0.9+.1;\n\n    res += refl*frenel;\n\n    // res += getSpec(refRay, lightDir);\n    fragColor = vec4(pow(res, vec3(.75)), 0);\n}","name":"Image","description":"","type":"image"}]}