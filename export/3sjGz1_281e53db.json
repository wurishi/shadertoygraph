{"ver":"0.1","info":{"id":"3sjGz1","date":"1548164254","viewed":106,"name":"Metaballs - Fizzz","username":"Fizzz","description":"Porting and improving one of my metaballs project from school.\nMetaballs with ray marching and sphere intersection","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["metaballs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float WIDTH = 800.0;\nconst float HEIGHT = 500.0;\nconst int maxSteps = 200;\nconst float minDist = 0.0;\nconst float maxDist = 50.0;\nconst float epsilon = 0.0001;\nconst int numMetaballs = 7;\nvec4 u_Metaballs[numMetaballs];\nvec4 u_MetaballsColor[numMetaballs];\n\n\nfloat sminClamp(float a, float b, float k) {\n  float h = max(k - abs(a-b), 0.0) / k;\n  return min(a, b) - h*h*k*(1.0/4.0);\n}\n\nfloat sphereSDF(vec3 pos, vec4 sphere) {\n  return length(pos - sphere.xyz) - sphere.w;\n}\n\nfloat cubeSDF(vec3 pos, vec4 cube) {\n    vec3 d = abs(pos - cube.xyz) - vec3(cube.w);\n    float insideDist = min(max(d.x, max(d.y, d.z)), 0.0);\n    float outsideDist = length(max(d, 0.0));\n    return insideDist + outsideDist;\n}\n\nfloat torusSDF(vec3 pos, vec4 torus) {\n    vec2 q = vec2(length(pos.xz - torus.xz) - torus.w, pos.y - torus.y);\n    return length(q) - 0.3;\n}\n\nfloat sceneSDF(vec3 pos) {\n  float smin = maxDist;\n  for (int i = 0; i < numMetaballs; i++) {\n    if(i < 4 && i != 0) {\n        smin = sminClamp(smin, cubeSDF(pos, u_Metaballs[i]), 0.8);\n    } else if (i == 0) {\n        smin = sminClamp(smin, torusSDF(pos, u_Metaballs[i]), 1.8);\n    } else {\n        smin = sminClamp(smin, sphereSDF(pos, u_Metaballs[i]), 0.8);\n    }\n  }\n  return smin;\n}\n\nfloat shortestDistanceToSurface(vec3 cam, vec3 dir, float start, float end) {\n  float depth = start;\n  for (int i = 0; i < maxSteps; i++) {\n    float dist = sceneSDF(cam+depth * dir);\n    if(dist < epsilon) {\n      return depth;\n    }\n    depth += dist;\n    if (depth >= end) {\n      return end;\n    }\n  }\n  return end;\n}\n\nvec3 estimateColor(vec3 pos, float dist) {\n  float smin = 0.0;\n  vec3 color = vec3(0.0);\n  for (int i = 0; i < numMetaballs; i++) {\n    float newSmin = sphereSDF(pos, u_Metaballs[i]);\n     color += u_MetaballsColor[i].xyz * (newSmin/dist) * 3.0;\n  }\n  return color/float(numMetaballs);\n}\n\nvec3 phongIllumination(vec3 pos, vec3 cam, float dist) {\n  vec3 kd = estimateColor(pos, dist);\n  vec3 ks = vec3(0.5);\n  float alpha = 5.0;\n  vec3 color = kd;// * 0.3;\n  vec3 light1Pos = vec3(0.0, 0.0, 4.0);\n  vec3 light1Inte = vec3(0.3);\n  //color += phongContribForLight(kd, ks, alpha, pos, cam, light1Pos, light1Inte);\n  return color;\n}\n\nvoid SetColors() {\n    u_MetaballsColor[0] = vec4(1.0, 0.0, 0.0, 1.0);\n    u_MetaballsColor[1] = vec4(0.0, 1.0, 0.0, 1.0);\n    u_MetaballsColor[2] = vec4(0.0, 1.0, 0.0, 1.0);\n    u_MetaballsColor[3] = vec4(0.0, 0.0, 1.0, 1.0);\n    u_MetaballsColor[4] = vec4(0.0, 0.0, 1.0, 1.0);\n\tu_MetaballsColor[5] = vec4(1.0, 0.0, 0.0, 1.0);\n    u_MetaballsColor[6] = vec4(1.0, 0.0, 0.0, 1.0);\n}\n\nvoid UpdateObjects(float time) {\n    u_Metaballs[0] = vec4(0.0, 0.0, 0.0, 1.0);\t\t\t\t\t\t\t\t\t\t//Torus\n    u_Metaballs[1] = vec4(vec3(3.0+cos(time*2.2), 1.0+cos(time*2.3), 1.0+cos(time*2.7)), 0.4);\t//Cube\n    u_Metaballs[2] = vec4(vec3(1.0+cos(time*1.7), 1.0+cos(time*2.9), 1.0+cos(time*3.3)), 0.4);\t//Cube\n    u_Metaballs[3] = vec4(vec3(2.0+cos(time*1.3), 1.0+cos(time*3.9), 1.0+sin(time*2.1)), 0.4);\t//Cube\n    u_Metaballs[4] = vec4(vec3(cos(time*1.5), 1.0+sin(time*1.3), 0.0), 1.0);\t\t\t//Sphere\n\tu_Metaballs[5] = vec4(vec3(-1.0+sin(time*2.3), 1.0+sin(time*2.7), 1.0+sin(time*1.7)), 0.4);\t//Sphere\n    u_Metaballs[6] = vec4(vec3(-3.0+sin(time*3.3), 1.0+sin(time*3.9), 1.0+sin(time*3.9)), 0.4);\t//Sphere\n}\n\nvec3 background( vec3 rd )\n{\n\treturn texture(iChannel0, rd).rgb;\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = (fragCoord.xy - iResolution.xy / 2.0) / min(iResolution.xy.x, iResolution.xy.y);\n    vec2 mouse = (iMouse.xy - iResolution.xy / 2.0) / min(iResolution.xy.x, iResolution.xy.y);\n    \n    float time = iTime;\n    //vec3 campos = vec3(10.0 * sin(time * 0.3 + 3.0 * mouse.x), 2.5 * sin(time * 0.5), -10.0 * cos(time * 0.3 + 3.0 * mouse.x));\n    vec3 campos = vec3(0.0, 2.5, 8.0);\n    vec3 camtar = vec3(0.0, 0.0, 0.0);\n    \n    mat3 camMat = calcLookAtMatrix(campos, camtar, 0.0);  // 0.0 is the camera roll\n\tvec3 camdir = normalize(camMat * vec3(xy, 1.0) ); // 2.0 is the lens length\n    \n    vec3 color = vec3(0.0, 0.0, 0.0);\n    SetColors();\n    UpdateObjects(time);\n    \n    float dist = shortestDistanceToSurface(campos, camdir, minDist, maxDist);\n    if (dist > maxDist - epsilon) {\n        color = background(camdir);\n    }\n    else {\n        vec3 pos = campos + dist * camdir;\n    \tcolor = phongIllumination(pos, campos, dist);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\n","name":"Image","description":"","type":"image"}]}