{"ver":"0.1","info":{"id":"X32fDD","date":"1729476005","viewed":101,"name":"Jumping experiment","username":"Elsio","description":"Eu comecei arrancando toda a beleza do shader do mestre @shane. Eu vivo fazendo isso. \nMas as vezes fica interessante publicar pois a técnica escondida por trás de toda aquela beleza, na minha opinião, precisa ser esmiuçada e disseminada. ","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","grid","rubber","geometry","shane","traversal","mufin"],"hasliked":0,"parentid":"lXBfDh","parentname":"Concave Heptagon Traversal study"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// shaders lindos ♥ https://www.shadertoy.com/playlist/cXBGzV\n\n#define rot(a) mat2(cos(a + vec4(0, 11, 33, 0)))\n#define cor(p) fract(29. * cos(vec4(p.xy, p.x * p.y, 0) + 15.))\n#define t iTime\n#define FAR 20.\n#define PI acos(-1.)\n#define TAU (2.*PI)\n\nfloat shape;\nvec2 ID = vec2(1e5);\n\nfloat h21(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 43.123);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hm(vec2 p, inout float tm) {\n    float rnd = h21(p + .13);\n    \n    tm = mod(rnd * 8. + iTime * 4. / TAU, 8.);\n    tm = tm < 1. ? tm : 0.;\n    \n    float w = dot(sin(p * 1.4 - cos(p.yx * 2.2 + mod(iTime, TAU)) * 2.), vec2(.25)) + .5;\n    float h = .5 - cos(tm * TAU) * .5;\n    \n    return (h / 4. + .25) * w + h;\n}\n\n\nfloat opExtrusion(float sdf, float pz, float h){\n    float sf = .08;\n    vec2 w = vec2(sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n}\n\nfloat sBoxS(vec2 p, vec2 b, float sf) {\n    vec2 d = abs(p) - b + sf;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n\nmat2 dice(vec2 id, float tm, float delay){\n    float d = h21(id + .07) < .5 ? 1. : -1.;\n          d *= h21(id + .05) < .5 ? 2. : 1.;\n    \n    return abs(tm - .5) < .5 - delay\n                    ? rot( d * (tm - delay) / (1. - delay * 2.) * PI )\n                    : mat2(1);\n}\n\n\nvec3 block(vec3 p, int i) {\n    mat4x2 V = mat4x2(-1, 1, 1, 1, 1, -1, -1, -1);\n    \n    vec2 id = floor(p.xy / 2. - V[i] / 4.) * 2.  +  V[i] / 2.  +  1.,\n         q = p.xy - id;\n    \n    float d, tm, delay = .175,\n          h = hm(id, tm);\n\n    shape = min(shape, sBoxS(q.xy, vec2(.43), .2));\n\n    vec3 p3 = vec3(q, p.z + (h * 2. -.48));\n    p3.zy *= dice(id, tm, delay);\n\n    d = sBoxS(p3.xy, vec2(.43), .24);\n\n    if((i & 1) == 0) d = max(d, -d - .36);\n\n    d = opExtrusion(d, p3.z, .4) \n         + tanh(cos(d * 50.) * 5.) * .02\n         + (abs(p3.y) < .4 ? 0. :smoothstep(.0, .1, abs(fract(q.x * 6.) - .5) - .2) * .02)\n         + (abs(p3.x) < .4 ? 0. :smoothstep(.0, .1, abs(fract(p3.y * 6.) - .5) - .2) * .02)\n         + d * .3;\n\n    return vec3(id, d);\n}\n\n\nfloat blocks(vec3 p) {\n    float d = shape = 1e5;\n    \n    for(int i; i < 4; i ++) {\n        vec3 ret = block(p, i);\n        if(ret.z < d){\n            d = ret.z;\n            ID = ret.xy;\n        }\n    }\n    \n    return d;\n}\n\nfloat table(vec3 p){\n    float \n    tb = -min(\n              p.z - .02, \n              max(\n                 shape, \n                 abs(p.z) - 1.\n              )\n          );\n    \n    tb -= smoothstep(-.5, .5, sin(shape * TAU * 8.)) * .02;\n    tb -= shape * .25;\n    \n    return tb;\n}\n\nfloat map(vec3 p) {\n    float\n    bl = blocks(p),\n    tb = table(p);\n    \n    ID *= step(bl, tb);\n    return min(tb, bl);\n}\n\nfloat march(vec3 ro, vec3 rd) {\n    float t, d, i;\n    \n    while(i++ < 64.) {\n        d = map(ro + rd * t);\n        if(abs(d) < .01 || t > FAR) break;\n        t += i < 32. ? d * .4 : d * .9;\n    }\n    \n    return min(t, FAR);\n}\n\n\nvec3 normal(vec3 p) {\n    vec3 e = vec3(.001, 0, 0);\n    vec3 v = vec3(\n                 map(p - e.xyy),\n                 map(p - e.yxy),\n                 map(p - e.yyx)\n             ) - map(p);\n    return normalize(-v);\n}\n\nfloat AO(vec3 p, vec3 n) {\n    float sca = 2.,\n        occ = 0.;\n    \n    for(int i = 0; i < 8; i ++) {\n        float hr = float(i + 1) * .15 / 5.;\n        float d = map(p + n * hr);\n        occ +=(hr - d) * sca;\n        sca *= .65;\n    }\n    return clamp(1. - occ, 0., 1.);\n}\n\nvoid mainImage(out vec4 o, vec2 u) {\n    vec2 r = iResolution.xy;\n    u = (u - r / 2.) / r.y;\n    \n    vec3 ro = vec3(0, 0, -5),\n         D = normalize(vec3(u, tanh(cos(iTime * .1) * 3.) * 2. + 3.));\n    \n    D.yz *= rot(PI / 3. + tanh(cos(iTime * .3) * 3.) * .2 - .2);\n    D.xy *= rot(PI / 3. + tanh(cos(iTime * .2) * 5.) * .3);\n    ro.y += iTime;\n    \n    float d = march(ro, D);\n    \n    o *= 0.;\n    \n    if(d < FAR) {\n        vec3 p = ro + d * D,\n             N = normal(p);\n             \n        o = vec4(\n                length(sin(N) * .25 + .5)\n                    * (ID != vec2(0) ? cor(ID) : vec4(1))\n                    * AO(p, N)\n            );\n    }\n}","name":"Image","description":"","type":"image"}]}