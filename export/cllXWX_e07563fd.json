{"ver":"0.1","info":{"id":"cllXWX","date":"1675426890","viewed":63,"name":"Manu_Cheremeh partiel","username":"manchere","description":"fantominus","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fantominus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nvec4 opSubtraction(vec4 d1, vec4 d2) {\n    return max(d1, d2);\n}\n\nvec4 sdCube(vec3 p, vec3 b, vec3 offset, vec3 col) {\n    vec3 q = abs(p) - b;\n    float d = length(max(q, 0.0) - offset) + min(max(q.x, max(q.y, q.z)), 0.0) ;\n    return vec4(d, col);\n}\n\nvec4 sdSphere(vec3 p, float r, vec3 offset, vec3 col)\n{\n  float d = length(p - offset) - r;\n  return vec4(d, col);\n}\n\nvec4 sdCone( vec3 p, vec2 c, vec3 col )\n{\n    vec2 q = vec2( length(p.xz), - p.y );\n    float d = length(q-c*max(dot(q,c), 0.0));\n    return vec4(d * ((q.x*c.y-q.y*c.x<0.0)?-1.0:1.0), col);\n}\n\nvec4 sdCutSphere( vec3 p, float r, float h, vec3 col)\n{\n  float w = sqrt(r*r-h*h);\n\n  vec2 q = vec2( length(p.xz), p.y );\n  float s = max( (h-r)*q.x*q.x+w*w*(h+r-2.0*q.y), h*q.x-w*q.y );\n  return vec4((s<0.0) ? length(q)-r :\n         (q.x<w) ? h - q.y     :\n                   length(q-vec2(w,h)), col);\n}\nvec4 sdFloor(vec3 p, vec3 col) {\n  float d = p.y + 7.;\n  return vec4(d, col);\n}\n\nvec4 minWithColor(vec4 obj1, vec4 obj2) {\n  if (obj2.x < obj1.x) {\n      return obj2;\n  }\n  return obj1;\n}\n\nvec4 sdScene(vec3 p) {\n  vec4 leftEye = sdSphere(p, .9, vec3(-1., 1.2, -4), vec3(1, 1, 1));\n  vec4 rightEye = sdSphere(p, .9, vec3(1., 1.2, -4), vec3(1, 1, 1));\n  vec4 eye = sdCone(p , vec2(0.3, 1), vec3(1., 0.5, 1.));\n  vec4 body = sdSphere(p, 2.5, vec3(0, 1, -6.6), vec3(0.1, 0.05, 0.1));\n  vec4 co = minWithColor(leftEye, rightEye); //co = closest object containing sd and color\n  co = minWithColor(co, sdFloor(p, vec3(0.1, 0.1, 0.9)));\n  co = minWithColor(co, body);\n  co = minWithColor(co, eye);\n\n  return co;\n}\n\nvec4 rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n  vec4 co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = sdScene(p);\n    depth += co.x;\n    if (co.x < PRECISION || depth > end) break;\n  }\n  \n  vec3 col = vec3(co.yzw);\n\n  return vec4(depth, col);\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; \n    return normalize(\n      e.xyy * sdScene(p + e.xyy).x +\n      e.yyx * sdScene(p + e.yyx).x +\n      e.yxy * sdScene(p + e.yxy).x +\n      e.xxx * sdScene(p + e.xxx).x);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.1, .1, 1);\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(sin(iTime *0.9), 0.25, 3); // camera position\n  vec3 rd = normalize(vec3(uv, -1)); // ray direction\n\n  vec4 co = rayMarch(ro, rd, MIN_DIST, MAX_DIST); // closest object\n\n  if (co.x > MAX_DIST) {\n    col = backgroundColor;\n  } else {\n    vec3 p = ro + rd * co.x; \n    vec3 normal = calcNormal(p);\n    vec3 lightPosition = vec3(sin(iTime *.001), .2, .0);\n    vec3 lightDirection = normalize(sin(iTime * lightPosition) - p);\n\n    float dif = clamp(dot(normal, lightDirection), 0.03, 1.);\n    float fresnel = 1. - pow((dot(normal, rd) +1.)*.5, 1.) * 3.5;\n    col = dif * co.yzw + backgroundColor * sin(.2) + (fresnel * vec3(.1, 0.1, sin(0.31)));\n  }\n\n  fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}