{"ver":"0.1","info":{"id":"7lVfRc","date":"1665083730","viewed":234,"name":"Whipped Cream","username":"Alpaga","description":"Click to flatten the cream.","likes":43,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Click to reset cream\n#define DEPTH 2\n#define STEPS 200\n#define FAR 30.0\n#define AA\n\nconst float fov = 35.0;\nconst float cameraSpeed = 0.02;\n\nstruct Material {\n    vec3 albedo;\n    vec3 specular;\n};\n\nint lightNumber = 1;\nvec3 ambient = vec3(0.03);\nvec3 lightPosition[3] = vec3[](\n    vec3(-1.0,6.0,4.0),\n    vec3(-1.0,5.0,-2.0),\n    vec3(1.0,3.0,-3.0));\nvec3 lightColor[3] = vec3[](\n    vec3(2),\n    vec3(2,2,1.6),\n    vec3(1.0));\n\nvec2 delta = vec2(0.0,0.001);\n\n// Table\nfloat sdTable(vec3 p) {\n    return p.y + 0.03*texture(iChannel1, 0.2*p.xz).r;\n}\n// Bowl\nfloat sdHalfSphere(vec3 p, float r) {\n    p.y -= r;\n    return p.y>0. ?\n        length(vec2(length(p.xz)-r,p.y)) :\n        abs(length(p) - r);\n}\nfloat sdBowl(vec3 p) {\n    return sdHalfSphere(p, bowlSize)-.1;\n}\n// Cream\nfloat sdCream(vec3 p) {\n    p.y -= bowlSize;\n    float d = texture(iChannel0, 0.5+0.5*vec2(iResolution.y/iResolution.x,1.)*(p.xz/bowlSize)).r;//0.5*(p.xz/bowlSize+1.0)).r;\n    return max(length(p)-1.5, .44*(p.y+.8-d));\n}\n// Whisk\nfloat sdHollowDrop(vec2 p, float r, float h) {\n    p.x = abs(p.x);\n    float hr = h/r;\n    float w = sqrt(1. - hr*hr);\n    \n    vec2 u = vec2(w,hr);\n    vec2 v = vec2(-hr,w);\n    vec2 top = vec2(0,h + w*w*r*r/h);\n    vec2 toTop = p-top;\n    return\n        dot(toTop,v) > 0. ?\n            length(toTop) :\n        dot(p,v) > 0.0 ?\n            abs(dot(p,u) - r) :\n            abs(length(p) - r);\n}\nfloat sdWhisk(vec3 p) {\n    vec3 pos = whiskPosition;\n    \n    p.y -= pos.y;\n    \n    p = whiskTransform*p;\n\n    p.xz -= pos.xz;\n\n    float cyl = length(vec2(max(abs(p.y-2.)-.6,0.),length(p.xz)))-.1;\n\n    float c = cos(turnSpeed*iTime), s = sin(turnSpeed*iTime);\n    p.xz *= mat2(c,s,-s,c);\n\n    p.xz = abs(p.xz);\n    mat2 m = mat2(.707,-.707,.707,.707);\n    p.xz = abs(m*p.xz);\n    m = mat2(.924,-.382,.382,.924);\n    p.xz = m*p.xz;\n    \n    vec2 q = vec2(sdHollowDrop(p.xy,.5,.15),p.z);\n    \n\n    return min(cyl, length(q)-.03);\n    \n}\nfloat sd(vec3 p, out int id) {\n    float minD = 10000.0;\n    float d;\n    \n    d = sdTable(p);\n    if(d<minD) {\n        minD = d;\n        id = 0;\n    }\n    d = sdBowl(p);\n    if(d<minD) {\n        minD = d;\n        id = 1;\n    }\n    d = sdCream(p);\n    if(d<minD) {\n        minD = d;\n        id = 2;\n    }\n    d = sdWhisk(p);\n    if(d<minD) {\n        minD = d;\n        id = 3;\n    }\n    \n    return minD;\n}\n\nMaterial material(vec3 p, int id) {\n    switch(id) {\n        case 0: //Table\n            vec3 col = texture(iChannel1, 0.2*p.xz).rgb;\n            col = col*col;\n            return Material(col, vec3(0.04));\n        case 1: //Bowl\n            vec2 f = vec2(120.*atan(p.x,p.z)/6.283,15.*p.y+.6);\n            f = mod(floor(f),vec2(2));\n            float ff = dot(f,f)/3.0;\n            return Material(vec3(1.0,ff,ff),vec3(0.0));//4));           \n        case 2: //Cream\n            return Material(vec3(1), vec3(0.01));\n        case 3: //Whisk\n            // Copper reflectivity taken from\n            // https://learnopengl.com/PBR/Theory\n            vec3 copper = vec3(0.95, 0.64, 0.54);\n            return Material(vec3(0),copper);\n    }\n}\n\n\n\nvec3 normal(vec3 p) {\n    int id;\n    float d = sd(p,id);\n    return normalize(vec3(\n        sd(p+delta.yxx,id),\n        sd(p+delta.xyx,id),\n        sd(p+delta.xxy,id)) - d);\n}\n\n\n// Returns (distance, object id)\nfloat march(vec3 start, vec3 dir, out int id, out int steps) {\n\tfloat totD = 0.0, d;\n    vec3 p;\n    float epsilon = 0.5/iResolution.y;\n    steps=0;\n    for(; steps<STEPS; steps++) {\n        p = start + totD * dir;\n        d = sd(p,id);\n        if(d<epsilon*totD || totD>FAR) break;\n        totD += d;\n    }\n    if(totD>FAR || steps==STEPS) id = -100;\n    return totD;\n}\n\nfloat lightMarch(vec3 start, vec3 dir, float dist) {\n\tfloat d = 1.0, totalD;\n    vec3 p = start;\n    float epsilon = 0.5/iResolution.y;\n    float minD = 1000.0;\n    int id;\n    for(int i=0; i<STEPS; i++) {\n        if(d<epsilon || totalD>dist) break;\n        d = sd(p,id);\n        p += d*dir;\n        totalD += d;\n        minD = min(minD,d);\n    }\n    return minD;\n}\nfloat shadow(vec3 p, vec3 toLight, float distToLight) {\n    float minD = lightMarch(p+0.1*toLight, toLight, distToLight);\n    return smoothstep(0.0,0.05,minD);\n}\n\nvec3 rayColor(vec3 start, vec3 dir) {\n    vec3 color;\n    vec3 coef = vec3(1.0);\n    \n    int id;\n    int steps;\n    float d;\n\n    for(int k=0; k<DEPTH; k++) {\n        d = march(start, dir, id, steps);\n        if(id == -100) {//No ray intersection\n            dir.z = -dir.z;\n            vec3 env = texture(iChannel2, dir).rgb;\n            env = env*env;//Gamma\n            color += coef*env;\n            return color;\n        } else {\n            vec3 p = start + d * dir;\n\n            vec3 normal = normal(p);\n            vec3 toEye = normalize(start - p);\n            Material mat = material(p,id);\n\n            float ao = 1. / (1.+0.1*float(steps));\n            color += coef * ao * ambient * mat.albedo;\n\n            for(int i=0; i<lightNumber; i++) {\n                vec3 toLight = lightPosition[i]-p;\n\n                // Diffuse\n                vec3 diff = mat.albedo * max(dot(toLight, normal), 0.0);\n\n                // Specular\n                vec3 h = normalize(toEye + toLight);\n                vec3 spec = mat.specular * pow(max(dot(h,normal),0.0), 40.0);\n\n                // Shadow\n                float toLightDist = length(toLight);\n                vec3 toLightNorm = toLight / toLightDist;\n                float sh = shadow(p, toLightNorm, toLightDist);\n\n                color += coef*sh*(diff + spec)*lightColor[i]/(1.0+.7*toLightDist*toLightDist);\n            }\n\n            // Reflection\n            vec3 ref = reflect(-toEye, normal);\n            start = p+0.1*ref;\n            dir = ref;\n            \n            coef *= mat.specular;\n           \n            if(dot(coef,vec3(1))<.01) return color;\n        }\n    }\n    return color;\n}\n\nmat3 setupCamera(vec3 cam, vec3 center, vec3 up) {\n \tvec3 w = normalize(cam-center);\n    vec3 u = normalize(cross(up, w));\n    vec3 v = cross(w, u);\n    \n    return mat3(u,v,w);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    updateWhiskPosition(iTime);\n    updateWhiskTransform(iTime);\n    \n    vec3 cam = vec3(\n        4.*cos(cameraSpeed*iTime),\n        5.5+.5*sin(3.0*cameraSpeed*iTime),\n        4.*sin(cameraSpeed*iTime));\n    mat3 m = setupCamera(cam, vec3(0,1,0), vec3(0,1,0));\n    \n    vec3 color = vec3(0);\n\n    #ifdef AA\n    for(float i=-0.25; i<0.5; i+=0.5) {\n        for(float j=-0.25; j<0.5; j+=0.5) {\n            vec2 uv = 2.0*(fragCoord + vec2(i,j) - 0.5 * iResolution.xy)/iResolution.y;\n            vec3 pix = vec3(tan(0.5*fov*0.01745)*uv,-1);\n    \n            vec3 dir = normalize(m*pix);\n    \n            color += rayColor(cam, dir);\n        }\n    }\n    color /= 4.0;\n    #else\n    {\n    vec2 uv = 2.0*(fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    vec3 pix = vec3(tan(0.5*fov*0.01745)*uv,-1);\n    vec3 dir = normalize(m*pix);\n\n    color = rayColor(cam, dir);\n    }\n    #endif\n    \n    color = 1.-exp(-4.*color);\n    \n    // Vignette\n    // Taken from https://www.shadertoy.com/view/XsGyDh\n    {vec2 uv = fragCoord/iResolution.xy;\n    color = mix(color, vec3(0), (1. - pow(16.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y), 0.25)));\n    }\n    // Gamma\n    color = sqrt(color);\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float bowlSize = 1.6;\n\nconst float loopRadius = 0.4;\nconst float loopNumber = 9.0;\n\nconst float speed = 2.;\nconst float turnSpeed = -5.;\n\n\nvec3 whiskPosition;\nmat3 whiskTransform;\n\nfloat firmness(float time) {\n    return pow(abs(cos(.3*time+.4)),2.);\n}\nvec3 getWhiskPosition(float time) {\n    float t = speed*time;\n    vec2 hor = (bowlSize - 0.6)*(1. - loopRadius)*vec2(cos(t),sin(t));\n    float param = pow(abs(cos(.3*time)),20.);\n    float ver = 1.3+2.*param;\n    hor *= pow(1.-param,10.);\n    return vec3(hor.x, ver, hor.y);\n}\nvoid updateWhiskPosition(float time) {\n    whiskPosition = getWhiskPosition(time);\n}\nvoid updateWhiskTransform(float time) {\n    vec2 u = (getWhiskPosition(time+0.4/speed) - getWhiskPosition(time)).zx;\n    float u2 = dot(u,u);\n    float c = 1.0/sqrt(1.0+u2);\n    float k = u2 > .01 ? (1.-c)/u2 : 0.;\n    whiskTransform = mat3(\n        c+k*u.x*u.x, c*u.y,  -k*u.x*u.y,\n             -c*u.y,     c,      -c*u.x,\n         -k*u.x*u.y, c*u.x, c+k*u.y*u.y);\n}\nvec2 wirePosition(int id, float time) {\n    float f = 6.2832 * float(id)/8.;\n    return vec2(cos(turnSpeed*time+f+.4),sin(turnSpeed*time+f+.4));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// The cream height is updated here.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    updateWhiskPosition(iTime);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pos = bowlSize*(2.*fragCoord-iResolution.xy)/iResolution.y;\n    float h;\n    \n    if(iFrame==0 || iMouse.w>0.0) {\n        h = .5;\n    } else {\n        // Averaging depending on cream firmness\n        float f = firmness(iTime);\n        h = f*texture(iChannel0,uv).r;\n        for(float i=-2.0; i<2.1; i++) {\n            for(float j=-2.0; j<2.1; j++) {\n                vec2 uvij = (fragCoord+vec2(i,j))/iResolution.xy;\n                h += (1.-f)*.04 * texture(iChannel0, uvij).r;\n            }\n        }\n        \n        // Update height if a wire is there\n        float sig = 1.;\n        for(int i=0; i<8; i++) {\n            vec2 wire = wirePosition(i, iTime);\n            float r = whiskPosition.y - 1.3;\n            \n            // Radius of that part of whisk at the surface of cream\n            r = sqrt(max(.25-r*r,0.));\n            \n            // Contact point between wire and cream\n            vec2 contact = whiskPosition.xz + r * wire;\n            \n            float d = length(pos-contact);\n            r *= 2.*.2/bowlSize;\n            // Alternate cavity and bump\n            float c = 0.5+sig * r;\n            \n            h = mix(c,h,min(1.0,d/r));\n            sig = -sig;\n        }\n    }\n    fragColor = vec4(h);\n}","name":"Buffer A","description":"","type":"buffer"}]}