{"ver":"0.1","info":{"id":"fdyXRR","date":"1634229456","viewed":139,"name":"black hole surface","username":"johnao","description":"This shader demostrates what you would see if the suface of the black hole had a checker board pattern.\n\na Schwarzchild black hole  v.s.  a normal sphere with the SAME radius.\n\nThe black hole looks bigger because the light near it is bent towards it.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["blackhole","relativity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nCreated by @johnao\n\nLicense: CC BY 4.0\n\nThis shader demostrates what you would see if the suface of\nthe black hole had a checker board pattern.\n\nLeft: a Schwarzchild black hole\n\nRight: a normal sphere with the SAME radius.\n\nThe black hole looks bigger because the light near it is bent\ntowards it. You can actually see the whole surface of the black\nhole (north pole and south pole) at the same time.\n\nThe tracing part is a leapfrog integration of light path according\nto equations of general relativity.\n\np.s. the default shadertoy code looks good so I keep it in the backgroud :)\n\n*/\n\n// uncomment the following to change display style\n\n//#define BLACK_HOLE_ONLY\n//#define SPHERE_ONLY\n//#define SIDE_BY_SIDE\n\n\n#define PI 3.14159265359\n// Schwarzchild radius\n#define rs 1.\n// rs1=rs*1.5\n#define rs1 1.5\n// rs2=rs*rs\n#define rs2 1.\n\n// the default settings run smoothly on my computer\n// you can change them if you want\n\n// N is the number of steps\n#define N 1000\n// dt is the step length, smaller dt needs more steps but gives more accurate result\n#define dt 0.1\n\n\nfloat sphereTexture(vec3 p){\n    p=p/length(p);\n    float phi=atan(p.y,p.x);\n    float theta=asin(p.z);\n    //return fract(phi/PI*8.)<0.11/(0.1+length(p.xy))||fract(theta/PI*8.)<0.1?0.:1.;\n    return 0.5+0.5*(2.*mod(floor(phi/PI*8.),2.)-1.)*(2.*mod(floor(theta/PI*8.),2.)-1.);\n}\n\nvec4 trace0(vec3 o,vec3 d){\n    float b=2.*dot(o,d);\n    float c=dot(o,o)-rs2;\n    float det=b*b-4.*c;\n    if(c<=0.||det<0.){\n        return vec4(0.);\n    }\n    float t=0.5*(-b-sqrt(det));\n    return vec4(o+t*d,1.);\n}\n\nvec4 trace(vec3 o,vec3 d){\n    float r=length(o);\n    o=normalize(o);\n    float c=dot(o,d);\n    float s2=1.-c*c;\n    float s=sqrt(s2);\n    float rp=c/r;\n    float phi=0.;\n    float last_r=r;\n    float last_phi=phi;\n    for(int i=0;i<N&&r<10.;++i){\n        float a=s2*(1.-rs1/r)/(r*r*r);\n        rp+=a*dt;\n        r+=rp*dt;\n        phi+=s*dt/(r*r);\n        if(r<rs){\n            phi=((rs-r)*last_phi+(last_r-rs)*phi)/(last_r-r);\n            vec3 y=cross(normalize(cross(o,d)),o);\n            return vec4(o*rs*cos(phi)+y*rs*sin(phi),1.);\n        }\n        last_r=r;\n        last_phi=phi;\n    }\n    return vec4(0.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy*2.-1.)*iResolution.xy/vec2(min(iResolution.x,iResolution.y))*1.2;\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    \n    float t=iTime+.5;\n    vec3 o=4.*vec3(1.,cos(t),sin(t));\n    vec3 z=normalize(o);\n    vec3 x=normalize(cross(vec3(0.,sin(t),1.),z));\n    vec3 y=cross(z,x);\n    \n    #ifdef SIDE_BY_SIDE\n        vec4 p;\n        vec3 d;\n        if(uv.x>0.5){\n            uv.x-=1.;\n            d=normalize(3.*(x*uv.x+y*uv.y)-o);\n            p=trace0(o,d);\n        }else{\n            uv.x+=0.5;\n            d=normalize(3.*(x*uv.x+y*uv.y)-o);\n            p=trace(o,d);\n        }\n    #else\n        vec3 d=normalize(3.*(x*uv.x+y*uv.y)-o);\n        t=iTime*0.7+4.;\n        float vline=pow((1.-pow(max(0.,min((sin(t+0.2)+0.8)*4.,4.)/4.),2.)),2.)*(sin(t*0.5)>0.?1.:-1.);\n        \n        #ifdef BLACK_HOLE_ONLY\n            vline=1.;\n        #endif\n        \n        #ifdef SPHERE_ONLY\n            vline=-1.;\n        #endif\n        \n        vline*=rs*1.2;\n        vec4 p=uv.x>vline?trace0(o,d):trace(o,d);\n    #endif\n    if(p.w>0.){\n        col*=0.2+sphereTexture(p.xyz)*0.5;\n    }\n    #ifndef SIDE_BY_SIDE\n        if(abs(uv.x-vline)<0.01){\n            col=0.5+0.5*col;\n        }\n    #endif\n        \n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}