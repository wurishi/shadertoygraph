{"ver":"0.1","info":{"id":"ldcfWn","date":"1524669018","viewed":123,"name":"circle drawing ","username":"akhgary","description":"good circle on left and bad circle on right!\n\nis there a better way that is computationally less expensive?","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["circle","plot","draw"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// equation of circle\n// https://en.wikipedia.org/wiki/Circle#Equations\n//\n// thanks to user FabriceNeyret2 for great help.\n// =========================================\n//\n// circle with center coordinates (a, b) and radius R has this equation\n//\n// (x-a)^2 + (y-b)^2 = R^2\n//\n// =========================================\n//\n// if we use \"|r|^2-|R|^2\" for distance field\n// where r is vector from center to any point on screen\n// and R is the radius vector,\n// distance field would be non linear and quadratic.\n// this means we get thin and thinner borders as the radius gets larger.\n// \n// in order to get a constant width we should take the square root of each term.\n// therefor \"|r|-|R|\" for distance field will be linear \n// you will get a constant border width as the radius changes\n//\n// =========================================\n//\n// if you have a circle with constant radius \n// you can use quadratic formula instead and tune the thickness as desired.\n//\n// =========================================\n\nconst float scale = 5.0; // 5x5 grid\nconst float thickness = 3.0*scale;\n\n// but its slower since we take two square roots.\nfloat goodCircle(vec2 p, vec2 c, vec2 R)\n{\n    vec2 r = p-c;\n    float fx = length(r)-length(R);\n    float dist = abs(fx);\n    return smoothstep(thickness/iResolution.y,0.0,dist);\n}\n\n// but its faster and is good if radius is constant.\nfloat badCircle(vec2 p, vec2 c, vec2 R)\n{\n    vec2 r = p-c;\n    float fx = dot(r,r)-dot(R,R);\n    float dist = abs(fx);\n    return smoothstep(thickness/iResolution.y,0.0,dist);\n}\n\nvec2 uvmap(vec2 uv)\n{\n    return (2.0*uv - iResolution.xy)/iResolution.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = scale*uvmap(fragCoord.xy);\n    vec2 p1 = scale*uvmap(iMouse.xy);\n    vec2 p0 = scale*vec2(0);\n    \n    if(iMouse.xy == vec2(0)) p1 = scale*vec2(0.5);\n        \n    vec3 col = uv.x < 0.0\n             ? vec3(goodCircle(uv, p0, p1-p0))\n             : vec3(badCircle (uv, p0, p1-p0));\n    \n    col += smoothstep(thickness/iResolution.y,0.0,abs(uv.x)); // separator\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}