{"ver":"0.1","info":{"id":"Xs3GWX","date":"1452419901","viewed":628,"name":"Daisy Bell","username":"davidar","description":"Please reset to sync sound. HAL model by @baldand\n\nDaisy, Daisy, give me your answer do,\nI'm half crazy all for the love of you.\nIt won't be a stylish marriage,\nI can't afford a carriage,\nBut you'll look sweet upon the seat\nOf a bicycle made for two.","likes":15,"published":1,"flags":8,"usePreview":1,"tags":["synthesis","speech","formant"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Parts Copyright (c) 2015 Andrew Baldwin (baldand)\n// Modified by @davidar\n// License = Attribution-ShareAlike 4.0 International (CC BY-SA 4.0) (http://creativecommons.org/licenses/by-sa/4.0/)\n\n// A tribute to HAL 9000, from Stanley Kubrick's film \"2001: A Space Odyssey\" \n\n#define PI 3.141592653589793\n\n// For basic distance-field modeling functions <thanks iq>\nfloat box( vec2 p, vec2 b )\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdRoundBox( in vec2 p, in vec2 b, in float r ) \n{\n    vec2 q = abs(p) - b+r; // AB added + r here so that size stay constant\n    vec2 m = vec2( min(q.x,q.y), max(q.x,q.y) );\n    float d = (m.x > 0.0) ? length(q) : m.y; \n    return d - r;\n}\n\nfloat line( vec2 p, vec3 d ) \n{\n\treturn abs(dot(p,normalize(d.xy)))-d.z;    \n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n// </thanks iq>\n\nvec4 hal( vec2 p, float aa, float mode ) \n{\n    float ref = 0.0;\n    float sc = 0.0033;\n    float outer = abs(box(p-vec2(.0,-1.1),vec2(114.3,349.25)*sc)+3.175*.5*sc)-3.175*.5*sc;\n    float lowerline = box(p-vec2(.0,-1.1-200.025*sc),vec2(114.,3.175*.5)*sc);\n    float woodbox = box(p-vec2(.0,-.86),vec2(114.4,270.0)*sc);\n    vec3 bg = 2.0*vec3(20.,18.,22.)/255.;\n    float eye = length(p-vec2(.0,-1.1-70.*sc));\n    float lens = abs(eye-.3)-3.175*sc*.5;\n    float rim = min(min(outer,lowerline),lens);\n    \n    vec3 eyeglow;\n    \teyeglow = mix(\n        \t\t\tmix(\n        \t\t\tmix(\n        \t\t\tmix( \n                        2.*vec3(1.,.5+.5*mode,.5+.5*mode), \n                        2.*vec3(.8+.2*mode,.1+.9*mode,.1*(1.-mode)), \n                        clamp(smoothstep(0.0005,.011,eye),0.,1.)\n                    ),\n        \t\t\tvec3(.2+.8*mode,0.,0.),\n        \t\t\tclamp(smoothstep(.011,.020,eye),0.,1.)\n    \t\t\t\t),\n        \t\t\tvec3(.1+.4*mode,.0,.0),\n        \t\t\tclamp(smoothstep(.020,.14,eye),0.,1.)\n    \t\t\t   ),\n        \t\t   vec3(.0),\n        \t\t\tclamp(smoothstep(.14,.35,eye),0.,1.));\n    if(mode < 0.) eyeglow *= mode + 1.;\n    //speaker = max(speaker,-grille);\n    \n    vec2 r = (p+vec2(4.,0.))*vec2(39.,107.7676);\n    float dither = abs(fract(r.x) *2.-1.); // Some texture to hide banding\n    vec3 glow = mix(bg*3.2,bg*1.0,clamp(length((p-vec2(0.,-1.))*vec2(2.,1.)*.5),0.,1.0));\n    vec3 wood = mix(vec3(.08),vec3(.09),dither);\n    wood = mix(eyeglow,wood,smoothstep(.3,.3+aa,eye));\n    vec3 back = mix(wood,bg,smoothstep(0.,aa,woodbox));\n    vec3 col = mix(vec3(.4),back,smoothstep(0.,aa,rim));  \n    if (eye<.24) ref=1.;\n    if (rim<0.) ref=.8;\n    return vec4(col,ref);\n}\n\n\nvec4 world( vec3 p )\n{\n    float d = sdBox(p-vec3(0.),vec3(1.2*5.+10.,1.2*2.+10.,0.1)); // Panel\n    float d2 = sdBox(p-vec3(0.,1.1,0.12),vec3(0.38,1.16,0.025)); // HAL\n    float lh = 1.331;\n    float l1 = sdCappedCylinder(p-vec3(0.,lh,0.17),vec2(0.308,.01)); // HAL lens outer grey cylinder\n    float l2 = sdCappedCylinder(p-vec3(0.,lh,0.19),vec2(0.270,.02)); // HAL lens inner black cylinder\n    float l3 = length(p-vec3(0.,lh,-.25))-.55; // HAL lens surface\n    float l4 = sdCappedCylinder(p-vec3(0.,lh,0.19),vec2(0.250,.12)); // HAL lens inner black cylinder\n    float grille = sdBox(p-vec3(0.,2.01,0.12-.0005*sin(p.y*333.)),vec3(0.347,.225,0.025)); // HAL\n    d = min(d,min(d2,grille));\n    l1 = min(l1,l2);\n    l1 = min(l1,max(l3,l4));\n    d = min(d,l1);\n    if (d<1e-3) {\n        vec2 sp = vec2(-dot(p,vec3(1.,0.,0.)),-dot(p,vec3(0.,1.,0.)));\n        return vec4(d,1.,sp);\n    } else\n        return vec4(d,vec3(0.));    \n}\n\nvec3 sampleNormal( vec3 p ) {\n    vec3 eps = vec3(1e-3,0.,0.);\n    float dx = world(p+eps).x-world(p-eps).x;\n    float dy = world(p+eps.yxy).x-world(p-eps.yxy).x;\n    float dz = world(p+eps.yyx).x-world(p-eps.yyx).x;\n    return normalize(vec3(dx,dy,dz));\n}\n      \nvoid render( out vec4 fragColor, in vec2 fragCoord, float blink )\n{\n\tvec3 sensor = vec3(1.*(fragCoord.xy-iResolution.xy*.5)/iResolution.x,0.);\n    //if (abs(sensor.y)>0.225) { fragColor=vec4(0.); return; } // 2001 was 2.20 : 1 Aspect Ratio\n    vec3 targetPosition = vec3(1.,0.,0.);\n    vec3 cameraPosition = vec3(2.5,0.5,5.);\n    //vec3 cameraPosition = vec3(3.0+3.*sin(iTime*.1),1.0,5.+3.0*sin(iTime*.1));\n    vec3 cameraDirection = normalize(targetPosition-cameraPosition);\n    vec3 up = normalize(vec3(.25,1.,0.));\n    float focalLength = .5; \n    float phase = mod(iTime,60.);\n    float off = 0.;\n    float scaryhal = blink;\n    targetPosition = vec3(.0+off,1.33,.0);\n    cameraPosition = vec3(.0+off,1.33,.8);\n    cameraDirection = normalize(targetPosition-cameraPosition);\n    up = normalize(vec3(0.,1.,0.));\n    focalLength = .5;\n    vec3 cameraH = normalize(cross(up,cameraDirection));\n    vec3 cameraV = normalize(cross(cameraH,cameraDirection));\n    vec3 cameraVH = cameraV + cameraH;\n    \n    vec3 rayDirection = normalize(focalLength*cameraDirection + sensor.x*cameraH + sensor.y*cameraV);\n    \n    vec3 pos = cameraPosition;\n    float l = 0.0;\n    float d = 1.0;\n    vec4 m;\n    vec3 lightpos = vec3(3.,-6.,6.);\n    vec3 lightarg = vec3(-0.5,1.,0.);\n    for (int i=0;i<100;i++) {\n        if (l>1000.0) continue;\n        if (d<1e-3) continue;\n\t    m = world(pos);\n        d = m.x;\n    \tl += d;\n        pos += rayDirection * d;\n    }    \n    // Check lighting by marching from surface towards light\n    vec3 ldir = normalize(lightpos-pos);\n    float ldist = length(lightpos-pos);\n    vec3 posl = pos+ldir*.005;\n    float ll = 0.0;\n    float dl = 1.0;\n    vec4 ml;\n    for (int i=0;i<100;i++) {\n        if (ll>ldist) continue;\n        if (dl<1e-3) continue;\n\t    ml = world(posl);\n        dl = ml.x;\n    \tll += dl;\n        posl += ldir * dl;\n    }\n    float shadow = 1.0;\n    if (ll<(ldist*.5)) shadow = 0.0;\n    \n    // Colour it\n    vec4 alb = vec4(0.0);\n    if (m.y==1.) {\n\t    vec2 muv = mod(m.zw-vec2(1.2,0.),2.4)-vec2(1.2);\n    \tvec2 fuv = floor((m.zw+vec2(1.2,0.)) / 2.4);\n        float aa = .0015*l*2000.0/iResolution.x;\n        alb = hal(m.zw,aa,scaryhal);\n    }\n    l*=0.2;\n    float v = 0.1;\n    vec3 albcol = alb.rgb;\n    if (d<1e-1) {\n\t    vec3 nor = sampleNormal( pos );\n        vec3 ref = reflect( rayDirection, nor );\n\t    vec3 lightDir = normalize(lightpos-pos);\n\t    vec3 lightTargDir = normalize(lightpos-lightarg);\n        float lv = .2+shadow*.8*smoothstep(.98,1.,dot(lightDir,lightTargDir));\n        vec3 refcol = vec3(clamp(texture(iChannel0,ref+iTime/120.).r*16.-15.,0.,1.));\n        vec3 refcol2 = vec3(clamp(texture(iChannel0,ref+iTime/120.).r,0.,1.));\n    \tif (alb.w>=0.) albcol *= max(lv*dot(nor,lightDir),0.2);\n        else alb.w=0.;\n        if (alb.w==1.) albcol = mix(albcol,albcol+0.75*refcol,alb.w);\n        else albcol = mix(albcol,albcol*refcol2,alb.w);\n        //albcol = vec3(shadow);\n    }\n    \n\tfragColor = vec4(albcol,.0);\n}\n\n#define BLINK(duration) { if(time > float(i)*30e-3) offset = time - float(i)*30e-3; i += duration; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime - 0.5;\n    float offset;\n    int i = 0;\n    BLINK(45); // Dai-\n    BLINK(48); // -sy\n    BLINK(45); // Dai-\n    BLINK(48); // -sy\n    BLINK(24); // Give\n    BLINK(15); // me\n    BLINK(20); // your\n    BLINK(30); // an-\n    BLINK(15); // -swer\n    BLINK(90); // do\n    BLINK(43); // I'm\n    BLINK(45); // half\n    BLINK(45); // cra-\n    BLINK(45); // -zy\n    BLINK(15); // All\n    BLINK(15); // for\n    BLINK(15); // the\n    BLINK(30); // love\n    BLINK(15); // of\n    BLINK(90); // you\n    BLINK(15); // It\n    BLINK(16); // won't\n    BLINK(15); // be\n    BLINK(15); // a\n    BLINK(43); // sty-\n    BLINK(18); // -lish\n    BLINK(15); // ma-\n    BLINK(71); // -rriage\n    BLINK(20); // I\n    BLINK(34); // can't\n    BLINK(15); // a-\n    BLINK(30); // -fford\n    BLINK(15); // a\n    BLINK(15); // ca-\n    BLINK(56); // -rriage\n    BLINK(16); // But\n    BLINK(30); // you'll\n    BLINK(16); // look\n    BLINK(33); // sweet\n    BLINK(15); // u-\n    BLINK(31); // -pon\n    BLINK(15); // the\n    BLINK(21); // seat\n    BLINK(15); // Of\n    BLINK(15); // a\n    BLINK(21); // bi-\n    BLINK(15); // -cy-\n    BLINK(15); // -cle\n    BLINK(35); // made\n    BLINK(23); // for\n    BLINK(56); // two\n    render(fragColor, fragCoord, exp(-offset) - smoothstep(45.,60.,time));\n}","name":"","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// 2009-2016 David A Roberts <https://davidar.io>\n\n#define PI 3.141592653589793\n\n#define ITERATIONS 8\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\n\nstruct Formant {\n    int f1, f2, f3, A1, A2, A3, noise;\n};\n\n#define NUL Formant(0x00,0x00,0x00,0x0,0x0,0x0,0x0)\n#define IY Formant(0x0a,0x54,0x6e,0xd,0xa,0x8,0x0)\n#define IH Formant(0x0e,0x49,0x5d,0xd,0x8,0x7,0x0)\n#define EH Formant(0x13,0x43,0x5b,0xe,0xd,0x8,0x0)\n#define AE Formant(0x18,0x3f,0x58,0xf,0xe,0x8,0x0)\n#define AA Formant(0x1b,0x28,0x59,0xf,0xd,0x1,0x0)\n#define AH Formant(0x17,0x2c,0x57,0xf,0xc,0x1,0x0)\n#define AO Formant(0x15,0x1f,0x58,0xf,0xc,0x0,0x0)\n#define UH Formant(0x10,0x25,0x52,0xf,0xb,0x1,0x0)\n#define AX Formant(0x14,0x2c,0x57,0xe,0xb,0x0,0x0)\n#define IX Formant(0x0e,0x49,0x5d,0xd,0xb,0x7,0x0)\n#define ER Formant(0x12,0x31,0x3e,0xc,0xb,0x5,0x0)\n#define UX Formant(0x0e,0x24,0x52,0xf,0xc,0x1,0x0)\n#define OH Formant(0x12,0x1e,0x58,0xf,0xc,0x0,0x0)\n#define RX Formant(0x12,0x33,0x3e,0xd,0xc,0x6,0x0)\n#define LX Formant(0x10,0x25,0x6e,0xd,0x8,0x1,0x0)\n#define WX Formant(0x0d,0x1d,0x50,0xd,0x8,0x0,0x0)\n#define YX Formant(0x0f,0x45,0x5d,0xe,0xc,0x7,0x0)\n#define WH Formant(0x0b,0x18,0x5a,0xd,0x8,0x0,0x0)\n#define R Formant(0x12,0x32,0x3c,0xc,0xa,0x5,0x0)\n#define L Formant(0x0e,0x1e,0x6e,0xd,0x8,0x1,0x0)\n#define W Formant(0x0b,0x18,0x5a,0xd,0x8,0x0,0x0)\n#define Y Formant(0x09,0x53,0x6e,0xd,0xa,0x8,0x0)\n#define M Formant(0x06,0x2e,0x51,0xc,0x3,0x0,0x0)\n#define N Formant(0x06,0x36,0x79,0x9,0x9,0x0,0x0)\n#define NX Formant(0x06,0x56,0x65,0x9,0x6,0x3,0x0)\n#define DX Formant(0x06,0x36,0x79,0x0,0x0,0x0,0x0)\n#define Q Formant(0x11,0x43,0x5b,0x0,0x0,0x0,0x0)\n#define S Formant(0x06,0x49,0x63,0x7,0xa,0xd,0xf)\n#define SH Formant(0x06,0x4f,0x6a,0x0,0x0,0xa,0xf)\n#define F Formant(0x06,0x1a,0x51,0x3,0x3,0x3,0xf)\n#define TH Formant(0x06,0x42,0x79,0x0,0x0,0xa,0xa)\n#define _H Formant(0x0e,0x49,0x5d,0x0,0x0,0x0,0x3)\n#define _X Formant(0x10,0x25,0x52,0x0,0x0,0x0,0x0)\n#define Z Formant(0x09,0x33,0x5d,0xf,0x3,0xf,0xa)\n#define ZH Formant(0x0a,0x42,0x67,0xb,0x5,0xf,0x6)\n#define V Formant(0x08,0x28,0x4c,0xb,0x3,0x0,0x3)\n#define DH Formant(0x0a,0x2f,0x5d,0xb,0x4,0x0,0x3)\n#define CHa Formant(0x06,0x4f,0x65,0x1,0x1,0x1,0x0)\n#define CHb Formant(0x06,0x4f,0x65,0x0,0x0,0xa,0xf)\n#define Ja Formant(0x06,0x42,0x79,0x1,0x0,0x0,0x0)\n#define Jb Formant(0x05,0x42,0x79,0x1,0x0,0x0,0xf)\n#define Jc Formant(0x06,0x6e,0x79,0x0,0xa,0xe,0xa)\n#define Jd Formant(0x00,0x00,0x00,0x2,0x2,0x1,0xa)\n#define EY Formant(0x13,0x48,0x5a,0xe,0xe,0x9,0x0)\n#define AY Formant(0x1b,0x27,0x58,0xf,0xd,0x1,0x0)\n#define OY Formant(0x15,0x1f,0x58,0xf,0xc,0x0,0x0)\n#define AW Formant(0x1b,0x2b,0x58,0xf,0xd,0x1,0x0)\n#define OW Formant(0x12,0x1e,0x58,0xf,0xc,0x0,0x0)\n#define UW Formant(0x0d,0x22,0x52,0xd,0x8,0x0,0x0)\n#define Ba Formant(0x06,0x1a,0x51,0x2,0x0,0x0,0x0)\n#define Bb Formant(0x06,0x1a,0x51,0x4,0x1,0x0,0xf)\n#define Bc Formant(0x06,0x1a,0x51,0x0,0x0,0x0,0x0)\n#define Da Formant(0x06,0x42,0x79,0x2,0x0,0x0,0x0)\n#define Db Formant(0x06,0x42,0x79,0x4,0x1,0xa,0xf)\n#define Dc Formant(0x06,0x42,0x79,0x0,0x0,0x0,0x0)\n#define Ga Formant(0x06,0x6e,0x70,0x1,0x0,0x0,0x0)\n#define Gb Formant(0x06,0x6e,0x6e,0x4,0x1,0x0,0xf)\n#define Gc Formant(0x06,0x6e,0x6e,0x0,0x0,0x0,0x0)\n#define GXa Formant(0x06,0x54,0x5e,0x1,0x0,0x0,0x0)\n#define GXb Formant(0x06,0x54,0x5e,0x4,0x1,0x0,0xf)\n#define GXc Formant(0x06,0x54,0x5e,0x0,0x0,0x0,0x0)\n#define Pa Formant(0x06,0x1a,0x51,0x1,0x1,0x1,0x0)\n#define Pb Formant(0x06,0x1a,0x51,0xa,0xa,0xa,0xf)\n#define Pc Formant(0x06,0x1a,0x51,0x0,0x0,0x0,0x0)\n#define Ta Formant(0x06,0x42,0x79,0x1,0x1,0x1,0x0)\n#define Tb Formant(0x06,0x42,0x79,0xa,0xa,0xa,0xf)\n#define Tc Formant(0x06,0x42,0x79,0x0,0x0,0x0,0x0)\n#define Ka Formant(0x06,0x6d,0x65,0x0,0x0,0x0,0x0)\n#define Kb Formant(0x0a,0x56,0x65,0xc,0xa,0x7,0x0)\n#define Kc Formant(0x0a,0x6d,0x70,0x0,0x0,0x0,0x0)\n#define KXa Formant(0x06,0x54,0x5e,0x0,0x0,0x0,0x0)\n#define KXb Formant(0x06,0x54,0x5e,0x0,0xa,0x5,0x0)\n#define KXc Formant(0x06,0x54,0x5e,0x0,0x0,0x0,0x0)\n\n// 1 out, 2 in... <https://www.shadertoy.com/view/4djSRW>\nfloat hash12(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3.zxy, p3.yzx+19.19);\n    return fract((p3.x + p3.y)*p3.z);\n}\nfloat noise(float time) {\n    float audio = 0.;\n    for (int t = 0; t < ITERATIONS; t++) {\n        float v = float(t)*3.21239;\n\t\taudio += hash12(vec2(time + v, time*1.423 + v)) * 2.0 - 1.0;\n    }\n    audio /= float(ITERATIONS);\n    return audio;\n}\n\nfloat midi_freq(int m) {\n    /* converts a MIDI note number to a frequency\n       <http://en.wikipedia.org/wiki/MIDI_Tuning_Standard> */\n    return 440. * pow(2., float(m-69)/12.);\n}\n\nfloat sin_wav(float w) { return sin(2.*PI*w); }\nfloat rec_wav(float w) { return (mod(w,1.) < 0.5) ? -1. : 1.; }\nfloat saw_wav(float w) { return 1. - mod(w,1.); }\n\nfloat synth(Formant f, int note, float time) {\n    float pitch = midi_freq(note) - time;\n    float t = mod(time, 1./pitch);\n    return (saw_wav(t*pitch) * (  float(f.A1)*sin_wav(t*33.65*float(f.f1))\n                                    + float(f.A2)*sin_wav(t*33.65*float(f.f2))\n                                    + float(f.A3)*rec_wav(t*33.65*float(f.f3)))\n               + float(f.noise)*noise(time))/64.;\n}\n\n#define FRAME(formant, duration, note) { if(time > float(i)*30e-3) r = synth(formant, note, time); i += duration; }\n\nvec2 mainSound( in int samp,float time) {\n    float r;\n    int i = 0;\n    /* Dai- */\n    FRAME(Da, 3, 57);\n    FRAME(Db, 1, 57);\n    FRAME(Dc, 4, 57);\n    FRAME(EY, 14, 57);\n    FRAME(YX, 23, 57); \n    /* -sy */\n    FRAME(Z, 10, 54);\n    FRAME(IY, 38, 54); \n    /* Dai- */\n    FRAME(Da, 3, 50);\n    FRAME(Db, 1, 50);\n    FRAME(Dc, 4, 50);\n    FRAME(EY, 14, 50);\n    FRAME(YX, 23, 50); \n    /* -sy */\n    FRAME(Z, 10, 45);\n    FRAME(IY, 38, 45); \n    /* Give */\n    FRAME(Ga, 2, 47);\n    FRAME(Gb, 2, 47);\n    FRAME(Gc, 2, 47);\n    FRAME(IH, 13, 47);\n    FRAME(V, 5, 47); \n    /* me */\n    FRAME(M, 2, 49);\n    FRAME(IY, 13, 49); \n    /* your */\n    FRAME(YX, 5, 50);\n    FRAME(AO, 10, 50);\n    FRAME(RX, 5, 50); \n    /* an- */\n    FRAME(AH, 25, 47);\n    FRAME(NX, 5, 47); \n    /* -swer */\n    FRAME(S, 2, 50);\n    FRAME(ER, 10, 50);\n    FRAME(RX, 3, 50); \n    /* do */\n    FRAME(Da, 3, 45);\n    FRAME(Db, 1, 45);\n    FRAME(Dc, 4, 45);\n    FRAME(UX, 77, 45);\n    FRAME(WX, 5, 45); \n    /* I'm */\n    FRAME(AY, 25, 52);\n    FRAME(YX, 10, 52);\n    FRAME(M, 8, 52); \n    /* half */\n    FRAME(_H, 5, 57);\n    FRAME(AX, 30, 57);\n    FRAME(F, 10, 57); \n    /* cra- */\n    FRAME(Ka, 3, 54);\n    FRAME(Kb, 3, 54);\n    FRAME(Kc, 4, 54);\n    FRAME(R, 5, 54);\n    FRAME(EY, 30, 54); \n    /* -zy */\n    FRAME(Z, 5, 50);\n    FRAME(IY, 40, 50); \n    /* All */\n    FRAME(AO, 10, 47);\n    FRAME(LX, 5, 47); \n    /* for */\n    FRAME(F, 5, 49);\n    FRAME(AO, 10, 49); \n    /* the */\n    FRAME(DH, 5, 50);\n    FRAME(AH, 10, 50); \n    /* love */\n    FRAME(L, 5, 52);\n    FRAME(AH, 20, 52);\n    FRAME(V, 5, 52);\n    /* of */\n    FRAME(AA, 10, 54);\n    FRAME(V, 5, 54);\n    /* you */\n    FRAME(Y, 10, 52);\n    FRAME(UX, 80, 52); \n    /* It */\n    FRAME(IH, 10, 54);\n    FRAME(Ta, 2, 54);\n    FRAME(Tb, 1, 54);\n    FRAME(Tc, 2, 54);\n    /* won't */\n    FRAME(W, 2, 55);\n    FRAME(OH, 10, 55);\n    FRAME(N, 1, 55);\n    FRAME(Ta, 1, 55);\n    FRAME(Tb, 1, 55);\n    FRAME(Tc, 1, 55);\n    /* be */\n    FRAME(Ba, 2, 54);\n    FRAME(Bb, 1, 54);\n    FRAME(Bc, 2, 54);\n    FRAME(IY, 10, 54);\n    /* a */\n    FRAME(AH, 15, 52);\n    /* sty- */\n    FRAME(S, 2, 57);\n    FRAME(Ta, 2, 57);\n    FRAME(Tb, 2, 57);\n    FRAME(Tc, 2, 57);\n    FRAME(AY, 25, 57);\n    FRAME(YX, 10, 57);\n    /* -lish */\n    FRAME(L, 3, 54);\n    FRAME(IH, 10, 54);\n    FRAME(SH, 5, 54);\n    /* ma- */\n    FRAME(M, 5, 52);\n    FRAME(AE, 10, 52);\n    /* -rriage */\n    FRAME(R, 5, 50);\n    FRAME(IH, 60, 50);\n    FRAME(Ja, 2, 50);\n    FRAME(Jb, 2, 50);\n    FRAME(Jc, 2, 50);\n    /* I */\n    FRAME(AY, 15, 52);\n    FRAME(YX, 5, 52);\n    /* can't */\n    FRAME(Ka, 2, 54);\n    FRAME(Kb, 2, 54);\n    FRAME(Kc, 2, 54);\n    FRAME(AH, 20, 54);\n    FRAME(N, 2, 54);\n    FRAME(Ta, 2, 54);\n    FRAME(Tb, 2, 44);\n    FRAME(Tc, 2, 54);\n    /* a- */\n    FRAME(AX, 15, 50);\n    /* -fford */\n    FRAME(F, 5, 47);\n    FRAME(AO, 20, 47);\n    FRAME(R, 2, 47);\n    FRAME(Da, 1, 47);\n    FRAME(Db, 1, 47);\n    FRAME(Dc, 1, 47);\n    /* a */\n    FRAME(AX, 15, 50);\n    /* ca- */\n    FRAME(Ka, 1, 47);\n    FRAME(Kb, 1, 47);\n    FRAME(Kc, 1, 47);\n    FRAME(AE, 12, 47);\n    /* -rriage */\n    FRAME(R, 5, 45);\n    FRAME(IH, 45, 45);\n    FRAME(Ja, 2, 45);\n    FRAME(Jb, 2, 45);\n    FRAME(Jc, 2, 45);\n    /* But */\n    FRAME(Ba, 1, 45);\n    FRAME(Bb, 1, 45);\n    FRAME(Bc, 1, 45);\n    FRAME(AH, 10, 45);\n    FRAME(Ta, 1, 45);\n    FRAME(Tb, 1, 45);\n    FRAME(Tc, 1, 45);\n    /* you'll */\n    FRAME(Y, 5, 50);\n    FRAME(UH, 20, 50);\n    FRAME(L, 5, 50);\n    /* look */\n    FRAME(L, 3, 54);\n    FRAME(UH, 10, 54);\n    FRAME(Ka, 1, 54);\n    FRAME(Kb, 1, 54);\n    FRAME(Kc, 1, 54);\n    /* sweet */\n    FRAME(S, 5, 52);\n    FRAME(W, 2, 52);\n    FRAME(IY, 20, 52);\n    FRAME(Ta, 2, 52);\n    FRAME(Tb, 2, 52);\n    FRAME(Tc, 2, 52);\n    /* u- */\n    FRAME(AX, 15, 45);\n    /* -pon */\n    FRAME(Pa, 2, 50);\n    FRAME(Pb, 2, 50);\n    FRAME(Pc, 2, 50);\n    FRAME(AA, 20, 50);\n    FRAME(N, 5, 50);\n    /* the */\n    FRAME(DH, 5, 54);\n    FRAME(AH, 10, 54);\n    /* seat */\n    FRAME(S, 5, 52);\n    FRAME(IY, 10, 52);\n    FRAME(Ta, 2, 52);\n    FRAME(Tb, 2, 52);\n    FRAME(Tc, 2, 52);\n    /* Of */\n    FRAME(AA, 10, 54);\n    FRAME(V, 5, 54);\n    /* a */\n    FRAME(AE, 15, 55);\n    /* bi- */\n    FRAME(Ba, 2, 57);\n    FRAME(Bb, 2, 57);\n    FRAME(Bc, 2, 57);\n    FRAME(AY, 10, 57);\n    FRAME(YX, 5, 57);\n    /* -cy- */\n    FRAME(S, 5, 54);\n    FRAME(IH, 10, 54);\n    /* -cle */\n    FRAME(Ka, 2, 50);\n    FRAME(Kb, 2, 50);\n    FRAME(Kc, 2, 50);\n    FRAME(L, 9, 50);\n    /* made */\n    FRAME(M, 2, 52);\n    FRAME(EY, 17, 52);\n    FRAME(YX, 10, 52);\n    FRAME(Da, 2, 52);\n    FRAME(Db, 2, 52);\n    FRAME(Dc, 2, 52);\n    /* for */\n    FRAME(F, 5, 45);\n    FRAME(OY, 13, 45);\n    FRAME(RX, 5, 45);\n    /* two */\n    FRAME(Ta, 2, 50);\n    FRAME(Tb, 2, 50);\n    FRAME(Tc, 2, 50);\n    FRAME(UX, 50, 50);\n    return vec2(r * (1. - smoothstep(55.,60.,time)));\n}","name":"","description":"","type":"sound"}]}