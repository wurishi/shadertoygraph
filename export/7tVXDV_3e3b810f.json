{"ver":"0.1","info":{"id":"7tVXDV","date":"1642015726","viewed":230,"name":"SmoothÂ²","username":"UnstableLobster","description":"A little bit of order can be quite healthy","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["grid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define DEBUG 0\n\n\n#define mixSDF(a, b, t, r) mix(a, b, saturate(-t*r))\n\n#define ratio iResolution.x\n#define cells 10.0\n#define cellRatio (ratio/cells)\n\nvec4 getCellRandomState(vec2 cell)\n{\n    rng_initialize(cell, 0);\n    \n    vec4 start = rand4();\n    vec4 state = (sin(rand4()*10.0 + start + iTime*(0.5+rand4()*0.5)*0.5 )*0.5+0.5);\n    state = 0.2 + state * 0.6;\n    \n    return vec4(state);\n}\n\nvec4 getCorrectedBounds(vec2 cell, vec2 iuv)\n{\n    vec4 bounds      = getCellRandomState(cell);    \n    vec4 boundsUp    = getCellRandomState(cell + vec2(0.0, 1.0) );\n    vec4 boundsRight = getCellRandomState(cell + vec2(1.0, 0.0) );\n    \n    bounds.z = boundsUp.x;\n    bounds.w = boundsRight.y;   \n    return bounds;\n}\n\nvec2 getBoxCell(vec2 cell, vec4 bounds, vec2 iuv)\n{\n    cell += float(iuv.y > bounds.w && iuv.x > bounds.z); \n    cell.x += float(iuv.x > bounds.x && iuv.y < bounds.w); \n    cell.y += float(iuv.x < bounds.z && iuv.y > bounds.y);\n    return cell;\n}\n\nvec4 getBoxShape(vec2 ccell, vec2 iuv)\n{\n   \n    vec4 ccellBounds     = getCorrectedBounds(ccell, iuv);\n    vec4 ccellBoundsLeft = getCorrectedBounds(ccell - vec2(1.0, 0.0), iuv);\n    vec4 ccellBoundsDown = getCorrectedBounds(ccell - vec2(0.0, 1.0), iuv);\n    \n    float xMin = -(1.0 - ccellBoundsLeft.x);\n    float xMax = ccellBounds.x;\n    float yMin = -(1.0 - ccellBoundsDown.y);\n    float yMax = ccellBounds.y;\n\n    vec2 center = vec2(xMin + xMax, yMin + yMax)*0.5;\n    vec2 size = vec2(abs(xMin) + abs(xMax), abs(yMin) + abs(yMax))*0.5;\n    \n    return vec4(center, size);\n}\n\nvec2 getBoxUV(vec2 cell, vec2 ccell, vec2 iuv)\n{\n    vec2 cellDiff = cell - ccell;\n    vec2 boxIuv = iuv;\n    if (cellDiff.x < -0.5) boxIuv.x = -(1.0 - iuv.x);\n    if (cellDiff.y < -0.5) boxIuv.y = -(1.0 - iuv.y);\n    return boxIuv;\n}\n\nvec4 getBoxColor(vec2 ccell)\n{\n    rng_initialize(ccell, 0);\n    return 0.25 + rand4()*0.5;\n}\n\n\nvoid mainImage( out vec4 O, in vec2 pos )\n{\n    vec2 uv = pos/ratio;\n    uv += iTime*0.021;\n    \n    \n    vec2 cell = floor(uv * cells);\n    vec2 iuv = (uv*cells - cell);\n  \n    vec4 bounds = getCellRandomState(cell);    \n    vec4 nBounds = getCorrectedBounds(cell, iuv);\n    vec2 ccell = getBoxCell(cell, nBounds, iuv);\n    \n    vec4 shape = getBoxShape(ccell, iuv);\n    vec2 center = shape.xy;\n    vec2 size = shape.zw;\n    vec2 boxUV = getBoxUV(cell, ccell, iuv);\n    \n    \n    vec4 displayBounds = nBounds;\n\n    //color\n    O = getBoxColor(ccell);\n    \n    //inner stripes\n    {\n       float r = 0.12;\n       float c = 0.18;\n       \n       float d = -sdBox(boxUV - center, size + r*0.5);\n       float t = -sdBox(boxUV - center, size);\n       \n       c = c*(1.0-t*0.7);\n       r = r*(1.0-t*0.7);\n       \n       float dd = mod(d, c);\n       dd = c-abs(dd - c*0.5);\n       dd = dd - r;\n       \n       O = mixSDF(O, O*saturate(0.8+t*0.5), -dd, cellRatio);\n    }\n\n    //shadows\n    {\n        float h = getCellRandomState(ccell).z;\n            \n        float upH = getCellRandomState(ccell + vec2(0.0, 1.0)).z;\n        vec4 up = getBoxShape(ccell + vec2(0.0, 1.0), iuv);\n        vec2 upCenter = up.xy + vec2(0.0, 1.0);\n        vec2 upSize = up.zw;\n             \n        float l = sdBoxL(boxUV - upCenter, upSize);\n        float o = sdBoxOC(boxUV - upCenter, upSize);\n        \n        float hDiff = saturate(upH-h); \n        l = mix(l, 1.0, hDiff/0.6);\n\n        float s = saturate(0.5+l*1.5);      \n        O = mixSDF(O, O*s, o/(1.0+s*6.0), cellRatio);\n    }\n   \n    //white\n    {\n        vec4 color = vec4(0.8);\n        \n        vec2 c = vec2(0.008);\n        vec2 puv = uv*rot(PI*0.25);\n        vec2 pp = repeat(vec2(puv.x, 0.0), c);\n        float d = length(pp) - 0.002;\n        \n        color = mixSDF(color,color + 0.15, d, ratio);\n    \n        if (nBounds.z > nBounds.x && nBounds.w > nBounds.y\n        && iuv.x > nBounds.x && iuv.x < nBounds.z\n        && iuv.y > nBounds.y && iuv.y < nBounds.w)          \n            O = color;\n            \n        if (nBounds.z < nBounds.x && nBounds.w < nBounds.y\n        && iuv.x < nBounds.x && iuv.x > nBounds.z\n        && iuv.y < nBounds.y && iuv.y > nBounds.w)          \n            O = color;\n    }\n    //black\n    {\n        if (nBounds.z < nBounds.x && nBounds.w > nBounds.y\n        && iuv.x < nBounds.x && iuv.x > nBounds.z\n        && iuv.y > nBounds.y && iuv.y < nBounds.w)          \n            O = vec4(0.0);\n            \n        if (nBounds.z > nBounds.x && nBounds.w < nBounds.y\n        && iuv.x > nBounds.x && iuv.x < nBounds.z\n        && iuv.y < nBounds.y && iuv.y > nBounds.w)          \n            O = vec4(0.0);\n\n    }\n\n    //lines\n    {\n        vec4 color = vec4(1.0);\n        float d = 0.0;\n        float l = 0.015;\n        float pixel = 1.0/cellRatio;\n        \n        l = max(l, pixel*1.25);\n\n        d = min(d, sdSegment(iuv, vec2(0.0, nBounds.y), vec2(max(nBounds.x, nBounds.z), nBounds.y)) - l);\n        d = min(d, sdSegment(iuv, vec2(1.0, nBounds.w), vec2(min(nBounds.x, nBounds.z), nBounds.w)) - l);\n        d = min(d, sdSegment(iuv, vec2(nBounds.x, 0.0), vec2(nBounds.x, max(nBounds.y, nBounds.w))) - l);\n        d = min(d, sdSegment(iuv, vec2(nBounds.z, 1.0), vec2(nBounds.z, min(nBounds.y, nBounds.w))) - l);\n            \n        O = mixSDF(O, color, d, cellRatio);\n    }\n    \n#if DEBUG == 1\n    //cell bounds\n    {\n        float d = 0.0;\n        float l = 0.0125;\n        float pixel = 1.0/cellRatio;\n        \n        l = max(l, pixel*1.0);\n        if (length(boxUV) <= 0.15) l *= 1.75;\n        \n        vec2 yBox = repeat(abs(boxUV), vec2(1.0, 0.2));               \n        vec2 xBox = repeat(abs(boxUV), vec2(0.2, 1.0));\n        \n        d = min(d, sdSegment(yBox, vec2(0.0), vec2(0.0, 0.1)) - l);\n        d = min(d, sdSegment(xBox, vec2(0.0), vec2(0.1, 0.0)) - l);       \n        \n        O = mixSDF(O, O+0.25, d, cellRatio);\n    }\n    \n    //dots\n    {\n        float a = distance(iuv, vec2(nBounds.x, 0.0));\n        float b = distance(iuv, vec2(nBounds.z, 1.0));     \n        float dx = min(a, b)-0.045;      \n        O = mixSDF(O, 0.25 + vec4(1.0, 0.0, 0.0, 0.0)*0.75, dx, cellRatio);\n        \n        float c = distance(iuv, vec2(0.0, nBounds.y));\n        float d = distance(iuv, vec2(1.0, nBounds.w));     \n        float dy = min(c, d)-0.045;      \n        O = mixSDF(O, 0.25 + vec4(0.0, 1.0, 0.0, 0.0)*0.75, dy, cellRatio);\n        \n    }\n#endif\n          \n    O = pow(O, vec4(0.9));   \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define PI 3.14159265\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n\nfloat sdBox(vec2 p, vec2 b)\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdBoxL(vec2 p, vec2 b)\n{\n    p = abs(p)-b;\n    return max(p.x, p.y);\n}\n\nfloat sdBoxOC(vec2 p, vec2 b)\n{\n    p = abs(p)-b;\n    return min(p.x, p.y);\n}\n\nmat2 rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang),\n                sin(ang), cos(ang)); \n}\n\nvec2 repeat(vec2 p, vec2 c)\n{\n    return mod(p + 0.5*c, c) - 0.5*c;\n}\nfloat repeat(float p, float c)\n{\n    return mod(p + 0.5*c, c) - 0.5*c;\n}\n\n\n\n//-------------\n// RNG https://www.shadertoy.com/view/wltcRS\n//-------------\nuvec4 s0; \n\nvoid rng_initialize(vec2 p, int frame)\n{\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n}\n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n}\n\nfloat rand() { pcg4d(s0); return float(s0.x)/float(0xffffffffu);  }\nvec2 rand2() { pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);  }\nvec3 rand3() { pcg4d(s0); return vec3(s0.xyz)/float(0xffffffffu); }\nvec4 rand4() { pcg4d(s0); return vec4(s0)/float(0xffffffffu);     }","name":"Common","description":"","type":"common"}]}