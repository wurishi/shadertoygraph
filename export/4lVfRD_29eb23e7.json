{"ver":"0.1","info":{"id":"4lVfRD","date":"1543763745","viewed":137,"name":"try perlin noise","username":"cailuming","description":"apply perlin noise to sphere, 3D is ok , but 2D can not be mapped to the sphere surface correctly","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//hash function is modified from iq's demo, for easy to remember \n//see https://www.shadertoy.com/view/4tXyWN\n\n#define PI   3.1415926\n#define U_PI 3141592657U\n#define MAXIT 256\n#define SCALE  7.01592657e+3\nstruct Ray{\n   vec3 o;\n   vec3 d;\n};\n    \nmat2 rot2D(float arc){\n   float c = cos(arc);\n   float s = sin(arc);\n   \n   return mat2(c,s,-s,c); \n}\n\nvec3 getColor(float c){\n   float r= cos((c-0.85)*PI);\n   float g= cos((c-0.55)*PI);\n   float b= cos((c-0.15)*PI);\n    \n   return vec3(r,g,b); \n}\n\nfloat hash( vec2 x ) //modified from iq's hash function\n{\n    uvec2 q = U_PI * uvec2(x);\n    uint  n = U_PI * (q.x^(q.y>>1U));\n    return float(n)/float(0xffffffffU);\n}\n\nvec2 hash1( vec2 x )  // modified from iq's hash function\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    vec2 v = -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) ); \n    v*=k;\n    v*=rot2D(iTime*4.);\n    return v;\n}\n\nvec3 hash2( vec3 x )  // modified from iq's hash function\n{\n    const vec3 k = vec3( 0.3183099, 0.3678794,.3787694 );\n    x = x*k + k.zyx;\n    vec3 v = -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*x.z*(x.x+x.y+x.z)) ); \n\n    return v;\n}\n\n//see https://iquilezles.org/articles/morenoise\n//refuse to remember ,but to understand what is going on is so important \n\n// 2d noise ,inspired by iq ,but without the gradient\n// 2d noise cann't be apllied to a sphere no matter what drivers I use vec3(x,y,z) or vec2(atan(p.y,p.x),atan(p.z,p.y)\n\nfloat noise2D(vec2 uv){\n   vec2 x00 = floor(uv);\n   vec2 x01 = x00+vec2(0,1);\n   vec2 x10 = x00+vec2(1,0);\n   vec2 x11 = x00+vec2(1);\n   vec2 cp  = fract(uv);\n    \n   vec2 v00 = hash1(x00);\n   vec2 v01 = hash1(x01);\n   vec2 v10 = hash1(x10);\n   vec2 v11 = hash1(x11);\n    \n   float d00 = dot(v00,uv-x00);\n   float d01 = dot(v01,uv-x01);\n   float d10 = dot(v10,uv-x10);\n   float d11 = dot(v11,uv-x11);\n    \n   cp = 3.*cp*cp - 2.*cp*cp*cp;\n     \n   d00 = mix(d00,d10,cp.x);\n   d01 = mix(d01,d11,cp.x);\n    \n       \n   return mix(d00,d01,cp.y);\n    \n}\n\n// 3d noise ,inspired by iq ,but without the gradient\nfloat noise3D(vec3 p){\n   vec3 x000 = floor(p);\n   //evaluate the eight corner first \n   vec3 x001 = x000+vec3(0,0,1);\n   vec3 x010 = x000+vec3(0,1,0);\n   vec3 x011 = x000+vec3(0,1,1);\n   \n   vec3 x100 = x000+vec3(1,0,0);\n   vec3 x101 = x000+vec3(1,0,1);\n   vec3 x110 = x000+vec3(1,1,0);\n   vec3 x111 = x000+vec3(1,1,1);\n   \n   // get the interpolation coe  \n   vec3 cp  = fract(p);\n   \n   //get each random vector of the corner \n   vec3 v000 = hash2(x000);\n   vec3 v001 = hash2(x001);\n   vec3 v010 = hash2(x010);\n   vec3 v011 = hash2(x011);\n   vec3 v100 = hash2(x100);\n   vec3 v101 = hash2(x101);\n   vec3 v110 = hash2(x110);\n   vec3 v111 = hash2(x111);\n    \n   //do the projection \n   float d000 = dot(v000,p-x000);\n   float d001 = dot(v001,p-x001);\n   float d010 = dot(v010,p-x010);\n   float d011 = dot(v011,p-x011);\n    \n   float d100 = dot(v100,p-x100);\n   float d101 = dot(v101,p-x101);\n   float d110 = dot(v110,p-x110);\n   float d111 = dot(v111,p-x111);\n    \n   //interpolation curve vector \n   cp = 6.*cp*cp*cp*cp*cp - 15.*cp*cp*cp*cp+10.*cp*cp*cp;\n   \n    \n   d000 = mix(d000,d010,cp.y);\n   d100 = mix(d100,d110,cp.y);\n   \n   d001 = mix(d001,d011,cp.y);\n   d101 = mix(d101,d111,cp.y);\n   \n   return mix(mix(d000,d100,cp.x),mix(d001,d101,cp.x),cp.z);\n    \n}\n\n \nvec2 planet(vec3 p,vec3 c){\n   p-=c;\n   p.xz*=rot2D(iTime*0.1);\n   vec3 p1 = p; \n\n   float n =  noise3D(p*1.94)*.3;\n\n   return vec2(mix(length(p)-1.,n,.4),1); \n}\n\nvec2 ocean(vec3 p,vec3 c){\n   p-=c;\n   p.xz*=rot2D(iTime*0.1);\n    \n   float a1 = atan(p.y,p.x);  \n   float a2 = atan(p.z,p.y);  \n    \n   return vec2(mix(length(p)-1.,noise2D(vec2(p.y,atan(p.z,p.x))*15.)*0.02,0.5),2); \n}\n \n\nvoid cmp(inout vec2 a, vec2 b){\n   a = a.x<b.x?a:b;\n}\n\nvec2 map(vec3 p){\n  vec2 ref = vec2(1000.);\n  cmp(ref,planet(p,vec3(0)));\n  cmp(ref,ocean(p,vec3(0)));\n    \n  return ref;  \n}\n\n\nvec3 grad(vec3 p){\n   float m = map(p).x;\n   vec2 e = vec2(1,0)*0.001;\n   return -normalize(vec3(m-map(p+e.xyy).x,m-map(p+e.yxy).x,m-map(p+e.yyx).x));\n}\n\nvoid shading(inout vec3 col,vec3 lp,vec3 p,vec3 vd,inout float id){\n   vec3 n  = grad(p);\n   vec3 ld = normalize(lp-p);\n   vec3 rd = reflect(-ld,n);\n   vec3 hv = normalize(ld-vd);\n    \n   float nl = smoothstep(0.,1.,dot(n,ld));\n   float rl = clamp(dot(rd,-vd),0.,1.);\n   float fr = clamp(dot(hv,n),0.,1.);\n   fr = 0.2+0.8*pow(1.-fr,5.);\n   if(id==1.){\n       p.xz*=rot2D(iTime*0.1);\n       col += texture(iChannel0,vec2(atan(p.z,p.x)+PI*0.5,p.y*0.5)).xyz*getColor(length(p*p)*1.2+1.6)*nl;\n       \n   }else if(id==2.){\n       col += getColor(0.1)*nl+pow(rl*1.,550.)*getColor(0.6);\n   } \n \n}\n \nvoid atmosphere(inout Ray r,inout vec3 col,vec3 p,vec3 lp){\n   vec3 p1   = vec3(0); \n   vec3 ld   = vec3(0);\n   vec3 rd   = vec3(0);\n   vec3 n    = vec3(0); \n   float ar  = 1.5; \n   float t  = 5.;\n   float lv = 0.;\n   float tens = 0.;\n \n   for(int i=0;i<MAXIT;i++){\n       p1 = r.o+r.d*t;\n       \n       if(length(p1)-ar<=0.0001){\n           \n           tens+=exp(t)*0.00003;\n       \n       }else if(length(p1)<=length(p)){\n           ld = normalize(lp-p);\n           rd = reflect(r.d,normalize(p));  \n           break;\n       } \n       \n       t+=0.015; \n   }\n       \n    col+=vec3(0.4,0.8,0.9)*(tens*smoothstep(-0.2,1.,dot(ld,rd))); \n}\n\nvoid drawStars(inout vec3 col,vec2 uv,vec2 c){\n   uv-=c;\n    \n   uv*=9.8;\n   \n   float l =length(uv);\n   float arc = atan(uv.y,uv.x); \n     \n   float d = abs(dot(vec2(0,1),uv));\n   float d1 = abs(dot(vec2(1,0),uv));\n   float ctv = c.x*10.0;\n   // clip the star\n   d+=pow(l,1.1+0.6*cos(iTime*2.0+ctv));\n   d1+=pow(l,1.1+0.6*cos(iTime*2.0+ctv));\n   \n   float v =0.0005/l;  \n   // blend the star\n   v+=0.01/(d);\n   v+=0.01/(d1);\n   v=pow(v,1.6);\n    \n   col+=vec3(cos(iTime+ctv)*0.1+0.5,sin(iTime+ctv)*0.4+0.5,sin(iTime)*0.3+0.7)*v;\n}\n\nvoid drawStarGroup(inout vec3 col,vec2 uv,float starNum){\n    for (float i=0.0;i<starNum;i++){\n        drawStars(col,uv,vec2(i*0.2*sin(i),cos(i)*0.3));\n    }\n    \n}\n\nvoid rayTrace(inout Ray r,inout vec3 col,vec3 lp){\n   vec2 res = vec2(0);\n   vec3 p   = vec3(0); \n   vec3 n  = vec3(1.); \n   float t  = 0.;\n   \n   for(int i=0;i<MAXIT;i++){\n       p = r.o+r.d*t;\n       res = map(p);\n       if(t>=32.){\n           \n          break;\n       }\n       if(res.x<=0.0001){\n          shading(col,lp,p,r.d,res.y);\n         \n          break;\n       }\n      \n       t+=res.x;\n   \n   }\n   atmosphere(r,col,p,lp); \n    \n}\n\nvoid setCamera(inout Ray r,vec3 eye,vec3 tar,vec2 uv){\n   vec3 look = normalize(tar-eye);\n   vec3 right = normalize(cross(vec3(0,1,0),look));\n   vec3 up    = normalize(cross(look,right));\n    \n   r.o = eye;\n   r.d = normalize(uv.x*right+uv.y*up +look);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = uv - vec2(0.5);\n    vec3 lp = vec3(10.0*sin(iTime*0.1),1,10.0*cos(iTime*0.1));\n    vec3 eye = vec3(0,1,-5);\n    vec3 tar = vec3(0,0,1);\n    vec3 col = vec3(0);\n    cuv.x*= iResolution.x/iResolution.y;\n    \n    Ray r;\n    \n    setCamera(r,eye,tar,cuv);\n    drawStarGroup(col,cuv,12.);\n    rayTrace(r,col,lp);\n    col = smoothstep(0.,1.,col);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}