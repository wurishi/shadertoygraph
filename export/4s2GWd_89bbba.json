{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"\nfloat kFarClip=1000.0;\n\nvec3 vLightPos = vec3(1.5, 2.0, 3.0);\t\t\t\nvec3 vLightColour = vec3(1.0, 0.5, 0.05);\n\nvec2 GetWindowCoord( const in vec2 vUV );\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget );\nvec3 GetSceneColour( in vec3 vRayOrigin,  in vec3 vRayDir );\nvec3 ApplyPostFX( const in vec2 vUV, const in vec3 vInput );\n\nvec3 vCameraOffset = vec3(0.0, 0.0, 0.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vUV = fragCoord.xy / iResolution.xy;\n\n\tvec2 vMouse = iMouse.xy / iResolution.xy;\n\t\n\tfloat fAngle = vMouse.x * 2.0 * 3.14 + 2.8;\n\tvec3 vCameraPos = vec3(sin(fAngle) * 10.0, vMouse.y * 10.0 - 2.0, cos(fAngle) * 10.0);\n\n\t\n\tvCameraOffset.z = iTime * 10.0;\n\t\n\tvec3 vCameraTarget = vec3(0.0, 0.0, 0.0);\n\n\tif(iMouse.z <= 0.0)\n\t{\n\t\tvCameraPos += vCameraOffset;\n\t\tvCameraTarget += vCameraOffset;\n\n\t\tvLightPos += vCameraOffset;\n\t\t\n\t\tvCameraPos.x += sin(iTime * 0.5);\n\t}\n\n\tvec3 vRayOrigin = vCameraPos;\n\tvec3 vRayDir = GetCameraRayDir( GetWindowCoord(vUV), vCameraPos, vCameraTarget );\n\t\n\tvec3 vResult = GetSceneColour(vRayOrigin, vRayDir);\n\t\n\tvec3 vFinal = ApplyPostFX( vUV, vResult );\n\t\n\tfragColor = vec4(vFinal, 1.0);\n}\n\n// CAMERA\n\nvec2 GetWindowCoord( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x / iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\t\t\t\t\t\t  \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * 2.0);\n\n\treturn vDir;\n}\n\n// POSTFX\n\nvec3 ApplyVignetting( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0);\n\t\n\tfloat fDist = dot(vOffset, vOffset);\n\t\n\tconst float kStrength = 0.5;\n\t\n\tfloat fShade = mix( 1.0, 1.0 - kStrength, fDist );\t\n\n\treturn vInput * fShade;\n}\n\nvec3 ApplyTonemap( const in vec3 vLinear )\n{\n\tconst float kExposure = 2.0;\n\t\n\treturn 1.0 - exp2(vLinear * -kExposure);\t\n}\n\nvec3 ApplyGamma( const in vec3 vLinear )\n{\n\tconst float kGamma = 2.2;\n\n\treturn pow(vLinear, vec3(1.0/kGamma));\t\n}\n\nvec3 ApplyPostFX( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec3 vTemp = ApplyVignetting( vUV, vInput );\t\n\t\n\tvTemp = ApplyTonemap(vTemp);\n\t\n\treturn ApplyGamma(vTemp);\t\t\n}\n\t\n// RAYTRACE\n\nstruct C_Intersection\n{\n\tvec3 vPos;\n\tfloat fDist;\t\n\tvec3 vNormal;\n\tvec3 vUVW;\n\tfloat fObjectId;\n};\n\n\nfloat GetSceneDistance( out vec4 vOutUVW_Id, const in vec3 vPos )\n{\n\t\n\tfloat fTileHash = (floor(vPos.x / 10.0) + floor(vPos.x / 12.0)) * 0.5;\n\t\n\tvec3 vStrandDomain = mod(vPos, 10.0) - 5.0;\n\t\t\n\tvStrandDomain.x += sin(vPos.y * 0.1);\n\t\n\tvStrandDomain.y += fTileHash * 10.0 + iTime * (1.0 + fract(fTileHash*123.456)) * 3.0;\n\t\n\tfloat fAngle = vPos.y * 0.5 + iTime* (1.0 + fract(fTileHash*123.456)) * 3.0;\n\tfloat s = sin(fAngle);\n\tfloat c = cos(fAngle);\n\n\tvec3 vStrutDomain = vStrandDomain;\n\tvStrutDomain.x = vStrandDomain.x * s + vStrandDomain.z * c;\n\tvStrutDomain.z = vStrandDomain.x * c - vStrandDomain.z * s;\n\t\n\tfloat fEdgeDist1 = length(vStrutDomain.xz + vec2(-1.0, 0.0)) - 0.25;\n\tfloat fEdgeDist2 = length(vStrutDomain.xz + vec2( 1.0, 0.0)) - 0.25;\n\t\n\tfloat fOutDist = min(fEdgeDist1, fEdgeDist2);\n\tvOutUVW_Id = vec4(vStrutDomain.xy, 0.0, 1.0);\n\n\tvStrutDomain.y = mod(vStrandDomain.y, 1.0) - 0.5;\n\t\n\tfloat fStrutDist = length(vStrutDomain.zy) - 0.1;\n\t\n\tfStrutDist = max(fStrutDist, length(vStrutDomain.xz) - 0.75);\n\t\n\tif(fStrutDist < fOutDist)\n\t{\n\t\tfOutDist = fStrutDist;\n\t\tvOutUVW_Id = vec4(vStrutDomain.xz, 0.0, 2.0);\n\t}\n\t//fOutDist = min(fStrutDist, fOutDist);\n\t\n\treturn fOutDist;\n}\n\nvec3 GetSceneNormal(const in vec3 vPos)\n{\n    const float fDelta = 0.0001;\n\n    vec3 vDir1 = vec3( 1.0, -1.0, -1.0);\n    vec3 vDir2 = vec3(-1.0, -1.0,  1.0);\n    vec3 vDir3 = vec3(-1.0,  1.0, -1.0);\n    vec3 vDir4 = vec3( 1.0,  1.0,  1.0);\n\t\n    vec3 vOffset1 = vDir1 * fDelta;\n    vec3 vOffset2 = vDir2 * fDelta;\n    vec3 vOffset3 = vDir3 * fDelta;\n    vec3 vOffset4 = vDir4 * fDelta;\n\n\tvec4 vUnused;\n    float f1 = GetSceneDistance( vUnused, vPos + vOffset1 );\n    float f2 = GetSceneDistance( vUnused, vPos + vOffset2 );\n    float f3 = GetSceneDistance( vUnused, vPos + vOffset3 );\n    float f4 = GetSceneDistance( vUnused, vPos + vOffset4 );\n\t\n    vec3 vNormal = vDir1 * f1 + vDir2 * f2 + vDir3 * f3 + vDir4 * f4;\t\n\t\t\n    return normalize( vNormal );\n}\n\nvoid TraceScene( out C_Intersection outIntersection, const in vec3 vOrigin, const in vec3 vDir )\n{\t\n\tvec4 vUVW_Id = vec4(0.0);\t\t\n\tvec3 vPos = vec3(0.0);\n\t\n\tfloat t = 0.01;\n\tconst int kRaymarchMaxIter = 48;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\n\t\tvPos = vOrigin + vDir * t;\n\t\tfloat fDist = GetSceneDistance(vUVW_Id, vPos);\t\t\n\t\tt += fDist;\n\t\tif(abs(fDist) < 0.001)\n\t\t{\n\t\t\tbreak;\n\t\t}\t\t\n\t\tif(t > 100.0)\n\t\t{\n\t\t\tt = kFarClip;\n\t\t\tvPos = vOrigin + vDir * t;\n\t\t\tvUVW_Id = vec4(0.0);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\toutIntersection.fDist = t;\n\toutIntersection.vPos = vPos;\n\toutIntersection.vNormal = GetSceneNormal(vPos);\n\toutIntersection.vUVW = vUVW_Id.xyz;\n\toutIntersection.fObjectId = vUVW_Id.w;\n}\n\n#define SOFT_SHADOW\n\nfloat TraceShadow( const in vec3 vOrigin, const in vec3 vDir, const in float fDist )\n{\n#ifndef SOFT_SHADOW\n\tC_Intersection shadowIntersection;\n\tTraceScene(shadowIntersection, vOrigin, vDir);\n\tif(shadowIntersection.fDist < fDist) \n\t{\n\t\treturn 0.0;\t\t\n\t}\n\t\n\treturn 1.0;\n#else\t\n\t#define kShadowIter 32\n\t#define kShadowFalloff 5.0\n\tfloat fShadow = 1.0;\n\tfloat t = 0.01;\n\tfloat fDelta = 1.0 / float(kShadowIter);\n\tfor(int i=0; i<kShadowIter; i++)\n\t{\n\t\tvec4 vUnused;\n\t\tfloat d = GetSceneDistance(vUnused, vOrigin + vDir * t);\n\t\t\n\t\tfShadow = min( fShadow, kShadowFalloff * d / t );\n\t\t\n\t\tt = t + fDelta;\n\t}\n\n\treturn clamp(fShadow, 0.0, 1.0);\n#endif\n}\n\n// AMBIENT OCCLUSION\n\nfloat GetAmbientOcclusion( const in vec3 vPos, const in vec3 vNormal )\n{\n\tfloat fAmbientOcclusion = 0.0;\n\t\n\tfloat fStep = 0.1;\n\tfloat fDist = 0.0;\n\tfor(int i=0; i<=5; i++)\n\t{\n\t\tfDist += fStep;\n\t\t\n\t\tvec4 vUnused;\n\t\tfloat fSceneDist = GetSceneDistance(vUnused, vPos + vNormal * fDist);\n\t\t\n\t\tfloat fAmount = (fDist - fSceneDist);\n\t\t\n\t\tfAmbientOcclusion += max(0.0, fAmount * fDist );                                  \n\t}\n\t\n\treturn max(1.0 - fAmbientOcclusion, 0.0);\n}\n\n// LIGHTING\n\nvoid AddLighting(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightColour)\n{\n\tfloat fNDotL = clamp(dot(vLightDir, vNormal), 0.0, 1.0);\n\t\n\tvDiffuseLight += vLightColour * fNDotL;\n\t\n\tvec3 vHalfAngle = normalize(-vViewDir + vLightDir);\n\tfloat fSpecularPower = exp2(4.0 + 6.0 * fSmoothness);\n\tfloat fSpecularIntensity = (fSpecularPower + 2.0) * 0.125;\n\tvSpecularLight += vLightColour * fSpecularIntensity * clamp(pow(dot(vHalfAngle, vNormal), fSpecularPower), 0.0, 1.0) * fNDotL;\n}\n\nvoid AddPointLight(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vPos, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightPos, const in vec3 vLightColour)\n{\n\tvec3 vToLight = vLightPos - vPos;\t\n\tfloat fDistance2 = dot(vToLight, vToLight);\n\tfloat fAttenuation = 100.0 / (fDistance2);\n\tvec3 vLightDir = normalize(vToLight);\n\t\n\tvec3 vShadowRayDir = vLightDir;\n\tvec3 vShadowRayOrigin = vPos + vShadowRayDir * 0.01;\n\tfloat fShadowFactor = TraceShadow(vShadowRayOrigin, vShadowRayDir, length(vToLight));\n\t\n\tAddLighting(vDiffuseLight, vSpecularLight, vViewDir, vLightDir, vNormal, fSmoothness, vLightColour * fShadowFactor * fAttenuation);\n}\n\nvoid AddPointLightFlare(inout vec3 vEmissiveGlow, const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fIntersectDistance, const in vec3 vLightPos, const in vec3 vLightColour)\n{\n    vec3 vToLight = vLightPos - vRayOrigin;\n    float fPointDot = dot(vToLight, vRayDir);\n    fPointDot = clamp(fPointDot, 0.0, fIntersectDistance);\n\n    vec3 vClosestPoint = vRayOrigin + vRayDir * fPointDot;\n    float fDist = length(vClosestPoint - vLightPos);\n\tvEmissiveGlow += sqrt(vLightColour * 0.05 / (fDist * fDist));\n}\n\nvoid AddDirectionalLight(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vPos, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightDir, const in vec3 vLightColour)\n{\t\n\tfloat fAttenuation = 1.0;\n\n\tvec3 vShadowRayDir = -vLightDir;\n\tvec3 vShadowRayOrigin = vPos + vShadowRayDir * 0.01;\n\tfloat fShadowFactor = TraceShadow(vShadowRayOrigin, vShadowRayDir, 10.0);\n\t\n\tAddLighting(vDiffuseLight, vSpecularLight, vViewDir, -vLightDir, vNormal, fSmoothness, vLightColour * fShadowFactor * fAttenuation);\t\n}\n\nvoid AddDirectionalLightFlareToFog(inout vec3 vFogColour, const in vec3 vRayDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fDirDot = clamp(dot(-vLightDir, vRayDir), 0.0, 1.0);\n\tfloat kSpreadPower = 4.0;\n\tvFogColour += vLightColour * pow(fDirDot, kSpreadPower);\n}\n\n// SCENE MATERIALS\n\nvoid GetSurfaceInfo(out vec3 vOutAlbedo, out vec3 vOutR0, out float fOutSmoothness, out vec3 vOutBumpNormal, const in C_Intersection intersection )\n{\n\tvOutBumpNormal = intersection.vNormal;\n\t\n\tif(intersection.fObjectId == 1.0)\n\t{\n\t\tvec2 vUV = intersection.vUVW.xy * 0.1;// + vec2(iTime * 0.5, 0.0);\n\t\tvOutAlbedo = texture(iChannel0, vUV).rgb;\n\t\tfloat fBumpScale = 1.0;\n\t\t\n\t\tvec2 vRes = iChannelResolution[0].xy;\n\t\tvec2 vDU = vec2(1.0, 0.0) / vRes;\n\t\tvec2 vDV = vec2(0.0, 1.0) / vRes;\n\t\t\n\t\tfloat fSampleW = texture(iChannel0, vUV - vDU).r;\n\t\tfloat fSampleE = texture(iChannel0, vUV + vDU).r;\n\t\tfloat fSampleN = texture(iChannel0, vUV - vDV).r;\n\t\tfloat fSampleS = texture(iChannel0, vUV + vDV).r;\n\t\t\n\t\tvec3 vNormalDelta = vec3(0.0);\n\t\tvNormalDelta.x += \n\t\t\t( fSampleW * fSampleW\n\t\t\t - fSampleE * fSampleE) * fBumpScale;\n\t\tvNormalDelta.z += \n\t\t\t(fSampleN * fSampleN\n\t\t\t - fSampleS * fSampleS) * fBumpScale;\n\t\t\n\t\tvOutBumpNormal = normalize(vOutBumpNormal + vNormalDelta);\n\n\t\tvOutAlbedo = vOutAlbedo * vOutAlbedo;\t\n\t\tfOutSmoothness = vOutAlbedo.r * 0.9;//\n\t\t\n\t\tvOutR0 = vec3(0.5) * vOutAlbedo.g;\n\t}\n\telse if(intersection.fObjectId == 2.0)\n\t{\n\t\tvec2 vUV = intersection.vUVW.xy;\n\t\t//vec2 vUV = vec2(intersection.vUVW.z, iTime * -0.5 * 3.14 + atan(intersection.vUVW.x, intersection.vUVW.y));\n\t\tvOutAlbedo = texture(iChannel1, vUV).rgb;\n\t\tvOutAlbedo = vOutAlbedo * vOutAlbedo;\t\n\t\tfOutSmoothness = vOutAlbedo.r;\t\t\t\n\t\tvOutR0 = vec3(0.05);\n\t}\n\t\n\t//vOutR0 = vec3(0.9);\n\t//fOutSmoothness = 0.5;\n}\n\nvec3 GetSkyColour( const in vec3 vDir )\n{\n\tvec3 vResult = vec3(0.0);\n\t\n\t//if(false)\n\t{\n\t\tvResult = mix(vec3(0.02, 0.04, 0.06), vec3(0.1, 0.5, 0.8), abs(vDir.y));\n\t}\n\t/*else\n\t{\n\t\tvec3 vEnvMap = texture(iChannel2, vDir).rgb;\n\t\tvEnvMap = vEnvMap * vEnvMap;\n\t\tfloat kEnvmapExposure = 0.5;\n\t\tvResult = -log2(1.0 - vEnvMap * kEnvmapExposure);\n\t}*/\n\t\n\treturn vResult;\t\n}\n\nfloat GetFogFactor(const in float fDist)\n{\n\tfloat kFogDensity = 0.005;\n\treturn exp(fDist * -kFogDensity);\t\n}\n\nvec3 GetFogColour(const in vec3 vDir)\n{\n\treturn vec3(0.1, 0.25, 0.0);\t\t\n}\n\n\nvec3 vSunLightColour = vec3(1.0, 0.9, 0.6) * 2.0;\nvec3 vSunLightDir = normalize(vec3(0.4, -0.3, -0.5));\n\t\nvoid ApplyAtmosphere(inout vec3 vColour, const in float fDist, const in vec3 vRayOrigin, const in vec3 vRayDir)\n{\t\t\n\tfloat fFogFactor = GetFogFactor(fDist);\n\tvec3 vFogColour = GetFogColour(vRayDir);\t\t\t\n\tAddDirectionalLightFlareToFog(vFogColour, vRayDir, vSunLightDir, vSunLightColour);\n\t\n\tvec3 vGlow = vec3(0.0);\n\tAddPointLightFlare(vGlow, vRayOrigin, vRayDir, fDist, vLightPos, vLightColour);\t\t\t\t\t\n\t\n\tvColour = mix(vFogColour, vColour, fFogFactor) + vGlow;\t\n}\n\n// TRACING LOOP\n\n\t\nvec3 GetSceneColour( in vec3 vRayOrigin,  in vec3 vRayDir )\n{\n\tvec3 vColour = vec3(0.0);\n\tvec3 vRemaining = vec3(1.0);\n\t\n\tfor(int i=0; i<2; i++)\n\t{\t\n\t\tvec3 vCurrRemaining = vRemaining;\n\t\tfloat fShouldApply = 1.0;\n\t\t\n\t\tC_Intersection intersection;\t\t\t\t\n\t\tTraceScene( intersection, vRayOrigin, vRayDir );\n\n\t\tvec3 vResult = vec3(0.0);\n\t\tvec3 vBlendFactor = vec3(0.0);\n\t\t\t\t\t\t\n\t\tif(intersection.fObjectId == 0.0)\n\t\t{\n\t\t\tvBlendFactor = vec3(1.0);\n\t\t\tfShouldApply = 0.0;\n\t\t}\n\t\telse\n\t\t{\t\t\n\t\t\tvec3 vAlbedo;\n\t\t\tvec3 vR0;\n\t\t\tfloat fSmoothness;\n\t\t\tvec3 vBumpNormal;\n\t\t\t\n\t\t\tGetSurfaceInfo( vAlbedo, vR0, fSmoothness, vBumpNormal, intersection );\t\t\t\n\t\t\n\t\t\tvec3 vDiffuseLight = vec3(0.0);\n\t\t\tvec3 vSpecularLight = vec3(0.0);\n\n\t\t\tAddPointLight(vDiffuseLight, vSpecularLight, vRayDir, intersection.vPos, vBumpNormal, fSmoothness, vLightPos, vLightColour);\t\t\t\t\t\t\t\t\n\n\t\t\tAddDirectionalLight(vDiffuseLight, vSpecularLight, vRayDir, intersection.vPos, vBumpNormal, fSmoothness, vSunLightDir, vSunLightColour);\t\t\t\t\t\t\t\t\n\t\t\t\n\t\t\tvDiffuseLight += 0.2 * GetAmbientOcclusion(intersection.vPos, vBumpNormal);\n\n\t\t\tfloat fSmoothFactor = fSmoothness * 0.9 + 0.1;\n\t\t\tvec3 vFresnel = vR0 + (1.0 - vR0) * pow(1.0 - dot(-vBumpNormal, vRayDir), 5.0) * fSmoothFactor;\n\t\t\t\n\t\t\tvResult = mix(vAlbedo * vDiffuseLight, vSpecularLight, vFresnel);\t\t\n\t\t\tvBlendFactor = vFresnel;\n\t\t\t\n\t\t\tApplyAtmosphere(vResult, intersection.fDist, vRayOrigin, vRayDir);\t\t\n\t\t\t\n\t\t\tvRemaining *= vBlendFactor;\t\t\t\t\n\t\t\tvRayDir = normalize(reflect(vRayDir, vBumpNormal));\n\t\t\tvRayOrigin = intersection.vPos;\n\t\t}\t\t\t\n\n\t\tvColour += vResult * vCurrRemaining * fShouldApply;\n\t\t\n\t\t\n\t}\n\n\tvec3 vSkyColor = GetSkyColour(vRayDir);\n\t\n\tApplyAtmosphere(vSkyColor, kFarClip, vRayOrigin, vRayDir);\t\t\n\t\n\tvColour += vSkyColor * vRemaining;\n\t\n\treturn vColour;\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4s2GWd","date":"1395286184","viewed":1698,"name":"[SH2014]Thing","username":"P_Malin","description":"Submission for Shadertoy Hackathon 2014 - Theme \"Evolution\"","likes":32,"published":1,"flags":0,"usePreview":0,"tags":["sh2014"],"hasliked":0,"parentid":"","parentname":""}}