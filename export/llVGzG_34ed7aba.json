{"ver":"0.1","info":{"id":"llVGzG","date":"1475296372","viewed":3522,"name":"Dithered gradients","username":"romainguy","description":"Test of various dithering algorithms for gradients. From top to bottom:\n- No noise\n- Ordered (Bayer matrix)\n- Uniform noise\n- Triangle noise (colored or not)\n- Interleaved gradient noise\n- RGB noise","likes":38,"published":1,"flags":0,"usePreview":0,"tags":["color","dither","srgb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Gradient quantization (1.0 to disable)\n#define QUANTIZATION 32.0\n// Number of quantization levels (use 256 for no quantization)\n#define LEVELS 256.0\n// Set to 0 to use monochromatic triangle noise\n#define RGB_TRIANGLE_NOISE 0\n// Linear or gamma gradients\n#define LINEAR_GRADIENT 1\n\n// Gjøl made a more exhaustive comparison here:\n//     https://www.shadertoy.com/view/MslGR8\n// It shows all dithers presented here\n\nfloat uniformNoise(vec2 n){\n    // uniformly distribued, normalized in [0..1[\n    return fract(sin(dot(n, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat interleavedGradientNoise(vec2 n) {\n    float f = 0.06711056 * n.x + 0.00583715 * n.y;\n    return fract(52.9829189 * fract(f));\n}\n\nfloat triangleNoise(const vec2 n) {\n    // triangle noise, in [-0.5..1.5[ range\n    vec2 p = fract(n * vec2(5.3987, 5.4421));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\n    float xy = p.x * p.y;\n    // compute in [0..2[ and remap to [-1.0..1.0[\n    float noise = (fract(xy * 95.4307) + fract(xy * 75.04961) - 1.0);\n    //noise = sign(noise) * (1.0 - sqrt(1.0 - abs(noise)));\n\treturn noise;\n}\n\nfloat triangleRemap(float n) {\n    float origin = n * 2.0 - 1.0;\n    float v = origin / sqrt(abs(origin));\n    v = max(-1.0, v);\n    v -= sign(origin);\n    return v;\n}\n\nvec3 triangleRemap(const vec3 n) {\n    return vec3(\n        triangleRemap(n.x),\n        triangleRemap(n.y),\n        triangleRemap(n.z)\n    );\n}\n\nvec4 Dither_None(vec4 rgba, float levels) {\n    return rgba;\n}\n\nvec4 Dither_Ordered(vec4 rgba, float levels) {\n    float noise = texture(iChannel0, gl_FragCoord.xy / iChannelResolution[0].xy, -10.0).r;\n    noise = noise - 0.5;\n    return vec4(rgba.rgb + noise / (levels - 1.0), rgba.a);\n}\n\nvec4 Dither_Uniform(vec4 rgba, float levels) {\n    float noise = uniformNoise(gl_FragCoord.xy / iResolution.xy);\n    noise = noise - 0.5;\n    return vec4(rgba.rgb + noise / (levels - 1.0), rgba.a);\n}\n\nvec4 Dither_Interleaved(vec4 rgba, float levels) {\n    // Jimenez 2014, \"Next Generation Post-Processing in Call of Duty\"\n    float noise = interleavedGradientNoise(gl_FragCoord.xy);\n    noise = noise - 0.5;\n    return vec4(rgba.rgb + noise / (levels - 1.0), rgba.a);\n}\n\nvec4 Dither_Vlachos(vec4 rgba, float levels) {\n    // Vlachos 2016, \"Advanced VR Rendering\"\n    vec3 noise = vec3(dot(vec2(171.0, 231.0), gl_FragCoord.xy));\n    noise = fract(noise / vec3(103.0, 71.0, 97.0));\n    noise = noise - 0.5;\n    return vec4(rgba.rgb + (noise / (levels - 1.0)), rgba.a);\n}\n\nvec4 Dither_Vlachos_TrianglePDF(vec4 rgba, float levels) {\n    // Vlachos 2016, \"Advanced VR Rendering\"\n    vec3 noise = vec3(dot(vec2(171.0, 231.0), gl_FragCoord.xy));\n    noise = fract(noise / vec3(103.0, 71.0, 97.0));\n    noise = triangleRemap(noise);\n    return vec4(rgba.rgb + (noise / (levels - 1.0)), rgba.a);\n}\n\nvec4 Dither_TriangleNoise(vec4 rgba, float levels) {\n    // Gjøl 2016, \"Banding in Games: A Noisy Rant\"\n#if RGB_TRIANGLE_NOISE == 1\n    vec3 noise = vec3(\n        triangleNoise(gl_FragCoord.xy / iResolution.xy         ) / (levels - 1.0),\n        triangleNoise(gl_FragCoord.xy / iResolution.xy + 0.1337) / (levels - 1.0),\n        triangleNoise(gl_FragCoord.xy / iResolution.xy + 0.3141) / (levels - 1.0)\n    );\n#else\n    vec3 noise = vec3(triangleNoise(gl_FragCoord.xy / iResolution.xy) / (levels - 1.0));\n#endif\n    return vec4(rgba.rgb + noise, rgba.a);\n}\n\nvec3 OECF(const vec3 c) {\n    return pow(c, vec3(1.0 / 2.2));\n}\n\nvec3 EOCF(const vec3 c) {\n    return pow(c, vec3(2.2));\n}\n\nvec4 gradient(const vec3 s, const vec3 e, const vec2 uv, float levels) {\n    // interpolate in linear space and convert back to sRGB\n    #if LINEAR_GRADIENT > 0\n    vec3 c = OECF(mix(EOCF(s / QUANTIZATION), EOCF(e / QUANTIZATION), uv.x));\n    #else\n    vec3 c= mix(s / QUANTIZATION, e / QUANTIZATION, uv.x);\n    #endif\n\n    // dither in sRGB space\n         if (uv.y < 1.0 / 6.0) return Dither_Vlachos(vec4(c, 1.0), levels);\n    else if (uv.y < 2.0 / 6.0) return Dither_Interleaved(vec4(c, 1.0), levels);\n    else if (uv.y < 3.0 / 6.0) return Dither_TriangleNoise(vec4(c, 1.0), levels);\n    else if (uv.y < 4.0 / 6.0) return Dither_Uniform(vec4(c, 1.0), levels);\n    else if (uv.y < 5.0 / 6.0) return Dither_Ordered(vec4(c, 1.0), levels);\n    else if (uv.y < 6.0 / 6.0) return Dither_None(vec4(c, 1.0), levels);\n\n    return vec4(0.0);\n}\n\nvec4 quantize(vec4 a, float l) {\n\treturn floor(a * l + 0.5) / l;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 c = vec4(0.0);\n    \n         if (uv.x < 1.0 / 4.0) c = gradient(vec3(1, 0, 0), vec3(0, 1, 0), (uv - vec2(0.0 / 4.0, 0.0)) / vec2(1.0 / 4.0, 1.0), LEVELS);\n    else if (uv.x < 2.0 / 4.0) c = gradient(vec3(0, 1, 0), vec3(0, 0, 1), (uv - vec2(1.0 / 4.0, 0.0)) / vec2(1.0 / 4.0, 1.0), LEVELS);\n    else if (uv.x < 3.0 / 4.0) c = gradient(vec3(1, 1, 1), vec3(0, 0, 0), (uv - vec2(2.0 / 4.0, 0.0)) / vec2(1.0 / 4.0, 1.0), LEVELS);\n    else if (uv.x < 4.0 / 4.0) c = gradient(vec3(1, 0, 1), vec3(1, 1, 0), (uv - vec2(3.0 / 4.0, 0.0)) / vec2(1.0 / 4.0, 1.0), LEVELS);\n\n  \tc = floor(c * 255.0 + 0.5) / 255.0;\n    c *= QUANTIZATION;\n\n    c -= step(mod(uv.x, 1.0 / 4.0), 0.0025);\n    c -= step(mod(uv.y, 1.0 / 6.0), 0.0025);\n\n    fragColor = c;\n}","name":"Image","description":"","type":"image"}]}