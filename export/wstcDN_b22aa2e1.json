{"ver":"0.1","info":{"id":"wstcDN","date":"1600979071","viewed":1231,"name":"Mandelbulb Ray Marching","username":"kylehovey","description":"SDF found here: http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["fractal","ray","mandelbulb","marching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 100.0\n#define MAX_STEPS 200\n#define EPSILON 0.0001\n\n#define Power 3.0\n\nfloat SDF(vec3 pos, out int steps) {\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 20 ; i++) {\n\t\tr = length(z);\n        steps = i;\n\t\tif (r>4.0) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\n\treturn 0.5*log(r)*r/dr;\n}\n\nvec3 normal(vec3 point) {\n  vec2 e = vec2(EPSILON, 0.0);\n  int steps = 0;\n\n  return normalize(\n      SDF(point, steps) - vec3(\n        SDF(point + e.xyy, steps),\n        SDF(point + e.yxy, steps),\n        SDF(point + e.yyx, steps)\n      )\n  );\n}\n\nfloat trace(vec3 ro, vec3 rd, out int steps) {\n  float depth = 0.0;\n\n  for (int i = 0; i < MAX_STEPS; ++i) {\n    float dist = SDF(ro + depth * rd, steps);\n\n    if (dist < EPSILON) return depth;\n\n    depth += dist;\n\n    if (depth > MAX_DIST) return MAX_DIST;\n  }\n\n  return MAX_DIST;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 xy = fragCoord - iResolution.xy / 2.0;\n  vec3 ro = vec3(0.0, 0.5 * sin(iTime), 2.0 + sin(iTime / 3.0));\n  vec3 rd = normalize(vec3(xy, -iResolution.y / tan(radians(50.0) / 2.0)));\n  int steps = 0;\n\n  float dist = trace(ro, rd, steps);\n\n  if (dist < MAX_DIST) {\n    fragColor = vec4(vec3(clamp(float(steps) / 20.0, 0.0, 1.0)), 1.0);\n\n    return;\n  }\n\n  fragColor = vec4(vec3(0.0), 1.0);\n}","name":"Image","description":"","type":"image"}]}