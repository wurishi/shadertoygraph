{"ver":"0.1","info":{"id":"ssBGDV","date":"1618065596","viewed":102,"name":"ShaderTest_Naletov","username":"TPDed","description":"My test\n","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["lights"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv) / float(iFrame + 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float INF = 1e10;\nconst float EPSILON = 0.0000001;\nconst vec3 CAMERA_POS = vec3(7, 3, -8);\n\nvec3 LIGHT1_POS = vec3(2, 2.5, 2);\nconst float LIGHT1_RADIUS = 0.4;\nconst vec3 LIGHT1_COLOR = vec3(1, 1, 0);\n\nvec3 LIGHT2_POS = vec3(0, 2.5, -3);\nconst float LIGHT2_RADIUS = 0.2;\nconst vec3 LIGHT2_COLOR = vec3(0, 1.0, 1);\n\nvec3 LIGHT3_POS = vec3(-2, 2.2, 2);\nconst float LIGHT3_RADIUS = 0.3;\nconst vec3 LIGHT3_COLOR = vec3(1, 0, 1);\nvec3 randDir;\n\nconst int EMISSION = 0;\nconst int DIFFUSE = 1;\nconst int REFLECTION = 2;\nconst int REFRACTION = 3;\n\nconst float GLASS_N = 1.5;\nconst float AIR_N = 1.0;\n\n\n\nfloat snoise(vec3 uv, float res)\n{\n\tconst vec3 s = vec3(1e0, 1e2, 1e4);\n\t\n\tuv *= res;\n\t\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n\t\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\n\t\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\t\n\tvec4 r = fract(sin(v*1e-3)*1e5);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-3)*1e5);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\treturn mix(r0, r1, f.z)*2.-1.;\n}\n\n\nfloat tracePlane(vec3 pos, vec3 dir, out vec3 normal) {\n    float t = (-1.2 - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    \n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) >= 60.0) {\n        return INF;\n    }\n    normal = vec3(0, 1, 0);\n    return t;\n}\n\n\nfloat traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal) {\n    float a = dot(dir, dir);\n    float b = dot(pos, dir);\n    float c = dot(pos, pos) - r * r;\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    float t = -b - sqrt(D);\n    if (t > 0.0) {\n        normal = normalize(pos + t * dir);\n        return t;\n    }\n    t = -b + sqrt(D);\n    if (t < 0.0) {\n        return INF;\n    }\n    normal = normalize(pos + t * dir);\n    return t;\n}\n\n\nfloat traceCylinder(vec3 pos, vec3 dir, out vec3 normal) {\n    float t = (-1.0 - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) < 2.5) {\n        normal = vec3(0, 1, 0);\n        return t;\n    }\n    float a = dot(dir.xz, dir.xz);\n    float b = dot(pos.xz, dir.xz);\n    float c = dot(pos.xz, pos.xz) - 2.5;\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    t = (-b - sqrt(D)) / a;\n    if (t > 0.0) {\n        worldPos = t * dir + pos;\n        if (worldPos.y <= -1.0) {\n            normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n            return t;\n        }\n    }\n    t = (-b + sqrt(D)) / a;\n    if (t < 0.0) {\n        return INF;\n    }\n    worldPos = t * dir + pos;\n    if (worldPos.y <= -1.0) {\n        normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n        return t;\n    }\n    return INF;\n}\n\n\nfloat traceTriangle(vec3 pos, vec3 dir, vec3 ed1,vec3 ed2, vec3 ed3, out vec3 normal)\n{\n    vec3 edge1 = ed2 - ed1;\n    vec3 edge2 = ed3 - ed1;\n    vec3 h = cross(dir,edge2);\n    float a = dot(edge1,h);\n    if (a > -EPSILON && a < EPSILON)\n        return INF;\n    float f = 1.0/a;\n    vec3 s = pos - ed1;\n    float u = f * dot(s,h);\n    if (u < 0.0 || u > 1.0)\n        return INF;\n    vec3 q = cross(s,edge1);\n    float v = f * dot(dir,q);\n    if (v < 0.0 || u + v > 1.0)\n        return INF;\n    float t = f * dot(edge2,q);\n    if (t > EPSILON) \n    {\n        normal = normalize(cross(edge1,edge2));\n        if(dot(normal, dir) <0.0){\n            normal = -normal;\n        }\n        return t;\n    }\n    else \n        return INF;\n}\n\n\nfloat traceFireball(vec3 pos, vec3 dir, float r, out vec3 normal){\n    float a = dot(dir, dir);\n    float b = dot(pos, dir);\n    float c = dot(pos, pos) - (r+randDir.x*0.6) * (r+randDir.x*0.6);\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    float t = -b - sqrt(D);\n    if (t > 0.0) {\n        normal = normalize(pos + t * dir);\n        return t;\n    }\n    t = -b + sqrt(D);\n    if (t < 0.0) {\n        return INF;\n    }\n    normal = normalize(pos + t * dir);\n    return t;\n}\n\n\nbool isShadowFireball(vec3 pos, vec3 target) {\n    vec3 dir = target - pos;\n    float dist = length(dir);\n    dir /= dist;\n    vec3 cylNorm;\n    float cylT = traceCylinder(pos, dir, cylNorm);\n    return (cylT < dist);\n}\n\n\nbool isShadow(vec3 pos, vec3 target) {\n    vec3 dir = target - pos;\n    float dist = length(dir);\n    dir /= dist;\n    vec3 v0,v1,v2;\n    vec3 triangle1Norm;\n    v0 = vec3( -1, -1.0, 1);\n    v1 = vec3(-1, -1.0, -1);\n    v2 = vec3( 0,  2, 0);\t\n    float triangle1 = traceTriangle(pos, dir, v0,v1,v2,triangle1Norm);\n    if (triangle1 < dist)\n        return true;\n\n    vec3 triangle2Norm;\n    v0 = vec3( -1, -1.0, 1);\n    v1 = vec3(1, -1.0, 1);\n    v2 = vec3( 0,  2, 0);\t\n    float triangle2 = traceTriangle(pos, dir, v0,v1,v2,triangle2Norm);\n    if (triangle2 < dist)\n        return true;\n\n    vec3 triangle3Norm;\n    v0 = vec3(1, -1.0, -1);\n    v1 = vec3( 0,  2, 0);\n    v2 = vec3( 1, -1.0, 1);\n    float triangle3 = traceTriangle(pos, dir, v0,v1,v2,triangle3Norm);\n    if (triangle3 < dist)\n        return true;\n\n    vec3 triangle4Norm;\n    v0 = vec3( -1, -1.0, -1);\n    v1 = vec3(1, -1.0, -1);\n    v2 = vec3( 0,  2, 0);\n    float triangle4 = traceTriangle(pos, dir, v0,v1,v2,triangle4Norm);\n    if (triangle4 < dist)\n        return true;\n\n    vec3 triangle5Norm;\n    v0 = vec3(1, -0.9999, -1);\n    v1 = vec3( -1, -0.9999, -1);\n    v2 = vec3( 1,  -0.9999, 1);\n    float triangle5 = traceTriangle(pos, dir, v0,v1,v2,triangle5Norm);\n    if (triangle5 < dist)\n        return true;\n        \n    vec3 triangle6Norm;\n    v0 = vec3(-1, -0.9999, 1);\n    v1 = vec3( 1,  -0.9999, 1);\n    v2 = vec3( -1, -0.9999, -1);\n    float triangle6 = traceTriangle(pos, dir, v0,v1,v2,triangle6Norm);\n    if (triangle6 < dist)\n        return true;\n        \n    vec3 cylNorm;\n    float cylT = traceCylinder(pos, dir, cylNorm);\n    return (cylT < dist);\n}\n\n\nvec3 computeLight(vec3 pos, vec3 color, vec3 normal) {\n    vec3 toLight1 = LIGHT1_POS - pos;\n    float distSqToLight1 = dot(toLight1, toLight1);\n    float att1 = isShadow(pos, LIGHT1_POS + randDir * LIGHT1_RADIUS) ? 0.0 : 15.0f / distSqToLight1;\n    \n    vec3 toLight2 = LIGHT2_POS - pos;\n    float distSqToLight2 = dot(toLight2, toLight2);\n    float att2 = isShadow(pos, LIGHT2_POS + randDir * LIGHT2_RADIUS) ? 0.0 : 20.0f / distSqToLight2;\n    \n    vec3 toLight3 = LIGHT3_POS - pos;\n    float distSqToLight3 = dot(toLight3, toLight3);\n    float att3 = isShadow(pos, LIGHT3_POS + randDir * LIGHT3_RADIUS) ? 0.0 : 10.0f / distSqToLight3;\n    \n    vec3 toFireball = vec3(0.0,0.0,0.0) - pos;\n    float distSqToFireball = dot(toFireball, toFireball);\n    float att4 = isShadowFireball(pos, vec3(0.0,0.0,0.0) + randDir * 0.2) ? 0.0: 10.0f / distSqToFireball;\n    \n    return color * (\n        max(0.0, dot(normal, normalize(toLight1))) * att1 * LIGHT1_COLOR\n        + max(0.0, dot(normal, normalize(toLight2))) * att2 * LIGHT2_COLOR\n        + max(0.0, dot(normal, normalize(toLight3))) * att3 * LIGHT3_COLOR\n        + texture(iChannel1, normal).rgb * 0.1\n        + max(0.0, dot(normal, normalize(toFireball))) * att4 * vec3(1,1,0.4)*0.4\n    );\n}\n\n\nvec3 refraction(vec3 v, vec3 normal, float n1, float n2) {\n    if (dot(v, normal) < 0.0) {\n        normal = -normal;\n    }\n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tang = normalize(v - cosA * normal);\n    float sinB = sinA / n2 * n1;\n    if (sinB > 1.0) {\n        return reflect(v, normal);\n    }\n    float cosB = sqrt(1.0 - sinB * sinB);\n    return sinB * tang + cosB * normal;\n}\n\n\nfloat pow2(float x) {\n    return x * x;\n}\n\n\nfloat rand(float frame)\n{\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    randDir = normalize(randVals - 0.5);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randVals.xy - 0.5)) / iResolution.x;\n    vec3 front = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    vec3 viewVec = normalize(front + right * uv.x + up * uv.y);\n    \n    vec3 LIGHT1_POS = vec3(2, 2.5, 2) +  randVals*0.06;\n    vec3 LIGHT2_POS = vec3(0, 2.5, -3) + randVals*0.06;\n    vec3 LIGHT3_POS = vec3(-2, 2.2, 2) + randVals*0.06;\n    \n    vec3 curPos = CAMERA_POS;\n    vec3 curDir = viewVec;\n    float n1 = AIR_N;\n    float GLASS_R = pow2(AIR_N - GLASS_N) / pow2(AIR_N + GLASS_N);\n    \n    vec3 colorMult = vec3(1, 1, 1);\n    \n    for (int i = 0; i < 10; ++i) {\n        float t = INF;\n        int materialType;\n        vec3 color;\n        vec3 normal;\n        float nEnter = AIR_N;\n        \n        //стол\n        vec3 planeNorm;\n        float planeT = tracePlane(curPos, curDir, planeNorm);\n        if (planeT < t) {\n            t = planeT;\n            materialType = DIFFUSE;\n            vec3 worldPos = t * curDir + curPos;\n            color = texture(iChannel0, worldPos.xz * 0.1).rgb;\n            normal = planeNorm;\n        }\n        \n        //источники света\n        vec3 light1Norm;\n        float light1 = traceSphere(curPos - LIGHT1_POS, curDir, LIGHT1_RADIUS, light1Norm);\n        if (light1 < t) {\n            t = light1;\n            materialType = EMISSION;\n            color = LIGHT1_COLOR;\n            normal = light1Norm;\n        }\n        vec3 light2Norm;\n        float light2 = traceSphere(curPos - LIGHT2_POS, curDir, LIGHT2_RADIUS, light2Norm);\n        if (light2 < t) {\n            t = light2;\n            materialType = EMISSION;\n            color = LIGHT2_COLOR;\n            normal = light2Norm;\n        }\n        vec3 light3Norm;\n        float light3 = traceSphere(curPos - LIGHT3_POS, curDir, LIGHT3_RADIUS, light3Norm);\n        if (light3 < t) {\n            t = light3;\n            materialType = EMISSION;\n            color = LIGHT3_COLOR;\n            normal = light3Norm;\n        }\n        \n        //пирамида\n        vec3 v0,v1,v2;\n        vec3 triangle1Norm;\n        v0 = vec3(-1, -1.0, -1);\n        v1 = vec3( -1, -1.0, 1);\n        v2 = vec3( 0,  2, 0);\t\n        float triangle1 = traceTriangle(curPos, curDir, v0,v1,v2,triangle1Norm);\n        if (triangle1 < t) {\n            t = triangle1;\n            normal = triangle1Norm;\n            if (randVals.x < GLASS_R*20.0) {\n                materialType = REFLECTION;\n            } else {\n                colorMult *= vec3(0.5, 0.5, 0.2)*2.0;\n                materialType = REFRACTION;\n                if (dot(curDir, normal) > 0.0) {\n                    nEnter = AIR_N;\n                } else {\n                    nEnter = GLASS_N;\n                }\n            }\n        }\n        vec3 triangle2Norm;\n        v0 = vec3(1, -1.0, 1);\n        v1 = vec3( 0,  2, 0);\n        v2 = vec3( -1, -1.0, 1);\t\n        float triangle2 = traceTriangle(curPos, curDir, v0,v1,v2,triangle2Norm);\n        if (triangle2 < t) {\n            t = triangle2;\n            normal = triangle2Norm;\n            if (randVals.x < GLASS_R*20.0) {\n                materialType = REFLECTION;\n            } else {\n                colorMult *= vec3(0.5, 0.5, 0.2)*2.0;\n                materialType = REFRACTION;\n                if (dot(curDir, normal) > 0.0) {\n                    nEnter = AIR_N;\n                } else {\n                    nEnter = GLASS_N;\n                }\n            }\n        }\n        vec3 triangle3Norm;\n        v0 = vec3( 0,  2, 0);\n        v1 = vec3(1, -1.0, -1);\n        v2 = vec3( 1, -1.0, 1);\n        float triangle3 = traceTriangle(curPos, curDir, v0,v1,v2,triangle3Norm);\n        if (triangle3 < t) {\n            t = triangle3;\n            normal = triangle3Norm;\n            if (randVals.x < GLASS_R*20.0) {\n                materialType = REFLECTION;\n            } else {\n                colorMult *= vec3(0.5, 0.5, 0.2)*2.0;\n                materialType = REFRACTION;\n                if (dot(curDir, normal) > 0.0) {\n                    nEnter = AIR_N;\n                } else {\n                    nEnter = GLASS_N;\n                }\n            }\n        }\n        vec3 triangle4Norm;\n        v0 = vec3( -1, -1.0, -1);\n        v1 = vec3(1, -1.0, -1);\n        v2 = vec3( 0,  2, 0);\n        float triangle4 = traceTriangle(curPos, curDir, v0,v1,v2,triangle4Norm);\n        if (triangle4 < t) {\n            t = triangle4;\n            normal = triangle4Norm;\n            if (randVals.x < GLASS_R*20.0) {\n                materialType = REFLECTION;\n            } else {\n                colorMult *= vec3(0.5, 0.5, 0.2)*2.0;\n                materialType = REFRACTION;\n                if (dot(curDir, normal) > 0.0) {\n                    nEnter = AIR_N;\n                } else {\n                    nEnter = GLASS_N;\n                }\n            }\n        }\n        vec3 triangle5Norm;\n        v0 = vec3(1, -0.9999, -1);\n        v1 = vec3( -1, -0.9999, -1);\n        v2 = vec3( 1,  -0.9999, 1);\n        float triangle5 = traceTriangle(curPos, curDir, v0,v1,v2,triangle5Norm);\n        if (triangle5 < t) {\n            t = triangle5;\n            normal = triangle5Norm;\n            if (randVals.x < GLASS_R*20.0) {\n                materialType = REFLECTION;\n            } else {\n                colorMult *= vec3(0.5, 0.5, 0.2)*2.0;\n                materialType = REFRACTION;\n                if (dot(curDir, normal) > 0.0) {\n                    nEnter = AIR_N;\n                } else {\n                    nEnter = GLASS_N;\n                }\n            }\n        }\n        vec3 triangle6Norm;\n        v0 = vec3(-1, -0.9999, 1);\n        v1 = vec3( 1,  -0.9999, 1);\n        v2 = vec3( -1, -0.9999, -1);\n        float triangle6 = traceTriangle(curPos, curDir, v0,v1,v2,triangle6Norm);\n        if (triangle6 < t) {\n            t = triangle6;\n            normal = triangle6Norm;\n            if (randVals.x < GLASS_R*20.0) {\n                materialType = REFLECTION;\n            } else {\n                colorMult *= vec3(0.5, 0.5, 0.2)*2.0;\n                materialType = REFRACTION;\n                if (dot(curDir, normal) > 0.0) {\n                    nEnter = AIR_N;\n                } else {\n                    nEnter = GLASS_N;\n                }\n            }\n        }\n        \n        //подставка\n        vec3 cylNorm;\n        float cyl = traceCylinder(curPos, curDir, cylNorm);\n        if (cyl < t) {\n            t = cyl;\n            materialType = DIFFUSE;\n            vec3 worldPos = t * curDir + curPos;\n            color = texture(iChannel2, worldPos.xz * worldPos.y).rgb;\n            normal = cylNorm;\n        }\n        \n        //fireball\n        float radius\t\t= 0.055;\n        float invRadius \t= 1.0/radius;\n        vec3 orange\t\t\t= vec3( 0.8, 0.65, 0.3 )/1.5;\n        vec3 orangeRed\t\t= vec3( 0.8, 0.35, 0.1 )/1.5;\n        float aspect\t= iResolution.x/iResolution.y;\n        vec2 uv_c\t\t\t= fragCoord.xy / iResolution.xy;\n        vec2 p \t\t\t= -0.5 + uv_c;\n        p.x *= aspect;\n        float fade\t\t= pow( length( 5.0 * p ), 0.8 );\n        float fVal1\t\t= 0.8 - fade;\n        float fVal2\t\t= 1.1 - fade;\n        float angle\t\t= atan( p.x, p.y )/6.2832;\n        float dist\t\t= length(p);\n        vec3 coord\t\t= vec3( angle, dist,  0);\n        for( int j=1; j<=10; j++ ){\n            float power = pow( 2.0, float(j + 1) );\n            fVal1 += ( 0.5 / power ) * snoise( coord, ( power * ( 10.0 ) ) );\n            fVal2 += ( 0.5 / power ) * snoise( coord, ( power * ( 25.0 ) ) );\n        }\n        float corona\t\t= pow( fVal1 * max( 1.1 - fade, 0.0 ), 2.0 ) * 20.0;\n        corona\t\t\t\t+= pow( fVal2 * max( 1.1 - fade, 0.0 ), 2.0 ) * 20.0;\n        vec3 sphereNormal \t= vec3( 0.0, 0.0, 1.0 );\n        vec3 dir \t\t\t= vec3( 0.0 );\n        vec3 center\t\t\t= vec3( 0.5, 0.5, 1.0 );\n        vec3 starSphere\t\t= vec3( -0.3 );\n        vec2 sp = -1.0 + 2.0 * uv_c;\n        sp.x *= aspect;\n        sp *= ( 6.0);\n        float r = dot(sp,sp);\n        float f = (1.0-sqrt(abs(1.0-r)))/(r);\n        if( dist < radius ){\n            corona\t\t\t*= pow( dist * invRadius, 24.0 );\n            vec2 newUv;\n            newUv.x = sp.x*f;\n            newUv.y = sp.y*f;\n\n            vec3 texSample \t= texture( iChannel0, newUv ).rgb;\n            vec2 starUV\t\t= newUv;\n            starSphere\t\t= texture( iChannel0, starUV ).rgb;\n        } \n        float starGlow\t= min( max( 1.0 - dist , 0.0 ), 1.0 );\n        \n        vec3 fireballNorm;\n        float fireball = traceFireball(curPos, curDir, 0.25, fireballNorm);\n        if (fireball < t) {\n            t = fireball;\n            normal = fireballNorm;\n            color = f * 1.2  * orange + starSphere*1.5+ 1.5*starGlow * orangeRed + corona * orange;\n            materialType = EMISSION;\n        }\n        \n        //отрисовка \n        if (t != INF) {\n            vec3 worldPos = t * curDir + curPos;\n            fragColor = texture(iChannel0, worldPos.xz);\n            if (materialType == EMISSION) {\n                fragColor.rgb = color * colorMult;\n                break;\n            } else if (materialType == DIFFUSE) {\n                fragColor.rgb = computeLight(worldPos, color, normal) * colorMult;\n                break;\n            } else if (materialType == REFLECTION) {\n                curDir = reflect(curDir, normal);\n                curPos = worldPos + curDir * 1e-5;\n            } else if (materialType == REFRACTION) {\n                curDir = refraction(curDir, normal, n1, nEnter);\n                curPos = worldPos + curDir * 1e-5;\n                n1 = nEnter;\n            }\n        } else {\n            fragColor.rgb = texture(iChannel1, curDir).rgb * colorMult * 1.5;\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}","name":"Buffer B","description":"","type":"buffer"}]}