{"ver":"0.1","info":{"id":"XtGBDW","date":"1542468823","viewed":1505,"name":"Inverse Hilbert Curve","username":"Wunkolo","description":"Projection of a 2D point onto a Hilbert Curve","likes":33,"published":1,"flags":0,"usePreview":0,"tags":["projection","curve"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define LEVEL 15U\n#define WIDTH ( (1U << LEVEL) )\n#define AREA ( WIDTH * WIDTH )\n\nfloat HilbertIndex( uvec2 Position )\n{   \n    uvec2 Regions;\n    uint Index = 0U;\n    for( uint CurLevel = WIDTH/2U; CurLevel > 0U; CurLevel /= 2U )\n    {\n        uvec2 Region = uvec2(greaterThan((Position & uvec2(CurLevel)), uvec2(0U)));\n        Index += CurLevel * CurLevel * ( (3U * Region.x) ^ Region.y);\n        if( Region.y == 0U )\n        {\n            if( Region.x == 1U )\n            {\n                Position = uvec2(WIDTH - 1U) - Position;\n            }\n            Position.xy = Position.yx;\n        }\n    }\n    \n    return float(Index) / float(AREA);\n}\n\nvec4 mirrored(vec4 v)\n{\n    vec4 Mod = mod(v, 2.0);\n    return mix(Mod, 2.0 - Mod, step(1.0, Mod));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 UV = fragCoord/iResolution.xy;\n    UV.x *= iResolution.x / iResolution.y;\n    UV.x -= fract((iResolution.x ) / iResolution.y) / 2.0;\n   \n    uvec2 FragCoord = uvec2( UV * float(WIDTH) );\n    float Index = HilbertIndex( FragCoord );\n    \n    Index += iTime / 12.0;\n\tvec2 Border = smoothstep(vec2(0.0), vec2(0.0) + vec2(0.01), UV) -\n        smoothstep(vec2(1.0) - vec2(0.01), vec2(1.0), UV);\n    fragColor = mirrored(\n        vec4(\n            Index * 7.0,\n            Index * 11.0,\n            Index * 13.0,\n            1.0\n        )\n\t) * (Border.x * Border.y);\n}","name":"Image","description":"","type":"image"}]}