{"ver":"0.1","info":{"id":"WslSRH","date":"1550603309","viewed":537,"name":"Blobacity","username":"teraspora","description":"Wild blobs","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["blobs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tBlobacity\n\tAuthor: John Lynch\n\tDate: Feb. 2019\n*/\n\n#define PI 3.14159265\nvec4 img;\nvec3 black = vec3(0.);\n\n// Some functions adapted from Github - \n// https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\n\nvec3 hue2rgb(float hue)\n{\n    float R = abs(hue * 6. - 3.) - 1.;\n    float G = 2. - abs(hue * 6. - 2.);\n    float B = 2. - abs(hue * 6. - 4.);\n    return clamp(vec3(R,G,B), 0., 1.);\n}\n\n// Converts a value from linear RGB to HCV (Hue, Chroma, Value)\nvec3 rgb2hcv(vec3 rgb) {\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (rgb.g < rgb.b) ? vec4(rgb.bg, -1.0, 2.0/3.0) : vec4(rgb.gb, 0.0, -1.0/3.0);\n    vec4 Q = (rgb.r < P.x) ? vec4(P.xyw, rgb.r) : vec4(rgb.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6. * C + 1.e-10) + Q.z);\n    return vec3(H, C, Q.x);\n}\n\n// Converts from HSL to linear RGB\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb = hue2rgb(hsl.x);\n    float C = (1. - abs(2. * hsl.z - 1.)) * hsl.y;\n    return (rgb - 0.5) * C + hsl.z;\n}\n\n// Converts from linear rgb to HSL\nvec3 rgb2hsl(vec3 rgb) {\n    vec3 HCV = rgb2hcv(rgb);\n    float L = HCV.z - HCV.y * 0.5;\n    float S = HCV.y / (1. - abs(L * 2. - 1.) + 1.e-10);\n    return vec3(HCV.x, S, L);\n}\n\n// Colour fns.:\nfloat hue(vec3 col) {\n    return rgb2hsl(col).s;\n}\n\nvec3 changeHue(vec3 col, float newHue) {\n    vec3 colHSL = rgb2hsl(col);\n    colHSL.s = newHue;\n    return hsl2rgb(colHSL);\n}\n    \nfloat lightness(vec3 col) {\n    return rgb2hsl(col).b;\n}\n\nvec3 changeLightness(vec3 col, float newLightness) {\n    vec3 colHSL = rgb2hsl(col);\n    colHSL.p = newLightness;\n    return hsl2rgb(colHSL);\n}\n    \nvec3 saturate(vec3 col) {\n    vec3 colHSL = rgb2hsl(col);\n    colHSL.t = 1.0;\n    return hsl2rgb(colHSL);    \n}\n\nvec2 nmouse() {\n    return iMouse.xy / iResolution.xy;\n}\n\nfloat om(float x) {     // one minus x\n    return 1. - x;\n}\n\nvec3 om(vec3 v) {       // one minus v\n    return 1. - v;\n}\n\nfloat op(float x) {     // one plus x \n    return 1. + x;\n}\n\n// Normalised trig fns.:\nfloat nsin(float x) {\n    return op(sin(x)) * 0.5;\n}\n\nfloat ncos(float x) {\n    return op(cos(x)) * 0.5;\n}\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 polar(float r, float phi) {\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\nvec2 times(vec2 v, vec2 w) {\n    return vec2(v.x * w.x - v.y * w.y, v.x * w.y + v.y * w.x);\n}\n\nvec2 rotate(vec2 v, float phi) {\n    return times(v, polar(1.0, phi)) ;\n}\n\nvec2 trt(vec2 v, vec2 offset, float phi) {\n\treturn rotate(v - offset, phi) + offset;\n}\n\nfloat sec(float theta) {\n    return 1. / cos(theta);\n}\n\nfloat iden(float x) {\n    return x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    float scale = exp2(nmouse().x * 6.) / 4.;\n    vec3 col;\n    float t = iTime / 2.;\n    vec2 asp = vec2(iResolution.x / iResolution.y, 1.);\n    vec2 uv = fragCoord.xy / iResolution.yy - asp * .5;\n    float amp = 0.04; // * sin(t);\n    float freq = 5.;\n    float freqx = floor(3. + 32. * nsin(t / 24.)); // + mod(floor(iTime / 16.), 9.);\n    \n    float uvy = uv.y;\n    col = mix(vec3(.0, .9, .6), vec3(.999, .3, .2), nsin(pow(length(uv), exp2(16. * nsin(t / 4.) * length(uv))))) / 2.;\n    float cdelta = mod(iTime, 15.) / 15.;\n    col = changeHue(col, fract(hue(col) + cdelta)); \n   \n    vec2 offset = vec2(sin(t) / 2., -cos(t) / 2.) * asp * 0.75 * nsin(mod(t / 5., 64.));\t\t// Path: Ellipse\n    float edge = 0.3 + 0.03 * sin(arg((uv - offset)) * freqx)  + 0.03 * sin(arg(uv) * freqx) + 0.05 * sin(t / 5.);\n    float dist = distance(uv, offset);\n    if (dist < edge) {\n        uv = trt(uv, offset, PI / 4. + t);\n        col = vec3(.9, .3, .2);\n        if (dist > edge - .04) {\n            col = black;\n        }\n        if (dist < edge * .3) {\n            col = vec3(.0, .7, .8);\n            if (dist > edge * .5 - .1) {\n                col = black;\n            }\n        }            \n    } \n    float edge2 = 0.2 + 0.1 * sin(arg((uv - offset)) * freqx)  + 0.03 * sin(arg(uv) * freqx) + 0.05 * sin(t / 5.);\n    float phi = t;\n    float a = 1.9;\n    offset = vec2(a * sin(phi), a * sin(phi) * cos(phi)) * asp * 0.75 * nsin(mod(t / 5., 64.));     // Path: Gerono lemniscate\n    dist = distance(uv, offset);\n    if (dist < edge2) {\n        uv = trt(uv, offset, PI / 4. + t);\n        col += vec3(.9, .3, .2).gbr;\n        // col = texture2D(u_tex0, uv).rgb;\n        if (dist > edge2 - .02) {\n            col = black;\n        }\n        if (dist < edge2 * .33) {\n            col = vec3(.8, .3, .3).gbr;\n            if (dist > edge2 * .33 - .01) {\n                col = black;\n            }\n        }            \n    } \n    \n    cdelta = mod(iTime, 32.) / 32.;\n    col = changeHue(col, fract(hue(col) + cdelta)); \n    col *= pow(col, vec3(.45454545));\n    col = saturate(col);\n    fragColor = vec4(col,1.0);\n}  ","name":"Image","description":"","type":"image"}]}