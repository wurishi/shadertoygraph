{"ver":"0.1","info":{"id":"lf2SRK","date":"1706570663","viewed":150,"name":"Voronoi Vogel Golden Spiral","username":"chronos","description":" A version of the forked shader showing the voronoi diagram of the Vogel Spiral sample points.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","spiral","bokeh","angle","discs","kernel","fibonacci","sunflower","diagram","vogel","phyllotaxis","spread","golden","layout","ratio"],"hasliked":0,"parentid":"XfSXzK","parentname":"Gaussian Vogel Golden Spiral"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n    /////////////////////////////////////////////////\n    Voronoi Vogel Golden Spiral by chronos\n    /////////////////////////////////////////////////\n    \n    A version of the forked shader showing the voronoi diagram of the Vogel Spiral sample points.\n    Can either use standard euclidean distance or a modified distance metric, more like the\n    Mahalanobis distance (https://en.wikipedia.org/wiki/Mahalanobis_distance).\n    \n    \n    // Forked shader description:\n    -----------------------------------------------------------\n    \n    Vogel golden spiral with brightness scaled by a normal distribution, like a blur kernel, and sample areas scaled to fit total area.\n    This version modifies the forked shader by introducing non-isotropic 'kernel' shape as well as 'sample-regions' themselves.\n    Can also switch between oval/disc sample regions, and gaussian ones.\n    Finally, added optional colors for visualization.\n    \n*/\n\nconst float PI     = 3.14159265;\nconst float TWO_PI = 6.283185307; // aka Tau\nconst float PHI = (1. + sqrt(5.))/2.; // Golden ratio\n\nconst float golden_angle = TWO_PI * (1. - 1./PHI);\n//const float golden_angle = PI * (3. - sqrt(5.));\n\nfloat sRGBencode(float C_linear) { return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear); }\nvec3 sRGBencode(vec3 C_linear) { C_linear = clamp(C_linear, 0., 1.); return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z)); }\nfloat sRGBdecode(float C_sRGB) { return C_sRGB > 0.04045 ? (pow((C_sRGB + 0.055)/1.055, 2.4) ) : (C_sRGB / 12.92); }\nvec3 sRGBdecode(vec3 C_sRGB) { return vec3(sRGBdecode(C_sRGB.x), sRGBdecode(C_sRGB.y), sRGBdecode(C_sRGB.z)); }\n\n// Disable to use circular shapes\n#define USE_NONISOTROPIC_SAMPLES 1\n\n#define USE_COLOR 1\n\n#define NUM_COLORS 12\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 mouse = (2. * iMouse.xy - iResolution.xy) / iResolution.y;\n\n    if (length(iMouse.xy) < 10.) mouse.xy = vec2(cos(iTime), sin(iTime)) + 0.1;\n\n    float ps = 2./ iResolution.y;\n\n    vec3 color = vec3(0);\n\n    \n    float num_samples = 150. * (mouse.y + 1.);\n    float rcp_num_samples = 1./num_samples;\n    \n    \n    // Find target disc area.\n    // Regardless of derivation the area should scale with the reciprocal sqare root of the number of samples.\n    // You can see the derivation in the forked shader: https://www.shadertoy.com/view/4fBXRG\n    // The principle is the same in all cases.\n    #if 1\n    float disc_radius = sqrt(2. / (num_samples * PI));\n    #elif 0\n    float disc_radius = 1. / (sqrt(num_samples) - 1.);\n    #else\n    float disc_radius = sqrt(1. / num_samples);\n    #endif\n    \n    float angle = iTime * .3;\n    vec2 scale = vec2(1,.5);\n    \n    vec2 cs = vec2(cos(angle), sin(angle));\n    mat2 S = mat2(scale.x, 0, 0, scale.y);\n    mat2 R = mat2(cs.x, cs.y, -cs.y, cs.x);\n    \n    mat2 RS = R * S;\n    \n    #if !USE_NONISOTROPIC_SAMPLES\n    disc_radius *= sqrt(determinant(S));\n    #endif\n    \n    //mat2 Cov = RS * transpose(RS);\n    float mindist = 9e9;\n    vec3 sample_color = vec3(0);\n    float alpha = 0.;\n    for(float i = .5; i < num_samples; i++) // Samples half-integers between 0 and num_samples\n    {\n        float t = i * rcp_num_samples;\n        \n        float r = sqrt(t);\n        float th = golden_angle * i;\n        \n        vec2 pos = r * vec2(cos(th), sin(th));\n        \n        #if USE_NONISOTROPIC_SAMPLES\n        float d = length( R * (pos - inverse(RS)*uv));\n        #else\n        pos = RS * pos;\n        float d = length( pos - uv);\n        #endif\n        \n        if(d < mindist)\n        {\n            mindist = d;\n            alpha = 1.;\n            sample_color = (.5 + .45*cos( 2. * PI * (fract(i/float(NUM_COLORS))+vec3(0.03, 0.2,.3)) )) * 10.;\n        }\n    }\n    mat2 invRS = inverse(RS);\n    color = mix(color, sample_color, \n        alpha \n        * exp(-dot(mindist,mindist)/2. /disc_radius/ disc_radius)/(2. * PI)\n    );\n\n    #if USE_COLOR\n    color = tanh(color);\n    #endif\n\n    color = sRGBencode(color);\n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}