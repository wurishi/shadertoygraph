{"ver":"0.1","info":{"id":"4sjfzw","date":"1500311108","viewed":531,"name":"Volumetric Raymarcher","username":"jgkling","description":"Volumetric raymarcher, single scattering.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based heavily on: https://is.muni.cz/th/396277/fi_m/thesis.pdf\n// Inspired by: https://www.shadertoy.com/view/XslGRr\n\nvec3 sunDirection = normalize(vec3(3.0, 2.5, -1.0));\nfloat invPi = 0.31830988618;\n\n// 3D Noise by IQ\nfloat Noise3D( in vec3 pos )\n{\n    vec3 p = floor(pos);\n    vec3 f = fract(pos);\n    f = f * f * (3.0 - 2.0 * f);\n    vec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n    vec2 rg = textureLod( iChannel0, (uv + 0.5) / 256.0, 0.0).yx;\n    return -1.0 + 2.0 * mix( rg.x, rg.y, f.z );\n}\n\nfloat ComputeFBM( in vec3 pos )\n{\n    float amplitude = 0.25;\n    float sum = 0.0;\n    for(int i = 0; i < 3; i++)\n    {\n        sum += Noise3D(pos) * amplitude;\n        amplitude *= 0.2;\n        pos *= 4.0;\n    }\n    sum -= pos.y / 1200.0;\n    sum *= 8.0; // Probably need to tweak this if the raymarching steps/step size are changed\n    return clamp(sum, 0.0, 1.0);\n}\n\n// Henyey-Greenstein\nfloat Phase( in float g, in float theta )\n{\n    return 0.25 * invPi * (1.0 - g * g) / (1.0 + g * g - 2.0 * g * pow(theta, 1.5));\n}\n\nvec3 ShadeBackground( in vec3 rayDirection )\n{\n    vec3 color = vec3(0.0);\n    //vec3 sunDirection = normalize(vec3(cos(iTime), 2.0, sin(iTime)));\n    // Sun\n    float sunDot = clamp(dot(sunDirection, rayDirection), 0.0, 1.0);\n    vec3 sunColor = vec3(1.0, 0.58, 0.3) * 20.0;\n    color += sunColor * pow(sunDot, 17.0);\n    \n    // Sky\n    vec3 skyColor = vec3(0.22, 0.44, 0.58) * 0.65;\n    color += skyColor;\n    \n    return color;\n}\n\nvec4 RaymarchScene( in vec3 origin, in vec3 dir )\n{\n    // Volume properties\n    float scatteringCoeff = 0.5;\n    float t = 0.1;\n    float dt;\n    vec3 pos;\n    vec3 accumColor = vec3(0.0);\n    float transmittance = 1.0;\n    \n    for(int i = 0; i < 50; i++)\n    {\n        pos = origin + t * dir + vec3(0.0, 0.0, -iTime);\n        \n        float density = ComputeFBM(pos);\n        transmittance *= exp(-scatteringCoeff * density * dt);\n        \n        // Evaluate incident lighting here\n        vec3 incidentLight = vec3(0.0);\n        \n        // Compute samples toward light source\n        const float numSamples = 1.0;\n        float stepSize = 0.1;\n        vec3 light = vec3(0.6, 0.55, 0.4) * 50.0;\n        float accumDensity = 0.0;\n        for(float j = 1.0; j <= numSamples; j += 1.0)\n        {\n            accumDensity += ComputeFBM(pos + stepSize * j * sunDirection) * stepSize;\n        }\n        accumDensity /= numSamples;\n        incidentLight = light * exp(-scatteringCoeff * accumDensity * stepSize);\n        \n        accumColor += scatteringCoeff * density * Phase(scatteringCoeff, abs(dot(dir, sunDirection))) * incidentLight * transmittance * dt;\n        \n        if (transmittance <= 0.01)\n        {\n            break;\n        }\n        \n        dt = max(0.04, 0.02 * t);\n        t += dt;\n    }\n    \n    // Shade the sky\n    vec3 backgroundColor = ShadeBackground(dir);\n    \n    return vec4(transmittance * backgroundColor + accumColor, 1.0);\n}\n\nvec3 CastRay( in vec2 sp, in vec3 origin )\n{\n    // Compute local camera vectors\n    vec3 refPoint = origin + vec3(0.0, 0.0, -1.0);\n    vec3 camLook = normalize(refPoint - origin);\n    vec3 camRight = normalize(cross(camLook, vec3(0, 1, 0)));\n    vec3 camUp = normalize(cross(camRight, camLook));\n    \n    vec3 rayPoint = refPoint + sp.x * camRight + sp.y * camUp;\n    return normalize(rayPoint - origin);\n}\n\nvec3 ToneMap( in vec3 color )\n{\n    return 1.0 - exp(-2.0 * color);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenPoint = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    // Compute ray direction\n    vec3 rayOrigin = vec3(0.0, 0.4, 0.0);\n    vec3 rayDirection = CastRay(screenPoint, rayOrigin);\n    \n    // Raymarch the fbm\n    vec4 finalColor = RaymarchScene(rayOrigin, rayDirection);\n    \n    fragColor = vec4(ToneMap(finalColor.xyz), 1.0);\n}","name":"Image","description":"","type":"image"}]}