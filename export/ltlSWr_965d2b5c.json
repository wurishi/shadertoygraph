{"ver":"0.1","info":{"id":"ltlSWr","date":"1435997709","viewed":188,"name":"pulse cell","username":"nexor","description":"bloop.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["noise","cell"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*precision highp float;\n\n//new version, optimized for size and speed by FabriceNeyret2\n\n#define s smoothstep\n\nfloat l, t=iDate.w, T=fract(t);\nvec2 p,m,r;\nmat2 m2 = mat2( 8, -6, 6, 8 )*.2; \n\nfloat N() {\n    m = fract(p);\n    l = dot(p-m,vec2(1,157));  // why p-(p=fract(p)) not working ?\n    p *= m2;\n    m *= m*(3.-m-m);\n#define h(n) fract(sin(n+vec2(0,157))*57.) \n    r = mix( h(l), h(++l),m.x);\n    return mix(r.x,r.y,m.y);\n}\n\nvoid mainImage( out vec4 f, vec2 u ) {\n    u = 14.*u/iResolution.y-vec2(13,7);  \n    T = s(.1,.7,T) + t-T;\n    p = u + 9.*sin(T*.1-t/3.+vec2(1.6,0));\n    f = vec4(4,1,4,1.5)*.1\n        *( N() + N()/2. + N()/4. + N()/8. ); // 2*fbm\n    l =   s( 4.,1.2, length(u) +.7*sin(T*6.3) ) \n        * 4.*(f.a+mod(f.b,.2));\n\tf = 1.-sqrt(\n        \t\t mix( vec4(.2,2,1.3,1)*l, vec4(.5,0,.8,1), l )\n        \t   - mix(f-f, f, s(.0,.005,l))\n               );\n}\n*/\n\n//old version\n#define time iTime\n#define resolution iResolution.xy\n\nconst float pi = 3.14156;\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0;\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); p = m2*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nvec2 tr(vec2 p)\n{\n\t p /= resolution.xy;\n\t p = -1.0+2.0*p;\n\t p.x *= resolution.x/resolution.y;\n\t return p;\n}\n\nvec2 pix(vec2 p, int s)\n{\n\t return floor(p*float(s)+0.5)/float(s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = tr(fragCoord.xy);\n\n    vec2 c = vec2(0.0);\n\n    //c.x = cos(time*0.5)*0.5;\n    //c.y = sin(time*0.5)*0.5;\n\n    //uv = pix(uv,128);\n\n    float t = smoothstep(0.1,0.7,fract(time))+floor(time);\n\n    vec3 bg = vec3(0.2,0.8,0.3);\n    bg *= fbm(uv*8.0 \n              +10.0*vec2(\n                  cos(t*0.1-time*0.35),\n                  sin(t*0.1-time*0.35))\n             );\n\n    vec3 col = vec3(1.0,.65,0.1);\n\n    vec2 v = uv-c;\n    float ang = atan(v.y,v.x);\n    float d = length(v);\n\n    float len =\n        smoothstep(\n            1.0,0.3\n            ,d*1.75\n            +0.175\n            *sin(t*pi*2.0)\n        );\n\n    len *= bg.b+mod(bg.g,0.2);\n    len *= 4.0;\n\n    col *= 2.0*len;\n    col = mix(col,vec3(0.0,0.8,0.5),len);\n\t\t\tcol = mix(col,\n\t\t\tcol-bg.rgg,\n\t\t\tsmoothstep(0.0,0.005,len)\n\t\t\t);\n\n    col = sqrt(col);\n    col = 1.0-col.brg;\n\n\n    fragColor = vec4( col, 1.0 );\n}\n\n\n","name":"Image","description":"","type":"image"}]}