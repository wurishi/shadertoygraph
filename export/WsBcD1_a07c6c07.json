{"ver":"0.1","info":{"id":"WsBcD1","date":"1586907031","viewed":235,"name":"Escher Cubes","username":"ZiMMaBuE","description":"Esheder","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["escher","reproduction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 64\n#define MAX_DIST 20.\n#define EPS 0.001\nconst float PI = acos(-1.0);\n\nmat3 rotX(float angle)\n{\n    return mat3(1,\t0,\t\t\t0,\n               0,\tcos(angle), -sin(angle),\n               0,\tsin(angle), cos(angle));\n}\n\nmat3 rotY(float angle)\n{\n\treturn mat3(cos(angle), 0, sin(angle),\n               0,\t\t\t1, 0,\n               -sin(angle), 0, cos(angle));\n}\n\nfloat sdCube(vec2 pos, float r)\n{\n\tvec2 q = abs(pos) - r;\n\treturn length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat sdCube(vec3 pos, float r)\n{\n\tvec3 q = abs(pos) - r;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat map(vec3 pos)\n{\n    pos = fract(pos)-0.5;\n    \n    float d1 = sdCube(pos, 0.1);\n    float d2 = sdCube(vec2(pos.x, pos.z), 0.02);\n    float d3 = sdCube(vec2(pos.x, pos.y), 0.02);\n    float d4 = sdCube(vec2(pos.z, pos.y), 0.02);\n    \n    float res = MAX_DIST;\n    res = min(res, d1);\n    res = min(res, d2);\n    res = min(res, d3);\n    res = min(res, d4);\n    return res;\n}\n\nvec3 normals(vec3 pos)\n{\n    vec2 e = vec2(0, 0.0001);\n    return normalize(vec3(\n    \tmap(pos+e.yxx)-map(pos-e.yxx),\n        map(pos+e.xyx)-map(pos-e.xyx),\n        map(pos+e.xxy)-map(pos-e.xxy)\n    ));\n}\n\nconst vec4 miss = vec4(MAX_DIST, vec3(0));\nvec4 raymarch(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for(int i = 0; i<MAX_STEPS; i++)\n    {\n        vec3 pos = ro + rd*t;\n        float d = map(pos);\n        \n        if(abs(d)<=EPS) return vec4(length(pos-ro), normals(pos));\n        if(d >= MAX_DIST) return miss;\n        \n        t+=d;\n    }\n         \n    \n    return miss;\n}\n\nconst vec3 BACK_GROUND = vec3(0.2);\nvec3 GetScene(vec3 ro, vec3 rd, vec3 lightDir)\n{\n    \n    vec4 a = raymarch(ro, rd);\n    float d = a.x;\n    vec3 nor = a.yzw;\n    \n    vec3 col = BACK_GROUND;\n    \n    if(d < MAX_DIST)\n    {\n        float li = dot(lightDir, nor);\n        \n        vec3 pos = ro+rd*d;\n        pos *= rotX(0.9);\n        \n        float lines = sin(pos.y * 600.) * 0.5+0.5;\n        lines = smoothstep(li+0.25, li-0.25, lines);\n        lines = lines*0.7+0.3;\n        \n        col = vec3(1, 0.94, 0.8) * lines;\n        col = mix(col, BACK_GROUND, smoothstep(1., 8., d)); // fog\n    }\n    \n    return col;\n    \n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.x;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    float camAngle = 0.09*PI*2.; // mouse.x*PI*2.;\n    vec2 p = 2.0 * vec2(cos(camAngle), sin(camAngle));\n    \n    vec3 scroll = vec3(0,0,iTime * 0.3);\n    \n    vec3 ro = vec3(p.x,0.08,p.y) - scroll;\n    mat3 ca = setCamera(ro, vec3(0,-0.5,0) - scroll, 0.0);\n    vec3 rd = ca*normalize(vec3(uv,1.8));\n    \n    vec3 ld = normalize(vec3(1, 0.5, -0.5));\n    \n    vec3 col = GetScene(ro, rd, ld);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}