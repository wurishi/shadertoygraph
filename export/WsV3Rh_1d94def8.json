{"ver":"0.1","info":{"id":"WsV3Rh","date":"1569707161","viewed":160,"name":"hypnosis","username":"guk","description":"ranging circles with intervals and giving them different gradient colors + some camera zooming at specified scales.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["camera","period","ranges"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float map_dist(float val, float step_val);\nfloat period();\nfloat camera_scale_period();\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord - vec2(iResolution.xy)) / iResolution.y;\n    p *= camera_scale_period(); // comment to see static camera\n\n    float len = length(p);\n    len = pow(len, period()); // comment to see static len\n\n    float val_step = .1;\n    val_step *= (period()/2.0 + 1.0); // comment to see static step\n    \n    len = map_dist(len, val_step);\n    len = clamp(len, 0.0, 3.0); // first version has 'clamp(0.0, 3.0, len);' at this place causing some user seeing only pink - fixed thanks to FabriceNeyret2 comment\n    \n    // some magic numbers to give cool colors\n    vec3 col = vec3(sin(len*2.0)*0.4 + 0.5, sin(len+2.5)*0.5 + .5, sin(len+3.2)*0.5 + .5);\n    fragColor = vec4(col * len,1.0);\n}\n\n// with all the random formulas tweaking up here I decided to make a \n// fixed-point camera with zooming to most interesting spots :)\nconst int cam_point_size = 8;\nconst float[cam_point_size] g_values = float[cam_point_size](.1, 5., 10., 12., 0.015, 0.015, 0.05, 0.08);\nfloat camera_scale_period() {\n    float time_in_per = mod(iTime, 6.28318); // 2 pi\n    float interval = 6.28318 / float(cam_point_size);\n    int current = int(time_in_per / interval);\n    int next = (current + 1) % cam_point_size;\n    float rem = time_in_per / interval - floor(time_in_per / interval);\n    float val = mix(g_values[current], g_values[next], rem);\n    return val;\n}\n\nfloat period() {\n    return sin(iTime);\n}\n\n// floor val into n intervals (n = 1/step_val)\nfloat map_dist(float val, float step_val) {\n    // in case, all this function can be replaced with \n    // 'return floor(val) * step_val;'\n    \n    float rem = val - floor(val);\n    float smooth_interval = 0.05 * val;\n    float smooth_border = 1.0 - smooth_interval / 2.0;\n    float smooth_rem = step(smooth_border, 1.0-rem) * step(smooth_border / 2.0, 1.0-rem)\n        + step(smooth_border, rem) * step(smooth_border, rem);\n    \n    // a lot of code for smoothing borders :(\n    if (smooth_rem == 1.0) {\n        // smooth transition between colors\n        // there's certainly a way to do it without branching\n        if (rem > 0.5) {\n            // case 1: increasing (from current color to next)\n            float current = floor(val) * step_val;\n            float next = (floor(val) + 1.0) * step_val;\n            float average = (current + next) / 2.0;\n            return mix(current, average, (rem - smooth_border) / (smooth_interval / 2.0));\n        } else {\n         \t// case 2: decreasing\n            float current = floor(val) * step_val;\n            float prev = (floor(val) - 1.0) * step_val;\n            float average = (current + prev) / 2.0;\n            return mix(average, current, rem / (smooth_interval / 2.0));\n        }\n    } else {\n    \treturn floor(val) * step_val;\n    } \n}\n","name":"Image","description":"","type":"image"}]}