{"ver":"0.1","info":{"id":"sts3WB","date":"1623219403","viewed":85,"name":"Newton Marcher V1.0","username":"Raxmo","description":"Here is a Newtonian approximation distance marching algorithm. See comment section in shader for more detail and information.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","isosurface"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Description:\n        I'm toying with the idea of using newtonian approximation\n        rather than distance stepping to find the points of ray\n        intersection to a 0 isosurface.\n    Discoveries:\n        From other experiments, compound distance fields do not work.\n        however, for indavidual objects, Newton-marching requires\n        orders of magnitude fewer itterations to find an intersection\n        with the same level of detail as sphere-tracing. I've come\n        to realize that Newton-marching is FAR more complicated than\n        sphere-tracing, as for each object requires 3 functions.\n        Sphere-tracing is also one of if not the simplest method of\n        rendering a scene.\n    Notes:\n        - the unit sphere case is the most detailed in the comments\n          when it comes to explaining the algorithm.\n        - I'm unsure of the relative efficiency with many objects.\n        - Will need to experiment with space deformation like with\n          sphere-tracing.\n        - Likely possible to elimate much of the branching in the\n          algorithm to make it even more efficient.\n        - I suspect that boolien opperations are possible, however,\n          they are likely rather complicated to impliment.\n        - Given smarter people, or more time, one could define exact\n          derivatives for the gradient calculations rather than use\n          the hackey approximations.\n        - Thanks to some smarter people (oneshade), some analytic\n          gradients/derivatives have been added.\n    Purpose:\n        The entire purpose for trying out these experiments is to find\n        a method of rendering volumetric data directly. As in, given\n        3D samples at known locations, rendering the 0 iso-surface\n        directly. This more of an overview of the algorithm than a full\n        demonstration of the end-use.\n*/\n\n//-[ Defines for use later ]-//\n#define MAXDIST 100.\n#define SURF 0.01\n#define eps 1e-5\n#define STEPS 16\n//< NOTE: Notice that the number of steps is FAR less than sphere-trace rendering. >//\n\n//-[ Unit Sphere Functions ]-//\nfloat UnitSphereVal(vec3 p) //<- SDF of a unit sphere at origin\n{\n    return length(p) - 1.;\n}\n\nfloat GradUSV(vec3 p, vec3 rd) //<- Find the gradient at the point in the direction of the ray.\n{\n    float v0 = UnitSphereVal(p);\n    float v1 = UnitSphereVal(p + rd * eps);\n    \n    return (v1 - v0) / eps;\n}\n\nvoid NUSV(in vec3 ro, in vec3 rd, inout vec3 norm, inout float D) //<- Newtonian distance calculation for unit sphere at origin\n{\n    float t = UnitSphereVal(ro);          //<- Step forward once just to get close\n    float v = UnitSphereVal(ro + rd * t); //<- this is the value of the function in first step\n    float g = GradUSV(ro + rd * t, rd);   //<- Find the gradient at the point, in the ray's direction\n    vec3 inorm = vec3(0.);\n    \n    for(int i = 0; i < STEPS && abs(v) > SURF && g != 0.; i++) //<- The Newtonian approximation loop\n    {\n        t -= v / g;    //<- find the x intercept of the gradient\n        \n        v = UnitSphereVal(ro + rd * t);  //<- Update the new value\n        g = GradUSV(ro + rd * t, rd);    //<- Update the new gradient\n    }\n    \n    if(abs(v) <= SURF && t > 0.)   //<- if the t value is positive, and the function value is within the perameters, then you've hit the surface within the view\n    {\n        inorm = ro + rd * t;  //<- set the internal normal to the normal of the point on the sphere, which is that point in the case of a unit sphere at the origin.\n    }\n    else\n    {\n        t = MAXDIST;  //<- otherwise, the point is either out of view, or not on the surface, set it to the max view distance to effectively exclude.\n    }\n    \n    if(t < D)   //<- if the calculated point is closer than the passed in point...\n    {\n        norm = inorm;   //<- set the passed in point to the internal calculated normal\n        D = t;          //<- set the passed in distance to the calculated distance\n    }\n}\n\n//-[ Plane Functions ]-//\nfloat SDPlane(vec3 p, vec4 n)\n{\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat GradSDP(vec3 p, vec3 rd, vec4 n)\n{//-> Oneshade's Analytic gradient\n    return dot(rd, n.xyz); \n}\n\nvoid SSDP(in vec3 ro, in vec3 rd, inout vec3 norm, inout float D, in vec4 n)\n{\n    float t = MAXDIST;\n    \n    float sol = (dot(ro, n.xyz) + n.w) / dot(rd, -n.xyz);\n    \n    if(sol >= 0.) t = sol;\n    \n    if(t < D)\n    {\n        D = t;\n        norm = n.xyz;\n    }\n}\n\nvoid NSDP(in vec3 ro, in vec3 rd, inout vec3 norm, inout float D, in vec4 n)\n{\n    float t = SDPlane(ro, n);\n    float v = SDPlane(ro + rd * t, n);\n    float g = GradSDP(ro + rd * t, rd, n);\n    vec3 inorm = vec3(0.);\n    \n    for(int i = 0; i < STEPS && abs(v) > SURF && g !=0.; i++)\n    {\n        t -= v / g;\n        \n        v = SDPlane(ro + rd * t, n);\n        g = GradSDP(ro + rd * t, rd, n);\n    }\n    \n    if(abs(v) <= SURF && t > 0.)\n    {\n        inorm = n.xyz; //<- Since the plane is partially defined by its normal, just return the normal of the plane.\n    }\n    else\n    {\n        t = MAXDIST;\n    }\n    \n    if(t < D)\n    {\n        D = t;\n        norm = inorm;\n    }\n}\n\n//-[ Sphere Functions ]-//\nfloat SphereVal(vec3 p, vec4 s)\n{\n    return length(p - s.xyz) - s.w;\n}\n\nfloat GradSV(vec3 p, vec3 rd, vec4 s)\n{ //-> Oneshade's Analytic Gradient\n    p -= s.xyz;\n    return dot(p, rd) / length(p);\n}\n\nvoid NSV(in vec3 ro, in vec3 rd, inout vec3 norm, inout float D, in vec4 s)\n{\n    float t = SphereVal(ro, s);\n    float v = SphereVal(ro + rd * t, s);\n    float g = GradSV(ro + rd * t, rd, s);\n    vec3 inorm = vec3(0.);\n    \n    for(int i = 0; i < STEPS && abs(v) > SURF && g != 0.; i++)\n    {\n        t -= v / g;\n        \n        v = SphereVal(ro + rd * t, s);\n        g = GradSV(ro + rd * t, rd, s);\n    }\n    \n    if(abs(v) <= SURF && t > 0.)\n    {\n        inorm = ((ro + rd * t) - s.xyz) / s.w;  //<- the normal of a sphere at a given point on that shpere is simply just that point relative to the sphere's center devided by the radius of that sphere.\n    }\n    else\n    {\n        t = MAXDIST;\n    }\n    \n    if(t < D)\n    {\n        D = t;\n        norm = inorm;\n    }\n}\n\n//-[ Scalar Field for Sphere ]-//\nfloat SFSphere(vec3 p, vec4 s)\n{//-> Here is a raw scalar field of a sphere.\n    vec3 q = p - s.xyz;\n    return dot(q, q) - (s.w * s.w);\n}\n\nfloat SFSGrad(vec3 p, vec3 rd, vec4 s)\n{\n    vec3 q = p - s.xyz;\n    vec3 g = 2. * q;     //<- true gradient of the scalar field\n    return dot(rd, g);\n}\n\nvoid NSFS(in vec3 ro, in vec3 rd, inout vec3 norm, inout float D, in vec4 s)\n{//-> Newton-Raphson approximation for the given sphere scalar field\n    float t = 0.;\n    float v = SFSphere(ro + rd * t, s);\n    float g = SFSGrad(ro + rd * t, rd, s);\n    vec3 inorm = vec3(0.);\n    \n    for(int i = 0; i < STEPS && abs(v) > SURF && g != 0.; i++)\n    {\n        t -= v / g;\n        \n        v = SFSphere(ro + rd * t, s);\n        g = SFSGrad(ro + rd * t, rd, s);\n    }\n    \n    if(abs(v) <= SURF && t > 0.)\n    {\n        inorm = ((ro + rd * t) - s.xyz) / s.w;  //<- the normal of a sphere at a given point on that shpere is simply just that point relative to the sphere's center devided by the radius of that sphere.\n    }\n    else\n    {\n        t = MAXDIST;\n    }\n    \n    if(t < D)\n    {\n        D = t;\n        norm = inorm;\n    }\n}\n\nvoid SSFS(in vec3 ro, in vec3 rd, inout vec3 norm, inout float D, in vec4 s)\n{//-> Direct solution of the scalar field for the sphere\n    vec3 o = ro - s.xyz;\n    vec3 d = rd;\n    float r = s.w;\n    \n    float a = dot(d, d);\n    float b = dot(o, d);\n    float c = dot(o, o) - (r * r);\n    \n    float dis = b*b - a * c;\n    \n    float t = MAXDIST;\n    \n    if(dis >= 0.0)\n    {\n        float z0 = (-b - sqrt(dis)) / a;\n        float z1 = (-b + sqrt(dis)) / a;\n\n        t = min(z0, z1);\n    }\n    \n    if(t < D)\n    {\n        D = t;\n        norm = ((ro + rd * t) - s.xyz) / s.w;\n    }\n}\n\n//-[ Rendering things ]-//\nfloat Sun(vec3 norm)\n{\n    float val = 0.;\n    \n    vec3 sun = normalize(-vec3(sin(iTime), -2., cos(iTime)));\n    val = dot(sun, norm);\n    \n    return val;\n}\n\n//-[ ENTRY POINT ]-//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize UV to -1, 1 relative to the X of the resolution\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x * 2.0;\n    \n    //[ Camera set-up ]//\n    vec3 co = vec3(0., 0., -5.);         //<- This is the camera's origin\n    vec3 cd = normalize(vec3(uv, 1.));   //<- This is the ray's direction\n    \n    \n    vec3 norm = vec3(0., 0., 0.);\n    float d = MAXDIST;\n    \n    //-[ Object calculations ]-//\n    SSFS(co, cd, norm, d, vec4(0., 0., 0., 1.));\n    SSDP(co, cd, norm, d, vec4(0., 1., 0., 1.));\n    \n    \n    vec3 col = vec3(Sun(norm));\n    //vec3 col = vec3(d / iTime);\n    \n    \n    // Output\n    fragColor = vec4(col, 1.);\n}\n/*\n    Remarks:\n        I've come to realize that faster algorithms tend to be more\n        complex, yet, ones that tend to look better are much simpler.\n*/","name":"Image","description":"","type":"image"}]}