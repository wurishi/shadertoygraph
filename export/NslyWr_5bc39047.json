{"ver":"0.1","info":{"id":"NslyWr","date":"1642044907","viewed":99,"name":"SimpleRaymarching","username":"herolang","description":"using SDF&Raymarching Simple example!","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float min_surface = 0.01;\nint max_steps=100;\nfloat max_dis = 200.;\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat getDist(vec3 p){\n    vec4 sphere = vec4(0,1,6,1);\n    vec3 BoxCenter = vec3(-3,1,6);\n    vec3 RoundBoxCenter = vec3(3,1,6);\n    float Box = sdBox(p-BoxCenter,vec3(1));\n    float RoundBox = sdRoundBox(p-RoundBoxCenter,vec3(1),0.07);\n    float d = sdSphere(p-sphere.xyz,sphere.w);\n    float pd = p.y;\n    d = min(min(min(pd,d),Box),RoundBox);\n    return d;\n}\n\nvec3 getNormal(vec3 p){\n    vec3 e = vec3(0,0.01,0.);\n    float d = getDist(p);\n    vec3 normal = vec3(0);\n    normal = normalize(d-vec3( \n        getDist(p-e.yzz),\n        getDist(p-e.zyz),\n        getDist(p-e.zzy)\n    ));\n    \n    return normal;\n}\n\nfloat raymarching(vec3 ro,vec3 rd){\n    float d=0.;\n    \n    for(int i=0;i<max_steps;i++){\n        vec3 p = ro+d*rd;\n        \n        d+=getDist(p);\n        if(d<min_surface||d>max_dis)break;\n    }\n    return d;\n}\n\nfloat getLight(vec3 p,vec3 lightPos){\n    vec3 lightDir = normalize(lightPos-p);\n    vec3 normal = getNormal(p);\n    float ndotl = max(0.,dot(lightDir,normal));\n    float dif = ndotl;\n    float d= raymarching(p+min_surface*normal*2.,lightDir);\n    \n    if(d<length(lightPos-p))dif*=0.16;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.yy;\n    //camera\n    vec3 ro=vec3(0,1,0);\n    //ray direction\n    vec3 rd = vec3(uv.x,uv.y,1);\n    //返回距离\n    float d=raymarching(ro,rd);\n    //获取位置\n    vec3 position = ro+d*rd;\n    vec3 lightPos= vec3(sin(iTime)*3.,10,6.+cos(iTime)*3.);\n    //计算着色\n    float dif = getLight(position,lightPos);\n    \n    fragColor = vec4(vec3(dif),1.0);\n}","name":"Image","description":"","type":"image"}]}