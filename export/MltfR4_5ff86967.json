{"ver":"0.1","info":{"id":"MltfR4","date":"1538892588","viewed":126,"name":"Hello Raymarching!","username":"spookyfox","description":"ray marching","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection","refraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float MISS = 0.;\nfloat BOX = 1.;\nfloat SPHERE = 2.;\nint AA = 2;\n\nfloat sdBox(vec3 p, vec3 c, vec3 b) {\n    // Modified from https://www.shadertoy.com/view/Xds3zN.\n    vec3 d = abs(p - c) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n\nfloat sdSphere(vec3 p, vec3 c, float r) {\n    // Modified from https://www.shadertoy.com/view/Xds3zN.\n\treturn length(p - c) - r;\n}\n\nvec2 opU(vec2 dm1, vec2 dm2) {\n    // Modified from https://www.shadertoy.com/view/Xds3zN.\n    return dm1.x < dm2.x ? dm1 : dm2;\n}\n\nvec2 map(vec3 p) {\n    // Modified from https://www.shadertoy.com/view/Xds3zN.\n    vec2 dm = opU(\n        vec2(sdBox(p, vec3(0, -2, 1), vec3(2, 1, 1)), BOX), \n        vec2(sdSphere(p, vec3(-1, 0, 1), 1.), SPHERE));\n    dm = opU(dm,\n        vec2(sdSphere(p, vec3(1,  cos(iTime) / 3., 1), .5), SPHERE));\n   \treturn dm;\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n    // Shortest distance and material key.\n    vec2 dm;\n    // Current step size.\n    float s = 1.;\n    for (int i = 0; i < 64; i++) {\n        // Current position in the scene.\n        vec3 p = ro + rd * s;\n        dm = map(p);\n        s += dm.x;\n    }\n    if (dm.x > 0.1) {\n        dm.y = MISS;\n    }\n    return vec2(s, dm.y);\n}\n\nvec3 normal(vec3 p) {\n    // Tetrahedron technique\n    // https://iquilezles.org/articles/normalsSDF\n    float h = 0.0001;\n\tvec2 k = vec2(1, -1);\n    return normalize(\n        k.xxx * map(p + k.xxx * h).x +\n        k.xyy * map(p + k.xyy * h).x +\n        k.yxy * map(p + k.yxy * h).x +\n        k.yyx * map(p + k.yyx * h).x);\n}\n\nfloat occlude(vec3 p, vec3 n) {\n    // Modified from https://www.shadertoy.com/view/Xds3zN\n\tfloat a = 1.;\n    for(int i = 0; i < 4; i++) {\n        float r = .1 * float(i);\n        // Consider a point moved in the direction of the normal.\n        vec3 s =  n * r + p;\n        // Find the distance to the nearest surface in the scene.\n        float d = map(s).x;\n        // Ambient.\n        // https://en.wikipedia.org/wiki/Ambient_occlusion\n        a -= r - d;\n    }\n    return pow(clamp(a, 0., 1.), 2.); \n}\n\nvec3 light(vec3 ro, vec3 p, vec3 n, float m) {\n    // General lighting resource: http://www.sunandblackcat.com/tipFullView.php?l=eng&topicid=30\n\tvec3 l = vec3(2, 2, -4);\n    \n    // Material properties.\n    // https://people.eecs.ku.edu/~jrmiller/Courses/672/InClass/3DLighting/MaterialProperties.html\n    vec3 ka, kd, ks;\n    // Larger -> smaller highlight.\n    float es;\n    if (m == BOX) {\n        // Polished Silver.\n    \tka = vec3(.23125);\n    \tkd = vec3(.2775);\n   \t\tks = vec3(.773911);\n        es = 89.6;\n    } else {\n        // Obsidian.\n        //ka = vec3(.05375, .05, .06625);\n    \t//kd = vec3(.18275, 0.17, 0.22525);\n   \t\t//ks = vec3(.332741, .328634, .346435);\n        // es = 38.4;\n        // Chrome.\n        ka = vec3(.25);\n    \tkd = vec3(.4);\n   \t\tks = vec3(.774597);\n        es = 76.8;\n    }\n    \n    // Ambient.\n    // https://en.wikipedia.org/wiki/Shading#Ambient_lighting\n    float a = 0.5;\n    \n    // Diffuse.\n    // https://en.wikipedia.org/wiki/Lambertian_reflectance\n    float d = clamp(dot(n, normalize(l - p)), 0., 1.);\n    \n    // Specular.\n    // https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model\n    vec3 v = normalize(ro - l);\n    vec3 h = normalize(v + l);\n    float s;\n    if (dot(n, l) > 0.) {\n        // Surface is oriented to the light source.\n        s = pow(clamp(dot(n, h), 0., 1.), es);\n    } else {\n        s = 0.;\n    }\n\t\n    float o = occlude(p, n);\n    \n    return (a * ka + d * kd + s * ks) * o;\n}\n\nvec3 reflectance(vec3 incident, vec3 normal, float m) {\n    // Fresnel.\n    // Modified from https://www.shadertoy.com/view/XlK3D3.\n    // https://en.wikipedia.org/wiki/Fresnel_equations\n    // http://graphics.stanford.edu/courses/cs148-10-summer/docs/2006--degreve--reflection_refraction.pdf\n    float r;\n    float n1 = 1.; // Air.\n    float n2 = 1.45; // Obsidian.\n    if (m != SPHERE) {\n        r = 1.;\n    } else {\n        float n = n1 / n2;\n        float cosI = -dot(normal, incident);\n        float sinT2 = n * n * (1. - cosI - cosI);\n        if (sinT2 > 1.) {\n            r = 1.; // TIR\n        } else {\n        \tfloat cosT = sqrt(1. - sinT2);\n            float r0rth = (n1 * cosI * - n2 * cosT) / (n1 * cosI + n2 * cosT);\n            float rPar = (n2 * cosI - n1 * cosT) / (n2 * cosI + n1 * cosT);\n            r = clamp((r0rth * r0rth + rPar * rPar) / 2., 0., 1.);   \n        }\n    }\n    return vec3(r, n1, n2);\n}\n\nvec3 color(vec3 ro, vec3 rd) {\n    vec2 dm = rayMarch(ro, rd);\n    if (dm.y != MISS) {\n        vec3 p = ro + rd * dm.x;\n        vec3 n = normal(p);\n        return light(ro, p, n, dm.y);\n    }\n    return texture(iChannel0, rd).xyz;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 c;\n    vec2 dm = rayMarch(ro, rd);\n    if (dm.y != MISS) {\n        vec3 p = ro + rd * dm.x;\n    \tvec3 n = normal(p);\n    \tc += light(ro, p, n, dm.y);\n        // Reflect and refract once - does not consider reflections on reflections.\n        // TODO: Consider multiple bounce approaches.\n        vec3 r = reflectance(rd, n, dm.y);\n        c += pow(r.x * color(p, reflect(rd, n)), vec3(.5));\n        c += pow((1. - r.x) * color(p, refract(rd, n, r.y / r.z)), vec3(2));\n    } else {\n       \tc = texture(iChannel0, rd).xyz;\n    }\n    \n    // Gamma correction.\n    return pow(c, vec3(0.4545));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 c = vec3(0);\n    \n    // Supersample anti-aliasing.\n    // https://vr.arvilab.com/blog/anti-aliasing\n    // Modified from https://www.shadertoy.com/view/Xds3zN.\n    for (int i = 0; i < AA; i++) {\n        for (int j = 0; j < AA; j++) {\n            vec2 o = vec2(i, j) / float(AA) - 0.5;\n            \n            // Remap xy to [-1, 1] and correct aspect ratio.\n    \t\tvec2 xy = (2.0 * (fragCoord.xy + o) - iResolution.xy) / iResolution.y;\n            \n            // z: Start behind the screen.\n\t\t\tvec3 ro = vec3(0, 0, -.5);\n            \n    \t\t// z: Go through the screen.\n    \t\tvec3 rd = normalize(vec3(xy, 1));\n            \n            c += render(ro, rd);\n        }\n    }\n    c /= float(AA * AA);\n\n    \n    fragColor = vec4(c, 1);\n}","name":"Image","description":"","type":"image"}]}