{"ver":"0.1","info":{"id":"7tt3zM","date":"1635905706","viewed":515,"name":"jneen - volumetric fog","username":"jneen","description":"fog! in a shape!","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fog"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rad(x) (radians(360.*(x)))\n#define time (iTime*.1)\n\nfloat box(vec3 p, vec3 a) {\n  vec3 q = abs(p)-a;\n  return length(max(q,0.))+min(0.,max(q.x,max(q.y,q.z)));\n}\n\nfloat sphere(vec3 p, float r) { return length(p) - r; }\n\nmat2 rot(float a) { float c=cos(a),s=sin(a); return mat2(c,s,-s,c); }\nfloat glow;\n\n#define tri(x) (abs(fract((x)*.5)-.5)*2.)\n\nfloat scene(vec3 p) {\n  float bg = box(p+vec3(0,5+1,0),vec3(5));//p.y + 2.;\n  vec3 orig_p = p.xyz;\n  p.xz *= rot(rad(3.*time));\n  p.xy *= rot(rad(3.*time*sqrt(2.)));\n  p.yz *= rot(rad(2./6.));\n  \n  // define the glow as a regular sdf float\n  float B = box(p, vec3(1))-.3;\n  float S = sphere(p, 2.*(tri(time*2.)));\n  float glowbox = max(B,-S);\n\n  p = orig_p;\n  p -= sin(time*6.);\n  p.xz *= rot(time*10.);\n  p.yz *= rot(time*20.);\n  p.xy *= rot(time*30.);\n  float squeeze = 4.8;\n  float solid = mix(sphere(p,.1+2.*tri(time*2.)),box(p,vec3(.5)-.2),.5+.5*sin(time*17.));\n  \n  // a buffer between the solid and the fog to prevent\n  // super-bright areas on the solid as the raymarcher\n  // slows down. try setting this to 0 and see what happens\n  // should be at least DENSITY\n  // raising this is the best way to deal with edge glow around\n  // the solid\n  float BUFFER_ZONE = 0.05;\n  \n  \n  // lower = more dense fog. should be at least 1/stepcount\n  // (100 here)\n  float FOGSTEP = .001;\n\n  // ==== and here's the 2-line fog effect ====\n  // * if we're inside the glowbox, increase the glow by how far\n  // we have penetrated into the box.\n  // * however, if we're passing close to the solid object, we have to\n  // not increase the glow because it will overcount as we step closer\n  // and closer to the solid. so we zero it out below the buffer zone\n  glow += max(0., -glowbox)*smoothstep(0.,BUFFER_ZONE*2.,solid);\n  // step towards the glowbox by the distance we are inside the cube,\n  // plus a little buffer to get us inside the box. if we're *in* the\n  // box, we want to keep moving, and abs(glowbox) will make sure we're\n  // approximately inside the box still. note that we will *never* detect\n  // a surface at any point of the glowbox, because the minimum distance is\n  // always positive.\n  glowbox = abs(glowbox) + FOGSTEP;\n  return min(bg,min(solid,glowbox));\n}\n\n\nfloat ray(vec3 start, vec3 dir) {\n  float dist=0.;\n  glow=0.;\n  \n  for (int i=0;i<700;i++) {\n    float c = scene(start+dir*dist);\n    dist += c;\n    if (c < .0001) return dist;\n    if (dist > 1000.) return 10001.;\n  }\n  \n  return min(dist,10001.);\n}\n\nvec3 grad(vec3 p) {\n  mat3 K = mat3(p,p,p) - mat3(.01);\n  return scene(p)-vec3(scene(K[0]),scene(K[1]),scene(K[2]));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float focus=2.;\n    vec3 cam = vec3(0,0,-5.*focus);\n    vec3 dir = normalize(vec3(uv,focus));\n    \n    float dist = ray(cam, dir);\n    float G = glow; \n    vec3 hit = cam+dir*dist;\n    vec3 norm = normalize(grad(hit));\n    \n    vec3 refl = reflect(dir,norm);\n    float refldist = ray(hit+refl*.1, refl);\n    float reflglow = glow;\n    \n    // thanks blackle for the awesome fake image lighting :3\n    float diff = 0.;\n\n    if (dist < 1000.) diff = length(sin(norm)*.5+.5)/sqrt(3.);\n\n    \n    vec3 col = diff*diff*vec3(.5,.9,1);\n    \n    // lower numbers are a denser, more uniform fog\n    // high numbers are very glowy and a little glitchy\n    float UNIFORMITY = 0.8;\n    col += pow(G, UNIFORMITY) *.2 * vec3(.9, .1,.5);;\n    col += reflglow * vec3(.9,.1,.5)*.2;\n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"}]}