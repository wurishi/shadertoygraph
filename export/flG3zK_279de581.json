{"ver":"0.1","info":{"id":"flG3zK","date":"1642084822","viewed":55,"name":"Sonik Basic 3D","username":"Sonik","description":"Basic 3D Raycasting with some lighting","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3draycasting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float MAX_DIST = 99999.0;\n\n\nmat2 rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec2 sphIntersect(in vec3 ro, in vec3 rd, float ra){\n    float b = dot(ro,rd);\n    float c = dot(ro,ro) - ra*ra;\n    float h = b * b - c;\n    if(h<0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\nfloat plaIntersect(in vec3 ro, in vec3 rd, in vec4 p){\n    return -(dot(ro,p.xyz)+p.w) / dot(rd, p.xyz);\n}\n\nvec2 boxIntersection(in vec3 ro, in vec3 rd, in vec3 rad, out vec3 oN)  {\n\tvec3 m = 1.0 / rd;\n\tvec3 n = m * ro;\n\tvec3 k = abs(m) * rad;\n\tvec3 t1 = -n - k;\n\tvec3 t2 = -n + k;\n\tfloat tN = max(max(t1.x, t1.y), t1.z);\n\tfloat tF = min(min(t2.x, t2.y), t2.z);\n\tif(tN > tF || tF < 0.0) return vec2(-1.0);\n\toN = -sign(rd) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n\treturn vec2(tN, tF);\n}\n\nvec3 getSky(vec3 rd){\n    vec3 light = normalize(vec3(sin(iTime), cos(iTime), 1.0));\n    vec3 col = vec3(0.3, 0.6, 1.0);\n    vec3 sun = vec3(0.95, 0.9, 1.0);\n    sun *= pow(max(0.0,dot(rd, light)),32.0);\n    return clamp(sun + col, 0.0, 1.0);\n}\n\n\n\nvec3 castRay(inout vec3 ro,inout vec3 rd){\n    vec3 col;\n    vec2 minIt = vec2(MAX_DIST);\n    vec2 it;\n    vec3 n;\n    vec3 spherePos = vec3(0.0, -1.0, 0.0);\n    it = sphIntersect(ro - spherePos, rd, 1.0);\n    if(it.x > 0.0 && it.x < minIt.x){\n        minIt = it;\n        vec3 itPos = ro + rd * it.x;\n        n = itPos - spherePos;\n        col = vec3(1.0, 0.2, 0.1);\n    }\n    vec3 planeNormal = vec3(0.0, 0.0, 1.0);\n    it.x = plaIntersect(ro, rd, vec4(planeNormal, 1.0));\n    if(it.x > 0.0 && it.x < minIt.x){\n        minIt = it;\n        n = planeNormal;\n        col = vec3(0.5);\n    }\n    vec3 boxN;\n\tvec3 boxPos = vec3(0.0, 2.0, 0.0);\n\tit = boxIntersection(ro - boxPos, rd, vec3(1.0), boxN);\n\tif(it.x > 0.0 && it.x < minIt.x) {\n\t\tminIt = it;\n\t\tn = boxN;\n        col = vec3(0.1, 0.2, 1.0);\n\t}\n    \n    if(minIt.x == MAX_DIST) return vec3(-1.0);\n    vec3 light = normalize(vec3(sin(iTime), cos(iTime), 1.0));\n    float diffuse = max(0.0, dot(light, n)) * 0.5 + 0.1;\n\tfloat specular = pow(max(0.0, dot(reflect(rd, n), light)),32.0);\n    col *= mix(diffuse, specular, 0.5);\n    \n    ro += rd * (minIt.x - 0.001);\n    rd = n;\n    return col;\n}\n\nvec3 traceRay(vec3 ro, vec3 rd){\n    vec3 light = normalize(vec3(sin(iTime), cos(iTime), 1.0));\n    vec3 col = castRay(ro, rd);\n    if(col.x == -1.0) return getSky(rd);\n    vec3 lightDir = light;\n    if(dot(rd,light)>0.0){\n        if(castRay(ro, lightDir).x != -1.0) col *= 0.5;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 uvMouse = (iMouse.xy/iResolution.xy-0.5)*5.0;\n    uvMouse.y *= -1.0;\n    \n    vec3 rayOrigin = vec3(-5.0, 0.0, 0.0);\n    vec3 rayDirection = normalize(vec3(1.0, uv));\n    \n    rayDirection.zx *= rot(uvMouse.y);\n    rayDirection.xy *= rot(uvMouse.x);\n    \n    vec3 col = traceRay(rayOrigin, rayDirection);\n    col.r = pow(col.r, 0.45);\n    col.g = pow(col.g, 0.45);\n    col.b = pow(col.b, 0.45);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}