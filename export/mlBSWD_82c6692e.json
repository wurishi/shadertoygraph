{"ver":"0.1","info":{"id":"mlBSWD","date":"1676062276","viewed":94,"name":"Pulsating hexes","username":"peremptor","description":"based on https://www.youtube.com/watch?v=VmrIDyYiJBA. \nWhat a guy...","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["pulse","hexagon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//defines so the shader works out of the box with shadertoy\n#define u_time iGlobalTime\n\n//constants that are often used\n#define PI 3.1415926\n\nvec3 calculateFragmentColor(vec2 uv);\n\nfloat SinXToY(float lowerBound, float upperBound, float value, float frequencyFactor, float frequencyOffset) {\n    float sinValue = sin(value * frequencyFactor + frequencyOffset);\n    //move the sine up to the interval 0->2\n    float noNegativeSin = sinValue + 1.;\n    //limit the sine down to 0->1\n    float zeroToOneSin = noNegativeSin / 2.;\n    //scales the amplitude of the sin to the desired size, that is described with x->y\n    float sinOfDesiredSize = zeroToOneSin * (upperBound - lowerBound);\n    //now move the sine along the x axis, so that x is actually the lowest possible value;\n    float finalSin = sinOfDesiredSize + lowerBound;\n    return finalSin;\n}\n\n//all of the calculations on how to create the hex tiling \n//has been taken from https://www.youtube.com/watch?v=VmrIDyYiJBA\nfloat SHexDistance(vec2 uv)\n{\n    uv = abs(uv);\n    float signedVerticalBorderDistance = uv.x;\n    float signedSlopeBorderDistance = dot(uv, normalize(vec2(1.,sqrt(3.))));\n    float signedHexDistance = max(signedSlopeBorderDistance,signedVerticalBorderDistance);\n    return signedHexDistance;\n}\n\nvec3 calculateHexWall(vec2 uv)\n{\n    float tileCount = 30.;\n    vec2 gridSpacing = vec2(sqrt(3.),3.);\n\n     vec2 scaledGridA = uv * tileCount;\n     vec2 aId = floor(scaledGridA / gridSpacing);\n     vec2 aGv = mod(scaledGridA,gridSpacing) - gridSpacing * .5;\n\n    vec2 scaledGridB = (uv * tileCount) + vec2(sqrt(3.) / 2.,1.5) ;\n    vec2 bId = floor(scaledGridB / gridSpacing);\n    vec2 bGv = mod(scaledGridB,gridSpacing) - gridSpacing * .5;\n\n    vec2 hexId = aId;\n    vec2 hexUv = aGv;\n    if(length(aGv) > length(bGv))\n    {\n        hexId = bId;\n        hexUv = bGv;\n    }\n\n    float hexMaxDistance = sqrt(3.) / 2.;\n    float smoothedDistance = smoothstep(0.1,8.,distance(hexId, vec2(0,0)));\n    float sizeModulation = SinXToY(0.7,.95, smoothedDistance - iTime,3.,0.);\n\n   \n    float hexWall = 0.02/ distance(SHexDistance(hexUv),(hexMaxDistance) * sizeModulation);\n    vec3 hexColor = vec3(1.0,0.,0.0);\n\n    \n\n    return hexColor * hexWall;\n}\n\nvec3 calculateFragmentColor(vec2 uv)\n{\n    vec3 ret = vec3(0);\n    ret += calculateHexWall(uv);\n\n    return ret;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 0.5)\n    vec2 uv = (fragCoord - .5*iResolution.xy) / iResolution.y;\n       \n    //uv += iTime / 10.;\n    vec3 pixelColor = calculateFragmentColor(uv);\n\n    fragColor = vec4(pixelColor, 1);\n}\n","name":"Image","description":"","type":"image"}]}