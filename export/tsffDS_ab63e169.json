{"ver":"0.1","info":{"id":"tsffDS","date":"1588975504","viewed":92,"name":"julia set interpolate iterations","username":"joeggeli","description":"mandelbrot/julia set with smooth interpolation between iterations","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["juliaset"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ITERATE_REVERSE 0\n\n// 0 = Julia set\n// 1 = Mandelbrot set\n#define MANDELBROT 1\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    const float SPEED = 0.3;\n    const float MAX_ITERATIONS = 30.0;\n    \n    // iteration state\n#if(ITERATE_REVERSE==1)\n    float iterations = abs(mod(iTime*SPEED, MAX_ITERATIONS*2.0)-MAX_ITERATIONS);    \n#else    \n    float iterations = mod(iTime*SPEED, MAX_ITERATIONS);    \n#endif\n    int iterations_i = int(iterations);\n    float iterations_f = fract(iterations)*3.0;\n    float iterations_fsqr = clamp(iterations_f, 0.0, 1.0);\n    float iterations_fc = clamp(iterations_f-1.0, 0.0, 1.0);\n    \n    // camera transform\n#if MANDELBROT == 1\n    vec2 cam_pos = vec2(-0.5, 0.0);\n    float cam_scale_exp = max(\n        log(5.0)/log(10.0) - (float(iterations_i)+iterations_fsqr)*0.1, \n        log(2.4)/log(10.0)\n    );\n# else\n    vec2 cam_pos = vec2(0.0, 0.0);    \n    float cam_scale_exp = max(\n        log(4.5)/log(10.0) - (float(iterations_i)+iterations_fsqr)*0.1, \n        log(2.0)/log(10.0)\n    );\n#endif\n    float cam_scale = pow(10.0, cam_scale_exp); \n   \t\n    // map pixel to coordinate system\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\t\n    uv *= cam_scale;\n    uv += cam_pos;\n        \n    // iterate integer\n    vec2 z = uv;\n#if MANDELBROT == 1\n    vec2 c = uv;    \n#else\n    vec2 c = vec2(-0.8, 0.156);    \n#endif\n    for(int i = 0; i < iterations_i; i++){\n        z = vec2(\n            z.x*z.x-z.y*z.y + c.x,\n          \t2.0*z.x*z.y     + c.y  \n    \t);\n    }\n    \n    // interpolate\n   \tfloat ang = atan(z.y, z.x);\n    float mag = length(z);\n   \tang = ang + ang*iterations_fsqr;\n    mag = pow(mag, iterations_fsqr+1.0);\n    z = vec2(cos(ang), sin(ang)) * mag + c * iterations_fc;\n    \n    // final color\n    vec3 col = circle_color(z, 2.0);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define M_PI  3.1415926535897932384626433832795\n#define M_PI_2 6.283185307179586476925286766559 \n\nfloat hue2rgb(float f1, float f2, float hue) {\n    if (hue < 0.0)\n        hue += 1.0;\n    else if (hue > 1.0)\n        hue -= 1.0;\n    float res;\n    if ((6.0 * hue) < 1.0)\n        res = f1 + (f2 - f1) * 6.0 * hue;\n    else if ((2.0 * hue) < 1.0)\n        res = f2;\n    else if ((3.0 * hue) < 2.0)\n    \tres = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\n    else\n    \tres = f1;\n    return res;\n}\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb;\t\t\t\n    if (hsl.y == 0.0) {\n        rgb = vec3(hsl.z);\n    } else {\n        float f2;\n\n        if (hsl.z < 0.5)\n            f2 = hsl.z * (1.0 + hsl.y);\n        else\n            f2 = hsl.z + hsl.y - hsl.y * hsl.z;\t\t\t\t\t\n        float f1 = 2.0 * hsl.z - f2;\t\t\t\t\n        rgb.r = hue2rgb(f1, f2, hsl.x + (1.0/3.0));\n        rgb.g = hue2rgb(f1, f2, hsl.x);\n        rgb.b = hue2rgb(f1, f2, hsl.x - (1.0/3.0));\n    }   \n    return rgb;\n}\nfloat line(vec2 P, vec2 A, vec2 B, float r){\n\tvec2 g = B - A;\n\tfloat d = abs(dot(normalize(vec2(g.y, -g.x)), P - A));\n\treturn smoothstep(r*0.6, r*0.5, d);\n}\nfloat ring(vec2 uv, vec2 pos, float radius, float thick){\n    return mix(1.0, 0.0, smoothstep(thick, thick + 0.01, abs(length(uv-pos) - radius)));\n}\nvec3 circle_color(vec2 uv, float r){    \n    float angle = atan(uv.y, uv.x);\n    float radius = length(uv);\n    vec3 hsl = vec3(\n        angle/M_PI_2,\n        radius/r,\n\t\t0.5\n    ); \n    const float line_width = 0.02;\n    const float line_width_2 = line_width*0.5;\n    vec3 rgb = hsl2rgb(hsl);\n    float ring = ring(uv, vec2(0.0), 0.5, line_width_2)\n               + ring(uv, vec2(0.0), 1.0, line_width_2)\n               + ring(uv, vec2(0.0), 1.5, line_width_2)\n               + ring(uv, vec2(0.0), 2.0, line_width_2);\n    float line = line(uv, vec2(0.0, 0.0), vec2(1.0, 0.0), line_width)\n               + line(uv, vec2(0.0, 0.0), vec2(0.0, 1.0), line_width)\n               + line(uv, vec2(0.0, 0.0), vec2(1.0, 1.0), line_width)\n               + line(uv, vec2(0.0, 0.0), vec2(-1.0, 1.0), line_width);\n    rgb = clamp(rgb + vec3(1.0, 0.0, 1.0) * ring, 0.0, 1.0);\n    rgb = clamp(rgb + vec3(0.0, 1.0, 1.0) * line, 0.0, 1.0);\n    return rgb * smoothstep(r+line_width, r, radius);\n}\n","name":"Common","description":"","type":"common"}]}