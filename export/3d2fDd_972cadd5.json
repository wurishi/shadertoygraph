{"ver":"0.1","info":{"id":"3d2fDd","date":"1591164586","viewed":261,"name":"Path Tracer for Practice","username":"specialsaucewc","description":"testing pathtracing following the blog\npress space to reset render\nhttps://blog.demofox.org/2020/05/25/casual-shadertoy-path-tracing-1-basic-camera-diffuse-emissive/","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["raytrace","pathtrace","practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct SMaterial\n{\n    vec3 albedo;\n    vec3 emissive;\n    float percentSpecular;\n    float roughness;\n    vec3 specularColor;\n};\n    \nstruct SRayHitInfo\n{\n    float dist;\n    vec3 normal;\n    SMaterial material;\n};\n\nbool testQuadTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    // calculate normal and flip vertices order if needed\n    vec3 normal = normalize(cross(c-a, c-b));\n    if (dot(normal, rayDir) > 0.0f)\n    {\n        normal *= -1.0f;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = rayPos;\n    vec3 q = rayPos + rayDir;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n    \n    // determine which triangle to test against by testing against diagonal first\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0f)\n    {\n        // test against triangle a,b,c\n        float u = -dot(pb, m);\n        if (u < 0.0f) return false;\n        float w = scalarTriple(pq, pb, pa);\n        if (w < 0.0f) return false;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*b+w*c;\n    }\n    else\n    {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0f) return false;\n        float w = scalarTriple(pq, pa, pd);\n        if (w < 0.0f) return false;\n        v = -v;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*d+w*c;\n    }\n    \n    float dist;\n    if (abs(rayDir.x) > 0.1f)\n    {\n        dist = (intersectPos.x - rayPos.x) / rayDir.x;\n    }\n    else if (abs(rayDir.y) > 0.1f)\n    {\n        dist = (intersectPos.y - rayPos.y) / rayDir.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - rayPos.z) / rayDir.z;\n    }\n    \n\tif (dist > MIN_RAY_HIT && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normal;        \n        return true;\n    }    \n    \n    return false;\n}\n\nbool testSphereTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 sphere)\n{\n\t//get the vector from the center of this sphere to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n    \n\t//ray now found to intersect sphere, compute smallest t value of intersection\n    bool fromInside = false;\n\tfloat dist = -b - sqrt(discr);\n    if (dist < 0.0f)\n    {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n    \n\tif (dist > MIN_RAY_HIT && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normalize((rayPos+rayDir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);\n        return true;\n    }\n    \n    return false;\n}\n\nvoid testSceneTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo hitInfo)\n{\n    // to move the scene around, since we can't move the camera yet\n    vec3 sceneTranslation = vec3(0.0f, 0.0f, 15.0f);\n    vec4 sceneTranslation4 = vec4(sceneTranslation, 0.0f);\n    \n   \t// back wall\n    {\n        vec3 A = vec3(-12.6f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.6f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 C = vec3( 12.6f,  12.6f, 25.0f) + sceneTranslation;\n        vec3 D = vec3(-12.6f,  12.6f, 25.0f) + sceneTranslation;\n        if (testQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.7f, 0.7f, 0.7f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.percentSpecular = 0.;\n        \thitInfo.material.roughness = 0.;\n        \thitInfo.material.specularColor = vec3(0.);\n        }\n\t}    \n    \n    // floor\n    {\n        vec3 A = vec3(-12.6f, -12.45f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.6f, -12.45f, 25.0f) + sceneTranslation;\n        vec3 C = vec3( 12.6f, -12.45f, 12.0f) + sceneTranslation;\n        vec3 D = vec3(-12.6f, -12.45f, 12.0f) + sceneTranslation;\n        if (testQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.7f, 0.7f, 0.7f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.percentSpecular = 0.;\n        \thitInfo.material.roughness = 0.;\n        \thitInfo.material.specularColor = vec3(0.);\n        }        \n    }\n    \n    // ceiling\n    {\n        vec3 A = vec3(-12.6f, 12.5f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.6f, 12.5f, 25.0f) + sceneTranslation;\n        vec3 C = vec3( 12.6f, 12.5f, 12.0f) + sceneTranslation;\n        vec3 D = vec3(-12.6f, 12.5f, 12.0f) + sceneTranslation;\n        if (testQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.7f, 0.7f, 0.7f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.percentSpecular = 0.;\n        \thitInfo.material.roughness = 0.;\n        \thitInfo.material.specularColor = vec3(0.);\n        }        \n    }    \n    \n    // left wall\n    {\n        vec3 A = vec3(-12.5f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 B = vec3(-12.5f, -12.6f, 12.0f) + sceneTranslation;\n        vec3 C = vec3(-12.5f,  12.6f, 12.0f) + sceneTranslation;\n        vec3 D = vec3(-12.5f,  12.6f, 25.0f) + sceneTranslation;\n        if (testQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.7f, 0.1f, 0.1f);\n            hitInfo.material.emissive = vec3(0.f, 0.f, 0.f);\n            hitInfo.material.percentSpecular = 0.;\n        \thitInfo.material.roughness = 0.;\n        \thitInfo.material.specularColor = vec3(0.);\n        }        \n    }\n    \n    // right wall \n    {\n        vec3 A = vec3( 12.5f, -12.6f, 25.0f) + sceneTranslation;\n        vec3 B = vec3( 12.5f, -12.6f, 12.0f) + sceneTranslation;\n        vec3 C = vec3( 12.5f,  12.6f, 12.0f) + sceneTranslation;\n        vec3 D = vec3( 12.5f,  12.6f, 25.0f) + sceneTranslation;\n        if (testQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.1f, 0.7f, 0.1f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.percentSpecular = 0.;\n        \thitInfo.material.roughness = 0.;\n        \thitInfo.material.specularColor = vec3(0.);\n        }        \n    }    \n    \n    // light\n    {\n        vec3 A = vec3(-5.0f, 12.4f,  22.5f) + sceneTranslation;\n        vec3 B = vec3( 5.0f, 12.4f,  22.5f) + sceneTranslation;\n        vec3 C = vec3( 5.0f, 12.4f,  17.5f) + sceneTranslation;\n        vec3 D = vec3(-5.0f, 12.4f,  17.5f) + sceneTranslation;\n        if (testQuadTrace(rayPos, rayDir, hitInfo, A, B, C, D))\n        {\n            hitInfo.material.albedo = vec3(0.0f, 0.0f, 0.0f);\n            hitInfo.material.emissive = vec3(1.0f, 0.9f, 0.7f) * 20.0f;\n            hitInfo.material.percentSpecular = 0.;\n        \thitInfo.material.roughness = 0.;\n        \thitInfo.material.specularColor = vec3(0.);\n        }        \n    }\n    \n\tif (testSphereTrace(rayPos, rayDir, hitInfo, vec4(-9.0f, -9.5f, 20.0f, 3.0f)+sceneTranslation4))\n    {\n        hitInfo.material.albedo = vec3(0.9f, 0.9f, 0.5f);\n        hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n        hitInfo.material.percentSpecular = .1;\n        hitInfo.material.roughness = .2;\n        hitInfo.material.specularColor = vec3(.9, .9, .5);\n    } \n    \n\tif (testSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, -9.5f, 20.0f, 3.0f)+sceneTranslation4))\n    {\n        hitInfo.material.albedo = vec3(0.9f, 0.5f, 0.9f);\n        hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        \n        hitInfo.material.percentSpecular = .3;\n        hitInfo.material.roughness = .2;\n        hitInfo.material.specularColor = vec3(.9, .5, .9);\n    }    \n    \n\tif (testSphereTrace(rayPos, rayDir, hitInfo, vec4(9.0f, -9.5f, 20.0f, 3.0f)+sceneTranslation4))\n    {\n        hitInfo.material.albedo = vec3(0.3f, 0.9f, 0.9f);\n        hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);\n        hitInfo.material.percentSpecular = .7;\n        hitInfo.material.roughness = .3;\n        hitInfo.material.specularColor = vec3(.3, .9, .9);\n    }\n    \n    //green balls\n    {\n        if (testSphereTrace(rayPos, rayDir, hitInfo, vec4(-10.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4))\n        {\n            hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        \n            hitInfo.material.percentSpecular = 1.0f;\n            hitInfo.material.roughness = 0.0f;\n            hitInfo.material.specularColor = vec3(0.3f, 1.0f, 0.3f);       \n        }     \n        \n        if (testSphereTrace(rayPos, rayDir, hitInfo, vec4(-5.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4))\n        {\n            hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        \n            hitInfo.material.percentSpecular = 1.0f;\n            hitInfo.material.roughness = 0.25f;\n            hitInfo.material.specularColor = vec3(0.3f, 1.0f, 0.3f);\n        }            \n        \n        if (testSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4))\n        {\n            hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        \n            hitInfo.material.percentSpecular = 1.0f;\n            hitInfo.material.roughness = 0.5f;\n            hitInfo.material.specularColor = vec3(0.3f, 1.0f, 0.3f);\n        }            \n        \n        if (testSphereTrace(rayPos, rayDir, hitInfo, vec4(5.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4))\n        {\n            hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        \n            hitInfo.material.percentSpecular = 1.0f;\n            hitInfo.material.roughness = 0.75f;\n            hitInfo.material.specularColor = vec3(0.3f, 1.0f, 0.3f);\n        }        \n        \n        if (testSphereTrace(rayPos, rayDir, hitInfo, vec4(10.0f, 0.0f, 23.0f, 1.75f)+sceneTranslation4))\n        {\n            hitInfo.material.albedo = vec3(1.0f, 1.0f, 1.0f);\n            hitInfo.material.emissive = vec3(0.0f, 0.0f, 0.0f);        \n            hitInfo.material.percentSpecular = 1.0f;\n            hitInfo.material.roughness = 1.0f;\n            hitInfo.material.specularColor = vec3(0.3f, 1.0f, 0.3f);\n        }           \n    }\n}\n\nvec3 getColorForRay(in vec3 startRayPos, in vec3 startRayDir, inout uint rngState)\n{\n    vec3 result = vec3(0.);\n    vec3 throughput = vec3(1.);\n    vec3 rayPos = startRayPos;\n    vec3 rayDir = startRayDir;\n    \n    for (int bounceIndex = 0; bounceIndex <= MAX_BOUNCES; bounceIndex++)\n    {\n        SRayHitInfo hitInfo;\n    \thitInfo.dist = MAX_RAY_DIST;\n        testSceneTrace(rayPos, rayDir, hitInfo);\n        \n        //We missed\n        if (hitInfo.dist == MAX_RAY_DIST)\n        {\n            //skybox is not using ACES tone map, multiply by 2 to approximate value\n            result += SRGBToLinear(texture(iChannel1, rayDir).rgb) * throughput * 2.;\n            break;\n        }\n        \n        //move to intersect and nudge back a bit\n        rayPos = (rayPos + rayDir * hitInfo.dist) + hitInfo.normal * MIN_RAY_HIT;\n        \n        float doSpecular = (randomFloat01(rngState) < hitInfo.material.percentSpecular) ? 1. : 0.;\n        \n        //Get both ray directions, pick direction based on specular roll\n        vec3 diffuseRayDir = normalize(hitInfo.normal + randomUnitVector(rngState));\n        vec3 specularRayDir = reflect(rayDir, hitInfo.normal);\n        specularRayDir = normalize(mix(specularRayDir, diffuseRayDir, hitInfo.material.roughness * hitInfo.material.roughness));\n        rayDir = mix(diffuseRayDir, specularRayDir, doSpecular);\n        \n        result += hitInfo.material.emissive * throughput;\n        \n        throughput *= mix(hitInfo.material.albedo, hitInfo.material.specularColor, doSpecular);\n        // Russian Roulette\n        // As the throughput gets smaller, the ray is more likely to get terminated early.\n        // Survivors have their value boosted to make up for fewer samples being in the average.\n        {\n            float p = max(throughput.r, max(throughput.g, throughput.b));\n            if (randomFloat01(rngState) > p)\n                break;\n\n            // Add the energy we 'lose' by randomly terminating paths\n            throughput *= 1.0f / p;\n        }\n    }\n    \n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tuint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    \n    vec3 cameraPos = vec3(0.);\n    float cameraDist = 1. / tan(FOV * .5 * PI / 180.);\n    \n    //jitter pixel coord each frame to increase sampling for AA\n    vec2 jitter = vec2(randomFloat01(rngState), randomFloat01(rngState)) - .5;\n    //[-1,1]\n    vec2 uv = ((fragCoord+jitter)/iResolution.xy)*2. - 1.;\n    \n    vec3 rayTarget = vec3(uv, cameraDist);\n    rayTarget.y /= iResolution.x / iResolution.y;\n    vec3 rayDir = normalize(rayTarget - cameraPos);\n    \n    vec3 col = vec3(0.);\n    for (int i = 0; i < RPP; i++) {\n    \tcol += getColorForRay(cameraPos, rayDir, rngState);\n    }\n    col /= float(RPP);\n    //apply camera exposure\n    col *= EXPOSURE;\n    //convert unbounded HDR to SDR curve\n    col = ACESFilm(col);\n    \n    bool spacePressed = (texture(iChannel2, vec2(32.5/256., .25)).x > .1);\n    \n    //frames are stored in sRGB\n    vec4 lastFrameCol = texture(iChannel0, fragCoord/iResolution.xy);\n    vec3 lastFrameLinear = SRGBToLinear(lastFrameCol.rgb);\n    //blend override to reset render\n    float blend = (lastFrameCol.a == 0. || spacePressed) ? 1. : 1. / (1. + (1. / lastFrameCol.a));\n    col = mix(lastFrameLinear.rgb, col, blend);\n\n    col = LinearToSRGB(col);    \n    fragColor = vec4(col,blend);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265\n#define FOV 80.\n#define MAX_BOUNCES 8\n#define MIN_RAY_HIT .001\n#define MAX_RAY_DIST 10000.\n#define EXPOSURE .5\n#define RPP 40\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat randomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n \nvec3 randomUnitVector(inout uint state)\n{\n    float z = randomFloat01(state) * 2.0f - 1.0f;\n    float a = randomFloat01(state) * 2. * PI;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n    \nfloat scalarTriple(vec3 u, vec3 v, vec3 w)\n{\n    return dot(cross(u,v),w);\n}\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n \nvec3 SRGBToLinear(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n    );\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}","name":"Common","description":"","type":"common"}]}