{"ver":"0.1","info":{"id":"cs23Dc","date":"1668490022","viewed":78,"name":"Curvature Plotter (Implicit)","username":"Envy24","description":"Template for plotting circle of curvature for implicit functions.\nUse mouse to pick point.\nIt works, kinda)","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["template","implicit","plotter","tangent","graphs"],"hasliked":0,"parentid":"Dsj3Wm","parentname":"Tangent Plotter (Implicit)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                         ( iResolution )\n#define AR                        ( R.x / R.y )                      // Aspect ratio.\n#define SCENE_SCALE               ( 2.5 )\n#define UNIT                      ( 3.*SCENE_SCALE / R.y )                      // Affects AA and thickness\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat draw_explicit_func(vec2 NDC, float fx, float dfdx)\n{\n    float sdf = NDC.y - fx;\n    return SMAA(abs(sdf) / sqrt(1.0 + dfdx * dfdx)); // absolute value / arclenght over unit length interval\n}\nfloat draw_implicit_func(vec2 NDC, float fxy, vec2 grad) { return SMAA(abs(fxy) / sqrt(1.0 + grad.x*grad.x + grad.y*grad.y)); }\nfloat draw_implicit_func(vec2 NDC, float fxyz, vec3 grad) { return SMAA(abs(fxyz) / sqrt(1.0 + grad.x*grad.x + grad.y*grad.y + grad.z*grad.z)); }\n// e.t.c.\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - R.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse)\n{\n    vec2 M = MOUSE_OFFSET * (mouse == true ? 1. : 0.);\n    return ((2. * (SC - M) - R.xy) / R.y) * scale - origin;\n}\n\n#define C0 ( 2.0 )\n#define C1 ( 2.0 )\n//float implicit(float x, float y) { return 3.*x*x*y*y - 5.*x + sin(y) - 3.*y + 1.; }\n//float implicit(float x, float y) { return sin(x+y)-cos(x*y)+1.; }\n//float implicit(float x, float y) { return x*x+y*y-1.; }\n//float implicit(float x, float y) { return y-x*x; }\nfloat implicit(float x, float y) { return (x*x+y*y)*(x*x+y*y) - 2.*C0*C0*(x*x-y*y) - (C1*C1*C1*C1-C0*C0*C0*C0); }\nfloat delf_delx(float x, float y) \n{ \n    /* Numeric derivative. */\n    const float dx=0.01;\n    return ( implicit(x+dx, y)-implicit(x-dx, y) ) / (2.*dx);\n    /* Analytic derivative. */\n    //return 2.*x; \n}\nfloat delf_dely(float x, float y) \n{ \n    /* Numeric derivative. */\n    const float dy=0.01;\n    return ( implicit(x, y+dy)-implicit(x, y-dy) ) / (2.*dy);\n    /* Analytic derivative. */\n    //return 2.*y; \n}\nfloat delf_delxy(float x, float y) \n{ \n    /* Numeric derivative. */\n    const float d=0.01;\n    return ( implicit(x-d, y-d)-implicit(x-d, y-d) ) / (2.*d);\n    /* Analytic derivative. */\n    //return 2.; \n}\nfloat ddelf_delxx(float x, float y) \n{ \n    /* Numeric derivative. */\n    const float dx=0.01;\n    return ( delf_delx(x+dx, y)-delf_delx(x-dx, y) ) / (2.*dx);\n    /* Analytic derivative. */\n    //return 2.; \n}\nfloat ddelf_delyy(float x, float y) \n{ \n    /* Numeric derivative. */\n    const float dy=0.01;\n    return ( delf_dely(x, y+dy)-delf_dely(x, y-dy) ) / (2.*dy);\n    /* Analytic derivative. */\n    //return 2.; \n}\nvec2 gradient(float x, float y) { return vec2(delf_delx(x, y), delf_dely(x, y)); }\nvec2 normal(float x, float y) { return vec2(delf_delx(x, y), delf_dely(x, y)); }\nvec2 tangent(float x, float y) { return vec2(delf_dely(x, y), -delf_delx(x, y)); }\nfloat dydx(float x, float y) { return -delf_delx(x, y) / delf_dely(x, y); }\nfloat dxdy(float x, float y) { return delf_dely(x, y) / -delf_delx(x, y); }\n\nfloat ddydxx(float x, float y) \n{\n    /* Numeric derivative. */\n    const float dx=0.001;\n    return ( dydx(x+dx, y)-dydx(x, y-dx) ) / (2.*dx);\n    // Analytic derivative.\n    //return 6.*x*x*y + cos(y) - 3.; \n}\nfloat ddxdyy(float x, float y) \n{\n    /* Numeric derivative. */\n    const float dy=0.001;\n    return ( dxdy(x, y+dy)-dxdy(x, y-dy) ) / (2.*dy);\n    // Analytic derivative.\n    //return 6.*x*x*y + cos(y) - 3.; \n}\n\n// source: https://en.wikipedia.org/wiki/Curvature\nvec2 curvature(float x, float y)\n{\n    float a = delf_delx(x, y),   b = delf_dely(x, y),\n          c = ddelf_delxx(x, y), d = ddelf_delyy(x, y),\n          e = delf_delxy(x, y), // partial derivative with respect to xy? what?\n          aa = a*a, bb = b*b,\n          f = aa + bb,\n          K = ( bb*c-2.*a*b*e + aa*d ) / sqrt(f*f*f),\n          ROC = 1./K;\n    return vec2(K, ROC);\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0), false);\n\n    vec3 color = vec3(1.);\n         color -= x_axis(NDC); color -= y_axis(NDC);\n \n \n \n    /* Implicit function f(x,y) */\n    color = mix(color, vec3(1,0,0), draw_implicit_func(NDC, implicit(NDC.x, NDC.y), gradient(NDC.x, NDC.y)));\n\n\n\n    /* Current mouse position */\n    vec2 M = map_to_centered_ndc(iMouse.xy, SCENE_SCALE, vec2(0), false);\n    color = mix( color, vec3(0,0,1), SMAA(diskSDF_L2(NDC, M, 3.*UNIT)) );\n\n\n\n    /* Tangent line */\n    if (abs(implicit(M.x, M.y)) < 0.45*SCENE_SCALE)\n    {\n        /* Circles of curvature. */\n        vec2 p0 = vec2(M.x, M.y);\n        vec2 data_a = curvature(M.x, M.y);\n        vec2 N = normal(M.x, M.y);\n        float s = -1.;\n        vec2 C = p0 + s*normalize(N)*data_a.y;   \n        color = mix(color, vec3(0,0,1), SMAA(abs(diskSDF_L2(NDC, C, abs(data_a.y)))) );\n\n        color = mix(color, vec3(1,0,1), SMAA(diskSDF_L2(NDC, p0, 2.*UNIT)) );\n        color = mix(color, vec3(0,1,0), SMAA(diskSDF_L2(NDC, C, 2.*UNIT)) );\n    }\n\n \n \n    /* Cells */\n#define CELL_SIZE 1\n         NDC = mod(NDC, vec2(CELL_SIZE)); \n         color -= vertical_line(NDC, 0.)*.2;  color -= horizontal_line(NDC, 0.)*.2; // comment this line if you not use mod\n         color -= vertical_line(NDC, -1.)*.2; color -= horizontal_line(NDC, -1.)*.2;         \n         color -= vertical_line(NDC, 1.)*.2;  color -= horizontal_line(NDC, 1.)*.2; \n    /* */ \n        \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/**\n//#define DFDX(x, y) ( ( -implicit(x+2.*INC, y)+8.*implicit(x+INC, y)-8.*implicit(x-INC, y) + implicit(x-2.*INC, y) ) / ( 12.*INC ) )\n//#define DFDY(x, y) ( ( -implicit(x, y+2.*INC)+8.*implicit(x, y+INC)-8.*implicit(x, y-INC) + implicit(x, y-2.*INC) ) / ( 12.*INC ) )\n/**/\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R) { return length(C - NDC)-R; }\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E,\n    float R)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - R;\n}","name":"Common","description":"","type":"common"}]}