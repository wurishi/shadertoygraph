{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//---------------------------------------------------\n//---------------------------------------------------\n//\n// \"Ray-intersection for uni-variate quadratic Bezier triangle\"\n//\n// 'Ray-intersection' instead of 'ray-tracing' becase we are finding the\n//  intersection with one primitive with a formula, as opposed to finding\n//  intersection with a group of objects with an iterative approach.\n//\n// 'Uni-variate' because the spline is interpolating scalar values, which\n//  we then interpret as the 'height' of the spline at that location.  \n//\n//  'Quadratic' because the basis functions are a set of 2D quadratic\n//  polynomials in Bernstein form.  Yes, the basis functions are\n//  intrinsically 2D and quadratic, unlike rectangular Bezier forms.\n//\n//  'Bezier triangle' because simplex (triangle, tetrahedra, etc) lend \n//  themselves to ray-intersection more easily than rectangular Bezier \n//  forms.  This is because the basis functions in the rectangular case\n//  are created by combinations of 1D basis functions that multiply out into\n//  higher powers when trying to solve non-axis-aligned ray-intersection.\n//  Simplex forms avoid by using intrinsically 2D basis functions.\n//\n//  This is intended to be more of a educational example than a 'real' \n//  optimized implementation. Currently suffers from some precision \n//  problems and ugly code that I may cleanup later if I feel like it.\n//\n//  -John Kloetzli, Jr\n//  @JJcoolkl\n//---------------------------------------------------\n//---------------------------------------------------\n\n\n\n#define H_FOV_RADIANS 0.785\n#define D_BIAS 0.0001\n\n\n//---------------------------------------------------\n// Definition of the quadratic triangular b-spline\n//---------------------------------------------------\nvec2 v2VertA = vec2( 0.0, 4.0 ); \nvec2 v2VertB = vec2(-4.0,-4.0 );\nvec2 v2VertC = vec2( 4.0,-4.0 );\n    \n//Control points marked by index\nfloat f200 = 2.0;\nfloat f020 = 2.0;\nfloat f002 = 2.0;\n\nfloat f011 = -2.0;\nfloat f101 = -2.0;\nfloat f110 = -2.0;\n\n//---------------------------------------------------\n// Evaluate the b-spline at a given barycentric point\n//---------------------------------------------------\nfloat BezierTriangle_Quadratic( const vec3 v3Bary, const vec3 CP_2, const vec3 CP_0 )\n{\n    return \n        v3Bary.x * v3Bary.x * CP_2.x + \n        v3Bary.y * v3Bary.y * CP_2.y +\n        v3Bary.z * v3Bary.z * CP_2.z +\n        \n        v3Bary.y * v3Bary.z * CP_0.x * 2.0 +\n        v3Bary.x * v3Bary.z * CP_0.y * 2.0 + \n        v3Bary.x * v3Bary.y * CP_0.z * 2.0; \n}\n\n//---------------------------------------------------\n// Evaluate the normal at a given barycentric point\n//---------------------------------------------------\nvec3 BezierTriangle_Quadratic_Normal( const vec3 v3Bary, const vec3 CP_2, const vec3 CP_0 )\n{\n    //directional derivatives for vectors AB and AC\n    float fDirAB = \n        (CP_2.x - CP_0.z) * v3Bary.x +\n        (CP_0.z - CP_2.y) * v3Bary.y +\n        (CP_0.y - CP_0.x) * v3Bary.z;\n    \n    float fDirAC = \n        (CP_2.x - CP_0.y) * v3Bary.x +\n        (CP_0.z - CP_0.x) * v3Bary.y +\n        (CP_0.y - CP_2.z) * v3Bary.z;\n    \n    //Reconstruct vectors AB and AC (are known in world space)\n    vec3 AB = vec3( v2VertA - v2VertB, fDirAB );\n    vec3 AC = vec3( v2VertA - v2VertC, fDirAC );\n        \n    vec3 Normal = normalize( cross( AB, AC ) );\n    return Normal;\n}\n\n//---------------------------------------------------\n// Convert a 2d Cartesian point to barycentric (relative to spline verts)\n//---------------------------------------------------\nvec3 CartToBary( vec2 v2Cart )\n{\n    vec2 v0 = v2VertB - v2VertA;\n    vec2 v1 = v2VertC - v2VertA;\n    vec2 v2 = v2Cart - v2VertA;\n    float d00 = dot(v0, v0);\n    float d01 = dot(v0, v1);\n    float d11 = dot(v1, v1);\n    float d20 = dot(v2, v0);\n    float d21 = dot(v2, v1);\n    float denom = d00 * d11 - d01 * d01;\n    \n    vec3 v3Bary;\n    v3Bary.y = (d11 * d20 - d01 * d21) / denom;\n    v3Bary.z = (d00 * d21 - d01 * d20) / denom;\n    v3Bary.x = 1.0 - v3Bary.y - v3Bary.z;\n    \n    return v3Bary;\n}\n\n//---------------------------------------------------\n// Intersect camera ray with bezier tri.\n//---------------------------------------------------\nvec2 LineISect( const vec2 S1, const vec2 S2, const vec2 E1, const vec2 E2 )\n{\n    vec3 A1, A2;\n    A1.x = S2.y - S1.y;\n    A1.y = S1.x - S2.x;\n    A1.z = A1.x * S1.x + A1.y * S1.y;\n    \n    A2.x = E2.y - E1.y;\n    A2.y = E1.x - E2.x;\n    A2.z = A2.x * E1.x + A2.y * E1.y;\n    \n    float fDet = A1.x * A2.y - A2.x * A1.y;\n    if( abs(fDet) < 0.001 )\n        return vec2(0.0, 0.0);\n    vec2 v2Ret;\n    v2Ret.x = ((A2.y*A1.z) - (A1.y*A2.z)) / fDet;\n    v2Ret.y = ((A1.x*A2.z) - (A2.x*A1.z)) / fDet;\n    return v2Ret;\n}\n\nvec4 BezierTriISect( const vec3 v3CameraPos, const vec3 v3LookDir, vec3 CP_2, vec3 CP_0 )\n{\n    vec2 v2LookPt = v3CameraPos.xy + v3LookDir.xy;\n    \n    //This is a hacky brute-force way of finding limits of triangle bounding retion.  \n    // I will probably re-write this with a better approach.\n    vec2 v2PosA = LineISect( v2VertA, v2VertB, v3CameraPos.xy, v2LookPt );\n    vec2 v2PosB = LineISect( v2VertB, v2VertC, v3CameraPos.xy, v2LookPt );\n    vec2 v2PosC = LineISect( v2VertC, v2VertA, v3CameraPos.xy, v2LookPt );\n    \n    vec2 v2MinA = vec2( min( v2VertA.x, v2VertB.x ), min( v2VertA.y, v2VertB.y ) ) - D_BIAS;\n    vec2 v2MinB = vec2( min( v2VertB.x, v2VertC.x ), min( v2VertB.y, v2VertC.y ) ) - D_BIAS;\n    vec2 v2MinC = vec2( min( v2VertC.x, v2VertA.x ), min( v2VertC.y, v2VertA.y ) ) - D_BIAS;\n    \n    vec2 v2MaxA = vec2( max( v2VertA.x, v2VertB.x ), max( v2VertA.y, v2VertB.y ) ) + D_BIAS;\n    vec2 v2MaxB = vec2( max( v2VertB.x, v2VertC.x ), max( v2VertB.y, v2VertC.y ) ) + D_BIAS;\n    vec2 v2MaxC = vec2( max( v2VertC.x, v2VertA.x ), max( v2VertC.y, v2VertA.y ) ) + D_BIAS;\n    \n    bool bAValid = \n        v2PosA.x >= v2MinA.x && v2PosA.x <= v2MaxA.x && \n        v2PosA.y >= v2MinA.y && v2PosA.y <= v2MaxA.y;\n    \n    bool bBValid =\n        v2PosB.x >= v2MinB.x && v2PosB.x <= v2MaxB.x &&\n        v2PosB.y >= v2MinB.y && v2PosB.y <= v2MaxB.y;\n    \n    bool bCValid =\n        v2PosC.x >= v2MinC.x && v2PosC.x <= v2MaxC.x && \n        v2PosC.y >= v2MinC.y && v2PosC.y <= v2MaxC.y;\n    \n    \n    \n    float fCamDistA = (v2PosA.x - v3CameraPos.x) / v3LookDir.x;\n    float fCamDistB = (v2PosB.x - v3CameraPos.x) / v3LookDir.x;\n    float fCamDistC = (v2PosC.x - v3CameraPos.x) / v3LookDir.x;\n    \n    vec3 v3Start, v3End;\n    if( bAValid && bBValid )\n    {\n        v3Start = v3CameraPos + v3LookDir * min( fCamDistA, fCamDistB );\n        v3End = v3CameraPos + v3LookDir * max( fCamDistA, fCamDistB );\n    }else if( bBValid && bCValid )\n    {\n        v3Start = v3CameraPos + v3LookDir * min( fCamDistB, fCamDistC );\n        v3End = v3CameraPos + v3LookDir * max( fCamDistB, fCamDistC );\n    }else if( bCValid && bAValid )\n    {\n        v3Start = v3CameraPos + v3LookDir * min( fCamDistC, fCamDistA );\n        v3End = v3CameraPos + v3LookDir * max( fCamDistC, fCamDistA );\n    }else{\n        //no intersection!\n        return vec4( 0.0, 0.0, 0.0, 2.0 );\n    }\n    \n    vec3 S = CartToBary( v3Start.xy );\n    vec3 E = CartToBary( v3End.xy );\n    \n    //Plug in eye ray and solve variables for root finding.\n    vec3 ES = E - S;\n    \n    float fA = dot( ES * ES, CP_2 ) + 2.0*dot( vec3(ES.y*ES.z, ES.x*ES.z, ES.x*ES.y), CP_0 );\n    \n    float fB = - (v3End.z - v3Start.z) + 2.0*( \n        dot( ES*S, CP_2 ) + \n        dot( vec3((ES.y*S.z + ES.z*S.y), (ES.x*S.z + ES.z*S.x), (ES.x*S.y + ES.y*S.x)), CP_0 ) );\n    \n    float fC = - v3Start.z + dot( S*S, CP_2 ) +\n    \t2.0*dot( vec3(S.y*S.z,S.x*S.z,S.x*S.y), CP_0 );\n    \n    //Actual root finding\n    float fRoot = fB*fB - 4.0*fA*fC;\n    if( fRoot >= 0.0 )\n    {\n        float fRootA = (-fB + sqrt( fRoot ) ) /( 2.0 * fA );\n        float fRootB = (-fB - sqrt( fRoot ) ) /( 2.0 * fA );\n        \n        if( fRootA >= 0.0 && fRootA <= 1.0 )\n        {\n            if( fRootB >= 0.0 )\n                fRootA = min( fRootB, fRootA );\n            \n            return vec4( S + fRootA*ES, fRootA );\n        }\n        \n        if( fRootB >= 0.0 && fRootB <= 1.0 )\n            return vec4( S + fRootB*ES, fRootB );\n    }\n    \n    return vec4(0.0, 0.0, 0.0, 2.0);\n}\n\n//---------------------------------------------------\n// Compute color based on bezier tri intersection + lighting\n//---------------------------------------------------\nvec4 ComputeBezierColor( vec3 v3CameraPos, vec3 v3LookDir, vec3 CP_2, vec3 CP_0 )\n{\n    vec4 v4ISect = BezierTriISect( v3CameraPos, v3LookDir, CP_2, CP_0 );\n    \n    vec3 v3Warm = vec3( 238.0, 197.0, 169.0 ) / 255.0;\n    vec3 v3Cool = vec3( 202.0, 185.0, 241.0 ) / 255.0;\n    vec3 v3Ambient = vec3( .5,.5,.5 );\n    \n    vec3 v3WarmPos = normalize( vec3(.7, .7, .7) ); \n    vec3 v3CoolPos = normalize( vec3(-.7, -.7, -.3) ); \n    \n    vec3 v3Color = vec3(0.0,0.0,0.0);\n    float fAlpha = 0.0;\n    if( v4ISect.w <= 1.0 )\n    {\n        vec3 v3Norm = BezierTriangle_Quadratic_Normal( v4ISect.xyz, CP_2, CP_0 );\n        \n        float fWarm = max( 0.0, dot( v3Norm, v3WarmPos ) );\n        float fCool = max( 0.0, dot( v3Norm, v3CoolPos ) );\n        \n        v3Color = 0.2*v3Ambient + v3Warm*fWarm + v3Cool*fCool;\n        \n        fAlpha = 1.0;\n    }\n    return vec4( v3Color.xyz, fAlpha );\n}\n\n\n//---------------------------------------------------\n// Overlay management\n//---------------------------------------------------\nfloat SphereISect( vec3 v3Camera, vec3 v3LookDir, vec4 v4Sphere )\n{       \n    vec3 v3Diff = v3Camera - v4Sphere.xyz;\n    float fA = dot(v3LookDir, v3Diff);\n    float fB = length( v3Diff );\n        \n    float fDelta = .0001;\n    float fSqrt = fA*fA - (fB*fB);\n    float fInner = fSqrt + v4Sphere.w*v4Sphere.w;\n    float fOuter = fSqrt + (v4Sphere.w+fDelta) * (v4Sphere.w+fDelta);\n     \n    return clamp( mix( 0.0, 1.0, fOuter / (fOuter - fInner ) ), 0.0, 1.0 );\n}\n\n\n//---------------------------------------------------\n// Compute overlay color\n//---------------------------------------------------\nfloat ComputeOverlay( vec3 v3Camera, vec3 v3LookAt, vec3 CP_2, vec3 CP_0 )\n{\n    float fDot = 0.0;\n    fDot += SphereISect( v3Camera, v3LookAt, vec4( v2VertA, \t\t\t\tCP_2.x, .2) );\n    fDot += SphereISect( v3Camera, v3LookAt, vec4( (v2VertA+v2VertB) * 0.5,\tCP_0.z, .2) );\n    fDot += SphereISect( v3Camera, v3LookAt, vec4( (v2VertC+v2VertA) * 0.5,\tCP_0.y, .2) );\n    fDot += SphereISect( v3Camera, v3LookAt, vec4( v2VertB, \t\t\t\tCP_2.y, .2) );\n    fDot += SphereISect( v3Camera, v3LookAt, vec4( (v2VertB+v2VertC) * 0.5,\tCP_0.x, .2) );\n    fDot += SphereISect( v3Camera, v3LookAt, vec4( v2VertC, \t\t\t\tCP_2.z, .2) );\n        \n    return fDot;\n}\n\n//---------------------------------------------------\n// Camera management\n//---------------------------------------------------\nvec3 GetCameraPos()\n{\n    vec2 v2Mouse = vec2( iMouse.xy / iResolution.xy ) * 10.0;\n    vec3 v3Pos = vec3(\n        sin(v2Mouse.x + iTime*.1), \n        cos(v2Mouse.x + iTime*.1), 1.0 );\n    \n    return normalize( v3Pos ) * 10.0;\n}\nvec3 GetLookDir( vec3 v3CameraPos, vec2 fragCoord )\n{\n    float fScale = tan( H_FOV_RADIANS );\n    float fAspectRatio = iResolution.x / iResolution.y;\n\tvec2 v2Screen = (2.0 * (fragCoord.xy / iResolution.xy) - 1.0) * vec2(fAspectRatio, 1.0) * fScale;\n   \n    vec3 v3Up = vec3(0.0, 0.0, 1.0);\n    vec3 v3Look = normalize( -v3CameraPos );\n    vec3 v3Left = cross( v3Up, v3Look );\n    v3Up = cross( v3Look, v3Left );\n    \n    v3Look += v3Left * v2Screen.x + v3Up * v2Screen.y;\n\treturn normalize( v3Look );\n}\n\n//---------------------------------------------------\n//---------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fAspectRatio = iResolution.x / iResolution.y;\n\tvec2 uv = (2.0 * (fragCoord.xy / iResolution.xy) - 1.0) * vec2(fAspectRatio, 1.0);\n    \n    vec3 v3Camera = GetCameraPos();\n    vec3 v3LookDir = GetLookDir( v3Camera, fragCoord);\n    \n    float fT = iTime;\n    vec3 CP_2 = vec3( f200 * sin(fT), f020 * sin(fT*1.2), f002 * sin(fT)*.9 );\n\tvec3 CP_0 = vec3( f011 * sin(fT*2.0), f101*sin(fT*1.1), f110 * sin(fT) );\n    \n    //Compute spline surface color\n    vec4 v4Color = ComputeBezierColor( v3Camera, v3LookDir, CP_2, CP_0 );\n    vec4 v4Final = mix( vec4( .5, .5, .5, 1.0 ), v4Color, v4Color.a );\n    \n    //Compute overlay\n    float fOverlay = ComputeOverlay( v3Camera, v3LookDir, CP_2, CP_0 );\n    \n    vec4 v4OverlayColor = vec4(.7,.7,.7,1);\n    v4Final = mix( v4Final, v4OverlayColor, fOverlay ); \n    \n\tfragColor = v4Final;\n}\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsjSDt","date":"1419886044","viewed":883,"name":"Bezier Triangle","username":"jjcoolkl","description":"Ray-intersection of a uni-variate quadratic Bezier triangle.  Unlike rectangular Bezier forms the Nth order simplex form is intrinsically Nth order, and so ray-intersection equation up through quartic can be solved in closed-form.","likes":31,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""}}