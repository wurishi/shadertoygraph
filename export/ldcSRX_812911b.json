{"ver":"0.1","info":{"id":"ldcSRX","date":"1460501535","viewed":275,"name":"Yuria Viewer with animation","username":"Marqin","description":"Julia Set constructed from -0.4 + 0.6i with simple looping animation.\n\nz - zoom in\nx - zoom out\narrows - move around\n\nC version - https://github.com/Marqin/YuriaViewer","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["procedural","2d","fractal","julia"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float loopTime = 35.0;\nconst int maxi = 1000;\nconst int vis = 50;\n\nconst vec2 txZoom = vec2(0.0, 0.0);\nconst vec2 txPosition = vec2(1.0, 0.0);\n\nstruct Camera {\n    vec2 position;\n    float zoom;\n};\n\nvec4 loadValue( in vec2 re )\n{\n    // loadValue from iq's shader - https://www.shadertoy.com/view/MddGzf\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\n\nvec3 color(in vec2 pos, in Camera cam)\n{\n    \n  float tmp = mod(iTime, 2.0*loopTime);\n  if(tmp > loopTime) {\n      tmp = loopTime - abs(loopTime-tmp);\n  }\n  float modifier = (tmp)/1500.0;\n  vec2 complex = vec2(-0.4+modifier, 0.6);\n\n  vec2 z;\n  z.x = 1.5 * pos.x/float(iResolution.x/2.0) - 1.5;\n  z.y = pos.y/float(iResolution.y/2.0) - 1.0;\n  z /= cam.zoom;\n  z += cam.position;\n    \n  int i = maxi;\n  for(int j = 0; j < 10000; j++) {\n    if( j >= maxi || length(z) > 2.0 ) {\n        i = j;\n        break;\n    }\n    z = mat2(z,-z.y,z.x)*z + complex;\n  }\n\n    \n  vec3 result = vec3(0.0, 0.0, 0.0);\n  if (i >= vis)\n  {\n    result = vec3(float(i)/float(maxi), 0.6, 1.0);\n  }\n  return result;\n}\n\nvec3 hsv2rgb(in vec3 c)\n{\n  // I found this in few public shaders \n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  Camera cam = Camera(loadValue(txPosition).xy, loadValue(txZoom).x);\n  vec3 col = hsv2rgb(color( fragCoord.xy, cam ));\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// loadValue(),storeValue() from iq's shader - https://www.shadertoy.com/view/MddGzf\n\n\n#define KEY_Z 90.0/255.0\n#define KEY_X 88.0/255.0\n#define KEY_LEFT 37.0/255.0\n#define KEY_UP 38.0/255.0\n#define KEY_RIGHT 39.0/255.0\n#define KEY_DOWN 40.0/255.0\n\n\nconst vec2 txZoom = vec2(0.0, 0.0);\nconst vec2 txPosition = vec2(1.0, 0.0);\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\n\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\nvoid storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 1.0;\n    vec2 position = vec2(0.0,0.0);\n\n    if( iFrame > 60 ) {\n       zoom = loadValue(txZoom).x;\n       position = loadValue(txPosition).xy;\n    }\n\n\n    if( texture( iChannel1, vec2(KEY_Z, 0.5) ).x > 0.0 ) {\n        zoom *= 2.0;\n    }\n    if( texture( iChannel1, vec2(KEY_X, 0.5) ).x > 0.0 ) {\n        zoom /= 2.0;\n    }\n\n    if( texture( iChannel1, vec2(KEY_LEFT, 0.5) ).x > 0.0 ) {\n        position.x -= 1.0/zoom;\n    }\n\n    if( texture( iChannel1, vec2(KEY_RIGHT, 0.5) ).x > 0.0 ) {\n         position.x += 1.0/zoom;\n    }\n\n    if( texture( iChannel1, vec2(KEY_UP, 0.5) ).x > 0.0 ) {\n         position.y += 1.0/zoom;\n    }\n\n    if( texture( iChannel1, vec2(KEY_DOWN, 0.5) ).x > 0.0 ) {\n         position.y -= 1.0/zoom;\n    }\n\n    storeValue( txZoom, vec4(zoom, 0.0, 0.0, 0.0), fragColor, fragCoord );\n    storeValue( txPosition, vec4(position, 0.0, 0.0), fragColor, fragCoord );\n}\n","name":"Buf A","description":"","type":"buffer"}]}