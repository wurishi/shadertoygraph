{"ver":"0.1","info":{"id":"sdjGRc","date":"1617801466","viewed":433,"name":"Paint Splatter Shader","username":"Neblig","description":"Simulates a paint splatter at each listed location and overlaps them.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["fractal","colors","paint","splat","splatter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAGIC_BOX_ITERS = 11; //Adjust this: higher = more detail, 11\nconst float MAGIC_BOX_MAGIC = .55; //This number is scary, dont mess with it, .55\n\nfloat centerThreshold = 0.0; //Closer they are, further it goes?\nfloat edgeThreshold = 80.0;\nfloat splatFalloffSize = .9;\nfloat splatCutoffSize = .9;\nvec4 defaultColor = vec4(0,0,0,0);\n \n//float temp = glutGet(GLUT_SCREEN_WIDTH/HEIGHT);\n\n\n//Fractal from https://www.shadertoy.com/view/4ljGDd\nfloat magicBox(vec3 p) {\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\n    // Take p anywhere in space and calculate the corresponding position\n    // inside the box, 0<(x,y,z)<1\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float lastLength = length(p);\n    float tot = 0.0;\n    // This is the fractal.  More iterations gives a more detailed\n    // fractal at the expense of more computation.\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\n      // The number subtracted here is a \"magic\" paremeter that\n      // produces rather different fractals for different values.\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\n      float newLength = length(p);\n      tot += abs(newLength-lastLength);\n      lastLength = newLength;\n    }\n\n    return tot;\n}\n\n\n// A random 3x3 unitary matrix, used to avoid artifacts from slicing the\n// volume along the same axes as the fractal's bounding box.\nconst mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                    0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                    -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n\n\nfloat euclideanDistance(vec2 a, vec2 b){\n    return sqrt(pow((a.x - b.x), 2.0) + pow((a.y - b.y), 2.0));\n}\n\nfloat lerp(float a, float b, float w)\n{\n  return a + w*(b-a);\n}\n\nbool inRange(vec2 a, vec2 b, float maxDist){\n    return (euclideanDistance(a, b)/iResolution.y) < maxDist;\n}\n\nvec4 overlayColors(vec4 first, vec4 second){\n    return first * first.w + second * (1.0 - first.w);\n}\n\nvec4 splatColor(vec2 splatCenter, vec4 paintColor, vec2 fragCoord, vec2 uv)\n{\n\n    //FRACTAL FUN:\n    // Rotate uv onto the random axes given by M, and scale\n    // it down a bit so we aren't looking at the entire\n    // 1x1x1 fractal volume.  Making the coefficient smaller\n    // \"zooms in\", which may reduce large-scale repetition\n    // but requires more fractal iterations to get the same\n    // level of detail.\n    vec3 p = 0.3*M*vec3(uv, 0.0);\n    \n    float result = magicBox(p);\n    // Scale to taste.  Also consider non-linear mappings.\n    //result *= 0.025; \n       //TODO: Scale to dist\n        //Removed this since can just scale threshold by distance\n        \n        \n    //Setup Colors (fun)\n    //vec3 paintColor = vec3(255.0, 0.0, 0.0);\n    //vec3 paintColor = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec4 retColor;\n    \n    //Now clamp them values\n    //Set threshold to inverse distance\n    float dist = euclideanDistance(fragCoord, splatCenter); //Pixels\n    float screenDist = dist/iResolution.y; //0 to 1 scale, percent of screen\n\n    //float threshold = centerThreshold + slope * adjDist; //.25\n    float threshold = lerp(centerThreshold, edgeThreshold, screenDist/splatFalloffSize);\n    \n    //circle\n    //if(screenDist/splatCutoffSize > splatCutoffSize){retColor = black;}\n    \n    if (result > threshold){\n        retColor = paintColor;\n    }else{\n        retColor = defaultColor;\n    }\n \n    \n\treturn retColor;\n}\n\n\nvec4 getOneSplat(vec2 splatCenter, vec4 paintColor, vec2 fragCoord, vec2 uv){\n    if(inRange(splatCenter, fragCoord, splatCutoffSize)){\n        return splatColor(splatCenter, paintColor, fragCoord, uv);\n    }\n    return defaultColor;\n}\n\n//Return the color at a point, (0,0,0) alpha 0 by default\n\nvec4 getSplatColorAtPixel(vec2 fragCoord, vec2 uv){\n    vec4 c1 = vec4(.0, 255.0, 0.0, 1.0);\n    \n    vec4 c2 = vec4(0.0, 255.0, 0.0, 1.0);\n    vec4 c3 = vec4(0.0, 0.0, 255.0, 1.0);\n    vec4 c4 = vec4(255.0, 0.0, 255.0, 1.0);\n    \n    vec2 s1 = vec2(400.0,250.0);\n    \n    vec2 s2 = vec2(200.0,200.0);\n    vec2 s3 = vec2(250.0,300.0);\n    vec2 s4 = vec2(300.0,200.0);\n    \n    vec4 retColor = defaultColor;\n    retColor = overlayColors(retColor, getOneSplat(s1, c1, fragCoord, uv));\n    //retColor = overlayColors(retColor, getOneSplat(s2, c2, fragCoord, uv));\n    //retColor = overlayColors(retColor, getOneSplat(s3, c3, fragCoord, uv));\n    //retColor = overlayColors(retColor, getOneSplat(s4, c4, fragCoord, uv));\n    return retColor;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n\n    // uv are screen coordinates, uniformly scaled to go from 0..1 vertically\n\tvec2 uv = fragCoord.xy / iResolution.yy;\n    \n    // scroll a certain number of screenfuls/second\n    uv.x += iTime * 0.2;\n    \n    //splatColor(s1, fragCoord, uv, c1);\n    vec4 dotColor = getSplatColorAtPixel(fragCoord,uv);\n    \n    //Alpha blending - replace black w Result from textures\n    vec4 result = overlayColors(dotColor, defaultColor);\n    \n    //vec2 temp = glGet(\"GL_VIEWPORT\");\n    \n    fragColor = result;\n}\n","name":"Image","description":"","type":"image"}]}