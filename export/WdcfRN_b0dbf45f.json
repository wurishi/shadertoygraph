{"ver":"0.1","info":{"id":"WdcfRN","date":"1604427425","viewed":326,"name":"Volumetrics sample","username":"Shcherbakov","description":"Sample from stream about simple volumetric rendering.\nStream: https://www.youtube.com/watch?v=FS1UIL1Td8I","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["volumetrics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265359;\n\nvec3 SPHERE_POS = vec3(0, 1.5, 1);\nfloat SPHERE_RADIUS = 2.0;\nvec3 SPHERE_COLOR = vec3(0.5, 0.5, 0.5);\n\nconst float MARCH_SIZE = 0.1;\nfloat LIGHT_MARCH_SIZE = MARCH_SIZE * 4.0;\nint MAX_STEPS = 100;\nint LIGHT_MAX_STEPS = 25;\nfloat ABSORPTION = 0.5;\n\nfloat sphereSdf(vec3 pos) {\n    float scale = mix(0.25, 1.0, 0.0);\n    return length((pos - SPHERE_POS) * vec3(scale, 1.0, scale)) - SPHERE_RADIUS;\n}\n\nfloat BeerLambert(float absorptionCoefficient, float distanceTraveled)\n{\n    return exp(-absorptionCoefficient * distanceTraveled);\n}\n\nfloat fogDensity(vec3 currentPos, float sdf) {\n    vec3 localCurrentPos = currentPos - SPHERE_POS;\n    vec2 rotate1 = vec2(cos(iTime), -sin(iTime));\n    vec2 rotate2 = vec2(sin(iTime), cos(iTime));\n    localCurrentPos.xz = vec2(dot(rotate1, localCurrentPos.xz), dot(rotate2, localCurrentPos.xz));\n    float density = texture(iChannel1, (SPHERE_POS + localCurrentPos) * 0.05).r;\n    return min(density, -sdf);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 LIGHT_POS = vec3(0, 5, 0);\n    vec3 LIGHT_COLOR = vec3(0.75, 1, 1);\n    float LIGHT_INNER_RADIUS = 3.5;\n    float LIGHT_RADIUS = 5.0;\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 cameraPos = vec3(0, 3, -8);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec3 front = normalize(vec3(0, -2, 4));\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    vec3 viewVec = normalize(front + up * uv.y + right * uv.x);\n    // viewVec.y * t + cameraPos.y == 0\n    // t = -cameraPos.y / viewVec.y;\n    float dist = (-cameraPos.y / viewVec.y);\n    vec3 floorIntersect = cameraPos + viewVec * dist;\n    vec2 floorTexTC = floorIntersect.xz * 0.2;\n    vec2 rotate1 = vec2(sin(PI / 4.0), cos(PI / 4.0));\n    vec2 rotate2 = vec2(cos(PI / 4.0), -sin(PI / 4.0));\n    floorTexTC = vec2(dot(floorTexTC, rotate1), dot(floorTexTC, rotate2));\n    vec3 color = texture(iChannel0, floorTexTC).rgb;\n\tvec3 worldPos = floorIntersect;    \n    vec3 normal = vec3(0, 1, 0);\n    vec3 toLight = LIGHT_POS - worldPos;\n    float NoL = max(0.0, dot(normal, normalize(toLight)));\n    float atten = clamp((LIGHT_RADIUS - length(toLight) + LIGHT_INNER_RADIUS) / (LIGHT_RADIUS - LIGHT_INNER_RADIUS), 0.0, 1.0);\n\n    vec3 AMBIENT_LIGHT = vec3(0.1, 0.1, 0.1);\n    vec3 result = color * (NoL * atten * LIGHT_COLOR + AMBIENT_LIGHT);\n    float opacity = 1.0;\n    vec3 fogEffect = vec3(0.0);\n    vec3 FOG_COLOR = vec3(0.5, 0.9, 0.5);\n    \n    for (int i = 0; i < MAX_STEPS; ++i) {\n        if (dist < MARCH_SIZE * float(i)) {\n            break;\n        }\n        vec3 currentPos = cameraPos + viewVec * MARCH_SIZE * float(i);\n        float sdf = sphereSdf(currentPos);\n        if (sdf < 0.0) {\n            float prevOpacity = opacity;\n            \n            opacity *= BeerLambert(ABSORPTION * fogDensity(currentPos, sdf), MARCH_SIZE);\n            float absorbtion = prevOpacity - opacity;\n            vec3 fogColorAtPoint = texture(iChannel2, currentPos * 0.05 + vec3(0, iTime * 0.05, 0)).rgb * 2.0;\n            fogEffect += vec3(absorbtion) * fogColorAtPoint * AMBIENT_LIGHT;\n            \n            vec3 toLight = LIGHT_POS - currentPos;\n            vec3 toLightDir = normalize(toLight);\n            float atten = clamp((LIGHT_RADIUS - length(toLight) + LIGHT_INNER_RADIUS) / (LIGHT_RADIUS - LIGHT_INNER_RADIUS), 0.0, 1.0);\n            float lightOpacity = 1.0;\n            for (int j = 0; j < LIGHT_MAX_STEPS; ++j) {\n                vec3 toLightPos = currentPos + toLightDir * LIGHT_MARCH_SIZE * float(j);\n                float sdf = sphereSdf(toLightPos);\n                if (sdf < 0.0) {\n                    lightOpacity *= BeerLambert(ABSORPTION * fogDensity(toLightPos, sdf), LIGHT_MARCH_SIZE);\n                }\n            }\n            fogEffect += fogColorAtPoint * LIGHT_COLOR * absorbtion * atten * lightOpacity;\n        }\n    }\n    result = mix(fogEffect, result, opacity);\n    \n    // Output to screen\n    fragColor = vec4(result,1.0);\n}","name":"Image","description":"","type":"image"}]}