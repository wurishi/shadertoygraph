{"ver":"0.1","info":{"id":"mdKyRG","date":"1696268240","viewed":65,"name":"Smooth vesica SDF (composite)","username":"Envy24","description":".","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf","smooth","vesica"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCENE_SCALE               ( 1.0 )\n#define AA_UNIT                   ( (SCENE_SCALE*3.0) / iResolution.y  )\n#define SMAA(d)                   ( smoothstep(AA_UNIT, 0., d) )\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\n/* Vesica SDF */\nfloat circleSDF(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\nfloat vesicaSDF(vec2 NDC, vec2 C, float rad, float r)\n{\n    // Inverse rotation column major matrix.\n    mat2 inv = mat2(cos(rad), -sin(rad), sin(rad), cos(rad));\n    // Apply inverse translation and rotation.\n    NDC = inv * (NDC - C);\n    \n    float dl = circleSDF(NDC, vec2(-0.25,0), r),\n          dr = circleSDF(NDC, vec2( 0.25,0), r);\n    return opSmoothIntersection(dl, dr, 0.1);\n}\n/* !Vesica SDF */\n\n/* https://www.shadertoy.com/view/ddfGz2 */\nvec3 colorize_field(float dist, vec3 color)\n{    \n    float F = 30., freq = F*dist, aa = 1./F, C = 0.7, amp = 0.2, width = F*0.01, //0.3\n          waves_sdf = C + amp*smoothstep(4./iResolution.y, 0., (width+cos(freq)) * aa),\n          exp_raise = 1. - exp(-4.*abs(dist));\n        \n    color = 1.0 - sign(dist) * color; // Change color if dist is negative. \n    color *= exp_raise;               // Attenuate color around edges.     \n    color *= waves_sdf;               // Add waves.\n    \n    return mix(color, vec3(1), smoothstep(4./iResolution.y, 0., abs(dist)) );\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0), false);\n\n    float min_d = vesicaSDF(NDC, vec2(0), triangleOSC(-1., 1., iTime), .7);\n    \n    O = vec4(colorize_field(min_d, vec3(.1, .4, .7)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns triangle wave in range [min, max]. */\nfloat triangleOSC(float min, float max, float T)\n{\n    const float invTAU = 0.1591549430918953;\n          T *= invTAU;          // scale T so that seq 0, 1, 2,... maps to 0, TAU, 2.*TAU, ...\n          T = fract(T);         // wrap T in range [0; TAU];\n    float y = T;                // y range is [0; 1]\n          y = 2.* y - 1.0;      // max from [0; 1] to [-1; 1]\n          y = y > 0.0 ? -y : y; // invert second half of period, new range [-1; 0]\n          y += 1.;              // shift from [-1; 0] to [0; 1]\n    return min + y*(max - min); // map y from [0, 1] to [min; max]\n}","name":"Common","description":"","type":"common"}]}