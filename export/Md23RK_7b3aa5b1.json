{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"float time;\nvec3 pln;\n\nfloat terrain(vec3 p)\n{\n\tfloat nx=floor(p.x)*10.0+floor(p.z)*100.0,center=0.0,scale=2.0;\n\tvec4 heights=vec4(0.0,0.0,0.0,0.0);\n\t\n\tfor(int i=0;i<5;i+=1)\n\t{\n\t\tvec2 spxz=step(vec2(0.0),p.xz);\n\t\tfloat corner_height = mix(mix(heights.x, heights.y, spxz.x),\n\t\t\t\t\t\t\t\t  mix(heights.w, heights.z, spxz.x),spxz.y);\n\t\t\n\t\tvec4 mid_heights=(heights+heights.yzwx)*0.5;\n\t\t\n\t\theights =mix(mix(vec4(heights.x,mid_heights.x,center,mid_heights.w),\n\t\t\t\t\t     vec4(mid_heights.x,heights.y,mid_heights.y,center), spxz.x),\n\t\t\t\t\t mix(vec4(mid_heights.w,center,mid_heights.z,heights.w), \n\t\t\t\t\t\t vec4(center,mid_heights.y,heights.z,mid_heights.z), spxz.x), spxz.y);\n\t\t\n\t\tnx=nx*4.0+spxz.x+2.0*spxz.y;\n\t\t\n\t\tcenter=(center+corner_height)*0.5+cos(nx*20.0)/scale*30.0;\n\t\tp.xz=fract(p.xz)-vec2(0.5);\n\t\tp*=2.0;\n\t\tscale*=2.0;\n\t}\n\t\n\t\t\n\tfloat d0=p.x+p.z;\n\t\n\tvec2 plh=mix( mix(heights.xw,heights.zw,step(0.0,d0)),\n\t\t\t\t  mix(heights.xy,heights.zy,step(0.0,d0)), step(p.z,p.x));\n\t\n\tpln=normalize(vec3(plh.x-plh.y,2.0,(plh.x-center)+(plh.y-center)));\n\n\tif(p.x+p.z>0.0)\n\t\tpln.xz=-pln.zx;\n\t\n\tif(p.x<p.z)\n\t\tpln.xz=pln.zx;\n\t\n\tp.y-=center;\t\n\treturn dot(p,pln)/scale;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ttime=iTime*0.4;\n\tvec2 uv=(fragCoord.xy / iResolution.xy)*2.0-vec2(1.0);\n\tuv.x*=iResolution.x/iResolution.y;\n\t\n\tfloat sc=(time+sin(time*0.2)*4.0)*0.8;\n\tvec3 camo=vec3(sc+cos(time*0.2)*0.5,0.7+sin(time*0.3)*0.4,0.3+sin(time*0.4)*0.8);\n\tvec3 camt=vec3(sc+cos(time*0.04)*1.5,-1.5,0.0);\n\tvec3 camd=normalize(camt-camo);\n\t\n\tvec3 camu=normalize(cross(camd,vec3(0.5,1.0,0.0))),camv=normalize(cross(camu,camd));\n\tcamu=normalize(cross(camd,camv));\n\t\n\tmat3 m=mat3(camu,camv,camd);\n\t\n\tvec3 rd=m*normalize(vec3(uv,1.8)),rp;\n\t\n\tfloat t=0.0;\n\t\n\tfor(int i=0;i<100;i+=1)\n\t{\n\t\trp=camo+rd*t;\n\t\tfloat d=terrain(rp);\n\t\tif(d<4e-3)\n\t\t\tbreak;\n\t\tt+=d;\n\t}\n\n\tvec3 ld=normalize(vec3(1.0,0.6,2.0));\n\tfragColor.rgb=mix(vec3(0.1,0.1,0.5)*0.4,vec3(1.0,1.0,0.8),pow(0.5+0.5*dot(pln,ld),0.7));\n\tfragColor.rgb=mix(vec3(0.5,0.6,1.0),fragColor.rgb,exp(-t*0.02));\n\t\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Md23RK","date":"1391124356","viewed":2521,"name":"Polygonal Terrain","username":"fizzer","description":"An experiment to produce a terrain using a variant of the diamond-square algorithm. Requires optimisation.","likes":82,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","terrain","polygon","lowpoly","minimalist"],"hasliked":0,"parentid":"","parentname":""}}