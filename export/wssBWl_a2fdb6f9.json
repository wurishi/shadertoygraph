{"ver":"0.1","info":{"id":"wssBWl","date":"1589294015","viewed":91,"name":"Messerschmitt Bf 109","username":"BAntDit","description":"WWII plane","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["plane"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// FXAA based on implementation: https://www.geeks3d.com/20110405/fxaa-fast-approximate-anti-aliasing-demo-glsl-opengl-test-radeon-geforce/3/\n\n#define FXAA_SPAN_MAX 8.0\n#define FXAA_REDUCE_MUL 1.0 / 8.0\n#define FXAA_REDUCE_MIN 1.0 / 128.0\n\nconst vec3 luma = vec3(0.299, 0.587, 0.114);\n\nfloat fxaaLuma(in vec3 rgb) {\n    return dot(rgb, luma); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 texelSize = vec2(1.0) / iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n\t\t\t\n    float lumaM = fxaaLuma(col);\n    \n\tfloat lumaNW = fxaaLuma(texture(iChannel0, uv + vec2(-texelSize.x, -texelSize.y)).rgb);\n\tfloat lumaNE = fxaaLuma(texture(iChannel0, uv + vec2(+texelSize.x, -texelSize.y)).rgb);\n\tfloat lumaSW = fxaaLuma(texture(iChannel0, uv + vec2(-texelSize.x, +texelSize.y)).rgb);\n\tfloat lumaSE = fxaaLuma(texture(iChannel0, uv + vec2(+texelSize.x, +texelSize.y)).rgb);\n                            \n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE))); \n                            \n    vec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE))); \n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\t  \n\tfloat rcpDirMin = 1. / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\t\n\tdir = min(\n        vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX), \n       \tmax(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * rcpDirMin)) * texelSize;                       \n                            \n    \n   \tvec3 rgbA = .5 * (texture(iChannel0, uv + dir * (1. / 3. - .5)).rgb  \n                      + texture(iChannel0, uv + dir * (2. / 2. - .5)).rgb);\n                            \n    vec3 rgbB = rgbA * .5 + .25 *\n\t\t(texture(iChannel0, uv + dir * (0. / 3. - .5)).rgb \n         + texture(iChannel0, uv + dir * (3. / 3. - .5)).rgb);\n    \n    float lumaB = dot(rgbB, luma);                        \n                            \n    fragColor.rgb = ((lumaB < lumaMin) || (lumaB > lumaMax)) ? rgbA : rgbB;   \n                           \n    fragColor.a = 1.0;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nconst float epsilon = 0.1e-4;\nconst float PI = 3.141592653589793;\nconst float RECEIPROCAL_PI = 1.0 / 3.141592653589793;\n\nfloat random(in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = random(i + vec2(0., 0.));\n    float b = random(i + vec2(1., 0.));\n    float c = random(i + vec2(0., 1.));\n    float d = random(i + vec2(1., 1.));\n\n    vec2 u = f * f * (3. - 2. * f);\n\n    return mix(a, b, u.x)\n        + (c - a) * u.y * (1.0 - u.x)\n        + (d - b) * u.x * u.y;\n}\n\nfloat opU(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nvec4 plainIntersect(in vec3 ro, in vec3 rd, in vec4 p)\n{\n    float t = -(dot(ro, p.xyz) + p.w) / dot(rd, p.xyz);\n\n    return vec4(t, p.xyz);\n}\n\n\nfloat sdBox(in vec3 p, in vec3 b)\n{\n    vec3 q = abs(p) - b;\n\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdMisc(in vec3 p, in float d, in vec3 l, in vec4 s) { // .7071\n    p.z += 1.9;\n    p.y += 0.06;\n\n    float ss = floor(l.x * 34.) * 0.1;\n\n    p.z -= ss * step(l.x, 0.145);\n\n    p.xz = vec2(p.x * l.y + p.z * l.z, p.z * l.y - p.x * l.z);\n\n    vec3 pp1 = p;\n    vec3 pp2 = p;\n\n    pp1.x -= max(s.x, min(s.y, pp1.x));\n    pp2.x -= max(s.z, min(s.w, pp2.x));\n\n    d = max(opU(d, length(pp1) - 0.015, 0.005), 0.0135 - length(pp2));\n\n    return d;\n}\n\nvec4 fuselage(in vec3 pos) {\n    vec3 p1 = pos;\n\n    float hl = 1.8;\n\n    float l = max(-hl, min(hl, p1.z));\n\n    float u = (l + hl) / (2. * hl);\n\n    p1.z -= l;\n\n    float bhh = 0.125;\n    float thh = 0.125;\n\n    bhh = -bhh + (1. - smoothstep(.0, hl, hl - abs(l + 0.25))) * bhh;\n    thh = thh - (1. - smoothstep(.0, hl, hl - abs(l + 0.25))) * thh;\n\n    p1.y -= max(bhh, min(thh, p1.y));\n\n    float h = max(-0.125, min(0.125, pos.y));\n    float v = (h + 0.125) / 0.25;\n\n    float r = 0.16;\n    r = r - step(0., l) * (l / hl) * 0.06;\n\n    float d = length(p1) - r;\n\n    vec3 p2 = pos;\n\n    p2.z += 1.32; // 1.62\n\n    vec3 p3 = p2;\n    vec3 p4 = p2;\n\n    p3.y -= 0.14;\n    p4.y -= 0.14;\n    p3.x += 0.08;\n    p4.x -= 0.08;\n\n    vec3 p5 = p3;\n    vec3 p6 = p4;\n\n    p3.z -= max(-0.01, min(0.05, p3.z));\n    p4.z -= max(-0.01, min(0.05, p4.z));\n\n    float d1 = length(p3) - 0.045;\n    float d2 = length(p4) - 0.045;\n\n    d = opU(d, d1, 0.05);\n    d = opU(d, d2, 0.05);\n\n    p5.x += 0.02;\n    p5.y -= 0.045;\n    p5.z += 0.26;\n    p5.z -= max(-0.13, min(0.13, p5.z));\n    float d3 = length(p5) - 0.04;\n\n    p6.x -= 0.02;\n    p6.y -= 0.045;\n    p6.z += 0.26;\n    p6.z -= max(-0.13, min(0.13, p6.z));\n    float d4 = length(p6) - 0.04;\n\n    d = max(d, -d3);\n    d = max(d, -d4);\n\n    vec3 p7 = p2;\n    p7.z += 0.65;\n\n    p7.z -= max(-0.09, min(0.05, p7.z));\n\n    float d5 = length(p7) - 0.09;\n\n    d = max(d, -d5);\n\n    vec3 p8 = pos;\n    p8.z += 1.418;\n    p8.x += 0.08;\n    p8.y -= 0.16;\n    p8.z -= min(-0.01, max(0.01, p8.z));\n\n    d = max(d, -length(p8) + 0.01);\n\n    vec3 p9 = pos;\n    p9.z += 1.418;\n    p9.x -= 0.08;\n    p9.y -= 0.16;\n    p9.z -= min(-0.01, max(0.01, p9.z));\n\n    d = max(d, -length(p9) + 0.01);\n    \n    d = sdMisc(pos, d, vec3(u, .7071, .7071), vec4(0., .24, 0., .26));\n    d = sdMisc(pos, d, vec3(u, .7071, -.7071), vec4(-0.24, .0,  -0.26, .0));\n\n    vec3 p10 = pos;\n\n    p10.z += 1.6;\n    p10.y += 0.145;\n\n    float d6 = max(sdBox(p10, vec3(0.078, 0.055, 0.15)), -sdBox(p10, vec3(0.07, 0.047, 0.16)));\n\n    d = opU(d, d6, 0.02);\n\n    return vec4(d, 1. - u, v, 4.);\n}\n\nvec4 wings(in vec3 pos) {\n    float hw = 1.9;\n\n    pos.z += 0.6;\n    pos.y += 0.125;\n\n    float w = max(-hw, min(hw, pos.x));\n\n    float v = (w + hw) / (2. * hw);\n\n    float thd = mix(0.55, 0.15, abs(w / hw));\n    float bhd = mix(0.27, 0.16, abs(w / hw));\n\n    float d = max(-thd, min(bhd, pos.z));\n\n    float u = (d + abs(bhd)) / (abs(thd) + bhd);\n\n    pos.x -= w;\n    pos.z -= d;\n\n    return vec4(length(pos) - 0.05 + 0.03 * smoothstep(0.0, hw, abs(w)), 1. - u, v, 3.);\n}\n\nvec4 stabilators(in vec3 pos) {\n    float hw = 0.7;\n\n    pos.y -= 0.15;\n    pos.z -= 1.55;\n\n    float w = max(-hw, min(hw, pos.x));\n\n    float v = (w + hw) / (2. * hw);\n\n    float thd = mix(0.4, 0.15, abs(w) / hw);\n    float bhd = mix(0.25, 0.1, abs(w) / hw);\n\n    float d = max(-thd, min(bhd, pos.z));\n\n    float u = (d + abs(bhd)) / (abs(thd) + bhd);\n\n    pos.x -= w;\n    pos.z -= d;\n\n    return vec4(length(pos) - 0.02, 1. - u, v, 2.);\n}\n\nvec4 fin(in vec3 pos) {\n    pos.z -= 1.55;\n\n    float h = max(0., min(.6, pos.y));\n\n    float v = h / .6;\n\n    float thd = mix(0.5, 0.15, h / 0.6);\n    float bhd = mix(0.3, 0.1, h / 0.6);\n\n    float d = max(-thd, min(bhd, pos.z));\n\n    float u = (d + thd) / (thd + bhd);\n\n    pos.y -= h;\n    pos.z -= d;\n\n    return vec4(length(pos) - 0.04 + 0.03 * smoothstep(0.0, .6, h), 1. - u, v, 2.);\n}\n\nvec4 propeller(in vec3 pos, in float time) {\n    vec3 p1 = pos;\n\n    p1.z += 1.91;\n    float h = max(-0.04, min(0.04, p1.z));\n    p1.z -= h;\n\n    float u = (h + 0.04) / 0.08;\n\n    float d = length(p1) - 0.085;\n\n    float stp = PI * 2. / 3.;\n    float spd = 2. * PI;\n\n    float m = 7.;\n\n    for (int i = 0; i < 3; i++) {\n        vec3 p2 = pos;\n\n        float phi = stp * float(i) + spd * time;\n\n        float x = cos(phi) * p2.x - sin(phi) * p2.y;\n        float y = sin(phi) * p2.x + cos(phi) * p2.y;\n\n        p2.x = x;\n        p2.y = y;\n\n        p2.z += 1.97;\n        p2.y -= 0.21;\n\n        float h = max(-0.24, min(0.24, p2.y));\n\n        float hw = 0.025;\n        hw = hw - (1. - smoothstep(.0, 0.24, 0.24 - abs(h * 0.7))) * hw;\n\n        float w = max(-hw, min(hw, p2.x));\n\n        p2.y -= h;\n        p2.x -= w;\n\n        float d1 = length(p2) - 0.0025;\n\n        m = d1 < d ? 8. : m;\n\n        d = opU(d, d1, 0.003);\n    }\n\n    vec3 p3 = pos;\n\n    p3.z += 2.03;\n    p3.z -= max(-0.0025, min(0.0025, p3.z));\n\n    float d2 = length(p3) - 0.02;\n\n    d = max(d, -d2);\n\n    vec3 p4 = pos;\n    p4.z += 2.03;\n    p4.z -= max(-0.08, min(0.02, p4.z));\n\n    float d3 = length(p4) - 0.01;\n\n    d = max(d, -d3);\n\n    return vec4(d, 1. - u, 0., m);\n}\n\nvec4 canopy(in vec3 pos) {\n    vec3 p1 = pos;\n    vec3 p2 = pos;\n\n    pos.y -= 0.2;\n    pos.z += 0.4;\n\n    float hl = .5;\n    float l = max(-hl, min(hl, pos.z));\n    float l2 = max(-0.55, min(0.55, pos.z));\n\n    float u = (l2 + 0.55) / 1.1;\n\n    float hh = .05;\n    float h = max(-hh , min(hh, pos.y));\n\n    pos.z -= l;\n    pos.y -= h;\n\n    float wh = 0.1;\n    float w = max(-wh , min(wh, pos.x));\n    float v = (w + wh) / (2. * wh);\n\n    float d = length(pos)\n        - step(l, 0.) * mix(0.085, 0.12, 1. - abs(l) / hl)\n        - step(0., l) * mix(0.12, 0.02, abs(l) / hl);\n\n    p1.y -= 0.32;\n    p1.z += 1.02;\n\n    {\n        float y = cos(PI / 3.) * p1.y - sin(PI / 3.) * p1.z;\n        float z = sin(PI / 3.) * p1.y + cos(PI / 3.) * p1.z;\n\n        p1.y = y;\n        p1.z = z;\n    }\n\n    float d1 = sdBox(p1, vec3(0.098));\n\n    p2.y -= 0.39;\n    p2.z += 0.67;\n\n    {\n        float y = cos(PI / 26.) * p2.y - sin(PI / 26.) * p2.z;\n        float z = sin(PI / 26.) * p2.y + cos(PI / 26.) * p2.z;\n\n        p2.y = y;\n        p2.z = z;\n    }\n\n    float d2 = sdBox(p2, vec3(0.1, 0.05, 0.25));\n\n    d = max(d, -d1);\n\n    d = max(d, -d2);\n\n    return vec4(d, 1. - u, v, 6.);\n}\n\nvec4 guns(in vec3 pos) {\n    pos.z += 1.5;\n    pos.y -= 0.16;\n\n    vec3 p1 = pos;\n    p1.x -= 0.08;\n\n\n    vec3 p2 = p1;\n    p2.z += 0.0035;\n\n    p1.z -= max(0., min(0.2, p1.z));\n\n    float d1 = length(p1) - 0.005;\n    float d2 = length(p2) - 0.0035;\n\n    vec3 p3 = pos;\n    p3.x += 0.08;\n\n    vec3 p4 = p3;\n    p4.z += 0.0035;\n\n    p3.z -= max(0., min(0.2, p3.z));\n\n    float d3 = length(p3) - 0.005;\n    float d4 = length(p4) - 0.0035;\n\n    float d = min(max(d1, -d2), max(d3, -d4));\n\n    return vec4(d, 0., 0., 5.);\n}\n\nvec4 antenna(in vec3 pos) {\n    vec3 p1 = pos;\n    vec3 p2 = pos;\n\n    p1.y -= .3;\n    p1.z += 0.35;\n\n    p2.y -= .6;\n    p2.z -= 1.39;\n\n    p1.yz = vec2(p1.y * 0.9659 + p1.z * 0.2588, p1.z * 0.9659 - p1.y * 0.2588);\n    p2.yz = vec2(p2.y * 0.7071 - p2.z * 0.7071, p2.y * 0.7071 + p2.z * 0.7071);\n\n    float h = max(0., min(0.35, p1.y));\n    p1.y -= h;\n\n    p2.y -= max(0., min(0.05, p2.y));\n\n    float d = min(length(p1) - mix(0.01, 0.004, h / 0.35), length(p2) - 0.006);\n\n    vec3 p3 = pos;\n\n    p3.y -= 0.63;\n    p3.z -= 0.54;\n\n    p3.z -= max(-.81, min(.81, p3.z));\n\n    float d1 = length(p3) - 0.0015;\n\n    float m = d1 < d ? 5. : 7.;\n\n    d = min(d1, d);\n\n    return vec4(d, 0., 0., m);\n}\n\nvec4 map(in vec3 pos, in float time) {\n    float d = 10. + epsilon;\n\n    vec3 uvm = vec3(0);\n\n    {\n        vec4 res = fuselage(pos);\n        uvm = res.x < d ? res.tpq : uvm;\n\n        d = min(d, res.x);\n    }\n\n    {\n        vec4 res = wings(pos);\n        uvm = res.x < d ? res.tpq : uvm;\n\n        d = opU(res.x, d, 0.02);\n    }\n\n    {\n        vec4 res = fin(pos);\n        uvm = res.x < d ? res.tpq : uvm;\n\n        d = opU(res.x, d, 0.02);\n    }\n\n    {\n        vec4 res = stabilators(pos);\n        uvm = res.x < d ? res.tpq : uvm;\n\n        d = opU(res.x, d, 0.02);\n    }\n\n    {\n        vec4 res = propeller(pos, time);\n        uvm = res.x < d ? res.tpq : uvm;\n\n        d = min(d, res.x);\n    }\n\n    {\n        vec4 res = canopy(pos);\n        uvm = res.x < d? res.tpq : uvm;\n\n        d = opU(d, res.x, 0.04);\n    }\n\n    {\n        vec4 res = guns(pos);\n        uvm = res.x < d ? res.tpq : uvm;\n\n        d = min(d, res.x);\n    }\n    \n    {\n        vec4 res = antenna(pos);\n        uvm = res.x < d ? res.tpq : uvm;\n\n        d = opU(d, res.x, 0.01);\n    }\n\n    return vec4(d, uvm.s, uvm.t, uvm.p);\n}\n\nvec3 calcNormal(in vec3 p, in float time)\n{\n    const float h = epsilon;\n    const vec2 k = vec2(1.0, -1.0);\n\n    return normalize(\n        k.xyy * map(p + k.xyy * h, time).x +\n        k.yyx * map(p + k.yyx * h, time).x +\n        k.yxy * map(p + k.yxy * h, time).x +\n        k.xxx * map(p + k.xxx * h, time).x);\n}\n\nvec4 raymarch(in vec3 ro, in vec3 rd, in vec2 bounds, in float time) {\n    float far = bounds.y;\n    float near = bounds.x;\n    float d = near;\n    vec3 uvm = vec3(0.);\n\n    for (int i = 0; i < 64 && d < far; i++) {\n        vec3 pos = ro + rd * d;\n\n        vec4 res = map(pos, time);\n\n        float h = res.x;\n\n        uvm = res.gba;\n\n        if (abs(h) < near) break;\n\n        d += h;\n    }\n\n    return vec4(d, uvm.r, uvm.g, uvm.b);\n}\n\nfloat calcAO(in vec3 pos, in vec3 nor, in float time)\n{\n    float occ = 0.0;\n    float sca = 1.0;\n\n    for(int i = 0; i < 8; i++) { // ao samples\n        float hr = 0.01 + 0.06 * float(i) / 8.0;\n\n        vec3 aopos =  nor * hr + pos;\n\n        float dd = map(aopos, time).x;\n\n        occ += -(dd - hr) * sca;\n\n        sca *= 0.95;\n    }\n\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0) * (0.5 + 0.5 * nor.y);\n}\n\nfloat calcSoftshadow(in vec3 ro, in vec3 rd, in vec2 bounds, in float time)\n{\n    float res = 1.0;\n    float d = bounds.x;\n\n    for(int i = 0; i < 32; i++)\n    {\n        float h = map(ro + rd * d, time).x;\n        float s = clamp(100.0 * h / d, 0.0, 1.0);\n\n        res = min(res, s * s * (3.0 - 2.0 * s));\n\n        d += clamp(h, bounds.x, 0.15);\n\n        if (res < bounds.x || d > bounds.y) break;\n    }\n\n    return clamp(res, 0.0, 1.0);\n}\n\n\nfloat grid(in vec2 p)\n{\n    const float N = 40.0; // grid ratio\n\n    vec2 w = max(abs(dFdx(p)), abs(dFdy(p))) + 0.001;\n\n    vec2 a = p + 0.5 * w;\n    vec2 b = p - 0.5 * w;\n\n    vec2 i = (floor(a) + min(fract(a) * N, 1.0) - floor(b) - min(fract(b) * N, 1.0)) / (N*w);\n\n    return max(0.6, (1.0 - i.x) * (1.0 - i.y));\n}\n\nvec3 camo(in vec2 uv, in vec2 scale) {\n    float n = noise(uv * scale);\n    float n2 = noise((uv + vec2(.5)) * scale);\n    float f1 = max((n - 0.5) * 2., 0.);\n    float f2 = n2;\n\n    return mix(\n        mix(vec3(0.20471, 0.25084, 0.212044), vec3(0.499505, 0.4819522, 0.35374), f1),\n        vec3(0.2888159, 0.31118, 0.215764), f2);\n}\n\nvec3 fuselagePaint(in vec2 uv) {\n    return mix(camo(uv, vec2(24., 4.)), vec3(0.40471, 0.45084, 0.212044), step(0.86, uv.s) * step(uv.t, 0.26));\n}\n\nvec3 canopyPaint(in vec2 uv, inout float roughness, inout vec3 f0) {\n    float v = 1. - uv.s;\n\n    float f = min(1.,\n        step(.14, uv.t) * step(uv.t, .22)\n        + step(.78, uv.t) * step(uv.t, .86)\n        + step(.035, v) * step(v, 0.055)\n        + step(.25, v) * step(v, 0.275)\n        + step(.46, v) * step(v, 0.5));\n\n    vec3 c = mix(vec3(0.789313, 0.907547, 1.), vec3(0.40471, 0.45084, 0.212044), f);\n\n    float front = step(0.5, uv.s);\n    float back = step(uv.s, 0.5);\n\n    vec3 albedo = camo(uv, vec2(2., 0.1)) * back + c * front;\n\n    f0 = mix(mix(f0, albedo, 0.8), f0, f) * front + f0 * back;\n\n    roughness = mix(0.3, roughness, f) * front + roughness * back;\n\n    return albedo;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec4 mouse = iMouse.xyzw / iResolution.xyxy;             \n    \n    vec3 ro = \n        step(iMouse.x, 0.1e-4) * vec3(3.0 * -.5, 0.7, 3.0 * -.866) + // initial pos\n        step(0.1e-4, iMouse.x) * vec3(3.0 * cos(2.8 * mouse.x), 2. * mouse.y + 0.5, 3.0 * sin(2.8 * mouse.x - PI));\n\n    vec3 ta = vec3(0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, up));\n    vec3 vv = normalize(cross(uu, ww));\n    \n    vec3 light = normalize(vec3(-1.57703, 1.57703, 1.57703));\n    \n    vec3 col = vec3(0.);\n    \n    float far = 8.0;\n    vec2 bounds = vec2(epsilon, far);\n      \n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec3 p = vec3(2.0 * uv - 1., 1.) * vec3(iResolution.x / iResolution.y, 1., 1.);\n\n    vec3 rd = normalize(p.x * uu + p.y * vv + p.z * ww);\n\n    col = mix(vec3(0.0, 0.509, 0.49), vec3(0.8, 0.94, 1.0), uv.y);\n\n    vec4 res = raymarch(ro, rd, bounds, iTime);\n\n    uv = res.yz;\n\n    float d = res.x;\n    float m = res.w;\n\n    vec3 albedo = vec3(0.8, 0.7, 0.7);\n\n    vec4 plain = plainIntersect(ro, rd, vec4(0.0, 1.0, 0.0, 0.75));\n\n    if (plain.x > 0.0) {\n        vec3 pos = ro + rd * plain.x;\n        vec3 norm = vec3(0.0, 1.0, 0.0);\n\n        float nl = clamp(dot(norm, light), 0.0, 1.0);\n\n        vec3 diff = vec3(nl) * albedo * RECEIPROCAL_PI;\n        vec3 amb = albedo * grid(pos.xz * 4.0);\n\n        float sh = calcSoftshadow(pos, light, bounds, iTime);\n        col = amb + diff * sh;\n    }\n\n    if (d < far && (d < plain.x || plain.x < 0.0)) {\n        vec3 pos = ro + rd * d;\n        vec3 norm = calcNormal(pos, iTime);\n\n        float ao = calcAO(pos, norm, iTime);\n\n        float nl = clamp(dot(norm, light), 0.0, 1.0);\n\n        int mi = int(floor(m));\n\n        vec3 albedo = vec3(0.0);\n        float roughness = 0.5;\n        vec3 f0 = vec3(0.04);\n\n        switch(mi) {\n            case 2:\n            albedo = camo(uv, vec2(2., 4.));\n            break;\n            case 3:\n            albedo = camo(uv, vec2(4., 24.));\n            break;\n            case 4:\n            albedo = fuselagePaint(uv);\n            break;\n            case 5:\n            albedo = vec3(0.1088);\n            break;\n            case 6:\n            albedo = canopyPaint(uv, roughness, f0);\n            break;\n            case 7:\n            albedo = vec3(0.40471, 0.45084, 0.212044);\n            break;\n            case 8:\n            albedo = vec3(0.1);\n            break;\n        }\n\n        vec3 haf = normalize(light - rd);\n        float nh = clamp(dot(norm, haf), 0., 1.);\n        float nv = clamp(dot(norm, -rd), 0., 1.);\n        float lh = clamp(dot(light, haf), 0., 1.);\n        float a = roughness * roughness;\n        float a2 = a * a;\n        float dnm = nh * nh * (a2 - 1.) + 1.;\n        float D = a2 / (PI * dnm * dnm);\n        float k = pow(roughness + 1., 2.) / 8.;\n        float G = (1. / (nl * (1. - k) + k)) * (1. / (nv * (1. - k) + k));\n        vec3 F = f0 + (1. - f0) * exp2((-5.55473 * lh - 6.98316) * lh);\n        vec3 specular = nl * D * F * G;\n\n        col = nl * (specular + albedo * (1. - f0));\n\n        float h = clamp(pos.y * 2. + .4, .01, 1.);\n\n        float bnc = clamp(dot(norm, normalize(vec3(light.x, .0, light.z))) * .5 + .28, 0., 1.);\n        col += albedo * bnc * .25 * h * (1. - nl);\n\n        float bnc2 = clamp(dot(norm, vec3(-light.x, light.y, -light.z)) * .5 + .28, 0., 1.);\n        col += albedo * bnc2 * 0.1 * h * (1. - nl);\n\n        col += 0.2 * albedo;\n        col *= ao;\n    }\n\n    col = pow(col, vec3(1. / 2.2));\n\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}