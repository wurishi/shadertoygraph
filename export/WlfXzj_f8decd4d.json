{"ver":"0.1","info":{"id":"WlfXzj","date":"1563481211","viewed":131,"name":"Simple 2D SDFs ","username":"twisterge","description":"Simple 2D SDFs","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592654\n\nfloat circle(vec2 p, float rad) {\n    return length(p) * 4.0 - rad * 0.5;\n}\n\nfloat square(vec2 p, float rad) {\n    vec2 d = abs(p) - vec2(rad * 0.5);\n    float od = length(max(d, 0.0));\n    float id = min(max(d.x, d.y), 0.0);\n    return od + id;\n}\n\nvec2 translate(vec2 p, vec2 off) {\n    return p - off;\n}\n\nvec2 rotate(vec2 p, float rot) {\n    float s = sin(rot);\n    float c = cos(rot);\n    return vec2(c * p.x + s * p.y, c * p.y - s * p.x);\n}\n\nvec2 scale(vec2 p, vec2 s) {\n    return p / (s + vec2(0.0001));\n}\n\nfloat merge(float a, float b) {\n    return min(a, b);\n}\n\nfloat intersection(float a, float b) {\n    return max(a, b);\n}\n\nfloat subtract(float base, float sub) {\n    return intersection(base, 1.0 - sub);\n}\n\nfloat scene(vec2 uv) {\n    float aspect = (iResolution.x / iResolution.y);\n    float sx = (sin(iTime) * 0.5 + 0.5) * 0.50 + 0.25;\n    vec2 spos = rotate(uv - vec2(sx * aspect, 0.5), iTime);\n    vec2 cpos = uv - vec2(0.75 * aspect, 0.5);\n    \n    float circ = smoothstep(0.7, 1.0, circle(cpos, 0.4));\n    float squa = smoothstep(0.01, 0.1, square(spos, 0.4));\n    \n    return merge(circ, squa);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = (iResolution.x / iResolution.y);\n    vec2 center = vec2(0.5 * aspect, 0.5);\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x *= aspect;\n    \n    vec2 mpos = iMouse.xy / iResolution.xy;\n    vec2 mp = vec2(mpos.x * aspect, mpos.y);\n    \n    vec2 pos = rotate(uv - center, iTime);\n    \n    float s = scene(uv);\n    \n    // Generate normals\n    vec3 nx = dFdx(vec3(uv, s));\n    vec3 ny = dFdy(vec3(uv, s));\n    vec3 n = normalize(cross(nx, ny));\n    \n    vec3 L = vec3(uv, 1.5) - vec3(mp, 1.0);\n    float Ld = length(L);\n    L = normalize(L);\n    \n    float att = smoothstep(2.0, 0.2, Ld);\n    float nl = max(dot(n, L), 0.0) * att;\n    \n    fragColor = vec4(vec3(nl), 1.0);\n}","name":"Image","description":"","type":"image"}]}