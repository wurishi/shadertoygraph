{"ver":"0.1","info":{"id":"7dVBWz","date":"1658047757","viewed":53,"name":"Newton-Raphson Root-Finding","username":"Envy24","description":"Based on this shader: https://www.shadertoy.com/view/fsB3Wt\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["approximation","solver","quadratic","newton","raphson","numeric"],"hasliked":0,"parentid":"fdVBzD","parentname":"Quadratic solvers"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define UNIT                      (  6.0 / R.y  )\n#define SM(x)                     ( smoothstep(UNIT, 0., x) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n\nfloat x_axis(vec2 NDC) { return SM(abs(NDC.x)); }\nfloat y_axis(vec2 NDC) { return SM(abs(NDC.y)); }\nfloat draw_func(vec2 NDC, float f, float dfdx)\n{\n    float df   = NDC.y - f;\n    return SM(abs(df) / sqrt(1.0 + dfdx * dfdx));\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = \n        LMB_IS_HOLD ?\n            2.5*TO_CENTERED_NDC(SC-(iMouse.xy-R.xy*0.5)) :\n            2.5*TO_CENTERED_NDC(SC);\n\n    //float a = 1., b = 0., c = -1., d = 0., e = 1., f = -1.;\n    /**/\n    float a = sinOSC(-1.25, 1.25, iTime * 0.15), b = sinOSC( -2.0,  2.0, iTime * 0.6), \n          c = sinOSC( -1.0,  1.0, iTime * 0.45), d = sinOSC( -1.0,  1.0, iTime * 0.25),\n          e = sinOSC( -1.0,  1.0, iTime * 0.17), f = sinOSC( -1.0,  1.0, iTime * 0.07);\n    /**/\n\n/* Algebraic */\n#define func(x)  ( ((((a * x + b) * x + c) * x + d) * x + e) * x + f )\n#define deriv(x) ( (((5. * a * x + 4. * b) * x + 3. * c) * x + 2. * d) * x + e )\n//#define func(x)  ( (((a * x + b) * x + c) * x + d) * x + e )\n//#define deriv(x) ( ((4.0 * a * x + 3.0 * b) * x + 2.0 * c) * x + d )\n//#define func(x)  ( ((a * x + b) * x + c) * x + d )\n//#define deriv(x) ( (3.0 * a * x + 2.0 * b) * x + c )\n//#define func(x)  ( (a * x + b) * x + c )\n//#define deriv(x) ( 2. * a * x + b )\n//#define func(x)  ( a * x + b )\n//#define deriv(x) ( 2. * a )\n/* Transcendential. */\n//#define func(x)  ( sin(x) )\n//#define deriv(x) ( cos(x) )\n//#define func(x)  ( exp(x) )\n//#define deriv(x) ( exp(x) )\n//#define func(x)  ( log(x) )\n//#define deriv(x) ( 1./x )\n//#define func(x)  ( sqrt(x)-1. )\n//#define deriv(x) ( 1./(2.*sqrt(x)) )\n//#define func(x)  ( abs(x)-1. )\n//#define deriv(x) ( x/abs(x) )\n/* */\n\n    vec3 color = vec3(1.);\n         color -= draw_func(NDC, func(NDC.x), deriv(NDC.x));\n         color -= x_axis(NDC); color -= y_axis(NDC);\n\n    /* Initial approximation. */\n    float x = sinOSC(-2., 2., iTime * 0.25);\n    color = mix(color, vec3(0, 0, 1), SM(diskSDF_L2(NDC, vec2(x, 0.0), 0.03)));\n    \n    /* First vertical segment */\n    vec2 B = vec2(x, 0.0);\n    color = mix(color, vec3(0, 1, 0), SM(segmentSDF_L2(NDC, vec2(x, 0.0), vec2(x, func(x)))));\n    color = mix(color, vec3(1, 0, 1), SM(diskSDF_L2(NDC, vec2(x, func(x)), 0.03)));\n\n    /* Inlined Newton-Raphson */\n    const float tolerance = 1e-7; /* Desired precision. */\n    const float EPSILON = 1e-14;  /* Treshold for infinitly small values. */\n    \n    float dfdx = deriv(x);\n    bool quit = abs(dfdx) <= EPSILON;\n    \n    for (int i = 0; (i < 24) && (quit == false); ++i)\n    {\n        float y = func(x);\n        x -= y / dfdx;          \n        dfdx = deriv(x);\n        quit = (abs(y) <= tolerance) || (abs(dfdx) <= EPSILON);\n        \n        /* Visualization */\n        B.y = y;\n        vec2 E = vec2(x, func(x));\n        \n        color = mix(color, vec3(1, 0, 0), SM(segmentSDF_L2(NDC, B, vec2(E.x, 0.0)))); // Tangent segment.\n        color = mix(color, vec3(0, 1, 0), SM(segmentSDF_L2(NDC, vec2(E.x, 0.0), E))); // Vertical segment.\n        color = mix(color, vec3(1, 0, 1), SM(diskSDF_L2(NDC, vec2(x, func(x)), 0.03)));\n\n        B.x = E.x;       \n        /* Visualization */\n    }\n\n    /* Root */\n    color = mix(color, vec3(1, 0, 0), SM(diskSDF_L2(NDC, vec2(x, 0.0), 0.05)));\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0));\n}","name":"Common","description":"","type":"common"}]}