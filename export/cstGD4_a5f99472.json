{"ver":"0.1","info":{"id":"cstGD4","date":"1698497577","viewed":92,"name":"Distance Transform Exploration","username":"Togposh","description":"Distance Transform returning the minimum distance of each fragment from any edge calculated in O(n^2) time instead of O(n^n) if done naively. \n\nBased on the method described in this paper: //https://cs.brown.edu/people/pfelzens/papers/dt-final.pdf","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["distancetransform"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float mouse = iMouse.x / iResolution.x;\n    \n    // fake mouse animation for clarity\n    if (iMouse.xy == vec2(0)) {\n        mouse = sin(iTime / 3.0) + 0.5;\n    }\n    \n    vec3 dt = vec3(0.0);\n    \n    if (mouse < uv.x) {\n        dt = sqrt(texture(iChannel1, uv).rbg);\n    } else {\n        dt = texture(iChannel0, uv).rbg;\n    }\n    \n    fragColor = vec4(dt, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 samplef(const int x, const int y, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy * iChannelResolution[0].xy;\n\tuv = (uv + vec2(x, y)) / iChannelResolution[0].xy;\n\treturn texture(iChannel0, uv).xyz;\n}\nvec3 sobel(int stepx, int stepy, in vec2 fragCoord) {\n    // Convert to grayscale      \n    mat3 pixelsGray = mat3(toGrayscale(samplef(-1, 1, fragCoord)), toGrayscale(samplef(0, 1, fragCoord)), toGrayscale(samplef(1, 1, fragCoord)),\n                       toGrayscale(samplef(-1, 0, fragCoord)), toGrayscale(samplef(0, 0, fragCoord)), toGrayscale(samplef(1, 0, fragCoord)),\n                       toGrayscale(samplef(-1, -1, fragCoord)), toGrayscale(samplef(0, -1, fragCoord)), toGrayscale(samplef(1, -1, fragCoord)));\n\n    // Horizontal Kernal\n    float x = float(pixelsGray[2][0]) * 1.0\n            + float(pixelsGray[2][1]) * 2.0\n            + float(pixelsGray[2][2]) * 1.0\n            + float(pixelsGray[0][0]) * -1.0\n            + float(pixelsGray[0][1]) * -2.0\n            + float(pixelsGray[0][2]) * -1.0;\n    \n    // Verticle Kernal\n    float y = float(pixelsGray[0][0]) * -1.0\n            + float(pixelsGray[1][0]) * -2.0\n            + float(pixelsGray[2][0]) * -1.0\n            + float(pixelsGray[0][2]) * 1.0\n            + float(pixelsGray[1][2]) * 2.0\n            + float(pixelsGray[2][2]) * 1.0;\n                        \n    float sobelResult = clamp(1.0 - step(x+y, 0.15), 0.0, 1.0);\n    \n    return vec3(sobelResult);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get pixel information from uv location\n    vec3 texColour = sobel(1, 1, fragCoord);\n    \n\n    // Output to screen\n    fragColor = vec4(texColour, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\tfloat texelSize = 1.0 / iResolution.y;\n\n    float threshold = 0.1;\n    float dist = toGrayscale(texture(iChannel0, uv).rgb);\n    \n    if(dist <= 1.0)\n    {\n        const int step = 1;\n        int size = int(iResolution.y) - int(fragCoord.y);\n        vec2 dir = vec2(0.0, texelSize);\n        \n        float down = computeDistance(uv, dir, threshold, step, size, iChannel0, iResolution.y);\n        float up = computeDistance(uv, -dir, threshold, step, int(iResolution.y) - size, iChannel0, iResolution.y);\n        \n        dist = down < up ? down : up;\n    }\n\n    fragColor = vec4(vec3(dist), 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float toGrayscale( in vec3 texColour ) {\n    return 0.299 * texColour.r + 0.587 * texColour.g + 0.114 * texColour.b;\n}\n\nfloat computeDistance(vec2 uv, vec2 dir, float theshold, int step, int distanceFromImageEdge, sampler2D test, float resolution)\n{\n    // initial distance of 0.0\n    float dist = 0.0;\n    \n    for (int i = 1; i < distanceFromImageEdge; i+=step)\n    {\n        // normalized step in the specified direction\n        vec2 normalizedOffset = float(i) * dir;\n        \n\t\tfloat val = toGrayscale(texture(test, vec2(uv) + normalizedOffset).rgb);\n        \n        // if edge is detected, return distance from verticle edge\n        if(val >= theshold)\n             return dist * float(step) / resolution;\n        \n        dist += 1.0;\n    }\n    \n    // return value of 1.0 if no edge is ever detected \n    return 1.0;\n}\n\nfloat additiveDistance(vec2 uv, vec2 dir, int step, int distanceFromImageEdge, sampler2D test, float resolution)\n{\n    // initial distance of the verticle distance of current fragment\n    float minDist = toGrayscale(texture(test, vec2(uv)).rgb);\n    \n    // loop over all fragments from edge in the same row\n    for (int i = 1; i < distanceFromImageEdge; i+=step)\n    {\n        vec2 normalizedOffset = float(i) * dir;\n        vec2 currentPoint = vec2(uv) + normalizedOffset;\n        \n\t\tfloat verticalDist = toGrayscale(texture(test, currentPoint).rgb);\n        \n        float horizontalDist = float(i) / resolution;\n        \n        float dist = sqrt(pow(verticalDist, 2.0) + pow(horizontalDist, 2.0));\n        \n        minDist = min(minDist, dist);\n    }\n    \n    return minDist;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\tfloat texelSize = 1.0 / iResolution.x;\n\n    float dy = toGrayscale(texture(iChannel0, uv).rgb);\n    \n        const int step = 1;\n        int size = int(iResolution.x) - int(fragCoord.x);\n        vec2 dir = vec2(texelSize, 0.0);\n        \n        float right = additiveDistance(uv, dir, step, size, iChannel0, iResolution.x);\n        float left = additiveDistance(uv, -dir, step, int(iResolution.x) - size, iChannel0, iResolution.x);\n        \n        dy = right < left ? right : left;\n\n    fragColor = vec4(vec3(dy), 1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}