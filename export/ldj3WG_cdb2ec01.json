{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst int nLights = 2;\n\tconst int nObjects = 2;\n\tvec2 r = (fragCoord.xy - 0.5*iResolution.xy)  / iResolution.y; // coordinate of the pixel\n\tvec2 m = (iMouse.xy - 0.5*iResolution.xy)  / iResolution.y; // coordinate of mouse\n\tvec2 s[nLights]; // coordinates of light sources\n\tvec3 sColor[nLights]; // colors of lights\n\tvec2 c[nObjects]; // coordinates of disks\n\tfloat rad[nObjects]; // radii of disks\n\t\n\ts[0] = vec2(-0.5, 0.0)+vec2(0.2*cos(iTime),0.2*sin(iTime));\n\tsColor[0] = vec3(0.0, 1.0, 1.0); // rotating turquaz light\n\ts[1] = vec2(0.3, 0.2);\n\tsColor[1] = vec3(1.0, 1.0, 0.0)*(sin(iTime*1.2)+1.0)*0.6; // flashing yellow light\n\t\n\tc[0] = vec2(0.0, 0.0) + vec2(0.0, 0.25)*sin(iTime); // oscillating big disk\n\trad[0] = 0.1;\n\tc[1] = m.xy; // disk moved by mouse\n\trad[1] = 0.05;\n\n\tvec3 light = vec3(0.0);\t\n\tfloat getLight;\n\tvec2 dsc, dsr, ndsc, ndsr;\n\tfor(int i=0; i<nLights; i++) {\n\t\tgetLight = 1.0;\n\t\tfor(int j=0; j<nObjects; j++) {\n\t\t\tdsc = c[j] - s[i]; // distance vector from the light source [i] to object [j]\n\t\t\tdsr = r - s[i]; // distance vector from the light source [i] to the pixel\n\t\t\tndsc = normalize(dsc); // normalized dsc\n\t\t\tndsr = normalize(dsr); // normalized dsr\n\t\t\tfloat cosPixelObject = dot( ndsc, ndsr ); // cosine of the angle between the dsc and dsr\n\t\t\t// Add the light color if\n\t\t\t// 2) \"from light to pixel\" direction is not in the range of \"light to disc center OR \n\t\t\t// 1) distance between light and pixel is less than the distance light and object center\n\t\t\tif( cosPixelObject<cos(asin( rad[j]/length(dsc))) || length(dsr) < length(dsc)) {\n\t\t\t\tgetLight *= 1.0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgetLight *= 0.0;\n\t\t\t}\n\t\t}\n\t\tif(getLight>0.0) {\n\t\t\tlight += 0.2*sColor[i]/pow(length(dsr)+0.3, 1.2);\n\t\t}\t\t\n\t}\n\t\n\tfloat objCol = 0.0;\n\tfor(int j=0; j<nObjects; j++) { \n\t\tobjCol += 1.0-smoothstep(rad[j]-0.005,rad[j]+0.005, length(r.xy-c[j].xy)); // draw objects\n\t\tobjCol += 1.0-step(0.01, length(r.xy-s[j].xy)); // and lights a white circles\n\t}\t\n\tvec3 col = vec3(objCol) + vec3(light);\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldj3WG","date":"1393040671","viewed":943,"name":"On Lights and Shadows","username":"vug","description":"Shadows of circles. Click on the screen to move the smaller circle around. New circles and light sources can be added easily. Inspired by this: https://www.shadertoy.com/view/XdjGDm But instead of raytracing, did a system that can only work for circles.","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""}}