{"ver":"0.1","info":{"id":"MdfcR8","date":"1486998274","viewed":837,"name":"Ray tracing rasterizer Triangle","username":"miffy","description":"my experiment of ray trace rasterizer.\ntrying to make simple easy to understand.\n","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// @param x....radian around x-axis\n// @param y....radian around y-axis\n// @param z....radian around z-axis\n//from https://www.shadertoy.com/view/XdlGzn\nmat4 rotate( float x, float y, float z )\n{\n    float a = sin(x); float b = cos(x); \n    float c = sin(y); float d = cos(y); \n    float e = sin(z); float f = cos(z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f,      d*e,       -c, 0.0,\n                 ac*f-b*e, ac*e+b*f, a*d, 0.0,\n                 bc*f+a*e, bc*e-a*f, b*d, 0.0,\n                 0.0,      0.0,      0.0, 1.0 );\n}\nmat4 ortho(float left,float right,float bottom,float top,float near,float far){\n    return mat4(2.0/(right-left),             0.0,            0.0, -(right+left)/(right-left),\n                              0.0,2.0/(top-bottom),            0.0,-(top+bottom)/(top-bottom),\n                              0.0,             0.0,-2.0/(far-near),    -(far+near)/(far-near),\n                              0.0,             0.0,             0.0,                      1.0);\n}\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, x,\n  \t\t\t\t 0.0, 1.0, 0.0, y,\n\t\t\t\t 0.0, 0.0, 1.0, z,\n\t\t\t\t 0.0,  0.0, 0.0, 1.0 );\n\n}\n\n//from https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/moller-trumbore-ray-triangle-intersection\n//ray and triangle hit test\n// @param orig...origin of ray\n// @param dir...ray direction\n// @param a,b,c....triangle vertices\n// @return vec3(0,0,0) if ray is not hit triangle\nvec3 hit(vec3 orig,vec3 dir,vec3 a,vec3 b,vec3 c){\n   float eps= 0.0000001;\n   vec3 ab=b-a;\n   vec3 ac=c-a;\n   \n   vec3 n=cross(dir,ac);\n\n   float det=dot(ab,n);\n    \n   if(det<=eps){ return vec3(0.3,0.3,0.3);}\n   // if the determinant is negative the triangle is backfacing\n   // if the determinant is close to 0, the ray misses the triangl\n   vec3 ao=orig-a;\n   float u=dot(ao,n)/det;\n   if(u<0.0 || u>1.0){ return vec3(0.3,0.3,0.3);}\n    \n   vec3 e=cross(ao,ab);\n   float v=dot(dir,e)/det;\n   if(v<0.0||u+v>1.0){ return vec3(0.3,0.3,0.3);}\n\n   float t = dot(ac,e)/det;\n   return vec3(u,v,t);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //triangle verts\n    vec4 a=vec4(0.0,0.5,0.0,1.0);\n    vec4 b=vec4(-0.5,-0.5,0.0,1.0);\n    vec4 c=vec4(0.5,-0.5,0.0,1.0);\n    \n    mat4 rot = rotate( 0.0,sin(iTime),0.0);\n   \ta = rot*a;\n    b = rot*b;\n    c = rot*c;\n\n    \n    vec2 uv = fragCoord/iResolution.xy;     \n    //z position of near clipping plane\n    float near=0.2;\n    vec3 p= vec3(uv*2.0-1.0,near);\n\n\t//calc ray direction\n    vec3 camera = vec3(0.0,0.0,5.0);\n    vec3 dir = p-camera;\n\tdir = normalize(dir);\n    fragColor =vec4(hit(camera,dir,a.xyz,b.xyz,c.xyz),1.0); \n }","name":"Image","description":"","type":"image"}]}