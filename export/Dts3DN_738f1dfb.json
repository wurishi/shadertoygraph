{"ver":"0.1","info":{"id":"Dts3DN","date":"1671822762","viewed":132,"name":"Blast Radius","username":"4LT","description":"Audio-responsive ball of spikes.  Thanks to iq for help with ray-segment distance.  Music by MegaDrive.","likes":9,"published":1,"flags":64,"usePreview":0,"tags":["audio"],"hasliked":0,"parentid":"dtf3WN","parentname":"BEES BEES BEES"},"renderpass":[{"inputs":[{"id":"Xt2Xzt","filepath":"https://soundcloud.com/megadrivemusic/slum-lord","previewfilepath":"https://soundcloud.com/megadrivemusic/slum-lord","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float tau = 2. * acos(-1.);\n\nconst vec3 forward = vec3(0., 0., 1.);\nconst vec3 up = vec3(0., 1., 0.);\nconst vec3 right = vec3(-1., 0., 0.);\nconst vec3 cam = vec3(0., 0., -2.0);\n\nconst float ptCt = 100.;\nconst float speed = 0.75;\n\nfloat auAvg() {\n    float sampCt = 20.;\n    float sum = 0.;\n    for (float i = 0.; i < sampCt; i++) {\n        sum+= texture(iChannel0, vec2(i/sampCt, 1.)).x;\n    }\n    return sum/sampCt;\n}\n\nfloat spow(float x, float power) {\n    return pow(abs(x), power) * sign(x);\n}\n\nfloat t;\n\nfloat dist(vec3 rayDir) {\n    float minDist = 99999.;\n    float sphHeight = sin(spow(2. * (auAvg() - 0.5), 3.) * tau * 2. + t)*0.2;\n    vec3 sph = vec3(0., sphHeight, 0.);\n    \n    for (float i = 0.; i < ptCt; i++) {\n        float iNorm = i / ptCt;\n        \n        vec4 denoms = vec4(0.243453, 0.4234345, 0.2357797, 0.165777341);\n        vec2 rand = mod(iNorm * vec2(1.3236574234, 0.934556756345), denoms.xy) / denoms.xy;\n        rand = mod(rand.yx, denoms.zw)/denoms.zw;\n        rand = mod(rand, denoms.xz)/denoms.xz;\n        rand = mod(rand.yx, denoms.yw)/denoms.yw;\n        \n        float phi = acos(1. - fract(rand.x + t) * 2.);\n        float theta = rand.y * tau + t * (rand.x + iNorm + 2.);\n        \n        float horz = sin(phi);\n        vec3 sph2i = vec3(horz * cos(theta), cos(phi), horz * sin(theta));\n        vec3 iPos = sph2i + sph;\n        vec3 sph2cam = cam - sph;\n        \n        float segFrac = \n            (dot(sph2cam, sph2i) - dot(sph2i, rayDir) * dot(sph2cam, rayDir))\n            / (1. - dot(sph2i, rayDir) * dot(sph2i, rayDir));\n        float bounce = abs(texture(iChannel0, vec2(iNorm, 1.)).x - 0.3)/1.5;\n        segFrac = clamp(segFrac, bounce * 0.75 + 0.5, bounce + 0.75);\n        \n        \n        float rayDist = dot(sph2i, rayDir) * segFrac - dot(sph2cam, rayDir);\n        vec3 rayPos = cam + rayDir * rayDist;\n                \n        float iDist = length(rayPos - mix(sph, iPos, segFrac));\n        minDist = min(iDist, minDist);\n    }\n    \n    return minDist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = iTime * speed;\n    vec2 uv = (fragCoord/iResolution.xy * 2. - 1.);\n    uv.x*= iResolution.x / iResolution.y;\n    vec3 rayDir = normalize(uv.x * right + uv.y * up + forward);\n    \n    \n    float d = dist(rayDir);\n    if (d < 0.09 && d > 0.07) {\n        fragColor = vec4(1., 1., 1., 1.);\n    } else if (d > 0.2) {\n        float bar = mod((t + uv.y + uv.x/4.) * 4., 1.0) < 0.1 ? 0.37 : 0.;\n        \n        fragColor = vec4(vec3(bar), 1.);\n    } else {\n        fragColor = vec4(0., 0., 0., 1.);\n    }\n}","name":"Image","description":"","type":"image"}]}