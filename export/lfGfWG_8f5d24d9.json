{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"void mainImage(out vec4 o, in vec2 p) {\n    o.a = 1.;\n    o.rgb = texture(iChannel1, p/iResolution.xy).rgb;\n    o.rgb += 0.3 * RGB_1 * (0.5+0.5*cos(2.*PI*p.y/iResolution.y));\n}\n","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"const float PI = radians(180.);\nconst float SQ3 = sqrt(3.);\nconst float INF = 1e10;\n\n// Simulation consts\nconst int N = 256;\nconst int M = 2;\nconst float ALPHA = 0.5;\nconst float MASS = 1.5;\n\n// Rendering consts\nconst vec3 RGB_1 = vec3(0.22, 0.05, 1.50)/1.5;\nconst vec3 RGB_2 = vec3(1.5, 0.5, 0.2)/1.5;\nconst float GLOW = 1.5;\nconst float R0 = 0.02;\nconst float R1 = 1.0;\nconst float DMAX = 1.0;\nconst float DAMPING = 0.001;\nconst float COUPLING = 0.01;\n\nvec2 p2q(vec2 p, vec3 iRes) {\n    vec2 ar = iRes.xy/iRes.yy;\n    return (p/iRes.xy*2. - 1.) * ar;\n}\n\nvec2 q2p(vec2 q, vec3 iRes) {\n    vec2 ar = iRes.xy/iRes.yy;\n    return (q/ar*0.5 + 0.5) * iRes.xy;\n}\n\nvec4 texFetch(sampler2D ch0, ivec2 p) {\n    p = ivec2(mod(vec2(p), vec2(ivec2(N,M))));\n    return texelFetch(ch0, p, 0);\n}\n\nvec2 c2mul(vec2 a, vec2 b) {\n    return mat2(a.x, a.y, -a.y, a.x) * b;\n}\n\nvec2 c2div(vec2 a, vec2 b) {\n    return c2mul(a, vec2(b.x, -b.y)) / dot(b, b);\n}\n\nvec2 c2exp(float x) {\n    return vec2(cos(x), sin(x));\n}\n\nvec2 basePos(int i) {\n    return 0.4*c2exp(float(i)/float(N)*2.*PI + PI/2.);\n}\n\nvec2 fullPos(sampler2D ch0, ivec2 pp) {\n    vec2 c = basePos(pp.x);\n    vec4 w = texFetch(ch0, pp);\n    return c + c2mul(c, w.xy)*R1;\n}","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Simulates the motion of masses in iChannel0.\n\nvec2 extForce(ivec2 pp, vec4 cc) {\n    if (iMouse.z < 1.) return vec2(0);\n    vec2 mxy = p2q(iMouse.xy, iResolution);\n    vec2 pos = fullPos(iChannel0, pp);\n    return 0.005 * c2div(mxy, basePos(pp.x));\n}\n\nvoid mainImage(out vec4 o, in vec2 p) {\n    ivec2 pp = ivec2(p - 0.5);\n\n    if (pp.x > N-1 || pp.y > M-1)\n        return;\n     \n    // initial state\n    if (iFrame == 0) {\n        float x = float(pp.x)/float(N);\n        x *= 3. + float(pp.y);\n        float y = 0.2*cos(2.*PI*(x + 12.34*float(pp.y)/float(M)));\n        y += 0.1*cos(2.*PI*(x*41. + float(pp.y)/float(M)));\n        o.xy = vec2(y,0);\n        o.zw = o.xy;\n        return;\n    }\n    \n    vec4 cc = texFetch(iChannel0, pp); // .xy=curr, .zw = prev\n    vec2 rr = texFetch(iChannel0, pp + ivec2(1,0)).xy;\n    vec2 ll = texFetch(iChannel0, pp - ivec2(1,0)).xy;\n    vec2 uu = texFetch(iChannel0, pp + ivec2(0,1)).xy;\n    \n    vec2 T = rr + ll - 2.*cc.xy; // Hooke's law\n    T += ALPHA*T*(rr - ll); // the non-linear term\n    if (pp.y == 0) T += extForce(pp, cc);\n    T += COUPLING * (uu - cc.xy); // coupling force\n    \n    o.xy = 2.*cc.xy - cc.zw;\n    o.xy += T.xy/MASS;\n    o.xy = (o.xy - DAMPING*cc.zw)/(1. + DAMPING);\n    o.zw = cc.xy; // prev <- curr\n    o = clamp(o,vec4(-DMAX),vec4(DMAX));\n}\n","name":"Buffer A","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XsXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Renders the mesh defined by iChannel0 coords.\n\nfloat lineSDF(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat ringSDF(vec2 q, int j) {\n    float d = INF, e = 0.;\n    vec2 a = fullPos(iChannel0, ivec2(N-1,j));\n    \n    for (int i = 0; i < N; i++) {\n        vec2 b = fullPos(iChannel0, ivec2(i,j));\n        d = min(d, lineSDF(q, a, b));\n        a = b;\n    }\n    \n    return d;\n}\n\nvec3 hsv2rgb_smooth(vec3 c) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0,4,2),6.0)-3.0)-1.0, 0., 1. );\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\treturn c.z * mix( vec3(1), rgb, c.y);\n}\n\nvoid mainImage(out vec4 o, in vec2 p) {\n    vec2 q = p2q(p, iResolution);\n    o.rgb = vec3(0);\n    \n    for (int j = 0; j < M; j++) {\n        float d = ringSDF(q, j);\n        float e = exp(-pow(7.5*d/R0, 2.0));\n        vec3 col = j % 2 == 1 ? RGB_2 : RGB_1;\n        o.rgb += col/float(M) * vec3(e, e*e, e*e*e);\n    }\n    \n    o.rgb = pow(o.rgb, vec3(0.4545));\n    \n    vec2 dq = q*(exp(-iTimeDelta*0.5) - 1.);\n    o.rgb += exp(-iTimeDelta*2.5)*texture(iChannel1, q2p(q+dq, iResolution)/iResolution.xy).rgb;\n}\n","name":"Buffer B","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"lfGfWG","date":"1734391782","viewed":112,"name":"Coupled Ring Oscillators","username":"prasound","description":"iMouse.xy = external force","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["oscillator"],"hasliked":0,"parentid":"Xc3fzs","parentname":"Sound Flow"}}