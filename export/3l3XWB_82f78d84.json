{"ver":"0.1","info":{"id":"3l3XWB","date":"1582755739","viewed":64,"name":"TP1 Graphique S4","username":"LucieFournier","description":"TP1","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["tp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Lucie Fournier\n// p1811511\n\nconst int Steps = 200;      // Number of steps\nconst float Epsilon = 0.0025; // Marching epsilon\n\n// Primitive functions -----------------------------------------------------------------------------------\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a,float b)\n{\n    return min(a,b);\n}\n\n// Intersection\n// a : field function of left sub-tree\n// b : fied function of right sub-tree\nfloat Intersection(float a, float b)\n{\n    return max(a,b);\n}\n\n// Difference\n// a : field function of major sub-tree\n// b : fied function of delete sub-tree\nfloat Difference(float a, float b)\n{\n    return max(a,-b);\n}\n\n// Translation indirecte\n// p : point de l'espace\n// t : vecteur de translation directe\nvec3 Translation(vec3 p, vec3 t)\n{\n \treturn p - t;   \n}\n\n// Rotation indirecte\n// p : point de l'espace\n// c : centre de rotation\n// r : vecteur des trois rotations (x, y, z) en radians d'angles directs\nvec3 Rotation(vec3 p, vec3 c, vec3 r)\n{\n    float cx = cos(-r.x);\n    float sx = sin(-r.x);\n    float cy = cos(-r.y);\n    float sy = sin(-r.y);\n    float cz = cos(-r.z);\n    float sz = sin(-r.z);\n    p -=c;\n    mat3 Rx = mat3(1.0, 0.0, 0.0,    0.0, cx, -sx,    0.0, sx,cx);\n    mat3 Ry = mat3(cy, 0.0, -sy,    0.0,1.0,0.0,    sy, 0.0, cy);\n    mat3 Rz = mat3(cz, -sz, 0.0,    sz, cz, 0.0,    0.0,0.0,1.0);\n    return (Rx*Ry*Rz*p)+c;\n}\n\n// Scale inverse\n// p : point de l'espace\n// c : centre de scale\n// s : vecteur des coefficients de scale (x, y, z)\n// /!\\ Remultipliser l'appel au scale par le scale min\nvec3 Scale(vec3 p, vec3 c, vec3 s)\n{\n \tp -= c;\n    p.x /= s.x;\n    p.y /= s.y;\n    p.z /= s.z;\n    return p + c;\n}\n\n// Sphere \n// p : point\n// c : center of skeleton\n// r : radius\nfloat Sphere(vec3 p, vec3 c, float r)\n{\n  return length(p-c)-r;\n}\n\n// Plan\n// p : point\n// n : Normal of plane\n// o : Point on plane\nfloat Plane(vec3 p, vec3 n, vec3 o)\n{\n    return dot((p-o),n);\n}\n\n// Boite AAB\n// p : point\n// a : point inferieur\n// b : point superieur\nfloat Boite(vec3 p, vec3 a, vec3 b)\n{\n    float  v = Intersection(Plane(p, vec3(-1.0,0.0,0.0),a),Plane(p, vec3(1.0,0.0,0.0),b));\n    v = Intersection(v, Intersection(Plane(p, vec3(0.0,-1.0,0.0),a),Plane(p, vec3(0.0,1.0,0.0),b)));\n    v = Intersection(v, Intersection(Plane(p, vec3(0.0,0.0,-1.0),a),Plane(p, vec3(0.0,0.0,1.0),b)));\n    return v;\n}\n\n\n// Cylindre infini\n// p : point\n// a : point du centre du cylindre\n// u : vecteur unitaire directeur\n// r : rayon\nfloat Cylindre(vec3 p, vec3 a, vec3 u, float r)\n{\n \tfloat l = dot((p-a),u);\n    float d = sqrt(length(p-a)*length(p-a) - l*l);\n    return d - r;\n}\n\n// Cylindre fini\n// p : point\n// a : base du cylindre\n// b : haut du cylindre\n// r : rayon\nfloat CylindreFini(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 u = (b-a)/length(b-a);\n    float fc = Cylindre(p, a, u, r);\n    float pa = Plane(p, u, a);\n    float pb = Plane(p, -u, b);\n    return Difference(fc, Union(pa, pb));\n}\n\n// Tore\n// p : point\n// c : centre du cercle\n// n : normale du plan\n// R : rayon majeur\n// r : rayon mineur\nfloat Tore(vec3 p, vec3 c, vec3 n, float R, float r)\n{\n    float ph = dot(p-c, n);\n    float l = sqrt(length(p-c)*length(p-c) - ph*ph);\n    float d = sqrt((l-R)*(l-R) + ph*ph);\n    return d-r;\n}\n\n// Disque\n// p : point\n// c : centre du cercle\n// n : normale au plan du cercle\n// R : rayon majeur\n// r : rayon mineur\nfloat Disque(vec3 p, vec3 c, vec3 n, float R, float r)\n{\n    n=normalize(n);\n    float ph = abs(dot(p-c, n));\n    float l = sqrt(length(p-c)*length(p-c) - ph*ph);\n    if(l < R)\n    {\n        return ph-r;\n    }\n    else\n    {\n        float d = sqrt((l-R)*(l-R) + ph*ph);\n        return d-r;\n    }\n}\n\n// Capsule\n// p : point\n// a : base du cylindre (hors sphere)\n// b : haut du cylindre (hors sphere)\n// r : rayon du cylindre\nfloat Capsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    float fc = CylindreFini(p, a, b, r);\n    float fs1 = Sphere(p, a, r);\n    float fs2 = Sphere(p, b, r);\n    return Union(fc, Union(fs1, fs2));\n}\n\n// Cone\n// p : point de l'espace\n// a : point d'origine (base) du cone\n// ra : rayon d'origine du cone\nfloat Cone(vec3 p, vec3 a, vec3 b, float ra) {\n    float ab = length(b-a);\n    vec3 u = (b-a)/ab;\n    \n    // Radial coordinates (l,e) l axial, e radial\n    vec3 ap=p-a;\n    float lap=length(ap);\n\tfloat l = dot(ap, u);\n    \n    float e = sqrt(lap*lap - l*l);\n        \n    vec2 n = vec2(ra, ab);\n    n=normalize(n);\n    float d = dot(vec2(l-ab,e),n);\n    // Section basse du cone\n    d = Difference(d, Plane(p, u, a));\n    return d;\n}\n\n// Goutte\n// p : point de l'espace\n// a : point central de la goutte\n// b : point culminant de la goutte\n// r : rayon de la goutte\nfloat Goutte(vec3 p, vec3 a, vec3 b, float r) {\n \tfloat cone = Cone(p, a, b, r);\n    return Union(cone,Difference(Sphere(p, a, r), Plane(p, -(b-a)/length(b-a), a)));\n}\n\n// Triangle\n// p : point de l'espace\n// a : point en bas à gauche du triangle\n// h : hauteur du triangle\n// prof : profondeur du triangle\n// Attention : a et b doivent avoir le même y\nfloat Triangle(vec3 p, vec3 a, vec3 b, float prof) {\n \tfloat d = Intersection(Plane(p, vec3(0.0,1.0,0.0), a), Plane(p, vec3(0.0,-1.0,0.0), vec3(a.x, a.y-prof,a.z)));\n    d = Intersection(d, Plane(p, vec3(0.0,0.0,-1.0), a));\n    vec3 aPrime = vec3(2.0*b.x - a.x, a.y, a.z);\n    vec3 uPrime = (b-aPrime)/length(b-aPrime);\n    d = Intersection(d, Plane(p, vec3(uPrime.z, 0.0, -uPrime.x), b));\n    vec3 u = (b-a)/length(b-a);\n    d = Intersection(d, Plane(p, vec3(-u.z, 0.0, u.x), a));\n    return d;\n}\n\n// Colonne\n// p : point\n// a : point de base de la colonne\n// h_pierre : hauteur des pierres\n// h_colonne : hauteur totale de la colonne\n// l : largeur de la pierre\nfloat Colonne(vec3 p, vec3 a, float h_pierre, float h_colonne, float l)\n{\n    float f = Boite(p, vec3(a.x - l/2.0, a.y-l/2.0, a.z), vec3(a.x + l/2.0, a.y + l/2.0, a.z + h_pierre));\n    f = Union(f, Disque(p, vec3(a.x, a.y, a.z + h_pierre*1.1), vec3(0.0,0.0,1.0), 0.35*l,h_pierre*0.1));\n    f = Union(f, CylindreFini(p, vec3(a.x, a.y, a.z + h_pierre*1.2), vec3(a.x, a.y, a.z - h_pierre*1.2 + h_colonne), l*0.3));\n    f = Union(f, Disque(p, vec3(a.x, a.y, a.z - h_pierre*1.1 + h_colonne), vec3(0.0,0.0,1.0), 0.35*l,h_pierre*0.1));\n    f = Union(f, Boite(p, vec3(a.x - l/2.0, a.y-l/2.0, a.z + h_colonne - h_pierre), vec3(a.x + l/2.0, a.y + l/2.0, a.z + h_colonne)));\n    \n    for(int i = 0 ; i < 10 ; i++) {\n        float angle = float(i)*2.0*3.14/10.0;\n        float ca = cos(angle);\n        float sa = sin(angle);\n        f = Difference(f, Capsule(p, vec3(a.x + ca*l*0.3, a.y + sa*l*0.3, a.z + h_pierre*1.2 + h_colonne/20.0), vec3(a.x + ca*l*0.3, a.y + sa*l*0.3, a.z + h_colonne - h_pierre*1.2 - h_colonne/20.0), l*0.05));\n    }\n    return f;\n}\n\n// Etage\n// p : point\n// c : centre de l'étage en bas\n// r : rayon de l'étage\n// n : nombre de colonnes\nfloat Etage(vec3 p, vec3 c, float r, int n)\n{\n    float f = CylindreFini(p, c, c + vec3(0.0,0.0,r/20.0),r);\n    for(int i = 0 ; i < n ; i++) {\n        float angle = float(i)*2.0*3.14/float(n);\n        float ca = cos(angle);\n        float sa = sin(angle);\n        f = Union(f, Colonne(p, vec3(c.x+0.9*r*ca, c.y+0.9*r*sa, c.z+r/20.0), r/20.0, r, r/5.0));\n    }\n    return f;\n}\n\n// Tube\n// p : point de l'espace\n// a : point la base du tube\n// b : point du haut du tube\n// R : rayon majeur du tube\n// r : rayon mineur du tube (qu'on enleve)\nfloat Tube(vec3 p, vec3 a, vec3 b, float R, float r) {\n    float cylindre = Difference(CylindreFini(p, a, b, R), CylindreFini(p, a, b, r));\n    vec3 n = vec3(-0.3,0.0,1.0);\n    n = normalize(n);\n    cylindre = Difference(cylindre, Plane(p, n, vec3(a.x, a.y, a.z+R)));\n    return cylindre;\n}\n\n// Flute\n// p : point de l'espace\n// h : hauteur de la flute\n// l : largeur de la flute\n// n : nombre de tubes de la flute\nfloat Flute(vec3 p, float h, float l, int n) {\n    float r = l/(2.0*float(n));\n    float f = Tube(p, vec3(0.0,0.0,0.0), vec3(0.0,0.0,h), r, r*0.8);\n    for(int i = 1 ; i < n ; i++) {\n        float x = 2.0*float(i)*r;\n        float z = 0.7*float(i)*h/float(n);\n        f = Union(f, Tube(p, vec3(x, 0.0, z), vec3(x, 0.0, h), r, r*0.8));\n    }\n    //f = Union(f, Boite(p, vec3(1.1*l, -0.1*l/float(n), 0.8*h), vec3(-0.1*l, 1.1*l/float(n), 0.9*h)));\n    f = Union(f,Boite(p, vec3(-0.1*l,-1.2*r,0.8*h), vec3(l,1.2*r,0.9*h)));\n    return f;\n}\n\n// Bonhomme\n// p : point de l'espace\nfloat Bonhomme(vec3 p) {\n    vec3 a = vec3(0.0,0.0,0.0);\n    vec3 b = vec3(0.0,0.0,5.0);\n    // Corps et Tete\n \tfloat f = Union(Cone(p, a, b, 2.2), Sphere(p, b, 1.0));\n    // Bras gauche\n    f = Union(f, Capsule(p, vec3(0.5, 0.0, 3.5), vec3(2.7, 0.5, 2.5), 0.3));\n    f = Union(f, Capsule(p, vec3(2.7, 0.5, 2.5), vec3(1.5, 1.5, 4.0), 0.3));\n    f = Union(f, Sphere(p, vec3(1.5, 1.5, 4.0), 0.4));\n    // Flute\n    f = Union(f, Flute(Translation(p, vec3(-0.7, 1.5, 1.9)), 2.5, 2.0, 8));\n    // Bras droit plus penche\n    f = Union(f, Capsule(p, vec3(-0.5, 0.0, 3.5), vec3(-2.0, 0.2, 2.0), 0.3));\n    f = Union(f, Capsule(p, vec3(-2.0, 0.2, 2.0), vec3(-1.2, 1.5, 4.0), 0.3));\n    f = Union(f, Sphere(p, vec3(-1.2, 1.5, 4.0), 0.4));\n    // Jambe gauche\n    f = Union(f, Capsule(p, vec3(0.5, 0.0, 0.0), vec3(0.0, 3.0, -1.0), 0.5));\n    f = Union(f, Capsule(p, vec3(0.0, 3.0, -1.0), vec3(-1.0, 1.5, -2.0), 0.5));\n    f = Union(f, Sphere(Scale(p, vec3(-1.0, 1.5, -2.0), vec3(1.0,1.0,1.7)), vec3(-1.2, 1.5, -2.3), 0.5));\n    // Jambe droite\n    f = Union(f, Capsule(p, vec3(-0.5, 0.0, 0.0), vec3(0.5, 3.2, -0.3), 0.5));\n    f = Union(f, Capsule(p, vec3(0.5, 3.2, -0.3), vec3(0.7, 2.5, -2.5), 0.5));\n    f = Union(f, Sphere(Scale(p, vec3(-1.0, 1.5, -2.0), vec3(1.0,1.0,1.7)), vec3(0.7, 2.5, -2.7), 0.5));\n    // Aureole\n    vec3 n = vec3(0.0,-0.5,1.0);\n    n = normalize(n);\n    f = Union(f, Tore(p, vec3(0.0,-0.5,6.5), n, 1.0,0.1));\n\treturn f;\n}\n\n// Pyramide non-reguliere\n// p : point de l'espace\n// a : point en bas à gauche de la pyramide (x superieur, y et z inferieur a b)\n// b : sommet de la pyramide (x inferieur, y et z superieur a a)\nfloat Pyramide(vec3 p, vec3 a, vec3 b) {\n    vec3 u = (b-a);\n    u = normalize(u);\n    // Point oppose a a sur la meme face\n    vec3 aPrime = vec3(2.0*b.x - a.x, 2.0*b.y - a.y, a.z);\n    vec3 uPrime = (b-aPrime)/length(b-aPrime);\n\tfloat f = Plane(p, vec3(0.0, -u.z, u.y), a);\n    f = Intersection(f, Plane(p, vec3(0.0,0.0,-1.0), a));\n   \tf = Intersection(f, Plane(p, vec3(u.z,0.0,-u.x), a));\n    f = Intersection(f, Plane(p, vec3(0.0,uPrime.z,-uPrime.y), aPrime));\n    f = Intersection(f, Plane(p, vec3(-uPrime.z,0.0,uPrime.x), aPrime));\n    return f;\n}\n\n// Balancelle\n// p : point de l'espace\nfloat Balancelle(vec3 p) {\n    float f = 0.5*Bonhomme(Rotation(Scale(Translation(p, vec3(0.0,0.0,2.0)), vec3(0.0,0.0,0.0), vec3(0.5,0.5,0.5)), vec3(0.0,0.0,0.0), vec3(0.0,0.0,3.14/2.0)));\n   \tf = Union(f, CylindreFini(p, vec3(0.0, -1.8, 1.7), vec3(0.0, 1.8, 1.7), 0.2));\n    f = Union(f, Difference(Tore(Scale(p, vec3(0.0,0.0,1.7), vec3(1.0,1.0,2.7)), vec3(0.0,0.0,1.7), vec3(1.0,0.0,0.0), 1.8, 0.05), Plane(p, vec3(0.0,0.0,1.0), vec3(0.0,0.0,1.7))));\n    f = Union(f, Sphere(p, vec3(0.0,0.0,6.7), 0.2));\n    f = Union(f, CylindreFini(p, vec3(0.0,0.0,6.7), vec3(0.0,0.0,7.5), 0.1));\n    f = Union(f, Pyramide(Rotation(p, vec3(0.0,0.0,7.65), vec3(0.0,3.14,0.0)), vec3(0.3,-0.3,7.5), vec3(0.0,0.0,7.8)));\n    return f;\n}\n\n// Sculpture\n// p : point de l'espace\nfloat Sculpture(vec3 p) {\n \tfloat f = Colonne(p, vec3(0.0,0.0,-4.0), 0.5,4.0,2.0);\n    f = Union(f, Difference(Tore(p, vec3(0.0,0.0,3.75), vec3(1.0,0.0,0.0), 4.1, 0.1), Plane(p, vec3(0.0, 0.5, 0.2), vec3(0.0,-1.8,3.75))));\n    f = Union(f, CylindreFini(p, vec3(0.0, -3.0, 6.6), vec3(0.0, -3.0, 5.5), 0.05));\n    f = Union(f, Goutte(p, vec3(0.0, -3.0, 5.0), vec3(0.0, -3.0, 5.5), 0.2));\n    f = Union(f, Balancelle(Rotation(p, vec3(0.0,0.0,0.0), vec3(0.0,0.0,iTime))));\n    return f;\n}\n    \n\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{        \n    //Plan\n   \tfloat v = Plane(p,vec3(0.0,0.0,1.0),vec3(0.0,0.0,-4.0));\n    \n    // Axes x, y, z\n    //v = Union(v, CylindreFini(p, vec3(-10.0,-10.0,8.0), vec3(-7.0,-10.0,8.0),0.3));\n    //v = Union(v, CylindreFini(p, vec3(-10.0,-10.0,8.0), vec3(-10.0,-7.0,8.0),0.3));\n    //v = Union(v, CylindreFini(p, vec3(-10.0,-10.0,8.0), vec3(-10.0,-10.0,11.0),0.3));\n    \n    v = Union(v, Sculpture(Translation(p, vec3(4.0,0.0,0.0))));\n   return v;\n}\n\n// Analysis of the scalar field --------------------------------------------------------------------------\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.001;\n  vec3 n;\n  float v = object(p);\n  n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// e : Maximum distance \n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, float e,out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=0.0;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v < 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,v/1.0);\n      // Escape marched too far away\n      if (t>e)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Lighting ----------------------------------------------------------------------------------------------\n\n// Ambient occlusion\n// p : Point\n// n : Normal\n// a : Number of smaples\nfloat AmbientOcclusion(vec3 p,vec3 n, int a)\n{\n    if (a==0) { return 1.0; }\n    \n\tfloat ao=0.0; \n    \n    for (int i=0;i<a;i++)\n    {\n \t\tvec3 d = Cosine(581.123*float(i) , n);\n\n        int s;\n        bool h;\n        float t=SphereTrace(p,d,10.0,h,s);\n        if (!h) {ao+=1.0;}\n        else if (t>5.0)\n            {\n             ao+=1.0;   \n            }\n    }\n    \n    ao/=float(a);\n\treturn ao;\n}\n\n// Background color\n// d : Ray direction\nvec3 background(vec3 d)\n{\n  return mix(vec3(0.452,0.551,0.995),vec3(0.652,0.697,0.995), d.z*0.5+0.5);\n}\n\n\nfloat Light(vec3 p,vec3 n)\n{\n   // point light\n  const vec3 lp = vec3(5.0, 10.0, 25.0);\n\n  vec3 l = normalize(lp - p);\n\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = pow(0.5*(1.0+dot(n, l)),2.0);\n\n    bool h;\n    int s;\n    float t=SphereTrace(p+0.1*n,l,100.0,h,s);\nif (!h)\n    {\n     return diff;\n    }\n    return 0.0; \n}\n\n\n// Shading and lighting\n// p : Point\n// n : Normal at point\nvec3 Shade(vec3 p, vec3 n)\n{\n    vec3 c = 0.25+0.25*background(n);\n    c+=0.15*AmbientOcclusion(p+0.1*n,n,0)*vec3(1.0,1.0,1.0);\n    c+=0.35*Light(p,n)*vec3(1.0,1.0,1.0);\n    return c;\n}\n\n// Shading according to the number of steps in sphere tracing\n// n : Number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return 0.5+mix(vec3(0.05,0.05,0.5),vec3(0.65,0.39,0.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel, out bool pip)\n{\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {    \n    const float fraction=1.0/4.0;\n    // Recompute pixel coordinates in sub-picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        p=(-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip=true;\n    }\n       else\n       {\n           pip=false;\n       }\n   }\n   return p;\n}\n\n\n// Image\nvoid mainImage( out vec4 color, in vec2 pxy )\n{\n    // Picture in picture on\n    bool pip=true;\n    \n   // Pixel\n     vec2 pixel=Pip(pxy, pip);\n    \n    // Mouse\n    vec2 m=iMouse.xy/iResolution.xy;\n\n    // Camera\n    vec3 ro,rd;\n    Ray(m,pixel,ro,rd);\n\n  // Trace ray\n\n  // Hit and number of steps\n  bool hit;\n  int s;\n\n  float t = SphereTrace(ro, rd, 100.0,hit, s);\n  \n    // Position \n    vec3 pt = ro + t * rd;\n    \n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pt);\n\n    // Shade object with light\n    rgb = Shade(pt, n);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  if (pip==true)\n  {\n      rgb = ShadeSteps(s); \n  }\n\n\n  color=vec4(rgb, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Hashing function\n// Returns a random number in [-1,1]\nfloat Hash(float seed)\n{\n    return fract(sin(seed)*43758.5453 );\n}\n\n// Cosine direction \n// seed : Random seed\n//    n : Normal\nvec3 Cosine( in float seed, in vec3 n)\n{\n    float u = Hash( 78.233 + seed);\n    float v = Hash( 10.873 + seed);\n\n    // Method by fizzer: http://www.amietia.com/lambertnotangent.html\n    float a = 6.2831853 * v;\n    u = 2.0 * u - 1.0;\n    return normalize( n + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 Rz(float a)\n{\n    float sa = sin(a); float ca = cos(a); \n    return mat3(ca,sa,0.0,    -sa,ca,0.0,  0.0,0.0,1.0);\n}\n\n// Compute the ray\n//      m : Mouse position\n//      p : Pixel\n// ro, rd : Ray origin and direction\nvoid Ray(in vec2 m, in vec2 p,out vec3 ro,out vec3 rd)\n{\n    float a = 3.0*3.14*m.x;\n   \tfloat le = 3.8;\n    \n    ro=vec3(40.0,0.0,9.0);\n    ro*=Rz(3.0*3.14*m.x);\n\n    vec3 ta = vec3(0.0,0.0,0.0);\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,0.0,1.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\trd = normalize( p.x*uu + p.y*vv + le*ww );\n}","name":"Common","description":"","type":"common"}]}