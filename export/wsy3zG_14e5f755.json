{"ver":"0.1","info":{"id":"wsy3zG","date":"1570445106","viewed":513,"name":"Can you read-me? (Stereogram)","username":"rmmcal","description":"Once upon a time, I heard about images that only 3% of the would population know how or get to see, these are stereograms\nCan you read the text? you can pause animation if help you...","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","text","stereogram"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///////////////////////\n// Brasil/Amazonas/Manaus\n// Can you read-me? (Stereogram)\n// Created by Rodrigo Cal (twitter: @rmmcal) - 2019/10\n///////////////////////\n//\n//  Once upon a time, I heard about images that only 3% of the \n//  would  population know how or get to see, these are stereograms\n//  Can you read the text? you can pause animation if you help...\n//\n// inspired: \n// -[stereogram] : -https://www.shadertoy.com/view/XtlGRn @zephmann\n// -[spiral dots]: -https://www.shadertoy.com/view/ldf3Dr @P_Malin \n//\n///////////////////////\n\nvec2 uv;\n\nstruct Hit{\n    vec3 p;               // point when hitted\n\tfloat distanceRadius; // min distance 3d radius hit => all sides <=\n    int id;       \t\t  // id hit\n};\n    \nfloat t(float d)\n{\n    return abs(fract(iTime*d)*2.-1.);\n}\n\nvec4 char(uint v)\n{\n    vec2 v2 = clamp((uv/.5)/(16.),-0.,1./16.)-vec2(0.,1./16.) + vec2(float(v%16u)/16.,-float(v/16u)/16.);\n    return vec4(texture(iChannel1,v2));\n}\n\nvec4 char(vec2 p, uint v)\n{\n    vec2 v2 = clamp((p/.5)/(16.),-0.,1./16.)-vec2(0.,1./16.) + vec2(float(v%16u)/16.,-float(v/16u)/16.);\n    return vec4(texture(iChannel1,v2));\n}\n\nfloat char(in vec3 p, uint v)\n{\t\n    float ch = abs(1.-char((p).xy*.2+0.2, v).x);\n    return max(length(max(abs(p+vec3(0.,0., .5))-vec3(1.),0.0)),(ch-p.z)/5.+.05);\n  \n}\n\nuint st[] = uint[6] (0x526f6472u,0x69676f20u, 0x43616e20u, 0x796f7520u, 0x72656164u, 0x2d6d653fu);\n\n\nfloat str(vec3 p, vec3 translate, float size, int s, int e)\n{\n    float d = 100.;\n    for ( uint i = uint(s); i < uint(e); i++)\n    {\n\t\tuint v =  uint(((st[i / 4u] >> (8u*(3u- (i % 4u)))) % 256u));\n        vec3 translateCh = translate+vec3(float(i)*1., 0.,0.);\n        d = min(d, char(p*size-translateCh,v) );\n    }\n    return d;\n}\n\nfloat str(vec2 p, vec2 transl, float size, float sp, int s, int e)\n{\n  \n    float dis = 0.;\n    for ( uint i = uint(s); i < uint(e); i++)\n    {\n\t\tuint v =  uint(((st[i / 4u] >> (8u*(3u- (i % 4u)))) % 256u));\n        vec2 translateCh = transl+vec2(float(i-uint(s))*sp, 0.);\n        dis = max(dis, char(p/size-translateCh*sp,v).x );\n    }\n    return dis;\n}\n\nfloat mapDistance(vec3 p) {\n    float d = 100.;\n  \n    d = min(d, abs(.5+p.y/5.));\n\td = min(d, abs(p.z+21.));\n\n    float y = -5.0;\n    d = min(d, ((length(p+vec3( 6.,y,-t(1.)*10.-1.))-2.1)));\n    d = min(d, ((length(p+vec3( 0.,y,-t(.2)*10.-1.))-2.1)));\n    d = min(d, ((length(p+vec3(-6.1,y,-t(.3)*10.-1.))-2.1)));\n    \n    vec3 translate = vec3(-03.,0.,2.);\n    d = min(d, (str(p, translate, .4, 0, 8)));\n    \n    return d;\n}\n\nfloat raymarching(vec3 p, vec3 d)\n{\n    float total = 0., hitDistance = 0.;\n    \n    for (int i = 0; i < 200; i++)\n    {        \n      \ttotal\t+= (hitDistance = mapDistance(p));          \n        p += d * hitDistance; \n        \n        if (total < .01) break;\t\t\t\t// so close... performance otimization...\n        if (total > 100.) { return 100.; }\t// so far..... performance otimization...\n    }\n   \n    return p.z;\n}\n\nfloat raymarching(vec2 p)\n{ \n\treturn raymarching( vec3(.0,.0,-20.), vec3(p.xy,1.));\n}\n\nfloat getDepth(vec2 p) {\n    return -min(1.,  raymarching(p)/10.);\n}\n\nvec3 mark(vec3 vColour, vec2 p, vec2 t,  float r){\n    r *= iResolution.x;    \n    vec2 pc = (p - t)*iResolution.xx;\n    float len = length(pc);\n    float ang = atan(pc.x, pc.y);\n    float spiral = abs( 0.5 - fract(len * 0.2 + ang * 3.14159 * 2.0 * 0.05 - iTime));\n    vec3 cor = mix( vec3(0.3), vec3(1.0, 1.0, 1.0), spiral);\n    vColour = mix(vColour, cor, smoothstep(r, r - 2.0, length(pc)));\n    return vColour;\n}\n\nfloat hashFix(vec2 p)  \n{\n    p  = fract( -abs(p)*vec2(0.2357111317,0.31357321) )*77.;\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nvec2 hashFix2D(vec2 p)  \n{\n\treturn vec2(hashFix(p), hashFix(p+.1));\n}\nfloat hash(vec2 p)  \n{\n    p  = fract( -abs(p)*vec2(0.2357111317,0.31357321) )*77.;\n    return fract( p.x*p.y*(p.x+p.y)+iTime*1. );\n}\n\nvec2 res(vec2 v, float r){\n\treturn vec2(floor(v*r)/r);\n}\n\nvec3 hash3(vec2 p)  \n{\n    p.y+=1.0;\n   \tfloat a = abs(hash((res(vec2(p),250.))));\n  \tfloat g = abs(hash((res(vec2(p),150.))));\n\treturn vec3((g+a)/8.+.5);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    uv = fragCoord/iResolution.xy;\n    vec2 res = iResolution.xy;\n    vec3 aspectRatio = vec3(1., iResolution.y/iResolution.x, 0.);\n    vec2 p = (uv-.5)*aspectRatio.xy;\n\t\n    float t = abs(fract(iTime*.1)*2.-1.);\n    \n    float maxStep = 10.;\n    float d = 0.;\n    float widthStereogram = 125./res.x;\n\n    vec2 uvStereogram = p;\n    vec2 center = vec2(-widthStereogram*aspectRatio.y,0.);\n    \n    for(int i = 0; i < 200; i++) {\n        if(uvStereogram.x+widthStereogram+.5 < widthStereogram )\n          break;\n        float d = getDepth(uvStereogram +vec2(-.1, 0.))/res.x ;\n        uvStereogram.x -= widthStereogram - (d * maxStep);\n    }\n    \n    vec3 rgb = texture( iChannel0, uvStereogram ,-100.).rgb;\n    if (rgb == vec3(0.))\n\t\trgb = vec3(hash3( uvStereogram ));\n   \n    float widthStereogramHalf = widthStereogram/2.;\n    if (res.x == 640.)\n    {\n        rgb = mark(rgb, p,  vec2(widthStereogramHalf*floor(p.x*5.+.5)*2.00,+0.250*sign(p.y)) , .02); // top down\n        rgb = mark(rgb, p,  vec2(widthStereogramHalf*floor(p.x*5.+.5)*2.08,+0.090), .02); // mark text up \n        rgb = mark(rgb, p,  vec2(widthStereogramHalf*floor(p.x*5.+.5)*2.16,-0.058), .02); // mark text down\n\t}\n    else if (res.x > 640.)\n    {\n        rgb = mark(rgb, p,  vec2(-widthStereogramHalf,-0.25) , .02);\n\t    rgb = mark(rgb, p,  vec2(+widthStereogramHalf,-0.25) , .02);\n    }\n    \n    if (abs(iMouse.z/res.x) > 0.6)\n    {\n        float translateHeight = 0.25;\n        vec2 repeatMark = vec2(sign(p.x), 1.) ;\n        float redMark = .01-length( p * repeatMark - vec2(widthStereogramHalf, -translateHeight ))  ;\n    \trgb = mix(rgb, vec3(1.,0.,0.),  step(0., redMark )  );\n    }\n     \n    \n\tfragColor = vec4(rgb,1.0);\n\n     \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.yxy*4.+vec3(0,2,4));\n\tfragColor = mix(fragColor , vec4(col,1.0), .2)*1.0;\n    \n    float fade = (iTime*.1);\n    fade = (fade*=fade)*(fade*=fade);\n    if (fade < 1.)\n    \tfragColor.xyz += str( p + (hashFix2D(p)-.5)*2.*fade, vec2(-4.,-.4), .2, .5, 8, 24 );\n    \n    //  Can you read-me? (Stereogram)... no? give up?\n    // => \n\t// fragColor = mix(fragColor, vec4(raymarching(p))*0.1, (t*=t)*(t*=t));\n}\n\n ","name":"Image","description":"","type":"image"}]}