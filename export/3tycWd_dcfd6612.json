{"ver":"0.1","info":{"id":"3tycWd","date":"1612712741","viewed":415,"name":"Deferred Shading Möbius","username":"ming","description":"Porting the classic Möbius shader to deferred shading, added with the following features:\n- gbuffer packing\n- variance clipping \n- temporal\n  - ssao\n  - contact shadows\n- simple dof\n- gamma correct shading\n- ssr","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["shadow","dof","gamma","ssao","moebius","deferred"],"hasliked":0,"parentid":"ldl3zr","parentname":"Möbius balls"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// DOF and other post-processing\n\n#define COUNT 8\nvec4 dof( vec2 uv, float radius, vec2 fragCoord )\n{\n    vec4 blurred = vec4(0.0);\n    \n    vec2 seed = texture(iChannel3, uv).xy;\n    \n    float r_offset = hash(seed.x + float((iFrame) % 1000));\n    float phi_offset = fract(seed.y + sqrt(3.0) * float((iFrame) % 1000));\n    \n    for(int i = 0; i < COUNT; i++)\n    {\n        vec2 off = vogel_disk(i, COUNT, r_offset, phi_offset);\n        \n        vec2 sampleUv = (fragCoord.xy + floor(off*radius))/iResolution.xy;\n        blurred += textureLod(iChannel0, sampleUv, 0.0);\n    }\n    blurred /= float(COUNT);\n    \n    return blurred;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy  / iResolution.xy;\n    vec4 sceneColor = texture(iChannel0, uv);\n    \n    float r = 5.0;\n    \n    float c = 9.5;\n    float f = 2.5;\n    float w = smoothstep(0.0, f, abs(sceneColor.w-c));\n    w = w * w;\n    r *= w;\n    \n\tsceneColor = dof(uv, r, fragCoord);\n    \n    if (w > 0.0) {\n        vec2 delta = vec2(w * 2.0);\n        sceneColor.g = dof(uv, r, fragCoord+delta).g;\n        sceneColor.b = dof(uv, r, fragCoord-delta).b;\n    }\n    \n    // blooming tricks with mipmaps\n    sceneColor += \n        (textureLod(iChannel0, uv, 3.) + \n         textureLod(iChannel0, uv, 4.) + \n         textureLod(iChannel0, uv, 5.)) * 0.125;\n    \n    fragColor = pow(sceneColor, vec4(0.454545));\n    \n    //sceneColor = texture(iChannel0, uv);\n    \n    \n    \n    //vec3 dir = normalize(CamTarget - camera(camera_time()));\n    //vec3 vsdir = worldToViewSpace(dir, camera_time());\n    //fragColor = vec4(abs(dot(vec3(0.,0.,1.), vsdir)));\n    \n    //fragColor = vec4(worldToViewSpace(gbuffer.xyz, camera_time()), 1.0);\n    \n    //fragColor = vec4(w);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// if you encounter strange colors / freezing, please uncomment the following line\n#define SAFE_MODE\n\n/// Basic Settings\n#define PI 3.14159265398\n\n#define SSR_DEBUG 0\n\n#define RAY_MARCH_STEPS 80\n#define MAX_DEPTH 60.0\n\n#define GROUND -2.0\n\n\nconst vec3 CamTarget = vec3(0.0, -1.5, 0.0);\nconst vec3 L = normalize(vec3(0.25, 1.0, -0.5)); // world space Lightdir\n\nvec2 r(vec2 v,float y)\n{\n    return cos(y)*v+sin(y)*vec2(-v.y,v.x);\n}\n\n/// GBuffer\n\n#define color_bits vec4( 6, 6, 6, 6 )\n#define color_values exp2( color_bits )\n#define color_rvalues (1. / color_values)\n#define color_maxValues (color_values - 1.)\n#define color_rmaxValues (1. / color_maxValues)\n#define color_positions vec4( color_values.x*color_values.y*color_values.z, color_values.x*color_values.y, color_values.x, 1. )\n#define color_rpositions (1. / color_positions)\n\n\nfloat encodeColor(vec4 a){\n\t\n    // convert from [0, 1] to [0, color_maxValues]\n    // pre-multiply 0.5 to a to avoid overflow\n    a = floor(a * (0.5 * color_maxValues) + 0.5);\n    \n    // bit shift then OR\n\treturn dot( a, color_positions );\n}\n\nvec4 decodeColor(float a){\n\n    // bit shift \n    // (we 1.0 / color_values so that we can use fract() instead of mod()) for bit masking\n    vec4 a4 = a * (color_rpositions / color_values);\n    \n    // bit masking for each component\n    // use fract() instead of mod() for performance reason\n    a4 = fract(a4);\n    \n    // since we use fract(), we need to multiply color_values back to a4\n    // then convert from [0, color_maxValues] back to [0, 1]\n    // multiply by 2.0 to cancel out the 0.5 pre-multiplication in encoding\n    return a4 * (2.0 * color_values / color_maxValues);\n}\n\n\n// Octahedron normal encode\nvec2 encodeNormal( in vec3 nor )\n{\n    nor /= ( abs( nor.x ) + abs( nor.y ) + abs( nor.z ) );\n    nor.xy = (nor.z >= 0.0) ? nor.xy : (1.0-abs(nor.yx))*sign(nor.xy);\n    vec2 v = 0.5 + 0.5*nor.xy;\n\n    return v;\n}\n\nvec3 decodeNormal( in vec2 v )\n{\n    v = -1.0 + 2.0*v;\n    // Rune Stubbe's version, much faster than original\n    vec3 nor = vec3(v, 1.0 - abs(v.x) - abs(v.y));\n    float t = max(-nor.z,0.0);\n    nor.x += (nor.x>0.0)?-t:t;\n    nor.y += (nor.y>0.0)?-t:t;\n    return normalize( nor );\n}\n\n/// Animation Time\n\nvec3 camera(float time)\n{\n    return vec3(cos(time) * 3.0, 3.5 + sin(time) * 1.5, -11.0);\n}\n\n\nfloat camera_time_impl(int offset, int frame)\n{\n    return 0.02 * float(frame + offset);\n}\n\n#define camera_time() camera_time_impl(0, iFrame)\n#define camera_time_last() camera_time_impl(-1, iFrame)\n\nfloat model_time_impl(int offset, int frame)\n{\n//#if SSR_DEBUG\n//    return 1.0;\n//#else\n    return 0.005 * float(frame + offset);\n//#endif\n}\n\n#define model_time() model_time_impl(0, iFrame)\n#define model_time_last() model_time_impl(-1, iFrame)\n\nfloat camera_fov() { return radians(50.0); }\n\n\n\n/// Reprojections\nvoid rayForFragCoord(in vec2 fragCoord, in vec2 resolution, in float time, out vec3 ro, out vec3 rd)\n{\n    vec3 pos = camera(time);\n    float viewDist = distance(pos, CamTarget);\n\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 dir = (CamTarget - pos) / viewDist;\n    vec3 right = normalize(cross(dir, up));\n    up = normalize(cross(right, dir));\n    \n    float imgU = tan(camera_fov()) * viewDist;\n    float imgV = imgU * resolution.y / resolution.x;\n\n    vec2 uv = fragCoord / resolution.xy * 2.0 - 1.0;\n    \n    dir = normalize(CamTarget + uv.x * imgU * right + uv.y * imgV * up - pos);\n    \n    ro = pos;\n    rd = dir;\n}\n\nvoid rayForFragCoordViewSpace(in vec2 fragCoord, in vec2 resolution, in float time, out vec3 rd)\n{\n    vec3 pos = camera(time);\n    float viewDist = distance(pos, CamTarget);\n\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 dir = vec3(0.0, 0.0, 1.0);\n    vec3 right = vec3(1.0, 0.0, 0.0);\n    \n    float imgU = tan(camera_fov()) * viewDist;\n    float imgV = imgU * resolution.y / resolution.x;\n\n    vec2 uv = fragCoord / resolution.xy * 2.0 - 1.0;\n    \n    dir = normalize(vec3(0.0, 0.0, viewDist) + uv.x * imgU * right + uv.y * imgV * up);\n    \n    rd = dir;\n}\n\nvec3 worldToViewSpace(in vec3 ws, in float time)\n{\n    vec3 pos = camera(time);\n\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 dir = normalize(CamTarget - pos);\n    vec3 right = normalize(cross(dir, up));\n    up = normalize(cross(right, dir));\n    \n    mat3 m = mat3(right, up, dir);\n    \n    return ws * m;\n}\n\nvec2 fragCoordForWorldPos(in vec3 worldPos, in vec2 resolution, in float time)\n{\n    vec3 pos = camera(time);\n    \n    float viewDist = distance(pos, CamTarget);\n    \n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 dir = (CamTarget - pos) / viewDist;\n    vec3 right = normalize(cross(dir, up));\n    up = normalize(cross(right, dir));\n\n    float imgU = tan(camera_fov()) * viewDist;\n    float imgV = imgU * resolution.y / resolution.x;\n\n    float dWorld = dot(worldPos - pos, dir);\n    float dProj = viewDist;\n    vec3 projPos = (worldPos - pos) * (dProj / dWorld) + pos - CamTarget;\n    \n    vec2 uv = vec2(dot(projPos, right) / imgU,\n                   dot(projPos, up)    / imgV) * 0.5 + 0.5;\n    return uv * resolution.xy;\n}\n\nvec2 fragCoordForViewPos(in vec3 viewPos, in vec2 resolution, in float time)\n{\n    vec3 pos = camera(time);\n    \n    float viewDist = distance(pos, CamTarget);\n    \n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 dir = vec3(0.0, 0.0, 1.0);//(CamTarget - pos) / viewDist;\n    vec3 right = vec3(1.0, 0.0, 1.0);\n\n    float imgU = tan(camera_fov()) * viewDist;\n    float imgV = imgU * resolution.y / resolution.x;\n\n    float dView = dot(viewPos, dir);\n    float dProj = viewDist;\n    vec3 projPos = (viewPos) * (dProj / dView) - vec3(0.0, 0.0, viewDist);\n    \n    vec2 uv = vec2(dot(projPos, right) / imgU,\n                   dot(projPos, up)    / imgV) * 0.5 + 0.5;\n    return uv * resolution.xy;\n}\n\n\n\nvec2 fragCoordForDir(in vec3 worldDir, in vec2 resolution, in float time)\n{\n    vec3 pos = camera(time);\n    float viewDist = distance(pos, CamTarget);\n    \n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 dir = normalize(CamTarget - pos);\n    vec3 right = normalize(cross(dir, up));\n    up = normalize(cross(right, dir));\n    \n    float imgU = tan(camera_fov()) * viewDist;\n    float imgV = imgU * resolution.y / resolution.x;\n\n    float dProj = distance(pos, CamTarget);\n    \n    //vec3 worldPosA = CamTarget;\n    vec3 worldPosB = CamTarget + worldDir;\n    \n    \n    //float dWorldA = dot(worldPosA - pos, dir);\n    float dWorldB = dot(worldPosB - pos, dir);\n    \n    \n    //vec3 projPosA = (worldPosA - pos) * (dProj / dWorldA) + pos - CamTarget;\n    vec3 projPosB = (worldPosB - pos) * (dProj / dWorldB) + pos - CamTarget;\n    \n    //vec2 uvA = vec2(dot(projPosA, right) / imgU,\n    //                dot(projPosA, up)    / imgV) * 0.5 + 0.5;\n                    \n    vec2 uvB = vec2(dot(projPosB, right) / imgU,\n                    dot(projPosB, up)    / imgV) * 0.5 + 0.5;\n                    \n    \n    // since CamTarget always stay at [0.5, 0.5]\n    return normalize((uvB * resolution.xy) - (0.5 * resolution.xy));\n}\n\nvec2 vogel_disk(int i, int num_samples, float r_offset, float phi_offset)\n{\n\tfloat r = sqrt(abs((float(i) + r_offset)) / float(num_samples));\n    float golden_angle = 2.399963229728;\n    float phi = float(i) * golden_angle + 2.0 * PI * phi_offset;\n    float x = r * cos(phi);\n    float y = r * sin(phi);\n\n    return vec2(x, y);\n}\n\nfloat hash(float seed)\n{\n    return fract(sin(seed * 12.9899) * 43758.5453); \n}\n\nfloat halton(int i, int b)\n{\n    /* Creates a halton sequence of values between 0 and 1.\n\thttps://en.wikipedia.org/wiki/Halton_sequence\n\tUsed for jittering based on a constant set of 2D points. */\n    float f = 1.0;\n    float r = 0.0;\n    while(i > 0)\n    {\n        f = f / float(b);\n        r = r + f * float(i % b);\n        i = i / b;\n    }\n    return r;\n}\n\nfloat clipToAABB(in float cOld, in float cNew, in float centre, in float halfSize)\n{\n    if (abs(cOld - centre) <= halfSize) {\n        return cOld;\n    }\n    \n    float dir = (cNew - cOld);\n    \n    if (abs(dir) < 1e-5)\n        return cOld;\n        \n    float near = centre - sign(dir) * halfSize;\n    float t = (near - cOld) / dir;\n    \n    if (t < 0.0) {\n\t\treturn cOld;\n    }\n    \n    return cOld + dir * t;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/// GBuffer setup\n\nfloat somestep(float t)\n{\n    return pow(t, 4.0);\n}\n\nvec3 smin(vec3 a, vec3 b)\n{\n    if (a.x < b.x)\n        return a;\n    \n    return b;\n}\n\nvec3 smax(vec3 a, vec3 b)\n{\n\tif (a.x > b.x)\n        return a;\n    \n    return b;\n}\n\nvec3 sinv(vec3 a)\n{\n\treturn vec3(-a.x, a.y, a.z);    \n}\n\n\n//repeat around y axis n times\nvoid rp(inout vec3 p, float n) {\n\tfloat w = 2.0*PI/n;\n\tfloat a = atan(p.z, p.x);\n\tfloat r = length(p.xz);\n\ta = mod(a+PI*.5, w)+PI-PI/n;\n\tp.xz = r*vec2(cos(a),sin(a));\n}\n\nvec3 moebius(vec3 p, vec3 q)\n{\n  float a = atan(p.z, p.x);\n  vec2 p2 = vec2(length(p.xz),p.y);\n  p2.x -= q.z;\n  p2 = r(p2, a*0.5);\n  vec2 p3 = r(p2, PI/4.0);\n  vec2 tc = vec2(p3.y,a);\n  float d = abs(p2.y)-q.x;\n  d = max(d,abs(p2.x)-q.y);\n  return vec3(d, tc);\n}\n \nvec3 dualmoebius(vec3 p)\n{\n\tfloat bandSize = 1.5;\n\tfloat radius = 5.0;\n\tfloat bandThickness = 0.75;\n\treturn smax(moebius(p, vec3(bandSize, bandThickness, radius)), sinv(moebius(p, vec3(bandSize - bandThickness, bandThickness+0.1, radius))));\n}\n \nvec3 sphere(vec3 p, float r)\n{\n    vec3 n = normalize(p);\n    vec2 tc = asin(n.xz)/PI + 0.5;\n\treturn vec3(length(p) - r, tc * 2.0);\n}\n\nvec3 spheres(vec3 p)\n{\n\trp(p, 12.0);\n\tp.x += 5.0;\n\treturn sphere(p, 0.75);\t\n}\n\nvec3 plane( vec3 p, vec3 n, float y )\n{\n\t// n must be normalized\n    vec2 tc = p.xz * 0.05;\n\treturn vec3(dot(p,n) - y, tc);\n}\n\nvec3 f( vec3 p )\n{\n    vec3 g = plane(p, vec3(0.0,1.0,0.0), GROUND);\n    \n    float mt = model_time();\n\tp.yz = r(p.yz, mt);\n    \n    vec3 q = p;\n\tq.xz = r(q.xz, mt * 2.0);\n\n//#if SSR_DEBUG\n#if 0\n    return smin( g, smin(sphere(p, 3.0), spheres(q) ) );\n#else\n\treturn smin( g, smin(sphere(p, 3.0), smin(spheres(q), dualmoebius(q))) );\n#endif\n}\n\nvec4 get_material(vec3 hit, vec3 ray, vec3 normal, float t, vec3 d) \n{\n    vec3 albedo = pow(texture(iChannel0, d.yz).rgb, vec3(2.2));\n    \n    // make the albedo color less saturated\n    albedo = mix(vec3(dot(vec3(0.299, 0.587, 0.114), albedo)), albedo, 0.625);\n    \n    vec3 second = pow(texture(iChannel1, d.yz * 0.05).rgb, vec3(2.2));\n    float rough = second.g;\n    rough = 1.0 - smoothstep(0.0, 0.5, rough) * 0.95;\n    \n    if ((abs(hit.y - GROUND) < 1e-2) )\n    {\n        albedo = pow(texture(iChannel2, d.yz).rgb, vec3(2.2));\n        rough = 0.0;\n    }\n    return vec4(albedo, rough);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.xyz = vec3(0);\n    \n    vec3 p, q;\n    rayForFragCoord(fragCoord, iResolution.xy, camera_time(), p, q);\n\n    float t=0.;\n    vec3 d = vec3(0);\n    float steps = 0.0;\n    for (int tt=0; tt < RAY_MARCH_STEPS; ++tt )\n    {\n        d = f(p+q*t);\n        t += d.x * 0.95;\n        if( !(t<=MAX_DEPTH)||d.x<=0.000001)\n        {\n            break;\n        }\n        steps = float(tt);\n    }\n\n    vec3 hit = p+q*t;\n    \n    vec4 gbuffer;\n    \n    if( t < MAX_DEPTH )\n    {\n\n        vec2 e = vec2(0.05, 0.0);\n        vec3 normal= vec3( f(hit + e.xyy).x - f(hit - e.xyy).x, f(hit + e.yxy).x - f(hit - e.yxy).x, f(hit + e.yyx).x - f(hit - e.yyx).x);\n        normal = normalize(normal);\n        \n        vec4 material = get_material(hit, q, normal, t, d);\n        \n        vec2 v = encodeNormal(normal);\n        \n        gbuffer.r = encodeColor(material);\n        gbuffer.g = v.x;\n        gbuffer.b = v.y;\n        \n        vec3 vsD = worldToViewSpace(q, camera_time());\n        gbuffer.a = vsD.z * t; // view space linear depth\n        \n    }\n    else\n    {\n        vec2 v = encodeNormal(q);\n        \n        gbuffer.r = 0.0;\n        gbuffer.g = v.x;\n        gbuffer.b = v.y;\n        gbuffer.a = MAX_DEPTH + 1.0;\n    }\n    \n    fragColor = gbuffer;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// SSAO, Contact Shadows, SSR\n#define COUNT_SSAO 4\n#define COUNT_SHADOW 8\n\n#define SSR_THRESHOLD 0.1\n#define SSR_THICKNESS 2.0\n\n\nfloat ssao( vec2 uv, vec4 gbuffer, float radius, vec2 fragCoord, vec2 seed )\n{    \n    float depth = gbuffer.w;\n    \n    float ao = 0.0;\n    \n    float r_offset = 0.0;//hash(seed.x + float((iFrame) % 1000));\n    float phi_offset = fract(seed.y + sqrt(3.0) * float((iFrame) % 1000));\n    \n    for(int i = 0; i < COUNT_SSAO; i++)\n    {\n        vec2 off = vogel_disk(i, COUNT_SSAO, r_offset, phi_offset);\n        \n        vec2 sampleUv = (fragCoord.xy + floor(off*radius))/iResolution.xy;\n        vec4 sampleGBuf = texture(iChannel0, sampleUv);\n        \n        float depthDelta = depth - sampleGBuf.w;\n        \n        float occ = clamp(depthDelta/0.2, 0.0, 1.0);\n        ao += occ;      \n    }\n    ao = 1.0 - ao / float(COUNT_SSAO);\n    \n    return ao;\n}\n\nfloat contactShadow( vec2 uv, vec4 gbuffer, float radius, vec2 fragCoord, vec2 seed )\n{    \n    float depth = gbuffer.w;\n    \n    // calculate the screen space light direction by reverse-projection\n    vec2 Ldir = fragCoordForDir(L, iResolution.xy, camera_time_last());\n    \n    int iseed = iFrame + int(floor(seed.x * 1000.));\n    float jitter = halton(iseed, 3);\n    \n    float shw = 0.0;\n    float div = 1.0 / float(COUNT_SHADOW);\n\n    vec2 Ldelta = radius * Ldir * div;\n\n    for(int i = 0; i < COUNT_SHADOW; i++)\n    {\n        float fi = float(i);\n        vec2 off = (fi+jitter) * Ldelta;\n\n        vec2 sampleUv = (fragCoord.xy + off)/iResolution.xy;\n        vec4 sampleGBuf = texture(iChannel0, sampleUv);\n        float depthDelta = depth - sampleGBuf.w;\n\n        if (depthDelta > 0.0)\n        {\n            // fade out shadows from contact point\n            shw += clamp(1.0 - depthDelta / 8.0, 0.0, 1.0);\n        }\n    }\n    \n    return clamp(1.0 - shw, 0.0, 1.0);\n}\n\n\nbool ssrTrace(vec3 P, vec3 R, float threshold, float jitter, out vec2 ret)\n{\n    ret = vec2(-1.0);\n    \n    vec3 begView = P;\n    vec3 endView = P + R * 8.0;\n    vec2 begCoord = fragCoordForViewPos(begView, iResolution.xy, camera_time());\n    vec2 endCoord = fragCoordForViewPos(endView, iResolution.xy, camera_time());\n    \n    vec3 delta = vec3(endCoord - begCoord, (endView - begView).z);\n      \n    #ifdef SAFE_MODE\n    const float cnt = 64.0;\n    #else\n    float cnt = max(0.0, max(abs(delta.x), abs(delta.y)) / 2.0);\n    \n    if (cnt <= 1.0)\n        return false;\n    #endif\n    \n    delta /= cnt;\n    \n    vec3 curr = vec3(begCoord, P.z);\n    curr += delta * jitter;\n    \n    float closest = -1.0;\n    vec3 closestUVZ = vec3(-1.0);\n    \n    for(int i = 0; i < int(cnt); i++)\n    {\n        \n        if (curr.x < 0. || curr.y < 0. || curr.x > iResolution.x || curr.y > iResolution.y)\n            break;\n        \n        vec2 sampleCoord = curr.xy;\n        \n        vec2 sampleUv = sampleCoord / iResolution.xy;\n        vec4 sampleGBuf = texture(iChannel0, sampleUv);\n        \n        float depthDelta = curr.z - sampleGBuf.w;\n        \n        if (depthDelta > 0.0)\n        {\n            if( depthDelta < threshold )\n            {\n                ret = sampleUv;\n                return true;\n            }\n            else if (closest == -1.0 || depthDelta < closest)\n            {\n                closest = abs(depthDelta);\n                closestUVZ = vec3(sampleUv, curr.z);\n            }\n        }\n        \n        curr += delta;\n    }\n    \n    \n    if (closest > -1.0)\n    {\n        // check the closest pixel is 'close' enough th treat as an occluder\n        vec4 sampleGBuf = texture(iChannel0, closestUVZ.xy);\n        vec3 sampleNrm = decodeNormal(sampleGBuf.gb);\n        \n        // scale the occluder thickness according to its normal\n        float effectiveThickness = abs(sampleNrm.z) * SSR_THICKNESS;\n        if (closest < effectiveThickness)\n        {\n            ret = closestUVZ.xy;\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nvec2 ssReflection( vec4 gbuffer, vec2 fragCoord, vec2 seed)\n{\n    float depth = gbuffer.w;\n    \n    vec3 vsNrm = worldToViewSpace(gbuffer.xyz, camera_time());\n    vec3 vsDir;\n    rayForFragCoordViewSpace(fragCoord, iResolution.xy, camera_time(), vsDir);\n    \n    vec3 R = reflect(vsDir, vsNrm);\n    vec3 P = vsDir * depth;\n    \n    int iseed = iFrame + int(floor(seed.x * 1000.));\n    float jitter = halton(iseed, 2);\n    \n    vec2 ret;\n    if(ssrTrace(P, R, SSR_THRESHOLD, jitter, ret))\n    {\n        return ret;\n    }\n    \n    \n    return vec2(-1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 gbuffer = texture(iChannel0, uv);\n    \n    \n    if (gbuffer.w < MAX_DEPTH) {\n    \n        vec4 material = decodeColor(gbuffer.r);\n        \n        vec2 seed = texture(iChannel2, uv).xy;\n        \n        // only compute the lbuffer if this is not an background pixel\n        gbuffer.xyz = decodeNormal(gbuffer.gb);\n        \n        float ao = 1.0;\n        vec2 ssr = vec2(-1.0);\n        \n        //if (material.a > 0.0)\n        ao = ssao(uv, gbuffer, 16.0, fragCoord, seed);\n        if (material.a == 0.0)\n            ssr = ssReflection(gbuffer, fragCoord, seed);\n            \n        float shw = contactShadow(uv, gbuffer, 256.0, fragCoord, seed);\n\n        fragColor = vec4(ao, shw, ssr.x, ssr.y);\n    }\n    else\n    {\n        fragColor = vec4(1.0, 1.0, -1.0, -1.0);\n    }\n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":3,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// temporal up sampleing with Marco Salvi's Variance Clipping\n\n#define COUNT 8\n#define RADIUS 8.0\n#define VARIANCE_CLIPPING 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    if (iFrame <= 1) {\n        fragColor = texture(iChannel1, uv);\n    }\n    else\n    {\n        vec4 gbuffer = texture(iChannel0, uv);\n        vec4 colorCurr = texture(iChannel1, uv);\n\n        // reprojection\n        vec3 vsD;\n        rayForFragCoordViewSpace(fragCoord, iResolution.xy, camera_time(), vsD);\n\n        // gbuffer.a = vsD.z * t;\n        float t = gbuffer.a / vsD.z;\n        vec2 fcOld = fragCoordForViewPos(vsD * t, iResolution.xy, camera_time_last());\n\n        vec4 colorOld = texture(iChannel2, fcOld / iResolution.xy);\n\n    #if VARIANCE_CLIPPING\n        // Look up colours for the immediate neighbourhood of the pixel in\n        // this frame. Calculate the first two moments of their distribution\n        // (i.e. mean and standard deviation).\n\n        vec4 mean = vec4(0.0);\n        vec4 stddev = vec4(0.0);\n\n        vec2 seed = texture(iChannel3, uv).xy;\n        float r_offset = 0.0;//hash(seed.x + float((iFrame) % 1000));\n        float phi_offset = fract(seed.y + sqrt(3.0) * float((iFrame) % 1000));\n\n        for(int i = 0; i < COUNT; i++)\n        {\n            vec2 off = vogel_disk(i, COUNT, r_offset, phi_offset);\n            vec2 fcOffset = floor(off * RADIUS + 0.5);\n\n            vec4 c = texture(iChannel1, (fragCoord + fcOffset) / iResolution.xy);\n            mean += c;\n            stddev += c * c;      \n        }\n\n        mean /= float(COUNT);\n        // since zw may contains -1.0 if SSR cannot find an occluder.\n        // we need to clamp it to zero before sqrt\n        stddev = sqrt(max(vec4(0.0), stddev / float(COUNT) - mean * mean));\n\n        // since we are storing uncorrelated data in each channel, we need to clip it separatly\n        colorOld.r = clipToAABB(colorOld.r, colorCurr.r, mean.r, stddev.r);\n        colorOld.g = clipToAABB(colorOld.g, colorCurr.g, mean.g, stddev.g);\n        //colorOld.b = clipToAABB(colorOld.b, colorCurr.b, mean.b, stddev.b);\n        //colorOld.a = clipToAABB(colorOld.a, colorCurr.a, mean.a, stddev.a);\n\n    #endif\n\n        fragColor.xy = mix(colorOld, colorCurr, 0.2).xy;\n        fragColor.zw = colorCurr.zw;\n    }\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Shading\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 gbuffer = texture(iChannel0, uv);\n    vec4 lbuffer = texture(iChannel1, uv);\n    vec2 ssr = lbuffer.zw;\n    lbuffer.xy = lbuffer.xy * lbuffer.xy;\n    \n    vec3 normal = decodeNormal(gbuffer.gb);\n    float depth = gbuffer.a;\n    \n    vec4 result;\n    \n    if (depth < MAX_DEPTH) {\n        \n        vec3 viewRO, viewRD;\n        rayForFragCoord(fragCoord, iResolution.xy, camera_time(), viewRO, viewRD);\n        vec4 material = decodeColor(gbuffer.r);\n        vec3 albedo = material.rgb;\n        float roughness = material.w;\n        \n        vec3 reflDir = reflect(viewRD, normal);\n        vec3 ibl = \n            mix(pow(textureLod(iChannel2, normal, 2.0).rgb, vec3(2.2)),\n                pow(textureLod(iChannel2, normal, 5.0).rgb, vec3(2.2)),\n                roughness);\n                \n        vec3 refl = \n            mix(pow(textureLod(iChannel2, reflDir, 0.0).rgb, vec3(2.2)),\n                pow(textureLod(iChannel2, reflDir, 5.0).rgb, vec3(2.2)),\n                roughness);\n                \n        if (ssr.x > -1.0 && ssr.y > -1.0)\n        {\n            vec3 ssrColor = texture(iChannel3, ssr).xyz;\n            float w = 0.0;\n            \n            #if SSR_DEBUG == 0\n            // fade out ssr according to uv distance\n            w = length(uv - ssr);\n            w = clamp(w * 2.0, 0.0, 1.0);\n            w = w * w;\n            w = w * w;\n            #endif\n            \n            refl = mix(ssrColor, refl, w);\n        }\n        \n        float direct = clamp(dot(L, normal), 0.0, 1.0);\n        vec3 diffuse = vec3(direct * lbuffer.g);\n        diffuse += ibl * lbuffer.r;\n        diffuse *= albedo;\n        \n        float ndotv = dot(-viewRD, normal);\n        float r0 = 0.04;\n        float fren = r0 + (1.0 - r0) * pow(1.0 - ndotv, 3.0);\n        fren = fren * 0.75 + 0.25;\n        \n        vec3 specular = refl * lbuffer.r * fren;\n        result.xyz = diffuse + specular;\n        \n        //result.xyz = vec3(lbuffer.g * direct);\n        //result.xyz = vec3(lbuffer.r);\n        //result.xyz = vec3(roughness);\n        //result.xyz = albedo;\n        //result.xyz = vec3(fres);\n        \n        #if SSR_DEBUG\n        result.xyz = refl;\n        \n        //result.xyz = vec3(max(vec2(0.0), ssr), 0.0);\n        #endif\n        \n        result.w = depth;\n        \n    }\n    else {\n        vec3 bg = pow(textureLod(iChannel2, normal, 0.0).rgb, vec3(2.2));\n        result = vec4(bg, depth);\n    }\n    \n    fragColor = result;\n}","name":"Buffer D","description":"","type":"buffer"}]}