{"ver":"0.1","info":{"id":"4tt3Wl","date":"1472425111","viewed":128,"name":"Heart has its reasons","username":"Draedrus","description":"experiment","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["experiment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define CAMPOS vec3(0, 1.85, -1.0)\n#define CAMDIST 2.0\n#define CAMROTSPEED 1.0\n#define TARGETPOS vec3(0.0, 0.0, 3.0)\n\n\n// the camera construction method is inspired by the one from IQ\nmat3 setCamera( in vec3 origin, in vec3 target, vec3 viewUp )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cu = normalize( cross(cw,viewUp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n// https://www.shadertoy.com/view/MdGGWh\nmat3 Gx = mat3(-1.0, 0.0, 1.0,\n               -2.0, 0.0, 2.0,\n               -1.0, 0.0, 1.0);\n\nmat3 Gy = mat3(-1.0, -2.0, -1.0,\n               0.0, 0.0, 0.0,\n               1.0, 2.0, 1.0);\n\n\nfloat applyKernel(mat3 gx, mat3 gy, sampler2D sampler, vec2 uv) {\n    float final = 0.0;\n    \n   \n    float horizontal = 0.0;\n    float vertical = 0.0;\n    \n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n          vec2 d = vec2(float(i), float(j)) / iChannelResolution[0].xy;\n          float averagePixel = dot(texture(sampler, uv+d).xyz, vec3(0.33333));\n            \n          horizontal += averagePixel * gx[i][j];\n          vertical += averagePixel * gy[i][j];            \n        }\n    }\n    \n    final = sqrt(horizontal * horizontal + vertical * vertical);\n    return final;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pixel = -1.0 + 2.0*uv;// vec2(iResolution.x*0.6, iResolution.y);\n\tpixel.x *= iResolution.x/iResolution.y;\n    \n    vec4 depth = texture(iChannel0, uv);\n    \n    vec3 diffuse = texture(iChannel1, uv).rgb;\n    \n    vec3 color = diffuse;\n    \n    float border = 1.0;\n    float dmin = 10000.0;\n    float dmax = 0.0;\n    // fake ao\n    if(depth.w>0.0)\n    {\n        for(float i=-0.002;i<0.003;i+=0.001)\n            for(float j=-0.002;j<0.003;j+=0.001)\n            {\n                float d = texture(iChannel0, uv+vec2(i, j)).w;\n                 dmin = min(dmin, d);\n                 dmax = max(dmax, d);\n            }\n        border = dmax-dmin;\n    }\n    \n    float bord = applyKernel(Gx, Gy, iChannel2, uv)*8.0;\n    \n    vec4 colorVeins = texture(iChannel2, uv);\n    \n    if(depth.w>0.0)\n    {\n        color = diffuse+border+mix(vec3(0.0), colorVeins.rgb, 1.0-bord);//-pow(bord, 1.5);\n    }\n    \n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/***********************************************************************\n * author: pierre.plans@gmail.com\n * thanks again to IQ for letting me discover raymarching algorithms\n ***********************************************************************/\n\n#define FAR 6.0\n#define NEAR 0.002\n\n#define NUM_STEPS 60\n#define CAMPOS vec3(0, 1.85, -1.0)\n#define CAMDIST 2.0\n#define CAMROTSPEED 1.0\n#define TARGETPOS vec3(0.0, 0.0, 3.0)\n\n#define OBJECTSIZE 1.0\n\n#define TYPE_FLOOR 0.0\n#define TYPE_WATER 1.0\n#define TYPE_BOAT 2.0\n#define TYPE_CLOUD 3.0\n\n/*******************\n * TOOLS\n *******************/\n\nvec3 RotXV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(1.0, 0.0, 0.0, 0.0, cA, -sA, 0.0, sA, cA);\n}\nvec3 RotYV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(cA, 0.0, -sA, 0.0, 1.0, 0.0, sA, 0.0, cA);\n}\nvec3 RotZV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(cA, -sA, 0.0, sA, cA, 0.0, 0.0, 0.0, 1.0);\n}\n\n/********************\n * NOISES\n ********************/\n\nfloat hash2D(vec2 x) {\n\treturn fract(sin(dot(x, vec2(13.454, 7.405)))*12.3043);\n}\n\nfloat hash3D(vec3 x) {\n\treturn fract(dot(x, vec3(12.4955, 49.4294, 42.40594))*13.4959451);    \n}\n\nfloat noise3D(vec3 x) {\n    vec3 p = floor(x);\n    vec3 n = fract(x);\n    vec3 f = n*n*(3.0-2.0*n);\n    float winx = 1.0;\n    float winy = 1.0;\n    float winz = 1.0;\n    \n    return mix(\n        \tmix(\n                mix(hash3D(p)     \t\t\t\t  , hash3D(p+vec3(winx, 0.0, 0.0)), f.x),\n                mix(hash3D(p+vec3(0.0, winy, 0.0)), hash3D(p+vec3(winx, winy, 0.0)), f.x),\n                f.y),\n        \tmix(\n                mix(hash3D(p+vec3(0.0, 0.0, winz)), hash3D(p+vec3(winx, 0.0, winz)), f.x),\n                mix(hash3D(p+vec3(0.0, winy, winz)), hash3D(p+vec3(winx, winy, winz)), f.x),\n                f.y),\n   \t\t\tf.z);\n}\n\n// Simplex 2D noise\n// sources: Ian McEwan - https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\n// sources: Patricio Gonzalez Vivo - https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\nfloat snoise(vec2 v){\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n                        -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n                     + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n                            dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n/**\n * This one is inspired by IQ code from this website.\n **/\nfloat fbm2D(vec2 p) {\n    float total = 0.0;\n    total  = 0.5000* snoise(p); p = p*2.0;\n    total += 0.2500* snoise(p); p = p*2.0;\n    total += 0.1250* snoise(p); p = p*2.0;\n    total += 0.0625* snoise(p); p = p*2.0;\n    return total;\n}\n\nfloat fbm3D(vec3 p) {\n    float total = 0.0;\n    total  = 0.5000* noise3D(p); p = p*2.0;\n    total += 0.2500* noise3D(p); p = p*2.0;\n    total += 0.1250* noise3D(p); p = p*2.0;\n    total += 0.0625* noise3D(p); p = p*2.0;\n    return total;\n}\n\nfloat voronoi2D(vec2 uv) {\n    vec2 fl = floor(uv);\n    vec2 fr = fract(uv);\n    float res = 1.0;\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec2 p = vec2(i, j);\n            float h = hash2D(fl+p);\n            vec2 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nfloat voronoi3D(vec3 uv) {\n    vec3 fl = floor(uv);\n    vec3 fr = fract(uv);\n    float res = 1.0;\n    for(int k=-1;k<=1;k++)\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec3 p = vec3(i, j, k);\n            float h = hash3D(fl+p);\n            vec3 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nfloat waterNoise(vec2 x) {\n    vec2 p = floor(x);\n    vec2 n = fract(x);\n    vec2 f = n*n*(3.0-2.0*n);\n    float winx = 1.0;\n    float winy = 1.0;\n    \n    return mix(\n                mix(hash2D(p)     , hash2D(p+vec2(winx, 0.0)), f.x),\n                mix(hash2D(p+vec2(0.0, winy)), hash2D(p+vec2(winx, winy)), f.x),\n                f.y);\n}\n\nfloat cloudNoiseFBMed(vec3 p)\n{\n    float f = 0.0;\n    vec3 q = 8.0*p;\n    f  = 0.5000*hash3D( q ); q = q*2.01;\n    f += 0.2500*hash3D( q ); q = q*2.02;\n    f += 0.1250*hash3D( q ); q = q*2.03;\n    f += 0.0625*hash3D( q ); q = q*2.01;\n    return f;\n}\n\nfloat cloudNoiseFBMed(vec2 p)\n{\n    float f = 0.0;\n    vec2 q = 8.0*p;\n    f  = 0.5000*waterNoise( q ); q = q*2.01;\n    f += 0.2500*waterNoise( q ); q = q*2.02;\n    f += 0.1250*waterNoise( q ); q = q*2.03;\n    f += 0.0625*waterNoise( q ); q = q*2.01;\n    return f;\n}\n\nfloat perlin(vec3 V) {\n    float total = 0.0;\n    for(int i=2;i<6+2;i++) {\n        total += (1.0/float(i))*snoise(V);\n        V*=2.0+(float(i)/100.0);\n    }\n    return total;\n}\n\nfloat clouds(vec3 p, vec2 scales)\n{\n    return perlin(p*scales.x)*(1.0-voronoi3D(p*scales.y));\n}\n\n/**\n * PRIMITIVES\n **/\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\nfloat sdSphere( vec3 p, float r)\n{\n\treturn length(p)-r;\n}\n\n/**\n * (Distance, Type) with Type =\n * 0.0 == Nthg\n **/\n\n/***********************\n * PRIMITIVE OPERATIONS\n ***********************/\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat polsmin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n/*******************\n * MAP ACTUAL ELEMENTS\n *******************/\n\n\nfloat mapTerrain(vec3 p, float s) {\n    float voro = voronoi3D(normalize(p.zyx)*4.0);\n    float bump = clamp(pow(voro, 8.0), 0.0, 1.0);\n    return polsmin(sdSphere(p, s),\n               polsmin(\n                   sdSphere(p-vec3(0.6, 0.6, 0.0), s*0.8),\n                   sdSphere(p-vec3(-0.6, 0.6, 0.0), s*0.8),\n                   0.2\n                   ),\n               0.2\n        )\n        +bump;\n}\n\n/*******************\n * MAP ACTUAL\n *******************/\n\nvec2 mapRM(vec3 p) {\n    vec2 d = vec2(-1.0, -1.0);\n    d = vec2(mapTerrain(p-TARGETPOS, OBJECTSIZE+sin(iTime)*0.1), TYPE_FLOOR);\n    return d;\n}\n\nvec2 mapRMDetailed(vec3 p) {\n    vec2 d = vec2(-1.0, -1.0);\n    d = vec2(mapTerrain(p-vec3(0.0, 00.0, 0.0), 1.0), TYPE_FLOOR);;\n    return d;\n}\n\n\n/**********************\n * RAYMARCHING\n **********************/\n\nvec2 raymarch(vec3 ro, vec3 rd, in float tmin, in float tmax) {\n    vec2 m = vec2(-1.0, -1.0);\n    vec2 res = vec2(tmin, -1.0);\n    res.x = tmin;\n\tfor( int i=0; i<NUM_STEPS; i++ )\n\t{\n        m = mapRM(ro + res.x*rd);\n\t\tif( m.x<tmin || res.x>tmax ) break;\n\t\tres.x += 0.5*m.x;\n        res.y = m.y;\n\t}\n    if( res.x>tmax ) {\n        res.y=-1.0;\n        res.x = tmax;\n    }\n\treturn res;\n}\n\n// the camera construction method is inspired by the one from IQ\nmat3 setCamera( in vec3 origin, in vec3 target, vec3 viewUp )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cu = normalize( cross(cw,viewUp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 camRotY(float t, vec3 ro) {\n    mat3 rotX = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(t), -sin(t),\n        0.0, sin(t), cos(t));\n    mat3 rotY = mat3(\n        cos(t), 0.0, sin(t),\n        0.0, 1.0, 0.0,\n        -sin(t), 0.0, cos(t));\n    mat3 rotZ = mat3(\n        cos(t), sin(t), 0.0,\n        -sin(t), cos(t), 0.0,\n    \t0.0, 0.0, 1.0);\n    \n    return rotY*ro;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy /iResolution.xy;\n    vec2 pixel = -1.0 + 2.0*uv;// vec2(iResolution.x*0.6, iResolution.y);\n\tpixel.x *= iResolution.x/iResolution.y;\n    \n    vec2 mv = -1.0 + 2.0*iMouse.xy/iResolution.xy+vec2(1.0, 0.0);\n    float Time = mod(iTime*CAMROTSPEED, 1000.0);\n\n    \n    vec3 ro = CAMPOS;\n    #ifdef CAMMOVING_ROTATION\n    ro.x = TARGETPOS.x+cos(Time*CAMROTSPEED)*CAMDIST;\n    ro.z = TARGETPOS.z+sin(Time*CAMROTSPEED)*CAMDIST;\n    #endif\n    ro.x = TARGETPOS.x+cos(mv.x*2.0)*4.0;\n    ro.y = TARGETPOS.y+sin(mv.y*2.0)*4.0;\n    ro.z = TARGETPOS.z+sin(mv.x*2.0)*4.0;\n    //ro.x = cos(iTime*CAMROTSPEED)*CAMDIST;\n    //ro.z = sin(iTime*CAMROTSPEED)*CAMDIST;\n    \n    vec3 target = TARGETPOS;/*+vec3(\n        cos(mv.x),\n        sin(mv.y),\n        1.0)*100.0;*/\n    \n    mat3 ca = setCamera(ro, target, vec3(0.0, 1.0, 0.0));\n    vec3 rd = ca*normalize(vec3(pixel.xy, 2.0));\n    vec2 rm = vec2(-1.0, -1.0);\n    rm = raymarch(ro, rd, NEAR, FAR);\n    fragColor = vec4(ro+rd*rm.x, (FAR-rm.x)/(FAR-NEAR));\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define DYING_IN_SECONDS 10.0\n\n/********************\n * NOISES\n ********************/\n\nfloat hash2D(vec2 x) {\n\treturn fract(sin(dot(x, vec2(13.454, 7.405)))*12.3043);\n}\n\nfloat hash3D(vec3 x) {\n\treturn fract(dot(x, vec3(12.4955, 49.4294, 42.40594))*13.4959451);    \n}\n\nfloat noise3D(vec3 x) {\n    vec3 p = floor(x);\n    vec3 n = fract(x);\n    vec3 f = n*n*(3.0-2.0*n);\n    float winx = 1.0;\n    float winy = 1.0;\n    float winz = 1.0;\n    \n    return mix(\n        \tmix(\n                mix(hash3D(p)     \t\t\t\t  , hash3D(p+vec3(winx, 0.0, 0.0)), f.x),\n                mix(hash3D(p+vec3(0.0, winy, 0.0)), hash3D(p+vec3(winx, winy, 0.0)), f.x),\n                f.y),\n        \tmix(\n                mix(hash3D(p+vec3(0.0, 0.0, winz)), hash3D(p+vec3(winx, 0.0, winz)), f.x),\n                mix(hash3D(p+vec3(0.0, winy, winz)), hash3D(p+vec3(winx, winy, winz)), f.x),\n                f.y),\n   \t\t\tf.z);\n}\n\n// Simplex 2D noise\n// sources: Ian McEwan - https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\n// sources: Patricio Gonzalez Vivo - https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\nfloat snoise(vec2 v){\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n                        -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n                     + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n                            dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n/**\n * This one is inspired by IQ code from this website.\n **/\nfloat fbm2D(vec2 p) {\n    float total = 0.0;\n    total  = 0.5000* snoise(p); p = p*2.0;\n    total += 0.2500* snoise(p); p = p*2.0;\n    total += 0.1250* snoise(p); p = p*2.0;\n    total += 0.0625* snoise(p); p = p*2.0;\n    return total;\n}\n\n/**\n * This one is inspired by IQ code from this website.\n **/\nfloat fbm2DT(vec2 p, float t) {\n    float total = 0.0;\n    total  = 0.5000* snoise(p); p = p*2.0;\n    total += 0.2500* snoise(p); p = p*2.0;\n    total += 0.1250* snoise(p); p = p*2.0;\n    total += 0.0625* snoise(p); p = p*2.0;\n    return min(1.0, total+t);\n}\n\nfloat fbm3D(vec3 p) {\n    float total = 0.0;\n    total  = 0.5000* noise3D(p); p = p*2.0;\n    total += 0.2500* noise3D(p); p = p*2.0;\n    total += 0.1250* noise3D(p); p = p*2.0;\n    total += 0.0625* noise3D(p); p = p*2.0;\n    return total;\n}\n\nfloat fbm3DT(vec3 p, float t) {\n    float total = 0.0;\n    total  = 0.5000* noise3D(p); p = p*2.0;\n    total += 0.2500* noise3D(p); p = p*2.0;\n    total += 0.1250* noise3D(p); p = p*2.0;\n    total += 0.0625* noise3D(p); p = p*2.0;\n    return min(1.0, total+t);\n}\n\nfloat voronoi2D(vec2 uv) {\n    vec2 fl = floor(uv);\n    vec2 fr = fract(uv);\n    float res = 1.0;\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec2 p = vec2(i, j);\n            float h = hash2D(fl+p);\n            vec2 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nfloat voronoi3D(vec3 uv) {\n    vec3 fl = floor(uv);\n    vec3 fr = fract(uv);\n    float res = 1.0;\n    for(int k=-1;k<=1;k++)\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec3 p = vec3(i, j, k);\n            float h = hash3D(fl+p);\n            vec3 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nfloat waterNoise(vec2 x) {\n    vec2 p = floor(x);\n    vec2 n = fract(x);\n    vec2 f = n*n*(3.0-2.0*n);\n    float winx = 1.0;\n    float winy = 1.0;\n    \n    return mix(\n                mix(hash2D(p)     , hash2D(p+vec2(winx, 0.0)), f.x),\n                mix(hash2D(p+vec2(0.0, winy)), hash2D(p+vec2(winx, winy)), f.x),\n                f.y);\n}\n\nvec3 greyscale(vec3 color)\n{\n \treturn vec3(dot(color, vec3(1.0)))*0.33;   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 depth = texture(iChannel0, uv);\n\n    vec3 color = vec3(0.0);\n    if(depth.w>0.0)\n       {\n    float voro = voronoi3D(depth.xyz*4.0);\n    float timeDying = clamp(iTime/DYING_IN_SECONDS, 0.0, 1.0);\n    float Time = iTime*0.04*(1.0-timeDying);\n    vec3 bloodColor = vec3(0.6, 0.3, 0.3);\n    vec3 darkBloodColor = vec3(0.3, 0.1, 0.1);\n    bloodColor = mix(darkBloodColor, bloodColor, fbm3D(depth.xyz*2.0-Time));\n    bloodColor += mix(darkBloodColor, bloodColor, fbm3D(depth.xyz*2.0+Time));\n    color = bloodColor;\n    vec3 dyingColor = greyscale(color);\n    float fDying = clamp(fbm3DT(depth.xyz*4.0,timeDying)*2.0*timeDying, 0.0, 1.0);\n    color = clamp(mix(color, dyingColor,  fDying), 0.0, 1.0);\n    //color = vec3(fDying);\n       }\n\tfragColor = vec4(color,1.0);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n\n/********************\n * NOISES\n ********************/\n\nfloat hash2D(vec2 x) {\n\treturn fract(sin(dot(x, vec2(13.454, 7.405)))*12.3043);\n}\n\nfloat hash3D(vec3 x) {\n\treturn fract(dot(x, vec3(12.4955, 49.4294, 42.40594))*13.4959451);    \n}\n\n// Simplex 2D noise\n// sources: Ian McEwan - https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\n// sources: Patricio Gonzalez Vivo - https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\nfloat snoise(vec2 v){\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n                        -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n                     + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n                            dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n/**\n * This one is inspired by IQ code from this website.\n **/\nfloat fbm2D(vec2 p) {\n    float total = 0.0;\n    total  = 0.5000* snoise(p); p = p*2.0;\n    total += 0.2500* snoise(p); p = p*2.0;\n    total += 0.1250* snoise(p); p = p*2.0;\n    total += 0.0625* snoise(p); p = p*2.0;\n    return total;\n}\n\nfloat voronoi2D(vec2 uv) {\n    vec2 fl = floor(uv);\n    vec2 fr = fract(uv);\n    float res = 1.0;\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec2 p = vec2(i, j);\n            float h = hash2D(fl+p);\n            vec2 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nfloat voronoi3D(vec3 uv) {\n    vec3 fl = floor(uv);\n    vec3 fr = fract(uv);\n    float res = 1.0;\n    for(int k=-1;k<=1;k++)\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec3 p = vec3(i, j, k);\n            float h = hash3D(fl+p);\n            vec3 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\n\nfloat waterNoise(vec2 x) {\n    vec2 p = floor(x);\n    vec2 n = fract(x);\n    vec2 f = n*n*(3.0-2.0*n);\n    float winx = 1.0;\n    float winy = 1.0;\n    \n    return mix(\n                mix(hash2D(p)     , hash2D(p+vec2(winx, 0.0)), f.x),\n                mix(hash2D(p+vec2(0.0, winy)), hash2D(p+vec2(winx, winy)), f.x),\n                f.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 depth = texture(iChannel0, uv);\n    vec3 color = vec3(0.0);\n    if(depth.w>0.0)\n    {\n        float voro = voronoi3D(depth.xyz*4.0);\n        float veins = clamp(pow(voro, 4.0), 0.0, 1.0);\n        vec3 veinsColor = vec3(0.55, 0.35, 0.0);\n        color = veinsColor*veins;\n        fragColor = vec4(color, veins);\n    }\n}","name":"Buf C","description":"","type":"buffer"}]}