{"ver":"0.1","info":{"id":"clKBWK","date":"1702494948","viewed":86,"name":"Alien Auditory Nerve","username":"MV10","description":"Turns out this is highly audio-reactive with no changes. Even more visible with a second texture (lines 20, 21) -- I changed nothing else. Looks super-fantastic at 4K! Track is Hypnotic by Zen DNA. (On Chrome/Edge you have to pause/play the music? Sad...)","likes":5,"published":1,"flags":64,"usePreview":1,"tags":["raymarching","sphere","abstract","wtf","dirtycode"],"hasliked":0,"parentid":"4tcXRr","parentname":"Alien Core"},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsd3Rf","filepath":"https://soundcloud.com/creasol-music/hypnotic-art-was-art-vocal","previewfilepath":"https://soundcloud.com/creasol-music/hypnotic-art-was-art-vocal","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// GLKITTY 2016.\n\nvec3 rotateY(vec3 v, float t){\n    float cost = cos(t); float sint = sin(t);\n    return vec3(v.x * cost + v.z * sint, v.y, -v.x * sint + v.z * cost);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat noise(vec3 p){\n    \n    float t = iTime;\n    vec3 np = normalize(p);\n    \n    // kind of bi-planar mapping\n    float a = texture(iChannel0,t/20.+np.xy).x + texture(iChannel1,t/20.+np.xy).y;\n    float b = texture(iChannel0,t/20.+.77+np.yz).x + texture(iChannel1,t/20.+.77+np.yz).y;\n    \n    a = mix(a,.5,abs(np.x));\n    b = mix(b,.5,abs(np.z));\n    \n    float noise = a+b-.4;    \n    noise = mix(noise,.5,abs(np.y)/2.);\n        \n    return noise;\n}\n\nfloat map(vec3 p){\n    \n    // spheres\n    float d = (-1.*length(p)+3.)+1.5*noise(p);    \n    d = min(d, (length(p)-1.5)+1.5*noise(p) );  \n    \n    // links\n    float m = 1.5; float s = .03;    \n    d = smin(d, max( abs(p.x)-s, abs(p.y+p.z*.2)-.07 ) , m);          \n    d = smin(d, max( abs(p.z)-s, abs(p.x+p.y/2.)-.07 ), m );    \n    d = smin(d, max( abs(p.z-p.y*.4)-s, abs(p.x-p.y*.2)-.07 ), m );    \n    d = smin(d, max( abs(p.z*.2-p.y)-s, abs(p.x+p.z)-.07 ), m );    \n    d = smin(d, max( abs(p.z*-.2+p.y)-s, abs(-p.x+p.z)-.07 ), m );\n    \n    return d;\n}\n\nfloat color( vec3 p){\n   return 0.; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Ray from UV\n\tvec2 uv = fragCoord.xy * 2.0 / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ray = normalize(vec3(1.*uv.x,1.*uv.y,1.));\n    \n    // Color    \n    vec3 color = vec3(0);    \n    const int rayCount = 1024;\n    \n    // Raymarching\n    float t = 0.;\n    for (int r = 1; r <= rayCount; r++)\n    {\n        // Ray Position\n        vec3 p = vec3(0,0,-3.) + ray * t;        \n        \n        // Rotation \n       \tp = rotateY(p, iMouse.x/iResolution.x * 2.* 3.14);  \n        p = rotateY(p,iTime/3.);\n        \n        // Deformation \n    \tfloat mask = max(0.,(1.-length(p/3.)));\n    \tp = rotateY(p,mask*sin(iTime/2.)*1.2);        \n        p.y += sin(iTime+p.x)*mask*.5;\n        p *= 1.1+(sin(iTime/2.)*mask*.3);\n\n        // distance\n        float d =  map(p);   \n        \n        //color\n        if(d<0.01 || r == rayCount )\n        {                 \n            \n            float iter = float(r) / float(rayCount);\n            float ao = (1.-iter);\n            ao*=ao;\n            ao = 1.-ao;\n                        \n            float mask = max(0.,(1.-length(p/2.)));            \n            mask *= abs(sin(iTime*-1.5+length(p)+p.x)-.2);            \n            color += 2.*vec3(.1,1.,.8) * max(0.,(noise(p)*4.-2.6)) * mask;            \n            color += vec3(.1,.5,.6) * ao * 6.;            \n            color += vec3(.27,.2,.4)*(t/8.);\n                       \n            color *= 2.;\n            color -= .15;\n                        \n            break;          \n        }\n        \n        // march along ray\n        t +=  d *.5;        \n    }\n    \n    // vignetting effect by Ippokratis\n    // https://www.shadertoy.com/view/lsKSWR\n    uv = fragCoord.xy / iResolution.xy;\n    uv *=  1.0 - uv.yx; \n    float vig = uv.x*uv.y * 20.0;    \n    vig = pow(vig, 0.25);        \n    color *= vig;\n    \n    //color adjustement\n    color.y *= .8;\n    color.x *= 1.5;\n    \n\tfragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}