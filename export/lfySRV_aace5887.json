{"ver":"0.1","info":{"id":"lfySRV","date":"1715440095","viewed":45,"name":"Ray Marching Beginner","username":"CheerWizard","description":"First try on Ray Marching.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define USE_GAMMA_CORRECTION 1\n\nstruct Camera {\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Sphere {\n    vec3 pos;\n    float radius;\n};\n\nconst vec4 backgroundColor = vec4(0, 0, 0, 1);\n\n#define MAX_STEPS 100\n#define MAX_DISTANCE 100.0\n#define SURFACE_DISTANCE 0.1\n\nfloat getDist(vec3 p) {\n    Sphere sphere;\n    sphere.pos = vec3(0, 1, 6);\n    sphere.radius = 1.0;\n    float planeY = 0.0;\n    float dS = length(sphere.pos - p) - sphere.radius;\n    float dP = p.y - planeY;\n    float d = min(dS, dP);\n    return d;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float d0 = 0.0;\n    for (int i = 0 ; i < MAX_STEPS ; i++) {\n        vec3 p = ro + rd * d0;\n        float dS = getDist(p);\n        d0 += dS;\n        if (d0 > MAX_DISTANCE || d0 < SURFACE_DISTANCE) {\n            break;\n        }\n    }\n    return d0;\n}\n\nvec3 getNormal(vec3 p)\n{\n    float d = getDist(p);\n    vec2 e = vec2(0.01, 0);\n    vec3 n = vec3(\n        d - getDist(p - vec3(0.01, 0, 0)),\n        d - getDist(p - vec3(0, 0.01, 0)),\n        d - getDist(p - vec3(0, 0, 0.01))\n    );\n    return normalize(n);\n}\n\nvec3 getDiffuseLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += 2.0 * vec2(sin(iTime), cos(iTime));\n    vec3 lightColor = vec3(1, 1, 1);\n    vec3 lightDir = normalize(lightPos - p);\n    vec3 normal = getNormal(p);\n    vec3 diffuse = clamp(dot(normal, lightDir), 0.0, 1.0) * lightColor;\n    float d = rayMarch(p + normal * SURFACE_DISTANCE * 2.0, lightDir);\n    if (d < length(lightPos - p)) {\n        diffuse *= 0.1;\n    }\n    return diffuse;\n}\n\nvec3 gamma_correction(vec3 color, float gamma) {\n    float g = 1.0 / gamma;\n    return vec3(pow(color.r, g), pow(color.g, g), pow(color.b, g));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    Camera camera;\n    camera.pos = vec3(0, 1, 0);\n    camera.dir = vec3(uv.x, uv.y, 1);\n    camera.dir = normalize(camera.dir);\n    \n    float d = rayMarch(camera.pos, camera.dir);\n\n    vec3 p = camera.pos + camera.dir * d;\n    \n    vec3 diffuse = getDiffuseLight(p);\n\n    #if(USE_GAMMA_CORRECTION)\n        vec3 color = gamma_correction(diffuse, 2.2);\n    #else\n        vec3 color = diffuse;\n    #endif\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}