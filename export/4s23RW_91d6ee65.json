{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"cubemap","id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Written by Anton Davidenko aka Dave for shadertoy.com\n// TODO: refraction\n\nconst float c_fMatGround = 1.0;\nconst float c_fMatGlass = 2.0;\nconst int c_iGlassWidth = 8;\nconst int c_iGlassHeight = 6;\nconst float c_fGlassWidth = 8.0;\nconst float c_fGlassHeight = 6.0;\n\n\nfloat g_fGlassCrashTime;\nfloat g_fSceneTime;\n\n\nvec2 rand( vec2 v )\n{\n//\treturn texture( iChannel0, v * 0.1 ).xy;\n    vec2 r;\n    r.x = fract( sin( v.x ) * 43758.5453 );\n    r.y = fract( sin( v.y ) * 1234.5678 );\n    return r;\n}\n\nvec2 pointInCell( ivec2 ic )\n{\n\tvec2 result = vec2( ic );\n\tvec2 vCenter = vec2( c_fGlassWidth, c_fGlassHeight ) * 0.5;\n\tvec2 vRand = rand( result ) * 0.8 + 0.1;\n\tvec2 vd = vec2( ic ) + vec2( 0.5 ) - vCenter;\n\tfloat rMax = min( c_fGlassWidth, c_fGlassHeight ) / 2.0;\n\tfloat r = length( vd );\n\tfloat d = min( r / rMax, 1.0 );\n\tfloat fScale = pow( d, 4.0 );\n\tresult = vCenter + ( vd + vRand ) * fScale;\n\t\n\treturn result;\n}\n\nvec3 moveOverTime( ivec2 c )\n{\n\tc -= ivec2( c_iGlassWidth / 2, c_iGlassHeight / 2 );\n\tvec3 acc = vec3( 0, -5, 0 );\n\tfloat velZ = max( 5.0 - length( vec2( c ) ), 0.0 );\n\tvelZ = pow( velZ, 3.0 );\n\tvec3 vel = vec3( 0, 0, -velZ );\n\treturn acc * g_fGlassCrashTime * g_fGlassCrashTime * 0.5 + vel * g_fGlassCrashTime;\n\treturn vec3( 0, g_fGlassCrashTime * -1.0, 0 );\n}\n\nmat3 matAxisAngle( vec3 axis, float a )\n{\n\tfloat s = sin( a );\n\tfloat c = cos( a );\n\tvec3 as = axis * axis;\n\n\tmat3 m;\n\tm[0][0] = as.x + (1.0 - as.x) * c;\n\tm[0][1] = axis.x * axis.y * (1.0 - c) + axis.z * s;\n\tm[0][2] = axis.z * axis.x * (1.0 - c) - axis.y * s;\n\n\tm[1][0] = axis.x * axis.y * (1.0 - c) - axis.z * s;\n\tm[1][1] = as.y + (1.0 - as.y) * c;\n\tm[1][2] = axis.y * axis.z * (1.0 - c) + axis.x * s;\n\n\tm[2][0] = axis.z * axis.x * (1.0 - c) + axis.y * s;\n\tm[2][1] = axis.y * axis.z * (1.0 - c) - axis.x * s;\n\tm[2][2] = as.z + (1.0 - as.z) * c;\n\n\treturn m;\n}\n\nmat3 rotationOverTime( ivec2 c )\n{\n\tvec2 co = vec2( c - ivec2( c_iGlassWidth / 2, c_iGlassHeight / 2 ) );\n\tco += vec2( 0.5, 0.5 );\n\tvec3 axis = vec3( co.y, -co.x, 0 );\n\taxis = normalize( axis );\n\tfloat fSpeed = max( 4.0 - length( vec2( co ) ), 0.0 );\n\tfSpeed = pow( fSpeed, 5.0 );\n//\tfSpeed = 1.0;\n\treturn matAxisAngle( axis, fSpeed * g_fGlassCrashTime );\n}\n\nmat4 transformOverTime( ivec2 c )\n{\n\tvec3 pieceOrigin = vec3( pointInCell( c ), 0 );\n\tmat3 mr = rotationOverTime( c );\n\tmat4 res = mat4( mr );\n\tmat4 mt = mat4( 1.0 );\n\tmt[3].xyz = vec3( -pieceOrigin );\n\tres = mat4( mr ) * mt;\n\tmt[3].xyz = pieceOrigin;\n\tres = mt * res;\n\t\n\tmt[3].xyz = moveOverTime( c );\n\tres = mt * res;\n\treturn res;\n}\n\nfloat voronoi( vec2 pos, ivec2 ic )\n{\n\tfloat mind = 1e6;\n\tfor( int i = -1; i <= 1; i++ )\n\t{\n\t\tfor( int j = -1; j <= 1; j++ )\n\t\t{\n\t\t\tvec2 pc = pointInCell( ic + ivec2( i, j ) );\n\t\t\tvec2 vd = ( pc - pos );\n\t\t\tfloat d = dot( vd, vd );\n\t\t\tmind = min( d, mind );\n\t\t}\n\t}\n\treturn sqrt( mind );\n}\n\nvoid piecePlane( ivec2 c, out vec4 pl, out vec3 center, out vec3 px, out vec3 py )\n{\n\tmat4 m = transformOverTime( c );\n\tvec3 pz = m[2].xyz;\n\tpx = m[0].xyz;\n\tpy = m[1].xyz;\n\tpl = vec4( pz, -dot( pz, m[3].xyz ) );\n\tcenter =  m[3].xyz;\n}\n\nbool rayHitPiece( vec3 vo, vec3 vd, ivec2 c, out float dist, out vec3 norm )\n{\n\tvec4 plane;\n\tvec3 center, px, py;\n\tpiecePlane( c, plane, center, px, py );\n\n\tfloat d = dot( vd, plane.xyz );\n\tif ( abs( d ) < 0.0001 ) return false;\n\tdist = ( - plane.w - dot( vo, plane.xyz ) ) / d;\n\tif ( dist < 0.001 ) return false;\n\n\tvec3 p = vo + dist * vd;\n\tvec2 vg = vec2( dot( p - center, px ), dot( p - center, py ) );\n\tif ( vg.x < 0.0 || vg.x > c_fGlassWidth || vg.y < 0.0 || vg.y > c_fGlassHeight ) return false;\n\tfloat fvn = voronoi( vg, c );\n\tvec2 vc = pointInCell( c ); // cell center\n\tfloat fDistToCenter = length( vc - vg );\n\tfloat fd = fDistToCenter - fvn;\n\tnorm = plane.xyz;\n\treturn abs( fd ) < 0.001;\n}\n\nbool rayHitSphere( in vec3 ro, in vec3 rd, vec3 spC, float spR, out float dist, out vec3 norm )\n{\n\tvec3 oc = ro - spC;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - spR * spR;\n\tfloat h = b*b - c;\n\tif( h < 0.0 ) return false;\n\tdist = -b - sqrt( h );\n\tif ( dist < 0.0 ) return false;\n\tnorm = normalize( ro + rd * dist - spC );\n\treturn true;\n}\n\nbool rayTrace( vec3 vo, vec3 vd, out vec3 color )\n{\n\tbool bResult = false;\n\tcolor = vec3( 0.0 );\n\t\n\tfloat dglass = 1e6;\n\tvec3 normGlass;\n\tvec3 clBG = texture( iChannel1, vd ).rgb;\n\tcolor = clBG;\n\tvec3 clGlassRefl;\n\n\tvec3 clGlass;\n\tfor( int cy = -1; cy < c_iGlassHeight; cy++ )\n\t\tfor( int cx = -1; cx < c_iGlassWidth; cx++ )\n\t\t{\n\t\t\tfloat d;\n\t\t\tif ( rayHitPiece( vo, vd, ivec2( cx, cy ), d, normGlass ) )\n\t\t\t{\n\t\t\t\tif ( d < dglass )\n\t\t\t\t{\n\t\t\t\t\tdglass = d;\n\t\t\t\t\tbResult = true;\n\t\t\t\t\tclGlassRefl = texture( iChannel1, reflect( vd, normGlass ) ).xyz;\n\t\t\t\t\tclGlass = mix( clBG, clGlassRefl, 0.4 );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tconst float fBulletSpeed = 100.0;\n\tvec3 vBulletPos = vec3( c_fGlassWidth * 0.5, c_fGlassHeight * 0.5, -g_fSceneTime * fBulletSpeed );\n\tconst float fBulletRadius = 0.2;\n\tvec3 norm;\n\tfloat d;\n\tif ( rayHitSphere( vo, vd, vBulletPos, fBulletRadius, d, norm ) )\n\t{\n\t\tbResult = true;\n\t\tvec3 crefl = texture( iChannel1, reflect( vd, norm ) ).xyz;\n\t\tcolor = mix( vec3( 0.8, 0.8, 0.4 ), crefl, 0.7 );\n\t\tif ( d > dglass )\n\t\t{\n\t\t\tcolor = mix( color, clGlass, 0.4 );\n\t\t}\n\t}\n\telse if ( bResult )\n\t\tcolor = clGlass;\n\t\n\treturn bResult;\n}\n\nvec3 render( vec3 vo, vec3 vd )\n{\n\tvec3 result = vec3( 0.0 );\n\trayTrace( vo, vd, result );\n\n\treturn result;\n}\n\nfloat spline( float t, float x1, float dx1, float x2, float dx2 )\n{\n\tfloat a = 2.0 * x1 - 2.0 * x2 + dx1 + dx2;\n\tfloat b = -3.0 * x1 + 3.0 * x2 - 2.0 * dx1 - dx2;\n\tfloat c = dx1;\n\tfloat d = x1;\n\tfloat t2 = t * t;\n\tfloat t3 = t2 * t;\n\treturn a * t3 + b * t2 + c * t + d;\n}\n\nfloat spline( float x, float x1, float x2, float y1, float dy1, float y2, float dy2 )\n{\n\tfloat t = ( x - x1 ) / ( x2 - x1 );\n\treturn spline( t, y1, dy1, y2, dy2 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n\tfloat fEpisodeTime = 10.0;\n\tfloat fGlobalTime = mod( iTime, fEpisodeTime );\n\tfloat cycle = floor( iTime / fEpisodeTime );\n\tfloat firstCycle = iTime < fEpisodeTime ? 1.0 : 0.0;\n\t\n\tconst float Pi = 3.14159;\n\tfloat fRandAngle = texture( iChannel0, vec2( cycle * 0.123, cycle * 0.456 ) ).r * ( Pi * 2.0 );\n\tfloat fHitTimeAngle = ( -Pi / 4.0 ) * firstCycle + ( 1.0 - firstCycle ) * fRandAngle;\n\tconst float fOrbitSpeed = 0.5;\n\n\tg_fSceneTime = fGlobalTime - 4.5;\n\tconst float fSlomoMin = -0.1;\n\tconst float fSlomoMax = 0.15;\n\tconst float fSlomoK = 0.1;\n\tconst float fSlomoPeriod = ( fSlomoMax - fSlomoMin ) / fSlomoK;\n\tif ( g_fSceneTime >= fSlomoMin && g_fSceneTime < fSlomoMin + fSlomoPeriod )\n\t\tg_fSceneTime = spline( g_fSceneTime, fSlomoMin, fSlomoMin + fSlomoPeriod, fSlomoMin, fSlomoPeriod * 0.2, fSlomoMax, fSlomoPeriod * 0.2 );\n\telse if ( g_fSceneTime >= fSlomoMin + fSlomoPeriod )\n\t\tg_fSceneTime = g_fSceneTime - fSlomoPeriod + ( fSlomoMax - fSlomoMin );\n\n\tg_fGlassCrashTime = step( 0.0, g_fSceneTime ) * g_fSceneTime;\n\n\tvec3 vTarget = vec3( c_fGlassWidth * 0.5, c_fGlassHeight * 0.5, 0 );\n\t\n\tvec3 vCamPos = vec3( -2, c_fGlassHeight * 0.5, -10 );\n\tfloat r = 10.0;\n\tfloat fAngle = fHitTimeAngle + g_fSceneTime * fOrbitSpeed;\n\tvCamPos = vec3( c_fGlassWidth * 0.5 + r * sin( fAngle ), c_fGlassHeight * 0.5, -r * cos( fAngle ) );\n\tvec3 vCamDir = normalize( vTarget - vCamPos );\n\tvec3 vCamUp = vec3( 0, 1, 0 );\n\tvec3 vCamRight = normalize( cross( vCamDir, vCamUp ) );\n\n\tvec3 vd = normalize( vCamDir * 2.0 + vCamRight * p.x + vCamUp * p.y );\n\tvec3 col = render( vCamPos, vd );\n\t\n\tfloat fFade = fGlobalTime > fEpisodeTime - 1.0 ? fEpisodeTime - fGlobalTime : 1.0;\n\tfFade *= fGlobalTime < 1.0 && firstCycle == 0.0 ? fGlobalTime : 1.0;\n\t\n\tfragColor = vec4( col * fFade, 1 );\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4s23RW","date":"1386609335","viewed":1431,"name":"Glass crash","username":"Dave","description":"Used voronoi to break geometry","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","voronoi","glass","physics","slomo"],"hasliked":0,"parentid":"","parentname":""}}