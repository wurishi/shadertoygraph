{"ver":"0.1","info":{"id":"lfcBR7","date":"1732835449","viewed":22,"name":"Nothing compares to PI","username":"kallaballa","description":"A  visualization of how much a cheap approximation for PI (Machin's Formula) differs from the Leibnitz series.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["pi","approximation","machinsformula","leibnitzseries"],"hasliked":0,"parentid":"4fKyWd","parentname":"Sometimes PI is not a constant"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Â© shadertoys@viel-zu.org \n// License: AGPL\n\n//Parameters to play around.\nconst int maxSteps = 50;\nconst int maxPISeries = 50;\nconst float scale = 300.;\n    \nfloat map( in vec3 pos ) {\n   return length(pos - vec3(-100., -100., 0.));\n}\n\nvec3 calcNormal(vec3 p )\n{\n    const float h = 0.0001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n                      k.yyx*map( p + k.yyx*h ) + \n                      k.yxy*map( p + k.yxy*h ) + \n                      k.xxx*map( p + k.xxx*h ) );\n}\n\nfloat computePI(int iterations) {\n    float pi = 0.0;\n    for (int i = 0; i < iterations; i++) {\n        float term = (i % 2 == 0 ? 1.0 : -1.0) / (2.0 * float(i) + 1.0);\n        pi += term;\n    }\n    return pi * 4.0;\n}\n\nfloat approximatePI() {\n    return 4.0 * (4.0 * atan(1.0 / 5.0) - atan(1.0 / 239.0));\n}\n\nfloat findRatio(int iterations) {\n    float ratio = 0.;\n    float targetPI = computePI(iterations);\n    float approxPI = approximatePI();\n    float error;\n\n    for (int i = 0; i < maxSteps; ++i) {\n        error = approxPI * ratio - targetPI;\n\n        if (abs(error) < 0.0000001) break;\n        ratio -= error * 0.0001;\n    }\n\n    return ratio;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = 2. * fragCoord/iResolution.xy - 1.;\n    vec2 p = uv * 0.5 + 0.5;\n    if(length(uv) > 0.68) {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    float ratio = findRatio(int(round((uv.x * iResolution.x + uv.y) * float(maxPISeries))));\n    \n    vec3 col = vec3(1.0, 0, .0); \n    vec3 pos = vec3((p * 2.0 - 1.0) * scale * 10., ratio * scale);\n    \n    vec3 nor = calcNormal(pos);\n    \n    float dif = dot(nor,vec3(.5));\n    float amb = 0.5 + 0.5 * dot(nor,vec3(sin(iTime), cos(iTime), 0.0));\n    col = normalize(0.01 + col * dif * amb) * 2.0;\n\n    fragColor = 1.0 - vec4(vec3(col), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}