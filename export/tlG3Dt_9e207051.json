{"ver":"0.1","info":{"id":"tlG3Dt","date":"1624507541","viewed":89,"name":"simple-blackhole","username":"feefi","description":"black hole simulation","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","blackhole"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":" float torus_sdf( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sphere_sdf(vec3 pos,float r)\n{\n    return length(pos) - r;\n}\nfloat blackhole(vec3 pos)\n{\n    //return sdBox(pos-center,vec3(10.3,10.3,10.3));\n    return sphere_sdf(pos,10.328);\n}\n\nconst int N = 420;\nconst float esp = 0.01;\nconst float Pi = 3.1415926;\nvec3 ray_marching(vec3 pos,vec3 dir)\n{\n    vec3 hitpos = pos;\n    float dt=0.404;\n    float hitbh = .0;\n    float hittor = .0;\n    vec3 speed = dir;\n    vec3 torCol = vec3(0.0);\n    vec3 center = vec3(0.0,0.0,100)+50.*vec3(sin(0.*iTime),sin(.5*iTime),0);\n    for(int i = 0;i<N;++i)\n    {\n        //s = v * t; if hit then break\n        hitpos += speed * dt * (1.0 - hitbh);\n        //blackhole, dectect if photon captured by blackhole\n        float d = blackhole(hitpos-center);\n        hitbh = max(hitbh, step(d,0.01));\n        \n        //disk\n                //rot \n        float rotangle = Pi/2.0 + Pi/24.0;\n        mat3 torRot = mat3(\n            vec3(sin(rotangle),cos(rotangle),0),\n            vec3(-cos(rotangle),sin(rotangle),0),\n            vec3(0,0,1)\n        );\n        vec3 torpos = torRot*hitpos;\n        float tor = torus_sdf((torpos-center)*vec3(1.0,25.,1.0),vec2(45.0,25.5));\n        hittor = max(hittor,step(tor,0.01));\n        torCol =  vec3(1.0)*hittor ;\n        \n       \n        //photon move forward \n        vec3 b = center-hitpos;\n        float G = (6.0+0.*sin(iTime*1.0));\n        //F = G*(M*m/R^2); a = F/m\n        float a = G/dot(b,b);\n        //v = v0+at;\n        speed += a * normalize(b);\n        \n\n    }\n    \n    vec3 bg = fract(hitpos/55.0) * (1.0-hitbh);\n    vec3 col = torCol  + bg;\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.y = iResolution.y/iResolution.x*st.y;\n    st = st * 2.0 - 1.0;  \n    st.y += 0.4;\n    vec3 color = ray_marching(vec3(0.,0.,-1.0), normalize(vec3(st,1.0)));\n    fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}