{"ver":"0.1","info":{"id":"MsfcD7","date":"1488453138","viewed":392,"name":"Ret_2.","username":"calx","description":"Distance Field Reticle. Similar to the other thing I did, just with 100 instructions rather than 1000.\nClick to change the seed, generate a new Reticle.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["procedural","distancefield","reticle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TWO_PI  6.28318530718\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2\tuv          = 2.0 * vec2(fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n   \tint     num        \t= 10;\n    float   h_smooth    = 0.0025;\n    float   dist        = length(uv);\n    float  \tdi          = floor(dist * float(num));\n    float   df          = di / float(num);\n    float   seed        = floor(iMouse.x) + 12.0;\n    float   gen         = fract(sin(df)*seed);\n    float   sd          = abs(sin(di));\n    float   sp          = sin(di);\n    float   ro          = gen * TWO_PI;\n    float   th          = ro + ((sp) * iTime); \n    vec2  \tq           = vec2(cos(th)*uv.x + sin(th)*uv.y, -sin(th)*uv.x + cos(th)*uv.y);\n    float   a           = atan(q.x, q.y) * (gen * 5.0);\n    float   act      \t= mod(di, 2.0);\n    float   fs          = 0.1;\n    float   strk        = (gen * fs + 0.005);\n    float   crve        = (strk * 0.25) * (1.0-act);\n    float   sect        = ((4.000 * gen) * act);\n    float   sw          = (0.040 * act) * gen;\n    float   success     = step(gen, sd);\n    float   angle       = (a < 0.0) ? (a + TWO_PI) / TWO_PI : a / TWO_PI;\n    float   ring        = step(sw * (1.0+df*-1.0), fract(angle * sect));\n    float   inner       = smoothstep(df-h_smooth, df+h_smooth,  dist);\n    float   inSlope     = 0.25 * gen;\n    float   outSope     = 0.75 * gen;\n    float   oDist       = dist + smoothstep(inSlope, inSlope + 0.008, angle) * (1.0 - smoothstep(outSope, outSope+0.008, angle)) * crve;  \n    float   outer       = 1.0 -  smoothstep((df + strk - 0.001)-h_smooth, (df + strk - 0.001)+h_smooth, oDist);\n    float   solid       = 1.0 - (strk / fs) ;\n    float   outline     = step(dist, 1.0) * 1.0-step(dist, 0.05);\n    float   final       = inner * outer * ring * outline * solid * success;\n\n    fragColor = vec4 (final*(0.392), final*(0.627+(gen*0.176)), final*(0.392+(df*0.607)), 1.0) * 1.6;\n}","name":"Image","description":"","type":"image"}]}