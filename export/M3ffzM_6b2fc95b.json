{"ver":"0.1","info":{"id":"M3ffzM","date":"1728163633","viewed":48,"name":"Joanna's Ray Marching Demo","username":"joannashader","description":"3D Ray marching demonstration with lights and soft shadows.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Tutorials & reference shaders used:\n//   Ray marching: https://www.youtube.com/watch?v=khblXafu7iA\n//   SDFs: https://iquilezles.org/articles/distfunctions/\n//   Diffuse Light: https://www.shadertoy.com/view/NlfGDs\n//   Shadow Mapping: https://iquilezles.org/articles/rmshadows/\n//   Soft shadow anti-banding: https://www.dropbox.com/s/s9tzmyj0wqkymmz/Claybook_Simulation_Raytracing_GDC18.pptx\n\n// Constants\nconst float min_distance = .001;\nconst float max_distance = 100.;\nconst float pi = 3.14159;\nconst int ray_march_iterations = 256;\n\n// all sdfs assume shape centered at origin\nfloat sd_torus(vec3 ray_position, vec2 torus) {\n    vec2 q = vec2(length(ray_position.xz) - torus.x, ray_position.y);\n    return length(q) - torus.y;\n}\n\nfloat sd_sphere(vec3 ray_position, float sphere_radius) {\n    return length(ray_position) - sphere_radius;\n}\n\nfloat sd_plane(vec3 ray_position, vec3 plane_normal) {\n    return dot(ray_position, plane_normal);\n}\n\n// rotation matrices\nmat3 rotateX(float angle) {\n    return mat3(\n        1, 0, 0,\n        0, cos(angle), -sin(angle),\n        0, sin(angle), cos(angle)\n    );\n}\n\nmat3 rotateY(float angle) {\n    return mat3(\n        cos(angle), 0, sin(angle),\n        0, 1, 0,\n        -sin(angle), 0, cos(angle)\n    );\n}\n\nmat3 rotateZ(float angle) {\n    return mat3(\n        cos(angle), -sin(angle), 0,\n        sin(angle), cos(angle), 0,\n        0, 0, 1\n    );\n}\n\nfloat scene_closest_distance(vec3 ray_position) {\n    vec3 torus_position = vec3(-2, 0, 4);\n    vec2 torus_parameters = vec2(1., 0.25);\n    vec3 ray_torus_space = rotateZ(mod(iTime, 2. * pi)) * rotateX(-pi / 4.) * (ray_position - torus_position);\n    float torus_distance = sd_torus(ray_torus_space, torus_parameters);\n    \n    vec3 sphere_position = vec3(2, 0, 4);\n    float sphere_radius = 1.0;\n    float sphere_distance = sd_sphere(ray_position - sphere_position, sphere_radius);\n    \n    vec3 plane_normal = vec3(0, 1, 0);\n    vec3 plane_position = vec3(0, -2, 0);\n    vec3 ray_plane_space = ray_position - plane_position;\n    float plane_distance = sd_plane(ray_plane_space, plane_normal);\n    \n    return min(torus_distance, min(sphere_distance, plane_distance));\n}\n\n// To get the surface normal we test the distances of 3 slightly offset points\n// one along each axis. The offset of these distances from the original hit\n// gives us the direction of the surface normal.\nvec3 get_normal(vec3 ray_hit) {\n    float distance = scene_closest_distance(ray_hit);\n    vec2 epsilon = vec2(0.01, 0.0);\n    vec3 offset_distances = vec3(\n        scene_closest_distance(ray_hit - epsilon.xyy),\n        scene_closest_distance(ray_hit - epsilon.yxy),\n        scene_closest_distance(ray_hit - epsilon.yyx)\n    );\n    return normalize(distance - offset_distances);\n}\n\nfloat get_light(vec3 light_position, vec3 ray_hit) {\n    vec3 light_direction = normalize(light_position - ray_hit);\n    vec3 normal = get_normal(ray_hit);\n    return clamp(dot(light_direction, normal), 0., 1.);\n}\n\nfloat shadow(vec3 light_position, vec3 hit_position)\n{\n    float shadow_factor = 1.0;\n    const float shadow_proportion = 8.;\n    vec3 light_direction = normalize(light_position - hit_position);\n    float ray_distance = min_distance;\n    float previous_closest_distance;\n    for(int i = 0; i < ray_march_iterations; i++)\n    {\n        vec3 ray_position = hit_position + light_direction * ray_distance;\n        float closest_distance = scene_closest_distance(ray_position);\n        if (closest_distance < min_distance*min_distance) {\n            return 0.0;\n        }\n        \n        // soften shadows where near misses occur\n        float y = i == 0 ? 0.0 : (closest_distance * closest_distance / (2.0 * previous_closest_distance));\n        float d = sqrt(closest_distance * closest_distance - y * y);\n        float w = 0.1;\n        shadow_factor = min(shadow_factor, d / (w * max(0.0, ray_distance - y)));\n        previous_closest_distance = closest_distance;\n        \n        ray_distance += closest_distance;\n        if (ray_distance > max_distance) {\n            break;\n        }\n    }\n    return shadow_factor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Correct aspect ratio and adjust coordinate space\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n\n    // Initialization\n    vec3 ray_origin = vec3(0, 0, 0);\n    vec3 ray_direction = normalize(vec3(uv, 1));\n    float ray_distance = 0.;\n    vec3 light_position = vec3(1.*8.*sin(iTime),5.,4.0);\n\n    // March our ray\n    vec3 ray_position;\n    for (int i = 0; i < ray_march_iterations; i++) {\n        ray_position = ray_origin + ray_direction * ray_distance;\n        \n        float closest_distance = scene_closest_distance(ray_position);\n        ray_distance += closest_distance;\n\n        if (closest_distance < min_distance) break; // Early stop if close enough\n        if (ray_distance > max_distance) break;     // Early stop if too far\n    }\n    \n    vec3 ray_hit = ray_position;\n    float ray_distance_from_light = distance(ray_hit, light_position);\n    float shadow_factor = shadow(light_position, ray_hit);\n    vec3 light_color = vec3(get_light(light_position, ray_hit) * shadow_factor);\n    fragColor = vec4(light_color, 1);\n}","name":"Image","description":"","type":"image"}]}