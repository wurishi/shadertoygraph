{"ver":"0.1","info":{"id":"7ssfRf","date":"1645176034","viewed":62,"name":"LIGHTTTTTT","username":"Gretsok","description":"LIGHTTTTTTINGGG","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shading : Romain Lopez-Rostain & Eric Galin\n\nconst float view = 5000.0;  // View distance\nconst float Epsilon = 0.01; // Marching epsilon\n\n// Iterations\nconst int Steps = 256;\n\nfloat Distance_to_sphere(in vec3 point, in vec3 center, in float radius)\n{\n    return length(center - point) - radius;\n}\n\n\n// Sphere tracing\n// ro, rd : Ray origin and direction\n// t : Intersection depth\n// i : Iteration count\nbool Intersect(in vec3 ro, in vec3 rd, out float t)\n{\n    t = 0.0;\n\tfor(int i=0; i<Steps; i++ )\n\t{\n        vec3 p = ro + t*rd;\n\t\tfloat h = min(\n            Distance_to_sphere(p, vec3(0., 0., 0.), 500.),\n            Distance_to_sphere(p, vec3(800., 800., 0.), 400.)\n        );\n        \n        // 1 cm precision at 1 meter range, reduce precision as we move forward\n\t\tif( abs(h)<(Epsilon*t)  ) return true;\n        if( t>view ) { return false; }\n\t\t// Empirical Lipschitz constant with level of detail (the further, the larger steps)\n        t += max(Epsilon,h*sqrt(1.0+8.0*t/view)/8.);\n\t}\n\n\treturn false;\n}\n\n// Rendering \n// ro, rd : Ray origin and direction\nvec4 Render( in vec3 ro, in vec3 rd)\n{\n    // Light direction\n    vec3 light1 = normalize( vec3(-0.8*cos(iTime),-0.3*sin(iTime),0.4) );\n    float light1_strength = 0.5;\n    vec3 light1_color = vec3(sin(2.* iTime), sin(01. * iTime), sin(0.7 * iTime));\n    \n\tvec3 col;\n    float t; // la longueur du rayon parcourue avant intersection\n    vec3 n;\n    \n    if (Intersect( ro, rd, t)) {\n        // Le point est ici\n        vec3 p = ro + rd * t;\n        \n        // Calculer la normale /!\\ normalisée /!\\\n        // Si on est plus proche de la première sphère :\n        if (Distance_to_sphere(p, vec3(0., 0., 0.), 500.) <\n            Distance_to_sphere(p, vec3(800., 800., 0.), 400.)\n        ) \n        {\n            vec3 dirFromCenter = p - vec3(0., 0., 0.);\n            n = vec3(dirFromCenter/ length(dirFromCenter));\n        }\n        else // On est plus proche de la seconde\n        {\n            vec3 dirFromCenter = p - vec3(800., 800., 0.);\n            n = vec3(dirFromCenter/ length(dirFromCenter));\n        }\n            \n        // Pseudo diffuse lighting\n        float dif = pow((1. + dot(light1, n)) / 2. ,2.); \n        col += dif * light1_strength * light1_color;\n        \n        // Brouillard de lointain (Distance modification)\n        float fog = exp(-pow(0.0005 * t, 1.5));\n        col += fog * vec3(0.4, 0.35, 0.35);\n        \n        // material color (ambient lighting)\n        col += vec3(0., 0.5, 0.5);\n    }\n    else\n        col = vec3(0., 0., 0.);\n    \n    return vec4(col, 1.);\n}\n\nmat3 moveCamera(float time, out vec3 ro)\n{\n\t// Origin\n    ro =  vec3(2000.0*cos(iMouse.x*0.01), 2000.0*sin(iMouse.x*0.01),1000.0) ;\n\t\n    // Target\n    vec3 ta = vec3(0.0 ,0.0, 0.0);\n    \n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, 0.0, 1.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec2 RayDirection(in vec2 pixel)\n{\n   // Pixel coordinates\n   return (-iResolution.xy + 2.0*pixel)/iResolution.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   // Time as function of the position of the mouse\n    float time = iTime*0.25 + 4.0*iMouse.x/iResolution.x;\n\n    // Camera transform\n    vec3 ro; \n    mat3 cam = moveCamera( time, ro);\n    \n    // Pixel coordinates\n    vec2 p = RayDirection(fragCoord);\n   \n    // Camera ray    \n    vec3 rd = cam * normalize(vec3(p,3.0));\n    \n    // Render\n    vec4 res = Render( ro, rd);\n     \n    fragColor = vec4( res.xyz, 0.0 );\n}","name":"Image","description":"","type":"image"}]}