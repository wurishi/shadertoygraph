{"ver":"0.1","info":{"id":"XtVyWG","date":"1537503586","viewed":147,"name":"Homestuck Aspect Time","username":"dahart","description":"Homestuck Aspect Time. scrub time using mouse.\nInspired by https://www.reddit.com/r/homestuck/comments/7ilwst/time_pixel_art/","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["2d","time","animation","pixelart","aspect","homestuck","aradiamegido","yokcos"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// https://www.reddit.com/r/homestuck/comments/7ilwst/time_pixel_art/ (found via https://www.reddit.com/user/yokcos700/posts?sort=top)\n// https://www.reddit.com/r/PixelArt/comments/7j0h0t/homestuck_aspects_oc/\n// http://mspaintadventures.wikia.com/wiki/Aspect\n// http://mspaintadventures.wikia.com/wiki/Aspect?file=ZodiacAspects.png\n\n//#define PIXELATE\n\nconst vec3 white  = vec3(1., 1., 1.);\nconst vec3 yellow = vec3(1., 1., 0.);\nconst vec3 red    = vec3(.9, .1, .1);\nconst vec3 blue   = vec3(0., .2, .9);\nconst vec3 black  = vec3(0., 0., 0.);\n\nconst vec3 medblue  = blue  * .6;\nconst vec3 darkred  = red   * .4;\nconst vec3 brown    = red   * .2;\nconst vec3 darkblue = blue  * .3;\nconst vec3 grey     = white * .4;\n\nconst vec3 lightblue = mix(blue, white, .7);\n\nfloat time;\nfloat phaseTime;\n\n\n// wings of aradia megido\nvec4 wings(vec2 uv, float t, vec4 color, float dx) {\n    float u = (uv.x - .5) * (1./t) + .5;\n    vec2 tuv = vec2(mirror(u), uv.y);\n    float d = maxFloat;\n    d = sdBezierMin2(tuv, vec3(.20, .19, .03), vec3(.00, .50, .02), vec3(.20, .70, .02), d);\n    \n    // inner loop\n    d = sdBezierMin2(tuv, vec3(.12, .60, .02), vec3(.09, .63, .015), vec3(.06, .64, .01), d);\n    d = sdBezierMin2(tuv, vec3(.12, .30, .02), vec3(.04, .45, .03), vec3(.04, .50, .02), d);\n    d = sdBezierMin2(tuv, vec3(.06, .64, .01), vec3(-.03, .70, .03), vec3(.04, .50, .02), d);\n\n    // outer loop\n    d = sdBezierMin2(tuv, vec3(.20, .70, .02), vec3(.12, .80, .015), vec3(.00, .81, .01), d);\n    d = sdBezierMin2(tuv, vec3(.13, .28, .03), vec3(.03, .40, .03), vec3(.02, .40, .02), d);\n\n    d = sdBezierMin2(tuv, vec3(.00, .81, .01), vec3(-.2, .80, .03), vec3(.02, .40, .02), d);\n    \n    float e = sdBezierMin2(tuv, vec3(.14, .19, .08), vec3(.10, .16, .10), vec3(.05, .10, .08), d);\n    d = min(d, max(e, -length(tuv-vec2(.05, .10))+.025));\n    \n    return premult(vec4(color.rgb, S(0., -dx, d)));\n}\n\nvec4 candles(vec2 uv, float t, float dx) {\n    //vec2 tuv = vec2(mirror(uv.x), uv.y+(1.-t));\n    vec2 tuv = vec2(mod(uv.x, .7), uv.y+(1.-t));\n    vec4 color = vec4(0., 0., 0., 0.);\n    if (tuv.y < .1 || tuv.y > .35) return color;\n    if (tuv.x < .1 || tuv.x > .2) return color;\n    float d = maxFloat;\n    \n    // candle holders\n    vec2 chuv;\n    float dummy_dc;\n    d = sdFatLine2All(tuv, vec3(.15, .15, .0), vec3(.15, .21, .05), dummy_dc, chuv);\n    d = sdSubtract(d, sdBox2(tuv - vec2(.15, .25), vec2(.05, .02)));\n    if (d < 0.) {\n        vec3 hc = mix(blue, lightblue, L(.1, .4, chuv.y));\n        color = comp(color, premult(hc.rgb, S(0., -dx, d)));\n    }\n    \n    // candles\n    d = sdBox2(tuv - vec2(.13, .25), vec2(.011, .03));\n    d = min(d, sdBox2(tuv - vec2(.165, .26), vec2(.011, .04)));\n    if (d < 0.) color = comp(color, premult(mix(red.rgb, white.rgb, abs(d)/.02), S(0., -1.5*fwidth(d), d)));\n    //if (d < 0.) color = premult(mix(red.rgb, white.rgb, abs(d)/.02), S(0., -1.5*fwidth(d), d));\n    //if (d < 0.) color.rgb = mix(red.rgb, white.rgb, abs(d)/.02), S(-1.5*fwidth(d), 0., d);\n\n    // flamelets\n    d = sdBox2(tuv - vec2(.13, .28), vec2(.005, .007));\n    d = min(d, sdBox2(tuv - vec2(.165, .30), vec2(.006, .008)));\n    if (d < 0.) color = comp(color, premult(yellow.rgb, S(0., -dx, d)));\n    \n    return color;\n}\n\nvec4 webfeet(vec2 uv, float t, float dx, int phase) {\n    vec4 color = vec4(0.);\n    vec2 tuv = vec2(mirror(uv.x), uv.y);\n    tuv.x += t - 1.;\n    if (tuv.y > .4) return color;\n    \n    // webbing\n    float d;\n    vec4 e, f;\n    e = sdBezier(tuv, vec3(.15, .07, .01), vec3(.13, .11, .01), vec3(.16, .22, .01));\n    f = sdBezier(tuv, vec3(.18, .10, .01), vec3(.17, .12, .01), vec3(.23, .21, .01));\n    d = smin(e.x, f.x, .08);\n    e = sdBezier(tuv, vec3(.204, .10, .01), vec3(.23, .13, .01), vec3(.30, .16, .01));\n    d = smin(d, e.x, .09);\n    vec4 feetColor = vec4(mix(yellow, white, abs(d*25.)), 1.);\n    if (d < dx) {\n        float edge = S(0., -dx, d);\n        color = premult(yellow.rgb/2., S(0., -dx, d));\n        if (phase == 2) color = comp(color, premult(red*.7, S(-.015-dx, -.015, d)*edge));\n    }\n\n    // arm\n    d = maxFloat;\n    d = sdBezierMin2(tuv, vec3(.16, -.01, .05), vec3(.15, .03, .05), vec3(.15, .06, .05), d);\n    d = sdBezierMin2(tuv, vec3(.15, .06, .05), vec3(.16, .076, .05), vec3(.17, .09, .05), d);\n    \n    // fingers\n    d = sdBezierMin2(tuv, vec3(.15, .07, .03), vec3(.13, .11, .02), vec3(.16, .22, .01), d);\n    d = sdBezierMin2(tuv, vec3(.18, .10, .03), vec3(.17, .12, .02), vec3(.23, .21, .01), d);\n    d = sdBezierMin2(tuv, vec3(.204, .10, .025), vec3(.23, .13, .02), vec3(.30, .16, .01), d);\n    feetColor = vec4(mix(yellow, white, abs(d*25.)), 1.);\n    if (d < dx) {\n        float edge = S(0., -dx, d);\n        color = comp(color, premult(feetColor.rgb, edge));\n        if (phase == 2) color = comp(color, premult(red*.7, S(-.015-dx, -.015, d)*edge));\n    }\n    \n    return color;\n}\n\nvec4 graves(vec2 uv, float t, float dx) {\n    vec4 color = vec4(0.);\n    //float t = sqrt(1. - sqr(1. - clamp(phaseTime/.7, 0., 1.)))*.25 + .75;\n    vec2 tuv = uv - nop.yz*(t - 1.);\n    if (tuv.y > .5 || tuv.y < 0.) return color;\n    float d = maxFloat;//vec4 d = fMaxFloat * nop.zzzz;\n    vec3 graveFG = grey.rgb;\n\n    if (tuv.x < .2) {\n        // grave 1\n        d = min(d, sdCapsule2(tuv, vec2(.10, -.10), vec2(.10, .18), .08));\n        // cross on grave 1\n        d = min(d, sdBox2(tuv - vec2(.10, .30), vec2(.01, .05)));\n        d = min(d, sdBox2(tuv - vec2(.10, .31), vec2(.03, .01)));\n        if (d < 0.) color = comp(color, premult(graveFG, S(0., -dx, d)));\n    } else if (tuv.x < .5) {\n        // grave 2\n        d = min(d, sdCapsule2(tuv, vec2(.30, -.10), vec2(.30, .10), .10));\n        if (d < 0.) color = comp(color, premult(graveFG, S(0., -dx, d)));\n    } else if (tuv.x < .75) {\n        // grave 3\n        d = min(d, sdCapsule2(tuv, vec2(.65, -.10), vec2(.65, -.05), .1));\n        // cross on grave 3\n        d = min(d, sdBox2(tuv - vec2(.65, .05), vec2(.01, .05)));\n        d = min(d, sdBox2(tuv - vec2(.65, .07), vec2(.03, .01)));\n        if (d < 0.) color = comp(color, premult(graveFG, S(0., -dx, d)));\n    } else {\n        // grave 4\n        float g4 = sdCapsule2(tuv, vec2(.85, -.10), vec2(.85, .24), .1);\n        // RIP on grave 4\n        // letter R\n        float g4rip = 9.;\n      \tg4rip = min(g4rip, sdCapsule2(tuv,  vec2(.83, .25-.027),  vec2(.83, .25+.025), 0.005));\n        float pp = length(tuv - vec2(.842, .26));\n        float po = pp - .02;\n        float pi = pp - .01;\n        float pd = max(max(po, -pi), -sdBox2(tuv-vec2(.82, .25), vec2(0.005, .03)));\n        g4rip = min(g4rip, pd);        \n        g4rip = min(g4rip, sdCapsule2(tuv, vec2(.847, .245), vec2(.858, .223), .005));\n        // letter I\n        g4rip = min(g4rip, sdBox2(tuv - vec2(.84, .15), vec2(.005, .03)));\n        g4rip = min(g4rip, sdCapsule2(tuv, vec2(.84-.010, .18), vec2(.84+.010, .18), .005));\n        g4rip = min(g4rip, sdCapsule2(tuv, vec2(.84-.010, .12), vec2(.84+.010, .12), .005));\n        // letter P\n        g4rip = min(g4rip, sdCapsule2(tuv, vec2(.83, .05-.027), vec2(.83, .05+.025), .005));\n        pp = length(tuv - vec2(.842, .06));\n        po = pp - .02;\n        pi = pp - .01;\n        pd = max(max(po, -pi), -sdBox2(tuv-vec2(.82, .05), vec2(.005, .03)));\n        g4rip = min(g4rip, pd);\n\n        d = min(d, max(g4, -g4rip));\n\n        if (d < 0.) color = comp(color, premult(grey.rgb, S(0., -dx, d)));\n    }\n    return color;\n}\n\n// rad = radii of gear. rad.x=core rad.y=base of teeth rad.z=tip of teeth\n// teethWidth = units? not used\nvec4 gear(vec2 uv, float dx, float time, \n          vec2 center, vec3 rad, float nTeeth, vec2 teethWidth, \n          vec4 gearColor, bool mainGear, int phase)//bool showCenter, bool shadeTeeth) \n{\n    vec2 tuv = uv - center;\n    float r = length(tuv);\n    \n    if (r > rad.z) return vec4(0.);\n    \n    float angleOffset = time * tau/nTeeth;\n    float worldAngle = d2a(tuv);\n    float angle = worldAngle + angleOffset;\n    vec4 color = vec4(0.);\n\n    // inner (raised) center of gear core\n    if (mainGear && r <= rad.x) {\n        //float alpha = S(rad.x, rad.x - 1.5*fwidth(r), r);\n        //color = mix(color, vec4(gearColor, 1.), alpha);\n        color = gearColor;\n    }\n    \n    // gear teeth\n    if (r < rad.z && r > rad.x) {\n        float toothId = floor(angle * (nTeeth/tau));\n        float toothAngle = (toothId + .5) * (tau/nTeeth);\n        \n        vec2 toothDir = a2d(toothAngle - angleOffset); // match start & winding of toothId\n        vec2 toothBase = rad.y * toothDir;\n\n        vec2 toothTip = rad.z * toothDir;\n        float dToothCenter = 1.;\n        vec2 uvTooth;\n        float d = sdFatLine2All(tuv, vec3(toothBase, teethWidth.x), vec3(toothTip, teethWidth.y), dToothCenter, uvTooth);\n       \t\n        float alpha = S(0., -dx, d); // antialias the primitives\n        alpha *= S(rad.z, rad.z - dx, r); // cut off & antialias the outer edge\n        vec4 toothColor;\n        if (mainGear) {\n            float uDark = (dot(toothDir, vec2(.4, 1.)) > 0.) ? .7 : .3;\n            float darkSide = S(uDark, .5, uvTooth.y);\n            toothColor = mix(vec4(gearColor.rgb*.65, 1.), gearColor, darkSide);\n        } else {\n            toothColor = gearColor;\n        }\n        if (d < dx) {\n            color = mix(color, toothColor, alpha);\n            if (mainGear && phase == 2) color = comp(color, premult(red*.7, S(-.02, -.02+dx, d)*alpha));\n        }\n    }\n    \n    // outer (recessed) ring of gear core\n    if (r < rad.y && r >= rad.x) {\n        float fr = dx;\n        float alpha = S(rad.y, rad.y - fr, r);\n        if (!mainGear) alpha *= S(rad.x, rad.x + fr, r);\n        else alpha *= S(rad.x-fr, rad.x+0.*fr, r);\n        vec3 ringColor;\n        if (mainGear) {\n            // shadow from raised core\n            ringColor = gearColor.rgb;\n            bool shadowSide = dot(tuv, vec2(.8, -1)) > 0.;\n            vec2 stuv = remove(tuv, rad.y*normalize(vec2(.8, -1.)));\n            float lstuv = length(stuv);\n            bool inShadow = lstuv < rad.x;\n            if (shadowSide && inShadow) {\n                float roundEdge = S(rad.x, rad.x+fr, r);\n                float straightEdgeSoftness = mix(1.5, 10., S(rad.x, rad.y, r));\n                float straightEdge = S(rad.x, rad.x-straightEdgeSoftness*dx, lstuv);\n                ringColor *= mix(1., .65, roundEdge * straightEdge);\n            }\n            \n            if (phase == 1) {\n                // highlight from raised core\n                //ringColor = gearColor.rgb;\n                bool shadowSide = dot(tuv, vec2(.8, -1)) < 0.;\n                vec2 stuv = remove(tuv, rad.y*normalize(vec2(.8, -1.)));\n                float lstuv = length(stuv);\n                bool inShadow = lstuv < rad.x;\n                if (shadowSide && inShadow) {\n                    float roundEdge = S(rad.x, rad.x+fr, r);\n                    float straightEdgeSoftness = mix(1.5, mix(25., 150., time), S(rad.x, rad.y, r));\n                    float straightEdge = S(rad.x, rad.x-straightEdgeSoftness*dx, lstuv);\n                    ringColor /= mix(1., .5, roundEdge * straightEdge);\n                }\n            }\n            \n        } else {\n            ringColor = gearColor.rgb;\n        }\n        color = mix(color, vec4(ringColor, 1.), alpha);\n    }\n    \n    return color;\n}\n\nvec4 timeEyes(vec2 uv, float time, float dx, vec3 eyeColor, int phase) {\n    vec4 color = vec4(0.);\n    vec2 euv = vec2(mirror(uv.x), uv.y + time*.1);\n    const float eRad = .1;\n    const vec2 eCenter = vec2(.25, .99);\n    float d = sdCircle(euv - eCenter, eRad);\n    vec2 browP = eCenter + eRad*1.*nop.yz;\n    vec2 browD = normalize(vec2(1.5, -1.));\n    d = sdUnion(d, sdFatLine2(euv, vec3(eCenter + eRad*nop.zz*.3, eRad*.5), vec3(browP+browD*2.*eRad, 0.)));\n    d = sdSubtract(d, dot(euv - browP, rot90(browD)));\n    vec2 eyeSpace = rot(.2)*(euv - eCenter);\n    vec2 pupilSpace = vec2(length(eyeSpace*vec2(2.,1.))-.02*time, d2a(eyeSpace));\n    float dPupil = pupilSpace.x - .3*eRad;\n    vec4 ec = texture(iChannel0, pupilSpace*vec2(.3,.1)*2.);\n    ec.rgb = mix(ec.rgb, vec3(.5), .75);\n    ec.rgb *= S(-dx, 0., dPupil);\n    \n    // highlight\n    vec2 worldEyeSpace = eyeSpace;\n    if (uv.x > .5) worldEyeSpace.x =  - worldEyeSpace.x;\n    vec3 n = normalize(vec3(worldEyeSpace, 1.-sqrt(length(worldEyeSpace/eRad))));\n    float hl = .5*pow(abs(dot(n, normalize(vec3(.25, .3*time, 1.)))), 30.);\n    hl += .5*pow(abs(dot(n, normalize(vec3(-.25, -.5+.3*time, 1.)))), 30.);\n    hl = sqr(hl);\n    \n    if (d < dx) {\n        float edge = S(0., -dx, d);\n        color = comp(color, premult(ec.rrr*eyeColor + hl*white, edge));\n        if (phase == 2) color = comp(color, premult(red*.7, S(-.015-dx, -.015, d)*edge));\n    }\n    \n    //color.rgb += .2; // show bounds\n        \n    return color;\n}\n\nvec4 Time( vec2 uv, float dx )\n{\n    const vec2 center = vec2(.5, .5);\n\n    // BG \n    vec2 tuv = uv - center;\n    float r = length(tuv);\n    float a = d2a(tuv);//atan(tuv.x, tuv.y)+pi+iTime;    \n    \n    int phase = int(time) & 0x3;\n    float phaseTime = fract(time);\n    \n    float phaseTimeEaseOut = sqrt(1.-sqr(1.-phaseTime));\n    float phaseTimeEaseOutFast = sqrt(1.-sqr(1.-min(phaseTime/.5, 1.)));\n        \n    float t = sqrt(1. - sqr(1. - clamp(phaseTime/.7, 0., 1.)))*.5 + .5;\n\n\tvec4 color;\n    vec4 gearColor;\n    vec4 lgc;\n    vec4 pendColor;\n    switch(phase) {\n        case 0: \n        \tcolor = vec4(.3, .1, .1, 1.);\n        \tgearColor = lgc = vec4(mix(vec3(1., 1., .5), red, phaseTimeEaseOut), 1.); \n        \tpendColor = vec4(.4, .1, .1, 1.);\n        \tlgc = mix(vec4(1., 1., .5, 1.), pendColor, phaseTimeEaseOut);\n        \tbreak;\n        case 1: \n        \tcolor = vec4(darkblue, 1.);\n        \tgearColor = lgc = vec4(mix(white, grey,  phaseTimeEaseOut), 1.);\n        \tpendColor = vec4(blue, 1.);\n            lgc = vec4(mix(white, pendColor.rgb,  phaseTimeEaseOut), 1.);\n            break;\n        case 2: color = vec4(brown, 1.) ; \n        \tgearColor = vec4(white, 1.) ; \n        \tpendColor = vec4(.5, .5, 1., 1.);\n        \tlgc = vec4(mix(white, pendColor.rgb,  phaseTimeEaseOut), 1.);\n        \tbreak;\n        case 3: color = vec4(blue*.2, 1.)    ; \n        \tgearColor = vec4(grey, 1.);\n        \tpendColor = vec4(.3, .3, .3, 1.);\n        \tlgc = pendColor;\n        \tbreak;\n    }\n    \n        \n    // little gear color\n    vec3 rad = vec3(.09, .12, .15);\n    color = comp(color, gear(uv, dx,  phaseTimeEaseOut-.49, vec2(.0,  1.), rad, 4., vec2(.02,.015), lgc, false, phase));\n    color = comp(color, gear(uv, dx, -phaseTimeEaseOut-.25, vec2(.17, .8), rad, 4., vec2(.02,.015), lgc, false, phase));\n    color = comp(color, gear(uv, dx,  phaseTimeEaseOut-.0,  vec2(.34, 1.), rad, 4., vec2(.02,.015), lgc, false, phase));\n    color = comp(color, gear(uv, dx,  phaseTimeEaseOut-.0,  vec2(1., .85), rad, 4., vec2(.02,.015), lgc, false, phase));\n    color = comp(color, gear(uv, dx, -phaseTimeEaseOut+.17, vec2(1., .59), rad, 4., vec2(.02,.015), lgc, false, phase));\n    \n    // pendulum\n    float pendulumPos = sin(time*tau/2.);\n    float pAngle = pendulumPos*.5;\n    vec2 p1 = vec2(0.5, 1.); // top pivot point of pendulum stick\n    vec2 stickDir = vec2(-sin(pAngle), -cos(pAngle));\n    vec2 p2 = p1 + .95 * stickDir; // center of pendulum bob\n    float distToPivot = dot(stickDir, uv - p1);\n    // add a little \"motion blur\"\n    vec2 dirToStick = remove(uv - p2, stickDir);\n    vec2 bobuv = uv - .25 * (1. - abs(pendulumPos)) * distToPivot * dirToStick;\n    // pendulum bob\n    float d = length(bobuv-p2) - .05;\n    if (d < 0.) color = comp(color, premult(pendColor.rgb, S(0., -dx, d)));\n    // pendulum stick\n    d = sdCapsule2(bobuv, p1, p2, 0.01);\n    if (d < 0.) color = comp(color, premult(pendColor.rgb, S(0., -dx, d)));\n    \n    // special background\n    switch(phase) {\n        case 0: color = comp(color, wings( uv, t, mix(lgc, vec4(.2, .15, .3, 1.), phaseTime ), dx )); break;\n        case 1: color = comp(color, candles ( uv, t, dx )); break;\n        case 2: color = comp(color, webfeet ( uv, t, dx, phase )); break;\n        case 3: color = comp(color, graves  ( uv, t, dx )); break;\n    }\n    \n    // base symbol of time\n    const float r1 = .23; // inner radius of gear\n    const float r2 = .31; // outer radius of gear (base of teeth)\n    const float r3 = .40; // outer radius of gear teeth (tip of teeth)\n    const float rayWidth = .05;\n\n    // big gear color\n    vec4 bgc = gear(uv, dx, phaseTimeEaseOut, vec2(.5, .5), vec3(.23, .31, .40), 10., vec2(.05,.04), gearColor, true, phase);\n    color = comp(color, bgc);\n    \n    // eyes\n    if (uv.y > .79 && uv.x > .14 && uv.x < .86) color = comp(color, timeEyes(uv, phaseTimeEaseOut, dx, mix(white,gearColor.rgb,.8), phase));\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime/1. + 3.*iMouse.x/iResolution.y;\n    float margin = .5 * (iResolution.x - iResolution.y);\n\tvec2 uv = (fragCoord.xy - X*margin) / iResolution.yy;\n    float dx = fwidth(length(uv)) * 1.5;\n    \n#ifdef PIXELATE\n    uv = floor(uv * 64.) / 64.;\n    time = floor(time * 16.) / 16.;\n#endif // PIXELATE\n\n    fragColor = vec4(0.);\n    if (uv.x >= 0.0 && uv.x <= 1.0) fragColor = Time(uv, dx);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define S(a,b,t) smoothstep(a,b,t)\n#define H(a,b,t) (step(a,t)*(1.-step(b,t)))\n#define unlerp(a,b,t) ((t-a)/(b-a))\n#define v30 vec3(0.)\n\n// lump between a and b. \n// returns 0 when t is outside [a,b]\n// returns 1 at t=(a+b)/2.\n// smoothstep from center to either end (t==a, t==b)\nfloat L(float a, float b, float t) {\n    float u = unlerp(a, b, t);\n    return S(0., 1., 2.*u) * S(0., 1., 2. - u*2.);\n}\n\n// take [0, 1], return [0, .5] + [.5, 0]\nfloat mirror(float x) { return .5-abs(x-.5); }\n\nfloat N(float t) {\n\treturn fract(sin(t*10234.324)*123423.23512);\n}\n\n// remove r from n, i.e., project n onto plane with normal r\nvec3 remove(vec3 n, vec3 r) {\n    return n - r * dot(n, r) / dot(r, r);\n}\nvec2 remove(vec2 n, vec2 r) {\n    return n - r * dot(n, r) / dot(r, r);\n}\n\nvec2 rot90(vec2 v) {\n    return vec2(v.y, -v.x);\n}\n\nconst vec2 X = vec2(1., 0.);\nconst vec3 nop = vec3(-1., 0., 1.);\nconst float pi = 4. * atan(1.); //3.14159265358979323;\nconst float tau = 8. * atan(1.); //2. * pi;\nconst float maxFloat = intBitsToFloat(0x7f7fffff);\n\nvec4 premult(vec4 color) {\n    return vec4(color.rgb * color.a, color.a);\n}\n\nvec4 premult(vec3 rgb, float alpha) {\n    return vec4(rgb * alpha, alpha);\n}\n\nvec4 comp(vec4 bg, vec4 fg) {\n    return fg + bg * (1. - fg.a);\n}\n    \nvec4 comp(vec4 bg, vec3 fg, float a) {\n    return vec4(fg + bg.rgb * (1. - a), bg.a + a);\n}\n    \nvec3 comp(vec3 bg, vec3 fg, float a) {\n    return fg + bg * (1. - a);\n}\n\n// val is [0..1]. steps is output resolution. offset is the dither value (constant, rand, pwm, etc.)\nfloat dither(float val, float steps, float offset) {\n    return floor(val * steps + offset) / steps;\n}\n\n//https://www.shadertoy.com/view/ltXSDB\n// Solve cubic equation for roots\nvec3 solveCubic(float a, float b, float c)\n{\n    float p = b - a*a / 3., p3 = p*p*p;\n    float q = a * (2.*a*a - 9.*b) / 27. + c;\n    float d = q*q + 4.*p3 / 27.;\n    float offset = -a / 3.;\n    if(d >= 0.) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1./3.));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27. / p3) * q / 2.) / 3.;\n    float m = cos(v), n = sin(v)*1.732050808;//sqrt(3.);\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.) + offset;\n}\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat testCross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat signBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{ \n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0, \n        step(testCross(A, B, p) * testCross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * testCross(A, C, B);\n}\n\n//https://www.shadertoy.com/view/ltXSDB\n// Find the signed distance from a point to a bezier curve\n// returns a vec4: (dist to boundary, dist to curve, sign, parameter [0-1])\nvec4 sdBezier(vec2 p, vec3 A, vec3 B, vec3 C)\n{    \n    //B = (4.0 * B - A - C) / 2.0;\n    // handle instability when B is midpoint between A and C\n    //B = vec3(mix(B.xy + vec2(1e-4), B.xy, abs(sign(B.xy * 2.0 - A.xy - C.xy))), B.z);\n    \n    vec3 a = B - A;\n    vec3 b = A - B * 2.0 + C;\n    vec3 c = a * 2.0;\n    vec2 d = A.xy - p;\n    \n    vec3 k = vec3(3.*dot(a.xy,b.xy),2.*dot(a.xy,a.xy)+dot(d.xy,b.xy),dot(d.xy,a.xy)) / dot(b.xy,b.xy);      \n    vec3 t = clamp(solveCubic(k.x, k.y, k.z), 0., 1.);\n    vec3 it = vec3(1.0) - t;\n\n    vec3 pos0 = A + (c + b*t.x)*t.x;\n    vec3 pos1 = A + (c + b*t.y)*t.y;\n    vec3 pos2 = A + (c + b*t.z)*t.z;\n\n    float dis0 = length(pos0.xy - p) - pos0.z;\n    float dis1 = length(pos1.xy - p) - pos1.z;\n    float dis2 = length(pos2.xy - p) - pos2.z;\n    \n\tfloat minT = t.x;\n    vec3 minP = pos0;\n\tfloat minDis = dis0;\n\tif (dis1 < minDis) { minDis = dis1; minT = t.y; minP = pos1; }\n\tif (dis2 < minDis) { minDis = dis2; minT = t.z; minP = pos2; }\n            \n    return vec4(minDis, minDis + minP.z, signBezier(A.xy, B.xy, C.xy, p), minT);\n}\n\nfloat sdBezierMin2(vec2 p, vec3 a, vec3 b, vec3 c, float dist) {\n    vec4 d = sdBezier(p, a, b, c);\n    if (d.x < dist) return d.x;\n    else return dist;\n}\n\nvec4 sdBezierMin2(vec4 d, vec2 p, vec3 a, vec3 b, vec3 c) {\n    vec4 e = sdBezier(p, a, b, c);\n    if (d.x < e.x) e = d;\n    return e;\n}\n\nfloat sdBezier2(vec2 p, vec3 a, vec3 b, vec3 c) {\n    vec4 d = sdBezier(p, a, b, c);\n    return d.x;\n}\n\n// returns a vec4: (dist to boundary, dist to curve, sign, parameter [0-1])\nvec4 sdCurve(vec2 p, int n, vec3[16] pts) {\n    int nn = n - 1;\n    vec4 d = vec4(maxFloat);    \n    vec3 pp1 = mix(pts[0], pts[1], -0.001), pp2;\n    float oofn = 1. / (float(n));\n    vec4 e;\n    for (int i = 0; i < nn; i++) {\n        pp2 = .5 * (pts[i] + pts[i+1]);\n        e = sdBezier(p, pp1, pts[i], pp2);\n        pp1 = pp2;\n        if (e.x < d.x) d = vec4(e.xyz, (e.w+float(i))*oofn);\n    }\n    pp2 = pts[nn];\n    e = sdBezier(p, pp1, pts[nn], pp2);\n    if (e.x < d.x) d = vec4(e.xyz, (e.w+float(nn))*oofn);\n\n    // signBezier fails on the first & last segments, here's a patch\n    if (d.w <= oofn) {\n        d.z = dot(p - pts[0].xy, rot90( pts[0].xy - pts[1].xy ) ) < 0. ? 1. : -1.;\n    }\n    else if (d.w >= 1.-oofn) {\n    \td.z = dot(p - pts[nn].xy, rot90( pts[nn-1].xy - pts[nn].xy ) ) < 0. ? 1. : -1.;\n    }\n\n    return d;\n}\n\nvec4 sdCurveSeg(vec4 d, vec2 p, int n, int i, vec3 a, vec3 b, vec3 c) {\n    vec4 e = sdBezier(p, a, b, c);\n    if (e.x < d.x) {\n        e = vec4(e.xyz, (e.w+float(i))/float(n+1));\n    }\n    else e = d;\n    return e;\n}\n\nvec4 sdCurveMid(vec4 d, vec2 p, int n, int i, vec3 a, vec3 b, vec3 c) {\n    vec4 e = sdBezier(p, mix(a,b,.5), b, mix(b,c,.5));\n    if (e.x < d.x) {\n        e = vec4(e.xyz, (e.w+float(i))/float(n));\n    }\n    else e = d;\n    return e;\n}\n\nvec4 sdCurveBgn(vec4 d, vec2 p, int n, int i, vec3 a, vec3 b, vec3 c) {\n    vec4 e = sdBezier(p, a, a, mix(a,b,.5));\n    if (e.x < d.x) {\n        e = vec4(e.xyz, (e.w+float(i))/float(n));\n        // signBezier fails on the first & last segments, here's a patch\n        e.z = dot(p - a.xy, rot90( a.xy - b.xy ) ) < 0. ? 1. : -1.;\n    }\n    else e = d;\n    \n    e = sdCurveMid(e, p, n, i+1, a, b, c);\n    \n    return e;\n}\n\nvec4 sdCurveEnd(vec4 d, vec2 p, int n, int i, vec3 a, vec3 b, vec3 c) {\n    vec4 e = sdBezier(p, mix(b,c,.5), c, c);\n    if (e.x < d.x) {\n        e = vec4(e.xyz, (e.w+float(i+1))/float(n));\n        // signBezier fails on the first & last segments, here's a patch\n        e.z = dot(p - c.xy, rot90( b.xy - c.xy ) ) < 0. ? 1. : -1.;\n    }\n    else e = d;\n    \n    e = sdCurveMid(e, p, n, i, a, b, c);\n    \n    return e;\n}\n\n// 2 output vectors: curvePoint, curveTangent\nvoid evalBezier(float t, vec2 a, vec2 b, vec2 c, out vec2 curvePoint, out vec2 curveTangent) {\n    t = clamp(t, 0., 1.);\n    curvePoint = mix(mix(a, b, t), mix(b, c, t), t);\n    curveTangent = 2. * (( a + c - 2. * b ) * t + ( b - a ));\n}\n\n// 2 output vectors: curvePoint, curveTangent\nvoid evalCurve(float t, int n, vec3[16] pts, out vec2 curvePoint, out vec2 curveTangent) {\n    float nt = clamp(t, 0.0001, .9999) * float(n);\n    int j = int(nt);\n    int i = max(0, j - 1);\n    int k = min(n-1, j + 1);\n    float tSegment = nt - float(j);\n    \n    vec2 a = pts[i].xy;\n    vec2 b = pts[j].xy;\n    vec2 c = pts[k].xy;\n    \n    a = mix(a, b, .5);\n    c = mix(b, c, .5);\n    \n    curvePoint = mix(mix(a, b, tSegment), mix(b, c, tSegment), tSegment);\n  \tvec2 ba = b-a;\n   \tcurveTangent = 2. * (( c - b - ba ) * tSegment + ( ba ));\n}\n\nstruct Hit {\n    float dBound;\n    float dCurve;\n    float sign;\n    vec2 pos;\n    vec2 tangent;\n    vec3 normal;\n    vec2 uv;\n};\n\n// vec4 d is the same format as return from sdBezier: vec4( dBound, dCurve, sign, param )\nvec2 calcBezierUv(float dBound, float dCurve, float sign, float param) {\n    return vec2(param, .5 + .5 * sign * dCurve / (abs(dBound) + dCurve));\n}\n\nHit calcBezierHit(vec2 uv, vec3 a, vec3 b, vec3 c) {\n    Hit hit;\n    vec4 d = sdBezier(uv, a, b, c);\n    hit.dBound = d.x;\n    hit.dCurve = d.y;\n    hit.sign = d.z;\n    hit.uv = calcBezierUv(d.x, d.y, d.z, d.w);\n    evalBezier(d.w, a.xy, b.xy, c.xy, hit.pos, hit.tangent);\n    float z = sin(hit.uv.y * pi);\n    hit.normal = normalize(vec3( (1.-z)*normalize(uv - hit.pos), .25*z));\n    return hit;\n}\n\nHit calcCurveHit(vec2 uv, int n, vec3[16] pts) {\n    Hit hit;\n    vec4 d = sdCurve(uv, n, pts);\n    hit.dBound = d.x;\n    hit.dCurve = d.y;\n    hit.sign = d.z;\n    hit.uv = calcBezierUv(d.x, d.y, d.z, d.w);\n    evalCurve(d.w, n, pts, hit.pos, hit.tangent);\n    float z = sin(hit.uv.y * pi);\n    hit.normal = normalize(vec3( (1.-z)*normalize(uv - hit.pos), .25*z));\n    return hit;\n}\n\nvec3 calcCurveRoundNormal(vec2 uv, Hit hit) {\n    float z = sin(hit.uv.y * pi);\n    return normalize(vec3( (1.-z)*normalize(uv - hit.pos), .25*z));\n}\n\nvec3 calcCurveTentNormal(vec2 uv, Hit hit) {\n    float z = abs(hit.uv.y);\n    return normalize(vec3( (1.-z)*normalize(uv - hit.pos), .25*z));\n}\n\n// a & b are two points w/ radius. a.xy = 2d point, a.z = radius\n// u=along curve v=perpendicular\n// bend should be [0,1], usually small like .1\n// bendWidth default should be .5. Increase for a smoother bend.\nfloat sdBentLine(vec2 p, vec3 a, vec3 b, float bend, float bendWidth /*, out float distToCurve, out vec2 uv*/) {\n    vec2 d = b.xy - a.xy;\n    \n    vec2 pd = p - a.xy;\n    float t = dot(pd, d) / dot(d, d);\n    t = min(1., max(0., t));\n    vec2 cp = a.xy + t * d;\n    cp += bend*rot90(d)*L(.5-bendWidth, .5+bendWidth, t);\n    \n    vec2 n = p - cp;\n    float distToCurve = length(n); // optionally output this\n    \n    // remember a.z & b.z are radius\n    float cr = mix(a.z, b.z, t);\n    float v = .5 + .5 * dot(vec2(-pd.y, pd.x), normalize(d)) / cr;\n    vec2 uv = vec2(t, v); // optionally output this\n\n    float distToBoundary = distToCurve - cr;\n    return distToBoundary;\n}\n\n// a & b are two points w/ radius. a.xy = 2d point, a.z = radius\n// u=along curve v=perpendicular\nfloat sdFatLine2All(vec2 p, vec3 a, vec3 b, out float distToCurve, out vec2 uv) {\n    vec2 d = b.xy - a.xy;\n    vec2 pd = p - a.xy;\n    float t = dot(pd, d) / dot(d, d);\n    t = min(1.0, max(0.0, t));\n    vec2 cp = a.xy + t * d;\n    \n    vec2 n = p - cp;\n    distToCurve = length(n);\n    \n    // remember a.z & b.z are radius\n    float cr = mix(a.z, b.z, t);\n    float v = .5 + .5 * dot(vec2(-pd.y, pd.x), normalize(d)) / cr;\n    uv = vec2(t, v);\n\n    float distToBoundary = distToCurve - cr;\n    \n    return distToBoundary;\n}\n\nfloat sdFatLine2(vec2 p, vec3 a, vec3 b)\n{\n    float dummy_dc;\n    vec2 dummy_uv;\n    return sdFatLine2All(p, a, b, dummy_dc, dummy_uv);\n}\n\nmat2 rot(float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat remap(float v, float min1, float max1, float min2, float max2) {\n    return min2 + (max2 - min2) * (v - min1) / (max1 - min1);\n}\n\nfloat bias(float x, float b) { return pow(x,log(b)/log(0.5)); }\n\nfloat gain(float x, float g) { return (x<0.5) ? bias(2.*x,1.-g)/2. : 1. - bias(2.-2.*x,1.-g)/2.; }\n\nfloat aaFloor(float x) {\n    float dx = 2. * length(vec2(dFdx(x), dFdy(x)));\n    float fx = fract(x), idx = 1. - dx;\n    return (fx < idx) ? x - fx : remap(fx, idx, 1., x-fx, x);\n}\n\nfloat aaFract(float x) {\n    float dx = 2. * length(vec2(dFdx(x), dFdy(x)));\n    float fx = fract(x), idx = 1. - dx;\n    return (fx < idx) ? fx : remap(fx, idx, 1., fx, 0.);\n}\n\nfloat stairs(float x, float steps) {\n    return floor(x * steps) / steps;\n}\n\nfloat stairs2(float x, float steps) {\n    return round(x * steps) / steps;\n}\n\nfloat escalator(float x, float steps, float time) {\n    float dx = 1. / steps;\n    x = remap(x, 0., 1., -dx/2., 1.+dx/2.) + dx/2.;\n    float ex = (x - time*dx) * steps;\n    float ey = (aaFloor(ex) + time) * dx;\n    return clamp(ey, 0., 1.);\n}\n\nvec2 escalatorId(float x, float steps, float time) {\n    float dx = 1. / steps;\n    x = remap(x, 0., 1., -dx/2., 1.+dx/2.) + dx/2.;\n    float ex = (x - time*dx) * steps;\n    float id = floor(ex);\n    float ey = (aaFloor(ex) + time) * dx;\n    return vec2(clamp(ey, 0., 1.), id);\n}\n\nfloat saw(float x) {\n    float mx = mod(x,1.);\n    return 2. * min(mx, 1.-mx);\n}\n\nfloat dline(vec2 p, vec2 lp, vec2 ld) {\n    return dot(p-lp, ld);\n}\n\nfloat sqr(float x) { return x*x; }\n\nfloat d2a (vec2 d) {\n    return atan(d.y, d.x);\n}\n\nvec2 a2d (float a) {\n    return vec2(cos(a), sin(a));\n}\n\n// polar = radius, angle. angle is unit [0..1] (not 2pi). convenient, right?\nvec2 xy2polar (vec2 xy) {\n    return vec2(length(xy), d2a(xy)/tau + .5);\n}\n\n// polar = radius, angle. angle is unit [0..1] (not 2pi). convenient, right?\nvec2 polar2xy (vec2 ra) {\n    return ra.x * a2d(tau * (ra.y - .5));\n}\n\nfloat sdEdgeNormal(vec2 x, vec2 p, vec2 normal) {\n    return dot(x-p, normal);\n}\n\nfloat sdEdgePoints(vec2 x, vec2 p1, vec2 p2) {\n    return dot(x-p1, normalize(rot90(p2 - p1)));\n}\n\n\n// lots of distance functions from IQ\n// https://iquilezles.org/articles/distfunctions\n\nfloat sdBox3( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox2( vec2 p, vec2 b )\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.) + length(max(d,0.));\n}\n\nfloat udRoundBox( vec2 p, vec2 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat udBox( vec2 p, vec2 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdCircle( vec2 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCapsule2All( vec2 p, vec2 a, vec2 b, float r, out float distToCenter, out vec2 uv, out vec2 pCenter )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    distToCenter = length( pa - ba*h );\n    float distToBoundary = distToCenter - r;\n    return distToBoundary;\n}\n\nfloat sdCapsule2( vec2 p, vec2 a, vec2 b, float r )\n{\n    vec2 dummy_pc, dummy_uv;\n    float dummy_dc;\n    return sdCapsule2All(p, a, b, r, dummy_dc, dummy_uv, dummy_pc);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// d1 minus d2\nfloat sdSubtract( float d1, float d2 )\n{\n    return max(d1, -d2);\n}\n\n// d1 union d2\nfloat sdUnion( float d1, float d2 )\n{\n    return min(d1, d2);\n}\n","name":"Common","description":"","type":"common"}]}