{"ver":"0.1","info":{"id":"WlccWN","date":"1609064944","viewed":177,"name":"interference (fullscreen)","username":"lahwran","description":"trying to analyze interference patterns between notes again. click and drag to add a third note at the given y. eg, to evaluate a major chord, click on y=3 (ie, note 4), then focus your eyes on y=6 (ie, note 7). then tune down to get it in phase!","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["musictheory"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define LINE_SIZE 1.0\n#define GRID_LINE_SIZE 1.0\n#define GRID_AXIS_SIZE 1.\n#define GRID_LINES 1.\n#define PI (atan(1.0) * 4.0)\n#define XSCALE 16.0\n\n#define resolution iResolution.y\n//#define resolution 300.\n\nfloat zooms(float mousex, bool mousedown) {\n    return mousedown ? floor(12.+mousex) : 12.;\n}\n\n\nfloat et2hz(float midi, float zoom) {\n    return pow(2., midi/zoom);\n}\n\nfloat osc(float x) {\n    // pure sin osc:\n    //return sin(x*PI*2.);\n    // pure saw osc:\n    return fract(x);\n}\n\nfloat bowl(float x, float p_) {\n    x = fract(x);\n    float p = 3.0 * p_;\n    return mix(0.0, 1.0, pow(x, p) + pow(1.-x, p));\n}\nvec2 rescale_factor(float zoom) {\n    return (vec2(1.0 / resolution) * vec2(XSCALE, zoom));\n}\n\nvec3 Derp(vec2 pixel, float alt_z, float zoom) {\n    vec2 rs = rescale_factor(1.);\n    vec2 p = rs * pixel;\n    \n    //phases of each wave at this pixel\n    //note: \"et2hz\" converts equal temperament(note) -> hz, using ZOOM as current equal temperament division\n    float phase_1 = osc((p.x)*et2hz(p.y, 1.));  // phase_1 is the wave at time p.x and freq p.y. range: [0..1]\n    float phase_2 = osc((p.x)*et2hz(0.0, 1.));// phase_2: time p.x, freq alt_y (note 0 by default)\n    float phase_3 = osc((p.x)*et2hz(alt_z, zoom));// phase_3: freq set by mouse or defaults to 0\n    //phase diffs: 1.0 if phases are same, 0.0 if \n    float phase_diff_a = 1.-abs(phase_1 - phase_2); //p.y wave 1 vs ref wave 2; \n    float phase_diff_b = 1.-abs(phase_2 - phase_3); //ref wave 2 vs mouse wave 3\n    float phase_diff_c = 1.-abs(phase_1 - phase_3); //p.y wave 1 vs mouse wave 3\n    // product of phase diffs: 1.0 if all three are 1.0, approaches 0 as any one of them does\n    float phase_diff_1 = phase_diff_a * phase_diff_c * phase_diff_b;\n    //x^3 to bend the phase_diff_1 value towards zero for sharpening the fade into the edges\n    // SUGGESTED CHANGE: comment this line\n    phase_diff_1 = pow(phase_diff_1, 5.);\n    // calculate a scaling variable that animates (according to mix()'s third argument) between\n    //   bowl(p.y), a repeating bowl wave that ranges from 1.0 at each integer value to 0.0 at any fract(x)=0.5 value\n    //   1.0, when the exp(sin(time)) animation value is large enough\n    // this scaling variable is what flashes the mute of off-key values\n    // when m is down, this is instead a bowl function on the mouse position y\n    \n    float copeak_curve = 1.0;\n    float copeak_amount = bowl(phase_1, copeak_curve)*bowl(phase_2, copeak_curve)*bowl(phase_3, copeak_curve);\n    \n    // construct an RGB value by gating each phase diff value with a bowl() of a relevant phase diff\n    // this is the thing that finally assembles it all into an rgb value you see on screen\n    return vec3((1.0-copeak_amount)*phase_diff_1*0.4, copeak_amount*phase_diff_1, pow((phase_1+phase_2+phase_3)/3.0, 5.0));\n}\n\n\nvec3 grid(vec2 pixel, vec3 col, float zoom)\n{\n    vec2 rs = rescale_factor(zoom);\n\tvec2 uv = mod(pixel * rs,1.0);\n\n    \n\tvec2 rad = GRID_LINE_SIZE * rs;\n    vec2 halfScale = 0.5 * rs;\n    //if (uvp.x < 1.0 || uvp.y < 1.0 || uvp.x >= ) {\n    //    return vec3(0., 0., 0.);\n    //}\n    vec2 my_zero = vec2(uv.x > 0.5 ? 1.0 : 0.0, uv.y > 0.5 ? 1.0 : 0.0);\n    vec2 uv_distance_to_my_zero = vec2(abs(my_zero.x - uv.x), abs(my_zero.y - uv.y));\n    vec2 pixel_dist = uv_distance_to_my_zero / rs;\n    float grid_amount = max(0.0, min(pixel_dist.x, pixel_dist.y) - 0.125);\n\n\t//float grid = halfScale - max(abs(uv.x - halfScale.x), abs(uv.y - halfScale.y));\n\t//grid = smoothstep(0.0, rad, grid);\n\n\t//float axis = min(abs(p.x), abs(p.y));\n\t//axis = smoothstep(axisRad - 0.02, rad, axis);\n    \n    float blend = 0.2;\n    col = mix(vec3(0.9, 0.8, 0.5), col, 1.0-blend*(1.0-max(0.0, min(1.0, grid_amount))));\n\treturn col;\n}\n\nfloat scaling(vec2 pixel, vec2 mouse, bool mousedown, float zoom) {\n    vec2 rs = rescale_factor(zoom);\n    vec2 p = rs * pixel;\n    vec2 mousecoord = mouse * rs;\n\n    // 1.0-bowl(fract(mousecoord.y), 2.0)\n    return pow(mix(bowl(p.y, 5.0), 1.0, mousedown ? 0.2 : bowl(fract(iTime/3.), 5.0)),1.);\n}\n\n\n// *** copied from another shadertoy:\n\n//=== original link for citation: https://www.shadertoy.com/view/llySRh\n//find many other tricks here: https://shadertoyunofficial.wordpress.com/\n\n// --- content:\n// - 2D and 3D rotations\n// - hue\n// - printing chars, text, ints, floats\n\n\n// --- compatibility tricks ------------------------------------------\n\n// all compatibility issues: https://shadertoyunofficial.wordpress.com/2016/07/22/compatibility-issues-in-shadertoy-webglsl/\n// force OpenGL on Windows: \n//       chrome:    chrome.exe --use-angle=gles\n//       firefox:   URL:  about:config   ; search “angle”; click on webgl.disable-angle to switch\n// online Windows, etc: https://www.browserling.com/ [ may still be using OpenGL ]\n//                      https://www.onworks.net/     [ may still be using OpenGL ]\n\n// --- rotations -----------------------------------------------------\n\n// 2D, or one axis after the other:\n#define rot2(a)      mat2(cos(a),-sin(a),sin(a),cos(a)) // V.xy *= rot2(a.z)\n\n// 3D rot around an arbitrary axis\n#define rot(P,A,a) ( mix( A*dot(P,A), P, cos(a) ) + sin(a)*cross(P,A) )\n\n\n// --- short approx hue -------------- https://www.shadertoy.com/view/ll2cDc\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n#define hsv(h,s,v)    (v) * ( 1. + (s)* ( .6 * cos( 6.3*(v)  + vec3(0,23,21)  ) - .4 ) )\n// short exact:\n//#define hsv(h,s,v)  (v) * ( 1. + (s)* clamp(  abs( fract( h + vec3(3,2,1)/3. ) * 6. - 3. ) - 2., -1.,0.) )\n\n\n// --- polar and complexes -------- https://shadertoyunofficial.wordpress.com/2019/01/02/programming-tricks-in-shadertoy-glsl/\n \n#define CS(a)        vec2( cos(a), sin(a) )\n#define cart2pol(U)  vec2( length(U), atan((U).y,(U).x) )\n#define pol2cart(U) ( (U).x * CS( (U).y ) )\n\n// add, sub;  mul or div by float : just use +, -, *, /\n#define cmod(Z)     length(Z)\n#define carg(Z)     atan( (Z).y, (Z).x )\n#define conj(Z)     vec2( (Z).x, -(Z).y )\n#define cmul(A,B) ( mat2( A, -(A).y, (A).x ) * (B) )  // by deMoivre formula\n#define cinv(Z)   ( vec2( (Z).x, -(Z).y ) / dot(Z,Z) ) \n#define cdiv(A,B)   cmul( A, cinv(B) )\n//#define cpow(Z,v)   pol2cart( vec2( pow(cmod(Z),v) , (v) * carg(Z) ) )\n#define cpow(A,B)   cexp( cmul( B, clog(A) ) )\n#define cexp(Z)     pol2cart( vec2( exp((Z).x), (Z).y ) )\n#define clog(Z)     vec2( log(cmod(Z)), carg(Z) )\n\n\n// --- printing chars, integers and floats ---------------------------\n\n// --- access to the image of ascii code c\n\n// 2 implementations.\n// Use #if 1 for extensive text use (with no superimposition nor color-appearance change)\n\n#define IMMEDIATE_DRAW 0 \n\n#if IMMEDIATE_DRAW //  (allows for superimposition and appearance change).\n\nvec4 char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n    //if (p.x<.25|| p.x>.75 || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5); // strange bug with an old driver\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                        dFdx, dFdy );\n  // variants:\n  //float l = log2(length(fwidth(p/16.*iResolution.xy)));\n  //return textureLod( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), l);\n                   // manual MIPmap to avoid border artifact. Should be textureLod, but don't available everywhere\n}\n#  define draw_char() vec4(0)  // stub the final call function is used\n\n#else // Deferred draw (call draw_char() ). Run and compiles faster.\n      //     First only determine the valid char id at cur pixel \n      //     then call the draw char once at the end.\n\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \nvec4 char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n // if ( p.x>.25&& p.x<.75 && p.y>.0&& p.y<1. )  // normal char box\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) // thighly y-clamped to allow dense text\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\n    return vec4(0);\n}\nvec4 draw_char() {\n    int c = char_id; vec2 p = char_pos;\n    return c < 0 \n        ? vec4(0,0,0,1e5)\n        : textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                       dfdx, dfdy );\n}\n#endif\n\n// --- display int4\n#if 0\nvec4 pInt(vec2 p, float n) {  // webGL2 variant with dynamic size\n    vec4 v = vec4(0);\n    for (int i = int(n); i>0; i/=10, p.x += .5 )\n        v += char(p, 48+ i%10 );\n    return v;\n}\n#else\nvec4 pInt(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(p - vec2(-.5,0), 45 ),\n        n = -n;\n\n    for (float i = 3.; i>=0.; i--) \n        n /=  9.999999, // 10., // for windows :-(\n        v += char(p - .5*vec2(i,0), 48+ int(fract(n)*10.) );\n    return v;\n}\n#endif\n\n// --- display float4.4\nvec4 pFloat(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) v += char(p - vec2(-.5,0), 45 ), n = -n;\n    float upper = floor(n);\n    float lower = fract(n)*1e4 + .5;  // mla fix for rounding lost decimals\n    if (lower >= 1e4) { lower -= 1e4; upper++; }\n    v += pInt(p,upper); p.x -= 2.;\n    v += char(p, 46);   p.x -= .5;\n    v += pInt(p,lower);\n    return v;\n}\n\n// printing full IEEE floats (right or left justified): see https://www.shadertoy.com/view/7dfyRH , https://www.shadertoy.com/view/7sscz7\n\n// --- chars\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc O+= char(U,64+CAPS+c);\n// NB: use either char.x ( pixel mask ) or char.w ( distance field + 0.5 )\n\n// *** end copy\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // mainimage is invoked once per pixel.\n    // convert gl_FragCoord.xy (pixels) to the units you see on screen.\n    // rescale's vertical division is defined by zooms(), which calculates number of divisions of the octave.\n\n    // this calculates this pixel's color for the main interference graph.\n    // hop up to Derp() to see comments there\n    \n    // m: true when mouse is down\n    bool mousedown = sign(max(0., iMouse.z)) > 0.0;\n    vec2 mouse = mousedown ? iMouse.xy : vec2(0.0);\n    float mousex = max(0.0, (XSCALE*(mouse.x/resolution))-0.5);\n    \n    float mousezoom1 = zooms(floor(mousex), mousedown);\n    float mousezoom2 = zooms(ceil(mousex), mousedown);\n    \n    vec2 rs1 = rescale_factor(mousezoom1);\n    vec2 rs2 = rescale_factor(mousezoom2);\n    \n    vec3 col1 = Derp(gl_FragCoord.xy, 0.0, mousezoom1) * scaling(gl_FragCoord.xy, mouse, mousedown, mousezoom1);\n    vec3 col2 = Derp(gl_FragCoord.xy, 0.0, mousezoom2) * scaling(gl_FragCoord.xy, mouse, mousedown, mousezoom2);\n    float p = 0.8;\n    col1 = vec3(pow(col1.x, p), pow(col1.y, p), pow(col1.z, p));\n    col2 = vec3(pow(col2.x, p), pow(col2.y,p), pow(col2.z, p));\n    \n    col1 = grid(gl_FragCoord.xy, col1, mousezoom1);\n    col2 = grid(gl_FragCoord.xy, col2, mousezoom2);\n    \n    vec3 col = mix(col1, col2, fract(mousex));\n    \n    // *** begin copied\n    vec2 R = iResolution.xy, U;\n    vec2 uv = fragCoord;\n    uv /= R.y;\n    vec4 O = vec4(0.0);\n    // *** copied, but modified\n    U = ( uv - vec2(.0,.9) ) * 16.;  caps C(5) C(4) C(15) C(-6)  // \"Resol\"\n    U = ( uv - vec2(.1,.8) ) * 8.;        // --- column 1\n    O += pFloat((U-vec2(0.1,.35))*2.0, mousedown ? 12.+mousex : 12.);\n    //O += mix(pInt(U, mousezoom1), fract(mousex));  U.y += .8;   // window resolution\n\n    O += draw_char().xxxx;\n    // *** end copied\n\n    \n    // this replaces the pixel with the highlights of the grid lines if within about two pixels of a cell edge.\n\n    // and finally, this sets the pixel (well, pixel *fragment*, in case of antialiasing) color\n\tfragColor = vec4(col, 1.0 ) + (0.3 * O.xxxw);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// === standard  Main() ==========================\n\n//#define R    iResolution.xy\n#define T(U) texelFetch( iChannel0, ivec2(U), 0 )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y;\n\n    O = T(u);\n}","name":"Buffer A","description":"","type":"buffer"}]}