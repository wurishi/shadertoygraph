{"ver":"0.1","info":{"id":"WlsSWS","date":"1564116322","viewed":1717,"name":"Procedural walk animation","username":"TLC123","description":"Now I have to catch my bouncy head.\nMy head is like a ball \nand I lost it in a fall.\nIf I only could catch my bouncy head","likes":94,"published":1,"flags":64,"usePreview":0,"tags":["3d","animation","walkcycle","footsteps"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Mll3zX","filepath":"https://soundcloud.com/clynos2/funny-melody","previewfilepath":"https://soundcloud.com/clynos2/funny-melody","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Football\" by . https://shadertoy.com/view/llKcR3\n// 2019-07-25 21:23:38\n// Modified from https://www.shadertoy.com/view/Xds3zN by iq.\n//\n\n/*\n Some path funtion: timefly(t) returns a 2d pivot\n pasaR(t) and pasaL(t) modifies time to get \n initial foot targets when fead to timefly()\n \n*/\n\n#define AA 1\n# define PI 3.14159265359\n# define PHI 1.618033988749895\n# define TAU 6.283185307179586\nvec3 rightFoot;\nvec3 leftFoot;\nvec3 rightToe;\nvec3 leftToe;\nvec3 rightHand;\nvec3 leftHand;\nvec3 rightFootT;\nvec3 leftFootT;\nvec3 rightHandT;\nvec3 leftHandT;\nvec3 rightToeT;\nvec3 leftToeT;\nvec3 rightE; // Elbow\nvec3 leftE;\nvec3 rightK;//Knee\nvec3 leftK;\nvec3 rightH; //Hip\nvec3 leftH;\nvec3 rightS;// Shoulder\nvec3 leftS;\nvec3 pelvis;\nvec3 torso;\nvec3 head;\nvec3 target;\n\n\tfloat pasa = 1.; // steps overlaping airtime\n\tfloat legmax = .89; // max extention\n\tfloat leg = .89+0.005; // actual max length\n\tfloat armmax = .7;// max extention\n\tfloat arm = .7 +.012;// actual max length\n  \tfloat toemax = 1.1;// max extention toe from hip\n    float footlift=0.19; //lift height later multiplied by speed\n\n\n# define PLOTPATH 0\n \n\n//------------------------------------------------------------------\nfloat sdPlane(vec3 p) {\n\treturn p.y;\n}\nfloat sdSphere(vec3 p, float s) {\n\treturn length(p) - s;\n}\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba * h) - r;\n}\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat pathterrain(float x,float z){\n    // Common height function for path and terrain\n    return \n        sin(x*.5 )*1.+cos(z*.3 )*0.3\n        +cos(x*3.+z )*0.1+sin(x-z*.2 )*0.2\n        \n        ;}\n vec3 timefly(float t) {\n    // main path Called from many places\n    t*=.80;\n\tt += (.125 + sin(t * .125));\n\tvec3 v =\n\tvec3(sin(t / 50.) * 20., 0., cos(t / 25.) * 24.) +\n\t\tvec3(sin(t / 17.1) * 07., 0., cos(t / 17.1) * 05.) +\n\t\tvec3(sin(t / 8.1) * 6., 0., cos(t / 8.1) * 8.) +\n\t\tvec3(cos(t / 3.) * 3.,0., sin(t / 3.) * 2.)\n        +vec3(cos(t  )*2.,0., sin(t  )*2. );\n    v.y=pathterrain(v.x,v.z);\n    return v        ;\n} \nfloat pasaR(float x){\nreturn max(x + fract(x + 0.25) * pasa - pasa, floor(x + 0.25) - 0.25) + 0.25;\n    //gait function \n}\n    \nfloat pasaL(float x){\nreturn max(x + fract(x - 0.25) * pasa - pasa, floor(x - 0.25) + 0.25) + 0.25;\n   //gait function \n}\n\n\n\nfloat lpnorm(vec3 p, float s) {\n\treturn pow(\n\t\t(\n\t\t\tpow(abs(p.x), s) +\n\t\t\tpow(abs(p.y), s) +\n\t\t\tpow(abs(p.z), s)),\n\t\t1.0 / s);\n}\n\n \n//------------------------------------------------------------------\nvec2 opU(vec2 d1, vec2 d2) {\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp(.5 + .5*(a-b)/k, 0., 1.);\n\treturn mix(a, b, h) - k*h*(1.-h);\n}\nvec2 bodyPlan(vec3 pos) {\n\tfloat res;\n\tres =  sdSphere(pos - leftFoot, .07);\n\tres = min(res, sdSphere(pos - leftHand, .06));\n\tres = min(res, sdSphere(pos - leftH, .09));\n\tres = min(res, sdSphere(pos - leftK, .08));\n\tres = min(res, sdSphere(pos - leftE, .08));\n\tres = min(res, sdSphere(pos - leftS, .07));\t\n\n    \n\n    res = min(res, sdSphere(pos - rightFoot, .07));\n\tres = min(res, sdSphere(pos - rightHand, .06));\n\tres = min(res, sdSphere(pos - rightH, .09));\n\tres = min(res, sdSphere(pos - rightS, .07));\n\tres = min(res, sdSphere(pos - rightK, .08));\n\tres = min(res, sdSphere(pos - rightE, .08));\n    \n    \tres = min(res, sdSphere(pos - target, .2));\n\t//res = min(res, sdSphere(pos - head, .16));\n\n \t\n   \n\n    \n\n    \n    res = min(res, sdCapsule(pos ,rightToe,rightFoot, .06));\n    res = smin(res, sdRoundedCylinder(pos - rightToe, .04, .02, .03 ),0.06 );\n\n    res = min(res, sdCapsule(pos ,rightK,rightFoot, .06));\n    res = min(res, sdCapsule(pos ,rightK,rightH, .07));   \n    res = min(res, sdCapsule(pos ,rightE,rightHand, .05));\n    res = min(res, sdCapsule(pos ,rightE,rightS, .06));\n    res = min(res, sdCapsule(pos ,torso,rightS, .08));\n    \n    res = min(res, sdCapsule(pos ,leftToe,leftFoot, .06));\n    res = smin(res, sdRoundedCylinder(pos - leftToe, .04, .02, .03 ),0.06);// todo rotate to grund normal\n\n    res = min(res, sdCapsule(pos ,leftK,leftFoot, .06));\n    res = min(res, sdCapsule(pos ,leftK,leftH, .07));   \n    res = min(res, sdCapsule(pos ,leftE,leftHand, .05));\n    res = min(res, sdCapsule(pos ,leftE,leftS, .06));\n    res = min(res, sdCapsule(pos ,torso,leftS, .08));\n    \n    res = smin(res, sdSphere(pos - torso, .14),0.025);\n    res = smin(res, sdSphere(pos - pelvis, .16),0.025);\n    \n    res = smin(res, sdCapsule(pos ,pelvis,torso, .13),0.025);\n\tres = min(res, sdCapsule(pos ,head,torso, .02)); \n    \n    \n    \n    if(PLOTPATH>0)for(int i=PLOTPATH;i>-PLOTPATH/2;i--)\n\n    {\n        res = min(res, sdSphere(pos- timefly(iTime+float(i)*0.5), .04));\n    \n       \n        \n}  \n  \n        \n \n    \n     //float x=iTime;\n\t // res= min(res, sdCapsule( pos, timefly(x),timefly(x+1.) , .06125));\n\t // res= min(res, sdCapsule( pos, timefly(x)-perpr*-0.25,timefly(x)-perpl*0.25 , .06125));\n\treturn vec2(res, 2.0);\n}\nvec2 map( in vec3 pos) {\n\tvec2 res = vec2(pos.y-pathterrain(pos.x,pos.z), 1.0);\n\tres = opU(res, bodyPlan(pos));\n\treturn res;\n}\nvec2 castRay( in vec3 ro, in vec3 rd) {\n\tfloat tmin = 1.0;\n\tfloat tmax = 30.0;\n\tfloat t = tmin;\n\tfloat m = -1.0;\n\tfor (int i = 0; i < 80; i++) {\n\t\tfloat precis = 0.0001 * t;\n\t\tvec2 res = map(ro + rd * t);\n\t\tif (res.x < precis || t > tmax) break;\n\t\tt += res.x * .7;\n\t\tm = res.y;\n\t}\n\tif (t > tmax) m = -1.0;\n\treturn vec2(t, m);\n}\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax) {\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor (int i = 0; i < 32; i++) {\n\t\tfloat h = map(ro + rd * t).x;\n\t\tres = min(res, 8.0 * h / t);\n\t\tt += clamp(h, 0.02, 0.10);\n\t\tif (res < 0.005 || t > tmax) break;\n\t}\n\treturn clamp(res, 0.0, 1.0);\n}\nvec3 calcNormal( in vec3 pos) {\n\tvec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n\treturn normalize(e.xyy * map(pos + e.xyy).x +\n\t\te.yyx * map(pos + e.yyx).x +\n\t\te.yxy * map(pos + e.yxy).x +\n\t\te.xxx * map(pos + e.xxx).x);\n}\nfloat calcAO( in vec3 pos, in vec3 nor) {\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\tfor (int i = 0; i < 5; i++) {\n\t\tfloat hr = 0.01 + 0.12 * float(i) / 4.0;\n\t\tvec3 aopos = nor * hr + pos;\n\t\tfloat dd = map(aopos).x;\n\t\tocc += -(dd - hr) * sca;\n\t\tsca *= 0.95;\n\t}\n\treturn clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n// https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox2( in vec2 p) {\n\t// filter kernel\n\tvec2 w = fwidth(p) + 0.001;\n\t// analytical integral (box filter)\n\tvec2 i = 2.0 * (abs(fract((p - 0.5 * w) * 0.5) - 0.5) - abs(fract((p + 0.5 * w) * 0.5) - 0.5)) / w;\n\t// xor pattern\n\treturn 0.5 - 0.5 * i.x * i.y;\n}\nfloat checkersGradBox( in vec2 p) {\n \n\treturn  checkersGradBox2(p) -checkersGradBox2(p-0.03 )*0.4 ;\n}\nvec3 render( in vec3 ro, in vec3 rd) {\n\tvec3 col = vec3(0.7, 0.9, 1.0) + rd.y * 0.8;\n\tvec2 res = castRay(ro, rd);\n\tfloat t = res.x;\n\tfloat m = res.y;\n\tif (m > -0.5) {\n\t\tvec3 pos = ro + t * rd;\n\t\tvec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect(rd, nor);\n\t\t// material        \n\t\tcol = 0.45 + 0.35 * sin(vec3(0.05, 0.08, 0.10) * (m - 1.0));\n\t\tif (m < 1.5) {\n\t\t\tfloat f = checkersGradBox(1.2 * pos.xz);\n\t\t\tcol = 0.3 + f * vec3(0.3);\n\t\t}\n\t\tif (m >= 2.0) {\n\t\t\tcol = vec3(0.6);\n\t\t}\n\t\tif (m >= 3.0) {\n\t\t\tcol = vec3(0.07);\n\t\t}\n\t\t// lighting        \n\t\tfloat occ = calcAO(pos, nor);\n\t\tvec3 lig = normalize(vec3(0.2, 0.7, 0.6));\n\t\tvec3 hal = normalize(lig - rd);\n\t\tfloat amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n\t\tfloat dif = clamp(dot(nor, lig), 0.0, 1.0);\n\t\tfloat bac = clamp(dot(nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0) * clamp(1.0 - pos.y, 0.0, 1.0);\n\t\tfloat dom = smoothstep(-0.1, 0.1, ref.y);\n\t\tfloat fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n\t\tdif *= calcSoftshadow(pos, lig, 0.02, 2.5);\n\t\tdom *= calcSoftshadow(pos, ref, 0.02, 2.5);\n\t\tfloat spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 16.0) *\n\t\t\tdif *\n\t\t\t(0.04 + 0.96 * pow(clamp(1.0 + dot(hal, rd), 0.0, 1.0), 5.0));\n\t\tvec3 lin = vec3(0.0);\n\t\tlin += 1.30 * dif * vec3(1.00, 0.80, 0.55);\n\t\tlin += 0.20 * amb * vec3(0.40, 0.60, 1.00) * occ;\n\t\tlin += 0.20 * dom * vec3(0.40, 0.60, 1.00) * occ;\n\t\tlin += 0.30 * bac * vec3(0.25, 0.25, 0.25) * occ;\n\t\tlin += 0.35 * fre * vec3(1.00, 1.00, 1.00) * occ;\n\t\tcol = col * lin;\n\t\tcol += 10.00 * spe * vec3(1.00, 0.90, 0.70);\n\t\tcol = mix(col, vec3(0.8, 0.9, 1.0), 1.0 - exp(-0.0002 * t * t * t));\n\t}\n\treturn vec3(clamp(col, 0.0, 1.0));\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr) {\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\treturn mat3(cu, cv, cw);\n}\n\n\n\n\n\nvoid setup() {\n\tfloat x = iTime   ;//Time manipulations moved to timefly\n      \n    \n    // filter gait slightly for less stabby foot placement, too much generates skating\n    float filt=18.;\n\tfloat left = 0.025+ mix(pasaR(floor(x*filt)/filt) ,pasaR(ceil(x*filt)/filt), ( fract(x*filt)));\n\tfloat right =0.025+ mix(pasaL(floor(x*filt)/filt) ,pasaL(ceil(x*filt)/filt), ( fract(x*filt)));\n\t\n    \n    float ahead=1.1;\n    vec3 dif = (timefly(x + ahead) - timefly(x))/ahead; //delta x+1\n\tfloat speed = length(dif); \n     ahead = clamp(0.8,1.1,1.3-speed);\n     dif = (timefly(x + ahead) - timefly(x))/ahead; //delta x+1\n\t speed = length(dif); \n    \n    \n    \n    vec3 nextdif = (timefly(x + ahead+.5) - timefly(x + .5))/ahead; \n\tvec3 lean = (nextdif - dif*2.); // bank into turns\n\n    //\n      ahead=speed;\n      dif = (timefly(x + ahead) - timefly(x))/ahead; //delta x+1\n\t  nextdif = (timefly(x + ahead+.5) - timefly(x + .5))/ahead; \n\t  lean = (nextdif - dif*2.); // bank into turns\n\n     \n    \n\tfloat nextSpeed = length(timefly(x + 1.2) - timefly(x + .2));\n   \n\n\n    vec3 dir = normalize(dif); //Path direction \n    vec3 nextdir = normalize(nextdif); //Path direction \n\tvec3 dirr = normalize(timefly(right + 1.) - timefly(right)); //Path direction Foot specific\n\tvec3 dirl = normalize(timefly(left + 1.) - timefly(left));\n    \n\tvec3 perp = cross(dir,vec3(0,-1,0));// perpendicular to main path\n\tvec3 perpl = cross(dirl,vec3(0,-1,0));// perpendicular to intervalled step path\n\tvec3 perpr = cross(dirr,vec3(0,-1,0));\n    \n    target =(timefly(x+1.5))\n               \n            +(vec3(0,.4,0)+lean*1.6+dir*0.25 )*(.09/clamp(speed , 0.05, 4.5));// rolling head\n\n       \n    target.y=pathterrain(target.x,target.z);// fix for rolling head collision \n    \n    target +=\n        +( vec3(0,0.14+abs(sin(x*7.)*0.3),0)) ;\n  \n      \n    vec3 tfx= timefly(x)  ; // Pelvis   path\n    vec3 tfr= timefly(right) ;//intervalled step path\n    vec3 tfl= timefly(left) ; //intervalled step path\n    \n    // foot lift component\n\tvec3 leftlift = vec3(0, min(0., sin(x * TAU + 1.57) * footlift * clamp(speed, 0.05, 1.5)), 0);\n\tvec3 rightlift = vec3(0, min(0., sin(x * TAU - 1.57) * footlift * clamp(speed, 0.05, 1.5)), 0);\n \n    \n    // setup targets\n\trightFootT = tfr + perpr * -0.16 - rightlift;\n\tleftFootT = tfl + perpl * 0.16 - leftlift;\n    rightToeT = tfr  + perpr * -0.19  +dir*0.172 - rightlift*0.6;\n\tleftToeT = tfl  + perpl * 0.19  +dir*0.172- leftlift*0.7;\n    // ground collision feet and toes\n    rightFootT.y=max(pathterrain(rightFootT.x,rightFootT.z),    rightFootT.y);\n    leftFootT.y=max(pathterrain(leftFootT.x,leftFootT.z),    leftFootT.y);\n    rightToeT.y=max(pathterrain(rightToeT.x,rightToeT.z),    rightToeT.y);\n    leftToeT.y=max(pathterrain(leftToeT.x,leftToeT.z),    leftToeT.y);\n    \n    \n\n    \n    \n\tpelvis = tfx \n        + (lean  ) * clamp(nextSpeed, 0.01, .5) * 0.1 // lean into turn\n        + vec3(0, .9 + cos(x * TAU * 2.) * 0.02 * speed, 0) // bob u/d with step\n\t\t+ dir * 0.1 * (-0.45 + speed) // lean in to run\n\t\t+ perpr * sin(x * TAU) * 0.025 * speed // bob l/R with step\n \t\t+ (vec3(0,-1.,0) )*(.02/clamp(speed , 0.15, 4.5))// bend when head is close\n;\n    // spine component\n\tvec3 spine = normalize(\n\t\t (lean  ) * clamp(nextSpeed, 0.2, .5) * 0.1 // lean into turn\n\t\t+ vec3(0, 0.3 + cos(x * TAU * 2.) * 0.0125 * speed, 0)// bob u/d with step\n\t\t+ dir * 0.05 * (-0.25 + nextSpeed)  // lean in to run\n        +(vec3(0,-1.,0)+dir)*(.05/clamp(speed , 0.15, 4.5))// bend when head is close\n        + perpr * cos(x * TAU) * 0.025 * speed// bob l/R with step\n\t);\n     \n    torso = pelvis + spine * 0.3;\n    \n    \n\n\t// Hips\n    rightH = pelvis + perp * -0.11 - rightlift * 0.1 - spine * 0.08 + dir * -0.025;\n\tleftH = pelvis + perp * 0.11 - leftlift * 0.1 - spine * 0.08 + dir * -0.025;\n    \n    // Feet\n\trightFoot = rightH + normalize(rightFootT - rightH) * min(legmax, length(rightFootT - rightH));\n\tleftFoot = leftH + normalize(leftFootT - leftH) * min(legmax, length(leftFootT - leftH));\n\t\n    rightToe = rightH + normalize(rightToeT - rightH) * min(toemax, length(rightToeT - rightH));\n\tleftToe = leftH + normalize(leftToeT - leftH) * min(toemax, length(leftToeT - leftH));\n    \n    // Shoulder\n\trightS = torso + perp * -0.2   + spine * 0.05;\n\tleftS = torso + perp * 0.2  + spine * 0.05;\n    \n    // Hand Target\n    rightHandT=(rightS +  normalize(\n\t\t\t+perpr * -0.06 \n\t\t\t+vec3(0, -0.4, 0) \n\t\t\t+dir * 0.3 * cos(.25 + x * TAU) * (clamp(speed, 0.0, 2.) * 0.25)\n \t\t\t) \n            * armmax \n\t\t\t+vec3(0, 0.2, 0) * clamp(speed - 0.6, 0., 1.) )// lift alittle with speed\n        \t+( target -rightS)*(1.-smoothstep(0.,1.2,(1.+sin(x*1. ))))*0.3;// reach for head \n    \n     leftHandT= (leftS + normalize(\n\t\t\tperpl * 0.06 +\n\t\t\tvec3(0, -0.4, 0) +\n\t\t\tdir * 0.3 * cos(.25 + PI + x * TAU) * (clamp(speed, 0.0, 2.) * 0.25)\n \t\t) * armmax +\n\t\tvec3(0, 0.2, 0) * clamp(speed - 0.6, 0., 1.))\n       +( target -leftS)*(1.-smoothstep(0.,1.2,(1.+sin(x*1.+PI))))*0.3;\n    \n       rightHand = rightS + normalize(rightHandT - rightS) * min(armmax, length(rightHandT - rightS));\n       leftHand = leftS + normalize(leftHandT - leftS) * min(armmax, length(leftHandT - leftS));\n \t\n     \n        rightHand.y=max(pathterrain(rightHand.x,rightHand.z)+.2,    rightHand.y);\n    leftHand.y=max(pathterrain(leftHand.x,leftHand.z)+.2,    leftHand.y);\n \n    \n    \n\thead = torso +normalize(\n\t\tvec3(0, .27, 0) \n\t\t+ normalize(lean) * clamp(nextSpeed, 0.2, 1.) * 0.05 // lean into torn\n\t\t+dir * 0.1 * (-0.35 + clamp(speed, 0.5, 2.)) // lean into run\n\t\t+perpr * cos(x * TAU) * 0.025 * clamp(speed, 0.5, 2.)\n        +(vec3(0,-1.,0)+dir)*(.07/clamp(speed , 0.05, 4.5))// bend when head is close\n\n       )*0.27;// sway with step\n    \n    // bendy lims IK\n    \n\trightE = mix(rightS, rightHand, 0.5) - cross(rightS - rightHand, -normalize(perp - dir * 0.5)) *\n\t\tsqrt(max(0.0001, arm * arm - length(rightS - rightHand) * length(rightS - rightHand))) * 0.5;\n\tleftE = mix(leftS, leftHand, 0.5) - cross(leftS - leftHand, -normalize(perp + dir * 0.5)) *\n\t\tsqrt(max(0.0001, arm * arm - length(leftS - leftHand) * length(leftS - leftHand))) * 0.5;\n\trightK = mix(rightH, rightFoot, 0.5) - cross(rightH - rightFoot, normalize(perp + dir * 0.25)) *\n\t\tsqrt(max(0.0001, leg * leg - length(rightH - rightFoot) * length(rightH - rightFoot))) * 0.5;\n\tleftK = mix(leftH, leftFoot, 0.5) - cross(leftH - leftFoot, normalize(perp - dir * 0.25)) *\n\t\tsqrt(max(0.0001, leg * leg - length(leftH - leftFoot) * length(leftH - leftFoot))) * 0.5;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tsetup();\n\tvec2 mo = iMouse.xy / iResolution.xy;\n\tfloat time = .0 + iTime;\n\tvec3 tot = vec3(0.0);\n #\tif AA > 1\n\tfor (int m = 0; m < AA; m++)\n\t\tfor (int n = 0; n < AA; n++) {\n\t\t\t// pixel coordinates\n\t\t\tvec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n\t\t\tvec2 p = (-iResolution.xy + 2.0 * (fragCoord + o)) / iResolution.y;\n # else\n\t\t\t\tvec2 p = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n # endif\n\t\t\t// camera\t\n\t\t\tvec3 ta = timefly(time) + vec3(0, 0.7, 0);\n\t\t\tvec3 ro = ta + vec3(-0.5 + 3.5 * cos(0.1 * time + 6.0 * mo.x),\n\t\t\t\t2.0 + 2.0 * mo.y,\n\t\t\t\t0.5 + 4.0 * sin(0.1 * time + 6.0 * mo.x));\n\t\t\t// camera-to-world transformation\n\t\t\tmat3 ca = setCamera(ro, ta, 0.0);\n\t\t\t// ray direction\n\t\t\tvec3 rd = ca * normalize(vec3(p.xy, 2.5));\n\t\t\t// render\t\n\t\t\tvec3 col = render(ro, rd);\n\t\t\t// gamma\n\t\t\tcol = pow(col, vec3(0.4545));\n\t\t\ttot += col;\n # if AA > 1\n\t\t}\n\ttot /= float(AA * AA);\n #\tendif\n\tfragColor = vec4(tot, 1.0);\n}","name":"Image","description":"","type":"image"}]}