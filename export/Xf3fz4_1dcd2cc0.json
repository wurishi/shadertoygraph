{"ver":"0.1","info":{"id":"Xf3fz4","date":"1732743600","viewed":106,"name":"Confuse hearts","username":"Elsio","description":"estudando...","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","heart","extrude"],"hasliked":0,"parentid":"ddSXR1","parentname":"Extruded Neon Hearts"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define h21(p) fract(sin(dot(p, vec2(27.617, 57.643))) * 43758.5453)\n#define rot(a) mat2(cos(a + vec4(0, 1, 3, 0) * pi / 2.))\n#define tau (2. * pi)\n#define t iTime\n#define FAR 20.\n#define pi acos(-1.)\n\nvec2 hex = vec2(1, sqrt(3.));\n\nfloat sdHex(vec2 p, float n) {\n    vec2 k = sqrt(vec2(7, 3));\n    float r = n / k.x / 2.;\n    vec3 H = vec3(.5, - .866, .577 * r);\n    if(n == 1.) \n        p -= vec2(3. / k.x / k.y, 0),\n        p *= rot(pi / 6.);\n    p = abs(p);\n    p -= 2. * min(dot(H.xy, p), 0.) * H.xy;\n    return length(p - vec2(r, clamp(p.y, -H.z, H.z)))\n            * sign(p.x - r);\n}\n\nfloat sdTri(vec2 p, float s) {\n    p *= rot(pi / 6.) * s;\n    vec2 k = sqrt(vec2(7, 3));\n    float b = -3. / k.x / k.y;\n    \n    p.x = abs(p.x) + b;\n    p.y += 1. / k.x;\n    \n    if(p.x + k.y * p.y > 0.) \n        p = (p * vec2(1, -1) - k.y * p.yx) / 2.;\n            \n    p.x -= clamp(p.x, 2. * b, 0.);\n    return -length(p) * sign(p.y);\n}\n\nfloat hm(vec2 p) {\n    float h = cos(\n                  dot(\n                      cos(p * .05 - t * 1.2),\n                      sin(p.yx * .03 - t * 1.)\n                  ) * pi\n              ) * .05 + .1;\n              \n    float h2 = cos(\n                   length(\n                       cos(p * .06 + sin(p.yx * .07 - t * .1))\n                   ) * 4.\n               );\n    \n    h2 = tanh(h2 * 6. - 3.);\n    \n    return max(h2, h);\n}\n\n\nfloat opExtrusion(vec3 p, float d, float h) {\n    vec2 b = vec2(d + .02, abs(p.z + h) - h);\n    return min(max(b.x, b.y), 0.) + length(max(b, 0.));\n}\n\nfloat wallDetail(vec3 p, float h){\n    return smoothstep(.0, .1,\n             abs(\n                 fract(  // wall detail\n                     (p.z + h) * 6.\n                 ) - .5\n             ) - .1\n         ) * -.015;\n}\n\nfloat piece(vec3 p, float d, vec2 id) {\n    float h = hm(id);\n    float d2 = max(d, -d - .12); // hole\n    \n    d = opExtrusion(p, d2, h);\n    d += wallDetail(p, h);\n    \n    d += max(d2, -.06) * .4; // top detail\n\n    return d;\n}\n\nvoid grid(vec2 p, out vec2 q, out vec2 id) {\n    vec2 A = mod(p           , hex) - hex / 2.;\n    vec2 B = mod(p - hex / 2., hex) - hex / 2.;\n    \n    q = A;\n    id = floor(p / hex) * 12.;\n    if(dot(A, A) > dot(B, B)){\n        q = B;\n        id = floor(p / hex - .5) * 12. + 6.;\n    }\n    \n    // shane prefere grids rotacionadas\n    // um dia vou entender pq \n    q *= rot(-atan(sqrt(3.) / 5.));\n}\n\n\nvec2 polRot(vec2 p, inout int na) {\n    float a = atan(p.y, p.x) / tau;\n    //na = int(a * 6.) % 6;              // pq não??\n    //na = int(floor(a * 6.)) % 6;       // pq não???\n    na = int(mod(floor(a * 6.), 6.));\n\n    return p * rot(-tau * (float(na) + .5) / 6.);\n}\n\nfloat distLine(vec2 q, vec2 id, int i){\n    vec2[] vID = \n               vec2[](\n                   vec2(2, -6), vec2(-2, -6), \n                   vec2(-4, 0), vec2(-2, 6),\n                   vec2(2, 6), vec2(4, 0)\n               );\n    i = i * 2 \n        + int(h21(id) * 36.) % 2; // why ???\n    \n    vec2 k = vID[i % 6] * hex.yx;\n             \n    return dot(q, k) * sqrt(3.) / 12.;\n}\n\nfloat sdHeart(vec2 q, int i, vec2 id){\n    return\n        max(\n            max(\n                min(\n                    sdTri(q, 1.), \n                    sdTri(q, -1.)\n                ), \n                sdHex(q, 3.)\n            ), \n\n            max(\n                distLine(q, id, i), \n                -distLine(q, id, i + 1)\n            )\n            \n        );\n}\n\n\nfloat confuseUgaBuga(vec3 p, vec2 q, vec2 id){\n    vec2[] eID = vec2[](\n                      vec2(-12, 0),  // Unfortunately, \"1. - 1./3.\" \n                      vec2(-6, 6),   // is not always the same as \"2./3.\" on a GPU.\n                      vec2(6, 6),    // but 12 - 4 is always 8\n                      vec2(12, 0),   //                                 -- @shane\n                      vec2(6, -6),   \n                      vec2(-6, -6)\n                  );\n\n    int na;\n    float hx = sdHex(polRot(q, na), 1.);\n\n    vec2 k = eID[(8 - na) % 6];\n    \n    vec2 confuse = \n            - eID[\n                    (\n                        7 - (\n                                (\n                                    int(h21(id + k) * 36.) % 2 + na // why?  :( \n                                ) / 2\n                            ) * 2\n                    ) % 6\n              ] \n            ;\n\n    float d = 1e5;\n    for(int i; i < 3; i++) \n        d = min(\n                d, \n                piece(\n                    p, \n                    sdHeart(q, i, id), \n                    eID[i + i] / sqrt(7.) + id\n                )\n            );\n    \n    \n    return min(d, piece(p, hx, confuse / sqrt(7.) + id + k));\n}\n\nfloat map(vec3 p) {\n    vec2 k, q, id;\n    grid(p.xy, q, id);\n    \n    return confuseUgaBuga(p, q, id);\n}\n\nfloat march(vec3 ro, vec3 rd) {\n    float t, d;\n    \n    for(int i; i < 120; i ++) {\n        d = map(ro + rd * t);\n        \n        if(abs(d) < .001 || t > FAR) break;\n        t += min(d, .1);\n    }\n    \n    return min(t, FAR);\n}\n\nvec3 normal(vec3 p) {\n    vec3 e = vec3(.01, 0, 0);\n    vec3 v = vec3(\n                 map(p - e.xyy),\n                 map(p - e.yxy),\n                 map(p - e.yyx)\n             ) - map(p);\n    return normalize(-v);\n}\n\nfloat AO(vec3 p, vec3 n) {\n    float sca = 3., occ, hr, s, i;\n    \n    while(i < 4.) {\n        hr = i * .03 + .03;\n        s = map(p + n * hr);\n        occ += (hr - s) * sca;\n        sca *= .6;\n        i++;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n\nvoid mainImage(out vec4 o, vec2 u) {\n    vec2 r = iResolution.xy;\n    u = (u + u - r) / r.y;\n    \n    vec3 D = normalize(vec3(u, 3)),\n         p = vec3(.1, -4., -3.2);\n\n    //if(false) // stop the cam\n        D.yz = rot(.9) * D.yz,\n        p.xy *= rot(cos(t * .3)),\n        D.xy *= rot(tanh(cos(t * .1) * 6. - 4.));\n    \n    float d = march(p, D);\n    \n    o = vec4(0);\n    if(d < FAR) {\n        vec3 p = p + d * D,\n             N = normal(p),\n             ref = reflect(D, N);\n        \n        vec4 alb = vec4(1);\n        float diff = length(sin(ref) * .5 - .43),\n              spec = pow(diff * .9, 25.) * .06;\n        \n        o = (alb * diff * .6 + spec) * AO(p, normalize(N)) * .4;\n        o = pow(o, vec4(.45)) * (1.2 - 2. * d / FAR) * 2.;\n    }\n}","name":"Image","description":"","type":"image"}]}