{"ver":"0.1","info":{"id":"3stGRM","date":"1568098673","viewed":151,"name":"Wavepool","username":"FreddyDoll","description":"A Wave Pool Simulation\nClick to disturb","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["simulation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0,uv);\n    fragColor.r *= 1.0; //Position\n    fragColor.g *= 5.0; //Velocity\n    fragColor.b *= 10.0; //Acceleration\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.141592\n#define SQRT2 1.4142135\n\n//Field properties\nconst float stiffness = 0.1;\nconst float damping = 0.995;\n\n//for all emitter types\nconst float frequency = 100.0;\nconst float amplitude = 3.0;\n\n\n//Central emitter with selectable nr of poles\n//set MULTIPOLE_EMMITERS to 0 to disable\n//MULTIPOLE_EMMITERS must be uint(0,1,2,3,4,5,6...)\nconst int MULTIPOLE_EMMITERS=6;\nconst float poles = float(MULTIPOLE_EMMITERS)/2.0;\n\n\n//Line Emitter at the bottom set LINE_EMITTER_NUM to 0 to remove\n#define LINE_EMITTER_NUM 2\n#define LINE_EMITTER_LEN 0.04\n#define LINE_EMITTER_DIST 0.02\n\nfloat extractPosition(vec2 uv)\n{\n    return texture(iChannel0,uv).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat stepx = 1.0/iResolution.x;\n\tfloat stepy = 1.0/iResolution.y;\n    float aspect = iResolution.x/iResolution.y;\n    \n    vec3 val = texture(iChannel0,uv).rgb;\n    \n    //neigbour difference\n    float diff = 0.0;\n    diff+=extractPosition(uv+vec2(stepx,0))-val.x;\n    diff+=extractPosition(uv+vec2(0,stepy))-val.x;\n    diff+=extractPosition(uv+vec2(-stepx,0))-val.x;\n    diff+=extractPosition(uv+vec2(0,-stepy))-val.x;\n    \n    diff+=(extractPosition(uv+vec2(stepx,stepy))-val.x) / SQRT2;\n    diff+=(extractPosition(uv+vec2(-stepx,stepy))-val.x) / SQRT2;\n    diff+=(extractPosition(uv+vec2(stepx,-stepy))-val.x) / SQRT2;\n    diff+=(extractPosition(uv+vec2(-stepx,-stepy))-val.x) / SQRT2;\n    \n    //integration\n    val.z = diff*stiffness;\n    val.y += val.z;\n    val.y *= damping;\n    val.x += val.y;\n    fragColor = vec4(val,1);\n    \n    //Minimum radius to get one pixel\n    float emmitterR = 1.0/iResolution.y;\n    \n    //Line Emitters\n    float xLine = 0.5-LINE_EMITTER_LEN*float(LINE_EMITTER_NUM)/2.0 - LINE_EMITTER_DIST*float(LINE_EMITTER_NUM-1)/2.0;\n    for(int n=0;n<LINE_EMITTER_NUM;n++)\n    {\n        if(2.0*abs(uv.x-xLine-LINE_EMITTER_LEN/2.0)<LINE_EMITTER_LEN && uv.y<emmitterR)\n            fragColor = vec4(amplitude*sin(frequency*iTime/2.0/PI)*0.5+1.0,0.0,0.0,0.0);\n        xLine+=LINE_EMITTER_LEN+LINE_EMITTER_DIST;\n    }\n    \n    //Multipole Emitters\n    if(MULTIPOLE_EMMITERS>0)\n    {\n        float phaseStep = 2.0 * PI * poles / float(MULTIPOLE_EMMITERS);\n        float poleStep = 2.0 * PI / float(MULTIPOLE_EMMITERS);\n\n        float currPole = 0.0;\n        float currPhase = 0.0;\n\n        uv.y /= aspect;\n\n        float radiusPoles = float(MULTIPOLE_EMMITERS)*emmitterR/2.0;\n\n        for(int n = 0;n<MULTIPOLE_EMMITERS;n++)\n        {\n            vec2 center = radiusPoles*vec2(sin(currPole),cos(currPole)) + vec2(0.5,0.5/aspect);\n            if(length(uv-center)<emmitterR)\n                fragColor = vec4(amplitude*sin(frequency*iTime/2.0/PI+currPhase)*0.5+1.0,0.0,0.0,0.0);\n            currPole += poleStep;\n            currPhase +=  phaseStep;\n        }\n    }\n        \n    \n    //Mouse\n    vec2 p = fragCoord.xy / iResolution.xx;\n    vec4 m = iMouse / iResolution.xxxx;\n    \n    if(m.z>0.0 && length( m.xy- p ) < emmitterR)\n        fragColor = vec4(0.0,1.0,0.0,1.0);    \n}","name":"Buffer A","description":"","type":"buffer"}]}