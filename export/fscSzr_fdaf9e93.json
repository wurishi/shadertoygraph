{"ver":"0.1","info":{"id":"fscSzr","date":"1632468809","viewed":139,"name":"Worley Noise Functions","username":"VitaleMarco","description":"My approach of a 2D and 3D Worley Noise\nFeedback is very welcome","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["noise","fbm","worley"],"hasliked":0,"parentid":"NsV3Wt","parentname":"Perlin Noise Functions"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//WORLEY NOISES GET CREATED BY CALCULATING THE DISTANCES OF RANDOM SCATTERED POINTS\n//ONE APPROACH IS TO STORE ALL POINTS INTO AN ARRAY AND LOOP THROUGH ALL THE POINTS\n//TO FIND THE MINIMUM DISTANCES. THIS WOULD BE A LITTLE HEAVY TO COMPUTE, BUT WOULD WORK JUST FINE\n\n//THIS APPROACH (I BELIEVE THIS IS HOW IT'S DONE IN MOST IMPLEMENTATIONS) CREATES A GRID OF\n//CELLS AND SCATTERS THE POINTS RANDOMLY WITHIN THEIR CORRESPONDING CELL, THE ADVANTAGE IS,\n//THAT WE KNOW A ROUGH POSITION OF THAT POINT (IT HAS TO BE SOMEWHERE IN THAT CELL).\n\n//WITH THAT IN MIND WE ONLY HAVE TO CALCULATE THE DISTANCES OF EIGHT NEIGHBOURS AND KEEP THE MINIMUM\n//(INSTEAD LOOPING THROUGH HUNDREDS OR THOUSENDS OF POINTS)\n\n//     A     B     C     D     E     FOR EXAMPLE WE ARE IN CELL C3 AND WANT TO CALCULATE OUR DISTANCES\n//  |-----|-----|-----|-----|-----|  WE KNOW THAT WE ONLY HAVE TO CALCULATE THE DISTANCES FOR THE DIRECT\n// 1| x   |     |  x  |     |  x  |  NEIGHBOURS (B2, C2, D2, B3, D3, B4, C4, D4) THAT KEEPS\n//  |     |   x |     | x   |     |\n//  |-----|-----|-----|-----|-----|\n// 2|     |     |     |     |    x|\n//  |  x  | x   |  x  |   x |     |\n//  |-----|-----|-----|-----|-----|\n// 3|     |    x|     |     |     |\n//  |   x |     |x    | x   |   x |\n//  |-----|-----|-----|-----|-----|\n// 4|     | x   |    x|  x  | x   |\n//  |x    |     |     |     |     |\n//  |-----|-----|-----|-----|-----|\n// 5|     |  x  |     |     |    x|\n//  |  x  |     | x   |x    |     |\n//  |-----|-----|-----|-----|-----|\n\n//FOR THE 3D WORLEY-NOISE IT'S THE SAME APPROACH, BUT WE HAVE TO CHECK 26 NEIGHBOURS (STILL VERY EFFICIENT) \n\n//THE NOISE GETS A BLOBBY SHAPE IF WE INVERT IT\n#define RETURN_WORLEY m_dist;\n//#define RETURN_WORLEY 1.0 - m_dist; //UNCOMMENT TO INVERT THE OUTPUT OF THE NOISE\n\n//WORLEY NOISES\nfloat worleyNoise2D(vec2 uv, vec2 scale, vec2 offset){\n    //APPLY SCALE\n    uv *= scale;\n    \n    //APPLY OFFSET\n    uv += offset;\n\n    //TILE THE SPACE INTO CELLS\n    vec2 floor_uv = floor(uv);\n    vec2 fract_uv = fract(uv);\n\n    //INITIAL DISTANCE\n    float m_dist = 1.0;\n\n    //LOOP THROUGH ALL THE NEIGHBOUR CELLS\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            //GET THE NEIGHBOUR CELL IN THE GRID\n            vec2 neighbor = vec2(x, y);\n\n            //GET THE POSITION OF THE CURRENT CELL AND THE NEIGHBOUR\n            vec2 point = rand2dTo2d(floor_uv + neighbor);\n\n\t\t\t//GET THE VECTOR BETWEEN THE CELLS\n            vec2 diff = neighbor + point - fract_uv;\n\n            //CALCULATE THE DISTANCE BETWEEN THE NEIGHBOUR AND THE CURRENT POINT\n            float dist = length(diff);\n\n            //KEEP THE CLOSER DISTANCE\n            m_dist = min(m_dist, dist);\n        }\n    }\n\n    //RETURN THE MINIMUM DISTANCE\n    return RETURN_WORLEY\n}\n\nfloat worleyNoise3D(vec3 pos, vec3 scale, vec3 offset){\n    //APPLY SCALE\n    pos *= scale;\n    \n    //APPLY OFFSET\n    pos += offset;\n\n    //TILE THE SPACE INTO CELLS\n    vec3 floor_pos = floor(pos);\n    vec3 fract_pos = fract(pos);\n\n    //INITIAL DISTANCE\n    float m_dist = 1.0;\n\n    //LOOP THROUGH ALL THE NEIGHBOUR CELLS\n    for (int z = -1; z <= 1; z++) {\n        for (int y= -1; y <= 1; y++) {\n            for (int x= -1; x <= 1; x++) {\n                //GET THE NEIGHBOUR CELL IN THE GRID\n                vec3 neighbor = vec3(x, y, z);\n\n                //GET THE POSITION OF THE CURRENT CELL AND THE NEIGHBOUR\n                vec3 point = rand3dTo3d(floor_pos + neighbor);\n\n                //GET THE VECTOR BETWEEN THE CELLS\n                vec3 diff = neighbor + point - fract_pos;\n\n                //CALCULATE THE DISTANCE BETWEEN THE NEIGHBOUR AND THE CURRENT POINT\n                float dist = length(diff);\n\n                //KEEP THE CLOSER DISTANCE\n                m_dist = min(m_dist, dist);\n            }\n        }\n    }\n    //RETURN THE MINIMUM DISTANCE\n    return RETURN_WORLEY\n}\n\n//FBM FUNCTIONS\nfloat fBmWorleyNoise2D(vec2 uv, vec2 scale, vec2 offset, int octaves, float lacunarity, float gain) {\n    //INITIAL VALUES\n    float value = 0.0;\n    float amplitude = .5;\n    \n    //LOOP OF OCTAVES\n    for (int i = 0; i < octaves; i++) {\n        value += amplitude * worleyNoise2D(uv, scale, offset);\n        uv*= lacunarity;\n        amplitude *= gain;\n    }\n    return value;\n}\n\nfloat fBmWorleyNoise3D(vec3 pos, vec3 scale, vec3 offset, int octaves, float lacunarity, float gain) {\n    //INITIAL VALUES\n    float value = 0.0;\n    float amplitude = .5;\n\n    //LOOP OF OCTAVES\n    for (int i = 0; i < octaves; i++) {\n        value += amplitude * worleyNoise3D(pos, scale, offset);\n        pos*= lacunarity;\n        amplitude *= gain;\n    }\n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //NORMALIZE COORDINATES TO UV\n    vec2 uv = fragCoord / iResolution.xy;\n\n    //GET SCREEN RATIO\n    float ratio = iResolution.y / iResolution.x;\n        \n    //MOVEMENT\n    float offset = iTime * 0.2;\n\n    //SCALE\n    vec3 scale = vec3(8.0);\n    scale.y = scale.x * ratio;\n    \n    //INITIAL NOISE VALUE\n    float noise = 0.0;\n    \n    //SPLIT THE SCREEN INTO 4 COLUMNS\n    if (uv.x <= 0.25) {\n        //FIRST COLUMN 2D PERLIN NOISE\n        noise = worleyNoise2D(uv, scale.xy, vec2(offset));\n    } else if (uv.x <= 0.5) {\n        //SECOND COLUMN 3D PERLIN NOISE\n        noise = worleyNoise3D(vec3(uv, 0.0), scale, vec3(offset));\n    } else if (uv.x <= 0.75) {\n        //THIRD COLUMN 2D PERLIN NOISE FBM\n        //SHOWING MULTIPLE OCTAVES\n        if (uv.y >= 2.0/3.0){\n            noise = fBmWorleyNoise2D(uv, scale.xy, vec2(offset), 2, 2.0, 0.5);\n        } else if (uv.y >= 1.0/3.0){\n            noise = fBmWorleyNoise2D(uv, scale.xy, vec2(offset), 3, 2.0, 0.5);\n        } else {\n            noise = fBmWorleyNoise2D(uv, scale.xy, vec2(offset), 4, 2.0, 0.5);\n        }\n    } else {\n        //FOURTH COLUMN 3D PERLIN NOISE FBM\n        //SHOWING MULTIPLE OCTAVES\n        if (uv.y >= 2.0/3.0){\n            noise = fBmWorleyNoise3D(vec3(uv, 0.0), scale, vec3(offset), 2, 2.0, 0.5);\n        } else if (uv.y >= 1.0/3.0){\n            noise = fBmWorleyNoise3D(vec3(uv, 0.0), scale, vec3(offset), 3, 2.0, 0.5);\n        } else {\n            noise = fBmWorleyNoise3D(vec3(uv, 0.0), scale, vec3(offset), 4, 2.0, 0.5);\n        }\n    }\n    \n    //OUTPUT\n    fragColor = vec4(vec3(noise), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//PSEUDO - RANDOM FUNCTIONS\n//TO 1D FUNCTIONS\nfloat rand3dTo1d(vec3 value, vec3 dotDir){\n    vec3 smallValue = sin(value);\n    float random = dot(smallValue, dotDir);\n    random = fract(sin(random) * 143758.5453);\n    return random;\n}\n\nfloat rand2dTo1d(vec2 value, vec2 dotDir){\n    vec2 smallValue = sin(value);\n    float random = dot(smallValue, dotDir);\n    random = fract(sin(random) * 143758.5453);\n    return random;\n}\n\nfloat rand1dTo1d(float value, float mutator){\n\tfloat random = fract(sin(value + mutator) * 143758.5453);\n\treturn random;\n}\n\n//TO 2D FUNCTIONS\nvec2 rand3dTo2d(vec3 value){\n    return vec2(\n        rand3dTo1d(value, vec3(12.989, 78.233, 37.719)),\n        rand3dTo1d(value, vec3(39.346, 11.135, 83.155))\n    );\n}\n\nvec2 rand2dTo2d(vec2 value){\n    return vec2(\n        rand2dTo1d(value, vec2(12.989, 78.233)),\n        rand2dTo1d(value, vec2(39.346, 11.135))\n    );\n}\n\nvec2 rand1dTo2d(float value){\n    return vec2(\n        rand1dTo1d(value, 3.9812),\n        rand1dTo1d(value, 7.1536)\n    );\n}\n\n//TO 3D FUNCTIONS\nvec3 rand3dTo3d(vec3 value){\n    return vec3(\n        rand3dTo1d(value, vec3(12.989, 78.233, 37.719)),\n        rand3dTo1d(value, vec3(39.346, 11.135, 83.155)),\n        rand3dTo1d(value, vec3(73.156, 52.235, 09.151))\n    );\n}\n\nvec3 rand2dTo3d(vec2 value){\n    return vec3(\n        rand2dTo1d(value, vec2(12.989, 78.233)),\n        rand2dTo1d(value, vec2(39.346, 11.135)),\n        rand2dTo1d(value, vec2(73.156, 52.235))\n    );\n}\n\nvec3 rand1dTo3d(float value){\n    return vec3(\n        rand1dTo1d(value, 3.9812),\n        rand1dTo1d(value, 7.1536),\n        rand1dTo1d(value, 5.7241)\n    );\n}\n","name":"Common","description":"","type":"common"}]}