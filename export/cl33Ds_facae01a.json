{"ver":"0.1","info":{"id":"cl33Ds","date":"1683310611","viewed":184,"name":"Quadtree Compression","username":"kastorp","description":"An experiment on storing data with pointers, and simulating a garbage collector\nSPACE BAR: toggle quadtree compression ON/OFF (NB: untoggle before fullscreen)\nA: clean 95% of the data\nmouse: zoom and move POV\n","likes":23,"published":1,"flags":48,"usePreview":0,"tags":["quadtree","morton"],"hasliked":0,"parentid":"dsGXz3","parentname":"Quadtree Experiments"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Quadtree Compression by Kastorp\n//   buffer A: raw sparse quadree\n//   buffer B: compressed quadtree, with wrong FirstChildPos pointer\n//   buffer C: compressed quadtree, with updated FirstChildPos pointer\n//\n//  For each pixel the following informations are stored\n//       level (0-10)\n//       morton code with 2*level bits\n//       unreachable flag used to discard unused texels\n//       state (0=empty,1=divide,2=solid)\n//       firstChildPos pointer to the first child pos texel\n//       swapIndex 0-7 the new index of the current texel after swap, inside the xor swap array of buffer B\n//------------------------------------------\n/*\nTODO:\n - use 64 bits per pixel on leafs, with 3 more levels\n - incremental loading  --> https://www.shadertoy.com/view/clVGzR\n*/\n\n\n\n//input i=tree level\n//output x= size, y=offset\nivec2 getSizeAndOffset(int i){\n    int lvl=-1,off=0;\n    if(i==0){lvl=2; off=0;}\n    else if(i==1){lvl=4; off=4;}\n    else if(i==2){lvl=8; off=20;}\n    else if(i==3){lvl=16; off=84;}\n    else if(i==4){lvl=32; off=340;}\n    else if(i==5){lvl=64; off=1364;}\n    else if(i==6){lvl=128; off=5460;}\n    else if(i==7){lvl=256; off=21844;}\n    else if(i==8){lvl=512; off=87380;}\n    else if(i==9){lvl=1024; off=349524;}\n    else if(i==10){lvl=2048; off=1398100;}\n    off=0;\n    return ivec2(lvl,off);\n}\n\n//input idx=buffer position;  i=level\nQuad getQuadDirect(int i,int idx){\n    if(i<0)  return Quad(i,0,false,1,0,8,0);\n     int res=int(iResolution.x);\n     vec4 d =texelFetch(iChannel2,ivec2(idx%res,idx/res),0);\n     if(idx>int(iResolution.x)*int(iResolution.y)) {return nullQuad(i) ;}                          \n     return decodeQuad(d);\n}\n//input m=morton code;  i=level\nQuad getQuadFromCode(int i, int m){\n\n    if(i<0)  return Quad(i,0,false,1,0,8,0);\n    ivec2 off= getSizeAndOffset(i);  \n    if( m>=0  && m<off.x*off.x){       \n        Quad q;\n       \n        for(int j=0;j<=i;j++){ \n\n            int cp = (m>>((i-j)*2))&3;   \n           for(int ci=0;ci<4;ci++){\n               int idx= (ci ==0)? (j<=0?0:q.firstChildPos):q.nextChildPos;\n               q= getQuadDirect(j,idx);    \n               if(cp==ci) break;\n           }\n   \n        }\n         q.code=m;\n         return q;\n     }\n     return nullQuad(i);\n\n}\n//input i=tree level; p=uv position\nQuad getQuadFromUV(int i, vec2 p){\n    if(min(p.x,p.y) <-.5) return nullQuad(i) ; //outside quad     \n    ivec2 c = ivec2((p+.5)*exp2(float(i)+1. )); \n    int m= xy2z(c) ;\n    return getQuadFromCode(i,m);\n}\n\n\nfloat minsize= 1./2048.; //voxel size\n#define  detail 9  // maximum LOD \n#define MAXSTEP 100\n//same code for octree and quadtree\n//#define octTree \n\n#define tvec vec2\n//using tree ray traversal from Abje: https://www.shadertoy.com/view/XdyfRy\nvec3 trace(in tvec ro,in tvec rd,float d, vec2 uv,inout vec3 O) \n{  \n    float size = 1.;  //current voxel size\n    tvec lro = mod(ro+.5,size); // quad corner position\n    tvec fro = ro-lro;  //relative position inside quad\n    tvec mask;\n    bool exit= false; \n    int recursions = 0; //current LOD from 0 to detail\n  \n    //the tree traverser loop\n    for (int i = 0; i < MAXSTEP; i++)\n    {\n        \n        Quad q= getQuadFromUV(recursions-1,lro +fro ); \n        \n        //debug\n        O+= vec3(1,1,0)*smoothstep(0.001,.0,length(uv-fro-lro));                   \n                       \n        //hit\n        if (q.state ==2 ||length(lro+fro-ro)>d)\n        {\n           // normal=-mask*sign(rd);                   \n            return vec3(length(lro+fro-ro),recursions,float(i));\n        }\n        //go up a level (without moving)\n        if (exit)\n        {           \n            tvec newfro = floor(fro/size*0.5+0.25)*size*2.0;           \n            lro += fro-newfro;fro = newfro;recursions--; size *= 2.0;           \n            exit = (recursions > 0) && (abs(dot(mod(fro/size+0.5,2.0)-1.0+mask*sign(rd)*0.5,mask))<0.1);\n            continue;\n        }\n        //go down one level (without moving)\n        else if(q.state == 1 && recursions<=detail)\n        {           \n            recursions++; size *= 0.5;\n            //find which of the 4 quad I will enter\n            tvec mask2 = step(tvec(size),lro);\n            fro += mask2*size; lro -= mask2*size;\n            continue;\n        }\n               \n        //move forward\n\n        //raycast and find distance to nearest quad border in ray direction\n        tvec hit = -(sign(rd)*(lro-size*.5)-size*.5)/max(abs(rd),0.00001); \n#ifndef octTree   \n            mask = step(hit, hit.yx); \n#else\n            mask = step(hit.xyz, hit.yzx) * step(hit.xyz, hit.zxy);            \n#endif\n        float len = dot(hit,mask)+0.0001; //move a bit forward, outside current block         \n\n        //moving forward in ray direction, and checking if i need to go up a level\n        lro += rd*len-mask*sign(rd)*size;\n        tvec newfro = fro+mask*sign(rd)*size ;\n \n        exit = (floor(newfro/size*0.5+0.25)!=floor(fro/size*0.5+0.25))&&(recursions>0);\n        fro = newfro;\n\n    }\n    return vec3(length(lro+fro-ro),-1.,50.);\n    \n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n   #define R iResolution.xy\n   vec2 uv = (I-iResolution.xy*.5)/iResolution.y;\n   O=vec4(0);\n   \n   if(uv.x<-.5){//debug buffer C \n              \n        int   cx= int((I.x/(R.x*.5 -.5*R.y) +I.y)*R.x);\n        int   Rx =int(R.x);\n        Quad q=  decodeQuad(texelFetch(iChannel2,ivec2(cx%Rx,cx/Rx),0));\n        O= vec4(0,1,0,0)+ vec4(q.state,q.unreachable,q.level,0)*vec4(.2,-1,.2,0);\n        if(q.swapIndex<8 &&! q.unreachable) O=vec4(1,1,0,0);      \n         \n         //labels\n         vec2 U=I/iResolution.y*20. -vec2(0.1,17.5);\n         #define C(c)   O+= char(U,64+32+c);U.x-=.5;\n         C(4) C(1) C(20) C(1) C(-38)\n         U=I/iResolution.y*20. -vec2(0.1,19.);\n         C(3) C(15) C(13) C(16) C(18) C(5) C(19) C(19) C(9) C(15) C(14)C(-38)\n         if( texelFetch(iChannel3,ivec2(32,2),0).x>.5)\n         {C(15) C(14)} else{C(15) C(6) C(6)}\n         O += draw_char(iChannel0).xxxx;\n    } else{\n         \n        vec2 ro= iMouse.z>.0? (iMouse.xy-iResolution.xy*.5)/iResolution.y :vec2(.4,sin(iTime)*.2);\n\n        if(iMouse.z>0.) uv=(uv-ro)/2.+ro;\n        vec3 col=vec3(0);\n        int minl=0,maxl=1+int(.4*log2(iResolution.x*iResolution.y));\n\n        int i=minl;\n        vec2 ps=uv;int m=0;\n        Quad q;\n        for(;i<=maxl;i++){\n             float x = 1./float(maxl-minl);\n\n            if(any(greaterThan(abs(ps),vec2(.5)))) {col=vec3(0); break;} //out of bound\n             vec2 mask = step(vec2(0),ps);\n             ps= (ps+.25 -mask*.5)*2.;\n             int cp=int(mask.x)+int(mask.y)*2;\n             for(int ci=0;ci<4;ci++){\n               int idx= (ci ==0)? (i<=0?0:q.firstChildPos):q.nextChildPos;\n               q= getQuadDirect(i,idx);    \n               if(cp==ci) break;\n             }\n\n    #ifdef DEBUG\n            col.y=q.unreachable?1.:0.; //debug unreachable\n    #endif\n\n        if(q.state==2) {col.x=float(i)*x; break;} //solid\n             else if(q.state==0) {col.z=float(i)*x; break;} //empty\n             if(i==maxl) col.y=1.;           \n        }\n\n    #ifdef DEBUG\n        if(i>0 && i<maxl){\n            int id= getQuadFromUV(i,uv).code;\n            int idp= getQuadFromUV(i-1,uv).code;\n            if((idp-id/4)!=0) col*=0.; //DEBUG PARENT MORTON CODE\n            if( id > idp*4+3 || id < idp*4 ) col*=0.; //DEBUG PARENT MORTON CODE\n        }\n    #endif\n\n        //quad traversal distance\n        col+=smoothstep(0.005,.0,length(uv-ro));\n        vec3 h = trace(ro,normalize(uv-ro),length(ro-uv),uv,col);\n            if (h.x-length(ro-uv)>.0)\n        col= max(col,(h.z)/float(MAXSTEP));//+.3+ cos(vec3(0,2,4) +h.z*.15)*.3);\n\n        O= vec4(col,1.0);\n    }\n\n       \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//raw uncompressed tree\n//  each pixel contains just the state of one quad\n//  quads are ordered by level (4 on 1st level, 16 on 2nd, etc...)\n//  for each level, quads are orderedby mrton code\n//  the number of levels depends on resolution (from 7 on preview to 10 fullscreen)\n\n//the SDF to be encoded (must be exact)\nfloat map(vec2 p){\n    p+=vec2(.1,.15);\n    float d=  abs(length(p)-.23)-.04;\n    d=min(d,sdSegment(p,vec2(0),.3*vec2(sin(iTime/4.),cos(iTime/4.)))-.04);\n    \n    d= abs(d)-.03;\n     d=min(d, .25*letter(iChannel3, (p-vec2(-.15,.5))*4., 33));\n     d=min(d, .25*letter(iChannel3, (p-vec2(.05,.5))*4., 37));\n     d=min(d, .25*letter(iChannel3, (p-vec2(.25,.5))*4., 17));\n     d=min(d, .25*letter(iChannel3, (p-vec2(.45,.5))*4., 20));\n     d=min(d, .25*letter(iChannel3, (p-vec2(.45,-.25))*4., int(mod(iTime*.55,10.)+0.)));\n     return d;\n}\n\nint check(float d, float sz){\n    const float sq2=sqrt(2.)/2.;\n    ivec2 b= ivec2(d+sz*sq2<0., //inside,\n                   d-sz*sq2<0.); //not empty\n    return int(b.x+b.y); //state \n}\n\n\n//x: state(0=empty,1=divide,2=solid), y:code,z:unreachable, w: level\nvec4 setQuad(int idx){\n    vec4 O=vec4(0);\n    int lvl=-1,off=0;\n    if(idx<4){lvl=2; off=0;}\n    else if(idx<20){lvl=4; off=4;}\n    else if(idx<84){lvl=8; off=20;}\n    else if(idx<340){lvl=16; off=84;}\n    else if(idx<1364){lvl=32; off=340;}\n    else if(idx<5460){lvl=64; off=1364;}\n    else if(idx<21844){lvl=128; off=5460;}\n    else if(idx<87380){lvl=256; off=21844;}\n    else if(idx<349524){lvl=512; off=87380;}\n    else if(idx<1398100){lvl=1024; off=349524;}\n    else {lvl=2048; off=1398100;} // --> 1398100  working only on flullscreen\n     \n    int idx2= idx-off;\n    ivec2 c = z2xy(idx2);\n    float sz =1./float(lvl);\n    vec2 p = vec2(-0.5) + (sz)*(vec2(c)+.5);\n           \n    //if(lvl<0) return O;\n\n    int fcp=idx2*4+ off+lvl*lvl; //first child pos\n    \n    Quad q = Quad(int(log2(float(lvl))) ,idx2,false,check(map(p),sz),fcp,8,idx+1)  ;\n\n\n    //check unreachable    \n    for(int lvp=lvl;lvp>0;lvp--){       \n        sz*=2.;\n        const float TOLERANCE=1.5; // with value= 1. or sqrt(2.) it's too restrictive\n        if(check(map(p),sz*TOLERANCE) !=1 ) {q.unreachable=true;break;}\n    }\n       \n    return encodeQuad(q);\n}\n\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    O=vec4(0);\n    vec2 uv = (I-iResolution.xy*.5)/iResolution.y;\n    int pos =int(I.x) + int(I.y)* int(iResolution.x);\n    O=setQuad(pos);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//https://iquilezles.org/articles/distfunctions2d/\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n//Z-Curve 2 by FabriceNeyret\n//https://www.shadertoy.com/view/XdsyWr\nint MASKS[] = int[] (0x55555555, 0x33333333, 0x0F0F0F0F, 0x00FF00FF, 0x0000FFFF);\n#define loglevel 3 // max 3    1: for 16x16 grid  2: for 256x256 grid\n\nint xy2z(ivec2 I) {                   // --- grid location to morton code \n    int n=8;\n    for (int i=3; i>=0; i--)\n        I =  (I | (I << n)) & MASKS[i],\n        n /= 2;\n    return I.x | (I.y << 1);\n}\n\nivec2 z2xy(int z) {                  // --- morton code to grid location \n    int n=1;\n    ivec2 I = ivec2(z,z>>1) & MASKS[0];\n    for (int i=1; i<=loglevel+1; i++)\n        I = (I | (I >>  n)) & MASKS[i],\n        n *= 2;\n    return I;\n}\n\n\n//--------------------------------\n\n//FabriceNeyret\n\n\n    \nint char_id = -1; vec2 char_pos, dfdx, dfdy; \nvec4 char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) \n    char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\n    return vec4(0);\n}\nvec4 draw_char(sampler2D ch) {\n    int c = char_id; vec2 p = char_pos;\n    return c < 0  ? vec4(0,0,0,1e5) : textureGrad( ch, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );\n}\nvec4 pInt(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.)  v += char(p - vec2(-.5,0), 45 ), n = -n;\n    for (float i = 3.; i>=0.; i--)  n /=  9.999999, v += char(p - .5*vec2(i,0), 48+ int(fract(n)*10.) );\n    return v;\n}\n#define  chars( pos,  ids) for(int i_=0;i_<ids.length();i_++) {char( pos +vec2(i,0)*10.,ids[i_]);}\n\n\n//-----------------------\n\nstruct Quad{\n    int level;\n    int code;\n    bool unreachable; \n    int state;\n    int firstChildPos;\n    int swapIndex;\n    int nextChildPos;\n   \n\n};\n\nQuad decodeQuad(vec4 d){\n    ivec4 i =ivec4(d);\n    return Quad(i.x&31,i.z,(i.x&256)>0,(i.x&192)/64,i.y,(i.x&(15*512))/512,i.w);\n    \n}\nvec4 encodeQuad(Quad q){\n    return vec4(max(q.level,0) + (q.state*64) + (q.unreachable?256:0)+(q.swapIndex*512),q.firstChildPos,q.code,q.nextChildPos);\n}\n\nQuad nullQuad( int i) {return Quad(i,0,true,0,0,8,0);}\n\n//------\n\nfloat letter(sampler2D chn,vec2 p,int ch){\n    ch+=48;\n    if(max(abs(p.x),abs(p.y))>.5)  return length(p)-.3;\n    vec2 cp = vec2(ivec2(ch%16, 15-ch/16));\n    vec4 d= textureLod(chn, (p+ cp + 0.5)/16., 0.) ;\n    vec2 grad=vec2(-1,1) *(d.yz-vec2(.5))*2.;\n    float dst=(d.w-.501) ;\n    return dst;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//sort quad if A key is pressed\n\n//pixel XOR Sorting 4x by Kastorp https://www.shadertoy.com/view/ftlfD8\n//sorting network https://www.shadertoy.com/view/XsXGDX\nint sf(vec4 v){ \n    Quad q = decodeQuad(v);\n\n    return -q.code-(q.level<<20)-(q.unreachable?(1<<24):0); //compression: remove unreachable nodes\n    //return -q.code-(q.level<<20); //original sorting level ASC, morton ASC\n}\n\n#define SW(a,b)  if(sf(v[a])<sf(v[b])) {vec4 t = v[a]; v[a] =v[b]; v[b] = t; int s=np[a];np[a]=np[b];np[b]=s; }\nvoid sort(inout vec4[8] v,inout int[8] np){\n    SW(0,1); SW(2,3); SW(0,2); SW(1,3); SW(1,2); \n    SW(4,5); SW(6,7); SW(4,6); SW(5,7); SW(5,6);\n    SW(0,4); SW(1,5); SW(1,4); SW(2,6); SW(3,7); \n    SW(3,6); SW(2,4); SW(3,5); SW(3,4);\n}\n\n\n#define RR iResolution.xy //vec2(512)\nvoid mainImage( out vec4 O, in vec2 U )\n{   \n    Quad q;\n    if(iFrame>10 && texelFetch(iChannel3,ivec2(32,2),0).x<.5){ \n        O= texelFetch(iChannel0,ivec2(U),0);\n        q=decodeQuad(O);\n        q.swapIndex=8;\n        O=encodeQuad(q);\n        return;\n    }\n    \n    ivec2 R=ivec2(RR);\n    int l= int(log2(RR.x*RR.y))-2, //maximum xor level\n        z=(iFrame/2)%l,zz=1<<z, //current xor level; also zz=1<<(2*z) works, with z<=l/2\n        ii = (int(U.x) + int(U.y)*R.x), //current position\n        i=ii/zz, //xor position\n        s= ((i&4)/4 == (iFrame&1)) ?0:1, //sorting side s=0 left, S=1 right\n        m= s*4+(i&(3)), //relative position in sort array\n        h= min(i -(i&(3)),i -(i&(3))-s*4) ; //first position in array  \n                \n    vec4[8] P; //sorting array\n    int[8] N; //swap index\n    for(int k=0;k<8;k++){\n         int j=(h+k)*zz + (ii%zz); //k-th absolute position\n         P[k]=texelFetch(iChannel2,ivec2(j%R.x,j/R.x),0); //previous values\n         N[k]=k;\n    }         \n    \n\n    if(h>=0 && (h+4)*zz>0 && (h+4)*zz  < ((R.x*R.y)&((1<<24)-4*zz)))  { ///sort only if inside boundaries\n        sort(P, N); \n              \n        int k;\n        for(k=0;k<8;k++){\n            if(N[k]==m) break;\n        }\n      \n        q=decodeQuad(P[m]);\n        if(N[m]!=m){          \n            q.swapIndex=k; //previous and next swap indexes\n        }else{\n            \n            q.swapIndex=8;\n        }\n        \n     } \n    else {\n        q=decodeQuad(P[m]);\n        q.swapIndex=8;   //otherwise keep order       \n    }\n    O=encodeQuad(q);\n    \n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//update buffer B first child pointer after swaps\n\n\nint getPos(int ii, int k){\n    vec2 R=iResolution.xy;\n    int l= int(log2(R.x*R.y))-2, //maximum xor level\n    z=(iFrame/2)%l,zz=1<<z, //current xor level; also zz=1<<(2*z) works, with z<=l/2\n    i=ii/zz, //xor position\n    s= ((i&4)/4 == (iFrame&1)) ?0:1, //sorting side s=0 left, S=1 right\n    m= s*4+(i&(3)), //relative position in sort array\n    h= min(i -(i&(3)),i -(i&(3))-s*4) ; //first position in array  \n\n    return (h+k)*zz + (ii%zz);\n}\nvoid mainImage( out vec4 O, in vec2 I )\n{\n     Quad q =  decodeQuad(texelFetch(iChannel1,ivec2(I),0));\n    \n     int res = int(iResolution.x),\n         pfc = q.firstChildPos; //previous first child\n     vec4  data =texelFetch(iChannel1,ivec2(pfc%res,pfc/res),0);\n     Quad q2= decodeQuad(data);   \n     int nfc = getPos(pfc,q2.swapIndex); //new first child    \n      if(q2.swapIndex<8) q.firstChildPos=nfc; //update pointer\n      \n      \n     int   pnc = q.nextChildPos; \n     vec4  data3 =texelFetch(iChannel1,ivec2(pnc%res,pnc/res),0);\n     Quad q3= decodeQuad(data3);   \n     int nnc = getPos(pnc,q3.swapIndex); //new first child    \n      if(q3.swapIndex<8) q.nextChildPos=nnc; //update pointer\n      \n      \n      if(texelFetch(iChannel3,ivec2(65,0),0).x>.5 && I.y >iResolution.y*.05 ){\n          q= nullQuad(0);\n      }\n      O=encodeQuad(q);\n}","name":"Buffer C","description":"","type":"buffer"}]}