{"ver":"0.1","info":{"id":"lccyRH","date":"1730238273","viewed":36,"name":"3d Julia simple 101","username":"kukovisuals","description":"Optimized the last 3D Julia shader to be faster and fixed camera rotation to have it fixed and rotating only the shape not the entire scene ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["fractal","julia","3djuliaset"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 3D Julia Set Rendering KukoVisuals\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst int MAX_MARCHING_STEPS = 50;\nconst float MIN_DIST = 0.001;\nconst float MAX_DIST = 7.0;\nconst int MAX_ITERATIONS = 10;\nconst float BAILOUT = 4.0;\n\n// Distance estimator for the 3D Julia Set\nfloat DE_Julia(vec3 pos, mat3 rotY) {\n    vec3 z = rotY * pos;\n    float dr = 1.0;\n    float r = 0.0;\n    vec3 c = vec3(-0.77, 0.112, 0.0); // Constant defining the Julia set shape\n\n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n        r = length(z);\n        if (r > BAILOUT) break;\n\n        // Precompute r^8 and r^7\n        float r_power = r * r * r * r * r * r * r * r;\n        float r_power_7 = r_power / r;\n\n        // Precompute theta and phi multipliers\n        float theta8 = 8.0 * acos(z.z / r);\n        float phi8 = 8.0 * atan(z.y, z.x);\n\n        // Calculate new position\n        float sinTheta = sin(theta8);\n        float cosTheta = cos(theta8);\n        float sinPhi = sin(phi8);\n        float cosPhi = cos(phi8);\n\n        z = r_power * vec3(sinTheta * cosPhi, sinTheta * sinPhi, cosTheta) + c;\n\n        // Compute derivative\n        dr = r_power_7 * 8.0 * dr + 1.0;\n    }\n    return 0.5 * log(r) * r / dr;\n}\n\n// Calculate normal for lighting\nvec3 getNormal(vec3 p,  mat3 rotY) {\n    float eps = 0.0001;\n    vec2 e = vec2(1.0, -1.0) * eps;\n\n    float nx = DE_Julia(p + vec3(e.x, e.y, e.y), rotY) - DE_Julia(p - vec3(e.x, e.y, e.y), rotY);\n    float ny = DE_Julia(p + vec3(e.y, e.x, e.y), rotY) - DE_Julia(p - vec3(e.y, e.x, e.y), rotY);\n    float nz = DE_Julia(p + vec3(e.y, e.y, e.x), rotY) - DE_Julia(p - vec3(e.y, e.y, e.x), rotY);\n\n    return normalize(vec3(nx, ny, nz));\n}\n\n// Main ray marching function\nfloat rayMarch(vec3 ro, vec3 rd, out vec3 p, mat3 rotY) {\n    float totalDist = 0.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        p = ro + rd * totalDist;\n        float dist = DE_Julia(p, rotY);\n        if (dist < MIN_DIST || totalDist > MAX_DIST) break;\n        totalDist += dist;\n    }\n    return totalDist;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Camera setup (fixed)\n    vec3 ro = vec3(0.0, 0.0, -4.0); // Camera position\n    vec3 rd = normalize(vec3(uv, 6.0)); // Ray direction\n\n    // Define rotation matrix\n    float angle = iTime * 0.2; // Adjust rotation angle\n    mat3 rotY = mat3(\n        cos(angle), 0.0, sin(angle),\n        0.0,        1.0,        0.0,\n        -sin(angle),0.0, cos(angle)\n    );\n    \n    // Fixed light direction\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n\n    // Ray marching with rotation applied only to the shape\n    vec3 p;\n    float totalDist = rayMarch(ro, rd, p, rotY); // Pass rotY to rayMarch\n\n    // Shading\n    vec3 color = vec3(0.0);\n    if (totalDist < MAX_DIST) {\n        vec3 normal = getNormal(p, rotY);\n        float diff = max(dot(normal, lightDir), 0.0);\n\n        // Increased ambient light to maintain brightness consistency\n        float ambient = 0.3;\n        color = (ambient + diff) * vec3(0.2, 0.7, 0.9);\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}