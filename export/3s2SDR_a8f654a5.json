{"ver":"0.1","info":{"id":"3s2SDR","date":"1553463423","viewed":450,"name":"Star-Packed (with Dart-Throwing)","username":"fizzer","description":"I tried packing circles together by updating a whole distance field texture on each iteration so that a collision detection is possible anywhere (only need distance to do a circle collision test). It worked, so I developed it into this \"starfield\".","likes":20,"published":1,"flags":32,"usePreview":0,"tags":["stars","packing","filling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Note: Click LMB to reset.\n\nfloat id=0.;\n\nfloat noise(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat smoothNoise2(vec2 p)\n{\n    return mix( mix(noise(floor(p)), noise(floor(p + vec2(1, 0))), fract(p.x)), \n               mix(noise(floor(p + vec2(0, 1))), noise(floor(p + vec2(1, 1))), fract(p.x)), fract(p.y));\n}\n\nfloat fbm(vec2 p)\n{\n    float x = 0.;\n    for(int i = 0; i < 18; ++i)\n        x += smoothNoise2(p * pow(2., float(i))) / pow(2., float(i) + 1.);\n    return x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    p.x += iTime * .02;\n\n    // Read the \"sprite\" data.\n    vec3 data = textureLod(iChannel0, p, 0.).rgb;\n\n    vec2 c = data.rg;\n    float r = data.b;\n\n    id = -(c.x * r - p.x) * 9.;\n\n    // Background colour.\n    fragColor.rgb = vec3(.5,.5,1.)*.6;\n\n    // Apply the \"sprite\" with an adjusted scale.\n    float scale = .8 + .2 * sin(p.y * 3. + p.x);\n    c.xy /= scale;\n    r *= scale;\n    fragColor.rgb = mix(fragColor.rgb, vec3(1., .9, .4), smoothstep(.0, .004 / r, (.8 + .2 * cos(atan(c.y, c.x) * 5.)) - length(c)));\n\n\n    // Paper-like texture.\n    fragColor.rgb *= mix(.5, 1., pow(texture(iChannel1, p * vec2(iResolution.x / iResolution.y ,1)).r, .5)) * 1.1;\n\n    fragColor.rgb *= 1. - fbm(p * 70.) * .2;\n\n    // Gamma correction.\n    fragColor.rgb = pow(clamp(fragColor.rgb, 0., 1.), vec3(1. / 2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This buffer stores the following data:\n//\n// R channel: X coordinate in local space of nearest circle\n// G channel: Y coordinate in local space of nearest circle\n// B channel: Radius of nearest circle\n// A channel: Distance field containing signed distance to nearest circle (valid at all pixels)\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame == 0 || iMouse.z > 0.)\n    {\n        // Reset.\n        fragColor.rgb = vec3(1e5);\n        fragColor.a = 1e4;\n        return;\n    }\n    \n    // Read in the previous data.\n    vec2 p = fragCoord.xy / iResolution.xy;\n    vec4 prev_p = textureLod(iChannel0, p, 0.);\n    \n    fragColor = prev_p;\n\n    // Apply aspect correction.\n    p.x *= iResolution.x / iResolution.y;\n    \n    // To make sure the texture can repeat, the sprite is drawn also on the\n    // left and right sides of the viewport.\n    for(int x = -1; x < 2; ++x)\n    {\n        // Random position.\n        vec2 c = hash21(float(iFrame)) + vec2(x, 0);\n\n        vec4 prev_c = textureLod(iChannel0, c, 0.);\n\n    \t// Apply aspect correction.\n        c.x *= iResolution.x / iResolution.y;\n\n        // Random radius.\n        float r = 0.06 * pow(0.998, float(iFrame % 1000));\n        \n        float d = distance(c, p) - r;\n\n        float margin = 2e-3;\n\n        // Check if the circle is valid by comparing it to the distance field\n        // stored in the alpha channel.\n        if(prev_c.a > r + margin)\n        {\n            if(d < 0.)\n            {\n                vec3 data = vec3((p - c) / r, r);\n                \n                // Apply a random rotation.\n                float angle = hash21(float(iFrame * 3)).x * pi * 2.;\n                data.xy = mat2(cos(angle), sin(angle), -sin(angle), cos(angle)) * data.xy;\n                \n                // Overwrite \"sprite\" data.\n                fragColor.rgb = data;\n            }\n\n            // Merge the distance field and store in alpha channel.\n            fragColor.a = min(fragColor.a, d);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float pi = 3.1415926535898797323;\n\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n","name":"Common","description":"","type":"common"}]}