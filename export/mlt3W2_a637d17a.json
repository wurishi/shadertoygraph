{"ver":"0.1","info":{"id":"mlt3W2","date":"1683166928","viewed":283,"name":"Study for Terrain Gen - v2","username":"pdcxs","description":"Just for study. Tutorial: https://www.bilibili.com/video/BV18P411i7PF","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["3d","terrain","noised"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 0.001\n#define MAX_DIST 200.\n#define MAX_ITER 128\n\nvec2 fixUV(vec2 uv) {\n    return (2. * uv - iResolution.xy) / iResolution.x;\n}\n\nfloat hash12(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat random(vec2 pos) {\n    // return abs(fract(78523.215 * sin(dot(pos, vec2(25.32, 547.23)))));\n    return hash12(pos);\n}\n\nvec3 noise(vec2 pos) {\n    vec2 i = floor(pos);\n    vec2 f = fract(pos);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    vec2 du = 6. * u * (1. - u);\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    return vec3(a + (b - a) * u.x * (1. - u.y) +\n        (c - a) * (1. - u.x) * u.y +\n        (d - a) * u.x * u.y, \n        du * (vec2(b - a, c - a) +\n        (a - b - c + d) * u.yx));\n}\n\nmat2 mat = mat2(0.6, -0.8, 0.8, 0.6);\n\nfloat ground(vec2 p) {\n    float a = 0.;\n    float b = 1.;\n    vec2 d = vec2(0);\n\n    for (int i = 0; i < 10; i++) {\n        vec3 n = noise(p);\n        d += n.yz;\n        a += b * n.x / (1. + dot(d, d));\n        p = mat * p * 2.;\n        b *= 0.5;\n    }\n\n    return a;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float t = 0.;\n    for(int i = 0; i < MAX_ITER; i++) {\n        vec3 p = ro + t * rd;\n        float h = p.y - ground(p.xz);\n        if(abs(h) < EPSILON * t || t > MAX_DIST)\n            break;\n        t += 0.2 * h;\n    }\n    return t;\n}\n\nvec3 calcNorm(vec3 p) {\n    vec2 epsilon = vec2(1e-5, 0);\n    return normalize(vec3(ground(p.xz + epsilon.xy) - ground(p.xz - epsilon.xy), 2.0 * epsilon.x, ground(p.xz + epsilon.yx) - ground(p.xz - epsilon.yx)));\n}\n\nmat3 setCamera(vec3 ro, vec3 target, float cr) {\n    vec3 z = normalize(target - ro);\n    vec3 up = normalize(vec3(sin(cr), cos(cr), 0));\n    vec3 x = cross(z, up);\n    vec3 y = cross(x, z);\n    return mat3(x, y, z);\n}\n\nvec3 render(vec2 uv) {\n    vec3 col = vec3(0);\n\n    float an = sin(iTime * .2) * .2 + .4;\n    float r = 3.1;\n    vec3 ro = vec3(r * sin(an), 1., r * cos(an));\n    vec3 target = vec3(0, 0., 0);\n    mat3 cam = setCamera(ro, target, 0.);\n\n    float fl = 1.;\n    vec3 rd = normalize(cam * vec3(uv, fl));\n\n    float t = rayMarch(ro, rd);\n\n    if(t < MAX_DIST) {\n        vec3 p = ro + t * rd;\n        vec3 n = calcNorm(p);\n        vec3 difColor = vec3(0.67, 0.57, 0.44);\n        col = difColor * dot(n, vec3(0, 1, 0));\n    }\n\n    return sqrt(col);\n    // return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fixUV(fragCoord);\n    vec3 col = render(uv);\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}