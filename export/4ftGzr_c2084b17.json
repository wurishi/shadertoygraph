{"ver":"0.1","info":{"id":"4ftGzr","date":"1711327080","viewed":92,"name":"Floral Dance","username":"laserbat","description":"Random patterns tend to die out quickly in this rule. Adding a source of noise mitigates this, resulting in this mesmerizing display of color and movement.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["feedback","cellularautomata"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Left click randomizes the CA state.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    int val = GET(fragCoord.xy, ivec2(0, 0));\n    \n    // The specifics of this rule lead to uneven distribution of cell values.\n    // Hashing shuffles the values back to a near-uniform distribution.\n    val = hash(val);\n    \n    fragColor.r = float(val & 255);\n    fragColor.g = float((val >> 8) & 255);\n    fragColor.b = float((val >> 16) & 255);\n    \n    fragColor.rgb /= 255.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Simple time-dependent noise function for seeding the CA.\nfloat noise(in vec2 co){\n    int x = int(co.x * float(M));\n    int y = int(co.y * float(M));\n    int z = int(iDate.a);\n    int w = int(fract(iDate.a) * float(M));\n    int res = hash(x + hash(y + hash(z + hash(w))));\n    \n    return float(res);\n}\n\n// Main computation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {        \n    // Randomize initial state on 0th frame or if mouse button is pressed\n    if (iFrame <= 0 || iMouse.z > 0.0 || length(fragCoord) < 2.0) {\n        fragColor.x = float(int(noise(fragCoord/iResolution.xy)) % M);\n    } else {\n    \tivec2 d;\n                \n        // Radius of the neighborhood.\n        int R = 8;\n        \n        int cen = GET(fragCoord, ivec2(0, 0));\n        \n        int minv = M - 1;\n        int maxv = 0;\n        \n        for(d.y = -R; d.y <= +R; d.y++)\n        \tfor(d.x = -R; d.x <= +R; d.x++){ \n                if(length(vec2(d)) > float(R)) continue;\n                int s = GET(fragCoord, d);\n                maxv = max(maxv, s);\n                minv = min(minv, s);\n             }\n        \n        // Changing how res is calcuated strongly affetcs th CA behavior. \n        int res = (minv + maxv) >> 16;\n        res ^= 127;\n                \n        for(d.y = -R; d.y <= +R; d.y++)\n        \tfor(d.x = -R; d.x <= +R; d.x++){ \n                if(length(vec2(d)) > float(R)) continue;\n                int s = GET(fragCoord, d) ^ res;\n                maxv = max(maxv, s);\n                minv = min(minv, s);\n             }\n        \n        maxv ^= res;\n        minv ^= res;\n        \n        // Changing this formula also has a big effect.\n        res = (minv + maxv) >> 13;\n        if (res % 3 == 0)\n            res = minv;\n        else \n            res = maxv;\n                            \n        fragColor.x = float(res);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define GET(coord, offset) int(texelFetch(iChannel0, ivec2(mod(coord + vec2(offset) + iResolution.xy, iResolution.xy)), 0).x)\n\n#define M (1<<24)\n\nint hash(int x) {\n    x++;\n    x ^= x >> 17;\n    x *= 0xed5ad4bb;\n    x ^= x >> 11;\n    x *= 0xac4c1b51;\n    x ^= x >> 15;\n    x *= 0x31848bab;\n    x ^= x >> 14;\n    return x;\n}","name":"Common","description":"","type":"common"}]}