{"ver":"0.1","info":{"id":"McBcDG","date":"1726703254","viewed":42,"name":"brdf vs importance spec 2.01","username":"quadrortx8000","description":"Basic ray tracer to build upon","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raytrace","base"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"brdf vs importance spec 2.0\" by quadrortx8000. https://shadertoy.com/view/MfSczt\n// 2024-08-05 23:28:36\n\n// Fork of \"Furnace test\" by quadrortx8000. https://shadertoy.com/view/Dt3fW4\n// 2024-06-28 19:10:10\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy / iResolution.xy);\n    \n    vec4 col = texture(iChannel0, uv);\n    \n    col.rgb /= col.w;\n    //col.rgb -= 0.4;\n    //col.rgb *= 10.0;\n\t\n\tfragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float pi = 3.141592653558979323;\n\nstruct info {\n    float dist;\n    vec3 norm;\n    vec3 alb;\n    vec3 emissive;\n};\n\nbool iSphere(in vec3 ro, in vec3 rd, inout info hit, in vec4 sph) {\n\tvec3 m = ro - sph.xyz;\n\n\tfloat b = dot(m, rd);\n\n\tfloat c = dot(m, m) - sph.w * sph.w;\n\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\tfloat discr = b * b - c;\n\n\tif(discr < 0.0)\n\t\treturn false;\n\n    bool inside = false;\n\tfloat dist = -b - sqrt(discr);\n    if (dist < 0.0) {\n        inside = true;\n        dist = -b + sqrt(discr);\n    }\n    \n\tif (dist < hit.dist) {\n        hit.dist = dist;        \n        hit.norm = normalize((ro+rd*dist) - sph.xyz) * (inside ? -1.0 : 1.0);\n        return true;\n    }\n    \n    return false;\n}\n\nuint hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat randF(inout uint state)\n{\n    return float(hash(state)) / 4294967296.0;\n}\n \nvec3 randV(inout uint state)\n{\n    float z = randF(state) * 2.0 - 1.0;\n    float a = randF(state) * 3.14159265358979323 * 2.0;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nvec3 hemiDir (vec3 norm, inout uint rand) {\n    vec3 dir = randV(rand);\n    return dir * sign(dot(norm, dir));\n}\n\nvec3 cosineDir (vec3 norm, inout uint rand) {\n    return normalize(norm + randV(rand));\n}\n\n// ---- QUATERNIONS ----\n\nvec4 quaternionMultiply(vec4 a, vec4 b) {\n    return vec4(\n        a.x * b.w + a.y * b.z - a.z * b.y + a.w * b.x,\n        -a.x * b.z + a.y * b.w + a.z * b.x + a.w * b.y,\n        a.x * b.y - a.y * b.x + a.z * b.w + a.w * b.z,\n        -a.x * b.x - a.y * b.y - a.z * b.z + a.w * b.w\n    );\n}\n\nvec3 quaternionRotate(vec3 pos, vec4 q) {\n    vec4 qInv = vec4(-q.xyz, q.w);\n    return quaternionMultiply(quaternionMultiply(q, vec4(pos, 0)), qInv).xyz;\n}\n\nvec4 getRotationToZAxis(vec3 vec) {\n\n\t// Handle special case when input is exact or near opposite of (0, 0, 1)\n\tif (vec.z < -0.99999f) return vec4(1.0f, 0.0f, 0.0f, 0.0f);\n\n\treturn normalize(vec4(vec.y, -vec.x, 0.0f, 1.0f + vec.z));\n}\n\nvec3 fresnelSchlick(vec3 F0, float cosTheta) {\n    return F0 + (1.0 - F0) * pow((1.0 - cosTheta), 5.0);\n}\nfloat distributionGGX(vec3 v, float alpha) {\n    float alpha2 = alpha * alpha;\n    return 1.0 / (pi * alpha2 * pow(v.x * v.x / alpha2 + v.y * v.y / alpha2 + v.z * v.z , 2.0));\n}\n\nfloat smithShadowing(vec3 v, float roughness) {\n    float lambda = (-1.0 + sqrt(1.0 + (roughness * roughness * (v.x * v.x + v.y * v.y)) / v.z / v.z)) / 2.0;\n    return 1.0 / (1.0 + lambda);\n}\n\nfloat smithUncorrelatedGeometry(vec3 V, vec3 L, float roughness) {\n    return smithShadowing(V, roughness) * smithShadowing(L, roughness);\n}\n\nvec3 sampleGGXVNDF(vec3 Ve, vec2 alpha2D, vec2 u) {\n\tvec3 Vh = normalize(vec3(alpha2D.x * Ve.x, alpha2D.y * Ve.y, Ve.z));\n\n\tfloat lensq = Vh.x * Vh.x + Vh.y * Vh.y;\n\tvec3 T1 = lensq > 0.0f ? vec3(-Vh.y, Vh.x, 0.0f) * inversesqrt(lensq) : vec3(1.0f, 0.0f, 0.0f);\n\tvec3 T2 = cross(Vh, T1);\n\n\tfloat r = sqrt(u.x);\n\tfloat phi = 2.0 * pi * u.y;\n\tfloat t1 = r * cos(phi);\n\tfloat t2 = r * sin(phi);\n\tfloat s = 0.5f * (1.0f + Vh.z);\n\tt2 = mix(sqrt(1.0f - t1 * t1), t2, s);\n\n\tvec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.0f, 1.0f - t1 * t1 - t2 * t2)) * Vh;\n\n\treturn normalize(vec3(alpha2D.x * Nh.x, alpha2D.y * Nh.y, max(0.0f, Nh.z)));\n}\n\nvec3 brdf (vec3 alb, float rough, float metal, vec3 F0, vec3 normal, vec3 view, vec3 light) {\n    vec4 q = getRotationToZAxis(normal);\n    vec3 V = quaternionRotate(view, q);\n    vec3 L = quaternionRotate(light, q);\n    vec3 H = normalize(V + L);\n    \n    float HdotV = clamp(dot(H, V), 0.0, 1.0);\n    float NdotH = clamp(H.z, 0.0, 1.0);\n    \n    vec3 F = fresnelSchlick(F0, HdotV);\n    float D = distributionGGX(H, rough);\n    float G = smithUncorrelatedGeometry(V, L, rough);\n    \n    vec3 spec = F * D * G / max(4.0 * V.z * L.z, 0.001);\n    \n    if (rough == 0.0) return (1.0 - metal) * (1.0 - fresnelSchlick(F0, L.z)) * (1.0 - fresnelSchlick(F0, max(dot(normal, view), 0.0))) * alb / pi * max(L.z, 0.0);\n    return ((1.0 - metal) * (1.0 - fresnelSchlick(F0, L.z)) * (1.0 - fresnelSchlick(F0, max(dot(normal, view), 0.0))) * alb / pi + spec) * L.z;\n}\n\nvec3 sampleSpecular(vec3 alb, float rough, float metal, vec3 F0, vec3 normal, vec3 view, inout uint rng, out vec3 brdf) {\n    vec4 q = getRotationToZAxis(normal);\n    vec3 V = quaternionRotate(view, q);\n    vec3 M = sampleGGXVNDF(V, vec2(rough), vec2(randF(rng), randF(rng)));\n    vec3 L = reflect(-V, M);\n    vec3 H = normalize(V + L);\n\n\n    vec3 F = fresnelSchlick(F0, dot(H, V));\n    float G2 = smithUncorrelatedGeometry(V, L, rough);\n    float G1 = smithShadowing(V, rough);\n    brdf = F * G2 / G1;\n    \n    vec3 specdir = quaternionRotate(L, vec4(-q.xyz, q.w));\n    vec3 diffusedir = cosineDir(normal, rng);\n    \n    float albchance = (1.0 - metal) * (1.0 - dot(fresnelSchlick(F0, max(dot(specdir, normal), 0.0)), vec3(1.0 / 3.0))) * (1.0 - dot(fresnelSchlick(F0, max(dot(view, normal), 0.0)), vec3(1.0 / 3.0)));\n    float specchance = dot(F, vec3(1.0 / 3.0));\n    if (randF(rng) <= specchance && metal != 1.0) {\n        brdf /= specchance;\n        return specdir;\n    } else if (metal == 1.0) {\n        return specdir;\n    } else {\n        brdf = (1.0 - metal) * (1.0 - fresnelSchlick(F0, max(dot(diffusedir, normal), 0.0))) * (1.0 - fresnelSchlick(F0, max(dot(view, normal), 0.0))) * alb / (1.0 - specchance);\n        return diffusedir;\n    }\n    \n    return specdir;\n}\n\nvec3 sampleSpecular2 (vec3 alb, float rough, float metal, vec3 F0, vec3 normal, vec3 view, inout uint rng, out vec3 brdf) {\n    vec4 q = getRotationToZAxis(normal);\n    vec3 V = quaternionRotate(view, q);\n    vec3 M = sampleGGXVNDF(V, vec2(rough), vec2(randF(rng), randF(rng)));\n    vec3 L = reflect(-V, M);\n    vec3 H = normalize(V + L);\n\n\n    vec3 F = fresnelSchlick(F0, dot(H, V));\n    float G2 = smithUncorrelatedGeometry(V, L, rough);\n    float G1 = smithShadowing(V, rough);\n    brdf = F * G2 / G1;\n    \n    vec3 specdir = quaternionRotate(L, vec4(-q.xyz, q.w));\n    vec3 diffusedir = cosineDir(normal, rng);\n    \n    float albchance = (1.0 - metal) * (1.0 - dot(fresnelSchlick(F0, max(dot(specdir, normal), 0.0)), vec3(1.0 / 3.0))) * (1.0 - dot(fresnelSchlick(F0, max(dot(view, normal), 0.0)), vec3(1.0 / 3.0)));\n    float specchance = dot(F, vec3(1.0 / 3.0));\n    if (randF(rng) <= specchance) {\n        brdf /= specchance;\n        return specdir;\n    } else {\n        brdf = (1.0 - metal) * (1.0 - fresnelSchlick(F0, max(dot(diffusedir, normal), 0.0))) * (1.0 - fresnelSchlick(F0, max(dot(view, normal), 0.0))) * alb / (1.0 - specchance);\n        return diffusedir;\n    }\n    \n    return specdir;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float far = 1000.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    uint rng = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    \n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 m = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n    m.x *= iResolution.x / iResolution.y;\n    \n    float fov = 90.0;\n\tvec3 ro = vec3(0.0, 0.0, -2.0);\n    float camdist = 1.0 / tan(fov * 0.5 * pi / 180.0);\n    vec3 rt = vec3(uv, camdist) + ro;\n\tvec3 rd = normalize(rt - ro);\n\tvec3 col;\n    \n    vec4 lastcol = texture(iChannel0, fragCoord / iResolution.xy);\n    float temp = lastcol.w;\n    \n    if (iFrame == 0 || iMouse.z > 0.0) {\n        lastcol = vec4(0.0);\n        temp = 0.0;\n    }\n    \n    info hit;\n    hit.dist = far;\n    \n    bool h = iSphere(ro, rd, hit, vec4(0.0, 0.0, 0.0, 1.0));\n    \n    int samples = 1000;\n    float rough = 0.2;\n    rough *= rough;\n    \n    vec3 F0 = vec3(1.000,0.749,0.059);\n    vec3 alb = vec3(1.0);\n    float metal = 0.0;\n    \n    for (int i = 0; i < samples; i++) {\n        if (fragCoord.x > iResolution.x / 2.0) {\n            vec3 dir = hemiDir(hit.norm, rng);\n            col += texture(iChannel1, dir).rgb * brdf(alb, rough, metal, F0, hit.norm, -rd, dir) * 2.0 * pi;\n        } else {\n            vec3 brdf;\n            vec3 dir = sampleSpecular(alb, rough, metal, F0, hit.norm, -rd, rng, brdf);\n            if (dot(dir, hit.norm) > 0.0) {\n                col += texture(iChannel1, dir).rgb * brdf;\n                continue;\n            }\n        }\n    }\n    col /= float(samples);\n    \n    if (!h) col = texture(iChannel1, rd).rgb;\n    \n    col += lastcol.rgb;\n    temp += 1.0;\n\t\n\tfragColor = vec4(col, temp);\n}","name":"Buffer A","description":"","type":"buffer"}]}