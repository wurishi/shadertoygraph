{"ver":"0.1","info":{"id":"dtlGzH","date":"1671334330","viewed":218,"name":"Projected water in cubemap","username":"ianertson","description":"Using some noise to produce water","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["water","cubemap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265359;\n\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nvec3 unreal(vec3 x) {\n  return x / (x + 0.155) * 1.019;\n}\n\n\nvec3 toLinear(vec3 sRGB)\n{\n    bvec3 cutoff = lessThan(sRGB, vec3(0.04045));\n    vec3 higher = pow((sRGB + vec3(0.055))/vec3(1.055), vec3(2.4));\n    vec3 lower = sRGB/vec3(12.92);\n\n    return mix(higher, lower, cutoff);\n}\nvec3 background(in vec2 fragCoord) {\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n  vec2 orientation = vec2(cos(iTime*0.2)*0.5, 0.1 + min(0.3,  max(0.2, 0.01 + sin(iTime*0.5)*0.5)));\n\n  vec3 lp = vec3(0);\n  vec3 ro = vec3(0, 0, 3);\n  ro.yz *= rotate2d(mix(-PI/2., PI/2., orientation.y));\n  ro.xz *= rotate2d(mix(-PI, PI, orientation.x));\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1.0));\n  \n  vec3 col = texture(iChannel0, rd).rgb;\n  \n  col += luma(col) / 1.6;\n  \n   float d = max(0.0, dot(rd, vec3(0.0, -1.0, 0.0)));\n  \n  float no1 = texture(iChannel1, rd).r;\n  float no = texture(iChannel1, rd*PI*1.0+cos(0.2*iTime+no1)).r;\n  vec3 norm = normalize(vec3(no1, no, fract(col.r+no)));\n  vec3 point = ro + (cross(rd, vec3(-1.0, 0.0, 0.0)));\n  vec3 vdir = normalize(ro - point) * -1.0;\n  vec3 v = reflect(vdir, norm);\n  \n  vec3 distCol = texture(iChannel0, v).rgb;\n  \n \n  \n  col = mix(col, distCol, d);\n  no *= d;\n  \n  col = toLinear(col);\n  col = unreal(col);\n  col = pow(col, vec3(1.0 / (0.3 + no)));\n  \n  col.r = max(0.0, col.r - (no*0.4));\n  col.g = max(0.0, col.g - (no*0.1));\n  \n  col = mix(col, col*col, no*0.5);\n  \n  col += (luma(col) * no) / (PI*2.0);\n\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n      vec2 mouseUV = iMouse.xy/iResolution.xy;\n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5);\n    \n    uv = 0.5 + uv * 0.5;\n\n\n  \nvec3 col = background(fragCoord);\n\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}