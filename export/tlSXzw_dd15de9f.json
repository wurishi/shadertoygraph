{"ver":"0.1","info":{"id":"tlSXzw","date":"1565370444","viewed":232,"name":"Cube in cube in cube in cube","username":"TambakoJaguar","description":"Just a simple shader to show that one can play with buffers to map other renders to cube faces.\nAt least it looks funny!","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["cube","colorful","mapping","rotating","face","buffer","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 obj_color(vec3 norm, vec3 pos)\n{\n    vec3 normr = abs(rotateVec2(norm));\n    vec3 posr = rotateVec2(pos);\n    \n    vec2 uv = getCubeUV(normr, posr, iResolution.y/iResolution.x);\n    vec4 ct = texture(iChannel0, uv);\n    \n    return mix (ct.rgb, normr, ct.a);\n}\n\nRenderData trace0(vec3 tpos, vec3 ray)\n{\n    vec2 t = trace(tpos, ray, maxdist);\n    float tx = t.x;\n    vec3 col;\n    float objnr = t.y;\n    \n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    if (tx<maxdist*0.65)\n    {\n        norm = getNormal(pos, normdelta);\n\n        // Coloring\n        col = obj_color(norm, pos);\n      \n        // Shading\n        col = ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n        return RenderData(vec4(col, 0.), pos, norm, objnr);\n    }\n    else\n        return RenderData(vec4(col, 1.), pos, norm, objnr);\n}\n\nvec4 render(vec2 fragCoord)\n{\n\n  vec2 uv = fragCoord.xy / iResolution.xy; \n  uv = uv*2.0 - 1.0;\n  uv.x*= iResolution.x / iResolution.y;\n\n  vec3 ray = GetCameraRayDir(uv, camdir, fov);\n    \n  RenderData traceinf = trace0(campos, ray);\n  vec4 col = traceinf.col;\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    init();\n    time = iTime;\n    cubeRot = cubeRot0;\n    \n    // Antialiasing\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    fragColor = vs/vec4(aasamples*aasamples);\n    \n    //vec2 uv = fragCoord.xy / iResolution.xy;\n    //fragColor = texture(iChannel0, uv);    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n\"Cube in cube in cube in cube\" by Emmanuel Keller aka Tambako - August 2019\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\nstruct Lamp\n{\n  vec3 position;\n  vec3 color;\n  float intensity;\n  float attenuation;\n};\n\nstruct RenderData\n{\n  vec4 col;\n  vec3 pos;\n  vec3 norm;\n  float objnr;\n};\n    \nLamp lamps[3];\n\nvec3 posr;\nfloat time;\nvec3 cubeRot0 = vec3(0.15, 0.3, 0.55);\nvec3 cubeRot;\n\nvec3 campos = vec3(0., 0., 9.);\nvec3 camdir = vec3(0., 0., -1.);\nfloat fov = 4.9;\n\nconst vec3 ambientColor = vec3(0.2);\nconst float ambientint = 0.16;\nconst vec3 speccolor = vec3(0.95, 0.97, 1.);\n\n#define specular\nconst float specint = 0.09;\nconst float specshin = 4.5;\n\nconst float normdelta = 0.0001;\nconst float maxdist = 17.;\n\nconst float cfl = 1.0;\nconst float cr = 0.04;\nconst float fz = 0.53;\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.8;\nconst int aasamples = 2;\n\nvoid init()\n{\n    lamps[0] = Lamp(vec3(-2., 4.5, 10.), vec3(1., 1., 1.), 6.4, 0.1);\n    lamps[1] = Lamp(vec3(9., -2.5, 4.), vec3(0.77, 0.87, 1.0), 4.5, 0.1);\n    lamps[2] = Lamp(vec3(-9., -5., -4.), vec3(1.0, 0.6, 0.5), 2.2, 0.1);    \n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) + vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) - vect.y*cos(angle);\n    return rv;\n}\n\nvec3 rotateVec2(vec3 posr)\n{\n    vec3 rv = cubeRot*time;\n    posr.yz = rotateVec(posr.yz, rv.x);\n    posr.zx = rotateVec(posr.zx, rv.y);\n    posr.xy = rotateVec(posr.xy, rv.z);\n    \n    return posr;\n}\n\nvec2 getCubeUV(vec3 normr, vec3 posr, float resFac)\n{\n    vec2 uv = fz*(normr.x>normr.y + normr.z?posr.yz:(normr.y>normr.z + normr.x?posr.zx:posr.xy));\n    uv.x*= resFac/cfl;\n    uv+= vec2(0.5);\n    \n    return uv;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat map(vec3 pos)\n{   \n    vec3 posr = rotateVec2(pos);\n    \n    return sdRoundBox(posr, vec3(1.), cr);\n}\n\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 1.0;\n    vec3 pos;\n    float dist;\n    \n  \tfor (int i = 0; i < 45; ++i)\n    {\n    \tpos = ray*t + cam;\n    \tdist = map(pos);\n        if (dist>maxdist || abs(dist)<0.0001)\n            break;\n        t+= dist;\n  \t}\n        \n  \treturn vec2(t, dist);\n}\n\n// From https://www.shadertoy.com/view/MstGDM\nvec3 getNormal(vec3 pos, float e)\n{\n    vec2 q = vec2(0, e);\n    vec3 norm = normalize(vec3(map(pos + q.yxx) - map(pos - q.yxx),\n                          map(pos + q.xyx) - map(pos - q.xyx),\n                          map(pos + q.xxy) - map(pos - q.xxy)));\n    return norm;\n}\n\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, float objnr)\n{\n\tvec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n    vec3 nlcol = normalize(lamp.color);\n    float dnp = dot(norm, pli);\n      \n    // Diffuse shading\n    vec3 col = ocol*nlcol*lamp.intensity*smoothstep(-0.1, 1., dnp);\n    \n    // Specular shading\n    #ifdef specular\n    col+= speccolor*nlcol*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    return col;\n}\n\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, float objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<3; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol, objnr);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 obj_color(vec3 norm, vec3 pos)\n{\n    vec3 normr = rotateVec2(norm);\n    return vec3(1.) - abs(normr);\n}\n\nRenderData trace0(vec3 tpos, vec3 ray)\n{\n    vec2 t = trace(tpos, ray, maxdist);\n    float tx = t.x;\n    vec3 col;\n    float objnr = t.y;\n    \n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    if (tx<maxdist*0.65)\n    {\n        norm = getNormal(pos, normdelta);\n\n        // Coloring\n        col = obj_color(norm, pos);\n      \n        // Shading\n        col = ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n        \n        return RenderData(vec4(col, 0.), pos, norm, objnr);\n    }\n    else\n        return RenderData(vec4(col, 1.), pos, norm, objnr);\n}\n\nvec4 render(vec2 fragCoord)\n{\n\n  vec2 uv = fragCoord.xy / iResolution.xy; \n  uv = uv*2.0 - 1.0;\n  uv.x*= iResolution.x / iResolution.y;\n\n  vec3 ray = GetCameraRayDir(uv, camdir, fov);\n    \n  RenderData traceinf = trace0(campos, ray);\n  vec4 col = traceinf.col;\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    init();\n    time = iTime;\n    cubeRot = -cubeRot0;\n    \n    // Antialiasing\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    fragColor = vs/vec4(aasamples*aasamples);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec3 obj_color(vec3 norm, vec3 pos)\n{\n    vec3 normr = abs(rotateVec2(norm));\n    vec3 posr = rotateVec2(pos);\n    \n    vec2 uv = getCubeUV(normr, posr, iResolution.y/iResolution.x);\n    vec4 ct = texture(iChannel0, uv);\n    \n    return mix (ct.rgb, normr, ct.a);\n}\n\nRenderData trace0(vec3 tpos, vec3 ray)\n{\n    vec2 t = trace(tpos, ray, maxdist);\n    float tx = t.x;\n    vec3 col;\n    float objnr = t.y;\n    \n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    if (tx<maxdist*0.65)\n    {\n        norm = getNormal(pos, normdelta);\n\n        // Coloring\n        col = obj_color(norm, pos);\n      \n        // Shading\n        col = ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n        \n        return RenderData(vec4(col, 0.), pos, norm, objnr);\n    }\n    else\n        return RenderData(vec4(col, 1.), pos, norm, objnr);\n}\n\nvec4 render(vec2 fragCoord)\n{\n\n  vec2 uv = fragCoord.xy / iResolution.xy; \n  uv = uv*2.0 - 1.0;\n  uv.x*= iResolution.x / iResolution.y;\n\n  vec3 ray = GetCameraRayDir(uv, camdir, fov);\n    \n  RenderData traceinf = trace0(campos, ray);\n  vec4 col = traceinf.col;\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    init();\n    time = iTime;\n    cubeRot = cubeRot0;\n    \n    // Antialiasing\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    fragColor = vs/vec4(aasamples*aasamples);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"vec3 obj_color(vec3 norm, vec3 pos)\n{\n    vec3 normr = abs(rotateVec2(norm));\n    vec3 posr = rotateVec2(pos);\n    \n    vec2 uv = getCubeUV(normr, posr, iResolution.y/iResolution.x);\n    vec4 ct = texture(iChannel0, uv);\n    \n    return mix (ct.rgb, vec3(1.) - normr, ct.a);\n}\n\nRenderData trace0(vec3 tpos, vec3 ray)\n{\n    vec2 t = trace(tpos, ray, maxdist);\n    float tx = t.x;\n    vec3 col;\n    float objnr = t.y;\n    \n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    if (tx<maxdist*0.65)\n    {\n        norm = getNormal(pos, normdelta);\n\n        // Coloring\n        col = obj_color(norm, pos);\n      \n        // Shading\n        col = ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n        \n        return RenderData(vec4(col, 0.), pos, norm, objnr);\n    }\n    else\n        return RenderData(vec4(col, 1.), pos, norm, objnr);\n}\n\nvec4 render(vec2 fragCoord)\n{\n\n  vec2 uv = fragCoord.xy / iResolution.xy; \n  uv = uv*2.0 - 1.0;\n  uv.x*= iResolution.x / iResolution.y;\n\n  vec3 ray = GetCameraRayDir(uv, camdir, fov);\n    \n  RenderData traceinf = trace0(campos, ray);\n  vec4 col = traceinf.col;\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    init();\n    time = iTime;\n    cubeRot = -cubeRot0;\n    \n    // Antialiasing\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    fragColor = vs/vec4(aasamples*aasamples);\n}","name":"Buffer C","description":"","type":"buffer"}]}