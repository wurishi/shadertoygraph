{"ver":"0.1","info":{"id":"llsfD8","date":"1511831599","viewed":2316,"name":"CRT Video Effect","username":"mattresn","description":"Simple CRT video effect shader","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["effects"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Simple CRT Video Effect\n// @author\tMatt Halford\tmatt@resn.co.nz\n\n// Applys a CRT effect including bulge distortion, vignette, scan lines, indirect moire effects,\n// color abberation near edges and video rolling effect\n\n\n// Util Functions\n\n// getCenterDistance\n// Gets Distance between points in the coord space and the center of that space\n// @param\tvec2\tcoord\t\tcoordinate space to caculate distance to center\n// @return\tfloat\t\t\t\tdistance from center of plane (0 in center, -1 and 1 at edges)\nfloat getCenterDistance(vec2 coord)\n{\n    return distance(coord, vec2(0.5)) * 2.0; //return difference between point on screen and the center with -1 and 1 at either edge\n}\n\n\n// Sample Distortion Functions\n\n// videoRollCoords\n// Rolls Coordinates to perform an old fashioned CRT rolling effect\n// @param\tvec2\tcoord\t\tcoordinates to distort\n// @param\tfloat\tspeed\t\tspeed to translate image (loops per second)\n// @param\tfloat\tamount\t\tfraction of the period during which rolling occurs (0 - 1)\n// @param\tfloat\tperiod\t\tperiod of rolling effect repetition (in seconds)\n// @return\tvec2\t\t\t\tdistorted sample coordinates\nvec2 videoRollCoords(vec2 coord, float speed, float amount, float period)\n{\n    float scrolling = step(0.0, sin(iTime * 6.28 / period) * 0.5 + (-0.5 + amount)); //set scrolling to 1 if frequency sin wave is above 0\n    \n    coord.y -= iTime * speed * scrolling; //if scrolling offset y coord over time\n\tcoord = fract(coord); //keep coord to fractional component so not multiplying crazily when applying later coord distance comparisons \n    \n    return coord;\n}\n\n// bulgeCoords\n// Bulges Coordinates to perform a bulging lens effect\n// @param\tvec2\tcoord\t\tcoordinates to distort\n// @param\tvec2\tsourceCoord\tsource coordinate space to caculate distance to center\n// @param \tfloat\tbulgeAmount\tamount to bulge coordindates\n// @return\tvec2\t\t\t\tdistorted sample coordinates\nvec2 bulgeCoords(vec2 coord, vec2 sourceCoord, float bulgeAmount)\n{\n    float centerDist = getCenterDistance(sourceCoord);\n    \n    coord.xy -= vec2(0.5); //reposition so scaling performed from center of image\n    \n    coord.xy *= 1.0 + centerDist * bulgeAmount; //scale up coordinates the further from center they are\n    coord.xy *= 1.0 - bulgeAmount; //scale down oversampling to reduce tiling\n    \n    coord.xy += vec2(0.5); //restore position to center of view\n    \n    return coord;\n}\n\n\n// Sample Functions\n\n// sampleRGBVignette\n// Samples texture pixels with RGB color abberation shift towards the edges of the view, simulating lens color abberation\n// @param\tsampler2D\tsource\t\tsource texture to sample\n// @param\tvec2\t\tcoord\t\tcoordinates to distort\n// @param\tvec2\t\tsourceCoord\tsource coordinate space to caculate distance to center\n// @param \tfloat\t\tamount\t\tamount to offset Green and Blue channels (B offset twice as far from R)\n// @param \tfloat\t\tpower\t\tbias of color abberation just towards edges of view (>= 1)\n// @return\tvec4\t\t\t\t\tresultant sample color with color RGB abberation\nvec4 sampleRGBVignette(sampler2D source, vec2 coord, vec2 sourceCoord, float amount, float power)\n{\n    float centerDist = getCenterDistance(sourceCoord);\n    centerDist = pow(centerDist, power); //bias distance from center to ramp up steeper towards edges\n    \n    vec2 sampleCoord = coord;\n    vec4 outputColor = texture(source, fract(sampleCoord)); //get default sample image (for R)\n    \n    sampleCoord = bulgeCoords(coord, sourceCoord, amount * centerDist); //bulge sample coordinates by amount, multiply by center distance to reduce effect in center\n    outputColor.g = texture(source, fract(sampleCoord)).g; //sample Green amount by G color abberation\n    \n    sampleCoord = bulgeCoords(coord, sourceCoord, amount * 2.0 * centerDist); //bulge sample coordinates by double amount for Blue (twice as far from R as G)\n    outputColor.b = texture(source, fract(sampleCoord)).b; //sample Blue amount by B color abberation\n    \n    return outputColor;\n}\n\n\n//Color Effect Functions\n\n// applyScanLines\n// Applys darkened horizontal scan line gaps to simulate a CRT effect\n// @param\tvec4\t\tcolor\t\toriginal color value\n// @param\tvec2\t\tcoord\t\tcoordinate space for scan lines (could be pre-distorted, e.g. with bulgeCoords)\n// @param\tfloat\t\tnumber\t\tnumber of scan lines across vertical view\n// @param \tfloat\t\tamount\t\tamount to darken gaps between scan lines (0 - 1)\n// @param \tfloat\t\tpower\t\tbias of illuminated scan lines to gaps (> 1 = wider bright lights, < 1 wider gaps)\n// @param \tfloat\t\tdrift\t\tspeed of vertical drift in line positions (loops per second)\n// @return\tvec4\t\t\t\t\tresultant color with scan line gaps applied\nvec4 applyScanLines(vec4 color, vec2 coord, float number, float amount, float power, float drift)\n{\n    coord.y += iTime * drift; //animate scrolling coordinates (great for shifting moire effects with high number of lines)\n    \n    float darkenAmount = 0.5 + 0.5 * cos(coord.y * 6.28 * number); //get darken amount as cos wave between 0 and 1, over number of lines across height\n    darkenAmount = pow(darkenAmount, power); //bias darkenAmount towards wider light areas\n        \n    color.rgb -= darkenAmount * amount; //darken rgb colors by given gap darkness amount\n        \n    return color;\n}\n\n// applyVignette\n// Applys darkened vignette to edges of view\n// @param\tvec4\t\tcolor\t\toriginal color value\n// @param\tvec2\t\tcoord\t\tsource coordinate space to caculate distance to center\n// @param \tfloat\t\tamount\t\tamount to darken gaps vignette edges\n// @param \tfloat\t\tscale\t\tscale of vignette outer ellipse (1 = darkest at ellipse incribing view)\n// @param \tfloat\t\tpower\t\tbias vignette fade towards edges of ellipse (>= 1)\n// @return\tvec4\t\t\t\t\tresultant color with vignette applied\nvec4 applyVignette(vec4 color, vec2 sourceCoord, float amount, float scale, float power)\n{\n    float centerDist = getCenterDistance(sourceCoord);\n    \n    float darkenAmount = centerDist / scale; //get amount to darken current fragment by scaled distance from center\n    \n    darkenAmount = pow(darkenAmount, power); //bias darkenAmount towards edges of distance\n    \n    darkenAmount = min(1.0, darkenAmount); //clamp maximum darkenAmount to 1 so amount param can lighten outer regions of vignette \n    \n    color.rgb -= darkenAmount * amount; //darken rgb colors by given vignette amount\n    \n    return color;\n}\n\n\n// Main Fragment Processing\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 sourceCoord = fragCoord.xy / iResolution.xy; //get sourceCoords in range 0 - 1\n    \n    vec2 sampleCoord = sourceCoord;\n    \n    sampleCoord = videoRollCoords(sampleCoord, 5.0, 0.2, 2.0); //apply video rolling effect to sample coords\n    sampleCoord = bulgeCoords(sampleCoord, sourceCoord, 0.1); //apply bulge effect to sample coords\n    \n    //vec4 outputColor = texture(iChannel0, fract(sampleCoord)); //to sample without RGB color abberation\n    \n    vec4 outputColor = sampleRGBVignette(iChannel0, sampleCoord, sourceCoord, 0.1, 2.0); //sample bulged coords with color abberation\n    \n    float vignetteAmount = 1.2 + 0.05 * sin(iTime * 50.0); //set a fluctuating vignette intensity\n    outputColor = applyVignette(outputColor, sourceCoord, vignetteAmount, 2.0, 2.5); //apply vignette to sampled color\n    \n    vec2 scanLineCoord = bulgeCoords(sourceCoord, sourceCoord, 0.2);  //get bulged coords to bulge scan lines\n    outputColor = applyScanLines(outputColor, scanLineCoord, 150.0, 0.25, 2.0, 0.01); //apply scan lines (with bulged coords)\n    \n    //outputColor = texture(iChannel0, fract(sourceCoord)); //to preview texture without effects\n    \n    fragColor = outputColor; //output resultant fragment color\n}","name":"Image","description":"","type":"image"}]}