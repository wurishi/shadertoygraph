{"ver":"0.1","info":{"id":"DtjBDR","date":"1694027038","viewed":35,"name":"torus surface by torus sdf","username":"tomcat7479","description":"通过环面的SDF函数实现的三维环面","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","torussdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n    R^3中的环面的SDF函数\n    环面的几种数学定义：\n        1. 拓扑定义\n           与S^1 x S^2同胚的曲面称为环面，其中S^1表示圆，S^2表示球面\n\n        2. 参数形式\n           环面可以参数式地定义为：\n                x(u,v) = (R + rcosv)cosu\n                y(u,v) = (R + rcosv)sinu\n                z(u,v) = rsinv\n           其中u, v ∈ [0, 2π], R是管子的中心到画面的中心的距离， r是圆管的半径。\n        3. 隐式方程\n           [(R - sqrt(x^2 + y^2))]^2 + z^2 = r^2\n           隐式方程的推导非常简单：半径为r的圆面绕着z轴距离为R的位置旋转一周得到环面\n\n    推导环面的SDF函数:\n        从环面的隐式方程：F(x,y,z) = [(R - sqrt(x^2 + y^2))]^2 + z^2 - r^2\n        F(x,y,z) = 0: 在环面上\n        F(x,y,z) < 0: 在环面内(实际上可以想象成环面的切面，实际就是一个半径为r的圆面)\n        F(x,y,z) > 0:: 在环面外        \n    所以按照这种方式其SDF就非常简单了\n    注意一下：shader中的坐标系和一般数学中定义的R^3笛卡尔坐标系的轴的对应关系是有问题，我们需要按照shader这种的\n    坐标系来看环面方程    \n*/\n\n#define min_iter_distance 0.1\n#define max_iter_distance 20.0\n#define iter_count 150\n#define iter_precision 1e-4\n#define N 3\n\nvec2 fix(in vec2 fragCoord) {\n    return (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\n\nfloat sdfTorus( vec3 p, float R, float r) {\n  vec2 q = vec2(length(p.xz) - R, p.y);\n  return min(length(q) - r, p.y + 10.0 * r);\n}   \n\n\nvec3 calNormal(vec3 p, float R, float r) {\n    const float h = 1e-4;\n    const vec2 k = vec2(1.0, -1.0);\n    vec3 part1 = k.xyy * sdfTorus(p + k.xyy * h, R, r);\n    vec3 part2 = k.yyx * sdfTorus(p + k.yyx * h, R, r);\n    vec3 part3 = k.yxy * sdfTorus(p + k.yxy * h, R, r);\n    vec3 part4 = k.xxx * sdfTorus(p + k.xxx * h, R, r);\n    return normalize(part1 + part2 + part3 + part4);\n}\n\n\nfloat rayMarching(vec3 ray_o, vec3 ray_d, float R, float r) {\n    float t = min_iter_distance;\n    for (int i = 0; i < iter_count; i++) {\n        vec3 p = ray_o + t * ray_d;\n        float d = sdfTorus(p, R, r);\n        if (d < iter_precision) {\n            break;\n        }\n        t += d;\n    }\n    return t;\n}\n\n\nvec3 render(vec2 uv) {\n    vec3 light_color = vec3(1.0);\n    vec3 light_pos = vec3(3.0, 4.0 ,3.0);\n    vec3 torus_color = vec3(0.91, 0.64, 0.18);\n    float ambient_strength = 0.31;\n    float diffuse_strength = 0.91;\n    float specular_strength = 0.88;\n    float specular_lightness = 80.0;\n    float R = 0.7;\n    float r = 0.18;\n\n    vec3 ray_o = vec3(1.5 * cos(iTime * 2.0), 1.0 * sin(iTime), 5.5);\n    vec3 ray_d = normalize(vec3(uv, 0.0) - ray_o);\n    float t = rayMarching(ray_o, ray_d, R, r);\n    vec3 color = vec3(0.0);\n    if (t < max_iter_distance) {\n        vec3 p = ray_o + t * ray_d;\n        vec3 n = normalize(calNormal(p, R, r));\n        \n        vec3 ambient = light_color * torus_color * ambient_strength;\n\n        float dif_cos = clamp(dot(n, normalize(light_pos - p)), 0.0, 1.0);\n        vec3 diffuse = light_color * dif_cos * diffuse_strength;\n\n        vec3 refL = reflect(light_pos - p, n);\n        float spec_cos = clamp(dot(normalize(refL), normalize(ray_d)), 0.0, 1.0);\n        vec3 specular = light_color * pow(spec_cos, specular_lightness) * specular_strength;\n\n        color = ambient + specular + diffuse;\n    }\n\n    return color;\n}\n\n\nvec3 after_smooth(in vec2 fragCoord) {\n    vec3 color = vec3(0.0);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            vec2 offset = vec2(float(i), float(j)) / float(N);\n            offset = 2.0 * (offset - 0.5);\n            vec2 uv = fix(fragCoord + offset);\n            color += render(uv);\n        }\n    }\n    return color / float(N * N);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(after_smooth(fragCoord), 1.0);\n}","name":"Image","description":"","type":"image"}]}