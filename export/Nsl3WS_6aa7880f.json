{"ver":"0.1","info":{"id":"Nsl3WS","date":"1616466837","viewed":105,"name":"PBR sphere demo","username":"romeosoft","description":"PBR","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*********************************************************************\n              PBR simple demo\nThe formula from:              \nhttps://www.jordanstevenstechart.com/physically-based-rendering\n    \n*********************************************************************/\n#define ROT(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\nconst float pi = 3.1415926;\n\n // The radius of the ball\nconst float R = 1.0;\n// light direction\nvec3 lightDirection = vec3(-1.414 / 2.,-1.414 / 2.,0.);\n\n// ----------------------------------------------------\nfloat MixFunction(float i, float j, float x) {\n\t return  j * x + i * (1.0 - x);\n}\nfloat SchlickFresnel(float i){\n    float x = clamp(1.0-i, 0.0, 1.0);\n    float x2 = x*x;\n    return x2*x2*x;\n}\n//normal incidence reflection calculation\nfloat F0 (float NdotL, float NdotV, float LdotH, float roughness){\n    float FresnelLight = SchlickFresnel(NdotL); \n    float FresnelView = SchlickFresnel(NdotV);\n    float FresnelDiffuse90 = 0.5 + 2.0 * LdotH*LdotH * roughness;\n    return  MixFunction(1., FresnelDiffuse90, FresnelLight) * MixFunction(1., FresnelDiffuse90, FresnelView);\n}\n\n\n// The following are from https://www.shadertoy.com/view/4dS3Wd\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\nfloat noise(float x) { float i = floor(x); float f = fract(x); float u = f * f * (3.0 - 2.0 * f); return mix(hash(i), hash(i + 1.0), u); }\nfloat noise(vec2 x) { vec2 i = floor(x); vec2 f = fract(x); float a = hash(i); float b = hash(i + vec2(1.0, 0.0)); float c = hash(i + vec2(0.0, 1.0)); float d = hash(i + vec2(1.0, 1.0)); vec2 u = f * f * (3.0 - 2.0 * f); return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y; }\nfloat noise(vec3 x) { const vec3 step = vec3(110, 241, 171); vec3 i = floor(x); vec3 f = fract(x); float n = dot(i, step); vec3 u = f * f * (3.0 - 2.0 * f); return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x), mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y), mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x), mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z); }\n\n#define DEFINE_FBM(name, OCTAVES) float name(vec3 x) { float v = 0.0; float a = 0.5; vec3 shift = vec3(100); for (int i = 0; i < OCTAVES; ++i) { v += a * noise(x); x = x * 2.0 + shift; a *= 0.5; } return v; }\nDEFINE_FBM(fbm3, 3)\nDEFINE_FBM(fbm5, 5)\nDEFINE_FBM(fbm6, 6)\n\n// =====================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pp = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    float eyer = 2.0;\n    float eyea = -((iMouse.x) / iResolution.x) * pi * 2.0;\n    float eyef = ((iMouse.y / iResolution.y)-0.24) * pi * 2.0;\n    \n\tvec3 cam = vec3(\n        eyer * cos(eyea) * sin(eyef),\n        eyer * cos(eyef),\n        eyer * sin(eyea) * sin(eyef));\n    \n\tvec3 front = normalize(- cam);\n\tvec3 left = normalize(cross(normalize(vec3(0.0,1,-0.01)), front));\n\tvec3 up = normalize(cross(front, left));\n\tvec3 v = normalize(front*1.5 + left*pp.x + up*pp.y);\n    \n    vec3 p = cam;\n    \n    float dt = 0.0025;\n    vec3 cor = vec3(0.0);\n    \n    float e = 0.05f;\n    for(int i = 0; i < 100; i ++)\n    {\n        float r = length(p);\n        dt = mix(0.001,0.04, smoothstep(0.,1.,(r - R) / 0.1));\n\t\t\n        if(r < R)\n        {  \n             //cor = mix(vec3(0.,0.0, 0.05),vec3(0.4,0.65,1.0),clamp(dot(normalize(p),lightDirection), 0., 1.));\n               \n             vec3 normalDirection = normalize(p);\n             \n             float NdotL = max(0.0, dot( normalDirection, lightDirection ));\n             \n             vec3 halfDirection = normalize(v+lightDirection); \n             \n             float NdotH =  max(0.0,dot( normalDirection, halfDirection));\n\n             float NdotV =  max(0.0,dot( normalDirection, v));\n             \n             float LdotH =  max(0.0,dot(lightDirection, halfDirection));\n             \n             float roughness = 0.5;\n             \n             float deta1 = fbm5(p*10.) * mix(1., 0.5, r / R);\n             float deta2 = fbm3(p*5.) * mix(1., 0.5, r / R);\n             cor += e*mix(vec3(0.,0.0, 0.05),vec3(0.3*deta2,deta1 * 0.4,0.4),F0( NdotL, NdotV, LdotH, roughness));\n             \n             e *= 0.99;\n             \n           //break;\n        }\n        p += v * dt;\n    }\n    fragColor = vec4(cor,1.0);\n}","name":"Image","description":"","type":"image"}]}