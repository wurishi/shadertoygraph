{"ver":"0.1","info":{"id":"XXdXRj","date":"1719279921","viewed":18,"name":"ball_sophytoeat","username":"sophytoeat","description":"None","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["ball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray\n{\n    vec3 org;\n    vec3 dir;\n};\n\nstruct Hit\n{\n    float distanceToHitpoint;\n    vec3 normal;\n};\n\n// 各種パラメータの例\nfloat FilmWidth() { return iResolution.x / 100.0; }\nfloat FilmHeight() { return iResolution.y / 100.0;  }\nfloat FilmDistance() { return 8.0; }\n\nvec3 CameraFrom() { return vec3(0, 2.0, 3.0); }\nvec3 CameraTo() { return vec3(0.2, 0.7, 0.2); }\nvec3 CameraUp() { return vec3(0.0, 1.0, 0.0); }\n\nfloat LargeFloat() { return 1e+6; }\n\n// 正規直交基底を計算する関数の例\nvoid creatnormalize(vec3 from, vec3 to, vec3 up, out vec3 u, out vec3 v, out vec3 w, out vec3 e)\n{\n    // TODO: ベクトル正規化normalize()や外積cross()を用いて実装する。\n    // カメラからの方向を正規化\n    w = normalize(from - to);\n    u = normalize(cross(up, w));\n    v = cross(w, u);\n    e = from;\n}\n\nvec3 convertCamera(vec2 pixelCoordinate)\n{\n    // TODO: ピクセル座標をカメラ座標系に変換する。\n    float filmWidth = FilmWidth();\n    float filmHeight = FilmHeight();\n    float filmDistance = FilmDistance();\n\n    float x = filmWidth - 2.0 * ((pixelCoordinate.x + 0.5) / iResolution.x) * filmWidth;\n    float y = filmHeight - 2.0 * ((pixelCoordinate.y + 0.5) / iResolution.y) * filmHeight;\n    float z = filmDistance;\n\n    return vec3(x, y, z);\n}\n\nRay generateCameraRay(vec2 pixelCoordinate)\n{\n    // TODO: 以下を実装する。\n    // 1. ピクセル座標をカメラ座標系に変換\n    // 2. カメラパラメータからカメラ座標系の正規直交基底を計算。\n    // 3. ピクセル座標を基底を用いてワールド座標系に変換\n    // 4. カメラレイを計算。\n    vec3 cameraPos = CameraFrom();\n    vec3 targetPos = CameraTo();\n    vec3 upDir = CameraUp();\n\n    vec3 u, v, w, e;\n    creatnormalize(cameraPos, targetPos, upDir, u, v, w, e);\n\n    vec3 camera_pixel = convertCamera(pixelCoordinate);\n    vec3 world_pixel = camera_pixel.x * u + camera_pixel.y * v + camera_pixel.z * w;\n\n    Ray ray;\n    ray.org = e;\n    ray.dir = normalize(e - world_pixel);\n    return ray;\n}\n\nbool intersectToSphere(vec3 center, float radius, Ray ray, out Hit hit)\n{\n    // TODO: レイと球の交差判定を実装する。\n    // 二次方程式の解の計算に帰着する。\n    vec3 oc = ray.org - center;\n    float a = dot(ray.dir, ray.dir);\n    float b = 2.0 * dot(oc, ray.dir);\n    float c = dot(oc, oc) - radius * radius;\n    float discri = b * b - 4.0 * a * c;\n    \n    if (discri < 0.0) return false;\n    \n    if (discri == 0.0) return true;\n\n    float t1 = (-b - sqrt(discri)) / (2.0 * a);\n    float t2 = (-b + sqrt(discri)) / (2.0 * a);\n    \n\n    if (t1 > 0.0 && t1 < hit.distanceToHitpoint)\n    {\n        hit.distanceToHitpoint = t1;\n        hit.normal = normalize((ray.org + t1 * ray.dir) - center);\n        return true;\n    }\n    \n    if (t2 > 0.0 && t2 < hit.distanceToHitpoint)\n    {\n        hit.distanceToHitpoint = t2;\n        hit.normal = normalize((ray.org + t2 * ray.dir) - center);\n        return true;\n    }\n\n    return false;\n}\n\nbool intersect(Ray ray, out Hit hit)\n{\n    hit.distanceToHitpoint = LargeFloat();\n\n    // TODO: intersectToSphere を用いて具体的な球との交差判定を行う。\n    vec3 sphereCenter = vec3(0.0, 0.0, 0.0);\n    float sphereRadius = 1.0;\n\n    return intersectToSphere(sphereCenter, sphereRadius, ray, hit);\n}\n\nvec3 shade(Ray ray, Hit hit)\n{\n    // TODO: なんらかのシェーディングを行う。\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n    float diffuse = max(dot(hit.normal, lightDir), 0.0);\n    return vec3(diffuse);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Ray ray = generateCameraRay(fragCoord);\n     \n    Hit hit;\n    if (intersect(ray, hit))\n    {\n        fragColor = vec4(shade(ray, hit), 1.0);\n    }\n    else\n    {\n        fragColor = vec4(0.0);\n    }\n}","name":"Image","description":"","type":"image"}]}