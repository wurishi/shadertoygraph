{"ver":"0.1","info":{"id":"ws3fDB","date":"1605881665","viewed":123,"name":"Stable random normalized vec3","username":"delfigamer","description":" Based on https://www.shadertoy.com/view/wdcBWS, but extended to handle 3-dimensional vectors.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["hash","rand","stable"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// from https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl by Spatial\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat constructFloat( uint uval )\n{\n    //const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieee_mantissa = (~0u << 9u) >> 9u; // binary32 mantissa bitmask (23 lower bits)\n    //const uint ieee_one      = 0x3F800000u; // 1.0 in IEEE binary32\n    const uint ieee_one    = floatBitsToUint(1.0f); // should be exactly thes ame\n\n    uval &= ieee_mantissa;                     // Keep only mantissa bits (fractional part)\n    uval |= ieee_one;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( uval );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\nvec3 constructFloat3(uvec3 val)\n{\n    return vec3(constructFloat(val.x), constructFloat(val.y), constructFloat(val.z));\n}\n\nuint hashUint( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\nuvec3 hash33UintA(uvec3 seed)\n{\n    uvec3 res;\n    res.x = hashUint(seed.x);\n    res.y = hashUint(seed.y ^ res.x);\n    res.z = hashUint(seed.z ^ res.y);\n    res.x = hashUint(seed.x ^ res.z);\n    res.y = hashUint(seed.y ^ res.x);\n    return res;\n}\n\nuvec3 hash33UintB(uvec3 seed)\n{\n    uvec3 res;\n    res.x = hashUint(hashUint(hashUint(seed.x) ^ seed.y) ^ seed.z);\n    res.y = hashUint(hashUint(hashUint(seed.y) ^ seed.z) ^ seed.x);\n    res.z = hashUint(hashUint(hashUint(seed.z) ^ seed.x) ^ seed.y);\n    return res;\n}\n\nvec3 hash33A(vec3 seed)\n{\n    uvec3 seed_uvec3 = uvec3(floatBitsToUint(seed.x), floatBitsToUint(seed.y), floatBitsToUint(seed.z));\n    uvec3 hash_uvec3 = hash33UintA(seed_uvec3);\n    return constructFloat3(hash_uvec3);\n}\n\nvec3 hash33B(vec3 seed)\n{\n    uvec3 seed_uvec3 = uvec3(floatBitsToUint(seed.x), floatBitsToUint(seed.y), floatBitsToUint(seed.z));\n    uvec3 hash_uvec3 = hash33UintB(seed_uvec3);\n    return constructFloat3(hash_uvec3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 relCoord = fragCoord / iResolution.xy;\n    vec3 arg;\n    if (relCoord.x < 0.3f) {\n        arg = vec3(fragCoord.xy * 1e-12f, iTime * 1e-12f);\n    } else if (relCoord.x < 0.7) {\n        arg = vec3(fragCoord.xy, iTime);\n    } else {\n        arg = vec3(fragCoord.xy * 1e12f, iTime * 1e12f);\n    }\n    vec3 pixel_hash;\n    if (relCoord.y < 0.5f) {\n        pixel_hash = hash33A(arg);\n    } else {\n        pixel_hash = hash33B(arg);\n    }\n    if (relCoord.y < 0.2f || relCoord.y >= 0.8f) {\n        fragColor = (pixel_hash.x < 0.5f) ? vec4(1.0f) : vec4(0.0f); //check bias in distribution\n    //} else if (relCoord.y < 0.2f || relCoord.y >= 0.8f) {\n    //    fragColor = (pixel_hash.x < 0.0f || pixel_hash.x > 1.0f) ? vec4(1.0f, 0.0f, 0.0f, 1.0f) : vec4(0.0f, 1.0f, 0.0f, 1.0f); //check range\n    } else {\n\t    fragColor = vec4(pow(pixel_hash, vec3(1.0/2.2, 1.0/2.2, 1.0/2.2)), 1.0f);\n    }\n}","name":"Image","description":"","type":"image"}]}