{"ver":"0.1","info":{"id":"7tlGDs","date":"1623160311","viewed":51,"name":"Ray Marching - Intersection","username":"ChaosOfZen","description":"A basic ray marching shader.\nAdapted from: https://timcoster.com/2020/02/11/raymarching-shader-pt1-glsl/","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","intersection","boolean"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Adapted from: https://timcoster.com/2020/02/11/raymarching-shader-pt1-glsl/\n// The Art of Code: The Art Of Code Youtube\n// Inigo Quilez: https://iquilezles.org\n\n// Constants\n#define PI 3.1415925359\n//#define TWO_PI 6.2831852\n#define MAX_STEPS 100 // Mar Raymarching steps\n#define MAX_DIST 100. // Max Raymarching distance\n#define SURFACE_DIST .01 // Surface Distance\n \n///////////////////////\n// Boolean Operators\n///////////////////////\n \nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n \nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n \nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n//////////////////////////\n \nmat2 Rotate(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n \nfloat sphereSDF( vec3 p, float s ) {\n  return length(p)-s;\n}\n \nfloat boxSDF( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n \nfloat GetDist(vec3 p) \n{   \n    // Rotate the whole scene\n    p.xz *=Rotate(iTime / 2.0);\n   \n    // Sphere. xyz is position w is radius\n    vec4 s0 = vec4(0,1,0,1);\n    float sphereDist_0 = sphereSDF(p-s0.xyz,s0.w);\n     \n    // Box\n    vec3 b0s = vec3(.8,.8,.8); //box size\n    vec3 b0p = vec3(0,1,0); // box position\n    float boxDist_0 = boxSDF(p-b0p,b0s);\n   \n    // Plane\n    float planeDist  = p.y;\n \n    float d = 0.0;\n    d = intersectSDF(boxDist_0,sphereDist_0);\n    // Uncomment to view the box\n    //d = min(boxDist_0,sphereDist_0);\n    d = min(d,planeDist);\n \n    return d;\n}\n \nfloat RayMarch(vec3 ro, vec3 rd) \n{\n    float dO = 0.; //Distane Origin\n    for(int i=0;i<MAX_STEPS;i++)\n    {\n        vec3 p = ro + rd * dO;\n        float ds = GetDist(p); // ds is Distance Scene\n        dO += ds;\n        if(dO > MAX_DIST || ds < SURFACE_DIST) \n            break;\n    }\n    return dO;\n}\n \nvec3 GetNormal(vec3 p)\n{ \n    float d = GetDist(p); // Distance\n    vec2 e = vec2(.01,0); // Epsilon\n \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),  // e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n \n    return normalize(n);\n}\n \nfloat GetLight(vec3 p)\n{ \n    // Directional light\n    vec3 lightPos = vec3(5.*sin(iTime),5.,5.0*cos(iTime)); // Light Position\n    vec3 l = normalize(lightPos-p); // Light Vector\n    vec3 n = GetNormal(p); // Normal Vector\n   \n    float dif = dot(n,l); // Diffuse light\n    dif = clamp(dif,0.,1.); // Clamp so it doesnt go below 0\n \n    // Shadows\n    float d = RayMarch(p+n*SURFACE_DIST*2., l);\n     \n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n     \n    vec3 ro = vec3(0,1,-6); // Ray Origin/Camera\n    vec3 rd = normalize(vec3(uv.x,uv.y,1)); // Ray Direction\n   \n    float d = RayMarch(ro,rd); // Distance\n     \n    vec3 p = ro + rd * d;\n    float dif = GetLight(p); // Diffuse lighting\n    d*= .2;\n    vec3 color = vec3(dif);\n \n    // Set the output color\n    fragColor = vec4(color,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}