{"ver":"0.1","info":{"id":"slcBDH","date":"1663016815","viewed":77,"name":"AdvancedLoadingIcon1.0","username":"Roboian316","description":"Submission for Shader Project 1 (CS4710)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["cs4710"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float PI = 3.1415;\n\n//https://iquilezles.org/articles/distfunctions/\nfloat sdSphere( vec3 p, float r){\n  return length(p) - r;\n}\n\n//https://iquilezles.org/articles/distfunctions/\nfloat sdTorus(in vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Draw a \"shape\" (A sphere with a band on it, essentially)\nvec3 drawShape(vec3 colIn, vec2 uv, vec3 position, float r, vec3 rgb)\n{\n    vec3 colOut = colIn;\n    float t = 0.0;\n    float tdx = 0.0;\n    float tdy = 0.0;\n    \n    vec3 dir = normalize(vec3(uv.x, uv.y, r));\n    vec3 dirdx = normalize(vec3(uv.x+0.01, uv.y, r));\n    vec3 dirdy = normalize(vec3(uv.x, uv.y+0.01, r));\n    \n    // Draw a sphere\n    for( int i = 0; i < 10; i++){\n        vec3 pos = position + dir * t;\n        vec3 posdx = position + dirdx * tdx;\n        vec3 posdy = position + dirdy * tdy;\n        \n        float dist = sdSphere(pos, r);\n        float distdx = sdSphere(posdx, r);\n        float distdy = sdSphere(posdy, r);\n        \n        if(dist < 0.01 && distdx < 0.01 && distdy < 0.01){\n        \n            //find vector direction slightly downward on surface\n            vec3 CA = normalize(posdy - pos);\n            \n            //find vector direction slightly to the right on the surface\n            vec3 BA = normalize(posdx - pos);\n            \n            vec3 normal = cross(CA, BA);\n            \n            float lightMultiplier = 1.0;\n            \n            if(mod(iTime + 1.8, PI / 4.0) > 0.6) {\n                lightMultiplier = 20.0 - ((mod(iTime + 1.8, PI / 4.0) - 0.6) * 100.0);\n            }\n            \n            //a fixed light from the direction of the camera\n            vec3 lightDir = vec3(0.0,-0.5,lightMultiplier * texture(iChannel0, \n                                            vec2(uv + mod(uv.x + iTime, iResolution.x)), 0.0));\n            \n            // Apply the result to the output\n            colOut = rgb*dot(-lightDir,normal);\n            break;\n        }\n        t += dist;\n        tdx += distdx;\n        tdy += distdy;\n    }\n    \n    // Draw a band around the sphere\n    t = 0.0;\n    tdx = 0.0;\n    tdy = 0.0;\n    \n    for( int i = 0; i < 10; i++){\n        vec3 pos = position + dir * t;\n        vec3 posdx = position + dirdx * tdx;\n        vec3 posdy = position + dirdy * tdy;\n        \n        float dist = sdTorus(pos, vec2(3.8 * r / 3.0, 1.0));\n        float distdx = sdTorus(posdx, vec2(3.8 * r / 3.0, 1.0));\n        float distdy = sdTorus(posdy, vec2(3.8 * r / 3.0, 1.0));\n        \n        if(dist < 0.01 && distdx < 0.01 && distdy < 0.01){\n        \n            //find vector direction slightly downward on surface\n            vec3 CA = normalize(posdy - pos);\n            \n            //find vector direction slightly to the right on the surface\n            vec3 BA = normalize(posdx - pos);\n            \n            vec3 normal = cross(CA, BA);\n            \n            float lightMultiplier = 1.0;\n            \n            if(mod(iTime + 1.8, PI / 4.0) > 0.6) {\n                lightMultiplier = 4.0 - ((mod(iTime + 1.8, PI / 4.0) - 0.6) * 20.0);\n            }\n            \n            //a fixed light from the direction of the camera\n            vec3 lightDir = vec3(0.0,-0.5,lightMultiplier);\n            \n            // Apply the result to the output\n            colOut = vec3(0.6)*dot(-lightDir,normal);\n            break;\n        }\n        t += dist;\n        tdx += distdx;\n        tdy += distdy;\n    }\n    \n    return colOut;\n}\n\n// Draw some diagonally striped decals\nvec3 drawDecals(vec3 colIn, vec2 uv, vec3 position, float width, float size, vec3 rgb, float flashOffset) {\n    vec3 colOut = colIn;\n    \n    float posX = uv.x + position.x;\n    float posY = uv.y + position.y;\n    \n    // Apply a size pulse effect to the decals\n    float sizeMod = 0.0;\n    \n    if(mod(iTime + flashOffset, PI / 2.0) > 1.2) {\n        sizeMod = sin((iTime + flashOffset) * 4.00203 - (PI / 2.0 + 3.2316415)) / 20.0;\n    }\n    \n    // Apply a color pulse effect to the decals (and also render it)\n    if(abs(posX) + abs(posY) < size + sizeMod && abs(posX) + abs(posY) > size - width + sizeMod) {\n        vec3 lightMultiplier = vec3(1.0);\n            \n        if(mod(iTime + flashOffset, PI / 2.0) > 1.2) {\n            lightMultiplier = (0.5 + 0.5*cos((iTime * PI - flashOffset)+uv.xyx + vec3(0,2,4))) * \n            (2.0 - ((mod(iTime + flashOffset, PI / 4.0) - 0.6) * 5.0));\n        }\n        \n        // Actually apply the decals to the output\n        colOut = rgb * lightMultiplier;\n    }\n    \n    return colOut;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x - vec2(0.5, 0.26);\n    \n    // Time varying pixel color\n    vec3 col = vec3(0.);\n    //if(abs(uv.x + 0.2) + abs(uv.y) < 0.4 && abs(uv.x + 0.2) + abs(uv.y) > 0.3) col = vec3(0.5);\n    //if(abs(uv.x - 0.2) + abs(uv.y) < 0.4 && abs(uv.x - 0.2) + abs(uv.y) > 0.3) col = vec3(0.5);\n    \n    // Left Decals\n    col = drawDecals(col, uv, vec3(0.7, -0.02, -100.0), 0.05, 0.5, vec3(0.5), 0.0);\n    col = drawDecals(col, uv, vec3(0.8, -0.02, -100.0), 0.05, 0.5, vec3(0.5), -0.15);\n    col = drawDecals(col, uv, vec3(0.9, -0.02, -100.0), 0.05, 0.5, vec3(0.5), -0.3);\n    \n    // Right Decals\n    col = drawDecals(col, uv, vec3(-0.7, -0.02, -100.0), 0.05, 0.5, vec3(0.5), 0.0);\n    col = drawDecals(col, uv, vec3(-0.8, -0.02, -100.0), 0.05, 0.5, vec3(0.5), -0.15);\n    col = drawDecals(col, uv, vec3(-0.9, -0.02, -100.0), 0.05, 0.5, vec3(0.5), -0.3);\n    \n    // Middle Decals\n    col = drawDecals(col, uv, vec3(0, -0.02, -100.0), 0.05, 0.2, vec3(0.5), PI / 4.0);\n    \n    // Draw \"Shapes\"\n    col = drawShape(col, uv, vec3(4.0 * pow(cos(iTime * 4.0), 3.0f),\n                                 (4.0 * pow(sin(iTime * 4.0), 3.0f) - 3.5), \n                                 -112), 2.4,\n                              vec3(1.0, 0.1, 0.1));\n    col = drawShape(col, uv, vec3(4.0 * pow(cos(iTime * 4.0 + (PI / 2.0f)), 3.0f) + 2.5, \n                                 (4.0 * pow(sin(iTime * 4.0 + (PI / 2.0f)), 3.0f) - 1.0), \n                                 -108), 2.6,\n                              vec3(1.0, 1.0, 0.1));\n    col = drawShape(col, uv, vec3(4.0 * pow(cos(iTime * 4.0 + PI), 3.0f), \n                                 (4.0 * pow(sin(iTime * 4.0 + PI), 3.0f) + 1.5), \n                                 -104), 2.8,\n                              vec3(0.1, 1.0, 0.1));\n    col = drawShape(col, uv, vec3(4.0 * pow(cos(iTime * 4.0 + (PI * 1.5f)), 3.0f) - 2.5, \n                                 (4.0 * pow(sin(iTime * 4.0 + (PI * 1.5f)), 3.0f) - 1.0), \n                                 -100), 3.0,\n                              vec3(0.1, 0.1, 1.0));\n                              \n    // Apply the filter and apply a filter on the filter\n    col *= texture(iChannel1, (uv * 25.0) + cos(\n                       texture(iChannel0, uv * 5.0).x + (iTime * 2.0)\n                   )).xxx * 1.5;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}