{"ver":"0.1","info":{"id":"sdt3Rr","date":"1629062512","viewed":87,"name":"my shapes wont cooperate ","username":"MyGoodSir","description":"hacking on iq's code trying to experement and learn. my code is embarrassingly icky so dont look >:(\ni also broke some stuff trying to avoid having to comprehend iq's lighting/material code bc im lazy :/\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sorryiq","imadeamess"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Credit goes to inigo quilez for most of this code.\n//original can be found here:\n//https://www.shadertoy.com/view/4tVyWw\n\n// 0 = orthographics\n// 1 = perspective\n#define PROJECTION 1\n#define AA 1   // make this 1 is your machine is too slow\n\n//------------------------------------------------------------------\n\nvec3 v[16];\nivec4 faces[6] = ivec4[](\n    ivec4(0, 1, 2, 3), \n    ivec4(0, 1, 5, 4), \n    ivec4(1, 2, 6, 5), \n    ivec4(2, 3, 7, 6), \n    ivec4(3, 0, 4, 7), \n    ivec4(4, 5, 6, 7)\n    );\nstruct Indices{\n    int v[8];\n\n};\nIndices cube_indices[8];\n  \nvec3 cubecols[8] = vec3[](\n    vec3(1.,1.,1.),\n    vec3(1.,1.,0.),\n    vec3(1.,0.,1.),\n    vec3(0.,1.,1.),\n    vec3(0.,0.,1.),\n    vec3(0.,1.,0.),\n    vec3(1.,0.,0.),\n    vec3(0.,0.,0.)\n);\n\nfloat cross2d( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n\n\nconst int lut[4] = int[](1,2,0,1); //\"left-upper triangle\"??\n\n// 0--b--3\n// |\\\n// a c\n// |  \\\n// 1    2\n//\nvec3 quadIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2, in vec3 v3 )\n{\n    // lets make v0 the origin\n    vec3 a = v1 - v0;\n    vec3 b = v3 - v0;\n    vec3 c = v2 - v0;\n    vec3 p = ro - v0;//change basis\n\n    // intersect plane\n    vec3 nor = cross(a,b);//normal of plane (kinda. might not have the right magnitude, but we care about direction)\n    float t = -dot(p,nor)/dot(rd,nor);\n    if( t<0.0 ) return vec3(-1.0);\n    \n    // intersection point\n    vec3 pos = p + t*rd;\n\n    // bilinear interpolation: https://www.shadertoy.com/view/lsBSDm\n    \n    // select projection plane\n    vec3 mor = abs(nor);\n    int id = (mor.x>nor.y && mor.x>mor.z ) ? 0 : \n             ((mor.y>mor.z)                ? 1 : \n                                             2);\n    int idu = lut[id  ];\n    int idv = lut[id+1];\n    \n    // project to 2D\n    vec2 kp = vec2( pos[idu], pos[idv] );\n    vec2 ka = vec2( a[idu], a[idv] );\n    vec2 kb = vec2( b[idu], b[idv] );\n    vec2 kc = vec2( c[idu], c[idv] );\n    \n    // find barycentric coords of the quadrilateral\n    vec2 kg = kc-kb-ka;\n\n    float k0 = cross2d( kp, kb );\n    float k2 = cross2d( kc-kb, ka );        // float k2 = cross2d( kg, ka );\n    float k1 = cross2d( kp, kg ) - nor[id]; // float k1 = cross2d( kb, ka ) + cross2d( kp, kg );\n    \n    // if edges are parallel, this is a linear equation\n\tfloat u, v;\n    if( abs(k2)<0.001 )\n    {\n\t\tv = -k0/k1;\n\t    //u  = (kp.x*k1+ka.x*k0) / (kb.x*k1-kg.x*k0);\n    }\n\telse\n    {\n        // otherwise, it's a quadratic\n        float w = k1*k1 - 4.0*k0*k2;\n        if( w<0.0 ) return vec3(-1.0);\n        w = sqrt( w );\n\n        float ik2 = 1.0/(2.0*k2);\n\n        v = (-k1 - w)*ik2; \n        if( v<0.0 || v>1.0 ) \n            v = (-k1 + w)*ik2;\n    }\n    u = (kp.x - ka.x*v)/(kb.x + kg.x*v);\n    if( u<0.0 || u>1.0 || v<0.0 || v>1.0) return vec3(-1.0);\n    \n    return vec3( t, u, v );\n}\n\n\n\n\nfloat iCapsule( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n\n        float y = baoa + t*bard;\n        \n        // body\n        if( y>0.0 && y<baba ) return t;\n\n        // caps\n        vec3 oc = (y<=0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - r*r;\n        h = b*b - c;\n        if( h>0.0 )\n        {\n            return -b - sqrt(h);\n        }\n    }\n    return -1.0;\n}\n\nvec3 nCapsule( in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n    vec3 ba = b-a, pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return (pa - h*ba)/r;\n}\n\nvec3 dCapsule( in vec3 ro, in vec3 rd, vec3 pa, vec3 pb, float rad )\n{\n\tvec3 ba = pb - pa;\n\tvec3 oa = ro - pa;\n\t\n\tfloat oad  = dot( oa, rd );\n\tfloat dba  = dot( rd, ba );\n\tfloat baba = dot( ba, ba );\n\tfloat oaba = dot( oa, ba );\n\t\n\tvec2 th = vec2( -oad*baba + dba*oaba, oaba - oad*dba ) / (baba - dba*dba);\n\t\n\tth.x = max(   th.x, 0.0 );\n\tth.y = clamp( th.y, 0.0, 1.0 );\n\t\n\tvec3 p = pa + ba*th.y;\n\tvec3 q = ro + rd*th.x;\n\t\n\treturn vec3( length( p-q )-rad, th );\n}\n\n\n\nint objA, objB;\nbool cubeHit[8];\nbool poleHit;\nconst float rad = 0.07;\n\nfloat intersect( in vec3 ro, in vec3 rd, in vec3 v[16] )\n{\n    cubeHit = bool[](false,false,false,false,false,false,false,false);\n    poleHit=false;\n    float tmp;\n    \n    float res = 1e10;\n\n    \n\n    for( int i=0; i<16; i++ ) // for each vertex\n    for( int j=0; j< 4; j++ ) // connect it to its 4 neighbors\n    {\n        int a = i;\n        int b = a ^ (1<<j); // change one bit/dimension\n        if( a<b )          // skip edge if already visited\n        {\n            tmp = iCapsule( ro, rd, v[a], v[b], rad );\n            if( tmp>0.0 && tmp<res )\n            {\n                poleHit=true;\n                res = tmp; \n                objA = a; \n                objB = b;\n            }\n        }\n    }\n    \n    \n    for(int ci=0; ci<8; ci++){\n        for(int fi; fi<6; fi++){\n            ivec4 fvoffsets = faces[fi];\n            Indices cube_verts = cube_indices[ci];\n            vec3 v0 = v[cube_verts.v[fvoffsets.x]];\n            vec3 v1 = v[cube_verts.v[fvoffsets.y]];\n            vec3 v2 = v[cube_verts.v[fvoffsets.z]];\n            vec3 v3 = v[cube_verts.v[fvoffsets.w]];\n            tmp = quadIntersect(ro, rd, v0, v1, v2, v3).x;\n            if(tmp > 0. && tmp<res){\n                cubeHit[ci] = true;\n                res=tmp;\n            }\n\n        //     int a = ci;\n        //     int b = a^(1<<fi);\n        //     if( a<b )          // skip edge if already visited\n        // {\n        //     tmp = iCapsule( ro, rd, v[a], v[b], rad );\n        //     if( tmp>0.0 && tmp<res )\n        //     {\n        //         res = tmp; \n        //         objA = a; \n        //         objB = b;\n        //     }\n        // }\n\n        }\n    }\n    \n\n    return (res<1e9)?res:-1.0;\n}\n\nvec3 calcNormal( in vec3 pos, in vec3 v[16] )\n{\n    return nCapsule( pos, v[objA], v[objB], rad );\n}\n\nfloat softShadowCapsule( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in float r )\n{\n    const float k = 16.0;\n    vec3 t = dCapsule( ro, rd, a, b, r );\n    return clamp( k*t.x/max(t.z,0.0001), 0.0, 1.0 );\n}\n\n\n// soft shadows\nfloat calcShadow( in vec3 ro, in vec3 rd, in vec3 v[16] )\n{\n    float t = 1.0;\n    \n    for( int i=0; i<16; i++ ) // for each vertex\n    for( int j=0; j< 4; j++ ) // connect it to its 4 neighbors\n    {\n        int a = i;\n        int b = a ^ (1<<j); // change one bit/dimension\n        if( a<b )           // skip edge if already visited\n        {\n            t = min( t, softShadowCapsule( ro, rd, v[a], v[b], rad ) );\n        }\n    }    \n\n    return t;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in float seed, in vec3 v[16] )\n{\n    return 1.0;\n}\n\n\nvec3 render( in vec3 ro, in vec3 rd, in float seed, in vec3 v[16] )\n{ \n    vec3 col = vec3(0.04) + 0.03*rd.y;\n\n    float t = intersect(ro,rd,v);\n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, v );\n        // material        \n\t\tcol = vec3(0.4);\n\n        // lighting\n        if(poleHit){\n        float occ = calcAO( pos, nor, seed, v )*(0.7+0.3*nor.y);\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        float sha = (dif>0.001) ? calcShadow( pos+0.02*nor, lig, v ) : 0.0;\n\n\t\tfloat spe = pow( clamp( dot(nor,hal), 0.0, 1.0 ),16.0)*dif*sha*\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.20,0.80,0.65)*vec3(sha,0.5*sha+0.5*sha*sha,sha*sha);\n        lin += 0.70*amb*vec3(0.70,0.80,1.00)*occ;\n        lin += 1.00*fre*vec3(1.20,1.10,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 15.00*spe*vec3(1.00,0.90,0.70);\n        }\n        for(int i = 0; i<8; i++){\n            if(cubeHit[i]){\n                col += cubecols[i]*(1./8.);\n            }\n        }\n    }\n\n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nmat2 rot(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nvec3 transform( in vec4 p )\n{\n    p.xw *= rot(iTime*0.41);\n    p.yw *= rot(iTime*0.23);\n    p.xy *= rot(iTime*0.73);\n    p.wz *= rot(iTime*0.37);\n    \n    // orthogonal projection\n    #if PROJECTION==0\n    return p.xyz;\n    #else\n    // perspective projection\n\treturn 2.5*p.xyz/(3.0+p.w);\n    #endif\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    cube_indices[0] = Indices(int[](3, 0,  4,  7,  11, 8,  12, 15));\n    cube_indices[1] = Indices(int[](1, 2,  6,  5,  9,  10, 14, 13));\n    cube_indices[2] = Indices(int[](0, 1,  5,  4,  8,  9,  13, 12));\n    cube_indices[3] = Indices(int[](2, 3,  7,  6,  10, 11, 15, 15));\n    cube_indices[4] = Indices(int[](0, 1,  2,  3,  8,  9,  10, 11));\n    cube_indices[5] = Indices(int[](4, 5,  6,  7,  12, 13, 14, 15));\n    cube_indices[6] = Indices(int[](0, 1,  2,  3,  4,  5,  6,  7));\n    cube_indices[7] = Indices(int[](8, 9,  10, 11, 12, 13, 14, 15));\n    vec3 v[16];\n\n    // rotate 4D cube\n    v[ 0] = transform( vec4(-1,-1,-1,-1));\n    v[ 1] = transform( vec4(-1,-1,-1, 1));\n    v[ 2] = transform( vec4(-1,-1, 1,-1));\n    v[ 3] = transform( vec4(-1,-1, 1, 1));\n    v[ 4] = transform( vec4(-1, 1,-1,-1));\n    v[ 5] = transform( vec4(-1, 1,-1, 1));\n    v[ 6] = transform( vec4(-1, 1, 1,-1));\n    v[ 7] = transform( vec4(-1, 1, 1, 1));\n    v[ 8] = transform( vec4( 1,-1,-1,-1));\n    v[ 9] = transform( vec4( 1,-1,-1, 1));\n    v[10] = transform( vec4( 1,-1, 1,-1));\n    v[11] = transform( vec4( 1,-1, 1, 1));\n    v[12] = transform( vec4( 1, 1,-1,-1));\n    v[13] = transform( vec4( 1, 1,-1, 1));\n    v[14] = transform( vec4( 1, 1, 1,-1));\n    v[15] = transform( vec4( 1, 1, 1, 1));\n    \n    \n    // camera (static)\n    vec3 ro = vec3( 4.5, 1.5, -10.0 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n\t#define ZERO min(iFrame,0)\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float seed =  gl_FragCoord.x + gl_FragCoord.y*131.1 + iTime + 17.1*float(m) + 37.4*float(n);\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float seed =  gl_FragCoord.x + gl_FragCoord.y*131.1 + iTime;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd, seed, v );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // cheap dither to remove banding from background\n    tot += 0.5*sin(fragCoord.x)*sin(fragCoord.y)/256.0;\n    \n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}