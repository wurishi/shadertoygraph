{"ver":"0.1","info":{"id":"4XByWD","date":"1727862624","viewed":162,"name":"shader water  avanc√©","username":"p0izon","description":"correction ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * \"Seascape with Fourier-based Waves\" - Fusion of sin waves and original wave code\n * Based on the work of Alexander Alekseev aka TDM - 2014\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n */\n\nconst int NUM_STEPS = 32;\nconst float PI = 3.141592;\nconst float EPSILON = 1e-3;\n#define EPSILON_NRM (0.1 / iResolution.x)\n\n// sea\nconst int ITER_GEOMETRY = 3;\nconst int ITER_FRAGMENT = 5;\nconst float SEA_HEIGHT = 2.6;\nconst float SEA_CHOPPY = 4.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 0.16;\nconst vec3 SEA_BASE = vec3(0.0, 0.09, 0.18);\nconst vec3 SEA_WATER_COLOR = vec3(0.8, 0.9, 0.6) * 0.6;\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\nconst mat2 octave_m = mat2(1.6, 1.2, -1.2, 1.6);\n\n// math functions\nmat3 fromEuler(vec3 ang) {\n    vec2 a1 = vec2(sin(ang.x), cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y), cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z), cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y * a3.y + a1.x * a2.x * a3.x, a1.y * a2.x * a3.x + a3.y * a1.x, -a2.y * a3.x);\n    m[1] = vec3(-a2.y * a1.x, a1.y * a2.y, a2.x);\n    m[2] = vec3(a3.y * a1.x * a2.x + a1.y * a3.x, a1.x * a3.x - a1.y * a3.y * a2.x, a2.y * a3.y);\n    return m;\n}\n\nfloat hash(vec2 p) {\n    float h = dot(p, vec2(127.1, 311.7));\n    return fract(sin(h) * 43758.5453123);\n}\n\nfloat noise(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return -1.0 + 2.0 * mix(mix(hash(i + vec2(0.0, 0.0)),\n                                hash(i + vec2(1.0, 0.0)), u.x),\n                            mix(hash(i + vec2(0.0, 1.0)),\n                                hash(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\n// lighting\nfloat diffuse(vec3 n, vec3 l, float p) {\n    return pow(dot(n, l) * 0.4 + 0.6, p);\n}\n\nfloat specular(vec3 n, vec3 l, vec3 e, float s) {\n    float nrm = (s + 8.0) / (PI * 8.0);\n    return pow(max(dot(reflect(e, n), l), 0.0), s) * nrm;\n}\n\n// sky color\nvec3 getSkyColor(vec3 e) {\n    e.y = (max(e.y, 0.0) * 0.8 + 0.2) * 0.8;\n    return vec3(pow(1.0 - e.y, 2.0), 1.0 - e.y, 0.6 + (1.0 - e.y) * 0.4) * 1.1;\n}\n\n// sea functions\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);\n    vec2 wv = 1.0 - abs(sin(uv));\n    vec2 swv = abs(cos(uv));\n    wv = mix(wv, swv, wv);\n    return pow(1.0 - pow(wv.x * wv.y, 0.65), choppy);\n}\n\nfloat additionalWaves(vec2 uv, float time) {\n    float baseFrequency1 = 1.5;\n    float baseFrequency2 = 2.5;\n    float baseFrequency3 = 3.5;\n    float baseFrequency4 = 4.5; \n    float baseFrequency5 = 5.5; \n    float amplitude1 = 0.3; \n    float amplitude2 = 0.1;\n    float amplitude3 = 0.03; \n    float amplitude4 = 0.05; \n    float amplitude5 = 0.02;\n\n    // Modify UV coordinates to avoid tiling\n    vec2 noiseOffset = vec2(sin(time * 0.5), cos(time * 0.5));\n    vec2 tiledUV1 = uv + noiseOffset * 0.1;\n    vec2 tiledUV2 = uv + noiseOffset * 0.05;\n    vec2 tiledUV3 = uv + noiseOffset * 0.15;\n    vec2 tiledUV4 = uv + noiseOffset * 0.2;\n    vec2 tiledUV5 = uv + noiseOffset * 0.25;\n\n    // Waves with sharper peaks\n    float wave1 = sin(tiledUV1.x * baseFrequency1 + time) * amplitude1 * 1.5;\n    float wave2 = sin(tiledUV2.x * baseFrequency2 + time * 1.5) * amplitude2 * 1.5; // Adjust amplitude for variability\n    float wave3 = sin(tiledUV3.x * baseFrequency3 + time * 2.0) * amplitude3 * 1.5;\n    float wave4 = sin(tiledUV4.x * baseFrequency4 + time * 2.5) * amplitude4 * 1.5;\n    float wave5 = sin(tiledUV5.x * baseFrequency5 + time * 3.0) * amplitude5 * 1.5; \n\n    // Sum of waves\n    return wave1 + wave2 + wave3 + wave4 + wave5; \n}\n\n\n\n\nfloat map(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz;\n    uv.x *= 0.3;\n    uv.y *= 0.2;\n\n    // Original waves and large wave rolls\n    float waveRoll = sin(uv.x * 2.0 + SEA_TIME) * 0.2;\n    float waveRollY = sin(uv.y * 2.0 + SEA_TIME * 0.8) * 0.2;\n\n    float h = waveRoll + waveRollY;\n\n    // Adding Fourier-based waves to the height map\n    h += additionalWaves(uv, SEA_TIME);\n\n    for (int i = 0; i < ITER_GEOMETRY; i++) {\n        float d = sea_octave((uv + SEA_TIME) * freq, choppy);\n        d += sea_octave((uv - SEA_TIME) * freq, choppy);\n        h += d * amp;\n        uv *= octave_m;\n        freq *= 1.9;\n        amp *= 0.22;\n        choppy = mix(choppy, 1.0, 0.2);\n    }\n\n    return p.y - h;\n}\n\n// sea color and shading\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {\n    float fresnel = clamp(1.0 - dot(n, -eye), 0.0, 1.0);\n    fresnel = min(fresnel * fresnel * fresnel, 0.5);\n\n    vec3 reflected = getSkyColor(reflect(eye, n));\n    vec3 refracted = SEA_BASE + diffuse(n, l, 80.0) * SEA_WATER_COLOR * 0.12;\n\n    vec3 specularLight = vec3(specular(n, l, eye, 90.0)) * SEA_WATER_COLOR;\n\n    vec3 color = mix(refracted, reflected, fresnel);\n\n    float atten = max(1.0 - dot(dist, dist) * 0.001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n\n    color += specularLight * (abs(p.y) * 0.5);\n\n    return color;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float eps) {\n    vec3 n;\n    n.y = map(p);\n    n.x = map(vec3(p.x + eps, p.y, p.z)) - n.y;\n    n.z = map(vec3(p.x, p.y, p.z + eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {\n    float tm = 0.0;\n    float tx = 1000.0;\n    float hx = map(ori + dir * tx);\n    if (hx > 0.0) {\n        p = ori + dir * tx;\n        return tx;\n    }\n    float hm = map(ori);\n    for (int i = 0; i < NUM_STEPS; i++) {\n        float tmid = mix(tm, tx, hm / (hm - hx));\n        p = ori + dir * tmid;\n        float hmid = map(p);\n        if (hmid < 0.0) {\n            tx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }\n        if (abs(hmid) < EPSILON) break;\n    }\n    return mix(tm, tx, hm / (hm - hx));\n}\n\nvec3 getPixel(in vec2 coord, float time) {\n    vec2 uv = coord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 ang = vec3(0.0, 0.3, 0.0);\n    vec3 ori = vec3(0.0, 9.0, 0.0);\n    vec3 dir = normalize(vec3(uv.xy, -2.0));\n    dir.z += length(uv) * 0.14;\n    dir = normalize(dir) * fromEuler(ang);\n\n    vec3 p;\n    heightMapTracing(ori, dir, p);\n    vec3 dist = p - ori;\n    vec3 n = getNormal(p, dot(dist, dist) * EPSILON_NRM);\n    vec3 light = normalize(vec3(0.0, 1.0, 0.8));\n\n    return getSeaColor(p, n, light, dir, dist);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float time = iTime * 0.3 + iMouse.x * 0.01;\n    vec3 color = getPixel(fragCoord, time);\n    fragColor = vec4(pow(color, vec3(0.75)), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}