{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"music","id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"\n// **************************************************************************\n// CONSTANTS\n\n#define PI 3.14159\n#define TWO_PI 6.28318\n#define PI_OVER_TWO 1.570796\n#define ONE_OVER_PI 0.1591549\n#define ONE_OVER_TWOPI 0.318309\n\n#define EPSILON 0.0001\n#define BIG_FLOAT 1000000.\n\n// **************************************************************************\n// GLOBALS\n\nvec3  g_camPointAt   = vec3(0.);\nvec3  g_camOrigin    = vec3(0.);\n\nfloat g_time         = 0.;\n\n\nmat2  g_rotateVortex = mat2(1.);\nmat2  g_rotateLight  = mat2(1.);\n\n// **************************************************************************\n// UTILITIES\n\n// Rotate the input point around the y-axis by the angle given as a  cos(angle)\n// and sin(angle) argument.  There are many times where  I want to reuse the\n// same angle on different points, so why do the  heavy trig twice. Range of\n// outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\nvec3 rotateAroundYAxis( vec3 point, float cosangle, float sinangle )\n{\n    return vec3(point.x * cosangle  + point.z * sinangle,\n                point.y,\n                point.x * -sinangle + point.z * cosangle);\n}\n\n// Rotate the input point around the x-axis by the angle given as a  cos(angle)\n// and sin(angle) argument.  There are many times where  I want to reuse the\n// same angle on different points, so why do the  heavy trig twice. Range of\n// outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\nvec3 rotateAroundXAxis( vec3 point, float cosangle, float sinangle )\n{\n    return vec3(point.x,\n                point.y * cosangle - point.z * sinangle,\n                point.y * sinangle + point.z * cosangle);\n}\n\n\n// **************************************************************************\n// SHADING\n\nvec3 shadeSurface(vec3 pos, vec3 nor, float s)\n{\n    vec3 ldir =  vec3(0., -1., 2.5);\n\tldir.xz *= g_rotateLight;\n\t\n    vec3 lcolor = .8 * mix(vec3(0., .5, 1.),\n                     vec3(1.2, .5, 0.),\n                     s);\n    vec3 scolor = texture(iChannel0, vec2(mod(.002 * length(pos.xz) - .03*g_time, 1.), .5)).rrr;\n    float ndl = dot(ldir, nor);\n    \n    return lcolor * scolor * max(0., ndl);\n}\n\nfloat noise(vec3 p)\n{\n    float lookup = mod(length(p.xz) * .4, 1.);\n    return 1. - texture(iChannel1, vec2(lookup, .99)).b;\n}\n\nfloat map(vec3 p)\n{   \n    vec3 ap = abs(p);\n\n    float res = 0.;\n    if (p.y < 0.) \n    {\n        float threshold = -log( pow(length(ap.xz), 1.3) - 8.) + 5.;\n        threshold += 1. * noise(ap);\n        res = smoothstep(threshold-2., threshold+2., .25 * ap.y);\n    }\n\n    return res;\n}\n\n// **************************************************************************\n// MARCHING\n\n// References for DDA marching:\n// original tutorial:  http://lodev.org/cgtutor/raycasting.html\n// initial shadertoy reference by fb39ca4: https://www.shadertoy.com/view/4dX3zl\n// optimization by iq: https://www.shadertoy.com/view/4dfGzs\nfloat ddamarch( vec3 ro, vec3 rd, \n\t\t\t   float maxdist,\n               out vec4 hitrgba )\n{\n\n    vec3 pos = floor(ro);\n    pos.xz *= g_rotateVortex;\n    vec3 rro = ro; rro.xz *= g_rotateVortex;\n    vec3 rrd = rd; rrd.xz *= g_rotateVortex;\n    \n    vec3 deltaDist = 1.0/rrd;\n    vec3 rs = sign(rrd);\n    vec3 sideDist = (pos-rro + 0.5 + rs*0.5) * deltaDist;\n    \n    float res = 0.0;\n    vec3 mm = vec3(0.0);\n    \n    hitrgba = vec4(0.);\n    vec3 hitdist = vec3(0.);\n\t\n\tfloat t = 0.;\n\t\n    for( int i=0; i<256; i++ ) \n    {\n\t\tif (hitrgba.a > .95 || t >= maxdist) { continue; }\n        mm = step(sideDist.xyz, sideDist.yxy) * step(sideDist.xyz, sideDist.zzx);        \n\n        vec3 normal = mm * rs;\n        pos += mm * rs;   \n        res = map(pos);\n                  \n        float alpha = smoothstep(0., 1., res);\n\t\thitrgba.rgb += shadeSurface(pos, normal, alpha) * (1. - hitrgba.a) * alpha;\n        hitrgba.a += (1. - hitrgba.a) * alpha;\n            \n        sideDist += mm * rs * deltaDist;  \n\t\tt = length(pos - rro);\n    }    \n    \n    return t;\n}\n\n// **************************************************************************\n// CAMERA & GLOBALS\n\nvoid animateGlobals()\n{\n    // remap the mouse click ([-1, 1], [-1/ar, 1/ar])\n    vec2 click = iMouse.xy / iResolution.xx;    \n    click = 2.0 * click - 1.0;  \n    \n    g_time = iTime;\n\n    // camera position\n    g_camOrigin = vec3(0., 5., 65.);\n    \n    float rotateXAngle    =  -.4 * PI * (.5 * sin(.4 * g_time + 1. * PI * click.y) + .5);\n    float cosRotateXAngle = cos(rotateXAngle);\n    float sinRotateXAngle = sin(rotateXAngle);\n    \n    float rotateYAngle    =  TWO_PI * click.x;\n    float cosRotateYAngle = cos(rotateYAngle);\n    float sinRotateYAngle = sin(rotateYAngle);\n\n    // Rotate the camera around the origin\n    g_camPointAt   = vec3(0., -2., 0.);\n    g_camOrigin    = rotateAroundXAxis(g_camOrigin, cosRotateXAngle, sinRotateXAngle);\n    g_camOrigin    = rotateAroundYAxis(g_camOrigin, cosRotateYAngle, sinRotateYAngle);\n\n    float vt = .05 * g_time;\n    g_rotateVortex = mat2(cos(vt), sin(vt), -sin(vt), cos(vt));\n\tfloat lt = -1. * g_time;\n\tg_rotateLight = mat2(cos(lt), sin(lt), -sin(lt), cos(lt));\n}\n\nstruct CameraData\n{\n    vec3 origin;\n    vec3 dir;\n    vec2 st;\n};\n\nCameraData setupCamera(vec2 fragCoord)\n{\n\n    // aspect ratio\n    float invar = iResolution.y / iResolution.x;\n    vec2 st = fragCoord.xy / iResolution.xy - .5;\n    st.y *= invar;\n\n    // calculate the ray origin and ray direction that represents\n    // mapping the image plane towards the scene\n    vec3 iu = vec3(0., 1., 0.);\n\n    vec3 iz = normalize( g_camPointAt - g_camOrigin );\n    vec3 ix = normalize( cross(iz, iu) );\n    vec3 iy = cross(ix, iz);\n\n    vec3 dir = normalize( st.x*ix + st.y*iy + 1.0 * iz );\n\n    return CameraData(g_camOrigin, dir, st);\n\n}\n\n// **************************************************************************\n// MAIN\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    \n    // ----------------------------------\n    // Animate globals\n\n    animateGlobals();\n\n    // ----------------------------------\n    // Setup Camera\n\n    CameraData cam = setupCamera(fragCoord);\n\n    // ----------------------------------\n    // SCENE MARCHING\n    vec3 scenecol = vec3(0.);\n\n    vec4 hitrgba;\n    float t = ddamarch( cam.origin, \n                        cam.dir, \n\t\t\t\t\t   120.,\n                        hitrgba);\n\n    scenecol = hitrgba.rgb * hitrgba.a;\n    // ----------------------------------\n    // POST PROCESSING    \n\n    // distance fog\n    scenecol *= smoothstep(120., 80., t);\n    \t\n    // Brighten\n    scenecol *= 1.8;\n\t\n    // Gamma correct\n    scenecol = pow(scenecol, vec3(0.45));\n\t\n\t\n    fragColor.rgb = scenecol;\n    fragColor.a = 1.;\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lsS3Dm","date":"1389497459","viewed":941,"name":"Blended DDA Marching","username":"mplanck","description":"While debugging my implementation of dda marching, I decided to test my algorithm with this blended approach and then tweaked it to find this fun vortex effect.  Cool how the blended dda blocks create a faux irradescence.","likes":17,"published":1,"flags":0,"usePreview":1,"tags":["dda"],"hasliked":0,"parentid":"","parentname":""}}