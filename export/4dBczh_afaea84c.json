{"ver":"0.1","info":{"id":"4dBczh","date":"1490747312","viewed":93,"name":"Little Box","username":"chapter9","description":"Simple, Raymarch, SDF","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["simple","raymarch","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float PI=3.14159265;\n\n// Floor\nvec2 objPlane(in vec3 p, in float offset, in int materialID)\n{\n  return vec2(p.y+offset,materialID);\n}\n\nvec2 opAdd(in vec2 obj0, in vec2 obj1)\n{\n    float r = min(obj0.x,obj1.x);\n\treturn vec2(r, r == obj0.x ? obj0.y : obj1.y);\n}\n\nvec2 obSub(in vec2 obj0, in vec2 obj1)\n{\n    float r = max(obj0.x,-obj1.x);\n\treturn vec2(r, r > obj0.x ? obj0.y : obj1.y);\n}\n\nvec2 objSphere(in vec3 p, in float r, in int materialID)\n{\n  float d = length(p) - r;\n  return vec2(d,materialID);\n}\n\nvec2 objCube( vec3 p, vec3 b, in int materialID)\n{\n  float d = length(max(abs(p)-b,0.0));\n  return vec2(d,materialID);\n}\n\nvec2 vScene(in vec3 p)\n{\n  return opAdd(\n      \t\tobjPlane(p,1.0,0),\n      \t\tobSub(\n                objCube(p,vec3(1.0,1.0,1.0),1),\n                objSphere(p,1.25,2)\n            )\n      \t );\n}\n\nvec3 material0(in vec3 p) \n{\n  if (fract(p.x*0.2)>0.2)\n  {\n    if (fract(p.z*0.2)>0.2)\n      return vec3(0,0.1,0.2);\n    else\n      return vec3(1,1,1);\n  }\n  else\n  {\n    if (fract(p.z*.2)>.2)\n      return vec3(1,1,1);\n    else\n      return vec3(0.3,0.2,0);\n   }\n}\nvec3 material1(in vec3 p) { return vec3(1.7,1.2,2.0); }\nvec3 material2(in vec3 p) { return vec3(1.0,0.0,0.0); }\n\nvec3 SetupCamera(vec3 camPos, vec3 camLookAt, vec3 worldUp, vec2 uv)\n{\n  // Camera setup.\n  vec3 camDir=normalize(camLookAt-camPos);\n  vec3 camRight=normalize(cross(worldUp,camDir));\n  vec3 camUp=cross(camDir,camRight);\n  vec3 vcv=(camPos+camDir);\n  vec3 scrCoord=vcv+uv.x*camRight*iResolution.x/iResolution.y+uv.y*camUp;\n  return normalize(scrCoord-camPos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // Texture Coordinate\n  vec2 uv = fragCoord.xy/iResolution.xy - 0.5;\n    \n  // Mouse Coordinate\n  vec2 m = iMouse.xy/iResolution.xy*PI*vec2(2.0,0.5);\n\n  // Camera\n  const float cameraDistance = 4.0;\n  const vec3 cameraUp = vec3(0,1,0);\n  const vec3 cameraLookAt = vec3(0,0,0);\n  const float cameraFar=100.0;\n  const float cameraNear=0.001;\n  vec3 cameraPos=vec3(cos(m.y)*cos(m.x),sin(m.y),cos(m.y)*sin(m.x))*cameraDistance; \n  vec3 scp=SetupCamera(cameraPos, cameraLookAt, cameraUp, uv);\n    \n  // Raymarching.\n  const int rayCount = 200;\n  vec2 rayDistance=vec2(0.001,0.0 /* Material ID */);\n  vec3 c,p,N;\n\n  float f=0.0;\n  for(int i=0;i<rayCount;i++)\n  {\n    if ((abs(rayDistance.x) < cameraNear) || (f > cameraFar)) \n      break;\n    \n    f+=rayDistance.x;  \n    p=cameraPos+scp*f; // rayPoint\n    rayDistance = vScene(p);\n  }\n  \n  if (f < cameraFar)\n  {\n    // y is used to manage materials.\n    if (rayDistance.y<=0.0) \n      c = material0(p);\n    else if (rayDistance.y<=1.0) \n      c = material1(p);\n    else if (rayDistance.y<=2.0) \n      c = material2(p);\n        \n    // Lighting\n\tconst vec3 e=vec3(0.00001,0,0);\n    vec3 n = vec3(rayDistance.x-vScene(p-e.xyy).x,\n                  rayDistance.x-vScene(p-e.yxy).x,\n                  rayDistance.x-vScene(p-e.yyx).x);\n    N = normalize(n);\n\tvec3 L = vec3(sin(iTime)*20.0,20.0,cos(iTime)*20.0);\n    float b=dot(N,normalize(cameraPos-p+L));\n    \n    //simple phong lighting, LightPosition = CameraPosition\n    fragColor=vec4((b*c+pow(b,16.0))*(1.0-f*.001),1.0);\n  }\n  else \n    fragColor=vec4(0,0,0,1); //background color\n}\n","name":"Image","description":"","type":"image"}]}