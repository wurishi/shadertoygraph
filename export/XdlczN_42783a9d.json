{"ver":"0.1","info":{"id":"XdlczN","date":"1487808329","viewed":123,"name":"Midterm Project","username":"OTK","description":"10 different effects","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["miderm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","previewfilepath":"/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define Result 10\n\nvec3 yellow = vec3(1.0, 1.0, 0.0);\nvec3 red = vec3(1.0, 0.0, 0.0);\nvec3 blue = vec3(0.0, 0.0, 1.0);\nvec3 green = vec3(0.0, 1.0, 0.0);\nvec3 orange = vec3(1.0, 0.5, 0.0);\nvec3 gray = vec3(0.5, 0.5, 0.6);\nvec3 violet = vec3(0.6, 0.251, 0.9);\n\nint circle = 1000;\nint square = 4;\nint triangle = 3;\nint pentagon = 5;\nint hexagon = 6;\n\nvec4 createColor(float r, float g, float b, float a)\n{\n \treturn vec4(r, g, b, a);  \n}\n\nfloat createEqualizer(float bars, vec2 uv)\n{\n \tfloat fft  = texture( iChannel0, vec2(floor(uv.x*bars)/bars,0.25) ).x;\n\tfloat amp = (fft - uv.y)*1000.0; \n    return amp;\n}\n\nmat2 rotate2d(float angle)\n{\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nmat2 scale(vec2 value)\n{\n    return mat2(value.x, 0, 0, value.y);\n}\n\nfloat createPolygon(int sides, vec2 uv, float ratio, float x, float y, float rotate)\n{\n    vec2 coor = vec2(x, y);\n    uv -= vec2(coor.x *ratio, coor.y);\n    float a = atan(uv.x,uv.y)+PI + rotate;\n\tfloat r = TWO_PI/float(sides);\n    float dist = cos(floor(.5+a/r)*r-a)*length(uv);\n    \n    return dist;\n}\n\nvec3 createSpiralPower(vec2 uv, float xCoord, float yCoord, float rings, float ratio, vec3 color)\n{\n    vec3 rinnegan = vec3(fract(distance(uv,vec2(xCoord * ratio, yCoord)) * rings + (iTime))) * color;\n\treturn rinnegan;\n}\n\n\n#if Result == 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv *= 5.0;\n    vec2 tiledx = floor(uv);\n    uv = fract(uv);\n    \n    uv *= ratio;\n   \n    \n    vec3 circle = createSpiralPower(uv, 0.5, 0.5, 10.0, ratio, violet);\n    \n\tfragColor = vec4(circle, 1.0);\n}\n\n#elif Result == 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    \n    uv *= iTime;\n    \n    vec2 tiledx = floor(uv);\n    uv = fract(uv);\n    \n    uv.x *= ratio;\n    vec2 origin = vec2(0.5 * ratio, 0.5);\n    uv -= origin;\n    \n    uv *= scale(vec2(sin(iTime)));\n    uv *= rotate2d(iTime);\n    \n    uv += origin;\n    \n    vec3 \n    polygon =  vec3(1.0 -step(0.1, createPolygon(hexagon, uv, ratio, 0.5, 0.5 , 0.0))) * orange;\n\tfragColor = vec4(polygon, 1.0);\n}\n\n#elif Result == 3\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv *= 10.0;\n    vec2 tiledx = floor(uv);\n    uv = fract(uv);\n\tfloat bars = 100000.0;\n\tfloat amp = createEqualizer(bars, uv);\n\tfragColor = vec4(amp, 0.0 , 0.0 ,1.0);\n}\n\n#elif Result == 4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv.x*=ratio;\n    vec2 shapePos = vec2(0.5 * ratio, 0.5);\n    float dist = distance(shapePos, uv) * 2.0;\n    uv -= shapePos;\n    float angle = atan(uv.y, uv.x);\n    float radius = cos(3.0 * angle) * tan(3.0 * angle);\n    radius = abs(texture(iChannel0, vec2(dist, sin(3.0 * angle) * sin(2.0 * angle)))).x;\n    vec3 value = step(radius, dist) * red;\n    fragColor = vec4(value, 1.0);\n    \n}\n\n#elif Result == 5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float value = step(sin(iTime * uv.x) / 2.0, uv.y);\n    \n    //vec4 color = createColor(0.0, (abs(sin(iTime* 2.0 * 2.0 + 2.0) / 2.0)), (abs(sin(iTime * 2.0) / 2.0)), 0.0);\n\tfragColor = vec4(vec3(value), 1.0);\n        \n}\n\n#elif Result == 6\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 red = vec3(1.0, 0.0, 0.0);\n    vec3 grey = vec3 (0.5, 0.5, 0.6);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv.x*=ratio;\n    vec2 shapePos = vec2(0.5 * ratio, 0.5);\n    float dist = distance(shapePos, uv) * 2.0;\n    uv -= shapePos;\n    float angle = atan(uv.y, uv.x);\n    float radius = cos(3.0 * angle) * tan(3.0 * angle);\n    radius = 1.0 - abs(floor(sin(5.0 * angle + iTime)) * floor(cos(9.0 * dist + iTime)) * floor(tan(4.0 * dist + iTime))\n                     * floor(tan(3.0 * dist + iTime)));\n    vec3 value = step(radius, dist) * red;\n    fragColor = vec4(value, 1.0);\n    \n}\n\n#elif Result == 7\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    \n    uv *= 3.0;\n    \n    vec2 tiledx = floor(uv);\n    uv = fract(uv);\n    \n    uv.x *= ratio;\n    vec2 origin = vec2(0.5 * ratio, 0.5);\n    uv -= origin;\n    \n    uv *= scale(vec2(sin(iTime)));\n    uv *= rotate2d(iTime);\n    \n    uv += origin;\n    \n    vec3 \n    polygon =  vec3(1.0 -step(0.1, createPolygon(hexagon, uv, ratio, 0.5, 0.5, 0.0))) * orange;\n    \n    if (tiledx.x == 0.0 && tiledx.y == 0.0 || tiledx.x == 2.0 && tiledx.y == 0.0 || tiledx.x == 1.0 && tiledx.y == 1.0 || tiledx.x == 0.0 && tiledx.y == 2.0 || tiledx.x == 2.0 && tiledx.y == 2.0)\n    {\n    \tuv -= origin;\n    \n    \tuv *= scale(vec2(cos(iTime)));\n    \tuv *= rotate2d(iTime);\n    \n    \tuv += origin;\n     \tpolygon =  vec3(1.0 -step(0.1, createPolygon(hexagon, uv, ratio, 0.5, 0.5, 0.0))) * green;   \n    }\n    \n\tfragColor = vec4(polygon, 1.0);\n}\n\n#elif Result == 8\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    const float upsideDown = 1.05;\n    const float normal = 0.0;\n    uv *= 5.0;\n    \n    vec2 tiledx = floor(uv);\n    uv = fract(uv);\n    \n    uv.x *= ratio;\n    \n    vec3\n    // top    \n    polygon =  vec3(1.0 -step(0.1, createPolygon(triangle, uv, ratio, 0.5, 0.8, normal))) * orange;\n    polygon += vec3(1.0 -step(0.1, createPolygon(triangle, uv, ratio, 0.5, 0.5, normal))) * orange;\n    for (float i = 0.0; i < 5.0; i += 1.0)\n    {\n    \tfor (float j = 0.0; j < 5.0; j += 1.0)\n    \t{\n            if (i == 1.0 || i == 3.0)\n            {\n        \t\tif (tiledx.x == i && tiledx.y == j)\n        \t\t{\n            \t\tpolygon =  vec3(1.0 -step(0.1, createPolygon(triangle, uv, ratio, 0.5, 0.2, upsideDown))) * orange;\n            \t\tpolygon += vec3(1.0 -step(0.1, createPolygon(triangle, uv, ratio, 0.5, 0.5, upsideDown))) * orange;\n        \t\t}\n            }\n    \t}\n    }\n   \n\tfragColor = vec4(polygon, 1.0);\n}\n\n#elif Result == 9\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    const float upsideDown = 1.05;\n    const float normal = 0.0;\n    uv *= 5.0;\n    \n    vec2 tiledx = floor(uv);\n    uv = fract(uv);\n    \n    uv.x *= ratio;\n    vec2 origin = vec2(0.5 * ratio, 0.5);\n    uv -= origin;\n    \n    uv *= scale(vec2(sin(iTime)));\n    uv *= rotate2d(iTime);\n    \n    uv += origin;\n    \n    vec3\n    // top    \n    polygon =  vec3(1.0 -step(0.1, createPolygon(triangle, uv, ratio, 0.5, 0.8, normal))) * green;\n    polygon += vec3(1.0 -step(0.1, createPolygon(triangle, uv, ratio, 0.5, 0.5, upsideDown))) * red;\n    for (float i = 0.0; i < 5.0; i += 1.0)\n    {\n    \tfor (float j = 0.0; j < 5.0; j += 1.0)\n    \t{\n            if (i == 1.0 || i == 3.0)\n            {\n        \t\tif (tiledx.x == i && tiledx.y == j)\n        \t\t{\n            \t\tpolygon =  vec3(1.0 -step(0.1, createPolygon(triangle, uv, ratio, 0.5, 0.2, upsideDown))) * yellow;\n            \t\tpolygon += vec3(1.0 -step(0.1, createPolygon(triangle, uv, ratio, 0.5, 0.5, normal))) * blue;\n        \t\t}\n            }\n    \t}\n    }\n   \n\tfragColor = vec4(polygon, 1.0);\n}\n\n#elif Result == 10\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    const float diamond = 0.8;\n    uv *= 10.0;\n    \n    vec2 tiledx = floor(uv);\n    uv = fract(uv);\n    \n    uv.x *= ratio;\n    \n    vec3\n    // top    \n    polygon =  vec3(1.0 -step(0.35, createPolygon(square, uv, ratio, 0.5, 0.5, sin(-iTime)))) * yellow;\n  \tfor (float i = 0.0; i < 10.0; i += 1.0)\n    {\n    \tfor (float j = 0.0; j < 10.0; j += 1.0)\n    \t{\n            if (i == 1.0 || i == 3.0 || i == 5.0 || i == 7.0 || i == 9.0) \n            {\n        \t\tif (tiledx.x == i && tiledx.y == j)\n        \t\t{\n            \t\tpolygon =  vec3(1.0 -step(0.35, createPolygon(square, uv, ratio, 0.5, 0.5, sin(iTime)))) * blue;\n        \t\t}\n            }\n    \t}\n    }\n   \n\tfragColor = vec4(polygon, 1.0);\n}\n\n#endif","name":"Image","description":"","type":"image"}]}