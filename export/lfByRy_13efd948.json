{"ver":"0.1","info":{"id":"lfByRy","date":"1722507050","viewed":69,"name":"WIP marching city v1","username":"Tivi","description":"Marching in cube grid, a few hardcoded roof decorations for buildings, primary+shadow","likes":2,"published":1,"flags":0,"usePreview":1,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n// Stole from iquilez\nvec3 noised( in vec2 x )\n{\n    vec2 f = fract(x);\n    //#if USE_SMOOTH_NOISE==0\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n    //#else\n    //vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    //vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n    //#endif\n\n#if 1\n    // texel fetch version\n    ivec2 p = ivec2(floor(x));\n    float a = texelFetch( iChannel0, (p+ivec2(0,0))&255, 0 ).x;\n\tfloat b = texelFetch( iChannel0, (p+ivec2(1,0))&255, 0 ).x;\n\tfloat c = texelFetch( iChannel0, (p+ivec2(0,1))&255, 0 ).x;\n\tfloat d = texelFetch( iChannel0, (p+ivec2(1,1))&255, 0 ).x;\n#else    \n    // texture version    \n    vec2 p = floor(x);\n\tfloat a = textureLod( iChannel0, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\n\tfloat b = textureLod( iChannel0, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\n\tfloat c = textureLod( iChannel0, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\n\tfloat d = textureLod( iChannel0, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\n#endif\n    \n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\tdu*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\n\nfloat fbm( in vec2 x, in float H )\n{    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    int numOctaves=8;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*noised(f*x).x;\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n#define BIGFLOAT (100000.)\n// return normal + t\nvec4 traverse(vec3 ro, vec3 rd)\n{\n\n    vec3 ro_ = ro;\n    vec3 cell = floor (ro_);\n    vec3 normal;\n    float t = BIGFLOAT;\n    for (int i=0; i<300; i++)\n    {\n        // Forward march\n        vec3 plane;\n        plane.x = rd.x<0. ? cell.x : cell.x+1.;\n        plane.y = rd.y<0. ? cell.y : cell.y+1.;\n        plane.z = rd.z<0. ? cell.z : cell.z+1.;\n        vec3 planet = abs((plane-ro_)/rd);\n        vec3 step = rd / abs(rd);\n        normal = vec3(0.,0.,1.);\n        float t_ = planet.z;\n        if (planet.x < planet.y && planet.x < planet.z)\n        {\n            cell.x += step.x;\n            normal = vec3(1.,0.,0.);\n            t_ = planet.x;\n        }\n        else if(planet.y < planet.z)\n        {\n            cell.y += step.y;\n            normal = vec3(0.,1.,0.);;\n            t_ = planet.y;\n        }\n        else\n        {\n            cell.z += step.z;\n        }\n        normal *= -step;\n        \n        //if (cell.y < sin(cell.x*0.5)*1.6f + cos(cell.x*0.2-cell.z*0.4)*0.8f)\n        float h = fbm(cell.xz,0.8)*5. - length(cell.xz)*0.22;\n        if (cell.y < h)\n        {\n            //hit = ro + rd*t;\n            t = t_;\n            break;\n        }\n        if (cell.y > 20. && rd.y > 0.) break;\n        \n        else if(cell.y < h+1.)\n        {\n            float dummy;\n            float foo = floor(modf(h, dummy) * 8.f);\n            \n            \n            if (foo==0. || foo == 7.)\n            {\n                // Sphere isect\n                vec3 ctr = cell+vec3(0.5,0.,0.5);\n                if (foo == 7.) ctr = cell + vec3(0.5,0.3,0.5);\n                //Line to form ax+bz+c=0\n                //float a = rd.z*10.f;\n                //float b = rd.x*10.f;\n                //float c = ((ro.x+b)*ro.z - (ro.z+a) * ro.x); //x2y1-y2x1\n                //float dist = abs(a*ctr.x + b*ctr.z + c)/sqrt(a*a+b*b);\n                float dist = length(((ro_-ctr)-(dot((ro_-ctr),rd)*rd)));\n                //float dist = length(vec3((ro-ctr).xz-(dot((ro-ctr).xz,rd.xz)*rd.xz),0.));\n\n                    //float t_ = -dot((ro_-ctr),rd);\n                    //vec3 hit_ = ro_+rd*t_;\n                //if (dist<.5 ){//&& hit.y > ctr.y) {\n                if (dist<.4) {\n\n                    vec3 oc = ro - ctr;\n                    float a = dot(rd, rd);\n                    float b = 2.0 * dot(oc, rd);\n                    float c = dot(oc,oc) - .45*.45;\n                    float discriminant = b*b - 4.*a*c;\n                    float t_ = (-b - sqrt(discriminant)) / (2.0*a);\n                    vec3 hit_ = ro_ + rd*t_;\n\n                    //t = t_;\n                    if (hit_.y > ctr.y)\n                    {\n                    //hit = hit_;\n                    t = t_;\n                    normal = normalize(hit_-ctr);\n                    break;\n                    }\n                }\n            }\n            else if (foo==1.)\n            {\n                // Cylinder isect\n                vec3 ctr = cell+vec3(0.5,0.,0.5);\n                //Line to form ax+bz+c=0\n                //float a = rd.z*10.f;\n                //float b = rd.x*10.f;\n                //float c = ((ro.x+b)*ro.z - (ro.z+a) * ro.x); //x2y1-y2x1\n                //float dist = abs(a*ctr.x + b*ctr.z + c)/sqrt(a*a+b*b);\n                float dist = length(((ro_.xz-ctr.xz)-(dot((ro_.xz-ctr.xz),normalize(rd.xz))* normalize(rd.xz))));\n                dist *= length(rd.xz);\n                //float dist = length(vec3((ro-ctr).xz-(dot((ro-ctr).xz,rd.xz)*rd.xz),0.));\n\n                    //float t_ = -dot((ro_-ctr),rd);\n                    //vec3 hit_ = ro_+rd*t_;\n                //if (dist<.5 ){//&& hit.y > ctr.y) {\n                if (dist<.5) {\n\n                    vec3 oc = ro - ctr;\n                    float a = dot(normalize(rd.xz), normalize(rd.xz));\n                    float b = 2.0 * dot(oc.xz, normalize(rd.xz));\n                    float c = dot(oc.xz,oc.xz) - .4*.4;\n                    float discriminant = b*b - 4.*a*c;\n                    float t_ = (-b - sqrt(discriminant)) / (2.0*a);\n                    t_ /= length(rd.xz);\n                    vec3 hit_ = ro_ + rd*t_;\n\n                    //t = t_;\n                    if (hit_.y > ctr.y && hit_.y < ctr.y+1.)\n                    {\n                        //hit = hit_;\n                        t = t_;\n                        normal = normalize(hit_-vec3(ctr.x,hit_.y,ctr.z));\n                        break;\n                    }\n                    t_ = (-b + sqrt(discriminant)) / (2.0*a);\n                    t_ /= length(rd.xz);\n                    hit_ = ro_ + rd*t_;\n                    if (hit_.y > ctr.y && hit_.y < ctr.y+1.)\n                    {\n                        //normal = vec3(0.,1.,0.);\n                        //t = planet.y;\n                        //hit = ro_ + rd*t;\n                    //hit = hit_;\n                        t = t_;\n                        normal = -normalize(hit_-vec3(ctr.x,hit_.y,ctr.z));\n                        break;\n                    }\n                }\n            }\n            else if (foo==2.||foo==3.||foo == 4.||foo==5.||foo==6.)\n            {\n                vec3 ctr = cell+vec3(0.5,0.,0.5);\n                vec3 ul = cell+vec3(0.,0.,0.);\n                vec3 lr = cell+vec3(1.,0.,1.);\n                //vec3 relro = ro_ - ctr;\n                vec3 s0 = vec3(1.f,1.f,0.f);\n                vec3 s1 = vec3(-1.f,1.f,0.f);\n                vec3 s2 = vec3(0.f,0.f,1.f);\n                \n                if (foo ==3.)\n                {\n                    s0 = vec3(0.f,1.f,1.f);\n                    s1 = vec3(0.f,1.f,-1.f);\n                    s2 = vec3(1.f,0.f,0.f);\n                }\n                if (foo ==4.)\n                {\n                    s0 = vec3(0.f,1.f,1.f);\n                    s1 = vec3(0.f,0.f,1.f);\n                    s2 = vec3(1.f,0.f,0.f);\n                }\n                if (foo ==5.)\n                {\n                    s0 = vec3(0.f,1.f,-1.f);\n                    s1 = vec3(0.f,0.f,1.f);\n                    s2 = vec3(1.f,0.f,0.f);\n                }\n                if (foo ==6.)\n                {\n                    s0 = vec3(1.f,1.f,0.f);\n                    s1 = vec3(0.f,0.f,1.f);\n                    s2 = vec3(1.f,0.f,0.f);\n                }\n                //vec3 s2 = vec3(0.f,1.f,1.f);\n                //vec3 s3 = vec3(0.f,1.f,-1.f);\n                float t0a = (dot(ul,s0) - dot(ro_,s0)) / dot(rd, s0); \n                float t0b = (dot(lr,s0) - dot(ro_,s0)) / dot(rd, s0); \n                float t1a = (dot(ul,s1) - dot(ro_,s1)) / dot(rd, s1); \n                float t1b = (dot(lr,s1) - dot(ro_,s1)) / dot(rd, s1); \n                float t2a = (dot(ul,s2) - dot(ro_,s2)) / dot(rd, s2); \n                float t2b = (dot(lr,s2) - dot(ro_,s2)) / dot(rd, s2); \n                float min0 = min(t0a,t0b);\n                float min1 = min(t1a,t1b);\n                float min2 = min(t2a,t2b);\n                float tmin = max(max(min(t0a,t0b), min(t1a,t1b)), min(t2a,t2b));\n                float tmax = min(min(max(t0a,t0b), max(t1a,t1b)), max(t2a,t2b));\n                vec3 hit_ = ro_ + rd*tmin;\n                //if (hit_.y >= ctr.y)\n                if (tmax >= tmin && hit_.y >= ctr.y)\n                {\n                    //hit = hit_;\n                    t = tmin;\n                    normal = s2;;\n                    if (min0 > min1 && min0 > min2)\n                        normal = normalize(s0);\n                    else if (min1 > min2 && min1 > min0)\n                        normal = normalize(s1);\n                    if (dot(normal, rd) > 0.) normal *= -1.;\n                    break;\n                }\n                \n            }\n            else if(false)// (foo==4.)\n            {\n                vec3 ctr = cell+vec3(0.5,0.,0.5);\n                vec3 ul = cell+vec3(0.,0.,0.);\n                vec3 lr = cell+vec3(1.,0.,1.);\n                //vec3 relro = ro_ - ctr;\n                vec3 s0 = vec3(0.f,1.f,1.f);\n                vec3 s1 = vec3(1.f,0.f,0.f);\n                vec3 s2 = vec3(0.f,0.f,1.f);\n                //vec3 s2 = vec3(0.f,1.f,1.f);\n                //vec3 s3 = vec3(0.f,1.f,-1.f);\n                float t0a = (dot(ul,s0) - dot(ro_,s0)) / dot(rd, s0); \n                float t0b = (dot(lr,s0) - dot(ro_,s0)) / dot(rd, s0); \n                float t1a = (dot(ul,s1) - dot(ro_,s1)) / dot(rd, s1); \n                float t1b = (dot(lr,s1) - dot(ro_,s1)) / dot(rd, s1); \n                float t2a = (dot(ul,s2) - dot(ro_,s2)) / dot(rd, s2); \n                float t2b = (dot(lr,s2) - dot(ro_,s2)) / dot(rd, s2); \n                float min0 = min(t0a,t0b);\n                float min1 = min(t1a,t1b);\n                float min2 = min(t2a,t2b);\n                float tmin = max(max(min(t0a,t0b), min(t1a,t1b)), min(t2a,t2b));\n                float tmax = min(min(max(t0a,t0b), max(t1a,t1b)), max(t2a,t2b));\n                vec3 hit_ = ro_ + rd*tmin;\n                //if (hit_.y >= ctr.y)\n                if (tmax >= tmin && hit_.y >= ctr.y)\n                {\n                    //hit = hit_;\n                    t = tmin;\n                    normal = s2;;\n                    if (min0 > min1 && min0 > min2)\n                        normal = normalize(s0);\n                    else if (min1 > min2 && min1 > min0)\n                        normal = normalize(s1);\n                    if (dot(normal, rd) > 0.) normal *= -1.;\n                    break;\n                }\n                \n            }\n        }\n        \n    }\n    return vec4(normal, t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    \n    \n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n\n    // Camera stoel IIRC from iquilez\n    // camera\t\n    vec3 ta = vec3( 0.25, -0.75, -0.75 );\n    vec3 ro = ta + vec3( 35.*cos(0.1*time + 40.0*mo.x), 30, 35.*sin(0.1*time + 40.0*mo.x) );\n    //vec3 ro = ta + vec3( 25.*cos(0.1*time + 40.0*mo.x), 30, 25.*sin(0.1*time + 20.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    // focal length\n    const float fl = 2.5;\n\n    // ray direction\n    vec3 rd = ca * normalize( vec3(p,fl) );\n    rd = normalize(rd);\n   \n    \n    vec3 planehit = ro - rd * (ro.y / rd.y);\n    \n    //vec2 xy = floor(planehit.xz*1.f);\n    \n    //vec3 col_ = 0.5 + 0.5*cos(xy.xyy);\n    vec3 xy = floor(vec3(planehit.x-planehit.z,planehit.x+planehit.z,planehit.x));\n    \n    vec3 col_ = 0.5 + 0.5*cos(xy.xyz);\n    fragColor = vec4(col_,1.0);\n    if(false)return;\n    \n    vec4 fuu = traverse(ro, rd);\n\n    float t = fuu.w;\n    vec3 normal = fuu.xyz;\n    vec3 hit = ro+t*rd;\n    vec3 cell = floor(hit);\n    \n    vec3 sun = vec3(20.f,25.f,20.f);\n    vec3 shadow_rd = normalize(sun-hit);\n    vec4 bar = traverse(hit + 0.01*shadow_rd, shadow_rd);\n    float shadow_occ = 1.f;\n    if (bar.w != BIGFLOAT)\n        shadow_occ = 0.f;\n    \n    \n    float ambient = 0.2;\n    \n    vec3 lightdir = normalize(sun-hit);\n\t\tfloat spec = max(pow( max(0.,dot( -rd ,normalize(2.0*dot(lightdir,normal)*normal + (lightdir))) ), 100.0),0.);\n    vec3 col = clamp((10.f+cell)/20.f,0.1,1.) *vec3(1.f,1.,0.5)* (ambient + spec + shadow_occ* (0.8)*clamp(dot(normal, normalize(sun-hit)), 0., 1.));\n    col = clamp(col,0.,1.);\n    //col=normalize(normal)*0.5+0.5;\n    //col = ((10.f+cell)/20.f);// * ((hit.z)/20.f);\n    //col = ((cell)/20.f);// * ((hit.z)/20.f);\n    //col = ((10.f+cell)/20.f) * (hit.y-cell.y);\n    //col = max(0.,0.5+0.5*dot(vec3(0.3,0.7,0.4), normal)) * vec3(0.15, 0.2, 0.3);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}