{"ver":"0.1","info":{"id":"M3XBD2","date":"1728918013","viewed":19,"name":"éclairement de phong","username":"Anthony","description":"phong","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["phong"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Distance functions\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// Définition correcte de sdPlane\nfloat sdPlane(vec3 p, vec3 n, float h)\n{\n    // n doit être normalisé\n    return dot(p, n) + h;\n}\n\n// Dans votre fonction map ou scène\nfloat map(vec3 p) {\n    float sphere = sdSphere(p - vec3(0, 1, 0), 1.0);\n    \n    // Utilisation correcte de sdPlane\n    vec3 planeNormal = vec3(0, 1, 0); // Normal du plan (vers le haut)\n    float planeHeight = 0.0; // Distance du plan à l'origine\n    float plane = sdPlane(p, planeNormal, planeHeight);\n    \n    return min(sphere, plane);\n}\n\n// Normal calculation\nvec3 calcNormal(vec3 p) {\n    const float eps = 0.0001;\n    const vec2 h = vec2(eps, 0);\n    return normalize(vec3(\n        map(p + h.xyy) - map(p - h.xyy),\n        map(p + h.yxy) - map(p - h.yxy),\n        map(p + h.yyx) - map(p - h.yyx)\n    ));\n}\n\n// Ray marching\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for(int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        float d = map(p);\n        if(d < 0.001 || t > 20.0) break;\n        t += d;\n    }\n    return t;\n}\n\n// Shadow calculation\nfloat softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\n    float res = 1.0;\n    float t = mint;\n    for(int i = 0; i < 16; i++) {\n        float h = map(ro + rd * t);\n        if(h < 0.001) return 0.0;\n        res = min(res, k * h / t);\n        t += clamp(h, 0.01, 0.2);\n        if(t > maxt) break;\n    }\n    return res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Camera setup\n    vec3 ro = vec3(0, 2, -5);\n    vec3 rd = normalize(vec3(uv, 1));\n    \n    // Light setup\n    vec3 lightPos = vec3(5, 5, -5);\n    \n    // Ray marching\n    float t = rayMarch(ro, rd);\n    vec3 p = ro + rd * t;\n    \n    // Shading\n    vec3 col = vec3(0);\n    if(t < 20.0) {\n        vec3 n = calcNormal(p);\n        vec3 l = normalize(lightPos - p);\n        \n        float diff = max(dot(n, l), 0.0);\n        float amb = 0.1;\n        \n        // Shadow calculation\n        float shadow = softShadow(p, l, 0.01, 10.0, 16.0);\n        \n        col = vec3(1) * (diff * shadow + amb);\n    }\n    \n    // Gamma correction\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}