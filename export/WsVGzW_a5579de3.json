{"ver":"0.1","info":{"id":"WsVGzW","date":"1569829320","viewed":281,"name":"BeyondTimeWarp","username":"rmmcal","description":"Just a contribution to time...","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","text","clock","wall","floor","chain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//  originally posted on http://glslsandbox.com/e#57593.5\n//    by twitter/@rmmcal\n//\n//  Rename to: BeyondTimeWarp\n//\n//  fork from http://glslsandbox.com/e#57593.0\n//  fork from http://glslsandbox.com/e#3044.0\n/////////////////////////////////////////////////////////////////////////////////////////\n\n// https://www.shadertoy.com/view/XtsSDH\n// https://www.shadertoy.com/view/ldl3zn\n// https://www.shadertoy.com/view/Msl3Rn\n\n\n// TimeWarp @P_Malin\n \n// added pan/zoom - hard work stolen from other shaders, thanks @emackey\n \n#ifdef GL_ES\nprecision highp float;\n#endif\n \n#define time iTime\n#define mouse iMouse.xy/iResolution.xy-.5\n#define resolution iResolution.xy\n \n// somehow these enable pan/zoom controls (using magic)\n//uniform vec2 surfaceSize;\n//varying vec2 surfacePosition;\n\nvec2 surfaceSize;\nvec2 surfacePosition;\n    \nconst float kPI = acos(0.0);\nconst float kHalfPi = asin(1.0);\nconst float kTwoPI = kPI * 2.0;\n\n \n \n//#define ENABLE_MONTE_CARLO\n#define ENABLE_REFLECTIONS\n//#define ENABLE_FOG\n#define ENABLE_SPECULAR\n#define ENABLE_DIRECTIONAL_LIGHT\n\n#ifdef ENABLE_MONTE_CARLO\nvec4 gPixelRandom;\nvec3 gRandomNormal;\n \nvoid CalcPixelRandom()\n{\n    // Nothing special here, just numbers generated by bashing keyboard\n    vec4 s1 = sin(time * 3.3422 + gl_FragCoord.xxxx * vec4(324.324234, 563.324234, 657.324234, 764.324234)) * 543.3423;\n    vec4 s2 = sin(time * 1.3422 + gl_FragCoord.yyyy * vec4(567.324234, 435.324234, 432.324234, 657.324234)) * 654.5423;\n    gPixelRandom = fract(2142.4 + s1 + s2);\n    gRandomNormal = normalize( gPixelRandom.xyz - 0.5);\n}\n\nfloat GetTime()\n{\n\treturn 0.0;\n}\n#else\nfloat GetTime()\n{\n\treturn time;\n}\n#endif\n \nstruct C_Ray\n{\n    vec3 vOrigin;\n    vec3 vDir;\n};\n \nstruct C_HitInfo\n{\n    vec3 vPos;\n    float fDistance;\n    vec3 vObjectId;\n};\n \nstruct C_Material\n{\n    vec3 cAlbedo;\n\tfloat fR1;\n    float fR0;\n    float fSmoothness;\n    vec2 vParam;\n};\n \nvec3 RotateX( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n   \n    vec3 vResult = vec3( vPos.x, c * vPos.y + s * vPos.z, -s * vPos.y + c * vPos.z);\n   \n    return vResult;\n}\n \nvec3 RotateY( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n   \n    vec3 vResult = vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\n   \n    return vResult;\n}\n   \nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n   \n    vec3 vResult = vec3( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y, vPos.z);\n   \n    return vResult;\n}\n \nvec4 DistCombineUnion( const in vec4 v1, const in vec4 v2 )\n{\n    //if(v1.x < v2.x) return v1; else return v2;\n    return mix(v1, v2, step(v2.x, v1.x));\n}\n \nvec4 DistCombineIntersect( const in vec4 v1, const in vec4 v2 )\n{\n    return mix(v2, v1, step(v2.x,v1.x));\n}\n \nvec4 DistCombineSubtract( const in vec4 v1, const in vec4 v2 )\n{\n    return DistCombineIntersect(v1, vec4(-v2.x, v2.yzw));\n}\n \nvec3 DomainRepeatXZGetTile( const in vec3 vPos, const in vec2 vRepeat, out vec2 vTile )\n{\n    vec3 vResult = vPos;\n    vec2 vTilePos = (vPos.xz / vRepeat) + 0.5;\n    vTile = (vTilePos + 1000.0);\n    vResult.xz = (fract(vTilePos) - 0.5) * vRepeat;\n    return vResult;\n}\n \nvec3 DomainRepeatXZ( const in vec3 vPos, const in vec2 vRepeat )\n{\n    vec3 vResult = vPos;\n    vec2 vTilePos = (vPos.xz / vRepeat) + 0.5;\n    vResult.xz = (fract(vTilePos) - 0.5) * vRepeat;\n    return vResult;\n}\n \nvec3 DomainRepeatY( const in vec3 vPos, const in float fSize )\n{\n    vec3 vResult = vPos;\n    vResult.y = (fract(vPos.y / fSize + 0.5) - 0.5) * fSize;\n    return vResult;\n}\n \nvec3 DomainRotateSymmetry( const in vec3 vPos, const in float fSteps )\n{\n    float angle = atan( vPos.x, vPos.z );\n \n    float fScale = fSteps / (kTwoPI);\n    float steppedAngle = (floor(angle * fScale + 0.5)) / fScale;\n \n    float s = sin(-steppedAngle);\n    float c = cos(-steppedAngle);\n \n    vec3 vResult = vec3( c * vPos.x + s * vPos.z,\n                vPos.y,\n                -s * vPos.x + c * vPos.z);\n \n    return vResult;\n}\n \nfloat GetDistanceXYTorus( const in vec3 p, const in float r1, const in float r2 )\n{\n    vec2 q = vec2(length(p.xy)-r1,p.z);\n    return length(q)-r2;\n}\nfloat GetDistanceYZTorus( const in vec3 p, const in float r1, const in float r2 )\n{\n    vec2 q = vec2(length(p.yz)-r1,p.x);\n    return length(q)-r2;\n}\nfloat GetDistanceCylinderY(const in vec3 vPos, const in float r)\n{\n    return length(vPos.xz) - r;\n}\nfloat GetDistanceBox( const in vec3 vPos, const in vec3 vSize )\n{\n    vec3 vDist = (abs(vPos) - vSize);\n    return max(vDist.x, max(vDist.y, vDist.z));\n}\n \nfloat GetDistanceRoundedBox( const in vec3 vPos, const in vec3 vSize, float fRadius )\n{\n    vec3 vClosest = max(min(vPos, vSize), -vSize);\n    return length(vClosest - vPos) - fRadius;\n}\n \nfloat GetDistanceWinder( const in vec3 vPos )\n{\n   float fWinderSize = 0.15;\n   float fAngle = atan(vPos.x, vPos.z) + vPos.y * 2.0;\n\t\n   float fBump = 1.0 + sin(fAngle * 10.0 * kPI) * 0.05;\n   return length(vPos + vec3(0.0, -1.0 - 0.2, 0.0)) * fBump - fWinderSize;\t\n}\n\nvec4 GetDistanceClock( const in vec3 vPos )\n{\n\tconst float fRadius = 1.0;\n\tconst float fThickness = 0.1;\n\tconst float fInsetRadius = 0.9;\n\tconst float fInsetDepth = 0.1;\n\tfloat fTorusDist = GetDistanceXYTorus(vPos, 1.0, fThickness);\n\t\n\tfloat fCylinderDist = length(vPos.xy) - fRadius;\n\tfloat fCylinderCap = abs(vPos.z) - fThickness;\n\tfCylinderDist = max(fCylinderDist, fCylinderCap);\n\tfloat fDist = min(fTorusDist, fCylinderDist);\n\t\n\tfloat fWinderDist = GetDistanceWinder(vPos);\n\tfDist = min(fDist, fWinderDist);\n\tvec4 vResult = vec4(fDist, 2.0, 0.0, 0.0);\n\t\n\tfloat fInsetDist = length(vPos.xy) - fInsetRadius;\n\tfloat fInsetCap = abs(vPos.z - fThickness) - fInsetDepth;\n\t\n\tvec4 vInsetCapDist = vec4(fInsetCap, 3.0, vPos.x, vPos.y);\n\tvec4 vInsetDist = vec4(fInsetDist, 2.0, 0.0, 0.0);\n\t\n\tvInsetDist = DistCombineIntersect(vInsetDist, vInsetCapDist);\n\t\n\tvResult = DistCombineSubtract(vResult, vInsetDist);\n\t\n\t\n\tfloat fHandSeconds = time;\n\t\n\tfHandSeconds = floor(fHandSeconds) + (pow(fract(fHandSeconds), 50.0));\n\tfloat fHandAngle = -fHandSeconds * kPI * 2.0 / 60.0;\n\t\n\tvec3 vHandDomain = RotateZ(vPos, fHandAngle);\n\tfloat fHandHeight = 0.05;\n\tvHandDomain.z -= fThickness - fInsetDepth + fHandHeight;\n\tfloat fHandDist = length(vHandDomain.xz) - 0.01;\n\tfHandDist = max(fHandDist, (abs(vHandDomain.y + 0.4) - 0.4));\n\t\n\tvec4 vHandDist = vec4(fHandDist, 4.0, 0.0, 0.0);\n\t\n\tvResult = DistCombineUnion(vResult, vHandDist);\n\t\n\treturn vResult;\n}\n \nvec3 WarpDomain( const in vec3 vPos )\n{\n\tvec3 vResult = vPos + vec3(0.0, 0.1, 0.1);\n\n\tfloat fUnbend = clamp(atan(vResult.y, vResult.z), 0.0, kPI * 0.9);\n\t\n\tfloat t = abs(fract(time/50.)*2.-1.);\n\tvResult = mix(vResult, RotateX(vResult, -fUnbend), t );\n\t \n\tfloat fDroopBlend = max(-vResult.y, 0.0);\t\n\tvResult.y = mix(vResult.y, vResult.y + fDroopBlend * 0.4, t);\n\tvResult.z = mix(vResult.z, vResult.z + sin(vResult.x * 4.0  + vResult.y * 6.0 + time) * fDroopBlend * 0.05, t);\n\treturn vResult;\n}\n\n// Utilities\nfloat udBox(vec3 p, vec3 s) { return length(max(abs(p)-s,0.0)); }\n\nfloat GetDistanceChain(vec3 vPos)\n{\n\tvec3 vChainDomain = vPos;\n\tvChainDomain.y = fract(vChainDomain.y + 0.5) - 0.5;\t\t\n\tfloat fDistTorus1 = GetDistanceXYTorus(vChainDomain, 0.35, 0.1);\n\tvChainDomain.y = fract(vChainDomain.y + 1.0) - 0.5;\t\t\n\tfloat fDistTorus2 = GetDistanceYZTorus(vChainDomain, 0.35, 0.1);\n\tfloat fDist = min(fDistTorus1, fDistTorus2);\n\treturn fDist;\n}\n\nvec2 DistCombineUnion( const in vec2 v1, const in vec2 v2 )\n{\n\treturn mix(v1, v2, step(v2.x, v1.x));\n}\n\nvec2 DistCombineIntersect( const in vec2 v1, const in vec2 v2 )\n{\n\treturn mix(v2, v1, step(v2.x,v1.x));\n}\nvec2 DistCombineSubstract( const in vec2 v1, const in vec2 v2 )\n{\n\treturn DistCombineIntersect(v1, vec2(-v2.x, v2.y));\n}\n\nfloat GetDistanceSceneChain( const in vec3 vPos, float fRepeat )\n{             \n\tvec2 vDistFloor = vec2(10000.0, -1.0);\n\t \n\tvec2 vChainTile;\n\tvec3 vChainDomain = vPos;\n\n\tvChainDomain.xz += fRepeat / 2.0;\n\tvChainDomain = DomainRepeatXZGetTile(vChainDomain, vec2(fRepeat), vChainTile);\n\tfloat fSpeed = (sin(vChainTile.y + vChainTile.x) + 1.1) * 0.5;\n\t\n\tvec2 vDistChain = vec2( GetDistanceChain(vChainDomain), 100.0);\n\n\tvec2 vDistChainHole = vec2( GetDistanceCylinderY(vChainDomain, 0.7), 2.0);\t\n\tvec2 vResult = vDistFloor;\n\tvResult = DistCombineSubstract( vResult, vDistChainHole );\n\tvResult = DistCombineUnion( vResult, vDistChain );\n\t\n\tfloat bounding = udBox(vPos-vec3(0.0,17.0,0.0), vec3(fRepeat,20.0,fRepeat));\n\tvResult.x = max(bounding, vResult.x);\t\n\t\n\treturn vResult.x;\n}\n\n\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\n\n// return distance, and cell id\nfloat voronoi( in vec2 x )\n{\n\t   \n\tvec2 n = floor( x );\n\tvec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n\tfor( int j=-1; j<=1; j++ )\n\tfor( int i=-1; i<=1; i++ )\n\t{\n\t\tvec2  g = vec2( float(i), float(j) );\n\t\tvec2  o = hash( n + g );\n\t\tvec2  r = g - f + (0.5+0.5*sin(6.2831*o));\n\tfloat d = dot( r, r );\n\t\tif( d<m.x )\n\t\t\tm = vec3( d, o );\n\t}\n\n\t vec2 c = vec2( sqrt(m.x), m.y+m.z );\n\t\n\treturn 0.5 + 0.5*cos( c.y*6.2831 + 0.0 );\t\n}\n\nconst float lineWidth = 0.059;\nconst float border = 0.05;\nconst float scale = 0.07;\nfloat line(vec2 p, vec2 s, vec2 e) {s*=scale;e*=scale;float l=length(s-e);vec2 d=vec2(e-s)/l;p-=vec2(s.x,-s.y);p=vec2(p.x*d.x+p.y*-d.y,p.x*d.y+p.y*d.x);return length(max(abs(p-vec2(l/2.0,0))-vec2(l/2.0,lineWidth/2.0),0.0))-border;}\nfloat A(vec2 p){float d=1.0;d=min(d,line(p,vec2(1,8),vec2(1,1.5)));d=min(d,line(p,vec2(1,1.5),vec2(5,1.5)));d=min(d,line(p,vec2(5,1.5),vec2(5,5)));d=min(d,line(p,vec2(5,5),vec2(1,5)));d=min(d,line(p,vec2(1,5),vec2(5,5)));d=min(d,line(p,vec2(5,5),vec2(5,8)));return d;}\nfloat C(vec2 p){float d=1.0;d=min(d,line(p,vec2(5,1.5),vec2(1,1.5)));d=min(d,line(p,vec2(1,1.5),vec2(1,8)));d=min(d,line(p,vec2(1,8),vec2(5,8)));return d;}\nfloat L(vec2 p){float d=1.0;d=min(d,line(p,vec2(1,1.5),vec2(1,8)));d=min(d,line(p,vec2(1,8),vec2(5,8)));return d;}\nfloat R(vec2 p){float d=1.0;d=min(d,line(p,vec2(1,8),vec2(1,1.5)));d=min(d,line(p,vec2(1,1.5),vec2(5,1.5)));d=min(d,line(p,vec2(5,1.5),vec2(5,5)));d=min(d,line(p,vec2(5,5),vec2(1,5)));d=min(d,line(p,vec2(1,5),vec2(3.5,5)));d=min(d,line(p,vec2(3.5,5),vec2(5,8)));return d;}\nfloat M(vec2 p){float d=1.0;d=min(d,line(p,vec2(1,8),vec2(1,1.5)));d=min(d,line(p,vec2(1,1.5),vec2(3,4)));d=min(d,line(p,vec2(3,4),vec2(5,1.5)));d=min(d,line(p,vec2(5,1.5),vec2(5,8)));return d;}\nfloat AT(vec2 p){float d=1.0;d=min(d,line(p,vec2(5, 1.5),vec2(1, 1.5)));d=min(d,line(p,vec2(1,1.5),vec2(1,8)));d=min(d,line(p,vec2(1,8),vec2(5,8)));d=min(d,line(p,vec2(3.5,5),vec2(5, 5)));d=min(d,line(p,vec2(5,5),vec2(5,1.0)));return d;}\nvec2 rot(vec2 v, float angle){float c = cos(angle); float s = sin(angle); return mat2(c, -s, s, c)*v;}\nconst vec3 boundingSize = vec3(40.,30.,1.0)*scale;\nvec2 pv = vec2(0);\n\n#define __ pv = pv + vec2(0.5,0);\n\n\n#define P p.xy-(pv = pv + vec2(0.5,0))\n#define _(v) letters = min(letters,v(P));\n\nvec4 sceneText1(const in vec3 p1)\n{\t\n\tvec3 p = p1;\n\tp.x += 1.2;\n\tp.xz = rot(p.xz,3.1416);\t\n\tfloat letters  = 1e10;\t\n\tp += vec3 ( 4.0, 0.2, 0. );\n\tfloat bounding = udBox(p-vec3(2.0,0.0,0.4), boundingSize);\n   \tpv = vec2(0); _(AT)__ _(R)_(M)_(M)_(C)_(A)_(L)\n\tletters = max(bounding, letters);\t\n\tvec4 vHandDist = vec4(letters, 4.0, 0.0, 0.0);\n\treturn vHandDist  ; \n}\n\n// result is x=scene distance y=material or object id; zw are material specific parameters (maybe uv co-ordinates)\nvec4 GetDistanceScene( const in vec3 vPos )\n{         \n\tvec4 vResult = vec4(10000.0, -1.0, 0.0, 0.0);\n   \n\tvec3 vClockDomain = WarpDomain(vPos + vec3(0.0, -0.1, -0.45));\n\tvClockDomain.y += 0.2;\t\n\tvResult = DistCombineUnion(vResult, GetDistanceClock(vClockDomain));\t\n    \tvResult = DistCombineUnion(vResult,  sceneText1(vPos));    \n\tvResult = DistCombineUnion(vResult, vec4(udBox(vPos+vec3(0.,3.,0.),vec3(5.,.2,5.)),5.,vPos.xz)); // floor\n\tvResult = DistCombineUnion(vResult, vec4(udBox(vPos+vec3(0.,1.,0.),vec3(3., 1.,.2)),1.,vPos.xy)); // wall    \n\tvResult = DistCombineUnion(vResult, vec4(GetDistanceSceneChain(vPos, 5.),6.,vPos.xy)); // wall\n\t\n\tvec2 t = vec2(3.,0.0);\n\tvec2 q = vec2(length(vPos.xy)-3., max(0.,abs(vPos.z)-1.));\n\tvec3 p = vPos*1.5;\n\tfloat min_wave = cos(p.x*p.y/100.)*cos(p.x * 23. + cos(p.z * 3.))/280. ;\n\tfloat v1 = abs(voronoi(p.xz*1.5))/8.;\n\tfloat noise = 0.;\n\tfloat terrain = 0.;\n\tfloat v = abs(p.y + noise + min_wave + terrain + 100.1 ) - 90.;\n\tvResult = DistCombineUnion(vResult, vec4(v, 7., p.xz)); // wall\n  \n\treturn vResult;\n}\n \nvec3 GetWatchFaceColour( const vec2 vUV )\n{\n        float fRadius = length(vUV);\n       \n        float fFraction = (atan(vUV.x, -vUV.y) / (kPI * 2.0)) + (0.5 / 60.0);\n               \n        float fTickValue = fFraction * 60.0;   \n        float fTickIndex = floor(fTickValue);\n        float fTickFraction = fract(fTickValue);\n               \n\tfloat fTickLength = 0.25;       \n\tfTickLength += step( fract(fTickIndex / 10.0), 0.5 / 10.0 ) * 0.1;\n\tfTickLength += step( fract(fTickIndex / 5.0), 0.5 / 5.0 ) * 0.05;\n\t\n\tfloat fTickWidth = 0.2;\n\tfloat fInTickSegment = step(abs(fTickFraction - 0.5), fTickWidth);\n\t\n\tfloat fInTickRadiusOuter = step(fRadius, 0.8);\n\tfloat fInTickRadiusInner = step(1.0 - fTickLength, fRadius);\n\t\n\t// 1.0 if not one of these...\n\tfloat fBlend = 1.0 - fInTickSegment * fInTickRadiusOuter * fInTickRadiusInner;\n\t\n\t// central dot\n\tfBlend = fBlend * step(0.025, fRadius);                                 \n\t\n\treturn mix(vec3(0.05), vec3(0.95), fBlend);\n}\n\nvec3 hsv2rgb (in vec3 hsv) {\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\treturn hsv.z * (1.0 + 0.5 * hsv.y * (cos (1.0 * 3.14159 * (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvec4 grid (vec2 frag) {\n\tfrag *= 10.0;\n\tfloat random = rand (floor (frag));\n\tvec2 black = smoothstep (1.0, 0.9, cos (frag * 3.14159 * 2.0));\n\tvec3 color = hsv2rgb (vec3 (random, 1.0, 1.0));\n\tcolor *= black.x * black.y * smoothstep (1.0, 0.1,length(fract(frag) - 0.5));\n\tcolor *= 0.5 + 0.8 * cos (random * time ); \n\treturn vec4 (color * vec3(1.0,1.0,1.0), 1.0);\n}\nC_Material GetObjectMaterial( const in vec3 vObjId, const in vec3 vPos )\n{\n    C_Material mat;\n    mat.fR1 = 1.;\n    if(vObjId.x < 1.5)\n    {\n        // wall\n        mat.fR0 = 0.02;\n        mat.fSmoothness = 0.0;\n\tvec2 vBrickPos = vObjId.yz;\n\tvBrickPos.x += floor(vBrickPos.y * 3.0) * 0.5;\n\tvBrickPos = fract(vBrickPos * vec2(1.0, 3.0));\n\t   \n        float fFade = 1.0 - step(vBrickPos.x, 0.96) * step(vBrickPos.y, 0.9);\n        //mat.cAlbedo = vec3(0.9, 0.4, 0.2) * (0.3 + fFade * 0.6);\n\t    \n\tfloat v = voronoi((vPos.yz+vPos.x)*500.);\n\tmat.cAlbedo = vec3(0.9, 0.4, 0.2) * (0.3 + fFade * 0.6) * (v/5.+.3);\n\tmat.fR1 = (v*v)/10.0;\n    }\n    else\n    if(vObjId.x < 2.5)\n    {\n        // silver\n        mat.fR0 = 0.95;\n        mat.fSmoothness = 0.9;\n        mat.cAlbedo = vec3(0.9, 0.9, 0.91);\n    }\n    else\n    if(vObjId.x < 3.5)\n    {\n\t    // clock face\n            mat.fR0 = 0.01;\n            mat.fSmoothness = 0.9;\n            mat.cAlbedo = GetWatchFaceColour( vObjId.yz );\n    }\n    else\n    if(vObjId.x < 4.5)\n    {\n        // hand\n        mat.fR0 = 0.01;\n        mat.fSmoothness = 0.9;\n        mat.cAlbedo = vec3(0.95, 0.05, 0.05);\n    }\n    else\n    if(vObjId.x < 5.5)\n    {\n        // floor      \n\t\tmat.fR0 = 0.10;\t    \n\t\tmat.fSmoothness = 1.2;\n\t\t\n\t\tvec2 vBrickPos = vObjId.yz;\n\t\tvBrickPos.x += floor(vBrickPos.y * 3.0) * 0.5;\n\t\tvBrickPos = fract(vBrickPos * vec2(1.0, 3.0));\n\t   \n\t\tfloat fFade = 1.0 - step(vBrickPos.x, 0.96) * step(vBrickPos.y, 0.9);\n\t\n\t    \tfloat v2 =  voronoi(vObjId.yz*5.);\n\t\tvec3 cAlbedo = vec3(0.0, 0.11, 0.0) * (0.3 + fFade * 0.6) * v2;\n\t\t//vec3 ghsv = grid(vec2(vBrickPos/8.)).xyz / 5.;\n\t    \tmat.cAlbedo = mix(cAlbedo, cAlbedo, .2);\n    }\n\t else\n\tif(vObjId.x < 6.5)\n\t{\n\t\t// hand\n\t\tmat.fR0 = 0.41;\n\t\tmat.fSmoothness = 0.2;\n\t\tmat.cAlbedo = vec3(0.95, 0.35, 0.00) ;\n\t} else\n\tif(vObjId.x < 7.5)\n\t{\n\t\t// hand\n\t\tmat.fR1 = 0.1;\n\t\tmat.fR0 = .001;\n\t\tmat.fSmoothness = .05;\n\t\tmat.cAlbedo = vec3(0.15, 0.15, 0.15) ;\n\t}\n    return mat;\n}\nvec3 GetLightDirection()\n{\n    vec3 vLightDir = vec3(1.0, 2.0, 1.0);\n\n    #ifdef ENABLE_MONTE_CARLO       \n    vLightDir += gRandomNormal * 0.01;\n    #endif\n    return normalize(vLightDir);\n}\nvec3 GetLightCol()\n{\n    return vec3(1.0, 0.7, 0.5) * 10.0;\n}\n\nvec3 GetSkyGradient( const in vec3 vDir )\n{\n\tfloat v = abs(dot(vDir.xyz, vDir.yzx));\n\tfloat fBlend =   vDir.y * 0.5 + 0.5 + v*v;  \n\treturn mix(vec3(0.0, 0.0, 0.0), vec3(0.25, 0.5, 1.0) * 4.0, fBlend);\n}\n \nvec3 GetAmbientLight(const in vec3 vNormal)\n{\n    return GetSkyGradient(vNormal);\n}\n \n#define kFogDensity 0.075\nvoid ApplyAtmosphere(inout vec3 col, const in C_Ray ray, const in C_HitInfo intersection)\n{\n    #ifdef ENABLE_FOG\n    // fog\n    float fFogAmount = exp(intersection.fDistance * -kFogDensity);\n    vec3 cFog = GetSkyGradient(ray.vDir);\n    col = mix(cFog, col, fFogAmount);\n    #endif\n}\n\nvec3 GetSceneNormal( const in vec3 vPos )\n{\n    // tetrahedron normal\n    float fDelta = 0.01;\n \n    vec3 vOffset1 = vec3( fDelta, -fDelta, -fDelta);\n    vec3 vOffset2 = vec3(-fDelta, -fDelta,  fDelta);\n    vec3 vOffset3 = vec3(-fDelta,  fDelta, -fDelta);\n    vec3 vOffset4 = vec3( fDelta,  fDelta,  fDelta);\n \n    float f1 = GetDistanceScene( vPos + vOffset1 ).x;\n    float f2 = GetDistanceScene( vPos + vOffset2 ).x;\n    float f3 = GetDistanceScene( vPos + vOffset3 ).x;\n    float f4 = GetDistanceScene( vPos + vOffset4 ).x;\n \n    vec3 vNormal = vOffset1 * f1 + vOffset2 * f2 + vOffset3 * f3 + vOffset4 * f4;\n \n    return normalize( vNormal );\n}\n \n#define kRaymarchEpsilon 0.01\n#define kRaymarchMatIter 256\n#define kRaymarchStartDistance 0.01\n// This is an excellent resource on ray marching -> https://iquilezles.org/articles/distfunctions\nvoid Raymarch( const in C_Ray ray, out C_HitInfo result, const float fMaxDist, const int maxIter )\n{       \n    result.fDistance = kRaymarchStartDistance;\n    result.vObjectId.x = 0.0;\n                             \n    for(int i=0;i<=kRaymarchMatIter;i++)             \n    {\n        result.vPos = ray.vOrigin + ray.vDir * result.fDistance;\n        vec4 vSceneDist = GetDistanceScene( result.vPos );\n        result.vObjectId = vSceneDist.yzw;\n \n        // abs allows backward stepping - should only be necessary for non uniform distance functions\n        if((abs(vSceneDist.x) <= kRaymarchEpsilon) || (result.fDistance >= fMaxDist) || (i > maxIter))\n        {\n            break;\n        }                       \n \n        result.fDistance = result.fDistance + vSceneDist.x;   \n    }\n     \n      \n    if(result.fDistance >= fMaxDist)\n    {\n        result.vPos = ray.vOrigin + ray.vDir * result.fDistance;\n        result.vObjectId.x = 0.0;\n        result.fDistance = 1000.0;\n    }\n}\n \nfloat GetShadow( const in vec3 vPos, const in vec3 vLightDir, const in float fLightDistance )\n{\n    C_Ray shadowRay;\n    shadowRay.vDir = vLightDir;\n    shadowRay.vOrigin = vPos;\n \n    C_HitInfo shadowIntersect;\n    Raymarch(shadowRay, shadowIntersect, fLightDistance, 32);\n                                                                                                       \n    return step(0.0, shadowIntersect.fDistance) * step(fLightDistance, shadowIntersect.fDistance );         \n}\n \n// http://en.wikipedia.org/wiki/Schlick's_approximation\nfloat Schlick( const in vec3 vNormal, const in vec3 vView, const in float fR0, const in float fSmoothFactor)\n{\n    float fDot = dot(vNormal, -vView);\n    fDot = min(max((1.0 - fDot), 0.0), 1.0);\n    float fDot2 = fDot * fDot;\n    float fDot5 = fDot2 * fDot2 * fDot;\n    return fR0 + (1.0 - fR0) * fDot5 * fSmoothFactor;\n}\n \nfloat GetDiffuseIntensity(const in vec3 vLightDir, const in vec3 vNormal)\n{\n    return max(0.0, dot(vLightDir, vNormal));\n}\n \nfloat GetBlinnPhongIntensity(const in C_Ray ray, const in C_Material mat, const in vec3 vLightDir, const in vec3 vNormal)\n{         \n    vec3 vHalf = normalize(vLightDir - ray.vDir);\n    float fNdotH = max(0.0, dot(vHalf, vNormal));\n \n    float fSpecPower = exp2(4.0 + 6.0 * mat.fSmoothness);\n    float fSpecIntensity = (fSpecPower + 2.0) * 0.125;\n \n    return pow(fNdotH, fSpecPower) * fSpecIntensity;\n}\n \n// use distance field to evaluate ambient occlusion\nfloat GetAmbientOcclusion(const in C_Ray ray, const in C_HitInfo intersection, const in vec3 vNormal)\n{\n    vec3 vPos = intersection.vPos;\n     \n    float fAmbientOcclusion = 1.0;\n     \n    float fDist = 0.0;\n    for(int i=0; i<=5; i++)\n    {\n        fDist += 0.1;\n \n        vec4 vSceneDist = GetDistanceScene(vPos + vNormal * fDist);\n \n        fAmbientOcclusion *= 1.0 - max(0.0, (fDist - vSceneDist.x) * 0.2 / fDist );                                 \n    }\n     \n    return fAmbientOcclusion;\n}\n \nvec3 GetObjectLighting(const in C_Ray ray, const in C_HitInfo intersection, const in C_Material material, const in vec3 vNormal, const in vec3 cReflection)\n{\n    vec3 cScene ;\n   \n    vec3 vSpecularReflection = vec3(0.0);\n    vec3 vDiffuseReflection = vec3(0.0);\n   \n    //float fAmbientOcclusion = GetAmbientOcclusion(ray, intersection, vNormal);\n    //vec3 vAmbientLight = GetAmbientLight(vNormal) * fAmbientOcclusion;\n    vec3 vAmbientLight = GetAmbientLight(vNormal) * material.fR1;\n\t\n    vDiffuseReflection += vAmbientLight;\n   \n    //vSpecularReflection += cReflection * fAmbientOcclusion;\n    vSpecularReflection += cReflection;\n             \n   // #ifdef ENABLE_DIRECTIONAL_LIGHT\n    vec3 vLightDir = GetLightDirection();\n      \n    float fShadowBias = 0.05;           \n    float fShadowFactor = GetShadow( intersection.vPos + vLightDir * fShadowBias, vLightDir, 10.0 );\n    vec3 vIncidentLight = GetLightCol() * fShadowFactor;\n   \n    vDiffuseReflection += GetDiffuseIntensity( vLightDir, vNormal ) * vIncidentLight;                                                                               \n    vSpecularReflection += GetBlinnPhongIntensity( ray, material, vLightDir, vNormal ) * vIncidentLight;\n   // #endif ENABLE_DIRECTIONAL_LIGHT\n   \n    vDiffuseReflection *= material.cAlbedo;             \n    \n    #ifdef ENABLE_SPECULAR\n    float fFresnel = Schlick(vNormal, ray.vDir, material.fR0, material.fSmoothness * 0.9 + 0.1);\n    cScene = mix(vDiffuseReflection , vSpecularReflection, fFresnel);\n    #else\n    cScene = vDiffuseReflection;\n    #endif\n   \n    return cScene;\n}\n \nvec3 GetSceneColourSimple( const in C_Ray ray )\n{\n    C_HitInfo intersection;\n    Raymarch(ray, intersection, 16.0, 32);\n                       \n    vec3 cScene;\n \n    if(intersection.vObjectId.x < 0.5)\n    {\n        cScene = GetSkyGradient(ray.vDir);\n    }\n    else\n    {\n        C_Material material = GetObjectMaterial(intersection.vObjectId, intersection.vPos);\n        vec3 vNormal = GetSceneNormal(intersection.vPos);\n \n        // use sky gradient instead of reflection\n        vec3 cReflection = GetSkyGradient(reflect(ray.vDir, vNormal));\n \n        // apply lighting\n        cScene = GetObjectLighting(ray, intersection, material, vNormal, cReflection );\n    }\n \n    ApplyAtmosphere(cScene, ray, intersection);\n \n    return cScene;\n}\n \nvec3 GetSceneColour( const in C_Ray ray )\n{                                                         \n    C_HitInfo intersection;\n    Raymarch(ray, intersection, 30.0, 256);\n               \n    vec3 cScene;\n     \n    if(intersection.vObjectId.x < 0.5)\n    {\n        cScene = GetSkyGradient(ray.vDir);\n    }\n    else\n    {\n        C_Material material = GetObjectMaterial(intersection.vObjectId, intersection.vPos);\n        vec3 vNormal = GetSceneNormal(intersection.vPos);\n \n        #ifdef ENABLE_MONTE_CARLO\n        vNormal = normalize(vNormal + gRandomNormal / (5.0 + material.fSmoothness * 200.0));\n        #endif\n \n        vec3 cReflection;\n        #ifdef ENABLE_REFLECTIONS   \n        {\n            // get colour from reflected ray\n            float fSepration = 0.05;\n            C_Ray reflectRay;\n            reflectRay.vDir = reflect(ray.vDir, vNormal);\n            reflectRay.vOrigin = intersection.vPos + reflectRay.vDir * fSepration;\n                                                                 \n            cReflection = GetSceneColourSimple(reflectRay);                                                                       \n        }\n        #else\n        cReflection = GetSkyGradient(reflect(ray.vDir, vNormal));                             \n        #endif\n        // apply lighting\n        cScene = GetObjectLighting(ray, intersection, material, vNormal, cReflection );\n    }\n     \n    ApplyAtmosphere(cScene, ray, intersection);\n     \n    return cScene;\n}\n \nvoid GetCameraRay( const in vec3 vPos, const in vec3 vForwards, const in vec3 vWorldUp, out C_Ray ray)\n{\n    vec2 vPixelCoord = gl_FragCoord.xy;\n    #ifdef ENABLE_MONTE_CARLO\n    vPixelCoord += gPixelRandom.zw;\n    #endif\n    vec2 vUV = ( vPixelCoord / resolution.xy );\n    vec2 vViewCoord = vUV * 2.0 - 1.0;\n \n    vViewCoord *= 0.75;\n     \n    float fRatio = resolution.x / resolution.y;\n \n    vViewCoord.y /= fRatio;                         \n \n    ray.vOrigin = vPos;\n \n    vec3 vRight = normalize(cross(vForwards, vWorldUp));\n    vec3 vUp = cross(vRight, vForwards);\n       \n    ray.vDir = normalize( vRight * vViewCoord.x + vUp * vViewCoord.y + vForwards);       \n}\n \nvoid GetCameraRayLookat( const in vec3 vPos, const in vec3 vInterest, out C_Ray ray)\n{\n    vec3 vForwards = normalize(vInterest - vPos);\n    vec3 vUp = vec3(0.0, 1.0, 0.0);\n \n    GetCameraRay(vPos, vForwards, vUp, ray);\n}\n \nvec3 OrbitPoint( const in float fHeading, const in float fElevation )\n{\n    return vec3(sin(fHeading) * cos(fElevation), sin(fElevation), cos(fHeading) * cos(fElevation));\n}\n \nvec3 Gamma( const in vec3 cCol )\n{\n    return cCol * cCol;\n}\n \nvec3 InvGamma( const in vec3 cCol )\n{\n    return sqrt(cCol);\n}\n \n \nvec3 Tonemap( const in vec3 cCol )\n{\n    // simple Reinhard tonemapping operator   \n    vec3 vResult = cCol / (1.0 + cCol);\n \n    return Gamma(vResult);\n}\n \nvec3 InvTonemap( const in vec3 cCol )\n{\n    vec3 vResult = cCol;\n    vResult = clamp(vResult, 0.01, 0.99);\n    vResult = InvGamma(vResult);\n    return - (vResult / (vResult - 1.0));\n}\n \nvoid mainBuff(  out vec4 fragColor, in vec2 fragCoord )\n{\n    float pan = 1.;\n    float zoom = 3.;\n    vec2 r = resolution;\n    vec2 p = gl_FragCoord.xy/r;\n    surfaceSize=vec2(pan, zoom);\n\tsurfacePosition=((p-.5)*surfaceSize+(mouse+.5)*8.);\n    \n    #ifdef ENABLE_MONTE_CARLO           \n    CalcPixelRandom();\n    #endif\n     \n    C_Ray ray;\n     \n    const float fCamreaInitialHeading = -0.6;\n    const float fCamreaInitialElevation = 0.5;\n    const float fCamreaInitialDist = 4.5;\n    const float fOrbitSpeed = 1.0;\n   \n    // This magic stolen from other 3d pan/zoom examples\n    float fZoom = surfaceSize.y * 0.5 + 0.4;\n   \n    vec2 vCenterPosition = (0.5 - ( gl_FragCoord.xy / resolution )) * surfaceSize + surfacePosition;\n    float fHeading = vCenterPosition.x * fOrbitSpeed + fCamreaInitialHeading;\n    float fElevation = (vCenterPosition.y * fOrbitSpeed + fCamreaInitialElevation);\n   \n    vec3 vCameraPos = OrbitPoint(fHeading, fElevation) * fCamreaInitialDist * fZoom;\n   \n    #ifdef ENABLE_MONTE_CARLO           \n    float fDepthOfField = 0.025;\n    vCameraPos += gRandomNormal * fDepthOfField;\n    #endif\n     \n    GetCameraRayLookat( vCameraPos, vec3(0.0, -0.5, 0.2), ray);\n     \n    vec3 cScene = GetSceneColour( ray ); \n      \n    float fExposure = 2.5;\n    cScene = cScene * fExposure;\n     \n    #ifdef ENABLE_MONTE_CARLO                             \n    vec3 cPrev = texture2D(backbuffer, gl_FragCoord.xy / resolution).xyz;\n    // add noise to pixel value (helps values converge)\n    cPrev += (gPixelRandom.xyz - 0.5) * (1.0 / 255.0);\n    cPrev = InvTonemap(cPrev);\n    // converge speed\n    float fBlend = 0.1;\n    vec3 cFinal = mix(cPrev, cScene, fBlend);\n    #else\n    vec3 cFinal = cScene;\n    #endif\n   \n    cFinal = Tonemap(cFinal);\n         \n    float fAlpha = 1.0;\n     \n    fragColor = vec4( cFinal, fAlpha );\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tmainBuff(fragColor, fragCoord);\n}","name":"Image","description":"","type":"image"}]}