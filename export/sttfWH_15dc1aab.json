{"ver":"0.1","info":{"id":"sttfWH","date":"1663072522","viewed":164,"name":"Cube rotation","username":"Hatokuro","description":"Programme capable de tracer des lignes, d'utiliser les matrices de rotation et de mise en Ã©chelle afin d'afficher un cube en rotation","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["cuberotationvertices"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define ANTIALIASING\n\n#define DISTCAMERA 10.\n#define SIZE 1.\n//======================== LINE ========================\nfloat segment(vec2 u, vec2 a, vec2 b)  {         \n    b -= a, u -= a;\n    return length( u - b * clamp(dot(b, u) / dot(b, b), 0., 1.));\n}\n\nfloat line(vec2 uv, vec2 A,vec2 B, float width)\n{\n    float mysegment = segment(uv,A,B);\n    return mysegment = smoothstep(width,0.,mysegment);\n}\n\n//======================== MATRIX ========================\nmat3 rotateX(float angle){\n    float cosPhi = cos(angle);\n    float sinPhi = sin(angle);\n    return mat3(1.,0.,0.,\n    0.,cosPhi,-sinPhi,\n    0.,sinPhi,cosPhi);\n}\n\nmat3 rotateY(float angle){\n    float cosPhi = cos(angle);\n    float sinPhi = sin(angle);\n    return mat3(cosPhi,0.,sinPhi,\n    0.,1.,0.,\n    -sinPhi,0.,cosPhi);\n}\n\nmat3 rotateZ(float angle){\n    float cosPhi = cos(angle);\n    float sinPhi = sin(angle);\n    return mat3(cosPhi,-sinPhi,0.,\n    sinPhi,cosPhi,0.,\n    0.,0.,1.);\n}\n\nmat3 scaleXYZ(vec3 scale){\n    return mat3(scale.x,0.,0.,\n    0.,scale.y,0.,\n    0.,0.,scale.z);\n}\n//======================== COORD CUBE ========================\nconst vec3 vertices[8] = vec3[](\n    vec3(-1.,-1.,1.),\n    vec3(1.,-1.,1.),\n    vec3(-1.,1.,1.),\n    vec3(1.,1.,1.),\n    vec3(-1.,-1.,-1.),\n    vec3(1.,-1.,-1.),\n    vec3(-1.,1.,-1.),\n    vec3(1.,1.,-1.)\n);\n\nconst int orderA[12] = int[](0,2,0,3,4,6,4,7,0,1,2,3);\nconst int orderB[12] = int[](1,3,2,1,5,7,6,5,4,5,6,7);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalisation des pixel (from 0 to 1)\n    vec2 uv = (2.* fragCoord - iResolution.xy)/iResolution.y;\n    float px_size = 2. / iResolution.y;\n    vec3 col = vec3(0.);\n    \n    vec3 verticesCube[8];\n    for(int i=0;i<8;i++)\n    {\n\n        verticesCube[i] =  vertices[i] * rotateX(iTime) * rotateY(iTime) *rotateZ(iTime);\n        verticesCube[i] = verticesCube[i] *  scaleXYZ(vec3(SIZE,SIZE,SIZE)); \n        verticesCube[i].z += DISTCAMERA;\n        \n        \n        //perspective pour la profondeur\n        float ooz = 1. / verticesCube[i].z;\n\n        verticesCube[i].x = ooz* verticesCube[i].x*2.;\n        verticesCube[i].y =  ooz * verticesCube[i].y*2.;\n        \n    }\n    \n    for(int i=0;i<12;i++)\n    {\n        col += line(uv,verticesCube[orderA[i]].xy,verticesCube[orderB[i]].xy,px_size);//trassage de lignes\n    }\n\n    // Output to screen\n    #ifdef ANTIALIASING\n        fragColor = vec4(pow(col, vec3(1.0/2.2)), 1.0);\n    #else\n        fragColor = vec4(col,1.0);\n    #endif\n    \n }","name":"Image","description":"","type":"image"}]}