{"ver":"0.1","info":{"id":"lclSWN","date":"1707173625","viewed":43,"name":"* Polar Comp 15-1-24 - 3d teste","username":"davidmachadosf","description":"The images I was creating in ShaderToys were wonderful, but they had become too complex for me to try to understand what I was doing exactly... I was a bit haphazard, I was messing with the formulas, parameters, and seeing what happened. ðŸ¤£\n","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["math"],"hasliked":0,"parentid":"ctdBzn","parentname":"* Polar Complex 24-11-23"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n  David Machado Santos Filho\n  davidmachadosf@gmail.com\n  \n  Based on openprocessing app:\n  https://openprocessing.org/sketch/1916670\n  (same author)\n  \n  \n  Any suggestion for improvement and inclusion of \n  interesting features is welcome! \n  \n  Feel free to fork the code and test your own ideas! \n  This code is copyleft! ;-)\n  \n*/\n\n\n\n\nfloat pi = 3.141592;\n\nfloat uniform_to_widthNanometers (float u){\n    return 380. + 400.*(1.-u);\n}\n\nfloat uniform_to_freqTeraHertz (float u){\n    return (384. + 405.*u)*1.e3;\n}\n\nvec4 paletteReal( float w ) {\n    \n    float red, green, blue;\n\n    if (w >= 380. && w < 440.) {\n        red   = -(w - 440.) / (440. - 380.);\n        green = 0.;\n        blue  = 1.;\n    }\n    else \n    if (w >= 440. && w < 490.) {\n        red   = 0.;\n        green = (w - 440.) / (490. - 440.);\n        blue  = 1.;\n    }\n    else \n    if (w >= 490. && w < 510.) {\n        red   = 0.;\n        green = 1.;\n        blue  = -(w - 510.) / (510. - 490.);\n    }\n    else \n    if (w >= 510. && w < 580.) {\n        red   = (w - 510.) / (580. - 510.);\n        green = 1.;\n        blue  = 0.;\n    }\n    else \n    if (w >= 580. && w < 645.) {\n        red   = 1.;\n        green = -(w - 645.) / (645. - 580.);\n        blue  = 0.;\n    }\n    else \n    if (w >= 645. && w < 781.) {\n        red   = 1.;\n        green = 0.;\n        blue  = 0.;\n    }\n    else {\n        red   = 0.;\n        green = 0.;\n        blue  = 0.;\n    }\n\n\n    // Let the intensity fall off near the vision limits\n    float factor;\n    if (w >= 380. && w < 420.)\n        factor = .3 + .7*(w - 380.) / (420. - 380.);\n    else \n    if (w >= 420. && w < 701.)\n        factor = 1.;\n    else \n    if (w >= 701. && w < 781.)\n        factor = .3 + .7*(780. - w) / (780. - 700.);\n    else\n        factor = 0.;\n\n    float gamma = .8;\n    float R = (red   > 0. ? 255.*pow(red   * factor, gamma) : 0.);\n    float G = (green > 0. ? 255.*pow(green * factor, gamma) : 0.);\n    float B = (blue  > 0. ? 255.*pow(blue  * factor, gamma) : 0.); \n    \n    return vec4(R/255.,G/255.,B/255.,1.);\n}\n\nvec4 paletteRealUniform( float u ) {\n    return paletteReal(uniform_to_widthNanometers(u));\n}\n\nvec4 paletteAlien( float u ) {\n    \n    vec4 pal1 = paletteRealUniform(u);\n    vec4 pal2 = paletteRealUniform(1.-u);    \n    \n    return (pal1+pal2)/2.;\n    \n}\n\n\nvec4 paletteAssimetric( float u ) {\n    \n    vec4 pal1 = paletteAlien(u);\n    vec4 pal2 = paletteRealUniform(u);    \n    \n    return (pal1-pal2);\n    \n}\n\n\nvec4 paletteBars( float u ) {\n    \n    //vec4 pal1 = paletteAlien(u);\n    vec4 pal1 = paletteRealUniform(1.-u);    \n    vec4 pal2 = paletteRealUniform(u); \n    vec4 pal3 = paletteAlien(1.-u);\n    \n    return (pal1*pal2 + pal3)/4.;\n    \n}\n\nvec4 paletteGray( float u ) {\n   if(u>1.) u = 1.;\n   if(u<0.) u = 0.;\n   \n   return vec4(u,u,u,1.);\n}\n\nvec4 paletteRevGray( float u ) {\n   \n   return vec4(.999,.999,.999,1.)-paletteGray(u);\n}\n\nvec4 paletteGold( float u ) {\n   \n   if(u>1.) u = 1.;\n   if(u<0.) u = 0.;\n   \n   \n   \n   vec4 gold = vec4(10.*u/16.,8.*u/16.,2.*u/16.,1.);\n   vec4 red = 1.-(1.-vec4(15.*pow(u,55.)/16.,0.,0.,1.));\n   \n   \n   \n   \n   return gold+red;\n}\n\n\nvec4 processPallete(int pall, float u, bool urev){\n    \n    \n    if(urev){\n       u = 1.-u;\n    }\n    \n    \n    switch(pall){\n        case 0: return paletteRealUniform(u);\n        case 1: return paletteGray(u);\n        case 2: return paletteGold(u);\n        case 3: return paletteAlien(u);\n        case 4: return paletteAssimetric(u);\n        case 5: return paletteBars(u);\n    }\n}\n\n\n// xy are generic 2d coordinates, not necessarily cartesian\n// maybe x:radius y:angle if using polar coordinates\nfloat processFunction(int func, float x, float y, float t){\n\n    // x:radius y:angle, changed variable names for using on polar formulas\n    // not realy necessary but can make the code more clear! ;-)\n    float r = x;\n    float a = y;\n    \n    \n    \n    \n    switch(func){\n        case 0: return sin(x);\n        case 1: return sin(y);\n        case 2: return (sin(x)+sin(y))/2.;\n        case 3: return sin(x)*sin(y);\n        case 4: return sin(x)/sin(y);\n        case 5: return sin(y)/sin(x);\n        \n        \n        case  6: return sin(x)/2. + .5;\n        case  7: return sin(y)/2. + .5;\n        case  8: return (sin(x)+sin(y))/4. + .5;\n        case  9: return (sin(x)*sin(y))/2. + .5;\n        case 10: return abs(sin(x)/sin(y));\n        case 11: return abs(sin(y)/sin(x));\n        \n        case 12: return abs(sin(x));\n        case 13: return abs(sin(y));\n        case 14: return abs(sin(x)+sin(y))/2.;\n        case 15: return abs(sin(x)*sin(y));\n        case 16: return abs(sin(x)/sin(y));\n        case 17: return abs(sin(y)/sin(x));\n        \n        case 18: return 1./log(abs(sin(x)/sin(y)));\n        case 19: return 1./log(abs(sin(y)/sin(x)));\n        \n        \n        case 20: return x;\n        case 21: return y;\n        \n        case 22: return sin(t*pi*y)/2.+.5;\n        case 23: return sin(t*t*pi*y)/2.+.5;\n        case 24: return sin(t*t*pi*y/x)/2.+.5;\n        case 25: return sin(t*t*t*pi*y/x)/2.+.5;\n        \n        \n        \n       \n        case 26: return abs(sin(x*y)/sin(y/x))*(sin(t)/2. + .5);\n        case 27: return abs(sin(y/t+x)/sin(t/x))*(sin(t)/2. + .5);\n        case 28: return abs(sin(x-y)/sin(y-t))*(sin(t)/2. + .5);\n        \n        \n        case 29: return abs(sin(cos(y))/cos(x))*(sin(t+x+y)/2. + .5);\n        \n        \n    \n        case 30: return log(abs(x)) + log(abs(y));\n        case 31: return log(abs(x)) +         y  ;\n        case 32: return         x   + log(abs(y));\n        case 33: return         x   +         y  ;\n        case 34: return         x   +   sin(y)*y ;\n        case 35: return       x*x   +   log(y*y) ;\n        case 36: return  log(x*x)   +       y*y  ;\n        case 37: return     x*x*y   +       y/x  ;\n        case 38: return     x*x*x   +     y*y*y  ;\n        case 39: return   cos(x/y)*x*x*x   + sin(y)*y*y*y  ;\n        case 40: return x*x*x*x*x   + y*y*y*y*y  ;\n        case 41: return      1./x   +      1./y  ;\n        case 42: return  1./(x*x)   -  1./(y/x)  ;\n        case 43: return 1./(x*x*x)  + 1./(y*y*y) ;\n        case 44: return     sin(log(abs(x*y)))   + \n                            cos(log(abs(y/x)))   ;\n        case 45: return (y+x)/cos(x*y*x)  + sin(x-y)/(y*x*y) ;\n        case 46: return sin(abs(atan(y/x)))+y/x;\n        case 47: return sin(log(abs(atan(y/x))))+y/x;\n        \n        case 48: return sin(y/x)*cos(x/y);\n        case 49: return (y+x)/x*cos(x+y);\n        \n        // new funcs\n        case 50: return (y/sin(x))/(y*cos(x/y));\n        case 51: return (1./sin(x))/(y*cos(x/y));\n        case 52: return (y/sin(x))/(x/cos(y));\n        case 53: return (y/sin(atan(x/y)))/(x/cos(atan(y/x)));\n        case 54: return (y+x)*t;\n        case 55: return (y/x)/t;\n        \n        \n        case 56: return .5*sin((r+a)/t+.1);\n        \n        case 57: return (sin(x*y)+sin(x-y));\n        \n        \n        \n        //when none functions mathes\n        default:  return .5;\n    }\n\n}\n\nfloat atan2_error(float y, float x){\n\n    if(x==0.) return (pi/2.)*(y>=0.?1.:-1.);\n    \n    float atanYX = atan(y,x);\n    \n    if(x>0.) return atanYX;\n    \n    return atanYX + pi*(y<0.?1.:-1.); \n\n}\n\n\nfloat atan2( float y, float x )\n{\n\tif ( x == 0.0f )\n\t{\n\t\tif ( y > 0.0f ) return pi/2.;\n\t\tif ( y == 0.0f ) return 0.;\n\t\treturn -pi/2.;\n\t}\n\tfloat atan;\n\tfloat z = y/x;\n\tif ( abs( z ) < 1. )\n\t{\n\t\tatan = z/(1. + .28*z*z);\n\t\tif ( x < 0. )\n\t\t{\n\t\t\tif ( y < 0.) return atan - pi;\n\t\t\treturn atan + pi;\n\t\t}\n\t}\n\telse\n\t{\n\t\tatan = pi/2. - z/(z*z + 0.28f);\n\t\tif ( y < 0. ) return atan - pi;\n\t}\n\treturn atan;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    \n    \n    float[5] colors;\n    \n    //\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(.5,0.);\n    uv *= vec2(iResolution.x/iResolution.y,1.);\n    uv += vec2(.5,0.);\n    //uv *= vec2(iResolution.x/iResolution.y,1.);\n    //uv += vec2(.5,0.);\n    \n    \n    // get parameters\n    float xi   = get(paramXi );\n    float xf   = get(paramXf );\n    float yi   = get(paramYi );\n    float yf   = get(paramYf );\n    float vel  = get(paramVel);\n    \n    \n    int func = int(get(paramFunc));\n    \n    bool      cicle = get(paramCicle)>0.;\n    float  velCicle = get(paramVelCicle);\n    float timeCicle = get(paramTimeCicle);\n    float timeBase  = get(paramTimeBase);    \n    float cpow      = get(paramCpow);\n    \n    int pall = int(get(paramPall));\n    \n    bool polar = get(paramPolar)>0.;\n    bool reverse = get(paramReverse)>0.;\n    bool urev = get(paramUrev)>0.;\n    \n    float x = (xi+(xf-xi)*uv.x);\n    float y = (yi+(yf-yi)*uv.y);\n    \n    float d, newx, newy;\n    float t = timeCicle;\n\n    \t\n        \n    if(cicle){\n      float dt = (1.*iTime - timeBase)*velCicle;\n      t += dt;        \n    }\n    \n    \n\n    \n    if(polar){\n        // coordenadas polares\n        //float r = pow(x*x+y*y,.5);\n        //float a = abs(atan(x,y));\n        \n        \n        float r = pow(x*x+y*y,.5);\n        float a = abs(atan2(x,y))/pi;\n        \n        if(x<0.) a *= .5;\n        else a = 1. - a*.5;\n        \n        \n        x=r;\n        y=a*r+t;\n    }\n    \n    \n        //coordenadas cartesianas\n    float r = x;\n    float a = y;\n    \n    \n    \n    \n   \n\n     \n    //d = .2;\n    for(int i=0;i<5;i++){\n\n        \n            \n        \n        /*else\n        if(func>26) {\n            d = processFunction(func-26,r/t,a*t,t);\n        }        \n        else\n        if(func<0) {\n            d = processFunction(-func+1,r/a,r*(log(t)),t);\n        }\n        else {*/\n            d = processFunction(func,(cos(r+t)+1.)/1.,a*float(i)*1.5+.1,t);\n        \n        \n        \n        //float omegax = cos(2.*pi+sin((d+t)*y));\n        //float omegay = sin(2.*pi+cos((d-t)*x));\n\n        \n        //float omegax = y/d + x/sqrt(n) + thetax + 2.*t;\n        //float omegay = x/d + y/sqrt(n) + thetay + .5*t;\n\n        //newx = omegax;\n        //newy = omegay;\n\n        //x = newx;\n        //y = newy;\n        \n        \n        //colors[i]=pow(d,cpow);\n        //colors[i]=pow((sin(d)+1.)/2.,cpow)*255.;//abs(pow(((x/t-y)/2.+1.)/2.,cpow))*255.;\n        \n        float color = \n            i==4?.5*(cos(d)+1.):\n            i==0?cos(abs(a*r+d)/r):\n            i==3?.5*(sin(abs(d)/abs(r/a))+1.):\n            i==2?.5*(sin(d/float(i))+.5):\n            i==1?.5*(cos(float(i)/d)+.5):\n            .1*abs(a+d);\n            \n        colors[i] = pow(color,cpow);\n    }\n\t\t\t\n\n    // Output to screen\n    //vec3 col = vec3();\n    \n    \n    \n    //fragColor = vec4(colors[2]/256.,colors[4]/256.,colors[3]/256.,1.0);\n    //float w1 = uniform_to_widthNanometers(colors[1]/256.);\n    //float w2 = uniform_to_widthNanometers(colors[2]/256.);\n    //float w3 = uniform_to_widthNanometers(colors[3]/256.);\n    \n    \n    float w0 = colors[0];\n    float w1 = colors[1];\n    float w2 = colors[2];\n    float w3 = colors[3];\n    float w4 = colors[4];\n    \n    fragColor = (\n        processPallete(pall,w1,urev)*\n        processPallete(pall,w2,urev)/\n        processPallete(pall,w3,urev))/3.;//*((colors[4]+colors[0])/512.);\n    fragColor /= processPallete(pall,w4, urev);/*+colors[0]*/;\n    fragColor *= processPallete(pall,w0, urev);\n    //\n    //d = processFunction(func,x,y,t);\n    //fragColor = palleteReal(uniform_to_widthNanometers(pow(f,cpow)));\n    //fragColor = processPallete(pall,pow(f,cpow));\n    \n    if(reverse){\n        fragColor = vec4(.999,.999,.999,1.)-fragColor;\n    }\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n  David Machado Santos Filho\n  davidmachadosf@gmail.com\n  \n  Based on openprocessing app:\n  https://openprocessing.org/sketch/1916670\n  (same author)\n  \n  \n  Any suggestion for improvement and inclusion of \n  interesting features is welcome! \n  \n  Feel free to fork the code and test your own ideas! \n  This code is copyleft! ;-)\n  \n*/\n\n// parameters (coordinates on texture buffer)\nconst ivec2 paramXi = ivec2(0,0);\nconst ivec2 paramXf = ivec2(0,1);\nconst ivec2 paramYi = ivec2(0,2);\nconst ivec2 paramYf = ivec2(0,3);\n\nconst ivec2 paramVel   = ivec2(1,0);\nconst ivec2 paramFunc  = ivec2(2,0);\n\n\nconst ivec2 paramCicle     = ivec2(3,0);\nconst ivec2 paramVelCicle  = ivec2(3,1);\nconst ivec2 paramTimeCicle = ivec2(3,2);\nconst ivec2 paramTimeBase  = ivec2(3,3);\n\nconst ivec2 paramCpow      = ivec2(4,0);\nconst ivec2 paramPall      = ivec2(4,1);\nconst ivec2 paramPolar     = ivec2(4,2);\nconst ivec2 paramReverse   = ivec2(4,3);\nconst ivec2 paramUrev      = ivec2(4,4);\n\n\n\n// read and store values as x value on texture pixels\n#define get(var) texelFetch(iChannel0, var, 0).x\n#define set(var, value, fragColor, fragCoord) fragColor=(ivec2(fragCoord)==var?vec4(value,0.,0.,1.):fragColor)\n\n\n// reset to initial parameters\nconst int keyReset = 192; // the \"' key, below Esc\n\n// change image functions\nconst int keyPrev = 33; // PgUp\nconst int keyNext = 34; // PgDown\n\n\n// change position (arrow keys)\nconst int keyNorth = 38;\nconst int keySouth = 40;\nconst int keyEast  = 37;\nconst int keyWest  = 39;\nconst int keyOrig  = 12;\n\n\n// keycodes below are from numeric keyboard\n\n// change scale\nconst int keyZoomOut = 111; // /\nconst int keyZoomIn  = 106; // *\n\n// change scale velocity\nconst int keySlow = 109; // -\nconst int keyFast = 107; // +\n\n// cicle palete over time\nconst int keyCicle = 110; // .\n\n// change cicle velocity\nconst int keyCicleSlow = 36; // Home\nconst int keyCicleFast = 35; // End\n\n\n// change palete pow\nconst int keyPowDec  = 81; // q\nconst int keyPowInc  = 65; // a\nconst int keyPowZero = 90; // z\n\n\n// change palete type\nconst int keyPallInc  = 80; // p\nconst int keyPallDec  = 79; // o\nconst int keyPallZero = 73; // i\n\n// toglr polar/cartesian coordinates\nconst int keyPolar = 45; // insert, 0 on keypad\n\n// toglr polar/cartesian coordinates\nconst int keyReverse = 82; // r\nconst int keyUrev    = 85; // u\n\n\n\n\n\n\n\n\n#define keyToggle(code)  ( texelFetch(iChannel1,ivec2(code,2),0).x > 0.)\n#define keyClick(code)   ( texelFetch(iChannel1,ivec2(code,1),0).x > 0.)\n#define keyDown(code)    ( texelFetch(iChannel1,ivec2(code,0),0).x > 0.)\n\n#define shift             ( texelFetch(iChannel1,ivec2(16,0),0).x  > 0.)\n#define ctrl              ( texelFetch(iChannel1,ivec2(17,0),0).x  > 0.)\n#define alt               ( texelFetch(iChannel1,ivec2(18,0),0).x  > 0.)\n#define modifier          ( int(shift) +2*int(ctrl) + 4*int(alt) )\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n  David Machado Santos Filho\n  davidmachadosf@gmail.com\n  \n  Based on openprocessing app:\n  https://openprocessing.org/sketch/1916670\n  (same author)\n  \n  \n  Any suggestion for improvement and inclusion of \n  interesting features is welcome! \n  \n  Feel free to fork the code and test your own ideas! \n  This code is copyleft! ;-)\n  \n*/\n\n\n/* MANUAL\n\nKEYS\n    ' : reset\n  (numpad numlock OFF):..\n    ARROWS   : move\n    NUMPAD5  : center 0,0\n    * /      : zoom in/out  \n    + -      : inc/dec zoom vel\n    .        : pause/play time\n    Home End : inc/dec cicle vel\n    PgUp PgDown: Cicle 31 diff f(x,y)\n    q a: change palete gamute\n    \n*/\n\nconst float lastFunc = 57.;\nconst float lastPall =  5.;\n\n\n// initial parameter values\nfloat iniXi       =  -10. ;\nfloat iniXf       =   10. ;\nfloat iniYi       =  -10. ;\nfloat iniYf       =   10. ;\nfloat iniVel      =   .01 ;\nfloat iniFunc     = 29.   ;\n\nfloat iniCicle     =  1.  ; // -1.: FALSE 1.:TRUE\nfloat iniVelCicle  =  1.  ;\nfloat iniTimeCicle =  0.  ;\nfloat iniTimeBase  =  0.  ;\n\nfloat iniCpow = 1. ; \nfloat iniPall = 0. ; \n\nfloat iniPolar   = +1.; // -1.: cartesian 1.:polar\nfloat iniReverse = -1.; // -1.: normal colors 1.:reversed colors\nfloat iniUrev    = -1.; // -1.: uniform 0-1 colors: 1. reversed 1-0 uniform scale\n\n\n\nvoid initParameters(inout vec4 fragColor, in vec2 fragCoord){\n    set(paramXi,       iniXi,       fragColor, fragCoord);   \n    set(paramXf,       iniXf,       fragColor, fragCoord);   \n    set(paramYi,       iniYi,       fragColor, fragCoord);   \n    set(paramYf,       iniYf,       fragColor, fragCoord);   \n    set(paramVel,      iniVel,      fragColor, fragCoord);   \n    set(paramFunc,     iniFunc,     fragColor, fragCoord);   \n    \n    set(paramCicle,     iniCicle,     fragColor, fragCoord);   \n    set(paramVelCicle,  iniVelCicle,  fragColor, fragCoord);   \n    set(paramTimeCicle, iniTimeCicle, fragColor, fragCoord);   \n    set(paramTimeBase,  iniTimeBase,  fragColor, fragCoord); \n    \n    set(paramCpow,  iniCpow,  fragColor, fragCoord); \n    set(paramPall,  iniPall,  fragColor, fragCoord); \n    set(paramPolar, iniPolar, fragColor, fragCoord); \n    \n    set(paramReverse, iniReverse, fragColor, fragCoord); \n    set(paramUrev,    iniUrev,    fragColor, fragCoord); \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // initialize values\n    if (iFrame==0) {\n        initParameters(fragColor, fragCoord);    \n    }\n\n    else { \n    \n        // get current values\n        float xi       = get(paramXi);   \n        float xf       = get(paramXf);   \n        float yi       = get(paramYi);   \n        float yf       = get(paramYf);   \n        float vel      = get(paramVel);   \n        float func     = get(paramFunc); \n        \n        float cicle     = get(paramCicle);  \n        float velCicle  = get(paramVelCicle);  \n        float timeCicle = get(paramTimeCicle);  \n        \n        float timeBase  = get(paramTimeBase);\n        \n        float cpow      = get(paramCpow);\n        float pall      = get(paramPall);\n        float polar     = get(paramPolar);\n        float reverse   = get(paramReverse);\n        float urev      = get(paramUrev);\n        \n        // current visible window size\n        float dx = xf-xi;\n        float dy = yf-yi;\n        \n        \n       \n        \n        // move image\n        if(keyDown(keyNorth)){\n            yi+=dy/100.;\n            yf+=dy/100.;\n        }\n        if(keyDown(keySouth)){\n            yi-=dy/100.;\n            yf-=dy/100.;\n        }\n        if(keyDown(keyEast)){\n            xi-=dx/100.;\n            xf-=dx/100.;\n        }\n        if(keyDown(keyWest)){\n            xi+=dx/100.;\n            xf+=dx/100.;\n        }\n        \n        // return to 0,0 (dont change scale)\n        if(keyDown(keyOrig)){\n            xi=-dx/2.;\n            xf=+dx/2.;\n            yi=-dy/2.;\n            yf=+dy/2.;\n        }\n        \n        // zoom controls\n        if(keyDown(keyZoomOut)){\n            xi-=dx*vel;\n            xf+=dx*vel;\n            if(!shift){\n                yi-=dy*vel;\n                yf+=dy*vel;\n            }\n        }        \n        if(keyDown(keyZoomIn)){\n            xi+=dx*vel;\n            xf-=dx*vel;\n            if(!shift){\n                yi+=dy*vel;\n                yf-=dy*vel;\n            }\n        }\n        \n        // zoom velocity change\n        if(keyClick(keySlow)){\n            vel/=2.;\n        }        \n        if(keyClick(keyFast)){\n            vel*=2.;\n        }\n                \n        \n        \n        // restart to initial status\n        if(keyClick(keyReset)){            \n            xi    = iniXi;\n            xf    = iniXf;\n            yi    = iniYi;\n            yf    = iniYf;\n            vel   = iniVel;\n            func  = iniFunc;\n            \n            cicle     = iniCicle;\n            velCicle  = iniVelCicle;  \n            timeCicle = 0.; \n            timeBase  = 1.*iTime;\n        }\n        \n        \n        // change f(x,y) function\n        if(keyClick(keyPrev)){\n            func = func-1.;\n            if(func<0.) func = lastFunc;\n        }        \n        if(keyClick(keyNext)){\n            func = func+1.;\n            if(func>lastFunc) func = 0.;\n        }\n        \n        // cicle fase and colors by iTime\n        if(keyClick(keyCicle)){\n            // its a bool, but I must store as float... \n            \n            float fTime = 1.*iTime;\n            \n            if(cicle < 0.){\n                // estava parado                \n                timeBase = fTime;\n            }\n            else{\n                // estava ciclando\n                float dt  = (fTime - timeBase)*velCicle;\n                timeCicle += dt;\n                timeBase = timeCicle;        \n            }\n                        \n            cicle*=-1.;\n        }\n        \n        // cicle velocity change\n        if(keyDown(keyCicleSlow)){\n        \n            \n            float fTime = 1.*iTime;\n            \n            if(cicle > 0.){\n                // estava ciclando\n                float dt  = (fTime - timeBase)*velCicle;\n                timeCicle += dt;\n                timeBase = fTime;        \n            }\n        \n            velCicle/=1.01;            \n        }        \n        if(keyDown(keyCicleFast)){\n            \n            float fTime = 1.*iTime;\n            \n            if(cicle > 0.){\n                // estava ciclando\n                float dt  = (fTime - timeBase)*velCicle;\n                timeCicle += dt;\n                timeBase = fTime;        \n            }\n            \n            velCicle*=1.01;            \n        }\n        \n        \n        // change palete power\n        if(keyDown(keyPowDec)){\n            cpow /=1.01;\n        }        \n        if(keyDown(keyPowInc)){\n            cpow *=1.01;\n        }\n        if(keyClick(keyPowZero)){\n            cpow = iniCpow;\n        }      \n        \n        // change palete power\n        if(keyClick(keyPallDec)){\n            pall = pall-1.;\n            if(pall<0.) pall = lastPall;\n        }        \n        if(keyClick(keyPallInc)){\n            pall = pall+1.;\n            if(pall>lastPall) pall = 0.;\n        }\n        if(keyClick(keyPallZero)){\n            pall = iniPall;\n        }  \n        \n        // change polar/cartesian\n        if(keyClick(keyPolar)){\n            // its a bool, but I must store as float... \n            polar*=-1.;\n        }\n        \n        // change color normal/reversed\n        if(keyClick(keyReverse)){\n            // its a bool, but I must store as float... \n            reverse*=-1.;\n        }\n        \n        \n        // change pallete mapping 0-1  1-0\n        if(keyClick(keyUrev)){\n            // its a bool, but I must store as float... \n            urev*=-1.;\n        }\n        \n        \n          \n        \n        \n        \n        // update parameters\n        set(paramXi,       xi,       fragColor, fragCoord);   \n        set(paramXf,       xf,       fragColor, fragCoord);   \n        set(paramYi,       yi,       fragColor, fragCoord);   \n        set(paramYf,       yf,       fragColor, fragCoord);   \n        set(paramVel,      vel,      fragColor, fragCoord);   \n        set(paramFunc,     func,     fragColor, fragCoord);   \n        \n        set(paramCicle,     cicle,     fragColor, fragCoord); \n        set(paramVelCicle,  velCicle,  fragColor, fragCoord); \n        set(paramTimeCicle, timeCicle, fragColor, fragCoord); \n        set(paramTimeBase,  timeBase, fragColor, fragCoord); \n        \n        set(paramCpow,  cpow,  fragColor, fragCoord); \n        set(paramPall,  pall,  fragColor, fragCoord); \n        set(paramPolar, polar, fragColor, fragCoord); \n        \n        set(paramReverse, reverse, fragColor, fragCoord); \n        set(paramUrev,    urev,    fragColor, fragCoord); \n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}