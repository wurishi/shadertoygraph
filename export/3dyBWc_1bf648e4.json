{"ver":"0.1","info":{"id":"3dyBWc","date":"1608051857","viewed":259,"name":"MarchingCubes~=trilinear(sdf(p))","username":"ollj","description":"i am a big fan of DualContouring and sdf:\nsomehow Trilinar interpolation over 8 corners of an sdf is a LOT like BASIC MarchingCubes:\nsee parent original:\nhttps://www.shadertoy.com/view/WsKfDV","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["dither","normal","trilinear","interpolation","mesh","tesselation","dualcontouring","dualcontouring","marchingcubes","mesheffect","sdftomesh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//ollj backup of:  https://www.shadertoy.com/view/WsKfDV\n\n/*\n\"SDF to Mesh\" by oneshade, comment by [oneshade]:\n\nAfter watching The Art of Code's (BIgWings) video about value noise,\nI started playing around with it and designed a 3D variant. I found\nthat if I removed the smooth remapping of local coordinates I got a\ncool mesh effect. It reminds me of nimitz's \"Triangulator\" shader\n(https://www.shadertoy.com/view/lllGRr) except the facets aren't always\ntriangles and it works on more than just heightmaps. I don't think\nthe facets are always perfectly planar though (take a cube for example).\n\nAlso reminds me a lot of marching cubes.\n*/\n\n// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) 0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0))\n\n#define SIN_15 0.2588190451\n#define COS_15 0.96592582628\n\nfloat Df(in vec3 p){\n    float s=iMouse.y/iResolution.y*2.-1.;\n    if(iMouse.z<0.)s=sin(iTime*.2);\n    return length(p) - 2.+s\n    //-sin(iTime*.2)\n    ;\n}\n\n//mix() recursion, AKA bilinear & trilinear... interpolation over L:\n//l.y last, is because of symmetry within DualConour-like-SDF of\n//  https://www.shadertoy.com/view/3dyBWc (and its original parent)\nfloat lin2(vec4 d,vec2 l){return mix(mix(d.x,d.y,l.x),mix(d.z,d.w,l.x),l.y);}\nfloat lin3(vec4 d,vec4 e,vec3 l){return mix(lin2(d,l.xz),lin2(e,l.xz),l.y);}\n//mapSceneMesh() 8-taps the mapScene in 4 corrners. \n//mapSceneMesh returns an SDF that LOOKS like it was DualContouring-ed\n//mapSceneMesh only does 1 TriLinear interpolation over 8 corners in 3d\nfloat Dfm(vec3 p){\n    vec3 c=floor(p);\n    mat3 a=mat3(1.);//==mat3(1,0,0,0,1,0,0,0,1)//normal matrix for 8 corner offsets\n    //8 tap 8 corners, mat4 components sorted to fit within lin3()\n    vec4 d=vec4(Df(c     ),Df(c   +a[0]),Df(c   +a[2]),Df(c+1.-a[1]));\n    vec4 e=vec4(Df(c+a[1]),Df(c+1.-a[2]),Df(c+1.-a[0]),Df(c+1.     ));\n    return lin3(d,e,fract(p));}//trilinear interpolation over fract(p)\n\n#define Derivative9Tap(a,p,b) normalize(vec3(a(p+b.yxx)-a(p-b.yxx),a(p+b.xyx)-a(p-b.xyx),a(p+b.xxy)-a(p-b.xxy)))\nvec3 getNormalMesh(vec3 p){vec2 b=vec2(0,.00001);return Derivative9Tap(Dfm,p,b);}   \nvec3 getNormal    (vec3 p){vec2 b=vec2(0,.00001);return Derivative9Tap(Df ,p,b);}  \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(1);//white for better contrast on shaded dark areas.\n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    float dt = 0.;\n    bool mesh = mod(floor(iTime), 2.0) == 0.;//toggle over time\n    fragCoord=mod(fragCoord,2.);\n    if(uv.y<0.)mesh=(fragCoord.x==fragCoord.y);//toggle checkereboard\n    //mesh=true;//overwrite\n    float tim=2.*-iMouse.x/iResolution.x;\n    if(iMouse.z<0.)tim=iTime;\n    for (int iter=0; iter < 250; iter++) {\n        vec3 p = ro + rd * dt;\n        p.yz *= mat2(COS_15, SIN_15, -SIN_15, COS_15);\n        float c = cos(tim), s = sin(tim);\n        p.xz *= mat2(c, s, -s, c);\n        float d=0.;\n        if (mesh) d=Dfm(p);\n        else      d=Df(p);\n        if (d < 0.001) {\n           if (mesh) fragColor.rgb=getNormalMesh(p)*.5+.5;//keep it simple\n           else      fragColor.rgb=getNormal    (p)*.5+.5;\n            break;}\n        if (d > 100.0)break;\n        dt += d;}\n}","name":"Image","description":"","type":"image"}]}