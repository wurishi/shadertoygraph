{"ver":"0.1","info":{"id":"styXWt","date":"1641510524","viewed":69,"name":"Phong Reflections","username":"DexM","description":"Phong reflection model. No shadows. No ray marching.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define INF (1.0 / 0.0)\n\nstruct Material\n{\n    vec3 ambientColor;\n    vec3 diffuseColor;\n    vec3 specularColor;\n    float shininess;\n};\n\n// Rotation happens in the direction specified by right hand rule\n// Axis must be unit vector (normalized)\nvec3 rotate(vec3 vec, vec3 rotationAxis, float rotationAngle)\n{\n    rotationAngle /= 2.0;\n    vec4 q = vec4(rotationAxis * sin(rotationAngle), cos(rotationAngle));\n\n    mat4 p = mat4(\n         0,      vec.z, -vec.y,  vec.x, // Column 1\n        -vec.z,  0,      vec.x,  vec.y, // Column 2\n         vec.y, -vec.x,  0,      vec.z, // Column 3\n        -vec.x, -vec.y, -vec.z,  0);    // Column 4\n\n    mat4 invQ = mat4(\n         q.w, -q.z,  q.y, -q.x,  // Column 1\n         q.z,  q.w, -q.x, -q.y,  // Column 2\n        -q.y,  q.x,  q.w, -q.z,  // Column 3\n         q.x,  q.y,  q.z,  q.w); // Column 4\n    \n    return (q * p * invQ).xyz;\n}\n\n// Calculate distance to an infinite plane\n// Plane is one sided, normal vector specifies outside\nfloat planeDistance(vec3 rayOrigin, vec3 rayDirection, vec3 planeOrigin, vec3 planeNormal)\n{\n    // Check whether ray origin is under the plane\n    float side = sign(dot(rayOrigin - planeOrigin, planeNormal));\n\n    // Calculate distance to the plane\n    float depth = side * dot(planeOrigin - rayOrigin, planeNormal) / dot(rayDirection, planeNormal);\n    \n    // Check whether intersection point is behind ray origin\n    if (depth < 0.0)\n        return side * INF;\n\n    return depth;\n}\n\n// Calculate distance to a sphere\nfloat sphereDistance(vec3 rayOrigin, vec3 rayDirection, vec3 sphereOrigin, float sphereRadius)\n{\n    // Part of the formula we need to get square root of\n    vec3 rso = rayOrigin - sphereOrigin;\n    float rsoLen = length(rso);\n    float rdrsoDot = dot(rayDirection, rso);\n    float d = rdrsoDot * rdrsoDot - rsoLen * rsoLen + sphereRadius * sphereRadius;\n    \n    if (d < 0.0)\n        return INF; // Ray does not intersect sphere\n\n    // Find intersection distances\n    float sq = sqrt(d);\n    vec2 dist = vec2(sq, -sq) - rdrsoDot;\n\n    float minDist = min(dist.x, dist.y);\n    float maxDist = max(dist.x, dist.y);\n\n    // Check whether both intersection points are behind ray origin\n    if (maxDist < 0.0)\n        return INF;\n    \n    // Check whether we are inside the sphere\n    if (minDist < 0.0)\n        return -maxDist;\n    \n    return minDist;\n}\n\n// Calculate pixel color based on phong reflection model\nvec3 singleLightPhong(vec3 normal, vec3 cameraDirection, vec3 lightDirection, Material material)\n{\n    float diffuseDot = dot(lightDirection, normal);\n    material.diffuseColor *= max(diffuseDot, 0.0);\n    \n    vec3 reflectionDirection = reflect(-lightDirection, normal);\n    float specularDot = dot(reflectionDirection, cameraDirection);\n    material.specularColor *= pow(specularDot, material.shininess) * step(0.0, specularDot);\n\n    return material.ambientColor + material.diffuseColor + material.specularColor;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    // UV has origin at the center of the screen and farthest edge of the canvas is at distance 1\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / max(iResolution.x, iResolution.y);\n\n    // Set up camera\n    const vec3 cameraOrigin = vec3(0);\n    const vec3 cameraDirection = vec3(0, 0, -1);\n    const float cameraFieldOfView = radians(45.0) / 2.0; // Divide by 2, because our UV go from -1 to 1\n\n    // Set up ray to render view\n    float rayAngle = cameraFieldOfView * length(uv);\n    vec3 rayRotationAxis = normalize(cross(cameraDirection, vec3(uv, 0)));\n    vec3 ray = rotate(cameraDirection, rayRotationAxis, rayAngle);\n    \n    // Scene setup\n    const vec3 planeOrigin = vec3(0, -1, 0);\n    const vec3 planeNormal = vec3(0, 1, 0);\n\n    const float sphereRadius = 1.0;\n    const vec3 sphereOrigin1 = vec3(-1.1, 0, -7);\n    const vec3 sphereOrigin2 = vec3(1.1, 0, -7);\n\n    const vec3 pointLightInitialPosition = vec3(0, 0, 5);\n    const vec3 pointLightOrbitCenterTranspose = vec3(0, 5, -7);\n    const vec3 pointLightOrbitAxis = normalize(vec3(0.1, 1, 0));\n\n    const Material backgroundMaterial = Material(vec3(0.07), vec3(0), vec3(0), 0.0);\n    const Material planeMaterial = Material(vec3(0.07), vec3(0.1, 0.9, 0.1), vec3(0), 0.0);\n    const Material sphereMaterial1 = Material(vec3(0.2, 0.07, 0.07), vec3(0.8, 0, 0), vec3(0.2, 0.4, 0.4), 5.0);\n    const Material sphereMaterial2 = Material(vec3(0.07, 0.07, 0.3), vec3(0, 0, 0.7), vec3(1), 20.0);\n\n    // Calculate depth, normal and material\n    float depth = INF;\n    vec3 normal = -ray;\n    Material material = backgroundMaterial;\n\n    float newDepth;\n    \n    newDepth = planeDistance(cameraOrigin, ray, planeOrigin, planeNormal);\n    if (newDepth < depth)\n    {\n        depth = newDepth;\n        normal = planeNormal;\n        material = planeMaterial;\n    }\n    \n    newDepth = sphereDistance(cameraOrigin, ray, sphereOrigin1, sphereRadius);\n    if (newDepth < depth)\n    {\n        depth = newDepth;\n        normal = normalize(cameraOrigin + ray * depth - sphereOrigin1);\n        material = sphereMaterial1;\n    }\n    \n    newDepth = sphereDistance(cameraOrigin, ray, sphereOrigin2, sphereRadius);\n    if (newDepth < depth)\n    {\n        depth = newDepth;\n        normal = normalize(cameraOrigin + ray * depth - sphereOrigin2);\n        material = sphereMaterial2;\n    }\n    \n    // Calculate lighting\n    vec3 lightDirection;\n    if (isinf(depth))\n        lightDirection = -ray;\n    else\n    {\n        vec3 pointLightPosition = rotate(pointLightInitialPosition, pointLightOrbitAxis, iTime) + pointLightOrbitCenterTranspose;\n        lightDirection = normalize(pointLightPosition - (cameraOrigin + ray * depth));\n    }\n    \n    vec3 color = singleLightPhong(normal, -ray, lightDirection, material);\n    \n    // Render result\n    fragColor = vec4(color, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}