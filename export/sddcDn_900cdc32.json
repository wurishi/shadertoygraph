{"ver":"0.1","info":{"id":"sddcDn","date":"1729781844","viewed":744,"name":"SpilledCoffee","username":"stephenl7797","description":"My first ray-traced scene. I wrote this 2 years ago and have no idea what the code is doing lol","likes":37,"published":1,"flags":32,"usePreview":1,"tags":["pathtrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\n\nvec4 debugShape(out vec4 outc, in vec2 FC) {\n    vec3 ro = vec3(0.,0.,-7.);\n    vec3 rd = normalize(vec3((FC-R.xy*.5) / R.yy, 3.));\n    ro.xz = mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime)) * ro.xz;\n    rd.xz = mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime)) * rd.xz;\n    \n    float t = 0.;\n    for (int i=0;i<60;i++) {\n    \n\n            \n        vec3 p = ro+t*rd;\n        int id;\n        float d = sceneSdf(p,id);\n        \n        //t += d*.995;\n        t += d*.65;\n        \n        if (t > 30.) break;\n    }\n    \n    vec3 p = ro + t * rd;\n    vec2 D = vec2(1.,0.) * .001;\n    int id;\n    vec3 n = normalize(vec3(\n            sceneSdf(p + D.xyy,id) - sceneSdf(p - D.xyy,id),\n            sceneSdf(p + D.yxy,id) - sceneSdf(p - D.yxy,id),\n            sceneSdf(p + D.yyx,id) - sceneSdf(p - D.yyx,id)));\n    \n    vec4 c = vec4(0.);\n    if (t < 29.99) {\n        c.rgb += .1;\n        c.rgb += abs(n);\n        }\n    return c;\n}\n\n\n\n\n\n\n\n\nvoid mainImage( out vec4 outc, in vec2 FC)\n{\n    vec4 samp = IC0(ivec2(FC));\n    samp.rgb /= samp.a;\n\n    // Output to screen\n    outc = vec4(samp);\n    \n    // Helper for shape modelling\n    //outc = debugShape(outc, FC);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float FOCAL = 1.80;\n\n\n\n/*\nfloat liq_map(vec3 p) {\n        const vec3 ctr = vec3(0.,-.6,0.);\n    \n        // sphere\n        float r = .6;\n        vec3 pp = p;\n        //pp.xz *= 1.15 + length(pp.xz);\n        r += (noise33(pp*.5).x-.6) * 1.35;\n        vec3 nn = noise33(pp*2.);\n        r += (nn.x-.2) * .35;\n        vec3 nnn = noise33(nn+p*4.);\n        r += (nnn-.2).x * .5 * .25;\n        r += (noise33(nnn*5. + nn+p*19.)-.2).x * .5 * .125;\n        \n        //p.xz *= 1. + length(p.xz);\n        //r=.4;\n        float d = length((ctr-p) * vec3(1.,1.,1.)) - r;\n        \n        // box\n        //d = length(ctr-p) - .7;\n        //vec3 q = abs(p-ctr) - vec3(.4);\n        //return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n        return d;\n}\n*/\n\n\n\n\nfloat liquid(vec3 ro, vec3 rd, out vec3 n, inout float len, out bool isNowInside, out int hitId) {\n\n    int hit;\n    // If we start inside the isovolume (-), then flip the sign.\n    float d1 = sceneSdf(ro, hit);\n    float sign_ = sign(d1);\n    if (hit != ID_LIQ) sign_ = 1.;\n    float t = .00000001;\n    \n    \n    for (int i=0; i<50; i++) {\n    \n        vec3 p = ro + t * rd;\n        float d = sceneSdf(p, hitId) * .85 * sign_;\n        //if (d < 0.) break;\n        \n        //vec3 pp = (rand33(p*10.) - .5) * .0001;\n        //rd = normalize(mix(rd, (rand33(p*10.) - .5), .001));\n      \n    \n        t += d;\n        if (t > 20.) {\n            isNowInside = false;\n            return 0.;\n        };\n    }\n    \n    vec3 p = ro + t * rd;\n    vec2 D = vec2(1.,0.) * .0001;\n    n = normalize(vec3(\n            sceneSdf(p + D.xyy, hit) - sceneSdf(p - D.xyy, hit),\n            sceneSdf(p + D.yxy, hit) - sceneSdf(p - D.yxy, hit),\n            sceneSdf(p + D.yyx, hit) - sceneSdf(p - D.yyx, hit)));\n\n\n    if (sign_ < 0.) len += abs(t);\n    else len = 0.;\n    if (sign_ < 0.) n *= -1.;\n    \n    const vec3 ctr = vec3(0.,-.85,0.);\n    //n = -normalize(p-ctr);\n    if (sceneSdf(p, hit) < 0. && hit == ID_LIQ) isNowInside = true;\n    else isNowInside = false;\n    hitId = hit;\n    \n    return t;\n}\n\nfloat hit_cylinder(vec3 ro, vec3 rd, inout float t, out vec3 n, out vec3 nro, out vec3 nrd) {\n    \n    mat3 CR = mat3(1.);\n    // Hit outer cylinder\n    vec3 no;\n    float ot = xsect_cylinder(CR*ro-vec3(0.55,-.7,3.6), CR*rd, no, .5, .5);\n    if (ot != 0. && ot < t) {\n        t = ot;\n        vec3 p = CR*(ro+ot*rd*EPS1);\n        vec3 n = CR*n;\n        \n        // Hit inner cylinder\n        if (abs(no.y) > .999) {\n            vec3 ni;\n            float it = xsect_cylinder(CR*ro-vec3(0.55,-.7,3.6), CR*rd, ni, .5, .5);\n            if (it > 0. && abs(ni.y) < .999) {\n                \n            }\n        }\n        \n        nrd = reflect(rd,n);\n        nro = p;\n        return ot;\n    }\n    return 0.;\n}\n\nvoid mainImage( out vec4 outc, in vec2 FC)\n{\n    //return;\n\n    vec3 eye = vec3(-.2, 0.4, -6.);\n    //vec3 eye = vec3(0., -1.8, -4.);\n    \n    const float DEPTH_BLUR = 1.3;\n    //vec2 FCO = DEPTH_BLUR*(abs(vec2(sin(FC.x*.01-FC.y*.01+iTime*71.79999), cos(FC.y*.01+iTime*139.3333))) - .5);\n    vec2 FCO = DEPTH_BLUR * (hash22(vec2(FC.x*.1-FC.y*.33 - iTime * 1.1, FC.x*.277-FC.y*.73 + iTime*2.333)) - .5);\n    vec2 fuv = vec2(FC+FCO-R.xy*.5) / R.yy;\n    vec3 ray = normalize(vec3(fuv, FOCAL));\n    \n    float X = -(abs(iMouse.x)/R.x - .5) * 7.;\n    float Y = clamp(abs(iMouse.y)/R.y - .5, -0.14,2.);\n    bool blank = false;\n    if (iMouse.z>0.) blank = true;\n    if (iMouse.x<1.) X = 0.;\n    if (iFrame == 0) { blank = true; }\n    if (iTime == 0.) { blank = true; }\n    mat3 RR = mat3(1.);\n    RR[2] = normalize(vec3(0.,-Y,0.)-vec3(-sin(X),0.,-cos(X)));\n    RR[0] = normalize(cross(vec3(0.,1.,0.),RR[2]));\n    RR[1] = normalize(-cross(RR[0],RR[2]));\n    eye = RR * eye;\n    ray = RR * ray;\n    \n    \n    outc = vec4(vec3(0.0),1.);\n    vec3 ro = eye, rd = ray;\n    \n    vec3 sc = vec3(1.);\n    vec3 lt = vec3(.02);\n    bool wasInside = false;\n    \n    for (int i=0; i<6; i++) {\n        float seed = fuv.x*.3136+fuv.y*.777+iTime*.931 + float(i) * 7.3843;\n    \n        int hitId = 0;\n        float t = 9999.;\n\n        \n        vec3 nro, nrd;\n    \n        // Sphere\n        float tt = xsect_sphere(ro, rd, .91);\n        tt=0.;\n        if (tt != 0. && tt < t) {\n            hitId = ID_REDTHING;\n            t = tt;\n            vec3 p = ro+tt*rd*EPS1P;\n            vec3 n = normalize(p);\n            nrd = reflect(rd,n);\n            nro = p;\n        \n        }\n        \n        // Cylinder\n        /*\n        vec3 cyl_n;\n        vec3 _y = normalize(vec3(0.,1.,cos(iTime)));\n        vec3 _x = -normalize(cross(_y,vec3(0.,1.,0.)));\n        vec3 _z = normalize(cross(_y,_x));\n        //mat3 CR = mat3(_x,_y,_z);\n        mat3 CR = mat3(1.);\n        tt = xsect_cylinder(CR*ro-vec3(0.55,-.7,3.6), CR*rd, cyl_n, .5, .5);\n        //tt=0.;\n        if (tt != 0. && tt < t) {\n            hitId = 1;\n            t = tt;\n            vec3 p = CR*(ro+tt*rd*EPS1);\n            vec3 n = CR*cyl_n;\n            nrd = reflect(rd,n);\n            nro = p;\n        }\n        */\n        vec3 cyl_n;\n        tt = hit_cylinder(ro,rd,t, cyl_n, nro, nrd);\n        if (tt>0.) hitId = ID_REDTHING;\n\n        \n        // Floor\n        tt = xsect_plane(ro, rd, vec3(0.,1.,0.), vec3(0.,-.6,0.));\n        //tt=0.;\n        if (tt != 0. && tt < t) {\n            vec3 p = ro+tt*rd*EPS1;\n            if (length(p) < 50.) {\n                hitId = ID_FLOOR;\n                t = tt;\n                vec3 n = vec3(0.,1.,0.);\n                nrd = reflect(rd,n);\n                nro = p;\n            }\n        }\n        \n\n\n        // Light (terminal)\n        tt = xsect_plane(ro, rd, vec3(0.,-1.,0.), vec3(0.,3.1,0.));\n        if (tt != 0. && tt < t) {\n            vec3 p = ro+tt*rd*EPS1;\n            if (length(p) < 20.) {\n                hitId = ID_TOPLIGHT;\n                t = tt;\n                vec3 n = vec3(0.,-1.,0.);\n                nrd = reflect(rd,n);\n                nro = p;\n            }\n        }\n        // Sun\n        tt = xsect_plane(ro, rd, vec3(0.,0.,-.1), vec3(0.,0.,9.));\n        if (tt != 0. && tt < t) {\n            vec3 p = ro+tt*rd*EPS1;\n            if (p.x > -1.3 && p.x < 1.3 && p.y > -.1 && p.y < 3.9) {\n                hitId = ID_SUN;\n                t = tt;\n                vec3 n = vec3(0.,-1.,0.);\n                nrd = reflect(rd,n);\n                nro = p;\n            }\n        }\n        \n        // Liquid: should be last\n        vec3 liq_n;\n        float liq_d;\n        bool inside = false;\n        int theHitId = ID_NONE;\n        tt = liquid(ro,rd,liq_n, liq_d, inside, theHitId);\n        \n        if (tt != 0. && tt < t && theHitId == ID_MUG) {\n        //if (theHitId == ID_MUG) {\n            hitId = ID_MUG;\n            t = tt;\n            vec3 p = ro+tt*rd;\n            nrd = reflect(rd,liq_n);\n            nro = p;\n            //outc = vec4(1.); return;\n        }\n        if (wasInside || (tt != 0. && tt < t)) {\n            if (theHitId == ID_LIQ) {             \n                hitId = ID_LIQ;\n            \n                t = tt;\n\n                float mu = 1.01;\n                if (inside) mu = 1./mu;\n                vec3 newBase = refract(rd, liq_n, mu);\n                float ang = abs(dot(-liq_n, rd));\n                bool forceReflect = 1.-pow(ang,2.) > rand11(fuv.x*3.1+fuv.y*.77+iTime)*.5+.6;\n                bool doReflect = length(newBase) < .5 || forceReflect;\n                if (doReflect) {\n                    // Reflect\n                    float rough = .1;\n                    newBase = reflect(rd,liq_n);         \n                    vec3 p = ro+tt*rd*(1.-.1);\n                    nro = p;\n                    nrd = sampleHemi4(newBase, 1./rough, seed);\n                    if (!inside)\n                        sc *= vec3(.9,.85,.82);\n                } else {\n                    float rough = .00001;\n                    vec3 p = ro+tt*rd*(1.001);\n                    nro = p;\n                    nrd = sampleHemi4(newBase, 1./rough, seed);\n\n                    //outc = vec4(liq_d*.21, 0.,0.,1.); return;\n                }\n                if (inside || !doReflect) {\n                    const float LIQUID_OPACITY_MULT = 4.936;\n                    sc *= vec3(1.,.95,.92) * exp(liq_d*-LIQUID_OPACITY_MULT);\n                }\n\n\n                wasInside = inside;\n                rd = nrd;\n                ro = nro;\n                //continue;\n            }\n        }\n        \n        if (hitId == ID_NONE) break;\n        \n        float rough = 0.;\n        if (hitId == ID_TOPLIGHT) {\n            lt = vec3(1.3);\n            break;\n        }\n        if (hitId == ID_SUN) {\n            lt = vec3(1.2,1.,.8)*5.;\n            break;\n        }\n        if (hitId == ID_FLOOR) {\n            vec3 p = ro+t*rd;\n            //vec4 samp = C3(p.xz*1.);\n            //sc *= .1 + .95 * samp.rgb * vec3(.8,.9,1.);\n            //rough = .1 / samp.r;\n            \n            //sc *= vec3(.8);\n            //rough = .03;\n            //lt += .2;\n            \n            float hd = smoothstep(.02,.05, hexagon(p.xz * 5.));\n            sc *= mix(.2,.95, hd);\n            rough = mix(1., .05, hd);\n        }\n        if (hitId == ID_REDTHING) {\n            sc *= vec3(.975,.6,.6);\n            lt += vec3(.1);\n            rough = 20.;\n        }\n        if (hitId == ID_MUG) {\n            //vec3 p = ro+t*rd;\n            //float hd = smoothstep(.02,.05, hexagon(p.xz * 5.));\n            //sc *= mix(.2,.95, hd);\n            //rough = mix(1., .05, hd);\n            rough = 2.1;\n            \n            float ang = abs(dot(-liq_n, rd));\n            bool forceReflect = 1.-pow(ang,1.) > rand11(fuv.x*3.1+fuv.y*.77+iTime)*.8+.2;\n            if (forceReflect) {\n                //float rough = .2 * abs(ang);  \n                float rough = .2 * (1.-abs(ang));\n                nrd = sampleHemi4(nrd, 1./rough, fuv.x+fuv.y*.777+iTime*.1);\n                sc *= vec3(1.0998); // Doesn't make physical sense, but kind of works?\n            } else {\n                float rough = .4;\n                vec3 p = ro+tt*rd*(1.001);\n                nrd = sampleHemi4(nrd, 1./rough, seed);\n                sc *= vec3(.99);\n            }\n            \n            ro = nro; rd = nrd;\n            continue;\n        }\n        \n        \n        if (hitId == ID_LIQ) { // liquid\n\n        } else {\n            // Basic surface bounce\n            if (rough > 0.) rd = sampleHemi4(nrd, 1./rough, seed);\n            else rd = nrd;\n            ro = nro;\n        }\n    }\n    \n    vec3 c = lt * sc;\n    outc.rgb = c;\n    outc *= .05;\n    \n    if (!blank)\n        //outc = outc + IC0(ivec2(FC))*.999;\n        outc = outc + IC0(ivec2(FC))*.9995;\n    \n    \n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n\n#define R iResolution.xy\n#define IR ivec2(iResolution.xy)\n#define C0(uv) texture(iChannel0, (uv))\n#define C1(uv) texture(iChannel1, (uv))\n#define C3(uv) texture(iChannel3, (uv))\n\n#define IC0(p) texelFetch(iChannel0, (p), 0)\n#define IC1(p) texelFetch(iChannel1, (p), 0)\n#define IC2(p) texelFetch(iChannel2, (p), 0)\n\n\nfloat max3(vec3 a) { return max(a.x,max(a.y,a.x)); }\n\nconst int ID_NONE = 0;\nconst int ID_FLOOR = 7;\nconst int ID_TOPLIGHT = 1;\nconst int ID_SUN = 2;\nconst int ID_LIQ = 3;\nconst int ID_MUG = 4;\nconst int ID_WALL = 5;\nconst int ID_REDTHING = 6;\n\n\n\n//const float EPS1 = 1. + .0001;\nconst float EPS1 = 1.-.00001;\nconst float EPS1P = 1.+.00001;\n//const float EPS1 = 1.;\n\n// https://www.shadertoy.com/view/Xd2GR3\nfloat hexagon( vec2 p ) \n{\n\tvec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\t\n\tvec2 pi = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(pi.x + pi.y, 3.0);\n\n\tfloat ca = step(1.0,v);\n\tfloat cb = step(2.0,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n    \n    // distance to borders\n\tfloat e = dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) );\n    return e;\n    /*\n\n\t// distance to center\t\n\tp = vec2( q.x + floor(0.5+p.y/1.5), 4.0*p.y/3.0 )*0.5 + 0.5;\n\tfloat f = length( (fract(p) - 0.5)*vec2(1.0,0.85) );\t\t\n\t\n\treturn vec4( pi + ca - cb*ma, e, f );\n    */\n}\n#define PI acos(0.);\nfloat hash11(float s) {    return fract(sin(s * 592.1)*57.23);}\nfloat hash11_(float s) {\n    uint a = floatBitsToUint(s);\n    a = a ^ ((a+1u)<<3u);\n    a = a ^ ((a*17u)<<16u);    \n    uint SU = 262144u;\n    float SF = 262144.;\n    return float(a%SU)/SF;\n}\nfloat hash11_a(float p) // https://www.shadertoy.com/view/4djSRW\n{\n    p = fract(p*10.31);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n/*float hash11(float p)\n{\n    uint n = uint(p * 200000.);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n\n    return float(n % 262144u) / 262144.;\n}*/\nvec2 hash22(vec2 p) {\n    return vec2(hash11(p.x-.3*p.y), hash11(p.y+.77*p.x));\n    uint a = floatBitsToUint(p.x-p.y);\n    uint b = floatBitsToUint(p.y+p.x);\n    a = a ^ ((a*23u)<<7u);\n    a = a ^ ((a*17u)<<16u);\n    b = b ^ ((b*23u)<<7u);\n    b = b ^ ((b*17u)<<16u);\n    uint SU = 262144u;\n    float SF = 262144.;\n    return vec2(float(a%SU)/SF, float(b%SU)/SF);\n}\nvec2 hash22_(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * 7.377 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat rand11(float x) { return fract(337.1*sin(x*22.13+11.2)); }\nfloat rand21(vec2 p) { return fract(\n    337.1*sin(22.3+27.31*p.y+p.x*22.13)); }\nvec2 rand22(vec2 p) { return fract(vec2(\n    337.1*sin(22.3+27.31*p.y+p.x*22.13),\n    437.1*sin(1.7+22.31*p.y+p.x*29.13) )); }\nvec3 rand23(vec2 p) { return fract(vec3(\n    337.1*sin(22.3+27.31*p.y+p.x*22.13),\n    437.1*sin(1.7+22.31*p.y+p.x*29.13),\n    407.1*sin(111.7+12.31*p.y+p.x*19.13) )); }\nvec3 rand33(vec3 p) { return fract(vec3(\n    337.1*sin(22.3+27.31*p.y+p.x*22.13+p.z*19.2),\n    437.1*sin(1.7+22.31*p.y+p.x*29.13+p.z*10.3),\n    407.1*sin(111.7+12.31*p.y+p.x*19.13+p.z*8.2) )); }\n\nfloat distanceToLine(vec3 p1, vec3 p2, vec3 q) {\n    return length(cross(q-p1, q-p2)) / length(p1-p2);\n}\nfloat distanceToLine(vec2 p1, vec2 p2, vec2 q) {\n    return abs((p2.x-p1.x)*(p1.y-q.y) - (p1.x-q.x)*(p2.y-p1.y)) / length(p2-p1);\n}\nfloat distanceToLine(vec2 a, vec2 b, vec2 q, inout vec2 p, inout float t) {\n    t = dot(q-a, normalize(b-a)) / distance(a,b);\n    t = clamp(t, 0., 1.);\n    p = a + t * (b-a);\n    return distance(p,q);\n}\n\nfloat distanceToLineSegment(vec3 a, vec3 b, vec3 q, inout vec3 p, inout float t) {\n    t = dot(q-a, normalize(b-a)) / distance(a,b);\n    t = clamp(t, 0., 1.);\n    p = a + t * (b-a);\n    return distance(p,q);\n}\n\nfloat xsect_plane(vec3 ro, vec3 rd, vec3 n, vec3 q) {\n    float t = dot(n,q-ro) / dot(n,rd);\n    if (t < 0.) t = 0.;\n    return t;\n}\n\nfloat xsect_sphere(vec3 ro, vec3 rd, float radius) {\n    float a = dot(rd,rd);\n    float b = 2. * dot(rd,ro);\n    float c = dot(ro,ro) - radius*radius;\n    float discrim = b*b - 4.*a*c;\n    if (discrim < 0.) return 0.;\n    float t1 = -b + sqrt(discrim);\n    float t2 = -b - sqrt(discrim);\n    if (t2 > 0.) return t2 / 2.*a;\n    if (t1 < 0.) return 0.;\n    return t1 / 2.*a;\n}\n\nfloat dot2(vec2 a) { return dot(a,a); }\nfloat dot2(vec3 a) { return dot(a,a); }\n\nfloat xsect_cylinder(vec3 ro, vec3 rd, out vec3 n, float h, float r) {\n    float a = dot(rd.xz,rd.xz);\n    float b = 2. * dot(rd.xz,ro.xz);\n    float c = dot2(ro.xz) - r*r;\n    float discrim = b*b - 4.*a*c;\n    if (discrim < 0.) return 0.;\n    float t1 = (-b + sqrt(discrim)) / 2.*a;\n    float t2 = (-b - sqrt(discrim)) / 2.*a;\n    float t = 0.;\n    if (t1 > 0. && abs(ro.y + rd.y * t1) < h) t = t1;\n    if (t2 > 0. && abs(ro.y + rd.y * t2) < h) t = t2;\n    // Don't take if too lo/hi\n    n = vec3(normalize(ro.xz+t*rd.xz), 0.).xzy;\n    \n    // Check caps\n    float tp = xsect_plane(ro,rd, vec3(0.,1.,0.), vec3(0.,h,0.));\n    if (tp > 0. && dot2(ro.xz+tp*rd.xz) < r*r && (t == 0. || tp < t)) { t = tp; n = vec3(0.,1.,0.); }\n    tp = xsect_plane(ro,rd, vec3(0.,-1.,0.), vec3(0.,-h,0.));\n    if (tp > 0. && dot2(ro.xz+tp*rd.xz) < r*r && (t == 0. || tp < t)) { t = tp; n = vec3(0.,-1.,0.); }\n    \n    return t;\n}\n\n\nvec3 sampleHemi4(vec3 base, float m, float seed) {\n    \n    float u = hash11(seed*1.3+2.);\n    float t = acos(pow(1.-u, 1./(1.+m)));\n    float phi = hash11(seed*2.99-1.123) *  8. * PI;\n    \n    vec3 d = vec3(sin(t)*cos(phi), sin(t)*sin(phi), cos(t));\n    \n    vec3 lk = normalize(base);\n    vec3 up = vec3(0.,0.,1.);\n    //if (abs(dot(up,lk)) > .97) up = vec3(1.,0.,0.);\n    vec3 rt = normalize(cross(lk, up));\n    up = normalize(cross(rt, lk));\n    mat3 RR = mat3(rt,up,lk);\n    return RR * d;\n\n}\n\n\n\n\n\nfloat smoo(float v) { return v*v*(3.-2.*v); }\n//float smoo(float v) { return v; }\nvec3 noise33(vec3 x) {\n    vec3 o = vec3(0.);\n    vec3 fx = floor(x);\n    vec3 lx = fract(x);\n    for (int i=0; i<8; i++) {\n        float dx = (i  ) % 2 == 0 ? 1. : 0.;\n        float dy = (i/2) % 2 == 0 ? 1. : 0.;\n        float dz = (i/4) % 2 == 0 ? 1. : 0.;\n        vec3 v  = rand33(fx + vec3(dx,dy,dz));\n        vec3 d = vec3(dx,dy,dz) * 2. * lx + 1. - lx - vec3(dx,dy,dz);\n        o += smoo(d.x)*smoo(d.y)*smoo(d.z)*v;\n    }\n    return o;\n}\n\n\n\n\n\n\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\n\n\n\n\n\n\n\n\n\n\n/*\nfloat liq_map(vec3 p, out int hitId) {\n        float outd = 1999.;\n        \n        //hitId = ID_MUG;        return length(p) - .8;\n    \n        // sphere\n        if(true)\n        {\n            const vec3 ctr = vec3(0.,-.0,0.);\n            float r = .65;\n            vec3 pp = p;\n            vec3 pc = vec3(0., -.4, 0.);\n            pp = pp + (pp-pc) / (length(pp-pc)*.3+.06);\n            //pp.xz *= .25 + length(pp.xz)*.01;\n            float nr = 0.;\n            r += (noise33(pp*1.5).x-.5) * .51;\n            vec3 nn = (noise33(20.+pp*2.)-.5) * .2;\n            r += (nn.x-.5) * .35;\n            vec3 nnn = noise33(20.-nn+p*4.);\n            r += (nnn-.5).x * .5;\n            r += (noise33(nnn*2. + nn+p*19.)-.5).x * .5 * .125;\n\n            //r = .5;\n            vec3 s_center = ctr + vec3(-.3,-.6,0.);\n            float sphere_d = length((p-s_center) * vec3(1.,2.9,1.)) - .7;\n            if ((p-s_center).y < 0.) sphere_d = 66.;\n            \n            vec3 pcyl = p;\n            const float ang = .81;\n            pcyl.xy = mat2(cos(ang),sin(ang),-sin(ang),cos(ang)) * pcyl.xy;\n            float d = opSmoothUnion(sphere_d, .99*sdRoundedCylinder(pcyl, .01, .07, .45), .2);\n            \n            \n            r = r - .01;\n            //r=0.;\n            d = d - (r) * .8;\n\n            \n            if (d < outd) { hitId = ID_LIQ; outd = d; }\n        }\n        \n        // mug\n        {\n            mat3 CR = mat3(1.);\n            CR[2] = normalize(vec3(.1,0.,.2));\n            CR[0] = normalize(cross(vec3(0.,-1.,2.),CR[2]));\n            CR[1] = normalize(cross(CR[0],CR[2]));\n        \n            \n            const vec3 ctr = vec3(0.,1.1,0.);\n            \n            \n            vec3 p0 = p;\n            p = CR * p;\n            //p = (p*5.) / (-(p0).y + 5.);\n            p = p - ctr;\n            float r = .6;\n            float h = .6;\n            \n            //float d = max(length(ctr.xz - p.xz) - r, abs(p.y-ctr.y)-h);\n            vec2 dd = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n            float d1 = sdRoundedCylinder(p, r*.5, .03, h);\n            //return d1;\n            \n            float r2 = .55;\n            float h2 = h+.1;\n            \n            vec3 p2 = p + vec3(0.,.1,0.);\n            dd = abs(vec2(length(p2.xz),p2.y)) - vec2(r2,h2);\n            float d2 = min(max(dd.x,dd.y),0.0) + length(max(dd,0.0));\n            float base_d = opSmoothSubtraction(d2,d1,.05);\n            \n            // handle\n            vec3 hp = p + vec3(r*.95,0.,0.);\n            float handle_d = sdLink(hp, .1, .33,.097);\n            if (hp.x > 0.) handle_d = 1.;\n            //return handle_d;\n            \n            float d = opSmoothUnion(base_d,handle_d,.05);\n            \n            if (d < outd) { hitId = ID_MUG; outd = d; }\n        }\n        \n        //hitId = ID_MUG;        return length(p) - .8;\n        \n        if (outd > 45.) hitId = ID_NONE;\n        return outd;\n}\n*/\n\n\nfloat sceneSdf(vec3 p, out int hitId) {\n        float outd = 999.;\n        \n        // mug\n        if (true) {           \n            mat3 CR = mat3(1.);\n            CR[2] = normalize(vec3(.1,0.,.2));\n            CR[0] = normalize(cross(vec3(0.,-1.,2.),CR[2]));\n            CR[1] = normalize(cross(CR[0],CR[2]));\n            const vec3 ctr = vec3(0.,1.1,0.);\n            vec3 p0 = p;\n            vec3 p1 = CR * p;\n            //p = (p*5.) / (-(p0).y + 5.);\n            p1 = p1 - ctr;\n            float r = .6;\n            float h = .6;\n            \n            //float d = max(length(ctr.xz - p.xz) - r, abs(p.y-ctr.y)-h);\n            vec2 dd = abs(vec2(length(p1.xz),p1.y)) - vec2(r,h);\n            float d1 = sdRoundedCylinder(p1, r*.5, .03, h);\n            //return d1;\n            \n            float r2 = .55;\n            float h2 = h+.1;\n            \n            vec3 p2 = p1 + vec3(0.,.1,0.);\n            dd = abs(vec2(length(p2.xz),p2.y)) - vec2(r2,h2);\n            float d2 = min(max(dd.x,dd.y),0.0) + length(max(dd,0.0));\n            float base_d = opSmoothSubtraction(d2,d1,.05);\n            \n            // handle\n            vec3 hp = p1 + vec3(r*.95,0.,0.);\n            float handle_d = sdLink(hp, .1, .33,.097);\n            \n            float d = base_d;\n            if (hp.x < 0.) d = opSmoothUnion(base_d,handle_d,.04);\n\n            \n            if (d < outd) { hitId = ID_MUG; outd = d; }\n        }\n        \n        // liquid, attempt 2\n        {\n\n            \n            // Main splash (cylinder + sphere)\n            const vec3 ctr = vec3(0.,-.0,0.);\n            \n            float r = .65;\n            vec3 pp = p;\n            vec3 pc = vec3(0., -.4, 0.);\n            pp = pp + (pp-pc) / (length(pp-pc)*.3+.06);\n            //pp.xz *= .25 + length(pp.xz)*.01;\n            float nr = 0.;\n            r += (noise33(pp*1.5).x-.5) * .51;\n            vec3 nn = (noise33(20.+pp*2.)-.5) * .2;\n            r += (nn.x-.5) * .35;\n            vec3 nnn = noise33(20.-nn+p*4.);\n            r += (nnn-.5).x * .5 * .25;\n            r += (noise33(nnn*2. + nn+p*19.)-.5).x * .5 * .125;\n            \n                        // Bubbles\n            float v = 0.;\n            float c = .125;\n            vec3 q = mod(p+0.5*c,c)-0.5*c;\n            \n            v += length(q) * 1.5;\n            float dd = -.2 + v + .25*length(p*vec3(1.,2.5,1.) - vec3(-.8, -1.1, 0.));\n            \n            dd -= (r-.5) * .95;\n            \n            vec3 s_center = ctr + vec3(-.3,-.6,0.);\n            float sphere_d = length((p-s_center) * vec3(1.,2.9,1.)) - .7;\n            if ((p-s_center).y < 0.) sphere_d = 66.;\n            \n            vec3 pcyl = p;\n            const float ang = .81;\n            pcyl.xy = mat2(cos(ang),sin(ang),-sin(ang),cos(ang)) * pcyl.xy;\n            float d = opSmoothUnion(sphere_d, .99*sdRoundedCylinder(pcyl, .01, .07, .45), .2);\n            d = d - r * .8;\n            d = min(d,dd); // Enable bubbles\n            if (d < outd) { hitId = ID_LIQ; outd = d; }\n        }\n        \n        return outd;\n\n}\n","name":"Common","description":"","type":"common"}]}