{"ver":"0.1","info":{"id":"MfjyDz","date":"1722192085","viewed":81,"name":"Voxel DDA (rd = (0, 0) problem)","username":"Elsio","description":"eu ainda não sei dirigir\n[url]https://www.shadertoy.com/view/DsBBWK[/url]","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","voxel","occlusion","dda"],"hasliked":0,"parentid":"4dfGzs","parentname":"Voxel Edges"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot(a) mat2(cos(a + vec4(0, 11, 33, 0)))\n#define sgn(p) (step(0., p) * 2. - 1.)\n#define t iTime * .4\n\nvoid mainImage(out vec4 o, vec2 u) {    \n    vec2  q = vec2(cos(3. * t), sin(2. * t)) * vec2(5, 4) + vec2(12., -30),\n          r = iResolution.xy; o *= 0.;\n          u = (u - r.xy / 2.) / r.y;\n    \n    vec3 D = normalize(vec3(-u, 1)), \n         p = vec3(q, t * 22.), \n         id = floor(p), N;\n         \n    D.xz *= rot(cos(t) * 2.);\n    p = (sgn(D) + id - p) / D; \n    \n    float i, d = 1.;\n    while(i++ < 140. && d > .3) \n        N = step(p, min(p.yzx, p.zxy)),\n        \n        id += N * sgn(D),\n        \n        d = dot(\n                sin(id.zxy * .3), \n                cos(id * .4)\n            ) - id.y * .05,\n        \n        p += N * sgn(D)/D;\n    \n    o.rgb = vec3(d * N + 1.) * (1. - i/140.);\n}\n\n\n/*\n    Esta versao minimalista é baseada em gyroid\n    minha outra versão baseada em tunel funciona melhor\n    \n    \n    DDA is NOT simple (2024-01-15)\n    https://www.shadertoy.com/view/lflXW4\n    \n    mas, a que eu mais amo é a versão hexagonal\n    \n    Vagalumes (2024-01-29) \n    https://www.shadertoy.com/view/McSXzV\n\n*/\n","name":"Image","description":"","type":"image"}]}