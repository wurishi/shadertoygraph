{"ver":"0.1","info":{"id":"mldczf","date":"1711324526","viewed":81,"name":"Dissolving Boundaries","username":"laserbat","description":"Layered structures with rounded features quickly form out of a random initial state. They gradually recede as if melting, leaving space for varied chaotic behaviors, more typical for this kind of CA.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["feedback","cellularautomata"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SQRT_3 1.73205080757\n#define ZOOM 2.0\n\n// Colorization and output stuff here.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    // Transform coordinates to correctly display hexagonal geometry\n    vec2 coord = vec2((fragCoord.x*SQRT_3 + fragCoord.y) / 2.0, fragCoord.y) / ZOOM;    \n    int val = GET(coord, ivec2(0, 0));\n    \n    fragColor.r = float(val % D) / float(D);\n    val /= D;\n    fragColor.g = float(val % D) / float(D);\n    val /= D;\n    fragColor.b = float(val % D) / float(D);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Simple time-dependant noise function, for seeding CA\nfloat noise(in vec2 co){\n    int x = int(co.x * float(M));\n    int y = int(co.y * float(M));\n    int z = int(iDate.a);\n    int w = int(fract(iDate.a) * float(M));\n    int res = hash(x + hash(y + hash(z + hash(w))));\n    \n    return float(res % M);\n}\n\n// Main CA computation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Randomize initial state on 0th frame or if mouse button is pressed\n    if (iFrame <= 0 || iMouse.z > 0.0) {\n        fragColor.x = noise(fragCoord/iResolution.xy);\n    } else {\n    \tivec2 d;\n        \n        int vals[7];\n        int i = 0;\n        int idx = 0;\n\n    \tfor(d.y = -1; d.y <= +1; d.y++)\n        \tfor(d.x = -1; d.x <= +1; d.x++){\n                // To turn Moore neighborhood into hexagonal one we simply ignore a pair of opposite corners\n                if((d.x == -1 && d.y == 1) || (d.x == 1 && d.y == -1)) continue;\n            \t\n                vals[i] = GET(fragCoord, d);\n                i += 1;\n             }\n        \n        // Sort the array using a sorting network\n        swap(0,6); swap(2,3); swap(4,5);\n        swap(0,2); swap(1,4); swap(3,6);\n        swap(0,1); swap(2,5); swap(3,4);\n        swap(1,2); swap(4,6);\n        swap(2,3); swap(4,5);\n        swap(1,2); swap(3,4); swap(5,6);\n\n        int uniq[7];\n        int ulen = 0;\n\n        uniq[ulen++] = vals[0];\n\n        for (i = 1; i < 7; i++) {\n            if (vals[i] != vals[i - 1]) {\n                uniq[ulen++] = vals[i];\n            }\n        }\n        \n        idx = (vals[0] & vals[6]) % ulen;\n        if (ulen > 3) idx = 2;\n        \n        fragColor.x = float(uniq[idx]);\n        \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define swap(x, y) if (vals[x] > vals[y]) {int t = vals[y]; vals[y] = vals[x]; vals[x] = t;};\n#define GET(coord, offset) int(texelFetch(iChannel0, ivec2(mod(coord + vec2(offset) + iResolution.xy, iResolution.xy)), 0).x)\n\n#define D 256\n#define M (D * D * D)\n\nint hash(int x) {\n    x++;\n    x ^= x >> 17;\n    x *= 0xed5ad4bb;\n    x ^= x >> 11;\n    x *= 0xac4c1b51;\n    x ^= x >> 15;\n    x *= 0x31848bab;\n    x ^= x >> 14;\n    return x;\n}","name":"Common","description":"","type":"common"}]}