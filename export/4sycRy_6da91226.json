{"ver":"0.1","info":{"id":"4sycRy","date":"1522436513","viewed":275,"name":"Wavelet Decompose","username":"kariluoma","description":"Partial implementation of the \"wavelet decompose\" plugin for gimp. A full implementation would decompose source image into multiple images of levels of detail (bandpass filter) and a residual low-pass image. When merged, they reproduce the source image.\n\n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["dilate","tophat"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAPR(v) ((v) / iResolution.xy)\n\n// Thanks Wavelet decompose GIMP plugin, 2008, Marco Rossini\nconst int stride = 3;\nconst int kSize = stride*stride;\nconst int kRadius = (stride-1)/2;\nconst float kernel[kSize] = float[] (1.,2.,1.,2.,4.,2.,1.,2.,1.);\nconst float norm = 16.;\nvec4 dilate0(sampler2D tex, vec2 xy) {\n\tconst float scale = pow(2.,0.);\n\tvec3 dilated = vec3(0.);\n\tfor (int i=-kRadius; i <= kRadius; ++i)\n\tfor (int j=-kRadius; j <= kRadius; ++j)\n\t\tdilated += kernel[stride*(kRadius+i) + (kRadius+j)]*texture(tex, MAPR(xy+vec2(scale*float(i),scale*float(j)))).rgb;\n\treturn vec4((dilated+0.03125)/norm, 1.0);\n}\nvec4 dilate1(sampler2D tex, vec2 xy) {\n\tconst float scale = pow(2.,1.);\n\tvec3 dilated = vec3(0.);\n\tfor (int i=-kRadius; i <= kRadius; ++i)\n\tfor (int j=-kRadius; j <= kRadius; ++j)\n\t\tdilated += kernel[stride*(kRadius+i) + (kRadius+j)]*dilate0(tex, xy+vec2(scale*float(i),scale*float(j))).rgb;\n\treturn vec4((dilated+0.03125)/norm, 1.0);\n}\nvec4 dilate2(sampler2D tex, vec2 xy) {\n\tconst float scale = pow(2.,2.);\n\tvec3 dilated = vec3(0.);\n\tfor (int i=-kRadius; i <= kRadius; ++i)\n\tfor (int j=-kRadius; j <= kRadius; ++j)\n\t\tdilated += kernel[stride*(kRadius+i) + (kRadius+j)]*dilate1(tex, xy+vec2(scale*float(i),scale*float(j))).rgb;\n\treturn vec4((dilated+0.03125)/norm, 1.0);\n}\nvec4 dilate3(sampler2D tex, vec2 xy) {\n\tconst float scale = pow(2.,3.);\n\tvec3 dilated = vec3(0.);\n\tfor (int i=-kRadius; i <= kRadius; ++i)\n\tfor (int j=-kRadius; j <= kRadius; ++j)\n\t\tdilated += kernel[stride*(kRadius+i) + (kRadius+j)]*dilate2(tex, xy+vec2(scale*float(i),scale*float(j))).rgb;\n\treturn vec4((dilated+0.03125)/norm, 1.0);\n}\nvec4 tophat_transform(sampler2D tex, vec2 fragCoord) {\n    // Scale 0\n    return 0.5 + texture(tex, MAPR(fragCoord.xy)) - dilate0(tex, fragCoord);\n    // Scale 1\n    return 0.5 + dilate0(tex, fragCoord) - dilate1(tex, fragCoord);\n    // Scale 2\n    return 0.5 + dilate1(tex, fragCoord) - dilate2(tex, fragCoord);\n    // Scale 3 (extremely slow)\n    return 0.5 + dilate2(tex, fragCoord) - dilate3(tex, fragCoord);\n    // Scale 4 (crashes my browser, removed impl)\n    // Residual (note: not a tophat-transform, just dilate)\n    return dilate3(tex, fragCoord);\n}\n\n//iChannel0: texture\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = tophat_transform(iChannel0, fragCoord);\n}","name":"Image","description":"","type":"image"}]}