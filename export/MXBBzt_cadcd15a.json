{"ver":"0.1","info":{"id":"MXBBzt","date":"1729817468","viewed":61,"name":"Fork 3D Zernike","username":"KylBlz","description":"paganosama catrary. mouse ga sheen wa kaeru!","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["zernike"],"hasliked":0,"parentid":"X3Bfzd","parentname":"3D Zernike Aberation "},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Constants\nconst int MAX_ZERNIKE_TERMS = 18;\nconst float PI = 3.14159265359;\nconst float eps = 1.0 / 512.0;\nconst float DISK_RADIUS = 1.0;\n\nfloat zernike_coeffs[MAX_ZERNIKE_TERMS];\n\n// Function to evaluate Zernike polynomials for height mapping\nfloat evaluateZernike(vec2 uv) {\n    float zernike = 0.0;\n    \n    // Z0: Piston\n    zernike += zernike_coeffs[0] * 1.0;  \n    \n    // Z1, Z2: Tilt X, Tilt Y\n    zernike += zernike_coeffs[1] * 2.0 * uv.x;  // Tilt X\n    zernike += zernike_coeffs[2] * 2.0 * uv.y;  // Tilt Y\n    \n    // Z3: Defocus\n    zernike += zernike_coeffs[3] * (2.0 * uv.x * uv.x + 2.0 * uv.y * uv.y - 1.0);  // Defocus\n    \n    // Z4, Z5: Astigmatism\n    zernike += zernike_coeffs[4] * (uv.x * uv.x - uv.y * uv.y);  // Astigmatism X\n    zernike += zernike_coeffs[5] * (2.0 * uv.x * uv.y);  // Astigmatism Y\n    \n    // Z6, Z7: Coma\n    zernike += zernike_coeffs[6] * (3.0 * uv.x * uv.x * uv.x - 2.0 * uv.x);  // Coma X\n    zernike += zernike_coeffs[7] * (3.0 * uv.y * uv.y * uv.y - 2.0 * uv.y);  // Coma Y\n    \n    // Z8, Z9: Trefoil\n    zernike += zernike_coeffs[8] * (uv.x * uv.x * uv.x - 3.0 * uv.x * uv.y * uv.y);  // Trefoil X\n    zernike += zernike_coeffs[9] * (3.0 * uv.x * uv.x * uv.y - uv.y * uv.y * uv.y);  // Trefoil Y\n    \n    // Z10: Spherical Aberration\n    zernike += zernike_coeffs[10] * (6.0 * uv.x * uv.x * uv.x * uv.x + 6.0 * uv.y * uv.y * uv.y * uv.y - 6.0 * (uv.x * uv.x + uv.y * uv.y) + 1.0);\n\n    // Z11, Z12: Secondary Astigmatism\n    zernike += zernike_coeffs[11] * (uv.x * uv.x * uv.x * uv.x - uv.y * uv.y * uv.y * uv.y);  // Secondary Astigmatism X\n    zernike += zernike_coeffs[12] * (4.0 * uv.x * uv.y * (uv.x * uv.x - uv.y * uv.y));  // Secondary Astigmatism Y\n\n    // Z13, Z14: Secondary Coma\n    zernike += zernike_coeffs[13] * (5.0 * uv.x * uv.x * uv.x * uv.x * uv.x - 4.0 * uv.x * uv.x * uv.x);  // Secondary Coma X\n    zernike += zernike_coeffs[14] * (5.0 * uv.y * uv.y * uv.y * uv.y * uv.y - 4.0 * uv.y * uv.y * uv.y);  // Secondary Coma Y\n\n    // Z15, Z16: Secondary Trefoil\n    zernike += zernike_coeffs[15] * (uv.x * uv.x * uv.x * uv.x * uv.x - 10.0 * uv.x * uv.y * uv.y * uv.y * uv.x);  // Secondary Trefoil X\n    zernike += zernike_coeffs[16] * (10.0 * uv.x * uv.x * uv.x * uv.y - uv.y * uv.y * uv.y * uv.y * uv.y);  // Secondary Trefoil Y\n\n    // Z17: Secondary Spherical Aberration\n    zernike += zernike_coeffs[17] * (20.0 * uv.x * uv.x * uv.x * uv.x * uv.x * uv.x + 20.0 * uv.y * uv.y * uv.y * uv.y * uv.y * uv.y - 30.0 * uv.x * uv.x * uv.x * uv.x - 30.0 * uv.y * uv.y * uv.y * uv.y + 12.0 * uv.x * uv.x + 12.0 * uv.y * uv.y - 1.0);\n\n    // Add more Zernike terms as necessary, up to Z36...\n    \n    return zernike;  // Scale the height deformation\n}\n\n// this approximates the Zernike disk as a signed distance field\nfloat sdf(vec3 p) {\n    float r = length(p.xz) - DISK_RADIUS;\n    if (r > 0.0)\n        return r + eps;\n    return max(r, abs(p.y - evaluateZernike(p.xz)) - 0.01);\n}\n\n// Function to raymarch the deformed disk\nfloat raymarch(vec3 ro, vec3 rd) {\n    float t = 0.414;\n    for (int i = 0; i < 512; i++) {  // Increased precision by increasing iterations\n        vec3 pos = ro + t * rd;\n\n        // Check if the ray is close to the surface\n        float dist = sdf(pos);\n        if (dist < eps) {\n            return t;  // Hit the surface\n        }\n\n        t += dist * 0.125;  // Finer step size for more precision\n    }\n\n    return -1.0;  // No hit\n}\n\n// Thanks Nimitz - https://www.shadertoy.com/view/Xts3WM\nvec4 norcurv(in vec3 p, in float eps) {\n    vec2 e = vec2(-1.0, 1.0) * eps;   \n    float t1 = sdf(p + e.yxx), t2 = sdf(p + e.xxy);\n    float t3 = sdf(p + e.xyx), t4 = sdf(p + e.yyy);\n    return vec4(\n        normalize(e.yxx*t1 + e.xxy*t2 + e.xyx*t3 + e.yyy*t4),\n        .25/e.y*(t1 + t2 + t3 + t4 - 4.0*sdf(p))\n    );\n}\n\n// Main shader\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize fragment coordinates to [-1, 1]\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\n    // Camera setup (third-person view above and to the side of the disk)\n    vec3 cameraPos = 2.5 * vec3(1.414 * sin(iTime * 0.1), 1.414, 1.414 * cos(iTime * 0.1));\n    // Looking at the disk center\n    vec3 target = vec3(0.0);\n    vec3 forward = normalize(target - cameraPos);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    vec3 rayDir = normalize(PI*forward + uv.x * right + uv.y * up);  // Ray direction\n\n    // Mouse input and mapping to normalized coordinates\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n    if (iMouse.xy == vec2(0.0))\n        mousePos = vec2(0.0, 0.675);\n    // Subdivide the screen into 36 vertical regions (each for a different coefficient)\n    for (int i = 0; i < MAX_ZERNIKE_TERMS; i++) {\n        if (mousePos.y > float(i) / float(MAX_ZERNIKE_TERMS) && mousePos.y < float(i + 1) / float(MAX_ZERNIKE_TERMS)) {\n            // Adjust the coefficient based on the horizontal mouse position\n            zernike_coeffs[i] = mousePos.x - 0.5;  // Mouse X position controls value (-1 to 1)\n        } else {\n            // Default value for other coefficients\n            zernike_coeffs[i] = 0.0;\n        }\n    }\n\n    // Raymarch to find the intersection with the deformed disk\n    float t = raymarch(cameraPos, rayDir);\n    vec3 hitPos = cameraPos + t * rayDir;\n    vec3 normal = norcurv(hitPos, eps).xyz;  // Disk normal is mostly up (Y-axis)\n\n    // Shading and color based on hit\n    if (t > 0.0) {\n        fragColor = texture(iChannel0, reflect(rayDir, normal)) * normal.xyzz*normal.xyzz;\n        \n    } else {\n        fragColor = texture(iChannel0, rayDir);  // Background color\n        \n    }\n    \n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2));\n}\n","name":"Image","description":"","type":"image"}]}