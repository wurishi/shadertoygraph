{"ver":"0.1","info":{"id":"7dcfRj","date":"1656769695","viewed":77,"name":"Fork equilatera chenxiaolo 095","username":"chenxiaolong","description":"For study.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["study"],"hasliked":0,"parentid":"NlsGzs","parentname":"equilateral triangle #7"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 旋转函数\nvec2 rotate(vec2 uv, float rotation)\n{\n    vec2 to_return = uv;\n    // rotation += atan(uv.y / uv.x);\n    to_return.x = uv.x * cos(rotation) + uv.y * -sin(rotation);\n    to_return.y = uv.x * sin(rotation) + uv.y * cos(rotation);\n\n    return to_return;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 纹理的中心点\n    vec2 center = iResolution.xy * 0.5;\n    \n    // 像素坐标\n    vec2 pixel = fragCoord.xy;\n    \n    // 三角形的高\n    float height = 0.7 * iResolution.y;\n    \n    // √3\n    float sqrt3 = sqrt(3.0);\n    \n    // 边长\n    float edgeLen = height * (2.0 / sqrt3);\n    \n    // 底边中心点\n    vec2 bottomMidpt = center - vec2(0.0, height / 2.0);\n    // 动起来的三角形\n    // bottomMidpt = rotate(bottomMidpt, sin((iTime/5.0)));\n    \n    // 中心点到底边中心点的向量\n    vec2 diff = pixel - bottomMidpt;\n    \n    // https://blog.csdn.net/sinat_31275315/article/details/108481856\n    // 判定方法详细解释\n    //  正三角形各个边点左右侧判定\n    float insideA = step(diff.x + diff.y / sqrt3, edgeLen / 2.0);\n    float insideB = step(-diff.x + diff.y / sqrt3, edgeLen / 2.0);\n    float insideC = step(bottomMidpt.y, pixel.y);\n    \n    //  判定像素点是否在三角形内\n    float inside = insideA * insideB * insideC;\n    \n    // 颜色输出\n    fragColor = vec4(inside, inside, inside, 1.0);\n}","name":"Image","description":"","type":"image"}]}