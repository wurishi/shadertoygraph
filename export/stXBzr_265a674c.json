{"ver":"0.1","info":{"id":"stXBzr","date":"1651163904","viewed":237,"name":"skybox shader","username":"itsjonebone","description":"my clouds with Mie  based on https://github.com/shff/opengl_sky\ngets dark during the night ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["clouds"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst vec3 u_light_position = vec3(0., 1., 0.);\nconst vec3 u_camera_position = vec3(-1., -1., 0.);\n\nconst vec4 u_color = vec4(0.8, 0.2, 0.7, 1.);\n\n\nfloat hash(float n)\n{\n    return fract(sin(n) * 43758.5453123);\n}\n\nfloat noise(vec3 x)\n{\n    vec3 f = fract(x);\n    float n = dot(floor(x), vec3(1.0, 157.0, 113.0));\n    return mix(mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n        mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n        mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n            mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\nfloat perlin_threshold(vec3 pos){\n    float rp = remap(perlin(pos.xy, 4.), -1., 1., -0.2, 1.7);\n    rp = pow(rp, 2.7);\n    if(rp > 1.) rp = 1.;\n    else if (rp < 0.) rp = 0.;\n    return rp;\n}\n\nconst mat3 m = mat3(0.0, 1.60, 1.20, \n                    -1.6, 0.72, -0.96, \n                    -1.2, -0.96, 1.28);\n\n\n\nfloat fbm(vec3 p) {\n    //float t = perlin_threshold(p / 10.);\n    //if(t < 0.1) return 0.;\n    float f = 0.0;\n    f += noise(p) / 2.; p = m * p * 1.1;\n    f += noise(p) / 4.; p = m * p * 1.2;\n    f += noise(p) / 6.; p = m * p * 1.3;\n    f += noise(p) / 12.; p = m * p * 1.4;\n    f += noise(p) / 24.;\n    return f;// * t;\n}\n/*\nfloat fbm(vec3 p) {\n    vec2 uv = vec2(p.x * p.z, p.z);\n    return cloud(uv, 1.);\n    return remap(cloud(uv, 1.), 0.75, 1., 0., 1.);\n}\n*/\n\n// this noise lookup inspired by iq's 3D noise lookup in his clouds shader\nfloat tex_noise(vec3 p) {\n    vec3 id = floor(p);\n    vec3 pos = fract(p);\n    //quintic interpolation\n    pos = pos * pos * pos * (pos *(pos * 6.0 - 15.0) + 10.0);\n    p = id + pos + 0.5;\n    return textureLod(iChannel0, p / 32. , 0.0).x * 2. - 1.;\n}\n\nfloat vol_fbm(vec3 p) {\n    return abs(\n           tex_noise(p * 1.) * .6 ) +\n           tex_noise(p * 2.) * .3 +\n           tex_noise(p * 4.) * .25 +\n           tex_noise(p * 8.) * .125;\n}\n\n\n\nfloat scene(vec3 p) {\n    p = p - iTime * 0.3;\n    float g = 0.5+0.5*tex_noise( p*0.3 );\n    float f = vol_fbm(p * 1.5);\n    //f = clamp(f, 0., 1.);\n    f = mix( f*0.1-0.75, f, g*g ) + 0.1;\n    // -1.65 => holes start to appear\n    p = p + iTime * 0.3;\n    return 1.5*f - .5 - ((p.y - 2.) * 1.); // noise bounding based on y value\n}\n\nvec3 noiseVec(vec3 p) {\n    vec3 v = textureLod(iChannel0, normalize(p), 0.).xyz;\n    return v * 2. - 1.;\n}\n\n// returns 6t^5 - 15t^4 + 10t^3\nfloat quintic_fade(float t) {\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\n\nvec4 volCloud(vec3 uvw, vec3 origin, vec3 sun_dir, vec3 cloudCol, vec3 lightCol, vec4 bgCol) {\n    float camAngle = 0.;\n    float dist = 3.;\n    int ray_it = 80;\n    int light_it = 4;\n    float opacity = 18.;\n    //vec3 cloudCol = vec3(0.5, 0.5, 0.6);\n    float light_opacity = 15.;\n    //vec3 lightCol = vec3(0.9, 0.7, 0.1);\n    \n    /// raycasting \n    // rays start at origin\n    // most of this can be moved to CPU computation to be passed to the shader in a practical application\n    origin *= dist;\n    origin += vec3(0., 2., 0.0); // adding y offset\n    vec3 target = vec3(0., -1., 0.);\n    \n    // normalized directional vector from origin to target\n    vec3 ot = normalize(target - origin);\n    // normalized left directional vector\n    // supply what we consider the up vector (-y in this case)\n    vec3 left = normalize(cross(vec3(0., 1., 0.), ot ));\n    // normalized up directional vector\n    vec3 up = normalize(cross(ot, left));\n    // normalized directional vector from origin to pixel\n    //vec3 dir = normalize(uv.x * left + uv.y * up + 1.5 * ot);\n    vec3 dir = normalize(mat3(left, up, ot) * normalize(vec3(uvw.xy, 1.)));\n    // ^ these two lines are the same\n    \n    // density ray loop things\n    \n    // sphere optimisation steps\n    //float area_mult = (2. * dist) * 0.01;\n    //float length_bound = area_mult * inv_sphere_mult;\n    // (area_mult * inv_square_mult)^2 can be done by hand in advance when dist is constant\n    //float length_bound_squared = length_bound * length_bound;\n    //float zMax = sqrt(length_bound_squared - (uv.x * uv.x + uv.y * uv.y));\n    \n    // following bounding based on iq's clouds shader:\n    //float volBasePlane = -4.0;\n    //float volTopPlane = 0.2;\n    float volBasePlane = 1.0;\n    float volTopPlane = 3.1;\n    \n    float stepToBase = (volBasePlane - origin.y)/dir.y; // stepToBase * dir + origin = P where p.y = volBase\n    float stepToTop = (volTopPlane - origin.y)/dir.y;  // stepToTop * dir + origin = P where p.y = volTop\n    \n    float stepMin, stepMax;\n    if( origin.y<volBasePlane) { \n        // if origin is below base plane\n        // view is from under clouds\n        // closest plane is Base plane\n        if( stepToBase < 0.0 ) return bgCol;\n        // if negative, then direction to plane is -dir (bad)\n        \n        // min set to dist to nearest plane\n        // max set to dist to farthest plane\n        stepMin = stepToBase;\n        stepMax = stepToTop;\n        \n    } else if( origin.y > volTopPlane) { \n        // if origin is above top plane\n        // view from above clouds\n        // closest plane is top plane\n        \n        if( stepToTop < 0.0 ) return bgCol;\n        // if negative, then direction to plane is -dir (bad)\n        //bgCol = vec4(0.5, .2, .2, 1.);\n        // min set to dist to nearest plane\n        // max set to dist to farthest plane\n        stepMin = stepToTop;\n        stepMax = stepToBase;\n        \n    } else { // view from inside clouds\n        \n        //bgCol = vec4(0.2, .7, .2, 1.);\n        stepMin = 0.0;\n        stepMax = 80.0;\n        // set max to the distance to the closest bound\n        if( stepToTop>0.0 ) stepMax = min( stepMax, stepToTop );\n        if( stepToBase>0.0 ) stepMax = min( stepMax, stepToBase );\n    }\n    \n    \n    // end bounding based on iq's shader\n    \n    float zTravel = stepMax-stepMin;\n    float zStep = zTravel / float(ray_it);\n    vec3 rayPoint = origin + stepMin * dir;\n    float ditherOffset = tex_noise(rayPoint * 0.27);\n    rayPoint += dir * (ditherOffset * zStep);\n    vec3 color = vec3(0.);\n    float density = 0.;\n    //Transmittence\n    float T = 1.;\n    float travelDist = stepMin + (ditherOffset * zStep);\n    \n    // light loop things\n    float lzTravel = zTravel * 0.125;\n    float lStep = lzTravel / float(light_it);\n    //float lStep = lzTravel * 0.125;\n    vec3 light_step = sun_dir * lStep;\n    float cone_spread_multiplier = length(light_step);\n    float light_density = 0.;\n    float lightSample = 0.;\n    \n    // ray loop\n    for(int i = 0; i < ray_it; i ++) {\n        density = scene(rayPoint);\n        \n        if (density > 0.) {\n            density = density / float(ray_it);\n            \n            T *= 1. - (density * float(ray_it) * 0.5);\n            // if ray_it == 100 we can simplify the above commented lines to:\n            //density = density / 2.;\n            //T *= 1. - density;\n            // idk if that's right actually\n            \n            \n            // allows transmittence to be \"used up\" as it goes through the cloud\n            if (T <= .01) break;\n            \n            /// light sampling\n            // copy point for use in sampling loop\n            vec3 samplePoint = rayPoint + ditherOffset * light_step;\n            // sampling loop\n            for (int j = 1; j < light_it; j ++) {\n                samplePoint += light_step; \n                   + (cone_spread_multiplier * float(i) * noiseVec(samplePoint));\n                   \n                lightSample = scene(samplePoint);\n                if (lightSample > 0.) {\n                    light_density += lightSample * 1.0;\n                }\n                \n            }\n            \n            // Beer's law states that\n            // E = e^-t\n            // where \n            // E is light engergy\n            // t is thickness\n            vec3 localCol = (cloudCol * opacity + lightCol * exp(-1. * light_density) * light_opacity) * density * T;\n            // add a fog effect to farther areas (inspired by iq)\n            //localCol = mix(localCol, bg, 1.0 - exp2(-0.075 * (0.5 * zStep * float(i)) ));\n            \n            \n            localCol = mix(localCol , bgCol.rgb / float(ray_it), clamp(0.5-exp2(-0.075*(travelDist)), 0., 1.) );\n            \n            float farness = length(target-rayPoint);\n            if (farness > 30.) localCol *= 30./farness;\n            \n            color += localCol;\n        }\n        \n        \n        rayPoint += dir * zStep;\n        \n        \n    }\n    \n    //add background if you want to!\n    color += bgCol.rgb;\n    \n\n    // Output to screen\n    return vec4(color, 1.);\n    \n    // here goes nothing\n\n}\n\n\n\nvoid mainImage( out vec4 out_color, in vec2 fragCoord )\n{\n    float u_time = iTime + 8.;\n    \n    //vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv = (2. * fragCoord - iResolution.xy)/(iResolution.y) ;\n    \n    //vec3 uvw = vec3(uv, abs(sin(iTime / 10.)));\n    vec3 uvw = vec3(uv, abs(sin(80.6)));\n    \n    vec2 m =                iMouse.xy      /iResolution.xy;\n    //m = (2. * iMouse.xy - iResolution.xy)/(iResolution.y);\n    vec3 origin = normalize(vec3(sin(3.0*m.x), 0.99 * m.y, cos(3.0*m.x)));\n    origin.y = remap(origin.y, 0., 1., -1., 1.);\n    \n    vec3 pos = origin * iResolution.y /250.;\n    pos = uvw;\n    // pos does need to be normalized\n    \n    \n    out_color = u_color;\n\n    //vec3 pos = vertout_fragment_position / 50.f;\n    //vec3 fsun = vec3(0.5, 1.5f, 0.f);\n    vec3 fsun = vec3(cos(u_time * 10.0 * 0.01), sin(u_time*10.0*0.01), cos(u_time * 10.0 *0.01));\n    \n    const float Br = 0.0001;\n    const float Bm = 0.0005;\n    const float g = 0.99;\n\n    const vec3 nitrogen = vec3(0.650, 0.570, 0.475);\n    const vec3 Kr = Br / pow(nitrogen, vec3(4.0));\n    const vec3 Km = Bm / pow(nitrogen, vec3(0.84));\n\n\n\n    float mu = dot(normalize(pos), normalize(fsun));\n\n    float rayleigh = 6.0 / (8.0 * 3.14) * (1.0 + mu * mu);\n\n    float sun_disk_size = 0.90f;\n\n    //vec3 mie = (Kr + Km * (1.0 - g * g) / (2.0 + g * g) / pow(1.0 + g * g - 2.0 * g * mu, 1.5)) / (Br + Bm);\n    vec3 mie = (Kr + Km * (0.99 - g * g) / (0.98 + g * g) / pow(1.0 + g * g - 2.0 * g * mu, sun_disk_size)) / (Br + Bm);\n\n    float sunrise_duration = 3000.f;\n    float sunrise_persistance = 2.f;\n    float sunrise_vibrance = 100.f;\n    float twilight_duration = 10.f;\n    float horizon_cutoff_height = 0.1f;\n    float atmosphere_scaling = 0.001f;\n    float haziness = 100.f;\n    float sunlight_strength = 2.f;\n    float sundisk_scaling = 0.4f;\n    float night_ambiance = 0.1f;\n    float sundisk_pureness = 0.7f;\n\n    float sunset_smoothness_offset = 0.5f;\n\n    vec3 day_extinction =  exp(-exp(-((pos.y + fsun.y * sunrise_persistance) \n                        * (exp(-pos.y * (100.0/sunrise_vibrance)) + sunset_smoothness_offset) / sunrise_duration) / Br)\n                        * (exp(-pos.y * twilight_duration) + sunset_smoothness_offset) * Kr / Br)\n                        *  exp(-pos.y * exp(-pos.y * horizon_cutoff_height) * atmosphere_scaling)\n                        *  exp(-pos.y * (100.0 / haziness)) * sunlight_strength;\n\n    vec3 night_extinction = vec3(1.f - exp(fsun.y)) * night_ambiance;\n\n    vec3 middleColor = vec3(0.992, 0.369, 0.325) * max((0.5f - abs(fsun.y)), 0.f);// pow(abs(fsun.y), 4.f / 5.f));\n    //vec3 middleColor = vec3(0.992, 0.369, 0.325) * (1.f - fsun.y);// pow(abs(fsun.y), 4.f / 5.f));\n\n    vec3 extinction = mix(day_extinction, \n                          night_extinction+middleColor, \n                          -fsun.y * sundisk_scaling + sundisk_pureness);\n\n    vec3 orange_tint = vec3(0.9686, 0.949, 0.8196);\n    out_color.rgb = rayleigh * mie * extinction * orange_tint * orange_tint;\n    \n\n    float cirrus = 0.9;\n    float cumulus = 0.6;\n    \n    float cloudSpeed = 10.;\n\n    // cloud fbm lookups are basically pos.x/pos.y, 1, pos.z/pos.y\n    //pos.z = pos.y * pos.y;\n\n    // my clouds :)\n    fsun.y *= -1.;\n    vec4 cloud_color = volCloud(uvw, origin, normalize(fsun), extinction * 4. * max(pos.y, 0.0), extinction, out_color);\n    \n    if (abs(cloud_color.x - out_color.x) < 0.135 && false) {\n        // Cirrus Clouds\n        out_color = mix(out_color, cloud_color, abs(cloud_color - out_color));\n        float density = smoothstep(1.0 - cirrus, 1.0, fbm(pos.xyz / pos.y * 2.0 + u_time * 0.05 * cloudSpeed)) * 0.3;\n        out_color.rgb = mix(out_color.rgb, extinction * 4.0, density * max(pos.y, 0.0));\n    } else out_color = cloud_color;\n    \n\n    \n    \n    \n    \n    // Cumulus Clouds\n    //for (int i = 0; i < 3; i++)\n    //{\n    //    float density = smoothstep(1.0 - cumulus, 1.0, fbm((0.7 + float(i) * 0.1) * pos.xyz / pos.y + u_time * 0.3 * cloudSpeed));\n        //out_color.rgb = mix(out_color.rgb, extinction * density * 5.0, min(density, 1.0) * max(pos.y, 0.0));\n    //}\n    \n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//// *** noisemaking in here *** ////\n\n/// point of interest generator\n// point of interest is a point we calculate distance to for worley noise\nvec2 poi_gen (vec2 gridIndex) {\n    // random val calculated based on gridindex and time\n    // ensures for the same grid index and time any calculated points are identical\n    // adding 1 to gridIndex prevents multiplying by 0 issues\n    return fract(sin(vec2(dot(gridIndex + 1.0, vec2(127.4, 723.8)), \n                dot(gridIndex + 1.0, vec2(837.7, 208.7)))) * 25787.33);\n}\n\n/// Inverse Worley Noise \nfloat worley(vec2 p, float freq) {\n    // assume p is normalized\n    // split p into id and position\n    vec2 id = floor(p);\n    vec2 pos = fract(p);\n    \n    float minDist = 100.0; // needs to be too big initially\n    for(int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n            vec2 offset = vec2(x, y);\n            vec2 poi = poi_gen(mod(id + offset, vec2(freq))); // use mod for tiling\n            poi += offset;\n            vec2 diff = poi - pos;\n            minDist = min(minDist, length(diff));\n        }\n    }\n    return 1.0 - minDist; // inverting noise\n}\n\n/// Compound Worley Noise\n// uses the Worley FBM described by Schneider's chapter in GPU Pro 7\nfloat worleyFBM(vec2 p, float freq) {\n    return worley(p * freq, freq) * 0.625 +\n           worley(p * freq * 2., freq * 2.) * 0.25 +\n           worley(p * freq * 4., freq * 4.) * 0.125;\n}\n\n/// PERLIN\n// modified to tile from thebookofshaders.com\nfloat perlin(vec2 uv, float freq) {\n    vec2 p = uv * freq;\n    // split into ID and position\n    vec2 id = floor(p);\n    vec2 pos = fract(p);\n    \n    // tile corners\n    float a = poi_gen(id).x;\n    float b = poi_gen(mod(id + vec2(1., 0.), freq)).x;\n    float c = poi_gen(mod(id + vec2(0., 1.), freq)).x;\n    float d = poi_gen(mod(id + vec2(1., 1.), freq)).x;\n    \n    //smooth interpolation\n    vec2 u = smoothstep(0., 1., pos);\n    //u = pos * pos * (3. - 2. * pos);\n    \n    // mix 4 corners using position as percentage\n    return mix(a, b, u.x) +\n           (c - a) * u.y * (1. - u.x) +\n           (d - b) * u.x * u.y;\n}\n\n\n/// Multi-octave perlin noise compounder\nfloat perlinFBM(vec2 p, float freq, int octaves) {\n    float noise = 0.;\n    float w = 0.5;\n    float c = 1.;\n    for (int i = 0; i < octaves; ++i) {\n        noise += w * perlin(p , freq * c);\n        c = c * 2.;\n        w *= 0.5;\n    }\n\n    return noise;\n}\n\n\n/// PerlinWorley\n// remapping as described by Schneider's chapter in GPU Pro 7\nfloat remap(float val, float old_min, float old_max, float new_min, float new_max) {\n    return new_min + (((val - old_min) / (old_max - old_min)) * (new_max - new_min));\n}\n\nfloat perlin_worley(vec2 uv, float freq) {\n    float w = worleyFBM(uv, freq);\n    float p = perlinFBM(uv, freq, 5);\n    p = abs(p * 2. - 1.);\n    return remap(p, 0., 1., w, 1.);\n}\n\n///cloud\nfloat cloud(vec2 uv, float freq) {\n    float pw = perlin_worley(uv, freq);\n    float wg = worleyFBM(uv, freq);\n    float wb = worleyFBM(uv, freq * 2.);\n    float wa = worleyFBM(uv, freq * 4.);\n    \n    float wfbm = wg * .625 + wb * .25 + wa * 0.125;\n    \n    return remap(pw, wfbm - 1., 1., 0., 1.);\n}\n","name":"Common","description":"","type":"common"}]}