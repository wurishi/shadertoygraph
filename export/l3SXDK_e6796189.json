{"ver":"0.1","info":{"id":"l3SXDK","date":"1711074852","viewed":75,"name":"Closest Tangent Pt - Sphere","username":"natevm","description":"Minimal tangent cone to a sphere. If the cone goes blue, nothing's visible in the positive hemisphere. \n\nMore closest tangency point queries here!: https://www.shadertoy.com/playlist/NcKBDV","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","sdf","capsule","closest"],"hasliked":0,"parentid":"4XBXzz","parentname":"Closest Tangent Point - Segment"},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright © 2024 Nate Morrical\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// cheaper alternative to acos intrinsic\n// https://developer.download.nvidia.com/cg/acos.html\nfloat swacos(float x) {\n  float negate = float(x < 0.f);\n  x = abs(x);\n  float ret = -0.0187293f;\n  ret = ret * x;\n  ret = ret + 0.0742610f;\n  ret = ret * x;\n  ret = ret - 0.2121144f;\n  ret = ret * x;\n  ret = ret + 1.5707288f;\n  ret = ret * sqrt(1.f-x);\n  ret = ret - 2.f * negate * ret;\n  return negate * 3.14159265358979f + ret;\n}\n\n// Given an angular similarity, returns the corresponding angle in radians. \n//   s - the similarity measure, s = (dot(d, ∆) |dot(d, ∆)| / |∆|^2)\nfloat similarityToAngle(float s) {\n    if (0.f <= s && s <= 1.f) {\n        return swacos(2.f * s - 1.0) / 2.0;\n    }\n    else if (-1.f <= s) {\n        return (swacos(2.f * s + 1.0) / 2.0) + radians(90.);\n    }\n}\n\n// Returns the angular similarity between two directions. \n// Similarity is expressed as s = dot(d, ∆) |dot(d, ∆)| / |∆|^2\n//  d - the direction of a ray\n//  ∆ - a vector relative to ray's origin. (∆ = p - o)\nfloat angularSimilarity(vec3 d, vec3 delta) {    \n    // length squared of delta\n    float deltaNorm2 = dot(delta, delta);\n    \n    // proportional to cos(theta) between d and ∆\n    float dDotDelta = dot(d, delta);\n    \n    // similarity = dot(d, ∆) |dot(d, ∆)| / |∆|^2\n    return dDotDelta * abs(dDotDelta) / deltaNorm2;\n}\n\n// Returns the angular similarity to a point relative to a cone.\n// Similarity is expressed as s = dot(d, ∆) |dot(d, ∆)| / |∆|^2\n//  o - the origin, or \"apex\" of the cone.\n//  d - the direction of the cone, perpendicular to it's base.\n//  p - the point, in the same coordinate system as o\nfloat mtcPointQuery(vec3 o, vec3 d, vec3 p) {\n    // The vector ∆ relating cone origin to point\n    vec3 delta = p - o;\n    \n    // length squared of delta\n    float deltaNorm2 = dot(delta, delta);\n    \n    // proportional to cos(theta) between d and ∆\n    float dDotDelta = dot(d, delta);\n    \n    // similarity = dot(d, ∆) |dot(d, ∆)| / |∆|^2\n    return dDotDelta * abs(dDotDelta) / deltaNorm2;\n}\n\n// Returns the angular similarity to a sphere relative to a cone.\n// Similarity is expressed as s = dot(d, ∆) |dot(d, ∆)| / |∆|^2\n//  o - the origin, or \"apex\" of the cone.\n//  d - the direction of the cone, perpendicular to it's base.\n//  p - the point, in the same coordinate system as o\nvec4 mtcSphereQuery(vec3 P, vec3 D, vec3 C, float r )\n{\n    float r2 = r * r;\n    \n    // The logic below simplifies the problem down to 2D, where we find the two points of tangency \n    // on a circle.\n    \n    // The vector ∆ relating cone apex to sphere origin\n    vec3 delta = C - P;\n    \n    // The Distance (squared) from apex to sphere center\n    float distAToC = dot(delta, delta);\n    \n    // The normal of our 2D plane, containing the circle (and our two extremal tangent points). \n    vec3 N = (cross(delta, D));\n    \n    // First application of A^2 = B^2 + C^2. The point of tangency will be perpendicular to our \n    // cone (in 2D, a line). The sides of this triangle are from apex to circle center, center to \n    // tangency point, and tangency point to apex. We now know the distance from apex to center, and \n    // also know the distance from center to tangency is equal to the circle's radius. So we solve \n    // for the distance to the point of tangency. \n    float distToTan = (r2 / distAToC);\n\n    // Next, we calculate a \"base point\", which lies on the circumference of a great circle containing\n    // the points of tangency. This base point forms a second right triangle, from base to center to point of tangency.\n    vec3 base = C - delta * distToTan;\n\n    // Vector from the sphere's center to our base point. \n    vec3 CToBase = base - C; \n    \n    // distance (squared) from sphere's center to base point\n    float distBaseToC = dot(CToBase, CToBase);\n    \n    // Second application of A^2 = B^2 + C^2, this time finding the distance from our base point \n    // to the point of tangency\n    float h2 = r2 - distBaseToC;\n \n    float h = sqrt(h2);\n    \n    // We can now find the direction towards the point of tangency relative to the base point. \n    vec3 dir = normalize(cross(N, delta));\n    \n    // Calculating the tangent points\n    vec3 T1 = base + h * dir;\n    vec3 T2 = base - h * dir;\n    \n    // Compute which point has the largest angular similarity\n    float s1 = angularSimilarity(D, T1 - P);\n    float s2 = angularSimilarity(D, T2 - P);\n    \n    if (s1 > s2) return vec4(s1, T1);\n    else return vec4(s2, T2);\n}\n\n\n\n\n//------------------------------------------------------------\n\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, vec3 cen, float rad )\n{\n    return length(p-cen)-rad;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\nvec3 angleAxis(float angle, vec3 axis, vec3 v) {\n    vec3 k = normalize(axis); // Ensure the axis is a unit vector\n    float cosTheta = cos(angle);\n    float sinTheta = sin(angle);\n\n    // Rodrigues' rotation formula\n    vec3 rotated = v * cosTheta + \n                   cross(k, v) * sinTheta + \n                   k * dot(k, v) * (1.0 - cosTheta);\n\n    return rotated;\n}\n\n//https://www.shadertoy.com/view/NttcW8\nfloat sdArrow(vec3 position, vec3 start, vec3 end, float baseRadius, float tipRadius, float tipHeight) {\n    vec3 t = start - end;\n    float l = length(t);\n    t /= l;\n    l = max(l, tipHeight);\n\n    position -= end;\n    if (t.y + 1.0 < 0.0001) {\n        position.y = -position.y;\n    } else {\n        float k = 1.0 / (1.0 + t.y);\n        vec3 column1 = vec3(t.z * t.z * k + t.y, t.x, t.z * -t.x * k);\n        vec3 column2 = vec3(-t.x, t.y, -t.z);\n        vec3 column3 = vec3(-t.x * t.z * k, t.z, t.x * t.x * k + t.y);\n        position = mat3(column1, column2, column3) * position;\n    }\n \n    vec2 q = vec2(length(position.xz), position.y);\n    q.x = abs(q.x);\n   \n    // tip\n    vec2 e = vec2(tipRadius, tipHeight);\n    float h = clamp(dot(q, e) / dot(e, e), 0.0, 1.0);\n    vec2 d1 = q - e * h;\n    vec2 d2 = q - vec2(tipRadius, tipHeight);\n    d2.x -= clamp(d2.x, baseRadius - tipRadius, 0.0);\n    \n    // base\n    vec2 d3 = q - vec2(baseRadius, tipHeight);\n    d3.y -= clamp(d3.y, 0.0, l - tipHeight);\n    vec2 d4 = vec2(q.y - l, max(q.x - baseRadius, 0.0));\n\n    float s = max(max(max(d1.x, -d1.y), d4.x), min(d2.y, d3.x));\n    return sqrt(min(min(min(dot(d1, d1), dot(d2, d2)), dot(d3, d3)), dot(d4, d4))) * sign(s);\n}\n\nfloat sdSolidAngle(vec3 p, vec3 a, vec3 d, vec3 b) {\n    // Length of the side of the solid angle conic\n    float ra = distance(a, b);    \n    \n    // The angle between the direction of the conic and a point\n    // on the base.\n    float s = angularSimilarity(d, b-a);\n    float ang = similarityToAngle(clamp(s, 0.0, 1.0));\n    \n    // Transform query point s.t. apex is origin\n    p = p-a;\n    \n    // Rotate query point such that conic direction is aligned to \"y\"\n    vec3 yAxis = vec3(0, 1, 0);\n    vec3 rotAxis = cross(d, yAxis);\n    float rotAngle = acos(dot(yAxis, d));\n    vec3 pRot = angleAxis(rotAngle, rotAxis, p);\n\n    // Now compute the SDF as before with the rotated point\n    vec2 q = vec2( length(pRot.xz), pRot.y );\n    \n    vec2 c = vec2(sin(ang), cos(ang)); \n    float l = length(q) - ra;\n    float m = length(q - c*clamp(dot(q,c),0.0,ra) );\n    return max(l,m*sign(c.y*q.x-c.x*q.y));\n}\n\n//------------------------------------------------------------\nconst float rad = 0.5;\nconst vec3 cen = vec3(0.f, 0.0, 0.0);\n\nvec2 map( in vec3 pos, bool showSolidAngle, bool showSphere, in vec3 apex, in vec3 dir )\n{\n    vec2 res = vec2(1e38f);\n    vec4 sxyz = mtcSphereQuery(apex, dir, cen, rad);\n    vec3 p = sxyz.yzw;\n    \n    // point on surface which lies tangent to the cone\n    {\n    float d = sdSphere( pos, p, 0.06 );\n    if( d<res.x ) res = vec2( d, 1.0 );\n    }\n    \n    // Sphere's surface\n    if (showSphere)\n    {\n    float d = sdSphere( pos, cen, rad);\n    if( d<res.x ) res =  vec2( d, 5.0 );\n    }\n    \n    // Arrow representing the ray\n    {\n    float d = sdArrow(pos, apex, apex+dir, .01, .06, .08);\n    if( d<res.x ) res =  vec2( d, 0.0 );\n    }\n   \n    // Query cone   \n    if (showSolidAngle) {    \n    float d = sdSolidAngle(pos, apex, dir, p + -normalize(apex - p));\n    if( d<res.x ) res =  vec2( d, 1.0 );\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, bool showSolidAngle, bool showSphere, in vec3 apex, in vec3 dir )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps, showSolidAngle, showSphere, apex, dir ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps, showSolidAngle, showSphere, apex, dir ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps, showSolidAngle, showSphere, apex, dir ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps, showSolidAngle, showSphere, apex, dir ).x );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftShadow( vec3 ro, vec3 rd, bool showSolidAngle, bool showSphere, in vec3 apex, in vec3 dir )\n{\n    float res = 1.0;\n    const float tmax = 2.0;\n    float t = 0.001;\n    for( int i=0; i<64; i++ )\n    {\n     \tfloat h = map(ro + t*rd, showSolidAngle, showSphere, apex, dir).x;\n        res = min( res, 64.0*h/t );\n    \tt += clamp(h, 0.01,0.5);\n        if( res<-1.0 || t>tmax ) break;\n        \n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep, in [-1,1]\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord)*AA + ivec2(m,n);\n        // time sample\n        float td = 0.5+0.5*sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1);\n        float time = iTime - 0.5*(1.0/60.0)*(td+float(m*AA+n))/float(AA*AA-1);\n        #else    \n        // pixel coordinates\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord);\n        // time sample\n        float time = iTime;\n        #endif\n\n        // animate camera\n        float an = 0.25*time + 6.283185*iMouse.x/iResolution.x;\n        vec3 ro = vec3( 2.4*cos(an), 0.7, 2.4*sin(an) );\n        vec3 ta = vec3( 0.0, 0.0, 0.0 );\n\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.2,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n\n        // animate the tangent cone\n        vec3 start = 1.5 * -sin(iTime*0.5*vec3(1.0,1.1,1.2)+vec3(4.0,2.0,1.0));\n        vec3 stop  = 1.5 * -cos(iTime*0.5*vec3(1.0,1.1,1.2)+vec3(4.0,2.0,1.0));\n        vec3 apex = start;\n        vec3 dir = normalize(stop - start);\n        \n        // Make bounding sphere and solid angle transparent\n        bool showSolidAngle = (texelFetch(iChannel0,samp&7,0).x>0.25);\n        bool showSphere = (texelFetch(iChannel0,samp&7,0).x>0.25);\n        \n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raycast\n        const float tmax = 5.0;\n        float t = 0.0;\n        float m = -1.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            vec2 hm = map(pos, showSolidAngle, showSphere, apex, dir);\n            m = hm.y;\n            if( hm.x<0.0001 || t>tmax ) break;\n            t += hm.x;\n        }\n    \n        // shade background\n        vec3 col = vec3(0.05)*(1.0-0.2*length(p));\n        \n        // shade objects\n        if( t<tmax )\n        {\n            // geometry\n            vec3  pos = ro + t*rd;\n            vec3  nor = calcNormal(pos, showSolidAngle, showSphere, apex, dir);\n\n            // color\n            vec3  mate = 0.55 + 0.45*cos( m + vec3(0.0,1.0,1.5) );\n                \n            vec4 result = mtcSphereQuery(apex, dir, cen, rad);\n            vec3 p = result.yzw;\n            \n            // Show distance isolines on query\n            if( abs(m-1.0)<0.6 || abs(m-3.0)<0.6)\n            {   \n                float dref = sdSolidAngle(p, apex, dir, p);\n                float dsam = length(pos-p);\n                mate += smoothstep(0.8,0.9,sin((dsam-dref)*80.0))*exp2(-1.0*(dsam-dref)*(dsam-dref));\n            }\n            \n            // Show distance isolines on sphere\n            if( abs(m-5.0)<0.6)\n            {     \n                float dref = sdSphere(p, cen, rad);\n                float dsam = length(pos-p);\n                mate += smoothstep(0.8,0.9,sin((dsam-dref)*80.0))*exp2(-1.0*(dsam-dref)*(dsam-dref));\n            }\n                       \n            // lighting\t\n            col = vec3(0.0);\n            {\n              // key light\n              vec3  lig = normalize(vec3(0.3,0.7,0.2));\n              float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n              if( dif>0.001 ) dif *= calcSoftShadow(pos+nor*0.001,lig, showSolidAngle, showSphere, apex, dir);\n              col += 0.75*mate*vec3(1.0,0.9,0.8)*dif;\n            }\n            {\n              // dome light\n              float dif = 0.5 + 0.5*nor.y;\n              col += 0.75*mate*vec3(0.2,0.3,0.4)*dif;\n            }\n        }\n\n        // gamma        \n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}