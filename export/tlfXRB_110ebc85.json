{"ver":"0.1","info":{"id":"tlfXRB","date":"1563361683","viewed":2310,"name":"Dawn and Water","username":"96logda","description":"With this shader it is possible to do a lot of cool stuff.\nYou can change the weather, apply various tonemaps, apply filters like sepia, vignette and color grading and modify how the water will behave by change the sea properties.\n ","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["procedural","noise","sea","water","ocean","reinhard","filmic","tonemap","aces","aces","alu","dawn","uncharted2","fogmap","hejl2015"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Copyright (c) 2019-06-23 - 2019-07-27 by Angelo Logahd\n//Portfolio: https://angelologahd.wixsite.com/portfolio\n\n//2019-09-27: Added support for filmic ALU tonemap\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n//...........................................................\n//\t\t    \t\t\tDO NOT MODIFY!\n//...........................................................\n#define SIMULATE \t\t\t\t0\n#define SIMULATE2x\t\t\t\t1\n#define SIMULATE3x\t\t\t\t2\n#define SIMULATE4x\t\t\t\t3\n#define SIMULATE5x\t\t\t\t4\n#define PAUSED\t\t\t\t\t5\n#define SLOW_MOTION\t\t\t\t6\n\n#define WAVES_WATER\t\t\t\t0\n#define CALM_WATER\t\t\t\t1\n//...........................................................\n\n//...........................................................\n//\t\t\t    \t\t   Settings\n//...........................................................\n#define SIMULATE_MODE\t\t\tSIMULATE\n#define WATER_TYPE\t\t\t\tCALM_WATER\n#define RAINBOW_WATER\t\t\tfalse\n#define FANTASY_WATER_PATH\t\tfalse\n#define FLIP_WATER_AND_SKY\t\tfalse\n#define DAY_AND_NIGHT\t\t\tfalse\n#define SUN_LIGHT\t\t\t\ttrue\n#define TEXTURED_GROUND\t\t\ttrue\n#define HDR\t\t\t\t\t\ttrue\n//...........................................................\n\n//...........................................................\n//\t\t    \t\t Day and night properties\n//...........................................................\n#if DAY_AND_NIGHT\nconst float DAY_AND_NIGHT_TIME\t\t\t\t0.1\nconst float DAY_AND_NIGHT_MIN_BRIGHTNESS\t0.2\nconst float DAY_AND_NIGHT_MAX_BRIGHTNESS\t1.0\n#endif\n//...........................................................\n\n//...........................................................\n//\t\t\t     \t\t\t  Sky\n//...........................................................\n#define SKY_GRADIENT_SKY_1\t\t\t\t0\n#define SKY_GRADIENT_SKY_2\t\t\t\t1\n#define SKY_SOLID_COLOR\t\t\t\t\t2\n\n#define SKY_TYPE\t      \t\t\t\tSKY_GRADIENT_SKY_1\n\n#if   SKY_TYPE == SKY_GRADIENT_SKY_1\nconst float SKY_RED_POW_FACTOR\t\t\t= 3.3;\nconst float SKY_RED_MUL_FACTOR  \t\t= 0.6;\nconst float SKY_GREEN_SUBTRACT  \t\t= 0.3;\nconst float SKY_BLUE_AMOUNT\t\t\t\t= 1.8;\n#elif SKY_TYPE == SKY_GRADIENT_SKY_2\nconst vec3  SKY_COLOR_1\t\t\t\t\t= vec3(0.0, 0.0, 0.1);\nconst vec3  SKY_COLOR_2\t\t\t\t\t= vec3(0.0, 0.0, 0.3);\n#elif SKY_TYPE == SKY_SOLID_COLOR\nconst vec3  SKY_COLOR\t\t\t\t\t= vec3(0.0);\n#endif\n//...........................................................\n\n//...........................................................\n//\t\t\t    \t\t\tWeathers\n//...........................................................\n#define\tRAIN\t\t\t\t\t\t\tfalse\n#define RAINBOW\t\t\t\t\t\t\tfalse\n#define STAR_SKY\t\t\t\t\t\tfalse\n#define SUN\t\t\t\t\t\t\t\ttrue\n#define MOON\t\t\t\t\t\t\tfalse\n\n#if RAIN\nconst vec3  RAIN_BASE_COLOR\t\t\t\t= vec3(1.0, 1.0, 1.0);\nconst float RAIN_COLOR_INTENSITY \t\t= 1.5;\n#endif\n\n#if RAINBOW\n#define RAINBOW_START_Y\t\t\t\t\t0.0\n\nconst float RAINBOW_BRIGHTNESS  \t\t= 1.0;\nconst float RAINBOW_INTENSITY   \t\t= 0.30;\nconst vec3  RAINBOW_COLOR_RANGE \t\t= vec3(50.0, 53.0, 56.0);  // The angle in degrees for red, green and blue\nvec3 \t    RAINBOW_POS\t\t\t\t\t= vec3(4.5, 0.0, 0.5);\nvec3 \t    RAINBOW_DIR \t\t\t\t= vec3(-0.2, -0.1, 0.0);\n#endif\n\n#if STAR_SKY\nconst float STAR_THRESHOLD\t\t\t\t= 0.98;\n#endif\n\n#if MOON\nconst vec2  MOON_F \t\t\t\t\t\t= vec2(0.0);\nconst vec3  MOON_BASE_COLOR \t\t\t= vec3(1.0, 1.0, 1.0);\nconst vec3  MOON_COLOR_GRADING \t\t\t= vec3(0.0, 0.0, 0.3);\nconst float MOON_FOG_LIGHT_STRENGTH\t\t= 0.1;\nconst float MOON_LIGHT_STRENGTH\t\t\t= 0.01;\nconst float MOON_SCALE \t\t\t\t\t= 5.0;\n#endif\n//...........................................................\n\n//...........................................................\n//\t\t\t     \t\t\t  Fog\n//...........................................................\n#define ALWAYS_FOG\t\t\t\t\t\t0\n#define NEVER_FOG\t\t\t\t\t\t1\n\n#define FOG_MODE\t\t\t\t\t\tNEVER_FOG\nconst vec3  FOG_COLOR  \t\t\t\t\t= vec3(0.15, 0.15, 0.15);\nconst float FOG_START \t\t\t\t\t= 0.04;\nconst float FOG_END \t\t\t\t\t= 500.0;\nconst float FOG_DENSITY \t\t\t\t= 0.2;\n\n#define FOGMAP\t\t\t\t\t\t\ttrue\n#if FOGMAP\nconst float FOGMAP_INTENSITY\t\t\t= 2.0;\nconst vec3  FOGMAP_VELOCITY\t\t\t\t= vec3(1.0, 0.2, 1.0);\nconst vec3  FOGMAP_DIR\t\t\t\t\t= vec3(-1.0, 0.5, -1.0);\n#endif\n//...........................................................\n\n//...........................................................\n//\t\t     \t\t Sun light properties\n//...........................................................\n#if SUN_LIGHT\nvec3  SEA_SUN_DIRECTION\t\t    \t\t= vec3(0.0, -1.0, -0.5);\nvec3  SEA_SUN_COLOR     \t\t\t\t= vec3(1.0, 1.0, 1.0);    //vec3(1.0, 1.0, 0.0) to use a yellow reflection color\nfloat SEA_SUN_DIFFUSE  \t\t\t\t\t= 0.65; \nvec3  SEA_SUN_SPECULAR      \t\t\t= vec3(0.65);\n#endif\n//...........................................................\n\n//...........................................................\n//\t\t\t\t\t   Post Processing\n//...........................................................\n#define APPLY_LUMINANCE\t\t\t\t\ttrue\n#if HDR\n#define APPLY_TONEMAP\t\t\t\t\ttrue\n#endif\n#define APPLY_GAMMA_CORRECTION\t\t\ttrue\n\n#if APPLY_GAMMA_CORRECTION\nconst float GAMMA\t\t\t\t\t\t= 2.2;\n#endif\n\nconst float INTENSITY\t\t\t\t\t= 1.0;\nconst float BRIGHTNESS\t\t\t\t\t= 0.8;\nconst float CONTRAST\t\t\t\t\t= 1.2;\nconst float SATURATION\t\t\t\t\t= 1.0; // 0.0 = luminance\nconst float DESATURATION\t\t\t\t= 0.0; // 1.0 = luminance\n\n#if APPLY_LUMINANCE\nconst float BLOOM_CUTOFF\t\t\t\t= 0.35;\n#endif\n\n#if HDR\n#if APPLY_TONEMAP\n\n#define LINEAR_TONEMAP\t\t\t\t\t0\n#define EXPONENTIAL_TONEMAP\t\t\t\t1\n#define REINHARD_TONEMAP\t\t\t\t2\n#define REINHARD2_TONEMAP\t\t\t\t3\n#define FILMIC_HEJL2015\t\t\t\t\t4\n#define FILMIC_TONEMAP_UNCHARTED2\t\t5\n#define FILMIC_TONEMAP_ACES\t\t\t\t6\n#define FILMIC_TONEMAP_ALU\t\t\t\t7\n\n//Note: If you use FILMIC_HEJL2015 Tonemap then you should use 2.4 as gamma.\n#define TONEMAP_TYPE\t\t\t\t\tFILMIC_TONEMAP_ACES\t\t\n \n#if TONEMAP_TYPE == LINEAR_TONEMAP\nconst float TONEMAP_EXPOSURE\t\t\t= 0.5;\n#endif\n#if TONEMAP_TYPE == EXPONENTIAL_TONEMAP\nconst float TONEMAP_EXPOSURE\t\t\t= 0.5;\n#endif\n#if TONEMAP_TYPE == REINHARD_TONEMAP\nconst float TONEMAP_EXPOSURE\t\t\t= 0.5;\n#endif\n#if TONEMAP_TYPE == REINHARD2_TONEMAP\nconst float LDR_WHITE\t\t\t\t\t= 1.2;\nconst float TONEMAP_EXPOSURE\t\t\t= 0.25;\n#endif\n#if TONEMAP_TYPE == FILMIC_HEJL2015\nconst float TONEMAP_WHITE_POINT\t\t\t= 1.0;\nconst float TONEMAP_EXPOSURE\t\t\t= 0.1;\nconst float TONEMAP_EXPOSURE_BIAS \t\t= 0.85;\n#endif\n#if TONEMAP_TYPE == FILMIC_TONEMAP_UNCHARTED2\n//https://www.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting\n//http://filmicworlds.com/blog/filmic-tonemapping-operators/\n\n//Uncharted2Tonemap:\n//Orginal Values:\n//A = 0.22\n//B = 0.30\n//C = 0.10\n//D = 0.20\n//E = 0.02\n//F = 0.30\n//W = 11.2\n\nconst float A = 0.22;\nconst float B = 0.50;\nconst float C = 0.10;\nconst float D = 0.20;\nconst float E = 0.02;\nconst float F = 0.30;\nconst float W = 11.2;\n\nconst float TONEMAP_EXPOSURE\t\t\t= 0.1;\nconst float TONEMAP_EXPOSURE_BIAS \t\t= 2.0;\n#endif\n#if TONEMAP_TYPE == FILMIC_TONEMAP_ACES\n\nconst float A = 2.51;\nconst float B = 0.03;\nconst float C = 2.43;\nconst float D = 0.59;\nconst float E = 0.14;\nconst float W = 11.2;\n\t\nconst float TONEMAP_EXPOSURE\t\t\t= 0.1;\nconst float TONEMAP_EXPOSURE_BIAS \t\t= 2.0;\n#endif\n#if TONEMAP_TYPE == FILMIC_TONEMAP_ALU\nconst float TONEMAP_EXPOSURE\t\t\t= 0.15;\n#endif\n#endif\n\n#endif\n\n//...........................................................\n//\t\t\tFilters\n//...........................................................\n#define VIGNETTE_FILTER\t\t\t\t\tfalse\n#define SEPIA_FILTER\t\t\t\t\tfalse\n#define COLOR_GRADING_FILTER\t\t\ttrue\n\n#if VIGNETTE_FILTER\nconst vec3  VIGNETTE_COLOR \t\t\t\t= vec3(1.0, 1.0, 1.0);\nconst float VIGNETTE_ZOOM  \t\t\t\t= 2.5; //2.5 -> full image \nconst float VIGNETTE_EXPOSURE \t\t\t= 2.0;\n#endif\n\n#if SEPIA_FILTER\nconst vec3  SEPIA_COLOR \t\t\t\t= vec3(1.9, 0.8, 0.6);\nconst float SEPIA_INTENSITY \t\t\t= 1.0;\n#endif\n\n//Based on Sobel filter\n//You can read more about Sobel here: http://clockworkchilli.com/forum/thread?id=Dynamic_scene_lightning___10351&page=1\n#if COLOR_GRADING_FILTER\n\n#define ADD\t\t\t\t\t\t\t\t0\n#define SUBTRACT\t\t\t\t\t\t1\n#define MULTIPLY\t\t\t\t\t\t2\n#define DIVIDE\t\t\t\t\t\t\t3\n\n#define COLOR_GRADING_BLEND_MODE\t\tMULTIPLY\nconst float COLOR_GRADING_REAL_WEIGHT \t= 1.0;\nconst float COLOR_GRADING_WEIGHT \t\t= 1.0;\nconst float COLOR_GRADING_G \t\t\t= 3.0;\nconst vec3  COLOR_GRADING_COLOR \t\t= vec3(1.0, 0.1, 0.0);\n\n//This is the simplest color grading you can do.\n//What this does is adding the color (COLOR_GRADING_COLOR2) to the result color.\nconst vec3  COLOR_GRADING_COLOR2\t\t= vec3(0.0, 0.0, 0.0);\n#endif\n//...........................................................\t\n\n//...........................................................\n\nconst int SEA_GEOMETRY_ITERATIONS   \t= 8;\nconst int SEA_FRAGMENT_ITERATIONS   \t= 10;\n\n//Sea base properties\nconst vec3  SEA_BASE_COLOR \t\t\t\t= vec3(0.08, 0.1, 0.125); //vec3(0.15, 0.2, 0.25);\nconst vec3  SEA_WATER_COLOR \t\t\t= vec3(0.15, 0.15, 0.15);\nconst vec3  SEA_ORI\t\t\t\t\t\t= vec3(0.0, 2.5, 0.0);\t\t\nconst float SEA_HEIGHT    \t\t\t\t= 1.25;\nconst float SEA_SPEED     \t\t\t\t= 1.0;\nconst float SEA_FREQ      \t\t\t\t= 0.15;\nconst float SEA_GEOMETRY_FREQ_MUL\t\t= 1.9;\nconst float SEA_GEOMETRY_AMPLITUDE_MUL \t= 0.22;\nconst float SEA_FREQ_MUL  \t\t\t\t= 2.0;\nconst float SEA_AMPLITUDE_MUL \t\t\t= 0.22;\nconst float SEA_REFRACTION_MUL_VALUE\t= 0.12;\nconst float SEA_ATTENUATION             = 0.001;\nconst float SEA_ATTENUATION_MUL_FACTOR  = 0.18;\nconst float SEA_CHOPPY    \t\t\t\t= 5.9;\nconst float SEA_CHOPPY_MIX_VALUE\t\t= 1.0;\nconst float SEA_CHOPPY_MIX_FACTOR\t\t= 0.2;\n\nconst int HEIGHTMAP_NUM_STEPS     \t\t= 20;\n\nconst float SEA_DIR_Z_SCALE \t\t\t= 0.1;\n\n//.................................................\n// \t\t  \t\t   PBR properties\n//.................................................\n#define FRESNEL_DEFAULT_FORMULA\t\t\t0\n#define FRESNEL_SCHLICK_FORMULA\t\t\t1\n\n#define FRESNEL_FORMULA\t\t\t\t\tFRESNEL_DEFAULT_FORMULA\n\n//.................................................\n//\t\t\t\t    Materials\n//.................................................\n\n//.................................................\n//\t\t      \t   Sea Material\n//.................................................\nconst vec3  SEA_EMISSIVE_COLOR          = vec3(1.0, 1.0, 1.0);\nconst vec3  SEA_AMBIENT_COLOR\t\t\t= vec3(0.0, 0.65, 0.75);\n\nconst float SEA_EMISSIVE_CONTRIBUTION\t= 0.00;\nconst float SEA_AMBIENT_CONTRIBUTION\t= 0.30;\n\nconst float SEA_SPECULAR_FACTOR\t\t\t= 60.0;\nconst float SEA_FRESNEL_POW_FACTOR\t\t= 3.0;\nconst float SEA_DIFFUSE_POW_FACTOR\t\t= 60.0;\n\n#if FRESNEL_FORMULA == FRESNEL_SCHLICK_FORMULA\nconst float SEA_R0\t\t \t\t\t\t= 0.01;\nconst float SEA_SMOOTH_FACTOR \t\t\t= 0.10;\n#elif FRESNEL_FORMULA == FRESNEL_DEFAULT_FORMULA\nconst float SEA_SMOOTH_FACTOR \t\t\t= 0.65;\n#endif\n//.................................................\n\n//.................................................\n\n//.................................................\n\n#if RAINBOW_WATER\nconst float RAINBOW_WATER_SATURATION\t= 0.35;\nconst float RAINBOW_WATER_LIGHTNESS\t\t= 0.1; //0.2\nconst float RAINBOW_WATER_SPEED \t\t= 0.1;\n#endif\n\n#if FANTASY_WATER_PATH\nconst float UV_START_X\t\t\t\t\t= -5.0;\nconst float UV_END_X\t\t\t\t\t=  5.0;\n#endif\n\n//Color mixing\nconst float SMOOTH_MIX_Y\t\t\t\t= -0.5; \nconst float MIX_SEA_AND_SKY_FACTOR\t\t= 0.11;\n\nconst mat2 OCTAVE_MATRIX \t\t\t\t= mat2(1.6, 1.2, -1.2, 1.6);\n\n#if SIMULATE_MODE == SLOW_MOTION\nconst float SEA_SLOWMOTION_SPEED        = 0.5;\n#endif\n\nfloat gSeaCurrentTime\t\t\t\t\t= 0.0;\n\n\nvec3 saturation(const vec3 color)\n{\n    const vec3 W = vec3(0.3, 0.59, 0.11);\n    vec3 colorIntensity = vec3(dot(color * BRIGHTNESS, W));\n    return mix(colorIntensity, color * BRIGHTNESS, SATURATION);\n}\n\nvec3 desaturation(const vec3 color)\n{\n    vec3 grayscale = vec3(dot(vec3(0.3, 0.59, 0.11), color * BRIGHTNESS));\n    return vec3(mix(color * BRIGHTNESS, grayscale, DESATURATION));\n}\n\nvec3 sky(vec3 e) \n{\n    #if SKY_TYPE == SKY_GRADIENT_SKY_1\n    e.y = max(e.y, 0.0);\n    vec3 ret;\n    ret.r = pow(1.0 - e.y, SKY_RED_POW_FACTOR) * SKY_RED_MUL_FACTOR;\n    ret.g = 1.0 - e.y - SKY_GREEN_SUBTRACT;\n    ret.b = SKY_BLUE_AMOUNT;\n    return ret;\n    #elif SKY_TYPE == SKY_GRADIENT_SKY_2\n    return mix(SKY_COLOR_1, SKY_COLOR_2, e.y);\n    #elif SKY_TYPE == SKY_SOLID_COLOR\n    return SKY_COLOR;\n    #endif\n\t\n    return vec3(0.0);\n}\n\nfloat seaOctave(vec2 uv, float choppy) \n{\t\n    #if WATER_TYPE == WAVES_WATER \n    uv += noise(uv);\n    vec2 wv = 1.0 - abs(sin(uv));   \n    wv = mix(wv, abs(cos(uv)), wv);\n    return pow(1.0 - pow(wv.x * wv.y, 0.65), choppy);\n    #elif WATER_TYPE == CALM_WATER\n    //Author: Angelo Logahd \n    //2019-06-29\n    float noise = noise(uv);\n    float x = cos(noise);\n    float y = sin(noise);\n    return pow(pow(abs(x * y), 0.65), choppy);\n    #endif\n}\n\nfloat seaGeometryMap(vec3 p) \n{\n    #if WATER_TYPE == WAVES_WATER\n    vec2 uv = p.xz * vec2(0.85, 1.0);\n\t\n    float freq \t = SEA_FREQ;\n    float amp \t = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    \n    float d = 0.0;\n    float h = 0.0;    \n    for (int i = 0; i < SEA_GEOMETRY_ITERATIONS; ++i) \n    {   \n\t\t#if FANTASY_WATER_PATH\n        if (uv.x > UV_START_X && uv.x < UV_END_X)\n\t   \t{\n\t\t\tcontinue;\n\t   \t}\n\t\t#endif\n\n    \td =  seaOctave((uv + SEA_CURRENT_TIME) * freq, choppy);\n    \td += seaOctave((uv - SEA_CURRENT_TIME) * freq, choppy);\n        h += d * amp; \n\t    \n\t\tfreq *= SEA_GEOMETRY_FREQ_MUL; \n\t\tamp  *= SEA_GEOMETRY_AMPLITUDE_MUL;\n\t    \n        choppy = mix(choppy, SEA_CHOPPY_MIX_VALUE, SEA_CHOPPY_MIX_FACTOR);\n\t    \n\t\tuv *= octaveMatrix; \n    }\n    return p.y - h;\n    #else\n    return p.y;\n    #endif\n}\n\nfloat seaFragmentMap(vec3 p) \n{\n    vec2 uv = p.xz * vec2(0.85, 1.0); \n    \n    float freq \t = SEA_FREQ;\n    float amp    = SEA_HEIGHT;  \n    float choppy = SEA_CHOPPY;\n\t\n    float d = 0.0;\n    float h = 0.0;    \n    for(int i = 0; i < SEA_FRAGMENT_ITERATIONS; ++i) \n    {\t    \n    \td =  seaOctave((uv + gSeaCurrentTime) * freq, choppy);\n\t\td += seaOctave((uv - gSeaCurrentTime) * freq, choppy); \n\t\th += d * amp;\n\t\n\t\tfreq *= SEA_FREQ_MUL; \n\t\tamp  *= SEA_AMPLITUDE_MUL;\n\t\n\t\tchoppy = mix(choppy, SEA_CHOPPY_MIX_VALUE, SEA_CHOPPY_MIX_FACTOR);\n\t\n\t\tuv *= OCTAVE_MATRIX;\n    }\n    return p.y - h;\n}\n\nvec3 diffuse(vec3 normal, vec3 light, float powFactor) \n{\n    float nDotl = dot(normal, light);\n    float diffuse = pow(max(nDotl, 0.0) * 0.4 + 0.6, powFactor);\n    return vec3(diffuse);\n}\n\nvec3 normal(vec3 p, vec3 dist) \n{\n    float eps = dot2(dist) * EPSILON_NRM;\n    vec3 n;\n    n.y = seaFragmentMap(p); \n    n = vec3(seaFragmentMap(vec3(p.x + eps, p.y, p.z)) - n.y,\n\t     \t seaFragmentMap(vec3(p.x, p.y, p.z + eps)) - n.y,\n\t     \t eps);\n    return normalize(n);\n}\n\nvec3 specular(vec3 eye, vec3 normal, vec3 light) \n{    \n    float nrm = (SEA_SPECULAR_FACTOR + 8.0) / (PI * 8.0);\n    float specular = pow(max(dot(reflect(eye, normal), light), 0.0), SEA_SPECULAR_FACTOR) * nrm;\n    return vec3(specular);\n}\n\n#if FRESNEL_FORMULA == FRESNEL_SCHLICK_FORMULA\nfloat schlick(const in vec3 vHalf, const in vec3 eye)\n{\n    float fDot = dot(vHalf, -eye);\n    fDot = saturate(1.0 - fDot);\n    float fDotPow = pow(fDot, SEA_FRESNEL_POW_FACTOR);\n    return SEA_R0 + (1.0 - SEA_R0) * fDotPow * SEA_SMOOTH_FACTOR;\n}\n\nfloat fresnel(const in vec3 normal, const in vec3 eye, const in vec3 diffuse, const in vec3 specular)\n{\n    vec3 vReflect = reflect(eye, normal);\n    vec3 vHalf = normalize(vReflect + -eye);\n    float fresnel = schlick(vHalf, eye);\n    return mix(diffuse, specular, fresnel).x;\n}\n#else\nfloat fresnel(const in vec3 normal, const in vec3 eye) \n{  \n    float fresnel = 1.0 - max(dot(normal, -eye), 0.0);\n    fresnel = pow(fresnel, SEA_FRESNEL_POW_FACTOR) * SEA_SMOOTH_FACTOR;\n    return fresnel;\n}\n#endif\n\nvec3 sea(const in vec3 p, const in vec3 lightDir, const in vec3 eye) \n{\n    vec3 dist     = p - SEA_ORI;  \n    vec3 normal   = normal(p, dist);\n    vec3 diffuse  = diffuse(normal, lightDir, SEA_DIFFUSE_POW_FACTOR);\n    vec3 emissive = SEA_EMISSIVE_COLOR * SEA_EMISSIVE_CONTRIBUTION;\n    vec3 ambient  = SEA_AMBIENT_COLOR * SEA_AMBIENT_CONTRIBUTION;\n    vec3 specular = specular(normal, lightDir, -eye);\n\t\n    #if FRESNEL_FORMULA == FRESNEL_DEFAULT_FORMULA\n    float fresnel = fresnel(normal, eye);\n    #elif FRESNEL_FORMULA == FRESNEL_SCHLICK_FORMULA\n    float fresnel = fresnel(normal, eye, diffuse, specular);\n    #endif\n    \n    vec3 reflected = sky(reflect(eye, normal));    \n    vec3 refracted = SEA_BASE_COLOR + diffuse * SEA_WATER_COLOR * SEA_REFRACTION_MUL_VALUE;\n    \n    vec3 color = mix(refracted, reflected, fresnel);\n    \n    float atten = max(0.0, 1.0 - dot2(dist) * SEA_ATTENUATION) * SEA_ATTENUATION_MUL_FACTOR;\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * atten;\n\n    #if TEXTURED_GROUND\n    vec2 uv = p.xz;\n    vec3 texRGB = textureLod(iChannel0, uv * 0.25, 0.0).rgb;\n    color += texRGB * 0.12;\n    #endif\n    \n    ambient *= color;\n    \n    color = color + emissive + ambient + specular;\n    \n    #if SUN_LIGHT\n    vec3 sunDiffuseColor = max(dot(SEA_SUN_DIRECTION, normal), 0.0) * SEA_SUN_COLOR * SEA_SUN_DIFFUSE;\n    vec3 reflection = normalize(reflect(-SEA_SUN_DIRECTION, normal));\n    float direction = max(0.0, dot(eye, reflection));\n    vec3 sunSpecular = direction * SEA_SUN_COLOR * SEA_SUN_SPECULAR;\n    color = color + sunDiffuseColor + sunSpecular;\n    #endif\n    \n    #if RAINBOW_WATER\n    color += hsv((p.z * 0.3) - iTime * RAINBOW_WATER_SPEED, RAINBOW_WATER_SATURATION, RAINBOW_WATER_LIGHTNESS);\n    #endif\n    \n    return color;\n}\n\nvec3 seaHeightMap(vec3 dir) \n{\n    vec3 p = vec3(0.0);\n    float x = 1000.0;\n\t\n    if (seaGeometryMap(SEA_ORI + dir * x) > 0.0)\n    {\n\t\treturn p;\n    }\n    \n    float mid = 0.0;\n    float m = 0.0;\n    float heightMiddle = 0.0;\n    for(int i = 0; i < HEIGHTMAP_NUM_STEPS; ++i) \n    {\t    \n\t\tmid = mix(m, x, 0.5); \n        p = SEA_ORI + dir * mid;\n    \theightMiddle = seaGeometryMap(p);\n\t\tif (heightMiddle < 0.0) \n\t\t{\n            x = mid;\n        } \n\t\telse \n\t\t{\n            m = mid;\n        }\n    }\n\t\n    return p;\n}\n\nvec3 fog(vec3 sceneColor, float dist)\n{\n    vec3 fragRGB = sceneColor;\n    float distanceF = (FOG_END - dist) / (FOG_END - FOG_START);\n    float fogAmount = saturate(1.0 - exp(-distanceF * FOG_DENSITY));\n    return mix(fragRGB, FOG_COLOR, fogAmount);\n}\n\n#if FOGMAP\nfloat fogNoise(in vec3 p)\n{\n    float z = 2.1;\n    p += tri3(p);\n    return tri(p.z + tri(p.x + tri(p.y))) / z;\n}\n\nfloat fogmap(in vec3 p, in float d)\n{\n    p += iTime * FOGMAP_VELOCITY * FOGMAP_DIR;\n    return saturate(fogNoise(p * 0.1) * fogNoise(p * 0.1) * 0.5);\n}\n#endif\n\n#if RAIN\nfloat rainHash(float x)\n{\n    vec2 p = fract(vec2(x) * vec2(0.16632, 0.17369));\n    p += dot(p.xy, p.yx + 19.19);\n    return fract(p.x * p.y);\n}\n\nfloat rainNoise(in vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = _smoothstep(x);\n    float n = p.x + p.y * 57.0;\n    return mix(mix(rainHash(n +  0.0), rainHash(n +  1.0), f.x),\n               mix(rainHash(n + 57.0), rainHash(n + 58.0), f.x), f.y);\n}\n\nfloat rain(vec2 uv, vec2 xy)\n{\t\n    float travelTime = (iTime * 0.7) + 0.1;\n\t\n    float x1 = (0.5 + xy.x + 1.0) * 0.3;\n    float y1 = 0.01;\n    float x2 = travelTime * 0.5 + xy.x * 0.2;\n    float y2 = travelTime * 0.2;\n\t\n    vec2 st = uv * vec2(x1, y1) + vec2(x2, y2);\n    \n    float rain = 0.1;\n    float f = rainNoise(st * 200.5) * rainNoise(st * 125.5);  \n    f = clamp(pow(abs(f), 20.0) * 1.5 * (rain * rain * 125.0), 0.0, 0.1);\n    return f;\n}\n#endif\n\n#if RAINBOW\nvec3 rainbowColor(in vec3 ray_dir) \n{ \n    RAINBOW_DIR = normalize(RAINBOW_DIR);   \n\t\t\n    float theta = degrees(acos(dot(RAINBOW_DIR, ray_dir)));\n    vec3 nd \t= saturate(1.0 - abs((RAINBOW_COLOR_RANGE - theta) * 0.2));\n    vec3 color  = _smoothstep(nd) * RAINBOW_INTENSITY;\n    \n    return color * max((RAINBOW_BRIGHTNESS - 0.75) * 1.5, 0.0);\n}\n\nvec3 rainbow(vec2 fragCoord)\n{\n     vec2 uv = fragCoord.xy / iResolution.xy;\n     vec2 p = (-1.0 + 2.0 * uv) * vec2(iResolution.x / iResolution.y, 1.0);\n\n     vec3 color = vec3(0.0);\n     if (p.y >= RAINBOW_START_Y)\n     {\n         vec3 rainbowW   \t  = -normalize(-RAINBOW_POS);\n    \t vec3 rainbowUp  \t  = normalize(cross(rainbowW, vec3(0.0, 1.0, 0.0)));\n    \t vec3 rainbowVertical = normalize(cross(rainbowUp, rainbowW));\n\n     \t vec3 dir = normalize(vec3(p, 0.0) - vec3(0.0, 0.0, -1.5));\n     \t vec3 wdDir = normalize(dir.x * rainbowUp + dir.y * rainbowVertical - dir.z * rainbowW);\n\t     \n         color += rainbowColor(wdDir);\n     }\t\n     return saturate(color);  \n}\n#endif\n\n//.......................................................................................\n//\t\t\t\t\tNight weathers\n//.......................................................................................\n#if STAR_SKY\nfloat starHash(float n) \n{\n    return fract((1.0 + cos(n)) * 15.92653) * 1.8;\n}\n\nvec3 star(in vec2 uv) \n{\n    vec2 p = uv * 0.02; //Multiply with some small value to avoid flickering\n    if (p.y > 0.001)\n    {\n\t\tfloat starValue = fract(starHash(p.x * 37.0) + starHash(p.y * 80.0));\n\t\tif (starValue > STAR_THRESHOLD) \n\t\t{\n\t   \t \tvec3 starColor = vec3(pow((starValue - STAR_THRESHOLD) / 0.02, 25.0));\n\t    \treturn starColor * 0.3;\n\t\t}  \n    }\n    return vec3(0.0);\n}\n#endif\n//.......................................................................................\n\n#if MOON\nvec3 moon(vec2 uv)\n{\n    float moonlight = MOON_FOG_LIGHT_STRENGTH + (MOON_LIGHT_STRENGTH / distance(uv, MOON_F)) * MOON_SCALE;\n    vec3 color = (MOON_BASE_COLOR + MOON_COLOR_GRADING) * moonlight;\n    return color;\n}\n#endif\n\n#if SUN\nvec3 sun(vec2 uv)\n{\n    float sunlight = 0.04 + (0.01 / distance(uv, vec2(0.0, 0.0))) * 5.0;\n    vec3 color = (vec3(1.0, 1.0, 1.0)) * sunlight;\n    return color;\n}\n#endif\n\n#if HDR\n#if TONEMAP_TYPE == FILMIC_TONEMAP_UNCHARTED2\nvec3 Uncharted2Tonemap(vec3 x)\n{\n   return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;\n}\n#elif TONEMAP_TYPE == FILMIC_TONEMAP_ACES\nvec3 TonemapACESFilm(vec3 x)\n{\n    return saturate((x * (A * x + B)) / (x * (C * x + D) + E));\n}\n#elif TONEMAP_TYPE == FILMIC_HEJL2015\n// https://twitter.com/jimhejl/status/633777619998130176\nvec3 TonemapFilmic_Hejl2015(vec3 hdr) \n{\n    vec4 vh = vec4(hdr, TONEMAP_WHITE_POINT);\n    vec4 va = 1.425 * vh + 0.05;\n    vec4 vf = (vh * va + 0.004) / (vh * (va + 0.55) + 0.0491) - 0.0821;\n    return vf.rgb / vf.www;\n}\n#elif TONEMAP_TYPE == FILMIC_TONEMAP_ALU\nvec3 TonemapFilmicALU(vec3 x)\n{\n    vec3 c = max(vec3(0.0), x - 0.004);\n    return (c * (c * 6.2 + 0.5)) / (c * (c * 6.2 + 1.7) + 0.06);\n}\n#endif\n\n#define LINEAR_TO_SRGB_ALPHA \t  \t\t0.055\n#define LINEAR_TO_SRG_LOWER_MUL_FACTOR\t12.92\n#define LINEAR_TO_SRGB_CONDITION  \t\t0.0031308\n// https://en.wikipedia.org/wiki/SRGB\nvec3 linearTo_sRGB(vec3 linearColor) \n{\n    vec3 sRGB_Higher = (1.0 + LINEAR_TO_SRGB_ALPHA) * pow(linearColor, vec3(1.0 / GAMMA)) - vec3(LINEAR_TO_SRGB_ALPHA);\n    return vec3(linearColor.r > LINEAR_TO_SRGB_CONDITION ? sRGB_Higher.r : LINEAR_TO_SRG_LOWER_MUL_FACTOR * linearColor.r,\n        \t\tlinearColor.g > LINEAR_TO_SRGB_CONDITION ? sRGB_Higher.g : LINEAR_TO_SRG_LOWER_MUL_FACTOR * linearColor.g,\n        \t\tlinearColor.b > LINEAR_TO_SRGB_CONDITION ? sRGB_Higher.b : LINEAR_TO_SRG_LOWER_MUL_FACTOR * linearColor.b);\n}\n\nvoid tonemap(inout vec3 color)\n{\n    #if TONEMAP_TYPE == LINEAR_TONEMAP\n    color *= vec3(TONEMAP_EXPOSURE);\n    #endif\n    #if TONEMAP_TYPE == EXPONENTIAL_TONEMAP\n    color = 1.0 - exp2(-color * TONEMAP_EXPOSURE);\n    #endif\n    #if TONEMAP_TYPE == REINHARD_TONEMAP\n    color *= TONEMAP_EXPOSURE;\n    color = color / (1.0 + color);\n    #endif\n    #if TONEMAP_TYPE == REINHARD2_TONEMAP\n    color *= TONEMAP_EXPOSURE;\n    color = (color * (1.0 + color / (LDR_WHITE * LDR_WHITE))) / (1.0 + color);\n    #endif\n    #if TONEMAP_TYPE == FILMIC_HEJL2015\n    color *= TONEMAP_EXPOSURE;\n    color = linearTo_sRGB(TonemapFilmic_Hejl2015(TONEMAP_EXPOSURE_BIAS * color));\n    #endif\n    #if TONEMAP_TYPE == FILMIC_TONEMAP_UNCHARTED2    \n    color *= TONEMAP_EXPOSURE;\n    vec3 tonemapedColor = Uncharted2Tonemap(TONEMAP_EXPOSURE_BIAS * color);\n    vec3 whiteScale = 1.0 / Uncharted2Tonemap(vec3(W));\n    color = tonemapedColor * whiteScale;\n    #endif\n    #if TONEMAP_TYPE == FILMIC_TONEMAP_ACES\n    color *= TONEMAP_EXPOSURE;\n    vec3 tonemapedColor = TonemapACESFilm(TONEMAP_EXPOSURE_BIAS * color);\n    vec3 whiteScale = 1.0 / TonemapACESFilm(vec3(W));\n    color = tonemapedColor * whiteScale;\n    #endif\n    #if TONEMAP_TYPE == FILMIC_TONEMAP_ALU\n    color *= TONEMAP_EXPOSURE;\n    color = TonemapFilmicALU(color);\n    #endif\n}\n#endif\n\nvoid postProcess(in vec2 uv, inout vec3 color)\n{\n    #if APPLY_LUMINANCE\t\n    float luminance = getFragLuminance(color);\n    luminance = saturate(luminance);\n    vec3 resLuminance = vec3(length(color.r * luminance), \n\t\t\t     length(color.g * luminance), \n\t\t\t     length(color.b * luminance));\n\t\n    float bloomIntensity = 1.0 / (1.0 - BLOOM_CUTOFF);\n    color = resLuminance * bloomIntensity;\n    #endif\n\t\n    #if COLOR_GRADING_FILTER\n\n    vec4 filteredFinal = COLOR_GRADING_G * COLOR_GRADING_WEIGHT * vec4(COLOR_GRADING_COLOR, 1.0);\n    vec4 realFinal = vec4(color, 1.0) * COLOR_GRADING_REAL_WEIGHT;\n\n    color = color * CONTRAST + 0.5 - CONTRAST * 0.5;\n\t\n    #if   COLOR_GRADING_BLEND_MODE == ADD\n    color = vec3(realFinal) + vec3(filteredFinal);\n    #elif COLOR_GRADING_BLEND_MODE == SUBTRACT\n    color = vec3(realFinal) - vec3(filteredFinal);\n    #elif COLOR_GRADING_BLEND_MODE == MULTIPLY\n    color = vec3(realFinal) * vec3(filteredFinal);\n    #elif COLOR_GRADING_BLEND_MODE == DIVIDE\n    color = vec3(realFinal) / vec3(filteredFinal);\n    #endif\n\t\n    #endif\n\t\n    color = saturation(color);\n    color = desaturation(color);\n\n    #if SEPIA_FILTER\n    float greyScale = GetFragLuminance(color);\n    color = greyScale * SEPIA_COLOR * SEPIA_INTENSITY;\n    #endif\n\t\n    #if VIGNETTE_FILTER\n    color *= vec3(VIGNETTE_COLOR) * saturate(1.0 - length(uv / VIGNETTE_ZOOM)) * VIGNETTE_EXPOSURE;\n    #endif\n\n    #if HDR && APPLY_TONEMAP\n    tonemap(color);\n    #endif\n    \n    #if TONEMAP_TYPE != FILMIC_TONEMAP_ALU\n    #if HDR && APPLY_GAMMA_CORRECTION && TONEMAP_TYPE != FILMIC_HEJL2015\n    color = pow(color, vec3(1.0 / GAMMA));\n    #elif APPLY_GAMMA_CORRECTION\n    color = pow(color, vec3(1.0 / GAMMA));\n    #endif\n    #endif\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{  \n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\t\n    vec2 xy = fragCoord.xy / iResolution.xy;\n    \n    float intensity = INTENSITY;\n    #if DAY_AND_NIGHT\n    intensity *= clamp(sin(time * DAY_AND_NIGHT_TIME) + DAY_AND_NIGHT_MIN_BRIGHTNESS, \n\t\t\t   \t\t   DAY_AND_NIGHT_MIN_BRIGHTNESS, \n\t\t\t   \t\t   DAY_AND_NIGHT_MAX_BRIGHTNESS);\n    #endif\n\t\n    EPSILON_NRM = 0.5 / iResolution.x;\n\t\n    #if SIMULATE_MODE == SIMULATE\n\tgSeaCurrentTime = iTime * SEA_SPEED;\n    #elif SIMULATE_MODE == SIMULATE2x\n\tgSeaCurrentTime = iTime * SEA_SPEED * 2.0;\n    #elif SIMULATE_MODE == SIMULATE3x\n\tgSeaCurrentTime = iTime * SEA_SPEED * 3.0;\n    #elif SIMULATE_MODE == SIMULATE4x\n\tgSeaCurrentTime = iTime * SEA_SPEED * 4.0;\n    #elif SIMULATE_MODE == SIMULATE5x\n\tgSeaCurrentTime = iTime * SEA_SPEED * 4.0;\n    #elif SIMULATE_MODE == PAUSED\n\tgSeaCurrentTime = 0.0;\n    #elif SIMULATE_MODE == SLOW_MOTION\n\tgSeaCurrentTime = iTime * SEA_SLOWMOTION_SPEED;\n    #endif\n \n    #if FLIP_WATER_AND_SKY\n    vec3 dir = normalize(vec3(-uv.xy, -1.0));\n    #else\n    vec3 dir = normalize(vec3(uv.xy, -1.0));\n    #endif\n    dir.z += length(uv) * SEA_DIR_Z_SCALE;\n    dir = normalize(dir);\n\t\n    vec3 p = seaHeightMap(dir);\n    vec3 lightDir = vec3(0.0);\n    \n    float smothMixFactor = pow(smoothstep(0.0, SMOOTH_MIX_Y, dir.y), MIX_SEA_AND_SKY_FACTOR);\n    \n    vec3 sky = sky(dir);\n    vec3 sea = sea(p, lightDir, dir);\n    \n    vec3 color = mix(sky, sea, smothMixFactor); \n    \n    #if FOG_MODE != NEVER_FOG\n    color = fog(color, dir.z);\n    #endif\n\t\n    #if FOGMAP\n    color += fogmap(p, p.z) * FOGMAP_INTENSITY;\n    #endif\n    \n    #if RAIN\n    vec3 rainColor = RAIN_BASE_COLOR * RAIN_COLOR_INTENSITY;\n    float rainFactor = rain(uv, xy);\n    color = mix(color, rainColor, rainFactor);\n    #endif\n    \n    #if COLOR_GRADING_FILTER\n    color = color * intensity + COLOR_GRADING_COLOR2;\n    #else\n    color = color * intensity;\n    #endif\n\t\n    #if STAR_SKY\n    color += star(uv);\n    #endif\n    \n    #if RAINBOW\n    color += rainbow(fragCoord);\n    #endif\n\n    #if MOON\n    color += moon(uv);\n    #endif\n    \n    #if SUN\n    color += sun(uv);\n    #endif\n\n    #if !HDR\n    color = saturate(color);\n    #endif\n\n    postProcess(uv, color);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI\t \t\t\t\t= 3.1415;\nfloat EPSILON_NRM\t\t\t\t= 0.001;\n\n#define true  \t\t\t\t\t1\n#define false \t\t\t\t\t0\n\n#define saturate(x)\t\t\t\tclamp(x, 0.0, 1.0)\n#define mul3x(x) \t\t\t\tx * x * x\n#define dot2(x)\t\t\t\t\tdot(x, x)\n\n\nfloat rand(float n)\n{\n    return fract(sin(n) * 43758.5453123);\n}\n\nfloat hash(vec2 p)\n{\t\n    return rand(dot(p, vec2(12.9898, 78.233)));\n}\n\nvec2 _smoothstep(in vec2 f)\n{\n    return f * f * (3.0 - 2.0 * f);\n}\n\nvec3 _smoothstep(in vec3 p)\n{\n     return p * p * 3.0 - 2.0 * mul3x(p);\n}\n\nfloat tri(in float x)\n{\n    return abs(fract(x) - 0.5);\n}\n\nvec3 tri3(in vec3 p)\n{\n    return vec3(tri(p.x), tri(p.y), tri(p.z));\n}\n\nfloat noise(in vec2 p) \n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 sp = _smoothstep(f);\n    return -1.0 + 2.0 * mix(mix(hash(i + vec2(0.0, 0.0)), \n                                hash(i + vec2(1.0, 0.0)), sp.x),\n                            mix(hash(i + vec2(0.0, 1.0)), \n                                hash(i + vec2(1.0, 1.0)), sp.x), sp.y);\n}\n\nfloat getFragLuminance(vec3 fragColor)\n{\n    return dot(fragColor, vec3(0.3, 0.59, 0.11));\n}\n\nvec3 hsv(float hue, float saturation, float value)\n{\n    vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(hue) + t.xyz) * 6.0 - vec3(t.w));\n    return value * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), saturation);\n}\n","name":"Common","description":"","type":"common"}]}