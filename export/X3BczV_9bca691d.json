{"ver":"0.1","info":{"id":"X3BczV","date":"1727434066","viewed":28,"name":"Taxicabogon Failed Successfully","username":"floopfloop","description":"Fork of TheTurk's https://www.shadertoy.com/view/stjSRd to conveniently see out how my taxicab experiment is failing in 3d. \n\nnow succeeding\n\nbut why\n\nnow we know","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","taxicab","octagon","linfinity","linf","maximumnorm"],"hasliked":0,"parentid":"stjSRd","parentname":"Raymarching Max Norm Primitives"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// thanks to spalmer for reminding me that i live in three dimensions\n// set this to 1. to see the original issue\n#define DISTANCE_FUDGE inversesqrt(3.)\n\nconst float pi = 3.1415927;\n\nfloat plane(vec3 position, vec3 planeNormal, float planeDistance) {\n    float d = dot(position, planeNormal) + planeDistance;\n    return d / dot(planeNormal, sign(planeNormal));\n}\n\nfloat taxibox(vec3 position, vec3 halfSize) {\n    position = abs(position) - halfSize;\n    return max(max(position.x, position.y), position.z);\n}\n\n// quite literally just the taxicab norm, which should give a diamond shape\nfloat taxidiamondsphere(vec3 position, float radius) {\n    position = abs(position);\n    return position.x + position.y + position.z - radius;\n}\n\n// intersection of a box and a diamondsphere gives a 3d octago-what\nfloat taxirhombicuboctahedronodon(vec3 position, float radius) {\n    const float K = sqrt(2.);\n    // Accounts for rounding errors :)\n    const float FUDGE = 0.5;\n    position = abs(position);\n    return max(\n        // taxicab diamondsphere\n        position.x + position.y + position.z, \n        // taxicab cube\n        max(max(position.x, position.y), position.z) * K\n    ) - radius * cos(radians(22.5+FUDGE)) * K;\n}\n\nfloat taxisphere(vec3 position, float radius) {\n    position = abs(position);\n    float d = max(max(position.x - radius, position.y), position.z);\n    d = min(d, max(max(position.x, position.y - radius), position.z));\n    d = min(d, max(max(position.x, position.y), position.z - radius));\n    {\n        float b = dot(vec2(1.0), position.yz);\n        float c = dot(position.yz, position.yz) - (radius * radius);\n        float discriminant = b * b - 2.0 * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / 2.0;\n            d = min(d, max(t, position.x));\n        }\n    }\n    {\n        float b = dot(vec2(1.0), position.xz);\n        float c = dot(position.xz, position.xz) - (radius * radius);\n        float discriminant = b * b - 2.0 * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / 2.0;\n            d = min(d, max(t, position.y));\n       }\n    }\n    {\n        float b = dot(vec2(1.0), position.xy);\n        float c = dot(position.xy, position.xy) - (radius * radius);\n        float discriminant = b * b - 2.0 * c;\n        if (discriminant >= 0.0) {\n            float t = (b - sqrt(discriminant)) / 2.0;\n            d = min(d, max(t, position.z));\n        }\n    }\n    float b = dot(vec3(1.0), position);\n    float c = dot(position, position) - (radius * radius);\n    float discriminant = b * b - 3.0 * c;\n    if (discriminant >= 0.0) {\n        float t = (b - sqrt(discriminant)) / 3.0;\n        d = min(d, t);\n    }\n    \n    return d;\n}\n\nmat3 rotationAxisAngle(vec3 axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    vec3 column1 = axis * axis.x * (1.0 - c) + vec3(c, axis.z * s, -axis.y * s);\n    vec3 column2 = axis * axis.y * (1.0 - c) + vec3(-axis.z * s, c, axis.x * s);\n    vec3 column3 = axis * axis.z * (1.0 - c) + vec3(axis.y * s, -axis.x * s, c);\n    return mat3(column1, column2, column3);\n}\n\nvec4 sdf(vec3 position) {\n    float material = 0.0;\n    float d = plane(position, vec3(0.0, 1.0, 0.0), 0.0);\n    \n    if (sin(iTime) > 0.) {\n        float d1 = taxisphere(position - vec3(0.0, 0.5, 0.0), 0.5);\n        if (d1 < d) {\n            material = 1.0;\n            d = d1;\n        }\n    }\n    \n    float d3 = taxibox(position - vec3(-1.0, 0.5, 0.0), vec3(0.5, 0.5, 0.5));\n    if (d3 < d) {\n        material = 3.0;\n        d = d3;\n    }\n    \n    float d4 = taxidiamondsphere(position - vec3(1.0, 0.5,  0.0), 0.5);\n    if (d4 < d) {\n        material = 4.0;\n        d = d4;\n    }\n    \n    float d5 = taxirhombicuboctahedronodon(position - vec3(0.0, 0.5,  0.0), 0.5);\n    if (d5 < d) {\n        material = 2.0;\n        d = d5;\n    }\n   \n    return vec4(d * DISTANCE_FUDGE, material, 0.0, 0.0);\n}\n\nvec3 normal(vec3 position) {\n    float epsilon = 0.001;\n    vec3 gradient = vec3(\n        sdf(position + vec3(epsilon, 0, 0)).x - sdf(position + vec3(-epsilon, 0, 0)).x,\n        sdf(position + vec3(0, epsilon, 0)).x - sdf(position + vec3(0, -epsilon, 0)).x,\n        sdf(position + vec3(0, 0, epsilon)).x - sdf(position + vec3(0, 0, -epsilon).x)\n    );\n    return normalize(gradient);\n}\n\nfloat testVisibility(vec3 rayOrigin, vec3 rayDirection, float threshold) {\n    int stepCount = 256;\n    float t = 0.0;\n    float maximumDistance = 10.0;\n    for (int i = 0; i < stepCount; i++) {\n        if (t > maximumDistance) {\n            break;\n        }\n        vec3 currentPosition = rayOrigin + rayDirection * t;\n        float d = sdf(currentPosition).x;\n        if (d < threshold) {\n            return 0.0;\n        }\n        t += d + threshold;\n    }\n    return 1.0;\n}\n\nvec4 raycast(vec3 rayOrigin, vec3 rayDirection) {\n    vec4 hitResult = vec4(0.0, 0.0, 0.0, 0.0);\n    int stepCount = 256;\n    float maximumDistance = 100.0;\n    float t = 0.0;\n    for (int i = 0; i < stepCount; i++) {\n        if (t > maximumDistance) {\n            break;\n        }\n        vec3 currentPosition = rayOrigin + rayDirection * t;\n        vec4 result = sdf(currentPosition);\n        if (result.x < 0.001 * max(t, 1.0)) {\n            hitResult = vec4(t, result.y, 0.0, 0.0);\n            break;\n        }\n        t += result.x;\n    }\n   \n    return hitResult;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float mouseSensitivity = 0.01;\n    vec2 delta = iMouse.xy - abs(iMouse.zw);\n    \n    float yaw = iMouse.z <= 0.0 ? ((iTime - 10.0) * 0.5) : delta.x * mouseSensitivity;\n    float pitch = iMouse.z <= 0.0 ? 0.05 : clamp(-delta.y * mouseSensitivity, -0.18, pi*0.5);\n    \n    mat3 orbitRotation = rotationAxisAngle(vec3(0.0, 1.0, 0.0), yaw);\n    orbitRotation *= rotationAxisAngle(vec3(1.0, 0.0, 0.0), pitch);\n\tvec3 cameraPosition = vec3(0.0, 0.5, 0.0) + orbitRotation * vec3(0.0, 0.0, -2.5);\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 rayDirection = orbitRotation * normalize(vec3(uv, 2.5));\n    vec3 color = mix(vec3(1.0), vec3(0.25, 0.5, 1.0) * 1.2, 2.0 * rayDirection.y + 0.6);\n    vec4 hitResult = raycast(cameraPosition, rayDirection);\n    float t = hitResult.x;\n    float material = hitResult.y;\n    if (t > 0.0) {\n        vec3 position = cameraPosition + rayDirection * t;\n        vec3 n = normal(position);\n        vec3 lightDirection = normalize(vec3(-0.5, 0.8, -0.2));\n        float visibility = testVisibility(position + n * 0.005, lightDirection, 0.001);\n        vec3 baseColor;\n        if (material == 0.0) {\n            float checkerboard = mod(floor(2.0 * position.z) + floor(2.0 * position.x), 2.0);\n            baseColor = vec3(0.2 + 0.1 * checkerboard);\n        } else {\n            baseColor = 0.2 + 0.2 * cos(2.0 * pi * (vec3(1.0, 1.0, 1.0) * (material / 6.0) + vec3(0.0, 1.0 / 3.0, 2.0 / 3.0)));\n        }\n        float lightAngle = max(dot(lightDirection, n), 0.0);\n        vec3 halfwayDirection = normalize(lightDirection + -rayDirection);\n        float halfwayAngle = max(dot(halfwayDirection, n), 0.0);        \n        // diffuse\n        color = 2.0 * vec3(1.0, 0.85, 0.55) * lightAngle * visibility * baseColor;\n        // specular\n\t\tcolor += 1.0 * vec3(1.0, 0.85, 0.55) * pow(halfwayAngle, 16.0) * lightAngle * visibility * baseColor;\n        // ambient\n        color += 0.5 * vec3(0.25, 0.5, 1.0) * ((n.y + 1.0) * 0.5) * baseColor; // sky\n        color += 0.5 * vec3(0.25, 0.25, 0.25) * clamp(dot(n, normalize(vec3(-lightDirection.x, 0.0, -lightDirection.z))), 0.0, 1.0) * clamp(1.0 - position.y, 0.0, 1.0) * baseColor; // back\n        // fog\n        color = mix(color, mix(vec3(1.0), vec3(0.25, 0.5, 1.0) * 1.2, 0.55), 1.0 - exp(-0.00005 * t * t * t));\n    }\n    // gamma\n    color = pow(color, vec3(1.0 / 2.2));\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}