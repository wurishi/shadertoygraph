{"ver":"0.1","info":{"id":"4ctczl","date":"1731056536","viewed":312,"name":"Holographic Radiance Cascades","username":"Suslik","description":"A new holographi RC algo!\n\nA 2D implementation of [url=https://drive.google.com/file/d/1L6v1_7HY2X-LV3Ofb6oyTIxgEaP4LOI6/view]\"Radiance Cascades: A Novel Approach to Calculating Global Illumination\"[/url]\n\nOriginal RC shader [url=/view/mtlBzX]by fad[/url]","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["mouse","interactive","global","illumination","light","tracing","keyboard","trace","path","radiance","cascade"],"hasliked":0,"parentid":"4ctXD8","parentname":"RC Experimental Testbed"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The OG shadertoy implementation of Radiance Cascades by fad: https://www.shadertoy.com/view/mtlBzX\n\nvec4 GatherFluencePerDirection(samplerCube atlas_sampler, vec2 screen_pos, int cascade_index, CascadeSize c0_size)\n{\n    ivec2 viewport_size = ivec2(iResolution.xy);\n    ivec2 face_size = textureSize(atlas_sampler, 0);\n    CascadeSize cascade_size = GetCascadeSize(cascade_index, c0_size);\n    \n    vec4 fluence = vec4(0.0f);\n    for(int dir_index = 0; dir_index < cascade_size.dirs_count; dir_index++)\n    {\n        //if(dir_index != 2) continue;\n        vec2 pixel_dir = GetProbeDir(float(dir_index), cascade_size.dirs_count);\n        vec2 screen_dir = pixel_dir / vec2(viewport_size);\n        int is_horizontal = IsDirHorizontal(float(dir_index), cascade_size.dirs_count);\n        InterpIntervalLocation interp_loc = GetInterpLocation(screen_pos, cascade_index, is_horizontal, screen_dir, c0_size);\n        vec3 radiance = InterpInterval(atlas_sampler, cascade_index, interp_loc.line_index, interp_loc.probe_indexf, dir_index, c0_size).rgb;\n\n        //radiance = vec3(interp_loc.probe_indexf) / 100.0f;\n        \n        //radiance = vec3(radiance.z) / 4.0f;\n\n        fluence += vec4(radiance, 1.0f);\n    }\n    fluence /= fluence.w;\n    return fluence;\n}\n\nvec4 GatherFluenceSlowly(samplerCube atlas_sampler, vec2 screen_pos, int cascade_index, CascadeSize c0_size, uint dir_steps_count)\n{\n    ivec2 viewport_size = ivec2(iResolution.xy);\n    ivec2 face_size = textureSize(atlas_sampler, 0);\n    CascadeSize cascade_size = GetCascadeSize(cascade_index, c0_size);\n\n    vec4 res = vec4(0.0f);\n    for(uint step_index = 0u; step_index < dir_steps_count; step_index++)\n    {\n//        float pos_ratio = (float(pos_step_index) + 0.5f) / float(pos_steps_count);\n        float dir_ratio = (float(step_index) + 0.5f) / float(dir_steps_count);\n        float dir_indexf = float(cascade_size.dirs_count) * dir_ratio;\n\n        vec2 pixel_dir = GetProbeDir(dir_indexf, cascade_size.dirs_count);\n        vec2 screen_dir = pixel_dir / vec2(viewport_size);\n\n\n        LinearSamples dir_samples = GetLinearSamples(dir_indexf);\n        vec2 weights = GetLinearWeights(dir_samples.ratio);\n        for(int offset = 0; offset < 2; offset++)\n        {\n            int dir_index = (dir_samples.base_index + offset + cascade_size.dirs_count) % cascade_size.dirs_count;\n            int is_horizontal = IsDirHorizontal(float(dir_index), cascade_size.dirs_count);\n            InterpIntervalLocation interp_loc = GetInterpLocation(screen_pos, cascade_index, is_horizontal, screen_dir, c0_size);\n            res += InterpInterval(atlas_sampler, cascade_index, interp_loc.line_index, interp_loc.probe_indexf, dir_index, c0_size) * weights[offset] / float(dir_steps_count);\n        }\n    }\n    return res;\n}\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n   \n    ivec2 viewport_size = ivec2(iResolution.xy);\n    \n    vec2 screen_pos = fragCoord.xy / vec2(viewport_size);\n    CascadeSize c0_size = GetC0Size(viewport_size);\n    int src_cascade_index = 0;\n    \n    vec4 fluence = 1.5f * GatherFluencePerDirection(iChannel0, screen_pos, src_cascade_index, c0_size);\n    //vec4 fluence = GatherFluenceSlowly(iChannel0, screen_pos, src_cascade_index, c0_size, 64u);\n    fragColor = vec4(1.0 - 1.0 / pow(1.0 + fluence.rgb, vec3(2.5)), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"// This buffer calculates and merges radiance cascades. Normally the\n// merging would happen within one frame (like a mipmap calculation),\n// meaning this technique actually has no termporal lag - but since\n// Shadertoy has no way of running a pass multiple times per frame, we \n// have to resort to spreading out the merging of cascades over multiple\n// frames.\n\n\n\nvec4 CastMergedInterval(IntervalLocation interval_loc)\n{\n    ivec2 viewport_size = textureSize(iChannel1, 0);\n    ivec2 face_size = textureSize(iChannel0, 0);\n    \n    CascadeSize c0_size = GetC0Size(viewport_size);\n    CascadeSize cascade_size = GetCascadeSize(interval_loc.cascade_index, c0_size);\n    int is_horizontal = IsDirHorizontal(float(interval_loc.dir_index), cascade_size.dirs_count);\n    vec2 screen_origin = GetIntervalScreenOrigin(float(interval_loc.probe_index), float(interval_loc.line_index), is_horizontal, interval_loc.cascade_index, c0_size);\n    \n    int prev_cascade_index = interval_loc.cascade_index + 1;\n    CascadeSize prev_cascade_size = GetCascadeSize(prev_cascade_index, c0_size);\n\n    vec4 merged_avg_interval = vec4(0.0f);\n    int avg_count = 1 << DIRS_COUNT_SCALE_POW2;\n    for(int dir_number = 0; dir_number < avg_count; dir_number++)\n    {\n        int prev_dir_index = interval_loc.dir_index * avg_count + dir_number;\n\n        vec2 pixel_dir = GetProbeDir(float(prev_dir_index), prev_cascade_size.dirs_count);\n        vec2 screen_dir = pixel_dir / vec2(viewport_size);\n\n        InterpIntervalLocation prev_interp_loc = GetInterpLocation(screen_origin, prev_cascade_index, is_horizontal, screen_dir, c0_size);\n        vec4 prev_interval = vec4(0.0f);\n        if(prev_cascade_index < nCascades)\n            prev_interval = InterpInterval(iChannel0, prev_cascade_index, prev_interp_loc.line_index, prev_interp_loc.probe_indexf, prev_dir_index, c0_size);\n\n        vec2 ray_start = screen_origin * vec2(viewport_size);\n        float ray_scale = (interval_loc.cascade_index + 1 == nCascades) ? 1000.0f : prev_interp_loc.ray_scale;\n        vec2 ray_end = screen_origin * vec2(viewport_size) + pixel_dir * ray_scale;\n\n        RayHit ray_hit = radiance(iChannel1, ray_start, normalize(ray_end - ray_start), length(ray_end - ray_start));\n        merged_avg_interval += MergeIntervals(ray_hit.radiance, prev_interval) / float(avg_count);\n    }\n    return merged_avg_interval;\n}\n\n//nobody knows why this part works\nfloat DirRatioToPosRatio(float dir_ratio, float ang_ratio)\n{\n    int quadrant = int(floor(ang_ratio * 4.0f));\n    return (quadrant == 0 || quadrant == 3) ? dir_ratio : (1.0f - dir_ratio);\n}\n\nvec4 CastMergedIntervalNumerical(IntervalLocation interval_loc)\n{\n    ivec2 viewport_size = textureSize(iChannel1, 0);\n    ivec2 face_size = textureSize(iChannel0, 0);\n    \n    CascadeSize c0_size = GetC0Size(viewport_size);\n    CascadeSize cascade_size = GetCascadeSize(interval_loc.cascade_index, c0_size);\n    int is_horizontal = IsDirHorizontal(float(interval_loc.dir_index), cascade_size.dirs_count);\n    \n    int prev_cascade_index = interval_loc.cascade_index + 1;\n    CascadeSize prev_cascade_size = GetCascadeSize(prev_cascade_index, c0_size);\n\n    vec4 merged_avg_interval = vec4(0.0f);\n    const uint dir_steps_count = 16u;\n    const uint pos_steps_count = 1u;\n    for(uint step_index = 0u; step_index < dir_steps_count * pos_steps_count; step_index++)\n    {\n//        float pos_ratio = (float(pos_step_index) + 0.5f) / float(pos_steps_count);\n        uint pos_step = step_index % pos_steps_count;\n        uint dir_step = step_index / pos_steps_count;\n        \n        \n        float pos_ratio = (float(pos_step) + 0.5f) / float(pos_steps_count);\n        float dir_ratio = (float(dir_step) + 0.5f) / float(dir_steps_count);\n\n        float dir_indexf = float(interval_loc.dir_index) - 0.5f + dir_ratio;\n        float ang_ratio = (dir_indexf + 0.5f) / float(cascade_size.dirs_count);\n        vec2 screen_origin = GetIntervalScreenOrigin(float(interval_loc.probe_index) - 0.5f + DirRatioToPosRatio(dir_ratio, ang_ratio), float(interval_loc.line_index), is_horizontal, interval_loc.cascade_index, c0_size);\n\n        float prev_dir_indexf = ang_ratio * float(prev_cascade_size.dirs_count) - 0.5f;\n\n        vec2 pixel_dir = GetProbeDir(prev_dir_indexf, prev_cascade_size.dirs_count);\n        vec2 screen_dir = pixel_dir / vec2(viewport_size);\n\n        vec4 prev_interval = vec4(0.0f);\n        if(prev_cascade_index < nCascades)\n        {\n            LinearSamples prev_dir_samples = GetLinearSamples(prev_dir_indexf);\n            vec2 prev_dir_weights = GetLinearWeights(prev_dir_samples.ratio);\n            for(int prev_dir_number = 0; prev_dir_number < 2; prev_dir_number++)\n            {\n                int prev_dir_index = (prev_dir_samples.base_index + prev_dir_number + prev_cascade_size.dirs_count) % prev_cascade_size.dirs_count;\n                int is_prev_horizontal = IsDirHorizontal(float(prev_dir_index), prev_cascade_size.dirs_count);\n                InterpIntervalLocation prev_interp_loc = GetInterpLocation(screen_origin, prev_cascade_index, is_prev_horizontal, screen_dir, c0_size);\n                prev_interval += InterpInterval(iChannel0, prev_cascade_index, prev_interp_loc.line_index, prev_interp_loc.probe_indexf, prev_dir_index, c0_size) * prev_dir_weights[prev_dir_number];\n            }\n        }\n        int is_prev_horizontal = IsDirHorizontal(prev_dir_indexf, prev_cascade_size.dirs_count);\n        InterpIntervalLocation prev_interp_loc = GetInterpLocation(screen_origin, prev_cascade_index, is_prev_horizontal, screen_dir, c0_size);\n\n        vec2 ray_start = screen_origin * vec2(viewport_size);\n        float ray_scale = (interval_loc.cascade_index + 1 == nCascades) ? 1000.0f : prev_interp_loc.ray_scale;\n        vec2 ray_end = screen_origin * vec2(viewport_size) + pixel_dir * ray_scale;\n\n        RayHit ray_hit = radiance(iChannel1, ray_start, normalize(ray_end - ray_start), length(ray_end - ray_start));\n        merged_avg_interval += MergeIntervals(ray_hit.radiance, prev_interval) / float(dir_steps_count * pos_steps_count);\n    }\n    return merged_avg_interval;\n}\n\n\nvec4 CastMergedIntervalExtended(IntervalLocation interval_loc)\n{\n    ivec2 viewport_size = textureSize(iChannel1, 0);\n    ivec2 face_size = textureSize(iChannel0, 0);\n    \n    CascadeSize c0_size = GetC0Size(viewport_size);\n    CascadeSize cascade_size = GetCascadeSize(interval_loc.cascade_index, c0_size);\n    int is_horizontal = IsDirHorizontal(float(interval_loc.dir_index), cascade_size.dirs_count);\n    \n    int prev_cascade_index = interval_loc.cascade_index + 1;\n    CascadeSize prev_cascade_size = GetCascadeSize(prev_cascade_index, c0_size);\n\n    vec2 line_screen_spacing = GetLineScreenSpacing(interval_loc.cascade_index, c0_size.lines_count);\n    vec2 probe_screen_spacing =  GetProbeScreenSpacing(interval_loc.cascade_index, c0_size.probes_count);\n\n\n    vec4 merged_avg_interval = vec4(0.0f);\n    const uint dir_steps_count = 64u;\n    const uint pos_steps_count = 1u;\n    for(uint step_index = 0u; step_index < dir_steps_count * pos_steps_count; step_index++)\n    {\n//        float pos_ratio = (float(pos_step_index) + 0.5f) / float(pos_steps_count);\n        uint pos_step = step_index % pos_steps_count;\n        uint dir_step = step_index / pos_steps_count;\n        \n        \n        float pos_ratio = (float(pos_step) + 0.5f) / float(pos_steps_count);\n        float dir_ratio = (float(dir_step) + 0.5f) / float(dir_steps_count);\n\n        vec2 screen_origin = GetIntervalScreenOrigin(float(interval_loc.probe_index)/* - 0.5f + (1.0f - dir_ratio)*/, float(interval_loc.line_index), is_horizontal, interval_loc.cascade_index, c0_size);\n\n        float dir_indexf = float(interval_loc.dir_index) - 0.5f + dir_ratio;\n        float ang_ratio = (dir_indexf + 0.5f) / float(cascade_size.dirs_count);\n        float prev_dir_indexf = ang_ratio * float(prev_cascade_size.dirs_count) - 0.5f;\n\n        vec2 pixel_dir = GetProbeDir(prev_dir_indexf, prev_cascade_size.dirs_count);\n        vec2 screen_dir = pixel_dir / vec2(viewport_size);\n\n        vec4 prev_interval = vec4(0.0f);\n        if(prev_cascade_index < nCascades)\n        {\n            LinearSamples prev_dir_samples = GetLinearSamples(prev_dir_indexf);\n            vec2 prev_dir_weights = GetLinearWeights(prev_dir_samples.ratio);\n            for(int prev_dir_number = 0; prev_dir_number < 2; prev_dir_number++)\n            {\n                int prev_dir_index = (prev_dir_samples.base_index + prev_dir_number + prev_cascade_size.dirs_count) % prev_cascade_size.dirs_count;\n                int is_prev_horizontal = IsDirHorizontal(float(prev_dir_index), prev_cascade_size.dirs_count);\n                InterpIntervalLocation prev_interp_loc = GetInterpLocation(screen_origin, prev_cascade_index, is_prev_horizontal, screen_dir, c0_size);\n                prev_interval += InterpInterval(iChannel0, prev_cascade_index, prev_interp_loc.line_index, prev_interp_loc.probe_indexf, prev_dir_index, c0_size) * prev_dir_weights[prev_dir_number];\n            }\n        }\n        int is_prev_horizontal = IsDirHorizontal(prev_dir_indexf, prev_cascade_size.dirs_count);\n        InterpIntervalLocation prev_interp_loc = GetInterpLocation(screen_origin, prev_cascade_index, is_prev_horizontal, screen_dir, c0_size);\n\n        int is_horizontal = IsDirHorizontal(dir_indexf, cascade_size.dirs_count);\n        float start_offset = GetBaseRaymarchDist(is_horizontal, screen_dir, line_screen_spacing);\n        \n        vec2 ray_start = screen_origin * vec2(viewport_size) + pixel_dir * start_offset;\n        float ray_scale = (interval_loc.cascade_index + 1 == nCascades) ? 1000.0f : prev_interp_loc.ray_scale;\n        vec2 ray_end = screen_origin * vec2(viewport_size) + pixel_dir * ray_scale;\n\n        RayHit ray_hit = radiance(iChannel1, ray_start, normalize(ray_end - ray_start), length(ray_end - ray_start));\n        merged_avg_interval += MergeIntervals(ray_hit.radiance, prev_interval) / float(dir_steps_count * pos_steps_count);\n    }\n    return merged_avg_interval;\n}\n\nvec4 CastMergedIntervalNumericalFast(IntervalLocation interval_loc)\n{\n    ivec2 viewport_size = textureSize(iChannel1, 0);\n    ivec2 face_size = textureSize(iChannel0, 0);\n    \n    CascadeSize c0_size = GetC0Size(viewport_size);\n    CascadeSize cascade_size = GetCascadeSize(interval_loc.cascade_index, c0_size);\n    int is_horizontal = IsDirHorizontal(float(interval_loc.dir_index), cascade_size.dirs_count);\n    vec2 screen_origin = GetIntervalScreenOrigin(float(interval_loc.probe_index), float(interval_loc.line_index), is_horizontal, interval_loc.cascade_index, c0_size);\n    \n    int prev_cascade_index = interval_loc.cascade_index + 1;\n    CascadeSize prev_cascade_size = GetCascadeSize(prev_cascade_index, c0_size);\n\n    vec4 prev_interval = vec4(0.0f);\n    int steps_count = 4;\n    for(int step_index = 0; step_index < steps_count; step_index++)\n    {\n        float ratio = (float(step_index) + 0.5f) / float(steps_count);\n        float dir_indexf = float(interval_loc.dir_index) - 0.5f + ratio;\n        float ang_ratio = (dir_indexf + 0.5f) / float(cascade_size.dirs_count);\n        float prev_dir_indexf = ang_ratio * float(prev_cascade_size.dirs_count) - 0.5f;\n        \n        vec2 pixel_dir = GetProbeDir(prev_dir_indexf, prev_cascade_size.dirs_count);\n        vec2 screen_dir = pixel_dir / vec2(viewport_size);\n\n        if(prev_cascade_index < nCascades)\n        {\n            LinearSamples prev_dir_samples = GetLinearSamples(prev_dir_indexf);\n            vec2 prev_dir_weights = GetLinearWeights(prev_dir_samples.ratio);\n            for(int prev_dir_number = 0; prev_dir_number < 2; prev_dir_number++)\n            {\n                int prev_dir_index = (prev_dir_samples.base_index + prev_dir_number + prev_cascade_size.dirs_count) % prev_cascade_size.dirs_count;\n                int is_prev_horizontal = IsDirHorizontal(float(prev_dir_index), prev_cascade_size.dirs_count);\n                InterpIntervalLocation prev_interp_loc = GetInterpLocation(screen_origin, prev_cascade_index, is_prev_horizontal, screen_dir, c0_size);\n                prev_interval += InterpInterval(iChannel0, prev_cascade_index, prev_interp_loc.line_index, prev_interp_loc.probe_indexf, prev_dir_index, c0_size) * prev_dir_weights[prev_dir_number] / float(steps_count);\n            }\n        }\n    }\n    vec2 pixel_dir = GetProbeDir(float(interval_loc.dir_index), cascade_size.dirs_count);\n    vec2 screen_dir = pixel_dir / vec2(viewport_size);\n    InterpIntervalLocation prev_interp_loc = GetInterpLocation(screen_origin, prev_cascade_index, is_horizontal, screen_dir, c0_size);\n\n    vec2 ray_start = screen_origin * vec2(viewport_size);\n    float ray_scale = (interval_loc.cascade_index + 1 == nCascades) ? 1000.0f : prev_interp_loc.ray_scale;\n    vec2 ray_end = screen_origin * vec2(viewport_size) + pixel_dir * ray_scale;\n\n    RayHit ray_hit = radiance(iChannel1, ray_start, normalize(ray_end - ray_start), length(ray_end - ray_start));\n    return MergeIntervals(ray_hit.radiance, prev_interval);\n}\n\n\nvoid mainCubemap(out vec4 fragColor, vec2 fragCoord, vec3 fragRO, vec3 fragRD) {\n    // Calculate the index for this cubemap texel\n    int face;\n    \n    if (abs(fragRD.x) > abs(fragRD.y) && abs(fragRD.x) > abs(fragRD.z)) {\n        face = fragRD.x > 0.0 ? 0 : 1;\n    } else if (abs(fragRD.y) > abs(fragRD.z)) {\n        face = fragRD.y > 0.0 ? 2 : 3;\n    } else {\n        face = fragRD.z > 0.0 ? 4 : 5;\n    }\n    \n    ivec2 face_size = textureSize(iChannel0, 0);\n    \n    ivec2 face_pixel = ivec2(fragCoord.xy);\n    int face_index = face;\n    int pixel_index = face_pixel.x + face_pixel.y * face_size.x + face_index * (face_size.x * face_size.y);\n    \n    ivec2 viewport_size = textureSize(iChannel1, 0);\n    CascadeSize c0_size = GetC0Size(viewport_size);\n    IntervalLocation interval_location = PixelIndexToIntervalLocation(pixel_index, c0_size);\n    \n    if(interval_location.cascade_index >= nCascades)\n    {\n        fragColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);\n        return;\n    }\n    //fragColor = CastMergedInterval(interval_location);\n    //fragColor = CastMergedIntervalExtended(interval_location);\n    fragColor = CastMergedIntervalNumerical(interval_location);\n    //fragColor = vec4(interval_location.cascade_index, interval_location.line_index, interval_location.probe_index, interval_location.dir_index);\n}","name":"Cube A","description":"","type":"cubemap"},{"inputs":[],"outputs":[],"code":"#define MERGE_FIX 1\n#define C_MINUS1_GATHERING 1\n// Number of cascades all together\nconst int nCascades = 4;\n\n// Brush radius used for drawing, measured as fraction of iResolution.y\nconst float brushRadius = 0.02;\n\nconst float MAX_FLOAT = uintBitsToFloat(0x7f7fffffu);\nconst float PI = 3.1415927;\nconst float MAGIC = 1e25;\n\nconst float line_grid_center = 0.5f;\nconst float probe_grid_center = 0.5f;\n\n#define LINES_COUNT_SCALE_POW2 1\n#define PROBES_COUNT_SCALE_POW2 0\n#define DIRS_COUNT_SCALE_POW2 1\n\nstruct CascadeSize\n{\n    ivec2 lines_count;\n    ivec2 probes_count;\n    int dirs_count;\n};\n\nCascadeSize GetC0Size(ivec2 viewport_size)\n{\n    CascadeSize c0_size;\n    c0_size.lines_count = ivec2(512) * ivec2(1, viewport_size.y) / ivec2(1, viewport_size.x);//viewport_size / 10;\n    c0_size.probes_count = c0_size.lines_count;\n    c0_size.dirs_count = 8;\n    /*c0_size.lines_count = ivec2(10);\n    c0_size.probes_count = c0_size.lines_count * 30;\n    c0_size.dirs_count = 8;*/\n    return c0_size;\n}\n\n\nstruct BilinearSamples\n{\n    ivec2 base_index;\n    vec2 ratio;\n};\n\nvec4 GetBilinearWeights(vec2 ratio)\n{\n    return vec4(\n        (1.0f - ratio.x) * (1.0f - ratio.y),\n        ratio.x * (1.0f - ratio.y),\n        (1.0f - ratio.x) * ratio.y,\n        ratio.x * ratio.y);\n}\n\nivec2 GetBilinearOffset(int offset_index)\n{\n    ivec2 offsets[4] = ivec2[4](ivec2(0, 0), ivec2(1, 0), ivec2(0, 1), ivec2(1, 1));\n    return offsets[offset_index];\n}\nBilinearSamples GetBilinearSamples(vec2 pixel_index2f)\n{\n    BilinearSamples samples;\n    samples.base_index = ivec2(floor(pixel_index2f));\n    samples.ratio = fract(pixel_index2f);\n    return samples;\n}\n\nstruct LinearSamples\n{\n    int base_index;\n    float ratio;\n};\nvec2 GetLinearWeights(float ratio)\n{\n    return vec2(1.0f - ratio, ratio);\n}\nLinearSamples GetLinearSamples(float indexf)\n{\n    LinearSamples samples;\n    samples.base_index = int(floor(indexf));\n    samples.ratio = fract(indexf);\n    return samples;\n}\n\nCascadeSize GetCascadeSize(int cascade_index, CascadeSize c0_size)\n{\n    CascadeSize cascade_size;\n    cascade_size.lines_count = max(ivec2(1), c0_size.lines_count >> (LINES_COUNT_SCALE_POW2 * cascade_index));\n    cascade_size.probes_count = max(ivec2(1), c0_size.probes_count >> (PROBES_COUNT_SCALE_POW2 * cascade_index));\n    cascade_size.dirs_count = c0_size.dirs_count * (1 << (DIRS_COUNT_SCALE_POW2 * cascade_index));\n    return cascade_size;\n}\n\nint GetCascadeLinearOffset(int cascade_index, CascadeSize c0_size)\n{\n    int offset = 0;\n    \n    for(int i = 0; i < cascade_index; i++)\n    {\n        CascadeSize cascade_size = GetCascadeSize(i, c0_size);\n        int hor_dirs_count = cascade_size.dirs_count / 2;\n        int vert_dirs_count = cascade_size.dirs_count / 2;\n        \n        offset += \n            cascade_size.lines_count.x * cascade_size.probes_count.y * vert_dirs_count +\n            cascade_size.lines_count.y * cascade_size.probes_count.x * hor_dirs_count;\n    }\n    return offset;\n}\n\nint IsDirHorizontal(float dir_indexf, int dirs_count)\n{\n    float ang_ratio = (dir_indexf + 0.5f) / float(dirs_count);\n    return fract(ang_ratio * 2.0f) < 0.5f ? 0 : 1;\n}\n\nstruct IntervalLocation\n{\n    int probe_index;\n    int line_index;\n    int dir_index;\n    int cascade_index;\n};\n\nint CardinalIndexToDirIndex(int cardinal_index, int is_horizontal, int dirs_count)\n{\n    int cardinal_count = dirs_count / 2;\n    int quadrant_count = cardinal_count / 2;\n    return cardinal_index % quadrant_count + (cardinal_index < quadrant_count ? 0 : cardinal_count) + (is_horizontal == 0 ? 0 : quadrant_count);\n}\n\nint DirIndexToCardinalIndex(int dir_index, int dirs_count)\n{\n    int cardinal_count = dirs_count / 2;\n    int quadrant_count = cardinal_count / 2;\n    \n    return (dir_index % quadrant_count) + (dir_index / cardinal_count) * quadrant_count;\n}\n\n\nint IntervalLocationToPixelIndex(IntervalLocation interval_loc, CascadeSize c0_size)\n{\n    CascadeSize cascade_size = GetCascadeSize(interval_loc.cascade_index, c0_size);\n    int cardinal_count = cascade_size.dirs_count / 2;\n    int horizontal_offset = cascade_size.probes_count.y * cascade_size.lines_count.x * cardinal_count;\n\n    int offset_in_cascade = 0;\n    \n\n    if(IsDirHorizontal(float(interval_loc.dir_index), cascade_size.dirs_count) == 0)\n    {\n        int vert_dirs_count = cascade_size.dirs_count / 2;\n        offset_in_cascade = (cascade_size.probes_count.y * interval_loc.line_index + interval_loc.probe_index) * cardinal_count + DirIndexToCardinalIndex(interval_loc.dir_index, cascade_size.dirs_count);\n    }else\n    {\n        int hor_dirs_count = cascade_size.dirs_count / 2;\n        offset_in_cascade = (cascade_size.probes_count.x * interval_loc.line_index + interval_loc.probe_index) * cardinal_count + DirIndexToCardinalIndex(interval_loc.dir_index, cascade_size.dirs_count) +\n            horizontal_offset;\n    }\n    return GetCascadeLinearOffset(interval_loc.cascade_index, c0_size) + offset_in_cascade;\n}\n\n\nIntervalLocation PixelIndexToIntervalLocation(int pixel_index, CascadeSize c0_size)\n{\n    IntervalLocation interval_location;\n    for(\n        interval_location.cascade_index = 0;\n        GetCascadeLinearOffset(interval_location.cascade_index + 1, c0_size) <= pixel_index && interval_location.cascade_index < 10;\n        interval_location.cascade_index++);\n\n    int offset_in_cascade = pixel_index - GetCascadeLinearOffset(interval_location.cascade_index, c0_size);\n    CascadeSize cascade_size = GetCascadeSize(interval_location.cascade_index, c0_size);\n    int cardinal_count = cascade_size.dirs_count / 2;\n    \n    int horizontal_offset = cascade_size.probes_count.y * cascade_size.lines_count.x * cardinal_count;\n    if(offset_in_cascade < horizontal_offset)\n    {\n        int offset_in_lines = offset_in_cascade;\n        int cardinal_index = offset_in_lines % cardinal_count;\n        interval_location.dir_index = CardinalIndexToDirIndex(cardinal_index, 0, cascade_size.dirs_count);\n        interval_location.probe_index = (offset_in_lines / cardinal_count) % cascade_size.probes_count.y;\n        interval_location.line_index = offset_in_lines / (cardinal_count * cascade_size.probes_count.y);\n    }else\n    {\n        int offset_in_lines = offset_in_cascade - horizontal_offset;\n        int cardinal_index = offset_in_lines % cardinal_count;\n        interval_location.dir_index =  CardinalIndexToDirIndex(cardinal_index, 1, cascade_size.dirs_count);\n        interval_location.probe_index = (offset_in_lines / cardinal_count) % cascade_size.probes_count.x;\n        interval_location.line_index = offset_in_lines / (cardinal_count * cascade_size.probes_count.x);\n    }\n    return interval_location;\n}\n\nivec3 PixelIndexToCubemapTexel(ivec2 face_size, int pixel_index)\n{\n    int face_pixels_count = face_size.x * face_size.y;\n    int face_index = pixel_index / face_pixels_count;\n    int face_pixel_index = pixel_index - face_pixels_count * face_index;\n    ivec2 face_pixel = ivec2(face_pixel_index % face_size.x, face_pixel_index / face_size.x);\n    return ivec3(face_pixel, face_index);\n}\n\nvec2 GetLineScreenSpacing(int cascade_index, ivec2 c0_lines_count)\n{\n    vec2 c0_line_screen_spacing = vec2(1.0f) / vec2(c0_lines_count);\n    return c0_line_screen_spacing * float(1 << (LINES_COUNT_SCALE_POW2 * cascade_index));\n}\nvec2 GetProbeScreenSpacing(int cascade_index, ivec2 c0_probes_count)\n{\n    vec2 c0_probe_screen_spacing = vec2(1.0f) / vec2(c0_probes_count);\n    return c0_probe_screen_spacing * float(1 << (PROBES_COUNT_SCALE_POW2 * cascade_index));\n}\n\nvec2 GetIntervalScreenOrigin(float probe_indexf, float line_indexf, int is_horizontal, int cascade_index, CascadeSize c0_size)\n{\n    vec2 probe_screen_spacing = GetProbeScreenSpacing(cascade_index, c0_size.probes_count);\n    vec2 line_screen_spacing = GetLineScreenSpacing(cascade_index, c0_size.lines_count);\n    \n    if(is_horizontal == 0)\n    {\n        return vec2(line_screen_spacing.x * (line_indexf + line_grid_center), probe_screen_spacing.y * (probe_indexf + probe_grid_center));\n    }else\n    {\n        return vec2(probe_screen_spacing.x * (probe_indexf + probe_grid_center), line_screen_spacing.y * (line_indexf + line_grid_center));\n    }\n}\n\n\n\nvec2 GetProbeDir(float dir_indexf, int dirs_count)\n{\n\n    float ang = -PI / 4.0f + (dir_indexf + 0.5f) / float(dirs_count) * 2.0f * PI;\n    return vec2(cos(ang), sin(ang));\n}\n\nvec4 cubemapFetch(samplerCube sampler, int face, ivec2 P) {\n    // Look up a single texel in a cubemap\n    ivec2 cubemapRes = textureSize(sampler, 0);\n    if (clamp(P, ivec2(0), cubemapRes - 1) != P || face < 0 || face > 5) {\n        return vec4(0.0);\n    }\n\n    vec2 p = (vec2(P) + 0.5) / vec2(cubemapRes) * 2.0 - 1.0;\n    vec3 c;\n    \n    switch (face) {\n        case 0: c = vec3( 1.0, -p.y, -p.x); break;\n        case 1: c = vec3(-1.0, -p.y,  p.x); break;\n        case 2: c = vec3( p.x,  1.0,  p.y); break;\n        case 3: c = vec3( p.x, -1.0, -p.y); break;\n        case 4: c = vec3( p.x, -p.y,  1.0); break;\n        case 5: c = vec3(-p.x, -p.y, -1.0); break;\n    }\n    \n    return texture(sampler, normalize(c));\n}\n\n\nvec4 InterpInterval(samplerCube cubemap_atlas, int cascade_index, int line_index, float probe_indexf, int dir_index, CascadeSize c0_size)\n{\n    ivec2 face_size = textureSize(cubemap_atlas, 0);\n    CascadeSize cascade_size = GetCascadeSize(cascade_index, c0_size);\n    \n    IntervalLocation interval_loc;\n    interval_loc.cascade_index = cascade_index;\n    interval_loc.line_index = line_index;\n    interval_loc.dir_index = dir_index;\n\n    LinearSamples probe_samples = GetLinearSamples(probe_indexf);\n    vec2 probe_weights = GetLinearWeights(probe_samples.ratio);\n\n    int probes_count = IsDirHorizontal(float(dir_index), cascade_size.dirs_count) == 0 ? cascade_size.probes_count.y : cascade_size.probes_count.x;\n    int lines_count = IsDirHorizontal(float(dir_index), cascade_size.dirs_count) == 0 ? cascade_size.lines_count.x : cascade_size.lines_count.y;\n    //interval_loc.line_index = clamp(interval_loc.line_index, 0, lines_count - 1);\n    vec4 res = vec4(0.0f);\n    for(int offset = 0; offset < 2; offset++)\n    {\n        interval_loc.probe_index = clamp(probe_samples.base_index + offset, 0, probes_count - 1);\n        int pixel_index = IntervalLocationToPixelIndex(interval_loc, c0_size);\n        ivec3 texel_index = PixelIndexToCubemapTexel(face_size, pixel_index);\n        res += cubemapFetch(cubemap_atlas, texel_index.z, texel_index.xy) * probe_weights[offset]; \n    }\n    return res;\n}\n\nstruct InterpIntervalLocation\n{\n    int line_index;\n    float probe_indexf;\n    float ray_scale;\n};\n\nInterpIntervalLocation GetInterpLocation(vec2 screen_pos, int cascade_index, int is_horizontal, vec2 screen_dir, CascadeSize c0_size)\n{\n    InterpIntervalLocation interp_loc;\n    \n    CascadeSize cascade_size = GetCascadeSize(cascade_index, c0_size);\n    \n    vec2 probe_screen_spacing = GetProbeScreenSpacing(cascade_index, c0_size.probes_count);\n    vec2 line_screen_spacing = GetLineScreenSpacing(cascade_index, c0_size.lines_count);\n    \n    if(is_horizontal == 0)\n    {\n        interp_loc.line_index = int(floor(screen_pos.x / line_screen_spacing.x - line_grid_center));\n        if(screen_dir.x > 0.0f) interp_loc.line_index++;\n        interp_loc.line_index = clamp(interp_loc.line_index, 0, int(cascade_size.lines_count.x - 1));\n        float line_x = line_screen_spacing.x * (float(interp_loc.line_index) + line_grid_center);\n        interp_loc.ray_scale = (line_x - screen_pos.x) / screen_dir.x;\n        float probe_y = screen_pos.y + screen_dir.y * interp_loc.ray_scale;\n        interp_loc.probe_indexf = probe_y / probe_screen_spacing.y - probe_grid_center;\n    }else\n    {\n        interp_loc.line_index = int(floor(screen_pos.y / line_screen_spacing.y - line_grid_center));\n        if(screen_dir.y > 0.0f) interp_loc.line_index++;\n        interp_loc.line_index = clamp(interp_loc.line_index, 0, int(cascade_size.lines_count.y - 1));\n        float line_y = line_screen_spacing.y * (float(interp_loc.line_index) + line_grid_center);\n        interp_loc.ray_scale = (line_y - screen_pos.y) / screen_dir.y;\n        float probe_x = screen_pos.x + screen_dir.x * interp_loc.ray_scale;\n        interp_loc.probe_indexf = probe_x / probe_screen_spacing.x - probe_grid_center;\n    }\n    return interp_loc;\n}\n\nfloat GetBaseRaymarchDist(int is_horizontal, vec2 screen_dir, vec2 line_screen_spacing)\n{\n    if(is_horizontal == 0)\n    {\n        return line_screen_spacing.x / abs(screen_dir.x);\n    }else\n    {\n        return line_screen_spacing.y / abs(screen_dir.y);\n    }\n}\n\nvec4 MergeIntervals(vec4 near_interval, vec4 far_interval)\n{\n    //return near_interval + far_interval;\n    return vec4(near_interval.rgb + near_interval.a * far_interval.rgb, near_interval.a * far_interval.a);\n}\n\nvec2 screenRes;\n\nvec3 integrateSkyRadiance_(vec2 angle) {\n    // Sky radiance helper function\n    float a1 = angle[1];\n    float a0 = angle[0];\n    \n    // Sky integral formula taken from\n    // Analytic Direct Illumination - Mathis\n    // https://www.shadertoy.com/view/NttSW7\n    const vec3 SkyColor = vec3(0.2,0.5,1.);\n    const vec3 SunColor = vec3(1.,0.7,0.1)*10.;\n    const float SunA = 2.0;\n    const float SunS = 64.0;\n    const float SSunS = sqrt(SunS);\n    const float ISSunS = 1./SSunS;\n    vec3 SI = SkyColor*(a1-a0-0.5*(cos(a1)-cos(a0)));\n    SI += SunColor*(atan(SSunS*(SunA-a0))-atan(SSunS*(SunA-a1)))*ISSunS;\n    return SI / 6.0;\n}\n\nvec3 integrateSkyRadiance(vec2 angle) {\n    // Integrate the radiance from the sky over an interval of directions\n    if (angle[1] < 2.0 * PI) {\n        return integrateSkyRadiance_(angle);\n    }\n    \n    return\n        integrateSkyRadiance_(vec2(angle[0], 2.0 * PI)) +\n        integrateSkyRadiance_(vec2(0.0, angle[1] - 2.0 * PI));\n}\n\n\nivec2 roundSDim(ivec2 v) {\n    return v - (v & ivec2((1 << nCascades) - 1));\n}\n\nconst int KEY_SPACE = 32;\nconst int KEY_1 = 49;\n\n#ifndef HW_PERFORMANCE\nuniform vec4 iMouse;\nuniform sampler2D iChannel2;\nuniform float iTime;\n#endif\n\nbool keyToggled(int keyCode) {\n    return texelFetch(iChannel2, ivec2(keyCode, 2), 0).r > 0.0;\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec3 rgb = clamp(\n        abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0,\n        0.0,\n        1.0\n    );\n\treturn c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvec3 getEmissivity() {\n    return !keyToggled(KEY_SPACE)\n        ? pow(hsv2rgb(vec3(iTime * 0.2 + -0.5f, 1.0, 2.5)), vec3(2.2))\n        : vec3(0.0);\n}\n\nfloat sdCircle(vec2 p, vec2 c, float r) {\n    return distance(p, c) - r;\n}\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b) {\n    vec2 ap = p - a;\n    vec2 ab = b - a;\n    return distance(ap, ab * clamp(dot(ap, ab) / dot(ab, ab), 0.0, 1.0));\n}\n\nvec4 sampleDrawing(sampler2D drawingTex, vec2 P) {\n    // Return the drawing (in the format listed at the top of Buffer B) at P\n    vec4 data = texture(drawingTex, P / vec2(textureSize(drawingTex, 0)));\n    \n    if (keyToggled(KEY_1) && iMouse.z > 0.0) {\n        float radius = brushRadius * screenRes.y;\n        //float sd = sdCircle(P, iMouse.xy + 0.5, radius);\n        float sd = sdSegment(P, abs(iMouse.zw) + 0.5, iMouse.xy + 0.5) - radius;\n        \n        if (sd <= max(data.r, 0.0)) {\n            data = vec4(min(sd, data.r), getEmissivity());\n        }\n    }\n\n    return data;\n}\n\nfloat sdDrawing(sampler2D drawingTex, vec2 P) {\n    // Return the signed distance for the drawing at P\n    return sampleDrawing(drawingTex, P).r;\n}\n\nvec2 intersectAABB(vec2 ro, vec2 rd, vec2 a, vec2 b) {\n    // Return the two intersection t-values for the intersection between a ray\n    // and an axis-aligned bounding box\n    vec2 ta = (a - ro) / rd;\n    vec2 tb = (b - ro) / rd;\n    vec2 t1 = min(ta, tb);\n    vec2 t2 = max(ta, tb);\n    vec2 t = vec2(max(t1.x, t1.y), min(t2.x, t2.y));\n    return t.x > t.y ? vec2(-1.0) : t;\n}\n\n\n\nfloat intersect(sampler2D sdf_tex, vec2 ro, vec2 rd, float tMax) {\n    // Return the intersection t-value for the intersection between a ray and\n    // the SDF drawing from Buffer B\n    screenRes = vec2(textureSize(sdf_tex, 0));\n    float tOffset = 0.0;\n    // First clip the ray to the screen rectangle\n    vec2 tAABB = intersectAABB(ro, rd, vec2(0.0001), screenRes - 0.0001);\n    \n    if (tAABB.x > tMax || tAABB.y < 0.0) {\n        return -1.0;\n    }\n    \n    if (tAABB.x > 0.0) {\n        ro += tAABB.x * rd;\n        tOffset += tAABB.x;\n        tMax -= tAABB.x;\n    }\n    \n    if (tAABB.y < tMax) {\n        tMax = tAABB.y;\n    }\n\n    float t = 0.0;\n\n    for (int i = 0; i < 100; i++) {\n        float d = sdDrawing(sdf_tex, ro + rd * t);\n        \n        t += (d);\n        if ((d) < 0.01)\n            return t;\n\n        if (t >= tMax) {\n            break;\n        }\n    }\n\n    return -1.0;\n}\n\nstruct RayHit\n{\n    vec4 radiance;\n    float dist;\n};\n#if MERGE_FIX != 3 //Dolkar fix works better if miss rays terminate instead of being infinite\nRayHit radiance(sampler2D sdf_tex, vec2 ro, vec2 rd, float tMax) {\n    // Returns the radiance and visibility term for a ray\n    vec4 p = sampleDrawing(sdf_tex, ro);\n    float t = 1e6f;\n    if (p.r > 0.0) {\n        t = intersect(sdf_tex, ro, rd, tMax);\n        \n        if (t == -1.0) {\n            return RayHit(vec4(0.0, 0.0, 0.0, 1.0), 1e5f);\n        }\n\n        p = sampleDrawing(sdf_tex, ro + rd * t);\n    }\n\n    return RayHit(vec4(p.gba, 0.0), t);\n}\n#else\nRayHit radiance(sampler2D sdf_tex, vec2 ro, vec2 rd, float tMax) {\n    // Returns the radiance and visibility term for a ray\n    vec4 p = sampleDrawing(sdf_tex, ro);\n    if (p.r > 0.0) {\n        float t = intersect(sdf_tex, ro, rd, tMax);\n        \n        if (t == -1.0) {\n            return RayHit(vec4(0.0, 0.0, 0.0, 1.0), 1e5f);\n        }\n\n        p = sampleDrawing(sdf_tex, ro + rd * t);\n        return RayHit(vec4(p.gba, 0.0), t);\n    } else {\n        return RayHit(vec4(0.0), 0.0);\n    }\n}\n#endif","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// SDF drawing logic from \n// Smooth Mouse Drawing - fad\n// https://www.shadertoy.com/view/dldXR7\n\n// This buffer tracks smoothed mouse positions over multiple frames.\n\n// See https://lazybrush.dulnan.net/ for what these mean:\n#define RADIUS (iResolution.y * 0.015)\n#define FRICTION 0.05\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    if (fragCoord.y != 0.5 || fragCoord.x > 3.0) {\n        return;\n    }\n\n    if (iFrame == 0) {\n        if (fragCoord.x == 2.5) {\n            fragColor = iMouse;\n        } else {\n            fragColor = vec4(0.0);\n        }\n        \n        return;\n    }\n    \n    vec4 iMouse = iMouse;\n    \n    if (iMouse == vec4(0.0)) {\n        float t = iTime * 3.0;\n        iMouse.xy = vec2(\n            cos(3.14159 * t) + sin(0.72834 * t + 0.3),\n            sin(2.781374 * t + 3.47912) + cos(t)\n        ) * 0.25 + 0.5;\n        iMouse.xy *= iResolution.xy;\n        iMouse.z = MAGIC;\n    }\n    \n    vec4 mouseA = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec4 mouseB = texelFetch(iChannel0, ivec2(2, 0), 0);\n    vec4 mouseC;\n    mouseC.zw = iMouse.zw;\n    float dist = distance(mouseB.xy, iMouse.xy);\n    \n    if (mouseB.z > 0.0 && (mouseB.z != MAGIC || iMouse.z == MAGIC) && dist > 0.0) {\n        vec2 dir = (iMouse.xy - mouseB.xy) / dist;\n        float len = max(dist - RADIUS, 0.0);\n        float ease = 1.0 - pow(FRICTION, iTimeDelta * 10.0);\n        mouseC.xy = mouseB.xy + dir * len * ease;\n    } else {\n        mouseC.xy = iMouse.xy;\n    }\n    \n    if (fragCoord.x == 0.5) {\n        fragColor = mouseA;\n    } else if (fragCoord.x == 1.5) {\n        fragColor = mouseB.z == MAGIC && iMouse.z != MAGIC ? vec4(0.0) : mouseB;\n    } else {\n        fragColor = mouseC;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// This buffer draws the SDF:\n// .r stores signed distance\n// .gba stores emissivity\n\n// SDF drawing logic from \n// Smooth Mouse Drawing - fad\n// https://www.shadertoy.com/view/dldXR7\n\n// solveQuadratic(), solveCubic(), solve() and sdBezier() are from\n// Quadratic Bezier SDF With L2 - Envy24\n// https://www.shadertoy.com/view/7sGyWd\n// with modification. Thank you! I tried a lot of different sdBezier()\n// implementations from across Shadertoy (including trying to make it\n// myself) and all of them had bugs and incorrect edge case handling\n// except this one.\n\nint solveQuadratic(float a, float b, float c, out vec2 roots) {\n    // Return the number of real roots to the equation\n    // a*x^2 + b*x + c = 0 where a != 0 and populate roots.\n    float discriminant = b * b - 4.0 * a * c;\n\n    if (discriminant < 0.0) {\n        return 0;\n    }\n\n    if (discriminant == 0.0) {\n        roots[0] = -b / (2.0 * a);\n        return 1;\n    }\n\n    float SQRT = sqrt(discriminant);\n    roots[0] = (-b + SQRT) / (2.0 * a);\n    roots[1] = (-b - SQRT) / (2.0 * a);\n    return 2;\n}\n\nint solveCubic(float a, float b, float c, float d, out vec3 roots) {\n    // Return the number of real roots to the equation\n    // a*x^3 + b*x^2 + c*x + d = 0 where a != 0 and populate roots.\n    const float TAU = 6.2831853071795862;\n    float A = b / a;\n    float B = c / a;\n    float C = d / a;\n    float Q = (A * A - 3.0 * B) / 9.0;\n    float R = (2.0 * A * A * A - 9.0 * A * B + 27.0 * C) / 54.0;\n    float S = Q * Q * Q - R * R;\n    float sQ = sqrt(abs(Q));\n    roots = vec3(-A / 3.0);\n\n    if (S > 0.0) {\n        roots += -2.0 * sQ * cos(acos(R / (sQ * abs(Q))) / 3.0 + vec3(TAU, 0.0, -TAU) / 3.0);\n        return 3;\n    }\n    \n    if (Q == 0.0) {\n        roots[0] += -pow(C - A * A * A / 27.0, 1.0 / 3.0);\n        return 1;\n    }\n    \n    if (S < 0.0) {\n        float u = abs(R / (sQ * Q));\n        float v = Q > 0.0 ? cosh(acosh(u) / 3.0) : sinh(asinh(u) / 3.0);\n        roots[0] += -2.0 * sign(R) * sQ * v;\n        return 1;\n    }\n    \n    roots.xy += vec2(-2.0, 1.0) * sign(R) * sQ;\n    return 2;\n}\n\nint solve(float a, float b, float c, float d, out vec3 roots) {\n    // Return the number of real roots to the equation\n    // a*x^3 + b*x^2 + c*x + d = 0 and populate roots.\n    if (a == 0.0) {\n        if (b == 0.0) {\n            if (c == 0.0) {\n                return 0;\n            }\n            \n            roots[0] = -d/c;\n            return 1;\n        }\n        \n        vec2 r;\n        int num = solveQuadratic(b, c, d, r);\n        roots.xy = r;\n        return num;\n    }\n    \n    return solveCubic(a, b, c, d, roots);\n}\n\nfloat sdBezier(vec2 p, vec2 a, vec2 b, vec2 c) {\n    vec2 A = a - 2.0 * b + c;\n    vec2 B = 2.0 * (b - a);\n    vec2 C = a - p;\n    vec3 T;\n    int num = solve(\n        2.0 * dot(A, A),\n        3.0 * dot(A, B),\n        2.0 * dot(A, C) + dot(B, B),\n        dot(B, C),\n        T\n    );\n    T = clamp(T, 0.0, 1.0);\n    float best = 1e30;\n    \n    for (int i = 0; i < num; ++i) {\n        float t = T[i];\n        float u = 1.0 - t;\n        vec2 d = u * u * a + 2.0 * t * u * b + t * t * c - p;\n        best = min(best, dot(d, d));\n    }\n    \n    return sqrt(best);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec4 data = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    float sd = iFrame != 0 ? data.r : MAX_FLOAT;\n    vec3 emissivity = iFrame != 0 ? data.gba : vec3(0.0);\n    vec4 mouseA = iFrame > 0 ? texelFetch(iChannel0, ivec2(0, 0), 0) : vec4(0.0);\n    vec4 mouseB = iFrame > 0 ? texelFetch(iChannel0, ivec2(1, 0), 0) : vec4(0.0);\n    vec4 mouseC = iFrame > 0 ? texelFetch(iChannel0, ivec2(2, 0), 0) : iMouse;\n    mouseA.xy += 0.5;\n    mouseB.xy += 0.5;\n    mouseC.xy += 0.5;\n    float d = MAX_FLOAT;\n    \n    if (mouseB.z <= 0.0 && mouseC.z > 0.0) {\n        d = distance(fragCoord, mouseC.xy);\n    } else if (mouseA.z <= 0.0 && mouseB.z > 0.0 && mouseC.z > 0.0) {\n        d = sdSegment(fragCoord, mouseB.xy, mix(mouseB.xy, mouseC.xy, 0.5));\n    } else if (mouseA.z > 0.0 && mouseB.z > 0.0 && mouseC.z > 0.0) {\n        d = sdBezier(\n            fragCoord,\n            mix(mouseA.xy, mouseB.xy, 0.5),\n            mouseB.xy,\n            mix(mouseB.xy, mouseC.xy, 0.5)\n        );\n    } else if (mouseA.z > 0.0 && mouseB.z > 0.0 && mouseC.z <= 0.0) {\n        d = sdSegment(fragCoord, mix(mouseA.xy, mouseB.xy, 0.5), mouseB.xy);\n    }\n    \n    d -= brushRadius * iResolution.y;\n    \n    if (\n        d < max(0.0, sd) && !keyToggled(KEY_1) &&\n        (mouseC.z != MAGIC || cos(iTime * 20.0) > 0.5)\n    ) {\n        sd = min(d, sd);\n        emissivity = getEmissivity() * float(mouseC.z != MAGIC || cos(iTime * 10.0) > 0.5);\n    }\n    \n    /*float t = 20.0f;\n    sd = distance(fragCoord, vec2(0.66 + sin(t/4.0)/8.0, 0.5 + cos(t/4.0)/4.0) * iResolution.xy) - 10.0;\n    sd = min(sd, max(abs(fragCoord.x - 0.5 * iResolution.x) - 10.0, abs(fragCoord.y - 0.5 * iResolution.y) - 30.0));\n    emissivity = (fragCoord.x < 0.52 * iResolution.x) ? vec3(0.0) : vec3(4.0);*/\n\n    fragColor = vec4(sd, emissivity);\n}","name":"Buffer B","description":"","type":"buffer"}]}