{"ver":"0.1","info":{"id":"3tKfDG","date":"1614972902","viewed":380,"name":"PBR Materials","username":"MatthieuJacquemet","description":"Simple test scene for different kind of pbr materials","likes":27,"published":1,"flags":0,"usePreview":1,"tags":["sdf","texture","pbr","meterial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Jacquemet Matthieu\n\n// Contants --------------------------------------------------------------------------------------------\nconst float PI   = 3.141592653589793238462643383279502884197169;\nconst float PI_2 = 1.570796326794896619231321691639751442098585;\n\n\nconst int MAX_STEPS = 200;      // Number of steps\nconst float EPSILON = 0.01; // Marching epsilon\n\n// Structure for objects\n// v : Field value\n// i : Texture index\nstruct TraceData {\n    float v; \n    int i;\n};\n\n// Structure for texture\n// c : Color\n// s : Specular\nstruct Material {\n    vec3 albedo;\n    vec3 emissive;\n    float roughness;\n    float clearcoat;\n    float metallic;\n};\n\n\n#define TONEMAP_LINEAR 0 \n#define TONEMAP_FILMIC 1\n#define TONEMAP_REINHARD 2\n#define TONEMAP_FILMIC_REINHARD 3\n#define TONEMAP_UNCHARTED2 4\n#define TONEMAP_ACES 5\n\n#define MATERIAL_FLOOR_TILES 0\n#define MATERIAL_CAR_COAT 1\n#define MATERIAL_BURNED_WOOD 2\n#define MATERIAL_SOIL 3\n#define MATERIAL_MARBLE 4\n#define MATERIAL_GRANITE 5\n#define MATERIAL_LAVA  6\n#define MATERIAL_RUSTED_METAL 7\n#define MATERIAL_BRICKS 8\n#define MATERIAL_ASPHALT 9\n#define MATERIAL_GOLD 10\n#define MATERIAL_RUSTY_PAINT 11\n#define MATERIAL_CARBON_FIBER 12\n\n#define SPECULAR_GGX 0\n#define SPECULAR_BLINN 1\n#define SPECULAR_BECKMANN 2\n\n#define SPECULAR_MODE SPECULAR_GGX\n#define TONEMAP_MODE TONEMAP_ACES // Tone mapping mode\n#define _DEBUG 0               // set 1 to enable debuging\n\n\n\n#if _DEBUG\n    vec3 _debug_color;\n    bool _is_debug = false;\n    #define DEBUG(color) if (_is_debug) _debug_color = color; // use this to debug a color\n    #define CATCH_DEBUG(expr) _is_debug = true; expr ; _is_debug = false;\n#else\n    #define DEBUG(color)\n    #define CATCH_DEBUG(expr) expr // any call to DEBUG(color) in this macro will output de color\n#endif\n// Primitive functions -----------------------------------------------------------------------------------\n\n\n// Hashing function\n// Returns a random number in [-1,1]\nfloat Hash(float seed)\n{\n    return fract(sin(seed)*43758.5453 );\n}\n\nfloat Hash3(vec3 p)\n{\n    return fract(sin(1e3*dot(p,vec3(1,57,-13.7)))*4375.5453);\n}\n\n// Cosine direction \n// seed : Random seed\n//    n : Normal\nvec3 Cosine( in float seed, in vec3 n)\n{\n    float u = Hash( 78.233 + seed);\n    float v = Hash( 10.873 + seed);\n\n    // Method by fizzer: http://www.amietia.com/lambertnotangent.html\n    float a = 6.2831853 * v;\n    u = 2.0 * u - 1.0;\n    return normalize( n + vec3(sqrt(1.0-u*u)* vec2(cos(a), sin(a)), u) );\n}\n\n// Texturing and noise ---------------------------------------------------------\n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in space\nfloat Hash(in vec3 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix(mix( Hash(i+vec3(0,0,0)), \n                        Hash(i+vec3(1,0,0)),f.x),\n                   mix( Hash(i+vec3(0,1,0)), \n                        Hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( Hash(i+vec3(0,0,1)), \n                        Hash(i+vec3(1,0,1)),f.x),\n                   mix( Hash(i+vec3(0,1,1)), \n                        Hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// Compute the distance to the Voronoi boundary\n// x : Point\n// Return (closest distance, second closest, cell id)\nvec3 Voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + Hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\n// based on https://www.shadertoy.com/view/llG3zy\nvec3 VoronoiE( in vec3 x )\n{\n    vec3 n = floor(x);\n    vec3 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec3 mr;\n\n    float md = 8.0;\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 g = vec3(float(i),float(j), float(k));\n\t\tvec3 o = vec3( g ) - f + Hash( n + g );\n        vec3 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders,\n    // visits only neighbouring cells\n    //----------------------------------\n    md = 8.0;\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 g = vec3(float(i),float(j), float(k));\n\t\tvec3 o = vec3( g ) - f + Hash( n + g );\n\t\tvec3 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>EPSILON ) // skip the same cell\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec3( md, mr );\n}\n\n// Tranforms --------------------------------------------------------------------\n\n// Map value from [Imin, Imax] to [Omin, Omax]\nfloat map(float value, float Imin, float Imax, float Omin, float Omax) \n{  \n  return Omin + (value - Imin) * (Omax - Omin) / (Imax - Imin);\n}\n\n// Translate point p\nvec3 Translate(vec3 pos, vec3 p) {\n\n    return p - pos;\n}\n\n// Scale point p\nvec3 Scale(vec3 scale, vec3 p) {\n\n    return vec3(p.x/scale.x, p.y/scale.y, p.z/scale.z);\n}\n\n// Rotate point p around X axis (radians)\nvec3 RotateX(float theta, vec3 p)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    mat3 M = mat3(  1,     0,     0,\n                    0,  _cos, -_sin,\n                    0,  _sin,  _cos);\n    \n    return M*p;\n}\n\n// Rotate point p around Y axis (radians)\nvec3 RotateY(float theta, vec3 p)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    mat3 M = mat3( _cos,    0,  -_sin,\n                    0,      1,      0,\n                   _sin,    0,   _cos);\n    \n    return M*p;\n}\n\n// Rotate point p around Z axis (radians)\nvec3 RotateZ(float theta, vec3 p)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    mat3 M = mat3(  _cos,  -_sin,   0,\n                    _sin,   _cos,   0,\n                    0,      0,      1);\n\n    return M*p;\n}\n\n// Rotate point p\nvec3 Rotate(vec3 rot, vec3 p)\n{\n    p = RotateX(rot.x, p);\n    p = RotateY(rot.y, p);\n    p = RotateZ(rot.z, p);\n\n    return p;\n}\n\n\n// Create scaling matrix\nmat3 Scaling(vec3 scale) {\n\n    return mat3(1.0/scale.x,0,          0,\n                0,          1.0/scale.y,0,\n                0,          0,          1.0/scale.z);\n}\n\n// Create rotation matrix for theta angle around X axis (radians)\nmat3 RotationX(float theta)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    return mat3(    1,     0,     0,\n                    0,  _cos, -_sin,\n                    0,  _sin,  _cos);\n}\n\n// Create rotation matrix for theta angle around Y axis (radians)\nmat3 RotationY(float theta)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    return mat3( _cos,     0, -_sin,\n                    0,     1,     0,\n                 _sin,     0,  _cos);\n}\n\n// Create rotation matrix for theta angle around Z axis (radians)\nmat3 RotationZ(float theta)\n{   \n    float _sin = sin(theta);\n    float _cos = cos(theta);\n\n    return mat3(_cos, -_sin,  0,\n                _sin,  _cos,  0,\n                0,     0,     1);\n}\n\n// Create rotation matrix for the 3 axes (radians)\nmat3 Rotation(float x, float y, float z) \n{\n    return RotationZ(z) * RotationY(y) * RotationX(x);\n}\n\n// Create rotation matrix for the 3 axes (radians)\nmat3 Rotation(vec3 rot)\n{\n    return Rotation(rot.x, rot.y, rot.y);\n}\n\n// Create translation matrix\nmat4 Translation(vec3 trans) {\n\n    mat4 M = mat4(1.0);\n    M[3] = vec4(-trans, 1.0);\n\n    return M;\n}\n\n// Create transform matrix \nmat4 Transform(vec3 scale, vec3 rot, vec3 trans) \n{\n    return mat4(Scaling(scale) * Rotation(rot)) * Translation(trans);\n}\n\n// Transform of point p\nvec3 Transform(vec3 scale, vec3 rot, vec3 trans, vec3 p)\n{\n    p = Scale(scale, p);\n    p = Rotate(rot, p);\n    p = Translate(trans, p);\n\n    return p;\n}\n\n// Camera -----------------------------------------------------------------------\n\n\n// Compute the ray\n//      m : Mouse position\n//      p : Pixel\n// ro, rd : Ray origin and direction\nvoid Ray(in vec2 m, in vec2 p,out vec3 ro,out vec3 rd)\n{\n        // focal length\n   \tfloat le = 2.0;\n    \n    // position camera\n    ro=vec3(-40.0,0.0,0.0);\n    \n    // reset camera position\n    // shadertoy initialize mouse pos at (0,0)\n    if (m == vec2(0))\n        m = vec2(0.9, 0.51);\n    \n    m = (m*2.0 - vec2(1.0))*3.0;\n    m.y = clamp(-m.y, -0.05, PI_2 - 0.1); // clamp camera y rotation\n\n    ro = RotateY(m.y, ro);\n    ro = RotateZ(m.x, ro);\n\n    vec3 ww = normalize(-ro);\n    vec3 uu = normalize( cross(ww,vec3(0.0,0.0,1.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\trd = normalize( p.x*uu + p.y*vv + le*ww );\n}\n\n\n\n\n// Sphere \n// p : point\n// c : center \n// r : radius\nTraceData Sphere(vec3 p, vec3 c,float r,int index)\n{\n    return TraceData(length(p-c)-r,index);\n}\n\n// Cube \n// p : point\n// c : center \n// r : radius\nTraceData Cube(vec3 p,vec3 c,vec3 r,int index)\n{\n    vec3 q = abs(p-c) - r;\n    return TraceData(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0),index);\n}\n\n// Plane \n// p : point\n// n : Normal of plane\n// o : Point on plane\nTraceData Plane(vec3 p, vec3 n, vec3 o,int index)\n{\n    return TraceData(dot((p-o),n),index);\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nTraceData Union(TraceData a,TraceData b)\n{\n    if (a.v<b.v)\n        return TraceData(a.v,a.i);\n    else \n    {\n        return TraceData(b.v,b.i);\n    }\n}\n\n// Intersection, preserve the index of first object\n// a, b : field function of left and right sub-trees\nTraceData Intersection(TraceData a,TraceData b)\n{\n    if (a.v>b.v)\n    {\n        return TraceData(a.v,a.i);\n    }\n    else \n    {\n        return TraceData(b.v,a.i);\n    }\n}\n\n\n// https://iquilezles.org/articles/distfunctionsl\n\n// Union with smoothing\n// a : Field function of left sub-tree, \n// b : Field function of right sub-tree\nTraceData SmoothUnion( TraceData a, TraceData b, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(b.v-a.v)/k, 0.0, 1.0 );\n    return TraceData(mix( b.v, a.v, h ) - k*h*(1.0-h), a.i);\n}\n\n// Difference with smoothing\n// a : Field function of left sub-tree, \n// b : Field function of right sub-tree\nTraceData SmoothDiff( TraceData a, TraceData b, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(a.v+b.v)/k, 0.0, 1.0 );\n    return TraceData(mix( a.v, -b.v, h ) + k*h*(1.0-h), a.i); \n}\n\n// Intersection with smoothing\n// a : field function of left sub-tree, \n// b : field function of right sub-tree\nTraceData SmoothInter( TraceData a, TraceData b, float k )\n{\n    float h = clamp( 0.5 - 0.5*(a.v-b.v)/k, 0.0, 1.0 );\n    return TraceData(mix( a.v, b.v, h ) + k*h*(1.0-h), a.i);\n}\n\n\n\n// Dice \n// p : point\n// c : center \n// r : radius\nTraceData Dice(vec3 p,vec3 c,float r,int index)\n{\n    return SmoothInter(Cube(p,c,vec3(r*0.75),index),Sphere(p,c,r,index), 0.05);\n}\n\n// Potential field of the object\n// p : point\nTraceData object(vec3 p)\n{\n    TraceData u = Plane(p,normalize(vec3(0.0,0.0,1.0)),vec3(0.0,0.0,-4.0),0);\n    vec3 dp = vec3(mod(p.xy + vec2(5,0), vec2(10.0)) - 5.0, p.z);\n\n    int index = int(p.x * 0.1 + 2.5);\n    index += int(p.y * 0.1 + 2.0)*3;\n\n    // DEBUG(vec3(float(index==5)))\n    TraceData dices = Dice(dp,vec3( 0.0, 0.0, 2.0),4.0, index);\n    dices = Intersection(dices, Cube(p, vec3(0), vec3(15.0,20.0,5.0), 0));\n    u = Union(u, dices);\n\n    return u;\n}\n\n// Analysis of the scalar field --------------------------------------------------------------------------\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.001;\n  vec3 n;\n  TraceData vp = object(p);\n    float v = vp.v;\n  n.x = object( vec3(p.x+eps, p.y, p.z) ).v - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ).v - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ).v - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// e : Maximum distance \n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, float e,out bool h,out int s)\n{\n    h = false;\n\n    // Start at the origin\n    float t=0.0;\n\n    for(int i=0; i<MAX_STEPS; i++)\n    {\n        s=i;\n        vec3 p = o+t*u;\n        float v = object(p).v;\n        // Hit object\n        if (v < 0.0)\n        {\n            s=i;\n            h = true;\n            break;\n        }\n        // Move along ray\n        t += max(EPSILON,v);\n        // Escape marched too far away\n        if (t>e)\n        {\n            break;\n        }\n    }\n    return t;\n}\n\n// Lighting ----------------------------------------------------------------------------------------------\n\nstruct DirectionalLight {\n    vec3 direction;\n    vec3 color;\n    float energy;\n    float shadow_dist;\n};\n\n// Compute ambient occlusion based on https://www.shadertoy.com/view/3lXyWs\n// p : Point\n// n : Normal at point\nfloat AmbientOcclusion(vec3 p,vec3 n) {\n\n    const int AO_STEPS = 4;\n    const float AO_MAX_DIST = 3.0;\n\n    const float SCALE = AO_MAX_DIST / pow(2.0, float(AO_STEPS))*2.0;\n    float ocl = 0.0;\n\n    for(int i = 1; i <= AO_STEPS; ++i) {\n        float dist = pow(2.0, float(i)) * SCALE;\n        ocl += 1.0 - (max(0.0, object(p + n * dist).v) / dist);\n    }\n    \n    return min(1.0-(ocl / float(AO_STEPS)),1.0);\n    // return pow(abs(object(p + 2.0 * n)),0.9);\n}\n\n\n// Cast soft shadow based on https://www.shadertoy.com/view/tlBcDK\n// p : Point\n// l : Point to light vector\n// d : Max tracing distance\n// r : Softness radius\nfloat Shadow(vec3 p,vec3 l, float d, float r)\n{\n\n    float res = 1.0;\n    float t = 0.1;\n\n    for (int i = 0; i < MAX_STEPS; ++i) {\n\n        if (res < 0.0 || t > d)\n            break;\n    \n        float h = object(p+t*l).v;\n\n        res = min(res, r * h / t);\n        t += h;    \n    }    \n\n    return clamp(res, 0.0, 1.0);\n}\n\n\n// Shading and lighting ---------------------------------------------------------------------------\n\n// Fractal brownian motion\nfloat Fbm(vec3 p, int octave) {\n\n    float v = 0.,  a = .5;\n    mat3 R = RotationX(.37);\n\n    for (int i = 0; i < octave; ++i, p*=2.0, a/=2.0) \n        p *= R,\n        v += a * Noise(p);\n\n    return v;\n}\n\n// Voronoi fractal brownian motion\nvec3 FbmVoronoi(vec3 p, int octave) {\n\n    vec3 v = vec3(0.0);\n    float a = 0.5;\n    mat3 R = RotationX(.37);\n\n    for (int i = 0; i < octave; ++i, p*=2.0, a/=2.0) \n        p *= R,\n        v += a * Voronoi(p);\n\n    return v;\n}\n\n\n// saturate\nfloat sat(float x) {\n\n    return clamp(x, 0.0, 1.0);\n}\n\n// saturate\nvec3 sat(vec3 x) {\n\n    return clamp(x, 0.0, 1.0);\n}\n\n\nMaterial MixMaterial(Material a, Material b, float t) {\n\n    Material mat;\n\n    mat.albedo = mix(a.albedo, b.albedo, t);\n    mat.roughness = mix(a.roughness, b.roughness, t);\n    mat.emissive = mix(a.emissive, b.emissive, t);\n    mat.clearcoat = mix(a.clearcoat, b.clearcoat, t);\n    mat.metallic = mix(a.metallic, b.metallic, t);\n\n    return mat;\n}\n\n\nMaterial MatFloor(vec3 p, vec3 n) {\n\n    Material mat;\n\n    float checker = mod(dot(ceil(p*0.2), vec3(1)), 2.0);\n\n    vec3 v = Voronoi(p + 2.45 + Fbm(p*1.5, 4)*2.0);\n\n    float fact = sat(pow(v.x*0.9,10.0));\n    float bt = sat(pow(v.z*0.0025, 0.7));\n\n    mat.albedo = vec3(fact);\n\n    vec3 marble = mix(vec3(0.9,0.87,0.85), \n                vec3(0.08,0.07,0.05), abs(fact-checker));\n\n    mat.albedo = marble;\n    mat.roughness = v.x*0.05 + 0.05;\n\n    return mat;\n}\n\n\nMaterial MatCarCoat(vec3 p, vec3 n) {\n\n    Material mat;\n\n    float glitters = Noise(p*25.0);\n\n    mat.albedo = mix(vec3(1,0,0), vec3(0.7,0,0), glitters);\n    mat.metallic = 1.0;\n    mat.roughness = glitters * 0.1 + 0.3;\n    mat.clearcoat = 1.0;\n\n    return mat;\n}\n\n\nMaterial MatAmbers(vec3 p, vec3 n) {\n\n    Material mat;\n\n    vec3 v = FbmVoronoi(p*vec3(3,2.0,2.0), 3);\n\n    float t = pow(1.0-v.y, 2.0);\n    float ef = pow(v.x, 6.0);\n    float bf = Noise(p*2.0 + iTime);\n\n    mat.emissive = mix(vec3(1,0.01,0),\n                        vec3(0.980, 0.321, 0),\n                        sat(pow(ef*pow(bf, 5.0)*4.0,0.2)));\n\n    mat.emissive *= pow(sat(ef*4.0),2.0)*bf*7.0;\n\n    float r = pow(Voronoi(p*2.0 + Fbm(p*2.0, 3)*2.0).x, 10.0);\n    r += Fbm(p, 4)*0.5 + ef;\n\n    mat.roughness = min(r*2.0, 1.0);\n    mat.albedo = vec3((1.0-mat.roughness)*0.01);\n    return mat;\n}\n\n\nMaterial MatWood(vec3 p, vec3 n) {\n\n    Material mat;\n\n    p += Fbm(p*0.9, 3)*1.0;\n    p.x += 1.0;\n\n    mat.roughness = 0.05;\n    vec3 v =  FbmVoronoi(p*vec3(2,0.02,0.0), 3);\n    float t = sat(pow(v.x*2.0 ,3.0));\n    vec3 a = mix(vec3(0.247, 0.105, 0.054), vec3(0.5,0.2,0.1), t);\n\n    mat.albedo = a;\n    mat.roughness = v.x;\n\n    return mat;\n}\n\n\nMaterial MatBurnedWood(vec3 p, vec3 n) {\n\n    Material mat;\n\n    p = RotateZ(-0.2, p);\n\n    float fact = smoothstep(0.5, 0.55, Fbm(p*0.14, 5));\n\n    Material wood = MatWood(p, n);\n    Material ambers = MatAmbers(p, n);\n\n    return MixMaterial(wood, ambers, fact);\n}\n\n\nMaterial MatMoss(vec3 p ,vec3 n) {\n    \n    Material mat;\n\n    float t = Noise(p*15.0);\n\n    mat.albedo = mix(\n                    mix(\n                        vec3(0.125, 0.074, 0.015),\n                        vec3(0.145, 0.105, 0.011),\n                        Fbm(p*3.0, 2)*2.0),\n                    mix(vec3(0.113, 0.2, 0.062),\n                        vec3(0.074, 0.156, 0.023),t),\n                    sat(Noise(p)*1.0)\n                );\n    \n    mat.roughness = min(t*0.3 + 0.5, 1.0);\n    \n    return mat;\n}\n\n\nMaterial MatSoil(vec3 p, vec3 n) {\n\n    Material mat;\n\n    vec3 v = FbmVoronoi(p*0.2, 3);\n    float stone =  max(1.0 - pow(v.y, 3.0)*3.0, 0.0 );\n    stone = max(stone, Fbm(p*0.5, 4));\n\n    stone = pow(sat(stone), 2.0)*0.7;\n\n    Material moss = MatMoss(p, n);\n    float t = min(pow(Voronoi(p*0.75).x + 0.2, 5.0), 1.0);\n    // float fact = \n    mat.albedo = vec3(stone);\n    mat.roughness = Fbm(p, 3);\n\n    return MixMaterial(mat, moss, t);\n}\n\n\nMaterial MatMarble(vec3 p, vec3 n) {\n\n    Material mat;\n\n    vec3 v = Voronoi(p*0.7+ Fbm(p*1.5, 4)*2.0);\n    float fact = sat(pow(v.x*1.1,5.0));\n    float bt = sat(pow(v.z*0.0025, 0.7));\n\n\n    mat.albedo = mix(vec3(0.9,0.87,0.85), \n                vec3(0.17,0.15,0.1), fact);\n\n    mat.roughness = 1.0-v.x;\n    mat.metallic = 0.0;\n    mat.clearcoat = 0.7;\n\n    return mat;\n}\n\n\nMaterial MatGranite(vec3 p, vec3 n) {\n\n    Material mat;\n\n    float fact = pow(sat(Fbm(p*7.0, 3)*2.5),4.0);\n\n    mat.albedo = mix(\n                    vec3(0.019, 0.023, 0.015),\n\n                    mix(vec3(0.596, 0.560, 0.580),\n                        vec3(0.141, 0.137, 0.141),\n                        smoothstep(0.0, 0.7, Fbm(p*7.0,3))),\n                    fact);\n\n    mat.roughness = min(fact + 0.2, 1.0);\n    mat.clearcoat = 1.0;\n\n    return mat;\n}\n\n\nMaterial MatLava(vec3 p, vec3 n) {\n\n    Material mat;\n    float fact = pow(FbmVoronoi(p*0.5 + vec3(0,0,iTime*0.2), 3).x*1.2, 3.0);\n    vec3 em = mix(vec3(1,0.01,0), vec3(1,0.3,0.1), fact);\n    float solid = smoothstep(0.0, 0.5, fact);\n\n    mat.emissive = em*solid*20.0;\n\n    mat.roughness = sat(solid*2.0 + 0.8) ;\n\n    return mat;\n}\n\n\nMaterial MatRust(vec3 p, vec3 n) {\n\n    Material mat;\n\n    float var = min(Noise(p*20.0)*0.3 + 0.3 + Fbm(p, 3)*0.5, 1.0);\n\n    mat.albedo = vec3(0.129, 0.023, 0.007)*var;\n    mat.roughness = var;\n\n    return mat;\n}\n\n\nMaterial MatRustedMetal(vec3 p, vec3 n) {\n\n    Material mat;\n\n    float var = Fbm(p,4);\n\n    mat.albedo = vec3(var*0.1 + 0.2);\n    mat.metallic = 1.0;\n    mat.roughness = var*0.2+0.1;\n\n    Material rust = MatRust(p, n);\n\n    float fact = sat(Fbm(vec3(p.xy*2.0, 0), 3) - p.z*0.2 + 0.3);\n\n    return MixMaterial(rust, mat, fact);\n}\n\n\nMaterial MatBricks(vec3 p, vec3 n) {\n\n    Material mat;\n\n    float var = Fbm(p*2.0, 4)*2.0;\n    mat.roughness = var*0.3 + 0.7;\n    p += var*0.07;\n    p.z += 0.1;\n\n    float fact = smoothstep(0.4, 0.6,abs(fract(p.z) - 0.5));\n    p.xy = p.xy*0.4 + 0.5 + mod(ceil(p.z), 2.0)*0.5;\n\n    vec2 xy = smoothstep(0.45, 0.55, abs(fract(p.xy) - 0.5));\n    fact = max(fact, max(xy.x , xy.y));\n\n    vec3 brick = vec3(ceil(p.z),ceil(p.xy));\n    var += Hash3(brick)-0.5;\n\n    brick = vec3(vec3(0.133, 0.015, 0.007) + var*0.04);\n\n    mat.albedo = mix(brick, vec3(1.0,0.95,0.9), fact);\n\n    return mat;\n}\n\n\nMaterial MatAsphalt(vec3 p, vec3 n) {\n\n    Material mat;\n    float disp = Fbm(p*4.0,4)*0.05;\n\n    vec3 v = Voronoi(p*12.0);\n    vec3 asphalt = vec3(0.05-v.y*0.04);\n    float t = smoothstep(0.27, 0.3, abs(fract((p.x+p.y)*0.35) - 0.5 + disp));\n\n    t *= max((Fbm(p*0.7,4)-0.3)*2.0, 0.0);\n\n    mat.albedo = mix(asphalt,\n                    vec3(0.6,0.2,0), t);\n\n    mat.roughness = min(mix(v.x*5.0 + 0.5, 0.5, t), 1.0);\n\n    return mat;\n}\n\n\nMaterial MatGold(vec3 p, vec3 n) {\n\n    Material mat;\n    \n    mat.albedo = vec3(1, 0.317, 0.039);\n    mat.metallic = 1.0;\n    mat.roughness == 0.0;\n\n    return mat;\n}\n\n\nMaterial  MatRustyPaint(vec3 p, vec3 n) {\n\n    Material mat;\n    p.z += 5.0;\n\n    float fact = 1.0 - smoothstep(0.25, 0.45, Fbm(p*0.5, 4));\n    float paint = 1.0;\n    vec3 pp = p;\n    mat3 R = RotationX(0.37);\n    float a = 0.5;\n\n    for (int i = 0; i < 3; ++i, pp*=2.0) {\n        pp = R*pp;\n        paint -= a*VoronoiE(pp).x;\n    }\n\n    paint = sat(pow(paint*2.0-0.8, 4.0));\n\n    // overlay blending\n    if (fact  < 0.5)\n        fact = 2.0*fact*paint;\n    else\n        fact = 1.0 - 2.0*(1.0-fact)*(1.0-paint);\n    \n    float var = Fbm(p, 4);\n    mat.albedo = vec3(0.074, 0.117, 0.203)*(var*0.3 + 0.5);\n    mat.roughness = 0.3 + var*0.3;\n\n    return MixMaterial(mat, MatRust(p, n), fact);\n}\n\nMaterial PlanarCarbonFiber(vec2 p) {\n\n    Material mat;\n\n    float offset = ceil(p.x*10.0)*0.3;\n    float stride = fract((p.y*2.0)+offset);\n\n    mat.albedo = vec3(ceil(stride-0.5)*0.01);\n    mat.roughness = max(1.0-stride*0.7 + 0.1, 0.0);\n    mat.clearcoat = 1.0;\n\n    return mat;\n}\n\nMaterial MatCarbonFiber(vec3 p, vec3 n) {\n\n    // triplanar projection\n    Material result = \n        MixMaterial(MixMaterial(PlanarCarbonFiber(p.xz),\n                                PlanarCarbonFiber(p.yz),\n                                pow(abs(n.x),5.0)),\n                    PlanarCarbonFiber(p.xy),\n                    pow(abs(n.z),5.0));\n    \n    return result;\n}\n\n\nMaterial MatPlastic(vec3 p, vec3 n) {\n\n    Material mat;\n    mat.albedo = vec3(1);\n    mat.metallic = 0.0;\n    mat.roughness = 0.2;\n    return mat;\n}\n\n\n// Compute texture \n// p : Point\n// n : Normal\nMaterial ComputeMaterial(in vec3 p, in vec3 n)\n{\n    TraceData vp= object(p);\n\n    switch (vp.i) {\n\n        case MATERIAL_FLOOR_TILES: return MatFloor(p, n);\n        case MATERIAL_CAR_COAT: return MatCarCoat(p, n);\n        case MATERIAL_BURNED_WOOD: return MatBurnedWood(p, n);\n        case MATERIAL_SOIL: return MatSoil(p, n);\n        case MATERIAL_MARBLE: return MatMarble(p, n);\n        case MATERIAL_GRANITE: return MatGranite(p, n);\n        case MATERIAL_LAVA: return MatLava(p, n);\n        case MATERIAL_RUSTED_METAL: return MatRustedMetal(p, n);\n        case MATERIAL_BRICKS: return MatBricks(p, n);\n        case MATERIAL_ASPHALT: return MatAsphalt(p, n);\n        case MATERIAL_GOLD: return MatGold(p, n);\n        case MATERIAL_RUSTY_PAINT:return MatRustyPaint(p, n);\n        case MATERIAL_CARBON_FIBER:return MatCarbonFiber(p, n);\n        default: return MatPlastic(p, n);\n    }\n}\n\n// Sky --------------------------------------------------------------------------------\n\n// Atmospheric scattering based on preetham's analytical model\n// https://github.com/vorg/pragmatic-pbr/blob/master/local_modules/glsl-sky/index.glsl\n\n\nconst float turbidity = 10.0;\nconst float reileighCoefficient = 2.0;\nconst float mieCoefficient = 0.005;\nconst float mieDirectionalG = 0.75;\n\n// constants for atmospheric scattering\n\nconst float n = 1.0003; // refractive index of air\nconst float N = 2.545E25; // number of molecules per unit volume for air at\n// 288.15K and 1013mb (sea level -45 celsius)\nconst float pn = 0.035; // depolatization factor for standard air\n\n// wavelength of used primaries, according to preetham\nconst vec3 lambda = vec3(680E-9, 550E-9, 450E-9);\n\n// mie stuff\n// K coefficient for the primaries\nconst vec3 K = vec3(0.686, 0.678, 0.666);\nconst float V = 4.0;\n\n// optical length at zenith for molecules\nconst float rayleighZenithLength = 8.4E3;\nconst float mieZenithLength = 1.25E3;\nconst vec3 up = vec3(0.0, 0.0, 1.0);\n\nconst float EE = 1000.0;\nconst float AngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;\n// 66 arc seconds -> degrees, and the cosine of that\n\n// earth shadow hack\nconst float cutoffAngle = PI/1.95;\nconst float steepness = 1.5;\n\n\nvec3 totalRayleigh(vec3 lambda)\n{\n    return (8.0 * pow(PI, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn));\n}\n\nfloat rayleighPhase(float cosTheta)\n{\n    return (3.0 / (16.0*PI)) * (1.0 + pow(cosTheta, 2.0));\n    // return (1.0 / (3.0*PI)) * (1.0 + pow(cosTheta, 2.0));\n    // return (3.0 / 4.0) * (1.0 + pow(cosTheta, 2.0));\n}\n\nvec3 totalMie(vec3 lambda, vec3 K, float T)\n{\n    float c = (0.2 * T ) * 10E-18;\n    return 0.434 * c * PI * pow((2.0 * PI) / lambda, vec3(V - 2.0)) * K;\n}\n\nfloat hgPhase(float cosTheta, float g)\n{\n    return (1.0 / (4.0*PI)) * ((1.0 - pow(g, 2.0)) / pow(1.0 - 2.0*g*cosTheta + pow(g, 2.0), 1.5));\n}\n\nfloat sunIntensity(float zenithAngleCos)\n{\n    return max(0.0, 1.0 - exp(-((cutoffAngle - acos(zenithAngleCos))/steepness)));\n}\n\n\n\nvoid AtmosphericScattering(DirectionalLight light, vec3 worldNormal, \n    out float cosTheta, out vec3 Lin, out vec3 Fex) \n{\n\n    vec3 lightDirection = light.direction;\n    float lightEnergy = light.energy;\n\n    float sunfade = 1.0-clamp(1.0- exp(light.direction.z / 450000.0) ,0.0,1.0);\n\n    float reileigh = reileighCoefficient - (1.0-sunfade);\n\n    // extinction (absorbtion + out scattering)\n    // rayleigh coefficients\n    vec3 betaR = totalRayleigh(lambda) * reileigh;\n\n    // mie coefficients\n    vec3 betaM = totalMie(lambda, K, turbidity) * mieCoefficient;\n\n    // optical length\n    // cutoff angle at 90 to avoid singularity in next formula.\n    //float zenithAngle = acos(max(0.0, dot(up, normalize(vWorldPosition - cameraPos))));\n    float zenithAngle = acos(max(0.0, dot(up, worldNormal)));\n    float sR = rayleighZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / PI), -1.253));\n    float sM = mieZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / PI), -1.253));\n\n\n    // combined extinction factor\n    Fex = exp(-(betaR * sR + betaM * sM));\n\n    // in scattering\n    cosTheta = dot(worldNormal, lightDirection);\n\n    float rPhase = rayleighPhase(cosTheta*0.5+0.5);\n    vec3 betaRTheta = betaR * rPhase;\n\n    float mPhase = hgPhase(cosTheta, mieDirectionalG);\n    vec3 betaMTheta = betaM * mPhase;\n\n\n    Lin = pow(lightEnergy * ((betaRTheta + betaMTheta) / (betaR + betaM)) * (1.0 - Fex),vec3(1.5));\n    Lin *= mix(vec3(1.0),pow(lightEnergy * ((betaRTheta + betaMTheta) / (betaR + betaM)) * Fex,vec3(1.0/2.0)),clamp(pow(1.0-dot(up, lightDirection),5.0),0.0,1.0));\n}\n\n\nvec3 AtmosphericScattering(DirectionalLight sun, vec3 viewDir) {\n\n    float cosTheta;\n    vec3 Lin;\n    vec3 Fex;\n\n    AtmosphericScattering(sun, viewDir, cosTheta, Lin, Fex);\n\n    vec3 texColor = Lin*0.04;\n    texColor += vec3(0.0,0.001,0.0025)*0.3;\n\n    return texColor;\n}\n\n\n// Get sky color\nvec3 Sky(DirectionalLight sun, vec3 viewDir) {\n\n    float CosTheta;\n    vec3 Lin;\n    vec3 Fex;\n\n    AtmosphericScattering(sun, viewDir, CosTheta, Lin, Fex);\n\n    float sundisk = smoothstep(AngularDiameterCos,AngularDiameterCos+0.00002,CosTheta);\n    vec3 L0 = sun.energy * 19000.0 * sundisk * Fex;\n\n    vec3 texColor = (Lin + L0) * 0.04;\n    texColor += vec3(0.0,0.001,0.0025)*0.3;\n\n    return texColor;\n}\n\n\nvec3 SkyExtinxtion(DirectionalLight light) \n{\n\n    float sunfade = 1.0-clamp(1.0-exp(light.direction.z),0.0,1.0);\n\n    float reileigh = reileighCoefficient - (1.0-sunfade);\n\n    // rayleigh coefficients\n    vec3 betaR = totalRayleigh(lambda) * reileigh;\n\n    // mie coefficients\n    vec3 betaM = totalMie(lambda, K, turbidity) * mieCoefficient;\n\n    // sun optical length\n    float zenithAngle = acos(max(0.0, dot(up, light.direction)));\n    float sR = rayleighZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / PI), -1.253));\n    float sM = mieZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / PI), -1.253));\n\n    // combined extinction factor\n    return exp(-(betaR * sR + betaM * sM));\n}\n\n\n\nvec3 Env(vec3 view, DirectionalLight sun) {\n\n    float cosTheta;\n    vec3 Lin;\n    vec3 Fex;\n\n    AtmosphericScattering(sun, view, cosTheta, Lin, Fex);\n\n    vec3 L0 = Fex * 0.1;\n\n    vec3 texColor = (Lin+L0) * 0.04;\n    texColor += vec3(0.0,0.001,0.0025)*0.3;\n\n\n    return texColor;\n}\n\n// PBR -------------------------------------------------------------------------\n\n//https://gist.github.com/galek/53557375251e1a942dfa\n\n// Get sky ambient color\n// sunDirection : Sun direction\n// worldNormal : Ray direction\nvec3 SkyAmbient(DirectionalLight sun) {\n\n    return Env(normalize(sun.direction*1.8 + vec3(0,0,1)), sun);\n}\n\n\n// phong (lambertian) diffuse term\nfloat phong_diffuse()\n{\n    return (1.0 / PI);\n}\n\n\n// compute fresnel specular factor for given base specular and product\n// product could be NdV or VdH depending on used technique\nvec3 fresnel_factor(in vec3 f0, in float product)\n{\n    return mix(f0, vec3(1.0), pow(1.01 - product, 5.0));\n}\n\n\n// following functions are copies of UE4\n// for computing cook-torrance specular lighting terms\n\nfloat D_blinn(in float roughness, in float NdH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float n = 2.0 / m2 - 2.0;\n    return (n + 2.0) / (2.0 * PI) * pow(NdH, n);\n}\n\nfloat D_beckmann(in float roughness, in float NdH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float NdH2 = NdH * NdH;\n    return exp((NdH2 - 1.0) / (m2 * NdH2)) / (PI * m2 * NdH2 * NdH2);\n}\n\nfloat D_GGX(in float roughness, in float NdH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float d = (NdH * m2 - NdH) * NdH + 1.0;\n    return m2 / (PI * d * d);\n}\n\nfloat G_schlick(in float roughness, in float NdV, in float NdL)\n{\n    float k = roughness * roughness * 0.5;\n    float V = NdV * (1.0 - k) + k;\n    float L = NdL * (1.0 - k) + k;\n    return 0.25 / (V * L);\n}\n\n\n// cook-torrance specular calculation                      \nvec3 cooktorrance_specular(in float NdL, in float NdV, in float NdH, in vec3 specular, in float roughness)\n{\n#if SPECULAR_MODE == SPECULAR_BLINN\n    float D = D_blinn(roughness, NdH);\n#elif SPECULAR_MODE == SPECULAR_BECKMANN\n    float D = D_beckmann(roughness, NdH);\n#elif SPECULAR_MODE == SPECULAR_GGX\n    float D = D_GGX(roughness, NdH);\n#endif\n\n    float G = G_schlick(roughness, NdV, NdL);\n\n    float rim = mix(1.0 - roughness * 0.9, 1.0, NdV);\n\n    return max((1.0 / rim) * specular * G * D, 0.0);\n}\n\n\n// Picture in picture ------------------------------------------------------------------------------\n\n// Shading according to the number of steps in sphere tracing\n// n : Number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(MAX_STEPS-1));\n   return 0.5+mix(vec3(0.05,0.05,0.5),vec3(0.65,0.39,0.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel, out bool pip)\n{\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {    \n    const float fraction=1.0/4.0;\n    // Recompute pixel coordinates in sub-picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        p=(-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip=true;\n    }\n       else\n       {\n           pip=false;\n       }\n   }\n   return p;\n}\n\n// Background color\nvec3 background(vec3 r, DirectionalLight sun)\n{\n    return Sky(sun, r);\n    // return mix(vec3(0.452,0.551,0.995),vec3(0.652,0.697,0.995), d.z*0.5+0.5);\n}\n\n\n// Tone mappin -------------------------------------------------------------------\n\n// based on https://www.shadertoy.com/view/ldcSRN\n\nconst float W =11.2; // white scale\n\n// filmic (John Hable)\n\n\nconst float A = 0.22; // shoulder strength\nconst float B = 0.3; // linear strength\nconst float C = 0.1; // linear angle\nconst float D = 0.20; // toe strength\nconst float E = 0.01; // toe numerator\nconst float F = 0.30; // toe denominator\n\nvec3 LinearToSRGB(vec3 x) \n{\n    vec3 t = step(x,vec3(0.0031308));\n    return mix(1.055*pow(x, vec3(1./2.4)) - 0.055, 12.92*x, t);\n}\n\n\nvec3 Gamma(vec3 color, float gamma) \n{\n    return pow(color, vec3(gamma));\n}\n\n\nvec3 Uncharted2Curve(vec3 x)\n{\n    float A = 0.15;\n    float B = 0.50;\n    float C = 0.10;\n    float D = 0.20;\n    float E = 0.02;\n    float F = 0.30;\n\n    return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n\nvec3 Uncharted2(vec3 color)\n{\n    vec3 white_scale = Uncharted2Curve(vec3(W));\n    return Uncharted2Curve(color) / white_scale;\n}\n\n\nvec3 ReinhardCurve (vec3 x)\n{\n\treturn x / (1.0 + x);\n}\n\nvec3 Reinhard(vec3 color) \n{\n    vec3 white_scale = ReinhardCurve(vec3(W));\n    return ReinhardCurve(color) / white_scale;\n}\n\n\nvec3 FilmicReinhardCurve (vec3 x) \n{\n    const float T = 0.01;\n    vec3 q = (T + 1.0)*x*x;\n\treturn q / (q + x + T);\n}\n\nvec3 FilmicReinhard(vec3 color) \n{\n    vec3 white_scale = FilmicReinhardCurve(vec3(W));\n    return FilmicReinhardCurve(color) / white_scale;\n}\n\n\nvec3 FilmicCurve(vec3 x)\n{\n\treturn ((x*(0.22*x+0.1*0.3)+0.2*0.01)/(x*(0.22*x+0.3)+0.2*0.3))-0.01/0.3;\n}\n\nvec3 Filmic(vec3 color)\n{\n    vec3 white_scale = FilmicCurve(vec3(W));\n    return FilmicCurve(color) / white_scale;\n}\n\n\nvec3 ACESFitted(vec3 color) {\n\n    color = pow(color, vec3(0.833));\n    color *= 1.07;\n\n    const mat3 ACESInput = mat3(\n        0.59719, 0.35458, 0.04823,\n        0.07600, 0.90834, 0.01566,\n        0.02840, 0.13383, 0.83777\n    );\n\n    const mat3 ACESOutput = mat3(\n        1.60475, -0.53108, -0.07367,\n        -0.10208,  1.10813, -0.00605,\n        -0.00327, -0.07276,  1.07602\n    );\n\n\n    color = color * ACESInput;\n\n    // Apply RRT and ODT\n    vec3 a = color * (color + 0.0245786) - 0.000090537;\n    vec3 b = color * (0.983729 * color + 0.4329510) + 0.38081;\n    color = a/b;\n\n    return color * ACESOutput;\n}\n\n\nvec3 ToneMapping(vec3 color) {\n\n    color = color*0.2;\n\n    #if TONEMAP_MODE == TONEMAP_FILMIC\n        color = Filmic(color);\n    #elif TONEMAP_MODE == TONEMAP_REINHARD\n        color = Reinhard(color);\n    #elif TONEMAP_MODE == TONEMAP_FILMIC_REINHARD\n        color = FilmicReinhard(color);\n    #elif TONEMAP_MODE == TONEMAP_UNCHARTED2\n        color = Uncharted2(color);\n    #elif TONEMAP_MODE == TONEMAP_ACES\n        color = ACESFitted(color);\n    #endif\n\n    color = clamp(LinearToSRGB(color), 0.0, 1.0);\n\n    return color;\n}\n\n// Compute Blinn-Phong specular\n// l : Vector to light\n// n : Normal at point\n// r : View ray direction\n// k : glossyness\nfloat Specular(vec3 l, vec3 n, vec3 r, float k)\n{\n    vec3 half_dir = normalize(l + r);\n    float spec_angle = max(dot(half_dir, n), 0.0);\n    return pow(spec_angle, k);\n\n    // Phong\n//     vec3 ref = reflect(r, n);\n//     float c = max(dot(ref, r), 0.0);\n//     return pow(c, k/4.0);\n}\n\n\n// Compute lighting\n// sun : Sun data\n// mat : Material data\n// p : Point on surface\n// rd : View ray direction\n// n : Normal at Point\n// reflection : Computed reflection\n// clearcoat : Computed clearcoat reflection\n vec3 Shade(DirectionalLight sun, Material mat, vec3 p, vec3 rd, vec3 n, \n    vec3 reflection, vec3 clearcoat) \n{\n\n    // Ambient color\n    vec3 ambient = SkyAmbient(sun) * 0.7;\n\n    // Ambient occlusion\n    ambient *= AmbientOcclusion(p, n);\n\n    // vec3 diffuse = ambient;\n    vec3 specular = mix(vec3(0.02), mat.albedo, mat.metallic);\n\n\n    vec3 L = sun.direction;\n    vec3 N = n;\n    vec3 V = -rd;\n    vec3 H = normalize(V+L);\n\n    float NdL = max(0.000, dot(N, L));\n    float NdV = max(0.001, dot(N, V));\n    float NdH = max(0.001, dot(N, H));\n    float HdV = max(0.001, dot(H, V));\n\n\n    // specular reflectance with COOK-TORRANCE\n    vec3 specfresnel = fresnel_factor(specular, HdV);\n    vec3 specref = cooktorrance_specular(NdL, NdV, NdH, specfresnel, mat.roughness);\n\n    specref *= vec3(NdL);\n\n    // diffuse is common for any model\n    vec3 diffref = (vec3(1.0) - specfresnel) * phong_diffuse() * NdL;\n\n    // visibility\n    float s = Shadow(p+n*0.1, L, sun.shadow_dist, 20.0);\n    \n    // compute lighting\n    vec3 reflected_light = vec3(0);\n    vec3 diffuse_light = vec3(0);\n\n    // point light\n    vec3 light_color = sun.color * sun.energy * 0.01;\n    reflected_light += specref * light_color * s;\n    diffuse_light += diffref * light_color * s;\n\n    reflected_light += min(vec3(0.99), fresnel_factor(specular, NdV)) * reflection;\n    reflected_light += min(vec3(0.99), fresnel_factor(vec3(0.02), NdV)) * clearcoat * 0.2;\n    diffuse_light += ambient * (1.0 / PI);\n\n    // final result\n    vec3 result = diffuse_light * mix(mat.albedo, vec3(0.0), mat.metallic);\n    result += reflected_light;\n    result += mat.emissive;\n\n    return result;\n}\n\n\n\n// Sample color from ray\n// sun : Sun light\n// ro : Ray origin\n// rd : Ray direction\n// steps : Number of trace steps\nvec3 ShadeRay(DirectionalLight sun, vec3 ro, vec3 rd, out int steps) {\n\n    // Hit and number of steps\n    bool hit;\n    int s;\n    \n    // primary ray\n    float t = SphereTrace(ro, rd, 100.0, hit, s);\n    steps += s;\n\n    // Position \n    vec3 pt = ro + t * rd;\n\n    if (!hit)\n        return background(rd, sun);\n\n    // Compute normal\n    vec3 n = ObjectNormal(pt);\n\n    // Shade object with light\n    Material mat = ComputeMaterial(pt, n);\n    vec3 reflect_dir = reflect(rd, n);\n    vec3 clearcoat = vec3(0);\n    vec3 reflection;\n\n    // reflection\n    if (mat.clearcoat > 0.0 || mat.roughness == 0.0) {\n\n        // secondary ray\n        t = SphereTrace(pt+n*0.01, reflect_dir, 100.0, hit, s);\n        steps += s;\n\n        if (hit) {\n            vec3 rpt = pt + t * reflect_dir;\n            vec3 rn = ObjectNormal(rpt);\n            Material rmat = ComputeMaterial(rpt, rn);\n\n            vec3 sec_reflection = Env(reflect(reflect_dir, rn), sun);\n            clearcoat = Shade(sun, rmat, rpt, reflect_dir, rn, \n                            sec_reflection, sec_reflection*mat.clearcoat);\n        } else\n            clearcoat = Env(reflect_dir, sun);\n    }\n    if (mat.roughness == 0.0)\n        reflection = clearcoat;\n    else {\n        float r = 1.0/max(mat.roughness, 0.00001);\n        float v = Shadow(pt+n*0.1, reflect_dir, 1000.0, r);\n        reflection = mix(SkyAmbient(sun)*0.1, Env(reflect_dir, sun), v);\n    }\n\n\n    clearcoat *= mat.clearcoat;\n\n    return Shade(sun, mat, pt, rd, n, reflection, clearcoat);\n}\n\n\n// Image\nvoid mainImage(out vec4 color, in vec2 pxy )\n{\n    // Picture in picture on\n    bool pip=true;\n\n    // Pixel\n        vec2 pixel=Pip(pxy, pip);\n\n    // Mouse\n    vec2 m=iMouse.xy/iResolution.xy;\n\n    // Camera\n    vec3 ro,rd;\n    Ray(m,pixel,ro,rd);\n\n    // Shade background\n    DirectionalLight sun;\n    sun.direction = normalize(vec3(1,0.5,0.7));\n    sun.color = SkyExtinxtion(sun)* 19.0;\n    sun.energy = sunIntensity(sun.direction.z) * EE;\n    sun.shadow_dist = 100.0;\n\n    int s;\n\n    CATCH_DEBUG(vec3 rgb = ShadeRay(sun, ro, rd, s));\n\n    rgb = ToneMapping(rgb);\n\n    // Uncomment this line to shade image with false colors representing the number of steps\n    if (pip==true)\n        rgb = ShadeSteps(s); \n\n\n#if _DEBUG\n    rgb = _debug_color;\n#endif\n    color = vec4(rgb, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}