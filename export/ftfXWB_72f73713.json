{"ver":"0.1","info":{"id":"ftfXWB","date":"1626405046","viewed":210,"name":"Base ray march","username":"tbx","description":"这是一个基础的ray march shader参考","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//https://iquilezles.org/articles/distfunctions/\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n\t//float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\t//return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// 球\nfloat dofSphere(vec3 p, vec3 center, float radius)\n{\n    float d = length(p - center) - radius;\n    return d;\n}\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n\n// 立方体\nfloat dofBox(vec3 p, vec3 center, vec3 border)\n{\n    vec3 pt = p - center;\n    vec3 q = abs(pt) - border;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// 简单的dof场景\nfloat getDistanceScene(vec3 p)\n{\n    mat3 rotate = rotateY(sin(iTime) * 3.1415);\n    vec3 boxLocate = vec3(0.6, -0.4, 0.0);\n    \n    float d1 = dofSphere(p, vec3(-0.6, -0.2, 0.0), 0.2);\n    float d2 = dofBox(rotate * p, rotate * boxLocate, vec3(0.2, 0.2, 0.2));\n    \n    float d3 = dofSphere(p, vec3(0.34, -0.3, 0.0), 0.2);\n\n    float result = min(d1, d2);\n    \n    result = differenceSDF(result, d3);\n    \n    vec3 plane = vec3(0.0, -0.6, 0.0);\n    float disPlane = p.y - plane.y;\n    \n    result = min(result, disPlane);\n    \n    return result;\n}\n\nfloat rayMarch(vec3 rs, vec3 rd)\n{\n    const int max_step = 100; // 循环次数\n    const float max_distance = 100.0; // 最大前进距离\n    const float min_distance = 1e-5; // 相交距离\n    \n    float ro = 0.0;\n    for(int i = 0; i < max_step; i++)\n    {\n        vec3 p = rs + rd * ro;\n        // 查询射线和场景物体的最小距\n        float ds = getDistanceScene(p);\n        // 射线前进\n        ro += ds;\n        // 达到最大距离，或与物体相交则结束\n        if(ro > max_distance || ds < min_distance)\n        {\n            break;\n        }\n    }\n    // 返回最终前进的步长\n    return ro;\n}\n\n// https://iquilezles.org/articles/normalsSDF\n// 求导计算法线\nvec3 generateNormal(vec3 p)\n{\n    float biase = 1e-2;\n    vec2 os = vec2(biase, 0.0);\n    \n    float d = getDistanceScene(p);\n    \n    vec3 n = d - vec3(getDistanceScene(p - os.xyy),\n                      getDistanceScene(p - os.yxy),\n                      getDistanceScene(p - os.yyx));\n                    \n    return normalize(n);\n}\n\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    float t = mint;\n    for( int i=0; i<256 && t<maxt; i++ )\n    {\n        float h = getDistanceScene(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        t += h;\n    }\n    return 1.0;\n}\n\n//https://iquilezles.org/articles/rmshadows/\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float w )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    float t = mint;\n    for( int i=0; i<256 && t<maxt; i++ )\n    {\n        float h = getDistanceScene(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, d/(w*max(0.0,t-y)) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.15*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = getDistanceScene( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - occ*1.5, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 texcoord = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    \n    vec3 cameraPos = vec3(0.0, 0.0, -1.50);\n    vec3 cameraDir = normalize(vec3(texcoord,1.0));\n    \n    float result = rayMarch(cameraPos, cameraDir);\n    \n    vec3 p = cameraPos + cameraDir * result;\n    \n    vec3 col = vec3(p);\n    vec3 n = generateNormal(p);\n    \n    vec3 lightPos = vec3(0.0, 1.50, -0.5);\n    \n    vec3 lightDir = normalize(lightPos - p);\n   \n    float NoL = dot(lightDir, n);\n    NoL = clamp(NoL, 0.0, 1.0);\n    \n    vec3 ambient = vec3(0.1);\n    \n    vec3 eyeDir = normalize(cameraPos - p);\n    \n    vec3 halfAngle = normalize(n + lightDir);\n    float spec = clamp(dot(lightDir, halfAngle), 0.0, 1.0);\n    spec = pow(spec, 12.0);\n    \n    col = vec3(NoL + spec * 0.025);\n    \n    float dof = getDistanceScene(p);\n    // 阴影\n    col *= softshadow(p + n * 1e-2, lightDir, 1e-5, length(lightPos - p), 0.05);\n    col *= calcOcclusion(p, n);\n    \n    col = pow(col, vec3(1.0/2.2));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}