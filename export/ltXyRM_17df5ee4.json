{"ver":"0.1","info":{"id":"ltXyRM","date":"1503990502","viewed":174,"name":"Hotomopy of linear maps","username":"etale_cohomology","description":"A homotopy is a map between maps. Here we show a homotopy between the identity linear map and a user-given linear map.\n\nIs there a better way of making a grid? This grid sucks if the linear map zooms in/out too much!","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["2d","simple","math","linear","algebra","transformations","maps","homotopy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A linear map is a map between vector spaces that preserves linear combinations.\n\n// Every linear map admits a representation as a matrix; \n// this matrix representation is unique if we fix a basis for both vector spaces (domain and codomain),\n// otherwise the linear map has infinitely-many matrix representations.\n// Conversely, every matrix represents a linear map;\n// this linear map is unique if we fix a basis for both vector spaces (domain and codomain),\n// otherwise the matrix represents infinitely-many linear maps.\n\n// A homotopy is a map between maps.\n// If f and g are 2 maps, then a simple homotopy between f and g is given by (1 - t) * f + t * g,\n// as t ranges over the unit interval.\n\n// Here we show a homotopy between the identity linear map and a user-given linear map.\n\n// Define your linear map here!\nconst mat2 LINEAR_MAP = mat2(1, 0, 1, 0);//mat2(2, -1, 1, 1);  // Write the linear map in row-major!\n\nfloat draw_grid(vec2 uv){\n    float zoom = 2.;\n    float antialias = 12. * zoom / iResolution.y;\n    vec2 grid_2D = smoothstep(antialias, 0., abs(sin(3.14159 * zoom * uv)));\n    return max(grid_2D.x, grid_2D.y);\n}\n\nvec2 linear_map(vec2 uv){\n\tmat2 identity_matrix = mat2(1, 0, 0, 1);\n    mat2 matrix = LINEAR_MAP;\n\n    float t = (1. + sin(iTime)) * .5;  // Squash the sine map to [0; 1]\n\n    uv.x *= -1.;  // Ensure the linear map retains it handedness!\n    mat2 deformed_matrix = (1. - t) * identity_matrix + t * matrix;\n    return uv * deformed_matrix;  // Apply to linear map to each point `uv`!\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;  // The Fabrice map!\n\n    uv = linear_map(uv);\n\n    float grid = draw_grid(uv);\n    fragColor.rgb = vec3(grid);\n}\n","name":"Image","description":"","type":"image"}]}