{"ver":"0.1","info":{"id":"wltXzS","date":"1581680929","viewed":523,"name":"Flocking Boids","username":"arifr123","description":"My interpretation of boids:\nhttps://en.wikipedia.org/wiki/Boids\n\nseparation:\nThe separation force is proportional to 1/dist^3.\n\nalignment:\nThe desired speed is proportional to neighborsNum.","likes":19,"published":1,"flags":32,"usePreview":0,"tags":["simulation","flocking","boids"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float r = 2.;\nconst int searchSize = int(r + velocityClip) - 1;\n\nivec2 ires = ivec2(0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(ires == ivec2(0))\n        ires = ivec2(iResolution);\n    \n    \n    ivec2 ic = ivec2(fragCoord);\n    \n    \n    if(false)\n    {\n        vec4 ov = texelFetch(iChannel0, ic, 0);\n        if(ov == NONE)\n        {\n            fragColor = vec4(0, 0, 0, 1);\n            return;\n        }\n        else\n        {\n            fragColor = vec4(ov.xy/1., 0, 1);\n            return;\n        }\n    }\n    \n    \n    vec3 color = vec3(0);\n\n    for(int x = ic.x - searchSize; x <= ic.x + searchSize; x++)\n    {\n        for(int y = ic.y - searchSize; y <= ic.y + searchSize; y++)\n        {\n            ivec2 ic = (ivec2(x, y) + ires) % ires;\n            vec4 ov = texelFetch(iChannel0, ic, 0);\n            \n            if(ov != NONE)\n            {\n    \t\t\tvec2 p = vec2(x, y) + ov.xy;\n                \n                float d = sq(fragCoord - p);\n                \n                color = max(vec3(smoothstep(sq(r), sq(r-1.), d)), color);\n            }\n        }\n    }\n    \n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"ivec2 ires = ivec2(0);\n\nconst float desiredSpeed = 0.03;\n\nconst int neighborhoodSize = 30;\nvec4 timeStep(ivec2 ic, vec4 ov)\n{\n    vec2 p = vec2(ic) + ov.xy;\n    \n    vec2 separation = vec2(0);\n    \n    vec2 vSum = vec2(0);\n    vec2 pSum = vec2(0);\n    int neighborsNum = 0;\n    \n    for(int x = ic.x - neighborhoodSize; x <= ic.x + neighborhoodSize; x++)\n    {\n        for(int y = ic.y - neighborhoodSize; y <= ic.y + neighborhoodSize; y++)\n        {            \n            if(ic == ivec2(x, y))continue;\n            \n            ivec2 oic = (ivec2(x, y) + ires) % ires;\n            vec4 oov = texelFetch(iChannel0, oic, 0);\n            \n            if(oov == NONE)continue;\n            \n            vec2 op = vec2(x, y) + oov.xy;\n\n            vec2 diff = p - op;\n            float len = sq(sq(diff));\n            \n            len = max(1., len);\n            \n            neighborsNum++;\n\n            separation += (diff)/len;\n\n            vSum += oov.zw;\n            pSum += op;\n            \n        }\n    }\n    \n    vec2 alignment = (float(neighborsNum)) * desiredSpeed * vSum/(length(vSum)+0.05) - ov.zw;// /float(neighborsNum)\n    \n    vec2 cohesion = (pSum/(float(neighborsNum)+0.05) - p);// - ov.zw\n    \n    vec2 toMouse = iMouse.xy - p;\n    vec2 predator = iMouse.z > 0. ? -toMouse/(sq(toMouse)+0.05) : vec2(0);\n    \n \t\n    vec2 a = 1.5*separation + 0.01*alignment + 0.0008*cohesion + 1.0*predator;\n    \n    \n    \n    //a = clamp(a, -velocityClip, velocityClip);\n    \n    \n    ov.zw += dt*a;\n    \n    ov.zw = clamp(ov.zw, -velocityClip, velocityClip);\n\n    ov.xy += dt*ov.zw;\n\n    return ov;\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(ires == ivec2(0))\n        ires = ivec2(iResolution);\n    \n    \n    ivec2 ic = ivec2(fragCoord);\n    \n    if(iFrame == 0)\n    {\n        ivec2 center = ires/2;\n        ivec2 box = ivec2(500, 280);\n        box /= 2;\n        \n        if((ic - center) % ivec2(15) == ivec2(0) && clamp(ic.x, center.x - box.x, center.x + box.x) == ic.x && clamp(ic.y, center.y - box.y, center.y + box.y) == ic.y)\n        {\n        \tfragColor = vec4(0, 0, 1.*(2.*hash22(vec2(ic - center)/100.) - 1.));\n        }\n        else\n        {\n            fragColor = NONE;\n        }\n        \n        return;\n    }\n    \n    vec4 ov = texelFetch(iChannel0, ic, 0);\n    \n    if(ov != NONE)\n    {        \n        if(clamp(ov.xy, 0., 1.) != ov.xy)\n        {\n            fragColor = NONE;\n        }\n        else\n        {\n            fragColor = timeStep(ic, ov);\n        }\n    }\n    else\n    {\n        for(int x = ic.x - maxThrow; x <= ic.x + maxThrow; x++)\n        {\n            for(int y = ic.y - maxThrow; y <= ic.y + maxThrow; y++)\n            {\n                ivec2 cic = (ivec2(x, y) + ires) % ires;\n                vec4 cov = texelFetch(iChannel0, cic, 0);\n                \n                if(cov != NONE)\n    \t\t\t{\n                    ivec2 p = cic + ivec2(floor(cov.xy));\n                    p = (p + ires) % ires;\n\n                    if(p == ic)\n                    {\n                        cov.xy -= vec2(ic) - vec2(x, y);\n\n                        fragColor = timeStep(ic, cov);\n                        return;\n                    }\n                }\n            }\n        }\n        \n        fragColor = NONE;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define NONE vec4(1000)\n\n#define sq(x) dot(x, x)\n\nconst int maxThrow = 4;\nconst float dt = 1.;\n\nconst float velocityClip = float(maxThrow) / dt;","name":"Common","description":"","type":"common"}]}