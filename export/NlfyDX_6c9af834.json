{"ver":"0.1","info":{"id":"NlfyDX","date":"1648927408","viewed":211,"name":"Basic 3D Meta Fluid","username":"uiop","description":"Just a quick particle demonstration. Would use more particles if the rendering wasn't terrible. May use a marching-cubes algorithm in a separate buffer to be able to render it with more particles.","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","fluid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Thanks iq for these functions:\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a);\n    float c = cos(a);\n    return(vec3(p.x*c+p.y*s,-p.x*s+p.y*c,p.z));\n}\nvec4 getSDF(vec3 p){\n    vec4 n = texelFetch(iChannel0,ivec2(0, 2), 0);\n    float dis = length(p - n.xyz) - clamp(-cos(iTime*0.7),0.,0.015);\n    for (int i = 1; i < COUNT; i++) {\n        vec4 n = texelFetch(iChannel0,ivec2(i, 2), 0);\n        float d = length(p - n.xyz) - clamp(-cos(iTime*0.7),0.,0.015);\n        dis = opSmoothUnion(d,dis,clamp(cos(iTime*0.7),0.,0.2));\n    }\n    dis = opSmoothIntersection(dis, length(p)-RADIUS - 0.0, 0.03);\n    return vec4(0,0,0,dis);\n}\n\nvec3 findNormal(vec3 p, float d){\n    return normalize(vec3(getSDF(p + vec3(d,0,d)).w - getSDF(p - vec3(d,0,0)).w,\n    getSDF(p + vec3(0,d,0)).w - getSDF(p - vec3(0,d,0)).w,\n    getSDF(p + vec3(0,0,d)).w - getSDF(p - vec3(0,0,d)).w\n    ));\n}\n\nvec3 refl(vec3 d, vec3 n){\n    return d - 2.f * n * dot(d,n);\n}\n\n\n\nvec4 marchRay(inout vec3 pos, vec3 dir, int ma, out bool hit){\n    float mindist = 100000.;\n    hit = false;\n    vec4 newcol;\n    for(int i = 0; i < ma; i ++){\n        vec4 oc = abs(getSDF(pos));\n        newcol = oc;\n        float dis = oc.w;\n        mindist = min(dis,mindist);\n        if(dis < 0.005){\n            hit = true;\n            return vec4(newcol.xyz,mindist);\n        }\n        if(dis > 5.){\n            return vec4(newcol.xyz,mindist);\n        }\n        pos += dir * dis;\n    }\n    return vec4(newcol.xyz,mindist);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 uv = (fragCoord-0.5f*iResolution.xy)/iResolution.x;\n    \n    vec3 pos = vec3(0.5,2.1*cos(time*0.5f),-2.1*sin(time*0.5f));\n    vec3 dir = normalize(rotx(vec3(uv.x,uv.y-0.24,-1.).zxy,time*0.5f).zxy);\n    int ma =100;\n    vec4 col = vec4(0,0,0,0);\n\n    bool hit;\n    vec4 co = marchRay(pos,dir,200,hit);\n    if(hit){\n        vec3 norm1 = findNormal(pos,0.0001);\n        //fragColor = 0.5*(1.+vec4(findNormal(pos,0.0001),0));\n        vec3 ref = refl(dir,norm1);\n\n        fragColor = vec4(texture(iChannel1, ref.yxz).xyz,1);\n        //pos += dir * (0.1);\n        //vec4 co2 = marchRay(pos,dir,100,hit);\n        //if(hit){\n        \n            //fragColor = fragColor + 0.5*vec4(findNormal(pos,0.0001),0);\n            //fragColor = vec4(pos.xyz,0);\n        //}\n        fragColor += 0.5*vec4(norm1,0);\n\n    }else{\n        float glow = co.w*100.0;\n        fragColor = vec4((sin(glow+time*4.)+0.)*glow,(sin(glow+1.0+ time*3.)+0.)*glow,(sin(glow + time*2.5 + 2.0)+0.)*glow,1);\n    }\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = texture(iChannel0,uv);\n    \n    \n    /*for (int i = 0; i < count; i++) {\n        if(float(i) != fragCoord.x){\n            vec4 n = texelFetch(iChannel0,ivec2(i, 0), 0);\n            vec3 del = r.xyz - n.xyz;\n        }\n    }*/\n    \n    /* if(fragCoord.x < float(count)){\n        vec4 r = texelFetch(iChannel0, ivec2(fragCoord.x, 2), 0);\n        //if(fragCoord.y == 0.){ // Acceleration\n            //for (int i = 0; i < count; i++) {\n              //  if(float(i) != fragCoord.x){\n                //    vec4 n = texelFetch(iChannel0,ivec2(i, 0), 0);\n                  //  vec3 del = r.xyz - n.xyz;\n                    //float amt = 1. / (length(del) + 0.01);\n                //}\n            //}\n        //}\n        fragColor = r;\n    }*/\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float dt = 0.1;\n    float maxSize = iResolution.x * iResolution.y;\n    \n    if(fragCoord.x < float(COUNT) && iFrame > 0){\n        vec4 p = texelFetch(iChannel0,ivec2(fragCoord.x, 2), 0);\n\n        if(int(fragCoord.y) == 0){ // Acceleration\n            fragColor = vec4(-0.05,0,0,0);\n            for (int i = 0; i < COUNT; i++) {\n                if(i != int(fragCoord.x)){\n                    vec4 n = texelFetch(iChannel0,ivec2(i, 2), 0);\n                    vec3 del = p.xyz - n.xyz;\n                    if(length(del) < 0.2){\n                        float amt = 1. / (length(del)*length(del) + 0.0001);\n                        fragColor += vec4(del * amt*0.0005,0);\n                    }\n                }\n            }\n            // Bounds\n            float ege = length(p.xyz) - RADIUS+0.05;\n            if (ege > 0.){\n                fragColor += -normalize(p) * ege*5.0;\n            }\n            if(iFrame%1000 < 70){ // Push\n                fragColor += vec4(0.1,0.1,0,0);\n            }\n            \n        } else if (int(fragCoord.y) == 1) { // Velocity\n            vec4 v = texelFetch(iChannel0,ivec2(fragCoord.x, 1), 0);            \n            vec4 a = texelFetch(iChannel0,ivec2(fragCoord.x, 0), 0);            \n            fragColor = v + a * dt;\n            fragColor *= 0.995;\n\n        } else if (int(fragCoord.y) == 2) { // Position\n            vec4 a = texelFetch(iChannel0,ivec2(fragCoord.x, 0), 0);\n            vec4 v = texelFetch(iChannel0,ivec2(fragCoord.x, 1), 0);\n                        vec4 p = texelFetch(iChannel0,ivec2(fragCoord.x, 2), 0);            \n            fragColor = p + (a / 2. * dt + v) * dt;\n//          // Bounds\n            float ege = length(fragColor.xyz) - (RADIUS);\n            if (ege > 0.){\n                fragColor = vec4(normalize(fragColor.xyz) * (RADIUS),0);\n            }\n        }\n        //fragColor = r*0.999;\n    }else{\n        fragColor = texture(iChannel1, uv) - 0.5;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}\n\n#define COUNT (200)\n#define RADIUS 0.45\n","name":"Common","description":"","type":"common"}]}