{"ver":"0.1","info":{"id":"ldGSRh","date":"1462748454","viewed":120,"name":"Fractal of Disapproval","username":"dextero","description":"Look of Disapproval as a fractal.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractal","disapproval","look"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1415926535897932384626433832795;\n\nconst vec4 cBackgroundColor = vec4(0.4, 0.4, 1.0, 1.0);\nconst vec4 cObjectColor = vec4(1.0, 1.0, 1.0, 1.0);\n\nconst float MARGIN = 1.0;\nconst float EYE_RADIUS = 10.0;\nconst float EYE_OFFSET = EYE_RADIUS;\nconst float EYEBROW_RADIUS = 0.5 * EYE_RADIUS;\nconst float EYEBROW_LENGTH = EYE_RADIUS * 2.0 - EYEBROW_RADIUS;\nconst float FOLD_SCALE = (4.0 * EYE_RADIUS + 2.0 * EYE_OFFSET);\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    float x = axis.x;\n    float y = axis.y;\n    float z = axis.z;\n\n    return mat3(oc * x * x + c,      oc * x * y - z * s,  oc * z * x + y * s,\n                oc * x * y + z * s,  oc * y * y + c,      oc * y * z - x * s,\n                oc * z * x - y * s,  oc * y * z + x * s,  oc * z * z + c);\n}\n\nstruct State {\n    bool hit;\n    vec3 pos;\n};\n\nState translate(State state,\n                vec3 offset) {\n    if (state.hit) { return state; }\n\n    state.pos -= offset;\n    return state;\n}\n\nState rotate(State state,\n             vec3 axis,\n             float angle) {\n    if (state.hit) { return state; }\n\n    state.pos = rotationMatrix(axis, -angle) * state.pos;\n    return state;\n}\n\nState scale(State state,\n            vec3 scale) {\n    if (state.hit) { return state; }\n\n    state.pos *= scale;\n    return state;\n}\n\nState x_line(State state,\n             vec3 offset,\n             float width) {\n    if (state.hit) { return state; }\n\n    if (abs(state.pos.y - offset.y) > MARGIN\n            || abs(state.pos.z - offset.z) > MARGIN\n            || abs(state.pos.x - offset.x - width / 2.0) > width / 2.0) {\n        return state;\n    }\n\n    state.pos -= offset;\n    state.pos.x = mod(state.pos.x, MARGIN * 2.0) - MARGIN;\n    state.hit = true;\n\n    return state;\n}\n\nState xy_circle(State state,\n                vec3 center,\n                float radius) {\n    if (state.hit) { return state; }\n\n    if (distance(state.pos.xy, center.xy) > radius\n            || distance(state.pos.xy, center.xy) < (radius - MARGIN * 2.0)) {\n        return state;\n    }\n\n    state = translate(state, center);\n    float angle = atan(state.pos.y, state.pos.x);\n    float part_radius = MARGIN;\n    float part_radians = asin(part_radius / (radius - part_radius)) * 2.0;\n    part_radians += mod(2.0 * PI, part_radians) / floor(2.0 * PI / part_radians);\n    float rot_angle = angle - mod(angle, part_radians) + part_radians / 2.0;\n    state = rotate(state, vec3(0.0, 0.0, 1.0), -rot_angle);\n    state = translate(state, vec3(radius - part_radius, 0.0, 0.0));\n    state = scale(state, vec3(MARGIN / part_radius));\n\n    state.hit = true;\n    return state;\n}\n\nState eyebrow_arc(State state,\n                  vec3 center,\n                  float radius) {\n    if (state.pos.x - center.x < 0.0) {\n        return state;\n    }\n\n    return xy_circle(state, center, radius);\n}\n\nState eyebrow(State state,\n              vec3 offset,\n              float length,\n              float radius) {\n    if (state.hit) { return state; }\n\n    state = x_line(state, offset, length);\n    state = eyebrow_arc(state, vec3(offset.x + length, offset.y + radius - MARGIN, offset.z), radius);\n    return state;\n}\n\nState eye(State state,\n          vec3 offset,\n          float eye_radius,\n          float eyebrow_radius) {\n    if (state.hit) { return state; }\n\n    if (length(state.pos - offset) < MARGIN) {\n        state.hit = true;\n        state.pos -= offset;\n        return state;\n    }\n\n    state = xy_circle(state, offset, eye_radius);\n    state = eyebrow(state,\n            // HACK: MARGIN\n                    vec3(offset.x - eye_radius + MARGIN, offset.y + eye_radius + MARGIN, offset.z),\n                    2.0 * eye_radius - eyebrow_radius - MARGIN,\n                    eyebrow_radius);\n\n    return state;\n}\n\nvec4 fractalOfDisapproval(vec3 pos) {\n    State state;\n    state.hit = false;\n    state.pos = pos;\n\n    int numHits = 0;\n    for (int i = 0; i < 8; ++i) {\n        state.hit = false;\n\n        state = x_line(state, vec3(EYE_RADIUS, -EYE_RADIUS, 0.0), 2.0 * EYE_OFFSET);\n        state = eye(state, vec3(0.0, 0.0, 0.0), EYE_RADIUS, EYEBROW_RADIUS);\n        state = eye(state, vec3(2.0 * (EYE_OFFSET + EYE_RADIUS), 0.0, 0.0), EYE_RADIUS, EYEBROW_RADIUS);\n\n        if (state.hit) {\n            ++numHits;\n        } else {\n            break;\n        }\n\n        state.pos *= FOLD_SCALE;\n    }\n\n    float dist = distance(state.pos / FOLD_SCALE, vec3(0.0, 0.0, 0.0));\n\n    if (state.hit && dist < MARGIN) {\n        return cObjectColor;\n    }\n\n    vec4 backgroundColor = vec4(numHits == 4 || numHits == 5 || numHits == 6 || numHits == 7 ? 0.6 : 0.0,\n                                numHits == 2 || numHits == 3 || numHits == 5 || numHits == 6 ? 0.6 : 0.0,\n                                numHits == 1 || numHits == 3 || numHits == 5 || numHits == 7 ? 0.6 : 0.0,\n                                1.0);\n\n    return backgroundColor / sqrt(dist);\n}\n\nvoid mainImage(out vec4 fragColor,\n               in vec2 fragCoord) {\n  vec2 screenSize = vec2(1.0, iResolution.y / iResolution.x) * 100.0;\n  vec3 pos = vec3(fragCoord.x / iResolution.x * screenSize.x - screenSize.x / 2.0,\n                  fragCoord.y / iResolution.y * screenSize.y - screenSize.y / 2.0,\n                  0.0);\n\n  pos /= exp(13.0 * (1.0 + sin((iTime - 8.0) / 5.0)));\n\n  fragColor = fractalOfDisapproval(pos);\n}\n","name":"Image","description":"","type":"image"}]}