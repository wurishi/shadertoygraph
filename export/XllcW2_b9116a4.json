{"ver":"0.1","info":{"id":"XllcW2","date":"1506470703","viewed":78,"name":"House of Layers Project","username":"anonguy","description":"Project","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["project"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y *= iResolution.y / iResolution.x;\n    \n    //Background\n    vec3 bgColor = vec3(0.0, 0.749, 1.0);\n    \n    //Body of House\n    vec4 bodyColor = vec4(1.0, 0.0, 5.0, 1.0);\n    vec2 bodyLocation = vec2(0.5, 0.2);\n    float bodyLength = 0.15;\n    float bodyWidth = 0.17;\n    bool bodyOn = true;\n    \n    //Chimney of House\n    vec4 chimneyColor = vec4(0.698, 0.133, 0.133, 1.0);\n    vec2 chimneyLocation = vec2(0.65, 0.37);\n    float chimneyLength = 0.04;\n    float chimneyWidth = 0.02;\n    bool chimneyOn = true;\n    \n    //Windows of House\n    vec4 windowColor = vec4(0.466, 0.533, 0.6, 1.0);\n    vec2 window1Location = vec2(0.4, 0.2);\n    vec2 window2Location = vec2(0.6, 0.2);\n    float windowSide = 0.05;\n    bool windowsOn = true;\n    \n    //Door of House\n    vec4 doorColor = vec4(0.0, 0.0, 0.0, 1.0);\n    vec2 doorLocation = vec2(0.5, 0.1);\n    float doorLength = 0.05;\n    float doorWidth = 0.03;\n    bool doorOn = true;\n    \n    //It may seem a little counter intuitive to cast bools to floats right? Well I designed this for the ease of the user, and since\n    //a boolean value is just a 0 or a 1, shadertoy just needed an extra push.\n    vec4 bgLayer = vec4(bgColor, 1.0);\n    vec4 bodyLayer = bodyColor * (step(length(bodyLocation.x - uv.x), bodyWidth) * step(length(bodyLocation.y - uv.y), bodyLength))\n         * float(bodyOn);\n    \n    vec4 chimneyLayer = chimneyColor * (step(length(chimneyLocation.x - uv.x), chimneyWidth) * step(length(chimneyLocation.y - uv.y),\n         chimneyLength)) * float(chimneyOn);\n    \n    vec4 windowLayer = windowColor * (step(length(window1Location.x - uv.x), windowSide) * step(length(window1Location.y - uv.y),\n         windowSide)) * float(windowsOn);\n    \n    windowLayer+= windowColor * (step(length(window2Location.x - uv.x), windowSide) * step(length(window2Location.y - uv.y),\n    windowSide)) * float(windowsOn);\n    \n    vec4 doorLayer = doorColor * (step(length(doorLocation.x - uv.x), doorWidth) * step(length(doorLocation.y - uv.y), doorLength))\n         * float(doorOn);\n    \n    vec4 composite = mix(bgLayer, bodyLayer, bodyLayer.a);\n    composite = mix(composite, chimneyLayer, chimneyLayer.a);\n    composite = mix(composite, windowLayer, windowLayer.a);\n    composite = mix(composite, doorLayer, doorLayer.a);\n    \n    fragColor = composite;\n}","name":"Image","description":"","type":"image"}]}