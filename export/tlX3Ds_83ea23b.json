{"ver":"0.1","info":{"id":"tlX3Ds","date":"1558043603","viewed":216,"name":"[TWITCH] The world within","username":"Flopine","description":"This is a shader made during a live stream in twitch here: https://www.twitch.tv/flopine\nI played with mixing 2d and 3d in one shader, was fun! :) ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","raymarching","tunnel","mask"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n#define time iTime\nfloat PI = 3.141592;\nfloat ITER = 100.;\n\nfloat stmin (float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5*(u+a+abs(mod(u-a+st, 2.*st)-st)));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat moda (inout vec2 p, float rep)\n{\n    float per = 2.*PI/rep;\n    float a = atan(p.y,p.x);\n    float l = length(p);\n\n    float id = floor(a/per);\n    a = mod(a, per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;\n    return id;\n}\n\nvoid mo (inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y > p.x) p = p.yx;\n}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat od (vec3 p, float d)\n{return dot(p, normalize(sign(p)))-d;}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0., max(q.x,max(q.y,q.z))) + length(max(q,0.));\n}\n\nfloat pillars (vec3 p)\n{\n    p.xz *= rot(sin(p.y+time));\n    moda(p.xz, 3.);\n    p.x -= 0.8;\n    float c = cyl(p.xzy, 0.2, 1e10);\n    return c;\n}\n\nfloat platform (vec3 p)\n{\n    float t1 = PI/4. * (floor(time) + pow(fract(time),5.));\n    p.xz *= rot(t1);\n    float b = box(p, vec3(1.5,.2,1.5));\n    moda(p.xz, 4.);\n    p.x -= 2.;\n    float o = od(p, 0.3);\n    return stmin(b,o, 0.3,3.);\n}\n\nfloat SDF (vec3 p)\n{\n    float per = 8.;\n\n    p.y += sin(p.z+time*2.);\n    p.x += cos(p.z+time*2.);\n\n    p.xy *= rot(p.z*0.2);\n    p.z = mod(p.z-per*0.5, per)-per*0.5;\n    moda (p.xy, 3.);\n    mo (p.xy, vec2(2., 1.5));\n    p.x -= 2.;\n    float pil = pillars(p);\n    float plat = platform(p);\n    \n    return stmin(pil, plat, 0.3, 4.);\n}\n\n\nvec3 get_cam (vec3 ro, vec3 tar, vec2 uv)\n{\n    vec3 f = normalize(tar-ro);\n    vec3 l = normalize(cross(vec3(0.,1.,0.),f));\n    vec3 u = normalize(cross(f,l));\n    return normalize(f + l*uv.x + u*uv.y);\n}\n\nvec3 palette (float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{return a+b*cos(2.*PI*(c*t+d));}\n\n\nfloat jaw (vec2 uv)\n{\n    uv *= 1.2;\n    uv += vec2(0.08,0.1);\n    return length(max(abs(uv.x),abs(uv.y)-uv.x*0.2));\n}\n\nfloat skull (vec2 uv)\n{\n    uv += vec2(.115,-.1);\n    return length(uv)-0.07;\n}\n\nfloat neck (vec2 uv)\n{\n    uv += vec2(.2,0.4);\n    uv *= rot(-PI/10.);\n    uv = abs(uv);\n    return length(max(uv.x-uv.y*0.1,uv.y)+0.05);\n}\n\nfloat nose (vec2 uv)\n{\n    uv += vec2(-0.16,0.05);\n    uv *= rot(-PI/5.);\n    uv *= vec2(5.,7.0);\n    return length(uv)-0.01;\n}\n\nfloat dots_grid (vec2 uv)\n{\n    uv *= rot(PI/4.);\n    float per = 0.08;\n    uv = mod(uv, per)-per*0.5;\n    return smoothstep(0.022, 0.011,length(uv));\n}\n\nfloat visage (vec2 uv)\n{\n    float face = smin(nose(uv),smin(neck(uv),smin(skull(uv), jaw(uv),0.1),0.2), 0.2);\n    float inface = smoothstep(0.28,0.25,face);\n    float outface =  smoothstep(face, 0.29,0.30)*smoothstep(0.3,0.29,face);;\n    return clamp((dots_grid(uv)*(1.-outface))+inface,0.,1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec3 ro = vec3(0.001,0.001,-10.-time); vec3 p = ro;\n    vec3 tar = vec3(cos(p.z+time*2.), sin(p.z+time*2.),0.);\n    vec3 rd = get_cam(ro, tar, uv); \n    float shad = 0.;\n\n    for (float i=0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if(d<0.01)\n        {\n            shad = i/ITER;\n            break;\n        }\n        p += d*rd*0.2;\n    }\n    \n    float t = length(ro-p);\n    \n    vec3 col = vec3(shad);\n    col = mix(col, palette(abs(uv.y-.7), vec3(0.5),vec3(0.5), vec3(0.5), vec3(0.2, 0.5, 0.8)), 1.-exp(-0.002*t*t));\n    col *= visage(uv);\n    \n    fragColor = vec4(pow(col,vec3(0.4545)),1.);\n}","name":"Image","description":"","type":"image"}]}