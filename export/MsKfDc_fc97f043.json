{"ver":"0.1","info":{"id":"MsKfDc","date":"1530906107","viewed":138,"name":"PQ <-> Gamma","username":"BattleAxeVR","description":"From Infamous Second Son. See code comments for authorship (not myself)","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["cheapapproximationforpqperceptualquantizer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This shader is to validate ST.2084 (PQ) curve fitting equations for HDR <-> SDR in Infamous Second Son\n// http://www.glowybits.com/blog/2017/01/04/ifl_iss_hdr_2/\n// See: https://twitter.com/jasminpatry/status/811975972035538945\n// All due credit goes to Jasmin Patry of SuckerPunch Games for these formulae\n\n/*\n\n// Use this to compare on the left hand side HDR to the right SDR\n\nfloat4 main(float2 tex : TEXCOORD0) : COLOR\n{\n\tfloat2 uv = tex;\n\t\n    uv.x *= 2.0f;\n\n    bool IsLeft = (uv.x < 1.0f);\n\n    if (IsLeft)\n    {\n\t\tfloat4 orig_color = tex2D(s0, uv);\n\t\tfloat4 left_color = orig_color;\n\t\t\n\t\tfloat3 linear_color = pq_to_linear(left_color.rgb) / 100.0;\n\t\tleft_color.rgb = linear_color;\n\n\t\treturn left_color;\n        \n    }\n    else\n    {\n\t\tuv.x -= 1.0f;\n\t\tfloat4 right_color = tex2D(s0, uv);\n\t\t\n\t\treturn right_color;\n    }        \n}\n\nPaste this into a .hlsl file to use it in Media Player Classic and watch HDR vids on your SDR monitor or TV (if you're curious)\n\n\nsampler s0 : register(s0);\n\nfloat3 pq_to_linear(float3 x)\n{\n\treturn (x * (x * (x * 85.471 + 13.947) + 0.1357) - 0.0008537) / (x * ( x * (x * -1.2149 + 3.1911) - 2.9834)+ 1.0);\n}\n\nfloat4 main(float2 tex : TEXCOORD0) : COLOR\n{\n\tfloat2 uv = tex;\n\tfloat4 color = tex2D(s0, uv);\n\tcolor.rgb = pq_to_linear(color.rgb) / 100.0;\n\treturn color;\n}\n\n*/\n\nvec3 linear_to_pq(vec3 x)\n{\n    x = (x * (x * (x * (x * (x * 533095.76 + 47438306.2) + 29063622.1) + 575216.76) + 383.09104) + 0.000487781) /\n        (x * (x * (x * (x * 66391357.4 + 81884528.2) + 4182885.1) + 10668.404) + 1.0);\n    return x;\n}\n\nvec3 pq_to_linear(vec3 x)\n{\n\treturn (x * (x * (x * 85.471 + 13.947) + 0.1357) - 0.0008537) / (x * ( x * (x * -1.2149 + 3.1911) - 2.9834)+ 1.0);\n}\n\n#define SHOW_ERROR 0 // set to 1 (then hit play, right arrow below) to see error on right hand side\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv.x *= 2.0;\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    if (uv.x < 1.0)\n    {\n        // Ground truth, on the left hand side of the screen\n        fragColor.rgb = vec3(uv, 0.5 + 0.5 * sin(iTime));\n    }\n    else\n    {\n        uv.x -= 1.0;\n        \n        vec3 ground_truth = vec3(uv, 0.5 + 0.5 * sin(iTime));\n        fragColor.rgb = ground_truth;\n        \n        //Doing the conversion to PQ then back should yield approximately the same result (and it does)\n    \tfragColor.rgb = linear_to_pq(fragColor.rgb);\n    \tfragColor.rgb = pq_to_linear(fragColor.rgb) / 100.0; // 100 fudge factor = 100 nits?\n        \n#if SHOW_ERROR\n        //Enable these lines to see the delta (error).\n        vec3 absolute_error = abs(ground_truth - fragColor.rgb);\n        absolute_error *= 30.0; //  There is only an error visible on the RHS when you boost this to a large value\n        fragColor.rgb = absolute_error;\n#endif\n    }\n}","name":"Image","description":"","type":"image"}]}