{"ver":"0.1","info":{"id":"XtyXWc","date":"1486096201","viewed":250,"name":"Gradient Orientation filter","username":"sepehr","description":"Gradient Orientations filter, used for content copy detection. Link to IEEE article in source.","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["filter","gradient","hash","kernel","fingerprint"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*!\n * This is the Centeroid of Gradient Orientation kernel\n * as described in the following paper:\n *\n * Lee, S., & Yoo, C. (n.d.). Video Fingerprinting Based on Centroids of Gradient Orientations.\n * 2006 IEEE International Conference on Acoustics Speed and Signal Processing Proceedings. doi:10.1109/icassp.2006.1660364\n *\n * IEEE link:\n * ieeexplore.ieee.org/iel5/11024/34758/01660364.pdf\n *\n * It is mainly used to generate fingerprints for images and perform \"content copy detection\".\n */\n\n#define M_1PI 3.14159265\n#define M_2PI 6.28318530\n#define SQRT2 1.41421356\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n\tvec3 Gx = texture(iChannel0, uv).xyz; // center of gradient x\n    vec3 Gy = texture(iChannel1, uv).xyz; // center of gradient y\n    \n    vec3 m = (sqrt(Gx*Gx + Gy*Gy)) / SQRT2;         // polar mag\n    vec3 t = (atan(   Gy ,    Gx) + M_1PI) / M_2PI; // polar angle\n    \n    vec3 c = (m + t) / 2.0; // so we can see both m and t, at the same time\n    \n    fragColor = vec4(m, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// RGB to Y conversion\nfloat Y(in vec3 c)\n{\n   return (0.257 * c.r) + (0.504 * c.g) + (0.098 * c.b) + 0.0625;\n}\n\n// RGB to YYY conversion\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float y = Y(texture(iChannel0, uv).rgb);\n    fragColor = vec4(y,y,y,1.0);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const mat3 Gy_kernel = mat3(\n    vec3( 0, -1,  0),\n    vec3( 0,  0,  0),\n    vec3( 0, +1,  0)\n);\n\nvec3 conv(in mat3 tex[3], in mat3 h)\n{\n    vec3 result;\n    \n    for (int x = 0; x < 3; x++)\n        for (int y = 0; y < 3; y++)\n            result += (h[x][y] * tex[x][y]);\n    \n    // normalize to 0..1\n    result = (result + vec3(1)) / vec3(2);\n    return result;\n}\n\n// Gy convolution\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 px = texture(iChannel0, uv).rgb;\n    mat3 tx [3];\n    \n    for (float x = -1.0; x < 2.0; ++x)\n    {\n        mat3 v;\n        for (float y = -1.0; y < 2.0; ++y)\n        {\n            vec2 pos = vec2(fragCoord.x + x, fragCoord.y + y);\n            v[int(y) + 1] = texture(iChannel0, pos.xy / iResolution.xy).rgb;\n        }\n        \n        tx[int(x) + 1] = v;\n    }\n    \n    vec3 Gy = conv(tx, Gy_kernel);\n    fragColor = vec4(Gy, 1.0);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"const mat3 Gx_kernel = mat3(\n    vec3( 0,  0,  0),\n    vec3(-1,  0, +1),\n    vec3( 0,  0,  0)\n);\n\nvec3 conv(in mat3 tex[3], in mat3 h)\n{\n    vec3 result;\n    \n    for (int x = 0; x < 3; x++)\n        for (int y = 0; y < 3; y++)\n            result += (h[x][y] * tex[x][y]);\n    \n    // normalize to 0..1\n    result = (result + vec3(1)) / vec3(2);\n    return result;\n}\n\n// Gx convolution\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 px = texture(iChannel0, uv).rgb;\n    mat3 tx [3];\n    \n    for (float x = -1.0; x < 2.0; ++x)\n    {\n        mat3 v;\n        for (float y = -1.0; y < 2.0; ++y)\n        {\n            vec2 pos = vec2(fragCoord.x + x, fragCoord.y + y);\n            v[int(y) + 1] = texture(iChannel0, pos.xy / iResolution.xy).rgb;\n        }\n        \n        tx[int(x) + 1] = v;\n    }\n    \n    vec3 Gx = conv(tx, Gx_kernel);\n    fragColor = vec4(Gx, 1.0);\n}","name":"Buf C","description":"","type":"buffer"}]}