{"ver":"0.1","info":{"id":"ls2fRh","date":"1499552015","viewed":173,"name":"Bouncing thingy 2d","username":"pmpod","description":"The first, veery simple shader I did for learning purposes, it was fun!\n\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise","geometry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","previewfilepath":"/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//***********************************************************************************\n// The MIT License\n// Copyright Â© 2017 Piotr Podziemski \n// ----------------------------------------\n// A first shader - commented heavily for myself and others at begginer level\n// Thanks for inspiration to: @jonobr1, @iq\n//***********************************************************************************\n\n\n#define CS(a) vec2(cos(a),sin(a)) \n\n//-----------------------------------------------------------\n// Get color in 0-1 range based on 0-255 RGB value\n//-----------------------------------------------------------\nvec3 rgbNormalized(float r, float g, float b) \n{\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n\n//-----------------------------------------------------------\n// 2d signed distance to the circle\n//-----------------------------------------------------------\nfloat sd2dCircle(vec2 uv, vec2 origin, float radius)\n{\n\tfloat d = length(origin - uv) - radius;\n    return d;\n}\n\n//-----------------------------------------------------------\n// 2d signed distance to the square\n//-----------------------------------------------------------\nfloat vmax(vec2 v)\n{\n\treturn max(v.x, v.y);\n}\nfloat sd2dBox(vec2 uv, vec2 origin, vec2 s)\n{\n\treturn vmax(abs(uv-origin) - s);\n}\n\n\n//-----------------------------------------------------------\n//  Main fragment shader function \n//-----------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = 3.*iTime; //global time\n    float noiseValue = texture(iChannel0, fragCoord.xy / iResolution.x).x;\n    \n    //[1] Coordinates of the fragment we are dealing with right now\n\tvec2 uv = -1.0 + 2.*fragCoord.xy / iResolution.xy;    //uv coordinates -1<u<1 ; -1<v<1 of the fragment on the viewport screen\n\t  uv.y *= iResolution.y/iResolution.x;  //correct y coordinate for the right aspect ratio\n    \n    //[2] Properties of the objects\n\tfloat radius = 0.25;\n    vec2 centerPoint = vec2(0.0,0.0);\n    \n    //[2] Define movement of the center point of the circle\n    float amplitudeMod = 0.02+0.4*texture(iChannel1, vec2(0.3, 0.0)).x;\n    float shapeChangeMod = 1.0*texture(iChannel1, vec2(0.5, 0.0)).x;\n\tvec2 movement =  amplitudeMod * CS(shapeChangeMod+time+noiseValue);\n    \n    centerPoint +=movement;\n    \n    // Background color\n\tvec4 layer1 = vec4(rgbNormalized(200.0, 210.0, 220.0), 1.0);\n\tvec4 layer2 = vec4(0.0,0.0,0.0,0.0);\n\t// Circle\n\tvec3 red = rgbNormalized(225.0, 95.0, 60.0);\n    \n\n    float minD = mix\n    (\n        sd2dCircle(uv, centerPoint, radius),\n        sd2dBox( uv, centerPoint, vec2(radius,radius)),\n        (cos(shapeChangeMod*20.0+time*1.564526) + 1.0) / 2.0\n    );\n    if(minD <0.1)\n    {\n\t\tfloat t = clamp(minD*iResolution.x, 0.0, 1.0);\n        layer2 = vec4(0.5+0.5*shapeChangeMod,0.0+0.1*shapeChangeMod,0.0, 1.0-t);\n    }\n    \n    // vigneting from iq\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    layer1 *= 0.2 + 0.8*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n    \n    \n\t// Blend the two\n\tfragColor = mix(layer1, layer2, layer2.a);\n    \n}\n\n","name":"Image","description":"","type":"image"}]}