{"ver":"0.1","info":{"id":"XsVSDW","date":"1464990982","viewed":5411,"name":"Flame thrower","username":"TambakoJaguar","description":"I'm pretty happy with this kind of test, even if many details are quite bad... It looks like it works better in Chrome...\nUse mouse to move the view.\nAnd yes, the sound is pretty crappy!\nHelp for improvement always appreciated!","likes":73,"published":1,"flags":8,"usePreview":1,"tags":["reflection","sound","refraction","flame","fire","water","bump","heat","wet","walls","flamethrower","decay"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\"Flame thrower\" by Emmanuel Keller aka Tambako - June 2016\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n// ToDo\n// * Variation power flame thrower with time\n// * Better texture/color tube (bump)\n// * Amb Occ\n// * Problem bump slow\n// * Lamp(s) for flame thrower\n// * Heat refraction\n// - Speed/compile optimisations\n\n#define pi 3.14159265359\n\n// Switches, you can play with them, but be careful, some options can crash your browser!\n#define specular\n#define reflections\n#define ambocc\n//#define test_ambocc\n#define bump_maps\n#define show_floor\n#define show_wall\n#define show_tube\n#define show_flame\n#define flame_a_turb\n#define heat_refraction\n//#define antialias\n\nstruct Lamp\n{\n  \tvec3 position;\n  \tvec3 color;\n  \tfloat intensity;\n  \tfloat attenuation;\n};\n\nstruct RenderData\n{\n  \tvec3 col;\n  \tvec3 pos;\n  \tvec3 norm;\n  \tint objnr;\n};\n   \n// Every object of the scene has its ID\n#define SKY_OBJ        0\n#define FLAME_OBJ      1\n#define TUBE_OBJ       2\n#define FLOOR_OBJ      3\n#define WALL_1_OBJ     4\n#define WALL_2_OBJ     5\n\nLamp lamps[3];\n\n// Campera options\nvec3 campos = vec3(0.5, -0.4, 10.);\nvec3 camtarget = vec3(0., 0.7, 0.);\nvec3 camdir;\nfloat fov = 4.5;\nfloat angle;\nfloat angle2;\n\n// Ambient light\nconst vec3 ambientColor = vec3(0.3);\nconst float ambientint = 0.;\n\n// Color options\nconst vec3 flameColor = vec3(1., 0.68, 0.32);\nconst vec3 tubeColor = vec3(0.3, 0.32, 0.42);\nconst vec3 floorColor = vec3(0.5, 0.5, 0.54);\nconst vec3 wallColor = vec3(0.3, 0.3, 0.34);\n\n// Shading options\nconst float specint = 0.14;\nconst float specshin  = 5.;\nconst float aoint = 0.42;\n    \n// Tracing options\nconst float normdelta = 0.001;\nconst float maxdist = 30.;\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.8;\nconst int aasamples = 2;\n\nconst float tubeDiameter = 0.14;\nconst float tubeLenght = 0.8;\nconst vec3 flamePos = vec3(0.05, 1.1, 1.5);\n\nbool traceFlame = true;\n\nfloat flameVar;\n\nfloat textureScale = 0.3;\nfloat rms;\nconst float rmb = 0.8;\n\nvoid init()\n{\n    // The lamps\n    lamps[0] = Lamp(vec3(-1.5, 3., 1.), vec3(1., 1., 1.), 1.2, 0.01); // 1.2\n    lamps[1] = Lamp(vec3(-5., 12., 15.), vec3(0.65, 0.75, 1.), 1.05, 0.01); // 0.9\n    lamps[2] = Lamp(flamePos*2., 1.2*flameColor, 0., 0.01);\n    \n    rms = 0.28 + 0.003*iTime;\n    \n    // Power of the flame in function of the time\n    flameVar = sin(iTime*0.55) + 0.56*sin(iTime*0.134) + 0.22*sin(iTime*0.095);\n}\n\n// Union operation from iq\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) - vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) + vect.y*cos(angle);\n    return rv;\n}\n\nvec3 rotateVec2(vec3 posr)\n{\n    posr = vec3(posr.x, posr.y*cos(angle2) + posr.z*sin(angle2), posr.y*sin(angle2) - posr.z*cos(angle2));\n    posr = vec3(posr.x*cos(angle) + posr.z*sin(angle), posr.y, posr.x*sin(angle) - posr.z*cos(angle)); \n    \n    return posr;\n}\n\n// 1D hash function\nfloat hash(float n)\n{\n    return fract(sin(n)*753.5453123);\n}\n\n// From https://www.shadertoy.com/view/4sfGzS\nfloat noise(vec3 x)\n{\n    //x.x = mod(x.x, 0.4);\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix(hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix(hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix(hash(n+113.0), hash(n+114.0),f.x),\n                   mix(hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n// From https://www.shadertoy.com/view/Xds3zN\nfloat sdCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// Distance mapping function of the tube where the flame comes\nfloat map_tube(vec3 pos)\n{\n    pos-= flamePos;\n    pos.x+= tubeLenght;\n    pos = pos.yxz;\n    \n    float df = sdCylinder(pos, vec2(tubeDiameter, tubeLenght));\n    df+= -0.006 + 0.003*noise(pos*vec3(70., 20., 70.));\n    df = max(df, -sdCylinder(pos, vec2(tubeDiameter - 0.02, tubeLenght + 0.02)));\n    return df;\n}\n\n// Gets the height of the water on the floor\nfloat waterPos;\nfloat getWaterPos(vec3 pos)\n{\n    vec3 pos2 = pos + vec3(0.3*noise(pos*4.2),\n                          0.27*noise(pos*6.5),\n                          0.32*noise(pos*3.8))\n                      + vec3 (7., 0.5, 12.);\n    return noise(pos2*1.7) - 0.1 \n        + 1.2*smoothstep(-0.3, 0.2, pos.x) \n        + 1.4*smoothstep(0.3, -0.2, pos.z);\n    return 0.;\n}\n\n// Get the bumpmap of the floor/walls\nfloat getBumps(vec3 pos, int objnr)\n{\n    #ifdef bump_maps\n    if (objnr==FLOOR_OBJ)\n    {\n    \tfloat a = 0.8*smoothstep(rms + 0.2, rms, waterPos);\n    \treturn 0.025*(texture(iChannel0, pos.xz*textureScale + vec2(0.55, 0.)).r*a - 0.55*a);\n    }\n    else if (objnr==WALL_1_OBJ)\n        return 0.01*texture(iChannel0, pos.yz*textureScale).r;\n    else if (objnr==WALL_1_OBJ)\n        return 0.01*texture(iChannel0, pos.xy*textureScale).r;\n    else\n        return 0.;\n    #else\n    return 0.;\n    #endif    \n}\n\n// Distance mapping function of the floor\nfloat map_floor(vec3 pos)\n{\n    return pos.y;\n}\n\n// Distance mapping function of the wall on the left\nfloat map_wall_1(vec3 pos)\n{\n    return -pos.x;\n}\n\n// Distance mapping function of the wall behind\nfloat map_wall_2(vec3 pos)\n{\n    return pos.z;\n}\n\n// Flame parameters\nconst float flameIntensity = 0.4;\nconst float flameStep = 0.07;\nconst float flamePow = 1.5;\nconst float flameBias = 0.;\nconst float faf = 0.18;\nconst float fd0 = -0.04;\nconst float fg = 0.02;\nconst float dnf = -0.25;\nconst float dnx = 0.26;\nconst float dns = 40.;\nconst float fdx = 0.2;\nconst float fts = 6.;\nconst float ftf = 1.1;\nfloat ft;\n\nconst float fcp = 1.5;\n\n// Simplified mapping function of the flame\nfloat map_flame_s(vec3 pos)\n{\n   \n    vec3 q = pos*0.6;\n    q*= vec3(1., 1.5, 1.);\n    q+= vec3(ft, 0., 0.);\n    float dn = 0.5*(dnf - dnx*pos.x);\n    pos.x+= dn*noise(q + vec3(12., 3. + ft, 16.)) - dn/2.;\n    pos.y+= dn*noise(q + vec3(14., 7., 20.)) - dn/2.;\n    pos.z+= dn*noise(q + vec3(8., 22., 9.)) - dn/2.;\n\n    float df = length(pos.yz) + 0.8*pos.x + 2.;\n    \n    return df;\n}\n\n// Main mapping function of the flame\nfloat map_flame(vec3 pos, bool turb, bool bounding)\n{  \n    #ifdef show_flame\n    if (!traceFlame && bounding)\n        return 10.;\n    \n    ft = iTime*dns;\n    \n    pos-= flamePos;\n    pos.x+= tubeLenght - 0.33;\n    pos.y+= pos.x*pos.x*fg - fg;\n \n    vec3 q = pos*fts;\n    \n    if (turb)\n    {\n        #ifdef flame_a_turb\n        float n = 0.07*noise(q*0.6);\n        q.xy = rotateVec(-q.xy, pos.z*n);\n    \tq.yz = rotateVec(-q.yz, pos.x*n);\n    \tq.zx = rotateVec(-q.zx, pos.y*n);\n    \t#endif\n        \n    \tq*= vec3(1., 1.5, 1.);\n        q+= vec3(ft, 0., 0.);\n    \tq.x+= 0.5*pos.x*noise(q + vec3(30., 40., 50. + ft));\n    \tq.y+= 0.5*pos.x*noise(q + vec3(10., 30. + ft, 20.));\n    \tq.z+= 0.5*pos.x*noise(q + vec3(20., 60. - ft, 40. - ft));\n \n    \tfloat dn = (dnf - dnx*pos.x);\n    \tpos.x+= dn*noise(q + vec3(12., 3.+ ft, 16. - ft)) - dn/2.;\n    \tpos.y+= dn*noise(q + vec3(14., 7., 20.)) - dn/2.;\n    \tpos.z+= dn*noise(q + vec3(8. + ft*0.3, 22., 9.)) - dn/2.;\n    }        \n    \n    float df = length(pos.yz) + faf*pos.x + fd0;\n    \n    if (bounding)\n    {\n        df-= 0.5*smoothstep(-1.1, -4., pos.x);\n        df = mix(df, sdCylinder(pos.yxz + vec3(0., 1., 0.), vec2(tubeDiameter - 0.01, tubeLenght*2.)), smoothstep(-1.3, -1.12, pos.x));   \n    }\n    else\n        df = mix(df, sdCylinder(pos.yxz + vec3(0., 1., 0.), vec2(tubeDiameter + 0.01, tubeLenght*2.)), smoothstep(-1.5, -1.12, pos.x));   \n\n    return df;\n    #else\n    return 10.;\n    #endif\n}\n\n// Main mapping function\nvec2 map(vec3 pos)\n{\n    vec2 res;\n\n    float tube = map_tube(pos);\n    float ffloor = map_floor(pos);\n    float wall1 = map_wall_1(pos);\n    float wall2 = map_wall_2(pos);\n    float flame = map_flame(pos, false, true);\n    \n    res = vec2(tube, TUBE_OBJ);\n    res = opU(vec2(ffloor, FLOOR_OBJ), res);\n    res = opU(vec2(wall1, WALL_1_OBJ), res);\n    res = opU(vec2(wall2, WALL_2_OBJ), res);\n    //res = opU(vec2(flame, TUBE_OBJ), res);\n    res = opU(vec2(flame, FLAME_OBJ), res);\n\n    return res;\n}\n\n// Main tracing function\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 0.02;\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n    float dist2;\n    \n  \tfor (int i = 0; i < 76; ++i)\n    {\n    \tpos = ray*t + cam;\n        vec2 res = map(pos);\n        dist = res.x;\n        if (dist>maxdist || abs(dist)<0.002)\n            break;\n        t+= dist*0.75;\n        objnr = abs(res.y);\n  \t}\n  \treturn vec2(t, objnr);\n}\n\n// Gets the normal at specified position\nvec3 getNormal(vec3 pos, float e, int objnr)\n{  \n    vec2 q = vec2(0, e);\n    vec3 b = vec3(map(pos + q.yxx).x - map(pos - q.yxx).x,\n                  map(pos + q.xyx).x - map(pos - q.xyx).x,\n                  map(pos + q.xxy).x - map(pos - q.xxy).x);\n    \n    waterPos = getWaterPos(pos);\n    b+= vec3(getBumps(pos + q.yxx, objnr) - getBumps(pos - q.yxx, objnr),\n             getBumps(pos + q.xyx, objnr) - getBumps(pos - q.xyx, objnr),\n             getBumps(pos + q.xxy, objnr) - getBumps(pos - q.xxy, objnr));\n        \n        \n    \n    return normalize(b);\n}\n\n// Gets the color of the sky\nvec3 sky_color(vec3 ray)\n{ \n    return vec3(0.);\n}\n\n// Gets the color of the tube\nvec3 getTubeColor(vec3 pos)\n{\n    return tubeColor*texture(iChannel2, vec2(pos.x, 2.*atan(pos.y, pos.z))).rrr;\n}\n\n// Gets the color of the floor\nvec3 getFloorColor(vec3 pos)\n{\n    return floorColor*mix(texture(iChannel0, pos.xz*textureScale + vec2(0.55, 0)).rgb, \n                          texture(iChannel0, pos.xz*textureScale + vec2(0.55, 0)).rrr, 0.8);\n}\n\n// Gets the color of the wall on the left\nvec3 getWallColor1(vec3 pos)\n{\n    return wallColor*mix(texture(iChannel0, pos.yz*textureScale).rgb, \n                         texture(iChannel0, pos.yz*textureScale).rrr, 0.6);\n}\n\n// Gets the color of the wall behind\nvec3 getWallColor2(vec3 pos)\n{\n    return wallColor*mix(texture(iChannel0, pos.xy*textureScale).rgb, \n                         texture(iChannel0, pos.xy*textureScale).rrr, 0.6);\n}\n\n// Gets the reflection factor of the floor in function of the position\nfloat getFloorReflection(vec3 pos)\n{\n    return 0.85*smoothstep(rms - 0.1, rms + 0.25, getWaterPos(pos));\n}\n\n// Gets the color of the flame\nvec3 getFlameColor(vec3 pos)\n{\n    return flameColor;\n}\n\n// Gets the color of the flame depending on the position and ray direction by volume sampling\nvec3 getFlameDensColor(vec3 pos, vec3 ray, float s, float fi, int nbSteps)\n{\n    float d = 1.;\n    float f;\n    vec3 scol = vec3(0.);\n    for (int i=0; i<70; i++)\n    {\n    \tif (i==nbSteps)\n            break;\n        pos+= ray*s;\n        f = -map_flame(pos, true, false);\n        f = sign(f)*pow(abs(f), flamePow);\n    \td = clamp(f + flameBias, 0., 10.);\n        d*= smoothstep(-7. - 0.8*flameVar, -4. - 0.3*flameVar, pos.x)*smoothstep(-1.3, -1.5, pos.x)*(3. + 0.4*pos.x);\n        d*= (0.7 + 20./(pow(abs(pos.x), 3.) + 1.3));\n        d*= 1. + 14.*smoothstep(-1.88, -1.2, pos.x);\n        scol+= d*getFlameColor(pos);\n    }\n    \n    return clamp(scol*fi, 0., 1.5);\n}\n    \n// Combines the colors\nvec3 getColor(vec3 norm, vec3 pos, int objnr, vec3 ray)\n{\n   pos = rotateVec2(pos);\n   return (objnr==TUBE_OBJ?getTubeColor(pos):\n          (objnr==FLOOR_OBJ?getFloorColor(pos):\n          (objnr==WALL_1_OBJ?getWallColor1(pos):\n          (objnr==WALL_2_OBJ?getWallColor2(pos):\n           vec3(0.)))));\n}\n\n// From https://www.shadertoy.com/view/Xds3zN\nfloat calcAO(in vec3 pos, in vec3 nor)\n{\n\tfloat occ = 0.0;\n    float sca = 1.1;\n    for(int i=0; i<10; i++)\n    {\n        float hr = 0.06 + 0.3*float(i)/4.0;\n        vec3 aopos =  nor*hr + pos;\n        float dd = map(aopos).x;\n        occ+= -(dd - hr)*sca;\n        sca*= 1.3;\n    }\n    //occ = 2.*smoothstep(0.06, 0.5, occ);\n    return clamp( 1.0 - 0.03*occ, 0.0, 1.0 );    \n}\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   float n1 = 1.; // air\n   float angle = acos(-dot(ray, norm));\n   float r0 = dot((n1-n2)/(n1 + n2), (n1 - n2)/(n1 + n2));\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return r;\n}\n\n// Shading of the objects pro lamp\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, int objnr, int lampnr)\n{     \n    vec3 lp = lamp.position;\n    float li = lamp.intensity;\n    vec3 lc = lamp.color;\n    if (lampnr==2)\n    {\n        lp = pos + norm;\n        #ifdef show_flame\n        li = 1.2*(1. + 0.3*flameVar)*clamp(3.*(1. - 0.25*map_flame_s(pos)), 0., 5.);\n        #endif\n    }\n    \n    vec3 pl = normalize(lp - pos);\n    float dlp = distance(lp, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n    float dnp = dot(norm, pli);\n    float specintc;\n    float specshinc;\n      \n    // Diffuse shading\n    vec3 col;\n    col = ocol*lc*li*clamp(dnp, 0., 1.);\n    \n    // Specular shading\n    #ifdef specular\n    // Special varaiation of the specular shading for the floor\n    if (objnr==FLOOR_OBJ)\n    {\n       \tspecintc = clamp(1.2*getFloorReflection(pos), 0., 1.);\n       \tspecshinc = 50.*pow(specint, 0.5);\n    }\n    else\n    {\n        specintc = specint;\n        specshinc = specshin;\n    }\n    \n    //if (dot(norm, lp - pos) > 0.0)\n    if (lampnr<2)\n        col+= lamp.color*li*specintc*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshinc);\n    #endif\n    \n    return col;\n}\n\n// Shading of the objects over all lamps\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, int objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<3; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol, objnr, l);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n// Sets the position of the camera with the mouse and calculates its direction\nvoid setCamera()\n{\n   vec2 iMouse2;\n   if (iMouse.x==0. && iMouse.y==0.)\n      iMouse2 = iResolution.xy*vec2(0.52, 0.65);\n   else\n      iMouse2 = iMouse.xy;\n   \n   campos = vec3(-3. + 10.*cos(1.3 + 1.3*iMouse2.x/iResolution.x)*(1. - 0.3*iMouse2.y/iResolution.y),\n                 12.*(iMouse2.y/iResolution.y),\n                 10.*sin(1.3 + 1.3*iMouse2.x/iResolution.x)*(1. - 0.3*iMouse2.y/iResolution.y));\n   camtarget = vec3(-2., -1.2*iMouse2.y/iResolution.y + 1.1, 0.);\n   camdir = camtarget - campos;   \n}\n\n// Combine the flame color with its background in a non-linear way\nvec3 combFlameCol(vec3 col1, vec3 col2)\n{\n    return pow(pow(col1, vec3(fcp)) + pow(clamp(col2, 0., 1.), vec3(fcp)), vec3(1./fcp));   \n}\n\n// Tracing and rendering a ray\nvec3 flamecol = vec3(0.);\nRenderData trace0(vec3 tpos, vec3 ray, float maxdist, bool ref)\n{\n    traceFlame = true;\n    vec2 tr = trace(tpos, ray, maxdist);\n    traceFlame = false;\n    float tx = tr.x;\n    int objnr = int(tr.y);\n    vec3 col;\n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    float flameIntensityV = flameIntensity*(1. + 0.37*flameVar);\n    \n    if (ref)\n    {\n        if (map_flame(tpos, false, true)>9. && map_tube(pos)>0.3)\n        \tflamecol = getFlameDensColor(tpos, ray, flameStep, flameIntensityV, 70);\n        else\n            flamecol = vec3(0.);\n    }\n    if (tx<maxdist*0.95)\n    {\n        vec3 rayRef = vec3(0.);\n        \n        // Includes the flame in the scene\n        if (objnr==FLAME_OBJ)\n        {\n            flamecol = getFlameDensColor(pos, ray, flameStep, flameIntensityV, 70);\n            \n            // Calculating the effect of the heat refraction (quick and dirty)\n            #ifdef heat_refraction\n            rayRef = 0.032*clamp(smoothstep(-2.2, -2.5, pos.x)*pow(flamecol, vec3(1.2)), -1., 1.);\n            #endif\n        }\n            \n        tr = trace(tpos, ray*(1. + rayRef), maxdist);\n        tx = tr.x;\n        objnr = int(tr.y);\n        pos = tpos + tx*ray;\n         \n        norm = getNormal(pos, normdelta, objnr);\n        col = getColor(norm, pos, objnr, ray);\n      \n        // Shading\n        col = ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n        \n        // Ambient occlusion\n        #ifdef ambocc\n        #ifdef test_ambocc\n        col = vec3(calcAO(pos, norm));\n        #else\n        col*= 1. - aoint + aoint*vec3(calcAO(pos, norm));\n        #endif\n        #endif\n        \n        // The end of the tube is glowing from the heat!\n        #ifdef show_flame\n        if (objnr==TUBE_OBJ)\n            col+= smoothstep(-0.6, -2., pos.x)*vec3(0.35, 0.13, 0.)*(0.8 + 0.2*flameVar);\n        #endif\n        \n        col = combFlameCol(col, flamecol);\n    }\n    else\n    {\n        objnr = SKY_OBJ;\n        col = vec3(0.);\n    }\n    return RenderData(col, pos, norm, objnr);\n}\n\n// Main render function with reflections and refractions\nvec4 render(vec2 fragCoord)\n{   \n  \tvec2 uv = fragCoord.xy / iResolution.xy; \n  \tuv = uv*2.0 - 1.0;\n  \tuv.x*= iResolution.x / iResolution.y;\n\n  \tvec3 ray0 = GetCameraRayDir(uv, camdir, fov);\n    vec3 ray = ray0;\n  \tRenderData traceinf0 = trace0(campos, ray, maxdist, false);\n    RenderData traceinf = traceinf0;\n  \tvec3 col = traceinf.col;\n    vec3 refray;\n    \n    #ifdef reflections\n    vec3 flamecol0 = flamecol;\n    if (traceinf.objnr==FLOOR_OBJ)\n    {\t               \n        refray = reflect(ray, traceinf.norm);\n\n        RenderData traceinf_ref = trace0(traceinf.pos, refray, maxdist, true);\n        float rf = getFloorReflection(traceinf.pos);\n\n        col = combFlameCol(mix(col, traceinf_ref.col, rf), rf*flamecol0);\n        //col = combFlameCol(traceinf_ref.col, flamecol0);\n        //col = traceinf_ref.col;\n    }\n    #endif\n\n  \treturn vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    init();    \n    setCamera();\n    \n    // Antialiasing.\n    #ifdef antialias\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vs/vec4(aasamples*aasamples);\n    #else\n    fragColor = render(fragCoord);\n    #endif\n}  ","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"XsfGRr","channel":0}],"code":"const float f = 16000.;\nconst float d = 222.5;\n\nfloat rand2(vec2 co)\n{\n    float r1 = fract(sin(dot(co.xy ,vec2(16.9898,78.233))) * 23758.5453);\n    return fract(sin(dot(vec2(r1, co.xy*1.562) ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise(float x)\n{\n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    vec2 n = vec2(p, p+1000.);\n    return mix(rand2(n), rand2(n + 1.0),f);\n}\n\nvec2 getSound(float t)\n{\n    float flameVar = sin(t*0.55) + 0.56*sin(t*0.134) + 0.22*sin(t*0.095);\n    float d2 = d*(1. - 0.02*flameVar);\n    \n    float t2 = f*(mod(t, 3.254) + mod(t, 1.8456));\n    float l = noise(t2) - 0.8*noise(t2 + d2*0.5) + 0.5*noise(t2 - d2);\n    float r = noise(t2 + 1000.) - 0.8*noise(t2 + d2 + 3000.) + 0.5*noise(t2 + d2*0.5 + 3000.);\n    \n    return (0.8 + 0.3*flameVar)*(1. + 0.3*noise(t*16.))*vec2(l, r);\n} \n\nvec2 mainSound( in int samp, float time )\n{\n    vec2 s = 0.5*getSound(time);\n    return s;\n}","name":"Sound","description":"","type":"sound"}]}