{"ver":"0.1","info":{"id":"XXjcWD","date":"1727287349","viewed":34,"name":"Fork website -CyberpunkDiscotech","username":"MercyMay","description":"Fork website - Cyberpunk Discotech","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["minimal"],"hasliked":0,"parentid":"4st3DS","parentname":"website background #2"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.14159;\nconst float pi2 = pi * 2.;\nconst vec2 cellSizePixels = vec2(192.,192.);\nfloat edgeSizePixels = 2.5;\nconst float iterations = 5.;\n\nvec2 q(vec2 x, vec2 p) {\n    return floor(x/p)*p;\n}\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 rand3(vec2 p) {\n    vec3 p2 = vec3(p, rand(p));\n    return fract(sin(vec3(\n        dot(p2,vec3(127.1,311.7,427.89)),\n        dot(p2,vec3(269.5,183.3,77.24)),\n        dot(p2,vec3(42004.33,123.54,714.24))\n    ))*43758.5453);\n}\n\nfloat sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br) {\n    vec2 d = max(tl - uv, uv - br);\n    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\n}\n\nmat2 rot2D(float r) {\n    float c = cos(r), s = sin(r);\n    return mat2(c, s, -s, c);\n}\n\nfloat pulse(float x, float pulseWidth, float totalPeriod) {\n    x = mod(x,totalPeriod);\n    x -= pulseWidth /= 2.;\n    return 1.-smoothstep(0.,pulseWidth, abs(x));\n}\n\n// New function to generate neon cyberpunk colors\nvec3 neonColor(float t) {\n    vec3 color1 = vec3(0.0, 1.0, 1.0);  // Cyan\n    vec3 color2 = vec3(1.0, 0.0, 1.0);  // Magenta\n    vec3 color3 = vec3(1.0, 1.0, 0.0);  // Yellow\n    \n    float t1 = fract(t);\n    float t2 = fract(t + 0.33333);\n    float t3 = fract(t + 0.66666);\n    \n    return color1 * smoothstep(0.0, 0.5, t1) * smoothstep(1.0, 0.5, t1) +\n           color2 * smoothstep(0.0, 0.5, t2) * smoothstep(1.0, 0.5, t2) +\n           color3 * smoothstep(0.0, 0.5, t3) * smoothstep(1.0, 0.5, t3);\n}\n\n// Glow effect\nvec3 neonGlow(vec3 color, float intensity) {\n    return color * intensity / (1.0 + length(color));\n}\n\nvoid mainImage(out vec4 o, in vec2 i) {\n    vec2 uv = i / iResolution.xy - .5;\n    vec2 uvn = uv;\n    uv += iMouse.xy * .1 / iResolution.xy;\n    \n    if(iResolution.x > iResolution.y)\n        uv.x *= iResolution.x / iResolution.y;\n    else\n        uv.y /= iResolution.x / iResolution.y;\n    \n    uv *= 1.+sin(iTime*0.3)*.15; // zoom\n    uv -= .7; // offset rotation origin\n    float rotation = -(iTime+40.)*0.008;\n    uv *= rot2D(rotation);\n    \n    vec2 cellSize = cellSizePixels / iResolution.x;\n    vec2 cellOrig;\n    float cellID;\n    float edgeSizePixels = 7.;\n    for(float i = 0.; i < iterations; i++) {\n        cellSize *= .5;\n        edgeSizePixels *= .5;\n        cellOrig = q(uv, cellSize);\n        cellID = rand(cellOrig);\n        if(i/iterations > sin(cellID*6.28+iTime*.3)*.5+.3)\n            break;\n    }\n    edgeSizePixels = max(edgeSizePixels, 1.);\n    \n    float distToCenter = distance(uv, cellOrig+cellSize/2.)/(length(cellSize)/2.);\n    vec2 tl = cellOrig;\n    vec2 br = cellOrig + cellSize;\n    float distToEdge = sdAxisAlignedRect(uv, tl, br) / length(cellSize);\n    \n    float edgeSize = edgeSizePixels/iResolution.x/length(cellSize);\n    float aEdge = smoothstep(-edgeSize, 0., distToEdge);\n    \n    float totalPulsePeriod = 3.; // in seconds\n    float highlightDuration = 0.6;\n    float highlightStrength = 3.0;\n    float highlight = pulse((cellID*totalPulsePeriod*totalPulsePeriod)+iTime,highlightDuration,totalPulsePeriod)*highlightStrength+1.;\n    \n    // cell background\n    vec3 cellColor = neonColor(cellID + iTime * 0.1);\n    o = vec4(cellColor.rgb, 1.0) * 0.8;\n    o *= highlight;\n    o.rgb = neonGlow(o.rgb, 1.5);\n    o *= 1.-distToCenter*.3;\n    \n    // edge color\n    vec4 edgeColor = vec4(1.0, 1.0, 1.0, 1.0);\n    o = mix(o, edgeColor, aEdge);\n    \n    // saturation boost\n    o = clamp(o, 0., 1.);\n    o.rgb = mix(o.rgb, vec3(dot(o.rgb, vec3(0.299, 0.587, 0.114))), -0.7);\n    \n    // cyberpunk scan lines\n    float scanLine = sin(uvn.y * 500.0 + iTime * 5.0) * 0.05;\n    o.rgb += vec3(scanLine);\n    \n    // digital noise\n    float noise = rand(uvn * 10.0 + iTime) * 0.05;\n    o.rgb += vec3(noise);\n    \n    // vignette\n    uvn *= 1.2;\n    o *= 1.-dot(uvn,uvn);\n    \n    // color aberration\n    float aberration = 0.01;\n    o.r += texture(iChannel0, uv + vec2(aberration, 0.0)).r * 0.5;\n    o.b += texture(iChannel0, uv - vec2(aberration, 0.0)).b * 0.5;\n    \n    // gamma\n    o = clamp(o,0.,1.);\n    o = pow(o, vec4(1./1.1));\n}","name":"Image","description":"","type":"image"}]}