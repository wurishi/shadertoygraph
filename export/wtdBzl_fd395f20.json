{"ver":"0.1","info":{"id":"wtdBzl","date":"1613313830","viewed":192,"name":"Heart Ribbon","username":"sylvain69780","description":"** VALENTINE DAY **\nBased on \n[url=https://www.shadertoy.com/view/3tdczX]Happy New Year using a Scytale ![/url]","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["helix"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Heart Ribbon\n    ------------\n\n    May be it's not too late for a nice message to your girl(boy)friend, \n    just fork and change the text !\n    \n    Related references\n    \n    Heart - distance 2D  - IQ\n    https://www.shadertoy.com/view/3tyBzV\n\n*/\n\n\n#define AA\n\n#define MAX_STEPS 256\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\n#define PI 3.14159265\n#define TAU 6.283185\n#define iFont iChannel0\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\n// a flat band of 1 unit wide, wound around an infinite cylinder of radius r\n// with UV parameters\nvec3 wrappedCylinder(vec3 p, float r) \n{\n    p.y-=-.5; // center the starting point at y=zero\n    float tpr = atan(p.z, p.x);\n    float tp = tpr/TAU;\n    float turn = p.y-tp;      // counting the turns\n    float count=floor(turn);\n    float delta=fract(turn);\n    float ts=tp+count;\n    float u=ts*r*TAU;\n    float v=delta-.5; // from -.5 to .5\n    // fix orientation regarding the slope\n     float slope = 1.0/(TAU*r);\n     u+=v*slope/sqrt(1.0+slope*slope); // sin(atan(x)) = x/sqrt(x2+1)\n     // distance calculation\n    float d = length(p.xz) - r;\n    return vec3(d,u,v);\n}\n\n// infinite ribbon wound around a cylinder of radius r and given spacing and thickness\n// with parametrization that can be used as a bounding volume\n// to make horrible fake but cool distance fields\nvec4 ribbon(vec3 p, float r, float spacing, vec2 thickness)\n{\n    float scale=spacing+1.0;\n    vec3 duv = scale*wrappedCylinder(p/scale,r/scale); // distances may be preserved\n    float w=duv.x;\n    vec2 uv=duv.yz;\n    vec2 q=duv.xz;\n    float d=sdBox(q,thickness*.5);\n    return vec4(d,uv,w);\n}\n\nfloat char(vec2 p, int c) {\n  if (c==64 || fwidth(p.y)>0.5 ) return 0.0; \n  float l = log2(length(fwidth(p/16.*iResolution.xy)));\n  return textureLod( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), l).x;\n}\n\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 animateRibbon() {\n    float atime = mod(T,10.0);\n    float l = 1.0-(S(1.0,4.0,atime)-S(7.0,9.0,atime));\n    float r=10./TAU+3.0*l;\n    float s=0.1+l*3.0;\n    return vec3(r,s,atime);\n}\n\nvec4 heartRibbon(vec3 p) {\n    p.x-=-7.0*.5; // center\n    float l=51.0; // length of the ribbon\n    vec3 anime = animateRibbon();\n    float r=anime.x;\n    float spacing = anime.y;   \n    p.z+=r; // stabilization of the start of the ribbon\n    p.yz*=Rot(3.14159*.6);\n    p.xy*=Rot(3.14159*.5);\n    vec2 boundThickness = vec2(1.0,.95);\n    float boundDist=1.0-boundThickness.y;\n    vec4 duvw = ribbon(p,r,spacing,boundThickness);\n    vec3 q=duvw.yzw;\n    float d=duvw.x;\n    if ( d > boundDist ) return vec4(d,0.0,vec2(0)); \n    float m=q.z > 0.0 && q.x >.1 && q.x <l-.1 ? 1.0 : 2.0;    \n    vec2 thickness=vec2(.0,.3);\n    float dCapped=sdBox(q.yz,thickness.yx);\n    dCapped=opExtrussion(q.zyx-vec3(0.0,0.0,l*.5),dCapped,l*.5);\n    d=dCapped-.2; // rounding\n\n    float gate=.5+spacing-abs(q.y);   // the uvw distance should do be over the distance to the next spire\n    if ( d > gate ) return vec4(gate,0.0,vec2(0));\n    return vec4(d,m,q.xy);\n}\n\nfloat GetDist(vec3 p) {\n    vec4 q = heartRibbon(p);\n    float d = q.x;\n    return d;\n}\n\nvec3 GetDistUV(vec3 p) {\n    vec4 q = heartRibbon(p);\n    return q.yzw;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nfloat GetDistShadow(vec3 p) { // for shadow, don't use bounding distance\n    vec4 m = heartRibbon(p);\n    return m.y == 0.0 ? 100.0 : m.x;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n//     float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<24; i++ )\n    {\n\t\tfloat h = GetDistShadow( ro + rd*t );\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(f,vec3(0,1,0))),\n        u = cross(r,f),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\n// IQ https://www.shadertoy.com/view/3tyBzV\nfloat sdHeart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 m = (iMouse.xy-0.5*iResolution.xy)/iResolution.xy;\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 0, 8);\n    vec3 target = vec3(0);\n    if ( iMouse.x > 0.0) {\n        ro.yz *= Rot(-m.y*3.14);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        float atime = mod(T,10.0);\n        float atime2=1.0-(S(0.0,4.0,atime)-S(5.0,9.0,atime));\n        float atime3=S(4.0,6.0,atime);\n        ro = vec3(0, 0, 8);\n        vec3 ro2 = vec3(0, 0, 7);\n        ro=mix(ro2,ro,atime2);\n        ro.xz *= Rot(-.5*atime2);\n        ro.xz *= Rot(TAU*atime3);\n    }\n    vec3 tcol = vec3(0);\n#ifdef AA\n\tfor (float dx = 0.; dx <= 1.; dx++)\n\t\tfor (float dy = 0.; dy <= 1.; dy++) {\n\t\t\tvec2 uv = (fragCoord + vec2(dx, dy) * .5 - .5 * iResolution.xy) / iResolution.y;\n#else\n\t\t\tvec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n#endif    \n    vec3 rd = GetRayDir(uv, ro, target, 1.);\n    \n    vec3 bgcol=vec3(0.9,0.2,0.3)*vec3(0.9/(1.0+10.0*rd.y*rd.y));\n\n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        \n    \tfloat dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        vec3 q = GetDistUV(p);\n        float m=q.x;\n        vec2 suv=vec2(q.y,q.z+0.5);\n        // lighting : in these few lines there is all the magic \n        float ks = 2.0; // specular effect by IQ\n        // This is coming from Happy Jumping video\n        float occ = calcOcclusion(p,n);\n        vec3  sun_lig = normalize(vec3( -0.8, 0.35, 1.5) );\n        float sun_dif = clamp(dot( n, sun_lig ), 0.0, 1.0 );\n        vec3  sun_hal = normalize( sun_lig-rd );\n        float sun_sha = calcSoftshadow( p+0.01*n, sun_lig, 0.1, 2.1 ); ; //1.0; //step(MAX_DIST,RayMarch( p+0.01*n, sun_lig ));\n\t\tfloat sun_spe = ks*pow(clamp(dot(n,sun_hal),0.0,1.0),8.0)*sun_dif*(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n\t\tfloat sky_dif = sqrt(clamp( 0.5+0.5*n.y, 0.0, 1.0 ));\n        float bou_dif = sqrt(clamp( 0.1-0.9*n.y, 0.0, 1.0 ))*clamp(1.0-0.1*p.y,0.0,1.0);\n                    // gold\n            col = vec3(0.9,0.6,0.1);\n            vec3 r = reflect(rd, n); // inspired by backle metal effect\n            float directionality=0.75;\n            float sharpness=0.7;\n            float spec = length(sin(r * 3.) * directionality + (1. - directionality)) / sqrt(3.);\n            spec = spec + pow(spec, 10. * sharpness);\n            col =  spec * col * (.3+.7*sun_sha) * occ;  //https://www.shadertoy.com/view/tlscDB    \n\n        if ( m == 1.0 ) {\n            vec2 auv=fract(suv.yx)*2.0-vec2(1.,0.65);\n            float da=sdHeart(auv)+sin(T*4.0+floor(suv.x))*.05;\n            vec3 c = .5*vec3(1.0,0.1,0.1)*S(0.1,-0.3,da);\n            int _c;                                          // prepare draw text\n            int idx=int(suv.x);\n            { int a=1,b=2,c=3,d=4,e=5,f=6,g=7,h=8,i=9,j=10,k=11,l=12,m=13,n=14,o=15,p=16,q=17,r=18,s=19,t=20,u=21,v=22,w=23,x=24,y=25,z=26,num0=48-64,num2=50-64,num1=49-64;\n            // message\n             _c = 64 + int[]( 0,0,0,0,0,0,0,0,0,l,0,0,0,0,0,0,0,0,0,o,0,0,0,0,0,0,0,0,0,v,0,0,0,0,0,0,0,0,0,e,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n                            ) [idx];\n            }\n           if (_c != 64 ) { c=.3*vec3(0.4,0.4,0.1)*char((fract(suv.yx)),_c); }\n            vec3 lin = vec3(0.0);\n            lin += sun_dif*vec3(8.10,6.00,4.20)*sun_sha;\n            lin += sky_dif*vec3(0.50,0.70,1.00)*occ;\n            lin += bou_dif*vec3(0.40,1.00,0.40)*occ;\n            c = c*lin;\n            c += sun_spe*vec3(8.10,6.00,4.20)*sun_sha;\n           col=mix(col,c,S(0.45,0.40,abs(suv.y-0.5)));\n        } \n    } else { col = bgcol; }\n        // fog\n        float fog=S(20.0,10.0,d);\n        col = mix(bgcol, col, fog);\n        tcol+=col;\n#ifdef AA\n\t\t}\n\ttcol /= 4.;\n#endif    \n    col = pow(tcol, vec3(.4545));\t// gamma correction\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}