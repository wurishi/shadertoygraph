{"ver":"0.1","info":{"id":"MtsyW4","date":"1504968730","viewed":222,"name":"Overlapping Cylinders","username":"TambakoJaguar","description":"I imagined a simple mechanical prototype of two overlapping cylinders. It tries to recreate what is easily made in computer graphics but impossible in real. Click and drag the mouse to rotate it, cut it in half and get colored pieces to see how it works.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","reflection","demo","rotating","moving","prototype","mechanical","cylinders","overlapping","pieces"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\"Overlapping Cylinders\" by Emmanuel Keller aka Tambako - September 2017\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.14159265359\n\n// Switches, you can play with them!\n#define specular\n#define reflections\n//#define always_cut\n//#define antialias\n\nstruct Lamp\n{\n  \tvec3 position;\n  \tvec3 color;\n  \tfloat intensity;\n  \tfloat attenuation;\n};\n\nstruct RenderData\n{\n  \tvec3 col;\n  \tvec3 pos;\n  \tvec3 norm;\n  \tint objnr;\n};\n    \n// Every object of the scene has its ID\n#define SKY_OBJ      0\n#define C1_OBJ       1\n#define C2_OBJ       2\n#define CC_OBJ       3\n#define BOX_OBJ      4\n#define WHEEL_OBJ    5\n\nLamp lamps[3];\n\n// Campera options\nvec3 campos = vec3(0., -0.8, 11.);\nvec3 camdir = vec3(0., 0., -1.);\nfloat fov = 4.3;\nfloat angle = 0.;\nfloat angle2 = 0.;\n\n// Ambient light\nconst vec3 ambientColor = vec3(0.5);\nconst float ambientint = 0.3;\n\n// Shading options\nconst float specint = 0.4;\nconst float specshin  = 25.;\n\n// Tracing options\nconst float normdelta = 0.001;\nconst float maxdist = 30.;\nconst int nbref = 3;\nconst float mesh_ior = 3.2;\nconst float mesh_gref = 0.78;\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.8;\nconst int aasamples = 2;\n\n// Geometry constants\nconst float cr = 0.8;\nconst float cl = 1.1;\nconst float ce = 1.1;\nconst float boxYPos = -1.4;\nconst vec3 boxSize = vec3(2., 1.4, 1.3);\n\n// Movement constants\nconst float cma = 0.33;\nconst float cms = 6.5;\n\nbool cut_obj;\n\nvoid init()\n{\n    lamps[0] = Lamp(vec3(-1.5, 3., 6.), vec3(1., 1., 1.), 1.5, 0.01);\n    lamps[1] = Lamp(vec3(5., -2., 1.), vec3(0.75, 0.85, 1.), 1.3, 0.01);\n    lamps[2] = Lamp(vec3(-3., 5., -8.), vec3(1., 0.6, 0.5), 0.3, 0.01);\n}\n\n// Union operation from iq\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n// Difference operation from iq\nfloat opS(float d1, float d2)\n{\n    return max(-d2,d1);\n}\n\n// From https://www.shadertoy.com/view/Xds3zN\nfloat sdCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// From https://www.shadertoy.com/view/Xds3zN\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) - vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) + vect.y*cos(angle);\n    return rv;\n}\n\nvec3 rotateVec2(vec3 posr)\n{\n    posr = vec3(posr.x, posr.y*cos(angle2) + posr.z*sin(angle2), posr.y*sin(angle2) - posr.z*cos(angle2));\n    posr = vec3(posr.x*cos(angle) + posr.z*sin(angle), posr.y, posr.x*sin(angle) - posr.z*cos(angle)); \n    \n    return posr;\n}\n\nfloat getCylYPos()\n{\n    return cma*sin(cms*iTime);     \n}\n\nvec2 map1(vec3 pos)\n{\n    pos = rotateVec2(pos);\n\n    vec2 obj;\n    \n    float ypos = getCylYPos();\n    \n    vec2 c1 = vec2(sdCylinder(pos - vec3(-ce/2., ypos, 0.), vec2 (cr, cl)), C1_OBJ);\n    vec2 c2 = vec2(sdCylinder(pos - vec3(ce/2., -ypos, 0.), vec2 (cr, cl)), C2_OBJ);\n    vec2 box = vec2(sdBox(pos - vec3(0., boxYPos, 0.), boxSize), BOX_OBJ);\n    obj = opU(c1, c2);\n    obj = opU(obj, box);\n \n    //obj.x = max(obj.x, pos.z);\n\n    return obj;\n}\n\nvec2 map2(vec3 pos)\n{\n    pos = rotateVec2(pos);\n\n    vec2 obj;\n    \n    float ypos = getCylYPos();\n    float ypos2 = cl - 1.2;\n    \n    float c1a = sdCylinder(pos - vec3(-ce/2., ypos + ypos2, 0.), vec2(cr, cl));\n    float c2a = sdCylinder(pos - vec3(ce/2., -ypos + ypos2, 0.), vec2(cr, cl));\n    float c1b = sdCylinder(pos - vec3(-ce/2., ypos, 0.), vec2(cr, 10.));\n    float c2b = sdCylinder(pos - vec3(ce/2., -ypos, 0.), vec2(cr, 10.));\n    float c1b2 = sdCylinder(pos - vec3(-ce/2., ypos, 0.), vec2(cr - 0.005, 10.));\n    float c2b2 = sdCylinder(pos - vec3(ce/2., -ypos, 0.), vec2(cr - 0.01, 10.));\n    float c1b3 = sdCylinder(pos - vec3(-ce/2., ypos, 0.), vec2(cr + 0.005, 10.));\n    float c2b3 = sdCylinder(pos - vec3(ce/2., -ypos, 0.), vec2(cr + 0.005, 10.));\n    float c1c = opS(c1a, c2b);\n    float c2c = opS(c2a, c1b);\n    \n    float cca = max(c1b2, c2b2);\n    float mposy = max(ypos, -ypos);\n    cca = max(cca, pos.y - mposy - cl - ypos2);\n    cca = max(cca, -pos.y + mposy - cl - ypos2);\n    \n    float cbc = sdCylinder(pos.yxz + vec3(-mposy + 0.85, 0., 0.), vec2(0.12, 0.5));\n    float bbc = sdBox(pos - vec3(0., mposy - 1.08, 0.), vec3(0.5, 0.22, 0.12)); \n    cca = opS(cca, cbc);\n    cca = opS(cca, bbc);\n    \n    float cb1 = sdCylinder(pos.yxz + vec3(-ypos + 0.85, 0.17, 0.), vec2(0.115, 0.12));\n    c1c = min(c1c, cb1);\n    \n    float cb2 = sdCylinder(pos.yxz + vec3(ypos + 0.85, -0.17, 0.), vec2(0.115, 0.12));\n    c2c = min(c2c, cb2);\n    \n    vec2 c1 = vec2(c1c, C1_OBJ);\n    vec2 c2 = vec2(c2c, C2_OBJ);\n    vec2 cc = vec2(cca, CC_OBJ);\n    \n    float boxa = sdBox(pos - vec3(0., boxYPos, 0.), boxSize);\n    boxa = opS(boxa, c1b3);\n    boxa = opS(boxa, c2b3);\n    float boxi = sdBox(pos - vec3(0., boxYPos - 0.65, 0.), boxSize*0.85);\n    boxa = opS(boxa, boxi);\n    float cbox = sdCylinder(pos.yxz + vec3(1.8, 0., 0.), vec2(0.12, boxSize.x*1.1));\n    boxa = opS(boxa, cbox);\n    \n    vec2 box = vec2(boxa, BOX_OBJ);\n    \n    vec3 posr = pos;\n    posr.y+= 1.8;\n    posr.yz = rotateVec(posr.yz, cms*iTime - pi*0.5);\n    float wc0 = sdCylinder(posr.yxz + vec3(0., 0.25, 0.), vec2(0.115, boxSize.x*1.2));\n    float wc1 = sdCylinder(posr.yxz + vec3(cma, -ce*0.5 - 0.1, 0.), vec2(0.6, 0.2));\n    float wc2 = sdCylinder(posr.yxz + vec3(-cma, ce*0.5 + 0.1, 0.), vec2(0.6, 0.2));\n    float wc3 = sdCylinder(posr.yxz + vec3(0., boxSize.x*1.25, 0.), vec2(0.65, 0.1));\n    float wc4 = sdCylinder(posr.yxz + vec3(0.55, boxSize.x*1.33, 0.), vec2(0.08, 0.2));\n    float wheela = min(min(min(min(wc0, wc1), wc2), wc3), wc4);\n    vec2 wheel = vec2(wheela, WHEEL_OBJ);\n    \n    obj = opU(c1, c2);\n    obj = opU(obj, cc);\n    obj = opU(obj, box);\n \n    #ifndef always_cut\n    if (cut_obj)\n    #endif\n       obj.x = max(obj.x, pos.z);\n\n    obj = opU(obj, wheel);\n    \n    return obj;\n}\n\nvec2 map(vec3 pos)\n{\n    return map2(pos);\n}\n\n// Edge value. From Shane.\nfloat getEdgeVal(vec3 p, float edgeDelta)\n{ \n\t\n\t// Edge spread of a few pixels, regardless of resolution.\n\t// Constant values could also be used.\n\tvec2 e = vec2(edgeDelta/iResolution.y, 0);\n\n\t// Nearby sample values.\n\tfloat d1 = map(p + e.xyy).x, d2 = map(p - e.xyy).x;\n\tfloat d3 = map(p + e.yxy).x, d4 = map(p - e.yxy).x;\n\tfloat d5 = map(p + e.yyx).x, d6 = map(p - e.yyx).x;\n\tfloat d = map(p).x*2.;\n\n\t// Edge value. One of a few ways to do it, depending on\n\t// the look you're after.\n\tfloat edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n\t//edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);\n\tedge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n\t\n\treturn edge;\n}\n\n\n// Main tracing function\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 0.01;\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n    \n  \tfor (int i = 0; i < 100; ++i)\n    {\n    \tpos = ray*t + cam;\n        vec2 res = map(pos);\n        dist = res.x;\n        if (dist>maxdist || abs(dist)<0.0001)\n            break;\n        t+= dist;\n        objnr = abs(res.y);\n  \t}\n  \treturn vec2(t, objnr);\n}\n\n// From https://www.shadertoy.com/view/MstGDM\n// Here the texture maping is only used for the normal, not the raymarching, so it's a kind of bump mapping. Much faster\nvec3 getNormal(vec3 pos, float e)\n{  \n    vec2 q = vec2(0, e);\n    return normalize(vec3(map(pos + q.yxx).x - map(pos - q.yxx).x,\n                          map(pos + q.xyx).x - map(pos - q.xyx).x,\n                          map(pos + q.xxy).x - map(pos - q.xxy).x));\n}\n\n// Gets the color of the sky\nvec3 sky_color(vec3 ray)\n{ \n    return 0.1 + 1.2*texture(iChannel0, ray).rgb;\n}\n\n    \n// Combines the colors\nvec3 getColor(vec3 norm, vec3 pos, int objnr, vec3 ray)\n{\n   #ifdef always_cut\n      return objnr==C1_OBJ?vec3(0.4, 0.43, 0.6):(\n             objnr==C2_OBJ?vec3(0.4, 0.6, 0.4):(\n             objnr==CC_OBJ?vec3(0.6, 0.5, 0.4):(\n             objnr==WHEEL_OBJ?vec3(0.6, 0.4, 0.5):\n                     vec3(0.5))));\n   #else\n    if (iMouse.z>0.)\n      return objnr==C1_OBJ?vec3(0.4, 0.43, 0.6):(\n             objnr==C2_OBJ?vec3(0.4, 0.6, 0.4):(\n             objnr==CC_OBJ?vec3(0.6, 0.5, 0.4):(\n             objnr==WHEEL_OBJ?vec3(0.6, 0.4, 0.5):\n                     vec3(0.5))));\n   else\n      return vec3(0.5);\n   #endif\n}\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   float n1 = 1.; // air\n   float angle = acos(-dot(ray, norm));\n   float r0 = dot((n1-n2)/(n1+n2), (n1-n2)/(n1+n2));\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return clamp(r, 0., 0.8);\n}\n\n// Shading of the objects pro lamp\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, int objnr, int lampnr)\n{   \n    vec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n    float dnp = dot(norm, pli);\n      \n    // Diffuse shading\n    vec3 col = ocol*lamp.color*lamp.intensity*smoothstep(-0.1, 1.0, dnp);\n    \n    // Specular shading\n    #ifdef specular\n    if (!cut_obj)\n       if (dot(norm, lamp.position - pos) > 0.0)\n           col+= lamp.color*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    return col;\n}\n\n// Shading of the objects over all lamps\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, int objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<3; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol, objnr, l);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n// Tracing and rendering a ray\nRenderData trace0(vec3 tpos, vec3 ray, float maxdist)\n{\n    vec2 tr = trace(tpos, ray, maxdist);\n    float tx = tr.x;\n    int objnr = int(tr.y);\n    vec3 col;\n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    \n    if (tx<maxdist*0.95)\n    {\n        norm = getNormal(pos, normdelta);\n        col = getColor(norm, pos, objnr, ray);\n      \n        // Shading\n        col = (cut_obj?vec3(0.8):ambientColor*ambientint)*col + (cut_obj?0.4:1.)*lampsShading(norm, pos, col, objnr);\n        \n        // Edging\n        if (cut_obj)\n        {\n           float edge = getEdgeVal(pos, 4.);\n           col *= 1. - edge;\n        }\n    }\n    else\n    {\n        objnr = SKY_OBJ;\n        col = sky_color(ray);\n    }\n    return RenderData(col, pos, norm, objnr);\n}\n\n// Main render function with reflections and refractions\nvec4 render(vec2 fragCoord)\n{   \n  \tvec2 uv = fragCoord.xy / iResolution.xy; \n  \tuv = uv*2.0 - 1.0;\n  \tuv.x*= iResolution.x / iResolution.y;\n\n  \tvec3 ray0 = GetCameraRayDir(uv, camdir, fov);\n    vec3 ray = ray0;\n  \tRenderData traceinf = trace0(campos, ray, maxdist);\n  \tvec3 col = traceinf.col;\n    vec3 refray;\n    float rf = 1.;\n\n    #ifdef reflections\n    if (!cut_obj)\n    {\n       for (int i=0; i<nbref; i++)\n       {\n           if (traceinf.objnr!=SKY_OBJ)\n           {\n               refray = reflect(ray, traceinf.norm);\n\n               RenderData traceinf_ref = trace0(traceinf.pos, refray, 20.);\n               rf*= fresnel(ray, traceinf.norm, mesh_ior);\n\n               col = mix(col, traceinf_ref.col, rf);\n               traceinf = traceinf_ref;\n               ray = refray;\n           }\n       }\n    }\n    #endif\n  \treturn vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    init();\n    if (iMouse.x==0. && iMouse.y==0.)\n    {\n       angle = 0.;\n       angle2 = 0.;\n    }\n    else\n    {\n       angle = 2.*pi*(iMouse.x/iResolution.x - 0.5);\n       angle2 = -2.*pi*(iMouse.y/iResolution.y - 0.5);\n    }\n    \n    cut_obj = iMouse.z>0.;\n    \n    // Antialiasing.\n    #ifdef antialias\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vs/vec4(aasamples*aasamples);\n    #else\n    //vec4 fc1 = render(fragCoord);\n    //cut_obj = true;\n    //vec4 fc2 = render(fragCoord);\n    //fragColor = mix(fc1, fc2, 0.5);\n    fragColor = render(fragCoord);\n    #endif\n}","name":"Image","description":"","type":"image"}]}