{"ver":"0.1","info":{"id":"7tfyDX","date":"1648788130","viewed":47,"name":"WIP Gradient descent lines","username":"kaia","description":"WIP of picking random points and drawing gradient descent lines up and down to maxima and minima of a function. Horribly optimized right now and no attention paid to aesthetic","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["gradientdescent"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Basic idea:\n// Define a function f(x, y) with analytic derivatives\n// Pick a grid of points and gradient descent up and down the function\n// Assign each point a random color\n\n#define PI 3.14159265359\n#define NUM_ITERS 128\n\nfloat function(vec2 pos, vec3 params) {\n    return (distance(pos, vec2(.7 + 0.2 * sin(iTime + 1.),.3 + 0.2 * sin(iTime + 1.))))\n        - (distance(pos, vec2(-.3 + 0.2 * sin(iTime + 2.),.45 + 0.2 * sin(1.3*iTime + 2.))))\n        + (distance(pos, vec2(-.7 + 0.2 * sin(0.3*iTime + 3.),.3 + 0.2 * sin(iTime + 3.))))\n        - (distance(pos, vec2(.2 + 0.2 * sin(iTime + 4.),-.6 + 0.2 * sin(0.3*iTime + 4.))));\n}\n\nvec2 funcNumericDeriv(vec2 pos, vec3 params, float dx) {\n    float f_base = function(pos, params);\n    float f_x = function(pos + vec2(dx, 0.), params);\n    float f_y = function(pos + vec2(0., dx), params);\n    return vec2(f_x - f_base, f_y - f_base) / dx;\n}\n\nvec2 rand2(float seed) {\n    return vec2(mod(seed * 13823.23, 2.) - 1.0,\n                mod(seed * 13232.37, 2.) - 1.0);\n}\n\nvec2 funcDeriv(vec2 pos, vec3 params) {\n    return vec2(0);\n    \n}\n\nfloat hardnessCalculations(float prevValue, float dist, float brushSize, float hardness) {\n    float normDist = min(1., dist / brushSize);\n    float clippedDist = max(0., (normDist - hardness)) / (1. - hardness); //  0 until dist=hardness, then linear to 1.0 at dist=1.0\n    float newValue = 1.0 - clippedDist + sin(2.*PI*clippedDist) / (2.*PI); // function with first, second order derivs 0 at 1 and 0\n    return prevValue + (1.0 - prevValue) * newValue; // pseudo-opacity saturating thing\n}\n\nfloat tracePoint(vec2 startPoint, vec2 pixelPoint, float multiplier, float brushMult) {\n    float acc = 0.;\n    vec2 point = startPoint;\n    for(int i = 0; i < NUM_ITERS; i++) {\n        vec2 deriv = funcNumericDeriv(point, vec3(0.), 0.01);\n        float brushSize = brushMult * length(deriv);\n        acc = hardnessCalculations(acc, distance(point, pixelPoint), brushSize, 0.6);\n        point += multiplier * deriv;\n        acc = hardnessCalculations(acc, distance(point, pixelPoint), brushSize, 0.6);\n        point += multiplier * deriv;\n    }\n    point = startPoint;\n    for(int i = 0; i < NUM_ITERS; i++) {\n        vec2 deriv = funcNumericDeriv(point, vec3(0.), 0.01);\n        float brushSize = brushMult * length(deriv);\n        acc = hardnessCalculations(acc, distance(point, pixelPoint), brushSize, 0.6);\n        point += multiplier * deriv * -1.;\n        acc = hardnessCalculations(acc, distance(point, pixelPoint), brushSize, 0.6);\n        point += multiplier * deriv * -1.;\n    }\n    return acc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2. * fragCoord/iResolution.xy - 1.;\n    //vec2 deriv = funcNumericDeriv(uv, vec3(0.), 0.01);\n    // Time varying pixel color\n    vec4 colAcc = vec4(0.);\n    for(int i=0; i < 16; i++) {\n        float value = tracePoint(rand2(float(i)), uv, 0.01, 0.02);\n        colAcc += vec4(vec3(value), value);\n    }\n    //vec3 col = vec3(hardnessCalculations(0., length(uv), 1., .6));\n    //vec3 col = vec3(float(length(uv) > 1.));\n    // Output to screen\n    fragColor = vec4(colAcc);\n}","name":"Image","description":"","type":"image"}]}