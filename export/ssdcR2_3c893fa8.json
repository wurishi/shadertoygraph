{"ver":"0.1","info":{"id":"ssdcR2","date":"1653786364","viewed":229,"name":"2D RayMarching (Modern_XP)","username":"Modern_XP","description":"A simple 2D ray marcher algorithm.\nI'm pretty happy with it.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","sdf","raymarcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float SpaceScale = 3.0;\n//\nvec2 NormalizeCoordinate(vec2 Input) { return (Input + Input - iResolution.xy)/iResolution.y * SpaceScale; }\n//\nvoid mainImage( out vec4 OutColor, in vec2 FragCoord ) {\n    vec3 ResultColor = vec3(0);\n    //\n    vec2 ScreenCoords = NormalizeCoordinate(FragCoord);\n    vec2 PixelSize = (2.0*SpaceScale)/iResolution.xy;\n    vec4 MousePos = texture(iChannel0,vec2(0)) * SpaceScale;\n    //\n    //ResultColor = vec3(ScreenCoords,0);\n    //\n    bool HitCheck;\n    vec2 MarchPosition;\n    vec2 MarchNormal;\n    //\n    RayMarch(ScreenCoords, MousePos.zw, normalize(MousePos.xy - MousePos.zw), MarchPosition, MarchNormal, HitCheck);\n    //\n    ResultColor = vec3(GetDistance(ScreenCoords));\n    //ResultColor.x = ResultColor.x < 0.0 ? 0.5 : 0.0;\n    //ResultColor.y = smoothstep(0.01,-0.01,ResultColor.y) * 0.25;\n    //ResultColor.z = clamp(ResultColor.z,0.0,0.5);\n    DrawGeometry(ScreenCoords,PixelSize,ResultColor);\n    DrawMarch(ScreenCoords,PixelSize,MousePos.zw,normalize(MousePos.xy - MousePos.zw),MarchNormal,ResultColor);\n    //\n    //ResultColor *= ResultColor;\n    //\n    OutColor = vec4(ResultColor,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Gets and saves mouse input.\nvoid mainImage( out vec4 OutColor, in vec2 FragCoord ) {\n    OutColor = texture(iChannel0, vec2(0));\n    vec4 Result = (iMouse.xyzw*2.0 - iResolution.xyxy) / iResolution.y;\n    OutColor.xy = Result.xy;\n    if (distance(iMouse.xy,iMouse.zw) <= 0.01) { OutColor.zw = Result.xy; }\n}\n/*\n    OutColor = texture(iChannel0, vec2(0));\n    vec4 Result = (iMouse.xyzw * 2.0 - iResolution.xyxy) / iResolution.y;\n    OutColor.xy = Result.xy;\n    if (distance(iMouse.xy, iMouse.zw) <= 0.01) { OutColor.zw += Result.xy; }\n    if (texelFetch(iChannel1, ivec2(9,0),0).x != 0.0) { OutColor = vec4(0); }\n*/","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265;\n/* These are the raymarching parameters. */\n//\n// The distance to the scene that counts as a hit.\nfloat MinDistance = 0.001;\n//\n// The distance to the scene that is considered too far away from anything so we stop checking.\nfloat MaxDistance = 100.0;\n//\n// The total number of steps we take before we stop checking.\nconst int StepCount = 100;\n//\n// The color of the surface of the geometry;\nvec4 SurfaceColor = vec4(0.25,0.375,0.625,1.0);\n//\n// The color of the inside of the geometry;\nvec4 InternalColor = vec4(0.125,0.25,0.5,0.75);\n//\n// Whether or not to draw the distance circles in the march.\nbool DrawMarchCircles = true;\n//\n/* The SDF Functions. These are what return a distance. */\n//\n// A sphere is mostly easy. You just return the distance to the centre minus the radius.\n// What is difficult is squishing or stretching the sphere. :/\n// It is doable however.\nfloat SphereSDF(vec2 SamplePoint, vec2 Position, float Rotation, vec2 Size, float Thickness) {\n    float Result = length(SamplePoint - Position) - Size.x;\n    return Result - Thickness;\n}\n//\n// A line is a bit more difficult than a sphere, but it's still fairly trivial.\n// You've got a start and end point. All you need to do is get the dot product \nfloat LineSDF(vec2 SamplePoint, vec2 StartPosition, vec2 EndPosition, float Thickness) {\n    float LineLength = length(StartPosition - EndPosition);\n    float LineDot = clamp(dot((EndPosition - StartPosition)/LineLength,(SamplePoint - StartPosition)/LineLength),0.0,1.0);\n    vec2 LinePoint = StartPosition + ((EndPosition - StartPosition) * LineDot);\n    float Result = length(SamplePoint - LinePoint);\n    return Result - Thickness;\n}\n// You can also define a line as distance from a point in a direction.\n// Here, it's a rotation defined in radians.\nfloat LineSDF(vec2 SamplePoint, vec2 Position, float Rotation, float Length, float Thickness) {\n    float Result = length(SamplePoint - Position);\n    return Result - Thickness;\n}\n//\n// A box works kind of like two lines. You get the \nfloat BoxSDF(vec2 SamplePoint, vec2 Position, float Rotation, vec2 Size, float Thickness) {\n    mat2 RotationMatrix = mat2(cos(Rotation),-sin(Rotation),sin(Rotation),cos(Rotation));\n    //\n\tvec2 ModifiedSample = (RotationMatrix * SamplePoint) - Position;\n    //\n\tfloat ValueX = abs(ModifiedSample.x)-Size.x;\n\tfloat ValueY = abs(ModifiedSample.y)-Size.y;\n    //\n    float Result = sqrt(max(ValueX,0.0)*ValueX + max(ValueY,0.0)*ValueY) + min(max(ValueX,ValueY),0.0);\n    return Result - Thickness;\n}\n//\n/* This is the function returning the distance. Feel free to change it up. :) */\nfloat GetDistance(vec2 InputPoint) {\n    float Result = 0.0;\n    //\n    Result = SphereSDF(InputPoint,vec2(-1.5,0.5),0.0,vec2(1),0.0);\n    Result = min(Result,BoxSDF(InputPoint,vec2(-2,-1),0.0,vec2(3,0.75),0.0));\n    Result = min(Result,LineSDF(InputPoint,vec2(2,2),vec2(1.5*PI,1.25),0.125));\n    Result = min(Result,max(BoxSDF(InputPoint,vec2(3,-1),0.0,vec2(1,0.5),0.0),-(SphereSDF(InputPoint,vec2(3,-0.75),0.0,vec2(0.5),0.0))));\n    //\n    //return max(ValueBuffer,-clamp((SphereSDF(InputPoint,vec2(3,-0.75),0.0,vec2(0.5),0.0)),-10.0,0.0));\n    return Result;\n}\n//\n/* This is the main raymarching function. */\n// You can mostly ignore it. It's just doing it's thing.\nvoid RayMarch(vec2 NormalizedCoord, vec2 RayOrigin, vec2 RayDir, out vec2 ResultPosition, out vec2 ResultNormal, out bool IsHit) {\n    // If the ray direction is undecided, pick down as the direction of the ray.\n    if (length(RayDir) == 0.0) { RayDir = vec2(0,-1); }\n    //\n    float TotalDistance = 0.0;\n    float StepDistance;\n    vec2 MarchedPoint = RayOrigin;\n    //\n    IsHit = false;\n    for (int i = 0; i < StepCount; i++) {\n        StepDistance = GetDistance(MarchedPoint);\n        if (StepDistance <= MinDistance) { IsHit = true; break; }\n        if (StepDistance >= MaxDistance) { break; }\n        TotalDistance += StepDistance;\n        MarchedPoint = RayOrigin + RayDir * TotalDistance;\n    }\n    ResultPosition = MarchedPoint;\n    //\n    vec2 Epsilon = vec2(0.001,0);\n    ResultNormal = normalize(\n        vec2(StepDistance) - vec2(\n            GetDistance(MarchedPoint + Epsilon.xy),\n            GetDistance(MarchedPoint + Epsilon.yx)\n        )\n    );\n}\n//\n/* This is a function for drawing the geometry. */\n// It's not too good - basically a brute force method - but it works.\nvoid DrawGeometry(vec2 NormalizedCoord, vec2 PixelSize, inout vec3 ResultColor) {\n    float Distance = GetDistance(NormalizedCoord);\n    ResultColor = mix(ResultColor,InternalColor.rgb,(Distance < 0.0) ? InternalColor.a : 0.0);\n    ResultColor = mix(ResultColor,SurfaceColor.rgb,(abs(Distance) < (1.0 * length(PixelSize))) ? SurfaceColor.a : 0.0);\n}\n//\n/* This is for drawing the marching. */\nvoid DrawMarch(vec2 Coord, vec2 PixelSize, vec2 StartPoint, vec2 RayDirection, vec2 FinalNormal, inout vec3 ResultColor) {\n    float TotalDistance = 0.0;\n    float StepDistance;\n    vec2 MarchedPoint = StartPoint;\n    //\n    float SmallestDistance = MaxDistance;\n    //\n    float PointBuffer[StepCount], CircleBuffer[StepCount], DistanceBuffer[StepCount];\n    //\n    int IterationCount;\n    //\n    for (int i = 0; i < StepCount; i++) {\n        IterationCount = i;\n        //\n        StepDistance = abs(GetDistance(MarchedPoint));\n        SmallestDistance = min(SmallestDistance,StepDistance);\n        //\n        if (StepDistance <= MinDistance) { SmallestDistance = 0.0; break; }\n        if (StepDistance >= MaxDistance) { break; }\n        //\n        DistanceBuffer[i] = StepDistance;\n        CircleBuffer[i] = smoothstep(1.0 * length(PixelSize),0.5 * length(PixelSize),abs(length(Coord - MarchedPoint) - StepDistance));\n        PointBuffer[i] = smoothstep(3.0 * length(PixelSize),2.0 * length(PixelSize),length(Coord - MarchedPoint));\n        //\n        TotalDistance += StepDistance;\n        MarchedPoint = StartPoint + RayDirection * TotalDistance;\n    }\n    //ResultColor = mix(ResultColor,vec3(MinGlow + ((MaxGlow-MinGlow) * (SmallestDistance/MinDistance))),PointBuffer[0]);\n    // Draw start point.\n    float MixValue = smoothstep(5.0 * length(PixelSize),3.5 * length(PixelSize),length(Coord - StartPoint));\n    ResultColor = mix(ResultColor,vec3(0.75,1,0.5),MixValue);\n    // Draw end point.\n    MixValue = smoothstep(5.0 * length(PixelSize),3.5 * length(PixelSize),length(Coord - MarchedPoint));\n    ResultColor = mix(ResultColor,vec3(1,0.25,0.125),MixValue);\n    // Draw line.\n    MixValue = smoothstep(1.5 * length(PixelSize),0.5 * length(PixelSize),LineSDF(Coord,StartPoint,MarchedPoint,0.0));\n    ResultColor = mix(ResultColor,vec3(0.875,0.625,0.3125),MixValue);\n    if (DrawMarchCircles) {\n        // Draw step distance circles.\n        for (int i = 0; i <= IterationCount; i++) { ResultColor = mix(ResultColor,vec3(0.5),CircleBuffer[i]); }\n        // Draw step points.\n        float MinGlow = 0.125, MaxGlow = 1.0, GlowValue;\n        //MinGlow + ((MaxGlow-MinGlow) * (DistanceBuffer[i]/MinDistance));\n        for (int i = 0; i <= IterationCount; i++) {\n            GlowValue = MinGlow + ((MaxGlow - MinGlow) * clamp((MinDistance/DistanceBuffer[i])-MinDistance,0.0,1.0));\n            ResultColor = mix(ResultColor,vec3(GlowValue),PointBuffer[i]);\n        }\n    }\n}\n\n\n\n\n\n\n\n\n\n\n","name":"Common","description":"","type":"common"}]}