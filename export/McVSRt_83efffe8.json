{"ver":"0.1","info":{"id":"McVSRt","date":"1715638674","viewed":28,"name":"aurora borealis imitation","username":"foxnerdsaysmoo","description":"aurora borealis imitation bc light pollution made me unable to see it :(","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["aurora"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float distributiong(float i){\n    return max(0.,1./(1.+(i-1.)*(i-1.))-exp(-(i-3.)*(i-3.)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 smear = vec2(0.,0.1);\n    vec3 green = vec3(35., 222., 132.) / 256.;\n    vec3 purple = vec3(191., 113., 201.) / 256.;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3((clamp(fbm_unbiased(vec3(uv,iTime/500.), 0.553, 3, 50., 1.5),0.5,1.)-.5));\n    for (float i=-2.; i<=2.; i+=0.01) {\n        vec2 adj = uv + smear*i;\n        if (adj.x != clamp(adj.x,0.,1.) || adj.y != clamp(adj.y,0.,1.)) {\n            continue;\n        }\n        float intensity = texture(iChannel0, uv+smear*i).x/50.;\n        color += green*distributiong(i)*intensity;\n    }\n    float rand_intensity = fbm_unbiased(vec3(uv.x,uv.y/30.,iTime/20.), 0.553, 2, 50., 1.5)/2. +1.3;\n    fragColor = vec4(color*rand_intensity,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 distort(in vec2 uv) {\n    float dx = fbm_unbiased(vec3(uv/20.,iTime/2000.), 0.553, 5, 50., 1.5)/10.;\n    float dy = fbm_unbiased(vec3(uv/20.,iTime/2000.) + vec3(12.13), 0.553, 5, 50., 1.5);\n    uv += vec2(dx,dy)/2.;\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord - iResolution.xy/2.0;\n    uv.x /= 70.;\n    uv /= 700.;\n    uv = distort(uv);\n    float fbm = fbm_unbiased(vec3(uv,iTime/3000.), 0.553, 2, 50., 1.5);\n    float brightness = 5.*(fbm-.26);\n    vec3 color = vec3(max(brightness,0.));\n    fragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec3 hash(vec3 co){\n    return vec3(fract(sin(dot(co, vec3(12.9898, 78.233, 47.1421))) * 43758.5453));\n}\n\n// Noise function by Inigo Quilez under MIT license\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n\n    \n    // gradients\n    vec3 ga = hash( p+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( p+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( p+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( p+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( p+vec3(0.0,0.0,1.0) );\n    vec3 gf = hash( p+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( p+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( p+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolation\n    return va + \n           u.x*(vb-va) + \n           u.y*(vc-va) + \n           u.z*(ve-va) + \n           u.x*u.y*(va-vb-vc+vd) + \n           u.y*u.z*(va-vc-ve+vg) + \n           u.z*u.x*(va-vb-ve+vf) + \n           u.x*u.y*u.z*(-va+vb+vc-vd+ve-vf-vg+vh);\n}\n\nfloat fbm_unbiased( in vec3 x, in float H, in int lod, float f, float f2 ) {\n    float G = exp2(-H);\n    float a = 1.0;\n    float t = 0.0;\n    float theta = 1.;\n    mat3 rot = mat3(1,0,0,0,cos(theta),-sin(theta),0,sin(theta),cos(theta)) * mat3(cos(theta),-sin(theta),0,sin(theta),cos(theta),0,0,0,1);\n    mat3 r = rot;\n    for( int i=0; i<lod; i++ )\n    // TODO: ADJUST LOD BASED ON DISTANCE, IE SHORTER DISTANCE -> HIGHER LOD\n    {\n        t += a*noise(f*x*r);\n        r *= rot;\n        f *= f2;\n        a *= G;\n    }\n    return t;\n}","name":"Common","description":"","type":"common"}]}