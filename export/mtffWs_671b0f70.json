{"ver":"0.1","info":{"id":"mtffWs","date":"1693952349","viewed":44,"name":"Sketch #12: Voronoi","username":"MOONtyzoo","description":"Based on tutorial from https://thebookofshaders.com/12/\n\nI really like the idea of only checking the 8 adjacent tiles for the shortest distance because then you can simulate a really large voronoi in the same time as a small one.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sketch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358\n\nfloat random(float x)\n{\n    return fract(439029.0*sin(x));\n}\n\nfloat random(vec2 uv)\n{\n    return fract(439029.0*sin(dot(uv, vec2(85.3876, 9.38532))));\n}\n\n// Grabbed from bookofshaders.com\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n//  Function from IÃ±igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n// -----------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec3 color = vec3(0.0);\n    \n    /*\n        Control variables\n    */\n    float size = 10.0 + 30.0*iMouse.x/iResolution.x;\n    \n    /*\n        Tile space into cells and find distance to shortest point\n    */\n    vec2 uv_i = floor(uv*size);\n    vec2 uv_f = fract(uv*size);\n    \n    float shortestDist = 1.0;\n    vec2 cell = vec2(0.0);\n    for (int x = -1; x <= 1; x++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n            vec2 neighbor = uv_i + vec2(float(x), float(y));\n            vec2 point = random2(neighbor);\n            point = 0.5 + 0.5*sin(iTime + 2.0*PI*point);\n            point += vec2(float(x), float(y));\n            \n            if (length(uv_f-point) < shortestDist)\n            {\n                shortestDist = length(uv_f-point);\n                cell = neighbor;\n            }\n            \n        }\n    }\n    \n    // Uncomment for borders\n    //shortestDist += 0.2*step(0.98, uv_f.x);\n    //shortestDist += 0.2*step(0.98, uv_f.y);\n    \n    \n    /*\n        Coloring\n    */\n    vec3 HSV = vec3(0.0);\n    HSV[0] = random(cell);\n    HSV[1] = 0.7;\n    HSV[2] = 1.0 - 0.5*shortestDist;\n    \n    fragColor = vec4(hsv2rgb(HSV), 1.0);\n}","name":"Image","description":"","type":"image"}]}