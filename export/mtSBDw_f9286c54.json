{"ver":"0.1","info":{"id":"mtSBDw","date":"1694100223","viewed":49,"name":"Path Tracing v2 [TRIANGLES OwO]","username":"FrederickAmpsUp","description":"See v1 here: https://www.shadertoy.com/view/DlSfDz\n\nThis version adds triangles, specular, better camera, and roughness. It's a complete rewrite.","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["3d","raytracer","triangle","sphere","pathtracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"/*\n\n * Path tracer v2 by FrederickAmpsUp\n \n * Buffer: Common\n \n * TODO: Camera, Godrays\n\n */\n\n#define OBJ_TP_SPHERE uint(0)\n#define OBJ_TP_TRI    uint(1)\n#define MAX_BOUNCES        5\n\n#define DOF_FOCUS 0.8\n#define DOF_BLUR  0.1\n\n#define EYE vec3(0.0, 0.0, 1.0)\n#define SUN vec3(0.8, 1.0, 1.0)\n\n#define SAMPLES 50\n\nstruct SubMaterial {\n    vec3 color;\n    \n    float diffuse;\n    float roughness;\n};\n\nstruct Material {\n    float specularAmnt;\n    \n    SubMaterial diffuse;\n    SubMaterial specular;\n    \n    vec3 emission;\n};\n\nstruct Triangle3d {\n    vec3 v1, v2, v3;\n    \n    Material mat;\n};\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n    \n    Material mat;\n};\n\n#define NUM_SPHERES 1\n#define NUM_TRIANGLES 1\n\nSphere SPHERES[NUM_SPHERES] = Sphere[NUM_SPHERES](\n    Sphere(vec3(0.0, 0.0, 2.0), 0.5, Material(0.5, SubMaterial(vec3(0.1, 0.1, 0.8), 1.0, 0.0), SubMaterial(vec3(0.8, 0.8, 0.8), 0.2, 0.0), vec3(0.0, 0.0, 0.0)))\n);\n\nTriangle3d TRIANGLES[NUM_TRIANGLES] = Triangle3d[NUM_TRIANGLES](\n    Triangle3d(\n        vec3(-2.0, -0.5, 0.0),\n        vec3( 2.0, -0.5, 0.0),\n        vec3( 0.0, -0.5, 4.0),\n        Material(0.7, SubMaterial(vec3(0.9, 0.9, 0.9), 0.1, 0.0), SubMaterial(vec3(0.8, 0.1, 0.1), 1.0, 0.0), vec3(0.0, 0.0, 0.0))\n    )\n);\n\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nfloat state = 0.0;\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453) * 2.0 - 1.0; }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\n/* TODO: make this better */\nRay camera_ray(vec2 uv) {\n    vec3 eye = EYE + (vec3(rand(uv * float(++state)), rand(uv * float(++state)), rand(uv * float(++state)) * 2.0 - 1.0) * float(DOF_BLUR));\n    \n    Ray ret;\n    ret.origin = eye;\n    \n    vec3 screen_plane = vec3(uv, 1.0);\n    \n    vec3 focus_plane = screen_plane * float(DOF_FOCUS);\n    focus_plane += EYE;\n    ret.direction = normalize(focus_plane - eye);\n    \n    return ret;\n}\n\nstruct RayHit {\n    bool hit;\n    \n    vec3 position;\n    vec3 normal;\n\n    uint hitType;\n    Triangle3d tri;\n    Sphere sphere;\n};\n\nfloat intersect_sphere(Sphere obj, Ray r) {\n    vec3 oc = r.origin - obj.center;\n    if (length(oc) < obj.radius + 0.001) return -1.0;\n    float a = dot(r.direction, r.direction);\n    float half_b = dot(oc, r.direction);\n    float c = dot(oc, oc) - obj.radius*obj.radius;\n    float discriminant = half_b*half_b - a*c;\n\n    if (discriminant < 0.0) {\n        return -1.0;\n    } else {\n        return (-half_b - sqrt(discriminant)) / a;\n    }\n}\n\nfloat intersect_triangle(Triangle3d obj, Ray r) {\n    vec3 e1 = obj.v2 - obj.v1;\n    vec3 e2 = obj.v3 - obj.v1;\n    vec3 h = cross(r.direction, e2);\n    float a = dot(e1, h);\n\n    if (a > -0.000001 && a < 0.000001) {\n        // Ray is parallel to the triangle\n        return -1.0;\n    }\n\n    float f = 1.0 / a;\n    vec3 s = r.origin - obj.v1;\n    float u = f * dot(s, h);\n\n    if (u < 0.0 || u > 1.0) {\n        // Intersection is outside the triangle\n        return -1.0;\n    }\n\n    vec3 q = cross(s, e1);\n    float v = f * dot(r.direction, q);\n\n    if (v < 0.0 || u + v > 1.0) {\n        // Intersection is outside the triangle\n        return -1.0;\n    }\n\n    float t = f * dot(e2, q);\n\n    if (t > 0.000001) {\n        // Intersection is valid and positive along the ray\n        return t;\n    }\n\n    // Intersection is behind the ray's origin\n    return -1.0;\n}\nvec3 triangle_norm(Triangle3d tri) {\n    vec3 e1 = tri.v2 - tri.v1;\n    vec3 e2 = tri.v3 - tri.v1;\n    return normalize(cross(e1, e2));\n}\n\n\nRayHit scene_intersect(Ray ray) {\n    RayHit ret;\n    ret.hit = true;\n    \n    float min_dist = float(1.0e38);\n    Sphere closest_sph;\n    Triangle3d closest_tri;\n    uint closest_tp = OBJ_TP_SPHERE;\n\n    Sphere obj_sph;\n    float dist;\n    for (uint i = uint(0); i < uint(NUM_SPHERES); ++i) {\n        obj_sph = SPHERES[i];\n        dist = intersect_sphere(obj_sph, ray);\n\n        if (dist > 0.0 && dist < min_dist) {\n            min_dist = dist;\n            closest_sph = obj_sph;\n            closest_tp = OBJ_TP_SPHERE;\n        }\n    }\n    \n    Triangle3d obj_tri;\n    for (uint i = uint(0); i < uint(NUM_TRIANGLES); ++i) {\n        obj_tri = TRIANGLES[i];\n        dist = intersect_triangle(obj_tri, ray);\n\n        if (dist > 0.0 && dist < min_dist) {\n            min_dist = dist;\n            closest_tri = obj_tri;\n            ret.hitType = OBJ_TP_TRI;\n        }\n    }\n    \n    if (min_dist == float(1.0e38)) {\n        ret.hit = false;\n        return ret;\n    }\n    \n    ret.sphere = closest_sph;\n    ret.tri    = closest_tri;\n    \n    ret.position = ray.origin + ray.direction * min_dist;\n    \n    if        (ret.hitType ==    OBJ_TP_TRI) {\n        ret.normal = triangle_norm(ret.tri);\n        ret.normal *= sign(dot(normalize(ret.position - ray.origin), ray.direction)) * -2.0 + 1.0;\n    } else if (ret.hitType == OBJ_TP_SPHERE) {\n        ret.normal = normalize(ret.position - ret.sphere.center);\n    }\n\n    vec3 position =  ray.origin + ray.direction * min_dist;\n\n    return ret;\n}\n\nvec3 sky_color(vec3 direction) {\n    vec3 sky_blue = vec3(0.380, 0.769, 0.961);\n\n    float sun = pow(clamp(dot(direction, normalize(SUN)), 0.0, 1.0), 500.0) * 100.0;\n    vec3 sunCol = vec3(sun, sun * 0.9, 0.0);\n\n    vec3 ret = sky_blue + sunCol;\n\n    return ret;\n}\n\nvec3 rand_hemis_dir(vec3 dir) {\n    vec3 rand_dir = normalize(vec3(rand(dir * float(++state)), rand(dir * float(++state)), rand(dir * float(++state))) * 2.0 - 1.0);\n    return rand_dir * -(sign(dot(dir, rand_dir)) * 2.0 - 1.0);\n}\n\n/* TODO: roughness */\n\nvec3 trace(Ray ray) {\n    vec3 color = vec3(1.0);\n    vec3 light = vec3(0.0);\n\n    for (int bounce = 0; bounce < MAX_BOUNCES; ++bounce) {\n        RayHit intersect = scene_intersect(ray);\n        if (!intersect.hit) {\n            vec3 sky = sky_color(ray.direction);\n            light = light + sky * color;\n            break;\n        };\n\n        Material mat;\n        if (intersect.hitType == OBJ_TP_TRI) {\n            mat = intersect.tri.mat;\n        } else {\n            mat = intersect.sphere.mat;\n        }\n        \n        SubMaterial specular = mat.specular;\n        SubMaterial diffuse  =  mat.diffuse;\n        \n        light = light + mat.emission * color;\n        if (rand(ray.origin * ray.direction * float(++state)) < mat.specularAmnt) {\n            color *= specular.color;\n        } else {\n            color *= diffuse.color;\n        }\n\n        ray.origin = intersect.position + intersect.normal * 0.001;\n        \n        float diffuseAmnt;\n        float roughnessAmnt;\n        if (rand((ray.origin + ray.direction) * float(++state)) < mat.specularAmnt) {\n            diffuseAmnt = specular.diffuse;\n            roughnessAmnt = specular.roughness;\n        } else {\n            diffuseAmnt = diffuse.diffuse;\n            roughnessAmnt = specular.roughness;\n        }\n        \n        vec3 rand_dir = normalize(vec3(rand(0.5 * intersect.position), rand(intersect.position), rand(2.0 * intersect.position)));\n        vec3 roughness_dir = normalize(intersect.normal + rand_dir);\n        vec3 diffuse_dir = normalize(intersect.normal + normalize(vec3(rand(float(++state)), rand(float(++state)), rand(float(++state))) * 2.0 - 1.0));\n        ray.direction = mix(reflect(ray.direction, intersect.normal), normalize(mix(diffuse_dir, roughness_dir, roughnessAmnt)), diffuseAmnt);\n    }\n    return light;\n}\n\n/*\n\n * End Path Tracer v2 by FrederickAmpsUp\n \n * Buffer: Common\n \n */\n \n \n/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Common\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The common unit contains most of the code, and\n  receives gamut extension matrices from a buffer.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n  Minified by 01000001\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n#define flim(x,y) flim_transform(iChannel1,x,y)\n// Parameters\n\nconst float pe = 4.3; const vec3 fpff = vec3(1); const float fpffs = 0.;\nconst float egr = 1.05; const float egg = 1.12; const float egb = 1.045;\nconst float grr = .5; const float ggr = 2.; const float gbr = .1;\nconst float grm = 1.; const float ggm = 1.; const float gbm = 1.; const float flsi = -10.;\nconst float flsa = 22.; const float fsx = .44; const float fsy = .28;\nconst float fssx = .591; const float fssy = .779; const float fe = 6.;\nconst float fd = 5.; const vec3 pb = vec3(1); const float pfe = 6.;\nconst float pfd = 27.5; const float bp = -1.; const vec3 pff = vec3(1);\nconst float pffs = 0.; const float ms = 1.02;\nfloat wrap(float i, float s, float e){return s + mod(i - s, e - s);}\nfloat lerp(float a, float b, float t){return a + t * (b - a);}\nvec3 lerp(vec3 a, vec3 b, float t){return a + t * (b - a);}\nfloat mrc(float i, float is, float ie, float os, float oe){\n    float t = clamp((i - is) / (ie - is), 0., 1.);\n    float v = os + t * (oe - os);\n    return v; }\nvec3 rth(vec3 rgb){\n    float ca, ci, h, s, v, cd;\n    vec3 c;\n    ca = max(rgb[0], max(rgb[1], rgb[2]));\n    ci = min(rgb[0], min(rgb[1], rgb[2]));\n    cd = ca - ci;\n    v = ca;\n    if (ca != 0.) s = cd / ca;\n    else s = 0.0; h = 0.0;\n    if (s == 0.) h = 0.0; \n    else{\n        c = (vec3(ca) - rgb.xyz) / cd;\n\n        if (rgb.x == ca) h = c[2] - c[1];\n        else if (rgb.y == ca) h = 2.+ c[0] - c[2];\n        else h = 4.+ c[1] - c[0];\n        h /= 6.0;\n        if (h < 0.) h += 1.0; }\n    return vec3(h, s, v); }\nvec3 htr(vec3 hsv){\n    float i, f, p, q, t, h, s, v;\n    vec3 rgb;\n    h = hsv[0];\n    s = hsv[1];\n    v = hsv[2];\n    if (s == 0.) rgb = vec3(v, v, v);\n    else {\n        if (h == 1.) h = 0.0;\n        h *= 6.0;\n        i = floor(h);\n        f = h - i;\n        rgb = vec3(f, f, f);\n        p = v * (1.- s);\n        q = v * (1.- (s * f));\n        t = v * (1.- (s * (1.- f)));\n        if (i == 0.) rgb = vec3(v, t, p);\n        else if (i == 1.) rgb = vec3(q, v, p);\n        else if (i == 2.) rgb = vec3(p, v, t);\n        else if (i == 3.) rgb = vec3(p, q, v);\n        else if (i == 4.) rgb = vec3(t, p, v);\n        else rgb = vec3(v, p, q); }\n    return rgb; }\nvec3 bhs(vec3 col, float hue, float sat, float value){\n    vec3 hsv = rth(col);\n    hsv[0] = fract(hsv[0] + hue + 0.5);\n    hsv[1] = clamp(hsv[1] * sat, 0., 1.);\n    hsv[2] = hsv[2] * value;\n    return htr(hsv); }\nfloat rgb_avg(vec3 i){\n    return (i.x + i.y + i.z) / 3.0; }\nfloat rgb_sum(vec3 i){\n    return i.x + i.y + i.z; }\nfloat rgb_max(vec3 i){\n    return max(max(i.x, i.y), i.z); }\nfloat rgb_min(vec3 i){\n    return min(min(i.x, i.y), i.z); }\nvec3 uo(vec3 i, float bp, float wp){\n    float mono = rgb_avg(i);\n    float mono2 = mrc(mono, bp / 1000., 1.- (wp / 1000.), 0., 1.);\n    return i * (mono2 / mono); }\n// https://www.desmos.com/calculator/khkztixyeu\nfloat ss(float i, float tx, float ty, float sx, float sy){\n    i = clamp(i, 0., 1.);\n    tx = clamp(tx, 0., 1.);\n    ty = clamp(ty, 0., 1.);\n    sx = clamp(sx, 0., 1.);\n    sy = clamp(sy, 0., 1.);\n    float slope = (sy - ty) / (sx - tx);\n    if (i < tx){\n        float toe_pow = slope * tx / ty;\n        return ty * pow(i / tx, toe_pow); }\n    if (i < sx){\n        float intercept = ty - (slope * tx);\n        return slope * i + intercept; }\n    float shoulder_pow = -slope / (((sx - 1.) / pow(1.- sx, 2.)) * (1.- sy));\n    return (1.- pow(1.- (i - sx) / (1.- sx), shoulder_pow)) * (1.- sy) + sy; }\nfloat dmf(float mono, float max_density){\n    float offset = pow(2., flsi);\n    float fac = mrc(log2(mono + offset), flsi, flsa, 0., 1.);\n    fac = ss(fac, fsx, fsy, fssx, fssy);\n    fac *= max_density;\n    fac = pow(2., -fac);\n    return clamp(fac, 0., 1.); }\nvec3 cl(vec3 i, vec3 sensitivity_tone, vec3 dye_tone, float max_density){\n    vec3 sensitivity_tone_norm = sensitivity_tone / rgb_sum(sensitivity_tone);\n    vec3 dye_tone_norm = dye_tone / rgb_max(dye_tone);\n    float mono = dot(i, sensitivity_tone_norm);\n    float mixFac = dmf(mono, max_density);\n    return lerp(dye_tone_norm, vec3(1.), mixFac); }\nvec3 rgbd(vec3 i, float e, float max_density){\n    i *= pow(2., e);\n    vec3 result = cl(i, vec3(0, 0, 1), vec3(1, 1, 0), max_density);\n    result *= cl(i, vec3(0, 1, 0), vec3(1, 0, 1), max_density);\n    result *= cl(i, vec3(1, 0, 0), vec3(0, 1, 1), max_density);\n    return result; }\nvec3 emr(float ph, float s, float r, float m){\n    vec3 result = htr(vec3(wrap(ph + (r / 360.), 0., 1.), 1./ s, 1.));\n    result /= rgb_sum(result);\n    result *= m;\n    return result; }\nmat3 gem(float rs,float gs,float bs,float rr,float gr, float br, float rm, float gm, float bm){\n    mat3 m;\n    m[0] = emr(0., rs, rr, rm);\n    m[1] = emr(1./ 3., gs, gr, gm);\n    m[2] = emr(2./ 3., bs, br, bm);\n    return m; }\nvec3 nap(vec3 i, vec3 bex){\n    i = rgbd(i, fe, fd);\n    i *= bex;\n    i = rgbd(i, pfe, pfd);\n    return i; }\nbool flm(sampler2D mc, out mat3 em, out mat3 emi){\n    const float valid_w = 2.0;\n    vec4 row;\n    row = texelFetch(mc, ivec2(0, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    em[0] = row.xyz;\n\n    row = texelFetch(mc, ivec2(1, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    em[1] = row.xyz;\n\n    row = texelFetch(mc, ivec2(2, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    em[2] = row.xyz;\n    row = texelFetch(mc, ivec2(3, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    emi[0] = row.xyz;\n\n    row = texelFetch(mc, ivec2(4, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    emi[1] = row.xyz;\n\n    row = texelFetch(mc, ivec2(5, 0), 0);\n    if (row.w != valid_w)\n        return false;\n    emi[2] = row.xyz;\n    return true; }\nvec3 flim_transform(sampler2D mc, vec3 i, float e){\n    i = max(i, 0.);\n    i *= pow(2., pe + e);\n    i = min(i, 5000.);\n    mat3 em, emi;\n    if (!flm(mc, em, emi)){ return vec3(1, 0, 1); }\n    vec3 bex = pb * em;\n    const float big = 10000000.0;\n    vec3 white_cap = nap(vec3(big, big, big), bex);\n    i = lerp(i, i * fpff, fpffs);\n    i *= em;\n    i = nap(i, bex);\n    i *= emi;\n    i = max(i, 0.);\n    i /= white_cap;\n    if (bp == -1.){\n        vec3 black_cap = nap(vec3(0.), bex);\n        black_cap /= white_cap;\n        i = uo(i, rgb_avg(black_cap) * 1000., 0.);\n    }else{ i = uo(i, bp, 0.); }\n    i = lerp(i, i * pff, pffs);\n    i = clamp(i, 0., 1.);\n    float mono = rgb_avg(i);\n    float mixFac = (mono < 0.5) ? mrc(mono, 0.05, 0.5, 0., 1.) : mrc(mono, 0.5, 0.95, 1., 0.);\n    i = lerp(i, bhs(i, 0.5, ms, 1.), mixFac);\n    i = clamp(i, 0., 1.);\n    i = pow(i, vec3(1./ 2.2));\n    return i; }\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Common\n\n***********************************/\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n \n * Path tracing v2 by FrederickAmpsUp\n \n * Buffer: Image, iChannel0 set to buffer X (of Path Tracing v2), iChannel1 set to buffer X (of MiniFlim)\n \n */\n \n vec3 denoise(vec2 fragTexCoord, sampler2D img, float sigma, int patchSize) {\n    vec2 texelSize = 1.0 / vec2(textureSize(img, 0));\n\n    vec3 centralColor = texture(img, fragTexCoord).rgb;\n    vec3 denoisedColor = vec3(0.0);\n\n    float totalWeight = 0.0;\n\n    for (int i = -patchSize; i <= patchSize; i++) {\n        for (int j = -patchSize; j <= patchSize; j++) {\n            vec2 offset = vec2(float(i), float(j)) * texelSize;\n            vec3 neighborColor = texture(img, fragTexCoord + offset).rgb;\n\n            // Compute the similarity between centralColor and neighborColor\n            float similarity = exp(-dot(centralColor - neighborColor, centralColor - neighborColor) / (2.0 * sigma * sigma));\n\n            denoisedColor += similarity * neighborColor;\n            totalWeight += similarity;\n        }\n    }\n\n    denoisedColor /= totalWeight;\n\n    return denoisedColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec4 texColor = vec4(denoise(uv, iChannel0, 0.05, 7), 1.0);\n\n    fragColor = vec4(flim(texColor.rgb, 0.), 1.0);\n}\n\n/*\n \n * End Path Tracing v2 by FrederickAmpsUp\n \n * Buffer: Image\n \n */","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/***********************************\n\nflim - Filmic Color Transform\n\nInput Color Space:   Linear BT.709 I-D65\nOutput Color Space:  sRGB 2.2\n\nShadertoy Unit:\n  Buffer X\n\nDescription:\n  Experimental port of flim for GLSL/Shadertoy\n  matching flim v1.1.0.\n  The buffer unit performs a one-time calculation\n  of flim's gamut extension matrices.\n\nAuthor:\n  Bean (beans_please on Shadertoy)\n  Minified by 01000001\n\nOriginal Repo:\n  https://github.com/bean-mhm/flim\n\nOriginal Shader:\n  https://www.shadertoy.com/view/dd2yDz\n\n***********************************/\n\n// NOTE:\n// iChannel0 must be set to this buffer (self-feeding).\n\nvoid mainImage(out vec4 O, in vec2 U){\n    const float w = 2.0;\n    if (ivec2(U).x > 5 || ivec2(U).y > 0)\n        return;\n    vec4 p = texelFetch(iChannel0, ivec2(U), 0);\n    O = p;\n    bool n = (p.w != w) || (iTime == 0.0) || (iFrame < 1);\n    if (!n)\n        return;\n    mat3 e = gem(egr,egg,egb,grr,ggr,gbr,grm,ggm,gbm);\n    mat3 ei = inverse(e);\n    if (ivec2(U) == ivec2(0, 0)) {\n        O = vec4(e[0], w);\n    } if (ivec2(U) == ivec2(1, 0)) {\n        O = vec4(e[1], w);\n    } if (ivec2(U) == ivec2(2, 0)) {\n        O = vec4(e[2], w);\n    }\n    if (ivec2(U) == ivec2(3, 0)) {\n        O = vec4(ei[0], w);\n    } if (ivec2(U) == ivec2(4, 0)) {\n        O = vec4(ei[1], w);\n    } if (ivec2(U) == ivec2(5, 0)) {\n        O = vec4(ei[2], w);\n    }}\n\n/***********************************\n\nEnd of flim's implementation for Shadertoy Unit: Buffer X\n\n***********************************/","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n \n * Path Tracing v2 by FrederickAmpsUp\n \n * Buffer: any, loopback to iChannel0\n \n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    state = mod(iTime, 10.0) + mod(float(iFrame), 100.0);\n\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    // uv -= iMouse.xy / iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    for (float i = 0.0; i < float(SAMPLES); ++i) {\n        Ray camera = camera_ray(uv);\n        col += trace(camera);\n    }\n    col /= float(SAMPLES);\n    \n    fragColor = mix(texture(iChannel0, (fragCoord/iResolution.xy)), vec4(col, 1.0), 1.0 / float(iFrame + 1));\n}\n\n/*\n \n * End Path Tracing v2 by FrederickAmpsUp\n \n * Buffer: any\n \n */","name":"Buffer A","description":"","type":"buffer"}]}