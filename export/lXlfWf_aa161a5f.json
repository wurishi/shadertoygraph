{"ver":"0.1","info":{"id":"lXlfWf","date":"1729022752","viewed":18,"name":"EdSquares","username":"Eatabekyan","description":"квадратики крутятся","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265359;\nconst int MAX_STEPS = 200;\nconst float MAX_DIST = 100.0;\nconst float MIN_DIST = 0.001;\nconst float AMBIENT_LIGHT = 0.3;\nconst float CUBE_SIZE = 0.5;\nconst float CUBE_SPEED = 1.5;\nconst float CUBE_ROTATION_SPEED = 2.0;\n\nvec3 lightPos = vec3(4.0, 6.0, 8.0);\n\nfloat sdCube(vec3 p, float s) {\n    return length(max(abs(p) - vec3(s), 0.0));\n}\n\nvec3 cubePosition(float time, float index) {\n    float angle = time * CUBE_ROTATION_SPEED + index * PI / 3.0;\n    float radius = 4.0 + sin(time * CUBE_SPEED + index) * 0.5; // Пульсация радиуса\n    return vec3(cos(angle) * radius, 0.0, sin(angle) * radius);\n}\n\nfloat sceneSDF(vec3 p) {\n    float d = MAX_DIST;\n\n    for (int i = 0; i < 5; i++) {\n        vec3 pos = cubePosition(iTime, float(i));\n        float cubeDist = sdCube(p - pos, CUBE_SIZE);\n        d = min(d, cubeDist);\n    }\n\n    // Плоскость\n    float ground = p.y + 0.5;\n    d = min(d, ground);\n    \n    return d;\n}\n\nvec3 getNormal(vec3 p) {\n    float h = MIN_DIST;\n    vec3 n = vec3(\n        sceneSDF(p + vec3(h, 0, 0)) - sceneSDF(p - vec3(h, 0, 0)),\n        sceneSDF(p + vec3(0, h, 0)) - sceneSDF(p - vec3(0, h, 0)),\n        sceneSDF(p + vec3(0, 0, h)) - sceneSDF(p - vec3(0, 0, h))\n    );\n    return normalize(n);\n}\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * t;\n        float dist = sceneSDF(p);\n        if (dist < MIN_DIST) {\n            return p;\n        }\n        t += dist;\n        if (t > MAX_DIST) break;\n    }\n    return vec3(MAX_DIST);\n}\n\nvec3 phongLighting(vec3 p, vec3 normal, vec3 viewDir) {\n    vec3 lightDir = normalize(lightPos - p);\n    \n    vec3 ambient = AMBIENT_LIGHT * vec3(0.5, 0.5, 0.5);\n    \n    float diff = max(dot(normal, lightDir), 0.0);\n    vec3 diffuse = diff * vec3(1.0, 0.5, 0.5); // Цвет диффузного освещения\n    \n    vec3 reflectDir = reflect(-lightDir, normal);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n    vec3 specular = spec * vec3(1.0);\n    \n    return (ambient + diffuse + specular);\n}\n\nvec3 getCameraPosition(float time) {\n    float radius = 10.0;\n    float height = 4.0 + sin(time * 0.5) * 2.0; // Динамическая высота камеры\n    return vec3(sin(time) * radius, height, cos(time) * radius);\n}\n\nvec3 getCameraTarget() {\n    return vec3(0.0, 1.0, 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 ro = getCameraPosition(iTime);\n    vec3 lookAt = getCameraTarget();    \n    \n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, forward);\n    vec3 rd = normalize(forward + uv.x * right + uv.y * up);\n    \n    vec3 p = rayMarch(ro, rd);\n    \n    if (length(p) < MAX_DIST) {\n        vec3 normal = getNormal(p);\n        vec3 viewDir = normalize(ro - p);\n        vec3 color = phongLighting(p, normal, viewDir);\n        fragColor = vec4(color, 1.0);\n    } else {\n        fragColor = vec4(0.1, 0.1, 0.2, 1.0); // Фон\n    }\n}\n","name":"Image","description":"","type":"image"}]}