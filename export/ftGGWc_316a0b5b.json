{"ver":"0.1","info":{"id":"ftGGWc","date":"1638404080","viewed":95,"name":"Spinning Hoops Illusion","username":"Artem_Romanenko","description":"shows a hooop that appears to travel toward the red dot in the middle","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["illusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float casin(float x) {\n\tfloat negate = float(x < 0.0);\n\tx = abs(x);\n\tfloat ret = -0.0187293;\n\tret *= x;\n\tret += 0.0742610;\n\tret *= x;\n\tret -= 0.2121144;\n\tret *= x;\n\tret += 1.5707288;\n\tret = 3.14159265358979*0.5 - sqrt(1.0 - x)*ret;\n\treturn ret - 2.0 * negate * ret;\n}\nfloat atan2(float y, float x) {\n \tfloat absx, absy, val;\n \n     if (x == 0.0 && y == 0.0) {\n \t\treturn 0.0;\n \t}\n \tabsy = y < 0.0 ? -y : y;\n \tabsx = x < 0.0 ? -x : x;\n \tif (absy - absx == absy) {\n \t\treturn y < 0.0 ? -3.1415*2.0 : 3.1415*2.0;\n \t}\n    \n    if (absx - absy == absx) {\n\t\tval = 0.0;\n    } else {\n        val = casin((y/x)/sqrt(1.0+((y/x)*(y/x))));\n    }\n \tif (x > 0.0) {\n \t\treturn val;\n \t}\n \tif (y < 0.0) {\n\t\treturn val - 3.1415;\n \t}\n \treturn val + 3.1415;\n}\n\nvec3 render_hoop(vec3 color, int num_slices, float inner_radius, float outer_radius, float border_thickness, vec2 center, vec2 pos, vec3 bkg_col, bool invertedness, float offset, vec2 drift_to_point){\n    vec3 col = bkg_col;\n    \n    //vec3 color_1 = vec3(.8, .3, .1);\n    \n    //vec3 color_1 = vec3(0.0,0.33,0.67);\n    //vec3 color_2 = vec3(.75, .7, .23);\n    \n    //vec3 color_1 = vec3(0.9,0.33,0.33);\n    //vec3 color_2 = vec3(.0, .8, .63);\n    \n    vec3 color_1 = vec3(0.0,0.0,0.0);\n    vec3 color_2 = vec3(1.0, 1.0, 1.0);\n    \n    //vec3 color_1 = vec3(0.0,1.0,0.0);\n    //vec3 color_2 = vec3(0.0,0.0,1.0);\n    \n    float dx = drift_to_point.x - center.x;\n    float dy = drift_to_point.y - center.y;\n    float angle_to_drift_pt = degrees(atan2(dx, dy));\n    \n    dx = pos.x - center.x;\n    dy = pos.y - center.y;\n    float angle = degrees(atan2(dx,dy));\n    \n    \n    float val = mod(angle - angle_to_drift_pt, 360.0);//mod((angle - angle_to_drift_pt)- 180.0, 360.0);\n    bool pointing_at_drift = val <= 90.0 || val >= 270.0;\n    \n    float slice_angle = 360.0/float(num_slices);\n    \n    float wedge_angle = slice_angle/4.0;\n    \n    float rotate_speed = 200.0;\n    \n    float blur_dist = .002;\n    \n    \n    \n    float dir = float(invertedness)*2.0-1.0;\n    float tdir = float(pointing_at_drift)*2.0-1.0;\n    \n    float angle_smooth_span = 20.0;\n    \n    float border_thickness_factor = 1.0;\n    float diff1 = abs(angle_to_drift_pt-angle+90.0);\n    float diff2 = abs(angle_to_drift_pt-angle-90.0);\n    if(diff1 < angle_smooth_span || diff2 < angle_smooth_span){\n        border_thickness_factor = min(diff1, diff2)/angle_smooth_span;\n    }\n    \n    border_thickness *= border_thickness_factor;\n    \n    // outer outline\n    float is_color_1_1 = float(float(int(tdir*dir*-wedge_angle+offset+angle+(iTime*rotate_speed)) % int(slice_angle)) < (slice_angle/2.0));\n    //float is_color_1_1 = float(((int(45.0+offset+(iTime*rotate_speed)))%int(slice_angle)) < int(slice_angle/2.0));\n    col = mix( col, color_1, is_color_1_1*(1.0-smoothstep(outer_radius+border_thickness,outer_radius+border_thickness+blur_dist, length(pos- center.xy ))) );\n    col = mix( col, color_2, (1.0-is_color_1_1)*(1.0-smoothstep(outer_radius+border_thickness,outer_radius+border_thickness+blur_dist, length(pos- center.xy ))) );\n    // inner hoop\n    float is_color_1_2 = float(((int(angle+offset+(iTime*rotate_speed)))%int(slice_angle)) < int(slice_angle/2.0));\n    col = mix( col, color_1, is_color_1_2*(1.0-smoothstep(outer_radius,outer_radius+blur_dist, length(pos- center.xy ))) );\n    col = mix( col, color_2, (1.0-is_color_1_2)*(1.0-smoothstep(outer_radius,outer_radius+blur_dist, length(pos- center.xy ))) );\n    //inner outline\n    float is_color_1_3 = float(float(int(tdir*-dir*-wedge_angle+offset+angle+(iTime*rotate_speed)) % int(slice_angle)) < (slice_angle/2.0));\n    col = mix( col, color_1, is_color_1_3*(1.0-smoothstep(inner_radius,inner_radius+blur_dist, length(pos- center.xy ))) );\n    col = mix( col, color_2, (1.0-is_color_1_3)*(1.0-smoothstep(inner_radius,inner_radius+blur_dist, length(pos- center.xy ))) );\n    col = mix( col, bkg_col, 1.0-smoothstep(inner_radius-border_thickness,inner_radius-border_thickness+blur_dist, length(pos- center.xy )) );\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 drift_to_point = vec2(0.5, 0.3);\n\n    int num_colors = 2;\n    \n    vec3 bkg_color = vec3(.5, .5, .5);\n    //vec3 bkg_color = vec3(1, 0, 0);\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = fragCoord / iResolution.x;\n\n    vec4 m = iMouse / iResolution.x;\n\n    \n\n    // Time varying pixel color\n    vec3 col = vec3(1,1,1); //* float(.5 < distance(fragCoord, vec2(0,0)));\n    \n    int NUM_SLICES = 10;\n    \n    float slice_angle = 360.0/float(NUM_SLICES);\n    \n    float outer_radius = .085;\n    float inner_radius = .068;\n    float border_thickness = .0025;\n    vec2 center_pt = m.xy;\n    \n    vec3 col_hoop_1 = render_hoop(col, NUM_SLICES, inner_radius, outer_radius, border_thickness, center_pt, p, bkg_color, true, 0.0, drift_to_point);\n    //vec3 col_hoop_2 = render_hoop(col, NUM_SLICES, inner_radius+.06, outer_radius+.06, border_thickness, center_pt, p, bkg_color, false, 45.0);\n    //vec3 col_hoop_3 = render_hoop(col, NUM_SLICES, inner_radius+.12, outer_radius+.12, border_thickness, center_pt, p, bkg_color, true, 0.0);\n    //vec3 col_hoop_4 = render_hoop(col, NUM_SLICES, inner_radius+.18, outer_radius+.18, border_thickness, center_pt, p, bkg_color, false, 45.0);\n    \n    //vec3 fin_col = (col_hoop_1 - bkg_color) + (col_hoop_2 - bkg_color) + (col_hoop_3 - bkg_color) + (col_hoop_4 - bkg_color) + bkg_color;\n    \n    //vec3 fin_col = (col_hoop_1 - bkg_color) + (col_hoop_2 - bkg_color) + bkg_color;\n    \n    //col = render_hoop(col, NUM_SLICES, .07, .073, center_pt, p);\n    \n    //col = render_hoop(col, NUM_SLICES, .037, .04, center_pt, p);\n    \n    col_hoop_1 = mix( col_hoop_1, vec3(1.0,0.0,0.0), (1.0-smoothstep(.01,.0101, length(p- drift_to_point ))) );\n    \n    // Output to screen\n    //fragColor = vec4(fin_col,1.0);\n    fragColor = vec4(col_hoop_1,1.0);\n}","name":"Image","description":"","type":"image"}]}