{"ver":"0.1","info":{"id":"M3S3WG","date":"1708798277","viewed":110,"name":"Vibrant Circles","username":"archon","description":"circles!!!!!!!","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["circles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//BY ARCHON copyright 2024\n\n\n\n\nvec2 Hash12(float g){\n    // Genera la primera coordenada pseudoaleatoria utilizando la función sinusoidal y una constante arbitraria\n    float x = fract(sin(g * 674.3) * 452.2);\n    \n    // Genera la segunda coordenada pseudoaleatoria utilizando la primera coordenada y otra constante arbitraria\n    float y = fract(sin((g * x) * 774.3) * 263.2);\n\n    // Retorna el par de coordenadas pseudoaleatorias\n    return vec2(x, y);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p * vec2(123.34, 456.21));\n    p += dot(p, p + 45.32);\n    return fract(p.x * p.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Coordenadas de píxel normalizadas (de 0 a 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float radius = 0.4;\n   \n    float angle = radians(180.0) + iTime * radians(30.0);\n    mat2 rotate = mat2(cos(angle), -sin(angle),\n                       sin(angle), cos(angle));\n    uv = rotate * uv;\n   \n    // Bucle para dibujar múltiples círculos\n    float d = length(uv);\n\n    // Efecto de variación de color\n    float t = tan(sin(iTime * 0.2));\n   \n    vec3 col1 = vec3(uv.x, 1.0, uv.x) + vec3(uv.y, 1.0, uv.y * t);\n    vec3 col2 = vec3(uv.x, uv.y, 1.0 * t);\n\n    // Color inicial del píxel\n    vec3 col = vec3(0.0);\n    \n    // Calcular el desenfoque gradual en el borde del círculo\n    float circleBlur = 1.0;\n    circleBlur *= smoothstep(radius - 0.000, radius + 0.2, d * t); \n    circleBlur *= smoothstep(radius - 1.000, radius + 0.2, d * t); \n    circleBlur *= smoothstep(radius - 0.000, radius + 0.2, d * t); \n    \n    // Mezclar entre col1 y col2 utilizando el valor de desenfoque del círculo\n    col = mix(col1, col2, circleBlur);\n    \n    // Definir el tamaño del efecto adicional de círculos\n    \n    // Star \n    float y = exp(cos(sin(iTime))); \n    float r = length(uv * t);\n    float b = atan(uv.x, uv.y * t);\n    float a = 0.001 + 0.1 * sin(b * 13.0) * y * t;\n    float u = 0.5 + 0.1  * a * y;\n    float f = (r < u) ? 1.0 : 0.0 * t;\n       \n    // Calcular efectos adicionales de círculos\n    vec2 offs = vec2(0.1, 0.2 * t); // Desplazamiento arbitrario\n    vec2 gv = fract(uv * 8.0 * t);\n    vec2 id = floor(uv * 8.0 );\n    float n = Hash21(id * 8.0);\n    float size = fract(n * 345.32 + t);\n    \n    vec3 additionalEffect = vec3(gv.x - offs.x - n, 0.0, gv.y - offs.y - fract(n * 34.0)) + 0.5; // Valor de efecto adicional\n   \n    col += circleBlur * n * smoothstep(0.45, 0.55, gv.x) * smoothstep(0.45, 0.55, uv.y) * n + smoothstep(.85, .1, size); // Efecto de cuadrícula\n    if (gv.x > 0.48 || gv.y > 0.48) col.b = 0.1 * gv.x;\n    \n    vec3 color = sin(vec3(0.5, 0.5, 0.5) * fract(n * 2345.2) * 123.2) * 0.5 + 0.5 * t * f;\n    color += color * vec3(1, 0, 1);\n    \n    // Generar una dirección pseudoaleatoria para las partículas\n    vec2 direction = Hash12(iTime);\n    \n    // Calcular la nueva posición de la partícula\n    vec2 newPos = uv + direction * iTime * 0.1;\n    \n    // Agregar brillo en función de la distancia de las partículas\n    float brillo = 0.004;\n    float q = length(uv - newPos);\n    col += brillo / q;\n    \n    // Asignar el efecto adicional al color\n    col += additionalEffect * size * color * f;\n    col += 0.001;\n    \n    // Salida al píxel\n    fragColor = vec4(col, 1.0) * t + f;\n}\n","name":"Image","description":"","type":"image"}]}