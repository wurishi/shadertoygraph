{"ver":"0.1","info":{"id":"cslSz2","date":"1670179074","viewed":86,"name":"Ray Tracer + Plane + shadow","username":"genis","description":"?","likes":1,"published":1,"flags":0,"usePreview":0,"tags":[],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Material\n{\n    float Ka;\t// ambiant        coefficient\n    float Kd;\t// diffuse        coefficient\n    float Ks;\t// specular       coefficient\n    float Kn;\t// specular power coefficient\n};\n    \n    // ~ ~ ~ ~ ~ ~ ~ ~ \n        \n// Camera parameters\nconst vec3\t   cameraPos    = vec3(6,  4, -5);\nconst vec3\t   cameraTarget = vec3(3,  1, -8);\nconst float    cameraFovY   = 80.0;\t\t\t\t// NOTE: angle in degree\n\n// Light(s) parameters\nconst vec3     ambiantCol   = vec3(0,0,1);\t\t// blue\nconst vec3     lightCol     = vec3(1,1,1);\t\t// white\nconst vec3     lightPos     = vec3(8, 10, -12);\n\n// Object\nconst int      nbObj        = 3;\n\n// Sphere parameters\nconst vec3     spherePos    = cameraTarget + vec3(0, 1, 2);\nconst float    sphereRadius = 1.0;\nconst vec3     sphereCol    = vec3(1,0,0);\t\t// red\nconst Material sphereMat    = Material(0.2/*Ka*/, 0.7/*Kd*/, 1.0/*Ks*/, 51.0/*Kn*/);\nconst int      sphereId     = 1;\n\n// Sky parameters\nconst vec3     skyCol       = vec3(0);           // black\nconst int      skyId        = 0;           \n\n// Plane parameters\nconst vec3     planePos     = vec3(0, 0.1, 0);\nconst vec3     planeNormal  = vec3(0, 1., 0);\nconst vec3     planeCol1    = vec3(1.0);       // white\nconst vec3     planeCol2    = vec3(0.4);       // grey\nconst Material planeMat     = Material(0.2 /*Ka*/, 1.0 /*Kd*/, 0.4 /*Ks*/, 5.0/*Kn*/);\nconst int      planeId      = 2;\n\n//##############################################################################################\n\nfloat raySphere(    vec3 rayPos    ,     vec3 rayDir, vec3 spherePos, float sphereRadius,\n                out vec3 intersecPt, out vec3 normal)\n{\n    \n    vec3 diff = rayPos - spherePos;\n    \n    float a =       dot(rayDir, rayDir);\n    float b = 2.0 * dot(diff  , rayDir);\n    float c =       dot(diff  , diff  ) - sphereRadius * sphereRadius;\n    \n    float di = b*b - 4.0*a*c;\n    \n    if (di >= 0.0)\n    {\n        float sdi = sqrt(di);\n        float den = 1. / (2.0 * a);\n        float t1  = (-b - sdi) * den;\n        float t2  = (-b + sdi) * den;\n\n\n        float t = -1.0;\n        float dir = 1.0;\n        if (t1 > 0.0)\n        \tt = t1;\n        else if (t2 > 0.0)\n        {\n            t = t2;\n            dir = -1.0;\n        }\n        else\n            return t;\n        intersecPt = rayPos + t * rayDir;\n\n        normal     = normalize(intersecPt - spherePos) * dir;\n        \n        return t;\n    }\n    \n    return -1.0;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvoid computeCameraRayFromPixel( in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{            \n    float focal = 1.0 / tan(radians(cameraFovY) / 2.0);\n\n    vec3 cz = normalize(cameraTarget - cameraPos);\n\n    vec3 up = vec3(0,1,0);\t\t\t\t\t\t\t// perfect up vector\n    vec3 cx = normalize(cross(-up, cz));\n\n    vec3 cy = normalize(cross( cz, cx));\n\n    vec2 pt = (2.*pixCoord - iResolution.xy) / iResolution.y;\n\n    rayPos = cameraPos;\n    rayDir = normalize(pt.x * cx - pt.y * cy + focal * cz);\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec3 computePhongShading(vec3 objectCol, Material objectMat, float shadowFactor, vec3 N, vec3 L, vec3 R, vec3 V)\n{\n    vec3 ambiant  = objectMat.Ka * ambiantCol;\n    vec3 diffuse;\n    if (shadowFactor == 0.)\n        diffuse = objectMat.Kd *  objectCol * lightCol *     max(dot(N,L), 0.);\n    else\n        diffuse = vec3(0.);\n    \n    vec3 specular = objectMat.Ks *              lightCol * pow(max(dot(R,V), 0.), objectMat.Kn);\n    \n    vec3 phongCol = ambiant + diffuse + specular;\n\n    return phongCol;\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n// NOTE: planeNormal must be a uint-vector!\nfloat rayPlane(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal, out vec3 intersectPt, out vec3 normal)\n{\n    float isIntersect = dot(rayDir, planeNormal);\n    if (isIntersect != 0.)\n    {\n        normal = planeNormal;\n        vec3 Bmrp = (planePos - rayPos);\n        float den = dot(rayDir,normal);\n        if (abs(den) <= 0.001)\n            return -1.;\n        float t = dot(Bmrp, normal)/dot(rayDir,normal); \n        intersectPt = rayPos + t * rayDir;\n        return t;\n    }\n    else\n    {\n        return -1.;\n    }\n}\n\n//----------------------------------------------------------------------------------------------\n\n// The aim of this routine is to find the nearest intersection the ray has with ALL the objects\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir, out int objectId, out vec3 intersecI, out vec3 normalI)\n{\n    bool  hasIntersected = false;\n    float dist    = 100000000.;\n    float newDist = -1.;\n    \n    vec3 tmpIntersectI;\n    vec3 tmpnormalI;\n    \n    for (int objId = 0 ; objId < nbObj ; objId++)\n    {\n        if (objId == 0)\n        {\n            continue;\n        }\n\n        if (objId == 1)\n        {\n            newDist = raySphere(rayPos, rayDir, spherePos, sphereRadius, tmpIntersectI, tmpnormalI);\n            //newDist = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecI, normalI);\n        }\n        else if (objId == 2)\n        {\n            newDist = rayPlane(rayPos, rayDir, planePos, planeNormal, tmpIntersectI, tmpnormalI);\n            //newDist = rayPlane(rayPos, rayDir, planePos, planeNormal, intersecI, normalI);\n        }\n        else\n        {\n            continue;\n        }\n        \n        if (newDist != -1.)\n        {\n            if (newDist > 0. && newDist < dist)\n            {\n                dist     = newDist;\n                objectId = objId;\n                newDist  = -1.;\n                \n                //TO DO -> TO COMMENT THOSE 2 LINES\n                intersecI = tmpIntersectI;\n                normalI   = tmpnormalI;\n            }\n        }\n    }\n    \n    \n    if (dist == 100000000.)\n        dist = 0.;\n        \n    return dist;\n}\n\n//----------------------------------------------------------------------------------------------\n\nfloat getShadowFactorAtPoint(vec3 I, vec3 N, Material objectMat, vec3 L, out float Ldist)\n{\n    Ldist = 0.;\n    int  objectId;\n    vec3 iObj;\n    vec3 nObj;\n    Ldist = computeNearestIntersection(I, L, objectId, iObj, nObj);\n    if (Ldist == 0.)\n        return 0.;\n    else \n        return 1.;\n}\n\n//----------------------------------------------------------------------------------------------\n//----------------------------------------------------------------------------------------------\n//----------------------------------------------------------------------------------------------\n\nvec3 getSphereColorAtPoint(vec3 intersecPt, vec3 intersecPtNor, vec3 rayDir)\n{\n    // unit-vector going from the surface point toward the light\n    vec3 L = normalize(lightPos - intersecPt);\n\n    // unit-vector of the reflection direction of the light at the surface point\n    vec3 R = 2.0 * intersecPtNor * dot(intersecPtNor, L)  - L;\n\n    // unit-vector going from the surface point toward the camera \n    vec3 V = -rayDir;\n\n    float Ldist = 0.;\n    float shadowFactor = getShadowFactorAtPoint(intersecPt, intersecPtNor, sphereMat, L, Ldist);\n\n    return computePhongShading(sphereCol, sphereMat, shadowFactor, intersecPtNor, L, R, V);\n}\n\n//----------------------------------------------------------------------------------------------\n\n// pt is assumed to be on the plane\nvec3 getPlaneColorAtPoint(vec3 pt)\n{\n    //pt = vec3(0.,0.,0.);\n    vec3 x = vec3(1.,0.,0.);\n   \n    vec3 uv = normalize(x-dot(planeNormal,x)*planeNormal);\n    vec3 vv = normalize(cross(planeNormal,uv));\n    \n    float xu = dot(pt, uv);\n    float yv = dot(pt, vv);\n\n    //return vec3(1,1,0);\n    return mod((floor(xu * 0.5) + floor(yv * 0.5)), 2.0) < 1.0 ? planeCol1 : planeCol2;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec3 getObjectColorAtPoint(int objectId, vec3 rayDir, vec3 ptI, vec3 nI)\n{\n    vec3 colorPix;\n    if (objectId == 0)\n    {\n        // SKY\n        colorPix = vec3(1,0,0);\n    }\n\n    if (objectId == 1)\n    {\n        // SPHERE\n        \n        vec3 L = normalize(lightPos - ptI);\n\n        // unit-vector of the reflection direction of the light at the surface point\n        vec3 R = 2. * nI * dot(nI, L) - L;\n\n        // unit-vector going from the surface point toward the camera \n         //vec3 V = normalize(cameraPos - intersecS);\n         vec3 V = -rayDir;\n\n        float Ldist = 0.;\n        float shadowFactor = getShadowFactorAtPoint(ptI, nI, sphereMat, L, Ldist);\n\n        // Apply the Phong shading to compute the color\n        // of the surface point as seen from the camera\n        colorPix = computePhongShading(sphereCol, sphereMat, shadowFactor, nI, L, R, V);\n        // = getSphereColorAtPoint(ptI, nI, rayDir);\n    }\n    else if (objectId == 2)\n    {\n        // PLANE\n        \n        vec3 L = normalize(lightPos - ptI);\n\n        // unit-vector of the reflection direction of the light at the surface point\n        vec3 R = 2. * nI * dot(nI, L) - L;\n\n        // unit-vector going from the surface point toward the camera \n         //vec3 V = normalize(cameraPos - intersecS);\n         vec3 V = -rayDir;\n         \n        vec3 colPix = getPlaneColorAtPoint(ptI);\n        \n        float Ldist = 0.;\n        float shadowFactor = getShadowFactorAtPoint(ptI, nI, planeMat, L, Ldist);\n        \n        colorPix = computePhongShading(colPix, planeMat, shadowFactor, nI, L, R, V);\n    }\n    else\n    {\n        colorPix = vec3(0,1,1);\n    }\n    \n    return colorPix;\n}\n\n//----------------------------------------------------------------------------------------------\n//----------------------------------------------------------------------------------------------\n//----------------------------------------------------------------------------------------------\n\n//##############################################################################################\n//##############################################################################################\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Compute the ray to be casted through the pixel towards the 3D scene\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(fragCoord, rayPos, rayDir);\n    \n\t// Test ray-sphere intersection and get the intersection point and associated normal\n    vec3 intersecI, normalI;\n    int objId;\n    float distS = computeNearestIntersection(rayPos, rayDir, objId, intersecI, normalI);\n    \n    // Apply the shading to the points that are on the sphere surface and seen by the camera\n    if (distS > 0.0)\n    {\n        vec3 colorPix = getObjectColorAtPoint(objId, rayDir, intersecI, normalI);\n        fragColor = vec4(colorPix, 1);\n    }\n    else\n    {\n        fragColor = vec4(0,0,0, 1);\n    }\n}","name":"Image","description":"","type":"image"}]}