{"ver":"0.1","info":{"id":"ftBBzc","date":"1652477272","viewed":74,"name":"audio portals","username":"Wampow","description":"Visualize Soundcloud audio. Put your own song into Buffer A iChannel1 and enjoy.","likes":0,"published":1,"flags":96,"usePreview":0,"tags":["audio"],"hasliked":0,"parentid":"flBfRV","parentname":"audio1"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.x = uv.x*.5+2.; //morph 1\n    vec3 polar = toPolar(uv); //polar projection (from interwebs)\n    uv = polar.xy; //project onto circle\n    uv *= 1.+0.35* sin(iTime * 0.1 + uv.yx*4.61)-0.725; // wobble\n    uv.x = uv.x * .8 + 1.14; //morph 2 \n    \n    // bad try to polar project myself\n    //float r = 1.0*(0.35*sin(iTime)-1.8);\n    //float teta = 2.0 * 3.141 * (uv.x-0.5);\n    //vec2 Tpolar = vec2(r * cos(teta), r *sin(teta)); //wrong\n    //uv = Tpolar;\n    \n    // unused point projection\n    //vec2 point = vec2( fragCoord.xy - 0.5*iResolution.xy );\n\t//point = 1.0 * point.xy / iResolution.y;\n    //point += vec2(+.9,0.50);\n    //point.x *= 0.275;\n    \n    uv *= vec2(.5,1.10); // extramorph\n    // Output to screen\n    // display spectrograph of Buffer A (loaded onto iChannel0)\n    fragColor = texture(iChannel0, uv); //+ vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4lSSz1","filepath":"https://soundcloud.com/wampow/you-tried","previewfilepath":"https://soundcloud.com/wampow/you-tried","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    //init\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //do point stuff\n    vec2 point = vec2( fragCoord.xy - 0.5*iResolution.xy );\n\tpoint = 2.0 * point.xy / iResolution.y;\n    point.x = -point.x;\n    //regret point stuff\n    //morphs\n    //uv = .625-uv;\n    uv *= 2.625;\n    uv += -1.5;\n    \n    // get sound (one channel)\n    vec4 snd = texture(iChannel1, uv.xx); \n    //colors by frequency\n    vec4 col = vec4(1.525/((uv.x+.5)*1.75)-0.5,6.75*(uv.x+.15)-0.2,pow((uv.x+.7),2.)*4.85-1.52,1.0);\n    col = clamp(col,0.0,2.0); // better safe than sorry\n    //color shift\n    col *= vec4(cross(col.yxz, vec3(1.8*cos(iTime*0.07+1.3),.7*sin(iTime*0.09+0.0),-1.015*cos(iTime*0.13-1.3))*sin(iTime*0.027)*.95-.710), 1.0);\n    col = clamp(col,0.0,2.0); // better safe than sorry\n    // sound mix and dampening\n    col *= snd.x * (1. - (uv.x*2./(1.*uv.x+0.75))); \n    \n    //col += vec4(-point.x,0.0,1.75,1.0) * point.x * col.x;\n    col = clamp(col,0.0,1.0); // better safe than sorry\n    fragColor += col + texture(iChannel0, uv) * (0.9 - 1./50.5); // fading from previous frame\n    fragColor = clamp(fragColor,0.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//https://gamedev.stackexchange.com/questions/135108/converting-back-and-forth-between-spherical-and-cartesian-coordinates-in-glsl\n//credits to andras\nconst float PI = 3.1415926535897932384626433832795028841971693993751058209749;\n\nvec2 toUV(in vec3 n)\n{\n    vec2 uv;\n\n    uv.x = atan(-n.x, n.y);\n    uv.x = (uv.x + PI / 2.0) / (PI * 2.0) + PI * (28.670 / 360.0);\n\n    uv.y = acos(n.z) / PI;\n\n    return uv;\n}\n\n// Uv range: [0, 1]\nvec3 toPolar(in vec2 uv)\n{\n    float theta = 2.0 * PI * uv.x + - PI / 2.0;\n    float phi = PI * uv.y;\n\n    vec3 n;\n    n.x = cos(theta) * sin(phi);\n    n.y = sin(theta) * sin(phi);\n    n.z = cos(phi);\n\n    //n = normalize(n);\n    return n;\n}","name":"Common","description":"","type":"common"}]}