{"ver":"0.1","info":{"id":"XsdSWS","date":"1461519526","viewed":319,"name":"Pedagogical Font","username":"akohdr","description":"Using 2D primitives to render text.  Mouse resizes, bunch of #define flags and commented sections to play with.\n\nComment DEBUG and change antialias from using neon to stripe for a fun font.","likes":7,"published":1,"flags":0,"usePreview":1,"tags":["2d","text","font","microcode"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Pedagogical Font  (related in use shader example https://www.shadertoy.com/view/4sdXD2 )\n// ================\n//\n// Experiment to capture 'eidos' of a minimal proportional sans serif font\n//\n//      point -> line -> plane / font\n//\t\tASCII -> glyph -> 2D ribbon of text\n//\n// ( somewhat inspired by Paul Klee's pedagogical sketchbook\n//   highlighted in a great eyeo presentation https://vimeo.com/135073747 )\n//\n// We render a font with minimal strokes of 2D primitives\n// Primitives are parameterized with control points in x>0 half plane\n//\n// Primitives used:\n//\t\t(green) circle/point        w (x,y) r\n//\t\t(blue)  rounded line\t    w (x,y) (x,y)\t\t\t(for efficiency)\n//\t\t(red)   rounded bezier line\tw (x,y) (x,y) (x,y)\n//\n// Control points provide basis for rendering alpha numerics in any output pipeline\n// translation, scaling, rotation become trivial linear transforms of control points\n// \n// This is not OpenType, TrueType etc. absolute typographical control is sacrificed \n// for simplicity and flexibility (optical sizing may become problematic)\n//\n// This approach provides seperation of concerns pushing stylistic control to the \n// output pipeline and primitive implementations\n//\n// (in your best Jonathan Ive voice .... )\n// Ultimately we seek to capture the essence of symbol and character in the planar domain.\n//\n// With this essence we can choose to reimagine or reinterpret as we see fit while still\n// conveying the textual semantic of the content through the visual domain to the viewer. :)\n//\n\n// Use debug flag to colour primitives RGB\n#define DEBUG\n// Choose #define macros vs functions\n//#define USE_GLYPH_DEFS\n\n#define INK ORG\n#define WIDTH 5.\n#define ALPHABET_OR_PANGRAM\n//#define ANIMATE_RESIZE\n\n// Using point to line distances gives us an antialiasing pointcut we can exploit\nvoid antialias(inout vec4 k, float d, float w, vec4 K) {\n    // Standard filled antialiased lines\n//    k += K*(w-d);\n\n    // Neon glow\n    k += K/d;\n    \n\t// Partially stenciled lines \n//  k += K*sin(d-w);\n    \n    // Hollow lines\n//    k += K*cos(1.5+d-w);\n    \n    // Center line plus outline\n//  k += K*tan(.2+d-w);\n    \n    // Stripe filled (using screen x/y would give stable fill)\n//    k += K*max(K*cos(d-w), cos(7.*(d-w)));\n    \n    // Temporally striped and outlined\n//  k += K*max(K*cos(d-w), 1.+2.*cos(7.*(d-w)*(1.1+sin(iTime/2.))));\n    \n    // Flashing font (temporal)\n//    k += K*max(K*cos(d-w), sin(5.*iTime));\n}\n\n\n#define BLK vec4(.0,.0,.0,1.)\n#define GRY vec4(.5,.5,.5,1.)\n#define WHT vec4(1.,1.,1.,1.)\n#define RED vec4(1.,.0,.0,1.)\n#define GRN vec4(.0,1.,.0,1.)\n#define BLU vec4(.0,.0,1.,1.)\n#define YEL vec4(1.,1.,.0,1.)\n#define ORG vec4(1.,.5,.0,1.)\n#define PNK vec4(1.,.0,.5,1.)\n#define MAG vec4(1.,.0,1.,1.)\n#define CYN vec4(0.,1.,1.,1.)\n#define PRP vec4(.5,.0,.5,1.)\n\n#define PI 3.14159265358979\n\nfloat dBezier1(vec2 p, vec4 ac, vec2 b);// exact  https://www.shadertoy.com/view/Mlj3zD\nfloat dBezier2(vec2 p, vec4 ac, vec2 b);// approx https://www.shadertoy.com/view/XsX3zf\n\n// Provides distance of p to audratic bezier curve described by abc\n#define dBezier dBezier1\n\n//=============================================================================\n// The primitives.\n\nvoid bezier(inout vec4 k, vec2 p, vec4 ac, vec4 bw, vec4 K) {\n#ifdef DEBUG \n    K = RED; \n#endif\n    float d = dBezier(p,ac,bw.xy);\n    if(d<bw.z) antialias(k,d,bw.z,K);\n}\n\nvoid circle(inout vec4 k, in vec2 p, vec4 a, vec4 K) \n{\n#ifdef DEBUG \n    K = GRN; \n#endif\n    float r = a.z,\n          w = a.w,\n          w2 = w/2.,\n          l = length(p-a.xy),\t\t\t\t\t\t\t// distance from p to center\n          // are we inside or outside circle?\n          d = (l>r) ? abs((l-r)+w2): abs((r-l)-w2);\t\t// distance to edge line width(w)\n//          d = (l>r) ? l-r : r-l;\t\t\t\t\t\t// distance to center line\n    if(d<w) antialias(k,d,w,K);\n}\n\nvoid line(inout vec4 k, vec2 p, vec4 l, float w, vec4 K) \n{\n#ifdef DEBUG \n    K = BLU; \n#endif\n    vec2 a=l.xy, b=l.zw;\n    b -= a;  p -= a;\n    float d = length (p - clamp (dot (p, b) / dot (b, b), .0, 1.) * b);\n    if(d<w) antialias(k,d,w,K);\n}\n\n//=============================================================================\n// We (micro)codify the control point data to drive the rendering process\n\nvoid procGlyph(inout vec4 k, inout vec4 c, in vec2 p, \n               float s, float w, vec4 K,\n               mat4 ps, int a)\n{\n    // Stroke endpoints are limited to x>0 half plane \n    //    (limits ability for hanging tails under previous char, compromise)\n    // this allows us to use sign of x component to select primitive\n    // line width (w) is injected before calling primitive\n    bool skip = false;\n    for(int i=0;i<4;i++) {\n        if(skip) {skip = false; continue;}\n        vec4 u = s*ps[i];\n        if(u.x<0.)\n            if(u.z<0.){ // second point x \n                vec4 v = s*ps[i+1]; skip = true;\n                bezier(k, p, c.xyxy+vec4(-u.x,u.y,-u.z,u.w), c+vec4(v.xy,w,0.), K);\n            }\n        else\n            circle(k, p, c+vec4(-u.x,u.yz,w), K);\n        else \n            if(u.x>0.)   // 0 is NOP\n                line(k, p, c.xyxy+u,w, K);\n    }\n    // advance cursor in font x direction (proportional font)\n    c.x += s*float(a);\n}\n\n// glyph functions ============================================================\n// Commented code shows development toward the final defs in USE_GLYPH_DEFS\n\n// hanging macro (compile quicker less source noise)\n#define PROC procGlyph(k,c,p,s,w,K,mat4(\n#define Z4 0,0,0,0\n#define Z8 Z4,Z4\n\n#ifndef USE_GLYPH_DEFS\n\n#define LP localPts(c,s,\n#define LPxy localPts(c.xyxy,s,\nvec4 localPts(vec4 c, float s, int x, int y, int z, int w){return c+s*vec4(x,y,z,w);}\nvec4 localPts(vec4 c, float s, float x, float y, float z, float w){return c+s*vec4(x,y,z,w);}\n\nvoid g_a(inout vec4 k, inout vec4 c, in vec2 p, float s, float w, vec4 K)\n{\n    PROC  -2,8,-13,-8,   16,15,0,0,   -6,-2,7,0,   Z4), 20);\n//\tbezier(k, p, LPxy 2,8,13,-8), LP 16.,15.,w,0.), K);\n//\tcircle(k, p, LP 6.,-2.,8.,w), K);\n//  c.x += s*20.;\n}\n\nvoid g_b(inout vec4 k, inout vec4 c, in vec2 p, float s, float w, vec4 K)\n{\n    PROC 1,20,0,-7,   -8,0,8,0,   Z8),20);\n    //line(k,p,LPxy 0,20,0,-7),w,K);\n    //circle(k, p, LP 8.,0.,10.,w), K);\n}\n\nvoid g_c(inout vec4 k, inout vec4 c, in vec2 p, float s, float w, vec4 K)\n{\n    PROC -1,0,-13,5,   3,12,0,0, -1,0,-14,-3,  -2,-12,0,0), 22);\n//    bezier(k, p, LPxy 0,0,13,5), LP 3.,12.,w,0.), K);\n//    bezier(k, p, LPxy 1,0,14,-3), LP 2.,-12.,w,0.), K);\n//    c.x += s*22.;\n}\n\nvoid g_d(inout vec4 k, inout vec4 c, in vec2 p, float s, float w, vec4 K)\n{\n    PROC -5,0,8,0,  13,20,13,-7,   Z8), 20);\n//\t  circle(k, p, LP 5.,0.,10.,w), K);\n//    line(k,p,LPxy 13,20,13,-7),w,K);\n//    c.x += s*20.;\n}\n\nvoid g_e(inout vec4 k, inout vec4 c, in vec2 p, float s, float w, vec4 K)\n{\n    PROC -6,6,-15,-6,   -8,-10,0,0,   -9,7,-1,-2,   25,2,0,0), 22);\n//    PROC -1,0,-13,2,   5,16,0,0,   -1,0,-13,-5,   2,-14,0,0), 0);\n//    PROC  3,-1,12,1,   Z4,Z8), 22);\n//    bezier(k, p, LPxy 0,0,13,2), LP 5.,16.,w,0.), K);\n//    bezier(k, p, LPxy 1,0,13,-5), LP 2.,-14.,w,0.), K);\n//    line(k,p,LPxy 3,-1,12,1),w,K);\n//    c.x += s*22.;\n}\n\nvoid g_f(inout vec4 k, inout vec4 c, in vec2 p, float s, float w, vec4 K)\n{\n    PROC -9,18,-2,-8,   1,25,0,0,   9,5,0,4,   Z4),14);\n//    bezier(k, p, LPxy 9,18,0,-8), LP -6.,25.,w,0.), K);\n//    line(k,p,LPxy 9,5,0,4),w,K);\n//    c.x += s*14.;\n}\n\nvoid g_g(inout vec4 k, inout vec4 c, in vec2 p, float s, float w, vec4 K)\n{\n    PROC -7,0,8,0,   -15,8,-1,-16,   17,-28,0,0,   Z4), 22);\n//\t  circle(k, p, LP 7.,0.,10.,w), K);\n//    bezier(k, p, LPxy 15,8,0,-16), LP 17.,-28.,w,0.), K);\n//    c.x += s*22.;\n}\n\nvoid g_h(inout vec4 k, inout vec4 c, in vec2 p, float s, float w, vec4 K)\n{\n    PROC 1,20,0,-8,   -1,4,-14,-8,   13,15,0,0,   Z4), 18);\n//    line(k,p,LPxy 0,20,0,-8),w,K);\n//    bezier(k, p, LPxy 1,4,14,-8), LP 13.,15.,w,0.), K);\n//    c.x += s*18.;\n}\n\nvoid g_i(inout vec4 k, inout vec4 c, in vec2 p, float s, float w, vec4 K)\n{\n    PROC -3,13,2,0,   -2,7,-4,-6,   -1,-16,0,0,   Z4), 10);\n//\tcircle(k, p, LP 3.,13.,2.,w), K);\n//    bezier(k, p, LPxy 2,7,4,-6), LP -1.,-16.,w,0.), K);\n//    c.x += s*10.;\n}\n\nvoid g_j(inout vec4 k, inout vec4 c, in vec2 p, float s, float w, vec4 K)\n{\n    PROC -2,13,2,0,   -5,7,-1,-15,   5,-22,0,0,   Z4), 10);\n//\tcircle(k, p, LP 2.,13.,2.,w), K);\n//    bezier(k, p, LPxy 2,7,-8,-15), LP 5.,-22.,w,0.), K);\n//    c.x += s*10.;\n}\n\nvoid g_k(inout vec4 k, inout vec4 c, in vec2 p, float s, float w, vec4 K)\n{\n    PROC 1,18,0,-8,   1,-2,13,6,   5,0,13,-8,   Z4), 18);\n//    line(k,p,LPxy 0,18,0,-8),w,K);\n//    line(k,p,LPxy 1,-2,13,6),w,K);\n//    line(k,p,LPxy 5,0,13,-8),w,K);\n//    c.x += s*18.;\n}\n\nvoid g_l(inout vec4 k, inout vec4 c, in vec2 p, float s, float w, vec4 K)\n{\n    PROC -1,19,-6,-5,   0,-18,0,0,   Z8), 12);\n//    bezier(k, p, LPxy 1,19,6,-5), LP 0.,-18.,w,0.), K);\n//    c.x += s*12.;\n}\n\nvoid g_m(inout vec4 k, inout vec4 c, in vec2 p, float s, float w, vec4 K)\n{\n    PROC -1,-9,-8,-3,   2,20,0,0,   -8,-3,-16,-9,   14,20,0,0), 24);\n    //TODO: pack further\n//    PROC 1,7,0,-8,   -1,4,-9,-3,   9,15,0,0,   Z4), 0);\n//    PROC -10,4,-17,-8,   19,15,0,0,   Z8), 24);\n//    line(k,p,LPxy 0,7,0,-8),w,K);\n//    bezier(k, p, LPxy 1,4,9,-3), LP 9.,15.,w,0.), K);\n//    bezier(k, p, LPxy 10,4,17,-8), LP 19.,15.,w,0.), K);\n//    c.x += s*24.;\n}\n\nvoid g_n(inout vec4 k, inout vec4 c, in vec2 p, float s, float w, vec4 K)\n{\n    PROC 1,7,0,-8,   -1,4,-14,-8,   15,15,0,0,   Z4), 20);\n//    line(k,p,LPxy 0,7,0,-8),w,K);\n//    bezier(k, p, LPxy 1,4,14,-8), LP 15.,15.,w,0.), K);\n//    c.x += s*20.;\n}\n\nvoid g_o(inout vec4 k, inout vec4 c, in vec2 p, float s, float w, vec4 K)\n{\n    PROC -7,0,8,0, Z4, Z8), 20);\n//\tcircle(k, p, LP 7.,0.,10.,w), K);\n//    c.x += s*20.;\n}\n\nvoid g_p(inout vec4 k, inout vec4 c, in vec2 p, float s, float w, vec4 K)\n{\n    PROC -9,0,8,0,   1,7,1,-20, Z8), 22);\n//\tcircle(k, p, LP 9.,0.,10.,w), K);\n//    line(k,p,LPxy 1,7,1,-20),w,K);\n//    c.x += s*22.;\n}\n\nvoid g_q(inout vec4 k, inout vec4 c, in vec2 p, float s, float w, vec4 K)\n{\n    PROC -6,0,8,0,   14,7,14,-20,   Z8), 20);\n//\tcircle(k, p, LP 6.,0.,10.,w), K);\n//    line(k,p,LPxy 14,7,14,-20),w,K);\n//    c.x += s*20.;\n}\n\nvoid g_r(inout vec4 k, inout vec4 c, in vec2 p, float s, float w, vec4 K)\n{\n    PROC 1,8,0,-7,   -2,3,-13,5,   11,12,0,0,   Z4), 20);\n//    line(k,p,LPxy 0,8,0,-7),w,K);\n//    bezier(k, p, LPxy 2,3,13,5), LP 11.,12.,w,0.), K);\n//    c.x += s*20.;\n}\n\nvoid g_s(inout vec4 k, inout vec4 c, in vec2 p, float s, float w, vec4 K)\n{\n    PROC -5,0,-8,7,   -8,8,0,0,   -6,-1,-1,-6,   15,-11,0,0), 14);\n//    bezier(k, p, LPxy 5,0,8,7), LP -10.,8.,w,0.), K);\n//    bezier(k, p, LPxy 6,-1,0,-6), LP 15.,-11.,w,0.), K);\n//    c.x += s*14.;\n}\n\nvoid g_t(inout vec4 k, inout vec4 c, in vec2 p, float s, float w, vec4 K)\n{\n    PROC -4,15,-12,-5,   1,-15,0,0,   1,8,8,8, Z4), 16);\n//    bezier(k, p, LPxy 4,15,12,-5), LP 1.,-15.,w,0.), K);\n//    line(k,p,LPxy 0,8,8,8),w,K);\n//    c.x += s*16.;\n}\n\nvoid g_u(inout vec4 k, inout vec4 c, in vec2 p, float s, float w, vec4 K)\n{\n    PROC -1,8,-13,-4,   0,-16,0,0,   14,8,14,-8,   Z4), 20);\n//    bezier(k, p, LPxy 1,8,13,-4), LP 0.,-16.,w,0.), K);\n//    line(k,p,LPxy 14,7,14,-8),w,K);\n//    c.x += s*20.;\n}\n\nvoid g_v(inout vec4 k, inout vec4 c, in vec2 p, float s, float w, vec4 K)\n{\n    PROC 1,8,6,-8,   11,8,6,-8,   Z8), 16);\n//    line(k,p,LPxy 1,8,6,-8),w,K);\n//    line(k,p,LPxy 11,8,6,-8),w,K);\n//    c.x += s*16.;\n}\n\nvoid g_w(inout vec4 k, inout vec4 c, in vec2 p, float s, float w, vec4 K)\n{\n    PROC 1,8,4,-8,   4,-6,9,4,   9,4,14,-6,   14,-8,18,8), 23);\n//    line(k,p,LPxy 0,8,4,-8),w,K);\n//    line(k,p,LPxy 4,-6,9,4),w,K);\n//    line(k,p,LPxy 9,4,14,-6),w,K);\n//    line(k,p,LPxy 14,-8,18,8),w,K);\n//    c.x += s*23.;\n}\n\nvoid g_x(inout vec4 k, inout vec4 c, in vec2 p, float s, float w, vec4 K)\n{\n    PROC 1,8,8,-8,   8,8,0,-8,   Z8), 12);\n//    line(k,p,LPxy 0,8,8,-8),w,K);\n//    line(k,p,LPxy 8,8,0,-8),w,K);\n//    c.x += s*12.;\n}\n\nvoid g_y(inout vec4 k, inout vec4 c, in vec2 p, float s, float w, vec4 K)\n{\n    PROC -2,8,-12,-4,   4,-11,0,0,   -14,8,-1,-18,   14,-28,0,0), 22);\n//    bezier(k, p, LPxy 2,8,12,-4), LP 4.,-11.,w,0.), K);\n//    bezier(k, p, LPxy 14,8,0,-18), LP 14.,-28.,w,0.), K);\n//    c.x += s*22.;\n}\n\nvoid g_z(inout vec4 k, inout vec4 c, in vec2 p, float s, float w, vec4 K)\n{\n    PROC 1,8,8,8,   8,8,0,-8,   1,-8,8,-8,   Z4), 14);\n//    line(k,p,LPxy 0,8,8,8),w,K);\n//    line(k,p,LPxy 8,8,0,-8),w,K);\n//    line(k,p,LPxy 0,-8,8,-8),w,K);\n//    c.x += s*14.;\n}\n\n#endif\n//=============================================================================\n\n#define OUT (k,c,p,s,w,K);\n\n/*\nThe 'eidos' of the font.....\n*/\n\n#ifdef USE_GLYPH_DEFS\n//#define R 6.\n#define R 8.\n//#define R 10.\n#define a_    PROC -2,8,-13,-8, \t16,15,0,0,   -6,-2,.8*R,0,  Z4), \t\t\t20);\n#define b_    PROC 1,20,1,-7,   \t-8,0,R,0,   \t\t\t\tZ8),\t\t\t20);\n#define c_    PROC -1,0,-13,5,   \t3,12,0,0, \t -1,0,-14,-3,   -2,-12,0,0), \t22);\n#define d_    PROC -5,0,R,0,  \t\t13,20,13,-7, Z8), \t\t\t\t\t\t\t20);\n#define e_    PROC -6,6,-15,-6,   \t-8,-10,0,0,   -6,6,-1,-2,   25,2,0,0), \t\t22);\n#define f_    PROC -9,18,-2,-8,  \t1,25,0,0,    9,5,0,4,   \tZ4),\t\t\t14);\n#define g_    PROC -7,0,R,0,   \t\t-15,8,-1,-16,17,-28,0,0, \tZ4), \t\t\t22);\n#define h_    PROC 1,20,1,-8,   \t-1,4,-14,-8, 13,15,0,0,   \tZ4), \t\t\t18);\n#define i_    PROC -3,13,2,0,   \t-2,7,-4,-6,  -1,-16,0,0,   \tZ4), \t\t\t10);\n#define j_    PROC -5,13,2,0,   \t-5,7,-1,-10, 8,-25,0,0,   \tZ4), \t\t\t12);\n#define k_    PROC 1,18,1,-8,   \t1,-2,13,6,   5,0,13,-8,   \tZ4), \t\t\t18);\n#define l_    PROC -1,19,-6,-5,  \t0,-18,0,0,   Z8), \t\t\t\t\t\t\t12);\n#define m_    PROC -1,-9,-8,-3,   \t2,20,0,0,  \t -8,-3,-16,-9,  14,20,0,0),\t\t24);\n#define n_    PROC 1,7,1,-8,   \t\t-1,4,-14,-8, 15,15,0,0,   \tZ4), \t\t\t20);\n#define o_    PROC -7,0,R,0, \t\tZ4, \t\t Z8), \t\t\t\t\t\t\t20);\n#define p_    PROC -9,0,R,0,   \t\t1,7,1,-20, \t Z8), \t\t\t\t\t\t\t22);\n#define q_    PROC -6,0,R,0,   \t\t14,7,14,-20, Z8), \t\t\t\t\t\t\t20);\n#define r_    PROC 1,8,1,-7,   \t\t-2,3,-13,5,  11,12,0,0,   \tZ4), \t\t\t20);\n#define s_    PROC -6,-1,-8,7,   \t-8,8,0,0,  \t -6,-1,-1,-6,   15,-11,0,0), \t14);\n#define t_    PROC -4,15,-12,-5, \t1,-15,0,0,   1,8,8,8, \t\tZ4),         \t16);\n#define u_    PROC -1,8,-13,-4,  \t0,-16,0,0,   14,8,14,-8,    Z4), \t\t\t20);\n#define v_    PROC 1,8,6,-8,   \t\t11,8,6,-8,   Z8), \t\t\t\t\t\t\t16);\n#define w_    PROC 1,8,4,-8,   \t\t4,-8,9,4,    9,4,14,-8,   \t14,-8,18,8), \t23);\n#define x_    PROC 1,8,8,-8,   \t\t8,8,0,-8,    Z8), \t\t\t\t\t\t\t12);\n#define y_    PROC -2,8,-13,-4,  \t4,-11,0,0,   -14,8,-1,-18,  14,-28,0,0), \t22);\n#define z_    PROC 1,8,8,8,   \t\t8,8,0,-8,    1,-8,8,-8,   \tZ4), \t\t\t14);\n\n#else\n\n// use g_ glyph functions\n#define a_ g_a OUT;\n#define b_ g_b OUT;\n#define c_ g_c OUT;\n#define d_ g_d OUT;\n#define e_ g_e OUT;\n#define f_ g_f OUT;\n#define g_ g_g OUT;\n#define h_ g_h OUT;\n#define i_ g_i OUT;\n#define j_ g_j OUT;\n#define k_ g_k OUT;\n#define l_ g_l OUT;\n#define m_ g_m OUT;\n#define n_ g_n OUT;\n#define o_ g_o OUT;\n#define p_ g_p OUT;\n#define q_ g_q OUT;\n#define r_ g_r OUT;\n#define s_ g_s OUT;\n#define t_ g_t OUT;\n#define u_ g_u OUT;\n#define v_ g_v OUT;\n#define w_ g_w OUT;\n#define x_ g_x OUT;\n#define y_ g_y OUT;\n#define z_ g_z OUT;\n\n#endif\n\n#define Sp_ c.x += s*16.;\n#define Cr_ c.y -= s*35.; c.x = s*40.;\n\nvoid mainImage(out vec4 k, in vec2 p )\n{    \n    k = vec4(0);\n    // DO NOT output text this way it's ridiculously inefficient \n    // used only for stress testing to gauge glyph efficiency\n\n#ifdef ANIMATE_RESIZE\n    float cT = 1.5+cos(iTime),\n          s = iResolution.x/600.*cT;\n#else\n#ifdef ALPHABET_OR_PANGRAM\n    float s = iResolution.x/250.;\n#else\n    float s = iResolution.x/600.;\n#endif\n#endif\n    if(iMouse.z>0.) s = 3.*(1.-iMouse.y/iResolution.y);\n    \n    float w = WIDTH;\n    vec4 c = vec4(0,iResolution.y,0,0),\n         K = INK;\n    \n#ifdef ALPHABET_OR_PANGRAM\n    Cr_\n    a_ b_ c_ d_ e_ f_ g_ h_ Cr_\n    i_ j_ k_ l_ m_ n_ o_ p_ q_ Cr_\n    r_ s_ t_ u_ v_ w_ x_ y_ z_ \n#else\n    //the quick brown fox jumps over the lazy dog\n    Cr_\n    t_ h_ e_ Sp_\n    q_ u_ i_ c_ k_ Sp_\n    b_ r_ o_ w_ n_ Sp_\n    f_ o_ x_ Cr_\n    j_ u_ m_ p_ s_ Sp_\n    o_ v_ e_ r_ Cr_\n    t_ h_ e_ Sp_\n    l_ a_ z_ y_ Sp_\n    d_ o_ g_\n#endif\n}\n\n\n\n\n\n\n\n\n\n//Bezier line implementations follow\n//=============================================================================\n// derived from bezier code @ https://www.shadertoy.com/view/Mlj3zD\n#define PI 3.14159265358979\nint findRoots(vec4 abcd, out vec3 r)\n{\n    float a = abcd[0], \n          b = abcd[1], \n          c = abcd[2], \n          d = abcd[3];\n    vec3 vS = vec3(-1);\n    if (abs(a) > 1e-9){\n        \n        float z = 1./a;\n        abcd *= z;\n        a = abcd[1];\n        b = abcd[2];\n        c = abcd[3];\n        \n        float d3 = 1./3.,\n              aa = a*a,\n             d27 = 1./27.,\n               p = b-aa*d3,\n               q = a*(2.*aa-9.*b)*d27+c,\n             ppp = p*p*p,\n               D = q*q+4.*ppp*d27,\n           delta = -a*d3;\n        \n        if (D > 1e-9){\n            z = sqrt(D);\n            vec2 uv = .5*(vec2(z,-z)-q),\n                  s = sign(uv);\n            uv = abs(uv);\n    \t\tfloat u = s.x*pow(uv.x,d3),\n                  v = s.y*pow(uv.y,d3);\n            r.x = u+v+delta;\n            return 1;\n        }\n        else if (D < -1e-9){\n            float u = sqrt(-p*d3)*2.,\n                  s = -sqrt(-27.0/ppp)*q*.5;\n            if (abs(s) > 0.) {}\n            r = u*cos(vec3(acos(s)*d3) + vec3(0,2,4)*PI*d3)+delta;\n            return 3;\n        }\t\t\n        else {\n            q = sign(q)*pow(abs(q)*.5,d3);\n            r.xy = vec2(-q,q)+delta;\n            r.x *= 2.;\n            return 2;\n        }\n    }\n    else {\n        if (abs(b) <= 1e-9 && abs(c) > 1e-9) {\n            r.x = -d/c;\n            return 1;\n        }\n        else {\n            float D = c*c-4.*b*d,\n                  z = 1./(2.*b);\n            if (D > 1e-9) {\n                D = sqrt(D);\n                r.xy = (vec2(-D,D)-c)*z;\n                return 2;\n            }\n            else if (D > -1e-9) {\n                r.x = -c*z;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\nvec2 bzPos(float t, vec2 a, vec2 b, vec2 c) \n{\n    float mT = 1.-t;\n    vec2 pos = mT*mT*a+2.*t*mT*b+t*t*c;\n    return pos;\n}\n\nfloat dBezier1(vec2 p, vec4 ac, vec2 b) \n{\n    vec2 a = ac.xy, \n         c = ac.zw,\n       dap = a-p,\n       dba = b-a,\n       sac = a+c-b*2.;\n    vec3 r;\n    float dist = 999.;\n    int roots = findRoots(vec4(dot(sac,sac), \n                               dot(dba,sac)*3.,\n                               dot(dba,dba)*2.+dot(dap, sac), \n                               dot(dap,dba)),r);\n    float r1 = r.x,\n          r2 = r.y,\n          r3 = r.z;\n    if (roots > 0 && r1 >= 0. && r1 <= 1.)\n        dist = distance(p,bzPos(r1,a,b,c));\n    if (roots > 1 && r2 >= 0. && r2 <= 1.)\n        dist = min(dist, distance(p,bzPos(r[1],a,b,c)));\n    if (roots > 2 && r3 >= 0. && r3 <= 1.)\n        dist = min(dist, distance(p,bzPos(r[2],a,b,c)));\n    return min(dist, min(distance(p, a), distance(p, c)));\n}\n\n\n//=============================================================================\n// Alternative Bezier Implementation derived from https://www.shadertoy.com/view/XsX3zf\n// approximation shows on thicker lines when endpoints are close\n// may be useful for finer lines/small text higher speed (?)\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\nvec2 bzPtInSeg( vec2 a, vec2 b ){\n  vec2 d = b - a;\n  return a + d*clamp( -dot(a,d)/dot(d,d), 0., 1. );\n}\n\nvec2 bzVec(vec2 a, vec2 b, vec2 c) {\n  float q = det(a,c), \n        r = det(b,a), \n        s = det(c,b),\n       q2 = 2.*(q + r + s);\n  if( abs(q2) < 1000. ) \n      return bzPtInSeg(a,c);\n  vec2 dba = b - a, \n       dca = c - a,\n        gf = q*dca + 2.*(r*(c-b) + s*dba),\n  \t\tgs = 2.*vec2(gf.y,-gf.x),\n         d = a + (4.*r*s - q*q)*gs/dot(gs,gs);\n  float t = clamp((det(d,dca) + 2.*det(dba,d)) / q2, 0. ,1.);\n  return mix(mix(a,b,t),mix(b,c,t),t);\n}\n\nfloat dBezier2(vec2 p, vec4 ac, vec2 b) {\n  return length(bzVec(ac.xy-p, b-p, ac.zw-p));\n}\n\n","name":"Image","description":"","type":"image"}]}