{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"\n#define max4(A,B,C,D) max(max(A,B),max(C,D))\n#define max3(A,B,C) max(max(A,B),C)\n\n// Very, very distant past: https://www.shadertoy.com/view/MtV3Dy\n// Thanks spalmer for a few ideas...\n\nfloat sdSphere(vec3 p,float s) {\n    return length(p)-s;\n}\n\nfloat sdTetrahedron(vec3 p,float d) {\n    return (max4(-p.x+p.y+p.z, p.x-p.y+p.z, p.x+p.y-p.z, -p.x-p.y-p.z) - d)/sqrt(3.);\n}\n\nfloat sdCube(vec3 p,float s) {\n    p = abs(p);\n    return max3(p.x,p.y,p.z)-s;\n}\n\nfloat sdOctahedron(vec3 p,float d) {\n    p = abs(p);\n    return (p.x+p.y+p.z-d)/sqrt(3.);\n}\n\n// Phi is Phun !\n#define PHI 1.6180339887\n\nfloat sdDodecahedron(vec3 p,float d) {\n    p = abs(p);\n    return max3( p.y+p.z*PHI, p.z+p.x*PHI, p.x+p.y*PHI )/sqrt(2.+PHI) - d;\n}\n\nfloat sdIcosahedron(vec3 p,float d) {\n    p = abs(p);\n    return max4( p.x+p.y+p.z, p.y/PHI+p.z*PHI, p.z/PHI+p.x*PHI, p.x/PHI+p.y*PHI )/sqrt(3.) - d;\n}    \n\n#define ROT2(ANG) mat2(cos(ANG),sin(ANG),-sin(ANG),cos(ANG))\n\nvec3 Spin(float tim,vec3 p) {\n   tim += iTime;\n   p.xz *= ROT2(tim);\n   p.yz *= ROT2(tim*1.5);\n   p.yx *= ROT2(tim*.5);\n   return p;\n}\n\n#define T(SDF) if ( (tmp = SDF) < hit.x ) hit = vec2(tmp,clr); clr += 1.;\n\nvec2 Dist(vec3 pt) {\n    vec2 hit = vec2(100000,0);\n    float tmp, clr = 0.;\n    T(sdCube(Spin(1.,pt-vec3(0,0,15)),4.))\n    T(sdOctahedron(Spin(2.,pt-vec3(9,9,9)),4.));\n    T(sdIcosahedron(Spin(3.,pt-vec3(9,-9,9)),4.));\n    T(sdDodecahedron(Spin(4.,pt-vec3(-9,9,9)),4.));\n    T(sdTetrahedron(Spin(5.,pt-vec3(-9,-9,9)),4.));\n    for ( float dist = 10.; dist < 160.; dist += 40. ) {\n      T(sdSphere(pt-vec3(-20,0,dist),5.));\n      T(sdSphere(pt-vec3(20,0,dist),5.));\n      T(sdSphere(pt-vec3(0,-20,dist),5.));\n      T(sdSphere(pt-vec3(0,20,dist),5.));\n    }\n    T(pt.z+200.);\n    return hit;\n}\n\nvec4 March(vec3 beg,vec3 dir) {\n    float dist = 0.;\n    vec3 pos;\n    #define LIMIT 100\n    for ( int stps = 0; stps <= LIMIT; ++stps ) {\n        pos = beg + dir * dist;\n        vec2 obj = Dist( pos );\n        dist += obj.x;\n        if ( obj.x < .001 || stps == LIMIT ) return vec4( pos, obj.y );\n    }\n    return vec4( pos, 90. );\n}\n\nvec3 Normal(vec3 pt) {\n    float delta = .001; // large delta gives rounded corners\n    vec3 norm = Dist(pt).x - vec3(\n        Dist(pt-vec3(delta, 0., 0.)).x, \n        Dist(pt-vec3( 0.,delta, 0.)).x, \n        Dist(pt-vec3( 0., 0.,delta)).x );\n    return normalize( norm );\n}\n\nfloat pow2n(float i,int n)\n{\n  while ( n-- > 0 ) i *= i;\n  return i;\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = (U+U-R) / min(R.x,R.y);  // -1 ... +1\n    uv /= 5.;\n    \n    vec3 cam = vec3( 0, 0, -64.);\n    vec3 camdir = normalize( vec3( uv, 1. ) );\n    \n    vec4 hit = March( cam, camdir );\n    vec3 norm = Normal(hit.xyz);\n    \n    vec3 light = vec3( 0, 10, -10 );\n    vec3 dir = normalize( light - hit.xyz );\n    float difu = dot( norm, dir );\n    \n    difu = .5 + .5*difu;\n    \n    #define col4(X) ( .5 + .3 * sin( vec4(0,21,23,0) + (X) ) )\n    O = sqrt( col4(hit.w*.4) );\n    O *= difu + pow2n(difu,9);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XcKBWc","date":"1734532614","viewed":93,"name":"Petite Platonic Polyhedra","username":"dray","description":"Find some almost 1 line SDF representations.\nAt this size, surely not perfect (exact).\n","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["polyhedra","platonic","golf"],"hasliked":0,"parentid":"","parentname":""}}