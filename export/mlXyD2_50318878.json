{"ver":"0.1","info":{"id":"mlXyD2","date":"1691189646","viewed":253,"name":"dessert...","username":"Swifter","description":"mmmm Dessert","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["lensflare","skybox","desert"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI2 6.28318530718\nconst vec3 UP = vec3(0, 1, 0);\nconst vec3 WHITE = vec3(1, 1, 1);\n\nconst float CAMERA_BACKWARD = 10.;\nconst float CAMERA_UPWARD = 7.;\nconst float PROJECTION_DIST = 0.6;\n\nconst float MAX_DIST = 300.;\n\nconst float SUN_THRESHOLD = 1. - (3. / 1800.);\nconst vec3 SUN_DIRECTION = normalize(vec3(3,0.05,1));\n\nconst vec3 RINGS_NORMAL = normalize(vec3(4,1,1));\nconst vec3 RINGS_POS = vec3(1000,0,0);\n\nfloat saturate(float x) {\n    return clamp(x, 0., 1.);\n}\n\nvec3 saturate(vec3 x) {\n    return clamp(x, 0., 1.);\n}\n\nfloat random(vec2 st, int seed) {\n    return fract(sin(dot((st.xy + float(seed)),\n        vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat getCornerDot(vec2 corner, vec2 pixel, int seed) {\n    float angle = PI2 * random(corner, seed);\n    vec2 vec = vec2(cos(angle), sin(angle));\n    return dot(vec, pixel - corner) * 0.5 + 0.5;\n}\n\nfloat noise2D(vec2 pixel, int seed) {\n    vec2 bottomLeft = vec2(floor(pixel));\n    vec2 topRight = vec2(ceil(pixel));\n    vec2 topLeft = vec2(bottomLeft.x, topRight.y);\n    vec2 bottomRight = vec2(topRight.x, bottomLeft.y);\n    \n    vec2 offset = smoothstep(0., 1., fract(pixel));\n    \n    float bottomLeftDot = getCornerDot(bottomLeft, pixel, seed);\n    float bottomRightDot = getCornerDot(bottomRight, pixel, seed);\n    float topLeftDot = getCornerDot(topLeft, pixel, seed);\n    float topRightDot = getCornerDot(topRight, pixel, seed);\n    \n    float top = mix(topLeftDot, topRightDot, offset.x);\n    float bottom = mix(bottomLeftDot, bottomRightDot, offset.x);\n    float middle = mix(bottom, top, offset.y);\n    \n    return middle;\n}\n\nfloat voronoi2D(vec2 grid, int seed) {\n    vec2 centerPos = floor(grid);\n    float minDist = 1.;\n    \n    for (int x = 0; x <= 2; x++) {\n        for (int y = 0; y <= 2; y++) {\n            vec2 gridPos = centerPos + vec2(x, y);\n            float randX = random(gridPos, seed);\n            float randY = random(gridPos, seed + 1);\n            vec2 randOffset = vec2(randX, randY);\n            float dist = length(grid - gridPos + randOffset);\n            \n            if (dist < minDist) {\n                minDist = dist;\n            }\n        }\n    }\n    \n    return minDist;\n}\n\nfloat smax0(float a, float b, float k)\n{\n    return log(exp(k * a) + exp(k * b)) / k;\n}\n\nfloat map( in vec3 pos )\n{\n    return pos.y\n    - noise2D(pos.xz, 0) * 0.1\n    - smax0(voronoi2D(pos.xz * vec2(0.2, 0.1) * 1.6, 2), 0.5, 6.)\n    // - voronoi2D(pos.xz * 0.06, 2) * 4.\n    - pow(noise2D(pos.xz * 0.02, 7), 1.) * 40.\n    + 25.\n    - noise2D(pos.xz * 0.07 + WHITE.xy, 3) * 10.\n    - pow(noise2D(pos.xz * 0.34 + WHITE.xy, 3), 6.) * 1.\n    - noise2D(pos.xz * 0.01, 10) * 40. + 20.\n    - noise2D(pos.xz * 0.0004, 12) * 40. + 15.\n    + 8.8;\n}\n\nconst float MAP_PRECISION = 0.001;\nconst float CLOUD_PRECISION = 0.05;\n\nvec3 calcMapNormal(in vec3 pos, in float height)\n{\n    float heightX = height - map(pos + vec3(MAP_PRECISION,0,0));\n    float heightZ = height - map(pos + vec3(0,0,MAP_PRECISION));\n    vec3 slopeX = normalize(vec3(MAP_PRECISION, heightX, 0));\n    vec3 slopeZ = normalize(vec3(0, heightZ, MAP_PRECISION));\n    return cross(slopeZ, slopeX);\n}\n\nfloat getCloudColor(in vec2 pos) {\n        float cloudOffset = iTime * 0.4;\n        return noise2D(pos * vec2(0.4, 0.2) + cloudOffset, 2)\n        + noise2D(pos / 0.6 + cloudOffset, 2) * 0.1;\n}\n\nvec3 calcCloudNormal(in vec2 pos, in float height)\n{\n    float heightX = height - getCloudColor(pos + vec2(CLOUD_PRECISION,0));\n    float heightZ = height - getCloudColor(pos + vec2(0,CLOUD_PRECISION));\n    vec3 slopeX = normalize(vec3(CLOUD_PRECISION, heightX, 0));\n    vec3 slopeZ = normalize(vec3(0, heightZ, CLOUD_PRECISION));\n    return cross(slopeZ, slopeX);\n}\n\nvec3 intersectLinePlane(vec3 linePoint, vec3 lineVec, vec3 planePoint, vec3 planeNormal) {\n    float t = dot(planeNormal, (planePoint - linePoint)) / dot(planeNormal, lineVec);\n    return linePoint + t * lineVec;\n}\n\nfloat project(vec3 a, vec3 b) {\n    return dot(a, b) / length(b);\n}\n\nvec2 worldToScreen(in vec3 pos, in vec3 camPos, in vec3 forward, in vec3 localX) {\n    vec3 camToPos = camPos - pos;\n    vec3 planeMidPoint = forward * PROJECTION_DIST + camPos;\n    \n    vec3 intersection = intersectLinePlane(\n        camPos,\n        camToPos,\n        planeMidPoint,\n        forward\n    );\n    \n    vec3 planeToIntersection = planeMidPoint - intersection;\n    \n    float yPos = intersection.y - camPos.y;\n    float xPos = -project(planeToIntersection, localX) * iResolution.y / iResolution.x;\n    \n    return vec2(xPos, yPos) + 0.5;\n}\n\nvec2 toSquareUV(in vec2 uv) {\n    float aspect = iResolution.x / iResolution.y;\n    return uv * vec2(1. * aspect, 1) + vec2(-(aspect - 1.) / 2., 0);\n}\n\nconst float SKY_HEIGHT = 5.;\n\nvec3 drawCircle(vec2 circlePos, vec2 pixelPos, float radius, float falloff, vec3 color) {\n    float dist = length(circlePos - pixelPos) / radius;\n    \n    if (dist > 1.) {\n        dist = pow(2. - dist, 3.);\n        \n        if (dist < 0.) {\n            return vec3(0,0,0);\n        }\n    }\n    \n    float colorMul = (dist - falloff) / (dist + 1.);\n    vec3 col = color;\n    col *= colorMul;\n    col = saturate(col);\n    \n    return col;\n}\n\nvec3 lensCircle(float position, float radius, float brightness, float falloff, vec2 pixelPos, vec2 sunScreen) {\n    vec2 sunToCenter = sunScreen - 0.5;\n    vec2 circlePos = pixelPos + sunToCenter * position;\n    vec2 pixelToCircle = sunScreen - circlePos;\n    \n    float toSunDot = dot(normalize(pixelToCircle), -normalize(sunToCenter)) * 0.5 + 0.5;\n    \n    brightness *= pow(toSunDot, 3.) * 0.9 + 0.1;\n    brightness *= length(sunToCenter);\n    brightness *= 5.;\n    \n    vec3 col = mix(vec3(0.3,0.3,1.), vec3(1.,1.,0.6), brightness) * brightness;\n\n    return drawCircle(sunScreen, circlePos, radius / 10., falloff, col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Construct coordinate space\n    float worldRot = PI2 * 0.15;\n    \n    if (iMouse.z > 0.) {\n        worldRot = PI2 * iMouse.x / iResolution.x + PI2 * 0.65;\n    }\n    \n    vec3 forward = vec3(cos(worldRot), 0, sin(worldRot));\n    vec3 localX = vec3(sin(worldRot), 0, -cos(worldRot));\n    \n    // Get ray direction\n    vec3 camPos = -forward * CAMERA_BACKWARD + UP * CAMERA_UPWARD;\n    float aspect = iResolution.x / iResolution.y;\n    vec3 rayForward = normalize(\n        localX * (uv.x - 0.5) * aspect +\n        UP * (uv.y - 0.5) +\n        forward * PROJECTION_DIST\n    );\n    \n    // Sky Color\n    float skyDot = dot(UP, rayForward) * 0.5 + 0.5;\n    float sunDot = dot(SUN_DIRECTION, rayForward) * 0.5 + 0.5;\n    vec3 skyCol = mix(vec3(1,0.6,0),vec3(0.3,0.3,1), skyDot);\n    vec3 sunCol = vec3(0.5,0.3,0);\n    vec3 col = skyCol + sunCol * pow(sunDot, 2.) * 1.5;\n    \n    // Travel ray\n    float totalDist = 0.;\n    vec3 currentPos = camPos;\n    \n    for (int i = 0; i < 700 && totalDist < MAX_DIST; i++) {\n        float sdf = map(currentPos);\n      \n        if (sdf < 0.01) {\n            vec3 normal = calcMapNormal(currentPos, sdf);\n            float dotWithSun = dot(normal, SUN_DIRECTION);\n            float brightness = mix(0.3, 0.6, dotWithSun);\n            \n            float distMul = pow(totalDist / MAX_DIST, 5.);\n            float noise = pow(noise2D(currentPos.xz * 10., 1), 0.1) * 0.5 +\n            pow(noise2D(currentPos.xz * 20., 1), 0.1) * 0.5;\n            \n            float colorRegion = noise2D(currentPos.xz * 0.1, 1) * noise2D(currentPos.xz * 0.01, 1);\n            vec3 yellow = mix(vec3(1,1,0.8), vec3(0.87,0.62,0.27), colorRegion);\n            \n            vec3 grainCol = noise * yellow;\n            vec3 sandCol = brightness * grainCol + sunCol * saturate(dotWithSun);\n            col = mix(sandCol, col, distMul);\n            break;\n        }\n        \n        currentPos += rayForward * sdf;\n        totalDist += sdf;\n    }\n    \n\n    bool hitSky = totalDist >= MAX_DIST;\n    vec3 sunPos = SUN_DIRECTION * 3000.;\n    \n    if (hitSky) {\n        // Clouds\n        float distToCeiling = (SKY_HEIGHT - camPos.y) / (rayForward.y + 0.00001);\n        vec3 cloudPos = rayForward * distToCeiling;\n        float dist = saturate(1. - (length(cloudPos - camPos) / MAX_DIST));\n        \n        float noiseVal = getCloudColor(cloudPos.xz);\n        vec3 cloudNormal = calcCloudNormal(cloudPos.xz, noiseVal);\n            \n        col += WHITE * noiseVal * dist * 0.2;\n        col += sunCol * saturate(dot(-cloudNormal, normalize(cloudPos - sunPos))) * dist;\n    \n        if (sunDot > SUN_THRESHOLD) {\n            float strength = 1. - ((1. - sunDot) / (1. - SUN_THRESHOLD));\n            strength *= strength;\n            col += WHITE * strength;\n        }\n        \n        // Rings\n        vec3 ringPos = intersectLinePlane(camPos, rayForward, RINGS_POS, RINGS_NORMAL);\n        float ringDist = length(RINGS_POS - ringPos);\n        float brightness = saturate(sin(ringDist / 150.) + sin(ringDist / 300.)  + sin(ringDist / 20.) + sin(ringDist / 50.) + sin(ringDist / 1000.));\n        brightness = brightness * saturate(sin(ringDist / 1500.)) * 0.6 + brightness * 0.4;\n        brightness *= saturate(1. - abs(9300. - ringDist) / 8000.);\n        // brightness = saturate(brightness);\n        brightness *= saturate(ringPos.y / 3000.);\n        \n        col += WHITE * brightness * 0.4;\n    }\n\n    // Lens flare\n    vec2 sunScreen = worldToScreen(sunPos, WHITE * 0., forward, localX);\n    float sunDotCamera = dot(forward, SUN_DIRECTION);\n    bool sunOnScreen =\n        sunScreen.x > -0.1 &&\n        sunScreen.y > -0.1 &&\n        sunScreen.x < 1.1 &&\n        sunScreen.y < 1.1 &&\n        sunDotCamera > 0.;\n        \n    float flicker = saturate((noise2D(vec2(iTime * 67., 0.), 2) - 0.2) * 2.5);\n    \n    if (sunOnScreen) {\n        col += sunCol * (pow(sunDot, 200.)) * 0.2 * flicker;\n        \n        if (!hitSky) {\n            col += sunCol * (pow(sunDot, 10.)) * 0.7;\n        }\n        else {\n            flicker = saturate((flicker - 0.5) * 3.);\n        }\n    \n        sunScreen = toSquareUV(sunScreen);\n        vec2 pixelPos = toSquareUV(uv);\n        vec2 pixelToSun = pixelPos - sunScreen;\n        vec2 sunToCenter = sunScreen - 0.5;\n        vec2 streakCompress = vec2(1,7) * 9.;\n        float sizeMul = 1. + (1. - sunDotCamera) * 2.;\n        \n        vec3 lensCol =\n        \n        (saturate(1.0 - WHITE * length(pixelToSun * streakCompress / sizeMul)) * 1.\n        + saturate(1.0 - WHITE * length(pixelToSun * streakCompress.yx / sizeMul)) * 1.\n        \n        + saturate(1.0 - WHITE * length(pixelToSun * streakCompress * vec2(0.5, 2) / sizeMul)) * 0.7\n        + saturate(1.0 - WHITE * length(pixelToSun * streakCompress.yx * vec2(2, 0.5) / sizeMul)) * 0.75)\n        \n        * flicker;\n      \n        \n        for (int i = 0; i < 30; i++) {\n            float pos = random(vec2(i, 0), 1) * 1.5;\n            float radius = random(vec2(0, i), 1) * 0.3 * (2. - pos);\n            float brightness = random(vec2(i, 0), 2) * (1.5 - pos) * 0.15 * (flicker + 1.5);\n            float falloff = random(vec2(0, i), 2);\n            lensCol += lensCircle(pos, radius, brightness, falloff, pixelPos, sunScreen);\n        }\n        \n        if (hitSky) {\n            lensCol += lensCircle(0., 1.9, 0.9, 0.8, pixelPos, sunScreen);\n        }\n\n        lensCol += lensCircle(0., 1.2, 0.8, 0.8, pixelPos, sunScreen);\n        lensCol += lensCircle(0., 0.7, 0.5, 0.2, pixelPos, sunScreen);\n\n        \n        col += lensCol * (flicker * 0.4 + 0.6);\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}