{"ver":"0.1","info":{"id":"3t2yRG","date":"1621204149","viewed":132,"name":"Steel Heart ReflectionðŸ–¤ðŸ¤–ðŸ¤”","username":"rmmcal","description":"Trying photorealism \n(...experiments...)","likes":10,"published":1,"flags":96,"usePreview":0,"tags":["photorealism"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////////////////////////////////////////\n/////    ....Steel Heart ReflectionðŸ–¤ðŸ¤–ðŸ¤”....    ////////// \n/////////////////////////////////////////////////////////////\n// ------------------------------------------------------- //\n// Brasil/Amazonas/Manaus                                  //                                       \n// Trying photorealism                                     //\n// Created by Rodrigo Cal (twitter: @rmmcal) - 2020-2021   //\n// - https://www.shadertoy.com/view/3t2yRG                 // \n// ------------------------------------------------------- //\n/////////////////////////////////////////////////////////////\n\n/**\n ðŸ–¤ðŸ¤–ðŸ¤” ðŸŽ¨ðŸŽ¹â™Ÿ\n*/\n\nfloat box2d(vec2 p, vec2 t, vec2 s) { \n    return length(max(abs(p-t)-s,0.0)); \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 r = iResolution.xy;\n    vec2 uv = fragCoord / r ;\n    \n    vec2 pt = uv;\n    vec2 ar = vec2(1., iResolution.y/iResolution.x);\n    vec2 p = uv*ar;\n    p = (uv-.5)*ar;\n\n    vec3 c = vec3(1.0);\n    float t = abs(fract(iTime*.1)*2.-1.)*2.-1.;\n    \n    float t1 = clamp((iTime-10.)*.1,0.,1.);\n  \n    pt += t1 * vec2(  cos(  cos(uv.x*5.1+iTime)*5.95 + cos(uv.x*5.1+iTime*2.)*5.01+ cos(uv.y*2.1+iTime*3.)*5.01 ) )*.002 ;\n    \n    vec4 fc = texture(iChannel1,pt);\n    if ( ( uv.x*uv.y < pow(t, 4.)*0.) )\n        fc = texture(iChannel0,pt);\n    \n    \n    \n    \n    float gt = clamp(iTime*0.05, 0., 1.) ;\n    float gf = clamp(gt*25., 0., 25.) ;\n    vec2 pg = uv * gf * ar  ;\n    float aa = .3;\n    float gd = smoothstep(0., aa,abs(mod(pg.x,1.)-.5)) * smoothstep(0.,aa,abs(mod(pg.y,1.)-.5));\n\n    float tf = fract(t)*2.;\n    //float t2 = pow(clamp(1.-t,0.,1.),16.);\n    //float t2 = 1.;\n    \n    \n    float s = (2. * pow(gf+.1,2.) *1.);\n   \tvec2 uvt = uv * s ;\n    vec2 uvs = vec2(ivec2(uvt*2.+.5));\n   \n  \n    vec2 pto = pt*((s)/1250.00);\n    fc = texture(iChannel2,pto);\n    \n    float constractDiv=0.5;\n    float constract=clamp(iTime*.02, 0.,.8)+1.;\n    fc *= 4.5;\n    fc=(fc-constractDiv)*constract+constractDiv;\n    fc /= 4.5;\n    \n    if (iTime > 100.0)\n    {\n       // float p = 122.*pow(fract(iTime*.1),4.);\n        \n     //   fc = fc*(5.+p) / (fc+5.+p);\n     //   fc = vec4( 1.-pow(1.-clamp(fc.x, 0., 1.),2.));\n     //   fc = vec4( pow(clamp(fc.x, 0., 1.),2.));\n     //   float ft1 =  0.;\n     //   vec4 fct = clamp(fc+ft1,.0,1.); \n        vec4 fco =fc;\n        //fc = (fct*fct-ft1 -   pow(clamp(fc.x, 0., 1.),2.)*.9)*10.;\n        fc =  ( fc*fc - fc*fc*.9)*10. ;//.7*clamp(fc,0.2,0.2)/( clamp(fc,0.2,.3))\n        fc =  mix( fc,fco, 0.5) ;//.7*clamp(fc,0.2,0.2)/( clamp(fc,0.2,.3))\n      //  fct = clamp(fc+.5,.0,52.); \n      //  fc = fct*fct-.5;\n        \n    }\n  \tif (iTime > 30.0 && iTime < 2290.0)\n    {\n        float tg =   abs(fract(iTime*.04)*2.-1.)*2.-1.; ;\n        fc =  mix(fc,texture(iChannel1,pto), step(uv.x,pow(abs(fract(iTime*.05)*2.-1.),1.)));\n        \n     \n        \n        fc =  mix(fc, vec4(1.), smoothstep(0.,.002, .002-abs(uv.x-pow(abs(fract(iTime*.05)*2.-1.),1.))));\n        fc +=  mix(vec4(0.), vec4(0.2,0.,.6,0.), smoothstep(0.,.005, .005-abs(uv.x-pow(abs(fract(iTime*.05)*2.-1.),1.))));\n     \n      \n        float div = (uv.x*uv.y +.001-pow(clamp(tg,0.,1.), 20.) );\n        if ( ( uv.x*uv.y < pow(tg, 20.)*1.) && iTime > 60.5){\n            fc = mix(fc, texture(iChannel0,pto), 1.);\n            fc =  mix(fc, vec4(1.), smoothstep(0.0,.001, .001- abs(div)));\n\t\t}\n    }\n    \n    vec3 bg = vec3(fc.rgb);\n\n  \n\tc = mix(c, bg, (1.- smoothstep(0.1, .2, (.5-gd))));\n\n    /**/\n    c = mix(c, vec3(1.), ( smoothstep(0.7, 1.1, (1. -gd*2.))));\n    //  c = mix(c, vec3(1.,  cos(uvt*.01+(iTime)*3.))  ,     \t( smoothstep(0.7, 1.1, (1. -gd*2.)) )        );\n    //  c = mix(c, vec3(cos(uvt*.05-iTime*2.),1.),  (1.0 - smoothstep(0.1, .2, abs(.2-gd))));\n    //  c = mix(c, vec3(cos(uvt*.005-iTime*2.),1.), smoothstep(0.5, 1., 1.-abs(0.5- abs(1.0 - smoothstep(0.0, .2, abs(.2-gd))))));\n\t/**/\n    \t\n\n    //c = mix(c, vec3(1.,0.,0.)  ,  smoothstep(-0.1, .01, 1.-abs(.01-abs(1.0-abs(1.-( smoothstep(0., 1., (1. -gd*2.)) )))     ))   );\n\tc = mix(c, vec3(0.,0.,0.)  , (1.-smoothstep(0., .1, abs(0.6-abs(1. - gd)))      )   );\n\tc = mix(c, vec3(0.,0.,0.)  , (1.-smoothstep(0., .1, abs(0.9-abs(1. - gd)))      )   );\n\t// c = mix(c, vec3(1.,0.,0.)  , (smoothstep(0., 1., (abs(1. - gd)))      )   );\n\n    // c+=(cos( iTime + cos(iTime +uv.x*9234.6543) + cos(uv.y*1731.4563) )*0.01)*11.2;\n    \n     \n  \n    c = mix(c, vec3(c+(cos( iTime + (uv.x+iTime)*234.6543 + uv.y*731.4563 )*0.01)*13.), ( smoothstep(0.0, .5, (1. -gd*2.))));\n \tc = mix(c, fc.xyz, gt);\n\n   // c = bg;\n    \n   //  c = col;\n   //  c =  texture(iChannel3,uv).rgb;\n   //  c =  mix(c + texture(iChannel2,uv).rgb*.5;\n   //  c =  texture(iChannel2,uv).rgb;\n   //  c =  texture(iChannel1,uv).rgb;\n   //  c =  texture(iChannel0,uv).rgb;\n\n \n    float barWidth = 0.4;\n    float pBarWidth = 0.4;\n    float showBar = 1.0-clamp((iTime-200.0)/5.,0.,1.);\n    \n    float pbar = clamp(iTime/200.,0.,1.);\n    float bar  = showBar * smoothstep(-0.010,-0.009, -box2d(p,vec2(0.0,-0.25),vec2(pBarWidth,0.0)));\n    float bar2 = showBar * smoothstep(-0.009,-0.006, -box2d(p,vec2(0.0+pBarWidth*pbar-pBarWidth,-0.25),vec2(pBarWidth*pbar,0.0)));\n    float bar3 = showBar * smoothstep(-0.05,0.02, -box2d(p,vec2(0.0+pBarWidth*pbar-pBarWidth,-0.25),vec2(pBarWidth*pbar,0.0)));\n    \n    c = mix(c, vec3(1.), bar   );\n    c = mix(c, vec3(1.), bar3   );\n    c = mix(c, vec3(.5-.08*cos(p.x*80.+p.y*80.-iTime*2.)), bar2   );\n   \n    fragColor = vec4(c,1.);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\n\nfloat length2( vec3 p ) { p=p*p; return sqrt( p.x+p.y+p.z); }\n\nfloat length6( vec3 p ) { p=p*p*p; p=p*p; return pow(p.x+p.y+p.z,1.0/6.0); }\n\nfloat length8( vec3 p ) { p=p*p; p=p*p; p=p*p; return pow(p.x+p.y+p.z,1.0/8.0); }\n\n\n\n\n\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\n\n\n\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n//-----------------------------------------------------------------------------\n// Maths utils\n//-----------------------------------------------------------------------------\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n  \n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n//////////////////////////////////////////","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MlBGRt","filepath":"https://soundcloud.com/host7/cold-jorge-mendez-sad-piano-violin-instrumental","previewfilepath":"https://soundcloud.com/host7/cold-jorge-mendez-sad-piano-violin-instrumental","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nint modi(int a, int n){\n\treturn a - (n * int(a/n));\n}\n\n\nfloat rand(vec2 v){\n    return sin(\n        \t\tfract(sin(v.x+v.y*v.y + fract(iTime)  )*758.5453\n    \n                     )*1758.5453)*2.;\n    \n}\n\nvec3 randv3(vec2 v){\n    v += +fract(iTime) * 2. + 11.;\n    return vec3(rand(v),rand(v*3.3357+.774),rand(v*2.7757+.274));\n    \n}\n\n\n\nfloat box(vec3 p, vec3 t, vec3 s) { \n    return length(max(abs(p-t)-s,0.0)); \n}\n\nvoid rotate(inout vec2 v, float angle){\n    float c = cos(angle); \n    float s = sin(angle); \n    \n    v = mat2(c, -s, s, c) * v;\n}\n\n\n\n\nstruct Shape{\n\tfloat dis;\n    int id;       \t\t \n};\n\nstruct Ray{\n    Shape hit;// hit\n    vec3 p;   // pos\n    float d;  // distance\n    float v;  // volumetric\n    float gr; // goodness-of-light / goodness ray\n    float l;\n};\n vec3 ligp;\n \n\nvoid add(inout Shape h1, Shape h2){    \n    if (h1.dis > h2.dis) h1 = h2;\n}\n\n\n\nvoid addSmooth(inout Shape h1, Shape h2, float f ) {\n    float d = opSmoothUnion( h1.dis, h2.dis, f );\n    h1 = Shape(d, (d<.5) ? h1.id : h2.id );\n}\n\nvoid subSmooth( inout Shape h1, Shape h2, float f ) {\n    float d = opSmoothSubtraction( h2.dis, h1.dis, f );\n    h1 = Shape(d, (d>.5) ? h2.id : h1.id );\n}\n\nShape sphere( vec3 p, vec3 t, float s, int id) {\n    return Shape(length(p-t)-s, id);\n}\n\n\n#define rot(a) mat2(cos(a), sin(a),-sin(a),cos(a))\n    \nfloat mapTexture(in vec3 p)\n{\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=1.; i<=3.; i++ )\n\t{\n        vec3 dg = cos(bp*i);\n        p += (dg*cos(i*i+i));\n        p.xz*= rot(12.0 +i);\n        p.yz*= rot(3.0 +i);\n        rz+= cos((p.z+(p.x-cos(p.y))) +0.1)/(i+1.) ;\n        p *= 1.2;\n        bp *= i*1.1;\n        bp += i*10.;\n        bp+=0.01;\n\t}\n\treturn sin(rz*20.);\n}\nvec3 bump(in vec3 p, in vec3 n, in float ds)\n{\n    vec2 e = vec2(.005,0);\n    float n0 = mapTexture(p);\n    vec3 d = vec3(mapTexture(p+e.xyy)-n0, mapTexture(p+e.yxy)-n0, mapTexture(p+e.yyx)-n0)/e.x;\n    n = normalize(n-d*2.5/sqrt(ds));\n    return n;\n}\n\nbool renderLight;\nShape sceneMap(vec3 p){\n    Shape d = Shape(1000., 0);\n    \n   // p.x = abs(p.x);\n    \n    //float t = iTime*0.; \n    //rotate(p.xz,t*.2);\n\n \t// floor  \n    add(d, Shape(p.y+2., 1)); \n    \n    // wall\n    float w = cos(fract(p.x*.2)+fract(p.y*.2)+fract(p.z*.2))*0.8;//fbm(p)*1.;\n    add(d, Shape(abs(abs(p.x)-22.)-1.-w, 3)); \n    add(d, Shape(abs(abs(p.z)-22.)-1.-w, 3)); \n    \n    // ceiling\n\t// add(d, Shape(abs(abs(p.y)-22.)-1., 3)); \n    \n    // black\n    add(d, sphere( p, vec3(-1.5,0.,0.), 2., 0 ) ); \n    add(d, sphere( p, vec3( 1.5,0.,0.), 2., 1 )); \n    addSmooth(d, sphere(p, vec3( .0,1.,0.), 2., 0 ),.5); \n    \n    // blue\n    add(d, sphere(p,vec3( 6.5,0.,0.),2., 6)); \n\n    // red\n    float mt = mapTexture(p)*0.01;\n    float f = 0.;//fbm(p);\n    add(d, Shape( box(p,vec3(-6.5, 2.,0), vec3(.5,1.0,0.5) )- f -mt, 8 )); \n    add(d, Shape( box(p,vec3(-6.5, -0.5,0), vec3(.5,.5,0.5)) -1.- f-mt, 8 ));\n\n    \n    \n    \n    \n    //addSmooth(d, Shape( box(p,vec3(-5., -0.5,0), vec3(.5,.5,0.5)) -1., 8 ), .5);\n\n    //d = subSmooth(d, sphere( p, vec3( 1.5 +fract(iTime*.2)*2.-1.,0.,-2.), 1., 1 ),.5); \n    subSmooth(d, sphere( p, vec3(  1.5, 0., -2.), 1., 1 ),.5); \n    subSmooth(d, sphere( p, vec3( -1.5, 0., -2.), 1., 1 ),.5); \n\n    \n    \n    //d.dis = opSmoothSubtraction(length(p-vec3( 1.5+fract(iTime*.2)*2.-1.,1.,-1.))-2., d.dis,  .1);\n        \n        \n        \n    if (renderLight)\n         add(d, Shape(length(p-ligp) - 1.,10)); \n   // d.id = 10;\n    \n\t//d.dis += - fbm(p*1.+iTime*.1)*1.;\n    return d ;\n    \n}\n\n\nfloat sceneSDF(vec3 p){\n    return sceneMap(p).dis;\n}\n\n\n\nvec3 close3d(vec4 p4, vec3 n){ \n    vec2 f = vec2(1.,0.);\n    vec3 d = normalize(n);\n    vec3 p = p4.xyz;\n\tfloat dx = sceneSDF(p - d * f.xyx) ;\n\tfloat dy = sceneSDF(p - d * f.yxx) ;\n\tfloat dz = sceneSDF(p - d * f.yyx) ;\n\treturn (vec3(dx, dy, dz)) * (p4.w > 100. ? 0.:1.) ;\n}\n\nvec2 hash22(vec2 p) {\n    p = p*mat2(127.1,311.7,269.5,183.3);\n\tp = -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n\treturn sin(p*6.283);\n}\nvec3 normal3d(vec3 p)\n{\n   \n  vec3 eps = vec3(.001,0.0,0.0);\n  vec3 nor;\n  float ref;\n  nor.x = sceneSDF(p+eps.xyy) - sceneSDF(p-eps.xyy);\n  nor.y = sceneSDF(p+eps.yxy) - sceneSDF(p-eps.yxy);\n  nor.z = sceneSDF(p+eps.yyx) - sceneSDF(p-eps.yyx);\n  return -normalize(nor);\n}\n\nRay raymarching(vec3 p, vec3 d, int nbSample){\n    Ray ray;\n    vec3 ps = p;\n    \n    \n    //d = normalize(d);\n \n    ray.v = 0.;\n    float depth = 0.;\n    float energy    = 1.;\n    float absorption   = float(nbSample*0)+1.;\n    \n    for (int i = 0; i < nbSample; i++)\n    {\n        Shape march = sceneMap(p);\n       \n        if (march.dis <   0.01) {depth=0.01; ray.hit = march; break;}//break;\n        if (march.dis > 128.00) {depth=128.; break;}//break;//{depth=0.; break;}\n        \n        if(depth>0.)\n\t\t{\n            if (march.id == 10){\n         \t\tray.l += 1./march.dis;\n            }\n            \n\t\t\tfloat density  = depth / float(nbSample);\n\t\t\tenergy *= 1. -density*.1 ;\n\t\t\tif( energy > 0.01)\n\t\t\t\tray.v += 25.*density*energy ;\n            \n            /**\n            vec3 vo = p ; // volum fog\n            vec3 vd = ( normalize(p-ligp)) ; // volum fog\n            float gr = 0.;// god ray\n            for (int i = 0; i < 16; i++)\n    \t\t{\n\t\t        Shape march2 = sceneMap(vo);\n                if (march2.dis <   0.01)\n                    break;\n                gr += march2.dis;\n                vo += vd * march2.dis; \n            }\n           // ray.gr = max( ray.gr, distance(vo,p) ) ;// gr\n            ray.gr += distance(vo,p)*.1 ;// gr\n\t\t   // ray.gr += p;// gr\n\t\t     //ray.gr  = clamp( ray.gr, 0., 16.); //gr;\n\t\t\t/**/\n\n\t\t}\n        \n        depth += march.dis;\n    \tp     += march.dis * d;\n    }\n    \n    ray.d = distance(ps, p);\n    //ray.depth = depth;\n    ray.p = p;\n    \n    \n    return ray;\n}\n\nRay raymarching(vec3 p, vec3 d){\n\treturn raymarching(p,d,64);\n}\n\nRay raymarchingLow(vec3 p, vec3 d){\n\treturn raymarching(p,d,32);\n}\n\n//float radiosity = 0.;\nfloat diffuse ;\nfloat diffuseShadown ;\nfloat diffuseReflection ;\nfloat diffuseDirection ;\n\n\nvec3 render(vec2 uv, vec3 cameraPos, vec3 cdir){\n\tvec4 r;\n\n    vec3 cameraDirection = cdir ;//+ randv3(uv)*diffuseDirection;\n    vec3 lightPos  = ligp;\n    renderLight= true;\n    const float len = 4.;\n    float transmission = 1.0;\n   \tfor (float i = 1.; i <= len; i++)\n    {\n        vec3 col;\n        Ray ray\t  = raymarchingLow(  cameraPos,  cameraDirection);\n        \n        float tColor = clamp(iTime-20.0,0.,1.); \n        if (ray.hit.id == 10){\n            //col += vec3(100.);//*pow(angNormalCam,4.0);\n        }  \n        else if (ray.hit.id == 6){\n            col += vec3(0.,0.,6.)*tColor;\n          \tdiffuse = 0.0;\n        }\n        else if (ray.hit.id == 8){\n            float mt = clamp(mapTexture(ray.p),0.6,1.);\n           \tvec3 bu = bump(ray.p,  normal3d(ray.p), 1.);\n            \n            col += vec3(6.,0.,0.)*tColor*mt;\n            \n            \n          \tdiffuse = 0.5;\n            \n            //transmission *= 0.5;\n            //r *= transmission;\n        }\n       //  else if (ray.hit.id == 1){\n       //     float mt = clamp(mapTexture(ray.p),0.6,1.);\n       //    \tvec3 bu = bump(ray.p,  normal3d(ray.p*2.), 1.);\n       //     col += vec3(1.)*tColor*bu.z*2.;\n       // }\n        else {\n            diffuse = 1.0 ;//+step(uv.x, .5); //1.0 ;//+ fract(iTime*.1);        \n        }\n        \n\n        diffuseShadown \t= 0.05  * diffuse;\n        diffuseReflection = 0.02  * diffuse;\n        diffuseDirection \t= 0.001 * diffuse;\n        \n                   \n        float focus = 0.0;\n        float focusRange = 350.0; \n        cameraDirection = cameraDirection + randv3(uv)*(diffuseDirection + smoothstep(-0.,focusRange, abs(ray.p.z-focus))*.1);    \n        ray\t  = raymarching(  cameraPos,  cameraDirection);\n        \n        //Ray ray\t  = raymarching(  cameraPos,  cameraDirection);\n        \n        vec4 rayHit = vec4(ray.p, ray.d);\n        vec3 rayHitDirection \t    = normal3d(rayHit.xyz);\n\t\tvec3 rayHitReflectDirection = normalize(reflect(normalize(cdir), rayHitDirection)+ randv3(rayHit.xy+uv)*diffuseReflection    );\n\n        Ray\t rayL       = raymarching( rayHit.xyz -cdir  ,  normalize(lightPos-rayHit.xyz)  + randv3(rayHit.xy)*diffuseShadown);\n        vec4 rayHitToLight =  vec4(rayL.p, rayL.d);\n        vec3 rayHitToLightDirection = normal3d( rayHitToLight.xyz );\n\n        float distanceHitToLight       = distance(rayHit.xyz, lightPos.xyz ); \t\t// hit x ligth distance\n        float distanceHitToBlockLight  = distance(rayHit.xyz, rayHitToLight.xyz);  \t// hit x ligth blocked distance\n\n        float shadow = min(distanceHitToBlockLight, distanceHitToLight)/(distanceHitToLight);\n        shadow = min(distanceHitToBlockLight, 1000.)/(distanceHitToLight);\n        \n        //vec3 col;\n        \t\n       \n        vec3 dirHitToLight = normalize(rayHit.xyz-lightPos);\n        float angDirect  = dot( rayHitDirection.xyz    , dirHitToLight);\n        float angReflect = dot( rayHitReflectDirection , dirHitToLight);\n        \n        float angDirectAbs  \t= clamp( angDirect,0.,1.);\n        float angReflectAbs \t= clamp( angReflect,0.,1.);\n        \n        float diffuseReflect \t= 1. - angReflectAbs;\n        float diffuseDirect  \t=  angDirectAbs * 2. ;\n        float especularDirect   =  pow(  angDirectAbs, 64.) ;\n  \t\tfloat ambient =  shadow * .0;\n\n        shadow *= angDirectAbs*2.;\n        \n        col +=  (diffuseReflect + diffuseDirect )* shadow + ambient + especularDirect;\n      \n\n        //if (ray.hit.id == 10){\n        //\tfloat angNormalCam = dot(normalize(rayHitDirection.xyz), normalize(cameraDirection.xyz))/1.;\n        //    angNormalCam*=angNormalCam;\n        //    angNormalCam*=angNormalCam;\n        //    angNormalCam*=angNormalCam;\n        //    col += vec3(200.)*(angNormalCam);\n        //}\n        \n        if (ray.hit.id == 10){\n            float angNormalCam = dot(normalize(rayHitDirection.xyz), normalize(cameraDirection.xyz));\n            //col *= clamp(pow(clamp(angNormalCam,.0,1.),4.0), 0.1, 1.);\n            angNormalCam*=angNormalCam;\n            angNormalCam*=angNormalCam;\n            angNormalCam*=angNormalCam;\n            //col *= angNormalCam;\n            col += vec3(100.)*angNormalCam;\n        }\n        //col += vec3(ray.l);\n        \n     \t//col+= distanceHitToLight/40.;\n     \t//col+= ray.v/40.;\n        //    col+=  ray.v/ distanceHitToLight;\n        ///\tcol+= 1./10.;\n        \n        //col = col*0. + abs(1. - dot(-rayHitReflectDirection, normalize(lightPos-rayHit.xyz))) * shadow + ambient*2.;\n        //\tcol = col*0. + ray.v/10.;\n        \n       // col = col*0. + ray.v/10.;\n       //  col = col*1. + ray.v/100.;\n\t\tcol = col*1. + ray.gr/100.;\n\t\n       // col  =  col*1. + rayHitDirection.z*2. ;\n       //  col  =  col*0. ;\n       //  col +=  abs(diffuse) * shadow;\n  \n        /*\n        if (ray.hit.id == 0)\n        \tcol *= vec3(1.,0.,0.); \n        else if (ray.hit.id == 1)\n        \tcol *= vec3(1.,1.,0.); \n        else if (ray.hit.id == 2)\n        \tcol *= vec3(0.,1.,0.);\n        else if (ray.hit.id == 3)\n        \tcol *= vec3(0.,1.,1.); \n        else if (ray.hit.id == 4)\n        \tcol *= vec3(0.,0.,1.); \n        else if (ray.hit.id == 5)\n        \tcol *= vec3(1.,0.,1.); \n        else if (ray.hit.id == 6)\n        \tcol *= vec3(1.,1.,1.); \n\t\t**/\n        \n        col  = col*.8 + rayHitDirection.z*.2;\n        \n       // if ( length(col) < 0.9 )\n       //     break;\n            \n        r.rgb += col/(i+1.) * transmission;\n        \n        cameraPos = rayHit.xyz-cameraDirection;\n        cameraDirection = rayHitReflectDirection;\n        \n    }\n    \n    r = clamp(r,vec4(0.),vec4(100.));\n    return r.rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n   \n\n    \n    float time2 = 3.46*.5;//(iTime*.5);\n    vec2 aspectRatio = vec2(1., iResolution.y/iResolution.x);\n\tvec2 uv = fragCoord/iResolution.xy; \n    vec2 p = (uv-.5)*aspectRatio;\n\n    \n     //float radiosity = 0.;\n     //diffuse = 0.0 ;//+step(uv.x, .5); //1.0 ;//+ fract(iTime*.1);\n     //diffuseShadown \t= 0.05  * diffuse;\n\t //diffuseReflection = 0.02  * diffuse;\n\t //diffuseDirection \t= 0.001 * diffuse;\n    \n\n    float time3 = time2;//(3.46);\n//\ttime3=time2*.2;\n    \n    ligp = normalize(vec3(cos(time3)*5.,10.0 + sin(time3*9.)*10. ,sin(time3)*15.)) ;\n    ligp*=10.;\n    \n    \n    vec3 cpos = vec3(.0,.0,-21.);\n    \n    ligp = normalize(vec3(cos(time3)*5.,10.0 + sin(time3*4.)*10. ,sin(time3)*15.)) ;\n    ligp*=10.;\n    cpos = vec3(.0,.0,-11.);\n    \n    \n    \n    \n    vec3 cdir = vec3(p.xy*1.,1.);\n     cdir = vec3(sin(p.xy),0.5);\n  //  cdir.yz = rotate(cdir.yz,-time2);\n  //  cdir.yz = rotate(cdir.yz,.4);\n  \t rotate(cdir.yz,-.05);\n  \n    \n    mat4 m = mat4(1.,0.,0.,0.,\n                  0.,1.,0.,0.,\n                  0.,0.,1.,0.,\n                  0.,0.,0.,1.);\n    \n\n    vec3 col = render (uv, cpos, cdir);\n    \n    col = col / ( diffuse*5.+5.);\n//    col = col/(col-1.);\n    \n    //vec4 gloss = texture(iChannel1,fragCoord/iResolution.xy+randv3(uv).xy*51.);\n \t//col += (gloss.rgb/ col)/8.;; \n     \n    //vec3 cf = col.rgb;\n    //vec3 diff = (  gloss.rgb *1. + .5 * col.xyz );\n    //col +=  diff/2.;\n    \n        \n    fragColor = vec4(col, 1.0);\n    \n    \n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    vec4 front = texture(iChannel0,fragCoord/iResolution.xy);\n    vec4 back = texture(iChannel1,fragCoord/iResolution.xy);\n    vec3 cf = back.rgb;\n    vec3 diff = (  back.rgb *.9 + .1 * front.xyz - cf);\n    cf +=  diff/2.;\n    fragColor = vec4(cf, 1.0);\n\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec4 front = texture(iChannel1,fragCoord/iResolution.xy);\n    vec4 back = texture(iChannel2,fragCoord/iResolution.xy);\n    vec3 cf = back.rgb;\n    vec3 diff = (  back.rgb *.9 + .1 * front.xyz - cf);\n    cf +=  diff/100.;\n    \n    \n    vec2 uv = fragCoord/iResolution.xy;\n  \n    cf =  mix(cf, texture(iChannel1,uv).rgb*1., .001);\n    cf =  mix(cf, texture(iChannel3,uv).rgb*1., .01);\n    cf =  mix(cf, texture(iChannel2,uv).rgb*1., .01);\n   \n    if (iTime < 10.){\n        cf =  mix(cf, texture(iChannel1,uv).rgb*1., .01);\n        cf =  mix(cf, texture(iChannel3,uv).rgb*1., .01);\n    }\n    fragColor = vec4(cf, 1.0);\n\n   \n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\nfloat rand(vec2 v){\n    return sin(\n        \t\tfract(sin(v.x+v.y*v.y + fract(iTime)  )*758.5453\n                     )*1758.5453)*2.;\n    \n}\n\nvec3 randv3(vec2 v){\n    v += +fract(iTime) * 2. + 11.;\n    return vec3(rand(v),rand(v*3.3357+.774),rand(v*2.7757+.274));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv;\n    vec4 front = texture(iChannel2,p);\n    vec4 back = texture(iChannel3,p+normalize(randv3(uv)).xy*.005);\n    vec3 cf = back.rgb;\n    vec3 diff = ( front.xyz - cf);\n    cf +=  diff/100.+0.0;\n    fragColor = vec4(cf, 1.0);\n\n   \n}","name":"Buffer D","description":"","type":"buffer"}]}