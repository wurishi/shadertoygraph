{"ver":"0.1","info":{"id":"XltBzl","date":"1540656486","viewed":124,"name":"nomdemonshader","username":"gaetanls","description":"test to correlate sound with shaders","likes":2,"published":1,"flags":8,"usePreview":0,"tags":["sound","fractals"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Explanations of \"Code Golf Fractal 120 Characters\"\n// https://www.shadertoy.com/view/4ttBWM\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define VERSION 0\n#define SYMETRY 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = iResolution.xy;\n\tvec2 p = fragCoord.xy;\n    \n    // Instead of fragCoord starting at (0,0) in the bottom left corner \n    // and extending to the (r.x,r.y) in the top right, \n    // (p+p-r) transforms each fragCoord so that the center of the screen is (0,0). \n    // This doubles the fragCoord value and then subtracts the resolution of the window. \n    // The division by r.y fits the coordinates such that the top has a y value of 1 \n    // and the bottom has a y value of -1. \n    // With this, the x is scaled accordingly without stretching. \n    // Finally, the multiplication by 2 just zooms out by a factor of 2.\n\tvec2 q = 2. * (p + p - r) / r.y;\n    \n    #if SYMETRY == 1\n    if(abs(q.y) > abs(q.x)) {\n        float x = abs(q.x);\n        q.x = abs(q.y);\n        q.y = x;\n    } else {\n        float y = abs(q.y);\n        q.y = abs(q.x);\n        q.x = y;\n    }\n    #endif\n    \n    vec4 o = vec4(0);\n\t\n    vec2 q1 = q;\n    vec2 q2 = q;\n    vec2 q3 = q;\n    \n    vec2 qinit = q;\n    \n\tfor(int i=0 ; float(i)<30.0 ; i++) {\n        \n        // Original version\n        #if VERSION == 0\n        \n        // iMouse.xy/r is a way to transform mouse coordinates from pixel to the range (0,0) to (1,1)\n\t\t// What produces this fractal is the idea that some initial values for q \n        // will escape to infinity and others will converge or cycle around a few small values. \n        // Each iteration I increase the lightness of the pixel based how far q is from (0,0). \n        q = abs(q)/dot(q,q) - iMouse.xy/r;\n        \n        // rectangle version from https://goo.gl/GxK2mW\n        #elif VERSION == 1\n        \n        q = abs(q)/(q.x*q.y) - iMouse.xy/r;\n        \n        // mix versions\n        #elif VERSION == 2\n        \n        q = i%7 > 0 ? abs(q)/(q.x*q.y) - 0.2 + sin(iTime*0.2)*0.5*iMouse.xy/r : abs(q)/dot(q,q) - iMouse.xy/r;\n        q *=0.000125;\n        \n        #elif VERSION == 3\n        \n        q = i%5 > 0 ? abs(q)/(q.x*q.y) - iMouse.xy/r :  abs(q)/dot(q,q) + sin(iTime*0.1)*1.0*iMouse.xy/r;\n        \n        #elif VERSION == 4\n        \n        q1 = i%7 > 0 ? abs(q3)/(q1.x*q1.y) - 1. + sin(iTime*0.20)*0.1*iMouse.xy/r : abs(q)/dot(q1,q1) - 10.5*iMouse.xy/r;\n        q2 = i%7 > 0 ? abs(q3)/(q2.x*q2.y) - 1. + sin(iTime*0.21)*0.1*iMouse.xy/r : abs(q)/dot(q2,q2) - 10.5*iMouse.xy/r;\n        q3 = i%7 > 0 ? abs(q3)/(q3.x*q3.y) - 1. + sin(iTime*0.22)*0.1*iMouse.xy/r : abs(q)/dot(q3,q3) - 10.5*iMouse.xy/r;\n        \n        \n\t\t#endif\n        \n        // This length of q is then divided by the constant 2e2 (200) \n        // which is to prevent o.rgb from increasing too rapidly.\n        #if VERSION != 4\n\t\to += length(q) / 400.0;\n        #else\n        o.r += length(q1) / 900.0;\n        o.g += length(q2) / 900.0;\n        o.b += length(q3) / 900.0;\n        #endif\n\n\t}\n    float duration = 10.;\n    float x = mod(iTime/duration, 2.);\n    \n    if(abs(qinit.y-x)<0.01) {\n        o.r = 1.;\n    }\n\n    fragColor = o;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 mainSound( in int samp, float time )\n{    \n    float fmin = 27.5;\n    //float fmax = 440.;\n    float duration = 10.;\n    \n    vec2 iMouse = vec2(0.5, 0.2);\n    \n    float w = 0.;\n    \n    float x = mod(time/duration, 2.);\n        \n    for (float f=0.; f<2.0; f+=0.01) {\n        \n        vec2 q = vec2(x, f);\n        float o = 0.;\n        \n        for(int i=0 ; float(i)<30.0 ; i++) {\n        \n        \tq = abs(q)/dot(q,q) - iMouse.xy;\n            \n\t\t\to += length(q) / 200.0;\n        }\n        \n        float freq = fmin + pow(10., 1.75*f);\n        \n        w += min(o, 1.) * sin(2.*3.14159*freq*time);\n    }\n    \n    return vec2(w)*0.1;    \n    \n}\n\n\n","name":"Sound","description":"","type":"sound"}]}