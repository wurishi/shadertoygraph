{"ver":"0.1","info":{"id":"MdBfzt","date":"1501665010","viewed":123,"name":"Moving Sin","username":"ircss","description":"A moving Sin Funcction practicce","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 lerp(vec3 colorone, vec3 colortwo, float value)\n{\n\n    \n\treturn  ((1.0 - value) * colorone) + (value * colortwo);\n}\n\n\n  vec3 HUEtoRGB(in float H)\n  {\n    float R = abs(H * 6.0 - 3.0) - 1.0;\n    float G = 2.0 - abs(H * 6.0 - 2.0);\n    float B = 2.0 - abs(H * 6.0 - 4.0);\n    return abs(vec3(R,G,B));\n  }\n\n \n \n  vec3 HCYtoRGB(in vec3 HCY)\n  {\n     // The weights of RGB contributions to luminance.\n  // Should sum to unity.\n     vec3 HCYwts = vec3(0.299, 0.587, 0.114);\n    vec3 RGB = HUEtoRGB(HCY.x);\n    float Z = dot(RGB, HCYwts);\n    if (HCY.z < Z)\n    {\n        HCY.y *= HCY.z / Z;\n    }\n    else if (Z < 1.0)\n    {\n        HCY.y *= (1.0 - HCY.z) / (1.0 - Z);\n    }\n    return (RGB - Z) * HCY.y + HCY.z;\n  }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    // Setting up the uv coo\n    \n    vec2 uv = (fragCoord.xy / iResolution.xx);\n     vec2 uv0=uv;\n    \n    // Setting up the time. \n    float time=iTime*1.0;\n    \n    // Color Desenation and other settings\n    \n    \n    //vec3 colorHCY = vec3(0.2,1,0); \n    \n    \n    \n    \n    // Setting up color.\n    \n    vec2 centre = vec2(0.5, 0.2);\n    vec2 currentToCentre = uv - centre;\n    \n    float distanceToEdge = 1.0- length(currentToCentre)/2.0;\n    \n    vec3 background = vec3(0.2,0,distanceToEdge); \n    \n    \n    \n    float color = abs( sin(time * 0.5 + uv.x*0.7)) ;\n    \n    vec3 graphColor = vec3(color ,1.0, 0.1 + length(currentToCentre)/1.0 ); \n    \n    float graphThickness = 500.0;\n    \n    \n    // Graph Calculations \n    \n    \n    float height = 0.02 +  abs( cos(time * 2.0)) * 0.1;\n    height = 0.5;\n    \n    float desiredPixel =  sin(uv.x *30.0 + time) *height +  iResolution.y/1500.0;\n    \n    float distanceToDesiredPixel = abs(uv.y - desiredPixel);\n    \n    /*\n    if(distanceToDesiredPixel <= 0.005){\n        \n          float color = abs( sin(time * 0.5 + uv.x*0.7)) ;\n          colorHCY = vec3(color ,0.6,0.7); \n    }\n\t*/\n    \n    \n    \n    vec3 colorHCY = abs( mix(graphColor, background, \n                             clamp( distanceToDesiredPixel* graphThickness, 0.0, 1.0)));\n\n    \n    // Conversion\n\n    vec3 colorRGB = HCYtoRGB(colorHCY);\n\tfragColor= vec4(colorRGB,1);\n}","name":"Image","description":"","type":"image"}]}