{"ver":"0.1","info":{"id":"WdSGRd","date":"1549649610","viewed":3313,"name":"SDF arbitary 2D polygon","username":"wagyx","description":"Implements the SDF for an arbitray polygon\nI could not find this anywhere else on shadertoy.\nUses the winding number algorithm.","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","polygon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define N 5\n\n\nfloat cross2d(vec2 v0, vec2 v1) {\n    return v0.x*v1.y - v0.y*v1.x;\n}\n\n\n\n// signed distance to a 2D polygon\n// adapted from triangle\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdPoly( in vec2[N] poly, in vec2 p ) {\n    vec2[N] e;\n    vec2[N] v;\n    vec2[N] pq;\n    // data\n    for( int i=0; i<N; i++) {\n        int i2= int(mod(float(i+1),float(N))); //i+1\n\t\te[i] = poly[i2] - poly[i];\n        v[i] = p - poly[i];\n        pq[i] = v[i] - e[i]*clamp( dot(v[i],e[i])/dot(e[i],e[i]), 0.0, 1.0 );\n    }\n    \n    //distance\n    float d = dot(pq[0], pq[0]); \n\tfor( int i=1; i<N; i++) {\n    \td = min( d, dot(pq[i], pq[i]));\n    }\n\t\n    //winding number\n    // from http://geomalgorithms.com/a03-_inclusion.html\n    int wn =0; \n    for( int i=0; i<N; i++) {\n        int i2= int(mod(float(i+1),float(N)));\n        bool cond1= 0. <= v[i].y;\n        bool cond2= 0. > v[i2].y;\n        float val3= cross2d(e[i],v[i]); //isLeft\n        wn+= cond1 && cond2 && val3>0. ? 1 : 0; // have  a valid up intersect\n        wn-= !cond1 && !cond2 && val3<0. ? 1 : 0; // have  a valid down intersect\n    }\n    float s= wn == 0 ? 1. : -1.;\n    return sqrt(d) * s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tp *= 1.5;\n    \n\tvec2 v1 = cos( iTime + vec2(0.0,2.00) + 0.0 );\n\tvec2 v2 = cos( iTime + vec2(0.0,1.50) + 1.5 );\n\tvec2 v3 = cos( iTime + vec2(0.0,3.00) + 4.0 );\n\tvec2 v4 = cos( iTime + vec2(0.0,2.00) - 2.0 );\n    vec2 v5 = cos( iTime + vec2(0.0,1.00) - 1.0 );\n    \n    // add more points\n    vec2[N] poly= vec2[N](v1,v2,v3,v4,v5);\n    \n\tfloat d = sdPoly(poly, p );\n\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n   \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}