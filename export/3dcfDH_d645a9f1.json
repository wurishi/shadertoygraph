{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"webcam","id":"4sf3zn","filepath":"/presets/webcam.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"video","id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define pi 3.14159265359\n\n\nfloat planeIntersection(vec3 N,vec3 V,vec3 pos){\n\tfloat distToPlane = -dot(pos,N);\n\tfloat rayDotPlane = -dot(V,N);\n    if (rayDotPlane > 0. && distToPlane > 0.)\n        return distToPlane/rayDotPlane;\n    else return 0.;\n}\n\nvec2 getUV(vec3 perpX, vec3 perpY, vec3 pos){\n\treturn vec2(dot(perpX,pos),dot(perpY,pos));\n}\n\nvec3 planeColor(vec2 uv, bool change_scene){\n    \n    float aspect = iResolution.x/iResolution.y;\n    uv = (0.5/aspect) * uv + vec2(0.5, 0.5/aspect);\n    uv.y *= iResolution.x/iResolution.y;\n    \n    return (change_scene) \n        ? texture(iChannel0, uv).rgb \n        : texture(iChannel1, uv).rgb;\n}\n\nvec4 boxColor(vec3 viewingNormal, vec3 boxPos, vec3 planeX,vec3 planeY, vec3 planeZ, bool change_scene){\n    for (int i = 0; i < 2; ++i){\n        vec3 planePos = boxPos + planeZ;\n        float t = planeIntersection(planeZ,viewingNormal,planePos);\n        vec2 uv;\n        if (t > 0.){\n            vec3 pos = t*viewingNormal;\n\n            uv = getUV(planeX,planeY,pos - planePos);\n\n            if (uv.x < length(planeX) && uv.x > -length(planeX) && uv.y < length(planeY) && uv.y > -length(planeY)){\n                return vec4(planeColor(uv, change_scene),t);\n            }\n        }\n        planePos = boxPos + planeX;\n        t = planeIntersection(planeX,viewingNormal,planePos);\n        if (t > 0.){\n            vec3 pos = t*viewingNormal;\n\n            uv = getUV(planeZ,planeY,pos - planePos);\n\n            if (uv.x < length(planeZ) && uv.x > -length(planeZ) && uv.y < length(planeY) && uv.y > -length(planeY)){\n                return vec4(planeColor(uv, change_scene),t);\n            }\n        }\n\n        planePos = boxPos + planeY;\n        t = planeIntersection(planeY,viewingNormal,planePos);\n        if (t > 0.){\n            vec3 pos = t*viewingNormal;\n\n            uv = getUV(planeX,planeZ,pos - planePos);\n\n            if (uv.x < length(planeZ) && uv.x > -length(planeZ) && uv.y < length(planeX) && uv.y > -length(planeX)){\n                return vec4(planeColor(uv, change_scene),t);\n            }\n        }\n\n        planeX *= -1.;\n        planeY *= -1.;\n        planeZ *= -1.;\n    }\n    return vec4(0);\n}\n\n\nconst float speed = 0.7;\nconst float farthest_pos = 25.;\nconst float closest_pos = 5.;\nconst float rotation_speed = 3.;\nconst float speed_power = 3.;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ///////////////////////////////\n    ///   Scene change params   ///\n    ///////////////////////////////\n    bool change_scene = int((speed*iTime + 0.5)/2.) % 2 == 0;\n    float ratio = mod(speed*iTime, 2.) - 1.;\n    ratio *= step(0., ratio);\n    \n    \n    ////////////////////////////\n    ///   Background color   ///\n    ////////////////////////////\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 col = (change_scene) \n        ? texture(iChannel0, uv).rgb \n        : texture(iChannel1, uv).rgb;\n    fragColor = vec4(col,1);\n    if (ratio<=0.) {\n        return;\n    }\n    \n    ///////////////////////\n    ///   Cube params   ///\n    ///////////////////////\n    uv = fragCoord.xy/iResolution.x;\n    float aspect = iResolution.x/iResolution.y;\n    vec3 viewingNormal = normalize(vec3(uv-vec2(0.5,0.5/aspect),1));\n    vec3 boxPos = vec3(\n        0,0, mix(closest_pos, \n                 farthest_pos, \n                 pow((ratio-0.5)*2., speed_power))\n    );\n    \n    \n    ///////////////////////////\n    ///   Rotation params   ///\n    ///////////////////////////\n    vec3 planeZ = normalize(vec3(\n        sin(rotation_speed * iTime),    \n        sin(rotation_speed * iTime),\n        cos(rotation_speed * iTime)\n    ));\n    vec3 planeX = normalize(cross(planeZ,vec3(\n        1, 0, 0\n    )));\n    vec3 planeY = normalize(cross(planeZ,planeX));\n    \n    \n    ////////////////////////////////\n    ///   Actual cube function   ///\n    ////////////////////////////////\n    vec4 boxCol = boxColor(viewingNormal,boxPos,planeX,\n                           planeY,planeZ,change_scene);\n    \n    \n    //////////////////////////////////////\n    ///   Mixing with the background   ///\n    //////////////////////////////////////\n    col = mix(col, boxCol.rgb, step(0.5, boxCol.a));\n    fragColor = vec4(col,1);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":true,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"3dcfDH","date":"1734427109","viewed":28,"name":"Transition.Cube.No.2","username":"avartation","description":"sxhmb","likes":1,"published":1,"flags":2,"usePreview":0,"tags":["cdxjbn"],"hasliked":0,"parentid":"","parentname":""}}