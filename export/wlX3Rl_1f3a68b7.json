{"ver":"0.1","info":{"id":"wlX3Rl","date":"1558079593","viewed":76,"name":"car physic attempt","username":"linlin64","description":"Use directional arrows to control the car","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","camera","car","physic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float zNear = 1.0;\nconst float zFar  = 400.0;\n\n//vec3 light = vec3(10.0, 30.0, 10.0);\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float radius) {return (length(p)-radius);}\n\nfloat sdPlane( vec3 p ) {return p.y;} \n\nstruct RayMarchingResult {\n    float dist;\n    vec3 color;\n    bool ground;\n};\n    \nRayMarchingResult opU (RayMarchingResult d1, RayMarchingResult d2) {\n    if (d1.dist < d2.dist) \n        return d1;\n    else \n        return d2;\n}\n\nRayMarchingResult wheel(in vec3 m) {\n    float iTimea = 3.14 / 2.0;\n    \n    float angle = texture (iChannel0, vec2(5.0, 5.0) / iResolution.xy).x;\n    mat3 mat1;\n    mat1[0] = vec3(cos(angle), 0.0, -sin(angle));\n    mat1[1] = vec3(0.0, 1.0, 0.0);\n    mat1[2] = vec3(sin(angle), 0.0, cos(angle));\n    mat3 mat;\n    mat[0] = vec3(1.0, 0.0, 0.0);\n    mat[1] = vec3(0.0, cos(iTimea), -sin(iTimea));\n    mat[2] = vec3(0.0, sin(iTimea), cos(iTimea));\n    vec3 mmat = mat * mat1 * (m-vec3(2.5, 0.4, 1.9));\n    RayMarchingResult res = RayMarchingResult(sdRoundedCylinder(mmat, 0.2, 0.05, 0.05), vec3(0.0, 0.0, 0.0), false);\n\n    mat[0] = vec3(1.0, 0.0, 0.0);\n    mat[1] = vec3(0.0, cos(iTimea), -sin(iTimea));\n    mat[2] = vec3(0.0, sin(iTimea), cos(iTimea));\n    mmat = mat * (m-vec3(-2.5, 0.4, 1.9));\n    res = opU(res, RayMarchingResult(sdRoundedCylinder(mmat, 0.2, 0.05, 0.05), vec3(0.0, 0.0, 0.0), false));\n\n    mat[0] = vec3(1.0, 0.0, 0.0);\n    mat[1] = vec3(0.0, cos(iTimea), -sin(iTimea));\n    mat[2] = vec3(0.0, sin(iTimea), cos(iTimea));\n    mmat = mat * mat1 * (m-vec3(2.5, 0.4, -1.9));\n    res = opU(res, RayMarchingResult(sdRoundedCylinder(mmat, 0.2, 0.05, 0.05), vec3(0.0, 0.0, 0.0), false));\n\n    mat[0] = vec3(1.0, 0.0, 0.0);\n    mat[1] = vec3(0.0, cos(iTimea), -sin(iTimea));\n    mat[2] = vec3(0.0, sin(iTimea), cos(iTimea));\n    mmat = mat * (m-vec3(-2.5, 0.4, -1.9));\n    res = opU(res, RayMarchingResult(sdRoundedCylinder(mmat, 0.2, 0.05, 0.05), vec3(0.0, 0.0, 0.0), false));\n\n\treturn res;\n}\n\nRayMarchingResult body(in vec3 m) {\n    RayMarchingResult res = RayMarchingResult(sdBox(m-vec3(0.0, 0.9 + 0.4, 0.0), vec3(4.0, 0.9, 1.8)), vec3(1.0, 0.0, 0.0), false);\n    res = opU(res, RayMarchingResult(sdBox(m-vec3(0.0, 1.8 + 0.4 + 0.4, 0.0), vec3(2.0, 0.4, 1.8)), vec3(1.0, 0.0, 0.0), false));\n    return res;\n}\n\n\nRayMarchingResult car(in vec3 m) {\n    RayMarchingResult res = wheel(m);\n    res = opU(res, body(m));    \n\t\n    return res;\n}\n\nRayMarchingResult world(in vec3 m) {\n    vec3 carPosition = texture (iChannel0, vec2(1.0, 1.0) / iResolution.xy).xyz;\n\tfloat carAngle = texture (iChannel0, vec2(7.0, 7.0) / iResolution.xy).x;\n\tvec3 sphere = texture (iChannel0, vec2(9.0, 9.0) / iResolution.xy).xyz;\n\n    mat3 mat;\n    mat[0] = vec3(cos(carAngle), \t0.0,\t-sin(carAngle));\n    mat[1] = vec3(0.0, \t\t\t\t1.0,\t0.0);\n    mat[2] = vec3(sin(carAngle), \t0.0,\tcos(carAngle));\n    \n    RayMarchingResult res = car(mat*(m - carPosition));\n    \n    res = opU(res, RayMarchingResult(sdPlane(m), vec3(0.0, 0.0, 1.0), true));\n\n    //res = opU(res, RayMarchingResult(sdSphere(m-sphere, 1.0), vec3(0.0, 0.0, 1.0)));\n\n    return res;\n}\n\nstruct Plane {\n    vec3 o;\n    vec3 n;\n};\n\nvec3 getNormalFromMaterial(in vec2 UV) {\n    float scale = .05;\n\n    vec2 eps = vec2(0.005, 0.0);\n    float hx1 = texture(iChannel1, UV + eps.xy).x;\n    float hx2 = texture(iChannel1, UV - eps.xy).x;   \n    float hz1 = texture(iChannel1, UV + eps.yx).x;\n    float hz2 = texture(iChannel1, UV - eps.yx).x;   \n\n    vec3 i = normalize(vec3(eps.x, 0.0, (hx1-hx2)*scale));\n    vec3 j = normalize(vec3(0.0, eps.x, (hz1-hz2)*scale));   \n/*vec3 i = normalize(vec3(eps.x, 0.0, (hx2-hx1)*scale));\nvec3 j = normalize(vec3(0.0, eps.x, (hz2-hz1)*scale));*/\n    return normalize(cross(i, j));\n}    \n    \nbool plane(vec3 eye, vec3 ray, out vec3 color) {\n    vec3 planeNormal = vec3(0.0,1.0,0.0);\n    Plane p = Plane(vec3(30.0,0.0,100.0), planeNormal);\n    \n    float h = dot(eye - p.o, p.n);\n    float rh = dot(p.n, -ray);\n    \n    vec3 hp = eye + ray * (h/rh);\n    /*if(rh < 0.0) {\n    \tcolor = vec3(0.0, 0.0, 0.0);\n        return false;\n    }*/\n    \n    float t = iTime;\n  \n    vec3 i = vec3(1.0, 0.0, 0.0);\n    vec3 j = p.n;\n    vec3 k = vec3(0.0, 0.0, 1.0);\n    \n    mat3 mat = mat3(i,j,k);\n    \n    vec3 normal = mat * getNormalFromMaterial(hp.xz*0.1);\n    vec3 light = vec3(0.0, 100.0, 0.0);\n    vec3 lightRay = normalize(hp - light);\n    \n    float diffuse = -dot(lightRay, normal);\n    float ambiant = 0.8;       \n    vec3 reflectedLight  = reflect(lightRay, normal);\n    float hilight = pow(max(-dot(reflectedLight, ray),0.0), 2.0) * 0.25;\n    vec3 textureColor = texture( iChannel2, 0.1 * hp.xz ).xyz;\n    color = textureColor * (diffuse + ambiant) + hilight;\n    \n    return true;\n}\n\nvec3 computeNormal(in vec3 pos)\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t     world(pos+eps.xyy).dist - world(pos-eps.xyy).dist,\n\t     world(pos+eps.yxy).dist - world(pos-eps.yxy).dist,\n\t     world(pos+eps.yyx).dist - world(pos-eps.yyx).dist);\n\treturn normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //light = vec3(0.0, cos(iTime) * 100.0, 0.0);\n    \n    float px = (-iResolution.x + 2.0 * fragCoord.x) / iResolution.y;\n    float py = (-iResolution.y + 2.0 * fragCoord.y) / iResolution.y;\n\n    vec2 p = vec2(px, py);\n\n    //vec3 ro = vec3(0.0/*4.0*sin(iTime)*/,10.0 /*+ 2.0*cos(iTime)*/, 5.0/**cos(iTime)*/);\n    //vec3 ta = vec3(0.0, 0.0, 0.0);\n    \n    vec3 ta = texture (iChannel0, vec2(1.0, 1.0) / iResolution.xy).xyz;\n    float angle = texture (iChannel0, vec2(13.0, 13.0) / iResolution.xy).x;\n    vec3 dir = vec3(cos(angle), 0.0, sin(angle));\n    \n    float speed = texture (iChannel0, vec2(11.0, 11.0) / iResolution.xy).x;\n    //float factor = speed / 10.0;\n    \n\tvec3 ro = ta + vec3(-dir.x * 5.0, 10.0 /*- speed* 10.0*/, -dir.z * 5.0);\n\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + ww );\n\n    float marchingDist = 0.0;\n    vec3 m;\n    bool test = false;\n\n    RayMarchingResult result;\n    \n    for(int i = 0; i < 1000; i++) {\n        m = ro + rd * marchingDist;    \n        result = world(m);\n        if(result.dist < 0.01) {\n        \ttest = true;\n            break;\n        }\n        \n        if(result.dist >= zFar) {\n            break;\n        }\n        marchingDist += result.dist;\n    }\n    \n    vec3 img = texture (iChannel3, fragCoord / iResolution.xy).xyz;\n    if(img.x > 0.0) {\n\t\tfragColor = vec4(img, 1.0);\n    } else {\n        if(test) {\n            if(result.ground) {\n                vec3 color;\n                plane(ro, rd, color);\n\n                fragColor = vec4(color.x, color.y, color.z, 1.); \n            } else {\n                vec3 normal = computeNormal(m);\n\n                vec3 light = vec3(20.0, 30.0, 0.0);\n                float ambiant = 0.25;\n                vec3 l = normalize(m-light);\n                float diffuse = -dot(l, normal);\n                float specular = max(0., dot(-rd, reflect(l, normal)));\n\n                vec3 couleurDeBase = result.color;\n\n                vec3 render = couleurDeBase * (ambiant+diffuse) + pow(specular, 20.0);\n\n                fragColor = vec4(render.x, render.y, render.z, 0.0);\n            }\n        } else {\n            fragColor = vec4(0.0, 1.0, 0.0, 0.0);\n        }\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define KEY_LEFT\t37.5/256.0\n#define KEY_UP\t\t38.5/256.0\n#define KEY_RIGHT\t39.5/256.0\n#define KEY_DOWN\t40.5/256.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 carPosition = texture (iChannel0, vec2(1.0, 1.0) / iResolution.xy).xyz;\n    float init = texture (iChannel0, vec2(3.0, 3.0) / iResolution.xy).x;\n    float angle = texture (iChannel0, vec2(5.0, 5.0) / iResolution.xy).x;\n    float carAngle = texture (iChannel0, vec2(7.0, 7.0) / iResolution.xy).x;\n    float speed = texture (iChannel0, vec2(11.0, 11.0) / iResolution.xy).x;\n    float cameraAngle = texture (iChannel0, vec2(13.0, 13.0) / iResolution.xy).x;\n\tfloat lastTime = texture (iChannel0, vec2(15.0, 15.0) / iResolution.xy).r;\n            \n    if(init == 0.0) {\n    \tcarPosition = vec3(0.0, 0.0, 0.0);\n        angle = 0.0;\n        carAngle = 0.0;\n        speed = 0.0;\n        cameraAngle = 0.0;\n        lastTime = 0.0;\n    }\n\n    float diff = iTime-lastTime;\n    \n    float kUp = texture( iChannel3, vec2(KEY_UP,0.0) ).x;\n    if (kUp > 0.5) {\n    \tspeed += 4.1 * diff;\n    }\n    \n    float kDown = texture( iChannel3, vec2(KEY_DOWN,0.0) ).x;\n    if (kDown > 0.5) {\n    \tspeed -= 4.1 * diff;\n    }\n    \n    bool directionEnabled = false;\n    float kLeft = texture( iChannel3, vec2(KEY_LEFT,0.0) ).x;\n    float kRight = texture( iChannel3, vec2(KEY_RIGHT,0.0) ).x;\n    if (kLeft > 0.5) {\n        directionEnabled = true;\n    \tangle -= 0.01;\n        if(angle < -3.14/4.0) {\n        \tangle = -3.14/4.0;\n        }\n    }\n    else if (kRight > 0.5) {\n        directionEnabled = true;\n    \tangle += 0.01;\n        if(angle > 3.14/4.0) {\n        \tangle = 3.14/4.0;\n        }\n    }\n    else {\n        angle = 0.0;\n    }\n    \n    mat3 mat;\n    mat[0] = vec3(cos(carAngle), \t0.0,\tsin(carAngle));\n    mat[1] = vec3(0.0, \t\t\t\t1.0,\t0.0);\n    mat[2] = vec3(-sin(carAngle), \t0.0,\tcos(carAngle));\n    \n    vec3 rearl = carPosition + mat * vec3(-2.5, 0.0, 1.8);\n    vec3 rearr = carPosition + mat * vec3(-2.5, 0.0, -1.8);\n    vec3 frontl = carPosition + mat * vec3(2.5, 0.0, 1.8);\n    vec3 frontr = carPosition + mat * vec3(2.5, 0.0, -1.8);\n    \n    float radius;\n    vec3 sphere;\n    float diffangle;\n    if(angle > 0.0) {\n\t    radius = length(rearl-frontl) * tan(3.14/2.0 - abs(angle));\n    \tsphere = rearl + radius * normalize(rearl - rearr);\n   \t\tdiffangle = (speed / radius) * diff;\n    } else {\n\t    radius = length(rearr-frontr) * tan(3.14/2.0 - abs(angle));\n    \tsphere = rearr + radius * normalize(rearr - rearl);\n   \t\tdiffangle = (-speed / radius) * diff;\n    }\n    \n    carAngle += diffangle;\n    /*float percentage;\n    if(directionEnabled) {\n        percentage = 0.01;\n    } else {\n        percentage = 0.05;\n    }*/\n\tcameraAngle += (carAngle - cameraAngle) * 0.01;\n    \n    //carAngle = carAngle - (3.14 * 2.0) * floor(carAngle / (3.14 * 2.0));\n    //cameraAngle = cameraAngle - (3.14 * 2.0) * floor(cameraAngle / (3.14 * 2.0));\n    \n    mat3 mat1;\n    mat1[0] = vec3(cos(diffangle), \t0.0,\tsin(diffangle));\n    mat1[1] = vec3(0.0, \t\t\t\t1.0,\t0.0);\n    mat1[2] = vec3(-sin(diffangle), \t0.0,\tcos(diffangle));\n\tcarPosition = (mat1 * (carPosition - sphere)) + sphere;\n    \n    \n    if(fragCoord.x >= 0.0 \n       && fragCoord.x < 2.0\n       && fragCoord.y >= 0.0\n       && fragCoord.y < 2.0) {\n       fragColor = vec4(carPosition, 1.0);\n    } else if(fragCoord.x >= 2.0 \n       && fragCoord.x < 4.0\n       && fragCoord.y >= 2.0\n       && fragCoord.y < 4.0) {\n\t   fragColor = vec4(1.0,0.0,0.0,0.0);\n    } else if(fragCoord.x >= 4.0 \n       && fragCoord.x < 6.0\n       && fragCoord.y >= 4.0\n       && fragCoord.y < 6.0) {\n\t   fragColor = vec4(angle,0.0, 0.0, 0.0);\n    } else if(fragCoord.x >= 6.0 \n       && fragCoord.x < 8.0\n       && fragCoord.y >= 6.0\n       && fragCoord.y < 8.0) {\n\t   fragColor = vec4(carAngle, 0.0, 0.0, 0.0);\n    } else if(fragCoord.x >= 8.0 \n       && fragCoord.x < 10.0\n       && fragCoord.y >= 8.0\n       && fragCoord.y < 10.0) {\n\t   fragColor = vec4(sphere,0.0);\n    } else if(fragCoord.x >= 10.0 \n       && fragCoord.x < 12.0\n       && fragCoord.y >= 10.0\n       && fragCoord.y < 12.0) {\n\t   fragColor = vec4(speed, 0.0, 0.0,0.0);\n    } else if(fragCoord.x >= 12.0 \n       && fragCoord.x < 14.0\n       && fragCoord.y >= 12.0\n       && fragCoord.y < 14.0) {\n\t   fragColor = vec4(cameraAngle, 0.0, 0.0,0.0);  \n    } else if(fragCoord.x >= 14.0 \n       && fragCoord.x < 16.0\n       && fragCoord.y >= 14.0\n       && fragCoord.y < 16.0) {\n\t   fragColor = vec4(iTime, 0.0, 0.0,0.0);         \n    } else {\n\t   fragColor = vec4(0.0,0.0,0.0,0.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define DOWN_SCALE 1.0\n\n#define MAX_INT_DIGITS 4\n\n#define CHAR_SIZE vec2(8, 12)\n#define CHAR_SPACING vec2(8, 12)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n#define NORMAL 0\n#define INVERT 1\n#define UNDERLINE 2\n\nint TEXT_MODE = NORMAL;\n\n/*\n--------\n-###----\n##-##---\n##-##---\n-###----\n#####-#-\n##-####-\n##--##--\n##-###--\n-###-##-\n--------\n--------\n\n00000000\n01110000\n11011000\n11011000\n01110000\n11111010\n11011110\n11001100\n11011100\n01110110\n00000000\n00000000\n\n//Broken up into 4 8x3 (24 bit) chunks for each component of the vec4.\n//Hexadecimal is being used to reduce clutter in the code but decimal still works.\n\n00000000\n01110000 -> 00000000 01110000 11011000 -> 0x0070D8\n11011000\n\n11011000\n01110000 -> 11011000 01110000 11111010 -> 0xD870FA\n11111010\n\n11011110\n11001100 -> 11011110 11001100 11011100 -> 0xDECCDC\n11011100\n\n01110110\n00000000 -> 01110110 00000000 00000000 -> 0x760000\n00000000\n\nvec4(0x0070D8,0xD870FA,0xDECCDC,0x760000)\n*/\n\n//Automatically generated from the 8x12 font sheet here:\n//http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n\nvec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000);\nvec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000);\nvec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000);\nvec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000);\nvec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000);\nvec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000);\nvec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000);\nvec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000);\nvec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000);\nvec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000);\nvec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000);\nvec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000);\nvec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000);\nvec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000);\nvec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000);\nvec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000);\nvec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000);\nvec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000);\nvec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000);\nvec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000);\nvec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000);\nvec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000);\nvec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000);\nvec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000);\nvec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000);\nvec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000);\nvec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000);\nvec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000);\nvec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000);\nvec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000);\nvec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000);\nvec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000);\nvec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000);\nvec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000);\nvec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000);\nvec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000);\nvec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000);\nvec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000);\nvec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000);\nvec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000);\nvec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000);\nvec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000);\nvec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000);\nvec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000);\nvec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000);\nvec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000);\nvec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000);\nvec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000);\nvec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000);\nvec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00);\nvec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000);\nvec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000);\nvec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000);\nvec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000);\nvec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000);\nvec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000);\nvec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000);\nvec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000);\nvec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000);\nvec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000);\nvec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000);\nvec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000);\nvec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000);\nvec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00);\nvec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000);\nvec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000);\nvec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000);\nvec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000);\nvec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000);\nvec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000);\nvec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78);\nvec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000);\nvec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000);\nvec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78);\nvec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000);\nvec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000);\nvec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000);\nvec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000);\nvec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000);\nvec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0);\nvec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E);\nvec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000);\nvec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000);\nvec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000);\nvec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000);\nvec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000);\nvec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000);\nvec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000);\nvec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0);\nvec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000);\nvec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000);\nvec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000);\nvec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000);\nvec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000);\nvec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n\nvec2 res = vec2(0);\nvec2 print_pos = vec2(0);\n\n//Extracts bit b from the given number.\n//Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat extract_bit(float n, float b)\n{\n    b = clamp(b,-1.0,24.0);\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(vec4 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    \n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));\n    \n    float pixels = 0.0;\n    pixels += extract_bit(spr.x, bit - 72.0);\n    pixels += extract_bit(spr.y, bit - 48.0);\n    pixels += extract_bit(spr.z, bit - 24.0);\n    pixels += extract_bit(spr.w, bit - 00.0);\n    \n    return bounds ? pixels : 0.0;\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat char(vec4 ch, vec2 uv)\n{\n    if( TEXT_MODE == INVERT )\n    {\n      //Inverts all of the bits in the character.\n      ch = pow(2.0,24.0)-1.0-ch;\n    }\n    if( TEXT_MODE == UNDERLINE )\n    {\n      //Makes the bottom 8 bits all 1.\n      //Shifts the bottom chunk right 8 bits to drop the lowest 8 bits,\n      //then shifts it left 8 bits and adds 255 (binary 11111111).\n      ch.w = floor(ch.w/256.0)*256.0 + 255.0;  \n    }\n\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\n\n//Returns the digit sprite for the given number.\nvec4 get_digit(float d)\n{\n    d = floor(d);\n    \n    if(d == 0.0) return ch_0;\n    if(d == 1.0) return ch_1;\n    if(d == 2.0) return ch_2;\n    if(d == 3.0) return ch_3;\n    if(d == 4.0) return ch_4;\n    if(d == 5.0) return ch_5;\n    if(d == 6.0) return ch_6;\n    if(d == 7.0) return ch_7;\n    if(d == 8.0) return ch_8;\n    if(d == 9.0) return ch_9;\n    return vec4(0.0);\n}\n\n//Prints out the given number starting at pos.\nfloat print_number(float number, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = 3;i >= -1;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n        \n        if(i == -1) //Add a decimal point.\n        {\n            result += char(ch_per,uv);\n        }\n        \n        if(abs(number) > pow(10.0, float(i)) || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\nfloat print_integer(float number, int zeros, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = MAX_INT_DIGITS;i >= 0;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n\n        if(abs(number) > pow(10.0, float(i)) || zeros > i  || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\nconst vec3 HASHSCALE3 = vec3(.1031, .1030, .0973);\n\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat text(vec2 uv)\n{\n    float col = 0.0;\n    \n    vec2 center = res/2.0;\n    \n    float hour = floor(iDate.w/60.0/60.0);\n    float minute = floor(mod(iDate.w/60.0,60.0));\n    float second = floor(mod(iDate.w,60.0));\n    \n    /*//Greeting Text\n    \n    print_pos = floor(center - vec2(STRWIDTH(17.0),STRHEIGHT(1.0))/2.0);\n       \n    col += char(ch_H,uv);\n    col += char(ch_e,uv);\n    col += char(ch_l,uv);\n    col += char(ch_l,uv);\n    col += char(ch_o,uv);\n    col += char(ch_com,uv);\n    \n    col += char(ch_spc,uv);\n    \n    col += char(ch_S,uv);\n    col += char(ch_h,uv);\n    col += char(ch_a,uv);\n    col += char(ch_d,uv);\n    col += char(ch_e,uv);\n    col += char(ch_r,uv);\n    col += char(ch_t,uv);\n    col += char(ch_o,uv);\n    col += char(ch_y,uv);\n    col += char(ch_exc,uv);\n    \n    //Date Text\n    \n    print_pos = vec2(2, 2.0 + STRHEIGHT(2.0));\n    \n    TEXT_MODE = INVERT;\n    col += char(ch_D,uv);\n    col += char(ch_a,uv);\n    col += char(ch_t,uv);\n    col += char(ch_e,uv);\n    \n    TEXT_MODE = NORMAL;\n    col += char(ch_col,uv);\n    \n    TEXT_MODE = UNDERLINE;\n    col += print_integer(iDate.z,2,uv);\n    col += char(ch_lsl,uv);\n    col += print_integer(iDate.y+1.0,2,uv);\n    col += char(ch_lsl,uv);\n    col += print_integer(iDate.x,4,uv);\n    \n    //Time Text\n    \n    print_pos = vec2(2, 2.0 + STRHEIGHT(1.0));\n    \n    TEXT_MODE = INVERT;\n    col += char(ch_T, uv);\n    col += char(ch_i, uv);\n    col += char(ch_m, uv);\n    col += char(ch_e, uv);\n    \n    TEXT_MODE = NORMAL;\n    col += char(ch_col, uv);\n    \n    TEXT_MODE = UNDERLINE;\n\n    col += print_integer(hour,2, uv);\n    col += char(ch_col, uv);\n    col += print_integer(minute,2, uv);\n    col += char(ch_col, uv);\n    col += print_integer(second,2, uv);*/\n    \n    //Resolution Text\n    \n    print_pos = vec2(2, 2.0 + STRHEIGHT(0.0));\n    \n    TEXT_MODE = NORMAL;  \n    col += char(ch_s,uv);\n    col += char(ch_p,uv);\n    col += char(ch_e,uv);\n    col += char(ch_e,uv);\n    col += char(ch_d,uv);\n    \n    TEXT_MODE = NORMAL;  \n    col += char(ch_col,uv);\n    \n    float speed = texture (iChannel1, vec2(11.0, 11.0) / iResolution.xy).x;\n\n    \n    TEXT_MODE = UNDERLINE;\n    //float i = 0.0;\n    //float value = random(uv);//i + 3.0 + floor((3.0 - i) /** hash22(uv).y*/) * 2.0;\n    //col += print_integer(value*1000.0,0,uv); \n    \n    col += print_integer(speed*3600.0/1000.0,0,uv); \n    //col += char(ch_x,uv);\n    //col += print_integer(iResolution.y,0,uv); \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    res = iResolution.xy / DOWN_SCALE;\n    vec2 uv = fragCoord.xy / DOWN_SCALE;\n\tvec2 duv = floor(fragCoord.xy / DOWN_SCALE);\n    \n\tfloat pixel = text(duv);\n    \n    //Shading stuff\n    //vec3 col = vec3(1);\n    //col *= (1.-distance(mod(uv,vec2(1.0)),vec2(0.65)))*1.2;\n    //col *= mix(vec3(0.2),vec3(0,1,0),pixel);\n\n\tfragColor = vec4(vec3(pixel), 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}