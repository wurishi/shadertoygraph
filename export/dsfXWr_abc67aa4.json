{"ver":"0.1","info":{"id":"dsfXWr","date":"1668792436","viewed":403,"name":"Watery Ripples","username":"revanw","description":"A shader swapping buffers to get a simple water ripple effect by diffusion.\n\nSee comments in Buffer A's code. \nThe diffusion term (Laplacian on velocity) is approximated by implicit finite difference. Then the time derivative is approximated via Euler.","likes":11,"published":1,"flags":32,"usePreview":1,"tags":["water","buffer","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shader based on algorithm for water ripples by Hugo Elias.\n// Consists in computing flow using neighbouring pixels in current buffer\n// substracted from previous frame\n// Algorithm slightly adapted using info from\n// https://www.ixm-ibrahim.com/explanations/simulating-water-ripples\n\n// Lots of help from https://www.shadertoy.com/view/4dK3Ww\n//\n// 2022\n\n# define sample_curr(uv) texture(iChannel0, uv).y;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n \n    // Reocmputing here too the value of neighbouring pixels\n    vec3 e = vec3(1./iResolution.xy, 0.);\n    float up = sample_curr(uv + e.zy);\n    float down = sample_curr(uv - e.zy);\n    float right = sample_curr(uv + e.xz);\n    float left = sample_curr(uv - e.xz);\n    // This flow displacement will help us compute a normal for refraction and specular\n    \n    //Lighting\n    vec3 normal = normalize(vec3(up - down, right - left, 1.)); //displacement\n    // Sample refracted texture\n    vec4 c = texture(iChannel1, fragCoord.xy*1.5/iChannelResolution[1].xy + normal.xy*.335).xxxw;\n    vec3 light = normalize(vec3(.5, -.2, .75));\n    float diff = max(dot(normal,light), 0.); // shadows\n    float spec = pow(max(0.,-reflect(light,normal).z),32.); //specular\n    vec4 lightblue = vec4(.55, .6, .7,1.); // color tint\n    fragColor = mix(c, lightblue, 0.25)  *  diff  + spec;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"# define sample(uv) texture(iChannel0, uv).xy;\n# define sample_prev(uv) texture(iChannel0, uv).x;\n# define sample_curr(uv) texture(iChannel0, uv).y;\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    //uv = uv * 2.0 - 1.0;\n    //uv.x *= iResolution.x / iResolution.y;\n    // pixel size in uv space\n    vec3 e = vec3(1./iResolution.xy, 0.);\n    \n    \n    float prev = sample_prev(uv);\n    float curr = sample_curr(uv);\n    \n    float up = sample_curr(uv + e.zy);\n    float down = sample_curr(uv - e.zy);\n    float right = sample_curr(uv + e.xz);\n    float left = sample_curr(uv - e.xz);\n    // Computing an average flow speed (as current_neighbouring - previous_middle)\n    // This actually corresponds to the finite difference implementation of a second \n    // order (spatial) derivative (laplacian) on the flow, i.e. a diffusion term\n    // Delta p = (p_i+1 + p_i-1 + p_j+1 + p_j-i - 4.0 * pij) / dx^2\n    // Correct laplacian\n    // float flow = ((up + down + left + right) - prev*4.0)*e.x*e.x;\n    // Formed used here\n    float flow = (up + down + left + right)/4.0 - prev;\n    \n    // basic flow diffusion equation: du/dt = d2u/dx2\n    // du/dt approximated as next - curr\n    // d2u/dx2 approximated as `flow`, which is the laplacian above\n    float next = curr + flow;\n    next *= damping;\n    \n    // With the correct laplacian above, use:\n    //float next = curr + flow * 135800.0; // this diffusion factor * dt reproduces\n                                           // the ripple effect but with the correct laplacian\n    //float next = curr + flow*iResolution.x*200.; // or this\n\n    //next *= 1.0000005; //  try with 1.005... slightly overexciting everything (will degenerate)\n    // Alternating between damping > 1 and <1 and the different laplacian forms    \n    // will allow to switch between effect\n    \n    // increasing rain rate\n    if (random(iTime)<mix(0., 0.7, min(iTime/15., 1.0))) {\n        vec2 pos = vec2(random(fract(iTime)), random(fract(iTime/3.14)));\n        if (length(uv - pos)<length(e)) {\n            next = 1.0;\n        }\n    }\n    //Mouse action\n    if (iMouse.z>0.) {\n        if (length(uv - vec2(iMouse.x, iMouse.y)/iResolution.xy)<length(e)) {\n            next = 1.0;\n        }\n    }\n    \n    fragColor = vec4(curr, next, 0.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define damping 0.95\n\nfloat random(float x) {\n     return fract(sin(x * 12.9898)*43758.5453123);\n}\n\n\n\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n","name":"Common","description":"","type":"common"}]}