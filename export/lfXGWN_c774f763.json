{"ver":"0.1","info":{"id":"lfXGWN","date":"1706915792","viewed":102,"name":"Raymarching a Black Hole","username":"glooper","description":"Raymarched a black hole (but made it a rectangular prism)\n\nI'm fairly new to raymarching, so this is pretty cool for me :)","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","light","blackhole"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TWO_PI 6.2831853071\n#define PI 3.14159265359\n\nmat3 rot_z(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      c,s,0\n    ,-s,c,0\n    , 0,0,1\n    );\n}\n\nmat3 rot_y(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      c,0,s\n    , 0,1,0\n    ,-s,0,c\n    );\n}\n\nmat3 rot_x(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat3(\n      1, 0,0\n    , 0, c,s\n    , 0,-s,c\n    );\n}\n\n\nfloat opUnion( float d1, float d2 ){\n    return min(d1,d2);\n}\n\nfloat opSubtraction( float d1, float d2 ){\n    return max(-d1,d2);\n}\n\nfloat sdSphere( vec3 p, float s ){\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b ){\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h ){\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat map(vec3 pos){\n    vec3 q = pos;\n    q *= rot_x(iTime) * rot_y(iTime * 0.1831) * rot_z(iTime * 1.4719);\n    //q.xz = mod(q.xz - 10.0, 20.0) - 10.0;\n    \n    //float res = sdSphere(q - vec3(1.6,0.,0.),1.5);\n    //res = opSubtraction(res, sdCappedCylinder(q * rot_z(PI / 2.), 0.5, 0.5));\n    //res = opSubtraction(sdSphere(q - vec3(-1.6,0.,0.),1.5), res);\n    //float res = sdSphere(q, 0.1);\n    //float res = sdCappedCylinder(q, sin(iTime * 2.194) * 4.0 + 6.0, sin(iTime * 3.1041) * 4.0 + 6.0);\n    float res = sdBox(q, vec3(sin(iTime * 2.194) * 4.0 + 6.0, sin(iTime * 1.381) * 4.0 + 6.0, sin(iTime * 1.928) * 4.0 + 6.0));\n    return res;\n}\n\nvec3 calcNormal(vec3 p){\n    float epsilon = 0.001; // arbitrary â€” should be smaller than any surface detail in your distance function, but not so small as to get lost in float precision\n    float centerDistance = map(p);\n    float xDistance = map(p + vec3(epsilon, 0, 0));\n    float yDistance = map(p + vec3(0, epsilon, 0));\n    float zDistance = map(p + vec3(0, 0, epsilon));\n    return normalize((vec3(xDistance, yDistance, zDistance) - centerDistance) / epsilon);\n}\n\nvec3 warpRay(vec3 dir, vec3 pos, float dist) { \n    float factor = 1.0 / pow(dist * 0.4, 2.0) * 1.0;\n    vec3 toSurface = -calcNormal(pos);\n    return normalize(dir + factor * toSurface);\n}\n\nvec3 rayMarch(vec3 ro, vec3 rd){\n    float tolerance = 0.001;\n    float travel = 0.0;\n    vec3 pos = ro + rd;\n    for(int i = 0; i < 80; i++){\n        float dist = map(pos);\n        \n        if(dist <= tolerance){\n            return vec3(0.0);\n            return vec3(dot(calcNormal(pos),normalize(vec3(1,1,1)))) / 2. + 0.5;\n        }\n        \n        if(length(pos) >= 500.0){\n            return texture(iChannel0, rd).rgb;\n        }\n        \n        rd = warpRay(rd, pos, dist);\n        pos += rd * dist;\n    }\n    return texture(iChannel0, rd).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = (uv * 2.0) - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0., 0., -50.);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * 2.0 - 1.0;\n    mouse.y = clamp(mouse.y, -0.25, 0.25);\n    mouse *= TWO_PI;\n    \n    rd *= rot_x(mouse.y);\n    rd *= rot_y(mouse.x);\n    \n    \n    ro *= rot_x(mouse.y);\n    ro *= rot_y(mouse.x);\n    \n\n    fragColor = vec4(vec3(rayMarch(ro, rd)), 1.0);\n    //fragColor = vec4(rd.xyz, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}