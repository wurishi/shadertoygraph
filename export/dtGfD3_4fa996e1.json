{"ver":"0.1","info":{"id":"dtGfD3","date":"1702593194","viewed":31,"name":"Rindler transformations 2D","username":"Amirk","description":"Construction of the Rindler coordinates, i.e., coords. for an observer under constant proper acceleration. And some investigation into its nature. Btw. I have made some 3D version of this effect too.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["light","relativity","lorentz","hyperbolic","acceleration","rindler"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nEXPLANATION OF PHASES:\n\n1. Just a dot in hyperbolic motion, i.e., constant proper acceleration according to special relativity. \n2. Its worldline added.\n3. Forming the coordinate system of the moving particle. \n   This is done by recording the planes of simultaneity in its instantaneous inertial frames.\n   These are called Rindler coordinates.\n   Note how they do not cover the whole original spacetime.\n   Moreover the left part seems to be reversed in time if compared to the original frame.\n   Lastly there is the weird point of intersection (red dot)... \n4. Coordinate transform into those coordinates.\n   The red dot turns into a vertical line beyond which\n   no information can reach the right side. It is called the Rindler Horizon.\n5. Next we see how the stationary (vertical) world lines look\n   from the point of view of the accelerating particle.\n6. Finally we compare lightcones in the two frames. \n   Light does not travel at constant rate in Rindler coordinates, \n   nor does it travel straight. Moreover the the light cones have turned\n   around in the left side of the horizon.\n   These are coordinate-effects. Light does not actually go faster than light\n   and time does not really go backwards.\n*/\nconst float AA=1.;\nfloat t =0.;\n#define PI 3.14159265359\n\nbool GRID = true;\nbool WORLDLINE= true;\nbool AXIS= true;\nbool RINDLERGRID= true;\nbool LIGHTCONES= true;\n\nconst float c=1.;\nvec2 fourvel;\nfloat alpha=.0001;\nconst float maxAlpha=5.;\n\nfloat gamma(float b){\n\n    return pow(abs(1.-b*b),-.5);\n}\n\nmat2 Lorentz(float v){\n     float beta= v/c;\n     float gamma = pow(abs(1.-beta*beta),-.5);\n    return gamma*mat2( beta, 1,\n                     1 ,  beta);                            \n}\n\n\nvec2 RindlerInv(vec2 spacetime, float properAcceleration){\n    float space=spacetime.x;\n    float time=spacetime.y;\n    \n    return vec2(sqrt(space*space-time*time), atanh(time/space)/properAcceleration);\n}\n\nvec2 Rindler(vec2 spacetime, float properAcceleration){\n    \n    float space= spacetime.x;\n    float time=spacetime.y;\n    \n    return vec2(space*cosh(properAcceleration*time), space*sinh(properAcceleration*time));\n}\n\nvec2 Hyperbola(vec2 spacetime){\n    spacetime.x+=1./maxAlpha;\n    float h=spacetime.x*spacetime.x-spacetime.y*spacetime.y-pow(maxAlpha,-2.);\n    \n    //float distFromGraph=smoothstep(.0,.01, 1.*abs(length(spacetime-vec2(.4,0))-.4));\n    float distFromGraph=smoothstep(.0,.01, 1.*abs(h));\n    \n    return vec2(1.-distFromGraph);\n}\n\nvoid originalGrid( vec2 p, inout  vec3 color){\n    vec2 q=p*.5;\n    q=abs(q);\n    color+=.5*smoothstep(.01,.0, min(q.x,q.y));\n    \n    p+=vec2(.05);\n    p.xy=(fract(p.xy*10.) -.5)/10.;\n    p=abs(p);\n    \n    color+=.5*smoothstep(.01,.0, min(p.x,p.y));\n    \n}\n\n\nvoid grid( vec2 p, inout  vec3 color){\n    vec2 q=p*10.;\n    \n    p.xy=(fract(p.xy*10.) -.5)/10.;\n    p=abs(p);\n    \n    if(q.x*.1<.05-1./alpha) //the red left half plane\n        color+=vec3(.9,0.,0)*.8*smoothstep(.01,.0, min(p.x,p.y));\n    else\n        color+=.8*smoothstep(.01,.0, min(p.x,p.y));\n    \n}\n\nvoid axes( vec2 p, inout  vec3 color){\n    \n    vec2 q=p*10.;\n    p.y=(fract(p.y*10.) -.5)/10.;\n    p=abs(p);\n    \n    color+=.8*smoothstep(.01,.0, min(p.x,p.y))*smoothstep(0.02,.01,p.x);\n    \n}\n\nvoid RindlerGrid(vec2 p, inout  vec3 color){\n   \n    p.x+=1./maxAlpha;\n    vec2 q=p;\n    p=RindlerInv(p,maxAlpha);\n    \n    p.xy=(fract(p.xy*10.) -.5)/10.;\n    p=abs(p+vec2(.05,0));\n    p.x=min(p.x,.1-p.x);\n    color+=.8*smoothstep(.01,.0, min(p.x,p.y))*smoothstep(0.,.1, t-RindlerInv(q,maxAlpha).y);\n    \n   // if(q.x*.1<.0) color.gb*=0.1;\n}\n\nvoid grid2( vec2 p, inout  vec3 color){\n    vec2 q=p*10.;\n    p*=.5;\n    \n    \n    //light diagonals:\n    vec2 d= vec2(p.x+p.y, p.x-p.y);\n    d+=.5;\n    d= (fract(d*5.)-.5); //fract(20.*d);//\n    color+=vec3(1.*sign(d.x+.02),1.,.1)*.4*smoothstep(.01,-.01, 50.*d.y*d.x)*smoothstep(.49,.35,abs(d.x-d.y)-0.01);\n    \n    d= (fract(d*2.)); \n    d=min(d,1.-d);\n    color+=vec3(1.,1.,.1)*.8*smoothstep(.05,.0, abs(d.x)-.01);\n    color+=vec3(.0,1.,.0)*.8*smoothstep(.05,.0, abs(d.y)-.01);\n\n}\n\nvoid timer(){\n    t = fract((-1.+iTime)*.2+.2)*.75-.34;\n    float time=iTime/5.;\n    time=fract(time/13.)*13.;\n    if(time<1.){\n         GRID=true;\n         WORLDLINE= false;\n         AXIS= false;\n         RINDLERGRID= false;\n         LIGHTCONES= false;\n    }\n    else if(time<2.){\n         GRID=true;\n         WORLDLINE= true;\n         AXIS= false;\n         RINDLERGRID= false;\n         LIGHTCONES= false;\n    }\n    else if(time<3.){\n         GRID=false;\n         WORLDLINE= true;\n         AXIS= true;\n         RINDLERGRID= true;\n         LIGHTCONES= false;\n    }\n    else if(time<3.5){\n         t=10.;\n         GRID=false;\n         WORLDLINE= true;\n         AXIS= true;\n         RINDLERGRID= true;\n         LIGHTCONES= false;\n    }\n    else if(time<5.){\n         t=10.;\n         alpha=smoothstep(0.,1.,time-3.5)*maxAlpha+.0001;\n         GRID=false;\n         WORLDLINE= true;\n         AXIS= true;\n         RINDLERGRID= true;\n         LIGHTCONES= false;\n    }\n    else if(time<6.){\n         \n         GRID=true;\n         WORLDLINE= true;\n         AXIS= true;\n         RINDLERGRID= false;\n         LIGHTCONES= false; \n    }\n    else if(time<6.5){\n         t=10.;\n         GRID=true;\n         WORLDLINE= true;\n         AXIS= true;\n         RINDLERGRID= false;\n         LIGHTCONES= false; \n    }\n    else if(time<8.){\n         t=10.;\n         alpha=smoothstep(0.,1.,time-6.5)*maxAlpha+.0001;\n         GRID=true;\n         WORLDLINE= true;\n         AXIS= true;\n         RINDLERGRID= false;\n         LIGHTCONES= false; \n    }\n    else if(time<9.){\n         \n         GRID=false;\n         WORLDLINE= true;\n         AXIS= true;\n         RINDLERGRID= false;\n         LIGHTCONES= true; \n    }\n    else if(time<9.5){\n         t=10.;\n         GRID=false;\n         WORLDLINE= true;\n         AXIS= true;\n         RINDLERGRID= false;\n         LIGHTCONES= true; \n    }\n    else if(time<13.){\n         t=10.;\n         alpha=smoothstep(0.,1.,time-9.5)*maxAlpha+.0001;\n         GRID=false;\n         WORLDLINE= true;\n         AXIS= true;\n         RINDLERGRID= false;\n         LIGHTCONES= true; \n    }\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    timer();\n    vec3 col = vec3(0);\n    \n    for(float i=-AA; i<=AA; i+=1.){\n    for(float j=-AA; j<=AA; j+=1.){\n        // Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = (fragCoord+vec2(i,j)-.5*iResolution.xy)/iResolution.y;\n        vec2 m=vec2(1,0);\n\n        m = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n\n        //make the transform into comoving coordinates:\n        uv.x= uv.x+1./alpha;\n        uv=Rindler(uv, alpha);\n        uv.x= uv.x-1./alpha;\n\n\n        //draw worldline of accelerating particle:\n        if(WORLDLINE)\n            col.rb+=Hyperbola(uv)*step(-.20, uv.x);\n\n        //MINKOWSKI GRID\n        if(GRID){\n            uv+=vec2(.05);\n            grid(uv, col);\n            uv-=vec2(.05);\n            }\n\n        //lightcones:\n        if(LIGHTCONES)\n            grid2(uv, col);\n\n        //Moving Ridler observer:\n        vec2 pos=Rindler(vec2(1./maxAlpha,t), maxAlpha);\n        pos.x-=1./maxAlpha;\n        col.rb+=smoothstep(.041,.02, length(uv-pos));\n\n\n        //Rindler Gridlines:\n        if(RINDLERGRID)\n            RindlerGrid(uv,col);\n\n\n        //Comoving coodinate axes:\n        if(AXIS){\n            vec2 uv2=uv;\n            float speed = tanh(maxAlpha*t);\n            uv2-=pos;\n            uv2*=inverse(Lorentz(speed));\n            uv2-=vec2(0,.05);\n            axes(uv2, col);\n        }\n        //Rindler horizon  red point:\n        col.r+=smoothstep(.031,.02, length(uv+vec2(1./maxAlpha,0)));\n    }\n    }\n    col/=(2.*AA+1.)*(2.*AA+1.);\n    \n    \n    \n    /*\n    //some reference spots here and there:\n    col.r+=smoothstep(.031,.01, length(uv-vec2(.6,.2)));\n    col.g+=smoothstep(.031,.01, length(uv-vec2(-.6,-.2)));\n    col.b+=smoothstep(.031,.01, length(uv-vec2(.6,-.2)));\n    col.gb+=smoothstep(.031,.01, length(uv-vec2(-.6,.2)));\n    \n    col.rg+=smoothstep(.031,.01, length(uv-vec2(.6,.0)));\n    \n    col.rgb+=smoothstep(.031,.01, length(uv-vec2(-.6,.0)));\n    */\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}