{"ver":"0.1","info":{"id":"fstXWl","date":"1634164141","viewed":118,"name":"Hoops","username":"rudros","description":"Very small but (hopefully) readable ray-caster","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","mini"],"hasliked":0,"parentid":"MdlGWs","parentname":"Boxes1"},"renderpass":[{"inputs":[],"outputs":[],"code":"#define PI 3.1415326\n\nmat2 rotate2D(float r) {\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\n// Distance of point p to hoop #hoopNum\nfloat hoopSDF(vec3 p, float hoopNum) {\n    float radius = hoopNum*0.03;\n    float height = .01;\n    // Account for hoop rotation\n    p.xy *= rotate2D(sin(iTime)*20.*radius+iTime);\n    // SDF for hoop\n    return max(abs(p.y), abs(length(p.zx)-radius))-height;\n}\n\n// Distance to closest hoop\nfloat worldSDF(vec3 p) {\n    float minDist=1.;\n    for(float j=1.; j<=10.; j++) { // number of hoops\n        float curDist = hoopSDF(p, j);\n        minDist = min(minDist, curDist); \n    }\n    return minDist;\n}\n\nvec3 cameraMotion(vec3 p) {\n    p.yz *= rotate2D(-0.8);\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float i;\n    float minDist, eyeDist;\n\n    vec3 eyePos = vec3(0, 0, -1);\n    vec3 ray = vec3((fragCoord.xy-.5*iResolution.xy)/iResolution.x, 1.);\n    ray = normalize(ray);\n\n    // Camera motion\n    eyePos = cameraMotion(eyePos);\n    ray = cameraMotion(ray);\n\n    for(minDist=1.; i<100. && minDist>.001; i++) {  \n        // Point to check\n        vec3 p = eyePos+eyeDist*ray;\n        \n        minDist = worldSDF(p);\n        // Move point forward\n        eyeDist += minDist*.5;\n    }\n    // Adjust steps by current distance to surface to fix banding\n    i += minDist*2000.;\n    fragColor = vec4(0) + 100./(i*i);\n}\n","name":"Image","description":"","type":"image"}]}