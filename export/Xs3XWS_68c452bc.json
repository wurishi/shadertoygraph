{"ver":"0.1","info":{"id":"Xs3XWS","date":"1461066312","viewed":732,"name":"ForceField","username":"Draedrus","description":"A force shield shader, it needs some optimization by the way ! I will do that soon.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raymarching","voronoi","heightmap","forcefield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_STEPS 50\n#define CAMDIST 20.0\n#define CAMROTSPEED 0.4\n#define FAR 200.0\n#define NEAR 1.0\n#define DAYNNIGHTSPEED 1.01\n#define DEPTH 1.0\n#define OCTAVES_PERLIN 8\n#define ASTRESIZE 1.8\n#define ANIMATE\n\n#define CAMPOS vec3(0.0, 10.0, 100.0)\n#define FORCEFIELDPOS vec3(0.0, 0.0, 80.0)\n#define CREEPSCALE 2.0\n\nstruct Light {\n    vec3 o;\n    vec3 d;\n    vec4 diffuseColor;\n    float shininess;\n\tfloat power;\n};\n\nLight sun = Light(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.0, 0.0),\n    vec4(1.0, 1.0, 0.3, 1.0),\n    2.0,\n    2.0);\nLight moon = Light(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.0, 0.0),\n    vec4(0.9, 0.9, 1.0, 1.0),\n    2.0,\n    0.3);\n\nvec3 dirtColor = vec3(1.0, 0.9, 0.9);\nvec3 grassColor = vec3(0.05, 0.4, 0.09);\nvec3 skyDayColor = vec3(0.4, 0.4, 1.0);\nvec3 skyNightColor = vec3(0.2, 0.2, 0.4);\nvec3 creepColor = vec3(0.6, 0.3, 0.7);\n\nfloat forcefieldRadius = 10.0;\nfloat forcefieldOpacity = 0.6;\nfloat forcefieldIntersectionSize = 0.15;\nfloat forcefieldDiffuseFactor = 1.4;\nfloat forcefieldSpecularFactor = 1.7;\nvec3 forcefieldColor = vec3(0.0, 0.3, 1.0);\nvec3 forcefieldVeinsColor = vec3(0.0, 0.5, 0.7);\n\nfloat hash(vec2 x) {\n    float h = dot(x, vec2(42.69, 51.42));\n\treturn fract(sin(h)*50403.43434);   \n}\n\nfloat noise(vec2 p) {\n    return mix(hash(p), hash(p+vec2(0.001, 0.001)), fract(p.x));\n}\n\nfloat voronoi(vec2 uv) {\n    vec2 fl = floor(uv);\n    vec2 fr = fract(uv);\n    float res = 1.0;\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec2 p = vec2(i, j);\n            float h = hash(fl+p);\n            vec2 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nvec2 hash2( vec2 p )\n{\n\t// texture based white noise\n\treturn texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n\t\n    // procedural white noise\t\n\t//return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec3 voronoi3( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n+g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n+g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>1.5 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec3( md, mr );\n}\n\nfloat tiles(vec2 uv) {\n\treturn smoothstep(\n        0.4,\n        0.5,\n        max(\n \t\t\tabs(\n                fract(8.0*uv.x - 0.5*mod(floor(8.0*uv.y), 2.0) ) - 0.5),\n \t\t\tabs(fract(8.0*uv.y) - 0.5)\n        )\n    );\n}\n\n/***************************************\n * Hexagonal tiles thanks to klk from https://www.shadertoy.com/view/lt2SzG\n ***************************************/\n\n#define pi 3.14159\n\n\nfloat vlx(vec2 uv, out float a)\n{\n    float v=0.0;\n    vec2 lp=uv-vec2(-0.5,0.5*tan(pi/6.0));\n    v=length(lp);a=atan(lp.y, lp.x);\n\n    vec2 lp1=uv-vec2(0.5,0.5*tan(pi/6.0));\n    float v1=length(lp1);\n    if(v1<v){v=v1;a=atan(lp1.y, lp1.x);}\n\n    vec2 lp2=uv-vec2( 0.0,-0.5/cos(pi/6.0));\n    float v2=length(lp2);\n    if(v2<v){v=v2;a=atan(lp2.y, lp2.x);}\n    \n    a=(a/pi*0.5+0.5);\n    \n    return v;\n}\n\nvec4 hex(vec2 uv, out float ang1, out float ang2)\n{\n    float x=uv.x;\n    float y=uv.y;\n    float h=1.0/cos(pi/6.0);\n    \n\tx+=(fract(y*h/2.0)>0.5?0.0:0.5);\n    x=fract(x)-0.5;\n    y=fract(y*h)/h-0.5/h;\n    float n=6.0;\n    float a=atan(x,y)/pi/2.0;\n    float v=length(vec2(x,y));\n    vec2 p=vec2(0,0);\n    vec2 p0=vec2(sin(pi/6.0),cos(pi/6.0));\n    if(y<0.0)p0.y=-p0.y;\n    if(x<0.0)p0.x=-p0.x;\n\tfloat v0=length(vec2(x,y)-p0);\n    if(v0<v)\n    {\n        v=v0;p=p0;\n\t    x=x-p.x;\n\t    y=y-p.y;\n    }\n\n    a=atan(x,y);\n    v=length(vec2(x,y))*2.0;\n    v=(v*5.0+a*pi/32.0)*10.0;\n\tfloat v1=0.0;\n    float v2=0.0;\n\n    v1=vlx(vec2(x,y), ang1);\n    v2=vlx(vec2(x,-y), ang2);\n    return vec4(x,y,v1,v2);\n}\n\n// Simplex 2D noise\n// sources: Ian McEwan - https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\n// sources: Patricio Gonzalez Vivo - https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\nfloat snoise(vec2 v){\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n                        -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n                     + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n                            dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat perlin(vec3 V) {\n    float total = 0.0;\n    for(int i=2;i<OCTAVES_PERLIN+2;i++) {\n        total += (1.0/float(i))*snoise(V.xz);\n        V*=2.0+(float(i)/100.0);\n    }\n    return total;\n}\n\nfloat sdSphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat sdGaussianRadialBlob(vec3 pos, vec3 originalPos, float radius)\n{\n    return (snoise((pos-FORCEFIELDPOS).xz+iTime))*0.2;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat IntersectSphere(vec3 ro, vec3 rd, vec3 sc, float sr, out float d2) {\n    vec3 Z = ro-sc;\n    float B = 2.0 * dot(rd, Z);\n    float C = Z.x*Z.x+Z.y*Z.y+Z.z*Z.z-sr*sr;\n    float D = B*B - 4.0*C;\n    float t = -1.0;\n    float d = -1.0;\n   \td2 = -1.0;\n    if(D>=0.0) {\n        if(C>0.0) {\n            d = (-B-sqrt(D))/2.0;\n            d2 = (-B+sqrt(D))/2.0;\n        }else{\n            d = (-B+sqrt(D))/2.0;\n            d2 = (-B-sqrt(D))/2.0;\n        }\n    }\n    return d;\n}\n\nfloat sdTerrain(vec3 p) {\n    float h = 0.0;\n    float f = 0.09;\n    float amp = 3.0;\n    for(int i = 0;i<7;i++) {\n        h+=snoise(p.xz*f)*amp;\n        f *= 1.9;\n        amp *= 0.22;\n    }\n\treturn DEPTH+h;//snoise(p.xz);//cos(p.x)+sin(p.z);\n}\n\nvec2 map(vec3 p) {\n    vec2 ret = vec2(-1.0, -1.0);\n    float t = sdTerrain(p);\n    float rb = sdGaussianRadialBlob(p,FORCEFIELDPOS/*vec3(0.0, 0.0, 60.0)*/, 1.0);\n    if(t<rb)\n  \t\tret.xy = vec2(t, 0.0);\n    else{\n        float s = sdSphere(FORCEFIELDPOS-p, forcefieldRadius);\n        if(min(rb, -s)==-s) {\n        \tret = vec2((t+rb)*CREEPSCALE, 1.0);\n        }else{\n            ret = vec2(t, 0.0);\n        }\n    }\n    //ret.x = max(ret.x, -s);\n    return ret;\n    /*return max(-sdSphere(p, vec3(0.0, 0.0, 80.0), forcefieldRadius),\n               min(sdTerrain(p),\n                   sdGaussianRadialBlob(p, vec3(0.0, 0.0, 60.0), 30.0)\n                   )\n               );*/\n}\n\nvec3 mapNormal(vec3 pt, float e) {\n    vec3 normal;\n    normal.y = map(pt).x;    \n    normal.x = map(vec3(pt.x+e,pt.y,pt.z)).x - normal.y;\n    normal.z = map(vec3(pt.x,pt.y,pt.z+e)).x - normal.y;\n    normal.y = e;\n    return normalize(normal);\n}\n\nvec2 raymarch(vec3 ro, vec3 rd, in float tmin, in float tmax) {\n    float t = tmin;\n    vec2 m;\n\tfor( int i=0; i<NUM_STEPS; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n        m = map(pos);\n\t\tfloat h = pos.y - m.x;\n\t\tif( h<(0.002*t) || t>tmax ) break;\n\t\tt += 0.5*h;\n\t}\n\n\treturn vec2(t, m.y);\n}\n\nvec3 TerrainColorMap(vec3 rd, vec3 p, vec3 n, vec3 l, float depth) {\n    float _noise = snoise(p.xz*0.2);\n    float _hash = perlin(p.xyz);\n    \n    float Lambert = max(0.0, dot(n, -l));\n    \n    float depthFactor = (FAR-depth)/(FAR-NEAR);\n    \n    return mix(\n        depthFactor*mix(dirtColor, grassColor, _noise)*(_hash+1.5)*0.2+Lambert*0.3,\n        mix(skyDayColor, skyNightColor, max(0.0, dot(rd, l)))*(1.0-depthFactor),\n        1.0-depthFactor);\n}\n\nvec3 CreepColorMap(vec3 rd, vec3 p, vec3 n, vec3 l, float depth) {\n    float _noise = snoise(p.xz*0.2);\n    float _hash = perlin((p-FORCEFIELDPOS).xyz+vec3(iTime*1.0, iTime, iTime*-1.0));\n    \n    float Lambert = max(0.0, dot(n, -l));\n    \n    float depthFactor = (FAR-depth)/(FAR-NEAR);\n    \n    return mix(\n        depthFactor*creepColor*(_hash+0.8)*0.7+Lambert*0.3,\n        mix(skyDayColor, skyNightColor, max(0.0, dot(rd, l)))*(1.0-depthFactor),\n        1.0-depthFactor);\n}\n\nvec3 SkyColorMap(vec2 pixel, vec3 ro, vec3 rd, vec3 p, vec3 n, vec3 l, float depth) {\n    float _noise = snoise(p.xz*0.000001);\n    float _hash = perlin(vec3(0.0, pixel.x, pixel.y)+p.xyz*0.000001);\n    \n    vec3 color = mix(skyDayColor, skyDayColor*0.8, pixel.y);\n    color = mix(skyDayColor, skyNightColor, max(0.0, dot(rd, l))); \n    // sun\n    float t3 = -1.0;\n    float t2 = IntersectSphere(ro, rd, sun.o, ASTRESIZE, t3);\n    if(t2>0.0) {\n        vec3 intersectP = ro+rd*t2;\n        vec3 normal = normalize(intersectP-sun.o);\n        float gradient = dot(-rd, normal);\n        color = mix(color, sun.diffuseColor.rgb, pow(gradient, sun.shininess)*sun.power);\n    }\n    // moon\n    t2 = IntersectSphere(ro, rd, -sun.o, ASTRESIZE, t3);\n    if(t2>0.0) {\n        vec3 intersectP = ro+rd*t2;\n        vec3 normal = normalize(intersectP+moon.o);\n        float gradient = dot(-rd, normal);\n        color = mix(color, moon.diffuseColor.rgb, pow(gradient, moon.shininess)*moon.power);\n    }\n    \n    \n    return mix(color, vec3(1.0), (1.0+snoise(p.yz*0.01))*0.5*(pixel.y*0.2));\n}\n\nvec3 ForceFieldColorMap(vec2 pixel, vec3 ro, vec3 rd, vec3 p, vec3 n, vec3 l, float depthFF, float depthTerrain) {\n    return vec3(0.0);\n}\n\n// the camera construction method is inspired by the one from IQ\nmat3 setCamera( in vec3 origin, in vec3 target, vec3 viewUp )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cu = normalize( cross(cw,viewUp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid camPos(float t, in vec3 rdi, in vec3 roi, out vec3 ro, out vec3 rd) {\n    mat3 rotX = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(t), -sin(t),\n        0.0, sin(t), cos(t));\n    mat3 rotY = mat3(\n        cos(t), 0.0, sin(t),\n        0.0, 1.0, 0.0,\n        -sin(t), 0.0, cos(t));\n    mat3 rotZ = mat3(\n        cos(t), sin(t), 0.0,\n        -sin(t), cos(t), 0.0,\n    \t0.0, 0.0, 1.0);\n    \n    ro = roi;/*+vec3(\n        cos(t)*CAMDIST,\n        0.0,\n        sin(t)*CAMDIST);*///vec3(cos(t), 4.0, sin(t))*CAMDIST;\n\trd = normalize(rdi*rotY);\n}\n\nvoid lightPos(float t, out vec3 lPos) {\n    mat3 rotX = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(t), -sin(t),\n        0.0, sin(t), cos(t));\n    lPos = lPos*rotX;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixel = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n    vec2 mv = -1.0 + 2.0*iMouse.xy/iResolution.xy+vec2(1.0, 0.0);\n    float Time = mod(iTime*CAMROTSPEED, 360.0);\n\n    vec3 forcefieldPos = FORCEFIELDPOS;\n    \n    vec3 ro = CAMPOS;\n    vec3 rd = vec3(pixel, 1.0);\n\tvec3 lPos = vec3(0.0, 100.0, 100.0);\n    #ifdef oldsys\n    camPos(Time*CAMROTSPEED,\n           rd, vec3(0.0, 4.0, 100.0),\n           ro, rd);\n    //lightPos(Time, forcefieldPos);\n    \n    mat3 ca = setCamera(ro, rd, vec3(0.0, 1.0, 0.0));\n    rd = ca*rd;\n    #else\n    \tro.x = forcefieldPos.x+cos(Time*CAMROTSPEED)*CAMDIST;\n    \tro.z = forcefieldPos.z+sin(Time*CAMROTSPEED)*CAMDIST;\n    \trd = normalize(rd);\n        mat3 ca = setCamera(ro, forcefieldPos, vec3(0.0, 1.0, 0.0));\n        rd = ca*rd;\n    #endif\n    lightPos(Time*DAYNNIGHTSPEED, lPos);\n    \n    vec2 rm = raymarch(ro, rd, 0.0, FAR);\n    float t = rm.x;\n    vec3 p = ro+rd*t;\n    vec3 n = normalize(mapNormal(p, 0.001));\n    vec3 l = normalize(p - lPos);\n    \n    sun.o = lPos;\n    sun.d = l;\n    \n    \n    vec3 color = vec3(0.0, 0.0, 0.0);\n    if(t>0.0 && t<FAR && rm.y==0.0) {\n    \t//color = vec3(1.0/t);\n        color = TerrainColorMap(rd, p, n, l, t);\n    }else if(t>0.0 && t<FAR && rm.y==1.0) {\n        color = CreepColorMap(rd, p, n, l, t);\n    }else{\n    \tcolor = SkyColorMap(pixel, ro, rd, p, n, l, t);\n    }\n    float t3;\n    float t2 = IntersectSphere(ro, rd, forcefieldPos, forcefieldRadius, t3);\n    if(abs(t2-t)<forcefieldIntersectionSize || (t3>=0.0 && abs(t2-t)<forcefieldIntersectionSize)) {\n        color = mix(color, forcefieldColor*(1.0-(abs(t2-t)/forcefieldIntersectionSize)), forcefieldOpacity);\n    }\n    if(t2>0.0 && t2<t) {\n        vec3 p = ro+rd*t2;\n        float v = voronoi3(p.xz).x;\n        vec2 tilesUV = p.xz;\n        tilesUV.y += sin((tilesUV.x+iTime)*10.0)*0.01;\n        float a;\n        vec3 ffn = normalize(p-forcefieldPos)*\n            hex(tilesUV*0.5, a, a).xyz\n            //mix(1.0, 1.0-tiles(tilesUV*0.5)*1.0, max(0.0, dot(rd, l)))\n            ;//smoothstep( 0.01, 0.02, v );//((pow(1.0-v, 0.3)*1.5));\n        vec3 ffc = forcefieldColor;\n    \n        float diffuseTerm = max(0.0, dot(-l, ffn));\n        float specularTerm = max(0.0, dot(-l, reflect(rd, ffn)));\n        ffc += diffuseTerm*forcefieldDiffuseFactor;\n        ffc += specularTerm*forcefieldSpecularFactor*pow(2.0, specularTerm);\n    \n    \tfloat edge = 1.0-(abs(t3-t2))/(forcefieldRadius*2.0);\n        color = mix(color, ffc, forcefieldOpacity*edge);\n        if(t3>=0.0 && t3<t) {\n            vec3 p = ro+rd*t3;\n            float v = voronoi3(p.xz).x;\n        \ttilesUV = p.xz;\n        \ttilesUV.y += sin((tilesUV.x+iTime)*10.0)*0.01;\n\n            ffn = normalize(p-forcefieldPos)*\n            \thex(tilesUV*0.5, a, a).xyz\n                //mix(1.0, tiles(tilesUV*0.5)*1.0, max(0.0, dot(rd, l)))\n                ;//*smoothstep( 0.01, 0.05, v );//((pow(1.0-v, 0.3)*1.5));\n            diffuseTerm = max(0.0, dot(-l, ffn));\n            specularTerm = max(0.0, dot(-l, reflect(rd, ffn)));\n            \n            ffc += diffuseTerm*forcefieldDiffuseFactor;\n        \tffc += specularTerm*forcefieldSpecularFactor*pow(2.0, specularTerm);\n            color = mix(color, ffc, forcefieldOpacity*edge);\n        }\n        color = mix(color, forcefieldVeinsColor, (1.0-smoothstep(0.02, 0.1, v))*forcefieldOpacity);\n    \tcolor = mix(color, vec3(1.0), edge*0.5);\n        //color = mix(color, forcefieldColor, 1.0-max(0.0, 1.0-dot(normalize(ffn), normalize(rd)))); \n    }\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}