{"ver":"0.1","info":{"id":"NllGRX","date":"1622530776","viewed":451,"name":"backdraft","username":"Carandiru","description":"fork of shader by Brady ^^^^^^ link above\n\nplaying with fire, trying to get a good effect.\n","likes":5,"published":3,"flags":0,"usePreview":0,"tags":["fire","volumetric","raymarcher"],"hasliked":0,"parentid":"WllXzB","parentname":"Brady's Volumetric Fire"},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////////\n// ORIGINALLY - BRADY'S VOLUMETRIC FIRE //\n/////////////////////////////\n\n// thanks brady, great shader btw.\n\nfloat noise( vec3 P )\n{\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n    vec3 Pf_min1 = Pf - 1.0;\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    vec2 hash_mod = vec2( 1.0 / ( 635.298681 + vec2( Pi.z, Pi_inc1.z ) * 48.500388 ) );\n    vec4 hash_lowz = fract( Pt * hash_mod.xxxx );\n    vec4 hash_highz = fract( Pt * hash_mod.yyyy );\n    vec3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);\n    vec4 res0 = mix( hash_lowz, hash_highz, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    return dot( res0, blend2.zxzx * blend2.wwyy );\n}\n\nfloat fnoise(vec3 p, float time)\n{\n    float f = 0.0;\n    p = p - vec3(0.0, 1.0, 0.0) * .5 * time;\n    p = p * 3.0;\n    f += 0.50000 * noise(p); p = 2.0 * p;\n\tf += 0.25000 * noise(p); p = 2.0 * p;\n\tf += 0.12500 * noise(p); p = 2.0 * p;\n\tf += 0.06250 * noise(p); p = 2.0 * p;\n    f += 0.03125 * noise(p); p = 2.0 * p;\n    f += 0.015625 * noise(p);\n    \n    return f;\n}\n\nfloat model( in vec3 p )\n{\n    p.y *= 0.75;\n    p.xz *= 0.5;\n\n    float sphere = length(p)-1.05;\n    float fire = fnoise(p*4.5, iTime*3.);\n    \n    float res = sphere + fire * 0.5f;\n    return res * 0.633f;\n}\n\nfloat raymarch(in vec3 ro, in vec3 rd)\n{\n    float dist = 0.;\n    for(int i = 0; i < 40; i++)\n    {\n\t\tfloat m = model(ro+rd*dist);\n        dist += m;\n        \n        if(m < .001) return dist;\n        //else if(dist > 2.) break;\n    }\n    return -1.;\n}\n\nvec3 background(in vec2 p)\n{\n\treturn vec3(0.);\n}\n\nvec3 blackbody(float t){\n    // http://en.wikipedia.org/wiki/Planckian_locus\n\n    vec4 vx = vec4( -0.2661239e9, -0.2343580e6, 0.8776956e3, 0.179910   );\n    vec4 vy = vec4( -1.1063814,   -1.34811020,  2.18555832, -0.20219683 );\n    //vec4 vy = vec4(-0.9549476,-1.37418593,2.09137015,-0.16748867); //>2222K\n    float it = 1. / t;\n    float it2= it * it;\n    float x = dot( vx, vec4( it*it2, it2, it, 1. ) );\n    float x2 = x * x;\n    float y = dot( vy, vec4( x*x2, x2, x, 1. ) );\n    \n    // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n    mat3 xyzToSrgb = mat3(\n         3.2404542,-1.5371385,-0.4985314,\n        -0.9692660, 1.8760108, 0.0415560,\n         0.0556434,-0.2040259, 1.0572252\n    );\n\n    vec3 srgb = vec3( x/y, 1., (1.-x-y)/y ) * xyzToSrgb;\n\n    return max( srgb, 0. );\n}\n\nvec3 volume(in vec3 p, in vec3 rd, in vec3 ld, in vec2 sp)\n{\n    vec3 op = p;\n    float trans = 1.0;\n    float td = 0.0;\n    float emit = 0.0;\n    float steps = 30.; // increase to smooth\n    \n    // march\n    for(float i = 0.; i < steps; i++)\n    {\n        float m = model(p);\n        p += rd*.03;\n        \n        float dens = exp2(-m * 0.85f) * 0.85f;\n        td += dens * trans;\n        trans *= dens;\n        \n        if(trans < 0.001f)\n        {\n            break;\n        }\n    }\n    \n    vec3 extreme;\n    extreme = mix(vec3(0), blackbody(400.0f * td * (1.0f - trans)), trans);\n    \n    extreme = mix(extreme, blackbody(450.0f * td), trans);\n    \n    extreme += extreme * extreme;\n    \n    return extreme;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    \n    float rs = .5;\n    vec3 ro = vec3(cos(iMouse.x/100.), 1., sin(iMouse.x/100.))*1.35;\n    vec3 ta = vec3(0., 0.1, .0);\t\t\t\t\n    \n    vec3 w = normalize (ta-ro);\n    vec3 u = normalize (cross (w, vec3(0., 1., 0.)));\n    vec3 v = normalize (cross (u, w));\n    mat3 mat = mat3(u, v, w);\n    vec3 rd = normalize (mat*vec3(p.xy,1.));\n    \n    float dist = raymarch(ro, rd);\n    vec3 ld = vec3(-1., 1., 0.);\n    vec3 col = dist > 0. ? volume(ro+rd*dist, rd, ld, p) : background(p);\n    \n    fragColor = vec4(col ,1.0);\n}","name":"Image","description":"","type":"image"}]}