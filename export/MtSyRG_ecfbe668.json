{"ver":"0.1","info":{"id":"MtSyRG","date":"1509040956","viewed":230,"name":"Lid-Driven Flow","username":"riouxld","description":"Test for the implementation of a stable unsteady fluid (jstam) solver in Shadertoy. I did not find a way to iterate the Jacobi method yet. Also, since we solve with H-H dec, the bdr value should be bettered.\nTry looking at vorticity in image and perturb!","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["simulation","fluid","multipass","navierstokes","jacobi","multistep"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// must be modified in all buffers and image\n// if poiseuille flow simulation\n#define LID\n// if lid-driven flow simulation\n//#define POIS\n\n// choose what field to look at by commenting\n//#define VELOCITY\n//#define PRESSURE\n//#define DIVERGENCE\n#define VORTICITY\n\n// must be modified in all buffers and image\n// simulation parameters\nconst float dt = 1.0/400.0;\nconst float reynold = 100.0;\n\n//macro\n#define GetVelocity(I,J) texelFetch( iChannel3, ijCoord+ivec2(I,J), 0 ).xy\n#define GetPressure(I,J) texelFetch( iChannel2, ijCoord+ivec2(I,J), 0 ).x\n#define GetDivVelocty(I,J) texelFetch( iChannel2, ijCoord+ivec2(I,J), 0 ).y\n#define GetGradPressure(I,J) texelFetch( iChannel3, ijCoord+ivec2(I,J), 0 ).zw\n\n// COLORMAP\nvec3 jet(float t)\n{\n    return smoothstep(0.5,0.75,t) * vec3(1,0,0)\n        + (smoothstep(0.0,0.25,t)-(smoothstep(0.75,1.0,t))) * vec3(0,1,0)\n        + (1.0-smoothstep(0.25,0.5,t)) * vec3(0,0,1);\n}\n\nvec3 wheel(float t)\n{\n    return clamp(abs(fract(t + vec3(1.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) -1.0, 0.0, 1.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //set grid\n    float dx = 1.0 / iResolution.y;\n    float dxPow = dx *dx ;\n    vec2 uvCoord = dx*fragCoord.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n\n\n    //to compute finite difference approximaton\n\n    vec2 uv = GetVelocity(0,0); \n    float uvDiv = GetDivVelocty(0,0); \n    float p = GetPressure(0,0); \n    vec2 pGrad = GetGradPressure(0,0);\n\n    // if you want to compute vorticity\n    #ifdef VORTICITY\n    //to compute finite difference approximaton\n    vec2 uvip1j = GetVelocity(1,0);\n    vec2 uvim1j = GetVelocity(-1,0);\n    vec2 uvijp1 = GetVelocity(0,1);\n    vec2 uvijm1 = GetVelocity(0,-1);\n    vec2 uvijentry =  GetVelocity(-ijCoord.x,0);\n    vec2 uvijexit =  GetVelocity(-ijCoord.x+int(iResolution.x)-1,0);\n\n    // set boundary conditions\n    #ifdef POIS\n    if(ijCoord.x ==  int(iResolution.x)-1)\n    {\n        uvip1j = uvijentry; //periodic\n    }\n\n    if(ijCoord.x == 0)\n    {\n        uvim1j = uvijexit; //periodic\n    }\n    if(ijCoord.y ==  int(iResolution.y)-1)\n    {\n        uvijp1 = -uv; //dirichlet\n    }\n\n    if(ijCoord.y == 0)\n    {\n        uvijm1 = -uv; //dirichlet\n    }\n    #endif\n    #ifdef LID\n    if(ijCoord.x ==  int(iResolution.x)-1)\n    {\n        uvip1j = -uv; //dirichlet\n    }\n\n    if(ijCoord.x == 0)\n    {\n        uvim1j = -uv; //dirichlet\n    }\n\n    if(ijCoord.y ==  int(iResolution.y)-1)\n    {\n        uvijp1 = 2.0*vec2(1.5,0.0)-uv; //dirichlet\n    }\n\n    if(ijCoord.y == 0)\n    {\n        uvijm1 = -uv; //dirichlet\n    }\n    #endif\n\n    float vortiticy = 0.5*(uvijp1.y-uvim1j.y +uvijp1.x-uvijm1.x)/dx;\n    #endif\n\n\n    #ifdef POIS\n    #ifdef VELOCITY\n    fragColor =vec4(jet(length(uv)),1);\n    #endif\n    #ifdef PRESSURE\n    fragColor =vec4(jet(p),1);\n    #endif\n    #ifdef DIVERGENCE\n    fragColor =vec4(jet(uvDiv),1);\n    #endif\n    #ifdef VORTICITY\n    fragColor =vec4(jet(0.5*(vortiticy+1.0)),1);\n    #endif\n    #endif\n    #ifdef LID\n    #ifdef VELOCITY\n    fragColor =vec4(jet(length(uv)),1);\n    #endif\n    #ifdef PRESSURE\n    fragColor =vec4(jet(0.5*(p+1.0)),1);\n    #endif\n    #ifdef DIVERGENCE\n    fragColor =vec4(jet(0.5*(uvDiv+1.0)),1);\n    #endif\n    #ifdef VORTICITY\n    fragColor =vec4(jet(0.04*(vortiticy+5.5)),1);\n    #endif\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Set initial condition / perturbation / advection / force\n\n// must be modified in all buffers and image\n// if poiseuille flow simulation\n#define LID\n// if lid-driven flow simulation\n//#define POIS\n\n// must be modified in all buffers and image\n// simulation parameters\nconst vec2 force = vec2(6.0, 0.0);\nconst float dt = 1.0/400.0;\nconst float reynold = 100.0;\n\n//macro\n#define GetVelocity(I,J) texelFetch( iChannel3, ijCoord+ivec2(I,J), 0 ).xy\n#define GetVelocityUV(X,Y) texture( iChannel3, fragCoord.xy/ iResolution.xy+vec2(X,Y)).xy\n\n// constant height bumb function\nconst float radius = 0.1; \nfloat bumbCyl(float p)\n{\n\treturn 1.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // set grid\n    float dx = 1.0 / iResolution.y;\n    float dxPow = dx *dx ;\n    vec2 uvCoord = dx*fragCoord.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n\n    // add perturbation with mouse\n    // does not conserve incompressibility\n    float pert = length((fragCoord.xy - iMouse.xy) / iResolution.y);   \n    if(iMouse.z > 0.0 && pert < radius) {\n        vec2 temp = (vec2(fragCoord.y - iMouse.y,-fragCoord.x + iMouse.x)/ iResolution.y)/radius;\n        fragColor = bumbCyl(pert)*vec4(temp,0,0);\n        return;\n    }\n    \n    // advect via semi-lagrangian method\n    vec2 uv = GetVelocity(0,0);\n    vec2 uvAdv = GetVelocityUV( -uv.x*dt,-uv.y*dt);\n    \n    // add driving force\n    #ifdef POIS\n    uvAdv += dt*force/reynold;\n    #endif\n    \n    fragColor = vec4(uvAdv, 0, 0); \n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// solve for diffusion\n\n// must be modified in all buffers and image\n// if poiseuille flow simulation\n#define LID\n// if lid-driven flow simulation\n//#define POIS\n\n// must be modified in all buffers and image\n// simulation parameters\nconst float dt = 1.0/400.0;\nconst float reynold = 100.0;\n\n//macro\n#define GetVelocity(I,J) texelFetch( iChannel0, ijCoord+ivec2(I,J), 0 ).xy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // set grid\n    float dx = 1.0 / iResolution.y;\n    float dxPow = dx *dx ;\n    vec2 uvCoord = dx*fragCoord.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n    \n    //to compute finite difference approximaton\n    vec2 uv = GetVelocity(0,0); \n    vec2 uvip1j = GetVelocity(1,0);\n    vec2 uvim1j = GetVelocity(-1,0);\n    vec2 uvijp1 = GetVelocity(0,1);\n    vec2 uvijm1 = GetVelocity(0,-1);\n    vec2 uvijentry =  GetVelocity(-ijCoord.x,0);\n    vec2 uvijexit =  GetVelocity(-ijCoord.x+int(iResolution.x)-1,0);\n    \n    // set boundary conditions\n    #ifdef POIS\n    if(ijCoord.x ==  int(iResolution.x)-1)\n    {\n        uvip1j = uvijentry; //periodic\n    }\n    \n    if(ijCoord.x == 0)\n    {\n        uvim1j = uvijexit; //periodic\n    }\n    if(ijCoord.y ==  int(iResolution.y)-1)\n    {\n        uvijp1 = -uv; //dirichlet\n    }\n    \n    if(ijCoord.y == 0)\n    {\n        uvijm1 = -uv; //dirichlet\n    }\n    #endif\n    #ifdef LID\n    if(ijCoord.x ==  int(iResolution.x)-1)\n    {\n        uvip1j = -uv; //dirichlet\n    }\n    \n    if(ijCoord.x == 0)\n    {\n        uvim1j = -uv; //dirichlet\n    }\n    \n    if(ijCoord.y ==  int(iResolution.y)-1)\n    {\n        uvijp1 = 2.0*vec2(1.0,0.0)-uv; //dirichlet\n    }\n    \n    if(ijCoord.y == 0)\n    {\n        uvijm1 = -uv; //dirichlet\n    }\n    #endif\n    \n    //should use more than 1 iteration...\n    //solve with jacobi for new velocity with laplacian\n    float coef = dt/(dxPow*reynold);\n    vec2 uvDiff = (uv+coef*(uvip1j+uvim1j+uvijp1+uvijm1))/(1.0+4.0*coef);\n \n    \n    fragColor = vec4(uvDiff,0,0);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// solve for pressure\n\n// must be modified in all buffers and image\n// if poiseuille flow simulation\n#define LID\n// if lid-driven flow simulation\n//#define POIS\n\n// must be modified in all buffers and image\n// simulation parameters\nconst float dt = 1.0/400.0;\nconst float reynold = 100.0;\n\n//macro\n#define GetVelocity(I,J) texelFetch( iChannel1, ijCoord+ivec2(I,J), 0 ).xy\n#define GetPressure(I,J) texelFetch( iChannel2, ijCoord+ivec2(I,J), 0 ).x\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //set grid\n    float dx = 1.0 / iResolution.y;\n    float dxPow = dx *dx ;\n    vec2 uvCoord = dx*fragCoord.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n    \n    //to compute finite difference approximaton\n    vec2 uv = GetVelocity(0,0); // texture.x value of u this step\n    vec2 uvip1j = GetVelocity(1,0);\n    vec2 uvim1j = GetVelocity(-1,0);\n    vec2 uvijp1 = GetVelocity(0,1);\n    vec2 uvijm1 = GetVelocity(0,-1);\n    \n    vec2 uvijentry =  GetVelocity(-ijCoord.x,0);\n    vec2 uvijexit =  GetVelocity(-ijCoord.x+int(iResolution.x)-1,0);\n    \n    //to compute finite difference approximaton\n    float p = GetPressure(0,0); // texture.x value of u this step\n    float pip1j = GetPressure(1,0);\n    float pim1j = GetPressure(-1,0);\n    float pijp1 = GetPressure(0,1);\n    float pijm1 = GetPressure(0,-1);\n    \n    float pijentry =  GetPressure(-ijCoord.x,0);\n    float pijexit =  GetPressure(-ijCoord.x+int(iResolution.x)-1,0);\n    \n    // set boundary conditions\n     #ifdef POIS\n    if(ijCoord.x ==  int(iResolution.x)-1)\n    {\n        uvip1j = uvijentry; //periodic\n        pip1j = pijentry; //periodic\n    }\n    if(ijCoord.x == 0)\n    {\n        uvim1j = uvijexit; //periodic\n        pim1j = pijexit; //periodic\n    }\n    if(ijCoord.y ==  int(iResolution.y)-1)\n    {\n        uvijp1 = -uv; //dirichlet\n        pijp1 = p;    //neumann\n    }\n    \n    if(ijCoord.y == 0)\n    {\n        uvijm1 =  -uv;//dirichlet\n        pijm1 = p;//neumann\n    }\n    #endif\n    #ifdef LID\n    if(ijCoord.x ==  int(iResolution.x)-1)\n    {\n        uvip1j = -uv;//dirichlet\n        pip1j = p;//neumann\n    }\n    if(ijCoord.x == 0)\n    {\n        uvim1j = -uv;//dirichlet\n        pim1j = p;//neumann\n    }\n    \n    if(ijCoord.y ==  int(iResolution.y)-1)\n    {\n        uvijp1 = 2.0*vec2(1.0,0.0)-uv;//dirichlet\n        pijp1 = p;//neumann\n    }\n    \n    if(ijCoord.y == 0)\n    {\n        uvijm1 =  -uv;//dirichlet\n        pijm1 = p;//neumann\n    }\n    #endif\n    \n    // compute velocity divergence\n    float divergence = 0.5*(uvip1j.x-uvim1j.x+uvijp1.y-uvijm1.y)/dx;\n    divergence*= reynold/dt;\n    \n    // should use more than 1 iteration...\n    // compute pressure (auxiliary) via jacobi iteration... \n    float phi = 0.25*((pip1j+pim1j)+(pijp1+pijm1)-dxPow*divergence);\n        \n        \n    fragColor = vec4(phi,dt*divergence/reynold,0,0);\n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// project for incompressibility\n\n// must be modified in all buffers and image\n// if poiseuille flow simulation\n#define LID\n// if lid-driven flow simulation\n//#define POIS\n\n// must be modified in all buffers and image\n// simulation parameters\nconst float dt = 1.0/400.0;\nconst float reynold = 100.0;\n\n//macro\n#define GetVelocity(I,J) texelFetch( iChannel1, ijCoord+ivec2(I,J), 0 ).xy\n#define GetPressure(I,J) texelFetch( iChannel2, ijCoord+ivec2(I,J), 0 ).x\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //set grid\n    float dx = 1.0 / iResolution.y;\n    float dxPow = dx *dx ;\n    vec2 uvCoord = dx*fragCoord.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n\n    \n    //to compute finite difference approximaton\n    vec2 uv = GetVelocity(0,0); \n    \n    //to compute finite difference approximaton\n    float p = GetPressure(0,0); // texture.x value of u this step\n    float pip1j = GetPressure(1,0);\n    float pim1j = GetPressure(-1,0);\n    float pijp1 = GetPressure(0,1);\n    float pijm1 = GetPressure(0,-1);\n    \n    float pijentry =  GetPressure(-ijCoord.x,0);\n    float pijexit =  GetPressure(-ijCoord.x+int(iResolution.x)-1,0);\n    \n    \n    \n     // set boundary conditions\n     #ifdef POIS\n    if(ijCoord.x ==  int(iResolution.x)-1)\n    {\n        pip1j = pijentry; //periodic\n    }\n    if(ijCoord.x == 0)\n    {\n        pim1j = pijexit; //periodic\n    }\n    if(ijCoord.y ==  int(iResolution.y)-1)\n    {\n        pijp1 = p;    //neumann\n    }\n    \n    if(ijCoord.y == 0)\n    {\n        pijm1 = p;//neumann\n    }\n    #endif\n    #ifdef LID\n    if(ijCoord.x ==  int(iResolution.x)-1)\n    {\n        pip1j = p;//neumann\n    }\n    if(ijCoord.x == 0)\n    {\n        pim1j = p;//neumann\n    }\n    \n    if(ijCoord.y ==  int(iResolution.y)-1)\n    {\n        pijp1 = p;//neumann\n    }\n    \n    if(ijCoord.y == 0)\n    {\n        pijm1 = p;//neumann\n    }\n    #endif\n    \n    //compute gradiant of pressure\n    vec2 pGrad = 0.5*vec2(pip1j-pim1j, pijp1-pijm1)/dx;\n    pGrad*= dt/reynold;\n    \n    //projection (helmholtz-hodge) to obtain divergence free\n    vec2 uvProj = uv-pGrad;\n    \n    fragColor = vec4(uvProj,  reynold*pGrad/dt);\n}","name":"Buf D","description":"","type":"buffer"}]}