{"ver":"0.1","info":{"id":"MfKcz3","date":"1732198999","viewed":31,"name":"Spiraling tunnel","username":"congodin","description":"cool shader","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["tunnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ancient Egyptian Hyperspace Tunnel with adjusted lighting\n#define HSAMPLES 128\n#define MSAMPLES 32\n\nfloat hieroglyphWall(vec2 p, float z) {\n    vec2 gp = fract(p * 2.0) - 0.5;\n    vec2 id = floor(p * 2.0);\n    \n    float charType = fract(sin(dot(id, vec2(12.9898, 78.233))) * 43758.5453);\n    \n    gp *= 0.7;\n    \n    float d = 999.0;\n    \n    if (charType < 0.3) {\n        // Standing figure\n        float body = length(gp * vec2(0.4, 1.0)) - 0.2;\n        float head = length(gp - vec2(0.0, 0.25)) - 0.08;\n        float arms = min(\n            length((gp - vec2(-0.15, 0.1)) * vec2(1.0, 0.3)) - 0.06,\n            length((gp - vec2(0.15, 0.1)) * vec2(1.0, 0.3)) - 0.06\n        );\n        d = min(min(body, head), arms);\n    } \n    else {\n        if (charType < 0.5) {\n            // Ankh\n            float circle = length(gp - vec2(0.0, 0.15)) - 0.12;\n            float stem = abs(gp.x) + smoothstep(-0.3, 0.3, gp.y) - 0.06;\n            d = min(circle, stem);\n        }\n        else if (charType < 0.7) {\n            // Eye of Horus\n            float eye = length(gp * vec2(1.8, 1.0)) - 0.18;\n            float detail = abs(gp.x + gp.y * 0.5) - 0.04;\n            d = min(eye, detail);\n        }\n        else {\n            // Cartouche with details\n            float frame = max(abs(gp.x) - 0.25, abs(gp.y) - 0.35);\n            float lines = abs(mod(gp.y * 8.0, 1.0) - 0.5) - 0.2;\n            d = max(frame, -lines);\n        }\n    }\n    \n    return smoothstep(0.01, 0.0, d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 ran = fract(vec4(10.5421, 22.61129, 30.7123, 35.36291) * \n                     dot(vec2(0.0149451, 0.038921), fragCoord)) - 0.5;\n    \n    vec2 p = (2.0 * (fragCoord + ran.xy) - iResolution.xy) / iResolution.y;\n    float t = iTime * 0.5;\n    float dof = dot(p, p);\n    \n    vec3 tot = vec3(0.0);\n    \n    for(int j = 0; j < MSAMPLES; j++) {\n        float msa = (float(j) + ran.z) / float(MSAMPLES);\n        float tim = t + 0.5 * (1.0/24.0) * (float(j) + ran.w) / float(MSAMPLES);\n        vec2 off = vec2(0.1 * tim, 0.0);\n        \n        vec2 q = p + dof * 0.04 * msa * vec2(cos(15.7 * msa), sin(15.7 * msa));\n        vec2 r = vec2(length(q), 0.5 + 0.5 * atan(q.y, q.x) / 3.1415927);\n        \n        vec3 uv;\n        vec3 col = vec3(0.0);\n        \n        for(int i = 0; i < HSAMPLES; i++) {\n            uv.z = (float(i) + ran.x) / float(HSAMPLES - 1);\n            \n            float wallWarp = sin(tim * 0.5 + uv.z * 3.0) * 0.1;\n            uv.xy = off + vec2(0.2 / (r.x * (1.0 - 0.6 * uv.z)), r.y + wallWarp);\n            \n            float wall = hieroglyphWall(uv.xy * 1.5, uv.z);\n            \n            if(wall > 0.5) {\n                // Darker wall colors\n                vec3 wallColor = mix(\n                    vec3(0.5, 0.45, 0.3),  // Darker sandstone\n                    vec3(0.3, 0.25, 0.15),  // Even darker sandstone\n                    wall\n                );\n                \n                // Reduced glow on hieroglyphs\n                float glyphGlow = sin(tim * 2.0 + uv.z * 6.28318) * 0.5 + 0.5;\n                col = wallColor * (1.0 + glyphGlow * 0.15);\n                col *= exp(-0.5 / (0.0001 + r.x)); // Increased darkness with distance\n                break;\n            }\n        }\n        \n        // Toned down light streaks\n        vec3 streakColor = mix(\n            vec3(0.0, 0.5, 0.8) * 0.8,  // Dimmer cyan\n            vec3(0.8, 0.3, 0.0) * 0.8,  // Dimmer orange\n            sin(r.x * 4.0 + tim) * 0.5 + 0.5\n        );\n        \n        float streaks = smoothstep(0.4, 0.9, abs(sin(atan(q.y, q.x) * 8.0 + r.x * 6.0 + tim * 2.0)));\n        col += streakColor * streaks * (1.0 - uv.z) * 0.8; // Reduced streak intensity\n        \n        // Less intense center light\n        float centerGlow = exp(-length(p) * 2.0);\n        col += vec3(0.9, 0.8, 0.6) * centerGlow * 1.5;\n        \n        tot += col;\n    }\n    \n    tot /= float(MSAMPLES);\n    \n    // Darker color correction\n    tot = 0.9 * pow(tot, vec3(0.9, 0.95, 1.0));\n    \n    // Darker atmospheric effect\n    tot += vec3(0.1, 0.15, 0.2) * (1.0 - length(p)) * 0.3;\n    \n    // Add subtle vignette\n    float vignette = smoothstep(1.5, 0.5, length(p));\n    tot *= vignette;\n    \n    fragColor = vec4(tot, 1.0);\n}","name":"Image","description":"","type":"image"}]}