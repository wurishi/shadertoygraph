{"ver":"0.1","info":{"id":"3ltGR4","date":"1575750507","viewed":149,"name":"segmented display 2","username":"pentaphobe","description":"While pondering a means to include text in path tracing I had the idea of doing a 7-segment display using capsules and bitmasks\n\n\nIntentionally messing up the distance field iterations to get a nice chrome ringing effect","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf","text","path"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// explode too much and end up with negative space\n//#define PARTICLE_EXPLODE 1\n\n// explode too much and end up with cool graphical patterns\n//#define ABSTRACT 1\n\n// hi frequency fbm to glitter the chrome\n#define GLITTER 1\n#define ROTATION 1\n\nconst float fogDistance = 7.0;\n\n/** yanked helpers\n */\nstruct ray {\n    vec3 pos;\n    vec3 dir;\n};\n    \nmat4 rotationY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\n    \nfloat smin(float a, float b, float k) {\n  float res = exp(-k * a) + exp(-k * b);\n  return -log(res) / k;\n}    \n    \n//Create the camera ray\nray create_camera_ray(vec2 uv, vec3 camPos, vec3 lookAt, float zoom){\n    vec3 f = normalize(lookAt - camPos);\n    vec3 r = cross(vec3(0.0,1.0,0.0),f);\n    vec3 u = cross(f,r);\n    vec3 c=camPos+f*zoom;\n    vec3 i=c+uv.x*r+uv.y*u;\n    vec3 dir=i-camPos;\n    return ray(camPos,normalize(dir));\n}\n\nfloat distToSphere(vec3 p, vec3 c, float r) {\n    return length(c-p)-r;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n/** end yanked helpers\n */\n\nfloat checkMask(int segMask, int bit) {\n    return (segMask & bit) == 0 ? -1. : 1.;\n}\n\nfloat segmentCharacter( vec3 p, float h, float r, int segmentMask ) {\n    float sp = h * 0.3;\n    \n    vec3 horz = vec3(h*0.75, 0., 0.);\n    return min( \n      min(\n        min(\n    \t  // topleft\n          sdCapsule(p, vec3(0.), vec3(0., h, 0.), r*checkMask(segmentMask,1)),\n          // topright\n          sdCapsule(p, vec3(-horz.x-sp, 0. , 0.), vec3(-horz.x-sp, h, 0.), r*checkMask(segmentMask,2))\n        ),\n        min(\n          // botleft\n          sdCapsule(p, vec3(0., -sp, 0.), vec3(0., -h-sp, 0.), r*checkMask(segmentMask,4)),\n          // botright\n          sdCapsule(p, vec3(-horz.x-sp, -sp, 0.), vec3(-horz.x-sp, -h-sp, 0.), r*checkMask(segmentMask,8))\n        )\n      ),\n      min(\n          min(\n            sdCapsule( p, vec3(-sp, h, 0.), vec3(0., h, 0.) - horz, r*checkMask(segmentMask, 16)),          \n        \tsdCapsule( p, vec3(-sp, 0., 0.), vec3(0.) - horz, r*checkMask(segmentMask, 32))               \t\n      \t),\n        sdCapsule( p, vec3(-sp, -h-sp, 0.), vec3(0., -h-sp, 0.) - horz, r*checkMask(segmentMask, 64))\n      \t\n      )\n    );\n}\n\nfloat dSegmentString(int[10] chars, int len, vec3 p) {\n    float leading = 0.7;\n    p.x -= float(len-1) * 0.5 * leading;\n\tfloat closest = 100.0;\n    for (int i=0; i < len; i++) {\n        int ch = chars[i];\n        float dst = segmentCharacter(p, 0.4, 0.1, ch);\n        closest = min(closest, dst);\n        p.x += leading;\n    }\n    return closest;\n}\n\nfloat fbm(vec3 p) {\n\treturn textureLod(iChannel0, p.xy*0.02, 0.2).x * 3. +\n        texture(iChannel0, p.xy*0.07).x * 0.7 +\n        texture(iChannel0, p.xy*0.13).x * 0.6;\n}\n\nfloat distToScene(vec3 p, float t) {\n    int txt[10] = int[10](\n        1+2+4+16+32, \n        1+4+16+32+64, \n        1+2+4+8+16,\n        2+8+16, \n        1+2+4+8+16+32, \n        1+2+4+16+32,\n        1+2+4+8+32, \n        1+2+4+8+16+64, \n        1+2+4+8+16+32+64,\n        1+4+16+32+64\n    );\n    \n    float pulse = sin(t*2.)*0.38;\n    #ifdef ROTATION\n    p = (vec4(p,1.0)*rotationY(sin(pow(t*.75, 0.8)) * 2. * 3.141) ).xyz;\n    #endif\n    p.y += sin(p.x*3.+t)*0.1;\n    p.z += -pulse*2.;\n    #ifdef PARTICLE_EXPLODE\n    return mod(dSegmentString(txt, 10, p) - clamp(fbm(p) * pulse, -0.05, 10.01), 20.);\n    #elif defined(ABSTRACT)\n    return mod(dSegmentString(txt, 10, p) - clamp(fbm(p) * pulse, -0.05, 10.01), 0.3);\n    #elif defined(GLITTER)\n    return dSegmentString(txt, 10, p) - clamp(fbm(p) * pulse, -0.05, 10.01) - fbm(p*4.1)*0.005;\n    #else\n    return dSegmentString(txt, 10, p) - clamp(fbm(p) * pulse, -0.05, 10.01);\n    #endif\n}\n\n//Estimate normal based on distToScene function\nconst float EPS=0.01;\nvec3 estimateNormal(vec3 p, float t){\n    float xPl=distToScene(vec3(p.x+EPS,p.y,p.z), t);\n    float xMi=distToScene(vec3(p.x-EPS,p.y,p.z), t);\n    float yPl=distToScene(vec3(p.x,p.y+EPS,p.z), t);\n    float yMi=distToScene(vec3(p.x,p.y-EPS,p.z), t);\n    float zPl=distToScene(vec3(p.x,p.y,p.z+EPS), t);\n    float zMi=distToScene(vec3(p.x,p.y,p.z-EPS), t);\n    float xDiff=xPl-xMi;\n    float yDiff=yPl-yMi;\n    float zDiff=zPl-zMi;\n    return normalize(vec3(xDiff,yDiff,zDiff));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5);\n    uv.x *= iResolution.x/iResolution.y;\n\n    float t = iTime;\n    //vec3 camPos=vec3(2.5+1.0*cos(t),1.0,1.0+0.5*sin(t));\n    vec3 camPos=vec3(0., 0., 5.);\n    //camPos = (vec4(camPos,1.0)*rotationY(t)).xyz;\n    //vec3 camPos=vec3(2.5+0.3*cos(t),1.0+sin(t*0.5)*0.01,-10.0);\n    vec3 lookAt=vec3(0., 0., 0.);\n    float zoom=1.1 + 0.01*abs(sin(pow(t*.75*2.0, 0.8)) * 2. * 3.141);              \n    ray camRay=create_camera_ray(uv,camPos,lookAt,zoom);\n\n    float totalDist=0.0;\n    float finalDist=distToScene(camRay.pos, t);\n    int iters=0;\n    int maxIters=7;\n    for(iters=0;iters<maxIters&&finalDist>0.0001;iters++){        \n        camRay.pos+=finalDist*camRay.dir;\n        totalDist+=finalDist;\n        finalDist=distToScene(camRay.pos, t);\n    }\n    //vec4 ambient=vec4(0.7, 0.8, 1., 1.);\n    vec4 ambient=vec4(0., 0., 0., 1.0);\n    //vec4 ambient=vec4(texture(iChannel1, uv), 1.);\n    float fog = 0.;\n\n    if (totalDist > fogDistance) {\n        fog = clamp(exp(totalDist-fogDistance)*0.1, 0., 0.4);\n        //ambient=vec4(.7,.8,1.,1.);\n    }\n    vec3 normal=estimateNormal(camRay.pos, t);\n    \n    vec3 lightPos=vec3(-1.5,1.4,2.);\n    \n    float lightDist = length(lightPos-camRay.pos);\n    float diffuse=dot(normal,normalize(lightPos-camRay.pos));\n    float specular=dot(normalize(lightPos-camRay.pos),reflect(normalize(camRay.pos-camPos),normal));\n    vec4 albedo = texture(iChannel0, camRay.pos.xz*16.);\n    //vec4 albedo = vec4(1.);\n    vec4 lighting = albedo*(0.25*pow(clamp(specular,0.0,1.0),200.0)+0.75*clamp(diffuse,0.0,1.0));\n    lighting += pow(texture(iChannel1, normal*0.01), vec4(2.2)) * 6.;\n    fragColor=0.1*ambient + mix(lighting*(1.5/lightDist), ambient, fog);\n}","name":"Image","description":"","type":"image"}]}