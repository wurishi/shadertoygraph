{"ver":"0.1","info":{"id":"4sKXDD","date":"1464561670","viewed":948,"name":"let it grow","username":"flockaroo","description":"grow system\npress R key to toggle automatic resolution/framerate adaptation.\n(enabled by default)","likes":45,"published":1,"flags":48,"usePreview":0,"tags":["simulation","grow","godray"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// grow system\n\n#define time float(iFrame)/30.0\n#define iChannel0Resolution iChannelResolution[0].xy\n#define iChannel1Resolution iChannelResolution[1].xy\n#define iChannel2Resolution iChannelResolution[2].xy\n#define iChannel3Resolution iChannelResolution[3].xy\n#define iChannel0Time iChannelTime[0]\n#define iChannel1Time iChannelTime[1]\n#define iChannel2Time iChannelTime[2]\n#define iChannel3Time iChannelTime[3]\n\n#define lightPos vec3(-0.06,0.30,0)\n\n#define godStrength 1.3\n#define godPower 1.5\n#define sampNum 128\n\nvec2 readRes()\n{\n    return texture(iChannel0,vec2(0.5)/iChannel0Resolution.xy).xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res=readRes();\n    vec2 ppos = fragCoord.xy/iResolution.xy*2.0-vec2(1.0);\n\n    vec3 lpos = lightPos;\n    lpos = 0.5*vec3(0.3*cos(time*0.3132*3.0),cos(time*0.534*3.0),0);\n\n    int i;\n    float sum=0.0;\n    vec4 col = vec4(0);\n    vec4 col2 = vec4(0);\n    vec2  ldistv = ppos.xy-lpos.xy;\n    float ldist=length(ldistv);\n    float amp = pow(ldist,godPower)*godStrength;\n    float amp2 = pow(ldist,1.0)*0.05;\n    vec2 delta = normalize(ppos.xy-lpos.xy);\n    for(int i=0;i<sampNum;i++)\n    {\n        vec2 ppos2;\n        vec2 texc;\n        float weight = 1.0-length((float(i))/float(sampNum));\n        float sampOffs=-(float(i))/float(sampNum);\n        ppos2 = ppos.xy+amp*sampOffs*delta;\n        texc = ppos2*0.5+vec2(0.5);\n        texc*=floor(res)/iResolution.xy;\n        col+=weight*pow(clamp(vec4(0.3)+texture(iChannel0,texc),vec4(0),vec4(1)),vec4(14.0));\n        ppos2 = ppos.xy+amp2*sampOffs*delta;\n        texc = ppos2*0.5+vec2(0.5);\n        texc*=floor(res)/iResolution.xy;\n        col2+=weight*pow(clamp(vec4(0.3)+texture(iChannel0,texc),vec4(0),vec4(1)),vec4(14.0));\n        sum+=weight;\n    }\n    col/=sum;\n    col2/=sum;\n    col=1.0*mix(col,col2,0.2);\n    fragColor = col;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// grow system\n\n#define time float(iFrame)/30.0\n#define iChannel0Resolution iChannelResolution[0].xy\n#define iChannel1Resolution iChannelResolution[1].xy\n#define iChannel2Resolution iChannelResolution[2].xy\n#define iChannel3Resolution iChannelResolution[3].xy\n#define iChannel0Time iChannelTime[0]\n#define iChannel1Time iChannelTime[1]\n#define iChannel2Time iChannelTime[2]\n#define iChannel3Time iChannelTime[3]\n//----- common ------\n\n#define MaxParticleNum 2048\n//#define MaxParticleNum 32768\n#define readSampler iChannel0\n#define InRes iChannel0Resolution\n\nstruct Particle {\n    vec4 pos;\n    vec4 quat;\n    float size;\n    int parent;\n};\n\nfloat hash(float seed)\n{\n    return fract(sin(seed)*158.5453 );\n}\n\nvec4 getRand4(float seed)\n{\n    return vec4(hash(seed),hash(seed+123.21),hash(seed+234.32),hash(seed+453.54));\n}\n\nbool isPixel(int x, int y, vec2 fragCoord) { return (int(fragCoord.x)==x && int(fragCoord.y)==y); }\nvec4 getPixel(int x, int y, sampler2D s) { vec2 res=InRes; return texture(s,(vec2(x,y)+vec2(0.5))/res); }\nvec4 getPixel(int x, int y) { return getPixel(x,y,readSampler); }\n\nint readGrowNum(sampler2D s) { return int(getPixel(0,0,s).x); }\nint readGrowNum() { return int(getPixel(0,0).x); }\nint readGrowIdx() { return int(getPixel(1,0).x); }\nvoid writeGrowNum(int num, inout vec4 fragColor, vec2 fragCoord) { if(isPixel(0,0,fragCoord)) fragColor.x=float(num); }\nvoid writeGrowIdx(int idx, inout vec4 fragColor, vec2 fragCoord) { if(isPixel(1,0,fragCoord)) fragColor.x=float(idx); }\n#define PixPerParticle 3\n#define ParticlesPerLine 128\nint XC(int idx) { return int(mod(float(idx),float(ParticlesPerLine)))*PixPerParticle; }\nint YC(int idx) { return (idx/ParticlesPerLine)+1; } // first line (y=0) reserved (e.g. for growNum, growIdx)\nint PIdx(int xc, int yc) {\n    if(xc/PixPerParticle>=ParticlesPerLine) return -1;\n    int pidx = (yc-1)*ParticlesPerLine + xc/PixPerParticle;\n    if(pidx>=MaxParticleNum) return -1;\n    return pidx;\n}\n\nvoid writeParticle( int idx, Particle p, inout vec4 fragColor, vec2 fragCoord)\n{\n    int xc = XC(idx);\n    int yc = YC(idx);\n    if (isPixel(xc+0,yc,fragCoord)) fragColor.xyzw=p.pos;\n    if (isPixel(xc+1,yc,fragCoord)) fragColor.xyzw=p.quat;\n    // not sure if framebuffer has .w, so store quat.w also in next pixel\n    if (isPixel(xc+2,yc,fragCoord)) fragColor.xyzw=vec4(p.size,p.parent,p.quat.w,1);\n}\n\nParticle readParticle( int idx )\n{\n    Particle p;\n    int xc = XC(idx);\n    int yc = YC(idx);\n    // first line (y=0) reserved (e.g. for growNum, growIdx)\n    p.pos    = getPixel(xc+0,yc);\n    p.quat   = getPixel(xc+1,yc);\n    // not sure if framebuffer has .w, so store quat.w also in next pixel\n    vec4 p2  = getPixel(xc+2,yc);\n    p.quat.w = p2.z;\n    p.size   = p2.x;\n    p.parent = int(p2.y);\n    return p;\n}\n\nvec3 readParticlePos( int idx )\n{\n    return getPixel(XC(idx),YC(idx)).xyz;\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v );\n}\n\nvec4 transformVecByQuat( vec4 v, vec4 q )\n{\n    return vec4( transformVecByQuat( v.xyz, q ), v.w );\n}\n\nvoid getEyeCoords(out vec3 right, out vec3 fwd, out vec3 up, out vec3 eye, out vec3 dir, float aspect, vec2 spos)\n{\n    float speed=1.0;\n    float elev = float(iMouse.y/iResolution.y)*0.5*1.0+0.7*sin(time*0.3*speed);\n    float azim = float(iMouse.x/iResolution.x)*0.5*1.0+0.5*time*speed;\n    right = vec3(sin(azim),cos(azim),0);\n    fwd   = vec3(vec2(-1,1)*right.yx*cos(elev),sin(elev));\n    up    = cross(right,fwd);\n    eye = -(20.0+4.0*sin(1.0*time*speed)+4.0*sin(0.65264*time*speed))*fwd+vec3(0,0,10);\n    dir = normalize(spos.x*right+spos.y*aspect*up+1.5*fwd);\n}\n\nvec2 calcScreenPos(vec3 eye, vec3 right, vec3 fwd, vec3 up, vec3 pos, float aspect)\n{\n    return vec2(dot(pos-eye,right)/dot(pos-eye,fwd)*1.5,dot(pos-eye,up)/dot(pos-eye,fwd)*1.5/aspect);\n}\n//----- update ------\n\n#define MaxGrowNum 64\n#define SplitProb 0.5\n#define SpontGrowProb 0.5\n//#define GrowAlongProb 0.98+0.02*cos(0.1*time)\n#define GrowAlongProb(pidx) ((length(readParticlePos(pidx).xyz)>20.0)?0.0:1.0)\n//#define GrowAlongProb(pidx) 0.995\n\nvec4 calcGrowQuat(vec4 quat, float randness, int index)\n{\n    vec4 randQuat = getRand4(float(index));\n    return normalize(mix(quat,(randQuat-vec4(0.5))*2.0,randness));\n}\n\nParticle GrowParticle(int index, int parentIdx, float randness)\n{\n    Particle p;\n    Particle pp = readParticle(parentIdx);\n\n    p.parent = parentIdx;\n    p.size = 1.0;\n    if(parentIdx>=0)\n    {\n        p.pos  = pp.pos + pp.size * transformVecByQuat( vec4(0,0,1,0), pp.quat );\n        p.quat = calcGrowQuat(pp.quat,randness,index);\n    }\n    else\n    {\n        vec4 rand = getRand4(float(index))-vec4(0.5);\n        p.pos  = vec4(vec3(0,0,0.1)*1.0+rand.yzw*0.03,0.0);\n        p.pos  = vec4(vec3(0,0,0),0.0);\n        p.quat = calcGrowQuat(vec4(0,0,0,1),randness,index);\n        //p.quat = rand;\n    }\n\n    return p;\n}\n\nParticle GrowAlongParticle(int index, int parentIdx)\n{\n    return GrowParticle(index, parentIdx, 0.13);\n}\n\nParticle GrowSplitParticle(int index, int parentIdx)\n{\n    return GrowParticle(index, parentIdx, 0.3);\n}\n\nParticle GrowNewParticle(int index)\n{\n    return GrowParticle(index, -1, 0.1);\n}\n\nvoid initAll( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=vec4(0.0);\n    writeGrowNum(0, fragColor, fragCoord);\n    writeGrowIdx(0, fragColor, fragCoord);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // copy old content\n    fragColor = getPixel(int(fragCoord.x),int(fragCoord.y));\n    int growNum = readGrowNum();\n    int growIdx = readGrowIdx();\n    \n    int j;\n    \n    int pIdx = int(mod(float(growIdx-growNum+MaxParticleNum),float(MaxParticleNum)));\n    j=0;\n    for(int i=0;i<MaxGrowNum;i++)\n    {\n        if(i==growNum) break;\n        int actIdx = int(mod(float(growIdx+j),float(MaxParticleNum)));\n        vec4 rnd = getRand4(float(actIdx+iFrame));\n        if(rnd.x<GrowAlongProb(pIdx))\n        {\n            writeParticle(actIdx,GrowAlongParticle(actIdx, pIdx), fragColor, fragCoord);\n            j++;\n        }\n        pIdx=int(mod(float(pIdx+1),float(MaxParticleNum)));\n    }\n    \n    for(int i=0;i<MaxGrowNum;i++)\n    {\n        if(i==MaxGrowNum-j) break;\n        int actIdx = int(mod(float(growIdx+j),float(MaxParticleNum)));\n        vec4 rnd = getRand4(float(actIdx+iFrame));\n        if(rnd.x>0.5)\n        {\n            if(rnd.z<SplitProb)\n            {\n                int pIdx = int(mod(float(growIdx-int(float(growNum)*rnd.y)+MaxParticleNum),float(MaxParticleNum)));\n                writeParticle(actIdx,GrowSplitParticle(actIdx, pIdx), fragColor, fragCoord);\n                j++;\n            }\n        }\n        else\n        {\n            if(rnd.z<SpontGrowProb)\n            {\n                writeParticle(actIdx,GrowNewParticle(actIdx), fragColor, fragCoord);\n                j++;\n            }\n        }\n    }\n\n\n    writeGrowNum(j, fragColor, fragCoord);\n    writeGrowIdx(int(mod(float(growIdx+j),float(MaxParticleNum))), fragColor, fragCoord);\n    \n    if(iFrame==0) initAll(fragColor,fragCoord);\n}\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// grow system\n\n#define time float(iFrame)/30.0\n#define iChannel0Resolution iChannelResolution[0].xy\n#define iChannel1Resolution iChannelResolution[1].xy\n#define iChannel2Resolution iChannelResolution[2].xy\n#define iChannel3Resolution iChannelResolution[3].xy\n#define iChannel0Time iChannelTime[0]\n#define iChannel1Time iChannelTime[1]\n#define iChannel2Time iChannelTime[2]\n#define iChannel3Time iChannelTime[3]\n//----- common ------\n\n#define MaxParticleNum 2048\n//#define MaxParticleNum 32768\n#define readSampler iChannel0\n#define InRes iChannel0Resolution\n\nstruct Particle {\n    vec4 pos;\n    vec4 quat;\n    float size;\n    int parent;\n};\n\nfloat hash(float seed)\n{\n    return fract(sin(seed)*158.5453 );\n}\n\nvec4 getRand4(float seed)\n{\n    return vec4(hash(seed),hash(seed+123.21),hash(seed+234.32),hash(seed+453.54));\n}\n\nbool isPixel(int x, int y, vec2 fragCoord) { return (int(fragCoord.x)==x && int(fragCoord.y)==y); }\nvec4 getPixel(int x, int y, sampler2D s) { vec2 res=InRes; return texture(s,(vec2(x,y)+vec2(0.5))/res); }\nvec4 getPixel(int x, int y) { return getPixel(x,y,readSampler); }\n\nint readGrowNum(sampler2D s) { return int(getPixel(0,0,s).x); }\nint readGrowNum() { return int(getPixel(0,0).x); }\nint readGrowIdx() { return int(getPixel(1,0).x); }\nvoid writeGrowNum(int num, inout vec4 fragColor, vec2 fragCoord) { if(isPixel(0,0,fragCoord)) fragColor.x=float(num); }\nvoid writeGrowIdx(int idx, inout vec4 fragColor, vec2 fragCoord) { if(isPixel(1,0,fragCoord)) fragColor.x=float(idx); }\n#define PixPerParticle 3\n#define ParticlesPerLine 128\nint XC(int idx) { return int(mod(float(idx),float(ParticlesPerLine)))*PixPerParticle; }\nint YC(int idx) { return (idx/ParticlesPerLine)+1; } // first line (y=0) reserved (e.g. for growNum, growIdx)\nint PIdx(int xc, int yc) {\n    if(xc/PixPerParticle>=ParticlesPerLine) return -1;\n    int pidx = (yc-1)*ParticlesPerLine + xc/PixPerParticle;\n    if(pidx>=MaxParticleNum) return -1;\n    return pidx;\n}\n\nvoid writeParticle( int idx, Particle p, inout vec4 fragColor, vec2 fragCoord)\n{\n    int xc = XC(idx);\n    int yc = YC(idx);\n    if (isPixel(xc+0,yc,fragCoord)) fragColor.xyzw=p.pos;\n    if (isPixel(xc+1,yc,fragCoord)) fragColor.xyzw=p.quat;\n    // not sure if framebuffer has .w, so store quat.w also in next pixel\n    if (isPixel(xc+2,yc,fragCoord)) fragColor.xyzw=vec4(p.size,p.parent,p.quat.w,1);\n}\n\nParticle readParticle( int idx )\n{\n    Particle p;\n    int xc = XC(idx);\n    int yc = YC(idx);\n    // first line (y=0) reserved (e.g. for growNum, growIdx)\n    p.pos    = getPixel(xc+0,yc);\n    p.quat   = getPixel(xc+1,yc);\n    // not sure if framebuffer has .w, so store quat.w also in next pixel\n    vec4 p2  = getPixel(xc+2,yc);\n    p.quat.w = p2.z;\n    p.size   = p2.x;\n    p.parent = int(p2.y);\n    return p;\n}\n\nvec3 readParticlePos( int idx )\n{\n    return getPixel(XC(idx),YC(idx)).xyz;\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v );\n}\n\nvec4 transformVecByQuat( vec4 v, vec4 q )\n{\n    return vec4( transformVecByQuat( v.xyz, q ), v.w );\n}\n\nvoid getEyeCoords(out vec3 right, out vec3 fwd, out vec3 up, out vec3 eye, out vec3 dir, float aspect, vec2 spos)\n{\n    float speed=1.0;\n    float elev = float(iMouse.y/iResolution.y)*0.5*1.0+0.7*sin(time*0.3*speed);\n    float azim = float(iMouse.x/iResolution.x)*0.5*1.0+0.5*time*speed;\n    right = vec3(sin(azim),cos(azim),0);\n    fwd   = vec3(vec2(-1,1)*right.yx*cos(elev),sin(elev));\n    up    = cross(right,fwd);\n    eye = -(20.0+4.0*sin(1.0*time*speed)+4.0*sin(0.65264*time*speed))*fwd+vec3(0,0,10);\n    dir = normalize(spos.x*right+spos.y*aspect*up+1.5*fwd);\n}\n\nvec2 calcScreenPos(vec3 eye, vec3 right, vec3 fwd, vec3 up, vec3 pos, float aspect)\n{\n    return vec2(dot(pos-eye,right)/dot(pos-eye,fwd)*1.5,dot(pos-eye,up)/dot(pos-eye,fwd)*1.5/aspect);\n}\n//----- update ------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // copy old content\n    fragColor = getPixel(int(fragCoord.x),int(fragCoord.y));\n\n    int pidx = PIdx(int(fragCoord.x),int(fragCoord.y));\n\n    if (pidx<MaxParticleNum && pidx>=0)\n    {\n\n    Particle p  = readParticle(pidx);\n    Particle pp = readParticle(p.parent);\n    if(p.parent<0) pp=p;\n    float rmax=20.0;\n    float growSpeed = 0.07/**clamp(exp((20-length(p.pos.xyz))*10.1),0.0,1.0)*/;\n    if( length(p.pos.xyz-pp.pos.xyz) < 3.0 && length(p.pos.xyz)>0.0001 )\n        p.pos.xyz += growSpeed * normalize(p.pos.xyz);\n    writeParticle(pidx, p, fragColor, fragCoord);\n    }\n}\n","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// grow system\n\n#define time float(iFrame)/30.0\n#define iChannel0Resolution iChannelResolution[0].xy\n#define iChannel1Resolution iChannelResolution[1].xy\n#define iChannel2Resolution iChannelResolution[2].xy\n#define iChannel3Resolution iChannelResolution[3].xy\n#define iChannel0Time iChannelTime[0]\n#define iChannel1Time iChannelTime[1]\n#define iChannel2Time iChannelTime[2]\n#define iChannel3Time iChannelTime[3]\n//----- common ------\n\n#define MaxParticleNum 2048\n//#define MaxParticleNum 32768\n#define readSampler iChannel0\n#define InRes iChannel0Resolution\n\nstruct Particle {\n    vec4 pos;\n    vec4 quat;\n    float size;\n    int parent;\n};\n\nfloat hash(float seed)\n{\n    return fract(sin(seed)*158.5453 );\n}\n\nvec4 getRand4(float seed)\n{\n    return vec4(hash(seed),hash(seed+123.21),hash(seed+234.32),hash(seed+453.54));\n}\n\nbool isPixel(int x, int y, vec2 fragCoord) { return (int(fragCoord.x)==x && int(fragCoord.y)==y); }\nvec4 getPixel(int x, int y, sampler2D s) { vec2 res=InRes; return texture(s,(vec2(x,y)+vec2(0.5))/res); }\nvec4 getPixel(int x, int y) { return getPixel(x,y,readSampler); }\n\nint readGrowNum(sampler2D s) { return int(getPixel(0,0,s).x); }\nint readGrowNum() { return int(getPixel(0,0).x); }\nint readGrowIdx() { return int(getPixel(1,0).x); }\nvoid writeGrowNum(int num, inout vec4 fragColor, vec2 fragCoord) { if(isPixel(0,0,fragCoord)) fragColor.x=float(num); }\nvoid writeGrowIdx(int idx, inout vec4 fragColor, vec2 fragCoord) { if(isPixel(1,0,fragCoord)) fragColor.x=float(idx); }\n#define PixPerParticle 3\n#define ParticlesPerLine 128\nint XC(int idx) { return int(mod(float(idx),float(ParticlesPerLine)))*PixPerParticle; }\nint YC(int idx) { return (idx/ParticlesPerLine)+1; } // first line (y=0) reserved (e.g. for growNum, growIdx)\nint PIdx(int xc, int yc) {\n    if(xc/PixPerParticle>=ParticlesPerLine) return -1;\n    int pidx = (yc-1)*ParticlesPerLine + xc/PixPerParticle;\n    if(pidx>=MaxParticleNum) return -1;\n    return pidx;\n}\n\nvoid writeParticle( int idx, Particle p, inout vec4 fragColor, vec2 fragCoord)\n{\n    int xc = XC(idx);\n    int yc = YC(idx);\n    if (isPixel(xc+0,yc,fragCoord)) fragColor.xyzw=p.pos;\n    if (isPixel(xc+1,yc,fragCoord)) fragColor.xyzw=p.quat;\n    // not sure if framebuffer has .w, so store quat.w also in next pixel\n    if (isPixel(xc+2,yc,fragCoord)) fragColor.xyzw=vec4(p.size,p.parent,p.quat.w,1);\n}\n\nParticle readParticle( int idx )\n{\n    Particle p;\n    int xc = XC(idx);\n    int yc = YC(idx);\n    // first line (y=0) reserved (e.g. for growNum, growIdx)\n    p.pos    = getPixel(xc+0,yc);\n    p.quat   = getPixel(xc+1,yc);\n    // not sure if framebuffer has .w, so store quat.w also in next pixel\n    vec4 p2  = getPixel(xc+2,yc);\n    p.quat.w = p2.z;\n    p.size   = p2.x;\n    p.parent = int(p2.y);\n    return p;\n}\n\nvec3 readParticlePos( int idx )\n{\n    return getPixel(XC(idx),YC(idx)).xyz;\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v );\n}\n\nvec4 transformVecByQuat( vec4 v, vec4 q )\n{\n    return vec4( transformVecByQuat( v.xyz, q ), v.w );\n}\n\nvoid getEyeCoords(out vec3 right, out vec3 fwd, out vec3 up, out vec3 eye, out vec3 dir, float aspect, vec2 spos)\n{\n    float speed=1.0;\n    float elev = float(iMouse.y/iResolution.y)*0.5*1.0+0.7*sin(time*0.3*speed);\n    float azim = float(iMouse.x/iResolution.x)*0.5*1.0+0.5*time*speed;\n    right = vec3(sin(azim),cos(azim),0);\n    fwd   = vec3(vec2(-1,1)*right.yx*cos(elev),sin(elev));\n    up    = cross(right,fwd);\n    eye = -(20.0+4.0*sin(1.0*time*speed)+4.0*sin(0.65264*time*speed))*fwd+vec3(0,0,10);\n    dir = normalize(spos.x*right+spos.y*aspect*up+1.5*fwd);\n}\n\nvec2 calcScreenPos(vec3 eye, vec3 right, vec3 fwd, vec3 up, vec3 pos, float aspect)\n{\n    return vec2(dot(pos-eye,right)/dot(pos-eye,fwd)*1.5,dot(pos-eye,up)/dot(pos-eye,fwd)*1.5/aspect);\n}\n//----- render ------\n\n#define MaxStepNum 1000\n\nvec4 checkTrunk(vec3 pos, vec3 dir, vec2 s)\n{\n    float minLen=100000000.0;\n    for(int i=0;i<MaxParticleNum;i++)\n    {\n        Particle p  = readParticle(i);\n        vec3 apos = p.pos.xyz-pos;\n        vec3 ppos = readParticlePos(p.parent)-pos;\n        if(p.parent<0 || length(ppos-apos)>5.0) continue;\n         //ppos=apos/*+transformVecByQuat(vec3(0,0,1),p.quat)*/;\n        vec3 cr =cross(dir,apos);\n        vec3 n=normalize(cross(apos-ppos,dir));\n        vec3 t=cross(n,dir);\n        float dist = abs(dot(apos,n));\n        //float r = 0.08*(1.0+0.4*sin(0.03*float(i)-5.0*time));\n        float r = 0.08;\n        if( dot(apos,dir)>0.0 ) // dont draw if behind screen\n        if( (dist<r && sign(dot(apos,t))!=sign(dot(ppos,t)))\n           || dot(cr,cr) < r*r )\n        {\n            minLen = min(dot(apos,apos),minLen);\n        }\n    }\n    return  mix(vec4(0,0,0,1),\n                mix(vec4(0.35,0.5,0.65,1.0),vec4(0.65,0.5,0.35,1.0),dir.z*0.2+0.5)*1.3, // bgcol\n                1.0-exp(-sqrt(minLen)*0.14));\n}\n\nvoid writeRes( vec2 res, inout vec4 fragColor, vec2 fragCoord )\n{\n    if (isPixel(0,0,fragCoord)) fragColor.xy=res.xy;\n}\n\nvec2 readRes()\n{\n    return getPixel(0,0,iChannel1).xy;\n}\n\n#define keyTex iChannel2\n#define KEY_R_toggle texture(keyTex,vec2((114.5-32.0)/256.0,(0.5+2.0)/3.0)).x\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res=iChannelResolution[0].xy;\n    \n    float minFPS=15.0;\n    if(iFrame>1 && KEY_R_toggle<0.5)\n    {\n        res=readRes();\n        if(iTimeDelta>1.0/minFPS) res*=0.9;\n        if(res.x<iChannelResolution[0].x) res*=1.02;\n    }\n    \n    float aspect=res.y/res.x;\n    vec2 spos = fragCoord.xy/res.xy*2.0-vec2(1.0);\n    vec3 right, fwd, up, pos, dir;\n    getEyeCoords(right,fwd,up,pos,dir,aspect,spos);\n    if(spos.x>1.0 || spos.y>1.0) discard;\n    fragColor = checkTrunk(pos,dir,spos);\n    \n    writeRes(res,fragColor,fragCoord);\n}\n","name":"Buf C","description":"","type":"buffer"}]}