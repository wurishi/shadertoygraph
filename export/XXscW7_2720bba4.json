{"ver":"0.1","info":{"id":"XXscW7","date":"1726256088","viewed":32,"name":"Raymarched tube experiment","username":"zsolt","description":"tube experiment - inspired by Martin Naumann","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["colors"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// inspired by https://www.instagram.com/p/C_cpBU8iMi4\n\nbool enableHDRI = true; // Toggle HDRI effect\nbool altColor = false; // More color perturbance\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize the pixel coordinates and adjust for aspect ratio\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Tube parameters\n    float radius = 2.0;\n    float bendAmplitude = 1.6;\n    float bendFrequency = 0.3;\n    float colorScale = 1.0;  // Scale to adjust the frequency of the color pattern\n\n    // Camera position along the tube's path\n    float time = iTime * 2.0;\n    float camAngle = bendFrequency * time;\n    vec2 camBend = vec2(sin(camAngle), cos(camAngle)) * bendAmplitude;\n    vec3 ro = vec3(camBend, time); // Ray origin on tube's path\n\n    // Calculate the target direction in the bent tube slightly ahead of current position\n    float nextTime = time + 4.1;\n    float nextCamAngle = bendFrequency * nextTime;\n    vec2 nextCamBend = vec2(sin(nextCamAngle), cos(nextCamAngle)) * bendAmplitude;\n    vec3 forward = normalize(vec3(nextCamBend, nextTime) - ro);\n\n    // Define the camera direction vectors\n    vec3 up = vec3(0.0, 1.0, 0.0); // World up vector\n    vec3 right = cross(up, forward); // Right vector of the camera\n    up = cross(forward, right); // Recalculate up vector to ensure orthogonality\n\n    // Adjusted ray direction to allow movement visualization in tube\n    vec3 rd = normalize(uv.x * right + uv.y * up - forward * 1.5); // view direction adjusted for perspective\n\n    const int maxSteps = 1000;\n    const float epsilon = 0.001;\n    vec3 p;\n    float totalDist = 0.0;\n    float distToCenter;\n    \n    // Ray marching loop\n    for (int i = 0; i < maxSteps; i++) {\n        p = ro + totalDist * rd;\n\n        // Apply tube bending to the current position\n        float angle = bendFrequency * p.z;\n        vec2 bend = vec2(sin(angle), cos(angle)) * bendAmplitude;\n        vec3 pos = vec3(p.xy - bend, p.z);\n\n        // Distance from the center of the tube\n        distToCenter = length(pos.xy) - radius;\n\n        if (abs(distToCenter) < epsilon) {\n            break; // Ray is inside the tube\n        }\n\n        // Step forward along the ray\n        totalDist += distToCenter * 0.5;\n    }\n\n    // Shading and color\n    vec3 color;\n    if (abs(distToCenter) < epsilon) {\n        // Calculate the angular position around the tube\n        float angleAroundTube = 0.0;\n        if (altColor) {\n            angleAroundTube = atan(sin(-p.y), cos(p.x));\n        } else {\n            angleAroundTube = atan(p.y, p.x);\n        }\n\n        // Dynamic colors based on sine functions and angular position, mapped to a continuous range\n        float r = 0.5 + 0.5 * sin(colorScale * angleAroundTube + p.z + iTime);\n        float g = 0.5 + 0.5 * cos(colorScale * angleAroundTube + (p.z + iTime) * 0.7);\n        float b = 0.5 + 0.5 * sin(colorScale * angleAroundTube + (p.z - iTime) * 0.9);\n        color = vec3(r, g, b);\n\n        // Map color to a continuous range without clamping\n        color = mod(color, 1.0);\n\n        // Calculate normal vector\n        vec3 norm = normalize(vec3(p.xy - vec2(sin(bendFrequency * p.z), cos(bendFrequency * p.z)) * bendAmplitude, 0.0));\n\n        // Spin the light source around the tube\n        float lightAngle = iTime * 0.15; // Time-based angle for spinning light\n        vec3 lightDir = normalize(vec3(sin(lightAngle), cos(lightAngle), -1.0)); // Spinning light direction\n\n        // Light shading\n        float diff = max(dot(norm, lightDir), 0.5); // Ensure some minimum lighting\n        color *= diff;\n\n        // Toggle HDRI effect\n        if (enableHDRI) {\n            // Enhancing HDRI color effect for brighter areas\n            vec3 hdriEffect = vec3(1.0) * pow(max(dot(norm, lightDir), 0.0), 2.0);\n            color += hdriEffect;\n        }\n\n        // Finally, ensure colors are within the valid range\n        color = max(vec3(0.0), min(color, vec3(1.0)));\n\n        fragColor = vec4(color, 1.0);\n    } else {\n        // Background color\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}