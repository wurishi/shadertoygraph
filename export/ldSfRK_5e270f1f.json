{"ver":"0.1","info":{"id":"ldSfRK","date":"1501096423","viewed":382,"name":"More Tentacles 1","username":"AlexM","description":"Trying some tentacles, this time with cell noise. A bit too slow though. ","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["organic","tentacles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Trying some some more tentacles.... this time with cell noise. \n#define PI 3.141592653589793 \n\nconst float MAXT = 70.0f;\nconst float FOGHEIGHT = 0.01; // background fog height. \nconst float FOGFADEHEIGHT = 0.30; // background fog fade height - fades background fog into actual sky.\nconst vec3  FOGCOLOR = vec3(0.839, 1, 0.980);\nconst float FOGDENSITY = 0.022; \n\n\nstruct TraceResult {\n    bool hit;\n    float rayt;\n    vec3 color; \n};\n\n// transformation funcs\nmat3 rotateY(float n) {\n    float a = cos(n);\n    float b = sin(n);\n    return mat3( a, 0.0, b, 0.0, 1.0, 0.0, -b, 0.0, a );\n}\n\nmat3 rotateX(float n) {\n    float a = cos(n);\n    float b = sin(n);\n    return mat3( 1.0, 0.0, 0.0, 0.0, a, -b, 0.0, b, a );\n}\n\nmat3 rotateZ(float n) {\n    float a = cos(n);\n    float b = sin(n);\n    return mat3(a, -b, 0.0, b, a, 0.0, 0.0, 0.0, 1.0);\n}\n\n// NOISE FUNCTIONS\nfloat random(in float n) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat random(in vec2 st) { \n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat random(in vec3 st) { \n    return fract(sin(dot(st,vec3(12.9898,78.233,19.124)))*43758.5453);\n}\n\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    \n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    \n    vec2 u = f*f*(3.0-2.0*f);\n    float a1 = mix(a, b, u.x);\n    float a2 = mix(c, d, u.x);\n    float a3 = mix(a1, a2, u.y);\n    return clamp(a3, 0.0, 1.0); \n}\n\nfloat noise(in vec3 st) {\n    vec3 i = floor(st);\n    vec3 x = fract(st);\n\n    float a = random(i);\n    float b = random(i + vec3(1.0, 0.0, 0.0));\n    float c = random(i + vec3(0.0, 1.0, 0.0));\n    float d = random(i + vec3(1.0, 1.0, 0.0));\n    float e = random(i + vec3(0.0, 0.0, 1.0));\n    float f = random(i + vec3(1.0, 0.0, 1.0));\n    float g = random(i + vec3(0.0, 1.0, 1.0));\n    float h = random(i + vec3(1.0, 1.0, 1.0));\n    vec3 u = x*x*(3.0-2.0*x);\n    float fa = mix(a, b, u.x);\n    float fb = mix(c, d, u.x);\n    float fc = mix(e, f, u.x);\n    float fd = mix(g, h, u.x);\n    float fe = mix(fa, fb, u.y);\n    float ff = mix(fc, fd, u.y);\n    float fg = mix(fe, ff, u.z);\n    return clamp(2.0*fg-1.0, -1.0, 1.0);\n}\n\nfloat sdSpheroid(vec3 p, vec3 s) {\n    return (length(p/s) - 1.0)  * min(s.x, min(s.y, s.z));\n}\n\nfloat sdPlane(vec3 p, vec4 n) {\n    return dot(p, n.xyz) - n.w;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat opAddSmooth( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opSubtract( float a, float b ) {\n    return max(-a,b);\n}\n\nfloat opAdd(float a, float b) {\n    return min(a,b);\n}\n\nvec3 opRepeat(vec3 p, vec3 c) {\n    return mod(p,c)-0.5*c;\n}\n\nfloat worley_smooth(vec3 p) {\n    vec3 tileCoord = floor(p);    \n    float dist = 90000.0;\n    float heightoffset = 0.0;\n    for (int z = -1; z <= 1; z++)\n    for (int y = -1; y <= 1; y++)\n    for (int x = -1; x <= 1; x++) {\n        vec3 currentTile = tileCoord + vec3(x,y,z);\n        vec3 point = currentTile + random(currentTile);\n\n        float d = distance(point, p);\n        dist = opAddSmooth(dist, d, 0.05);\n    }\n    return -dist;\n}\n\nfloat fbm(vec3 p) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 0.8;\n\n    const int octaves = 5;\n    for (int i = 0; i < octaves; i++) {\n        value += amplitude * noise(p*frequency);\n        p *= 2.;\n        amplitude *= 0.3;\n        frequency *= 1.4;\n    }\n    return value;\n}\n\nvec4 map(vec3 p) {\n    // tentacle\n    p.x -= noise(p.zz*0.2+iTime*0.04) * 2.25;\n    p.y -= noise(p.xy*0.2+iTime*0.10) * 1.20;\n    float tube = length(p.xy)-1.75; \n\n    for (int i = 1; i < 5; i++) {\n        vec3 pt = p - vec3(0.0,0.0,float(i)*20.0);\n        pt = rotateZ(1.75*float(i))*pt;\n        pt = opRepeat(pt, vec3(0.0, 0.0, 60.0));\n\n        float sphere = sdSpheroid(pt-vec3(0.0, 12.0, 0.0), vec3(6.0, 5.0, 6.0));\n        float stube = length(pt.xz) - 1.2;\n        float plane = sdPlane(pt, vec4(0.0,1.0,0.0,0.0));\n\n        stube = opSubtract(plane, stube);\n        stube = opAddSmooth(sphere, stube, 5.5);\n        tube = opAddSmooth(stube, tube, 0.75);\n    }\n\n    // outer walls\n    float box1 = length(p.xy) -12.0;\n    float box2 = length(p.xy) -10.0;\n    box1 = opSubtract(box2, box1);\n    tube = opAddSmooth(box1, tube, 4.0);\n\n    vec3 color = vec3(0.964, 0.482, 0.454); // default body color;\n    vec3 cavity_color = vec3(0.403, 0.090, 0.074); // color between cells.\n    vec3 veins_color = vec3(0.027, 0.117, 0.333);\n\n    float f = worley_smooth(p*0.5-iTime*0.04)*0.7;\n    color = mix(color, cavity_color, abs(f)*2.5);  \n\n    // veins @OPTIMIZE this is still slow!!! \n    float a = 0.25*(1.0-abs(fbm(p*1.0+iTime*0.06))); \n    float c = 0.01*(1.0-abs(fbm(p*9.2+iTime*0.03))); \n    float veins = a+c;\n    float sm = smoothstep(0.0, 1.0, veins*2.0);\n    color = mix(color, veins_color, sm);\n\n    return vec4((tube-f-veins)*0.75, color);\n}\n\nTraceResult trace(vec3 ro, vec3 rd) {\n    TraceResult traceResult = TraceResult(false, 0.0, vec3(0.0));\n    float t = 0.02;\n    float tmax = MAXT; \n    for (;t < tmax;) {\n        vec3 rp = ro + rd * t;\n        vec4 tr = map(rp);\n        if (tr.x<0.001) {\n            traceResult = TraceResult(true, t, tr.yzw);\n            break;\n        }\n        t += tr.x;\n    }\n    traceResult.rayt = t;\n    return traceResult;\n}\n\n\nvec3 calcNormal(vec3 p) {\n    vec2 eps = vec2(0.001,0.0);\n    float x = map(p+eps.xyy).x-map(p-eps.xyy).x;\n    float y = map(p+eps.yxy).x-map(p-eps.yxy).x;\n    float z = map(p+eps.yyx).x-map(p-eps.yyx).x;\n    return normalize(vec3(x,y,z));\n}\n\n// based on a function in IQ's shadertoy \n//https://www.shadertoy.com/view/Xdl3R4\nfloat calcSurfaceThickness(vec3 ro, vec3 rd, float p) {\n    float w = 1.0;\n    float a = 0.0;\n    const int numsteps = 4;\n    for (int t = 1; t <= numsteps; t++) {\n        float rt = 0.1*float(t); \n        float d = map(ro+rt*rd).x;\n        a += w*(rt-min(d,0.0));\n        w *= 0.9;\n    }\n\n    return pow(clamp(1.2-0.25*a, 0.0, 1.0), p);\n}\n\nfloat calcAO(vec3 p, vec3 n) {\n    float w = 1.0;\n    float a = 0.0;\n    const int maxsteps = 4;\n    for (int t = 1; t <= maxsteps; t++) { \n        float rt = 0.2*float(t);\n    \ta += w*(rt-map(p+rt*n).x);   \n        w *= 0.8;\n    }\n    \n    return clamp(1.0-a, 0.0, 1.0);\n}\n\n//@l - light direction, normalized;\n//@n - surface normal, normalized;\nfloat phongDiffuseFactor(vec3 l, vec3 n) {\n    return max(0.0, dot(l,n));\n}\n\n//@l - light direction, normalized;\n//@n - surface normal, normalized;\n//@v - view direction, normalized;\n//@k - shininess constant;\nfloat phongSpecularFactor(vec3 l, vec3 n, vec3 v, float k) {\n    vec3 r = normalize(reflect(l, n));\n    return pow(max(0.0, dot(r, v)), k);\n}\n\nfloat fog(float dist) {\n    return  1.0 - 1.0/exp(pow(dist*FOGDENSITY, 2.0));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy / iResolution.xy;\n    float finv = tan(90.0 * 0.5 * PI / 180.0);\n    float aspect = iResolution.x / iResolution.y;\n    st.x = st.x * aspect;\n    st = (st - vec2(aspect * 0.5, 0.5)) * finv;\n\n    vec3 rd = normalize(vec3(st, 1.0));\n    rd = rotateY(-iMouse.x*0.008) * rotateX(iMouse.y*0.004)* rd;\n    rd = normalize(rd);\n\n    vec3 ro = vec3(2.0, 4.0, 0.0); \n    ro += iTime*0.3*normalize(vec3(0.0, 0.0, 1.0));\n\n    vec3 color = FOGCOLOR;\n    TraceResult traceResult = trace(ro, rd);\n    if (traceResult.hit) {\n\n        vec3 rp = ro+traceResult.rayt*rd;\n\n        vec3 n = calcNormal(rp);\n\n        // calculate surface thickness \n        float thickness = calcSurfaceThickness(rp-n*0.01, rd, 20.0) * 4.0;\n        float ao = calcAO(rp, n);\n\n        vec3 c = traceResult.color;\n\n        vec3 SUNDIRECTION = rd;\n        float ph = 0.5*ao + phongDiffuseFactor(-SUNDIRECTION, n) * 0.5 \n                          + phongSpecularFactor(-SUNDIRECTION,n, rd, 50.0) * 0.5;\n        float ph2 = phongDiffuseFactor(-SUNDIRECTION, n) ;\n        color = ph*c+c*thickness;\n        color = mix(color, FOGCOLOR, fog(traceResult.rayt));\n    }\n\n    color = clamp(color, 0.0, 1.0);\n    fragColor = vec4(color, 1.0); \n}","name":"Image","description":"","type":"image"}]}