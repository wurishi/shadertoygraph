{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// by srtuss, 2013\n// I love complex machines! :)\n// Still could use some optimisation.\n\n// * improved gears\n// * improved camera movement\n\nfloat hash(float x)\n{\n\treturn fract(sin(x) * 43758.5453);\n}\n\nvec2 hash(vec2 p)\n{\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n\treturn fract(sin(p) * 43758.5453);\n}\n\n// simulates a resonant lowpass filter\nfloat mechstep(float x, float f, float r)\n{\n\tfloat fr = fract(x);\n\tfloat fl = floor(x);\n\treturn fl + pow(fr, 0.5) + sin(fr * f) * exp(-fr * 3.5) * r;\n}\n\n// voronoi cell id noise\nvec3 voronoi(in vec2 x)\n{\n\tvec2 n = floor(x);\n\tvec2 f = fract(x);\n\n\tvec2 mg, mr;\n\t\n\tfloat md = 8.0;\n\tfor(int j = -1; j <= 1; j ++)\n\t{\n\t\tfor(int i = -1; i <= 1; i ++)\n\t\t{\n\t\t\tvec2 g = vec2(float(i),float(j));\n\t\t\tvec2 o = hash(n + g);\n\t\t\tvec2 r = g + o - f;\n\t\t\tfloat d = max(abs(r.x), abs(r.y));\n\t\t\t\n\t\t\tif(d < md)\n\t\t\t{\n\t\t\t\tmd = d;\n\t\t\t\tmr = r;\n\t\t\t\tmg = g;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn vec3(n + mg, mr);\n}\n\nvec2 rotate(vec2 p, float a)\n{\n\treturn vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n}\n\nfloat stepfunc(float a)\n{\n\treturn step(a, 0.0);\n}\n\nfloat fan(vec2 p, vec2 at, float ang)\n{\n\tp -= at;\n\tp *= 3.0;\n\t\n\tfloat v = 0.0, w, a;\n\tfloat le = length(p);\n\t\n\tv = le - 1.0;\n\t\n\tif(v > 0.0)\n\t\treturn 0.0;\n\t\n\ta = sin(atan(p.y, p.x) * 3.0 + ang);\n\t\n\tw = le - 0.05;\n\tv = max(v, -(w + a * 0.8));\n\t\n\tw = le - 0.15;\n\tv = max(v, -w);\n\t\n\treturn stepfunc(v);\n}\n\nfloat gear(vec2 p, vec2 at, float teeth, float size, float ang)\n{\n\tp -= at;\n\tfloat v = 0.0, w;\n\tfloat le = length(p);\n\t\n\tw = le - 0.3 * size;\n\tv = w;\n\t\n\tw = sin(atan(p.y, p.x) * teeth + ang);\n\tw = smoothstep(-0.7, 0.7, w) * 0.1;\n\tv = min(v, v - w);\n\t\n\tw = le - 0.05;\n\tv = max(v, -w);\n\t\n\treturn stepfunc(v);\n}\n\nfloat car(vec2 p, vec2 at)\n{\n\tp -= at;\n\tfloat v = 0.0, w;\n\tw = length(p + vec2(-0.05, -0.31)) - 0.03;\n\tv = w;\n\tw = length(p + vec2(0.05, -0.31)) - 0.03;\n\tv = min(v, w);\n\t\n\tvec2 box = abs(p + vec2(0.0, -0.3 - 0.07));\n\tw = max(box.x - 0.1, box.y - 0.05);\n\tv = min(v, w);\n\treturn stepfunc(v);\n}\n\nfloat layerA(vec2 p, float seed)\n{\n\tfloat v = 0.0, w, a;\n\t\n\tfloat si = floor(p.y);\n\tfloat sr = hash(si + seed * 149.91);\n\tvec2 sp = vec2(p.x, mod(p.y, 4.0));\n\tfloat strut = 0.0;\n\tstrut += step(abs(sp.y), 0.3);\n\tstrut += step(abs(sp.y - 0.2), 0.1);\n\t\n\tfloat st = iTime + sr;\n\tfloat ct = mod(st * 3.0, 5.0 + sr) - 2.5;\n\t\n\tv = step(2.0, abs(voronoi(p + vec2(0.35, seed * 194.9)).x));\n\t\n\tw = length(sp - vec2(-2.0, 0.0)) - 0.8;\n\tv = min(v, 1.0 - step(w, 0.0));\n\t\n\t\n\ta = st;\n\tw = fan(sp, vec2(2.5, 0.65), a * 40.0);\n\tv = min(v, 1.0 - w);\n\t\n\t\n\treturn v;\n}\n\nfloat layerB(vec2 p, float seed)\n{\n\tfloat v = 0.0, w, a;\n\t\n\tfloat si = floor(p.y / 3.0) * 3.0;\n\tvec2 sp = vec2(p.x, mod(p.y, 3.0));\n\tfloat sr = hash(si + seed * 149.91);\n\tsp.y -= sr * 2.0;\n\t\n\tfloat strut = 0.0;\n\tstrut += step(abs(sp.y), 0.3);\n\tstrut += step(abs(sp.y - 0.2), 0.1);\n\t\n\tfloat st = iTime + sr;\n\t\n\tfloat cs = 2.0;\n\tif(hash(sr) > 0.5)\n\t\tcs *= -1.0;\n\tfloat ct = mod(st * cs, 5.0 + sr) - 2.5;\n\n\t\n\tv = step(2.0, abs(voronoi(p + vec2(0.35, seed * 194.9)).x) + strut);\n\t\n\tw = length(sp - vec2(-2.3, 0.6)) - 0.15;\n\tv = min(v, 1.0 - step(w, 0.0));\n\tw = length(sp - vec2(2.3, 0.6)) - 0.15;\n\tv = min(v, 1.0 - step(w, 0.0));\n\t\n\tif(v > 0.0)\n\t\treturn 1.0;\n\t\n\t\n\tw = car(sp, vec2(ct, 0.0));\n\tv = w;\n\t\n\tif(hash(si + 81.0) > 0.5)\n\t\ta = mechstep(st * 2.0, 20.0, 0.4) * 3.0;\n\telse\n\t\ta = st * (sr - 0.5) * 30.0;\n\tw = gear(sp, vec2(-2.0 + 4.0 * sr, 0.5), 8.0, 1.0, a);\n\tv = max(v, w);\n\t\n\tw = gear(sp, vec2(-2.0 + 0.65 + 4.0 * sr, 0.35), 7.0, 0.8, -a);\n\tv = max(v, w);\n\tif(hash(si - 105.13) > 0.8)\n\t{\n\t\tw = gear(sp, vec2(-2.0 + 0.65 + 4.0 * sr, 0.35), 7.0, 0.8, -a);\n\t\tv = max(v, w);\n\t}\n\tif(hash(si + 77.29) > 0.8)\n\t{\n\t\tw = gear(sp, vec2(-2.0 - 0.55 + 4.0 * sr, 0.30), 5.0, 0.5, -a + 0.7);\n\t\tv = max(v, w);\n\t}\n\t\n\treturn v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n\tvec2 p = uv;\n\tp.x *= iResolution.x / iResolution.y;\n\t\n\tfloat t = iTime;\n\t\n\tvec2 cam = vec2(sin(t) * 0.2, t);\n\t\n\t// for future use\n\t/*float quake = exp(-fract(t) * 5.0) * 0.5;\n\tif(quake > 0.001)\n\t{\n\t\tcam.x += (hash(t) - 0.5) * quake;\n\t\tcam.y += (hash(t - 118.29) - 0.5) * quake;\n\t}*/\n\t\n\tp = rotate(p, sin(t) * 0.02);\n\t\n\tvec2 o = vec2(0.0, t);\n\tfloat v = 0.0, w;\n\t\n\t\n\tfloat z = 3.0 - sin(t * 0.7) * 0.1;\n\tfor(int i = 0; i < 5; i ++)\n\t{\n\t\tfloat f = 1.0;\n\t\t\n\t\tfloat zz = 0.3 + z;\n\t\t\n\t\tf = zz * 2.0 * 0.9;\n\t\t\n\t\t\n\t\tif(i == 3 || i == 1)\n\t\t\tw = layerA(vec2(p.x, p.y) * f + cam, float(i));\n\t\telse\n\t\t\tw = layerB(vec2(p.x, p.y) * f + cam, float(i));\n\t\tv = mix(v, exp(-abs(zz) * 0.3 + 0.1), w);\n\t\t\n\t\t\n\t\tz -= 0.6;\n\t}\n\t\n\t\n\t\n\t\n\tv = 1.0 - v;// * pow(1.0 - abs(uv.x), 0.1);\n\t\n\tfragColor = vec4(v, v, v, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Msf3D7","date":"1373111520","viewed":3779,"name":"Industry","username":"srtuss","description":"Beeing creative in 2D. :)","likes":141,"published":1,"flags":0,"usePreview":0,"tags":["2d","voronoi","mechanic","technology"],"hasliked":0,"parentid":"","parentname":""}}