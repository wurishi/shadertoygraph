{"ver":"0.1","info":{"id":"XsG3zm","date":"1453658309","viewed":1461,"name":"binoculars","username":"nicoptere","description":"a 2D transition","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","effect","transition"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 rgb = vec3( uv, 0.5+0.5*sin( iTime ) );\n\tvec3 color = vec3(0.);\n    \n    float radius = 0.5 + cos( iTime ) * .5;\n    float gradientLength = abs( sin( iTime * 3. ) * .1 );\n    \n    //the 'binoculars'\n    //get a normalized screen position in the range [-1,1]\n    vec2 p =  2. * ( fragCoord.xy / iResolution.xy ) - 1.;\n    //with the same aspect ratio as the screen\n    p.x *= iResolution.x / iResolution.y;\n\n    //left eye / right eye\n    vec2 le = vec2( -.4, 0. );\n    vec2 re = vec2(  .4, 0. );\n\n    //we'll compute a distance to the eyes' locations and a radius\n    //beyond which we'll use a flat color d is the union of the 2 eyes\n    float d = max(  ( 1.-( distance( p, le ) * radius )  ) ,  ( 1.-( distance( p, re ) * radius )  ) );\n\n    //if d < .5 -> transparent\n    //if d > .5 -> opaque color\n    // .55 - .5 = 0.05 : that's the opaque to transparent gradient's length\n    rgb = mix( color, rgb, smoothstep( 0.5, 0.5 + gradientLength, d ) );\n    fragColor = vec4( rgb, 1. );\n    \n}","name":"","description":"","type":"image"}]}