{"ver":"0.1","info":{"id":"Md3GW7","date":"1450002686","viewed":201,"name":"Donuts Time!","username":"tom_D","description":"It's my first ray marching!","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["donuts"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"/**\n* \t\t\t\t\t\t\t\t!!First RayMarching!!\n*/\n#define R iResolution\n#define T iTime\n\nvec3 ro;\nvec3 rd;\nvec3 light;\nvec3 dir;\nstruct RAY\n{\n    vec3 p;\n    float l;\n    float d;\n};\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n    \n    \nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n} \nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n    \nfloat plane(in vec3 p, vec4 n) \n{ \n    return dot(p, n.xyz) + n.w;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n    \nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}    \n\nfloat sphere(in vec3 p, vec4 s)\n{\n    return (length(p - s.xyz) - s.w);\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n \n  return length(q)-t.y;\n}\n\nfloat blob(float a, float b, float coef)\n{\n    return dot(a, b) / coef;\n}\n\nmat3 rotz(float c, float s)\n{\n    return mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n}\n\nmat3 roty(float c, float s)\n{\n    return mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n}\n\nmat3 rotx(float c, float s)\n{\n    return mat3(1, 0, 0, 0, c, -s, 0, s, c);\n}\n\nvec3 setrotate(float angle, int y, vec3 p, int angle_true)\n{\t\n    float a;\n  \tif (angle_true == 0)\n\t a = radians(iTime * angle);\n    else if (angle_true == 1)\n         a = radians(angle);\n \tfloat c = cos(a);\n    float s = sin(a);\n    if (y == 0)\n        p *= rotx(c, s);\n    else if (y == 1)\n        p *= roty(c, s);\n    else if (y == 2)\n        p *= rotz(c, s);\n\treturn p;\n}\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n /*float getSphere = sphere(p, vec4(setSphere, 2.)); */\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat scene(in vec3 p)\n{\t\n    vec3 res = vec3(0);\n    vec4 plan = vec4(0.,1.,0.,2.);\n    vec3 uv = vec3(0);     \t \t\n   \tres = p;\n    p.y += -4.0;\n    p.z += 0.5;\n    p = setrotate(60., 0, p, 0);\n   \n\tfloat last = sdTorus82(p, vec2(2., .4));\t\n    \n    p = setrotate(80., 0, p, 0);\n    float ret = sdTorus82(p, vec2(5., 0.4));\n    p = setrotate(90., 2, p, 0);\n    float a = sdTorus82(p, vec2(3., .5));\n    p = res;\n    p.y += -4.0;\n    p.z += 0.5;\n    p = setrotate(80., 1, p, 0);\n   \tp = setrotate(80., 0, p, 0);\n    float b = sdTorus82(p, vec2(6., .2));\n    p = res;\n    p.y += -4.0;\n    p.z += 0.5;\n    p = setrotate(40., 1, p, 0);\n    float c = sdTorus82(p, vec2(1., .2));\n    \n    p = res;\n    p.x += 17.0;\n    p.y += 0.0;\n    p.z += -6.0;\n    p = setrotate(0., 1, p, 1);\n    float sed = sdCappedCylinder(p, vec2(1.5, 5.0));\n    \n    p = res;\n    p.x += 17.0;\n    p.y += -5.0;\n    p.z += -6.0;\n    p = setrotate(90., 1, p, 1);\n   \tp = setrotate(-5., 0, p, 1);\n   \tfloat sedx = sdCappedCylinder(p, vec2(1.5, 5.0));\n    p = res;\n    float getPlane = plane(p, plan);\n    p = res;\n    p.x  += -14.0;  p.z += -6.0; \n    float mart = sdCappedCylinder(p, vec2(1.5, 5.0));\n    p = res;\n   \tp.x += -16.0;\n    p.z += -6.0;\n    p.y += -2.0;\n    p = setrotate(-30., 1, p, 1);\n    float mar = sdCappedCylinder(p, vec2(1.5, 3.0));\n     p = res;\n    p.x += -20.0;\n    p.z += -6.0;\n    p.y += -2.0;\n    p = setrotate(30., 1, p, 1);\n    float ma = sdCappedCylinder(p, vec2(1.5, 3.0));\n\tp = res;\n    p.x += -22.0;\n    p.z += -6.0;\n    float sma = sdCappedCylinder(p, vec2(1.5, 5.0));\n    \n    p = res;\n    p = setrotate(50., 0, p, 0);\n   \n    return (min(min(min(min(min(min(min(min(min(min(min(getPlane, last), ret), a), b), c), sedx), sed), mart), mar), ma), sma));\n}\n    \nRAY trace(float maxd)\n{\n    RAY r = RAY(ro, 2., .001);\n    for (int i = 0; i < 128; ++i)\n    {\n        if (abs(r.d) < .001 || r.l > maxd)\n            break;\n        r.l += r.d;\n        r.p = ro + rd * r.l;\n        r.d = scene(r.p);\n    }\n    return r;\n}\nvoid init(in vec2 uv)\n{\n    ro = vec3(0., 4.5, -10.5);\n    rd = normalize(vec3(uv, 1));\n    light = vec3(0, 2, -8);\n    dir = normalize(vec3(0, 0, -1));\n}\n    \nvoid mainImage(out vec4 C, in vec2 U)\n{\n    C.rgb = vec3(0);\n\tvec2 uv = 2. * U.xy / R.xy - 1.;\n    uv.x *= R.x / R.y;\n    init(uv);\n    RAY r = trace(100.);\n    if (r.l < 100.)\n    {\n       // light here\n        vec3 c = mix(vec3(0.,.001,.001), vec3(.001,.001,.001), vec3(-r.p.z));\n        vec3 e = vec3(.00001, 0, 0);\n        vec3 n = vec3(r.d) - vec3(scene(r.p - e.xyy), scene(r.p - e.yxy), scene(r.p - e.yyx));\n        float b = dot(normalize(n), normalize(light - r.p));\n        C.rgb = (b * c + 1.0 * pow(b, 42.)) * (1. - r.l * -55.09);\n   \n    }\n}","name":"","description":"","type":"image"}]}