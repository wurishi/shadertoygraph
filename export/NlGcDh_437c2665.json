{"ver":"0.1","info":{"id":"NlGcDh","date":"1661334072","viewed":218,"name":"Metaballs in 3D","username":"GCScholar","description":"Metaballs in 3D","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["metaballs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Francesco S. Spoto\n//\n// The total field is generated the sum of a baunch of 3D fields with a quintic falloff.\n//\n// First ray trace the scene (fields bounding spheres) to get the nearest total field point,\n// then ray march inside it until the searched isosurface.\n//\n// I will use the quintic polinomial as falloff, that avoid discontinuities in the normals,\n// as shown by IQ in https://www.shadertoy.com/view/ld2GRz (tnx 🙏).\n//\n\nMaterial getMaterial(int matId, int objId)\n{\n    Material mat;\n    mat.albedo = vec3(1);\n    mat.albedo = samplePalette(float(objId*60)/800.);\n    return mat;\n}\n\n// Render a field hit.\nvec3 render(vec3 eye, Hit hit)\n{\n    // No hit -> background\n    if(hit.objId == -1) return vec3(0);\n    \n    // Get the material of the hitten object at the hitten point\n    //Material mat = getMaterial(hit.objId, 6);\n    Material mat;\n    mat.albedo = hit.color;\n    \n    // Lights in the scene\n    vec3 KeyLightPos = vec3(0,1,0);\n    vec3 KeyLightColor = vec3(0.5,0.8,0.1);\n    vec3 fillLightPos = vec3(0,1,0);\n    vec3 fillLightColor = vec3(0.65);\n    vec3 backLightPos = vec3(-1,-1,-1);\n    vec3 backLightColor = vec3(0.5);\n    \n    vec3 ambientLight = vec3(0.1,0.1,0.1);\n    \n    // Vector used in the computation of lighting\n    vec3 N = hit.normal;               // Surface normal\n    vec3 L = normalize(KeyLightPos);   // To light dir\n    vec3 V = normalize(eye-hit.point); // To eye vector\n    vec3 H = normalize(V+L);           // Half vector between to light direction and to eye direction\n    vec3 R = reflect(-L,N);\n    \n    // Compute different light components\n    vec3 ambient = ambientLight * mat.albedo;\n    vec3 diffuse = max(dot(N,L),0.) * KeyLightColor * mat.albedo;\n    diffuse += max(dot(N,normalize(fillLightPos)),0.) * fillLightColor * mat.albedo;\n    diffuse += max(dot(N,normalize(backLightPos)),0.) * backLightColor * mat.albedo;\n    \n    diffuse += 0.07*texture(iChannel0, R).xyz;\n    float specular = pow(max(dot(R,V),0.),10.);\n    float fresnel = 0.2 * pow(1.+dot(N,-V),4.);\n    return diffuse + 0.4*specular + 2.*fresnel;    \n}\n\n// A field function\nstruct Field\n{\n    vec3 position;\n    float radius;\n};\n\n// Define the number of functions (scalar fields) that generate the total field\n#define N_FIELDS 8\nField fields[N_FIELDS] = Field[N_FIELDS]\n(\n     Field(vec3(0,0,0),1.)\n    ,Field(vec3(0,0,0),2.)\n    ,Field(vec3(0,0,0),3.)\n    ,Field(vec3(0,0,0),4.)\n    ,Field(vec3(0,0,0),5.)\n    ,Field(vec3(0,0,0),2.)\n    ,Field(vec3(0,0,0),3.)\n    ,Field(vec3(0,0,0),4.)\n);\n \n// Get the value of the falloff function and the derivative for a value of x in [0,1]\nvoid getFalloff(float x, out float f)\n{\n    f = 0.;\n    if(x<0.01||x>1.) return; // Field is 0 outside [0,1]\n    \n    // Quintic falloff 1-6x^5 - 15x^4 + 10x^3\n    f = 1.-(x*x*x*(6.*x*x-15.*x + 10.));\n}\n\n// Get the falloff derivative\nvoid getFalloffDerivative(float x, out float df)\n{\n    df = 0.;\n    if(x<0.01||x>1.) return; // Field is 0 outside [0,1]\n   \n    // Quintic fallof derivative 1-(30x^4 - 60x^2 + 30x)\n    df = -(x*x*(30.*x*x - 60.*x + 30.));\n}\n\n// Get the field values, return true if hit the isosurface of a give threshold\n// return also the normal and the color in that point.\nbool getFieldValues(vec3 p, float threshold, out float value, out vec3 normal, out vec3 color)\n{\n    normal = vec3(0);\n    float f, df;\n    value = 0.;\n    \n    // Compute the field generated from all the scalar field that we sum up ...\n    for(int i=0;i<N_FIELDS;i++)\n    {\n        // The distance from the center of the field\n\t\tfloat r = length(p-fields[i].position);\n        \n        // Test against Bounding Sphere of the field\n        if(length(p-fields[i].position)>fields[i].radius) continue;\n        \n        // The distance from the center of the function is normalized with the radius of the field\n        float d = length((p-fields[i].position)/fields[i].radius);\n        \n        // Get the value of the falloff ...\n        getFalloff(d, f);\n        \n        // ... and sum it to the total\n        value += f;\n        \n        // Already choose a color in case this is a hit\n        color = mix(color,samplePalette(float(i*50)/800.),f/2.);\n    }\n    \n    // If the value of the field is greater than threshold we reach the isosurface,\n    // so compute the normal\n    if(value>=threshold)\n    {\n        float df=0.;\n        \n        // The resulting normal is the sum of all the gradient of the fields function summed up.\n        // The gradient of a single field is the derivative of its falloff in this point (that is a scalar)\n        // multiplied the normal vector to the surface, that is the differece between the current position \n        // and the center of the field (it's a spherical field).\n        for(int i=0;i<N_FIELDS;i++) \n        {\n            // Get the value of the falloff derivative in this point ...\n            float d = length((p-fields[i].position)/fields[i].radius);\n            getFalloffDerivative(d, df);\n            \n            // Compute the normal of this specific field in this position and sum to the others\n            normal += df*normalize(fields[i].position-p);\n        }\n        \n        // Normalize the result\n        normal = normalize(normal);\n        \n        return true;\n    }\n    \n    // Not reached the isosurface yet\n    return false;\n}\n\n\n// Find the nearest distance from origin to the field generated by the spheres on the dir direction, \n// return INF if the ray does not intersect the field\nHit rayTraceFieldBoudingSpheres(vec3 origin, vec3 dir)\n{\n    float minT = INF;\n    float point;\n    Hit hit, result;\n    \n    // Get nearest point from the spheres\n    result.t = INF;\n    for(int i=0; i<N_FIELDS; i++)\n    {\n        if(traceSphere(origin, dir, fields[i].position, fields[i].radius, hit) && hit.t<result.t) \n        {\n            result.t = hit.t;\n            result.point = origin + result.t*dir;\n            result.objId = 1;\n        }\n    }\n    \n    return result;\n}\n\n// Update the position of the objects in the scene\nvoid updateField()\n{\n    for(int i=0; i<N_FIELDS; i++)\n    {\n        float id = float(i);\n        float a = 2.;\n        fields[i].position = vec3(a*sin(float(iFrame)/200.+id*244.),1.4*abs(sin(id*0.1*iTime+323.3))-1.,a*sin(float(iFrame)/100.+id*1724.)) * 2.;   \n    }\n}\n\n// Cast a ray into the scene\nvec3 castRay(vec3 origin, vec3 dir)\n{\n    // Update the position of the fields in the scene\n    updateField();\n    \n    vec3 fieldNormal;\n    \n    float MAX_DISTANCE = 20.;\n    int MAX_ITERATIONS = 200;\n    \n    // getDistanceToField Ray-Trace the field spheres bounding boxes Get to the field nearest point, ray\n    Hit hit = rayTraceFieldBoudingSpheres(origin, dir);\n    \n    float t = hit.t;\n    if(t==INF) return vec3(1); // No hit -> return white background\n    \n    // Ray march inside the scalar field\n    vec3 p;\n    vec3 color;\n    float value=0.;\n    float threshold = 0.4;\n    for(int i=0; i<MAX_ITERATIONS; i++)\n    {\n        if(t>MAX_DISTANCE) break; // No hit\n        t+=0.05;\n        p = origin + t*dir;\n        \n        if(getFieldValues(p, threshold, value, fieldNormal,color))\n        {\n            hit.t=t;\n            hit.point=p;\n            hit.normal=fieldNormal;\n            hit.objId=1;            \n            hit.color=color;\n            break;\n            \n        }\n    }\n    \n    if(value < 0.4) return vec3(1); // No ray marcher hit -> return background white\n    \n    return render(origin,hit);\n}\n\n// This is function is executed for each pixel\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    // Change coordinates from [0,iResolution.x]X[0,iResolution.y] to [-1,1]X[-1,1]\n    vec2 U = (2.*fragCoord.xy - iResolution.xy) / iResolution.x;\n\n    // Right-handed camera reference system\n    float tetha, phi;\n    if(iMouse.z > 0.)\n    {\n        // Camera angle when clicking on the mouse\n        tetha = clamp(iMouse.x/iResolution.x *2.*PI, 0.,2.*PI);\n        phi = clamp(iMouse.y/iResolution.y*PI, 0.,PI);\n    }\n    else \n    {\n        // Camera angle when the mouse is not clicked\n        tetha = mod(iTime,2.*PI);\n        phi = PI*1./4.;\n    }\n    \n    // Eye position\n    vec3 eye = vec3(12.*cos(tetha)*sin(phi),12.*cos(phi),12.*sin(tetha)*sin(phi));\n    \n    // Target position\n    vec3 target = vec3(0,0,0);\n   \n    // Camera reference frame\n    vec3 ww = normalize(eye-target);\n    vec3 uu = normalize(cross(vec3(0,1,0),ww));\n    vec3 vv = normalize(cross(ww,uu));\n    \n    // Cast a ray from origin through pixel, into the scene\n    float focalLength = 1.4;\n    vec3 ray = normalize(U.x*uu + U.y*vv - focalLength*ww);\n    fragColor = vec4(castRay(eye,ray),1.);\n    \n    // Gamma correction\n    fragColor = pow(fragColor,vec4(0.45));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Define a very large value, will be used as infinity\n#define INF 1e5\n#define PI acos(-1.)\n\nstruct Hit \n{\n    float t;\n    vec3 point;\n    vec3 normal;\n    vec3 color;\n    int objId;\n};\n\nvoid swap(inout float x0, inout float x1)\n{\n    float tmp = x0;\n    x0=x1;\n    x1=tmp;\n}\n\nbool solveQuadratic(float a, float b, float c, out float x0, out float x1) \n{ \n    float delta = b*b-4.*a*c; \n    if (delta < 0.) return false; \n    else if (delta == 0.) \n    {\n        x0 = x1 = -0.5*b/a; \n    }\n    else \n    { \n        float q = (b > 0.) ? -0.5 * (b + sqrt(delta)) : -0.5 * (b - sqrt(delta)); \n        x0 = q/a; \n        x1 = c/q; \n    } \n    \n    return true; \n} \n\nbool traceSphere(vec3 eye, vec3 ray, vec3 center, float radius, out Hit hit)\n{ \n    float t0, t1;\n\n    vec3 L = eye-center;\n    float a = dot(ray,ray);\n    float b = 2. * dot(ray,L); \n    float c = dot(L,L) - (radius*radius);\n    if (!solveQuadratic(a, b, c, t0, t1)) return false; \n    \n    if (t0 > t1) swap(t0, t1); \n\n    if (t0 < 0.) \n    { \n        t0 = t1;  //if t0 is negative, let's use t1 instead \n        if (t0 < 0.) return false;  //both t0 and t1 are negative \n    } \n\n    hit.t = t0;\n    hit.point = eye + t0*ray;\n    hit.normal = normalize(hit.point - center);\n    \n    return true; \n} \n\nstruct Material\n{\n    vec3 Fresnel0;   // Fresnel value when the light incident angle is 0 (angle between surface normal and to light direction)\n    float roughness; // Roughness in [0,1] \n    vec3 albedo;\n};\n\n// Palette generator tnx Iq\nvec3 getColor(vec3 a, vec3 b, vec3 c, vec3 d, float t)\n{\n    return a + b*cos(2.*PI*(t*c+d));\n}\n\n// Color palette\nvec3 samplePalette(float t)\n{\n     vec3 a = vec3(0.5,0.5,0.5);\n     vec3 b = vec3(.5,0.5,0.5);\n     vec3 c = vec3(1.0,1.0,1.0);\n     vec3 d = vec3(0.,0.2,0.4);\n     \n     return getColor(a,b,c,d,t);\n} \n\n\n","name":"Common","description":"","type":"common"}]}