{"ver":"0.1","info":{"id":"l3fSzs","date":"1709834356","viewed":84,"name":"hyper's shell texturing","username":"hypercubed","description":"shell texturing, wavy grass","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["grass","hair","fur","shell"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float camera_plane_distance = 0.5;\nfloat density = 256.0;\nint layers = 32;\nfloat layer_distance = 0.007;\n\nbool planeIntersects(vec3 ray, vec3 rayOrigin, vec3 normal, vec3 tangent_x, vec3 center, float size) {\n    // ray is normalized\n    // get intersection point\n    vec3 tangent_y = normalize(cross(normal, tangent_x));\n    float dist = dot(center - rayOrigin, normal) / dot(ray, normal);\n    vec3 intersect = rayOrigin + dist * ray;\n    vec2 centered_uv = vec2(dot((intersect - center), tangent_x / size), dot((intersect - center), tangent_y / size));\n    \n    return abs(centered_uv.x) < 1.0 && abs(centered_uv.y) < 1.0;\n}\nvec2 planeUV(vec3 ray, vec3 rayOrigin, vec3 normal, vec3 tangent_x, vec3 center, float size) {\n    // ray is normalized\n    // tangent is uv x coordinate\n    // get intersection point\n    vec3 tangent_y = normalize(cross(normal, tangent_x));\n    float dist = dot(center - rayOrigin, normal) / dot(ray, normal);\n    vec3 intersect = rayOrigin + dist * ray;\n    vec2 centered_uv = vec2(dot((intersect - center), tangent_x / size), dot((intersect - center), tangent_y / size));\n    return (centered_uv + 1.0) * 0.5;\n}\n\nvec3 gamma(in vec3 color)\n{\n    return pow(color, vec3(1.0 / 2.2));\n}\n\nvec3 mainPass( in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xx;\n    vec3 camera_plane_coord = vec3((uv * 2.0 - vec2(1.0, 0.65)), camera_plane_distance);\n    \n    vec3 plane_center = vec3(0.0, -0.5, 1.5);\n    vec3 plane_normal = normalize(vec3(0.0, 1.0, -0.5));\n    vec3 plane_tangent = vec3(1.0, 0.0, 0.0);\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    vec3 ray = normalize(camera_plane_coord - rayOrigin);\n    \n    vec3 color = vec3(0.5, 0.5, 0.5);\n    \n    for (int i = 0; i < layers; i++) {\n        vec3 layer_center = plane_center + plane_normal * layer_distance * float(i);\n        float layer_normalized = float(i) / float(layers);\n        \n        if (planeIntersects(ray, rayOrigin, plane_normal, plane_tangent, layer_center, 2.0)) {\n            vec2 local_uv = planeUV(ray, rayOrigin, plane_normal, plane_tangent, layer_center, 2.0);\n            float wave_offset = sin(local_uv.x * 7.0 + local_uv.y * 7.0 + iTime) * 0.5 + 0.5;\n            local_uv += (wave_offset / density) * layer_normalized * 2.0;\n            \n            vec2 strand_uv = fract(local_uv * density + 0.5) * 2.0 - 1.0;\n            float dist_from_strand_center = length(strand_uv);\n            \n            setSeed(uint(local_uv.x * density - 0.5) + uint(local_uv.y * density - 0.5) * uint(density));\n            float noise_sample = rand() * 0.5 + 0.5;\n            \n            if (dist_from_strand_center < 2.0 * (noise_sample - layer_normalized)) {\n                //color = vec3(0.0, layer_normalized + 0.1, 0.0);\n                color = vec3(0.0, layer_normalized + 0.1, 0.0);\n            }\n        }\n    }\n    return color;\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 antialias(in vec2 fragCoord)\n{\n    // Set the number of AA passes here\n    // Note that your shader code is called n^2 times, so be careful\n    // Higher values have diminishing returns anyway\n    const float AA_STAGES = 2.0;\n    \n    // These constants don't need changing\n    const float AA_TOTAL_PASSES = AA_STAGES * AA_STAGES + 1.0;\n    const float AA_JITTER = 0.5;\n    \n    // Run the shader multiple times with a random subpixel offset each time and average the results\n    vec3 color = mainPass(fragCoord);\n    for (float x = 0.0; x < AA_STAGES; x++)\n    {\n        for (float y = 0.0; y < AA_STAGES; y++)\n        {\n            vec2 offset = AA_JITTER * (2.0 * hash22(vec2(x, y)) - 1.0);\n            color += mainPass(fragCoord + offset);\n        }\n    }\n    return color / AA_TOTAL_PASSES;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 color = antialias(fragCoord);\n    color = gamma(color);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const ivec2 FS_ADDR = ivec2(0.0);\n\nconst vec4 fs_stt = vec4(1.0);\n\nuint seed = 0u;\n\nvoid setSeed(uint s) {\n    seed = s;\n}\n\nuint hash(uint s) {\n    s ^= 2747636419u;\n    s *= 2654435769u;\n    s ^= s >> 16;\n    s *= 2654435769u;\n    s ^= s >> 16;\n    s *= 2654435769u;\n    return s;\n}\n\nuint randI() {\n    seed = hash(seed);\n    return seed;\n}\n\nfloat rand() {\n    uint rn = randI();\n    rn %= 1000000000u;\n    float rs = float(rn);\n    rs /= 1000000000.0;\n    return rs;\n}","name":"Common","description":"","type":"common"}]}