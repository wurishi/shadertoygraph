{"ver":"0.1","info":{"id":"csccR4","date":"1696453897","viewed":60,"name":"Cheap Raymarching AA","username":"Real_NC","description":"Testing out a \"free\" way to add antialiasing to a raymarched scene. Basically just finds the closest point where the map function is still increasing along the ray direction to make sure the closest surface isn't just the intersected surface.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","antialiasing","aa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 1e-3\n#define SPHERES 10\n#define MAX_STEPS 200\n#define PI 3.14159\n#define TAU 2.0 * PI\n\nvec2 opU (vec2 d1, vec2 d2)\n{\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat dSphere(vec3 p, vec3 o, float r)\n{\n    return length(p-o)-r;\n}\n\nvec3 spherePos(float id) // Do not use this hash under any circumstance\n{\n    return vec3(vec2(sin(id*72.53),cos(id*26.7528)),3.0 + sin(id*58.58917));\n}\n\nfloat sphereRad(float id)\n{\n    return 0.5;\n}\n\nvec3 sphereAlbedo(float id, vec3 p)\n{\n    vec3 color = round(texelFetch(iChannel1, ivec2(id, 1), 0).rgb * 2.0);\n    p -= spherePos(id);\n    \n    p = normalize(p);\n    \n    color *= smoothstep(-1.0, 1.0, p.y);\n    \n    return color * texture(iChannel0, vec2(atan(p.x, p.z), atan(p.y, length(p.xz)))).r;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 d = vec2(dSphere(p, spherePos(1.0), sphereRad(1.0)), 1.0);\n    for (int i = 2; i <= SPHERES; i++)\n    {\n        d = opU(d, vec2(dSphere(p, spherePos(float(i)), sphereRad(float(i))), i));\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    \n    vec3 rd = normalize(vec3(uv,1));\n    vec3 ro = vec3(0);\n    \n    // Raymarching\n    float d = 0.0;\n    vec2 m;\n    float dm, prevm = 0.0;\n    vec2 secondClosest = vec2(1e20, 0);\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        m = map(ro + rd*d);\n        d += m.x;\n        if (secondClosest.x > m.x && prevm < m.x){\n            secondClosest = m;\n            dm = d;\n        }\n        if (d >= 8.0) break;\n        if (m.x <= EPSILON) break;\n        prevm = m.x;\n    }\n    fragColor.rgb = mix(sphereAlbedo(secondClosest.y, ro + rd*dm), sphereAlbedo(m.y, ro + rd*d)*float(m.x <= EPSILON), smoothstep(0.0, 1.4*dm/iResolution.y, secondClosest.x));\n    \n    fragColor = pow(fragColor*0.6, vec4(1.0 / 2.2));\n}","name":"Image","description":"","type":"image"}]}