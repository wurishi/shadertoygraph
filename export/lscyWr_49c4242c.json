{"ver":"0.1","info":{"id":"lscyWr","date":"1518480358","viewed":796,"name":"Terrain flythrough","username":"owmywrists","description":"First test with signed distance fields","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","terrain","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NSTEPS 256\n#define EPS 0.01\n\nstruct Camera\n{\n    vec3 pos; \n    vec3 lookat; \n    float fov;\n};\n    \nstruct Ray\n{\n   vec3 o;\n   vec3 d;\n};\n    \n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\n    \nfloat planeSDF(vec3 p)\n{\n    vec4 n = normalize(vec4(0.0, 1.0, 0.0, 1.0));\n    return dot(p, n.xyz) + n.w; \n}\n\nfloat displace(float d1,vec3 p)\n{\n    float d2 = abs(fbm(p.zx/5.0))*1.3 + abs(fbm(p.zx/15.0))*8.5;\n    return d1 + d2;\n}\n    \nfloat sphereSDF(vec3 p, float r)\n{\n    return length(p) -r;\n}\n\nfloat boxSDF(vec3 p, float size)\n{\n  return length(max(abs(p)- vec3(size),0.0));\n}\n\nfloat repeat_sphere(vec3 p, vec3 c)\n{\n    vec3 q = mod(p,c) - 0.5*c;\n    \n    return boxSDF(q, 7.0);\n}\n\nfloat smin(float a, float b, float k)\n{\n    float res = exp(-k*a) + exp(-k*b);\n    return -log(res)/k;\n}\n\nfloat sceneSDF(vec3 p)\n{\n    float terrain = displace(planeSDF(p), p);\n    float water = planeSDF(p + vec3(0.0, 9.0, 0.0));                      \n    return min(terrain, water);\n}\n\nvec3 normal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPS, p.y, p.z)) - sceneSDF(vec3(p.x - EPS, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPS, p.z)) - sceneSDF(vec3(p.x, p.y - EPS, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPS)) - sceneSDF(vec3(p.x, p.y, p.z - EPS))\n    ));\n}\nvec3 get_ray_hit(Ray ray, float t){return ray.o + ray.d*t;}\n\nRay get_camera_ray(Camera c, float s, float t)\n{\n    float aspect = iResolution.x/iResolution.y;\n    vec3 eye = normalize(c.pos - c.lookat);\n    vec3 u = normalize(cross(vec3(0,1,0), eye));\n    vec3 v = normalize(cross(eye, u));\n   \n    float fov_rad = radians(c.fov);\n    float hh =  tan(fov_rad/2.0);\n    float hw = aspect * hh;\n    vec3 bl = c.pos - u*hw - v*hh - eye;\n    vec3 x = u*2.0*hw;\n    vec3 y = v*2.0*hh;\n    \n    return Ray(c.pos, bl + x*s + y*t - c.pos);\n}\n\nvec3 phong(vec3 ambient, vec3 diffuse, vec3 specular, float spec, vec3 p, Ray r)\n{\n    vec3 sun = normalize(vec3(0.2, 0.2,1.0));\n    vec3 sun_intensity = vec3(0.6);\n    \n    vec3 n = normal(p);\n    \n    vec3 view = normalize(r.o - p);\n    vec3 refl = normalize(reflect(-sun, n));\n    \n    float dotln = dot(sun, n);\n    float dotrv = dot(refl, view);\n    if (dotrv < 0.0) return sun_intensity * (diffuse*dotln);\n    return sun_intensity * (diffuse*dotln) + specular*pow(dotrv, spec);\n}\nvec3 fog(vec3 rgb, float dist)\n{\n    float fog_amount = 1.0 - exp(-dist*0.007);\n    vec3 fog_col = vec3(0.5, 0.6, 0.7);\n    return mix(rgb, fog_col, fog_amount);\n}\n\nvec3 raymarch(Ray ray, float y_frag)\n{\n    float current_depth = 0.0;\n    for (int s = 0; s < NSTEPS; s++)\n    {\n        vec3 hit = get_ray_hit(ray, current_depth);\n     \tfloat obj_dist = sceneSDF(hit);\n        if (obj_dist < EPS)\n        {\n            vec3 col;\n            if ( hit.y < -9.95)\n               \tcol = vec3(0.0,0.2,0.4)*length(texture(iChannel0, hit.xz))*0.3;\n            else\n            \tcol = phong(vec3(0.15), texture(iChannel1, hit.zx/15.0).xyz,vec3(0.2),texture(iChannel1, hit.xz/15.0).x*1.0, hit, ray);\n            return fog(col, current_depth);\n        }\n        current_depth += obj_dist;\n        if ( current_depth >= 400.0) \n        { \n            return vec3(0.5, 0.6, 0.7)/(y_frag);\n        }\n    }\n    return vec3(0.0,0.0,0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tCamera cam = Camera(vec3(0.0, -6.0,10.0), vec3(0.0, -6.2,10.0 - 1.0), 45.0);\n    cam.pos.z += -iTime*10.0;\n    cam.lookat.z += -iTime*10.0 - 10.0;\n    //cam.lookat.x += sin(iMouse.x/iResolution.x)*50.0;\n    cam.lookat.y = cam.pos.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = vec4(raymarch(get_camera_ray(cam, uv.x, uv.y),uv.y), 1.0);\n    //vec4 o = step(texture(iChannel2, fragCoord/2.).r, col);\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}