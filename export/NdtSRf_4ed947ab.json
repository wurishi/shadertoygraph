{"ver":"0.1","info":{"id":"NdtSRf","date":"1633633271","viewed":88,"name":"Game of Life Cellular Automata","username":"16384","description":"A shader test for the cellular automaton, the Game of life, originally found by John Conway. Works SIGNIFICANTLY faster than methods that don't use shaders. Can work 60fps fullscreen with many devices. Click the screen to randomize","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["automata","cellular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//turn 'false' to 'true' below for some chromatic aberration because that's fun\n\n#define chromaticAberration false\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    if (chromaticAberration) {\n        //vec2 uvr = (uv + vec2(0.0, 0.0)) * (1.0 / (sin(iTime/2.0)*10.0+11.0));\n        //vec2 uvg = (uv + vec2(0.0, 0.0)) * (1.0 / (sin(iTime/2.0)*10.0+11.0));\n        //vec2 uvb = (uv + vec2(0.0, 0.0)) * (1.0 / (sin(iTime/2.0)*10.0+11.0));\n    \n        vec2 uvr = uv;\n        vec2 uvg = uv;\n        vec2 uvb = uv;\n    \n    \n        float rr = length(uvr - vec2(0.5 + sin(iTime), 0.5 + cos(iTime)));\n        float rg = length(uvg - vec2(0.5 + cos(iTime), 0.5));\n        float rb = length(uvb - vec2(0.5, 0.5+sin(iTime)));\n        vec2 thetaVecr = normalize(uvr - vec2(0.5, 0.5+sin(iTime)));\n        vec2 thetaVecg = normalize(uvg - vec2(0.5, 0.5));\n        vec2 thetaVecb = normalize(uvb - vec2(0.5, 0.5));\n\n        float bMod = rb * 1.0;\n        float gMod = rg * 0.995;\n        float rMod = rr * 0.99;\n\n        vec2 rPos = vec2(0.5,  0.5) + thetaVecr * rMod;\n        vec2 gPos = vec2(0.5,  0.5) + thetaVecg * gMod;\n        vec2 bPos = vec2(0.5,  0.5) + thetaVecb * bMod;\n\n        float red = texture(iChannel0, rPos).r;\n        float green = texture(iChannel0, gPos).g;\n        float blue = texture(iChannel0, bPos).b;\n\n        vec3 col = vec3(red, green, blue);\n        fragColor = vec4(col, 1.0);\n    } else {\n        fragColor = texture(iChannel0, uv);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nMost likely very inefficient code for a simple game of life simulation\n\nFrom one very basic test, most likely at least 30x faster\nthan a non-shader version of this same simulation\n*/\n\n#define C(i, j) texture(iChannel0, uv + vec2(i, j) / iResolution.xy).x\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    if(iMouse.w > 0.0 || iTime < 0.1) {\n        fragColor = rand(vec2(uv.x+iTime, uv.y)) > 0.5 ? vec4(1.0) : vec4(0.0, 0.0, 0.0, 1.0);\n    } else {\n        int neighbors = int(C(-1.0, -1.0) + C(0.0, -1.0) + C(1.0, -1.0) + C(-1.0, 0.0) + C(1.0, 0.0) + C(-1.0, 1.0) + C(0.0, 1.0) + C(1.0, 1.0));\n        fragColor = (texture(iChannel0, uv).x > 0.5 && neighbors == 2) || neighbors == 3 ? vec4(1.0) : vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}