{"ver":"0.1","info":{"id":"XfSfRD","date":"1725822256","viewed":48,"name":"Street Lights","username":"DGMKPixy","description":"Siguiendo el tutorial de TheArtOfCode para aprender y hacerlo a mi forma: https://www.youtube.com/@TheArtofCodeIsCool","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["cameralightswater"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Define la distancia que hay entre la camara y la pantalla.\n#define CAMERA_SCREEN_DIST 2.\n\nvec4 Noise4(float t, vec4 seed)\n{\n    return fract(sin(t * vec4(6543.,1234.,9642.,3312.))*seed); \n}\n\n\nfloat Noise(float t, float seed)\n{\n    return fract(sin(t * 6543.)*seed); \n}\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nRay GetRay(vec2 uv, vec3 cameraOrigin, vec3 lookat, float zoom)\n{\n    // vector FRENTE de la camara\n    vec3 F = normalize(lookat - cameraOrigin);\n    // Vector DERECHA de la camara\n    vec3 R = cross(vec3(0.,1.,0.), F);\n    // Vector UP de la camara\n    vec3 U = cross(F, R);\n        \n    // Ahora tenemos que saber cual es el centro de la pantalla. El centro de la\n    // pantalla será un punto resultante de la suma del origen más el vector FRENTE por\n    // el zoom.\n    vec3 centerScreen = cameraOrigin + F * zoom;\n    // Con el centro, podemos calcular donde está el punto \"i\". Este punto es la posición\n    // uv del pixel situado RIGHT veces en el eje x y UP veces en el eje y desde el centro\n    vec3 i = centerScreen + uv.x*R + uv.y*U;\n    // calculamos la dirección del rayo\n    vec3 rayDirection = normalize(i - cameraOrigin);\n    \n    Ray r;\n    r.origin = cameraOrigin;\n    r.direction = rayDirection;\n    return r;\n}\n\nvec3 ClosestPointInRayFromPoint(Ray r, vec3 point)\n{\n    return r.origin + max(0., dot(point - r.origin, r.direction))*r.direction;\n}\n\nfloat DistRay(Ray r, vec3 point)\n{\n    return length(point-ClosestPointInRayFromPoint(r, point));\n}\n\nfloat DistLine(vec3 ro, vec3 rd, vec3 p)\n{\n    return length(cross((p-ro),rd)) / length(rd); \n}\n\n\n\nfloat DrawPoint(vec3 ro, vec3 rd, vec3 p)\n{\n    float d = DistLine(ro, rd, p);\n    d = smoothstep(.06,.05,d);\n    return d;\n}\n\nfloat Bokeh(Ray r, vec3 point, float size, float blur)\n{\n    float d = DistRay(r, point);\n    size *= length(point);\n    float c = smoothstep(size,size*(1.-blur),d);\n    c *= mix(.7,1.,smoothstep(size*.8,size,d));\n    return c;\n}\n\nvec3 StreetLights(Ray r, float t)\n{\n    float side = step(r.direction.x,0.);\n    r.direction.x = abs(r.direction.x);\n    float s = .1;\n    float m = 0.;\n    for(float i = 0.; i < 1.; i+=s)\n    {\n        float ti = fract(t + i + side*s*.5);\n        vec3 p = vec3(2.,2.,100.-(ti)*100.);//vec3(sin(iTime),0.,2. + (2.*cos(iTime)));\n        m += Bokeh(r, p, .05,.1)*ti*ti*ti;\n    }\n    \n    return m * vec3(1.,.7,.3);\n}\n\nvec3 EnvironmentLights(Ray r, float t)\n{\n    float side = step(r.direction.x,0.);\n    r.direction.x = abs(r.direction.x);\n    float s = 1./10.;\n    vec3 c = vec3(0.);\n    for(float i = 0.; i < 1.; i+=s)\n    {\n        float ti = fract(t + i + side*s*.5);\n        float fade = ti*ti*ti; \n        vec4 n = Noise4(i + side*100., vec4(1232., 481., 241., 544.));\n        \n        float occlusion = sin(ti*6.28*10.*n.x) * .5 + .5; //2*PI\n        fade = occlusion;\n        vec3 col = n.wzy;\n        \n        float x = mix(2.5,10.,n.x);\n        float y = mix(.1,1.5,n.y);\n        \n        vec3 p = vec3(x,y,50.-(ti)*50.);//vec3(sin(iTime),0.,2. + (2.*cos(iTime)));\n        c += Bokeh(r, p, .05,.1)*fade*col*.5;\n    }\n    \n    return c;\n}\n\nvec3 HeadLights(Ray r, float t)\n{\n    t *= 2.; // así parece que los coches van más rápido.\n\n    float carWidth = .25;\n    float carWidth2 = carWidth*1.2;\n    float s = 1. / 30.;\n    float m = 0.;\n    for(float i = 0.; i < 1.; i+=s)\n    {\n        float n = Noise(i, 9234.); // i es el coche\n        \n        if(n > .1) continue;\n        \n        // ti es la distancia normalizada entre el principio de la luz y el final\n        float ti = fract(t + i);// + side*s*.5);\n        float fade = ti*ti*ti*ti*ti; // Cuanto más se eleve ti, mayor es el fade en el\n                                     // punto de origen.\n        float z = 100.-(ti)*100.;\n        float focus = smoothstep(.9,1.,ti);\n        \n        float size = mix(.05, .03, focus);\n        \n        m += Bokeh(r, vec3(-1.-carWidth,.15,z), size,.1)*fade;\n        m += Bokeh(r, vec3(-1.+carWidth,.15,z), size,.1)*fade;\n        m += Bokeh(r, vec3(-1.-carWidth2,.15,z), size,.1)*fade;\n        m += Bokeh(r, vec3(-1.+carWidth2,.15,z), size,.1)*fade;\n        \n        float ref = 0.;\n        vec3 head3 = vec3(-1.-carWidth2,-.15,z);//vec3(sin(iTime),0.,2. + (2.*cos(iTime)));\n        vec3 head4 = vec3(-1.+carWidth2,-.15,z);//vec3(sin(iTime),0.,2. + (2.*cos(iTime)));\n        ref += Bokeh(r, head3, size*3.,1.)*fade;\n        ref += Bokeh(r, head4, size*3.,1.)*fade;\n        \n        m+=ref*focus;\n    }\n    \n    return m * vec3(.9,.9,1.);\n}\n\n\nvec3 TailLights(Ray r, float t)\n{\n    t *= .25; // así parece que los coches van más lento.\n\n    float carWidth = .25;\n    float carWidth2 = carWidth*1.2;\n    float s = 1. / 15.; // Menos coches que en head\n    float m = 0.;\n    for(float i = 0.; i < 1.; i+=s)\n    {\n        float n = Noise(i, 6789.); // i es el coche\n        \n        if(n > .5) continue; // Pero más probable que aparezcan.\n        \n        float lane = step(.1,n); // 0 para el carril izq y 1 para el derecho.\n        \n        // ti es la distancia normalizada entre el principio de la luz y el final\n        float ti = fract(t + i);// + side*s*.5);\n        float fade = ti*ti*ti*ti*ti; // Cuanto más se eleve ti, mayor es el fade en el\n                                     // punto de origen.\n        float z = 100.-(ti)*100.;\n        float lineShift = smoothstep(1.,.92,ti);\n        float x = 1.5-lane * lineShift;\n        float focus = smoothstep(.9,1.,ti);\n        \n        float size = mix(.05, .03, focus);\n        \n        // Cuando el sin de menos que 0, entonces valdrá 0 por el step, y cuando sea mayor,\n        // valdrá 1.\n        float blink = step(0.,sin(t*1000.)) * 5. * lane * step(.92,ti); // Esto provoca que vaya de 0 a 1 muy rápido\n        float blinkerSize = size*.4;\n        \n        m += Bokeh(r, vec3(x-carWidth,.15,z), size,.1)*fade;\n        m += Bokeh(r, vec3(x+carWidth,.15,z), size,.1)*fade;\n        m += Bokeh(r, vec3(x-carWidth2,.15,z), size,.1)*fade;\n        m += Bokeh(r, vec3(x+carWidth2,.15,z), size,.1)*fade*(1.+blink);  \n        \n        float ref = 0.;\n        vec3 head3 = vec3(x-carWidth2,-.15,z);//vec3(sin(iTime),0.,2. + (2.*cos(iTime)));\n        vec3 head4 = vec3(x+carWidth2,-.15,z);//vec3(sin(iTime),0.,2. + (2.*cos(iTime)));\n        ref += Bokeh(r, head3, size*4.,1.)*fade;\n        ref += Bokeh(r, head4, size*4.,1.)*fade*(1.+blink*.1);\n        \n        m+=ref*focus;\n    }\n    \n    // Sobresaturamos el color rojo y hacemos muy pequeño el azul. Asi, cuando arriba\n    // hacemos esto:\n    //\n    // blink = step(0.,sin(t*1000.))*5.\n    // \n    // y multiplicamos el 5., estamos aumentando la instensidad, quedando el color con blink:\n    // (5.,.5,.15) ó (1.,.5,.15)\n    return m * vec3(1.,.1,.03); \n}\n\n// Devuelve la distorsion de los uvs para hacer la lluvia\nvec2 Rain(vec2 uv, float t)\n{\n    t*=40.;\n    vec2 aspectRatio = vec2(3.,1.);\n    vec2 st = uv*aspectRatio;\n    vec2 id = floor(st);\n    st.y += t*.2;\n    float n = fract(sin(id.x*76.781) * 822.9);\n    st.y += n;\n    uv.y += n;\n    \n    id = floor(st);\n    st = fract(st)-.5; // -.5 porque así centramos las UVs en cada recruado.\n    \n    t += fract(sin(id.x*532.781+id.y*84.56) * 82.9)*3.1416*5.;\n    \n    //float x = fract(cos(id.y*362.781)*232.25)*0.3;\n    float x = sin(id.x*342.71+id.y*114.56);\n    float y = -sin(t+sin(t+sin(t)*.5))*.4;\n    vec2 position = vec2(x*.3,y);\n    \n    vec2 opacity1 = (st-position)/aspectRatio;\n    float d = length(opacity1);\n    float m1 = smoothstep(.08, .0, d);\n    \n    uv.x += -x*.3/length(aspectRatio); // Ajustamos el aspect ratio para las gotas.\n    \n    vec2 opacity2 = (fract(uv*vec2(1.,2.)*aspectRatio.x)-.5)/vec2(1.,2.);\n    d = length(opacity2);\n    float m2 = smoothstep(.3*(-st.y+.5), .0, d)*smoothstep(.1,-.1,y-st.y);\n    \n    //if(st.x > .46 || st.y > .49) m1 = 1.;\n    vec2 result = vec2(m1*opacity1*30. + m2*opacity2*20.);\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 m = iMouse.xy/iResolution.xy;\n    m -= .5;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y; \n\n    vec3 cameraOrigin = vec3(0.5,.6,0.);\n    //vec3 lookat = vec3(m.x,m.y+.2,1.);    \n    vec3 lookat = vec3(0.5,.6,8.);    \n    float zoom = 2.;\n\n    float t = iTime*.05+m.x;\n    vec2 rainDistorsion = Rain(uv*15., t*.7)*.3;\n    rainDistorsion += Rain(uv*.6, t*2.)*.1;\n\n    rainDistorsion += Rain(uv*4., t)*.1;\n\n    uv.x += sin(uv.y*100.)*.004;\n    uv.y += sin(uv.x*170.)*.002;\n    // creamos un Ray para cada uv.\n    //Reflexion\n    //Ray r = GetRay(uv-rainDistorsion, cameraOrigin, lookat, zoom);\n    //Refraccion\n    Ray r = GetRay(uv-rainDistorsion, cameraOrigin, lookat, zoom);\n        \n    vec3 c = StreetLights(r, t);\n    c += HeadLights(r,t);\n    c += TailLights(r,t);\n    c += EnvironmentLights(r,t);\n    \n    c += (r.direction.y+.25) * vec3(.2,.1,.5);\n    \n    /*\n    DrawPoint(cameraOrigin, r.direction, p+vec3(0,0,0.));\n    d += DrawPoint(cameraOrigin, r.direction, p+vec3(0.,0.,1.));\n    d += DrawPoint(cameraOrigin, r.direction, p+vec3(0.,1.,0.));\n    d += DrawPoint(cameraOrigin, r.direction, p+vec3(0.,1.,1.));\n    d += DrawPoint(cameraOrigin, r.direction, p+vec3(1.,0.,0.));\n    d += DrawPoint(cameraOrigin, r.direction, p+vec3(1.,0.,1.));\n    d += DrawPoint(cameraOrigin, r.direction, p+vec3(1.,1.,0.));\n    d += DrawPoint(cameraOrigin, r.direction, p+vec3(1.,1.,1.));\n    */\n    // Time varying pixel color\n    vec4 col = vec4(c,1.);\n    \n    //col += vec3(rainDistorsion,0.);\n\n    // Output to screen\n    fragColor = vec4(col);\n}","name":"Image","description":"","type":"image"}]}