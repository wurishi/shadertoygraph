{"ver":"0.1","info":{"id":"XtdSDn","date":"1485002732","viewed":11348,"name":"SmoothLife(L) ","username":"chronos","description":"SmoothLife by Stephan Rafler, a continuous analog of Conway's Game of Life.\nMy favorite cellular automaton / reaction diffusion like system, due the continuous rules and emergent behavior:\nfrequent gliders, connective ribbons which contract, etc.","likes":150,"published":1,"flags":48,"usePreview":1,"tags":["2d","life","cellular","cells","smooth","automaton"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 CellColor = vec3(0.2, 0.2, 0.2);\nconst vec3 RingColor = vec3(0.0, 0.2, 0.2);\nconst vec3 DiskColor = vec3(0.0, 0.0, 0.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 buffer = texture(iChannel0, uv);\n    \n    vec3 color = 1.0*(buffer.x * CellColor + buffer.y * RingColor + buffer.z * DiskColor);\n    \n    float c = 1.0 - buffer.z;\n    float c2 = 1. - texture(iChannel0, uv + .5/iResolution.xy).y;\n    color += vec3(.6, .85, 1.)*max(c2*c2 - c*c, 0.)*4.;\n    \n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n//Conventions:\n// x component = outer radius / ring\n// y component = inner radius / disk\n/*\n   _\n /   \\\n|  O  |\n \\ _ /\n*/\nconst float PI = 3.14159265;\nconst float dt = 0.30;\n\n\nconst vec2 r = vec2(10.0, 3.0);\n\n// SmoothLifeL rules\nconst float b1 = 0.257;\nconst float b2 = 0.336;\nconst float d1 = 0.365;\nconst float d2 = 0.549;\n\nconst float alpha_n = 0.028;\nconst float alpha_m = 0.147;\n/*------------------------------*/\n\n//const float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\n//const float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\nconst float KEY_SPACE  = 32.5/256.0;\n\n\n// 1 out, 3 in... <https://www.shadertoy.com/view/4djSRW>\n#define MOD3 vec3(.1031,.11369,.13787)\nfloat hash13(vec3 p3) {\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.x + p3.y)*p3.z);\n}\n\n\n/* ---------------- Sigmoid functions ------------------------------------ */\n\n// TODO: reduce unnecessary parameters (remove arguments, use global consts)\n\nfloat sigmoid_a(float x, float a, float b) {\n    return 1.0 / (1.0 + exp(-(x - a) * 4.0 / b));\n}\n\n// unnecessary \nfloat sigmoid_b(float x, float b, float eb) {\n    return 1.0 - sigmoid_a(x, b, eb);\n}\n\nfloat sigmoid_ab(float x, float a, float b, float ea, float eb) {\n    return sigmoid_a(x, a, ea) * sigmoid_b(x, b, eb);\n}\n\nfloat sigmoid_mix(float x, float y, float m, float em) {\n    return x * (1.0 - sigmoid_a(m, 0.5, em)) + y * sigmoid_a(m, 0.5, em);\n}\n\n/* ----------------------------------------------------------------------- */\n\n// SmoothLifeL\nfloat transition_function(vec2 disk_ring) {\n    return sigmoid_mix(sigmoid_ab(disk_ring.x, b1, b2, alpha_n, alpha_n),\n                       sigmoid_ab(disk_ring.x, d1, d2, alpha_n, alpha_n), disk_ring.y, alpha_m\n                      );\n}\n\n// unnecessary (?)\nfloat ramp_step(float steppos, float t) {\n    return clamp(t-steppos+0.5, 0.0, 1.0);\n}\n\n// unnecessary\nvec2 wrap(vec2 position) { return fract(position); }\n\n// Computes both inner and outer integrals\n// TODO: Optimize. Much redundant computation. Most expensive part of program.\nvec2 convolve(vec2 uv) {\n    vec2 result = vec2(0.0);\n    for (float dx = -r.x; dx <= r.x; dx++) {\n        for (float dy = -r.x; dy <= r.x; dy++) {\n            vec2 d = vec2(dx, dy);\n            float dist = length(d);\n            vec2 offset = d / iResolution.xy;\n            vec2 samplepos = wrap(uv + offset);\n            //if(dist <= r.y + 1.0) {\n                float weight = texture(iChannel0, samplepos).x;\n            \tresult.x += weight * ramp_step(r.y, dist) * (1.0-ramp_step(r.x, dist));\t\n            \t\n            //} else if(dist <= r.x + 1.) {\n                //float weight = texture(iChannel0, uv+offset).x;\n\t\t\t\tresult.y += weight * (1.0-ramp_step(r.y, dist));\n            //}\n        }\n    }\n    return result;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0.0);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Compute inner disk and outer ring area.\n    vec2 area = PI * r * r;\n    area.x -= area.y;\n    /* -------------------------------------*/\n    \n    // TODO: Cleanup.\n    color = texture(iChannel0, uv).xyz;\n    vec2 normalized_convolution = convolve(uv.xy).xy / area;\n    color.x = color.x + dt * (2.0 * transition_function(normalized_convolution) - 1.0);\n    color.yz = normalized_convolution;\n    color = clamp(color, 0.0, 1.0);\n    \n    // Set initial conditions. TODO: Move to function / cleanup\n    if(iFrame < 10 || texture( iChannel2, vec2(KEY_SPACE,0.5) ).x > 0.5) {\n        color = vec3(hash13(vec3(fragCoord, iFrame)) - texture(iChannel1, uv).x + 0.5);\n    }\n    \n    if(iMouse.z > 0.) {\n        //vec2 dst = abs(uv - iMouse.xy/iResolution.xy);\n        float dst = length((fragCoord.xy - iMouse.xy)/iResolution.xx);\n        /*if(max(dst.x * iResolution.x/iResolution.y, dst.y) < 0.05) {\n        \tcolor = vec3(hash13(vec3(fragCoord, iFrame)) - texture(iChannel1, uv).x + 0.5);\n        }*/\n        if(dst <= (r.x)/iResolution.x) {\n        \tcolor.x = step((r.y+1.5)/iResolution.x, dst) * (1.0 - step(r.x/iResolution.x, dst));\n        }\n        /*if(dst <= (r.x)/iResolution.x) {\n        \tcolor.x = step((r.y+1.0)/iResolution.x, dst) * (1.0 - step((r.x-0.5)/iResolution.x, dst));\n        }*/\n    }\n    \n    // Inspect transition function. TODO: Move to function / ifdef\n    if(texture( iChannel2, vec2(KEY_DOWN, 5.0/3.0) ).x > 0.5) {\n        color = vec3(transition_function(uv));\n    }\n    \n    if(texture( iChannel2, vec2(KEY_UP, 0.5)).x > 0.5) {\n    \tcolor = vec3(0.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}