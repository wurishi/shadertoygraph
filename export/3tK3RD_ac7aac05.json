{"ver":"0.1","info":{"id":"3tK3RD","date":"1578418495","viewed":141,"name":"AA-maze-ing","username":"spalmer","description":"hacked my aa checker testbed to filter Fabrice's clever one-line maze.  It's not perfect, still WIP, but better than the unfiltered version!","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["antialias","maze"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// an antialiased ALU maze.\n// Fabrice Neyret's teensy golfed maze algorithm:\n// https://www.shadertoy.com/view/lt2cRR\n// I just put his maze on a 3d plane since I had some code handy.\n// https://www.shadertoy.com/view/3tVGRz\n\nfloat smoothGrid(float x, float s, float g, float w)\n{\n    return mix(x, s, exp2(-g / w));    \n}\n\n// it's not his exact macro, but changed to have less gaps\nfloat mazeFabrice(vec2 p)\n{\n\treturn mod(p[int(1e4*length(ceil(p/4.)))&1], 4.) >= 1. ? 0. : 1.;\n}\n\nfloat mazeFabriceAA(vec2 p)\n{\n    vec2 dx = dFdx(p), dy = dFdy(p);\n    // fine, I give up on analytically filtering this; I'm just gonna discretely filter it.\n    // at least to get the value to blend to along the edge.\n    // still shows some unwanted grid cell edges though. \n    // Probably blurs too much toward the horizon.\n    vec2 w = vec2(length(dx), length(dy)); //filterWidth2(p);\n    w = w + .0001;\n\tfloat x = mazeFabrice(p);\n\tfloat y = .25 * (mazeFabrice(p + dx*vec2( .5, 0.))\n                   + mazeFabrice(p + dx*vec2(-.5, 0.))\n                   + mazeFabrice(p + dy*vec2( 0., .5))\n                   + mazeFabrice(p + dy*vec2( 0.,-.5)));\n    y = mix(y, .2, min(1., length(w))); // rebalance due to scale of maze empty vs. walls ratio; maze has more empty than filled\n    vec2 f = fract(p);\n    float g = min(f.x * (1.-f.x), f.y * (1.-f.y)) * 4.; //1.; // parabola box?\n    return smoothGrid(x, y, .125 * g, length(w));\n}\n\n\n// shown on right side of split screen\nfloat ImageR(vec2 uv)\n{\n    return mazeFabriceAA(uv);\n}\n// shown on left half of split screen\nfloat ImageL(vec2 uv)\n{\n    return mazeFabrice(uv);\n}\n\n\nconst float maxd = 850.;\n\n// halfspace\nfloat tracePlaneY(vec3 rp, vec3 rd)\n{\n    return rp.y <= 0. ? 0. :\n    \trd.y >= 0. ? -1. : //maxd :\n    \trp.y / -rd.y;\n}\n\n// cs is a cosine,sine pair representing angle of rotation as unit spinor\nvec2 rot(inout vec2 v, vec2 cs)\n{\n    float c = cs.x, s = cs.y;\n    // inlined rotation matrix 2x2 transforming v.\n    return v = vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}\n// there're so many ways to do this though.  at least it's not all inlined and undocumented.\n\nvec2 rot(inout vec2 v, float radians)\n{\n    return rot(v, vec2(cos(radians), sin(radians)));\n}\n\n\nvec3 CameraRay(vec2 p)\n{\n    vec2 q = (2. * p - iResolution.xy) / iResolution.y; // Fabrice's aspect-correct signed uv trick :)  I like it!\n    vec3 rd = normalize(vec3(q / 2., 1.));\n    float pitch = .4, yaw = iTime * .04;\n    rot(rd.yz, pitch);\n    rot(rd.xz, yaw);\n    return rd;\n}\n\n\nconst vec3 C1 = vec3(.5,.9,.8); //1.,1.,1.); //1.,1.,0.); //\nconst vec3 C2 = vec3(0.,.2,0.); //1.,0.,1.);\nconst vec3 Csky = vec3(.8,.9,1.);\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // a simple camera\n    vec3 rp = vec3(0,1,0);\n    rp.y += sin(iTime * 0.07f) * .99; // bob slowly up and down\n    vec3 rd = CameraRay(fragCoord);\n    \n    // Y plane distance\n    float d = maxd;\n    float dplane = tracePlaneY(rp, rd);\n    vec2 cc = vec2(1., 0.);\n    if (dplane >= 0.) {\n        d = min(d, dplane);\n\t    cc = rp.xz + rd.xz * d; // grid uv at hit point\n    \tcc *= 4.0; // tiling\n    }\n    \n    // split screen at mouse click\n    float splits = fragCoord.x - iMouse.x;\n    bool left = splits < 0.; //fragCoord.x < iMouse.x;\n    // depending on last mouse click, split screen between two different functions\n    float check = left \n        ? ImageL(cc)\n        : ImageR(cc);\n\n    vec3 c = mix(C1, C2, check); // colorize\n    \n    float fog = 1.0 - exp2(-.03*d); //0.; //\n    c = mix(c, Csky, fog);\n    // green vertical line at split\n    c = mix(c, vec3(.0,.5,.0), exp2(-2. * abs(splits)));\n    c = pow(c, vec3(1./2.2)); // to srgb gamma\n    // output to screen\n    fragColor = vec4(c, 1.);\n}\n ","name":"Image","description":"","type":"image"}]}