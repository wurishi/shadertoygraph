{"ver":"0.1","info":{"id":"4ssyRj","date":"1488925325","viewed":183,"name":"Log color space","username":"piratehurrdurr","description":"Hey all,\n\nCheck out the comment in the Image buffer! \n\nThis demo is in no way written to be optimized. It is there to convey the picture.\nCode for calculating the normal of an SDF scene can be found here:\nhttps://github.com/stackgl/glsl-sdf-normal/blob/ma","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["colorspace","unreal","log","ue"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nHello everyone,\n\nThis shader is written by me to demonstrate the changes of the tonemapper in UE4.15.\nThe tonemapper used in 4.15 requires projects to make some drastic changes to the\nlighting in the scene. These changes are in my opinion for the better.\n\nMy lessons learned will be used for my education.\n\nThe tonemapper is more in tune with movie cameras and can thus properly feed into a\npostprocessor. Also the fact that this tonemapper exists means that more accurate\nvalues can be used for lighting, such as a brighter sun, which has effects on a more\naccurate bloom and depth of field effect as well.\n\nThis problem only exists because the screens we use to view scenes are not as powerful\nas the sun. I have yet to witness a HDR sceen myself but I hope it is as exiting as\nit sounds.\n\nIn this demo I demonstrate three different illumination techniques used in games.\nEvery five seconds the demo switches from classic, to UE4.14, to UE4.15.\nAlso the pillar glows stronger over time, demonstrating clipping.\nYou can enable clipping warning by uncommeting the DISPLAY_OVERBRIGHT define down below.\n\nTo prove a point a proper bloom could be applied by blurring the scene image, and mixing\nthis with the original scene image, doing this in linear space. So no addition trickery.\n\nThis demo is in no way written to be optimized. It is there to convey the picture.\nCode for calculating the normal of an SDF scene can be found here:\nhttps://github.com/stackgl/glsl-sdf-normal/blob/master/index.glsl\nThe code for the gaussion blur can be found here (thanks mrharicot):\nhttps://www.shadertoy.com/view/XdfGDH\n\nThanks IQ and Epic Games for making our lives easier.\n*/\n\n//#define DISPLAY_OVERBRIGHT\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;    \n    fragColor.rgb = texture(iChannel0, uv).rgb;\n    \n    //int mode  = int(uv.x*4.0);\n    int mode = (int(floor(uv.x+0.5)));\n    mode+=int(floor(uv.y+0.5)*2.0);\n    if (mode == 0) {\n        fragColor.rgb*=0.1;\n    } else if (mode==1) {\n        fragColor.rgb = pow(fragColor.rgb*0.05, 1.0/vec3(2.2))-0.02;\n    } else if (mode==2) {\n         const float n3= 4.0f;\n    \tconst float n1 = 0.2f;\n    \tconst float n2 = -0.1f;\n    \tfragColor = log(fragColor*n3 + 1.0)*n1 + n2;\n    } else if (mode==3) {\n        const float n1=6.0;\n        const float n2 = 1.0;\n        fragColor = fragColor / (fragColor+n1)*n2;\n    }\n    \n   #ifdef DISPLAY_OVERBRIGHT\n    if (fragColor.r>=1.0) {\n        fragColor.r=0.0;\n    }\n    if (fragColor.g>=1.0) {\n        fragColor.g=0.0;\n    }\n    if (fragColor.b>=1.0) {\n        fragColor.b=0.0;\n    }\n    #endif\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nCreate the sample scene in linear color space\nDon't mind the messy code\n*/\n\n\n\n#define SAMPLES 256\n#define ERR 1.0e-4\n#define EPS 1.0e-2\n\n\n#define SUN normalize(vec3(1.0f,2.0f,-0.3f))\n\n\n//#define DISPLAY_OVERBRIGHT\n\nvec3 sun(vec3 dir) {\n    return vec3(20.0f,12.0,5.3)*max(0.0,dot(dir, SUN));\n}\n\nvec3 ambient(vec3 dir) {\n    return (vec3(3.0,5.0,9.0)) + sun(dir)*0.3;\n}\n\nfloat DistPillar(const vec3 pos, const float size) {\n    return length(pos.xz)-size;\n}\n\nfloat DistFloor(const vec3 pos) {\n    return pos.y;\n}\n\nfloat Dist(const vec3 pos) {\n    return min(DistFloor(pos+vec3(0.0,1.8,0.0)), DistPillar(pos+vec3(1.1,0.0,-6.0), 1.5));\n}\n\nint Ray(out vec3 pos, vec3 dir) {\n    int i=0;\n    while (i<=SAMPLES) {\n        float dist = Dist(pos);\n        if (dist<ERR) {\n            return i;\n        }\n        pos+=dir*dist;\n        ++i;\n    }\n    return -1;\n}\n\nfloat ShadowRay(vec3 pos, const vec3 sun) {\n    float accdist = 0.0;\n    float accshadow = 1.0;\n    const float _stepsize =0.1f;\n    vec3 _step = sun*_stepsize;\n    \n    int i=0;\n    while (i<SAMPLES) {\n        pos+=_step;\n        float dist = Dist(pos);\n        accdist+=_stepsize*0.06;\n        \n       accshadow = min(accshadow, dist/accdist);\n        \n        if (accshadow<0.0) {\n            return 0.0;\n        }\n        ++i;\n    }\n    return accshadow;\n}\n\nvec3 Normal(const vec3 pos) {\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n  return normalize( v1 * Dist( pos + v1*EPS ) +\n                    v2 * Dist( pos + v2*EPS ) +\n                    v3 * Dist( pos + v3*EPS ) +\n                    v4 * Dist( pos + v4*EPS ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv2 = fragCoord.xy/iResolution.xy*2.0;\n    vec2 uv=mod(uv2,1.0)-0.5;\n    \n\t//vec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 forward = vec3(0.0,0.0,1.0);\n    vec3 up = vec3(0.0,1.0,0.0);\n    vec3 right = vec3(1.0,0.0,0.0);\n    \n    \n    const vec3 start = vec3(0.0);\n    vec3 dir = normalize( forward+up*uv.y + right*uv.x);\n    vec3 world = start;\n    int samples = Ray(world, dir );\n    \n    if (samples==-1) {\n        fragColor.rgb= ambient(dir);\n    } else {\n    \n    fragColor = vec4(0.5f);\n    fragColor = texture(iChannel0, world.xz*0.3+world.y*0.4);\n    \n    vec3 normal = Normal(world);\n    vec3 l = vec3(0.0);\n        \n        l+=ambient(vec3(0.0,1.0,0.0));\n        l+=ShadowRay(world, SUN)*sun(normal);\n        \n    \n    //if (samples>=0) {\n    //    fragColor.rgb = vec3(0.0);\n    //}\n    \n    \n    float fogAmount = 1.0 - 1.0 / (1.0 + length(start-world)*0.02);\n    fragColor = mix(fragColor, vec4(0.5f), fogAmount);\n    l = mix(l, vec3(0.5), fogAmount);\n    \n       \n        float heat = mod(iTime, 5.0);\n        \n            fragColor.rgb = fragColor.rgb+max((world.y+0.5)*heat*heat*heat,0.0)*vec3(1.0,0.03,0.01);\n        \n    fragColor.rgb*=l;\n    }\n    \n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //Downsample for faster bloom\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy*16.0;\n    fragColor = texture(iChannel0, uv);\n    \n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"float normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragCoord.xy/=16.0;\n\n\tconst int mSize = 9;\n\t\tconst int kSize = (mSize-1)/2;\n\t\tfloat kernel[mSize];\n\t\tvec3 final_colour = vec3(0.0);\n\t\t\n\t\t//create the 1-D kernel\n\t\tfloat sigma =2.0;\n\t\tfloat Z = 0.0;\n\t\tfor (int j = 0; j <= kSize; ++j)\n\t\t{\n\t\t\tkernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n\t\t}\n\t\t\n\t\t//get the normalization factor (as the gaussian has been clamped)\n\t\tfor (int j = 0; j < mSize; ++j)\n\t\t{\n\t\t\tZ += kernel[j];\n\t\t}\n\t\t\n\t\t//read out the texels\n\t\tfor (int i=-kSize; i <= kSize; ++i)\n\t\t{\n\t\t\tfor (int j=-kSize; j <= kSize; ++j)\n\t\t\t{\n\t\t\t\tfinal_colour += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel0, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfragColor = vec4(mix( final_colour/(Z*Z), texture(iChannel1, uv).rgb,0.97), 1.0);\n}","name":"Buf C","description":"","type":"buffer"}]}