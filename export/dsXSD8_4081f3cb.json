{"ver":"0.1","info":{"id":"dsXSD8","date":"1668870694","viewed":460,"name":"Jump Flood Distance 2D","username":"spalmer","description":"Learning the jump flood technique from demofox and paniq, hope I simplified it enough to be worthy of posting","likes":19,"published":1,"flags":32,"usePreview":0,"tags":["2d","voronoi","sdf","distance","jumpflood"],"hasliked":0,"parentid":"Mdy3DK","parentname":"Jump Flood Algorithm: Points"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// demonstrate Jump Flood algorithm\n// fork of demofox http://shadertoy.com/view/Mdy3DK\n// see also http://shadertoy.com/view/lsKGDV\n// all inspired by paniq http://shadertoy.com/view/4syGWK\n// apparently there's a paper!  http://comp.nus.edu.sg/~tants/jfa/i3d06.pdf\n\nvoid mainImage(out vec4 o, vec2 fc)\n{\n    // show closest seed from BufferA in iChannel0\n\tvec2 seed = T(fc);\n    vec3 color = seed.x >= 0. //&& seed.y >= 0. \n        ? vec3(hash(seed), hash(seed*2.1), hash(seed*1.4)) * .9 + .1\n        : vec3(0);\n    color *= cos(.8 * length(seed - fc)) * .2 + .8;\n    o = vec4(pow(color, vec3(.45)), 1);\n}\n\n// kastorp ported to 3d  :)  http://shadertoy.com/view/cdlXRl","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// JFA steps to do.  supports resolutions up to 2^maxSteps\nconst int maxSteps = 12;\n\n// frames between steps.  1 = full speed.\nconst int frameStepDelay = 1; //5; //15; //50; //\n\nfloat sqr(vec2 v) { return dot(v, v); }\n\nvec2 StepJFA(vec2 p, int level)\n{\n    level = maxSteps - 1 - level; // reverse order: coarse to fine works much better\n    level = clamp(level, 0, maxSteps);\n    vec2 best = vec2(-1);\n    float bestd2 = 3e38,\n        w = float(1 << level);   \n    for (float y = -w; y <= w; y += w)\n    for (float x = -w; x <= w; x += w) {\n        vec2 seed = T(vec2(x,y) + p);\n        if (seed.x >= 0.) { // && seed.y >= 0.) // skip computing for yet invalid seeds\n            float d2 = sqr(seed - p);\n            if (bestd2 > d2) {\n                bestd2 = d2;\n                best = seed;\n            }\n        }\n    }\n    return best;\n}\n\nbool isSeed(vec2 fc)\n{\n    float approxCount = 24.,\n      seedChance = approxCount/iResolution.x/iResolution.y, \n      rchance = sqrt(seedChance); // 2 hashes because precision issues\n    return hash(fc.yx + fract(iDate.w * 1.214)) < rchance\n        && hash(3.*fc + fract(iDate.w * 2.123)) < rchance;\n}\n            \nvoid mainImage(out vec4 o, vec2 fc) // fragCoord\n{\n    vec2 seed;\n    int f = iFrame & 2047;\n    if (f == 0) {\n        // initialize random seed locations\n        seed = isSeed(fc) \n            ? floor(fc) : vec2(-1);\n    } else {    \n        // periodic steps\n        seed = (f % frameStepDelay == 0)\n            ? StepJFA(fc, f / frameStepDelay - 1) : T(fc);\n    }\n    o = vec4(seed, 0, 0); // output data has closest seed location in xy\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Hoskins hash without sine from http://shadertoy.com/view/4djSRW\nfloat hash(vec2 p)\n{\n\tvec3 q = fract(vec3(p.xyx) * .1031);\n    q += dot(q, q.yzx + 19.19);\n    return fract((q.x + q.y) * q.z);\n}\n\n// obtain nearest seed location to p from BufferA\n#define T(p) texture(iChannel0, (p) / iResolution.xy).xy","name":"Common","description":"","type":"common"}]}