{"ver":"0.1","info":{"id":"XsfyWS","date":"1489526631","viewed":861,"name":"Resolve","username":"TimothyLottes","description":"Comparison of resolve filters","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["noise","antialiasing","filtering","resolve"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// CHANGE THIS MODE DEFINE TO TRY DIFFERENT OPTIONS\n//  \n// Sorry, only looks right at 1920x1080 non-full-screen.\n//\n\n// 0 Red ......... NoAA\n// 1 Orange ...... NoAA + 2x2 Programmable Pixel Locations + Gaussian Resolve \n// 2 Gold ........ NoAA + Jittered Pixel Locations + Noise\n// 3 Yellow ...... NoAA + Jittered Pixel Locations + Gaussian Resolve + Noise\n// 4 Lime ........ 2xSGSSAA + Box Filter\n// 5 Green ....... 2xSGSSAA + Jittered Pixel Locations + Gaussian Resolve + Noise\n// 6 BlueGreen ... 4xSGSSAA + Box Filter\n// 7 Blue ........ 4xSGSSAA + Jittered Pixel Locations + Gaussian Resolve + Noise\n#define MODE 1\n\n//================================================================================\n\n#define F1 float\n#define F2 vec2\n#define F3 vec3\n#define F4 vec4\n\n// Convert from linear to sRGB.\nF1 Srgb(F1 c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\n\n// Convert from sRGB to linear.\nF1 Linear(F1 c){return(c<=0.04045)?c/12.92:pow((c+0.055)/1.055,2.4);}    \n\n//\n// Semi-Poor Quality Temporal Noise\n//\n\n// Base.\n// Ripped ad modified from: https://www.shadertoy.com/view/4djSRW\nF1 Noise(F2 p,F1 x){p+=x;\n F3 p3=fract(F3(p.xyx)*10.1031);\n p3+=dot(p3,p3.yzx+19.19);\n return fract((p3.x+p3.y)*p3.z)*2.0-1.0;}\n\n// Step 1 in generation of the dither source texture.\nF1 Noise1(F2 uv,F1 n){\n F1 a=1.0,b=2.0,c=-12.0,t=1.0;   \n return (1.0/max(a*4.0+b*4.0,-c))*(\n  Noise(uv+F2(-1.0,-1.0)*t,n)*a+\n  Noise(uv+F2( 0.0,-1.0)*t,n)*b+\n  Noise(uv+F2( 1.0,-1.0)*t,n)*a+\n  Noise(uv+F2(-1.0, 0.0)*t,n)*b+\n  Noise(uv+F2( 0.0, 0.0)*t,n)*c+\n  Noise(uv+F2( 1.0, 0.0)*t,n)*b+\n  Noise(uv+F2(-1.0, 1.0)*t,n)*a+\n  Noise(uv+F2( 0.0, 1.0)*t,n)*b+\n  Noise(uv+F2( 1.0, 1.0)*t,n)*a+\n 0.0);}\n    \n// Step 2 in generation of the dither source texture.\nF1 Noise2(F2 uv,F1 n){\n F1 a=1.0,b=2.0,c=-2.0,t=1.0;   \n return (1.0/(a*4.0+b*4.0))*(\n  Noise1(uv+F2(-1.0,-1.0)*t,n)*a+\n  Noise1(uv+F2( 0.0,-1.0)*t,n)*b+\n  Noise1(uv+F2( 1.0,-1.0)*t,n)*a+\n  Noise1(uv+F2(-1.0, 0.0)*t,n)*b+\n  Noise1(uv+F2( 0.0, 0.0)*t,n)*c+\n  Noise1(uv+F2( 1.0, 0.0)*t,n)*b+\n  Noise1(uv+F2(-1.0, 1.0)*t,n)*a+\n  Noise1(uv+F2( 0.0, 1.0)*t,n)*b+\n  Noise1(uv+F2( 1.0, 1.0)*t,n)*a+\n 0.0);}\n\n// Compute temporal dither from integer pixel position uv.\nF1 Noise3(F2 uv){return Noise2(uv,fract(iTime));}    \n\n// Energy preserving dither, for {int pixel pos,color,amount}.\nF1 Noise4(F2 uv,F1 c,F1 a){\n // Grain value {-1 to 1}.\n F1 g=Noise3(uv)*2.0;\n // Step size for black in non-linear space.\n F1 rcpStep=1.0/(256.0-1.0);\n // Estimate amount negative which still quantizes to zero.\n F1 black=0.5*Linear(rcpStep);\n // Estimate amount above 1.0 which still quantizes to 1.0.\n F1 white=2.0-Linear(1.0-rcpStep);\n // Add grain.\n return clamp(c+g*min(c+black,min(white-c,a)),0.0,1.0);}\n\n//\n// Pattern\n//\n\n// Dummy shader given pixel position.\nF1 Shade(F2 p){\n p.xy+=sin(iTime)*2.0;\n F2 pp=F2(p.x+p.y/16.0,p.y+p.x/16.0);\n pp*=pp;\n F1 x=sin(pp.x/800.0)>0.0?0.5:0.0;\n F1 y=sin(pp.y/1000.0)>0.0?0.5:0.0;\n return x+y;}\n\n// 4xMSAA pattern for quad given integer coordinates.\n//\n//  . x . . | < pixel\n//  . . . x |\n//  x . . .\n//  . . x .\n//\n//  01\n//  23\n//\nF2 Quad4(F2 pp){\n int q=(int(pp.x)&1)+((int(pp.y)&1)<<1);\n if(q==0)return pp+F2( 0.25,-0.25);\n if(q==1)return pp+F2( 0.25, 0.25);\n if(q==2)return pp+F2(-0.25,-0.25);\n         return pp+F2(-0.25, 0.25);}\n\n// Rotate {0.0,r} by a {-1.0 to 1.0}. \nF2 Rot(F1 r,F1 a){return F2(r*cos(a*3.14159),r*sin(a*3.14159));}\n\n// Rotate {pp} by a {0.0 to 1.0}. \nF2 Rot2(F2 pp,F1 a){\n a*=3.14159*2.0;\n F1 cosA=cos(a);\n F1 sinA=sin(a);\n return F2(dot(pp,F2(cosA,sinA)),dot(pp,F2(-sinA,cosA)));}\n\n//\n// SINGLE SAMPLE RESOLVES\n//\n    \n// Single center sample.\n//\n//  x\n//\nF1 ResolveNoAA(F2 pp){return Shade(pp);}\n\n//\n// FIXED QUAD RESOLVES\n//\n\n// Single center sample using Quad4 sample positions (no filtering).\n//\n//  x\n//\nF1 ResolveQuad4(F2 pp){return Shade(Quad4(floor(pp)));}\n\n// Gaussian filtered.\nvoid Quad4Gaus(inout F1 sumC,inout F1 sumW,F2 pp,F2 mm){\n F2 jj=Quad4(pp);\n F1 c=Shade(jj);\n F2 vv=mm-jj;\n F1 w=exp2(-2.0*dot(vv,vv));    \n sumC+=c*w; sumW+=w;}   \n\n// Single center sample using Quad4 sample positions (with guassian filtering).\n//\n//  . x x x . \n//  x x x x x \n//  x x x x x \n//  x x x x x \n//  . x x x . \n//\nF1 ResolveQuad4Gaus(F2 pp){\n pp=floor(pp);\n F1 sumC=0.0;\n F1 sumW=0.0;\n Quad4Gaus(sumC,sumW,pp+F2(-1.0,-2.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2( 0.0,-2.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2( 1.0,-2.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2(-2.0,-1.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2(-1.0,-1.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2( 0.0,-1.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2( 1.0,-1.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2( 2.0,-1.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2(-2.0, 0.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2(-1.0, 0.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2( 0.0, 0.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2( 1.0, 0.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2( 2.0, 0.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2(-2.0, 1.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2(-1.0, 1.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2( 0.0, 1.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2( 1.0, 1.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2( 2.0, 1.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2(-1.0, 2.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2( 0.0, 2.0),pp);\n Quad4Gaus(sumC,sumW,pp+F2( 1.0, 2.0),pp);\n return sumC/sumW;}\n\n// Disc filtered.\nvoid Quad4Disc(inout F1 sumC,inout F1 sumW,F2 pp,F2 mm){\n F2 jj=Quad4(pp);\n F1 c=Shade(jj);\n F2 vv=mm-jj;\n // disc contribution (faster than gaussian)\n //  d=distance\n //  r=radius^2 for 1.0\n //  f=radius^2 to drop to 0.0\n F1 r=0.707*1.75;\n F1 f=r+0.707*0.333;\n r=r*r;f=f*f;\n F1 s=1.0/(r-f);\n F1 t=f/(f-r);    \n F1 w=clamp(dot(vv,vv)*s+t,0.0,1.0);\n sumC+=c*w; sumW+=w;}   \n    \n// Single center sample using Quad4 sample positions (with disc filtering).\n//\n//  . x x x . \n//  x x x x x \n//  x x x x x \n//  x x x x x \n//  . x x x . \n//\nF1 ResolveQuad4Disc(F2 pp){\n pp=floor(pp);\n F1 sumC=0.0;\n F1 sumW=0.0;\n Quad4Disc(sumC,sumW,pp+F2(-1.0,-2.0),pp);\n Quad4Disc(sumC,sumW,pp+F2( 0.0,-2.0),pp);\n Quad4Disc(sumC,sumW,pp+F2( 1.0,-2.0),pp);\n Quad4Disc(sumC,sumW,pp+F2(-2.0,-1.0),pp);\n Quad4Disc(sumC,sumW,pp+F2(-1.0,-1.0),pp);\n Quad4Disc(sumC,sumW,pp+F2( 0.0,-1.0),pp);\n Quad4Disc(sumC,sumW,pp+F2( 1.0,-1.0),pp);\n Quad4Disc(sumC,sumW,pp+F2( 2.0,-1.0),pp);\n Quad4Disc(sumC,sumW,pp+F2(-2.0, 0.0),pp);\n Quad4Disc(sumC,sumW,pp+F2(-1.0, 0.0),pp);\n Quad4Disc(sumC,sumW,pp+F2( 0.0, 0.0),pp);\n Quad4Disc(sumC,sumW,pp+F2( 1.0, 0.0),pp);\n Quad4Disc(sumC,sumW,pp+F2( 2.0, 0.0),pp);\n Quad4Disc(sumC,sumW,pp+F2(-2.0, 1.0),pp);\n Quad4Disc(sumC,sumW,pp+F2(-1.0, 1.0),pp);\n Quad4Disc(sumC,sumW,pp+F2( 0.0, 1.0),pp);\n Quad4Disc(sumC,sumW,pp+F2( 1.0, 1.0),pp);\n Quad4Disc(sumC,sumW,pp+F2( 2.0, 1.0),pp);\n Quad4Disc(sumC,sumW,pp+F2(-1.0, 2.0),pp);\n Quad4Disc(sumC,sumW,pp+F2( 0.0, 2.0),pp);\n Quad4Disc(sumC,sumW,pp+F2( 1.0, 2.0),pp);\n return sumC/sumW;}\n\n//\n// POOR QUALITY BOX SGSSAA\n//\n\n// Box filtered 2xSGSSAA.\n//\n//  x .\n//  . x\n//\nF1 ResolveBox2xSSAA(F2 pp){return 0.5*Shade(pp-F2(0.25,0.25))+0.5*Shade(pp+F2(0.25,0.25));}\n\n// Box filtered 4xSGSSAA.\n//\n//  . . x .\n//  x . . .\n//  . . . x\n//  . x . .\n//\nF1 ResolveBox4xSSAA(F2 pp){return\n Shade(pp+F2( 0.125,-0.375))*0.25+\n Shade(pp+F2(-0.375,-0.125))*0.25+\n Shade(pp+F2( 0.375, 0.125))*0.25+\n Shade(pp+F2(-0.125, 0.375))*0.25;}\n\n//\n// POOR QUALITY JITTERED\n//\n\n// Jittered position.\nF2 Jit(F2 pp){\n // Start with better baseline pattern.\n pp=Quad4(pp);\n // Very poor quality (clumping) move in disc around pixel.\n F1 n=Noise(pp,fract(iTime));    \n F1 m=Noise(pp,fract(iTime*0.333))*0.5+0.5;\n m = sqrt(m);\n return pp+Rot(0.707*0.5*m,n);}\n\n// Single poor quality jittered sample.\n//\n//  x\n//\nF1 ResolveJit(F2 pp){return Shade(Jit(floor(pp)));}\n\n// Gaussian filtered jittered tap.\nvoid JitGaus(inout F1 sumC,inout F1 sumW,F2 pp,F2 mm){\n F2 jj=Jit(pp);\n F1 c=Shade(jj);\n F2 vv=mm-jj;\n F1 w=exp2(-4.0*dot(vv,vv));    \n sumC+=c*w; sumW+=w;}   \n\n// Many tap gaussian from poor quality jittered single/sample per pixel\n//\n//  . x x x . \n//  x x x x x \n//  x x x x x \n//  x x x x x \n//  . x x x . \n//\nF1 ResolveJitGaus(F2 pp){\n pp=floor(pp);\n F1 sumC=0.0;\n F1 sumW=0.0;\n JitGaus(sumC,sumW,pp+F2(-1.0,-2.0),pp);\n JitGaus(sumC,sumW,pp+F2( 0.0,-2.0),pp);\n JitGaus(sumC,sumW,pp+F2( 1.0,-2.0),pp);\n JitGaus(sumC,sumW,pp+F2(-2.0,-1.0),pp);\n JitGaus(sumC,sumW,pp+F2(-1.0,-1.0),pp);\n JitGaus(sumC,sumW,pp+F2( 0.0,-1.0),pp);\n JitGaus(sumC,sumW,pp+F2( 1.0,-1.0),pp);\n JitGaus(sumC,sumW,pp+F2( 2.0,-1.0),pp);\n JitGaus(sumC,sumW,pp+F2(-2.0, 0.0),pp);\n JitGaus(sumC,sumW,pp+F2(-1.0, 0.0),pp);\n JitGaus(sumC,sumW,pp+F2( 0.0, 0.0),pp);\n JitGaus(sumC,sumW,pp+F2( 1.0, 0.0),pp);\n JitGaus(sumC,sumW,pp+F2( 2.0, 0.0),pp);\n JitGaus(sumC,sumW,pp+F2(-2.0, 1.0),pp);\n JitGaus(sumC,sumW,pp+F2(-1.0, 1.0),pp);\n JitGaus(sumC,sumW,pp+F2( 0.0, 1.0),pp);\n JitGaus(sumC,sumW,pp+F2( 1.0, 1.0),pp);\n JitGaus(sumC,sumW,pp+F2( 2.0, 1.0),pp);\n JitGaus(sumC,sumW,pp+F2(-1.0, 2.0),pp);\n JitGaus(sumC,sumW,pp+F2( 0.0, 2.0),pp);\n JitGaus(sumC,sumW,pp+F2( 1.0, 2.0),pp);\n return sumC/sumW;}\n\n//\n// POOR QUALITY JITTERED 2x\n//\n\n// Gaussian filtered jittered tap.\nvoid JitGaus2(inout F1 sumC,inout F1 sumW,F2 pp,F2 mm){\n F2 jj=Jit(pp);\n F1 c=Shade(jj/sqrt(2.0));\n F2 vv=mm-jj;\n F1 w=exp2(-2.0*dot(vv,vv));    \n sumC+=c*w; sumW+=w;}   \n\n// Many tap gaussian from poor quality jittered 2/sample per pixel\n//\n//  . x x x . \n//  x x x x x \n//  x x x x x \n//  x x x x x \n//  . x x x . \n//\nF1 ResolveJitGaus2(F2 pp){\n pp*=sqrt(2.0);\n F2 ppp=floor(pp);\n F1 sumC=0.0;\n F1 sumW=0.0;\n JitGaus2(sumC,sumW,ppp+F2(-1.0,-2.0),pp);\n JitGaus2(sumC,sumW,ppp+F2( 0.0,-2.0),pp);\n JitGaus2(sumC,sumW,ppp+F2( 1.0,-2.0),pp);\n JitGaus2(sumC,sumW,ppp+F2(-2.0,-1.0),pp);\n JitGaus2(sumC,sumW,ppp+F2(-1.0,-1.0),pp);\n JitGaus2(sumC,sumW,ppp+F2( 0.0,-1.0),pp);\n JitGaus2(sumC,sumW,ppp+F2( 1.0,-1.0),pp);\n JitGaus2(sumC,sumW,ppp+F2( 2.0,-1.0),pp);\n JitGaus2(sumC,sumW,ppp+F2(-2.0, 0.0),pp);\n JitGaus2(sumC,sumW,ppp+F2(-1.0, 0.0),pp);\n JitGaus2(sumC,sumW,ppp+F2( 0.0, 0.0),pp);\n JitGaus2(sumC,sumW,ppp+F2( 1.0, 0.0),pp);\n JitGaus2(sumC,sumW,ppp+F2( 2.0, 0.0),pp);\n JitGaus2(sumC,sumW,ppp+F2(-2.0, 1.0),pp);\n JitGaus2(sumC,sumW,ppp+F2(-1.0, 1.0),pp);\n JitGaus2(sumC,sumW,ppp+F2( 0.0, 1.0),pp);\n JitGaus2(sumC,sumW,ppp+F2( 1.0, 1.0),pp);\n JitGaus2(sumC,sumW,ppp+F2( 2.0, 1.0),pp);\n JitGaus2(sumC,sumW,ppp+F2(-1.0, 2.0),pp);\n JitGaus2(sumC,sumW,ppp+F2( 0.0, 2.0),pp);\n JitGaus2(sumC,sumW,ppp+F2( 1.0, 2.0),pp);\n return sumC/sumW;}\n\n//\n// POOR QUALITY JITTERED 4x\n//\n\n// Gaussian filtered jittered tap.\nvoid JitGaus4(inout F1 sumC,inout F1 sumW,F2 pp,F2 mm){\n F2 jj=Jit(pp);\n F1 c=Shade(jj/sqrt(4.0));\n F2 vv=mm-jj;\n F1 w=exp2(-1.0*dot(vv,vv));    \n sumC+=c*w; sumW+=w;}   \n\n// Many tap gaussian from poor quality jittered 4/sample per pixel\n//\n//  . x x x . \n//  x x x x x \n//  x x x x x \n//  x x x x x \n//  . x x x . \n//\nF1 ResolveJitGaus4(F2 pp){\n pp*=sqrt(4.0);\n F2 ppp=floor(pp);\n F1 sumC=0.0;\n F1 sumW=0.0;\n JitGaus4(sumC,sumW,ppp+F2(-1.0,-2.0),pp);\n JitGaus4(sumC,sumW,ppp+F2( 0.0,-2.0),pp);\n JitGaus4(sumC,sumW,ppp+F2( 1.0,-2.0),pp);\n JitGaus4(sumC,sumW,ppp+F2(-2.0,-1.0),pp);\n JitGaus4(sumC,sumW,ppp+F2(-1.0,-1.0),pp);\n JitGaus4(sumC,sumW,ppp+F2( 0.0,-1.0),pp);\n JitGaus4(sumC,sumW,ppp+F2( 1.0,-1.0),pp);\n JitGaus4(sumC,sumW,ppp+F2( 2.0,-1.0),pp);\n JitGaus4(sumC,sumW,ppp+F2(-2.0, 0.0),pp);\n JitGaus4(sumC,sumW,ppp+F2(-1.0, 0.0),pp);\n JitGaus4(sumC,sumW,ppp+F2( 0.0, 0.0),pp);\n JitGaus4(sumC,sumW,ppp+F2( 1.0, 0.0),pp);\n JitGaus4(sumC,sumW,ppp+F2( 2.0, 0.0),pp);\n JitGaus4(sumC,sumW,ppp+F2(-2.0, 1.0),pp);\n JitGaus4(sumC,sumW,ppp+F2(-1.0, 1.0),pp);\n JitGaus4(sumC,sumW,ppp+F2( 0.0, 1.0),pp);\n JitGaus4(sumC,sumW,ppp+F2( 1.0, 1.0),pp);\n JitGaus4(sumC,sumW,ppp+F2( 2.0, 1.0),pp);\n JitGaus4(sumC,sumW,ppp+F2(-1.0, 2.0),pp);\n JitGaus4(sumC,sumW,ppp+F2( 0.0, 2.0),pp);\n JitGaus4(sumC,sumW,ppp+F2( 1.0, 2.0),pp);\n return sumC/sumW;}\n\n//\n// ENTRY\n//\n\nvoid mainImage(out F4 fragColor,in F2 fragCoord){\n F2 pp=fragCoord;\n F1 cc=0.0;\n int ss=MODE;\n // Red\n if(ss==0){\n  if(pp.y<8.0){fragColor.xyz=F3(1.0,0.0,0.0);return;}\n  cc=ResolveNoAA(pp);}\n // Orange\n else if(ss==1){\n  if(pp.y<8.0){fragColor.xyz=F3(1.0,0.5,0.0);return;}\n  cc=ResolveQuad4Gaus(pp);}\n // Gold\n else if(ss==2){\n  if(pp.y<8.0){fragColor.xyz=F3(1.0,0.75,0.0);return;}\n  cc=ResolveJit(pp);\n  cc=Noise4(pp,cc,0.5);}\n // Yellow\n else if(ss==3){\n  if(pp.y<8.0){fragColor.xyz=F3(1.0,1.0,0.0);return;}\n  cc=ResolveJitGaus(pp);\n  cc=Noise4(pp,cc,0.5);}\n // Lime\n else if(ss==4){\n  if(pp.y<8.0){fragColor.xyz=F3(0.5,1.0,0.0);return;}\n  cc=ResolveBox2xSSAA(pp);}\n // Green\n else if(ss==5){\n  if(pp.y<8.0){fragColor.xyz=F3(0.0,1.0,0.0);return;}\n  cc=ResolveJitGaus2(pp);\n  cc=Noise4(pp,cc,0.125);}\n // Green Blue\n else if(ss==6){\n  if(pp.y<8.0){fragColor.xyz=F3(0.0,1.0,0.5);return;}\n  cc=ResolveBox4xSSAA(pp);}\n // Blue\n else if(ss==7){\n  if(pp.y<8.0){fragColor.xyz=F3(0.0,0.0,1.0);return;}\n  cc=ResolveJitGaus4(pp);\n  cc=Noise4(pp,cc,1.0/16.0);}     \n // Output   \n fragColor.x=Srgb(cc);\n fragColor.yxz=fragColor.xxx;}\n","name":"Image","description":"","type":"image"}]}