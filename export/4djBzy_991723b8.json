{"ver":"0.1","info":{"id":"4djBzy","date":"1500957381","viewed":142,"name":"Buggy Rip of IQs Heart","username":"Slyth","description":"No clue why the shadows are bugging out. Not too worried about it. Was just interested in messing around with sphere deformations. Wrote this in very short amount of time, not high quality whatsoever. Credit to www.youtube.com/watch?v=aNR4n0i2ZlM (IQ)","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 obj_union(in vec2 obj0, in vec2 obj1)\n{\n\tif (obj0.x < obj1.x)\n    \treturn obj0;\n\telse\n    \treturn obj1;\n}\n\nvec2 obj_floor(in vec3 p)\n{\n\treturn vec2(p.y+4.0,0);\n}\n\nvec2 obj_sphere(in vec3 op, float r)\n{\n    float theta = iTime * 0.5;\n    mat3 rot = mat3(vec3(cos(theta), 0.0, -sin(theta)),\n                    vec3(0.0, 1.0, 0.0),\n                    vec3(sin(theta), 0.0, cos(theta)));\n    vec3 p = op * rot;\n    r = r + r / 5.0 * pow(0.5 + 0.5 * sin(2.0 * 3.14159265 * iTime + p.y), 3.5);\n    p.z = p.z * (2.1 - p.y);\n    p.y = 1.2 * p.y - abs(p.x) * sqrt(max(1.25 - abs(p.x), 0.0));\n  \treturn vec2(length(p) - r, 1.0);\n}\n\nvec2 distance_to_obj(in vec3 p)\n{\n  \treturn obj_union(obj_floor(p), obj_sphere(p + vec3(0.0, 1.0, 0.0), 1.0));\n}\n\nfloat shadowSoft( vec3 ro, vec3 rd, float mint, float maxt, float k )\n{\n\tfloat t = mint;\n\tfloat res = 1.0;\n    for ( int i = 0; i < 64; ++i )\n    {\n        vec2 h = distance_to_obj( ro + rd * t * .6);\n        if ( h.x < 0.001 )\n            return 0.1;\n\t\t\n\t\tres = min( res, k * h.x / t );\n        t += h.x;\n\t\t\n\t\tif ( t > maxt )\n\t\t\tbreak;\n    }\n    return res;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = distance_to_obj( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 1.0;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 floor_color(in vec3 p)\n{\n    float f = mod(floor(p.z / 3.0) + floor(p.x / 3.0), 2.0);\n\treturn 0.3 + 0.1 * f * vec3(1.0);\n}\n\nvec3 prim_c(in vec3 p)\n{\n  \treturn vec3(0.8, 0.3, 0.3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 vPos = -1.0 + 2.0 * uv;\n\n   \tvec3 vuv=vec3(0,1,0); \n    vec3 vrp=vec3(0,-1,0);\n\n\tvec3 prp = vec3(0.0, 0.1, -3.0); \n    \n    vec3 vpn = normalize(vrp-prp);\n  \tvec3 u = normalize(cross(vuv,vpn));\n  \tvec3 v = cross(vpn,u);\n  \tvec3 vcv = (prp+vpn);\n  \tvec3 scrCoord = vcv+vPos.x*u*iResolution.x/iResolution.y+vPos.y*v;\n  \tvec3 scp = normalize(scrCoord-prp);\n    \n    vec3 lightPos = vec3(5.0, 2.5, -4.0);\n  \tvec3 fogColor = vec3(0.5,0.6,0.7);\n    vec3 lightColor = vec3(1.0);\n\n    const vec3 e = vec3(0.02,0,0);\n  \tconst float maxd = 100.0;\n  \tvec2 d = vec2(0.02,0.0);\n  \tvec3 c,p,N;\n    \n    float f = 1.0;\n    float stepDist = 0.9;\n    for(int i = 0; i < 256; i++)\n    {\n     \tif((abs(d.x) < .001) || (f > maxd))\n        \tbreak;\n        f += d.x;\n        p = prp + scp * f;\n        d = distance_to_obj(p);\n    }\n    \n    if (f < maxd)\n  \t{\n        if (d.y==0.0) {\n      \t\tc=floor_color(p);\n            N = vec3(0.0, 1.0, 0.0);\n        } else {\n      \t\tc=prim_c(p);\n    \t    N = vec3(d.x-distance_to_obj(p-e.xyy).x, d.x-distance_to_obj(p-e.yxy).x, d.x-distance_to_obj(p-e.yyx).x);\n        }\n        \n    \tN = normalize(N);\n        vec3 lightDir = normalize(lightPos - p);\n        float diff = max(dot(N, lightDir), 0.0);\n\t\tvec3 diffuse = diff * lightColor; \n        float vis = shadowSoft( p, normalize(lightPos-p), 0.0925, length(lightPos-p), 128.0);\n        float ambient = 0.15;\n        float ao = calcAO(p, N);\n        vec3 h = (lightDir - scp) / 2.0;\n\t\tfloat s = clamp(pow(dot(N, h), 30.) * 50.0, 0.0, 0.9);\n        diffuse += s;\n        \n        float fogAmount = 1.0 - exp(-sqrt(p.x * p.x + p.z * p.z) * 0.065 );\n    \tfragColor = vec4(mix(c * diffuse * (ao * 1.0) * (vis * 1.5 + 0.3) + ambient, fogColor, fogAmount), 1.0);\n  }\n  else \n    fragColor = vec4(fogColor,1);\n    \n}","name":"Image","description":"","type":"image"}]}