{"ver":"0.1","info":{"id":"dlcSRj","date":"1685811961","viewed":38,"name":"3d sphere, lighting ","username":"motschel","description":"Sphere with dynamically moving light","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","lighting","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\n#define NUM_SPHERES 1\nvec4[NUM_SPHERES] init_spheres() \n{\n    vec4 spheres[NUM_SPHERES] = vec4[NUM_SPHERES](\n        vec4(0.,0.,0., 4.)\n        //vec4(-4.,0.,0., 3.)\n    );\n    \n    return spheres;\n}\n\nvec4[NUM_SPHERES] SPHERES;\n\nvec3 LIGHT_POS;\n\nfloat distance_from_sphere(vec3 p, vec4 s)\n{\n  return distance(p, s.xyz) - s[3];\n}\n\nfloat map_the_world(in vec3 p)\n{\n    float shortest_dist = -1.;\n    \n    for(int i=0; i<SPHERES.length(); i++) \n    {\n        float curr_dist = distance_from_sphere(p, SPHERES[i]);\n        if(curr_dist < shortest_dist || shortest_dist == -1.)\n            shortest_dist = curr_dist;\n    }\n   \n    float displacement = sin(2.0 * p.x + iTime) * sin(2.0 * p.y + iTime) * sin(2.0 * p.z + iTime) * 0.25;    \n\n    return shortest_dist + displacement;\n}\n\nvec3 calculate_normal(vec3 p)\n{\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // tiny epsilon\n    \n    \n    return normalize(\n        e.xyy * map_the_world(p + e.xyy) +\n        e.yyx * map_the_world(p + e.yyx) +\n        e.yxy * map_the_world(p + e.yxy ) +\n        e.xxx * map_the_world(p + e.xxx));\n}\n\nvec3 calculate_sphere_color(vec3 curr_pos) \n{\n    //return vec3(1.0,0.,0.);\n    return vec3(\n        sin(curr_pos.x),\n        sin(curr_pos.y),\n        sin(curr_pos.z)\n    ) * 2.;\n}\n\n\nvec3 ray_march(vec3 ro, vec3 rd, float start, float end) \n{\n    float total_distance = start;\n    \n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 current_position = ro + total_distance * rd;\n        \n        float distance_to_closest = map_the_world(current_position);\n        if (distance_to_closest < PRECISION) \n        {\n            vec3 normal = calculate_normal(current_position);\n            vec3 direction_to_light = normalize(current_position - LIGHT_POS);\n\n            float diffuse_intensity = max(0.0, dot(normal, direction_to_light));\n\n            return calculate_sphere_color(current_position) * diffuse_intensity;\n        }\n        if (total_distance > end) break;\n        total_distance += distance_to_closest;\n      }\n      \n      return vec3(0.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // < -1, 1 >\n    vec2 uv = (2. * fragCoord - 1. * iResolution.xy) / iResolution.y;\n    vec2 U_MOUSE = (2. * iMouse.xy - 1. * iResolution.xy) / iResolution.y;\n\n    SPHERES = init_spheres();\n    LIGHT_POS = vec3(5.*sin(iTime),-5, 3.);\n\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0.,0.,10.);\n    //vec3 ro = 5. * vec3(sin(iTime),0.,cos(iTime));\n\n    vec3 rd = normalize(vec3(uv, -1));\n\n    float a = iTime;\n    mat3 rotY = mat3(\n    vec3(cos(a), 0., sin(a)),\n    vec3(0.,1.,0.),\n    vec3(sin(a), 0., cos(a))\n    );\n    \n    mat3 rotX = mat3(\n    vec3(cos(a), -sin(a), 0.),\n    vec3(sin(a), cos(a), 0.),\n    vec3(0.,0.,1.)\n    );\n    \n    mat3 rotZ = mat3(\n    vec3(1.,0.,0.),\n    vec3(0., cos(a), -sin(a)),\n    vec3(0., sin(a), cos(a))\n    );\n    \n    \n    \n    //ro *= rotZ;\n    //rd *= rotX;\n    //rd *= rotZ;\n    \n\n    \n    \n    \n\n    vec3 shaded_color = ray_march(ro, rd, MIN_DIST, MAX_DIST);\n    \n\n    // Output to screen\n    fragColor = vec4(shaded_color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}