{"ver":"0.1","info":{"id":"7dlcDN","date":"1642549706","viewed":190,"name":"Fork Rainforest DMeville 491","username":"DMeville","description":"Another terrain, with cheap trees made of ellipsoids and noise. It computes analytic normals for the terrain and clouds. The art composed to camera as usual.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["procedural","3d","raymarching","reprojection"],"hasliked":0,"parentid":"4ttSWf","parentname":"Rainforest"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright Inigo Quilez, 2016 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n// A rainforest landscape.\n//\n// Normals are analytical (true derivatives) for the terrain and for the\n// clouds, including the noise, the fbm and the smoothsteps.\n//\n// See here for more info: \n//  https://iquilezles.org/articles/fbm\n//  https://iquilezles.org/articles/morenoise\n//\n// Lighting and art composed for this shot/camera. The trees are really\n// cheap (ellipsoids with noise), but they kind of do the job in distance\n// and low image resolutions Also I used some cheap reprojection technique\n// to smooth out the render.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n\n    vec3 col = texture( iChannel0, p ).xyz;\n  //vec3 col = texelFetch( iChannel0, ivec2(fragCoord-0.5), 0 ).xyz;\n\n    col *= 0.5 + 0.5*pow( 16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y), 0.05 );\n         \n    fragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define LOWQUALITY\n#define LOWQUALITY_SHADOWS\n\n//==========================================================================================\n// general utilities\n//==========================================================================================\n#define ZERO (min(iFrame,0))\n\nfloat sdEllipsoidY( in vec3 p, in vec2 r )\n{\n    float k0 = length(p/r.xyx);\n    float k1 = length(p/(r.xyx*r.xyx));\n    return k0*(k0-1.0)/k1;\n}\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// return smoothstep and its derivative\nvec2 smoothstepd( float a, float b, float x)\n{\n\tif( x<a ) return vec2( 0.0, 0.0 );\n\tif( x>b ) return vec2( 1.0, 0.0 );\n    float ir = 1.0/(b-a);\n    x = (x-a)*ir;\n    return vec2( x*x*(3.0-2.0*x), 6.0*x*(1.0-x)*ir );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n//==========================================================================================\n// hashes (low quality, do NOT use in production)\n//==========================================================================================\n\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\nvec2 hash2( vec2 p ) \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    float n = 111.0*p.x + 113.0*p.y;\n    return fract(n*fract(k*n));\n}\n\n//==========================================================================================\n// noises\n//==========================================================================================\n\n// value noise, and its analytical derivatives\nvec4 noised( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    #if 1\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    #else\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    #endif\n\n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z), \n                      2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                                      k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                                      k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\n\n\n\n//==========================================================================================\n// fbm constructions\n//==========================================================================================\n\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\nconst mat3 m3i = mat3( 0.00, -0.80, -0.60,\n                       0.80,  0.36, -0.48,\n                       0.60, -0.48,  0.64 );\nconst mat2 m2 = mat2(  0.80,  0.60,\n                      -0.60,  0.80 );\nconst mat2 m2i = mat2( 0.80, -0.60,\n                       0.60,  0.80 );\n\n//------------------------------------------------------------------------------------------\n\n\nvec4 fbmd_8( in vec3 x ) //fbm derivative used as the cloud density volume\n{\n    float f = 2.0;\n    float s = 0.65;\n    float a = 0.0;\n    float b = 0.5;\n    vec3  d = vec3(0.0);\n    mat3  m = mat3(1.0,0.0,0.0,\n                   0.0,1.0,0.0,\n                   0.0,0.0,1.0);\n    for( int i=ZERO; i<8; i++ )\n    {\n        vec4 n = noised(x);\n        a += b*n.x;          // accumulate values\t\t\n        if( i<4 )\n        d += b*m*n.yzw;      // accumulate derivatives\n        b *= s;\n        x = f*m3*x;\n        m = f*m3i*m;\n    }\n\treturn vec4( a, d );\n}\n\n\n//==========================================================================================\n// specifics to the actual painting\n//==========================================================================================\n\n\n//------------------------------------------------------------------------------------------\n// global\n//------------------------------------------------------------------------------------------\n\nvec3  kSunDir = vec3(-0.624695,0.468521,-0.624695);\n\n\n\nvec3 fog( in vec3 col, float t )\n{\n    vec3 ext = exp2(-t*0.0005*vec3(1,1.5,4)); \n    return col*ext + (1.0-ext)*vec3(0.55,0.55,0.58); // 0.55\n}\n\n//------------------------------------------------------------------------------------------\n// clouds\n//------------------------------------------------------------------------------------------\nvec4 cloudsFbm( in vec3 pos )\n{\n    return fbmd_8(pos*0.003+vec3(2.0,2.0,1.0)+0.07*vec3(iTime,0.5*iTime,-0.15*iTime));\n}\n\n//wat dis\nvec4 cloudsMap( in vec3 pos, out float nnd )\n{\n    float d = abs(pos.y-150.0)-(sin(iTime)*50.0);\n    vec3 gra = vec3(0.0,sign(pos.y-150.0),0.0);\n    \n    vec4 n = cloudsFbm(pos);\n    d += 200.0*n.x * (0.7+0.3*gra.y);\n    \n    if( d>0.0 ) return vec4(-d,0.0,0.0,0.0);\n    \n    nnd = -d;\n    d = min(-d/50.0,0.25);\n    \n    //gra += 0.1*n.yzw *  (0.7+0.3*gra.y);\n    \n    return vec4( d, gra );\n}\n\nfloat cloudsShadowFlat( in vec3 ro, in vec3 rd )\n{\n    float t = (150.0-ro.y)/rd.y;\n    if( t<0.0 ) return 1.0;\n    vec3 pos = ro + rd*t;\n    vec4 n = cloudsFbm(pos);\n    return 200.0*n.x-20.0;\n}\n\n#ifndef LOWQUALITY_SHADOWS\nfloat cloudsShadow( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n\tfloat sum = 0.0;\n\n    // bounding volume!!\n    float tl = (  50.0-ro.y)/rd.y;\n    float th = ( 300.0-ro.y)/rd.y;\n    if( tl>0.0 ) { if(ro.y>50.0) tmin = min( tmin, tl ); else tmin = max( tmin, tl ); }\n    if( th>0.0 ) tmax = min( tmax, th );\n\n    // raymarch\n\tfloat t = tmin;\n\tfor(int i=ZERO; i<128; i++)\n    { \n        vec3  pos = ro + t*rd; \n        float kk;\n        vec4  denGra = cloudsMap( pos, kk ); \n        float den = denGra.x;\n        float dt = max(1.0,0.05*t);\n        if( den>0.01 ) \n        { \n            float alp = clamp(den*0.1*dt,0.0,1.0);\n            sum = sum + alp*(1.0-sum);\n        }\n        else \n        {\n            dt = -den+0.1;\n        }\n        t += dt;\n        if( sum>0.995 || t>tmax ) break;\n    }\n\n    return clamp( 1.0-sum, 0.0, 1.0 );\n}\n#endif\n\n\n//actual function that marches the clouds\nvec4 renderClouds( in vec3 ro, in vec3 rd, float tmin, float tmax, inout float resT, in vec2 px )\n{\n    vec4 sum = vec4(0.0);\n\n    // bounding volume!!\n    float tl = (   0.0-ro.y)/rd.y;\n    float th = ( 300.0-ro.y)/rd.y;\n    if( tl>0.0 ) tmin = max( tmin, tl ); else return sum;\n    if( th>0.0 ) tmax = min( tmax, th );\n\n    float t = tmin;\n    //t += 1.0*hash1(gl_FragCoord.xy);\n    float lastT = -1.0;\n    float thickness = 0.0;\n    kSunDir = normalize(vec3(0, sin(iTime), -1));\n    \n    #ifdef LOWQUALITY_SHADOWS\n    for(int i=ZERO; i<128; i++)\n    { \n        vec3  pos = ro + t*rd; \n        float nnd;\n        vec4  denGra = cloudsMap( pos, nnd ); \n        float den = denGra.x;\n        float dt = max(0.1,0.011*t);\n        //dt *= hash1(px+float(i));\n        if( den>0.001 ) \n        { \n            float kk;\n            cloudsMap( pos+kSunDir*35.0, kk );\n            float sha = 1.0-smoothstep(-100.0,100.0,kk); sha *= 1.5;\n            \n            vec3 nor = normalize(denGra.yzw);\n            float dif = clamp( 0.4+0.6*dot(nor,kSunDir), 0.0, 1.0 )*sha; \n            float fre = clamp( 1.0+dot(nor,rd), 0.0, 1.0 )*sha;\n            float occ = 0.2+0.7*max(1.0-kk/100.0,0.0) + 0.1*(1.0-den);\n            // lighting\n            vec3 lin  = vec3(0.0);\n                 lin += vec3(0.70,0.80,1.00)*1.0*(0.5+0.5*nor.y)*occ;\n                 lin += vec3(0.10,0.40,0.20)*1.0*(0.5-0.5*nor.y)*occ;\n                 lin += vec3(1.00,0.95,0.85)*3.0*dif*occ + 0.1;\n\n            // color\n            vec3 col = vec3(0.8,0.8,0.8)*0.45;\n\n            col *= lin;\n\n            col = fog( col, t );\n\n            // front to back blending    \n            float alp = clamp(den*0.5*0.25*dt,0.0,1.0);\n            col.rgb *= alp;\n            sum = sum + vec4(col,alp)*(1.0-sum.a);\n\n            thickness += dt*den;\n            if( lastT<0.0 ) lastT = t;            \n        }\n        else \n        {\n            dt = abs(den)+0.1;\n\n        }\n        t += dt;\n        if( sum.a>0.995 || t>tmax ) break;\n    }\n    #else\n    for(int i=ZERO; i<128; i++)\n    { \n        vec3  pos = ro + t*rd; \n        float  kk;\n        vec4  denGra = cloudsMap( pos, kk ); \n        float den = denGra.x;\n        float dt = max(0.1,0.011*t);\n        if( den>0.001 ) \n        { \n            float sha = cloudsShadow( pos, kSunDir, 0.0, 150.0 );\n            vec3 nor = normalize(denGra.yzw);\n            float dif = clamp( 0.5+0.5*dot(nor,kSunDir), 0.0, 1.0 )*sha; \n            float fre = clamp( 1.0+dot(nor,rd), 0.0, 1.0 )*sha;\n            // lighting\n            vec3 lin  = vec3(0.0);\n                 lin += vec3(0.70,0.80,1.00)*1.0*(0.5+0.5*nor.y)*(1.0-den);\n                 lin += vec3(0.20,0.30,0.20)*1.0*(0.5-0.5*nor.y)*(1.0-den);\n                 lin += vec3(1.00,0.75,0.50)*2.0*dif;\n            \t lin += vec3(0.80,0.70,0.50)*11.3*pow(fre,32.0)*(1.0-den);\n                 lin += sha*0.4*(1.0-den);\n                 lin = max(lin,0.0);\n            // color\n            vec3 col = vec3(0.8,0.8,0.8)*0.6;\n\n            col *= lin;\n            \n            col = fog( col, t );\n\n            float alp = clamp(den*0.5*0.25*dt,0.0,1.0);\n            col.rgb *= alp;\n            sum = sum + vec4(col,alp)*(1.0-sum.a);\n\n            thickness += dt*den;\n            if( lastT<0.0 ) lastT = t;           \n        }\n        else \n        {\n            dt = abs(den)+0.1;\n\n        }\n        t += dt;\n        if( sum.a>0.995 || t>tmax ) break;\n    }\n    #endif\n    \n    //resT = min(resT, (150.0-ro.y)/rd.y );\n    if( lastT>0.0 ) resT = min(resT,lastT);\n    //if( lastT>0.0 ) resT = mix( resT, lastT, sum.w );\n    \n    \n    sum.xyz += max(0.0,1.0-0.025*thickness)*vec3(1.00,0.60,0.40)*0.3*pow(clamp(dot(kSunDir,rd),0.0,1.0),32.0);\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\n\n\n//------------------------------------------------------------------------------------------\n// sky\n//------------------------------------------------------------------------------------------\n\nvec3 renderSky( in vec3 ro, in vec3 rd )\n{\n    // background sky     \n    vec3 col = vec3(0.42,0.62,1.1) - rd.y*0.4;\n\n\t// sun glare    \n    float sun = clamp( dot(kSunDir,rd), 0.0, 1.0 );\n    col += 0.2*vec3(1.0,0.6,0.3)*pow( sun, 32.0 );\n\treturn col;\n}\n\n//------------------------------------------------------------------------------------------\n// main image making function\n//------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o = hash2( vec2(iFrame,1) ) - 0.5;\n    \n    vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/ iResolution.y;\n    \n    //----------------------------------\n    // setup\n    //----------------------------------\n\n    // camera\n    float time = iTime;\n    vec3 ro = vec3(0.0, -99.25, 3.0);\n    vec3 ta = vec3(0.0, -98.25, -45.0 + ro.z );\n    \n    //ro += vec3(10.0*sin(0.02*time),0.0,-10.0*sin(0.2+0.031*time))\n    \n    ro.x -= 40.0*sin(0.01*time);\n    ta.x -= 43.0*sin(0.01*time);\n\n    // ray\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = ca * normalize( vec3(p,1.50));\n\n\tfloat resT = 5000.0;\n\n    //----------------------------------\n    // sky\n    //----------------------------------\n\n    vec3 col = renderSky( ro, rd );\n    float isCloud = 0.0;\n    //----------------------------------\n    // clouds\n    //----------------------------------\n    {\n        vec4 res = renderClouds( ro, rd, 0.0, resT, resT, fragCoord );\n        col = col*(1.0-res.w) + res.xyz;\n        isCloud = res.w;\n    }\n\n\n    // gamma\n    //col = sqrt( clamp(col,0.0,1.0) );\n    col = pow( clamp(col*1.1-0.02,0.0,1.0), vec3(0.4545) );\n\n       \n    \n   \n    /*\n    //------------------------------------------\n\t// reproject from previous frame and average\n    //------------------------------------------\n\n    mat4 oldCam = mat4( textureLod(iChannel0,vec2(0.5,0.5)/iResolution.xy, 0.0),\n                        textureLod(iChannel0,vec2(1.5,0.5)/iResolution.xy, 0.0),\n                        textureLod(iChannel0,vec2(2.5,0.5)/iResolution.xy, 0.0),\n                        0.0, 0.0, 0.0, 1.0 );\n    \n    // world space\n    vec4 wpos = vec4(ro + rd*resT,1.0);\n    // camera space\n    vec3 cpos = (wpos*oldCam).xyz; // note inverse multiply\n    // ndc space\n    vec2 npos = 1.5 * cpos.xy / cpos.z;\n    // screen space\n    vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y/iResolution.x,1.0);\n    // undo dither\n    spos -= o/iResolution.xy;\n\t// raster space\n    vec2 rpos = spos * iResolution.xy;\n    \n    if( rpos.y<1.0 && rpos.x<3.0 )\n    {\n    }\n\telse\n    {\n        vec3 ocol = textureLod( iChannel0, spos, 0.0 ).xyz;\n    \tif( iFrame==0 ) ocol = col;\n        col = mix( ocol, col, 0.1+0.8*isCloud );\n    }\n\n    //----------------------------------\n    */\n                           \n\tif( fragCoord.y<1.0 && fragCoord.x<3.0 )\n    {\n        if( abs(fragCoord.x-2.5)<0.5 ) fragColor = vec4( ca[2], -dot(ca[2],ro) );\n        if( abs(fragCoord.x-1.5)<0.5 ) fragColor = vec4( ca[1], -dot(ca[1],ro) );\n        if( abs(fragCoord.x-0.5)<0.5 ) fragColor = vec4( ca[0], -dot(ca[0],ro) );\n    }\n    else\n    {\n        fragColor = vec4( col, 1.0 );\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}