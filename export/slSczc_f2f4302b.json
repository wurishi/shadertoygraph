{"ver":"0.1","info":{"id":"slSczc","date":"1650016020","viewed":68,"name":"Let there be light ?","username":"nonologism","description":"Your mouse is a light source. Some shapes are moving around. Can you guess what is displayed ?","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["clock"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 uv;   // Normalized pixel coordinates (from 0 to 1)\nvec4 col;  // Result \nfloat eps = 0.5; \n#define POLY_SIZE 5\n#define POLYS 7\n#define showsolution 0 // Set to 1 to show solution\n\n\nfloat corss2d(vec2 v0, vec2 v1) {\n    return v0.x * v1.y - v0.y - v1.x;\n}\n\nbool onLine(vec2 a1, vec2 a2, vec2 p) {   //check whether p is on the line or not\n   return (p.x <= max(a1.x, a2.x) && p.x <= min(a1.x, a2.x) && (p.y <= max(a1.y, a2.y) && p.y <= min(a1.y, a2.y)));\n}\n\nfloat direction(vec2 a, vec2 b, vec2 c) {\n   float val = (b.y-a.y)*(c.x-b.x)-(b.x-a.x)*(c.y-b.y);\n   if (val == 0.0)\n      return 0.0;     //colinear\n   else if(val < 0.0)\n      return 2.0;    //anti-clockwise direction\n   return 1.0;    //clockwise direction\n}\n\n\nbool isIntersect(vec2 l1a, vec2 l1b, vec2 l2a,  vec2 l2b) {\n   //four direction for two lines and points of other line\n   float dir1 = direction(l1a, l1b, l2a);\n   float dir2 = direction(l1a, l1b, l2b);\n   float dir3 = direction(l2a, l2b, l1a);\n   float dir4 = direction(l2a, l2b, l1b);\n   \n   if(dir1 != dir2 && dir3 != dir4)\n      return true; //they are intersecting\n\n   if(dir1 == 0.0 && onLine(l1a, l1b, l2a)) //when p2 of line2 are on the line1\n      return true;\n\n   if(dir2 == 0.0 && onLine(l1a, l1b, l2b)) //when p1 of line2 are on the line1\n      return true;\n\n   if(dir3 == 0.0 && onLine(l2a, l2b, l1a)) //when p2 of line1 are on the line2\n      return true;\n\n   if(dir4 == 0.0 && onLine(l2a, l2b, l1b)) //when p1 of line1 are on the line2\n      return true;\n         \n   return false;\n}\n\n//=========== \n//main rasterizer commands\nvoid LINE (vec2 start, vec2 end, vec4 rgba)\n{\n    vec2 uv_start = uv-start, end_start = end-start;\n    float h = clamp( dot(uv_start,end_start)/dot(end_start, end_start), 0.0, 1.0 );\n    float l = length (uv_start - end_start*h);\n\n    if (l < eps)\n        col = rgba;\n}\n\nvoid OUTLINE_POLYGONS (vec2[POLY_SIZE * POLYS] points, vec4 rgba)\n{\n    for (int i = 0; i < (POLYS * POLY_SIZE) - 1; i ++) {\n        if(((i + 1) % POLY_SIZE) == 0) {\n            i++;\n        }\n        LINE(points[i], points[i+1], rgba);\n    }\n}\n\nvoid FILL_CIRCLE (vec2 xy, int r, vec4 rgba)\n{\n    if (distance(uv, xy) < float(r)) {\n        col = rgba;\n    }\n}\n\nvoid LIGHT(float r, vec2[POLYS * POLY_SIZE] poly) {\n    vec2 mousePos = iMouse.xy;\n    float dist = distance(mousePos, uv);\n    float intensity = max(r - dist, 0.0) / r;\n    \n\n    if (dist < r) {\n        bool obstructed = false;\n        for (int i = 0; i < (POLYS * POLY_SIZE) - 1; i ++) {\n            if(((i + 1) % POLY_SIZE) == 0) {\n                i++;\n            }\n            if(isIntersect(uv, mousePos, poly[i], poly[i + 1])) {\n                obstructed = true;\n                break;\n            }\n        }\n        if (!obstructed) {\n            col = vec4(intensity, intensity, intensity, 1);\n        }\n    }\n}\n\nvec2 rotate(vec2 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    return m * v;\n}\n\n//=========== \n//only these function calls allowed inside draw: \n//POINT\n//LINE \n//OUTLINE_CIRCLE, FILL_CIRCLE\n//OUTLINE_POLYGON, FILL_POLYGON\n\n\nvoid draw ()\n{\n    vec2 A = vec2(-5.0, 0.0);\n    vec2 B = vec2(-5.0, 150.0);\n    vec2 C = vec2(5.0, 150.0);\n    vec2 D = vec2(5.0, 0.0);\n    \n    vec2 radius = vec2(0, 30);\n    \n    vec2 offset = vec2(20.0, 20.0);\n     \n    vec2 center = vec2(400, 225);\n    \n    float pi = 3.14159;\n    float seca = float(int(iDate.w) % 60) * pi / 30.0;\n    float mina = float(int(iDate.w) % 3600) * pi / 1800.0;\n    float ha = (iDate.w * pi) / (3600.0 * 12.0);\n    \n    vec2 vertices[POLYS * POLY_SIZE] = vec2[POLYS * POLY_SIZE]\n    (\n        vec2(400, 405),\n        vec2(390, 425), \n        vec2(410, 425),\n        vec2(400, 405), \n        vec2(410, 425),\n        \n        vec2(580, 225),\n        vec2(600, 235), \n        vec2(600, 215),\n        vec2(580, 225), \n        vec2(600, 235),\n        \n        vec2(400, 45),\n        vec2(390, 25), \n        vec2(410, 25),\n        vec2(400, 45), \n        vec2(390, 25),\n        \n        vec2(220, 225),\n        vec2(200, 215), \n        vec2(200, 235),\n        vec2(220, 225), \n        vec2(200, 215),\n        \n        rotate(A + radius, seca) + center,\n        rotate(B + radius, seca) + center, \n        rotate(C + radius, seca) + center,\n        rotate(D + radius, seca) + center, \n        rotate(A + radius, seca) + center,\n        \n        rotate(A + radius, mina) + center,\n        rotate(B + radius, mina) + center, \n        rotate(C + radius, mina) + center,\n        rotate(D + radius, mina) + center, \n        rotate(A + radius, mina) + center,\n        \n        rotate(A + radius, ha) + center,\n        rotate(B + radius, ha) + center, \n        rotate(C + radius, ha) + center,\n        rotate(D + radius, ha) + center, \n        rotate(A + radius, ha) + center\n    );\n    LIGHT(700.0, vertices);\n    if(showsolution == 1) {\n        OUTLINE_POLYGONS(vertices, vec4(1.0, 1.0, 0.0, 1.0));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = fragCoord; \n    col = vec4(0.0);\n    \n    draw();\n    \n    fragColor = col;\n}\n","name":"Image","description":"","type":"image"}]}