{"ver":"0.1","info":{"id":"ldXBWs","date":"1498761476","viewed":192,"name":"Prueba perlin seamless","username":"ps","description":"Intento de perlin seamless, Basado en https://www.shadertoy.com/view/4lB3zz, prueba para p2 RA","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["perlinseamless"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int firstOctave = 3;\nconst int octaves = 8;\nconst float persistence = 0.6;\n\n//Not able to use bit operator like <<, so use alternative noise function from YoYo\n//\n//https://www.shadertoy.com/view/Mls3RS\n//\n//And it is a better realization I think\nfloat noise(int x,int y)\n{   \n    float fx = float(x);\n    float fy = float(y);\n    \n    return 2.0 * fract(sin(dot(vec2(fx, fy) ,vec2(12.9898,78.233))) * 43758.5453) - 1.0;\n}\n\nfloat smoothNoise(int x,int y)\n{\n    return noise(x,y)/4.0+(noise(x+1,y)+noise(x-1,y)+noise(x,y+1)+noise(x,y-1))/8.0+(noise(x+1,y+1)+noise(x+1,y-1)+noise(x-1,y+1)+noise(x-1,y-1))/16.0;\n}\n\nfloat COSInterpolation(float x,float y,float n)\n{\n    float r = n*3.1415926;\n    float f = (1.0-cos(r))*0.5;\n    return x*(1.0-f)+y*f;\n    \n}\n\nfloat InterpolationNoise(float x, float y)\n{\n    int ix = int(x);\n    int iy = int(y);\n    float fracx = x-float(int(x));\n    float fracy = y-float(int(y));\n    \n    float v1 = smoothNoise(ix,iy);\n    float v2 = smoothNoise(ix+1,iy);\n    float v3 = smoothNoise(ix,iy+1);\n    float v4 = smoothNoise(ix+1,iy+1);\n    \n   \tfloat i1 = COSInterpolation(v1,v2,fracx);\n    float i2 = COSInterpolation(v3,v4,fracx);\n    \n    return COSInterpolation(i1,i2,fracy);\n    \n}\n\nfloat PerlinNoise2D(float x,float y)\n{\n    float sum = 0.0;\n    float frequency =0.0;\n    float amplitude = 0.0;\n    for(int i=firstOctave;i<octaves + firstOctave;i++)\n    {\n        frequency = pow(2.0,float(i));\n        amplitude = pow(persistence,float(i));\n        sum = sum + InterpolationNoise(x*frequency,y*frequency)*amplitude;\n    }\n    \n    return sum;\n}\n\nfloat F_tile(float x, float y, float w, float h) {\nreturn (PerlinNoise2D(x, y) * (w - x) * (h - y) +\nPerlinNoise2D(x - w, y) * (x) * (h - y) +\nPerlinNoise2D(x - w, y - h) * (x) * (y) +\nPerlinNoise2D(x, y - h) * (w - x) * (y)\n) / (w * h);\n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float x = uv.x;\n    float y = uv.y;\n\t//fragColor = vec4(noise(x,y),noise(x,y),noise(x,y),1);\n    float noise = 0.3+0.7*PerlinNoise2D(x,y);\n    fragColor = vec4(noise,noise,noise,1.0);\n    float bufferwidth=iResolution.x;\n    float bufferheight=iResolution.y;\n    \n    \tfloat s=x/bufferwidth;\n\t\tfloat t=y/bufferheight;\n    \n     \tfloat  dx=x*2.0-x;\n        float  dy=y*2.0-y;\n            \n\t\tfloat pi=3.14;\n\t\t//float nx=cos(s*2.0*pi);\n\t\t//float ny=sin(t*2.0*pi);\n      \n    \n  /*  local s=x/bufferwidth\n        local t=y/bufferheight\n        local dx=x2-x1\n        local dy=y2-y1*/\n\n        float nx=x+cos(s*2.0*pi)*dx/(2.0*pi);\n        float ny=y+cos(t*2.0*pi)*dy/(2.0*pi);\n     //   local nz=x1+sin(s*2*pi)*dx/(2*pi)\n       // local nw=y1+sin(t*2*pi)*dy/(2*pi)\n\tnoise = 0.3+0.7*PerlinNoise2D(nx,ny);\n\t\tfragColor = vec4(noise,noise,noise,1.0);\n       // buffer:set(x,y,Noise4D(nx,ny,nz,nw))\n   \t\t \n\t\t//buffer:set(x,y,F_tile(nx,ny,x2-x1,y2-y1))\n}","name":"Image","description":"","type":"image"}]}