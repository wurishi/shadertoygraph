{"ver":"0.1","info":{"id":"Xl3XzM","date":"1507282148","viewed":356,"name":"7.600.000.000 is lot","username":"iapafoto","description":"Take 1 legoman by living human being. Put them on top of each other (5cm each), and you can almost reach the moon ... with true humans you are approaching Venus\n\nSorry for the huggly code, I get very few time... one day I will arrange it","likes":14,"published":1,"flags":96,"usePreview":0,"tags":["speed","human","legomans"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MsXXDl","filepath":"https://soundcloud.com/hugo-carrard/instru-2-27-07-16-20-15","previewfilepath":"https://soundcloud.com/hugo-carrard/instru-2-27-07-16-20-15","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Created by sebastien durand - 01/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// ---------------------------------------\n// Just to illustrate a strange reflexion\n// Take 1 legoman by living human being. \n// Put them on top of each other (5cm each), and you can almost reach the Moon! \n// With the true humans you are approaching Venus\n\n\n// ---------------------------------------\n// Text : FabriceNeyret2: https://www.shadertoy.com/view/llySRh\n// ---------------------------------------\n// Atmosphere : dmytro rubalskyi (ruba) : https://www.shadertoy.com/view/XlXGzB\n// ---------------------------------------\n// For V2 not implement yet but need to\n// Speed directionnal blur technic : inigo quilez : Volcanic : https://www.shadertoy.com/view/XsX3RB\n// ---------------------------------------\n\n\n\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n#define HASHSCALE1 .1031\n\nfloat hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n\n// ---------------------------------------\n// FabriceNeyret2: https://www.shadertoy.com/view/llySRh\n// ---------------------------------------\n\n // --- access to the image of ascii code c\nvec4 char(vec2 p, int c) {\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n    //if (p.x<.25|| p.x>.75 || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5); // strange bug\n\treturn textureGrad( iChannel3, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                        dFdx(p/16.),dFdy(p/16.) );\n  //float l = log2(length(fwidth(p/16.*iResolution.xy)));\n  //return textureLod( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), l);\n                   // manual MIPmap to avoid border artifact. Should be textureLod, but don't available everywhere\n}\n\n\n// --- display int4\nvec4 pInt(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(p - vec2(-.5,0), 45 ),\n        n = -n;\n\n    for (float i = 3.; i>=0.; i--) \n        n /=  9.999999, // 10., // for windows :-(\n        v += char(p - .5*vec2(i,0), 48+ int(fract(n)*10.) );\n    return v;\n}\n\n// --- chars\nint CAPS=0;\n#define low CAPS=32\n#define caps CAPS=0\n#define C(c) U.x-=.5; O+= char(U,64+CAPS+c)\n\n\nfloat t1 = 20., t2 = 40., t3 = 50.;\n\n\nvec3 camPos(float t) {\n    if (t < t1) {\n        float a = -1.-t*mix(.0, 3.5, smoothstep(0.6,8.,t));\n        float k = smoothstep(0.5,5.,t*.1);\n        return vec3((25.+k*100.)*cos(a), 100.*k*t, (25.+k*100.)*sin(a));\n    } else if (t < t2) {\n    \tt = t-t1;\n\t    return vec3(35.*cos(-.5*t), t*100., 15.*sin(-.5*t));\n    } else if (t<t3) { \n    \treturn vec3(2.*cos(2.*t)+5.*cos(-.5*t), t*1000., 5.*sin(-.5*t));\n    } \n    return vec3(3.*cos(2.1231*t)+5.*cos(-.5*t), t*100., 5.*sin(-.5*t));\n}\n\n\nvec3 camPosEarth(float t) {\n    if (t < t1) {\n        float a = -1.-t*mix(.0, 3.5, smoothstep(0.6,8.,t));\n        return vec3(.1*cos(a), .1+smoothstep(0.5,5.,t*.1)*t, .1*sin(a));\n    } else if (t < t2) {\n    \tt = t-t1;\n\t    return vec3(5.*cos(-.5*t), t, 5.*sin(-.5*t));\n    } else if (t < t3) {\n        t -= t2;\n\t    return vec3(5.*cos(-.5*t), 90000.+t*t*500., 5.*sin(-.5*t));\n    } else {\n    \treturn vec3(5.*cos(-.5*t), t*100., 5.*sin(-.5*t));\n    }\n}\n\n\nfloat getAlti(float t) {\n    if (t < t1) return camPos(t).y/4.;  // cm\n    if (t < t2) return camPosEarth(t).y*10.;\n    if (t < t3) return camPosEarth(t).y;\n\treturn 3e5 + camPosEarth(t).y;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col1 = texture( iChannel1, uv ),\n\t\t col2 = texture( iChannel0, uv );\n    \n    vec3 col = vec3(0.0);\n    if(1==1)// col1.w < 0.0 )\n    {\n    \tcol = col2.xyz*col2.w + col1.xyz*(1.-col2.w);\n    }\n    else\n    {\n        // decompress velocity vector\n        float ss = mod(col1.w,256.0)/255.0;\n        float st = floor(col1.w/256.0)/255.0;\n\n        // motion blur (linear blur across velocity vectors\n        vec2 dir = (-1.0 + 2.0*vec2( ss, st ))*0.25;\n        col1 = vec4(0.);\n        for( int i=0; i<32; i++ )\n        {\n            float h = float(i)/31.0;\n            vec2 pos = uv + dir*h;\n            col1.xyz += texture( iChannel1, pos ).xyz;\n        }\n        col1 /= 32.0;\n        col1.w = 1.;\n    }\n    col = col1.w > 0. ? col1.xyz : col2.xyz;\n\n    // vignetting\t\n//\tcol *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n\n    fragColor = vec4(col,1.);\n    \n    \n    vec2 U = ( fragCoord / iResolution.y - vec2(-.15,.8) ) * 8.;        // --- column 1\n    vec2 U2 = ( fragCoord / iResolution.y - vec2(.1,.8) ) * 8.;        // --- column 1\n    vec2 U3 = ( fragCoord / iResolution.y - vec2(.35,.8) ) * 8.;        // --- column 1\n\n    \n    float alti, time, t0 = (iResolution.x < 400.) ? iTime-10.: iTime;\n    for (int i=0;i<16;i++) {\n        time = t0+.1*(.5+.5*hash31(iTime+fragCoord.xyx*float(i)));\n        alti = getAlti(time);\n        \n        if (iTime<t1) {\n            fragColor += .05*pInt(U,0.).x;\n            fragColor += .05*pInt(U2,0.).x;\n            fragColor += .05*pInt(U3,alti+1.).x;\n        } else if (iTime>t1) {\n            fragColor += .05*pInt(U,alti/10000.).x;\n            fragColor += .05*pInt(U2,alti).x;\n            fragColor += .05*pInt(U3,alti*1000.).x;\n    \t}\n    }\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n// Created by sebastien durand - 01/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// ---------------------------------------\n// Just to illustrate a strange reflexion\n// Take 1 legoman by living human being. \n// Put them on top of each other (5cm each), and you can almost reach the Moon! \n// With the true humans you are approaching Venus\n\n\n// ---------------------------------------\n// Text : FabriceNeyret2: https://www.shadertoy.com/view/llySRh\n// ---------------------------------------\n// Atmosphere : dmytro rubalskyi (ruba) : https://www.shadertoy.com/view/XlXGzB\n// ---------------------------------------\n\n\n//#define ANTIALIASING\n\n#define AA 1\n#define TAO 6.28318530718\n#define NB_ITER 48\n#define MAX_DIST 5000.\n#define PRECISION .015\n\n\n// - LegoMan Constants & Globals ------------------------------------------\n\n#define HEAD 1.\n#define SHIRT 2.\n#define MIDDLE 3.\n#define LEGS 4.\n#define ARMS 5.\n#define HAND 6.\n\nconst lowp float \n\tlegh = 1., \n\tlege=.34, \n\tlegx=.31;\n\n\n\n   vec3 sunDir = normalize(vec3(1.0, .9, -1.0));\n\n// -- Tools -----------------------------------------------------------\n\nfloat smin(in float a, in float b, in float k ) {\n    float h = clamp( .5+.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.-h);\n}\n\nvec2 minObj(in vec2 o1, in vec2 o2) {\n    return (o1.x<o2.x) ? o1 : o2;\n}\n\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\nmat2 Rot(in float a) {\n\tfloat sa=sin(a), ca=cos(a);\n\treturn mat2(ca, -sa, sa, ca);\n}\n\n\n\n\nbool box(vec3 ro, vec3 rd, vec3 sz, out float tn, out float tf) {\n\tvec3 m = 1./rd,\n         k = abs(m)*sz,\n         a = -m*ro-k*.5, \n         b = a+k;\n    tn = max(max(a.x,a.y),a.z);\n    tf = min(min(b.x,b.y),b.z);\n\treturn tn>0. && tn<tf;\n}\n\n// -------------------------------------------------------------------\n\n\nvec3 armn = normalize(vec3(-.4,-1.,-.5) - vec3(-.25,-.5,0));\nvec2 boby2 = normalize(vec2(1,.15));\nmat2 handmat;\n\n\n// -- Legoman position and color -------------------------------------\n\nstruct Legoman {\n\tfloat \n\t\thead,\n\t\tarm_left, arm_right,\n\t\tleg_left, leg_right,\n\t\thand_left, hand_right,\n\t\tyaw, pitch,roll;\n\tvec3 pos;\n\tvec3 c_shirt, c_arms, c_middle, c_legs;\n};\n\nLegoman man = Legoman(-.2, \n\t\t\t\t\t  2.,-.4,.6,-.5, 0.,0.,\n\t\t\t\t\t  0.,0.,0.,\n\t\t\t\t\t  vec3(0,-.77,0),\n\t\t\t\t\t  vec3(1,0,0), vec3(1), vec3(.1,.1,.3), vec3(.1,.1,.4));\n\n\n// -- Renderer Constants & Globals -------------------------------------\n\nconst vec2 \n\tV01 = vec2(0,1),\n\tVe = vec2(.001,0);\n\nfloat time;\nvec3 sunLight;\nvec2 fCoord;\n\n\n// -- Distance functions -----------------------------------------------\n\nfloat sdCapsule(in vec3 p, in vec3 a, in vec3 b, in float r0, in float r1 ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1.);\n    return length( pa - ba*h ) - mix(r0,r1,h);\n}\n\nfloat roundCylinder(in vec3 p, in float h, in float r1, in float r2) {\n    float a = abs(p.y)-(h-r2), b = length(p.xz)-r1;\n    return min(min(max(a, b), max(a-r2, b+r2)), length(vec2(b+r2,a))-r2);\n}\n\nfloat head(in vec3 p) {\n    float d = max(abs(p.y+.4)-.3, length(p.xz)-.326);\n    d = min(d, roundCylinder(p, .425,.51,.1));\n    p.y -= .425;\n    return min(d, roundCylinder(p, .173, .245,.025));\n}\n\nfloat body(in vec3 p) {\n    vec3 vd = abs(p) -  vec3(.75,.6,1.);\n    float d = min(max(vd.x,max(vd.y,vd.z)),0.0) + length(max(vd,0.0));\n    p.x = abs(p.x);\n    d = max(dot(p.xy, boby2)-.7,d);\n    p.y -= .4;    \n    d = min(d, length(max(abs(p)- vec3(.47,.14,.45),0.0))-.16);\n    return max(abs(p.z)-.392, d);\n}\n\nfloat leg(in vec3 p) {\n    float d = length(p.zy)-lege;\n    d = min(d, length(max(abs(p+vec3(0.,legh*.5,-.08))-vec3(legx,legh*.5,lege-.08),0.)));\n    d = min(d, length(max(abs(p+vec3(0.,legh,.02))-vec3(legx,.15,lege+.02),0.)));\n    d = max(abs(p.x)-legx, d)-.02;\n    vec3 dd = abs(p+vec3(0.,legh,-.08))-vec3(legx-.1,legh+.2,lege-.18);\n    float d2 = min(max(dd.x,max(dd.y,dd.z)),0.) + length(max(dd,0.));\n    dd = abs(p+vec3(0.,legh+.1,.02))-vec3(legx-.1,.15,lege-.98);\n    d2 = min(d2, min(max(dd.x,max(dd.y,dd.z)),0.0) + length(max(dd,0.)));\n    d2 = min(d2, max(-p.z-.05, length(p.xy-vec2(0,-.1))-.24));\n    d2 = min(d2, max(-p.z-.05, length(p.xy-vec2(0,-.8))-.24));\n    return max(-d2,d);\n}\n\nfloat arm(in vec3 p) {\n    float d = smin(sdCapsule(p, vec3(0), vec3(-.25,-.5,0), .22, .23), \n\t\t\t\t   sdCapsule(p, vec3(-.25,-.5,0), vec3(-.4,-1.,-.5), .23, .24),.02); \n    return max(dot(p, armn) - .9, d);\n}\n\nfloat hand(in vec3 p) {\n    float d1 = length(p)-.15;\n\tp.y+=.29;\n    float d=length(p.xy);\n    return max(abs(p.z+.09)-.2, max(-length(p.xy+vec2(-.1,.25))+.2, max(-d+.18, smin(d1, d-.26,.02))));\n}\n\nvec2 legoman(in vec3 p, in Legoman lego, vec4 txt) {\n\tfloat sa,ca, a;\n\tbool isLeft = p.x>0.;\n\t\n\t// - Head & Shirt --------------------\n\tvec2 dHead = vec2(head(p+vec3(0,-1.4,0)), HEAD),\n    \t dBody = vec2(body(p+vec3(0,-.15,0)), SHIRT);\n   \n\t// - Middle --------------------------\n    float middle = length(max(abs(p+vec3(0,.44,0))- vec3(.65,.1,.325),0.0))-.05;\n    middle = min(middle,roundCylinder(p.yxz+vec3(.76,0,0),.06,.39,.02));\n    vec2 dMiddle = vec2(middle,MIDDLE);   \n\t\n\t// - Legs ----------------------------\n    p.x = -abs(p.x);       \n\tvec3 p1 = p;\n\tp1.y +=.77;\n\t//R(p1.yz,isLeft?-lego.leg_left:-lego.leg_right);\n\tp1.x += .38;\n\tvec2 dLeg = vec2(leg(p1), LEGS);\n\n\t// - Arms ----------------------------\n    p += vec3(.7,-.55,0); \n    float ang1 = -fract(txt.x*4.);\n    float ang2 = -fract(txt.y*4.);\n    \n\tR(p.yz,isLeft?-ang1:-ang2);\n    vec2 dArm = vec2(arm(p), ARMS);\n\t\n\t// - Hands ---------------------------\n\tp += vec3(.35,.85,.35);\n\tp.yz *= handmat;\n\t//R(p.xz,isLeft?-lego.hand_left:-lego.hand_right);\n    vec2 dHand = vec2(hand(p), HAND);\n\n\t// - Mix -----------------------------\n    return minObj(minObj(minObj(minObj(minObj(dHead, dBody),dHand),dArm),dMiddle),dLeg);\n\t//res = minObj(res, vec2(length(boundingSphere.xyz) - boundingSphere.w, 3.));\n//\treturn  vec2(length(boundingSphere.xyz) - boundingSphere.w, 3.);\n}\n\n\n// -- Legoman colors ----------------------------------------- \n\nvec3 getTexture(in vec3 p, in float m, in Legoman lego) {\n//\tp *= /*man.rot; */Rot(man.yaw, man.pitch, man.roll);//Rot(man.leg_right);\n\tvec3 p0 = p;\n\tp += man.pos;\n\tp = mod(p+2.,4.)-2.;\n    vec3 c;   \n     vec4 txt = texture( iChannel1, vec2(floor((p0.y+2.)/4.-.5)) /256.);\n   // vec4 txt = texture( iChannel1, vec2(.25*p0.y-.7)/256. );\n    if (m == HEAD) {\n\t\tc = vec3(1.,1.,0);\n      //  c = txt.xyz;\n\t\tfloat a = cos(4.*txt.a-iTime); //lego.head;\n\t\tp.xz*= mat2(cos(a), -sin(a), sin(a), cos(a));\n\t\t\n\t\tif (p.z<0.) { // draw face\t\t\t\n\t\t\tvec2 p2 = p.xy;\n\t\t\tp2.y -= 1.46;\n\t\t\tp2 *= 100.; // scale \n\t\t\tfloat face_r = 27.;\n\t\t\tfloat face_x = face_r*0.453596121, //face_r*cos(a); // precalcul\n\t\t\t\t  face_y = -face_r*0.89120736; //face_r*sin(a); // precalcul\n\t\t\tfloat px = abs(p2.x);\n\t\t\tfloat e = 4.-.08*px;\n\t\t\tfloat v = (px<face_x && p2.y<-e) ? abs(length(p2)-face_r)-e : \n\t\t\t\t\t  (p2.y<-e) ? length(vec2(px,p2.y)-vec2(face_x,face_y))-e :\n\t\t\t\t\t  length(vec2(px,p2.y)-vec2(face_x,-face_y*.1))-1.8*e; \n\t\t\tv = clamp(v, 0., 1.);\n\t\t\tc = mix(vec3(0), c, v);\n\t\t}\n    } else {\n        c = m == HAND   ? vec3(1.,1.,0.) :\n\t\t\tm == SHIRT  ? txt.xyz : //lego.c_shirt :\n\t\t\tm == MIDDLE ? cos(txt.xyz)*.15 :// lego.c_middle :\n\t\t\tm == LEGS   ? cos(txt.xyz)*.3 : //lego.c_legs :\n                          lego.c_arms;\n    }\n\treturn c;\n}\n\n#define M_MAX 1e9\n#define KEY_M (float(77)+0.5)/256.0\n\nconst float M_PI = 3.1415926535;\nconst float M_4PI = 4.0 * M_PI;\n\n///////////////////////////////////////\n// planet\nconst float earthRadius \t= 6360.0;\nconst float atmoHeight \t\t= 60.0;\nconst float atmoRadius \t\t= earthRadius + atmoHeight;\nconst vec3 earthCenter \t\t= vec3(0.0, 0., 0.0);\n\n///////////////////////////////////////\n//moon\nconst float moonRadius \t= 1737.0;\nconst vec3 moonCenter = vec3(0.,384000.,0.);\n\n///////////////////////////////////////\n// sun\nconst float distanceToSun = 1.496e8;\nconst float sunRadius = 2.0 * 109.0 * earthRadius;\nconst float sunIntensity = 10.0;\n\n///////////////////////////////////////\n// atmosphere\nconst vec3 betaR \t\t\t= vec3(5.8e-4, 1.35e-3, 3.31e-3);\nconst vec3 betaM \t\t\t= vec3(4.0e-3, 4.0e-3, 4.0e-3);\n\nconst vec3 M_4PIbetaR\t \t= M_4PI * betaR;\nconst vec3 M_4PIbetaM \t\t= M_4PI * betaM;\n\nconst float heightScaleRayleight = 6.0;\nconst float heightScaleMie = 1.2;\nconst float g = -0.76;\n\nconst float NUM_DENSITY_SAMPLES = 6.0;\nconst float NUM_VIEW_SAMPLES = 6.0;\nconst int \tINT_NUM_DENSITY_SAMPLES = int(NUM_DENSITY_SAMPLES);\nconst int\tINT_NUM_VIEW_SAMPLES = int(NUM_VIEW_SAMPLES);\n\n\n// Grab from https://www.shadertoy.com/view/4djSRW\n#define MOD3 vec3(.1031,.11369,.13787)\n//#define MOD3 vec3(443.8975,397.2973, 491.1871)\n\n\n\n\n//-----------------------------------------------------\n// Noise functions\n//-----------------------------------------------------\n// Hash without Sine by Dave_Hoskins [https://www.shadertoy.com/view/4djSRW]\n//----------------------------------------------------------------------------------------\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n#define HASHSCALE1 .1031\n\nfloat hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec4 hash4(const in vec4 n) { return fract(sin(n)*1399763.5453123); }\n\n\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nvec4 hash43(vec3 p) {\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n\treturn fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\n\n//----------------------------------------------------------------------------------------\n/*\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n*/\n\n///////////////////////////////////////\n// ray - sphere intersection\n\nbool sphere(vec3 ro, vec3 rd, float r, out float tn, out float tf) {\n    float b = -dot(rd,ro), \n          d = b*b - dot(ro,ro) + r*r;\n    if (d<0.) return false;\n\ttn = b - sqrt(d);\n\ttf = b+b-tn;\n\treturn tf > 0.;\n}\n\n\nvec2 iSphere(vec3 ro, vec3 rd, vec4 sph)\n{\n    vec3 tmp = ro - sph.xyz;\n\n    float b = dot(rd, tmp);\n    float c = dot(tmp, tmp) - sph.w * sph.w;\n    \n    float disc = b * b - c;\n    \n    if(disc < 0.0) return vec2(-M_MAX, -M_MAX);\n    \n    float disc_sqrt = sqrt(disc);\n\t\n    float t0 = -b - disc_sqrt;\n    float t1 = -b + disc_sqrt;\n    \n    return vec2(t0, t1);\n}\n\n///////////////////////////////////////\n// Henyey-Greenstein phase function\nfloat phase(float nu, float g)\n{\n    float g2 = g*g;\n\treturn (3.0 * (1.0 - g2) * (1.0 + nu * nu)) / (2.0 * (2.0 + g2) * pow(1.0 + g2 - 2.0 * g * nu, 1.5));\n}\n\n///////////////////////////////////////\n// density integral calculation from p0 to p1 \n// for mie and rayleight\nvec2 densityOverPath(vec3 p0, vec3 p1, vec2 prescaler)\n{\n    float l = length(p1 - p0);\n    vec3  v = (p1 - p0) / l;\n    \n    l /= NUM_DENSITY_SAMPLES;\n    \n    vec2 density = vec2(0.0);\n    float t = 0.0;\n    \n\tfor(int i = 0; i < INT_NUM_DENSITY_SAMPLES; i++)\n    {\n        vec3 sp = p0 + v * (t + 0.5 * l);\n        vec2 h = vec2(length(sp) - earthRadius);\n        density += exp(-h / prescaler);\n        \n        t += l;\n    }\n    \n    return l * density;\n}\n\n///////////////////////////////////////\n// inscatter integral calculation\nvec4 inscatter(vec3 cam, vec3 v, vec3 sun)\n{    \n    vec4 atmoSphere \t= vec4(earthCenter, atmoRadius);\n    vec4 earthSphere \t= vec4(earthCenter, earthRadius);\n        \n\tvec2 t0 = iSphere(cam, v, atmoSphere);\n    vec2 t1 = iSphere(cam, v, earthSphere);\n   \n    bool bNoPlanetIntersection = t1.x < 0.0 && t1.y < 0.0;\n    \n    float farPoint = bNoPlanetIntersection ? t0.y : t1.x;\n    float nearPoint = t0.x > 0.0 ? t0.x : 0.0;\n    \n    float l = (farPoint - nearPoint) / NUM_VIEW_SAMPLES;\n\tcam += nearPoint * v;  \n    \n    float t = 0.0;\n\n    vec3 rayleight = vec3(0.0);\n\tvec3 mie = vec3(0.0);\n    \n    vec2 prescalers = vec2(heightScaleRayleight, heightScaleMie);\n    \n    vec2 densityPointToCam = vec2(0.0);\n    \n    for(int i = 0; i < INT_NUM_VIEW_SAMPLES; i++)\n    {\n        vec3 sp = cam + v * (t + 0.5 * l);\n        float tc = iSphere(sp, sun, vec4(earthCenter, atmoRadius)).y;\n        \n        vec3 pc = sp + tc * sun;\n        \n        vec2 densitySPCam = densityOverPath(sp, cam, prescalers);\n        vec2 densities = densityOverPath(sp, pc, prescalers) + densitySPCam;\n        \n        vec2 h = vec2(length(sp) - earthRadius);\n        vec2 expRM = exp(-h / prescalers);\n        \n        rayleight \t+= expRM.x * exp( -M_4PIbetaR * densities.x );\n\t\tmie \t\t+= expRM.y * exp( -M_4PIbetaM * densities.y );\n\n\t\tdensityPointToCam += densitySPCam;\n        \n        t += l;\n    }\n    \n\trayleight *= l;\n    mie *= l;\n    \n    vec3 extinction = exp( - (M_4PIbetaR * densityPointToCam.x + M_4PIbetaM * densityPointToCam.y));\n    \n    float nu = dot(sun, -v);\n    \n    vec3 inscatter_ = sunIntensity * (betaM * mie * phase(nu, g) + betaR * phase(nu, 0.0) * rayleight);\n    return vec4(inscatter_, extinction.r * float(bNoPlanetIntersection));\n}\n\n///////////////////////////////////////\n// rotation around axis Y\nvec3 rotate_y(vec3 v, float angle)\n{\n\tvec3 vo = v; float cosa = cos(angle); float sina = sin(angle);\n\tv.x = cosa*vo.x - sina*vo.z;\n\tv.z = sina*vo.x + cosa*vo.z;\n\treturn v;\n}\n\n\n// Standard Ray-Marching stuff --------------------------------------------\n\nvec2 DE(in vec3 p) {\n\t//p *= /*man.rot; //*/Rot(man.yaw, man.pitch, man.roll);//Rot(man.leg_right);\n\tp += man.pos;\n    vec4 txt = texture( iChannel1, vec2(floor((p.y+2.)/4.)) /256.);\n    p.y = mod(p.y+2.,4.)-2.;\n\treturn legoman(p, man, txt);\n}\n\nvec3 N(vec3 p) {\n\treturn normalize(vec3(\n        DE(p+Ve.xyy).x - DE(p-Ve.xyy).x,\n        DE(p+Ve.yxy).x - DE(p-Ve.yxy).x,\n        DE(p+Ve.yyx).x - DE(p-Ve.yyx).x\n    ));\n}\n\nfloat SoftShadow(in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k) {\n    float res = 1.0, h, t = mint;\n    for( int i=0; i<30; i++ ) {\n        if (t < maxt) {\n            h = DE( ro + rd*t ).x;\n            res = min( res, k*h/t );\n            t += 0.2;\n        }\n    }\n    return clamp(res, 0., 1.);\n}\n\nfloat CalcAO(in vec3 pos, in vec3 nor) {\n    float dd, hr=.01, totao=.0, sca=1.;\n    for(int aoi=0; aoi<5; aoi++ ) {\n        dd = DE(nor * hr + pos).x;\n        totao += -(dd-hr)*sca;\n        sca *= .75;\n        hr += .05;\n    }\n    return clamp(1.-4.*totao, 0., 1.);\n}\n\nvec3 Render(in vec3 p, in vec3 rd, in float t, in float m) {\n\tsunLight = sunDir;\n    \n    vec3  col = getTexture(p, m, man),\n    \t  nor = N(p);\n\t\n    float sh = 1.,\n          ao = CalcAO(p, nor ),\n          amb = clamp(.5+.5*nor.y, .0, 1.),\n          dif = clamp(dot( nor, sunLight ), 0., 1.),\n          bac = clamp(dot( nor, normalize(vec3(-sunLight.x,0.,-sunLight.z))), 0., 1.)*clamp( 1.0-p.y,0.0,1.0);\n\n\tif( dif>.0 ) { \n        sh = SoftShadow( p, sunLight, .02, 10., 7.); \n        dif *= (.1+.8*sh); \n    }\n\t\n\tvec3 brdf =\n\t\tao*.2*(amb*vec3(.10,.11,.13) + bac*.15) +\n\t\t1.2*dif*vec3(1.,.9,.7);\n\t\n\tfloat\n\t\tpp = clamp(dot(reflect(rd,nor), sunLight),0.,1.),\n\t\tspe = sh*pow(pp,16.),\n\t\tfre = ao*pow( clamp(1.+dot(nor,rd),0.,1.), 2.);\n\t\n\tcol = col*(brdf + spe) + .2*fre*(.5*col+.5)*exp(-.01*t*t);\n    return sqrt(col);\n}\n\nmat3 lookat(in vec3 ro, in vec3 up){\n    vec3 fw=normalize(ro),\n    \t rt=normalize(cross(fw,up));\n    return mat3(rt, cross(rt,fw),fw);\n}\n\nvec3 RD(in vec3 ro, in vec3 cp) {\n    return lookat(cp-ro, V01.xyx)*normalize(vec3((2.*fCoord-iResolution.xy)/iResolution.y, 12.0));\n} \n\n// Thanks Dave\nfloat noise3D( in vec3 x )\n{\n    x*= 800.;\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel1, (uv+ 0.5) / 256.0, 0.0).yx;\n\treturn mix(rg.x, rg.y, f.z);\n}\n\n\nvec3 starField(vec3 rd) {\n\tvec3 txt = vec3(noise3D(rd),noise3D(rd.yxz),noise3D(rd.zyx));\n    return smoothstep(.8,1., txt.y) * smoothstep(.8,1., txt.x)*mix(vec3(1.,.5,.5), vec3(1.), txt.z);\n}\n\n// ---------------------------------------\n// FabriceNeyret2: https://www.shadertoy.com/view/llySRh\n// ---------------------------------------\n\n // --- access to the image of ascii code c\nvec4 char(vec2 p, int c) {\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n    //if (p.x<.25|| p.x>.75 || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5); // strange bug\n\treturn textureGrad( iChannel3, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                        dFdx(p/16.),dFdy(p/16.) );\n  //float l = log2(length(fwidth(p/16.*iResolution.xy)));\n  //return textureLod( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), l);\n                   // manual MIPmap to avoid border artifact. Should be textureLod, but don't available everywhere\n}\n\n\n// --- display int4\nvec4 pInt(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(p - vec2(-.5,0), 45 ),\n        n = -n;\n\n    for (float i = 3.; i>=0.; i--) \n        n /=  9.999999, // 10., // for windows :-(\n        v += char(p - .5*vec2(i,0), 48+ int(fract(n)*10.) );\n    return v;\n}\n\n// --- chars\nint CAPS=0;\n#define low CAPS=32\n#define caps CAPS=0\n#define C(c) U.x-=.5; O+= char(U,64+CAPS+c)\n\n\nfloat t1 = 20., t2 = 40., t3 = 50.;\n\n\nvec3 camPos(float t) {\n    if (t < t1) {\n        float a = -1.-t*mix(.0, 3.5, smoothstep(0.6,8.,t));\n        float k = smoothstep(0.5,5.,t*.1);\n        return vec3((25.+k*100.)*cos(a), 100.*k*t, (25.+k*100.)*sin(a));\n    } else if (t < t2) {\n    \tt = t-t1;\n\t    return vec3(35.*cos(-.5*t), t*100., 15.*sin(-.5*t));\n    } else if (t<t3) { \n    \treturn vec3(2.*cos(2.*t)+5.*cos(-.5*t), t*1000., 5.*sin(-.5*t));\n    } \n    return vec3(3.*cos(2.1231*t)+5.*cos(-.5*t), t*100., 5.*sin(-.5*t));\n}\n\nvec3 lookAt(float t, vec3 ro) {\n    if (t<t1) {\n        return vec3(0., ro.y+1.-smoothstep(0.5,5.,t*.1)*t, 0.);\n    } \n    else if (t < t2) {\n    \tt = t-t1;\n    \treturn vec3(1., mix(ro.y, ro.y+1000., smoothstep(t1,t2,t)),0.);\n    } else if (t<t3) { \n        return vec3(0.);\n    } else {\n    \treturn vec3(4.-5.*cos(-.5*t), mix(ro.y, ro.y+200., smoothstep(t1,t2,t)),-5.*sin(-.5*t));\n    }\n}\n\nvec3 camPosEarth(float t) {\n    if (t < t1) {\n        float a = -1.-t*mix(.0, 3.5, smoothstep(0.6,8.,t));\n        return vec3(.1*cos(a), .1+smoothstep(0.5,5.,t*.1)*t, .1*sin(a));\n    } else if (t < t2) {\n    \tt = t-t1;\n\t    return vec3(5.*cos(-.5*t), t, 5.*sin(-.5*t));\n    } else if (t < t3) {\n        t -= t2;\n\t    return vec3(5.*cos(-.5*t), 90000.+t*t*500., 5.*sin(-.5*t));\n    } else {\n    \treturn vec3(5.*cos(-.5*t), t*100., 5.*sin(-.5*t));\n    }\n}\n\nvec3 lookAtEarth(float t, vec3 ro) {\n    if (t<t1) {\n        return vec3(0., ro.y+.01, 0.);\n    } else if (t < t2) {\n        return vec3(0, mix(ro.y, ro.y+.5, smoothstep(t1,t2,t)), 0);\n    } else if(t<t3) {\n        return vec3(0.);\n    } else {\n    \t//return vec3(0.,ro.y+1.,0.);\n        return moonCenter;\n    }\n}\n\n\nfloat getAlti(float t) {\n    if (t < t1) return camPos(t).y/4.;  // cm\n    if (t < t2) return camPosEarth(t).y*10.;\n    if (t < t3) return camPosEarth(t).y;\n\treturn 3e5 + camPosEarth(t).y;\n}\n\n\n/*\nfloat rnd(float w) {\n    return fract(sin(w)*1e3);\n}\n\n\nfloat regShape(vec2 p, float N) {\n\tfloat a = atan(p.x,p.y)+.2, \n       \t  b = 6.28319/N;\n\treturn smoothstep(.5,.51, cos(floor(.5+a/b)*b-a)*length(p.xy));\n}\n\n\nvec3 circle(vec2 p, float s, float d, vec2 m) {\n    vec2 k = m*d;\n    float l = length(p + k*4.) + s*.5,\n        c  = 50.*max(.01 -pow(length(p +k), s*1.4), 0.)\n           +  3.*max(.001-pow(l-.3, 1./40.)+sin(l*30.), .0)\n           +  5.*max(.01 -pow(regShape(p*5. + k*5. + .9, 6.) , 1.), 0.)\n           + .05*max(.04 /length(p-k*.4), 0.);\n      return c*(cos(vec3(.44, .24, .2)*8. + d*4.)*.5 + .5)-.01;\n}\n\n\nvec3 flare(vec2 p, vec2 uv)\n{\n    //now to make the sky not black\n    vec3 c = vec3(0);//mix(vec3(.3, .2, .02)/.9, vec3(.2, .5, .8), uv.y)*3.-.52*sin(iTime);\n         \n    //this calls the function which adds three circle types every time through the loop based on parameters I\n    //got by trying things out. rnd i*2000. and rnd i*20 are just to help randomize things more\n    for(float i=0.;i<10.;i++)\n        c += circle(uv, pow(rnd(i*2e3)*1.8, 2.)+1.41, rnd(i*20.)*3.-.3, p);\n    \n    \n    //get angle and length of the sun (uv - mouse)\n    float a = atan(uv.y-p.y, uv.x-p.x),\n          l = max(1.-length(uv-p)-.84, 0.),\n          b = .1; // brightnes //+0.1/abs(sin(iTime/3.))/3.;//add brightness based on how the sun moves so that it is brightest\n    //when it is lined up with the center\n    \n    float lu = length(uv-p);\n    //add the sun with the frill things\n    c += max(.1/pow(lu*5.,   5.), 0.) * abs(sin(a*5.+cos(a*9.))) * .05;\n    c += max(.1/pow(lu*10., .05), 0.) + abs(sin(a*3.+cos(a*9.))) * .125*abs(sin(a*9.));\n    //add another sun in the middle (to make it brighter)  with the20color I want, and bright as the numerator.\n    c += max(b/pow(lu*4., .5), 0.) * 16.*vec3(.2, .21, .3);\n       // * (0.5+.5*sin(vec3(0.4, 0.2, 0.1) + vec3(a*2., 00., a*3.)+1.3));\n    \t\n    //multiply by the exponetial e^x ? of 1.0-length which kind of masks the brightness more so that\n    //there is a sharper roll of of the light decay from the sun. \n    c*= exp(1.-lu)*.2;\n    \n\treturn c;\n}\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    float speed = 50.;\n    vec2 sc = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    sc.x *= iResolution.x / iResolution.y;\n    \n    \n   \n    float time = (iResolution.x < 400.) ? iTime-10.: iTime;\n    vec3 ctot = vec3(0);\n    \n    \n    // Earth in coord earth (km)\n    vec2 \n\t\tobj, \n//\t\tmouse = (iMouse.xy/iResolution.xy)*6.28,\n\t\tq = fragCoord.xy/iResolution.xy;\n    vec3 \n\t\tro = camPosEarth(time),\n        rd, cp = lookAtEarth(time, ro);\n  \n    ro.y += earthRadius;\n    cp.y += earthRadius;\n\t\n\tfCoord = fragCoord.xy;\n     rd = RD(ro, cp);\n    \n \n    \n    vec4 col = inscatter(ro, rd, sunDir);\n    \n    vec3 sunPos = sunDir * distanceToSun;\n    \n    vec4 star = vec4(sunPos, sunRadius);\n    vec2 t0 = iSphere(ro, rd, star);\n    \n    if(t0.x > 0.0)\n    {\n    \tcol.xyz += vec3(1.0,1.0,1.0) * col.a;\n    }\n    \n    if (iTime>t1) {\n    \tvec3 stars = starField(rd);\n    \tcol.xyz = col.xyz + stars * col.a;\n    }\n    col.xyz = pow(col.xyz, vec3(1.0 / 2.2));\n    \n    float tn, tf;\n    \n  \n    if (iTime>t3) {\n    \tro = camPos(iTime),\n        cp = lookAt(iTime, ro);\n \n\t\n\t\tfCoord = fragCoord.xy;\n        rd = RD(ro, cp);\n  \n \n  \t  \tt0 = iSphere(ro, rd, vec4(moonCenter, moonRadius/2.));\n   \t \tif(t0.x > 0.0)\n    \t{\n            vec3 p = ro + rd*t0.x, n = normalize(moonCenter - p);\n            float e = dot(n,-sunDir);\n    \t\tcol.xyz = vec3(sqrt(e));\n    \t}\n    }\n    \n    \n  \n\n    fragColor = col;\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n\n// Created by sebastien durand - 01/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// ---------------------------------------\n// Just to illustrate a strange reflexion\n// Take 1 legoman by living human being. \n// Put them on top of each other (5cm each), and you can almost reach the Moon! \n// With the true humans you are approaching Venus\n\n\n// ---------------------------------------\n// Text : FabriceNeyret2: https://www.shadertoy.com/view/llySRh\n// ---------------------------------------\n// Atmosphere : dmytro rubalskyi (ruba) : https://www.shadertoy.com/view/XlXGzB\n// ---------------------------------------\n\n\n//#define ANTIALIASING\n\n#define AA 4\n#define TAO 6.28318530718\n#define NB_ITER 100\n#define MAX_DIST 5000.\n#define PRECISION .002\n\n// - LegoMan Constants & Globals ------------------------------------------\n\n#define HEAD 1.\n#define SHIRT 2.\n#define MIDDLE 3.\n#define LEGS 4.\n#define ARMS 5.\n#define HAND 6.\n\nconst lowp float \n\tlegh = 1., \n\tlege=.34, \n\tlegx=.31;\n\n\n\n   vec3 sunDir = normalize(vec3(1.0, .9, -1.0));\n\n// -- Tools -----------------------------------------------------------\n\nfloat smin(in float a, in float b, in float k ) {\n    float h = clamp( .5+.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.-h);\n}\n\nvec2 minObj(in vec2 o1, in vec2 o2) {\n    return (o1.x<o2.x) ? o1 : o2;\n}\n\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\nmat2 Rot(in float a) {\n\tfloat sa=sin(a), ca=cos(a);\n\treturn mat2(ca, -sa, sa, ca);\n}\n\n\n\n\nbool box(vec3 ro, vec3 rd, vec3 sz, out float tn, out float tf) {\n\tvec3 m = 1./rd,\n         k = abs(m)*sz,\n         a = -m*ro-k*.5, \n         b = a+k;\n    tn = max(max(a.x,a.y),a.z);\n    tf = min(min(b.x,b.y),b.z);\n\treturn tn>0. && tn<tf;\n}\n\n// -------------------------------------------------------------------\n\n\nvec3 armn = normalize(vec3(-.4,-1.,-.5) - vec3(-.25,-.5,0));\nvec2 boby2 = normalize(vec2(1,.15));\nmat2 handmat;\n\n\n// -- Legoman position and color -------------------------------------\n\nstruct Legoman {\n\tfloat \n\t\thead,\n\t\tarm_left, arm_right,\n\t\tleg_left, leg_right,\n\t\thand_left, hand_right,\n\t\tyaw, pitch,roll;\n\tvec3 pos;\n\tvec3 c_shirt, c_arms, c_middle, c_legs;\n};\n\nLegoman man = Legoman(-.2, \n\t\t\t\t\t  2.,-.4,.6,-.5, 0.,0.,\n\t\t\t\t\t  0.,0.,0.,\n\t\t\t\t\t  vec3(0,-.77,0),\n\t\t\t\t\t  vec3(1,0,0), vec3(1), vec3(.1,.1,.3), vec3(.1,.1,.4));\n\n\n// -- Renderer Constants & Globals -------------------------------------\n\nconst vec2 \n\tV01 = vec2(0,1),\n\tVe = vec2(.001,0);\n\nfloat time;\nvec3 sunLight;\nvec2 fCoord;\n\n\n// -- Distance functions -----------------------------------------------\n\nfloat sdCapsule(in vec3 p, in vec3 a, in vec3 b, in float r0, in float r1 ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1.);\n    return length( pa - ba*h ) - mix(r0,r1,h);\n}\n\nfloat roundCylinder(in vec3 p, in float h, in float r1, in float r2) {\n    float a = abs(p.y)-(h-r2), b = length(p.xz)-r1;\n    return min(min(max(a, b), max(a-r2, b+r2)), length(vec2(b+r2,a))-r2);\n}\n\nfloat head(in vec3 p) {\n    float d = max(abs(p.y+.4)-.3, length(p.xz)-.326);\n    d = min(d, roundCylinder(p, .425,.51,.1));\n    p.y -= .425;\n    return min(d, roundCylinder(p, .173, .245,.025));\n}\n\nfloat body(in vec3 p) {\n    vec3 vd = abs(p) -  vec3(.75,.6,1.);\n    float d = min(max(vd.x,max(vd.y,vd.z)),0.0) + length(max(vd,0.0));\n    p.x = abs(p.x);\n    d = max(dot(p.xy, boby2)-.7,d);\n    p.y -= .4;    \n    d = min(d, length(max(abs(p)- vec3(.47,.14,.45),0.0))-.16);\n    return max(abs(p.z)-.392, d);\n}\n\nfloat leg(in vec3 p) {\n    float d = length(p.zy)-lege;\n    d = min(d, length(max(abs(p+vec3(0.,legh*.5,-.08))-vec3(legx,legh*.5,lege-.08),0.)));\n    d = min(d, length(max(abs(p+vec3(0.,legh,.02))-vec3(legx,.15,lege+.02),0.)));\n    d = max(abs(p.x)-legx, d)-.02;\n    vec3 dd = abs(p+vec3(0.,legh,-.08))-vec3(legx-.1,legh+.2,lege-.18);\n    float d2 = min(max(dd.x,max(dd.y,dd.z)),0.) + length(max(dd,0.));\n    dd = abs(p+vec3(0.,legh+.1,.02))-vec3(legx-.1,.15,lege-.98);\n    d2 = min(d2, min(max(dd.x,max(dd.y,dd.z)),0.0) + length(max(dd,0.)));\n    d2 = min(d2, max(-p.z-.05, length(p.xy-vec2(0,-.1))-.24));\n    d2 = min(d2, max(-p.z-.05, length(p.xy-vec2(0,-.8))-.24));\n    return max(-d2,d);\n}\n\nfloat arm(in vec3 p) {\n    float d = smin(sdCapsule(p, vec3(0), vec3(-.25,-.5,0), .22, .23), \n\t\t\t\t   sdCapsule(p, vec3(-.25,-.5,0), vec3(-.4,-1.,-.5), .23, .24),.02); \n    return max(dot(p, armn) - .9, d);\n}\n\nfloat hand(in vec3 p) {\n    float d1 = length(p)-.15;\n\tp.y+=.29;\n    float d=length(p.xy);\n    return max(abs(p.z+.09)-.2, max(-length(p.xy+vec2(-.1,.25))+.2, max(-d+.18, smin(d1, d-.26,.02))));\n}\n\nvec2 legoman(in vec3 p, in Legoman lego, vec4 txt) {\n\tfloat sa,ca, a;\n\tbool isLeft = p.x>0.;\n\t\n\t// - Head & Shirt --------------------\n\tvec2 dHead = vec2(head(p+vec3(0,-1.4,0)), HEAD),\n    \t dBody = vec2(body(p+vec3(0,-.15,0)), SHIRT);\n   \n\t// - Middle --------------------------\n    float middle = length(max(abs(p+vec3(0,.44,0))- vec3(.65,.1,.325),0.0))-.05;\n    middle = min(middle,roundCylinder(p.yxz+vec3(.76,0,0),.06,.39,.02));\n    vec2 dMiddle = vec2(middle,MIDDLE);   \n\t\n\t// - Legs ----------------------------\n    p.x = -abs(p.x);       \n\tvec3 p1 = p;\n\tp1.y +=.77;\n\t//R(p1.yz,isLeft?-lego.leg_left:-lego.leg_right);\n\tp1.x += .38;\n\tvec2 dLeg = vec2(leg(p1), LEGS);\n\n\t// - Arms ----------------------------\n    p += vec3(.7,-.55,0); \n    float ang1 = -fract(txt.x*4.);\n    float ang2 = -fract(txt.y*4.);\n    \n\tR(p.yz,isLeft?-ang1:-ang2);\n    vec2 dArm = vec2(arm(p), ARMS);\n\t\n\t// - Hands ---------------------------\n\tp += vec3(.35,.85,.35);\n\tp.yz *= handmat;\n\t//R(p.xz,isLeft?-lego.hand_left:-lego.hand_right);\n    vec2 dHand = vec2(hand(p), HAND);\n\n\t// - Mix -----------------------------\n    return minObj(minObj(minObj(minObj(minObj(dHead, dBody),dHand),dArm),dMiddle),dLeg);\n\t//res = minObj(res, vec2(length(boundingSphere.xyz) - boundingSphere.w, 3.));\n//\treturn  vec2(length(boundingSphere.xyz) - boundingSphere.w, 3.);\n}\n\n\n// -- Legoman colors ----------------------------------------- \n\nvec3 getTexture(in vec3 p, in float m, in Legoman lego) {\n//\tp *= /*man.rot; */Rot(man.yaw, man.pitch, man.roll);//Rot(man.leg_right);\n\tvec3 p0 = p;\n\tp += man.pos;\n\tp = mod(p+2.,4.)-2.;\n    vec3 c;   \n     vec4 txt = texture( iChannel1, vec2(floor((p0.y+2.)/4.-.5)) /256.);\n   // vec4 txt = texture( iChannel1, vec2(.25*p0.y-.7)/256. );\n    if (m == HEAD) {\n\t\tc = vec3(1.,1.,0);\n      //  c = txt.xyz;\n\t\tfloat a = cos(4.*txt.a-iTime); //lego.head;\n\t\tp.xz*= mat2(cos(a), -sin(a), sin(a), cos(a));\n\t\t\n\t\tif (p.z<0.) { // draw face\t\t\t\n\t\t\tvec2 p2 = p.xy;\n\t\t\tp2.y -= 1.46;\n\t\t\tp2 *= 100.; // scale \n\t\t\tfloat face_r = 27.;\n\t\t\tfloat face_x = face_r*0.453596121, //face_r*cos(a); // precalcul\n\t\t\t\t  face_y = -face_r*0.89120736; //face_r*sin(a); // precalcul\n\t\t\tfloat px = abs(p2.x);\n\t\t\tfloat e = 4.-.08*px;\n\t\t\tfloat v = (px<face_x && p2.y<-e) ? abs(length(p2)-face_r)-e : \n\t\t\t\t\t  (p2.y<-e) ? length(vec2(px,p2.y)-vec2(face_x,face_y))-e :\n\t\t\t\t\t  length(vec2(px,p2.y)-vec2(face_x,-face_y*.1))-1.8*e; \n\t\t\tv = clamp(v, 0., 1.);\n\t\t\tc = mix(vec3(0), c, v);\n\t\t}\n    } else {\n        c = m == HAND   ? vec3(1.,1.,0.) :\n\t\t\tm == SHIRT  ? txt.xyz : //lego.c_shirt :\n\t\t\tm == MIDDLE ? cos(txt.xyz)*.15 :// lego.c_middle :\n\t\t\tm == LEGS   ? cos(txt.xyz)*.3 : //lego.c_legs :\n                          lego.c_arms;\n    }\n\treturn c;\n}\n\n#define M_MAX 1e9\n#define KEY_M (float(77)+0.5)/256.0\n\nconst float M_PI = 3.1415926535;\nconst float M_4PI = 4.0 * M_PI;\n\n///////////////////////////////////////\n// planet\nconst float earthRadius \t= 6360.0;\nconst float atmoHeight \t\t= 60.0;\nconst float atmoRadius \t\t= earthRadius + atmoHeight;\nconst vec3 earthCenter \t\t= vec3(0.0, 0., 0.0);\n\n///////////////////////////////////////\n//moon\nconst float moonRadius \t= 1737.0;\nconst vec3 moonCenter = vec3(0.,384000.,0.);\n\n///////////////////////////////////////\n// sun\nconst float distanceToSun = 1.496e8;\nconst float sunRadius = 2.0 * 109.0 * earthRadius;\nconst float sunIntensity = 10.0;\n\n///////////////////////////////////////\n// atmosphere\nconst vec3 betaR \t\t\t= vec3(5.8e-4, 1.35e-3, 3.31e-3);\nconst vec3 betaM \t\t\t= vec3(4.0e-3, 4.0e-3, 4.0e-3);\n\nconst vec3 M_4PIbetaR\t \t= M_4PI * betaR;\nconst vec3 M_4PIbetaM \t\t= M_4PI * betaM;\n\nconst float heightScaleRayleight = 6.0;\nconst float heightScaleMie = 1.2;\nconst float g = -0.76;\n\nconst float NUM_DENSITY_SAMPLES = 6.0;\nconst float NUM_VIEW_SAMPLES = 6.0;\nconst int \tINT_NUM_DENSITY_SAMPLES = int(NUM_DENSITY_SAMPLES);\nconst int\tINT_NUM_VIEW_SAMPLES = int(NUM_VIEW_SAMPLES);\n\n\n// Grab from https://www.shadertoy.com/view/4djSRW\n#define MOD3 vec3(.1031,.11369,.13787)\n//#define MOD3 vec3(443.8975,397.2973, 491.1871)\n\n\n\n\n//-----------------------------------------------------\n// Noise functions\n//-----------------------------------------------------\n// Hash without Sine by Dave_Hoskins [https://www.shadertoy.com/view/4djSRW]\n//----------------------------------------------------------------------------------------\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n#define HASHSCALE1 .1031\n\nfloat hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec4 hash4(const in vec4 n) { return fract(sin(n)*1399763.5453123); }\n\n\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nvec4 hash43(vec3 p) {\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n\treturn fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\n\n//----------------------------------------------------------------------------------------\n/*\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n*/\n\n///////////////////////////////////////\n// ray - sphere intersection\n\nbool sphere(vec3 ro, vec3 rd, float r, out float tn, out float tf) {\n    float b = -dot(rd,ro), \n          d = b*b - dot(ro,ro) + r*r;\n    if (d<0.) return false;\n\ttn = b - sqrt(d);\n\ttf = b+b-tn;\n\treturn tf > 0.;\n}\n\n\nvec2 iSphere(vec3 ro, vec3 rd, vec4 sph)\n{\n    vec3 tmp = ro - sph.xyz;\n\n    float b = dot(rd, tmp);\n    float c = dot(tmp, tmp) - sph.w * sph.w;\n    \n    float disc = b * b - c;\n    \n    if(disc < 0.0) return vec2(-M_MAX, -M_MAX);\n    \n    float disc_sqrt = sqrt(disc);\n\t\n    float t0 = -b - disc_sqrt;\n    float t1 = -b + disc_sqrt;\n    \n    return vec2(t0, t1);\n}\n\n///////////////////////////////////////\n// Henyey-Greenstein phase function\nfloat phase(float nu, float g)\n{\n    float g2 = g*g;\n\treturn (3.0 * (1.0 - g2) * (1.0 + nu * nu)) / (2.0 * (2.0 + g2) * pow(1.0 + g2 - 2.0 * g * nu, 1.5));\n}\n\n///////////////////////////////////////\n// density integral calculation from p0 to p1 \n// for mie and rayleight\nvec2 densityOverPath(vec3 p0, vec3 p1, vec2 prescaler)\n{\n    float l = length(p1 - p0);\n    vec3  v = (p1 - p0) / l;\n    \n    l /= NUM_DENSITY_SAMPLES;\n    \n    vec2 density = vec2(0.0);\n    float t = 0.0;\n    \n\tfor(int i = 0; i < INT_NUM_DENSITY_SAMPLES; i++)\n    {\n        vec3 sp = p0 + v * (t + 0.5 * l);\n        vec2 h = vec2(length(sp) - earthRadius);\n        density += exp(-h / prescaler);\n        \n        t += l;\n    }\n    \n    return l * density;\n}\n\n///////////////////////////////////////\n// inscatter integral calculation\nvec4 inscatter(vec3 cam, vec3 v, vec3 sun)\n{    \n    vec4 atmoSphere \t= vec4(earthCenter, atmoRadius);\n    vec4 earthSphere \t= vec4(earthCenter, earthRadius);\n        \n\tvec2 t0 = iSphere(cam, v, atmoSphere);\n    vec2 t1 = iSphere(cam, v, earthSphere);\n   \n    bool bNoPlanetIntersection = t1.x < 0.0 && t1.y < 0.0;\n    \n    float farPoint = bNoPlanetIntersection ? t0.y : t1.x;\n    float nearPoint = t0.x > 0.0 ? t0.x : 0.0;\n    \n    float l = (farPoint - nearPoint) / NUM_VIEW_SAMPLES;\n\tcam += nearPoint * v;  \n    \n    float t = 0.0;\n\n    vec3 rayleight = vec3(0.0);\n\tvec3 mie = vec3(0.0);\n    \n    vec2 prescalers = vec2(heightScaleRayleight, heightScaleMie);\n    \n    vec2 densityPointToCam = vec2(0.0);\n    \n    for(int i = 0; i < INT_NUM_VIEW_SAMPLES; i++)\n    {\n        vec3 sp = cam + v * (t + 0.5 * l);\n        float tc = iSphere(sp, sun, vec4(earthCenter, atmoRadius)).y;\n        \n        vec3 pc = sp + tc * sun;\n        \n        vec2 densitySPCam = densityOverPath(sp, cam, prescalers);\n        vec2 densities = densityOverPath(sp, pc, prescalers) + densitySPCam;\n        \n        vec2 h = vec2(length(sp) - earthRadius);\n        vec2 expRM = exp(-h / prescalers);\n        \n        rayleight \t+= expRM.x * exp( -M_4PIbetaR * densities.x );\n\t\tmie \t\t+= expRM.y * exp( -M_4PIbetaM * densities.y );\n\n\t\tdensityPointToCam += densitySPCam;\n        \n        t += l;\n    }\n    \n\trayleight *= l;\n    mie *= l;\n    \n    vec3 extinction = exp( - (M_4PIbetaR * densityPointToCam.x + M_4PIbetaM * densityPointToCam.y));\n    \n    float nu = dot(sun, -v);\n    \n    vec3 inscatter_ = sunIntensity * (betaM * mie * phase(nu, g) + betaR * phase(nu, 0.0) * rayleight);\n    return vec4(inscatter_, extinction.r * float(bNoPlanetIntersection));\n}\n\n///////////////////////////////////////\n// rotation around axis Y\nvec3 rotate_y(vec3 v, float angle)\n{\n\tvec3 vo = v; float cosa = cos(angle); float sina = sin(angle);\n\tv.x = cosa*vo.x - sina*vo.z;\n\tv.z = sina*vo.x + cosa*vo.z;\n\treturn v;\n}\n\n\n// Standard Ray-Marching stuff --------------------------------------------\n\nvec2 DE(in vec3 p) {\n\t//p *= /*man.rot; //*/Rot(man.yaw, man.pitch, man.roll);//Rot(man.leg_right);\n\tp += man.pos;\n    vec4 txt = texture( iChannel1, vec2(floor((p.y+2.)/4.)) /256.);\n    p.y = mod(p.y+2.,4.)-2.;\n\treturn legoman(p, man, txt);\n}\n\nvec3 N(vec3 p) {\n\treturn normalize(vec3(\n        DE(p+Ve.xyy).x - DE(p-Ve.xyy).x,\n        DE(p+Ve.yxy).x - DE(p-Ve.yxy).x,\n        DE(p+Ve.yyx).x - DE(p-Ve.yyx).x\n    ));\n}\n\nfloat SoftShadow(in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k) {\n    float res = 1.0, h, t = mint;\n    for( int i=0; i<30; i++ ) {\n        if (t < maxt) {\n            h = DE( ro + rd*t ).x;\n            res = min( res, k*h/t );\n            t += 0.2;\n        }\n    }\n    return clamp(res, 0., 1.);\n}\n\nfloat CalcAO(in vec3 pos, in vec3 nor) {\n    float dd, hr=.01, totao=.0, sca=1.;\n    for(int aoi=0; aoi<5; aoi++ ) {\n        dd = DE(nor * hr + pos).x;\n        totao += -(dd-hr)*sca;\n        sca *= .75;\n        hr += .05;\n    }\n    return clamp(1.-4.*totao, 0., 1.);\n}\n\nvec3 Render(in vec3 p, in vec3 rd, in float t, in float m) {\n\tsunLight = sunDir;\n    \n    vec3  col = getTexture(p, m, man),\n    \t  nor = N(p);\n\t\n    float sh = 1.,\n          ao = CalcAO(p, nor ),\n          amb = clamp(.5+.5*nor.y, .0, 1.),\n          dif = clamp(dot( nor, sunLight ), 0., 1.),\n          bac = clamp(dot( nor, normalize(vec3(-sunLight.x,0.,-sunLight.z))), 0., 1.)*clamp( 1.0-p.y,0.0,1.0);\n\n\tif( dif>.0 ) { \n        sh = SoftShadow( p, sunLight, .02, 10., 7.); \n        dif *= (.1+.8*sh); \n    }\n\t\n\tvec3 brdf =\n\t\tao*.2*(amb*vec3(.10,.11,.13) + bac*.15) +\n\t\t1.2*dif*vec3(1.,.9,.7);\n\t\n\tfloat\n\t\tpp = clamp(dot(reflect(rd,nor), sunLight),0.,1.),\n\t\tspe = sh*pow(pp,16.),\n\t\tfre = ao*pow( clamp(1.+dot(nor,rd),0.,1.), 2.);\n\t\n\tcol = col*(brdf + spe) + .2*fre*(.5*col+.5)*exp(-.01*t*t);\n    return sqrt(col);\n}\n\nmat3 lookat(in vec3 ro, in vec3 up){\n    vec3 fw=normalize(ro),\n    \t rt=normalize(cross(fw,up));\n    return mat3(rt, cross(rt,fw),fw);\n}\n\nvec3 RD(in vec3 ro, in vec3 cp) {\n    return lookat(cp-ro, V01.xyx)*normalize(vec3((2.*fCoord-iResolution.xy)/iResolution.y, 12.0));\n} \n\n// Thanks Dave\nfloat noise3D( in vec3 x )\n{\n    x*= 800.;\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel1, (uv+ 0.5) / 256.0, 0.0).yx;\n\treturn mix(rg.x, rg.y, f.z);\n}\n\n\nvec3 starField(vec3 rd) {\n\tvec3 txt = vec3(noise3D(rd),noise3D(rd.yxz),noise3D(rd.zyx));\n    return smoothstep(.8,1., txt.y) * smoothstep(.8,1., txt.x)*mix(vec3(1.,.5,.5), vec3(1.), txt.z);\n}\n\n// ---------------------------------------\n// FabriceNeyret2: https://www.shadertoy.com/view/llySRh\n// ---------------------------------------\n\n // --- access to the image of ascii code c\nvec4 char(vec2 p, int c) {\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n    //if (p.x<.25|| p.x>.75 || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5); // strange bug\n\treturn textureGrad( iChannel3, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                        dFdx(p/16.),dFdy(p/16.) );\n  //float l = log2(length(fwidth(p/16.*iResolution.xy)));\n  //return textureLod( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), l);\n                   // manual MIPmap to avoid border artifact. Should be textureLod, but don't available everywhere\n}\n\n\n// --- display int4\nvec4 pInt(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(p - vec2(-.5,0), 45 ),\n        n = -n;\n\n    for (float i = 3.; i>=0.; i--) \n        n /=  9.999999, // 10., // for windows :-(\n        v += char(p - .5*vec2(i,0), 48+ int(fract(n)*10.) );\n    return v;\n}\n\n// --- chars\nint CAPS=0;\n#define low CAPS=32\n#define caps CAPS=0\n#define C(c) U.x-=.5; O+= char(U,64+CAPS+c)\n\n\nfloat t1 = 20., t2 = 40., t3 = 50.;\n\n\nvec3 camPos(float t) {\n    if (t < t1) {\n        float a = -1.-t*mix(.0, 3.5, smoothstep(0.6,8.,t));\n        float k = smoothstep(0.5,5.,t*.1);\n        return vec3((25.+k*100.)*cos(a), 100.*k*t, (25.+k*100.)*sin(a));\n    } else if (t < t2) {\n    \tt = t-t1;\n\t    return vec3(35.*cos(-.5*t), t*100., 15.*sin(-.5*t));\n    } else if (t<t3) { \n    \treturn vec3(2.*cos(2.*t)+5.*cos(-.5*t), t*1000., 5.*sin(-.5*t));\n    } \n    return vec3(3.*cos(2.1231*t)+5.*cos(-.5*t), t*100., 5.*sin(-.5*t));\n}\n\nvec3 lookAt(float t, vec3 ro) {\n    if (t<t1) {\n        return vec3(0., ro.y+1.-smoothstep(0.5,5.,t*.1)*t, 0.);\n    } \n    else if (t < t2) {\n    \tt = t-t1;\n    \treturn vec3(1., mix(ro.y, ro.y+1000., smoothstep(t1,t2,t)),0.);\n    } else if (t<t3) { \n        return vec3(0.);\n    } else {\n    \treturn vec3(4.-5.*cos(-.5*t), mix(ro.y, ro.y+200., smoothstep(t1,t2,t)),-5.*sin(-.5*t));\n    }\n}\n\nvec3 camPosEarth(float t) {\n    if (t < t1) {\n        float a = -1.-t*mix(.0, 3.5, smoothstep(0.6,8.,t));\n        return vec3(.1*cos(a), .1+smoothstep(0.5,5.,t*.1)*t, .1*sin(a));\n    } else if (t < t2) {\n    \tt = t-t1;\n\t    return vec3(5.*cos(-.5*t), t, 5.*sin(-.5*t));\n    } else if (t < t3) {\n        t -= t2;\n\t    return vec3(5.*cos(-.5*t), 90000.+t*t*500., 5.*sin(-.5*t));\n    } else {\n    \treturn vec3(5.*cos(-.5*t), t*100., 5.*sin(-.5*t));\n    }\n}\n\nvec3 lookAtEarth(float t, vec3 ro) {\n    if (t<t1) {\n        return vec3(0., ro.y+.01, 0.);\n    } else if (t < t2) {\n        return vec3(0, mix(ro.y, ro.y+.5, smoothstep(t1,t2,t)), 0);\n    } else if(t<t3) {\n        return vec3(0.);\n    } else {\n    \t//return vec3(0.,ro.y+1.,0.);\n        return moonCenter;\n    }\n}\n\n/*\nfloat rnd(float w) {\n    return fract(sin(w)*1e3);\n}\n\n\nfloat regShape(vec2 p, float N) {\n\tfloat a = atan(p.x,p.y)+.2, \n       \t  b = 6.28319/N;\n\treturn smoothstep(.5,.51, cos(floor(.5+a/b)*b-a)*length(p.xy));\n}\n\n\nvec3 circle(vec2 p, float s, float d, vec2 m) {\n    vec2 k = m*d;\n    float l = length(p + k*4.) + s*.5,\n        c  = 50.*max(.01 -pow(length(p +k), s*1.4), 0.)\n           +  3.*max(.001-pow(l-.3, 1./40.)+sin(l*30.), .0)\n           +  5.*max(.01 -pow(regShape(p*5. + k*5. + .9, 6.) , 1.), 0.)\n           + .05*max(.04 /length(p-k*.4), 0.);\n      return c*(cos(vec3(.44, .24, .2)*8. + d*4.)*.5 + .5)-.01;\n}\n\n\nvec3 flare(vec2 p, vec2 uv)\n{\n    //now to make the sky not black\n    vec3 c = vec3(0);//mix(vec3(.3, .2, .02)/.9, vec3(.2, .5, .8), uv.y)*3.-.52*sin(iTime);\n         \n    //this calls the function which adds three circle types every time through the loop based on parameters I\n    //got by trying things out. rnd i*2000. and rnd i*20 are just to help randomize things more\n    for(float i=0.;i<10.;i++)\n        c += circle(uv, pow(rnd(i*2e3)*1.8, 2.)+1.41, rnd(i*20.)*3.-.3, p);\n    \n    \n    //get angle and length of the sun (uv - mouse)\n    float a = atan(uv.y-p.y, uv.x-p.x),\n          l = max(1.-length(uv-p)-.84, 0.),\n          b = .1; // brightnes //+0.1/abs(sin(iTime/3.))/3.;//add brightness based on how the sun moves so that it is brightest\n    //when it is lined up with the center\n    \n    float lu = length(uv-p);\n    //add the sun with the frill things\n    c += max(.1/pow(lu*5.,   5.), 0.) * abs(sin(a*5.+cos(a*9.))) * .05;\n    c += max(.1/pow(lu*10., .05), 0.) + abs(sin(a*3.+cos(a*9.))) * .125*abs(sin(a*9.));\n    //add another sun in the middle (to make it brighter)  with the20color I want, and bright as the numerator.\n    c += max(b/pow(lu*4., .5), 0.) * 16.*vec3(.2, .21, .3);\n       // * (0.5+.5*sin(vec3(0.4, 0.2, 0.1) + vec3(a*2., 00., a*3.)+1.3));\n    \t\n    //multiply by the exponetial e^x ? of 1.0-length which kind of masks the brightness more so that\n    //there is a sharper roll of of the light decay from the sun. \n    c*= exp(1.-lu)*.2;\n    \n\treturn c;\n}\n*/\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta)\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0, 1,0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    float speed = 50.;\n    vec2 sc = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    sc.x *= iResolution.x / iResolution.y;\n    \n    \n   \n    float time = (iResolution.x < 400.) ? iTime-10.: iTime;\n    vec4 ctot = vec4(0);\n    \n    \n    // Earth in coord earth (km)\n    vec2 \n\t\tobj, \n//\t\tmouse = (iMouse.xy/iResolution.xy)*6.28,\n\t\tq = fragCoord.xy/iResolution.xy;\n    vec3 \n\t\tro = camPosEarth(time),\n        rd, cp = lookAtEarth(time, ro);\n  \n    ro.y += earthRadius;\n    cp.y += earthRadius;\n\t\n\tfCoord = fragCoord.xy;\n     rd = RD(ro, cp);\n    \n vec4 col = vec4(0);\n    /*\n    vec4 col = inscatter(ro, rd, sunDir);\n    \n    vec3 sunPos = sunDir * distanceToSun;\n    \n    vec4 star = vec4(sunPos, sunRadius);\n    vec2 t0 = iSphere(ro, rd, star);\n    \n    if(t0.x > 0.0)\n    {\n    \tcol.xyz += vec3(1.0,1.0,1.0) * col.a;\n    }\n    \n    if (iTime>t1) {\n    \tvec3 stars = starField(rd);\n    \tcol.xyz = col.xyz + stars * col.a;\n    }\n    col.xyz = pow(col.xyz, vec3(1.0 / 2.2));\n    \n    float tn, tf;\n    \n  \n    if (iTime>t3) {\n    \tro = camPos(iTime),\n        cp = lookAt(iTime, ro);\n   // ro.y += alti+100.;\n        \n       // ro.y += alti;// +earthRadius;\n        // camera move with speed\n       // ro.xz += 1.*hash33(vec3(floor(8.*iTime))).xy; \n \n\t\n\t\tfCoord = fragCoord.xy;\n        rd = RD(ro, cp);\n  \n \n  \t  \tt0 = iSphere(ro, rd, vec4(moonCenter, moonRadius/2.));\n   \t \tif(t0.x > 0.0)\n    \t{\n            vec3 p = ro + rd*t0.x, n = normalize(moonCenter - p);\n            float e = dot(n,-sunDir);\n    \t\tcol.xyz = vec3(sqrt(e));\n    \t}\n    }\n    \n    \n    ctot = vec3(0);\n \n    */\n    float st = -1.;\n    //  \n    float a=0., tn, tf, tt0 = time;\n    for (int ii=0; ii<AA; ii++) {\n    for (int jj=0; jj<AA; jj++) {\n        \n            \n        time = tt0 + hash31(fragCoord.xyx*rd+2000.*float(ii+1111*jj))/100.;\n\n            \n    vec2 \n\t\tobj, \n\t\tmouse = (iMouse.xy/iResolution.xy)*6.28,\n\t\tq = fragCoord.xy/iResolution.xy;\n    vec3 \n\t\tro = camPos(time),\n        rd, cp = lookAt(time, ro);\n\t\n\t\tfCoord = fragCoord.xy+vec2(ii,jj)/(float(AA));\n        rd = RD(ro, cp);\n  \n        if (box(ro, rd, vec3(2.7,1e30,2.6), tn, tf)) {\n        \n        handmat = Rot(-.5);\n\n\t\n// - Animation -----------------------------------------------\n\t//man.arm_right  = man.arm_left  = .5; \n\tman.roll  = man.leg_right;\n    \n    man.pos = vec3(0,-.77,0);\n//------------------------------------------------------------\n         \n    // Camera origin (o) and direction (d)\n\n        // Ray marching\n\t\tfloat m=0.;\n        float t=tn,d=1.;\n\t\ttf = min(MAX_DIST, tf);\n        for(int i=0;i<NB_ITER;i++){\n            if(t>tf || d<PRECISION) break;\n            obj = DE(ro+rd*t);\n            t += d=obj.x *.9;\n            m = obj.y;\n        }\n\n        // Render colors\n        if(t<tf){// if we hit a surface color it\n            ctot += vec4(Render(ro + rd*t, rd, t, m), 1.);\n    \t\tst = t;        \n        } else {\n            ctot += col;\n        } \n     \n \n        }\n        else {\n            ctot += col;\n    \t\t\n        }\n        \n      }\n    }\n    \n    ctot /= float(AA*AA);\n    \n\n    \n    \n    fragColor = ctot;\n\n\n       //-------------------------------------\n\t// velocity vectors (through depth reprojection)\n    //-------------------------------------\n    float vel = -1.0;\n    if( st>0.0 )\n    {\n        // old camera position\n        float oldTime = time - 1.0/30.0; // 1/30 of a second blur\n        vec3 oldRo = camPos(time);\n        vec3 oldTa = lookAt(time, oldRo);\n        //; float oldCr, oldFl;\n       // moveCamera( oldTime, oldRo, oldTa, oldCr, oldFl );\n        mat3 oldCam = setCamera( oldRo, oldTa );\n\n        // world spcae\n        vec3 wpos = ro + rd*st;\n        // camera space\n        vec3 cpos = vec3( dot( wpos - oldRo, oldCam[0] ),\n                          dot( wpos - oldRo, oldCam[1] ),\n                          dot( wpos - oldRo, oldCam[2] ) );\n        float oldFl = 12.;\n        // ndc space\n        vec2 npos = oldFl * cpos.xy / cpos.z;\n        // screen space\n        vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y/iResolution.x,1.0);\n\n\n        // compress velocity vector in a single float\n        vec2 uv = fragCoord/iResolution.xy;\n        spos = clamp( 0.5 + 0.5*(spos - uv)/0.25, 0.0, 1.0 );\n        vel = floor(spos.x*255.0) + floor(spos.y*255.0)*256.0;\n\t    fragColor = vec4( ctot.xyz, vel );\n    } else {\n\t\tfragColor = vec4( ctot.xyz, -1 );\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}