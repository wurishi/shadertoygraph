{"ver":"0.1","info":{"id":"wttSD7","date":"1581129713","viewed":128,"name":"glitchy mandelbulb","username":"makc","description":"I intend to continue glitching this code further sometimes until it is prettier, or I am bored of doing so... if you have an interesting mutation for me to try, leave the comment I guess","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["mandelbulb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ruined version of https://www.shadertoy.com/view/XsdXRs by Swax97\n#define BOUNDING_RADIUS 1.5\n\n#define COLOR1 vec3(1.0, 0.3, 0.0)\n#define COLOR2 vec3(0.0, 0.7, 1.0)\n#define BACKGROUND vec3(0.2, 0.8, 0.2)\n\n#define ir3 0.57735\n\nfloat mandelbulb(vec3 pos){\n    vec3 w = pos;\n    float dr = 1.0,r;\n    vec3 p,p2,p4;\n    float k1,k2,k3,k4,k5;\n\n    for (int i = 0; i < 10; i++){\n        r = dot(w, w);\n        if (r > 4.0) break;\n        dr =  pow(r, 3.5)*8.0*dr + 1.0;\n\n        p = w;\n        p2 = w * w;\n        p4 = p2 * p2;\n\n        k3 = p2.x + p2.z;\n        k2 = inversesqrt( k3*k3*k3*k3*k3*k3*k3 );\n        k1 = p4.x + p4.y + p4.z - 6.0 * dot(p2, vec3(p2.y, p2.z, -p2.x / 3.0));\n        k4 = p2.x - p2.y + p2.z;\n        k5 = (8.0 - k1)*p.y*k4*k1*k2;\n\n        w = pos + vec3(8.0*k5*p.x*p.z*(p2.x-p2.z)*(p4.x-6.0*p2.x*p2.z+p4.z),\n                       -16.0*p2.y*k3*k4*k4 + k1*k1,\n                       -k5*(p4.x*p4.x - 28.0*p4.x*p2.x*p2.z + \n                            70.0*p4.x*p4.z - 28.0*p2.x*p2.z*p4.z + p4.z*p4.z));\n    }\n    return log(r)*sqrt(r)/dr;\n}\n\nfloat dist(vec3 p) {\n    return 0.385*mandelbulb(p);\n}\n\nbool bounding(in vec3 ro, in vec3 rd){\n    float b = dot(rd,ro);\n    return dot(ro,ro) - b*b < BOUNDING_RADIUS * BOUNDING_RADIUS;\n}\n\nvec2 march(vec3 ro, vec3 rd){\nro.xyz = ro.zxy;\nrd.xyz = rd.zxy;\n    if (bounding(ro, rd)){\n        float t = 0.72, d;\n        for (int i = 0; i < 11; i++){\n            d = dist(ro + rd * t);\n            t += d;\n\n            if (d < 0.042) return vec2(t, d);\n            if (d > 0.4) return vec2(-1.0);\n        }\n    }\n\n    return vec2(-1.0);\n}\n\nvec3 normal(vec3 p){\n    const float eps = 0.005;\n    return normalize(vec3(dist(p+vec3(eps,0,0))-dist(p-vec3(eps,0,0)),\n                          dist(p+vec3(0,eps,0))-dist(p-vec3(0,eps,0)),\n                          dist(p+vec3(0,0,eps))-dist(p-vec3(0,0,eps))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float theta = iTime * 0.2;\n    mat2 rot = mat2(+cos(theta), -sin(theta),\n                    +sin(theta), +cos(theta));\n    mat2 rrot = mat2(+cos(theta), +sin(theta),\n                     -sin(theta), +cos(theta));\n    vec2 rxz = vec2(0.0, -1.8) * rot;\n    vec3 ro = vec3(rxz.x, sin(theta*1.61)*0.1, rxz.y);\n\n    //coordinates of pixel\n    vec2 uv = (iResolution.xy - 2.0 * fragCoord.xy) / iResolution.y;\n\n\n    vec3 rd = normalize(vec3(uv, 1.1));\n    rd.xz *= rot;\n\n    vec2 res = march(ro, rd);\n\n    if (res.x > 0.0){\n        vec3 end = ro + rd * res.x;\n\n        vec3 norm = normal(end-rd*0.001);\n\n        float ao = clamp((dist(end + norm * 0.02) - res.y) / 0.02, 0.0, 1.0);\n        norm.xz *= rrot;\n\n        float m = clamp(dot(end, end), 0.0, BOUNDING_RADIUS) / BOUNDING_RADIUS;\n        vec3 col = mix(COLOR1, COLOR2, m*m*m);\n\n        float d = max(dot(norm, vec3(-ir3)), 0.0);\n        vec3 light = col * ao + 0.2 * d + 0.4 * d*d*d*d*d*d*d*d;\n\n        fragColor = vec4(light, 1.0);\n    } else {\n        fragColor = vec4(BACKGROUND - length(uv) / 4.0, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}