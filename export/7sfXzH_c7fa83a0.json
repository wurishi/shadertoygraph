{"ver":"0.1","info":{"id":"7sfXzH","date":"1619648420","viewed":141,"name":"Relativistic Raymarching","username":"bgold","description":"Mess with the first few lines in the Common tab to change the amount of relativistic effects.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"wlsfzH","parentname":"Ray March test 2"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// some screen-space effects, most of the work is in Buffer A\n\nvoid mainImage( out vec4 f, in vec2 u)\n{\n    vec2 v = u/iResolution.xy;\n    f = texture(iChannel0, v);\n    // increase brightness\n    f *= 10.0;\n    \n#ifdef SPIKES\n    // diffraction spikes?\n    float b = 0.0;\n    for (int i=-200; i<=200; i+=1) {\n        b += smoothstep(1., 6., length(texture(iChannel0, (u+vec2(i,0)/1.8)/iResolution.xy).xyz))/ float(abs(i)+5);\n        b += smoothstep(1., 6., length(texture(iChannel0, (u+vec2(0,i))/iResolution.xy).xyz))/ float(abs(i)+5);\n    }\n    f += b;\n#endif\n    \n    // vignette\n    f *= smoothstep(0.6, 0.35, max(abs(v.x-0.5), abs(v.y-0.5)));\n    \n    // gamma?\n    f = vec4(pow(f.xyz, vec3(0.8)), 1.0);\n    f = clamp(f, 0., 1.);\n   \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// RATE is the speed of the marker cubes toward the camera, as a fraction of the speed of light\n// LRATE is the speed of the light sources away from the camera, as a fraction of the speed of light\n// LIGHTSPEED is the speed of light in GL units, lower values make it easier to see what's going on\n#define RATE 0.90\n#define LRATE 0.99\n#define LIGHTSPEED 1.0\n\n// this turns on Lorentz contraction\n#define USEGAMMA\n\n// number of lights\n#define NL 2\n\n// ray marching and camera params\n#define STEPS 1000\n#define SUBSTEP 2\n#define MAXDIST 200.0\n#define FOV 85.0\n\n// color definition for marker cubes\n#define AMB     0.0\n#define ACOLOR  vec3(0.5, 0.5, 1.0)\n#define DIFF    0.8\n#define DCOLOR  vec3(1.0, 0.8, 0.1)\n#define SPEC    1.0\n#define SCOLOR  vec3(1.0, 1.0, 1.0) \n#define SEXP    100.0\n#define DARKR   50.0\n#define DARKEXP 2.0\n\n// uncomment this for a lame attempt at diffraction spikes\n//#define SPIKES\n\n//////////////////////////////////////////////////////////\n#define ZERO3   vec3(0)\n#define PI      3.1415926536\n#define DEG45   (45.0 * PI/180.0)\n\n#define ID_NOTHING 0\n#define ID_LIGHT 1\n#define ID_MARKER 2\n\nconst float mrate = RATE * LIGHTSPEED;\nconst float lrate = LRATE * LIGHTSPEED;\n\n#ifdef USEGAMMA\nconst float gamma = pow(1.0 - RATE*RATE, -0.5);\nconst float lgamma = pow(1.0 - LRATE*LRATE, -0.5);\n#else\nconst float gamma = 1.0;\nconst float lgamma = 1.0;\n#endif\n\nstruct ObjHit {\n    vec4 norm;\n    int id;};\n\nvec3 rotx(in vec3 r, float a) {\n    return vec3(r.x, cos(a)*r.y+sin(a)*r.z, cos(a)*r.z-sin(a)*r.y); }\n\nvec3 roty(in vec3 r, float a) {\n    return vec3(cos(a)*r.x+sin(a)*r.z, r.y, cos(a)*r.z-sin(a)*r.x); }\n\nvec3 dubstep(in float e, in vec3 x) {\n    return step(e, x) - step(e, -x); }\n\nvec4 merge(in vec4 a, in vec4 b) {\n    float d = min(a.w, b.w);\n    vec3 norm = (a.w < b.w) ? a.xyz : b.xyz;\n    return vec4(norm, d);}\n    \nvec4 dist_s(in vec3 x, in vec3 s, in float rad) { \n    vec3 norm = normalize(x-s);\n    float d = distance(x,s) - rad;\n    return vec4(norm, d); }\n\nvec4 dist_c(in vec3 x, in vec3 c, in float side) { \n\tvec3 norm = (x-c) / side;\n    norm = dubstep(1., norm);    \n    vec3 dv = max((x-c)-side, -side-(x-c));\n    float d = max(max(dv.x,dv.y),dv.z);\n    return vec4(norm,d); }\n        \nvec4 dist_x(in vec3 x, in vec3 c, in float side) {\n    return merge(\n        dist_c(x, c, side),\n        dist_s(x, c, side*1.3));}\n\nfloat cdot(in vec3 x, in vec3 y) {\n    return clamp(dot(x,y), 0., 1.);}    ","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3[NL] lightpos(in float t) {\n    return vec3[NL](vec3(0., -2., mod(-t*lrate,200.0)-100.0), \n                       vec3(0., 2., mod(-t*lrate+100.0,200.0)-100.0));}\n                                           \nfloat lightblink(in float t) { // not sure if blinking is entirely working properly\n    return step(0.0, mod(t,1.0))*0.9+1e-4;}                 \n                                   \nObjHit estdist(in vec3 x, in float t) {\n    vec3 xform = x*vec3(1,1,gamma) + vec3(0,0, -mrate*gamma * (iTime-t));\n    vec3 c = vec3(1.,1.,1.)*5.;\n    xform = mod(xform, c) - 0.5*c;\n    vec4 obj1 = dist_x(xform, vec3(0,0,0), 0.5);\n    vec4 obj2 = dist_s(x, lightpos(iTime-t)[0], 0.1);\n    for (int i=1; i<NL; i++) {\n        obj2 = merge(obj2, dist_s(x, lightpos(iTime-t)[i], 0.1));\n    }\n    return ObjHit(merge(obj1,obj2), obj1.w < obj2.w ? ID_MARKER : ID_LIGHT);\n}\n\nObjHit march(in vec3 start, in vec3 dir) {\n    vec3 x = start;\n    ObjHit rval;\n    vec3 norm;\n    for (int i=0; i<STEPS*SUBSTEP; i++) {\n        rval = estdist(x, distance(start,x)/LIGHTSPEED);\n        if (rval.norm.w < 0.001) break;       \n\t\tif (length(x-start) > MAXDIST) {\n            return ObjHit(vec4(0), ID_NOTHING);\n        }\n        x = x + rval.norm.w/float(SUBSTEP)/gamma * dir;\n    }\n    float dist = distance(start,x);\n    norm = rval.norm.xyz;    \n    return ObjHit(vec4(norm,dist), rval.id);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 ar = vec2(iResolution.x/iResolution.y, 1.0);\n    vec2 uv = (fragCoord/iResolution.xy - vec2(0.5,0.5))*2.0 * ar;\n    \n    vec3 campos = vec3(0, 0, 1.0 / tan(FOV / ar.x / 2.0 / 180.0 * PI));\n    vec3 camdir = normalize(vec3(uv,0)-campos);\n    vec3 camvel = camdir * LIGHTSPEED;\n    \n    ObjHit m = march(campos, camdir);\n    \n    switch (m.id) {\n    case ID_NOTHING:\n        fragColor = vec4(0);\n        break;\n    case ID_LIGHT:\n        fragColor = vec4(1e2*pow(m.norm.w/10.0, -2.0)) * lightblink(iTime-m.norm.w/LIGHTSPEED)  ;\n        break;\n    case ID_MARKER:\n        vec3 surface = campos + m.norm.w * camdir;\n        float ts = m.norm.w / LIGHTSPEED;\n        vec3 normdistort = vec3(0);\n        vec3 norm = normalize(m.norm.xyz + normdistort);\n    \n        vec3 diffuse = vec3(0);\n        vec3 spec = vec3(0);\n        vec3 ambient = AMB * ACOLOR;\n        \n        float doppler = 1.0 / (gamma * (1.0 + RATE * (surface.z-campos.z)/m.norm.w));\n \n        for (int i=0; i<NL; i++) {\n            float ld = distance(surface, lightpos(iTime-ts)[i]);\n            float ldpara = surface.z - lightpos(iTime-ts)[i].z;\n            float vldp = lrate * ldpara;\n            float sqdiff = LIGHTSPEED * LIGHTSPEED - lrate * lrate;\n            float tl = vldp + sqrt(vldp * vldp + ld*ld*sqdiff);\n            tl /= sqdiff;\n            float lightdist = tl * LIGHTSPEED;\n            float lightdistfalloff = 0.2*pow(lightdist/10.0, -2.0);\n            lightdistfalloff *= lightblink(iTime-ts-tl );\n            \n            vec3 lightdir = vec3(0);\n            lightdir.z = -ldpara/tl - lrate;\n            lightdir.xy = (lightpos(iTime-ts)[i].xy - surface.xy)/tl;\n            lightdir = normalize(lightdir);\n            vec3 halfdir = normalize(lightdir - camdir);\n            vec3 reflectdir = reflect(lightdir, norm);\n            \n            diffuse += DIFF * DCOLOR \n               * normalize(pow(vec3(0.5,1.0,1.5), vec3(doppler-1.0))) // not at all a realistic redshift, put that in later\n               * cdot(norm, lightdir) * lightdistfalloff;\n            spec    += SPEC * SCOLOR * pow( cdot(camdir, reflectdir), SEXP) * lightdistfalloff;\n        }\n    \n        float darkdist = pow(1.0 + m.norm.w / DARKR, -DARKEXP);\n     \n        vec3 rawcolor = darkdist * (diffuse + spec + ambient);\n        \n        fragColor = clamp(vec4(rawcolor, 1.0), 0.0, 1e6);\n    }\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}