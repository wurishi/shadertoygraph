{"ver":"0.1","info":{"id":"MX3Xzs","date":"1719493063","viewed":8,"name":"Splash circles animation","username":"mikssx","description":"two circles animation","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["circles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Gradient colours\nconst vec3 COL1 = vec3(1.0, 0.867, 0.792); // #FFDDCA\nconst vec3 COL3 = vec3(1.0, 0.153, 0.153); // #FF2727\nconst vec3 COL2 = vec3(1.0, 0.686, 0.686); // #FFAFAF\nconst vec3 COL4 = vec3(0.878, 0.027, 0.4); // #E00766\n\n// Edge smoothing\nconst float SMOOTHING = 128.0;\n\n// Rotation and size parameters\nconst float PHASE1_DURATION = 1.; // Duration for phase 1\nconst float PHASE2_DURATION = 1.; // Duration for phase 2\nconst float PHASE3_DURATION = 1.; // Duration for phase 3\nconst float PHASE4_DURATION = 1.; // Duration for phase 4\n\nconst float TOTAL_DURATION = PHASE1_DURATION + PHASE2_DURATION + PHASE3_DURATION + PHASE4_DURATION;\n\n// Rotation angles\nconst float ROTATION_PHASE1 = radians(70.0); // 70 degrees\nconst float ROTATION_PHASE2 = radians(-50.0); // -50 degrees\nconst float ROTATION_PHASE4 = radians(40.0); // 40 degrees for phase 4\n\n\n// Ease-in-out cubic function\nfloat easeInOutCubic(float t) {\n    return t < 0.5 ? 4.0 * t * t * t : (t - 1.0) * (2.0 * t - 2.0) * (2.0 * t - 2.0) + 1.0;\n}\n\nfloat Circle(vec2 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nvec3 getGradientColor(float t) {\n    // Determine the color based on the distance t\n     if (t < 0.5) {\n        return mix(COL2, COL3, smoothstep(0., 0.6, t));\n    } else {\n        return mix(COL3, COL4, smoothstep(0.5, 1.0, t));\n    }\n}\n\nvoid mainImage(out vec4 fragColour, in vec2 fragCoord)\n{\n    // Background color\n    vec3 backgroundColor = vec3(0.071, 0.071, 0.071); // #121212\n    \n    // Calculate aspect ratio\n    float aspect = 1.0 / min(iResolution.x, iResolution.y);\n    \n    // Aspect ratio corrected UV coordinates\n    vec2 uv = fragCoord * aspect;\n    \n    // Normalized position from -0.5 to 0.5\n    vec2 pos = uv - 0.5 * aspect * iResolution.xy;\n\n    float time = mod(iTime, TOTAL_DURATION);\n\n    float rotationAngle;\n    float sizeFactor;\n\n    if (time < PHASE1_DURATION) {\n        // Phase 1: Clockwise rotation and getting smaller\n        float t = time / PHASE1_DURATION;\n        float easedT = easeInOutCubic(t);\n        rotationAngle = ROTATION_PHASE1 * easedT;\n        sizeFactor = mix(1.0, 0.7, easedT);\n    } else if (time < PHASE1_DURATION + PHASE2_DURATION) {\n        // Phase 2: Counterclockwise rotation and getting bigger to 150%\n        float t = (time - PHASE1_DURATION) / PHASE2_DURATION;\n        float easedT = easeInOutCubic(t);\n        rotationAngle = ROTATION_PHASE1 + ROTATION_PHASE2 * easedT;\n        sizeFactor = mix(0.7, 1.5, easedT);\n    } else if (time < PHASE1_DURATION + PHASE2_DURATION + PHASE3_DURATION) {\n        // Phase 3: Slowly getting bigger to 200% with wave interference\n        float t = (time - PHASE1_DURATION - PHASE2_DURATION) / PHASE3_DURATION;\n        rotationAngle = ROTATION_PHASE1 + ROTATION_PHASE2;\n        \n        // Breathing effect\n        float breathingCycles = 2.0;\n        float breathingT = sin(t * breathingCycles * 3.14159) * 0.15 + 1.65;\n        sizeFactor = mix(1.5, breathingT, t);\n    } else {\n        // Phase 4: 40 degrees clockwise rotation and getting smaller from phase 3 size to 0.5\n        float t = (time - PHASE1_DURATION - PHASE2_DURATION - PHASE3_DURATION) / PHASE4_DURATION;\n        float easedT = easeInOutCubic(t);\n        \n        // The final size at the end of phase 3\n        float finalPhase3Size = sin(2.0 * 3.14159) * 0.15 + 1.65;\n        sizeFactor = mix(finalPhase3Size, 0.5, easedT);\n        \n        rotationAngle = ROTATION_PHASE1 + ROTATION_PHASE2 + ROTATION_PHASE4 * easedT;\n    }\n\n    // Apply rotation\n    float cosT = cos(rotationAngle);\n    float sinT = sin(rotationAngle);\n    mat2 rotationMatrix = mat2(cosT, -sinT, sinT, cosT);\n    pos = rotationMatrix * pos;\n\n    float radius = 0.35 * sizeFactor;\n\n    // Position for the first circle (top right)\n    vec2 pos1 = pos - vec2(0.25 * iResolution.x, -0.25 * iResolution.y) * aspect;\n    float c1 = Circle(pos1, radius);\n    float s1 = SMOOTHING * aspect;\n    float smoothedC1 = smoothstep(s1, -s1, c1);\n    float dist1 = length(pos1) / radius;\n    vec3 color1 = getGradientColor(dist1);\n\n    // Position for the second circle (bottom left)\n    vec2 pos2 = pos - vec2(-0.25 * iResolution.x, 0.25 * iResolution.y) * aspect;\n    float c2 = Circle(pos2, radius);\n    float s2 = SMOOTHING * aspect;\n    float smoothedC2 = smoothstep(s2, -s2, c2);\n    float dist2 = length(pos2) / radius;\n    vec3 color2 = getGradientColor(dist2);\n    \n    // Combine both circles' colors and alpha values\n    vec3 combinedColor = color1 * smoothedC1 + color2 * smoothedC2;\n    float combinedAlpha = max(smoothedC1, smoothedC2);\n\n    // Mix the combined color with the background color\n    vec3 finalColor = mix(backgroundColor, combinedColor, combinedAlpha);\n\n    // Set the fragment color\n    fragColour.rgb = finalColor;\n    fragColour.a = 1.0; // Full opacity\n}\n","name":"Image","description":"","type":"image"}]}