{"ver":"0.1","info":{"id":"XsByWW","date":"1492582681","viewed":165,"name":"Grapprog Finals","username":"Jops","description":"ye","likes":6,"published":1,"flags":64,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"MdBGDt","filepath":"https://soundcloud.com/ujico/pixelgalaxy","previewfilepath":"https://soundcloud.com/ujico/pixelgalaxy","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[],"code":"#define PATTERN 6\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\nfloat rand(vec2 uv)\n{\n    //return fract(sin(dot(uv, vec2(12.9898,78.233)))*10000.*iTime);\n\t//return fract(sin(dot(uv, iMouse.xy))*10000.);\n\t//return (fract(sin(dot(uv, vec2(12., 70.)))*100000.));\n    return (fract(sin(dot(uv, vec2(12., 70.)))*43758.5453123));\n}\n\n\nfloat createPoly(int corners, vec2 uv, vec2 pos, float rotate)\n{\n    uv-=pos;\n    //pos.x *= ratio;\n// Number of sides of your shape\n\tint N = corners;\n\n// Angle and radius from the current pixel\n\tfloat a = atan(uv.x,uv.y)+PI + rotate;\n\tfloat r = TWO_PI/float(N);\n  \n// Shaping function that modulate the distance\n    float dist = cos(floor(.5+a/r)*r-a)*length(uv);\n    \n    return dist;\n}\n\nfloat createRectangle(vec2 uv, vec2 pos, vec2 size)\n{\n   \n    \n    float testH = step(pos.x, uv.x ) - step(pos.x + (size.x), uv.x );\n    float testV = step(pos.y, uv.y ) - step(pos.y + (size.y), uv.y );\n    \n    return testV * testH;\n}\n\nfloat random (in vec2 uv) {\n    return fract(sin(dot(uv.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 uv) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 uv) {\n    // Initial values\n    float value = 0.0;\n    float amplitud = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitud * noise(uv);\n        uv *= 2.;\n        amplitud *= .5;\n    }\n    return value;\n}\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat createCircle(vec2 uv, vec2 pos, float rad)\n{\n    \n    float testV;\n    \n    testV = 1.-step(rad, distance(pos, uv));  \n    return testV;\n}\n//WOOD \n#if PATTERN == 1 \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n\t\n    \n    //uv *- 1.;\n    \n    float brightness = 1.;\n        \n    vec3 value = vec3(0.860, .806, .574);\n    \n    value *= brightness;\n    \n    float planks;\n    planks = abs(sin(uv.x*10.) +.1 );\n    planks = abs(floor(sin(uv.x * 20.) + .5) + .2);\n    value *= planks;\n    \n    vec3 colorA = vec3(.390, .265, .192);\n    vec3 colorB = vec3 (.930, .493, .502);\n    vec3 colorC = vec3(.0, .0, 1.);\n    \n    float mask = step(0.5, uv.x) ;\n    //mask = sin(uv.x*1.0) ;\n    mask = createRectangle(uv, vec2(0.5 * ratio, 0.5), vec2(0.2, 0.2));\n    value = mix(value, colorA, vec3(fbm(uv.xx * 10.)));  \n    \n    //mask = createRectangle(uv, vec2(0.5 * ratio * sin(iTime) + .59, 0.5), vec2(0.2, 0.2));\n    //value *= mix(value, colorB, vec3(fbm(uv.xx * 10.)));\n    \n   \t\n    value -= (noise(uv*vec2(500., 14.) / noise(uv*vec2(1000., 64.) )) * .2);\n    value -= vec3((snoise(uv*vec2(400., 3.)) - snoise(uv*vec2(14., 1.)))) * .04;\n    value -= vec3((snoise(uv*vec2(4000., 3.)) - snoise(uv*vec2(1400., 1.)))) * .01;\n        \n    //value = vec3(snoise(uv*vec2(400., 3.)));\n    \n    //vec3 stains = vec3(fbm((uv*3.)*1.))*.40;\n    //value = mix(value, vec3(0.860, .806, .574) * -.01,  (smoothstep(.08, .11, stains) - smoothstep(.11, .14, stains)) * .4);\n    \n    fragColor = vec4(vec3(value),1.0);\n    \n    \n}\n\n//CLOUD\n#elif PATTERN == 2\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    \n    float offset = noise(uv * 8. + iTime) * .2;\n    vec3 colorA = vec3(.0, .0, .36);\n    vec3 colorB = vec3(.3, .0, .0);\n    vec3 colorC = vec3(.755,.755,.755);\n    vec3 value = colorC;\n    float wave = sin(iTime*.8);\n    \n    //vec3 fbm = vec3(fbm(uv));\n    vec3 cloud = vec3(fbm((uv * 4. + iTime / 2.)*1.))*2.;\n    \n   \t//value = fbm + offset;\n    //value *= cloud;\n    //value = mix(value, vec3(0.860, .806, .574) * -.01,  (smoothstep(.08, .11, cloud) - smoothstep(.11, .14, cloud)) * .4);\n   \tvalue = mix(colorA, colorC, smoothstep(.9,.5,cloud) - smoothstep(1.,.2, cloud) *.1 ); \n    value += .1;\n\tfragColor = vec4(vec3(value),1.0);\n}\n\n#elif PATTERN == 3\n//WATER\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    \n    float offset = noise(uv * 8. + iTime) * .2;\n    float wave = sin(iTime*.8);\n    \n    vec2 water = vec2(fbm(uv + offset * 1.5 * wave) * .1);\n\n    \n    fragColor = texture(iChannel0, uv + water);\n    \n}\n\n#elif PATTERN == 4\n//Concrete\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    vec3 colorA = vec3(.211,.211,.211); // Dark Grey\n    vec3 colorB = vec3(.469,.469,.469); // Light Gray\n    \n    vec3 roughness = (vec3(fbm(((uv * 10.))*2.))*1.);\n    \n\t  \n    float offset = noise(((uv * 1.)) * 5.);\n    float wave = sin(iTime*.8);\n    \n    float concrete = (fbm(uv  * 2.5) * .6);\n    \n    vec3 value = colorA;\n    \n    //value *= abs(floor(sin(uv.x + fbm * 20.) + .2) + .1);\n    value *= abs(sin(uv.x + concrete *10.) +.3 );\n    \n    vec3 color = mix(colorB, colorA, roughness);\n   \t\n  \tvalue += color; \n   \t\n    value -= (noise(uv*vec2(500., 14.) / noise(uv*vec2(1000., 64.) )) * .2);\n    value -= vec3((rand(uv*vec2(10., 3.)) - rand(uv*vec2(14., 1.)))) * .1;\n    \n   \tvalue -= vec3((snoise(uv*vec2(4000., 3.)) - snoise(uv*vec2(1400., 1.)))) * .01;\n        \n    fragColor = vec4(vec3(value),1.0);\n    \n}\n#elif PATTERN == 5\n//Lava\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    vec3 colorA = vec3(.955,.155,.155); // Red\n    vec3 colorB = vec3(.955,.369,.0); // Yellow\n    \n    float offset = noise(uv * 8. + iTime) * .2;\n    float wave = sin(iTime*.8);\n    \n  \tfloat lava = (fbm(uv  * 2.5 + iTime /6.) * .6);\n    float test = abs(sin(uv.x + lava *100. + iTime) +.3 );\n    vec3 value = colorB;\n    value *= abs(sin(uv.x + lava *100. + iTime) +.3 );\n    value = mix(value, colorB , offset) + mix(value, colorA , offset) ;\n    value *= mix(value, colorA , offset);\n\tvalue -= colorA * .5;\n    \n    //fragColor = texture(iChannel0, uv + fbm*10.) +.3 ;\n    fragColor = vec4(vec3(value),1.0);\n    \n}\n#elif PATTERN == 6\n//WAVE\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n\n    \n    float offset = noise(uv * 8. + iTime) * .2;\n    \n    vec3 colorA = vec3(.955,.155,.155); // Red\n    vec3 colorB = vec3(.955,.369,.0); // Yellow\n  \n    vec3 value = vec3(0.,0.,0.);\n   \n    \n    //float value = step(radius , dist);\n   \t\n    value +=  step(distance(vec2(0.5 * ratio,0.5), uv ), 0.2 * abs(sin(iTime * 5.))) - step(distance(uv , vec2(0.5 * ratio, 0.5) ) , 0.16 * abs(sin(iTime * 5.)));\n    value = mix(value , colorA, value);\n\tvalue +=  step(distance(vec2(0.5 * ratio,0.5), uv ), 0.3 * abs(sin(iTime * 5.))) - step(distance(uv, vec2(0.5 * ratio, 0.5) ) , 0.26 * abs(sin(iTime * 5.)));\n    value = mix(value, colorB, value);\n    value +=  step(distance(vec2(0.5* ratio,0.5), abs(uv + offset) ), 0.2 + abs(fract(iTime *1.6 ))) - step(distance( abs(uv + offset) , vec2(0.5 * ratio, 0.5) ) , 0.16  + abs(fract(iTime * 1.6 )));\n    value = mix(value, colorA, value);\n    //LIGHT\n    value += smoothstep( distance(vec2(0.5 * ratio, 0.5), uv + offset), 0.001, 0.1 + abs(fract(iTime *1.6 ))) - smoothstep( distance(vec2(0.5 * ratio, 0.5), uv + offset), 0.0, 0.2 + abs(fract(iTime *1.6 ))) ;\n    value = mix(value, colorB, value);\n     value += .13;\n    \n    fragColor = vec4(vec3(value),1.0);\n    \n}\n#elif PATTERN == 7\n//SUNSET\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    float offset = noise(uv * 8. + iTime) * .2;\n    vec3 cloud = vec3(fbm((uv * 4. + iTime / 2.)*1.))*2.;\n    \n    vec3 colorA = vec3(.955,.155,.155); // Red\n    vec3 colorB = vec3(.955,.369,.0); // Yellow\n    vec3 colorC = vec3(.228,.128,.828) ;// Indigo\n    vec3 colorD = vec3(.0, .0, .36);\n    \n    vec3 sun; \n    sun =  vec3(smoothstep(distance(vec2(0.5 * ratio,0.5 * sin(iTime)), uv ),  .3, 0.2) * 2. );\n    \n   \t//vec3 value = sun;\n   \n   \n   \tvec3 value = mix(colorA * sin(iTime) , colorB * sin(iTime) , uv.y + .3);\n    value = mix(colorB  * sin(iTime), value, sun);\n    value = mix(value, (colorC ) + offset , uv.y - .3);\n  \n  \t\n    fragColor = vec4(vec3(value),1.0);\n}\t\n#elif PATTERN == 8\n//HUD\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    //uv.x *= ratio;\n    float offset = noise(uv * 8. + iTime) * .2;\n\tfloat offset2 = (fbm(uv  * 2.5 + iTime /6.) * .6);\n    \n    vec3 colorA = vec3(.955,.155,.155); // Red\n    vec3 colorB = vec3(.955,.369,.0); // Yellow\n    vec3 colorC = vec3(.228,.128,.828) ;// Indigo\n    vec3 colorD = vec3(.0, .0, .36);\n    \n   \n    \n   \t  //2d array\n    //uv *= 4.;    \n    //vec2 tileIdx = floor(uv);\n    //uv = fract(uv);\n    \n    \n    \n    uv.x *= ratio;    \n    vec2 origin = vec2(0.5*ratio, 0.5);\n    \n    uv -= origin;     \n   \t//uv *= scale(vec2(sin(iTime / 6.) * 6.35));\n    //uv *= rotate2d((sin(iTime / 6.) * 6.35));\n    uv += origin;   \n \t\n    vec2 pos = origin;\n    \n   float dist = distance(pos, uv )*2.;\n   \n    \n   \tuv -= pos;\n    float angle = atan(uv.y, uv.x);\n    //float test = 1.-abs(smoothstep(cos(8.*angle  + snoise(  vec2(iTime / 2. )) - snoise(  vec2(iTime * 2. )) ) - 1.6   , .3 ,cos(10.*dist)));\n   \t//float test = 1.-abs(smoothstep(cos(8.*angle  ) - 1.6   , .3 ,cos(10.*dist)));\n   \tfloat ring1 = abs( step(dist * floor(sin(12.* angle + snoise(vec2(iTime) ) ) + 2. ),  cos(9.*dist) ) );\n    float ring2 = abs( step(dist * floor(sin(12.* angle - sin(snoise(vec2(iTime) ) ) * 5. ) + 2.  ),  cos(15.*dist) ) );\n    float ring3 = abs( step(dist * floor(sin(16.* angle + sin(snoise(vec2(iTime * 2.) ) ) ) + 2.  ),  cos(7.*dist) ) );\n    //test += 1.-abs(smoothstep(cos(8.*angle  - snoise(  vec2(step(.2, uv) + iTime )) ) - 1.6   , .3 ,cos(2.*dist)));\n    \n    \n   \tvec3 value = colorD;\n    value = mix(value, colorB, uv.y );\n    value = mix(value, colorB , -smoothstep( distance(vec2(0.0), uv ), 0.3 ,0.4) -smoothstep( distance(vec2(0.), uv), 0.1,0.9) );\n \t//value = mix(value, colorA, colorC);\n \tvalue += ring1; \n    value += ring2;\n    value += ring3;\n    \n\tvalue = mix(value, colorA, colorC);\n  \n  \t\n    fragColor = vec4(vec3(value),1.0);\n}\n#endif","name":"Image","description":"","type":"image"}]}