{"ver":"0.1","info":{"id":"3sVfW3","date":"1608503623","viewed":83,"name":"Chess piece - Queen","username":"Atchafalaya","description":"After binging The Queen's Gambit, I though that it would be fun to model chess pieces with SDFs. Long live the queen.\nStill working on lighting and post-processing.\nFeel free to comment if you have any advice :)","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","chess"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define FOCAL 2.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - R.xy) / R.y;\n\n    vec2 angle = vec2(2.*iMouse.xy/R.xy - 1.) * vec2(3., -0.7);\n    angle.x += iTime;\n    mat3 rotCam = rot(angle);\n    vec3 ro = rotCam * vec3(0., 0., 4.5);\n    ro += vec3(-1., 0.4, -1.);\n    vec3 rd = rotCam * normalize(vec3(uv, -FOCAL));\n    \n    vec3 mainLight = normalize(vec3(1.));\n    \n    float t;\n    RMResult s = raymarch(ro, rd, t);\n    vec3 p = ro + t * rd;\n    vec3 normal = gradient(p);    \n\n    vec3 sky = texture(iChannel0, rd).xyz;\n    vec3 col;\n    if (s.id < 0.)\n    {\n        // skybox\n        col = sky;\n    }\n    else if (s.id < 1.)\n    {\n        // board\n        if (abs(p.x) > 8. || abs(p.z) > 8.)\n        {\n            vec3 n = abs(normal);\n            vec2 fetch;\n            fetch = n.x > n.y && n.x > n.z ? vec2(0.5 * p.z, p.y) :\n            \t    n.y > n.z ? \t\t\t vec2(p.x, p.z) * 0.5:\n            \t\t\t\t\t\t\t   \t vec2(0.5 * p.x, p.y);\n            col = texture(iChannel1, fetch).xyz;\n        }\n        else\n        {\n            vec2 ss = sin(0.5 * PI * p.xz);\n            col = sign(ss.x) * sign(ss.y) < 0. ? vec3(0.05) : vec3(0.9);\n            col *= max(0.2, dot(normal, mainLight));\n        }\n    }\n    else if (s.id < 2.)\n    {\n        // chess piece\n        col = vec3(0.95, 0.95, 0.85) * max(0.2, dot(normal, mainLight));\n        col += 0.1 * max(0.0, dot(normal, -mainLight));\n        col += 0.1 * vec3(0.7, 0.43, 0.3) * max(0., dot(normal, vec3(0., 1., 0.)));\n    }\n\n    col = pow(col, vec3(0.5));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define I_MAX 1024\n#define FAR 1000.\n#define EPS 0.01\n#define PI 3.141592653589793\n\n// ~~~~~~~~ CAMERA ~~~~~~~~\nmat3 rot(vec2 angle)\n{\n    vec2 cc = cos(angle);\n    vec2 ss = sin(angle);\n    return mat3(vec3(cc.x      , 0.  , ss.x      ),\n\t\t\t\tvec3(ss.x*ss.y , cc.y, -ss.y*cc.x),\n                vec3(-cc.y*ss.x, ss.y, cc.x*cc.y ));\n}\n\n// ~~~~~~~~ SDFs and operations ~~~~~~~~\n// SDFs from iq's website https://iquilezles.org/articles/distfunctions\nfloat sdSphere(vec3 o, float r, vec3 p)\n{\n    return length(p - o) - r;\n}\n\nfloat sdBox(vec3 b, vec3 p)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundedBox(vec3 b, float r, vec3 p)\n{\n\treturn sdBox(b, p) - r;\n}\n\nfloat sdHPlane(float h, vec3 p)\n{\n    return p.y - h;\n}\n\nfloat sdCappedCylinder(float h, float r, vec3 p)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid(vec3 r, vec3 p)\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdTorus(vec2 t, vec3 p)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdRoundCone(vec3 a, vec3 b, float r1, float r2, vec3 p)\n{\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    vec3 x =  pa*l2 - ba*y;\n    float x2 = dot(x, x);\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdCone(vec2 c, float h, vec3 p)\n{\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat smax(float a, float b, float k)\n{\n    k *= 1.4;\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*h/(6.0*k*k);\n}\n\n// ~~~~~~~~ Ray-marching algorithm ~~~~~~~~\nstruct RMResult{\n  \tfloat dist;\n    float id;\n};\n\nRMResult map(vec3 p)\n{\n    float d = FAR;\n    float id = -1.;\n    \n    {// board\n        float d0 = sdRoundedBox(vec3(8.2, 0.35, 8.2), 0.1, p - vec3(0., -1.5, 0.));\n        if (d0 < d)\n        {\n            d = d0;\n            id = 0.5;\n        }\n    }\n    {// queen\n\t\tp += vec3(1., 0., 1.);\n        // body\n        vec3 p0 = p - vec3(0., 0.5, 0.);\n        float r = 0.28 + pow(0.4 - p0.y, 2.) / 6.;\n        float d0 = sdCappedCylinder(1.5, r, p0) - 0.02;\n        // head\n        vec3 p1 = p - vec3(0., 1.9, 0.);\n        float d1 = sdCappedCylinder(0.2, r - 0.1, p1);\n        d0 = smax(d0, -d1, 0.03);\n        vec3 p2 = p  - vec3(0., 2.05, 0.);\n        float a = mod(atan(p2.z, p2.x) + PI / 8., PI / 4.) - PI / 8.;\n        float l = length(vec2(p2.x, p2.z));\n        p2 = vec3(p2.y, l * cos(a), l * sin(a));\n        float d2 = sdCappedCylinder(0.6, 0.12, p2);\n        d0 = smax(d0, -d2, 0.07);\n        vec3 p3 = p - vec3(0., 2.15, 0.);\n        float d3 = sdCone(vec2(sin(PI / 5.), cos(PI / 5.)), 0.22, p3);\n        d0 = smin(d0, d3, 0.05);\n        float d4 = sdSphere(vec3(0., 2.18, 0.), 0.09, p);\n        d0 = smin(d0, d4, 0.03);\n        vec3 p5 = p - vec3(0., 1.4, 0.);\n        float d5 = sdEllipsoid(vec3(0.5, 0.07, 0.5), p5);\n        d0 = smin(d0, d5, 0.03);\n        vec3 p6 = p - vec3(0., 1.51, 0.);\n        float d6 = sdEllipsoid(vec3(0.42, 0.07, 0.42), p6);\n        d0 = smin(d0, d6, 0.03);\n        // base\n        vec3 p7 = p - vec3(0., -1., 0.);\n        float d7 = sdTorus(vec2(0.43, 0.5), p7);\n        d7 = max(d7, -sdHPlane(0., p7));\n        d0 = smin(d0, d7, 0.05);\n        float d8 = sdEllipsoid(vec3(0.77, 0.08, 0.77), p - vec3(0., -0.55, 0.));\n        d0 = smin(d0, d8, 0.05);\n        // stripes\n        float d9 = sdTorus(vec2(0.586, 0.01), p - vec3(0., -0.425, 0.));\n        d0 = smax(d0, -d9, 0.05);\n        float d10 = sdTorus(vec2(0.553, 0.01), p - vec3(0., -0.345, 0.));\n        d0 = smax(d0, -d10, 0.05);\n        if (d0 < d)\n        {\n            d = d0;\n            id = 1.5;\n        }\n    }\n    \n    return RMResult(d, id);\n}\n\nvec3 gradient( vec3 p )\n{\n    float h = EPS * EPS;\n    vec2 k = vec2(1,-1);\n    return normalize( k.xyy * map(p + k.xyy * h).dist + \n                      k.yyx * map(p + k.yyx * h).dist + \n                      k.yxy * map(p + k.yxy * h).dist + \n                      k.xxx * map(p + k.xxx * h).dist );\n}\n\nRMResult raymarch(vec3 ro, vec3 rd, out float t)\n{\n\tt = 0.;\n    vec3 p = ro + t * rd;\n    RMResult s = map(p);\n    float isInside = sign(s.dist);\n    for(int i = 0; i < I_MAX; i++)\n    {\n        float inc = isInside * s.dist;\n        if (t + inc < FAR && abs(s.dist) > EPS) \n        {\n\t\t\tt += inc;\n\t        p = ro + t * rd;\n            s = map(p);\n        }\n        else\n        {\n            if (t + inc > FAR)\n            {\n               s.id = -1.;\n            }\n            break;\n        }\n    }\n    return s;\n}\n","name":"Common","description":"","type":"common"}]}