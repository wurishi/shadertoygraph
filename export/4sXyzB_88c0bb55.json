{"ver":"0.1","info":{"id":"4sXyzB","date":"1488606270","viewed":105,"name":"Waaaahhhh","username":"sea","description":"What I yelled when I got the rotation working, needs optimization.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["rotate","perlinnosie"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 hash (vec3 p)\n{\n    p = vec3(dot(p, vec3(189.0, 75.0, 121.0)), dot(p, vec3(122.0, 220.0, 62.0)), dot(p, vec3(34.0, 96.0, 162.0)));\n    return fract(sin(p) * 4328395.432885) * 2.0 - 1.0;\n}\n\nfloat perlin3 (vec3 p)\n{\n    vec3 lbb = floor(p);\n    vec3 rtf = ceil(p);\n    \n    vec3 ltb = vec3(lbb.x, rtf.y, lbb.z);\n    vec3 rbb = vec3(rtf.x, lbb.y, lbb.z);\n    vec3 rtb = vec3(rtf.x, rtf.y, lbb.z);\n    vec3 rbf = vec3(rtf.x, lbb.y, rtf.z);\n    vec3 lbf = vec3(lbb.x, lbb.y, rtf.z);\n    vec3 ltf = vec3(lbb.x, rtf.y, rtf.z);\n    \n    vec3 glbb = hash(lbb);\n    vec3 gltb = hash(ltb);\n    vec3 grbb = hash(rbb);\n    vec3 grtb = hash(rtb);\n    vec3 grbf = hash(rbf);\n    vec3 grtf = hash(rtf);\n    vec3 glbf = hash(lbf);\n    vec3 gltf = hash(ltf);\n    \n    vec3 dlbb = p - lbb;\n    vec3 dltb = p - ltb;\n    vec3 drbb = p - rbb;\n    vec3 drtb = p - rtb;\n    vec3 drbf = p - rbf;\n    vec3 drtf = p - rtf;\n    vec3 dlbf = p - lbf;\n    vec3 dltf = p - ltf;\n    \n    float d1 = dot(dlbb, glbb);\n    float d2 = dot(dltb, gltb);\n    float d3 = dot(drbb, grbb);\n    float d4 = dot(drtb, grtb);\n    float d5 = dot(drbf, grbf);\n    float d6 = dot(drtf, grtf);\n    float d7 = dot(dlbf, glbf);\n    float d8 = dot(dltf, gltf);\n    \n    p = mod(p, 1.0);\n    p = p * p * (3.0 - 2.0 * p);\n    \n    float x1 = mix(d1, d3, p.x);\n    float x2 = mix(d2, d4, p.x);\n    float x3 = mix(d7, d5, p.x);\n    float x4 = mix(d8, d6, p.x);\n    \n    float y1 = mix(x1, x2, p.y);\n    float y2 = mix(x3, x4, p.y);\n    \n    return mix(y1, y2, p.z);\n}\n\nvec3 rotate (vec3 p, vec3 r)\n{\n    r *= 3.1415926 / 180.0;\n    \n    mat4 pitch = mat4(\n    \t1.0, 0.0, 0.0, 0.0,\n        0.0, cos(r.x), -sin(r.x), 0.0,\n        0.0, sin(r.x), cos(r.x), 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n    \n    mat4 yaw = mat4(\n    \tcos(r.y), 0.0, -sin(r.y), 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        sin(r.y), 0.0, cos(r.y), 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n    \n    mat4 roll = mat4(\n    \tcos(r.z), -sin(r.z), 0.0, 0.0,\n        sin(r.z), cos(r.z), 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n    \n    return (vec4(p, 1.0) * pitch * yaw * roll).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 ws = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    vec3 ro = vec3(0.0, 1.0, -2.0);\n    vec3 rd = vec3(ws, 1.0);\n    \n    for (float i = 0.0; i < 20.0; i += 0.1) \n    {\n        vec3 p = ro + rd * i;\n        p = rotate(p, vec3(0.0, p.y * 3.6, p.z * 36.0 * cos(iTime * 0.1)));\n        float r = perlin3(vec3(p.x, 0.0, p.z + iTime * 1.0)) - 0.5;\n        if (p.y < r)\n        {\n            color = vec3(r + 0.5);\n            break;\n        }\n    }\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}