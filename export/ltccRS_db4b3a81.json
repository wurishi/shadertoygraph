{"ver":"0.1","info":{"id":"ltccRS","date":"1532982267","viewed":151,"name":"Waving Pearls","username":"LUplusplus","description":"A real-time ray tracer of a string of pearls.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//============================================================================\n// PROJECT ID: <your Project ID is an integer equal to 62 + group_no.>\n//\n// GROUP NUMBER:\n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// COMMENTS TO GRADER: \n//\n//============================================================================\n\n\n// FRAGMENT SHADER FOR SHADERTOY\n// Run this at https://www.shadertoy.com/new\n// See documentation at https://www.shadertoy.com/howto\n\n// Your browser must support WebGL 2.0.\n// Check your browser at http://webglreport.com/?v=2\n\n\n//============================================================================\n// Constants.\n//============================================================================\nconst int NUM_LIGHTS = 1;\nconst int NUM_MATERIALS = 4;\nconst int NUM_PLANES = 6;\nconst int NUM_SPHERES = 7;\nconst int NUM_BOXES = 1;\nconst float PI = 3.1415926535;\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.2, 0.6 );\n\n // Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * 3.1415926535 / 180.0; \n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 3;\n\n\n//============================================================================\n// Define new struct types.\n//============================================================================\n\nstruct Triangle_t {\n    vec3 A,B,C;     // Barycentric Coordinates\n    \n    // Arbitrary point P in triangle\n    // P = (1-beta-gamma)A + betaB + gammaC\n};\n\nstruct Box_t {\n    float xLen, yLen, zLen;     // Length, width and height\n    vec3 center;                // Center coordinates in world space\n    float xAngle, yAngle, zAngle;       // Rotation angles about 3 axes\n    vec3 vertices[8];           // Pre-compute 8 vertices to reduce cost\n    int materialID;\n};\n\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    vec3 k_t;\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0. \n    float m; \n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that on Slides 8 and 12 of \n// Lecture 11 (Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS { \n//                   I_a * k_a + \n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\nBox_t Box[NUM_BOXES];\n\n// In total, 12 vertex combinations of triangle\nivec3 TriIndices[12];\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitBoxVertices(int i)\n{\n    Box[i].vertices[0] = vec3(-0.5*Box[i].xLen, -0.5*Box[i].yLen, -0.5*Box[i].zLen);\n    Box[i].vertices[1] = vec3(0.5*Box[i].xLen, -0.5*Box[i].yLen, -0.5*Box[i].zLen);\n    Box[i].vertices[2] = vec3(0.5*Box[i].xLen, 0.5*Box[i].yLen, -0.5*Box[i].zLen);\n    Box[i].vertices[3] = vec3(-0.5*Box[i].xLen, 0.5*Box[i].yLen, -0.5*Box[i].zLen);\n    Box[i].vertices[4] = vec3(-0.5*Box[i].xLen, -0.5*Box[i].yLen, 0.5*Box[i].zLen);\n    Box[i].vertices[5] = vec3(0.5*Box[i].xLen, -0.5*Box[i].yLen, 0.5*Box[i].zLen);\n    Box[i].vertices[6] = vec3(0.5*Box[i].xLen, 0.5*Box[i].yLen, 0.5*Box[i].zLen);\n    Box[i].vertices[7] = vec3(-0.5*Box[i].xLen, 0.5*Box[i].yLen, 0.5*Box[i].zLen);  \n}\nvoid InitScene()\n{\n\n    TriIndices[0] = ivec3(1, 0, 2);\n    TriIndices[1] = ivec3(0, 3, 2);\n    TriIndices[2] = ivec3(4, 5, 7);\n    TriIndices[3] = ivec3(5, 6, 7);\n    TriIndices[4] = ivec3(0, 7, 3);\n    TriIndices[5] = ivec3(0, 4, 7);\n    TriIndices[6] = ivec3(1, 2, 6);\n    TriIndices[7] = ivec3(1, 6, 5);\n    TriIndices[8] = ivec3(0, 1, 4);\n    TriIndices[9] = ivec3(1, 5, 4);\n    TriIndices[10] = ivec3(2, 3, 7);\n    TriIndices[11] = ivec3(2, 7, 6);\n\n    // Horizontal plane.\n    Plane[0].A = -1.0;\n    Plane[0].B = 0.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 8.0;\n    Plane[0].materialID = 0;\n\n    // Vertical plane.\n    Plane[1].A = 1.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 0.0;\n    Plane[1].D = 8.0;\n    Plane[1].materialID = 0;\n    \n    // Vertical plane.\n    Plane[2].A = 0.0;\n    Plane[2].B = 0.0;\n    Plane[2].C = 1.0;\n    Plane[2].D = 8.0;\n    Plane[2].materialID = 0;\n    \n    // Vertical plane.\n    Plane[3].A = 0.0;\n    Plane[3].B = 1.0;\n    Plane[3].C = 0.0;\n    Plane[3].D = 0.0;\n    Plane[3].materialID = 1;\n    \n    Plane[4].A = 0.0;\n    Plane[4].B = -1.0;\n    Plane[4].C = 0.0;\n    Plane[4].D = 16.0;\n    Plane[4].materialID = 0;\n    \n    Plane[5].A = 0.0;\n    Plane[5].B = 0.0;\n    Plane[5].C = -1.0;\n    Plane[5].D = 8.0;\n    Plane[5].materialID = 0;\n    // Center bouncing sphere.\n    Sphere[0].center = vec3( 0.0, sin(4.0 * (iTime - (3.0 * PI / 12.0))) + 5.0, 0.0 );\n    Sphere[0].radius = 0.8;\n    Sphere[0].materialID = 2;\n\n    // Circling sphere.\n    Sphere[1].center = vec3( 1.8, sin(4.0 * (iTime - (4.0 * PI / 12.0))) + 5.0, 0.0 );\n    Sphere[1].radius = 0.5;\n    Sphere[1].materialID = 3;\n\n    Sphere[2].center = vec3( 3.2, sin(4.0 * (iTime - (5.0 * PI / 12.0))) + 5.0, 0.0 );\n    Sphere[2].radius = 0.4;\n    Sphere[2].materialID = 3;\n\n    Sphere[3].center = vec3( 4.4, sin(4.0 * (iTime - (6.0 * PI / 12.0))) + 5.0, 0.0 );\n    Sphere[3].radius = 0.3;\n    Sphere[3].materialID = 3;\n\n    Sphere[4].center = vec3( -1.8, sin(4.0 * (iTime - (2.0 * PI / 12.0))) + 5.0, 0.0 );\n    Sphere[4].radius = 0.5;\n    Sphere[4].materialID = 3;\n\n    Sphere[5].center = vec3( -3.2, sin(4.0 * (iTime - (PI / 12.0))) + 5.0, 0.0 );\n    Sphere[5].radius = 0.4;\n    Sphere[5].materialID = 3;\n\n    Sphere[6].center = vec3( -4.4, sin(4.0 * iTime) + 5.0, 0.0 );\n    Sphere[6].radius = 0.3;\n    Sphere[6].materialID = 3;\n\n    // Wall material.\n    Material[0].k_d = vec3( 0.59, 0.52, 0.3685 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 1.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].k_t = 0.5 * Material[0].k_d;\n    Material[0].n = 64.0;\n    Material[0].m = 64.0;\n    \n    // Floor material.\n    Material[1].k_d = vec3( 0.533, 0.484, 0.424 );\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 2.0 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].k_t = 2.0 * Material[1].k_d;\n    Material[1].n = 64.0;\n    Material[1].m = 64.0;\n\n    // Middle sphere material.\n    Material[2].k_d = vec3( 0.5, 0.8, 0.9 );\n    Material[2].k_a = 0.2 * Material[2].k_d;\n    Material[2].k_r = 1.0 * Material[2].k_d;\n    Material[2].k_rg = 0.5 * Material[2].k_r;\n    Material[2].k_t = 2.0 * Material[2].k_d;\n    Material[2].n = 64.0;\n    Material[2].m = 128.0;\n\n    // Little sphere material.\n    Material[3].k_d = vec3( 0.6, 0.8, 0.6 );\n    Material[3].k_a = 0.2 * Material[3].k_d;\n    Material[3].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[3].k_rg = 0.5 * Material[3].k_r;\n    Material[3].k_t = 2.0 * Material[3].k_d;\n    Material[3].n = 128.0;\n    Material[3].m = 32.0;\n\n    // Light 1.\n    Light[0].position = vec3( -4.0, 8.0, 0.0 );\n    //Light[0].I_a = vec3( 0.5, abs(sin(iTime) * cos(iTime)) , abs(cos(iTime)) );\n    Light[0].I_a = vec3( 0.1, 0.1 , 0.1 );\n    Light[0].I_source = vec3( 1.0, 1.0, 1.0 );\n\n    Box[0].center = vec3(0.0, (cos(4.0 * (iTime - (3.0 * PI / 12.0))) + 2.74)/2.0, 0.0);\n    Box[0].xLen = 1.6;\n    Box[0].yLen = cos(4.0 * (iTime - (3.0 * PI / 12.0))) + 2.74;\n    Box[0].zLen = 1.6;\n    Box[0].xAngle = 0.0;\n    Box[0].yAngle = 2.0 * PI * sin(0.15 * iTime);\n    Box[0].zAngle = 0.0;\n    InitBoxVertices(0);\n    Box[0].materialID = 2;\n     \n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection \n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the \n// smaller t, the position of the intersection (hitPos) and the normal \n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    // Generate temporary objects with 'test' prefix\n    Sphere_t testSphere = sph;\n    Ray_t testRay = ray;\n    \n    // Translate the temporary objects to sphere's local space\n    testRay.o = testRay.o - testSphere.center;\n    testSphere.center = vec3(0.0, 0.0, 0.0);\n    \n    // Components of the test quadratic equation\n    float a = 1.0;\n    float b = 2.0 * dot(testRay.d, testRay.o);\n    float c = dot(testRay.o, testRay.o) - dot(testSphere.radius, testSphere.radius);\n    \n    // Discriminant\n    float d = b * b - 4.0 * a * c;\n    \n    // No intersection\n    // Includes the case of tangency, when d = 0.0\n    if (d <= 0.0)\n        return false;\n    \n    // They have a intersection\n    float tMinor = (-b - sqrt(d)) / (2.0 * a);\n    float tMajor = (-b + sqrt(d)) / (2.0 * a);\n    \n    // Choose the minimal positive solution\n    float t0;\n    if (tMinor > tmin) {\n    \tt0 = tMinor;\n    /*} else if (tMajor > tmin) {\n        // tMinor <= 0 but tMajor > 0\n        t0 = tMajor;*/\n    } else {\n        // tMinor, tMajor <= 0\n     \treturn false;\n    }\n\n    // Hit position and normal vector\n    if ( tmin < t0 && t0 < tmax ) {\n        t = t0;\n        hitPos = ray.o + t * ray.d;\n        hitNormal = normalize(hitPos - sph.center);\n        return true;\n    } else {\n    \t// the \"epsilon\" problem\n        return false;\n    }\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    // Just used to cater for parameter list\n    float t;\n    vec3 hitPos, hitNormal;\n    \n    // Some redundant calculations of the precise hit position\n    // for keeping the consistency of the same code\n    return IntersectSphere(sph, ray, tmin, tmax, t, hitPos, hitNormal);\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow, \n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a + \n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\nmat3 RotateXMat(float a)\n{\n    return mat3(1.0, 0.0, 0.0, 0.0, cos(a), sin(a), 0.0, -sin(a), cos(a));\n}\nmat3 RotateYMat(float a)\n{\n    return mat3(cos(a), 0.0, -sin(a), 0.0, 1.0, 0.0, sin(a), 0.0, cos(a));\n}\nmat3 RotateZMat(float a)\n{\n    return mat3(cos(a), sin(a), 0.0,\n                -sin(a), cos(a), 0.0,\n                0.0, 0.0, 1.0);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a box and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectTriangle(in Triangle_t triangle, in Ray_t ray, in float tmin, in float tmax,\n    out float t, out vec3 hitPos, out vec3 hitNormal)\n{\n    // Equation w.r.t. beta, gamma and t\n    mat3 LeftMat = mat3(triangle.A - triangle.B, triangle.A - triangle.C, ray.d);\n    vec3 rightVec = vec3(triangle.A - ray.o);\n\n    vec3 solution = inverse(LeftMat) * rightVec;\n    float beta = solution.x;\n    float gamma = solution.y;\n    t = solution.z;\n\n    bool isHit = (beta + gamma < 1.0)\n        && (beta > 0.0) && (gamma > 0.0)\n        && (tmin < t && t < tmax);\n    \n    // No intersection\n    if ( !isHit )\n        return false;\n    \n    // t has been already updated\n    // ......\n    \n    // Hit Position\n    hitPos = ray.o + t * ray.d;\n    \n    // Hit Normal Vector\n    vec3 AB = triangle.B - triangle.A;\n    vec3 AC = triangle.C - triangle.A;\n    vec3 BC = triangle.C - triangle.B;\n    vec3 NormalA = cross(AB, AC);\n    vec3 NormalB = cross(AB, BC);\n    vec3 NormalC = cross(AC, BC);\n    hitNormal = normalize( (1.0-beta-gamma)*NormalA + beta*NormalB + gamma*NormalC );\n    \n    return true;\n}\n\nbool IntersectTriangle(in Triangle_t triangle, in Ray_t ray, in float tmin, in float tmax)\n{\n    float t;\n    vec3 hitPos, hitNormal;\n    \n    return IntersectTriangle(triangle, ray, tmin, tmax,\n        t, hitPos, hitNormal);\n}\n\nbool IntersectBox(in Box_t box, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal)\n{\n    // Generate temporary objects\n    Ray_t testRay = ray;\n    \n    // Rotation Matrix\n    mat3 rotationMat = RotateXMat(box.xAngle) * RotateYMat(box.yAngle) * RotateZMat(box.zAngle);\n    // Translation and rotation of points\n    testRay.o = inverse(rotationMat) * (ray.o - box.center);\n    // Rotation of vectors\n    testRay.d = normalize(inverse(rotationMat) * ray.d);\n    \n    bool hasHitSth = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    // int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    // Intersection detection for each triangle\n    for (int i = 0; i < 12; i++)\n    {\n        Triangle_t tempTriangle;\n        tempTriangle.A = box.vertices[TriIndices[i].x];\n        tempTriangle.B = box.vertices[TriIndices[i].y];\n        tempTriangle.C = box.vertices[TriIndices[i].z];\n        \n        // Actual intersection detection\n        temp_hasHit = IntersectTriangle(tempTriangle, testRay, tmin, tmax,\n            temp_t, temp_hitPos, temp_hitNormal);\n        \n        if (temp_hasHit)\n        {\n            hasHitSth = true;\n            \n            if (temp_t < nearest_t)\n            {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n            }\n        }\n    }\n    \n    if (hasHitSth) {\n        t = nearest_t;\n        \n        // Transform points to the world space\n        hitPos = box.center + rotationMat * nearest_hitPos;\n        \n        hitNormal = rotationMat * nearest_hitNormal;\n        \n        return true;\n    } else\n        return false;\n}\n\nbool IntersectBox(in Box_t box, in Ray_t ray, in float tmin, in float tmax)\n{\n    float t;\n    vec3 hitPos, hitNormal;\n    \n    return IntersectBox(box, ray, tmin, tmax,\n        t, hitPos, hitNormal);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray, \n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg,out vec3 k_t ) \n{\n    // Find whether and where the ray hits some object. \n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Try interesecting input ray with all the planes and spheres,\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    for (int i = 0; i < NUM_PLANES; i++)\n    {\n        temp_hasHit = IntersectPlane(Plane[i], ray, DEFAULT_TMIN, DEFAULT_TMAX,\n                                     temp_t, temp_hitPos, temp_hitNormal);\n        if (temp_hasHit)\n        {\n            hasHitSomething = true;\n            \n            if (temp_t < nearest_t)\n            {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Plane[i].materialID;\n            }\n        }   \n    }\n    \n    for (int i = 0; i < NUM_SPHERES; i++)\n    {\n        temp_hasHit = IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, DEFAULT_TMAX,\n                                     temp_t, temp_hitPos, temp_hitNormal);\n        if (temp_hasHit)\n        {\n            hasHitSomething = true;\n            \n            if (temp_t < nearest_t)\n            {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Sphere[i].materialID;\n            }\n        }\n    }\n    for (int i = 0; i < NUM_BOXES; i++)\n    {\n        temp_hasHit = IntersectBox(Box[i], ray, DEFAULT_TMIN, DEFAULT_TMAX,\n            temp_t, temp_hitPos, temp_hitNormal);\n\n        if (temp_hasHit)\n        {\n            hasHitSomething = true;\n\n            if (temp_t < nearest_t)\n            {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Box[i].materialID;\n            }\n        }\n    }\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Accumulate lighting from each light source on the nearest hit point. \n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres) between the \n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    for (int i = 0; i < NUM_LIGHTS; i++)\n    {\n        Ray_t shadowRay;\n        // ShadowRay points to the light source\n        // from the hit position of ray\n        shadowRay.o = nearest_hitPos;\n        shadowRay.d = normalize(Light[i].position - nearest_hitPos);\n        \n        for (int j = 0; j < NUM_PLANES; j++)\n        {\n            temp_hasHit = IntersectPlane(Plane[j], shadowRay,\n                DEFAULT_TMIN, distance(Light[i].position, nearest_hitPos));\n            if (temp_hasHit)\n                break;\n        }\n        if ( ! temp_hasHit )\n        {\n            for (int j = 0; j < NUM_SPHERES; j++)\n            {\n                temp_hasHit = IntersectSphere(Sphere[j], shadowRay,\n                    DEFAULT_TMIN, distance(Light[i].position, nearest_hitPos));\n                if (temp_hasHit)\n                    break;\n            }\n        }\n        if ( ! temp_hasHit )\n        {\n            // Check the boxes\n            for (int j = 0; j < NUM_BOXES; j++)\n            {\n                temp_hasHit = IntersectBox(Box[j], shadowRay,\n                    DEFAULT_TMIN, distance(Light[i].position, nearest_hitPos));\n                if (temp_hasHit)\n                    break;\n            }\n\n        }\n        // Light vector is a unit vector from hit point to the light source\n        vec3 L = shadowRay.d;\n        // Normal vector\n        vec3 N = nearest_hitNormal;\n        // View vector\n        vec3 V = -normalize(ray.d);\n        // shadowRay hits something\n        bool inShadow = temp_hasHit;\n        \n        I_local += PhongLighting(L, N, V, inShadow,\n            Material[nearest_hitMatID], Light[i]);\n    }\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n    k_t = Material[nearest_hitMatID].k_t;\n    return I_local;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    // Position the camera.\n    // vec3 cam_pos = vec3( 8.0 * sin(0.3 * iTime), 4.0, 8.0 * cos(0.3 * iTime) );\n    float cam_theta = 4.0 * PI * sin(0.1 * iTime);\n    float cam_radius = 2.0 + 3.0 / (2.0 * PI) * abs(cam_theta);\n    vec3 cam_pos = vec3( cam_radius*cos(cam_theta), 4.0, cam_radius*sin(cam_theta) );\n    vec3 cam_lookat = vec3( 0.0, 4.0, 0.0 );\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 0.5 );\n    vec3 compounded_k_t = vec3( 0.5 );\n    Ray_t nextRay_r = pRay;\n    Ray_t nextRay_t = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ ) \n    {\n        bool hasHit_r, hasHit_t;\n        vec3 hitPos_r, hitPos_t, hitNormal_r, hitNormal_t, k_rg1, k_t1, k_rg2, k_t2;\n        vec3 I_local_r = CastRay( nextRay_r, hasHit_r, hitPos_r, hitNormal_r, k_rg1, k_t1 );\n        vec3 I_local_t = CastRay( nextRay_t, hasHit_t, hitPos_t, hitNormal_t, k_rg2, k_t2 );\n        I_result += compounded_k_rg * I_local_r + compounded_k_t * I_local_t;\n\n        if ( !hasHit_r && !hasHit_t) break;\n\n        compounded_k_rg *= k_rg1;\n        compounded_k_t *= k_t2;\n        nextRay_r = Ray_t( hitPos_r, normalize( reflect(nextRay_r.d, hitNormal_r) ) );\n        nextRay_t = Ray_t( hitPos_t, normalize( refract(nextRay_t.d, hitNormal_t, 0.8) ) );\n    }\n    \n    fragColor = vec4( I_result, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}