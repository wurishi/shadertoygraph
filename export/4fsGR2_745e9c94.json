{"ver":"0.1","info":{"id":"4fsGR2","date":"1703277672","viewed":44,"name":"hacky cubemap dome master","username":"possan","description":"attempt at using textures for cubemap sides while doing dome master projection","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["cubemap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358979323846264338327\n\n// from https://www.shadertoy.com/view/XllGW4\n\nmat2 Rot2(float a ) {\n    float c = cos( a );\n    float s = sin( a );\n    return mat2( c, -s, s, c );\n}\n\nmat4 Rot4X(float a ) {\n    float c = cos( a );\n    float s = sin( a );\n    return mat4( 1, 0, 0, 0,\n                 0, c,-s, 0,\n                 0, s, c, 0,\n                 0, 0, 0, 1 );\n}\n\nmat4 Rot4Y(float a ) {\n    float c = cos( a );\n    float s = sin( a );\n    return mat4( c, 0, s, 0,\n                 0, 1, 0, 0,\n                -s, 0, c, 0,\n                 0, 0, 0, 1 );\n}\n\nmat4 Rot4Z(float a ) {\n    float c = cos( a );\n    float s = sin( a );\n    return mat4(\n        c,-s, 0, 0,\n        s, c, 0, 0,\n        0, 0, 1, 0,\n        0, 0, 0, 1\n     );\n}\n\n// from: https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection.html\n\nfloat uglyRaySphereIntersect(vec3 rayorigin, vec3 raydirection, vec3 center, float radius) {\n\n    vec3 L = center - rayorigin;\n\n    float tca = dot(L, raydirection);\n    // if (tca < 0) return false;\n\n    float d2 = dot(L, L) - tca * tca;\n\n    if (d2 > radius) {\n        return -1.0;\n    }\n\n    float thc = sqrt(radius - d2);\n    float t0 = tca - thc;\n    // float t1 = tca + thc;\n\n    return t0;       \n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;  \n    vec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n    vec2 nuv = ((uv.xy-0.5) * 2.26 * aspect) + 0.0;\n        \n    vec3 ray = vec3(nuv, 1.0);\n    float len = length(ray);\n    \n    ray = normalize(ray);\n \n    float R = 1.0;\n    float Ex = 0.0;\n\n    vec4 P0 = vec4(ray, 0);\n\n    float rr = (PI/2.0) * (nuv.x*nuv.x + nuv.y*nuv.y) / 2.0;\n   \n    vec4 ret = vec4(0,0,0,1);\n    \n    vec3 origin = vec3(0, 0, 1.33333);\n\n    float T0 = uglyRaySphereIntersect(origin, ray, vec3(0.0,0.0,0.0), 1.0);\n\n    vec3 TP = origin + T0 * ray;\n    vec3 N = normalize(-TP);\n    \n    P0 = vec4(N,0);\n\n    mat4 m1 = Rot4Z( iTime * 0.2 );\n    mat4 m2 = Rot4Y( iTime * 1.3 );\n    P0 *= m1;\n    P0 *= m2;\n\n  \n    ret += texture(iChannel0, P0.xyz) * 0.5;\n    \n    float P0xa = abs(P0.x);\n    float P0ya = abs(P0.y);\n    float P0za = abs(P0.z);\n    \n    if (P0xa > P0ya && P0xa > P0za) {\n        \n        vec2 side = vec2(P0.y, P0.z);\n        \n        side.x /= P0xa;\n        side.y /= P0xa;\n    \n        side = side / 2.0 + 0.5;\n\n        if (P0.x > 0.0) {\n            ret += texture(iChannel1, side) * 0.3;\n        } else {\n            ret += texture(iChannel1, side) * 0.7;\n        }\n        \n            ret += vec4(0.3, 0.0, 0.0, 0.0);\n        \n    } else if (P0ya > P0xa && P0ya > P0za) {\n    \n        vec2 side = vec2(P0.x, P0.z);\n        \n        side.x /= P0ya;\n        side.y /= P0ya;\n        \n        side = side / 2.0 + 0.5;\n\n        if (P0.y > 0.0) {\n            ret += texture(iChannel1, side) * 0.3;\n        } else {\n            ret += texture(iChannel1, side) * 0.7;\n        }\n    \n        ret += vec4(0.0, 0.3, 0.0, 0.0);\n        \n    } else {\n        \n        vec2 side = vec2(P0.x, P0.y);\n\n        side.x /= P0za;\n        side.y /= P0za;\n    \n        side = side / 2.0 + 0.5;\n\n    \n        if (P0.z > 0.0) {\n            ret += texture(iChannel1, side) * 0.3;\n        } else {\n            ret += texture(iChannel1, side) * 0.7;\n        }\n        \n        ret += vec4(0.0, 0.0, 0.3, 0.0);\n    }\n    \n    if (rr > 1.0) {\n        ret *= 0.5;\n    }\n     \n    fragColor = ret; \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// checkerboard\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 uv2 = uv;\n    uv2 *= 3.0;\n    uv2 = vec2(mod(uv2.x, 1.0), mod(uv2.y, 1.0));\n\n    float iu = floor(uv2.x * 2.0);\n    float iv = floor(uv2.y * 2.0);\n    float iw = iu * iv + (1.0 - iu) * (1.0 - iv);\n    \n    if (iw > 0.5) {\n        fragColor = vec4(1, 1, uv.y, 1);\n    } else {\n        fragColor = vec4(0, 0, uv.y, 1);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}