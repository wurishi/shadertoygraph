{"ver":"0.1","info":{"id":"Ds2fRh","date":"1689856935","viewed":88,"name":"xAI Stars ","username":"TheTurk","description":"Stars animation from [url]https://x.ai/[/url]","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["blur","texture","animation","stars","gaussian","universe","squares","boxes","generation","ai","artificial","intelligence","xai"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {        \n    float scale = 1000.0 / iResolution.y;\n    \n    vec4 backgroundColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    vec2 uv1 = fragCoord;\n    uv1.y -= iTime * 35.0;\n    uv1 = uv1.yx;\n    uv1 = mod(uv1, iResolution.y * 0.5 * scale);\n    vec4 foregroundColor1 = texture(iChannel0, (uv1 / (scale * 0.5)) / iResolution.xy) * 0.1;\n    backgroundColor = backgroundColor * (1.0 - foregroundColor1.a) + foregroundColor1;\n    \n    vec2 uv2 = fragCoord;\n    uv2.y -= iTime * 70.0;\n    uv2 = mod(uv2, iResolution.y * scale);\n    vec4 foregroundColor2 = texture(iChannel1, (uv2 / scale) / iResolution.xy) * 0.2;\n    backgroundColor = backgroundColor * (1.0 - foregroundColor2.a) + foregroundColor2;\n  \n    vec2 uv3 = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    float m = dot(vec2(-iResolution.x / iResolution.y * 2.0, 2.0), vec2(-sqrt(0.5), sqrt(0.5)));\n    vec4 gradientColor = vec4(0.94, 0.92, 0.92, 1.0) * 0.2 * (1.0 - clamp(dot(uv3 - vec2(iResolution.x / iResolution.y, -1.0), vec2(-sqrt(0.5), sqrt(0.5))) / m, 0.0, 1.0));    \n    backgroundColor = backgroundColor * (1.0 - gradientColor.a) + gradientColor;\n    \n    fragColor = backgroundColor;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float box(vec2 position, vec2 halfSize, float cornerRadius) {\n   position = abs(position) - halfSize + cornerRadius;\n   return length(max(position, 0.0)) + min(max(position.x, position.y), 0.0) - cornerRadius;\n}\n\nvec4 read(sampler2D buffer, ivec2 offset) {\n    return texelFetch(buffer, offset, 0);\n}\n\nvoid write(vec4 value, ivec2 offset, inout vec4 fragColor, vec2 fragCoord) {\n    if (int(fragCoord.x) == offset.x && int(fragCoord.y) == offset.y) {\n        fragColor = value;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 lastResolution = read(iChannel0, ivec2(iResolution.xy - 1.0)).xy;\n    if (iResolution.y == lastResolution.y && iFrame > 1) {\n       \tfragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        return;\n    }\n    \n    uint seed = 0x535291adU;\n    int gridSize = 8;\n    float padding = 0.015 * iResolution.y;\n\n    float cellSize = (iResolution.y - 2.0 * padding) / float(gridSize);\n    vec2 position = (fragCoord - padding) / cellSize;\n    ivec2 centerCellCoordinates = ivec2(floor((fragCoord - padding) / cellSize));\n\n    vec4 backgroundColor = vec4(0.0);    \n    for (int m = -1; m <= 1; m++) {\n        for (int n = -1; n <= 1; n++) {\n            ivec2 cellCoordinates = centerCellCoordinates + ivec2(m, n);\n            if (cellCoordinates.x < 0 || cellCoordinates.y < 0 || cellCoordinates.x > gridSize - 1 || cellCoordinates.y > gridSize - 1) {\n                continue;\n            }\n        \n            randState = hash(uvec2(uint(cellCoordinates.x), uint(cellCoordinates.y)), seed); \n            vec2 positionRandom = vec2(rand(), rand()) / float(0xffffffffU) * 2.0 - 1.0;\n            float densityRandom = float(rand()) / float(0xffffffffU);\n            if (!(densityRandom < 0.5)) {\n                continue;\n            }\n        \n            vec2 center = vec2(cellCoordinates) + 0.5;\n            center += positionRandom * 0.3; \n            float d = box(position - center, vec2(0.30), 0.14);\n            vec4 foregroundColor = d < 0.0 ? vec4(0.34, 0.69, 0.85, 1.0) : vec4(0.0);\n            backgroundColor = backgroundColor * (1.0 - foregroundColor.a) + foregroundColor;\n        }\n    }\n    fragColor = backgroundColor;\n       \n    write(vec4(iResolution.x, iResolution.y, 0.0, 0.0), ivec2(iResolution.xy - 1.0), fragColor, fragCoord);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float pi = 3.141592;\n\nvec4 read(sampler2D buffer, ivec2 offset) {\n    return texelFetch(buffer, offset, 0);\n}\n\nvoid write(vec4 value, ivec2 offset, inout vec4 fragColor, vec2 fragCoord) {\n    if (int(fragCoord.x) == offset.x && int(fragCoord.y) == offset.y) {\n        fragColor = value;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) { \n    vec2 lastResolution = read(iChannel1, ivec2(iResolution.xy - 1.0)).xy;\n    if (iResolution.y == lastResolution.y && iFrame > 1) {\n       \tfragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n        return;\n    }\n    vec4 color = vec4(0.0);  \n    float sigma = 0.013 * iResolution.y;\n    int kernelRadius = int(sigma * 3.0);\n    float sum = 0.0;\n    for (int y = -kernelRadius; y <= kernelRadius; y++) {\n        for (int x = -kernelRadius; x <= kernelRadius; x++) { \n            vec4 c = texture(iChannel0, (fragCoord - vec2(x, y)) / iResolution.xy);\n            float weight = exp(-0.5 * float(x * x + y * y) / (sigma * sigma)) / (2.0 * pi * sigma * sigma);\n            color += weight * c;\n            sum += weight;\n        }\n    }\n    color /= sum;\n    fragColor = color;\n    write(vec4(iResolution.x, iResolution.y, 0.0, 0.0), ivec2(iResolution.xy - 1.0), fragColor, fragCoord);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// murmur hash function https://sites.google.com/site/murmurhash/\nuint hash(uvec2 x, uint seed){\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    uint k = x.x; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    k = x.y; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\nuint randState;\n\n// pcg pseudo random number generator https://www.pcg-random.org/\nuint rand() {\n    uint state = randState;\n    randState = randState * 747796405U + 2891336453U;\n    uint x = ((state >> ((state >> 28U) + 4U)) ^ state) * 277803737U;\n    return (x >> 22U) ^ x;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"float pi = 3.141592;\n\nvec4 read(sampler2D buffer, ivec2 offset) {\n    return texelFetch(buffer, offset, 0);\n}\n\nvoid write(vec4 value, ivec2 offset, inout vec4 fragColor, vec2 fragCoord) {\n    if (int(fragCoord.x) == offset.x && int(fragCoord.y) == offset.y) {\n        fragColor = value;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 lastResolution = read(iChannel1, ivec2(iResolution.xy - 1.0)).xy;\n    if (iResolution.y == lastResolution.y && iFrame > 1) {\n       \tfragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n        return;\n    }\n    vec4 color = vec4(0.0);  \n    float sigma = 0.01 * iResolution.y;\n    int kernelRadius = int(sigma * 3.0);\n    float sum = 0.0;\n    for (int y = -kernelRadius; y <= kernelRadius; y++) {\n        for (int x = -kernelRadius; x <= kernelRadius; x++) { \n            vec4 c = texture(iChannel0, (fragCoord - vec2(x, y)) / iResolution.xy);\n            float weight = exp(-0.5 * float(x * x + y * y) / (sigma * sigma)) / (2.0 * pi * sigma * sigma);\n            color += weight * c;\n            sum += weight;\n        }\n    }\n    color /= sum;\n    fragColor = color;\n    write(vec4(iResolution.x, iResolution.y, 0.0, 0.0), ivec2(iResolution.xy - 1.0), fragColor, fragCoord);\n}","name":"Buffer C","description":"","type":"buffer"}]}