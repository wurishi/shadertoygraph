{"ver":"0.1","info":{"id":"XXffWl","date":"1729042328","viewed":46,"name":"Bouncing Circle Test","username":"8InfinityTaco8","description":"This is a test and a reference for myself for future projects involving similar solutions. I learned a lot writing this and will definitley be experimenting with this solution and combining it with other projects.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["distancefield","sdf","bounce"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// SDF for a box\nfloat sdBox(vec2 p, vec2 bMin, vec2 bMax) {\n    vec2 bCenter = (bMax + bMin) * 0.5;\n    vec2 bSize = (bMax - bMin) * 0.5;\n    vec2 d = abs(p - bCenter) - bSize;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n} \n\n// SDF for a circle\nfloat sdCircle(vec2 p, vec2 center, float radius) {\n    return length(p - center) - radius;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize pixel coordinates (from -1 to 1, adjusting for aspect ratio) in clip space\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Define bounding box in normalized coordinates\n    vec2 boxMin = vec2(-0.88, -0.49);\n    vec2 boxMax = vec2(0.88, 0.49);\n    \n    // Circle properties\n    float radius = 0.08;\n    vec2 velocity = vec2(1.0, 1.0); // Base velocity\n    float speed = 0.9; // Adjust for faster/slower movement\n    \n    // Calculate position based on time\n    vec2 position = vec2(\n        mod(iTime * velocity.x * speed, (boxMax.x - boxMin.x - 2.0 * radius)) + boxMin.x + radius,\n        mod(iTime * velocity.y * speed, (boxMax.y - boxMin.y - 2.0 * radius)) + boxMin.y + radius\n    );\n    \n    // Bouncing effect\n    if (mod(floor(iTime * velocity.x * speed / (boxMax.x - boxMin.x - 2.0 * radius)), 2.0) == 1.0) {\n        position.x = boxMax.x - (position.x - boxMin.x);\n    }\n    if (mod(floor(iTime * velocity.y * speed / (boxMax.y - boxMin.y - 2.0 * radius)), 2.0) == 1.0) {\n        position.y = boxMax.y - (position.y - boxMin.y);\n    }\n    \n    // SDF for the circle\n    float distToCircle = sdCircle(uv, position, radius);\n    \n    // SDF for the box\n    float distToBox = sdBox(uv, boxMin, boxMax);\n    \n    // Set the thickness for rendering the edges\n    float edgeThickness = 0.005;\n\n    // Render the circle as hollow by rendering only its edges\n    vec3 color = vec3(0.0);\n    if (abs(distToCircle) < edgeThickness) {\n        color = vec3(1.0); // White edges for the circle\n    }\n    \n    // Render the box edges\n    if (abs(distToBox) < edgeThickness) {\n        color = vec3(1.0, 0.0, 0.0); // Red edges for the box\n    }\n    \n    // Debug: Draw center point\n    float centerPoint = step(length(uv), 0.005);\n    color = mix(color, vec3(0.0, 1.0, 0.0), centerPoint); // Green center point\n\n    // Output the final color to the screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}