{"ver":"0.1","info":{"id":"DdlSWS","date":"1669494437","viewed":97,"name":"bootleg flappy bird","username":"import_shader_steve","description":"Controls:\nUp Arrow - Jump\n\nWorking on collision detection.","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["aweoifjew"],"hasliked":0,"parentid":"cdlSWS","parentname":"gravity implementation"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdfCircle(vec2 uv, float r, float offset) {\n    float x = uv.x + iResolution.x/iResolution.y - r * 2.;\n    float y = uv.y - offset;\n    \n    float d = length(vec2(x, y)) - r;\n    \n    return step(0., -d);\n}\n\nvec3 drawCircle(vec2 uv) {\n    vec3 col = vec3(0);\n    \n    // Fetch the offset from the XY part of the pixel values returned by Buffer A\n    float offset = texelFetch( iChannel0, ivec2(34,0), 0 ).w;\n    \n    float blueCircle = sdfCircle(uv, 0.1, offset);\n    \n    col = mix(col, vec3(0, 0, 1.), blueCircle);\n    \n    return col;\n}\n\nfloat sdfBox(vec2 uv, float width, float height) {\n    float horizontal = 1. - step(height/2., abs(uv.y));\n    float vertical = 1. - step(width/2., abs(uv.x));\n    return horizontal * vertical;\n}\n\nfloat drawPillars(vec2 uv, float x, float y, float width, float height) {\n    uv -= vec2(x, y);\n    return sdfBox(uv, width, height);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy; // [0.0 ~ 1.0]\n    uv -= 0.5; // [-0.5 ~ 0.5]\n    uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n    uv *= 2.; // [-1.0 ~ 1.0]\n\n    // draw the blue circle\n    vec3 col = drawCircle(uv);\n    \n    float fDigits = 6.0;\n\tfloat fDecimalPlaces = 4.0;\n    float pressedTime = texelFetch(iChannel0, ivec2(0, 0), 0).x;\n    col = mix(col, vec3(1.0, 0.5, 0.0), PrintValue(fragCoord, grid(-2,0), fontSize, pressedTime, fDigits, fDecimalPlaces));\n    float elapsedTime = texelFetch(iChannel0, ivec2(0, 0), 0).y;\n    col = mix(col, vec3(0.0, 0.5, 1.0), PrintValue(fragCoord, grid(10,0), fontSize, elapsedTime, fDigits, fDecimalPlaces));\n    float currentVelocity = texelFetch(iChannel0, ivec2(0, 0), 0).z;\n    col = mix(col, vec3(0.5, 0.0, 1.0), PrintValue(fragCoord, grid(25,0), fontSize, currentVelocity, fDigits, fDecimalPlaces));\n    float currentHeight = texelFetch(iChannel0, ivec2(0, 0), 0).w;\n    col = mix(col, vec3(0.0, 1.0, 0.0), PrintValue(fragCoord, grid(40,0), fontSize, currentHeight, fDigits, fDecimalPlaces));\n    \n    // draw the moving pillars\n    uv *= 1.5; // [-1.5, 1.5]\n    uv.x += iTime * 1.;\n    \n    float id = floor(uv.x);\n    float nXoffset = fract(sin(id * 234.12) * 5463.3) * 2. - 1.; // [-1., 1.]\n    \n    // the actual total height of top & bottom pillars on screen is actually half the totalHeight\n    // b/c half of both pillars are outside of the screen, not visible\n    const float totalHeight = 3.;\n    float nBottomHeight = fract(sin(id * 345.67) * 7891.2) * totalHeight; // [0., 2.5]\n    float nTopHeight = totalHeight - nBottomHeight;\n    \n    uv.x = fract(uv.x) - .5; // [-0.5, 0.5]\n    const float width = .3;\n    float x = .35 * nXoffset; // [-.35, .35], b/c 0.5 - 0.3/2 = 0.35\n    float y1 = -1.5;\n    float bottom_pillars = drawPillars(uv, x, y1, width, nBottomHeight);\n    col += mix(col, vec3(1., 1., 0.), bottom_pillars);\n    float y2 = 1.5;\n    float top_pillars = drawPillars(uv, x, y2, width, nTopHeight);\n    col += mix(col, vec3(1., 1., 0.), top_pillars);\n    \n    // if col == 'white', then means circle collides with pillars\n    if (col == vec3(1., 1., 1.)) {\n        col = vec3(0.);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// For details on how the keyboard input works, see iq's tutorial: https://www.shadertoy.com/view/lsXGzf\n\n// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nvec4 handleKeyboard(vec4 info) {\n    \n    float pressed = texelFetch( iChannel1, ivec2(KEY_UP,1),0 ).x;\n    // info.x -> pressedTime\n    // info.y -> elapsedTime\n    if (pressed == 1.) {\n        info.x = iTime;\n        info.y = 0.;\n    } else {\n        info.y += iTimeDelta;\n    }\n    // info.z -> current velocity\n    if (pressed == 1.) {\n        info.z = vJump;\n    } else {\n        info.z -= 30. * info.y / 1000.;\n    }\n    // info.w -> current height\n    info.w = clamp(info.w + info.z * iTimeDelta, low, high);\n\n    return info;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Return the offset value from the last frame (zero if it's first frame)\n    vec4 info = texelFetch( iChannel0, ivec2(69, 0), 0).xyzw;\n    \n    // Pass in the offset of the last frame and return a new offset based on keyboard input\n    info = handleKeyboard(info);\n\n    // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n    fragColor = vec4(info);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\nfloat PrintValue(vec2 fragCoord, vec2 pixelCoord, vec2 fontSize, float value,\n\t\tfloat digits, float decimals) {\n\tvec2 charCoord = (fragCoord - pixelCoord) / fontSize;\n\tif(charCoord.y < 0.0 || charCoord.y >= 1.0) return 0.0;\n\tfloat bits = 0.0;\n\tfloat digitIndex1 = digits - floor(charCoord.x)+ 1.0;\n\tif(- digitIndex1 <= decimals) {\n\t\tfloat pow1 = pow(10.0, digitIndex1);\n\t\tfloat absValue = abs(value);\n\t\tfloat pivot = max(absValue, 1.5) * 10.0;\n\t\tif(pivot < pow1) {\n\t\t\tif(value < 0.0 && pivot >= pow1 * 0.1) bits = 1792.0;\n\t\t} else if(digitIndex1 == 0.0) {\n\t\t\tif(decimals > 0.0) bits = 2.0;\n\t\t} else {\n\t\t\tvalue = digitIndex1 < 0.0 ? fract(absValue) : absValue * 10.0;\n\t\t\tbits = DigitBin(int (mod(value / pow1, 10.0)));\n\t\t}\n\t}\n\treturn floor(mod(bits / pow(2.0, floor(fract(charCoord.x) * 4.0) + floor(charCoord.y * 5.0) * 4.0), 2.0));\n}\n// Multiples of 4x5 work best\nconst vec2 fontSize = vec2(4,5) * vec2(5,5);\nvec2 grid(int x, int y) {\n    return fontSize.xx * vec2(1,ceil(fontSize.y/fontSize.x)) * vec2(x,y) + vec2(2);\n}\n\nconst float vJump = 0.6;\nconst float high = 0.9;\nconst float low = -0.9;","name":"Common","description":"","type":"common"}]}