{"ver":"0.1","info":{"id":"tdlcWH","date":"1584814248","viewed":108,"name":"flower rotating 3D","username":"jiaolyulu1","description":"this is a 3D flower shader","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//This shader got inspiration from \n//https://www.shadertoy.com/view/XdBSzG\n//whose author is iq\n//I learn how to make capsule growing and exploding from a fixed point\n\n#define S(a,b,t) smoothstep(a,b,t)\n#define MaxStep 100\n#define MaxDistance 100.\n#define SurfOut 0.1\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nmat2 rot(float a){\n\tfloat x = sin(a);\n    float y = cos(a);\n    return mat2(y,-x,x,y);\n}\n\nfloat N(float n){\n\treturn fract(12.32*sin(34.56*n));\n}\n\nvec3 getNoise(vec2 uv){\n    return texture(iChannel0,uv+iTime/1000.).rgb;\n}\n\nvec3 N33(vec2 uv){\n    vec3 p=getNoise(uv);\n\treturn vec3(N(p.x),N(p.y),N(p.z));\n}\n\nfloat Dcapsule (vec3 p,vec3 a,vec3 b, float r){\n\tvec3 ap = p - a;\n    vec3 ab = b - a;\n    float t = clamp(dot(ap,ab)/dot(ab,ab),0.0,1.0);\n    vec3 at = t*ab;\n    return length(at-ap)-r;\n}\n\n\n\nfloat Dist (vec3 p){\n\n    float rad=length(p);\n\t//float density=0.15;\n    float density=0.4+sin(iTime/10.)*0.18;\n    float dist_plane= p.y+1.0;\n    //p.x*=0.9+0.2*sin(p.x*4.);\n    vec3 pos=p;\n    float dir= atan(p.x,p.y)+3.1416;\n    dir+=(sin(iTime/2.)*3.+2.)*sin(rad);\n    float center = acos((pos.z\n                         -0.2)/rad) ;\n    center+=(sin(iTime/50.)*1.+1.)*sin(0.3*rad);\n\tdir=mod(dir,density)-density/2.;\n    center=mod(center,density)-density/2.;\n    vec2 id=vec2(floor(dir/density),floor(center/density));\n    vec3 Noise=getNoise(id/10.4);\n    float length= clamp((Noise.r*4.-2.2),0.,4.)*(2.1-rad);\n    Noise-=0.5;\n    float dist_capsule=Dcapsule(vec3(dir*2.4,center*6.,rad), \n                         \t\tvec3(0.,1.,-0.0), \n                         \t\tvec3(0.,0.,length), 0.9);\n \n    return dist_capsule;\n\n}\n\n  \n\nvec3 normal(vec3 p){\n    float d= Dist(p);\n    vec2 o = vec2(-0.01,0.0);\n    vec3 n = d - vec3 (Dist(p+o.xyy),\n                       Dist(p+o.yxy),\n                       Dist(p+o.yyx));\n    n = normalize(n);\n    return n;\n}\n\nfloat diffuse(vec3 p){\n\tvec3 light = vec3 (2.0*sin(iTime),6.0,3.0+3.0*cos(iTime));\n    vec3 l=normalize(light-p);\n    vec3 n = normal(p);\n    float d = clamp(dot(l,n),0.0,1.0);\n\n    return 1.8*d+0.3;\n}\n\nfloat rayMarch(vec3 ro,vec3 rd, inout float outline){\n\tfloat t=0.0;\n    float d;\n    \n    for (int i=0; i<=MaxStep; i++){\n        float prevDist=d;\n        d =Dist(ro+rd*t);\n        t+= d;\n        if(d > prevDist  && d < 0.1 ){\n        \toutline = 1.;\n        }\n        if (d<0.01 || t>MaxDistance ){\n        \tbreak;\n        }\n        \n    }\n    \n    outline/=0.1;\n   \t\n    //col = normal(p).z;\n    return t;\n    \n}\n\nfloat shadow(vec3 p, vec3 lightPos){\n    vec3 p1 = p+normal(p)*SurfOut;\n    vec3 ray1 = normalize(lightPos-p1);\n    float m;\n    float shadow = rayMarch(p1,ray1,m);\n    if (shadow<length(lightPos-p1)){\n       return clamp(shadow*0.4,0.0,1.0);\n    }\n    return 1.;\n    \n}\n\nvec3 look (vec2 uv, vec3 p){\n\tvec3 i;\n    vec3 f = normalize(p);\n    vec3 r = cross(vec3(0.,1.,0.),f);\n    vec3 u = cross(f,r);\n    i = f*1.0+uv.x*r+uv.y*u;\n    i = normalize(i);\n    return i;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float alpha;\n    vec3 lookAt = vec3(0.0,0.0,0.0);\n    float angle= (iMouse.x/iResolution.x-0.5)*6.28;\n\tvec3 cam = vec3(1.0*sin(angle),6.0*sin(iTime*0.2),6.0+2.0*cos(angle));\n    vec3 ray = look(uv,lookAt-cam);\n    float outline=0.;\n    float t = rayMarch(cam,ray,outline);\n    alpha=S(20.,19.,t);\n    vec3 p =cam+ray*t;\n     \n    float light = diffuse(p);\n    float c= 2.5*light;\n    \n    //vec3 lightPos=vec3 (2.0*sin(iTime),2.0,3.0+3.0*cos(iTime));\n    //c*=shadow(p,lightPos);\n    \n    \n    \n    vec3 col= vec3(c*0.4)*texture(iChannel1,vec2(c/10.,uv.y)).rgb;\n    col=mix(col,vec3(1.,0.,1.),outline);\n    //col+=vec3(outline);\n    // Output to screen\n    fragColor = vec4(col*alpha,alpha);\n}","name":"Image","description":"","type":"image"}]}