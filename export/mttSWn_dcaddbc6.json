{"ver":"0.1","info":{"id":"mttSWn","date":"1685285618","viewed":73,"name":"Noise-based stars","username":"fantazista","description":"Stars","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["noise","stars","starfield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float palette(in float a, in float b, in float c, in float d, in float x)\n{\n    return a + b * cos(6.28318 * (c * x + d));\n}\n    \n// 2D Noise from IQ\nfloat Noise2D(in vec2 x)\n{\n    ivec2 p = ivec2(floor(x));\n    vec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tivec2 uv = p.xy;\n\tfloat rgA = texelFetch( iChannel0, (uv+ivec2(0,0))&255, 0 ).x;\n    float rgB = texelFetch( iChannel0, (uv+ivec2(1,0))&255, 0 ).x;\n    float rgC = texelFetch( iChannel0, (uv+ivec2(0,1))&255, 0 ).x;\n    float rgD = texelFetch( iChannel0, (uv+ivec2(1,1))&255, 0 ).x;\n    return mix( mix( rgA, rgB, f.x ),\n                mix( rgC, rgD, f.x ), f.y );\n}\n\nfloat ComputeFBMStars(in vec2 pos)\n{\n    float amplitude = 0.75;\n    float sum = 0.0;\n    float maxAmp = 0.0;\n    for(int i = 0; i < 5; ++i)\n    {\n        sum += Noise2D(pos) * amplitude;\n        maxAmp += amplitude;\n        amplitude *= 0.5;\n        pos *= 2.0;\n    }\n    return sum / maxAmp * 1.15;\n}\n\nvec3 BackgroundColor(in vec2 uv)\n{\n    \n    // Sample various noises and multiply them\n    float noise1 = ComputeFBMStars(uv * 5.0);\n    float noise2 = ComputeFBMStars(uv * vec2(15.125, 25.7));\n    float noise3 = ComputeFBMStars((uv + vec2(0.5, 0.1)) * 4.0 + iTime * 0.35);\n    float starShape = noise1 * noise2 * noise3;\n    \n    // Compute star falloff - not really doing what i hoped it would, i wanted smooth falloff around each star\n    float falloffRadius = 0.2;\n    float baseThreshold = 0.6; // higher = less stars\n    \n    starShape = clamp(starShape - baseThreshold + falloffRadius, 0.0, 1.0);\n    \n    float weight = starShape / (2.0 * falloffRadius);\n    return weight * vec3(noise1 * 0.55, noise2 * 0.4, noise3 * 1.0) * 6.0; // artificial scale just makes the stars brighter\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 finalColor;\n    vec3 color;\n      \n    // Cosine-based pallette: http://dev.thi.ng/gradients/\n    color.r = palette(0.5, -1.081592653589793, 0.798407346410207, 0.0, 1.0);\n    color.g = palette(0.5, 0.658407346410207, 0.908407346410207, 0.268407346410207, 1.0);\n    color.b = palette(0.5, -0.201592653589793, 0.318407346410207, -0.001592653589793, 1.0);\n    \n   \n    // Add some blue to the background\n    vec3 backgroundCol = BackgroundColor(fragCoord.xy * 0.9);\n    \n    finalColor = vec4(mix(backgroundCol, color, 0.0), 1);\n        \n\tfragColor = finalColor;\n}","name":"Image","description":"","type":"image"}]}