{"ver":"0.1","info":{"id":"mtSyzm","date":"1691836895","viewed":33,"name":"202308091841_anton_sh_table","username":"anton_sh","description":"draw a simple table 15*15","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["webgl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 _screen;\nvec2 _table;\nvec2 _directionPoint;\nfloat _rotation;\nfloat _strength;\nbool _enableMouseInput;\n\nvoid set()\n{\n        _screen = vec2(iResolution.x, iResolution.y);\n        _table = vec2(min(iResolution.x, iResolution.y) - 1.0, min(iResolution.x, iResolution.y)) -1.0;\n        _directionPoint = vec2(0.1, 0.5);\n        _rotation = 90.0;\n        _strength = 1.5;\n        _enableMouseInput = true;\n}\n\nvec4 sum(vec4 layer1, vec4 layer2)\n{\n    layer1.r = layer1.r*(1.0-layer2.a) + layer2.r*layer2.a;\n    layer1.g = layer1.g*(1.0-layer2.a) + layer2.g*layer2.a;\n    layer1.b = layer1.b*(1.0-layer2.a) + layer2.b*layer2.a;\n    \n    return layer1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    set();\n\n    vec2 currentPoint = fragCoord.xy / _screen.xy;\n    vec4 table = texture(iChannel0, currentPoint);\n    vec4 point = texture(iChannel1, currentPoint);\n    vec4 wrap = vec4(texture(iChannel2, currentPoint).rgb ,0.5);\n    \n    //fragColor = sum(table, point);\n    //fragColor = sum(table, wrap);\n    //fragColor = sum(fragColor, point);\n    fragColor = sum(wrap, point);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 _screen;\nvec2 _table;// = vec2(300, 300);\nvec2 _directionPoint = vec2(0.1, 0.5);\nfloat _rotation = 90.0;//azimuth = East\nfloat _strength = 1.5;// 70.0 of 100.0\nbool _enableMouseInput = true;\n//bool _enableMouseInput = false;\n\n\nvoid SetVariables()\n{\n    _screen = vec2(iResolution.x, iResolution.y);\n    _table = vec2(min(iResolution.x, iResolution.y) - 1.0, min(iResolution.x, iResolution.y)) -1.0;\n}\n\nvec4 Introduce (float value)\n{\n    float multiplier = 256.0;\n    float v = iResolution.x;\n    float a = floor(v/multiplier/multiplier/multiplier/multiplier);\n    v = v - a*multiplier*multiplier*multiplier*multiplier;\n    float b = floor(v/multiplier/multiplier/multiplier);\n    v = v - b*multiplier*multiplier*multiplier;\n    float c = floor(v/multiplier/multiplier);\n    v = v - c*multiplier*multiplier;\n    float d = v/multiplier;\n    \n    vec4 result = vec4(a,b,c,d);\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    SetVariables();\n\n    if (0.0 < fragCoord.x && fragCoord.x < 0.1)\n    {\n        fragColor = Introduce(_screen.x);\n    }\n    else\n        if (0.1 < fragCoord.x && fragCoord.x < 0.2)\n    {\n        fragColor = Introduce(_screen.y);\n    }\n    else\n        if (0.2 < fragCoord.x && fragCoord.x < 0.3)\n    {\n        fragColor = Introduce(_table.x);\n    }\n    else\n    \n        if (0.3 < fragCoord.x && fragCoord.x < 0.4)\n    {\n        fragColor = Introduce(_table.y);\n    }\n    else\n        if (0.4 < fragCoord.x && fragCoord.x < 0.5)\n    {\n        fragColor = Introduce(_directionPoint.x);\n    }\n    else\n        if (0.5 < fragCoord.x && fragCoord.x < 0.6)\n    {\n        fragColor = Introduce(_directionPoint.y);\n    }\n    else\n    \n        if (0.6 < fragCoord.x && fragCoord.x < 0.7)\n    {\n        fragColor = Introduce(_rotation);\n    }\n    else\n        if (0.7 < fragCoord.x && fragCoord.x < 0.8)\n    {\n        fragColor = Introduce(_strength);\n    }\n    else\n        if (0.8 < fragCoord.x && fragCoord.x < 0.9)\n    {\n        if (_enableMouseInput)\n        {\n            fragColor = vec4(1.0,0.0,0.0,0.0);\n        }\n        else\n        {\n            fragColor = vec4(0.0,0.0,0.0,0.0);\n        }\n    }\n    else\n    {\n        fragColor = vec4(0.5,0.5,0.5,1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec2 _screen;\nvec2 _table;\nvec2 _directionPoint;\nfloat _rotation;\nfloat _strength;\nbool _enableMouseInput;\n\nfloat gather(vec4 parts)\n{\n    float multiplier = 256.0;\n    float result = parts.r * multiplier * multiplier * multiplier * multiplier;\n    result = result + parts.r * multiplier * multiplier * multiplier;\n    result = result + parts.r * multiplier * multiplier;\n    result = result + parts.r * multiplier;\n    return result;\n}\n\nvoid set()\n{\n    if (false)\n    {\n        //I don't understand why it doesn't work.\n        float d = pow(iResolution.x*iResolution.x + iResolution.y*iResolution.y, 0.5)/20.0;\n        vec2 request1 = vec2(d,0.0)/iResolution.xy;\n        vec2 request2 = vec2(3.0*d,0.0)/iResolution.xy;\n        vec2 request3 = vec2(5.0*d,0.0)/iResolution.xy;\n        vec2 request4 = vec2(7.0*d,0.0)/iResolution.xy;\n        vec2 request5 = vec2(9.0*d,0.0)/iResolution.xy;\n        vec2 request6 = vec2(11.0*d,0.0)/iResolution.xy;\n        vec2 request7 = vec2(13.0*d,0.0)/iResolution.xy;\n        vec2 request8 = vec2(15.0*d,0.0)/iResolution.xy;\n        vec2 request9 = vec2(17.0*d,0.0)/iResolution.xy;\n    \n        vec4 input1 = texture(iChannel0, request1);\n        vec4 input2 = texture(iChannel0, request2);\n        vec4 input3 = texture(iChannel0, request3);\n        vec4 input4 = texture(iChannel0, request4);\n        vec4 input5 = texture(iChannel0, request5);\n        vec4 input6 = texture(iChannel0, request6);\n        vec4 input7 = texture(iChannel0, request7);\n        vec4 input8 = texture(iChannel0, request8);\n        vec4 input9 = texture(iChannel0, request9);\n\n        _screen = vec2(gather(input1), gather(input2));\n        _table = vec2(gather(input3), gather(input4));\n        _directionPoint = vec2(gather(input5), gather(input6));\n        _rotation = gather(input7);\n        _strength = gather(input8);\n        if (input9 == vec4(1.0,0.0,0.0,0.0))\n        {\n            _enableMouseInput = true;\n        }\n        else\n        {\n            _enableMouseInput = false;\n        }\n    }\n    else\n    {\n        _screen = vec2(iResolution.x, iResolution.y);\n        _table = vec2(min(iResolution.x, iResolution.y) - 1.0, min(iResolution.x, iResolution.y)) -1.0;\n        _directionPoint = vec2(0.1, 0.5);\n        _rotation = 90.0;\n        _strength = 1.5;\n        _enableMouseInput = true;\n        //_enableMouseInput = false;\n    }\n    \n}\n\nvec4 drawTable(vec2 currentPoint)\n{\n    vec4 colorTableField = vec4(0.0,0.0,0.0,1.0);;\n    \n    float x0 = (_screen.x-_table.x) / 2.0;\n    float dX = _table.x/15.0;//20.0+\n    float x = currentPoint.x*_screen.x-x0;\n    \n    bool oddFieldX = (x/(dX*2.0) - floor(x/(dX*2.0)))*dX*2.0 < dX;\n    \n    float y0 = (_screen.y-_table.y) / 2.0;\n    float dY = _table.y/15.0;\n    float y = currentPoint.y*_screen.y - y0;\n    \n    bool oddFieldY = (y/(dY*2.0) - floor(y/(dY*2.0)))*dY*2.0 < dY;\n    \n    if (x > 0.0 && x < _screen.x-2.0 * x0\n        && y > 0.0 && y < _screen.y-2.0 * y0\n        && ((oddFieldX && oddFieldY) || (!oddFieldX && !oddFieldY))\n        )\n    {\n        colorTableField = vec4(1.0,1.0,1.0,1.0);\n    }\n    \n    return colorTableField;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    set();\n\n    vec2 currentPoint = fragCoord/_screen.xy;\n\tfragColor = drawTable(currentPoint);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"vec2 _screen;\nvec2 _table;\nvec2 _directionPoint;\nfloat _rotation;\nfloat _strength;\nbool _enableMouseInput;\n\nfloat gather(vec4 parts)\n{\n    float multiplier = 256.0;\n    float result = parts.r * multiplier * multiplier * multiplier * multiplier;\n    result = result + parts.r * multiplier * multiplier * multiplier;\n    result = result + parts.r * multiplier * multiplier;\n    result = result + parts.r * multiplier;\n    return result;\n}\n\nvoid set()\n{\n        _screen = vec2(iResolution.x, iResolution.y);\n        _table = vec2(min(iResolution.x, iResolution.y) - 1.0, min(iResolution.x, iResolution.y)) -1.0;\n        _directionPoint = vec2(0.1, 0.5);\n        _rotation = 90.0;\n        _strength = 1.5;\n        _enableMouseInput = true;\n        //_enableMouseInput = false;\n}\n\nvec2 ResetPoint(vec2 point, vec2 table)\n{\n    float x0 = (_screen.x-_table.x) / 2.0;\n    float y0 = (_screen.y-_table.y) / 2.0;\n    \n    point.x = point.x * _table.x / _screen.x + x0/_screen.x;\n    point.y = point.y * _table.y / _screen.y + y0/_screen.y;\n    return point;\n}\n\nfloat DrawPoint(vec2 drawedPoint, vec2 currentPoint)\n{\n\tvec2 vDelta = (drawedPoint - currentPoint) * _screen.xy;\n\tfloat fDist = length(vDelta);\n\treturn smoothstep(3.0, 2.0, fDist);\n}\n\nvec2 GetPowerPoint(vec2 directionPoint, float rotation)\n{\n    float angle = 90.0 - rotation;\n    float dX = _strength/100.0 * cos(angle);\n    float dY = _strength/100.0 * sin(angle);\n\n    vec2 powerPoint = vec2(directionPoint.x + dX, directionPoint.y + dY);\n    return powerPoint;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    set();\n\n    //parameters correction for power point stay on table\n    _directionPoint = ResetPoint(_directionPoint, _screen.xy);\n    _strength = _strength*min(_table.x, _table.y)/max(_screen.x, _screen.y);\n\n\tvec2 powerPoint = GetPowerPoint(_directionPoint, _rotation);\n    \n    if(_enableMouseInput)\n    if(iMouse.x > 0.00)\n    {\n        powerPoint = iMouse.xy / _screen.xy;\n\t\t_directionPoint = abs(iMouse.zw) / _screen.xy;\n    }\n    \n    \n    float x0 = (_screen.x-_table.x) / 2.0;\n    float y0 = (_screen.y-_table.y) / 2.0;\n    _directionPoint.x = _directionPoint.x * _screen.x;\n    _directionPoint.y = _directionPoint.y * _screen.y;\n    powerPoint.x = powerPoint.x * _screen.x;\n    powerPoint.y = powerPoint.y * _screen.y;\n    //if (_directionPoint.x < x0)\n    //{\n    //    _directionPoint.x = x0;\n    //}\n    //else if (_directionPoint.x > _screen.x - x0)\n    //{\n    //    _directionPoint.x = _screen.x - x0;\n    //}\n    \n    //if (_directionPoint.y < y0)\n    //{\n    //    _directionPoint.y = y0;\n    //}\n    //else if (_directionPoint.y > _screen.y - y0)\n    //{\n    //    _directionPoint.y = _screen.y - y0;\n    //}\n    //if (powerPoint.x < x0)\n    //{\n    //    powerPoint.x = x0;\n    //}\n    //else if (powerPoint.x > _screen.x - x0)\n    //{\n    //    powerPoint.x = _screen.x - x0;\n    //}\n    \n    //if (powerPoint.y < y0)\n    //{\n    //    powerPoint.y = y0;\n    //}\n    //else if (powerPoint.y > _screen.y - y0)\n    //{\n    //    powerPoint.y = _screen.y - y0;\n    //}\n    \n    _directionPoint = _directionPoint.xy/_screen.xy;\n    powerPoint = powerPoint.xy/_screen.xy;\n    \n    \n\n    vec2 currentPoint = fragCoord.xy / iResolution.xy;\n    vec4 blackLayer = vec4(0.0,0.0,0.0,0.0);\n    vec4 directionPointLayer = mix( blackLayer.rgba, vec4(0.0, 1.0, 0.0, 1.0), DrawPoint(_directionPoint, currentPoint));\n    vec4 powerPointLayer = mix( directionPointLayer, vec4(1.0, 0.0, 1.0, 1.0), DrawPoint(powerPoint, currentPoint));\n    \n    fragColor = vec4(powerPointLayer);\n}\n\n\n\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"vec2 _screen;\nvec2 _table;\nvec2 _directionPoint;\nfloat _rotation;\nfloat _strength;\nbool _enableMouseInput;\n//what is above should be part of the uniform\n\nvoid set()\n{\n        _screen = vec2(iResolution.x, iResolution.y);\n        _table = vec2(min(iResolution.x, iResolution.y) - 1.0, min(iResolution.x, iResolution.y)) -1.0;\n        _directionPoint = vec2(0.1, 0.5);\n        _rotation = 90.0;\n        _strength = 1.5;\n        _enableMouseInput = true;\n        //_enableMouseInput = false;\n}\n\nvec2 ResetPoint(vec2 point)\n{\n    float x0 = (_screen.x-_table.x) / 2.0;\n    float y0 = (_screen.y-_table.y) / 2.0;\n    \n    point.x = point.x * _table.x / _screen.x + x0/_screen.x;\n    point.y = point.y * _table.y / _screen.y + y0/_screen.y;\n    return point;\n}\n\nfloat GetSin(vec2 point)\n{\n    float r = pow(\n                  pow(point.x, 2.0)\n                  + pow(point.y, 2.0),\n                  0.5\n                  );\n\n    float sinA = point.y/r;\n    return sinA;\n}\n\nfloat GetCos(vec2 point)\n{\n    float r = pow(\n                  pow(point.x, 2.0)\n                  + pow(point.y, 2.0),\n                  0.5\n                  );\n\n    float cosA = point.x/r;\n    return cosA;\n}\n\nvec2 GetPowerPoint(vec2 directionPoint, float rotation, float strength)\n{\n    float angle = 90.0 - rotation;\n    float dX = strength * cos(angle);\n    float dY = strength * sin(angle);\n\n    vec2 powerPoint = vec2(directionPoint.x + dX, directionPoint.y + dY);\n    return powerPoint;\n}\n\nvec2 updateDirectionPoint()\n{\n    vec2 directionPoint = ResetPoint(_directionPoint);\n    _strength = _strength*float(min(_table.x, _table.y))/max(_screen.x, _screen.y);\n\n    if(_enableMouseInput)\n    if(iMouse.x > 0.00)\n    {\n\t\tdirectionPoint = abs(iMouse.zw) / iResolution.xy;\n    }\n    \n    float x0 = (_screen.x-_table.x) / 2.0;\n    float y0 = (_screen.y-_table.y) / 2.0;\n    directionPoint.x = directionPoint.x * _screen.x;\n    directionPoint.y = directionPoint.y * _screen.y;\n\n    //if (directionPoint.x < x0)\n    //{\n    //    directionPoint.x = x0;\n    //}\n    //else if (directionPoint.x > _screen.x - x0)\n    //{\n    //    directionPoint.x = _screen.x - x0;\n    //}\n    \n    //if (directionPoint.y < y0)\n    //{\n    //    directionPoint.y = y0;\n    //}\n    //else if (directionPoint.y > _screen.y - y0)\n    //{\n    //    directionPoint.y = _screen.y - y0;\n    //}\n    \n    return directionPoint;\n}\n\n\n\nvec2 updatePowerPoint()\n{\n    vec2 directionPoint = ResetPoint(_directionPoint);\n    _strength = _strength*float(min(_table.x, _table.y))/max(_screen.x, _screen.y);\n\n\tvec2 powerPoint = GetPowerPoint(directionPoint, _rotation, _strength);\n    \n    if(_enableMouseInput)\n    if(iMouse.x > 0.00)\n    {\n        powerPoint = iMouse.xy / iResolution.xy;\n    }\n    \n    float x0 = (_screen.x-_table.x) / 2.0;\n    float y0 = (_screen.y-_table.y) / 2.0;\n    powerPoint.x = powerPoint.x * _screen.x;\n    powerPoint.y = powerPoint.y * _screen.y;\n    \n    //if (powerPoint.x < x0)\n    //{\n    //    powerPoint.x = x0;\n    //}\n    //else if (powerPoint.x > _screen.x - x0)\n    //{\n    //    powerPoint.x = _screen.x - x0;\n    //}\n    \n    //if (powerPoint.y < y0)\n    //{\n    //    powerPoint.y = y0;\n    //}\n    //else if (powerPoint.y > _screen.y - y0)\n    //{\n    //    powerPoint.y = _screen.y - y0;\n    //}\n    \n    \n    return powerPoint;\n}\n\n\n\n\nvec4 sum(vec4 layer1, vec4 layer2)\n{\n    layer1.r = layer1.r*(1.0-layer2.a) + layer2.r*layer2.a;\n    layer1.g = layer1.g*(1.0-layer2.a) + layer2.g*layer2.a;\n    layer1.b = layer1.b*(1.0-layer2.a) + layer2.b*layer2.a;\n    \n    return layer1;\n}\n\nvec2 Wrap(vec2 currentPoint, vec2 directionPoint, vec2 powerPoint)\n{\n    //middle line width [y = 7] x = {34.00,32.00,30.50,30.00,29.00, 28.50,29.00,29.50,30.50,31.50, 34.00,38.00,44.00,51.00,32.00}\n    \n    \n    //edge effects start at 4 out of 15 cells and last up to 1 cell, first cell for offset compensation\n     \n    //perpendicular warpping\n    //{(3;11.25);(4;11.7);(8;12);(15;12)}\n    //{(3;2.8);(6;2.5);(9;2.5);(13;2.5)}\n    \n    //deformation looks like an ellipse with semi-major axis equal to 5 and semi-minor axis equal to 4\n    //but i will make deformation like a bubble with a radius of 4\n    float k = (34.0 - 29.00)/(34.00*4.0)/(34.00*4.0);//deformation multiplier\n    \n    //looking for a solution as a function of the sum of bubble deformation and edge smoothing\n    //currentWarp = bubbleWarp + edgeWarp;\n    \n    \n    \n    float r = pow(\n                  pow(powerPoint.x - directionPoint.x, 2.0)\n                  + pow(powerPoint.y - directionPoint.y, 2.0),\n                  0.5);\n                  \n    //!!!interpret strength of wrapp as a measure of radius\n    float strength = k*r*r;\n    \n    float bubbleWarpStrength = 0.0;\n    \n    float l = pow(\n            pow(currentPoint.x - directionPoint.x, 2.0)\n            + pow(currentPoint.y - directionPoint.y, 2.0),\n            0.5);\n    \n    if (l <= r)\n    {\n       bubbleWarpStrength = l/r*strength;\n       //bubbleWarpStrength = bubbleWarpStrength*5.0;//only my wish, for test, in task`s example it string absent\n    }\n    else if (l < 2.0*r)\n    {\n        bubbleWarpStrength = (1.0-(l-r)/r)*strength;\n    }\n    \n    vec2 bubbleWarp = vec2(0.0,0.0);\n    bubbleWarp.x = bubbleWarpStrength*GetCos(currentPoint-directionPoint);\n    bubbleWarp.y = bubbleWarpStrength*GetSin(currentPoint-directionPoint);\n\n    vec2 waveWarp = vec2(0.0,0.0);\n    vec2 edgeWarp = vec2(0.0,0.0);\n    vec2 cellSide = vec2(_table.x/15.0, _table.y/15.0);\n    \n    float x0 = (_screen.x-_table.x) / 2.0;\n    float y0 = (_screen.y-_table.y) / 2.0;\n    \n    if (\n    currentPoint.x < x0 + cellSide.x\n    || currentPoint.y < y0 + cellSide.y\n    || currentPoint.x - x0 > _table.x - cellSide.x\n    || currentPoint.y - y0 > _table.y - cellSide.y\n    )\n    {\n        waveWarp = vec2(0.0,0.0);\n        edgeWarp = -(bubbleWarp+waveWarp);\n    }\n    else\n    {\n        float lNorth = (y0 + _table.y - currentPoint.y - cellSide.y)/cellSide.y;//how far is the edge\n        float lWest = (currentPoint.x - x0 - cellSide.x)/cellSide.x;\n        float lSouth = (currentPoint.y - y0 - cellSide.y)/cellSide.y;\n        float lEast = (x0 + _table.x - currentPoint.x - cellSide.x)/cellSide.x;\n        float minL = min(min(lNorth,lWest),min(lSouth,lEast));\n    \n        if (minL == lNorth && minL<4.0)\n        {\n            //edgeWarp = -(1.0-minL/4.0)*(bubbleWarp + waveWarp);\n            edgeWarp = -(1.0 - sin(3.1415926/2.0*minL/4.0))*(bubbleWarp + waveWarp);\n        }\n        else\n        if (minL == lWest && minL<4.0)\n        {\n            //edgeWarp = -(1.0-minL/4.0)*(bubbleWarp + waveWarp);\n            edgeWarp = -(1.0 - sin(3.1415926/2.0*minL/4.0))*(bubbleWarp + waveWarp);\n        }\n        else\n        if (minL == lSouth && minL<4.0)\n        {\n            //edgeWarp = -(1.0-minL/4.0)*(bubbleWarp + waveWarp);\n            edgeWarp = -(1.0 - sin(3.1415926/2.0*minL/4.0))*(bubbleWarp + waveWarp);\n        }\n        else\n        if (minL == lEast && minL<4.0)\n        {\n            //edgeWarp = -(1.0-minL/4.0)*(bubbleWarp + waveWarp);\n            edgeWarp = -(1.0 - sin(3.1415926/2.0*minL/4.0))*(bubbleWarp + waveWarp);\n        }\n        else\n        {\n            edgeWarp = vec2(0.0,0.0);//error\n        }\n    \n    }\n    \n    \n    vec2 result = vec2(currentPoint.x + bubbleWarp.x + waveWarp.x + edgeWarp.x, currentPoint.y+bubbleWarp.y  + waveWarp.y + edgeWarp.y);\n    \n    return result;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    set();\n    \n    vec2 directionPoint = updateDirectionPoint();\n    vec2 powerPoint = updatePowerPoint();\n    \n    vec2 currentPoint = fragCoord.xy;\n    \n    currentPoint = Wrap(currentPoint, directionPoint, powerPoint);\n    \n    currentPoint = currentPoint.xy / _screen.xy;\n    vec4 table = texture(iChannel0, currentPoint);\n    //vec4 point = texture(iChannel1, currentPoint);\n    \n    //fragColor = sum(table, point);\n    fragColor = table;\n}","name":"Buffer D","description":"","type":"buffer"}]}