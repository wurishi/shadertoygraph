{"ver":"0.1","info":{"id":"lslfz4","date":"1495145271","viewed":215,"name":"my avatar","username":"wutzhuhn","description":"I used a signed distance field to render the general shape to a buffer, then in the second step I generate a normal based on the gradient and do some normal-based lighting. There is also some light grain added to the image to avoid banding in the light.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","normalmap","signeddistancefield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14\n#define roundnes 0.025\n\nfloat merge(float a, float b) {\n\treturn max(min(a, b), roundnes) - length(max(vec2(roundnes) - vec2(a, b), vec2(0.0)));\n}\n\nfloat substract(float a, float b) {\n\treturn max(-a, b);\n}\n\nfloat intersect(float a, float b) {\n\treturn min(max(a, b), -roundnes) + length(max(vec2(roundnes) + vec2(a, b), vec2(0.0)));\n}\n\nvec2 rotate(vec2 p, float a) {\n    float sa = sin(a), ca = cos(a);\n\treturn p * mat2(ca, -sa, sa, ca);\n}\n\nfloat circle(vec2 p, float radius) {\n\treturn length(p) - radius;\n}\n\nfloat box(vec2 p, vec2 size) {\n\tvec2 d = abs(p) - size + roundnes;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - roundnes;\n}\n\nfloat shapeDist(vec2 p) {\n\treturn\n      intersect(\n        substract(\n          circle(p, 0.75),\n          merge(\n            min(\n              box(\n                rotate(p, PI / 6.0),\n                vec2(0.125, 1.25)),\n              min(\n                box(\n                  p,\n                  vec2(0.125, 1.25)),\n                box(\n                  rotate(p, -PI / 6.0),\n                  vec2(0.125, 1.25)))),\n              circle(p, 1.0))),\n        circle(\n          p - vec2(0.0, -1.25),\n          1.0));\n}\n\nfloat maskSharp(vec2 p) {\n    return clamp(shapeDist(p - vec2(0.0, 0.5)) * 400.0, 0.0, 1.0);\n}\n\nfloat maskBlurry(vec2 p) {\n    return clamp((shapeDist(p - vec2(0.0, 0.5)) + 0.003) * 75.0, 0.0, 1.0);\n}\n\nvec3 normalAt(vec2 p) {\n    float ps = 1.0 / iResolution.x;\n    float x = maskBlurry(p - vec2( ps, 0.0)) - maskBlurry(p + vec2( ps, 0.0));\n    float y = maskBlurry(p - vec2(0.0,  ps)) - maskBlurry(p + vec2(0.0,  ps));\n    return normalize(vec3(x, y, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 p = fragCoord * 2.0 / iResolution.xx - 1.0;\n\n    vec3 lightPos = vec3(cos(iTime), sin(iTime), 1.0);\n    vec3 toLight = lightPos - vec3(p, 0.0);\n    vec3 normal = normalAt(p);\n    float shade = 0.3 + maskSharp(p) * 0.7;\n    vec3 color = vec3(clamp(dot(normalize(toLight), normal), 0.0, 1.0) / length(toLight)) * shade;\n    vec3 noise = vec3((texture(iChannel0, p * 4.0).x - 0.5) / 32.0);\n\n\tfragColor = vec4(color + noise, 1.0);\n}","name":"Image","description":"","type":"image"}]}