{"ver":"0.1","info":{"id":"XdXczf","date":"1489054369","viewed":178,"name":"american flag","username":"vooku","description":"task for a job offer from avocode.com","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["flag","america"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// American flag according to 4 U.S. Code § 1 and Standard Color Reference of America\n// Author: Vadim Petrov\n// Date: 3/2017\n\nconst float PI = 3.14159;\nconst vec4 RED = vec4(0.698, 0.132, 0.203, 1.0);\nconst vec4 BLUE = vec4(0.234, 0.233, 0.430, 1.0);\nconst vec4 WHITE = vec4(1.0);\nconst vec4 BLACK = vec4(0.0, 0.0, 0.0, 1.0);\n\n// Point / triangle intersection\n// Thanks to Christer Ericson – Real-Time Collision Detection\n// Using barycentric coords and solving resulting equations with Cramer's rule\nbool inTriangle(vec2 p, vec2 a, vec2 b, vec2 c) {\n    vec2 v0 = b - a;\n    vec2 v1 = c - a;\n    vec2 v2 = p - a;\n\t\n    float d00 = dot(v0, v0);\n    float d01 = dot(v0, v1);\n    float d11 = dot(v1, v1);\n    float d20 = dot(v2, v0);\n    float d21 = dot(v2, v1);\n    \n    float denom = d00 * d11 - d01 * d01;\n    float v = (d20 * d11 - d21 * d01) / denom;\n    float w = (d00 * d21 - d01 * d20) / denom;\n        \n    return (v >= 0.0 && w >= 0.0 && v + w < 1.0);\n}\n\n// Point / star intersection\n// Using polar coords to determine circle segment and testing for two triangles only\n// Could be faster with precalculated values, more precise this way\nbool inStar(vec2 uv, float x, float y, float r) {\n    const float a1 = 0.4 * PI;\n    const float a2 = 0.1 * PI;\n    const float a3 = a1 - a2;\n    const float a4 = 0.5 * PI;\n    //const float k = sqrt(sin(a2) * cos(a3) / sin(a3) * sin(a2) * cos(a3) / sin(a3) + sin(a2) * sin(a2));\n    const float k = 0.382;\n    \n    vec2 a = vec2(x, r + y);\n    vec2 b = vec2(-cos(a3) * k * r + x, sin(a3) * k * r + y);\n    vec2 c = vec2(x, y);\n    vec2 d = vec2(cos(a3) * k * r + x, sin(a3) * k * r + y);\n    \n    vec2 v = uv - vec2(x, y);\n    float len = length(v);\n    v /= len;\n    float neg = float(v.y < 0.0);\n    float amod = mod(acos((uv.x - x) / len) - a3 - neg * 2.0 * a3, a1) + a3;\n    vec2 uvmod;\n    uvmod.x = cos(amod) * len + x;\n    uvmod.y = sin(amod) * len + y;\n    \n    bool t1 = inTriangle(uvmod, b, c, d);\n    bool t2 = inTriangle(uvmod, a, b, d);\n    \n    return t1 || t2;\n}\n\n// Helper function for star anti-aliasing\nvec4 supersample(vec2 uvmod, float x, float y, float k) {\n\treturn (float(inStar(uvmod, x, y, k)) +\n            float(inStar(uvmod + vec2(0.5 / iResolution.x, 0.0), x, y, k)) +\n            float(inStar(uvmod + vec2(0.0, 0.5 / iResolution.y), x, y, k)) + \n            float(inStar(uvmod + vec2(0.5 / iResolution.x, 0.5 / iResolution.y), x, y, k))) * 0.25 * WHITE;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= 1.9;\n    \n    float h = iResolution.x / 1.9; // flag height\n    \n    float ymin = (iResolution.y - h) / (2.0 * iResolution.y);\n    float ymax = (iResolution.y + h) / (2.0 * iResolution.y);\n    float l = (1.0 - 2.0 * ymin) / 13.0; // stripe height\n\tvec2 uvmod;\n    uvmod.y = mod(uv.y - ymin, 2.0 * l);\n    \n    // stripes\n    fragColor = uv.y > ymin && uv.y < ymax ? RED : vec4(0.0);\n    fragColor += uvmod.y > l && uvmod.y < 2.0 * l && uv.y > ymin && uv.y < ymax ? WHITE : BLACK;\n    \n    // canton\n    float c_w = 0.76; // canton width\n    fragColor = clamp(fragColor, vec4(0.0), vec4(1.0));\n    fragColor -= uv.y >= ymin + 6.0 * l && uv.y < ymax && uv.x < c_w ? WHITE : BLACK;\n    fragColor = clamp(fragColor, vec4(0.0), vec4(1.0));\n    fragColor += uv.y >= ymin + 6.0 * l && uv.y < ymax && uv.x < c_w ? BLUE : BLACK;\n    \n    // stars\n    float g = 0.0633; // horizontal distance between stars\n    float e = 0.7 * l; // vertical distance between stars\n    float k = 0.4 * l; // star radius\n    \n    uvmod.x = mod(uv.x - g, 2.0 * g);\n    uvmod.y = mod(uv.y - e - ymin - 6.0 * l, 2.0 * e);\n    \n    bool inCanton = uv.x > k && uv.x <= 11.0 * g + k && uv.y >ymin + 6.0 * l && uv.y < ymax;\n    \n    fragColor += inCanton ? supersample(uvmod, 0.0, 0.0, k) : BLACK;\n    fragColor += inCanton ? supersample(uvmod, 2.0 * g, 0.0, k) : BLACK;\n    fragColor += inCanton ? supersample(uvmod, 2.0 * g, 2.0 * e, k) : BLACK;\n    fragColor += inCanton ? supersample(uvmod, 0.0, 2.0 * e, k) : BLACK;\n    \n    inCanton = uv.x > k && uv.x <= 11.0 * g + k && uv.y > ymin + 6.0 * l + e && uv.y < ymax - e;\n    fragColor += inCanton ? supersample(uvmod, g, e, k) : BLACK;\n    \n    fragColor = clamp(fragColor, vec4(0.0), vec4(1.0));\n}\n\n","name":"Image","description":"","type":"image"}]}