{"ver":"0.1","info":{"id":"M3lczH","date":"1725881292","viewed":38,"name":"Rectangle Truchet Reproduction","username":"chronos","description":"Saw the rectangle tree truchet pattern by snoopetheduck.\nClick to show rectangle subdivision tree.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["tree","truchet","rectangle","subdivision","weave","reproduction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n    \"Reproduction of \"RectSubdivide Multiscale Truchet\" by SnoopethDuckDuck\" by chronos\n    ----------------------------------------------------------------------------------\n    \n    Tried to code this pattern myself after learning from the original shader.\n    It's not as good as Snoopeth's, but close enough for me! ¯\\_(ツ)_/¯\n    \n    See SnoopethDuckDuck's original shader here: https://www.shadertoy.com/view/XfSBWV\n    \n    ----------------------------------------------------------------------------------\n*/\n\n#define TRANSPARENT_DISCS 0\n#define ALLOW_MIDDLE_DISCS 0\n\nconst float gridsize = 20.;\nconst int num_iterations = 3;\n    \n    \nvec2 split_wh(vec2 uv, vec2 wh, vec2 p)\n{\n    wh.x = uv.x < p.x ? p.x : wh.x - p.x;\n    wh.y = uv.y < p.y ? p.y : wh.y - p.y;\n    return wh;\n}\n\nvec2 split_uv(vec2 uv, vec2 p)\n{\n    uv.x = uv.x < p.x ? uv.x : uv.x - p.x;\n    uv.y = uv.y < p.y ? uv.y : uv.y - p.y;\n    return uv;\n}\n\nvec2 split_id(vec2 uv, vec2 p)\n{\n    uv.x = uv.x < p.x ? 0. : 1.;\n    uv.y = uv.y < p.y ? 0. : 1.;\n    return uv;\n}\n\nvec3 id_to_color(vec2 ids)\n{\n    return pow(texelFetch(iChannel0, ivec2(ids), 0).rgb, vec3(2.));\n}\n\nint ids_to_id(vec2 ids, int iter)\n{\n    ivec2 IDs = ivec2(ids);\n    int id = (IDs.y << iter) + IDs.x;\n    return id;\n}\n\nivec4 permutation(int id)\n{\n    ivec4 perm = ivec4(0,1,2,3);\n    \n    ivec4[24] all_permutations = ivec4[](\n        perm.xyzw,\n        perm.xywz,\n        perm.xzyw,\n        perm.xzwy,\n        perm.xwyz,\n        perm.xwzy,\n\n        perm.yxzw,\n        perm.yxwz,\n        perm.yzxw,\n        perm.yzwx,\n        perm.ywxz,\n        perm.ywzx,\n\n        perm.zyxw,\n        perm.zywx,\n        perm.zxyw,\n        perm.zxwy,\n        perm.zwyx,\n        perm.zwxy,\n\n        perm.wyzx,\n        perm.wyxz,\n        perm.wzyx,\n        perm.wzxy,\n        perm.wxyz,\n        perm.wxzy\n    );\n    \n    return all_permutations[id%24];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    uv = (uv + 1.) / 2.;\n    vec2 UV = uv;\n    float ps = 1. / iResolution.y;\n\n    vec3 color = vec3(0);\n\n    vec2 p   = vec2(0);\n    vec2 ids = vec2(0);\n\n    vec2 wh = vec2(1);\n    for(int i = 0; i < num_iterations; i++)\n    {\n        p   = ((1./gridsize) + (1.-2./gridsize) * texelFetch(iChannel0, ivec2(ids), 0).rg) * wh;\n        \n        p = round(gridsize * p) / gridsize;\n                \n        ids = ids * 2. + split_id(uv, p);\n        wh  = split_wh(uv, wh, p);\n        uv  = split_uv(uv, p);\n  \n        if(min(wh.x, wh.y) <= 2./gridsize) break;\n    }\n\n    color += \n        smoothstep(0.25-gridsize*ps, 0.25+gridsize*ps, fract(gridsize * (wh.x < wh.y? uv.y : uv.x))) * \n        smoothstep(0.75+gridsize*ps, 0.75-gridsize*ps, fract(gridsize * (wh.x < wh.y? uv.y : uv.x)));\n\n    vec2[4] positions = vec2[]( vec2(0), vec2(1,0)*wh, vec2(0,1)*wh, wh );\n\n    float r = min(wh.x, wh.y);\n    int id = ids_to_id(ids, num_iterations);\n    \n    // This allows some of the rectangles to put their discs on the middle of the short edges,\n    // instead of the coners\n    #if ALLOW_MIDDLE_DISCS\n    \n        if(id % 3 == 0)\n        {\n            r/=2.;\n            if(wh.x < wh.y)\n            {\n                positions[0] = vec2(r, 0);\n                positions[1] = vec2(r, 0);\n                positions[2] = vec2(r, wh.y);\n                positions[3] = vec2(r, wh.y);\n            }\n            else\n            {\n                positions[0] = vec2(0, r);\n                positions[1] = vec2(wh.x, r);\n                positions[2] = vec2(0, r);\n                positions[3] = vec2(wh.x, r);\n            }\n        }   \n    \n    #endif\n\n    \n    \n    ivec4 perm = permutation(id);\n    \n    for(int i = 0; i < 4; i++)\n    {\n        vec2 pos = positions[perm[i]];\n        \n        float d = length(uv - pos) - r;\n        \n        //float trim = .125/gridsize; // trims half the black edge\n        //float trim = .25/gridsize;  // trims the entire black edge\n        float trim = .175/gridsize;   // trims the majority of the black edge\n        \n        float pattern = \n            smoothstep(0.25-gridsize*ps, 0.25+gridsize*ps, fract(gridsize * d)) * \n            smoothstep(0.75+gridsize*ps, 0.75-gridsize*ps, fract(gridsize * d));\n        \n        \n        #if TRANSPARENT_DISCS\n        // Cast shadow from white lines\n        color *= \n            mix(1.-\n                smoothstep(0.1 -gridsize*ps, 0.25+gridsize*ps, fract(gridsize * d)) * \n                smoothstep(0.9+gridsize*ps, 0.75-gridsize*ps, fract(gridsize * d)),\n            1.,\n            smoothstep(0., trim, d+trim))\n            ;\n            \n        color = mix(color, vec3(1), pattern * smoothstep(ps, -ps, d + trim)); // only draw white lines\n        \n        #else\n        \n        color *= smoothstep(0., trim, d+trim); // disc shadow\n        color = mix(color, vec3(pattern), smoothstep(ps, -ps, d + trim)); // draw pattern on disc\n        #endif\n    }\n\n    if(iMouse.z > 0.)\n    {\n        color += smoothstep(0.95, 1., fract(gridsize * UV).x);\n        color += smoothstep(0.95, 1., fract(gridsize * UV).y);\n\n        color = mix(color, vec3(1), smoothstep(wh.x-0.005-ps, wh.x-0.005, uv.x));\n        color = mix(color, vec3(1), smoothstep(wh.y-0.005-ps, wh.y-0.005, uv.y));\n        \n        color = mix(color, vec3(1), smoothstep(0.005+ps, 0.005, uv.x));\n        color = mix(color, vec3(1), smoothstep(0.005+ps, 0.005, uv.y));\n        \n        color = color*.8 +.2;\n        color *= id_to_color(ids);\n    }\n    \n    color *= step(0., min(UV.x, 1.-UV.x));\n    color = pow(color, vec3(1./2.2));\n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}