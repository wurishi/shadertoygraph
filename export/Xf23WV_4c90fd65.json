{"ver":"0.1","info":{"id":"Xf23WV","date":"1704646538","viewed":22,"name":"planet s23121","username":"nayk","description":"planet,stars, galaxy, copypast,","likes":2,"published":1,"flags":1,"usePreview":0,"tags":["planet","galaxy","stars","copypast"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam;\n            // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.2-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.0050,1.);\t\n}\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(13,23,31))*.5+.5)\n\n\nfloat zoom2=1.;\n\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\n\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n\th = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\nfloat map(in vec3 p) {\n\t\n\tfloat res = 0.;\n\t\n    vec3 c = p;\n\tfor (int i = 0; i < 15; ++i) {\n        p =.7*abs(p)/dot(p,p) -.2;\n        p.yz= csqr(p.yz);\n        p=p.zxy;\n        res += exp(-19. * abs(dot(p,c)));\n        \n\t}\n\treturn res/2.;\n}\n\n\n\nvec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax )\n{\n    float t = tminmax.x;\n    float dt = .02;\n    //float dt = .2 - .195*cos(iTime*.05);//animated\n    vec3 col= vec3(0.);\n    float c = 0.;\n    for( int i=0; i<64; i++ )\n\t{\n        t+=dt*exp(-2.*c);\n        if(t>tminmax.y)break;\n                \n        c = map(ro+t*rd);               \n        \n        col = 0.99*col+ .08*vec3(c*c, c, c*c*c);//green\t\n        //col = .99*col+ .08*vec3(c*c*c, c*c, c);//blue\n    }    \n    return col;\n}\nmat2 rotate2D(float r) {\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,iTime*0.01);\n\tfloat time=iTime*speed+.25;\n    vec4 O = fragColor;\n    vec2 C=fragCoord;\n O=vec4(0);\n    \n    float time2 = iTime;\n    vec2 q = C.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.);\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\n    m-=.5;\n\n    // camera\n\n    vec3 ro = zoom*vec3(4.);\n    ro.yz*=rot(m.y);\n    ro.xz*=rot(m.x+ 1.1*time);\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 3.0*ww );\n\n    \n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,2.) );\n\n\t// raymarch\n    vec3 col = raymarch(ro,rd,tmm);\n  \n  \n        vec3 nor=(ro+tmm.x*rd)/2.;\n        nor = reflect(rd, nor);        \n        float fre = pow(.5+ clamp(dot(nor,rd),0.0,5.0), 3. )*1.3;\n      \n    \n    \n\t\n\t// shade\n    \n    col =  .5 *(log(1.+col));\n    col = clamp(col,0.,1.);\n   vec3 n,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<110.;\n        O.xyz+=mix(vec3(1),H(g*.1),sin(.8))*1./e/8e3\n    )\n    {\n        n=g*d;\n        n.z+=iTime*1.0;\n       \n        a=20.;\n        n=mod(n-a,a*2.)-a;\n        s=4.;\n        for(int i=0;i++<8;){\n            n=.3-abs(n);\n            \n            n.x<n.z?n=n.zyx:n;\n            n.z<n.y?n=n.xzy:n;\n            n.y<n.x?n=n.zyx:n;\n            \n            s*=e=1.4+sin(iTime*.234)*.1;\n            n=abs(n)*e-\n                vec3(\n                    4.+cos(iTime*.11+2.1*cos(iTime*.205))*3.,\n                    70.+cos(iTime*.25)*5.,\n                    10.+cos(iTime*.25)*5.\n                 )*col ;\n         }\n        \n         g+=e=length(n.yx)/s;\n    }\n\t\n    \n    \n    \n\tvec3 from=vec3(1.,.5,0.5)*O.xyz;\n\tfrom+=vec3(time*2.,time,-2.);\n\t\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\t\n    fragColor+=O;\n}\n","name":"Image","description":"","type":"image"}]}