{"ver":"0.1","info":{"id":"MtdXz7","date":"1478880345","viewed":312,"name":"Sphere to Plane Transition","username":"Ark","description":"A transition by a homeomorphism between the sphere in R^3 with a single point removed and the set of all points in R^2.\n「球面上から一点を取り除いた集合」と「平面上の点全体」の間の同相写像による遷移","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["transition"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define INF 1e10\n#define EPS 1e-2\n#define PI 3.14159265359\n\nstruct Camera{\n    vec3 pos;\n    vec3 dir;\n    vec3 up;\n    vec3 side;\n    float focus;\n} camera;\n\nstruct Ray {\n    vec3 dir;\n} ray;\n\nstruct Light{\n    vec3 pos;\n} light;\n\nstruct Intersection{\n    vec3 pos;\n    vec3 diffuseColor;\n    vec3 specularColor;\n    vec3 ambientColor;\n    float specularPower;\n} intersection;\n\nvoid setPhong() {\n    intersection.diffuseColor = vec3(0.2, 0.4, 0.7);\n    intersection.specularColor = vec3(1.0, 1.0, 1.0) * 0.9;\n    intersection.ambientColor = vec3(0.0, 0.02, 0.10);\n    intersection.specularPower = 20.0;\n}\n\nvec3 convert(float r, float theta, float phi, float a) {\n    float x = r*sin(theta)*cos(phi);\n    float y = r*sin(theta)*sin(phi);\n    float z = r*cos(theta);\n    \n    float h = -1.0;\n    float t = (z-r)/(h-r);\n    float _x = x/t;\n    float _y = y/t;\n    \n    vec3 v1 = vec3(x, y, z);\n    vec3 v2 = vec3(_x, _y, h);\n    \n    //return mix(v1, v2, a);\n    return clamp(mix(v1, v2, a), -vec3(INF), vec3(INF));\n}\n\nvoid init(vec2 pos) {\n    float phi = PI*iTime/6.0;\n    float theta = mix(EPS, PI-EPS, sin(PI*iTime/13.0)*0.5+0.5);\n    camera.pos = convert(3.0, theta, phi, 0.0);\n    //camera.pos = vec3(3.0, 0.0, 2.0);\n    camera.dir = normalize(-camera.pos);\n    camera.side = normalize(cross(camera.dir, vec3(0.0, 0.0, 1.0)));\n    camera.up = normalize(cross(camera.side, camera.dir));\n    camera.focus = 1.8;\n    light.pos = vec3(15.0, 20.0, 5.0);\n    ray.dir = normalize(camera.side*pos.x + camera.up*pos.y + camera.dir*camera.focus);\n    setPhong();\n}\n\nfloat capsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p-a;\n    vec3 ba = b-a;\n    float h = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n    return max(0.0, length(pa - ba*h) - r);\n}\n\nfloat torus(vec3 p, float r1, float r2) {\n    vec2 q = vec2(length(p.xy)-r1, p.z);\n    return abs(length(q)-r2);\n}\n\nfloat getT() {\n    return pow(sin(iTime/3.0), 4.0);\n}\n\nfloat dist(vec3 pos) {\n    float res = INF;\n    \n    const float r = 1.0;\n    \n///*\n    const int N = 36;\n    const float weight = 0.02;\n    \n    for(int i=0; i<N; i++) {\n        float theta = mix(0.1, PI, float(i)/float(N));\n        vec3 v = convert(r, theta, 0.0, getT());\n        float d = torus(pos-vec3(0.0, 0.0, v.z), length(v.xy), weight);\n        res = min(res, d);\n    }\n//*/    \n/*\n    const int num1 = 8;\n    const int num2 = 12;\n    const float weight = 0.05;\n    for (int i=0; i<num1; i++) {\n        for (int j=0; j<num2; j++) {\n            float phi1 = mix(0.0, 2.0*PI, float(i)/float(num1));\n            float phi2 = mix(0.0, 2.0*PI, float(i+1)/float(num1));\n            float theta1 = mix(0.1, PI, float(j)/float(num2));\n            float theta2 = mix(0.1, PI, float(j+1)/float(num2));\n            vec3 v1 = convert(r, theta1, phi1, getT());\n            vec3 v2 = convert(r, theta1, phi2, getT());\n            vec3 v3 = convert(r, theta2, phi1, getT());\n            float d1 = capsule(pos, v1, v2, weight);\n            float d2 = capsule(pos, v1, v3, weight);\n            res = min(res, min(d1, d2));\n        }\n    }\n*/\n    \n    return res;\n}\n\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        dist(p+vec3(EPS,0,0)) - dist(p),\n        dist(p+vec3(0,EPS,0)) - dist(p),\n        dist(p+vec3(0,0,EPS)) - dist(p)\n    ));\n}\n\nvec3 calc() {\n    \n    float t = 0.0, d;\n    intersection.pos = camera.pos;\n    const int N = 24;\n    for(int i=0; i<N; i++) {\n        d = dist(intersection.pos);\n        if (abs(d) < EPS) break;\n        t += d*0.9+EPS;\n        intersection.pos = camera.pos + t*ray.dir;   \n    }\n    \n    vec3 n = getNormal(intersection.pos);\n    vec3 lightDir = - normalize(intersection.pos - light.pos);\n    vec3 eyeDir = - normalize(intersection.pos - camera.pos);\n    float diffuse = clamp(dot(n, lightDir), 0.0, 1.0);\n    float specular = pow(clamp(dot(n, normalize(lightDir+eyeDir)), 0.0, 1.0), intersection.specularPower);\n    float ambient = 1.0;\n\n    if (abs(d) < EPS) {\n        return vec3(diffuse * intersection.diffuseColor + specular * intersection.specularColor + ambient * intersection.ambientColor);\n    } else {\n        return vec3(0.1);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (2.0*fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    init(uv);\n    \n    vec3 col = calc();\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}