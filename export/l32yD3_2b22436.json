{"ver":"0.1","info":{"id":"l32yD3","date":"1727836390","viewed":32,"name":"Skully McPumpkin Loopa","username":"valalalalala","description":"Super spooky! Rather kooky! Somewhat ooky!","likes":5,"published":1,"flags":16,"usePreview":0,"tags":["raymarching","skull","pumpkin"],"hasliked":0,"parentid":"ctBXzm","parentname":"Grundschattierer"},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"     ////////////////////////////////////////////////////////////\n    //                                                       ////\n   // \"Skully McPumpkin Loopa\"                              // //\n  //  by Val \"valalalalala\" GvM ðŸ’ƒ 2024                    //  //\n //                                                       //  //\n///////////////////////////////////////////////////////////  //\n//                                                       // //\n// Creative Commons Attribution-NonCommercial-ShareAlike ////\n// 3.0 Unported License                                  ///\n//                                                       //\n//////////////////////////////////////////////////////////\n\nfloat tTime;\n\n//based off fLineSegment + madness\nfloat linor(vec3 p, vec3 a, vec3 b, float r1, float r2, float power ) {\n    vec3 ab = b - a;\n    float t = saturate(dot(p - a, ab) / dot(ab, ab));\n    float r = mix( r1, r2, pow( t, power ) );\n    return length((ab*t + a) - p) -r;\n}\n\nfloat linor(vec3 p, vec3 a, vec3 b, float r1, float r2 ) {\n    return linor( p, a, b, r1, r2, EINS );\n}\n\n// polynomial smooth min (k = 0.1); iq\nfloat smin( float a, float b, float k ){\n    if(keyToggle(13,iChannel1)) return min(a,b);\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smin( float a, float b ) {\n    return smin( a, b, .1 );\n}\n\n// https://www.shadertoy.com/view/MltcDB\nfloat ellipsoid(vec3 p, vec3 r){\n    float lg = length(p /(r * r));\n\treturn (length(p / r) - 1.) * (length(p / r)) / lg;\n\t//return (length(p / r) - 1.) * (r.x + r.y + r.z) / 3.;//max(max(r.x, r.y), r.z);\n}\n\nfloat sphere( vec3 p, vec3 center, float radius ) {\n    return length( p - center ) - radius;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b + r;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat skull( vec3 p ) {\n    p.y += .28;\n    vec3 px = p; \n    px.x = abs( px.x );\n\n    float d = 3e3;\n    \n    d = sphere( p, vec3( ZED, .34, .01 ), .305 );  // front of head  \n    d = smin( d, sphere( p, vec3( ZED, .342, -.07 ), .33 ), .02 ); // back of head\n    d = smin( d, sphere( p,  vec3( ZED,-.02, .18 ), .03 ), .31 ); // chin\n    d = smin( d, sphere( px, vec3( .19, .14, .18 ), .033 ), .13 ); // cheek\n    d = smin( d, sphere( px, vec3( .12, .1 , .14  ), .006 ), .211 ); // jaw\n    d = smin( d, ellipsoid( p - vec3( ZED, .13, .21 ), vec3( .090, .091, .07) ), .104 ); // mouth barrel    \n    //d = smin( d, lipDistance( p, .95 ), .005 ); // bring in lips\n\n    d = smin( d, linor( px, vec3( .06, .40, .26 ), vec3( .1931, .41, .12 ), .015, .012 ), .13 ); // brows\n\n    float eyes = sdRoundBox(\n        px - vec3(.11,.28, .1)\n        + vec3(\n        .0, px.x * .21, .0\n        )\n        , \n        vec3(.08, .06, .26), \n        .06\n    );\n    float nose = linor(\n        p, \n        vec3(.0,.17,.28),\n        vec3(.0,.24,.28),\n        .044,\n        .022\n    );\n    float neg = min(nose, eyes);\n    \n    float tmax = .015;\n    //tmax = .02 * ss(.01, .015, px.x);\n    tmax = .08 * (.4 - 2.3 * px.x);\n    \n    \n    float tgrd = .013 + tmax * step(fract(36.*px.x+.08),.18);\n    float teef = sdRoundBox(\n        px\n        - vec3(.0,.08,.26),\n        vec3(.1,tgrd,.05), .03\n    );\n    neg = min(neg, teef);\n    \n    //linor(vec3 p, vec3 a, vec3 b, float r1, float r2 )\n    d = max(d,-neg);\n    \n    return d;\n}\n\nfloat leaf(vec3 p) {\n    float d;\n    \n    float px = p.y * .3 + p.x *.21 - .08;\n    vec3 pstem = p + vec3(px,.0,.0);\n    pstem -= vec3(.0,.45,.0);\n    float stem = sdRoundBox(\n        pstem,\n        vec3(.1,.2,.1) *.65, .06\n    );\n    \n    vec3 pleaf = p - vec3(.12,.46,.0);\n    pleaf.x += p.y * .1;\n    pleaf.y -= p.x * .6;\n    float leaf = sdRoundBox(\n        pleaf,\n        vec3(.13,.1,.01),\n        .1\n    );\n    \n    d = min(leaf, stem);\n    \n    pleaf = p - vec3(-.08,.46,.10);\n    pleaf.x += p.y * .1;\n    pleaf.y += p.x * .3;\n    float t = pleaf.x;\n    pleaf.x = pleaf.z + t *.7;\n    pleaf.z = t - .03 + p.y *.6 -.28;\n    leaf = sdRoundBox(\n        pleaf,\n        vec3(.131,.12,.01),\n        .12\n    );\n    \n    d = min(leaf, d);\n    \n    return d;\n}\n\nfloat pumpkin(vec3 p) {\n    float a = abs(atan(p.x + .1 * p.z, p.z - .1 *p.x));\n    a = abs(fract(a*1.5)-.5);\n    a = smoothstep(1.,.0,a);\n        \n    float r = .66 + a * .07;\n    r -= .4 * ss(.0,1.,abs(p.y + .4));\n    \n    return length(p) - r;\n}\n\nMapped skullMap(vec3 p) {\n    return Mapped(skull(p), EINS);\n}\n\nMapped pumpkinMap(vec3 p) {\n    Mapped m = Mapped(pumpkin(p), 2.);\n    mino(m, Mapped(leaf(p), 3.));\n    return m;\n}\n\n\n\nMapped omap( vec3 p ) {\n    vec3 s = p - vec3(.5, .0, .0);\n    vec3 o = p + vec3(.5, .0, .0);\n    Mapped m = Mapped(skull(s), EINS);\n    mino(m, pumpkinMap(o));\n    return m;\n}\n\nMapped map( vec3 p ) {\n    float m = 7.;\n    p -= vec3(.0,.0, m);\n    p = MODO(p, m + .88); //+ vec3(.0,.0,1.3);\n\n    Mapped pumpkin = pumpkinMap(p);\n    Mapped skull  = skullMap(p);\n    \n    float t = triangle(iTime * 1.);\n    float s = ss(.0, .6, t * t);\n    float d = mix(pumpkin.depth, skull.depth, s);\n    float c = mix(pumpkin.type, skull.type, s);\n    return Mapped(d, c);\n}\n\nMAP_TIME\n\nvec3 subo( vec3 p ) {\n    // https://www.shadertoy.com/view/MdXSzX\n    #define TRANSMISSION_RANGE .15\n    vec3 lightDir1 = normalize(vec3(3,1,-2));//normalize( V101.xzx );\n    vec3 lightDir2 = normalize(vec3(-3,1,-2));//normalize( V101.zzx );\n    vec3 lightCol1 = vec3(1.1,1,.9)*1.4;\n    vec3 lightCol2 = vec3(.8,.4,.2)*2.0;\n\n    // And sub surface scattering too! Because, why not?\n    float transmissionRange = TRANSMISSION_RANGE;//iMouse.x/iResolution.x;//distance/10.0; // this really should be constant... right?\n    float transmission1 = map( p + lightDir1*transmissionRange ).depth/transmissionRange;\n    float transmission2 = map( p + lightDir2*transmissionRange ).depth/transmissionRange;\n    vec3 sslight = lightCol1 * smoothstep(0.0,1.0,transmission1) + lightCol2 * smoothstep(0.0,1.0,transmission2);\n    vec3 subsurface = vec3(1,.8,.5) * sslight;\n    return subsurface;\n}\n\n\nvec3 matte( vec3 n, vec3 dir, float type ) {\n    vec3 white = vec3(.88);\n    vec3 orange = vec3(.8,.5,.2);\n    vec3 green = vec3(.3, .4, .3);\n    vec3 color = mix(white,orange,step(1.1,type));\n    color = mix(color, green, step(2.2, type));\n    \n    return dot( n, -dir ) * color;\n}\n\nvec3 textme( vec3 dir, float time ) {\n    return texture( iChannel0, dir + time *.066 ).rgb;\n}\n\nvec3 textme( vec3 dir ) {\n    return textme( dir, tTime );\n}\n\nvec3 shiny( vec3 p, vec3 n, vec3 dir, float type ) {\n    n += 3.3 * noise_iq( 3.3 * order( abs( p + tTime ) ).xy );\n    float l = dot( n, -dir );\n    vec3 color = matte(n, dir, type);\n \n    vec3 rDir = reflect( dir, n );\n    float fresnel = clamp( ZED, 1.88, pow( EINS + l, 5. ) );\n\n    return mix( color, textme( rDir ), fresnel * .1);\n}\n\nvec3 toon( vec3 p, vec3 n, vec3 dir, float type ) {\n    float l = floor( dot( n, -dir + vec3(.2,.02,.2) ) * 4. ) / 4. ;\n    vec3 color = matte(n, dir, type);\n    return color * l * 2.;\n}\n\nvec3 demo( in vec2 st ) {\n    INIT_SHADER_ENVIRONMENT(st)\n    \n    tTime = triangle( iTime * .2 );\n  \n    vec3 color;\n    Ray ray = makeRay( env );\n    Marched marched = march( ray );\n\n    if ( marched.hit ) {\n        vec3 p = marched.p;\n        vec3 n = mapNormal( p, marched.depth );\n        int w = int(iTime * .22) % 3;\n        switch(w) {\n            case 0: \n                color = matte(n, ray.dir, marched.mapped.type);\n                break;\n            case 1:\n                color = shiny( p, n, ray.dir, marched.mapped.type );\n                break;\n            default:\n                color = toon( p, n, ray.dir, marched.mapped.type );\n        }\n    } else {\n        color = mix( textme( ray.dir, ZED ).rgb, V101.yyy, step( marched.edgeDepth, ZED ) );\n    }    \n    \n    return color;\n}\n\nvoid mainImage( out vec4 result, in vec2 st ){    \n    result = vec4( demo( st ), 1. );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"////////////////////////////////////////////////////////////////////////////////////\n\nconst float TAU = 99733. / 15873., ZED = .0, HALB = .5, EINS = 1., PI  = HALB * TAU;\n\nconst vec3 V101 = vec3( -EINS, ZED, +EINS );\nconst vec3 V000 = vec3( ZED );\n\nconst float EPSILON = .001, ZFAR = 199., VIEW_DISTANCE = 5.5;\n#define _EDGE_THICKNESS 0.022 *3.\n\nconst vec3 MAGIC = vec3( TAU * 3.3, 99.733, 15873. );\n\n////////////////////////////////////////////////////////////////////////////////////\n\nvec2 pixelToUv( vec2 st, vec2 resolution ) {\n    return ( st * 2. - resolution.xy ) / min( resolution.x, resolution.y );\n}\n\nfloat absMod( float f, float m ) {\n    return abs( mod( f, m ) - m *.5 );\n}\n\nfloat scalo( float f, float s ) {\n    return f * s - .5 * s;\n}\n\nfloat invert( float f ) {\n    return 1. - f;\n}\n\nfloat modScale( float f, float s ) {\n    return mod( f, s ) / s;\n}\n\n\n#define saturate(x) clamp(x, ZED, EINS)\n#define ss smoothstep\n\n#define cost( x ) triangle( x )\n#define sint( x ) triangle( x + TAU * .75 )\n#define coso( x ) triangle( x + TAU * .25 )\nfloat triangle( float x ) {\n    return 4. * abs( modScale( x, TAU ) - .5 ) -1.;\n}\n#define SCALE_AND_OFFSET(v,o)   (o + v * o) \n#define MODO(v,f)  (mod((v)+.5*(f),f)-.5*(f))\n#define MIN3(v)    min(v.x,min(v.y,v.z))\n\nvec3 colorF( float f ) {\n    return SCALE_AND_OFFSET( vec3( cost( f ), sint( f ), coso( f ) ), .5 );\n}\n\n/////////////////////////////////////////////////////////////////////\n\nfloat magicFloat( vec2 uv ) {\n    return dot( uv, MAGIC.xy );\n}\n\n// really a lot like just regular fract based hash :-P\nfloat triangleHash( float f ) {\n    return fract( triangle( f * MAGIC.x ) * f * MAGIC.z * .133 );\n}\n\nfloat triangleHash( vec2 uv ) { \n    return triangleHash( magicFloat( uv ) );\n}\n\n////////////////////////////////////////////////////////////////\n// IQ's https://www.shadertoy.com/view/XdXGW8, gradient - 2D \nvec2 hash( in vec2 p ) {\n    return vec2( triangleHash( p.xy ), triangleHash( p.yx ) );\n}\nfloat noise_iq( in vec2 p ){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n/////////////////////////////////////////////////////////////////////\n\n\nvec2 trig( float angle ) {\n    return vec2( cos( angle ), sin( angle ) );\n}\n\n/////////////////////////////////////////////////////////////////////\n\nvec3 order( vec3 p )  {\n    vec3 q = vec3( min( p.x, min( p.y, p.z ) ), .0, max( p.x, max( p.y, p.z ) ) );\n    q.y = ( p.x + p.y + p.z ) - ( q.x + q.z );\n    return q;  \n}\n\n/////////////////////////////////////////////////////////////////////\n\nbool keyToggle( int key, sampler2D keyboardChannel ) {\n    return .0 < texelFetch( keyboardChannel, ivec2(key,2), 0 ).x;\n}\n\n/////////////////////////////////////////////////////////////////////\n\nconst int MOUSE_UP = -1, MOUSE_DOWN = 1, MOUSE_CLICKED = 2;\n\nstruct ShadEnv {\n    vec3      iResolution;           // viewport resolution (in pixels) \n    float     iTime;                 // shader playback time (in seconds)\n    float     iTimeDelta;            // render time (in seconds)\n    float     iFrameRate;            // shader frame rate\n    int       iFrame;                // shader playback frame\n    float     iChannelTime[4];       // channel playback time (in seconds)\n    vec3      iChannelResolution[4]; // channel resolution (in pixels) \n    vec4      iMouse;                // mouse pixel coords. xy: current (if MLB down), zw: click\n    vec4      iDate;                 // (year, month, day, time in seconds)\n    float     iSampleRate;           // sound sample rate (i.e., 44100)\n    vec2      st;                    // aka fragCoord\n    vec2      uv;\n    vec2      ms;\n    vec2      trigTime;\n    int       mouseStatus;\n    float     pixel1;\n};\n\n#define INIT_SHADER_ENVIRONMENT(st) ShadEnv env = ShadEnv( iResolution, iTime, iTimeDelta, iFrameRate, iFrame, iChannelTime, iChannelResolution, iMouse, iDate, iSampleRate, st, V101.xy, V101.xy, V101.xy, MOUSE_UP, EINS );     init( env ); \n\nvoid init( inout ShadEnv env ) {\n    env.uv = pixelToUv( env.st, env.iResolution.xy );\n    env.trigTime = trig( env.iTime );\n    env.mouseStatus = MOUSE_UP + int( 2. * step( 3e-3, env.iMouse.z ) + step( 3e-3, env.iMouse.w ) );\n    env.ms = pixelToUv( env.iMouse.xy, env.iResolution.xy ) * step( 3e-3, env.iMouse.z + env.iMouse.w );\n    env.pixel1 = max( EINS / env.iResolution.x, EINS / env.iResolution.y ); \n}\n\n/////////////////////////////////////////////////////////////////////\n\nstruct Ray { \n    vec3 eye; \n    vec3 dir; \n};\n\nmat3 makeCamera( vec3 a, vec3 b, float roll ) {\n    vec3 up = vec3( trig( roll ).yx, ZED );\n\tvec3 z = normalize( b - a );\n\tvec3 x = normalize( cross( z, up ) );\n\tvec3 y = normalize( cross( x, z ) );\n\treturn mat3( x, y, z );\n}\n\nRay makeRay( in ShadEnv env, float depth ) {\n    vec2 t = trig( env.ms.x * PI );\n    vec3 eye = depth * vec3( t.y, sin( env.ms.y * 1.88 ), t.x );    \n    vec3 dir = normalize( makeCamera( eye, V000, ZED ) * vec3( env.uv, EINS ) - eye );\n    \n    return Ray( eye, dir );\n}\n\nRay makeRay( inout ShadEnv env ) {\n    return makeRay( env, VIEW_DISTANCE );\n}\n\n/////////////////////////////////////////////////////////////////////\n\nstruct Mapped {\n    float depth;\n    float type;\n};\n\nstruct Marched {\n    vec3 p;\n    float depth;\n    bool hit;\n    float edgeDepth;\n    Mapped mapped;\n};\n\nconst int MARCH_CONTINUE = 0, MARCH_SUCCESS = 1, MARCH_FAILED = 2;\n\n///////////////////////////////////////\n\nMapped newMapped( float depth ) { return Mapped( depth, -EINS ); }\nMapped newMapped() { return newMapped( 3e11 ); }\n\nMarched newMarch( Ray ray ) {\n    return Marched( ray.eye, ZED, false, 3e3, newMapped( ZED ) );\n}\n\n///////////////////////////////////////\n\nvoid mino( inout Mapped m, in Mapped q ) {\n    if ( q.depth < m.depth ) {\n        m = q;\n    }\n}\n\n///////////////////////////////////////\n\nint _marchStep( int i, in Ray ray, in float side, inout Marched marched, Mapped mapped ) {\n    marched.mapped = mapped;\n    marched.mapped.depth *= side; // current\n    marched.depth += marched.mapped.depth; // total\n               \n    if ( abs( marched.mapped.depth ) < EPSILON ) {\n        marched.hit = true;\n        return MARCH_SUCCESS;\n    }\n        \n    if ( marched.depth > ZFAR ) return MARCH_FAILED;\n    \n    marched.p = ray.eye + marched.depth * ray.dir;\n\n    #ifdef EDGE_THICKNESS\n        // from ll33Wn, inspired by 4s2XRd ; as usual mine is a bit glitched\n        marched.edgeDepth = min( mapped.depth, marched.edgeDepth );\n        if ( i > 0 && mapped.depth > marched.edgeDepth && marched.edgeDepth < EDGE_THICKNESS ) {\n            marched.edgeDepth = -abs( marched.edgeDepth );\n            return MARCH_SUCCESS;\n        }\n    #endif    \n\n    return MARCH_CONTINUE;\n}\nMarched _marchMissed( in Marched marched ) {\n    marched.depth = -abs( marched.depth );\n    return marched;\n}\n\n///////////////////////////////////////\n\nMapped map( vec3 p ); // implement this, then use this macro: MAP_TIME\n\n#define MAP_TIME \\\nfloat mapDepth( vec3 p ) { return map( p ).depth; } \\\nvec3 mapNormal(vec3 p,float d) {\\\n    mat3 k = mat3(p,p,p) - mat3( d * EPSILON ); \\\n    return normalize( mapDepth(p) - vec3( mapDepth(k[0]), mapDepth(k[1]), mapDepth(k[2])) ); \\\n} \\\nvec3 mapNormal(vec3 p) { return mapNormal(p,EPSILON); }\\\nMarched march( in Ray ray, in float side ) { \\\n    Marched marched = newMarch( ray ); \\\n    for( int i = 0 ; i < int( ZFAR ) ; i++ ) { \\\n        switch( _marchStep( i, ray, side, marched, map( marched.p ) ) ) { \\\n            case MARCH_SUCCESS: return marched; \\\n            case MARCH_FAILED: i = int(ZFAR); \\\n        } \\\n    } \\\n    return _marchMissed( marched ); \\\n} \\\nMarched march( Ray ray ) { return march( ray, EINS ); }\n\n/////////////////////////////////////////////////////////////////////","name":"Common","description":"","type":"common"}]}