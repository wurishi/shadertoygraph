{"ver":"0.1","info":{"id":"Nl2Szw","date":"1627400128","viewed":163,"name":"Little Sines","username":"billowers","description":"Sine bright like a diamond","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["circle","sine","lights","neon","pathing","chasing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926538\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec2 uv = I/(iResolution.xy / 2.0);  // range from 0 to 2, so we can have x in [-1,1], y in [-1,1]\n    uv = uv - vec2(1.0,1.0); // move the origin to the centre of the circle/noramlised space\n    \n    float frequency = 8.0; // number of cycles for sine wave, matches crest & dip counts\n    float amplitude = 0.10; // we actually experience +/- of this value so 2 of it in length\n    \n    float circle_radius = 0.8; // this is the radius of the circle before the sine wave gets involved, account for +/- 1 of the amplitude\n    float edge_width = 0.02; // On a disk this is the fade off at the edge, on a line, this the fade off either side\n    \n    \n    \n    // Disc Version\n    //float colour = smoothstep(circle_radius - edge_width, circle_radius, length(uv) + (sin(atan(uv.y, uv.x) * frequency - 3.141 / 2.0) * amplitude));\n    // NOTE: PI/2 is just a constant that aligns the crests with the x/y axis by rotating in x/y, space, but really just offseting our angle that the sine is driven by\n    \n    // Line Version\n    //colour = smoothstep( 0.0, edge_width, abs( circle_radius - length(uv) + (sin(atan(uv.y, uv.x) * frequency - 3.141 / 2.0) * amplitude)));\n    \n    \n\n    // Lines & Discs\n    // A line we want to be a certain distance either side of the radius\n    // A disc we want to be above and below the radius\n    // Essentially the core difference is either just using the distance from the centre, or the the distance from the radius itself\n    \n    // Circle Line\n    // colour = smoothstep(0.0, 0.01, abs(circle_radius- length(uv)));\n    // This essentially says we only accept points 0.01 from our\n    \n    // Circular Disc\n    // colour = smoothstep(circle_radius - 0.01, circle_radius, length(uv));\n    // 0.01 is the distance of the fade at the egdes for both\n    \n    \n    // Smooth step\n    // everything less than first edge is 0\n    // everything greater than second edge is 1\n    // when inbetween, the interpolate between the two edges to give you values between 0 & 1\n   \n    \n    \n    float centre_angle = atan(uv.y, uv.x);\n    // Using the two argument of atan gives nicer results as it handles some of the jankeness around +/- axes and the undefined point\n    // https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/atan.xhtml\n\n    \n    float sine_distortion_1 =  (sin(centre_angle *  frequency        + iTime) * amplitude);\n    float sine_distortion_2 = -(sin(centre_angle * (frequency / 2.0) + iTime) * amplitude); \n    float sine_distortion_3 =  (sin(centre_angle * (frequency / 4.0) + iTime) * amplitude);\n    float sine_distortion_4 = -(sin(centre_angle * (frequency / 8.0) + iTime) * amplitude);\n    // Can cause desync (disconnect in graph) when uv.x = 0. Depends on if they even or odd frequency divisors and if they sync up or not at that value\n    // Sticking to even divisors of an even frequency is kosher!\n\n    float flare_shape_1 = smoothstep(edge_width, 0.0, abs(circle_radius - 0.25 - length(uv) - sine_distortion_1 + sine_distortion_2));\n    float flare_shape_2 = smoothstep(edge_width, 0.0, abs(circle_radius - 0.18 - length(uv) + sine_distortion_1 + sine_distortion_4));\n    float flare_shape_3 = smoothstep(edge_width, 0.0, abs(circle_radius - 0.11 - length(uv) + sine_distortion_2 + sine_distortion_3));\n    float flare_shape_4 = smoothstep(edge_width, 0.0, abs(circle_radius - 0.03  - length(uv) + sine_distortion_1 + sine_distortion_2 + sine_distortion_3 + sine_distortion_4));\n    \n    //flare_shape_1 = 1. - (1.-flare_shape_1)*(1.-flare_shape_1)*(1.-flare_shape_1)*(1.-flare_shape_1);\n    \n    // Colouring\n    vec4 flare_1 = vec4(flare_shape_1 * vec3(0.1,1.0,1.0), 1.0); // blue\n    vec4 flare_2 = vec4(flare_shape_2 * vec3(0.9,0.1,0.5), 1.0); // pink\n    vec4 flare_3 = vec4(flare_shape_3 * vec3(1.0,1.0,1.0), 1.0); // white\n    vec4 flare_4 = vec4(flare_shape_4 * vec3(1.0,0.9,0.1), 1.0); // yellow\n    \n    \n    // Segment\n    \n    //float moving_angle = mod(iTime, 2. * PI) - PI; // want a value that runs from -PI to PI with time\n    \n    float flare_length = PI;\n    float angle_offset = PI / 6.;\n    \n    float min_angle = mod(iTime * 1.2, 2. * PI) - PI;\n    float max_angle = mod(iTime * 1.2 + flare_length, 2. * PI) - PI;\n    \n    if(min_angle > max_angle)\n    {\n        if(centre_angle < max_angle) centre_angle += 2. * PI;\n        \n        max_angle += 2.* PI;\n    }\n    \n    float visible_angle_distance = (max_angle - min_angle);\n    float t = (centre_angle - min_angle) / visible_angle_distance;\n    \n    t *= t *t; // effect the tail drop off\n    \n    flare_1 *= t* step(min_angle, centre_angle) *step(centre_angle, max_angle);\n    flare_2 *= t* step(min_angle, centre_angle) *step(centre_angle, max_angle);\n    flare_3 *= t* step(min_angle, centre_angle) *step(centre_angle, max_angle);\n    flare_4 *= t* step(min_angle, centre_angle) *step(centre_angle, max_angle);\n   \n    \n    O = flare_1 + flare_2 + flare_3 + flare_4;\n}","name":"Image","description":"","type":"image"}]}