{"ver":"0.1","info":{"id":"ld2yDw","date":"1492451001","viewed":540,"name":"threejs - random dithering","username":"bhouston","description":"experiements with rand","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["dithering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 dither_ceeJay( vec2 fragCoord )\n{\n    //note: from comment by CeeJayDK\n    const float dither_bit = 8.0; //Bit-depth of display. Normally 8 but some LCD monitors are 7 or even 6-bit.\t\n\n    //Calculate how big the shift should be\n    const float dither_shift = (0.25) * (1.0 / (pow(2.0,dither_bit) - 1.0));\n    \n    //Calculate grid position\n    float grid_position = fract( dot( fragCoord.xy - vec2(0.5,0.5) , vec2(1.0/16.0,10.0/36.0) + 0.25 ) );\n\n\n\n    //Shift the individual colors differently, thus making it even harder to see the dithering pattern\n    vec3 dither_shift_RGB = vec3(dither_shift, -dither_shift, dither_shift); //subpixel dithering\n\n    //modify shift acording to grid position.\n    dither_shift_RGB = mix(2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position); //shift acording to grid position.\n\n    //shift the color by dither_shift\n    return 0.5/255.0 + dither_shift_RGB; \n}\n\n\n//note: returns [-intensity;intensity[, magnitude of 2x intensity\n//note: from \"NEXT GENERATION POST PROCESSING IN CALL OF DUTY: ADVANCED WARFARE\"\n//      http://advances.realtimerendering.com/s2014/index.html\nfloat InterleavedGradientNoise( vec2 uv )\n{\n    const vec3 magic = vec3( 0.06711056, 0.00583715, 52.9829189 );\n    return fract( magic.z * fract( dot( uv, magic.xy ) ) );\n}\n\nfloat ThreeJSRand( vec2 uv )\n{\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv, vec2( a,b ) ), sn = mod( dt, 3.141569 );\n\treturn fract(sin(sn) * c);\n}\n\n\nvec3 dither_InterleavedGradientNoise( vec2 uv )\n{\n\treturn vec3( ThreeJSRand( uv ),\n                 ThreeJSRand( uv + 0.1337 ),\n                 ThreeJSRand( uv + 0.89 ) );\n}\n\n//note: remaps [0;1] to triangular [0;1]\nfloat remap_noise_tri_erp( const float v )\n{\n    float r2 = 0.5 * v;\n    float f1 = sqrt( r2 );\n    float f2 = 1.0 - sqrt( r2 - 0.25 );\n    return (v < 0.5) ? f1 : f2;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    const float SCALE = 64.0;\n    \n    float its = uv.x / SCALE;\n    vec3 outcol;\n    if ( uv.y < 1.0/4.0 )\n    {\n        outcol = vec3( its );\n    }\n    else if ( uv.y < 2.0/4.0 )\n    {\n        vec3 rnd = dither_ceeJay( fragCoord.xy );\n        outcol = vec3( its ) + rnd - 0.5/255.0;\n    }\n    else if ( uv.y < 3.0/4.0 )\n    {\n        vec3 rnd = dither_InterleavedGradientNoise( fragCoord.xy );\n        outcol = vec3( its ) + (rnd-vec3(0.5)) / 255.0;\n    }\n    else\n    {\n        vec3 rnd = dither_InterleavedGradientNoise( fragCoord.xy );\n        rnd = vec3( remap_noise_tri_erp( rnd.x ),\n                    remap_noise_tri_erp( rnd.y ),\n                    remap_noise_tri_erp( rnd.z ) );\n        rnd = 2.0 * rnd - vec3(1.0);\n        outcol = vec3( its ) + rnd / 255.0;\n    }\n    \n    //note: manually truncate to 8bit\n    outcol = floor(outcol*255.0 + 0.5) / 255.0;\n    \n    \n    fragColor = vec4( SCALE*outcol, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}