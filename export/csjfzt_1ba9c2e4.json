{"ver":"0.1","info":{"id":"csjfzt","date":"1690049042","viewed":76,"name":"Podka Dots","username":"deditzy","description":"Podka Dots","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["podkadots"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 22./7.;\n\nfloat deg(float ang){\n    return 2. * PI * ang / 360.;\n}\n\n//from https://www.shadertoy.com/view/Xt23Ry\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\nvec3 palette(float t){\n    vec3 a =  vec3(0.5, 0.5, .5); \n    vec3 b = vec3(0.5, 0.5, 0.5); \n    vec3 c = vec3(1.0, 1.9, 1.0); \n    vec3 d = vec3(0.263, 0.416, 0.557);\n    \n    // Testing out color schemes\n    // a =  vec3(0.1, .5, .0); \n    // b = vec3(0.6, 0.5, 0.); \n    // c = vec3(0.9, 1.0, 0.2); \n    // d = vec3(0.3, 1., 0.5);\n\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nfloat c(float x, float y, float r){\n    return r * r - (x * x + y * y);\n}\n\n// My version of teh flimziest hexagon\nfloat hex(float x, float y, float pad){\n    // construction regions\n    float r1 = 0.5 * cos(deg(30.)) - abs(x);\n    float r2 = -tan(deg(30.)) * abs(x) + .5 - abs(y);\n    \n    return smoothstep(pad, pad + 0.0001, min(min(r1, r2),1.));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 uv0 = uv;    \n    \n    uv.y /= 1. + .5 * pow( abs(uv.x), 2.);\n    \n    uv.x -= sin(iTime);\n    uv.y += 0.5 * iTime;\n    \n    // Trying to rotate the grid\n    //uv = mat2(3., 4., -4., 5.) * uv;\n    \n    float scale = 20.;\n    uv *= scale;\n\n    // Time varying pixel color\n    float r = .5;\n    float pad = .01; float thresh = 0.1;\n    \n    float x = uv.x; \n    float y = uv.y;\n    \n    //y += 0.01 * y * pow((scale - abs(x)), 2.);\n    \n    x += r * floor(uv.y);\n    \n    \n    float x0 = x; float y0 = y;\n    \n    x = fract(x) - r;\n    y = fract(y) - r;\n    \n    // Hex\n    float col = hex(x, y, .01);\n    \n    // Dots\n    // float col = c(x, y, r);\n    \n    col = smoothstep(0., 32./iResolution.y, col);\n    // col = smoothstep(thresh, thresh + 0.002 * scale, col);\n    \n    vec3 fcol = palette(length(vec2(floor(abs(x0)), floor(y0))) + iTime * .2) * col;\n    fcol = palette(rand(vec2(floor(x0), floor(y0))) * iTime / 5. + iTime * .2 + 9.23452) * col;\n    // fcol = (0.5 + 0.5*cos(iTime+uv0.xyx+vec3(0,2,4))) * col;\n    \n    // col = uv.x;\n    \n    //fcol*= (uv.y + scale)/scale;\n\n    // Output to screen\n    fragColor = vec4(fcol,1.0);\n}","name":"Image","description":"","type":"image"}]}