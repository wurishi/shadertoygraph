{"ver":"0.1","info":{"id":"4tycRK","date":"1536851251","viewed":351,"name":"Okonomiyaki","username":"FMS_Cat","description":"shitpost","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarcher","food"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://twitter.com/FMS_Cat\n\n// ------\n\n#define MARCH_ITER 50\n#define INIT_LEN 0.01\n#define MARCH_MULT 0.8\n\n#define material float\n#define MTL_NONE 0.0\n#define MTL_BASE 1.0\n#define MTL_HAPPA 3.0\n#define MTL_KATSUO 5.0\n#define MTL_MAYO 192.0\n\n#define V vec2(0.,1.)\n#define PI 3.14159265\n#define HUGE 1E9\n#define saturate(i) clamp(i,0.,1.)\n#define lofi(i,d) floor(i/d)*d\n\n// ------\n\n// 二次元回転行列\nmat2 rotate2D( float _t ) {\n  return mat2(\n    cos( _t ), sin( _t ),\n    -sin( _t ), cos( _t )\n  );\n}\n\n// smooth minimum : https://iquilezles.org/articles/smin\nfloat smin( float _a, float _b, float _k, out float h ) {\n  h = clamp( 0.5 + 0.5 * ( _b - _a ) / _k, 0.0, 1.0 );\n  return mix( _b, _a, h ) - _k * h * ( 1.0 - h );\n}\n\nfloat smin( float _a, float _b, float _k ) {\n  float h;\n  return smin( _a, _b, _k, h );\n}\n\nfloat random( vec2 _uv ) {\n  return fract( sin( dot( vec2( 12.563, 21.864 ), _uv ) ) * 19934.54 );\n}\n\nfloat iRandom( vec2 _uv ) {\n  float v00 = random( floor( _uv + V.xx ) );\n  float v10 = random( floor( _uv + V.yx ) );\n  float v01 = random( floor( _uv + V.xy ) );\n  float v11 = random( floor( _uv + V.yy ) );\n  return mix(\n    mix( v00, v10, smoothstep( 0.0, 1.0, fract( _uv.x ) ) ),\n    mix( v01, v11, smoothstep( 0.0, 1.0, fract( _uv.x ) ) ),\n    smoothstep( 0.0, 1.0, fract( _uv.y ) )\n  );\n}\n\nfloat noise( vec2 _uv ) {\n  float sum = 0.0;\n  for ( int i = 0; i < 4; i ++ ) {\n    float p = pow( 2.0, float( i ) + 1.0 );\n    sum += iRandom( _uv * p * 4.0 ) / p;\n  }\n  return sum;\n}\n\nvec3 rainbow( vec3 _i, float _p ) {\n  float p = fract( _p );\n  return mix(\n    mix(\n      mix(\n        _i.xyz,\n        _i.yzx,\n        saturate( p * 3.0 )\n      ),\n      _i.zxy,\n      saturate( p * 3.0 - 1.0 )\n    ),\n    _i.xyz,\n    saturate( p * 3.0 - 2.0 )\n  );\n}\n\n// ------\n\n// カメラの構造体\nstruct Camera {\n  vec3 pos;\n  vec3 dir;\n  vec3 sid;\n  vec3 top;\n  float fov;\n};\n\n// レイの構造体\nstruct Ray {\n  vec3 dir;\n  vec3 ori;\n};\n\n// ------\n\n// カメラの初期化\nCamera camInit( in vec3 _pos, in vec3 _tar, in float _fov ) {\n  Camera cam;\n  cam.pos = _pos;\n  cam.dir = normalize( _tar - _pos );\n  cam.sid = normalize( cross( cam.dir, V.xyx ) );\n  cam.top = normalize( cross( cam.sid, cam.dir ) );\n  cam.fov = _fov;\n\n  return cam;\n}\n\n// レイの初期化\nRay rayInit( in vec3 _ori, in vec3 _dir ) {\n  Ray ray;\n  ray.dir = _dir;\n  ray.ori = _ori;\n  return ray;\n}\n\n// カメラから出るレイを求める\nRay rayFromCam( in vec2 _p, in Camera _cam ) {\n  vec3 dir = normalize(\n    _p.x * _cam.sid\n    + _p.y * _cam.top\n    + _cam.dir / tan( _cam.fov * PI / 360.0 ) // Is this correct?\n  );\n  return rayInit( _cam.pos, dir );\n}\n\n// ------\n\n// 球体の距離関数\nfloat distFuncSphere( vec3 _p, float _r ) {\n  return length( _p ) - _r;\n}\n\n// 箱の距離関数\nfloat distFuncBox( vec3 _p, vec3 _s ) {\n  vec3 d = abs( _p ) - _s;\n  return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\n// トーラスの距離関数\nfloat distFuncTorus( vec3 _p, float _r, float _R ) {\n  vec2 q = vec2( length( _p.xz ) - _R, _p.y );\n  return length( q ) - _r;\n}\n\n// 円柱の距離関数\nfloat distFuncPillar( vec3 _p, float _r, float _t ) {\n  return max( abs( _p.y ) - _t, length( _p.xz ) - _r );\n}\n\n// xz円状にRepetition\nvec3 circleRep( vec3 _p, float _r, float _c ) {\n  vec3 p = _p;\n  float intrv = PI * 2.0 / _c;\n  p.zx = rotate2D( floor( atan( p.z, p.x ) / intrv ) * intrv ) * p.zx;\n  p.zx = rotate2D( intrv / 2.0 ) * p.zx;\n  p.x -= _r;\n  return p;\n}\n\n// 距離関数\nfloat distFunc( vec3 _p, out material mtl ) {\n  vec3 p = _p;\n  float dist = HUGE;\n    \n  vec3 pBase = p + ( vec3(\n        noise( p.yz * 0.5 - 0.2 ),\n        noise( p.xz * 0.5 - 0.4 ),\n        noise( p.xy * 0.5 - 0.7 )\n    ) - 0.5 ) * 0.1;\n  \n  { // base\n    vec3 p = pBase;\n    float distt = distFuncPillar( p, 0.85, 0.05 );\n    distt = smin( distt, distFuncTorus( p, 0.05, 0.9 ), 0.1 );\n    mtl = distt < dist ? MTL_BASE : mtl;\n    dist = distt < dist ? distt : dist;\n  }\n    \n  { // mayo\n    vec3 p = pBase - vec3( 0.0, 0.06, 0.0 );\n    p.z += ( noise( p.xz * 0.5 - 0.2 ) - 0.5 ) * 0.3;\n    float d = length( p.zx ) - 0.85;\n    p.z = mod( p.z - 0.1, 0.2 ) - 0.1;\n    d = max( d, length( p.yz ) - 0.01 );\n    float distt = smin( dist, d, 0.02 );\n    mtl = distt < dist ? MTL_MAYO : mtl;\n    dist = distt < dist ? distt : dist;\n  }\n    \n  { // happa\n    vec3 p = pBase - vec3( 0.0, 0.06, 0.0 );\n    float d = length( p.zx ) - 0.85;\n    d = max( d, length( p.y ) - 0.04 );\n    d += noise( p.xz * 5.0 ) * 0.14;\n    float distt = smin( dist, d, 0.02 );\n    mtl = distt < dist ? MTL_HAPPA : mtl;\n    dist = distt < dist ? distt : dist;\n  }\n    \n  { // katsuo\n    vec3 p = pBase - vec3( 0.0, 0.06, 0.0 );\n    float d = length( p.zx ) - 0.5;\n    d = max( d, length( p.y ) - 0.05 );\n    d += noise( p.xz * 3.0 ) * 0.13;\n    float distt = smin( dist, d, 0.02 );\n    mtl = distt < dist ? MTL_KATSUO : mtl;\n    dist = distt < dist ? distt : dist;\n  }\n  \n  return dist;\n}\n\nfloat distFunc( vec3 _p ) {\n  material dummy = MTL_NONE;\n  return distFunc( _p, dummy );\n}\n\n// 距離関数から法線を求める\nvec3 normalFunc( in vec3 _p ) {\n  vec2 d = V * 1E-3;\n  return normalize( vec3(\n    distFunc( _p + d.yxx ) - distFunc( _p - d.yxx ),\n    distFunc( _p + d.xyx ) - distFunc( _p - d.xyx ),\n    distFunc( _p + d.xxy ) - distFunc( _p - d.xxy )\n  ) );\n}\n\n// ------\n\nvec4 draw( vec2 p, float time ) { \n  // カメラとレイを定義\n  Camera cam = camInit(\n    vec3( cos( time ) * 3.0, 2.0, sin( time ) * 3.0 ),\n    vec3( 0.0, -0.2, 0.0 ),\n    50.0\n  );\n  Ray ray = rayFromCam( p, cam );\n\n  // ------\n\n  float rayLen = INIT_LEN; // 探索レイの長さ\n  vec3 rayPos = ray.ori + rayLen * ray.dir; // 探索レイの位置\n  float rayDist = 0.0; // 探索レイ到達点から物体までの距離\n  material mtl = MTL_NONE;\n\n  // raymarch\n  for ( int i = 0; i < MARCH_ITER; i ++ ) {\n    rayDist = distFunc( rayPos, mtl );\n    rayLen += rayDist * MARCH_MULT;\n    rayPos = ray.ori + rayLen * ray.dir;\n    if ( 10.0 < rayLen ) { break; }\n    if ( abs( rayDist ) < 1E-4 ) { break; }\n  }\n\n  vec4 col = V.xxxx; // 出力する色\n  if ( abs( rayDist ) < 1E-1 ) { // もし物体に衝突したなら\n    // 各ベクトルを求める\n    vec3 normal = normalFunc( rayPos );\n    vec3 camDir = normalize( rayPos - cam.pos );\n    vec3 ligPos = cam.pos + cam.sid + cam.top * 1.0 - cam.dir;\n    vec3 ligDir = normalize( rayPos - ligPos );\n\n    // 拡散反射・光源の鏡面反射を求める\n    float dif = 0.5 + 0.5 * dot( -normal, ligDir );\n    float spe = pow( dot( normalize( camDir - normal ), ligDir ), 40.0 );\n    \n    // 材質に応じて色と反射率を変化させる\n    vec3 mtlCol = vec3( 0.0 );\n    float mtlSpe = 0.0;\n\t  \n    if ( floor( mtl ) == MTL_BASE ) {\n      float sauce = smoothstep( 0.9, 0.8, length( rayPos ) );\n      mtlCol = mix(\n        vec3( 1.0, 0.7, 0.2 ),\n        vec3( 0.4, 0.2, 0.1 ),\n        sauce\n      );\n      mtlSpe = mix( 0.1, 0.9, sauce );\n\t    \n    } else if ( floor( mtl ) == MTL_HAPPA ) {\n      float c = smoothstep( 0.4, 0.6, noise( rayPos.xz * 6.0 ) );\n      mtlCol = mix(\n        vec3( 0.2, 0.6, 0.1 ),\n        vec3( 0.1, 0.3, 0.02 ),\n        c\n      );\n      mtlSpe = 0.1;\n\n    } else if ( floor( mtl ) == MTL_KATSUO ) {\n      float c = smoothstep( 0.4, 0.6, noise( rayPos.xz * 6.0 ) );\n      mtlCol = mix(\n        vec3( 0.6, 0.3, 0.1 ),\n        vec3( 0.8, 0.7, 0.5 ),\n        c\n      );\n      mtlSpe = 0.3;\n\t  \n    } else if ( floor( mtl ) == MTL_MAYO ) {\n      mtlCol = vec3( 0.9, 0.8, 0.7 );\n      mtlSpe = 0.8;\n    }\n\n    // 色を決定\n    col.xyz += mtlCol * dif;\n    col.xyz += mtlSpe * spe;\n    col.w = 1.0;\n\t  \n    return col;\n\n  } else { // 物体に当たらなかったら\n    return mix(\n      vec4( 0.9, 0.1, 0.3, 1.0 ),\n      vec4( 0.7, 0.9, 0.2, 1.0 ),\n      p.y + 0.5\n    );\n  }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 p = ( fragCoord.xy * 2.0 - iResolution.xy ) / iResolution.x;\n  fragColor = draw( p, iTime );\n}","name":"Image","description":"","type":"image"}]}