{"ver":"0.1","info":{"id":"3dsyzS","date":"1585040506","viewed":23403,"name":"COVID","username":"GinesMendoza","description":"leave a comment if you want to help to improve this shader, I will appreciate it. ","likes":23,"published":1,"flags":64,"usePreview":0,"tags":["fft","audio","virus","cineshader","coronavirus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"MtXXzM","filepath":"https://soundcloud.com/lajosephine/youre-not-leaving","previewfilepath":"https://soundcloud.com/lajosephine/youre-not-leaving","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n//Music: You're Not Leaving by La Josephine\n//https://soundcloud.com/lajosephine/youre-not-leaving\n\n#define MAX_STEPS 100\n#define MAX_DIST 7.\n#define SURF_DIST .001\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat snoise( in vec3 x ) { // in [0,1]\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.-2.*f);\n\n    float n = p.x + p.y*57. + 113.*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.), hash(n+  1.),f.x),\n                        mix( hash(n+ 57.), hash(n+ 58.),f.x),f.y),\n                    mix(mix( hash(n+113.), hash(n+114.),f.x),\n                        mix( hash(n+170.), hash(n+171.),f.x),f.y),f.z);\n    return res * 2.0 - 1.0;\n}\n\n    \n\nmat2 Rot(float a){\n\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,-s,s,c);\n}\nvec3 Transform ( vec3 p ,float time){\n    p.z -= time * .5;\n\n    \n    p += sin(p.x+p.z+time)*.03\n        +sin(p.y+time)*.05\n        +cos(p.x+p.z+time)*.03\n        -cos(p.x+time)*.03\n        +cos(p.y+time)*.05;\n        \n    //p.xy *= Rot(time*.15);\n    return p;\n    \n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n    p *= scale;\n    return abs(dot(sin(p), cos(p.zxy))+bias)/scale - thickness;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat line( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n\n\nfloat smin(float a, float b, float k)\n{\n    float h=clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b,a,h)-k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k)\n{\n   \n    float h = clamp( 0.5 + 0.5*(a-b)/k, 0., 1.);\n    return mix(b, a, h) + h*(1.0-h)*k;\n}\nvec2 opUMin( vec2 a, vec2 b, float k ) { \n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 ); \n    return vec2( mix( b.x, a.x, h ) - k*h*(1.0-h), (a.x<b.x) ? a.y : b.y ); \n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\n\nconst float PI  = 3.14159265359;\nconst float PHI = 1.61803398875;\n\n\nvoid basis(vec3 n, out vec3 b1, out vec3 b2) \n{\n    if(n.y<-0.999999) \n    {\n        b1=vec3(0,0,-1);\n        b2=vec3(-1,0,0);\n    } \n    else \n    {\n        float a=1./(1.+n.y);\n        float b=-n.x*n.z*a;\n        b1=vec3(1.-n.x*n.x*a,-n.x,b);\n        b2=vec3(b,-n.z,1.-n.z*n.z*a);\n    }\n}\n\nvec4 invsf(vec3 p, float n)\n{\n    float m=1.-1./n;\n    float phi=min(atan(p.y,p.x),PI);\n    float k=max(2.,floor(log(n*PI*sqrt(5.)*\n                             (1.-p.z*p.z))/log(PHI+1.)));\n    float Fk=pow(PHI,k)/sqrt(5.);\n    vec2  F=vec2(round(Fk), round(Fk*PHI));\n    vec2 ka=2.*F/n;\n    vec2 kb=2.*PI*(fract((F+1.)*PHI)-(PHI-1.));    \n    mat2 iB=mat2(ka.y,-ka.x, \n                    kb.y,-kb.x)/(ka.y*kb.x-ka.x*kb.y);\n    \n    vec2 c=floor(iB*vec2(phi, p.z-m));\n    float d=0.;\n    vec4 res=vec4(0);\n    for(int s=0; s<4; s++) \n    {\n        vec2 uv=vec2(s&1,s>>1);\n        float i=dot(F,uv+c); \n        float phi=2.*PI*fract(i*PHI);\n        float ct=m-2.*i/n; //costheta\n        float st=sqrt(1.-ct*ct); //sintheta\n        \n        vec3 q=vec3(cos(phi)*st, \n                    sin(phi)*st, \n                    ct);\n        float d1=dot(p,q);\n        if(d1>d) \n        {\n            d=d1;\n            res=vec4(q,d);\n        }\n    }\n    return res;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r ) {\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n\nvec3 Background ( vec3 rd){\n    vec3 col = vec3(0);\n    float y = abs(rd.z)*.5+.5;\n    col += y*vec3(1,0.58,0.03);\n    return col;\n}\nvec3 opRep( in vec3 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\nvec2 e = vec2(.01, 0);\n\n\n\nvec2 Virus( vec3 p, float atime){\n    \n   \n    \n    p = p - vec3(sin(atime+2.0)*.1,sin(atime)*.1+sin(atime)*.02,0);\n    float t=mod(atime,1.5)/1.5;\n    p*=1.-0.05*clamp(sin(6.*t)*exp(-t*4.),-2.,2.);\n\n    p.xy *= Rot(0.04*atime);\n    p.xz *= Rot(0.06*atime);\n    p += sin(p.x+p.z+atime)*.01+sin(p.y+atime)*.042*p.y;\n    \n    \n    \n    vec3 r,f;\n    vec4 fibo=invsf(normalize(p),20.);\n    p += sin(p.x+p.z+atime)*.01+sin(p.y+atime)*.042*fibo.w*1.;\n    \n    float cvwidth = .54 +(- (sin(90.*p.x)*cos(40.*p.z)*sin(90.*p.y))*.06\n    - (cos(100.*p.x)*sin(100.*p.z)*sin(40.*p.y))*.06\n     - (sin(100.*p.y)*sin(100.*p.z)*sin(40.*p.x))*.06)*0.09;\n    \n    float sphere = sdSphere(p,cvwidth);\n     \n    vec2 d0Vector= vec2(sphere,2.0);\n \n   \n    \n    vec3 q=p-fibo.xyz;\n    vec3 n=normalize(fibo.xyz);\n    basis(n,r,f);\n    q=vec3(dot(r,q),dot(n,q),dot(f,q));\n\n\n   \n   \n   \n    q=q-vec3(0,-cvwidth+.08,0);\n    \n    float d1= sdRoundCone( q, 0.02,0.03 , 0.1);\n    \n    q=q-vec3(-.03,.12,0.0);\n    d1 = smin(sdSphere(q, 0.002)-0.003*snoise(q*83.),d1,.1);\n    \n  \n               \n    \n    vec2 d1Vector=vec2(d1,3.0);\n    \n    d1 = min(sdSphere(q-vec3(-.1,-.11,0.05), 0.02),\n             sdSphere(q-vec3(.1,-.11,.0), 0.02));\n    \n    d0Vector=opUMin( d0Vector,vec2(d1,4.0),0.02);\n    \n    d0Vector=opUMin( d0Vector,d1Vector,0.02);\n    \n    \n    return d0Vector;\n   \n}\n\nfloat cell(vec3 p, float atime){\n\n    vec3 c = mod(abs(p),1.5) - .75;\n    c.y += sin(c.z) * .15;\n    c.xy *= Rot( c.z*.95) ;\n\n    \n    float r = 0.1;\n   \n   \n    return sdSphere(c,r)*.8;\n}\n\nvec2 Bloodstream (vec3 p, float atime){\n    \n    p = p - vec3(snoise(p)*sin(atime)*.2,sin(atime)*snoise(p)*0.2,0.);\n    p.z += atime * .9;\n    p.xy *= Rot( p.z*.5) ;\n    \n    \n    if (abs(p.x) > 3. || abs(p.y) > 3.) {\n       return vec2(100.,-1.0);\n    }\n    \n\n    \n    return vec2(cell( p,  atime),5.0);\n}\n\n\nvec2 map(in vec3 p,float atime ){\n   \n\n    vec2 cv=Virus(p,atime);\n    vec2 b = Bloodstream (p,  atime);\n    \n    p = Transform(p,atime);\n    \n    float g1 = sdGyroid(p,1.3,.06,1.4);\n\n\n    float g2 = sdGyroid(p,10.76,.03,.3);\n    float g3 = sdGyroid(p,20.76,.03,.3);\n    float g4 = sdGyroid(p,35.76,.03,.3);\n    float g5 = sdGyroid(p,60.76,.03,.3);\n    \n    \n    g1 += g2 * .3 * sin(atime*1.53) * cos(atime*2.34) * p.y ;\n    g1 -= g3 * .2;\n    g1 += g4 * .1;\n    g1 += g5 * .2;\n    \n    \n    float tunel = smax(PI*.9 - length(p.xy), .75-g1, 1.) - abs(1.-g1)*.175;\n    \n    tunel += g2 * .2 * sin(atime*1.53) * cos(atime*2.34) * p.y ;\n    tunel -= g3 * .2;\n    tunel += g4 * .1;\n    tunel += g5 * .2;\n     \n    \n    g1 = smin(tunel, g1,.9); \n    \n    \n    vec2 vg1 = vec2(g1,1.);\n    \n    b = opUMin( b,vg1,.31);\n    return opU( cv, b);\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, float time )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = map( opos, time ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec2 RayMarching(vec3 ro, vec3 rd,float time){\n\n\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 2.;\n    float tmax = 100.0;  \n    \n    float t = tmin;\n    for( int i=0; i<512 && t<tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t, time );\n        if( abs(h.x)<(.001*t))\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n \nvec3 calcNormal(in vec3 pos,float time,float quality){\n    vec3 n = vec3(0.0);\n   for( int i=min(0,0); i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+quality*e,time).x;\n    }    \n    return normalize(n);\n}\n\n\n\nvec4 render( in vec3 ro, in vec3 rd, float time )\n{ \n    \n    \n    vec3 col = vec3(0.);\n        \n    vec2 res = RayMarching(ro,rd,time);\n    if(res.y>0.5){\n        \n        float fft  = texelFetch( iChannel0, ivec2(3.,0.75), 0 ).x;\n        fft = smoothstep( 0.8, 1., fft )*2.;\n\n        float fft1  = texelFetch( iChannel0, ivec2(5.,0.75), 0 ).x; \n        fft1 = smoothstep( 0.9, 1., fft1 )*1.5;\n\n        float fft2  = texelFetch( iChannel0, ivec2(6.,0.75), 0 ).x; \n        fft2 = smoothstep( 0.9, 1., fft2 );    \n\n        float fft3  = texelFetch( iChannel0, ivec2(7.,0.75), 0 ).x; \n        fft3 = smoothstep( 0.9, 1., fft3 )*2.2;\n\n        float flash =  texture( iChannel0, vec2(512, 0.25)).x;\n        flash = smoothstep(.45, .8, flash )*20.;\n        flash = clamp(flash,0.,1.);\n        \n        float d = res.x;\n        vec3 pos = ro + rd*d;\n        \n        \n        float quality = res.y < 1.5 ?  0.016 : 0.0025;\n        \n        vec3 nor = normalize(e.xyy*map(pos+e.xyy,time).x\n                     +e.yyx*map(pos+e.yyx,time).x\n                     +e.yxy*map(pos+e.yxy,time).x\n                     +e.xxx*map(pos+e.xxx,time).x); \n        \n         vec3 ref = reflect(rd,nor);\n        \n        vec3 light_pos = normalize(  vec3( 0., .5, 0.2 ));\n        \n        vec3 specular = vec3( max( .30, dot( light_pos, ref ) ) );\n        specular = pow( specular, vec3( 100.0 ) );\n        \n       col += vec3(1,.4,.1)* 20. * specular; \n         \n        vec3 lin = vec3(0.0);\n        \n        vec3  sun_lig = light_pos;\n        float sun_dif = clamp(dot( nor, sun_lig ), 0.0,1. );\n        \n        pos = Transform(pos,time);\n        if(res.y > 4.5) \n        { \n        \n            col += sun_dif *vec3(1.5,0.,.0);\n            \n        }\n        else if(res.y > 3.5)\n        {\n            col += vec3(1.00,0.24,0.0)*sun_dif;\n        }\n        else if(res.y > 2.5)\n        {\n            col += vec3(.79,0.0,0.0)*sun_dif;\n        }\n        else if(res.y > 1.5) \n        {\n            col += sun_dif;\n        }\n        else if(res.y > 0.5) \n        {\n            col += sun_dif *vec3(1.,0.,.0);\n            \n            float g2 = sdGyroid(pos,10.76,.03,.3);\n            col *= smoothstep(-.1,.1,g2);\n            \n            float beat = abs((g2 * .2 * sin(time*1.53) * cos(time*2.34) * pos.y));\n            col += beat*vec3(1.,0.031,.02);\n            \n            float crackWidth = -.019 + smoothstep(0.,-.1,nor.y)*.04;\n            float cracks = smoothstep(crackWidth,-.043,g2);\n            cracks *= .5 * smoothstep(.2,.5,nor.y) *.5 +5.5;\n            col += cracks*vec3(0.7,0.0,.0)*beat *15.;\n            \n            \n            float speed = 1.5;\n            float g5 = sdGyroid(pos+vec3(cos(time*speed),sin(time*speed),time), 1.75, .705, 0.);\n            g5 *= sdGyroid(pos+vec3(sin(time*speed),cos(time*speed),time), 1., 1.9, .1);\n            col += g5*vec3(.4, .0, .0);\n            \n     \n        }\n        \n        \n        \n        \n         \n       \n        \n       \n        //col *= vec3(fft);\n        \n        vec3  sun_hal = normalize( sun_lig-rd );\n        float sun_sha = calcOcclusion( pos, sun_lig, time );\n        lin += sun_dif*vec3(1,.4,.1)*sun_sha;\n        \n        \n        \n        float ks = .5;\n        float sun_spe = ks*\n            pow(clamp(dot(nor,sun_hal),0.0,1.0),9.0)\n            *sun_dif\n            *(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n        float sky_dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n        lin += sky_dif*vec3(1.0,0.5,.5);\n        \n        col *= lin;\n        col += sun_spe*vec3(8.10,6.00,4.20)*sun_sha;\n\n\n\n        vec3 fog = (abs(rd.z)*.5+.5)\n            *(\n                + (vec3(1.0,0.2,0.0))\n                + (vec3(1.0) * flash * 2.)\n                + (vec3(2.0,0.5,0.0) * fft1 * 1.3)\n            \t+ (vec3(1.0,0.0,0.0) * fft2 * 1.3)\n            \t+ (vec3(1.0,0.0,0.1) * fft3 * 1.3)\n             )\n            ;\n       \n        \n    \n\t\t\n        fog = (fog*.5+.5);\n        \n        col = mix(col, fog,smoothstep(0.,10.,d));\n        col *= mix(Background(rd), fog,smoothstep(0.,10.,d));\n        \n    }\n    \n        \n    return vec4(col,res.x);\n}\n\n\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float t = iTime;\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    \n    \n    vec3 ro = vec3(0, 0, 3.);\n    \n    ro.xy *= Rot(sin(t*.1)*PI);\n    ro.xz *= Rot(sin(t*.1)*PI);\n    ro.yz *= Rot(sin(t*.1)*PI);\n    \n    \n    vec3 ta = vec3(0.0,0.,0.);\n    vec3 rd = GetRayDir(uv, ro, ta, .6);\n    \n    vec4 res = render( ro, rd, t );\n        \n    vec3 col = res.xyz ;\n    col = clamp(col, 0.0,1.0);\n    \n    \n    vec2 q = fragCoord/iResolution.xy;\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), .5 );\n    \n    \n    col = pow(col,vec3(0.4545));\n    \n    float depth = min(10.0, res.w);\n    fragColor = vec4(col,1.0 - (depth - 0.5) / 2.0);\n    \n}\n\n\n/** SHADERDATA\n{\n\t\"title\": \"My Shader 0\",\n\t\"description\": \"Lorem ipsum dolor\",\n\t\"model\": \"person\"\n}\n*/","name":"Image","description":"","type":"image"}]}