{"ver":"0.1","info":{"id":"mtSGRW","date":"1672924234","viewed":203,"name":"Irregular Rectangle Tiling","username":"mla","description":"An old favourite. This one uses an SDF to determine the region to be filled. The offset() function says how far the vertical or horizontal line through a grid point is from the point itself. Lots of xy flipping to make sure everything lines up.","likes":15,"published":3,"flags":16,"usePreview":0,"tags":["rectangle","tiling","irregular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////////////////////////////////////////////\n//\n// Irregular Rectangle Tiling, mla, 2023\n//\n// Inspired by:\n// https://www.shadertoy.com/view/Dt2GRz (@jt)\n// https://www.shadertoy.com/view/Ws3GRs (@Shane)\n// https://www.shadertoy.com/view/7tKGRc (@Gelami)\n//\n// This one just works out the boundaries and the tile id for\n// colouring - would need extra work to work out the actual\n// tile dimensions eg. for texturing or for a proper tile SDF.\n//\n// 'c' shows underlying grid.\n//\n/////////////////////////////////////////////////////////////////\n\n// An SDF for the region to be filled - this must have a boundary\n// (distance == 0) on integer gridlines\nfloat regiondist(vec2 p) {\n  float d0 = max(abs(p.x)-13.0,abs(p.y)-8.0);\n  float d1 = max(abs(p.x)-5.0,abs(p.y)-3.0);\n  return max(d0,-d1);\n}\n\nfloat offset(vec2 p, bool flip) {\n  if (flip) p = p.yx;\n  // NB: grid points _on_ the boundary have offset 0\n  if (regiondist(p) >= 0.0) return 0.0;\n  float t = rand(ivec2(p)^int(iTime));\n  return 0.95*(t-0.5);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  float scale = 10.0;\n  vec2 p = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n  p *= scale;\n  vec3 col = vec3(1,1,0.8);\n  float px = fwidth(p.x);\n  float lwidth = 0.01;\n  float rdist = regiondist(p);\n  if (rdist > 0.0) {\n    col *= smoothstep(0.0,px,rdist-lwidth);\n  } else {\n    vec2 ix = round(p);\n    p -= ix;\n    bool flip = mod(ix.x+ix.y,2.0) != 0.0; // Chequerboard\n    if (flip) {\n      p = p.yx; ix = ix.yx;\n    }\n    float x = offset(ix,flip);\n    float d = p.x-x; // Vertical line\n    int xdelta = d < 0.0 ? -1 : 1;\n    float y = offset(ix+vec2(xdelta,0),flip);\n    float d1 = p.y-y; // Horizontal line to left or right\n    if (d < 0.0) ix.x--;\n    if (d1 < 0.0) ix.y--;\n    if (flip) ix = ix.yx; // Now ix is the tile id\n    col = 0.5+0.5*h2rgb(rand(ivec2(ix)));\n    if (key(CHAR_C) && flip) col *= 0.8;\n    d = min(abs(d),abs(d1));\n    col *= smoothstep(0.0,px,d-lwidth);\n  }\n  fragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const int CHAR_C = 67;\n\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n  x += 0x12345678u;\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat rand(ivec2 p) {\n  uint h = ihash(uint(p.x)^ihash(uint(p.y)));\n  return float(h)/exp2(32.0);\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}\n","name":"Common","description":"","type":"common"}]}