{"ver":"0.1","info":{"id":"lcfyRN","date":"1720926751","viewed":28,"name":"ray-march steps2: primitives","username":"letbonsaibe","description":"learn material \n1. https://www.youtube.com/watch?v=PMltMdi1Wzg&ab_channel=InigoQuilez\n2. https://www.youtube.com/watch?v=62-pRVZuS5c&t=5s&ab_channel=InigoQuilez","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 80\n#define MAX_DIST 100.0\n#define SURFACE_DIST 0.01\n#define NORMAL_DELTA 0.01\n#define DIFFUSE_COLOR vec3(0.671,0.651,0.651)\n#define AMBIENT_COLOR vec3(0.20,0.20,0.20)\n#define AA 2\n#define PI 3.1415926\n\n\nfloat getT() {\n    float t = mod(iTime/1.5, 2.0);\n    return (t < 1.0) ? t : 2.0-t;\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdLine( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n    return dot(p,n) + h;\n}\n\n\nvec2 opUnion( vec2 d1, vec2 d2 )\n{\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map(vec3 p, float time) {\n    vec2 result = vec2(0.0);\n\n    vec2 sphere = vec2(\n        sdSphere(p-vec3(3.0, 2.0, 0.0), 1.),\n        1.5\n    );\n    vec2 line = vec2(\n        sdLine(p, vec3(-1., 1., 0.), vec3(1.0, 1.0, 0.0), 0.2),\n        2.5\n    );\n    vec2 box = vec2(\n        sdBox(p-vec3(-3.0, 2.0, 0.), vec3(1.0)),\n        3.5\n    );\n\n    vec2 plane  = vec2(\n        sdPlane(p, vec3(0., 1., 0.), 0.0),\n        0.5\n    );\n\n\n    result = opUnion(sphere, line);\n    result = opUnion(result, box);\n    result = opUnion(result, plane);\n\n    return result;\n}\n\n\n\n\nvec3 calcNormal(vec3 p, float time) {\n    vec2 e = vec2(NORMAL_DELTA, 0.);\n    return normalize(vec3(\n         map(p+e.xyy, time).x - map(p-e.xyy, time).x,\n         map(p+e.yxy, time).x - map(p-e.yxy, time).x,\n         map(p+e.yyx, time).x - map(p-e.yyx, time).x\n     ));\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, float time )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 0.5;\n    float tmax = 20.0;\n\n    float t = tmin;\n    for( int i=0; i<MAX_STEPS && t<tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t, time );\n        if( h.x<SURFACE_DIST || h.x > MAX_DIST)\n        {\n            res = vec2(t,h.y);\n            break;\n        }\n        t += h.x;\n    }\n    return res;\n}\n\n\nfloat GetShadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<MAX_STEPS && t<maxt; i++ )\n    {\n        vec2 h = map(ro + rd*t, 0.0);\n        if( h.x<SURFACE_DIST )\n        return 0.0;\n        res = min( res, k*h.x/t );\n        t += max(.001, .5 *h.x);\n    }\n    return res;\n}\n\nfloat GetDiffuseLight(vec3 p, vec3 lightPos ) {\n    vec3 incidentLight = normalize(p - lightPos);\n    vec3 surfaceNormal = calcNormal(p, 0.0);\n    float diffuseRatio = clamp(dot(-incidentLight,surfaceNormal), 0.0, 1.0);\n\n    float distanceFromLight = distance(p, lightPos);\n    float shadow = GetShadow(\n        p + SURFACE_DIST * 2.0 * surfaceNormal,\n        -incidentLight,\n        0.1,\n        distance(p, lightPos),\n        4.\n    );\n\n    return diffuseRatio * shadow;\n}\n\nmat3 setCamera(vec3 ro, vec3 ta, float a) {\n    vec3 forward = normalize(ta - ro);\n    vec3 up = vec3(0., 1.,  0.);\n    vec3 right = cross(forward, up);\n\n    // pitch\n    mat3 pitchMat = mat3(\n        cos(a), sin(a), 0.0,\n        -sin(a), cos(a), 0.0,\n        0.0,    0.0, 1.0\n    );\n\n\n    vec3 newForward = forward * pitchMat ;\n    vec3 newUp = up * pitchMat;\n    vec3 newRight = cross(newForward, newUp);\n\n    return mat3(newRight, newUp, newForward);\n}\n\n// triangular signal\nvec2 tri( in vec2 x )\n{\n    vec2 h = fract(x*.5)-.5;\n    return 1.-2.*abs(h);\n}\n\nfloat checkersGrad( in vec2 uv )\n{\n    vec2 w = fwidth(uv);    // filter kernel\n    vec2 i = (tri(uv+0.5*w)-tri(uv-0.5*w))/w;   // analytical integral (box filter)\n    return 0.5 - 0.5*i.x*i.y;                   // xor pattern\n}\n\nfloat checkers(in vec2 uv){\n    vec2 q = floor(uv);\n    float f = mod(q.x+q.y,2.);\n    return f;\n}\n\n\nvec3 render(in vec3 ro, in vec3 rd, float time) {\n    vec2 res = castRay(ro, rd, time);\n    vec3 col = vec3(0.5, 0.8, 0.9) - max(rd.y,0.0)*0.5;\n    vec3 p = ro + rd * res.x;\n\n    if (res.y > 3.0) {\n        col = vec3(0.8, 0.2, 0.0);\n    } else if (res.y > 2.0) {\n        col = vec3(1.0, 1.0, 0.0);\n    } else if (res.y > 1.0) {\n        col = vec3(0.0, 0.0, 1.0);\n    } else if (res.y > 0.0) {\n        col = vec3(0.3);\n        float f = checkersGrad(p.xz);\n        col += f;\n    }\n\n    vec3 directionalLightPosition = vec3(0., 5., 5.);\n    directionalLightPosition.xz += 3.0 * vec2(sin(0.15), cos(0.15));\n\n    float diffuse = GetDiffuseLight(p, directionalLightPosition);\n\n    if (res.x > -.5) {\n       col *= diffuse;\n    }\n\n    return col;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 tot = vec3(0.0);\n\n#if AA>1\nfor( int m=0; m<AA; m++ ) {\nfor( int n=0; n<AA; n++ ) {\n    // pixel coordinates\n    vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n    vec2 uv = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n    vec3 col = vec3(0.0);\n\n    float theta = mix( 2.5 * PI * iMouse.x/ iResolution.x,  iTime * PI* 0.1, step(iMouse.z, 0.0));\n    float pitch =  0.1 * PI * (iMouse.y - iResolution.y * .5)/ iResolution.y;\n    vec3 target = vec3(0.0, 2.0, 0.);\n    vec3 rayOrigin  = vec3( 10.*cos(theta), 2.0, 10.*sin(theta) );\n\n    mat3 camera = setCamera( rayOrigin, target, pitch );\n    vec3 rayDirection = normalize(camera * vec3(uv,1.8) );\n\n    col = render(rayOrigin, rayDirection, iTime);\n\n\n    tot += col;\n#if AA>1\n    }}\n    tot /= float(AA*AA);\n#endif\n\n    fragColor = vec4( tot, 1.0 );\n}\n\n","name":"Image","description":"","type":"image"}]}