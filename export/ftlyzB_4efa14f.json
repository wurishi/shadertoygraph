{"ver":"0.1","info":{"id":"ftlyzB","date":"1648297064","viewed":168,"name":"Hyeve's Renderer Demo :>","username":"Hyeve","description":"A fully expanded, commented, and explained, version of my \"True Transparency\" raymarching renderer. ","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","transparency","demo","glass","explanation","crystal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Degress to Radians. Useful to have around.\n#define DTR 0.01745329\n\n//Standard rotation matrix for rotating a 2D plane around 0,0\n//In 3D, it's used to rotate a 3D vector around any one axis at a time\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n\n\n//I like defining everything globally, it's easier and more compact,\n//but it does make things a little more confusing. I've de-abbreviated\n//all the names for this demo.\n\n\n\n//Position of the current pixel, with 0,0 being the centre of the screen,\n//going negative towards the bottom left, positive towards top right.\nvec2 uv_coords; //Normally \"uv\"\n\n\n\n//------------ 3D Position & Direction Vars\n\n\n//Current Position, in 3D space. \n//Usually stores the hit position of the most recent ray.\nvec3 current_position; //Normally \"cp\"\n\n//Current Normal, in 3D space.\n//Usually stores the normal vector of the most recently hit surface.\nvec3 current_normal; //Normally \"cn\"\n\n//Current Ray, in 3D space.\n//Stores the direction of movement for the current/most recent ray.\n//This is used in addition to ray_direction, as I need to store two different ray directions at times,\n//which is required for the refraction code.\nvec3 current_ray; //Normally \"cr\"\n\n//Ray Origin, in 3D space.\n//Stores the origin position (usually camera position) of the current/most recent ray.\nvec3 ray_origin; //Normally \"ro\"\n\n//Ray Direction, in 3D space.\n//Stores the direction of movement for the current/most recent ray.\n//This is used in addition to current_ray, as I need to store two different ray directions at times,\n//which is required for the refraction code.\nvec3 ray_direction;\n\n\n\n//------------ Colour & Lighting Vars\n\n\n//Subsurface - Used for fake \"subsurface scattering\" colouring.\nvec3 subsurface; //Normally \"ss\"\n\n//Object Colour - Used for the base \"matt\" colour of objects.\nvec3 object_color; //Normally \"oc\"\n\n//Current Color - Stores the colour of the current hit, after/including lighting calculations \nvec3 current_colour; //Normally \"cc\"\n\n//Glow - Stores some amount of additional \"glow\" colouring.\nvec3 glow; //Normally \"gl\" or \"glw\"\n\n//Volume Blending - Stores various information about whether and how\n//the current object should be rendered as volumetric\nvec3 volume_blend; //Normally \"vb\"\n\n//Final Colour - Stores the final color that the current pixel will be set to.\nvec4 final_color; //Normally \"fc\"\n\n//Index of refraction - Stores, well, the IOR for the current object.\nfloat index_of_refraction; //Normally \"io\" or \"ior\"\n\n//Object alpha - Also pretty self explanatory. 0 is invisible, 1 is opaque.\nfloat object_alpha; //Normally \"oa\"\n\n\n\n//------------ Other Vars\n\n//Time - Global time variable that I use instead of iTime, partly to be concise and partly to make porting easier.\nfloat time; //Normally \"tt\"\n\n//Current Distance - Stores the distance that the current ray has travelled so far.\nfloat current_distance; //Normally \"cd\"\n\n//Scene Distance - Stores the current distance away from any surface in the scene.\nfloat scene_distance; //Normally \"sd\"\n\n//Total Distance - Stores the total distance that has been travelled for the current pixel.\n//(this is often different from the current_distance)\nfloat total_distance; //Normally \"td\"\n\n//Step Count - Stores the number of iterations the raymarcher has used so far.\nfloat step_count; //Normally \"sc\" or \"tc\"\n\n//Escape - Stores the number of \"escape loops\" needed, and is iterated inside the render loop\nint escape; //Normally \"es\"\n\n//Escape Count - This is set to trigger that number of escape loops.\n//It needs to be separate from \"escape\" because otherwise it overwrite itself while trying to iterate.\nint escape_count; //Normally \"ec\"\n\n\n\n//Signed Distance Function for a cuboid given a position and size.\n//It's pretty standard, this is the \"true\" version rather than the slightly faster version.\nfloat box_sdf(vec3 position, vec3 size) //Normally \"bx(p,s)\"\n{\n    vec3 quarter = abs(position) - size;\n    return min( max( quarter.x, max( quarter.y, quarter.z ) ), 0.) + length( max( quarter, 0.) );\n}\n\n\n\n\n//Map function. Fairly standard stuff, takes a position and returns the SDF value.\nfloat map(vec3 position) //Normally \"mp(p)\"\n{\t\n    \n    //Rotate entire scene slowly\n\tposition.xz*=rot(time*0.1);\n\tposition.xy*=rot(time*0.1);\n\t\n    //Create basic rounded cube\n\tscene_distance = box_sdf(position, vec3(1) ) - 0.1;\n\t\n    //We can do cool stuff here! Explained below.\n    float fake_sss_box = box_sdf(position, vec3(0.8) ) - 0.1;\n    \n    //\"Glow Trick\". No idea who came up with the original idea of adding glow based on scene\n    //distances, or who then figured out that exp(-anything) looks fantastic, but here it is!\n    //It's pretty subtle here as to make sure you can see the other effects easily too, but if you\n    //want to mess with it, feel free to change the 0.01 at the end to something bigger.\n    if(scene_distance > 0.) glow += exp(-scene_distance) * vec3(0., 1., 1.) * 0.01;\n    \n\n\t//IMPORTANT SPECIAL STEP: \"Onion\" the cube to make it completely hollow with face thickness of 0.001.\n    //This is CRUCIAL to how my transparency and volumetrics are done.\n    //(Well, technically, it isn't crucial to the technique, but it's crucial to this optimised version)\n\tscene_distance = abs(scene_distance) - 0.001;\n\n    \n    //We assign object properties in the scene! This is a far easier and more elegant way of doing it\n    //rather than returning an ID of some kind, and it even lets us do a lot more interesting effects,\n    //since we have access to everything else in the scene function!\n\tif(scene_distance < 0.001)\n\t{\n\t\tobject_color = vec3(1); //Basic white cube\n    \n\t\tindex_of_refraction = 1.3; //Quite refractive\n\n\t\tobject_alpha = 0.3; //Mostly transparent\n        \n        //We can do really cool fake subsufrace here!\n        //Essentially, we use the distance to a second object \n        //(usually a slightly smaller copy of the original)\n        //in order to \"edge detect\" and add lighting to the edges and corners!\n\t\tsubsurface = vec3(1) * pow(fake_sss_box * 3., 4.);\n        \n        //We're not doing volume blending for this object, so this can remain all zeros.\n        //To explain though, the X component of volume_blend is purely a flag - should it be volumetric -\n        //The Y is the blending distance - how \"dense\" the volume is - and the Z is the falloff.\n        //Explained more in the rendering loop.\n        //----\n        //If you want to play with it, try setting the index of refraction to 1,\n        //the object_alpha to 0, and this to 1,3,1.5, to create a nice fog cube.\n\t\tvolume_blend = vec3(0.,0.,0.);\n        \n        //Escape count. This is the number of surfaces that will be skipped through to escape total\n        //internal refraction/reflection, if it occurs. This is.. not exactly physically accurate, but\n        //it looks much better than the recursive reflections that happen otherwise.\n        //Normally it is at two, but occasionally strange scene geometry can require changing it for best effect.\n\t\tescape_count = 2;\t\n\t}\n    \n    //Important thing to point out! The only reason we actually return the scene distance is because\n    //it makes the normal calculation function far more concise. Aside from that, because it's set globally,\n    //we never need to use the return value!\n\treturn scene_distance;\n}\n\n\n\n\n//Basic raymarcher, except... it gets to be void, because everything is global!\nvoid trace() // Normally \"tr()\"\n{\n    volume_blend.x = 0.; // We need to ensure nothing is accidentally still volumetric before we start marching\n    \n    current_distance = 0.;\n    \n    //I generally do 256 or 512 steps because I have a good GPU and want the quality, but 128 will do just fine\n    //in most cases. Specifically using powers of two is completely pointless, but hey, I'm a programmer.\n    for(step_count = 0.; step_count < 512.; step_count ++)\n    {\n        map(ray_origin + ray_direction * current_distance); //Obtain the scene distance at the current ray position\n        \n        current_distance += scene_distance; //Add it to current distance\n        \n        total_distance += scene_distance; //Add it to total distance\n        \n        //Break if we're close enough to count a hit or far enough to assume a miss\n        if(scene_distance < 0.0001 || current_distance > 128.) break;\n    }\n    \n    \n    //No return value? No problem! Everything is stored globally!\n}\n\n\n\n\n//Standard 3-tap normal calculation, elegant matrix version. I'll be honest, I don't understand matricies well,\n//but hey, it works and is easier to write than the other way.\nvoid normal() //Normally \"nm()\"\n{\n    mat3 k = mat3(current_position, current_position, current_position)  -mat3(.001);\n    \n    current_normal = normalize( map(current_position) - vec3( map( k[0] ), map( k[1] ), map( k[2] ) ) );\n}\n\n\n\n\n//My pixel... \"shader\" function? I find it ironic that I have a pixel shader function inside a pixel shader, but\n//that's.. pretty much what it does. It does all the lighting equations to shade pixels!\nvoid pixel() //Normally \"px()\"\n{\n\n  current_colour = vec3(0.1,0.1,0.5); //First we initialise the colour to the background colour\n  \n  //This line looks confusing, but it's just adding a highlight to the background, so it's not totally flat.\n  //Essentially, we take the length of the ray direction to see how close we are to the centre, with\n  //a pow thrown in there for attenuation, and a bit of added offset to move the highlight upwards.\n  //The abs() is so we don't throw negative values into the pow() - pow on negative vectors works\n  //exactly as you'd expect on mine and most other implementations, but it IS technically undefined, \n  //and COULD return a vector of all 0s. One of my friends had that issue when looking at my shaders.\n  current_colour += length( pow( abs( ray_direction + vec3(0,0.5,0) ), vec3(3) ) ) * 0.3;\n  \n  //Then we also need to add the glow colour, attenuated by the step count! (since the glow trick is step-based)\n  current_colour += glow / step_count;\n  \n  //We do a distance check in here, to make sure we don't try and apply lighting equations to the background itself\n  if(current_distance > 128.)\n  {\n      object_alpha = 1.; //We need to make sure alpha is 1, too, so that the render loop exits correctly\n      return;\n  }\n  \n  //My custom lighting uses axis-based diffuse, \n  //where the \"light\" is set in terms of relative brightnesses per axis.\n  //Here it's quite bright along X, and Y, and less so on Z.\n  vec3 light = vec3(0.9,0.7,0.5);\n  \n \n  //My basic diffuse lighting. As mentioned, it's axis-based.\n  float diffuse = clamp( length( current_normal * light ), 0., 1.);\n  \n  //My fresnel effect. This is very simply inverse diffuse raised to a power, coloured something\n  //between the background and the object colour, tweaked to what looks good for different scenes\n  vec3 fresnel = pow(1. - diffuse, 3.) * mix(current_colour , object_color , 0.3);\n  \n  //My specular effect. I... honestly just messed around until I found something that worked well and I liked,\n  //I don't have much idea how it actually works. It has a little multipler on the end for per-scene tweaking, though\n  float specular = ( 1. - length( cross( current_ray, current_normal * light ) ) ) * 0.2;\n  \n  //My Ambient Occlusion effect. It's a 1-tap comparision between the actual scene distance and the expected\n  //scene distance at a certain offset, and.. it's not perfect, but it works really well most of the time.\n  float ambient_occlusion  =min( map( current_position + current_normal * 0.3 ) - 0.3 , 0.3 ) * 0.4;\n  \n  //Then we gotta mix it all together!\n  //This is.. essentially two things. The normal non-volumetric result is the object colour\n  //multiplied by a combination of factors, then with a combination of factors added.\n  //The mix will mix between that and the pure object colour, depending on the volume blending flag.\n  current_colour = \n  mix( \n      (object_color * ( diffuse + fresnel + subsurface) + fresnel + specular + ambient_occlusion + glow / step_count),\n      object_color, volume_blend.x\n  );\n}\n\n\n\n\n//This is my main render function - previously I would just have all this code in the main function,\n//but this makes both porting and antialiasing much more easy to do.\nvoid render(vec2 frag, vec2 res, float time_in, out vec4 col)\n{\n\n  //Assign global time variable. It's mod'd to ensure things like rotation and transforms don't get too imprecise\n  time = mod(time_in, 260.);\n  \n  \n  //Assign global uv coords and centre them\n  uv_coords = vec2( frag.x / res.x , frag.y / res.y );\n  uv_coords -= 0.5; \n  uv_coords /= vec2( res.y / res.x , 1 );\n  \n  \n  //Assign ray origin and direction, the origin is arbitrary and the direction is a basic perspective camera\n  ray_origin = vec3( 0 , 0 , -5 ); \n  ray_direction = normalize( vec3( uv_coords , 1 ) );\n  \n  \n  \n  //Okay, here's where all the things start happening! This is my main render loop,\n  //which pulls everything else together to calculate the pixels. Gonna take a lot of explaining.\n  //----\n  //Firstly, the iteration count is the maximum number of SURFACES we will raymarch. As mentioned\n  //in the map function, I specially make sure that everything is onioned to be as thin as possible.\n  //The reason for doing that is so that all objects become ultra-thin shells, which lets me optimise\n  //and simplify the rendering, because I no longer need to keep track of whether I'm inside or outside the\n  //objects, and I don't need to invert the distance field to be able to raymarch through the inside of things.\n  //----\n  //That means that this value, at BEST, is 2x the number of objects we can pass through, but some objects might\n  //use up more iterations. Usually I leave this really high, as it's very rare my scenes are complex enough to\n  //hit the limit, and they'll start lagging hard on my machine well before they do anyway.\n  for(int i = 0; i < 25; i++)\n  {\n  \n    //Step 1: Raymarch. This is a 100% normal vanilla raymarcher step. Nothing fancy.\n\ttrace();\n    \n    \n    //Step 2: Update current position and calculate normal. Also totally standard.\n    current_position = ray_origin + ray_direction * current_distance;\n    \n    normal();\n    \n    \n    //Step 3: This is where things start to get a little more complex.\n    //We are updating the ray origin - the starting point for rays - to be\n    //the current (hit) position, subtract a tiny amount of the current normal. \n    //This pushes it THROUGH the surface we hit, ready to raymarch through the \n    //inside of the object in the next iteration. (Or just to the next surface, same object or otherwise)\n    ray_origin = current_position - current_normal * 0.01;\n    \n    \n    //Step 4: Refraction & Total Internal Refraction checks.\n    //I've split this out into an if statement for readability. \n    //Normally it's one function with an inlined ?: operator.\n    //----\n    //IOR needs to be [IOR] for ENTERING an object, and 1/[IOR] for EXITING it, assuming that\n    //the object is denser than the current medium (assumed to be air, with IOR of 1)\n    //This means that the ray refracts in one direction on enter, and the opposite when exiting,\n    //which creates the correct visual distortion.\n    //----\n    //My IOR inversion is very simply based on the number of sufaces we've passed through so far.\n    //Sure, it could screw up and get flipped around, but it will generally work, and even if it\n    //does screw up because of some weird surfaces, it will still look fine, as long as it flips\n    //between each surface.\n    //You can test by making both of these cases identical, either IOR or 1/IOR, and see how it looks.\n    if(i % 2 == 0)\n    {\n        //This is a (relatively) \"simple\" refraction of the ray direction and current normal.\n        //Note that it is stored into current_ray, NOT back into ray_direction. This is important,\n        //because we might still need the value of ray_direction in the upcoming code.\n        current_ray = refract(ray_direction , current_normal , 1. / index_of_refraction);\n    }\n    else\n    {\n        //Same thing here.\n        current_ray = refract(ray_direction , current_normal , index_of_refraction);\n    }\n    \n    \n    \n    //And here's whhere we need it. If the length of current_ray is 0, this means the refraction\n    //returned a vector of all 0, which happens if it FAILS, which means it's time for total internal\n    //reflection! Except doing that recursively looks bad, so we've also got an escape system.\n    //----\n    //Without the escape checks here, total internal reflection would cause there to be visible recursive\n    //reflections. Sometimes it looks cool, but it's not at all physically accurate, and often looks bad.\n    //So we don't want that. (But you can have a look at it by setting escape_count to 0 and the IOR\n    //really high in the scene! - like 1.8 or so)\n    //----\n    //We make sure that the escape iterator is already <= 0 to ensure we're not already escaping.\n    if(length(current_ray) == 0. && escape <= 0)\n    {\n        //If we're NOT escaping, then we do the reflection - see, we needed that old ray_direction! -\n        //and then assign the escape iterator to the escape count.\n        current_ray = reflect( ray_direction , current_normal );\n        escape = escape_count;\n    }\n    \n    \n    //This check is slightly different in my actual shaders, but I can't remember why, and\n    //this works and is nice to explain for here, sooooo..\n    if(escape <= 0 && current_distance < 128.) //First check is usually \"max(escape, 0) % 3 == 0\" for some reason..\n    {\n        //Anyway. If we're not escaping, and we haven't hit the background, we update the ray\n        ray_direction = current_ray;\n    }\n    \n    //Annd decrement the escape iterator.\n    escape--;\n    \n    \n    //Step 5: Lighting & Colours!\n    //First up, we check the volume blend. Volume blending LITERALLY only changes the\n    //alpha of objects, which means it can do... interesting, things, if the base alpha isn't\n    //zero or the IOR isn't 0. It's pretty cool. It's also the part of my renderer that still\n    //needs the most work to really figure out the best way of doing it. Decent for now though.\n\tif(volume_blend.x > 0. && i % 2 == 1)\n    { \n    \n        //Anway, if we are volume blending this object, and have just EXITED a surface (hopefully,\n        //assuming nothing weird happened), then we set it's alpha based on the distance travelled,\n        //(which will hopefully be the distance through the object), and the volume blending parameters.\n        object_alpha = pow( clamp( current_distance / volume_blend.y ,0.,1.), volume_blend.z);\n    }\n    \n    //Then we calculate the pixel/hit colour\n\tpixel();\n    \n    //Then we mix it in with the final colour. Originally I did this with a mix(), but that caused some weird\n    //issues in places, and I realised it was absolutely not the proper way to do this kind of alpha blending,\n    //so I went and looked up the actual formulas for doing proper pre-multiplied alpha blending, which I am\n    //now using. You can go look them up too, if you're interested.\n    final_color = final_color + vec4( current_colour * object_alpha , object_alpha ) * ( 1. - final_color.a );\t\n    \n    //And if we've accumulated a 100% opaque colour, or gone too far, we exit the render loop!\n\tif( final_color.a >= 1. || current_distance > 128. ) break;\n    \n    //Otherwise, this loop repeats, traces to the next surface, refracts or reflects, etc, etc.\n  }\n  \n  //And... that's that! We just assign the colour, deviding it by it's own alpha in order to undo the\n  //pre-multiplication from earlier incase we HAVEN'T accumulated a 100% opaque colour yet (possible),\n  //and.. it's done!\n  col = final_color / final_color.a;\n  \n}\n\n\n\n//And here's the little cute mainImage function that just sits here and \n//really does all the hard work for us without any notice or care <3\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    render(fragCoord.xy,iResolution.xy,iTime,fragColor);\n} \n\n","name":"Image","description":"","type":"image"}]}