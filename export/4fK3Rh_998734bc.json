{"ver":"0.1","info":{"id":"4fK3Rh","date":"1712566294","viewed":93,"name":"Simple waves simulation","username":"Jaraxus","description":"Multiple waves interfering with each other.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["simulation","water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926538\n#define PI_2 2.f * 3.1415926538\n#define DELTA 0.01f\n#define EPSILON 0.0001f\n#define UP vec3(0.f, 0.f, 1.f)\n#define SPHERE_RADIUS 0.1f\n#define DONUT_RADIUS 0.07f\n#define DONUT_WIDTH 0.03f\n\n#define WAVES_COUNT 11\n#define LIGHTS_COUNT 2\n\nstruct Wave {\n    float start;\n    vec2 center;\n    float strength;\n    float speed;\n    float wavelength;\n    float decay;\n};\n\nstruct Light {\n    vec3 center;\n    vec3 color;\n    float phi;\n};\n\nWave waves[WAVES_COUNT];\nLight lights[LIGHTS_COUNT];\n\nfloat waterAlbedo = 0.5f;\nfloat waterSpecular = 48.f;\nvec3 waterColor = vec3(0.f, 0.3f, 1.f);\n\nfloat waveAt(float t, vec2 pos, Wave wave) {\n    float dist = length(wave.center - pos) * 100.f + 0.001f;\n    float dT = t * wave.speed - (wave.start + dist);\n    \n    if (dT < 0.f) {\n        return 0.f;\n    }\n    \n    float p = dT / wave.wavelength;\n    float waveId = floor(p);\n    p *= PI_2;\n    \n    return wave.strength * cos(p) * exp(- wave.decay * p);\n}\n\nvec2 gradientAt(float t, vec2 pos, Wave wave) {\n    float dist = length(wave.center - pos) * 100.f + 0.001f;\n    float dT = t * wave.speed - (wave.start + dist);\n    \n    if (dT < 0.f) {\n        return vec2(0.f, 0.f);\n    }\n    \n    float p = dT / wave.wavelength;\n    float waveId = floor(p);\n    p *= PI_2;\n    \n    float dpx = (wave.center.x - pos.x) / dist;\n    float dpy = (wave.center.y - pos.y) / dist;\n    \n    vec2 gradient = vec2(\n         PI_2 * dpx * sin(p) * exp(- wave.decay * waveId),                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      \n         PI_2 * dpy * sin(p) * exp(- wave.decay * waveId)\n    );\n    \n    return wave.strength * gradient;\n}\n\nvec3 normalAt(vec2 pos, float t) {\n    vec2 accGradient = vec2(0.f);\n    \n    for (int i = 0; i < WAVES_COUNT; ++i) {\n        accGradient += gradientAt(t, pos, waves[i]);\n    }\n    \n    return normalize(cross(vec3(1.f, 0.f, accGradient.x), vec3(0.f, 1.f, accGradient.y)));\n}\n\nvec3 lightingAt(vec3 viewDir, vec2 pos, vec3 normal, float t) {\n    vec3 color = vec3(0.f);\n    \n    for (int i = 0; i < WAVES_COUNT; ++i) {\n        Light light = lights[i];\n        vec3 pos2Light = light.center - vec3(pos.xy, 0.f);\n        float dist = length(pos2Light);\n        pos2Light /= dist;\n        \n        float diffuseIntensity = clamp(dot(normal, pos2Light), 0.f, 1.f);\n        float diffuse = waterAlbedo * diffuseIntensity;\n        \n        vec3 h = normalize(pos2Light + viewDir);\n        float specularIntensity = pow(clamp(dot(normal, h), 0.f, 1.f), waterSpecular);\n        \n        color += (light.color * diffuse * waterColor + light.color * specularIntensity) / dist;\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float minResolution = min(iResolution.x, iResolution.y);\n    vec2 distortion = iResolution.xy / minResolution;\n    \n    // Init waves\n    waves[0] = Wave(2.f, vec2(0.3f * distortion.x, 0.75f * distortion.y), 3.f, 5.f, 5.f, 0.1f);\n    waves[1] = Wave(5.f, vec2(0.5f * distortion.x, 0.2f * distortion.y), 1.f, 5.f, 5.f, 0.1f);\n    // Noise waves\n    waves[2] = Wave(-10000.f, vec2(0.f * distortion.x, -0.2f * distortion.y), 0.2f, 5.f, 10.f, 0.f);\n    waves[3] = Wave(-20000.f, vec2(1.f * distortion.x, -0.8f * distortion.y), 0.15f, 8.f, 20.f, 0.f);\n    waves[4] = Wave(-30000.f, vec2(1.5f * distortion.x, 1.3f * distortion.y), 0.5f, 3.f, 15.f, 0.f);\n    waves[5] = Wave(-10000.f, vec2(0.2f * distortion.x, 0.7f * distortion.y), 0.4f, 4.f, 10.f, 0.f);\n    waves[6] = Wave(-20000.f, vec2(-1.2f * distortion.x, -0.6f * distortion.y), 0.8f, 12.f, 20.f, 0.f);\n    waves[7] = Wave(-30000.f, vec2(-1.1f * distortion.x, -1.1f * distortion.y), 0.3f, 7.f, 15.f, 0.f);\n    waves[8] = Wave(-10000.f, vec2(-0.4f * distortion.x, 0.9f * distortion.y), 0.25f, 1.f, 10.f, 0.f);\n    waves[9] = Wave(-20000.f, vec2(-1.8f * distortion.x, 0.2f * distortion.y), 0.15f, 8.f, 20.f, 0.f);\n    waves[10] = Wave(-30000.f, vec2(1.3f * distortion.x, -1.7f * distortion.y), 0.1f, 3.f, 15.f, 0.f);\n\n    // Init lights\n    lights[0] = Light(\n        vec3(0.6f * distortion.x, 0.6f * distortion.y, 0.2f),\n        vec3(1.f, 1.f, 1.f),\n        1.f\n    );\n    lights[1] = Light(\n        vec3(0.1f * distortion.x, 0.9f * distortion.y, 0.2f),\n        vec3(1.f, 0.f, 0.f),\n        1.f\n    );\n\n    // Computes color at position\n    vec2 uv = fragCoord/minResolution;\n    vec3 normal = normalAt(uv, iTime);\n    vec3 color = lightingAt(UP, uv, normal, iTime);\n    \n    //color = 0.5f + 0.5f * normal;\n        \n    // Output to screen\n    fragColor = vec4(color, 1.f);\n}","name":"Image","description":"","type":"image"}]}