{"ver":"0.1","info":{"id":"DsKGzc","date":"1678897404","viewed":56,"name":"\"rotating cube\" by gpt-4","username":"zov","description":"Gpt4","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["gpt4"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nmat3 rotateX(float a) {\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(a), -sin(a),\n        0.0, sin(a), cos(a)\n    );\n}\n\nmat3 rotateY(float a) {\n    return mat3(\n        cos(a), 0.0, sin(a),\n        0.0, 1.0, 0.0,\n        -sin(a), 0.0, cos(a)\n    );\n}\n\nmat3 rotateZ(float a) {\n    return mat3(\n        cos(a), -sin(a), 0.0,\n        sin(a), cos(a), 0.0,\n        0.0, 0.0, 1\n    );\n}\n\nfloat sdBox(vec3 p) {\n    vec3 d = abs(p) - vec3(1);\n    return min(max(d.x,max(d.y,d.z)), .01) + length(max(d,.01));\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    \n    float time = iTime * .5;\n    \n    // Normalized pixel coordinates (from -1 to +1)\n    vec2 uv = (fragCoord.xy / iResolution.xy - .5) * vec2(iResolution.x / iResolution.y ,1);\n    \n    // Ray direction\n    vec3 rayDirection = normalize(vec3(uv.x , uv.y ,2));\n    \n    // Rotate ray direction\n    rayDirection *= rotateX(time);\n\trayDirection *= rotateY(time);\n\trayDirection *= rotateZ(time);\n    \n\t// Raymarch\n\tfloat d = sdBox(rayDirection);\n\t\n\tif (d < .01) {\n\t\tfragColor.rgb = mix(vec3(1.),vec3(.5,.8,.9),(rayDirection.z + rayDirection.y)*10.);\n\t} else {\n\t\tfragColor.rgb = mix(vec3(.9,.8,.7),vec3(.4,.6,.8),(rayDirection.z + rayDirection.y)*10.);\n\t}\n}","name":"Image","description":"","type":"image"}]}