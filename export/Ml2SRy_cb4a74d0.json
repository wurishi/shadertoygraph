{"ver":"0.1","info":{"id":"Ml2SRy","date":"1444737192","viewed":180,"name":"Rave Party","username":"Makio64","description":"Night Life","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cat","depth","party"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Rave Party\n// By David Ronai / @Makio64\n\nprecision lowp float;\n\n//------------------------------------------------------------------ VISUAL QUALITY\n#define POSTPROCESS\n#define SHADOW\n\n#define RAYMARCHING_STEP 38\n#define RAYMARCHING_JUMP .85\n\n#define RENDER_DEPTH\n//activate normal Render if you want a true nyancat experience\n//#define RENDER_NORMAL\n\nvec3 material = vec3(1.);\nvec3 tmpMaterial = vec3(1.);\n\n//------------------------------------------------------------------ MATRIX Functions\n\nmat2 Rot2(float a ) {\n\tfloat c = cos( a );\n\tfloat s = sin( a );\n\treturn mat2( c, -s, s, c );\n}\n\nmat4 Rot4X(float a ) {\n\tfloat c = cos( a );\n\tfloat s = sin( a );\n\treturn mat4( 1, 0, 0, 0,\n\t\t\t\t 0, c,-s, 0,\n\t\t\t\t 0, s, c, 0,\n\t\t\t\t 0, 0, 0, 1 );\n}\n\nmat4 Rot4Y(float a ) {\n\tfloat c = cos( a );\n\tfloat s = sin( a );\n\treturn mat4( c, 0, s, 0,\n\t\t\t\t 0, 1, 0, 0,\n\t\t\t\t-s, 0, c, 0,\n\t\t\t\t 0, 0, 0, 1 );\n}\n\nmat4 Rot4Z(float a ) {\n\tfloat c = cos( a );\n\tfloat s = sin( a );\n\treturn mat4(\n\t\tc,-s, 0, 0,\n\t\ts, c, 0, 0,\n\t\t0, 0, 1, 0,\n\t\t0, 0, 0, 1\n\t);\n}\n\nmat4 matRotate( in vec3 xyz )\n{\n\tvec3 si = sin(xyz);\n\tvec3 co = cos(xyz);\n\treturn mat4( co.y*co.z,                co.y*si.z,               -si.y,       0.0,\n\t\t\t\t si.x*si.y*co.z-co.x*si.z, si.x*si.y*si.z+co.x*co.z, si.x*co.y,  0.0,\n\t\t\t\t co.x*si.y*co.z+si.x*si.z, co.x*si.y*si.z-si.x*co.z, co.x*co.y,  0.0,\n\t\t\t\t 0.0,                      0.0,                      0.0,        1.0 );\n}\n\nmat4 Loc4( vec3 p ) {\n\treturn mat4(\n\t\t1,  0,  0,  -p.x,\n\t\t0,  1,  0,  -p.y,\n\t\t0,  0,  1,  -p.z,\n\t\t0,  0,  0,  1\n\t);\n}\n\nmat4 transpose3(in mat4 m ) {\n\treturn mat4(\n\t\t vec4( m[0].x, m[1].x, m[2].x, m[3].x ),\n\t\t vec4( m[0].y, m[1].y, m[2].y, m[3].y ),\n\t\t vec4( m[0].z, m[1].z, m[2].z, m[3].z ),\n\t\t vec4( m[0].w, m[1].w, m[2].w, m[3].w )\n\t);\n}\n\nmat4 matInverse( in mat4 m )\n{\n\treturn mat4(\n\t\tm[0][0], m[1][0], m[2][0], 0.0,\n\t\tm[0][1], m[1][1], m[2][1], 0.0,\n\t\tm[0][2], m[1][2], m[2][2], 0.0,\n\t\t-dot(m[0].xyz,m[3].xyz),\n\t\t-dot(m[1].xyz,m[3].xyz),\n\t\t-dot(m[2].xyz,m[3].xyz),\n\t\t1.0 );\n}\n\n//------------------------------------------------------------------ PRIMITIVES\n\nfloat sdCappedCylinder( in vec3 p, in vec2 h ) {\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba) / dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n\tvec2 q = vec2( length(p.xz), p.y );\n\tfloat d1 = -p.y-c.z;\n\tfloat d2 = max( dot(q,c.xy), p.y);\n\treturn length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdSphere( vec3 p, float r ) {\n\treturn length(p) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdBoxRounded(vec3 p, vec3 b, float r) {\n\treturn length(max(abs(p)-b,0.0))-r;\n}\n\n//------------------------------------------------------------------ OPERATIONS\nfloat sMinP( float a, float b, float k ) {\n\tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opS( float a, float b ) {\n\treturn max( a, -b );\n}\n\nvec3 opTx( vec3 p, mat4 m ) {\n\treturn (transpose3(m)*vec4(p,1.0)).xyz;\n}\n\nvec3 opRep( vec3 p, in vec3 spacing ) {\n    p.x = mod(p.x, spacing.x) - 0.5*spacing.x;\n    p.z = mod(p.z, spacing.z) - 0.5*spacing.z;\n\treturn p;\n}\n\nvec3 opRepY( vec3 p, in float spacingY ) {\n    p.y = mod(p.y, spacingY) - 0.5*spacingY;\n\treturn p;\n}\n\nvec3 opRepX( vec3 p, in float spacingX ) {\n    p.x = mod(p.x, spacingX) - 0.5*spacingX;\n\treturn p;\n}\n\nvec3 opRepZ( vec3 p, in float spacingZ ) {\n    p.z = mod(p.z, spacingZ) - 0.5*spacingZ;\n\treturn p;\n}\n\nvec2 opU( in vec2 v1, in vec2 v2){\n\t//Alternative wihout if.\n\treturn mix(v1,v2,clamp(sign(v1.x - v2.x),0.,1.));\n\t//return (v1.x<v2.x)?v1:v2;\n}\n\n\n//------------------------------------------------------------------ MATERIALS\n\n#define BLACK 1.\n#define WHITE 2.\n#define BLUE 3.\n#define PINK 4.\n#define NYAN 5.\n#define NEON 6.\n\n\n//------------------------------------------------------------------ MAP\n\nvec3 posFromAngle(in float phi, in float theta, in float radius){\n\treturn vec3(\n\t\tradius * sin( phi ) * cos( theta ),\n\t\tradius * cos( phi ),\n\t\tradius * sin( phi ) * sin( theta )\n\t);\n}\n\nfloat freqs[4];\n\nfloat sdSimpleCat(in vec3 pos){\n    vec3 q = pos;\n\n    vec3 headPos = pos+vec3(0.,freqs[2]*.5,0.);\n\n\tq = opTx( headPos - vec3(0.,6.,-3.), Rot4X(.3) );\n\tfloat hearL = sdCone( q, vec3( 0.5, .3, 3.0 ));\n\tq = opTx( headPos - vec3(0.,6.,3.), Rot4X(-.3) );\n\tfloat hearR = sdCone( q, vec3( 0.5, .3, 3.0 ));\n\tfloat hears = min(hearR,hearL);\n\n\tq = headPos;\n\tfloat head = min(hears,sdSphere(q,5.));\n\tfloat body = sdCapsule(q, vec3( 0., -12., 0. ), vec3( 0., -12., 0.), 8.2 );\n\treturn sMinP(body, head, 5.);\n}\n\n// Return distance + material ID\nvec2 map( in vec3 pos )\n{\n    pos -= vec3(0.,freqs[3]*15.,0.);\n\tvec3 q = pos;\n\n    float screen = sdBoxRounded(pos-vec3(-45.,16.,0.),vec3(1.,42.,100.),0.);\n    vec2 nyan = vec2(screen, NYAN);\n\n    vec3 headPos = pos+vec3(0.,freqs[2]*.5,0.);\n    q = opTx( headPos - vec3(.5,5.2,-3.), Rot4X(.3) );\n\tfloat pinkHearL = sdCone( q, vec3( 0.5, .3, 3.0 ));\n\tq = opTx( headPos - vec3(.5,5.2,3.), Rot4X(-.3) );\n\tfloat pinkHearR = sdCone( q, vec3( 0.5, .3, 3.0 ));\n\tfloat pinkHears = min(pinkHearL,pinkHearR);\n\n\tq = opTx( headPos - vec3(0.,6.,-3.), Rot4X(.3) );\n\tfloat hearL = sdCone( q, vec3( 0.5, .3, 3.0 ));\n\tq = opTx( headPos - vec3(0.,6.,3.), Rot4X(-.3) );\n\tfloat hearR = sdCone( q, vec3( 0.5, .3, 3.0 ));\n\tfloat hears = min(hearR,hearL);\n\tpinkHears = max(pinkHears,hears);\n\thears = opS(hears,pinkHears);\n\n\tq = headPos;\n\tfloat head = min(hears,sdSphere(q,5.));\n\tfloat head2 = sdSphere(q,5.2);\n\tq = headPos;\n\tpinkHears = opS(pinkHears,head2);\n\tq = pos;\n\tfloat body = sdCapsule(q, vec3( 0., -12., 0. ), vec3( 0., -12., 0.), 8.2 );\n\tbody = sMinP(body, head, 5.);\n\n    q = pos - vec3(-5.,0.,0.+sin(pos.y/2.+iTime));\n    float tail = sdCapsule(q, vec3( -15., -5., 0. ), vec3( 0., -15., 0.), .5+max(0.,min((pos.y+15.)/7.,3.)) );\n\n    q = pos;\n    vec2 white = vec2(min(tail,body),WHITE);\n\n\tfloat phi = freqs[3]*2.-1.;\n\n\tq = headPos - posFromAngle(phi+1.35,.3,5.);\n\tfloat eyeL = sdSphere(q,.3);\n\n\tq = headPos - posFromAngle(phi+1.35,-.3,5.);\n\tfloat eyeR = sdSphere(q,.3);\n\n    q = headPos - posFromAngle(1.54,1.54,5.3);\n\tfloat headphoneL = sdSphere(q,1.3);\n\n\tq = headPos - posFromAngle(1.54,-1.54,5.3);\n\tfloat headphoneR = sdSphere(q,1.3);\n    float headphones = min(headphoneL, headphoneR);\n    q = opTx( pos, Rot4Z(1.3) );\n    float bassin = sdTorus(q, vec2(5.7,.3));\n\t//headphones = min(bassin,headphones);\n    vec2 neon = vec2(headphones,NEON);\n\n\tfloat eyes = min(eyeL,eyeR);\n\tvec2 blue = vec2(eyes, BLUE);\n\tvec2 pink = vec2(min(bassin,pinkHears),PINK);\n\n\tq = pos - posFromAngle(phi+1.5,0.,5.1);\n\tfloat noze = sdSphere(q,.1);\n\n\tq = pos - posFromAngle(phi+1.5,.4,5.);\n\tq = opTx( q, Rot4X(-1.3) );\n\tfloat mustache = sdCappedCylinder(q, vec2(.05,2.5));\n\n\tq = pos - posFromAngle(phi+1.55,.4,5.);\n\tq = opTx( q, Rot4X(-1.4) );\n\tmustache = min(mustache,sdCappedCylinder(q, vec2(.05,2.5)));\n\n\tq = pos - posFromAngle(phi+1.6,.4,5.);\n\tq = opTx( q, Rot4X(-1.5) );\n\tmustache = min(mustache,sdCappedCylinder(q, vec2(.05,2.5)));\n\n\tq = pos - posFromAngle(phi+1.5,-.4,5.);\n\tq = opTx( q, Rot4X(1.3) );\n\tmustache = min(mustache,sdCappedCylinder(q, vec2(.05,2.5)));\n\n\tq = pos - posFromAngle(phi+1.55,-.4,5.);\n\tq = opTx( q, Rot4X(1.4) );\n\tmustache = min(mustache,sdCappedCylinder(q, vec2(.05,2.5)));\n\n\tq = pos - posFromAngle(phi+1.6,-.4,5.);\n\tq = opTx( q, Rot4X(1.5) );\n\tmustache = min(mustache,sdCappedCylinder(q, vec2(.05,2.5)));\n\n    \n    q = opTx( pos-vec3(-25.,17.,120.), Rot4Y(.2) );\n    float speakerL = sdBoxRounded(q,vec3(20.,50.,20.),0.1);\n    q = opRepY(pos-vec3(2.,14.,70.),16.);\n    float speakerSphere = sdSphere(q,2.+(1.-freqs[1])*11.);\n    speakerL = opS(speakerL,speakerSphere);\n    white.x = min(speakerL,white.x);\n\n    q = opTx( pos-vec3(-25.,17.,-120.), Rot4Y(-.2) );\n    float speakerR = sdBoxRounded(q,vec3(20.,50.,20.),0.1);\n    q = opRepY(pos-vec3(2.,14.,-70.),16.);\n    speakerSphere = sdSphere(q,2.+(1.-freqs[1])*11.);\n    speakerR = opS(speakerR,speakerSphere);\n\n    white.x = min(speakerR,white.x);\n\n    q = opRepZ(pos-vec3(-50.,70.,-70.),20.);\n\tfloat projectors = sdBoxRounded(q,vec3(freqs[1]*11.),3.);\n    neon.x = min(projectors,neon.x);\n\n    if(freqs[3]<.62){\n   \t\tq = opRepZ(pos-vec3(-75.,10.,-70.),100.);\n   \t\tq = opTx( q, Rot4X(freqs[2]*10.)*Rot4Y(freqs[3]*10.) );\n\t\tprojectors = sdBoxRounded(q,vec3(freqs[1]*30.),0.);\n  \t\tneon.x = min(projectors,neon.x);\n    } else {\n    \tq = opRepZ(pos-vec3(-75.,25.,-70.),100.);\n\t\tprojectors = sdSimpleCat(q/2.5)*2.5;\n  \t\tneon.x = min(projectors,neon.x);\n    }\n\n    q = pos-vec3(19.,-15.,0.);\n    float table = sdBoxRounded(q,vec3(8.,5.5,20.),0.);\n\twhite.x = min(white.x,table);\n\n    q = pos-vec3(29.,-13.,0.);\n    float tableCat = sdSimpleCat(q/.25)*.25;\n\tneon.x = min(neon.x,tableCat);\n\n    q = pos-vec3(-25.,-50.,0.);\n    float stage = sdBoxRounded(q,vec3(30.,20.,2000.),0.);\n\twhite.x = min(white.x,stage);\n\n    q = pos-vec3(17.,-14.,11.);\n    float dj = sdCappedCylinder(q,vec2(6.,5.3));\n    neon.x = min(dj,neon.x);\n    //white.x = min(dj,white.x);\n    q = pos-vec3(17.,-14.,-11.);\n    dj = sdCappedCylinder(q,vec2(6.,5.3));\n    neon.x = min(dj,neon.x);\n    //white.x = min(dj,white.x);\n\n\tvec2 black = vec2(min(noze,mustache),BLACK);\n    pos += vec3(0.,40.,0.);\n\n    if(pos.x>30.){\n    \tq = opRep(pos+vec3(0.,10.+cos(iTime*10.)*2.,0.),vec3(60.,50.,60.));\n        float cats = sdSimpleCat(q);\n\n        q = opRep(pos+vec3(25.,10.+cos(iTime*10.+.5)*2.,25.),vec3(60.,50.,60.));\n        cats = min(cats,sdSimpleCat(q));\n\n        q = opRep(pos+vec3(50.,10.+cos(iTime*10.+1.)*2.,50.),vec3(60.,50.,60.));\n        cats = min(cats,sdSimpleCat(q));\n\n        white.x = min(white.x,cats);\n    }\n\n    vec2 infos = opU(white,blue);\n\tinfos = opU(infos,pink);\n\tinfos = opU(infos,black);\n    infos = opU(infos,nyan);\n    infos = opU(infos,neon);\n\treturn infos;\n}\n\n\n//------------------------------------------------------------------ RAYMARCHING / NORMAL / SHADOW ( call map )\n\n#ifdef RENDER_DEPTH\nvec2 castRay( in vec3 ro, in vec3 rd, inout float depth )\n#else\nvec2 castRay( in vec3 ro, in vec3 rd )\n#endif\n{\n\tfloat tmax = 500.;\n\tfloat precis = .01;\n\tfloat t = 0.0;\n\tvec2 res;\n\n\tfor( int i=0; i<RAYMARCHING_STEP; i++ )\n\t{\n\t\tvec3 pos = ro+rd*t;\n\t\tres = map( pos );\n\t\tif( res.x<precis || t>tmax ) break;\n\t\tt += res.x*RAYMARCHING_JUMP;\n\n\t\t#ifdef RENDER_DEPTH\n\t\tdepth += 1./float(RAYMARCHING_STEP);\n\t\t#endif\n\t}\n\treturn vec2( t, res.y );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tconst vec2 e = vec2(0.001,-0.001);\n\treturn normalize( e.xyy*map( pos + e.xyy ).x +\n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x +\n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x +\n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\n//------------------------------------------------------------------ RENDER\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv )\n{\n\tvec3 col;\n\n\t#ifdef RENDER_DEPTH\n\tfloat depth = 0.;\n\tvec2 res = castRay(ro,rd,depth);\n\t#else\n\tvec2 res = castRay(ro,rd);\n\t#endif\n\n\tfloat t = res.x;\n\tfloat m = res.y;\n\n\tvec3 pos = ro + t * rd;\n\tvec3 nor = calcNormal(pos);\n\t\tvec3 lig = vec3(0.6, 0.5, -0.5);\n\n    col = vec3(1.);\n\tcol *= clamp( dot( nor, lig ), 0.0, 1.0 )*vec3(1.);\n\tvec3 ambient = vec3(.3,.3,.4);\n\tcol += ambient*(1.-col);\n    \t\n    if( m == NYAN )\n\t{\n \t\tvec2 uv = vec2( pos.z/100.-mod(iTime,1.0), 1.5*pos.y/80. );\n\t\t//thanks IQ! <3\n       \tfloat ww = 40.0/256.0;\n    \tfloat ofx = floor( mod( iTime*10.0*2.0, 6.0 ) );\n\t \tuv.y = 1.0-uv.y;\n\t\tuv.x = clamp( uv.x*ww + ofx*ww, 0.0, 1.0 );\n       col = texture( iChannel1, uv ).rgb;\n       col *= vec3(1.,.3,.3);\n   }\n    \n    if( m == NEON ){\n        col *= 1.3;\n    \tdepth *= 3.;\n    }\n    \n\tif(t>400.){\n\t\tcol = vec3(.6,.5,.35)*.1;\n\t}\n\n\t#ifdef RENDER_DEPTH\n    \tvec3 depthColor = vec3(depth)*vec3(.8,.2,.1);\n    \tcol = mix(col,depthColor,freqs[0]);\n    #endif\n\n\treturn col;\n}\n\n\n//------------------------------------------------------------------ POSTEFFECTS\n\n#ifdef POSTPROCESS\n\nvec3 bw( in vec3 col )\n{\n\treturn vec3(0.299*col.r + 0.587*col.g + 0.114*col.b);\n}\n\nvec3 postEffects( in vec3 col, in vec2 uv, in float time )\n{\n    if(freqs[3]>.65){\n\t\tcol = bw( col*1.5 );\n    }\n\n\t// vigneting\n\tcol *= 0.25+0.75*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.15 );\n\n\t//extra bright\n\tcol+=0.05;\n\treturn col;\n}\n\n#endif\n\n\n//------------------------------------------------------------------ CAMERA\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n\n\n//------------------------------------------------------------------ MAIN\n\nvoid mainImage( out vec4 fragColor, in vec2 coords )\n{\n    freqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel0, vec2( 0.1, 0.3 ) ).x;\n\tfreqs[2] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel0, vec2( 0.2, 0.05 ) ).x;\n\n\tfloat time = mod(iTime,100.);\n\tvec2 uv = coords.xy / iResolution.xy;\n\tvec2 mouse = iMouse.xy/iResolution.xy;\n\n\tvec2 q = coords.xy/iResolution.xy;\n\tvec2 p = (-iResolution.xy+2.0*coords.xy)/iResolution.y;\n\n    //Close camera\n\tfloat angle = 0.;\n\tfloat radius = 1.+freqs[2]*freqs[2]*250.;\n    vec3 ro = vec3(cos(angle)*radius,cos(time/3.)*4.+9.,sin(angle)*radius);\n    vec3 ta = vec3(0.);\n\n    //Far camera\n    angle = sin(iTime)*.3;\n    radius += 70.+freqs[2]*freqs[2]*380.;\n    vec3 ro2 = vec3(cos(angle)*radius,cos(time/3.)*4.+50.,sin(angle)*radius);\n\n    //Select the camera\n    float s = sign(freqs[3] - .5);\n    ro = mix(ro,ro2,clamp(s,0.,1.));\n\n\tmat3 ca = setCamera( ro, ta, 0. );\n\tvec3 rd = ca * normalize( vec3(p.xy,1.5) );\n\n\tvec3 color = render( ro, rd, uv );\n\n\t#ifdef POSTPROCESS\n\tcolor = postEffects( color, uv, time );\n\t#endif\n\tfragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}