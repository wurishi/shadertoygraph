{"ver":"0.1","info":{"id":"NdSfzd","date":"1649335847","viewed":60,"name":"Cours 2 3D - IUT2","username":"vangriea","description":"Cours","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Antonio VAN GRIEKEN FUGUET\n//LP Applications Web\n\n#define R iResolution.xy\n#define DIST_MIN 0.5 // minimum distance to objects\n#define DIST_MAX 30.0 // maximum distance to objects\n#define RAY_MARCH_STEPS 100\n#define RAY_MARCH_PRECI 0.001\n#define PI 3.14159265359\n#define mouseUp      ( iMouse.z < 0. )                  // mouse up even:   mouse button released (well, not just that frame). cf https://www.shadertoy.com/view/3dcBRS\n#define mouseDown    ( iMouse.z > 0. && iMouse.w > 0. ) // mouse down even: mouse button just clicked\n#define mouseClicked ( iMouse.w < 0. )                  // mouse clicked:   mouse button currently clicked\n#define fond vec3(vec2(iMouse.xy/iResolution.xy),1.0)\n// ray structure\nstruct Ray {\n    vec3 o; // origin\n    vec3 d; // direction\n};\n\nstruct Surface {\n    float t; // surface distance\n    vec3 c; // surface color\n};\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\nSurface minSurf(Surface s1, Surface s2){\n    if(s1.t < s2.t){\n        return s1;\n    }else{\n        return s2;\n    }\n}\n\nSurface scene(in vec3 p) {\n    vec3 t = p*2.;\n    float v1 = (cos(t.x)*cos(t.y)*cos(t.z)/9.)*sin(iTime*2.);\n    float v2 = ((sin(t.x)+sin(t.y))/5.)*sin(iTime*2.);\n    float v5 = ((sin(t.x)+cos(t.y))/4.5)*sin(iTime*5.);\n    float v3 = ((sin(t.x)+sin(t.y))/9.)*sin(iTime*4.);\n    float v4 = ((sin(t.x)+sin(t.y))/9.)*sin(iTime*9.);\n    \n    float d1 = sdSphere(p+(sin(iTime*1.3)*2.)+vec3(3.,0.5+cos(iTime)*2.,-4.),1.1)+v1;\n    float d2 = sdSphere(p+(cos(iTime*1.2)*2.)+vec3(1.,5.,-2.),1.2)+v4;\n    float d3 = sdSphere(p+(sin(iTime)*4.)+vec3(5.,6.,6.),0.5)+v3;\n    float d4 = sdSphere(p+(cos(iTime)*2.2)+vec3(4.,7.,5.),1.4)+v3;\n    float d5 = sdSphere(p+(sin(iTime)*2.4)+vec3(2.,3.,-3.),1.4)+v2;\n    float d6 = sdSphere(p+(cos(iTime)*1.8)+vec3(9.,sin(iTime*2.)+9.,3.),1.8)+v3+v1;\n    float d7 = sdSphere(p+(sin(iTime)*1.5)+vec3(5.,2.,4.),1.4)+v2;\n    float d8 = sdSphere(p+(cos(iTime)*2.)+vec3(6.,0.,-2.),1.3)+v5;\n    \n    return minSurf(\n        minSurf(\n            minSurf(\n                Surface(d1,vec3(3.,1.,0.)),\n                Surface(d2,vec3(1.,1.,0.))\n            ),\n            minSurf(\n                Surface(d7,vec3(0.,1.,2)),\n                Surface(d8,vec3(1.,1.,2.))\n            )\n        ),\n        minSurf(\n            minSurf(\n                Surface(d3,vec3(1.,1.,1.)),\n                Surface(d4,vec3(0.,1.,0.))\n            ),\n            minSurf(\n                Surface(d5,vec3(1.,0.,0.)),\n                Surface(d6,vec3(0.,1.,1.))\n            )\n        )\n    );\n}\n\nSurface march(in Ray r) {\n    float t = DIST_MIN;\n\n    for(int i=0;i<RAY_MARCH_STEPS,t<=DIST_MAX;++i) {\n        Surface s = scene(r.o+t*r.d);\n\n        if(s.t<RAY_MARCH_PRECI) {\n            return Surface(t+s.t,s.c);\n        }\n\n        t = t+s.t;\n    }\n    \n    return Surface(DIST_MAX,fond);\n}\n\nvec3 normalAt(in Surface s,in Ray r) {\n    const float e = 0.01;\n    vec3 p = r.o+s.t*r.d;\n    float nx = scene(vec3(p.x+e,p.y,p.z)).t-scene(vec3(p.x-e,p.y,p.z)).t;\n    float ny = scene(vec3(p.x,p.y+e,p.z)).t-scene(vec3(p.x,p.y-e,p.z)).t;\n    float nz = scene(vec3(p.x,p.y,p.z+e)).t-scene(vec3(p.x,p.y,p.z-e)).t;\n\n    return normalize(vec3(nx,ny,nz));\n}\n\nRay camRay(in vec2 p) {\n    // camera position\n    float DP = 20.;\n    float d = DP/3.;\n    //vec3 ro = vec3(d*cos(iTime/2.),DP/5.0,d*sin(iTime/2.) );\n\n    vec3 ro = vec3(10.,7.,0.);\n\n    // target point\n    //vec3 ta = vec3(0.0,DP/10.0,0.0);\n    vec3 ta = vec3(0.0,0.0,0.0);\n\n    // camera view vector\n    vec3 cw = normalize(ta-ro);\n\n    // camera up vector\n    vec3 cp = vec3(0.0,1.0,0.0);\n\n    // camera right vector\n    vec3 cu = normalize(cross(cw,cp));\n\n    // camera (normalized) up vector\n    vec3 cv = normalize(cross(cu,cw));\n    \n    float fovDeg = 45.;\n    float fovRad = (fovDeg/360.)*2.*PI;\n    float zf = 1./tan(fovRad/2.);\n    \n    // view vector, including perspective (the more you multiply cw, the less fovy)\n    vec3 rd = normalize(p.x*cu + p.y*cv*(R.y/R.x) + 2.*cw);\n\n    return Ray(ro,rd);\n}\n\nvec3 shade(in Surface surf, in Ray ray) {\n    // tous les vecteurs nécessaires au shading\n    vec3 n = normalAt(surf,ray);\n    vec3 l = normalize(vec3(1.,1.,0.));\n    vec3 v = ray.d;\n    vec3 r = reflect(l,n);\n    \n    // parametres du materiel\n    vec3 kd = surf.c;\n    vec3 ks = vec3(0.8);\n    float s = 20.;\n    \n    // coeficients diffus et spéculaires\n    float diff = max(dot(n,l),0.);\n    float spec = pow(max(dot(r,v),0.),s);\n    \n    return kd*diff + ks*spec;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord / R.xy)*2.-1.;\n    \n    Ray r = camRay(uv);\n    Surface s = march(r);\n    vec3 c = s.c;\n    \n    if(iMouse.z > 0.0){\n        c = fond;\n    }\n    \n    if(s.t<DIST_MAX) {\n        c = shade(s,r);\n    }\n    \n    fragColor = vec4(c,1.0); \n}","name":"Image","description":"","type":"image"}]}