{"ver":"0.1","info":{"id":"llfyW2","date":"1506429501","viewed":217,"name":"Sci-Fi pipes panel","username":"Gallo","description":"ray marching procedural texture set of a sci-fi pipes panel","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["procedural","raymarching","scifi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 r = texture(iChannel0, uv);\n\t\n    // gamma\n    r = clamp(r,0.0,1.0);\n\tr = vec4( pow( r , vec4(1.8/2.2)));    \n    \n    fragColor =  r;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Procedural Sci-Fi pipes panel\n//by @galloscript\n\n#define MESH \t\t\t\t(0)\n#define AMBIENT_OCCLUSION \t(1)\n#define HEIGHT_MAP\t\t\t(2)\n#define CURVATURE \t\t\t(3)\n#define NORMAL_MAP\t\t\t(4)\n\n//Change here the map ids\n#define MAP_ID MESH\n\n//set CAM_DEPTH 6 to remove perspective, 1. to see with perspective\n#define CAM_DEPTH 6.  \n\n\n#define PI 3.142\n#define MARCHING_STEPS   256\n#define ROTATE_CAM  false\n\nconst vec3 X_AXIS = vec3(1,0,0);\nconst vec3 Y_AXIS = vec3(0,1,0);\nconst vec3 Z_AXIS = vec3(0,0,1);\n\nvec3 gMouseLight = vec3(-40.3, 20.3,30.);\n\nstruct Material\n{\n    vec4 col;\n    float ref;\n};\n\n#define MAX_MATERIALS 7\nconst Material gMaterials[MAX_MATERIALS] = Material[](\n    Material(vec4(0.94901, 0.90588, 0.780392, 1.0), 0.0),//0 = background \n    Material(vec4(0.1, 1.0, 1.02, 0.0), 1.0),  \t\t\t //1 = blue pipes\n    Material(vec4(1.10, 1.0, 1.0, 0.0), 1.0),  \t\t\t //2 = white boxes\n    Material(vec4(0.83, 0.04, 0.03, 0.0), 1.5),   \t\t //3 = red pipes\n    Material(vec4(0.23, 0.4, 0.3, 0.0), 0.8),   \t\t //4 = green box\n    Material(vec4(0.42, 0.4, 0.4, 0.0), 1.0),  \t\t\t //5 = grey boxes\n    Material(vec4(0.5, 0.5, 0.5, 0.0), 0.9) \t\t\t //6 = unused\n);\n    \n\n// first object gets a v-shaped engraving where it intersect the second\nfloat fOpEngrave(float a, float b, float r) {\n\treturn max(a, (a + r - abs(b))*sqrt(0.5));\n}\n\n\nfloat sdTorus( vec3 p, vec2 t, mat3 m )\n{\n  p = m * p;\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nfloat sdCappedCylinder( vec3 p, vec2 h, mat3 m  )\n{\n    p = m * p;\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}  \n\nfloat udRoundBox( vec3 p, vec3 b, float r, mat3 m  )\n{\n  p = m * p; \n  return length(max(abs(p)-b,0.0))-r;\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r, mat3 m )\n{\n    p = m * p;\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n\nfloat sdBox( vec3 p, vec3 b, mat3 m )\n{\n  p = m * p;\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t, mat3 m  )\n{\n  p = m * p;\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nmat3 rotation(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return inverse(mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n                                              oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  \n                                              oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c));\n}\n\n\nfloat map(vec3 p, out int material)\n{\n    float d2, d, b = 0.0;    \n    mat3 rot = mat3(1);\n    float c, c2;\n    d2 = d = b = 200000.;\n\t\n    p.z += CAM_DEPTH;\n    \n    //FRAME BOX\n    d = min(d, sdBox(p + vec3(0.,0.,0.5), vec3(1,1,0.5), rot));\n    //d = max(d, -udRoundBox(p + vec3(0.,0.,-0.15), vec3(0.9,0.9,0.4), 0.04, rot));\n    d = max(d, -sdBox(p + vec3(0.,0.,-0.15), vec3(0.9,0.9,0.4), rot));\n    if(d < b){ material = 0; b = d; }\n    \n    \n    //CENTER PANEL\n    d = min(d, udRoundBox(p + vec3(-0.03,-0.6,0.3), vec3(0.4,0.2,0.18), 0.02, rot));\n    d = min(d, udRoundBox(p + vec3(0.17,-0.2,0.3), vec3(0.2,0.2,0.18), 0.02, rot));\n    d = min(d, udRoundBox(p + vec3(-0.03,-0.6,0.26), vec3(0.35,0.05,0.18), 0.02, rot));\n    d = min(d, udRoundBox(p + vec3(0.07,-0.7,0.26), vec3(0.25,0.05,0.18), 0.02, rot));\n    d = min(d, udRoundBox(p + vec3(0.17,-0.25,0.26), vec3(0.15,0.2,0.18), 0.02, rot));\n    if(d < b){ material = 2; b = d; }\n    \n     //LEFT TWIN PIPES\n    rot = mat3(1);\n    d = min(d, sdCappedCylinder( p + vec3(0.775, 0.0, 0.16), vec2(0.1, 1.0), rot));\n    d = min(d, sdCappedCylinder( p + vec3(0.56, 0.0, 0.16), vec2(0.1, 1.0), rot));\n    if(d < b){ material = 3; b = d; }\n    \n    //UPPER RIGHT BOXES\n    d = min(d, udRoundBox(p + vec3(-0.25,-0.2,0.26), vec3(0.12,0.05,0.18), 0.02, rot));\n    d = min(d, udRoundBox(p + vec3(-0.7,-0.73,0.26), vec3(0.08,0.08,0.18), 0.02, rot));\n    if(d < b){ material = 5; b = d; }\n    \n    \n    //BOTTOM RIGHT PANEL\n    d2 = udRoundBox(p + vec3(-0.6,0.4,0.24), vec3(0.2,0.4,0.18), 0.04, rot);\n    d2 = fOpEngrave(d2, udRoundBox(p + vec3(-0.6,0.4,0.1), vec3(0.18,0.38,0.18), 0.01, rot), 0.015);\n    d2 = min(d2, sdSphere(p  + vec3(-0.6,0.1,0.0), 0.05));\n   \n    d = min(d, d2);\n    if(d < b){ material = 4; b = d; }\n    \n    //RIGHT BIG PIPE\n    rot = rotation(X_AXIS, PI * 0.5);\n    d2 = min(d2, sdTorus( p + vec3(-0.75, -0.33, 0.16), vec2(0.15, 0.1), rot ));\n    d2 = max(d2, sdBox( p + vec3(-0.6, -0.47, 0.16), vec3(0.13, 0.15, 0.1), mat3(1) ));\n    d = min(d, d2);\n    rot = rotation(Z_AXIS, PI * 0.5);\n    d = min(d, sdCappedCylinder( p + vec3(-0.86, -0.478, 0.16), vec2(0.1, 0.14), rot));\n    rot = mat3(1);\n    d = min(d, sdCappedCylinder( p + vec3(-0.6, -0.123, 0.16), vec2(0.1, 0.2), rot));\n    d = min(d, sdCappedCylinder( p + vec3(-0.6, 0.8, 0.16), vec2(0.1, 0.2), rot));\n    if(d < b){ material = 1; b = d; }\n        \n   \n    //TORUS CORE\n    rot = rotation(X_AXIS, PI * 0.5);\n    d = min(d, sdTorus82( p + vec3(0.05, 0.5, 0.12), vec2(0.25, 0.06), rot));\n    d = min(d, sdTorus82( p + vec3(0.05, 0.5, 0.12), vec2(0.08, 0.04), rot));\n    if(d < b){ material = 5; b = d; }\n    rot = mat3(1);\n    d = min(d, udRoundBox(p + vec3(0.05,0.5,0.38), vec3(0.33,0.33,0.18), 0.02, rot));\n    if(d < b){ material = 2; b = d; }\n\n    \n    d = min(d, sdCappedCylinder( p + vec3(0.05, 0.64, 0.12), vec2(0.03, 0.06), rot));\n    rot = rotation(Z_AXIS, PI * 0.75);\n    d = min(d, sdCappedCylinder( p + vec3(0.18, 0.38, 0.12), vec2(0.03, 0.06), rot));\n    \n    rot = rotation(Z_AXIS, PI * -0.85);\n    d = min(d, sdCappedCylinder( p + vec3(-0.08, 0.2, 0.12), vec2(0.03, 0.09), rot));\n    rot = rotation(Z_AXIS, PI * 0.5);\n    d = min(d, sdCappedCylinder( p + vec3(-0.255, 0.13, 0.12), vec2(0.03, 0.15), rot));\n        \n    rot = rotation(X_AXIS, PI * 0.5);\n    d = min(d, sdTorus( p + vec3(0.05, 0.5, 0.05), vec2(0.25, 0.025), rot) );\n    if(d < b){ material = 1; b = d; }\n        \n    //UPPER RIGHT PIPES\n    rot = mat3(1);\n    d = min(d, sdCapsule( p + vec3(-0.2,-0.2,0.06), vec3(0.,0.,0.), vec3(0.,0.25,0.), 0.04, rot ));\n    d = min(d, sdCapsule( p + vec3(-0.3,-0.2,0.06), vec3(0.,0.,0.), vec3(0.,0.25,0.), 0.04, rot ));    \n    d = min(d, sdCapsule( p + vec3(-0.3,-0.73,0.06), vec3(0.,0.,0.), vec3(0.4,0.0,0.), 0.04, rot ));\n        \n    if(d < b){ material = 1; b = d; }\n    \n    return d;\n}\n\nvec3 calcNormal(in vec3 pos) \n{\n    int mat;\n    vec2 e = vec2(1.0, -1.0) * 0.001;\n    return normalize(\n        e.xyy * map(pos + e.xyy, mat) +\n        e.yyx * map(pos + e.yyx, mat) +\n        e.yxy * map(pos + e.yxy, mat) +\n        e.xxx * map(pos + e.xxx, mat));\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    int mat;\n    float occ = 0.0;\n    float sca = 1.0, dd;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.09*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        dd = map( aopos, mat );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    float res = clamp( 1.0 - 1.6*occ, 0.0, 1.0 );\n    return res;    \n}\n\nvec4 GetMaterialColor(int tex, vec2 coord)\n{\n    if(tex == -1) return vec4(1., 1., 1., 1.);\n    switch(tex)\n    {\n        case 0: return texture(iChannel0, coord);\n        case 1: return texture(iChannel1, coord);\n        case 2: return texture(iChannel2, coord);\n        case 3: return texture(iChannel3, coord);\n    };\n}\n\nvec4 trace(vec3 ro, vec3 rd)//, out vec3 normal, out float ao, out float depth)\n{\n    int matId;\n    float h, t = 0.;\n    for(int i = 0; i < MARCHING_STEPS; ++i)\n    {\n        h = map(ro + rd * t, matId);\n        t += h;\n        if(h < 0.001) break;\n    }\n\t\n    vec3 endPoint = ro + rd * t;\n    Material mat = gMaterials[matId];\n     \n    if(mat.col.a > 1.)\n    {\n       return vec4(mat.col.rgb * mat.col.a * 0.15, 1.0);\n    }\n    if (h < 0.001) \n    {\n        vec3 p = ro + rd * t;\n        vec3 normal = calcNormal(p);\n             \n        vec4 lsum = vec4(0.0f);\n\n            vec3 light = gMouseLight;\n            float dif = clamp(dot(normal, normalize(light - p)), 0., 1.);\n            float spe = pow(clamp(dot(normal,normalize(ro+(light-p))), 0., 1.), 30.);\n\t\t\tlsum.xyz+=dif*mat.col.rgb;\n            lsum.xyz+=vec3(mat.col.rgb)*spe*mat.ref;\n        lsum.w = 1.;\n\n        vec4 normalMapSizzled = vec4((normal + 1.0) * 0.5, 1.);\n        normalMapSizzled.r = 1.0 - normalMapSizzled.r;\n        \n#ifdef MAP_ID\n        \n#\tif  (MAP_ID == AMBIENT_OCCLUSION)\n        return vec4(vec3(calcAO(p, normal)), 1.); \n#\telif  (MAP_ID == HEIGHT_MAP)\n        return vec4(vec3(((p.z + CAM_DEPTH) * 1.5) + 0.4), 1.0);\n#\telif  (MAP_ID == CURVATURE)\n        return vec4(vec3(((p.z + CAM_DEPTH) * 1.5) + 0.4), 0.8); //height with a < 1.0 for the Buffer B\n#\telif  (MAP_ID == NORMAL_MAP)\n        return normalMapSizzled;\n#\tendif\n#endif\n    \n    int lStep = int(iTime * 0.5) % 5;\n\tif  (lStep == AMBIENT_OCCLUSION)\n        return vec4(vec3(calcAO(p, normal)), 1.); \n\telse if  (lStep == HEIGHT_MAP)\n        return vec4(vec3(((p.z + CAM_DEPTH) * 1.5) + 0.4), 1.0);\n\telse if  (lStep == CURVATURE)\n        return vec4(vec3(((p.z + CAM_DEPTH) * 1.5) + 0.4), 0.8); //height with a < 1.0 for the Buffer B\n\telse if  (lStep == NORMAL_MAP)\n        return normalMapSizzled;\n\t\n        \n        return vec4(vec3(calcAO(p, normal) * lsum), 1.0);\n    } \n    else \n    {\n        return vec4(vec3(0.8), 1);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = (fragCoord.xy - .5 * iResolution.xy ) / iResolution.y;\n    mat3 cameraRot = rotation(Y_AXIS, iMouse.x * 4. / iResolution.y) * rotation(X_AXIS, -iMouse.y / iResolution.y);\n    cameraRot = ROTATE_CAM ? cameraRot : mat3(1.0);\n    vec3 ro = cameraRot * vec3(vec2(0., 0.) / iResolution.xy, CAM_DEPTH);\n    vec3 rd = normalize(cameraRot*vec3(q, 0.) - ro);\n\t\n    //gMouseLight.x = (iMouse.x / iResolution.x * gMouseLight.z * 2.) - gMouseLight.z;\n    //gMouseLight.y = (iMouse.y / iResolution.y * gMouseLight.z * 2.) - gMouseLight.z;\n    \n    vec4 thing = trace(ro, rd);\n    fragColor = thing;\n\n}\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float generate_curviness(vec2 uv, vec2 res, float radius)\n{\n    //determine curviness at each point and return it\n    float curviness = 0.;\n    float vcurviness, hcurviness;\n    for(float d = 1.; d < radius + 1.; d += 1.)\n    {\n\n        if( ((uv.x-d) < 0.) || ((uv.x+d) >= res.x) || ((uv.y-d)< 0.) || ((uv.y+d) >= res.y) )\n        {\n            continue;\n        }\n        else\n        {\n            float h = texture(iChannel0, uv/res).r;\n            float hv1 = texture(iChannel0, (uv - vec2(0., d))/res).r;\n            float hv2 = texture(iChannel0, (uv + vec2(0., d))/res).r;\n            float hh1 = texture(iChannel0, (uv - vec2(d, 0.))/res).r;\n            float hh2 = texture(iChannel0, (uv + vec2(d, 0.))/res).r;\n\t\t\t\n            \n            \n            if( hv1 < hv2 )\n            {\n                vcurviness = (h - hv2) - (hv1 - h);\n            }\n            else\n            {\n                vcurviness = (h - hv1) - (hv2 - h);\n            }\n\n            if( hh1 < hh2 )\n            {\n                hcurviness = (h - hh2) - (hh1 - h);\n            }\n            else\n            {\n                hcurviness = (h - hh1) - (hh2 - h);\n            }\n\n            curviness += (vcurviness + hcurviness) / (d*1.);\n        }\n    }\n    \n    return curviness;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 r = texture(iChannel0, uv);\n    \n    r.rgb = (r.a < 1.0) ? vec3(generate_curviness(fragCoord, iResolution.xy, 7.) + 1.0) * 0.5 : r.rgb;\n    \n    fragColor = vec4(vec3(r.xyz),1.0);\n}","name":"Buf B","description":"","type":"buffer"}]}