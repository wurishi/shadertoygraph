{"ver":"0.1","info":{"id":"llj3WR","date":"1428407297","viewed":1797,"name":"Orb","username":"dila","description":"Flying around in a structure of spheres and bars.","likes":40,"published":1,"flags":0,"usePreview":0,"tags":["repetition","shadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define PI 3.14159\n\nmat3 xrot(float t)\n{\n    return mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrot(float t)\n{\n    return mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrot(float t)\n{\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat map(vec3 pos)\n{\n\tvec3 rpos = fract(pos) * 2.0 - 1.0;\n    \n    float tl = length(rpos);\n    float tv = acos(rpos.z/tl);\n    float tu = atan(rpos.y,rpos.x);\n    \n    float bump = texture(iChannel1, vec2(tv,tu)*0.5).x*2.0-1.0;\n    \n\tfloat d = sdSphere(rpos, 1.2+bump*0.005);\n    \n    vec2 ts = vec2(0.6,0.05);\n    \n    float td = 1000.0;\n    \n    vec3 ro = rpos;\n    \n    float rad = 0.1 + bump * 0.003;\n    \n    float ta = sdHexPrism(ro, vec2(rad, 1000.0));\n    \n    float tb = sdHexPrism(ro*yrot(PI*0.5), vec2(rad, 1000.0));\n    \n    float tc = sdHexPrism(ro*xrot(PI*0.5), vec2(rad, 1000.0));\n    \n    d = min(-d, min(min(ta,tb),tc));\n    \n    return d;\n}\n\nvec3 surfaceNormal(vec3 pos) {\n \tvec3 delta = vec3(0.01, 0.0, 0.0);\n    vec3 normal;\n    normal.x = map(pos + delta.xyz) - map(pos - delta.xyz);\n    normal.y = map(pos + delta.yxz) - map(pos - delta.yxz);\n    normal.z = map(pos + delta.zyx) - map(pos - delta.zyx);\n    return normalize(normal);\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n    \tvec3 pos = o + r * t;\n\t\tfloat d = map(pos);\n        t += d * 0.5;\n    }\n    return t;\n}\n\nvec3 pos(float time)\n{\n    vec3 o = vec3(0.35);\n\n    float n = 3.0;\n    float a = floor(time/n)*n;\n    float b = fract(time/n)*n;\n    \n    o.x += a + clamp(b-0.0, 0.0, 1.0);\n    o.y += a + clamp(b-1.0, 0.0, 1.0);\n    o.z += a + clamp(b-2.0, 0.0, 1.0);\n    \n    return o;\n}\n\nvec3 smoothpos(float time)\n{\n\tfloat a = floor(time);\n    float b = fract(time);\n    float c = smoothstep(0.0, 1.0, b);\n    return pos(a+c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /* colour scheme */\n    vec3 diffcol = vec3(255.0, 200.0, 128.0) / 255.0;\n    vec3 indspec = vec3(64.0, 128.0, 200.0) / 255.0;\n    vec3 lightc = vec3(148.0, 96.0, 54.0) / 255.0;\n    \n    /* 2d stuff */\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    /* 2d -> 3d projection */\n    float ms = iTime * 0.25;\n    vec3 o = smoothpos(ms);\n    vec3 r = normalize(vec3(uv, 1.0-dot(uv,uv)*0.33));\n    mat3 m = yrot(ms) * xrot(ms) * zrot(ms);\n    r *= m;\n    \n    /* ray marching */\n\tfloat t = trace(o, r);\n    vec3 world = o + r * t;\n    vec3 sn = surfaceNormal(world);\n\n    /* fresnel shading */\n    vec3 pr = reflect(-r, sn);\n    vec3 tf = texture(iChannel0, pr).xxx;\n    float rpr = 1.0-abs(dot(sn,-r));\n    vec3 dc = diffcol*mix(indspec,tf,rpr);\n    dc *= max(dot(sn,-r),0.0);\n    \n    /* lighting and shadows */\n    vec3 lp = o + vec3(0.05, 0.05, -0.00) * m * zrot(iTime);\n    vec3 lv = world + sn * 0.01 - lp;\n    float ld = length(lv);\n    lv /= ld;\n    float lt = trace(lp, lv);\n    float ls = 1.0;\n    if (lt < ld) {\n    \tls = 0.0;   \n    }\n    \n    /* specular lighting */\n    vec3 sr = reflect(lv, sn);\n    float lr = max(dot(sr, -r), 0.0);\n    lr = min(pow(lr, 16.0),1.0);\n    \n    /* light intensity and fogging */\n    float fd = map(world);\n    float ldp = max(dot(lv,-sn),0.0);\n    float la = ldp * lr + ldp / (1.0 + ld * ld + fd * 100.0);\n    float fog = 1.0 / (1.0 + t * t * 0.25 + fd * 100.0);\n    \n    /* put it all together */\n    dc += ls * la * lightc;\n    dc *= fog;\n    \n\tfragColor = vec4(dc,1.0);\n}","name":"","description":"","type":"image"}]}