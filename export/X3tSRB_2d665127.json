{"ver":"0.1","info":{"id":"X3tSRB","date":"1719225945","viewed":31,"name":"sphere cutout","username":"toasted","description":"chunks","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRr","filepath":"/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","previewfilepath":"/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.001\n#define PI 3.14159265359\n#define NUM_SPHERES 15\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\nvec3 getSpherePosition(float t, float angleOffset, float radialOffset, float audioReactive) {\n    float animationDuration = 10.0;\n    float adjustedTime = mod(t, animationDuration);\n    \n    float progress = sin(adjustedTime * 2.0 * PI / animationDuration);\n    \n    vec3 startPoint = vec3(2.0 + radialOffset, 0.0, 0.0);\n    vec3 endPoint = vec3(-2.0 - radialOffset, 0.0, 0.0);\n    \n    vec3 position = mix(startPoint, endPoint, (progress + 1.0) * 0.5);\n    \n    position.y = (0.3 + radialOffset * 0.2) * sin(adjustedTime * 4.0 * PI / animationDuration + angleOffset);\n    position.y += audioReactive * 0.5; // Add audio-reactive vertical movement\n    \n    mat3 rotation = rotateY(angleOffset);\n    return rotation * position;\n}\n\nvec3 getProceduralTexture(vec3 p, float audioReactive) {\n    float noise = sin(p.x * 10.0) * cos(p.y * 10.0) * sin(p.z * 10.0);\n    vec3 color1 = vec3(1.0, 0.7, 0.2);\n    vec3 color2 = vec3(0.1, 0.5, 0.8);\n    return mix(color1, color2, (noise * 0.5 + 0.5) * (1.0 + audioReactive)); // Make color more vibrant with audio\n}\n\nfloat GetDist(vec3 p) {\n    mat3 rot = rotateY(iTime * 0.5) * rotateX(iTime * 0.3);\n    vec3 rotatedP = rot * p;\n    \n    float smallSpheresDist = MAX_DIST;\n    \n    for (int i = 0; i < NUM_SPHERES; i++) {\n        float angleOffset = float(i) * 2.0 * PI / float(NUM_SPHERES);\n        float radialOffset = 0.5 * sin(float(i) * 0.7);\n        float sphereRadius = 0.1 + 0.3 * (float(i) / float(NUM_SPHERES - 1));\n        \n        // Sample audio data\n        float audioSample = texture(iChannel0, vec2(float(i) / float(NUM_SPHERES), 0.0)).x;\n        \n        // Make sphere size audio-reactive\n        sphereRadius *= 1.0 + audioSample * 0.5;\n        \n        vec3 spherePos = getSpherePosition(iTime + float(i), angleOffset, radialOffset, audioSample);\n        float sphereDist = sdSphere(p - spherePos, sphereRadius);\n        smallSpheresDist = min(smallSpheresDist, sphereDist);\n    }\n    \n    float mainSphereRadius = 1.2;\n    float adjustedSphereRadius = mainSphereRadius + 0.05 * sin(iTime);\n    \n    // Make main sphere audio-reactive\n    float bassAudio = texture(iChannel0, vec2(0.1, 0.0)).x;\n    adjustedSphereRadius += bassAudio * 0.2;\n    \n    float mainSphereDist = sdSphere(rotatedP, adjustedSphereRadius);\n    \n    float distortion = sin(p.x * 10.0 + iTime) * sin(p.y * 10.0 + iTime) * sin(p.z * 10.0 + iTime) * 0.03;\n    mainSphereDist += distortion;\n    \n    return opSmoothSubtraction(smallSpheresDist, mainSphereDist, 0.15);\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p);\n    vec2 e = vec2(0.01, 0);\n    vec3 n = d - vec3(\n        GetDist(p - e.xyy),\n        GetDist(p - e.yxy),\n        GetDist(p - e.yyx)\n    );\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 sphereColor(vec3 p, vec3 n, vec3 rd) {\n    float audioSample = texture(iChannel0, vec2(length(p) * 0.1, 0.0)).x;\n    vec3 baseColor = getProceduralTexture(p, audioSample);\n    \n    vec3 lightPos = vec3(2.0 * sin(iTime), 5.0, 3.0 * cos(iTime));\n    vec3 l = normalize(lightPos - p);\n    float diff = max(dot(n, l), 0.0);\n    vec3 r = reflect(-l, n);\n    float spec = pow(max(dot(r, -rd), 0.0), 32.0);\n    \n    float rim = 1.0 - max(dot(n, -rd), 0.0);\n    rim = smoothstep(0.6, 1.0, rim);\n    \n    return baseColor * (diff * 0.7 + 0.3) + vec3(1.0) * spec * 0.5 + vec3(0.3, 0.5, 1.0) * rim;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float sceneRotationSpeed = 0.2;\n    mat3 sceneRotation = rotateY(iTime * sceneRotationSpeed) * rotateX(sin(iTime * 0.5) * 0.2);\n    \n    // Make camera position audio-reactive\n    float bassAudio = texture(iChannel0, vec2(0.05, 0.0)).x;\n    vec3 ro = sceneRotation * vec3(0, 0, -4.0 - bassAudio * 0.5);\n    vec3 rd = sceneRotation * normalize(vec3(uv, 1));\n    \n    float d = RayMarch(ro, rd);\n    \n    if(d < MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 col = sphereColor(p, n, rd);\n        \n        float aberrationStrength = 0.02;\n        vec3 colR = sphereColor(p + vec3(aberrationStrength, 0, 0), n, rd);\n        vec3 colB = sphereColor(p - vec3(aberrationStrength, 0, 0), n, rd);\n        col = vec3(colR.r, col.g, colB.b);\n        \n        float alpha = 0.8;\n        \n        vec3 fogColor = vec3(0.7, 0.8, 1.0) + 0.1 * sin(iTime * 0.5);\n        float fogFactor = 1.0 - exp(-0.1 * d);\n        col = mix(col, fogColor, fogFactor);\n        \n        float glow = exp(-0.1 * d);\n        col += vec3(1.0, 0.7, 0.3) * glow * 0.2;\n        \n        // Add audio-reactive glow\n        float highFreqAudio = texture(iChannel0, vec2(0.8, 0.0)).x;\n        col += vec3(0.5, 0.7, 1.0) * highFreqAudio * 0.5;\n        \n        fragColor = vec4(mix(fogColor, col, alpha), 1.0);\n    } else {\n        // Make background audio-reactive\n        float midFreqAudio = texture(iChannel0, vec2(0.5, 0.0)).x;\n        vec3 bgColor = vec3(0.7, 0.8, 1.0) + 0.1 * sin(iTime * 0.5 + uv.x * 10.0) * sin(iTime * 0.7 + uv.y * 10.0);\n        bgColor += vec3(0.2, 0.3, 0.4) * midFreqAudio;\n        fragColor = vec4(bgColor, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}