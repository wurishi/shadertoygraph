{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"const vec4 orange = vec4(1.0, 0.4, 0.0, 1.0);\nconst vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\nconst vec4 black = vec4(0.0, 0.0, 0.0, 0.0);\nconst vec4 yellow = vec4(1.0, 1.0, 0.0, 1.0);\nconst vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\nconst vec4 gray = vec4(0.4, 0.4, 0.4, 1.0);\nconst vec4 darkgray = vec4(0.2, 0.2, 0.2, 1.0);\n\n\nvec4 drawLetterD( in vec2  center, \n\t\t  in vec2  sPos,\n\t\t  in float aspRatio,\n\t\t  in float baseSize,\n\t\t  in float fontThickness,\n          in vec4  currColor)\n{\n\tvec2 lPos = sPos - center;\n\tlPos.x *= aspRatio; // make square and circle instead of rect and ellipse\n\tfloat outSize = baseSize;\n\tfloat outHSize = outSize * 0.5;\n    vec4 fragColor = currColor;\n\t\n\tfontThickness *= baseSize; // font thickness specified is relative to size of font..\n\t\n\t\n\tfloat inSize = outSize - fontThickness;\n\tfloat inHSize = inSize * 0.5;\n\n\tif( (length(lPos) < outHSize ||\n\t     lPos.x > -outHSize &&\n\t     lPos.y > 0.0 &&\n\t     lPos.x < 0.0 && \n\t     lPos.y < outHSize) &&\n\t   \n\t   !(length(lPos) < inHSize ||\n\t     lPos.x > -inHSize &&\n\t     lPos.y > 0.0 &&\n\t     lPos.x < 0.0 && \n\t     lPos.y < inHSize ) )\n\t{\n\t\tfragColor = darkgray;\n\t}\n\t\n#if 1\n//draw 14\t\n\tfloat littleFontThickness = fontThickness * 0.15;\n\t{\n\t//draw 1 of '14'\n\tfloat up    = 0.3 * outHSize;\n\tfloat down  = -up;\n\tfloat leftBase = -0.3 * outHSize;\n\tfloat left  = leftBase - ((lPos.y > 0.6 * up) ? (fontThickness * 0.1) : 0.0);\n\tfloat right = leftBase + littleFontThickness;\n\t\n\tif(  lPos.x > left &&\n\t     lPos.y > down &&\n\t     lPos.x < right && \n\t     lPos.y < up)\t   \n\t{\n\t\tfragColor = darkgray;\n\t}\n\t}\n\t\n\t//draw 4 of '14'\n\t{\n\tfloat up    = 0.3 * outHSize;\n\tfloat down  = -0.1 * outHSize;\n\tfloat leftBase = -0.012;// * outHSize;\n\tfloat left  = leftBase + 0.75 * lPos.y;\n\tfloat right = left + littleFontThickness * 1.25;\n\t\n\tif(  lPos.x > left &&\n\t     lPos.y > down &&\n\t     lPos.x < right && \n\t     lPos.y < up)\t   \n\t{\n\t\tfragColor = darkgray;\n\t}\n\t\t\n\tup    = 0.3 * outHSize;\n\tdown  = -0.3 * outHSize;\n\tleftBase = -0.012;\n\tleft  = leftBase + 0.78 * 0.33 * outHSize;\n\tright = left + littleFontThickness * 1.0;\n\t\n\tif(  lPos.x > left &&\n\t     lPos.y > down &&\n\t     lPos.x < right && \n\t     lPos.y < up)\t   \n\t{\n\t\tfragColor = darkgray;\n\t}\n\t\t\n\tup    = -0.09 * outHSize;\n\tdown  = -0.2 * outHSize;\n\tleftBase = -0.0135;\n\tleft  = leftBase - 0.065 * outHSize;\n\tright = left + 0.5 * outHSize;\n\t\n\tif(  lPos.x > left &&\n\t     lPos.y > down &&\n\t     lPos.x < right && \n\t     lPos.y < up)\t   \n\t{\n\t\tfragColor = darkgray;\n\t}\t\t\t\n\t}\n\t\n#endif\n    return fragColor;\n}\n\n\nvec4 drawLetterC( in vec2  center, \n\t\t  in vec2  sPos,\n\t\t  in float aspRatio,\n\t\t  in float baseSize,\n\t\t  in float fontThickness,\n          in vec4  currColor)\n{\n    vec4 fragColor = currColor;    \n\tvec2 lPos = sPos - center;\n\tlPos.x *= aspRatio; // make square and circle instead of rect and ellipse\n\t//but make it a controlled ellipse now\n\tlPos.x *= 0.85;\n    \n\t\n\tfontThickness *= baseSize; // font thickness specified is relative to size of font..\n\t\n\tfloat outSize = baseSize;\n\tfloat outHSize = outSize * 0.5;\n\tfloat inSize = outSize - fontThickness;\n\tfloat inHSize = inSize * 0.5;\n\n\tif( (length(lPos) < outHSize &&\n\t\t lPos.x < outHSize*0.45) &&\n\t   \n\t   !(length(lPos) < inHSize) )\n\t{\n\t\tfragColor = darkgray;\n\t}\n    return fragColor;\n}\n\nvec4 drawLetterG( in vec2  center, \n\t\t  in vec2  sPos,\n\t\t  in float aspRatio,\n\t\t  in float baseSize,\n\t\t  in float fontThickness,\n          in vec4  currColor)\n{\n\tvec2 lPos = sPos - center;\n    vec4 fragColor = currColor;\n\tlPos.x *= aspRatio; // make square and circle instead of rect and ellipse\n\t//but make it a controlled ellipse now\n\tlPos.x *= 0.85;\n\t\n\tfontThickness *= baseSize; // font thickness specified is relative to size of font..\n\t\n\tfloat outSize = baseSize;\n\tfloat outHSize = outSize * 0.5;\n\tfloat inSize = outSize - fontThickness;\n\tfloat inHSize = inSize * 0.5;\n\n\tif( (length(lPos) < outHSize &&\n\t\t lPos.x < outHSize*0.45) &&\n\t   \n\t   !(length(lPos) < inHSize) )\n\t{\n\t\tfragColor = darkgray;\n\t}\n\n//\tfloat leftBound = smoothstep(inHSize * 0.15;\n\tfloat derp = smoothstep(-outHSize*0.3, 0.0, lPos.y);\n\tfloat leftBound = inHSize * 0.25 - (derp * 2.0 * inHSize * 0.15);\n\t\n\tif( lPos.x > leftBound &&\n\t    lPos.y > -outHSize*.9 &&\n\t    lPos.x < outHSize*.45 &&\n\t    lPos.y < 0.0)\n\t{\n\t\tfragColor = darkgray;\n\t}\n    return fragColor;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 center = vec2(0.5, 0.5);\n\tfloat radius = 0.3;\n\tfloat aspRatio = iResolution.x / iResolution.y;\n\t\n\tfloat throbAmt = 0.1;\n\tfloat size = 0.3 + throbAmt * sin(iTime*8.0);\n\tfloat hSize = size/2.0;\n\t\n\tvec2 sPos = fragCoord.xy / iResolution.xy;\n\tvec2 uv = sPos;\n\tuv.y = -uv.y;\n\t\n\tcenter.x = (sin(iTime)+1.5)/3.0;\n\tcenter.y = (cos(iTime)+1.5)/3.0;\n\t\n\tvec2 lPos = sPos - center;\n\tlPos.x *= aspRatio; // make square and circle instead of rect and ellipse\n\t\n\tfragColor = gray; // background color\n\n//#define SQUARE\n//#define CIRCLE\n\t\n#ifdef SQUARE\n//Square\n\tif(lPos.x > -hSize &&\n\t   lPos.y > -hSize &&\n\t   lPos.x < (hSize) && \n\t   lPos.y < (hSize) )\n\t{\n\t\tfragColor = texture( iChannel0, uv );\n\t}\n\telse\n\t{\n\t\tdiscard;\n\t}\n#elif defined CIRCLE\n//Circle\n\tfragColor = ((length(lPos) < hSize))?red:black;\n#else\n//GDC Squary Circle throbbing\n\n\tfloat thickness = 0.1;\n\tfloat fontThrobAmt = 0.0;\n\tfloat fontBaseSize = 0.28;\n\tfloat fontThickness = 0.1;\n//\tdrawLetterD(center, sPos, aspRatio, fontThrobAmt, fontBaseSize, fontThickness, true, false);\n\t\n\t\n//left bottom square\n\tif(length(lPos) < hSize ||\n\t   lPos.x > -hSize &&\n\t   lPos.y > -hSize &&\n\t   lPos.x < 0.0 && \n\t   lPos.y < 0.0 )\n\t{\n\t\tfragColor = orange;\n\t}\n\t\n//yellow\n//right top square \n\tcenter.x = (cos(iTime*1.84)+1.5)/3.0;\n\tcenter.y = (sin(iTime*2.2)+1.5)/3.0;\n\tlPos = sPos - center;\n\tlPos.x *= aspRatio; // make square and circle instead of rect and ellipse\n\t\n\tthrobAmt = 0.15;\n\tsize = 0.3 + throbAmt * cos(iTime*6.0);\t\n\thSize = size * 0.35;\n\n\tif(length(lPos) < hSize ||\n\t   lPos.x > 0.0 &&\n\t   lPos.y > 0.0 &&\n\t   lPos.x < hSize && \n\t   lPos.y < hSize )\n\t{\n\t\tfragColor = yellow;\n\t}\n\t\n//red\n//left top square\n\tcenter.x = (cos(iTime*0.64)+1.6)/3.2;\n\tcenter.y = (sin(iTime*1.7)+1.1)/2.2;\n\tlPos = sPos - center;\n\tlPos.x *= aspRatio; // make square and circle instead of rect and ellipse\n\tthrobAmt = 0.15;\n\tsize = 0.4 + throbAmt * cos(iTime*7.0);\t\n\thSize = size * 0.45;\n\n\tif(length(lPos) < hSize ||\n\t   lPos.x > -hSize &&\n\t   lPos.y > 0.0 &&\n\t   lPos.x < 0.0 && \n\t   lPos.y < hSize )\n\t{\n\t\tfragColor = red;\n\t}\n\t\n//white\n//right bottom square\n\tcenter.x = (cos(iTime*1.2)+1.3)/2.6;\n\tcenter.y = (sin(iTime*0.4)+1.3)/2.6;\n\tlPos = sPos - center;\n\tlPos.x *= aspRatio; // make square and circle instead of rect and ellipse\n\tthrobAmt = 0.1;\n\tsize = 0.33 + throbAmt * sin(iTime*2.0);\t\n\thSize = size * 0.3;\n\n\tif(length(lPos) < hSize ||\n\t   lPos.x > 0.0 &&\n\t   lPos.y > -hSize &&\n\t   lPos.x < hSize && \n\t   lPos.y < 0.0 )\n\t{\n\t\tfragColor = white;\n\t}\n\t\n//black\n//right bottom square\n\tcenter.x = (cos(iTime*2.1)+1.3)/2.6;\n\tcenter.y = (sin(iTime*4.0)+1.3)/2.6;\n\tlPos = sPos - center;\n\tlPos.x *= aspRatio; // make square and circle instead of rect and ellipse\n\tthrobAmt = 0.1;\n\tsize = 0.28 + throbAmt * sin(iTime*2.0);\t\n\thSize = size * 0.3;\n\n\tif(length(lPos) < hSize ||\n\t   lPos.x > -hSize &&\n\t   lPos.y > -hSize &&\n\t   lPos.x < 0.0 && \n\t   lPos.y < 0.0 )\n\t{\n\t\tfragColor = black;\n\t}\t\n\t\n//letters\n//GDC\n\tfontThickness = 0.38;\n\tfontBaseSize = 0.4;// + 0.15;// * abs(sin(iTime));\t\n\tcenter = vec2(0.5,0.5);\n\tfragColor = drawLetterD(center, sPos, aspRatio, fontBaseSize, fontThickness, fragColor);\n\tcenter.x = 0.5 + 1.13 * fontBaseSize / aspRatio;\n\tfragColor = drawLetterC(center, sPos, aspRatio, fontBaseSize, fontThickness, fragColor);\n\tcenter.x = 0.5 - 0.85 * fontBaseSize / aspRatio;\n\tfragColor = drawLetterG(center, sPos, aspRatio, fontBaseSize, fontThickness, fragColor);\n\t\n#endif\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Md23Dt","date":"1395398912","viewed":286,"name":"GDC 2014 pulse","username":"dganesh","description":"Checked out the ShaderToy hackathon at GDC. Wrote up my first shader. Super hacky, full of horrendous control flow changes, and tbh lame. But, hey, it's my first. Love ShaderToy!\n-- Plan to clean up the code soon --","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["n00b","sh2014","gdc","learn","branchy","codehorror","shame"],"hasliked":0,"parentid":"","parentname":""}}