{"ver":"0.1","info":{"id":"flXfRn","date":"1650615536","viewed":101,"name":"3D Shapes Ballet","username":"tomansion","description":"Much woaw\nVery wavy\nSuch beautiful ","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["waves","dancing","o","student"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright Â© 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Smooth vs sharp boolean operations for combining shapes\n\n// Related techniques:\n//\n// Elongation  : https://www.shadertoy.com/view/Ml3fWj\n// Rounding    : https://www.shadertoy.com/view/Mt3BDj\n// Onion       : https://www.shadertoy.com/view/MlcBDj\n// Metric      : https://www.shadertoy.com/view/ltcfDj\n// Combination : https://www.shadertoy.com/view/lt3BW2\n// Repetition  : https://www.shadertoy.com/view/3syGzz\n// Extrusion2D : https://www.shadertoy.com/view/4lyfzw\n// Revolution2D: https://www.shadertoy.com/view/4lyfzw\n//\n// More information here: https://iquilezles.org/articles/distfunctions\n\n\n/// GUI\nconst vec4 bitShL = vec4(16777216.0, 65536.0, 256.0, 1.0);\nconst vec4 bitShR = vec4(1.0/16777216.0, 1.0/65536.0, 1.0/256.0, 1.0);\nfloat unpackFloat( in vec4 val ){\n    float m = 1.0;\n    if(val.r>=256.){ val.r-=256.; m=-1.0; } \n    return dot(val, bitShL)/1000.*m;\n}\nvec4 readPixel(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\nfloat readFloat(vec2 address){ return unpackFloat(readPixel(address));}\n\n/// Graphics\nstruct hit {\n    float h;\n    vec3 col;\n};\n\nmat3x3 rotationAxisAngle( vec3 v, float a )\n{\n     float si = sin( a );\n     float co = cos( a );\n     float ic = 1.0f - co;\n\n    return mat3x3( v.x*v.x*ic + co,       v.y*v.x*ic - si*v.z,    v.z*v.x*ic + si*v.y,\n                   v.x*v.y*ic + si*v.z,   v.y*v.y*ic + co,        v.z*v.y*ic - si*v.x,\n                   v.x*v.z*ic - si*v.y,   v.y*v.z*ic + si*v.x,    v.z*v.z*ic + co );\n}\n\nvec3 rotateX (vec3 p, float theta)\n{\n    return p * rotationAxisAngle(vec3(1., 0., 0.), theta); \n}\n\nvec3 rotateY (vec3 p, float theta)\n{\n    return p * rotationAxisAngle(vec3(0., 1., 0.), theta); \n}\nvec3 rotateZ (vec3 p, float theta)\n{\n    return p * rotationAxisAngle(vec3(0., 0., 1.), theta); \n}\n\nhit opUnion( hit h1, hit h2)\n{\n    if (h1.h > h2.h) return h2;\n    return h1;\n}\n\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opIntersection( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n\t//float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\t//return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = max(k-abs(-d1-d2),0.0);\n    return max(-d1, d2) + h*h*0.25/k;\n\t//float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n\t//return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return max(d1, d2) + h*h*0.25/k;\n\t//float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n\t//return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n//-------------------------------------------------\n\nfloat sdSphere( in vec3 p, in float r )\n{\n    return length(p)-r;\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdWave(vec3 p, float height) {\n    float wH = 50.;\n    float timeX = iTime * 15. * readFloat(vec2(5.0, 0.0));\n    float w = sin(p.z * 5. + timeX) / wH\n            + sin((p.x + 10.) * 5. + timeX) / wH\n            + cos(p.x * 5. + timeX) / wH;\n            \n    return p.y - w + height;\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n//---------------------------------\n\n\nhit map(in vec3 pos)\n{\n    const float rowsSpace = 1.3;\n    const float lineSpace = 3.;\n    \n    // Wave\n    vec3 rWave = pos;\n    rWave = rotateY(rWave, iTime * readFloat(vec2(5.0, 0.0)) / 20.);\n    hit planeHit;\n    planeHit.h = sdWave(rWave, 0.02);\n    planeHit.col = vec3(0.3, 0.3, 1.);\n    \n    // Cube \n    vec3 rCube = pos + vec3(0.0,-0.5,0.);\n    rCube = vec3 (rCube.x, rCube.y, mod(rCube.z,rowsSpace));\n    rCube = rotateZ(rCube, iTime);\n    rCube = rotateX(rCube, iTime);\n    rCube = rotateY(rCube, iTime);\n    hit cubeHit;\n    cubeHit.h = sdBox( rCube, vec3(0.2));\n    cubeHit.col = vec3(1., 0., 0.);\n    \n    // Round box\n    hit roundedCubeHit;\n    vec3 rRCube = pos + vec3(1.0,-0.5,0.);\n    rRCube = vec3 (rRCube.x, rRCube.y, mod(rRCube.z,rowsSpace));\n    roundedCubeHit.h = sdRoundBox(rRCube, vec3(0.1), 0.1);\n    roundedCubeHit.col = vec3(0., 0., 1.);\n    \n    // Octa\n    hit octaHit;\n    vec3 rOcta = pos + vec3(-1.0,-0.5,0.);\n    rOcta = vec3 (rOcta.x, rOcta.y, mod(rOcta.z,rowsSpace));\n    octaHit.h = sdOctahedron(rOcta, 0.25 + sin(iTime * 4.) / 20.);\n    octaHit.col = vec3(0., 1., 0.);\n\n    return opUnion(opUnion(cubeHit, roundedCubeHit), opUnion(planeHit, octaHit));\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ).h + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ).h + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ).h + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ).h );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).h;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.20 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat shadow(vec3 lightPos, vec3 pos) {\n    vec3  lig = normalize(lightPos);\n    vec3 nor = calcNormal(pos);\n    float dif = clamp(dot(nor,lig),0.0,1.0);\n    float sha = calcSoftshadow( pos, lig, 0.001, 1.0, 16.0 );\n    return dif * sha;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n   vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y; \n   //center of screen: (0,0)\n   //dimensions: +/- 0.5\n \n \n   // CAMERA\n   // camera pos  x y z\n   vec3 ro = vec3(0.0,2.5,8.4 );\n   //   camera direction   angle: x y screen_dist\n   vec3 rd = normalize(vec3(p-vec2(0.,2.5),-10.));\n\n\n   float renderDistMin = 2.;\n   float renderDistMax = 50.;\n\n   float t = renderDistMin;\n   hit hitRay;\n   for( int i=0; i<128; i++ )\n   {\n        vec3 p = ro + t*rd;\n        hitRay = map(p);\n        float h = hitRay.h;\n        if( abs(h)<0.0001 || t> renderDistMax ) break;\n        t += h;\n   }\n   \n   // Shadows\n   vec3 col = vec3(0.0);\n   if( t < renderDistMax ) {\n   \n        vec3 pos = ro + t*rd;\n        float sha1 = shadow(vec3(cos(iTime * 2.) * 3.,3., sin(iTime * 2.) * 3.), pos);\n        float sha2 = shadow(vec3(1.), pos);\n\n        float amb = 1.;\n        vec3 ambColor = vec3(0.,0.,0.);\n        vec3 shadowColor = vec3(1.0); \n\n        col =  ambColor * amb + hitRay.col * (sha1 + sha2) / 2. ;\n   }\n\n    col = sqrt( col );\n\n    fragColor = vec4( col, 1.0 );\n    \n    // UI\n    vec4 gui = texture(iChannel0,fragCoord.xy/iResolution.xy);\n    if (gui.a > 0.0 && gui.z < 0.5) fragColor = gui;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//////////////////////////////\n//   Read Write             //\n//////////////////////////////\nconst vec4 bitShL = vec4(16777216.0, 65536.0, 256.0, 1.0);\nconst vec4 bitShR = vec4(1.0/16777216.0, 1.0/65536.0, 1.0/256.0, 1.0);\n// only positive in range 0-1\nvec4 packNormal( const in float value ){\n    vec4 res = fract( value*bitShL );\n\tres.yzw -= res.xyz/256.0;\n\treturn res;\n}\nfloat unpackNormal( const in vec4 value ){ return dot( value, bitShR );}\n\n// only positive int\nvec4 packInt(int val){\n    vec4 res = floor(float(val)*bitShR);\n    res.yzw -= res.xyz*256.0;\n    return res;\n}\nfloat unpackInt( const in vec4 value ){ return dot(value, bitShL);}\n// +-2147483 with 3 digit float precigion\nvec4 packFloat( const in float val ){\n   bool negative = sign(val)==-1.;\n   vec4 res = floor(abs(val)*1000.0* bitShR);\n   res.gba -= res.rgb*256.0;\n   if(negative) res.r+=256.;\n   return res;\n}\nfloat unpackFloat( in vec4 val ){\n    float m = 1.0;\n    if(val.r>=256.){ val.r-=256.; m=-1.0; }   \n    return dot(val, bitShL)/1000.*m;\n}\n\n\nbool isCell(in vec2 p, in vec2 a) { return floor(p) == a;}\nvoid savePixel(vec4 val, vec2 address, inout vec4 col, vec2 px){ if(isCell(px, address)) col=val;}\nvec4 readPixel(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\nvoid saveInt(int val, vec2 address, inout vec4 col, vec2 p){if(isCell(p, address)) col= packInt(val);}\nfloat readInt(vec2 address){ return unpackInt(readPixel(address));}\nvoid saveIntVec2(vec2 val, float id, inout vec4 col, vec2 p){\n    saveInt(int(val.x), vec2(id,0.0), col, p);        \n    saveInt(int(val.y), vec2(id,1.0), col, p);\n}\nvoid saveFloat(float val, vec2 address, inout vec4 col, vec2 px){ if(isCell(px, address)) col= packFloat(val);}\nfloat readFloat(vec2 address){ return unpackFloat(readPixel(address));}\n\n////// Constants ////////////////////////////////////////////////////////////////////////\nconst float PI    = 3.14159265358979323846;\nconst float SQRT2 = 1.41421356237309504880;\n\n////// 2D Ttransformations ///////////////////////////////////////////////////////////////\nvec2 translate(vec2 p, vec2 t){\treturn p - t;}\nvec2 scale(vec2 p, float s){ return p * mat2(s, 0, 0, s);}\nvec2 rotate(vec2 p, float a){return p * mat2(cos(a), -sin(a), sin(a), cos(a));}\nvec2 rotateCCW(vec2 p, float a){\treturn p * mat2(cos(a), sin(a), -sin(a), cos(a));}\n\n////// 2D Matrix Ttransformations /////////////////////////////////////////////////////////\nmat3 rotate(float r){float c = cos(r), s = sin(r); return mat3(c,-s,0,  s,c,0,  0,0,1);}\nmat3 scale(float s){ return mat3(s,0,0, 0,s,0, 0,0,1);}\nmat3 translate(vec2 p) { return mat3(1,0,p.x, 0,1,p.y, 0,0,1);}\nmat3 skew(float r) { return mat3(1,tan(r),0, 0,1,0, 0,0,1);}\nmat3 skewVert(float r) { return mat3(1,0,0, tan(r),1,0, 0,0,1);}\nmat3 inverse2x3(mat3 m){\n      float a=m[0][0], b=m[0][1], c=m[0][2], d=m[1][0], e=m[1][1], f=m[1][2], t=a*e-b*d;\n      return mat3(e/t, -b/t, (f*b-c*e)/t, -d/t, a/t, (-f*a+c*d)/t, 0, 0, 1);\n}\nvec2 transform(vec2 p, mat3 m){ return (vec3(p,1)*m).xy;}\n////// Distance field functions //////////////////////////////////////////////////////////\n\nfloat dfBox(vec2 p, vec2 size) {vec2 d = abs(p)-size; return max(d.x, d.y);}\nfloat dfBox(vec2 p, vec4 b) {vec2 d = abs(-b.xy-b.zw*.5 + p) - b.zw*.5; return max(d.x, d.y);}\nfloat dfRoundedBox(vec2 p, vec2 size, float radius){size -= vec2(radius);vec2 d = abs(p) - size; return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat dfBoxRounded(vec2 p, vec4 b, float radius){ vec2 size = b.zw*.5-vec2(radius); vec2 d = abs(-b.xy-b.zw*.5 + p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\n\nfloat dfCircle(vec2 p, float radius){\t\n    return length(p) - radius;\n}\nfloat dfLine(in vec2 p, in vec2 a, in vec2 b){\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n\n////// UI /////////////////////////////////////////////////////////////////////////////////\nfloat extract_bit(float n, float b){ return mod(floor(n/exp2(floor(b))),2.0);}\nfloat extract_decimal(float n, float index){ return mod(n/pow(10.0, index),10.0);}\nfloat drawDigit(int n, vec2 p){ p=floor(p);\n    int i = n==0?0x69996:n==1?0x62227:n==2?0xE168F:n==3?0xE161E:n==4?0x99711:n==5?0xF8E1E:\n    n==6?0x68E96:n==7?0xF1244:n==8?0x69696:n==9?0x69716:n==10?0x00700:n==11?0x00004:0xFFFFF;\n    return extract_bit(float(i), mod(p.y,5.0) * 4.0 + 3.0-p.x);\n}\nfloat drawFloat(in float val, in float fractPrecision, in vec2 p, vec2 location, int zoom){\n    p-=location; p/= float(zoom);\n    float n = floor(p.x / 5.0); //current char index \n    p.x -= n*5.; //move origin\n    if(p.y<0.||p.y>5.||n<0.||n>8.||p.x<0.||p.x>4.) return 0.; //out of digit bounds\n    if(sign(val)<0.0){if(n==0.) return drawDigit(10, p);n-=1.; val=abs(val);}  //draw minus sign \n    float intCount = floor(val)==0.0 ? 1.0 : floor(log(val)/2.302585) +1.;//calculate int part length\n    float count = intCount + fractPrecision; //totla number of digits to print \n    if(fractPrecision > 0.){val *= pow(10.,fractPrecision);}  // move decimal point \n    if(intCount <= n){if(intCount == n) return drawDigit(11, p); n-=1.0;}  //draw dot  \n    if(count <= n)  return 0.0; //no need to draw more\n    return drawDigit(int(extract_decimal(val, count-n-1.)), p); //draw digit   \n}\nfloat drawVec2(in vec2 val, in float fractPrecision, in vec2 p, vec2 location, int zoom){\n    float r =drawFloat(val.y,fractPrecision, p, location, zoom);\n    r+=drawFloat(val.x,fractPrecision, p, location+vec2(0,6*zoom), zoom);\n    return r;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\nconst vec2 activeUIAddress = vec2(0,4);\n\n\nfloat slider(in float id, in vec4 conf, in vec2 loc, in vec2 sp, inout vec4 col, inout float ui){ \n    float val = readFloat(vec2(id,0));//read saved value \n    vec4 data = readPixel(vec2(id,3));\n    float activeUIID = readInt(activeUIAddress);    \n    float slui = dfBoxRounded(floor(sp), vec4(loc,124,20), 5.0);\n    slui = max(-slui-2.0, slui );    \n    if(data.x==0.){ //set default value\n        val = conf.x; data.x=.05;\n    \tsaveFloat(val, vec2(id,0), col, sp);\n    }if(iMouse.z <= 0.){//on mouse up\n        data.g = 0.;//stop drag this point\n        savePixel(vec4(0), activeUIAddress, col, sp);//unlock other controlls\n    }else if(dfBox(iMouse.xy, vec4(loc, 120, 20))<2. && activeUIID==0.0){//on press\n        data.g = .05;//start drag this point\n        saveInt(int(id),activeUIAddress, col, sp);//lock other controlls\n    }else if(data.g>0.0 && activeUIID==id){//on mouse drag\n        float distanceFromLeftEdege = clamp(iMouse.x, loc.x, loc.x+120.0)-loc.x;\n        val = mix(conf.y, conf.z, distanceFromLeftEdege/120.0);\n        val = floor(val/conf.w) * conf.w;        \n    \tsaveFloat(val, vec2(id,0), col, sp);\n    }\n        \n    slui = min(slui, dfBoxRounded(floor(sp), vec4(loc+vec2(2,2),120.0*(val-conf.y)/(conf.z-conf.y),16), 3.0) );\n    \n    ui = min(ui, -drawFloat(val, 2.0, sp, loc+vec2(128,8), 1)); //val   \n    //ui = min(ui, -drawFloat(conf.y, 2.0, sp, loc+vec2(0,24), 1)); //from   \n    //ui = min(ui, -drawFloat(conf.z, 2.0, sp, loc+vec2(80,24), 1));  //to   \n    //ui = min(ui, -drawFloat(conf.w, 2.0, sp, loc+vec2(50,-10), 1)); //step    \n    ui = min(ui, slui);     \n    savePixel(data, vec2(id,3), col, sp);     \n    return val;    \n}\n\n\n////// Masks for drawing /////////////////////////////////////////////////////////////////\n\nfloat hardFill(float d){return step(0.0, -d);}\nfloat fill(in float d, in float softness, in float offset){\n    return clamp((offset +softness*.5 - d)/softness, 0.0, 1.0);\n}\nfloat simpleFill(float d){return clamp(-d, 0.0, 1.0);}\nfloat sharpFill(in float d){return clamp(.5-d, 0.0, 1.0);} //same as fill(d, 1.0, 0.0)\nfloat stroke(in float d, in float softness, in float offset, in float width){ \n   d = abs(d-offset);\n   return clamp((width/2.0 +softness*.5 - d)/softness, 0.0, 1.0);\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////////////\n\nvoid mainScene(inout vec4 col, in vec2 sp ){\n    //ui elements\n    float ui = 0.;\n    //                      id     default min max step    coords \n    float softness = slider(5.0, vec4(1, 0, 3, .25), vec2(125, 20), sp, col, ui);\n    //float offset = slider(6.0, vec4(1., 0., 3., .25), vec2(125, 40), sp, col, ui);\n    // float width = slider(7.0, vec4(2.5, 0, 10, .25), vec2(20, 160), sp, col, ui);\n    \n    ///////////////// output /////////////////\n\n    col = mix(col, vec4(1., 0.6, 0.1, 1.0), simpleFill(ui));\n    \n}\n\n\nvoid mainImage( out vec4 o, in vec2 p ){ \n    o = p.y <= 5.? texture(iChannel0,p.xy/iResolution.xy) : vec4(0);  //data for next frame\n    mainScene(o, p);   \n}","name":"Buffer A","description":"","type":"buffer"}]}