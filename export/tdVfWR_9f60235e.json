{"ver":"0.1","info":{"id":"tdVfWR","date":"1608800860","viewed":394,"name":"North Cave","username":"Draedrus","description":"This is my christmas shader for the year 2020","likes":15,"published":1,"flags":32,"usePreview":1,"tags":["procedural","raymarching","fire","shadow","water","fog","smoke","ice","cave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Pierre-Marie Plans - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n// https://www.shadertoy.com/view/lstSRS\nvec3 tonemapping(vec3 color)\n{\n    //Tonemapping and color grading\n    color = pow(color, vec3(1.5));\n    color = color / (1.0 + color);\n    color = pow(color, vec3(1.0 / 1.5));\n\n    \n    color = mix(color, color * color * (3.0 - 2.0 * color), vec3(1.0));\n    color = pow(color, vec3(1.3, 1.20, 1.0));    \n\n\tcolor = clamp(color * 1.01, 0.0, 1.0);\n    \n    color = pow(color, vec3(0.7 / 2.2));\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 invRes = 1./iResolution.xy;\n    vec2 uv = fragCoord*invRes;\n    vec3 m_ = vec3(100.), _m = vec3(0.);\n   \tfragColor.rgb = texture(iChannel0, uv).rgb;\n    for(int i = -1;i<2; ++i)\n    {\n    \tfor(int j = -1;j<2; ++j)\n        {\n        \tif(i==0 && j == 0)\n            \tcontinue;\n        \tvec3 v = clamp((1.-abs(float(i)*0.33))*(1.-abs(float(j)*0.33))*texture(iChannel0, uv+vec2(float(i), float(j))*invRes).rgb, 0., 1.);\n            m_ = min(m_, v); _m = max(_m, v);\n        \tfragColor.rgb += v;\n        }\n    }\n    fragColor *= fragColor;\n    fragColor *= 0.11;\n    fragColor.rgb = tonemapping(fragColor.rgb);\n    //fragColor = texture(iChannel0, uv);\n    //fragColor.rgb = vec3(normal_unpack(fragColor.zw));\n    //fragColor.rgb = fragColor.yyy/4.;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Created by Pierre-Marie Plans - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#define ENABLE_FOG\n#define ENABLE_FIRE_SMOKE\n#define ENABLE_WATER_PUDDLE\n//#define ENABLE_WATER_PUDDLE_DRIPPLING\n#define ENABLE_DETAILED_PYLONS\n//#define ENABLE_GBUFFER_OPTIMS\n\n#define CAM_TGT \tvec3(-0.2, 0., 0.)\n#define MOUSE_ANGLE 3.14*(-1.+2.*iMouse.xy/iResolution.xy)\n#define CAM_POS vec3(0., .5, -4.)\n\n#define CAM_DEPTH\t1.0\n#define CAM_NEAR \t0.01\n#define CAM_FAR\t\t50.0\n\n#define CAVE_ORIGIN vec3(0., 0., 0.)\n#define CAVE_RADIUS 10.\n#define CAVE_HEIGHT 4.0\n\n#define CAVE_ENTRY_POS vec3(0., 1., 10.)\n#define CAVE_ENTRY_OUTSIDE_POS vec3(0., 5., 50.)\n#define CAVE_ENTRY_SIZE 3.\n#define CAVE_ENTRY_LIGHT_POS vec3(0., 4.0, 40.)\n#define CAVE_ENTRY_LIGHT_I 10.\n#define AMBIENT_VALUE .05\n\n#define CAMP_FIRE_POS vec3(0., -0.6, 0.)\n#define CAMP_FIRE_ASHES_LENGTH 0.66\n#define CAMP_FIRE_HEAT_NEAR 2.5\n#define CAMP_FIRE_HEAT_FAR 5.\n#define CAMP_FIRE_WOOD_LENGTH 0.5\n#define CAMP_FIRE_LIGHT_POS (CAMP_FIRE_POS+vec3(0., 0.0, 0.))\n#define CAMP_FIRE_LIGHT_I 3.\n\n#define PERSON_POS vec3(-1.3, -.85, -1.3)\n\n#define MAIN_SCENE_MAX_STEPS 120\n#define SHADOW_STEPS 18\n#define REFLECTION_SCENE_MAX_STEPS 50\n#define REFLECTION_SHADOW_MAX_STEPS 5\n\n#define LIGHT_OUTSIDE_COLOR vec3(0.9, 1.0, 1.0)\n#define LIGHT_CAMPFIRE_COLOR vec3(1.0, 0.4, 0.0)\n\n#define WATER_LEVEL -1.3\n\n#define FOG_LEVEL -1.0\n#define FOG_FREQ 0.5\n#define FOG_ABSORBTION 0.5\n\n#define MATERIAL_VOID -1.\n#define MATERIAL_ICE 0.\n#define MATERIAL_DIRT 1.\n#define MATERIAL_WOOD 2.\n#define MATERIAL_WOOL 3.\n#define MATERIAL_ASHES 4.\n\nfloat remap01(float x, float m_, float _m)\n{\n \treturn clamp((x-m_)/(_m-m_), 0., 1.);\n}\n\nvec2 scene_min(vec2 a, vec2 b)\n{\n    return a.x<b.x?a:b;\n}\n\nvec2 scene_smooth_union( vec2 d1, vec2 d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return vec2(mix( d2.x, d1.x, h ) - k*h*(1.0-h), mix(d2.y, d1.y, h));\n}\n\nvec2 scene_smooth_substraction( vec2 d1, vec2 d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2.x+d1.x)/k, 0.0, 1.0 );\n    return vec2(mix( d2.x, -d1.x, h ) + k*h*(1.0-h), mix(d2.y, d1.y, h));\n}\n\n// NOISES\n\nvec2 rot(vec2 X, float a)\n{\n \tfloat s = sin(a); float c = cos(a);\n    return mat2(c, -s, s, c)*X;\n}\n\nfloat hash2D(vec2 uv)\n{\n \tvec2 suv = sin(uv);\n    suv = rot(suv, uv.x);\n    return fract(mix(suv.x*13.13032942, suv.y*12.01293203924, dot(uv, suv)));\n}\n\nfloat perlin_hash2D(vec2 uv)\n{\n \tvec2 lower\t= floor(uv);\n    vec2 frac \t= fract(uv);\n    vec2 f = frac*frac*(3.0-2.0*frac);\n    \n    return mix(\n        \tmix(hash2D(lower+vec2(0.0, 0.0)), hash2D(lower+vec2(1.0, 0.0)), f.x),\n        \tmix(hash2D(lower+vec2(0.0, 1.0)), hash2D(lower+vec2(1.0, 1.0)), f.x),\n        \tf.y);\n}\n\nfloat fbm_hash2D(vec2 uv)\n{\n    float total = 0.0;\n    total += 0.5000*perlin_hash2D(uv); uv*=2.001;\n    total += 0.2500*perlin_hash2D(uv); uv*=2.003;\n    total += 0.1250*perlin_hash2D(uv); uv*=2.002;\n    total += 0.0625*perlin_hash2D(uv); uv*=2.001;\n    return clamp(total, 0.0, 1.0);\n}\n\nfloat hash3D(vec3 uv)\n{\n \tvec3 suv = fract(sin(uv));\n    mat3 rdz = mat3(0.324354, 0.303147, 0.21024,\n                    0.405434, 0.723953, 0.69343,\n                    0.904379, 0.594319, 0.10439);\n    suv = rdz*suv;\n    return fract(dot(suv, uv)*1204.9324234934);\n}\n\nfloat custom_perlin_hash3D(vec3 uv)\n{\n \tvec3 lower\t= floor(uv);\n    vec3 frac \t= fract(uv);\n    vec3 f = frac*frac*(3.0-2.0*frac);\n    \n    return mix( // Z\n        \tmix( // Y\n                mix( // X\n                    hash3D(lower+vec3(0.0, 0.0, 0.0)), hash3D(lower+vec3(1.0, 0.0, 0.0)), f.x),\n                mix( // X\n                    hash3D(lower+vec3(0.0, 1.0, 0.0)), hash3D(lower+vec3(1.0, 1.0, 0.0)), f.x),\n                f.y),\n        \tmix( // Y\n                mix( // X\n                    hash3D(lower+vec3(0.0, 0.0, 1.0)), hash3D(lower+vec3(1.0, 0.0, 1.0)), f.x),\n                mix( // X\n                    hash3D(lower+vec3(0.0, 1.0, 1.0)), hash3D(lower+vec3(1.0, 1.0, 1.0)), f.x),\n                f.y),\n        \tf.z);\n}\n\nfloat fbm_hash3D(vec3 uv)\n{\n    float total = 0.0;\n    total += 0.5000*custom_perlin_hash3D(uv); uv*=2.001;\n    total += 0.2500*custom_perlin_hash3D(uv); uv*=2.003;\n    total += 0.1250*custom_perlin_hash3D(uv); uv*=2.002;\n    total += 0.0625*custom_perlin_hash3D(uv); uv*=2.001;\n    return clamp(total, 0.0, 1.0);\n}\n\n// SCENE\n\n// iq sdf methods\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n// scene build-ups\nvec2 raymarch_main_scene_floor(vec3 _p)\n{\n    return vec2(_p.y, MATERIAL_DIRT);\n}\n\nvec2 raymarch_main_scene_cave_entry(vec3 _p)\n{\n    return vec2(\n        sdCapsule(_p+vec3(cos(0.2*_p.z), 0., sin(0.2*_p.z)), CAVE_ENTRY_POS, CAVE_ENTRY_OUTSIDE_POS, CAVE_ENTRY_SIZE)\n        , MATERIAL_ICE);\n}\nvec2 raymarch_main_scene_cave_pylons(vec3 _p)\n{\n    float h = (1.-clamp(2.*(fbm_hash2D(1.8*_p.xz)-0.5), 0., 1.));\n    vec3 c = vec3(2.+4.*h);\n    vec3 q = mod((_p-vec3(2.0, 0., 0.0))+0.5*c,c)-0.5*c;\n    return vec2(\n        (sdCapsule(q, vec3(0., -CAVE_HEIGHT, 0.), vec3(0., CAVE_HEIGHT, 0.), 0.1*(abs(_p.y-CAVE_HEIGHT*.5))))\n           \n        , MATERIAL_ICE);\n}\n\nvec2 raymarch_main_scene_cave_campfire(vec3 _p)\n{\n    vec3 _o = CAMP_FIRE_POS;\n    _p.xz += .05*vec2(sin(4.*3.14*_p.x), cos(3.*3.14*_p.z));\n    return scene_min(\n        vec2(.02*fract(8.*(_p.x+_p.z))+sdCapsule(_p-_o, _o-vec3(CAMP_FIRE_WOOD_LENGTH, 0., CAMP_FIRE_WOOD_LENGTH), _o-vec3(-CAMP_FIRE_WOOD_LENGTH, 0., -CAMP_FIRE_WOOD_LENGTH), 0.1), MATERIAL_WOOD),\n        vec2(.01*pow(sin(5.*3.14*(_p.x-_p.z)), 8.)+sdCapsule(_p-_o-vec3(0., 0.1, 0.), _o-vec3(-CAMP_FIRE_WOOD_LENGTH, 0.1, CAMP_FIRE_WOOD_LENGTH), _o-vec3(CAMP_FIRE_WOOD_LENGTH, 0., -CAMP_FIRE_WOOD_LENGTH), 0.1), MATERIAL_WOOD)\n                  );\n}\n\nvec2 raymarch_scene_campfire_ashes(vec3 _p)\n{\n    vec3 _o = CAMP_FIRE_POS-vec3(0., .35, 0.);\n    return vec2(\n            sdCone(_p-_o, vec2(0.3, 0.7),.2),\n            MATERIAL_ASHES);\n}\n\nvec2 raymarch_main_scene_cave(vec3 _p)\n{\n    return vec2(\n        sdEllipsoid(_p-CAVE_ORIGIN, vec3(CAVE_RADIUS, CAVE_HEIGHT, CAVE_RADIUS))//-1.0*fbm_hash3D(_p)\n        , MATERIAL_ICE);\n}\n\nvec2 raymarch_main_scene_person(vec3 _p)\n{\n    float sinCloth = 0.005*sin(100.*_p.x)*sin(100.*_p.y)*sin(100.*_p.z);\n    vec2 body = vec2(\n        sdEllipsoid(_p-PERSON_POS, vec3(0.4, 0.8, 0.4))-.01*sin(4.*3.14*(-_p.x-_p.y-_p.z))+sinCloth\n        , MATERIAL_WOOL);\n    vec2 head = vec2(\n        sdEllipsoid(_p-PERSON_POS-vec3(0., 0.7, 0.), vec3(0.2, 0.4, 0.2))-sinCloth\n        , MATERIAL_WOOL);\n    vec2 leg = vec2(\n        sdCapsule(_p-PERSON_POS, PERSON_POS+vec3(1.9, 0.6, 1.4), PERSON_POS+vec3(0.85, 0.7, 1.5), 0.2)\n        , MATERIAL_WOOL);\n    vec3 pBed = _p+.01*vec3(cos(2.*3.14*_p.z), sin(12.*3.14*_p.z), 0.);\n    vec2 bed = vec2(sdRoundBox(pBed-PERSON_POS+vec3(1.5, 0.2, 1.65), vec3(1., .02, 1.8), 0. )-0.005*sin(200.*pBed.x)*sin(100.*pBed.y)*sin(50.*pBed.z), MATERIAL_WOOL);\n    vec3 stick_or = PERSON_POS+vec3(0.0, 0.8, -0.0);\n    vec3 stick_tgt = CAMP_FIRE_POS+vec3(0., 0., 0.);\n    vec3 stickdir = normalize(stick_tgt-stick_or);\n    vec2 stick = vec2(\n        sdCapsule(_p-stick_tgt, stick_tgt, stick_or, 0.01)\n        , MATERIAL_WOOD);\n    return scene_min(scene_min(stick, scene_smooth_union(scene_smooth_union(body, leg, 0.5), head, 0.1)), bed);\n}\n\nvec2 raymarch_reflection(vec3 _p, bool bDetail)\n{\n \treturn scene_smooth_union(\n                    scene_smooth_union(\n                        raymarch_main_scene_floor(_p-vec3(0., -1.5, 0.))\n                        , scene_smooth_substraction(\n                            raymarch_main_scene_cave_entry(_p),\n                            -raymarch_main_scene_cave(_p),\n                           1.0\n                        )\n                        , 1.\n                    ),\n                    raymarch_main_scene_cave_pylons(_p)\n                    #if defined(ENABLE_DETAILED_PYLONS)\n                    -(bDetail?.1*fbm_hash3D(4.*_p):0.)\n                    #endif\n                    ,\n        1.0)\n        #if defined(ENABLE_GBUFFER_OPTIMS)\n        -(bDetail?.5*fbm_hash3D(_p):0.)\n        #else\n        -.5*fbm_hash3D(_p)\n        #endif\n        ;\n}\n\nvec2 raymarch_main_scene(vec3 _p, bool bDetail)\n{\n    return \n        scene_min(\n            scene_min(\n                raymarch_reflection(_p, bDetail),\n                scene_min(\n                    raymarch_main_scene_cave_campfire(_p),\n                    raymarch_scene_campfire_ashes(_p)\n                )\n            ),\n            raymarch_main_scene_person(_p)\n            );\n}\n\n// rm\n\nvec2 raymarch_main(vec3 _ro, vec3 _rd, float _near, float _far)\n{\n    vec2 close;\n    close.x = 0.;\n    for(int i = 0;i < MAIN_SCENE_MAX_STEPS; ++i)\n    {\n        vec3 p = _ro+_rd*close.x;\n        // eval scene\n        vec2 t = raymarch_main_scene(p, true);\n        if(t.x<_near || close.x>_far)\n            break;\n        close.x += t.x*0.5;\n        close.y = t.y;\n    }\n    return close;\n}\n\nvec3 raymarch_main_normal(vec3 _p, float eps)\n{\n    vec3 n;\n    n.y = raymarch_main_scene(_p, true).x;\n    n.x = raymarch_main_scene(_p+vec3(eps, 0., 0.), true).x-n.y;\n    n.z = raymarch_main_scene(_p+vec3(0., 0., eps), true).x-n.y;\n    n.y = raymarch_main_scene(_p+vec3(0., eps, 0.), true).x-n.y;\n    return normalize(n);\n}\n\nvec2 raymarch_reflections(vec3 _ro, vec3 _rd, float _near, float _far)\n{\n    vec2 close;\n    close.x = 0.;\n    close.y = MATERIAL_VOID;\n    for(int i = 0;i < REFLECTION_SCENE_MAX_STEPS; ++i)\n    {\n        vec3 p = _ro+_rd*close.x;\n        // eval scene\n        vec2 t = raymarch_reflection(p, false);\n        if(t.x<_near || close.x>_far)\n            break;\n        close.x += t.x*0.5;\n        close.y = t.y;\n    }\n    return close;\n}\n\nvec3 raymarch_reflections_normal(vec3 _p, float eps)\n{\n    vec3 n;\n    n.y = raymarch_reflection(_p, false).x;\n    n.x = raymarch_reflection(_p+vec3(eps, 0., 0.), false).x-n.y;\n    n.z = raymarch_reflection(_p+vec3(0., 0., eps), false).x-n.y;\n    n.y = eps;//raymarch_reflection(_p+vec3(0., eps, 0.), false).x-n.y;\n    return normalize(n);\n}\n\n// LIGHTING\n\nfloat shadows(vec3 _ro, vec3 _rd, float _near, float _far)\n{\n    float d = _near;\n    for(int i = 0;i < SHADOW_STEPS; ++i)\n    {\n        vec3 p = _ro+_rd*d;\n        // eval scene\n        vec2 t = raymarch_main_scene(p, false);\n        if(abs(t.x)<_near || d>_far)\n            break;\n        d += t.x*0.5;\n    }\n    #if defined(ENABLE_GBUFFER_OPTIMS)\n    d-=.1*perlin_hash2D(_rd.xy*40.);\n    #endif\n    return d;\n}\n\nfloat computeLightShadow(vec3 _lightPos, vec3 _pointPos, float _scale)\n{\n    vec3 l2p = _pointPos-_lightPos;\n    float far = length(l2p);\n    //meh return shadows(_lightPos, normalize(l2p), 0.01, CAM_FAR)/far;\n    //nope return 1.-exp(-shadows(_lightPos, normalize(l2p), 0.01, far)/far);\n    //return exp(-0.4*shadows(_lightPos, normalize(l2p), 0.01, far));\n    //return exp(-(far-shadows(_lightPos, normalize(l2p), CAM_NEAR, CAM_FAR))/(far-CAM_NEAR));\n    return exp(-_scale*(far-shadows(_lightPos, normalize(l2p), 0.01, far)));\n    //meh return exp(-(far-shadows(_lightPos, normalize(l2p), 0.01, far))/_intensity);\n}\n\n// NORMAL\n\nvec2 normal_pack(vec3 n)\n{\n    return n.xy*0.5+0.5;\n}\n\nvec3 normal_unpack(vec2 enc)\n{\n    vec3 n;\n    n.xy = enc*2.0-1.0;\n    n.z = sqrt(1.0-dot(n.xy, n.xy));\n    return n;\n}\n\n// CAMERA\n\nvec3 getCamPos(vec4 _m, vec3 _r)\n{\n    vec2 a = 4.71*(-1.+2.*_m.xy/_r.xy);\n    vec2 csax = vec2(cos(a.x), sin(a.x));\n    mat2 rot = mat2(csax.x, -csax.y, csax.y, csax.x);\n    vec3 rotPos = CAM_POS;\n    rotPos.xz = rot*rotPos.xz;\n    rotPos.y = sin(.5*a.y);\n    return _m.z<=0.?CAM_POS:rotPos;\n}\n\n// the camera construction method is inspired by the one from IQ\nmat3 setCamera( in vec3 ro, in vec3 tgt, vec3 up )\n{\n\tvec3 cw = normalize(tgt-ro);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by Pierre-Marie Plans - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // compute uvs\n    vec2 invRes = 1./iResolution.xy;\n    vec2 uv = fragCoord*invRes;\n    uv.x *= iResolution.x*invRes.y;\n    uv.x -= iResolution.y*invRes.x;\n    \n    // ray\n    vec3 ro = getCamPos(iMouse, iResolution);\n    mat3 camMatrix = setCamera(ro, CAM_TGT, vec3(0., 1., 0.));\n    vec3 rd = normalize(camMatrix*normalize(vec3(-1.+2.*uv, CAM_DEPTH)));\n    \n    // build up scene\n    vec2 element = raymarch_main(ro, rd, CAM_NEAR, CAM_FAR);\n    \n    // evaluate normal\n    vec3 N = raymarch_main_normal(ro+rd*element.x, 0.001);\n\n    if(element.x>CAM_FAR)\n        N = vec3(1., 0., 0.);\n    if(element.x<CAM_NEAR)\n        N = vec3(0., 1., 0.);\n\n    vec2 np = normal_pack(N);\n    fragColor = vec4(element.x, element.y, np.x, np.y);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Created by Pierre-Marie Plans - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#define COMPAO(gbt, gba, Nt, Na) clamp(0.1/abs(gba.x-gbt.x), 0., 1.)*abs(dot(Na, Nt))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // compute uvs\n    vec2 invRes = 1./iResolution.xy;\n    vec2 uv = fragCoord*invRes;\n    vec2 tuv = uv;\n    uv.x *= iResolution.x*invRes.y;\n    uv.x -= iResolution.y*invRes.x;\n    float e = 2.;\n    fragColor.r = 1.;\n    \n    vec3 center, left, right, top, down;\n    vec3 Nc, Nl, Nr, Nt, Nd;\n    vec4 dr = texture(iChannel0, tuv);\n    if(dr.x>=CAM_FAR)\n        return;\n    vec2 off[4];\n    off[0] = vec2(-e,e*.5)*invRes;\n    off[1] = vec2(0.3*e,-e*.9)*invRes;\n    off[2] = vec2(e*.7,0.2*e)*invRes;\n    off[3] = vec2(0.1*e, e*.8)*invRes;\n    vec4 gb[4];\n    gb[0] = texture(iChannel0, tuv+off[0]);\n    gb[1] = texture(iChannel0, tuv+off[1]);\n    gb[2] = texture(iChannel0, tuv+off[2]);\n    gb[3] = texture(iChannel0, tuv+off[3]);\n    \n    vec3 ro = getCamPos(iMouse, iResolution);\n    mat3 camMatrix = setCamera(ro, CAM_TGT, vec3(0., 1., 0.));\n    #define EPS 0.001\n    // ray\n    {\n        vec3 rd = vec3(-1.+2.*uv, CAM_DEPTH);\n    \trd = camMatrix*normalize(rd);\n        center = ro+rd*dr.x;\n        Nc = normal_unpack(dr.zw);\n    }\n    {\n        vec3 rd = vec3(-1.+2.*(uv+off[0]), CAM_DEPTH);\n    \trd = camMatrix*normalize(rd);\n        left = ro+rd*gb[0].x;\n        Nl = normal_unpack(gb[0].zw);\n        fragColor.r += COMPAO(dr, gb[0], Nc, Nl);\n    }\n    {\n        vec3 rd = vec3(-1.+2.*(uv+off[1]), CAM_DEPTH);\n    \trd = camMatrix*normalize(rd);\n        down = ro+rd*gb[1].x;\n        Nr = normal_unpack(gb[1].zw);\n        fragColor.r += COMPAO(dr, gb[1], Nc, Nr);\n    }\n    {\n        vec3 rd = vec3(-1.+2.*(uv+off[2]), CAM_DEPTH);\n    \trd = camMatrix*normalize(rd);\n        right = ro+rd*gb[2].x;\n        Nt = normal_unpack(gb[2].zw);\n        fragColor.r += COMPAO(dr, gb[2], Nc, Nt);\n    }\n    {\n        vec3 rd = vec3(-1.+2.*(uv+off[3]), CAM_DEPTH);\n    \trd = camMatrix*normalize(rd);\n        top = ro+rd*gb[3].x;\n        Nd = normal_unpack(gb[3].zw);\n        fragColor.r += COMPAO(dr, gb[3], Nc, Nd);\n    }\n    fragColor.r = clamp(0.25*fragColor.r, 0., 1.);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Created by Pierre-Marie Plans - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nfloat Fresnel_Schlick(float n1, float n2, float NdotV)\n{\n    float R0 = (n1-n2)/(n1+n2);\n    R0 *= R0;\n    return R0+(1.0-R0)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV);\n}\n\nfloat beckmannDistribution(float roughness, float NdotH)\n{\n    float r1 = 1.0 / max(0.0001, 4.0 * roughness * roughness * pow(NdotH, 4.0));\n    float r2 = (NdotH * NdotH - 1.0) / (roughness * roughness * NdotH * NdotH);\n    return r1 * exp(r2);\n}\n\nfloat GGX(float a, float NoV, float NoL)\n{\n    float a2 = a*a;\n    float G_V = NoV + sqrt( (NoV - NoV * a2) * NoV + a2 );\n    float G_L = NoL + sqrt( (NoL - NoL * a2) * NoL + a2 );\n\treturn 1.0/( G_V * G_L );\n}\n\n// https://github.com/stackgl/glsl-specular-cook-torrance/blob/master/index.glsl\nfloat cookTorranceSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float fresnel) {\n\n  float VdotN = max(dot(viewDirection, surfaceNormal), 0.01);\n  float LdotN = max(dot(lightDirection, surfaceNormal), 0.01);\n\n  //Half angle vector\n  vec3 H = normalize(lightDirection + viewDirection);\n\n  //Geometric term\n  float NdotH = max(dot(surfaceNormal, H), 0.01);\n  float VdotH = max(dot(viewDirection, H), 0.0001);\n  float LdotH = max(dot(lightDirection, H), 0.0001);\n  float G1 = (2.0 * NdotH * VdotN) / VdotH;\n  float G2 = (2.0 * NdotH * LdotN) / LdotH;\n  float G = max(0.00001, min(1.0, min(G1, G2)));\n  \n  //Distribution term\n  //float D = GGX(roughness, VdotN, LdotN);//beckmannDistribution(roughness, NdotH);\n  float D = beckmannDistribution(roughness, NdotH);\n  //Fresnel term\n  float F = pow(1.0 - VdotN, fresnel);\n\n  //Multiply terms and done\n  return  G * F * D / max(3.14159265 * VdotN * LdotN, 0.01);\n}\n\nvec3 brdf(\n    float Ks,\n    float Kd,\n    float roughness,\n    float opacity,\n    vec3 specularColor,\n    vec3 diffuseColor,\n    vec3 I,\n    vec3 N,\n    vec3 L,\n\tvec3 Lcolor)\n{\n    vec3 Vn = -I;\n    float NdotV = dot(Vn, N);\n    vec3 C = vec3(0.0);\n    float Oi = opacity;\n    float spec = 0.0;\n    if(NdotV>0.0)\n    {\n        float F = Fresnel_Schlick(1.0, 1.0, NdotV);\n        spec = cookTorranceSpecular(L, Vn, N, roughness, F);\n    }\n    return (Kd*diffuseColor*max(0.0, NdotV)*max(0.0, dot(N, L))*Lcolor+Ks*specularColor*spec) * Oi;\n}\n\nvec4 render_reflections(vec2 scene, vec3 ro, vec3 rd, vec3 N, float campfire_modulation, float _shadow_campfire, float _shadow_outside)\n{\n    if(scene.x>CAM_FAR)\n        return vec4(CAVE_ENTRY_LIGHT_I*LIGHT_OUTSIDE_COLOR, 0.);\n    \n    vec3 wp = ro+rd*scene.x;\n    \n    vec3 lcampfire = normalize(wp-CAMP_FIRE_LIGHT_POS);\n    vec3 loutside = normalize(wp-CAVE_ENTRY_LIGHT_POS);\n    \n    float lcampfire_intensity = CAMP_FIRE_LIGHT_I*campfire_modulation;\n    float lcampfire_dist = length(wp-CAMP_FIRE_LIGHT_POS);\n    \n    float lcampfire_atten = exp(-(1./lcampfire_intensity)*lcampfire_dist);\n    float loutside_atten = exp(-(1./CAVE_ENTRY_LIGHT_I)*length(wp-CAVE_ENTRY_LIGHT_POS));\n    \n    float lcampfire_contrib = lcampfire_intensity*lcampfire_atten*_shadow_campfire;\n    float loutside_contrib = CAVE_ENTRY_LIGHT_I*loutside_atten*_shadow_outside;\n    \n    vec3 color = vec3(0.);\n    float roughness = 0.;\n    vec3 V = -rd;\n    float F = 0.13+0.87*pow(max(0., dot(N,-rd)), 5.);\n    vec3 color_ice = color, color_dirt = color;\n    float roughness_ice = 0., roughness_dirt = 0.;\n    {\n        const vec3 ICECOLORNARROW = vec3(0.64, 0.945, 0.949);\n        const vec3 ICECOLORDEEP = vec3(0.05, 0.05, 0.3);\n        roughness_ice = mix(0.8, 0.1, F);\n\n        vec3 brdfIceCampFire = brdf(0.6, 1., roughness_ice, 1.,\n                                    LIGHT_CAMPFIRE_COLOR, mix(ICECOLORNARROW,ICECOLORDEEP,F),\n                                    rd, N, -lcampfire, LIGHT_CAMPFIRE_COLOR);\n\n        vec3 brdfIceOutside = brdf(0.6, 1., roughness_ice, 1.,\n                                   LIGHT_OUTSIDE_COLOR, mix(ICECOLORNARROW,ICECOLORDEEP,F),\n                                   rd, N, -loutside, LIGHT_OUTSIDE_COLOR);\n\n        color_ice = brdfIceCampFire*lcampfire_contrib + brdfIceOutside*loutside_contrib;\n    }\n    {\n        const vec3 DIRTCOLOR = vec3(0.3, 0.25, 0.28);\n        const vec3 SNOWCOLOR = vec3(0.9, 0.9, 1.);\n\n        float snow_mask = 1.;\n        float melted = (CAMP_FIRE_HEAT_NEAR-clamp(lcampfire_dist, 0., CAMP_FIRE_HEAT_NEAR));\n        \n        snow_mask = max(0., snow_mask-melted);\n\n        float snow_amount = mix(fbm_hash2D(4.1*wp.xz), 1., remap01(lcampfire_dist, CAMP_FIRE_HEAT_NEAR, CAMP_FIRE_HEAT_FAR));\n\n        float snow = snow_amount*snow_mask;\n        float Kd = mix(1., mix(1.0, 0.8, F), snow);\n        float Ks = mix(.01, mix(0.6, 1.0, F), snow);\n        roughness_dirt = mix(1.-snow, mix(0.4, 0.05, F), snow);\n\n        vec3 dirt = texture(iChannel2, 1.*wp.xz).rgb;\n        N.xz = N.xz + dirt.rb;\n        N = normalize(N);\n        vec3 dirtColor = mix(DIRTCOLOR, vec3(snow_amount), snow_mask)+dirt;\n\n        vec3 brdfCampFire = brdf(Ks, Kd, roughness_dirt, 1.,\n            dirtColor, dirtColor,\n            rd, N, -lcampfire, LIGHT_CAMPFIRE_COLOR);\n\n        vec3 brdfOutside = brdf(Ks, Kd, roughness_dirt, 1.,\n            LIGHT_OUTSIDE_COLOR, dirtColor,\n            rd, N, -loutside, LIGHT_OUTSIDE_COLOR);\n\n        color_dirt = brdfCampFire*lcampfire_contrib\n            + brdfOutside*loutside_contrib;\n    }\n    color = mix(color_ice, color_dirt, scene.y);\n    roughness = mix(roughness_ice, roughness_dirt, scene.y);\n    return vec4(color, roughness);\n}\n\nvec3 render(vec2 scene, vec3 ro, vec3 rd, vec3 N, float campfire_modulation, float _shadow_campfire, float _shadow_outside)\n{\n    if(scene.x>CAM_FAR)\n        return CAVE_ENTRY_LIGHT_I*LIGHT_OUTSIDE_COLOR;\n    \n    vec3 wp = ro+rd*scene.x;\n    \n    vec3 lcampfire = normalize(wp-CAMP_FIRE_LIGHT_POS);\n    vec3 loutside = normalize(wp-CAVE_ENTRY_LIGHT_POS);\n    \n    float lcampfire_intensity = CAMP_FIRE_LIGHT_I*campfire_modulation;\n    float lcampfire_dist = length(wp-CAMP_FIRE_LIGHT_POS);\n    \n    float lcampfire_atten = exp(-(1./lcampfire_intensity)*lcampfire_dist);\n    float loutside_atten = exp(-(1./CAVE_ENTRY_LIGHT_I)*length(wp-CAVE_ENTRY_LIGHT_POS));\n    \n    float lcampfire_contrib = lcampfire_intensity*lcampfire_atten*_shadow_campfire;\n    float loutside_contrib = CAVE_ENTRY_LIGHT_I*loutside_atten*_shadow_outside;\n    \n    vec3 color = vec3(0.);\n    float roughness = 0.;\n    vec3 V = -rd;\n    float F = 0.13+0.87*pow(max(0., dot(N,-rd)), 5.);\n    float VoN = dot(V, N);\n    float LcfoN = dot(lcampfire, N);\n    float LosoN = dot(loutside, N);\n    vec3 Hcf = normalize(V+lcampfire);\n    vec3 Hos = normalize(V+loutside);\n    if(scene.y==MATERIAL_WOOD)\n    {\n        float hot = hash3D(50.*wp)*(1.-clamp(lcampfire_dist, 0., 1.));\n        float burn = fbm_hash3D(8.*wp);\n        vec3 WOODCOLOR = vec3(1.)*(burn<.5?1.:0.);\n    \n        roughness = 0.7;\n        vec3 brdfCampFire = brdf(.05, 1., roughness, 1.,\n                                 LIGHT_CAMPFIRE_COLOR, WOODCOLOR,\n                                 rd, N, -lcampfire, LIGHT_CAMPFIRE_COLOR);\n\n        vec3 brdfOutside = brdf(.05, 1., roughness, 1.,\n                                LIGHT_OUTSIDE_COLOR, WOODCOLOR,\n                                rd, N, -loutside, LIGHT_OUTSIDE_COLOR);\n    \tcolor = brdfCampFire*lcampfire_contrib\n            + brdfOutside*loutside_contrib;\n    }\n    else if(scene.y==MATERIAL_WOOL)\n    {\n    \tF = 1.-(0.02+0.92*pow(dot(N,V), 0.5));\n        vec3 WOOLCOLOR = fract(6.*3.14*(wp.x-wp.y))>0.5 || fract(6.*3.14*(wp.x+wp.y))>.5?vec3(0.365, 0.365, 0.173):vec3(0.95, 0.95, 0.86);\n        \n        roughness = 0.85;\n        vec3 brdfCampFire = brdf(.1, 1., roughness, 1.,\n                                 LIGHT_CAMPFIRE_COLOR, WOOLCOLOR,\n                                 rd, N, -lcampfire, LIGHT_CAMPFIRE_COLOR);\n\n        vec3 brdfOutside = brdf(.1, 1., roughness, 1.,\n                                LIGHT_OUTSIDE_COLOR, WOOLCOLOR,\n                                rd, N, -loutside, LIGHT_OUTSIDE_COLOR);\n                                \n    \tcolor = brdfCampFire*lcampfire_contrib//*ao\n            + brdfOutside*loutside_contrib;//*ao;\n        vec3 sss = (dot(Hcf, V)*LIGHT_CAMPFIRE_COLOR*lcampfire_contrib\n        +dot(Hos, V)*LIGHT_OUTSIDE_COLOR*loutside_contrib);\n        color += exp(-4.*dot(N,V))*sss;\n    }\n    else if(scene.y==MATERIAL_ASHES)\n    {\n        float ashesDist = clamp(1.-lcampfire_dist, 0., 1.);\n        float ash = fbm_hash3D(32.*wp)*ashesDist;\n        vec3 ashColor = vec3(log(1.+9.*ash));\n        vec3 brdfCampFire = brdf(.2, 1., roughness, ash,\n                                 LIGHT_CAMPFIRE_COLOR, ashColor,\n                                 rd, N, -lcampfire, LIGHT_CAMPFIRE_COLOR);\n\n        roughness = 1.0;\n        vec3 brdfOutside = brdf(.2, 1., roughness, ash,\n                                LIGHT_OUTSIDE_COLOR, ashColor,\n                                rd, N, -loutside, LIGHT_OUTSIDE_COLOR);\n        color = brdfCampFire*lcampfire_contrib\n                + brdfOutside*loutside_contrib;\n    }\n    else\n    {\n    \tvec3 color_ice = color, color_dirt = color;\n        float roughness_ice = 0., roughness_dirt = 0.;\n        {\n            const vec3 ICECOLORNARROW = vec3(0.64, 0.945, 0.949);\n            const vec3 ICECOLORDEEP = vec3(0.05, 0.05, 0.3);\n            roughness_ice = mix(0.8, 0.1, F);\n\n            vec3 brdfIceCampFire = brdf(0.6, 1., roughness_ice, 1.,\n                                        LIGHT_CAMPFIRE_COLOR, mix(ICECOLORNARROW,ICECOLORDEEP,F),\n                                        rd, N, -lcampfire, LIGHT_CAMPFIRE_COLOR);\n\n            vec3 brdfIceOutside = brdf(0.6, 1., roughness_ice, 1.,\n                                       LIGHT_OUTSIDE_COLOR, mix(ICECOLORNARROW,ICECOLORDEEP,F),\n                                       rd, N, -loutside, LIGHT_OUTSIDE_COLOR);\n\n            color_ice = brdfIceCampFire*lcampfire_contrib + brdfIceOutside*loutside_contrib;\n        }\n        {\n            const vec3 DIRTCOLOR = vec3(0.3, 0.25, 0.28);\n            const vec3 SNOWCOLOR = vec3(0.9, 0.9, 1.);\n\n            float snow_mask = 1.;\n    \t\tfloat melted = (CAMP_FIRE_HEAT_NEAR-clamp(lcampfire_dist, 0., CAMP_FIRE_HEAT_NEAR));\n            \n            snow_mask = max(0., snow_mask-melted);\n            \n            float snow_amount = mix(fbm_hash2D(4.1*wp.xz), 1., remap01(lcampfire_dist, CAMP_FIRE_HEAT_NEAR, CAMP_FIRE_HEAT_FAR));\n\n\t\t\tfloat snow = snow_amount*snow_mask;\n            float Kd = mix(1., mix(1.0, 0.8, F), snow);\n            float Ks = mix(.01, mix(0.6, 1.0, F), snow);\n            roughness_dirt = mix(1.-snow, mix(0.4, 0.05, F), snow);\n            \n            vec3 dirt = texture(iChannel2, 1.*wp.xz).rgb;\n            N.xz = N.xz + dirt.rb;\n            N = normalize(N);\n            vec3 dirtColor = mix(DIRTCOLOR, vec3(snow_amount), snow_mask)+dirt;\n    \n            vec3 brdfCampFire = brdf(Ks, Kd, roughness_dirt, 1.,\n                dirtColor, dirtColor,\n                rd, N, -lcampfire, LIGHT_CAMPFIRE_COLOR);\n\n            vec3 brdfOutside = brdf(Ks, Kd, roughness_dirt, 1.,\n                LIGHT_OUTSIDE_COLOR, dirtColor,\n                rd, N, -loutside, LIGHT_OUTSIDE_COLOR);\n\n            color_dirt = brdfCampFire*lcampfire_contrib\n                + brdfOutside*loutside_contrib;\n        }\n    \tcolor = mix(color_ice, color_dirt, scene.y);\n        roughness = mix(roughness_ice, roughness_dirt, scene.y);\n    }\n    return clamp(AMBIENT_VALUE*LIGHT_OUTSIDE_COLOR + color, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 invRes = 1./iResolution.xy;\n    vec2 uv = fragCoord*invRes;\n    vec4 scene = texture(iChannel0, uv);\n    \n    // compute uvs\n    vec2 cuv = fragCoord*invRes;\n    cuv.x *= iResolution.x*invRes.y;\n    cuv.x -= iResolution.y*invRes.x;\n    \n    // ray\n    vec3 ro = getCamPos(iMouse, iResolution);\n    mat3 camMatrix = setCamera(ro, CAM_TGT, vec3(0., 1., 0.));\n    vec3 rd = normalize(camMatrix*normalize(vec3(-1.+2.*cuv, 1.)));\n    \n    // shadows\n    vec3 wps = ro+rd*scene.x;\n    \n    vec3 lcampfire = normalize(wps-CAMP_FIRE_LIGHT_POS);\n    vec3 loutside = normalize(wps-CAVE_ENTRY_LIGHT_POS);\n    float lcampfire_dist = length(wps-CAMP_FIRE_LIGHT_POS);\n    float loutside_dist = length(wps-CAVE_ENTRY_LIGHT_POS);\n    \n    #define SINT(x) (.5*(1.+(sin(x*3.14*iTime))))\n    float campfire_modulation = mix(0.6, 1., clamp(SINT(4.)*SINT(1.), 0., 1.));//clamp(.5+0.5*.5*(1.+sin(3.0*iTime))*pow(.5*(1.+sin(8.*iTime)), 2.), 0., 1.);\n\n    vec3 color = vec3(0.0);\n    float shadowCampfire = 1., shadowOutside = 1.;\n    vec3 N = normal_unpack(scene.zw);\n    N.z = -N.z;\n    {\n        shadowCampfire = computeLightShadow(CAMP_FIRE_POS, wps, 2.8);\n        shadowOutside = max(AMBIENT_VALUE, computeLightShadow(CAVE_ENTRY_LIGHT_POS, wps, .05)); // 0.03\n        color = render(scene.xy, ro, rd, N, campfire_modulation, shadowCampfire, shadowOutside);\n    }\n    \n    //color = vec3(heatNSmoke.y);\n    fragColor = vec4(color, 0.);\n    //fragColor = vec4(vec3(shadowOutside), heat);\n    //if(uv.x>.6)*/\n    //fragColor = vec4(vec3(shadowCampfire), heat);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Created by Pierre-Marie Plans - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nfloat Fresnel_Schlick(float n1, float n2, float NdotV)\n{\n    float R0 = (n1-n2)/(n1+n2);\n    R0 *= R0;\n    return R0+(1.0-R0)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV);\n}\n\nfloat beckmannDistribution(float roughness, float NdotH)\n{\n    float r1 = 1.0 / max(0.0001, 4.0 * roughness * roughness * pow(NdotH, 4.0));\n    float r2 = (NdotH * NdotH - 1.0) / (roughness * roughness * NdotH * NdotH);\n    return r1 * exp(r2);\n}\n\nfloat GGX(float a, float NoV, float NoL)\n{\n    float a2 = a*a;\n    float G_V = NoV + sqrt( (NoV - NoV * a2) * NoV + a2 );\n    float G_L = NoL + sqrt( (NoL - NoL * a2) * NoL + a2 );\n\treturn 1.0/( G_V * G_L );\n}\n\n// https://github.com/stackgl/glsl-specular-cook-torrance/blob/master/index.glsl\nfloat cookTorranceSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float fresnel) {\n\n  float VdotN = max(dot(viewDirection, surfaceNormal), 0.01);\n  float LdotN = max(dot(lightDirection, surfaceNormal), 0.01);\n\n  //Half angle vector\n  vec3 H = normalize(lightDirection + viewDirection);\n\n  //Geometric term\n  float NdotH = max(dot(surfaceNormal, H), 0.01);\n  float VdotH = max(dot(viewDirection, H), 0.0001);\n  float LdotH = max(dot(lightDirection, H), 0.0001);\n  float G1 = (2.0 * NdotH * VdotN) / VdotH;\n  float G2 = (2.0 * NdotH * LdotN) / LdotH;\n  float G = max(0.00001, min(1.0, min(G1, G2)));\n  \n  //Distribution term\n  //float D = GGX(roughness, VdotN, LdotN);//beckmannDistribution(roughness, NdotH);\n  float D = beckmannDistribution(roughness, NdotH);\n  //Fresnel term\n  float F = pow(1.0 - VdotN, fresnel);\n\n  //Multiply terms and done\n  return  G * F * D / max(3.14159265 * VdotN * LdotN, 0.01);\n}\n\nvec3 brdf(\n    float Ks,\n    float Kd,\n    float roughness,\n    float opacity,\n    vec3 specularColor,\n    vec3 diffuseColor,\n    vec3 I,\n    vec3 N,\n    vec3 L,\n\tvec3 Lcolor)\n{\n    vec3 Vn = -I;\n    float NdotV = dot(Vn, N);\n    vec3 C = vec3(0.0);\n    float Oi = opacity;\n    float spec = 0.0;\n    if(NdotV>0.0)\n    {\n        float F = Fresnel_Schlick(1.0, 1.0, NdotV);\n        spec = cookTorranceSpecular(L, Vn, N, roughness, F);\n    }\n    return (Kd*diffuseColor*max(0.0, NdotV)*max(0.0, dot(N, L))*Lcolor+Ks*specularColor*spec) * Oi;\n}\n\nfloat yfiredeform(float x)\n{\n    float s = sin(x);\n    return 1.*s*s*s+2.*s*s-1.5*s+.5;\n}\n\nvec2 volumetric_camp_fire(\n    vec3 _ro, vec3 _rd, vec3 _or, vec2 _radius, float intensity, float scene)\n{\n    float time = 8.*iTime;\n    float stime = 4.*sin(4.*iTime);\n    float heat = 0.;\n    float tmin = length(CAMP_FIRE_LIGHT_POS-_ro)-_radius.x, tmax = tmin+_radius.x;\n    \n    \n    float smoke = 1.;\n    //if(-1.!=IntersectSphere(_ro, _rd, _or+vec3(0., .5*_radius.y, 0.), _radius.y, tmin, tmax))\n    {\n        float t = tmin;\n        float depth = max(0., tmax-tmin);\n        for(int i = 0;i<6; ++i)\n        {\n            vec3 p = _ro+_rd*t;\n            float height = ((p-_or).y)/_radius.y;\n            vec2 foff = vec2(0.01*yfiredeform(4.*3.14*p.y-t), yfiredeform(3.*3.14*p.x+3.14*t));\n            float n = fbm_hash2D(2.5*p.xy+vec2(0., -time));\n\n            t+= depth*0.15;\n            float hr = smoothstep(0., 1., pow(height, 1.));\n            float l = length(p.xz-_or.xz);\n\n            heat += max(0., _radius.x-l)*n*mix(1., (1.-hr)*exp(-l*foff.y), hr);\n        }\n    }\n    #ifdef ENABLE_FIRE_SMOKE\n    float t = CAM_NEAR;\n \tfor(int i = 0;i<4; ++i)\n    {\n        vec3 p = _ro+_rd*t;\n        float d = fbm_hash3D(2.5*p+vec3(0., -mod(.1*time, 6.), 0.));\n        if(abs(d-scene)<CAM_NEAR || t>CAM_FAR)\n            break;\n        float height = ((p-_or).y)/_radius.y;\n        smoke *= exp(-max(0., 1.0*d*clamp(height-2.*length(p.xz-_or.xz), 0., 1.)));\n        t += 1.;\n    }\n    #endif\n    return vec2(heat, smoke);\n}\n\nvec4 render_reflections(vec2 scene, vec3 ro, vec3 rd, vec3 N, float campfire_modulation, float _shadow_campfire, float _shadow_outside)\n{\n    if(scene.x>CAM_FAR)\n        return vec4(CAVE_ENTRY_LIGHT_I*LIGHT_OUTSIDE_COLOR, 0.);\n    \n    vec3 wp = ro+rd*scene.x;\n    \n    vec3 lcampfire = normalize(wp-CAMP_FIRE_LIGHT_POS);\n    vec3 loutside = normalize(wp-CAVE_ENTRY_LIGHT_POS);\n    \n    float lcampfire_intensity = CAMP_FIRE_LIGHT_I*campfire_modulation;\n    float lcampfire_dist = length(wp-CAMP_FIRE_LIGHT_POS);\n    \n    float lcampfire_atten = exp(-(1./lcampfire_intensity)*lcampfire_dist);\n    float loutside_atten = exp(-(1./CAVE_ENTRY_LIGHT_I)*length(wp-CAVE_ENTRY_LIGHT_POS));\n    \n    float lcampfire_contrib = lcampfire_intensity*lcampfire_atten*_shadow_campfire;\n    float loutside_contrib = CAVE_ENTRY_LIGHT_I*loutside_atten*_shadow_outside;\n    \n    vec3 color = vec3(0.);\n    float roughness = 0.;\n    vec3 V = -rd;\n    float F = 0.13+0.87*pow(max(0., dot(N,-rd)), 5.);\n    vec3 color_ice = color, color_dirt = color;\n    float roughness_ice = 0., roughness_dirt = 0.;\n    {\n        const vec3 ICECOLORNARROW = vec3(0.64, 0.945, 0.949);\n        const vec3 ICECOLORDEEP = vec3(0.05, 0.05, 0.3);\n        roughness_ice = mix(0.8, 0.1, F);\n\n        vec3 brdfIceCampFire = brdf(0.6, 1., roughness_ice, 1.,\n                                    LIGHT_CAMPFIRE_COLOR, mix(ICECOLORNARROW,ICECOLORDEEP,F),\n                                    rd, N, -lcampfire, LIGHT_CAMPFIRE_COLOR);\n\n        vec3 brdfIceOutside = brdf(0.6, 1., roughness_ice, 1.,\n                                   LIGHT_OUTSIDE_COLOR, mix(ICECOLORNARROW,ICECOLORDEEP,F),\n                                   rd, N, -loutside, LIGHT_OUTSIDE_COLOR);\n\n        color_ice = brdfIceCampFire*lcampfire_contrib + brdfIceOutside*loutside_contrib;\n    }\n    {\n        const vec3 DIRTCOLOR = vec3(0.3, 0.25, 0.28);\n        const vec3 SNOWCOLOR = vec3(0.9, 0.9, 1.);\n\n        float snow_mask = 1.;\n        float melted = (CAMP_FIRE_HEAT_NEAR-clamp(lcampfire_dist, 0., CAMP_FIRE_HEAT_NEAR));\n        \n        snow_mask = max(0., snow_mask-melted);\n\n        float snow_amount = mix(fbm_hash2D(4.1*wp.xz), 1., remap01(lcampfire_dist, CAMP_FIRE_HEAT_NEAR, CAMP_FIRE_HEAT_FAR));\n\n        float snow = snow_amount*snow_mask;\n        float Kd = mix(1., mix(1.0, 0.8, F), snow);\n        float Ks = mix(.01, mix(0.6, 1.0, F), snow);\n        roughness_dirt = mix(1.-snow, mix(0.4, 0.05, F), snow);\n\n        vec3 dirt = texture(iChannel2, 1.*wp.xz).rgb;\n        N.xz = N.xz + dirt.rb;\n        N = normalize(N);\n        vec3 dirtColor = mix(DIRTCOLOR, vec3(snow_amount), snow_mask)+dirt;\n\n        vec3 brdfCampFire = brdf(Ks, Kd, roughness_dirt, 1.,\n            dirtColor, dirtColor,\n            rd, N, -lcampfire, LIGHT_CAMPFIRE_COLOR);\n\n        vec3 brdfOutside = brdf(Ks, Kd, roughness_dirt, 1.,\n            LIGHT_OUTSIDE_COLOR, dirtColor,\n            rd, N, -loutside, LIGHT_OUTSIDE_COLOR);\n\n        color_dirt = brdfCampFire*lcampfire_contrib\n            + brdfOutside*loutside_contrib;\n    }\n    color = mix(color_ice, color_dirt, scene.y);\n    roughness = mix(roughness_ice, roughness_dirt, scene.y);\n    return vec4(color, roughness);\n}\n\nfloat phaseHG(float g, float cosTeta)\n{\n\treturn (1.-g*g)/(4.*3.14*pow(1.+g*g-2.*g*cosTeta, 1.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 invRes = 1./iResolution.xy;\n    vec2 uv = fragCoord*invRes;\n    vec4 scene = texture(iChannel0, uv);\n    \n    // compute uvs\n    vec2 cuv = fragCoord*invRes;\n    cuv.x *= iResolution.x*invRes.y;\n    cuv.x -= iResolution.y*invRes.x;\n    \n    // ray\n    vec3 ro = getCamPos(iMouse, iResolution);\n    mat3 camMatrix = setCamera(ro, CAM_TGT, vec3(0., 1., 0.));\n    vec3 rd = normalize(camMatrix*normalize(vec3(-1.+2.*cuv, 1.)));\n    \n    // shadows\n    vec3 wps = ro+rd*scene.x;\n    \n    vec3 lcampfire = normalize(wps-CAMP_FIRE_LIGHT_POS);\n    vec3 loutside = normalize(wps-CAVE_ENTRY_LIGHT_POS);\n    float lcampfire_dist = length(wps-CAMP_FIRE_LIGHT_POS);\n    float loutside_dist = length(wps-CAVE_ENTRY_LIGHT_POS);\n    \n    #define SINT(x) (.5*(1.+(sin(x*3.14*iTime))))\n    float campfire_modulation = mix(0.6, 1., clamp(SINT(4.)*SINT(1.), 0., 1.));//clamp(.5+0.5*.5*(1.+sin(3.0*iTime))*pow(.5*(1.+sin(8.*iTime)), 2.), 0., 1.);\n\n    vec3 color = vec3(0.0);\n    float shadowCampfire = 1., shadowOutside = 1.;\n    vec3 N = normal_unpack(scene.zw);\n    N.z = -N.z;\n    {\n        shadowCampfire = computeLightShadow(CAMP_FIRE_POS, wps, 2.8);\n        shadowOutside = max(AMBIENT_VALUE, computeLightShadow(CAVE_ENTRY_LIGHT_POS, wps, .05)); // 0.03\n        color = texture(iChannel2, uv).rgb;\n    }\n    \n    // AO pp\n    float aof = texture(iChannel1, uv).r;\n    color *= .2+.8*aof*aof*(3.-2.*aof);\n    \n    // water pp\n    #ifdef ENABLE_WATER_PUDDLE\n    float wh = wps.y-WATER_LEVEL;\n    if(wh<0.)\n    {\n        #ifdef ENABLE_WATER_PUDDLE_DRIPPLING\n        vec3 dir = normalize(wps-vec3(0.));\n        vec3 Nw = vec3(0., 1., 0.);\n        float w = (.5*(1.+sin(iTime)));\n        Nw.x += dir.x*.2*w;\n        Nw.z += dir.z*.2*w;\n        Nw = normalize(Nw);\n        #else\n        vec3 Nw = vec3(0., 1., 0.);\n        #endif\n        float NwoV = dot(-rd, Nw);\n        vec3 po = wps;\n        po.y = WATER_LEVEL;\n        float distPlane = dot(ro - po, Nw) / NwoV;\n\t\tvec3 wcol;\n        vec3 pw = ro+rd*abs(distPlane);\n\n        float lcampfire_intensity = CAMP_FIRE_LIGHT_I*campfire_modulation;\n        float lcampfire_atten = exp(-(1./lcampfire_intensity)*lcampfire_dist);\n        float loutside_atten = exp(-(1./CAVE_ENTRY_LIGHT_I)*loutside_dist);\n        {\n            vec3 Hc = normalize(-rd-lcampfire);\n            vec3 Ho = normalize(-rd-lcampfire);\n\n            //return vec3(shadowOutside);\n            float lcampfire_contrib = lcampfire_intensity*pow(max(0., dot(Nw, Hc)), 8.)*lcampfire_atten*shadowCampfire;\n            float loutside_contrib = CAVE_ENTRY_LIGHT_I*pow(max(0., dot(Nw, Ho)), 8.)*loutside_atten*shadowOutside;\n\n            wcol = LIGHT_CAMPFIRE_COLOR*lcampfire_contrib+LIGHT_OUTSIDE_COLOR*loutside_contrib;\n        }\n        vec3 rrd = reflect(rd, Nw);//rd;//reflect(rd, Nw);\n        //rrd.y = -rrd.y; // we can do this we have a perfect mirror\n        vec2 rm = raymarch_reflections(pw, rrd, CAM_NEAR, CAM_FAR);\n    \n        vec3 rc = vec3(0.);\n        {\n            // faked normal for the sake of compilation time\n            vec3 rwp = pw+rrd*rm.x;\n            vec3 rN;\n            {\n                //compilation time monger = raymarch_reflections_normal(rwp, 0.01);\n                // here we take a normal approx, it's way enough for our needs\n                rN = normalize(vec3(-rrd.x, -1., abs(rrd.y)));\n            }\n            {\n                float rshadowCampfire = computeLightShadow(CAMP_FIRE_LIGHT_POS, rwp, 3.);\n                float rshadowOutside = computeLightShadow(CAVE_ENTRY_LIGHT_POS, rwp, 0.07);\n                rc = render_reflections(vec2(rm.x, rm.y), pw, rrd, rN, campfire_modulation, rshadowCampfire, rshadowOutside).rgb;\n            }\n        }\n        float F = 0.04+0.96*pow(1.-NwoV, 5.);\n        wcol += (CAVE_ENTRY_LIGHT_I+lcampfire_intensity)*rc*F;\n        color = mix(color, wcol, remap01(abs(wh), 0.0, 0.1));\n    }\n    #endif\n    \n    // post-effect\n    // fog\n    vec3 pf = wps;\n    #ifdef ENABLE_FOG\n    float tr = 1.;\n    {\n        pf = ro+rd*scene.x;\n        float t = scene.x-.4;\n        float fh = wps.y-FOG_LEVEL;\n    \tfloat melted = (CAMP_FIRE_HEAT_FAR-clamp(lcampfire_dist, CAMP_FIRE_HEAT_NEAR, CAMP_FIRE_HEAT_FAR));\n        melted /= (CAMP_FIRE_HEAT_FAR-CAMP_FIRE_HEAT_NEAR);\n        vec3 sl = vec3(0.);\n        for(int i = 0;i<4;++i)\n        {\n         \tvec3 p = ro+rd*t;\n           \tfloat n = .5*max(0., 1.-fh-melted);\n            n *= fbm_hash3D(FOG_FREQ*p+vec3(0., .0, .5*iTime))+fbm_hash3D(FOG_FREQ*p-vec3(0., .0, .5*iTime));\n            if(n<0.01)\n                break;\n            float ctr = exp(-FOG_ABSORBTION*n);\n            \n            float cosTeta = dot(rd, lcampfire);\n            float hgf = mix(phaseHG(-.6, cosTeta), phaseHG(.6, cosTeta), .5);\n            cosTeta = dot(-rd, loutside);\n            float hgo = mix(phaseHG(-.6, cosTeta), phaseHG(.6, cosTeta), .5);\n            \n            float lcampfire_intensity = CAMP_FIRE_LIGHT_I*campfire_modulation;\n\n            vec3 lum = (ctr*hgf*LIGHT_CAMPFIRE_COLOR*lcampfire_intensity*shadowCampfire)\n                +(ctr*hgo*LIGHT_OUTSIDE_COLOR*CAVE_ENTRY_LIGHT_I*shadowOutside);\n            lum *= n;\n            sl += tr*(lum-ctr*lum)/n;\n            \n            tr*= ctr;\n            t+=0.1;\n        }\n\n        color *=tr;\n        color += (1.-tr)*sl;\n    }\n    #endif\n    // fire\n    float heat = 0.;\n    {\n        vec2 campfire_radius = vec2(mix(0.5, 0.7, campfire_modulation),\n                                    mix(0.8, 1.2, campfire_modulation));\n        float depth_blend = clamp(min(wps.z,pf.z)-CAMP_FIRE_LIGHT_POS.z+campfire_radius.x, 0., 1.);\n        vec2 heatNSmoke = volumetric_camp_fire(ro, rd, CAMP_FIRE_LIGHT_POS, campfire_radius, campfire_modulation, scene.x);\n        heat = depth_blend*heatNSmoke.x;\n        float alphaHeat = clamp(heat, 0., 1.);\n        heat = remap01(heat, 0., 2.0);\n        float prevHeat = texture(iChannel3, uv).a;\n        heat = mix(prevHeat, heat, 0.8);\n        color = color*(1.-alphaHeat)*heatNSmoke.y;\n        vec3 colorFlammes = mix(vec3(1., 0.08, 0.2), vec3(1.0, 1.0, 0.2), heat);\n        color += alphaHeat*colorFlammes;\n    }\n    // simulate light coming from outside: global illum ambient, really hacky but adds something nice\n    color += LIGHT_OUTSIDE_COLOR*.5*(1.-clamp(length(CAVE_ENTRY_OUTSIDE_POS-wps)/CAM_FAR,0., 1.));\n    fragColor = vec4(color, heat);\n}","name":"Buffer D","description":"","type":"buffer"}]}