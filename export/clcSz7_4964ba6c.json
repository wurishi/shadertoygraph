{"ver":"0.1","info":{"id":"clcSz7","date":"1685163349","viewed":154,"name":"hot grid","username":"Carandiru","description":"hot grid","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["grid","light","distance","gif"],"hasliked":0,"parentid":"dlXXRr","parentname":"color triangle"},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// hot grid\n//\n//\n\n#define SCALE (pow(GOLDEN_RATIO_ZERO, pi + pow(GOLDEN_RATIO, GOLDEN_RATIO_ZERO)))\n\n//                                       range[0.5 --- 1.0]\nfloat grid2( in vec2 uv, in float scale, in float thick ) // perfect, derived from https://www.shadertoy.com/view/ft2Bzw\n{\n    vec2 tile = floor(uv/scale);\n    vec2 tile_coord = fract(uv/scale) * 2.0 - 1.0;\n    \n    float max_norm = max(abs(tile_coord.x), abs(tile_coord.y)) * thick;\n    float square = smoothstep(0.5 - 2.0 * fwidth(max_norm), 0.5, max_norm);\n    \n    return(square);\n}\nfloat line(float width, float offset, float magnitude, float pixelwidth) {\n    float mid = 0.5f + offset;\n    return (smoothstep(mid - width, mid - width + pixelwidth, magnitude) - \n            smoothstep(mid + width, mid + width + pixelwidth, magnitude));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = SCALE;\n    vec2 uv = ((fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y);\n\n    vec3 color = vec3(0);\n        \n    float bn = textureLod(iChannel0, fragCoord.xy/1024.0f, 0.0f).r;\n    \n    vec3 select = vec3(cos(iTime), sin(iTime), 0.0f);\n    select.z = abs(select.x - select.y) + bn * (7.0f/255.0f);\n    \n    vec2 desc;\n    desc.x = textureLod(iChannel0, (fragCoord.xy - (10.5f + bn) * select.xy)/(8192.0f * 4.0625f), 0.0f).r * 2.0f - 1.0f;\n    desc.y = textureLod(iChannel0, (fragCoord.xy + (10.5f + bn) * select.xy)/(8192.0f * 4.0625f), 0.0f).r * 2.0f - 1.0f;\n    \n    desc = mix(mix(vec2(select.x, 0.0f), vec2(0.0f, select.y), desc.x),\n               mix(vec2(0.0f, select.x), vec2(select.y, 0.0f), desc.y), 0.5f);\n    \n    color = vec3(0.6f, 0.5f, 0.4f) * 2.0f;\n\n    float f = fract(iTime/iTimeDelta) * bn;\n    color.b *= (f*f + 0.5f) * 0.5f;\n    color.g *= (f + 0.5f) * 0.5f;\n    color.r += f;\n    \n    float d = length(uv);\n    vec3 inv_sq = vec3(select + desc.x + desc.y) / (d*d + 1.0f);\n\n    vec3 light[3] = vec3[3]( vec3(-d * select.x,   -d * select.y, inv_sq.x),\n                             vec3( 0.0f,            d * select.y, inv_sq.y),\n                             vec3( d * select.x,   -d * select.y, inv_sq.z));\n    \n    uv *= 2.0f;\n    \n    float mini = 999999.999999f;\n    for (int i = 0 ; i < light.length() ; ++i) {\n        d = distance(uv, light[i].xy);\n        color = (color * light[i].z) / (d*d + 1.0f);\n        mini = min(mini, d);\n    }\n    mini = 1.0f / (mini*mini + 1.0f);\n    float minip = pow(mini, 4.0f);\n    \n    color = color*color;\n    \n    float g = grid2(uv, scale, grid_width);\n        \n    float intensity = mini*(desc.y * 0.5f + 0.5f);\n    float pixelwidth = 1.0f / (iResolution.x);\n    float l = 0.0f;\n    \n    l = line(line_width, (uv.y + 0.5f) * 0.5f, fract(iTime/iTimeDelta), pixelwidth*(1.0f-minip)) * intensity;\n    color += color*l*minip;\n\n    color = color * g + (mix(vec3(0.9f, 0.0f, 0.0f), color*color, color) * (g))*l*mini;\n    color += vec3(g * minip) * 0.625f * minip;\n    \n    color = pow(color, vec3(1.0f/2.2f));\n    color += (1.0f - bn) * (17.0f/255.0f);\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define pi (3.141592653589793)\n#define GOLDEN_RATIO (1.61803398874989484820)\n#define GOLDEN_RATIO_ZERO (0.61803398874989484820)\n\n#define line_width (0.0125)\n#define grid_width (0.525)\n\nconst int  FFT_BASS = 2; //46 Hz / 23 Hz\n\nconst int  FFT_MID = 15; //345 Hz / 23 Hz\n\nconst int  FFT_TRE = 500; //11500 Hz / 23 Hz\n\n// these functions are available in GLSL 4.0+\nvec4 _unpackUnorm4x8(in uint a)\n{\n    vec4 c = vec4(0);\n    c.a = float((a >> 24u)&0xffu) / 255.0;\n    c.b = float((a >> 16u)&0xffu) / 255.0;\n    c.g = float((a >> 8u)&0xffu) / 255.0;\n    c.r = float((a >> 0u)&0xffu) / 255.0;\n    \n    return(c);\n}\nuint _packUnorm4x8(in vec4 a)\n{\n    uint c = 0u;\n    c |= ((uint(a.a * 255.0)&0xffu) << 24u);\n    c |= ((uint(a.b * 255.0)&0xffu) << 16u);\n    c |= ((uint(a.g * 255.0)&0xffu) << 8u);\n    c |= ((uint(a.r * 255.0)&0xffu) << 0u);\n    \n    return(c);\n}\n\n// color packing\nvec3 unpackColor(in float fetched) {\n\n\treturn( _unpackUnorm4x8(uint(fetched)).rgb );\n}\nfloat packColor(in vec3 pushed) {\n\t\n\treturn(float(_packUnorm4x8(vec4(pushed,0.0f))));\n}","name":"Common","description":"","type":"common"}]}