{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"music","id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Zhirnokleev Konstanin 2013\n// Creative Commons Attribution-ShareAlike 3.0 Unported\n//\n// Bits of code taken from Inigo Quilez, including hash(), noice(), softshadow()\n\nfloat freqs[4];\nfloat sinTime;\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat Dist(in vec3 p, out vec3 color){\n\t \n\tfloat c = cos(0.5 * sinTime * p.y);\n    float s = sin(0.5 * sinTime * p.y);\n    mat2  m = mat2(c, -s, s, c);\n   \n\tvec3  RayPos = vec3(m*p.xz, p.y).xzy;\n\tvec3  d = abs(RayPos) - vec3(2.0, 5.0, 2.0);\n  \n\tcolor = vec3(0.0, 1.0, 0.0);\t\n\tfloat distance = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) + noise(RayPos * 0.2 + vec3(iTime)) * (freqs[3] * 3.0);\n\t\n\t\n\tfloat dist = length(p - vec3(6.0,sinTime*2.0, 0.0)) - 2.0;\n\tif (distance > dist) \n\t{\n\t\tdistance = dist;\n\t\tcolor = vec3(1.0, 0.0, 0.0);\n\t}\n\t\n\t\n\treturn distance;\n\t\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<25; i++ )\n    {\n\t\tvec3 C;\n        float h = Dist(ro + rd*t, C);\n        res = min( res, k*h/t );\n        t += h;//clamp( h, 0.001, 0.6 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 trace(vec3 start, vec3 dir){\n \tvec3 Color = vec3(0.0, 0.0, 0.0);\n    vec3 RayPos = start;\n    float step = 0.6;\n\tfloat dist = 0.0;\n\tvec3 Normal;\n\tfloat coff = 1.0;\n\tfloat find;\n\t\n\tfor(int k=0; k<2; k++){\n\t\t\n\t\tfind = 0.0;\n\t\tfor(int i=0; i<35; i++)\n\t\t{\n\t\t\tvec3 color;\n\t\t\tstep = Dist(RayPos, color);\n\t\t\tdist += step;\n\t\t\tRayPos = start + dist * dir;\n\t\t\t\n\t\t\tif( abs(step) <= 0.005){\n\t\t\t\tconst float eps = 0.005;\n\t\t\t\tvec3 C;\n\t\t\t\tNormal = normalize(vec3(Dist(RayPos+vec3(eps,0,0),C)-Dist(RayPos+vec3(-eps,0,0),C),\n\t\t\t\t\t\t\t\t\t    Dist(RayPos+vec3(0,eps,0),C)-Dist(RayPos+vec3(0,-eps,0),C),\n\t\t\t\t\t\t\t\t\t    Dist(RayPos+vec3(0,0,eps),C)-Dist(RayPos+vec3(0,0,-eps),C)));\n\t\t\t\tfloat shadow = (0.3+ softshadow(RayPos + Normal * 0.03, normalize(vec3(0.4, 0.6, 0.0)), 0.01, 20.0) * 0.7);\n\t\t\t\tColor = mix(Color, color * vec3(dot(Normal, -dir)) * shadow, coff) ;\n\t\t\t\tColor = mix(Color, vec3(0.0), dist/20.0);\n\t\t\t\tfind = 1.0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\tfloat alpha = dot(dir, vec3(0.0, 1.0, 0.0));\n\t\t\tif (find == 0.0)\n\t\t\t{\n\t\t\t\tif (alpha < 0.0)\n\t\t\t\t{\n\t\t\t\t\talpha = -(5.0 +dot(vec3(0.0, 1.0, 0.0), start))/alpha; \n\t\t\t\t\tNormal = vec3(0.0, 1.0, 0.0);\n\t\t\t\t\tRayPos = start + dir * alpha;\n\t\t\t\t\t\n\t\t\t\t\tfloat shadow = (0.3+ softshadow(RayPos + Normal * 0.03, normalize(vec3(0.4, 0.6, 0.0)), 0.01, 20.0) * 0.7);\n\t\t\t\t\tColor = mix(Color, vec3(shadow) * dot(Normal, -dir), coff);\n\t\t\t\t} else {\n\t\t\t\t\tColor = mix(Color, alpha * vec3(0.3, 0.0, 0.2) * freqs[0], coff);\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t//RayPos -= step;\n\t\t//step = -0.6;\n\t\tdist = 0.0;\n\t\tstart = RayPos + Normal * 0.01;\n\t\tRayPos = start;\n\t\t//step = 0.01;\n\t\tdir = reflect(dir, Normal);\n\t\tcoff *= 0.3;\n\t}\n\t\n   \t\n\treturn Color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tsinTime = sin(iTime);\n\tfreqs[0] = texture( iChannel0, vec2( 0.01, 0.5 ) ).x;\n\tfreqs[1] = texture( iChannel0, vec2( 0.07, 0.5 ) ).x;\n\tfreqs[2] = texture( iChannel0, vec2( 0.15, 0.5 ) ).x;\n\tfreqs[3] = texture( iChannel0, vec2( 0, 0.25 ) ).x;\n\t\n    vec3 CamPos = vec3(cos(iTime), sinTime * 0.2 , sinTime) * 10.0;\n    vec3 CamDir = normalize(-CamPos);\n    vec3 CamRight = normalize(cross(CamDir, vec3(0.0, 1.0, 0.0)));\n    vec3 CamUp = normalize(cross(CamRight, CamDir));\n   \n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    vec3 Dir = normalize(vec3(uv * vec2(aspect, 1.0), 1.0 + sinTime * 0.7 )) * mat3(CamRight,CamUp,CamDir);\n   \n\n    fragColor = vec4(trace(CamPos, Dir),1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldXGRS","date":"1372912891","viewed":240,"name":"simple ray marching example","username":"jkot","description":"Simple test. Draft ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","distancefield","draft"],"hasliked":0,"parentid":"","parentname":""}}