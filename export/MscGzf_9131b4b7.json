{"ver":"0.1","info":{"id":"MscGzf","date":"1451355719","viewed":443,"name":"Square Sin Curve","username":"gaz","description":"3d\n","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["de"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI\t3.14159265359\n\nmat2 rotate(float a)\n{\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nmat3 lookat(in vec3 eye, in vec3 target)\n{\n\tvec3 w = normalize(target-eye);\n\tvec3 u = normalize(cross(w,vec3(0.0,1.0,0.0)));\n\tvec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nfloat smin(float a, float b, float k)\n{\n    return -(log(exp(k*-a)+exp(k*-b))/k);\n}\n\nfloat lengthN(in vec2 p, in float n)\n{\n\tp = pow(abs(p), vec2(n));\n\treturn pow(p.x+p.y, 1.0/n);\n}\n\nfloat func(in float x)\n{\n    // inspired https://twitter.com/Astarisk6446229/status/1319478131539890176\n    // rewrote 2020/10/24\n    float t = iTime*3.;\n    return sin(2.*x+sin(x+t)-t)*.5;\n    \n    //float t = iTime *1.5;\n    //return 0.15*sin(x*5.0+t)+0.2*sin(x*3.0+t);\n}\n\nfloat deCurve(in vec3 p)\n{\n    // transform\n    p.y -= 0.5;\n    p.xy *= rotate(0.3);\n    // de\n    p.y -= func(p.x);\n\tfloat e = 0.01;\n    float g = (func(p.x+e)-func(p.x-e))/(2.0*e);\n    \n    // https://iquilezles.org/articles/distance\n    // https://socratic.org/questions/how-do-you-simplify-cos-arctan-x\n    // cos(atan(g)) == 1.0/sqrt(g*g+1.0)\n    p.y *= cos(atan(g));\n    //p.y *= 1.0/sqrt(g*g+1.0);\n    \n    float de = 0.6*(abs(lengthN(p.yz,5.0)-0.1)-0.01);\n    return max(abs(p.x) - 2.0, de);\n}\n\nfloat deGroud(in vec3 p)\n{\n    return p.y;\n}\n\nfloat map(in vec3 p)\n{    \n    return smin(deCurve(p),deGroud(p),50.0);\n}\n\nvec3 doColor(in vec3 p)\n{\n    float e = 0.01;\n    if (deGroud(p)<e)\n    {\n    \treturn mix(0.6*texture(iChannel0, p.xz*0.2).xxx,\n    \t\tvec3(0.3,0.4,0.5), 0.5);\n    }\n    return vec3(0.6, 1.0, 0.7);\n\t/*\n    float d1 = deCurve(p);\n    float d2 = deGroud(p);\n    if (d1 < d2){\n        return vec3(0.35, 0.6, 0.4);\n    } else {   \t\n    \treturn mix(0.6*texture(iChannel0, p.xz*0.2).xxx,\n    \t\tvec3(0.3,0.4,0.5), 0.5);\n    }\n\t*/\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0, -1.0) * 0.002;\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.05;\n    for(int i = 0; i < 32; i++)\n    {\n\t\tfloat h = map(ro + rd * t);\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.1);\n        if(h < 0.001 || t > 1.5) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat calcAO(in vec3 pos, in vec3 nor)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.4*p.y*p.y);\n    vec3 ro = vec3(0.0, 1.5, 2.5);\n    vec3 rd = normalize(vec3(p, 2.0));\n    ro.xz *= rotate(iTime * 0.1);\n    rd = lookat(ro, vec3(0.0,0.5,0.0)) * rd;\n    float maxd = 20.0;\n    float t = 0.0, h;\n    for(int i = 0; i < 128; i++)\n    {\n        t += h = map(ro+rd*t);\n        if(h<0.001 || t>maxd) break;\n    }\n    if(t<maxd)\n    {\n        vec3 pos = ro+t*rd;\n        vec3 nor = calcNormal(pos);\n\t\tcol = doColor(pos);\n\t\tfloat occ = calcAO( pos, nor );\n\t\tvec3  li = normalize( vec3(2.0, 2.0, 3.0) );\n        float dif = clamp(dot(nor, li), 0.0, 1.0);\n        dif *= softshadow(pos, li);\n        col *= max(dif, 0.3);\n        col *= max(0.5+0.5*nor.y, 0.0)*occ;\n        col = pow(col, vec3(0.5));\n    }\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}