{"ver":"0.1","info":{"id":"3lKSRw","date":"1584832875","viewed":66,"name":"expanding circles with blur","username":"BakingBread","description":"expanding circles with blur","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["circles","blur"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void blur(vec2 uv, float sigma2, float blur_dist, float blur_step, out vec3 color) {\n\n    float number_samples = 0.;\n    vec4 col = vec4(0.);\n    if (sigma2 == 0.) {\n        color = texture(iChannel0, uv).rgb;\n    \treturn;\n    }\n    \n    for (float x=-blur_dist; x<= blur_dist; x+=blur_step) {\n        for (float y=-blur_dist; y<= blur_dist; y+=blur_step) {\n            vec2 offset = vec2(x, y);\n            float weight = exp(-(x*x+y*y)/sigma2);\n            col += weight * texture(iChannel0, uv+offset);\n\t\t\tnumber_samples += weight;\n        }\n    }\n    color = col.rgb/number_samples;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 position = uv - 0.5;\n    vec3 col;\n    \n    const float blur_dist = 0.007;\n    const float blur_step = 0.0007;\n    float sigma2;\n    \n    if (position.x < -0.0) sigma2 = pow(0.01, 2.); else sigma2 = 0.;\n    \n    blur(uv, sigma2, blur_dist, blur_step, col);\n    \n    fragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define RADIUS 0.5\n#define MAX_TIME 7.\n#define PI 3.1415926\n\nfloat XOR(float a, float b) {\n    return a*(1.-b) + b*(1.-a);\n}\n\n#if 0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 position = uv - 0.5;\n    position.x *= iResolution.x/iResolution.y;\n    // Time varying pixel color\n    position *= 10.;\n    float angle = 0.01 * iTime;\n    mat2 rotation_matrix = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    position = rotation_matrix * position;\n    \n    const float zwei = 2.;\n\tvec3 col = vec3(XOR(mod(floor(position.x),2.),mod(floor(position.y),2.)));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 position = uv - 0.5;\n    position.x *= iResolution.x/iResolution.y;\n    \n    float angle = 0.01*iTime*PI;\n    float cells = 25.;\n    mat2 rotation_matrix = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    position = rotation_matrix * ((position+1./(2.*cells))*cells);\n\t\n    vec3 color = vec3(0.);\n    \n  \tvec2 gv = fract(position) - 0.5;\n    vec2 id = floor(position);\n    \n    float m = 0.;\n\tfloat time = fract(iTime/MAX_TIME)*MAX_TIME;\n    \n    for (float x=-1.; x<=1.; x++) {\n        for (float y=-1.; y<=1.; y++) {\n            float distance_from_center = length(id+vec2(x,y));\n            float radius = (2.+cos(5.*time-40.*distance_from_center))*pow(5.-time, 2.)*\n               0.1/(3.+pow(-5.0*time+distance_from_center,2.));\n            \n            vec2 offset = vec2(x, y);\n            float d = pow(0.8* length(gv-offset), 2.);\n            m = XOR(m, smoothstep(radius, radius-.05, d)*1.0);\n        }\n    }\n    \n    color = vec3(m);\n    fragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}