{"ver":"0.1","info":{"id":"7sKSW1","date":"1635340575","viewed":325,"name":"voxel experiment","username":"lz","description":"Experimenting with voxel rendering and antialiasing.\ndrag and hold mouse to change grid resolution.\nPlane shadow can be disabled by setting SHADOW_QUALITY 0","likes":30,"published":1,"flags":32,"usePreview":0,"tags":["voxel","antialiasing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define texLaplace(ch, uv, eps) (0.25 * (texture(ch, uv + eps.xz) + texture(ch, uv - eps.xz) + texture(ch, uv + eps.zy) + texture(ch, uv - eps.zy)))\n\n// combining the image buffers.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    vec3 euv = vec3(1.0, 1.0, 0.);\n    euv.xy /= iResolution.xy;\n\n    // quadrant uv coordinates.\n    vec2 uvdl = uv * 2.;\n    vec2 uvul = vec2(uv.x*2., -1. + uv.y*2.);\n    vec2 uvdr = vec2(uv.x*2. - 1., uv.y*2.);\n    vec2 uvur = vec2(uv.x*2. - 1., uv.y*2. - 1.);\n\n    // uv sample\n    vec4 cdl0 = texture(iChannel0, uvdl);\n    vec4 cul0 = texture(iChannel1, uvul);\n    vec4 cdr0 = texture(iChannel2, uvdr);\n    vec4 cur0 = texture(iChannel3, uvur);\n    \n    // neighbour's sample\n    vec4 cdl = texLaplace(iChannel0, uvdl, euv);\n    vec4 cul = texLaplace(iChannel1, uvul, euv);\n    vec4 cdr = texLaplace(iChannel2, uvdr, euv);\n    vec4 cur = texLaplace(iChannel3, uvur, euv);\n    \n    // interpolation between samples based on distance from camera\n    cdl = mix(cdl0, cdl, 2.*cdl.w);\n    cul = mix(cul0, cul, 2.*cul.w);\n    cdr = mix(cdr0, cdr, 2.*cdr.w);\n    cur = mix(cur0, cur, 2.*cur.w);\n    \n    // picking color from quadrant based on uv.\n    vec4 col = (uv.x < 0.5 && uv.y < 0.5) ? cdl :\n               (uv.x < 0.5 && uv.y >= 0.5) ? cul :\n               (uv.x >= 0.5 && uv.y < 0.5) ? cdr :\n               (uv.x >= 0.5 && uv.y >= 0.5) ? cur : vec4(0., 0., 0., 1.);\n    \n    fragColor = vec4(pow(col.rgb, vec3(2.2)), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Quadrant: Lower Left\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    float oOffset = iTime*0.24;\n    vec3 o = vec3(-4. + sin(oOffset),6. + 2.*cos(oOffset),6.);\n   // o = vec3(0.);\n    vec3 d = normalize(vec3((vec2(-1., -1.) + 1.*(uv-origOffset) ), -1.));\n    \n    d = camera(o, d, vec3(0.));\n\n    vec3 col;\n    \n    // setting mouse, animation and resolution parameters passed to tracer and renderer\n    VOXTRACEPARAMS\n    \n    // setting animation interpolation values\n    SET_ANIMATION_TIMES\n    \n    // adjusted voxel grid\n    ADJUST_VOXEL_GRID\n    \n    // bounding volume pass. \n    vec3 boxres = traceVox(o, d, \n        vec3(BOXGRID), ivec2(M_ITER_LOW, 1), 2.*BOXGRID, params, pnts);\n        \n    // voxel tracing pass. Last parameter outputs traversed points.\n    vec3 res = traceVox(o, d, \n        vgrid, ivec2(int(boxres.x + step(0.35, vgrid.x)) * M_ITER, 3), vgrid.x*0.5, params, pnts);\n        \n    // rendering visited voxels.\n    vec3 cres = renderVox(pnts, vgrid, res, d, params, col); \n\n    // plane + shadow.\n    col.rgb = mix(planeRender(vec3(res.x, cres.x, 0.), o, d, vgrid, params), col.rgb, cres.r);\n\n    fragColor = vec4(col,clamp((res.z/FAR), 0., 1.));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Quadrant: Upper Left\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    float oOffset = iTime*0.24;\n    vec3 o = vec3(-4. + sin(oOffset),6. + 2.*cos(oOffset),6.);\n   // o = vec3(0.);\n    vec3 d = normalize(vec3((vec2(-1., 0.) + 1.*(uv-origOffset) ), -1.));\n    \n    d = camera(o, d, vec3(0.));\n\n    vec3 col;\n    \n     // setting mouse, animation and resolution parameters passed to tracer and renderer\n    VOXTRACEPARAMS\n    \n    // setting animation interpolation values\n    SET_ANIMATION_TIMES\n    \n    // adjusted voxel grid\n    ADJUST_VOXEL_GRID\n    \n    // bounding volume pass. \n    vec3 boxres = traceVox(o, d, \n        vec3(BOXGRID), ivec2(M_ITER_LOW, 1), 2.*BOXGRID, params, pnts);\n        \n    // voxel tracing pass. Last parameter outputs traversed points.\n    vec3 res = traceVox(o, d, \n        vgrid, ivec2(int(boxres.x + step(0.3, vgrid.x)) * M_ITER, 3), vgrid.x*0.5, params, pnts);\n        \n    // rendering visited voxels.\n    vec3 cres = renderVox(pnts, vgrid, res, d, params, col); \n\n    // plane + shadow.\n    col.rgb = mix(planeRender(vec3(res.x, cres.x, 0.), o, d, vgrid, params), col.rgb, cres.r);\n\n    fragColor = vec4(col,clamp((res.z/FAR), 0., 1.));\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Quadrant: Lower Right\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    float oOffset = iTime*0.24;\n    vec3 o = vec3(-4. + sin(oOffset),6. + 2.*cos(oOffset),6.);\n   // o = vec3(0.);\n    vec3 d = normalize(vec3((vec2(ratio - 2.*origOffset.x, -1.) + 1.*(uv-origOffset) ), -1.));\n    \n    d = camera(o, d, vec3(0.));\n\n    vec3 col;\n    \n    // setting mouse, animation and resolution parameters passed to tracer and renderer\n    VOXTRACEPARAMS\n    \n    // setting animation interpolation values\n    SET_ANIMATION_TIMES\n    \n    // adjusted voxel grid\n    ADJUST_VOXEL_GRID\n    \n    // bounding volume pass. \n    vec3 boxres = traceVox(o, d, \n        vec3(BOXGRID), ivec2(M_ITER_LOW, 1), 2.*BOXGRID, params, pnts);\n        \n    // voxel tracing pass. Last parameter outputs traversed points.\n    vec3 res = traceVox(o, d, \n        vgrid, ivec2(int(boxres.x + step(0.3, vgrid.x)) * M_ITER, 3), vgrid.x*0.5, params, pnts);\n        \n    // rendering visited voxels.\n    vec3 cres = renderVox(pnts, vgrid, res, d, params, col); \n\n    // plane + shadow.\n    col.rgb = mix(planeRender(vec3(res.x, cres.x, 0.), o, d, vgrid, params), col.rgb, cres.r);\n\n    fragColor = vec4(col, clamp((res.z/FAR), 0., 1.));\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Quadrant: Upper Right\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n\n    float oOffset = iTime*0.24;\n    vec3 o = vec3(-4. + sin(oOffset),6. + 2.*cos(oOffset),6.);\n    vec3 d = normalize(vec3((vec2(ratio - 2.*origOffset.x, 0.) + 1.*(uv-origOffset) ), -1.));\n    \n    d = camera(o, d, vec3(0.));\n\n    vec3 col;\n    \n    // setting mouse, animation and resolution parameters passed to tracer and renderer\n    VOXTRACEPARAMS\n    \n    // setting animation interpolation values\n    SET_ANIMATION_TIMES\n    \n    // adjusted voxel grid\n    ADJUST_VOXEL_GRID\n    \n    // bounding volume pass. \n    vec3 boxres = traceVox(o, d, \n        vec3(BOXGRID), ivec2(M_ITER_LOW, 1), 2.*BOXGRID, params, pnts);\n        \n    // voxel tracing pass. Last parameter outputs traversed points.\n    vec3 res = traceVox(o, d, \n        vgrid, ivec2(int(boxres.x + step(0.3, vgrid.x)) * M_ITER, 3), vgrid.x*0.5, params, pnts);\n        \n    // rendering visited voxels.\n    vec3 cres = renderVox(pnts, vgrid, res, d, params, col); \n\n    // plane + shadow.\n    col.rgb = mix(planeRender(vec3(res.x, cres.x, 0.), o, d, vgrid, params), col.rgb, cres.r);\n\n    fragColor = vec4(col, clamp((res.z/FAR), 0., 1.));\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const vec2 origOffset = vec2(.5, -.2);\n\n#define FAR 20.\n#define VERY_FAR 80.\n#define M_ITER_LOW 64\n#define M_ITER_MID 128\n#define M_ITER 512\n#define M_ITER_HIGH 1024\n#define T_EPS 0.00001\n#define N_EPS 0.00001\n\n#define PI 3.14159265359\n#define PI2 6.28318530718\n#define LSPHERFACT -10.\n\n#define FDIST 7.5\n#define ATIME 0.5 // animation time\n#define ATIME2 0.75 // animation time\n#define BOXGRID 1.0\n\n#define VOXTRACEPARAMS vec4 params; vec2 mouse = iMouse.xy / iResolution.xy; params.xy = mouse; params.z = iTime; params.w = iResolution.x; vec3 pnts[3]; \n\nconst vec2 lgrid = vec2(1.5, .75);\nconst vec2 grid = vec2(0.75, 0.125);\n\n#define SHADOW_QUALITY 2\n\n#if SHADOW_QUALITY == 0\n    #define SHADOW_GRID_FACTOR 4.\n    #define M_SHADOW_ITER 0\n    #define SHADOW_OPT_STEP 32\n#elif SHADOW_QUALITY == 1\n    #define SHADOW_GRID_FACTOR 2.\n    #define M_SHADOW_ITER M_ITER_LOW\n    #define SHADOW_OPT_STEP 32\n#elif SHADOW_QUALITY == 2\n    #define SHADOW_GRID_FACTOR 2.\n    #define SHADOW_OPT_STEP 64\n#elif SHADOW_QUALITY == 3\n    #define SHADOW_GRID_FACTOR 1.\n    #define SHADOW_OPT_STEP 64\n#elif SHADOW_QUALITY == 4\n    #define SHADOW_GRID_FACTOR .5\n    #define SHADOW_OPT_STEP 128\n#else\n    #define SHADOW_GRID_FACTOR 2.\n    #define SHADOW_OPT_STEP 64\n#endif\n\nconst vec4 l1 = LSPHERFACT*vec4(0.942809042, 0., -0.333333333, .8);\nconst vec4 l2 = LSPHERFACT*vec4(-0.471404521, 0.816496581, -0.333333333, .8);\nconst vec4 l3 = LSPHERFACT*vec4(-0.471404521, -0.816496581, -0.333333333, .8);\nconst vec4 l4 = LSPHERFACT*vec4(0., 0., 1., .8);\n\nconst vec4 l5 = vec4(0., 0., 0., 1.);\n\nfloat hash(in vec3 p)\n{\n    return fract(sin(dot(p,\n    vec3(12.6547, 765.3648, 78.653)))*43749.535);\n}\n\nfloat hash_2(in vec3 p)\n{\n    return fract(sin(dot(p,\n    vec3(122.6547, 7635.3648, 8.653)))*41149.535);\n}\n\nfloat hash_3(in vec3 p)\n{\n    return fract(sin(dot(p,\n    vec3(531.6547, 1635.3238, 18.653)))*19149.535);\n}\n\n#define ROT2D(p2d, ang) (cos(ang) * p2d.xy + sin(ang) * vec2(p2d.y, -p2d.x))\n\nvec3 hsv2rgb( const in vec3 c )\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n// animation time interpolation values (all in [0,1] range). \n// significantly reduced compilation times (in contrary to in-place evaluation).\nfloat animTimes[16] = float[](0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.);\n\n#define ANIM_TIME_T(start, stop, t) (smoothstep(start, start + ATIME, t) - smoothstep(stop, stop + ATIME, t))\n#define ANIM_TIME_T2(start, stop, t) (smoothstep(start, start + ATIME2, t) - smoothstep(stop, stop + ATIME2, t))\n\n#define SET_ANIMATION_TIMES \\\n    float time60 = mod(iTime, 60.);   \\\n    float time17 = mod(iTime, 17.);   \\\n    float time20 = mod(iTime, 20.);   \\\n    float time180 = mod(iTime, 180.); \\\n    animTimes[0] = ANIM_TIME_T(4., 50.0, time60); \\\n    animTimes[1] = ANIM_TIME_T(10., 25.0, time60); \\\n    animTimes[2] = ANIM_TIME_T(1., 59., time60); \\\n    animTimes[3] = ANIM_TIME_T(1.5, 50., time60); \\\n    animTimes[4] = ANIM_TIME_T(4.5, 59.5, time60); \\\n    animTimes[5] = ANIM_TIME_T(15., 20., time60); \\\n    animTimes[6] = ANIM_TIME_T(14., 31., mod(iTime, 43.)); \\\n    animTimes[7] = ANIM_TIME_T(5., 10., time17); \\\n    animTimes[8] = ANIM_TIME_T(3., 7., time20); \\\n    animTimes[9] = ANIM_TIME_T(13., 17., time20); \\\n    animTimes[10] = ANIM_TIME_T(0., 10., time20); \\\n    animTimes[11] = ANIM_TIME_T(5., 15., time20); \\\n    animTimes[12] = ANIM_TIME_T2(43., 72., time180); \\\n    animTimes[13] = ANIM_TIME_T2(72., 120., time180); \\\n    animTimes[14] = ANIM_TIME_T2(120., 150., time180); \\\n    animTimes[15] = ANIM_TIME_T2(39., 43., time180);\n    \n#define ADJUST_VOXEL_GRID \\\nvec2 rgrid = mix(lgrid, grid, smoothstep(50., 800., iResolution.x)); \\\nvec3 manGrid = vec3(mix(rgrid.x, rgrid.y, clamp(params.x, 0., 1.))); \\\nfloat autoGrid = mix(rgrid.x, rgrid.y, 0.67); \\\nautoGrid = mix(autoGrid, mix(rgrid.x, rgrid.y, 0.98), animTimes[15]); \\\nautoGrid = mix(autoGrid, mix(rgrid.x, rgrid.y, 0.5), animTimes[12]); \\\nautoGrid = mix(autoGrid, mix(rgrid.x, rgrid.y, 0.25), animTimes[13]); \\\nautoGrid = mix(autoGrid, mix(rgrid.x, rgrid.y, 0.85), animTimes[14]); \\\nvec3 vgrid = mix(vec3(autoGrid), manGrid, step(0.01, iMouse.z)); \n\nvec2 geom(in vec3 p, in vec4 params)\n{\n   float rotAngle = 0.6 * p.y * (animTimes[0] + animTimes[1]);\n   p.xz = ROT2D(p.xz, rotAngle);\n   p.y -= abs(0.8*p.x) * animTimes[2];\n   p.z += p.z*animTimes[3];\n   float boxf = sdRoundBox(p, vec3(3.0), .1);\n   float circF = length(p) - 4.5;\n   return vec2(mix(circF, boxf, 2.0 * (animTimes[4] - animTimes[5])), 1.);\n}\n\nint lineGeomTest(in vec3 st, in vec3 end, in vec3 vgrid, in int n_iter, in float threshold, in vec4 params)\n{\n  int hit = 0;\n  vec3 dir = normalize(end - st);\n  float fstep = length(end - st) / float(n_iter);\n  vec3 p = st;\n  for (int i_iter = 1; i_iter < n_iter && hit == 0; i_iter++)\n  {\n    p += fstep * dir;\n    //vec3 ip = floor((p) / vgrid) * vgrid + 0.5*vgrid;\n    hit = int(float(geom(p, params).x < threshold) + T_EPS);\n  }\n  \n  return hit;\n}\n\nvec3 traceVox(in vec3 o, in vec3 d, in vec3 vgrid, in ivec2 iter,\n              in float threshold, in vec4 params, out vec3 pnts[3])\n{\n  vec3 sgnd = sign(d);\n  vec3 inc = sgnd * vgrid;\n  vec3 io = vgrid * (floor(o / vgrid) - vec3(min(sgnd.x, 0.), min(sgnd.y, 0.), min(sgnd.z, 0.)));\n  vec3 next = io + inc;\n  \n  vec3 t = (next - o) / d;\n  \n  vec3 sp;\n  \n  sp.x = float(t.x < t.y && t.x < t.z);\n  sp.y = float(t.y <= t.x && t.y < t.z);\n  sp.z = float(t.z <= t.y && t.z <= t.x);\n  \n  vec3 p = o + dot(t, sp) * d;\n  vec3 tDelta = abs(vgrid / d);\n  \n  t += sp * tDelta;\n  \n  float totalT = min(t.x, min(t.y, t.z));\n  float prevT = 0.0;\n\n  vec3 res = vec3(0.);\n  \n  int hit = 0;\n  int i_st = 0;\n  // trace\n  for (i_st = 0; i_st < iter.x; i_st++)\n  {\n     vec3 ip = floor((p+T_EPS*d) / vgrid) * vgrid + 0.5*vgrid;\n     vec2 r = geom(ip, params);\n     \n     if (r.x <= threshold)\n     {\n         pnts[hit] = p;\n         hit++;\n     }\n     \n     if (hit == iter.y)\n     {\n         break;\n     }\n     \n     \n     if (totalT > FAR)\n     {\n       break;\n     }\n    \n     sp.x = float(t.x < t.y && t.x < t.z);\n     sp.y = float(t.y <= t.x && t.y < t.z);\n     sp.z = float(t.z <= t.y && t.z <= t.x);\n     \n     prevT = totalT;\n     totalT = min(t.x, min(t.y, t.z));\n\n     p = o + totalT * d;\n     \n     t += sp * tDelta;\n  }\n  \n  res = vec3(float(hit), prevT, totalT);\n  \n  return res;\n}\n\nfloat voxTrilinear(in vec3 p, in vec3 d, in vec3 vgrid)\n{\n  vec3 ip000 = floor((p+T_EPS*d) / vgrid) * vgrid + 0.5*vgrid;\n  vec2 e = vec2(vgrid.x, 0.);\n  \n  vec3 ip100 = ip000 + e.xyy;\n  vec3 ip010 = ip000 + e.yxy;\n  vec3 ip110 = ip000 + e.xxy;\n  \n  vec3 ip001 = ip000 + e.yyx;\n  vec3 ip101 = ip000 + e.xyx;\n  vec3 ip011 = ip000 + e.yxx;\n  vec3 ip111 = ip000 + e.xxx;\n  \n  vec3 fp = fract((p - ip000) / vgrid);\n  vec3 ufp = 2.*fp*fp*fp - 3.*fp*fp;\n  \n  return mix(mix(mix(hash(ip000),hash(ip100),ufp.x), \n                 mix(hash(ip010),hash(ip110),ufp.x),ufp.y), \n             mix(mix(hash(ip001),hash(ip101),ufp.x),\n                 mix(hash(ip011),hash(ip111),ufp.x),ufp.y),ufp.z);\n}\n\nvec3 renderVox(in vec3 pnts[3], in vec3 vgrid, in vec3 traceRes, in vec3 d, in vec4 params, out vec3 col)\n{\n  float accAlpha = 0.0;\n  float feps = 0.5*vgrid.x;\n  vec3  colGrid = vgrid * (10. + 30. * animTimes[6]);\n  \n  for (int i_pnt = 0; i_pnt < int(traceRes.x + T_EPS) && accAlpha < 1.0; i_pnt++)\n  {\n     vec3 p = pnts[i_pnt];\n     vec3 ip = floor((p+T_EPS*d) / vgrid) * vgrid + 0.5*vgrid;\n     vec3 ipc = floor((p+T_EPS*d) / (colGrid)) * colGrid + 0.5 * colGrid;\n     vec3 n = (p - ip);\n     vec3 an = abs(n);\n     float thr = sqrt(2.)*vgrid.x - feps;\n\n     float twoVal = float(abs(an.x + an.y) > thr || abs(an.y + an.z) > thr || abs(an.z + an.x) > thr);\n     \n     if (twoVal > 0.5)\n     {\n       col = col * accAlpha  + (1.-accAlpha) * hash_2(ip);\n       accAlpha = 1.0;\n       float spHash = clamp(hash_3(ip), 0.1, 0.8);\n       vec3 vsp = normalize(vec3(1., -1., -1.));\n       vec3 spec = vec3(0.91, 0.6, 0.32)*pow(max(0.0, dot(reflect(vsp, n),vsp)), 1024.*spHash)/(8.*spHash);\n\n       col += (spec);\n     }\n     else\n     {\n         float alpha = clamp(hash(ip) + animTimes[7], 0.25, 1.0);\n\n         accAlpha = alpha + (1. - alpha) * accAlpha;\n\n         float hue = mix(hash(ipc), voxTrilinear(p, d, vgrid*20.), 0.5*animTimes[8] + 0.5*animTimes[9]);\n         col = alpha * hsv2rgb(vec3(hash(ipc), hue, 0.5 + 0.5 * animTimes[10])) + (1. - alpha) * col;\n     }\n\n     n.x *= step(an.y, an.x) * step(an.z, an.x);\n     n.y *= step(an.x, an.y) * step(an.z, an.y);\n     n.z *= step(an.x, an.z) * step(an.y, an.z);\n     n = normalize(n);\n\n     vec3 l1dir = l1.xzy - p;\n     vec3 l2dir = l2.xzy - p;\n     vec3 l3dir = l3.xzy - p;\n     vec3 l4dir = l4.xzy - p;\n     vec3 l5dir = l5.xyz - p;\n     \n     float ll1 = distance(p, l1.xzy);\n     float ll2 = distance(p, l2.xzy);\n     float ll3 = distance(p, l3.xzy);\n     float ll4 = distance(p, l4.xzy);\n     float ll5 = distance(p, l5.xyz);\n     \n     vec3 dummy[3];\n     float trsh = vgrid.x * 0.5;\n     int l1h = lineGeomTest(l1.xzy, p, vgrid, 8, 2.*vgrid.x, params);\n     int l2h = lineGeomTest(l1.xzy, p, vgrid, 8, 2.*vgrid.x, params);\n     int l3h = lineGeomTest(l1.xzy, p, vgrid, 8, 2.*vgrid.x, params);\n     int l4h = lineGeomTest(l1.xzy, p, vgrid, 8, 2.*vgrid.x, params);\n\n\n     col = col * (max(dot(n, l1.w * l1dir / (ll1*ll1)), 0.) + \n                  max(dot(n, l2.w * l2dir / (ll2*ll2)), 0.) + \n                  max(dot(n, l3.w * l3dir / (ll3*ll3)), 0.) +\n                  max(dot(n, l4.w * l4dir / (ll4*ll4)), 0.) +\n                  max(dot(n, l5.w * (-l5dir) / (ll5*ll5)), 0.));\n     \n     // shadows\n     float shc = 1. - 0.125 * float(l1h + l2h + l3h + l4h);\n     col = mix(shc*col, col, 0.5 + 0.5*animTimes[11]);\n  }\n  \n  vec3 res = vec3(accAlpha, 0., 0.);\n  return res;\n}\n\nvec3 camera(in vec3 o, in vec3 d, in vec3 tar) {\n  vec3 dir = normalize(o - tar);\n  vec3 right = cross(vec3(0.,1.,0.),dir);\n  vec3 up = cross(dir,right);\n\n  mat3 view = mat3(right,up,dir);\n  return view*d;\n}\n\nfloat tiling(in vec2 uv, in vec2 b, in vec2 e)\n{\n  vec2 vf = smoothstep(b, b + e, uv) - smoothstep(vec2(1.) - e, vec2(1.), uv);\n  \n  return 1. - vf.x * vf.y;\n}\n\nvec3 planeRender(in vec3 traceRes, in vec3 o, in vec3 d, in vec3 vgrid, in vec4 params)\n{\n    vec4 plane = vec4(0., 1., 0., -3.);\n\n    vec3 col;\n\n    if (traceRes.y < (1. - T_EPS) && abs(dot(plane.xyz, d)) > T_EPS)\n    {\n      float t = dot(vec3(0., plane.w, 0.) - o, plane.xyz) / dot(plane.xyz, d);\n\n      if (t > T_EPS && t < VERY_FAR)\n      {\n          vec3 pp = o + t * d;\n          \n          vec3 shGrid = vgrid * SHADOW_GRID_FACTOR;\n          // Light - point segment with geometry intersection pseudo test.\n          // Shadow pass.\n          int l1h = lineGeomTest(l1.xzy, pp, shGrid, SHADOW_OPT_STEP, shGrid.x, params);\n          int l2h = lineGeomTest(l2.xzy, pp, shGrid, SHADOW_OPT_STEP, shGrid.x, params);\n          int l3h = lineGeomTest(l3.xzy, pp, shGrid, SHADOW_OPT_STEP, shGrid.x, params);\n          int l4h = lineGeomTest(l4.xzy, pp, shGrid, SHADOW_OPT_STEP, shGrid.x, params);\n          \n          float shfct = 1. - 0.25*float(l1h + l2h + l3h + l4h);\n          col.rgb = 0.5 * mix(vec3(0.12, 0.33, 0.94), vec3(0.81, 0.75, 0.52), (FAR/t));\n          col.rgb *= (1. - smoothstep(30., 60., t));\n          \n          // plane\n          col.rgb = mix(0.75*col.rgb, col.rgb, tiling(fract(pp.xz / vgrid.xy), vec2(0.1), vec2(0.01)));\n          col.rgb *= shfct;\n      }\n    }\n    \n    return col;\n}\n\n","name":"Common","description":"","type":"common"}]}