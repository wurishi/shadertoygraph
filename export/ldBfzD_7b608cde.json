{"ver":"0.1","info":{"id":"ldBfzD","date":"1499738288","viewed":129,"name":"iDonut","username":"Sheado","description":"My first raymarched thing!.. yum. \nRaymarched donut and ~20 cylindrical sprinkles. Distance field for the frosting. And some Phong lighting.\n\nMouse click to seed the randomizer.\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","phong","sdf","lighting","random","donut"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float EPSILON = 0.01;\nconst int maxSteps = 64;\n\nvec3 raymarch(vec2 uv);\nfloat sdTorus( vec3 p );\n\nconst float ambientIntensity = 0.1;\nconst vec3 floorColor = vec3(50./255.,205./255.,50./255.);\nconst vec3 ambientLightColorDonut = vec3(228./255.,163./255.,94./255.);\nconst vec3 diffuseLightColorDonut = ambientLightColorDonut;\nconst vec3 specularLightColorDonut = vec3(.1,.1,.1);\nconst vec3 ambientLightColorFrosting = vec3(255./255.,105./255.,193./255.);\nconst vec3 diffuseLightColorFrosting = ambientLightColorFrosting;\nconst vec3 specularLightColorFrosting = vec3(.4,.4,.4);\nvec3 lightPosition \t= vec3( 0., 20., 0. );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x/iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n        \n    vec3 color = raymarch( uv );\n\tfragColor = vec4(color,1.0);\n}\n\n/**\n * https://learnopengl.com/#!Getting-started/Transformations\n */\nmat4 rotate(float theta, vec3 a /*axis*/) {\n    float c = cos(theta);\n    float ic = 1. - c;\n    float s = sin(theta);\n    float is = 1. - s;\n\n    return mat4(\n        vec4(c+a.x*a.x*ic, \t\ta.x*a.y*ic-a.z*s, \ta.x*a.z*ic+a.y*s, \t0),\n        vec4(a.y*a.x*ic+a.z*s, \tc+a.y*a.y*ic, \t\ta.y*a.z*ic-a.x*s, \t0),\n        vec4(a.z*a.x*ic-a.y*s, \ta.z*a.y*ic+a.x*s, \tc+a.z*a.z*ic, \t\t0),\n        vec4(0, \t\t\t\t0, \t\t\t\t\t0,\t\t\t\t\t1)\n    );\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n \tp.y += 5.;\t// translate\n    \n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdTorus( vec3 p, vec2 t )\n{   \n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  float d = length(q)-t.y;\n  // d += sin(1.5*p.x)*sin(2.*p.y)*sin(2.*p.z);\t// displacement effect for a weirdo donut\n  return d;\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p, vec2 dimensions) {\n    return normalize(vec3(\n        sdTorus(vec3(p.x + EPSILON, p.y, p.z), dimensions) - sdTorus(vec3(p.x - EPSILON, p.y, p.z), dimensions),\n        sdTorus(vec3(p.x, p.y + EPSILON, p.z), dimensions) - sdTorus(vec3(p.x, p.y - EPSILON, p.z), dimensions),\n        sdTorus(vec3(p.x, p.y, p.z  + EPSILON), dimensions) - sdTorus(vec3(p.x, p.y, p.z - EPSILON), dimensions)\n    ));\n}\n\n/**\n * the camera\n */ \nmat3 getView(vec3 position, vec3 target)\n{\n    vec3 cameraDirection = normalize(target-position);\t// technically the reverse direction\n    vec3 up = vec3(0, 1, 0);\t\t\t\t\t\t\t// world up\n    vec3 cameraRight = normalize(cross(up, cameraDirection));\t\n    vec3 cameraUp = cross(cameraDirection, cameraRight);\n                                 \n\tmat3 view = mat3(cameraRight, cameraUp, cameraDirection);\n \treturn view;\n}\n\n/**\n * https://learnopengl.com\n */\nvec3 light(vec3 position, vec3 viewPosition, vec3 normal, vec3 ambientLightColor, vec3 diffuseLightColor, vec3 specularLightColor )\n{\n    // ambient\n    vec3 ambient = ambientLightColor * ambientIntensity;\n    \n    // diffuse\n    vec3 lightDirection = normalize(lightPosition-position);\n    float diffuseIntensity = max(dot(normal, lightDirection),0.0);\n    vec3 diffuse = diffuseIntensity * diffuseLightColor;\n    \n    // specular\n    float specularStrength = 1.5;\n    vec3 viewDirection = normalize(viewPosition-position);\n    vec3 reflectionVector = reflect(-lightDirection, normal);\n    float specularIntensity = pow(max(dot(viewDirection,reflectionVector),0.0),32.);\n    vec3 specular = specularStrength * specularIntensity * specularLightColor;\n    return ambient + diffuse + specular;\n}\n\n// light and donut shadow\nvec3 floorLight(vec3 p)\n{\n    vec3 lightDirection = normalize(lightPosition-p);\n\t// floor diffuse - hacking the normal for now\n    float diffuseIntensity = max(dot(vec3(0.,1.,0.), lightDirection),0.0);\n    vec3 diffuse = diffuseIntensity * floorColor;\n    \n    float l = 0.;\n    const vec2 dimensions = vec2(2.,1.2);\n    vec3 v;\n    float dt;\n    for( int i = 0; i < maxSteps; ++i )\n    {\n        v = p + lightDirection*l;\n        dt = sdTorus(v,dimensions);\n        if( dt < EPSILON )\n        \treturn floorColor-ambientIntensity;\t// return shadow\n        l += dt;\n    }\n    \n\treturn vec3(ambientIntensity) + diffuse;\n}\n\nfloat random(vec2 uv)\n{\n    float x = iMouse.x;\n    float y = iMouse.y;\n    if( x == 0. )\n        x = 12.32453454;\n    if( y == 0. )\n        y = 4.98743657943;\n    return fract(sin(dot(uv,vec2(x,y))) * iResolution.x*iResolution.y);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u;// = f*f*(3.0-2.0*f);\n     u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\nvec2 randomDirection(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n\nvec3 raymarch(vec2 uv)\n{\n    float aspect = iResolution.x/iResolution.y;\n    uv *= 2.;\n    uv -= 1.;\n    uv.x *= aspect;\n    \n    vec3 rayOrigin = vec3(1.,20.,6.);\n    // light movement\n    // lightPosition = vec3(3.+3.*cos(iTime),10.+3.*sin(iTime),2.+6.*cos(iTime));\n    // camera movement\n    rayOrigin = vec3(3.*sin(iTime),10.,10.);\n    vec3 cameraTarget = vec3(0.,.0,.0);\n    mat3 view = getView(rayOrigin,cameraTarget);\n    vec3 modelPosition = normalize(vec3(uv,2.));\n    vec3 rayDirection = view * modelPosition;\n\n    \n    float t = 0.;\n    float threshold = EPSILON;\n    const vec2 dimensions = vec2(2.,1.2);\n    const vec3 boxDimensions = vec3(20.,1.,20.5);\n    vec3 p;\n    for( int i = 0; i < maxSteps; ++i )\n    {\n        p = rayOrigin + rayDirection*t;\n        float db = sdBox(p,boxDimensions);\n        \n        // movement\n        p = (inverse(rotate(sin(iTime)*.5, vec3(1.,.25,0.))) * vec4(p,1.)).xyz;\n\n        \n        float dt = sdTorus(p, dimensions );\n        float d;\n        \n        // draw the floor if in view\n        if( db < dt )\n        {            \n            d = db;\n            if( d < threshold )\n            {\n\t\t\t\treturn floorLight(p);                \n            }\n        }\n        // else draw sprinkles and donut\n        else\n        {\n            // start with the sprinkles first\n            bool drawSprinkle = false;\n            float minDs = 10000000.;\n            float ii, r, r2, r3;\n            vec2 vii;\n            mat4 m;\n            vec3 rotationAxis = vec3(0.,1.,0.);\n            for( float i = 0.; i < 20.; ++i )\n            {\n                ii = i*i;\n                vii = vec2(i,i);\n                r3 = random(vii);\t\t\t\t\t\t\t// TODO - needs optimization\n                m = rotate(r3, rotationAxis);\n                \n                vec2 rd = randomDirection(vii);\t\t\t\t// TODO - needs optimization\n                r = rd.x;\n                r2 = rd.y;\n                if( r < 0. )\n                    r *= -1.;\n                if( r2 > .5 )\n                    r2 *= -1.;\n                if( r3 > .5 )\n                    r3 *= -1.;\n\n                // scatter the sprinkles by randomly rotating away from center\n                p = mat3(m) * p;\t\t\t\t\t\t\t// TODO - needs optimization\n                vec3 pp = p - .8 - .6*r;\n\t\t     \tfloat ds = sdCapsule( pp, vec3(.5+.5*r2,.1,.3+.3*r3), vec3(.1+.5*r3,.1+.5*r2,.1), .08+.08*r3*r2 );\n                if( ds < threshold )\n                {\n                    drawSprinkle = true;\n                    return vec3(.5 + random(vec2(i,r)), .5 + random(vec2(1.,r2)), .5 + random(vec2(i,r3)));\n                }\n                if( ds < minDs )\n                    minDs = ds;\n            }\n  \n            // if no sprinkle pixel drawn, draw donut pixel\n            if( !drawSprinkle )\n            {\n                // draw dough or frosting\n                if( dt < threshold )\n                {\n                    vec3 p2 = p + rayDirection*t*.09;\n                    float dt = sdTorus(p2,dimensions);\n\n                    // frosting noise to make imperfect splatter of frosting\n                    float n = noise(p2.xz);\n                    n = length(p2.xz)-5.5*n;\n                    dt += n;\n\n                    if( dt > EPSILON )\n                        return light(p, rayOrigin, estimateNormal(p,dimensions), ambientLightColorDonut, diffuseLightColorDonut, specularLightColorDonut );\n                    else\n                        return light(p, rayOrigin, estimateNormal(p,dimensions), ambientLightColorFrosting, diffuseLightColorFrosting, specularLightColorFrosting);\n                }\n                d = dt;\n\t\t\t\tif( dt < minDs )\n\t\t\t\t\tminDs = dt;\n            }\n            d = minDs;\n        }\n        t += d;\n    }\n    // else the bg color\n    return floorColor*.6;\n}","name":"Image","description":"","type":"image"}]}