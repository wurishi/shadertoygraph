{"ver":"0.1","info":{"id":"McsGR4","date":"1702831019","viewed":34,"name":"mandelbulb-mipt-2023-kolesnikov","username":"difichento","description":"mipt 2023 cg hw kolesnikov","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["mipt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Mandelbulb SDF function\nfloat mandelbulbSDF(vec3 p) {\n    const int iterations = 4; // Number of Mandelbulb iterations\n    const float power = 6.0;  // Mandelbulb power\n\n    vec3 z = p;\n    float dr = 1.0;\n    float r = 0.0;\n\n    for (int i = 0; i < iterations; i++) {\n        r = length(z);\n        if (r > 2.0) break;\n\n        float theta = asin(z.z / r) * power;\n        float phi = atan(z.y, z.x) * power;\n        float zr = pow(r, power);\n        dr = pow(r, power - 1.0) * power * dr + 1.0;\n\n        z = zr * vec3(cos(theta) * cos(phi), cos(theta) * sin(phi), sin(theta));\n        z += p;\n    }\n\n    return 0.5 * log(r) * r / dr;\n}\n\n// Raymarching\nfloat rayMarch(vec3 origin, vec3 direction) {\n    const int steps = 5196;\n    float t = 0.0;\n    for (int i = 0; i < steps; ++i) {\n        float sdf = mandelbulbSDF(origin + t * direction);\n        if (sdf < 1e-6) return t;\n        t += sdf;\n    }\n    return -1.0;\n}\n\n// Calculate normal\nvec3 calcNormal(vec3 position) {\n    float eps = 1e-6;\n    vec2 h = vec2(eps, 0.0);\n    return normalize(vec3(\n        mandelbulbSDF(position + h.xyy) - mandelbulbSDF(position - h.xyy),\n        mandelbulbSDF(position + h.yxy) - mandelbulbSDF(position - h.yxy),\n        mandelbulbSDF(position + h.yyx) - mandelbulbSDF(position - h.yyx)\n    ));\n}\n// Utility function: Rotate a 3D vector by an angle (in radians) around a specified axis\nvec3 rotateAroundAxis(vec3 inp, vec3 axis, float angle) {\n    float cosTheta = cos(angle);\n    float sinTheta = sin(angle);\n    return (cosTheta + (1.0 - cosTheta) * dot(axis, axis)) * inp\n        + (sinTheta * cross(axis, inp)) + (1.0 - cosTheta) * dot(inp, axis) * axis;\n}\n\nvec3 hemisphereLight(vec3 normal, vec3 up, vec3 lightColor1, vec3 lightColor2)\n{\n    float intensity = dot(normal, up) * 0.5 + 0.5;\n    vec3 lightColor = mix(lightColor1, lightColor2, intensity);\n    return lightColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Screen-space UV coordinates\n    vec2 uv = (fragCoord.xy / iResolution.xy - 0.5) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Camera and ray setup\n    vec3 cameraPos = vec3(0.0, 0.0, 3.0);\n\n    // Calculate rotation based on time\n    float rotSpeed = 0.5;                        // Rotation speed (radians per second)\n    float rotY = iTime * rotSpeed;               // Rotate around Y-axis\n    float rotX = sin(iTime * rotSpeed * 0.25);   // Rotate around X-axis\n\n    cameraPos = rotateAroundAxis(cameraPos, vec3(0.0, 1.0, 0.0), rotY);\n    cameraPos = rotateAroundAxis(cameraPos, vec3(sin(rotY), 0.0, -cos(rotY)), rotX);\n\n    // Compute forward direction\n    vec3 forward = normalize(-cameraPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = cross(forward, up);\n\n    // Ray direction\n    vec3 dir = normalize(uv.x * right + uv.y * up + 2.0 * forward);\n\n    // Raymarching\n    float t = rayMarch(cameraPos, dir);\n    if (t < 0.0) {\n        fragColor = vec4(0.2, 0.2, 0.2, 1.0); // Background color\n    } else {\n        vec3 position = cameraPos + dir * t;\n        vec3 normal = calcNormal(position);\n\n        // Hemisphere lighting\n        vec3 lightColor1 = vec3(1.0);\n        vec3 lightColor2 = vec3(0.5, 0.3, 0.2);\n        vec3 lightColor = hemisphereLight(normal, up, lightColor1, lightColor2);\n\n        // Output to screen\n        fragColor = vec4(lightColor, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}