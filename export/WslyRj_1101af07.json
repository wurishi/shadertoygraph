{"ver":"0.1","info":{"id":"WslyRj","date":"1588962580","viewed":100,"name":"Titanic_Bridge","username":"mrabbitz","description":"raymarching, penumbra shadows, procedural texturing, FBM, uv mapping...","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// LOOK THROUGH ALL BUFFERS FOR THEIR PURPOSE AND REFERENCES\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 shipColor = texture(iChannel0, uv);\n    vec4 backgroundColor = texture(iChannel1, uv);\n    \n    if (shipColor == vec4(10.0, 10.0, 10.0, 1.0))\n    {\n        fragColor = backgroundColor;\n    }\n    else\n    {\n        fragColor = shipColor;\n    }\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// MAIN CODE THAT BRINGS EVERYTHING TOGETHER\n\n// MAIN SDF SCENE MAP CONSTRUCTED HERE\n// https://iquilezles.org/articles/distfunctions\n\n// PENUMBRA SHADOWS\n// https://iquilezles.org/articles/rmshadows\n\n// PRIMITIVE COMBINATIONS: Union, Subtraction, Intersection\n// https://iquilezles.org/articles/distfunctions\n\n// FINITE REPITITION\n// https://iquilezles.org/articles/distfunctions\n\n// ROUNDING EDGES\n// https://iquilezles.org/articles/distfunctions\n\nfloat knobStrength = 2.0;\nfloat pixelsPerPlank = 10.0;\nfloat linesPerPlank = 5.5;\nfloat verticalScale = 6.0;\nfloat lineStrength = 0.2;\nfloat plankLength = 8.0;\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res;\n}\n\nfloat noisetex(in vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\treturn texture( iChannel2, (p + f + 0.5)/256.0, -100.0 ).x;\n}\n\nfloat height(in vec2 a) {\n    a = a*vec2(1.0, 1.0/verticalScale);\n    return linesPerPlank * (knobStrength*noise(a) + a.x);\n}\n\n// make the lines constant width\n// https://iquilezles.org/articles/distance\nvec2 grad(in vec2 x) {\n\tvec2 h = vec2(0.05, 0.0);\n\treturn vec2(height(x+h.xy) - height(x-h.xy),\n                height(x+h.yx) - height(x-h.yx))/(2.0*h.x);\n}\n\nvec4 composit(in vec4 top, in vec4 bottom) {\n    return vec4(mix(top.xyz, bottom.xyz, 1.0-top.a), 1.0);\n}\n\n#define PI 3.14159265358\nconst int MAX_MARCHING_STEPS = 256;\nconst float EPSILON = 0.004;\n\nconst float k_coeff = 0.1;\n\nstruct Intersection {\n    vec3 p;\n    vec3 normal;\n    float t;\n    int objHit;\n};\n   \nfloat random1o3i(vec3 p) {\n  return fract(sin(dot(p, vec3(127.1, 311.7, 191.999))) * 43758.5453);\n}\n   \nvec3 rotateX(vec3 p, float a) {\n    return vec3(p.x, cos(a) * p.y - sin(a) * p.z, sin(a) * p.y + cos(a) * p.z);\n}\n   \nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvec3 rotateZ(vec3 p, float a) {\n    return vec3(cos(a) * p.x - sin(a) * p.y, sin(a) * p.x + cos(a) * p.y, p.z);\n}\n\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n// polynomial smooth min (k = 0.1);\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n// Create multiple copies of an object - https://iquilezles.org/articles/distfunctions\nvec3 opRepLim( in vec3 p, in float c, in vec3 lima, in vec3 limb)\n{\n    return p-c*clamp(round(p/c),lima,limb);\n}\n\n// b consists of width, height, and depth VECTORS (center to edge)\nfloat BoxSDF(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// point, radius, center\nfloat SphereSDF(vec3 p, float r, vec3 c) {\n    return distance(p, c) - r;\n}\n\nfloat TorusSDF( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xy)-t.x,p.z) )-t.y;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat CappedConeSDF( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\nfloat CappedConeSDF(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\nfloat FrameSDF(in vec3 pos) {\n    // main frame\n    float sampleBox = BoxSDF(pos, vec3(0.6, 1.6, 0.1));\n    // outer window ridge\n    float sampleBox1 = BoxSDF(pos - vec3(0.0, 0.5, 0.0), vec3(0.48, 0.48, 0.12));\n    // cutting hole out of main frame\n    sampleBox = opSubtraction(sampleBox1,sampleBox);\n    // inner window ridge cut piece\n    float sampleBox2 = BoxSDF(pos - vec3(0.0, 0.5, 0.0), vec3(0.46, 0.46, 0.15));\n    // cutting hole out of outer window ridge\n    sampleBox1 = opSubtraction(sampleBox2,sampleBox1);\n    // adding inner window ridge to outer window ridge, creating window frame\n    sampleBox1 = opUnion(sampleBox1, BoxSDF(pos - vec3(0.0, 0.5, 0.0), vec3(0.46, 0.46, 0.07)));\n    // window cut piece\n    sampleBox2 = BoxSDF(pos - vec3(0.0, 0.5, 0.0), vec3(0.44, 0.44, 0.15));\n    // cutting hole out of window frame\n    sampleBox1 = opSubtraction(sampleBox2,sampleBox1);\n    // window\n    sampleBox2 = BoxSDF(pos - vec3(0.0, 0.5, 0.0), vec3(0.44, 0.44, 0.01));\n    \n    // bottom wood\n    float bottomPiece = BoxSDF(pos - vec3(0.0, -0.5, 0.0), vec3(0.4, 0.4, 0.12));\n    bottomPiece = opSmoothSubtraction(SphereSDF(pos, 0.13, vec3(0.0, -0.4, 0.0)), bottomPiece, k_coeff);\n    \n    // don't want window as an intersectable object\n    // return min(sampleBox, min(sampleBox1, min(sampleBox2, bottomPiece)));\n    return min(sampleBox, min(sampleBox1, bottomPiece));\n}\nfloat FrameSDF(in vec3 pos, out int objHit) {\n    float sampleBox = BoxSDF(pos, vec3(0.6, 1.6, 0.1));\n    float sampleBox1 = BoxSDF(pos - vec3(0.0, 0.5, 0.0), vec3(0.48, 0.48, 0.12));\n    sampleBox = opSubtraction(sampleBox1,sampleBox);\n    float sampleBox2 = BoxSDF(pos - vec3(0.0, 0.5, 0.0), vec3(0.46, 0.46, 0.15));\n    sampleBox1 = opSubtraction(sampleBox2,sampleBox1);\n    sampleBox1 = opUnion(sampleBox1, BoxSDF(pos - vec3(0.0, 0.5, 0.0), vec3(0.46, 0.46, 0.07)));\n    sampleBox2 = BoxSDF(pos - vec3(0.0, 0.5, 0.0), vec3(0.44, 0.44, 0.15));\n    sampleBox1 = opSubtraction(sampleBox2,sampleBox1);\n    sampleBox2 = BoxSDF(pos - vec3(0.0, 0.5, 0.0), vec3(0.44, 0.44, 0.01));\n    \n    float bottomPiece = BoxSDF(pos - vec3(0.0, -0.5, 0.0), vec3(0.4, 0.4, 0.12));\n    bottomPiece = opSmoothSubtraction(SphereSDF(pos, 0.13, vec3(0.0, -0.4, 0.0)), bottomPiece, k_coeff);\n   \n    float t = sampleBox;\n    objHit = 0;\n    if (sampleBox1 < t)\n    {\n        t = sampleBox1;\n        objHit = 2;\n    }\n    // don't want window as an intersectable object\n    //if (sampleBox2 < t)\n    //{\n    //    t = sampleBox2;\n    //    objHit = -1;\n    //}\n    if (bottomPiece < t)\n    {\n        t = bottomPiece;\n        objHit = 2;\n    }\n   \n    return t;\n}\n\nfloat CeilingSDF(in vec3 pos) {\n    float t = BoxSDF(pos + vec3(0.0, -1.5, -2.9), vec3(5.5, 0.1, 3.0));\n    vec3 r1 = opRepLim(pos + vec3(0.6, 0.0, 0.0), 1.2,vec3(-4, 0, 0),vec3(5, 0, 0));\n    float t1 = BoxSDF(r1 + vec3(0.0, -1.45, -2.9), vec3(0.1, 0.2, 3.0));\n    vec3 r2 = opRepLim(pos + vec3(0.0, -1.4, -0.75), 1.0,vec3(0, 0, 0),vec3(0, 0, 5));\n    float t2 = BoxSDF(r2, vec3(6.0, 0.22, 0.2));\n    return min(t, min(t1, t2));\n}\n\nfloat CeilingSDF(in vec3 pos, out int objHit) {\n    objHit = 1;\n    return CeilingSDF(pos);\n}\n\nfloat GadgetSDF(in vec3 pos) {\n    float t = CappedConeSDF(pos - vec3( 0.0, -0.93, 1.0), 0.07, 0.2, 0.06);\n    float t2 = CappedConeSDF(pos - vec3( 0.0, -0.6, 1.0), 0.4, 0.1, 0.06);\n    t = sminCubic(t, t2, k_coeff);\n    \n    t2 = CappedConeSDF(pos-vec3( 0.0, -0.1, 1.0), vec3(0.2,0.0,0.0), vec3(-0.2,0.0,0.0), 0.2, 0.2);\n    float t3 = CappedConeSDF(pos-vec3( 0.25, -0.1, 1.0), vec3(0.0,0.0,0.0), vec3(-0.05,0.0,0.0), 0.25, 0.2);\n    t2 = opUnion(t2, t3);\n    \n    t3 = CappedConeSDF(pos-vec3( -0.25, -0.1, 1.0), vec3(0.0,0.0,0.0), vec3(0.05,0.0,0.0), 0.25, 0.2);\n    t2 = opUnion(t2, t3);\n    \n    return min(t, t2);\n}\n\nfloat GadgetSDF(in vec3 pos, out int objHit) {\n    objHit = 4;\n    \n    float t = CappedConeSDF(pos - vec3( 0.0, -0.93, 1.0), 0.07, 0.2, 0.06);\n    float t2 = CappedConeSDF(pos - vec3( 0.0, -0.6, 1.0), 0.4, 0.1, 0.06);\n    t = sminCubic(t, t2, k_coeff);\n    \n    t2 = CappedConeSDF(pos-vec3( 0.0, -0.1, 1.0), vec3(0.2,0.0,0.0), vec3(-0.2,0.0,0.0), 0.2, 0.2);\n    float t3 = CappedConeSDF(pos-vec3( 0.25, -0.1, 1.0), vec3(0.0,0.0,0.0), vec3(-0.05,0.0,0.0), 0.25, 0.2);\n    t2 = opUnion(t2, t3);\n    \n    t3 = CappedConeSDF(pos-vec3( -0.25, -0.1, 1.0), vec3(0.0,0.0,0.0), vec3(0.05,0.0,0.0), 0.25, 0.2);\n    t2 = opUnion(t2, t3);\n    \n    if (t2 < t)\n    {\n        t = t2;\n        objHit = 5;\n    }\n    \n    return t;\n}\n\n//float opRound( in sdf3d primitive, float rad )\n//{\n//    return primitive(p) - rad\n//}\n\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat WheelStand(in vec3 pos) {\n    \n    float t = BoxSDF(pos - vec3(0.0, -1.0, 1.5), vec3(0.6, 0.03, 0.3)) - 0.03;\n    \n    vec3 r1 = opRepLim(pos - vec3(0.0, -1.0, 1.5), 0.09, vec3(-6, 0, -3),vec3(6, 0, 3));\n    float t1 = BoxSDF(r1, vec3(0.025, 0.5, 0.025));\n    \n    t = opSubtraction(t1, t);\n    \n    // wood poles\n    t1 = sdCappedCylinder(pos - vec3(2.0, 0.0, 0.0), vec3(0.0, -1.5, 2.7), vec3(0.0, 2.0, 2.7), 0.05);\n    t1 = min(t1, sdCappedCylinder(pos + vec3(2.0, 0.0, 0.0), vec3(0.0, -1.5, 2.7), vec3(0.0, 2.0, 2.7), 0.05));\n\n    return min(t, t1);\n}\n\nfloat WheelStand(in vec3 pos, out int objHit) {\n    \n    objHit = 2;\n\n    return WheelStand(pos);\n}\n\nfloat WheelStand1(in vec3 pos) {\n    \n    float t = CappedConeSDF(pos - vec3( 0.0, -0.93, 0.9), 0.07, 0.16, 0.04);\n    float t2 = CappedConeSDF(pos - vec3( 0.0, -0.65, 0.9), 0.3, 0.06, 0.04);\n    t = sminCubic(t, t2, k_coeff);\n    t = min(t, BoxSDF(pos - vec3( 0.0, 1.1, 0.9), vec3(0.16)));\n    \n    // gold\n    t2 = sdCappedCylinder(pos, vec3(0.0, -0.4, 0.9), vec3(0.0, -0.2, 0.9), 0.15);\n    t2 = min(t2, sdCappedCylinder(pos, vec3(0.0, -0.3, 0.9), vec3(0.0, 1.2, 0.9), 0.02));\n    t2 = min(t2, sdCappedCylinder(pos, vec3(0.0, 1.1, 0.9), vec3(0.0, 1.1, 10.0), 0.02));\n    \n    return min(t, t2);\n}\n\nfloat WheelStand1(in vec3 pos, out int objHit) {\n    \n    objHit = 4;\n\n    float t = CappedConeSDF(pos - vec3( 0.0, -0.93, 0.9), 0.07, 0.16, 0.04);\n    float t2 = CappedConeSDF(pos - vec3( 0.0, -0.65, 0.9), 0.3, 0.06, 0.04);\n    t = sminCubic(t, t2, k_coeff);\n    t = min(t, BoxSDF(pos - vec3( 0.0, 1.1, 0.9), vec3(0.16)));\n    \n    // gold\n    t2 = sdCappedCylinder(pos, vec3(0.0, -0.4, 0.9), vec3(0.0, -0.2, 0.9), 0.15);\n    t2 = min(t2, sdCappedCylinder(pos, vec3(0.0, -0.3, 0.9), vec3(0.0, 1.2, 0.9), 0.02));\n    t2 = min(t2, sdCappedCylinder(pos, vec3(0.0, 1.1, 0.9), vec3(0.0, 1.1, 10.0), 0.02));\n    \n    if (t2 < t)\n    {\n        t = t2;\n        objHit = 5;\n    }\n    \n    return t;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat Wheel(in vec3 pos) {\n    \n    float t = TorusSDF(pos - vec3( 0.0, -0.3, 1.1), vec2(0.4,0.04));\n    float t2 = sdCapsule(pos, vec3(-0.6, -0.3, 1.1), vec3(0.6, -0.3, 1.1), 0.03);\n    t2 = sminCubic(t2, sdCapsule(pos, rotateZ(vec3(-0.6, 0.0, 1.1), PI / 4.0) + vec3(0.0, -0.3, 0.0), rotateZ(vec3(0.6, 0.0, 1.1), PI / 4.0) + vec3(0.0, -0.3, 0.0), 0.03), 0.08);\n    t2 = sminCubic(t2, sdCapsule(pos, rotateZ(vec3(-0.6, 0.0, 1.1), PI / 2.0) + vec3(0.0, -0.3, 0.0), rotateZ(vec3(0.6, 0.0, 1.1), PI / 2.0) + vec3(0.0, -0.3, 0.0), 0.03), 0.08);\n    t2 = sminCubic(t2, sdCapsule(pos, rotateZ(vec3(-0.6, 0.0, 1.1), PI*.75) + vec3(0.0, -0.3, 0.0), rotateZ(vec3(0.6, 0.0, 1.1), PI*.75) + vec3(0.0, -0.3, 0.0), 0.03), 0.08);\n\n\n    return min(t, t2);\n}\n\nfloat Wheel(in vec3 pos, out int objHit) {\n    \n    objHit = 2;\n    \n    if \t(\n        \t(length(vec2(pos.x, pos.y + 0.3)) < 0.09)\n        || \t(length(vec2(pos.x, pos.y + 0.3)) > 0.57)\n        || \t(\n            \t(length(vec2(pos.x, pos.y + 0.3)) > 0.37)\n            && \t(length(vec2(pos.x, pos.y + 0.3)) < 0.43)\n            && \tpos.z > 1.1\n        \t)\n    \t)\n    {\n        objHit = 5;\n    }\n\n    return Wheel(pos);\n}\n\nfloat RightWall(in vec3 pos) {\n    float t = BoxSDF(pos - vec3( 5.5, 0.0, 3.0), vec3(0.1, 1.6, 3.1));\n    t = min(t, BoxSDF(pos - vec3( -5.5, 0.0, 3.0), vec3(0.1, 1.6, 3.1)));\n    t = min(t, BoxSDF(pos - vec3( 0.0, 0.0, 5.4), vec3(5.6, 1.6, 0.1)));\n    return t;\n}\nfloat RightWall(in vec3 pos, out int objHit) {\n    objHit = 6;\n    return RightWall(pos);\n}\n\nfloat SceneSDF(in vec3 pos) {\n    vec3 r1 = opRepLim(pos, 2.0, vec3(-2, 0, 0),vec3(-1, 0, 0));\n    float t3 = GadgetSDF(r1);\n    \n    vec3 r2 = opRepLim(pos, 2.0, vec3(1, 0, 0),vec3(2, 0, 0));\n    float t4 = GadgetSDF(r2);\n    \n    t3 = min(t3, t4);\n    \n    t3 = min(t3, WheelStand(pos));\n    \n    t3 = min(t3, WheelStand1(pos));\n    \n    t3 = min(t3, Wheel(pos));\n    \n    t3 = min(t3, RightWall(pos));\n    \n    vec3 r = opRepLim(pos, 1.2,vec3(-4, 0, 0),vec3(4, 0, 0));\n    return min(t3, min(CeilingSDF(pos), min(FrameSDF(r), BoxSDF(pos + vec3(0.0, 1.1, -2.5), vec3(6.0, 0.1, 3.0)))));\n\n}\nfloat SceneSDF(in vec3 pos, out int objHit) {\n    \n    vec3 r = opRepLim(pos, 1.2,vec3(-4, 0, 0),vec3(4, 0, 0));\n    float t = FrameSDF(r, objHit);\n    float t1 = BoxSDF(pos + vec3(0.0, 1.1, -2.5), vec3(6.0, 0.1, 3.0));\n    if (t1 < t)\n    {\n        t = t1;\n        objHit = 3;\n    }\n    int objHit2;\n    float t2 = CeilingSDF(pos, objHit2);\n    if (t2 < t)\n    {\n        t = t2;\n        objHit = objHit2;\n    }\n    int objHit3;\n    vec3 r1 = opRepLim(pos, 2.0, vec3(-2, 0, 0),vec3(-1, 0, 0));\n    float t3 = GadgetSDF(r1, objHit3);\n    if (t3 < t)\n    {\n        t = t3;\n        objHit = objHit3;\n    }\n    \n    int objHit4;\n    vec3 r2 = opRepLim(pos, 2.0, vec3(1, 0, 0),vec3(2, 0, 0));\n    float t4 = GadgetSDF(r2, objHit4);\n    if (t4 < t)\n    {\n        t = t4;\n        objHit = objHit4;\n    }\n    \n    t4 = WheelStand(pos, objHit4);\n    if (t4 < t)\n    {\n        t = t4;\n        objHit = objHit4;\n    }\n    \n    t4 = WheelStand1(pos, objHit4);\n    if (t4 < t)\n    {\n        t = t4;\n        objHit = objHit4;\n    }\n    \n    t4 = Wheel(pos, objHit4);\n    if (t4 < t)\n    {\n        t = t4;\n        objHit = objHit4;\n    }\n    \n    t4 = RightWall(pos, objHit4);\n    if (t4 < t)\n    {\n        t = t4;\n        objHit = objHit4;\n    }\n    \n    return t;\n}\n\n\nfloat RayMarch(in vec3 eye, in vec3 viewRayDirection, out int objHit) {\n  float marchedDist = 0.0;\n  float minDist = 0.0;\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n      minDist = SceneSDF(eye + marchedDist * viewRayDirection, objHit);\n      if (minDist < EPSILON) {\n          // We're inside the scene surface!\n          return marchedDist;\n      }\n      // Move along the view ray\n      marchedDist += minDist;\n  }\n  objHit = -1;\n  return -1.0;\n}\n\nvec3 ComputeColor(vec3 p, vec3 n, int objHit) {\n    vec3 color;\n    \n    // white wood with breaks\n    if (objHit == 0)\n    {\n        //if (fract((p.x * 5.85) + 0.05) < 0.1)\n        //{\n        //    color = vec3(0.0, 0.0, 0.0);\n        //}\n        //else\n        //{\n                    knobStrength = 2.0;\n\t\tpixelsPerPlank = 10.0;\n\t\tlinesPerPlank = 2.0;\n\t\tverticalScale = 6.0;\n\t\tlineStrength = 0.2;\n\t\tplankLength = 200.0;\n        \n\t\tvec3 woodBase = vec3(1.0);\n        vec3 woodLine = vec3(0.8);\n        \n        vec2 fragCoord = (p.xy) * 48.0;\n            vec2 pixel = fragCoord / pixelsPerPlank;\n    float plank = floor(pixel.x); // unique per plank\n    float start = 15.0 * rand(vec2(plank));\n    float item = floor(pixel.y/plankLength + start);\n    \n    vec2 plankPixel = pixel + vec2(124., 11.) * plank;\n    float value = height(plankPixel + item);\n    vec2 gradient = grad(plankPixel + item);\n    float linePos = 1.0 - smoothstep(0.0, 0.08, fract(value)/length(gradient));\n    float line = floor(value); // unique per line\n    float lineWeight = mix(1.0, 0.4+rand(vec2(line,plank)), 0.8);\n    float lineGrain = smoothstep(-0.2, 0.9, noisetex(fragCoord));\n    \n    float darkness = mix(1.0, 0.5+rand(vec2(plank, item)), 0.2);\n    float grain = mix(1.0, 0.5 + 0.7*noisetex(fragCoord + 12.5), 0.1);\n    \n    float plankGapY = step(0.0, fract(pixel.x)) * (1.0-step(0.0, fract(pixel.x)));\n    float plankGapX = step(0.0, fract(pixel.y/plankLength+start)) * (1.0-step(0.0/plankLength, fract(pixel.y/plankLength+start)));\n   \n    // final images\n    vec4 planks = vec4(0.1, 0.1, 0.1, max(plankGapY, plankGapX));\n    vec4 lines = vec4(woodLine, lineStrength*lineWeight*lineGrain*linePos);\n    vec4 wood = vec4(woodBase*darkness*grain, 1.0);\n    \n    color = composit(planks, composit(lines, wood)).rgb;\n        //}\n    }\n    // white wood without breaks\n    else if (objHit == 1)\n    {\n        color = vec3(1.0);\n    }\n    // brown wood without breaks\n    else if (objHit == 2)\n    {\n        \n                knobStrength = 2.0;\n\t\tpixelsPerPlank = 10.0;\n\t\tlinesPerPlank = 5.5;\n\t\tverticalScale = 6.0;\n\t\tlineStrength = 0.2;\n\t\tplankLength = 10.0;\n        \n        vec3 woodBase = vec3(82.0/255.0, 39.0/255.0, 26.0/255.0);\n        vec3 woodLine = vec3(144., 91., 49.)/255.;\n        \n        vec2 fragCoord = (p.xy) * 48.0;\n            vec2 pixel = fragCoord / pixelsPerPlank;\n    float plank = floor(pixel.x); // unique per plank\n    float start = 15.0 * rand(vec2(plank));\n    float item = floor(pixel.y/plankLength + start);\n    \n    vec2 plankPixel = pixel + vec2(124., 11.) * plank;\n    float value = height(plankPixel + item);\n    vec2 gradient = grad(plankPixel + item);\n    float linePos = 1.0 - smoothstep(0.0, 0.08, fract(value)/length(gradient));\n    float line = floor(value); // unique per line\n    float lineWeight = mix(1.0, 0.4+rand(vec2(line,plank)), 0.8);\n    float lineGrain = smoothstep(-0.2, 0.9, noisetex(fragCoord));\n    \n    float darkness = mix(1.0, 0.5+rand(vec2(plank, item)), 0.2);\n    float grain = mix(1.0, 0.5 + 0.7*noisetex(fragCoord + 12.5), 0.1);\n    \n    float plankGapY = step(0.0, fract(pixel.x)) * (1.0-step(0.0, fract(pixel.x)));\n    float plankGapX = step(0.0, fract(pixel.y/plankLength+start)) * (1.0-step(0.0/plankLength, fract(pixel.y/plankLength+start)));\n   \n    // final images\n    vec4 planks = vec4(0.1, 0.1, 0.1, max(plankGapY, plankGapX));\n    vec4 lines = vec4(woodLine, lineStrength*lineWeight*lineGrain*linePos);\n    vec4 wood = vec4(woodBase*darkness*grain, 1.0);\n    \n    color = composit(planks, composit(lines, wood)).rgb;\n    }\n    // wood floor\n    else if (objHit == 3)\n    {\n        knobStrength = 2.0;\n\t\tpixelsPerPlank = 10.0;\n\t\tlinesPerPlank = 5.5;\n\t\tverticalScale = 6.0;\n\t\tlineStrength = 0.2;\n\t\tplankLength = 8.0;\n        \n        vec3 woodBase = vec3(231.,207.,180.)/255.;\n        \n        vec2 fragCoord = (p.xz) * 48.0;\n            vec2 pixel = fragCoord / pixelsPerPlank;\n    float plank = floor(pixel.x); // unique per plank\n    float start = 15.0 * rand(vec2(plank));\n    float item = floor(pixel.y/plankLength + start);\n    \n    vec3 woodLine = vec3(144., 91., 49.)/255.;\n    vec2 plankPixel = pixel + vec2(124., 11.) * plank;\n    float value = height(plankPixel + item);\n    vec2 gradient = grad(plankPixel + item);\n    float linePos = 1.0 - smoothstep(0.0, 0.08, fract(value)/length(gradient));\n    float line = floor(value); // unique per line\n    float lineWeight = mix(1.0, 0.4+rand(vec2(line,plank)), 0.8);\n    float lineGrain = smoothstep(-0.2, 0.9, noisetex(fragCoord));\n    \n    float darkness = mix(1.0, 0.5+rand(vec2(plank, item)), 0.2);\n    float grain = mix(1.0, 0.5 + 0.7*noisetex(fragCoord + 12.5), 0.1);\n    \n    float plankGapY = step(0.0, fract(pixel.x)) * (1.0-step(0.0, fract(pixel.x)));\n    float plankGapX = step(0.0, fract(pixel.y/plankLength+start)) * (1.0-step(0.0/plankLength, fract(pixel.y/plankLength+start)));\n   \n    // final images\n    vec4 planks = vec4(0.1, 0.1, 0.1, max(plankGapY, plankGapX));\n    vec4 lines = vec4(woodLine, lineStrength*lineWeight*lineGrain*linePos);\n    vec4 wood = vec4(woodBase*darkness*grain, 1.0);\n    \n    color = composit(planks, composit(lines, wood)).rgb;\n    }\n    // white part of gadgets\n    else if (objHit == 4)\n    {\n        color = vec3(1.0);\n    }\n    // gold tops of gadgets\n    else if (objHit == 5)\n    {\n        if (abs(n.z) > 0.0 || abs(n.y) > 0.0)\n        {\n        \tcolor = vec3(1.0, 215.0/255.0, 0.0);\n        }\n        else\n        {\n            // p.z is 0.25 to 1.25\n            // want -1 to 1\n            p.z -= 0.75;\t// -.5 to .5\n            p.z *= 2.0;\t// -1 to 1\n                \n            // p.y is -.85 to .15\n            // want -1 to 1\n            p.y += 0.35; // -.5 to .5\n            p.y *= 2.0;\n\n            if (n.x > 0.0)\n            {\n                p.z *= -1.0;\n                p.z += 1.0;\n            }\n            color = texture(iChannel1, p.zy).rgb;\n        }\n    }\n    // white wood walls\n    else if (objHit == 6) {\n               knobStrength = 2.0;\n\t\tpixelsPerPlank = 10.0;\n\t\tlinesPerPlank = 2.0;\n\t\tverticalScale = 6.0;\n\t\tlineStrength = 0.2;\n\t\tplankLength = 200.0;\n        \n        vec3 woodBase = vec3(1.0);\n        vec3 woodLine = vec3(0.8);\n        \n        vec2 fragCoord = (p.zy) * 48.0;\n        if (n.z < -0.5)\n        {\n            fragCoord = (p.xy) * 48.0;\n        }\n            vec2 pixel = fragCoord / pixelsPerPlank;\n    float plank = floor(pixel.x); // unique per plank\n    float start = 15.0 * rand(vec2(plank));\n    float item = floor(pixel.y/plankLength + start);\n    \n    vec2 plankPixel = pixel + vec2(124., 11.) * plank;\n    float value = height(plankPixel + item);\n    vec2 gradient = grad(plankPixel + item);\n    float linePos = 1.0 - smoothstep(0.0, 0.08, fract(value)/length(gradient));\n    float line = floor(value); // unique per line\n    float lineWeight = mix(1.0, 0.4+rand(vec2(line,plank)), 0.8);\n    float lineGrain = smoothstep(-0.2, 0.9, noisetex(fragCoord));\n    \n    float darkness = mix(1.0, 0.5+rand(vec2(plank, item)), 0.2);\n    float grain = mix(1.0, 0.5 + 0.7*noisetex(fragCoord + 12.5), 0.1);\n    \n    float plankGapY = step(0.0, fract(pixel.x)) * (1.0-step(0.0, fract(pixel.x)));\n    float plankGapX = step(0.0, fract(pixel.y/plankLength+start)) * (1.0-step(0.0/plankLength, fract(pixel.y/plankLength+start)));\n   \n    // final images\n    vec4 planks = vec4(0.1, 0.1, 0.1, max(plankGapY, plankGapX));\n    vec4 lines = vec4(woodLine, lineStrength*lineWeight*lineGrain*linePos);\n    vec4 wood = vec4(woodBase*darkness*grain, 1.0);\n    \n    color = composit(planks, composit(lines, wood)).rgb;\n    }\n    else\n    {\n        color = vec3(0.0);\n    }\n    return color;\n}\n\nvec3 ComputeNormal(vec3 pos) {\n    vec2 offset = vec2(0.0, 0.001);\n    return normalize( vec3( SceneSDF(pos + offset.yxx) - SceneSDF(pos - offset.yxx),\n                            SceneSDF(pos + offset.xyx) - SceneSDF(pos - offset.xyx),\n                            SceneSDF(pos + offset.xxy) - SceneSDF(pos - offset.xxy)\n                          )\n                    );\n}\n\nIntersection SceneIntersection(in vec3 eye, in vec3 viewRayDirection) {\n  int objHit = -1;\n  float t = -1.0;\n  t = RayMarch(eye, viewRayDirection, objHit);\n\n  if (objHit == -1)\n  {\n    return Intersection(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), t, objHit);\n  }\n  else\n  {\n    vec3 intersectPoint = eye + t * viewRayDirection;\n    vec3 intersectNormal = ComputeNormal(intersectPoint);\n    return Intersection(intersectPoint, intersectNormal, t, objHit);\n  }\n}\n\n// https://www.shadertoy.com/view/3dj3Rc\nvoid RayCast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {\n    //eye = vec3(0.0, 0.0, 5.0);\n    //ref = vec3(0.0, 0.0, 0.0);\n    //float len = tan(3.14159 * 0.125) * distance(eye, ref);\n    //vec3 F = ref - eye;\n   \n    float t = iTime * 3.14159 * 0.01;\n    //eye = 10.0 * vec3(cos(t), 0.0, sin(t));\n    //F = rotateY(vec3(0.0, 0.0, 1.0), -t);\n    //len = 1.0 * tan(3.14159 * 0.125);\n    //ref = eye + F;\n   \n    //eye = vec3(5.4, 1.9, -1.0);\n    //eye = rotateY(vec3(-5.0, 0.0, 0.2), t);\n    //ref = vec3(5.1, 1.0, 1.0);\n    //eye = vec3(2.0, 0.0, 3.0);\n    eye = rotateY(vec3(-5.0, 0.2, 1.0), t);\n    ref = vec3(0.0, 0.0, 0.0);\n    float len = tan(3.14159 * 0.125) * distance(eye, ref);\n    vec3 F = ref - eye;\n   \n   \n    vec3 H = normalize(cross(F, vec3(0.0, 1.0, 0.0)));\n    vec3 V = normalize(cross(H, F));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<100; i++ )\n    {\n\t\tfloat h = SceneSDF( ro + rd*t );\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d/max(0.0,t-y) );\n        ph = h;\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.001 + 0.15*float(i)/4.0;\n        float d = SceneSDF( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n   \n    // https://www.shadertoy.com/view/wsjGDG\n    Intersection aaIsects[4];\n    vec3 dir, eye, ref;\n    int idx = 0;\n    for(float i = 0.0; i < 1.0; i += 0.5) {\n        for(float j = 0.0; j < 1.0; j += 0.5) {\n            RayCast(uv2 + vec2(i, j) / iResolution.xy, dir, eye, ref);\n            aaIsects[idx++] = SceneIntersection(eye, dir);\n        }\n    }\n    \n    Intersection intersection = aaIsects[0];\n    \n    if (intersection.objHit == -1)\n    {\n        fragColor = vec4(10.0, 10.0, 10.0, 1.0);\n    }\n    else\n    {\n    \tvec3 avgColor = vec3(0.0);\n    \tfor(int i = 0; i < 4; ++i) {\n    \t    avgColor += ComputeColor(aaIsects[i].p, aaIsects[i].normal, aaIsects[i].objHit);\n    \t}\n    \tavgColor *= 0.25;\n   \n    \tvec3 color = vec3(0.0);\n    \tvec3 baseColor = avgColor;\n        \n    //    https://www.shadertoy.com/view/lsKcDD\n    \n    // key light\n        vec3  lig = normalize( vec3(-0.25, 0.3, -0.4) );\n        vec3  hal = normalize( lig-dir );\n        float dif = clamp( dot( intersection.normal, lig ), 0.0, 1.0 ) * \n                    calcSoftshadow( intersection.p, lig, 0.01, 15.0);\n\n\t\tfloat spe = pow( clamp( dot( intersection.normal, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,dir),0.0,1.0), 5.0 ));\n\n\t\tcolor = baseColor * 4.0*dif*vec3(1.00,0.70,0.5);\n        color +=      12.0*spe*vec3(1.00,0.70,0.5);\n    \n            // ambient light\n        float occ = calcAO( intersection.p, intersection.normal );\n\t\tfloat amb = clamp( 0.5+0.5*intersection.normal.y, 0.0, 1.0 );\n        color += baseColor*amb*occ*vec3(0.0,0.08,0.1);\n    color += baseColor * 0.4;\n    if (intersection.p.z < -0.065)\n    {\n        color = vec3(10.0);\n    }\n   \n    fragColor = vec4(color, 1.0);\n    }\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// SKY AND OCEAN\n// this standalone code is demonstrated at https://www.shadertoy.com/view/wsXcD7\n// the following reference is sparingly used:\n// https://www.shadertoy.com/view/4d2cDy\n#define PI 3.14159265358\n\n// random1o2i\nfloat noise2D(vec2 p) {\n    return fract(sin(dot(p,vec2(127.1,311.7))) * 43758.5453);\n}\n\nfloat interpNoise2D(vec2 uv) {\n    float intX = floor(uv.x);\n    float fractX = fract(uv.x);\n    float intY = floor(uv.y);\n    float fractY = fract(uv.y);\n\n    float v1 = noise2D(vec2(intX, intY));\n    float v2 = noise2D(vec2(intX + 1.0, intY));\n    float v3 = noise2D(vec2(intX, intY + 1.0));\n    float v4 = noise2D(vec2(intX + 1.0, intY + 1.0));\n\n    float i1 = mix(v1, v2, fractX);\n    float i2 = mix(v3, v4, fractX);\n    \n    return mix(i1, i2, fractY);\n}\n\nfloat fbm2D(vec2 uv) {\n    float total = 0.0;\n    float persistence = 0.5;\n    int octaves = 8;\n\n    for(int i = 1; i <= octaves; i++) {\n        float freq = pow(2.f, float(i));\n        float amp = pow(persistence, float(i));\n\n        total += interpNoise2D(uv * freq) * amp;\n    }\n    return total;\n}\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvoid RayCast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {\n    //eye = vec3(0.0, 0.0, 5.0);\n    //ref = vec3(0.0, 0.0, 0.0);\n    //float len = tan(3.14159 * 0.125) * distance(eye, ref);\n    //vec3 F = ref - eye;\n   \n    float t = iTime * 3.14159 * 0.01;\n    //eye = 10.0 * vec3(cos(t), 0.0, sin(t));\n    //F = rotateY(vec3(0.0, 0.0, 1.0), -t);\n    //len = 1.0 * tan(3.14159 * 0.125);\n    //ref = eye + F;\n   \n    eye = vec3(-3.0, 0.0, 4.0);\n    eye = rotateY(vec3(-3.0, 0.0, 4.0), t);\n    ref = vec3(0.0, 0.0, 1.0);\n    float len = tan(3.14159 * 0.125) * distance(eye, ref);\n    vec3 F = ref - eye;\n   \n   \n    vec3 H = normalize(cross(F, vec3(0.0, 1.0, 0.0)));\n    vec3 V = normalize(cross(H, F));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n\nconst vec3 up = vec3(0.0, 1.0, 0.0);\n\n// https://www.color-hex.com/color/87cefa\nconst vec3 horizonColor = vec3(135.0/255.0, 206.0/255.0, 250.0/255.0);\n// https://www.color-hex.com/color/1874cd\nconst vec3 skyColor = vec3(24.0/255.0, 116.0/255.0, 205.0/255.0);\nconst vec3 cloudColor = vec3(1.0);\nconst float cloudPlaneHeight = 10.0;\n\nvoid Clouds(vec3 dir, out vec3 color) {\n    vec3 cloudPlane = dir*cloudPlaneHeight/dot(dir, up);\n    vec2 uv = cloudPlane.xz + iTime * .5;\n    float clouds = fbm2D(uv * .01);\n    clouds = clamp((clouds - 0.5) * 2.0, 0.0, 1.0);\n    color = mix(color, cloudColor, clouds);\n}\n\nconst float waterPlaneHeight = 1.0;\n// https://www.schemecolor.com/sample?getcolor=004281\nconst vec3 waterColor = vec3(0.0/255.0, 66.0/255.0, 129.0/255.0);\n\nconst vec3 sun = normalize(vec3(0.0, 0.1, 1.0));\n\nvoid Ocean(vec3 dir, out vec3 color) {\n    vec3 waterPlane = dir*waterPlaneHeight/dot(dir, up);\n    vec2 uv = waterPlane.xz + iTime * 2.0;\n    \n    color = waterColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n    uv2.y /= 3.0;\n   \n    vec3 dir, eye, ref;\n    RayCast(uv2, dir, eye, ref);\n    // sets color of sky\n    vec3 color = mix(horizonColor, skyColor, smoothstep(-.2, .3, dir.y));\n    \n    // clouds\n    if (uv2.y>0.045)\n    {\n        Clouds(dir, color);\n\t}\n    else if (uv2.y<0.025)\n    {\n        Ocean(dir, color);\n    }\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// PROCEDURAL WOOD MATERIAL\n// based off of https://www.shadertoy.com/view/XsG3Dc\n\nconst float knobStrength = 2.0;\nconst float pixelsPerPlank = 10.0;\nconst float linesPerPlank = 5.5;\nconst float verticalScale = 6.0;\nconst float lineStrength = 0.2;\nconst float plankLength = 8.0;\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res;\n}\n\nfloat noisetex(in vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\treturn texture( iChannel2, (p + f + 0.5)/256.0, -100.0 ).x;\n}\n\nfloat height(in vec2 a) {\n    a = a*vec2(1.0, 1.0/verticalScale);\n    return linesPerPlank * (knobStrength*noise(a) + a.x);\n}\n\n// make the lines constant width\n// https://iquilezles.org/articles/distance\nvec2 grad(in vec2 x) {\n\tvec2 h = vec2(0.05, 0.0);\n\treturn vec2(height(x+h.xy) - height(x-h.xy),\n                height(x+h.yx) - height(x-h.yx))/(2.0*h.x);\n}\n\nvec4 composit(in vec4 top, in vec4 bottom) {\n    return vec4(mix(top.xyz, bottom.xyz, 1.0-top.a), 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //animation\n    //fragCoord.y += iTime * 100.;\n    \n    vec2 pixel = fragCoord / pixelsPerPlank;\n    float plank = floor(pixel.x); // unique per plank\n    float start = 15.0 * rand(vec2(plank));\n    float item = floor(pixel.y/plankLength + start);\n    \n    vec3 woodLine = vec3(144., 91., 49.)/255.;\n    vec2 plankPixel = pixel + vec2(124., 11.) * plank;\n    float value = height(plankPixel + item);\n    vec2 gradient = grad(plankPixel + item);\n    float linePos = 1.0 - smoothstep(0.0, 0.08, fract(value)/length(gradient));\n    float line = floor(value); // unique per line\n    float lineWeight = mix(1.0, 0.4+rand(vec2(line,plank)), 0.8);\n    float lineGrain = smoothstep(-0.2, 0.9, noisetex(fragCoord));\n    \n    vec3 woodBase = vec3(231.,207.,180.)/255.;\n    float darkness = mix(1.0, 0.5+rand(vec2(plank, item)), 0.2);\n    float grain = mix(1.0, 0.5 + 0.7*noisetex(fragCoord + 12.5), 0.1);\n    \n    float plankGapY = step(0.0, fract(pixel.x)) * (1.0-step(0.0, fract(pixel.x)));\n    float plankGapX = step(0.0, fract(pixel.y/plankLength+start)) * (1.0-step(0.0/plankLength, fract(pixel.y/plankLength+start)));\n   \n    // final images\n    vec4 planks = vec4(0.1, 0.1, 0.1, max(plankGapY, plankGapX));\n    vec4 lines = vec4(woodLine, lineStrength*lineWeight*lineGrain*linePos);\n    vec4 wood = vec4(woodBase*darkness*grain, 1.0);\n    \n    fragColor = composit(planks, composit(lines, wood));\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// GENERATING THE TEXT/IMAGE ON THE SIDE OF THE TELEGRAPHS\n// this standalone code is demonstrated at https://www.shadertoy.com/view/wdsyWM\n// which comes from modification of https://www.shadertoy.com/view/XdXGRB\n\nvec2 coord;\n\n#define font_size 20. \n#define font_spacing .055\n#define STROKEWIDTH 0.2\n#define PI 3.14159265359\n\n#define A_ vec2(0.,0.)\n#define A1_ vec2(1.,0.)\n#define B_ vec2(2.,0.)\n#define B1_ vec2(3.,0.)\n#define C_ vec2(4.,0.)\n\n#define D_ vec2(0.,1.)\n#define E_ vec2(2.,1.)\n#define F_ vec2(4.,1.)\n\n#define G_ vec2(0.,2.)\n#define G1_ vec2(1.,3.2)\n#define H_ vec2(2.,2.)\n#define H1_ vec2(3.,3.2)\n#define I_ vec2(4.,2.)\n\n#define J_ vec2(0.,3.)\n#define K_ vec2(2.,3.)\n#define L_ vec2(4.,3.)\n\n#define M_ vec2(0.,4.)\n#define M1_ vec2(1.,4.)\n#define N_ vec2(2.,4.)\n#define N1_ vec2(3.,4.)\n#define O_ vec2(4.,4.)\n\n#define P_ vec2(0.,5.)\n#define Q_ vec2(2.,5.)\n#define R_ vec2(4.,5.)\n\n#define S_ vec2(0.,6.)\n#define T_ vec2(2.,6.)\n#define U_ vec2(4.,6.)\n\n#define L(p) t(M_,O_,p) + t(M_,A_,p)\n#define O(p) t(M_,O_,p) + t(O_,C_,p) + t(C_,A_, p) + t(A_,M_,p)\n#define S(p) t(M_,O_,p) + t(O_,I_,p) + t(I_,G_,p) + t(G_,A_,p) + t(A_,C_,p)\n#define W(p) t(A_,M1_,p) + t(M1_,B_,p) + t(B_,N1_,p) + t(N1_,C_,p)\n\n#define F(p) t(M_,A_,p) + t(A_,C_,p) + t(G_,I_,p)\n#define U(p) t(M_,A_,p) + t(M_,O_,p) + t(O_,C_,p)\n\n#define H(p) t(M_,A_,p) + t(G_,I_,p) + t(O_,C_,p)\n#define A(p) t(M_,B_,p) + t(G1_,H1_,p) + t(B_,O_,p)\n\n#define T(p) t(N_,B_,p) + t(A_,C_,p)\n#define P(p) t(M_,A_,p) + t(A_,C_,p) + t(G_,I_,p) + t(C_,I_,p)\n\t\nvec2 caret_origin = vec2(11., .5);\nvec2 caret;\n\n//-----------------------------------------------------------------------------------\nfloat minimum_distance(vec2 v, vec2 w, vec2 p)\n{\t// Return minimum distance between line segment vw and point p\n  \tfloat l2 = (v.x - w.x)*(v.x - w.x) + (v.y - w.y)*(v.y - w.y); //length_squared(v, w);  // i.e. |w-v|^2 -  avoid a sqrt\n  \tif (l2 == 0.0) {\n\t\treturn distance(p, v);   // v == w case\n\t}\n\t\n\t// Consider the line extending the segment, parameterized as v + t (w - v).\n  \t// We find projection of point p onto the line.  It falls where t = [(p-v) . (w-v)] / |w-v|^2\n  \tfloat t = dot(p - v, w - v) / l2;\n  \tif(t < 0.0) {\n\t\t// Beyond the 'v' end of the segment\n\t\treturn distance(p, v);\n\t} else if (t > 1.0) {\n\t\treturn distance(p, w);  // Beyond the 'w' end of the segment\n\t}\n  \tvec2 projection = v + t * (w - v);  // Projection falls on the segment\n\treturn distance(p, projection);\n}\n\n//-----------------------------------------------------------------------------------\nfloat textColor(vec2 from, vec2 to, vec2 p)\n{\n\tp *= font_size;\n\tfloat inkNess = 0., nearLine, corner;\n\tnearLine = minimum_distance(from,to,p); // basic distance from segment, thanks http://glsl.heroku.com/e#6140.0\n\tinkNess += smoothstep(0., 1., 1.- 14.*(nearLine - STROKEWIDTH)); // ugly still\n\tinkNess += smoothstep(0., 2.5, 1.- (nearLine  + 5. * STROKEWIDTH)); // glow\n\treturn inkNess;\n}\n\n//-----------------------------------------------------------------------------------\nvec2 grid(vec2 letterspace) \n{\n\treturn ( vec2( (letterspace.x / 2.) * .65 , 1.0-((letterspace.y / 2.) * .95) ));\n}\n\n//-----------------------------------------------------------------------------------\nfloat count = 0.0;\nfloat gtime;\nfloat t(vec2 from, vec2 to, vec2 p) \n{\n\treturn textColor(grid(from), grid(to), p);\n}\n\n//-----------------------------------------------------------------------------------\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nvec2 rSlow()\n{\n\tvec2 pos = coord.xy/iResolution.xy;\n\t\n    \n    pos -= vec2(0.5);\n    // rotate the space\n    pos = rotate2d( PI / 4. ) * pos;\n    // move it back to the original place\n    pos += vec2(0.5);\n    \n    pos.y -= caret.y;\n\tpos.x -= font_spacing*caret.x;\n\treturn pos;\n}\nvec2 rFull()\n{\n\tvec2 pos = coord.xy/iResolution.xy;\n\t\n    \n    pos -= vec2(0.5);\n    // rotate the space\n    pos = rotate2d( -PI / 5. ) * pos;\n    // move it back to the original place\n    pos += vec2(0.5);\n    \n    pos.y -= caret.y;\n\tpos.x -= font_spacing*caret.x;\n    \n    pos.y += 0.01;\n    pos.x -= 0.01;\n    \n\treturn pos;\n}\nvec2 rHalf()\n{\n\tvec2 pos = coord.xy/iResolution.xy;\n\t\n    \n    pos -= vec2(0.5);\n    // rotate the space\n    pos = rotate2d( PI / 5. ) * pos;\n    // move it back to the original place\n    pos += vec2(0.5);\n    \n    pos.y -= caret.y;\n\tpos.x -= font_spacing*caret.x;\n    \n    pos.y -= 0.01;\n    pos.x -= 0.01;\n    \n\treturn pos;\n}\nvec2 rStop()\n{\n\tvec2 pos = coord.xy/iResolution.xy;\n    pos.y -= caret.y;\n\tpos.x -= font_spacing*caret.x;\n\treturn pos;\n}\nvec2 rHalf1()\n{\n\tvec2 pos = coord.xy/iResolution.xy;\n\t\n    \n    pos -= vec2(0.5);\n    // rotate the space\n    pos = rotate2d( -PI / 5. ) * pos;\n    // move it back to the original place\n    pos += vec2(0.5);\n    \n    pos.y -= caret.y;\n\tpos.x -= font_spacing*caret.x;\n    \n    pos.x += 0.55;\n    \n\treturn pos;\n}\nvec2 rFull1()\n{\n\tvec2 pos = coord.xy/iResolution.xy;\n\t\n    \n    pos -= vec2(0.5);\n    // rotate the space\n    pos = rotate2d( PI / 5. ) * pos;\n    // move it back to the original place\n    pos += vec2(0.5);\n    \n    pos.y -= caret.y;\n\tpos.x -= font_spacing*caret.x;\n    \n    pos.x += 0.55;\n    \n\treturn pos;\n}\n\n//-----------------------------------------------------------------------------------\nvoid add()\n{\n\tcaret.x += 1.7;\n}\n\n//-----------------------------------------------------------------------------------\nvoid space()\n{\n\tcaret.x += 1.5;\n}\n\n//-----------------------------------------------------------------------------------\nvoid newline()\n{\n\tcaret.x = caret_origin.x;\n\tcaret.y -= .18;\n}\n\n//-----------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat d = 0.;\n\tvec3 col = vec3(0.0, 0.0, 0.0);\n    \n    coord = fragCoord;\n\t\n    // SLOW\n\t//caret = caret_origin;\n\t//d += S(rSlow()); add(); d += L(rSlow()); add(); d += O(rSlow()); add(); d += W(rSlow());\n    // FULL\n    caret = caret_origin;\n    d += F(rFull()); add(); d += U(rFull()); add(); d += L(rFull()); add(); d += L(rFull());\n    // HALF\n    caret = caret_origin;\n    d += H(rHalf()); add(); d += A(rHalf()); add(); d += L(rHalf()); add(); d += F(rHalf());\n    // STOP\n    caret = caret_origin;\n    caret.x -= 5.0;\n    caret.y += 0.38;\n    d += S(rStop()); add(); d += T(rStop()); add(); d += O(rStop()); add(); d += P(rStop());\n    // HALF\n    caret = caret_origin;\n    d += H(rHalf1()); add(); d += A(rHalf1()); add(); d += L(rHalf1()); add(); d += F(rHalf1());\n    // FULL\n    caret = caret_origin;\n    d += F(rFull1()); add(); d += U(rFull1()); add(); d += L(rFull1()); add(); d += L(rFull1());\n      \n    col += vec3(d);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    uv = 2.0 * uv - vec2(1.0);\n    col *= 1.0 - step(1.0, length(uv));\n    if (col.r > 0.0)\n    {\n        if (uv.x > 0.0 || (uv.x > -0.4 && uv.y > 0.5))\n        {\n        \tcol = vec3(1.0, 0.0, 0.0);\n        }\n        else\n        {\n            col = vec3(1.0);\n        }\n    }\n\n    //if((step(0.0, uv.y + 0.01) - step(0.0, uv.y - 0.01)) > 0.1)\n    //{\n    //    col = vec3(1.0);\n    //}\n    if (length(uv) < 0.15 && length(uv) > 0.12)\n    {\n        col = vec3(1.0);\n    }\n    if (abs(uv.x) < 0.015 && abs(uv.y) > 0.15 && abs(uv.y) < 0.28)\n    {\n        col = vec3(1.0);\n    }\n        if (abs(uv.y) < 0.015 && abs(uv.x) > 0.15 && abs(uv.x) < 0.37)\n    {\n        col = vec3(1.0);\n    }\n    if(abs(uv.x) > 0.36 || abs(uv.y) > 0.28)\n    {\n    \tif ((step((uv.x/1.3)-0.015, uv.y-.28) - step((uv.x/1.3)+0.015, uv.y-.28)) > 0.5)\n    \t{\n    \t    col = vec3(1.0);\n    \t}\n    \tif ((step((uv.x/1.3)-0.015, uv.y+.28) - step((uv.x/1.3)+0.015, uv.y+.28)) > 0.5)\n    \t{\n    \t    col = vec3(1.0);\n    \t}\n    \tif ((step((-uv.x/1.3)-0.015, uv.y-.28) - step((-uv.x/1.3)+0.015, uv.y-.28)) > 0.5)\n    \t{\n    \t    col = vec3(1.0);\n    \t}\n    \tif ((step((-uv.x/1.3)-0.015, uv.y+.28) - step((-uv.x/1.3)+0.015, uv.y+.28)) > 0.5)\n    \t{\n    \t    col = vec3(1.0);\n    \t}\n    }\n    \n    fragColor = vec4( col, 1.0 );\n}\n","name":"Buffer D","description":"","type":"buffer"}]}