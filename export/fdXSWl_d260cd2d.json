{"ver":"0.1","info":{"id":"fdXSWl","date":"1619444703","viewed":68,"name":"The Deathstar of Menger","username":"oo_miguel","description":"My first Menger based shader","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["procedural","fractal","menger"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCross( in vec3 p )\n{\n  float da = sdBox(p.xyz,vec3(99.,1.0,1.0));\n  float db = sdBox(p.yzx,vec3(1.0,99.,1.0));\n  float dc = sdBox(p.zxy,vec3(1.0,1.0,99.));\n  return min(da,min(db,dc));\n}\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n                \n}\n\nfloat map( in vec3 p )\n{\n   mat3 rot_obj=rotationMatrix(vec3(0,0,1),0.2*iTime);\n   mat3 rot_obj2=rotationMatrix(vec3(1,0,0),0.1*iTime);\n   p*=rot_obj*rot_obj2;\n\n   float glow4=mod((iTime+2.),8.)-3.;\n   float glow5=mod((iTime+4.),8.)-3.;\n   float glow6=mod((iTime+6.),8.)-3.;\n   \n   p-=vec3(0,0,0); \n   //float d = sdBox(p,vec3(1.0));\n   float d = sdSphere(p,1.2);\n   \n   if(p.y>-0.8)\n   if(p.y+0.7>glow6&&p.y-0.7<glow6){\n        float falloff = 1. - abs(glow6-p.y)/0.7;\n        //d-=falloff*falloff*0.2;\n        if(p.y>0.)d-=falloff*p.y*0.4;\n        \n    }\n    \n   float s = 1.;\n   for( int m=0; m<5; m++ )\n   {\n      vec3 a = mod( p*s, 2.0 )-1.0;\n      s *= 3.;\n      vec3 r = 1.0 - 3.0*abs(a);\n      float c = sdCross(r)/s;\n      if(p.y>-0.8)\n      if(p.y+0.7>glow4&&p.y-0.7<glow4){\n        float falloff = 1. - abs(glow4-p.y)/0.7;\n        if(m==1)c+=falloff/10.;\n       }\n\n      d = max(d,c);\n   }\n   \n\n   if(p.y>-0.8)\n   if(p.y+0.7>glow5&&p.y-0.7<glow5){\n        float falloff = 1. - abs(glow5-p.y)/0.7;\n        d+=falloff/200.;\n    }\n    \n   return d;\n}\n\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n    int st=0;\n    for(float t=0.0; t<10.0; )\n    {\n        st++;\n        float h = map(ro + rd*t);\n        if( h<0.0002  ) return t;\n        t += h; //min(h,1.);\n        //if(st==100)break;\n    }\n    return -1.;\n}\n\nvec3 normal(vec3 p){\n\tfloat d = map(p);\n    vec2  e = vec2(.0001, 0);\n    vec3  n = d - vec3(map(p-e.xyy),map(p-e.yxy),map(p-e.yyx));\n    return normalize(n);\n}\n\n\nfloat light(vec3 p, vec3 light_pos) {\n    vec3 light_dir = normalize(light_pos-p);\n    vec3 n = normal(p);\n    vec3 l = normalize(light_pos-p);\n    float scene=mod(iTime,20.0);\n    if(scene>6.&&scene<12.){\n    return clamp(dot(n, l), 0.1, 1.);\n    }\n    if(intersect(p+n*0.0003, light_dir)>0.)return (0.2*clamp(dot(n, l), 0., 1.));\n    return clamp(dot(n, l), 0.1, 1.);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 ro;\n    float l;\n    float scene=mod(iTime,20.0);\n    if(scene>6.&&scene<12.){\n     \n        ro = vec3(-0.3,0.1,0.3);\n    }\n    else{\n        ro = vec3(-3.3  ,1,1.5);\n    \n    }\n    \n    mat3 rot_cam=rotationMatrix(vec3(0,1,0),2.);\n    mat3 rot_cam2=rotationMatrix(vec3(0,0,1),-0.25);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.))*rot_cam*rot_cam2;\n    \n    float d = intersect(ro, rd);\n    if(d<0.){\n        fragColor=vec4(vec3(0.04,0.,0.06),1.); \n        return;\n    }\n    vec3  p = ro + rd * d;\n    \n    if(scene>6.&&scene<12.){\n        l=light(p, vec3(-0.2,0.2,0.2));    \n    }\n    else{\n         l=light(p, vec3(-3,-2,0));\n    }\n    \n    \n    \n    float glow=mod(iTime,4.)-2.;\n    float glow2=mod(0.5*iTime,2.)+2.;\n    float glow3=mod(iTime,1.)-1.;\n    \n    mat3 rot_obj=rotationMatrix(vec3(0,0,1),0.2*iTime);\n    mat3 rot_obj2=rotationMatrix(vec3(1,0,0),0.1*iTime);\n    vec3 pp=p*rot_obj*rot_obj2;\n    float c=floor(1.+(pp.y+1.)*2.)/7.;\n   \n    fragColor=vec4(vec3(l*.7,l*c,l*.2),1.);\n    if(p.y+0.03>glow-1.&&p.y-0.03<glow-1.)fragColor+=vec4(0.2,0,0,0);\n    if(p.y+0.03>glow+1.&&p.y-0.03<glow+1.)fragColor+=vec4(0.2,0,0,0);\n    if(p.z+0.03>glow+2.&&p.z-0.03<glow+2.)fragColor+=vec4(0,0.2,0,0);\n    if(p.x+0.03>glow3&&p.x-0.03<glow3)fragColor+=vec4(0.,0.,0.0,0.9);\n    if(d+0.005>glow2&&d-0.005<glow2)fragColor+=vec4(0.6,0.6,0,0);\n    //fragColor=vec4(vec3(l,l,l),1.);\n}","name":"Image","description":"","type":"image"}]}