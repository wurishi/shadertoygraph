{"ver":"0.1","info":{"id":"MfGyzc","date":"1732185087","viewed":31,"name":"mindscape","username":"hazelwu","description":"less psychedelic, with cool sound effects","likes":0,"published":1,"flags":8,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"4cyyR3","parentname":"panicking"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PHI = 1.61803398874989484820459; // the golden ratio\n\nfloat circle(vec2 r, vec2 center, float radius) {\n\treturn 1. - smoothstep(radius - 0.2, radius + 0.2, length(r - center));\n}\n\n//float noise(in vec2 r) {\n//    return 0.5 + 0.5 * cos(cos(r.x * r.x) + cos(r.y * r.y) + iTime);\n//}\n\nfloat hash(vec2 p){\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0 + 2.0*fract( p.x*p.y*(p.x+p.y) );\n}\nfloat noise( in vec2 p ){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat noise(in float r) {\n    return noise(vec2(r + iTime));\n}\n\n// fractional brownian motion\nfloat fbm(in vec2 xy) {\n\tfloat val = 0.0;\n    val += 0.50000*noise(xy); xy *= 2.0;\n\tval += 0.25000*noise(xy); xy *= 2.0;\n\tval += 0.12500*noise(xy); xy *= 2.0;\n\tval += 0.06250*noise(xy); xy *= 2.0;\n\tval += 0.03125*noise(xy); xy *= 2.0;\n    return val;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 r = 2.0 * vec2(fragCoord.xy - 0.5 * iResolution.xy) / iResolution.xy;\n    \n    float color = fbm(vec2(abs(r.x), abs(r.y)) + vec2(iTime / 5.0));\n    float symmetric = abs(r.x * r.y);\n    \n    if (iTime < 5.0) {\n        symmetric += iTime;\n    } else if (iTime < 20.0) {\n        symmetric += iTime / 6.0;\n    } else {\n        symmetric += iTime / 20.0;\n    }\n    \n    color = mix(color, noise(symmetric), 0.2 * circle(vec2(noise(symmetric)), r * vec2(1.0, 1.0), 0.3));    \n    color = mix(color, noise(symmetric), 0.2 * circle(vec2(noise(symmetric)), r * vec2(1.0, -1.0), 0.3));\n    color = mix(color, noise(symmetric), 0.2 * circle(vec2(noise(symmetric)), r * vec2(-1.0, 1.0), 0.3));\n    color = mix(color, noise(symmetric), 0.2 * circle(vec2(noise(symmetric)), r * vec2(-1.0, -1.0), 0.3));\n    \n    fragColor = vec4(0.0, 0.05, color + 0.08, 0.5);\n    \n    if (color > 0.2) {\n    \n        float colorRange = 255.0 * 255.0 * 255.0 * color;\n\n        float R = (colorRange / 255.0 / 255.0) / 255.0;\n        float G = mod((colorRange / 255.0), 255.0) / 255.0;\n        float B = mod(colorRange, 255.0) / 255.0;\n\n        vec3 rgb = vec3(PHI * R, min(G, 0.2), min(B, 0.3));\n\n        fragColor = vec4(rgb, 0.2);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PHI = 1.61803398874989484820459; // the golden ratio\n\nfloat noise(in vec2 xy) {\n    return fract(tan(distance(xy * PHI, xy)) * (xy.x * xy.x + xy.y * xy.y));\n}\n\nvec2 mainSound( int samp, float time ) {\n   \n    if (time <= 5.0) {\n        return vec2(noise(vec2(iSampleRate*fract(time))));\n    } else if (time < 20.0) {\n        return vec2(noise(vec2(iSampleRate*fract(time / 6.0))));\n    } else {\n        return vec2(noise(vec2(iSampleRate*fract(time / 20.0))));\n    }\n\n}","name":"Sound","description":"","type":"sound"}]}