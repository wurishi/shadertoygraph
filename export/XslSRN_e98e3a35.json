{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"webcam","id":"4sf3zn","filepath":"/presets/webcam.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Cartesian equation in form of coefficients\n// ax + by + cz + d = 0\n// so normal vector and a displacement coefficient along that vector\n\nvec3 frustum;\n\nvec3 intersec;\nvec3 normIntersec;\nfloat t;\nvec3 tempIntersec;\nvec3 tempNormIntersec;\nfloat tempt;\n\n\n/* INTERSECTION BETWEEN A PLANE AND A RAY\n\n(P) : normal vector n = (nx, ny, nz), displacement Pd -> nx*x + ny*y + nz*z + Pd = 0\n(C) : directional vector u = (ux, uy, uz), passes by point C(Cx, Cy, Cz)\n    _\n-> /  x = Cx + ux * t\n  <|  y = Cy + uy * t\n   \\_ z = Cz + uz * t\n\n(P)âˆ©(C) is the intersection between the camera ray and the plane, i.e\nthe point that belongs to both of them.\nThat means :\n\nnx*x + ny*y + nz*z + Pd = 0\n\nx, y and z are the ray's definitions of x, y and z. So we replace them to get t (the\nray's parameter) :\n\n-> nx * (ux * t + Cx) + ny * (uy * t + Cy) + nz * (uz * t + Cz) + Pd = 0\n-> nx * ux * t + nx * Cx + ny * uy * t + ny * Cy + nz * uz * t + nz * Cz = -Pd\n-> nx * ux * t + ny * uy * t + nz * uz * t = -Pd - nx * Cx - ny * Cy - nz * Cz\n-> t * dot(n, u) = -Pd - dot(n, C)\n->\n      -Pd - dot(n, C)\n  t = ---------------\n\t\t dot(n, u)\n\nNow that we know t, we just replace it in the ray's definition :\n-> intersec = (Cabc) * t + (Cxyz)\n*/\nbool intersecPlane(in vec4 plane, in vec3 rayDir, in vec3 rayOrigin)\n{\n\tif(dot(rayDir, plane.xyz) != 0.)\n\t{\n\t\t// the ray hits, now to find where\n\t\tfloat param = (-plane.w - dot(plane.xyz, rayOrigin)) / dot(plane.xyz, rayDir);\n\t\tif(param > 0.)\n\t\t{\n\t\t\ttempt = param;\n\t\t\ttempIntersec = rayDir * tempt + rayOrigin;\n\t\t\ttempNormIntersec = plane.xyz;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n/* INTERSECTION BETWEEN A SPHERE AND A RAY\n\n(S) : center S(Sx, Sy, Sz), radius Sr : (x-Sx)^2 + (y-Sy)^2 + (z-Sz)^2 = Sr^2\n(C) : directional vector u = (ux, uy, uz), passes by point C(Cx, Cy, Cz)\n\n(S)âˆ©(C) is not the intersection between the sphere and the ray, it's actually BOTH intersections.\nSince a ray is infinite and a sphere is finite, a ray will traverse a sphere, thus having 2\nintersections points : the point where the ray enters the sphere, and the point where it exits the\nsphere. As for (P)âˆ©(C), we will search for t, but this time it will be a second degree polynomial.\nSince we only want the closest point to the camera, we only take the smallest root, as long as it\nremains positive (we don't want to display things if they are behind the camera). Here, we assume\nthat the camera can't be inside the sphere so that we only have to test one root.\n\nD = C - S = D(Cx - Sx, Cy - Sy, Cz - Sz) = D(Dx, Dy, Dz)\n\n(S)âˆ©(C) : (ux*t + Dx)^2 + (uy*t + Dy)^2 + (uz*t + Dz)^2 = Sr^2\n-> ux^2 * t^2 + 2*ux*t*Dx + Dx^2 + uy^2 * t^2 + 2*uy*t*Dy + Dy^2 + uz^2 * t^2 + 2*uz*t*Dz + Dz^2 = Sr^2\n-> t^2 (ux^2 + uy^2 + uz^2) + 2t(ux*Dx + uy*Dy + uz*Dz) + Dx^2 + Dy^2 + Dz^2 = Sr^2\n-> t^2 * dot(u, u) + 2 * t * dot(u, D) + dot(D, D) - Sr^2 = 0\n-> at^2 + bt + c = 0\na = dot(u,u)\nb = 2 * dot(u, D)\nC = dot(D, D) - Sr^2\n\nHere we just have to resolve a common second degree polynomial.\n\ndelta = b^2 - 4 * a * c\nIf negative : no solution, ie no intersection at all\nIf zero : one solution, the ray is tangent to the sphere - but that's still an intersection\nIf positive : two intersections, the ray goes through the sphere, so take the closest point\n-> t = (-b - sqrt(delta)) / (2 * a)\n\nIf negative, intersection is behind the camera, so discard.\nNow that we got t, solve the equation :\n\nintersec = camDir * t + camPos\n\n------\n\nYou are most likely to see only b, c and d and not a, like in iq's functions for example. That is because\nu (rayDir in my function) is assumed to be normalized, so that the square of it is 1.\n*/\n\nbool intersecSphere (in vec4 sphere,in vec3 rayDir,in vec3 rayOrigin) {\n\tvec3 delta = rayOrigin - sphere.xyz;\n\tfloat a = dot(rayDir, rayDir);\n\tfloat b = dot(rayDir, delta) * 2.;\n\tfloat c = dot(delta, delta) - sphere.w * sphere.w;\n\tfloat d = b*b - 4.*a*c;\n\tif(d > 0.)\n\t{\n\t\tfloat param = (-b - sqrt(d)) / (a * 2.);\n\t\tif(param > 0.)\n\t\t{\n\t\t\ttempt = param;\n\t\t\ttempIntersec = rayDir * param + rayOrigin;\n\t\t\ttempNormIntersec = normalize(tempIntersec - sphere.xyz);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    frustum = vec3(1., iResolution.y / iResolution.x, 1.);\n\t// Define objects to be raytraced\n\tvec4 gplane = vec4(0., 1., 0., 2.);\n\tvec4 suchSphere = vec4(cos(iTime) * 2., sin(iTime) + 1., cos(iTime) * 10. + 10., 1.);\n\t\n\t// Final color\n\tfloat shade;\n\t\n\t// 2D coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\t// Camera position\n\tvec3 camPos = vec3(0., 1., 0.); // vec3(sin(iTime) * 5.,cos(iTime) * 2. + 1., cos(iTime) * 5.);\n\tvec3 camDir = vec3(uv, 1.) * 2. - 1.;\n\tcamDir = normalize(camDir * frustum);\n\tvec4 light = vec4(0., 10., 10., 30);\n\tbool hasHitAnything = false;\n\tbool hasHitPlane = false; // dissociate plane and sphere\n\t\n\t// Check if the ray hits the sphere, and where\n\tif(intersecSphere(suchSphere, camDir, camPos))\n\t{\n\t\thasHitAnything = true;\n\t\tintersec = tempIntersec;\n\t\tnormIntersec = tempNormIntersec;\n\t\tt = tempt;\n\t}\n\t\n\t// check if the ray hits the plane, and where\n\t\n\tif(intersecPlane(gplane, camDir, camPos))\n\t{\n\t\tif(!hasHitAnything || tempt < t)\n\t\t{\n\t\t\thasHitPlane = true;\n\t\t\thasHitAnything = true;\n\t\t\tintersec = tempIntersec;\n\t\t\tnormIntersec = tempNormIntersec;\n\t\t\tt = tempt;\n\t\t}\n\t}\n\t\n\tif(hasHitAnything)\n\t{\n\t\tvec3 lightTranspose = light.xyz - intersec;\n\t\t\n\t\tif(dot(lightTranspose, lightTranspose) > light.w * light.w)\n\t\t\tshade = 0.;\n\t\telse\n\t\t{\n\t\t\t// Currently in the process of understanding this formula\n\t\t\tshade = dot(normIntersec, normalize(lightTranspose)) * (1. - length(lightTranspose) / light.w);\n\t\t\t\n\t\t\tif(intersecSphere(suchSphere, normalize(light.xyz - intersec), intersec))\n\t\t\t\t// dumb projection on the plane, only correct if the latter is horizontal\n\t\t\t\t// I need an orthogonal projection of a point on a plane using the plane's normal\n\t\t\t\t// but can't think of a way to get it\n\t\t\t\t// theorically, let I be the orth. proj. of the intersection and S the orth. proj.\n\t\t\t\t// of the sphere's center, both on the plane :\n\t\t\t\t// shade *= distance(I, S) / sphere.w;\n\t\t\t\tshade *= distance(tempIntersec.xz, suchSphere.xz) / suchSphere.w;\n\t\t\tfragColor = vec4(shade, shade, shade, 1.);\n\t\t}\n\t}\n\telse\n\t\tfragColor = vec4(0., 0., abs(uv.y - .25), 1.);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":true,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XslSRN","date":"1398440982","viewed":459,"name":"Raytracing tutorial","username":"matrefeytontias","description":"Work-in-progress. Also has verbose demonstrations of formulas used.","likes":2,"published":1,"flags":2,"usePreview":0,"tags":["3d","raytracing","tutorial","demonstration"],"hasliked":0,"parentid":"","parentname":""}}