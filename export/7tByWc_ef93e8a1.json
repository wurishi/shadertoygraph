{"ver":"0.1","info":{"id":"7tByWc","date":"1650315932","viewed":36,"name":"ray marching for the first time","username":"turnipGod","description":"playing around with ray marching tutorials","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sphere_sdf(vec3 sphere_pos, float sphere_radius, vec3 p);\nfloat sceneSDF(vec3 p);\nvec3 estimateNormal(vec3 p);\n\nvoid\nmainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //calculate ray direction\n    vec2 p = (2.0*(fragCoord + 0.5)-iResolution.xy)/ iResolution.y;\n    vec3 ray_dir = normalize(vec3(p, -1.0));\n\n    // colors\n    vec3 bg_col = vec3(0.3, 0.5, 0.6);\n    vec3 sphere_col = vec3(0.882, 0.901, 0.717);\n    \n    //light dir\n    vec3 light_pos = vec3(5.0 * sin(iTime * 1.5), 1.0, 1.0);\n    \n    //march ray_pos from origin, outwards and along ray_dir.\n    // each step will be the size of the calculated distance.\n    //Find out how close the ray ever got to the sphere (min_dist).\n    const int MAX_STEP = 255;\n    float min_dist = 1000.0;\n    vec3  intersection;\n    vec3 ray_pos = vec3(0.0);\n    float current_dist;\n    for (int i = 0; i < MAX_STEP; i++) {\n        current_dist = sceneSDF(ray_pos);\n        if (current_dist < min_dist) {\n            min_dist = current_dist;\n            intersection = ray_pos;\n        }\n        ray_pos = ray_pos + (ray_dir * current_dist);\n    }\n    \n    // If the minimum distance was so close to the object that we consider it intersected, then color the point as a sphere\n    vec3 col;\n    const float INTERSECT = 0.01;\n    float illumination;\n    if (min_dist < INTERSECT) {\n        vec3 normal = estimateNormal(intersection);\n        vec3 light_dir = normalize(light_pos - intersection);\n        vec3 R = normalize(2.0 * dot(light_dir, normal) * normal - light_dir);\n        vec3 V = normalize(-intersection);\n        illumination = 0.4 * dot(estimateNormal(intersection), light_dir) + 0.4 * max(0.0, pow(dot(R, V), 10.0)) + 0.5;\n        col = sphere_col * illumination;\n    } else {\n        col = bg_col;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n\n// Sphere Signed Distance Function\n// calculates the distance between point p, and a given sphere.\nfloat\nsphere_sdf(vec3 sphere_pos, float sphere_radius, vec3 p)\n{\n    return length(sphere_pos - p) - sphere_radius;\n}\n\n//run through all SDF's for the scene. In this case, it's just one sphere.\nfloat\nsceneSDF(vec3 p)\n{\n    //sphere params\n    vec3 sphere_pos = vec3(0.0, 0.0, -3.0);\n    float sphere_radius = 1.0;\n    \n    return sphere_sdf(sphere_pos, sphere_radius, p);\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3\nestimateNormal(vec3 p)\n{\n    const float EPSILON = 0.0001;\n    \n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}","name":"Image","description":"","type":"image"}]}