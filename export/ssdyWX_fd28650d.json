{"ver":"0.1","info":{"id":"ssdyWX","date":"1654283259","viewed":95,"name":"character 1 toon shading","username":"brando23","description":"crying","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","sdf","animation"],"hasliked":0,"parentid":"sd3czS","parentname":"Character 1 "},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.1415926535897932385\n#define TERRAIN 1\n#define FIRE 2\n#define LAM 3\n#define EYE 4\n#define EPSILON 1e-4\n\n\nstruct material{\n    vec3 color;\n    int type;\n};\nstruct camera{\n\n    vec3 origin;\n    vec3 w;\n    vec3 u;\n    vec3 v;\n\n};\n\n\nstruct ray {\n    vec3 ori;\n    vec3 dir;\n};\n\n\nray getray(camera cam, vec2 uv){\n\n    return ray(cam.origin,normalize(uv.x * cam.u + uv.y * cam.v + 1.5*cam.w));\n   \n\n}\nvec3 rayAt(ray r, float t){\n    return r.ori + t*r.dir;\n}\n\nfloat model(in vec3 pos){\n\n    vec3 h = pos - vec3(.1 ,.9 +  .01*sin(iTime),1.2 -.01*cos(iTime) );\n\n    float head = sdSphere(h, .45);\n    float littleFlame = sdCone(pos - vec3(.1 + .08 * sin(iTime * 3.),1.45,1.3 - .15 * cos(iTime * 3.)), vec2(1.0,.4), .3);\n    float littleFlame2 = sdCone(pos - vec3(.1 + .08 * -sin(iTime * 3.),1.45,1.3 - .15 * -cos(iTime * 3.)), vec2(1.0,.4), .3);\n    float littleFlame3 = sdCone(pos - vec3(.1 + .05 * sin(iTime * 4.),1.5,1.3 - .1 * cos(iTime * 4.)), vec2(1.0,.4), .5);\n    \n    \n    head = opSmoothUnion(head,littleFlame,.13);\n    head = opSmoothUnion(head,littleFlame2,.13);\n    head = opSmoothUnion(head,littleFlame3,.1);\n    \n    \n    \n    \n    float t1 = sdSphere(pos - vec3(0.1 ,0.8,.8 ), 0.03);\n    float t2 = sdSphere(pos - vec3(0.0,0.8,0.0), 0.03);\n    float t3 = sdSphere(pos - vec3(-0.1,0.8,-1.), 0.03);\n    \n    \n    float l1 = sdSphere(pos - vec3(-0.7 ,-.2,-.9 ), 0.1);\n    float l2 = sdSphere(pos - vec3(0.7,-.2,-.9), 0.15);\n    float l3 = sdSphere(pos - vec3(-0.7,-.2,.8), 0.16);\n    float l4 = sdSphere(pos - vec3(0.7,-.2,.8), 0.13);\n    \n    \n    float torso = opSmoothUnion(t1, t2, 2.5);\n    torso = opSmoothUnion(torso, t3, 2.5);\n    \n    torso = opSmoothUnion(head,torso,.2);\n    \n    \n    float tail = sdSphere(pos - vec3(.1,1.,-1.2), .05);\n    float tail2 = sdSphere(pos - vec3(.1,1.2,-1.5), .03);\n    float tail3 = sdSphere(pos - vec3(.1,1.4,-1.8), .03);\n    \n    float tail4 = sdSphere(pos - vec3(.1,1.6,-2.), .01) ;\n    \n    tail = opSmoothUnion(tail,tail2,.6);\n    tail = opSmoothUnion(tail,tail3,.5);\n    tail = opSmoothUnion(tail,tail4,.2) ;\n    \n    \n    tail = opRound(tail,0.1);\n\n    \n    torso = opSmoothUnion(tail,torso,.15);\n    \n    float d = opSmoothUnion(torso, l1, 1.);\n    d = opSmoothUnion(d, l2, 1.);\n    d = opSmoothUnion(d, l3, 1.);\n    d = opSmoothUnion(d, l4, 1.);\n    return d;\n\n}\n\n\nfloat terrain(in vec3 pos){\n    float flr_h = sin(.3 *pos.x) +  cos(pos.z *.5) - .3;\n    \n    return pos.y + flr_h;\n\n\n}\n\nfloat map( in vec3 pos, out material mat ){\n    float flr = terrain(pos);\n    \n    float creature = model(pos) - sin(iTime)*.004;\n    \n    mat.type = FIRE;\n  \n    \n    float eye1 = sdSphere(pos - vec3(.3,.9,1.6) , .05);\n    float eye2 = sdSphere(pos - vec3(-.1,.9,1.6) , .05);\n    \n    \n    \n    vec3 current = pos - vec3(.1,1.8,-2.1);\n    if (current.y > .1){\n        current.y *= .5 * cos(iTime * 4.);\n        current.y = clamp(current.y, .065,1.);\n    }\n    float tail = sdSphere(current , .05);\n    creature = opSmoothUnion(creature, tail, .99);\n    \n\n  \n    float m = min(flr,creature);\n    m = min(m, eye1);\n    m = min(m, eye2);\n    m = min(m, tail);\n\n    \n    \n    if (m == flr) mat.type = TERRAIN;\n    if (m == eye1 || m == eye2){\n        mat.type = EYE;\n        return m;\n    }\n    \n        \n    return m;\n    \n\n}\n\nvec3 calcNormal(in vec3 pos ){\n    material m;\n    vec3 x = vec3(EPSILON,0.0,0.0);\n    vec3 y = vec3(0.0,EPSILON,0.0);\n    vec3 z = vec3(0.0,0.0,EPSILON);\n    return normalize(vec3(map(pos + x,m ) - map(pos-x, m), \n                          map(pos + y,m) - map(pos-y,m ),\n                          map(pos + z,m ) - map(pos-z, m)));\n    \n    \n\n}\n\n\n\n\n\n\nfloat castRay(in ray r, out material m){\n\n    float t = 0.0;\n   \n    for (int i = 0; i < 150; i ++){\n        vec3 pos = rayAt(r, t);\n        float h = map(pos, m);\n        \n        if (h < EPSILON) return t;\n        \n        t +=h;\n        \n        //past max distance\n        if (t > 20.0) {\n            t = 0.0;\n            return t;\n        }\n\n        \n    }\n\n\n    return t;\n}\n\n\ncamera makeCam(vec3 lookfrom, vec3 lookat, vec3 vup){\n    camera cam;\n    cam.origin = lookfrom;\n    cam.w = normalize(lookat - lookfrom);\n    cam.u = normalize(cross(cam.w, vup));\n    cam.v = normalize(cross(cam.u,cam.w));\n    return cam;\n}\n\n\n\nvec3 computerColor(float t, inout vec3 col, material m, in vec3 pos, vec2 uv){\n  \n    vec3 nor = calcNormal(pos);\n    vec3 Lpos = vec3(0.8 ,0.4,1.2);\n    vec3 l = normalize(Lpos);\n\n    float intensity = max(0.0,dot(l,nor))/.23;\n   \n    if (t > 0.0){\n        if (m.type == FIRE){\n\n        float base =1.0 - uv.y * .9;\n        float up1 = snoise(uv * 3.0 + vec2(0.,-iTime * 2.0)) ;\n        float up2 = 2.8 + snoise(uv * 6.0 + vec2(0.,-iTime)) ;\n\n        vec3 col1 = up1 * vec3(1.0,0.,0.0);\n        vec3 col2 = up2 * vec3(1.0,.6,0.);\n        \n        col = mix(col1,col2, base);\n        col *= vec3(1.0,0.,0.) * col + (vec3(1.) - col) ;\n        col *= intensity * l ;\n     \n\n         \n       \n        }\n        else if (m.type == TERRAIN){\n            col =vec3(0.,1.,0.);\n            //float f = .4 + smoothstep(-.1,.1, sin(4. * pos.x) * cos(pos.z * 8.));\n            //col *= f * 1.2;\n            col *= intensity * l ;\n        }\n        //black eyes\n        else if (m.type == EYE){\n            col = vec3(0.0);\n        }\n\n\n        \n      \n\n\n    }\n    \n   \n    \n    \n    return col;\n\n\n\n\n\n\n\n}\n\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    vec2 uv = (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n    \n    float an = 10.0 * iMouse.x/iResolution.x;\n    vec3 lookfrom = vec3(4.0 * sin(an), 1,4.0*cos(an));\n    vec3 lookat = vec3(0.0, 0.9,0.);\n    vec3 vup = vec3(0,1,0);\n    \n\n    \n    camera cam = makeCam(lookfrom, lookat, vup); \n\n    \n    //default sky box color \n    vec3 col = vec3(fractal_sum(uv + vec2(iTime * .3,0.0), 8.));\n    col *=vec3(0.5, 0.8, 0.9);\n    col = mix(vec3(0.0,1.0,1.0), vec3(0.0,0.,1.), col);\n\n    material m;\n\n    ray r = getray(cam, uv);\n    float t = castRay(r, m);\n    vec3 pos = lookfrom + t*r.dir;\n\n    col = computerColor(t, col, m, pos, uv);\n\n\n\n    col = pow(col,vec3(1.0/2.4));\n    fragColor = vec4(col, 1.);\n\n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\n\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n   \n  //length of vector to p without y direction\n  float dist = length(p.xz);\n  \n  \n  return max(dot(c,vec2(dist,p.y)),-h-p.y);\n}\n\n\n\nfloat sdSphere(vec3 p, float r)\n{\n \treturn length(p) - r;\n}\n\n\nfloat opRound(float d, float iso)\n{\n    // TODO\n    return d - iso;\n}\n\nfloat opSmoothUnion(float d1, float d2, float k)\n{\n    // TODO\n    float h = max(k - abs(d1-d2),0.0);\n    return min(d1,d2) - (h*h)/( 4.0* k); \n}\n\n\n// Copyright Â© 2022 Wojciech Jarosz\n// Based off of Andrew Kensler's blog: http://eastfarthing.com/blog/2015-04-21-noise/\n\n\n// map fragment coordinates to world coordinates\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\nfloat falloff(float t)\n{\n    float t2 = clamp(0.0, 1.0, abs(t));\n\n    return 1.0 - smoothstep(0.0, 1.0, t2);\n}\n\nvec2 grad(vec2 center)\n{\n    // 1D random angle\n    float angle = radians(360.*hash12(center));\n    \n    vec2 g = vec2(cos(angle), sin(angle));\n    //vec2 g = vec2(frag2World(iMouse.xy) - center);\n    return g;\n}\n\nfloat bump(vec2 p, vec2 center)\n{\n    vec2 offset = p - center;\n    \n    float b = falloff(offset.x) * falloff(offset.y);\n    \n    float v = 2.*hash12(center) - 1.;\n    return v * b;\n}\n\n\n// signed noise\n// return value in [-1,1]\nfloat snoise(vec2 p)\n{\n    float result = 0.;\n    \n    vec2 ll = floor(p);\n    \n    result += bump(p, ll + vec2(0., 0.0));\n    result += bump(p, ll + vec2(1., 0.0));\n    result += bump(p, ll + vec2(1., 1.0));\n    result += bump(p, ll + vec2(0., 1.0));\n    return result;\n}\n\nfloat fractal_sum(vec2 p, float octaves){\n\n    float v = 0.0;\n    float w = 1.0;\n    \n    for (float i = 0.; i < octaves; ++i, p *=3., w *=.25)\n        v += w * snoise(p);\n\n    return v;\n}\n\n\n\n\n","name":"Common","description":"","type":"common"}]}