{"ver":"0.1","info":{"id":"ddBcWW","date":"1687704844","viewed":71,"name":"Toil","username":"Oxys","description":"Time based perlin noise on grid.\nAnti aliasing based on code from GregRostami & FabriceNeyret2 (Thank you :) )","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["noise","grid","perlin","bnw"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\tClassic Perlin 2D Noise\n//\tby Stefan Gustavson\n//\nvec2 fade(vec2 t){return t*t*t*(t*(t*6.-15.)+10.);}\n\nvec4 permute(vec4 x,float seed){\n    return mod(((x*34.)+1.+seed)*x,289.);\n}\n\nfloat cnoise(vec2 P,float seed){\n    vec4 Pi=floor(P.xyxy)+vec4(0.,0.,1.,1.);\n    vec4 Pf=fract(P.xyxy)-vec4(0.,0.,1.,1.);\n    Pi=mod(Pi,289.);// To avoid truncation effects in permutation\n    vec4 ix=Pi.xzxz;\n    vec4 iy=Pi.yyww;\n    vec4 fx=Pf.xzxz;\n    vec4 fy=Pf.yyww;\n    vec4 i=permute(permute(ix,seed)+iy,seed);\n    vec4 gx=2.*fract(i*.0243902439)-1.;// 1/41 = 0.024...\n    vec4 gy=abs(gx)-.5;\n    vec4 tx=floor(gx+.5);\n    gx=gx-tx;\n    vec2 g00=vec2(gx.x,gy.x);\n    vec2 g10=vec2(gx.y,gy.y);\n    vec2 g01=vec2(gx.z,gy.z);\n    vec2 g11=vec2(gx.w,gy.w);\n    vec4 norm=1.79284291400159-.85373472095314*\n    vec4(dot(g00,g00),dot(g01,g01),dot(g10,g10),dot(g11,g11));\n    g00*=norm.x;\n    g01*=norm.y;\n    g10*=norm.z;\n    g11*=norm.w;\n    float n00=dot(g00,vec2(fx.x,fy.x));\n    float n10=dot(g10,vec2(fx.y,fy.y));\n    float n01=dot(g01,vec2(fx.z,fy.z));\n    float n11=dot(g11,vec2(fx.w,fy.w));\n    vec2 fade_xy=fade(Pf.xy);\n    vec2 n_x=mix(vec2(n00,n01),vec2(n10,n11),fade_xy.x);\n    float n_xy=mix(n_x.x,n_x.y,fade_xy.y);\n    return 2.3*n_xy;\n}\n\nvec2 centerImage(vec2 uv){\n    uv=(uv*2.-iResolution.xy)/min(iResolution.x, iResolution.y);\n    return uv;\n}\n\nvoid mainImage0(out vec4 fragColor,in vec2 fragCoord)\n{   \n\n    vec2 coord = centerImage(fragCoord);\n    vec2 uv = coord;\n    uv = 5.*uv;\n    uv *= cnoise(uv, 0.)+cnoise(uv+vec2(.3*iTime),1.);\n    vec2 triangle = 4. * abs(uv - floor(uv + 0.5));\n    // float \n    float c = min(triangle.x, triangle.y) > 0.1 ? 1. : 0.;\n    c = distance(vec2(0.), uv) < 0.2 ? 1. : 0.;\n\n    // if (distance(coord, vec2(0.)) < 0.1)\n    //     c = 1.;\n\n    c = smoothstep(-1.,1.,(c-.55)/fwidth(c));\n    c = coord.x > 0. ? c : 1. - c;\n    c = coord.y > 0. ? c : 1. - c;\n\n    fragColor=vec4(c, c, c, 1.);\n}\n\n// Auto antialiasing by GregRostami & FabriceNeyret2\n// Check out https://www.shadertoy.com/view/wtBBW3 (Same code but easier to read)\n// Usage: paste this bit of code at the end of any shader, change the AA value,\n//       the higher the AA value, the longer it takes to render.\n//       AA = 1 is no antialiasing, AA = 2 is 2x2, AA = 3 is 3x3, etc.\n\n#define AA 12\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {                \n    vec4 T;\n    fragColor = vec4(0.);\n    int x, y;\n    float A = float (AA);\n    for (x = 0; x < AA; x++) {\n        for (y = 0; y < AA; y++) {\n            mainImage0( T, fragCoord + vec2(x,y)/A-.5 );\n            fragColor += min(T, 1.);\n        }\n    }\n    fragColor /= A*A;\n}\n","name":"Image","description":"","type":"image"}]}