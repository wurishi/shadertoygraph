{"ver":"0.1","info":{"id":"X3KXDc","date":"1720584733","viewed":121,"name":"n^sphere","username":"ozazl","description":"conceptual model of a perceived 4D cube inside perceived space. (gets cool at 90s) camera is rotatable.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define MAX_STEPS 30 \n#define MAX_DIST 300.0\n#define SURF_DIST 3.0001\n#define PI 3.14159265359\n\nconst float minDist = 5.0;\nconst float maxDist = 20.0;\nconst float colorSpeed = 0.0;\nconst float camOrbitDistance = 50.0;\n\nfloat zoomLevel = 42.0; // camera distance\nfloat azimuth = 0.0;\nfloat elevation = 0.0;\n// // //// //////// //// // // // // //// //////// //// // //\n\nmat4 rotationMatrix4D(int axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    if (axis == 0) return mat4(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n    if (axis == 1) return mat4(c, 0, -s, 0, 0, 1, 0, 0, s, 0, c, 0, 0, 0, 0, 1);\n    if (axis == 2) return mat4(c, 0, 0, -s, 0, 1, 0, 0, 0, 0, 1, 0, s, 0, 0, c);\n    if (axis == 3) return mat4(1, 0, 0, 0, 0, c, -s, 0, 0, 0, 1, 0, 0, s, 0, c);\n    if (axis == 4) return mat4(1, 0, 0, 0, 0, c, 0, -s, 0, 0, 1, 0, 0, s, 0, c);\n    if (axis == 5) return mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, c, -s, 0, 0, s, c);\n    return mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n}\n\nvec4 fold4D(vec4 p, float time) {\n    for (int i = 0; i < 6; i++) {\n        float angle = time * (float(i) * 0.1 + 0.2);\n        p = rotationMatrix4D(i, angle) * p;\n        p = abs(p) - 0.5;\n        if (p.w > p.z) p.zw = p.wz;\n        if (p.z > p.y) p.yz = p.zy;\n        if (p.y > p.x) p.xy = p.yx;\n        if (i == 5 && p.z > p.x) p.xz = p.zx;\n    }\n    return p;\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat fractalShape(vec3 p, float scale, int iterations) {\n    vec4 p4 = vec4(p, 0.0);\n    float d = sdSphere(p, scale);\n\n    for (int i = 0; i < iterations; i++) {\n        p4 = fold4D(p4, iTime * 0.1);\n        float newD = sdSphere(p4.xyz, scale * pow(0.5, float(i + 1)));\n        d = min(d, newD);\n    }\n\n    return d;\n}\n\nfloat getDistance(vec3 p) {\n    float scale = 1.5;\n    p /= scale;\n    float d = fractalShape(p, 1.0, 5);\n\n    vec4 p4 = vec4(p, 0.0);\n    for (int i = 0; i < 7; i++) {\n        p4 = fold4D(p4, iTime * 0.05);\n        float detail = fractalShape(p4.xyz, 0.2, 2);\n        d = mix(d, detail, 0.2);\n    }\n\n    return d * scale;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = getDistance(p);\n        dO += dS;\n        if (dO > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 getNormal(vec3 p) {\n    float d = getDistance(p);\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        getDistance(p - e.xyy),\n        getDistance(p - e.yxy),\n        getDistance(p - e.yyx));\n    return normalize(n);\n}\n\nvec3 vibrantPalette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0);\n\n    if (iFrame == 0) {\n        zoomLevel = camOrbitDistance;\n        azimuth = 0.0;\n        elevation = 0.0;\n    } else if (iMouse.z > 0.0) {\n        vec2 mouseDelta = (iMouse.xy - iMouse.zw) / iResolution.xy;\n        azimuth += 2.0 * PI * mouseDelta.x;\n        elevation += PI * mouseDelta.y;\n    }\n\n    vec3 ro = vec3(\n        zoomLevel * cos(elevation) * sin(azimuth),\n        zoomLevel * sin(elevation),\n        zoomLevel * cos(elevation) * cos(azimuth)\n    );\n    vec3 lookAt = vec3(0, 0, 0);\n    vec3 f = normalize(lookAt - ro);\n    vec3 r = normalize(cross(vec3(0, 1, 0), f));\n    vec3 u = cross(f, r);\n    vec3 c = ro + f;\n    vec3 i = c + uv.x * r + uv.y * u;\n    vec3 rd = normalize(i - ro);\n\n    float d = rayMarch(ro, rd);\n\n    if (d < MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = getNormal(p);\n        vec3 r = reflect(rd, n);\n\n        vec3 lightPos = vec3(2.0 * sin(iTime), 5.0, 2.0 * cos(iTime));\n        vec3 l = normalize(lightPos - p);\n        float dif = clamp(dot(n, l), 0.1, 1.0);\n        float spec = pow(max(dot(r, l), 0.0), 32.0);\n        float fresnel = pow(1.0 - max(dot(n, -rd), 0.0), 5.0);\n\n        float depth = length(p);\n        float pulse = 0.5 + 0.5 * sin(iTime * colorSpeed + depth * 2.0);\n        vec3 objColor = vibrantPalette(pulse);\n        col = objColor * dif + vec3(0.8) * spec + vec3(0.1, 0.3, 0.5) * fresnel;\n\n        float ao = clamp(getDistance(p + n * 0.5) * 2.0, 0.0, 1.0);\n        col *= ao;\n    }\n\n    vec3 bg = mix(vec3(0.0, 0.05, 0.1), vec3(0.1, 0.2, 0.3), smoothstep(-1.0, 1.0, uv.y));\n    col = mix(bg, col, smoothstep(0.0, 0.95, 1.0 - d / MAX_DIST));\n\n    col = col / (1.0 + col);\n    col = pow(col, vec3(0.4545));\n\n    col *= 1.0 - smoothstep(0.5, 1.5, length(uv));\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}