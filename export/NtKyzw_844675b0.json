{"ver":"0.1","info":{"id":"NtKyzw","date":"1716556795","viewed":189,"name":"fractal Cloud","username":"eriben0628","description":"dfa","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["wraga"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define maxIterations 15\n#define steps 200\n#define steps2 10\n#define increment 4.0/float(steps)\n#define increment2 4.0/float(steps2)\n#define fractalPos vec4(0.0, 0.0, 1.8, 0.0)\n#define LightPos vec4(0.0, 5.0, 5.5, 0.0)\n#define LightColor vec4(0.5,0.9,0.85,1.0);\n#define LightIntensity 8.0\n#define forwardScattering 0.5\n\nfloat squaredDistance(vec4 p) {\n    return dot(p,p);\n}\n\nvec3 imMul(vec3 a, vec3 b) {\n    vec3 c;\n    c.x = a.x*b.x - a.y*b.y - a.z*b.z + a.y*b.z - a.z*b.y;\n    c.y = a.x*b.y + a.y*b.x;\n    c.z = a.x*b.z + a.z*b.x;\n    \n    return c;\n}\n\nvec4 quaternionMul(vec4 a , vec4 b) {\n    vec4 c;\n    c.x = a.x*b.x - a.y*b.y - a.z*b.z - a.w*b.w;\n    c.y = a.y*b.x + a.x*b.y + a.z*b.w - a.w*b.z;\n    c.z = a.x*b.z + a.z*b.x + a.y*b.w - a.w*b.y;\n    c.w = a.x*b.w + a.w*b.x + a.y*b.z - a.z*a.y;\n    \n    return c;\n}\n\nfloat fractal(vec4 p) {\n    vec4 z = p;\n    vec4 c = p;//vec4(-0.5, 0.6, 0.0, 0.0);\n    \n    for(int i = 0; i < maxIterations; i++) {\n        if(length(z) > 2.0) {\n            return float(i)/float(maxIterations)*1.0;\n        }\n        \n        z = quaternionMul(z,z) + c;\n    }\n    \n    return 10.0;\n}\n\nvec3 trace(vec3 Origin, vec3 Dir) {\n    vec4 p = vec4(Origin, 0.0);\n    vec4 dir = normalize( vec4(Dir,0.0) );\n    float totalDensity = 0.0;\n    vec4 totalLight = vec4(0.0);\n    vec4 totalLight2 = vec4(0.0);\n    float transmittence = 1.0;\n\n    for(int i = 0; i < steps; i++) {\n        vec4 LightDir = normalize(LightPos-p);\n        float density = fractal(p - fractalPos);\n        totalDensity += density*increment;\n        float transmittence2 = 1.0;//20.0/squaredDistance(p-LightPos);\n        totalLight2 = vec4(0.0);\n        vec4 p2 = p;\n        if(density >= 0.0001) {\n            for(int j = 0; j < steps2; j++) {\n                float density2 = fractal(p2-fractalPos);\n                if(density2 > 0.0001) {\n                    transmittence2 *= exp(-density2*increment2);\n                    totalLight2 += 1.0/squaredDistance(p2-LightPos) * transmittence2 * increment2 * LightColor;\n                }\n                \n                p2 += LightDir*increment2;\n            }\n            \n            totalLight2 *= (abs(dot(LightDir, dir))*forwardScattering+1.0-forwardScattering) * LightIntensity;\n        }\n        transmittence *= exp(-density*increment);\n        totalLight += totalLight2*transmittence * increment * LightColor;//1.0/squaredDistance(p-LightPos) * transmittence * increment;//\n        \n        p += dir * increment;\n    }\n    \n    \n    return vec3(totalLight);\n}\n\nvec2 randomPos(float t) {\n    float x = fract(t*1.0);\n    float y = fract(t*1.0);\n    return vec2(x,y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord + randomPos(iTime) )/iResolution.xy;\n    uv = uv*2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 Dir = normalize(vec3(uv,1.));\n    vec3 col = trace(vec3(0.0, 0.0, 0.0), Dir);\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}