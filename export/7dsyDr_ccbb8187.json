{"ver":"0.1","info":{"id":"7dsyDr","date":"1642784279","viewed":231,"name":"Magnetic Pendulum Simulation","username":"dawramath","description":"Imagine there is a piece of metal at each black point, and a magnetic pendulum is launched above each pixel on screen. The colors show the magnet each pendulum is closest to over time. Enjoy!","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["magent"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define tmax 50.\n#define dt .01\n#define h .25\n#define g .2\n#define mu .1\nprecision highp float;\n\nfloat sigmoid(float z) {\n    return 1./(1. + exp(-1. * z));\n}\n\nfloat smoothramp(float z, float mid, float c1, float c2){\n    if(z<mid){\n        return .5*pow((z/mid), c1);\n    } \n    else {\n        return (.5*pow(((z - mid)/(1. - mid)), c2)) + .5;\n    }\n    \n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid disk(vec2 r, vec2 center, float radius, vec3 color, inout vec3 pixel) {\n\tif( length(r-center) < radius) {\n\t\tpixel = color;\n\t}\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n\tvec2 r = vec2( fragCoord.xy - 0.5*iResolution.xy );\n\tr = 10.0 * r.xy / iResolution.y;\n    \n    \n    \n    float t = 0.0;\n    vec2 z = r;\n    vec2 v = vec2(0.0);\n    vec2 vprev = vec2(0.0);\n    vec2 vnext = vec2(0.0);\n    vec2 a = vec2(0.0);\n    vec2 aprev = vec2(0.0);\n    vec2 anext = vec2(0.0);\n    vec2 magnets[5] = vec2[5](vec2(2.,0.),vec2(0.618034,1.90211),vec2(-1.61803,1.17557),vec2(-1.61803,-1.17557),vec2(0.618034,-1.90211));\n    float pathlength = 0.;\n    vec2 zprev;\n    \n    float endtime = min(tmax, iTime);\n    \n    while (t < endtime) {\n        zprev = z;\n        z+= (dt*v) + (dt*dt/6.)*((4.*a) - aprev);\n        vnext = v + (dt/2.)*((3.*a) - aprev);\n        anext=vec2(0.);\n        //Compute approximate next acceleration for all points\n        \n        for(int i=0; i<magnets.length(); i++){\n            anext += (magnets[i] - z)/pow((pow(h,2.0) + pow(length(magnets[i]-z), 2.0)), 1.5);\n        }\n        \n        anext -= (g*z + mu* vnext);\n        v+= (dt/6.)*((2. * anext) + (5. * a) - aprev);\n        aprev = a;\n        a = anext;\n        t+= dt;\n        pathlength += length(z - zprev);\n    }\n    \n    int argmin = 0;\n    \n    for(int i=0; i<magnets.length(); i++){\n        if (length(magnets[i] - z) < length(magnets[argmin] - z)){\n            argmin = i;\n        }\n    }\n    \n    \n\n    // pixel color\n    vec3 col = hsv2rgb(vec3(float(argmin)/float(magnets.length()), 1., 1. - smoothramp(pathlength/60., .5, 10., 1.)));\n    \n    \n    for(int i=0; i<magnets.length(); i++){\n        disk(r, magnets[i],.05, vec3(0.), col);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}