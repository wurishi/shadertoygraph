{"ver":"0.1","info":{"id":"l3GSRG","date":"1720101739","viewed":74,"name":"A Fractal Tile-Generator 2D","username":"Imagyx","description":"Creates tiles with many different fractals by generating fractals through a range of parameters. Next step may be to change palettes as well.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","palette","generator","parametrize"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \n ----------------------------------------------------------------------------------------------------------------------------------------\n * Creates tiles with many different fractals by generating one fractal through a range of parameters for each tile randomly.\n * Some are repeated. But the variety overall is amazing, I think.\n * Even changing the ranges making them bigger or smaller affects the results in a way making it impossible to define ranges\n * that show all possible results in a short amount of time.\n * Change ranges, change values, play with them as much as possible. Find other palettes and please let me know if you find nices ones.\n * I think I'll have to also get back to 3D to play with these formulas more...\n * But first more transformations and operations can be added and parametrized, as well.\n \n #defines\n TILE_SIZE:    Make it bigger to show bigger more detailed tiles\n SPEED:        Changes the speed of the movement of the tiles\n ----------------------------------------------------------------------------------------------------------------------------------------\n */\n#define TILE_SIZE 2.0\n#define SPEED 1.0\n\nvec3 palette(in float t){\n\treturn (pow(palette(t, vec3(0.5),vec3(0.5),vec3(1.0),vec3(1.25, 1.425, 1.55)), vec3(1.2)));\n}\n\nconst float split = 1.5;\nconst vec2 rangeCr = vec2(0.1, 1.0);\nconst vec2 rangeCl = vec2(0.5, 2.5);\nconst vec2 rangeCs = vec2(0.4, 2.0);\nconst vec2 rangeCa = vec2(0.1, 1.0);\nconst vec2 rangeCb = vec2(1.2, 1.9);\nconst vec2 rangeCm = vec2(0.5, 2.5);\nconst vec2 rangeCd = vec2(-5.0, 40.0);\nconst vec2 rangeCd2 = vec2(-5.0, 40.0);\nconst vec2 rangeCt = vec2(3.0, 13.0);\nconst vec2 rangeCz = vec2(0.0, 1.0);\nconst vec4 rangeCi = vec4(0.01, 1.0, 2.0, 3.0);\nconst vec4 rangeCj = vec4(0.1, 1.5, 2.0, 4.0);\nvoid applyRange(inout float v, in vec2 r, in vec2 id){\n    v = r.x + hash12(id * 13371.931 + 130223.82) * (r.y - r.x);\n}\n// Source: The basic idea for this certain type of fractal is from https://jbaker.graphics/writings/DEC.html, adjusted for 2D and parametrized\nfloat de(vec2 q) {\n  float cr,ca,cb,cs,cl,cm,cd,cd2,ct,cz;\n    vec2 ci,cj;\n    vec2 id = 234.0 + floor((q - split) / (2.0 * split));\n    applyRange(cr, rangeCr, id);\n    applyRange(cl, rangeCl, id);\n    applyRange(cs, rangeCs, id);\n    applyRange(ca, rangeCa, id);\n    applyRange(cb, rangeCb, id);\n    applyRange(cm, rangeCm, id);\n    applyRange(cd, rangeCd, id);\n    applyRange(cd2, rangeCd2, id);\n    applyRange(ct, rangeCt, id);\n    applyRange(cz, rangeCz, id);\n    applyRange(ci.x, rangeCi.xy, id);\n    applyRange(ci.y, rangeCi.zw, id);\n    applyRange(cj.x, rangeCj.xy, id);\n    applyRange(cj.y, rangeCj.zw, id);\n    q = mod(q - split, 2.0 * split) - split;\n\tq = abs(q) - cl;\n\tif(q.x < q.y){\n        q.xy = q.yx;\n    }\n\tfloat s = cs;\n\tq -= ci;\n\tfor(float i = 0.0; i < ct; i+= 1.0) {\n\t\tfloat r2 = 2.0 / clamp(dot(q, q), ca, cb);\n\t\tq = abs(q) * r2;\n        rotate(q, cd);\n\t\tq -= cj;\n        rotate(q.xy, cd2);\n        if(cz > 0.5){\n            q = abs(q.yx);\n        }\n\t\ts *= r2;\n\t}\n\treturn cm * length(q) / (s - cr);\n}\nvec3 render(in vec2 pa){\n    float d = de(pa * 6.0 / TILE_SIZE);\n\tvec3 col = palette(d * 8.0);\n\tcol = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.02, abs(d)));\n    float mm = 0.25 * TILE_SIZE;\n    drawLine(col, vec3(0.1), min(mod(pa.y + mm, mm * 2.0), mod(pa.x + mm, mm * 2.0)), 0.03, 0.01);\n    return col;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord / iResolution.xy;\n    uv -= 0.5;\n    uv -= iTime * SPEED * 0.1;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 col = render(uv);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Source: https://iquilezles.org/articles/palettes/\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n// Source: https://www.shadertoy.com/view/XdGfRR\nfloat hash12(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * uvec2(1597334673U, 3812015801U);\n\tuint n = (q.x ^ q.y) * 1597334673U;\n\treturn float(n) * 2.328306437080797e-10;\n}\n// My own\nvoid drawLine(inout vec3 col, in vec3 lineColor, in float pos, in float thickness, in float hardness){\n    col = mix(col, lineColor, smoothstep(thickness, thickness * hardness, abs(pos)));\n}\n// Basic\nvoid rotate(inout vec2 q, in float deg){\n    float rad = radians(deg);\n    q = mat2x2(cos(rad),sin(rad),-sin(rad),cos(rad)) * q;\n}\n","name":"Common","description":"","type":"common"}]}