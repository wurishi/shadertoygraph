{"ver":"0.1","info":{"id":"WstcW4","date":"1601286536","viewed":478,"name":"Centrifuge","username":"iapafoto","description":"Interaction between balls and moving distance field \nSome other EXPERIMENTS are availables on Tab Common\n      #define EXPERIMENT 1 \n  // #define EXPERIMENT 2","likes":48,"published":1,"flags":32,"usePreview":0,"tags":["collision","ball","physic","mecanic","cinetic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//-----------------------------------------------------\n// Created by sebastien durand - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n//\n// Interaction between Balls and distance field\n//\n//-----------------------------------------------------\n// [dr2]            More Balls               - https://www.shadertoy.com/view/MsfyRn\n// [iq]             Balls and shadows        - https://www.shadertoy.com/view/lsSSWV\n// [reinder]        Old watch (IBL)          - https://www.shadertoy.com/view/lscBW4\n//-----------------------------------------------------\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n//\n//   5 EXPERIMENTS are availables on Tab Common!!!\n//   => #define EXPERIMENT 0..5\n//\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n\n#define WITH_AA\n\n\n//#define WITH_NOISE\n\n\n#define MAX_LOD 8.\n#define DIFFUSE_LOD 6.75\n\nvec2 BallHit(vec3 ro, vec3 rd, out vec3 vnBall) {\n    vec4 p;\n    vec3 u;\n    int id;\n    float b, d, w, dMin = FAR;\n    for (int i = 0; i<NB_ELT; i++) {\n        p = Load(iChannel0, POSITION, i);\n        float r = p.w;\n        if (length(ro-p.xyz)-r<dMin) {\n            u = ro - p.xyz;\n            b = dot (rd, u);\n            w = b * b - dot (u, u) + r * r;\n            if (w >= 0.) {\n                d = - b - sqrt (w);\n                if (d > 0. && d < dMin) {\n                    dMin = d;\n                    vnBall = (u + d * rd) / r;\n                    id = i;\n                }\n            }\n        } \n    }\n    return vec2(dMin, dMin < FAR ? MAT_BALL + float(id) : -1.);\n}\n\n\nvec3 getSpecularLightColor( vec3 N, float roughness ) {\n    // This is not correct. You need to do a look up in a correctly pre-computed HDR environment map.\n    return pow(textureLod(iChannel1, N, roughness * MAX_LOD).rgb, vec3(4.5)) * 6.5;\n}\n\nvec3 getDiffuseLightColor( vec3 N ) {\n    // This is not correct. You need to do a look up in a correctly pre-computed HDR environment map.\n    return .25 +pow(textureLod(iChannel1, N, DIFFUSE_LOD).rgb, vec3(3.)) * 1.;\n}\n\n//\n// Modified FrenelSchlick: https://seblagarde.wordpress.com/2011/08/17/hello-world/\n//\nvec3 FresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n//\n// Image based lighting\n//\n\nvec3 lighting(in vec3 ro, in vec3 pos, in vec3 N, in vec3 albedo, in float ao, in float roughness, in float metallic ) {\n    vec3 V = normalize(ro - pos); \n    vec3 R = reflect(-V, N);\n    float NdotV = max(0.0, dot(N, V));\n\n    vec3 F0 = vec3(0.04); \n    F0 = mix(F0, albedo, metallic);\n\n    vec3 F = FresnelSchlickRoughness(NdotV, F0, roughness);\n\n    vec3 kS = F;\n\n    vec3 prefilteredColor = getSpecularLightColor(R, roughness);\n    vec2 envBRDF = texture(iChannel0, vec2(NdotV, roughness)).rg;\n    vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n\n    vec3 kD = 1. - kS;\n\n    kD *= 1. - metallic;\n\n    vec3 irradiance = getDiffuseLightColor(N);\n    vec3 diffuse  = albedo * irradiance;\n    vec3 color = (kD * diffuse + specular) * ao;\n\n    return color;\n}\n\n//\n// main \n//\n\nvec4 render( const in vec3 ro, const in vec3 rd, float tmax ) {\n    \n    vec3 nor;\n    vec3 col = vec3(0); \n    vec2 res = min2(BallHit(ro, rd, nor), castRay( ro, rd, tmax ));\n\n    if (res.x > 0.) {\n        vec3 pos = ro + rd * res.x;\n        vec3 albedo;\n        float roughness, metallic, ao;\n\n        getMaterialProperties(pos, res.y, nor, albedo, ao, roughness, metallic, iChannel2, iChannel3, iChannel0);\n        col = lighting(ro, pos, nor, albedo, ao, roughness, metallic);\n    }\n\n    // Glass. \n    float glass = castRayGlass( ro, rd );\n    if (glass > 0. && (glass < res.x || res.x < 0.)) {\n        vec3 N = calcNormalGlass(ro+rd*glass);\n        vec3 pos = ro + rd * glass;\n\n        vec3 V = normalize(ro - pos); \n        vec3 R = reflect(-V, N);\n        float NdotV = max(0.0, dot(N, V));\n        float roughness = .3;\n\n        vec3 F = FresnelSchlickRoughness(NdotV, vec3(.08), roughness);\n        vec3 prefilteredColor = getSpecularLightColor(R, roughness);\n        vec2 envBRDF = texture(iChannel0, vec2(NdotV, roughness)).rg;\n        vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n\n        col = col * (1.0 -  (F * envBRDF.x + envBRDF.y) ) + specular;\n    } \n\n    // gamma correction\n    col = max( vec3(0), col - 0.004);\n    col = (col*(6.2*col + .5)) / (col*(6.2*col+1.7) + 0.06);\n    \n    return vec4(col, res.x);\n}\n\nfloat NoiseSeed;\n\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 84522.13219145687;\n  return fract(NoiseSeed);\n}\n\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord) {\n\n    GTime = 10.*float(iFrame)*DT; //iTime;\n    \n    // Normalize pixels\n    vec2 canvas = iResolution.xy,\n         uv = 2. * fragCoord.xy/canvas - 1.;\n    uv.x *= canvas.x / canvas.y;\n    \n\t// Camera      \n    float gAnim = mod(GTime,35.);\n\n \tvec2 mo = iMouse.xy/iResolution.xy;\n    if(iMouse.w <= 0.) {\n        mo = vec2(.2*sin(-GTime*.1+.3)+.045,.1-.2*sin(-GTime*.1+.3));\n    }\n    float a = 5.05;\n    vec3 ro = 12.*vec3( .25 + 2.*cos(6.0*mo.x+a), 2. + 2. * mo.y, 2.0*sin(6.0*mo.x+a) );\n    vec3 ta = vec3( -1., 1., .0 );\n\n    mat3 ca = setCamera(ro, ta);   \n    \n    // current ray direction\n    vec3 rd = ca * normalize( vec3(uv.xy, 3.5) );\n\n    // Background color\n    vec2 q = fragCoord.xy/canvas;\n    float h = dot(vec3(q,1.),vec3(127.1,311.7,758.5453123));\t\n\tvec3 backColor = vec3(.2) + .05*fract(sin(h)*43758.5453123);\n      \n    // Render scene (xyz = color, w = distance)\n    vec4 col = render(ro, rd, FAR);           \n    \n#ifdef WITH_NOISE    \n       NoiseSeed = float(iFrame)* .003186154 + fragCoord.y * 17.2986546543 + fragCoord.x;\n    \n \n    float noise = .9 + randomFloat()*.2;\n    col *= noise;\n  \t//col = vec4(ACESFilm(col.rgb), col.w);\n\n#endif  \n    \n    // Post traitment\n   \tcol.rgb = pow(col.rgb,vec3(.7));\n    col.rgb *= pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y), .25);       \n    \n    fragColor = vec4(col);\n}\n\n\n#ifdef WITH_AA\n  #define mainImage(O,U)                          \\\n    vec4 T;                                     \\\n    for (int k=0; k<4; k++, O+=T)               \\\n        mainImage(T, U+.33*vec2(k%2-1,k/2-1));  \\\n    O /= 4.;\n#endif\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//-----------------------------------------------------\n// Created by sebastien durand - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n// [dr2]            More Balls               - https://www.shadertoy.com/view/MsfyRn\n//-----------------------------------------------------\n\n\n// +---------------------------+\n// |     Choose experiment     |\n// +---------------------------+\n// 1  2 3 4 \n#define EXPERIMENT 1\n// +---------------------------+\n\n\n// +---------------------------+\n// | Experiments configuration |\n// +---------------------------+\n#if EXPERIMENT == 1\n\t#define ROT_SPEED 40.\n\t#define MIN_BALL_SIZE .5\n\t#define MAX_BALL_SIZE 1.1\n#elif EXPERIMENT == 2\n\t#define ROT_SPEED 20.\n\t#define MIN_BALL_SIZE .5\n\t#define MAX_BALL_SIZE .5\n#elif EXPERIMENT == 3\n\t#define ROT_SPEED 30.\n\t#define MIN_BALL_SIZE .5\n\t#define MAX_BALL_SIZE .7\n#elif EXPERIMENT == 4\n\t#define ROT_SPEED 20.\n\t#define MIN_BALL_SIZE .7\n\t#define MAX_BALL_SIZE 1.\n#elif EXPERIMENT == 5\n\t#define ROT_SPEED 0.\n\t#define MIN_BALL_SIZE .5\n\t#define MAX_BALL_SIZE .5\n#endif\n// +---------------------------+\n\n\n#define NB_ELT 64\n\n\n// -- RENDER --------------------------------------------------\n\n#define FAR 80.\n\n\n// -- PHYSICS -------------------------------------------------\n\n#define GRAV          9.81  // m/s-1 (on earth)\n#define DT            .002  // Step for mecanic calculus (.004 = real time => time beween two frame at 240fps)\n\n// +----------------------------------------------------------+\n// |       !!!!  DO NOT CHANGE AFTER THIS LINE !!!!           |  \n// +----------------------------------------------------------+\n\n// -- Step of the algorithm -----------------------------------\n\n#define STAGE_INIT            0  // First initialisation\n#define STAGE_SIMULATE        1  // Make moves\n\n// -- Position of elements in BufferPicture ------------------\n#define LINE_CONF\t    1\n\n#define POSITION        0\n#define ORIENTATION     1\n#define VELOCITY        2\n#define ROT_VELOCITY    3\n\n// -- Constants ----------------------------------------------\n#define PI              3.141592653589\n\n#define MAT_TABLE    1.\n#define MAT_METAL_0  7.\n#define MAT_METAL_1  8.\n#define MAT_BALL     9.\n\nfloat GTime = 0.;\n\n\n// +---------------------------+\n// |        Save / Load        |\n// +---------------------------+\n\nvec4 LoadConf (sampler2D txBuf, int idVar) {\n    return texelFetch(txBuf, ivec2(idVar, LINE_CONF), 0);\n}\n\nvec4 Load(sampler2D txBuf, int kind, int eltId) {\n    return texelFetch(txBuf, ivec2(NB_ELT*kind + eltId, 0), 0);\n}\n\nvoid Save(int kind, int eltId, vec4 val, inout vec4 fCol, vec2 fCoord) {\n\tvec2 iFrag = floor(fCoord);\n    if (NB_ELT*kind + eltId == int(iFrag.x) && int(iFrag.y) == 0) fCol = val;\n}\n\n\n// +---------------------------------+\n// | SDF functions (by Inigo Quilez) |\n// +---------------------------------+\n\nfloat sdTorus( const vec3 p, const vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCylinder( const vec3 p, const vec2 h ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( const vec3 p, const vec3 a, const vec3 b, const float r ) {\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdSphere( const vec3 p, const float r ) {\n    return length(p) - r;\n}\n\nfloat sdCone(vec3 p, vec2 c) {\n    vec2 q = vec2( length(p.xz), -p.y );\n    float d = length(q-c*max(dot(q,c), 0.0));\n    return d * ((q.x*c.y-q.y*c.x<0.0)?-1.0:1.0);\n}\n\nfloat sdBox(vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb) {\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nmat2 rotate(const float a) {\n    float co = cos(a), si = sin(a);\n    return mat2(co,-si,si,co);\n}\n\n//\n// Hash without Sine by Dave Hoskins.\n//\n\nfloat hash11(float p) {\n\tvec3 p3  = fract(vec3(p) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n\treturn a.x<b.x ? a : b;\n}\n\n\n\n// +-------------------------------------------------+ \n// |       Map use for drawing and cinetic           |\n// +-------------------------------------------------+\n\n\nvec2 map(in vec3 p, in float time) {\n    \n    float dGround = -sdCone(vec3(p.x+15.,-p.y-4.7,p.z),vec2(cos(.2),sin(.2)));\n#if EXPERIMENT != 5     \n    dGround = min(dGround, sdCylinder(p+vec3(0,3.2,0),vec2(8,3))-.2);\n#endif\n    dGround = max(dGround, -length(p.xz+vec2(15,0))+2.5);\n    dGround = max(dGround, -length(p.xz)+.4);\n    \n    float d = 999.;\n    \n     \n  #if EXPERIMENT == 4\n    d = sdCylinder(p, vec2(3.,.1));\n    d = max(d, -length(p.xz)+1.5)-.01;\n  #elif EXPERIMENT != 5   \n    d = sdCylinder(p, vec2(6.,.1));\n    d = max(d, -length(p.xz)+4.)-.01;\n  #endif\n    d = min(d, sdCylinder(p-vec3(-15,-4.2,0), vec2(3.2,.0)));\n  \td = max(d, -length(p.xz-vec2(-15,0))+2.9)-.1;\n\n    time = mix(0., time - 2., smoothstep(1.,2.,time));\n    float b = ROT_SPEED*cos(.2*time)* smoothstep(0., 20., time);\n    \n    p.xz *= rotate(b);\n    \n    float dRot = 999.;\n    \n#if EXPERIMENT == 1\n    dRot = sdCylinder(p, vec2(.2,10.))-.1;\n    dRot = min(dRot, sdCapsule(p,vec3(.1,7,0), vec3(-3.6,7.,0), .2));\n    dRot = min(dRot, sdTorus(p-vec3(-4.5,7,0), vec2(.8,.1)));\n    dRot = min(dRot, sdTorus(p.zxy-vec3(0,-4.5,7), vec2(.8-.1,.1)));\n    dRot = min(dRot, sdTorus(p.yzx-vec3(7,0,-4.5), vec2(.8+.1,.1)));\n    p -= vec3(3.9,7,0);\n    dRot = min(dRot, max(sdCylinder(p, vec2(3.8,.4)), -length(p.xz)+3.7)); \t\n    \n#elif EXPERIMENT == 2\n    dRot = sdCylinder(p, vec2(.5,2.5));\n    dRot = min(dRot, max(sdCylinder(p.zxy-vec3(0,0,6), vec2(3.4,.4)),\n                         -length(p.zy-vec2(0,6))+3.2)); \t\n    dRot = max(dRot, p.y-5.5);\n    dRot = min(dRot, sdBox(p-vec3(0,2.7,0),vec3(4,.1,.4)));\n    dRot = min(dRot, sdCapsule(p,vec3(0,.5,-7), vec3(0,.5,7),.3));\n    \n#elif EXPERIMENT == 3\n    dRot = sdCylinder(p, vec2(.2,6.))-.1;\n    dRot = min(dRot, max(sdCylinder(p.yzx-vec3(5.5,0,4.5), vec2(2.4,.4)),\n                           -length(p.yx-vec2(5.5,4.5))+2.2)); \n    //p.x = abs(p.x);\n    dRot = min(dRot, sdCapsule(p,vec3(2.2,5.5,0), vec3(0,5.5,0), .2)); \n    p-=vec3(-3.5,1,0);\n    p.yz *= rotate(-PI*.125);\n    dRot = min(dRot, sdBox(p, vec3(3.5,.1,2)));\n    dRot = min(dRot, sdBox(p-vec3(0,-.8,-3.5*.5),vec3(3.5,.8,.1)));\n    \n#elif EXPERIMENT == 4\n    dRot = sdCylinder(p, vec2(.2,2.8))-.1;\n    dRot = min(dRot, sdCapsule(p,vec3(0,.5,-7), vec3(0,.5,7),.3));\n    dRot = min(dRot, sdCapsule(p,vec3(-7,1.1,0), vec3(7,1.1,0),.3));\n    dRot = min(dRot, max(-p.y+.5,sdTorus(p.zxy -vec3(0,0,3), vec2(7.5 ,.2))));\n    dRot = min(dRot, max(-p.y+1.1,sdTorus(p.yzx -vec3(3,0,0), vec2(7.5 ,.2))));\n    dRot = min(dRot, sdTorus(p    -vec3(0,4,0), vec2(1.2  ,.2)));\n    dRot = min(dRot, sdTorus(p.zxy-vec3(0,0,4), vec2(1.2,.2)));\n    dRot = min(dRot, sdTorus(p.yzx-vec3(4,0,0), vec2(1.2,.2)));\n#elif EXPERIMENT == 5\n#endif    \n    \n    return min2(vec2(dGround,MAT_TABLE), \n                min2(vec2(dRot, MAT_METAL_0), \n                     vec2(d,    MAT_METAL_1)));\n}\n\nfloat mapGlass(in vec3 p, in float time) {\n    time = mix(0., time - 2., smoothstep(1.,2.,time));\n    float b = ROT_SPEED*cos(.2*time)* smoothstep(0., 20., time);\n    p.xz *= rotate(b);\n    float d = 999.;\n#if EXPERIMENT == 1\n    const float r1 = 3.5, r2 = .2;\n    const float x = r1+r2+.2;\n    d = sdCapsule(p, vec3(x,4.,0), vec3(x,8,0), r1);\n//    d = min(d, sdCapsule(p, vec3(-x-.5,7.2,2), vec3(-x-.5,7.2,-2), 2.));\n//    d = min(d, sdCappedTorus(p.zxy-vec3(0,0,7.2), vec2(.1,.8), x+.5,1.));\n    d = max(-d, d-r2);\n    d = max(d, p.y-8.);\n    d = min(d, sdTorus(p-vec3(x,8,0),vec2(r1+r2*.5,r2*.5))); \n    \n#elif EXPERIMENT == 2\n    d = sdCapsule(p, vec3(5,6,0), vec3(-5,6,0), 3.);\n    d = max(-d, d-.2);\n    d = max(d, p.y-6.);\n    \n#elif EXPERIMENT == 3\n\t//p.x = abs(p.x);\n    d = sdCapsule(p, vec3(4.5,5.5,3), vec3(4.5,5.5,-3), 2.);\n//    d = min(d, sdCappedTorus(p.zxy-vec3(0,0,7.2), vec2(.1,.8), x+.5,1.));\n    d = max(-d, d-.2);\n    d = max(d, p.y-6.);\n\n#elif EXPERIMENT == 4\n    d = length(p-vec3(0,3,0)) - 8.;\n    d = max(-d, d-.2);\n    d = max(d, p.y-6.);\n    d = min(d, sdTorus(p-vec3(0,6,0),vec2(7.5,.1)));\n#elif EXPERIMENT == 5\n\n    d = sdTorus(p.yzx-vec3(8,0,0), vec2(4,1.5));\n    d = min(d, length(p-vec3(4,10,0))-4.);\n    d = max(-d, d-.2);\n    d = max(d, -p.x);\n    vec3 p2 = p-vec3(0,3.2,-3.9);\n    p2.yz *= rotate(.2);\n    float d2 = sdTorus(p2, vec2(4,1.5));\n    d2 = max(-d2, d2-.2);\n    d2 = max(d2, p.x);\n\tp2 = p -vec3(0,.8,0);\n    p2.yz *= rotate(-.2);\n    float d3 = sdTorus(p2, vec2(8,1.5));\n    d3 = max(-d3, d3-.2);\n    d3 = max(d3, -p2.x);\n    d = min(d, min(d2,d3));\n    d = max(d, p.y-10.);\n#endif\n    \n    return d;\n}\n\n    \n// +-------------------------------------------------+ \n// |                   Normals                       |\n// +-------------------------------------------------+\n\nvec3 calcNormal( in vec3 pos ) {\n    const vec2 e = vec2(1.0,-1.0)*0.0075;\n    return normalize( e.xyy*map( pos + e.xyy, GTime ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, GTime ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, GTime ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, GTime ).x );\n}\n\nvec3 calcNormalGlass( in vec3 pos ) {\n    const vec2 e = vec2(1.0,-1.0)*0.005;\n    return normalize( e.xyy*mapGlass( pos + e.xyy, GTime ) + \n\t\t\t\t\t  e.yyx*mapGlass( pos + e.yyx, GTime ) + \n\t\t\t\t\t  e.yxy*mapGlass( pos + e.yxy, GTime ) + \n\t\t\t\t\t  e.xxx*mapGlass( pos + e.xxx, GTime ) );\n}\n\n// +-------------------------------------------------+ \n// |           distance field velocity               |\n// +-------------------------------------------------+\n\nvec3 calcVMap( in vec3 pos, float t1, float t2 ) {\n    const vec2 e = vec2(1.0,-1.0)*0.005;\n    return ( e.xyy*(map( pos + e.xyy,t1 ).x-map( pos + e.xyy,t2 ).x) + \n\t\t\t\t\t  e.yyx*(map( pos + e.yyx,t1 ).x-map( pos + e.yyx,t2 ).x) + \n\t\t\t\t\t  e.yxy*(map( pos + e.yxy,t1 ).x-map( pos + e.yxy,t2 ).x) + \n\t\t\t\t\t  e.xxx*(map( pos + e.xxx,t1 ).x-map( pos + e.xxx,t2 ).x) );\n}\n\nvec3 calcVMapGlass( in vec3 pos, float t1, float t2 ) {\n    const vec2 e = vec2(1.0,-1.0)*0.005;\n    return ( e.xyy*(mapGlass( pos + e.xyy,t1 )-mapGlass( pos + e.xyy,t2 )) + \n\t\t\t\t\t  e.yyx*(mapGlass( pos + e.yyx,t1 )-mapGlass( pos + e.yyx,t2 )) + \n\t\t\t\t\t  e.yxy*(mapGlass( pos + e.yxy,t1 )-mapGlass( pos + e.yxy,t2 )) + \n\t\t\t\t\t  e.xxx*(mapGlass( pos + e.xxx,t1 )-mapGlass( pos + e.xxx,t2 )) );\n}\n\n// +-------------------------------------------------+ \n// |                  Ray casting                    |\n// +-------------------------------------------------+\n\n// --------------------------------------------------------------------------\n// Adapted from [reinder] Old watch (IBL) - https://www.shadertoy.com/view/lscBW4\nvec2 castRay( in vec3 ro, in vec3 rd, float tmax) {  \n    float t = .5, mat = -1.;\n    for( int i=0; i<100; i++ ) {\n\t    float precis = 0.00025*t;\n\t    vec2 res = map(ro+rd*t, GTime); \n        t += res.x; \n        mat = res.y;\n        if( res.x<precis || t>tmax ) break;\n    }\n    return vec2(t, mat);\n}\n\n// --------------------------------------------------------------------------\n// Adapted from [reinder] Old watch (IBL) - https://www.shadertoy.com/view/lscBW4\nfloat castRayGlass( in vec3 ro, in vec3 rd ) {\n    float t = 0.;\n    float tmax = FAR;\n    for( int i=0; i<64; i++ ) {\n        float precis = 0.00025*t;\n        float res = mapGlass(ro+rd*t, GTime);\n        if( res<precis || t>tmax ) break; \n        t += res;\n    }\n\n    if( t>tmax ) t=-1.0;\n    return t;\n}\n\n\n// +---------------------------+\n// |        Quaternions        |\n// +---------------------------+\n\nvec4 Quaternion(vec3 n, float a) {\n    return normalize(vec4(n*sin(a*.5), -cos(a*.5)));\n}\n\n// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/arithmetic/index.htm\n//vec4 QtMul(vec4 q1, vec4 q2) {\n//    return vec4(cross(q1.xyz,q2.xyz) + q1.w*q2.xyz + q2.w*q1.xyz, q1.w*q2.w - dot(q1.xyz,q2.xyz));\n//}\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\n//-----------------------------------------------------------\n// [dr2] More Balls - https://www.shadertoy.com/view/MsfyRn\nmat3 QtToRMat(vec4 q) {\n    mat3 m;\n    float a1, a2, s;\n    q = normalize (q);\n    s = q.w * q.w - 0.5;\n    m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n    a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n    a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n    a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n    return 2. * m;\n}\n\n//-----------------------------------------------------------\n// [dr2] More Balls - https://www.shadertoy.com/view/MsfyRn\nvec4 RMatToQt(mat3 m) {\n    vec4 q;\n    const float tol = 1e-6;\n    q.w = .5 * sqrt(max(1. + m[0][0] + m[1][1] + m[2][2], 0.));\n    if (abs(q.w) > tol) q.xyz =\n        vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4.*q.w);\n    else {\n        q.x = sqrt (max(.5 * (1. + m[0][0]), 0.));\n        if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n        else {\n            q.y = sqrt (max (.5 * (1. + m[1][1]), 0.));\n            if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n            else q.z = 1.;\n        }\n    }\n    return normalize (q);\n}\n\n//-----------------------------------------------------------\n// [dr2] More Balls - https://www.shadertoy.com/view/MsfyRn\nmat3 LpStepMat (vec3 a) {\n    mat3 m1, m2;\n    vec3 t, c, s;\n    float b1, b2;\n    t = .25 * a * a;\n    c = (1. - t) / (1. + t);\n    s = a / (1. + t);\n    m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n    b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n    m1[0][1] = b1 + b2;    m2[1][0] = b1 - b2;\n    b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n    m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n    b1 = c.y * s.z;\n    m1[1][0] = - b1;       m2[0][1] = b1;  \n    b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n    m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n    b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n    m1[1][2] = b1 + b2;    m2[2][1] = b1 - b2;\n    m1[2][0] = s.y;        m2[0][2] = - s.y;\n    b1 = s.x * c.y;\n    m1[2][1] = - b1;       m2[1][2] = b1;\n    b1 = c.x * c.y;\n    m1[2][2] = b1;         m2[2][2] = b1;\n    return m1 * m2;\n}\n\n\n\n// +---------------------------+\n// |         Rendering         |\n// +---------------------------+\n\n// --------------------------------------------------------------------------\n// [iq] Balls and shadows - https://www.shadertoy.com/view/lsSSWV\nfloat sphOcclusion(in vec3 pos, in vec3 nor, in vec4 sph) {\n    vec3  r = sph.xyz - pos;\n    float l = length(r), d = dot(nor,r), res = d;\n    if (d<sph.w) \n        res = pow(clamp((d+sph.w)/(2.*sph.w),0.,1.),1.5)*sph.w;\n    float oc = clamp(res*(sph.w*sph.w)/(l*l*l), 0., 1. );\n    return pow(oc,.65);\n}\n\nfloat calcAO( in vec3 ro, in vec3 rd, in sampler2D txt) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    \n    for( int i=0; i<6; i++ ) {\n        float h = 0.001 + 0.25*float(i)/5.0;\n        float d = map( ro+rd*h, GTime).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    float d =  1.0 - 1.5*occ;\n   \n    for (int i = 0; i<NB_ELT; i++) {\n        vec4 p = Load(txt, POSITION, i);\n        d *= 1. - sphOcclusion( ro, rd, p);\n    }\n    return clamp(d, 0.0, 1.0 ); \n}\n\n// --------------------------------------------------------------------------\n// [Shane]\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;    \n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n// --------------------------------------------------------------------------\n// [Shane]\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n    const vec2 e = vec2(0.001, 0);\n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);                \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n}\n\n\n\n// --------------------------------------------------------------------------\n// Adapted from Mercury lib\nvoid pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = mod(atan(p.y, p.x) + angle*.5,angle) - angle*.5;\n\tp = vec2(cos(a), sin(a))*length(p);\n}\n\n\n// --------------------------------------------------------------------------\n// [reinder] Old watch (IBL) - https://www.shadertoy.com/view/lscBW4\nvec4 texNoise( sampler2D sam, in vec3 p, in vec3 n ) {\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n// --------------------------------------------------------------------------\n// Adapted from [reinder] Old watch (IBL) - https://www.shadertoy.com/view/lscBW4\nvoid getMaterialProperties(\n    in vec3 pos, in float mat,\n    inout vec3 normal, inout vec3 albedo, inout float ao, inout float roughness, inout float metallic,\n\tsampler2D tex1, sampler2D tex2, sampler2D tex3) {\n    \n    if (mat < MAT_BALL) {\n    \tnormal = calcNormal( pos );\n    }\n    ao = calcAO(pos, normal, tex3);\n    \n    metallic = 0.;\n    \n    float metalnoise;\n    mat -= .5;\n\n    if (mat < MAT_TABLE) {\n        normal = texBump(tex1, pos*vec3(.1,.4,.1), normal,.01);\n        albedo = .12 * pow(texture(tex1, pos.xz*.1).rgb, vec3(1.1));\n        roughness = 0.95 - albedo.r * .6;\n        vec2 p2 = pos.xz;\n        albedo *= .2+.8*smoothstep(.06,.1, abs(length(p2-vec2(-15,0))-5.));\n\n       \n        pModPolar(p2, 10.);\n        p2 -= vec2(7.1,0);\n        albedo *= .2+.8*smoothstep(.25,.3, length(p2));\n        \n            \n    } else if( mat < MAT_METAL_0 ) { \n        \n        float time = mix(0., GTime - 2., smoothstep(1.,2.,GTime));\n\t    float b = ROT_SPEED*cos(.2*time)* smoothstep(0., 20., time);\n    \tvec3 uvw = pos;\n        uvw.xz *= rotate(b);\n\n    \tvec4 noise = texNoise(tex1, uvw * .5, normal);\n    \tmetalnoise = 1.- noise.r;\n    \tmetalnoise *= metalnoise;\n        \n \t\talbedo = vec3(0.972, 0.960, 0.915); // Silver\n   \t\troughness = .7 + max(.15 * length(uvw.xz)-.3, 0.); // prevent aliasing\n   \t\tmetallic = 1.; \n        \n    } else if( mat < MAT_METAL_1 ) {\n\n        vec4 noise = texNoise(tex1, pos * .5, normal);\n        float metalnoise = 1.- noise.r;\n\n        metalnoise *= metalnoise;\n        \n\t    albedo = vec3(0.972, 0.960, 0.915); // Silver\n   \t\troughness = .7 + max(.15 * length(pos.xz)-.3, 0.); // prevent aliasing\n   \t\tmetallic = 1.; \n\n    } else {\n    \tfloat id = (mat+.5 - MAT_BALL);\n        \n        albedo = .5*mix(vec3(1,0,0), vec3(0,1,1), float((int(id)%2==0 ? int(id) : int(id)+NB_ELT/2)%NB_ELT)/float(NB_ELT));    \n        \n        vec3 uvw = pos - Load(tex3, POSITION, int(id)).xyz;\n        uvw *= QtToRMat(Load(tex3, ORIENTATION, int(id)));\n\n        albedo *= mix(.2, 1.2, smoothstep(.7,.9, cos(3.*3.141592*uvw.z)))+\n                  mix(.2, 1.2, smoothstep(.7,.9, cos(3.*3.141592*uvw.x)));\n   \t\troughness = .5; \n    }\n    \n    \n    if (metallic > .5) {   \n        albedo *= 1.-metalnoise;\n        roughness += metalnoise*4.;\n    }\n    \n   // ao = clamp(.1+.9*ao, 0., 1.);\n    roughness = clamp(roughness, 0., 1.);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta ) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, 1.0,0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\n// +------------------------------------------------------+\n// |                    INIT SPHERES                      |\n// +------------------------------------------------------+\n// Create Initial Pos from ADN\n\nvoid InitPositions(sampler2D txBuf, int eltId, out vec3 rm, out vec4 qm, out float rad) {\n    int CHAIN = 2;\n    float idChain = float(eltId/CHAIN);\n    int NB_LINES = NB_ELT/CHAIN;\n    float ca = cos(floor(idChain/float(CHAIN*CHAIN))), sa = sin(idChain/float(CHAIN*CHAIN));\n\n    rad = mix(MIN_BALL_SIZE, MAX_BALL_SIZE, float(eltId%7)/7.);\n\n    rm = vec3(3.,10,.5)+vec3(float((eltId/CHAIN)%(CHAIN))*2.5, mix(50.,200., smoothstep(5.,20.,float(eltId)))*float(eltId/(CHAIN*CHAIN)), float(eltId%CHAIN - CHAIN/2)*2.5);\n    qm = vec4(0,0,0,-1);\n}\n\n\n//-----------------------------------------------------------\n// Adapted from [dr2] More Balls - https://www.shadertoy.com/view/MsfyRn\nvoid Simulate(float time, sampler2D txBuf, int eltId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float rad) {\n\n  \tvec4 p;\n  \tfloat fOvlap, fricN, fricT, fricS, fricSW, fDamp, fPull, fCent, grav, rSep,\n     \t  fc, ft, drv, dt, spFreq;\n    \n    fOvlap = 5000.;\n    fricN = 0.5;\n    fricS = 0.1;\n    fricSW = 0.5;\n    fricT = 0.5;\n    fDamp = 0.01;\n    grav = 9.81;\n    \n    vec3  vmN, wmN, dr, dv, am, wam;\n    float radSum, h;\n        \n    vec4 pc1 = Load(txBuf, POSITION, eltId);\n    qm = Load(txBuf, ORIENTATION,    eltId);\n    vm = Load(txBuf, VELOCITY,       eltId).xyz;\n    wm = Load(txBuf, ROT_VELOCITY,   eltId).xyz;\n\n    rm = pc1.xyz;\n    rad = pc1.w;\n\n    am = wam = vec3(0); // Sum or forces\n \n    // Slow it a bit\n    vm *= .995;\n    wm *= .995;\n\n    // Check intersection between Elements of the creature\n    for (int i=0; i<NB_ELT; i++) {\n\n        vec4 pc2 = Load(txBuf, POSITION, i);\n\n        dr = pc1.xyz - pc2.xyz;\n\n        rSep = length(dr);\n        radSum = (pc1.w + pc2.w);\n\n        if (i != eltId && rSep < radSum) {\n            // Impulsion de contact\n            fc = fOvlap * (radSum / rSep - 1.);\n\n            vmN = Load(txBuf, VELOCITY, i).xyz;\n            wmN = Load(txBuf, ROT_VELOCITY, i).xyz;\n\n            dv = vm - vmN;\n            drv = dot (dr, dv) / (rSep * rSep);\n            fc = max (fc - fricN * drv, 0.);\n            am += fc * dr;\n        }\n    }\n    \n    \n    mat3 rot1, rot2, rot = QtToRMat(qm);\n    \n// -------------------------------------------------------\n// Intersection with the distance field \n    \n    vec3 vmap;\n\tfloat dMap = map(rm, GTime).x;\n\tfloat dMapGlass = mapGlass(rm, GTime);\n    vec3 nor;\n    \n    if (dMapGlass < dMap) {\n        dMap = dMapGlass;\n\t\tnor = calcNormalGlass(rm);    \t\n        vmap = calcVMapGlass(rm-dr, GTime, GTime-DT);\n    } else {\n\t\tnor = calcNormal(rm);\n        vmap = calcVMap(rm-dr, GTime, GTime-DT);\n    }        \n\n\trSep = dMap-.2;//-pc1.w;//length (dr);\n    float radAv = pc1.w;\n    \n    dr = dMap*nor;\n  \t\n    if (rm.y < 8. && rSep < pc1.w) {\n        \n        // Distance field velocity                    \n        rm -= .5*normalize(dr)*(rSep-radAv);\n        fc = 15.*fOvlap * (pc1.w / rSep - 1.);\n        dv = vm - vmap;\n        drv = dot (dr, dv) / (rSep * rSep);\n        fc = max (fc - fricN * drv, 0.);\n        am += fc * dr;\n        dv -= drv * dr + cross (wm, dr);\n        ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n        am -= ft * dv;\n        wam += (ft / rSep) * cross (dr, dv);\n  }\n     \n  vec3 vGrav = vec3(0,-1,0);\n\n    \n  am += vGrav * /*ms*/GRAV *40.;\n  am -= fDamp * vm;\n  wam -= 1e-4 * fDamp * wm;\n  vm += DT * am;\n  if (length(vm) > 100.) vm = 100.*normalize(vm); \n    \n  rm += DT * vm;\n  wm += DT * wam / 0.03;\n    \n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * DT * wm)), qm));\n    \n    if (rm.y < -10.) {\n        rm = vec3(1.+.2*float(eltId)/7.,20,0); \n        vm = wm = vec3(0); \n    }\n}\n\n\n// +---------------------------+\n// |         Main Loop         |\n// +---------------------------+\n\nvoid calculatePhysicLoop(float iTime, vec4 iMouse, vec2 iResolution, int iFrame, sampler2D txBuf, out vec4 fragColor, in vec2 fragCoord) {\n\n    GTime = iTime;\n    vec4 configuration = LoadConf(txBuf, 3);\n    \n    int stage, nextStage;\n    \n    if (iFrame == 0) {\n        stage = STAGE_INIT;\n\n    } else {\n        stage = int(configuration.z);\n        nextStage = stage;\n    }\n\n    vec2 iFrag = floor(fragCoord);\n    int pxId = int(iFrag.x);\n        \n    // By default : do not change value \n    fragColor = texelFetch(txBuf, ivec2(iFrag), 0);\n        \n    // Win some cycles \n    if (iFrag.y >= float(2)) {      \n\t\treturn;\n    }\n\n    // Configuration\n    if (int(iFrag.y) == LINE_CONF) {  \n\n        if (pxId == 3) {\n            // Change states (sequence of actions)\n            if (stage == STAGE_INIT) {\n                nextStage = STAGE_SIMULATE;\n            } \n\n            configuration = vec4(0, 0, nextStage, 0);\n        }\n\t\t\n\t\t// Save config\n        fragColor = configuration;\n\n    } else {\n\n\t\tint eltId = pxId%NB_ELT + int(iFrag.y)*NB_ELT;\n\t\tint varColId = pxId/NB_ELT;\n        \n        vec4 p, qm;\n    \tvec3 rm, vm, wm;\n        float rad;\n        \n\t// -- Init ---------------------------------------------------------\n\n        if (stage == STAGE_INIT) {\n\n            if (varColId == VELOCITY || varColId == ROT_VELOCITY) {\n                fragColor = vec4(0); // Static at starts\n         \n            } else if (varColId == POSITION || varColId == ORIENTATION) {\n                       \n\t\t\t\t// ------------------------------------------------------------------\n                // Init positions and orientations\n                InitPositions(txBuf, eltId, rm, qm, rad);\n                // Save Positon and Orientation\n                fragColor = varColId == POSITION ? vec4(rm, rad) : qm;\n            }\n         \n        }  else if (stage == STAGE_SIMULATE) {\n            // Do physical simulation\n            Simulate(GTime, txBuf, eltId, rm, vm, qm, wm, rad);\n\n            // Save new positions, orientation and speeds\n            fragColor = varColId == POSITION ? vec4(rm, rad) :\n            varColId == ORIENTATION ? qm :\n            varColId == VELOCITY ? vec4(vm,0) : vec4(wm,0);\n        }\n    }\n}\n\n\n\n\n\n// ----------------------------------------------------------------\n\n\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    GTime = 10.*float(iFrame)*DT; //iTime;\n    calculatePhysicLoop(GTime, iMouse, iResolution.xy, iFrame, iChannel0, fragColor, fragCoord);\n}\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    \n    GTime = 10.*float(iFrame)*DT; //iTime;\n    calculatePhysicLoop(GTime, iMouse, iResolution.xy, iFrame, iChannel0, fragColor, fragCoord);\n}\n\n\n\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    GTime = 10.*float(iFrame)*DT; //iTime;\n\n   calculatePhysicLoop(GTime, iMouse, iResolution.xy, iFrame, iChannel0, fragColor, fragCoord);\n}\n\n\n\n\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//-----------------------------------------------------\n// [reinder]        Old watch (IBL)          - https://www.shadertoy.com/view/lscBW4\n//-----------------------------------------------------\n\n// see: http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\nfloat PartialGeometryGGX(float NdotV, float a) {\n    float k = a / 2.0;\n\n    float nominator   = NdotV;\n    float denominator = NdotV * (1.0 - k) + k;\n\n    return nominator / denominator;\n}\n\nfloat GeometryGGX_Smith(float NdotV, float NdotL, float roughness) {\n    float a = roughness*roughness;\n    float G1 = PartialGeometryGGX(NdotV, a);\n    float G2 = PartialGeometryGGX(NdotL, a);\n    return G1 * G2;\n}\n\nfloat RadicalInverse_VdC(uint bits) {\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n\nvec2 Hammersley(int i, int N) {\n    return vec2(float(i)/float(N), RadicalInverse_VdC(uint(i)));\n} \n\nvec3 ImportanceSampleGGX(vec2 Xi, float roughness) {\n    float a = roughness*roughness;\n    float phi      = 2.0 * PI * Xi.x;\n    float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\n    vec3 HTangent;\n    HTangent.x = sinTheta*cos(phi);\n    HTangent.y = sinTheta*sin(phi);\n    HTangent.z = cosTheta;\n\n    return HTangent;\n}\n\nvec2 IntegrateBRDF(float roughness, float NdotV) {\n    vec3 V;\n    V.x = sqrt(1.0 - NdotV*NdotV);\n    V.y = 0.0;\n    V.z = NdotV;\n\n    float A = 0.0;\n    float B = 0.0;\n\n    const int SAMPLE_COUNT = 128;\n\n    vec3 N = vec3(0.0, 0.0, 1.0);\n    vec3 UpVector = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n    vec3 TangentX = normalize(cross(UpVector, N));\n    vec3 TangentY = cross(N, TangentX);\n\n    for(int i = 0; i < SAMPLE_COUNT; ++i)  {\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n        vec3 HTangent = ImportanceSampleGGX(Xi, roughness);\n        \n        vec3 H = normalize(HTangent.x * TangentX + HTangent.y * TangentY + HTangent.z * N);\n        vec3 L = normalize(2.0 * dot(V, H) * H - V);\n\n        float NdotL = max(L.z, 0.0);\n        float NdotH = max(H.z, 0.0);\n        float VdotH = max(dot(V, H), 0.0);\n\n        if(NdotL > 0.0) {\n            float G = GeometryGGX_Smith(NdotV, NdotL, roughness);\n            float G_Vis = (G * VdotH) / (NdotH * NdotV);\n            float Fc = pow(1.0 - VdotH, 5.0);\n\n            A += (1.0 - Fc) * G_Vis;\n            B += Fc * G_Vis;\n        }\n    }\n    A /= float(SAMPLE_COUNT);\n    B /= float(SAMPLE_COUNT);\n    return vec2(A, B);\n}\n\nbool resolutionChanged() {\n    return floor(texelFetch(iChannel1, ivec2(0,2), 0).r) != floor(iResolution.x);\n}\n\nvoid mainImage0( out vec4 fragColor, in vec2 fragCoord ) {\n    if(resolutionChanged()) {\n        if (fragCoord.x < 1.5 && fragCoord.y < 2.5) {\n            fragColor = floor(iResolution.xyxy);\n        } else {\n\t   \t\tvec2 uv = fragCoord / iResolution.xy;\n    \t\tvec2 integratedBRDF = IntegrateBRDF(uv.y, uv.x);\n   \t \t\tfragColor = vec4(integratedBRDF, 0.0,1.0);\n        }\n    } else {\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    if (fragCoord.y < 2.) {\n        \n    GTime = 10.*float(iFrame)*DT; //iTime;\n\n   \t\tcalculatePhysicLoop(GTime, iMouse, iResolution.xy, iFrame, iChannel0, fragColor, fragCoord);\n    } else {\n        mainImage0(fragColor, fragCoord);\n    }\n}\n\n\n\n\n","name":"Buffer D","description":"","type":"buffer"}]}