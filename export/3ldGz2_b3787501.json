{"ver":"0.1","info":{"id":"3ldGz2","date":"1576977235","viewed":218,"name":"Cloud Cube","username":"JohnShadow","description":"Cloud Cube","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["cloudcube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define light normalize(vec3(sin(iTime), cos(iTime), 0.0))\nconst float stepsize = 0.1;\nconst float lightstepsize = 6.0;\nconst float deltas = 1.0;\nconst float cloudscale = 0.5;\nconst float cloudupdown = 0.4;\nconst float orbit = 30.0;\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60, -0.80,  0.36, -0.48, -0.60, -0.48,  0.64 );\n#define hdot(a, b) ((dot(a, b) + 1.0) * 0.5)\n\nstruct Ray\n{\n\tvec3 o, d;\n};\n\nstruct AABB\n{\n\tvec3 max, min;\n};\n    \nAABB worldbox = AABB(vec3(-5.0, -5.0, -5.0), vec3(5.0, 5.0, 5.0));\nvec2 rayAABB(Ray ray, AABB aabb, float tmin, float tmax) {\n    vec3 invD = 1.0/ray.d;\n\tvec3 t0s = (worldbox.min - ray.o) * invD;\n  \tvec3 t1s = (worldbox.max - ray.o) * invD;\n    \n  \tvec3 tsmaller = min(t0s, t1s);\n\tvec3 tbigger  = max(t0s, t1s);\n\n\ttmin = max(tmin, max(tsmaller[0], max(tsmaller[1], tsmaller[2])));\n\ttmax = min(tmax, min(tbigger[0], min(tbigger[1], tbigger[2])));\n\treturn vec2((tmin < tmax) ? tmin : 0.0, max(tmin, tmax));\n}\n    \nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\nfloat noise( in vec3 x )\n{\n    x *= cloudscale;\n    \n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res - cloudupdown;\n}\n\n\nfloat shadow(Ray ray)\t\n{\n    vec2 hit = rayAABB(ray, worldbox, 0.0, 1e20);\n    float far = hit.y - hit.x;\n\t\n    float density = 0.0;\n    float dist = 0.0;\n    float dlightstepsize = far/lightstepsize;\n    vec3 pos = ray.o;\n\tfor(float i = 0.0; i < lightstepsize; ++i)\n    {\n\t\tpos += ray.d * dlightstepsize;\n\t\tdensity += max(noise(pos) * dlightstepsize, 0.0);\n\t}\n\treturn exp(-density);\n}\nfloat scatter(Ray ray, float far)\n{\n\tfloat dist = 0.0;\n    float density = 1.0;\n    float lightDensity = 0.0;\n\twhile(far > dist)\n\t{\n\t\tvec3 pos = ray.o + ray.d * dist;\n\t\tfloat pointDensity = max(noise(pos), 0.0);\n        if(pointDensity > 0.0)\n        {\n        \tlightDensity += pointDensity * shadow(Ray(pos, light)) * (1.0/lightstepsize);\n            density *= exp(-pointDensity * stepsize);\n            if(density < 0.01)\n                break;\n        }\n\t\tdist += stepsize;\n\t}\n\treturn (lightDensity + (1.0-density)) * 0.25;\n}\nfloat cloud(Ray ray)\n{\n\tvec2 boxhit = rayAABB(ray, worldbox, 0.0, 1.e20);\n    if(boxhit.x == 0.0)\n        return 0.0;\n    vec3 hitpoint = ray.o + ray.d * (boxhit.x + 0.001);\n\tfloat sss = scatter(Ray(hitpoint, ray.d), boxhit.y - boxhit.x);\n\treturn sss;\n}\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n\tvec3 ori = vec3(orbit * sin(iTime * 0.5), 10.0, orbit * cos(iTime * 0.5));\n    mat4 viewToWorld = viewMatrix(ori, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 dir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n\t\n\tvec3 c = vec3(0.0);\n\t\n\tfloat sss = cloud(Ray(ori, dir));\n\tc = vec3(sss);\n\t\n    // Output to screen\n    fragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}]}