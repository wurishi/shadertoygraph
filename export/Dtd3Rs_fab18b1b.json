{"ver":"0.1","info":{"id":"Dtd3Rs","date":"1683126123","viewed":123,"name":"Parabola - Intersection","username":"Poisson","description":"Just parabola intersection using a quadratic equation.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["2d","raytracing","raytracer","ray","math","raycasting","intersection","graph","quadratic","parabola","raycaster","maths","intersector"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// circle sdf\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\n// segment sdf\nfloat sdSegment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1.);\n    return length(pa - ba*h);\n}\n\n// ray sdf\n// o is the origin\n// d is the direction\nfloat sdRay(vec2 p, vec2 o, vec2 d) {\n    vec2 po = p-o;\n    float h = dot(po,d);\n    return length(po - d*h);\n}\n\n// sdf antialiasing function\nfloat antialias(float d) {\n    #if 1\n    float idf = iResolution.y;\n    #else\n    float dx = dFdx(d);\n    float dy = dFdy(d);\n    float idf = 1./length(vec2(dx,dy));\n    #endif\n    return clamp(.5-d*idf, 0., 1.);\n}\n\n// parabola sdf approximation\n\n// f(x) = ax^2 + bx + c\n// f'(x) = 2ax + b -> this is the derivate of f(x)\n// x and y are the coordinates of the point\n\n//          f(x) - y\n// d ≈ -------------------\n//      sqrt(1 + f'(x)^2)\n\nfloat sdParabola(vec2 p, float ka, float kb, float kc) {\n    float x2 = p.x*p.x;\n    float h = sqrt(1. + 4.*ka*ka*x2 + 4.*ka*kb*p.x + kb*kb); // sqrt(1 + f'(x)^2)\n    return (ka*x2 + kb*p.x + kc - p.y) / h;\n}\n\n// ray parabola intersection function\n\n/* \nWrite the equation:\n\ny = ax^2 + bx + c\nax^2 + bx - y + c = 0\na*(ro.x + rd.x*t)^2 + b*(ro.x + rd.x*t) - (ro.y + rd.y*t) + c = 0\n(a*rd.x^2)*t^2 + (2*a*ro.x*rd.x + b*rd.x - rd.y)*t + a*ro.x^2 + b*ro.x - ro.y + c = 0\n\n*/\n\n/*\nSolve quadratic equation:\n\nA = a*rd.x^2;\nB = 2*a*ro.x*rd.x + b*rd.x - rd.y\nC = a*ro.x^2 + b*ro.x - ro.y + c\n\nΔ = B^2 - 4AC\nt1 = -B - sqrt(Δ) / (2A)\nt2 = -B + sqrt(Δ) / (2A)\n\n*/\n\nvec2 iParabola(vec2 ro, vec2 rd, float ka, float kb, float kc) {\n    // solve quadratic equation    \n    float a = ka*rd.x*rd.x;\n    float b = 2.*ka*ro.x*rd.x + kb*rd.x - rd.y;\n    float c = ka*ro.x*ro.x + kb*ro.x - ro.y + kc;\n    float h = b*b - 4.*a*c; // discriminant\n    \n    if (h<0.) return vec2(-1); // no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/(2.*a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p =  (fragCoord - .5*iResolution.xy) / iResolution.y;\n    // normalized mouse coordinates\n    vec2 mo = (iMouse.xy - .5*iResolution.xy) / iResolution.y;\n      \n    // 3 parameters of the parabola ax^2 + bx + c\n    float ka = 6.*cos(iTime*1.3);\n    float kb = -sin(iTime);\n    float kc = .15*sin(iTime+1.);\n      \n    vec3 col;\n      \n    { // draw background\n    col = vec3(.45+.55*p.y)*.03;\n    col *= 1.+.35*smoothstep(.5,-.5,cos(p.x*64.)*cos(p.y*64.)); // grid\n\n    float d = min(sdSegment(vec2(p.x,abs(p.y)), vec2(.85,0), vec2(.81,.015)),\n                  sdSegment(vec2(abs(p.x),p.y), vec2(0,.47), vec2(.015,.43)));\n    \n    d = min(d, min(sdSegment(p, vec2(-10,0), vec2(.85,0)), \n                   sdSegment(p, vec2(0,-10), vec2(0,.47))));\n    \n    col = mix(col, vec3(.75), antialias(d-.0025));\n    }\n    \n    { // draw curve\n    float d = sdParabola(p, ka, kb, kc); // distance\n    col = mix(col, vec3(1), .02*step(d,0.)); // fill\n    col = mix(col, vec3(1), antialias(abs(d)-.004)); // outline\n    }\n    \n    // create ray\n    vec2 ro = vec2(-.65,-.25); // ray origin\n    // ray direction\n    vec2 rd = iMouse.z>0. ? mo : vec2(.1);\n         rd = normalize(rd - ro);\n    \n    { // draw ray\n    col = mix(col, vec3(.5), antialias(sdRay(p, ro, rd)-.002)); // ray\n    \n    vec2 tp = ro + rd*.16;\n    vec2 rdn = vec2(-rd.y,rd.x);\n      \n    // draw arrow\n     float d = min(min(sdSegment(p, ro, tp),\n                       sdSegment(p, tp, tp+.035*normalize(rdn-2.*rd))),\n                       sdSegment(p, tp, tp-.035*normalize(rdn+2.*rd)));\n      \n    col = mix(col, vec3(.75), antialias(d-.0035));\n    col = mix(col, vec3(1,.7,.06), antialias(sdCircle(p-ro, .02))); // origin\n    }\n    \n    { // draw intersection points\n    vec2 t = iParabola(ro, rd, ka, kb, kc); // intersection distances\n    // intersection points\n    vec2 p1 = ro + rd*(t.x<0. ? 1e10 : t.x);\n    vec2 p2 = ro + rd*(t.y<0. ? 1e10 : t.y);\n    \n    // intersection points sdf\n    float d = min(sdCircle(p-p1, .02),\n                  sdCircle(p-p2, .02));\n    \n    col = mix(col, vec3(.05,.2,1), antialias(d));\n    }\n        \n    col = pow(col, vec3(.4545)); // gamma correction\n    \n    // vignette\n    vec2 q = fragCoord/iResolution.xy;\n    col *= .4+.6*pow(16. * q.x*q.y*(1.-q.x)*(1.-q.y), .1);\n            \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}