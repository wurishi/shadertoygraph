{"ver":"0.1","info":{"id":"XdjBDG","date":"1501965549","viewed":188,"name":"RayCastSphere","username":"diroru","description":"Raycasting a sphere with relief as an alternative to displacement of vertices.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","displacementmap","geovis"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\n#define STEP_SIZE 0.001 //a lower value produces better results but requires more computation\n\nvec3 getEyeVec(vec2 xy, vec3 eyeOrigin) {\n  return normalize(vec3(xy,0) - eyeOrigin);\n}\n\nfloat angleBetween(vec3 a, vec3 b) {\n    //TODO: signed version\n    return acos(dot(a, b) / length(a) / length(b));\n}\n\n//source: https://math.stackexchange.com/questions/1830695/how-to-rotate-a-3d-vector-on-the-surface-of-a-plane-by-a-known-angle\nvec3 rotateInPlane(vec3 v, vec3 n, float theta) {\n    return cos(theta)*v + sin(theta)*cross(n, v);\n}\n\nvec3 getIntersectionCandidate(vec3 sphereOrigin, vec3 eyeOrigin, vec3 eyeVec, float angleInc) {\n\tvec3 eyeSphere = eyeOrigin-sphereOrigin;\n    float theta = angleBetween(eyeSphere, eyeVec)*angleInc;\n    //normal of the plane defined by the eye origin, sphere origin and the eye vector\n    vec3 n = normalize(cross(eyeSphere, eyeVec));\n    return normalize(rotateInPlane(eyeSphere, n, theta));\n}\n\n//we have a triangle formed by three vectors, with only one known side\n//and would like to determine (the lenght of) one of the unknown sides (belonging to vector c)\n//in other words a + mu * b + lambda * c = 0\n//mu and lambda are unknown scalars\n//lambda is what we are looking for\n//c should be normalized\nfloat getDistanceToRay(vec3 a, vec3 b, vec3 c) {\n    //TODO: check for corner cases!?\n    return (a.x*b.y*b.z - 0.5*a.y*b.x*b.z - 0.5*a.z*b.x*b.y)/(c.x*b.y*b.z - 0.5*c.y*b.x*b.z - 0.5*c.z*b.x*b.y);\n}\n\nfloat map(float value, float low1, float high1, float low2, float high2) {\n\treturn low2 + (value - low1) * (high2 - low2) / (high1 - low1);\n}\n\nvec2 xyzToLatLon(vec3 v) {\n    vec3 p = normalize(v);\n    float lat = map(asin(p.z),-PI*0.5, PI*0.5, 0.0, 1.0);\n    float lon = map(atan(p.y, p.x), -PI, PI, 0.0, 1.0);\n    return vec2(lat, lon);\n}\n\nvec3 xRot(vec3 v, float theta) {\n  float x = v.x;\n  float y = v.y*cos(theta) - v.z*sin(theta);\n  float z = v.y*sin(theta) + v.z*cos(theta);\n  return vec3(x,y,z);\n}\n\nvec3 yRot(vec3 v, float theta) {\n  float x = v.z*sin(theta) + v.x*cos(theta);\n  float y = v.y;\n  float z = v.z*cos(theta) - v.x*sin(theta);\n  return vec3(x,y,z);\n}\n\nvec3 zRot(vec3 v, float theta) {\n  float x = v.x*cos(theta) - v.y*sin(theta);\n  float y = v.x*sin(theta) + v.y*cos(theta);\n  float z = v.z;\n  return vec3(x,y,z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //GLOBALS\n    float width = iResolution.x;\n    float height =  iResolution.y;\n    float fov_h = PI / 3.0;\n\tfloat eyeZ = -width / 2.0 / tan(fov_h*0.5);\n\tvec3 eyeOrigin = vec3(width*0.5, height*0.5, eyeZ);\n\tfloat fov_v = atan(height*0.5, eyeZ)*2.0;\n\n    vec3 sphereOrigin = vec3(iMouse.xy, 500.0);\n    float sphereRadius = 200.0;\n    vec3 eyeVec = getEyeVec(fragCoord.xy, eyeOrigin);\n    vec3 eyeSphere = eyeOrigin-sphereOrigin;\n    \n    //DEBUG\n    float theta_limit = asin(sphereRadius/length(eyeSphere));\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    //fragColor = vec4(eyeVec(fragCoord.xy, eyeOrigin),1.0);\n\tfragColor = vec4(0.5);    \n    for (float i=0.0; i<1.0; i = i+STEP_SIZE) {\n    \t//vec3 isc = getIntersectionCandidate(sphereOrigin, eyeOrigin, eyeVec, i);\n        vec3 isc = normalize(mix(normalize(eyeVec),normalize(eyeSphere),i));\n        float d =  getDistanceToRay(eyeSphere, eyeVec, isc);\n        vec3 isc_r = xRot(yRot(isc, iTime*1.0),iTime*0.3);\n        vec2 latlon = xyzToLatLon(isc_r);\n        float displacement = texture(iChannel1, latlon).r*100.0;\n        if (d <= sphereRadius + displacement && d > 0.0) {\n            //fragColor = vec4(latlon, 0.0, 1.0);\n            fragColor = texture(iChannel0, latlon).xxxx;\n            //fragColor = vec4((sphereOrigin + isc_r*d)*0.005, 1.0);\n            break;\n        }\n    }\n    \n    //DEBUG\n    //if (angleBetween(-eyeSphere, eyeVec) < theta_limit) {\n    //    fragColor += vec4(0.0, 1.0, 0.0, 0.5);\n    //}\n}","name":"Image","description":"","type":"image"}]}