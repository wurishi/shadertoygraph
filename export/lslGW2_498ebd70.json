{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"cubemap","id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Created by Michael Mara 2013\n// Learning by playing around with raymarching distance fields.\n\n#define PI 3.1415965\n#define FIELD_OF_VIEW_Y (PI * (1.0/4.0)) \n#define CAMERA_DISTANCE (5.0)\n#define MAX_STEP_COUNT 100\n#define DIRECTIONAL_LIGHT_DIRECTION normalize(vec3(1.0, 3.0, 2.0))\n#define LIGHT_BIRADIANCE (2.0)\n#define MAX_RAY_DIST (200.0)\n\n#define radianceMap iChannel0\n#define irradianceMap iChannel1\n\n// Very basic material this time around\nstruct Material {\n    vec3\tlambertian;\n\tfloat\tglossy;\n\tfloat   glossyExponent;\n};\n\n/** \n    The length of the vector v using the L_p norm. \n\tAt p=1, this is Manhattan distance, or taxicab distance\n\tAt p=2, this is Euclidean distance, and the function is equivalent to regular old length()\n\tAt p=âˆž, this is Chebyshev distance, or chessboard distance\n    http://en.wikipedia.org/wiki/Lp_space#The_p-norm_in_finite_dimensions\n\n\tAt p < 1, the unit sphere is no longer convex and naive raymarching gets pretty bad.\n*/\nfloat length_p( vec3 v, float p )\n{\n\t// Sphere just disappears if we don't have this branch. \n\t// Probably not a good idea to be doing the hundredth root of\n\t// the hundredth power of something in floating point on the GPU anyway...\n\tvec3 a = abs(v);\n\tif (p > 50.0) { // Basically infinite...\n\t\treturn max(a.x,max(a.y,a.z));\n\t} else { \n\t\treturn pow( pow(a.x,p) + pow(a.y,p) + pow(a.z,p), 1.0/p );\n\t}\n\t\n}\n\n// Smooth mapping from [0,1] to [1,âˆž] with 0 -> 1, 0.5 -> 2, and 1 -> âˆž, \n// implemented with only elementary math operations.\nfloat getPForLength( float x ) {\n\treturn 1.0/(1.0-x);\t\n}\n\nfloat signedDistanceSphere_p( vec3 point, float radius, float p )\n{\n    return length_p(point, p) - radius;\n}\n\nvec2 map( in vec3 pos )\n{\n    float p = getPForLength(sin(iTime*3.0)*0.5+0.5);\n\tvec2 result = vec2( signedDistanceSphere_p( pos + vec3(0), 1.0, p ), 1.0);\n\treturn result;\n}\n\n// To get the actual partial derivative, divide the result by 2*length(delta)\nfloat getUnnormalizedPartialDerivative(in vec3 position, in vec3 delta) {\n\treturn map(position + delta).x - map(position - delta).x;\t\n}\n\nvec3 calculateNormal(in vec3 position)\n{\n    float epsilon = .001;\n    vec3 normal;\n\t// The normal points in the direction that distance increases the fastest\n    normal.x = getUnnormalizedPartialDerivative(position, vec3(epsilon, 0, 0));\n    normal.y = getUnnormalizedPartialDerivative(position, vec3(0, epsilon, 0));\n    normal.z = getUnnormalizedPartialDerivative(position, vec3(0, 0, epsilon));\n    return normalize(normal);\n}\n// sqrt(3)/3\n#define SQRT_THIRD 0.57735\n\nvec2 castRay( in vec3 rayOrigin, in vec3 rayDirection, in float maxDistance )\n{\n\tfloat epsilon = 0.0001;\n    float stepLength = epsilon*2.0;\n    float distanceAlongRay = 0.0;\n    float material = -1.0;\n    for( int i=0; i < MAX_STEP_COUNT; i++ )\n    {\n        if( abs(stepLength) < epsilon || distanceAlongRay > maxDistance ) continue;//break;\n        distanceAlongRay += stepLength;\n\t    vec2 result = map( rayOrigin + rayDirection * distanceAlongRay );\n        stepLength = result.x * (SQRT_THIRD); // When p=1, this is the miximum value of the ratio length_p/length\n\t    material   = result.y;\n    }\n\n    if( distanceAlongRay > maxDistance ) material = -1.0;\n    return vec2( distanceAlongRay, material );\n}\n\n// When I had other objects, I had other materials... now this is a boring function\nMaterial getMaterialFromID(float materialID) {\t\n\tMaterial chrome;\n\tchrome.lambertian     = vec3(0.3);\n\tchrome.glossy         = 0.3;\n\tchrome.glossyExponent = 60.0;\n\treturn chrome;\n}\n\n\n// Lighting model loosely based on the one in G3D\nvec3 render( in vec3 rayOrigin, in vec3 rayDirection )\n{ \n    vec3 L_o = vec3(0.0);\n    vec2 result = castRay(rayOrigin, rayDirection, (MAX_RAY_DIST));\n    float distance = result.x;\n\tfloat materialID = result.y;\n\tvec3 hitpoint = rayOrigin + rayDirection * distance;\n\tvec3 normal = calculateNormal(hitpoint);\n\tif (materialID > 0.0) {\n\t\tMaterial material = getMaterialFromID(materialID);\n\t\n\t\tvec3 w_i = DIRECTIONAL_LIGHT_DIRECTION;\n\t\t\n\t\t// Mirror reflection vector\n\t\tvec3 w_m = -reflect(-rayDirection, normal);\n\t\t\n\t\t// Integrate over the hemisphere, so there is no factor of 1/pi\n\t\tL_o += texture(irradianceMap, normal, -32.0).rgb * material.lambertian;\n\n\t\t// Glossy environment reflection\n\t\tL_o += texture(radianceMap, w_m).rgb * material.glossy;\t\n\t\t\n\t\tvec3 w_o = -rayDirection;\n\t\tvec3 w_h = normalize(w_i + w_o);\n\t\t\n\t\t// Compute the light contribution from the directional source\n\t\tL_o += max(0.0, dot(normal, w_i)) * LIGHT_BIRADIANCE * \n\t\t\t(material.lambertian / PI + \n\t\t\t pow(max(0.0, dot(normal, w_h)), material.glossyExponent) \n\t\t\t * material.glossy * (material.glossyExponent + 8.0) / (8.0 * PI));\n\t\t\n\t\t\n\t} else {\n\t\tL_o = texture(radianceMap, rayDirection).rgb;\n\t}\n\t\n\treturn L_o;\n}\n\nmat3 lookAt(vec3 target, vec3 translation) {\n    vec3 z = normalize(translation - target);\n    vec3 up = normalize(vec3(0.0, 1.0, 0.0) + z * z.y);\n    vec3 x = normalize(cross(up, z));\n    return mat3(x, cross(z, x), z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n\tfloat tanHalfFieldOfViewY = tan(FIELD_OF_VIEW_Y * 0.5);\n\t\n\t// Quick orbit camera hack, slowly rotates on a path on a sphere of radius 5.\n    vec3 eyeRayOrigin = normalize(vec3(sin(iTime/4.0),sin(iTime/23.0)*1.0,cos(iTime/4.0))) * CAMERA_DISTANCE;\n\t\n\tmat3 M = lookAt(vec3(0.0), eyeRayOrigin);\n    vec3 eyeRayDirection = M * normalize(vec3((fragCoord.xy - iResolution.xy / 2.0), \n                  iResolution.y / ( -2.0 * tanHalfFieldOfViewY)));\n\t\t\n\t\n    vec3 col = render( eyeRayOrigin, eyeRayDirection );\n\n\tcol = sqrt( col ); // Gamma 1/2.0\n    fragColor=vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lslGW2","date":"1380163221","viewed":473,"name":"L_p Unit Sphere","username":"Mx7f","description":"A unit sphere whose length is calculated using the L_p norm for varying p. It oscillates between Manhattan distance (where it's an octahedron) to Chebyshev distance (where it's a cube), passing through a sphere using the Euclidean metric (p=2) on the way.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","distancefield","lp","norm"],"hasliked":0,"parentid":"","parentname":""}}