{"ver":"0.1","info":{"id":"MdtyDl","date":"1520681996","viewed":293,"name":"floating away","username":"stellabialek","description":"spheretraced dancing blob guys inside raytraced spheres","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","motionblur","dof","spheretracing","blending"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1415926535897932384626433832795;\nconst float TWOPI = 2.0 * PI;\nconst float PIHALF = PI / 2.0;\nconst float EPSILON = 0.00001;\nconst float INFINITY = 1000000000.0;\n\nconst int MOTIONBLURSAMPLES = 4;\nconst float MOTIONBLURDELTA = 0.01;\nconst int DOFSAMPLES = 4;\nconst float DOFDELTA = 0.01;\n\nconst float FOCUS = 4.0;\n\nconst int NUMLAYERS = 4;\nconst float[4] LAYERS = float[4](2.0, 4.0, 6.0, 12.0);\n\nconst vec3 ORB = vec3(0.9, 0.4, 0.0);\nconst vec3 GLOW = vec3(1.0, 1.0, 0.0);\nconst vec3 BG = vec3(0.0, 0.1, 0.1);\n\nconst vec2 FOG = vec2(8.0, 20.0);\nconst vec3 MOVEMENT = vec3(0.2,-0.4,0.0);\n\nstruct ray{ vec3 o; vec3 d; };\nstruct result{ float t; vec3 n; };\n\nstruct sphere{ vec3 c; float r; };\nstruct plane{ vec3 n; float d; };\n\nvec3 getRayDirection(vec2 pos, vec2 res, float fov)\n{\n\tfloat fx = tan(radians(fov) * 0.5) / res.x;\n\tvec2 d = (2.0 * pos - res) * fx;\n\treturn normalize(vec3(d, 1.0));\n}\n\nresult intersectPlane(ray r, plane pl)\n{\n\tresult res;\n\tres.t = -INFINITY;\n\n\tfloat d = dot(pl.n, r.d);\n\tif(abs(d) < EPSILON)\n\t\treturn res;\n\tres.t = (-pl.d - dot(pl.n, r.o)) / d;\n\tres.n = pl.n;\n\treturn res;\n}\n\nresult intersectSphere(ray r, sphere s)\n{\n\tresult res;\n\tres.t = -INFINITY;\n\t\n\tvec3 v = r.o - s.c;\n\tfloat vd = dot(v, r.d);\n\tfloat d = vd * vd - (dot(v, v) - s.r * s.r);\n\tif(d < EPSILON)\n\t\treturn res;\n\tfloat q = sqrt(d);\t\n\tres.t = (-vd -q) > 0.0 ? -vd -q : -vd + q;\n\tres.n = normalize((r.o + r.d * res.t) - s.c);\n\treturn res;\n}\n\nfloat rand(float seed)\n{\t\n\treturn fract(sin(seed) * 1231534.9);\n}\n\nfloat rand(vec2 seed)\n{\n\treturn rand(dot(seed, vec2(12.9898, 783.233)));\n}\n\nvec2 rand2D(vec2 seed)\n{\n\tfloat r = rand(seed) * TWOPI;\n\treturn vec2(cos(r), sin(r));\n}\n\nfloat fresnel(vec3 v, vec3 n, float p)\n{\n\treturn clamp(pow(1.0 + dot(v,n),p),0.0,1.0);\n}\n\nfloat specular(vec3 v, vec3 n, vec3 l, float shininess)\n{\n\tvec3 r = reflect(l, n);\n\treturn pow(max(0.0, dot(r, v)), shininess);\n}\n\nvec3 rotateX(vec3 p, float angle)\n{\n\tmat3 r = mat3(1, 0, 0,\n\t\t\t\t\t0, cos(angle), -sin(angle),\n\t\t\t\t\t0, sin(angle), cos(angle));\n\treturn r * p;\n}\n\nvec3 rotateY(vec3 p, float angle)\n{\n\tmat3 r = mat3(cos(angle), 0, sin(angle),\n\t\t\t\t0, 1, 0,\n\t\t\t\t-sin(angle),0 , cos(angle));\n\treturn r * p;\n}\n\nvec3 rotateZ(vec3 p, float angle)\n{\n\tmat3 r = mat3(cos(angle), -sin(angle), 0,\n\t\t\t\tsin(angle), cos(angle), 0,\n\t\t\t\t0, 0, 1);\n\treturn r * p;\n}\n\nfloat distSphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat distanceField(vec3 p, float t, sphere s, float seed)\n{\n\tp -= s.c;\n\n\tfloat rnd = rand(seed*100.0);\n\tt += rnd;\n\tt *= mix(2.0,8.0,rnd);\n\tt *= sign(rand(seed*20.0)-0.5);\n\n\trnd = rand(seed*200.0);\n\tfloat rot = p.y-s.r*0.2;\n\tp = rotateX(p, PI*(rnd-0.5)*0.4 + sin(t)*rot*2.0);\n\tp = rotateZ(p, PI*(rnd-0.5)*0.2 + cos(t)*rot);\n\tp = rotateY(p, t);\n\tvec3 op = p;\n\t\n\tp.y *= 0.8;\n\tp.xz *= 1.1;\n\tfloat body = distSphere(p,s.r*0.5);\n\t\n\tp = op;\n\tp.y -= s.r*0.06;\n\trot = pow(p.x,2.0)*10.0;\n\tp = rotateZ(p, rot*sin(t*2.0));\n\tp = rotateY(p, rot*cos(t*2.0));\n\tp.x *= 0.8;\n\tp.yz *= 3.0;\n\tfloat arms = distSphere(p,s.r*0.5);\n\t\n\tp = op;\n\tp.y -= s.r*0.2;\n\tp.z += s.r*0.4;\n\tp.x *= 2.0;\n\tfloat mouth = distSphere(p,s.r*0.1);\n\t\n\tp = op;\n\tp.yz += s.r*vec2(-0.3,0.3);\n\tvec3 o = s.r*vec3(0.2,0.0,0.0);\n\tfloat eyes = min(distSphere(p+o,s.r*0.1), distSphere(p-o,s.r*0.1));\n\t\n\tfloat d = smin(body,arms,0.008);\n\td = max(d, -mouth);\n\td = max(d, -eyes);\n\treturn d;\n}\n\nvec3 getNormal(vec3 p, float t, sphere s, float rnd)\n{\n\tvec2 d = vec2(0.01, 0.0);\n\tfloat dx = distanceField(p + d.xyy,t,s,rnd)\n\t\t\t\t- distanceField(p - d.xyy,t,s,rnd);\n\tfloat dy = distanceField(p + d.yxy,t,s,rnd)\n\t\t\t\t- distanceField(p - d.yxy,t,s,rnd);\n\tfloat dz = distanceField(p + d.yyx,t,s,rnd)\n\t\t\t\t- distanceField(p - d.yyx,t,s,rnd);\n\treturn normalize(vec3(dx, dy, dz));\n}\n\nfloat getInsideGlow(ray r, vec3 p, float t, sphere s, float rnd)\n{\n\tvec3 n = getNormal(p,t,s,rnd);\t\n\treturn fresnel(r.d,n,2.0);\n}\n\nfloat inside(ray r, float time, sphere s, float rnd)\n{\t\t\n\tfloat t = 0.0;\n\tvec3 p;\t\n\twhile(t <= s.r)\n\t{\n\t\tp = r.o + r.d * t;\n\t\tfloat d = distanceField(p, time, s,rnd);\t\t\n\t\tif(d <= EPSILON) \n\t\t{\n\t\t\tfloat glow = getInsideGlow(r,p,time,s,rnd);\n\t\t\tglow *= 1.0-t/(s.r*2.0);\n\t\t\treturn glow;\n\t\t}\n\t\tt += max(d, t * 0.0001);\n\t}\t\n\treturn 0.0;\n}\n\nvec4 getColor(ray r, result res, float t, float rnd, sphere s)\n{\n\tif(res.t < 0.0)return vec4(0.0);\n\t\n\tr.o = r.o + res.t * r.d;\n\t\t\t\t\n\tvec3 lPos = MOVEMENT*t + vec3(0.0, 2.0, 2.0);\n\tvec3 l = normalize(lPos-r.o);\n\t\n\tfloat glow = inside(r,iTime,s,rnd);\n\tglow *= smoothstep(0.4, 1.0, rand(rnd*40.0));\n\tglow *= 2.0;\n\tglow += (sin((t+TWOPI*rnd)*3.0)+1.0)*0.2;\n\tglow += specular(r.d, res.n, l, 16.0)*0.4;\n\t\n\tvec3 color = ORB + GLOW * glow;\n\t\n\tfloat a = 1.0;\n\ta *= pow(dot(r.d,-res.n),1.5);\n\ta *= rnd;\t\n\ta *=  1.0 - smoothstep(FOG.x,FOG.y,res.t);\n\treturn vec4(color,a);\n}\n\n\nvec3 spheres(ray r, float t, vec3 bg)\n{\n\tr.o += t*MOVEMENT;\n\tvec4 color = vec4(bg,0.0);\n\tfor(int i = 0; i < NUMLAYERS; i++)\n\t{\n\t\tplane pl = plane(vec3(0.0,0.0,-1.0),LAYERS[i]);\n\t\tvec3 p = r.o + intersectPlane(r,pl).t * r.d;\n\t\tp = vec3(floor(p.xy)+vec2(0.5),p.z);\n\t\t\n\t\tfloat rnd = rand(p.xy+float(i));\n\t\t\n\t\tfloat radius = mix(0.01, 0.3, rnd);\t\n\t\tvec2 offset = rand2D(p.xy+float(i));\n\t\toffset.x *= sin(3.0*radius*t+rnd);\n\t\tp.xy += offset*(0.5-radius);\n\t\t\n\t\tsphere s = sphere(p, radius);\t\n\t\tvec4 c = getColor(r,intersectSphere(r, s),t,rnd,s);\n\n\t\tfloat a = c.a*(1.0-color.a);\n\t\tcolor.rgb = mix(color.rgb, c.rgb, a);\n\t\tcolor.a += a;\n\t}\t\n\treturn color.rgb;\n}\n\nvec3 pow3D(vec3 x, float p)\n{\n\treturn vec3(pow(x.x,p),pow(x.y,p),pow(x.z,p));\n}\n\nfloat stars(vec2 uv, float amount, float radius)\n{\n\tuv = uv * amount;\n\tvec2 gridID = floor(uv);\n\tvec2 starPos = vec2(rand(gridID),rand(gridID+1.0));\n\tstarPos = (starPos - 0.5) * 2.0;\n\tstarPos = vec2(0.5) + starPos * (0.5 - radius * 2.0);\n\tfloat stars = distance(fract(uv), starPos);\n\tfloat size = rand(gridID)*radius;\n\tstars = 1.0 - smoothstep(0.0, size + radius, stars);\n\treturn stars;\n}\n\nvec3 background(vec2 uv)\n{\n\tfloat f = 1.0-(uv.y+1.0)/2.0;\n\tf += stars(uv, 4.0, 0.06)*0.3;\n\tvec3 bg = mix(pow3D(BG,4.0), BG, f/1.3);\n\treturn bg;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 coord = fragCoord.xy;\n\tvec2 uv = vec2(2.0*coord - iResolution.xy)/iResolution.y;\n\tray r;\n\tr.o = vec3(0.0);\n\tr.d = getRayDirection(coord,iResolution.xy, 60.0);\n\t\t\n\tvec3 fp = r.o + intersectPlane(r,plane(vec3(0.0,0.0,-1.0),FOCUS)).t*r.d;\n\t\n\tvec3 bg = background(uv);\n\tvec3 color = vec3(0.0);\n\tfloat total;\n\tfor(int i = 0; i < MOTIONBLURSAMPLES; i++)\n\t{\n\t\tfloat t = iTime - MOTIONBLURDELTA*float(i);\n\t\tfloat falloff = pow(0.8, float(i));\n\t\ttotal += falloff;\t\n\t\tvec3 c = spheres(r,t,bg);\n\t\tfor(int j = 0; j < DOFSAMPLES; j++)\n\t\t{\n\t\t\tray r;\n\t\t\tr.o.xy = rand2D(vec2(float(j),rand(float(j))))*DOFDELTA;\n\t\t\tr.d = normalize(fp - r.o);\n\t\t\tc += spheres(r,t,bg);\n\t\t}\n\t\tcolor += c*falloff;\n\t}\n\tcolor /= total*float(DOFSAMPLES+1);\n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}