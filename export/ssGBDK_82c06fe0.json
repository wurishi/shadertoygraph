{"ver":"0.1","info":{"id":"ssGBDK","date":"1658854826","viewed":101,"name":"Smooth Ellipse","username":"Ni2Be","description":"Two approaches to make a smooth-edged ellipse. \nThe original intent was to create fall-off-maps -> for that it's nice to have the option to render parts of the ellipse in multiple drawcalls (use of tiling and offset) and to switch between both approaches.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ellipse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// In mainImage:\n// If equalSmoothness is set to 1.0 the ellipse will have an equal border\n// that is smoothened.\n// If it is set to 0.0 the smoothness to the longer radius will be thicker.\n// Anything inbetween will mix both results.\n\n// Animate will alternate equalSmoothness between 0.0 and 1.0\n#define ANIMATE\n\n// Makes border visible\n//#define MAKE_BORDER_VISIBLE\n\n\nfloat inEllipseSmooth(vec2 pos, vec2 radiusXY, float equalSmoothness, float smoothness, float varyingSmoothnessAmplifier, float tiling, vec2 offset)\n{\n    pos = pos / iResolution.xy;\n    float smoothnessSqr = smoothness * tiling * smoothness * tiling;\n\n    vec2 center = -offset + tiling / 2.0;\n    pos -= center;\n\n// ---------------------------------- Equal border\n    float resultEqualBorder; \n    float dist = ellipseDistanceExact(pos, radiusXY * tiling);\n\n    if (dist > 0.0) \n        resultEqualBorder = 0.0;\n    else if (dist < -smoothness) \n        resultEqualBorder = 1.0;\n    else \n#ifdef MAKE_BORDER_VISIBLE\n        resultEqualBorder = 0.5;\n#else\n        resultEqualBorder = smoothstep(0.0, -smoothness, dist);\n#endif\n\n// ---------------------------------- Varying border\n    float resultVaryingBorder;\n    float tilingSqr = tiling * tiling;\n    float outerRatio = 1.0 * tilingSqr;\n    float innerRatio = (1.0 - smoothness * varyingSmoothnessAmplifier) * tilingSqr;\n    \n    vec2 radXY = (pos * pos) / (radiusXY * radiusXY);\n    \n    dist = (radXY.x + radXY.y);\n\n    if (dist > outerRatio) \n        resultVaryingBorder = 0.0;\n    else if (dist < innerRatio) \n        resultVaryingBorder = 1.0;\n    else \n#ifdef MAKE_BORDER_VISIBLE\n        resultVaryingBorder = 0.5;\n#else\n        resultVaryingBorder = smoothstep(outerRatio, innerRatio, dist);\n#endif\n\n// ---------------------------------- Mix\n    return mix(resultEqualBorder, resultVaryingBorder, equalSmoothness);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float equalSmoothness = 0.5;\n\n    /* \n    tiling should define how many full textures should be needed to\n    render the full ellipse:\n    tiling := 1 => 1 texture\n    ____\n    |  |\n    ̅ ̅ ̅ ̅ \n    tiling := 2 => 2 * 2 = 4 textures\n    _______\n    |  |  |\n    ̅ ̅ ̅ ̅ ̅ ̅ ̅\n    |__|__|\n    \n    */\n    float tiling = 1.0;\n    vec2 offset = vec2(.0, .0);\n        \n    vec2 radiusXY = vec2(0.5, 0.3);\n    float smoothness = 0.2;\n    float varyingSmoothnessAmplifier = 3.0;\n    \n#ifndef ANIMATE\n    fragColor = vec4(vec3(inEllipseSmooth(fragCoord.xy, radiusXY, equalSmoothness, smoothness, varyingSmoothnessAmplifier, float(tiling), offset)), 1.0);\n#else\n    equalSmoothness = (1.+ cos(iTime * 2.0)) / 2.0;\n    fragColor = vec4(vec3(inEllipseSmooth(fragCoord.xy, radiusXY, equalSmoothness, smoothness, varyingSmoothnessAmplifier, float(tiling), offset)), 1.0);\n#endif\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// The MIT License\n// Copyright © 2015 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// see: https://www.shadertoy.com/view/4lsXDN\nfloat ellipseDistanceExact(vec2 p, vec2 ab)\n{\n    // symmetry\n\tp = abs( p );\n\n    // find root with Newton solver\n    vec2 q = ab*(p-ab);\n\tfloat w = (q.x<q.y)? 1.570796327 : 0.0;\n    for( int i=0; i<5; i++ )\n    {\n        vec2 cs = vec2(cos(w),sin(w));\n        vec2 u = ab*vec2( cs.x,cs.y);\n        vec2 v = ab*vec2(-cs.y,cs.x);\n        w = w + dot(p-u,v)/(dot(p-u,u)+dot(v,v));\n    }\n    \n    // compute final point and distance\n    float d = length(p-ab*vec2(cos(w),sin(w)));\n    \n    // return signed distance\n    return (dot(p/ab,p/ab)>1.0) ? d : -d;\n}\n\n","name":"Common","description":"","type":"common"}]}