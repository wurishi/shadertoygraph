{"ver":"0.1","info":{"id":"3dlSz2","date":"1551705608","viewed":2462,"name":"Grid Landscape","username":"postrediori","description":" A retro futuristic dynamic landscape based on 'Sunset In a Cyber World' by Flyguy: https://www.shadertoy.com/view/4dt3RX\n\nJust wanted to have a dynamic grid landscape, so I reduced the scene for sphere marching to a minimum and added dynamic height.","likes":46,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","grid","retro","landscape"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Raymarch settings\n\n#define MIN_DIST 0.001\n#define MAX_DIST 32.0\n#define MAX_STEPS 96\n#define STEP_MULT 0.9\n#define NORMAL_OFFS 0.01\n#define FOCAL_LENGTH 0.8\n\n//Scene settings\n\n//Colors\n#define GRID_COLOR_1 vec3(0.00, 0.05, 0.20)\n#define GRID_COLOR_2 vec3(1.00, 0.20, 0.60)\n\n//Parameters\n#define GRID_SIZE 0.20\n#define GRID_LINE_SIZE 1.25\n\n//Object IDs\n#define SKYDOME 0.\n#define FLOOR 1.\n\nfloat pi = atan(1.0) * 4.0;\nfloat tau = atan(1.0) * 8.0;\n\nstruct MarchResult\n{\n    vec3 position;\n    vec3 normal;\n    float dist;\n    float steps;\n    float id;\n};\n\n//Returns a rotation matrix for the given angles around the X,Y,Z axes.\nmat3 Rotate(vec3 angles)\n{\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\n    return rotX * rotY * rotZ;\n}\n\n//==== Distance field operators/functions by iq. ====\nvec2 opU(vec2 d1, vec2 d2)\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nvec2 opS(vec2 d1, vec2 d2)\n{\n    return (-d1.x > d2.x) ? d1*vec2(-1,1) : d2;\n}\n\nvec2 sdSphere(vec3 p, float s, float id)\n{\n  return vec2(length(p) - s, id);\n}\n\nvec2 sdPlane(vec3 p, vec4 n, float id)\n{\n  // n must be normalized\n  return vec2(dot(p,n.xyz) + n.w, id);\n}\n\nvec2 heightmapNormal(vec2 p)\n{\n    return vec2(sin(p.x+iTime*0.25)*0.15, sin(p.y-iTime*0.125)*0.15);\n}\n\n//Distance to the scene\nvec2 Scene(vec3 p)\n{\n    vec2 d = vec2(MAX_DIST, SKYDOME);\n    \n    d = opU(sdPlane(p, normalize(vec4(heightmapNormal(p.xy),-1, 0)), FLOOR), d);\n    \n\treturn d;\n}\n\n//Surface normal at the current position\nvec3 Normal(vec3 p)\n{\n    vec3 off = vec3(NORMAL_OFFS, 0, 0);\n    return normalize\n    ( \n        vec3\n        (\n            Scene(p + off.xyz).x - Scene(p - off.xyz).x,\n            Scene(p + off.zxy).x - Scene(p - off.zxy).x,\n            Scene(p + off.yzx).x - Scene(p - off.yzx).x\n        )\n    );\n}\n\n//Raymarch the scene with the given ray\nMarchResult MarchRay(vec3 orig,vec3 dir)\n{\n    float steps = 0.0;\n    float dist = 0.0;\n    float id = 0.0;\n    \n    for(int i = 0;i < MAX_STEPS;i++)\n    {\n        vec2 object = Scene(orig + dir * dist);\n        \n        //Add the sky dome and have it follow the camera.\n        object = opU(object, -sdSphere(dir * dist, MAX_DIST, SKYDOME));\n        \n        dist += object.x * STEP_MULT;\n        \n        id = object.y;\n        \n        steps++;\n        \n        if(abs(object.x) < MIN_DIST * dist)\n        {\n            break;\n        }\n    }\n    \n    MarchResult result;\n    \n    result.position = orig + dir * dist;\n    result.normal = Normal(result.position);\n    result.dist = dist;\n    result.steps = steps;\n    result.id = id;\n    \n    return result;\n}\n\n//Scene texturing/shading\nvec3 Shade(MarchResult hit, vec3 direction, vec3 camera)\n{\n    vec3 color = vec3(0.0);\n\n    if(hit.id == FLOOR)\n    {\n        vec2 uv = abs(mod(hit.position.xy + GRID_SIZE/2.0, GRID_SIZE) - GRID_SIZE/2.0); \n        \n        uv /= fwidth(hit.position.xy);\n        \n        float riverEdge = 1.0; //dfRiver(hit.position, 0.0).x / fwidth(hit.position.xy).x;\n                                                       \n        float gln = min(min(uv.x, uv.y), riverEdge) / GRID_SIZE;\n        \n    \tcolor = mix(GRID_COLOR_1, GRID_COLOR_2, 1.0 - smoothstep(0.0, GRID_LINE_SIZE / GRID_SIZE, gln));\n    } \n    \n    //Distance fog\n    color *= 1.0 - smoothstep(0.0, MAX_DIST*0.9, hit.dist);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    //Camera stuff   \n    vec3 angles = vec3(0);\n    \n    //Auto mode\n    if(iMouse.xy == vec2(0,0))\n    {\n        angles.y = tau * (1.4 / 8.0);\n        angles.x = tau * (3.9 / 8.0) + sin(iTime * 0.1) * 0.3;\n    }\n    else\n    {    \n    \tangles = vec3((iMouse.xy / iResolution.xy) * pi, 0);\n        angles.xy *= vec2(2.0, 1.0);\n    }\n    \n    angles.y = clamp(angles.y, 0.0, 15.5 * tau / 64.0);\n    \n    mat3 rotate = Rotate(angles.yzx);\n    \n    vec3 orig = vec3(0, 0,-2) * rotate;\n    \n    vec3 dir = normalize(vec3(uv - res / 2.0, FOCAL_LENGTH)) * rotate;\n    \n    //Ray marching\n    MarchResult hit = MarchRay(orig, dir);\n    \n    //Shading\n    vec3 color = Shade(hit, dir, orig);\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}