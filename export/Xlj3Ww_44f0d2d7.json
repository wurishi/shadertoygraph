{"ver":"0.1","info":{"id":"Xlj3Ww","date":"1429561357","viewed":204,"name":"heyx3 Cloud Raymarcher","username":"heyx3","description":"Playing around with the idea of raymarching through transparent materials with variable density. Still a WIP.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","clouds"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"//Z axis is height.\n\n\n#define N_ITERATIONS 50\n#define FOG_COLOR vec3(0.8, 0.75, 0.7)\n#define SUN_COLOR vec3(0.9, 0.9, 0.0)\n#define LIGHT_DIR normalize(vec3(1.0, -1.0, -0.4))\n\n\nvec3 getVoroniCenter(vec3 minGridCorner)\n{\n    return mix(minGridCorner, minGridCorner + 1.0,\n               texture(iChannel0, minGridCorner.xy * 454.232 + minGridCorner.z * 35.151).xyz);\n}\nfloat getDensityLayer(vec3 pos)\n{\n    const float gridSize = 0.8;\n    vec3 gridPos = pos / gridSize;\n    \n    vec3 minGridCorner = floor(gridPos);\n    \n    float minDist = 999999.0;\n    for (int x = 0; x < 3; ++x)\n    {\n        for (int y = 0; y < 3; ++y)\n        {\n            for (int z = 0; z < 3; ++z)\n            {\n                vec3 voroniPos = gridSize *\n                    \t\t\t getVoroniCenter(minGridCorner +\n                                                 vec3(float(x - 1), float(y - 1), float(z - 1)));\n                minDist = min(minDist, distance(pos, voroniPos));\n            }\n        }\n\t}\n    \n    const float maxDist = 3.3;\n    float density = clamp(minDist / maxDist, 0.1, 1.0);\n    \n    density *= 1.0 - step(mix(2.5, 4.5,\n                              pow(texture(iChannel0, pos.xy * 0.005 - (pos.z * 0.009 * -fract(iTime * 0.1))).r, 0.3)),\n                          pos.z);\n \n    return density;\n}\nfloat getDensity(vec3 pos)\n{\n    return getDensityLayer(pos * vec3(0.5, 0.5, 1.0));\n}\nvec3 getNormal(vec3 pos)\n{\n    const vec2 epsilon = vec2(0.0, 0.01);\n    \n    float myDensity = getDensity(pos);\n    return normalize(vec3(getDensity(pos + epsilon.yxx) -\n                              getDensity(pos - epsilon.yxx),\n                     \t  getDensity(pos + epsilon.xyx) -\n                              getDensity(pos - epsilon.xyx),\n                     \t  getDensity(pos + epsilon.xxy) -\n                              getDensity(pos - epsilon.xxy)));\n}\n\nfloat colorSurface(vec3 pos, float tLerp)\n{\n    return 1.0;\n    \n    \n    //Calculate lighting.\n    const float ambient = 0.1,\n                diffuse = 1.0 - ambient;\n    float dotted = max(0.0, dot(-LIGHT_DIR, getNormal(pos)));\n    float brightness = ambient + (diffuse * dotted);\n        \n    return brightness;\n}\n\nvec3 colorSky(vec3 dir)\n{\n    float heightLerp = (0.5 + (0.5 * dot(dir, vec3(0.0, 0.0, 1.0)))),\n          sunLerp = pow(0.5 + (0.5 * dot(dir, -LIGHT_DIR)), 64.0);\n    return mix(mix(vec3(0.2), FOG_COLOR, heightLerp),\n               SUN_COLOR,\n               sunLerp);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Cam data.\n    const float turnSpeed = 0.01;\n    float moveAmount = (iMouse.y * 0.1) + (iTime * 1.3);\n    vec3 pos = vec3(vec2(moveAmount), 4.8);\n    vec3 forward = normalize(vec3(sin(iMouse.x * turnSpeed), cos(iMouse.x * turnSpeed), -0.5)),\n         up = vec3(0.0, 0.0, 1.0),\n         side = cross(forward, up);\n    \n    //Ray data.\n    vec2 uv = fragCoord / iResolution.xy,\n         screenXY = -1.0 + (2.0 * uv);\n    vec3 start = pos + forward +\n        \t\t (up * screenXY.y) +\n        \t\t (side * screenXY.x * iResolution.x / iResolution.y);\n    vec3 dir = normalize(start - pos);\n    vec3 end = start + dir;\n    \n    //March the ray. Accumlate color as the ray passes through the clouds.\n    float t = 0.0,\n          tIncrement = 0.01;\n    const float tIncrementIncrement = 0.002;\n    fragColor = vec4(colorSky(dir), 1.0);\n    for (int i = 0; i < N_ITERATIONS; ++i)\n    {\n        vec3 rayPos = mix(start, end, t);\n        \n        float density = getDensity(rayPos);\n        fragColor = mix(fragColor,\n                        vec4(1.0),//vec4(colorSurface(rayPos, t)),\n                        pow(density, 2.0));\n        \n        \n        t += tIncrement;\n        tIncrement += tIncrementIncrement;\n    }\n}","name":"","description":"","type":"image"}]}