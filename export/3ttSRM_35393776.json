{"ver":"0.1","info":{"id":"3ttSRM","date":"1580754326","viewed":143,"name":"Colourful Voronoi Noise","username":"Neebz","description":"Probably not the best or fastest (actually it's definitly not), but it's my implementation of the Voronoi noise algorithm.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define timeScale 1.\n#define gridSize 5.\n#define edgeThickness .1\n\nfloat N21(vec2 p){\n    p = fract(p*vec2(233.34,851.73));\n    p += dot(p,p+23.45);\n    return fract(p.x*p.y);\n}\n\nvec2 N22(vec2 p){\n    float n = N21(p);\n    return vec2(n, N21(p + n));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.);\n\n    uv *= gridSize;\n    vec2 gv = fract(uv) - .5;\n    vec2 id = floor(uv);    \n\n    \n    float shortestDist = 100.;    \n    vec2 index = vec2(0.);\n    vec2 shortestPos = vec2(0.);\n    \n    //First loop - Find the closest point to the current grid uv.\n    for(float y = -1.; y <= 1.; y++){\n        for(float x = -1.; x <= 1.; x++){            \n            vec2 offs = vec2(x,y);\n            \n            vec2 n = N22(id + offs);\n            vec2 p = offs + sin(n * iTime * timeScale) * 0.5;\n            float d = length(gv - p);\n            \n            //If the length from the grid uv to the point is less than\n            //the current shortest, make that the new shortest.\n            if (d < shortestDist) {\n                shortestDist = d;\n                index = id + offs;\n                shortestPos = p;\n            }\n        }\n    }\n    \n    //Second loop - find the distance from each grid uv, to the edge of the current index,\n    //in order to draw this edge a solid colour.\n    for(float y = -1.; y <= 1.; y++){\n        for(float x = -1.; x <= 1.; x++){   \n            vec2 offs = vec2(x,y);            \n            vec2 n = N22(id + offs);\n            \n            if (index != id+offs){\n                //The point in cell at offset\n                vec2 p = offs + sin(n * iTime * timeScale) * 0.5;\n                //Distance between current cell point, and point in cell at offset\n                vec2 between = p - shortestPos;                \n                //Center between current cell point and offset point\n                vec2 center = shortestPos + between * .5;\n                //The normalized vector from current cell point, to center point\n                vec2 diffVec = normalize(between);\n                //Vector from current grid uv to center point\n                vec2 vecToCenter = center - gv;\n                //If dot product between the vector from the grid uv to the center\n                //and the normalized vector from the current cell point to the center\n                //is less than some value, set the color to black.\n                float distToEdge = dot(vecToCenter, diffVec);\n                if (distToEdge < edgeThickness){\n                col -= smoothstep(edgeThickness, edgeThickness * .8, distToEdge);\n                }\n            }            \n        }\n    }\n    //Some mathmatical screwery to display random colours for each distance cell\n    col.rgb += vec3(N21(index), N21(vec2(fract(index.x * 23.4234), index.y * .4324)), N21(vec2(index.x, fract(index.y * 54.3434))));\n\n    \n    //Draws gridlines\n    //if (gv.x > .48 || gv.x < -.48 || gv.y > .48 || gv.y < -.48) col.r = 1.;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}