{"ver":"0.1","info":{"id":"stsfzM","date":"1650674869","viewed":146,"name":"sRGB Tonemapper","username":"TinyTexel","description":"An attempt at building a somewhat decent sRGB tonemapper that doesn't screw up the hues before blending towards white.","likes":1,"published":1,"flags":48,"usePreview":1,"tags":["tonemapping","tonemapper"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n    My attempt at building a minimalist, hue-preserving sRGB tonemapper.\n    \n    Tab â†¹ - toggle knobs marix on/off\n    \n    knobs:\n    \n        shoulderStrength desatBias\n\n        toeStrength      contrast\n\n                                    exposure\n*/\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\nfloat ReadKey      (int keyCode) {return texelFetch(iChannel1, ivec2(keyCode, 0), 0).x;}\nfloat ReadKeyToggle(int keyCode) {return texelFetch(iChannel1, ivec2(keyCode, 2), 0).x;}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(iChannel0, ivec2(cx, cy), 0).w;}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\nfloat ReadVar(inout int x) { return ReadVar(x++, 0); }\nvec4 ReadVar4(inout int x) { return ReadVar4(x++, 0); }\n\nvec4 AA[8], BB[8], CC[8], DD[8];\nvec4 A0, B0, C0, D0;\nvec4 A1, B1, C1, D1;\n\n//======================================================================//\n//////////////////////////////////////////////////////////////////////////\n\n\nfloat Pow2Toe(float x, float s, float end)\n{\n    if(x < end)\n    {\n        x *= 1.0 / end;\n        \n        return mix(x, x*x, s) * end; \n    }\n    else\n    {\n        float d = 1.0 + s;\n        \n        return x * d + (end - end * d);\n    }\n}\n\nfloat Reinhard(float x, float s, float start)\n{    \n    if(x <= start) return x;\n \n    float sx = 1.0 / (1.0 - start);\n    float ax = -start * sx;\n    \n    float sy = 1.0 - start;\n    float ay = start;\n    \n    x = x * sx + ax;\n    \n    x += x * x * s;\n    \n    float y = x / (x + 1.0);\n    \n    return y * sy + ay;\n}\n\n// x: [0, inf], s: (-1, 1]\nfloat SoftClip(float x, float s)\n{\n    return (1.0 + x - sqrt(1.0 - 2.0 * s * x + x*x)) / (1.0 + s);\n}\n\nfloat Bias(float x, float bias)\n{\n    float b = 1.0/bias;\n    \n    return x / ((2.0 - b) * x + b - 1.0);\n}\n\nvec3 Tonemap_sRGB(vec3 col, float toeStrength, vec2 linSeg, float shoulderStrength, float desatBias)\n{\n    vec3 wL = vec3(0.2126, 0.7152, 0.0722);\n    \n    float L0 = max(0.0, dot(col, wL));\n\n    // transfer function (replace as desired)\n    float L0t = Reinhard(Pow2Toe(L0, toeStrength, linSeg.x), \n                                shoulderStrength, linSeg.y);\n\n    col *= L0t / L0;\n\n\n    float L1 = max(col.r, max(col.g, col.b));\n\n    float L1t = SoftClip(L1, 0.9);\n\n    col *= L1t / L1;\n\n\n    float L2 = dot(col, wL);\n\n    float sat = (L2 - L0t) / (L2 - 1.0);\n    \n    sat = Bias(sat, desatBias);\n    \n    col = mix(col, vec3(1.0), sat);\n\n\n    return col;\n}\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    vec2 uv = uv0 - 0.5;\n    vec2 tex = uv0 / iResolution.xy;\n\n    Resolution = iResolution;\n    \n    ivec2 uvi = ivec2(uv);\n    \n    int I = 0;\n    vec4 iMouse     = ReadVar4(I);\n    vec4 mouseAccu  = ReadVar4(I);\n    vec4 wasdAccu   = ReadVar4(I);\n    float frameAccu = ReadVar (I);\n    ActiveKnobMatId = int(ReadVar(I));\n\n    for(int i = 0; i < KnobMatCount; ++i)\n    {\n        int KnobMatId = i;\n        ivec2 KnobMatStateBuffOrigin = ivec2(KnobMatId * 4, KnobMatStateBuffY0);\n\n        #define READ(xy) texelFetch(iChannel0, xy + KnobMatStateBuffOrigin, 0).w;\n        \n        for(int j = 0; j < 4; ++j)\n        {\n            AA[i][j] = READ(ivec2(j, 0));\n            BB[i][j] = READ(ivec2(j, 1));\n            CC[i][j] = READ(ivec2(j, 2));\n            DD[i][j] = READ(ivec2(j, 3));\n        }\n        \n        #undef READ\n    }\n        \n    A0 = AA[ActiveKnobMatId]; B0 = BB[ActiveKnobMatId]; C0 = CC[ActiveKnobMatId]; D0 = DD[ActiveKnobMatId];\n    //A0 = AA[0]; B0 = BB[0]; C0 = CC[0]; D0 = DD[0];\n    //A1 = AA[1]; B1 = BB[1]; C1 = CC[1]; D1 = DD[1];\n\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    float hue;\n    {\n    \tfloat q = 32.0*1.0*0.5;\n    \thue = (floor(tex.x * q) + 0.) / q;\n    }\n    \n    float intensity;\n    {\n    \tfloat q = 16.0*0.5;\n    \tintensity = (floor(tex.y * q) + 0.) / q;\n    }\n    \n    float exposure = exp2(D0.w * 8.0);\n    \n   #if 1\n    hue = tex.x;\n    intensity = tex.y;\n    intensity *= intensity * intensity;\n    intensity *= exposure * 4.0;\n   #endif\n    \n    col = Hue_to_RGB(hue);\n    \n    col *= intensity;\n    \n    \n    float shoulderStrength = A0.x;\n    float toeStrength = B0.x;\n    float desatBias = A0.y * 0.5 + 0.5;\n    float contrast = B0.y;\n    col = Tonemap_sRGB(col, shoulderStrength, vec2(0.18), toeStrength, desatBias);\n  \n    col = clamp01(col);\n\n\n    #if 0\n    col = sRGB_GammaEncode(col);\n    #else\n    col = pow(col, vec3(1.0/2.2));\n    #endif\n    \n    #if 1\n    // contrast\n    {\n        vec3 c = 1.0 - col;\n        c = 1.0 - c * c;\n        col = mix(col, c*c, contrast);\n    }\n    #endif  \n    \n   #if 1\n    if(ReadKeyToggle(KEY_TAB) == 0.0 && (IsKnobUITexel(uv) || IsNumValueUITexel(uv)))\n    {    \n        col = pow(col, vec3(2.2));\n        \n        col = mix(col, col * 0., GetKnobUIMask(uv));\n\n        // knobs\n        vec3 ui = texelFetch(iChannel0, ivec2(uv), 0).rgb;\n\n        vec3 kcol = vec3(1.0);\n        if(ui.z <  0.0) kcol = vec3(0.0, 0.0, 0.0); else\n        if(ui.z == 1.0) kcol = vec3(1.0, 0.0, 0.0); else\n        if(ui.z == 2.0) kcol = vec3(0.0, 0.5, 0.0); else\n        if(ui.z == 3.0) kcol = vec3(0.0, 0.0, 1.5); else\n        if(ui.z == 4.0) kcol = vec3(0.9, 0.9, 0.0); else\n        if(ui.z == 5.0) kcol = vec3(0.0, 0.8, 0.8); else\n        if(ui.z == 6.0) kcol = vec3(0.8, 0.0, 0.8);\n    \n       #if 0\n        col = mix(col, kcol, ui.y);\n        col = mix(col, vec3(0.99), ui.x);\n       #else\n        col = mix(col, vec3(0.0), ui.y);\n        col = mix(col, mix(kcol, vec3(1.0), 0.25)*0.8, ui.x);\n       #endif\n       \n        col = pow(col, vec3(1.0/2.2));\n    }\n   #endif \n   \n    outCol = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 Resolution;\n\n/* http://keycode.info/ */\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_TAB 9\n#define KEY_CTRL 17\n#define KEY_SHIFT 16\n#define KEY_SPACE 32 \n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n#define KEY_Q 81\n#define KEY_E 69\n#define KEY_R 82\n#define KEY_T 84\n#define KEY_Z 90\n#define KEY_U 85\n#define KEY_I 73\n#define KEY_O 79\n#define KEY_P 80\n#define KEY_F 70\n#define KEY_G 71\n#define KEY_H 72\n#define KEY_J 74\n#define KEY_K 75\n#define KEY_L 76\n#define KEY_Y 89\n#define KEY_X 88\n#define KEY_C 67\n#define KEY_V 86\n#define KEY_B 66\n#define KEY_N 78\n#define KEY_M 77\n\n#define KEY_N0 48\n#define KEY_N1 49\n#define KEY_N2 50\n#define KEY_N3 51\n#define KEY_N4 52\n#define KEY_N5 53\n#define KEY_N6 54\n#define KEY_N7 55\n#define KEY_N8 56\n#define KEY_N9 57\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nvec3 AngToVec(vec2 ang)\n{\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    return vec3(cosPhi * cosTheta, \n                         sinTheta, \n                sinPhi * cosTheta); \n}\n\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat cubic(float x) { return x*x*(3.0-2.0*x); }\n\n\nfloat sRGB_GammaEncode(float c)\n{\n    return c > 0.0031308 ? pow(c, 1.0/2.4) * 1.055 - 0.055 : c * 12.92;\n}\n\nfloat sRGB_GammaDecode(float c)\n{\n    return c > 0.04045 ? pow(c / 1.055 + 0.055/1.055, 2.4) : c / 12.92;\n}\n\nvec3 sRGB_GammaEncode(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.0031308)), pow(rgb, vec3(1.0/2.4)) * 1.055 - 0.055, rgb * 12.92);\n}\n\nvec3 sRGB_GammaDecode(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.04045)), pow(rgb / 1.055 + 0.055/1.055, vec3(2.4)), rgb / 12.92);\n}\n\n\nvec3 Hue_to_RGB(float hue)\n{\n    float H6 = hue * 6.0;\n    \n\tfloat R =       abs(H6 - 3.0) - 1.0;\n\tfloat G = 2.0 - abs(H6 - 2.0);\n\tfloat B = 2.0 - abs(H6 - 4.0);\n    \n\treturn clamp(vec3(R, G, B), 0.0, 1.0);\n}\n\nvec3 HSV_to_RGB(vec3 hsv)\n{\n    return (Hue_to_RGB(hsv.x) * hsv.y + vec3(1.0 - hsv.y)) * hsv.z;\n}\n\n\nfloat RGB_to_Hue(vec3 rgb)\n{\n    float v = (rgb.r - rgb.g - rgb.b) *  (1.0/6.0) + (1.0/3.0);\n    \n    return (rgb.b < rgb.g ? -v : v) + 0.5;     \n}\n//*/\n\nvec3 RGB_to_HSV(vec3 rgb)\n{\n    float v = max(rgb.r, max(rgb.g, rgb.b));\n    \n    if(v == 0.0) return vec3(0.0);\n    \n    rgb /= v;\n    \n    float ds = min(rgb.r, min(rgb.g, rgb.b));\n    float s = 1.0 - ds;\n    \n    if(ds == 1.0) return vec3(0.0, 0.0, v);\n    \n    rgb = (rgb - ds) / s;\n    \n    float h = RGB_to_Hue(rgb);\n    \n    return vec3(h, s, v);\n}\n\n// ===============================================  KNOB STUFFS  =========================================================================== //\nstruct KnobState\n{\n    vec2 p;\n    vec2 r;\n    bool signed;\n    float colId;\n    \n    float n;\n};\n\nKnobState CreateKnobState(vec2 p, vec2 r, bool signed, float n)\n{\n    KnobState state;\n    state.p = p;\n    state.r = r;\n    state.signed = signed;\n    state.colId = 0.0;\n    state.n = n;\n\n    return state;\n}\n\nint ActiveKnobMatId = 0;\n\nconst int KnobMatCount = 2;// <=== set this to number of matrices you want to use \nconst int KnobMatKnobCount = 16;\nconst int KnobCount = KnobMatKnobCount * KnobMatCount;\n\nconst int KnobMatStateBuffY0 = 4;\n\nconst float KnobOuterRadius = 16.0; \nconst float KnobCircleThick =  4.0; \nconst float KnobPadding     =  4.0; \nconst float KnobSizeTotal   =  2.0 * (KnobOuterRadius + KnobPadding);\nfloat GetKnobMatPosY0() { return Resolution.y*0.5 + (KnobSizeTotal*2.0); } \nfloat GetKnobMatPosY1() { return Resolution.y*0.5 - (KnobSizeTotal*2.0); } \n\nivec2 GetKnobMatStateBuffOrigin()\n{\n    return ivec2(ActiveKnobMatId * 4, KnobMatStateBuffY0);\n}\n\nivec2 GetKnobXY(vec2 uv)\n{\n    int x = int(floor(uv.x / KnobSizeTotal));\n    int y = int(floor((GetKnobMatPosY0() - uv.y) / KnobSizeTotal));\n    \n    if(x < 0 || x >= 4 || y < 0 || y >= 4) return ivec2(-1, -1);\n    \n    return ivec2(x, y);\n}\n\nfloat ReadKnobValue(sampler2D stateBuffer, ivec2 xy)\n{\n    return texelFetch(stateBuffer, GetKnobMatStateBuffOrigin() + xy, 0).w;\n}\n\nbool IsKnobUITexel(vec2 uv)\n{\n    float width = KnobSizeTotal * 4.0;\n\n    if(uv.x < width+4.0 && uv.y > GetKnobMatPosY1()-4.0 && uv.y < GetKnobMatPosY0() + 48.0+2.0)\n    {\n        return true;\n    }\n\n    return false;\n}\n\nfloat GetKnobUIMask(vec2 uv)\n{\n    float width = KnobSizeTotal * 4.0 + 0.0;\n\n    float minY = GetKnobMatPosY1() - 1.0;\n    float maxY = GetKnobMatPosY0() + 48.0 - 2.0;\n\n    float r = 8.0;\n\n    vec2 p = uv - vec2(width, maxY + minY) * 0.5;\n    vec2 b = vec2(width, maxY - minY) * 0.5 - r;\n    vec2 d = max(abs(p) - b, 0.0);\n    \n    return 1.0 - clamp01((dot(d, d) - r*r)*0.05);\n}\n\nbool IsNumValueUITexel(vec2 uv)\n{\n    if(uv.x < 51.0 && uv.y < 17.0) return true;\n}\n\nKnobState CreateMatKnob(ivec2 xy, bool signed, float n, float colId)\n{\n    float x = float(xy.x);\n    float y = float(xy.y);\n    \n    KnobState knob;\n    knob.p.x = 0.5 * KnobSizeTotal + x * KnobSizeTotal;\n    knob.p.y = 0.5 * KnobSizeTotal + y * KnobSizeTotal;\n    \n    knob.p.y = GetKnobMatPosY0() - knob.p.y;\n\n    knob.r = vec2(KnobOuterRadius, KnobCircleThick);\n    knob.signed = signed;\n    knob.colId = colId;\n\n\tknob.n = n;\n    \n    return knob;\n}\n\nbool GetKnob0(ivec2 xy, out KnobState knob)\n{\n    KnobState knob0;\n    knob0.n = 1.25;\n    knob = knob0;\n    \n    if(xy.x < 0 || xy.x > 3 || \n       xy.y < 0 || xy.y > 3) return false;\n\n    if(ActiveKnobMatId < 0 || ActiveKnobMatId >= KnobMatCount) return false;\n\n    int i = xy.x + xy.y * 4;\n    \n    i += ActiveKnobMatId * KnobMatKnobCount;\n    \n    const bool fals = false;\n    const bool IsSigned[] = bool[]\n    (\n        //========  0  ========//\n        fals, true, fals, fals,// A\n        fals, true, fals, fals,// B\n        fals, fals, fals, fals,// C\n        fals, fals, fals, fals,// D\n        \n        //========  1  ========//\n        fals, true, fals, fals,// A\n        fals, true, fals, fals,// B\n        fals, fals, fals, fals,// C\n        fals, fals, fals, fals,// D\n        \n        //========  3  ========//\n        fals, fals, fals, fals,// A\n        fals, fals, fals, fals,// B\n        fals, fals, fals, fals,// C\n        fals, fals, fals, fals,// D\n        \n        false\n    );\n    \n    const float DefaultValue[] = float[]\n    (\n        //======  0  ======//\n        0.5, 0. , 0.0, 0.0,// A \n        0.5, 0. , 0.0, 0.0,// B \n        0.0, 0.0, 0.0, 0.0,// C \n        0.0, 0.0, 0.0, 0.5,// D \n    \n        //======  1  ======//\n        0.5, 0.0, 0.0, 0.0,// A \n        0.5, 0.0, 0.0, 0.0,// B \n        0.0, 0.0, 0.0, 0.0,// C \n        0.0, 0.0, 0.0, 0.5,// D \n        \n        //======  3  ======//\n        0.0, 0.0, 0.0, 0.0,// A \n        0.0, 0.0, 0.0, 0.0,// B \n        0.0, 0.0, 0.0, 0.0,// C \n        0.0, 0.0, 0.0, 0.0,// D \n       \n        0.0\n    );\n    \n    const float ColId[] = float[]\n    (\n        //======  0  ======//\n        0.0, 1.0, -.1, -.1,// A \n        0.0, 2.0, -.1, -.1,// B \n        -.1, -.1, -.1, -.1,// C \n        -.1, -.1, -.1, 4.0,// D\n    \n        //======  1  ======//\n        0.0, 1.0, -.1, -.1,// A \n        0.0, 2.0, -.1, -.1,// B \n        -.1, -.1, -.1, -.1,// C \n        -.1, -.1, -.1, 4.0,// D\n        \n        //======  3  ======//\n        -.1, -.1, -.1, -.1,// A \n        -.1, -.1, -.1, -.1,// B \n        -.1, -.1, -.1, -.1,// C \n        -.1, -.1, -.1, -.1,// D\n        \n        0.0\n    );    \n    \n    knob = CreateMatKnob(xy, IsSigned[i], DefaultValue[i], ColId[i]);\n    \n    return true;\n}\n\n\n// get knob by position id xy\nbool GetKnob(ivec2 xy, sampler2D stateBuffer, bool doInit, out KnobState knob)\n{\n    // fill knob with hardcoded settings\n\tif(!GetKnob0(xy, /*out*/ knob)) return false;\n    \n    // fill in knob value stored in state buffer\n    if(!doInit) knob.n = ReadKnobValue(stateBuffer, xy);\n    \n    return true;\n}\n\n// get knob by uv\nbool GetKnob(vec2 uv, sampler2D stateBuffer, bool doInit, out KnobState knob)\n{\n    ivec2 xy = GetKnobXY(uv);\n    \n    // is position id valid\n    if(xy.x == -1 || xy.y == -1) return false;\n    \n    // does knob actually exist\n    if(!GetKnob0(xy, /*out*/ knob)) return false;\n\n    // does uv lie on knob disk\n    if(SqrLen(uv - knob.p) >= Pow2(knob.r.x + KnobPadding)) return false;\n    \n    // fill in knob value stored in state buffer\n    if(!doInit) knob.n = ReadKnobValue(stateBuffer, xy);\n\n    return true;\n}\n\n\nvec3 Knob(vec2 uv, KnobState state)\n{\n    //if(state.colId < 0.0) return vec3(0.0);\n    if(state.colId < 0.0) { state.n = 0.0; state.r.x *= 0.5; state.r *= 1.5; }\n    \n    uv -= state.p;\n    \n    float v = 0.0;\n    \n    float l = length(uv);\n    \n    v = abs(l - (state.r.x - state.r.y)) - state.r.y;\n    \n    float sh = 1.0;\n    sh = clamp01(v * 0.18);\n    sh = 1.0-(1.0-sh)*(1.0-sh);\n    sh = mix(0., 1.0, sh);\n    v = clamp01(v);\n    \n    v = 1.0 - v;\n    float o;\n    {\n        float a = state.n;\n\n        bool tc = state.signed;\n        if(tc) a = a * 0.5 + 0.5;\n        a *= 2.0;\n        bool ac = a > 1.0;\n        float m = clamp01((ac ? uv.x : -uv.x)+0.5);\n        if(ac) a = a - 1.0;\n\n        m = min(m, clamp01((tc ? 1.0 : -1.0) * dot(AngToVec((1.0-a)*Pi), uv)+0.5));\n        if(!tc && ac) m = 1.0-m;\n       \n        o = m;\n    }\n    \n    float r = v;\n    r = v * mix(0.25, 0.95, o);\n\n    if(state.signed && uv.x < 0.0) { r = v * mix(0.06, 0.6, o);}\n    \n    if(state.colId < 0.0) { r *= 0.25; sh = 1.0; }\n    \n    return vec3(r, 1.0 - sh, state.colId);\n}\n\n// https://www.shadertoy.com/view/4tfBzn\nfloat TextSDF(vec2 p, float glyph, sampler2D glyphBuffer)\n{\n    p = abs(p.x - .5) > .5 || abs(p.y - .5) > .5 ? vec2(0.) : p;\n    return 2. * (texture(glyphBuffer, p / 16. + fract(vec2(glyph, 15. - floor(glyph / 16.)) / 16.)).w - 127. / 255.);\n}\n\nvoid ValueText(inout vec4 col, vec2 uv0, float n, sampler2D glyphBuffer)\n{\n    vec2 p = uv0 * 0.5;\n    \n    vec2 scale = vec2(4., 8.);\n    vec2 t = floor(p / scale);   \n\n    if(t.x < 0.0 || t.x > 5.0 || t.y != 0.0) return;\n    if((n == 0.0 || abs(n) == 1.0) && t.x > 1.0) return;\n    if(t.x == 0.0 && n >= 0.0) return;\n    \n\n    float c = 0.0;\n    \n    if(t.x == 0.0) c = 45.0;\n    else if(t.x == 1.0) c = n == 0.0 ? 48.0 : (abs(n) == 1.0 ? 49.0 : 46.0);\n    else\n    c = abs(n) == 1.0 ? 48.0 : 48.0 + mod(floor(abs(n)*1000.0 * exp2((4.0-t.x) * -(log2(10.0)/log2(2.0)))), 10.0);\n\n    p = (p - t * scale) / scale;\n    p.x = (p.x - 0.5) * 0.5 + 0.5;\n\n    if (c == 0.) return;\n    \n    float sdf = TextSDF(p, c, glyphBuffer);\n    \n    sdf = smoothstep(-0.05, 0.05, sdf);\n\n    col.r = (1.0 - sdf);// * 0.999;\n}\n\nfloat KnobMatIdButtonMat(inout vec4 col, vec2 uv)\n{\n    vec2 uv2 = vec2(uv.x, uv.y - GetKnobMatPosY0());\n    \n    float width = KnobSizeTotal * 4.0;\n    float height = 48.0;\n    float ButtonCountX = 4.0;\n    float ButtonCountY = 2.0;\n\n    if(uv2.x < width && uv2.y >= 0.0 && uv2.y < height)\n    {\n        float wi = width / ButtonCountX;\n        float hi = height / ButtonCountY;\n\n        float ix = 0.0;\n        float iy = 1.0;\n\n        ix = floor(uv2.x / wi);\n        uv2.x = (uv2.x / wi - ix) * wi;\n\n        iy = floor(uv2.y / hi);\n        uv2.y = (uv2.y / hi - iy) * hi;\n        iy = float(ButtonCountY) - 1.0 - iy;\n\n        uv2 -= vec2(wi, hi) * 0.5;\n\n        float buttonSizeMod = 2.0;\n        float l = length(uv2) + buttonSizeMod;\n\n        float ll = min(wi, hi) * 0.5;\n\n        float i = ix + iy * ButtonCountX;\n\n        bool isActive = int(i) == ActiveKnobMatId;\n\n        float buttonOpacity = isActive ? 0.9 : 0.2;\n        float shadowOpacity = isActive ? 0.6 : 0.4;\n\n        if(int(i) >= KnobMatCount) { buttonOpacity *= 0.09; shadowOpacity = 0.0; }\n\n        col.rgb = vec3(smoothstep(ll-3.0, ll-4.5, l)       * buttonOpacity , \n                   pow(smoothstep(ll    , ll-4.0, l), 2.0) * shadowOpacity, .0);\n                   \n        return i;\n    }\n    \n    return -1.0;\n}\n\nfloat KnobMatIdButtonMat(vec2 uv)\n{\n    vec4 col;\n    return KnobMatIdButtonMat(col, uv);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n\n#define KeyBoard iChannel1\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\nfloat ReadKeyToggle(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 2), 0).x;}\n\n#define VarTex iChannel0\n#define OutCol col\n#define OutChannel w\n\n#define WRITEVAR(v, cx, cy) {if(uv.x == float(cx) && uv.y == float(cy)) OutCol.OutChannel = v;}\n#define WRITEVAR2(v, cx, cy) {WRITEVAR(v.x, cx, cy) WRITEVAR(v.y, cx, cy + 1)}\n#define WRITEVAR3(v, cx, cy) {WRITEVAR(v.x, cx, cy) WRITEVAR(v.y, cx, cy + 1) WRITEVAR(v.z, cx, cy + 2)}\n#define WRITEVAR4(v, cx, cy) {WRITEVAR(v.x, cx, cy) WRITEVAR(v.y, cx, cy + 1) WRITEVAR(v.z, cx, cy + 2) WRITEVAR(v.w, cx, cy + 3)}\n\n#define WriteVar(v, x) {WRITEVAR(v, x, 0) ++x;}\n#define WriteVar2(v, x) {WRITEVAR2(v, x, 0) ++x;}\n#define WriteVar3(v, x) {WRITEVAR3(v, x, 0) ++x;}\n#define WriteVar4(v, x) {WRITEVAR4(v, x, 0) ++x;}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec2 ReadVar2(int cx, int cy) {return vec2(ReadVar(cx, cy), ReadVar(cx, cy + 1));}\nvec3 ReadVar3(int cx, int cy) {return vec3(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2));}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\nfloat ReadVar(inout int x) { return ReadVar(x++, 0); }\nvec2 ReadVar2(inout int x) { return ReadVar2(x++, 0); }\nvec3 ReadVar3(inout int x) { return ReadVar3(x++, 0); }\nvec4 ReadVar4(inout int x) { return ReadVar4(x++, 0); }\n\nbool IsKnobStateTexel(vec2 uv)\n{\n    return uv.x < float(KnobMatCount) * 4.0 && uv.y >= float(KnobMatStateBuffY0) && uv.y < float(KnobMatStateBuffY0 + 4);\n}\n\nbool IsActiveTexel(vec2 uv)\n{\n    // state variables\n    if(uv.y < 4.0) return true;\n\n    // knob states\n    if(IsKnobStateTexel(uv)) return true;\n\n    // UI\n    {\n        // numerical value\n        if(IsNumValueUITexel(uv)) return true;\n        \n        if(IsKnobUITexel(uv)) return true;\n    }\n    \n    return false;\n}\n\nbool HandleStateAndDrawUI( out vec4 col, in vec2 uv0 )\n{  \n    Resolution = iResolution;\n    \n    col = vec4(0.0);\n    vec2 uv = uv0 - 0.5;\n   \n    //if(IsActiveTexel(uv) == false) return false;\n    \n    int I = 0;\n    vec4 iMouseLast     = ReadVar4(I);\n    vec4 iMouseAccuLast = ReadVar4(I);\n    vec4 wasdAccuLast   = ReadVar4(I);\n    float frameAccuLast = ReadVar (I);\n    ActiveKnobMatId = int(ReadVar(I));\n    //float numKeyLast    = ReadVar (I);\n    \n    vec2 iMouseClick    = ReadVar2(I);\n    \n    //float numKey = \n    bool isClick = iMouseLast.z < 0.0 && iMouse.z >= 0.0;\n    \n    if(isClick) iMouseClick = iMouse.xy;\n    \n    bool shift = ReadKey(KEY_SHIFT) != 0.0;\n    \n    float kW = ReadKey(KEY_W);\n    float kA = ReadKey(KEY_A);\n    float kS = ReadKey(KEY_S);\n    float kD = ReadKey(KEY_D);\n    \n    float left  = ReadKey(KEY_LEFT);\n    float right = ReadKey(KEY_RIGHT);\n    float up    = ReadKey(KEY_UP);\n    float down  = ReadKey(KEY_DOWN);\n    \n    vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n    \n    bool didInteractUI = false;\n    \n    float knopMouseDelta = mouseDelta.y * (1.0 / 96.0 * (shift ? 0.125 : 1.0));\n     \n    {\n        float i;\n        if((i = KnobMatIdButtonMat(iMouseClick.xy)) >= 0.0)\n        {\n            if(isClick)\n            ActiveKnobMatId = int(i);\n            \n            didInteractUI = true;\n        }\n    }\n        \n    // if current texel holds a knobs state update it if necessary\n    if(IsKnobStateTexel(uv))\n    {\n        int ActiveKnobMatIdTemp = ActiveKnobMatId;\n        \n        ActiveKnobMatId = int(uint(uv.x) / 4u);\n        \n        bool IsKnobMatActuallyActive = ActiveKnobMatId == ActiveKnobMatIdTemp;\n        \n        ivec2 KnobMatStateBuffOrigin = ivec2(ActiveKnobMatId * 4, KnobMatStateBuffY0);\n    \n        KnobState knob;\n    \tif(GetKnob(ivec2(uv) - KnobMatStateBuffOrigin, iChannel0, /*doInit:*/ frameAccuLast == 0.0, /*out*/ knob))\n        {\n            if(!isClick && IsKnobMatActuallyActive && knob.colId >= 0.0)\n            if(SqrLen(iMouseClick.xy - knob.p) < Pow2(knob.r.x))\n            {\n                float n = clamp(knob.n + knopMouseDelta * (knob.signed ? 2.0 : 1.0), knob.signed ? -1.0 : 0.0, 1.0);\n                //n = round(n*32.0)/32.0;\n                knob.n = n;\n                didInteractUI = true;\n            }\n\n            col.w = knob.n;// write knob state\n        }\n        \n        ActiveKnobMatId = ActiveKnobMatIdTemp;\n    }\n    \n    // check for knob interaction (irrespective of whether current texel holds a knobs state or not)\n    float knobVal = 0.0;\n    {\n        KnobState knob;\n        if(GetKnob(iMouseClick.xy, iChannel0, /*doInit:*/ false, /*out*/ knob))\n        {\n            knobVal = knob.n;\n            didInteractUI = true;\n        }\n    }\n\n    // draw knob mat UI\n    {\n        KnobState knob;\n        \n        if(GetKnob(uv0, iChannel0, /*doInit:*/ frameAccuLast == 0.0, /*out*/ knob))\n        {\n            vec3 k = Knob(uv0, knob);\n            col.rgb = k;\n        }\n        \n    \tValueText(col, uv0, knobVal, iChannel2);\n        KnobMatIdButtonMat(col, uv0);\n    }\n    \n\n    \n    bool anyK = false;\n    \n    anyK = anyK || iMouse.z > 0.0;\n    anyK = anyK || shift;\n    anyK = anyK || kW != 0.0;\n    anyK = anyK || kA != 0.0;\n    anyK = anyK || kS != 0.0;\n    anyK = anyK || kD != 0.0;\n    anyK = anyK || left  != 0.0;\n    anyK = anyK || right != 0.0;\n    anyK = anyK || up    != 0.0;\n    anyK = anyK || down  != 0.0;\n    \n    \n    float frameAccu = frameAccuLast + 1.0;\n    //if(anyK) frameAccu = 0.0;\n    \n    \n    vec4 wasdAccu = wasdAccuLast;\n    wasdAccu += vec4(kW, kA, kS, kD);\n    wasdAccu += vec4(up, left, down, right);        \n    \n        \n    bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n    cond0 = cond0 && !didInteractUI;\n    \n    vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n    vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n    \n    vec4 iMouseAccu = iMouseAccuLast + vec4(mouseDelta2, mouseDelta3);\n    \n\n    \n    int J = 0;\n    WriteVar4(iMouse,       J);\n    WriteVar4(iMouseAccu,   J);\n    WriteVar4(wasdAccu,     J);\n    WriteVar(frameAccu,     J);\n    WriteVar(float(ActiveKnobMatId), J);\n\n    WriteVar2(iMouseClick,  J);\n    \n    return true;\n}\n\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{\n    vec2 uv = uv0 - 0.5;\n\n    if(!HandleStateAndDrawUI(col, uv0)) return;\n}\n","name":"Buffer D","description":"","type":"buffer"}]}