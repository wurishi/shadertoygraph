{"ver":"0.1","info":{"id":"fsKyRt","date":"1655393686","viewed":267,"name":"swirling colored gas cloud","username":"pb","description":"fbm color volume march, the \"cloud\" is rotating in the YZ direction, click the mouse on various parts of the screen to change your motion relative to the dust cloud.  perf aweful at 1080p - welcoming suggestions... click near center to align with rotation","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["noise","raymarch","fbm","color"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// philip.bertani@gmail.com\n\n// the dust cloud is swirling around the YZ plane\n// clicking near the center of the screen keeps your motion aligned\n// with the rotation of the dust cloud so you should see vertical motion blur\n// click on the sides and it is more interesting\n\n// performance is aweful on 1080p unless you have a high end GPU\n// any suggestions appreciated...\n\n#define oct 7   //number of fbm octaves\n#define pi  3.14159265\n\nfloat random(vec2 p) {\n    //a random modification of the one and only random() func\n    return fract( sin( dot( p, vec2(12., 90.)))* 1e5 );\n}\n\n\n//this is taken from Visions of Chaos shader \"Sample Noise 2D 4.glsl\"\nfloat noise(vec3 p) {\n    vec2 i = floor(p.yz);\n    vec2 f = fract(p.yz);\n    float a = random(i + vec2(0.,0.));\n    float b = random(i + vec2(1.,0.));\n    float c = random(i + vec2(0.,1.));\n    float d = random(i + vec2(1.,1.));\n    vec2 u = f*f*(3.-2.*f); //smoothstep here, it also looks good with u=f\n    \n    return mix(a,b,u.x) + (c-a)*u.y*(1.-u.x) + (d-b)*u.x*u.y;\n\n}\n\nfloat fbm3d(vec3 p) {\n    float v = 0.;\n    float a = .5;\n    vec3 shift = vec3(100.);  //play with this\n    \n    float angle = pi/2.;      //play with this\n    float cc=cos(angle), ss=sin(angle);  //yes- I know cos(pi/2.)=0.\n    mat3 rot = mat3( cc,  0., ss, \n                      0., 1., 0.,\n                     -ss, 0., cc );\n    for (int i=0; i<oct; i++) {\n        v += a * noise(p);\n        p = rot * p * 2. + shift;\n        a *= .6;  //changed from the usual .5\n    }\n    return v;\n}\n\nmat3 rxz(float an){\n    float cc=cos(an),ss=sin(an);\n    return mat3(cc,0.,-ss,\n                0.,1.,0.,\n                ss,0.,cc);                \n}\nmat3 ryz(float an){\n    float cc=cos(an),ss=sin(an);\n    return mat3(1.,0.,0.,\n                0.,cc,-ss,\n                0.,ss,cc);\n}   \n\nvec3 get_color(vec3 p) {\n    vec3 q;\n    q.x = fbm3d(p);\n    q.y = fbm3d(p.yzx);\n    q.z = fbm3d(p.zxy);\n\n    float f = fbm3d(p + q);\n    \n    return q*f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float tt = iTime / 8.;\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mm = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    vec3 rd = normalize( vec3(uv, -2.) );  \n    vec3 ro = vec3(0.,0.,0.);\n    \n    float delta = 2.*pi/10.;\n    float initm = -.5 * delta;\n    mat3 rot = rxz(-mm.x*delta) * ryz(-mm.y*delta);\n    \n    ro -= rot[2]*iTime*2.;\n    \n    rd = rot * rd;\n    \n    vec3 p = ro + rd;\n    \n    vec3 cc = vec3(0.);\n\n    float stepsize = .034;\n    float totdist = stepsize;\n    \n    for (int i=0; i<50; i++) {\n       vec3 cx = get_color(p);\n       p += stepsize*rd;\n       float fi = float(i);\n       cc += exp(-totdist*totdist*2.)* cx;\n       totdist += stepsize;\n       rd = ryz(.2)*rd;   //yz rotation here\n    }\n    \n    \n    vec3 x2 = ro, x1=vec3(.5,-1.,5.);\n    vec3 x0 = p + abs(cc);\n    \n    float dist_to_line = length( cross( (x0-x1), (x0-x2) ) ) / length( x2 - x1 );\n    \n    cc = .5 + 1.5*(cc-.5);  //more contrast makes nice shimmering blobs\n    cc = pow( cc/15. , vec3(1.9));    //play with this\n\n    fragColor = vec4(cc,1.0);\n    \n    \n}\n\n","name":"Image","description":"","type":"image"}]}