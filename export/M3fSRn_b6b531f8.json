{"ver":"0.1","info":{"id":"M3fSRn","date":"1709063211","viewed":90,"name":"blood colorswap","username":"sanderoneil","description":"red-blue and length of speed","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["flow"],"hasliked":0,"parentid":"MXjGWc","parentname":"Fork blood/rive r invert"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    \n    vec4 buff_sample = texture(iChannel0, uv);\n    \n    fragColor = vec4(buff_sample.xyw/2.+vec3(.5,.5,.5),1.0);\n    \n    float red = buff_sample.w;\n    float blue = 1.- buff_sample.w;\n    \n    fragColor = vec4(red,length(buff_sample.xy),blue,0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float brush_size = 300.0;\nconst float sample_dist = 15.4;\nconst float sample_count = 10.;\n\nconst float pi= 3.14159265358979323846264338327950288;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    vec2 uv = (fragCoord )/iResolution.xy;\n    vec4 buff_sample = texture(iChannel0, uv);\n    \n    //buff_sample.xyz =  buff_sample.xyz *2. - vec3(1,1,1);\n    vec2 m = iMouse.xy;\n    float brush = max(brush_size - length(fragCoord - m),0.0);\n    vec2 brush_push = brush * normalize(fragCoord - m);\n    \n    if (iMouse.z > 0.){\n    brush = -max(brush_size - length(fragCoord - m),0.0);\n    brush_push = brush * normalize(fragCoord - m);\n\n    }\n    \n    vec3 v = vec3(0,0,0);\n    \n    vec2 sample_v = vec2(0,0);\n    \n    float total_pressure = 0.0;\n    float total_pressure_source = 0.0;\n    \n    for (float a = 0.0; a < pi*2.0; a += pi*2.0/ float( sample_count))\n    {\n        vec2 sample_offset = vec2(cos(a),sin(a));\n        vec4 sampl =  texture(iChannel0,uv+sample_offset/iResolution.xy*sample_dist).xyzw;\n        \n        float inflow = (dot(sampl.xy,sample_offset));\n        float pressure = sampl.w;\n        \n        \n        sample_v += sample_offset * abs(pressure) * inflow;\n        \n        \n        total_pressure += inflow *( sampl.w);\n        total_pressure_source += inflow;\n        \n        //vec4 sampl_opposing = texture(iChannel0,uv-sample_offset/iResolution.xy).xyzw;\n        \n        \n        \n        //buff_sample.w -= dot(sampl.xy,sample_offset)* sampl.w*iTimeDelta;\n    }\n    for (float a = 0.0; a < pi*2.0; a += pi*2.0/ float( sample_count))\n    {\n        vec2 sample_offset = vec2(cos(a),sin(a));\n        vec4 sampl =  texture(iChannel0,uv+sample_offset/iResolution.xy*sample_dist/3.).xyzw;\n        \n        float inflow = (dot(sampl.xy,sample_offset));\n        float pressure = sampl.w;\n        \n        \n        sample_v += sample_offset * abs(pressure) * inflow;\n        \n        \n        total_pressure += inflow *( sampl.w);\n        total_pressure_source += inflow;\n        \n        //vec4 sampl_opposing = texture(iChannel0,uv-sample_offset/iResolution.xy).xyzw;\n        \n        \n        \n        //buff_sample.w -= dot(sampl.xy,sample_offset)* sampl.w*iTimeDelta;\n    }\n    \n \n    if (length(sample_v) > .01){\n    sample_v/= total_pressure_source;}\n    //sample_v = normalize(sample_v);\n    \n    // /= total_pressure_source;\n    float average_pressure = total_pressure_source/total_pressure;\n    \n    float pressure = average_pressure;\n    \n    vec2 vel = sample_v;\n    \n    if (brush != 0.0){\n    vel = brush_push;\n    pressure = brush;\n    }\n    \n    \n    if (length(vel) > 1.)\n    {\n    vel /= length(vel);\n    }\n    \n    vec4 before_clamp= buff_sample * (1.0-iTimeDelta) + iTimeDelta*vec4(vel,1.0,brush*iTimeDelta);\n    \n    fragColor.x =max( min(10.0,before_clamp.x) ,-10.0);\n    fragColor.y =max( min(10.0,before_clamp.y),-10.0);\n    fragColor.z =max( min(1.0,before_clamp.z),-1.0);\n    \n    //fragColor.xyz = fragColor.xyz/2. + vec3(.5,.5,.5);\n    //fragColor.w = min(1.0,before_clamp.w);\n    pressure = max( min(10.0, pressure),-10.0);\n    \n    \n    fragColor.w = pressure;\n    \n    //fragColor.w = brush;\n    if (iTime < 0.5){\n    fragColor = vec4(0,0,0,texture(iChannel1,uv)*4.-2.);}\n    \n}\n","name":"Buffer A","description":"","type":"buffer"}]}