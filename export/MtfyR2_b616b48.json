{"ver":"0.1","info":{"id":"MtfyR2","date":"1507261870","viewed":152,"name":"partriforce","username":"balkhan","description":"2d particle system used to displace raymarched cubes on x and y axis.\nUse mouse to displace the center of weird gravity of the 2d particles. \nMotion blurr test on raymarching buffer. \nRedefine \"NUM\" on both buffer A and B to change the number of particles","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","particle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 o, in vec2 f )\n{\n    vec2\tR = iResolution.xy;\n    vec2\tu = (f.xy) / R.xy;\n    \n    o.xyz = texture(iChannel1, u).xyz;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n* BUFFER B : 2D Particle System\n*/\n\n#define NUM 20\n\nstruct\tparticle\n{\n    vec2\tpos;\n    vec2\tacc;\n    vec2\tvit;\n};\n    \nvoid\tinit_pos(inout vec2 pos, float i)\n{\n    pos.xy = .05*vec2( cos(iTime*1.+(i)/20.)*10.51, sin(iTime*1.+(i)/20.)*10.51);\n}\n\nvoid\tinit(inout particle part)\n{\n    part.acc *= 0.;\n\tpart.vit.xy *= 0.;\n}\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n    particle parts[NUM];\n    vec4\ttexture_buff;\n    vec2\tR = iResolution.xy;\n    o *= 0.;\n    vec2\tmous = (iMouse.xy-R/2.) / R.xy;\n    for (int i = 2; i <= NUM*2; i+=2)\n    {\n        texture_buff = texture(iChannel0, vec2(float(i)/R.x+.5/R.x,0.) ).xyzw;\n        parts[i].pos.xy = texture_buff.xy;\n    \tparts[i].vit.xy = texture_buff.zw;\n        texture_buff = texture(iChannel0, vec2(float(i+1)/R.x+.5/R.x,0.) ).xyzw;\n        parts[i].acc = texture_buff.xy;\n        parts[i].acc =\n            (\n                mous-parts[i].pos.xy\n            )\n            /\n            (\n                1000.1\n                /\n                length(\n                    \tmous-parts[i].pos.xy\n                \t  )\n                +\n                dot(\n                    normalize(\n                        \t\tmous-parts[i].pos.xy\n                    \t\t )\n                    ,\n                    normalize(\n                        \t\tmous-parts[i].pos.xy\n                    \t\t )\n\t\t\t\t\t)\n\t\t\t)\n            ;\n        parts[i].vit.xy += parts[i].acc.xy;\n        parts[i].vit.xy =\n               \t\t\t\tclamp(\n                                   \tparts[i].vit.xy\n                                   \t,\n                                   \t-.5\n                                   \t,\n                                   \t+.5)\n               \t\t\t\t\t\t;\n        parts[i].pos.xy += parts[i].vit.xy;\n        if (float(iFrame) <= 100.)\n        {\n\t\t\tinit(parts[i]);\n\t\t\tinit_pos(parts[i].pos.xy, float(i));\n        }\n        // Affectation of the values in buff B for next frame\n        o.xy += \n           \t\t( ( (f.x)-.5 == (float(i+0) )  ) ? 1. : 0.)\n           \t\t*\n           \t\tparts[i].pos.xy\n          \t\t+\n           \t\t( ( (f.x)-.5 == ( (float(i+1)) )  ) ? 1. : 0.)\n           \t\t*\n           \t\tparts[i].acc.xy\n           \t\t;\n\t\to.zw += \n\t            ((f.x -.5 == float(i)) ? 1. : 0.)\n\t            *\n\t            parts[i].vit.xy\n\t            ;\n\t}\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\n\n/*\n* BUFFER A : Raymarching and Motion Blurr\n*/\n\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvoid\trotate(inout vec2 v, float angle);\nvec3\tcalcNormal( in vec3 pos, float e, vec3 dir);\nfloat\tdist_func(vec3 p);\n\nfloat \tt;\t\t\t// time\nvec3\th; \t\t\t// light amount\nfloat\tid;\t\t\t// color id\nvec2\tpart_pos;\t// particle position\n\n#define I_MAX\t\t100.\n#define E\t\t\t0.001\n#define FAR\t\t\t20.\n#define PI\t\t\t3.14\n#define NUM\t\t\t20\n\n#define VL(p) (1./((dist_func(p)-.021)*(dist_func(p)-.021) ) )\n\n//#define DEBUG\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n    vec2\tR = iResolution.xy;\n    vec2\tdep;\n    vec3\told;\t\n    vec2\tuv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(.0, .0, 2.0);\n    vec2\tinter = march(pos, dir);\n\n    dep.xy = texture(iChannel1, vec2(f.x/R.x, 0.) ).zw;\n\n    vec3\tp = pos + inter.y * dir;\n\n    float\tg = \n    (\n        step(sin(20.*abs(p.y)-length(fract(p*3.)-.5)*30.*sin(.1*iTime) ), .0) \n        +\n        step(sin(20.*abs(p.x)-length(fract(p*3.)-.5)*30.*sin(.1*iTime) ), .0)\n        +\n        step(sin(20.*abs(p.z)-length(fract(p*3.)-.5)*30.*sin(.1*iTime) ), .0)\n    )\n    ;\n    \n    vec3\tcol =\n        (\n            inter.y > FAR ? 0. : 1.\n        )\n        *\n        (\n        \t(\n                id != 0.\n            )\n        ?\n        (\n            (\n                1.-inter.x*.05\n            )\n            *\n\t        abs(\n                vec3(\n\t\t        \tsin(+0.00+id/1.+0.*iTime*2.1)\n\t            \t,\n\t            \tsin(+1.04+id/1.+0.*iTime*2.5)\n\t            \t,\n\t         \t\tsin(+2.08+id/1.+0.*iTime*1.5)\n\t\t\t        )\n               )\n        )\n        :\n            (\n\t\t        (\n                    1.-inter.y*.125\n                )\n                *\n                abs(\n                    vec3(\n\t                \tsin(g+0.00)\n                    \t,\n                    \tsin(g+1.04)\n                    \t,\n                    \tsin(g+2.08)\n                \t)\n                )\n            )\n\t    )\n        \n        ;\n    col+=h*.0005;\n\n    o.xyzw += vec4(col.xyz, 1.);\n    old\t\t= texture(iChannel0, f.xy/R.xy).xyz;\n    o.xyz\t= mix(col.xyz, old, (id == 0.?1.:0.)*exp(-abs(-old + col.xyz)) );\n    #ifdef DEBUG\n    dep\t\t= texture(iChannel1, f.xx/R.xx).xy;\n    o.xyz  += dep.xyx*10.;\n    #endif\n}\n\nfloat\tscene(vec3 p)\n{  \n    float\tmind = 1e5;\n\tfloat\tming = 1e5;\n\tvec2\tdep;\n    vec2\tR = iResolution.xy;\n    id = 0.;\n\n\tfor (int i = 2; i <= NUM*2; i+=2)\n    {\n        dep = texture(iChannel1, vec2(float(i)/R.x, 0.) ).xy;\n        part_pos.xy = dep.xy;\n        mind = min(mind, dist_func(p-vec3(part_pos.xy,sin((part_pos.x+part_pos.y)*3.14)*1.))-.03);\n        dep = texture(iChannel1, vec2(float(i+1)/R.x, 0.) ).xy;\n        id = length(dep.xy)*3.;\n        if (mind < E || mind > FAR)\n            break;\n    }\n    ming = (p.z)+2.;\n    ming = min(ming, -p.x+1.5);\n    ming = min(ming, +p.x+1.5);\n    mind = min(mind, ming);\n    id = (mind != ming) ? id : 0.;\n\th +=\n        VL(p-vec3(part_pos.xy,sin((part_pos.x+part_pos.y)*3.14)))\n        *\n        .125\n        *\n        vec3(.6, .2, .5)\n        ;\n    return (mind);\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec2\ts = vec2(0.0, 0.0);\n\n    for (float i = -1.; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n        dist.x = scene(p);\n        dist.y += dist.x;\n        if (dist.x < E || dist.y > FAR)\n        {\n\t\t\tbreak;\n        }\n        s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\n// Utilities\n\nfloat\toct(vec3 p)\n{\n\tfloat\ts;\n    p = abs(p)/sqrt(3.);\n    s = p.x+p.y+p.z;\n    return (s);\n}\n\nfloat\tdist_func(vec3 p)\n{\n\tfloat\tret = 1e5;\n    \n    ret = max(-(max(abs(p.z),max(abs(p.x),abs(p.y)))-.175) , (oct(p)-.15));\n    ret = max(ret, -((max(abs(p.z),max(abs(p.x),abs(p.y+.65)))-.7)) );\n    return ret;\n}\n\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n    return normalize(vec3(\n           march(pos+eps.xyy, dir).y - march(pos-eps.xyy, dir).y,\n           march(pos+eps.yxy, dir).y - march(pos-eps.yxy, dir).y,\n           march(pos+eps.yyx, dir).y - march(pos-eps.yyx, dir).y ));\n}\n","name":"Buffer A","description":"","type":"buffer"}]}