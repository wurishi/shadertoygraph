{"ver":"0.1","info":{"id":"7dVGDc","date":"1632367587","viewed":343,"name":"Real Projective Triangle Tiling","username":"stevejtrettel","description":"A tiling of a convex domain in real projective space, as a deformation of a hyperbolic triangle group","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["tiling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI=3.14159;\n\n\n//------------------------------------------\n//Real Projective Reflections\n//------------------------------------------\n\n\n//the structure defining a mirror in real projective space\nstruct Mirror{\n    vec3 halfSpace;\n    mat3 reflection;\n    };\n    \n    \n //checking if you are inside a half space with normal vec normal\nbool inside(vec3 p, Mirror mirror){\n    return dot(p,mirror.halfSpace)>0.;\n}\n\n\n\n//if p is on the wrong side of the half space, perform the reflection\nvoid reflectIn(inout vec3 p, Mirror mirror,inout float invCount){\n\n    if(!inside(p,mirror)){\n        p=mirror.reflection*p;\n        \n        //project back down to keep entries small?\n        p/=p.z;\n        \n        invCount+=1.;\n    }\n}\n\n\n\n\n//------------------------------------------\n//set up the fundamental domain\n//------------------------------------------\n\n\n  Mirror M1,M2,M3;\n  \n  \n  void setupFD(float d){\n  //for the 334 triangle group\n  //this is computed separately, in mathematica\n  \n  float sqrt3=sqrt(3.);\n  \n  M1.halfSpace=vec3(0,1,0);\n  M1.reflection=mat3(\n  1,0,0,\n  0,-1,0,\n  0,0,1\n  );\n  \n  \n  M2.halfSpace=vec3(sqrt3,-1.,0);\n  M2.reflection=mat3(\n  -0.5,sqrt3/2.,0.,\n  sqrt3/2.,0.5,0.,\n  0.,0.,1.\n  );\n  \n  \n  M3.halfSpace=vec3(-1./d,-2./sqrt3+1./(sqrt3*d),1.);\n  M3.reflection=mat3(\n  1.+1./(2.-4.*d)+2./(d-2.),sqrt3/(2.-4.*d), 1./(1.-2.*d)+1./(d-2.)+1./d,\n  (7.*d-2.)/(2.*sqrt3*(d-2.)),1./2.,(2.+d*(3.*d-4.))/(sqrt3*d*(d-2.)),\n  d*(2.-7.*d)/(4.-10.*d+4.*d*d),sqrt3*d/(4.*d-2.),-d*(1.+d)/(2.-5.*d+2.*d*d)\n  );\n  \n  }\n  \n  \n//reflect in each wall of the fundamental domain if needed\n  void reflectInFD(inout vec3 p,inout float invCount){\n    reflectIn(p,M1,invCount);\n    reflectIn(p,M2,invCount);\n    reflectIn(p,M3,invCount);\n}\n\n\n//this function checks if p is inside our fundamental domain or not\n    bool insideFD(vec3 p){\n       return inside(p,M1)&&inside(p,M2)&&inside(p,M3);\n    }\n\n\n//move into the fundamental domain\n//this combines the two functions above: it iteratively reflects in the sides,\n//then checks if you ended up inside the FD\n//if you do, it stops.\nvoid moveToFD(inout vec3 p,inout float invCount){\n\n\n    for(int i=0;i<30;i++){\n\n        reflectInFD(p,invCount);\n        \n        if(insideFD(p)){\n            return;\n        }\n    }\n\n    invCount=-1.;\n\n}\n\n\n\n\n//------------------------------------------\n//prepare the screen pixels for computation\n//------------------------------------------\n\n\n\n//\"unprojectivize\" a point in an affine patch to a representative in R3\nvec3 toR3(vec2 p){\n    return vec3(p,1.);\n}\n\n//project to affine patch z=1\nvec2 proj(vec3 p){\n    return p.xy/p.z;\n    }\n    \n\n//this takes in the pixel coordinates on the screen (fragCoord) and rescales\n//them to show the appropriate region of the plane\nvec2 normalizedFragCoord(vec2 fragCoord){\n\n    // Normalized the pixel coordinates (from -0.5 to 0.5)\n    vec2 uv =(fragCoord/iResolution.xy-vec2(0.5));\n\n    //rescale this how you like\n    uv = 7.*vec2(1,iResolution.y/iResolution.x)*uv;\n\n    return uv;\n}\n\n\n\n    \n//------------------------------------------\n//coloring the fundamental domain\n//------------------------------------------\n\nvec3 tilingColor(float invCount){\n\n    vec3 tilingColor;\n\n    if(invCount<0.){\n        //if we didnt get into the fundamental domain\n        //color it black//BETTER: A DEBUG COLOR\n        tilingColor=vec3(0.2);\n        //0.6*vec3(71,58,153)/255.;\n    }\n\n    else {\n    \n        //we did get into the fundamental domain:\n        float parity=mod(invCount, 2.);\n\n        \n            if (parity==0.){\n                tilingColor=vec3(116, 161, 250)/255.;\n            }\n            else { //parity=1.\n                tilingColor=vec3(120, 170, 250)/255.;\n           }\n\n       }\n\n    return tilingColor;\n\n}\n\n\n\n//------------------------------------------\n//making the main image\n//------------------------------------------\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    //set up the input\n    vec2 uv = normalizedFragCoord(fragCoord);\n\n    //map into R3\n    vec3 p=toR3(uv);\n    \n    setupFD(0.89+0.3*sin(iTime));\n    \n    //reflect into the fundamental domain\n    float invCount=0.;\n    moveToFD(p,invCount);\n    \n    vec3 col;\n    \n    ///if(insideFD(p)){col=vec3(1);}\n\n    // Time varying pixel color\n    col = tilingColor(invCount);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}