{"ver":"0.1","info":{"id":"DtXfzj","date":"1693167052","viewed":140,"name":"Brownian Blocks II","username":"kastorp","description":"this time using Margolus neighbourhood, like in the outstanding Gelami [Url=https://www.shadertoy.com/view/msBSWK]shader[/Url]\nmouse: gravity direction (+SHIFT: draw walls)\nspace bar: reset\nsliders: set swap probabilities\n","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["brownian","ca"],"hasliked":0,"parentid":"dsjfRW","parentname":"Brownian Blocks"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Brownian Blocks II by Kastorp\n//  mouse: gravity direction\n//  mouse + SHIFT: draw walls\n//  mouse + D: erase walls\n//  mouse + C: magnet \n//  space bar: reset\n//  P: pause\n//  sliders: set swap probabilities (bottom=horizontal, center=diagonal, top=vertical)\n//------------------\n\nvoid mainImage( out vec4 O, in vec2 I )\n{   \n     INIT\n         \n    \n    vec2 p=I/res.y*SZ;\n    ivec2 c=  ivec2(p);\n    O = texelFetch(iChannel0,c,0);\n    vec3 col= vec3(0);\n    if(OTHER(O)) col= vec3(0.5);\n    if(EMPTY(O)) col= vec3(0);    \n    if(BLOCK(O)) col=vec3(.5) +.5*cos(vec3(0,2,4)+ O.y*12.);   \n    O.xyz=col;\n    \n    //SLIDER:\n    if(I.x>res.y && I.x/res.y< 1.5){\n        vec4 sl=texelFetch(iChannel1,ivec2(0),0);\n        float id = floor(I.y/res.y*4.);\n        if((I.x/res.y -1.)*2.<  sl[int(id)])O=vec4(1);\n        else O=vec4(0.5);   \n        if(abs(fract(I.y/res.y*4.-.05))>.9 || id>2.)O=vec4(0);\n    } \n    //GRAVITY POINTER\n    if(iMouse.z>0. && M.x<1.  && length(I/res.y-M)<.01) O=vec4(1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//SLIDERS\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    INIT\n    if(min(I.y,I.x)>1.5) return;\n    bool rc =texelFetch(iChannel0,ivec2(iResolution.x-1.,0),0)==vec4(0);\n    if(iFrame==0 || rc )\n    {\n        O=vec4(.33,.66,1.,0.);\n        return;    \n    }\n    \n    O=texelFetch(iChannel1,ivec2(0),0); \n    if(iMouse.z>0.  && abs(M.x-1.25)<.25) {\n    \n        float id = floor(M.y*4.);\n        O[int(id)]=  (M.x -1.)*2.;\n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//configuration:\n#define SZ (res.y>1000.?res.y*.5:res.y)\n#define INIT frame=iFrame; mouse=iMouse; res=iResolution;\n#define M (mouse.xy/res.y)\n\n\n//CURRENT BLOCK CONDITIONS\n#define EMPTY(b) (b.x==0.)\n#define BLOCK(b) (b.x==8.)\n#define OTHER(b) (b.x==4.)\n\n//https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n///------------------------\n\nint frame;\nvec4 mouse;\nvec3 res;\n\n\nvoid sim( inout vec4 O, in vec2 I,sampler2D ch0,sampler2D ch1,sampler2D ch3)\n{\n\n    if(I.y>SZ || I.x>SZ) return;\n        //Margolus vector  (cycling every 2 frames)\n        //todo implement improved version of Gelami, cycling every 4 frames\n        vec2 md = vec2((int(I.x)&1)!=(int(frame)&1),(int(I.y)&1)!=(int(frame)&1))*2.-1.;\n        \n        vec2 nx =I+vec2(md.x,0), ny= I+vec2(0,md.y), nxy = I+md;\n        \n        //uncomment  to get xy symmetry \n       //if((iFrame&2) >0) {vec2 t =nx;nx=ny;ny=t;md=md.yx;} \n      \n        //Margolus 2x2 Neighbourhood\n        vec4\n            c=texelFetch(ch0,ivec2(I),0),\n            cx=texelFetch(ch0,ivec2(nx),0), \n            cy=texelFetch(ch0,ivec2(ny),0), \n            cd=texelFetch(ch0,ivec2(nxy),0); \n        \n        O=c; //default: no swaps\n       \n        //get sliders\n        vec4 sl=texelFetch(ch1,ivec2(0),0);\n        float HP =sl[0], DP=sl[1], VP=sl[2]; //swap probabilities\n        \n        bool  GRAVITY_R= false,\n              GRAVITY_U =false,\n              GRAVITY_D =false,\n              GRAVITY_L =false;\n              \n         //get gravity\n         if(mouse.z>0. && M.x<res.y/SZ){\n             vec2 d =M*SZ-I-md*.5;\n             \n            if(texelFetch(ch3,ivec2(67,0),0).x>.5){\n                 \n                 float e=abs(d.y/d.x);\n                 GRAVITY_R =d.x< 0. && e <2.;\n                 GRAVITY_L =d.x> -0. && e <2.;\n                 GRAVITY_U =d.y< 0. && e >.5;\n                 GRAVITY_D =d.y> -0. && e >.5;\n             }\n             else if(texelFetch(ch3,ivec2(16,0),0).x>.5){    \n                 if(length(d)<SZ*.01 && EMPTY(c) ){O=vec4(4); return;}\n             }\n             else if(texelFetch(ch3,ivec2(68,0),0).x>.5){    \n                 if(length(d)<SZ*.01 && OTHER(c) ){O=vec4(0); return;}\n             }\n            else{\n                 GRAVITY_R =M.x< .25;\n                 GRAVITY_L =M.x> .75;\n                 GRAVITY_U =M.y< .25;\n                 GRAVITY_D =M.y> .75;\n             }\n         }\n          if(texelFetch(ch3,ivec2(80,2),0).x>.5) return;\n         \n        //constraints\n        bool cUp = ( md.y>0.  || !GRAVITY_U) && ( md.y<0.  || !GRAVITY_D),\n             cDown=( md.y<0.  || !GRAVITY_U) && ( md.y>0.  || !GRAVITY_D),\n             cLeft=( md.x<0.  || !GRAVITY_R) && ( md.x>0.  || !GRAVITY_L),\n             cRight=( md.x>0. || !GRAVITY_R) && ( md.x<0.  || !GRAVITY_L);\n             \n        // There are six possible swaps, each with two directions.\n        // Swap decisions can be any mix of random and deterministic conditions\n        // which could also depend on an extended neighbourhood.\n        // Here we have only random brownian motion, \n        // and gravity constraint (configurable) \n        bool sh  =hash13(vec3(I,frame))<HP && cLeft, //current horizontal swap\n             sxh =hash13(vec3(nx,frame))<HP && cRight,  //current horizontal inverse swap\n             syh =hash13(vec3(ny,frame))<HP && cLeft, //conflicting horizontal inverse swap\n             sdh =hash13(vec3(nxy,frame))<HP && cRight, //conflicting horizontal  swap\n             \n             syv =hash13(vec3(ny,frame))<VP && cUp , //current vertical inverse swap             \n             sv  =hash13(vec3(I,frame))<VP && cDown , //current vertical swap \n             sdv =hash13(vec3(nxy,frame))<VP && cUp, //conflicting vertical inverse swap\n             sxv =hash13(vec3(nx,frame))<VP && cDown, //conflicting vertical swap\n            \n             sd  =hash13(vec3(I,frame))<DP && cDown && cLeft, //current diagonal swap\n             sdd =hash13(vec3(nxy,frame))<DP && cUp && cRight, //current diagonal inverse swap\n             sxd =hash13(vec3(nx,frame))<DP && cDown && cRight, //conflicting diagonal swap\n             syd =hash13(vec3(ny,frame))<DP && cUp  && cLeft; //conflicting diagonal inverse swap \n                   \n         \n         //Swap order \n         //0=horizontal, 1= diagonal,  2=vertical\n         const ivec3 SW =  ivec3(0,1,2); // HDV\n                    // ivec3(1,0,2); // DHV\n                    //ivec3(0,2,1); // HVD\n                    \n         // Swaps inside Margolus neighbourhood are evaluated\n         // swaps in the same direction must be evaluated together         \n         // Every swap can directly or indirectly impact the current block\n        for(int i=0;i<3;i++){\n            int j=SW[i];\n            if(j==0){\n                     //horizontal Swap\n                     if(EMPTY(c) && BLOCK(cx) && sxh  ){O=cx; return;}\n                     if(BLOCK(c) && EMPTY(cx) && sh   ){O=cx; return;} \n                     if(EMPTY(cy) && BLOCK(cd) && sdh ){O=c; return;}\n                     if(BLOCK(cy) && EMPTY(cd) && syh ){O=c; return;}\n             }  else if(j==1){      \n                      //diagonal Swap\n                     if(EMPTY(c) && BLOCK(cd) && sdd  ){O=cd; return;}\n                     if(BLOCK(c) && EMPTY(cd) && sd   ){O=cd; return;}\n                     if(EMPTY(cy) && BLOCK(cx) && sxd ){O=c; return;}\n                     if(BLOCK(cy) && EMPTY(cx) && syd ){O=c; return;}\n            }  else if(j==2){\n                     //vertical Swap\n                     if(EMPTY(c) && BLOCK(cy) && syv  ){O=cy; return;}\n                     if(BLOCK(c) && EMPTY(cy) && sv   ){O=cy; return;}   \n                     if(EMPTY(cx) && BLOCK(cd) && sdv ){O=c; return;}\n                     if(BLOCK(cx) && EMPTY(cd) && sxv ){O=c; return;}  \n           }\n        }   \n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    INIT\n        \n    //resolution change?\n    bool rc =texelFetch(iChannel0,ivec2(res.x-1.,0),0)==vec4(0);\n    if(iFrame==0|| rc ||texelFetch(iChannel3,ivec2(32,0),0).x>.5) { \n    \n        //initialize\n        O = vec4(0); //VOID\n        if(length(I-vec2(SZ*.5))<SZ*.3) O = vec4(8.,I.x/SZ,I.y/SZ,0);\n        if(max(abs(I.x-SZ*.5),abs(I.y-SZ*.5))>SZ*.5-1.) O = vec4(4,0,0,0);\n        if(I.y<1. && I.x>res.x-2.)O=vec4(1);      \n        return;\n    }\n    else sim(O,I,iChannel0,iChannel1,iChannel3);             \n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 O, in vec2 I )\n{\n    INIT\n    sim(O,I,iChannel0,iChannel1,iChannel3); \n    \n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 O, in vec2 I )\n{\n    INIT\n    sim(O,I,iChannel0,iChannel1,iChannel3);             \n}","name":"Buffer D","description":"","type":"buffer"}]}