{"ver":"0.1","info":{"id":"WddyRl","date":"1601511728","viewed":237,"name":"RayMarching - Boolean Operators","username":"marcelfernandez13","description":"This is my first experience using raymarching and boolean operators","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","hittest","shapes","operators"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DISTANCE 100.0\n#define SURFACE_DIST 0.01\n\n#define NO_HIT              0\n#define CYLINDER_SHAPE_ID   1\n#define SPHERE_SHAPE_ID     2\n#define CUBE_SHAPE_ID       3\n#define PLANE_SHAPE_ID      4\n\n#define PI 3.14159265358979323846264338327950288\n#define DEG_TO_RAD (PI / 180.0)\n\n\n// ****************************************************\n// *******************  Structs  **********************\n// ****************************************************\n\nstruct RayHit {\n    float dist;\n    int objectId;\n};\n\n// ****************************************************\n// *********************  Utils  **********************\n// ****************************************************\n\nmat2 rotMat(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat2(c, -s, s, c);\n}\n\nRayHit Union(RayHit hit1, RayHit hit2) {\n    if (hit1.dist < hit2.dist) {\n        return hit1;\n    } else {\n        return hit2;\n    }\n}\n\nRayHit Substruction(RayHit hit1, RayHit hit2) {\n    if (-hit1.dist > hit2.dist) {\n        return RayHit(-hit1.dist, hit1.objectId);\n    } else {\n        return hit2;\n    }\n}\n\nRayHit Intersection(RayHit hit1, RayHit hit2) {\n    if (hit1.dist > hit2.dist) {\n        return hit1;\n    } else {\n        return hit2;\n    }\n}\n\n// ****************************************************\n// **********  Surface Distance Functions  ************\n// ****************************************************\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float radius) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n\n    float t = dot(ap, ab) / dot(ab, ab);\n    vec3 c = a + t * ab;\n\n    float x = length(p - c) - radius;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float externalDist = length(max(vec2(x, y), 0.0));\n    float iteriorDist = min(max(x, y), 0.0);\n\n    // The ray marcher  gets an aproximation to the distance. \n    // So, sometimes the distance cooresponds to a point inside\n    // the cylinder.\n\n    return externalDist + iteriorDist;\n}\n\nfloat sdBox(vec3 p, vec3 size) {\n    return length(max(abs(p) - size, 0.0));\n}\n\nfloat sdSphere(vec3 p, vec3 position, float radius) {\n    return length(position - p) - radius;\n}\n\n// ****************************************************\n// ********************  Scene  ***********************\n// ****************************************************\n\nRayHit sdCustomShape(vec3 p, float cylinderRadius, float cylinderHeight) {\n    mat2 rot = rotMat(90.0 * DEG_TO_RAD);\n    \n    // Height Cylinder Distance\n    RayHit hcd = RayHit(sdCylinder(p, vec3(0, cylinderHeight * 0.5, 0), vec3(0, cylinderHeight * -0.5, 0), cylinderRadius), CYLINDER_SHAPE_ID);\n\n    // Rotate the first cylinder to generate the structure\n    p.xy *= rot;\n\n    // Width Cylinder Distance\n    RayHit wcd = RayHit(sdCylinder(p, vec3(0, cylinderHeight * 0.5, 0), vec3(0, cylinderHeight * -0.5, 0), cylinderRadius), CYLINDER_SHAPE_ID);\n\n    // Rotate the first cylinder to generate the \"cross\"\n    p.yz *= rot;\n\n    // Depth Cylinder Distance\n    RayHit dcd = RayHit(sdCylinder(p, vec3(0, cylinderHeight * 0.5, 0), vec3(0, cylinderHeight * -0.5, 0), cylinderRadius), CYLINDER_SHAPE_ID);\n\n    RayHit result = Union(wcd, hcd);\n    result = Union(result, dcd);\n\n    float cubeSize = (cylinderHeight * 0.5) - 0.02;\n    RayHit cd = RayHit(sdBox(p, vec3(cubeSize)), CUBE_SHAPE_ID);\n    RayHit sd = RayHit(sdSphere(p, vec3(0), cubeSize + 0.22), SPHERE_SHAPE_ID);\n\n    result = Substruction(result, Intersection(cd, sd));\n\n    return result;\n}\n\nRayHit sceneHit(vec3 p) {\n\n    p.xz *= rotMat(-iTime * 25.0 * DEG_TO_RAD);\n\n    // Input params\n    float cylinderRadius = 0.5;\n    float cylinderHeight = 1.5;\n\n    RayHit plainHit = RayHit(p.y + cylinderHeight, PLANE_SHAPE_ID);\n    RayHit shapeHit = sdCustomShape(p, cylinderRadius, cylinderHeight);\n\n    return Union(plainHit, shapeHit);\n}\n\n// ****************************************************\n// ************  Ray Marching Algorithms  *************\n// ****************************************************\n\nRayHit rayMarch(vec3 ro, vec3 rd) {\n    // Distance to the object\n    float dO = 0.0; \n    int objId = NO_HIT;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + (dO * rd);\n        RayHit hit = sceneHit(p);\n        dO += hit.dist;\n        if (hit.dist <= SURFACE_DIST || hit.dist > MAX_DISTANCE) \n        {\n            objId = hit.objectId;\n            break;\n        }   \n    }\n\n    return RayHit(dO, objId);\n}\n\nvec3 getNormal(vec3 p) {\n    RayHit hit = sceneHit(p);\n    // This is a delta to calculate a very closer point to p.\n    // Then you can get the normal vector\n    vec2 e = vec2(0.000001, 0);\n\n    vec3 normal = hit.dist - vec3(sceneHit(p - e.xyy).dist,\n                              sceneHit(p - e.yxy).dist,\n                              sceneHit(p - e.yyx).dist);\n\n    return normalize(normal);\n}\n\n// ****************************************************\n// *******************  Shading  **********************\n// ****************************************************\n\nfloat getLight(vec3 p) {\n    vec3 lightPos = vec3(0, 3, -5);\n    lightPos.xz -= vec2(sin(iTime), cos(iTime));\n\n    vec3 l = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n\n    float NdotL = clamp(dot(n, l), 0.0, 1.0);\n\n    return NdotL;\n}\n\n// ****************************************************\n// *********************  Main  ***********************\n// ****************************************************\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Set 0 of uv in the midle of the screen\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Camera info. ro = ray origin, rd ray direction\n    vec3 ro = vec3(0, 1, -3);\n    vec3 rd = normalize(vec3(uv.x, uv.y - 0.4, 1.0));\n\n    RayHit hit = rayMarch(ro, rd);\n\n    vec3 p = ro + (rd * hit.dist);\n\n    vec3 color = vec3(0);\n\n    if (hit.objectId == PLANE_SHAPE_ID) {\n        color += texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    } else {\n        color += vec3(1, 0, 0) * (hit.objectId == CUBE_SHAPE_ID ? 1.0 : 0.0);\n        color += vec3(0, 1, 0) * (hit.objectId == CYLINDER_SHAPE_ID ? 1.0 : 0.0);\n        color += vec3(0, 0, 1) * (hit.objectId == SPHERE_SHAPE_ID ? 1.0 : 0.0);\n    }\n\n    vec3 diffuse = color * getLight(p);    \n\n    fragColor = vec4(diffuse, 1.0);\n}","name":"Image","description":"","type":"image"}]}