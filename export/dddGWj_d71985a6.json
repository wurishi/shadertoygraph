{"ver":"0.1","info":{"id":"dddGWj","date":"1677863735","viewed":82,"name":"Raymarching + weird effect","username":"Orcalancelulu","description":"raymarching of a sphere","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","simple"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float getVectorLength(vec3 vec) {\n    return sqrt(vec.x * vec.x + vec.y * vec.y + vec.z * vec.z);\n}\n\nvec3 getVectorBetweenPoints(vec3 point1, vec3 point2) {\n    return vec3(point2.x-point1.x, point2.y-point1.y, point2.z-point1.z);\n}\n\nfloat getDistanceToSphere(vec3 position, vec3 spherePos, float sphereRadius) {\n    vec3 vec = getVectorBetweenPoints(position, spherePos);\n    float disToSphere = getVectorLength(vec) - sphereRadius;\n    return disToSphere;\n}\nvec3 spherePos;\n\nfloat getDistanceToNearestObj(vec3 position) {\n   \n    float sphereRadius = 1.0;\n    \n    return getDistanceToSphere(position, spherePos, sphereRadius);\n    \n}\n\nfloat getCosOfAngleBetweenVectors(vec3 vector1, vec3 vector2) {\n    float scalar = vector1.x * vector2.x + vector1.y * vector2.y + vector1.z * vector2.z;\n    return scalar / (getVectorLength(vector1) * getVectorLength(vector2));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    spherePos = vec3(0.5 + sin(iTime + fragCoord.y * 0.01), 0.5, 3.0);\n    \n    // iResolution.y damit das Bild nicht verzerrt wird\n    vec2 uv = vec2(fragCoord.x / iResolution.y, fragCoord.y / iResolution.y);\n    \n    vec3 cameraPosition = vec3((iResolution.x / iResolution.y) * 0.5, 0.5, -2.0);\n    vec3 uvWorldPosition = vec3(uv.x, uv.y, 0.0);\n    \n    vec3 cameraToUvVector = uvWorldPosition - cameraPosition;\n    \n    cameraToUvVector = cameraToUvVector * (1.0/sqrt(cameraToUvVector.x * cameraToUvVector.x + cameraToUvVector.y * cameraToUvVector.y + cameraToUvVector.z * cameraToUvVector.z));\n        \n    //raymarching star pos: uvWorldPosition\n    //raymarching norm. vector: cameraToUvVector\n    \n    float distanceToNearestObj = 100.0;\n    float collidingDistance = 0.01;\n    \n    vec3 currentPosOnVector = uvWorldPosition;\n    \n    while(distanceToNearestObj > collidingDistance && distanceToNearestObj < 200.0){\n         distanceToNearestObj = getDistanceToNearestObj(currentPosOnVector);\n         currentPosOnVector += cameraToUvVector * distanceToNearestObj;\n    }\n    \n    float distanceToIntersection = getVectorLength(getVectorBetweenPoints(currentPosOnVector, uvWorldPosition));\n    \n    vec3 col = vec3(1.0, 1.0, 1.0);\n \n    if (distanceToNearestObj < 0.1) {\n        //float greyValue = pow(distanceToIntersection / 3.0, 4.0);\n        float greyValue = getCosOfAngleBetweenVectors(cameraToUvVector + currentPosOnVector, -getVectorBetweenPoints(spherePos, currentPosOnVector));\n        col = vec3(greyValue, greyValue, greyValue);\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}