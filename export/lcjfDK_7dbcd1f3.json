{"ver":"0.1","info":{"id":"lcjfDK","date":"1725539943","viewed":14,"name":"ray tracer xuanchen","username":"tomzhou","description":"This is a simple ray tracer in progress","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Simple ray tracer by Xuanchen Zhou\n\n\n// Small constant to solve self-occlusion\nconst float delta = 0.0001;\n\n// Sphere 0\nconst float ground = -1.5;\nconst vec3 ground_color = vec3(0.8, 0.8, 0.8);\n\n// Sphere 1\nconst vec3 sphere_1_pos = vec3(0.0, 0.0, 2.0);\nconst float sphere_1_radius = 0.8;\nconst vec3 sphere_1_color = vec3(0.0, 0.0, 1.0);\n\n// Sphere 2\nconst vec3 sphere_2_pos = vec3(-1.5, 0.2, 2.0);\nconst float sphere_2_radius = 0.5;\nconst vec3 sphere_2_color = vec3(0.0, 0.0, 1.0);\n\n// Sphere 3\nconst vec3 sphere_3_pos = vec3(-1.5, -0.3, 1.5);\nconst float sphere_3_radius = 0.3;\nconst vec3 sphere_3_color = vec3(1.0, 0.0, 0.0);\n\n// Light 1\nconst vec3 light_1_pos = vec3(-2.0, 1.8, 2.0);\nconst float light_1_radius = 0.1;\nconst vec3 light_1_color = vec3(5.0, 5.0, 5.0);\n\nfloat intersect_sphere( in vec3 ray_origin, in vec3 ray_dir, in vec3 sphere_loc, in float radius )\n{\n    // Intersection calc\n    float a = dot(ray_dir, ray_dir);\n    float b = -2.0 * dot(ray_dir, sphere_loc - ray_origin);\n    float c = dot(sphere_loc - ray_origin, sphere_loc - ray_origin) - radius * radius;\n    float intersect = b*b - 4.0*a*c;\n    \n    if (intersect < 0.0)\n        return -1.0;\n    else\n        return (-b - sqrt(intersect)) / (2.0*a);\n}\n\nfloat intersect_ground( in vec3 ray_origin, in vec3 ray_dir )\n{\n    // Intersection calc\n    vec3 ground_normal = vec3(0.0, 1.0, 0.0);\n    float t = (dot(vec3(0.0, ground, 0.0), ground_normal) - dot(ray_origin, ground_normal)) / dot(ray_dir, ground_normal); \n    \n    return t;\n}\n\nvec3 ray_sample_multi( in vec3 ray_origin, in vec3 ray_dir, int depth )\n{\n    vec3 current_color = vec3(0.0);\n\n    for (int dep = 0; dep < depth; dep++) {\n        // Intersection with light\n        float t_light = intersect_sphere(ray_origin, ray_dir, light_1_pos, light_1_radius);\n\n        // Intersection with diffuse sphere\n        float t_0 = intersect_ground(ray_origin, ray_dir);\n        float t_diff = intersect_sphere(ray_origin, ray_dir, sphere_1_pos, sphere_1_radius);\n\n        // Intersection with specular sphere\n        float t_spec = intersect_sphere(ray_origin, ray_dir, sphere_2_pos, sphere_2_radius);\n        \n        float t_refrac = intersect_sphere(ray_origin, ray_dir, sphere_3_pos, sphere_3_radius);\n    \n        // Sphere 1\n        if (t_diff > 0.0) {\n            // Compute normal\n            vec3 intersect_pos = ray_origin + t_diff * ray_dir;\n            vec3 normal = normalize(intersect_pos - sphere_1_pos);\n\n            // Diffuse\n            float shadow = intersect_sphere(intersect_pos + delta, normalize(light_1_pos - intersect_pos), sphere_1_pos, sphere_1_radius);\n            if (shadow > 0.0)\n                return vec3(0.0);\n\n            float dist = length(intersect_pos - light_1_pos);\n            vec3 color = light_1_color / (dist*dist) * sphere_1_color;\n\n            current_color += color;\n            break;\n        }\n        // Sphere 2 (specular)\n        else if (t_spec > 0.0) {\n            // Compute normal\n            vec3 intersect_pos = ray_origin + t_spec * ray_dir;\n            vec3 normal = normalize(intersect_pos - sphere_2_pos);\n\n            // Trace a new ray\n            vec3 reflect_dir = reflect(ray_dir, normal);\n            ray_origin = intersect_pos + delta;\n            ray_dir = reflect_dir;\n            \n            current_color += vec3(0.0, 0.1, 0.0);\n        }\n        // Sphere 3 (refraction)\n        //else if (t_refrac > 0.0) {\n            // Compute normal\n        //    vec3 intersect_pos = ray_origin + t_spec * ray_dir;\n        //    vec3 normal = normalize(intersect_pos - sphere_3_pos);\n\n            // Trace a new ray\n        //    vec3 reflect_dir = refract(ray_dir, normal, 1.0 / 1.33);\n        //    ray_origin = intersect_pos + delta;\n        //    ray_dir = reflect_dir;\n            \n            //current_color += vec3(0.0, 0.1, 0.0);\n        //}\n        // Ground\n        else if ((t_0 > 0.0 && t_diff < 0.0 && t_spec < 0.0) || (t_0 > 0.0 && t_0 < t_diff && t_0 < t_spec)) {\n            // Compute normal\n            vec3 intersect_pos = ray_origin + t_0 * ray_dir;\n            vec3 normal = vec3(0.0, 1.0, 0.0);\n\n            // Diffuse\n            float shadow = intersect_sphere(intersect_pos + delta, normalize(light_1_pos - intersect_pos), sphere_1_pos, sphere_1_radius);\n            if (shadow > 0.0)\n                return vec3(0.0);\n\n            float dist = length(intersect_pos - light_1_pos);\n            vec3 color = light_1_color / (dist*dist) * ground_color;\n            \n            //return color;\n            current_color += color;\n            break;\n        }\n        else if (t_light > 0.0) {\n            // Compute normal\n            vec3 intersect_pos = ray_origin + t_light * ray_dir;\n            vec3 normal = normalize(intersect_pos - vec3(0.0, 0.0, 2.0));\n\n            current_color += light_1_color;\n            break;\n        }\n        else {\n            current_color += vec3(0.2);\n            break;\n            \n        }\n    }\n    return current_color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n\n    // Camera\n    vec3 camera_pos = vec3(0.0, 0.0, 0.0);\n    vec3 viewport_pos = vec3(0.0, 0.0, 1.0);\n    float viewport_height = 2.0;\n    float viewport_width = ratio * viewport_height;\n    \n    // Viewport\n    float dy = viewport_height / iResolution.y;\n    float dx = viewport_width / iResolution.x;\n    vec3 upper_left_pixel = viewport_pos - vec3(viewport_width / 2.0, 0, 0) - vec3(0, viewport_height / 2.0, 0);\n    \n    // Ray\n    vec3 pixel_pos = upper_left_pixel + vec3(fragCoord.x * dx, 0, 0) + vec3(0, fragCoord.y * dy, 0);\n    vec3 ray_dir = normalize(pixel_pos - camera_pos);\n    \n    vec3 color = ray_sample_multi(camera_pos, ray_dir, 5);\n    //vec3 color = vec3(fragCoord/iResolution.xy, 0.0);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}