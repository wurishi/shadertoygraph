{"ver":"0.1","info":{"id":"4lKcDK","date":"1537891772","viewed":117,"name":"Assignment-2","username":"elijah_green14","description":"assignment for class","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Elijah Green\n//9/24/2018\n//Assignment 2 \nmat3 rotateY(float rad) {\n\tfloat c = cos(rad);\n\tfloat s = sin(rad);\n\treturn mat3(\n\t\tc, 0.0, -s,\n\t\t0.0, 1.0, 0.0,\n\t\ts, 0.0, c\n\t);\n}\n\nmat3 rotateZ(float rad) {\n\tfloat c = cos(rad);\n\tfloat s = sin(rad);\n\treturn mat3(\n\t\tc, s, 0.0,\n        -s, c, 0.0,\n\t\t0.0, 0.0, 1.0\n\t\t\n\t);\n}\n\nfloat kEpsilon = 1e-8;\n\nbool triangleTrace(in vec3 rayPos, in vec3 rayDirection,\n\tin vec3 vertex0, in vec3 vertex1, in vec3 vertex2,\n\tout vec3 intersectPos, out vec3 intersectDir)\n{\n    \n    \n    vec3 v1v0 = vertex1 - vertex0;\n    vec3 v2v0 = vertex2 - vertex0;\n    vec3 rov0 = rayPos - vertex0;\n\n\n    // Cramer's rule for solcing p(t) = ro+t·rd = p(u,v) = vo + u·(v1-v0) + v·(v2-v1)\n    float d = 1.0/determinant(mat3(v1v0, v2v0, -rayDirection ));\n    float u =   d*determinant(mat3(rov0, v2v0, -rayDirection ));\n    float v =   d*determinant(mat3(v1v0, rov0, -rayDirection ));\n    float t =   d*determinant(mat3(v1v0, v2v0, rov0));\n\n    if( u<0.0 || u>1.0 || v<0.0 || (u+v)>1.0 || t < 0.001 )\n        return false;\n    \n    \n    vec3 N = normalize(cross(v1v0,v2v0));\n    if(dot(rayDirection,N) > 0.0)\n        return false;\n\n    intersectPos = rayPos + t * rayDirection; \n    \n     \n    intersectDir = reflect(rayDirection, N);\n    return true;\n    \n    \n}\n\n\n\n\n\nbool planeTrace(in vec3 rayPos, in vec3 rayDirection,\n\tin vec3 planePos, in vec3 planeNormal,\n\tout vec3 intersectPos, out vec3 intersectDir)\n{\n\tfloat denom = dot(-rayDirection, planeNormal);\n\n\tif (denom < 0.0001)\n\t\treturn false;\n\n\tfloat t = dot(rayPos - planePos, planeNormal) / denom;\n\n    if(t < 0.001)\n        return false;\n    \n\t//the point on the plane is...\n\tintersectPos = rayPos + rayDirection * t;\n\n\tintersectDir = reflect(rayDirection, planeNormal);\n\n\n\treturn true;\n\n}\n\nbool planeTraceUV(in vec3 rayPos, in vec3 rayDirection,\n\tin vec3 planePos, in vec3 planeNormal,\n\tout vec3 intersectPos, out vec3 intersectDir)\n{\n\tfloat denom = dot(-rayDirection, planeNormal);\n\n\tif (denom < 0.0001)\n\t\treturn false;\n\n\tfloat t = dot(rayPos - planePos, planeNormal) / denom;\n\n\t//the point on the plane is...\n\tintersectPos = rayPos + rayDirection * t;\n\n\tintersectDir = reflect(rayDirection, planeNormal);\n\n\n\treturn true;\n\n}\n\n\n//send a ray toward a sphere?\n//return true if it intersects sphere\n//also set the intersecting 3D Point\n//and reflected Ray direction\nbool sphereTrace(in vec3 rayPos, in vec3 rayDirection,\n\tin vec3 spherePos, in float sphereRadius,\n\tout vec3 intersectPos, out vec3 intersectDir) {\n\n\t//create a vector from ray Starting Point to Sphere Center\n\tvec3 L = spherePos - rayPos;\n\n\t//project that ray onto my ray direction and get its length\n\tfloat tc = dot(L, rayDirection);\n\n\tif (tc < 0.0)\n\t\treturn false;\n\n\t//float d = sqrt(pow(length(L), 2.0) - pow(tc,2.0));\n\tfloat d = sqrt(dot(L, L) - pow(tc, 2.0));\n\tif (d > sphereRadius)\n\t\treturn false;\n\n\tfloat t1c = sqrt(pow(sphereRadius, 2.0) - pow(d, 2.0));\n\n\t//distance from ray Start to hitting the sphere\n\tfloat t1 = tc - t1c;\n\n\t//results in 3D point where ray hits the sphere\n\tintersectPos = rayPos + rayDirection * t1;\n\n\tvec3 normal = normalize(intersectPos - spherePos);\n\n\tintersectDir = reflect(rayDirection, normal);\n\n\treturn true;\n\n}\n\nconst ivec3 CUBE_INDEX[12] = ivec3[12](\n\tivec3(0, 1, 2),\n\tivec3(2, 1, 3),\n\tivec3(2, 3, 4),\n\tivec3(4, 3, 5),\n\tivec3(4, 5, 6),\n\tivec3(6, 5, 7),\n\tivec3(6, 7, 0),\n\tivec3(0, 7, 1),\n\tivec3(1, 7, 3),\n\tivec3(3, 7, 5),\n\tivec3(6, 0, 4),\n\tivec3(4, 0, 2)\n\t);\n\n\nconst vec3 CUBE_VERTS[8] = vec3[8](\n\tvec3(-0.25, -0.45, 0.35),\n\tvec3(0.35, -0.45, 0.25),\n\tvec3(-0.25, 0.45, 0.35),\n\tvec3(0.35, 0.45, 0.25),\n\tvec3(-0.45, 0.25, -0.35),\n\tvec3(0.35, 0.25, -0.25),\n\tvec3(-0.25, -0.25, -0.25),\n\tvec3(0.35, -0.25, -0.25)\n\t);\n\n\nconst vec3 SPHERE_POS[3] = vec3[3](vec3(2.0, 0.5, -1.0),\n\tvec3(0.5, 0.0, 0.0),\n\tvec3(0.55, 0.25, -1.0)\n\n\t);\n\nconst vec3 SPHERE_COLOR[3] = vec3[3](vec3(0.2, 0.0, 0.0),\n\tvec3(0.8, 0.75, 0.5),\n\tvec3(0.0, 1.0, 0.0)\n\t);\n\nconst float SPHERE_RADIUS[3] = float[3](0.8, 0.25, 0.25\n\t);\n\nconst vec3 LIGHT_POS[3] = vec3[3](vec3(1.0, 10.0, 0.0),\n\tvec3(-5.0, 2.5, 5.0),\n\tvec3(2.5, 2.5, 10.0)\n\n\t);\n\nconst vec3 LIGHT_COLOR[3] = vec3[3](vec3(0.0, 0.0, 1.0),\n\tvec3(1.0, 1.0, 1.0),\n\tvec3(1.0, 0.0, 0.0)\n\t);\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 uv = fragCoord / iResolution.y*2.0;\n\tuv -= 0.5; //center the uvs\n\n\n\tvec3 cubePos = vec3(0.5, 0.55, -1.0);\n\n\n\tvec3 lightPos = vec3(0, 10, 0);\n\tvec3 lightPos2 = vec3(5, 0, 5);\n\n    vec3 rayPos = vec3(0.0,0.5, 3.0);\n    \n\tvec3 rayDir = normalize(vec3(uv.x*2.0, uv.y*2.0 , -3.0));\n\n\tvec3 planePos = vec3(0.0, -0.25, 0.0);\n\tvec3 planeNormal = vec3(0.0, 1.0, 0.0);\n\n\n\tvec3 newPos;\n\tvec3 newDir;\n\tvec3 currColor;\n\n\tvec3 col = vec3(0.0);\n\n\t//loop for ray bounces\n\tfor (int r = 0; r < 6; r++) {\n\n\n\n\t\tfloat minDist = 999999999.0;\n\t\tvec3 tempNewPos;\n\t\tvec3 tempNewDir;\n\n\t\t//foreach sphere in our scene check if ray hits it\n\t\tfor (int s = 0; s < 3; s++) {\n\n\t\t\t//check if the current pixel ray (uv) interects with a sphere\n\n\t\t\tif (sphereTrace(rayPos, rayDir,\n\t\t\t\trotateY(iTime*float(s))*SPHERE_POS[s], SPHERE_RADIUS[s],\n\t\t\t\ttempNewPos, tempNewDir)) {\n\n\t\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\t\tif (dist < minDist) {\n\n\t\t\t\t\tminDist = dist;\n\n\t\t\t\t\tnewPos = tempNewPos;\n\t\t\t\t\tnewDir = tempNewDir;\n\t\t\t\t\tcurrColor = SPHERE_COLOR[s];\n\n\t\t\t\t}\n\n\t\t\t\t//update the \"ray\" to our resulting ray\n\t\t\t}\n\n\t\t}\n\t\tfor (int f = 0; f < 12; f++) {\n            vec2 tex;\n\t\t\tif (triangleTrace(rayPos, rayDir,\n\t\t\t\t\t\t\t  CUBE_VERTS[CUBE_INDEX[f].x] * rotateY(iTime) + cubePos,\n                              CUBE_VERTS[CUBE_INDEX[f].y] * rotateY(iTime) + cubePos,\n                              CUBE_VERTS[CUBE_INDEX[f].z] * rotateY(iTime) + cubePos,\n             // CUBE_VERTS[CUBE_INDEX[f].x], CUBE_VERTS[CUBE_INDEX[f].y] , CUBE_VERTS[CUBE_INDEX[f].z],\n\t\t\t\ttempNewPos, tempNewDir)) {\n\n\t\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\t\tif (dist < minDist) {\n\n\t\t\t\t\tminDist = dist;\n\n\t\t\t\t\tnewPos = tempNewPos;\n\t\t\t\t\tnewDir = tempNewDir;\n\t\t\t\t\tcurrColor = vec3(0.5,0.0,1.0);\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (planeTrace(rayPos, rayDir,\n\t\t\tplanePos, planeNormal,\n\t\t\ttempNewPos, tempNewDir)) {\n\n\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\tif (dist < minDist) {\n\n\t\t\t\tminDist = dist;\n\n\t\t\t\tnewPos = tempNewPos;\n\t\t\t\tnewDir = tempNewDir;\n\t\t\t\tcurrColor = texture(iChannel1, newPos.xz/10.0).rrr;//vec3(1.0);\n\n\t\t\t}\n\n\t\t\t//update the \"ray\" to our resulting ray\n\t\t}\n\n\n\n        if(planeTrace(rayPos, rayDir,\n                      //planePos, planeNormal,\n                       vec3(15,0,0), vec3(-1,0,0),\n                      tempNewPos, tempNewDir)){\n\n            float dist = distance(rayPos, tempNewPos);\n\n            if(dist < minDist){\n\n                minDist = dist;\n\n                newPos = tempNewPos;\n                newDir = tempNewDir;\n                //texture(sourceImage, 2D location in image to read from)\n                currColor = texture(iChannel2, vec2(newPos.y,newPos.z)/5.0).rgb;\n\n            }\n        }\n\n\t\tif (minDist < 50.0) { \n\n\t\t\trayPos = newPos;\n\t\t\trayDir = newDir;\n\n\n\n\t\t\tfor (int l = 0; l < 3; l++) {\n\t\t\t\t//now let's check if this ray can see the light sources\n\n\t\t\t\tvec3 lightDir = normalize(LIGHT_POS[l] - rayPos);\n\t\t\t\tcol += (currColor*0.25 //ambient\n\t\t\t\t\t\t+ clamp(dot(rayDir, lightDir), 0.0, 1.0)*currColor //diffuse\n\t\t\t\t\t\t+ pow(clamp(dot(rayDir, lightDir), 0.0, 1.0), 50.8) * LIGHT_COLOR[l]\n\n\t\t\t\t\t\t) * (1.0/(float(r) + 1.0))\n\t\t\t\t\t\t* 50.0 / pow(distance(rayPos, LIGHT_POS[l]), 2.0);\n\n\t\t\t}\n\t\t}\n\n\t}\n\t// Output to screen\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}