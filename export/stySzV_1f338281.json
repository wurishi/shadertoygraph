{"ver":"0.1","info":{"id":"stySzV","date":"1641059191","viewed":119,"name":"z= function rendering","username":"Tameno","description":"i found a way to render an equation that starts with z= with ray marching, it won't work proper if the equation has parts where the slope is too high\n\nthe function currently being rendered is\nz = ( | sin(10x) | + | sin(10y) | ) / 20 - ( x^2 + y^2 )","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","function"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float mathFunc(float x, float y) {\n    //TRY CHANGING THIS FUNCTION\n    float z;\n    z = (abs(sin(10.0*x))+abs(sin(10.0*y)))/20.0-(x*x+y*y);\n    return z;\n}\nvec3 CameraPosition = vec3(0.0, 0.3, -2.0);\nfloat CameraAngle = -0.55;\nfloat RotationSpeed = 1.0;\nvec3 SunDirection = vec3(1.0, -0.3, -1.0);\nfloat correctErrors = 5.0;\n      // ^ increase this value if the shape\n      //   isn't being displayed properly\n\n//-------------------------------------------\n/*\nThanks to the user \"iq\" for pointing out mistakes and \nproposing improvements to the code\n*/\n\nfloat PI = 3.14159;\n\nvec2 rotate2D(vec2 vect, float ang) {\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2( c*vect.x - s*vect.y,\n                 s*vect.x + c*vect.y );\n}\nvec3 rotate_Y(vec3 vect, float ang) {\n    vec2 flatVect = vec2(vect.x, vect.z);\n    flatVect = rotate2D(flatVect, ang);\n    return vec3 (flatVect.x, vect.y, flatVect.y);\n}\nvec3 rotate_X(vec3 vect, float ang) {\n    vec2 flatVect = vec2(vect.z, vect.y);\n    flatVect = rotate2D(flatVect, ang);\n    return vec3 (vect.x, flatVect.y, flatVect.x);\n}\nvec3 rotate_Z(vec3 vect, float ang) {\n    vec2 flatVect = vec2(vect.x, vect.y);\n    flatVect = rotate2D(flatVect, ang);\n    return vec3 (flatVect.x, flatVect.y, vect.z);\n}\n\nvec3 pattern(vec3 coord) {\n    vec3 col = vec3(0.0, 0.0, 0.0).rgb;\n    col.r = sin(coord.x/1.3)/2.0+0.5;\n    col.g = sin(coord.z/1.3)/2.0+0.5;\n    col.b = 0.5;\n    return col;\n}\n\nvec3 sunDir() {\n    vec3 dir = SunDirection;\n    dir = rotate_Y(dir, iTime*RotationSpeed);\n    return normalize(dir);\n}\n\nfloat DE( vec3 pos ) {\n\n    float d = pos.y;\n    d -= mathFunc(pos.x, pos.z);\n    d /= correctErrors;\n    return abs(d);\n\n}\n\nvec3 rayMarch( vec3 dir, vec3 pos ) {\n    \n    float minDistance = 999.9;\n    float marchCount = 0.0;\n    bool hit = false;\n    for( int i = 0; i < 512; i++ ) {\n        float d = DE(pos);\n        if (d < 0.001) {\n            hit = true;\n            minDistance = d;\n            break;\n        }\n        pos += dir*d;\n        if (length(pos) > 100.0) break;\n        \n        \n        if (d < minDistance) minDistance = d;\n        marchCount += 1.0;\n    }\n    \n    vec3 col;\n    \n    \n    if (hit) {\n    \n        bool inShadow = false;\n        float distanceB = DE(pos-sunDir()*minDistance);\n        if (distanceB < minDistance) inShadow = true;        \n        col = pattern(pos);\n        \n        if (inShadow) {\n        \n            float ao = 2.0 / marchCount * correctErrors;\n            ao = min(1.0, ao);\n            col *= ao;\n            \n        } else {\n        \n            float specular = 0.0;\n            vec3 dirS = -sunDir();\n            vec2 dirF_x = vec2(dirS.z, dirS.y);\n            vec2 dirF_y = vec2(dirS.x, dirS.z);\n            vec2 dirF_z = vec2(dirS.x, dirS.y);\n            float i = 0.0;\n            bool flipAngle = false;\n            for(i; i < 1.0; i += 0.02) {\n                \n                float angle = PI/2.0*i;\n                if (flipAngle) angle *= -1.0;\n                flipAngle = !flipAngle;\n                \n                vec2 testX_a = rotate2D(\n                    vec2(length(dirF_x), dirS.x), angle);\n                float txx = testX_a.x;\n                vec3 testX_b = vec3(\n                    testX_a.y, dirS.y*txx, dirS.z*txx);\n                float deX = DE(pos+testX_b*minDistance);\n                \n                vec2 testY_a = rotate2D(\n                    vec2(length(dirF_y), dirS.y), angle);\n                float tyx = testY_a.x;\n                vec3 testY_b = vec3(\n                    dirS.x*tyx, testY_a.y, dirS.z*tyx);\n                float deY = DE(pos+testY_b*minDistance);\n                \n                vec2 testZ_a = rotate2D(\n                    vec2(length(dirF_z), dirS.z), angle);\n                float tzx = testZ_a.x;\n                vec3 testZ_b = vec3(\n                    dirS.x*tzx, dirS.y*tzx, testZ_a.y);\n                float deZ = DE(pos+testZ_b*minDistance);\n                \n                float minDe = min(min(deX, deY), deZ);\n                \n                if (minDe < minDistance) break;\n                \n            }\n            \n            specular = i;\n            \n            col += specular;\n            \n        }\n        \n    } else {\n    \n        float val;\n        val = 0.1/(minDistance+0.1);\n        val = min(val, 1.0);\n        col = vec3(val/2.0, 0.0, val);\n        val = length(-sunDir() - dir);\n        val = 0.1 / val;\n        col += val;\n        \n    }\n    \n    return col;\n    \n}\n\nvec3 getRayDir(vec2 uv) {\n    vec3 dir = vec3(uv.xy, 1.0);\n    dir = normalize(dir);\n    dir = rotate_X(dir, CameraAngle);\n    dir = rotate_Y(dir, iTime*RotationSpeed);\n    return dir;\n}\n\nvec3 getRayPos(vec2 uv) {\n    vec3 pos = CameraPosition;\n    pos = rotate_Y(pos, iTime*RotationSpeed);\n    return pos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = fragCoord/iResolution.y*2.0\n        -vec2(iResolution.x/iResolution.y, 1.0);\n\n    vec3 col = rayMarch(getRayDir(uv), getRayPos(uv));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}