{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"cubemap","id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"/**\nA magnificent crown, rendered realistically.\nby lerrain@gmail.com 2024/12/15，thanks to IQ、Shane and TambakoJaguar\n*/\n#define PI 3.1415926\n\nconst vec3 SUN_DIR = normalize(vec3(-100, 200, 60));\nconst float LOOK = 550.;\n\nstruct Object {\n    float d;\n    int type;\n};\n\nmat3 setCamera(in vec3 ro, in vec3 ta) {\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(0, 1, 0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n) {\n    n = max(n*n - .2, .001); \n    n /= dot(n, vec3(1)); \n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n;\n}\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\nfloat sdCappedCylinder( vec3 p, float h, float r ) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h ) {\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nfloat sdCircle( vec3 p, float h, float r1, float r2 ) {\n    float v1 = sdCappedCylinder(p, h, r1);\n    float v2 = sdCappedCylinder(p, h + 1., r2);\n    return max(v1, -v2);\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r ) {\n    vec3 q = abs(p) - b + r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdOctahedron( vec3 p, float s) {\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\nconst vec4 ddp = vec4(-.8506508,.8506508,.5257311,0);\nfloat sdGem1(vec3 p, float r) {\n  float dp0=abs(dot(p,ddp.wyz)),dp1=abs(dot(p,ddp.wxz)),dp2=abs(dot(p,ddp.zwy)),\n        dp3=abs(dot(p,ddp.zwx)),dp4=abs(dot(p,ddp.yzw)),dp5=abs(dot(p,ddp.xzw));\n  return max(max(max(dp0,dp1),dp2),max(max(dp3,dp4),dp5))-r;\n}\nfloat sdGem2(in vec3 p, float r) {\n  if (dot(p,p) > 1.5*r*r) return length(p)-r;\n  p.y -= r * .1;\n  float a = round(atan(p.z,p.x)/(PI*.25))*PI*.25;\n  float c = cos(a), s = sin(a);\n  vec3  q = vec3(c*p.x+s*p.z, p.y, abs(-c*p.z+s*p.x)) / r;\n  float fcBezel = dot(q, vec3(.544639035, .8386705679, 0))           - .544639035;\n  float fcUGird = dot(q, vec3(.636291199, .7609957358, .1265661887)) - .636291199;\n  float fcLGird = dot(q, vec3(.675808237,-.7247156073, .1344266163)) - .675808237;\n  float fcStar  = dot(q, vec3(.332894535, .9328278154, .1378894313)) - .448447409;\n  float fcPMain = dot(q, vec3(.656059029,-.7547095802, 0))           - .656059029;\n  float fcTable =   q.y - .2727511892;\n  float fcCulet = - q.y - .8692867378 * .96;  \n  float fcGirdl = length(q.xz) - .975;\n  return max(fcGirdl, max(fcCulet, max(fcTable, max(fcBezel, max(fcStar, max(fcUGird, max(fcPMain,fcLGird)))))));\n}\nvec2 rot(vec2 p, float deg) {\n    float ts = sin(deg);\n    float tc = cos(deg);\n    return vec2(tc * p.x - ts * p.y, ts * p.x + tc * p.y);\n}\nvec3 rot(vec3 p, float deg) {\n    float ts = sin(deg);\n    float tc = cos(deg);\n    return vec3(tc * p.x - ts * p.z, p.y, ts * p.x + tc * p.z);\n}\nconst vec3 normalTopA = normalize (vec3 (0.0, 1.0, 1.4));\nconst vec3 normalTopB = normalize (vec3 (0.0, 1.0, 1.0));\nconst vec3 normalTopC = normalize (vec3 (0.0, 1.0, 0.5));\nconst vec3 normalBottomA = normalize (vec3 (0.0, -1.0, 1.0));\nconst vec3 normalBottomB = normalize (vec3 (0.0, -1.0, 1.6));\nfloat sdGem3(in vec3 p, float r) {\n    if (dot(p,p) > 6.*r*r) return length(p)-r-r;\n\tfloat topCut = p.y - 1.0*r;\n\tfloat angleStep = PI / 8.;\n\tfloat angle = angleStep * (0.5 + floor (atan (p.x, p.z) / angleStep));\n\tvec3 q = rot (p, angle);\n\tfloat topA = dot (q, normalTopA) - 2.0*r;\n\tfloat topC = dot (q, normalTopC) - 1.5*r;\n\tfloat bottomA = dot (q, normalBottomA) - 1.7*r;\n\tq = rot (p, -angleStep * 0.5);\n\tangle = angleStep * floor (atan (q.x, q.z) / angleStep);\n\tq = rot (p, angle);\n\tfloat topB = dot (q, normalTopB) - 1.85*r;\n\tfloat bottomB = dot (q, normalBottomB) - 1.9*r;\n\treturn max (topCut, max (topA, max (topB, max (topC, max (bottomA, bottomB)))));\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n#define STONE(ty) if (obj.d > u) {obj.d = u;obj.type = ty;}\n#define MOV(y1) vec3(pos.x,pos.y-y1,pos.z)\nObject map(vec3 pos) {\n    Object obj;\n    \n    //obj.d = sdRoundBox(pos-vec3(0,-55,0), vec3(400.,55.,400.), 10.);\n    obj.d = sdRoundedCylinder(pos-vec3(0,-65,0), 200., 35., 30.);\n    //obj.d = pos.y;\n    if (obj.d < 0.) {\n        obj.type = 1;\n        return obj;\n    }\n    \n    float pr = length(pos.xz);\n    float pd = atan(pos.z,pos.x);\n    float pl, py;\n    float u, v, deg;\n    vec3 pc;\n\n\n    //底环\n    pc = MOV(41.);\n    v = sdCircle(pc, 40., 201., 199.); \n    //v = smin(v, sdCircle(MOV(8.5), 5., 202., 198.), 1.); \n    //v = smin(v, sdCircle(MOV(73.5), 5., 202., 198.), 1.); \n    v = smin(v, sdTorus(MOV(80.), vec2(200., 3.)), .5);\n    //v = smin(v, sdTorus(MOV(0,39,0), vec2(200., 1.5)), .5);\n    //v = smin(v, sdTorus(MOV(0,4,0), vec2(200., 1.5)), .5);\n    v = smin(v, sdTorus(MOV(2.), vec2(200., 3.)), .5);\n\n    //底环碎钻\n    const float sk3 = 2.*PI/round(150.*PI);\n    pl = pd-round(pd/sk3)*sk3;\n    py = pc.y-round(clamp(pc.y,-27.,27.)/3.)*3.;\n    //u = sdOctahedron(vec3(pl, pr-200., py), 2.);\n    u = sdGem2(vec3(pl*200., pr-201., py), 1.);\n    STONE(10);\n\n    //底环小珍珠\n    const float sk1 = PI/80.;\n    pl = pd-round(pd/sk1)*sk1;\n    u = sdSphere(vec3(pl*201., pos.y-8.5, pr-201.), 3.);\n    STONE(3);\n    u = sdSphere(vec3(pl*201., pos.y-73.5, pr-201.), 3.);\n    //u = sdGem2(vec3(pl, pr-200., pos.y-6.), 3.);\n    STONE(3);\n\n    //底环宝石\n    const float sk2 = PI/12.;\n    float id = round(pd/sk2);\n    pl = pd-id*sk2;\n    float size = id==0.?24.:12.+float((int(id)+101)%2)*6.;\n    v = smin(v, sdTorus(vec3(pl*201., pr-201., pc.y), vec2(size, 1.5)), .5);\n    v = smin(v, sdTorus(vec3(pl*199., pr-199., pc.y), vec2(size*0.75, 1.)), .5);\n    u = sdGem2(vec3(pl*201., pr-201., pc.y), size);\n    //STONE(10);\n    STONE(11+(int(id)+100)%3);\n\n    //中层宝石\n    const float sk4 = PI/4.;\n    id = round(pd/sk4);\n    pl = pd-id*sk4;\n    pc = vec3(pl*200., pr-200., pos.y-130.);\n    v = smin(v, sdTorus(pc, vec2(22., 2.)), .5);\n    u = sdGem2(pc, 22.);\n    STONE(11+(int(id)+100)%2);\n\n    //中层宝石一圈装饰\n    const float sk5 = PI/5.;\n    //vec3 pc2 = vec3(pc.x, pc.z+35., pc.y);\n    //pc2.x += sign(pc2.x) * sin((pc2.y+10.) * .03) * 15.;\n    //v = smin(v, sdRoundBox(pc2, vec3(20., 35., .5), .5), .5);\n    float pr1 = length(pc.xz);\n    float pd1 = atan(pc.x,pc.z);//  sign(pc.x)*acos(pc.z/pr1);\n    float pl1 = clamp(pd1,-PI+sk5*1.6,PI-sk5*1.5)-round(pd1/sk5)*sk5;\n    pc = vec3(pl1*pr1, pc.y, pr1-40.);\n    v = smin(v, sdTorus(pc, vec2(7., 1.)), .5);\n    v = smin(v, sdCappedCylinder(vec3(pc.x-sin((pc.z+10.)*0.2)*5.,pc.z+10.,pc.y), 15., 1.5), .5); //用这个在 大角度和小角度同时位于0/pi位置 附近为什么有这么多噪点，推测pc.x和pc.z的值有异常\n    //v = smin(v, sdCappedCylinder(vec3(pc.z,pc.z+10.,pc.z+pc.y), 15., 1.5), .5);\n    //v = smin(v, sdRoundBox(vec3(pc.x-sin((pc.z+10.)*0.2)*5.,pc.z+10.,pc.y), vec3(1.5, 15., 1.5), 1.), 1.);\n    u = sdGem1(pc, 5.);\n    STONE(10);\n        \n    //中层波浪装饰\n    //pc2 = vec3(pl*200., pr-200., pos.y-55.);\n    deg = (sign(pl)*sk4*.5-pl)*27.;\n    vec3 pc3 = vec3(pl*200., pr-200., cos(deg)*8.+pos.y-96.);\n    v = smin(v, sdRoundBox(pc3, vec3(100., 0.6, 5.), .5), .5);\n    \n    float npl = round(pl/0.03)*0.03;\n    deg = (sign(pl)*sk4*.5-npl)*27.;\n    u = sdGem2(vec3(pc3.x-npl*200., pc3.y-1., cos(deg)*8.+pos.y-96.), 2.5);\n    STONE(10);\n\n    //冠顶支撑\n    pl = pd+sk4*.5;\n    pl = pl-round(pl/sk4)*sk4;\n    const float wr = 100.*sqrt(2.);\n    const float r45 = sqrt(2.)/2.;\n    const float blend = 0.8; //扭曲的坐标系真实距离难以计算，大距离偏差较大，防止步进过度\n    vec2 m = vec2(200.-pr,pos.y-77.);\n    m = rot(m, -PI/4.);\n    vec2 ct = vec2(wr,-20.);\n    float fr = distance(m,ct);\n    float ww = PI/50.*pr+7.;\n    float dy = abs(fr-wr)-2.+1.5; //sqrt(1.-dg*dg)*wr - m.y;\n    float dx = abs(pl*pr+ww)-4.+1.5;\n    float nv = length(max(vec2(dx, dy),0.))+min(max(dx,dy),0.)-1.5;\n    dx = abs(pl*pr-ww)-4.+1.5;\n    nv = min(nv, length(max(vec2(dx, dy),0.))+min(max(dx,dy),0.)-1.5)*blend;\n\n    float cut = max(max(m.x-wr-wr+10., abs(fr-wr)-25.), max(-m.x, -m.y)); //\n    nv = max(cut, nv);\n    v = smin(v, nv, 1.5);\n    if (cut < 0.) {\n        deg = atan(m.x-ct.x,m.y-ct.y);\n        pc = vec3(pl*pr-ww, fr-wr-3., (deg-round(deg/0.05)*0.05)*fr);\n        u = sdGem2(pc, 3.)*blend;\n        STONE(10);\n        pc.x += ww+ww;\n        u = sdGem2(pc, 3.)*blend;\n        STONE(10);\n        deg = PI*.5 - deg;\n        float n = (-1.+sqrt(1.+8.*deg/0.03))/2.;\n        n = floor(n);\n        if (n < 13.) {\n            float t = (1.+n)*(1.+n)*.5;\n            pc = vec3(pl*pr, fr-wr, (deg-t*0.03)*fr);\n            float sr = ww-4.;\n            u = sdGem3(pc, sr*.42)*blend;\n            STONE(10);\n            v = smin(v, sdTorus(pc, vec2(sr, 1.))*blend, .5);\n            float fc = ww-abs(pc.x);\n            v = smin(v, max(-fc, sdTorus(vec3(sign(pc.x)*ww-pc.x, fr-wr, pc.z), vec2(ww, 1.)))*blend, .5);\n        }\n    }\n    \n    //顶部\n    v = smin(v, sdTorus(MOV(292.), vec2(30., 3.)), .5);\n    pc = MOV(305.);\n    u = sdSphere(pc, 30.);\n    STONE(11);\n    \n    v = smin(v, sdTorus(vec3(pc.y,pc.x,pc.z), vec2(31., 1.)), .5);\n    v = smin(v, sdTorus(vec3(pc.y,pc.z,pc.x), vec2(31., 1.)), .5);\n    \n    float xv = sdRoundBox(MOV(365.), vec3(4.,30.,5.), 2.);\n    pc = MOV(375.);\n    xv = min(xv, sdRoundBox(pc, vec3(4.,5.,20.), 2.));\n    #define XRS nr = vec3(pc.x,xr.x,xr.y); //u = sdRoundBox(nr, vec3(6,3.5,3.5), 2.); STONE(13);\n    vec2 xr = rot(vec2(pc.y,pc.z), PI/4.);\n    vec3 nr;\n    XRS;\n    \n    xr = rot(vec2(pc.y,pc.z-20.), PI/4.);\n    XRS;\n    xv = min(xv, sdRoundBox(nr, vec3(4,6,6), 2.));\n    \n    xr = rot(vec2(pc.y,pc.z+20.), PI/4.);\n    XRS;\n    xv = min(xv, sdRoundBox(nr, vec3(4,6,6), 2.));\n    \n    xr = rot(vec2(pc.y-20.,pc.z), PI/4.);\n    XRS;\n    xv = min(xv, sdRoundBox(nr, vec3(4,6,6), 2.));\n    \n    v = smin(v, xv, 1.);\n    \n    if (obj.d > 0. && obj.d > v) {\n        obj.d = v;\n        obj.type = 2;\n    }\n    \n    return obj;\n}\n\nvec3 calcNormal2( in vec3 pos ) {\n    const vec2 eps = vec2(0.001,0.0);\n    return normalize(vec3(\n        map(pos+eps.xyy).d - map(pos-eps.xyy).d,\n        map(pos+eps.yxy).d - map(pos-eps.yxy).d,\n        map(pos+eps.yyx).d - map(pos-eps.yyx).d));\n}\n\nvec3 calcNormal(in vec3 p) {\n    const vec2 e = vec2(.01, 0);\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]).d;\n        sgn = -sgn;\n        if(sgn>2.) break; \n    }\n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\nfloat softShadow(in vec3 ro) {\n    float sha = 1., st;\n    for (float t=0.; sha>0. && t<400.; t+=st) {\n        vec3 pos = ro + SUN_DIR * t;\n        Object obj = map(pos);\n        if (obj.d < t*0.01) {\n            sha = min(sha, 1. + (obj.d-t*0.01) / (t*0.02));\n        }\n        st = max(.1, obj.d);\n    }\n    return max(0., sha);\n}\n\n/*\nfloat calcAO(in vec3 ro, in vec3 sn) {\n    float ao = 1.;\n    for (float t=0.1; t<2.; t+=.1) {\n        float deg = t*PI;\n        vec3 pos = ro + vec3(sin(deg)*t, 2.-t, cos(deg)*t);\n        Object obj = map(pos);\n        if (obj.d < 0.) {\n            ao -= .05;\n        }\n    }\n    return ao;\n}\n*/\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 1., occ = 0.;\n    for( int i = min(iFrame, 0); i<5; i++ ){\n        float hr = float(i + 1)*0.5;\n        float d = map(p + n*hr).d;\n        occ += (hr - d)*sca*.1;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0.2, 1.);\n}\n\n\nfloat raymarch(in vec3 ro, in vec3 rd, out Object obj) {\n    float st;\n    for (float t=0.; t<1500.; t+=st) {\n        vec3 pos = ro + t*rd;\n        if (pos.y < -500.) {\n            break;\n        }\n\n        obj = map(pos);\n        if (obj.d < 0.)\n            return t;\n\n        st = max(.1, obj.d);\n    }\n\n    obj.type = 0;\n    return 10000.;\n}\n\nfloat fresnel(vec3 ray, vec3 norm, float n2) {\n   float r0 = pow((1.-n2)/(1.+n2), 2.);\n   return r0 + (1.-r0)*pow(1. + min(dot(ray, norm), 0.), 5.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 ro, ta;\n    if (iMouse.z + iMouse.w > 0.) {\n        vec2 uvMouse = (iMouse.xy / iResolution.xy);\n        float deg = (uvMouse.x-.5)*2.*3.1415926;\n        ro = vec3(sin(deg), sin(uvMouse.y*1.4) + .225, cos(deg))*LOOK;\n        ta = vec3(0, 120., 0);\n    } else {\n        int phase = int(iTime / 10.) % 4;\n        float time = mod(iTime, 10.);\n        float deg = (time-5.)/5.;\n        //phase = 3;\n        if (phase == 2) {\n            ro = vec3(sin(deg*PI*.3), .9-deg, cos(deg*PI*.3))*500.;\n            ta = vec3(0, 120., 0);\n        } else if (phase == 1) {\n            ro = vec3(sin(deg*PI*.5), .225, cos(deg*PI*.5))*400.;\n            ta = vec3(0, 150., 0);\n        } else if (phase == 0) {\n            deg = deg * .85 - .15;\n            ro = vec3(sin(deg*PI*.15), .225+(deg+1.)*1.5, cos(deg*PI*.15))*(1.-deg)*(350.+deg*50.);\n            ta = vec3(0, 120.+(deg+1.)*100., 0);\n        } else {\n            ro = vec3(sin(deg*PI), .925, cos(deg*PI))*500.;\n            ta = vec3(0, 120., 0);\n        }\n    }\n\n    mat3 ca = setCamera( ro, ta );\n    vec2 px = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    vec3 rd = ca * normalize(vec3(px, sqrt(3.)));\n\n    vec3 fCol = vec3(0);\n    vec3 lCol = vec3(1);\n\n    for (int i=0;i<2;i++) {\n        Object obj;\n        float far = raymarch(ro, rd, obj);\n        vec3 sp = ro + rd * far;\n\n        vec3 sn = calcNormal(sp);\n        vec3 reflection = reflect(rd, sn);\n        \n        float sha, ao;\n        if (i == 0) {\n            sha = softShadow(sp + sn * .9);\n            ao = calcAO(sp, sn);\n        } else {\n            sha = 1.;\n            ao = 1.;\n        }\n        \n        float rac = -dot(rd, sn);\n        float dif = max(dot(SUN_DIR, sn), 0.);\n        float spe = max(dot(reflection, SUN_DIR), 0.);\n        float fre = clamp(1. - rac, 0., 1.);\n        float amt = .2;\n        \n        vec3 add = vec3(0);\n        vec3 oCol, rCol;\n        if (obj.type == 1) {\n            spe = pow(spe, 15.)*10.; \n            float rl = length(sp.xz);\n            oCol = pow(texture(iChannel1,vec2(sp.x-sp.y*sp.x/rl, sp.z-sp.y*sp.z/rl)*0.003).rgb, vec3(1.5));\n            float resl = fresnel(rd, sn, 1.5);\n            rCol = pow(oCol, vec3(.5)) * resl;//smoothstep(1., 0., rac) * 0.8;\n        } else if (obj.type == 2) {\n            vec3 tx = tex3D(iChannel0, sp*.02, sn);\n            tx = smoothstep(-.05, .5, tx);\n            tx = tx*.3+.5;\n            oCol = tx*mix(vec3(.9, 1, 1.2).zyx, vec3(.9, 1, 1.2), tx.x);\n            oCol *= vec3(1., .85, .1);\n            //完全抛光金属折射率约90%，这里不做成抛光\n            rCol = oCol * .2 + .3;\n            spe = pow(spe, 8.)*20.;\n            dif = pow(dif, 4.)*2.;\n        } else if (obj.type == 3) {\n            oCol = vec3(1.);\n            spe = pow(spe, 20.)*30.;\n            //dif *= .9;\n            rCol = oCol * smoothstep(1., 0., rac) * 0.5;\n        } else if (obj.type == 10) {\n            oCol = vec3(1);\n            spe = pow(spe, 40.)*200.;\n            float resl = fresnel(rd, sn, 1./2.4);\n            vec3 rayRd = refract(rd, sn, 1./2.4);\n            vec3 rayRo = sp;\n            vec3 pos;\n            float st;\n            for (int n=0; n<5; n++) {\n                for (float t=0.; t<50.; t+=st) {\n                    pos = rayRo + t*rayRd;\n                    Object obj = map(pos);\n                    if (obj.d > 0.) {\n                        pos = rayRo + (t-st)*rayRd;\n                        break;\n                    }\n                    st = max(.1, -obj.d);\n                }\n                vec3 raySn = -calcNormal(pos);\n                vec3 oldRd = rayRd;\n                rayRd = refract(oldRd, raySn, 2.4);\n                if (length(rayRd) != 0.) //光线飞出\n                    break;\n                rayRd = reflect(oldRd, raySn);\n                rayRo = pos;\n            }\n            add += texture(iChannel2, rayRd).rgb; //飞出可能碰到皇冠自己和桌子，需要再次调用整体渲染，而不是直接用环境贴图\n            add *= 1. - resl;\n            spe += pow(max(dot(rayRd, SUN_DIR), 0.), 40.)*200.;\n            rCol = oCol * resl;\n            dif = 0.;\n            amt = 0.; \n        } else if (obj.type > 10) {\n            vec3 rayRef;\n            float tr;\n            if (obj.type == 11) {\n                oCol = vec3(1,.2,.1);\n                tr = smoothstep(1., 0.76, rac);\n                rayRef = refract(rd, sn, 0.15);\n            } else if (obj.type == 12) {\n                oCol = vec3(.1,1,.1);\n                tr = smoothstep(1., 0.76, rac);\n                rayRef = refract(rd, sn, 0.15);\n            } else if (obj.type == 13) {\n                oCol = vec3(.1,.2,1);\n                tr = smoothstep(1., 0.76, rac);\n                rayRef = refract(rd, sn, 0.15);\n            } else {\n                oCol = vec3(1);\n                tr = smoothstep(1., 0.91, rac);\n                rayRef = refract(rd, sn, 0.24);\n            }\n            add = (1.-tr) * texture(iChannel2, rayRef).rgb;\n            dif = 0.;\n            spe = pow(spe, 40.)*200.;\n            amt = 0.1;\n            rCol = oCol * tr;\n        } else {\n            oCol = texture(iChannel2, rd).rgb;\n            dif = 1.;\n            spe = 0.;\n            amt = 0.;\n            rCol = vec3(0); \n        }\n        fCol += lCol * (min(oCol * ((dif + spe)*sha + amt), 1.) + add) * ao;\n        lCol *= rCol;\n        \n        rd = reflection;\n        ro = sp + rd * 0.1;;\n\n        if (length(lCol) < 0.01)\n            break;\n    }\n    \n    fragColor = vec4(pow(fCol, vec3(0.6)), 1.);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lcyfR3","date":"1734263614","viewed":376,"name":"magnificent crown","username":"lerrain","description":"A magnificent crown, rendered realistically.\nby lerrain@gmail.com 2024/12/15，thanks to IQ、Shane and TambakoJaguar","likes":21,"published":3,"flags":0,"usePreview":1,"tags":["raycast","sdf","diamond","marble","gem","stone","gold","ruby","pearl","dazzling","crown","jewel","sapphire","magnificent"],"hasliked":0,"parentid":"","parentname":""}}