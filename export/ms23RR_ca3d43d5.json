{"ver":"0.1","info":{"id":"ms23RR","date":"1667221504","viewed":210,"name":"Soap bubble attempt","username":"Krafpy","description":"An attempt to simulate soap bubble color interferences.","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","interference","iridescence"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RADIUS 1.\n#define RGB vec3(612.,549.,464.)\n#define PI 3.14159265\n#define TWO_PI 6.283185\n\n// 2D rotation matrix\nmat2 rot(float a){\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// from https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 gradient(vec3 p){\n    vec3 r = hash33(p);\n    r = r*2. - 1.;\n    return normalize(r);\n}\n\n// 3D gradient noise\nfloat noise(vec3 p){\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    \n    f = smoothstep(0., 1., f);\n    \n    vec2 h = vec2(1., 0.);\n    \n    vec3 g0 = gradient(i+h.yyy);\n    vec3 g1 = gradient(i+h.xyy);\n    vec3 g2 = gradient(i+h.yxy);\n    vec3 g3 = gradient(i+h.xxy);\n    vec3 g4 = gradient(i+h.yyx);\n    vec3 g5 = gradient(i+h.xyx);\n    vec3 g6 = gradient(i+h.yxx);\n    vec3 g7 = gradient(i+h.xxx);\n    \n    float v0 = dot(p-(i+h.yyy), g0);\n    float v1 = dot(p-(i+h.xyy), g1);\n    float v2 = dot(p-(i+h.yxy), g2);\n    float v3 = dot(p-(i+h.xxy), g3);\n    float v4 = dot(p-(i+h.yyx), g4);\n    float v5 = dot(p-(i+h.xyx), g5);\n    float v6 = dot(p-(i+h.yxx), g6);\n    float v7 = dot(p-(i+h.xxx), g7);\n    \n    float v01 = mix(v0, v1, f.x);\n    float v23 = mix(v2, v3, f.x);\n    float vv1 = mix(v01, v23, f.y);\n    \n    float v45 = mix(v4, v5, f.x);\n    float v67 = mix(v6, v7, f.x);\n    float vv2 = mix(v45, v67, f.y);\n    \n    float v = mix(vv1, vv2, f.z);\n    \n    v = v*0.5+0.5;\n\n\treturn v;\n}\n\n// Fractal brownian motion\nfloat fbm(vec3 p){\n    float f = 0.5*noise(p); p *= 2.;\n    f += 0.25*noise(p); p *= 2.;\n    f += 0.125*noise(p); p *= 2.;\n    return f;\n}\n\n// SDF of the bubble\nfloat sdf(vec3 p){\n    float d = length(p) - RADIUS;\n    d -= noise(p+iTime)*0.1;\n    return d;\n}\n\nvec3 normal(vec3 p){\n    vec2 h = vec2(0.001, 0.);\n    return normalize(vec3(\n        sdf(p+h.xyy) - sdf(p-h.xyy),\n        sdf(p+h.yxy) - sdf(p-h.yxy),\n        sdf(p+h.yyx) - sdf(p-h.yyx)\n    ));\n}\n\nfloat raymarch(vec3 ro, vec3 rd) {\n    float eps = 0.001;\n    float t = 0.;\n    for(int i = 0; i < 32; ++i){\n        float d = sdf(ro + rd * t);\n        if(d < eps){\n            return t;\n        }\n        t += 0.9*d;\n    }\n    return -1.;\n}\n\nfloat sat(float x){\n    return clamp(x, 0., 1.);\n}\n\n// returns the thickness of the water layer at a given point, in nanometers\nfloat thickness(vec3 p){ \n    float h = 590.;\n    \n    //float y = sat(0.5*(p.y+RADIUS)/RADIUS);\n    //h += mix(0., -200., pow(1.-y, 2.));\n    \n    p *= 3.;\n    p.y += 0.5*iTime;\n    float f = fbm(p + 5.*fbm(5.*p + 10.*fbm(p)));\n    h += mix(-150., 250., f);\n    \n    return h;\n}\n\nvec3 background(vec3 rd){\n    return texture(iChannel0, rd).rgb;\n}\n\nvec3 color(vec3 p, vec3 rd){\n    float n1 = 1.; // air refraction index\n    float n2 = 1.33; // water refraction index\n    \n    vec3 n = normal(p);\n    float cosi1 = -dot(rd, n);\n    \n    // Schlick approximation\n    float R0 = (n2-1.)/(n2+1.); R0 *= R0; // reflection coefficient at normal incidence\n    float R = R0 + (1. - R0)*pow(1.-cosi1, 5.);\n    float T = 1.-R;\n    \n    float h = thickness(p);\n    \n    // Phase shift between the ray reflected from the outer surface\n    // of the bubble and the ray reflected from the inner surface\n    //float a = 2.*n2 - 2.*(n1*n1/n2)*(1.-cosi1*cosi1);\n    //float b = 1. - (n1/n2)*(n1/n2)*(1.-cosi1*cosi1);\n    //vec3 shift = TWO_PI * (a/sqrt(b)) * (h/RGB) + PI/2.;\n    \n    // Simpler formula based on:\n    // https://www.alanzucconi.com/2017/07/25/the-mathematics-of-thin-film-interference/\n    // Looks equivalent to my first attempt one above.\n    float a = n1/n2;\n    float cosi2 = sqrt(1. - a*a*(1. - cosi1*cosi1));\n    vec3 shift = 4.*PI*(h/RGB)*n2*cosi2 + PI/2.;\n    \n    // Intensity of each color channel after interference\n    vec3 irid = R*( 1. + T*( T + 2.*cos(shift) ) );\n    \n    // Reflection and background\n    vec3 ref = background(reflect(rd, n));\n    vec3 bak = background(rd);\n    \n    // Specular reflection\n    vec3 spec = pow(ref, vec3(7.));\n    \n    // Final color\n    vec3 col = ref*irid + T*T*T*T*bak + spec*irid;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    // pixel ray    \n    vec3 ro = vec3(0., 0., -3.5);\n    vec3 rd = normalize(vec3(uv, 1.));\n    \n    // control camera\n    vec2 mouseAngle = iMouse.xy/iResolution.xy;\n    mouseAngle -= 0.5;\n    mouseAngle.x *= iResolution.x / iResolution.y;\n    mouseAngle *= PI;\n    \n    ro.yz *= rot(mouseAngle.y);\n    rd.yz *= rot(mouseAngle.y);\n    ro.xz *= rot(mouseAngle.x);\n    rd.xz *= rot(mouseAngle.x);\n    \n    \n    // coloring\n    float t = raymarch(ro, rd);\n    if(t > 0.){\n        vec3 p = ro + rd*t;\n        col = color(p, rd);\n    } else {\n        col = background(rd);\n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}