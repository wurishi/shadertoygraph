{"ver":"0.1","info":{"id":"mdBGDt","date":"1716556891","viewed":105,"name":"path tracing by Erik","username":"eriben0628","description":"asdf","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["adf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 color = texture(iChannel0, uv)/(texture(iChannel1,vec2(0.0)).x+1.0);\n    color = tanh(color);\n    //color = 1.0-0.3/(0.3+color);\n    \n    \n    fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define ObjectCount 4\n\nstruct Object {\n    vec3 pos;\n    vec3 normal;\n    float radius;\n    vec3 color;\n    vec3 emisionColor;\n    float roughness;\n    int type;\n};\n\nvec3 randomPos(vec3 a) {\n    //float x = fract(length(sin(a*a*130.23)*654.23));\n    //float y = fract(length(sin(a*53.43)*73.435+x+a))*2.0-1.0;\n    //float z = fract(length(sin(a*1626.64+x)*143.2345+y)+y)*2.0-1.0;\n    \n    vec3 b = a;\n    for(int i = 0; i < 2; i++) b = fract(b.zxy*9835.0+a+b.xzy+float(i)*10.0)*2.0-1.0;\n    \n    \n    return normalize(b);\n}\n\nvec2 DistanceToSphere(vec3 Dir, vec3 Origin, vec3 Center, float radius) {\n    vec3 D = Center - Origin;\n    float a = dot(Dir, D);\n    float b =a*a-dot(D,D)+radius*radius;\n    if(b < 0.0) return vec2(10000.0);\n    b = sqrt(b);\n    vec2 c = vec2(a-b, a+b);\n    if (c.x < 0.0) return vec2(10000.0,10000.0);\n    return c;\n}\n\nfloat DistanceToPlane(vec3 Origin, vec3 Dir, vec3 Pos, vec3 Normal) {\n    float d = dot(Pos-Origin,Normal) / dot(Dir,Normal);\n    if(d < 0.0) d = 100000.0;\n    \n    return d;\n}\n\nfloat brdf(vec3 inDir, vec3 outDir, vec3 normal, float roughness) {\n    vec3 r = reflect(inDir, normal);\n    float a = 1.0;\n    float b = clamp(dot(outDir,r),0.0,1.0);\n    if(roughness != 0.0) b = pow(b, 1.0/(roughness));\n    else b = 1.0;\n    float c = mix(b,a,roughness);\n    \n    return c;\n}\n\nvec3 ReflectedDir(vec3 Dir, vec3 normal, float roughness) {\n    if(roughness == 0.0) return reflect(Dir,normal);\n    vec3 diffusedDir = normalize(randomPos(Dir));\n    diffusedDir *= sign(dot(diffusedDir,normal));\n    vec3 r = reflect(Dir, normal);\n    \n    return normalize(mix(r,diffusedDir, roughness));\n}\n\nObject InizialiseObject (vec3 pos, vec3 normal, float radius, float roughness, vec3 color, vec3 emisionColor, int type) {\n    Object object;\n    object.pos = pos;\n    object.normal = normal;\n    object.radius = radius;\n    object.roughness =  roughness;\n    object.color = color;\n    object.emisionColor = emisionColor;\n    object.type = type;\n    \n    return object;\n}\n\nvec3 skybox(vec3 Dir) {\n    vec3 sun = normalize(vec3(0.5,0.5,0.5));\n    float sunDot = max(dot(Dir,sun),0.0);\n    sunDot = pow(sunDot, 1000.0);\n    vec3 lowerSkyColor = vec3(0.6,0.7,0.9);\n    vec3 higherSkyColor = vec3(0.4,0.4,0.9);\n    vec3 skyColor = mix(lowerSkyColor, higherSkyColor,max(0.0,Dir.y));\n    return vec3(sunDot)*40.0 + skyColor;\n}\n\nvec3 picture(vec3 Dir, vec3 Origin) {\n    //type 1: plane\n    //type 2: sphere\n\n    Object[ObjectCount] objects;\n    //                                 pos                  normal    radius roughness color  emisionColor  type\n    objects[0] = InizialiseObject( vec3(0.0,-1.0,0.0), vec3(0.0,1.0,0.0), 0.0, 0.5, vec3(1.0,0.6,0.6), vec3(0.0,0.0,0.0), 1);\n    objects[1] = InizialiseObject( vec3(0.0,0.0,0.0) , vec3(0.0,0.0,0.0), 1.0, 0.0, vec3(0.9), vec3(0.0,0.0,0.0), 2);\n    objects[2] = InizialiseObject( vec3(-2.0,0.0,0.0), vec3(0.0,0.0,0.0), 1.0, 0.5, vec3(0.9), vec3(0.0,0.0,0.0), 2);\n    objects[3] = InizialiseObject( vec3(-4.0,0.0,0.0), vec3(0.0,0.0,0.0), 1.0, 1.0, vec3(0.9), vec3(0.0,0.0,0.0), 2);\n    \n    \n    \n    vec3 color = vec3(0.0);\n    vec3 transmittence = vec3(1.0);\n    vec3 normal=vec3(0.0);\n    \n    \n    int hitID;\n    vec3 hitpos;\n    \n    for(int i = 0; i < 20; i++) {\n        \n        float distanceToScene = 1000000.0;\n        for(int n = 0; n < ObjectCount; n++) {\n            float dist;\n            if(objects[n].type == 1) dist = DistanceToPlane(Origin, Dir, objects[n].pos, objects[n].normal);\n            if(objects[n].type == 2) dist = DistanceToSphere(Dir, Origin, objects[n].pos, objects[n].radius).x;\n            \n            if(dist < distanceToScene) {\n                hitID = n;\n                distanceToScene = dist;\n            }\n        }\n    \n        if(distanceToScene > 1000.0) { \n            color += skybox(Dir)*transmittence;\n            break;\n        }\n        \n        hitpos = Origin + Dir*distanceToScene;\n        \n        if(objects[hitID].type == 1) normal = objects[hitID].normal;\n        if(objects[hitID].type == 2) normal = (hitpos-objects[hitID].pos) / objects[hitID].radius;\n        \n        color += objects[hitID].emisionColor*transmittence;\n        \n        Origin = hitpos+normal*0.001;\n        vec3 reflectedDir = ReflectedDir(Dir, normal, objects[hitID].roughness);\n        transmittence *= brdf(Dir,reflectedDir,normal,objects[hitID].roughness);\n        transmittence *= objects[hitID].color;\n        Dir = reflectedDir;\n        transmittence *= objects[hitID].color;\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 color = vec3(0.0);\n    vec3 dir = vec3(uv,1.0);\n    for(int i = 0; i < 10; i++) {\n        vec3 Dir = normalize(dir+randomPos(vec3(iTime+float(i)*0.1,uv.x,uv.y))/iResolution.yyy);\n        vec3 Origin = vec3(-2.0,0.0,-5.0);\n        color += picture(Dir, Origin);\n    }\n    color *= 0.1;\n    //color = color/(color+1.0);\n    if(texture(iChannel1, vec2(0.0)).z == 1.0) fragColor = vec4(color,1.0);\n    else fragColor = vec4(color,1.0) + texture(iChannel0, fragCoord/iResolution.xy);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 Output = texture(iChannel0, vec2(0.0));\n    if(iFrame == 0) Output = vec4(0.0);\n    else Output.x += 1.0;\n    Output.z = 0.0;\n    if(Output.y != iResolution.x) {\n        Output.y = iResolution.x;\n        Output.z = 1.0;\n        Output.x = 0.0;\n    }\n    \n    fragColor = Output;\n}","name":"Buffer B","description":"","type":"buffer"}]}