{"ver":"0.1","info":{"id":"lflSDl","date":"1707732522","viewed":33,"name":"[inspirnathan] 12 - Shadows","username":"hrst4","description":"[inspirnathan] 12 - Shadows","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["inspirnathan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This a french translation of the highly educational Nathan Vaughn's tutorials.\n// Un grand merci à lui !\n// his website: https://inspirnathan.com/\n// original:\n// from https://inspirnathan.com/posts/59-shadertoy-tutorial-part-13\n#define PART 7\n\n/*\nBonjour, chers amis ! Bienvenue dans la 13ème partie de ma série de tutoriels Shadertoy.\nDans ce tutoriel, nous allons apprendre à ajouter des ombres à notre scène 3D.\nConfiguration initiale\n\nNotre code de départ pour ce tutoriel va être un peu différent cette fois-ci.\nNous allons revenir au rendu de scènes avec une seule couleur et nous allons revenir\nà l'utilisation d'une caméra basique sans point d'observation.\nJ'ai également simplifié la fonction rayMarch. \nElle accepte deux paramètres au lieu de quatre. Nous n'utilisions pas vraiment les deux derniers\nparamètres de toute façon.\n*/\n#if PART == 0\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat sdFloor(vec3 p) {\n  return p.y + 1.;\n}\n\nfloat scene(vec3 p) {\n  float co = min(sdSphere(p, 1., vec3(0, 0, -2)), sdFloor(p));\n  return co;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d; // distance ray has travelled\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0);\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  vec3 rd = normalize(vec3(uv, -1)); // ray direction\n\n  float sd = rayMarch(ro, rd); // signed distance value to closest object\n\n  if (sd > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * sd; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(cos(iTime), 2, sin(iTime));\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.); // diffuse reflection clamped between zero and one\n\n    col = vec3(dif);\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\n\n/*\nAprès avoir exécuté le code, nous devrions voir une scène 3D très basique avec une sphère, \nun sol et une réflexion diffuse. \nLa couleur de la réflexion diffuse sera une nuance de gris entre le noir et le blanc.\nhttps://inspirnathan.com/_nuxt/img/img-1.5c620f6.png\n\n# Ombres basiques\nCommençons par apprendre à ajouter des ombres très simples. \nAvant de commencer à coder, regardons l'image ci-dessous pour visualiser le fonctionnement de l'algorithme.\nhttps://inspirnathan.com/_nuxt/img/img-2.8da7582.png\n\nNotre fonction rayMarch implémente l'algorithme de ray marching.\n\nNous l'utilisons actuellement pour découvrir un point dans la scène qui touche l'objet \nou la surface la plus proche. \n\nCependant, nous pouvons l'utiliser une seconde fois pour générer un nouveau rayon et le diriger\nvers notre source lumineuse dans la scène. Dans l'image ci-dessus, des \"rayons d'ombre\"\nsont projetés vers la source lumineuse depuis le sol.\n\nDans notre code, nous effectuerons le ray marching une seconde fois,\nl'origine du nouveau rayon étant égale à p, \nle point de la sphère ou du sol découvert lors de la première étape du ray marching.\n\nLa nouvelle direction du rayon sera égale à lightDirection. \n\nDans notre code, il suffit d'ajouter trois lignes sous le calcul de la réflexion diffuse.\n\nfloat dif = clamp(dot(normal, lightDirection), 0., 1.); // diffuse reflection clamped between zero and one\n\nvec3 newRayOrigin = p;\nfloat shadowRayLength = rayMarch(newRayOrigin, lightDirection); // cast shadow ray to the light source\nif (shadowRayLength < length(lightPosition - newRayOrigin)) dif *= 0.; // if the shadow ray hits the sphere, set the diffuse reflection to zero, simulating a shadow\n\nCependant, lorsque vous exécutez ce code, l'écran apparaît presque complètement noir.\nQue se passe-t-il ? Au cours de la première boucle de ray marching, \nnous lançons des rayons à partir de la caméra. \n\nSi notre rayon atteint un point, p, qui est plus proche du sol que la sphère,\nla valeur de la distance signée sera égale à la longueur entre la caméra et le sol.\n\nLorsque nous utilisons cette même valeur p dans la deuxième boucle de marche des rayons,\nnous savons déjà qu'elle est plus proche du sol que de la surface de la sphère.\n\nPar conséquent, presque tout semblera être dans l'ombre, ce qui rendra l'écran noir.\nNous devons choisir une valeur très proche de p lors de la deuxième étape de la marche des rayons,\nafin d'éviter ce problème.\n\nUne approche courante consiste à ajouter la normale de la surface, multipliée par une valeur minuscule,\nà la valeur de p, afin d'obtenir un point voisin.\n\nNous utiliserons la variable PRECISION comme valeur minuscule qui fera légèrement \nglisser p vers un point voisin.\n\nvec3 newRayOrigin = p + normal * PRECISION;\n\nLorsque vous exécutez le code, vous devriez maintenant voir une ombre apparaître sous la sphère.\nCependant, il y a un artefact étrange près du centre de la sphère.\nhttps://inspirnathan.com/_nuxt/img/img-3.1856d7e.png\n\nNous pouvons multiplier la valeur de la précision par deux pour la faire disparaître.\n\nvec3 newRayOrigin = p + normal * PRECISION * 2.;\n\nhttps://inspirnathan.com/_nuxt/img/img-4.b22185c.png\n\nLorsque vous ajoutez des ombres à votre scène, vous devrez peut-être continuer à ajuster newRayOrigin\nen le multipliant par différents facteurs pour voir ce qui fonctionne.\n\nCréer des ombres réalistes n'est pas une tâche facile, et vous devrez peut-être jouer \navec les valeurs jusqu'à ce que le résultat soit satisfaisant.\n\nLe code terminé devrait ressembler à ce qui suit :\n\n*/\n\n#elif PART == 1\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat sdFloor(vec3 p) {\n  return p.y + 1.;\n}\n\nfloat scene(vec3 p) {\n  float co = min(sdSphere(p, 1., vec3(0, 0, -2)), sdFloor(p));\n  return co;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d; // distance ray has travelled\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0);\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  vec3 rd = normalize(vec3(uv, -1)); // ray direction\n\n  float sd = rayMarch(ro, rd); // signed distance value to closest object\n\n  if (sd > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * sd; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(cos(iTime), 2, sin(iTime));\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.); // diffuse reflection clamped between zero and one\n    \n    vec3 newRayOrigin = p + normal * PRECISION * 2.;\n    float shadowRayLength = rayMarch(newRayOrigin, lightDirection);\n    if (shadowRayLength < length(lightPosition - newRayOrigin)) dif *= 0.;\n\n    col = vec3(dif);\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n/*\n# Ajout d'ombres à des scènes colorées\n\nEn utilisant la même technique, nous pouvons appliquer des ombres aux scènes colorées \navec lesquelles nous avons travaillé dans les derniers tutoriels.\n\n\n*/\n\n#elif PART == 2\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\n\nstruct Surface {\n    float sd; // signed distance value\n    vec3 col; // color\n};\n\nSurface sdFloor(vec3 p, vec3 col) {\n  float d = p.y + 1.;\n  return Surface(d, col);\n}\n\nSurface sdSphere(vec3 p, float r, vec3 offset, vec3 col) {\n  p = (p - offset);\n  float d = length(p) - r;\n  return Surface(d, col);\n}\n\nSurface opUnion(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\nSurface scene(vec3 p) {\n  vec3 floorColor = vec3(0.1 + 0.7 * mod(floor(p.x) + floor(p.z), 2.0));\n  Surface co = sdFloor(p, floorColor);\n  co = opUnion(co, sdSphere(p, 1., vec3(0, 0, -2), vec3(1, 0, 0)));\n  return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = scene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy).sd +\n      e.yyx * scene(p + e.yyx).sd +\n      e.yxy * scene(p + e.yxy).sd +\n      e.xxx * scene(p + e.xxx).sd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.835, 1, 1);\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  vec3 rd = normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd); // closest object\n\n  if (co.sd > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.sd; // point discovered from ray marching\n    vec3 normal = calcNormal(p);\n\n    vec3 lightPosition = vec3(cos(iTime), 2, sin(iTime));\n    vec3 lightDirection = normalize(lightPosition - p);\n    \n    float dif = clamp(dot(normal, lightDirection), 0., 1.); // diffuse reflection\n    \n    vec3 newRayOrigin = p + normal * PRECISION * 2.;\n    float shadowRayLength = rayMarch(newRayOrigin, lightDirection).sd; // cast shadow ray to the light source\n    if (shadowRayLength < length(lightPosition - newRayOrigin)) dif *= 0.0; // shadow\n\n    col = dif * co.col; \n    \n  }\n\n  fragColor = vec4(col, 1.0); // Output to screen\n}\n\n/*\nSi vous exécutez ce code, vous devriez voir une sphère rouge avec une source lumineuse mobile \n(et donc une ombre \"mobile\"), mais la scène entière semble un peu trop sombre.\nhttps://inspirnathan.com/_nuxt/img/img-5.6ee1800.png\n\n# Correction Gamma\n\nNous pouvons appliquer un peu de correction gamma pour rendre les couleurs plus sombres plus lumineuses.\nNous ajouterons cette ligne juste avant d'afficher la couleur finale à l'écran.\n\ncol = pow(col, vec3(1.0/2.2)); // Gamma correction\n\nVotre fonction mainImage devrait maintenant ressembler à ce qui suit :\nhttps://inspirnathan.com/_nuxt/img/img-6.7823442.png\n*/\n\n#elif PART == 3\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\n\nstruct Surface {\n    float sd; // signed distance value\n    vec3 col; // color\n};\n\nSurface sdFloor(vec3 p, vec3 col) {\n  float d = p.y + 1.;\n  return Surface(d, col);\n}\n\nSurface sdSphere(vec3 p, float r, vec3 offset, vec3 col) {\n  p = (p - offset);\n  float d = length(p) - r;\n  return Surface(d, col);\n}\n\nSurface opUnion(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\nSurface scene(vec3 p) {\n  vec3 floorColor = vec3(0.1 + 0.7 * mod(floor(p.x) + floor(p.z), 2.0));\n  Surface co = sdFloor(p, floorColor);\n  co = opUnion(co, sdSphere(p, 1., vec3(0, 0, -2), vec3(1, 0, 0)));\n  return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = scene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy).sd +\n      e.yyx * scene(p + e.yyx).sd +\n      e.yxy * scene(p + e.yxy).sd +\n      e.xxx * scene(p + e.xxx).sd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.835, 1, 1);\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  vec3 rd = normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd); // closest object\n\n  if (co.sd > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.sd; // point discovered from ray marching\n    vec3 normal = calcNormal(p);\n\n    vec3 lightPosition = vec3(cos(iTime), 2, sin(iTime));\n    vec3 lightDirection = normalize(lightPosition - p);\n    \n    float dif = clamp(dot(normal, lightDirection), 0., 1.); // diffuse reflection\n    \n    vec3 newRayOrigin = p + normal * PRECISION * 2.;\n    float shadowRayLength = rayMarch(newRayOrigin, lightDirection).sd; // cast shadow ray to the light source\n    if (shadowRayLength < length(lightPosition - newRayOrigin)) dif *= 0.; // shadow\n\n    col = dif * co.col; \n    \n  }\n\n  col = pow(col, vec3(1.0/2.2)); // Gamma correction\n  fragColor = vec4(col, 1.0); // Output to screen\n}\n\n/*\nL'ombre semble encore un peu trop sombre.\nNous pouvons l'éclaircir en ajustant l'échelle de la réflexion diffuse.\nActuellement, nous mettons la couleur de réflexion diffuse du sol et de la sphère à zéro \nlorsque nous calculons quels points se trouvent dans l'ombre.\n\nNous pouvons modifier le \"facteur d'échelle\" en le fixant à 0,2 :\n\nif (shadowRayLength < length(lightPosition - newRayOrigin)) dif *= 0.2; // shadow\n\nL'ombre est maintenant un peu plus belle, et vous pouvez voir la couleur diffuse du sol à travers l'ombre.\n\n*/\n\n#elif PART == 4\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\n\nstruct Surface {\n    float sd; // signed distance value\n    vec3 col; // color\n};\n\nSurface sdFloor(vec3 p, vec3 col) {\n  float d = p.y + 1.;\n  return Surface(d, col);\n}\n\nSurface sdSphere(vec3 p, float r, vec3 offset, vec3 col) {\n  p = (p - offset);\n  float d = length(p) - r;\n  return Surface(d, col);\n}\n\nSurface opUnion(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\nSurface scene(vec3 p) {\n  vec3 floorColor = vec3(0.1 + 0.7 * mod(floor(p.x) + floor(p.z), 2.0));\n  Surface co = sdFloor(p, floorColor);\n  co = opUnion(co, sdSphere(p, 1., vec3(0, 0, -2), vec3(1, 0, 0)));\n  return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = scene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy).sd +\n      e.yyx * scene(p + e.yyx).sd +\n      e.yxy * scene(p + e.yxy).sd +\n      e.xxx * scene(p + e.xxx).sd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.835, 1, 1);\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  vec3 rd = normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd); // closest object\n\n  if (co.sd > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.sd; // point discovered from ray marching\n    vec3 normal = calcNormal(p);\n\n    vec3 lightPosition = vec3(cos(iTime), 2, sin(iTime));\n    vec3 lightDirection = normalize(lightPosition - p);\n    \n    float dif = clamp(dot(normal, lightDirection), 0., 1.); // diffuse reflection\n    \n    vec3 newRayOrigin = p + normal * PRECISION * 2.;\n    float shadowRayLength = rayMarch(newRayOrigin, lightDirection).sd; // cast shadow ray to the light source\n    if (shadowRayLength < length(lightPosition - newRayOrigin)) dif *= 0.2; // shadow\n\n    col = dif * co.col; \n    \n  }\n\n  col = pow(col, vec3(1.0/2.2)); // Gamma correction\n  fragColor = vec4(col, 1.0); // Output to screen\n}\n\n/*\n# Ombres douces\n\nDans la vie réelle, les ombres ont tendance à avoir plusieurs parties, y compris une ombre,\nune pénombre et une pénombre.\n\nNous pouvons ajouter une \"ombre douce\" qui tente de copier les ombres dans la vie réelle en \nutilisant des algorithmes trouvés sur le site Web d'Inigo Quilez.\n\nVous trouverez ci-dessous une implémentation de la fonction \"ombre douce\" trouvée dans \nle shader populaire de Shadertoy, Raymarching Primitives Commented. \n\nJ'ai fait des ajustements pour la rendre compatible avec notre code.\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float tmax) {\n  float res = 1.0;\n  float t = mint;\n\n  for(int i = 0; i < 16; i++) {\n    float h = scene(ro + rd * t).sd;\n      res = min(res, 8.0*h/t);\n      t += clamp(h, 0.02, 0.10);\n      if(h < 0.001 || t > tmax) break;\n  }\n\n  return clamp( res, 0.0, 1.0 );\n}\n\nDans notre fonction mainImage, nous pouvons supprimer le code \"hard shadow\" et le remplacer \npar l'implémentation \"soft shadow\".\n\nfloat softShadow = clamp(softShadow(p, lightDirection, 0.02, 2.5), 0.1, 1.0);\ncol = dif * co.col * softShadow;\n\nNous pouvons serrer l'ombre entre 0,1 et 1,0 pour l'éclaircir un peu, afin qu'elle ne soit pas trop sombre.\nhttps://inspirnathan.com/_nuxt/img/img-8.b8e98f6.png\n*/\n\n#elif PART == 5\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\n\nstruct Surface {\n    float sd; // signed distance value\n    vec3 col; // color\n};\n\n\n\n\nSurface sdFloor(vec3 p, vec3 col) {\n  float d = p.y + 1.;\n  return Surface(d, col);\n}\n\nSurface sdSphere(vec3 p, float r, vec3 offset, vec3 col) {\n  p = (p - offset);\n  float d = length(p) - r;\n  return Surface(d, col);\n}\n\nSurface opUnion(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\nSurface scene(vec3 p) {\n  vec3 floorColor = vec3(0.1 + 0.7 * mod(floor(p.x) + floor(p.z), 2.0));\n  Surface co = sdFloor(p, floorColor);\n  co = opUnion(co, sdSphere(p, 1., vec3(0, 0, -2), vec3(1, 0, 0)));\n  return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = scene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy).sd +\n      e.yyx * scene(p + e.yyx).sd +\n      e.yxy * scene(p + e.yxy).sd +\n      e.xxx * scene(p + e.xxx).sd);\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float tmax) {\n  float res = 1.0;\n  float t = mint;\n\n  for(int i = 0; i < 16; i++) {\n    float h = scene(ro + rd * t).sd;\n      res = min(res, 8.0*h/t);\n      t += clamp(h, 0.02, 0.10);\n      if(h < 0.001 || t > tmax) break;\n  }\n\n  return clamp( res, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.835, 1, 1);\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  vec3 rd = normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd); // closest object\n\n  if (co.sd > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.sd; // point discovered from ray marching\n    vec3 normal = calcNormal(p);\n\n    vec3 lightPosition = vec3(cos(iTime), 2, sin(iTime));\n    vec3 lightDirection = normalize(lightPosition - p);\n    \n    float dif = clamp(dot(normal, lightDirection), 0., 1.); // diffuse reflection\n    \n    vec3 newRayOrigin = p + normal * PRECISION * 2.;\n    float shadowRayLength = rayMarch(newRayOrigin, lightDirection).sd; // cast shadow ray to the light source\n    if (shadowRayLength < length(lightPosition - newRayOrigin)) dif *= 0.2; // shadow\n    \n    float softShadow = clamp(softShadow(p, lightDirection, 0.02, 2.5), 0.1, 1.0);\n    col = dif * co.col * softShadow;\n\n    \n  }\n\n  col = pow(col, vec3(1.0/2.2)); // Gamma correction\n  fragColor = vec4(col, 1.0); // Output to screen\n}\n\n/*\nRemarquez les bords de l'ombre douce. \nLa transition entre l'ombre et la couleur normale du sol est plus douce.\n\n# Application du brouillard\n\nVous avez peut-être remarqué que la couleur de la sphère qui ne fait pas face\nà la lumière est encore trop sombre. \nNous pouvons tenter de l'éclaircir en ajoutant 0,5 à la réflexion diffuse, dif.\n\nfloat dif = clamp(dot(normal, lightDirection), 0., 1.) + 0.5; // diffuse reflection\n\nLorsque vous exécutez le code, vous verrez que la sphère apparaît un peu plus claire,\nmais que l'arrière du sol au loin semble un peu bizarre.\n*/\n\n#elif PART == 6\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\n\nstruct Surface {\n    float sd; // signed distance value\n    vec3 col; // color\n};\n\n\n\n\nSurface sdFloor(vec3 p, vec3 col) {\n  float d = p.y + 1.;\n  return Surface(d, col);\n}\n\nSurface sdSphere(vec3 p, float r, vec3 offset, vec3 col) {\n  p = (p - offset);\n  float d = length(p) - r;\n  return Surface(d, col);\n}\n\nSurface opUnion(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\nSurface scene(vec3 p) {\n  vec3 floorColor = vec3(0.1 + 0.7 * mod(floor(p.x) + floor(p.z), 2.0));\n  Surface co = sdFloor(p, floorColor);\n  co = opUnion(co, sdSphere(p, 1., vec3(0, 0, -2), vec3(1, 0, 0)));\n  return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = scene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy).sd +\n      e.yyx * scene(p + e.yyx).sd +\n      e.yxy * scene(p + e.yxy).sd +\n      e.xxx * scene(p + e.xxx).sd);\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float tmax) {\n  float res = 1.0;\n  float t = mint;\n\n  for(int i = 0; i < 16; i++) {\n    float h = scene(ro + rd * t).sd;\n      res = min(res, 8.0*h/t);\n      t += clamp(h, 0.02, 0.10);\n      if(h < 0.001 || t > tmax) break;\n  }\n\n  return clamp( res, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.835, 1, 1);\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  vec3 rd = normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd); // closest object\n\n  if (co.sd > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.sd; // point discovered from ray marching\n    vec3 normal = calcNormal(p);\n\n    vec3 lightPosition = vec3(cos(iTime), 2, sin(iTime));\n    vec3 lightDirection = normalize(lightPosition - p);\n    \n    float dif = clamp(dot(normal, lightDirection), 0., 1.) + 0.5; // diffuse reflection\n\n    //float dif = clamp(dot(normal, lightDirection), 0., 1.); // diffuse reflection\n    \n    vec3 newRayOrigin = p + normal * PRECISION * 2.;\n    float shadowRayLength = rayMarch(newRayOrigin, lightDirection).sd; // cast shadow ray to the light source\n    if (shadowRayLength < length(lightPosition - newRayOrigin)) dif *= 0.2; // shadow\n    \n    float softShadow = clamp(softShadow(p, lightDirection, 0.02, 2.5), 0.1, 1.0);\n    col = dif * co.col * softShadow;\n\n    \n  }\n\n  col = pow(col, vec3(1.0/2.2)); // Gamma correction\n  fragColor = vec4(col, 1.0); // Output to screen\n}\n\n/*\nIl est fréquent de voir des personnes masquer les irrégularités de l'arrière-plan en appliquant du brouillard.\nAppliquons le brouillard juste avant la correction gamma.\ncol = mix(col, backgroundColor, 1.0 - exp(-0.0002 * co.sd * co.sd * co.sd)); // fog\n\nMaintenant, la scène a l'air un peu plus réaliste !\nhttps://inspirnathan.com/_nuxt/img/img-10.d9516ba.png\n\nVous trouverez le code terminé ci-dessous :\n*/\n\n/* The MIT License\n** Copyright © 2022 Nathan Vaughn\n** Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n** \n** Example on how to create a shadow, apply gamma correction, and apply fog.\n** Visit my tutorial to learn more: https://inspirnathan.com/posts/63-shadertoy-tutorial-part-16/\n** \n** Resources/Credit:\n** Primitive SDFs: https://iquilezles.org/articles/distfunctions\n** Soft Shadows: https://iquilezles.org/articles/rmshadows/\n*/\n\n#elif PART == 7\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\n\nstruct Surface {\n    float sd; // signed distance value\n    vec3 col; // color\n};\n\nSurface sdFloor(vec3 p, vec3 col) {\n  float d = p.y + 1.;\n  return Surface(d, col);\n}\n\nSurface sdSphere(vec3 p, float r, vec3 offset, vec3 col) {\n  p = (p - offset);\n  float d = length(p) - r;\n  return Surface(d, col);\n}\n\nSurface opUnion(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\nSurface scene(vec3 p) {\n  vec3 floorColor = vec3(0.1 + 0.7*mod(floor(p.x) + floor(p.z), 2.0));\n  Surface co = sdFloor(p, floorColor);\n  co = opUnion(co, sdSphere(p, 1., vec3(0, 0, -2), vec3(1, 0, 0)));\n  return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = scene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  co.sd = depth;\n  \n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy).sd +\n      e.yyx * scene(p + e.yyx).sd +\n      e.yxy * scene(p + e.yxy).sd +\n      e.xxx * scene(p + e.xxx).sd);\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float tmax) {\n  float res = 1.0;\n  float t = mint;\n\n  for(int i = 0; i < 16; i++) {\n    float h = scene(ro + rd * t).sd;\n      res = min(res, 8.0*h/t);\n      t += clamp(h, 0.02, 0.10);\n      if(h < 0.001 || t > tmax) break;\n  }\n\n  return clamp( res, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.835, 1, 1);\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  vec3 rd = normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd); // closest object\n\n  if (co.sd > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.sd; // point discovered from ray marching\n    vec3 normal = calcNormal(p);\n\n    vec3 lightPosition = vec3(cos(iTime), 2, sin(iTime));\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) + 0.5; // diffuse reflection\n\n    float softShadow = clamp(softShadow(p, lightDirection, 0.02, 2.5), 0.1, 1.0);\n\n    col = dif * co.col * softShadow;\n  }\n\n  col = mix(col, backgroundColor, 1.0 - exp(-0.0002 * co.sd * co.sd * co.sd)); // fog\n  col = pow(col, vec3(1.0/2.2)); // Gamma correction\n  fragColor = vec4(col, 1.0); // Output to screen\n}\n\n/*\n# Conclusion\n\nDans ce tutoriel, vous avez appris à appliquer des \"ombres dures\", des \"ombres douces\",\nla correction gamma et le brouillard. \n\nComme nous l'avons vu, l'ajout d'ombres peut s'avérer délicat. \nDans ce tutoriel, j'ai expliqué comment ajouter des ombres à une scène ne comportant que des reflets diffus,\nmais les mêmes principes s'appliquent aux scènes comportant d'autres types de reflets.\n\nVous devez vous assurer de comprendre comment votre scène est éclairée et anticiper l'impact des ombres \nsur les couleurs de votre scène. \n\nCe que j'ai mentionné dans cet article n'est qu'une façon d'ajouter des ombres à votre scène.\nEn plongeant dans le code de divers shaders sur Shadertoy, vous découvrirez des façons complètement \ndifférentes de mettre en place l'éclairage dans la scène.\n\n*/\n\n\n#endif","name":"Image","description":"","type":"image"}]}