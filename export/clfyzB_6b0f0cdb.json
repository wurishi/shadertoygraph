{"ver":"0.1","info":{"id":"clfyzB","date":"1690895399","viewed":62,"name":"cloud_ayaha401","username":"ayaha401","description":"Study Cloud raymarching ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","cloud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/WslGWl\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nconst float PI=3.1415926536;\nconst float TAU=PI*2.;\nconst float eps=0.01;\nconst float DEG2RAD = PI/180.;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64);\n\nfloat hash(float n)\n{\n    return fract(sin(n) * 43758.5453);\n}\n\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n = p.x + p.y * 57.0 + 113.0 * p.z;\n\n    float res = mix(mix(mix(hash(n +   0.0), hash(n +   1.0), f.x),\n                        mix(hash(n +  57.0), hash(n +  58.0), f.x), f.y),\n                    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n                        mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);\n    return res;\n}\n\nfloat fbm(vec3 p)\n{\n    float f;\n    f  = 0.5000 * noise(p); p = m * p * 2.02;\n    f += 0.2500 * noise(p); p = m * p * 2.03;\n    f += 0.1250 * noise(p);\n    return f;\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat chain(vec3 p, vec3 s)\n{\n    p.x-=clamp(p.x, -s.x, s.x);\n    return length(vec2(length(p.xy)-s.y,p.z))-s.z;\n}\n\nfloat map(vec3 p)\n{\n    p.xy *= rot(iTime);\n    p.xz *= rot(iTime);\n    \n    float d0 = -sphere(p, 10.5) * 0.05 + fbm(p * 0.3);\n    float d1 = -chain(p, vec3(15.5, 13.2, .1)) * 0.05 + fbm(p * 0.3);\n    float d = mix(d1, d0, max(0., sin(iTime)));\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n    float dist, hit, i = 0.;\n    vec3 cPos = vec3(0., 0., 35.);\n    vec3 cDir = normalize(vec3(0., 0., -1.));\n    vec3 cUp = vec3(0., 1., 0.);\n    vec3 cSide = cross(cDir, cUp);\n    vec3 ray = normalize(cSide * uv.x + cUp * uv.y + cDir); \n    vec3 L = normalize(vec3(1));\n    vec3 col=vec3(0);\n    float sampleCount = 64.0;\n    float zMax = 65.0;\n    float zStep = zMax / sampleCount;\n    // Substantially transparency parameter.\n    float absorption = 100.0;\n    // Transmittance\n    float T = 1.0;\n    \n    for(;i<64.;i++)\n    {\n        vec3 rp = cPos + ray * hit;\n        dist=map(rp);\n        hit+=zStep;\n        if(dist > eps)\n        {\n            float tmp = dist / sampleCount;\n            T *= 1.0 - (tmp * absorption);\n            if (T <= 0.01)\n            {\n                break;\n            }\n            float opaity = 50.0;\n            float k = opaity * tmp * T;\n            vec3 cloudColor = vec3(1.0);\n            col += cloudColor * k;\n        }\n    }\n    vec3 bg = mix(vec3(0.3, 0.1, 0.8), vec3(0.7, 0.7, 1.0), 1.0 - (uv.y + 1.0) * 0.5);\n    col += bg;\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}