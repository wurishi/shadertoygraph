{"ver":"0.1","info":{"id":"sl2yWK","date":"1650282556","viewed":777,"name":"Is This Your Card?","username":"yx","description":"2nd place in the 4K Executable Graphics compo at Revision 2022.\n\nDownload: [url]https://demozoo.org/graphics/307508/[/url]\n\nThis code has been tidied up slightly, the party exe was messy.\n\nAll comments on how to minify the shader further will be deleted.","likes":37,"published":1,"flags":32,"usePreview":0,"tags":["sdf","pathtracing","revision","cards","sizecoding","demoparty","queen"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n\t// readback the buffer\n\tvec4 tex = texelFetch(iChannel0,ivec2(fragCoord.xy),0);\n\n\t// divide accumulated color by the sample count\n\tvec3 color = tex.rgb / tex.a;\n\t\n\t// vignette to darken the corners\n\tvec2 uv = gl_FragCoord.xy/iResolution.xy;\n\tuv-=.5;\n\tcolor *= 1.-dot(uv,uv)*.6;\n\n    // exposure and tonemap\n    color *= 3.;\n    color = 1.-exp(color*-2.);\n\n    // warm grade\n    color = pow(color,vec3(1,1.07,1.15));\n\n    // pop\n    color = mix(color, smoothstep(0., 1., color), 0.4);\n\n\t// gamma correction\n\tcolor = pow(color, vec3(.45));\n\t\n    // final color\n    fragColor = vec4(vec3(color),1);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float pi = acos(-1.);\n\nconst vec3 kCardSize = vec3(64,0.294,89.);\nconst vec3 kHalfCardSize = kCardSize*.5;\nconst float kCardCornerRadius = 3.;\n\nconst float kFloorRotation = -.3;\n\nmat2 rotate(float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return mat2(c,-s,s,c);\n}\n\n// hash functions adapted from Devour\n// https://www.shadertoy.com/view/3llSzM\nfloat seed;\nfloat hash() {\n\tfloat p=fract((seed++)*.1031);\n\tp+=(p*(p+19.19))*3.;\n\treturn fract((p+p)*p);\n}\nvec2 hash2(){return vec2(hash(),hash());}\n\nfloat sdBox(vec2 p, vec2 b)\n{\n    vec2 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat sdBox(vec2 p, vec2 b, float r)\n{\n    return sdBox(p,b-r)-r;\n}\n\nfloat sdCard(vec3 p, vec3 b, float r)\n{\n    p.xz = max(vec2(0),abs(p.xz)-b.xz+r);\n    vec2 d = vec2(max(0.,length(p.xz)-r),p.y);\n    return length(d)-b.y;\n}\n\nfloat sd2D_rect(vec2 p, vec2 b)\n{\n    p = abs(p)-b;\n    return max(p.x,p.y);\n}\n\nfloat sd2D_roundRect(vec2 p, vec2 b, float r)\n{\n    p = max(vec2(0),abs(p)-b+r);\n    return length(p)-r;\n}\n\nfloat sdLinenCard(vec3 p, vec3 b, float r)\n{\n    //p.y -= max(sin(p.x*20.),sin(p.z*20.))*.01;\n    \n    // plasticky faux-linen\n    /*p.y -= sin(p.x*15.)*.005;\n    p.y -= sin(p.z*15.)*.005;*/\n    \n    // noise-based linen\n    if (abs(p.y) < kHalfCardSize.y+.1) {\n        p.y -= texture(iChannel1,p.xz*vec2(.025,.001)).r*.01;\n        p.y -= texture(iChannel1,p.xz*vec2(.001,.025)).r*.01;\n    }\n    \n    return sdCard(p,b,r);\n}\n\nfloat sd2D_Q(vec2 p)\n{\n    float tilde = sdBox(p+vec2(0,.6+1.2*smoothstep(-1.2,1.2,p.x)),vec2(1.4,.2),.1);\n    p.y=max(0.,abs(p.y)-1.);\n    float loop = abs(length(p)-.8)-.2;\n    return min(loop,tilde);\n}\n\nfloat sd2D_Heart(vec2 p)\n{\n    p.x = abs(p.x)-1.;\n    p.y -= 1.;\n    float a = length(p)-1.;\n    float b = p.x+smoothstep(-1.,1.,-.5*p.y-1.)*2.2-1.;\n    b = max(abs(p.y+2.)-2.,b);\n    return min(a,b);\n}\n\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdArc( in vec2 p, in vec2 scb, in float ra, in float rb )\n{\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nvec4 sd2D_Queen(vec2 p)\n{\n    vec2 op=p;\n\n    // face shape\n    p=op;\n    p -= vec2(1.75,30.);\n    float a = max(length(p*vec2(2,0.5))-10.,-p.y);\n    float b = max(length(p*vec2(2,1.))-10.,p.x);\n    p.x+=.5;\n    float c = max(length(p*vec2(1.2,1.))-10.,-.5-p.x);\n    float faceMask = min(a,min(b,c));\n    float faceOutline = abs(faceMask)-.25;\n\n    // topleft hair\n    p=op;\n    p -= vec2(-7,39.5);\n    float leftHairMask = length(p)-7.5;\n    float leftHair = max(abs(mod(leftHairMask,.6)-.3)-.15, max(leftHairMask, faceMask));\n\n    // topright hair\n    p=op;\n    p -= vec2(7,40);\n    float rightHairMask = length(p)-8.;\n    float rightHair = max(abs(mod(rightHairMask,.6)-.3)-.15, max(rightHairMask, faceMask));\n\n    // lower right hair\n    p=op;\n    p -= vec2(11,28);\n    float lowRightHairMask = length(p)-5.;\n    float lowRightHair = max(abs(mod(lowRightHairMask,.6)-.3)-.15, lowRightHairMask);\n\n    // left side black\n    p=op;\n    p -= vec2(12,17);\n    float leftSideBlack = abs(length(p)-20.)-1.4;\n    leftSideBlack = max(max(leftSideBlack,-faceMask),op.x);\n\n    // left shoulder\n    p=op;\n    p -= vec2(6,2.5);\n    float leftShoulderMask = length(p)-22.;\n    float leftShoulder = max(abs(leftShoulderMask)-.15,max(-faceMask,op.x));\n\n    // lower left hair\n    p=op;\n    p -= vec2(12,17);\n    float lowerLeftHairMask = length(p)-18.6;\n    float lowerLeftHair = abs(mod(lowerLeftHairMask-.4,.6)-.3)-.15;\n    lowerLeftHair = max(lowerLeftHair, max(max(lowerLeftHairMask,-faceMask),max(-leftShoulderMask,op.x)));\n    \n    // right side diagonal black\n    p=op;\n    float rightSideDiagBlack1 = dot(vec3(p,1),vec3(normalize(vec2(-2,-1)),20));\n    float rightSideDiagBlack2 = dot(vec3(p,1),vec3(normalize(vec2(2,1.1)),-23));\n    float rightSideDiagBlack = max(rightSideDiagBlack1, rightSideDiagBlack2);\n\n    // hat\n    p=op;\n    float hatCircle1 = length(p-vec2(37,32))-20.5;\n    float hatCircle2 = length(p-vec2(18,14))-10.;\n    float hatMask = max(-rightSideDiagBlack2,max(-hatCircle1,-hatCircle2));\n    float hatOutline = abs(hatMask)-.15;\n\n    // hat trim\n    p=op;\n    p.xy *= rotate(atan(2.,1.1));\n    p.x = mod(p.x,3.)-1.5;\n    p.y -= 25.5;\n    float hatTrim1 = length(p*vec2(.5,2))-.5;\n    float hatTrim2 = length(abs(p*vec2(2,2))-vec2(0,1.5))-.5;\n    p.x = mod(p.x,3.)-1.5;\n    float hatTrim3 = length(p*vec2(2,.5))-.5;\n    float hatTrim4 =length(p*vec2(.5,2)-vec2(0,-1.5))-.5;\n    float hatTrim = min(min(hatTrim1,hatTrim2), min(hatTrim3,hatTrim4));\n    hatTrim = max(hatTrim, hatMask);\n\n    // left eye\n    p=op;\n    p -= vec2(-1.5,29.8);\n    float leftPupil = length(p)-.4;\n    float leftIris = abs(leftPupil-.45)-.12;\n    p.y+=.1;\n    p.x-=.1;\n    float leftOuterEyeMask = length(p*vec2(.5,1))-.75;\n    float leftOuterEye = abs(leftOuterEyeMask)-.1;\n    leftIris = max(leftIris, leftOuterEyeMask);\n    float leftEye = min(min(leftPupil,leftIris),leftOuterEye);\n    \n    // right eye\n    p=op;\n    p -= vec2(3.5,29.8);\n    float rightPupil = length(p)-.4;\n    float rightIris = abs(rightPupil-.45)-.12;\n    p.y+=.1;\n    p.x-=.1;\n    float rightOuterEyeMask = length(p*vec2(.5,1))-.75;\n    float rightOuterEye = abs(rightOuterEyeMask)-.1;\n    rightIris = max(rightIris, rightOuterEyeMask);\n    float rightEye = min(min(rightPupil,rightIris),rightOuterEye);\n\n    faceOutline = max(faceOutline, -hatMask);\n    faceOutline = max(faceOutline, -lowRightHairMask-.25);\n    rightHair = max(rightHair, -hatMask);\n    lowRightHair = max(lowRightHair, -rightSideDiagBlack1);\n\n    // left eyehood\n    p=op;\n    p -= vec2(-1.8,29.9);\n    p.y -= cos(p.x-.4)*.4;\n    float leftEyehood = length(p*vec2(1,5))-1.9;\n\n    // right eyehood\n    p=op;\n    p -= vec2(4.0,29.9);\n    p.y -= cos(p.x+.4)*.4;\n    float rightEyehood = length(p*vec2(1,5))-1.9;\n\n    // left eyebrow\n    p=op;\n    p -= vec2(-1.9,31.7);\n    p.y += pow(p.x,2.)*.15;\n    p.y /= 1.5-smoothstep(-3.,3.,-p.x);\n    float leftEyebrow = length(p*vec2(1,8))-2.4;\n\n    // right eyebrow\n    p=op;\n    p -= vec2(4.0,31.7);\n    p.y += pow(p.x+.3,2.)*.15;\n    p.y /= 1.5-smoothstep(-3.,3.,p.x);\n    float rightEyebrow = length(p*vec2(1,8))-2.4;\n\n    // nose\n    p=op;\n    p -= vec2(0.4,28.5);\n    p.x += pow(p.y-1.2,2.)*.05;\n    float nose = length(p*vec2(11,1))-2.7;\n    \n    // nostril\n    p=op;\n    p -= vec2(1.3,25.8);\n    float nostril = sdArc(p*rotate(-.25),vec2(.8,.6),.5,.15);\n\n    // chin\n    // definitely uses sdArc wrong,\n    // but iq's site was down in the hours before the deadline,\n    // so I just winged it and hoped for the best. it looks good enough!\n    p=op;\n    p -= vec2(1.25,20.5);\n    float chin1 = sdArc(p,vec2(.45,.6),1.8,.15);\n    float chin2 = sdArc(vec2(0,4.1)-p,vec2(.3,.6),1.7,.1);\n    float chin=min(chin1,chin2);\n    \n    // mouth\n    p=op;\n    p -= vec2(1.25,24);\n    p.y += cos(p.x*5.)*.08;\n    p.y /= 1.-abs(p.x)*.4;\n    float mouth = abs(p.y)-.35;\n    mouth = max(mouth,abs(p.x)-1.65);\n    \n    // right side diagonal red\n    p=op;\n    float rightSideDiagRed1 = dot(vec3(p,1),vec3(normalize(vec2(-2,-1.1)),23));\n    float rightSideDiagRed2 = dot(vec3(p,1),vec3(normalize(vec2(2,1.1)),-24));\n    float rightSideDiagRed = max(hatMask, max(rightSideDiagRed1, rightSideDiagRed2));\n    float rightSideDiagRedOutline = abs(rightSideDiagRed)-.15;\n\n    float red = rightSideDiagRed;\n    float yel = hatMask;\n    float blu = min(min(faceOutline,min(leftHair,min(rightHair,lowRightHair))),min(leftEye,rightEye));\n    blu = min(blu,chin);\n    blu = min(blu,mouth);\n    blu = min(blu,nose);\n    blu = min(blu,nostril);\n    blu = min(blu,min(leftEyehood,rightEyehood));\n    blu = min(blu,min(leftEyebrow,rightEyebrow));\n    blu = min(blu,lowerLeftHair);\n    blu = min(blu,leftShoulder);\n    float blk = min(min(leftSideBlack, rightSideDiagBlack), min(hatOutline,rightSideDiagRedOutline));\n    blk = min(blk,hatTrim);\n    return vec4(red,yel,blu,blk);\n}\n\nconst int kMatGround        = 0;\nconst int kMatQueen         = 1;\nconst int kMatCardBack      = 2;\n\nint mat=0;\nvec3 pLocalHit=vec3(0);\nfloat scene(vec3 p)\n{\n    vec3 op=p;\n    vec3 oop=p;\n\n    float ground = p.y;\n    \n    /* fuzzy ground */\n    p.xz *= rotate(kFloorRotation);\n    p.xz=abs(mod(p.xz,.5)-.25);\n    ground = min(length(p.xy),length(p.zy))-.25;\n    if (abs(ground) < .03) {\n        ground += texture(iChannel1,p.xz).r*.01;\n    }\n    \n    op.xy *= rotate(-.04);\n    op.y -= 1.2;\n    \n    vec3 pQueen=op;\n    pQueen.z += 25.;\n    pQueen.y-=kCardSize.y;\n    float dQueen = sdLinenCard(pQueen,kHalfCardSize,kCardCornerRadius);\n    \n    float dStack = p.y+15.;\n    vec3 pBestStack = vec3(0);\n    if (p.y < 15.) {\n        vec3 pStack=op;\n        pStack.y -= kCardSize.y;\n        float pivotDist = 150.;\n        float pivotAngle = .04;\n        \n        int start = -6;\n        pStack.z -= pivotDist;\n        pStack.xz *= rotate(pivotAngle*float(start));\n        pStack.z += pivotDist;\n        pStack.y -= kCardSize.y*float(start);\n\n        \n        for (int i = start+1; i < 14; ++i) { \n            pStack.z -= pivotDist;\n            pStack.xz *= rotate(pivotAngle);\n            pStack.z += pivotDist;\n            pStack.y -= kCardSize.y;\n\n            if (i != 0) {\n                float dStackItem = sdLinenCard(pStack,kHalfCardSize,kCardCornerRadius);\n                if (dStackItem < dStack) {\n                    dStack = dStackItem;\n                    pBestStack = pStack;\n                }\n            }\n        }\n    }\n    \n    float best = ground;\n    best=min(best,dQueen);\n    best=min(best,dStack);\n    \n    if(best==ground)\n    {\n        mat = kMatGround;\n\t\tpLocalHit = oop;\n    }\n    else if (best==dQueen)\n    {\n        mat = kMatQueen;\n        pLocalHit = pQueen;\n    }\n    else if (best==dStack)\n    {\n        mat = kMatCardBack;\n        pLocalHit = pBestStack;\n    }\n    \n    return best;\n}\n\nvec3 ortho(vec3 a){\n    vec3 b=cross(vec3(-1,-1,-1),a);\n    // assume b is nonzero\n    return (b);\n}\n\n// various bits of lighting code \"borrowed\" from \n// http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec3 getSampleBiased(vec3  dir, float power) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = hash2();\n\tr.x=r.x*2.*pi;\n\tr.y=pow(r.y,1.0/(power+1.0));\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nvec3 getConeSample(vec3 dir, float extent) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r =  hash2();\n\tr.x=r.x*2.*pi;\n\tr.y=1.0-r.y*extent;\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nvec3 sky(vec3 sunDir, vec3 viewDir) {\n    float softlight = max(0.,dot(sunDir*vec3(-1,1,-1),viewDir)+.2);\n    float keylight = pow(max(0.,dot(sunDir,viewDir)-.5),3.);\n    \n    return vec3(\n\t\tsoftlight*.03 + keylight * 10.\n\t)*1.5;\n}    \n\nbool trace5(vec3 cam, vec3 dir, float nearClip, out vec3 h, out vec3 n, out float k) {\n\tfloat t=nearClip;\n    for(int i=0;i<40;++i)\n    {\n        k = scene(cam+dir*t);\n        if (abs(k) < .001)\n            break;\n        t += k;\n    }\n\n    h = cam+dir*t;\n\t\n    // if we hit something\n    if(abs(k)<.001)\n    {\n        vec2 o = vec2(.001, 0);\n        n = normalize(vec3(\n            scene(h+o.xyy) - k,\n            scene(h+o.yxy) - k,\n            scene(h+o.yyx) - k \n        ));\n        return true;\n    }\n    return false;\n}\n\nfloat floorPattern(vec2 uv)\n{\n    float kUnit = 10.;\n    float kSubUnit = 2.;\n\n    uv=abs(mod(uv,kUnit)-kUnit*.5);\n    float lines = -max(uv.x,uv.y)+kUnit*.5-kSubUnit*.05; \n    \n    uv=abs(mod(uv-kUnit*.1,kUnit*.1)-kUnit*.1);\n    float lines2 = -max(uv.x,uv.y)+kUnit*.1-kSubUnit*.02;\n    \n    return min(lines,lines2);\n}\n\nvec3 trace2(vec3 cam, vec3 dir, float nearClip)\n{\n    const vec3 sunDirection = normalize(vec3(0,.5,1.));\n\n    vec3 accum = vec3(1);\n    for(int ibounce=0;ibounce<10;++ibounce)\n    {\n        vec3 h,n;\n        float k;\n        if (trace5(cam,dir,ibounce==0?nearClip:0.,h,n,k))\n        {\n\t\t\tcam = h+n*.01;\n            if (mat == kMatGround)\n            {\n\t\t\t\tdir=getSampleBiased(n,1.);\n\t\t\t\t\n                h.xz *= rotate(kFloorRotation);\n                uint sprite = 0x5511f077u;\n\n                uint x = uint(h.z*-2.+500.)%6u;\n                uint y = uint(h.x*2.+500.)%6u;\n                uint shift = (x*6u+y);\n                uint bit = (shift<32u)?(sprite>>shift)&1u:0u;\n\n                float floorMarkers = bit>0u?1.:-1.;\n\n\t\t\t\tconst vec3 green = vec3(0,80,13)*.2/255.;\n\n                accum *= mix(green*.5,green,step(0.,floorMarkers));\n                accum *= texture(iChannel1,h.zx*.0625).r*.4+.6;\n            }\n            else if (mat == kMatQueen || mat == kMatCardBack)\n            {\n                float fresnel = pow(1.-min(.99,dot(-dir,n)),5.);\n                fresnel = mix(.04,1.,fresnel);\n                if (hash() < fresnel)\n                {\n                \tdir=reflect(dir,n);\n                } \n                else\n                {\n                \tdir=getSampleBiased(n,1.);\n                    accum *= 240./255.; // off-white\n                    \n                    vec3 hl = pLocalHit;\n                    const vec3 red = pow(vec3(.8,.1,.2),vec3(2.2));\n                    const vec3 yellow = pow(vec3(.9,.85,.1),vec3(2.2));\n                    const vec3 blue = pow(vec3(.1,.15,.3)*2.,vec3(2.2));\n                    const vec3 black = vec3(0);\n                    if (mat == kMatQueen)\n\t\t\t\t\t{\n                        if (hl.x>hl.z)\n                            hl=-hl;\n                        hl *= .5;\n                        hl.xz -= vec2(-13.5,18.5);\n                        float sd_q = sd2D_Q(hl.xz);\n                        float sd_heart = sd2D_Heart((hl.xz+vec2(0,4))*1.8);\n                        float sd_bigheart = sd2D_Heart((hl.xz+vec2(-6,4.5))*vec2(.8,.7));\n                        float sd_mask = sd2D_rect(pLocalHit.xz,kHalfCardSize.xz-vec2(9,8));\n                        float sd_border = abs(sd_mask)-.15;\n                        float sd_red = min(min(sd_q, sd_heart), sd_bigheart);\n                        accum *= mix(red,vec3(1,1,1),smoothstep(-.04,.04,sd_red));\n                        accum *= mix(blue,vec3(1,1,1),smoothstep(-.04,.04,sd_border));\n                        \n                        hl = pLocalHit;\n                        if (hl.x>hl.z)\n                            hl=-hl;\n                        vec4 sd_queen = max(sd2D_Queen(hl.xz),sd_mask);\n                        accum *= mix(red,   vec3(1),smoothstep(-.04,.04,sd_queen.r));\n                        accum *= mix(yellow,vec3(1),smoothstep(-.04,.04,sd_queen.g));\n                        accum *= mix(blue,  vec3(1),smoothstep(-.04,.04,sd_queen.b));\n                        accum *= mix(black, vec3(1),smoothstep(-.04,.04,sd_queen.a));\n                    }\n                    if (mat == kMatCardBack)\n\t\t\t\t\t{\n                        uint sprite = 0x5511f077u;\n\n                        float dCardBackMask = sd2D_roundRect(hl.xz,kHalfCardSize.xz-2.5,2.);\n                        \n                        hl.xz *= rotate(pi*-.25);\n                        uint x = uint(hl.z*-4.+500.)%6u;\n                        uint y = uint(hl.x*4.+500.)%6u;\n                        uint shift = (x*6u+y);\n                        uint bit = (shift<32u)?(sprite>>shift)&1u:0u;\n                        float floorMarkers = bit>0u?1.:-1.;\n                    \n                        float sd=max(dCardBackMask,floorMarkers*.1);\n                        sd = min(sd, abs(dCardBackMask)-.1);\n                        sd = min(sd, abs(dCardBackMask-.5)-.2);\n                        accum *= mix(red,vec3(1,1,1),smoothstep(-.05,.05,sd));\n                    }\n                }\n            }\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn vec3(1,0,1);\n\t\t\t}\n        }\n        else {\n            break;\n        }\n    }\n    \n    return sky(sunDirection, dir) * accum;\n}\n\nvec2 bokeh(){\n    // hexagon\n    vec2 a = hash2();\n    a.x=a.x*3.-1.;\n    a-=step(1.,a.x+a.y);\n\ta.x += a.y * .5;\n\ta.y *= sqrt(.75);\n    return a;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n\n    if (iMouse.z > 0.) {\n        fragColor = vec4(0.);\n    }\n\n\t// seed the RNG (again taken from Devour)\n\tseed = float(((iFrame*73856093)^int(fragCoord.x)*19349663^int(fragCoord.y)*83492791)%38069);\n\t//seed = float((iFrame*73856093)%38069);\n\t\n\t// set up UVs, jittered for antialiasing\n\tvec2 uv = (gl_FragCoord.xy+hash2()-.5)/iResolution.xy-.5;\n\t\n\t// aspect ratio\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n    uv = uv*.6-vec2(.13*16./9.,-.3); // good crop\n\n\tconst float cameraFisheye = .2;\n    uv = normalize(uv) * tan(asin(length(uv) * cameraFisheye)) / cameraFisheye;\n\n    // camera params\n    const float yOffset = 1.2;\n    const vec3 camPos = vec3(100,200.+yOffset,150);\n    const vec3 lookAt = vec3(0,0.+yOffset,0);\n    const float focusDistance=distance(camPos,lookAt)*1.1;\n    const vec2 apertureRadius=vec2(4.5);\n    \n    // make a camera\n    vec3 cam = vec3(0);\n    vec3 dir = normalize(vec3(uv,3.));\n    \n    // slight bokeh\n    vec2 bokehJitter=bokeh();\n    cam.xy+=bokehJitter*apertureRadius;\n    dir.xy-=bokehJitter*apertureRadius*dir.z/focusDistance;\n\n    // rotate/move the camera\n    vec3 lookDir = lookAt-camPos;\n    float pitch = -atan(lookDir.y,length(lookDir.xz));\n    float yaw = -atan(lookDir.x,lookDir.z);\n    cam.yz *= rotate(pitch);\n    dir.yz *= rotate(pitch);\n    cam.xz *= rotate(yaw);\n    dir.xz *= rotate(yaw);\n    cam += camPos;\n    \n    // compute the pixel color\n\tvec3 pixel = trace2(cam,dir,length(camPos)*.7);\n\n    fragColor += vec4(pixel,1);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}