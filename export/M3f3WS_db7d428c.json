{"ver":"0.1","info":{"id":"M3f3WS","date":"1707864927","viewed":56,"name":"Le Planet","username":"Shin0155","description":"Le Planet","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["leplanet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shadertoy uniforms\nuniform vec3 iGlobalResolution;\nuniform float iGlobalTime;\nuniform sampler2D iGlobalChannel0; // Ground texture\nuniform sampler2D iGlobalChannel1; // Cloud texture\nuniform sampler2D iGlobalChannel2; // Night texture\n\n#define Pi 3.14159265359\n#define d2r(a) ((a)*180.0/Pi)\n#define RGB(r,g,b) pow(vec3(float(r), float(g), float(b))/255.0, vec3(2.22))\n\n#define R0 10.9200  // Scaled Earth radius (6360 km)\n#define R1 10.9294  // Scaled Atmosphere radius (6420 km)\n\nvec3 Render(in vec2 uv)\n{\n    vec3 Color = vec3(0.0);\n    float t = iTime;\n\n    // Rotate the UV coordinates to simulate rotation\n    float rotationSpeed = 0.01; // Adjust the speed of rotation\n    float rotationAngle = t * rotationSpeed;\n    mat2 rotationMatrix = mat2(cos(rotationAngle), -sin(rotationAngle),\n                               sin(rotationAngle), cos(rotationAngle));\n    uv = rotationMatrix * uv;\n\n    // Sun:\n    vec3 L0 = vec3(cos(0.1*t), 0.0, sin(0.1*t));\n    float cs = cos(d2r(90.0 + 23.4)), sn = sin(d2r(90.0 + 23.4));\n    vec3 LightDir = vec3(cs*L0.x + sn*L0.y, cs*L0.y - sn*L0.x, L0.z);\n\n    vec2 SunC = -5.0*LightDir.xy/LightDir.z - uv;\n    float Halo = max(0.0, dot(LightDir, normalize(vec3(uv.x, uv.y, -5.0))));\n    float SunRay = pow(texture(iChannel1, vec2(0.1*t, atan(SunC.x,SunC.y))).x, 2.22);\n    float Sun = 0.05*(1.0 + SunRay)*pow(Halo, 1000.0)*smoothstep(0.85, 1.3, length(SunC+uv));\n\n    // Sphere hit:\n    float z = 1.0 - dot(uv, uv);\n    if(z < 0.0)\n    {\n        Sun += 1.5*pow(Halo, 10000.0);\n        return Sun*RGB(255,250,230);\n    }\n\n    // Intersection:\n    vec3 Normal = vec3(uv.x, uv.y, sqrt(z));\n    vec3 Reflection = reflect(vec3(0.0, 0.0, 1.0), Normal);\n\n    // Textures:\n    float U = 1.0-atan(Normal.z, Normal.x) / (2.0*Pi);\n    float V = 1.0-(atan(length(Normal.xz), Normal.y)) / Pi;\n    vec3 Ground = pow(texture(iChannel0, vec2(U-t/80.0, V)).rgb, vec3(2.22));\n    vec3 Cloud  = pow(texture(iChannel1, vec2(U-t/75.0, V)).rgb, vec3(2.22));\n    vec3 Night  = pow(texture(iChannel2, vec2(U-t/80.0, V)).rgb, vec3(2.22));\n\n    // Shading\n    float Diffuse = max(0.0, dot(Normal, LightDir));\n    float Specular = max(0.0, dot(-Reflection, LightDir));\n    float Scatter = 4.0*pow((sqrt(R1 - dot(uv, uv)) - Normal.z) / sqrt(R1-R0), 1.35);\n    float Extinct = pow(1.0 - Diffuse, 4.0);\n    float Sea = smoothstep(1.0, 0.0, 100.0*length(Ground - RGB(2,5,20)));\n    float Shadow = 1.0 - pow(Cloud.r, 0.5); // Assuming Cloud is a single-channel texture\n\n    // Combine textures and shading\n    vec3 color = mix(Ground, Night, Sea);\n    color = mix(color, Cloud, Shadow);\n    color += Sun;\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 color = Render(uv);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}