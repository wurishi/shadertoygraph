{"ver":"0.1","info":{"id":"wtd3DM","date":"1576592663","viewed":193,"name":"3d truchet tiling","username":"Anskiere","description":"-","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","tiling","trouchet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float maxDist = 200.;\nconst float planeDist = 2.;\nconst float PHI = 1.61;\nconst float pi = 3.1415926;\n\nfloat rand11(float x, float seed)\n{\n    x += 10.;\n    return fract(tan(distance(x*PHI, x)*seed)*x);\n}\n\nfloat rand31(vec3 p, float seed)\n{\n    p += 10.;\n    return fract(tan(distance(p*PHI, p)*seed)*p.x);\n}\n\nvec2 rand32(vec3 p, float seed)\n{\n    vec2 res;\n\n    res.x = rand31(p, seed);\n    res.y = rand11(res.x, seed);\n\n    return res;\n}\n\nvec3 rand33(vec3 p, float seed)\n{\n    vec3 res;\n\n    res.x = rand31(p, seed);\n    res.y = rand11(res.x, seed);\n    res.z = rand11(res.y, seed);\n\n    return res;\n}\n\nvec3 lightPos()\n{\n    return vec3(1,1,1);\n}\n\nvec3 cameraPos()\n{\n    vec3 res;\n\n    vec2 tuv;\n\n    if (iMouse.z > 0.) tuv = iMouse.xy/iResolution.xy;\n    else tuv = vec2(-iTime*0.0125, 0.35);\n\n    float a = tuv.y * pi;\n    float b = (1.-tuv.x) * pi * 2.;\n\n    res.x = sin(a)*cos(b);\n    res.z = sin(a)*sin(b);\n    res.y = cos(a);\n\n    res *= 12.;\n\n    return res;\n}\n\nvec3 getRay(vec2 uv)\n{\n    vec3 cam = cameraPos();\n    vec3 origin = vec3(0, 0, 0);\n    vec3 look = normalize(origin - cam);\n    vec3 upGlob = vec3(0,1,0);\n    vec3 right = normalize(cross(upGlob, look));\n    vec3 camUp = normalize(-cross(right, look));\n\n    vec3 p = cam + camUp * uv.y + right * uv.x;\n    p += look * planeDist;\n\n    vec3 res = p - cam;\n    return normalize(res);\n}\n\nfloat getCube(vec3 p, float size)\n{\n    p = abs(p);\n    return max(max(p.x, p.y), p.z) - size;\n}\n\nfloat diff(float a, float b)\n{\n    return max(a, -b);\n}\n\nfloat getCapsule(vec3 p, vec3 a, vec3 b)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat getTorus(vec3 p, float radius)\n{\n    vec3 pr = vec3(p.x, 0, p.z);\n    vec3 a = normalize(pr)*radius;\n\n    return length(a - p);\n}\n\nconst vec3 d = vec3(1,-1,0);\n\nfloat tile1(vec3 luv)\n{\n    float res = getCapsule(luv, d.zyz, d.zxz);\n\n    res = min(res, getTorus(luv - d.xzx, 1.));\n    res = min(res, getTorus(luv - d.yzy, 1.));\n\n    return res;\n}\n\n\nfloat tile2(vec3 luv)\n{\n    float res = getTorus(luv.xyz-d.xzx, 1.);\n    res = min(res, getTorus(luv.xzy-d.yzx, 1.));\n    res = min(res, getTorus(luv.yxz-d.yzy, 1.));\n\n    return res;\n}\n\nfloat getTileSd(vec3 ijk, vec3 luv)\n{\n    luv = luv*2.-1.;\n\n    {\n        vec2 r = rand32(ijk, 10.);\n        if (r.x > .5) luv = luv.yzx;\n        if (r.y > .5) luv = luv.yzx;\n    }\n\n    {\n        vec3 r = rand33(ijk, 12.);\n        if (r.x > .5) luv.x = -luv.x;\n        if (r.y > .5) luv.y = -luv.y;\n        if (r.z > .5) luv.z = -luv.z;\n    }\n\n    float tr = rand31(ijk, 1.);\n    \n    float res;\n\n    if (tr < .5) res = tile2(luv) / 2.;\n    else res = tile1(luv) / 2.;\n\n    return res;\n}\n\nfloat getSd(vec3 p)\n{\n    vec3 ijk = floor(p);\n    vec3 luv = fract(p);\n\n    float res = getTileSd(ijk, luv);\n\n    float sdCube = getCube(p, 1.95);\n\n    res = max(res, sdCube);\n\n    res -= .06;\n\n    return res;\n}\n\nvec3 calcNormal(vec3 p )\n{\n    const float h = 0.005; // or some other value const\n    vec2 k = vec2(1, -1);\n\n    return\n        normalize(\n            k.xyy*getSd( p + k.xyy*h ) +\n            k.yyx*getSd( p + k.yyx*h ) +\n            k.yxy*getSd( p + k.yxy*h ) +\n            k.xxx*getSd( p + k.xxx*h ) );\n}\n\nfloat raymarch(vec3 sp, vec3 ray)\n{\n    float depth = 0.;\n\n    for(int i = 0; i < 100; i++)\n    {\n        vec3 p = sp + ray * depth;\n        float dist = getSd(p);\n\n        if (dist <= 0.001)\n            return depth + dist;\n\n        depth += dist;\n\n        if (depth >= maxDist)\n            return maxDist;\n    }\n\n    return maxDist;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x /= iResolution.y / iResolution.x;\n    \n    vec3 ray = getRay(uv);\n    vec3 camPos = cameraPos();\n    float d = raymarch(camPos, ray);\n\n    if (d >= maxDist)\n    {\n        fragColor = vec4(texture(iChannel0, ray));\n        return;\n    }\n\n    vec3 intP = cameraPos() + d*ray;\n    vec3 n = calcNormal(intP);\n    \n    vec3 refRay = reflect(ray, n);\n    \n    vec3 refl = texture(iChannel0, refRay).rgb;\n    vec3 res = refl;\n    \n    res *= smoothstep(18., 10., d);\n    \n    res = pow(res, vec3(1.2));\n    \n    fragColor = vec4(res, 0);\n}","name":"Image","description":"","type":"image"}]}