{"ver":"0.1","info":{"id":"tdScDV","date":"1587328423","viewed":162,"name":"raymarching intersecting glass","username":"trupples","description":"I was playing around with a way to raymarch a scene with transparent bodies, and more so properly handle it when transparent objects intersect. It's currently not physically correct, as I don't have fresnel equations; will fix in following versions","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["refraction","transparent","raymarhing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nMy approach to achieving proper refraction and correct rendering of overlapping\ntransparent bodies is to keep track of what body each ray is \"inside of\", and\nignore that current body's SDF when marching. When switching from a body to\nanother, we can use the ratio of their refraction indices to properly calculate\nthe new ray direction.\n\nCurrently it doesn't properly handle all transparent surface boundaries, especially\nwhen going from glass to air. (see the bottom half of the middle octagon - it doesn't\nshow any checkerboards) I'll fix that and enhance transparent objects in the\nnext version where I'll implement fresnel's transmission formula n maybe some other\nsmart shiz like that.\n\n*/\n\n#define FOV         radians(100.0)\n#define CLIP_FAR    50.0\n#define TOUCH_DIST  0.001\n#define GAMMA       0.45\n#define MAX_DEPTH   8\n\n// The \"materials\" here actually refer to \"textures\", or rather ways to apply a\n// base color to a body. Upon this base color are applied the refractions and\n// reflections, where applicable (see the Body structure)\n#define MAT_BG           0 // skybox \"texture\" index\n#define MAT_CHECKERBOARD 1 // checkerboard floor \n#define MAT_DIR          2 // \"directional\" i.e. rgb based on the global coordinate of the intersection\n#define MAT_NORMAL       3 // rgb based on the intersection normal\n#define MAT_NOBASE       4 // no base color - with refractions you get a transparent colourless glass -like effect\n\n#define PIXEL_RAY_LIMIT 50 // how many rays can be re-cast for a given pixel for reflections and refractions (prevents infinite reflection if you have the reflection/refraction coefficient = 1.0)\n#define RAY_STEP_LIMIT 500 // helps with lag spikes when you have rays almost parallel to the ground which have to do many small steps \n\nstruct Body {\n    int base; // base texture\n    float refl_coef; // percentage of light which is reflected (i.e. 90% means 10% of the reflected data is \"absorbed\"). 0 means no reflection\n    float refr_idx, refr_coef; // same for refraction, along with the refraction index\n};\n\nBody bodies[] = Body[] (\n    Body(MAT_BG, 0.0, 1.0, 1.0),             // background\n    Body(MAT_CHECKERBOARD, 0.2, 1.0, 0.0),   // floor\n    Body(MAT_DIR, 0.0, 1.0, 0.0),            // axes\n    Body(MAT_DIR, 0.2, 1.0, 0.0),            // balls\n    Body(MAT_DIR, 0.8, 1.0, 0.0),\n    Body(MAT_DIR, 0.05, 1.0, 0.0),\n    Body(MAT_NOBASE, 0.1, 1.5, 0.5),         // refractboi\n    Body(MAT_NOBASE, 0.1, 2.4, 0.7)          // gem\n);\n\n// https://math.stackexchange.com/a/2193733\nfloat segm(const in vec3 a, const in vec3 b, const in vec3 p) {\n    float t = dot(b-a,p-a)/dot(b-a,b-a);\n    t = clamp(t, 0.0, 1.0);\n    return length(a*(1.0-t)+b*t-p);\n}\n\n// inigo quilez' collection\nfloat plane(const in vec4 n, const in vec3 p) {\n    return dot(p, n.xyz) - n.w;\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{    \n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n    vec3 r = 3.0*p - m;\n    vec3 q;\n         if( r.x < 0.0 ) q = p.xyz;\n    else if( r.y < 0.0 ) q = p.yzx;\n    else if( r.z < 0.0 ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\n// takes in the usual vec3 position, as well as the current \"space\", i.e. the\n// index of the shape we're currently casting through. Outputs the closest other\n// shape index, so that when at a boundary we can switch to the \"next space\"\nfloat map(const in vec3 p, const in int cur_space, out int closest_space) {\n    #define m(myid, dp) do { \\\n        float _dp=(dp); \\\n        if(cur_space == myid) break; \\\n        if(_dp < dist) { \\\n            dist = _dp; \\\n            closest_space = myid; \\\n        } \\\n    } while(false)\n    float dist = 1e30;\n\n    // indices should start at 1, because 0 is \"the air\"\n    m(1, plane(vec4(0.0,1.0,0.0,-5.0), p));\n    \n    m(2, min(min(\n        segm(vec3(-5.0,0.0,0.0), vec3(5.0,0.0,0.0), p)-.1,\n        segm(vec3(0.0,-5.0,0.0), vec3(0.0,5.0,0.0), p)-.1),\n        segm(vec3(0.0,0.0,-5.0), vec3(0.0,0.0,5.0), p)-.1));\n\n    m(3, length(p-vec3(0.0,sin(iTime*0.5)*10.0,5.0))-4.0);\n    m(4, length(p-vec3(10.0,0.0,0.0))-5.0);\n    m(5, length(p-vec3(0.0,10.0,10.0))-3.0);\n    \n    m(6, length(p-vec3(0.0,0.0,-5.0+cos(iTime)))-2.0);\n    m(7, sdOctahedron(p, 5.0));\n\n    if(cur_space == closest_space) closest_space = 0;\n\n    return dist;\n}\n\nvec3 normal(vec3 p, float eps, const in int cur_space) {\n    // sample 6 distances around the given point, taking into account the body we're currently inside of\n    vec3 v = vec3(eps,0.0,0.0);\n    int _;\n    return normalize(\n        v.xyy*(map(p+v.xyy, cur_space, _)-map(p-v.xyy, cur_space, _)) +\n        v.yxy*(map(p+v.yxy, cur_space, _)-map(p-v.yxy, cur_space, _)) +\n        v.yyx*(map(p+v.yyx, cur_space, _)-map(p-v.yyx, cur_space, _))\n    );\n}\n\nvec3 normal(vec3 pos, const in int cur_space) {\n  return normal(pos, 0.0002, cur_space);\n}\n\n// cast a ray inside a given space/body, and return the id of the space we'll\n// enter when exiting this space through the given ray\nint cast_ray(const in vec3 origin, const in vec3 direction, out vec3 intersection, const in int cur_space) {\n    vec3 ray_pos = origin;\n    int next_space;\n    float dist = 0.0;\n    int num_rays = 0;\n    do {\n        ray_pos += dist * direction;\n        num_rays ++;\n        dist = abs(map(ray_pos, cur_space, next_space));\n    } while(length(ray_pos) < CLIP_FAR && dist > TOUCH_DIST && num_rays < RAY_STEP_LIMIT);\n    if(dist > TOUCH_DIST) next_space = 0; // far-clipped or reached step limit\n    intersection = ray_pos;\n    return next_space;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // spinny camera\n    vec3 cam_pos = vec3(cos(-iTime*0.1)*12.0,cos(iTime*0.5)*3.0+4.0, sin(-iTime*0.1)*12.0),\n               view_fwd = normalize(-cam_pos),\n               view_lft = vec3(sin(-iTime*0.1), 0.0, -cos(-iTime*0.1)),\n               view_up = -cross(view_fwd, view_lft);\n    \n    vec2 screen_pos = (fragCoord-.5*iResolution.xy);\n    float focal_len = iResolution.x / (2.0 * tan(FOV*.5));\n    vec3 ray_dir = normalize(view_lft * -screen_pos.x + view_up * screen_pos.y + view_fwd * focal_len);\n    \n    // Ray stack\n    vec3 st_org[MAX_DEPTH];   // origin\n    vec3 st_dir[MAX_DEPTH];   // direction\n    float st_coef[MAX_DEPTH]; // contribution coefficient\n    int st_spc[MAX_DEPTH];    // space/body the ray is in\n    int st_depth = 0;         // height of stack\n\n    vec3 final_color = vec3(0.0,0.0,0.0);\n    \n    #define st_push(o, d, c, s) if(st_depth<MAX_DEPTH){st_org[st_depth]=o; st_dir[st_depth]=d; st_coef[st_depth]=c; st_spc[st_depth]=s; st_depth++;}\n    \n    st_push(cam_pos, ray_dir, 1.0, 0);\n    \n    int num_rays = 0;\n    \n    while(st_depth > 0 && num_rays < PIXEL_RAY_LIMIT) {\n        // pop a ray off the stack\n        st_depth--;\n        vec3 org = st_org[st_depth];\n        vec3 dir = st_dir[st_depth];\n        float coef = st_coef[st_depth];\n        int current_space = st_spc[st_depth];\n        \n        // if its coefficient is <.1% then it won't make any significant difference, so just discard\n        if(coef < 0.001) continue;\n        \n        vec3 p;\n\n        num_rays++;\n        int next_space = cast_ray(org, dir, p, current_space);\n\n        vec3 col = vec3(0.0,0.0,0.0);\n        switch(bodies[next_space].base) {\n        case MAT_BG:\n            col = texture(iChannel0, dir).xyz;\n            break;\n        case MAT_DIR:\n            col = normalize(p)*.5 + vec3(0.5,0.5,0.5);\n            break;\n        case MAT_NORMAL:\n            col = normal(p, current_space)*.5 + vec3(0.5,0.5,0.5);\n            break;\n        case MAT_CHECKERBOARD:\n            vec3 s = sign(fract(p/5.0*.5)-.5);\n            col = vec3(.8,.8,.8)*(.5 - .5*s.x*s.y*s.z);\n            break;\n        case MAT_NOBASE:\n            col = vec3(0.0,0.0,0.0);\n            break;\n        }\n        final_color += col * coef;\n\n        if(next_space == current_space) continue; // don't reflect/refract off of the skybox\n\n        // push refracted and reflected rays, if applicable\n        // if the stack is full, they'll just be discarded, so if this sort of\n        // auto limits the potential shitton of reflections and refractions \n        if(bodies[next_space].refl_coef > 0.001) {\n            vec3 refl_dir = reflect(dir, normal(p, current_space));\n            st_push(p+refl_dir*0.05, refl_dir, coef*bodies[next_space].refl_coef, current_space);\n        }\n        if(bodies[next_space].refr_coef > 0.001) {\n            vec3 refr_dir = refract(dir, normal(p, current_space), bodies[current_space].refr_idx / bodies[next_space].refr_idx);\n            st_push(p+refr_dir*0.05, refr_dir, coef*bodies[next_space].refr_coef, next_space);\n        }\n    }\n    if(num_rays >= PIXEL_RAY_LIMIT) final_color = vec3(1.0,0.0,1.0); // debug pink <3\n    \n    final_color = pow(final_color, vec3(GAMMA,GAMMA,GAMMA));\n    final_color = clamp(final_color, 0.0, 1.0);\n\n    fragColor = vec4(final_color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}