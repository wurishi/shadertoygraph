{"ver":"0.1","info":{"id":"WdVcz1","date":"1602302138","viewed":195,"name":"Mosaic_4","username":"bigt","description":"马赛克","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["mosaic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float sqrt3 = 1.7320508076;\n\n// 整体思路(纸上画一下!纸上画一下!纸上画一下!):\n// 1.按3:sqrt(3)划分格子\n// 2.将uv坐标或窗口坐标转换到格子坐标下\n// 3.按这样划分格子后有规律:偶数行的格子,划分的那条边是朝右、朝左、朝右...\n//\t\t\t\t\t\t\t对应的六边形中心是左下右上、左上右下、左下右上...\n//\t\t\t\t\t\t\t奇数行同理\n// 4.根据当前像素的位置以及第三步找到的两个六边形中心点可以判断出来当前像素在哪个六边形里面\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 六边形马赛克的半径(单位:像素)\n    float hexagonRadius = 16.0;\n    // 六边形之间平滑值(单位:像素)\n    float threshold = hexagonRadius*0.1;\n\n    // 纸上画图:假设正六边形半径是2,按x:y=3:sqrt(3)划分格子的话,每个格子都是正好让一条边分割两部分\n    vec2 mosaicSize = vec2(hexagonRadius * (1.0+0.5), hexagonRadius * sqrt3*0.5);\n    // 结果为左下角\n    vec2 gridCoord = floor(fragCoord/mosaicSize);// 格子坐标,(0,0)(1,1)(2,2)\n    \n    vec3 col = vec3(0.1,0.1,0.1);\n    \n    // 偶数行:朝右、朝左、朝右、朝左\n    float bRow = 1.0 - step(0.99999, mod(gridCoord.y, 2.0));// 偶数行为1，奇数行为0\n    float bCol = 1.0 - step(0.99999, mod(gridCoord.x, 2.0));// 偶数列为1，奇数列为0\n    float bResult = 1.0 - step(0.00001, abs(bRow - bCol));// 如果行和列相等，则为1(0,0)(1,1)\n    //col = vec3(1.0,0.0,0.0) * bResult;\n    // 每个格子中的两个六边形中心点坐标\n    vec2 c1 = mix(gridCoord + vec2(0.0), gridCoord + vec2(0.0,1.0), 1.0 - bResult);\n    vec2 c2 = mix(gridCoord + vec2(1.0), gridCoord + vec2(1.0,0.0), 1.0 - bResult);\n    // 与以下代码等效\n    {\n    \t//if(mod(gridCoord.y, 2.0) < 0.99999)\n    \t//{\n    \t//    // 偶数列:朝右,六边形中心点坐标在左下或者右上\n    \t//    if(mod(gridCoord.x, 2.0) < 0.99999)\n    \t//    {\n    \t//        c1 = gridCoord;\n    \t//        c2 = gridCoord + vec2(1.0);\n    \t//        //col = vec3(1.0,0.0,0.0);\n    \t//    }\n    \t//    // 奇数列:朝左,中心点在左上，右下\n    \t//    else\n    \t//    {\n    \t//        c1 = gridCoord + vec2(0.0,1.0);\n    \t//        c2 = gridCoord + vec2(1.0,0.0);\n    \t//        //col = vec3(1.0,1.0,0.0);\n    \t//    }\n    \t//}\n    \t//// 奇数行:朝左、朝右、朝左、朝右\n    \t//else\n    \t//{\n    \t//    // 偶数列:朝左,中心点在左上，右下\n    \t//    if(mod(gridCoord.x, 2.0) < 0.99999)\n    \t//    {\n    \t//        c1 = gridCoord + vec2(0.0,1.0);\n    \t//        c2 = gridCoord + vec2(1.0,0.0);\n    \t//        //col = vec3(1.0,1.0,0.0);\n    \t//    }\n    \t//    // 奇数列:朝右,中心点在左下，右上\n    \t//    else\n    \t//    {\n    \t//        c1 = gridCoord;\n    \t//        c2 = gridCoord + vec2(1.0);\n    \t//        //col = vec3(1.0,0.0,0.0);\n    \t//    }\n    \t//}\n    }\n\t\n    // 判断当前坐标离哪个格子近\n    // 不能拿格子坐标去直接判断，因为格子坐标是宽高都一样，单位长度都是1\n    //vec2 curCoordInGrid = fragCoord/mosaicSize;\n    //if(length(curCoordInGrid-c1) < length(curCoordInGrid-c2))\n    float fL1 = length(fragCoord-c1*mosaicSize);\n    float fL2 = length(fragCoord-c2*mosaicSize);\n    // 判断当前点 距离哪个两个六边形中心近，然后将格子坐标转换成uv坐标采样\n    vec3 col1 = texture(iChannel0, c1*mosaicSize/iResolution.xy).rgb;\n\tvec3 col2 = texture(iChannel0, c2*mosaicSize/iResolution.xy).rgb;\n    col = mix(col1, col2, smoothstep(-threshold,threshold,fL1 - fL2));\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}