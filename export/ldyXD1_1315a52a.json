{"ver":"0.1","info":{"id":"ldyXD1","date":"1464144724","viewed":187,"name":"f(x) - 1D functions","username":"JasonD","description":"Testing f(x) 1D functions.\nSee my f(x,y) 2D functions shader here:\nhttps://www.shadertoy.com/view/cscXRr\n\nINSTRUCTIONS:\nEdit float f_x() to test your own functions.\nClick and move mouse to zoom out.\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["testing","graph","fx","function","convenience","verification"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Jason Allen Doucette\n// http://xona.com/jason/\n//\n// f(x)\n// May 24, 2016\n\n\n// ---- SETTINGS ----------------------------------------------------------------\n\n#define COLOR1 vec3(0.3, 0.3, 1.0)\n#define COLOR2 vec3(1.0, 0.3, 0.3)\n#define GRID_DIM_PERCENTAGE 0.9\n\n#define STANDARD_ZOOM 4.0     // 4 = show -2.0..+2.0 at least\n#define ZOOM_MOUSE_POWER 5.0\n\n\n// ---- CONSTANTS ----------------------------------------------------------------\n\n#define PI 3.141592653589793238462643383\n\n\n// ---- METHODS ----------------------------------------------------------------\n\n// ================================================================\n// =    ENTER f(x) FUNCTION HERE                                  =\n// ================================================================\nfloat f_x(float x)\n{\n    \n    // 1a. Sine wave\n    //return sin(x);\n\n    // 1b. Sine wave with time\n    float t = iTime;\n    return sin(x + t);\n\n    // 2a. Smoother Sine?\n    //return sin(sin(x));\n\n    // 2b. Smoother Sine, mapped -1..+1\n    //#define max sin(sin(PI / 2.0));\n    //return sin(sin(x)) / max;\n    \n    // 2c. Sine 3x\n    //#define max sin(sin(sin(PI / 2.0)));\n    //return sin(sin(sin(x))) / max;\n    \n    // 2d. Sine 4x\n    //#define max sin(sin(sin(sin(PI / 2.0))))\n    //return sin(sin(sin(sin(x)))) / max;\n    \n    // 2e. Sine 5x\n    //#define max sin(sin(sin(sin(sin(PI / 2.0)))))\n    //return sin(sin(sin(sin(sin(x))))) / max;\n    \n    // 3. manual creation of a Sine-like wave\n    /*\n    float s = +1.0;\n\n    // cycle every sine wave\n    // so we only need to describe one\n    x = mod(x, PI * 2.0);\n\n    // mirror the second half of the sine wave\n    // with the first\n    // so we only need to describe the first half\n    if (x > PI) {\n        x = x - PI;\n        s = -1.0;\n    }\n    \n    // mirror the second quarter of the sine wave\n    // with the first quarter.\n    // so we only need to describe the first quarter.\n    float xx = PI / 2.0;\n    if (x > xx) {\n        x = xx - (x - xx);\n    }\n    \n    // now describe one quarter\n    // from 0..1\n    float p = x / xx;\n\n    // consider an upside-down, quadratic\n    // starting at (1,1)\n    // and going to the left, starting to accelerate downward in y\n    // as x goes from 1..0\n    \n    // this is it:\n    p = (p - 1.0);\n    \n    p = pow(p, 2.0); // quadratic\n    //p = pow(p, 3.0); // cubic\n    //p = pow(p, 4.0); // quartic\n    \n    p = 1.0 - p;\n    \n    // purpose of that is that we want a fast slope increase\n    // at the x=0 point, and no slope at the x=1\n    \n    // modify x (currently from 0..xx, the range of our quarter sine wave)\n    // so that it accounts for this new p from the quadratic.\n    // at x=0,p=0, and x=1,p=1\n    // so p(0..1)*xx(the max distance), x IS THE SAME.\n    // but inbetween, x rapidly gets away from 0,\n    // but slows to reach 1.\n    x = p * xx;\n    \n    return s * sin(x);\n\t*/\n    \n    // 4.\n    //return abs(x);\n    \n    // 5.\n    //float a = 1. - (1. / (abs(x) + 1.)); // 0..1 for x = 0..infinity\n    //return mix(x*x, abs(x), a);\n}\n\n// ================================================================\n// ================================================================\n// ================================================================\n\nvec3 f_uv(vec2 uv)\n{\n    return (uv.y > f_x(uv.x) \n            ? COLOR1 \n            : COLOR2);\n}\n\nvec3 addGrid(vec2 uv, vec3 color)\n{\n\treturn\n        ((mod(uv.x, 2.0) < 1.0 ? 1 : 0) +\n         (mod(uv.y, 2.0) < 1.0 ? 1 : 0) == 1\n    \t\t? color * GRID_DIM_PERCENTAGE\n            : color);\n}\n\n\n// ---- MAIN ----------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // isotropic scaling, ensuring entire texture fits into the view.\n    // After this, you should consider fragCoord = 0..1, usually,\n    // aside from overflow for wide-screen.\n    float minRes = min(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord / minRes;\n    \n    // get mouse\n    vec2 m = iMouse.xy / minRes;\n    if (iMouse.z < 0.5) {\n    \tm = iResolution.xy / minRes / 2.;\n    }\n    \n    // center point on screen\n    vec2 center = (iResolution.xy / minRes) / 2.;\n    \n    // adjust for center\n    uv -= center;\n    m -= center;\n    \n    // adjust for mouse\n    uv -= m;\n    \n    // zoom\n    // normal zoom of 1.0 shows at least -0.5 .. +0.5 in one of the dimensions\n    float zoom = STANDARD_ZOOM * 2.;\n    float mouseZoom = 1.0 + sqrt(m.x*m.x + m.y*m.y) * ZOOM_MOUSE_POWER;\n    float totalZoom = zoom * mouseZoom;\n    uv.xy *= totalZoom;\n\n    // f(x)\n    vec3 color = f_uv(uv);\n        \n    // show x-axis and y-axis\n    float a = 0.002 * totalZoom;\n    float b = a * 2.;    \n    color *= smoothstep( a, b, abs(uv.x) );\n    color *= smoothstep( a, b, abs(uv.y) );\n    \n    // add grid\n    color = addGrid(uv, color);\n   \n    // result\n\tfragColor = vec4(color, 1.);\n}\n","name":"Image","description":"","type":"image"}]}