{"ver":"0.1","info":{"id":"3dfyRs","date":"1585607073","viewed":52,"name":"36 Days Of Type - B","username":"nicolasdnl","description":"36 Days Of Type - B","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["letter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float dot2( in vec2 v ) { return dot(v,v); }\nfloat msign( in float x ) { return (x>0.0)?1.0:-1.0; }\n\n// https://iquilezles.org/articles/distfunctions2d\nvec2 sdSqLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( dot2(pa-ba*h), ba.x*pa.y-ba.y*pa.x );\n}\n\nfloat sdCrescent(vec2 p, float r0, float r1, float d, float sign0, float sign1)\n{\n    float a = (r0*r0 - r1*r1 + d*d) / (2.0 * d);\n    \n    if( a < r0)\n    {\n        p.y = abs(p.y);\n        float b = sqrt(r0*r0-a*a);\n        float k = p.y*a - p.x*b;\n        float h = min(d*sign0*(d*(p.y-b)-k ),\n                      d*sign1*k);\n        if (h>0.0)\n        {\n            return length(p-vec2(a,b));\n        }\n    }\n    \n    return max(sign0*(length(p          )-r0),\n               sign1*(length(p-vec2(d,0))-r1));\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nvec2 sdSqArc( in vec2 p, in vec2 a, in vec2 b, in float h, float d2min )\n{\n    vec2  ba  = b-a;\n    float l   = length(ba);\n    float ra2 = h*h + l*l*0.25;\n\n    // recenter\n    p -= (a+b)/2.0 + vec2(-ba.y,ba.x)*h/l;\n    \n    float m = ba.y*p.x-ba.x*p.y;\n    float n = dot(p,p);\n    \n    if( abs(h)*abs(ba.x*p.x+ba.y*p.y) < msign(h)*l*0.5*m )\n    {\n        d2min = min( d2min, n + ra2 - 2.0*sqrt(n*ra2) );\n    }\n\n    return vec2(d2min, -max(m,ra2-n) );\n}\n\n\n//------------------------------------------------------------\n\n\n\n// SDF of a shape made of a set line and arc segments\nfloat sdShape( in vec2 p, int kType[6], float kPath[16] )\n{\n    vec2 vb = vec2(kPath[0],kPath[1]);\n    \n    float d = dot2(p-vb);\n    int off = 0;\n    float s = 1.0;\n    for( int i=0; i<kType.length(); i++ )\n    {\n        vec2 va = vb;\n        vec2 ds;\n        \n        if( kType[i]==0) // line (x,y)\n        {\n            vb = vec2(kPath[off+2],kPath[off+3]);\n            ds = sdSqLine( p, va, vb );\n            off += 2;\n        }\n        else if( kType[i]==1) // arc (x,y,r)\n        {\n            vb = vec2(kPath[off+3],kPath[off+4]);\n            ds = sdSqArc(p, va, vb, kPath[off+2], d );\n        \toff += 3;\n\n        }\n        \n        // in/out test\n        bvec3 cond = bvec3( p.y>=va.y, p.y<vb.y, ds.y>0.0 );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n\n        d = min( d, ds.x );\n    }\n\treturn s*sqrt(d);\n}\n\nfloat sdA( in vec2 p )\n{\n   \tint kType[] = int[](0,1,0,1,0,0);\n   \tfloat kPath[] = float[](-0.35,  0.5,\n                             0.15,  0.5, 0.0,\n                             0.15,  0.0,\n                             0.15,  0.0, 0.0,\n                             0.15, -0.5,\n                            -0.35, -0.5,\n                            -0.35,  0.5);\n    return sdShape(p,kType,kPath );\n}\n\nvec3 generateBorder(in vec3 col, in float border)\n{\n    col = mix( col, vec3(0.0), 1.0-smoothstep(0.0,0.015,border) );\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    \n    // distance computations\n    float d = sdA(p);\n    \n    // coloring\n    //float t = 0.525;\n    float t = iTime * 2.5;\n    float gap = 3./10.;\n    \n    vec3 col = vec3(1.,1.,1.);\n    col *= 1.0 + 0.15*cos(128.0*abs(d)-t);\n    col = generateBorder(col, abs(d));\n    /*for (int i=0; i<10; i++) {\n    \tcol = generateBorder(col, abs(d+0.5-mod(t+gap*float(i),3.)));\n    }*/\n    col = 1. - col;\n\n    // output\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}