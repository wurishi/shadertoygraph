{"ver":"0.1","info":{"id":"ds2SDR","date":"1670173196","viewed":87,"name":"example shadertoy planet shader","username":"ChatGPTGeneratedGems","description":"see https://www.shadertoy.com/view/dsjSDR","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test","fun","ai","gpt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// one of the first valid shaders generated by prompt: \"example Shadertoy planet shader\" on chat.openai.com/chat\n//\n// just for testing purposes and/or inspiration\n//\n// #####################################################################################################################\n\n\n\n\n#define PI 3.14159265358979323846\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized device coordinates (-1 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // 3D position in camera space\n    vec3 camPos = vec3(0.0, 0.0, -1.0);\n    vec3 camDir = normalize(vec3(uv.xy, 1.0));\n    vec3 camRight = normalize(vec3(camDir.z, 0.0, -camDir.x));\n    vec3 camUp = cross(camRight, camDir);\n\n    // Planet radius and cloud height\n    float radius = 0.5;\n    float cloudHeight = 0.04;\n    \n    //camPos.x +=iTime *0.05;\n\n    // Raymarch the planet surface and clouds\n    vec3 p = camPos;\n    vec3 color = vec3(0.0);\n    float totalDist = 0.0;\n    for (int i = 0; i < 520; i++)\n    {\n        // Distance to the planet surface\n        float dist = length(p) - radius;\n\n        // Distance to the cloud layer\n        float cloudDist = abs(p.y) - cloudHeight;\n\n        // Compute the color of the planet surface and clouds\n        vec3 c = vec3(0.0);\n        if (dist < 0.0)\n        {\n            c = mix(vec3(0.2, 0.4, 0.8), vec3(0.8, 0.4, 0.2), p.y*0.1 + 0.5);\n        }\n        else if (cloudDist < 100.0)\n        {\n            c = mix(vec3(1.0, 1.0, 1.0), vec3(0.8, 0.4, 0.2), p.y*0.1 + 0.5);\n        }\n\n        // Accumulate the color and distance for shading\n        color += c * exp(-totalDist);\n        totalDist += dist;\n\n        // Advance the ray\n        p += camDir * dist * 0.1;\n    }\n\n    // Compute the lighting\n    float lighting = clamp(dot(normalize(p), normalize(vec3(-0.3, 0.5, 0.5))), 0.0, 1.0);\n\n    // Apply the lighting and gamma correction\n    fragColor = vec4(color * lighting, 1.0);\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.4545));\n}\n","name":"Image","description":"","type":"image"}]}