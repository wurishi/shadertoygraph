{"ver":"0.1","info":{"id":"MfBcDG","date":"1722901801","viewed":36,"name":"tunnel with camera","username":"Elsio","description":"para além do cálculo de câmera, que me parece uma coisa sem controle, ainda tem a questão da iluminação que não é uma coisa fácil e parece que tem que ser específica para cada shader. Nunca vou ter aprendido isso por completo. ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["torus","tutorial","rings","tunel"],"hasliked":0,"parentid":"4c2yRK","parentname":"tunnel without camera"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*  \n\n*/\n\n#define rot(a) mat2(cos(a + vec4(0, 11, 33, 0)))\n#define r33(p) fract(7896. * sin(p * 452.))\n#define T  iTime * 4.\n\nvec4 cor;\n\nvec2 path(float z) {\n    return  2. * vec2(\n        sin(z * .3), \n        cos(z * .2) \n    );\n}\n\nfloat texturize(vec3 p){\n    p = fract(p) - .5;\n    return length(p) - .1;\n}\n\nfloat insertObjs(vec3 p){\n    vec3 id = floor(p);\n         p = fract(p) - .5;\n    \n    p.zy *= rot(T + id.x);\n    p.zx *= rot(T + id.z);\n    \n    float torus = length(p.xy) - .1;\n          torus = length(vec2(torus, p.z)) - .03;\n    \n    return id.y < 0.? torus : 1.;\n}\n\n\nfloat map(vec3 p){\n    p.xy -= path(p.z);\n    \n    cor.xyz = r33(floor(p));\n    \n    float tunel = 3. - length(p.xy);;\n    tunel += texturize(p);\n    tunel *= insertObjs(p);\n    return tunel * .4;\n}\n\n\n\nvoid mainImage(out vec4 O, vec2 u){\n    vec2 R = iResolution.xy;\n         u = (u - .5 * R) / R.y;\n\n    vec3 p = vec3(0, 0, T),\n         eye = p + vec3(0, 0, 1),\n         ld = p + vec3(0, .5, 5. + cos(T * .2) * 5.);\n    \n    p.xy += path(p.z);\n    ld.xy += path(ld.z);\n    eye.xy += path(eye.z);\n    \n    vec3 D = normalize(eye - p),\n         r = vec3(D.z, 0, -D.x);\n         \n    D += mat2x3(r, cross(D, r)) * u;\n    \n    float i, d, s = 1.;\n    while(i++ < 1e3 && d < 1e3 && s > .001) \n        s = map(p) * .6,\n        d += s,\n        p += s * D;\n        \n    vec3 e = vec3(.01, 0, 0),\n         n = normalize(\n             map(p) - vec3(\n                 map(p-e.xyy), \n                 map(p-e.yxy),\n                 map(p-e.yyx)));\n\n    \n    O = sqrt(\n            cor * max(0., dot(n, normalize(ld - p)))  \n            + .5 * pow(\n                     max(0., \n                         dot(n, normalize(ld - p))\n                     )\n                     , 20. )); \n}","name":"Image","description":"","type":"image"}]}