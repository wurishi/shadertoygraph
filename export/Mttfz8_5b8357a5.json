{"ver":"0.1","info":{"id":"Mttfz8","date":"1538932723","viewed":648,"name":"Continuous-Scale Morphology","username":"vchizhov","description":"Continuous-scale morphology based on the hyperbolic PDE: du/dt = +-|grad(u)|. WS - dilate/erode. AD - to change mode (0 - Rouy–Tourin, 1 - Osher and Sethian, 2 - FCT). Setting TEST_WITH_DISK to 1, uses a disk as initial image.","likes":9,"published":1,"flags":48,"usePreview":0,"tags":["filtering","hyperbolic","morphology"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tBased on the lecture \"Continuous-Scale Morphology I: Basic Ideas\" from the course \n\t\"Differential Equations in Image Processing and Computer Vision\", \n\tWinter Term 2017 / 2018, Saarland University\n\n\tNote: the FCT scheme was applied separately for each colour channel which may not be ideal.\n\tThe same was done for the other schemes.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n\tContinuous-scale morphology: dilation and erosion\n\tDilation: du/dt = |grad(u)|\n\tErosion: du/dt = -|grad(u)|\n\n\tRouy–Tourin (1992) schemes (h1=h2=1):\n\tDilation:\n\tT(0,0)' = T(0,0) + tau * sqrt((max{0, T(1,0)-T(0,0), T(-1,0)-T(0,0)})^2 + (max{0, T(0,1)-T(0,0), T(0,-1)-T(0,0)})^2)\n\tErosion:\n\tT(0,0)' = T(0,0) - tau * sqrt((max{0, T(0,0)-T(1,0), T(0,0)-T(-1,0)})^2 + (max{0, T(0,0)-T(0,1), T(0,0)-T(0,-1)})^2)\n\t\n\tstability: tau <= 1/sqrt(2)\n\n\n\tOsher and Sethian schemes:\n\tDilation:\n\tT(0,0)' = T(0,0) + tau * sqrt((max{0, T(1,0)-T(0,0)})^2 + (max{0,T(-1,0)-T(0,0)})^2 + \n\t\t\t\t(max{0, T(0,1)-T(0,0)})^2 + (max{0,T(0,-1)-T(0,0)})^2)\n\tErosion:\n\tT(0,0)' = T(0,0) - tau * sqrt((max{0, T(0,0)-T(1,0)})^2 + (max{0,T(0,0)-T(-1,0)})^2 + \n\t\t\t\t(max{0, T(0,0)-T(0,1)})^2 + (max{0,T(0,0)-T(0,-1)})^2)\n\n\n\tFlux Corrected Transport schemes:\n\tM. Breuß, J. Weickert: A shock-capturing algorithm for the differential equations of dilation and\n\terosion. Journal of Mathematical Imaging and Vision, Vol. 25, 187–201, 2006.\n\n\tThe FCT scheme avoids overblurring at edges.\n\n*/\n\n#define T(X,Y) texture(iChannel0, scale*(fragCoord+vec2(X,Y))).xyz\n\nbool keyDown(int ascii) {\n\treturn texture(iChannel2,vec2((.5+float(ascii))/256.,0.25)).x>0.0;\n}\n\nint keyHit(int ascii) {\n\treturn int(texture(iChannel2,vec2((.5+float(ascii))/256.,1.5/3.)).x == 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 scale = 1.0 / iResolution.xy;\n    vec4 info = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    bool textureLoaded = iChannelResolution[1].x>0.0;\n    vec3 col;\n    \n    // encode state: \n    // sEncoded & 32 == 0 -> sEncoded & 16 == 0 -> mode 0; == 1 -> mode 1\n    // sEncoded & 32 == 1 -> sEncoded & 16 == 0 -> mode 2; == 1 -> undefined\n    // mode 0: Rouy–Tourin\n    // mode 1: Osher and Sethian\n    // mode 2: FCT\n    // sEncoded & 8 == 1 -> erosion; == 0 -> dilation\n    // For FTC:\n    // sEncoded & 4 == sz, sEncoded & 2 == sy, sEncoded & 1 = sx\n    int sEncoded = int(texelFetch(iChannel3, ivec2(fragCoord), 0).w);\n    int mode = 2*(sEncoded / 32) + (sEncoded - 32 * (sEncoded / 32))/16;\n    mode = (mode + keyHit(KEY_D) - keyHit(KEY_A));\n    // wrap around\n    mode = mode<0 ? 3+mode : mode>2 ? mode-3 : mode;\n    \n    // save the mode for next frame\n    sEncoded = 32*(mode/2) + 16*(mode%2);\n    bool kDW = keyDown(KEY_W);\n    bool kD = kDW || keyDown(KEY_S);\n    if(kD) // do dilation/erosion\n    {\n        vec3 c = T(0,0);\n        // save state dilation/erosion\n        sEncoded += int(!kDW)*8;\n        // use appropriate sign depending on dilation/erosion\n        float sgn = 2.0*float(kDW)-1.0;\n        if(mode==0) // Rouy–Tourin\n        {\n            vec3 ux = max(vec3(0.0), max(sgn*(T(1,0)-c), sgn*(T(-1,0)-c)));\n            vec3 uy = max(vec3(0.0), max(sgn*(T(0,1)-c), sgn*(T(0,-1)-c)));\n            col = c + sgn*tau * sqrt(ux*ux + uy*uy);\n        }\n        else if(mode==1) // Osher and Sethian\n        {\n            vec3 ufx = max(vec3(0.0), sgn*(T(1,0)-c));\n            vec3 ubx = max(vec3(0.0), sgn*(T(-1,0)-c));\n            vec3 ufy = max(vec3(0.0), sgn*(T(0,1)-c));\n            vec3 uby = max(vec3(0.0), sgn*(T(0,-1)-c));\n            col = c + sgn*tau * sqrt(ufx*ufx + ubx*ubx + ufy*ufy + uby*uby);\n        }\n        else // FCT\n        {\n            vec3 dUjh = sgn*(T(0,1)-c);  vec3 dUih = sgn*(T(1,0) - c);\n            vec3 dUjn = sgn*(c-T(0,-1)); vec3 dUin = sgn*(c-T(-1,0));\n            vec3 dUi = 0.5*tau * ( abs(T(1,0) - T(-1,0)) + dUih - dUin );\n            vec3 dUj = 0.5*tau * ( abs(T(0,1) - T(0,-1)) + dUjh - dUjn );\n            vec3 s = vec3(1.0)-vec3(lessThanEqual(dUih,vec3(0.0)))*vec3(lessThanEqual(dUjh,vec3(0.0)))*\n                vec3(greaterThanEqual(dUin,vec3(0.0)))*vec3(greaterThanEqual(dUjn,vec3(0.0)));\n            col = c + sgn*sqrt(s*(dUi*dUi + dUj*dUj));\n            sEncoded += int(s.x) + 2*int(s.y) + 4*int(s.z);\n        }\n    }\n    else // do nothing\n    {\n        col = info.xyz;\n        // sEncoded does not need to change\n        // this works as it is, since s.x, s.y, s.z will all be 0, so the image won't change\n        // even if the mode is set to FCT (mode==2)\n    }\n    \n    fragColor = vec4(col,sEncoded);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define T(X,Y) texture(iChannel0, scale*(fragCoord+vec2(X,Y))).xyz\n#define PI           3.14159265358979323846\n\nvec3 minmod(vec3 a, vec3 b, vec3 c)\n{\n    return sign(b)*max(vec3(0.0),min(sign(b)*a, min(abs(b), sign(b)*c)));\n}\n\n // Official HSV to RGB conversion \nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 scale = 1.0 / iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    bool textureLoaded = iChannelResolution[1].x>0.0;\n    vec3 col;\n    \n   \n    if(textureLoaded && texture(iChannel3, fragCoord).w<1.0)\n    {\n        #if TEST_WITH_DISK == 1\n        vec2 diff = uv-vec2(0.5);\n        diff.x *= iResolution.x/iResolution.y;\n        if (dot(diff,diff)<0.01)\n        {\n            float angle = atan(diff.y,diff.x);\n            col = hsv2rgb(vec3(angle/(2.0*PI),1,1));\n        }\n        else\n            col = vec3(0);\n        #else\n        col = texture(iChannel1, uv).xyz;\n        #endif\n        \n    }\n    else\n    {\n        col = texture(iChannel0, uv).xyz;\n        \n        int sEncoded = int(texelFetch(iChannel0, ivec2(fragCoord), 0).w);\n        int mode = sEncoded / 32;\n        if(2*mode==2) // execute this only for FCT, otherwise just use the color\n        {\n            int rem = sEncoded;\n            // get rid of the mode bits:\n            rem = sEncoded - 32;\n            rem = rem - 16 * (rem / 16);\n            // retrieve the dilation/erosion bit\n            int erosion = rem / 8;\n            // get rid of the dilation/erosion bit\n            rem = rem - 8* erosion;\n            // retrieve the sx, sy, sz bits:\n            int sz = rem / 4;\n            rem = rem - sz*4;\n            int sy = rem/2;\n            int sx = rem - 2*sy; \n            vec3 sDecoded = vec3(sx, sy, sz);\n            // use +1 for dilation, -1 for erosion\n            float sgn = 2.0*float(erosion) - 1.0;\n            \n            \n            // stabilize:\n            vec3 qh1 = 0.5*tau*abs(T(1,0)-T(-1,0));\n            vec3 qh2 = 0.5*tau*abs(T(0,1)-T(0,-1));\n            vec3 qh = sgn*sqrt(qh1*qh1 + qh2*qh2);\n\n\n            vec3 gip = minmod(T(0,0)-T(-1,0), 0.5*tau*(T(1,0)-T(0,0)), T(2,0) - T(1,0));\n            vec3 gin = minmod(T(-1,0)-T(-2,0), 0.5*tau*(T(0,0)-T(-1,0)), T(1,0) - T(0,0));\n            vec3 gjp = minmod(T(0,0)-T(0,-1), 0.5*tau*(T(0,1)-T(0,0)), T(0,2) - T(0,1));\n            vec3 gjn = minmod(T(0,-1)-T(0,-2), 0.5*tau*(T(0,0)-T(0,-1)), T(0,1) - T(0,0));\n            vec3 deltaUi = qh1 + sgn*gip - sgn*gin;\n            vec3 deltaUj = qh2 + sgn*gjp - sgn*gjn;\n            vec3 ql = sgn*sqrt(deltaUi*deltaUi + deltaUj*deltaUj);\n            col = T(0,0) + sDecoded*(qh - ql);\n\n        }\n    }\n    fragColor = vec4(col,float(textureLoaded));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// stability is guaranteed for tau <= 1/sqrt(2) ~ 0.7\n// I've set it to 0.1 to reduce the sensitivity when pressing W/S\nconst float tau = 0.1;\n\n// utility:\nconst int KEY_W = 87;\nconst int KEY_S = 83;\nconst int KEY_D = 68;\nconst int KEY_A = 65;\n\n#define TEST_WITH_DISK 0","name":"Common","description":"","type":"common"}]}