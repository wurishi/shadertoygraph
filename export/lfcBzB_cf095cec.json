{"ver":"0.1","info":{"id":"lfcBzB","date":"1733229902","viewed":166,"name":"Elevation Map","username":"Nekodigi","description":"- The solid is reconstructed by layering -\nCreated with simple extrusion and stack.","likes":11,"published":3,"flags":0,"usePreview":0,"tags":["elevation","layer","isovalue"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//References\n//Isovalues 4 https://www.shadertoy.com/view/MdtfDl\n//Extrusion and Revolution SDF  https://www.shadertoy.com/view/4lyfzw\n\n#define PI 3.14159265358979\n#define ZERO (min(iFrame,0))\n#define FOG_D 0.04\n#define FAR 50. // Maximum allowable ray distance.\n//tailwind colors, green 50-950 https://tailwindcss.com/docs/customizing-colors\nvec3 COL_LUT[11] = vec3[](vec3(0.941,0.992,0.957), vec3(0.863,0.988,0.906), vec3(0.733,0.969,0.816), vec3(0.525,0.937,0.675), vec3(0.29,0.871,0.502),\nvec3(0.133,0.773,0.369), vec3(0.086,0.639,0.29), vec3(0.082,0.502,0.239), vec3(0.086,0.396,0.204), vec3(0.078,0.325,0.176), vec3(0.02,0.18,0.086));\n\nfloat noise3( vec3 x ) {\n    vec3 p = floor(x),f = fract(x);\n\n    f = f*f*(3.-2.*f);  // or smoothstep     // to make derivative continuous at borders\n\n#define hash3(p)  fract(sin(1e3*dot(p,vec3(1,57,-13.7)))*4375.5453)        // rand\n    \n    return mix( mix(mix( hash3(p+vec3(0,0,0)), hash3(p+vec3(1,0,0)),f.x),       // triilinear interp\n                    mix( hash3(p+vec3(0,1,0)), hash3(p+vec3(1,1,0)),f.x),f.y),\n                mix(mix( hash3(p+vec3(0,0,1)), hash3(p+vec3(1,0,1)),f.x),       \n                    mix( hash3(p+vec3(0,1,1)), hash3(p+vec3(1,1,1)),f.x),f.y), f.z);\n}\n#define noise(x) (noise3(x)+noise3(x+11.5)) / 2. // pseudoperlin improvement from foxes idea \n\n\nfloat sdCross( in vec2 p, in vec2 b, float r ) \n{\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    \n\tvec2  q = p - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n    \n    return sign(k)*length(max(w,0.0)) + r;\n}\n\nfloat opExtrusion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nmat2 rot2(float a){\n    \n    float c = cos(a); float s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat map(in vec3 pos)\n{\n    float d = 1e10;\n    pos.xy *= rot2(iTime*0.1);\n    pos.y += sin(iTime * 0.1)*10.;\n    pos.x += cos(iTime * 0.1)*10.;\n    \n    //pos.xy *= sin(iTime*0.1)*0.8+1.5;\n    for(float i=0.; i<10.; i++){\n      vec3 q = pos - vec3(0., 0., i*0.1);\n      d = min(d,opExtrusion( q, noise(vec3(q.xy, sin(iTime/100.)*10.))-i*0.1, 0.1 ));\n    }\n    return d-0.03;\n}\n\n\n\n// Surface normal.\nvec3 getNormal(in vec3 p) {\n\t\n\tconst float eps = 0.001;\n\treturn normalize(vec3(\n\t\tmap(vec3(p.x + eps, p.y, p.z)) - map(vec3(p.x - eps, p.y, p.z)),\n\t\tmap(vec3(p.x, p.y + eps, p.z)) - map(vec3(p.x, p.y - eps, p.z)),\n\t\tmap(vec3(p.x, p.y, p.z + eps)) - map(vec3(p.x, p.y, p.z - eps))\n\t));\n}\n\nfloat calculateAO( in vec3 p, in vec3 n )\n{\n\tfloat ao = 0.0, l;\n    const float maxDist = 2.;\n\tconst float nbIte = 6.0;\n\t//const float falloff = 0.9;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i*.75 + fract(cos(i)*45758.5453)*.25)/nbIte*maxDist;\n        \n        ao += (l - map( p + n*l ))/(1.+ l);// / pow(1.+l, falloff);\n    }\n\t\n    return clamp(1.- ao/nbIte, 0., 1.);\n}\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<24; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s );\n        t += clamp( h, 0.01, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nvec2 trace(in vec3 ro, in vec3 rd){\n\n    float t = 0.0, h;\n    float iter = 0.;\n    for(int i = 0; i < 96; i++){\n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.002*(t*.125 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h*.8;\n        iter += FOG_D;\n        iter *= 0.97;\n    }\n\n    return vec2(min(t, FAR), iter);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  \n  vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\tvec2 mouse = (iMouse.xy / iResolution.xy)*2. - 1.;\n\t// Camera Setup.\n  vec3 lookAt = vec3(0.0, 0.0, -5.);  // \"Look At\" position.\n\tvec3 ro = lookAt + vec3(0., -0.5, -.5); // Camera position, doubling as the ray origin.\n    // Light positioning. One is a little behind the camera, and the other is further down the tunnel.\n \tfloat FOV = PI/3.; // FOV - Field of view.\n  vec3 forward = normalize(lookAt-ro);\n  vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n  vec3 up = cross(forward, right);\n  // rd - Ray direction.\n  vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n  \n  vec3 light_pos = ro + vec3(4., 3., 4.125);// Put it a bit in front of the camera.\n\tvec3 light_pos2 = ro + vec3(-5., 7.0, 4.0);// Put it a bit in front of the camera\n\t\n  // Raymarching.\n  vec2 t = trace(ro, rd);\n  vec3 col = vec3(0.0);\n  if (t.x < FAR) {\n    vec3 sp = ro + rd*t.x;\n    vec3 albedo = COL_LUT[int(sp.z*10.)];\n    vec3 sn = getNormal(sp);\n    float ao = calculateAO(sp, sn);\n    vec3 ld1 = normalize(light_pos - sp);\n    vec3 ld2 = normalize(light_pos2 - sp);\n    vec3 ld3 = normalize(vec3(1.0, 1.0, -1.0));\n    vec3 lc1 = vec3(0.906,0.898,0.894);\n    vec3 lc2 = vec3(0.996,0.792,0.792);\n    vec3 lc3 = vec3(0.992,0.902,0.541);\n    float diff1 = max(0., dot(sn, ld1));\n    float diff2 = max(0., dot(sn, ld2));\n    float diff3 = max(0., dot(sn, ld3));\n    float sh1 = calcSoftshadow(sp, ld1, 0.01, 1.0);\n    float sh2 = calcSoftshadow(sp, ld2, 0.01, 1.0);\n    float sh3 = calcSoftshadow(sp, ld3, 0.01, 1.0);\n    col = albedo*(diff1*lc1*sh1 + diff2*lc2*sh2 + diff3*lc3*sh3)*ao;\n    \n  }\n  col = pow( col, vec3(0.4545) );//gamma\n  fragColor = vec4(col, 1.0);\n}\n\n//Feedback\n//! Phase shift\n\n//! Bevel / Round Edge\n//! Dynamic movement like flying\n//? Crystal Tunnel\n//! Colorful light\n","name":"Image","description":"","type":"image"}]}