{"ver":"0.1","info":{"id":"csVcWd","date":"1697541927","viewed":56,"name":"More Simple Metaballs","username":"poxel","description":"my first actual creation","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["simple","noob","metaballas"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Basic constants\nconst float EDGE = 1.0; // This is the edge for the step function used for drawing the metaballs\nconst int BALL_COUNT = 5; // If you add a ball and a speed update this constant\n\n\n// Defining a list of balls in their initial positions in (x, y, magnitude) format.\nvec3 balls[] = vec3[](\n    vec3(0.1, 0.2, 0.03),\n    vec3(0.1, -0.2, 0.05),\n    vec3(0.7, -0.5, 0.07),\n    vec3(0., 0., 0.1),\n    vec3(-0.1, -0.2, 0.05)\n);\n\n// Defining speeds for the balls. \nvec2 speeds[] = vec2[](\n    vec2(0.1, 0.5),\n    vec2(-0.1, 0.5),\n    vec2(0.5, 0.7),\n    vec2(1., 1.),\n    vec2(0.3, -0.1)\n);\n\n\n//vec3 colorA = vec3(0.149,0.141,0.912);\n//vec3 colorB = vec3(1.000,0.833,0.224);\n\n\n// This is basically the 3d function which takes uv coordinates and returns a float value.\n// The metaballs are used to consruct the function and have greater effect the closer they are to the uv.\nfloat metaballFunction(vec2 uv, vec3 balls[BALL_COUNT]) {\n    float sum = 0.;\n    for (int i = 0; i < BALL_COUNT; i++){\n        sum += balls[i].z/distance(balls[i].xy, uv);\n    }\n    return sum;\n}\n\n\n// This function calculates the position of the balls and edits the ball array\nvoid getBalls() {\n    \n    float yloopbacks;\n    float xloopbacks;\n    \n    for (int i = 0; i < BALL_COUNT; i++){\n        // update the ball position\n        balls[i].xy += iTime*speeds[i];\n        \n        // get the amount of screens the ball passed in the x and y axis\n        yloopbacks = floor(balls[i].y + 0.5);\n        xloopbacks = floor((balls[i].x + 0.5*iResolution.x/iResolution.y)/(iResolution.x/iResolution.y));\n        \n        // move ball back to screen\n        balls[i].y = mod(balls[i].y + 0.5, 1.0) - 0.5;\n        balls[i].x = mod(balls[i].x + 0.5*iResolution.x/iResolution.y, iResolution.x/iResolution.y) - 0.5*iResolution.x/iResolution.y;\n        \n        // update position based on number of loopbacks so it looks like the balls are bouncing\n        // off the edges and not teleporting.\n        balls[i].y *= 1. - 2.*mod(yloopbacks, 2.);\n        balls[i].x *= 1. - 2.*mod(xloopbacks, 2.);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n    \n    getBalls();\n    float value = metaballFunction(uv, balls);\n    \n    vec3 col = vec3(step(EDGE, value));\n    \n    //col = mix(colorA, colorB, value);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}