{"ver":"0.1","info":{"id":"ldtXWf","date":"1461939155","viewed":323,"name":"Craters on Craters","username":"NickWest","description":"Moon surface with craters. Simple lighting.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["moon","surface","lunar","crater"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define animSpeed 0.05\n\n//-----------------------------------------------------------------------------\n// Crater in -1.0 to 1.0 space\nfloat crater(in vec2 pos) {\n    float len = length(pos);\n    float pi = 3.1415926535;\n    float x = clamp(pow(len, 4.0) * 8.0, pi*0.5, pi*2.5);\n    float t = clamp(len, 0.0, 1.0);\n    return sin(-x) + 0.5 - 0.5 * cos(t * pi);\n}\n\n//-----------------------------------------------------------------------------\nvec2 pseudoRand(in vec2 uv) {\n    // from http://gamedev.stackexchange.com/questions/32681/random-number-hlsl\n    float noiseX = (fract(sin(dot(uv, vec2(12.9898,78.233)      )) * 43758.5453));\n    float noiseY = (fract(sin(dot(uv, vec2(12.9898,78.233) * 2.0)) * 43758.5453));\n    return vec2(noiseX, noiseY);}\n\n//-----------------------------------------------------------------------------\nfloat repeatingCraters(in vec2 pos, in float repeat, in float scaleWeight) {\n    vec2 pos01 = fract(pos * vec2(repeat));\n    vec2 index = (pos * vec2(repeat) - pos01) / repeat;\n    vec2 scale = pseudoRand(index);\n    float craterY = crater(vec2(2.0) * (pos01 - vec2(0.5)));\n    return mix(1.0, pow(0.5*(scale.x + scale.y), 4.0), scaleWeight) * craterY; \n}\n\n//-----------------------------------------------------------------------------\nfloat getY(in vec2 pos) {    \n    float y = 0.5;\n    for(int i=0;i<int(100);++i) {\n        float f01 = float(i) / float(99.0);\n        float magnitude = pow(f01, 2.3);\n        vec2 offs = pseudoRand(vec2(float(i+2), pow(float(i+7), 3.1)));\n        float repeat = 0.5 / (magnitude + 0.0001);\n\n        y += magnitude * repeatingCraters(pos+offs, repeat, 1.0);\n    }\n    \n\treturn y;\n}\n\n//-----------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pos = (fragCoord.xy - iResolution.xy*0.5) / vec2(iResolution.y);\n    pos += vec2(1.0); // avoid negative coords\n\n    vec2 offs = vec2(0.001, -0.001);\n    \n    pos.x += iTime * animSpeed;\n    pos.y -= iTime * animSpeed * 0.25;\n    \n    float y = getY(pos);\n    float y1 = getY(pos - offs);\n    //float y2 = getY(pos + offs);\n\n    vec3 normal = normalize(vec3(0.01, y-y1, 0.01));\n\n    float d = 0.5 + 0.5 * dot(normal, normalize(vec3(2.0, 1.0, 2.0)));\n    \n    float shadeScale = 1.0;\n\n    /*\n    // shadows\n    {\n        \n        for(int i=0;i<int(40);++i) {\n            float f01 = float(i+1) / float(40.0);\n            f01 = pow(f01, 2.0);\n\n            vec2 posTest = pos - vec2(f01, -f01) * 0.5;\n\n            float yTest = getY(posTest);\n\n            float over = yTest - (y + f01 * 3.0);\n            \n            if(over > 0.0)\n                shadeScale = min(shadeScale, mix(1.0, 0.7, clamp(over*0.5,0.0,1.0)));\n        }\n    }\n    \n    d *= shadeScale;\n    */\n\n    float c = y * 0.02 - 0.5 + d * 1.3;\n\n    // color ramp\n    vec3 rgb = vec3(mix(mix(vec3(0.0,0.0,0.0), vec3(0.8,0.6,0.4), c), vec3(1.0,0.95,0.90), c));\n    \n    fragColor = vec4(rgb,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}