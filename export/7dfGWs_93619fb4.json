{"ver":"0.1","info":{"id":"7dfGWs","date":"1616722339","viewed":248,"name":"PS5 Bokeh-Ribbon for Retroarch","username":"carterisonline","description":"Read the comments at the top for information on how to use with Retroarch","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/// How to use:\n/// ---\n/// Replace `fragColor` with `gl_FragColor`\n/// Replace `iResolution` with `OutputSize`\n/// Replace `fragCoord` with `gl_FragCoord`\n/// Replace `iTime` with `time`\n/// ---\n/// In the Retroarch repository: (you should clone their git repo)\n/// `gfx/drivers/gl_shaders`\n/// Replace contents of `pipeline_bokeh.glsl.frag.h`'s `main()` function with the contents of this `mainImage()` function\n/// ---\n/// Return to retroarch repository\n/// Run `./configure && make`\n/// When the project finishes compiling, run `./retroarch` or `\\.retroarch.exe`\n/// ???\n/// profit\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\n  float aspectRatio = iResolution.x / iResolution.y;\n\n  vec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n      uv.x *= aspectRatio;\n\n  float speed = iTime * 4.0 + 4000.0;\n\n  vec3 color = vec3(0.0);\n\n  for (float i = 0.0; i < 320.0; i += 1.0) {\n    float phase = sin(i * 1546.13 + 1.0) / 20.0 + 0.5;\n    float size = pow(sin(i * 651.74) * 0.6 + 0.1, 4.0);\n\n    float phase_times_speed = phase * speed;\n\n    vec2 pos = vec2(\n        i / 80.0 - 1.8,\n        (( sin( phase_times_speed / (((i + 50.0) / 5.0) - 1.0) ) * cos(phase * 10.0) / 3.0 ) - ( sin( i / 26.0 + 1.0 ) * 0.1 )) * 0.5\n    );\n\n    float radius = 0.1 + 0.5 * size + sin(phase + size) / 40.0;\n    float distance_from_origin = length(uv - pos) * 10.0;\n    if (distance_from_origin < radius) {\n      vec3 color_out = mix(\n          vec3(0.615, 0.73, 0.8) * sin(phase_times_speed / 2.0) * 2.0,\n          vec3(0.1, 0.3 * phase, 0.4 * sin(phase)),\n          0.5 + sin(i) * 0.1\n      );\n      color += color_out.zyx * (1.0 - smoothstep(radius / 2.0, radius, distance_from_origin));\n    }\n  }\n  color *= sqrt(1.5 - length(uv) * 0.1);\n  fragColor = vec4(color.r, color.g, color.b, 0.5);\n}","name":"Image","description":"","type":"image"}]}