{"ver":"0.1","info":{"id":"NdlcDB","date":"1643547253","viewed":103,"name":"Ray Marching Mob Programming","username":"lesleylai","description":"Ray marching demo mob programmed by the Graphics Programming Virtual Meetup attendees","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 lightPos = vec3(0.0, 2, -4.0);\n\nfloat sphereSdf(vec3 pos, vec3 origin, float radius) {\n  return distance(pos, origin) - radius;\n}\n\nfloat xzPlaneSdf(vec3 pos, float height) {\n  return pos.y - height;\n}\n\n\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n  return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat sceneSdf(vec3 pos) {\n  return min(smin(sphereSdf(pos, vec3(-1.0*sin(iTime * 0.4), 0.6*sin(iTime * 0.4), -4.0), 0.5),\n             sphereSdf(pos, vec3(1.0*sin(iTime * 0.4), 0.6*sin(iTime * 0.4), -4.0), 0.5), 1.),\n             xzPlaneSdf(pos, -1.));\n}\n\nvec3 sceneNormal(vec3 pos) {\n  const float epsilon = 1e-4;\n  float dist = sceneSdf(pos);\n  float dx = sceneSdf(pos + vec3(epsilon, 0.0, 0.0)) - dist;\n  float dy = sceneSdf(pos + vec3(0.0, epsilon, 0.0)) - dist;\n  float dz = sceneSdf(pos + vec3(0.0, 0.0, epsilon)) - dist;\n  return normalize(vec3(dx, dy, dz));\n}\n\nbool rayMarching(inout vec3 origin, vec3 direction) {\n  float nextDist = 1000000.0;\n  const float epsilon = 1e-3;\n  float t = 0.0;\n  for (int i = 0; i < 200; ++i) {\n    nextDist = sceneSdf(origin);\n    t += nextDist;\n    if (nextDist < epsilon) {\n      return true;\n    }\n    origin += direction * nextDist;\n  }\n  return false;\n}\n\nvec3 tonemap_uchimura2(vec3 v)\n{\n    const float P = 1.0;  // max display brightness\n    const float a = 1.7;  // contrast\n    const float m = 0.1; // linear section start\n    const float l = 0.0;  // linear section length\n    const float c = 1.33; // black\n    const float b = 0.0;  // pedestal\n\n    float l0 = ((P - m) * l) / a;\n    float L0 = m - m / a;\n    float L1 = m + (1.0 - m) / a;\n    float S0 = m + l0;\n    float S1 = m + a * l0;\n    float C2 = (a * P) / (P - S1);\n    float CP = -C2 / P;\n\n    vec3 w0 = 1.0 - smoothstep(0.0, m, v);\n    vec3 w2 = step(m + l0, v);\n    vec3 w1 = 1.0 - w0 - w2;\n\n    vec3 T = m * pow(v / m, vec3(c)) + vec3(b);\n    vec3 S = P - (P - S1) * exp(CP * (v - S0));\n    vec3 L = m + a * (v - vec3(m));\n\n    return T * w0 + L * w1 + S * w2;\n}\n\nvec3 aces_approx(vec3 v)\n{\n    v *= 0.6f;\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n    uv.y *= iResolution.y / iResolution.x;\n    \n    vec3 direction = normalize(vec3(uv, -1.0));\n    \n    vec3 origin = vec3(0.0);\n    bool hit = rayMarching(origin, direction);\n    vec3 col = vec3(0.0);\n    if (hit) {\n      vec3 lightDir = normalize(lightPos - origin);\n      vec3 normal = sceneNormal(origin);\n      vec3 shadowRayOrigin = origin + 3e-3 * normal;\n      bool shadowRayHit = rayMarching(shadowRayOrigin, lightDir);\n      float lightDistance = distance(lightPos, origin);\n\n      if (!shadowRayHit || distance(shadowRayOrigin, origin) > lightDistance) {\n          col = normal * 0.5 + 0.5;\n          col *= 5.0 / (lightDistance * lightDistance);\n          col *= max(dot(normal, lightDir), 0.);\n      }\n      col += vec3(0.05, 0.05, 0.05); // ambient\n    } else {\n      col = mix(vec3(0.3, 0.3, 1.0), vec3(1.0, 1.0, 1.0), pow(1.0 - clamp(uv.y, 0., 1.), 2.0));\n    }\n    \n    // tone mapping\n    // col = tonemap_uchimura2(col);\n    col = aces_approx(col);\n    \n    // gamma\n    col = pow(col, vec3(1.0 / 2.2));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}