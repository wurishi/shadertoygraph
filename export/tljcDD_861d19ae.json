{"ver":"0.1","info":{"id":"tljcDD","date":"1594441909","viewed":74,"name":"raycasting plane","username":"IXshader","description":"vector solution to plane implicit equation","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["plane"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n\n\n\nfloat iSphere(vec3 ro , vec3 rd, vec4 spr)\n{\n    vec3 rc = ro - spr.xyz;\n    float b = dot(rc,rd);\n    float c = dot(rc,rc) - spr.w*spr.w;\n    \n    float d = b*b - c;\n    \n    if( d > 0.0)\n    {\n\t  return d;\n    }\n\telse\n    {\n\t  return 0.0;\n    }\n\n}\n\n\n//Using\n//(X-C).n = 0; as the plane equation\n// where X in the point given by ro + rdt\n// C is the point on the plane\n\n\nfloat iPlane(vec3 ro, vec3 rd)\n{\n   //c is a point from the the plane passes\n    vec3 c = vec3(0.0,-1.0,0.0);\n    //I have considered normal to be perpendicular up\n    vec3 n = normalize(vec3(0.0,1.0,0.0));\n    \n    //C - P\n    //vector from ray origin to point on the plane\n    vec3 pc = c-ro;\n    float wn = dot(n,rd);\n    float t = dot(pc,n)/wn;\n    \n    if(t >= 0.0001)\n    {\n\t\treturn t;\n    }\n    else\n    {\n\t\treturn 0.0;\n    }\n    \n}\n\n//simple camera\n\nvoid camera(out vec3 ro, out vec3 rd, in vec2 uv)\n{\n\tfloat fov = 45.0 * PI/180.0;\n    float z = -1.0;\n    float side  = tan(fov/2.0)* 2.0;\n    \n    vec3 origin = vec3(0.0,0.0,1.0); //somewhere behind\n    \n    ro = vec3(z*uv.x*side ,-z*uv.y*side, z);\n    \n    rd = normalize(vec3(ro - origin));\n    \n    \n}\n\n\nvec3 map(vec3 ro, vec3 rd)\n{\n    vec4 sp = vec4(0.0,0.0,-2.0,0.5);\n    \n    \n    \n\tfloat t1 = iPlane(ro,rd);\n    float t2 = iSphere(ro,rd,sp);\n    \n    if(t1 > 0.0)\n    {\n        if(t2 > 0.0)\n        {\n            return vec3(1.0,0.0,0.0);\n        }\n        \n        return vec3(0.5,0.5,0.5);\n    }\n    else if(t2 > 0.0)\n    {\n        return vec3(1.0,0.0,0.0);\n    }\n   \n\n\treturn vec3(1.0);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = -1.0 + 2.0 * uv;\n    \n    uv.x *= iResolution.x/iResolution.y;\n    \n\t\n    // Time varying pixel color\n    vec3 col;\n    vec3 ro , rd;\n    camera(ro,rd,uv);\n\t\n    float t= iPlane(ro,rd);\n    \n    col = map(ro,rd);\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}