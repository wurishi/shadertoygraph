{"ver":"0.1","info":{"id":"fss3WH","date":"1615879782","viewed":79,"name":"Simple 2D Geometry","username":"zxuccv","description":"Just a playground I created to learn and play with simple geometries.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Author: Xuan Yang\n//Just a playground I created to learn and play with Shadertoy.\n//You can drag around the yellow polygon with mouse and modify it\n//  by edit the CustomEdgeCount, CustomRotateSpeed and/or CustomEdgeDistortion below.\n\n\n//Number of edges of the yellow polygon (at least 3)\n//Type: int\n#define CustomEdgeCount 8\n\n//Rotate speed of the yellow polygon\n//Type: float\n#define CustomRotateSpeed 1.\n\n//Amount of distortion along edges (recommended value [-0.3, 0.3])\n//Type: float\n#define CustomEdgeDistortion -0.05\n\n#define PI 3.14159265359\n\n//define shape: circle\nfloat circle(vec2 point, vec2 center, float radius, float smoothRate){\n    float range = length(point - center);\n    return smoothstep(range-smoothRate, range+smoothRate, radius);\n}\n\n//define shape: square\n//can also use polygon with edgeCount = 4 instead\nfloat square(vec2 point, vec2 center, float radius, float smoothRate){\n    //LB: Left Bottom of the square\n    //TR: Top Right of the square\n    vec2 lb = center-radius;\n    vec2 rt = center+radius;\n    float mask = smoothstep(point.x-smoothRate, point.x+smoothRate, rt.x);\n    mask *= smoothstep(point.y-smoothRate, point.y+smoothRate, rt.y);\n    mask *= smoothstep(lb.x-smoothRate, lb.x+smoothRate, point.x);\n    mask *= smoothstep(lb.y-smoothRate, lb.y+smoothRate, point.y);\n    return mask;\n}\n\n//define shape: polygon\n//edgeCount: number of edges of the polygon (at least 3)\n//distortion: add distortion along the edges\nfloat polygon(vec2 point, float rotateSpeed, vec2 center, float radius, int edgeCount, float distortion, float smoothRate){\n    if(edgeCount < 3){\n        edgeCount = 3;\n    }\n    //local vector\n    vec2 localVector = point - center;\n    //rotate angle\n    float rangle = iTime*-rotateSpeed;\n    //rotation matrix\n    mat2 rot = mat2(cos(rangle), -sin(rangle), sin(rangle),  cos(rangle));\n    localVector = rot*localVector;\n    \n    float range = length(localVector);\n    \n    //get angle between local vector and upward vector.\n    float angle = acos(dot(normalize(localVector), vec2(0, 1)));\n    \n    //angle of each trangle inside the polygon\n    float partAngle = 2.*PI/float(edgeCount);\n    \n    //length of altitude line of each triangle\n    float midRadius = radius * cos(partAngle/2.);\n    \n    //angle between local vector inside its triangle \n    float localAngle = mod(angle, partAngle);\n    \n    //angle between local vector and the altitude line of its triangle\n    float actualAngle = step(partAngle, localAngle) * ((partAngle / 2.) - localAngle);\n    actualAngle += step(localAngle, partAngle) * (localAngle - (partAngle / 2.));\n\n    //actual length from center to edge of the polygon along the point.\n    radius = midRadius / cos(actualAngle);\n    \n    //apply distortion to the edge\n    float distortionScale = 1. - abs(actualAngle/(partAngle/2.));\n    radius += distortion * distortionScale;\n    \n    \n    \n    return smoothstep(range-smoothRate, range+smoothRate, radius);\n}\n\n//Effect: fresnel\nfloat fresnel(vec2 point, vec2 center, float radius, float strangth){\n    float range = length(point - center);\n    return clamp((strangth-(radius - range)/radius), 0., 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Center and Normalized pixel coordinates (so y in range -1 to 1)\n    float screen_ratio = iResolution.x/iResolution.y;\n    vec2 uv = fragCoord * 2./iResolution.xy - 1.;\n    uv.x = uv.x * screen_ratio;\n    vec2 mousePos = iMouse.xy * 2./iResolution.xy - 1.;\n    mousePos.x = mousePos.x * screen_ratio;\n    \n    //init color\n    vec3 baseCol = vec3(1,1,1);\n    vec3 bgCol = vec3(0,0,0);\n    vec3 colR = vec3(1,0,0);\n    vec3 colG = vec3(0,1,0);\n    vec3 colB = vec3(0,0,1);\n    vec3 colCustom = vec3(1,1,0);\n    \n    //init speeds\n    float rotate_speed1 = 2.;\n    float rotate_speed2 = 2.;\n    float local_rotate_speed2 = 1.;\n    \n    //init center\n    \n    vec2 pentaPos[5]; //\n    float armAngle = 18./180.*PI;\n    float legAngle = 36./180.*PI;\n    pentaPos[0] = vec2(-cos(armAngle),sin(armAngle));\n    pentaPos[1] = vec2(cos(armAngle),sin(armAngle));\n    pentaPos[2] = vec2(-sin(legAngle),-cos(legAngle));\n    pentaPos[3] = vec2(0.,1.);\n    pentaPos[4] = vec2(sin(legAngle),-cos(legAngle));\n    int index = int(mod(iTime, 5.));\n    vec2 center1 = pentaPos[index] * sin(mod(iTime, 1.) * PI);\n    \n    vec2 default_center = vec2(0,0);\n    vec2 center2 = vec2(-0.5*cos(iTime*rotate_speed2), 0.5*cos(iTime*rotate_speed2 + PI/2.0));\n    \n    center2 *= sin(iTime * 1.);\n    \n    //init scale\n    float bgRadius = 1.5;\n    float radius0 = 0.5;\n    float radius1 = 0.4;\n    float radius2 = 0.3;\n    \n    //blend red along with green\n    float append = dot(normalize(uv.xy), center1)*0.2;\n    append += dot(normalize(uv.xy), mousePos)*0.1;\n\n    radius0 += append;\n    \n    //scale greed based on distance with red\n    radius1 -= length(center1 - default_center)/5.;\n    \n    rotate_speed2 += length(center2 - default_center)/80.;\n    \n    //init smoothRate\n    float defaultSmoothRate = 0.005;\n    float BGSmoothRate = min(length(uv.xy - center1)/2.,length(uv.xy - center2)/2.);\n    BGSmoothRate = min(BGSmoothRate, length(uv.xy - mousePos)/2.);\n    \n    //apply color\n    vec3 col = bgCol;\n    col += baseCol*(1.-circle(uv.xy, default_center, bgRadius, BGSmoothRate));\n    \n    float redMask = polygon(uv.xy, 0., default_center, radius0, 5, -0.1, defaultSmoothRate);\n    col += colR*redMask;\n    \n    float greenMask = circle(uv.xy, center1, radius1, defaultSmoothRate);\n    //greenMask *= fresnel(uv.xy, center1, radius1, 1.2);\n    col += colG*greenMask;\n    \n    float blueMask = polygon(uv.xy, rotate_speed2, center2, radius2, 3, 0.05,  defaultSmoothRate);\n    col += colB*blueMask;\n    \n    float clickMask = polygon(uv.xy, CustomRotateSpeed, mousePos, radius2, CustomEdgeCount, CustomEdgeDistortion, defaultSmoothRate);\n    clickMask *= fresnel(uv.xy, mousePos, radius2, 1.2);\n    col = clickMask * colCustom + (1.-clickMask) * col;\n    \n    \n    //output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}