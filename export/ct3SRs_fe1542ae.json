{"ver":"0.1","info":{"id":"ct3SRs","date":"1685691537","viewed":126,"name":"Exact SDF intersection","username":"lisyarus","description":"Computing the exact SDF of an intersection of two SDF's using the Newton-Raphson method. More or less works, but there are some artifacts still.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct sdf_sample\n{\n    float value;\n    vec2 gradient;\n};\n\nsdf_sample circle(vec2 p, vec2 center, float radius)\n{\n    vec2 r = p - center;\n    float l = length(r);\n    return sdf_sample(l - radius, r / l);\n}\n\nsdf_sample invert(sdf_sample s)\n{\n    return sdf_sample(-s.value, -s.gradient);\n}\n\nsdf_sample shape1(vec2 p)\n{\n    return circle(p, vec2(0.0, 0.0), 1.0);\n}\n\nsdf_sample shape2(vec2 p)\n{\n    return invert(circle(p, vec2(sin(iTime) * 1.5, 0.0), 0.9));\n}\n\nsdf_sample intersection(vec2 p)\n{\n    sdf_sample s1 = shape1(p);\n    sdf_sample s2 = shape2(p);\n    \n    if (s1.value > s2.value)\n        return s1;\n    else\n        return s2;\n}\n\nsdf_sample intersection_exact(vec2 p)\n{\n    vec2 q = p;\n    for (int i = 0; i < 256; ++i)\n    {\n        sdf_sample s = intersection(q);\n        \n        if (abs(s.value) < 1e-4) break;\n        \n        if (length(s.gradient) < 1e-4) break;\n        \n        // Newton's method for finding sdf(q) = 0\n        // Equivalent to `q -= s.value * s.gradient` if length(s.gradient) = 1\n        q -= s.value * s.gradient / dot(s.gradient, s.gradient);\n    }\n    \n    vec2 r = p - q;\n    float l = length(r);\n    \n    if (intersection(p).value > 0.0)\n        return sdf_sample(l, r / l);\n    else\n        return sdf_sample(-l, -r / l);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (fragCoord - iResolution.xy * 0.5) * 0.01;\n    vec2 m = (iMouse.xy - iResolution.xy * 0.5) * 0.01;\n        \n    sdf_sample s;\n    if (p.x > m.x)\n        s = intersection_exact(p);\n    else\n        s = intersection(p);\n    \n    vec3 color = s.value > 0.0 ? vec3(0.9,0.6,0.3) : vec3(0.5,0.85,1.0);\n    color *= (0.5 - 0.5 * cos(s.value * 40.0));\n    color = mix(color, vec3(1.0), exp(- 3000.0 * s.value * s.value));\n    color = mix(color, vec3(1.0, 0.0, 0.0), exp(- 3000.0 * (p.x - m.x) * (p.x - m.x)));\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}