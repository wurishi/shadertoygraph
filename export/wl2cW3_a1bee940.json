{"ver":"0.1","info":{"id":"wl2cW3","date":"1595595868","viewed":851,"name":"Canny Edge Detection","username":"Chindianese","description":"Built off sorbel detection. Generate clean outlines.","likes":9,"published":1,"flags":0,"usePreview":1,"tags":["edge","canny","sorbel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define channel iChannel0\n#define MERGE 0\n// sets RGB based on edge angle\n#define COLOR_ANGLE 0\n#define OUTLINE_COL 0.0f,0.5f,1.0f\n// enable / disable canny, uses only sorbel edge\n#define CANNY 1\n// STEP effects thickness\n#define STEP 1.0f\n// MIN outline brightness mask\n#define MIN 0.1f\n// MAX NOT USED\n#define MAX 0.5f \n#define INTENSITY 2.0f\n\n// GREENSCREEN requires MERGE\n#define GREENSCREEN 0\n#define GREENSCREEN_CHANNEL iChannel2\n#define threshold 0.55\n#define padding 0.01\n// CONSTANTS\nconst float M_PI = 3.14159265358979323846264338327950288;\nfloat GetBrightness(vec2 uv)\n{\n    vec4 color = texture(channel,uv);\n\treturn sqrt((color.x * color.x) + (color.y*color.y) + (color.z * color.z));   \n}\nvec2 Sorbel(vec2 uv)\n{\n    float stepx = STEP/iResolution[0];\n    float stepy = STEP/iResolution[1];\n\n\tvec2 uvTL = vec2(uv.x-stepx, uv.y+stepy);\n    vec2 uvML = vec2(uv.x-stepx, uv.y);\n    vec2 uvBL = vec2(uv.x-stepx, uv.y-stepy);\n    \n    vec2 uvTR = vec2(uv.x+stepx, uv.y+stepy);\n    vec2 uvMR = vec2(uv.x+stepx, uv.y);\n    vec2 uvBR = vec2(uv.x+stepx, uv.y-stepy);\n    \n    vec2 uvTM = vec2(uv.x, uv.y+stepy);\n    vec2 uvBM = vec2(uv.x, uv.y-stepy);\n    // Time varying pixel color\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float tl = GetBrightness(uvTL);\n    float ml = GetBrightness(uvML);\n    float bl = GetBrightness(uvBL);\n    \n    float tr = GetBrightness(uvTR);\n    float mr = GetBrightness(uvMR);\n    float br = GetBrightness(uvBR);\n    \n    float tm = GetBrightness(uvTM);\n    float bm = GetBrightness(uvBM);\n    \n    float gx = 0.0f;\n    gx += tl * -1.f;\n    gx += ml * -2.f;     \n    gx += bl * -1.f;\n    \n    gx += tr * 1.f;\n    gx += mr * 2.f;     \n    gx += br * 1.f;\n  \tfloat gy = 0.0f;\n    gy += tl * -1.f;\n    gy += tm * -2.f;     \n    gy += tr * -1.f;\n    \n    gy += bl * 1.f;\n    gy += bm * 2.f;     \n    gy += br * 1.f;\n    \n    return vec2(gx,gy);\n}\nfloat GetStrength(vec2 vg)\n{\n   \n    float gx = vg.x;\n    float gy = vg.y;\n    \n    float g = (gx*gx+gy*gy);\n    return g;\n}\nfloat GetAngle(vec2 vg)\n{\n    float angle = atan(vg.y,vg.x);\n\treturn angle;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float stepx = STEP/iResolution[0];\n    float stepy = STEP/iResolution[1];  \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 sorbeA = Sorbel(uv);\n   \tfloat sorbelA_Strength = GetStrength(sorbeA);\n    float angle = GetAngle(sorbeA);\n    #if CANNY\n    vec2 dir;\n  \tdir.x = cos(angle)*stepx;\n\tdir.y = sin(angle)*stepy;\n    vec2 sorbelB = Sorbel(uv + dir);\n    vec2 sorbelC = Sorbel(uv - dir);\n    \n    float sorbelB_Strength = GetStrength(sorbelB);    \n    float sorbelC_Strength = GetStrength(sorbelC);\n\n    if(sorbelA_Strength < sorbelB_Strength || sorbelA_Strength < sorbelC_Strength )\n    \tsorbelA_Strength = 0.0f;\n    #endif\n    // Treshold\n    if(sorbelA_Strength < MIN)\n        sorbelA_Strength = 0.0f;\n    \n    vec4 col = vec4(0,0,0,0);\n    #if MERGE\n    #if GREENSCREEN\n    vec4 greenScreen = vec4(0.,1.,0.,1.);\n    vec4 sourceColor = texture(channel, uv);\n    \n    vec3 diff = sourceColor.xyz - greenScreen.xyz;\n    float fac = smoothstep(threshold-padding,threshold+padding, dot(diff,diff));\n    \n    col += mix(sourceColor, texture(GREENSCREEN_CHANNEL, uv), 1.-fac);\n\t #else\n    col += texture(channel, uv);\n       #endif\n    #endif\n    \n\t#if COLOR_ANGLE\n     vec3 outlineCol = vec3(sin(angle), sin(angle + 2.0f*M_PI/3.0f),sin(angle + 2.f*M_PI/3.0f * 2.0f));\n\t#else\n       vec3 outlineCol = vec3(OUTLINE_COL);\n#endif\n    col += vec4(outlineCol*sorbelA_Strength * INTENSITY, 1.0);\n    // Output to screen\n    // col = vec4(angle,angle,angle,1.0f);\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}