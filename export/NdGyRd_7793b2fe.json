{"ver":"0.1","info":{"id":"NdGyRd","date":"1661464944","viewed":73,"name":"circle - art of code tutorial","username":"zdgra","description":" ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["circle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /*\n        fragCoord = pixel coordinates, or fragment coordinates, as a vec2\n        the canvas is a plane, with origin (0, 0) in the bottom-left\n        and (iResolution.x, iResolution.y) in the top-right\n        iResolution.xy = (iResolution.x, iResolution.y)\n        \n        hence, \"vec2 uv = fragCoord/iResolution.xy\" means\n            fragCoord.x/iResolution.x\n            fragCoord.x/iResolution.x\n        \n        what this does is normalize the pixel coordinates to be [0, 1] on both axes\n        \n        ---\n        \n        \"uv -= 0.5\" means (uv.x, uv.y) = (uv.x - 0.5, uv.y - 0.5)\n        this brings pixel coordinates to be [-0.5, 0.5] on both axes\n        \n        ---\n        \n        we notice that the resolution is longer in the x-direction than the y-direction\n        that's why at this point, we have more of an ellipse than a circle\n        hence, we must account for our aspect ratio\n        \n        say we have an aspect ratio of 2:1, or a width twice as long as the height\n        say our uv.x has a range of [-1, 1]\n        with an aspect ratio of 2:1, we will have an ellipse twice as wide as it is high\n        what we do to make our ellipse have the same width and height is\n        multiply uv.x by 2 so that it has a range of [-2, 2]\n        this way, uv.x has a wider range, which squishes the circle's width in half\n        \n        similarly, to normalize for aspect ratio, we multiply uv.x by the aspect ratio\n        \n        ---\n        \n        now our uv coordinates are zero-centered and normalized for aspect ratio\n    */\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    /*\n        d = distance from the origin\n            since our uv coordinates are zero-centered,\n            this is equivalent to length(uv)\n        \n        r = radius of the circle\n    */\n    float d = length(uv);\n    float r = 0.3; \n    \n    /*\n        s = smoothing width\n        \n        smoothstep(threshold1, threshold2, input)\n        \n        if threshold1 < threshold2\n            if input <= threshold1, return 0.0\n            if input >= threshold2, return 1.0\n            otherwise, perform smoothing (hermite interpolation) on input\n        \n        if threshold1 > threshold2\n            if input >= threshold1, return 0.0\n            if input <= threshold2, return 1.0\n            \n        here, we have threshold1 = r, threshold2 = r-s\n        we want all distances greater than or equal to r to be black, 0.0\n        we want all distances less than or equal to r-s to be white, 1.0\n        we want all distances between r-s and r to be smoothed\n        \n        here, s is the smoothing width\n        the larger s is, the longer smoothing happens\n    */\n    \n    float s = 0.01;\n    float c = smoothstep(r, r-s, d);\n    \n    /*\n        this is a natural way to make a circle\n        if the distance from the origin\n    \n    if (d < 0.3)\n        c = 1.0;\n    else\n        c = 0.0;\n    */\n    \n    /*\n        finally, vec3(c) = (c, c, c)\n        so vec4(vec3(c), 1.0) = (c, c, c, 1.0),\n        where c gives the uniform color output for RGB\n        the fourth parameter in fragColor represents the alpha channel,\n        or the opacity level\n    */\n    fragColor = vec4(vec3(c), 1.0);\n}","name":"Image","description":"","type":"image"}]}