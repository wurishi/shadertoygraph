{"ver":"0.1","info":{"id":"WsVSRK","date":"1574457224","viewed":249,"name":"debug parallax","username":"nabr","description":"still digging into parallax mapping\n\nmouseclick+drag == rotate","likes":6,"published":1,"flags":8,"usePreview":0,"tags":["raytracing","parallax","debug","triangel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// nabr\n// https://www.shadertoy.com/view/WsVSRK\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://creativecommons.org/licenses/by-nc-sa/3.0/\n\n// -----------------------------------------------------\n// Parallax mapping by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/4lSGRh\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n// -----------------------------------------------------\n\n\n\n#define pi (acos(-1.))\n#define R2d(_p,_a)(_p=cos(_a)*_p+sin(_a)*vec2(_p.y, -_p.x))\n#define R3d(_a)(mat3(1,0,0,0,cos(_a.y),-sin(_a.y),0,sin(_a.y),cos(_a.y))*mat3(cos(_a.x),0,sin(_a.x),0,1,0,-sin(_a.x),0,cos(_a.x)))\n\nfloat tex(in vec3 px)\n{\n    \t#define S(_p)(smoothstep(0., 1., fract(_p)))\n    \tfloat z = 1., f = 0., k = 11.;\n        for (int j = 0; j < 2; j++)\n        {\n            \n            vec3 p = px;\n            p*=pi*.5; \n            for (float i = .5; i > 0.; i -= .152)\n            {\n                float u = floor(p).x + floor(p).y * k;\n                vec4 v = vec4(u, u + 1., u + k, 1. + u + k);\n                v = .5+fract(.50707+fract(1.23456 * v) * v * .369159);\n                f += i * mix(mix(v.x, v.y, S(fract(p.x))),\n                             mix(v.z, v.w, S(fract(p.x))),\n                             S(fract(p.y)));\n                // rotate to 3d\n                p.yz *= mat2(1, 1, -1, .001);\n                p.xz *= mat2(2, 1, .001, .001);\n                p.xy *= mat2(0, 1, -1,.001);\n                p = p + f * f;\n            }\n            px*= 7.;\n            z *= -1.001;\n            f /= z;\n        }\n        return clamp(f * f * 2., 0., 1.)*2.-1.;\n}\n\nvec3 prlpos(in vec3 p, in vec3 n, in vec3 rd)\n{\n    const float PARALLAX_SCALE = .255, OFFSET_SCALE = 1.002;\n    vec3 tgt = (n * dot(rd, n) - rd); // Optimized\n    tgt /= (abs(dot(tgt, rd))) + OFFSET_SCALE;\n    p += (tgt * tex(p) * PARALLAX_SCALE);\n    return p;\n}\n\nvec3 bump(in vec3 p, in vec3 n, in float ds)\n{\n    const float BUMP_STRENGTH = .025, BUMP_WIDTH = 0.0214;\n    vec2 e = vec2(BUMP_WIDTH * sqrt(ds) * 0.5, 0);\n    #define btex(_p)(tex(_p)+tex(_p)*1.0125)\n    float n0 = btex(p);\n    vec3 d = vec3(btex(p + e.xyy) - n0, btex(p + e.yxy) - n0, btex(p + e.yyx) - n0) / e.x;\n    vec3 tgd = d - n * dot(n, d);\n    n = normalize(n - tgd * BUMP_STRENGTH * 8. / (ds));\n    return n;\n}\n/// ----- tex2 raymarch\nfloat map(in vec3 p)\n{\n    \n\tvec3 q = p;\n    //R2d(q.xy, iTime);R2d(q.zy, iTime); \n    q.z-=2.*sin(iTime);\n    #define mk(_v,_m)(pow(dot(pow(_v,vec3(_m)),vec3(1)), 1./_m))\n\tfloat t =  mk(abs(q), max(1.,mod(floor(4.*iTime), 5.)) ) - 1.;\n\tt = min(t, 1.5+dot(p, vec3(0, 1, 0)) + (sin(p.x * .55) * sin(3.*iTime-.5*p.z)));\n    return t; \n}\n\n\nvec3 mImage( out vec3 O, in vec2 fragCoord )\n{\n    vec3 c = vec3(1);\n    vec2 p =fragCoord; //\n\tif (abs(p.y) > .6){return vec3(.1, .1, 0.2);}\n    vec3 o = vec3(0.001, 0.001, 5.),\n         d = normalize(vec3(p, -1.));\n    if(mod(iTime,6.)<2.)\n    {\n    vec2 ang = vec2(iTime*.25); //iMouse.xy/iResolution.xy;\n\tR2d(o.xy, ang.x*6.2831);R2d(d.xy, ang.x*6.2831);\n\tR2d(o.yz, ang.y*6.2831);R2d(d.yz, ang.y*6.2831);\n    }\n    float t = 0.;\n\tfloat sam = 1./64.;\n    for (float i = 0.; (i <= 1.); i+=sam)\n    {\n    \tfloat h = abs(map((o + d * t)))*.7;\n        if(abs(h) < .001 || t > 100.0) break;\n        t += h;\n    }\n    if(abs(t)<10.)\n    {\n    vec3 pos = (o + d * t);\n    vec2 e = vec2(-.001, .001);\n    vec3 nor = normalize(e.yxx * map(pos + e.yxx) + e.xxy * map(pos  + e.xxy) + e.xyx * map(pos  + e.xyx)+ e.yyy * map(pos  + e.yyy));\n    pos = prlpos(pos, nor, d);\n    float ds = distance(o, pos);\n    nor = bump(pos, nor, ds);\n\n    vec3 ligt = normalize(-15.*d);\n    float dif = dot(nor, ligt);\n    float bac = dot(nor, ligt);\n    float spe = pow(clamp(dot(reflect(d, nor), ligt), 0.0, 1.0), 8.);\n    float fre = pow(clamp(1.001 + dot(nor, d), 0.0, 1.0), 32.0);\n    vec3 brdf = vec3(.3);\n    brdf += bac * vec3(.5);\n    brdf += dif * .5;\n\n    float tx = tex(pos)*2.5;\n\n    c = cos(vec3(1.8,2.4,2.7) + tx * 1.2 - .141) * 0.35 + 0.53;\n    c = c * brdf + spe * .8 / sqrt(t*.1) + .5 * fre;\n\tO.xyz = c;\n    }\n    else\n    {\n    c = mix(c.xyz,vec3(0.24,0.36,0.4), clamp(exp(t * 0.5 - 5.), 0., 1.));\n    O.xyz = c;\n    }\n    return O; \n}\n\n// --------- raytrace\n\nstruct Ray{vec3 o,d;};\nstruct Tri{vec3 p0,p1,p2;};\n// wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm#C++_Implementation\n// not fully developed fits this working scenario fair enough   \nbool isTriangle(in Tri tri,in Ray r, out float t, out vec3 n)\n{\n    vec3 e0 = tri.p0 - tri.p2, e1 = tri.p1 - tri.p2;\n    vec3 r0 = cross(r.d, e1);\n    float d = dot(e0, r0);\n    if (abs(d) < 1e-3)\n        return false;\n    float ivd = 1. / d;\n    vec3 s = r.o - tri.p2;\n    float b0 = dot(s, r0) * ivd;\n    if ((b0 < 0.) || (b0 > 1.))\n        return false;\n    vec3 r2 = cross(s, e0);\n    float b1 = dot(r.d, r2) * ivd;\n    if ((b1 < 0.) || ((b0 + b1) > 1.))\n        return false;\n    t = dot(e1, r2) * ivd;\n    n = normalize(cross((tri.p0 - tri.p2), (tri.p1 - tri.p2)));\n    return t > 1e-3;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // -------- camera\n    vec2 st = 2.*(fragCoord.xy/iResolution.xy)-1.;\n    //dither https://www.shadertoy.com/view/3tj3DW\n    vec3 dthr = 31.*fract(sin(st.x*vec3(13,1,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n    \n    vec3 o = vec3(.001, .001, 1),\n         g = normalize(- o),\n         u = normalize(cross(g, vec3(0, 1, 0))),\n         v = normalize(cross(u, g));\n\n    float ang = 95.0;\n    u = u * tan(radians(ang * 0.5));\n    v = v * tan(radians(ang * 0.5)) / max(iResolution.x / iResolution.y,iResolution.y / iResolution.x);\n\n    vec3 d = normalize(g - st.x * u - st.y * v);\n\n    // -------- quad\n    mat4x3 pp = mat4x3(\n        -.98, -.5, 0, \n        .98, -.5, 0, \n        .98, .5, 0, \n        -.98, .5, 0);\n    \n    Tri tri0 = Tri(pp[0], pp[1], pp[2]), \n        tri1 = Tri(pp[0], pp[2], pp[3]);\n    \n    // quad texture\n    mat4x3 pp1 = mat4x3(\n        -.98, -.5, -.125,\n        .98, -.5, -.125,\n        .98, .5, -.125,\n        -.98, .5,-.125);\n    \n    Tri tri2 = Tri(pp1[0], pp1[1], pp1[2]), \n        tri3 = Tri(pp1[0], pp1[2], pp1[3]);\n\n    // -------- mouse rotation\n    vec2 mous = (iMouse.xy / iResolution.xy) * 2. * pi - pi;\n    if (iMouse.z > .001)\n    {\n        d = R3d(mous) * d;\n        o = R3d(mous) * o;\n    }\n\n    Ray r = Ray(o, d);\n    vec3 c = //vec3(0.24,0.36,0.4);//bg\n    \t\t dthr+vec3(.757);\n    // -------- raytrace\n    float t = 0.;\n    vec3 nor = vec3(0);\n     \n   if (isTriangle(tri0, r, t, nor) || isTriangle(tri1, r, t, nor))\n    {\n        vec3 pos = (o + d * t);\n     \n        \n    pos = prlpos(pos, nor, d);\n    float ds = distance(o, pos);\n    nor = bump(pos, nor, ds);\n\n    vec3 ligt = normalize(vec3(5, -5, 10.));\n    float dif = clamp(dot(nor, ligt), 0.0, 1.0);\n    float bac = clamp(dot(nor, ligt), 0.0, 1.0);\n    float spe = pow(clamp(dot(reflect(d, nor), ligt), 0.0, 1.0), 4.);\n    float fre = pow(clamp(1.001 + dot(nor, d), 0.0, 1.0), 32.0);\n    vec3 brdf =vec3(0.125);\n    brdf += bac * vec3(.5);\n    brdf += dif * .5;\n    c = cos(vec3(0,1,.5*pi) +  (tex(pos)*2.)) * .35 + .5;\n    c *= brdf + spe * .8 / sqrt(t) + .5 * fre;\n    //fragColor.xyz =  c ;\n    }\n     \n    if(isTriangle(tri2, r, t, nor) || isTriangle(tri3, r, t, nor))\n    {\n        float mm = sin(.5*iTime)*.5+.5;\n        if(iMouse.z>.001)mm=0.015;\n        //\n       vec2 uv = ((-(o + t * d) - nor).xy  * vec2(.5) + .5);\n       c =mix(c,min(.5/length(sin(.5-nor.z*iTime)*d.xy)+c,\n                     2.*texture( iChannel0, uv, .5 ).xyz), (1.25*mm) );\n       c =mix(c,min(.7/length(sin(nor.z+.85*iTime)*d.xy)-c.zyx, mImage(c, st)), mm );\n     }\n\t\n    // text\n    vec2 _u = st; vec3 text = vec3(.009);\n\t#define char(p, C)(((p.x < 0. || p.x > 1. || p.y < 0. || p.y > 1.))? vec4(0, 0, 0, 1e5) : textureGrad(iChannel3, p / 16. + fract(vec2(C, 15 - C / 16) / 16.), dFdx(p / 16.), dFdy(p / 16.))).xyz\n    int msg[] = int[](117,115,101,32,97,116,32,121,111,117,114,32,111,119,110,32,114,105,115,107 );\n    for (int i = 0; i < msg.length(); ++i)\n    {\n        text.yx += char(8. * vec2(_u.x+.65, _u.y), msg[i]).x;\n        _u.x -= .065;\n        if(iMouse.z>.001) text = vec3(0); \n    }\n    \n    // -------- shade\n    fragColor.rgb = max(c,mix(1.2*text, vec3(0), sin(6.*iTime)*.5+.5));\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 mainSound( in int samp,float time)\n{\n    int block = int((iBlockOffset+0.5)*iSampleRate/(512.*512.));\n    int s = 512*512*block + 512*int(gl_FragCoord.y) + int(gl_FragCoord.x);\n    return mSound(s);\n}\n","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"// nabr\n// https://www.shadertoy.com/view/WsVSRK\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://creativecommons.org/licenses/by-nc-sa/3.0/\n\n\nfloat intfract(int s,float n)\n{\n    //Explanation and copyright : shadertoy.com/view/4ltfRN\n    int sn=int(n),a=s%sn,b=(s/sn);\n    const float MAXF=float(uint(-1))+1.;\n    return fract((float(a)/n)+float((uint(b)*uint(MAXF*float(sn)/n)))/MAXF);\n}\n\n#define rndp(_rng,_maxval)(1315313u%(_rng+1u))%_maxval\n#define tau (8.*atan(1.))\nvec2 mSound(int samp)\n{\n    const int l = 1, a = 2, _ = 999;\n    const int[] pseq = int[](0, _, 1, 2, \n                             3, _, 4, 5, \n                             5, _, 6, 7,\n                             _, _, _, \n                             2, 4, 5),\n        \t\tnseq = int[](a, l, l, \n                             l, l, a, \n                             l, l, _, \n                             a, l, l, \n                             a, a, a, \n                             l, l, l);\n    float an[] = float[](195., 293., 438.,231., 392., 292., 153., 172.);\n    float bn[] = float[](349.23, 349.23,466.16, 349.23, 440., 349.23, 523.25, 0.);\n    float clkbase = 2.; // bpm\n    int clk = int(iSampleRate * (clkbase / 8.));\n    const int len = pseq.length();\n    //-------- is: \"index (of) sequence\"\n    int is = samp / clk;\n    for (; is % len > 0 && nseq[is % len] == a; is--){}\n    int nl = 1;\n    for (; (is + nl) < len && nseq[(is + nl)] == a; nl++){}\n    int synsamp = samp - is * clk;\n    float syntime = float(synsamp) / iSampleRate, \n          notedur = float(nl * clk) / iSampleRate;\n    int pc = pseq[is % len];\n    float f0 = float(an[pc]);\n    float f1 = float(bn[pc - max(1, int(rndp(uint(samp / int(iSampleRate * 1.)), 7u)))]);\n    float dur = exp(-syntime / notedur * 2.) * (1. - exp(-1. + syntime / notedur));\n    \n    // kick // spring rev (wip)\n    float gt = mod(2.*syntime, .25);\n    float kk = (sin(1800. * gt * exp(-8. * gt)) \n                    + sin(1200. * gt * exp(-2. * gt)))\n            \t\t* float(int[](1, 0, 0, 0, 1, 1)[uint(1. * syntime) % 6u]);\n    kk*=dur;\n    \n    float ly0 = sin(tau * intfract(synsamp, 2.*iSampleRate / f0)) * dur;\n    float ly1 = sin(tau * intfract(synsamp, 2.*iSampleRate / f1)) * dur;\n    \n    // moog\n    float m0 = .2 * (mod(3. + syntime * f0, 2.)) \n            + .1 * (mod(syntime * f1, 1.));\n    float m1 = .1 * (mod(6. + syntime * f0, 3.))\n        \t\t+ .2 * (mod(12.+syntime * f1, 2.));\n    \n    m0 +=mix(kk,m0, .3);\n    m1 +=mix(kk,m1, .2);\n    \n    // -------- out\n    /*return \n        +.7*(vec2(mix(m0, m1, sin(syntime * 1.001) * .5 + .5),\n              mix(m1, m0, sin(syntime * 2.002) * .4 + .4)) + (.5 * vec2(ly0, ly1)));\n    */\n    return .707 * (.3 * vec2( m0, m1 ) ) + (.15 * vec2(ly0, ly1)) ;\n}","name":"Common","description":"","type":"common"}]}