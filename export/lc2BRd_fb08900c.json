{"ver":"0.1","info":{"id":"lc2BRd","date":"1727502739","viewed":27,"name":"Benimod's Second Shader","username":"Benimod","description":"My second shader! I'm trying to learn realistic lighting and materials for this one.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 1000\n#define MIN_DIST 0.001\n#define MAX_DIST 100.\n\n#define PI = 3.14159\n\nvec2 map(vec3 p){\n    float groundDist = p.y + 1.;\n    vec3 spherePos = vec3(0., 0, 1.);\n    float sphereRadius = 1.;\n    float sphereDist = length(p - spherePos) - sphereRadius;\n    \n    vec3 boxPos = vec3(-1.4, 0., 1.);\n    vec3 boxDims = vec3(1., 1., 1.);\n    float boxDist = sdRoundBox(p - boxPos, boxDims, 0.5);\n   \n    vec3 hexPos = vec3(1.5, 0., 1.);\n    vec2 hexDims = vec2(1.);\n    float hexDist = sdHexPrism(p - hexPos, hexDims);\n    \n    vec3 reflectSpherePos = vec3(1., 0., -2.);\n    float reflectSphereRadius = 1.;\n    float reflectSphereDist = length(p - reflectSpherePos) - reflectSphereRadius;\n    \n    float dist = min(min(min(min(min(sphereDist, groundDist), boxDist), hexDist), reflectSphereDist), reflectSphereDist);\n\n    float res;\n    \n    if (dist == sphereDist) res = 1.;\n    else if (dist == boxDist) res = 2.;\n    else if (dist == hexDist) res = 3.;\n    else if (dist == groundDist) res = 0.;\n    else if (dist == reflectSphereDist) res = 4.;\n   \n    float outdist = min(min(smin(smin(min(sphereDist, reflectSphereDist), boxDist, 0.1).x, hexDist, 0.1).x, reflectSphereDist), groundDist);\n    //float outdist = min(min(smin(smin(smin(sphereDist, groundDist, 0.1).x, boxDist, 0.1).x, hexDist, 0.1).x, reflectSphereDist), reflectSphereDist);\n    \n    return vec2(outdist, res);\n}\n\n\nvec2 raymarch(vec3 orig, vec3 dir){\n    vec2 mapping;\n    float d = 0.;\n    vec3 p = orig;\n    for (int i = 0; i < MAX_STEPS; ++i){\n        p = orig + d * dir;\n        mapping = map(p);\n        float dist = mapping.x;\n        if (dist < MIN_DIST) break;\n        d += dist;\n        if (d > MAX_DIST){\n            mapping.y = 999.;\n            break;\n        }\n        \n    }\n    \n    return vec2(d, mapping.y);\n}\n\nvec3 getNormal(vec3 p){\n    float delta = 0.001;\n    float yDistance = map(p + vec3(0, delta, 0)).x - map(p - vec3(0, delta, 0)).x;\n    float xDistance = map(p + vec3(delta, 0, 0)).x - map(p - vec3(delta, 0, 0)).x;\n    float zDistance = map(p + vec3(0, 0, delta)).x - map(p - vec3(0, 0, delta)).x;\n    \n    return normalize(vec3(xDistance, yDistance, zDistance));\n}\n\nfloat getShadow(vec3 p, vec3 sun_dir, vec3 normal, float spread){\n    if (raymarch(p + normal * MIN_DIST, sun_dir).x >= MAX_DIST) return 1.;\n    return 0.;\n}\n\nvec3 getReflectColor(vec3 p, vec3 cam, float objId){\n    float dist = length(p - cam);\n    vec3 sun_dir = lights[0].p;\n    if (objId == 999.) {\n        return vec3(0.33, 0.79, 1);\n    }\n    vec3 normal = getNormal(p);\n    vec3 base = vec3(0.);\n    if (objId == 1.) base = vec3(0.1, 0.01, 0.01);\n    else if (objId == 2.) base = vec3(0., 0.25, 0.);\n    else if (objId == 3.) base = vec3(0.05, 0.05, 0.4);\n    else if (objId == 0.) base = vec3(0.07, 0.25, 0.02);\n    else if (objId == 4.) base = vec3(0.2);\n\n    float sun_shadow = getShadow(p, sun_dir, normal, 0.05);\n    vec3 reflect_dir = normalize(2. * dot(sun_dir, normal) * normal - sun_dir);\n    vec3 look_dir = normalize(cam - p);\n    vec3 is = lights[0].specular;\n    vec3 id = lights[0].diffuse;\n    vec3 ia = vec3(0.2, 0.3, 0.5) * 0.3; \n    vec3 ks = vec3(1);\n    vec3 kd = normalize(base);\n    vec3 ka = normalize(base);\n    float shine = 20.;\n    vec3 color = ka * ia + sun_shadow * kd * clamp(dot(sun_dir, normal), 0., 1.)*id + sun_shadow * ks*pow(clamp(dot(reflect_dir, look_dir), 0., 1.),shine) * is;\n    color = pow(color, vec3(0.4545));\n    color = mix(color, vec3(0.33, 0.79, 1), pow(dist / MAX_DIST, 3.));\n    return color;\n}\n\nvec3 getColor(vec3 p, vec3 cam, float objId) {\n    float dist = length(p - cam);\n    vec3 sun_dir = lights[0].p;\n    if (objId == 999.) {\n        return vec3(0.33, 0.79, 1) + pow(clamp(dot(normalize(p-cam),sun_dir), 0., 1.), 200.);\n\n    }\n    \n    vec3 normal = getNormal(p);\n    vec3 base = baseColor(objId, p);\n    vec3 look_dir = normalize(cam - p);\n    vec3 look_reflect_dir = normalize(2. * dot(look_dir, normal) * normal - look_dir);\n\n    \n    float sun_shadow = getShadow(p, sun_dir, normal, 0.05);\n    vec3 reflect_dir = normalize(2. * dot(sun_dir, normal) * normal - sun_dir);\n    \n    vec3 ia = vec3(0.2, 0.3, 0.5) * 0.3;\n    vec3 ks = vec3(1);\n    vec3 kd = base;\n    vec3 ka = base;\n    float shine = 20.;\n    float reflectivity = 0.;\n    vec3 reflection = vec3(0.);\n    \n    if (objId == 0.){\n        vec2 march = raymarch(p + normal * MIN_DIST, look_reflect_dir);\n        float d = march.x;\n        vec3 reflectPos = p + look_reflect_dir * d;\n        reflection = getReflectColor(reflectPos, p, march.y);\n        kd = base;\n        ka = base;\n        reflectivity = 1.;\n        ks = vec3(2);\n        kd *= 0.8;\n        shine = 20.;\n    }\n    \n    vec3 is = lights[0].specular;\n    vec3 id = lights[0].diffuse;\n    \n    vec3 color = ka * ia + sun_shadow * kd * clamp(dot(sun_dir, normal), 0., 1.)*id + sun_shadow * ks*pow(clamp(dot(reflect_dir, look_dir), 0., 1.),shine) * is;\n    color += reflection * 0.15;\n    \n    color = pow(color, vec3(0.4545));\n    color = mix(color, vec3(0.33, 0.79, 1) + pow(clamp(dot(normalize(p-cam),sun_dir), 0., 1.), 200.), pow(dist / MAX_DIST, 3.) );\n   \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord * 2. - iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy * 2. - iResolution.xy) / iResolution.y;\n    \n    // Camera\n    vec3 cam = vec3(0., 1, -5.);\n    vec3 dir = normalize(vec3(uv, 1));\n    \n    // Camera rotation\n    cam.xz *= rot2d(-mouse.x * 5.);\n    dir.xz *= rot2d(-mouse.x * 5.);\n    \n    // Rendering\n    vec2 march = raymarch(cam, dir);\n    float d = march.x;\n    vec3 p = cam + dir * d;\n    vec3 color = getColor(p, cam, march.y);\n    \n    // Output to screen\n    fragColor = vec4(color, 1.);\n\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// DATA\nstruct Light {\n    // If isPoint is true, this is a point light: p refers to position\n    // Otherwise, this is a directional light: p is the light direction\n    vec3 p;\n    bool isPoint;\n    \n    vec3 diffuse;\n    vec3 specular;\n};\nLight lights[1] = Light[](\n    Light(\n        normalize(vec3(0.8, 0.4, 0.7)),\n        false,\n        vec3(0.4, 0.3, 0.2) * 5.,\n        vec3(0.3))\n);\n\n\n// BASIC HELPERS\nmat2 rot2d(float angle){\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nvec2 smin( float a, float b, float k )\n{\n    float h = 1.0 - min( abs(a-b)/(4.0*k), 1.0 );\n    float w = h*h;\n    float m = w*0.5;\n    float s = w*k;\n    return (a<b) ? vec2(a-s,m) : vec2(b-s,1.0-m);\n}\nfloat between (float a, float b, float c){\n    // If c is a, return 0.\n    // If c is b, return 1.\n    // If c is between a and b, return a number proportionally between 0 and 1.\n    c = c - a;\n    b = b - a;\n    // Now we have some c between 0 and b, still proportional!\n    c = c / b;\n    // Done!\n    return c;\n}\n\n\n\n// SDFs\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b + r;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\n\n\n// TEXTURES\nvec3 baseColor (float id, vec3 p){\n    vec3 res = vec3(0.5);\n    \n    if (id == 0.){\n        vec3 q = mod(p, 20.);\n        if ((q.x > 10. && q.z > 10.) || q.x <= 10. && q.z <= 10.) res = normalize(vec3(255, 74, 61));\n        else res = normalize(vec3(166, 76, 76)); \n    }\n    else if (id == 1.) res = normalize(vec3(0.1, 0.01, 0.01));\n    else if (id == 2.) res = normalize(vec3(0., 0.25, 0.));\n    else if (id == 3.) res = normalize(vec3(0.05, 0.05, 0.4));\n    else if (id == 4.) res = normalize(vec3(88, 176, 63));\n    \n\n    \n    return res;\n}","name":"Common","description":"","type":"common"}]}