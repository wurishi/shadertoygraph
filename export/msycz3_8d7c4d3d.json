{"ver":"0.1","info":{"id":"msycz3","date":"1696788218","viewed":48,"name":"Noise (Worley and Perlin)","username":"akoylasar","description":"Worley and Perlin noise (in 1D and 2D). Another reference for when I forget things. ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise","perlin","worley","1d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DEBUG 0\n#define hSqrt2 .707106781186548\n                       \n// From https://www.shadertoy.com/view/4djSRW by Dave_Hoskins\nfloat hash11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nfloat worley1(float p, float freq) {\n    float q = fract(p);\n    p = floor(p);\n    float d = 1e7;\n    for (float i = -1.; i <= 1.; i++) {\n        float r = hash11(mod(i + p , freq));\n#if DEBUG\n        r = mix(r, 0., .5 + .5 * sin(iTime));\n#endif\n        d = min(d, abs(q - (i + r)));\n    }\n    return d;\n}\n\nfloat worley2(vec2 p, float freq) {\n    vec2 q = floor(p);\n    vec2 f = p - q;\n    float d = 1e7;\n    for (float i = -1.; i <= 1.; i++) {\n        for (float j = -1.; j <= 1.; j++) {\n            vec2 grid = vec2(i, j);\n            vec2 r = hash22(mod(grid + q , freq));\n#if DEBUG\n            r = mix(r, vec2(0.), .5 + .5 * sin(iTime));\n#endif\n            d = min(d, distance(f, grid + r));\n        }\n    }\n    return d;\n}\n\nvec3 plotWorley1(vec2 p, float freq) {\n    float n = worley1(p.x, freq);\n    float f = smoothstep(0.01, .05, abs(n - p.y));\n    vec3 col = mix(vec3(.9, 0., 0.), vec3(n), f);\n    return col;\n}\n\nfloat gradient(float v) {\n    return hash11(v) * 2. - 1.;\n}\n\nvec2 gradient(vec2 v) {\n    vec2 w = hash22(v) * 2. - 1.;\n    return normalize(w);\n}\n\n// Can also use any other e.g. quintic.\nfloat hermite(float x) {\n    float x2 = x * x;\n    return 3. * x2 - 2. * x2 * x;\n}\n\nvec2 hermite(vec2 x) {\n    vec2 x2 = x * x;\n    return 3. * x2 - 2. * x2 * x;\n}\n\nfloat perlin1(float p, float freq) {\n    float q = floor(p);\n    float f = p - q;\n    float g0 = gradient(mod(q, freq));\n    float g1 = gradient(mod(q + 1., freq));\n#if DEBUG\n    float u = .5 + .5 * sin(iTime);\n    g0 = mix(g0, 1., u);\n    g1 = mix(g1, 1., u);\n#endif\n    float n0 = g0 * f;\n    float n1 = g1 * (f - 1.);\n    return mix(n0, n1, hermite(f));\n}\n\nfloat perlin2(vec2 p, float freq) {\n    vec2 q = floor(p);\n    vec2 f = p - q;\n    \n    // Random gradients in production can have more quality.\n    vec2 g00 = gradient(mod(q, freq));\n    vec2 g10 = gradient(mod(q + vec2(1., 0.), freq));\n    vec2 g01 = gradient(mod(q + vec2(0., 1.), freq));\n    vec2 g11 = gradient(mod(q + vec2(1., 1.), freq));\n#if DEBUG\n    vec2 u = vec2(.5 + .5 * sin(iTime));\n    g00 = mix(g00, vec2(hSqrt2), u);\n    g10 = mix(g10, vec2(hSqrt2), u);\n    g01 = mix(g01, vec2(hSqrt2), u);\n    g11 = mix(g11, vec2(hSqrt2), u);\n#endif  \n    float n00 = dot(g00, f);\n    float n10 = dot(g10, f + vec2(-1., 0.));\n    float n01 = dot(g01, f + vec2(0., -1.));\n    float n11 = dot(g11, f + vec2(-1., -1.));\n    \n    vec2 t = hermite(f);\n    float nx0 = mix(n00, n10, t.x);\n    float nx1 = mix(n01, n11, t.x);\n    float nxy = mix(nx0, nx1, t.y);\n\n    return nxy;\n}\n\nvec3 plotPerlin1(vec2 p, float freq) {\n    float n = perlin1(p.x, freq);\n    float f = smoothstep(0.01, .05, abs(n - p.y));\n    vec3 col = mix(vec3(.9, 0., 0.), vec3(n), f);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 q = (fragCoord - iResolution.xy * .5) / iResolution.xx;\n    vec2 p = q;\n    \n    const float scale = 16.;\n    const float freq = 255.;\n    \n    p *= scale;\n    p.x += 1.2 * iTime;\n\nvec3 col = vec3(0.);\n    float h_fourth = iResolution.y * .25 / iResolution.x;\n    if (q.y > h_fourth) {\n        float y0 = 1.5 * h_fourth;\n        vec2 r = vec2(p.x, (p.y / scale - y0) * scale);\n        col += plotWorley1(r, freq);\n        \n    } else if (q.y > 0.) {\n        float wor = worley2(p, freq);\n        col += vec3(wor);\n        \n    } else if (q.y > -h_fourth) {\n        float y0 = -.5 * h_fourth;\n        vec2 r = vec2(p.x, (p.y / scale - y0) * scale);\n        col += plotPerlin1(r, freq);\n        \n    } else {\n        float per = perlin2(p, freq) * .5 + .5;\n        col += per;\n    }\n    \n#if DEBUG\n    vec2 grid = step(fract(p), vec2(.03));\n    col = mix(col, vec3(0., .9, .9), grid.x);\n    col = mix(col, vec3(0., .9, .9), grid.y);\n#endif\n\n    float sep = smoothstep(0., .003, abs(q.y));\n    col = mix(vec3(0., 0., .9), col, sep);\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}