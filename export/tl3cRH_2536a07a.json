{"ver":"0.1","info":{"id":"tl3cRH","date":"1608487322","viewed":286,"name":"Transmission thru Noise","username":"Carandiru","description":"A 2D volumetric ray march thru blue noise\n","likes":4,"published":3,"flags":0,"usePreview":0,"tags":["bluenoise","transmission"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// - carandiru\n// http://bit.ly/supersinfulsilicon\n\n// shader is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/tl3cRH\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n#define ZOOM 0.25f  // less is more zoom\n#define SPEED 0.125f\n#define MAX_STEPS 64\n#define EPSILON 0.000000001f\n\n// for noise\n#define sample_nearest iChannel0\n#define sample_nearest_dimensions iChannelResolution[0].xy\n// for normals from noise\n#define sample_linear iChannel2\n#define sample_linear_dimensions iChannelResolution[2].xy\n\nconst float SQRT_MAX_STEPS = -2.0f * sqrt(float(MAX_STEPS));\nconst vec2 light_start = vec2(0, -1); \nconst float noise_start = -0.75f;\nconst float opacity_threshold = 0.5f;\n\nfloat zoom = ZOOM;\n\nfloat fetch_opacity(in sampler2D source, in vec2 dimensions, in vec2 uv)\n{\n    return(textureLod(source, (uv * 0.5f + 0.5f) * iResolution.xy / dimensions * zoom, 0.0f).r);\n}\n\nfloat fetch_opacity(in vec2 uv)\n{\n    return(fetch_opacity(sample_nearest, sample_nearest_dimensions, uv));\n}\n\nvec2 computeNormal(in sampler2D source, in vec2 dimensions, in vec2 uv)\n{\n    vec3 half_texel_offset = vec3(0.5f, 0.5f, 0.0f) / vec3(dimensions, 1.0f);\n\n\tvec2 gradient;\t\n\n\tgradient.x = fetch_opacity(source, dimensions, uv - half_texel_offset.xz) - fetch_opacity(source, dimensions, uv + half_texel_offset.xz);\n\tgradient.y = fetch_opacity(source, dimensions, uv - half_texel_offset.zy) - fetch_opacity(source, dimensions, uv + half_texel_offset.zy);\n\t\n\treturn( normalize(gradient) );\n}\n\nvec2 computeNormal(in vec2 uv)\n{\n    return(computeNormal(sample_linear, sample_linear_dimensions, uv));\n}\n\n\n\nconst vec3 royal_blue_purple = vec3(0.222f,0.222f,1.0f) * vec3(0.80f,0.65f,1.0f);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tT = iTime * SPEED;\n    zoom = exp2(-(tT + (44.0f * SPEED)) * ZOOM * 2.0f);\n    \n    vec2 uv = (fragCoord/iResolution.xy) * 2.0f - 1.0f;\n    \n    vec2 ro = vec2(uv.x, uv.y + tT);\n    vec2 rd = normalize(vec2(0, 1));\n    \n    float dt = 1.0f / length(iResolution.xy * rd);\n    \n    vec2 p = ro + rd * dt * fetch_opacity(uv); // jittered offset\n    \n    vec2 light_pos = light_start + vec2(sin(iTime), tT);\n    \n    float intensity = 1.0f;\n    float light = 0.0f;\n    float tran = 1.0f;\n    for(int i = MAX_STEPS; i >= 0; --i) {\n    \n        vec2 ld = p - light_pos;\n        float dist = length(ld);    \n        float att = 1.0f / (1.0f + dist*dist);\n        \n        float lightAmount = att * intensity * 2.0f;\n        \n        float opacity = fetch_opacity(p);\n        float sigmaS = lightAmount * (1.0f-opacity);\n        float inv_sigmaE = 1.0f / max(EPSILON, sigmaS); // to avoid division by zero extinction\n    \n        float sigma_dt = exp2(sigmaS * SQRT_MAX_STEPS * dt);\n        float Sint = (sigmaS - sigmaS * sigma_dt) * inv_sigmaE;\n\n        light += tran * Sint;\n\n\t    tran *= sigma_dt;\n       \n        if (tran < 0.015f)\n            break;\n       \n        if (opacity - opacity_threshold >= 0.0f) {\n        \n            vec2 n = computeNormal(p);\n            rd = reflect(rd, n);\n            \n            intensity = max(0.0f, dot(normalize(ld), n)) * tran;\n          //  light_pos = p;  // optional adds flicker\n        }\n        \n        p += rd * dt;\n    }\n    \n    vec3 color = vec3(light * (1.0f - tran));\n    \n    color = mix(color, mix(royal_blue_purple, color, tran), light);\n    //color = vec3(rd, 0);\n    //color = vec3(normal * 0.5f + 0.5f, opacity) * opacity;\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}