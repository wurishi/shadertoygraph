{"ver":"0.1","info":{"id":"4sc3zr","date":"1447633025","viewed":112,"name":"151113","username":"dmmn","description":"Candles","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["fire"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"\n#define PI 3.1415926535897932384626433832795\n\nstruct Voxel\n{\n  float dist;\n  vec4 color;\n};\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nVoxel smin( Voxel voxel1, Voxel voxel2, float blendRatio )\n{\n  float ratio = clamp(.5 + .5 * (voxel2.dist - voxel1.dist) / blendRatio, 0., 1.);\n\n  float dist = mix(voxel2.dist, voxel1.dist, ratio) - blendRatio * ratio * (1. - ratio);\n  vec4 color = mix(voxel2.color, voxel1.color, ratio);\n\n  return Voxel(dist, color);\n}\n\nVoxel minVoxel( Voxel voxel1, Voxel voxel2 )\n{\n  if(voxel1.dist - voxel2.dist < 0.) {\n    return voxel1;\n  }\n  else {\n    return voxel2;\n  }\n}\n\nVoxel maxVoxel( Voxel voxel1, Voxel voxel2 )\n{\n  if(voxel1.dist - voxel2.dist > 0.) {\n    return voxel1;\n  }\n  else {\n    return voxel2;\n  }\n}\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res*res;\n}\n\nVoxel map( in vec3 p) {\n    \n    Voxel voxel = Voxel(1., vec4(.12, .1, 0., 1.));\n    \n    vec2 gridPosition = floor(p.xz + .5);\n    \n    float height = rand(gridPosition);\n    \n    vec3 positionOffset = vec3(0.0, 0.0, 2.0);\n    vec3 q = p;\n    q.xz = mod(p.xz + positionOffset.xz + 1.0, 2.0) - 1.0;\n    \n    q.y += height;\n    \n    Voxel candle = Voxel(sdCapsule(q, vec3(0., 1., 0.), vec3(0., -1., 0.), .1), vec4(1.) * (q.y - height + .3));\n    voxel = minVoxel(voxel, candle);\n    \n    Voxel plane = Voxel(p.y + 1.0, vec4(0.));                                    \n\tvoxel = smin(voxel, plane, .5);\n                                        \n    Voxel wick = Voxel(sdCappedCylinder(q + vec3(0., -1.2, 0.), vec2(.01, .2)), vec4(1.));\n\tvoxel = minVoxel(voxel, wick);\n    \n    return voxel;\n}\n\nVoxel mapCandles( in vec3 p) {\n    \n    Voxel voxel = Voxel(1., vec4(0.));\n    \n    vec2 gridPosition = floor(p.xz + .5);\n   \n    float height = rand(gridPosition);\n    \n    vec3 positionOffset = vec3(0.0, 0.0, 2.0);\n    vec3 q = p;\n    \n    q.xz = mod(p.xz + positionOffset.xz + 1.0, 2.0) - 1.0;\n    q.y += height;\n    \n    vec3 flamePosition = q + vec3(0., -1.5, 0.);\n    Voxel flame = Voxel(sdEllipsoid(flamePosition, vec3(.1, .4, .1)), vec4(1., .5, 0., 1.) + (.2 - flamePosition.x));\n    vec2 noiseOffset = flamePosition.xy;\n    noiseOffset.y = noiseOffset.y - iTime + gridPosition.x + gridPosition.y;\n    \n    Voxel flameHalo = flame;\n    \n    flame.dist += noise(noiseOffset * 10.) * .10;\n    voxel = minVoxel(voxel, flame);\n    \n    return voxel;\n}\n\nvec3 calcNormal ( vec3 p ) {\n  vec2 e = vec2(.0001, 0.0);\n  return normalize(vec3(\n    map(p + e.xyy).dist - map(p - e.xyy).dist,\n    map(p + e.yxy).dist - map(p - e.yxy).dist,\n    map(p + e.yyx).dist - map(p - e.yyx).dist\n  ));\n}\n\nvec3 calcNormalCandles ( vec3 p ) {\n  vec2 e = vec2(.0001, 0.0);\n  return normalize(vec3(\n    mapCandles(p + e.xyy).dist - mapCandles(p - e.xyy).dist,\n    mapCandles(p + e.yxy).dist - mapCandles(p - e.yxy).dist,\n    mapCandles(p + e.yyx).dist - mapCandles(p - e.yyx).dist\n  ));\n}\n\nVoxel rayMarch(vec3 rayOrigin, vec3 rayDirection)\n{\n  Voxel voxel = Voxel(0., vec4(0.0));\n\n  float rayMarchingStep = 0.001;\n  float dist = .1;\n\n  for(int i = 0; i < 64; i++) {\n    if (rayMarchingStep < 0.001 || dist > 100.) break;\n    voxel = map(rayOrigin + rayDirection * dist);\n    rayMarchingStep = voxel.dist;\n    dist += rayMarchingStep;\n  }\n\n  vec3 normal = calcNormal(rayOrigin + rayDirection * dist);\n  voxel.color *= 1.7 + dot(normal, normalize(vec3(1., 1., 1.)));\n\n  return voxel;\n}\n\nVoxel rayMarchCandles(vec3 rayOrigin, vec3 rayDirection)\n{\n  Voxel voxel = Voxel(0., vec4(0.0));\n\n  float rayMarchingStep = 0.001;\n  float dist = .1;\n\n  for(int i = 0; i < 64; i++) {\n    if (rayMarchingStep < 0.001 || dist > 100.) break;\n    voxel = mapCandles(rayOrigin + rayDirection * dist);\n    rayMarchingStep = voxel.dist;\n    dist += rayMarchingStep;\n  }\n\n  vec3 normal = calcNormalCandles(rayOrigin + rayDirection * dist);\n  voxel.color *= 2. + dot(normal, normalize(vec3(1., 1., 1.)));\n\n  return voxel;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0.0, 2., -iTime);\n    vec3 rd = normalize( vec3( p, 1.0 ));\n    float rotation = (1.0 - (iMouse.x / iResolution.x) * 2.0) * PI;\n    vec3 direction = vec3(cos(rotation + PI * .5), -.4, sin(rotation + PI * .5));\n    rd = normalize(direction + vec3( cos(rotation) * p.x, p.y, sin(rotation) * p.x ));\n    \n    Voxel voxel = rayMarch(ro, rd);\n    \n    voxel.color += rayMarchCandles(ro, rd).color;\n    \n\tfragColor = vec4(voxel.color.rgb, 1.);\n}","name":"Image","description":"","type":"image"}]}