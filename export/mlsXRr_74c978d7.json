{"ver":"0.1","info":{"id":"mlsXRr","date":"1674227805","viewed":104,"name":"Cloud Raymarching Test","username":"OscarSaharoy","description":"Trying to learn volumetric raymarching - any advice & help hugely appreciated :)","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","cloud","atmosphere"],"hasliked":0,"parentid":"flS3zy","parentname":"cloud in a bubble"},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI 3.1415927\n// atmospheric scattering specifics\n\n// Mie scattering\nfloat miePhase = 0.9;\nfloat mieAmount = 0.01;\nvec3 mieScatteringConstants = vec3(0.01);\nvec3 mieAbsorptionConstants = vec3(0.01);\n\n// Rayleigh scattering\nfloat rayleighPhase = -0.01;\nfloat rayleighAmount = 0.9;  // how blue is your sky?\nvec3 rayleighScatteringConstants = vec3(0.15, 0.31, 1.24);\n\n// Cloud scattering\nfloat cloudAbsorb = .5; // amount of absorption by clouds\nfloat cloudScatter = 6.0; // amount of omni-directional scatter off clouds\nfloat cloudMie = .6; // amount of Mie scattering by clouds\n\n\nvec3 lightCol = vec3(1) * 10.;\nvec4 sph1 = vec4 (0,0,0,1);\n\n\n\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand(vec3 co) {\n    return fract(sin(dot(co.xyz ,vec3(12.9898,78.233,47.985))) * 43758.5453);\n}\n\n// credit: iq/rgba\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\n\n// credit: iq/rgba\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n\nfloat fbm(in vec3 x) {\n    float i = 1.0;\n\n    float n = noise(x * i) / i; i *= 2.0;\n    n+= noise(x * i) / i; i *= 2.0;\n    n+= noise(x * i) / i; i *= 2.0;\n    n+= noise(x * i) / i; i *= 2.0;\n    n+= noise(x * i) / i; i *= 2.0;\n    n+= noise(x * i) / i; i *= 2.0;\n\n    return n;\n}\n\n\n//============================================================\n// Intersection Formulae\n//============================================================\n\n\n// intersection through participating media (like atmospheres)\nstruct iMediaIntersection {\n    float tnear;   // first intersection\n    float tfar;    // last intersection\n};\n\n\n// intersect ray ro+rd with sphere sph, calculates both entry and exit points.\niMediaIntersection mSphere(in vec3 ro, in vec3 rd, in vec4 sph) {\n\n    iMediaIntersection res;\n    res.tnear = -1.0;\n    res.tfar = -1.0;\n\n\n    // sphere intersection\n    float r = sph.w; //radius\n    vec3 oc = ro - sph.xyz; //origin = position sphere\n    float b = 2.0*dot(oc,rd);\n    float c = dot(oc,oc)-r*r;\n    float h = b*b - 4.0*c;\n\n    if (h >= 0.0) {\n        float hsqrt = sqrt(h);\n        res.tnear = (-b - hsqrt) / 2.0;\n        res.tfar = (-b + hsqrt)/2.0;\n    }\n\n    return res;\n}\n\n// mie/rayleigh phase - @pyalot http://codeflow.org/entries/2011/apr/13/advanced-webgl-part-2-sky-rendering/\n// sensible g: mie:0.97, ral:-0.01\nfloat phase(float alpha, float g) {\n    float gg = g*g;\n    float a = 3.0*(1.0-gg);\n    float b = 2.0*(2.0+gg);\n    float c = 1.0+alpha*alpha;\n    float d = pow(1.0+gg-2.0*g*alpha, 1.5);\n    return (a/b)*(c/d);\n}\n\nfloat mieDensity( in vec3 pos ) {\n    return 0.01 * smoothstep(1., 0., 20.*(length(pos)-.95) );\n}\n\nfloat rayleighDensity( in vec3 pos ) {\n    // constant 0.2 except fade to 0 at edges of sphere\n    return 0.2 * smoothstep(1., 0., 20.*(length(pos)-.95) );\n}\n\nfloat cloudDensity( in vec3 pos ) {\n\n    vec3 pos2 = pos - sph1.xyz;\n    float density = 1.0-smoothstep(0.2,0.9,dot(pos2,pos2));\n    pos += vec3(17.3,6.9,0.19) * iTime * 0.002;\n    return fbm(pos*2.3) * density - 0.8;\n}\n\nvec3 attenuationToSun( in vec3 apos, in vec3 sunDir ) {\n\n    // do another raycast towards the sun\n    float tsun = mSphere( apos, sunDir, sph1 ).tfar; // cast ray to sun, intersect with inner edge of sphere\n    float dtl  = tsun * 0.12; // keep it rather chunky, don't want to bog down\n\n    float rayleighToSun = 0.0;\n    float mieToSun      = 0.0;\n    float cloudToSun    = 0.0;\n\n    for (float tl = 0.; tl < tsun; tl += dtl) {\n\n        vec3 spos = apos + sunDir * tl;\n\n        mieToSun += mieDensity(spos) * dtl;  // acumulate mie density\n        rayleighToSun += rayleighDensity(spos) * dtl;\n        float stepCloudDensity = cloudDensity(spos);\n        cloudToSun += max(0.,stepCloudDensity) * dtl;  // acumulate cloud density\n        \n        if( cloudToSun > 4. ) break;\n        \n        dtl = tsun * clamp( 0.2 - 0.2 * stepCloudDensity, 0.05, 0.4 );\n    }\n\n    return exp( -(\n        rayleighToSun * rayleighScatteringConstants +\n        mieToSun * mieScatteringConstants +\n        cloudToSun * vec3(cloudScatter) +\n        mieToSun * mieAbsorptionConstants +\n        cloudToSun * vec3(cloudAbsorb)\n    ) );\n}\n\n\nvec3 scatteredLight( in vec3 ro, in vec3 rd, in iMediaIntersection hit, in vec3 sunDir ) {\n\n    vec3 light = vec3(0);\n\n    //hit.tnear += hash( hit.tnear*100. )*0.2;\n    vec3 pos = ro + hit.tnear * rd; //hit position\n\n    // step through atmosphere, cast rays to lightsource to determine shadow.\n    float dt = (hit.tfar - hit.tnear) * 0.12;\n\n    // raymarch through sphere:\n    // - calculate cumulative absorption\n    // - calculate influx at each point\n    // - raymarch towards sun & repeat above process.\n\n    float mieMass = 0.0;\n    float rayleighMass = 0.0;\n    float cloudMass = 0.0;\n\n    for(float t = hit.tnear + dt/2.; t<hit.tfar; t+=dt){\n\n        vec3 apos = ro + rd * t; // position along atmosphere ray\n\n        float stepMieDensity = mieDensity(apos) * dt;\n        mieMass += stepMieDensity; // total mie density along path\n\n        float stepRayleighDensity = rayleighDensity(apos) * dt;\n        rayleighMass += stepRayleighDensity; // total rayliegh density from viewer to point\n\n        float cd = cloudDensity(apos);\n        float stepCloudDensity = max(0.,cd) * dt;\n        cloudMass += stepCloudDensity; // total cloud density from viewer to point\n\n        vec3 mieScatterFactors =\n            phase( dot(rd,sunDir), miePhase )\n            * mieAmount * mieScatteringConstants\n            * stepMieDensity;\n\n        vec3 rayleighScatterFactors =\n            phase( dot(rd,sunDir), rayleighPhase )\n            * rayleighAmount * rayleighScatteringConstants\n            * stepRayleighDensity;\n\n        vec3 cloudScatterFactors =\n            vec3( phase( dot(rd,sunDir), miePhase ) * cloudMie + cloudScatter )\n            * stepCloudDensity;\n\n        vec3 influx = lightCol * attenuationToSun( apos, sunDir );\n\n        vec3 attenuationToViewer = exp( -(\n            rayleighMass * rayleighScatteringConstants +\n            mieMass * mieScatteringConstants +\n            cloudMass * vec3(cloudScatter) +\n            mieMass * mieAbsorptionConstants +\n            cloudMass * vec3(cloudAbsorb)\n        ) );\n\n        light += influx * ( rayleighScatterFactors + mieScatterFactors + cloudScatterFactors ) * attenuationToViewer;\n\n        // sun disc\n        float mie_eye = phase( dot(rd,sunDir), 0.9995 ) * stepMieDensity; // relative amount of Mie scattering.\n        light += mie_eye * influx * attenuationToViewer;\n        \n        if( length(attenuationToViewer) < 0.01 ) break;\n        \n        dt = (hit.tfar - hit.tnear) * clamp( 0.2 - 0.2 * cd, 0.05, 0.2 );\n    }\n\n    return light;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 p = ( fragCoord.xy - iResolution.xy * .5 )\n        / min(iResolution.x, iResolution.y) * 2.;\n\n    vec3 ro = 2. * vec3(-cos(iTime*0.5), 0., sin(iTime*0.5));\n    ro = vec3( -2, 0, 0 );\n\n    vec3 lookAt = sph1.xyz;\n    vec3 front = normalize(lookAt - ro);\n    vec3 left = normalize(cross(vec3(0,1,0), front));\n    vec3 up = normalize(cross(front, left));\n\n    vec3 rd = normalize(front*1.5 + left*p.x + up*p.y); // view dir\n    vec3 lightDir = normalize(vec3(1));\n    lightDir = normalize(vec3(.75,.25,0.25));\n\n    vec3 light = vec3(0.0);\n    iMediaIntersection hit = mSphere(ro,rd,sph1);\n\n    if (hit.tnear > 0.0)\n        light += scatteredLight( ro, rd, hit, lightDir );\n\n    // reinhardt HDR tonemapping\n    float whitelevel = 5.;\n    light = (light * (vec3(1.0) + (light / (whitelevel * whitelevel))  ) ) / (vec3(1.0) + light);\n\n    // gamma\n    light = pow(light,vec3(1.0/2.0));\n\n    fragColor = vec4(light,1.0);\n}\n","name":"Image","description":"","type":"image"}]}