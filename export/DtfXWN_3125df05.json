{"ver":"0.1","info":{"id":"DtfXWN","date":"1675086786","viewed":132,"name":"Jonix Jedi Hologram","username":"Hultsborn10","description":"My attempt to create some kind of Star Wars Hologram effect on video","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["starwars","hologram"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Created 2023-01-30\n//\n\n\n//\"Slump-funktion\". Ger 0.0 - 1.0 ut\nfloat Ran(float t){\n    float p = fract(t * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\n//\"Slump-funktion\". Ger 0.0 eller 1.0 ut\nfloat RanStep(float t, float d, float a){\n    //använd d som \"delay\" för att hålla kvar samma värde i d antal sekunder\n    float v = floor(t / d);\n    float p = fract(v * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    p = fract(p);\n    return step(a,p);\n}\n\n//Skapar horisontella och vertikala ränder i hologrammet\nfloat Hologram(vec2 uv){\n    //Små lodräta rader (värde 0.5 - 1.0)\n    float verticalStripe = sin(uv.x*1000.0)*0.25 + 0.75;\n    //Breda vågräta rader (värde 0.5 - 1.0), \"slump-mässigt\" aktiverade \n    float horizontal = RanStep(iTime, 5.0, 0.4)*sin(3.0*uv.y+iTime)*sin(uv.y*15.0 + iTime*5.0)*0.25 + 0.75;\n    //Visa endast den översta delen (över 0.95) med stegfunktion (utvärde 0.5 eller 1.0)\n    horizontal = smoothstep(0.94,0.96,horizontal)*.5+0.5;\n    //Multiplicera ihop lodräta och vågräta värden\n    float holo = verticalStripe*horizontal;\n    return holo;\n}\n\n//Skapar en ljus kant runt figuren\nvec3 Glow(vec2 uv, vec3 GREEN){\n    //delta ska motsvara ett antal \"pixlar\"\n    vec2 delta = 7.0 / iResolution.xy;\n    //ta fram positioner i fyra riktningar\n    vec2 upPos = vec2(uv.x, uv.y + delta.y);\n    vec2 rightPos = vec2(uv.x + delta.x, uv.y);\n    vec2 downPos = vec2(uv.x, uv.y - delta.y);\n    vec2 leftPos = vec2(uv.x - delta.x, uv.y);\n    \n    //Läs ut färg från punkter i alla fyra riktningarna\n    //Räkna ut skillnaden mot den gröna färgen (summera sen alla skillnader)\n    vec3 texCol = texture(iChannel0, upPos).rgb;\n    float diff = length(texCol - GREEN);\n    \n    texCol = texture(iChannel0, rightPos).rgb;\n    diff += length(texCol - GREEN);\n    \n    texCol = texture(iChannel0, downPos).rgb;\n    diff += length(texCol - GREEN);\n    \n    texCol = texture(iChannel0, leftPos).rgb;\n    diff += length(texCol - GREEN);\n    \n    //diff är nästan 0 när det är helt grönt, \n    //mellan 0 och 2 i kanten,\n    //och mer än 2 mitt i centrum av figuren\n    \n    //Plocka bort \"centrum\"-delen av bilden \n    //(dvs. där alla fyra riktningar innehåller annan färg än grön)\n    diff *= smoothstep(2.0,0.8,diff);\n    \n    return vec3(diff);\n    \n}\n\n\n//Skapar horisontella störningar\nvec2 Scramble(vec2 uv){\n    vec2 xy = vec2(uv.x+Ran(100.0*uv.y)*0.2-0.1,uv.y);\n    return xy;\n}\n\n\nvec3 MaskGreen(vec2 st){\n    //Aktivera störningar vid korta sporadiska tillfällen\n    float tSc = RanStep(iTime, 0.1, 0.04);\n    vec2 uv = tSc*st + (1.0 - tSc)*Scramble(st);\n    //RGB value for green backgrund is (13,163,37)\n    //Float RGB is (0.05,0.64, 0.145)\n    vec3 GREEN = vec3(13,163,37)/255.0;\n    //Read the rgb value of the texture at uv coordinate\n    vec3 texCol = texture(iChannel0, uv).rgb;\n    \n    \n    //En variant som blir negativ när grönt dominerar\n    float greenDiff = texCol.r + texCol.b - texCol.g ;\n    \n    //En annan variant som mäter \"färg-avståndet\" till den gröna färgen \n    float greenDiff2 = length(texCol-GREEN);\n    //Skapa en smooth mask som är 0 vid grönt och 1 vid andra färger\n    float BORDER = 0.6;\n    float greenMask = smoothstep(0.0, BORDER, greenDiff2);\n    \n    \n    \n    //vec3 col = texCol * greenMask + texCol * greenDiff2;\n    vec3 col = texCol * greenMask; //Applicera mask på filmen\n    //col = texCol * greenDiff2;\n    col = col.b*vec3(1.0,1.2,1.8); //Använd endast blå-komponenten för figuren\n    \n    //Lägg till Hologram-effekten\n    col *= Hologram(uv);\n    \n    //Läs bakgrunden\n    //Stökig rörlig bakgrund\n    //vec2 st = uv*vec2(sin(uv.x + iTime),cos(uv.y + iTime));\n    //vec3 backCol = texture(iChannel1, st).rgb;\n    vec3 backCol = texture(iChannel1, st).rgb;\n    \n    //Skapa en inverterad mask för bakgrunden\n    backCol *= smoothstep(BORDER, 0.0,greenDiff2);\n    \n    //Lägg ihop film och bakgrund\n    col += backCol;\n    \n    //col = vec3(texCol.r, texCol.g*0.2, texCol.b);\n    //col = vec3(1.0, 0.1, 1.0)*texCol;\n    \n    //Lägg till en ljus, suddig kant\n    col += 0.6*Glow(uv,GREEN);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // UV - scale coordinates from 0.0 to 1.0 both x and y \n    //0.0 is in the left bottom corner\n    vec2 uv = fragCoord/iResolution.xy;\n    //(from top-left to bottom-right)\n    \n    \n    vec3 col = vec3(0.0); //Create base color black.\n    \n    //Texture\n    col = MaskGreen(uv);\n    //col = vec3(uv,0.0);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}