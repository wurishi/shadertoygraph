{"ver":"0.1","info":{"id":"7dKfz1","date":"1659647667","viewed":120,"name":"Snowflake Fractal Tiling","username":"PlasmaVortex","description":"Spinning snowflakes!","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 norm(vec2 p0, vec2 p1, vec2 p) {\n    float a = p.x - p0.x;\n    float b = p.y - p0.y;\n    float c = p1.x - p0.x;\n    float d = p1.y - p0.y;\n    float x = (a*c+b*d)/(c*c+d*d);\n    float y = (b*c-a*d)/(c*c+d*d);\n    return vec2(x,y);\n}\n\nvec2 rotate(vec2 p, vec2 center, float angle) {\n    float x = p.x - center.x;\n    float y = p.y - center.y;\n    float s = sin(angle);\n    float c = cos(angle);\n    float rx = c*x - s*y;\n    float ry = s*x + c*y;\n    return center + vec2(rx,ry);\n}\n\nconst float pi = 3.1415926;\nfloat ease(float x) {\n    return (1.0 - cos(pi * x)) / 2.0;\n}\n\nbool inTriangle(vec2 pt) {\n    float x = pt.x;\n    float y = pt.y;\n    if (y < 0.0 || y > x/sqrt(3.0) || y > -(x-1.0)/sqrt(3.0))\n        return false;\n    \n    bool b = true;\n    while (true) {\n        if (y > sqrt(3.0)*(x - 1.0/3.0)) {\n            float tx = 1.5*x + sqrt(3.0)/2.0*y;\n            float ty = sqrt(3.0)/2.0*x - 1.5*y;\n            x = tx;\n            y = ty;\n            b = !b;\n        } else if (y > -sqrt(3.0)*(x - 2.0/3.0)) {\n            float tx = 1.5*(1.0-x) + sqrt(3.0)/2.0*y;\n            float ty = sqrt(3.0)/2.0*(1.0-x) - 1.5*y;\n            x = tx;\n            y = ty;\n            b = !b;\n        } else {\n            return b;\n        }\n    }\n}\n\nbool inFractal(vec2 coord, vec2 center, float radius) {\n    float x = coord.x - center.x;\n    float y = coord.y - center.y;\n    vec2 pt = vec2(x,y);\n    \n    float s = radius / 2.0;\n    vec2 verts[3] = vec2[3](\n        vec2(-sqrt(3.0)*s, s),\n        vec2(sqrt(3.0)*s, s),\n        vec2(0, -2.0*s)\n    );\n    \n    if (y > s) {\n        pt = norm(verts[0], verts[1], pt);\n    } else if (y < sqrt(3.0)*x - 2.0*s) {\n        pt = norm(verts[1], verts[2], pt);\n    } else if (y < -sqrt(3.0)*x - 2.0*s) {\n        pt = norm(verts[2], verts[0], pt);\n    } else {\n        return true;\n    }\n    return inTriangle(pt);\n}\n\nconst float bR = 100.0;\nconst float bH = bR;\nconst float bW = bR * sqrt(3.0);\nconst vec2 shift = vec2(0,90);\nvec2 possibleBlack(vec2 coord) {\n    vec2 v = coord + shift;\n    float x = mod(v.x, 2.0 * bW) - bW;\n    float y = mod(v.y, 2.0 * bH) - bH;\n    if (x*x + y*y <= bR*bR) {\n        return coord - vec2(x,y);\n    } else {\n        x = mod(v.x + bW, 2.0 * bW) - bW;\n        y = mod(v.y + bH, 2.0 * bH) - bH;\n        if (x*x + y*y <= bR*bR) {\n            return coord - vec2(x,y);\n        } else {\n            return vec2(-100);\n        }\n    }\n}\n\nconst float wR = bR / sqrt(3.0);\nconst float wH = wR * sqrt(3.0);\nconst float wW = wR;\nvec2 possibleWhite(vec2 coord) {\n    vec2 v = coord + vec2(bW,bH) + shift;\n    float x = mod(v.x, 2.0 * wW) - wW;\n    float y = mod(v.y, 2.0 * wH) - wH;\n    if (x*x + y*y <= wR*wR) {\n        return coord - vec2(x,y);\n    } else {\n        x = mod(v.x + wW, 2.0 * wW) - wW;\n        y = mod(v.y + wH, 2.0 * wH) - wH;\n        if (x*x + y*y <= wR*wR) {\n            return coord - vec2(x,y);\n        } else {\n            return vec2(-100);\n        }\n    }\n}\n\nconst float spinTime = 90.0;\nconst float pauseTime = 30.0;\nconst float period = 2.0*(spinTime + pauseTime);\nbool inWhite(vec2 coord) {\n    float frame = mod(float(iFrame), period);\n    vec2 blackCenter = possibleBlack(coord);\n    vec2 whiteCenter = possibleWhite(coord);\n    bool possibleB = (blackCenter.x > -10.0);\n    bool possibleW = (whiteCenter.x > -10.0);\n    \n    if (distance(coord, blackCenter) < wR) {\n        return false;\n    }\n    if (frame < spinTime) { // black spinning\n        if (possibleB) {\n            float angle = -60.0 * ease(frame / spinTime);\n            vec2 c = rotate(coord, blackCenter, radians(angle));\n            return !inFractal(c, blackCenter, bR);\n        }\n        return true;\n    } else {\n        if (possibleW) {\n            float angle = 30.0;\n            frame -= spinTime + pauseTime;\n            if (0.0 < frame && frame < spinTime) // white spinning\n                angle += 60.0 * ease(frame / spinTime);\n            vec2 c = rotate(coord, whiteCenter, radians(angle));\n            return inFractal(c, whiteCenter, wR);\n        }\n        return false;\n    }\n}\n\nconst int s = 3;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float white = 0.0;\n    for (int i = 0; i < s; i++) {\n        for (int j = 0; j < s; j++) {\n            vec2 coord = fragCoord + vec2(i,j)/float(s);\n            white += float(inWhite(coord));\n        }\n    }\n    \n    vec3 col = vec3(white / float(s*s));\n    \n    fragColor = vec4(col,0.0);\n}","name":"Image","description":"","type":"image"}]}