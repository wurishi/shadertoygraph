{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// @eddbiddulph\n// Use the mouse to rotate the view!\n\n#define EPS vec2(1e-3, 0.0)\n\nvec3 rotateX(float a, vec3 v)\n{\n   return vec3(v.x, cos(a) * v.y + sin(a) * v.z, cos(a) * v.z - sin(a) * v.y);\n}\n\nvec3 rotateY(float a, vec3 v)\n{\n   return vec3(cos(a) * v.x + sin(a) * v.z, v.y, cos(a) * v.z - sin(a) * v.x);\n}\n\nfloat cube(vec3 p, vec3 s)\n{\n   return length(max(vec3(0.0), abs(p) - s));\n}\n\nfloat customCube(vec3 p, vec3 s)\n{\n   return cube(p, s) - 0.01;\n}\n\nfloat circular(float t)\n{\n   return sqrt(1.0 - t * t);\n}\n\nfloat processionOfCubes(vec3 p)\n{\n   float t = -iTime * 0.2;\n   p.z -= t * 2.5;\n   float rad = 0.1 + cos(floor(p.z) * 10.0) * 0.07;\n   p.x += cos(floor(p.z) * 2.0) * 0.3;\n   p.z -= floor(p.z);\n   t /= rad;\n   t -= floor(t);\n   vec3 org = vec3(0.0, circular((t - 0.5) * 1.5) * length(vec2(rad, rad)), 0.5);\n   return customCube(rotateX(t * 3.1415926 * 0.5, p - org), vec3(rad));\n}\n\nfloat scene(vec3 p)\n{\n   float tunnel0 = max(-p.y, length(max(vec2(0.0), vec2(-abs(p.z) + 2.0, max(length(p.xy) - 2.0, 0.9 - length(p.xy))))) - 0.03);\n   return min(tunnel0, processionOfCubes(p));\n}\n\nvec3 sceneGrad(vec3 p)\n{\n   float d = scene(p);\n   return (vec3(scene(p + EPS.xyy), scene(p + EPS.yxy), scene(p + EPS.yyx)) - vec3(d)) / EPS.x;\n}\n\nvec3 veil(vec3 p)\n{\n   float l = length(p);\n   return vec3(1.0 - smoothstep(0.0, 4.0, l)) * vec3(1.0, 1.0, 0.75);\n}\n\nvec3 environment(vec3 ro, vec3 rd)\n{\n   float t = -ro.y / rd.y;\n   vec2 tc = ro.xz + rd.xz * t;\n   vec3 p = vec3(tc.x, 0.0, tc.y);\n   float d = scene(p);\n\n   float u = fract(dot(tc, vec2(1.0)) * 20.0);\n   float s = t * 2.0;\n   float stripes = smoothstep(0.0, 0.1 * s, u) - smoothstep(0.5, 0.5 + 0.1 * s, u);\n\n\n   vec3 col = mix(vec3(0.3, 0.3, 0.6), vec3(0.3, 0.3, 0.6) * 1.3, stripes);\n\n   return veil(p) * col * mix(0.0,\n         mix(0.9, 1.0, 1.0) *\n         mix(0.5, 1.0, sqrt(smoothstep(0.0, 0.3, d))) *\n         mix(0.5, 1.0, sqrt(smoothstep(0.0, 0.06, d))), step(0.0, t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - vec2(1.0);\n\tuv.x *= iResolution.x / iResolution.y;\n\tvec3 ro = vec3(0.0, 0.2, 1.0), rd = vec3(uv, -0.9);\n\t\n\tvec2 angs = vec2(1.0-iMouse.y * 0.003, 1.0-iMouse.x * 0.01);\n\t\n\tro = rotateY(angs.y, ro) + vec3(0.0, 0.6, 0.0);\n\trd = rotateY(angs.y, rotateX(angs.x, rd));\n\t\n\tfragColor.rgb = environment(ro, rd);\n\t\n\tfor(int i = 0; i < 200; i += 1)\n\t{\n\t\tfloat d = scene(ro);\n\t\t\n\t\tif(abs(d) < 1e-3)\n\t\t{\n\t\t\tfragColor.rgb = veil(ro) * mix(vec3(0.1, 0.1, 0.4) * 0.25, vec3(1.0),\n\t\t\t\t\t\t  (1.0 + dot(normalize(sceneGrad(ro)), normalize(vec3(0.0, 1.0, 0.4)))) * 0.5);\n\t\t}\n\t\t\n\t\tro += rd * d * 0.2;\n\t}\n\t\n\tfragColor.rgb = sqrt(fragColor.rgb);\n\tfragColor.a = 1.0;\n}\n\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdsGz8","date":"1362857168","viewed":2644,"name":"Marching Cubes","username":"fizzer","description":"Obviously not the famous 'marching cubes' polygonisation algorithm, but I couldn't resist the opportunity to use a pun like this!","likes":56,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cubes"],"hasliked":0,"parentid":"","parentname":""}}