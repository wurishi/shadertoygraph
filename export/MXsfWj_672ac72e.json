{"ver":"0.1","info":{"id":"MXsfWj","date":"1728992909","viewed":81,"name":"Volumetric Clouds 14-10-2024","username":"Datablock","description":"Rough prototype of cloud rendering, a lot needs to be done. Camera height and pitch are controlled by the mouse position.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","clouds","cloud","volumetric","scattering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float cloudBot = -100.0;\nconst float cloudTop = 120.0;\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n    return mix( rg.x, rg.y, f.z );\n}\n\nfloat densityAtPoint(vec3 point) {\n    float d1 = clamp(cloudTop - point.y, 0.0, 25.0);\n    float d2 = clamp(point.y  - cloudBot, 0.0, 25.0);\n\tfloat density0 = noise(point*0.001  + vec3(iTime*0.03, iTime*0.01, iTime*0.02));\n    float density1 = noise(point*0.01   + vec3(iTime*0.13, iTime*0.01, iTime*0.01)       ) * 0.2;\n    float density2 = noise(point*0.1    + vec3(iTime*0.23, iTime*0.01, iTime*0.03)       ) * 0.1;\n    float density3 = noise(point*0.3    + vec3(iTime*0.10, iTime*0.01, iTime*0.04)       ) * 0.05;\n    return max(density0 + density1 + density2 + density3 - 0.8, 0.0) * d1 * d2 * 0.00016;\n}\n\nfloat HenyeyGreenstein(float g, float costh) {\n    return 0.0795774715459 * (\n    ((1.0 - g * g) / pow(1.0 + g * g - 2.0 * g * costh, 1.5)) +\n    ((1.0 - g * g) / pow(1.0 + g * g + 2.0 * g * costh, 1.5)) * 0.3);\n}\n\nfloat opticalDepth(vec3 rayOrigin, vec3 rayDir, float rayLength) {\n    \n    int opticalDepthPoints = 7;\n\tfloat stepSize = rayLength / float(opticalDepthPoints + 1);\n\tvec3 dDist = rayDir * stepSize;\n\tvec3 densitySamplePoint = rayOrigin;\n\tfloat opticalDepth = 0.0;\n    \n\tfor (int i = 0; i < opticalDepthPoints; i++)\n    {\n\t\tfloat localDensity = densityAtPoint(densitySamplePoint);\n\t\topticalDepth += localDensity * stepSize;\n\t\tdensitySamplePoint += dDist;\n\t}\n    return opticalDepth;\n}\n\nvec4 rayMarch( in vec3 rayOrigin, in vec3 rayDir) {\n    \n    vec3 rayPos = rayOrigin;\n    \n    float distCloudTop = max(abs(cloudTop - rayOrigin.y) / abs(rayDir.y), 0.0);\n    float distCloudBot = max(abs(cloudBot - rayOrigin.y) / abs(rayDir.y), 0.0);\n    \n    float minDist = min(distCloudBot, distCloudTop);\n    float maxDist = max(distCloudBot, distCloudTop);\n    \n    rayPos += rayDir * minDist;\n    float rayLength = min(10000.0, (maxDist - minDist));\n    \n    int scatterPoints = 70;\n\tfloat stepSize = rayLength / float(scatterPoints - 1);\n\tvec3 dDist = rayDir * stepSize;\n    rayPos += dDist * 0.5;\n    \n\tvec3 totalLight = vec3(0.0);\n    float transmittance = 1.0;\n    \n    float absorptionCoefficient = 0.3;\n    vec3 sunColor = vec3(1.0);//vec3(1.0, 0.5, 0.2);\n    vec3 sunDir = normalize(vec3(0.0, 3.0, 1.0));\n    \n    for (int i = 0; i < scatterPoints; i++)\n    {\n        float localDensity = densityAtPoint(rayPos);\n        transmittance *= exp(-absorptionCoefficient * (localDensity * stepSize));\n        \n        if (transmittance < 0.01) {\n            break;\n        }\n        \n        float sunRayLength = max((cloudTop - rayPos.y) / sunDir.y, (cloudBot - rayPos.y) / sunDir.y);\n        float sunOD = opticalDepth(rayPos, sunDir, sunRayLength);\n        \n        float inscatteredLight = exp(-absorptionCoefficient * sunOD) * HenyeyGreenstein(0.2, dot(sunDir, rayDir));\n        //(1.0 - exp(-2.0 * sunOD)) * \n        totalLight += inscatteredLight * localDensity * stepSize * transmittance;\n        rayPos += dDist;\n    }\n    \n    return vec4(totalLight * sunColor * 15.0 * absorptionCoefficient, transmittance);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //Fix bad camera angle at start\n    vec2 mouse = iMouse.xy;\n    if (mouse.x == 0.0 && mouse.y == 0.0) {\n        mouse.x = iResolution.x * 0.6;\n    }\n    \n    //Initialize camera\n    float anlge = (mouse.x / iResolution.x - 0.5) * 3.14159265359;\n    float ca = cos(anlge);\n    float sa = sin(anlge);\n    mat3 RotAroundX = mat3(\n        1.0, 0.0, 0.0,\n        0.0,  ca,  sa,\n        0.0, -sa,  ca);\n    vec3 rayDir = normalize(vec3((uv * 2.0 - 1.0) * vec2(1.77777777778, 1.0), 1.0)) * RotAroundX;\n    vec3 camPos = vec3(iTime * 10.0, 100.0 + (mouse.y / iResolution.y - 0.5) * 3000.0, 0.0);\n    \n    //Calculate color\n    vec3 col = vec3(0.027, 0.263, 0.835) * 0.6;\n    if (!(camPos.y > cloudTop && rayDir.y > 0.0) && !(camPos.y < cloudBot && rayDir.y <= 0.0)) {\n        vec4 brightnessAndTransmittance = rayMarch(camPos, rayDir);\n        vec3 cloudColor = brightnessAndTransmittance.xyz;\n        float transmittance = brightnessAndTransmittance.w;\n        col = col * transmittance + cloudColor;\n    }\n    \n    //Convert RGB to sRGB and output result\n    col = pow(col, vec3(0.45454545454545));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}