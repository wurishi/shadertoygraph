{"ver":"0.1","info":{"id":"tldXDn","date":"1580834996","viewed":170,"name":"Otherworldly Allure","username":"ChutneyPot","description":"This was my first shader on Shadertoy. Learning about raymarching and SDFs, I decided to create a shader iteratively to apply the knowledge. \n\n\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Otherworldly Allure, February 2020\n// by Tito Morab - ChutneyPot\n// https://www.shadertoy.com/view/tldXDn\n//--------------------------------------------------------------------------\n#define EPSILON 0.001\n#define GAMMA 2.2\n\n#define CAM_POS vec3(1.0, 0.0, -1.0)\n#define CAM_LOOKAT vec3(0.0, 0.0, 0.0)\n\n#define MAX_STEPS 200\n#define MAX_DIST 100.0\n\n#define BASE_COLOR_MULTIPLIER 0.2;\n#define MAX_SHININESS 32.0\n\n#define SUN_DIR vec3(0.6, 0.9, -0.4)\n#define SUN_COLOR vec3(1.0, 0.8, 0.6)\n#define SUN_INTENSITY 10.0\n\n#define SAND_COLOR vec3(0.7, 0.7, 0.5)\n#define STRUCTURE_COLOR vec3(0.53, 0.27, 0.18)\n\n#define SKY_LIGHT_COLOR vec3(0.0, 0.1, 0.3)\n#define SKY_LIGHT_INTENSITY 1.0\n\n#define BOUNCE_LIGHT_COLOR vec3(0.8, 0.6, 0.4)\n#define BOUNCE_LIGHT_INTENSITY 1.0\n\n#define SKY_COLOR vec3(0.1, 0.9, 1.0)\n#define SPECULAR_COLOR vec3(0.8, 0.8, 0.8)\n#define SHADOW_COLOR vec3(0.25, 0.16, 0.1)\n\nvec3 xSymOp(vec3 pos)\n{\n    return vec3(abs(pos.x), pos.yz);\n}\n\nvec3 zSymOp(vec3 pos)\n{\n    return vec3(pos.xy, abs(pos.z));\n}\n\nvec3 xzSymOp(vec3 pos)\n{\n    return vec3(abs(pos.x), pos.y, abs(pos.z));\n}\n \n\nmat2 rotOp(float angle)\n{\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    return rot;\n}\n    \nvec2 minOp(vec2 obj1, vec2 obj2)\n{\n    vec2 min;\n    \n    if(obj1.x <= obj2.x)\n    {\n        min = obj1;\n    }\n    else\n    {\n        min = obj2;\n    }\n    \n    return min;    \n}\n\nvec2 maxOp(vec2 obj1, vec2 obj2)\n{\n    vec2 max;\n    \n    if(obj1.x >= obj2.x)\n    {\n        max = obj1;\n    }\n    else\n    {\n        max = obj2;\n    }\n    \n    return max;    \n}\n\nfloat sMin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - (k * h * (1.0 - h));\n}\n\nfloat planeSDF(vec3 pos, vec3 up)\n{\n    float dist = dot(normalize(up), pos);\n    return dist;\n}\n\nfloat sphereSDF(vec3 pos, float radius)\n{\n    float dist = length(pos) - radius;\n    return dist;\n}\n\nfloat boxSDF(vec3 pos, vec3 size)\n{\n    float dist = length(max(abs(pos) - size, 0.0));\n    return dist;\n}\n\nfloat vertCapsuleSDF(vec3 pos, float height, float radius)\n{\n    pos.y -= clamp(pos.y, 0.0, height);\n    float dist = length(pos) - radius;\n    return dist;\n}\n\nfloat capCylinderSDF(vec3 pos, float height, float radius)\n{\n    vec2 d = abs(vec2(length(pos.xz), pos.y)) - vec2(radius, height);\n    float dist = min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    return dist;\n}\n\nfloat pillarSDF(vec3 pos, vec3 size, float rounding)\n{\n    float pillarDist = boxSDF(pos, size) - rounding;\n    float baseDist = capCylinderSDF(pos - vec3(0.0, -0.28, 0.0), 0.03, 0.08);\n    \n    float topDist = capCylinderSDF(pos - vec3(0.0, 0.31, 0.0), 0.03, 0.08); \n    float dist = min(pillarDist, min(baseDist, topDist));\n\n    vec3 r = pos;\n    vec3 sym = xzSymOp(r);\n    vec3 c = sym - vec3(0.06, -0.2, 0.06);\n    float carvingDist = vertCapsuleSDF(c, 0.4, 0.03);\n    \n    r.xz *= rotOp(40.0);\n    sym = xzSymOp(r);\n    c = sym - vec3(0.06, -0.2, 0.06);\n    float carvingDist2 = vertCapsuleSDF(c, 0.4, 0.03);\n    carvingDist = min(carvingDist, carvingDist2);\n    \n    return max(dist, -carvingDist);\n}\n\nvec2 structureSDF(vec3 pos)\n{\n    vec3 sym = xzSymOp(pos - vec3(0.0, 0.0, 0.0));\n    vec3 cen = sym - vec3(0.7, 0.0, 0.25);\n    float pillarSet1Dist = pillarSDF(cen, vec3(0.01, 0.3, 0.01), 0.05);\n    \n    sym = xzSymOp(pos - vec3(0.0, 0.0, 1.0));\n    cen = sym - vec3(0.7, 0.0, 0.25);\n    float pillarSet2Dist = pillarSDF(cen, vec3(0.01, 0.3, 0.01), 0.05);\n    \n    float damageDist = vertCapsuleSDF(pos - vec3(0.66, 0.1, 0.2), 0.4, 0.15);\n    pillarSet1Dist = max(pillarSet1Dist, -damageDist);\n    \n    float pillarDist = min(pillarSet1Dist, pillarSet2Dist);\n    \n    sym = xzSymOp(pos - vec3(0.0, 0.0, 2.5));\n    float pyrDist = dot(normalize(vec3(0.1, 0.1, 0.1)), sym - 0.3);\n        \n    float plate1Dist = boxSDF(pos - vec3(0.0, -0.2, 2.5), vec3(1.1, 0.25, 1.1));\n    float plate2Dist = boxSDF(pos - vec3(0.0, 0.3, 2.5), vec3(1.1, 0.2, 1.1));\n    float plate3Dist = boxSDF(pos - vec3(0.0, 0.8, 2.5), vec3(1.1, 0.25, 1.1));\n      \n    pyrDist = min(min(max(pyrDist, plate1Dist), max(pyrDist, plate2Dist)), max(pyrDist, plate3Dist));\n    \n    float strucDist = min(pillarDist, pyrDist);\n    vec2 struc = vec2(strucDist, 2.0);\n    \n    sym = xzSymOp(pos - vec3(0.0, 0.0, 0.5));\n    float pathDist = boxSDF(sym - vec3(0.0, -0.3, 0.0), vec3(0.2, 0.01, 1.0));\n    vec2 path = vec2(pathDist, 3.0);\n    \n    vec2 obj = minOp(struc, path);\n    return obj;\n}\n\nfloat dunes(vec3 pos)\n{\n    float waves = (sin(pos.z + 1.2) * 0.2) - 0.2 + (cos(pos.x + 0.7) * 0.2) - 0.11;\n    \n    float dunes1 = max(min(sin(pos.z  - 2.2), cos(pos.x * 0.5 - 3.0)), 0.0);\n    float dunes2 = max(min(sin(pos.x - 1.5), cos(pos.z * 0.2 - 1.0)), 0.0);\n    \n    return max(max(dunes1, dunes2), waves);\n}\n\nvec2 sceneSDF(vec3 pos)\n{\n    float face1Dist = sphereSDF(pos - vec3(-0.2, 1.3, 2.5), 0.3); \n    float face2Dist = sphereSDF(pos - vec3(0.2, 1.3, 2.5), 0.3);\n    float faceDist = max(face1Dist, face2Dist);\n    \n    float ballDist = sphereSDF(pos - vec3(0.0, 1.3, 2.5), 0.16);\n\tfaceDist = max(faceDist, -ballDist);\n    vec2 face = vec2(faceDist, 4.0);\n    \n    float planeDist = planeSDF(pos - vec3(0.0, -0.3, 0.0), vec3(0.0, 1.0, 0.0)) - dunes(pos);\n    vec2 plane = vec2(planeDist, 1.0);\n    \n    vec2 struc = structureSDF(pos);\n    vec2 scene = minOp(minOp(plane, struc), face);\n    \n    return mix(scene, plane, round(sin(iTime * 0.5 + 1.0) * 0.5 + 0.5));\n    //return minOp(plane, scene);\n}\n\nvec2 rayMarch(vec3 rayOrig, vec3 rayDir)\n{\n    float t = 0.0;\n    float id = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 pos = rayOrig + t * rayDir;\n        \n        vec2 dist = sceneSDF(pos);\n        \n        if(dist.x < EPSILON)\n        {\n            id = dist.y;\n            break;\n        }\n        \n        t += dist.x;\n        \n        \n        if(t > MAX_DIST)\n            break;\n    }\n    \n    return vec2(t, id);\n}\n\nvec3 getNormal(vec3 pos)\n{\n    vec2 e = vec2(EPSILON, 0.0);\n    vec3 normal = normalize(vec3(sceneSDF(pos + e.xyy).x - sceneSDF(pos - e.xyy).x,\n                       sceneSDF(pos + e.yxy).x - sceneSDF(pos - e.yxy).x,\n                       sceneSDF(pos + e.yyx).x - sceneSDF(pos - e.yyx).x));\n        \n    return normal;\n}\n\nvec3 getLighting(vec3 pos, vec3 viewDir, float specIntensity, float shininess)\n{   \n    vec3 normal = getNormal(pos);\n    \n    float nDotL = clamp(dot(normal, SUN_DIR), 0.0, 1.0);\n    vec3 sunCol = SUN_COLOR * nDotL;\n    sunCol *= SUN_INTENSITY * BASE_COLOR_MULTIPLIER;\n    \n    nDotL = clamp(dot(normal, vec3(0.0, 1.0, 0.0)) * 0.5 + 0.5, 0.0, 1.0);\n    vec3 skyCol = SKY_LIGHT_COLOR * nDotL;\n    skyCol *= SKY_LIGHT_INTENSITY * BASE_COLOR_MULTIPLIER;\n    \n    nDotL = clamp(dot(normal, vec3(0.0, -1.0, 0.0)) * 0.5 + 0.5, 0.0, 1.0);\n    vec3 bounceCol = BOUNCE_LIGHT_COLOR * nDotL;\n    bounceCol *= BOUNCE_LIGHT_INTENSITY * BASE_COLOR_MULTIPLIER;\n    \n    //vec3 reflectDir = reflect(SUN_DIR, normal);\n    vec3 halfwayDir = normalize(SUN_DIR + viewDir);\n    float power = shininess * MAX_SHININESS;\n    float spec = pow(max(dot(halfwayDir, viewDir), 0.0), power);\n    vec3 specCol = spec * specIntensity * SPECULAR_COLOR;\n    \n    float dist = rayMarch(pos + normal * 0.001, SUN_DIR).x;\n    if(dist < length(SUN_DIR))\n    {\n        return sunCol * SHADOW_COLOR + skyCol + bounceCol;\n    }\n    \n    return sunCol + skyCol + bounceCol + specCol; \n}\n\nvec3 getRayDir(vec3 pos, vec3 lookAt, vec2 uv, float fov)\n{  \n    float z = 1.0 / tan((radians(fov) / 2.0));\n    \n    vec3 zDir = normalize(lookAt - pos);\n    vec3 xDir = normalize(cross(vec3(0.0, 1.0, 0.0), zDir));\n    vec3 yDir = normalize(cross(zDir, xDir));\n    \n    vec3 rayDir = normalize(vec3(uv.x * xDir + uv.y * yDir + z * zDir));\n    return rayDir;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    float angle = 0.0;//10.0 * iMouse.x / iResolution.x;\n    vec3 rayOrig = CAM_POS * vec3(-sin(angle), 1.0, cos(angle));\n    vec3 rayDir = getRayDir(rayOrig, CAM_LOOKAT, uv, 60.0);\n    vec3 viewDir = normalize(CAM_LOOKAT - rayOrig);\n    \n    vec3 col = mix(SKY_COLOR, vec3(0.9, 0.9, 0.9), 1. - sqrt(rayDir.y));\n    \n    vec2 dist = rayMarch(rayOrig, rayDir);\n    \n    if(dist.x < MAX_DIST)\n    {\n        vec3 pos = rayOrig + dist.x * rayDir;   \n  \n        if(dist.y < 1.5)\n        {\n            col = SAND_COLOR * getLighting(pos, viewDir, 0.2, 1.0);// * (texture(iChannel0, vec2(pos.x * 4.0, pos.z * 4.0)).x - 0.07) * 2.0;\n        }\n        else if(dist.y < 2.5)\n        {\n            col = STRUCTURE_COLOR * getLighting(pos, viewDir, 1.0, 0.1) * texture(iChannel1, vec2(pos.y, pos.z)).xyz;\n        }\n        else\n        {\n            col = STRUCTURE_COLOR * getLighting(pos, viewDir, 1.0, 0.1) * texture(iChannel1, vec2(pos.x * 8.0, pos.z * 16.0)).xyz;\n        }\n\n        col = pow(col, vec3(1.0 / GAMMA));\n        //col = getNormal(pos);\n    }\n    \n    col *= smoothstep(0.0, 1.0, 1.0 - length(uv.x * uv.y) + sin(iTime));\n    //col = texture(iChannel2, rayDir).xyz;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}