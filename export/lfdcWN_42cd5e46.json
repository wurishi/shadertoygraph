{"ver":"0.1","info":{"id":"lfdcWN","date":"1730693221","viewed":79,"name":"Circle-polygon analytic overlap","username":"benoneal","description":"Implementation and testing for the solution in the link. Fixes several bugs in that solution and extends it to arbitrary polygons. \nhttps://stackoverflow.com/questions/540014/compute-the-area-of-intersection-between-a-circle-and-a-triangle","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["triangle","intersection","circle","hexagon","area","polygon","overlap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\n#define POLY_SIDES 6\n#define POLY_RAD 0.25\n#define CIRCLE_RAD 0.21\n\nstruct Triangle {\n  vec2 a;\n  vec2 b;\n  vec2 c;\n};\n\nstruct Polygon {\n  vec2 corners[POLY_SIDES];\n  float angles[POLY_SIDES];\n  vec2 center;\n};\n\nvec2 xy2uv(vec2 xy) {\n  vec2 uv = xy / iResolution.xy;\n  uv -= 0.5;\n  uv.x *= iResolution.x / iResolution.y;\n  return uv;\n}\n\nfloat sdTriangle(in vec2 p, in Triangle t) {\n  vec2 e0 = t.b - t.a;\n  vec2 e1 = t.c - t.b;\n  vec2 e2 = t.a - t.c;\n\n  vec2 v0 = p - t.a;\n  vec2 v1 = p - t.b;\n  vec2 v2 = p - t.c;\n\n  vec2 pq0 = v0 - e0 * clamp(dot(v0, e0) / dot(e0, e0), 0.0, 1.0);\n  vec2 pq1 = v1 - e1 * clamp(dot(v1, e1) / dot(e1, e1), 0.0, 1.0);\n  vec2 pq2 = v2 - e2 * clamp(dot(v2, e2) / dot(e2, e2), 0.0, 1.0);\n\n  float s = e0.x * e2.y - e0.y * e2.x;\n  vec2 d = min(min(vec2(dot(pq0, pq0), s * (v0.x * e0.y - v0.y * e0.x)), vec2(dot(pq1, pq1), s * (v1.x * e1.y - v1.y * e1.x))), vec2(dot(pq2, pq2), s * (v2.x * e2.y - v2.y * e2.x)));\n\n  return -sqrt(d.x) * sign(d.y);\n}\n\nvec2 poly_corner(vec2 center, float i) {\n  float angle_step = 360./float(POLY_SIDES);\n  float angle_deg = angle_step * i - angle_step*0.5;\n  float angle_rad = PI / 180. * angle_deg;\n  return vec2(center.x + POLY_RAD * cos(angle_rad), center.y + POLY_RAD * sin(angle_rad));\n}\n\n\n\nfloat edgeSD(vec2 a, vec2 b, vec2 bc, vec3 p) {\n  vec2 dir = normalize(b - a);\n  vec2 n = a + dir * dot(p.xy - a, dir);\n  float s = sign(dot(p.xy - n, n - bc));\n  return max(-1., distance(p.xy, n) * s / p.z);\n}\n\nfloat angle(vec2 a, vec2 b) {\n  return acos(clamp(dot(normalize(a), normalize(b)), -1.0, 1.0));\n}\n\nPolygon polygon(vec2 c) {\n  Polygon p;\n  p.center = c;\n  for (int i = 0; i < POLY_SIDES; i++) {\n    p.corners[i] = poly_corner(c, float(i));\n    vec2 a = p.corners[i] - poly_corner(c, float((i + 1) % POLY_SIDES));\n    vec2 b = poly_corner(c, float((i + 2) % POLY_SIDES)) - poly_corner(c, float((i + 1) % POLY_SIDES));\n    p.angles[i] = angle(a, b);\n  }\n  return p;\n}\n\nfloat segmentArea(float ed) {\n  float h = clamp(ed + 1.0, 0.0, 2.0);\n  return acos(1.0 - h) - (1.0 - h) * sqrt(2.0 * h - h * h);\n}\n\nfloat excessArea(float d0, float d1, float angle) {\n  angle = PI - angle;\n  vec2 i0 = vec2(-cos(asin(d0)), -d0);\n  vec2 i1 = vec2(cos(angle + asin(-d1)), sin(angle + asin(-d1)));\n  vec2 p = vec2(-cos(angle) / sin(angle) * d0 + d1 / sin(angle), -d0);\n\n  if (dot(p, p) > 1.0) {\n    bool b0 = p.x < i0.x;\n    bool b1 = p.y > i1.y;\n    if (b0 == b1)\n      return 0.0;\n    if (b0)\n      return segmentArea(d1);\n    return segmentArea(d0);\n  }\n\n  float triangle_area = 0.5 * distance(p, i0) * distance(p, i1) * sin(PI - angle);\n  float segment_angle = asin(d0) - angle - asin(-d1) + PI;\n  float segment_area = 0.5 * (segment_angle - sin(segment_angle));\n  return triangle_area + segment_area;\n}\n\nfloat overlap(Polygon p, vec3 s) {\n  float edges[POLY_SIDES];\n  for (int i = 0; i < POLY_SIDES; i++) {\n    edges[i] = edgeSD(p.corners[i], p.corners[(i + 1) % POLY_SIDES], p.center, s);\n  }\n  float inv_area = 0.0;\n  for (int j = 0; j < POLY_SIDES; j++) {\n    inv_area += segmentArea(edges[j]);\n    inv_area -= excessArea(edges[j], edges[(j + 1) % POLY_SIDES], p.angles[j]);\n  }\n  return clamp((PI - inv_area) / PI, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = xy2uv(fragCoord);\n  bool in_triangle = false;\n\n  vec3 circle = vec3(-0.0, -0.0, CIRCLE_RAD);\n  Polygon p = polygon(vec2(0., 0.));\n  Triangle t[POLY_SIDES];\n  for (int i = 0; i < POLY_SIDES; i++) {\n    t[i].a = p.center;\n    t[i].b = p.corners[i];\n    t[i].c = p.corners[(i + 1) % POLY_SIDES];\n    in_triangle = in_triangle || sdTriangle(uv, t[i]) <= 0.0;\n  }\n\n  if (iMouse.z > 0.) {\n    circle.xy = xy2uv(iMouse.xy);\n  }\n\n  float o = overlap(p, circle);\n  bool in_circle = distance(uv, circle.xy) <= circle.z;\n  vec3 col = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0, 2, 4));\n  vec3 ocol = vec3(o);\n  col = in_triangle ? in_circle ? ocol : col : in_circle ? col : o <= 0. ? vec3(0.25) : ocol;\n\n  fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}