{"ver":"0.1","info":{"id":"cltcDf","date":"1699761680","viewed":30,"name":"Holography (conjugate)","username":"Fuergu","description":"Demonstrate the process of holographic imaging to reproduce the wavefront of physical light.\nThanks to  https://www.shadertoy.com/view/DtKSDW   by Quazi","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","simulation","physics","optics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**********************************************************\nYou can move the mouse to change the direction of the \nreference light.\n\nOn the left, a point light source (spherical wave) is used \nas the object light, a uniform plane wave is used as the \nreference light, the two interfere, and the fringes are \nrecorded on a light-sensitive negative in the center.\n\nThe right side is a reference light illuminating the negative \nfrom the left side, and thus reproduce the object.\n**********************************************************/\n// 1: Reconstruction using conjugate light, 0: Otherwise\n#define isconjugate 1\n\n// Number of sampling points\n#define Sample 1500\n\n/*\nReproducing with a conjugate reference light will give \na solid image, while using the original will give an imaginary \nimage.\n*/\n\nconst float PI = 3.14159265359;\nconst float freq = 10.;\nconst float amp = 1.;\n\n//Parallel plane wave propagation direction\n#define angle (iMouse.y/iResolution.y+1.5)\n/**********************************************************\n**********************************************************/\nvec2 plane_wave( vec2 uv, float time, float freq, float amp, float phase, vec2 dir,float S )\n{\n    float w= dot(uv, dir) * S;\n    float t=((w - time) * freq + phase) * 2.0 * PI;\n    return amp*vec2(sin(t), cos(t));\n}\n\nvec2 point_wave( vec2 uv, float time, float freq, float amp, float phase, vec2 pos,float S )\n{\n    //this represents a column into Z rather than a point, hence like field around wire.\n    float w = length(uv-pos) * S;\n    float r_sqd = w;\n    float t=((w - time) * freq + phase )* 2.0 * PI;\n    return amp*vec2(sin(t),cos(t))/(length(uv-pos) * 50.);\n}\n\n\nvec2 ref_beam( vec2 uv, float t,float S)\n{\n    float ang = PI * angle;\n    vec2 dir= vec2(cos(ang), sin(ang));\n    return plane_wave(uv, t, freq, amp, 0., dir,S);\n}\n\n\nfloat hologram_exposure(vec2 hologram,float holo_mag){\n    // simulate exposing the holographic film and the non-linear effects it can have.\n    // exposure is ultimately what modulates incoming wave.\n    // there's a sweet spot for mapping the hologram to an exposure to maximize the spike\n\n    float exposure = 0.;\n    if(hologram.x*hologram.x+hologram.y*hologram.y>1.)\n    exposure = .5;\n    else\n    exposure = 0.;\n    return exposure;\n    //return exposure*pow((holo_mag-1.),.1);\n}\n\nvec2 hologram( vec2 uv, float t, vec2 pos,float S)\n{   \n    vec2 wave = vec2(0.);\n    wave += ref_beam(uv, t,S);\n    wave += point_wave(uv, t, freq, amp, iTime, pos,S);\n    return wave;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x;\n    float t = iTime*0.001;\n    \n    //scale factor (what does 1 unit equal (e.g. 100 pixels = 1 unit -> S=100.0))\n    //float S = 50.*(0.5*cos(iTime)+0.5)*0.2;\n    float S = 20.;\n    \n    // Hologram consts\n    float holo_thickness = 0.005;\n    float holo_height = iResolution.y/iResolution.x;\n    vec2 holo_pos = vec2(0.5, holo_height*0.5);\n    \n    vec2 mouse_uv = iMouse.xy/iResolution.x;\n    mouse_uv.x = clamp(0.,0.5,mouse_uv.x);\n    if(length(iMouse.zw - vec2(0.0,0.0))<4.0){\n        float ang = iTime;\n        mouse_uv = vec2(0.25,holo_height*0.5)+vec2(cos(ang*3.0), sin(ang*1.1)*1.5)*0.1;\n    }\n\n\n    \n    // Pixel color\n    vec4 col = vec4(0.);\n    vec2 wave = vec2(0.);\n    \n    // Draw a the hologram film\n    vec2 holo = hologram(uv, t, mouse_uv,S);\n    float holo_mag = length(hologram(uv, t, mouse_uv,S));\n    // we may want ref beam too\n    vec2 ref_wave = ref_beam(uv, t,S);\n    \n    if(uv.x < holo_pos.x){\n        // draw the left hand side (reference beam)\n        wave = holo;\n        //wave = vec2(holo.y);\n        if(isconjugate<1 && iMouse.z>0.)\n        {\n        wave = vec2(0.);\n        // draw the right hand side (interference from hologram film)\n        //int N = int(100.*iTime);\n        int N = Sample;\n        float E_chunk = (S * holo_height * amp) / float(N);\n        vec2 wave_chunk = vec2(0.);\n        for (int i = 0; i < N; i++) {\n            // need total energy of the wavefront???\n            // Scale factor is important.\n            float ang = -PI*float(isconjugate*2-1)*angle;\n            vec2 dir= -vec2(cos(ang), sin(ang));\n            vec2 integral_uv = vec2(holo_pos.x, ((float(i)+0.5)/float(N))*holo_height);\n            //float integral_holo_mag = length(hologram_exposure(hologram(integral_uv, t, mouse_uv)));\n            float integral_holo_mag = hologram_exposure(hologram(integral_uv, t, mouse_uv,S),holo_mag);\n            float integral_phase = dot(integral_uv, dir) * S * freq + integral_holo_mag;\n            wave_chunk += point_wave(uv, t, freq, 1.0, integral_phase, integral_uv,S);\n        }\n        wave += wave_chunk * E_chunk;\n        }\n    }else{\n        // draw the right hand side (interference from hologram film)\n        //int N = int(100.*iTime);\n        int N = Sample;\n        float E_chunk = (S * holo_height * amp) / float(N);\n        vec2 wave_chunk = vec2(0.);\n        for (int i = 0; i < N; i++) {\n            // need total energy of the wavefront???\n            // Scale factor is important.\n            float ang = -PI*float(isconjugate*2-1)*angle;\n            vec2 dir= vec2(cos(ang), sin(ang));\n            vec2 integral_uv = vec2(holo_pos.x, ((float(i)+0.5)/float(N))*holo_height);\n            //float integral_holo_mag = length(hologram_exposure(hologram(integral_uv, t, mouse_uv)));\n            float integral_holo_mag = hologram_exposure(hologram(integral_uv, t, mouse_uv,S),holo_mag);\n            float integral_phase = dot(integral_uv, dir) * S * freq + integral_holo_mag;\n            wave_chunk += point_wave(uv, t, freq, 1.0, integral_phase, integral_uv,S);\n        }\n        wave += wave_chunk * E_chunk;\n    }\n        \n    vec2 cancel_wave = wave;\n    float mag_disp = length(wave);\n    if (uv.x<.5){\n    col.r = pow(log(1.*mag_disp),.6);\n    col.g = log(1.*mag_disp)*5.;\n    col.b = log(1.5*mag_disp);\n        if(iMouse.z>0.&& isconjugate == 0)\n        {\n        col.r = log(8.*mag_disp);\n        col.g = log(4.*mag_disp);\n        col.b = log(1.*mag_disp);\n        }\n    }else{\n    col.r = log(5.*mag_disp);\n    col.g = log(11.*mag_disp);\n    col.b = log(10.*mag_disp); \n    }\n    if(mag_disp < 0.1){\n       col.b = 1.0-exp(-8.0*(0.1-mag_disp));\n    }\n    //col.b = holo_mag;\n    if(abs(uv.x-holo_pos.x) < holo_thickness){ \n        //col.rgb = vec3(40.*(holo_mag-1.));\n        col.r = 40.*(holo_mag-1.);\n        col.g = 10.*(holo_mag-1.);\n        col.b = 0.;\n    }\n    \n    // Output to screen\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}