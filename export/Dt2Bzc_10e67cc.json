{"ver":"0.1","info":{"id":"Dt2Bzc","date":"1694330814","viewed":36,"name":"Mandelbrot X","username":"Domenic3000","description":"Mandelbrot zoom","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct DoubleFloat {\n    vec2 high; // High precision part\n    vec2 low;  // Low precision part\n};\n\n// 1. Define the MandelbrotResult structure\nstruct MandelbrotResult {\n    int iteration;\n    DoubleFloat z;\n};\n\nvec3 palette(float t, vec3 c1, vec3 c2, vec3 c3, vec3 c4) {\n    float x = 1.0 / 3.0;\n    if (t < x) return mix(c1, c2, t/x);\n    else if (t < 2.0 * x) return mix(c2, c3, (t - x)/x);\n    else if (t < 3.0 * x) return mix(c3, c4, (t - 2.0*x)/x);\n    return c4;\n}\n\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 adjustHueSaturation(vec3 color, float hueShift, float saturationFactor) {\n    vec3 hsv = rgb2hsv(color);\n    hsv.x = mod(hsv.x + hueShift, 1.0);\n    hsv.y *= saturationFactor;\n    return hsv2rgb(hsv);\n}\n\nvec3 adjustBrightnessContrast(vec3 color, float brightness, float contrast) {\n    return (color - 0.5) * contrast + 0.5 + brightness;\n}\n\nDoubleFloat dfSquare(DoubleFloat a) {\n    DoubleFloat result;\n    result.high = a.high * a.high;\n    result.low = a.low * a.low;\n    return result;\n}\n\nDoubleFloat dfAdd(DoubleFloat a, DoubleFloat b) {\n    vec2 highSum = a.high + b.high;\n    vec2 lowSum = a.low + b.low + (highSum - a.high - b.high);\n    vec2 correctedHigh = highSum + (lowSum - (lowSum - a.low - b.low));\n    return DoubleFloat(correctedHigh, lowSum - (correctedHigh - highSum));\n}\n\nDoubleFloat dfMul(DoubleFloat a, DoubleFloat b) {\n    vec2 highProduct = a.high * b.high;\n    vec2 crossProduct1 = a.high * b.low;\n    vec2 crossProduct2 = a.low * b.high;\n    vec2 lowProduct = a.low * b.low;\n    \n    vec2 sumOfCrossProducts = crossProduct1 + crossProduct2;\n    vec2 correctedHigh = highProduct + sumOfCrossProducts;\n    vec2 low = lowProduct + (sumOfCrossProducts - (correctedHigh - highProduct));\n    \n    return DoubleFloat(correctedHigh, low);\n}\n\nDoubleFloat dfAddDoubleFloat(DoubleFloat a, DoubleFloat b) {\n    DoubleFloat result;\n    result.high = a.high + b.high;\n    result.low = a.low + b.low;\n    return result;\n}\n\nDoubleFloat dfAddVec2(DoubleFloat a, vec2 b) {\n    DoubleFloat result;\n    result.high = a.high + b;\n    result.low = a.low;\n    return result;\n}\n\nDoubleFloat dfSubVec2(DoubleFloat a, vec2 b) {\n    DoubleFloat result;\n    result.high = a.high - b;\n    result.low = a.low;\n    return result;\n}\n\n// Helper function to convert vec2 to DoubleFloat\nDoubleFloat vec2ToDoubleFloat(vec2 v) {\n    return DoubleFloat(v, vec2(0.0, 0.0));\n}\n\nMandelbrotResult mandelbrot(DoubleFloat c) {\n    DoubleFloat z = DoubleFloat(vec2(0.0), vec2(0.0));\n    int n = 0;\n    for(int i = 0; i < 500; i++) {\n        DoubleFloat z2;\n        z2.high.x = z.high.x * z.high.x - z.high.y * z.high.y;\n        z2.high.y = 2.0 * z.high.x * z.high.y;\n        \n        z2.low.x = z.low.x * z.low.x - z.low.y * z.low.y;\n        z2.low.y = 2.0 * z.low.x * z.low.y;\n        \n        z = dfAdd(z2, c);             // This applies the iterative formula\n        if(dot(z.high, z.high) > 4.0) break;\n        n++;\n    }\n    MandelbrotResult result;\n    result.iteration = n;\n    result.z = z;\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Step 1: Normalized coordinates from -1.0 to 1.0\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n\n    // Step 2: Apply the zoom function\n    float initialZoom = 1.0;\n    float zoomRate = 1.25;\n    float zoom = initialZoom * pow(zoomRate, mod(iTime, 48.0));\n    \n    uv /= zoom;\n\n    // Step 3: Correct for the aspect ratio\n    float aspect = iResolution.y / iResolution.x;\n    uv.y *= aspect;\n\n    vec2 zoomCenter;\n    zoomCenter.x = -0.748;\n    zoomCenter.y = 0.107 * aspect; // Adjusted zoom center for a boundary in Seahorse Valley\n    uv += zoomCenter;\n\n    // Step 5: Compute the Mandelbrot set for the resulting coordinates\n    DoubleFloat c = DoubleFloat(uv, vec2(0.0));\n    MandelbrotResult result = mandelbrot(c);\n    int n = result.iteration;\n\n    // Coloring\n    vec3 col;\n    if (n < 500) {\n        col = palette(float(n) / 500.0, \n                      vec3(0.6, 0.2, 0.2), \n                      vec3(0.2, 0.6, 0.2), \n                      vec3(0.2, 0.2, 0.7), \n                      vec3(0.6, 0.6, 0.2));\n    } else {\n        col = vec3(0.9, 0.5, 0.3);\n    }\n\n    // Adjustments\n    col = adjustBrightnessContrast(col, 0.3, 3.2);\n    col = adjustHueSaturation(col, mod(iTime/40.0,1.0), 1.5);\n\n    fragColor = vec4(col, 1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}