{"ver":"0.1","info":{"id":"XsGXzz","date":"1462416505","viewed":282,"name":"Mapped Text","username":"akohdr","description":"Space mapping of simple checkerboard with animated overlay of text.\nMouse sizes characters and shows unmapped texture.\n(not sure why not working on iPad.....)","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["2d","text","distortion","font","mapping","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Multipass example of animated text over checkboard warped to circle\n//\n\n#define DIM vec2(26,9)\n#define BLK vec4(0)\n\n#define PI  3.14159265358979\n#define TAU 6.28318530717858\n\nvec2 polar(vec2 p)\n{\n    float x = p.x,  \n          y = p.y,\n          a = atan(abs(y/x)),\n          r = sqrt(x*x+y*y);\n    a = x>0. ? y>0. ?    a : TAU-a :\n               y>0. ? PI-a :  PI+a;\n                   \n\treturn vec2(r, a);    \n}\n\nbool inUnit(vec2 v)\n{\n    return v.x>=0. && v.x<=1. && v.y>=0.  && v.y<=1.;\n}\n\nvec4 inTex(vec2 uv) \n{\n    return inUnit(uv) ? texture(iChannel0, uv) : BLK;\n}\n\nvec2 mapToTex(float x, float y, float w) \n{\n    return vec2(mod(x,w), y + floor(x/w));\n}\n\nvoid mainImage( out vec4 k, in vec2 p )\n{\n    k = vec4(0);\n\n\tvec2 ir = iResolution.xy,\n         ir2 = ir/2.,\n         uv = p.xy / ir,\n         rs;\n    \n    float sy = ir.y/DIM.y,\n          sx = ir.x/DIM.x;\n\n\t// We use a polar coord transformation to warp rectangle to circle\n    vec2 pol = polar(p-ir2).yx;\n    pol = vec2(-pol.x/TAU, .2+pol.y/ir2);\n\n    uv = pol*ir;\n    uv = mapToTex(uv.x, uv.y, ir.x);\n    uv /= ir;\n    \n    k = inTex(iMouse.z>0. ? p/ir : uv);\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Simple B&W/HSV/RGB checkerboard, various flags and options\n//\n\n//#define BW_CHECKER\n#define COLOR_MAP HSV\n//#define COLOR_MAP RGB\n\n// board dimensions\n//#define DIM vec2(3,2)\n//#define DIM vec2(6,4)\n//#define DIM vec2(16,9)\n#define DIM vec2(26,9)\n\n#define HSV hsv2rgb\n#define RGB(a,c,b) vec3(a,b,c) \n\n#define FACTOR 1.\n//#define FACTOR 17.\n\n// absolute size (overrides DIM)\n//#define SIZE vec2(8)\n//#define SIZE vec2(32)\n//#define SIZE vec2(64)\n\n//#define RATIO .25\n//#define RATIO .5\n//#define RATIO .75\n#define RATIO 1.\n\n#define BLK vec4(0)\n#define WHT vec4(1)\n#define GRY vec4(.5)\n\n#define EVERY(x,n) (float(x)/float(n))\n#define EVEN(x) (mod(x,2.)<RATIO)\n#define XOR(a,b) (a && !b) || (!a && b)\n#define CHECKER(v,n) XOR(EVEN(EVERY(v.x,n.x)),EVEN(EVERY(v.y,n.y)))\n\nvec3 hsv2rgb(float a,float b,float c)\n{\n\treturn c * (1. - b * smoothstep(2., 1., abs( mod( a*6.+vec3(0,4,2), 6.) -3.) ));\n}\n\nvoid mainImage( out vec4 k, in vec2 p )\n{\n    k = vec4(0);\n    vec2 ir = iResolution.xy;\n        \n#ifndef SIZE\n    vec2 SIZE = vec2(ir.x/DIM.x, ir.y/DIM.y);\n#endif\n        \n    vec2 u = p/ir;\n    \n#ifdef BW_CHECKER\n    k = CHECKER(p, SIZE) ? BLK : WHT;\n#else\n    // ir/DIM is not piecewise ?!\n    k = CHECKER(p, SIZE) ? GRY : vec4(COLOR_MAP(FACTOR*u.x, .5, 2.*u.y),1);\n#endif\n    \n    k += texture(iChannel0, u);\n}\n\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Animated font overlay (uses temporal primitives)\n//\n\n#define STAGGERED\n//#define SLOW_MO\n\n// Use debug flag to colour primitives RGB\n//#define DEBUG\n\n#define INK vec4(.3,.2,1,1)\n#define LINE_WIDTH 1.7\n//#define LINE_WIDTH 5.1\n\n// Select screen mode text res. size\n#define MODE vec2(26,9)\n// two chars per cell\n//#define MODE vec2(52,9)\n\n// Using point to line distances gives us an antialiasing pointcut we can exploit\nvoid antialias(inout vec4 k, float d, float w, vec4 K) {\n    // Standard filled antialiased lines\n    k += K*(w-d);\n\n    // Neon glow\n//    k += K/d;\n    \n\t// Partially stenciled lines \n//    k += K*sin(d-w);\n    \n    // Hollow lines (provides reasonable high res. legibility)\n//    k += K*cos(1.5+d-w);\n    \n    // Center line plus outline\n//  k += K*tan(.2+d-w);\n    \n    // Stripe filled (using screen x/y would give stable fill)\n//    k += K*max(K*cos(d-w), cos(7.*(d-w)));\n    \n    // Temporally striped and outlined\n//  k += K*max(K*cos(d-w), 1.+2.*cos(7.*(d-w)*(1.1+sin(iTime/2.))));\n    \n    // Flashing font (temporal)\n//    k += K*max(K*cos(d-w), sin(5.*iTime));\n}\n\n\n//=============================================================================\n// The primitives.\n\n#define PI  3.14159265358979\n#define TAU 6.28318530717858\n\nvec2 rot2D(vec2 p, float a) \n{\n    vec3 csa = vec3(cos(a),-sin(a),0);\n               csa.z = -csa.y;\n    return p * mat2( csa.xyzx);\n}\n\n           \nvec2 polar(vec2 p)\n{\n    float x = p.x,  \n          y = p.y,\n          a = atan(abs(y/x)),\n          r = sqrt(x*x+y*y);\n    a = x>0. ? y>0. ?    a : TAU-a :\n               y>0. ? PI-a :  PI+a;\n                   \n\treturn vec2(r, a);    \n}\n\n\nfloat dLine(vec2 p, vec2 a, vec2 b) \n{\n    b -= a;  \n    p -= a;\n    return length (p - clamp (dot (p, b) / dot (b, b), .0, 1.) * b);\n}\n\n\nvec2 linePos(vec2 a, vec2 b, float t)\n{\n\tt = clamp(t,0.,1.);\n    vec2 d = b - a;\n    return a + t * d;\n}\n\nfloat dCircle(vec2 p, vec2 a, float r, float w)\n{\n    float w2 = w/2.,\n           l = length(p-a);\n    return (l>r) ? abs((l-r)+w2): abs((r-l)-w2);\n}\n\n\nvec2 cirPos(vec2 a, float r, float t)\n{\n    return a+r*vec2(cos(TAU*t),sin(TAU*t));\n}\n\nfloat dCircle(vec2 p, vec2 a, float r, float w, float t, float s)\n{\n    t *= TAU;\n    vec2 pa = rot2D(p-a,abs(s)),\n        pol = polar(pa);\n    float l = length(pa),\n         w2 = w/2.;\n    \n    bool bo = s<0. ? pol.y < TAU-t : pol.y > t;\n        \n    return (pol.x>r+w || bo) ? 1e9 : \n    \t\t(l>r) ? abs((l-r)+w2) : abs((r-l)-w2);\n}\n\nvec2 bzPos(float t, vec2 a, vec2 b, vec2 c) \n{\n    float mT = 1.-t;\n    vec2 pos = mT*mT*a+2.*t*mT*b+t*t*c;\n    return pos;\n}\n\nfloat dBezierSegs(vec2 p, vec4 ac, vec2 b, float dt) {\n    float d = 9999.;\n    vec2 a = ac.xy, c = ac.zw, q = a, r;\n    \n    for(float t=0.; t<=1.; t+=.03) {\n        r = bzPos(t,a,b,c);\n        d = min(d, dLine(p,q,r));   //TODO make temporal\n        q = r;\n        if(t>dt) return d;\n    }\n    \n    return d;\n}\n\nvoid bezier(inout vec4 k, vec2 p, vec4 ac, vec4 bw, vec4 K, float t) {\n    if(t<.1) return;\n#ifdef DEBUG \n    K = RED; \n#endif\n    \n    float d = dBezierSegs(p,ac,bw.xy,t);\n    if(d<bw.z) antialias(k,d,bw.z,K);\n}\n\nvoid circle(inout vec4 k, in vec2 p, vec4 a, vec4 K, float t, float s) \n{\n    if(t<.1) return;\n#ifdef DEBUG \n    K = GRN; \n#endif\n    float r = a.z,\n          w = a.w,\n          w2 = w/2.,\n          l = length(p-a.xy),\t\t\t\t\t\t\t// distance from p to center\n          d = dCircle(p,a.xy,r,w,t,s);\n    if(d<w) antialias(k,d,w,K);\n}\n\nvoid line(inout vec4 k, vec2 p, vec4 l, float w, vec4 K, float t) \n{\n    if(t<.1) return;\n#ifdef DEBUG \n    K = BLU; \n#endif\n    vec2 a = l.xy, \n         b = l.zw;\n    \n    float d = dLine(p,a,linePos(a,b,t));\n    if(d<w) antialias(k,d,w,K);\n}\n\n//=============================================================================\n// We (micro)codify the control point data to drive the rendering process\n\n// input params getting unwieldy start using context struct\nstruct glyphCtx {\n    vec2 p; \t\t// fragCoord\n    vec2 s; \t\t// scale XY\n    float w; \t\t// line width\n    vec4 K;\t\t\t// colour\n    mat4 gp; \t\t// glyph microcode\n    int gw;\t\t\t// glyph width\n    float t;\t\t// time\n};\n\nvoid procGlyph(inout vec4 k, inout vec4 c, \n               glyphCtx g)\n{\n    vec2 s = g.s;\n    \n    vec4 ss = vec4(s,s);\n    bool skip = false;\n    for(int i=0;i<4;i++) {\n        if(skip) {skip = false; continue;}\n        \n        float t = g.t-float(i)/2.;\n        vec4 u = ss*g.gp[i];\n        if(u.x<0.)\n            if(u.z<0.){ // second point x \n                vec4 v = ss*g.gp[i+1]; skip = true;\n                bezier(k, g.p, vec4(-u.x,u.y,-u.z,u.w), vec4(v.xy,g.w,0.), g.K, t);\n            }\n        else\n            circle(k, g.p, vec4(-u.x,u.yz,g.w), g.K, t, u.w);\n        else\n            if(u.z>0.)   // 0 is NOP\n                line(k, g.p, u,g.w, g.K, t);\n    }\n    // advance cursor in font x direction (proportional font)\n    c.x += s.x*float(g.gw);\n}\n\n// glyph functions ============================================================\n// hanging macro (compile quicker less source noise)\n//#define PROC procGlyph(k,c,p,s,w,K,mat4(\nmat4 retMat(mat4 m, int w) { return m; }\n#define PROC retMat(mat4(\n#define Z4 0,0,0,0\n#define Z8 Z4,Z4\n\n//The 'eidos' of the font.....\n\n//#define R 6.\n#define R 8.\n//#define R 10.\n#define a_    PROC -6,-2,.8*R,-4, \tZ4,\t\t\t -2,8,-13,-8, \t16,15,0,0),\t\t20)\n#define b_    PROC 1,20,1,-7,   \tZ4,          -8,0,R,-4,   \tZ4),\t\t\t20)\n#define c_    PROC -13,5,-1,0,   \t3,12,0,0, \t -1,0,-14,-3,   -2,-12,0,0), \t22)\n#define d_    PROC -5,0,R,0,  \t\tZ4,          13,20,13,-7,   Z4), \t\t\t20)\n#define e_    PROC  -1,-2,-6,6,   \t25,2,0,0,\t -6,6,-15,-6,   -8,-10,0,0), \t22)\n#define f_    PROC -9,18,-2,-8,  \t1,25,0,0,    Z4,            1,4,9,5),\t    14)\n#define g_    PROC -7,0,R,0,   \t\tZ4,          -15,8,-1,-16,  17,-28,0,0),    22)\n#define h_    PROC 1,20,1,-8,   \tZ4,          -1,4,-14,-8,   13,15,0,0),     18)\n#define i_    PROC -2,7,-4,-6,  \t-1,-16,0,0,  Z4,            -3,13,2,0), \t10)\n#define j_    PROC -5,7,-1,-10, \t8,-25,0,0,   Z4,            -5,13,2,0), \t12)\n#define k_    PROC 1,18,1,-8,   \t13,6,1,-2,   Z4,            5,0,13,-8), \t18)\n#define l_    PROC -1,19,-6,-5,  \t0,-18,0,0,   Z8), \t\t\t\t\t\t\t12)\n#define m_    PROC -1,-9,-8,-3,   \t2,20,0,0,  \t -8,-3,-16,-9,  14,20,0,0),\t\t24)\n#define n_    PROC 1,7,1,-8,   \t\tZ4,          -1,4,-14,-8,   15,15,0,0), \t20)\n#define o_    PROC -7,0,R,-6, \t\tZ4, \t\t Z8), \t\t\t\t\t\t\t20)\n#define p_    PROC 1,7,1,-20,\t\tZ8,          -9,0,R,-4),         \t\t\t22)\n#define q_    PROC -6,0,R,0,   \t\tZ8,\t\t\t 14,7,14,-20), \t     \t\t\t20)\n#define r_    PROC 1,8,1,-7,   \t\tZ4,\t\t\t -2,3,-13,5,    11,12,0,0), \t20)\n#define s_    PROC -8,7,-6,-1,   \t-8,8,0,0,  \t -6,-1,-1,-6,   15,-11,0,0), \t14)\n#define t_    PROC -4,15,-12,-5, \t1,-15,0,0,   1,8,8,8, \t\tZ4),         \t16)\n#define u_    PROC -1,8,-13,-4,  \t0,-16,0,0,   Z4,\t\t\t14,8,14,-8), \t20)\n#define v_    PROC 1,8,6,-8,   \t\tZ4,\t\t\t 6,-8,11,8,   \tZ4), \t\t\t16)\n#define w_    PROC 1,8,4,-8,   \t\t4,-8,9,4,    9,4,14,-8,   \t14,-8,18,8), \t23)\n#define x_    PROC 1,8,8,-8,   \t\tZ8,\t\t\t 8,8,1,-8), \t\t\t\t\t12)\n#define y_    PROC -2,8,-13,-4,  \t4,-11,0,0,   -14,8,-1,-18,  14,-28,0,0), \t22)\n#define z_    PROC 1,8,8,8,   \t\t8,8,1,-8,    1,-8,8,-8,   \tZ4), \t\t\t14)\n\nvoid mainImage(out vec4 k, in vec2 p )\n{   \n    k = vec4(0);\n    \n    vec2 ir = iResolution.xy,\n         sc = MODE,\n         cr = ir/sc,\n          s,\n        off = cr/vec2(4.,2.),\n         mp = mod(p, ir/sc)-off;\n\n     vec4 c = vec4(floor(p/cr),0,0),\n          K = INK;\n    \n    s = (iMouse.x>0.) ? \n        3.*iMouse.xy/iResolution.xy :\n    \tvec2(.04,.02)*ir/sc;\n    \n    float ch = mod(floor(p.x/cr.x),26.);\n\n    // need vectored jump?!\n    mat4 gp = ch< 1. ? a_ :\n       \t      ch< 2. ? b_ :\n       \t      ch< 3. ? c_ :\n              ch< 4. ? d_ :\n      \t      ch< 5. ? e_ :\n      \t      ch< 6. ? f_ :\n       \t      ch< 7. ? g_ :\n       \t      ch< 8. ? h_ :\n       \t      ch< 9. ? i_ :\n       \t      ch<10. ? j_ :\n       \t      ch<11. ? k_ :\n       \t      ch<12. ? l_ :\n       \t      ch<13. ? m_ :\n       \t      ch<14. ? n_ :\n       \t      ch<15. ? o_ :\n       \t      ch<16. ? p_ :\n       \t      ch<17. ? q_ :\n       \t      ch<18. ? r_ :\n       \t      ch<19. ? s_ :\n       \t      ch<20. ? t_ :\n       \t      ch<21. ? u_ :\n       \t      ch<22. ? v_ :\n       \t      ch<23. ? w_ :\n       \t      ch<24. ? x_ :\n       \t      ch<25. ? y_ :\n    \t      z_;\n    \nglyphCtx ctx;\n    ctx.p = mp;\n    ctx.s = s;\n    ctx.w = LINE_WIDTH;\n    ctx.K = K;\n    ctx.gp = gp;\n    ctx.gw = 0;\t\t\t\t\t// fixed width for now....\n    \n\n// Animate the output    \n    float gt = iTime;\n\n#ifdef SLOW_MO\n    gt *= .1;\n#endif\n    \n\tgt = 9.*(1.-cos(2.*cos(gt+12.)));    \n    \n#ifdef STAGGERED\n    ctx.t = -48. + (-2.*ch) + c.y*(11.*gt + 2.);\n#else\n    ctx.t = (-2.*ch)+32.*gt;\n#endif\n    \n    procGlyph(k, c, ctx);\n}\n\n\n\n\n","name":"Buf B","description":"","type":"buffer"}]}