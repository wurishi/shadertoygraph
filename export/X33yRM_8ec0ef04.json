{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = vec3(0.0);\n    \n    vec2 R = iResolution.xy;\n    vec2 worldPos = (2. * fragCoord - R) / R.y;\n    \n    const int PARTICLE_GRID_SIZE = 18;\n    float radius = 0.05;\n    float centerRadius = 0.01;\n    \n    float blur = 3.0 / iResolution.y;\n    \n    ivec2 I = ivec2(fragCoord);\n    float voronoiId = texelFetch(iChannel1, I, 0).x;\n    \n    #define T(i,j) texelFetch(iChannel1, ivec2(fragCoord+vec2(i,j)), 0).x\n    \n    if(I.x > 0 && I.y > 0 && I.x < int(iResolution.x) - 1 && I.y < int(iResolution.y) -1){\n        float voronoiLeftId = T(-1,0);\n        float voronoiRightId = T(1,0);\n        float voronoiUpId = T(0,-1);\n        float voronoiDownId = T(0,1);\n    \n        if(voronoiId != voronoiLeftId || voronoiId != voronoiRightId || \n           voronoiId != voronoiUpId || voronoiId != voronoiDownId)\n        {\n            color = vec3(1.0);\n        }\n    }\n    \n    for(int y=0; y< PARTICLE_GRID_SIZE; y++){\n        for(int x=0; x<PARTICLE_GRID_SIZE; x++){\n            vec4 posVel = texelFetch(iChannel0, ivec2(x,y), 0);\n            vec4 colorData = texelFetch(iChannel2, ivec2(x,y), 0);\n            vec2 pos = posVel.xy;\n            float d = length(worldPos - pos);\n            float circle = smoothstep(radius, radius - blur, d);\n            vec3 particleColor = colorData.rgb;\n            float point = smoothstep(centerRadius, centerRadius - blur, d);\n            color += particleColor * circle;\n            color -= (point);\n        }\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"\n//=====================================\n// Buffer A: Particle Physics Simulation\n//=====================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 pixel = ivec2(fragCoord);\n    const int NUM_PARTICLES = 300;\n    const int PARTICLE_GRID_SIZE = 18;\n    const float CELL_SIZE = 0.2;\n    \n    if(pixel.x < PARTICLE_GRID_SIZE && pixel.y < PARTICLE_GRID_SIZE){\n        int index = pixel.y * PARTICLE_GRID_SIZE + pixel.x;\n        \n        vec2 pos, vel;\n        vec3 color;\n        float mass = 1.0;\n        float radius = 0.05;\n        uint seed = uint(index);\n\n        if(iFrame == 0) {\n            bool validPosition = false;\n            \n            // Poisson Disk Sampling Loop\n            for(int attempt = 0; attempt < 100; attempt++){\n                uint tempSeed = seed;\n                vec2 newPos = vec2(pcg_hash(tempSeed) * 2.0 - 1.0, pcg_hash(tempSeed) * 2.0 - 1.0);\n                \n                validPosition = true;\n                \n                for(int otherY = 0; otherY < PARTICLE_GRID_SIZE; otherY++){\n                    for(int otherX = 0; otherX < PARTICLE_GRID_SIZE; otherX++){\n                        int otherIndex = otherY * PARTICLE_GRID_SIZE + otherX;\n                        if(otherIndex < index){\n                            vec4 otherState = texelFetch(iChannel0, ivec2(otherX,otherY),0);\n                            vec2 otherPos = otherState.xy;\n                            if (distance(newPos, otherPos) < 0.15) {\n                                validPosition = false;\n                                break;\n                            }\n                        }\n                    }\n                    if (!validPosition) break;\n                }\n                if (validPosition)\n                {\n                    pos = newPos;\n                    break;\n                }\n            }\n            \n            if(!validPosition){\n                pos = vec2(0.0);\n            }\n            \n            vel = vec2(0.0);\n        } else {\n            vec4 prevState = texelFetch(iChannel0, ivec2(pixel), 0);\n            pos = prevState.xy;\n            vel = prevState.zw;\n        }\n       \n        uint seed1 = seed + 1000u;\n        uint seed2 = seed + 2000u;\n        // Apply a small random force to spread out\n        vel += vec2(pcg_hash(seed1) * 2.0 - 1.0, pcg_hash(seed2) * 2.0 - 1.0) * 0.0002;\n        \n        // Update position\n        pos += vel * 0.016;\n        \n        //periodic boundary\n        float aspect = iResolution.x/iResolution.y;\n        vec2 bounds = vec2(aspect, 1.0);\n\n        if(pos.x > bounds.x){\n            pos.x = -bounds.x;\n        }\n        if(pos.x < -bounds.x){\n            pos.x = bounds.x;\n        }\n        if(pos.y > bounds.y){\n            pos.y = -bounds.y;\n        }\n        if(pos.y < -bounds.y){\n            pos.y = bounds.y;\n        }\n       \n        vec2 next_vel = vel;\n        vec2 next_pos = pos;\n\n        // Spatial Hash for current particle\n        ivec2 cellIndex = spatialHash(pos, CELL_SIZE, bounds);\n           \n        // Collision Loop\n        for (int dy = -1; dy <= 1; dy++) {\n            for (int dx = -1; dx <= 1; dx++) {\n                ivec2 otherCellIndex = cellIndex + ivec2(dx, dy);\n                for(int otherY = 0; otherY < PARTICLE_GRID_SIZE; otherY++){\n                    for(int otherX = 0; otherX < PARTICLE_GRID_SIZE; otherX++){\n                        int otherIndex = otherY * PARTICLE_GRID_SIZE + otherX;\n                        if (otherIndex > index) {\n                            vec4 otherState = texelFetch(iChannel0, ivec2(otherX, otherY), 0);\n                            vec2 otherPos = otherState.xy;\n                            vec2 otherVel = otherState.zw;\n                                 \n                            ivec2 otherCell = spatialHash(otherPos, CELL_SIZE, bounds);\n                            if (otherCell == otherCellIndex)\n                            {\n                                vec2 next_other_pos = otherPos;\n                                vec2 next_other_vel = otherVel;\n                                if(checkCircleCollide(next_pos, radius, otherPos, radius)){\n                                    dynamicCircleCircleCollisionResponse(next_vel, mass, next_pos, next_other_vel, mass, otherPos, next_pos, next_other_pos);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        fragColor = vec4(next_pos.x, next_pos.y, next_vel.x, next_vel.y);\n    }\n    else\n    {\n        fragColor = vec4(0.0);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XsXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"\n//=====================================\n// Buffer B: Distance Field\n//=====================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 worldPos = (uv * 2.0 - 1.0) * vec2(iResolution.x/iResolution.y, 1.0);\n    const int NUM_PARTICLES = 300;\n    const int PARTICLE_GRID_SIZE = 18;\n\n    float minDist = 1000.0;\n    int minIndex = -1;\n    for(int y=0; y< PARTICLE_GRID_SIZE; y++){\n        for(int x=0; x<PARTICLE_GRID_SIZE; x++){\n            int index = y*PARTICLE_GRID_SIZE + x;\n            vec4 data = texelFetch(iChannel0, ivec2(x,y), 0);\n            vec2 pos = data.xy;\n            float d = distance(worldPos, pos);\n            if(d < minDist)\n            {\n                minDist = d;\n                minIndex = index;\n            }\n        }\n    }\n    \n    fragColor = vec4(float(minIndex) / float(NUM_PARTICLES), 0.0, 0.0, 1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"outputs":[],"inputs":[],"code":"//Build with mainly Google AI Studio and based on a bunch of articles:\n//Circular particle collsions: https://ericleong.me/research/circle-circle/\n//Broad-Phase Collision Detection: https://developer.nvidia.com/gpugems/gpugems3/part-v-physics-simulation/chapter-32-broad-phase-collision-detection-cuda\n//Note, had some help from Claude AI to bounce back some ideas.\n\n//Buffer A: Particle physics\n//Buffer B: Distance field\n//Buffer C: Color storage\n//Image: Final rendering\n\n//=====================================\n// Common\n//=====================================\n// PCG Random Number Generator from https://www.shadertoy.com/view/Xds3zN\nfloat pcg_hash(inout uint seed) {\n    seed = seed * 1664525u + 1013904223u;\n    seed ^= seed >> 16u;\n    seed *= 2074839491u;\n    seed ^= seed >> 16u;\n    seed *= 1868893697u;\n    return float(seed) / float(4294967295u);\n}\n\n// Closest Point on a Line to a Point\nvec2 closestPointOnLine(vec2 lx1, vec2 lx2, vec2 x0) {\n    float A1 = lx2.y - lx1.y;\n    float B1 = lx1.x - lx2.x;\n    float C1 = (lx2.y - lx1.y) * lx1.x + (lx1.x - lx2.x) * lx1.y;\n    float C2 = -B1 * x0.x + A1 * x0.y;\n    float det = A1 * A1 - (-B1 * B1);\n\n    vec2 closestPoint;\n    if (det != 0.0) {\n        closestPoint.x = (A1 * C1 - B1 * C2) / det;\n        closestPoint.y = (A1 * C2 - (-B1 * C1)) / det;\n    } else {\n        closestPoint = x0;\n    }\n    return closestPoint;\n}\n\n//Static Circle-Circle Collision Detection\nbool checkCircleCollide(vec2 circle1_x, float r1, vec2 circle2_x, float r2){\n    return dot(circle1_x - circle2_x, circle1_x-circle2_x) < (r1 + r2) * (r1 + r2);\n}\n\n// Static Circle-Circle Collision Response\nvec2 staticCircleCollisionResponse(vec2 circle1_x, float r1, vec2 circle2_x, float r2){\n    vec2 midPoint = (circle1_x + circle2_x) / 2.0;\n    float dist = distance(circle1_x, circle2_x);\n    vec2 circle1_final_pos = midPoint + r1 * (circle1_x - circle2_x) / dist;\n    vec2 circle2_final_pos = midPoint + r2 * (circle2_x - circle1_x) / dist;\n    return circle1_final_pos;\n}\n\n//Dynamic Circle - Static Circle Collision Detection\nbool dynamicStaticCircleCollisionDetection(vec2 circle1_x, vec2 circle1_v, float r1, vec2 circle2_x, float r2) {\n    vec2 d = closestPointOnLine(circle1_x, circle1_x + circle1_v, circle2_x);\n    float closestdistsq = distance(circle2_x, d);\n    return closestdistsq <= (r1 + r2);\n}\n\n//Dynamic Circle - Static Circle Collision Response\nvec2 dynamicStaticCircleCollisionResponse(vec2 circle1_x, vec2 circle1_v, float r1, float m1, vec2 circle2_x, float r2, float m2) {\n    vec2 d = closestPointOnLine(circle1_x, circle1_x + circle1_v, circle2_x);\n    float closestdistsq = distance(circle2_x, d);\n    float backdist = sqrt((r1 + r2) * (r1 + r2) - closestdistsq);\n    float movementvectorlength = length(circle1_v);\n    vec2 c = d - backdist * (circle1_v / movementvectorlength);\n    \n    float collisiondist = distance(circle2_x, c);\n    vec2 n = (circle2_x - c) / collisiondist;\n    float p = 2.0 * dot(circle1_v, n) / (m1 + m2);\n    vec2 w = circle1_v - p * m1 * n - p * m2 * n;\n    return w;\n}\n\n// Dynamic Circle-Circle Collision Response (Corrected for Elastic Collisions)\nvoid dynamicCircleCircleCollisionResponse(inout vec2 circle1_v, float m1, vec2 circle1_x, inout vec2 circle2_v, float m2, vec2 circle2_x, inout vec2 circle1_pos, inout vec2 circle2_pos) {\n    vec2 n = normalize(circle2_x - circle1_x);\n    float p = 2.0 * dot(circle1_v - circle2_v, n) / (m1 + m2);\n    circle1_v -= p * m2 * n;\n    circle2_v += p * m1 * n;\n    \n    // Resolve overlap by moving circles apart\n    float dist = distance(circle1_x, circle2_x);\n    float overlap = (0.05 + 0.05) - dist;\n\n    if (overlap > 0.0) {\n        // Calculate the separation vector\n        vec2 separationVector = n * overlap * 0.5; // Divide the overlap by 2 to move them equally\n        \n        // Move both circles apart\n        circle1_pos -= separationVector;\n        circle2_pos += separationVector;\n    }\n}\n\n// Spatial Hash function\nivec2 spatialHash(vec2 pos, float cellSize, vec2 bounds){\n    float aspect = bounds.x/bounds.y;\n    vec2 worldPos = pos * vec2(aspect, 1.0) + bounds;\n    return ivec2(floor(worldPos / cellSize));\n}\n","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"4sXGR8"}],"inputs":[{"channel":2,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"//=====================================\n// Buffer C: Color Storage\n//=====================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 pixel = ivec2(fragCoord);\n    const int PARTICLE_GRID_SIZE = 18;\n    \n    if(pixel.x < PARTICLE_GRID_SIZE && pixel.y < PARTICLE_GRID_SIZE) {\n        int index = pixel.y * PARTICLE_GRID_SIZE + pixel.x;\n        \n        if(iFrame == 0) {\n            // Create gradient based on particle index\n            float normalizedIndex = float(index) / float(PARTICLE_GRID_SIZE * PARTICLE_GRID_SIZE);\n            vec3 color = vec3(normalizedIndex, 0.5, 1.0);  // HSV-like gradient\n            fragColor = vec4(color, 1.0);\n        } else {\n            // Maintain color from previous frame\n            fragColor = texelFetch(iChannel2, pixel, 0);\n        }\n    } else {\n        fragColor = vec4(0.0);\n    }\n}","name":"Buffer C","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"X33yRM","date":"1734864387","viewed":110,"name":"Voro Boro / Gradient-based","username":"Chimel","description":"Voronoi build on top of particles with circular collision detection. Version 'Gradient-based'\nbased on\nCircle-Circle Coll.: https://ericleong.me/research/circle-circle/","likes":8,"published":3,"flags":32,"usePreview":0,"tags":["voronoi","collision"],"hasliked":0,"parentid":"","parentname":""}}