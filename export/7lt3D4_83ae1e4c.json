{"ver":"0.1","info":{"id":"7lt3D4","date":"1636143435","viewed":899,"name":"Prismatic Synapse","username":"Hyeve","description":"this is what happens when i'm tired in class and just start writing shader code\n\nalso the first with my own lighting equations, thanks evvvil for the ones i originally learned and used before these <3","likes":62,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","transparency","glow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n\n\n//NOTE: this style of very compact, hard-to-read code makes\n//things easier for shaders, especially in the view of\n//livecoding compos where you have very limited time to\n//write them, but it would be absolutely awful anywhere else,\n//and I definitely don't recommend doing it outside of shaders like this\n\n\n\nvec3 glw; //glow\n\nfloat bx(vec3 p, vec3 s) //box\n{\n  vec3 q=abs(p)-s;\n  return min(max(q.x,max(q.y,q.z)),0.) + length(max(q,0.));\n}\n\nvec2 mp(vec3 p) //scene\n{\n \n  float scl=0.8;\n  for(int i=0;i<3;i++)\n  {\n    p.yz*=rot(scl-0.3);\n    p.y=abs(p.y)-scl;\n    p.x+=p.y*scl;\n    scl-=abs(p.y)*0.2;\n    p.xz*=rot(iTime*0.4);\n  }\n  float s = length(p-vec3(0,0,2));\n  float b = bx(p,vec3(scl)) - 0.1;\n  b*=0.5;b=min(s,b);\n  s*=8.;glw += 0.01/(0.01*s*s)*normalize(p*p);\n  return vec2(b,1);\n}\n\nvec2 tr(vec3 ro, vec3 rd, float z) //raymarch\n{\n  vec2 d=vec2(0);\n  for(int i=0;i<256;i++)\n  {\n    vec2 s=mp(ro+rd*d.x);\n    s.x*=z;d.x+=s.x;d.y=s.y;\n    if(s.x<0.0001||d.x>64.)break;\n  }\n  return d;\n}\n\nvec3 nm(vec3 p) //get normal\n{\n  vec2 e=vec2(0.001,0); return normalize(mp(p).x - vec3(mp(p-e.xyy).x,mp(p-e.yxy).x,mp(p-e.yyx).x));\n}\n\nvec4 px(vec2 h, vec3 p, vec3 n, vec3 r) //shade pixel\n{\n  vec4 bg = vec4(0.1,0.1,0.8,0) + length(r*r)*0.5;\n  if(h.x>64.) return bg; \n  vec4 fc = vec4(0.4,0.4,01,1);\n  vec3 ld = normalize(vec3(0.6,0.4,0.8));\n  float diff = length(n*ld);\n  float fres = abs(1.-length(n*r))*0.2;\n  float spec = pow(max(dot(reflect(ld,n)*ld,-r),0.),6.);\n  float ao = clamp(1.-mp(p+n*0.1).x*10.,0.,1.)*0.1;\n  float sss = smoothstep(0.,1.,mp(p*ld*3.).x)*0.6;\n  fc.rgb+=fc.rgb*sss;\n  fc*=diff;\n  fc+=spec;\n  fc+=fres;\n  fc-=ao;\n  return fc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  vec3 ro = vec3(0,0,-5),rd=normalize(vec3(uv,1));\n  vec3 cp,cn,cr,h=vec3(1);\n  vec4 cc,fc=vec4(1);\n  \n  //adjust this value for different amounts of refraction\n  //higher = more refraction; lower = less refraction (1.0 is none)\n  //below 1.0 makes them.. inverted i think? kinda interesting\n  float io = 1.4; \n \n  for(int i=0;i<4*2;i++) //more efficient transparency loop\n  {\n     h.xy=tr(ro,rd,h.z);cp=ro+rd*h.x;\n     cn=nm(cp);cr=rd;ro=cp-cn*(0.01*h.z);\n     rd=refract(cr,cn*h.z,h.z>0.?1./io:io);\n     if(dot(rd,rd)==0.)rd=reflect(cr,cn*h.z);\n     cc=px(h.xy,cp,cn,cr);h.z*=-1.;\n     if(h.z<0.)fc.rgb=mix(fc.rgb,cc.rgb,fc.a);\n     fc.a*=cc.a;if(fc.a<=0.||h.x>64.)break;\n  }\n  \n  //various interesting effects to try\n  fragColor = vec4(fc+glw.rgbb);\n  //fragColor = vec4(fc+sqrt(glw.rgbb*0.6));\n  //fragColor = vec4(fc+sqrt(glw.rgbb-0.005));\n  //fragColor = vec4(fc*sqrt(glw.rgbb-0.005));\n}\n","name":"Image","description":"","type":"image"}]}