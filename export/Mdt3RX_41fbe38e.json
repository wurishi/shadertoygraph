{"ver":"0.1","info":{"id":"Mdt3RX","date":"1451577941","viewed":430,"name":"Radiolarian #2","username":"tdhooper","description":"Sources:\n* http://mercury.sexy/hg_sdf/\n* https://www.shadertoy.com/view/4scGzs\n* https://www.shadertoy.com/view/XlB3DV","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["sdf","modpolyhedra"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PHI (sqrt(5.)*0.5 + 0.5)\n#define PI 3.14159265\n\n#define t iTime\n\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tfloat m = max(a, b);\n\tif ((-a < r) && (-b < r)) {\n\t\treturn max(m, -(r - sqrt((r+a)*(r+a) + (r+b)*(r+b))));\n\t} else {\n\t\treturn m;\n\t}\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n\tfloat t = dot(p, planeNormal)+offset;\n\tif (t < 0.) {\n\t\tp = p - (2.*t)*planeNormal;\n\t}\n\treturn sign(t);\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n\tfloat m = min(a, b);\n\tif ((a < r) && (b < r) ) {\n\t\treturn min(m, r - sqrt((r-a)*(r-a) + (r-b)*(r-b)));\n\t} else {\n\t return m;\n\t}\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n\nvec3 pModDodecahedron(inout vec3 p) {\n    vec3 v1 = normalize(vec3(0., PHI, 1.));\n    vec3 v2 = normalize(vec3(PHI, 1., 0.));\n\n    float sides = 5.;\n    float dihedral = acos(dot(v1, v2));\n    float halfDdihedral = dihedral / 2.;\n    float faceAngle = 2. * PI / sides;\n    \n    p.z = abs(p.z);\n    \n    pR(p.xz, -halfDdihedral);\n    pR(p.xy, faceAngle / 4.);\n    \n   \tp.x = -abs(p.x);\n    \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n    \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n    \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n    \n    pR(p.zy, halfDdihedral);\n   \tp.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    p.z = -p.z;\n\tpModPolar(p.yx, sides);\n    pReflect(p, vec3(-1, 0, 0), 0.);\n    \n    return p;\n}\n\nvec3 pModIcosahedron(inout vec3 p) {\n\n    vec3 v1 = normalize(vec3(1, 1, 1 ));\n    vec3 v2 = normalize(vec3(0, 1, PHI+1.));\n\n    float sides = 3.;\n    float dihedral = acos(dot(v1, v2));\n    float halfDdihedral = dihedral / 2.;\n    float faceAngle = 2. * PI / sides;\n    \n\n    p.z = abs(p.z);    \n    pR(p.yz, halfDdihedral);\n    \n   \tp.x = -abs(p.x);\n    \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n    \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n     \n    pR(p.zy, halfDdihedral);\n    p.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    pR(p.xy, faceAngle);\n  \n    pR(p.zy, halfDdihedral);\n   \tp.y = -abs(p.y);\n    pR(p.zy, -halfDdihedral);\n\n    p.z = -p.z;\n\tpModPolar(p.yx, sides);\n    pReflect(p, vec3(-1, 0, 0), 0.);\n\n\treturn p;\n}\n\nfloat spikeModel(vec3 p) {\n    pR(p.zy, PI/2.);\n    return fCone(p, 0.25, 3.);\n}\n\nfloat spikesModel(vec3 p) {\n    float round = 0.6;\n    \n    pModDodecahedron(p);\n    \n    vec3 v1 = normalize(vec3(0., PHI, 1.));\n    vec3 v2 = normalize(vec3(PHI, 1., 0.));\n\n    float sides = 5.;\n    float dihedral = acos(dot(v1, v2));\n    float halfDdihedral = dihedral / 2.;\n    float faceAngle = 2. * PI / sides;\n    \n    float spikeA = spikeModel(p);\n    \n    pR(p.zy, -dihedral);\n\n    float spikeB = spikeModel(p);\n\n    pR(p.xy, -faceAngle);\n    pR(p.zy, dihedral);\n    \n    float spikeC = spikeModel(p);\n    \n    return fOpUnionRound(\n        spikeC,\n        fOpUnionRound(\n            spikeA,\n            spikeB,\n            round\n       \t),\n        round\n   \t);\n}\n\nfloat coreModel(vec3 p) {\n    float outer = length(p) - .9;\n\tfloat spikes = spikesModel(p);\n    outer = fOpUnionRound(outer, spikes, 0.4);\n\treturn outer;\n}\n\nfloat exoSpikeModel(vec3 p) {\n    pR(p.zy, PI/2.);\n    p.y -= 1.;\n    return fCone(p, 0.5, 1.);\n}\n\nfloat exoSpikesModel(vec3 p) {\n    pModIcosahedron(p);\n\n    vec3 v1 = normalize(vec3(1, 1, 1 ));\n    vec3 v2 = normalize(vec3(0, 1, PHI+1.));\n\n    float dihedral = acos(dot(v1, v2));\n\n    float spikeA = exoSpikeModel(p);\n    \n    pR(p.zy, -dihedral);\n\n    float spikeB = exoSpikeModel(p);\n\n    return fOpUnionRound(spikeA, spikeB, 0.5);\n}\n\nfloat exoHolesModel(vec3 p) {\n    float len = 3.;\n    pModDodecahedron(p);\n    p.z += 1.5;\n    return length(p) - .65;\n}\n\nfloat exoModel(vec3 p) {    \n    float thickness = 0.18;\n    float outer = length(p) - 1.5;\n    float inner = outer + thickness;\n\n    float spikes = exoSpikesModel(p);\n    outer = fOpUnionRound(outer, spikes, 0.3);\n\t\n    float shell = max(-inner, outer);\n\n    float holes = exoHolesModel(p);\n\tshell = fOpIntersectionRound(-holes, shell, thickness/2.);\n    \n\treturn shell;\n}\n\n// Based on Template 3D by iq: https://www.shadertoy.com/view/ldfSWs\n\nfloat doModel(vec3 p) {\n    float exo = exoModel(p);\n    float core = coreModel(p);\n    return min(exo, core);\n}\n\nvoid doCamera(out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse) {\n    \n    float an = 10.0 * mouse.x + PI / 2.;\n    //an = 10.;\n\n    //float d = 2. + sin(an) * 1.6;\n    float d = 2. + (1. - mouse.y) * 10.;\n    camPos = vec3(\n        sin(an),\n        sin(mouse.y * PI / 2.),\n        cos(an)\n    ) * d;\n\n   \tcamTar = vec3(0);\n}\n\nvec3 doBackground(void) {\n    return vec3(0.0);\n}\n\nvec3 doMaterial(in vec3 pos, in vec3 nor) {\n    return vec3(.5);\n}\n\n\nfloat doRulerModel(vec3 p) {\n    return 1000.0;\n    float t = 0.1;\n    return abs(p.y) - mod(t/5., 1.);\n}\n\nfloat rule(float d, float scale) {\n    return mix(1., .35, smoothstep(.6, 1., abs(fract(d * scale) * 2. - 1.)));\n}\n\nvec3 rulerColor(float t) {\n    t = clamp(log(t+1.0), 0.0, 1.0);\n    return mix(mix(vec3(0.,.1,1.), vec3(1.,.1,0.), t*5.), vec3(1.0), smoothstep(.2,.5,t));\n}\n\nvec3 doRulerMaterial(vec3 p, float d, float t) {\n    float lt = log(t) / log(10.0);\n    float s = pow(10.0, -floor(lt));\n    float m = smoothstep(0.0, 0.33, fract(lt));\n    float r = rule(d, s * 10.) * mix(rule(d, s * 100.0), rule(d, s), m);\n    return mix(rulerColor(s * d), rulerColor(s * d * 0.1), m) * 0.8 * r;\n}\n\nfloat doCombinedModels(vec3 p) {\n    return min(doModel(p), doRulerModel(p));\n}\n\nfloat calcSoftshadow(in vec3 ro, in vec3 rd);\n\nvec3 doLighting(in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal) {\n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    vec3 lig = normalize(vec3(1.1, 0.7, 0.9));\n    float dif = max(dot(nor, lig), 0.0);\n    float sha = 0.0;\n    if (dif > 0.01) sha = calcSoftshadow(pos + 0.01 * nor, lig);\n    lin += dif * vec3(2.) * sha;\n\n    // ambient light\n    //-----------------------------\n    lin += vec3(0.5);\n\n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mal * lin;\n\n    // fog\n    //-----------------------------\n    col *= exp(-0.01 * dis * dis);\n\n    return col;\n}\n\nvec3 calcIntersection(in vec3 ro, in vec3 rd) {\n    const float maxd = 100.0;    // max trace distance\n    const float precis = 0.00001; // precission of the intersection\n    vec3 p;\n    float h = precis * 2.0;\n    float d, r;\n    float t = 0.0;\n    float res = -1.0;\n    for (int i = 0; i < 90; i++) // max number of raymarching iterations is 90\n    {\n        if (h < precis || t > maxd) break;\n        p = ro + rd * t;\n        r = doRulerModel(p);\n        d = doModel(p);\n        h = min(d, r);\n        t += h;\n    }\n\n    if (t < maxd) res = t;\n    return vec3(res, r < d ? 1.0 : 0.0, d);\n}\n\nvec3 calcNormal(in vec3 pos) {\n    const float eps = 0.002; // precision of the normal computation\n\n    const vec3 v1 = vec3(1.0, -1.0, -1.0);\n    const vec3 v2 = vec3(-1.0, -1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0, -1.0);\n    const vec3 v4 = vec3(1.0, 1.0, 1.0);\n\n    return normalize(v1 * doCombinedModels(pos + v1 * eps) + \n                     v2 * doCombinedModels(pos + v2 * eps) +\n                     v3 * doCombinedModels(pos + v3 * eps) + \n                     v4 * doCombinedModels(pos + v4 * eps));\n}\n\nfloat calcSoftshadow(in vec3 ro, in vec3 rd) {\n    float res = 1.0;\n    float t = 0.0005; // selfintersection avoidance distance\n    float h = 1.0;\n    for (int i = 0; i < 40; i++) { // 40 is the max numnber of raymarching steps\n        h = doModel(ro + rd * t);\n        res = min(res, 64.0 * h / t); // 64 is the hardness of the shadows\n        t += clamp(h, 0.01, 2.0);     // limit the max and min stepping distances\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nmat3 calcLookAtMatrix(in vec3 ro, in vec3 ta, in float roll) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n\n    // camera movement\n    vec3 ro, ta;\n    doCamera(ro, ta, iTime, m);\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix(ro, ta, 0.0); // 0.0 is the camera roll\n\n    // create view ray\n    vec3 rd = normalize(camMat * vec3(p.xy, 2.0)); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n    // render\n    //-----------------------------------------------------\n\n    vec3 col = doBackground();\n\n    // raymarch\n    vec3 t = calcIntersection(ro, rd);\n    if (t.x > -0.5) {\n        // geometry\n        vec3 pos = ro + t.x * rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec3 mal;\n        if (t.y > 0.) {\n            mal = doRulerMaterial(pos, t.z, t.x);\n        \t//mal = doLighting(pos, nor, rd, t.x, mal);\n        } else {\n            mal = doMaterial(pos, nor);\n        }\n        \n        //col = doLighting(pos, nor, rd, t.x, mal);\n      \tcol = vec3(0.5) + nor * 0.5;\n    }\n\n    //-----------------------------------------------------\n    // postprocessing\n    //-----------------------------------------------------\n\n    // gamma\n    //col = pow(clamp(col, 0.0, 1.0), vec3(0.4545));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}