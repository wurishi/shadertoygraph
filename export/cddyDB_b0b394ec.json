{"ver":"0.1","info":{"id":"cddyDB","date":"1695427368","viewed":115,"name":"Q1 FEM v2","username":"athibaul","description":"Mass-lumped Q1 finite element method with rectanular mesh.\nGeneralizes FDTD to warped domains.","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["q1","finiteelements"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Warped domain finite elements\n//\n\n// This technique, based on mass-lumped Q1 square finite elements \n// and the leap-frog scheme, allows to simulate wave propagation\n// in domains whose shape is a warped rectangle.\n//\n// Several examples of warped domains are shown (see Common tab).\n// For such a case, this method should be more accurate than na√Øve FDTD,\n// since the scheme correctly takes into account the curved boundary.\n//\n// However, like FDTD, the scheme has a stability condition, which becomes more and\n// more stringent as the deformation gets more extreme.\n// This makes it necessary to use a smaller time step, leading to\n// a slower simulation, if there is either \n// a highly compressed region, or strongly warped elements.\n// \n// Both traits are characterized by the diameter of the inscribed circle\n// in each cell, which in turn is related to the smallest eigenvalue of dfdx.\n// If any of the cells are \"thin\" in any direction, then we will have to slow down.\n// In other words, our deformation has to be as \"smooth\" as possible to be admissible.\n\n//#define SHOW_UNWARPED\n\n//#define GRID_OVERLAY\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 pq = ivec2(fragCoord);\n    \n    #ifdef SHOW_UNWARPED\n    fragColor = texelFetch(iChannel0, pq, 0) * 0.5 + 0.5;\n    return;\n    #endif\n    \n    //ivec2 pq = ivec2(fragCoord * 0.02 + 98.); // Zoom on pixel (100,100)\n    //pq.y = 99;\n    vec2 uv = (2.*fragCoord-iResolution.xy) / iResolution.y;\n    uv = 0.5+0.5*uv;\n    \n    // Look up the texture using the inverse mapping\n    //Enable SHOW_UNWARPED or comment out this line \n    // to see the rectangular domain\n    // in which the actual simulation takes place!\n    uv = calcFinv(uv);\n    // Of course, the result will look weird, since\n    // the wave propagation in that domain is anisotropic\n    // due to the change of variables.\n    \n    //uv *= step(1.,float(pq.x));\n    \n    //vec3 col = vec3(uv,0);\n    //fragColor = vec4(col, 0);\n    \n    //float v = texelFetch(iChannel0, pq, 0).g;\n    \n    //fragColor = vec4(step(uv.y, v));\n    \n    \n    //float v = texelFetch(iChannel0, pq, 0).g;\n    float v = texture(iChannel0, uv).g;\n    vec3 w = 6.28*v + vec3(-0.5,0.,0.5);\n    vec3 col = 0.5-0.5*(1.-.5*w*w);\n    \n    \n    // Overlay the grid of warped uv coordinates\n    #ifdef GRID_OVERLAY\n    float checker = mod(floor(uv.x*20.)+floor(uv.y*20.),2.);\n    col = mix(col, vec3(0,1,0), 0.2*checker);\n    #endif\n    \n    \n    if(uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) {\n        col = vec3(0.2);\n    }\n    \n    \n    \n    fragColor = vec4(sqrt(col),0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nfloat isInGrid(float p, float q) {\n    return step(0., p) * step(p, iResolution.x-2.) \n         * step(0., q) * step(q, iResolution.y-2.);\n}\n\nfloat tau(float a, float b, float x, float y) {\n    x = (a < 0.5) ? 1.-x : x;\n    y = (b < 0.5) ? 1.-y : y;\n    return x*y;\n}\n\nvec2 dtau(float a, float b, float x, float y) {\n    vec2 v = vec2(1);\n    x   = (a < 0.5) ? 1.-x : x;\n    y   = (b < 0.5) ? 1.-y : y;\n    v.x = (a < 0.5) ?  -1. : 1.;\n    v.y = (b < 0.5) ?  -1. : 1.;\n    return v * vec2(y,x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    ivec2 pq = ivec2(fragCoord);\n    float p = float(pq.x), q = float(pq.y);\n    ivec2 N = ivec2(iResolution.xy);\n    mat2 invN = mat2(1./float(N.x),0,0,1./float(N.y));\n    vec2 uv = invN * vec2(pq);\n    \n    \n    // Calculate transformation of the space\n    vec2 f = calcF(uv);\n    mat2 df = calcDf(uv);\n    mat2 dF = df * invN;\n    float detdf = determinant(dF);\n    mat2 invdF = inverse(dF);\n    // Calculate the lumped mass\n    float mass0 = detdf * 0.25;\n    float mass = 0.;\n    \n    for(float p_=p-1.; p_<=p; p_++) {\n        for(float q_=q-1.; q_<=q; q_++) {\n            mass += isInGrid(p_,q_) * mass0;\n        }\n    }\n    \n    float un = texelFetch(iChannel0, ivec2(p,q), 0).x;\n    float unm1 = texelFetch(iChannel0, ivec2(p,q), 0).y;\n    \n    // Calculate the negative Laplacian of the data with a finite element method\n    // For performance it would be preferable to pre-calculate the 3x3 stencil of\n    // each cell, and only perform a 3x3 convolution at each time step.\n    // I am not sure how to do that easily in Shadertoy, so I did not bother\n    // doing it.\n    float lapl = 0.;\n    for(float pj=p-1.; pj<=p+1.; pj++) {\n        for(float qj=q-1.; qj<=q+1.; qj++) {\n            // Data value at node j\n            float uj = texelFetch(iChannel0, ivec2(pj,qj), 0).x;\n            for(float pk=max(p-1.,pj-1.); pk<=min(p,pj); pk++) {\n                for(float qk=max(q-1.,qj-1.); qk<=min(q,qj); qk++) {\n                    // Calculate the contribution of each neighboring cell\n                    float lapl0 = 0.0;\n                    // Quadrature over the nodes\n                    for(float a=0.; a<=1.; a++) {\n                        for(float b=0.; b<=1.; b++) {\n                            mat2 df_ab = calcDf(vec2(pk+a,qk+b)/vec2(N)) * invN;\n                            float detdf_ab = determinant(df_ab);\n                            vec2 dtaui = dtau(p  - pk, q  - qk, a, b);\n                            vec2 dtauj = dtau(pj - pk, qj - qk, a, b);\n                            mat2 invD = inverse(df_ab);\n                            //lapl0 += dot(invD * dtaui, invD * dtauj) * detdf_ab;\n                            lapl0 += dot(dtaui * invD,dtauj*invD) * detdf_ab;\n                        }\n                    }\n                    lapl += 0.25 * isInGrid(pk,qk) * lapl0 * uj;\n                }\n             }\n        }\n    }\n    \n    float c0 = 1.0;\n    float c02 = c0*c0;\n    // If the simulation blows up, reduce the following number\n    float dt = 0.45/float(N.x);\n    float dt2 = dt*dt;\n    float unp1 = 2.*un - unm1 - dt2*c02*lapl/mass * 0.5;\n    \n    /*\n    // Initial impulse\n    if(iFrame == 0) {\n        vec2 d0 = f - vec2(0.2,0.5);\n        unp1 = 5.*exp(-dot(d0,d0) * 3000.);\n        //unp1 = step(length(vec2(pq)-100.),1.e-6);\n        un = unp1;\n    }*/\n    \n    // Oscillating source\n    if(iFrame >= 0) {\n        vec2 d0 = f - vec2(0.2,0.5);\n        float t = float(iFrame)*dt;\n        unp1 += 10.*dt*exp(-dot(d0,d0) * 3000.) * cos(t*100.)\n        * smoothstep(1.,0.9,t);\n    }\n    \n    \n    //vec3 col = vec3(detdf * iResolution.x * iResolution.y,0,0);\n    //vec3 col = vec3(0.5 + lapl);\n    vec3 col = vec3(unp1, un, 0);\n    //vec3 col = vec3(un, 0.5 + 0.5 * lapl, 0);\n    \n    fragColor = vec4(col, 0);\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Different warpings\n// 0 : no warping\n// 1 : vertical scaling\n// 2 : complex mapping\n\n#define WARP_TYPE 2\n\n\n\n\n\n#define PI 3.1415926\n\n// Parameters for WARP_TYPE 1\n#define HA 0.25\n#define H0 (1.-(HA))\n#define HB (2.*PI)\n#define HC 1.0\n\n\nvec2 cinv(vec2 z) {\n    return vec2(z.x, -z.y) / dot(z,z);\n}\n\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);\n}\n\nvec2 calcF(vec2 uv) {\n    // Transform from the (0,1)^2 square to an arbitrary shape\n    \n    // Non-uniform compression of the vertical scale\n    #if WARP_TYPE==0\n    return uv;\n    #elif WARP_TYPE==1\n    float h = H0 + HA*sin(HB*uv.x+HC);\n    return vec2(uv.x, uv.y*h);\n    #elif WARP_TYPE==2\n    uv.x += 1.;\n    uv = vec2(uv.x, -uv.y) / dot(uv,uv);\n    uv *= 2.;\n    uv += vec2(-1,1);\n    return uv;\n    #endif\n}\n\nvec2 calcFinv(vec2 uv) {\n    // Inverse transform of f\n    #if WARP_TYPE==0\n    return uv;\n    #elif WARP_TYPE==1\n    float h = H0 + HA*sin(HB*uv.x+HC);\n    return vec2(uv.x, uv.y/h);\n    #elif WARP_TYPE==2\n    uv -= vec2(-1,1);\n    uv *= 0.5;\n    uv = vec2(uv.x, -uv.y) / dot(uv,uv);\n    uv.x -= 1.;\n    return uv;\n    #endif\n}\n\nmat2 calcDf(vec2 uv) {\n    #if WARP_TYPE==0\n    return mat2(1,0,0,1);\n    #elif WARP_TYPE==1\n    float h = H0 + HA*sin(HB*uv.x+HC);\n    float dhdx = HA*HB*cos(HB*uv.x+HC);\n    vec2 dfdx = vec2(1, uv.y*dhdx);\n    vec2 dfdy = vec2(0, h);\n    return mat2(dfdx, dfdy);\n    #elif WARP_TYPE==2\n    // TODO\n    //return mat2(1,0,0,1);\n    uv.x += 1.;\n    vec2 duv = -cinv(cmul(uv,uv));\n    duv *= 2.;\n    return mat2(duv.x,duv.y,-duv.y,duv.x);\n    #endif\n}","name":"Common","description":"","type":"common"}]}