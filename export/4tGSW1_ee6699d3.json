{"ver":"0.1","info":{"id":"4tGSW1","date":"1484053104","viewed":311,"name":"Test encoding decoding float","username":"tedd","description":"Test Unity encoding decoding float","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Encoding/decoding [0..1) floats into 8 bit/channel RGBA. Note that 1.0 will not be encoded properly.\nvec4 EncodeFloatRGBA( float v )\n{\n    vec4 kEncodeMul = vec4(1.0, 255.0, 65025.0, 16581375.0);\n    float kEncodeBit = 1.0/255.0;\n    vec4 enc = kEncodeMul * v;\n    enc = fract (enc);\n    enc -= enc.yzww * kEncodeBit;\n    return enc;\n}\n\nfloat DecodeFloatRGBA( vec4 enc )\n{\n    vec4 kDecodeDot = vec4(1.0, 1./255.0, 1./65025.0, 1./16581375.0);   \n    return dot( enc, kDecodeDot );\n}\n\n// Notice hos this only works if max color is 254 since 255 would give 1.0 which is not valid as per Unitys comment above\n// This limits us to the range 0-254, effectively 255 colors. Given that our source is 32-bit RGBA then it should be 256.\n// So we need to divide by 257 and multiply by color 0-255 to support full range of 256 + avoid 1.0 (257).\nconst vec4 color1 = vec4(1./255.*254.,0,0,0); // RGB 0-255\nconst vec4 color2 = vec4(0,1./255.*128.,0,0); // RGB 0-255\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\n    if (uv.y < 0.5) {\n        if (uv.x < 0.5) {\n        \tfragColor = color1;\n    \t} else {\n        \tfragColor = color2;\n    \t}\n    } else {\n        float a = DecodeFloatRGBA(color1);\n        if (uv.x < 0.5) {\n        \tfragColor = EncodeFloatRGBA(DecodeFloatRGBA(color1));\n    \t} else {\n        \tfragColor = EncodeFloatRGBA(DecodeFloatRGBA(color2));\n    \t}\n    }\n    \n}\n\n","name":"Image","description":"","type":"image"}]}