{"ver":"0.1","info":{"id":"dssfW2","date":"1689198424","viewed":57,"name":"Colorful Tartan","username":"qevitta","description":"A little experiment with simple patterns","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["colorful","pattern","pixels","tartan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float PI = 3.1415926535;\nfloat pixelSize = 2.;\nfloat distortion = 0.2;\nfloat tileSize = 15.;\nfloat moveSpeed = 60.;\n\nfloat stripe(float coord, float div) {\n    return mod(floor(coord / div), 2.);\n}\n\n// pseudo-random noise, found it accidentally, it works funny and gives 0 or 1\nfloat noiseBase(float seed1, float seed2) {\n    return floor(seed1 * seed2 / seed1 / seed2);\n}\n\n// dynamic periodic noise with controllable speed\nfloat noise(float seed1, float seed2, float speed) {\n    float frame = floor(float(iFrame) * speed);\n    return noiseBase(\n        sin(seed1 + frame), \n        cos(seed2 + frame)\n    );\n}\n\n// simplified form of noise(seed1, seed2, float), using same value for both seeds \n// it's different than noiseBase(x, x) because noise() wraps seeds in sin and cos respectively (and changes over time)\nfloat unaryNoise(float seed, float speed) {\n    return noise(seed, seed, speed);\n}\n\nfloat weightedUNoise(float seed, float speed, float weight) {\n    return (1. - weight) + weight * unaryNoise(seed, speed);\n}\n\n// floor division by pixelSize\nfloat pixelize(float x) {\n    return floor(x / pixelSize);\n}\n\n// fisheye\nvec2 distort(vec2 p) {\n    float aspect = iResolution.x / iResolution.y;\n    float d = length(p);\n    float z = sqrt(distortion + d * d * -distortion);\n    float r = atan(d, z) / PI;\n    float phi = atan(p.y, p.x);\n    return vec2(r * cos(phi) * (1.0 / aspect) + 0.5, r * sin(phi) + 0.5);\n}\n\nfloat posSin(float x) {\n    return (sin(x) + 1.) * .5;\n}\n\nfloat interp(float x1, float x2, float k) {\n    return x1 * k + x2 * (1. - k);\n}\n\nfloat interp2(vec3 col, float k1, float k2) {\n    return interp(col.x, interp(col.x, col.y, k1), k2);\n}\n\nfloat mixColor(vec3 rgb, float k, float k2, float noiseSpeed) {\n    return interp2(rgb, k, k2) * weightedUNoise(rgb.x, noiseSpeed, 0.7);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    \n    float k = posSin(iTime);\n    float k2 = posSin((iTime + pixelSize) / 2.3);\n    \n    vec2 distorted = distort(uv);\n    vec2 coords = floor(distorted * iResolution.xy / 2.) * 2.;\n    \n    // pixel coordiantes centered in canvas center and offset over time\n    float x = coords.x + iTime * moveSpeed; \n    float y = coords.y + iTime * moveSpeed;\n    \n    float r_ = stripe(pixelize(x) + pixelize(y), tileSize);\n    float g_ = stripe(pixelize(-x) + pixelize(y), tileSize);\n    float b_ = 1. - min(mod((r_ + g_) + .5, 2.), 1.);\n\n    float r = mixColor(vec3(r_, g_, b_), k, k2, 0.02);\n    float g = mixColor(vec3(g_, b_, r_), k, k2, 0.03);\n    float b = mixColor(vec3(b_, r_, g_), k, k2, 0.05);\n\n    fragColor = vec4(r, g, b, 1.);\n}","name":"Image","description":"","type":"image"}]}