{"ver":"0.1","info":{"id":"l3Xyzl","date":"1726593243","viewed":25,"name":"Sand Maybe (Demo)","username":"copperTones","description":"I'm working on a more complete and customizable version of this. The rules are hardcoded currently.\nFull version in a week. Maybe.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["sand","cellularautomata","margolus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 color, in vec2 coord) {\n    color = texelFetch(iChannel0, ivec2(coord), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"ivec2 time_off[] = ivec2[](\n    ivec2(0, 0),\n    ivec2(1, 1),\n    ivec2(1, 0),\n    ivec2(0, 1)\n);\n\n// x + 2*y\nvec4 ruleset[] = vec4[](\n    /* \n    vec4(0, 0, 0, 0),\n    vec4(1, 0, 0, 0),\n    vec4(0, 1, 0, 0),\n    vec4(1, 1, 0, 0),\n    vec4(0, 0, 1, 0),\n    vec4(1, 0, 1, 0),\n    vec4(0, 1, 1, 0),\n    vec4(1, 1, 1, 0),\n    vec4(0, 0, 0, 1),\n    vec4(1, 0, 0, 1),\n    vec4(0, 1, 0, 1),\n    vec4(1, 1, 0, 1),\n    vec4(0, 0, 1, 1),\n    vec4(1, 0, 1, 1),\n    vec4(0, 1, 1, 1),\n    vec4(1, 1, 1, 1)\n    /*/\n    vec4(0, 0, 0, 0),//  \n    vec4(1, 0, 0, 0),//. \n    vec4(0, 1, 0, 0),// .\n    vec4(1, 1, 0, 0),//..\n    vec4(1, 0, 0, 0),//' \n    vec4(1, 1, 0, 0),//: \n    vec4(1, 1, 0, 0),//'.\n    vec4(1, 1, 1, 0),//:.\n    vec4(0, 1, 0, 0),// '\n    vec4(1, 1, 0, 0),//.'\n    vec4(1, 1, 0, 0),// :\n    vec4(1, 1, 0, 1),//.:\n    vec4(1, 1, 0, 0),//''\n    vec4(1, 1, 1, 0),//:'\n    vec4(1, 1, 0, 1),//':\n    vec4(1, 1, 1, 1) //::\n    //*/\n);\n\nvoid mainImage(out vec4 color, in vec2 coord) {\n    if (iFrame == 0) {\n        float sand = texture(iChannel1, coord/iResolution.xy).r;\n        color = vec2(step(sand, .3), 1).xxxy;\n        return;\n    }\n    if (coord.y < 5.) {\n        color = vec4(1);\n        return;\n    }\n    \n    ivec2 pos = ivec2(coord);\n    ivec2 npos = pos - time_off[iFrame & 3];\n    npos = npos - npos%2 + time_off[iFrame & 3];\n    \n    float index = 0.;//*\n    for (int i = 3; i >= 0; i--) {\n        ivec2 noff = ivec2(i & 1, i >> 1);\n        index = 2.*index + texelFetch(iChannel0, npos + noff, 0).x;\n    }\n    \n    ivec2 moff = pos - npos;\n    float next = ruleset[int(index)][moff.x | moff.y<<1];\n    \n    color = vec2(next, 1).xxxy;\n}","name":"Buffer A","description":"","type":"buffer"}]}