{"ver":"0.1","info":{"id":"DlG3R3","date":"1684689295","viewed":123,"name":"Neon Bars 3, Time is running","username":"epibyte","description":"neon bars","likes":2,"published":1,"flags":0,"usePreview":1,"tags":["neonbars"],"hasliked":0,"parentid":"DlKGWh","parentname":"Neon Bars 3.0"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n\n/**\n * NeonBar\n */\n\nstruct NeonBar{\n  vec2 pos;  // position\n  float len; // length\n  float ang; // angle\n  float dag; // delta angle\n  float cag; // curr angle\n  vec3 clr;  // color rgb\n  float its; // intensity\n};\n\nNeonBar createBar(vec2 pos, float len, float angle, float deltaAngle, vec3 color, float intense) {\n    NeonBar bar;\n    bar.pos = pos;\n    bar.len = len;\n    bar.ang = angle;\n    bar.dag = deltaAngle;\n    bar.cag = angle;\n    bar.clr = color;\n    bar.its = intense;\n    return bar;\n}\n\nvoid barSetAngle( out NeonBar bar, in float time) {\n    bar.cag = bar.ang + bar.dag * time;\n}\n\n/**\n * Rand & Noise\n */\n\nfloat random ( in vec2 st ) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d // https://www.shadertoy.com/view/4dS3Wd\nfloat noise ( in vec2 st ) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// dist from rotating spot point center, radius, angle\nfloat distCircRad( in vec2 uv, in vec2 c, in float r, in float a) {\n   vec2 p = c + vec2(cos(a), sin(a)) * r;\n   return length(uv - p);\n}\n\n// dist from segment point a, point b\n// changed FBK: h_c ersetzt durch h, sowie if() vor return\nfloat _distSegment( in vec2 p, in vec2 a, in vec2 b ) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return max(0., length( pa - ba * h ));\n}\nfloat distSegment( in vec2 p, in vec2 a, in vec2 b ) {\n    vec2 pa = p-a, ba = b-a;\n    float h_c = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d_c = max(0., length( pa - ba * h_c ));\n    \n    float h = dot(pa,ba)/dot(ba,ba);\n    float d = max(0., length( pa - ba * h ));\n    \n    //  double angle=atan2(v1.x*v2.x+v1.y*v2.y,v1.x*v2.y-v1.y*v2.x);\n    // \n    if (h < 0.) d_c += abs(h);\n    // \n    if (h > 1.) d_c += h - 1.;\n    // \n    // if (h < 0. || h > 1.) d_c *= 2.25;\n    return d_c;\n}\n\n/*\n    let tempVecBar = this.vec.copy().normalize();\n    let currPos = createVector(x - this.x1, y - this.y1);\n    let scalarProjection = currPos.dot(tempVecBar);\n    this.scPr = scalarProjection;\n\n    // print(scalarProjection)\n    if (scalarProjection < 0) scalarProjection = 0;\n    if (scalarProjection > this.dist) scalarProjection = this.dist;\n    const vP = tempVecBar.mult(scalarProjection).add(this.pos);\n    this.vPrD = dist(x, y, vP.x, vP.y);\n    this.angP = this.vec.angleBetween(createVector(x - vP.x, y - vP.y));\n\n    // colors\n    this.clr = this.angP > 0 ? this.clrR : this.clrL;\n    let factorAngle = sin(abs(this.angP));\n    factorAngle *= factorAngle; //  * factorAngle * factorAngle;\n    let factorDist = map(this.vPrD, 0, this.len, 1, 0);\n    factorDist *= factorDist * factorDist;\n    const intensity = factorAngle * factorDist;\n*/\n\n// dclr for NeonBar\nvec3 _clrNeonBar( in vec2 p, in NeonBar bar ) {\n    // float angle = bar.ang + bar.dag * time;\n    vec2 w = vec2(cos(bar.cag),sin(bar.cag)) * bar.len * 0.5;\n    vec2  a = bar.pos + w;\n    vec2  b = bar.pos - w;\n    \n    float d = _distSegment(p, a, b);\n    \n    vec2 pa = p-a, ba = b-a;\n    \n    float br =  bar.its / d;\n    br = min(1.86, br); // reduce overglue\n    // br = smoothstep(.001, 0.91, br);\n    return vec3(br) * bar.clr; \n}\nvec3 clrNeonBar( in vec2 p, in NeonBar bar ) {\n    // float angle = bar.ang + bar.dag * time;\n    vec2 w = vec2(cos(bar.cag),sin(bar.cag)) * bar.len * 0.5;\n    vec2  a = bar.pos + w;\n    vec2  b = bar.pos - w;\n    float d = distSegment(p, a, b);\n    float br =  bar.its / d;\n    br = min(1.86, br); // reduce overglue\n    // br = smoothstep(.001, 0.91, br);\n    return vec3(br) * bar.clr; \n}\n\n// intersections\nbool intersectsA(vec2 ro, vec2 rd, NeonBar bar) {\n    // abcd ray1, pqrs ray2\n    float det, gamma, lambda;\n    float a = ro.x;\n    float b = ro.y;\n    float c = a + rd.x;\n    float d = b + rd.y;\n    \n    vec2 w0 = vec2(cos(bar.ang),sin(bar.ang)) * bar.len * 0.5;\n    vec2 p1 = bar.pos + w0;\n    vec2 p2 = bar.pos - w0;\n    float p = p1.x;\n    float q = p1.y;\n    float r = p2.x;\n    float s = p2.y;\n    \n    \n    det = (c - a) * (s - q) - (r - p) * (d - b);\n    if (abs(det) < .0001) {\n      return false; // negative = no intersection\n    } else {\n      lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;\n      gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;\n      // print(lambda, gamma);\n      // print(lambda*(c-a)+a, lambda*(d-b)+b)\n      return 0. < lambda && lambda < 1. && 0. < gamma && gamma < 1.;\n    }\n}\n\n// bool intersects(vec2 p, vec2 q, vec2 r, vec2 s) {\nbool intersects(vec2 uv, NeonBar bar, NeonBar other) {\n    vec2 w = vec2(cos(bar.cag),sin(bar.cag)) * bar.len * 0.5;\n    vec2 p1 = bar.pos + w;\n    vec2 p2 = bar.pos - w;\n    \n    return intersectsA(uv, p1 - uv, other) || intersectsA(uv, p2 - uv, other);\n}\n\nvec3 getColor(vec2 pos, float iTime) {\n    float n = noise(pos);\n    return n < sin(iTime) * .5 ? vec3(.8, .2, .7) : n < sin(iTime) ? vec3(.2, .7, .8)  : vec3(0.9);\n}\n\n/**\n * Main fragment\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - 0.5; // 0 center\n    uv.x *= iResolution.x / iResolution.y; // aspect ratio\n\n\n    // angle\n    float angle = iTime * 2.;\n\n    // define bars\n    NeonBar bars[100];\n    const int barsNum = 100; // bars.length(); not working\n    // NeonBar createBar(vec2 pos, float len, float angle, float deltaAngle, vec3 color, float intense)\n    int barIndex = 0;\n    if (true) {\n        vec2 pos;\n        vec3 col;\n        \n        if (false) {\n            pos = vec2(.001, .0);\n            col = getColor(pos, iTime);\n            col = vec3(.9, .0, .1);\n            bars[barIndex++] = createBar(pos, 0.95, PI/2., .0, col, 0.0075);\n            pos = vec2(.0, .01);\n            col = getColor(pos, iTime);\n            bars[barIndex++] = createBar(pos, 0.95, -PI/4., .0, col, 0.005);\n            pos = vec2(-.01, .0);\n            col = getColor(pos, iTime);\n            col = vec3(.0, .9, .6);\n            bars[barIndex++] = createBar(pos, 0.95, 0., .0, col, 0.0125);\n        } else {\n            for (int i = 0; i < 45 && i < barsNum; i++) {\n                float a = random(vec2(iDate.z + float(i) * .321, iDate.x + float(i) * .123)) * PI * 2.;\n                float r = 1. - random(vec2(a, a * PI)) * random(vec2(a * PI * .1, a * .1));\n                r *= .5;\n                float x = cos(a) * r;\n                float y = sin(a) * r;\n                vec2 pos = vec2(x, y);\n                // delta a\n                a += noise(pos * iTime) * PI * 2.;\n                 x = cos(a) * r;\n                 y = sin(a) * r;\n                 pos = vec2(x, y);\n                \n                float n = noise(pos);\n                vec3 col = getColor(pos, iTime); // n < sin(iTime) * .5 ? vec3(.8, .2, .7) : n < sin(iTime) ? vec3(.2, .7, .8)  : vec3(0.9);\n                float da = 0.; // floor((n * 10.) * 10.) < 5. ? -.1 : .1;\n                float ang = a; // ang = noise(vec2(iTime * (x + 0.05), iTime * (y - 0.1))) < .5 ? ang : -ang;\n                float len = .141; // .282\n                float its = 0.0025;\n                bars[barIndex++] = createBar(pos, len, ang, da, col, its);\n            }\n        }\n \n    } else {\n        for (float y = -.4; y <= .401; y += .1) {\n            for (float x = -.4; x <= .401; x += .1) {\n                if (barIndex < barsNum) {\n                    vec2 pos = vec2(x, y); // vec2(x + 0.05, y - 0.1);\n                    float n = noise(pos);\n                    vec3 col = n < sin(iTime) * .5 ? vec3(.8, .2, .7) : n < sin(iTime) ? vec3(.2, .7, .8)  : vec3(0.9);\n                    float da = floor((n * 10.) * 10.) < 5. ? -.1 : .1;\n                    da *= 0.;\n                    float ang = PI/4.;\n                    ang = noise(vec2(iTime * (x + 0.05), iTime * (y - 0.1))) < .5 ? ang : -ang;\n                    float len = .141; // .282\n                    float its = 0.0025;\n                    bars[barIndex++] = createBar(pos, len, ang, da, col, its);\n                }\n            }\n        }\n    }\n\n\n    // background color\n    vec3 col = vec3(.0, .0, 0.1);\n    \n    float dd = distance(uv, vec2(0.));\n    // col += vec3(.01 / dd);\n\n\n// --> Segments <---------------------------------------------------------\n\n    for (int i = 0; i < barsNum; i++) {\n        barSetAngle(bars[i], iTime * 4.);\n        bool visible = true;\n        /*\n        for (int j = 0; j < barsNum; j++) {\n            float d;\n            if (i != j) {\n                visible = visible && !intersects(uv, bars[i], bars[j]);\n            }\n        }\n        \n        visible = true; // ToDO fix intersects \n        if (visible) col += clrNeonBar(uv, bars[i]); // sin(angle)\n        if (!visible) col += .25 * clrNeonBar(uv, bars[i]); // sin(angle)\n        */\n        col += clrNeonBar(uv, bars[i]);\n    }\n\n// --> random & noise <---------------------------------------------------\n    // col += 0.25 * random(uv) + .25;\n    // col *= max(.25, min( .75, noise(1.1*uv+iTime)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}