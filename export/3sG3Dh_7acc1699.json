{"ver":"0.1","info":{"id":"3sG3Dh","date":"1570045199","viewed":114,"name":"Orbiting reflective orbs","username":"Agneseion","description":"I watched a Youtube video about raymarching and thought it sounded pretty cool, so here's an example of that. I probably screwed up the mathematics somewhere? HSL colour functions were taken from https://www.shadertoy.com/view/wt23Rt.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct RayMarchingSphere\n{\n    int index;\n    bool isEmptySphere;\n    vec3 centre;\n    float radius;\n    vec3 collisionPoint;\n    vec3 normal;\n    bool movingAway;\n    float reflexivity;\n    float hue;\n    float saturation;\n    float d;\n};\n    \n    \n#define SPHERES 4\n#define RAYMARCHING_ITERATIONS 25\n#define MINIMUM_DISTANCE 0.025\n    \nRayMarchingSphere[SPHERES] getSpheres()\n{\n    RayMarchingSphere results[SPHERES];\n    results[0].index = 0;\n    results[0].isEmptySphere = false;\n    results[0].centre = vec3(0.0, 0.0, 0.0);\n    results[0].radius = 1.0;\n    results[0].normal = vec3(0.0, 0.0, 0.0); // Set by collision\n    results[0].movingAway = false;\n    results[0].reflexivity = 0.3;\n    results[0].hue = 0.7;\n    results[0].saturation = 0.6;\n    \n    results[1].index = 1;\n    results[1].isEmptySphere = false;\n    results[1].centre = vec3(1.5*sin(iTime), 1.3*sin(iTime/22.0), 1.5*cos(iTime));\n    results[1].radius = 0.3;\n    results[1].normal = vec3(0.0, 0.0, 0.0); // Set by collision\n    results[1].movingAway = false;\n    results[1].reflexivity = 0.3;\n    results[1].hue = 0.3;\n    results[1].saturation = 0.6;\n    \n    results[2].index = 2;\n    results[2].isEmptySphere = false;\n    results[2].centre = vec3(2.1*sin(0.3 + iTime/16.8), 0.3*sin(iTime/1.6), 2.1*cos(0.3 + iTime/16.8));\n    results[2].radius = 0.1;\n    results[2].normal = vec3(0.0, 0.0, 0.0); // Set by collision\n    results[2].movingAway = false;\n    results[2].reflexivity = 0.1;\n    results[2].hue = 0.5;\n    results[2].saturation = 0.2;\n    \n    results[3].index = 3;\n    results[3].isEmptySphere = false;\n    results[3].centre = results[1].centre + vec3(0.5*sin(3.18*iTime), 0.5*cos(3.18*iTime), 0.5*cos(3.18*iTime));\n    results[3].radius = 0.1;\n    results[3].normal = vec3(0.0, 0.0, 0.0); // Set by collision\n    results[3].movingAway = false;\n    results[3].reflexivity = 0.3;\n    results[3].hue = 0.3;\n    results[3].saturation = 0.6;\n    \n    return results;\n}\n    \nRayMarchingSphere getCollisionSphere(vec3 rayOrigin, vec3 rayDirection, int ignoreSphere)\n{\n    RayMarchingSphere result;\n    result.isEmptySphere = true;\n    \n    RayMarchingSphere[] spheres = getSpheres();\n    float previousDistances[SPHERES];\n    \n    float dTot = 0.0;\n    \n    for (int j = 0; j < previousDistances.length(); j++)\n        previousDistances[j] = -1.0;\n    \n    for (int i = 0; i < RAYMARCHING_ITERATIONS; i++)\n    {   \n        float dMin = -1.0;\n        RayMarchingSphere closest;\n        closest.isEmptySphere = true;\n        for (int j = 0; j < SPHERES; j++)\n        {   \n            RayMarchingSphere s = spheres[j];\n            if (s.movingAway || j == ignoreSphere)\n                continue;\n            \n            float d = distance(rayOrigin, s.centre) - s.radius;\n            \n            if (previousDistances[j] < 0.0)\n            {\n                previousDistances[j] = d;\n            }\n            else\n            {\n             \tfloat p = previousDistances[j];\n                if (p < d)\n                {\n                    s.movingAway = true;\n                }\n                else\n                    previousDistances[j] = d;\n            }\n            \n            if (dMin < 0.0 || d < dMin)\n            {\n                closest = s;\n                dMin = d;\n            }\n        }\n        \n        if (closest.isEmptySphere)\n        {\n         \treturn closest;   \n        }\n        \n        if (dMin < MINIMUM_DISTANCE)\n        {\n            closest.normal = normalize(rayOrigin - closest.centre);\n            closest.d = dTot;\n            closest.collisionPoint = rayOrigin;\n            return closest;\n        }\n        else\n        {\n        \trayOrigin += dMin * normalize(rayDirection);\n        \tdTot += dMin;\n        }\n    }\n    return result;\n}\n    \nvec3 getSkyColourFromVector(vec3 v)\n{\n \tfloat phi = acos(v.y/length(v));\n    float theta = atan(v.z, v.x);\n    return calculateTotalSkyColourAtAngle(phi, theta, iTime/10.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5*iResolution.xy) / iResolution.y;\n    \n    vec3 cameraPoint = vec3(uv, -3.0);\n    vec3 rayDirection = vec3(uv.x, uv.y, 1.0);\n    rayDirection.xy += (iMouse.xy - .5 * iResolution.xy) / iResolution.y;\n    \n    RayMarchingSphere collisionSphere = getCollisionSphere(cameraPoint, rayDirection, -1);\n    \n    if (collisionSphere.isEmptySphere)\n    {\n   \t\tvec3 skyColour = getSkyColourFromVector(rayDirection);\n    \tfragColor = vec4(skyColour, 1.0);\n    }\n    else\n    {\n     \tvec3 sphereColourHSL = vec3(collisionSphere.hue, collisionSphere.saturation, 1.0/collisionSphere.d);\n    \tvec3 sphereColourRGB = hsl2rgb(sphereColourHSL);\n        \n        float reflectionSum = collisionSphere.reflexivity;\n        float localRefl = reflectionSum;\n        sphereColourRGB *= localRefl;\n        \n        while (localRefl > 0.01)\n        {\n            vec3 cp = collisionSphere.collisionPoint;\n            vec3 norm = collisionSphere.normal;\n        \tcollisionSphere = getCollisionSphere(cp, norm, collisionSphere.index);\n            \n            if (collisionSphere.isEmptySphere)\n            {\n                sphereColourRGB += getSkyColourFromVector(norm) * (1.0 - reflectionSum);\n                break;\n            }\n            else\n            {\n                float refl = collisionSphere.reflexivity;\n                localRefl = refl * (1.0 - reflectionSum);\n                \n                reflectionSum += localRefl;\n                \n                vec3 sphereColourHSL = vec3(collisionSphere.hue, collisionSphere.saturation, localRefl / max(1.0, collisionSphere.d));\n    \t\t\tvec3 localColourRGB = hsl2rgb(sphereColourHSL);\n                sphereColourRGB += localRefl * localColourRGB;\n            }\n        }\n                                                 \n        fragColor = vec4(sphereColourRGB, 1.0);\n    }\n\t// fragColor = vec4(skyColourHSL, 1.0);\n    \n    // Output to screen\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float hashPoint(vec2 point)\n{\n\treturn fract(14872.7194 * sin(103819.53 + 6.465*point.x + 57.419*point.y));\n}\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nfloat getBlobSizeInSector(float phiSector, float thetaSector)\n{\n\treturn 2.0 * hashPoint(vec2(phiSector, thetaSector)) - .5;\n}\n\nvec3 blendSkyColourAtAngle(float phi, float theta, float phiSectors, float thetaSectors, vec3 skyColour, vec3 cloudColour)\n{\n\t// 0 <= phi <= pi:\n\tfloat phiSector = mod(floor(phiSectors * phi / PI), phiSectors);\n\t// 0 <= theta < 2*pi\n\tfloat thetaSector = mod(floor(thetaSectors * theta / TWO_PI), thetaSectors);\n\t\n\t// In sectors, what is the radius of the cloud blob in this sector?\n\tfloat blobRadius = getBlobSizeInSector(phiSector, thetaSector);\n\t\n\t// Also calculate this for all neighbouring sectors:\n\tfloat thetaEast = mod(thetaSector + 1.0, thetaSectors);\n\tfloat thetaWest = mod(thetaSector - 1.0 + thetaSectors, thetaSectors);\n\tfloat phiUp = mod(phiSector - 1.0 + phiSectors, phiSectors);\n\tfloat phiDown = mod(phiSector + 1.0, phiSectors);\n\t\n\t// The number we increase to hide more of the sky later.\n\tfloat cloudDensity = 0.0;\n\t\n\tvec2 positionInSector = vec2(fract(phiSectors * phi / PI),\n\t\t\t\t\t\t\t\t fract(thetaSectors * theta / TWO_PI));\n\tpositionInSector -= .5;\n\t\n\tfor (float deltaThetaSector = -1.0; deltaThetaSector <= 1.0; deltaThetaSector += 1.0)\n\t{\n\t\tfloat currentThetaSector = thetaSector;\n\t\t\n\t\tif (deltaThetaSector < 0.0)\n\t\t\tcurrentThetaSector = thetaWest;\n\t\telse if (deltaThetaSector > 0.0)\n\t\t\tcurrentThetaSector = thetaEast;\n\t\n\t\tfor (float deltaPhiSector = -1.0; deltaPhiSector <= 1.0; deltaPhiSector += 1.0)\n\t\t{\n\t\t\tfloat currentPhiSector = phiSector;\n\t\t\t\n\t\t\tif (deltaPhiSector < 0.0)\n\t\t\t\tcurrentPhiSector = phiUp;\n\t\t\telse if (deltaPhiSector > 0.0)\n\t\t\t\tcurrentPhiSector = phiDown;\n\t\t\n\t\t\tfloat radiusInSector = getBlobSizeInSector(currentPhiSector, currentThetaSector);\n\t\t\t\n\t\t\t// How far away is the centre of this sector?\n\t\t\tvec2 distanceVector = vec2(deltaPhiSector, deltaThetaSector) - positionInSector;\n\t\t\t\n\t\t\tfloat remainder = radiusInSector - length(distanceVector);\n\t\t\t\n\t\t\tif (remainder > 0.0)\n\t\t\t{\n\t\t\t\tcloudDensity += remainder;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcloudDensity = min(pow(cloudDensity, 2.0)/1.5, 1.0);\n\t\n\treturn cloudDensity * cloudColour + (1.0 - cloudDensity) * skyColour;\n}\n\nvec3 calculateTotalSkyColourAtAngle(float phi, float theta, float time)\n{\n    theta = mod(theta + time, TWO_PI);\n    \n\t// Blend three layers of clouds, with the smaller clouds getting darker.\n\tvec3 skyColour = vec3(0.3, 0.5, 0.96 + 0.4*sin(theta + phi + time/35.0));\n    \n    // The sun is at phi = 0.25*pi, theta = pi\n    float sunDistance = abs(phi - 0.25*PI);\n    if (theta > PI)\n        sunDistance += theta - PI;\n    else\n        sunDistance += PI - theta;\n    \n    skyColour += 0.5*vec3(0.95, 0.45, 0.1)/sunDistance;\n    \n\tvec3 brightestCloudColour = vec3(0.95);\n\tvec3 middleCloudColour = vec3(0.9);\n\tvec3 darkestCloudColour = vec3(0.6);\n\t\n\tvec3 result = blendSkyColourAtAngle(phi, theta + time/20.0, 16.0, 32.0, skyColour, brightestCloudColour);\n\tresult = blendSkyColourAtAngle(phi, theta + time/15.0, 18.0, 36.0, result, middleCloudColour);\n\tresult = blendSkyColourAtAngle(phi, theta + time/10.0, 20.0, 40.0, result, darkestCloudColour);\n\t\n\treturn result;\n}\n\n// RGB =======================\n\n//Hue to RGB (red, green, blue).\n//Source: https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\n#ifndef saturate\n#define saturate(v) clamp(v,0.,1.)\n//      clamp(v,0.,1.)\n#endif\nvec3 hue2rgb(float hue){\n\thue=fract(hue);\n\treturn saturate(vec3(\n\t\tabs(hue*6.-3.)-1.,\n\t\t2.-abs(hue*6.-2.),\n\t\t2.-abs(hue*6.-4.)\n\t));\n}\n\n//HSV (hue, saturation, value) to RGB.\n//Sources: https://gist.github.com/yiwenl/745bfea7f04c456e0101, https://gist.github.com/sugi-cho/6a01cae436acddd72bdf\nvec3 hsv2rgb(vec3 c){\n\tvec4 K=vec4(1.,2./3.,1./3.,3.);\n\treturn c.z*mix(K.xxx,saturate(abs(fract(c.x+K.xyz)*6.-K.w)-K.x),c.y);\n}\n\n//RGB to HSV.\n//Source: https://gist.github.com/yiwenl/745bfea7f04c456e0101\nvec3 rgb2hsv(vec3 c) {\n\tfloat cMax=max(max(c.r,c.g),c.b),\n\t      cMin=min(min(c.r,c.g),c.b),\n\t      delta=cMax-cMin;\n\tvec3 hsv=vec3(0.,0.,cMax);\n\tif(cMax>cMin){\n\t\thsv.y=delta/cMax;\n\t\tif(c.r==cMax){\n\t\t\thsv.x=(c.g-c.b)/delta;\n\t\t}else if(c.g==cMax){\n\t\t\thsv.x=2.+(c.b-c.r)/delta;\n\t\t}else{\n\t\t\thsv.x=4.+(c.r-c.g)/delta;\n\t\t}\n\t\thsv.x=fract(hsv.x/6.);\n\t}\n\treturn hsv;\n}\n//Source: https://gist.github.com/sugi-cho/6a01cae436acddd72bdf\nvec3 rgb2hsv_2(vec3 c){\n\tvec4 K=vec4(0.,-1./3.,2./3.,-1.),\n\t     p=mix(vec4(c.bg ,K.wz),vec4(c.gb,K.xy ),step(c.b,c.g)),\n\t     q=mix(vec4(p.xyw,c.r ),vec4(c.r ,p.yzx),step(p.x,c.r));\n\tfloat d=q.x-min(q.w,q.y),\n\t      e=1e-10;\n\treturn vec3(abs(q.z+(q.w-q.y)/(6.*d+e)),d/(q.x+e),q.x);\n}\n\n//RGB to HSL (hue, saturation, lightness/luminance).\n//Source: https://gist.github.com/yiwenl/745bfea7f04c456e0101\nvec3 rgb2hsl(vec3 c){\n\tfloat cMin=min(min(c.r,c.g),c.b),\n\t      cMax=max(max(c.r,c.g),c.b),\n\t      delta=cMax-cMin;\n\tvec3 hsl=vec3(0.,0.,(cMax+cMin)/2.);\n\tif(delta!=0.0){ //If it has chroma and isn't gray.\n\t\tif(hsl.z<.5){\n\t\t\thsl.y=delta/(cMax+cMin); //Saturation.\n\t\t}else{\n\t\t\thsl.y=delta/(2.-cMax-cMin); //Saturation.\n\t\t}\n\t\tfloat deltaR=(((cMax-c.r)/6.)+(delta/2.))/delta,\n\t\t      deltaG=(((cMax-c.g)/6.)+(delta/2.))/delta,\n\t\t      deltaB=(((cMax-c.b)/6.)+(delta/2.))/delta;\n\t\t//Hue.\n\t\tif(c.r==cMax){\n\t\t\thsl.x=deltaB-deltaG;\n\t\t}else if(c.g==cMax){\n\t\t\thsl.x=(1./3.)+deltaR-deltaB;\n\t\t}else{ //if(c.b==cMax){\n\t\t\thsl.x=(2./3.)+deltaG-deltaR;\n\t\t}\n\t\thsl.x=fract(hsl.x);\n\t}\n\treturn hsl;\n}\n\n//HSL to RGB.\n//Source: https://github.com/Jam3/glsl-hsl2rgb/blob/master/index.glsl\n/*float hueRamp(float a,float b,float hue){\n\thue=fract(hue);\n\tfloat o=a;\n\tif((6.*hue)<1.){\n\t\to=a+(b-a)*6.*hue;\n\t}else if((2.*hue)<1.){\n\t\to=b;\n\t}else if((3.*hue)<2.){\n\t\to=a+(b-a)*((2./3.)-hue)*6.;\n\t}\n\treturn o;\n}*/\nvec3 hsl2rgb(vec3 hsl){\n\tif(hsl.y==0.){\n\t\treturn vec3(hsl.z); //Luminance.\n\t}else{\n\t\tfloat b;\n\t\tif(hsl.z<.5){\n\t\t\tb=hsl.z*(1.+hsl.y);\n\t\t}else{\n\t\t\tb=hsl.z+hsl.y-hsl.y*hsl.z;\n\t\t}\n\t\tfloat a=2.*hsl.z-b;\n\t\treturn a+hue2rgb(hsl.x)*(b-a);\n\t\t/*vec3(\n\t\t\thueRamp(a,b,hsl.x+(1./3.)),\n\t\t\thueRamp(a,b,hsl.x),\n\t\t\thueRamp(a,b,hsl.x-(1./3.))\n\t\t);*/\n\t}\n}\n\n//RGB to YCbCr, ranges [0, 1].\n//Source: https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\nvec3 rgb2ycbcr(vec3 c){\n\tfloat y=.299*c.r+.587*c.g+.114*c.b;\n\treturn vec3(y,(c.b-y)*.565,(c.r-y)*.713);\n}\n\n//YCbCr to RGB.\nvec3 ycbcr2rgb(vec3 yuv){\n\treturn vec3(\n\t\tyuv.x+1.403*yuv.z,\n\t\tyuv.x- .344*yuv.y-.714*yuv.z,\n\t\tyuv.x+1.770*yuv.y\n\t);\n}\n\n//CIE L*a*b* (CIELAB, L* for lightness, a* from green to red, b* from blue to yellow)\n//Source: https://gist.github.com/mattatz/44f081cac87e2f7c8980 (HLSL)\nvec3 rgb2xyz(vec3 c){\n\tvec3 tmp=vec3(\n\t\t(c.r>.04045)?pow((c.r+.055)/1.055,2.4):c.r/12.92,\n\t\t(c.g>.04045)?pow((c.g+.055)/1.055,2.4):c.g/12.92,\n\t\t(c.b>.04045)?pow((c.b+.055)/1.055,2.4):c.b/12.92\n\t);\n\tmat3 mat=mat3(\n\t\t.4124,.3576,.1805,\n\t\t.2126,.7152,.0722,\n\t\t.0193,.1192,.9505\n\t);\n\treturn 100.*(tmp*mat);\n}\nvec3 xyz2lab(vec3 c){\n\tvec3 n=c/vec3(95.047,100.,108.883),\n\t     v=vec3(\n\t\t(n.x>.008856)?pow(n.x,1./3.):(7.787*n.x)+(16./116.),\n\t\t(n.y>.008856)?pow(n.y,1./3.):(7.787*n.y)+(16./116.),\n\t\t(n.z>.008856)?pow(n.z,1./3.):(7.787*n.z)+(16./116.)\n\t);\n\treturn vec3((116.*v.y)-16.,500.*(v.x-v.y),200.*(v.y-v.z));\n}\nvec3 rgb2lab(vec3 c){\n\tvec3 lab=xyz2lab(rgb2xyz(c));\n\treturn vec3(lab.x/100.,.5+.5*(lab.y/127.),.5+.5*(lab.z/127.));\n}\nvec3 lab2xyz(vec3 c){\n\tfloat fy=(c.x+16.)/116.,\n\t      fx=c.y/500.+fy,\n\t      fz=fy-c.z/200.;\n\treturn vec3(\n\t\t 95.047*((fx>.206897)?fx*fx*fx:(fx-16./116.)/7.787),\n\t\t100.   *((fy>.206897)?fy*fy*fy:(fy-16./116.)/7.787),\n\t\t108.883*((fz>.206897)?fz*fz*fz:(fz-16./116.)/7.787)\n\t);\n}\nvec3 xyz2rgb(vec3 c){\n\tmat3 mat=mat3(\n\t\t3.2406,-1.5372,-.4986,\n\t\t-.9689, 1.8758, .0415,\n\t\t .0557, -.2040,1.0570\n\t);\n\tvec3 v=(c/100.0)*mat,\n\t     r=vec3(\n\t\t(v.r>.0031308)?((1.055*pow(v.r,(1./2.4)))-.055):12.92*v.r,\n\t\t(v.g>.0031308)?((1.055*pow(v.g,(1./2.4)))-.055):12.92*v.g,\n\t\t(v.b>.0031308)?((1.055*pow(v.b,(1./2.4)))-.055):12.92*v.b\n\t);\n\treturn r;\n}\nvec3 lab2rgb(vec3 c){return xyz2rgb(lab2xyz(vec3(100.*c.x,2.*127.*(c.y-.5),2.*127.*(c.z-.5))));}\n\n//RGB to sRGB (standard Red Green Blue).\n//Source: https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\nconst float SRGB_ALPHA=.055;\nfloat linear2srgb(float x){\n\tif(x<=.0031308){\n\t\treturn 12.92*x;\n\t}else{\n\t\treturn(1.+SRGB_ALPHA)*pow(x,1./2.4)-SRGB_ALPHA;\n\t}\n}\nvec3 rgb2srgb(vec3 c){\n\treturn vec3(\n\t\tlinear2srgb(c.r),\n\t\tlinear2srgb(c.g),\n\t\tlinear2srgb(c.b)\n\t);\n}\n//sRGB to RGB.\nfloat srgb2linear(float x) {\n\tif(x<=.04045){\n\t\treturn x/12.92;\n\t}else{\n\t\treturn pow((x+SRGB_ALPHA)/(1.+SRGB_ALPHA),2.4);\n\t}\n}\nvec3 srgb2rgb(vec3 c){\n\treturn vec3(\n\t\tsrgb2linear(c.r),\n\t\tsrgb2linear(c.g),\n\t\tsrgb2linear(c.b)\n\t);\n}\n\n//XYZ to CIE 1931 Yxy color space (luma (Y) along with x and y chromaticity), I found that Photoshop used this.\nvec3 xyz2yxy(vec3 c){\n\tfloat s=c.x+c.y+c.z;\n\treturn vec3(c.y,c.x/s,c.y/s); //Blue's within s.\n}\nvec3 yxy2xyz(vec3 c){\n\tfloat x=c.x*(c.y/c.z); //Y*(x/y)\n\treturn vec3(x,c.x,(x/c.y)-x-c.x); //(X,Y,(X/x)-X-Y)\n}\nvec3 rgb2yxy(vec3 c){return xyz2yxy(rgb2xyz(c));}\nvec3 yxy2rgb(vec3 c){return xyz2rgb(yxy2xyz(c));}\n\n//RGB to CMYK (cyan, magenta, yellow, key).\nvec4 rgb2cmyk(vec3 c){\n\tfloat k=1.-max(max(c.r,c.g),c.b);\n\treturn vec4(\n\t\t(1.-c.r-k)/(1.-k),\n\t\t(1.-c.g-k)/(1.-k),\n\t\t(1.-c.b-k)/(1.-k),\n\t\tk\n\t);\n}\n//CMYK to RGB.\nvec3 cmyk2rgb(vec4 c){\n\treturn vec3(\n\t\t(1.-c.x)*(1.-c.w),\n\t\t(1.-c.y)*(1.-c.w),\n\t\t(1.-c.z)*(1.-c.w)\n\t);\n}\nvec3 inkColors[18]=vec3[]( //SWOP (Coated), RGB and Yxy.\n\tvec3(0.,1.,1.),   vec3(26.25,.1673,.2328), //C\n\tvec3(1.,0.,1.),   vec3(14.5,.4845,.2396),  //M\n\tvec3(1.,1.,0.),   vec3(71.2,.4357,.5013),  //Y\n\tvec3(1.,0.,0.),   vec3(14.09,.6075,.3191), //MY\n\tvec3(0.,1.,0.),   vec3(19.25,.2271,.5513), //CY\n\tvec3(0.,0.,1.),   vec3(2.98,.2052,.1245),  //CM\n\tvec3(.25,.25,.25),vec3(2.79,.3227,.2962),  //CMY\n\tvec3(1.,1.,1.),   vec3(83.02,.3149,.3321), //W\n\tvec3(0.,0.,0.),   vec3(.82,.3202,.3241)    //K\n);\n//TODO: Look at SWOP 2006 ICC Profile.\n//vec3 pal[]=vec3[](vec3(0.,.5765,.8275),vec3(.8,0.05,.4196),vec3(1.,.9451,.0471),vec3(.0784));\nvec3 cmyk2rgb_pal(vec4 c){ //This might be an incorrect way of blending.\n\t/*return saturate((1.-(\n\t\t(c.x*(1.-vec3(0.,.5765,.8275)))+\n\t\t(c.y*(1.-vec3(.8,0.05,.4196)))+\n\t\t(c.z*(1.-vec3(1.,.9451,.0471)))\n\t))*(1.-(c.w*.9216)));*/\n\treturn\n\t\tmix(vec3(1.),vec3(0.,.5765,.8275),c.x)*\n\t\tmix(vec3(1.),vec3(.8,0.05,.4196),c.y)*\n\t\tmix(vec3(1.),vec3(1.,.9451,.0471),c.z)*\n\t\tmix(1.,.0784,c.w);\n}","name":"Common","description":"","type":"common"}]}