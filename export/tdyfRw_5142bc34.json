{"ver":"0.1","info":{"id":"tdyfRw","date":"1606866440","viewed":596,"name":"Realistic Ocean with Reflections","username":"erkan612","description":"This is realistic ocean with simple ray marching(sphere tracing) techniques.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection","lighting","ocean","sky","fog","realistic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n* Created by erkan612 - 02.12.2020\n* * Discord: erkan612#9667\n*/\n\nconst vec3 BACKGROUND_COLOR = vec3(0.0, 1.0, 0.0);\nconst vec3 DEFAULT_MESH_COLOR = vec3(0.8);\nconst int MAX_STEPS = 150;\nconst float SURFACE_DISTANCE = 0.01;\nconst float MAX_RENDER_DISTANCE = 40.0;\nconst int MAX_REFLECTION_STEPS = 20;\nconst float FOG_START = 20.0;\nconst float FOG_END = 50.0;\nconst vec3 FOG_COLOR = vec3(1.0);\nconst vec3 SKY_DOWN_COLOR = vec3(1.0);\nconst vec3 SKY_UP_COLOR = vec3(0.7, 0.8, 1.0)*1.15;\nconst vec3 SEA_BASE_COLOR = vec3(0.1,0.2,0.3)*1.2;\nconst vec3 SEA_WATER_COLOR = vec3(0.5)*0.5;\n\n// Ocean Displacement Req\nfloat Hash(vec2);\nfloat Noise(vec2);\nfloat SeaHard(vec2, float);\nfloat SeaHeight(vec2, float, int, float);\n\n// Ocean\nvec3 GetOceanColor(vec3, vec3, vec3);\n\n// Secene Maps\nvec4 MAP_Scene(vec3, vec3);\nvec4 MAP_DETAILED_Scene(vec3);\nvec4 MAP_REFLECTION_Scene(vec3, vec3);\nvec4 MAP_SIMPLE_Scene(vec3);\n\n// N\nvec3 GetNormal(vec3);\nvec3 GetNormalForReflection(vec3);\nvec3 Diffuse(vec3, vec3, int, vec3);\nvec3 Specular(vec3, vec3, vec3, vec3, float);\n\n// Ray Tracing\nvec3 RayMarch(vec3, vec3);\nvec3 REFLECTION_RayMarch(vec3, vec3);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/min(iResolution.x, iResolution.y);\n    float t = float(iTime/75.0);\n    float d = 12.0;\n    //t = 0.0;\n    float pitorad = 180.0/3.1415;\n    \n    vec3 ro = vec3(cos(t*pitorad) * d, 0.3*d, sin(t*pitorad)*d);\n    //vec3 ro = vec3(0.0, 1.0, -3.0);\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    \n    vec3 cz = normalize(ta - ro);\n    vec3 cx = normalize(cross(vec3(0.0, 1.0, 0.0), cz));\n    vec3 cy = normalize(cross(cz, cx));\n    vec3 rd = normalize(cx * uv.x + cy * uv.y + cz * 1.0);\n    vec3 color = RayMarch(ro, rd);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n// Ocean Displacement Req\nfloat Hash(vec2 p) {\n\treturn fract(sin(dot(p, vec2(5.5, 8.5)*84.5))*845.8425);\n}\n\nfloat Noise(vec2 p) {\n\tvec2 lv = smoothstep(0.0, 1.0, fract(p));\n    vec2 id = floor(p);\n    \n    float bl = Hash(id);\n    float br = Hash(id+vec2(1.0, 0.0));\n    float b = smoothstep(0.0, 1.0, mix(bl, br, lv.x));\n    \n    float tl = Hash(id+vec2(0.0, 1.0));\n    float tr = Hash(id+vec2(1.0, 1.0));\n    float t = smoothstep(0.0, 1.0, mix(tl, tr, lv.x));\n    \n    return mix(b, t, lv.y);\n}\n\nfloat SeaHard(vec2 p, float hard) {\n    p += Noise(p);\n    vec2 aw = 1.0-abs(sin(p));\n    vec2 bw = abs(cos(p));\n\taw = mix(aw,bw,aw);\n    return pow(1.0-pow(aw.x*aw.y,0.65), hard);\n}\n\nfloat SeaHeight(vec2 p, float timeShift, int detail, float freqSize) {\n\tfloat h = 0.0;\n    float hard = 4.0;\n    float freq = 0.1 * freqSize;\n    float hh = 1.0;\n    \n    for (int i = 0; i < detail; i++) {\n    \tfloat d = SeaHard((p+timeShift)*freq, hard);\n    \td += SeaHard((p-timeShift)*freq, hard);\n        h += d * hh;\n        hard = mix(hard, 1.0, 0.2);\n        hh *= 0.22;\n        freq *= 1.9;\n        p *= vec2(1.66, -1.60);\n    };\n    \n    return 1.0-h;\n}\n\n// Ocean\nvec3 GetOceanColor(vec3 p, vec3 n, vec3 eye) {\n    vec3 color = DEFAULT_MESH_COLOR;\n    vec3 eyeVec = normalize(eye - p);\n    \n    float fresnel = 1.0-max(dot(eyeVec, n), 0.0);\n    fresnel = pow(fresnel, 3.0)*0.4;\n    \n    vec3 diff = Diffuse(normalize(vec3(1.0, 1.0, 0.2)), n, 1, vec3(1.0));\n    \n    vec3 reflected = vec3(1.0);\n    vec3 refracted = SEA_BASE_COLOR + diff * SEA_WATER_COLOR * 0.15;\n    color = mix(refracted, reflected, fresnel);\n    \n    color += SEA_WATER_COLOR * p.y * 0.5;\n    \n    color += Specular(normalize(vec3(1.0, 1.0, 0.2)), n, eyeVec, vec3(1.0), 64.0);\n    \n\treturn color;\n}\n\n// Scene Maps\nvec4 MAP_REFLECTION_Scene(vec3 p, vec3 eye, int mode) { // Main Reflection Scene\n\tfloat fulldist = 9999.0;\n    float dist = fulldist;\n    vec3 color = DEFAULT_MESH_COLOR;\n    vec3 n = mode == 1 ? GetNormalForReflection(p) : vec3(0.0);\n    vec3 diff = mode == 1 ? Diffuse(normalize(vec3(1.0, 1.0, 0.2)), n, 1, vec3(1.0)) : vec3(1.0);\n    \n    // Red Sphere\n    {\n        vec3 sphereColor = vec3(1.0, 0.0, 0.0);\n        float sphereRadius = 1.0;\n        vec3 spherePosition = vec3(0.0, 1.0, 0.0);\n        float sphereDist = length(p-spherePosition)-sphereRadius;\n        if (sphereDist < dist) {\n            color = sphereColor*diff;\n            dist = sphereDist;\n        }\n    }\n    \n    // Ocean\n    {\n        vec3 oceanColor = mode == 1 ? GetOceanColor(p, n, eye) : vec3(1.0);\n        float oceanHeight = 0.0;\n        vec3 oceanP = p + SeaHeight(p.xz, float(iTime), 1, 1.0);\n        float oceanDist = dot(oceanP, vec3(0.0, 1.0, 0.0))-oceanHeight;\n        if (oceanDist < dist) {\n            color = oceanColor;\n            dist = oceanDist;\n        }\n    }\n    \n    return vec4(color, dist);\n}\n\nvec4 MAP_Scene(vec3 p, vec3 eye, int mode) { // Main Scene\n\tfloat fulldist = 9999.0;\n    float dist = fulldist;\n    vec3 color = DEFAULT_MESH_COLOR;\n    vec3 n = mode == 1 ? GetNormal(p) : vec3(0.0);\n    vec3 diff = mode == 1 ? Diffuse(normalize(vec3(1.0, 1.0, 0.2)), n, 1, vec3(1.0)) : vec3(1.0);\n    \n    // Red Sphere\n    {\n        vec3 sphereColor = vec3(1.0, 0.0, 0.0);\n        float sphereRadius = 1.0;\n        vec3 spherePosition = vec3(0.0, 1.0, 0.0);\n        float sphereDist = length(p-spherePosition)-sphereRadius;\n        if (sphereDist < dist) {\n            vec3 reflected = mode == 1 ? REFLECTION_RayMarch(p+n*SURFACE_DISTANCE, reflect(-normalize(eye-p), n)) : vec3(1.0);\n            color = mix(sphereColor, reflected, 0.5)*diff;\n            dist = sphereDist;\n        }\n    }\n    \n    // Ocean\n    {\n        vec3 oceanColor = mode == 1 ? GetOceanColor(p, n, eye) : vec3(1.0);\n        float oceanHeight = 0.0;\n        vec3 oceanP = p + SeaHeight(p.xz, float(iTime), 2, 1.0);\n        float oceanDist = dot(oceanP, vec3(0.0, 1.0, 0.0))-oceanHeight;\n        if (oceanDist < dist) {\n            vec3 reflected = mode == 1 ? REFLECTION_RayMarch(oceanP+n*SURFACE_DISTANCE, reflect(-normalize(eye-oceanP), n)) : vec3(1.0);\n            color = mix(oceanColor, reflected, max(dot(normalize(eye-p), n), 0.0)/5.0);\n            dist = oceanDist;\n        }\n    }\n    \n    return vec4(color, dist);\n}\n\nvec4 MAP_DETAILED_Scene(vec3 p) { // Detailed Main Secene\n\tfloat fulldist = 9999.0;\n    float dist = fulldist;\n    vec3 color = DEFAULT_MESH_COLOR;\n    \n    // Red Sphere\n    {\n        vec3 sphereColor = vec3(1.0, 0.0, 0.0);\n        float sphereRadius = 1.0;\n        vec3 spherePosition = vec3(0.0, 1.0, 0.0);\n        float sphereDist = length(p-spherePosition)-sphereRadius;\n        if (sphereDist < dist) {\n            color = sphereColor;\n            dist = sphereDist;\n        }\n    }\n    \n    // Ocean\n    {\n        vec3 oceanColor = vec3(1.0);\n        float oceanHeight = 0.0;\n        vec3 oceanP = p + SeaHeight(p.xz, float(iTime), 5, 1.0);\n        float oceanDist = dot(oceanP, vec3(0.0, 1.0, 0.0))-oceanHeight;\n        if (oceanDist < dist) {\n            color = oceanColor;\n            dist = oceanDist;\n        }\n    }\n    \n    return vec4(color, dist);\n}\n\nvec4 MAP_SIMPLE_Scene(vec3 p) {\n\tfloat fulldist = 9999.0;\n    float dist = fulldist;\n    vec3 color = DEFAULT_MESH_COLOR;\n    \n    // Red Sphere\n    {\n        vec3 sphereColor = vec3(1.0, 0.0, 0.0);\n        float sphereRadius = 1.0;\n        vec3 spherePosition = vec3(0.0, 1.0, 0.0);\n        float sphereDist = length(p-spherePosition)-sphereRadius;\n        if (sphereDist < dist) {\n            color = sphereColor;\n            dist = sphereDist;\n        }\n    }\n    \n    // Ocean\n    {\n        vec3 oceanColor = vec3(1.0);\n        float oceanHeight = 0.0;\n        vec3 oceanP = p + SeaHeight(p.xz, float(iTime), 1, 1.0);\n        float oceanDist = dot(oceanP, vec3(0.0, 1.0, 0.0))-oceanHeight;\n        if (oceanDist < dist) {\n            color = oceanColor;\n            dist = oceanDist;\n        }\n    }\n    \n    return vec4(color, dist);\n}\n\n// N\nvec3 GetNormal(vec3 p) {\n\tvec2 e = vec2(SURFACE_DISTANCE, 0.0);\n    float dist = MAP_DETAILED_Scene(p).w;\n    return normalize(dist-vec3(\n    \tMAP_DETAILED_Scene(p-e.xyy).w,\n        MAP_DETAILED_Scene(p-e.yxy).w,\n        MAP_DETAILED_Scene(p-e.yyx).w\n    ));\n}\nvec3 GetNormalForReflection(vec3 p) {\n\tvec2 e = vec2(SURFACE_DISTANCE, 0.0);\n    float dist = MAP_SIMPLE_Scene(p).w;\n    return normalize(dist-vec3(\n    \tMAP_SIMPLE_Scene(p-e.xyy).w,\n        MAP_SIMPLE_Scene(p-e.yxy).w,\n        MAP_SIMPLE_Scene(p-e.yyx).w\n    ));\n}\n\nvec3 Diffuse(vec3 l, vec3 n, int normalized, vec3 color) {\n\treturn (normalized == 1 ? dot(l,n)*0.5+0.5 : max(dot(l,n), 0.0)) * color;\n}\n\nvec3 Specular(vec3 l, vec3 n, vec3 eyeVec, vec3 color, float s) {\n\treturn pow(max(dot(normalize(reflect(-eyeVec, n)), l), 0.0), s)*color;\n}\n\n// Ray Tracing\nvec3 REFLECTION_RayMarch(vec3 ro, vec3 rd) {\n\tvec3 color = vec3(0.5);\n    float st = 1.0/float(MAX_REFLECTION_STEPS);\n    vec3 p = vec3(0.0);\n    \n    for (int i = 0; i < MAX_REFLECTION_STEPS; i++) {\n    \tp = ro + rd*st;\n        vec4 mesh = MAP_REFLECTION_Scene(p, ro, 0);\n        \n        // Scene Color\n        if (mesh.w <= SURFACE_DISTANCE) {\n            mesh = MAP_REFLECTION_Scene(p, ro, 1);\n            vec3 sceneColor = mesh.xyz;\n        \t\n             if (st>=FOG_START) {\n            \tfloat nrmlz = st - FOG_START;\n                nrmlz /= FOG_END - FOG_START;\n                sceneColor = mix(sceneColor, FOG_COLOR, pow(nrmlz, 1.0));\n            }\n            \n            color = sceneColor;\n            break;\n        }\n        \n        if (st >= MAX_RENDER_DISTANCE) {\n        \tbreak;\n        }\n        \n        st += mesh.w;\n    }\n    \n    // Sky(Background) Color\n    if (st >= MAX_RENDER_DISTANCE) {\n    \tcolor = mix(SKY_DOWN_COLOR, SKY_UP_COLOR, pow(abs(p.y), 0.1));\n    }\n    \n    return color;\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd) {\n\tvec3 color = BACKGROUND_COLOR;\n    float st = 0.0;\n    vec3 p = vec3(0.0);\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n    \tp = ro + rd*st;\n        vec4 mesh = MAP_Scene(p, ro, 0);\n        \n        // Scene Color\n        if (mesh.w <= SURFACE_DISTANCE) {\n            mesh = MAP_Scene(p, ro, 1);\n            vec3 sceneColor = mesh.xyz;\n        \t\n             if (st>=FOG_START) {\n            \tfloat nrmlz = st - FOG_START;\n                nrmlz /= FOG_END - FOG_START;\n                sceneColor = mix(sceneColor, FOG_COLOR, pow(nrmlz, 1.0));\n            }\n            \n            color = sceneColor;\n            break;\n        }\n        \n        if (st >= MAX_RENDER_DISTANCE) {\n        \tbreak;\n        }\n        \n        st += mesh.w;\n    }\n    \n    // Sky(Background) Color\n    if (st >= MAX_RENDER_DISTANCE) {\n    \tcolor = mix(SKY_DOWN_COLOR, SKY_UP_COLOR, pow(abs(p.y), 0.1));\n    }\n    \n    return color;\n}","name":"Image","description":"","type":"image"}]}