{"ver":"0.1","info":{"id":"clBXRz","date":"1675537217","viewed":33,"name":"Rounded Rect w/ (in/out)line","username":"KraftJrIvo","description":"a simple useful rounded rectangle shader","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["util"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// rectangle \n//(origin is at the bottom left corner)\nconst vec4 RECT = vec4(100., 200., 300., 400.);\n\n// corner roundness\nconst float RADIUS = 10.;\n\n// in/out contour width\nconst float IN_W  = 0.;\nconst float OUT_W = 5.;\n\n//colors\nconst vec3 BG_COLOR  = vec3(1., 0., 0.);\nconst vec3 IN_COLOR  = vec3(.75, 0., 0.);\nconst vec3 OUT_COLOR = vec3(.6, 0., 0.);\n\nvec3 rect(in vec2 fragCoord, in vec4 rect, in float radius, in float inW, in float outW, in vec3 bgClr, in vec3 inClr, in vec3 outClr)\n{\n    vec4 inRect = vec4(rect.x + radius, rect.y + radius , rect.z - radius * 2., rect.w - radius * 2.);\n    vec2 r = fragCoord - inRect.xy;\n    float x = r.x * float(r.x < 0.) + (r.x - inRect.z) * float(r.x > inRect.z);\n    float y = r.y * float(r.y < 0.) + (r.y - inRect.w) * float(r.y > inRect.w);\n    vec2 center = inRect.xy + inRect.zw * .5;\n    float len = length(vec2(x, y));\n    float bgCoeff = smoothstep(float(len < radius), clamp(len - radius, 0., 1.), 0.);//float(len < radius);\n    //float inCoeff = float(\n    //    (len > 0. && len > radius - inW && len < radius) || \n    //    (inW > radius && (\n    //        (abs(center.x - fragCoord.x) > rect.z * .5 - inW) || \n    //        (abs(center.y - fragCoord.y) > rect.w * .5 - inW)))\n    //);\n    //float outCoeff = smoothstep(float(len > radius), 0., clamp((len - radius) - outW, 0., 1.));\n    //return bgClr * (bgCoeff - inCoeff) + inClr * inCoeff + outClr * outCoeff;\n    vec3 scnd = (IN_W > 0.) ? IN_COLOR : (OUT_W > 0. ? OUT_COLOR : vec3(0.));\n    vec3 thrd = (IN_W > 0.) ? (OUT_W > 0. ? OUT_COLOR : vec3(0.)) : vec3(0.);\n    return \n        BG_COLOR * smoothstep(1., 0., clamp(len - radius, 0., 1.)) +\n        OUT_COLOR * smoothstep(9., 0., clamp(radius - len - 2., 0., 1.));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col  = rect(fragCoord, RECT, RADIUS, IN_W, OUT_W, BG_COLOR, IN_COLOR, OUT_COLOR);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}