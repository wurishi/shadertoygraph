{"ver":"0.1","info":{"id":"3ddSz4","date":"1571606638","viewed":260,"name":"Floating Sandbox Rain","username":"GabrieleGiuseppini","description":"Experiments for Floating Sandbox's rain.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["rain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y /= (iResolution.x / iResolution.y); // obey aspect ratio\n    \n    float paramRainDensity = 1.; //.3;    \n    float paramTime = float(iFrame) / 10.;\n    \n    \n    //\n    // ---------------------------------------------\n    //\n    \n    #define RainSpatialDensityX 45.\n    #define RainSpatialDensityY 30.\n    #define RainMaxDensity .4\n    #define RainSpeed 7.\n    #define DropletLength .9\n    #define DropletWidth .08\n    \n    vec2 scaledUV = uv * vec2(RainSpatialDensityX, RainSpatialDensityY);\n        \n    // Calculate tile X coordinate\n    float tileX = floor(scaledUV.x);\n    \n\t// Offset Y based off time, and in two different ways to provide \n    // a sense of depth\n    scaledUV.y += \n        paramTime \n        * RainSpeed \n        * (.8 + mod(tileX, 3.) * .1);\n                \n    // Offset Y randomly based off its tile X coordinate\n    scaledUV.y += 407.567 * fract(351.5776456 * tileX);\n    \n    // Calculate tile Y coordinate\n    float tileY = floor(scaledUV.y);\n    \n    // Decide whether tile is turned off\n    float randOnOff = fract(sin(tileX * 71. + tileY * 7.));\n    float onOffThickness = 1. - step(paramRainDensity * RainMaxDensity, randOnOff);\n    \n    //if (onOffThickness == 0.)\n    //    discard;\n    \n    // Calculate coords within the tile\n    vec2 inTile = fract(scaledUV);\n    \n    // Shuffle tile center X based on its tile coordinates\n    float rand = fract(sin(77.7 * tileY + 7.7 * tileX));\n    float tileCenterX = .5 + (abs(rand) - .5) * (1. - DropletWidth);\n        \n    // Distance from center of tile\n    float xDistance = abs(tileCenterX - inTile.x);\n    float yDistance = abs(.5 - inTile.y);\n    \t    \n    // Thickness of droplet:\n    //    > 0.0 only within Width\n    //    ...with some tile-specific randomization\n    float clampedXDistance = smoothstep(.0, DropletWidth, xDistance);\n    float dropletThickness = (1. - clampedXDistance) * smoothstep(1. - DropletLength + rand/2.4, 1., 1. - yDistance);\n    \n    // TODOTEST\n    vec2 dropletHead = vec2(tileCenterX, .2);\n    dropletThickness = 1.0 * mix(\n        dropletThickness, \n        1. - min(1., distance(inTile, dropletHead)),\n        0.);\n    //dropletThickness = 1. - min(1., distance(inTile, dropletHead));\n    \n    \n    //\n    // ---------------------------------------------\n    //\n\n    // Turning off tiles\n    dropletThickness *= onOffThickness;\n    \n    //vec3 c = mix(vec3(.5, .7, .95), vec3(dropletThickness), smoothstep(.4, 1., dropletThickness));\n    vec3 c = mix(vec3(.5, .7, .95), vec3(1.), smoothstep(.4, 1., dropletThickness));\n\n    // Output to screen\n    fragColor = vec4(c, 1.);\n}","name":"Image","description":"","type":"image"}]}