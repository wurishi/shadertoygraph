{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"XdfGR8","filepath":"/media/previz/buffer03.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":3,"type":"texture","id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Redo of a cloth sim I made a long time ago\n// since I lost the source to that one somehow.\n// idk what happened, have exe but can't find source backup.\n// But never had to do it all in a frag shader before!  ;)\n\n// Probably not the best cloth physics or rendering,\n// but it's what I've got going in WebGL atm.\n// I think my original sim was better.\n\n// fork of Orbit Camera at https://shadertoy.com/view/WlVGD1\n// borrows heavily from reinder & iq's \n// compilation at https://shadertoy.com/view/tl23Rm\n// I might switch over to use my own tracers at some point\n// but for now I've just modified theirs.\n\n// FIXME the flag physics seems a little spastic\n// TODO shadows\n\n// can be swapped out for any flag colors you like.\n\n// made a toy just for Old Glory on 4th for 2020!\n// https://shadertoy.com/view/ttXyD2\n// now can leave this basic Cloth Flag without all the\n// bells and whistles so it's easier to understand\n// and possibly less controversial.\n// Can leave debugging & wireframe stuff in this one.\n\n#define ClothBuf iChannel0\n\nconst vec3 sunDir = normalize(vec3(.3,.6,.5))\n, skyColor = vec3(.1,.5,.9) //vec3(.1,.4,.7) //\n, sunColor = vec3(1.2)\n, glowColor = vec3(1.7,1.4,1);\n\nconst float ambient = .15;\n\n// TODO Having some sort of acceleration structure,\n// such as a spatial index of closest nearby particle,\n// would help with rendering.\n\n// I figure since we're brute forcing it all anyway\n// and having to iterate over the particles more than once\n// may as well just load them all into a big array, right?\n// on cpu that would be a fine strategy, but on gpu probably not.\n// It'll be ok up to a certain total particle count,\n// but then again, the alternative, re-reading them\n// and relying on compiler to discard duplicates,\n// seems more unwise.  For now it seems ok up to 12x9 or so.\n\n// loading all particles at once at start of mainImage\n// seems wise, otherwise we'd wind up needing to do it all\n// multiple times per pixel per frame, as it's all referenced\n// inside the main raymarch loop to draw the links!\nvec3[nlinkx*nlinky] ps;\n\nvec3 flagbblo, flagbbhi; // world AABB bounding box of flag particles\n\nint pidx(int i, int j) \n{ \n    return i + j * nlinkx; \n}\n\nvec3 vnormal(ivec2 p)\n{\n    ivec2 i = p;\n    i = clamp(i, ivec2(0), ivec2(nlinkx, nlinky)-2);\n    int j = pidx(i.x,i.y);\n    vec3 n0 = ps[j]; // must normalize prior to interpolation\n    return normalize(cross(ps[j+1]-n0, ps[j+nlinkx]-n0));\n}\n\nvec3 vnormal(vec2 q)\n{\n    ivec2 i = ivec2(floor(q));\n    vec2 f = q - vec2(i);\n    // now should be a simple matter of bilinear interpolation\n    // but doing it this way means we need 4 normals to lerp between, not 3\n    vec3 sn00 = vnormal(i)\n    , sn01 = vnormal(i + ivec2(1,0))\n    , sn10 = vnormal(i + ivec2(0,1))\n    , sn11 = vnormal(i + ivec2(1));\n    return mix(mix(sn00, sn01, f.x)\n             , mix(sn10, sn11, f.x), f.y);\n}\n\n// my intersection interface uses out args\n// out args are only valid if returned time\n// indicates a valid intersection (is positive)\n\n// Ray/Triangle through vertices v0, v1 and v2, reworked by spalmer\n// original by iq from https://iquilezles.org/articles/intersectors\n// just reusing the same variables, made all relative to v0 implicitly\n// changed interface to use out args\nfloat iTri(vec3 ro, vec3 rd          // ray org and dir\n         , vec3 v0, vec3 v1, vec3 v2 // vertices\n         , out vec3 n, out vec2 uv)  // normal and uv at hit point, returns hit time\n{\n    v1 -= v0; v2 -= v0; ro -= v0;\n          n = cross(v1, v2);\n    vec3  q = cross(ro, rd);\n    float d = 1.0 / dot(rd, n)\n    , u = -d * dot(q, v2)\n    , v =  d * dot(q, v1)\n    , t = -d * dot(n, ro);\n    if (u < 0.0 || v < 0.0 || u+v > 1.0) t = -1.0;\n    if (dot(n, rd) > 0.) n = -n; // double-sided, use whichever side faces ray origin\n    // FIXME flat shaded normals; should gouraud shade at least; interpolate between 3 normals\n    // maybe only after final closest hit determined?  Think it could still be done then.\n    uv = vec2(1.-u, v); // FIXME straighten out these sign HACKS\n    return t;\n}\n// see also https://shadertoy.com/view/MlGcDz which has several MIT licensed variations\n\n// Ray/Plane - modified from reinder's compilation at https://shadertoy.com/view/tl23Rm\nfloat iPlane(vec3 ro, vec3 rd\n           , vec3 planeNormal, float planeDist\n           , out vec3 normal, out vec2 uv)\n{\n    float a = dot(rd, planeNormal);\n    float t = -(dot(ro, planeNormal) + planeDist) / a;\n    if (a > 0.0 || t < 0.0)\n        t = -1.0;\n\telse \n        normal = planeNormal, uv = (ro + rd * t).xz;\n\treturn t;\n}\n\n// Ray/Sphere - modified from reinder's compilation at https://shadertoy.com/view/tl23Rm\n// https://shadertoy.com/view/4d2XWV\nfloat iSphere(vec3 ro, vec3 rd\n              , vec3 center, float sphereRadius\n              , out vec3 normal, out vec2 uv)\n{\n    ro -= center;\n    float b = dot(ro, rd)\n    , c = dot(ro, ro) - sphereRadius*sphereRadius\n    , h = b*b - c\n    , d = -1.0;\n    if (h >= 0.) {\n\t    h = sqrt(h);\n        float d1 = -b-h\n        , d2 = -b+h;\n        if (d1 >= 0.) {\n            normal = ro + rd*d1;\n            d = d1;\n        } else if (d2 >= 0.) {\n            normal = ro + rd*d2;            \n            d = d2;\n        }\n    }\n    uv = vec2(.5); // TODO unused though\n    return d;\n}\n\n// Ray/Cylinder - modified from reinder's compilation at https://shadertoy.com/view/tl23Rm\n// Capped Cylinder: https://shadertoy.com/view/4lcSRn\nfloat iCylinder(vec3 ro, vec3 rd\n               , vec3 A, vec3 B, float r\n               , out vec3 normal, out vec2 uv)\n{\n    vec3 ca = B-A\n       , oc = ro-A;\n    float caca = dot(ca,ca)\n        , card = dot(ca,rd)\n        , caoc = dot(ca,oc)\n    , a = caca - card*card\n    , b = caca * dot(oc, rd) - caoc*card\n    , c = caca * dot(oc, oc) - caoc*caoc - r*r*caca\n    , h = b*b - a*c\n\t, d = -1.0;\n    if (h >= 0.) {\n\t    h = sqrt(h);\n\t    d = (-b-h)/a;\n\t    float y = caoc + d*card;\n\t    if (y > 0. && y < caca)\n\t        normal = oc+d*rd-ca*y/caca, uv = vec2(atan((oc+d*rd).x, (oc+d*rd).z), 2. / pi / r * length(ca) * y / caca);\n\t    else {\n\t\t    d = ((y < 0. ? 0. : caca) - caoc) / card;    \n\t\t    if (abs(b+a*d) < h && d >= 0.0)\n\t\t\t\tnormal = ca*sign(y)/caca, uv = (oc+d*rd).xz;\n\t\t\telse\n\t\t\t\td = -1.0;\n\t    }\n    }\n\treturn d;\n}\n// for a fake building or something for some scenery, also for bounding box of flag\n// Box: - modified from reinder's compilation at https://shadertoy.com/view/tl23Rm\n// derived from https://shadertoy.com/view/ld23DV\nfloat iBox(vec3 ro, vec3 rd\n           //, vec2 distBound\n           , vec3 boxSize\n           , out vec3 normal, out vec2 uv) \n{\n    vec3 m = sign(rd)/max(abs(rd), 1e-8);\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max(max(t1.x, t1.y), t1.z);\n\tfloat tF = min(min(t2.x, t2.y), t2.z);\n\tfloat d = -1.;\n    normal = vec3(0,1,0); uv = vec2(.5);\n    if (tN <= tF && tF > 0.) {\n        //if (tN >= distBound.x && tN <= distBound.y) {\n        \tnormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n            d = tN;\n        //} else if (tF >= distBound.x && tF <= distBound.y) { \n        //\tnormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n        //    d = tF;\n        //}\n    }\n    return d;\n}\n\n// everything ray traced now, don't need sdf or discrete normal anymore\n// am keeping this stuff mainly for debugging atm, TODO probably remove before publicizing\n#if 0\nfloat d2seg(vec3 q, vec3 a, vec3 b)\n{\n    b -= a; q -= a; \n    q -= b * clamp(dot(q, b) / dot(b, b), 0., 1.);\n    return dot(q, q);\n}\n\nfloat distanceScene(vec3 p)\n{\n    #define CHECK(dl) if ((dl) < d) d = (dl)\n    float d = 3.4e38;\n    //CHECK(p.y * max(0., p.y)); // plane\n    //CHECK(d2seg(p, vec3(0), vec3(0,oradius*1.25,0)) - .0004); // pole\n    /* // no need to store pold.\n    for (int j = 0; j < nlinky; ++j)\n    for (int i = 0; i < nlinkx; ++i) {\n        vec3 pp = p - ps[pidx(i, j)];\n        CHECK(dot(pp, pp) - .0001);\n    } */\n    // FIXME algo FAR too slow to draw links with!\n    // I have no idea what I'll do about it yet!\n    // just splat big particles for now, very blobby cloth\n    /*\n    for (int j = 0; j < nlinky  ; ++j)\n    for (int i = 0; i < nlinkx-1; ++i) {\n        CHECK(d2seg(p, ps[pidx(i, j)], ps[pidx(i+1, j)]));\n    }\n    for (int j = 0; j < nlinky-1; ++j)\n    for (int i = 0; i < nlinkx  ; ++i) {\n        CHECK(d2seg(p, ps[pidx(i, j)], ps[pidx(i, j+1)]));\n    }\n\t*/\n    /*\n\tfor (int j = 0; j < nlinky-1; ++j)\n\tfor (int i = 0; i < nlinkx-1; ++i) {\n        CHECK(d2seg(p, ps[pidx(i, j)], ps[pidx(i+1, j+1)]));\n    } // diagonals\n\t*/\n    #undef CHECK\n    return sign(d) * sqrt(abs(d)) - .0001;\n}\n\n// from old Fly Camera https://shadertoy.com/view/tdsfR4\nvec3 normalScene(vec3 p, float h, out float d)\n{\n    vec3 n = vec3(\n          distanceScene(p + vec3(h,0,0))\n        , distanceScene(p + vec3(0,h,0))\n        , distanceScene(p + vec3(0,0,h))\n      ) - (d = distanceScene(p));\n    if (dot(n,n) < 1e-7) n = vec3(0,1,0);\n    else n = normalize(n);\n    return n;\n}\n#endif\n\nconst int\n  mSky  = 0\n, mLand = 1\n, mPole = 2\n, mFlag = 3\n;\n\nvec4 texcol(sampler2D ch, vec2 uv)\n{\n    vec4 t = texture(ch, uv);\n    return vec4(pow(t.rgb, vec3(2.2)), t.a);\n}\n\n// TODO antialias!\nvec3 FlagColor(vec2 uv)\n{\n//    uv.y = 1.-uv.y; // vertical flip\n    // TODO could be alpha for holes?\n//    return 1.-texcol(iChannel1, uv).grr; // some simple texture\n    vec4 nyan = texcol(iChannel3, (vec2(floor(mod(3.*iTime,6.)),0) + uv) * vec2(40./256.,1));\n    return mix(vec3(.5,1,0), nyan.rgb, nyan.a); // nyancat anim :3\n// TODO https://soundcloud.com/sengteck-phang/nyanyanyanyanyanyanya\n}\n\nvec3 albedo(int m, vec2 uv)\n{\n    vec3 c = vec3(.5);\n    switch(m) {\n        case mSky:  c = skyColor; break;\n        case mLand: c = texcol(iChannel1, uv / 2.).r * vec3(.5,.3,.1); break;\n        case mPole: c = texcol(iChannel2, uv / 8.).rgb; break;\n        case mFlag: c = FlagColor(uv); break;\n    }\n    return c;\n}\n\nvoid checkT(inout int id, inout float t, inout vec3 n, inout vec2 uv\n          , int idl, float tl, vec3 nl, vec2 uvl)\n{\n    if (tl > 0. && tl < t) id = idl, t = tl, n = nl, uv = uvl;\n}\n\nconst vec3 litepos = vec3(2,1.5,-1.5);\n\nfloat raytraceScene(vec3 ro, vec3 rd, float maxd, out int m, out vec3 n, out vec2 uv)\n{\n    int id; float t = 3.4e38, t0; n = vec3(0,1,0); vec3 n0; \n    vec2 uv0, uvnorm = 1.0 / vec2(nlinkx-1,nlinky-1);\n    // bounding sphere to cull the flag detail\n    if (iSphere(ro, rd, vec3(0, orbitheight*.95, 0) + globalwind * .6, flagLength * 1.25, n0, uv0) > 0.)\n\tif (iBox(ro - .5*(flagbblo+flagbbhi), rd, .5*(flagbbhi-flagbblo), n0, uv0) >= 0.)\n    for (int j = 0; j < nlinky-1; ++j)\n\tfor (int i = 0; i < nlinkx-1; ++i) {\n        t0 = iTri(ro, rd, ps[pidx(i+1, j)], ps[pidx(i+1, j+1)], ps[pidx(i, j)], n0, uv0);\n        uv0.x = 1.-uv0.x; uv0.y = 1.-uv0.y;\n        checkT(m, t, n, uv, mFlag, t0, n0, (uv0.yx + vec2(i,j)) * uvnorm);\n        t0 = iTri(ro, rd, ps[pidx(i, j+1)], ps[pidx(i, j)], ps[pidx(i+1, j+1)], n0, uv0);\n        checkT(m, t, n, uv, mFlag, t0, n0, (uv0.yx + vec2(i,j)) * uvnorm);\n    } // triangles\n    // TODO BVH or some other spatial acceleration structure\n  #if 1\n    if (m == mFlag) {\n\t    // if we hit any triangle so far, we'll have its normal and uv now\n\t    // now it a great time to compute the smooth surface normal\n\t    // so we don't have to do it more than once\n\t    vec2 uvpt = uv * vec2(nlinkx-1,nlinky-1); // address in terms of cloth particle grid index\n\t    n = vnormal(uvpt);\n        if (dot(n, rd) > 0.) n = -n; // always facing viewer\n    }\n  #endif\n    t0 = iPlane(ro, rd, vec3(0,1,0), 0., n0, uv0);\n    checkT(m, t, n, uv, mLand, t0, n0, uv0);\n    t0 = iCylinder(ro, rd, vec3(0), vec3(0,poleheight,0), .03, n0, uv0); // FIXME hard-coded oradius or hoist\n    checkT(m, t, n, uv, mPole, t0, n0, uv0);\n\tt0 = iCylinder(ro, rd, litepos*vec3(1,0,1), litepos, .02, n0, uv0); // FIXME hard-coded oradius or hoist\n    checkT(m, t, n, uv, mPole, t0, n0, uv0);\n\tif (t < 0. || t > maxd) t = maxd;\n    else n = normalize(n);\n    return t;\n}\n\n// monochrome light only does falloff for one channel,\n// but you can use it for all rgb channels\nfloat pointLight(vec3 surfpos, vec3 n, vec3 lp, float lumin)\n{\n    lp -= surfpos; float l2 = dot(lp, lp);\n    float d = dot(n, lp) / sqrt(l2); //l2;\n    float nl = max(d, 0.);\n    return nl * exp2(-l2); // * lumin\n}\n\nfloat pointGlare(vec3 ro, vec3 rd, vec3 lp, float lumin)\n{ // extreme HACK just so I can see the light sources directly\n    // TODO need a better falloff computation\n    lp -= ro;\n    float d = dot(rd, lp) / length(lp);\n    float c = max(d, 0.); //(d+1.)/2.;\n    //float g = acos(clamp(d, -1., 1.));\n    //float s = sqrt(max(0., 1. - c*c));\n    return 4.*pi* lumin * pow(c, 256.) / dot(lp,lp); //  4.*exp2(-2.*pi*g*g); // lumin\n}\n\nconst int nlights = 1;\nvec3[nlights] lightpos;\nvec3[nlights] lightcolor;\n\nvec3 hue(float h)\n{\n    return max(cos(vec3(0,2,4) + 2. * pi * h), 0.);\n}\n\nvoid InitLights()\n{ // a nearby \"street lamp\" or something\n    lightpos[0] = litepos;\n    lightcolor[0] = .6*vec3(1,.95,.9);\n}\n\nvec3 pointLightsShade(vec3 v, vec3 hp, vec3 n)\n{\n    vec3 lite = vec3(0);\n    for (int i = nlights; i-- > 0; )\n        lite += pointLight(hp, n, lightpos[i], length(lightcolor[i])) * lightcolor[i];\n    // no specular on point lights in this one :(\n\treturn lite;\n}\n\nvec3 pointLightsGlare(vec3 ro, vec3 rd, float t)\n{\n    vec3 lite = vec3(0);\n    for (int i = nlights; i-- > 0; ) // FIXME need lumi? HACK using length\n        lite += pointGlare(ro, rd, lightpos[i], length(lightcolor[i])) * lightcolor[i];\n    lite *= 1.-exp2(-.5*t); // HACK using total optical depth instead of depth thru the medium in range of the light\n    // probably should limit somehow\n    // anyway this whole thing is a big ol' hack atm, don't worry,\n    // I plan on replacing it with something better if I can find my old glare stuff\n    return lite;\n}\n\n/*\nfloat traceScene(vec3 ro, vec3 rd, float maxd, int nsteps)\n{\n    float t = 0.;\n    for (int i = nsteps + IZERO; i-- > 0; ) {\n        vec3 p = ro + rd * t;\n        float d = distanceScene(p);\n        if (abs(d) < .01) break;\n        t += d;\n    \tif (t > maxd) break;\n    }\n    return t;\n}\n*/\n\nvoid InitParticles()\n{\n\t// Because pold isn't reference here,\n\t// compiler should eliminate fetches of\n\t// unused second pixel of each particle.  I hope!\n    flagbblo = vec3(9e9); flagbbhi = vec3(-9e9);\n    for (int j = 0; j < nlinky; ++j)\n    for (int i = 0; i < nlinkx; ++i) {\n\t\tvec3 p = ps[pidx(i, j)] = particle(ClothBuf, ivec2(i, j)).pnew;\n        flagbblo = min(flagbblo, p); flagbbhi = max(flagbbhi, p);\n    }   \n}\n\nvec3 RenderScene(vec3 ro, vec3 rd)\n{\n    InitParticles();\n    InitLights();\n    // TODO antialiasing, probably simple SSAA.\n    // can't really afford it though!\n    const float maxd = 16.; //64.; //32.; //12.; \n    vec3 n; vec2 uv; int m;\n    float t1 = raytraceScene(ro, rd, maxd, m, n, uv)\n    //, t2 = traceScene(ro, rd, maxd, 64)\n    , t = t1 //min(t1, t2)\n    , d;\n    if (!(t >= 0.) || t > maxd) { t = maxd; n = rd; d = maxd; }\n\tvec3 h = ro + rd * t;\n    vec3 c = albedo(m, uv)\n    , glare = vec3(0);\n    float nl = dot(n, sunDir), onl = max(0., nl), nv = clamp(dot(rd, sunDir), 0., 1.);\n    if (nl > 0. && (m == mFlag || m == mPole)) { // fake specular from sun\n        vec3 h = normalize(sunDir-rd);\n        float nh = dot(n,h);\n        nh = max(nh, 0.);\n        float specpower = 64.;\n        c += pow(nh, specpower) * specpower * .038 * nl * .4 * mix(c, vec3(1), .5);\n    }\n    if (m == mFlag) {\n        // FIXME normal facing is wrong, already fixed in Old Glory\n        nl = nl * (nl < 0. ? -.2 : 1.); //abs(nl); //mix(nl, 1., .7); // double-sided lighting\n        nl += .5 * pow(max(dot(rd, sunDir), 0.), 4.); // fake back-lit SSS\n    }\n//    nl = mix(nl, 1., .02); // ambient wrap lighting hack\n    if (m == mSky) {\n    //    nl += 1. * pow(max(onl, 0.), 16.);\n    //    nl = mix(nl, 1., .1); // sky lighting hack\n    }\n    nl = max(0., nl);\n    nl = mix(nl, 1., ambient); // main ambient hack\n    if (m != mSky) {\n        c += pointLightsShade(-rd, h, n);\n    }\n    if (m == mSky || m == mLand) {\n        c += pow(max(0., 1.-abs(rd.y)), 8.) * (1.-exp2(-.055*t)); // fake horizon fog\n\t    // * (1.-exp2(-.6 * t))\n        vec3 gl = glowColor * (m == mLand ? .8 : 1.) * .25; // sun halo\n        glare += gl * 1.2 * pow(nv, 64.)\n               + gl *  .8 * pow(nv, 16.);\n    }\n    glare += pointLightsGlare(ro, rd, t);\n    return sunColor * nl * c + glare;\n}\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    c = vec4(0,0,0,1);\n    vec2 R = iResolution.xy\n    , M = iMouse.xy\n    , q = StoQ(   p, R)\n    , m = StoQ(M.xy, R);\n    if (length(M.xy) <= 1.)\n        m = vec2(.2 - .02*iTime,.15); // unattended, mouse in bottom left corner?\n    vec3 object_pos = vec3(0, orbitheight, 0) + globalwind * .4\n    , camera_dir = OrbitCamera(m)\n    , camera_pos = object_pos - orbit_scale * orbitheight * camera_dir; // LookAt\n    camera_pos.y = max(camera_pos.y, 1e-2); // do not go beneath ground\n    camera_dir = normalize(object_pos - camera_pos); // redo LookAt after clamp\n    mat3 cam = CameraMatrix(camera_dir);\n    float hfovy = pi/6., rnd = hash(p);\n    if (iMouse.z > 0.) hfovy *= .5; // zoom while mousing\n    vec3 vd = normalize(vec3(q, 1./sin(hfovy)))\n    , ro = camera_pos, rd = normalize(cam * vd); // view ray\n    c.rgb = RenderScene(ro, rd);\n//    c.rgb = texelFetch(BufferA, ivec2(p)/16, 0).rgb;// debug particles\n    c.rgb = pow(c.rgb, vec3(1./2.2)); // srgb gamut\n    // TODO blue noise would work better; could use BN texture instead of nyancat in iChannel3?\n    // but hey this gets the job done for now\n    c.rgb += vec3(.75/256. * (rnd * 2. - 1.)); // dither quantization bands\n}\n\n// TODO should try to integrate some techniques from these excellent cloth sim toys:\n// http://shadertoy.com/view/Ddj3Wh\n// http://shadertoy.com/view/MldXWX","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"#define IZERO min(0, iFrame)\n\nconst float\n  pi = acos(-1.) //3.141592\n, orbit_scale = 1.3\n, poleheight = 2.\n, drag = .13 // hack, really; should flow with wind if anything\n, hoist = .8 // height on pole of attachment\n, orbitheight = poleheight * hoist * .9\n, linksag = .005 // squishiness of link constraints\n, ropesag = .1\n, flutter = 100.\n, diagmul = .6\n, unfold = 8.\n, windvar = .1 //.0 //\n, windgust = .1 //.3 //.0 //\n, gravity = 9.8; // m/s/s\n\nconst vec3 globalwind = vec3(1.,.01,.01) * .2;\n\nconst int\n  nlinkx = 12 //15 //10 //\n, nlinky = 7  //9  //6  //\n;\n\nconst float\n  flagLength = poleheight / 3.\n, flagWidth = flagLength * float(nlinky) / float(nlinkx)\n, llen = flagLength / float(nlinkx-1);\n\n// to signed aspect correct uv given screen pixel and resolution\nvec2 StoQ(vec2 s, vec2 r)\n{\n\treturn (s + s - r) / r.y;\n}\n\n// build a 3x3 camera orientation matrix given forward direction vector, assuming up is +Y\nmat3 CameraMatrix(vec3 camFwd)\n{\n    vec3 w = normalize(camFwd)\n       , u = normalize(cross(vec3(0., 1., 0.), w))\n       , v = normalize(cross(w, u));\n    return mat3(u, v, w);\n}\n// then transform by pw = MC * pv;\n\nvec3 sph2cart(vec3 a) // spherical radians theta, psi, radius -> cartesian\n{\n    float cx = cos(a.x), sx = sin(a.x)\n        , cy = cos(a.y), sy = sin(a.y);\n    return vec3(sx*cy, sy, cx*cy) * a.z;\n}\n\nvec3 OrbitCamera(vec2 angles)\n{ // angles is yaw, pitch in radians\n    angles.x *= 2.; // kludge because Shadertoys clip mouse to window\n    angles.y = clamp(angles.y, -.4, .3);\n    return sph2cart(vec3(angles * pi, 1.));\n} // returns forward vector camera aims along\n\n// https://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner\nfloat hash(float x)\n{\n    return fract(sin(x*7.) * 43708.8672);\n}\n\nfloat hash(vec2 x) \n{ \n    return hash(dot(x, vec2(11.07,10.71)));\n}\n\nstruct Particle \n{\n    vec3 pnew, pold;\n};\n\nParticle particle(sampler2D bufA, ivec2 i)\n{\n    i.x += i.x;\n    vec4 d0 = texelFetch(bufA, i, 0)\n    , d1 = texelFetch(bufA, i + ivec2(1, 0), 0);\n    return Particle(d0.xyz, d1.xyz);\n}\n\nvec3 velocity(Particle p, float dt)\n{\n    return (p.pnew - p.pold) / dt;\n}\n\nvoid setVelocity(inout Particle p, vec3 v, float dt)\n{\n    p.pold = p.pnew - v * dt;\n}\n\n\n// verlet particle cloth\n\n// arrange links in 2d same as buffer \n// nlinkx * nlinky\n\n// verlet integration uses new & old particle positions \n// instead of position & velocity.\n// it's much simpler to work with \n// (except that one must compute velocity)\n\n// FIXME breaks at low framerates despite the implicit integration\n\n// FIXME changing nlinks makes flag go past top of pole etc.\n\n// for stiffer links must\n// copy entire buffer code to more buffers\n// to pipeline multiple passes of the constraints\n// to increase wavefront propagation speed\n// (speed of sound) in the cloth.\n// Otherwise it is limited to being fairly stretchy\n// or must animate slower than seems natural.\n// using all 4 now!\n\n// convert relative signed to zero-based for 3x3 array of neighbors\nint lidx(int i, int j)\n{\n    return 1 + 3 + i + j * 3;\n}\n\n/* // idk if I even want spring forces\n// compute p's spring forcereaction to other particle qid given spring rest length\nvoid react(inout Particle p, ivec2 qid, float rl)\n{\n    Particle q = particle(qid);\n    vec3 di = q.pnew - p.pnew  // relative pos\n        , w = q.pold - p.pold; // relative vel\n    float l = length(di), dt = iTimeDelta; //1.; //\n//\tp.pnew += stiffness * (l - rl) / l * di;\n    vec3 e = di / max(l, 1e-3); // unit length more or less direction to other\n    vec3 f = stiffness * (l - rl) * e; // simple undamped spring force\n    float j = .3*stiffness; // ok, don't use too much relative stiffness!\n    // seems this is doing impulses, actually\n    f -= j * dot(w, e) * e; // damping force (euler integration's unstable without it)\n    p.pold -= f * dt;\n}\n*/\n// maybe should take v instead of po, easier to work with; then just multiply by dt before computing pold\nvoid CheckLink(inout vec3 p, inout vec3 po, int i, int j, float dt, vec3 wind, sampler2D ch)\n{\n    float squish = exp2(-linksag*dt)\n        , squish2 = exp2(-ropesag*dt); // how squishy are constraints?\n    #define CHECK(q, i_, j_, f_) { \\\n\t\tfloat d = distance(p, q) \\\n    \t, l = llen * length(vec2(i_,j_)); \\\n        p += (q - p) * (d - l) * (f_); \\\n    }\n\t// FIXME aha, this is probably part of the problem:\n\t// should be adjusting the velocity (old position)\n\t// NOT the new position!\n    #define SPRING(q, i_, j_, f_) { \\\n\t\tfloat d = distance(p, q) \\\n    \t, l = llen * length(vec2(i_,j_)); \\\n        po -= (q - p) * (d - l) * (f_) * dt; \\\n        /*p += (q - p) * (d - l) * (f_) * dt;*/ \\\n    }\n    // only really need to check the immediate neighbors\n\tParticle[9] ps;\n    for (int j0 = 1; j0 >= -1; --j0)\n    for (int i0 = 1; i0 >= -1; --i0)\n        ps[lidx(i0,j0)] = particle(ch, ivec2(i+i0, j+j0));\n    // TODO refactor vnormal to Common from Image\n    // compute local normal here, since we have the neighbors loaded and need it for wind application\n    vec3 n = normalize(cross(ps[lidx(i == nlinkx-1 ? 0 : 1,0)].pnew - ps[lidx(i == 0 ? 0 : -1,0)].pnew\n                           , ps[lidx(0,j == nlinky-1 ? 0 : 1)].pnew - ps[lidx(0,j == 0 ? 0 : -1)].pnew));\n    // do wind forces\n\t//wind -= velocity(ps[lidx(0,0)], dt); // now relative to vertex motion\n    //p += n * dot(n, wind) * dt;\n\tpo -= n * dot(n, wind) * dt * dt * flutter; // should * dt again for a true force; this is an impulse?\n    #if 1\n    // some weak self-unfolding \n    // spring forces to neighbors of neighbors\n    // to make up for lack of self-collision\n    // cannot use ps until I have the lidx and lut extended to support 5x5 samples or something\n    if (i > 1)\n    \tSPRING(particle(ch, ivec2(i-2, j+0)).pnew,-2, 0, unfold*squish)    \n    if (j > 1)\n    \tSPRING(particle(ch, ivec2(i+0, j-2)).pnew, 0,-2, unfold*squish)\n    if (i < nlinkx-2)\n    \tSPRING(particle(ch, ivec2(i+2, j+0)).pnew, 2, 0, unfold*squish)    \n\tif (j < nlinky-2)\n    \tSPRING(particle(ch, ivec2(i+0, j+2)).pnew, 0, 2, unfold*squish)\n    #endif\n    #if 1\n    // soft diagonal springs\n    if (i > 0 && j > 0)\n    \tSPRING(ps[lidx(-1,-1)].pnew,-1,-1, diagmul*squish)\t\n    if (i < nlinkx-1 && j < nlinky-1)\n    \tSPRING(ps[lidx( 1, 1)].pnew, 1, 1, diagmul*squish)\t\n    #endif\n    if (i > 0)\n    \tCHECK(ps[lidx(-1, 0)].pnew,-1, 0, 1.*squish)    \n    if (j > 0)\n    \tCHECK(ps[lidx( 0,-1)].pnew, 0,-1, 1.*squish)\n    if (i < nlinkx-1)\n    \tCHECK(ps[lidx( 1, 0)].pnew, 1, 0, 1.*squish)    \n\tif (j < nlinky-1)\n    \tCHECK(ps[lidx( 0, 1)].pnew, 0, 1, 1.*squish)\t\n    #if 0\n    // soft diagonal links, allow cloth to bend but not too much\n    if (i > 0 && j > 0)\n    \tCHECK(ps[lidx(-1,-1)].pnew,-1,-1, diagmul*squish)\t\n    if (i < nlinkx-1 && j < nlinky-1)\n    \tCHECK(ps[lidx( 1, 1)].pnew, 1, 1, diagmul*squish)\t\n    #endif\n    if (i == 0 && (j == 0 || j == nlinky-1)) // attach to pole\n    \tCHECK(vec3(llen*.25, llen * float(j) + poleheight * hoist,0), 0, 0, 1.*squish2)\n    #undef CHECK\n}\n\nvoid DoPhysics(inout Particle part, ivec2 i, float dt, vec3 wind, sampler2D ch)\n{    \n\tvec3 pn = part.pnew, po = pn; // original new pos -> new old pos\n\tvec3 v = velocity(part, dt);\n\tv *= exp2(-drag * dt); // drag forces\n\t//v.y -= gravity * .5 * dt; // 'gravity'\n\tpo.y += gravity * dt * dt;\n\tpn += v * dt;\n    for (int j = 2; j-- > 0; ) // multiple iterations helps a bit probably? idk anymore w 4 buffers\n\t\tCheckLink(pn, po, i.x, i.y, dt, wind, ch); // constraint links\n\tpart.pnew = pn;\n\tpart.pold = po;\n}\n\nvoid DoPhysicsInit(inout Particle part, ivec2 i, float dt, float time, int frame, sampler2D ch)\n{\n    if (frame == 0) {\n        // by setting old and new to same position,\n        // velocity is initialized to zero.\n\t\tpart.pold = part.pnew =\n            vec3(vec2(i)*llen + vec2(llen*1.2, poleheight * hoist), 0);\n    } else {\n\t    vec3 wind = globalwind;\n\t \twind += windvar * vec3(1,.01,.02) * sin(vec3(3,5,2)/6.*time);\n\t\twind *= mix(1., sin(time*.4), windgust); // overall strength waxes and wanes with time, in gusts\n    \tDoPhysics(part, i, dt, wind, ch);\n    }\n}\n\n// per-particle data does not fit in one vec4 pixel\nvec4 Store(Particle p, int pixelsection)\n{\n    vec4 o;\n    switch (pixelsection) {\n      case 0:\n\t\to = vec4(p.pnew, 0);\n        break;\n      case 1:\n\t\to = vec4(p.pold, 0);\n        break;\n      default:\n        o = vec4(0);\n        break;\n    }\n    return o;\n}\n\n// FIXME I get the feeling my cloth sim is just\n// not as good as the one I had way back when.\n// It doesn't flutter as well as I recall;\n// I remember having it tuned way more billowy.\n// Maybe the physics was just ticking really slowly\n// to keep it from blowing up?\nvoid computeBuffer(out vec4 o, vec2 p, float timeDelta, float time, int frame, sampler2D ch)\n{\n    ivec2 i = ivec2(p);\n    int psection = i.x & 1;\n    i.x >>= 1;\n    if (i.x >= nlinkx || i.y >= nlinky) discard;\n    float dt = clamp(timeDelta, 1./640., 1./480.);\n    Particle part = particle(ch, i);\n    DoPhysicsInit(part, i, dt, time, frame, ch);\n    o = Store(part, psection);\n}\n\n// macro shim for verlet physics buffers\n#define mainBuffer(nbuf) \\\nvoid mainImage(out vec4 o, vec2 p) { \\\n    computeBuffer(o, p, iTimeDelta/float(nbuf), iTime, iFrame, iChannel0); \\\n}\n\n","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"XdfGR8","filepath":"/media/previz/buffer03.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// see Common tab\nmainBuffer(4)\n\n","name":"Buffer A","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XsXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// see Common tab\nmainBuffer(4)\n\n","name":"Buffer B","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"4sXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// see Common tab\nmainBuffer(4)\n\n","name":"Buffer C","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XdfGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// see Common tab\nmainBuffer(4)\n\n","name":"Buffer D","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"ttlcD7","date":"1593879626","viewed":165,"name":"Cloth Flag","username":"spalmer","description":"simple verlet particle cloth physics demo of flag flapping in the wind, recreating a demo I made a long long time ago, since I lost that source code way back when.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["flag","physics","verlet","cloth"],"hasliked":0,"parentid":"","parentname":""}}