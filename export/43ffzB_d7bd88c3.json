{"ver":"0.1","info":{"id":"43ffzB","date":"1728513605","viewed":33,"name":"Colored Cubes 2","username":"MSchaefer","description":"This is a raymarching shader, that was created while watching this tutorial from the user kishimisu (https://www.youtube.com/watch?v=khblXafu7iA). I used code from the users kishimisu and iq on this plattform for this shader.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","hsv"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The idea of this shader is not new, i created and modified it while learning raymarching.\n// The shader is inspired by the two users iq (https://www.shadertoy.com/user/iq) \n// and kishimisu (https://www.shadertoy.com/user/kishimisu).\n// -----------------------------------------------------------\n// The Internet-Sources are:\n// https://iquilezles.org/articles/distfunctions/\n// https://www.youtube.com/watch?v=khblXafu7iA\n// -----------------------------------------------------------\n// ps: you can use the mouse to rotate the camera\n// -----------------------------------------------------------\n\n// Here is something to play with:\n\n// Set background rotation\nconst bool rotateBackground = true;\n// Set cube scaling:\nfloat cubeScaling = 7.0;\n// Set the iteration count for the raymarching here:\nint iterations = 160;\n//--------------------------------------------------\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(k-abs(a-b), 0.0) / k;\n    return min(a, b) - h*h*h*k*(1.0/6.0);\n}\n\nmat2 rot2D(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat map(vec3 p, vec3 ro) {\n    float dx = 0.;\n    float dz = (iTime) * 5.4;\n\n    p.x += dx;\n    p.z += dz;\n   \n    vec3 spherePos1 = vec3(ro.x + dx, ro.y + sin(iTime) * 2., ro.z + dz + 5.);\n    float sphere1 = sdSphere(p - spherePos1, 1.);\n    \n    vec3 spherePos2 = vec3(ro.x + dx, ro.y + sin(iTime) * 2., ro.z + dz - 5.);\n    float sphere2 = sdSphere(p - spherePos2, 1.);\n    \n    vec3 q = p; // copy\n    \n    q.x -= sin(iTime + q.y + q.z) * 0.4;\n    q = fract(q) - .5;\n    q.xy *= rot2D(iTime);\n    q.yz *= rot2D(sin(iTime + q.y + q.z) * 0.4);\n    \n    float box = sdBox(q * cubeScaling, vec3(.75)) / cubeScaling;\n    float spheres = smin(sphere1, sphere2, 2.0);\n    return smin(spheres, box, 2.);\n}\n\n// hsv2rgb_smooth from user iq, found on https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb_smooth(in vec3 c) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    vec2 m = vec2(cos(iTime*.2), sin(iTime*.2));\n    \n    vec3 rayOrigin = vec3(0, 0, -5);\n    vec3 rayDirection = normalize(vec3(uv, 1. + 0.5 * (sin(iTime)+1.)*0.25));\n    vec3 col = vec3(0);\n    \n    float t = 0.;\n    \n    if (rotateBackground) {\n        rayOrigin.xz *= rot2D(-m.x);\n        rayDirection.xz *= rot2D(-m.x);\n    }\n    \n    for (int i = 0; i < iterations; i++) {\n        vec3 p = rayOrigin + rayDirection * t;\n        \n        p.xy *= rot2D(t*.2 * m.x);\n        p.y += sin(t*(m.y+1.)*.5)*.35;\n        \n        float dist = map(p, rayOrigin + rayDirection);\n        t += dist; \n        col += vec3(i) / (float(iterations) * 10.);\n        if (dist < .001 || t > 200.) break;\n    }\n    \n    float negator = 1.;\n    \n    \n    vec3 colors = hsv2rgb_smooth(rayDirection);\n    fragColor = \n        vec4(t * negator * colors.x * 0.25 - negator, \n             ((col.y - 0.5) + rayDirection.z * 0.5) * colors.y, \n             ((col.z - 0.5) + rayDirection.x * 0.45) * colors.z, \n             0);\n}\n","name":"Image","description":"","type":"image"}]}