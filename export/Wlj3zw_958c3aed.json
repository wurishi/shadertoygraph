{"ver":"0.1","info":{"id":"Wlj3zw","date":"1558910126","viewed":1716,"name":"depth of field example","username":"edapx","description":"depth of field test example. Simplification of https://www.shadertoy.com/view/MlK3R3","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["dof","depthoffield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// this test is a simplification of https://www.shadertoy.com/view/MlK3R3\n\nconst int MAX_MARCHING_STEPS = 164;\nconst float EPSILON = 0.0015;\nconst float NEAR_CLIP = 0.0;\nconst float FAR_CLIP = 80.00;\nconst vec3 lightDirection = vec3(0.702, 1.9686, 0.6745);\n\nvec2 squareFrame(vec2 res, vec2 coord){\n    return ( 2. * coord.xy - res.xy ) / res.y;\n}\n\nfloat sphere(vec3 pos, float radius){\n    return length(pos) - radius;\n}\n\nfloat map(vec3 pos){\n    vec3 pos0 = pos + vec3(1.9,-1.1,-3.8);\n    vec3 pos1 = pos + vec3(-1.9, 0.0, 3.8);\n\n    float s = sphere(pos0, 2.15);\n    float s1 = sphere(pos, 1.35);\n    float s2 = sphere(pos1, 1.95);\n    \n    return min(s,min(s1,s2));\n}\n    \nfloat raymarching(vec3 eye, vec3 marchingDirection){\n    float depth = NEAR_CLIP;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = map(eye + depth * marchingDirection);\n        if (dist < EPSILON){\n            return depth;\n        }\n\n        depth += dist;\n\n        if (depth >= FAR_CLIP) {\n            return FAR_CLIP;\n        }\n    }\n    return FAR_CLIP;\n}\n\nvec3 computeNormal(vec3 pos){\n    vec2 eps = vec2(0.01, 0.);\n    return normalize(vec3(\n        map(pos + eps.xyy) - map(pos - eps.xyy),\n        map(pos + eps.yxy) - map(pos - eps.yxy),\n        map(pos + eps.yyx) - map(pos - eps.yyx)\n    ));\n}\n\nfloat clampeddot(vec3 a, vec3 b){\n    return max(0.,dot(a, b));\n}\n\nfloat diffuse(vec3 normal){\n    float ambient = 0.2;\n    return clampeddot(normal, lightDirection) * ambient + ambient;\n}\n\nfloat specular(vec3 normal, vec3 dir){\n    vec3 h = normalize(normal - dir);\n    float specularityCoef = 40.;\n    return clamp( pow(clampeddot(h, normal), specularityCoef), 0.0, 1.0);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ){\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = cross(cu,cw);\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec3 red = vec3(1.0, 0.353, 0.208);\n    vec3 blu = vec3(0.086, 0.19, 0.8);\n    vec2 st = squareFrame(iResolution.xy, fragCoord);\n\n    // this is the accumulated color\n    vec3 color = vec3(0.0,0.0,0.0);\n\n    // Depth of field variables\n    float lensResolution = 3.0;\n    float focalLenght = 20.0;\n    float lensAperture = 0.6;\n    float shiftIteration = 0.0;\n    float inc = 1.0/lensResolution;\n    float start = inc/2.0-0.5;\n\n    // camera setup\n    float camSpeed = 0.3;\n    vec3 eye = 10.0*vec3(\n        sin(4.0*iTime * camSpeed),\n        cos(3.0*iTime * camSpeed),\n        cos(4.0*iTime * camSpeed)); \n    vec3 tangent = vec3(0.3, 1.0, -1.0);  \n    mat3 camera = setCamera( eye, tangent, 0.0 );\n    float fov = 3.4;\n    vec3 dir = camera * normalize(vec3(st, fov));\n    \n    // calculate the focal point\n    vec3 focalPoint = eye + (dir * focalLenght);\n\n    // loop that:\n    // 1) shifts the ray origin \n    // 2) uses that origin to get a secondary ray that points toward the focal point\n    // 3) raymarch using these 2 variables\n    // 4) accumulate the result in the vec3 color\n    for (float stepX = start; stepX < 0.5; stepX+=inc){\n        for (float stepY = start; stepY < 0.5; stepY+=inc){\n            vec2 shiftedOrigin = vec2(stepX, stepY) * lensAperture;\n            // create a secondary ray that has as origin the shifted origin\n            // and as direction focalPoint - shifted origin\n            if (length(shiftedOrigin)<(lensAperture/2.0)){\n                vec3 shiftedRayOrigin = eye;\n                shiftedRayOrigin.x += shiftedOrigin.x;\n                shiftedRayOrigin.y += shiftedOrigin.y;\n                vec3 shiftedRay = normalize(focalPoint - shiftedRayOrigin);\n\n                float shortestDistanceToScene = raymarching(shiftedRayOrigin, shiftedRay);\n\n                if (shortestDistanceToScene < FAR_CLIP - EPSILON) {\n                    vec3 collision = (shiftedRayOrigin += (shortestDistanceToScene*0.995) * shiftedRay );\n\n                    vec3 normal = computeNormal(collision);\n                    float diffLight = diffuse(normal);\n                    float specLight = specular(normal, shiftedRay);\n                    color += (diffLight + specLight ) * red;\n                } else {\n                    color += blu;\n                }\n                shiftIteration ++;\n            }\n        }\n    }\n\tvec3 c = sqrt(clamp(color/shiftIteration, 0., 1.));\n    fragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}]}