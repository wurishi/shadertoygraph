{"ver":"0.1","info":{"id":"Mltfzn","date":"1538498799","viewed":303,"name":"square_flip","username":"sporadiclizard","description":"this is the code for a gif I made. It uses mobius transformations to deform the plane. I tried to explain the square switching in the code itself, hopefully it's somewhat understandable.","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["grid","mobius","loop","sporadiclizard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2*pi\n#define TAU 6.283185307179\n\nvec2 cxmul(vec2 z, vec2 w) {\n    return mat2(z, -z.y, z.x) * w; //vec2(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\nvec2 cxdiv(vec2 z, vec2 w) {\n    return cxmul(z, vec2(w.x, -w.y)) / dot(w,w);\n}\n\nvec2 mobius(vec2 z, vec2 a, vec2 b, vec2 c, vec2 d) {\n    return cxdiv(cxmul(a,z) + b, cxmul(c,z) + d); \n}\n\n// mobius transformation described with which complex numbers \n// it sends zero, one and infinity to.\n// 0 -> q, 1 -> r, inf -> s\nvec2 mobi3(vec2 z, vec2 q, vec2 r, vec2 s) {\n    return cxdiv(cxmul(z - q, r - s), cxmul(z - s, r - q));\n}\n\nvec2 rotate(vec2 v, float a) {\n  float s = sin(a);\n  float c = cos(a);\n  mat2 m = mat2(c, -s, s, c);\n  return m * v;\n}\n\nconst float scale = 1.5;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tfloat time = iTime*0.25;\n    \n    // centered around origin, [-1, 1];\n    vec2 pos = ( 2. * fragCoord - iResolution.xy ) / iResolution.y; \n    \n    vec2 zero = vec2( .15, 0.);\n    vec2 one =  vec2( -.15, 0.);\n    vec2 inf =  vec2( 0., 1.5);\n\n    // mobius transformed position - deforms the plane \n    vec2 posi = mobi3(pos, zero, one, inf);\n  \t\n    // switch for the two phases of the animation\n    // 0 for 0 < (iTime % 2) < 1\n    // 1 for 1 < (iTime % 2) < 2 \n    float sw = mod(floor(2.*time),2.);\n\n    // make a grid with the inverted position\n    // the switch moves the grid for when the visual \"switch\" happens\n    vec2 gposi = -1. + 2. * fract((scale*posi + sw*0.5 - time));\n    \n    // eased time for smooth rotation anim \n    float eased = 0.5*(1.-cos(mod(time,0.5)*TAU));\n    // switch direction for the two phases of the animation\n    eased *= mix(1., -1., sw);\n    gposi = rotate(gposi, eased*TAU/4.);\n    \n    // distance function for a 45 degree rotated square, or a diamond\n    float diamond = smoothstep(0., 1., (abs(gposi.x)+abs(gposi.y))*0.5);\n    \n    // this flips the colors of the diamond for the different phases of the anim\n    // together with the grid movement, this produced the visual \"switch\"\n    // from black squares on white bg to white squares on black bg\n    float switchedDiamond = 2. * mix(1.-diamond, diamond, sw);\n    \n    // use the distance func to make squares \n    // float colVal = pow(switchedDiamond, 20.);\n\n    // antialiased version by FabriceNeyret2 - Thank you!\n    // it blurs the edges more where the squares are smaller  \n    float b = 40. / ( iResolution.y * length(pos-vec2(0.,1.)) ); \n    float colVal = smoothstep(-b,b,switchedDiamond-1.);\n\n    // Output to screen\n    fragColor = vec4(vec3(colVal),1.0);\n}","name":"Image","description":"","type":"image"}]}