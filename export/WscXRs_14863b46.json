{"ver":"0.1","info":{"id":"WscXRs","date":"1572568817","viewed":211,"name":"[TWITCH] ShaderTober - Coat","username":"Flopine","description":"A small doodle with inktober's theme \"Coat\".\nI've made it on a Twitch live session that you can watch here > https://www.twitch.tv/flopine","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","scales","twitch","inktober"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define wr vec2(1.,0.8)\n#define time iTime\n#define PI 3.141592\n\nmat2 rot(float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvoid moda (inout vec2 p, float rep)\n{\n    float per = (2.*PI)/rep;\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a,per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;\n}\n\nfloat wool (vec2 uv)\n{\n    uv.x = abs(uv.x);\n    float c = 0.5-abs(uv.x-uv.y);\n    return c;\n}\n\nvec4 wool_grid (vec2 uv)\n{\n    uv *= 10.;\n    vec2 ga = mod(uv,wr)-wr*0.5;\n    vec2 gb = mod(uv-wr*0.5,wr)-wr*0.5;\n\n    vec2 guv = (dot(ga,ga) < dot(gb,gb)) ? ga : gb;\n    guv.y = wool(guv);\n    vec2 id = uv-guv;\n    return vec4(guv,id);\n}\n\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\nfloat SDF (vec3 p)\n{ \n    p.z += wool_grid(p.xy*0.8).y*0.1;\n\n    p.xz *= rot(p.y*0.5);\n    moda(p.xz, 7.);\n    p.x -= .8 + sin(p.y*2.+time)*0.5;\n\n    p.xz *= rot(p.y+time);\n    moda(p.xz, 5.);\n    p.x -= 0.12+cos(p.y*5.-time)*0.15;\n    \n    return cyl(p.xzy, 0.1,5.);\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(vec3( SDF(p+eps.xyy)-SDF(p-eps.xyy),\n                         SDF(p+eps.yxy)-SDF(p-eps.yxy),\n                         SDF(p+eps.yyx)-SDF(p-eps.yyx)\n                         )\n                    );\n}\n\nfloat fre (vec3 n, vec3 rd)\n{return pow(clamp(1.-dot(n, -rd),0.,1.),1.5);}\n\nfloat spe (vec3 l, vec3 n, vec3 rd)\n{\n    vec3 h = normalize(-rd);\n    return pow(max(dot(n,h),0.),10.);\n}\n\nvec3 palette (float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{return a+b*cos(2.*PI*(c*t+d));}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\tuv *= 0.5;\n    \n    vec3 ro = vec3(0.001,0.001,-3.),\n        p = ro,\n        rd = normalize(vec3(uv,1.)),\n        col = vec3(0.);\n\n    bool hit = false;\n\tfloat dmax = 10.;\n    \n    for (float i=0.; i<64.; i++)\n    {\n        float d = SDF(p);\n        if (d < 0.001)\n        {\n            hit = true;\n            break;\n        }\n        p += d*rd*0.5;\n    }\n\n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        col = palette (fre(n,rd),\n                       vec3(0.5),\n                       vec3(0.5),\n                       vec3(.5),\n                       vec3(0.1,0.37,0.43));      \n        col += spe(ro,n,rd) * vec3(0.,0.5,0.);\n    }\n\t\n    col *= smoothstep(0.1,0.4,wool_grid(uv).y)*1.-(abs(sin(length(uv*wool_grid(uv).zw)-time))-0.1);\n    \n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}