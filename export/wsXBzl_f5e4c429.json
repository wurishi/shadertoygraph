{"ver":"0.1","info":{"id":"wsXBzl","date":"1588852674","viewed":254,"name":"PerlinNosie","username":"Yann1210","description":"Sample Perlin Nosie","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["study"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Perlin噪声、Simplex噪声和Value噪声在性能上大致满足：Perlin噪声 > Value噪声 > Simplex噪声，\n//Simplex噪声性能最好。Perlin噪声和Value噪声的复杂度是O(2n)O(2n)，其中n是维数，\n//但Perlin噪声比Value噪声需要进行更多的乘法（点乘）操作。而Simplex噪声的复杂度为O(n2)O(n2)\n//https://blog.csdn.net/candycat1992/article/details/50346469\n\n//计算顶点梯度向量\nvec2 hash22(vec2 p)\n{\n    p = vec2( dot(p,vec2(127.1,311.7)),\n              dot(p,vec2(269.5,183.3)));\n\n    return -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n}\n\nvec3 hash33( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\treturn fract(sin(p)*43758.5453123);\n}\n\nfloat hash21(vec2 p)\n{\n    // Two typical hashes...\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n    \n    // This one is better, but it still stretches out quite quickly...\n    // But it's really quite bad on my Mac(!)\n    //return fract(sin(dot(p, vec2(1.0,113.0)))*43758.5453123);\n\n}\n\n\n//简单perlin noise\nfloat noise(vec2 p)\n{\n    vec2 pi = floor(p);//向下取整得到晶格结构的左下点，方便得到输入点对应的晶体结构\n    vec2 pf = p - pi;\n\n    vec2 w = pf * pf * (3.0 - 2.0 * pf); //s(t)=3t2−2t3\n    \n    //vec2 w = pf * pf * pf* (6.0 * pf * pf -15.0 * pf + 10.0); //s(t)=6t5−15t4+10t3\n\t\n    //使用缓和曲线（ease curves）来计算它们的权重和\n   // return mix(mix(dot(hash22(pi + vec2(0.0, 0.0)), pf - vec2(0.0, 0.0)), \n   //                dot(hash22(pi + vec2(1.0, 0.0)), pf - vec2(1.0, 0.0)), w.x), \n    //           mix(dot(hash22(pi + vec2(0.0, 1.0)), pf - vec2(0.0, 1.0)), \n   //                dot(hash22(pi + vec2(1.0, 1.0)), pf - vec2(1.0, 1.0)), w.x),\n  //             w.y);\n    \n    \n    //计算该点到各个晶格顶点的距离向量，再分别与顶点上的梯度向量做点乘\n    float dis1 = dot(hash22(pi + vec2(0.0, 0.0)), pf - vec2(0.0, 0.0));\n    float dis2 = dot(hash22(pi + vec2(1.0, 0.0)), pf - vec2(1.0, 0.0));\n    float dis3 = dot(hash22(pi + vec2(0.0, 1.0)), pf - vec2(0.0, 1.0));\n    float dis4 = dot(hash22(pi + vec2(1.0, 1.0)), pf - vec2(1.0, 1.0));\n    \n    float m1 = mix(dis1, dis2, w.x);\n    float m2 = mix(dis3, dis4, w.x);        \n    \n    return mix(m1,m2,w.y);\n                  \n}\n\n\n//简单value noise\nfloat value_noise(vec2 p)\n{\n    vec2 pi = floor(p);\n    vec2 pf = p - pi;\n\n    //vec2 w = pf * pf * (3.0 - 2.0 * pf);\n    vec2 w = pf * pf * pf* (6.0 * pf * pf -15.0 * pf + 10.0); //s(t)=6t5−15t4+10t3\n\n    \n    float m1 = mix(hash21(pi + vec2(0.0, 0.0)), hash21(pi + vec2(1.0, 0.0)), w.x);\n    float m2 = mix(hash21(pi + vec2(0.0, 1.0)), hash21(pi + vec2(1.0, 1.0)), w.x);\n    \n   // return mix(mix(hash22(pi + vec2(0.0, 0.0)), hash22(pi + vec2(1.0, 0.0)), w.x),\n     //          mix(hash22(pi + vec2(0.0, 1.0)), hash22(pi + vec2(1.0, 1.0)), w.x),\n       //        w.y);\n        \n       return mix(m1,m2,w.y);\n}\n\n//simplex noise\nfloat simplex_noise(vec2 p)\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n    vec2 i = floor(p + (p.x + p.y) * K1);\n\n    vec2 a = p - (i - (i.x + i.y) * K2);\n    vec2 o = (a.x < a.y) ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0 * K2;\n\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n    vec3 n = h * h * h * h * vec3(dot(a, hash22(i)), dot(b, hash22(i + o)), dot(c, hash22(i + 1.0)));\n\n    return dot(vec3(70.0, 70.0, 70.0), n);\n}\n\n\n//分形布朗运动  noise(p)+1/2noise(2p)+1/4noise(4p)+...\nfloat perlin_noise_sum(vec2 p)\n{\n    float f = 0.0;\n    //叠加了5层，并把初始化采样距离设置为4\n    p = p * 2.0;\n    f += 1.0000 * noise(p); p = 2.0 * p;\n    f += 0.5000 * noise(p); p = 2.0 * p;\n    f += 0.2500 * noise(p); p = 2.0 * p;\n    f += 0.1250 * noise(p); p = 2.0 * p;\n    f += 0.0625 * noise(p); p = 2.0 * p;\n\n   return f;\n}\n\n//分形布朗运动  noise(p)+1/2noise(2p)+1/4noise(4p)+...\nfloat perlin_noise_sum_abs(vec2 p)\n{\n    float f = 0.0;\n    p = p * 2.0;\n    f += 1.0000 * abs(noise(p)); p = 2.0 * p;\n    f += 0.5000 * abs(noise(p)); p = 2.0 * p;\n    f += 0.2500 * abs(noise(p)); p = 2.0 * p;\n    f += 0.1250 * abs(noise(p)); p = 2.0 * p;\n    f += 0.0625 * abs(noise(p)); p = 2.0 * p;\n\n    return f;\n}\n\n\n//分形布朗运动  sin(x+|noise(p)|+12|noise(2p)|+14|noise(4p)|+...)\nfloat perlin_noise_sum_abs_sin(vec2 p)\n{\n    float f = 0.0;\n    p = p * 7.0;\n    f += 1.0000 * abs(noise(p)); p = 2.0 * p;\n    f += 0.5000 * abs(noise(p)); p = 2.0 * p;\n    f += 0.2500 * abs(noise(p)); p = 2.0 * p;\n    f += 0.1250 * abs(noise(p)); p = 2.0 * p;\n    f += 0.0625 * abs(noise(p)); p = 2.0 * p;\n    f = sin(f + p.x/32.0);\n    return f;\n}\n\n//==============================================================================\n//分形布朗运动  noise(p)+1/2noise(2p)+1/4noise(4p)+...\nfloat value_noise_sum(vec2 p)\n{\n    float f = 0.0;\n    //叠加了5层，并把初始化采样距离设置为4\n    p = p * 2.0;\n    f += 1.0000 * value_noise(p); p = 2.0 * p;\n    f += 0.5000 * value_noise(p); p = 2.0 * p;\n    f += 0.2500 * value_noise(p); p = 2.0 * p;\n    f += 0.1250 * value_noise(p); p = 2.0 * p;\n    f += 0.0625 * value_noise(p); p = 2.0 * p;\n\n   return f;\n}\n\n//分形布朗运动  noise(p)+1/2noise(2p)+1/4noise(4p)+...\nfloat value_noise_sum_abs(vec2 p)\n{\n    float f = 0.0;\n    p = p * 2.0;\n    f += 1.0000 * abs(value_noise(p)); p = 2.0 * p;\n    f += 0.5000 * abs(value_noise(p)); p = 2.0 * p;\n    f += 0.2500 * abs(value_noise(p)); p = 2.0 * p;\n    f += 0.1250 * abs(value_noise(p)); p = 2.0 * p;\n    f += 0.0625 * abs(value_noise(p)); p = 2.0 * p;\n\n    return f;\n}\n\n\n//分形布朗运动  sin(x+|noise(p)|+12|noise(2p)|+14|noise(4p)|+...)\nfloat value_noise_sum_abs_sin(vec2 p)\n{\n    float f = 0.0;\n    p = p * 7.0;\n    f += 1.0000 * abs(value_noise(p)); p = 2.0 * p;\n    f += 0.5000 * abs(value_noise(p)); p = 2.0 * p;\n    f += 0.2500 * abs(value_noise(p)); p = 2.0 * p;\n    f += 0.1250 * abs(value_noise(p)); p = 2.0 * p;\n    f += 0.0625 * abs(value_noise(p)); p = 2.0 * p;\n    f = sin(f + p.x/32.0);\n    return f;\n}\n\n\n//==============================================================================\n//分形布朗运动  noise(p)+1/2noise(2p)+1/4noise(4p)+...\nfloat simplex_noise_sum(vec2 p)\n{\n    float f = 0.0;\n    //叠加了5层，并把初始化采样距离设置为4\n    p = p * 2.0;\n    f += 1.0000 * simplex_noise(p); p = 2.0 * p;\n    f += 0.5000 * simplex_noise(p); p = 2.0 * p;\n    f += 0.2500 * simplex_noise(p); p = 2.0 * p;\n    f += 0.1250 * simplex_noise(p); p = 2.0 * p;\n    f += 0.0625 * simplex_noise(p); p = 2.0 * p;\n\n   return f;\n}\n\n//分形布朗运动  noise(p)+1/2noise(2p)+1/4noise(4p)+...\nfloat simplex_noise_sum_abs(vec2 p)\n{\n    float f = 0.0;\n    p = p * 2.0;\n    f += 1.0000 * abs(simplex_noise(p)); p = 2.0 * p;\n    f += 0.5000 * abs(simplex_noise(p)); p = 2.0 * p;\n    f += 0.2500 * abs(simplex_noise(p)); p = 2.0 * p;\n    f += 0.1250 * abs(simplex_noise(p)); p = 2.0 * p;\n    f += 0.0625 * abs(simplex_noise(p)); p = 2.0 * p;\n\n    return f;\n}\n\n\n//分形布朗运动  sin(x+|noise(p)|+12|noise(2p)|+14|noise(4p)|+...)\nfloat simplex_noise_sum_abs_sin(vec2 p)\n{\n    float f = 0.0;\n    p = p * 7.0;\n    f += 1.0000 * abs(simplex_noise(p)); p = 2.0 * p;\n    f += 0.5000 * abs(simplex_noise(p)); p = 2.0 * p;\n    f += 0.2500 * abs(simplex_noise(p)); p = 2.0 * p;\n    f += 0.1250 * abs(simplex_noise(p)); p = 2.0 * p;\n    f += 0.0625 * abs(simplex_noise(p)); p = 2.0 * p;\n    f = sin(f + p.x/32.0);\n    return f;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv *= 2.0;\n    float n =  simplex_noise_sum_abs_sin(uv);\n    //float noise = noise_itself(uv);\n    \n    fragColor = vec4(n,n,n,1.0);\n}","name":"Image","description":"","type":"image"}]}