{"ver":"0.1","info":{"id":"sdjSDG","date":"1620956732","viewed":337,"name":"Test Cheap Sky","username":"yuletian","description":"cheap sky","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["cheapsky"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.14159265359;\nconst float invPi = 1.0 / pi;\n\nconst float zenithOffset = 0.0f;\nconst float multiScatterPhase = 0.1;\nconst float density = 0.7;\n\nconst float anisotropicIntensity = 0.0; //Higher numbers result in more anisotropic scattering\n\nconst vec3 skyColor = vec3(0.39, 0.57, 1.0) * (1.0 + anisotropicIntensity); //Make sure one of the conponents is never 0.0\n\n#define smooth(x) x*x*(3.0-2.0*x)\n#define zenithDensity(x) density / pow(max(x - zenithOffset, 0.0), 1.5f)\n#define zenithDensityB(x) density / pow(max(x - zenithOffset, 0.0), 1.5f)\n\nvec3 getSkyAbsorption(vec3 x, float y){\n\t\n\tvec3 absorption = x * -y;\n\t     absorption = exp2(absorption) * 2.0;\n\t\n\treturn absorption;\n}\n\nfloat getSunPoint(vec2 p, vec2 lp){\n\treturn smoothstep(0.03, 0.026, distance(p, lp)) * 50.0;\n}\n\nfloat getRayleigMultiplier(vec2 p, vec2 lp){\n\treturn 1.0 + pow(1.0 - clamp(distance(p, lp), 0.0, 1.0), 2.0) * pi * 0.5;\n}\n\nfloat getMie(vec2 p, vec2 lp){\n\tfloat disk = clamp(1.0 - pow(distance(p, lp), 0.1), 0.0, 1.0);\n\t\n\treturn disk*disk*(3.0 - 2.0 * disk) * 2.0 * pi;\n}\n\nvec3 getAtmosphericScattering(vec2 p, vec2 lp){\n\tvec2 correctedLp = lp;\n\t\t\n\tfloat zenith = zenithDensity(p.y);\n    \n\n\tfloat sunPointDistMult =  clamp(length(max(correctedLp.y + multiScatterPhase - zenithOffset, 0.0)), 0.0, 1.0);\n\tfloat rayleighMult = getRayleigMultiplier(p, correctedLp);\n\n\t\n\tvec3 absorption = getSkyAbsorption(skyColor, zenith);\n        \t\n\n    vec3 sunAbsorption = getSkyAbsorption(skyColor, zenithDensityB(correctedLp.y + multiScatterPhase));\n\tvec3 sky = skyColor * zenith * rayleighMult;\n\n\tvec3 sun = getSunPoint(p, correctedLp) * absorption;\n\n\tvec3 mie = getMie(p, correctedLp) * sunAbsorption;\n\t\n\tvec3 totalSky = mix(sky * absorption, sky / (sky + 0.5), sunPointDistMult);\n         totalSky += sun + mie;\n\t     totalSky *= sunAbsorption * 0.5 + 0.5 * length(sunAbsorption);\n\t\n\treturn totalSky;\n}\n\nvec3 jodieReinhardTonemap(vec3 c){\n    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));\n    vec3 tc = c / (c + 1.0);\n\n    return mix(c / (l + 1.0), tc, tc);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 position = (fragCoord.xy / iResolution.xy) * 2.0f;\n    //fragColor = vec4(position, 0.0, 1.0);\n    //return;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 dir = vec3(uv*2.0-1.0,1);\n\tdir.y *= -9.0/16.0; // wide screen    \n    \n    //position = vec2((atan(dir.z/dir.x)/6.28)-1.0f, 2.0f * acos(-dir.y)/3.1415926);\n    \n    vec2 lightPosition = iMouse.xy / iResolution.xy * 2.0f + ((iMouse.x + iMouse.y) == 0.0 ? vec2(1.0, 0.4) : vec2(0.0));\n    //lightPosition = vec2(1.0f, 1.0f);\n    \n    vec2 SubVal = vec2(0.0f, 0.0f);\n\t\n\tvec3 color = getAtmosphericScattering(position - SubVal, lightPosition - SubVal) * pi;\n\tcolor = jodieReinhardTonemap(color);\n    color = pow(color, vec3(2.2)); //Back to linear\n\n\tfragColor = vec4(color, 1.0 );\n\n}","name":"Image","description":"","type":"image"}]}