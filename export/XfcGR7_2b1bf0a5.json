{"ver":"0.1","info":{"id":"XfcGR7","date":"1711522856","viewed":60,"name":"Closest Tangent Pt - Rectangle","username":"natevm","description":"Minimal tangent cone to a rectangle. Only the front facing \"red\" edges are considered. \nMore tangent queries here: https://www.shadertoy.com/playlist/NcKBDV","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","sdf","capsule","closest"],"hasliked":0,"parentid":"l3SXDK","parentname":"Closest Tangent Pt - Sphere"},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright © 2024 Nate Morrical\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// cheaper alternative to acos intrinsic\n// https://developer.download.nvidia.com/cg/acos.html\nfloat swacos(float x) {\n  float negate = float(x < 0.f);\n  x = abs(x);\n  float ret = -0.0187293f;\n  ret = ret * x;\n  ret = ret + 0.0742610f;\n  ret = ret * x;\n  ret = ret - 0.2121144f;\n  ret = ret * x;\n  ret = ret + 1.5707288f;\n  ret = ret * sqrt(1.f-x);\n  ret = ret - 2.f * negate * ret;\n  return negate * 3.14159265358979f + ret;\n}\n\n// Given an angular similarity, returns the corresponding angle in radians. \n//   s - the similarity measure, s = (dot(d, ∆) |dot(d, ∆)| / |∆|^2)\nfloat similarityToAngle(float s) {\n    if (0.f <= s && s <= 1.f) {\n        return swacos(2.f * s - 1.0) / 2.0;\n    }\n    else if (-1.f <= s) {\n        return (swacos(2.f * s + 1.0) / 2.0) + radians(90.);\n    }\n}\n\n// Returns the angular similarity between two directions. \n// Similarity is expressed as s = dot(d, ∆) |dot(d, ∆)| / |∆|^2\n//  d - the direction of a ray\n//  ∆ - a vector relative to ray's origin. (∆ = p - o)\nfloat angularSimilarity(vec3 d, vec3 delta) {    \n    // length squared of delta\n    float deltaNorm2 = dot(delta, delta);\n    \n    // proportional to cos(theta) between d and ∆\n    float dDotDelta = dot(d, delta);\n    \n    // similarity = dot(d, ∆) |dot(d, ∆)| / |∆|^2\n    return dDotDelta * abs(dDotDelta) / deltaNorm2;\n}\n\n// Returns the closest tangent point from an infinite 3D line to a 2D rectangle on the X-Y plane, plus the closest \"t\" along o+t*d\n//   o - the origin of the segment\n//   d - the direction along the segment (which does not need to be normalized)\n//   b - the rectangle radius (2 half side lengths)\nvec4 ctpRectangleQuery( vec3 o, vec3 d, vec2 b)\n{           \n    // Since rectangle is centered, \"o\" is a vector from the center of the plane to the apex. \n    float ddotN = dot(o, vec3(0.f, 0.f, 1.f));\n    \n    // Check the four edges to determine which is closest.\n    // Project direction onto the shadow volume triangles which subtend these edges.\n    vec4 result = vec4(-1.f);\n    for (int i = 0; i < 4; ++i)\n    {\n        // Compute edge vertices of the rectangle in a counterclockwise fashion.\n        // (bit twiddling, but essentially returns bottom left, bottom right, top right, top left.\n        int i1 = i, i2 = (i == 3) ? 0 : i + 1;\n        vec2 c0 = vec2((i1 == 0) || (i1 == 3) ? -b.x : b.x, i1 < 2 ? -b.y : b.y);\n        vec2 c1 = vec2((i2 == 0) || (i2 == 3) ? -b.x : b.x, i2 < 2 ? -b.y : b.y);\n        vec3 d0 = vec3(c0, 0.0) - o;\n        vec3 d1 = vec3(c1, 0.0) - o;\n        \n        // Vector perpendicular to triangle from edge to apex, scaled by parallelogram.\n        // Equivalent to great circle normal connecting ∆0 and ∆1, but scaled.        \n        vec3 n = cross(d0, d1); // |∆0x∆1| = |∆0||∆1|sin(γ)\n        float dnn = dot(n, n);  // |N|^2\n        float ddn = dot(d, n);  // |D||N|cos(θ)\n        \n        // Cull back facing edges\n        if (ddn * ddotN < 0.0) continue; \n        \n        float dd00 = dot(d0, d0); // |∆0|^2\n        float dd11 = dot(d1, d1); // |∆1|^2\n        float dd01 = dot(d0, d1); // |∆0||∆1|cos(γ)\n\n        // By construction, this plane is tangent to the cone and lies on the great circle.\n        // Using \"Perpendicular to a chord theorem\", projecting d onto \n        // the face (which itself projects spherically to a chord) defines a line bisecting the arc. \n        // ∆2 = D - (D·N)/(N·N) * N\n        vec3 d2 = d - (ddn / dnn) * n;\n        \n        // Projection falls on the triangle / within the arc.\n        // Compute the barycentrics to recover t.\n        float d20 = dot(d2,d0);\n        float d21 = dot(d2,d1);\n        float area = (dd00*dd11 - dd01*dd01);\n        float v = ((dd11*d20) - (dd01*d21)) / area;    \n        float w = ((dd00*d21) - (dd01*d20)) / area;\n        float u = 1.f - v - w;    \n        float t = w / (w + v);\n        vec3 p = mix(d0, d1, clamp(t, 0.0, 1.0)); \n\n        float dp = dot(d, p);\n        float dpp = dot(p, p);    \n        float s = dp * abs(dp) / dpp;\n        if (s < result[0]) continue;\n        \n        result = vec4(s, p);\n    }\n    return vec4(result[0], result.yzw + o);\n}\n\n\n\n// Returns the angular similarity between a vector and a rectangle such that the infinite cone \n// with central axis matching the given ray does not cross the edges of the rectangle.\n//   o - the origin of the segment\n//   d - the direction along the segment (which does not need to be normalized)\n//   b - the rectangle radius (2 half side lengths)\nfloat mtcRectangleQuery( vec3 o, vec3 d, vec2 b)\n{              \n    // Since rectangle is centered, \"o\" is a vector from the center of the plane to the apex. \n    float ddotN = dot(o, vec3(0.f, 0.f, 1.f));\n    \n    // Check the four edges to determine which is closest.\n    // Project direction onto the shadow volume triangles which subtend these edges.\n    float maxSimilarity = -1.0;\n    for (int i0 = 0; i0 < 4; ++i0)\n    {        \n        // Some bit twiddling to get counterclockwise edges\n        int i1 = (i0 == 3) ? 0 : i0 + 1; \n        vec3 d0 = vec3((i0 == 0) || (i0 == 3) ? -b.x : b.x, i0 < 2 ? -b.y : b.y, 0.0) - o; // ∆0\n        vec3 d1 = vec3((i1 == 0) || (i1 == 3) ? -b.x : b.x, i1 < 2 ? -b.y : b.y, 0.0) - o; // ∆1\n        vec3 n = cross(d0, d1); // |∆0x∆1| = |∆0||∆1|sin(γ)\n        float ddn = dot(d, n);\n\n        // Cull back facing edges\n        if (ddn * ddotN < 0.0) continue;\n        \n        vec3 p = d - (ddn / dot(n, n)) * n; // proj(d, n)\n        float dd01 = dot(d0, d1); // |∆0||∆1|cos(γ)    \n        \n        // Clamp point to the left or right of the segment\n        // (via normals of perpendicular planes the arc via triple vector product)\n             if (dot(p, d1 * dot(d0, d0) - d0 * dd01) < 0.f) p = d0;\n        else if (dot(p, d0 * dot(d1, d1) - d1 * dd01) < 0.f) p = d1;\n        \n        // From here we compute angular similarity\n        float dp = dot(d, p);\n        float s = dp * abs(dp) / dot(p, p);\n        maxSimilarity = max(s, maxSimilarity);\n    }\n    \n    // If all edges are back facing, the ray intersects the face\n    if (maxSimilarity == -1.0) maxSimilarity = 1.f;\n    return maxSimilarity;\n}\n\n// Useful for illustrating edge winding order\nvec4 getRectanceEdgeSigns(vec3 o, vec3 d, vec2 b) {\n    vec4 edgeSign;\n    \n    float ddotN = dot(o, vec3(0.f, 0.f, 1.f));\n    \n    for (int i0 = 0; i0 < 4; ++i0)\n    {        \n        int i1 = (i0 == 3) ? 0 : i0 + 1; \n        vec3 d0 = vec3((i0 == 0) || (i0 == 3) ? -b.x : b.x, i0 < 2 ? -b.y : b.y, 0.0) - o; // ∆0\n        vec3 d1 = vec3((i1 == 0) || (i1 == 3) ? -b.x : b.x, i1 < 2 ? -b.y : b.y, 0.0) - o; // ∆1\n        vec3 n = cross(d0, d1);\n        float ddn = dot(d, n);\n        edgeSign[i0] = ddn * ddotN;\n    }\n    return edgeSign;\n}\n\n//------------------------------------------------------------\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, vec3 cen, float rad )\n{\n    return length(p-cen)-rad;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\nvec3 angleAxis(float angle, vec3 axis, vec3 v) {\n    vec3 k = normalize(axis); // Ensure the axis is a unit vector\n    float cosTheta = cos(angle);\n    float sinTheta = sin(angle);\n\n    // Rodrigues' rotation formula\n    vec3 rotated = v * cosTheta + \n                   cross(k, v) * sinTheta + \n                   k * dot(k, v) * (1.0 - cosTheta);\n\n    return rotated;\n}\n\n//https://www.shadertoy.com/view/NttcW8\nfloat sdArrow(vec3 position, vec3 start, vec3 end, float baseRadius, float tipRadius, float tipHeight) {\n    vec3 t = start - end;\n    float l = length(t);\n    t /= l;\n    l = max(l, tipHeight);\n\n    position -= end;\n    if (t.y + 1.0 < 0.0001) {\n        position.y = -position.y;\n    } else {\n        float k = 1.0 / (1.0 + t.y);\n        vec3 column1 = vec3(t.z * t.z * k + t.y, t.x, t.z * -t.x * k);\n        vec3 column2 = vec3(-t.x, t.y, -t.z);\n        vec3 column3 = vec3(-t.x * t.z * k, t.z, t.x * t.x * k + t.y);\n        position = mat3(column1, column2, column3) * position;\n    }\n \n    vec2 q = vec2(length(position.xz), position.y);\n    q.x = abs(q.x);\n   \n    // tip\n    vec2 e = vec2(tipRadius, tipHeight);\n    float h = clamp(dot(q, e) / dot(e, e), 0.0, 1.0);\n    vec2 d1 = q - e * h;\n    vec2 d2 = q - vec2(tipRadius, tipHeight);\n    d2.x -= clamp(d2.x, baseRadius - tipRadius, 0.0);\n    \n    // base\n    vec2 d3 = q - vec2(baseRadius, tipHeight);\n    d3.y -= clamp(d3.y, 0.0, l - tipHeight);\n    vec2 d4 = vec2(q.y - l, max(q.x - baseRadius, 0.0));\n\n    float s = max(max(max(d1.x, -d1.y), d4.x), min(d2.y, d3.x));\n    return sqrt(min(min(min(dot(d1, d1), dot(d2, d2)), dot(d3, d3)), dot(d4, d4))) * sign(s);\n}\n\nfloat sdSolidAngle(vec3 p, vec3 a, vec3 d, vec3 b) {\n    // Length of the side of the solid angle conic\n    float ra = distance(a, b);    \n    \n    // The angle between the direction of the conic and a point\n    // on the base.\n    float s = angularSimilarity(d, b-a);\n    float ang = similarityToAngle(clamp(s, 0.0, 1.0));\n    \n    // Transform query point s.t. apex is origin\n    p = p-a;\n    \n    // Rotate query point such that conic direction is aligned to \"y\"\n    vec3 yAxis = vec3(0, 1, 0);\n    vec3 rotAxis = cross(d, yAxis);\n    float rotAngle = acos(dot(yAxis, d));\n    vec3 pRot = angleAxis(rotAngle, rotAxis, p);\n\n    // Now compute the SDF as before with the rotated point\n    vec2 q = vec2( length(pRot.xz), pRot.y );\n    \n    vec2 c = vec2(sin(ang), cos(ang)); \n    float l = length(q) - ra;\n    float m = length(q - c*clamp(dot(q,c),0.0,ra) );\n    return max(l,m*sign(c.y*q.x-c.x*q.y));\n}\n\nfloat sdSolidAngle(vec3 p, vec3 a, vec3 d, float ra, float ang) {\n    // Length of the side of the solid angle conic\n    //float ra = length(d); // distance(a, b);    \n    \n    // The angle between the direction of the conic and a point\n    // on the base.\n    //float s = angularSimilarity(d, b-a);\n    //float ang = similarityToAngle(clamp(s, 0.0, 1.0));\n    \n    // Transform query point s.t. apex is origin\n    p = p-a;\n    \n    // Rotate query point such that conic direction is aligned to \"y\"\n    vec3 yAxis = vec3(0, 1, 0);\n    vec3 rotAxis = cross(d, yAxis);\n    float rotAngle = acos(dot(yAxis, d));\n    vec3 pRot = angleAxis(rotAngle, rotAxis, p);\n\n    // Now compute the SDF as before with the rotated point\n    vec2 q = vec2( length(pRot.xz), pRot.y );\n    \n    vec2 c = vec2(sin(ang), cos(ang)); \n    float l = length(q) - ra;\n    float m = length(q - c*clamp(dot(q,c),0.0,ra) );\n    return max(l,m*sign(c.y*q.x-c.x*q.y));\n}\n\n//------------------------------------------------------------\nconst vec2 rect_rad = vec2(1.2, .6);\n\nvec2 map( in vec3 pos, bool showSolidAngle, bool showPyramid, in vec3 apex, in vec3 dir )\n{\n    vec2 res = vec2(100.f);\n    vec4 edgeSign = getRectanceEdgeSigns(apex, dir, rect_rad);\n    float s = mtcRectangleQuery(apex, dir, rect_rad);\n    \n    // The rectangle's surface\n    {\n    float d = sdBox( pos, vec3(rect_rad.xy, .01) );\n    if( d<res.x ) res =  vec2( d, 5.0);\n    }\n    \n    // The edges of the rectangle (debugging...)\n    vec2 b = rect_rad;\n    for (int i = 0; i < 4; ++i) {\n    int i1 = i, i2 = (i == 3) ? 0 : i + 1;\n    vec2 c0 = vec2((i1 == 0) || (i1 == 3) ? -b.x : b.x, i1 < 2 ? -b.y : b.y);\n    vec2 c1 = vec2((i2 == 0) || (i2 == 3) ? -b.x : b.x, i2 < 2 ? -b.y : b.y);\n    \n    {\n    float d = sdCapsule(pos, vec3(c0, 0.0), vec3(c1, 0.0), .02);\n    if( d<res.x ) res =  vec2( d, edgeSign[i] > 0.f ? 2.0 : 4.f );\n    }\n    }\n    \n    // Arrow representing the ray\n    {\n    float d = sdArrow(pos, apex, apex+dir, .025, .06, .08);\n    if( d<res.x ) res =  vec2( d, 0.0 );\n    }\n   \n    // Query cone   \n    if (showSolidAngle) {   \n    float angle = similarityToAngle(s);\n    float d = sdSolidAngle(pos, apex, dir, 3.f, angle);\n    if( d<res.x ) res =  vec2( d, 1.0);\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, bool showSolidAngle, bool showSphere, in vec3 apex, in vec3 dir )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps, showSolidAngle, showSphere, apex, dir ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps, showSolidAngle, showSphere, apex, dir ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps, showSolidAngle, showSphere, apex, dir ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps, showSolidAngle, showSphere, apex, dir ).x );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftShadow( vec3 ro, vec3 rd, bool showSolidAngle, bool showSphere, in vec3 apex, in vec3 dir )\n{\n    float res = 1.0;\n    const float tmax = 2.0;\n    float t = 0.001;\n    for( int i=0; i<64; i++ )\n    {\n     \tfloat h = map(ro + t*rd, showSolidAngle, showSphere, apex, dir).x;\n        res = min( res, 64.0*h/t );\n    \tt += clamp(h, 0.01,0.5);\n        if( res<-1.0 || t>tmax ) break;\n        \n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep, in [-1,1]\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord)*AA + ivec2(m,n);\n        // time sample\n        float td = 0.5+0.5*sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1);\n        float time = iTime - 0.5*(1.0/60.0)*(td+float(m*AA+n))/float(AA*AA-1);\n        #else    \n        // pixel coordinates\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord);\n        // time sample\n        float time = iTime;\n        #endif\n        \n        //time = 190.f;\n\n        // animate camera\n        float an = 0.25*time + 6.283185*iMouse.x/iResolution.x;\n        vec3 ro = vec3( 3.*cos(an), 0.7, 3.*sin(an) );\n        vec3 ta = vec3( 0.0, 0.0, 0.0 );\n\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.2,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n\n        // animate the tangent cone\n        vec3 start = 1.5*-sin(time*0.5*vec3(1.0,1.1,1.2)+vec3(4.0,2.0,1.0)); //* vec3(0.0, 1.0, 1.0) + vec3(0.0, 0.0, 0.0);\n        vec3 stop  = 1.5*-cos(time*0.5*vec3(1.0,1.1,1.2)+vec3(4.0,2.0,1.0));// * vec3(0.0, 1.0, 1.0) + vec3(0.0, 0.0, 0.0);\n        vec3 apex = start;\n        vec3 dir = normalize(stop - start);\n        \n        // Make bounding sphere and solid angle transparent\n        bool showSolidAngle = (texelFetch(iChannel0,samp&7,0).x>0.25);\n        bool showSphere = (texelFetch(iChannel0,samp&7,0).x>0.25);\n        \n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raycast\n        const float tmax = 5.0;\n        float t = 0.0;\n        float m = -1.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            vec2 hm = map(pos, showSolidAngle, showSphere, apex, dir);\n            m = hm.y;\n            if( hm.x<0.0001 || t>tmax ) break;\n            t += hm.x;\n        }\n    \n        // shade background\n        vec3 col = vec3(0.05)*(1.0-0.2*length(p));\n        \n        // shade objects\n        if( t<tmax )\n        {\n            // geometry\n            vec3  pos = ro + t*rd;\n            vec3  nor = calcNormal(pos, showSolidAngle, showSphere, apex, dir);\n\n            // color\n            vec3  mate = 0.55 + 0.45*cos( m + vec3(0.0,1.0,1.5) );\n                \n            vec4 result = ctpRectangleQuery(apex, dir, rect_rad);\n            vec3 p = result.yzw;\n            \n            // Show distance isolines on query\n            if( abs(m-1.0)<0.6 || abs(m-3.0)<0.6)\n            {   \n                float dref = sdSolidAngle(p, apex, dir, p);\n                float dsam = length(pos-p);\n                mate += smoothstep(0.8,0.9,sin((dsam-dref)*80.0))*exp2(-1.0*(dsam-dref)*(dsam-dref));\n            }\n            \n            // Show distance isolines on sphere\n            if( abs(m-5.0)<0.6)\n            {     \n                float dref = sdBox(p, vec3(rect_rad, .01));\n                float dsam = length(pos-p);\n                mate += smoothstep(0.8,0.9,sin((dsam-dref)*80.0))*exp2(-1.0*(dsam-dref)*(dsam-dref));\n            }\n                       \n            // lighting\t\n            col = vec3(0.0);\n            {\n              // key light\n              vec3  lig = normalize(vec3(0.3,0.7,0.2));\n              float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n              if( dif>0.001 ) dif *= calcSoftShadow(pos+nor*0.001,lig, showSolidAngle, showSphere, apex, dir);\n              col += 0.75*mate*vec3(1.0,0.9,0.8)*dif;\n            }\n            {\n              // dome light\n              float dif = 0.5 + 0.5*nor.y;\n              col += 0.75*mate*vec3(0.2,0.3,0.4)*dif;\n            }\n        }\n\n        // gamma        \n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}