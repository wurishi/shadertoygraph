{"ver":"0.1","info":{"id":"tsySWt","date":"1575297751","viewed":252,"name":"Animated 3D grid","username":"foez","description":"3d cartesian grid, I want to get smooth rotation and visit all octants not sure how to do it yet.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["3d","grid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float capsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ap = p - a;\n    vec3 ab = b - a;\n    \n    float t = dot(ap, ab)/dot(ab, ab);\n    vec3 c = a + t*ab;\n    \n    return length(c-p) - r;\n}\n\nfloat plane(vec3 p, vec4 n) {\n    n = normalize(n);\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat pmod1(float a, float m) {\n    return mod(a-m/2., m) - m/2.;\n}\n\nfloat dF(vec3 p) {\n    float xaxis = capsule(p, vec3(0), vec3(1., 0, 0), 1.);\n    float yaxis = capsule(p, vec3(0), vec3(0, 1., 0), 1.);\n    float zaxis = capsule(p, vec3(0), vec3(0, 0, 1.), 1.);    \n    float axis = min(xaxis, yaxis);\n    axis = min(axis, zaxis);\n    \n    float xzp = abs(plane(p, vec4(0, 1, 0, 100)));\n    float xyp = abs(plane(p, vec4(0, 0, 1, 100)));\n    float yzp = abs(plane(p, vec4(1, 0, 0, 100)));\n    float planes = min(xzp, xyp);\n    planes = min(planes, yzp);\n    \n    float lines = 200.;\n    if(abs(p.z) < 1.) {\n        p.x = pmod1(p.x, 2.);\n        p.y = pmod1(p.y, 2.);\n        lines = min(lines, capsule(p, vec3(0), vec3(0, 1, 0), .2));\n        lines = min(lines, capsule(p, vec3(0), vec3(1, 0, 0), .2));\n    } else if(abs(p.x) < 1.) {\n        p.y = pmod1(p.y, 2.);\n        p.z = pmod1(p.z, 2.);\n        lines = min(lines, capsule(p, vec3(0), vec3(0, 1, 0), .2));\n        lines = min(lines, capsule(p, vec3(0), vec3(0, 0, 1), .2));\n    } else if(abs(p.y) < 1.) {\n        p.x = pmod1(p.x, 2.);\n        p.z = pmod1(p.z, 2.);\n        lines = min(lines, capsule(p, vec3(0), vec3(1, 0, 0), .2));\n        lines = min(lines, capsule(p, vec3(0), vec3(0, 0, 1), .2));\n    }\n    \n    \n    float scene = min(planes, axis); \n    return min(scene, lines);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    for(int i=0;i<100;i++) {\n        float dd = dF(ro + d*rd);\n        if(dd < 0.001 || d > 101.) break;\n        d += dd;\n    }\n    return d;\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0.0);\n\treturn normalize(vec3(\n    \tdF(p+e.xyy) - dF(p-e.xyy),\n        dF(p+e.yxy) - dF(p-e.yxy),\n        dF(p+e.yyx) - dF(p-e.yyx)\n    ));\n}\n\nfloat getDiffuse(vec3 p, vec3 lightPos) {\n    vec3 lightDir = normalize(p-lightPos);\n    vec3 n = getNormal(p);\n    return max(0.8, dot(lightDir, n));\n}\n\nvec4 image(vec2 uv, vec2 resolution)\n{\n    vec3 col = vec3(0);\n    float ar = resolution.x/resolution.y;\n    uv.x *= ar;\n    \n    vec3 ro = vec3(30, 10, 30);\n    vec3 la = vec3(0);\n    \n    float t = iTime*0.5;\n    \n    ro.xz *= rot(t*.5);\n\tt *= 2.;\n    ro.y *= sin(t+sin(t+sin(t + 0.5)));\n    vec3 f = normalize(la-ro);\n    vec3 u = normalize(vec3(0, 1, 0));\n    vec3 r = normalize(cross(f, u));\n    \n    float focal_length = ar/tan(55.0*3.14/180.);\n    vec3 rd = normalize(focal_length*f + uv.x*r + uv.y*u);\n    \n    float d = rayMarch(ro, rd);\n    \n    if(d < 100.) {\n        vec3 p = ro + d*rd;\n        float diffuse = getDiffuse(p, vec3(10, 10, 10));\n        col = mix(vec3(1)*diffuse, vec3(0), d/100.);\n        \n        if(p.x > 1.1 && abs(p.y) < 1.1 && abs(p.z) < 1.1) col *= vec3(1, 0, 0);\n        else if(p.x < -1.1 && abs(p.y) < 1.1 && abs(p.z) < 1.1)col *= 0.5*vec3(1, 0, 0);\n        \n        \n        if(p.y > 1.1 && abs(p.x) < 1.1 && abs(p.z) < 1.1) col *= vec3(0, 1, 0);\n        else if(p.y < -1.1 && abs(p.x) < 1.1 && abs(p.z) < 1.1) col *= 0.5*vec3(0, 1, 0);\n        \n        if(p.z > 1.1 && abs(p.y) < 1.1 && abs(p.x) < 1.1) col *= vec3(0, 0, 1);\n        else if(p.z < -1.1 && abs(p.y) < 1.1 && abs(p.x) < 1.1) col *= 0.5*vec3(0, 0, 1);\n    }\n    \n    return vec4(col, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1. + 2.*fragCoord/iResolution.xy;\n    fragColor = image(uv, iResolution.xy);\n}","name":"Image","description":"","type":"image"}]}