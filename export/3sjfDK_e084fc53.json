{"ver":"0.1","info":{"id":"3sjfDK","date":"1590908483","viewed":152,"name":"DriveHome","username":"fangyuan267","description":"3d space move light","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["light"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define S(a, b, t) smoothstep(a, b, t)\n\nfloat Noise(float t) //generate random number\n{\n\treturn fract(sin(t * 3456.)*6543.);   \n}\n\nvec4 Noise4(float t) //generate random number\n{\n\treturn fract(sin(t * vec4(123., 1024.,3456., 9564.))*vec4(6543., 345.,8799., 1564.));   \n}\n\nstruct ray\n{\n    vec3 o, d;\n};\n    \nray GetRay(vec2 uv, vec3 camPos, vec3 lookat, float zoom)\n{\n    ray a;\n    a.o = camPos;\n    vec3 forward = normalize(lookat - camPos);\n    vec3 right = normalize(cross(vec3(0., 1., 0.), forward));\n    vec3 up = normalize(cross(forward, right));\n    vec3 center = a.o + forward * zoom;\n    vec3 i = center + uv.x*right + uv.y*up;\n    \n    a.d = normalize(i - a.o);\n    \n    return a;\n}\n\nfloat DistRay(ray r, vec3 p)\n{\n\t return length(cross(p - r.o, r.d))/length(r.d);\n}\n\nfloat Bokeh(ray r , vec3 p, float size, float blur)  \n{\n    float dist = DistRay(r , p);\n    size *= length(p); //set light in same size, without change of depth\n    \n    float light = S(size, size *(1. - blur), dist);\n    light *= mix(.7, 1.,S(size* .8, size, dist));\n    \n    return light;\n}\n\nvec3 StreetLights(ray r, float t)\n{\n    float side = step(r.d.x, 0.); //if x<0，return 0，else return 1,to control generate speed side by side\n    r.d.x = abs(r.d.x); //mirror effect\n    float s = .1; //generate speed\n    float mask = 0.;\n    for(float i = 0.; i<1. ; i+=s)\n    {\n        float ti = fract(t + i +side*s*.5);\n        vec3 p = vec3(2., 2. , 100. -ti*100.);   \n\t\tmask += Bokeh(r, p , .05, .1) *ti *ti *ti;\n    }\n    \n    return vec3(1., .7, .3) *mask;\n}\n\nvec3 EnviromentLights(ray r, float t)\n{\n    float side = step(r.d.x, 0.); //if x<0，return 0，else return 1,to control generate speed side by side\n    r.d.x = abs(r.d.x); //mirror effect\n    float s = .1; //generate speed\n    vec3 color = vec3(0.);\n    for(float i = 0.; i<1. ; i+=s)\n    {\n        float ti = fract(t + i +side*s*.5);\n        \n        vec4 n = Noise4(i+side*100.);\n        \n        float fade = ti *ti *ti;\n        float occlusion = sin(ti*6.28*10.*n.x) * .5 +.5;\n        \n        fade += occlusion; //add blink to light\n        float x = mix(2.5, 10., n.x);\n        float y = mix(.1, 1.5, n.y);\n        vec3 p = vec3(x , y , 50. -ti*50.); \n        \n        vec3 col = n.wzy; //random light color\n\t\tcolor += Bokeh(r, p , .05, .1)* fade *col *.4; \n    }\n    \n    return color;\n}\n\nvec3 HeadLights(ray r, float t)\n{\n    t *= 2.;\n    float w1 = .25;\n    float w2 = w1*1.2;\n    float s = 1./30.;\n    float mask = 0.;\n    for(float i = 0.; i<1. ; i+=s)\n    {\n        float n = Noise(i); //light number generate irregularly\n        \n        if(n >.1) continue;\n        \n        float ti = fract(t + i); //set time change between 0. and 1.\n        float z = 100. -ti*100.; //control light original depth and speed\n        float fade = ti* ti* ti * ti* ti; //light bright level\n  \t\tfloat focus = S(.9, 1., ti);  //limit highlight in center\n        \n        float size = mix(.06, .03, ti);\n\t\tmask += Bokeh(r, vec3(-1. -w1, .15 , z) , size, .1) *fade;\n        mask += Bokeh(r, vec3(-1. +w1, .15 , z) , size, .1) *fade;\n        \n        mask += Bokeh(r, vec3(-1. -w2, .15 , z) , size, .1) *fade;\n        mask += Bokeh(r, vec3(-1. +w2, .15 , z) , size, .1) *fade;\n        \n        float ref =0.; //reflection on road\n        ref += Bokeh(r, vec3(-1. -w2, -.15 , z) , size*3., 1.) *fade;\n        ref += Bokeh(r, vec3(-1. +w2, -.15 , z) , size*3., 1.) *fade;\n        \n        mask += ref ;//* focus;\n    }\n    \n    return vec3(.9, .9, 1.) *mask;\n}\n\nvec3 TailLights(ray r, float t)\n{\n    t *= .25;\n    float w1 = .25;\n    float w2 = w1*1.2;\n    float s = 1./15.;\n    float mask = 0.;\n    for(float i = 0.; i<1. ; i+=s)\n    {\n        float n = Noise(i); //n = 0. to 1.\n        \n        if(n >.5) continue; //n = 0. to .7\n        \n        float lane = step(0.25, n); //lane = 0. or 1.,generate diffrent side position\n        float ti = fract(t + i); //set time change between 0. and 1.\n        float z = 100. -ti*100.; //control light original depth and speed\n        float fade = ti* ti* ti * ti* ti; //light bright level\n  \t\tfloat focus = S(.9, 1., ti);  //limit highlight in center\n        \n        float size = mix(.06, .03, ti);\n        float laneShift = S(1., .96, ti);\n        float x = 1.5 -lane * laneShift; //control light side\n        float blink = step(0., sin(t * 1000.)) *7.* abs(lane -1.) *step(0.9, ti); //blinker, right side blink\n        \n\t\tmask += Bokeh(r, vec3(x -w1, .15 , z) , size, .1) *fade;\n        mask += Bokeh(r, vec3(x +w1, .15 , z) , size, .1) *fade;\n        \n        mask += Bokeh(r, vec3(x -w2, .15 , z) , size, .1) *fade;\n        mask += Bokeh(r, vec3(x +w2, .15 , z) , size, .1) *fade* (1. +blink);\n        \n        float ref =0.; //reflection on road\n        ref += Bokeh(r, vec3(x -w2, -.15 , z) , size*3., 1.) *fade;\n        ref += Bokeh(r, vec3(x +w2, -.15 , z) , size*3., 1.) *fade* (1. +blink *.1);\n        \n        mask += ref ;//* focus;\n    }\n    \n    return vec3(1., .1, .03) *mask;\n}\n\nvec2 Rain(vec2 uv, float t)\n{\n    t *= 40.;\n    uv.x += uv.y*0.4; //add wind global\n    vec2 a = vec2(3., 1.); //aspect ratio\n    //vec2 st = fract(uv *a) -.5;//set every uv box center is (0,0)\n    vec2 st = uv *a; //slice uv to little box\n    \n    vec2 id = floor(st); //return the bigest integer that < st\n    st.y += t*.22; //move box down, as well as drop down and then stay at some position  \n    //st.x += t*.08;\n    float n = fract(sin(id.x * 716.34) *768.34); \n    uv.x += uv.y*n; //add random wind offset \n    st.x += n*.1;\n    st.y += n;//set random y position\n    uv.y += n;//drop at diffrent hight\n    id = floor(st);\n    st = fract(st) -.5;\n    \n    t+= fract(cos(id.y * 345.6 + id.x *678.7) *234.34) *6.283;\n    t+= fract(sin(id.x * 76.34 + id.y *1453.7) *768.34) *6.283; //drop at diffrent time\n    float y = - sin(t+sin(t+sin(t) *.5)) *.4; //diffrent speed for up and down   \n    vec2 p1 = vec2(0., y);//move drop in y axis\n    vec2 o1 = (st - p1)/a; //set drop shape to round\n    \n    //get little drop in every box\n    float d = length(o1);\n    float mask1 = S(.07, .0, d);\n    \n    vec2 o2 = (fract(uv * a.x* vec2(1., 2.)) - .5)/vec2(1.,2.); //add more little round drop in line\n    d = length(o2);\n    \n    //S(-.1, .1, st.y- p1.y) for remove little drop below the big drop\n    //(.5 - st.y) for change little drop size by distance to big drop\n    float mask2 = S(.3 * (.5 - st.y), .0, d) * S(-.1, .1, st.y- p1.y);\n    //if(st.x > .46 || st.y >.48) mask1 = 1.; //debug line\n    return vec2(mask1 * o1*30. + mask2 *o2*10.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    float t = iTime * .05 ;//*m.x;\n    \n    vec3 camPos = vec3(0.5 + sin(t* 20.)*0.012, .2, .0);\n    vec3 lookat = vec3(0.5, .2, 1.);\n    \n    float zoom = 2.;\n    \n    vec2 rainDistort = Rain(uv*5., t)* .5;\n    rainDistort += Rain(uv*7., t)* .5;\n    \n    //add rain distortion\n    uv.x += sin(uv.y *70.) *.005; \n    uv.y += sin(uv.x *170.) *.003;\n    \n    ray r = GetRay(uv, camPos, lookat, zoom);\n    \n    vec3 col = StreetLights(GetRay(uv - rainDistort*.5, camPos, lookat, zoom), t);\n    col += HeadLights(GetRay(uv - rainDistort*.5, camPos, lookat, zoom), t);\n    col += TailLights(GetRay(uv - rainDistort*.5, camPos, lookat, zoom), t);\n    col += EnviromentLights(GetRay(uv - rainDistort*.5, camPos, lookat, zoom), t);\n    \n    col += (r.d.y+ .25) * vec3(.2, .1, .5);\n    //col = vec3(rainDistort, 0.);\n\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}