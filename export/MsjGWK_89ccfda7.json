{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//#define ORBIT_CAM\n\n#define ITERATIONS 96\n#define SHADOW_ITERATIONS 8\n\n\nconst float streetWidth = 30.0;\nconst float blockWidth = 200.0;\nconst float totalBlock = blockWidth + streetWidth;\nconst float halfStreetWidth = streetWidth*0.5;\nconst float maxBlockHeight = 600.00;\n\n#define sat(x) clamp(x,0.0, 1.0)\n\nfloat linstep(float a, float b, float t){\n\tfloat v=(t-a)/(b-a);\n\treturn clamp(v,0.,1.);\n}\nfloat rand(vec2 co){// implementation found at: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\nfloat smoothstep2( float min1, float max1, float min2, float max2, float p )\n{\n\treturn smoothstep(min1, max1, p) * (1.0 - smoothstep(min2, max2, p));\n}\nfloat softstep( float min1, float p )\n{\n\treturn smoothstep(min1, min1+0.01, p);\n}\nfloat softstep2( float min1, float min2, float p )\n{\n\treturn softstep(min1, p) * (1.0 - softstep(min2, p));\n}\n\n\n\nfloat BlockDe( vec3 pos, float blockId, inout vec4 m )\n{\n\tif( blockId < 0.33 )\n\t\treturn 99999.9;\n\tfloat h = blockId;\n\t\n\th = maxBlockHeight*0.01 + h*maxBlockHeight*0.99;\n\th *= 0.5;\n\t\n\tfloat wScale = fract(blockId+0.5);\n\t\n\tfloat w = blockWidth*0.5;\n\tfloat xz = w*0.6 + w*0.4*wScale;\n\t\n\tpos.xz -= totalBlock*0.5;\n\t\n\tfloat bulk = sdBox( pos - vec3(0,h,0), vec3(xz,h,xz) );\n\tfloat de = bulk;\n\t\n\tfloat bounds = sdBox( pos - vec3(0,h+1.0,0), vec3(xz+2.0,h+2.0,xz+2.0) );\n\t\n\tfloat bands;\n\t{\n\t\tvec3 p = pos;\n\t\tfloat addHeight = 10.0;\n\t\tp.y += 2.0;\n\t\tfloat r = addHeight + addHeight + 20.0 * (fract(1.3-blockId*7.0));\n\t\tp.y = mod(p.y,r);//-0.5*r;\n\t\txz = xz+1.0*wScale;\n\t\tbands = sdBox(p, vec3(xz, addHeight, xz));\n\t\tbands = max(bands,bounds);\n\t\tde = smin( de, bands, 10.0 );\n\t}\n\t\n\tfloat base;\n\t{\n\t\tfloat baseW = w*0.9 + w*0.1*wScale;\n\t\tfloat baseH = 0.1 + 4.0 * blockId;\n\t\tbase = sdBox( pos - vec3(0,baseH,0), vec3(baseW,baseH,baseW) );\n\t\tde = min(de,base);\n\t}\n\t\n\t\n\tfloat alpha = clamp((bulk-bands)*100.0,0.0,1.0);\n\tm = mix( vec4(1,0,0,0), vec4(0,1,0,0), alpha );\n\talpha = clamp((base-bulk+2.0)*10000.0,0.0,1.0);\n\tm = mix( vec4(0,0,1,0), m, alpha );\n\t\n\treturn de;\n}\nfloat BlockId( vec2 pos )\n{\n\t//return 1.0;\n\treturn rand(floor(pos/totalBlock));\n}\n//close to the surface of a building\nfloat DeN( vec3 pos )\n{\n\tfloat blockId1 = BlockId(pos.xz);\n\tpos.x = mod(pos.x,totalBlock);\n\tpos.z = mod(pos.z,totalBlock);\n\tvec4 m = vec4(0);\n\treturn BlockDe(pos, blockId1, m);\n}\n//within city volume\nfloat DeWithin( vec3 pos, vec3 rd, out float maxStep, inout vec4 m )\n{\n\tfloat startBlockX = floor((pos.x)/totalBlock);\n\tfloat startBlockZ = floor((pos.z)/totalBlock);\n\tfloat xDir = rd.x > 0.0 ? 1.0 : -1.0;\n\tfloat zDir = rd.z > 0.0 ? 1.0 : -1.0;\n\tvec3 p1N = normalize(vec3(-1,0,0));\n\tvec3 p2N = normalize(vec3(0,0,-1));\n\tfloat p1Offs = rd.x > 0.0 ? (startBlockX+1.0)*totalBlock : (startBlockX)*totalBlock;\n\tfloat p2Offs = rd.z > 0.0 ? (startBlockZ+1.0)*totalBlock : (startBlockZ)*totalBlock;\n\tfloat e1 = -(dot(p1N,pos) + p1Offs) / (dot(p1N, rd));\n\tfloat e2 = -(dot(p2N,pos) + p2Offs) / (dot(p2N, rd));\n\tmaxStep = min(e1,e2);\n\t\n\tfloat blockId1 = BlockId(pos.xz);\n\tpos.x = mod(pos.x,totalBlock);\n\tpos.z = mod(pos.z,totalBlock);\n\treturn BlockDe(pos, blockId1, m);\n}\n//above city volume\nfloat DeAbove( vec3 pos, vec3 rd, out float maxStep, inout vec4 m )\n{\n\tfloat de;\n\tif( pos.y > maxBlockHeight+0.1 )\n\t{//if ray is above buildings, continue until you're at roof height\n\t\tde = (pos.y-maxBlockHeight) / (abs(rd.y));\n\t\tde = max(de, 0.1);\n\t}\n\telse\n\t{\n\t\treturn DeWithin(pos, rd, maxStep, m);\n\t\t//return DeN(pos);\n\t}\n\treturn maxStep=de;\n}\n\n\nvec3 CalcNormal(vec3 p, float rCoC)\n{\n\trCoC = 0.001;\n\tvec2 v=vec2(0.5*rCoC,0.0);\n\treturn normalize(vec3(-DeN(p-v.xyy)+DeN(p+v.xyy),-DeN(p-v.yxy)+DeN(p+v.yxy),-DeN(p-v.yyx)+DeN(p+v.yyx)));\n}\n\nvec2 GetUv(vec3 N0, vec3 hit0)\n{\n\tN0 = abs(N0);\n\treturn N0.x > N0.y\n\t\t? (N0.z > N0.x ? hit0.xy : hit0.zy)\n\t\t: (N0.z > N0.y ? hit0.xy : hit0.xz);\n}\n\nfloat noise( in vec2 x )\n{\n\treturn sin(1.5*x.x)*sin(1.5*x.y);\n}\n\nfloat fbm4( vec2 p )\n{\n\tconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nfloat fbm6( vec2 p )\n{\n\tconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.015625*(0.5+0.5*noise( p ));\n    return f/0.96875;\n}\n\n\nvec3 DoLighting( vec3 pos, vec3 V, vec3 N, vec3 color, vec2 fragCoord )\n{\n\tfloat specular = 0.0;\n\tfloat diffuse = 0.0;\n\t\n\tvec3 ambientL = normalize(vec3(-1,2,1));\n\tvec3 ambientH = normalize(ambientL + V);\n\t\n\tvec3 L = ambientL;\n\tfloat shadow = 0.0;\n\tfloat t = 1.0;\n\tpos += N*1.0;\n\t//pos += V*1.0;\n\tfor(int i=1;i<SHADOW_ITERATIONS;i++){//march loop\n\t\t\n\t\tvec3 p = pos+L*t;\n\t\tfloat rCoC;\n\t\t\n\t\tfloat maxStep = 9999999.0;\n\t\tvec4 c = vec4(0);\n\t\tfloat de=DeWithin( p, L, maxStep, c );// +0.25*rCoC;\n\t\t\n\t\trCoC = (100.0 - 100.0/(t*0.02));\n\t\tif(de<rCoC){\n\t\t\tshadow += (1.0-sat(de/rCoC))*sat(45.0/t);\n\t\t}\n\t\t\n\t\tde = max( de * 2.0, 10.0 );\n\t\tde = min(de,maxStep);\n\t\tde += 1.0*rand(fragCoord.xy*vec2(i));\n\t\tt += de;\n\t}\n\tshadow = 1.0-sat(shadow)*0.55;\n\t\n\tdiffuse += (dot(N,ambientL)*0.5+0.5) * shadow;\n\tspecular += sat(dot(N,ambientL))* pow(sat(dot(N,ambientH)), 10.0) * shadow;\n\t\n\t//return vec3(shadow);\n\t\n\tfloat specMask = sat(1.0-dot(vec3(1./3.), color));\n\treturn diffuse * color + specular * specMask;\n}\n\nvec3 _RoadTexture(vec3 pos)\n{\n\tfloat f = abs(sin(pos.x*10.0))*abs(sin(pos.z*12.0));\n\tvec3 road = mix(vec3(0.10,0.12,0.13), vec3(0.13,0.1,0.08), f);\n\t\n\tvec2 xz = abs(mod(pos.xz, totalBlock)-totalBlock*0.5)-blockWidth*0.5;\n\txz /= halfStreetWidth;\n\t\n\tconst float lineWidth = 0.1;\n\tconst float lnpcnt = 0.5*lineWidth/halfStreetWidth;\n\tvec3 paint = vec3(0.5,0.5,0.4);\n\tfloat lane;\n\t\n\troad = mix(road, paint, softstep(1.0-lnpcnt*5.0,xz.x) );\n\tlane = 3.0/halfStreetWidth;\n\troad = mix(road, paint, softstep2(1.0-lane-lnpcnt, 1.0-lane+lnpcnt, xz.x) );\n\tlane = 6.0/halfStreetWidth;\n\troad = mix(road, paint, softstep2(1.0-lane-lnpcnt, 1.0-lane+lnpcnt, xz.x) );\n\tlane = 9.0/halfStreetWidth;\n\troad = mix(road, paint, softstep2(1.0-lane-lnpcnt, 1.0-lane+lnpcnt, xz.x) );\n\tlane = 12.0/halfStreetWidth;\n\troad = mix(road, paint, softstep2(1.0-lane-lnpcnt*5.0, 1.0-lane+lnpcnt*5.0, xz.x) );\n\t\n\troad = mix(road, paint, softstep(1.0-lnpcnt*5.0,xz.y) );\n\tlane = 3.0/halfStreetWidth;\n\troad = mix(road, paint, softstep2(1.0-lane-lnpcnt, 1.0-lane+lnpcnt, xz.y) );\n\tlane = 6.0/halfStreetWidth;\n\troad = mix(road, paint, softstep2(1.0-lane-lnpcnt, 1.0-lane+lnpcnt, xz.y) );\n\tlane = 9.0/halfStreetWidth;\n\troad = mix(road, paint, softstep2(1.0-lane-lnpcnt, 1.0-lane+lnpcnt, xz.y) );\n\tlane = 12.0/halfStreetWidth;\n\troad = mix(road, paint, softstep2(1.0-lane-lnpcnt*5.0, 1.0-lane+lnpcnt*5.0, xz.y) );\n\treturn road;\n}\nvec3 RoadTexture(vec3 uvw)\n{\n\tvec3 ddx_uvw = uvw + dFdx(uvw);\n\tvec3 ddy_uvw = uvw + dFdy(uvw);\n\t\n\tfloat detail = 1.0;\n\tconst int MaxSamples = 4;\n\t\n    int sx = 1 + int( clamp( 4.0*length(ddx_uvw-uvw), 0.0, float(MaxSamples-1) ) );\n    int sy = 1 + int( clamp( 4.0*length(ddy_uvw-uvw), 0.0, float(MaxSamples-1) ) );\n\n\tvec3 no = vec3(0.0);\n\n    for( int j=0; j<MaxSamples; j++ )\n    for( int i=0; i<MaxSamples; i++ )\n    {\n        if( j<sy && i<sx )\n        {\n            vec2 st = vec2( float(i), float(j) ) / vec2( float(sx),float(sy) );\n            no += _RoadTexture( uvw + st.x*(ddx_uvw-uvw) + st.y*(ddy_uvw-uvw) );\n        }\n    }\n\n    return no / float(sx*sy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime;\n#ifdef ORBIT_CAM\n\tvec3 ro = vec3(sin(time*0.5)*1000.0, 1000, cos(time*0.5)*1000.0);\n\tvec3 ta = vec3(0, (sin(time)*0.5+0.5)*200.0, 0);\n#else\n\tvec3 ro = vec3(pow(sin(time*0.5),3.0)*5.0+6.0, 1.4, time*100.0);\n\tvec3 ta = ro + vec3(sin(time*0.8)*3.0,(sin(time)*0.5+0.5)*2.0,10);\n#endif\n\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 1.0*cw );\n\t\n\tfloat distToGround = - (dot(vec3(0,1,0),ro) + 0.0) / (dot(vec3(0,1,0), rd));\n\tdistToGround = distToGround < 0.0 ? 999999.0 : distToGround;\n\t\n\tvec3 N = vec3(0,0.000001,0);\n\tfloat coverage = 0.0;\n\tvec4 material = vec4(0.001, 0, 0, 0);\n\tfloat t=0.0;//distance traveled\n\t//float didHit = 0.0;\n\tfor(int i=0;i<ITERATIONS;i++){//march loop\n\t\tif( t >= distToGround || coverage > 0.99 ) continue;\n\t\t\n\t\tvec3 pos = ro+rd*t;\n\t\t\n\t\tfloat rCoC=0.0001;\n\t\t\n\t\tfloat maxStep = 999999.0;\n\t\tfloat de=DeAbove( pos, rd, maxStep, material ) +0.25*rCoC;\n\t\t\n\t\tif(de<rCoC){\n\t\t\tN = CalcNormal(pos, rCoC);\n\t\t\tcoverage = 1.0;\n\t\t}\n\t\t\n\t//\tde = abs(de)*(0.5+0.5*rand(fragCoord.xy*vec2(i)));\n\t\tde = min(de, maxStep+halfStreetWidth);\n\n\t\tt += de;\n\t}\n\t\n\tt = min(t,abs(distToGround));\n\tvec3 pos = ro + rd*t;\n\t\n//\t\tcol += vec3(0.5,.5,1.0) * (sin(pos.y*0.5)*0.25+0.75) * bgAlpha;\n\t\n\t//vec3 N = normalize(avgN);\n\tN = normalize(N);\t\n\t\n\tvec3 _mtl0 = vec3(0.34, 0.40, 0.24);\n\tvec3 _mtl1 = vec3(0.38, 0.54, 0.51);\n\tvec3 _mtl2 = vec3(0.38, 0.40, 0.61);\n\tvec3 _mtl3 = vec3(0.03, 0.42, 0.64);\n\t\n\tfloat id = BlockId(pos.xz);\n\t\n\tvec3 mtl0 = mix(_mtl0, _mtl1, fract(id*2.0));\n\t     mtl0 = mix( mtl0, _mtl3, fract(id*2.0+1.0));\n\tvec3 mtl1 = mix(_mtl1, _mtl2, fract(id*4.0+0.4));\n\t     mtl1 = mix( mtl1, _mtl0, fract(id*1.0+0.3));\n\tvec3 mtl2 = mix(_mtl2, _mtl3, fract(id*2.0+0.7));\n\t     mtl2 = mix( mtl2,  mtl1, fract(id*0.1+0.7));\n\tvec3 mtl3 = mix(_mtl3, _mtl0, fract(id*8.0+0.6));\n\t     mtl3 = mix( mtl3, _mtl1, fract(id*0.5+0.6));\n\t\n\t\n\tvec3 col = vec3(0);\n\t\n\tif( pos.y < 0.01 )\n\t{\n\t\tmtl3 = RoadTexture(pos);\n\t\tmaterial = vec4(0,0,0,1);\n\t\tN = vec3(0,1,0);\n\t\tcoverage = 1.0;\n\t}\n//\telse if( rd.y > 0.0 && t > 1000.0 )\n//\telse if( rd.y > 0.0 && pos.y >= maxBlockHeight-1.1 )\n\telse if( pos.y >= maxBlockHeight-10.1 )\n\t{\n\t\tvec3 sky = mix( vec3(.17, .13, .3), vec3(.1, .13, .47), rd.y );\n\t\tcol = sky;\n\t\tcoverage = 0.0;\n\t}\n\telse if( coverage < 1.0 )\n\t{\n\t\tfloat rCoC=0.01;\n\t\tN = CalcNormal(pos, rCoC);\n\t\tcoverage = 1.0;\n\t}\n\t\n\t\t\t\n\tvec2 uv = GetUv(N, pos.xyz);\n\t\n\tmaterial /= dot(vec4(1),material);\n\tvec3 mtlCol = mtl0 * material.x\n\t            + mtl1 * material.y\n\t            + mtl2 * material.z\n\t            + mtl3 * material.w;\n\tmtlCol *= (fbm4(uv*0.041)*0.25+0.75) * vec3(1);\n\t\n\tif( coverage > 0.0 )\n\t{\n\t\tvec3 V = -normalize(pos - ro);\n\t\tcol.rgb += DoLighting( pos, V, N, mtlCol, fragCoord )*2.0;\n\t}\n\t\n\tif( fragCoord.x > iMouse.x )\n\t{\n\t\tfloat crush = 0.1;\n\t\tfloat frange = 12.0;\n\t\tfloat exposure = 256.0;\n\t\tcol = log2(1.0+col*exposure);\n\t\tcol = smoothstep(crush, frange, col);\n\t\tcol = col*col*col*(col*(col*6.0 - 15.0) + 10.0);\n\t\tcol = pow(col, vec3(2.2));\n\t}\n\t\n//\tcol = mix( col, vec3(1,0,0), coverage>0.0?0.0:1.0 );\n\tfragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsjGWK","date":"1393724853","viewed":254,"name":"future city mk2","username":"Hodgman","description":"Another version of https://www.shadertoy.com/view/Xdj3WV","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["cyberpunk"],"hasliked":0,"parentid":"","parentname":""}}