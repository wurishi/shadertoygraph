{"ver":"0.1","info":{"id":"4lBfD1","date":"1515521308","viewed":1070,"name":"Spiral Triangles","username":"jchabin1","description":"Raymarched triangle thingies with bloom effect.\nIt now interacts with music...\n\nFor something different, change the URL of iChannel1 on Buf A to\nhttps://soundcloud.com/khaki-2/muse-supermassive-black-hole\nand change CRAZY_MODE to true in Buf A.","likes":15,"published":1,"flags":96,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#pragma optionNV (unroll all)\n\n//I have no idea what that does... but it might fix the bug tholzer was having?\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float size = 15.0;\n    float res = 3.0;\n    vec4 color = vec4(0.0);\n    for(float x = 0.0; x <= size * 2.0; x += res)\n        for(float y = 0.0; y <= size * 2.0; y += res)\n\t\t\tcolor += texture(iChannel0, (fragCoord + vec2(x, y) - vec2(size)) / iResolution.xy) * clamp(1.0 - distance(vec2(size), vec2(x, y)) / size, 0.01, 1.0);\n    color /= pow(size / res, 2.0);\n    color = pow(color, vec4(0.5));\n    //color *= 2.0;\n    color += clamp(texture(iChannel0, fragCoord / iResolution.xy), 0.0, 1.0);\n    color /= 2.0;\n    fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsBXRm","filepath":"https://soundcloud.com/ursine-vulpine/do-you-realize-the-flaming-lips-ursine-vulpine","previewfilepath":"https://soundcloud.com/ursine-vulpine/do-you-realize-the-flaming-lips-ursine-vulpine","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const bool CRAZY_MODE = false;\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float EPSILON = 0.00001;\n\nfloat sphere(vec3 p, vec3 pos, float size){\n    return length(p - pos) - size;\n}\n\nfloat box(vec3 p, vec3 pos, vec3 size){\n    return length(max(abs(p - pos) - size, 0.0));\n}\n\nfloat triPrism(vec3 p, vec2 h){\n    vec3 q = abs(p);\n    return max(q.z - h.y, max(q.x * 0.866025 + p.y * 0.5, - p.y) - h.x * 0.5);\n}\n\nvec3 rotateX(vec3 p, float r){\n    return vec3(p.x, p.y * cos(r) - p.z * sin(r), p.y * sin(r) + p.z * cos(r));\n}\n\nvec3 rotateY(vec3 p, float r){\n    return vec3(p.x * cos(r) - p.z * sin(r), p.y, p.x * sin(r) + p.z * cos(r));\n}\n\nvec3 rotateZ(vec3 p, float r){\n    return vec3(p.x * cos(r) - p.y * sin(r), p.x * sin(r) + p.y * cos(r), p.z);\n}\n\nfloat smin(float a, float b, float k){\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nvec2 vmin(vec2 a, vec2 b){\n    return a.x < b.x ? a : b;\n}\n\nvec2 vmax(vec2 a, vec2 b){\n    return a.x > b.x ? a : b;\n}\n\nvec2 sceneDist(vec3 p){\n    vec3 pos = p;\n    vec4 sound = texelFetch(iChannel1, ivec2(mod(floor(pos.z / 3.0) * 150.0, 512.0), 0), 0);\n    pos = rotateZ(pos, 0.3 * floor((pos.z) / 3.0));\n    pos = vec3(mod(pos.x + 10.0, 20.0) - 10.0, mod(pos.y + 5.0, 10.0) - 5.0, mod(pos.z, 3.0) - 1.5);\n    pos = rotateZ(pos, pow(sound.x, 5.0) * 5.0);\n    if(CRAZY_MODE)\n    \tpos.xy *= pow(sound.x, 7.0) * 5.0;\n    vec2 dist = vec2(\n        max(\n            max(triPrism(pos, vec2(3.0, 0.3)), -triPrism(pos, vec2(1.5, 0.6))),\n            triPrism(rotateZ(pos, PI / 3.0), vec2(5.0, 1.0))\n        ), 1.0);\n    dist = vmin(dist,\n              vec2(max(\n                  triPrism(rotateZ(pos, PI / 3.0), vec2(1.4, 0.1)),\n                  -triPrism(pos, vec2(1.3 - sound.x * 0.2, 0.2))\n              ), 2.0 + clamp(sound.x, 0.0, 1.0))\n           );\n    //dist = vmin(dist,\n    //            vec2(\n    //                sphere(mod(p + 10.0, 20.0) - 10.0, vec3(0.0), 1.0)\n    //            , 3.0));\n    return dist;\n}\n\nvec3 getNormal(vec3 p){\n    float EPSILON = EPSILON * 100.0;\n    return normalize(vec3(\n        sceneDist(vec3(p.x + EPSILON, p.y, p.z)).x - sceneDist(vec3(p.x - EPSILON, p.y, p.z)).x,\n        sceneDist(vec3(p.x, p.y + EPSILON, p.z)).x - sceneDist(vec3(p.x, p.y - EPSILON, p.z)).x,\n        sceneDist(vec3(p.x, p.y, p.z  + EPSILON)).x - sceneDist(vec3(p.x, p.y, p.z - EPSILON)).x\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 mouse;\n    if(iMouse.z > 0.0)\n    \tmouse = vec2(iMouse.x / iResolution.x * 2.0 - 1.0, iMouse.y / iResolution.y * 2.0 - 1.0);\n    else\n        mouse = vec2(0.0);\n    float sound = texelFetch(iChannel1, ivec2(512 / 2, 0), 0).x;\n\tvec3 camera = vec3(0.0, 0.0, -iTime * 7.0);\n    float fov = PI / 4.0;\n    vec2 cameraAngle = vec2(PI + mouse.x * fov, 0.0 + mouse.y * fov);\n    \n    vec4 skycolor = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 color = skycolor;\n    \n    vec2 pos = vec2((2.0 * (fragCoord.x / iResolution.x) - 1.0), (2.0 * (fragCoord.y / iResolution.y) - 1.0) / iResolution.x * iResolution.y);\n    \n    float t = 0.0;\n    vec3 direction = normalize(vec3(sin(pos.x * fov + cameraAngle.x), sin(pos.y * fov + cameraAngle.y), cos(pos.x * fov + cameraAngle.x) * cos(pos.y * fov + cameraAngle.y)));\n    \n    vec3 p = camera;\n    vec3 light = vec3(1.0, 1.0, 1.0);\n    for(t = 0.0; t < 100.0; t++){\n        vec2 dist = sceneDist(p);\n        if(dist.x < EPSILON * pow(distance(camera, p), 2.0)){\n            p = p + dist.x * direction;\n            vec3 normal = getNormal(p);\n            if(dist.y == 1.0){\n                color = vec4(0.0);\n            \t//color += max(pow(dot(normalize(light), normal), 2.0) * 0.5, EPSILON);\n            \tcolor += max(pow(abs(dot(reflect(normalize(light), normal), normalize(p - camera))), 20.0) * 3.0, EPSILON);\n            \tcolor += texture(iChannel0, reflect(normalize(p - camera), normal)) * 0.5;\n            }else\n                color = vec4(vec3(3.0, 20.0, 30.0) * clamp(dist.y - 2.0, 0.0, 1.0), 1.0);\n            float d = distance(p, camera) / 75.0;\n            color = mix(color, skycolor, clamp(d, 0.0, 1.0));\n            //color = vec4(normal, 1.0);\n            break;\n        }\n        dist.x = clamp(dist.x, 0.0, 1.0);\n        p = p + dist.x * direction;\n    }\n    color.a = 1.0;\n    fragColor = color;\n}","name":"Buf A","description":"","type":"buffer"}]}