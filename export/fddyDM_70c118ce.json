{"ver":"0.1","info":{"id":"fddyDM","date":"1653559591","viewed":116,"name":"Working with CubeMaps (Cube A)","username":"NicoEl","description":"Example exploring how to work with CubeMaps on ShaderToy.\nKeys:\nC: Switch Cubemap face coloring\nV: Switch View Mode (Rotating Cubemap; Cycling Cubemap Faces)\nB: Toggle MipMap animation example","likes":2,"published":1,"flags":16,"usePreview":0,"tags":["example","cubemap","cubemap","mipmaps","cubea"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* ----------------------------------------------------------\nWorking with CubeMaps - Example exploring how to work with CubeMaps on ShaderToy\n\nWritten in 2022 by Nico Ell\n\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\n---------------------------------------------------------- */\n\n#define rot(a) mat2(sin(a + vec4(0, 33, 11, 0))) // https://www.shadertoy.com/view/XlsyWX\n#define pi 3.14159265359\n#define mipLevelLimit 11.0\n\nconst int kViewMode = kV;\nconst int kLod = kB;\n\n// ----------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord / iResolution.xy;\n\n\tCubeMapInfo cbmi;\n\tif (readKey(iChannel3, kViewMode, true))\n\t{\n\t\tcbmi = createCubeMapInfo(uv, int((6.0 * fract(iTime / 12.))));\n\t}\n\telse\n\t{\n\t\tfloat fov = 1.8;\n\t\tvec3 rayDir = normalize(vec3(1. / fov, (fragCoord + fragCoord - iResolution.xy) / iResolution.y));\n\n\t\trayDir.xz *= rot(iTime / 2.);\n\t\trayDir.yz *= rot(iTime / 2.);\n\n\t\tcbmi = createCubeMapInfo(rayDir);\n        \n\t}\n    \n    //cbmi.UV = unflipUV(cbmi.UV, cbmi.FaceIdx);\n\n\tif (readKey(iChannel3, kLod, true))\n\t{\n\t\tfragColor = sampleCubeMap(iChannel0, cbmi);\n\t}\n\telse\n\t{\n\t\tfloat t = 0.5 + 0.5 * cos(iTime * 0.5);\n\t\tfloat lod = clamp(length(2. * (uv - 0.5)) - mix(0.25, 2., t), 0., 1.);\n\t\tlod += 0.5 * t;\n\t\tfragColor = sampleCubeMapLod(iChannel0, cbmi, mipLevelLimit * lod);\n\t}\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"/* ----------------------------------------------------------\nWorking with CubeMaps - Example exploring how to work with CubeMaps on ShaderToy\n\nWritten in 2022 by Nico Ell\n\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\n---------------------------------------------------------- */\n\nconst int kColor = kC;\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir)\n{\n\tvec2 uv = fragCoord / iResolution.xy;\n    \n    // Test: 'ray -> uv -> ray' returns the same result\n    int fid = dirToFaceIdx(rayDir);\n    vec2 faceUV = dirToUV(rayDir, fid);// + vec2(0.5, 0.5);\n    rayDir = faceUVToDir(fid, faceUV);\n\n    \n\tCubeMapInfo cbmi = createCubeMapInfo(rayDir, uv);\n    \n    // Both uv obtained from mainCubemap fragCoord and calculated from rayDir prodouce the same result\n    // if (uv.x > 0.5) cbmi = createCubeMapInfo(rayDir, uv);\n    // else cbmi = createCubeMapInfo(rayDir);\n    \n\tif (readKey(iChannel3, kColor, true))\n\t{\n\t\tfragColor = dbgColorFaceIdx(cbmi);\n\t}\n\telse\n\t{\n\t\tfragColor = dbgColorDir(cbmi);\n        //fragColor.xyz = 0.5 * rayDir + 0.5;\n        \n\t}\n\n\tfragColor += dbgPrintFaceIdx(iChannel2, cbmi);\n}\n","name":"Cube A","description":"","type":"cubemap"},{"inputs":[],"outputs":[],"code":"// ----------------------------------------------------------\n// BEGIN Working-with-Cubemaps\n// ----------------------------------------------------------\n\n/* ----------------------------------------------------------\nWorking with CubeMaps - Example exploring how to work with CubeMaps on ShaderToy\n\nWritten in 2022 by Nico Ell\n\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\n---------------------------------------------------------- */\n\n#define facePosX 0\n#define facePosY 1\n#define facePosZ 2\n#define faceNegX 3\n#define faceNegY 4\n#define faceNegZ 5\n\n// ----------------------------------------------------------\n// transform functions\nvec3 facePosXUVToDir(in vec2 uv)\n{\n    uv = 2. * uv - 1.;\n\treturn normalize(vec3(1., -uv.y, -uv.x));\n}\nvec3 facePosYUVToDir(in vec2 uv)\n{\n    uv = 2. * uv - 1.;\n\treturn normalize(vec3(uv.x, 1., uv.y));\n}\nvec3 facePosZUVToDir(in vec2 uv)\n{\n    uv = 2. * uv - 1.;\n\treturn normalize(vec3(uv.x, -uv.y, 1.));\n}\nvec3 faceNegXUVToDir(in vec2 uv)\n{\n\treturn vec3(-1., 1., -1.) * facePosXUVToDir(uv);\n}\nvec3 faceNegYUVToDir(in vec2 uv)\n{\n\treturn vec3(1., -1., -1.) * facePosYUVToDir(uv);\n}\nvec3 faceNegZUVToDir(in vec2 uv)\n{\n\treturn vec3(-1., 1., -1.) * facePosZUVToDir(uv);\n}\n\n\nvec3 faceUVToDir(in int faceIdx, in vec2 uv)\n{\n    //uv = unflipUV(uv, faceIdx);\n\tswitch (faceIdx)\n\t{\n\t\tcase facePosX: return facePosXUVToDir(uv);\n\t\tcase facePosY: return facePosYUVToDir(uv);\n\t\tcase facePosZ: return facePosZUVToDir(uv);\n\t\tcase faceNegX: return faceNegXUVToDir(uv);\n\t\tcase faceNegY: return faceNegYUVToDir(uv);\n\t\tcase faceNegZ: return faceNegZUVToDir(uv);\n\t\tdefault: return vec3(0.0, 0.0, 0.0);\n\t}\n}\n\nint dirToFaceIdx(in vec3 dir)\n{\n\tvec3 absDir = abs(dir);\n\tif (absDir.z >= absDir.x && absDir.z >= absDir.y)\n\t{\n\t\treturn dir.z < 0.0 ? faceNegZ : facePosZ;\n\t}\n\n\tif (absDir.y >= absDir.x)\n\t{\n\t\treturn dir.y < 0.0 ? faceNegY : facePosY;\n\t}\n\n\treturn dir.x < 0.0 ? faceNegX : facePosX;\n}\n\nvec2 dirToUV(in vec3 dir, in int faceIdx)\n{\n\tvec2 uv;\n\tvec3 absDir = abs(dir);\n\tif (absDir.z >= absDir.x && absDir.z >= absDir.y)\n\t{\n\t\tuv = dir.xy / dir.z;\n\t}\n\telse if (absDir.y >= absDir.x)\n\t{\n\t\tuv = dir.xz / dir.y;\n\t}\n\telse\n\t{\n\t\tuv = dir.yz / dir.x;\n\t}\n\t\n\tuv = 0.5 + 0.5 * uv;\n\t\n\tswitch (faceIdx)\n\t{\n\t\tcase facePosX: uv = 1. - uv.yx; break;\n\t\tcase facePosZ: uv.y = 1. - uv.y; break;\n\t\tcase faceNegX: uv = vec2(1. - uv.y, uv.x); break;\n\t\tcase faceNegY: uv = vec2(1. - uv.x, uv.y); break;\n\t\tdefault: break;\n\t}\n\n\treturn uv;\n}\n\n// ----------------------------------------------------------\n// sampling functions\nvec4 sampleCubeMap(in samplerCube cubeTextureChannel, in vec3 dir) { return texture(cubeTextureChannel, dir); }\nvec4 sampleCubeMap(in samplerCube cubeTextureChannel, in vec3 dir, in float bias) { return texture(cubeTextureChannel, dir, bias); }\nvec4 sampleCubeMapLod(in samplerCube cubeTextureChannel, in vec3 dir, in float lod) { return textureLod(cubeTextureChannel, dir, lod); }\n\n// ----------------------------------------------------------\n// debug helper functions\nvec4 dbgColorFaceIdx(in int faceIdx)\n{\n\tswitch (faceIdx)\n\t{\n\t\tcase facePosX: return vec4(1.0, 0.0, 0.0, 1.0);\n\t\tcase facePosY: return vec4(0.0, 1.0, 0.0, 1.0);\n\t\tcase facePosZ: return vec4(0.0, 0.0, 1.0, 1.0);\n\t\tcase faceNegX: return vec4(1.0, 1.0, 0.0, 1.0);\n\t\tcase faceNegY: return vec4(0.0, 1.0, 1.0, 1.0);\n\t\tcase faceNegZ: return vec4(1.0, 0.0, 1.0, 1.0);\n\t\tdefault: return vec4(0.0, 0.0, 0.0, 1.0);\n\t}\n}\n\nvec4 dbgColorDir(in vec3 dir, in vec2 uv, in int faceIdx)\n{\n\tvec4 col = dbgColorFaceIdx(faceIdx);\n\n\tconst float borderSize = 0.1;\n\tvec2 uv_b = abs((2. + borderSize) * (uv - 0.5));\n\n\tcol.xyz = max(uv_b.x, uv_b.y) > 1.0 ? col.xyz : vec3(uv, 0.);\n\n\tuv_b = abs((2. + 2. * borderSize) * (uv - 0.5));\n\n\tcol.xyz = max(uv_b.x, uv_b.y) > 1.0 ? col.xyz : (0.5 + 0.5 * dir);\n\treturn col;\n}\n\nfloat dbgPrintFaceIdx(in sampler2D fontTexture, in vec2 uv, in int faceIdx)\n{\n\tconst int fontTextureNumberOffset = 48;\n\tint i = fontTextureNumberOffset + faceIdx;\n\n\treturn texture(fontTexture, (fract(uv*1.) + vec2(i, 15 - i / 16)) / 16., -100.).w > 0.5 ? 0.0 : 1.0;\n}\n\nfloat dbgPrintFaceIdx(in sampler2D fontTexture, in vec3 dir) { int faceIdx = dirToFaceIdx(dir); return dbgPrintFaceIdx(fontTexture, dirToUV(dir, faceIdx), faceIdx); }\n\n// ----------------------------------------------------------\n// (optional) helper struct with overloaded constructing functions\n// in case you prefer to keep all your cubemap info bundled\n\nstruct CubeMapInfo\n{\n\tvec3 Dir;\n\tint FaceIdx;\n\tvec2 UV;\n};\n\nCubeMapInfo createCubeMapInfo(in vec3 dir, in vec2 uv, int faceIdx) { return CubeMapInfo(dir, faceIdx, uv); }\nCubeMapInfo createCubeMapInfo(in vec3 dir, in vec2 uv) { return CubeMapInfo(dir, dirToFaceIdx(dir), uv); }\nCubeMapInfo createCubeMapInfo(in vec3 dir) { int faceIdx = dirToFaceIdx(dir); return CubeMapInfo(dir, faceIdx, dirToUV(dir, faceIdx)); }\nCubeMapInfo createCubeMapInfo(in vec2 uv, in int faceIdx) { return CubeMapInfo(faceUVToDir(faceIdx, uv), faceIdx, uv); }\n\n// ----------------------------------------------------------\n// sampling functions\nvec4 sampleCubeMap(in samplerCube cubeTextureChannel, in CubeMapInfo cbmi) { return sampleCubeMap(cubeTextureChannel, cbmi.Dir); }\nvec4 sampleCubeMap(in samplerCube cubeTextureChannel, in CubeMapInfo cbmi, float bias) { return sampleCubeMap(cubeTextureChannel, cbmi.Dir, bias); }\nvec4 sampleCubeMapLod(in samplerCube cubeTextureChannel, in CubeMapInfo cbmi, float lod) { return sampleCubeMapLod(cubeTextureChannel, cbmi.Dir, lod); }\n\n// ----------------------------------------------------------\n// debug helper functions\n\nvec4 dbgColorFaceIdx(in CubeMapInfo cbmi) { return dbgColorFaceIdx(cbmi.FaceIdx); }\nvec4 dbgColorDir(in CubeMapInfo cbmi) { return dbgColorDir(cbmi.Dir, cbmi.UV, cbmi.FaceIdx); }\nfloat dbgPrintFaceIdx(in sampler2D fontTexture, in CubeMapInfo cbmi) { return dbgPrintFaceIdx(fontTexture, cbmi.UV, cbmi.FaceIdx); }\n\n// ----------------------------------------------------------\n// END Working-with-Cubemaps\n// ----------------------------------------------------------\n\n// Keys\nconst int kA = 65, kB = 66, kC = 67, kD = 68, kE = 69, kF = 70, kG = 71, kH = 72, kI = 73, kJ = 74, kK = 75, kL = 76, kM = 77, kN = 78, kO = 79, kP = 80, kQ = 81, kR = 82, kS = 83, kT = 84, kU = 85, kV = 86, kW = 87, kX = 88, kY = 89, kZ = 90;\nconst int k0 = 48, k1 = 49, k2 = 50, k3 = 51, k4 = 52, k5 = 53, k6 = 54, k7 = 55, k8 = 56, k9 = 57;\nconst int kSpace = 32, kLeft = 37, kUp = 38, kRight = 39, kDown = 40;\n\nbool readKey(sampler2D textureChannel, int key, bool toggle)\n{\n\tfloat keyVal = texture(textureChannel, vec2((float(key) + .5) / 256.0, toggle ? .75 : .25)).x;\n\treturn (keyVal > .5) ? true : false;\n}\n","name":"Common","description":"","type":"common"}]}