{"ver":"0.1","info":{"id":"3d3BWj","date":"1607867968","viewed":177,"name":"One more Hourglass","username":"savegor","description":"Non realistic sand. Use mouse to rotate.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["particles","hourglass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// based on https://www.shadertoy.com/view/ts3czH\n\nvec2 to_polar(vec2 pos) {\n\tvec2 center = iResolution.xy * 0.5;\n    \n    vec2 npos = pos - center;\n    \n    return vec2(length(npos), atan(npos.x, npos.y));\n}\n\nvec2 to_decart(vec2 polar) {\n    vec2 center = iResolution.xy * 0.5;\n\treturn center + vec2(polar.x * cos(polar.y), polar.x * sin(polar.y));   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //rescale\n    vec2 screen_center = iResolution.xy * 0.5;\n    fragCoord -= screen_center;\n    fragCoord *= 1.1;\n    fragCoord += screen_center;\n    \n    // rotation angle from mouse position\n    float zero_mouse = float((abs(iMouse.x) + abs(iMouse.y)) > 0.0);\n    vec2 mdiff = iMouse.xy - iResolution.xy * 0.5;\n    mdiff = mix(vec2(0.0, 1.0), mdiff, zero_mouse);\tfloat alpha = atan(mdiff.y, mdiff.x);\t\n    \n    vec2 p_fc = to_polar(fragCoord);\n    p_fc.y += alpha;\n    \n    vec2 fc_rot = to_decart(p_fc);\n    float dist = 1.0e3;\n\n    for(float i = -2.0; i < 2.01; i += 1.0) {\n        for(float j = -2.0; j < 2.01; j += 1.0) {\n            vec2 crd = fragCoord + vec2(i, j);\n            \n            vec2 p_crd = to_polar(crd);\n            p_crd.y += alpha;\n\n            vec2 crd_rot = to_decart(p_crd);\n\n            vec4 cell_state = texture(iChannel0, SCALE * crd_rot / iResolution.xy);\n            vec2 pos = cell_state.xy / SCALE;\n    \t\tfloat cur_dist = distance(fc_rot, pos);\n            \n            if(cur_dist < dist) {\n                dist = cur_dist;\n            }\n   \n        }\n    }\n    \n    float edge_c = edge_center(fc_rot, iResolution);\n    vec2 shift = normalize(fc_rot - iResolution.xy * 0.5) * edge_c;\n    \n    shift += 10.0 *  normalize(fc_rot - iResolution.xy * 0.5) * distortion_hourglass(fc_rot, iResolution);\n\n    //scene from cubemap\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    float eyeAngle = 1.0e-2 * iTime;\n    float in_circle = float(edge_c > 0.0);\n    eyeAngle += (1.0 - in_circle) * dist * 0.1;\n\n  \tvec3 eye = vec3(20.0 * vec2(cos(eyeAngle), sin(eyeAngle)), 1.0);\n    vec3 rayDirection1 = -normalize(eye);\n    vec3 rayDirection2 = cross(vec3(0.0, 0.0, 1.0), rayDirection1);\n    vec3 rayDirection3 = cross(rayDirection1, rayDirection2);\n\n    uv += shift * 0.05;\n    \n    \n    vec3 rayDirection = normalize(rayDirection1 + uv.x * rayDirection2 + uv.y * rayDirection3);\n\n    vec4 background = texture(iChannel1, rayDirection.xzy);\n    \n    // sand + bg\n    float sand = float(dist < (1.2 / SCALE));\n    \n    vec4 sand_color = texture(iChannel2, rayDirection.xyz);\n    \n    fragColor = background * in_circle +  sand * sand_color + 10.0 *  vec4(hourglass_contour(fc_rot, iResolution));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float SCALE = 1.0;\nconst float COL_SQR_DIST = 2.0;\nconst float COL_FORCE = 0.16;\n\nconst float FRICTION = 0.92;\nconst float GRAVITY = 0.086;\nconst float COLLISION = 0.66;\nconst float EDGE_WIDTH = 1.0;\n\nconst vec2 SHIFTS[8] = vec2[8](\n    vec2(-1, -1),\n    vec2(-1,  0),\n    vec2(-1,  1),\n    vec2(0,  -1),\n    vec2(0,   1),\n    vec2(1,  -1),\n    vec2(1,   0),\n    vec2(1,   1)\n);\n\n\nfloat distortion_hourglass(vec2 coord, vec3 iResolution) {\n    // hourglass     \n    float rad = SCALE * iResolution.y * 0.5;\n\t\n    vec2 top_center = vec2(SCALE * iResolution.x * 0.5, SCALE * iResolution.y);\n    vec2 bot_center = vec2(SCALE * iResolution.x * 0.5, 0.0);\n\n\t\n    vec2 rescale = vec2(1.7, 1.0);\n    \n    float dist_top = distance(coord * rescale, top_center * rescale);\n    float dist_bot = distance(coord * rescale, bot_center * rescale);\n    \n    float inside_hg = float(dist_top < rad || dist_bot < rad);\n    \n    \n    float distortion_top = 1.0 / pow(rad - dist_top, 2.0);\n    float distortion_bot = 1.0 / pow(rad - dist_bot, 2.0);\n    \n    float inside_circle = float(distance(SCALE * iResolution.xy * 0.5, coord) < rad);\n    \n    dist_top = clamp(dist_top, 0.0, 2.);\n    dist_bot = clamp(dist_bot, 0.0, 2.);\n   \n    \n\treturn sin(min(dist_top, dist_bot)) * inside_circle * inside_hg;    \n}\n\nfloat hourglass_contour(vec2 coord, vec3 iResolution) {   \n    // hourglass     \n    float rad = SCALE * iResolution.y * 0.5;\n\t\n    vec2 top_center = vec2(SCALE * iResolution.x * 0.5, SCALE * iResolution.y);\n    vec2 bot_center = vec2(SCALE * iResolution.x * 0.5, 0.0);\n\n\t\n    vec2 rescale = vec2(1.7, 1.0);\n    \n    float dist_top = distance(coord * rescale, top_center * rescale);\n    float dist_bot = distance(coord * rescale, bot_center * rescale);\n    \n    float inside_hg = float(dist_top < rad || dist_bot < rad);\n    \n    float dist_cent = distance(SCALE * iResolution.xy * 0.5, coord);\n    \n    float inside_circle = float(dist_cent < rad);\n\n    float dist = min(dist_top, dist_bot);\n            \n    float edge = EDGE_WIDTH * (   1.0 / pow(rad - dist_cent, 2.0) \n                                + 1.0 / pow(rad - dist, 2.0));\n                                \n    float neck = float( abs(coord.x - iResolution.x * 0.5) < iResolution.x * 0.009 && \n                        abs(coord.y - iResolution.y * 0.5) < iResolution.y * 0.02);  \n\n    return  edge * inside_circle * inside_hg;    \n}\n\nfloat edge_center(vec2 coord, vec3 iResolution) {\n    // hourglass     \n    float rad = SCALE * iResolution.y * 0.5;\n    \n    float dist_center = max(distance(SCALE * iResolution.xy * 0.5, coord) - rad, 0.0);\n    \n    \n\treturn dist_center;    \n}\n\nbool in_hourglass(vec2 coord, vec3 iResolution) {\n    // hourglass     \n    float rad = SCALE * iResolution.y * 0.5;\n\t\n    vec2 top_center = vec2(SCALE * iResolution.x * 0.5, SCALE * iResolution.y);\n    vec2 bot_center = vec2(SCALE * iResolution.x * 0.5, 0.0);\n\n\t\n    vec2 rescale = vec2(1.7, 1.0);\n    \n    float dist_top = distance(coord * rescale, top_center * rescale);\n    float dist_bot = distance(coord * rescale, bot_center * rescale);\n    float dist_center = distance(SCALE * iResolution.xy * 0.5, coord);\n    \n    // neck\n\tbool neck = abs(coord.x - iResolution.x * 0.5) < iResolution.x * 0.01;  \n    \n\treturn dist_center < rad && (dist_top < rad || dist_bot < rad || neck);    \n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat noise(vec2 st) {\n    return fract(sin(st.x + iTime) * st.y * iTime);\n}\n\nbool has_particle(vec4 cell_state, vec2 cell_pos) {\n    // cell state: xyzw -> [x, y, vx, vy]\n    // cell_pos:   xy   -> x,y in {N * 0.5} where N is integer\n    vec2 diff = abs(cell_state.xy - cell_pos);\n\treturn diff.x < 0.5 && diff.y < 0.5;    \n}\n\nvec2 calc_accel(vec4 next_state, vec2 cell) {\n    vec2 cell_uv = cell / iResolution.xy;\n    vec4 cell_state = texture(iChannel0, cell_uv);\n    \n    float particle_in_cell = float(has_particle(cell_state, cell));\n    \n    vec2 diff = next_state.xy - cell_state.xy;\n    \n    float sqr_dist = dot(diff, diff);\n        \n    float collision = COL_FORCE * float(sqr_dist < COL_SQR_DIST);\n    \n    return particle_in_cell * collision * (COL_SQR_DIST - sqr_dist) * normalize(diff); \n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // rotation angle\n    float zero_mouse = float((abs(iMouse.x) + abs(iMouse.y)) > 0.0);\n    vec2 mdiff = iMouse.xy - iResolution.xy * 0.5;\n    mdiff = mix(vec2(0.0, 1.0), mdiff, zero_mouse);\n    \n\tfloat alpha = atan(mdiff.y, mdiff.x);\n\t\n    \n    vec2 gravity_dir = vec2(cos(alpha), sin(alpha));\n        \n        \n    vec2 cur_cell = fragCoord;\n\n    if(iFrame == 0) {\n        if(in_hourglass(fragCoord, iResolution)) {\n            vec2 start_velocity = vec2(noise(fragCoord), noise(fragCoord.yx));\n            if(length(start_velocity) > 1.0) {\n                start_velocity = normalize(start_velocity);    \n            }\n\n            // 0.5 pixel per frame is the max value of the each particle velocity\n            // so the relative speed is not exceed 1 pixel per frame\n            start_velocity *= 0.5;\n\n            fragColor = vec4(fragCoord.xy, start_velocity) * float(fragCoord.y > 0.5 * iResolution.y);\n        }\n        \n    }\n    else {\n        \n        vec4 cur_state = texture(iChannel0, fragCoord / iResolution.xy);\n        vec4 next_state = vec4(0.0, 0.0, 0.0, 0.0);\n\n        \n        if(iFrame % 2 == 0) {\n\t\t\t\n            if(has_particle(cur_state, fragCoord)) {\n                // COLLISION\n                // calculate the repulsion from particles\n                // in the outer boundary:\n                //\n                // * * * * *\n                // *       *\n                // *   O < O\n                // *   ^   *\n                // * * O * *\n                // \n                vec2 accel = vec2(0.0);\n                \n                for(float i = -2.0; i < 2.01; i += 1.0) {\n                    for(float j = -2.0; j < 2.01; j += 1.0) {\n                        if(abs(i) > 0.1  || abs(j) > 0.1) {\n                        \taccel += calc_accel(cur_state, fragCoord + vec2(i, j));\n                        }\n                    }\n                }\n\t\t\t\t\n\n                cur_state.zw += COLLISION * accel;\n                \n                // GRAVITY\n                \n                cur_state.zw -= GRAVITY * gravity_dir;\n                \n                // FRICTION\n                cur_state.zw *= FRICTION;\n\n               \n                // velocity normalization\n                float velocity = length(cur_state.zw);\n                if(velocity > 1.0) {\n                \tcur_state.zw = cur_state.zw / velocity;   \n                }\n                \n                \n                fragColor = cur_state;\n            }\n        }\n        else {\n            // MOTION\n            // simulation the particle propagation from the \n            // neighbouring cells into current one:\n            //\n            //  ____________________\n            // |      |      |      |\n            // |      |      |      |\n            // |      |      |      |\n            // |______|______|______|\n            // |      |      |      |\n            // |  O---|->    |      |\n            // |      |      |      |\n            // |______|______|______|\n            // |      |      |      | \n            // |      |      |      |\n            // |      |      |      |\n            // |______|______|______|\n            //\n\n            \n            // 1) cur state is empty\n            if(!has_particle(cur_state, cur_cell) && in_hourglass(cur_cell, iResolution)) {\n                \n\t\t\t\t\n                float min_dist = 1.0e6;\n                \n                int count = 0;\n                \n                for(int i = 0; i < 8; ++i) {\n                    vec2 nb_cell = cur_cell + SHIFTS[i];\n\n                    vec4 nb_state = texture(iChannel0, nb_cell / iResolution.xy);\n\t\t\t\t\t\n                    // position of particle moved from the neighboring cell\n                    vec2 nb_pos_after_move = nb_state.xy + nb_state.zw;\n\t\t\t\t\t\n                    // diff from the current cell to the neighbouring cell particle\n                    vec2 nb_particle_diff = abs(cur_cell - nb_pos_after_move);\n                    float dist_to_particle = length(nb_particle_diff);\n\n                    if(nb_particle_diff.x < 0.5 &&\n                       nb_particle_diff.y < 0.5 ) {\n                       //&& dist_to_particle < min_dist) {\n                        count++;\n                        min_dist = dist_to_particle;\n                        next_state.xy = nb_pos_after_move; // coord\n                        next_state.zw = nb_state.zw;    // velocity\n                    }\n                }\n                \n                float can_move = float(count == 1);\n                \n                fragColor = next_state * can_move;\n            }\n            //  cur state is not empty\n            else {\n                // if the current particle move away from the \n                // current cell we need to additional check\n                // that this particle is the nearest to the next one\n                \n                vec2 target_pos = cur_state.xy + cur_state.zw;\n                vec2 target_cell = floor(target_pos) + vec2(0.5, 0.5);\n                \n                float cur_particle_dist = distance(target_cell, target_pos);\n                \n                // if we the particle in the current cell\n                if(distance(target_cell, cur_cell) < 0.1) {\n                    next_state.xy = target_pos;\n                    next_state.zw = 0.9 * cur_state.zw;\n                }\n                //try to move to the next cell\n                else {\n                    bool can_move = true;\n                    \n                    vec2 cell_shift = cur_cell - target_cell;\n                    \n                    vec4 target_state = texture(iChannel0, target_cell / iResolution.xy);\n                    \n                    int count = 0;\n                    \n                    for(int i = 0; i < 8; ++i) {\n                        vec2 nb_cell = target_cell + SHIFTS[i];\n                        \n                        vec4 nb_state = texture(iChannel0, nb_cell / iResolution.xy);\n\n                        vec2 nb_pos_after_move = nb_state.xy + nb_state.zw;\n\t\t\t\t\t\t\n                        // dist to the neighboring partcle from the \n                        // target cell\n                        float dist_to_nb_particle = distance(target_cell, nb_pos_after_move);\n\t\t\t\t\t\t\n                         vec2 nb_particle_diff = abs(target_cell - nb_pos_after_move);\n\n                        \n                        if(nb_particle_diff.x < 0.5 &&\n                           nb_particle_diff.y < 0.5 ) {\n                            count++;\n                        }       \n\n                    }\n                    \n                    if(count != 1 || has_particle(target_state, target_cell) || !in_hourglass(target_cell, iResolution)) {\n                        next_state = cur_state;\n                        next_state.zw += 0.01 *  vec2(noise(fragCoord.xy), noise(fragCoord.yx));\n                    }\n                }\n                \n                fragColor = next_state;\n\n            }\n            \n        }\n    }\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nfloat noise(vec2 st) {\n    return fract(sin(st.x + iTime) * st.y * iTime);\n}\n\nbool has_particle(vec4 cell_state, vec2 cell_pos) {\n    // cell state: xyzw -> [x, y, vx, vy]\n    // cell_pos:   xy   -> x,y in {N * 0.5} where N is integer\n    vec2 diff = abs(cell_state.xy - cell_pos);\n\treturn diff.x < 0.5 && diff.y < 0.5;    \n}\n\nvec2 calc_accel(vec4 next_state, vec2 cell) {\n    vec2 cell_uv = cell / iResolution.xy;\n    vec4 cell_state = texture(iChannel0, cell_uv);\n    \n    float particle_in_cell = float(has_particle(cell_state, cell));\n    \n    vec2 diff = next_state.xy - cell_state.xy;\n    \n    float sqr_dist = dot(diff, diff);\n        \n    float collision = COL_FORCE * float(sqr_dist < COL_SQR_DIST);\n    \n    return particle_in_cell * collision * (COL_SQR_DIST - sqr_dist) * normalize(diff); \n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // rotation angle\n    float zero_mouse = float((abs(iMouse.x) + abs(iMouse.y)) > 0.0);\n    vec2 mdiff = iMouse.xy - iResolution.xy * 0.5;\n    mdiff = mix(vec2(0.0, 1.0), mdiff, zero_mouse);    \n\tfloat alpha = atan(mdiff.y, mdiff.x);\n\t\n    \n    vec2 gravity_dir = vec2(cos(alpha), sin(alpha));\n        \n        \n    vec2 cur_cell = fragCoord;\n\n        \n    vec4 cur_state = texture(iChannel0, fragCoord / iResolution.xy);\n    vec4 next_state = vec4(0.0, 0.0, 0.0, 0.0);\n\n\n    if(iFrame % 2 == 0) {\n\n        if(has_particle(cur_state, fragCoord)) {\n            // COLLISION\n            // calculate the repulsion from particles\n            // in the outer boundary:\n            //\n            // * * * * *\n            // *       *\n            // *   O < O\n            // *   ^   *\n            // * * O * *\n            // \n            vec2 accel = vec2(0.0);\n\n            for(float i = -2.0; i < 2.01; i += 1.0) {\n                for(float j = -2.0; j < 2.01; j += 1.0) {\n                    if(abs(i) > 0.1  || abs(j) > 0.1) {\n                        accel += calc_accel(cur_state, fragCoord + vec2(i, j));\n                    }\n                }\n            }\n\n\n             cur_state.zw += COLLISION * accel;\n\n            // GRAVITY\n\n            cur_state.zw -= GRAVITY * gravity_dir;\n\n            // FRICTION\n\n            cur_state.zw *= FRICTION;\n\n            // velocity normalization\n            float velocity = length(cur_state.zw);\n            if(velocity > 1.0) {\n                cur_state.zw = cur_state.zw / velocity * 1.0;   \n            }\n\n\n            fragColor = cur_state;\n        }\n    }\n    else {\n        // MOTION\n        // simulation the particle propagation from the \n        // neighbouring cells into current one:\n        //\n        //  ____________________\n        // |      |      |      |\n        // |      |      |      |\n        // |      |      |      |\n        // |______|______|______|\n        // |      |      |      |\n        // |  O---|->    |      |\n        // |      |      |      |\n        // |______|______|______|\n        // |      |      |      | \n        // |      |      |      |\n        // |      |      |      |\n        // |______|______|______|\n        //\n\n\n        // 1) cur state is empty\n        if(!has_particle(cur_state, cur_cell) && in_hourglass(cur_cell, iResolution)) {\n\n\n            float min_dist = 1.0e6;\n\n            int count = 0;\n\n            for(int i = 0; i < 8; ++i) {\n                vec2 nb_cell = cur_cell + SHIFTS[i];\n\n                vec4 nb_state = texture(iChannel0, nb_cell / iResolution.xy);\n\n                // position of particle moved from the neighboring cell\n                vec2 nb_pos_after_move = nb_state.xy + nb_state.zw;\n\n                // diff from the current cell to the neighbouring cell particle\n                vec2 nb_particle_diff = abs(cur_cell - nb_pos_after_move);\n                float dist_to_particle = length(nb_particle_diff);\n\n                if(nb_particle_diff.x < 0.5 &&\n                   nb_particle_diff.y < 0.5 ) {\n                    //&& dist_to_particle < min_dist) {\n                    count++;\n                    min_dist = dist_to_particle;\n                    next_state.xy = nb_pos_after_move; // coord\n                    next_state.zw = nb_state.zw;    // velocity\n                }\n            }\n\n            float can_move = float(count == 1);\n\n            fragColor = next_state * can_move;\n            /*if(count == 1) {\nfragColor = next_state;\n}\nelse {\nfragColor = vec4(0.0, 0.0, 0.0, 0.0);\n}\n*/\n        }\n        //  cur state is not empty\n        else {\n            // if the current particle move away from the \n            // current cell we need to additional check\n            // that this particle is the nearest to the next one\n\n            vec2 target_pos = cur_state.xy + cur_state.zw;\n            vec2 target_cell = floor(target_pos) + vec2(0.5, 0.5);\n\n            float cur_particle_dist = distance(target_cell, target_pos);\n\n            // if we the particle in the current cell\n            if(distance(target_cell, cur_cell) < 0.1) {\n                next_state.xy = target_pos;\n                next_state.zw = cur_state.zw;\n            }\n            //try to move to the next cell\n            else {\n                bool can_move = true;\n\n                vec2 cell_shift = cur_cell - target_cell;\n\n                vec4 target_state = texture(iChannel0, target_cell / iResolution.xy);\n\n                int count = 0;\n\n                for(int i = 0; i < 8; ++i) {\n                    vec2 nb_cell = target_cell + SHIFTS[i];\n\n                    vec4 nb_state = texture(iChannel0, nb_cell / iResolution.xy);\n\n                    vec2 nb_pos_after_move = nb_state.xy + nb_state.zw;\n\n                    // dist to the neighboring partcle from the \n                    // target cell\n                    float dist_to_nb_particle = distance(target_cell, nb_pos_after_move);\n\n                    vec2 nb_particle_diff = abs(target_cell - nb_pos_after_move);\n\n\n                    if(nb_particle_diff.x < 0.5 &&\n                       nb_particle_diff.y < 0.5 ) {\n                        count++;\n                    }       \n\n                }\n\n                if(count != 1 || has_particle(target_state, target_cell) || !in_hourglass(target_cell, iResolution)) {\n                    next_state = cur_state;\n                    next_state.zw += 0.01 *  vec2(noise(fragCoord.xy), noise(fragCoord.yx));\n                }\n            }\n\n            fragColor = next_state;\n\n        }\n\n    }\n\n\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\nfloat noise(vec2 st) {\n    return fract(sin(st.x + iTime) * st.y * iTime);\n}\n\nbool has_particle(vec4 cell_state, vec2 cell_pos) {\n    // cell state: xyzw -> [x, y, vx, vy]\n    // cell_pos:   xy   -> x,y in {N * 0.5} where N is integer\n    vec2 diff = abs(cell_state.xy - cell_pos);\n\treturn diff.x < 0.5 && diff.y < 0.5;    \n}\n\nvec2 calc_accel(vec4 next_state, vec2 cell) {\n    vec2 cell_uv = cell / iResolution.xy;\n    vec4 cell_state = texture(iChannel0, cell_uv);\n    \n    float particle_in_cell = float(has_particle(cell_state, cell));\n    \n    vec2 diff = next_state.xy - cell_state.xy;\n    \n    float sqr_dist = dot(diff, diff);\n        \n    float collision = COL_FORCE * float(sqr_dist < COL_SQR_DIST);\n    \n    return particle_in_cell * collision * (COL_SQR_DIST - sqr_dist) * normalize(diff); \n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // rotation angle\n    float zero_mouse = float((abs(iMouse.x) + abs(iMouse.y)) > 0.0);\n    vec2 mdiff = iMouse.xy - iResolution.xy * 0.5;\n    mdiff = mix(vec2(0.0, 1.0), mdiff, zero_mouse);    \n\tfloat alpha = atan(mdiff.y, mdiff.x);\n\t\n    \n    vec2 gravity_dir = vec2(cos(alpha), sin(alpha));\n        \n        \n    vec2 cur_cell = fragCoord;\n\n        \n    vec4 cur_state = texture(iChannel0, fragCoord / iResolution.xy);\n    vec4 next_state = vec4(0.0, 0.0, 0.0, 0.0);\n\n\n    if(iFrame % 2 == 0) {\n\n        if(has_particle(cur_state, fragCoord)) {\n            // COLLISION\n            // calculate the repulsion from particles\n            // in the outer boundary:\n            //\n            // * * * * *\n            // *       *\n            // *   O < O\n            // *   ^   *\n            // * * O * *\n            // \n            vec2 accel = vec2(0.0);\n\n            for(float i = -2.0; i < 2.01; i += 1.0) {\n                for(float j = -2.0; j < 2.01; j += 1.0) {\n                    if(abs(i) > 0.1  || abs(j) > 0.1) {\n                        accel += calc_accel(cur_state, fragCoord + vec2(i, j));\n                    }\n                }\n            }\n\n\n            cur_state.zw += COLLISION * accel;\n\n            // GRAVITY\n\n            cur_state.zw -= GRAVITY * gravity_dir;\n\n            // FRICTION\n\n            cur_state.zw *= FRICTION;\n\n            // velocity normalization\n            float velocity = length(cur_state.zw);\n            if(velocity > 1.0) {\n                cur_state.zw = cur_state.zw / velocity * 1.0;   \n            }\n\n\n            fragColor = cur_state;\n        }\n    }\n    else {\n        // MOTION\n        // simulation the particle propagation from the \n        // neighbouring cells into current one:\n        //\n        //  ____________________\n        // |      |      |      |\n        // |      |      |      |\n        // |      |      |      |\n        // |______|______|______|\n        // |      |      |      |\n        // |  O---|->    |      |\n        // |      |      |      |\n        // |______|______|______|\n        // |      |      |      | \n        // |      |      |      |\n        // |      |      |      |\n        // |______|______|______|\n        //\n\n\n        // 1) cur state is empty\n        if(!has_particle(cur_state, cur_cell) && in_hourglass(cur_cell, iResolution)) {\n\n\n            float min_dist = 1.0e6;\n\n            int count = 0;\n\n            for(int i = 0; i < 8; ++i) {\n                vec2 nb_cell = cur_cell + SHIFTS[i];\n\n                vec4 nb_state = texture(iChannel0, nb_cell / iResolution.xy);\n\n                // position of particle moved from the neighboring cell\n                vec2 nb_pos_after_move = nb_state.xy + nb_state.zw;\n\n                // diff from the current cell to the neighbouring cell particle\n                vec2 nb_particle_diff = abs(cur_cell - nb_pos_after_move);\n                float dist_to_particle = length(nb_particle_diff);\n\n                if(nb_particle_diff.x < 0.5 &&\n                   nb_particle_diff.y < 0.5 ) {\n                    //&& dist_to_particle < min_dist) {\n                    count++;\n                    min_dist = dist_to_particle;\n                    next_state.xy = nb_pos_after_move; // coord\n                    next_state.zw = nb_state.zw;    // velocity\n                }\n            }\n\n            float can_move = float(count == 1);\n\n            fragColor = next_state * can_move;\n            /*if(count == 1) {\nfragColor = next_state;\n}\nelse {\nfragColor = vec4(0.0, 0.0, 0.0, 0.0);\n}\n*/\n        }\n        //  cur state is not empty\n        else {\n            // if the current particle move away from the \n            // current cell we need to additional check\n            // that this particle is the nearest to the next one\n\n            vec2 target_pos = cur_state.xy + cur_state.zw;\n            vec2 target_cell = floor(target_pos) + vec2(0.5, 0.5);\n\n            float cur_particle_dist = distance(target_cell, target_pos);\n\n            // if we the particle in the current cell\n            if(distance(target_cell, cur_cell) < 0.1) {\n                next_state.xy = target_pos;\n                next_state.zw = cur_state.zw;\n            }\n            //try to move to the next cell\n            else {\n                bool can_move = true;\n\n                vec2 cell_shift = cur_cell - target_cell;\n\n                vec4 target_state = texture(iChannel0, target_cell / iResolution.xy);\n\n                int count = 0;\n\n                for(int i = 0; i < 8; ++i) {\n                    vec2 nb_cell = target_cell + SHIFTS[i];\n\n                    vec4 nb_state = texture(iChannel0, nb_cell / iResolution.xy);\n\n                    vec2 nb_pos_after_move = nb_state.xy + nb_state.zw;\n\n                    // dist to the neighboring partcle from the \n                    // target cell\n                    float dist_to_nb_particle = distance(target_cell, nb_pos_after_move);\n\n                    vec2 nb_particle_diff = abs(target_cell - nb_pos_after_move);\n\n\n                    if(nb_particle_diff.x < 0.5 &&\n                       nb_particle_diff.y < 0.5 ) {\n                        count++;\n                    }       \n\n                }\n\n                if(count != 1 || has_particle(target_state, target_cell) || !in_hourglass(target_cell, iResolution)) {\n                    next_state = cur_state;\n                    next_state.zw += 0.01 *  vec2(noise(fragCoord.xy), noise(fragCoord.yx));\n                }\n            }\n\n            fragColor = next_state;\n\n        }\n\n    }\n\n\n}","name":"Buffer C","description":"","type":"buffer"}]}