{"ver":"0.1","info":{"id":"fltyR8","date":"1659263417","viewed":449,"name":"Wire Lenses","username":"panna_pudi","description":"Why it runs at 69 fps...","likes":26,"published":1,"flags":32,"usePreview":1,"tags":["3d","wireframe","sphere","bloom","reflect","refract","refractive","rhomb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Wire Lenses by Pudi\n// Email: k.a.komissar@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Thanks to Flopine, provod, YX, NuSan, slerpy, wwrighter, Shane,\n// BigWings, FabriceNeyret, iq, and Blackle for sharing their knowledge\n\n#define colorRange 24.0\n\nvec3 jodieReinhardTonemap(vec3 c){\n    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));\n    vec3 tc = c / (c + 1.0);\n\n    return mix(c / (l + 1.0), tc, tc);\n}\n\nvec3 bloomTile(float lod, vec2 offset, vec2 uv){\n    return texture(iChannel1, uv * exp2(-lod) + offset).rgb;\n}\n\nvec3 getBloom(vec2 uv){\n    vec3 blur = vec3(0.0);\n\n    blur = pow(bloomTile(2., vec2(0.0,0.0), uv),vec3(2.2))       \t   \t+ blur;\n    blur = pow(bloomTile(3., vec2(0.3,0.0), uv),vec3(2.2)) * 1.3        + blur;\n    blur = pow(bloomTile(4., vec2(0.0,0.3), uv),vec3(2.2)) * 1.6        + blur;\n    blur = pow(bloomTile(5., vec2(0.1,0.3), uv),vec3(2.2)) * 1.9 \t   \t+ blur;\n    blur = pow(bloomTile(6., vec2(0.2,0.3), uv),vec3(2.2)) * 2.2 \t   \t+ blur;\n\n    return blur * colorRange;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = texture(iChannel0, uv).rgb;\n    \n    vec3 bloom = getBloom(uv) * 0.0025;\n    bloom = jodieReinhardTonemap(bloom);\n    color += bloom;\n    \n    color = pow(color, vec3(1. / 2.2));\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = acos(-1.);\nconst float TAU = 2. * PI;\n\nconst float PERIOD = 15. * 2.;\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nconst vec3 CRAYOLA = vec3(254, 215, 102) / 255.;\nconst vec3 VIOLET = vec3(61, 49, 74) / 255.;\nconst vec3 RED = vec3(274, 15, 46) / 255.;\nconst vec3 BLUE = vec3(37, 142, 166) / 255.;\nconst vec3 WHITE = vec3(239, 241, 243) / 255.;\n\nvec2 _min(vec2 a, vec2 b) {\n    if (a.x < b.x) return a;\n    return b;\n}\n\nfloat hash11(float p){\n    return fract(sin(p * 78.233) * 43758.5453);\n}\n\nfloat hash31(vec3 p) {\n    float n = sin(dot(p, vec3(7, 157, 113)));\n    return fract(262144. * n);\n}\n\nvec3 hash33(vec3 p) {\n    p = fract(p * vec3(443.8975, 397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz + 19.27);\n    return fract(p.xzy * p.yxz);\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvec2 intersect_sphere(in vec3 ro, in vec3 rd, in vec3 ce, float ra) {\n    vec3 oc = ro - ce;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - ra * ra;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-h, h) - b;\n}\n\nvec3 erot(vec3 p, vec3 ax, float a) {\n    return mix(dot(ax, p) * ax, p, cos(a)) + cross(ax, p) * sin(a);\n}\n\nfloat smooth_floor(float x, float c) {\n    float a = fract(x);\n    float b = floor(x);\n    return ((pow(a, c) - pow(1. - a, c)) / 2.) + b;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sd_octahedron(vec3 p, float s) {\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n    vec3 q;\n         if (3.0 * p.x < m ) q = p.xyz;\n    else if (3.0 * p.y < m ) q = p.yzx;\n    else if (2.0 * p.z < m ) q = p.zxy;\n    else\n        return m * 0.57735027;\n\n    float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\n    return length(vec3(q.x, q.y - s + k, q.z - k));\n}\n\n// https://jbaker.graphics/writings/DEC.html\nfloat deko(vec3 p){\n    float radius = 1.;\n    const float q = 2.61803398875;  // Golden Ratio + 1 = (sqrt(5)+3)/2;\n    const vec3 n1 = normalize(vec3(q, 1,0));\n    const vec3 n2 = vec3(0.57735026919);  // = sqrt(3)/3);\n\n    p = abs(p / radius);\n    float a = dot(p, n1.xyz);\n    float b = dot(p, n1.zxy);\n    float c = dot(p, n1.yzx);\n    float d = dot(p, n2) - n1.x;\n    return max(max(max(a, b), c) - n1.x, d) * radius;\n}\n\nfloat sd_hollow_sphere(vec3 p, float r, float h, float t) {\n    float w = sqrt(r * r - h * h);\n\n    vec2 q = vec2(length(p.xz), p.y);\n    float d = (h * q.x < w * q.y) ? length(q - vec2(w, h)) \n                                  : abs(length(q) - r);\n    return d - t;\n}\n\nfloat loop_noise(float x, float loopLen) {\n    x = mod(x, loopLen);\n\n    float i = floor(x);\n    float f = fract(x);\n    float u =\n        f * f * f * (f * (f * 6. - 15.) + 10.);\n\n    return mix(hash11(i), hash11(mod(i + 1.0, loopLen)), u);\n}\n\nmat3 get_cam(vec3 eye, vec3 target) {\n    vec3 zaxis = normalize(target - eye);\n    vec3 xaxis = normalize(cross(vec3(0., 1., 0.), zaxis));\n    vec3 yaxis = cross(zaxis, xaxis);\n    return mat3(xaxis, yaxis, zaxis);\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float LENS_WIDTH = 0.005;\nfloat lenses(vec3 p) {\n    float time = iTime;\n    float t = smooth_floor(time, 2.);\n    vec3 q = erot(p, normalize(vec3(sin(-time / 2.), sin(time), cos(0.3 * time))), -0.6 * time);\n    float lens = sd_hollow_sphere(q, 0.9, -0.4, LENS_WIDTH);\n    q = erot(p, normalize(vec3(sin(time / 2.), sin(time / 3.), 1.)), -2. * t);\n    lens = min(lens, sd_hollow_sphere(q, 1., -0.5, LENS_WIDTH));\n    return lens;\n}\n\nfloat rhomb(vec3 p) {\n    p.xz *= rot(0.2);\n    float time = iTime;\n    vec3 q = erot(p, normalize(vec3(sin(time / 2.), 1., cos(time / 3.))), time);\n\n    vec3 pp = p;\n    float id = floor(pp.y * 20.);\n    float cell = fract(pp.y);\n    float rand = hash11(id) * 2. - 1.;\n    /* pp.xz *= rot(time + sin(id / 10. + (sin(time)))); */\n    pp.xz *= rot(6. * loop_noise(id / 30. + ((time)), 25.));\n    /* pp.xz *= rot(4. * sin(id / 20. + time)); */\n    \n    float shape_type = step(PERIOD / 2., mod(iTime, PERIOD));\n    float d = shape_type > 0.5 ? sd_octahedron(pp * vec3(1., .6, 1.), 0.4)\n                               : deko(q / 0.4) * 0.4;\n    return d - 0.0;\n}\n\nvec2 map(vec3 p) {\n    vec2 shape = vec2(rhomb(p), 0.);\n    vec2 lens = vec2(lenses(p), 1.);\n    return _min(lens, shape);\n}\n\nvec3 get_norm(vec3 p) {\n    mat3 k = mat3(p, p, p) - mat3(0.05);\n    return normalize(vec3(map(p).x) -\n                     vec3(map(k[0]).x, map(k[1]).x, map(k[2]).x));\n}\n\nvec3 get_rhomb_norm(vec3 p, float eps) {\n    mat3 k = mat3(p, p, p) - mat3(eps);\n    return normalize(vec3(rhomb(p)) -\n                     vec3(rhomb(k[0]), rhomb(k[1]), rhomb(k[2])));\n}\n\nvec3 get_lens_norm(vec3 p) {\n    mat3 k = mat3(p, p, p) - mat3(0.005);\n    return normalize(vec3(lenses(p)) -\n                     vec3(lenses(k[0]), lenses(k[1]), lenses(k[2])));\n}\n\nvec3 trace_scene(in vec3 ro, in vec3 rd, in float tmin, in float tmax) {\n    float t = tmin; float eps = .1 / iResolution.y;\n    for (int i = 0; i < 100; i++) {\n        vec3 pos = ro + rd * t;\n        vec2 d = map(pos);\n        if (d.x < t * eps) return vec3(t, 1., d.y);;\n        t += d.x;\n        if (t > tmax) break;\n    }\n    return vec3(t, -1., -1.);\n}\n\nvec2 trace_rhomb(in vec3 ro, in vec3 rd, in float tmin, in float tmax) {\n    float t = tmin; float eps = 1. / iResolution.y;\n    for (int i = 0; i < 100; i++) {\n        vec3 pos = ro + rd * t;\n        float d = rhomb(pos);\n        if (d < t * eps) return vec2(t, 1.);;\n        t += d;\n        if (t > tmax) break;\n    }\n    return vec2(t, -1.);\n}\n\nvec2 trace_lenses(in vec3 ro, in vec3 rd, in float tmin, in float tmax) {\n    float t = tmin; float eps = 1. / iResolution.y;\n    for (int i = min(iFrame, 0); i < 25; i++) {\n        vec3 pos = ro + rd * t;\n        float d = lenses(pos);\n        if (d < t * eps) return vec2(t, 1.);;\n        t += d;\n        if (t > tmax) break;\n    }\n    return vec2(t, -1.);\n}\n\nvoid lens_in_out(inout vec3 pos, inout vec3 rd, in float refn) {\n    vec3 rng = (hash33(rd) * 2. - 1.) * 0.001;\n    vec3 nor = -get_lens_norm(pos) + rng;\n    rd = refract(rd, nor, refn);\n\n    vec3 w = (LENS_WIDTH * nor) / dot(nor, rd);\n    pos = pos + w;\n\n    nor = get_lens_norm(pos);\n    rd = refract(rd, nor, refn);\n}\n\nvec3 sky(vec3 rd) {\n    vec3 col = vec3(0.);\n    col += mix(0.15 * vec3(0.75, 0.5, 1.0), 0.01 * vec3(0.25, 0.5, 1.0),\n               0.5 + 0.5 * normalize(rd).y);\n    col += mix(0.5 * vec3(1.000,1.000,1.000), 0.01 * vec3(0.25, 0.5, 1.0),\n               0.85 + 0.5 * normalize(-rd).y);\n    col += smoothstep( -0.4, 0.4,\n               dot(rd + vec3(0.0, 0.7, 0.0), normalize(vec3(0.0, -0.2, 0.0)))) *\n           vec3(0.1, 0.0, 0.3) * 0.3;\n    return col * 0.5 + hash31(rd) * 0.01;\n}\n\nfloat fblur = 0.;\nbool blur_on = true;\n\nvec3 paint(vec3 pos, vec3 rd, vec3 nor) {\n    vec3 ld = normalize(vec3(-2.5, 2.2, -7.3));\n    vec3 ld2 = -ld;\n    vec3 albedo = WHITE * 0.25;\n    vec3 ambient = 0.06 * CRAYOLA * smoothstep(-2.0, 0.8, length(pos.xz) + abs(pos.y));\n    vec3 directional = 0.3 * VIOLET * max(dot(nor, normalize(ld)), 0.0);\n    directional += 1.0 * RED * max(dot(nor, normalize(ld2)), 0.0);\n    directional *= smoothstep(-1.0, 1.5, dot(pos, normalize(ld2)));\n\n    float f = 1.2 - abs(dot(nor, rd));\n    float fresnel = f * f * f * f * f;\n    fresnel = mix(.04, 1.0, fresnel);\n\n    if (blur_on) fblur = fresnel;\n\n    vec3 reflection = 2. * sky(reflect(rd, nor));\n\n    return mix(albedo * (ambient + directional), reflection, vec3(fresnel));\n}\n\nvec3 afterimage(vec3 pos, vec3 rd, float refn) {\n    vec3 col = vec3(0.);\n    lens_in_out(pos, rd, refn);\n    \n    vec3 wire_color = WHITE;\n    vec2 hit_lens = trace_lenses(pos, rd, 0.08, 0.5);\n    if (hit_lens.y > 0.) {\n        refn = 1. / 1.1;\n        lens_in_out(pos, rd, refn);\n        wire_color = vec3(0.639,0.627,0.384);\n    }\n\n    // Check out Tater's shader for full explanation\n    // https://www.shadertoy.com/view/7sdGRr\n    float s = 1.0, t = 0.;\n    for (float i = min(float(iFrame), 0.); i < 50.; ++i) {\n        vec3 pos = pos + rd * t;\n        float d = rhomb(pos);\n        if (abs(d) < 0.01) {\n            float edge = 0.003 * t * clamp(800. / iResolution.x, 1.0, 2.5);\n            float edge_amount =\n                length(get_rhomb_norm(pos, 0.015) - get_rhomb_norm(pos, edge));\n            col += wire_color * smoothstep(0.1, 0.5, edge_amount) * 0.25;\n            s *= -1.;\n            d = 0.02 * s;\n        }\n        if (t > 1.5) break;\n        t += d * s;\n    }\n\n    return col;\n}\n\nvec3 render(vec2 uv) {\n    vec3 ro = vec3(0., 0., -4.);\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    float anglex = iMouse.z > 0.0 ? TAU * mouse.x : PI;\n    float angley = iMouse.z > 0.0 ? (mouse.y * TAU) - 0.4 : 0.25;\n    ro= (vec3(sin(anglex)*cos(angley), sin(angley), cos(anglex)*cos(angley))) * 4.0;\n\n    mat3 cam = get_cam(ro, vec3(0.));\n    vec3 rd = cam * normalize(vec3(uv, 1.));\n\n    vec3 col = sky(rd);\n\n    vec2 bound = intersect_sphere(ro, rd, vec3(0.), 1.02);\n    if (bound.y < 0.) return col;\n\n    vec3 hit = trace_scene(ro, rd, bound.x, bound.x + 2.);\n    if (hit.y > 0.) {\n        vec3 pos = ro + rd * hit.x;\n        vec3 nor = get_norm(pos);\n        float mat_id = hit.z;\n\n\n        if (mat_id == 0.) {\n            col = paint(pos, rd, nor);\n        }\n        if (mat_id == 1.) {\n            col = .6 * sky(reflect(pos, pos));\n            col += .2 * sky(refract(rd, nor, 1. / 1.1));\n\n            blur_on = false;\n\n            /* col = afterimage(pos, rd, 1. / 1.1); */\n\n            col.r += afterimage(pos, rd, 1. / 1.13).r * 2.;\n            col.g += afterimage(pos, rd, 1. / 1.12).g * 1.3;\n            col.b += afterimage(pos, rd, 1. / 1.1).b * 1.6;\n            col /= 3.;\n        }\n    }\n\n    return col;\n}\n\n// I saved this function when I was reverse engineering\n// one of the 0b5vr shaders and can't trace from where and when I did it.\n// I need a whole book on how to create glitch effects!\n#define BEAT (iTime * 80.0 / 60.0)\n#define lofi(x, d) (floor((x) / (d)) * (d))\nvec2 glitch(vec2 uv) {\n    vec2 vt = uv;\n    for (int i = 0; i < 6; ++i) {\n        float fac = 4.0 * pow(2.2, -float(i));\n        float s = hash11(lofi(vt.x, 1.6 * fac));\n        s += hash11(lofi(vt.y, 0.4 * fac));\n        s += hash11(iTime);\n        float proc = hash11(s);\n        \n        // https://www.desmos.com/calculator/w4u0k6gejv\n        float release = 0.8 * smoothstep(1., 0., abs(mod(2. * iTime + 1., PERIOD) - 1.));\n        release = pow(release, 5.) - 0.1; if (iTime < 2.) release = -0.1;\n       \n        vt -= 0.2 * step(proc, release) * (vec2(hash11(s + 22.56), hash11(s + 17.56)) - 0.5);\n  }\n  return vt;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    uv *= .55;\n    uv = glitch(uv);\n    \n    vec3 col = render(uv);\n    \n    col = ACESFilm(col);\n    fragColor = vec4(col, fblur * fblur);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// from https://www.shadertoy.com/view/lsBfRc\nvec3 makeBloom(float lod, vec2 offset, vec2 bCoord){\n    \n    vec2 pixelSize = 1.0 / iResolution.xy;\n\n    offset += pixelSize;\n\n    float lodFactor = exp2(lod);\n\n    vec3 bloom = vec3(0.0);\n    vec2 scale = lodFactor * pixelSize;\n\n    vec2 coord = (bCoord.xy-offset)*lodFactor;\n    float totalWeight = 0.0;\n\n    if (any(greaterThanEqual(abs(coord - 0.5), scale + 0.5)))\n        return vec3(0.0);\n\n    for (int i = -5; i < 5; i++) {\n        for (int j = -5; j < 5; j++) {\n\n            float wg = pow(1.0-length(vec2(i,j)) * 0.125,6.0);\n            vec4 tex = texture(iChannel0, vec2(i,j) * scale + lodFactor * pixelSize + coord, lod);\n            bloom = pow(tex.rgb * tex.a, vec3(2.2))*wg + bloom;\n            totalWeight += wg;\n\n        }\n    }\n\n    bloom /= totalWeight;\n\n    return bloom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n\tvec3 blur = makeBloom(2.,vec2(0.0,0.0), uv);\n\t\tblur += makeBloom(3.,vec2(0.3,0.0), uv);\n\t\tblur += makeBloom(4.,vec2(0.0,0.3), uv);\n\t\tblur += makeBloom(5.,vec2(0.1,0.3), uv);\n\t\tblur += makeBloom(6.,vec2(0.2,0.3), uv);\n\n    fragColor = vec4(pow(blur, vec3(1.0 / 2.2)),1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}