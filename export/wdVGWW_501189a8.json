{"ver":"0.1","info":{"id":"wdVGWW","date":"1570204739","viewed":210,"name":"ShaderTober - Freeze","username":"Flopine","description":"A small doodle with inktober's theme \"freeze\"","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","transparency","hexagone"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define hr vec2(1., sqrt(3.))\n#define PI 3.141592\n\nfloat hash21 (vec2 x)\n{return fract(sin(dot(vec2(1.45,3.54),x+0.2))*12.4);}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvec2 moda (vec2 p, float per)\n{\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a-per/2.,per)-per/2.;\n    return vec2(cos(a),sin(a))*l;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n// iq's formula https://iquilezles.org/articles/distfunctions\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat cyl (vec2 p, float r)\n{return length(p)-r;}\n\nfloat prim1(vec3 p)\n{\n    return sdCapsule(p, vec3(0.,-1.5,0.), vec3(0.,1.5,0.), 1.4+p.y*0.3);\n}\n\nfloat cocoon(vec3 p)\n{\n    vec3 pp = p;\n    float cap = prim1(p);\n    \n    p.xz *= rot(p.y*0.5);\n    p.xz = moda(p.xz, 2.*PI/3.);\n   \tp.x -= (2.-abs(p.y-1.)*0.3);\n    float branch1 = cyl(p.xz, 0.4);\n    \n    p = pp;\n\n    p.xy *= rot(PI/3.);\n    p.xz *= rot(p.y*0.4);\n    p.xz = moda(p.xz, 2.*PI/2.);\n   \tp.x -= (1.+abs(p.y)*0.1);\n    float branch2 = cyl(p.xz, 0.3+abs(p.y)*0.03);\n    \n    p = pp;\n\n    p.xy *= rot(-PI/3.);\n    p.xz *= rot(p.y*0.4);\n    p.xz = moda(p.xz, 2.*PI/2.);\n   \tp.x -= (1.+abs(p.y)*0.1);\n    float branch3 = cyl(p.xz, 0.1+abs(p.y)*0.03);\n    \n    return smin(branch3,smin(branch2,smin(cap,branch1,3.), 3.),3.);\n}\n\nfloat SDF (vec3 p)\n{\n    return cocoon(p);\n}\n\nvec3 getnormals(vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nfloat hdist (vec2 uv)\n{\n    uv = abs(uv);\n    return max(uv.x,dot(uv, normalize(hr)));\n}\n\nvec4 hgrid(vec2 uv, float detail)\n{\n    uv *= detail;\n    vec2 ga = mod(uv, hr)-hr*0.5;\n    vec2 gb = mod(uv-hr*0.5,hr)-hr*0.5;\n    \n    vec2 guv = (dot(ga,ga)<dot(gb,gb)) ? ga : gb;\n    \n    vec2 gid = uv-guv;\n    \n    guv.y = 0.5-hdist(guv);\n    return vec4(guv,gid);\n}\n\n\nvec3 background(vec2 uv)\n{\n    vec4 hg = hgrid(uv,4.);\n    vec2 hgid = hg.zw;\n    return clamp(vec3(hash21(hgid+0.01),hash21(hgid),1.)\n                 *exp(-fract(iTime*hash21(hgid)*0.5))+hg.y,\n                 0.,\n                 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    float dither = hash21(uv);\n    \n    vec3 ro = vec3(0.001,0.001,-6.),\n        rd = normalize(vec3(uv,1.)),\n     \tp = ro,\n        lp = vec3(1.,3.,2.),\n        col = vec3(0.); \n    \n    float shad = 0., t=0., layers=0., d, aD;\n    // light parameters\n    float lDist, specular, lighting;\n    // thickness of the geometry\n    float thD = .00125;\n\n    bool hit = false;\n    \n    for(float i=0.; i<64.; i++)\n    { \n        // Shane fake transparency trick\n        // https://www.shadertoy.com/view/Xd3SDs  \n        if(layers > 30. || t > 15.) break;\n        p = ro+t*rd;\n        d = SDF(p);\n        aD = (thD-abs(d))/thD;\n        \n        if (aD>0.)\n        {\n            hit = true;\n            uv *= 0.975;\n            col += vec3(0.,0.8,1.)*0.018;\n            vec3 sn = getnormals(p)*sign(d);\n            vec3 ld = (lp - p);\n            lDist = length(ld);\n            ld /= lDist;\n            specular = pow(max(dot(reflect(-ld, sn), -rd), 0.), 15.);\n            lighting = max(dot(ld, sn), 0.);\n            col += (lighting * 0.3 + vec3(0.5)*specular)*aD/ (1.+lDist*0.25 + lDist*lDist*0.05)*0.5;\n            layers ++;\n        }\n        d *= 0.8 + dither*0.1;\n        t += max(abs(d), thD*0.25);\n    }\n    \n    if (hit) col += pow(background(uv),vec3(1.5));\n    else col = background(uv)*0.4;\n\n     // vignetting (from iq)\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= .5 + 0.5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), 0.2);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}