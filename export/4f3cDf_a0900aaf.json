{"ver":"0.1","info":{"id":"4f3cDf","date":"1731242054","viewed":33,"name":"Weird Shapes - Chamas Ali","username":"alichamas","description":"Ce shader a 3 formes étranges que j'ai créées pour apprendre la création et la modification de formes.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["weirdspheres","weirdcube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Modeling - 2024.10.06\n// Chamas Ali\n\nstruct Ray {\n    vec3 o; \n    vec3 d; \n};\n\nstruct Val {\n    float v; \n    int c;  \n};\n\nconst int Steps = 200;  \nconst float Epsilon = 0.01;  \n\n\nvec3 Point(Ray ray, float t) {\n    return ray.o + t * ray.d;\n}\n\n\nmat3 Rz(float a) {\n    float sa = sin(a);\n    float ca = cos(a);\n    return mat3(ca, sa, 0., -sa, ca, 0., 0., 0., 1.);\n}\n\nRay CreateRay(vec2 m, vec2 p) {\n    float a = 3. * 3.14 * m.x;\n    \n    float zoomFactor = 1.5; \n    float fovFactor = 1.0;  \n\n    \n    vec3 ro = vec3(37., 0., 20.);  \n    ro *= zoomFactor; \n    ro *= Rz(a); \n\n    vec3 ta = vec3(0., 0., 1.);\n\n    vec3 w = normalize(ta - ro);\n    vec3 u = normalize(cross(w, vec3(0., 0., 1.)));\n    vec3 v = normalize(cross(u, w));\n\n    float le = 3.5 * fovFactor; \n\n    vec3 rd = normalize(p.x * u + p.y * v + le * w);\n\n    return Ray(ro, rd);\n}\n\n\n\nVal Plane(vec3 p, vec3 n, vec3 o) {\n    return Val(dot((p - o), n), 1);\n}\n\nfloat smoothMin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * h * h * k * (1.0 / 16.0);\n}\n\nVal Union(Val a, Val b) {\n    return Val(smoothMin(a.v, b.v, 0.1), a.c + b.c + 1);\n}\n\nVal Shape1(vec3 p, vec3 center, float radius) {\n\n    float distortion = sin(p.x *15.0) *0.01 - cos(p.y * 2.0) * 0.; \n    float dist = length(p - center) - radius;\n    \n    return Val(dist + distortion, 1); \n}\n\nVal Shape2(vec3 p, vec3 center, float radius, float spikes) {\n\n    float dist = length(p - center) - radius;\n    float angle = atan(p.y - center.y, p.x - center.x);\n    float smoothDistortion = sin(angle * spikes) * 0.05; \n\n    dist += smoothDistortion;\n\n    return Val(dist, 1);\n}\n\n\n\n\nVal Shape3(vec3 p, vec3 center, float size, float twistFactor, float frequency) {\n    vec3 d = abs(p - center) - vec3(size); \n    float dist = max(d.x, max(d.y, d.z)); \n\n    \n    float angle = atan(p.y - center.y, p.x - center.x);\n    float twist = sin(angle * frequency + p.z * twistFactor); \n\n   \n    float distortedDist = dist + twist * 0.1; \n\n    return Val(distortedDist, 1); \n}\n\n\nVal object(vec3 p) {\n\n    float separation = 9.0;\n    Val v = Union(\n    \n        Shape2(p, vec3(-15.0, 0.0, 0.0), 6.25, 10.0),\n\n        Shape1(p, vec3(-1.0, 0.0, 0.0), 6.25)\n    );\n\n    v = Union(v, Plane(p, vec3(0., 0., 1.), vec3(0.0, 0.0, -4.0)));\n    v = Union(v, Shape3(p,vec3(14.0, 0.0, 0.0),6.25,2.,0.));\n\n\n    return v;\n}\n\nvec3 ObjectNormal(vec3 p) {\n    const float eps = 0.001;\n    vec3 n;\n    Val val = object(p);\n    float v = val.v;\n    n.x = object(vec3(p.x + eps, p.y, p.z)).v - v;\n    n.y = object(vec3(p.x, p.y + eps, p.z)).v - v;\n    n.z = object(vec3(p.x, p.y, p.z + eps)).v - v;\n    return normalize(n);\n}\n\nbool SphereTrace(Ray ray, float e, out float t, out int s, out int c) {\n    bool hit = false;\n    t = 0.0;\n    c = 0;\n\n    for (int i = 0; i < Steps; i++) {\n        s = i;\n        vec3 p = Point(ray, t);\n        Val val = object(p);\n        float v = val.v;\n        c += val.c;\n        if (v < 0.) {\n            hit = true;\n            break;\n        }\n        t += max(Epsilon, v);\n        if (t > e) {\n            break;\n        }\n    }\n    return hit;\n}\n\n\nvec3 background(Ray ray) {\n    return mix(vec3(0.5, 0.15, 0.89), vec3(0.2, 0.79, 0.99), ray.d.z * 0.5 + 0.5);\n}\n\n\nfloat Shadow(vec3 p, vec3 n, vec3 l) {\n    float t;\n    int s;\n    int c;\n    bool hit = SphereTrace(Ray(p + Epsilon * n, l), 100., t, s, c);\n    return hit ? 0. : 1.;  \n}\n\n\nvec3 Shade(vec3 p, vec3 n, Ray eye) {\n    const vec3 lp = vec3(5., 10., 25.); \n    vec3 l = normalize(lp - p);\n\n    vec3 ambient = 0.25 + 0.25 * background(Ray(p, n));\n\n    float shadow = Shadow(p, n, l);\n    vec3 diffuse = 0.35 * clamp(dot(n, l), 0., 1.) * vec3(1., 1., 1.);\n\n    vec3 r = reflect(eye.d, n);\n    vec3 specular = 0.15 * pow(clamp(dot(r, l), 0., 1.), 35.) * vec3(1., 1., 1.);\n\n    return ambient + shadow * (diffuse + specular);\n}\n\nvoid mainImage(out vec4 color, in vec2 pxy) {\n    vec2 pixel = (-iResolution.xy + 2. * pxy) / iResolution.y;\n\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    Ray ray = CreateRay(m, pixel);\n\n    float t = 0.0;\n    int s = 0;\n    int c;\n    bool hit = SphereTrace(ray, 100., t, s, c);\n    vec3 rgb = background(ray);\n\n    if (hit) {\n        vec3 p = Point(ray, t);\n        vec3 n = ObjectNormal(p); \n        rgb = Shade(p, n, ray); \n    }\n\n   \n    color = vec4(rgb, 1.);\n}\n","name":"Image","description":"","type":"image"}]}