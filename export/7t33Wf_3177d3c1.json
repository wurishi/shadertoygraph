{"ver":"0.1","info":{"id":"7t33Wf","date":"1728415179","viewed":39,"name":"Melody Maker","username":"spalmer","description":"simple sine synth playing a simple melody","likes":8,"published":1,"flags":8,"usePreview":0,"tags":["sound","music","sequencer","fmsynthesis","pianoroll"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 o, vec2 u)\n{\n    vec2 r = iResolution.xy; u = u - .5 * r;\n    u.y *= 2.; u.y -= .2*u.x;\n    vec3 c = .5 + .5 * cos(iTime + u.xyx/r.y + vec3(0,2,4));\n    float a = .2 * r.y - length(u + vec2(.1,.5) * r.y);\n    a = max(a, .04 * r.y - length(vec2(u.x - .053 * r.y, sign(u.y) * max(abs(u.y) - .55 * r.y, 0.)))); \n    c *= clamp(a, 0., 1.);\n    o = vec4(c, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Melody Maker - by spalmer\n\n// I found this stalled WIP that had been gathering dust for years,\n// Had hoped to do more with it, but never seem to find time to work on it.\n// I can't remember what I had planned for it anymore.\n\n// Figure why not just public it, since it sounds pretty decent.\n// Supports variable polyphony, multiple instrument voices.\n// Surely can find some use somewhere.\n\n// Enjoy!\n\n\n// TODO if I moved some of this to Common tab, could debug some of it in Image.\n// or visualize it.\n\nconst float pi = acos(-1.),\n    tau = radians(360.);\n\n// the instrument is made of first few harmonics of the fundamental frequency,\n// forming a kind of sawtooth or square wave, depending on details of phase\nvec2 ins(float t, float f)\n{\n    vec2 o;// = vec2(0);\n    float g = 1., F = f;\n    for (float i = -0.; i <= 2.; ++i) {\n        float u = t - i;\n        o += vec2(\n        sin(tau * F * u) // sine doesn't need an attack envelope\n        //cos(tau * F * u) // cosine produces an audible pop due to lack of attack envelope\n        // * exp2(-4.3 * u)\n         //* exp2(4. * i)\n         * g\n         );\n        F *= 2.01; //1.5; // // perfect 2.0 winds up cancelling the tone out somehow\n        g *= .7; // controls timbre\n    }\n    o *= exp2(-.004 * t * f); // \n    o *= 1. - exp2(-5e1 / sqrt(f)); // slower attack for high frequencies\n    o *= exp2(-.001 * f); //16. / sqrt(f); // attenuate higher frequencies more\n    return o;\n}\n\nfloat note(float fund, float chr)\n{\n    return fund * exp2(chr / 12.);\n}\n\nconst float\n    key = 440. * exp2((-0.*12. + 7.) / 12.), //660., //55. * 12., //exp2(3./12.), // fundamental frequency of song (middle A = 440 Hz, so this would be.. E)\n    m = 0.,//1., // 1. for minor, 0. for major\n    tsig = 4., // beats/measure\n    tempo = 240.; // BPM\n\n// 4. + m is the third, 7. is perfect fifth, 12. is octave.  table is 1-based, first entry is a throwaway.\n// has like 1.5 octaves worth, idk why I wrapped it manually\nconst float scale[13] = float[13](   -1. - m,\n     0.,  2.,  4. - m,  5.,  7., 9. - m, 11. - m,\n    12., 14., 16. - m, 17., 19.\n    );\n// non-chromatic notation for chord progression and notes.\n// looks everything up through the scale so it all stays in key.\n// 1 = root, 3 = third, 5 = fifth, 8 = octave, 10 = octave*third\n// the main chord progression; for slow background swells\nconst int song[] = int[] (\n    8, //5, \n    8, //5,\n    4, //1, \n    4, //1,\n    8, //5, \n    8, //5,\n    4, //1, \n    4, //1,\n    9, //6, \n    11 //, //5,\n    );\n// bassline not too bad now\nconst int bassline[] = int[](\n    8, 5, 8, 5, \n    8, 5, 8, 10,\n    4, 8, 4, 8, \n    4, 8, 4, 3,\n    8, 5, 8, 5, \n    8, 5, 8, 10,\n    4, 8, 4, 8, \n    4, 8, 4, 3,\n    9, 6, 2, 6, \n    11, 8, 4, 10\n    );\n// FIXME melody needs work still\nconst int melody[] = int[](\n    1, 9, 5, 8, 3, 10, 8, 11,\n    1, 9, 5, 8, 3, 10, 8, 7,\n    4, 8, 1, 5, 3, 6, 4, 5,\n    4, 8, 1, 5, 3, 6, 5, 7,\n    1, 9, 5, 8, 3, 10, 8, 11,\n    1, 9, 5, 8, 3, 10, 8, 7,\n    4, 8, 1, 5, 3, 6, 4, 5,\n    4, 8, 1, 5, 3, 6, 5, 7,\n    2, 10, 6, 11, 2, 10, 6, 7,\n    4, 8, 1, 5, 3, 6, 4, 7\n    );\n\n// gives volume, chromatic pitch for beat, given a pattern table\nvec2 beat(int x) //, in int)\n{\n    if (x < 0) return vec2(0); // only start at the beginning of the song, not before!\n    x += melody.length();\n    x %= melody.length();\n    int note = melody[x];\n    float rp;\n    rp = scale[note];\n    // TODO allow greater range of inputs by wrapping table and using powers of two to extend it. (not working yet)\n    //rp = scale[(note + 6) % 7 + 1] * exp2(float((note + 6) / 7 - 1)); // * key;\n    return vec2(.1, rp);\n}\n/*\n// old song was ok for one instrument, but not well parameterized,\n// all of this would need duplicated and customized for practically every instrument.\nvec2 oldSong(int s, float t, float rate)\n{\n    vec2 o = vec2(0);\n    float w = 60. / tempo, // beat duration in seconds\n        ph = mod(t, w);    \n    int bi = int(t / w);\n    for (int i = - 6; i <= 0; ++i) { // polyphony allows notes to ring longer than their beat\n        vec2 b = beat(bi + i);\n        o += b.x * ins(ph - float(i) * w, note(key, b.y));\n    }\n    return o;\n}\n*/\n// this damnable macro does NOT help.\n// be sure to properly parenthesize macro arguments!\n\n#define TRACK(O, t, bps, polyphony, pattern, instrument, pan, pitchshift) {    \\\n    float w = 1. / (bps),    \\\n         ph = mod((t), w);    \\\n    int ip = int(floor((t) / (w)));    \\\n    for (int i = -(polyphony); i <= 0; ++i) {    \\\n        int bi = ip + i;    \\\n        if (true && bi < 0) continue;    \\\n        float rp = scale[pattern[(bi + pattern.length()) % pattern.length()]];    \\\n        O += (pan) * instrument(ph - float(i) * w, note(key, (pitchshift) + rp));    \\\n    }    \\\n}\n\n// ignore t input and recompute from iSampleRate\n// t input is basically float(s) / iSampleRate;\n// that's the problem, it's computed in single precision.\n// after a few seconds it becomes increasingly inaccurate.\n// the 'trick' is to utilize the song's tempo\n// to recompute a floating point sub-beat time that\n// is highly precise relative to the start of the sub-beat\n// or, not even sure we care about that, we mostly care\n// about having precise measurements from the beginning of\n// each played note.  So we can produce waveforms free of\n// weird distortions due to FP precision.\n// I imagine just having a measurement relative to bar would suffice\n// but tempo tends to stay more constant than time signature.\n    //t = float(s) / float(rate), // FIXME precision issues; idk if we can trust t input either. but recomputing here wouldn't be an improvement.\n    // the goal is to evaluate ph with very high precision\n    // since it's relative to the beat or at least the measure or whatever\n    // think there's a better way still, by finding a nearby integer beat start.\n    // like, estimate where a nearby beat would start, and... subtract in integer,\n    // *then* convert to float.\n    // let's relate it all to a measure so we won't notice any pop usually\n    //const int intbar = int(round(rate / bardur)), // rate is sample/second, we want sample/measure\n    //    intbeat = int(round(bps / rate));\n    // TODO need samples since start of the measure, converted back to float\n    // but in like instrument pitched wave units.\n    //bi = (s - ....); // TODO\n    //const float     beatdur = 60. / tempo, // 1. / bps, //\n    //    bardur = tsig * beatdur; // measure/second\n    //float bi = t * bps; //bps / rate * float(s); //\nvec2 newSong(int s, float t, float rate)\n{\n    t -= .5; // delay split second from pressing play until it starts to hear start of song properly over mouse click and/or initial pop\n    const float bps = tempo / 60.;\n    vec2 o;\n    TRACK(o, t, bps / 8., 1, song,     ins, vec2(.3,0),  -3.*12.);\n    TRACK(o, t, bps / 2., 1, bassline, ins, vec2(0, .4), -2.*12.);\n    TRACK(o, t, bps / 1., 2, melody,   ins, vec2(.7,.6), -0.*12.);\n    if (m != 0.) o = clamp(o, -1., .1); // grungy distorted when minor?  ;)  tyvm @dray for finding this bug\n    return o;\n}\n\n\nvec2 mainSound(int s, float t)\n{\n    return newSong //oldSong //\n        (s, t, iSampleRate)\n        * .5 // volume\n        ;\n}","name":"Sound","description":"","type":"sound"}]}