{"ver":"0.1","info":{"id":"csVcDy","date":"1696860436","viewed":43,"name":"drunk moon again","username":"pomote","description":"but with texture now","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// thanks to https://inspirnathan.com/ for tutorial\nconst float PI = 3.1415926535;\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nconst mat2 m = mat2( 0.80,  0.80, -0.80,  0.80 );\n\nfloat noise(in vec2 p)\n{\n\treturn sin(p.x)*cos(p.y) + sin(p.x)*sin(p.y);\n}\n\nfloat func(vec2 p) {\n\tvec2 k = vec2(noise(m*p*2.), 0.5+0.5*noise(m*p*2.));\n    vec2 m = vec2(0.5+0.5*noise(m*k*2.), 0.5+0.5*noise(m*k*2.));\n    float f = 0.5 + 0.5*noise(m*(4.*p + 2.0*m)*2.);\n    return mix(f, f*f*f, f);\n}\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// smooth min\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// smooth max\nfloat smax(float a, float b, float k) {\n  return -smin(-a, -b, k);\n}\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat distLine(vec3 ro, vec3 rd, vec3 p) {\n    return length(cross(p-ro,rd))/length(rd);\n}\n\nfloat sdSphere (vec3 p, float r) {\n\treturn length (p - vec3(r)) - 1.0 + 0.03 * sin(20.0*p.x + iTime);\n}\n\nfloat sdScene(vec3 p) {\n   float sphere = smin (sdSphere (p - vec3(-3, -3, -2), 1.),   sdSphere(p - vec3(2, -2, -1.5), 1.), 3.);\n   sphere = smin (sphere,   sdSphere(p - vec3(10, 5, -10), 1.), 0.5);\n   return sphere;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, vec3 p) {\n  float depth = MIN_DIST;\n  p = (p) * (rotateX(iTime)*0.3 + rotateZ(iTime)*0.2 + rotateY(iTime)*0.5);\n  float move = distLine(ro, rd, p);\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    float d = sdScene(p);\n    //depth += d;\n    depth += move;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n\n  return depth;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n      e.xyy * sdScene(p + e.xyy) +\n      e.yyx * sdScene(p + e.yyx) +\n      e.yxy * sdScene(p + e.yxy) +\n      e.xxx * sdScene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvec4 phong(vec3 lightDir, vec3 normal, vec3 rd) {\n  // ambient\n  float k_a = 0.6;\n  vec3 i_a = vec3(0.8);\n  vec3 ambient = k_a * i_a;\n\n  // diffuse\n  float k_d = 0.5;\n  float dotLN = clamp(dot(lightDir, normal), 0., 1.);\n  vec3 i_d = vec3(0.7, 0.5, 0);\n  vec3 diffuse = k_d * dotLN * i_d;\n\n  // specular\n  float k_s = 0.6;\n  float dotRV = clamp(dot(reflect(lightDir, normal), -rd), 0., 1.);\n  vec3 i_s = vec3(1, 1, 1);\n  float alpha = 10.;\n  vec3 specular = k_s * pow(dotRV, alpha) * i_s;\n\n  return vec4(ambient + diffuse + specular, 0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float seed = 0.3;\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec4 backgroundColor = texture (iChannel1, uv)*0.6;\n  float f = func(uv.xy);\n  vec4 col = vec4(f, .0, .0, .0);\n  //vec3 col = vec3(0);\n  vec3 lp = vec3(0.01); // lookat point (aka camera target)\n  vec3 ro = vec3(0, 0, 4);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n    \n  float t = iTime;\n  vec3 p = vec3(sin(t),0.+sin(t)*0.5,2.+cos(t));\n\n\n  float d = rayMarch(ro, rd, p);\n  \n  if (d > MAX_DIST) {\n    col = backgroundColor;\n  } else {\n      vec3 p = ro + rd * d; // point on surface found by ray marching\n      vec3 normal = calcNormal(p); // surface normal\n      float randomValue = rand(fragCoord);\n      //col = vec4(normal, 1.0);\n      col = vec4(texture (iChannel0, uv).rgb, 0.);\n      if (iMouse.z > 0.) {\n          if (iMouse.x > 400.) {   \n             col = vec4(randomValue, randomValue * 0.3, randomValue, 0.1);\n             backgroundColor = vec4(f, .0, .0, .0);\n          } \n          if (iMouse.x < 400.) {   \n             col = vec4(randomValue, randomValue * 0.9, randomValue * 0.3, 0.);\n             backgroundColor = vec4(f, .0, .0, .0);\n          } \n      }\n      // light #1\n      vec3 lightPosition1 = vec3(-8, -6, -5);\n      vec3 lightDirection1 = normalize(lightPosition1 - p);\n      float lightIntensity1 = 0.6;\n      \n      // light #2\n      vec3 lightPosition2 = vec3(1, 1, 1);\n      vec3 lightDirection2 = normalize(lightPosition2 - p);\n      float lightIntensity2 = 0.5;\n\n      // final sphere color\n      col += lightIntensity1 * phong(lightDirection1, normal , rd);\n      col += lightIntensity2 * phong(lightDirection2, normal , rd);\n  }\n  fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 hash(float p) {\n   return fract(vec3(p) * vec3(0., 0., 0.006)); \n}\n\nvec3 hash(vec3 p) {\n    return fract(p * vec3(0.1, 0.5, 1.));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 col;\n    for(int i = 0; i < 9; i++) {\n        vec2 uv = (fragCoord * 5.) / (iResolution.y * 10.) + iTime / 46.;\n        uv.y *= 2.;\n        uv = fract(uv).yx + col.zx;\n        uv.y *= (-(hash(iTime * 0.5).y / 5.) + uv.y);\n        //uv.y /= uv.x * 8.;\n        col[i] = sin(fract(uv.x - uv.y));\n    }\n    fragColor = vec4(col, 1.);\n}","name":"Buffer A","description":"","type":"buffer"}]}