{"ver":"0.1","info":{"id":"dscczn","date":"1694664133","viewed":18,"name":"Shader HW1b - Cold Roller","username":"Truckbuchet","description":"Clock & Hold. Feel hot cold.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["rhombus","roundcone"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//from https://iquilezles.org/articles/distfunctions/\n//sdRoundCone, ndot, & sdRhombus\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  // sampling independent computations (only depend on shape)\n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float k = dot(q,vec2(-b,a));\n  if( k<0.0 ) return length(q) - r1;\n  if( k>a*h ) return length(q-vec2(0.0,h)) - r2;\n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdRhombus( vec3 p, float la, float lb, float h, float ra )\n{\n  p = abs(p);\n  vec2 b = vec2(la,lb);\n  float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n  vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n//pattern 1 - background\nvec3 pattern1(vec2 Pos){\n Pos = floor(Pos);\n return vec3(mod(Pos.x + mod(Pos.x, Pos.y), 0.36));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //rotation direction\n    float s = sin(iTime);\n    float c = cos(iTime);\n    mat3 roty = mat3(\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n        -s, 0.0, c\n      );\n    mat3 rotx = mat3(\n        1.0, 0.0, 0.0,\n        0.0, c,   s,\n        0.0, -s,  c\n      );\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.xy -= 0.5;\n    \n    //pattern 1 - background\n    vec3 col = pattern1(fragCoord.xy /10.0 + vec2(iMouse));\n    \n    //Create deathrays for math, three of them\n    vec3 rayPt = vec3(uv.xy, 0);\n    vec3 rayPtdx = vec3(uv.x + 0.00001, uv.y, 0);\n    vec3 rayPtdy = vec3(uv.x,          uv.y + 0.00001, 0);\n    \n    vec3 rayDir = vec3(0,0,1);\n    //camera perspective perspective of deathrays\n    //vec3 eyePos = vec3(0,0,-10);//make z a mouse dependent perspective?\n    //vec3 rayDir = normalize(vec3(uv.xy, 0) - eyePos);\n    \n    //ray paremeters\n    float t = 0.0, tdx = 0.0, tdy = 0.0;\n    \n    for(int i = 0; i < 20; i++){\n        //calculate 3 points along the ray\n        vec3 pos = rayPt + rayDir * t;    \n        vec3 posdx = rayPtdx + rayDir * tdx;\n        vec3 posdy = rayPtdy + rayDir * tdy;\n        \n        //define Rhombus properties\n        vec3 RhombusPos = vec3(0.01, 0.0, 0.01);\n        float RhAxisX = (0.1);\n        float RhAxisY = (0.1);\n        float RhHeight = (0.1);\n        float RhCorner = (0.1);\n        \n        //define RoundCone properties\n        vec3 RCPos = vec3(0.01, -0.1, 0.01);\n        float RCx = (0.1);\n        float RCy = (0.1);\n        float RCHeight = (0.2);\n        \n        //subtract object position from ray position and check if that point\n        //is in the world origin sphere\n        \n        //Rhombus + RoundCone\n        float dist = min(sdRhombus(roty*rotx*(pos - RhombusPos), RhAxisX, RhAxisY, RhHeight, RhCorner),\n                         sdRoundCone(roty*rotx*(pos - RCPos), RCx, RCy, RCHeight));\n        float distdx = min(sdRhombus(roty*rotx*(posdx - RhombusPos), RhAxisX, RhAxisY, RhHeight, RhCorner),\n                           sdRoundCone(roty*rotx*(posdx - RCPos), RCx, RCy, RCHeight));\n        float distdy = min(sdRhombus(roty*rotx*(posdy - RhombusPos), RhAxisX, RhAxisY, RhHeight, RhCorner),\n                           sdRoundCone(roty*rotx*(posdy - RCPos), RCx, RCy, RCHeight));\n        \n        if(dist < 0.001  && distdx < 0.001 && distdy < 0.001){\n        \n            vec3 lightDir = rayDir;\n            \n            //pattern 2 - checking color of combined shape\n            vec3 comboColor = vec3(iMouse.x,(iMouse.y),1);\n            \n            //output color = surfacecolor * dot (-Light Direction, surface normal)\n            //combination shape\n            col = comboColor*dot(-lightDir, normalize(cross(posdy - pos, posdx - pos)));\n            \n            break;\n        }\n        \n        t = t + dist;\n        tdx = tdx + distdx;\n        tdy = tdy + distdy;\n    }\n    \n    //pattern 3 - noise pattern\n    //It's fun to see what happens without the noise filter on. It's a totally different look and\n    //the mouse movement is more obvious\n    //col = mix(col,vec3(sin(iTime + fragCoord.x/3.6)), iTime);    \n    //output to the screen\n    fragColor = vec4(col,1.0);\n\n}","name":"Image","description":"","type":"image"}]}