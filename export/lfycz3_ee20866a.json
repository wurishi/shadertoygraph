{"ver":"0.1","info":{"id":"lfycz3","date":"1732386729","viewed":121,"name":"Energy Ball","username":"BipedPotato","description":"My first actual \"Complicated\" shader so don't hate on the messy code lol. Basically a recreation of Gojo's Hollow Purple from the anime Jujutsu Kaisen. You can probably also use this in games after some cleaning up :)\n","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["particles","ball","electricity","energy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    \n    uv = uv * 2.0 - 1.0;\n    \n    \n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n        \n        \n    float padding = 0.5;\n    float move_speed =1.2;\n    \n    \n    vec2 amp = vec2(0.02,0.02);\n    float frequency = 5.0;\n    vec2 scale = vec2(10.0,10.0);\n    \n    float compensate = (ratio+padding)/move_speed;\n    float delay = 3.0;\n    vec2 ball_position = vec2(\n        -ratio-padding+mod((iTime+compensate-delay)*move_speed,padding*2.0+ratio*2.0),0.0\n    );\n    if(iTime < delay){\n        ball_position = vec2(0.0,0.0);\n    }\n    \n    vec2 background_distortion_uv = uv;\n    background_distortion_uv.x+= smoothstep(0.9,0.6,length(uv - ball_position))*amp.x*cos(frequency*iTime+uv.y*scale.x);\n    background_distortion_uv.y+= smoothstep(0.9,0.6,length(uv - ball_position))*amp.y*sin(frequency*iTime+uv.x*scale.y);\n    \n    vec3 background = texture(iChannel1,background_distortion_uv).xyz*0.2;\n    float t = iTime * 2.5;\n    vec3 color = background;\n\n    const int num = 75;\n\n    float spawn_radius = 0.15;\n    float spawn_radius_rand = 0.15;\n    \n    float node_differ_radius = 0.05;\n    float differ_rand = 0.03;\n\n    float volt_thickness = 0.02;\n    float volt_thickness_rand = 0.01;\n\n    float amplitude = 1.0;\n    float amplitude_rand = 6.0;\n    float oscillation_speed = 1.5;\n    float oscillation_rand = 0.5;\n    float speed = 0.01;\n\n    float angular_speed = 0.69;\n    float loop_amount = 20.0;\n    float loop_length = 1.0;\n\n    vec3 purple = vec3(1.0, 0.9, 1.0) * 0.8;\n    \n    vec3 lines = vec3(0.0,0.0,0.0);\n    const int max_nodes = 7;\n    float nodes_removal = 4.0;\n    \n    int seed_offset = 0;\n    for (int i = 0; i < num; i++) {\n        float seed = float(i+seed_offset) * 2228.2918;\n\n        float time_offset = fract(sin(seed) * 8927.2357) * loop_length;\n        float loop = (t + time_offset) / loop_length;\n\n        seed_offset = int(mod(loop, loop_amount));\n\n        int nodes = int(\n            float(max_nodes) -\n            fract(sin(seed) * 1227.2212) * nodes_removal\n        );\n\n        float angular_speed_i = (fract(sin(seed) * 3452.5881) - 0.5) * 2.0 * angular_speed;\n        float angle = angular_speed * t + fract(cos(seed) * 9231.124392843) * 6.2831;\n\n        float dist_to_center = spawn_radius + spawn_radius_rand * fract(sin(seed) * 6248.8572);\n        vec2 start = vec2(cos(angle), sin(angle)) * dist_to_center;\n        vec2 position = start+ball_position;\n\n        float volt_thickness_i = volt_thickness + fract(sin(seed) * 3789.01241) * volt_thickness_rand;\n        float thickness_fall_off = volt_thickness_i/float(nodes);\n        for (int j = 0; j < max_nodes; j++) {\n            float node_seed = float(num + j + (i * max_nodes)+seed_offset) * 3242.96291079;\n            float differ = node_differ_radius + fract(sin(node_seed) * 7452.3967) * differ_rand;\n\n            float osc_speed = oscillation_speed + fract(sin(node_seed) * 3412.4823) * oscillation_rand;\n            float amp = amplitude + fract(sin(node_seed) * 2241.6469) * amplitude_rand;\n            float age = sin(t * osc_speed);\n            vec2 move_dir = vec2(cos(fract(cos(node_seed) * 12569.01435207) * 6.2831), \n                                 sin(fract(cos(node_seed) * 12569.01435207) * 6.2831));\n\n            vec2 new_position = position +\n                                vec2(cos(fract(cos(node_seed) * 43758.5453123) * 6.2831),\n                                     sin(fract(cos(node_seed) * 43758.5453123) * 6.2831)) * differ +\n                                move_dir * speed * age * amp;\n\n            float intensity = 15.0;\n            vec3 node_color = vec3(0.3, 0.25, 0.3) * intensity*pow(length(uv-ball_position),2.0);\n\n            float lifetime_ratio = mod((t + time_offset), loop_length) / loop_length;\n            float t_b = volt_thickness_i- (float(j) * thickness_fall_off);\n            float t_e = volt_thickness_i- (float(j+1) * thickness_fall_off);\n            \n            float t_n = volt_thickness_i- (float(j+2) * thickness_fall_off);\n            lines += drawLine(\n                        position,\n                        new_position,\n                        uv,\n                        t_b,\n                        t_e\n                    ) * (1.0 - lifetime_ratio) * node_color*2.0;\n        \n            position = new_position+normalize(new_position-position)*t_n;\n\n            if (j > nodes) {\n                break;\n            }\n        }\n    }\n    float outside_purple_distance = length(uv-ball_position);\n    //outer\n    float intensity = smoothstep(1.0, 0.4, outside_purple_distance);\n    color += vec3(0.15, 0.0, 0.2)*1.0*intensity;\n    //inner\n    vec3 norm = normal(uv-ball_position*0.5,iChannel0,iTime);\n    vec3 lightDir = normalize(vec3(10.0,15.0,5.0));\n    intensity = smoothstep(0.5, 0.2, outside_purple_distance);\n    color += vec3(0.4, 0.1, 0.6) *1.5* intensity;\n    vec3 dark_spots =(color*max(0.0,dot(lightDir,norm))*smoothstep(0.5, 0.32, outside_purple_distance))*length(uv-ball_position);\n    norm = normal(uv*1.0-ball_position,iChannel0,iTime);\n    vec3 spots = (color*max(0.0,dot(lightDir,norm))*smoothstep(0.5, 0.4, outside_purple_distance))*length(uv-ball_position);\n    float spots_clamp = 0.12;\n    spots = clamp_dots(spots,spots_clamp,1.0);\n    float spot_seed = uv.x*uv.y*9224.128456104*iTime;\n    color = color + (spots*4.0*fract(sin(spot_seed)*234.948271)) - dark_spots*0.8;\n    \n    //white\n    intensity = smoothstep(0.3, 0.01, outside_purple_distance);\n    color += vec3(1.0,1.0,1.0)*1.2*intensity;\n    float e_bound = 1.0;\n\n    fragColor = vec4(color+lines, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float drawLine(vec2 start,vec2 end,vec2 uv,float t_b,float t_e)\n{\n    vec2 direction = normalize(end-start);\n    vec2 uv_to_start = uv-start;\n    float projection = clamp(dot(uv_to_start,direction),0.0,length(end-start));\n    vec2 close = start+projection*direction;\n    float dist = length(uv-close);\n    float thick = t_b + (projection/length(start-end))*(t_e-t_b);\n    return smoothstep(thick,thick-0.03,dist);\n}\nvec3 clamp_dots(vec3 color, float lower, float upper){\n    if(color.x < lower){\n        color.x = 0.0;\n    }\n    if(color.y < lower){\n        color.y = 0.0;\n    }\n    if(color.z < lower){\n        color.z = 0.0;\n    }\n    float avg = (color.x+color.y+color.z)/3.0;\n    return vec3(avg,avg,avg);\n}\n\n//Kinda took this portion from https://www.shadertoy.com/view/4ls3zj by public_int_i\nfloat height(in vec2 uv,in sampler2D tex,in float iTime ) {\n    return texture(tex,uv+vec2(iTime,iTime)*0.1).x;\n}\n\nconst vec2 NE = vec2(0.01,0.0);\nvec3 normal(in vec2 uv,in sampler2D tex,in float iTime) {\n    return normalize(vec3(height(uv+NE.xy,tex,iTime)-height(uv-NE.xy,tex,iTime),\n                          0.0,\n                          height(uv+NE.yx,tex,iTime)-height(uv-NE.yx,tex,iTime)));\n}\n","name":"Common","description":"","type":"common"}]}