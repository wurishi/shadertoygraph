{"ver":"0.1","info":{"id":"l3lSzs","date":"1709876137","viewed":112,"name":"Drawing practice #3","username":"hasenpfote","description":"It may appear as a quirky way of drawing lines.","likes":2,"published":1,"flags":32,"usePreview":1,"tags":["edgedetection","sketch","drawing","npr","bilateral","oklab"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * Drawing practice #3\n *\n * ===\n * In this pass, edge detection is performed to determine the final colors.\n */\n\n//==============================================================================\n\n#define METHOD 1\n\nvec4 fetch(in vec2 pos){\n    return texture(iChannel0, pos / iResolution.xy);\n}\n\n#if (METHOD == 0)\nfloat noise(in vec2 x){\n    vec2 i = floor(x);\n    vec2 f = x - i;\n    vec2 u = f * f * (3. - 2. * f);\n\n    float a = hash12(i);\n    float b = hash12(i + vec2(1., 0.));\n    float c = hash12(i + vec2(0., 1.));\n    float d = hash12(i + vec2(1., 1.));\n\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n#elif (METHOD == 1)\nfloat noise(in vec2 x){\n    vec2 i = floor(x);\n    vec2 f = x - i;\n    vec2 u = f * f * (3. - 2. * f);\n\n    float a = dot(2. * hash22(i + vec2(0., 0.)) - 1., f - vec2(0., 0.));\n    float b = dot(2. * hash22(i + vec2(1., 0.)) - 1., f - vec2(1., 0.));\n    float c = dot(2. * hash22(i + vec2(0., 1.)) - 1., f - vec2(0., 1.));\n    float d = dot(2. * hash22(i + vec2(1., 1.)) - 1., f - vec2(1., 1.));\n\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n#endif\n\nfloat fbm(in vec2 x){\n    const float lacunarity = 2.;\n    const float gain = 0.75;\n\n    float amplitude = 0.5;\n    float frequency = 1.;\n    float value = 0.;\n\n    for(int i = 0; i < 2; i++){\n        value += amplitude * noise(frequency * x);\n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n    return value;\n}\n\nvec2 grad(in vec2 pos, in float delta){\n    // 2nd order central difference\n    vec2 d = vec2(delta, 0.);\n    return vec2(\n        fetch(pos + d.xy).r - fetch(pos - d.xy).r,\n        fetch(pos + d.yx).r - fetch(pos - d.yx).r\n    ) / (2. * delta);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n#ifdef DEBUG\n    const float ampl = 30.;\n#else\n    const float ampl = 15.;\n#endif\n\n    // Normalization factor for invariance with respect to screen resolution.\n    float srinf = iResolution.y / BASE_SCREEN_HEIGHT;\n    float trinf = fetch(fragCoord).a;\n    float t = iMouse.z > 0. ? iMouse.x / iResolution.x : 0.5 + 0.5 * sin(iTime);\n    vec2 uv = fragCoord / iResolution.y;\n    vec2 r = vec2(srinf * t * ampl);\n#if (METHOD == 0)\n    float angle = TAU * fbm(17. * uv);\n    r *= vec2(cos(angle), sin(angle));\n#elif (METHOD == 1)\n    r *= vec2(fbm(17. * uv), fbm(19. * uv));\n#endif\n\n    float mag;\n    vec2 g = trinf * grad(fragCoord + r, 0.5 * trinf);\n#ifdef DEBUG\n    vec2 g0 = trinf * grad(fragCoord, 0.5 * trinf);\n    mag = mix(length(g0), length(g), 0.8);\n#else\n    mag = length(g);\n#endif\n\n    vec3 lab = vec3(1. - smoothstep(0., 0.5, mag), 0., 0.);\n    vec3 color = oklab_to_linear_srgb(lab);\n\n    fragColor = vec4(linear_to_srgb(color), 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n//#define DEBUG\n\n/**\n * This constant represents the reference height used to determine the\n * normalization factor. It may vary depending on the environment, such as the\n * default height in window mode for Shadertoy.\n */\nconst float BASE_SCREEN_HEIGHT = 450.;\n\n//==============================================================================\n\nconst float PI = 3.1415926;\nconst float TAU = 6.2831853;\n\n//==============================================================================\n\nfloat atan2(in float y, in float x){\n    return x == 0. ? sign(y) * TAU / 4. : atan(y, x);\n}\n\nfloat cbrt(in float x){\n    return sign(x) * pow(abs(x), 1./3.);\n}\n\nvec3 cbrt(in vec3 x){\n    return sign(x) * pow(abs(x), vec3(1./3.));\n}\n\n//==============================================================================\n\n// Hash without Sine - David Hoskins\n// https://www.shadertoy.com/view/4djSRW\n\nfloat hash11(in float p){\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(in vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//==============================================================================\n\nfloat srgb_to_linear(in float x){\n    return x <= 0.04045 ? x / 12.92 : pow((x + 0.055) / 1.055, 2.4);\n}\n\nvec3 srgb_to_linear(in vec3 color){\n    return vec3(srgb_to_linear(color.r), srgb_to_linear(color.g), srgb_to_linear(color.b));\n}\n\nfloat linear_to_srgb(in float x){\n    return x <= 0.0031308 ? 12.92 * x : 1.055 * pow(x, 1./2.4) - 0.055;\n}\n\nvec3 linear_to_srgb(in vec3 color){\n    return vec3(linear_to_srgb(color.r), linear_to_srgb(color.g), linear_to_srgb(color.b));\n}\n\n//==============================================================================\n// Oklab\n// https://bottosson.github.io/posts/oklab/\n//==============================================================================\n\nconst mat3 LINEAR_SRGB_TO_LMS = mat3(\n    0.4122214708, 0.2119034982, 0.0883024619,\n    0.5363325363, 0.6806995451, 0.2817188376,\n    0.0514459929, 0.1073969566, 0.6299787005\n);\n\nconst mat3 LMS_PRIME_TO_OKLAB = mat3(\n     0.2104542553,  1.9779984951,  0.0259040371,\n     0.7936177850, -2.4285922050,  0.7827717662,\n    -0.0040720468,  0.4505937099, -0.8086757660\n);\n\nconst mat3 LMS_TO_LINEAR_SRGB = mat3(\n     4.0767416621, -1.2684380046, -0.0041960863,\n    -3.3077115913,  2.6097574011, -0.7034186147,\n     0.2309699292, -0.3413193965,  1.7076147010\n);\n\nconst mat3 OKLAB_TO_LMS_PRIME = mat3(\n    1.,            1.,            1.,\n    0.3963377774, -0.1055613458, -0.0894841775,\n    0.2158037573, -0.0638541728, -1.2914855480\n);\n\nvec3 linear_srgb_to_lms_prime(in vec3 rgb){\n    vec3 lms = LINEAR_SRGB_TO_LMS * rgb;\n    return cbrt(lms);\n}\n\nvec3 linear_srgb_to_oklab(in vec3 rgb){\n    vec3 lms_prime = linear_srgb_to_lms_prime(rgb);\n    return LMS_PRIME_TO_OKLAB * lms_prime;\n}\n\nvec3 lms_prime_to_linear_srgb(in vec3 lms_prime){\n    vec3 lms = lms_prime * lms_prime * lms_prime;\n    return LMS_TO_LINEAR_SRGB * lms;\n}\n\nvec3 oklab_to_linear_srgb(in vec3 lab){\n    vec3 lms_prime = OKLAB_TO_LMS_PRIME * lab;\n    return lms_prime_to_linear_srgb(lms_prime);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/**\n * In this pass, noise reduction is applied. The output is in the Oklab color\n * space.\n */\n\n#define USE_LUT\n\n/** Radius of the gaussian kernel. */\nconst int KERNEL_RADIUS = 2;\n\n/** Standard deviation for the domain kernel. */\nconst float SIGMA_D = 10.;\n\n/** Standard deviation for the range kernel. */\nconst float SIGMA_R = 0.1;\n\n//==============================================================================\n\nvec3 fetch(in vec2 pos){\n    return srgb_to_linear(texture(iChannel0, pos / iResolution.xy).rgb);\n}\n\n//==============================================================================\n\nfloat weight(in vec2 x, in vec3 intensity){\n#ifdef USE_LUT\n    return exp(- 0.5 * (x.x + x.y + dot(intensity, intensity)/(SIGMA_R*SIGMA_R)));\n#else\n    return exp(- 0.5 * (dot(x,x)/(SIGMA_D*SIGMA_D) + dot(intensity, intensity)/(SIGMA_R*SIGMA_R)));\n#endif\n}\n\n// https://en.wikipedia.org/wiki/Bilateral_filter\nvec3 bilateral_filter(in vec2 pos){\n#ifdef USE_LUT\n    const float vd = SIGMA_D * SIGMA_D;\n    float lut[KERNEL_RADIUS + 1];\n\n    for(int i = 0; i <= KERNEL_RADIUS; i++){\n        lut[i] = float(i*i) / vd;\n    }\n#endif\n\n    vec4 sum = vec4(0.);\n    vec3 c0 = fetch(pos);\n\n    for(int i = -KERNEL_RADIUS; i <= KERNEL_RADIUS; i++){\n#ifdef USE_LUT\n        float y_d = lut[abs(i)];\n#endif\n        for(int j = -KERNEL_RADIUS; j <= KERNEL_RADIUS; j++){\n            vec2 offset = vec2(i, j);\n            vec3 c = fetch(pos + offset);\n            vec3 intensity = c - c0;\n#ifdef USE_LUT\n            float w = weight(vec2(lut[abs(j)], y_d), intensity);\n#else\n            float w = weight(offset, intensity);\n#endif\n            sum.rgb += w * c;\n            sum.a += w;\n        }\n    }\n\n#undef USE_LUT\n\n    return sum.rgb / sum.a;\n}\n\n//==============================================================================\n\n#ifdef DEBUG\n// Heart - distance 2D - Inigo Quilez\n// https://www.shadertoy.com/view/3tyBzV\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat sdHeart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n#endif\n\n//==============================================================================\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Normalization factor for invariance with respect to texture resolution.\n    float rinf;\n    vec3 lab;\n#ifdef DEBUG\n    rinf = 1.;\n    vec2 p = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    p.y += 0.5; \n    float d = sdHeart(p);\n    lab = vec3(step(0., d), 0., 0.);\n#else\n    rinf = iResolution.y / iChannelResolution[0].y;\n    vec3 color = bilateral_filter(fragCoord);\n    lab = linear_srgb_to_oklab(color);\n#endif\n    fragColor = vec4(lab, rinf);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}