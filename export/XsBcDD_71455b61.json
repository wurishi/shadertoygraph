{"ver":"0.1","info":{"id":"XsBcDD","date":"1492135283","viewed":142,"name":"IIS Parabolic Example","username":"soma_arc","description":"Render the orbit of circles with Iterated Inversion System.\nParabolic Generator.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","inversion","schottky"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec3 makeCircleFromPoints(vec2 a, vec2 b, vec2 c){\n    float lA = distance(b, c);\n    float lB = distance(a, c);\n    float lC = distance(a, b);\n    float coefA = lA * lA * (lB * lB + lC * lC - lA * lA);\n    float coefB = lB * lB * (lA * lA + lC * lC - lB * lB);\n    float coefC = lC * lC * (lA * lA + lB * lB - lC * lC);\n    float denom = coefA + coefB + coefC;\n    vec2 center = (coefA * a + coefB * b + coefC * c)/denom;\n    return vec3(center, distance(center, a));\n}\n\nvec2 circleInvert(vec2 pos, vec3 circle){\n\treturn ((pos - circle.xy) * circle.z * circle.z)/(length(pos - circle.xy) * length(pos - circle.xy) ) + circle.xy;\n}\n\nfloat RT_2 = sqrt(2.);\nvec3 circleInvertOnCircle(vec3 invertCircle, vec3 genCircle){\n    float coeffR = invertCircle.z * RT_2 / 2.;\n    vec2 p1 = circleInvert(invertCircle.xy + vec2(coeffR), \n                           genCircle);\n    vec2 p2 = circleInvert(invertCircle.xy + vec2(coeffR, -coeffR),\n                                  genCircle);\n    vec2 p3 = circleInvert(invertCircle.xy + vec2(-coeffR), genCircle);\n    return makeCircleFromPoints(p1, p2, p3);\n}\n\nconst float PI = 3.1415926535;\nconst float PI_2 = PI / 2.;\n\nconst float schottky1R = 100.;\nconst float schottky2R = 100.;\nconst float schottky3R = 150.;\nvec3 schottky1 = vec3(100, 200, schottky1R);\nvec3 schottky2 = vec3(100, -200, schottky2R);\nvec3 schottky3 = vec3(250, 0, schottky3R);\n\n\n// Parabolic Generator\nvec3 C1 = vec3(-50, 0, 150.);\nvec3 C2 = vec3(0, 0, 200);\nvec3 C1d; // C1' = I_C2(C1)\n\nconst int MAX_ITERATIONS = 55;\nfloat colNum = 0.;\nint iterations = 0;\nfloat IIS(vec2 pos){\n    colNum = 0.;\n    float loopNum = 0.;\n\tbool cont = false;\n\tfor(int i = 0 ; i < MAX_ITERATIONS ; i++){\n        if(i > iterations) break;\n\t\tcont = false;\n        \n        \n\t\tif(distance(pos, schottky1.xy) < schottky1.z){\n\t\t\tpos = circleInvert(pos, schottky1);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(distance(pos, schottky2.xy) < schottky2.z){\n\t\t\tpos = circleInvert(pos, schottky2);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(distance(pos, schottky3.xy) < schottky3.z){\n\t\t\tpos = circleInvert(pos, schottky3);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}// Parabolic generator\n        else if(distance(pos, C1.xy) < C1.z){\n           pos = circleInvert(pos, C1);\n           pos = circleInvert(pos, C2);\n           cont = true;\n           //loopNum++;\n        }else if(distance(pos, C1d.xy) >= C1d.z){\n           pos = circleInvert(pos, C2);\n           pos = circleInvert(pos, C1);\n           cont = true;\n           //loopNum++;\n        }\n        \n\t\tif(cont == false) break;\n\t}\n\n\treturn loopNum;\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 renderGen(const vec2 pos, const vec3 C1, const vec3 C2, const vec3 C1d){\n    if(distance(pos, C1.xy) < C1.z){\n    \treturn vec3(.5, 0, 0);\n    }else if(distance(pos, C2.xy) < C2.z){\n    \treturn vec3(0, .5, 0);\n    }else if(distance(pos, C1d.xy) < C1d.z){\n    \treturn vec3(0, 0, .5);\n    }\n    return vec3(0);\n}\n\nvec3 gammaCorrect(vec3 c){\n    const float gammaCoeff = 1. / 2.2;\n\treturn vec3(pow(c.x, gammaCoeff),\n               \tpow(c.y, gammaCoeff),\n               \tpow(c.z, gammaCoeff));\n}\n\n//w: start time\n//s: duration\nfloat scene(in float t, in float w, in float s){\n    return clamp(t - w, 0.0, s) / s;  \n}\n\n\nfloat expEasingIn(float t){\n    return pow( 2., 13. * (t - 1.) );\n}\nfloat expEasingOut(float t) {\n\treturn -pow( 2., -10. * t) + 1.;\n}\n\nfloat circEasingInOut(float t){\n\tt /= .5;\n\tif (t < 1.) return -.5 * (sqrt(1. - t*t) - 1.);\n\tt -= 2.;\n\treturn .5 * (sqrt(1. - t*t) + 1.);\n}\n\nfloat circEasingIn(float t){\n\treturn -  (sqrt(1. - t*t) - 1.);\n}\n\n\nconst float SAMPLE_NUM = 20.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 sum = vec3(0);\n    float t = mod(iTime, PI * 6. / 1.6);\n\tfloat ratio = iResolution.x / iResolution.y / 2.0;\n    \n    float rotation = t * 1.6;\n    vec2 contactP = vec2(C2.z * cos(rotation), C2.z * sin(rotation));\n    C1.xy = contactP - vec2(C1.z * cos(rotation), C1.z * sin(rotation));\n    C1d = circleInvertOnCircle(C1, C2);\n    \n    float rotationS1 = rotation + PI_2;\n    contactP = vec2(C2.z * cos(rotationS1), C2.z * sin(rotationS1));\n    schottky1.xy = contactP - vec2(schottky1.z * cos(rotation),\n                                   schottky1.z * sin(rotation));\n    \n    float rotationS2 = rotation + PI + PI_2;\n    contactP = vec2(C2.z * cos(rotationS2), C2.z * sin(rotationS2));\n    schottky2.xy = contactP - vec2(schottky2.z * cos(rotation), \n                                   schottky2.z * sin(rotation));\n\n    float rotationS3 = rotation + PI;\n    contactP = C1d.xy + vec2(C1d.z * cos(rotationS3), C1d.z * sin(rotationS3));\n    schottky3.xy = contactP - vec2(schottky3.z * cos(rotationS3),\n                                   schottky3.z * sin(rotationS3));\n \n    float startTime = 0.;\n    schottky1.z = mix(0., schottky1R,\n        \t\t\t  expEasingIn(scene(t, startTime, 1.)));\n    startTime += 2.;\n    \n    iterations += (t > startTime + 0.1) ? 1 : 0;\n    iterations += (t > startTime + 0.2) ? 1 : 0;\n    iterations += (t > startTime + 0.3) ? 1 : 0;\n    iterations += (t > startTime + 0.4) ? 1 : 0;\n    iterations += (t > startTime + 0.5) ? 1 : 0;\n    iterations += (t > startTime + 0.6) ? 1 : 0;\n    iterations += (t > startTime + 0.7) ? 1 : 0;\n    iterations += (t > startTime + 0.8) ? 1 : 0;\n    iterations += (t > startTime + 0.9) ? 1 : 0;\n    iterations += (t > startTime + 1.) ? 1 : 0;\n    \n    startTime += 1.;\n    \n    iterations += int(mix(0., 30.,\n                         scene(t, startTime, 0.5)));\n    startTime += 0.5;\n    \n    schottky2.z = mix(0., schottky2R,\n        \t\t\t  expEasingIn(scene(t, startTime, 1.)));\t\n    startTime += 1.5;\n  \n    schottky3.z = mix(0., schottky3R,\n        \t\t\t  expEasingIn(scene(t, startTime, 1.)));\n    startTime += 2.;\n    \n    schottky1.z += mix(0., -schottky1R,\n        \t\t\t  expEasingIn(scene(t, startTime, 1.)));\n    startTime += 1.;\n    \n    schottky2.z += mix(0., -schottky2R,\n        \t\t\t  expEasingIn(scene(t, startTime, 1.)));\t\n    startTime += 1.;\n  \n    schottky3.z += mix(0., -schottky3R,\n        \t\t\t  expEasingIn(scene(t, startTime, 1.)));\n    \n    for(float i = 0. ; i < SAMPLE_NUM ; i++){\n        vec2 position = ( (fragCoord.xy + rand2n(fragCoord.xy, i)) / iResolution.yy ) - vec2(ratio, 0.5);\n\t\tposition = position * 1800.;\n//        position *= 1.2 + 1. * sin(t);\n//        position.x += 800. * cos(t);\n        \n        float loopNum = IIS(position);\n\n        if(loopNum >  0.){\n            sum += hsv2rgb(vec3(0.01 + 0.03 * (loopNum - 1.),1.0,1.0));\n        }else{\n            sum += renderGen(position, C1, C2, C1d);\n            //sum += vec3(0.,0.,0.);\n        }\n    }\n    fragColor = vec4(gammaCorrect(sum/SAMPLE_NUM), 1.);\n}","name":"Image","description":"","type":"image"}]}