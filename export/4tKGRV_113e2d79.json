{"ver":"0.1","info":{"id":"4tKGRV","date":"1475604000","viewed":243,"name":"Raymarcher + Diffuse + Shadows","username":"efairbanks","description":"It's what it says it is. Maybe not yet.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["phong","raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct ray{\n \tvec3 position;\n    vec3 direction;\n};\n\n// get the distance from a torus (how does this work?)\nfloat distTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// get the distance from a sphere\nfloat distSphere( vec3 p, float s )\n{\n  p = p - vec3(0.,0.,-0.25);\n  return length(p)-s;\n}\n\nfloat distBox(vec3 p, vec3 b, float roundness)\n{\n\treturn length(max(abs(p)-(b-vec3(roundness)),0.0))-roundness;\n}\n\nray getLookRayFlawed(vec2 uv, vec3 eye, vec3 target, float fov)\n{\n\ttarget = vec3(target.x + (uv.x*fov), target.y + (uv.y*fov), target.z);\n    vec3 fwdDirection = normalize(target-eye);\n    return ray(eye,fwdDirection);\n}\n\nray getLookRay(vec2 uv, vec3 cameraPos, vec3 target, float fov)\n{\n\tvec3 forward = normalize(target-cameraPos);\n    vec3 up = vec3(0.,1.,0.);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(forward,right));\n    \n    right = right*uv.x*fov;\n    up = up*uv.y*fov;\n    \n    return ray(cameraPos,right+up+forward);\n}\n/*\nfloat dist(vec3 p) {\n\tfloat d = 0.;\n    \n    d = distBox(p-vec3(0.,0.,-0.15),vec3(0.2,0.2,0.15),0.05);\n    d = max(-distSphere(p+vec3(0.,0.,-0.1), 0.2),d);\n    d += 0.005;\n    \n    float e = 0.;\n    \n    e = distTorus(p-vec3(0.,0.,-0.25), vec2(0.05+(0.02*sin(iTime*4.4)), 0.01));\n    e = max(-distTorus(p-vec3(0.,0.,-0.25), vec2(0.11+(0.02*sin(iTime*4.4)), 0.055)),e);\n    e = min(distSphere(p, 0.03+(0.01*sin((iTime+0.14)*4.4))),e);\n    e -= 0.005;\n    \n    float f = 0.;\n    f = min(d, e);\n    \n\td = f;\n    \n    return d;\n}\n*/\n\nfloat dist(vec3 p)\n{\n\tfloat d = 0.;\n    \n    d = distBox(p, vec3(0.09), 0.05);\n    d = max(-distTorus(p, vec2(0.08,0.045)), d);\n    d = min(distSphere(p-vec3(0.,-0.15,0.25), 0.04), d);\n    \n    return d;\n}\n\nfloat shadow(vec3 lightPos, vec3 pointPos)\n{\n    const float maxSteps = 200.;\n\tfloat hitDistance = 0.0005;\n    float distanceTravelled = 0.;\n    ray lookRay = ray(lightPos,normalize(pointPos-lightPos));\n    for(float i=0.0; i<maxSteps; i++)\n    {\n        vec3 rayTip = lookRay.position + (lookRay.direction * distanceTravelled);\n        float nextDistanceTravelled = dist(rayTip);\n        float distanceFromPoint = distance(rayTip,pointPos);\n        if(distanceFromPoint < hitDistance) {\n            return 1.;\n        }\n        distanceTravelled += nextDistanceTravelled;\n    }\n    return 0.;\n}\n\n// ----------------------------- //\n// --- DIDN'T WRITE THIS ONE --- //\n// ----------------------------- //\nconst float grad_step = 0.02;\n// computes the surface normal for a given point\n// on the shape\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist( pos + dx ) - dist( pos - dx ),\n\t\t\tdist( pos + dy ) - dist( pos - dy ),\n\t\t\tdist( pos + dz ) - dist( pos - dz )\n\t\t)\n\t);\n}\n\n// ------------------------ //\n// --- BACK TO MY STUFF --- //\n// ------------------------ //\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // scale fragCoord xy to 0.0 -> 1.0\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    // transform uv x/y to go from -1.0 -> 1.0\n    uv = uv * vec2(2) - vec2(1);\n    // tranform uv x axis so that it's not skewed by aspect ratio\n    uv.x = uv.x * iResolution.x / iResolution.y;\n    \n    float mask = 1.0-distance(uv, vec2(0.,0.));\n    vec3 rot = vec3(-6.,-6.,-6.);\n    rot = vec3(sin(iTime), cos(iTime*0.5), cos(iTime)) * 30.;\n    ray lookRay = getLookRay(uv, rot, vec3(0.,0.,0.), 0.005);\n    \n    // begin raymarch\n    const float maxSteps = 128.;\n    float hitDistance = 0.0005;\n    float distanceTravelled = 0.;\n    float forwardLight = 0.;\n    vec3 rayTip = vec3(0.,0.,0.);\n    float steps = 0.;\n\tfor(float i=0.0; i<maxSteps; i++)\n    {\n        vec3 ray = lookRay.position + (lookRay.direction * distanceTravelled);\n        float nextDistanceTravelled = dist(ray);\n        if(nextDistanceTravelled < hitDistance) {\n        \tforwardLight =  1.-(i/maxSteps);\n            rayTip = ray;\n            break;\n        }\n        distanceTravelled += nextDistanceTravelled;\n        if(i >= maxSteps-1.) {\n        \tfragColor = vec4(vec3(0.1,0.1,0.15),1.);\n            return;\n        }\n    }\n    \n    fragColor = vec4(vec3(forwardLight),1.);\n    vec3 n = gradient(rayTip);\n    vec3 light1Pos = vec3(0.,-10.,0.);\n    vec3 light2Pos = vec3(sin(iTime*3.),cos(iTime*3.),cos(iTime*3.));\n    float light1 = max(dot(n,normalize(light1Pos)),0.1)*0.5;\n    float light2 = max(dot(n,normalize(light2Pos)),0.1)*0.5;\n    \n    light1 *= shadow(light1Pos,rayTip);\n    light2 *= shadow(light2Pos,rayTip);\n    \n    float light = light1 + light2;\n    \n    fragColor = vec4(vec3(.95,.85,.6)*vec3(light), 1.);\n    //fragColor = vec4(vec3(1.-steps/maxSteps), 1.);\n    //fragColor = vec4(shading( rayTip, n, rot ), 1.);\n    //fragColor = vec4(n, 1.);\n}","name":"Image","description":"","type":"image"}]}