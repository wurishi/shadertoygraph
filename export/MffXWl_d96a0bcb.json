{"ver":"0.1","info":{"id":"MffXWl","date":"1706988883","viewed":93,"name":"Smooth Life Naive Convolution","username":"afmika","description":"Simple shader implementing Rafler's paper","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["convolution","gameoflife","cellularautomata"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 zoom(vec2 uv) {\n    float zoom = 0.5 + 0.5 * sin(iTime / 20.);\n    vec2 scale = vec2(0.5);\n    return (uv - scale) * max(0.4, zoom) + scale;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = zoom(uv);\n    fragColor = texture(iChannel0, uv);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float randBW(vec2 co) {\n    return (fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453) > 0.5) ? 1. : 0.;\n}\n\n\n#define NEW_COL iChannel0\n#define SELF iChannel1\n#define TEST_INIT iChannel2\n\nbool cooldown() {\n    int frame = 100;\n    return iFrame % 10 == 0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 color = vec4(0.);\n    if (iFrame > 4) { // small delay\n        int fcount = 1;\n        bool retexture = 0 == iFrame % fcount;\n        if (retexture) {\n            color = texture(NEW_COL, uv);\n        } else {\n            // do nothing\n            color = texture(SELF, uv);\n        }\n    } else {\n       // init\n       // custom image\n       color = vec4(length(fwidth(step(0.5, texture(TEST_INIT, uv)))));\n       // noise\n       // color = vec4(1.) * randBW(fragCoord);\n    }\n    fragColor = color;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define STORAGE_BUFF iChannel0\n#define PI 3.141592653589793\n\n#define ALPHA_1 0.028\n#define ALPHA_2 0.147\n\n// Ref: https://arxiv.org/abs/1111.1567\n\n// kernel parameters\nconst float Ri = 3.;\nconst float Ro = 3. * Ri;\nconst float full_area = PI * Ro * Ro;\nconst float inner_area = PI * Ri * Ri;\nconst float ring_area = full_area - inner_area;\n\n// transition parameters\nconst float b1 = 0.278; // birth low\nconst float d1 = 0.267; // death low\nconst float b2 = 0.365; // birth high\nconst float d2 = 0.445; // death high\n\n// time step\nfloat dt = 0.2;\n\n\nfloat sigmoid(float alpha, float x, float a) {\n    return 1. / (1. + exp(-(x - a) * 4. / alpha));\n}\n\nfloat sigmoid_1(float x, float a) {\n    return sigmoid(ALPHA_1, x, a);\n}\n\nfloat sigmoid_2(float x, float a, float b) {\n    return sigmoid(ALPHA_2, x, a) * (1. - sigmoid(ALPHA_2, x, b));\n}\n\nfloat sig_m(float m, float a, float b) {\n    float alive_m = sigmoid_1(m, 0.5);\n    float dead_m = 1. - alive_m;\n    return a * dead_m + b * alive_m;\n}\n\n// S_nm\nfloat transition(float N, float M) {\n    return sigmoid_2(N, sig_m(M, b1, d1), sig_m(M,b2, d2));\n}\n\nfloat f(vec2 coord) {\n    vec4 col = (texture(STORAGE_BUFF, coord / iResolution.xy));\n    return (col.r + col.g + col.b) / 3.;\n}\n\n\n\nfloat delta(vec2 p) {   \n    // M := alive\n    // N := neighbours\n    float N = 0., M = 0.;\n    for (float dx = -Ro; dx <= Ro; dx += 1.) {\n        for (float dy = -Ro; dy <= Ro; dy += 1.) {\n            vec2 u = vec2(dx, dy);\n            float r = length(u);\n            // naive approach\n            if (r <= Ro) {\n                float value =  f(p + u);\n                if (r > Ri) N += value;\n                else M += value;\n            }\n        }\n    }\n    // normalize after convolution!\n    M = M / inner_area;\n    N = N / ring_area;\n\n    // Next state f(p, t + 1) := S(n, m) \n    float S_nm = transition(N, M);\n    // df(p)/dt\n    return 2. * S_nm - 1.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float next = clamp(\n        f(fragCoord) + delta(fragCoord) * dt,\n        0.,\n        1.\n    );\n    \n    fragColor = vec4(next, next, next, fragColor.a);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}