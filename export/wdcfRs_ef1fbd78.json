{"ver":"0.1","info":{"id":"wdcfRs","date":"1605768995","viewed":1010,"name":"Falling into a checkerboard","username":"rreusser","description":"On the theme of #swirledseries. The code is a bit messy, sorry.","likes":29,"published":1,"flags":0,"usePreview":0,"tags":["checkerboard","complex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int octaves = 4;\nconst int steps = 8;\nconst int zoomOctaves = 5;\nconst float smoothLoopFudgeFactor = 10.5;\nconst int AA = 3;\nconst float period = 3.0;\nconst float blur = 1.4 / 60.0 / period;\n\nvec2 f (vec2 zView, float t) {\n    t = fract(t);\n    float range = exp(-t * float(zoomOctaves) * log(float(steps)));\n    vec2 phase = cexp(vec2(0, 1.0 * PI * t));\n    vec2 z0 = mix(vec2(0.0), vec2(5.0 / 2.0), (exp(-smoothLoopFudgeFactor * t) - 1.0) / (exp(-smoothLoopFudgeFactor) - 1.0));\n\n    zView = cmul(zView, cmul(phase, phase));\n    vec2 fz = z0 + zView * range;// * 1.25;\n    return fz; \n}\n\nfloat checkerboard (vec2 xy) {\n  vec2 f = fract(xy * 0.5) * 2.0 - 1.0;\n  return f.x * f.y > 0.0 ? 1.0 : 0.0;\n}\n\nfloat rectangularDomainColoring (vec4 f_df,\n                     vec2 steps,\n                     vec2 baseScale,\n                     float justCheckerboard\n) {\n  float cmagRecip = 1.0 / hypot(f_df.xy);\n  baseScale *= 10.0;\n\n  vec2 znorm = f_df.xy * cmagRecip;\n  float cmagGradientMag = hypot(vec2(dot(znorm, f_df.zw), dot(vec2(znorm.y, -znorm.x), f_df.zw)));\n\n  float xContinuousScale = log2(cmagGradientMag) / log2(steps.x);\n  float xDiscreteScale = floor(xContinuousScale);\n  float xScalePosition = 1.0 - (xContinuousScale - xDiscreteScale);\n\n  float yContinuousScale = log2(cmagGradientMag) / log2(steps.y);\n  float yDiscreteScale = floor(yContinuousScale);\n  float yScalePosition = 1.0 - (yContinuousScale - yDiscreteScale);\n\n  vec2 scalePosition = 1.0 - vec2(xContinuousScale, yContinuousScale) + vec2(xDiscreteScale, yDiscreteScale);\n  vec2 scaleBase = vec2(pow(steps.x, -xDiscreteScale), pow(steps.y, -yDiscreteScale)) / baseScale;\n\n  float totalWeight = 0.0;\n  float shading = 0.0;\n  vec2 invSteps = 1.0 / steps;\n  vec2 octaveScale = vec2(1.0);\n  vec2 grid = vec2(0.0);\n  vec2 gridScaleBase = vec2(\n    pow(steps.x, xScalePosition),\n    pow(steps.y, yScalePosition)\n  );\n\n  for(int i = 0; i < octaves; i++) {\n    float w0 = i == 0 ? 1e-4 : 1.0 + float(i);\n    float w1 = i == octaves - 1 ? 1e-4 : 1.0 + float(i + 1);\n    float w = mix(w0, w1, xScalePosition);\n    totalWeight += w;\n    vec2 value = f_df.xy * scaleBase * octaveScale;\n\n    vec2 gridSlope = baseScale * gridScaleBase / octaveScale / steps;\n\n    shading += w * checkerboard(value);\n    \n    octaveScale *= invSteps;\n  }\n\n  return 1.0 - shading / totalWeight;\n}\n\nfloat color (vec2 z, float t) {\n  //float justCheckerboard = (1.0 - smoothstep(0.1, 0.3, t) * smoothstep(0.95, 0.8, t));\n  //t = smoothstep(0.1, 0.9, t);\n  vec2 fz = f(2.0 * z - 0.4, t);\n\n  vec4 fdf = vec4(fz, vec2(hypot(dFdx(fz)), hypot(dFdy(fz))));\n\n  return rectangularDomainColoring(\n      fdf,\n      vec2(float(steps)), // steps\n      vec2(0.5), // scale\n      0.0 //justCheckerboard\n  );\n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord ) {\n    float sum = 0.0;\n    float t = iTime / period;\n\n    float tf = fract(t);\n    vec2 uv = 0.5 + (fragCoord / iResolution.xy - 0.5) * vec2(iResolution.x / iResolution.y, 1.0);\n\n    for (int i = 0; i < AA; i++) {\n      for (int j = 0; j < AA; j++) {\n        vec2 offset = (vec2(i + 1, j + 1) / float(AA + 1) - 0.5) / iResolution.xy;\n        //float tOffset = random(gl_FragCoord.xy + t + float(i) * 0.005915 + float(j) * 0.025901);\n        float tOffset = fract(100.0 * 1.61803398875 * float(i + j * AA));\n        float tt = fract(t + tOffset * blur);\n\n        vec2 z = ((uv + offset) - 0.5) * 8.0;\n\n        float c = color(z, tt);\n\n        sum += c;\n      }\n    }\n    sum /= float(AA * AA);\n    vec2 pos = 2.0 * fragCoord / iResolution.xy - 1.0;\n    float vignette = max(1.0 - 0.4 * length(pos), 0.0);\n    vignette *= vignette;\n    fragColor = vec4(vec3(pow(clamp(sum, 0.0, 1.0) * vignette, 0.5)), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Complex math! Beware that these functions are not all great for overflow,\n// even though a GPU is precisely the sort of place where you ought to be \n// *very* concerned about overflow.\n//\n// This also includes a partial implementation of automatic differentiation\n// for complex arithmetic using vec4 as a + bi --> vec4(a, b, da, db). This\n// may be used to successfully avoid standard derivatives, though I just\n// didn't find it worthwhile when standard derivatives are so easy and well\n// supported.\n\n#define PI 3.141592653589793238\n#define TO_RADIANS 0.01745329251\n#define HALF_PI 1.57079633\n#define HALF_PI_INV 0.15915494309\n#define PI_INV 0.31830988618\n#define TWO_PI 6.28318530718\n#define E 2.71828182845904590\n\nfloat hypot (vec2 z) {\n  float x = abs(z.x);\n  float y = abs(z.y);\n  float t = min(x, y);\n  x = max(x, y);\n  t = t / x;\n  return x * sqrt(1.0 + t * t);\n}\n\nvec2 cadd (vec2 a, vec2 b) {\n  return a + b;\n}\n\nvec2 csub (vec2 a, vec2 b) {\n  return a - b;\n}\n\nfloat cmod (vec2 z) {\n  return hypot(z);\n} \n\nvec2 csqrt (vec2 z) {\n  float t = sqrt(2.0 * (cmod(z) + (z.x >= 0.0 ? z.x : -z.x)));\n  vec2 f = vec2(0.5 * t, abs(z.y) / t);\n\n  if (z.x < 0.0) f.xy = f.yx;\n  if (z.y < 0.0) f.y = -f.y;\n\n  return f;\n}\n\n/*\nfloat sinh (float x) {\n  return 0.5 * (exp(x) - exp(-x));\n}\n\nfloat cosh (float x) {\n  return 0.5 * (exp(x) + exp(-x));\n}*/\n\nvec2 sinhcosh (float x) {\n  vec2 ex = exp(vec2(x, -x));\n  return 0.5 * (ex - vec2(ex.y, -ex.x));\n}\n\nfloat cabs (vec2 z) {\n  return cmod(z);\n}\n\nvec2 clog(vec2 z) {\n  return vec2(\n    log(hypot(z)),\n    atan(z.y, z.x)\n  );\n}\n\nvec2 catan (vec2 z) {\n  float a = z.x * z.x + (1.0 - z.y) * (1.0 - z.y);\n  vec2 b = clog(vec2(1.0 - z.y * z.y - z.x * z.x, -2.0 * z.x) / a);\n  return 0.5 * vec2(-b.y, b.x);\n} \n\nvec2 catanh (vec2 z) {\n  float oneMinus = 1.0 - z.x;\n  float onePlus = 1.0 + z.x;\n  float d = oneMinus * oneMinus + z.y * z.y;\n\n  vec2 x = vec2(onePlus * oneMinus - z.y * z.y, z.y * 2.0) / d;\n\n  vec2 result = vec2(log(hypot(x)), atan(x.y, x.x)) * 0.5;\n\n  return result;\n} \n\nvec2 cacos (vec2 z) {\n  vec2 a = csqrt(vec2(\n    z.y * z.y - z.x * z.x + 1.0,\n    -2.0 * z.x * z.y\n  ));\n\n  vec2 b = clog(vec2(a.x - z.y, a.y + z.x));\n  return vec2(HALF_PI - b.y, b.x);\n} \n\nvec2 cacosh (vec2 z) {\n  vec2 a = cacos(z);\n\n  if (a.y <= 0.0) {\n    return vec2(-a.y, a.x);\n  }\n\n  return vec2(a.y, -a.x);\n} \n\nvec2 cacot (vec2 z) {\n  return catan(vec2(z.x, -z.y) / dot(z, z));\n} \n\nvec2 cacoth(vec2 z) {\n  return catanh(vec2(z.x, -z.y) / dot(z, z));\n} \n\nvec2 casin (vec2 z) {\n  vec2 a = csqrt(vec2(\n    z.y * z.y - z.x * z.x + 1.0,\n    -2.0 * z.x * z.y\n  ));\n\n  vec2 b = clog(vec2(\n    a.x - z.y,\n    a.y + z.x\n  ));\n\n  return vec2(b.y, -b.x);\n} \n\nvec2 casinh (vec2 z) {\n  vec2 res = casin(vec2(z.y, -z.x));\n  return vec2(-res.y, res.x);\n} \n\nvec2 cacsch(vec2 z) {\n  return casinh(vec2(z.x, -z.y) / dot(z, z));\n} \n\nvec2 casec (vec2 z) {\n  float d = dot(z, z);\n  return cacos(vec2(z.x, -z.y) / dot(z, z));\n} \n\nvec2 casech(vec2 z) {\n  return cacosh(vec2(z.x, -z.y) / dot(z, z));\n} \n\nvec2 cconj (vec2 z) {\n  return vec2(z.x, -z.y);\n} \n\nvec2 ccos (vec2 z) {\n  return sinhcosh(z.y).yx * vec2(cos(z.x), -sin(z.x));\n} \n\nvec2 ccosh (vec2 z) {\n  return sinhcosh(z.x).yx * vec2(cos(z.y), sin(z.y));\n} \n\nvec2 ccot (vec2 z) {\n  z *= 2.0;\n  vec2 sch = sinhcosh(z.y);\n  return vec2(-sin(z.x), sch.x) / (cos(z.x) - sch.y);\n} \n\nvec2 ccoth(vec2 z) {\n  z *= 2.0;\n  vec2 sch = sinhcosh(z.x);\n  return vec2(sch.x, -sin(z.y)) / (sch.y - cos(z.y));\n} \n\nvec2 ccsc (vec2 z) {\n  float d = 0.25 * (exp(2.0 * z.y) + exp(-2.0 * z.y)) - 0.5 * cos(2.0 * z.x);\n\n  return sinhcosh(z.y).yx * vec2(sin(z.x), -cos(z.x)) / d;\n} \n\nvec2 ccsch (vec2 z) {\n  vec2 sch = sinhcosh(z.x);\n  float d = cos(2.0 * z.y) - (exp(2.0 * z.x) + exp(-2.0 * z.x)) * 0.5;\n  return vec2(-cos(z.y), sin(z.y)) * sch / (0.5 * d);\n} \n\nvec2 cdiv (vec2 a, vec2 b) {\n  float e, f;\n  float g = 1.0;\n  float h = 1.0;\n\n  if( abs(b.x) >= abs(b.y) ) {\n    e = b.y / b.x;\n    f = b.x + b.y * e;\n    h = e;\n  } else {\n    e = b.x / b.y;\n    f = b.x * e + b.y;\n    g = e;\n  }\n\n  return (a * g + h * vec2(a.y, -a.x)) / f;\n} \n\nvec2 cexp(vec2 z) {\n  return vec2(cos(z.y), sin(z.y)) * exp(z.x);\n} \n\nvec2 cinv (vec2 b) {\n  float e, f;\n  vec2 g = vec2(1, -1);\n\n  if( abs(b.x) >= abs(b.y) ) {\n    e = b.y / b.x;\n    f = b.x + b.y * e;\n    g.y = -e;\n  } else {\n    e = b.x / b.y;\n    f = b.x * e + b.y;\n    g.x = e;\n  }\n\n  return g / f;\n} \n\nvec2 cmul (vec2 a, vec2 b) {\n  return vec2(\n    a.x * b.x - a.y * b.y,\n    a.y * b.x + a.x * b.y\n  );\n}\n\nvec2 cmul (vec2 a, vec2 b, vec2 c) {\n  return cmul(cmul(a, b), c);\n}\n\nvec2 cmul (vec2 a, vec2 b, vec2 c, vec2 d) {\n  return cmul(cmul(a, b), cmul(c, d));\n}\n\nvec2 cmul (vec2 a, vec2 b, vec2 c, vec2 d, vec2 e) {\n  return cmul(cmul(a, b, c), cmul(d, e));\n}\n\nvec2 cmul (vec2 a, vec2 b, vec2 c, vec2 d, vec2 e, vec2 f) {\n  return cmul(cmul(a, b, c), cmul(d, e, f));\n} \n\nvec2 cpolar (vec2 z) {\n  return vec2(\n    atan(z.y, z.x),\n    hypot(z)\n  );\n} \n\nvec2 cpow (vec2 z, float x) {\n  float r = hypot(z);\n  float theta = atan(z.y, z.x) * x;\n  return vec2(cos(theta), sin(theta)) * pow(r, x);\n}\n\nvec2 cpow (vec2 a, vec2 b) {\n  float aarg = atan(a.y, a.x);\n  float amod = hypot(a);\n\n  float theta = log(amod) * b.y + aarg * b.x;\n\n  return vec2(\n    cos(theta),\n    sin(theta)\n  ) * pow(amod, b.x) * exp(-aarg * b.y);\n} \n\nvec2 csec (vec2 z) {\n  float d = 0.25 * (exp(2.0 * z.y) + exp(-2.0 * z.y)) + 0.5 * cos(2.0 * z.x);\n  return sinhcosh(z.y).yx * vec2(cos(z.x), sin(z.x)) / d;\n} \n\nvec2 csech(vec2 z) {\n  float d = cos(2.0 * z.y) + 0.5 * (exp(2.0 * z.x) + exp(-2.0 * z.x));\n  vec2 sch = sinhcosh(z.x);\n\n  return vec2(cos(z.y), -sin(z.y)) * sch.yx / (0.5 * d);\n} \n\nvec2 csin (vec2 z) {\n  return sinhcosh(z.y).yx * vec2(sin(z.x), cos(z.x));\n} \n\nvec4 csincos (vec2 z) {\n  float c = cos(z.x);\n  float s = sin(z.x);\n  return sinhcosh(z.y).yxyx * vec4(s, c, c, -s);\n} \n\nvec2 csinh (vec2 z) {\n  return sinhcosh(z.x) * vec2(cos(z.y), sin(z.y));\n} \n\nvec2 csqr (vec2 z) {\n  return vec2(\n    z.x * z.x - z.y * z.y,\n    2.0 * z.x * z.y\n  );\n} \n\nvec2 ctan (vec2 z) {\n  vec2 e2iz = cexp(2.0 * vec2(-z.y, z.x));\n\n  return cdiv(\n    e2iz - vec2(1, 0),\n    vec2(-e2iz.y, 1.0 + e2iz.x)\n  );\n} \n\nvec2 ctanh (vec2 z) {\n  z *= 2.0;\n  vec2 sch = sinhcosh(z.x);\n  return vec2(sch.x, sin(z.y)) / (sch.y + cos(z.y));\n}\n","name":"Common","description":"","type":"common"}]}