{"ver":"0.1","info":{"id":"tdlSWX","date":"1572607258","viewed":255,"name":"fc_dynamo_artwork","username":"skaplun","description":"Artwork dedicated to FC Dynamo Kyiv.\nMany pieces of code stolen here from Shadertoy.\nUndefine #LIGHTNING for better performance\nIts quite a lot left to be implemented in this scene like shadows or better D char\nNeed to be fixed for non-chrome viewers","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["noise","sdf","bezier","simplex","dynamo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define LIGHTNING\n#define MOD3 vec3(.1031,.11369,.13787)\n\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat simplex_noise(vec3 p){\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n        \n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\nfloat lightning(vec2 uv, int steps){\n\tfloat m = 0.;\n    for(int i=0; i<steps; i++){\n        float f = floor(iTime * 20.) + float(i) * .5;\n        float b = \n            simplex_noise(vec3(f, uv.x * 1., 1.)) * .15 + \n            simplex_noise(vec3(f, uv.x * 5., 5.)) * .1 +\n            simplex_noise(vec3(f, uv.x * 15., 10.)) * .02;\n\n        float l = .000025 + (uv.x + .5) * .00001;\n        m += .0005/smoothstep(0., l*25e3, abs(b - uv.y));\n    }\n    \n    return min(m, 10.);\n}\n\n#define NB_LIGHTS 1\n\nstruct Light {\n \tvec3 pos;\n    vec3 color;\n};\n\nLight lights[NB_LIGHTS];\n\nfloat G1V ( float dotNV, float k ) {\n\treturn 1.0 / (dotNV*(1.0 - k) + k);\n}\n\nvec3 computePBRLighting( in Light light, in vec3 position, in vec3 N, in vec3 V, in vec3 albedo, in float roughness, in vec3 F0 ) {\n\n\tfloat alpha = roughness*roughness;\n\tvec3 L = normalize(light.pos.xyz - position);\n\tvec3 H = normalize (V + L);\n\n\tfloat dotNL = clamp (dot (N, L), 0.0, 1.0);\n\tfloat dotNV = clamp (dot (N, V), 0.0, 1.0);\n\tfloat dotNH = clamp (dot (N, H), 0.0, 1.0);\n\tfloat dotLH = clamp (dot (L, H), 0.0, 1.0);\n\n\tfloat D, vis;\n\tvec3 F;\n\n\t// NDF : GGX\n\tfloat alphaSqr = alpha*alpha;\n\tfloat pi = 3.1415926535;\n\tfloat denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n\tD = alphaSqr / (pi * denom * denom);\n\n\t// Fresnel (Schlick)\n\tfloat dotLH5 = pow (1.0 - dotLH, 5.0);\n\tF = F0 + (1.0 - F0)*(dotLH5);\n\n\t// Visibility term (G) : Smith with Schlick's approximation\n\tfloat k = alpha / 2.0;\n\tvis = G1V (dotNL, k) * G1V (dotNV, k);\n\n\tvec3 specular = /*dotNL **/ D * F * vis;\n\n\tvec3 ambient = vec3(.01);\n\n\tfloat invPi = 0.31830988618;\n\tvec3 diffuse = (albedo * invPi);\n\n\n\treturn ambient + (diffuse + specular) * light.color.xyz * dotNL ;\n}\n\nvec3 addPBR( in vec3 position, in vec3 N, in vec3 V, in vec3 baseColor, in float metalMask, in float smoothness, in float reflectance) {\n\tvec3 color = vec3(0.0);\n\n    float roughness = 1.0 - smoothness*smoothness;\n    vec3 F0 = 0.16*reflectance*reflectance * (1.0-metalMask) + baseColor*metalMask;\n    vec3 albedo = baseColor;\n    \n    float s = 0.0;\n    \n    \n\tfor ( int i = 0; i < NB_LIGHTS; ++i ) {\n\t\tvec3 col = computePBRLighting(lights[i], position, N, V, albedo, roughness, F0);\n\t\tcolor += col;\t\n        s += 1.;//softshadow( position, normalize(lights[i].pos.xyz - position), 0.02, 2.5 );\n\t}\n\n\treturn color*s;\n}\n\nvec3 color(in vec2 fragCoord){\n    mat3 cam2worldMatrix;\n    vec3 localViewDir;\n    vec3 camPos;\n    setUpView(fragCoord, iResolution.xy, iTime, iMouse.xyz, camPos, localViewDir, cam2worldMatrix);\n    \n    vec3 color = vec3(1.);\n    vec4 geometry = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    if(geometry.w >= 0.){\n    \tfloat dist = geometry.w * (1./localViewDir.z) / (1./FARCLIP);\n        vec3 rd = cam2worldMatrix * localViewDir;\n        vec3 pos = camPos + rd * dist;\n        color = scene(pos, iChannel2, ASPECT, iTime).gba;\n    \t//vec3 nrm = inverse(cam2worldMatrix) * vec3(geometry.r, geometry.g, -geometry.b);\n        vec3 nrm = geometry.rgb;\n        color = addPBR(pos, nrm, -rd, color, .9, .5, .5)\n              * texelFetch(iChannel0, ivec2(fragCoord), 0).r;\n        //color = vec3(texelFetch(iChannel0, ivec2(fragCoord), 0).r);\n    }\n    \n    return color;\n}\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nconst vec3 BG = vec3(.05, .05, .075);\n#define AA 1\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    mat3 cam2worldMatrix;\n    vec3 localViewDir;\n    vec3 camPos;\n    setUpView(fragCoord, iResolution.xy, iTime, iMouse.xyz, camPos, localViewDir, cam2worldMatrix);\n    \n    vec2 uv = (2. * fragCoord - iResolution.xy)/iResolution.y;\n    vec3 bg = mix(\n        mix(vec3(0.0), BG,        \n        \tsmoothstep(-1.0,1.0,uv.y)),\n        mix(BG*0.5, vec3(0.0),        \n        \tsmoothstep(-1.0,1.0,uv.y)),\n        smoothstep(-1.0,1.0,uv.x));      \n    bg *= 0.8 + 0.2 * smoothstep(.1, 0., sin((uv.x-uv.y)*40.0));\n    bg = pow(bg, vec3(1./2.2));\n    \n    //if(fragCoord.y < (iResolution.y - 10.) && fragCoord.x > 15.)\n    //\tbg *= (1. - step(0., texelFetch(iChannel1, ivec2(fragCoord) - ivec2(15, -10), 0).w) * .33);\n    \n    float time = 0.25*iTime;\n    \n    lights[0] = Light(camPos + vec3(0., 1., 0.), vec3(1.));\n\t\n    vec3 clr = vec3(0.);\n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x){\n            clr += clamp(color(fragCoord + vec2(x, y) / float(AA)), 0., 1.);\n        }\n    clr /= float(AA * AA);\n    float mask = step(0., texelFetch(iChannel1, ivec2(fragCoord), 0).w);\n    clr = mix(bg, clr, mask);\n    fragColor = vec4(clr, 1.);\n\n#ifdef LIGHTNING\n    {\n        vec3 p1p = inverse(cam2worldMatrix) * vec3(-.175, .75, 0.);\n        vec3 p2p = inverse(cam2worldMatrix) * vec3(.175, .75, 0.);\n        vec3 p3p = inverse(cam2worldMatrix) * vec3(0., .9, 0.);\n        \n        vec3 r = sdBezier(p1p.xy, p3p.xy, p2p.xy, uv);\n        float s = sign(r.y);\n        float x = r.z - .5;\n        float y = r.x * s;\n        float l = lightning(vec2(x, y * 2.), 4) * step(abs(y), .1);\n        fragColor.rgb += (1.-mask) * vec3(63., 215., 252.)/256. * l;\n        \n        l = 0.;\n        for(float i=0.; i<4.; i++){\n\t\t\tp1p = inverse(cam2worldMatrix) * vec3(-.175, .75, 0.);\n            p2p = inverse(cam2worldMatrix) * mix(vec3(-.5, -.2, 0.), vec3(-.05, .5, 0.), texture(iChannel3, vec2(i * .17, iTime)).r);\n            p3p = inverse(cam2worldMatrix) * vec3(-.5, .4, 0.);\n            \n            r = sdBezier(p1p.xy, p3p.xy, p2p.xy, uv);\n            s = sign(r.y);\n            x = r.z - .5;\n            y = r.x * s;\n            l = max(l, lightning(vec2(x, y * 2.), 1));\n            \n            p1p = inverse(cam2worldMatrix) * vec3(.175, .75, 0.);\n            p2p = inverse(cam2worldMatrix) * mix(vec3(.5, -.2, 0.), vec3(.05, .5, 0.), texture(iChannel3, vec2(i * -.17, iTime)).r);\n            p3p = inverse(cam2worldMatrix) * vec3(.5, .4, 0.);\n\n            r = sdBezier(p1p.xy, p3p.xy, p2p.xy, uv);\n            s = sign(r.y);\n            x = r.z - .5;\n            y = r.x * s;\n            l = max(l, lightning(vec2(x, y * 2.), 1));\n        }\n        fragColor.rgb += (1.-mask) * vec3(63., 215., 252.)/256. * l;        \t\n    }\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float dist2Line(vec2 a, vec2 b, vec2 p) { \n    p -= a, b -= a;\n\tfloat h = clamp(dot(p, b) / dot(b, b), 0., 1.); \n\treturn length( p - b * h );                       \n}\n\nfloat TestCurve(vec2 uv){\n    uv = 1.0 - uv;\n    return 1.0 - dot(uv, uv);\n}\n\nfloat Cross( const in vec2 A, const in vec2 B ){\n    return A.x * B.y - A.y * B.x;\n}\n\nvec2 GetUV(const in vec2 A, const in vec2 B, const in vec2 C, const in vec2 P){\n    vec2 vPB = B - P;\n    float f1 = Cross(A-B, vPB);\n    float f2 = Cross(B-C, vPB);\n    float f3 = Cross(C-A, C-P);\n    \n    return vec2(f1, f2) / (f1 + f2 + f3);\n}\n\nfloat InCurve( const in vec2 A, const in vec2 B, const in vec2 C, const in vec2 P ){\n    vec2 vCurveUV = GetUV(A, B, C, P);\n    \n    float fResult = -1.0;\n\n    fResult = max(fResult, (-vCurveUV.x));\n    fResult = max(fResult, (-vCurveUV.y));\n    fResult = max(fResult, (vCurveUV.x + vCurveUV.y - 1.0));\n\n    float fCurveResult = TestCurve(vCurveUV);\n        \n    fResult = max(fResult, fCurveResult);   \n    \n    return fResult;\n}\n\nfloat InCurve2( const in vec2 A, const in vec2 B, const in vec2 C, const in vec2 P ){\n    vec2 vCurveUV = GetUV(A, B, C, P);\n    \n    float fResult = -1.0;\n\n    fResult = max(fResult, (vCurveUV.x + vCurveUV.y - 1.0));\n    \n    float fCurveResult = -TestCurve(vCurveUV);\n    \n    fResult = max(fResult, fCurveResult);   \n    \n    return fResult;\n}\n\nfloat InQuad( const in vec2 A, const in vec2 B, const in vec2 C, const in vec2 D, const in vec2 P )\n{\n    float f1 = Cross(B-A, A-P);\n    float f2 = Cross(C-B, B-P);\n    float f3 = Cross(D-C, C-P);\n    float f4 = Cross(A-D, D-P);\n    \n    return (max(max(max(f1, f2), f3), f4));\n}\n\nfloat InTri( const in vec2 A, const in vec2 B, const in vec2 C, const in vec2 P ){\n    float f1 = Cross(B-A, A-P);\n    float f2 = Cross(C-B, B-P);\n    float f3 = Cross(A-C, C-P);\n    \n    return (max(max(f1, f2), f3));\n}\n\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat dynamo(vec2 uv){\n    float fDist = 1.0;\n    uv *= vec2(.675, .6);\n    \n    const vec2 vP0 = vec2(-.164, -.146);\n    const vec2 vP1 = vec2(-.31, -.31);\n    const vec2 vP2 = vec2(-.383, -.1);\n    const vec2 vP3 = vec2(-.41, .13);\n    const vec2 vP4 = vec2(-.1, .179);\n    const vec2 vP5 = vec2(.215, .23);\n    const vec2 vP6 = vec2(.345, .038);\n    const vec2 vP7 = vec2(.56, -.29);\n    const vec2 vP8 = vec2(.165, -.445);\n    const vec2 vP9 = vec2(.02, -.5225);\n    const vec2 vP10 = vec2(-.21, -.386);\n    const vec2 vP11 = vec2(-.27, -.38);\n    const vec2 vP12 = vec2(-.24, -.42);\n    const vec2 vP13 = vec2(-.22, -.44);\n    const vec2 vP14 = vec2(-.165, -.4275);\n    const vec2 vP15 = vec2(-.022, -.4);\n    const vec2 vP16 = vec2(-.06, -.2);\n    const vec2 vP17 = vec2(-.17, .1);\n    const vec2 vP18 = vec2(-.03, .26);\n    const vec2 vP19 = vec2(.12, .425);\n    const vec2 vP20 = vec2(.134, .23);\n    const vec2 vP21 = vec2(.125, .06);\n    const vec2 vP22 = vec2(-.1, -.015);\n    \n    const vec2 vP23 = vec2(-.181, .1);\n    const vec2 vP24 = vec2(.05, .132);\n    const vec2 vP25 = vec2(.25, -.22);\n    const vec2 vP26 = vec2(-.075, -.4075);\n    \n    const vec2 vP27 = vec2(-.075, -.43);\n    const vec2 vP28 = vec2(-.16, -.49);\n    const vec2 vP29 = vec2(-.255, -.452);\n    const vec2 vP30 = vec2(.09, -.375);\n    const vec2 vP31 = vec2(.11, -.09);\n    const vec2 vP32 = vec2(-.025, -.1);\n    const vec2 vP33 = vec2(-.045, .1);\n    \n    const vec2 vP34 = vec2(-.038, .14);\n    const vec2 vP35 = vec2(.054, .246);\n    const vec2 vP36 = vec2(.005, .095);\n    const vec2 vP37 = vec2(-.05, .03);\n    const vec2 vP38 = vec2(-.142, .021);\n    const vec2 vP39 = vec2(-.142, -.025);\n    const vec2 vP40 = vec2(-.03, -.4);\n    \n    const vec2 vP41 = vec2(-.365, -.38);\n    const vec2 vP42 = vec2(-.24, -.338);\n    const vec2 vP43 = vec2(-.15, -.34);\n    const vec2 vP44 = vec2(-.1, -.4);\n    const vec2 vP45 = vec2(-.246, -.383);\n    const vec2 vP46 = vec2(-.09, -.404);\n    const vec2 vP47 = vec2(-.145, -.423);\n    const vec2 vP48 = vec2(-.25, -.39);\n    const vec2 vP49 = vec2(-.1, -.44);\n    const vec2 vP50 = vec2(-.1, -.41);\n    const vec2 vP51 = vec2(-.142, -.367);\n    const vec2 vP52 = vec2(-.1, -.42);\n    const vec2 vP53 = vec2(.01, -.445);\n    const vec2 vP54 = vec2(.01, -.41);\n    const vec2 vP55 = vec2(.01, -.43);\n    const vec2 vP56 = vec2(-.1, -.395);\n    fDist = min( fDist, InCurve2(vP0, vP1, vP2, uv));\n    fDist = min( fDist, InCurve2(vP2, vP3, vP4, uv));\n    fDist = min( fDist, InCurve2(vP4, vP5, vP6, uv));\n    fDist = min( fDist, InCurve2(vP6, vP7, vP8, uv));\n    fDist = min( fDist, InCurve2(vP8, vP9, vP10, uv));\n    fDist = min( fDist, InCurve(vP10, vP11, vP12, uv));\n    fDist = min( fDist, InCurve(vP12, vP13, vP14, uv));\n    fDist = min( fDist, InCurve(vP14, vP15, vP16, uv));\n    fDist = min( fDist, InCurve2(vP16, vP17, vP18, uv));\n    fDist = min( fDist, InCurve2(vP18, vP19, vP20, uv));\n    fDist = min( fDist, InCurve2(vP20, vP21, vP22, uv));\n    fDist = min( fDist, InCurve(vP0, vP2, vP23, uv));\n    fDist = min( fDist, InCurve(vP23, vP4, vP24, uv));\n    fDist = min( fDist, InCurve(vP24, vP6, vP25, uv));\n    fDist = min( fDist, InCurve(vP25, vP8, vP26, uv));\n    fDist = min( fDist, InCurve2(vP27, vP28, vP29, uv));\n    fDist = min( fDist, InCurve2(vP27, vP30, vP31, uv));\n    fDist = min( fDist, InCurve(vP31, vP32, vP33, uv));\n    fDist = min( fDist, InCurve(vP34, vP18, vP35, uv));\n    fDist = min( fDist, InCurve(vP35, vP20, vP36, uv));\n    fDist = min( fDist, InCurve(vP36, vP37, vP38, uv));\n    fDist = min( fDist, InQuad(vP37, vP38, vP39, vP22, uv));\n    fDist = min( fDist, InQuad(vP31, vP32, vP16, vP40, uv));\n    fDist = min( fDist, InTri(vP32, vP33, vP16, uv));\n    fDist = min( fDist, InCurve2(vP29, vP41, vP42, uv));\n    fDist = min( fDist, InCurve2(vP42, vP43, vP44, uv));\n    fDist = min( fDist, InTri(vP42, vP45, vP46, uv));\n    fDist = min( fDist, InCurve(vP47, vP29, vP48, uv));\n    fDist = min( fDist, InTri(vP29, vP49, vP50, uv));\n    fDist = min( fDist, InTri(vP51, vP52, vP53, uv));\n    fDist = min( fDist, InTri(vP54, vP56, vP55,  uv));\n    \n    return 1. - step(fDist, 0.);\n}\n\nfloat outline(vec2 uv){\n\tuv *= vec2(.675, .6);\n    uv *= 1.1;\n    uv.y += .1725;\n    uv.x = abs(uv.x);\n    \n    float outline = dist2Line(vec2(.69, 0.), vec2(0., .88), uv);\n    outline = smin(outline, dist2Line(vec2(.69, 0.), vec2(0., -.88), uv), .001);\n    \n    return outline - .02;\n}\n\nfloat crestShape(vec2 uv){\n    uv = abs(uv + vec2(0., .264));\n    float val = 1.;\n    val = min(val, distance(uv, vec2(0., 1.33)) - .075);\n    val = min(val, distance(uv, vec2(.925, 0.)) - .075);\n    val = min(val, dist2Line(vec2(0., 1.33), vec2(.925, 0.), uv) - .075);\n    val *= step(1. - uv.x * 1.02, uv.y * .72);\n    return val;\n}\n\n#define N 5\n#define D 2\n\nconst float PI_2 = 2.0 * PI;\nconst float DEGREES_TO_RADIANS = PI / 180.0;\nconst float EXTERNAL_ANGLE_N_3 = 150.0 * DEGREES_TO_RADIANS;\nconst float EXTERNAL_ANGLE_N_4 = 135.0 * DEGREES_TO_RADIANS;\n// https://en.wikipedia.org/wiki/Star_polygon#Simple_isotoxal_star_polygons\nfloat externalAngle(in int n, in int d) {\n    float internalAngle = PI * float(n - 2 * d) / float(n);  // the angle-radians of the \"convex tip\"\n\n    // The sum of all angles in a convex polygon with 2*n vertices is (2*n-2)*180deg\n    // Since n angles in the star polygon are convex and n angles are concave, we have\n    // n*internalAngle + n*complementAngle = (2*n-2)*180deg\n    // where complementAngle is the complement of the externalAngle we will use to find the \"intersection radius\"\n    // see https://qr.ae/TWhyAC\n    float complementAngle = PI_2 * float(n - 1) / float(n) - internalAngle;  // simplified\n    float externalAngle = PI_2 - complementAngle;\n    return\n        d == 2 && n == 3 ? EXTERNAL_ANGLE_N_3 :  // special cases for polygons with 3 and 4 vertices that make sense\n        d == 2 && n == 4 ? EXTERNAL_ANGLE_N_4 :  // but are not valid (n,d) star polygons\n        externalAngle;\n}\n\n// signed distance to a star polygon with n convex vertices and external angle (i.e. the \"concave\" angle between \"convex tips\")\nfloat sdStar(in vec2 p, in float r, in int n, in float externalAngle) {\n    // these 2 lines can be precomputed\n    float an = 6.2831853 / float(n);\n    float he = r * tan(0.5 * an);  // half-edge\n\n    // rotate to first sector\n    p = -p.yx;  // if you want the corner to be up\n    float bn = an * floor((atan(p.y, p.x) + 0.5 * an) / an);\n    vec2 cs = vec2(cos(bn), sin(bn));\n    p = mat2(cs.x, -cs.y, cs.y, cs.x) * p;\n\n    // flip symmetrically about the x-axis\n    p.y = abs(p.y);\n\n    // create a line SDF from the right-hand \"convex tip\" to the \"concave vertex\" on the x-axis\n    float complementRadius = he / tan(0.5 * externalAngle);\n    float ir = r - complementRadius;  // first, we need to know where the inner \"intersection radius\" is on the x-axis\n    vec2 a = vec2(r, he);\n    vec2 b = vec2(ir, 0.0);\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    vec2 line = pa - ba * h;\n\n    // use the cross product to project the point onto the line, determining the inside from the outside\n    float s = sign(ba.x * pa.y - ba.y * pa.x);\n    return length(line) * s;\n}\n\nfloat star(vec2 uv){\n    uv.x = abs(uv.x);\n    return sdStar(uv * 4.8 - vec2(1.44, 6.76), 1., N, externalAngle(N, D));\n}\n\nconst float e = 0.07;\nfloat gear(vec2 uv, vec2 center, float r, float nb, float t, float ph, float x){\n    uv -= center;\n    float angle = atan(uv.x, uv.y);\n    float v = length(uv) + r*t*(smoothstep(e, 1.-e, sin(ph + angle * nb)*0.5 + 0.5));\n    float res = max(v - r, distance(length(uv), r) - .1);\n    res = min(res, length(uv) - .1);\n    res = smin(res, distance(mod(angle, PI * 2./x), PI/(x*3.)) - .05 - (1. - length(uv)/r) * .2 + step(r - .05, length(uv)) * 100., .25);\n    return res;\n}\n\n#define INSIDE(c, r) (c.x >= r.x && c.x <= r.x + r.z && c.y >= r.y && c.y <= r.y+r.w)\n#define REMAP(from, to) vec2((from.x - to.x)/to.z, (from.y - to.y)/to.w)\nfloat getChar(sampler2D Font, vec2 P, int L){\n   return texture(Font, (P + vec2(L%16, 15-L/16))/16.).a;\n}\nstruct Char{\n\tvec4 region;\n\tint letter;\n};\n\n#define CITY_LENGTH 4\nconst Char city[CITY_LENGTH] = Char[CITY_LENGTH](\n    Char(vec4(-.28, -1.1, .15, .2), 75),\n    Char(vec4(-.13, -1.1, .15, .2), 78),\n    Char(vec4(0.0, -1.105, .15, .2), 207),\n    Char(vec4(.13, -1.105, .15, .2), 66));\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n    float a = radians(-90.);\n    uv *= mat2(cos(a), -sin(a), sin(a), cos(a)); \n    uv *= 1.05;\n    \n    if (iFrame < 5){\n    \tfragColor.r = dynamo(uv);\n        fragColor.g = outline(uv);\n        fragColor.b = crestShape(uv);\n\n        float star = star(uv);\n        if (star > 0.)\n            star = pow(star, 2.);\n        fragColor.a = star;\n\n        float g = gear(uv, vec2(0.), 0.4, 20., 0.15, 2.5, 3.);\n        fragColor.a = min(fragColor.a, g);\n        g = gear(uv, vec2(0.), 0.3, 14., 0.22, 2.2, 4.);\n        fragColor.g = min(fragColor.g, g);\n\n        for(int i=0; i<CITY_LENGTH; i++){\n            if(INSIDE(uv, city[i].region)){\n                vec2 r = REMAP(uv, city[i].region);\n                r.x = .25 + r.x * .505;\n                if(i == 1)\n                    r.y = 1. - r.y;\n                float T = getChar(iChannel1, r, city[i].letter);\n                fragColor.r = min(fragColor.r, T - .5);\n                break;\n            }\n        }\n    }else{\n\t\tfragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float march(vec3 camPos, vec3 rayDir){\n    float dis = 1e-5;\n    for(int i = 0; i < 200; i++){\n\t    float res = scene(camPos + rayDir * dis, iChannel0, ASPECT, iTime).x;\n        if(res < .001) \n            break;\n        dis += res * .25;\n        if(dis > FARCLIP)\n            return -1.;\n    }\n    return dis;\n}\n\nvec3 calcNormal(vec3 pos){\n    vec3 eps = vec3(.01, 0., 0.);\n\tvec3 nor = vec3(scene(pos + eps.xyy, iChannel0, ASPECT, iTime).x - scene(pos - eps.xyy, iChannel0, ASPECT, iTime).x,\n                    scene(pos + eps.yxy, iChannel0, ASPECT, iTime).x - scene(pos - eps.yxy, iChannel0, ASPECT, iTime).x,\n                    scene(pos + eps.yyx, iChannel0, ASPECT, iTime).x - scene(pos - eps.yyx, iChannel0, ASPECT, iTime).x);\n\treturn normalize(nor); \n}\n\nvec4 render(const in vec2 fragCoord){\n    mat3 cam2worldMatrix;\n    vec3 localViewDir;\n    vec3 camPos;\n    setUpView(fragCoord, iResolution.xy, iTime, iMouse.xyz, camPos, localViewDir, cam2worldMatrix);\n    \n    vec4 col;\n    vec3 pos = camPos;\n    vec3 rayDir = cam2worldMatrix * localViewDir;\n    \n    float dis = march(pos, rayDir);\n    if(dis > 0.0){\n        pos += rayDir * dis;\n        vec3 nor = calcNormal(pos);\n        nor = inverse(cam2worldMatrix) * nor;\n        nor.z *= -1.0;\n\n        float zDelta = localViewDir.z * dis / FARCLIP;\n        \n        col = vec4(nor, zDelta);\n    }else{\n        col = vec4(vec3(0.0), -1.);\n    }\n    \n    return col;\n}\n\n#define AA 1\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    //vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(0.);\n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x){\n            fragColor += render(fragCoord + vec2(x, y) / float(AA));\n        }\n    \n    fragColor /= float(AA * AA);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define COUNT 32\n#define FARCLIP 5.\n#define BIAS .3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 uv = fragCoord.xy / iResolution.xy;    \n\n    vec4 norz = texture(iChannel0, uv);\n    float depth = norz.w * FARCLIP;\n    float radius = .03;\n    float scale = radius / depth;\n    \n    float ao = 0.;\n    for(int i = 0; i < COUNT; i++)\n    {\n        vec2 randUv = (fragCoord.xy + 23.71 * float(i)) / iChannelResolution[1].xy;\n        vec3 randNor = texture(iChannel1, randUv).xyz * 2.0 - 1.0;\n        if(dot(norz.xyz, randNor) < 0.0)\n            randNor *= -1.0;\n        \n        vec2 off = randNor.xy * scale;\n        vec4 sampleNorz = texture(iChannel0, uv + off);\n        float depthDelta = depth - sampleNorz.w * FARCLIP;\n        \n        vec3 sampleDir = vec3(randNor.xy * radius, depthDelta);        \n        float occ = max(0.0, dot(normalize(norz.xyz), normalize(sampleDir)) - BIAS) / (length(sampleDir) + 1.0);\n        ao += 1. - pow(occ, .75);\n    }    \n    ao /= float(COUNT);\n    \n    fragColor = vec4(vec3(ao), 1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"float normpdf(in float x, in float sigma){\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec3 c = texture(iChannel0, fragCoord.xy / iResolution.xy).rgb;\n\tfragColor = vec4(c, 1.0);\n    {\n\t\t//declare stuff\n\t\tconst int mSize = 7;\n\t\tconst int kSize = (mSize-1)/2;\n\t\tfloat kernel[mSize];\n\t\tvec3 final_colour = vec3(0.0);\n\t\t\n\t\t//create the 1-D kernel\n\t\tfloat sigma = 7.0;\n\t\tfloat Z = 0.0;\n\t\tfor (int j = 0; j <= kSize; ++j)\n\t\t{\n\t\t\tkernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n\t\t}\n\t\t\n\t\t//get the normalization factor (as the gaussian has been clamped)\n\t\tfor (int j = 0; j < mSize; ++j)\n\t\t{\n\t\t\tZ += kernel[j];\n\t\t}\n\t\t\n\t\t//read out the texels\n\t\tfor (int i=-kSize; i <= kSize; ++i)\n\t\t{\n\t\t\tfor (int j=-kSize; j <= kSize; ++j)\n\t\t\t{\n\t\t\t\tfinal_colour += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel0, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n\t\n\t\t\t}\n\t\t}\n\t\tfragColor = vec4(final_colour/(Z*Z), 1.);\n\t}\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define FARCLIP 5.\n#define BLUE (vec3(51., 110., 185.)/255.)\n#define WHITE (vec3(245.)/255.)\n#define GOLD vec3(1.0, 0.71, 0.29)\n#define COPPER vec3(0.95, 0.64, 0.54)\n#define IRON vec3(0.56, 0.57, 0.58)\n#define ALUMINIUM vec3(0.91, 0.92, 0.92)\n#define SILVER vec3(0.95, 0.93, 0.88)\n#define ASPECT (iResolution.xy/iResolution.y)\n#define PI 3.14159265359\nconst vec2 GEAR_1_POS = vec2(.6, -.6);\nconst vec2 GEAR_2_POS = vec2(0.27, -1.);\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h){\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nvec4 opMin(in vec4 a, in vec4 b){\n    return (a.x < b.x) ? a : b;\n}\n\nvec4 scene(vec3 pos, sampler2D sam, vec2 aspect, float time){\n\tfloat a = radians(90.);\n    vec4 res = vec4(1., BLUE);\n    \n    {\n        vec3 p = pos - vec3(GEAR_1_POS, 0.);\n        float a = time * 5.;\n        p.xy *= mat2(cos(a), -sin(a), sin(a), cos(a));\n        p.xy /= aspect;\n        float shape = texture(sam, p.xy * .6 + .5, 0.).a;\n        res = opMin(res, vec4(opExtrussion(pos, max(shape, step(p.x, -.25)), .02), COPPER));\n        \n        p = pos - vec3(GEAR_2_POS, 0.);\n        a = -time * 5. + .9;\n        p.xy *= mat2(cos(a), -sin(a), sin(a), cos(a));\n        p.xy /= aspect;\n        shape = texture(sam, p.xy * .6 + .5, 0.).g;\n        res = opMin(res, vec4(opExtrussion(pos, max(shape, step(.35, length(p.xy))), .02), COPPER));\n    }\n\t\n    vec3 p = pos;\n    p.xy *= aspect;\n    p.xy *= mat2(cos(a), -sin(a), sin(a), cos(a));\n    \n    //TODO handle D letter separately //p.y *= sign(p.z);\n    vec4 shape = texture(sam, p.xy * .3 + .5, 0.);\n    res = opMin(res, vec4(opExtrussion(p, shape.b, .025), BLUE));\n    res = opMin(res, vec4(opExtrussion(p, max(shape.g, step(length(p.xy), .5)), .05), WHITE));\n    res = opMin(res, vec4(opExtrussion(p, shape.r, .05), WHITE));\n    res = opMin(res, vec4(opExtrussion(p, max(shape.a, step(pos.y, .5)), .025 * smoothstep(0., -.1, shape.a)), GOLD));\n    \n    return res;\n}\n\nmat3 SetCamera(vec3 ro, vec3 ta, float cr){\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid setUpView(in vec2 fragCoord, in vec2 iResolution, in float iTime, in vec3 iMouse, out vec3 camPos, out vec3 localViewDir, out mat3 cam2worldMatrix){\n\tvec2 uv = (2. * fragCoord.xy - iResolution.xy)/iResolution.y;\n    float mouse = mix(sin(iTime) * .5 + .5, iMouse.x/iResolution.x, step(1., iMouse.z)) * PI*.35 + PI*.25;\n    camPos = vec3(2.5 * cos(mouse), .5, 2.5 * sin(mouse));\n    vec3 camLookAt = vec3(0., .125, 0.);\n    cam2worldMatrix = SetCamera(camPos, camLookAt, 0.0);\n    localViewDir = normalize(vec3(uv, 1.5));\n}\n\nvec3 solveCubic(float a, float b, float c)\n{\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a bezier curve with endpoint extension\nvec3 sdBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{   \n    // This is to prevent 3 colinear points, but there should be better solution to it.\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    \n    // Calculate roots.\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec2 t = clamp(solveCubic(k.x, k.y, k.z).xy, 0.0, 1.0);\n    // note: 3rd root is actually unnecessary, it's never closest!\n    \n    // [Tom'2017] simplified calculations\n    vec2 dp1 = d + (c + b*t.x)*t.x;\n    float d1 = dot(dp1, dp1);\n    vec2 dp2 = d + (c + b*t.y)*t.y;\n    float d2 = dot(dp2, dp2);\n   \n    // Find closest distance and t\n    vec2 r = (d1 < d2) ? vec2(d1, t.x) : vec2(d2, t.y);\n   \n    // Find on which side (t=0 or t=1) is extension\n    vec2 e = vec2(step(0.,-r.y),step(1.,r.y));\n\n    // Calc. gradient\n    vec2 g = 2.*b*r.y + c;\n   \n    // Calc. extension to t\n    float et = (e.x*dot(-d,g) + e.y*dot(p-C,g))/dot(g,g);\n   \n    // Find closest point on curve with extension\n    vec2 dp = d + (c + b*r.y)*r.y + et*g;\n   \n    // Sign is just cross product with gradient\n    float s =  sign(g.x*dp.y - g.y*dp.x);\n   \n    return vec3(sqrt(r.x), s*length(dp), r.y + et);\n}","name":"Common","description":"","type":"common"}]}