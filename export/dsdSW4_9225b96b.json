{"ver":"0.1","info":{"id":"dsdSW4","date":"1680195257","viewed":560,"name":"materials :)","username":"Poisson","description":"Features : pbr, ibl, diffuse, roughness, glossy, metal, global illumination, glass refraction and caustics, bump mapping, textures, emission, lights, absorption, depth of field (dof). And for the post processing, chromatic aberration (CA).","likes":50,"published":1,"flags":32,"usePreview":1,"tags":["3d","raytracing","reflection","raytracer","ray","gi","materials","pathtracing","pathtracer","wood","ellipsoid","brdf","diffuse","path","pbr","bsdf","pathtraced"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Just a pbr shader to test materials.\n\n// aces tonemapper\nvec3 ACES(vec3 x) {\n    float a = 2.51;\n    float b =  .03;\n    float c = 2.43;\n    float d =  .59;\n    float e =  .14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = fragCoord/iResolution.xy;\n    \n    float w = texture(iChannel0, p).w; // numbers of renders\n    \n    // base texture with chromatic aberration\n    vec2 off = (p-.5)*.004; // CA offset\n    vec3 col = vec3(texture(iChannel0, p+off).r,\n                    texture(iChannel0, p    ).g,\n                    texture(iChannel0, p-off).b)/w;\n    \n    col = pow(col, vec3(.4545)); // gamma correction\n    col = ACES(col); // tonemapping\n   \n    // color grading\n    col = col*col*(3.-2.*col); // contrast\n    col = 1.85*col/(1.+col); // highlighs rollof\n\n    // vignette\n    col *= .5+.5*pow(16. * p.x*p.y*(1.-p.x)*(1.-p.y), .1);\n   \n    // output\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":3,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SKY_BOX 0\n\n// vec2 to float hash\nfloat hash(vec2 x) {\n\tfloat n = dot(x,vec2(127.1,311.7));\n\treturn fract(sin(n)*4568.7564);\n}\n\nfloat seed; // randoms seed\n\n// float hash\nfloat hash(void) {return fract(sin(seed+=.1)*4568.7564);}\n\n// normalized 3d vector\nvec3 uniformVector() {\n    float a = hash()*6.2831853;\n    float x = hash()*2.-1.;\n    float z = hash();\n    \n\treturn pow(z,1./3.)*vec3(sqrt(1.-x*x)*vec2(sin(a),cos(a)),x);\n}\n\n// random 3d vector\nvec3 randomVector() {\n    float a = hash()*6.2831853;\n    float x = hash()*2.-1.;\n    float z = hash();\n    float w = sqrt(hash());\n    \n\treturn w*pow(z,1./3.) * vec3(sqrt(1.-x*x)*vec2(sin(a),cos(a)),x);\n}\n\n// cosine distribued diffuse brdf\n// thanks to fizzer: http://www.amietia.com/lambertnotangent.html\nvec3 cosineDirection(vec3 n) {\n    float u = hash();\n    float v = hash();\n\n    float a = 6.283185*v;\n    float b = u*2.-1.;\n    vec3 rr = vec3(sqrt(1.-b*b)*vec2(cos(a),sin(a)),b);\n\n    return normalize(n + rr);\n}\n\n// ray ellipsoid intersection function\n// thanks to iq: https://iquilezles.org/articles/intersectors/\n// sph[0] is the center of the ellipsoid and sph[1] is the size\nvec4 elliIntersect(vec3 ro, vec3 rd, mat2x3 sph) {\n    vec3 oc = ro - sph[0];\n    vec3 r2 = sph[1]*sph[1];\n    \n    float a = dot(rd, rd/r2);\n\tfloat b = dot(oc, rd/r2);\n\tfloat c = dot(oc, oc/r2);\n\tfloat h = b*b - a*(c-1.); // discriminant\n    \n\tif (h<0.) return vec4(-1);\n    h = sqrt(h);\n    float t = (-b-h) / a;\n    vec3 n = normalize((oc + rd*t) / r2); // normal\n    \n    return vec4(t, n);\n}\n\n// ellipsoids\n#define NUM_SPHERES 11\nmat2x3 spheres[NUM_SPHERES];\n\n// intersection function\nfloat intersect(vec3 ro, vec3 rd, float tmax, out vec3 on, out float oid) {\n    float t = tmax; // final distance\n    \n    for (int i=0; i<NUM_SPHERES; i++) {\n        mat2x3 sph = spheres[i]; // current ellipsoid        \n        vec4 tn = elliIntersect(ro, rd, sph); // distance and normal\n        \n        if (tn.x>0. && tn.x<t) {\n            on = tn.yzw;\n            oid = float(1 + i); // ellipsoid id\n            t = tn.x;\n        }\n    }\n    \n    // plane\n    float h = (-.5-ro.y)/rd.y;\n    if (h>0. && h<t) {\n        on = vec3(0,1,0);\n        oid = 0.;\n        t = h;\n    }\n            \n    // output\n    return t<tmax ? t : -1.;\n}\n\n// 2d texture function\n// thanks to this great tutorial of the art of code:\n// https://www.youtube.com/watch?v=VaYyPTw0V84\nvec3 tex3D(sampler2D tex, vec3 p, vec3 n) {\n    vec3 xy = texture(tex, p.xy).rgb;\n    vec3 xz = texture(tex, p.xz).rgb;\n    vec3 yz = texture(tex, p.yz).rgb;\n    \n    vec3 m = abs(n);\n    return yz*m.x + xz*m.y + xy*m.z;\n}\n\n// texture bump mapping, thanks to Shane\n// bf is the bump factor\nvec3 texBump(sampler2D tex, vec3 p, vec3 n, float bf) {\n    const vec2 e = vec2(.0001, 0); // epsilon\n    \n    // normal of the texture\n    mat3 m = mat3(tex3D(tex, p - e.xyy, n),\n                  tex3D(tex, p - e.yxy, n),\n                  tex3D(tex, p - e.yyx, n));\n    \n    vec3 g = vec3(.299, .587, .114)*m; // luma\n    g = (g - dot(tex3D(tex,  p , n), vec3(.299, .587, .114)))/e.x; \n    g -= n*dot(n, g);\n                      \n    return g*bf;\n}\n\nvec3 skybox(vec3 rd) {\n    #if SKY_BOX==0\n    return pow(textureLod(iChannel1, rd, 0.).rgb, vec3(2.2));\n    #else\n    vec3 col = .3*mix(vec3(.4,.7,1), .5*vec3(.1,.3,.6), .5+.5*rd.y);\n    col += 6.*step(.98,dot(rd, vec3(.57735)));\n    return col;\n    #endif\n}\n\n// rendering\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = vec3(1); // final color\n    \n    for (int i=0; i<8; i++) { // 8 bounces of GI\n        vec3 n; float id; // normal and id\n        float t = intersect(ro, rd, 1e10, n, id); // distance\n\n        // background\n        if (t<0.) return col*skybox(rd);\n        vec3 p = ro + rd*t;\n        float fre = 1.+dot(rd, n); // fresnel\n\n        if (id<.5) { // wood material\n            vec3 bmp = texBump(iChannel3, p*.5, n, .0025);\n            n = normalize(n + bmp);\n            \n            ro = p + n*.0001;\n            \n            float rou = .1; // roughness\n            float ks = .1+.9*pow(fre, 5.)*(1.-rou); // reflectivity\n            \n            if (ks>hash()) { // rough reflection\n                rd = normalize(reflect(rd, n) + rou*randomVector());\n            } else { // diffuse\n                col *= pow(tex3D(iChannel3, p*.5, n), vec3(1.5));\n                rd = cosineDirection(n);\n            }\n        } else if (id<1.5) { // light\n            return col*5.;\n        } else if (id<2.5) { // orange plastic\n            ro = p + n*.0001;\n                        \n            float ks = .05+.95*pow(fre, 5.); // reflectivity\n            if (ks>hash()) { // reflection\n                rd = reflect(rd, n);\n            } else { // diffuse\n                col *= vec3(.9,.3,.1);\n                rd = cosineDirection(n);\n            }\n        } else if (id<3.5) { // green plastic\n            vec3 bmp = texBump(iChannel2, p*2., n, .04);\n            n = normalize(n + bmp);\n            \n            ro = p + n*.0001;\n            \n            float rou = .6; // roughness\n            float ks = .1+.9*pow(fre, 5.)*(1.-rou); // reflectivity\n            \n            if (ks>hash()) { // rough reflection\n                rd = normalize(reflect(rd, n) + rou*randomVector());\n            } else { // diffuse\n                col *= vec3(.2,.6,.1);\n                rd = cosineDirection(n);\n            }\n        } else if (id<4.5) { // rough metal\n            vec3 bmp = texBump(iChannel3, p*.5, n, .003);\n            n = normalize(n + bmp);\n            \n            col *= .9;\n            ro = p + n*.0001;\n            rd = reflect(rd, n);\n        } else if (id<5.5) { // gold\n            vec3 bmp = texBump(iChannel2, p*2., n, -.04);\n            n = normalize(n + bmp);\n            \n            col *= vec3(.9,.7,.3);\n            ro = p + n*.0001;\n            rd = reflect(rd, n);\n        } else if (id<6.5) { // light\n            return col*5.;\n        } else if (id<7.5) { // abstract (purple and gold)\n            vec3 bmp = texBump(iChannel2, p*2., n, .1);\n            n = normalize(n + bmp);\n            \n            ro = p + n*.0001;\n            \n            float h = tex3D(iChannel2, p*2., n).r;\n            if (h<.6) { // diffuse\n                col *= vec3(.3,.1,.9);\n                rd = cosineDirection(n);\n            } else { // gold\n                col *= vec3(.9,.6,.3);\n                rd = reflect(rd, n);\n            }\n        } else if (id<8.5) { // anisotropic metal (sort of)\n            vec3 bmp = texBump(iChannel3, p, n, .0);\n            n = normalize(n + bmp);\n                        \n            vec3 rou = vec3(.4,1,.4); // roughness\n\n            col *= vec3(.1,.3,.9);\n            ro = p + n*.0001;\n            rd = normalize(reflect(rd, n) + rou*randomVector());\n        } else if (id<9.5) { // absorption\n            float ior = 1.5; // refraction index\n            \n            // fresnel bias\n            float f0 = (1.-ior)/(1.+ior);\n            f0 = f0*f0;\n            float ks = f0 + (1.-f0)*pow(fre, 5.); // reflectivity\n            \n            float s = -sign(fre-1.); // inside or outside\n            \n            if (ks>hash()) { // reflection\n                ro = p+n*.0001;\n                rd = reflect(rd, n);\n            } else { // transmission\n                if (s>0.) col *= exp(-.2*t*vec3(1,2,3)); // absorption\n                ro = p - n*.001;\n                rd = refract(rd, n, s<0. ? ior : 1./ior);\n            }\n        } else if (id<10.5) { // normal glass\n            float ior = 1.5; // refraction index\n            \n            // fresnel bias\n            float f0 = (1.-ior)/(1.+ior);\n            f0 = f0*f0;\n            float ks = f0 + (1.-f0)*pow(fre, 5.); // reflectivity\n            \n            float s = -sign(fre-1.); // inside or outside\n            \n            if (ks>hash()) { // reflection\n                ro = p+n*.0001;\n                rd = reflect(rd, n);\n            } else { // transmission\n                ro = p - n*.001;\n                rd = refract(rd, n, s<0. ? ior : 1./ior);\n            }\n        } else if (id<11.5) { // emerald with gold\n            vec3 bmp = texBump(iChannel2, p*2., n, .07);\n            n = normalize(n + bmp);\n            \n            float h = tex3D(iChannel2, p*2., n).r;\n            if (h<.65) { // emerald\n                float ior = 2.4; // refraction index\n\n                // fresnel bias\n                float f0 = (1.-ior)/(1.+ior);\n                f0 = f0*f0;\n                float ks = f0 + (1.-f0)*pow(fre, 5.); // reflectivity\n\n                float s = -sign(fre-1.); // inside or outside\n\n                if (ks>hash()) { // reflection\n                    ro = p+n*.0001;\n                    rd = reflect(rd, n);\n                } else { // transmission\n                    if (s>0.) col *= exp(-.5*t*vec3(3,.2,2.5)); // absorption\n                    ro = p - n*.001;\n                    rd = refract(rd, n, s<0. ? ior : 1./ior);\n                }\n            } else { // gold\n                col *= vec3(.9,.6,.3);\n                ro = p + n*.0001;\n                rd = reflect(rd, n);\n            }\n        }\n    }\n            \n    // return black\n    return vec3(0);\n}\n\n// camera function\nmat3 setCamera(vec3 ro, vec3 ta) {\n    vec3 w = normalize(ta - ro); // forward vector\n    vec3 u = normalize(cross(w, vec3(0,1,0))); // side vector\n    vec3 v = cross(u, w); // up vector\n    return mat3(u, v, w);\n}\n\n#define SPP 5 // samples per pixel\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // setup scene\n    spheres[0] = mat2x3(-1.5,1.5,.5,.25,.25,.25);\n    spheres[1] = mat2x3(-1.5,0,0,.4,.5,.4);\n    spheres[2] = mat2x3(0,0,0,.4,.5,.4);\n    spheres[3] = mat2x3(1.5,0,0,.4,.5,.4);\n    spheres[4] = mat2x3(1.5,0,1.5,.4,.5,.4);\n    spheres[5] = mat2x3(1.5,1.5,-.5,.25,.25,.25);\n    spheres[6] = mat2x3(-1.5,0,1.5,.4,.5,.4);\n    spheres[7] = mat2x3(0,0,1.5,.4,.5,.4);\n    spheres[8] = mat2x3(0,0,-1.5,.4,.5,.4);\n    spheres[9] = mat2x3(1.5,0,-1.5,.4,.5,.4);\n    spheres[10] = mat2x3(-1.5,0,-1.5,.4,.5,.4);\n    \n    // normalized mouse coordinates\n    vec2 mo = (iMouse.xy - .5*iResolution.xy) / iResolution.y;\n    \n    vec3 tot = vec3(0); // accumulated color\n    for (int i=0; i<SPP; i++) {\n        // init randoms seed\n        seed = float(i)+iTime + hash(fragCoord/iResolution.xy);\n        \n        vec2 off = vec2(hash(), hash()) - .5; // AA offset\n        // pixel coordinates centered at the origin\n        vec2 p = (fragCoord+off - .5*iResolution.xy) / iResolution.y;\n        \n        float an = -mo.x*6.283185-1.5; // camera xz rotation\n        vec3 ro = 4.5*vec3(sin(an),.3+.7*mo.y,cos(an)); // ray origin\n        vec3 ta = vec3(0); // target\n        mat3 ca = setCamera(ro, ta); // camera matrix\n        vec3 rd = ca * normalize(vec3(p,1.5)); // ray direction\n        \n        // depth of field\n        \n        vec3 tn; float tid; // temporary variables\n        float t = intersect(ro, ca[2], 1e10, tn, tid); // focus distane\n        vec3 fp = ro + rd*t; // focus plane\n        \n        // distribution on a disk\n        float w = sqrt(hash()); // vector length\n        float a = hash()*6.283185; // angle\n        \n        ro += .03 * w*(ca[0]*sin(a) + ca[1]*cos(a)); // blur\n        rd = normalize(fp - ro);\n                \n        vec3 col = render(ro, rd); // render\n        tot += col;\n    }\n    tot /= float(SPP);    \n    \n    // blend with the previous frame\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = vec4(tot,1) + data*step(iMouse.z,0.);\n}","name":"Buffer A","description":"","type":"buffer"}]}