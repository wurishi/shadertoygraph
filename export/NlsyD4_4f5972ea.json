{"ver":"0.1","info":{"id":"NlsyD4","date":"1655986869","viewed":88,"name":"Assignment1 - Daniel Kuknyo","username":"BasicTask","description":"This is the 1st assignment for the ELTE computer graphics course. Please hit like if you think it's a good shader! ","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["graphics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float pi = 3.1415926535897932384626433832795;\n\nstruct Material {\n    vec3 color; // [0,1/pi]\n    float roughness; // [0,~7]\n    vec3 emission; // [0, inf]\n    float metalness; // 0.02-0.05 for non-metals, 0.6-0.9 for metals\n};\n\n// Material properties from: https://www.shadertoy.com/view/flXcWN\n#define LIGHTSRC(r,g,b)    Material(vec3(0,0,0)   , 1.      , vec3(r,g,b), 0.  )\n#define METALLIC(r,g,b,m)  Material(vec3(r,g,b)/pi, float(m), vec3(0,0,0), 0.9 )\n#define NONMETAL(r,g,b,m)  Material(vec3(r,g,b)/pi, float(m), vec3(0,0,0), 0.02)\n#define NOMATERIAL(r,g,b) Material(vec3(0,0,0), 0., vec3(0,0,0), 0.)\n\nconst Material colors[] = Material[](\n    METALLIC(  .6,  .4, .1, 0.03), // 0\n    NONMETAL( .15, .01,  1,   .1), // 1\n    NONMETAL(  .1,   1, .5,    1), // 2\n    NONMETAL(   1,   1,  1,  0.3), // 3\n    LIGHTSRC( 0.4, 0.4, 0.4),      // 4\n    NOMATERIAL(0.,  0., 0.)        // 5\n);\n\nstruct Sphere {\n    vec3 c;    // center\n    float r;   // radius\n    Material mat;\n    bool textured;\n};\n\nstruct Plane {\n    vec3 q0;   // any point on the plane\n    vec3 n;    // normal\n    Material mat;\n    bool textured;\n};\n\nstruct Triangle { // Barycentric coordinates for vertices\n    vec3 a;\n    vec3 b;\n    vec3 c;\n    Material mat;\n    bool textured;\n};\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s ) // Distance function for sphere\n{\n  return length(p)-s;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h ) // Distance function for plane\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c ) // Distance function for triangle\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nstruct Ray\n{\n\tvec3 p0;    // ray origin if tmin=0\n\tfloat tmin; // omit solutions t<tmin\n\tvec3 v;     // direction\n\tfloat tmax; // omit solutions t>tmax\n};\n\nstruct TraceResult\n{\n    vec3 n;  // Normal vector on surface\n    float t; // Distance taken on ray\n    Material mat;\n    bool textured;\n};\n\nfloat somestep(float t) {\n    return pow(t,4.0);\n}\n\n// the following methods are courtesy of: https://www.shadertoy.com/view/XsfXWX\nvec3 textureAVG(samplerCube tex, vec3 tc) { \n    const float diff0 = 0.35;\n    const float diff1 = 0.12;\n \tvec3 s0 = texture(tex,tc).xyz;\n    vec3 s1 = texture(tex,tc+vec3(diff0)).xyz;\n    vec3 s2 = texture(tex,tc+vec3(-diff0)).xyz;\n    vec3 s3 = texture(tex,tc+vec3(-diff0,diff0,-diff0)).xyz;\n    vec3 s4 = texture(tex,tc+vec3(diff0,-diff0,diff0)).xyz;\n    \n    vec3 s5 = texture(tex,tc+vec3(diff1)).xyz;\n    vec3 s6 = texture(tex,tc+vec3(-diff1)).xyz;\n    vec3 s7 = texture(tex,tc+vec3(-diff1,diff1,-diff1)).xyz;\n    vec3 s8 = texture(tex,tc+vec3(diff1,-diff1,diff1)).xyz;\n    \n    return (s0 + s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8) * 0.111111111;\n}\n\nvec3 textureBlurred(samplerCube tex, vec3 tc) {\n   \tvec3 r = textureAVG(tex,vec3(1.0,0.0,0.0));\n    vec3 t = textureAVG(tex,vec3(0.0,1.0,0.0));\n    vec3 f = textureAVG(tex,vec3(0.0,0.0,1.0));\n    vec3 l = textureAVG(tex,vec3(-1.0,0.0,0.0));\n    vec3 b = textureAVG(tex,vec3(0.0,-1.0,0.0));\n    vec3 a = textureAVG(tex,vec3(0.0,0.0,-1.0));\n        \n    float kr = dot(tc,vec3(1.0,0.0,0.0)) * 0.5 + 0.5; \n    float kt = dot(tc,vec3(0.0,1.0,0.0)) * 0.5 + 0.5;\n    float kf = dot(tc,vec3(0.0,0.0,1.0)) * 0.5 + 0.5;\n    float kl = 1.0 - kr;\n    float kb = 1.0 - kt;\n    float ka = 1.0 - kf;\n    \n    kr = somestep(kr);\n    kt = somestep(kt);\n    kf = somestep(kf);\n    kl = somestep(kl);\n    kb = somestep(kb);\n    ka = somestep(ka);    \n    \n    float d;\n    vec3 ret;\n    ret  = f * kf; d  = kf;\n    ret += a * ka; d += ka;\n    ret += l * kl; d += kl;\n    ret += r * kr; d += kr;\n    ret += t * kt; d += kt;\n    ret += b * kb; d += kb;\n    \n    return ret / d;\n}\n\nfloat G1V ( float dotNV, float k ) {\n\treturn 1.0 / (dotNV*(1.0 - k) + k);\n}\n\nfloat GGX(vec3 N, vec3 V, vec3 L, float roughness, float F0) {\n    \tfloat alpha = roughness*roughness;\n\tvec3 H = normalize (V + L);\n\n\tfloat dotNL = clamp (dot (N, L), 0.0, 1.0);\n\tfloat dotNV = clamp (dot (N, V), 0.0, 1.0);\n\tfloat dotNH = clamp (dot (N, H), 0.0, 1.0);\n\tfloat dotLH = clamp (dot (L, H), 0.0, 1.0);\n\n\tfloat D, vis;\n\tfloat F;\n\n\t// NDF : GGX\n\tfloat alphaSqr = alpha*alpha;\n\tfloat pi = 3.1415926535;\n\tfloat denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n\tD = alphaSqr / (pi * denom * denom);\n\n\t// Fresnel (Schlick)\n\tfloat dotLH5 = pow (1.0 - dotLH, 5.0);\n\tF = F0 + (1.0 - F0)*(dotLH5);\n\n\t// Visibility term (G) : Smith with Schlick's approximation\n\tfloat k = alpha / 2.0;\n\tvis = G1V (dotNL, k) * G1V (dotNV, k);\n\n\treturn /*dotNL */ D * F * vis;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int spheresNo = 6;\nSphere spheres[spheresNo];\n\nconst int planeNo = 1;\nPlane planes[planeNo];\n\nconst int trianglesNo = 3;\nTriangle triangles[trianglesNo];\n\nconst vec3 EyeStartPosition = vec3(-4, 4, 4);\n\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2)\n{   \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw+EyeStartPosition;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y), sin(-uv.y), sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.2;\n    if (isKeyHeld(KeyLeft )) eye -= u*speed;\n    if (isKeyHeld(KeyRight)) eye += u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//V\n               0.5,\t\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//P\n               500.);\t\t\t\t\t\t//maxT\n}\n\nTraceResult intersectPlane(Ray ray, Plane plane) // Plane intersection---------------------\n{\n    float t = dot(plane.q0-ray.p0,plane.n)/dot(ray.v,plane.n);\n    return TraceResult(plane.n, t, plane.mat, plane.textured);\n}\n\nTraceResult intersectSphere(Ray ray, Sphere sp) // Sphere intersection---------------------\n{\n    vec3 p0c = ray.p0 - sp.c;\n    float a = dot(ray.v, ray.v); // 1.0\n    float b = 2.0 * dot(p0c, ray.v);\n    float c = dot(p0c,p0c) - sp.r*sp.r;\n    \n    float discriminant = b*b - 4.0*a*c;\n    if(discriminant < 0.0)\n        return TraceResult(vec3(0), ray.tmax, colors[5], false);\n    \n    float sqd = sqrt(discriminant);\n    float numerator = -b - sqd;\n    if(numerator < 0.0)  \n        numerator = -b + sqd;\n    float t = 0.5 * numerator / a;\n    \n    vec3 p = ray.p0 + t * ray.v;\n    vec3 normal = normalize(p - sp.c);\n    \n    return TraceResult(normal, t, sp.mat, sp.textured);\n}\n\nTraceResult intersectTriangle(Ray ray, Triangle trg) // Triangle intersection-------------\n{\n    vec3 ab = trg.b - trg.a;\n    vec3 ac = trg.c - trg.a;\n    vec3 ap = ray.p0 - trg.a;\n    \n    vec3 f = cross(ray.v, ac);\n    vec3 g = cross(ap, ab);\n    \n    float term1 = 1. / dot(f, ab);\n    \n    vec3 term2 = vec3(dot(g, ac), dot(f, ap), dot(g, ray.v));\n    \n    vec3 result = term1 * term2;\n    \n    float t = result.x;\n    float u = result.y;\n    float v = result.z;   \n        \n    if(u<0. || u>1. || v<0. || v+u>1.)\n    {\n        return TraceResult(vec3(0), ray.tmax, colors[5], false); // no intersection\n    }\n    else\n    {\n        vec3 p = ray.p0 + t * ray.v;\n        vec3 result = normalize(p - vec3(t, u, v));\n        return TraceResult(result, t, trg.mat, trg.textured);\n    }\n}\n\nTraceResult raycast(Ray ray)\n{\n    TraceResult res = TraceResult(vec3(0), ray.tmax, colors[5], false);\n    for(int i = 0; i < spheresNo; ++i)\n    {\n        TraceResult res2 = intersectSphere(ray, spheres[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    for(int i = 0; i < planeNo; ++i)\n    {\n        TraceResult res2 = intersectPlane(ray, planes[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    for(int i = 0; i < trianglesNo; ++i)\n    {\n        TraceResult res2 = intersectTriangle(ray, triangles[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    \n    return res;\n}\n\n// idea (partly) from: https://iquilezles.org/articles/rmshadows\n// the implementation is my own\nfloat calcSoftshadow(vec3 ro, vec3 rd, float mint, float tmax, float k)\n{\n    float t = mint;\n    float res = 1.0;\n    \n    Ray ray = Ray(ro+rd*t, mint, rd, tmax);\n    TraceResult tr = raycast(ray);\n    float h = tr.t;\n    \n    for(int i=0; i<64; i++)\n    {\n        \n\t\tres = min(res, smoothstep(0.0, 1.0, k*h/t));\n        t += clamp(h, 0.01, 0.2);\n        \n        if(res<0.005 || t>10.)\n        {\n            break;\n        }\n    }\n    return clamp(res,0.0,1.0);\n}\n\n// original color of the pixel // camera to point distance // camera to point vector // sun light direction // b-> fog strenth\n// Maths: http://www.terathon.com/lengyel/Lengyel-UnifiedFog.pdf \nvec3 applyFog(vec3 rgb, float dist, in vec3 rayDir, vec3 sunDir, float b)  \n{\n    float fogAmount = 1.0 - exp(-dist*b);\n    float sunAmount = max(dot(rayDir, sunDir), 0.);\n    \n    vec3 fogColor = mix(vec3(0.5,0.6,0.7), vec3(1.0,0.9,0.7), pow(sunAmount,8.0) );\n    \n    return mix(rgb, fogColor, fogAmount);\n}\n\nvec4 hitColor(Ray ray, TraceResult tr, vec3 lightPos) // Calculate shadows\n{\n    Material mat = tr.mat;\n    \n    vec3 p = ray.p0 + ray.v * tr.t; // point of hit\n    vec3 n = tr.n;\n    \n    vec3 l = lightPos-p;\n    float lightDist = length(l);\n    l /= lightDist; // normalized direction to the light\n    \n    Ray shadowray = Ray(p+0.001*n, 0.001, l, lightDist); // p0, tmin, v, tmax\n                      \n    TraceResult res = raycast(shadowray); \n    \n    vec3 v = -ray.v;\n    l = normalize(lightPos-p);\n\n    float metallic = mat.metalness;\n    float roughness = mat.roughness;\n    float fresnel_pow = mix(3., 3.5, mat.metalness);\n    vec3 color_mod = mat.color+0.5;\n    vec3 light_color = pow(texture(iChannel2, vec3(1.0,0.0,0.0)).xyz * 1.2, vec3(2.2));\n\n    // IBL\n    vec3 ibl_diffuse = pow(textureBlurred(iChannel2, n), vec3(2.2));\n    vec3 ibl_reflection = pow(textureBlurred(iChannel2, reflect(ray.v, n)), vec3(2.2));\n\n    // fresnel\n    float fresnel = max(1.0 - dot(n, -ray.v), 0.0);\n    fresnel = pow(fresnel, fresnel_pow); \n\n    // reflection        \n    vec3 refl = pow(texture(iChannel2, reflect(ray.v, n)).xyz, vec3(2.2));\n    refl = mix(refl, ibl_reflection, (1.0-fresnel) * roughness);\n    refl = mix(refl,ibl_reflection,roughness);\n    \n    // specular\n    float power = 1.0 / max(roughness * 0.4,0.01);\n    vec3 spec = mat.color * GGX(n, -ray.v, lightPos, roughness*0.7, 0.2);\n    refl -= spec;\n    \n    // soft shadow\n    float sh = 1.;\n    if(!(res.t == shadowray.tmax || mat.emission!=vec3(0.) || res.mat.emission!=vec3(0.))) // in a shadow\n    {\n        sh = calcSoftshadow(p, l, 0.0001, 128., 0.8);\n    }\n    \n    // diffuse\n    vec3 diffuse = ibl_diffuse * dot(n,l) * sh; //dot(n,v)=|n|*|v|*cos(alpha)\n    diffuse = mix(diffuse * color_mod, refl, fresnel); \n    \n    vec3 colorfinal = mix(diffuse, refl * color_mod, metallic) + spec;\n    \n    vec3 specular; // again for more fancy FX\n    if(dot(n,l) < 0.)\n    {\n        specular = vec3(0);\n    }\n    else\n    {\n        specular = vec3(30, 30, 30);\n        float specdot = dot(reflect(l, n), v);\n        specular = l * specular * pow(max(0.0, specdot), 100.);\n    }\n    \n    if(tr.textured) // add texture if any\n    {\n        vec3 mattex = texture(iChannel3, p.xy).rgb;\n        mattex *= 0.8;\n        colorfinal+=mattex;\n    }\n    \n    vec3 col = diffuse + (colorfinal + specular*mat.metalness) * max(dot(n,l), 0.);\n    \n    if(mat.emission != vec3(0.)) // if it's a light source\n    { \n        return vec4(col + clamp(mat.emission, 0., 1.), 1.);\n    }\n    \n    col = applyFog(col, tr.t, ray.v, l, 0.003);\n    \n    return vec4(col, 1.);\n}\n\nvec4 missColor(Ray ray)\n{\n    return vec4(texture(iChannel2, ray.v).xyz, 1.);\n}\n\nvec4 fragFromLight(Ray ray, TraceResult tr) // add light from all other light sources\n{\n    vec4 color;\n    for(int i = 0; i < spheresNo; ++i)\n    {\n        if(spheres[i].mat.emission!=vec3(0.) && spheres[i].c.y > 0.)\n        {\n            color += hitColor(ray, tr, spheres[i].c);\n        }\n    }\n    for(int i = 0; i < trianglesNo; ++i)\n    {\n        if(triangles[i].mat.emission!=vec3(0.))\n        {\n            color += hitColor(ray, tr, triangles[i].a); \n            color += hitColor(ray, tr, triangles[i].b);\n            color += hitColor(ray, tr, triangles[i].c);\n        }\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// The rolling ball\n    float rotateRadius = 10.;\n    float rotateSpeed = 1.;\n    spheres[0] = Sphere(vec3(rotateRadius*sin(iTime*rotateSpeed)+8., 1, rotateRadius*cos(iTime*rotateSpeed)+5.), 1.f, colors[0], false);\n\n    // The sun\n    rotateRadius = 15.;\n    rotateSpeed = 0.1;\n    spheres[1] = Sphere(vec3(rotateRadius*sin(iTime*rotateSpeed), rotateRadius*cos(iTime*rotateSpeed), 5.), 1.f, colors[4], false);\n    \n    // The stack of marbles to show materials\n    spheres[2] = Sphere(vec3(9,1,10), 1.f, colors[3], false);\n    spheres[3] = Sphere(vec3(8,1,8.3), 1.f, colors[2], false);\n    spheres[4] = Sphere(vec3(10,1,8.3), 1.f, colors[0], false);\n    spheres[5] = Sphere(vec3(9,2.64,8.86), 1.f, colors[0], true);\n    \n    // The ground plane\n    planes[0] = Plane(vec3(0), normalize(vec3(0,1,0)), colors[1], false);\n    \n    // This will define the pyramid\n    vec3 top = vec3(6,8,2);\n    vec3 apnt = vec3(3,4,5);\n    vec3 bpnt = vec3(9,4,3);\n    vec3 cpnt = vec3(4.5,4,-2);\n    triangles[0] = Triangle(apnt, top, bpnt, colors[0], false); \n    triangles[1] = Triangle(apnt, top, cpnt, colors[0], false);\n    triangles[2] = Triangle(bpnt, top, cpnt, colors[0], false);\n    \n    // Camera and coordinates\n    vec2 uv = fragCoord/iResolution.xy*2.-vec2(1.); // Normalized pixel coordinates (from -1 to 1)\n\n    vec3 eye; vec2 data;                    // this will be saved into first two pixels\n    Ray ray = Camera(fragCoord, eye, data); // Generate ray from pixel\n\n    TraceResult ret = raycast(ray); // Traceresult\n    \n    if(ray.tmax <= ret.t){ // This will calculate shadows\n        fragColor = missColor(ray);\n    }\n    else\n    {\n        fragColor = hitColor(ray, ret, vec3(10.,10.,6.));\n        fragColor += fragFromLight(ray, ret);\n    }\n    \n    // Reserve the first 2 pixels for the camera position\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.yzw = eye-EyeStartPosition;\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.zw = data;\n}","name":"Buffer A","description":"","type":"buffer"}]}