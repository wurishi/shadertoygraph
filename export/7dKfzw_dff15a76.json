{"ver":"0.1","info":{"id":"7dKfzw","date":"1658227001","viewed":135,"name":"Raymarching synth wave","username":"pepe","description":"*You should select a music into Channel #0*\n\nThe colors and the sun reacts to the sound selected, and Shadertoy does not save the selected sound Music, \"Tropical Beeper\" fits well with the effects\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","wave","retro","audio","synth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRr","filepath":"/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","previewfilepath":"/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat hue2rgb(float p, float q, float t)\n{\n\tif(t < 0.0) t += 1.0;\n\tif(t > 1.0) t -= 1.0;\n\tif(t < 1.0/6.0) return p + (q - p) * 6.0 * t;\n\tif(t < 1.0/2.0) return q;\n\tif(t < 2.0/3.0) return p + (q - p) * (2.0/3.0 - t) * 6.0;\n\treturn p;\n}\n\nvec3 hslToRgb(float h, float s, float l)\n{\n    vec3 rgb;\n    if(s == 0.0)\n\t{\n        rgb = vec3( l );\n    }\n\telse\n\t{\n        float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;\n        float p = 2.0 * l - q;\n        rgb = vec3( hue2rgb(p, q, h + 0.33333), hue2rgb(p, q, h), hue2rgb(p, q, h - 0.33333) );\n    }\n\n    return rgb;\n}\n\nvec3 grid(vec2 p) \n{\n    vec3 col = vec3(0.);\n    \n    //col.g = step(abs(p.x), .01);\n    //col.r = step(abs(p.y), .01);\n    \n    vec2 q = p;\n    q.x = fract(10. * q.x);\n    col += .2*vec3(step(abs(q.x), 0.05));\n    \n    q = p;\n    q.y = fract(10. * q.y);\n    col += .2*vec3(step(abs(q.y), 0.05));\n    \n    return col;\n}\n\nvec2 hash22( vec2 x )  \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat pnoise(vec2 p)\n{\n    vec2 id = floor(p);\n    vec2 st = fract(p);\n    \n    vec2 f = st;\n    f = f*f*f*(f*(f*6.0-15.0)+10.0);\n    \n    return \n        mix(\n        \tmix(dot(hash22(id + vec2(0., 0.)), vec2(0., 0.) - st),\n                dot(hash22(id + vec2(1., 0.)), vec2(1., 0.) - st), \n                f.x),\n            mix(dot(hash22(id + vec2(0., 1.)), vec2(0., 1.) - st),\n                dot(hash22(id + vec2(1., 1.)), vec2(1., 1.) - st), \n                f.x),\n        \tf.y\n\t\t);\n}\n\n// fractional brownian motion\nfloat fbm(vec2 p)\n{   \n    int octaves = 10;\n    float laccun = 1.75;\n    float gain = 0.5;\n\n    float c = 0.;\n    \n    float g = gain, l = 1.;\n    float total_g = 0.0;\n    \n    for (int iter = 0; iter < octaves; ++iter)\n    {\n        c += g * pnoise(p * l);\n        total_g += g;\n        g *= gain;\n        l *= laccun;        \n    }\n    \n  \n    \n    return c / total_g\n    *abs(1.25-1./(pow(p.x/2., 2.)+0.8))*3.\n    +cos(p.x*0.3)/1.+0.13;\n    ;\n}\n\n\nfloat map(vec3 pos) \n{\n    return min(\n        pos.y + fbm(pos.xz), \n        10000000.);\n}\n\n\nvec3 calcNormal(vec3 pos) \n{\n    vec2 eps = vec2(0.0001, 0.0);\n    float h = map(pos);\n    return normalize(vec3(    \n        map(pos + eps.xyy) - h,\n        map(pos + eps.yxy) - h,\n        map(pos + eps.yyx) - h  \n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.);\n        \n    // setup camera    \n    vec3 CameraOrigin = vec3(0., .4, -1.); \n    CameraOrigin = vec3(0., -0.7, -1.+iTime*0.5); \n    vec3 CameraTarget = vec3(0., 0., 0.);\n    CameraTarget = vec3(0., -0.7, 0.+iTime*0.5);\n    \n    vec3 cam_forward = normalize(CameraTarget - CameraOrigin);\n    vec3 cam_right   = normalize(cross(cam_forward, vec3(0., 1., 0.)));\n    vec3 cam_up      = normalize(cross(cam_right, cam_forward));\n    \n    vec3 rd = normalize(uv.x * cam_right + \n                        uv.y * cam_up + \n                        1.   * cam_forward);\n    \n    \n    \n\n    \n    int tx = int(uv.x*256.0+256.);\n    float fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n\n    float wave = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n    \n    vec2 tempUV = uv.yx+vec2(-0.15,0.0);\n    vec3 ColorDelFuckingSol = vec3(0.3,0.3,0.0);\n    col += step(length(tempUV), 0.65)*hslToRgb(sin(iTime),0.5,0.5);\n    \n    tempUV = uv.xy+vec2(+1., 0.1);\n    col += (1. -  smoothstep( .0, 0.15, abs(wave - tempUV.y) ))*col;\n    \n    tempUV = uv.xy+vec2(0.3, 0.3);\n    \n    if(tempUV.x>0. && tempUV.x<1. && tempUV.y>0. && tempUV.y<1.){\n    \n       vec3 vanDamme = texture(iChannel1, tempUV).xyz;\n       \n       vec3 chroma = vec3(0.05, 0.64, 0.15);\n       float mask = pow(dot(vanDamme, chroma)/(length(vanDamme)*length(chroma)), 50.);\n       if(mask<0.9){\n           col = vanDamme;\n           }\n           \n    }\n    \n    col += (smoothstep(length(tempUV), 0.0, 0.65)*hslToRgb(1.-sin(iTime),0.5,0.5)/2.);\n    \n    \n    float tot_dist = 0.;\n    //for (int t = 0; t < int(128.*(abs(atan(sin(iTime*6.)))+0.8)/3.); ++t) {   //si animamos el numero de iteraciones del raymarching hace un efecto de oscuridad guapisimo\n    for (int t = 0; t < 128; ++t) { \n        vec3 pos = CameraOrigin + tot_dist * rd;\n        float h = .4 * map(pos);\n        if (h < 0.001) {   \n            vec3 Normal = calcNormal(pos);                        \n            vec3 LightDirection = normalize(vec3(.3, -1., -.2));\n            float lambert = max(0., dot(-LightDirection, Normal));\n            \n            float top = smoothstep(0., 0.3, pow(max(0., dot(Normal, vec3(0., 1., 0.))), 20.0));\n            \n            float s = 0.5 + 0.5 * sin(0.1*pos.x*+pos.y*pos.z);\n            s=1.;\n            \n            col = vec3(0.2 * s + .5*lambert);\n            \n            float fog = 1. - clamp(tot_dist/8.0, 0., 1.);\n            //fog = 1.;\n            col = fog * vec3(0.3 * s + 0.5 * lambert);\n            \n            int tx = int(fog*512.0);\n    \n            float fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n            float wave = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n            \n            vec3 SoundValue = hslToRgb( fog * 0.4 - 0.05 + texture( iChannel1, vec2( fog * 0.05 + iTime * 0.002, 0.0 ) ).x * 0.1\n            , .5, .5 ) * 0.95;\n\t\n            vec3 SoundValueMod = SoundValue* texture( iChannel0, vec2( mod( abs( pos.x ) * 0.25, 1.0 ), 0.0 ) ).xyz * 0.3\n            +  texture( iChannel0, vec2( mod( abs( fog * 0.1 ) * 0.25, 1.0 ), 0.0 ) ).xyz * 0.7;\n            \n            col *= hslToRgb(atan(2.1*SoundValue.x*iTime)*SoundValueMod.r, 0.3+0.5+0.1*pos.y*wave,0.2*(top)*wave+0.5);\n            col+= vec3(top*0.2); \n            \n            col+= grid(pos.xz);\n            \n            break;\n        }\n        tot_dist += h;\n    }\n   \n   \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}