{"ver":"0.1","info":{"id":"ftGXWh","date":"1640555729","viewed":112,"name":"Passing Through","username":"PGRacer","description":"Playing with some negative spaces for the first time.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","negativespace"],"hasliked":0,"parentid":"slVXDz","parentname":"PGRacer - Raymarching Template"},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 5.0\n#define SURF_DIST 0.000001\n#define OUTLINE_WIDTH 3.0\n#define COLOR_SEPARATION 4.0\n#define LIGHT_POWER 2.5\n\n#define PI 3.141592\n\n#define TIME_FACTOR 0.25\n\nfloat time;\nfloat outlineWidth;\n\n// Generate rotation matrix\nmat3x3 GetRotationMatrix3x3(float angle, vec3 axis)\n{\n\tfloat c = cos(angle);\n    float s = sin(angle);\n\n\tfloat t = 1.0 - c;\n\tfloat x = axis.x;\n\tfloat y = axis.y;\n\tfloat z = axis.z;\n\n\treturn mat3x3\n\t(\n\t\tt * x * x + c, t * x * y - s * z, t * x * z + s * y,\n\t\tt * x * y + s * z, t * y * y + c, t * y * z - s * x,\n\t\tt * x * z - s * y, t * y * z + s * x, t * z * z + c\n\t);\n}\n\nmat4 GetRotationMatrix4x4(float angle, vec3 axis)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat GetAvgComponentLength(vec3 v)\n{\n    return (abs(v.x) + abs(v.y) + abs(v.z)) / 3.0;\n}\n\n// Test sphere\nfloat sdSphere(vec3 p, vec3 pos, float r)\n{\n\treturn length(p - pos) - r;\n}\n\n// Test Torus\nfloat sdTorus(vec3 p, vec3 pos, float w, float r)\n{\n\treturn length(vec2(length((p - pos).xz) - w, (p - pos).y)) - r;\n}\n\n// Test Capsule\nfloat sdCapsule(vec3 p, vec3 pos, float len, float rad)\n{\n\tvec3 a = pos + vec3(len * 0.5, 0.0, 0.0);\n\tvec3 b = pos + vec3(-len * 0.5, 0.0, 0.0);\n\tvec3 ab = b - a;\n\tvec3 ap = p - a;\n\n\tfloat t = dot(ab, ap) / dot(ab, ab);\n\tt = clamp(t, 0.0, 1.0);\n\n\tvec3 c = a + t * ab;\n\treturn length(p - c) - rad;\n}\n\n// Test Cylinder\nfloat sdCylinder(vec3 p, vec3 pos, float l, float r)\n{\n\tvec3 a = pos + vec3(l * 0.5, 0.0, 0.0);\n\tvec3 b = pos + vec3(-l * 0.5, 0.0, 0.0);\n\tvec3 ab = b - a;\n\tvec3 ap = p - a;\n\n\tfloat t = dot(ab, ap) / dot(ab, ab);\n\n\tvec3 c = a + t * ab;\n\tfloat x = length(p - c) - r;\n\tfloat y = (abs(t - 0.5) - 0.5) * length(ab);\n\tfloat e = length(max(vec2(x, y), 0.0));\n\tfloat i = min(max(x, y), 0.0);\n\n\treturn e + i;\n}\n\n// Test Box\nfloat sdBox(vec3 p, vec3 pos, vec3 dimensions)\n{\n\treturn length(max(abs(p - pos) - (0.5 * dimensions), 0.0));\n}\n\n// Test Gyroid\nfloat sdGyroid(vec3 p, vec3 repetition, float width, vec2 bias)\n{\n    p *= repetition;\n    float avgRepetition = GetAvgComponentLength(repetition);\n    return abs(dot(sin(p * bias.x), cos(p.zxy * bias.y))) / avgRepetition - width;\n}\n\nfloat GetDist(vec3 p)\n{   \n    float s0 = sdSphere(p, vec3(0.0), 0.4);\n\n    vec3 spherePos = vec3(0.0, 0.0, 1.0);\n    \n    mat3x3 rot1 = GetRotationMatrix3x3(time, vec3(0.0, 1.0, 0.0));\n    float s1 = sdSphere(p, rot1 * spherePos, 0.25);\n    \n    mat3x3 rot2 = GetRotationMatrix3x3(time + PI / 2.0, vec3(0.0, 1.0, 0.0));\n    float s2 = sdSphere(p, rot2 * spherePos, 0.25);\n    \n    mat3x3 rot3 = GetRotationMatrix3x3(time + PI, vec3(0.0, 1.0, 0.0));\n    float s3 = sdSphere(p, rot3 * spherePos, 0.25);\n    \n    mat3x3 rot4 = GetRotationMatrix3x3(time + 3.0 * PI / 2.0, vec3(0.0, 1.0, 0.0));\n    float s4 = sdSphere(p, rot4 * spherePos, 0.25);\n    \n    mat3x3 rot5 = GetRotationMatrix3x3(PI / 2.0, vec3(1.0, 0.0, 0.0));\n    float s5 = sdSphere(p, rot5 * spherePos, 0.25);\n    \n    mat3x3 rot6 = GetRotationMatrix3x3(-PI / 2.0, vec3(1.0, 0.0, 0.0));\n    float s6 = sdSphere(p, rot6 * spherePos, 0.25);\n    \n    float t1 = sdTorus(p, vec3(0.0), 1.0, 0.15);\n    float t2 = sdTorus(p, vec3(0.0), 1.0, 0.10);\n    \n    \n    mat3x3 rot7 = GetRotationMatrix3x3(-time + PI / 2.0, vec3(0.0, 1.0, 0.0));\n    float t3 = sdTorus(rot5 * rot7 * p, vec3(0.0), 1.0, 0.15);\n    float t4 = sdTorus(rot5 * rot7 * p, vec3(0.0), 1.0, 0.10);\n    \n    \n    mat3x3 rot8 = GetRotationMatrix3x3(-time, vec3(0.0, 1.0, 0.0));\n    float t5 = sdTorus(rot5 * rot8 * p, vec3(0.0), 1.0, 0.15);\n    float t6 = sdTorus(rot5 * rot8 * p, vec3(0.0), 1.0, 0.10);\n    \n    float c1 = sdCylinder(rot7 * p, vec3(0.0), 2.0, .15);\n    float c2 = sdCylinder(rot7 * p, vec3(0.0), 2.0, .1);\n    \n    float c3 = sdCylinder(rot8 * p, vec3(0.0), 2.0, .15);\n    float c4 = sdCylinder(rot8 * p, vec3(0.0), 2.0, .1);\n    \n    mat3x3 rot9 = GetRotationMatrix3x3(PI / 2.0, vec3(0.0, 0.0, 1.0));\n    float c5 = sdCylinder(rot9 * p, vec3(0.0), 2.0, .15);\n    float c6 = sdCylinder(rot9 * p, vec3(0.0), 2.0, .1);\n    \n    float cap1 = sdCapsule(rot7 * p, vec3(0.0), 0.5, 0.25);\n    float cap2 = sdCapsule(rot8 * p, vec3(0.0), 0.5, 0.25);\n    float cap3 = sdCapsule(rot9 * p, vec3(0.0), 0.5, 0.25);\n    \n    float d = s0;\n    d = min(d, cap1);\n    d = min(d, cap2);\n    d = min(d, cap3);\n    d = min(d, s1);\n    d = min(d, s2);\n    d = min(d, s3);\n    d = min(d, s4);\n    d = min(d, s5);\n    d = min(d, s6);\n    d = max(d, -t1);\n    d = max(d, -t3);\n    d = max(d, -t5);\n    d = max(d, -c1);\n    d = max(d, -c3);\n    d = max(d, -c5);\n    d = min(d, t2);\n    d = min(d, t4);\n    d = min(d, t6);\n    d = min(d, c2);\n    d = min(d, c4);\n    d = min(d, c6);\n    \n    return d;\n}\n\nvec3 GetNormal(vec3 p)\n{\n\tvec2 e = vec2(1e-2, 0);\n\tint objID;\n\tvec3 n = GetDist(p) - vec3(\n\t\tGetDist(p - e.xyy),\n\t\tGetDist(p - e.yxy),\n\t\tGetDist(p - e.yyx)\n\t\t);\n\treturn normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Global time alteration for convenience\n    time = iTime * TIME_FACTOR;\n    \n    // Keep outline width same in full screen\n    float outlineWidth = OUTLINE_WIDTH / iResolution.x;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5);\n    uv.x *= (iResolution.x / iResolution.y);\n    \n    // Camera Stuff\n    vec3 camPos = vec3(0.0, 1.0, -3.0);\n    vec3 camDir = normalize(vec3(uv.x, uv.y, 1.0));\n    camDir = GetRotationMatrix3x3(PI/-9.0, vec3(1.0, 0.0, 0.0)) * camDir;\n\n    // Do raymarching\n    float dO = 0.0;\n\tvec3 p = vec3(0.0);\n\tbool outline = false;\n\tbool hit = false;\n    float prevDist = 1000.0;\n\n\tfor (int i = 0; i < MAX_STEPS; i++)\n\t{\n\t\tp = camPos + camDir * dO;\n\t\tfloat d = GetDist(p);\n\t\tdO += d;\n\n\t\tif (!outline && d < outlineWidth * (1.0 + log2(dO)) + SURF_DIST)\n\t\t{\n\t\t\toutline = true;\n\t\t}\n\n\t\tif (dO > MAX_DIST)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tif (d <= SURF_DIST)\n\t\t{\n            hit = true;\n\t\t\tbreak;\n\t\t}\n        \n        // If at any point we've gotten within the thickness of our outline and \n        // then we get further away from a hit we break out and draw the outline\n        if (outline && prevDist < d)\n        {\n            break;\n        }\n        \n        prevDist = d;\n\t}\n\n    dO /= MAX_DIST;\n    \n    vec3 col;\n    \n    if (hit)\n    {\n        vec3 normal = GetNormal(p);\n        vec3 absNormal = abs(normal);\n        col = vec3(\n            pow(absNormal.x, COLOR_SEPARATION),\n            pow(absNormal.y, COLOR_SEPARATION),\n            pow(absNormal.z, COLOR_SEPARATION)\n        );\n        \n        vec3 lightDir = normalize(vec3(1.0, 1.0, -0.5));\n        float scalar = dot(lightDir, normal);\n        scalar = clamp(scalar, 0.0, 1.0);\n        scalar *= LIGHT_POWER;\n        scalar = (scalar + 1.0) / 2.0;\n        col *= scalar;\n        //col = vec3(scalar);\n        \n    }\n    else if (outline)\n    {\n        col = vec3(0.0);\n    }\n    else\n    {\n        vec3 dir = GetRotationMatrix3x3(iTime * 0.1, vec3(0.0, 1.0, 0.0)) * camDir; \n        col = texture(iChannel0, dir).rgb;\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}