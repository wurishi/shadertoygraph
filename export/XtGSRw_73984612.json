{"ver":"0.1","info":{"id":"XtGSRw","date":"1483446221","viewed":246,"name":"Twisted fiber","username":"Nesvi7","description":"Repetition Rules. Enjoy!","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","math","dof","repetition"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 dof(sampler2D buffer, vec2 uv, float distanceOfFocus){\n\tvec3 finalColor = vec3(0.0,0.0,0.0);\n    const float squareEdge = 5.0;\n    const float iters = (squareEdge*2.0+1.0)*(squareEdge*2.0+1.0);\n    float l = abs(distanceOfFocus-texture(buffer,uv).a);\n    float radiousOfDepth = 3.0;\n    float dofLevel = clamp((l-radiousOfDepth )*0.1,0.0,1.0);    \n    for( float i = -squareEdge; i <= squareEdge; i++)\n        for( float j = -squareEdge; j <= squareEdge; j++)\n            finalColor += texture(buffer,uv+vec2(i,j)*0.0015*dofLevel).xyz;\n        \n    finalColor /= iters;\n    return finalColor;\n}\nvec3 GammaCorrection(vec3 inColor){\n\tconst vec3 gammaExp = vec3(1.0/2.2);\n    return pow(inColor,gammaExp);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\tfragColor = vec4(dof(iChannel0,uv,10.0),1.0);\n    \n    fragColor.xyz = GammaCorrection(fragColor.xyz);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//By Nestor Vina\n\n// ray marching\nconst int max_iterations = 200;\nconst float stop_threshold = 0.02;\nconst float normal_step = 0.02;\nconst float clip_far = 1000.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nconst vec3 sunDir = normalize(vec3(1.0,-1.0,1.0));\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nvec3 rotate( vec3 p, vec3 rot ){\n    rot.z = -rot.z;\n    mat3 ry = mat3(cos(rot.y), 0.0,-sin(rot.y),\n\t\t\t   0.0, 1.0, 0.0, \n\t\t\t   sin(rot.y), 0.0, cos(rot.y)  );\n    \n\tmat3 rz = mat3(cos(rot.z),-sin(rot.z), 0.0,\n\t\t\t   sin(rot.z), cos(rot.z), 0.0,\n\t\t\t   0.0, 0.0, 1.0 );\n     \n\tmat3 rx = mat3(1.0, 0.0, 0.0,\n\t\t\t   0.0, cos(rot.x), sin(rot.x), \n\t\t\t   0.0,-sin(rot.x), cos(rot.x) );\n    return p*rz*ry*rx;\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opUS( vec2 d1, vec2 d2, float _smooth )\n{\n\treturn vec2(smin(d1.x,d2.x, _smooth), (d1.y<d2.y)?d1.y:d2.y);\n}\n\n//by iq\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//Primitives\nvec2 Structure(vec3 p){\n    \n    float freq = 0.2;\n    float amplitude = 2.0;\n    \n    float deformationValue = (sin(iTime*2.0)+1.0)*0.5;\n    p.x += sin(p.z*freq+iTime)*amplitude*deformationValue;\n    p.y += cos(p.z*freq+iTime)*amplitude*deformationValue;\n    p.y += p.z*p.z*p.z*0.00002*sin(iTime);\n    p.x += p.z*p.z*p.z*0.00002*cos(iTime);\n    vec3 initialp = p;\n    \n    float repetitionz = 2.0;\n    float repetitionxy = 20.0;\n    p.z = mod(p.z,repetitionz)- repetitionz*0.5;\n    p.xy = mod(p.xy,repetitionxy)-repetitionxy*0.5;\n    p = rotate(p,vec3(0.0,0.0,initialp.z*0.1));\n    \n    const float percentage = 0.7;\n    const float initialRadious = 1.0;\n    float percentagePow = 0.5;//0.5;\n   \tfloat theDist = 99999999.0;\n    \n    float radious = initialRadious;\n    float currentOffset = 0.0;\n    float currentPercentage = 1.0;\n    vec3 lastPosition = vec3(0.0);\n    vec2 hash = floor(initialp.xy/repetitionxy)*vec2(8.5498,1.716457);\n    float outIter = 0.0;\n    \n    for( float i = 1.0; i < 12.0; i++){\n        vec3 direction = rotate(vec3(0.0,1.0,0.0),vec3(0.0,0.0,i*sin(iTime+hash.x+hash.y)));\n        lastPosition = lastPosition+direction*currentOffset;\n        \n        float newDist = length(p+lastPosition)-radious;\n        \n        if(newDist <theDist)\n            outIter = i;\n        \n        theDist = min(theDist,newDist);\n        \n        currentOffset = radious;\n        currentPercentage *= pow(percentage,percentagePow);\n        radious = currentPercentage * initialRadious;\n        currentOffset += radious;\n        \n    }    \n    return vec2(theDist,outIter);\n}\n\n//Map\nvec2 map( vec3 p) {\n    return Structure(p);\n}\n// ray marching\nvec2 ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\t\n    float depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n        vec2 distResult = map( origin + dir * depth );\n\t\tfloat dist = distResult.x*0.6;\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn vec2(depth,distResult.y);\n\t\t}\n\t\tdepth += dist;\n\t\tif ( depth >= end) {\n\t\t\treturn vec2(end,-1.0);\n\t\t}\n\t}\n\treturn vec2(end,-1.0);\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\t\n\treturn normalize( vec3( -xy, -z ) );\n}\n\nfloat calculateAmbientOcclusion(vec3 p, vec3 n, const float stepDistance){\n    #ifdef low\n    return 0.0;\n    #else\n    float ao = 0.0;\n    float difference = 0.0;\n    float depth = 0.0;\n    for(float i = 0.0; i < 20.0; i++){\n        ao += map(p+depth*n).x;\n        depth += stepDistance;\n    }\n    \n    return ao / 10.0;\n    #endif\n}\n\nvec3 normal( vec3 pos ) {\n\tconst vec3 dx = vec3( normal_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, normal_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, normal_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tmap( pos + dx ).x - map( pos - dx ).x,\n\t\t\tmap( pos + dy ).x - map( pos - dy ).x,\n\t\t\tmap( pos + dz ).x - map( pos - dz ).x\t\t\t\n\t\t)\n\t);\n}\n\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x, \n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nfloat fresnel(vec3 n, vec3 d, float exp ){\n    return pow(1.0-dot(d,n),exp);\n}\n\nvec3 material( vec3 v, vec3 n, vec3 eye, float iter ) {    \n    //Texturing \n    vec2 uv = v.xz;    \n\tfloat sin01 = sin(iTime)*0.5+0.5;\n    vec3 albedo = pal( pow(iter,(sin01)*2.0)*0.083, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );//vec3(0.5,0.0,0.0);// rotate(vec3(0.5,0.0,0.0),vec3(0.0,v.z,0.0))+vec3(0.5);\n    albedo = mix(vec3(0.0,0.0,0.0),albedo,sin01);\n    albedo *= 0.39;\n    float ao = pow(clamp(calculateAmbientOcclusion(v,n,0.05),0.0,1.0),1.0+(sin01)*4.0);\n    //return ao*albedo;\n    vec3 viewDir = normalize(eye-v);    \n    vec3 fresnelColor = vec3(0.0,0.3,0.7) * fresnel(n,viewDir,2.0)*pow(clamp((0.7-(iter)/12.0),0.0,1.0),0.5);    \n    \n    float diffuse = dot(sunDir,n)*0.01;\n    vec3 ambient = vec3(0.005,0.05,0.005);\n    \n    return (albedo+diffuse*ao+ambient*ao+fresnelColor);\n}\n\nvec4 ApplyFog(vec4 color, float depth){    \n    vec4 fogColor = vec4(0.0,0.1,0.2,depth);\n    const float maxDist = 200.0;\n    return mix(color,fogColor,pow(clamp(depth/maxDist,0.0,1.0),2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// default ray dir\n\tvec3 dir = ray_dir( 45.0, iResolution.xy, fragCoord.xy );\n\t\n\t// default ray origin\n\tvec3 eye = vec3( 8.0, 0.0, 0.0);\n\n\t// rotate camera\n\tmat3 rot = rotationXY( vec2(cos(iTime*0.4+0.5), 0.8+sin(iTime*0.6)*0.2 ) );//rotationXY( iMouse.yx/iResolution.yx *2.0 );//vec2(-0.2, iTime/2.0 ) );\n\tdir = rot * dir;\n\teye = rot * eye;\n\teye += vec3(-iTime*20.0,0.0,0.0);\n\t// ray marching\n    vec2 rayResult = ray_marching( eye, dir, 0.0, clip_far );\n\tfloat depth = rayResult.x;\n\tif ( depth >= clip_far ) {        \n\t\tfragColor = vec4(0.3,0.3,0.3,1.0);//Background color\n    \tfragColor = ApplyFog(fragColor,depth);\n        return;\n\t}\n\t\n\t// shading\n\tvec3 pos = eye + dir * depth;\n\tvec3 n = normal( pos );\n    \n    fragColor = vec4(material( pos, n, eye, rayResult.y), 1);\n    \n    fragColor = ApplyFog(fragColor,depth);\n}","name":"Buf A","description":"","type":"buffer"}]}