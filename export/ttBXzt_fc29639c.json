{"ver":"0.1","info":{"id":"ttBXzt","date":"1567028994","viewed":1126,"name":"Magnifying glass","username":"TambakoJaguar","description":"I tried to create this realistic magnifying glass!\nYou can move it with the mouse.\n - W/S or UP/DOWN to change its height\n - A/D or LEFT/RIGHT to rotate it\n - R/F to zoom the view\n - 1, 2 or 3 to change the paper type","likes":25,"published":1,"flags":48,"usePreview":0,"tags":["reflection","grid","refraction","text","lens","glass","metal","keyboard","letters","optics","buffer","magnifying","magnify","characters","loupe"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\"Magnifying glass\" by Emmanuel Keller aka Tambako - August 2019\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.141593\n\n// The defines to switch on and off some features\n#define specular\n#define shadow\n#define lens_refraction\n\n#define PAPER_OBJ      1\n#define LENS_OBJ       2\n#define RIM_OBJ        3\n#define HANDLE_OBJ     4\n\nstruct Lamp\n{\n  vec3 position;\n  vec3 color;\n  float intensity;\n  float attenuation;\n};\n\nstruct RenderData\n{\n  vec3 col;\n  vec3 pos;\n  vec3 norm;\n  float objnr;\n};\n\nLamp lamps[3];    \n    \n// Campera options\nvec3 campos = vec3(0.5, -0.4, 9.);\nvec3 camtarget = vec3(0., 0., 0.);\nvec3 camdir;\nfloat fov = 5.5;\nfloat angle;\n\nconst float mg_scale = 3.1;\nconst float mg_angle = 45.;\n\nconst float normdelta = 0.0015;\nconst float maxdist = 60.;\n\nconst vec3 ambientColor = vec3(0.3);\nconst float ambientint = 0.12;\nconst vec3 speccolor = vec3(0.95, 0.97, 1.);\n\nconst float specint_paper = 0.04;\nconst float specshin_paper = 15.;\nconst float specint_glass = 0.055;\nconst float specshin_glass = 480.;\nconst float specint_rim = 0.18;\nconst float specshin_rim = 25.;\nconst float specint_handle = 0.04;\nconst float specshin_handle = 15.;\n\nconst float shi = 0.6;\nconst float shf = 0.2;\n\nfloat glass_ior = 1.5;\nvec3 glass_vol_col = vec3(0.96, 0.99, 0.96);\n\nvec3 rim_color = vec3(0.88, 0.9, 0.92);\nvec3 handle_color = vec3(0.23);\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.8;\nconst int aasamples = 1;\n\n// Union operation from iq\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n// From https://www.shadertoy.com/view/Xds3zN\nfloat sdCylinder(vec3 p, vec2 h, float t, float rr)\n{\n    h-= vec2(rr);\n    vec2 d = abs(vec2(length(p.xz*(1. + t*p.y)),p.y)) - h;\n    return -rr + min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) + vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) - vect.y*cos(angle);\n    return rv;\n}\n\nfloat get_mg_posz()\n{\n    return texture(iChannel2, vec2(0., 0.)).r;\n}\n\nfloat get_mg_angle()\n{\n    return texture(iChannel2, vec2(0., 0.)).b;\n}\n\nfloat get_zoom()\n{\n    return texture(iChannel2, vec2(0., 0.)).a;\n}\n\nfloat map_lens(vec3 pos)\n{   \n    pos.z+= 3.2 - get_mg_posz();\n    pos/= mg_scale;\n    pos.z-= 0.77;\n    float d = length(pos) - .95;\n    pos.z-= 1.81;\n    d = max(d, length(pos) - .95);\n    d = max(d, length(pos.xy) - 0.26);\n    \n    //d = max(d, -pos.y);\n    return d;\n}\n\nfloat map_rim(vec3 pos)\n{  \n    pos.z-= 2. + get_mg_posz();\n    pos/= mg_scale;\n    \n    vec3 pos2 = pos.xzy;   \n    float d = sdCylinder(pos2, vec2(0.26, 0.03), 0., 0.);\n    d = max(d, -sdCylinder(pos2, vec2(0.26, 0.18), 0., 0.)) - 0.003;\n    \n    vec3 pos3 = pos;\n    pos3.xy = rotateVec(pos3.xy, get_mg_angle()-mg_angle/180.*pi - pi);\n    pos3.y+= 0.287;\n    d = min(d, sdCylinder(pos3, vec2(0.02, 0.026), 0., 0.));\n    pos3.y-= 0.01;\n    d = min(d, sdTorus(pos3, vec2(0.02, 0.0037)));\n    pos3.y+= 0.028;\n    d = min(d, sdTorus(pos3, vec2(0.02, 0.0037)));\n    pos3.y+= 0.006;\n    d = min(d, sdTorus(pos3, vec2(0.02, 0.0037)));    \n\n    //d = max(d, -pos.y);\n    return d;\n}\n\nfloat map_handle(vec3 pos)\n{\n    pos.z-= 2. + get_mg_posz();\n    pos/= mg_scale; \n    \n    vec3 pos3 = pos;\n    pos3.xy = rotateVec(pos3.xy, get_mg_angle()-mg_angle/180.*pi - pi);\n    \n    return sdCylinder(pos3 + vec3(0., 0.556, 0.), vec2(0.032, 0.24), 0.4, 0.008);\n}\n\nfloat map_paper(vec3 pos)\n{\n    return pos.z;\n}\n\nvec2 map(vec3 pos, bool inside, bool nolens)\n{\n    vec2 res;\n    \n    float paper = map_paper(pos);\n    \n    vec2 iMouse2;\n    if (iMouse.x==0. && iMouse.y==0.)\n       iMouse2 = iResolution.xy*vec2(0.45, 0.5);\n    else\n       iMouse2 = iMouse.xy;\n    \n    pos.xy+= (5.6*vec2(1., -1.)*iMouse2.xy/iResolution.xx + vec2(-2.8, 1.6))/get_zoom();\n    float lens = map_lens(pos);\n    if (inside)\n       res = vec2(-lens, LENS_OBJ);\n    else\n    {\n       if (nolens)\n           res = vec2(paper, PAPER_OBJ);\n       else\n           res = opU(vec2(paper, PAPER_OBJ), vec2(lens, LENS_OBJ));\n        \n       float rim = map_rim(pos);\n       res = opU(res, vec2(rim, RIM_OBJ));\n        \n       float handle = map_handle(pos);\n       res = opU(res, vec2(handle, HANDLE_OBJ));        \n    }\n    \n    return res;\n}\n\nvec2 trace(vec3 cam, vec3 ray, float maxdist, bool inside) \n{\n    float t = 0.3;\n    vec3 pos;\n    float dist;\n    float objnr = 0.;\n    \n  \tfor (int i = 0; i < 100; ++i)\n    {\n    \tpos = ray*t + cam;\n    \tvec2 res = map(pos, inside, false);\n        dist = res.x;\n        if (dist>maxdist || abs(dist)<0.0001)\n            break;\n        t+= dist*0.9;\n        objnr = abs(res.y);\n  \t}\n        \n  \treturn vec2(t, objnr);\n}\n\nvec3 getNormal(vec3 pos, float e, bool inside)\n{  \n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e2 = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e2*map(pos + e*e2, inside, false).x;\n    }\n    return normalize(n);\n}\n\nvec3 sky_color(vec3 ray)\n{ \n    return texture(iChannel1, ray).rgb;\n}\n\nvec3 obj_color(vec3 norm, vec3 pos, float objnr, vec3 ray)\n{\n    vec3 colo;\n    \n    if (int(objnr)==PAPER_OBJ)\n       colo = texture(iChannel0, vec2(0.5, 0.3) + pos.xy*vec2(-0.18, 0.18)).rgb;\n    else if (int(objnr)==RIM_OBJ)\n       colo = rim_color;\n    else if (int(objnr)==HANDLE_OBJ)\n       colo = handle_color;        \n    else if (int(objnr)==LENS_OBJ)        \n       colo = vec3(0.6);\n    else\n       colo = sky_color(ray);\n\n    return colo;\n}\n\n\n// From https://www.shadertoy.com/view/Xds3zN;\nfloat softshadow(vec3 ro, vec3 rd, float mint, float tmax)\n{\n\tfloat res = 1.;\n    float t = mint;\n    for(int i=0; i<15; i++)\n    {\n    \tvec2 mr = map(ro + rd*t, false, true);\n        float h = mr.x;\n        res = min(res, 13.*h/t);\n        t += clamp(h, 0.01, 0.7);  \n        if (h<0.001) break;\n    }\n    return smoothstep(0.0, 0.5, res);\n}\n\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, float objnr)\n{\n    vec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n    vec3 nlcol = normalize(lamp.color);\n    float dnp = dot(norm, pli);\n    \n    vec3 col = vec3(0.);\n    float specint;\n    float specshin;\n      \n    // Diffuse shading\n    if (int(objnr)==PAPER_OBJ || int(objnr)==HANDLE_OBJ)\n       col = ocol*nlcol*lamp.intensity*smoothstep(-0.1, 1., dnp);\n\n    specint = int(objnr)==PAPER_OBJ?specint_paper:(int(objnr)==RIM_OBJ?specint_rim:(int(objnr)==HANDLE_OBJ?specint_handle:specint_glass));\n    specshin = int(objnr)==PAPER_OBJ?specshin_paper:(int(objnr)==RIM_OBJ?specshin_rim:(int(objnr)==HANDLE_OBJ?specshin_handle:specshin_glass));        \n    \n    // Specular shading\n    #ifdef specular\n    \n    if (dot(norm, lamp.position - pos) > 0.0)\n        col+= speccolor*nlcol*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    // Softshadow\n    #ifdef shadow\n    //if (int(objnr)==HOLE_OBJ)\n       col*= shi*softshadow(pos, normalize(lamp.position - pos), shf, 2.) + 1. - shi;\n    #endif    \n    \n    return col;\n}\n\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, float objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<3; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol, objnr);\n    \n    return col;\n}\n\nvec3 getGlassAbsColor(float dist, vec3 color)\n{\n    return pow(color, vec3(0.1 + pow(dist*8., 2.)));\n}\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   float n1 = 1.; // air\n   float angle = acos(-dot(ray, norm));\n   float r0 = dot((n1-n2)/(n1+n2), (n1-n2)/(n1+n2));\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return clamp(r, 0., 0.8);\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n// Sets the position of the camera with the mouse and calculates its direction\nvoid setCamera()\n{\n   /*vec2 iMouse2;\n   if (iMouse.x==0. && iMouse.y==0.)\n      iMouse2 = iResolution.xy*vec2(0.52, 0.65);\n   else\n      iMouse2 = iMouse.xy;\n    \n   campos = vec3(3.5 + 10.*cos(1.3 + 1.3*iMouse2.x/iResolution.x)*(1. - 0.0*iMouse2.y/iResolution.y),\n                 -13. + 12.*(iMouse2.y/iResolution.y),\n                 -5.5 + 10.*sin(1.3 + 1.3*iMouse2.x/iResolution.x)*(1. + 0.6*iMouse2.y/iResolution.y));\n   camtarget = vec3(0., -3.2 + 2.8*iMouse2.y/iResolution.y + 0.1, 1.);*/\n    \n   camdir = camtarget - campos;   \n}\n\nRenderData trace0(vec3 tpos, vec3 ray, bool inside)\n{\n  vec2 t = trace(tpos, ray, maxdist, inside);\n  float tx = t.x;\n  vec3 col;\n  float objnr = t.y;\n    \n  vec3 pos = tpos + tx*ray;\n  vec3 norm;\n  if (tx<maxdist*0.65)\n  {\n      norm = getNormal(pos, normdelta, inside);\n\n      // Coloring\n      col = obj_color(norm, pos, objnr, ray);\n      \n      // Shading\n      col = ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n  }\n  else\n  {\n      col = sky_color(ray);\n      objnr = 0.;\n  }\n  return RenderData(col, pos, norm, objnr);\n}\n\nvec3 render_glass(vec3 ray, RenderData traceinf)\n{\n     bool inside = true;\n     vec3 col = traceinf.col;\n    \n     vec3 refray = reflect(ray, traceinf.norm);\n     float rf = fresnel(ray, traceinf.norm, glass_ior);\n      \n     vec3 pos1 = traceinf.pos;\n      \n     vec3 ray_r = refract(ray, traceinf.norm, 1./glass_ior);     \n     traceinf = trace0(traceinf.pos, ray_r, inside);\n      \n     vec3 pos2 = traceinf.pos;\n     ray = ray_r;\n      \n     ray_r = refract(ray_r, traceinf.norm, glass_ior);\n     inside = !inside;\n     if (length(ray_r)==0.)\n       ray_r = reflect(ray, traceinf.norm);            \n     traceinf = trace0(traceinf.pos, ray_r, inside);\n     col+= traceinf.col;\n      \n     col*= getGlassAbsColor(0.6*distance(pos1, pos2), glass_vol_col);\n     col = mix(col, sky_color(refray), rf);\n    \n     return col;\n}\n\nvec4 render(vec2 fragCoord)\n{\n  lamps[0] = Lamp(vec3(2, -2., 23.5), vec3(1.0, 1.0, 1.0), 12.4, 0.1);\n  lamps[1] = Lamp(vec3(-14., 2.5, 29.), vec3(0.7, 0.82, 1.0), 5.3, 0.1);\n  lamps[2] = Lamp(vec3(1., 0., 6.2), vec3(1.0, 0.6, 0.4), 0.22, 0.1);\n    \n  vec2 uv = fragCoord.xy / iResolution.xy; \n  uv = uv*2.0 - 1.0;\n  uv.x*= iResolution.x / iResolution.y;\n\n  vec3 ray = GetCameraRayDir(uv, camdir, fov*get_zoom());\n    \n  RenderData traceinf = trace0(campos, ray, false);\n  vec3 col = traceinf.col;\n  float obj = traceinf.objnr;\n    \n  #ifdef lens_refraction\n  if (int(traceinf.objnr)==LENS_OBJ)\n  {\n     col = render_glass(ray, traceinf);\n  }\n  #endif\n  if (int(traceinf.objnr)==RIM_OBJ || int(traceinf.objnr)==HANDLE_OBJ)\n  {\n     float rf = fresnel(ray, traceinf.norm, 1.6);\n     vec3 ray_r = reflect(ray, traceinf.norm);         \n     traceinf = trace0(traceinf.pos, ray_r, false);\n     //if (int(traceinf.objnr)==PAPER_OBJ)\n        //col+= render_glass(ray_r, traceinf);\n        //col = vec3(1., 0., 0.);\n     //else\n     \n     if (int(obj)==RIM_OBJ)\n        col+= rim_color*traceinf.col;\n     else\n        col = mix(col, traceinf.col, rf*0.7);\n  }\n  \n    \n  return vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    setCamera();\n    \n    // Antialiasing\n    vec4 orv;\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vec4 rv = render(fragCoord + vec2(ox, oy));\n          vs+= rv;        \n       }\n    }\n    fragColor = vs/vec4(aasamples*aasamples);\n    \n    //vec2 uv = fragCoord/iResolution.xx;\n    //fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This buffer produces a backgound to be magnified\n\n#define al(i) 65 + int(hash(float(i)*745.5)*26.)\n\nconst vec2 textScale = vec2(0.35, 0.412);\nconst vec2 charSpacingFac = vec2(.8, .95);\nconst vec3 paperColor = vec3(1., 0.97, 0.94);\nconst vec3 textColor = vec3(0., 0.03, 0.06);\n\nconst vec2 lineSpacing = vec2 (0.025, 0.025);\nconst vec3 lineColor = vec3(0.1, 0.4, 0.6);\nconst float lineWidth = 0.0045;\n\nbool showText;\n\nfloat hash(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat noise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0 - 2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix(hash(n + 0.0), hash(n + 1.0),f.x),\n                   mix(hash(n + 157.0), hash(n + 158.0),f.x),f.y),\n               mix(mix(hash(n + 113.0), hash(n + 114.0),f.x),\n                   mix(hash(n + 270.0), hash(n + 271.0),f.x),f.y),f.z);\n}\n\nfloat getChar(vec2 uv, int ch)\n{\n    ch-= 95;\n    vec2 uv2 = mod(uv, charSpacingFac*1./16.);\n    uv2.y-= 0.5;\n    vec2 offset = vec2(mod(float(ch-1), 16.)/16., -float(ch/16)/16.);\n    vec2 pos = uv2 + offset;\n    return texture(iChannel0, pos).r;\n}\n\nint getRandomChar0(int idx)\n{\n    // Random letter\n    int char = al(idx);\n    \n    // Words\n    if (hash(float(idx)*226.8)<0.18)\n       char = 0;\n    else if (hash(float(idx-1)*226.8)<0.12 && hash(float(idx)*842.2)<0.08)\n       char-= 32;\n        \n    // Sentences\n    if (hash(float(idx)*325.1)<0.038)\n       char = 14;\n    else if (hash(float(idx-1)*325.1)<0.038)\n       char = 0;\n    else if (hash(float(idx-2)*325.1)<0.038 && char>32)\n       char-= 32;\n    \n    return char; \n}\n\nint getRandomChar(int idx)\n{\n    int char = getRandomChar0(idx);\n    \n    // Tidies up a bit\n    if (char==14 && getRandomChar0(idx+1)==14)\n        char = al(idx + 2000);\n    \n    if (char==0 && getRandomChar0(idx-1)==0)\n        char = al(idx + 3000);\n    \n    if (char==0 && getRandomChar0(idx+1)==14)\n        char = al(idx + 4000);\n    \n    if (char>64 && getRandomChar0(idx-2)==14)\n        char-= 32;\n    \n    return char;\n}\n\nfloat paperTexture(vec2 uv)\n{\n   float pt = 0.97 + 0.06*smoothstep(0.6, 0.1, (noise(vec3(uv*220., 0.) + noise(vec3(uv*330., 0.)))));\n   pt-= 0.08*smoothstep(0.15, 0.07, noise(vec3(uv*380., 0.)));\n   return pt;\n}\n\nvec3 textTexture(vec2 uv)\n{\n   uv/= textScale;\n   int idx = int(uv.x*16./charSpacingFac.x)+1000*int(uv.y*16./charSpacingFac.y);\n    \n   int char = getRandomChar(idx);\n   float text = getChar(uv, char);\n   vec3 textwColor = mix(paperColor*paperTexture(uv), textColor, text);  \n    \n   return textwColor;\n}\n\nvec3 lineTexture(vec2 uv)\n{\n   vec2 uv2 = mod(uv*vec2(1., iResolution.x/iResolution.y), lineSpacing);\n   uv2+= 0.0008*noise(vec3(uv*190., 0.)); \n    \n   float lwf = 0.3;\n   float gx = smoothstep(lineSpacing.x-lineWidth, lineSpacing.x-lineWidth*(1. - lwf), uv2.x) - smoothstep(lineSpacing.x-lineWidth*lwf, lineSpacing.x, uv2.x);\n   float gy = smoothstep(lineSpacing.y-lineWidth, lineSpacing.y-lineWidth*(1. - lwf), uv2.y) - smoothstep(lineSpacing.y-lineWidth*lwf, lineSpacing.y, uv2.y);\n   float g = max(gx, gy);\n\n   vec3 col = mix (paperColor*paperTexture(uv), lineColor, g*0.8);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   float bgMode = texture(iChannel1, vec2(0., 0.)).g;\n    \n   vec2 uv = fragCoord/iResolution.xx;\n   vec2 uv2 = fragCoord/iResolution.xx*vec2(1., 3.);\n   vec3 textwColor = bgMode==1.?textTexture(uv):(bgMode==2.?lineTexture(uv):texture(iChannel2, uv2).rgb);\n    \n   fragColor = vec4(textwColor, 0.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// This buffer handles the keyboard\n\nconst float KEY_W\t\t= 87.5/256.0;\nconst float KEY_A\t\t= 65.5/256.0;\nconst float KEY_S\t\t= 83.5/256.0;\nconst float KEY_D\t\t= 68.5/256.0;\nconst float KEY_R\t\t= 82.5/256.0;\nconst float KEY_F\t\t= 70.5/256.0;\nconst float KEY_1\t\t= 49.5/256.0;\nconst float KEY_2\t\t= 50.5/256.0;\nconst float KEY_3\t\t= 51.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\nconst float KEY_SPACE\t= 32.5/256.0;\nconst float KEY_SHIFT\t= 16.5/256.0;\n\nconst float zstep = 0.04;\nconst float astep = 0.01;\nconst float zfact = 1.01;\n\nbool isKeyPressed(float key)\n{\n\treturn texture(iChannel0, vec2(key, 0.25) ).x > .0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mg_zpos = texture(iChannel1, vec2(0., 0.)).r;\n\n    if (mg_zpos<3. && (isKeyPressed(KEY_W) || isKeyPressed(KEY_UP)))\n       mg_zpos+= zstep;\n    \n    if (mg_zpos>-1.8 && (isKeyPressed(KEY_S) || isKeyPressed(KEY_DOWN)))\n       mg_zpos-= zstep;\n    \n    float mg_angle = texture(iChannel1, vec2(0., 0.)).b;\n\n    if (isKeyPressed(KEY_A) || isKeyPressed(KEY_LEFT))\n       mg_angle+= astep;\n    \n    if (isKeyPressed(KEY_D) || isKeyPressed(KEY_RIGHT))\n       mg_angle-= astep;\n    \n    float zoom = texture(iChannel1, vec2(0., 0.)).a;\n    if (zoom==0.)\n         zoom = 1.;\n    \n    if (isKeyPressed(KEY_R) && zoom<4.)\n       zoom*= zfact;\n    \n    if (isKeyPressed(KEY_F) && zoom>0.3)\n       zoom/= zfact;       \n    \n    float bgMode = texture(iChannel1, vec2(0., 0.)).g;\n    if (bgMode==0.)\n         bgMode = 1.;    \n    if (isKeyPressed(KEY_1))\n       bgMode = 1.;\n    if (isKeyPressed(KEY_2))\n       bgMode = 2.;\n    if (isKeyPressed(KEY_3))\n       bgMode = 3.;       \n        \n    fragColor = vec4(mg_zpos, bgMode, mg_angle, zoom);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}