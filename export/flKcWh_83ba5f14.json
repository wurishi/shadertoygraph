{"ver":"0.1","info":{"id":"flKcWh","date":"1661440461","viewed":100,"name":"Fixed width shapes from triangle","username":"spontificus","description":"buggy unoptimised solution\n\nhexgrid collision detection, ultimately\n- coord system rethought\n- too many ifs","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["hexagonal"],"hasliked":0,"parentid":"stGyzw","parentname":"Hexadic Line 2"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int point_i_size = 2;\n\n\nbool myInRange(int t, int v1, int v2) {\n    return (abs(t - v1) + abs(v2 - t) <= abs(v2 - v1));\n}\n\n// centered and anti-square\nivec3 screenToHex( vec2 p ) {\n    int j = int(iResolution.y-p.y)/2 - int(iResolution.y/4.);\n    int i = (int(p.x) - j )/2 - int(iResolution.x/4.);\n    return ivec3(i,j,-(i+j));\n}\n\n\n// squarerootless solution?\nint hexDist(ivec3 p1, ivec3 p2) {\n    //return (p2.x-p1.x)*(p2.x-p1.x) + (p2.y-p1.y)*(p2.y-p1.y) + (p2.x-p1.x)*(p2.y-p1.y);\n    return int(sqrt(float((p2.x-p1.x)*(p2.x-p1.x) + (p2.y-p1.y)*(p2.y-p1.y) + (p2.x-p1.x)*(p2.y-p1.y))));\n}\n\n// returns true only if c is on right-hand side of line p1-p2 somehow\nbool line(ivec3 p1, ivec3 p2, ivec3 v) {\n    // translate relative to p1\n    int i = p2.x-p1.x;\n    int j = p2.y-p1.y;\n    int k = p2.z-p1.z;\n    int fragI = v.x - p1.x;\n    int fragJ = v.y - p1.y;\n    int fragK = v.z - p1.z;\n    \n    \n    // weird line alg\n    // how does it even work?\n    int p1I = (-k-i-fragI);\n    int p1J = (-i-j-fragJ);\n    int p1K = (-j-k-fragK);\n    int mp1 = p1I*p1I + p1J*p1J + p1K*p1K;\n    \n    int p2I = (-j-i-fragI);\n    int p2J = (-k-j-fragJ);\n    int p2K = (-i-k-fragK);\n    int mp2 = p2I*p2I + p2J*p2J + p2K*p2K;\n\n    return ( (mp2) - (mp1) < 0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec3 fragHex = screenToHex(fragCoord.xy);\n    int fragI = fragHex.x;\n    int fragJ = fragHex.y;\n    int fragK = fragHex.z;\n    \n    ivec3 mouseHex = screenToHex(iMouse.xy);  \n    int mouseI = mouseHex.x;\n    int mouseJ = mouseHex.y;\n    int mouseK = mouseHex.z;\n\n    vec4 col = vec4(.1,.1,.1,1.);\n   \n    // draw i,j,k axes\n    if ( (fragI - mouseI) == 0 ) {\n        col = vec4(1., 0., 0., 1.);\n    }\n    \n    if ( (fragJ - mouseJ) == 0 ) {\n        col = vec4(0., 1., 0., 1.);\n    }\n     \n    if ( (fragK - mouseK) == 0 ) {\n        col = vec4(0., 0., 1., 1.);\n    }\n    \n\n    if ( fragHex == mouseHex ) {\n        col = vec4(1., 1., 1., 1.);\n    }\n    \n    // line\n    int i = mouseI; // e.g. 6, 7, [-13]\n    int j = mouseJ;\n    int k = mouseK;\n\n    ivec3 p1 = ivec3(250,-75,-175);\n    ivec3 p2 = ivec3(200,100,-300);\n    ivec3 p3 = ivec3(mouseI,mouseJ,mouseK);\n    if (!line(p1,p2,p3)) {\n        p3 = p2;\n        p2 = ivec3(mouseI,mouseJ,mouseK);\n    }\n    \n    \n    // find longest line, 2nd longest\n    int d1 = hexDist(p1,p2);\n    int d2 = hexDist(p2,p3);\n    int d3 = hexDist(p3,p1);\n    \n    int dtot = d1+d2+d3;\n    \n    int maxD = max(d1,max(d2,d3));\n    int minD = min(d1,min(d2,d3));\n    int medD = dtot - minD - maxD;\n    \n    bool s1 = line(p1,p2,fragHex);\n    bool s2 = line(p2,p3,fragHex);\n    bool s3 = line(p3,p1,fragHex);\n    \n    if (s1 ) {\n        col += vec4(.5, 0., 0., 1.);\n    }\n    \n    if (s2) {\n        col += vec4(0., .5, 0., 1.);\n    }\n\n    if (s3) {\n        col += vec4(0., 0., .5, 1.);\n    }\n    \n    int rad=0;\n    int radMin = maxD + medD - minD;\n    \n    // red\n    if (s1 && !s2 && !s3) {\n        if (d2 == minD || d3 == minD) {\n            if (d2 == medD || d3 == medD) {\n                rad =  maxD-minD;\n            } else {\n                rad =  medD-minD;\n            }\n            \n            if ( hexDist(p3,fragHex) <= rad ) {\n                col += vec4(.25, .0, 0., 1.);\n            }\n        }\n    }\n    \n    // yellow\n    if (s1 && s2) {\n        if (d3 == maxD) {\n            rad = medD;\n        } else if (d3 == medD) {\n            rad = maxD;\n        } else {\n            rad = radMin;\n        }\n        \n        if ( hexDist(p2,fragHex) <= rad ) {\n            col += vec4(.5, .5, 0., 1.);\n        }\n    }\n    \n    // green\n    if (s2 && !s1 && !s3) {\n        if (d3 == minD || d1 == minD) {\n            if (d3 == medD || d1 == medD) {\n                rad =  maxD-minD;\n            } else {\n                rad =  medD-minD;\n            }\n            if ( hexDist(p1,fragHex) <= rad ) {\n                col += vec4(.0, .25, 0., 1.);\n            }\n        }\n    }\n    \n    // cyan\n    if (s2 && s3) {\n        if (d1 == maxD) {\n            rad = medD;\n        } else if (d1 == medD) {\n            rad = maxD;\n        } else {\n            rad = radMin;\n        }\n        \n        if ( hexDist(p3,fragHex) <= rad ) {\n            col += vec4(.25, .5, .5, 1.);\n        }\n    }\n    \n    // blue\n    if (s3 && !s1 && !s2) {\n        if (d1 == minD || d2 == minD) {\n            \n            if (d1 == medD || d2 == medD) {\n                rad =  maxD-minD;\n            } else {\n                rad =  medD-minD;\n            }\n            \n            if ( hexDist(p2,fragHex) <= rad ) {\n                col += vec4(.0, .0, 25., 1.);\n            }\n        }\n    }\n    \n    \n    // purple\n    if (s3 && s1) {\n        if (d2 == maxD) {\n            rad = medD;\n        } else if (d2 == medD) {\n            rad = maxD;\n        } else {\n            rad = radMin;\n        }\n    \n        if ( hexDist(p1,fragHex) <= rad ) {\n            col += vec4(.5, .0, .5, 1.);\n        }\n    }\n    \n    // center dot\n    if (fragI == 0 && fragJ == 0) {\n        col = vec4(0., 0., 0., 1.);   \n    }\n    \n    fragColor = col;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}