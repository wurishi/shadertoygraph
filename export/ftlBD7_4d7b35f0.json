{"ver":"0.1","info":{"id":"ftlBD7","date":"1650990223","viewed":150,"name":"Volumetric Light With Shadow Map","username":"March3rd","description":"Study for use shadow mapping to acclerate volumetric light calculation.It's just for practice.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["volumtriclightshadowmapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\n#define STEP_NUM 120\n#define MAX_DEPTH 35.0\n#define SURFACE_DIST 0.01\n#define SCATTER 0.015\n#define BLOOM_LIMIT 0.985\n\nvec3 Light_Pos;\nvec3 Light_Col = vec3(1.0, 0.8, 0.75);\nfloat Light_Depth = 20.0;\n\nvec3 Ambient_Col = vec3(0.1, 0.1, 0.08);\n\nvec3 Material = vec3(1.0, 0.15, 0.1);\n\nfloat sphereSDF(vec3 base, float r, vec3 p) {\n    return length(p - base) - r;\n}\nfloat planeSDF(vec3 base, vec3 normal, vec3 p) {\n    return dot(p - base, normal); \n}\n\nstruct Sphere {\n    vec3 base;\n    float radius;\n};\nstruct Plane {\n    vec3 base;\n    vec3 normal;\n};\n\nSphere ball;\nPlane ground;\n\nfloat map(vec3 pos) {\n    float dist = sphereSDF(ball.base, ball.radius, pos);\n    dist = min(dist, planeSDF(ground.base, ground.normal, pos));\n    return dist;\n}\n\nvec3 getNormal(vec3 pos) {\n    float delta = 0.001;\n    float dist = map(pos);\n    float dx = map(pos + vec3(delta, 0.0, 0.0)) - dist;\n    float dy = map(pos + vec3(0.0, delta, 0.0)) - dist;\n    float dz = map(pos + vec3(0.0, 0.0, delta)) - dist;\n    return normalize(vec3(dx, dy, dz));\n}\n\nbool shadow(vec3 pos) {\n    vec3 dir = normalize(pos - Light_Pos);\n    float depth = length(pos - Light_Pos);\n    float alpha = asin(dir.y);\n    float hr = cos(alpha);\n    float theta = acos(dir.x / hr);\n    if (dir.z <= 0.0) {\n        theta = 2.0 * PI - theta;\n    }\n    vec2 uv = vec2(theta / 2.0 / PI, (alpha + PI / 2.0) / PI);\n    return depth > Light_Depth * texture(iChannel0, uv).r + SURFACE_DIST * 5.0;\n}\n\nvec3 shade(vec3 pos, float light_decay) {\n    vec3 col = vec3(0.0);\n    col += Ambient_Col * Material * sqrt(light_decay);\n    if (!shadow(pos))\n        col += clamp(dot(getNormal(pos), normalize(Light_Pos - pos)), 0.0, 1.0) * Light_Col * light_decay * Material;\n    return col;\n}\n\nvec3 rayMarching(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.0);\n    float depth = 0.0;\n    for (int i = 0; i < STEP_NUM; i ++) {\n        float dist = min(map(ro + rd * depth), MAX_DEPTH / float(STEP_NUM));\n        float light_decay = pow(clamp(1.0 - length(ro + rd * depth - Light_Pos) / Light_Depth, 0.0, 1.0), 2.0);\n        float view_decay = pow(clamp(1.0 - depth / MAX_DEPTH, 0.0, 1.0), 2.0);\n        if (dist < SURFACE_DIST) {\n            col += shade(ro + rd * depth, light_decay);\n            return col;\n        } else {\n            if (!shadow(ro + rd * depth)) {\n                col += dist * Light_Col * light_decay * view_decay * SCATTER;\n            }\n        }\n        depth += dist;\n        if (depth > MAX_DEPTH) {\n            break;\n        }\n    }\n    float light_bloom = dot(rd, normalize(Light_Pos - ro));\n    if (light_bloom > BLOOM_LIMIT) {\n        col += Light_Col * pow((light_bloom - BLOOM_LIMIT) / (1.0 - BLOOM_LIMIT), 16.0);\n    }\n    return col;\n}\n\nvoid motion() {\n    ball.base = vec3(0.0, 0.5, 4.5);\n    ball.radius = 0.5;\n    ground.base = vec3(0.0, -2.0, 0.0);\n    ground.normal = vec3(0.0, 1.0, 0.0);\n    Light_Pos = vec3(sin(iTime * 0.5) * 1.5, 1.0, 5.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    motion();\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord - iResolution.xy / 2.0;\n    uv /= iResolution.y;\n    \n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n    \n    vec3 col = rayMarching(ro, rd);\n\n    // Output to screen\n    fragColor = vec4(pow(col, vec3(1.0 / 2.0)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.1415926\n#define STEP_NUM 100\n#define SURFACE_DIST 0.01\n\nvec3 Light_Pos;\nfloat Light_Depth = 20.0;\n\nfloat sphereSDF(vec3 base, float r, vec3 p) {\n    return length(p - base) - r;\n}\nfloat planeSDF(vec3 base, vec3 normal, vec3 p) {\n    return dot(p - base, normal); \n}\n\nstruct Sphere {\n    vec3 base;\n    float radius;\n};\nstruct Plane {\n    vec3 base;\n    vec3 normal;\n};\n\nSphere ball;\nPlane ground;\n\nfloat map(vec3 pos) {\n    float dist = sphereSDF(ball.base, ball.radius, pos);\n    dist = min(dist, planeSDF(ground.base, ground.normal, pos));\n    return dist;\n}\n\nfloat rayMarching(vec3 ro, vec3 rd) {\n    float depth = 0.0;\n    for (int i = 0; i < STEP_NUM; i ++) {\n        float dist = map(ro + rd * depth);\n        if (dist < SURFACE_DIST) {\n            break;\n        }\n        depth += dist;\n        if (depth > Light_Depth) {\n            depth = Light_Depth;\n            break;\n        }\n    }\n    return depth;\n}\n\nvoid motion() {\n    ball.base = vec3(0.0, 0.5, 4.5);\n    ball.radius = 0.5;\n    ground.base = vec3(0.0, -2.0, 0.0);\n    ground.normal = vec3(0.0, 1.0, 0.0);\n    Light_Pos = vec3(sin(iTime * 0.5) * 1.5, 1.0, 5.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    motion();\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 ro = Light_Pos;\n    float alpha = PI * uv.y - PI / 2.0;\n    float theta = 2.0 * PI * uv.x;\n    vec3 rd = vec3(cos(theta) * cos(alpha), sin(alpha), sin(theta) * cos(alpha));\n    float depth01 = rayMarching(ro, rd) / Light_Depth;\n    fragColor = vec4(depth01, depth01, depth01, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}