{"ver":"0.1","info":{"id":"mtfyR8","date":"1690552766","viewed":65,"name":"Factory Lines","username":"StefanPijnacker","description":"belts, belts and more belts!\nWanted to see if I could figure out how to do something with overlaying UVs, then the idea of factory belts came to mind. ","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 Rotate(in vec2 uv, float angle)\n{\n    float r = angle * (3.14159265359 / 180.0);\n    mat2 rot = mat2(cos(r), sin(r), -sin(r), cos(r));\n    return rot * uv;\n}\n\nvec3 CPallete(float t)\n{\n    vec3 a = vec3(0.718, 0.438, 0.72);\n    vec3 d = vec3(0.694,0.725,0.694);\n    vec3 c = vec3(-0.43, -0.397, -0.083);\n    vec3 b = vec3(0.275,0.267,0.004);\n\n    return a + b * cos(6.28316 * (c * t + d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n    \n    uv = Rotate(uv, 12. * iTime);\n    uv.x += iTime * 0.3 + cos(iTime * 0.3);\n    uv.y += (iTime) * 0.1 - sin(iTime * 0.7);\n    \n    vec3 tex = texture(iChannel0, uv).rgb;\n    vec3 color = vec3(tex.g);\n    color += tex.r * CPallete(uv.x + iTime * 0.2 ) * 0.8;\n    \n    if(color == vec3(0.0))\n    color = vec3(0.000,0.000,0.098);\n    \n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define rowCount 8.\n#define beltSpeed 0.25\n#define pi 3.14159265359\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdArrow(in vec2 uv, float offsetX)\n{\n    float t = 0.0f;\n    float a = sdSegment(uv, vec2(offsetX, -1.2), vec2(offsetX + 0.3, 0.));\n    a = step(0.1, abs(a));\n    \n    float b = sdSegment(uv, vec2(offsetX, 1.2), vec2(offsetX + 0.3, 0.));\n    b = step(0.1, abs(b));\n    \n    return 1.0 - (a * b);\n}\n\nvec2 Rotate(in vec2 uv, float angle)\n{\n    float r = angle * (pi / 180.0);\n    mat2 rot = mat2(cos(r), sin(r), -sin(r), cos(r));\n    return rot * uv;\n}\n\nfloat N21(vec2 uv)\n{\n    return fract(sin(uv.x * 18.928 + uv.y * 103.81) * 5028.182);\n}\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nvec3 DrawBelt(ivec3 belt, vec2 uv, vec2 gID)\n{\n    vec3 c = vec3(0.0);\n\n    if(int(gID[(belt.y + 1) % 2]) == belt.x)\n    {\n        float dir = (float(belt.z) * 2.0) - 1.0;\n        if(belt.y > 0)\n        {\n             uv.y += iTime * beltSpeed * dir; \n        }\n        else\n        {\n             uv.x += iTime * beltSpeed * dir; \n        }\n     \n        // Bring uv space to clip space so we can easily rotate\n        vec2 lUV = fract(uv * rowCount) * 2.0 - 1.0;\n\n        if(belt.y == 1)\n        {\n            lUV = Rotate(lUV, 90. * dir);\n        }\n        else\n        {\n            if(dir > 0.0)\n            {\n                lUV = Rotate(lUV, 180.);\n            }\n        }\n\n        // top & bottom lines\n        float tL = sdSegment(lUV, vec2(-1.0, 1.0), vec2(1.0, 1.0));\n        tL = 1.0 - step(0.1, abs(tL));\n    \n        float bL = sdSegment(lUV, vec2(-1.0, -1.0), vec2(1.0, -1.0));\n        bL = 1.0 - step(0.1, abs(bL));\n    \n        float d = sdArrow(lUV, 0.6);\n    \n        c = vec3(0.2);\n        c += d * vec3(0.05, 0.05, 0.05);\n        c += (tL + bL) * vec3(0.125);\n     }\n     \n     return vec3(0.0, c.g, 0.0);\n}\n\nvec3 DrawObject(ivec3 belt, vec2 uv)\n{\n    vec3 color;\n    float dir = (float(belt.z) * 2.0) - 1.0;\n    float fTime = fract(iTime * beltSpeed * -dir);\n\n    uv[belt.y] += -fTime;\n\n    float mask = cos(uv[belt.y] * pi * 8. + pi * 0.5);\n\n    vec2 lUV = fract(uv * rowCount);\n    lUV *= 2.0;\n    lUV -= 1.0;\n    lUV = Rotate(lUV, 12.);\n    \n    float d = sdHexagon(lUV, 0.3);\n    d = abs(d);\n    d = smoothstep(0.0, 0.7, d);\n    d = 0.2 / d;\n         \n    if(mask > 0.2)\n    color.r += d * (mask * 0.5);    \n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 gID = floor(uv * rowCount);\n    float n = N21(gID);\n    ivec2 belt = ivec2(2, 0);\n    \n    ivec3 belts[6] = ivec3[6]\n    (ivec3(1, 0, 0), ivec3(1, 1, 1), ivec3(6, 0, 0),\n     ivec3(6, 1, 1), ivec3(3, 1, 0), ivec3(3, 0, 1));\n    \n    vec3 color = vec3(0.0);\n    \n    float time = iTime * 0.25;\n    int beltIndex = int(floor(time)) % 6;\n    \n    for(int i = 0; i < 6; i++)\n    {\n        vec3 c = DrawBelt(belts[i], uv, gID);\n        \n        if(c != vec3(0.0))\n        {\n            color = DrawBelt(belts[i], uv, gID);\n            color += DrawObject(belts[i], uv);\n        }\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}