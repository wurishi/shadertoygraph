{"ver":"0.1","info":{"id":"4cfyDM","date":"1721253007","viewed":61,"name":"palying with fract","username":"jamielobban","description":"asd","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cloud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 100;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 5.0;\nconst float PRECISION = 0.001;\nconst float MARCH_SIZE = 0.2;\n\n////////////////////////////////////////////////////\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(1.0-2.0*f);\n\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm(vec3 p) {\n  vec3 q = p + iTime * 0.2 * vec3(1., 0.0, -.2);\n  float f = 0.01;\n  float scale = 0.6;\n  float factor = 1.;\n\n  for (int i = 0; i < 6; i++) {\n      f += scale * noise(q * 2.3);\n      q *= factor;\n      factor += 0.2;\n      scale *= 0.35;\n  }\n\n  return f;\n}\n////////////////////////////////////////////////////\nfloat sdSphere(vec3 p, float s, vec3 elongation)\n{\n    vec3 scaledP = p / elongation;\n    return length(scaledP) - s;\n}\n\nfloat scene(vec3 p) {\n  float distance = sdSphere(p, 0.95, vec3(2.0,1.2,1.0));\n\n  float f = fbm(p);\n\n  return -distance + f ;\n}\n\nvec4 rayMarch(vec3 ro, vec3 rd, float start, float end) {\n    vec4 res = vec4(0.0);\n    res.a = start; \n    \n    float howdense = 0.0;\n    float totalDensity = 0.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 p = ro + res.a * rd;\n        float density = scene(p);\n        \n        if (density > PRECISION) {\n            howdense = density / 36.0; \n            float edgeFactor = smoothstep(0.0, 1.0, res.a / 66.);\n            howdense *= (1.0 - edgeFactor);\n            \n            res.rgb += vec3(2.0 - totalDensity) * vec3(howdense * 0.5); \n            totalDensity += howdense * 15.;\n        }\n\n        res.a += MARCH_SIZE;\n        \n        if (res.a > MAX_DIST) break;\n    }\n\n    return res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 backgroundColor = vec3(0.835, 1.0, 1.0);\n\n    vec3 ro = vec3(0.0, -0., 5.0); // Camera position\n    vec3 rd = normalize(vec3(uv, -1.0)); // Ray direction\n\n    vec4 res = rayMarch(ro, rd, MIN_DIST, MAX_DIST);\n    \n    vec3 finalColor = res.rgb;\n    finalColor *= 10.0; \n\n    vec3 bg = mix(vec3(0.216,0.000,0.761), vec3(0.000,0.667,1.000), 1.0 - (uv.y + 1.0) * 0.7);\n    \n    finalColor += bg * 0.4;\n    \n    //finalColor = pow(finalColor.rgb, vec3(1.0 / 2.2)); \n\n    fragColor = vec4(finalColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}