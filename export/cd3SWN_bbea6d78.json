{"ver":"0.1","info":{"id":"cd3SWN","date":"1679767250","viewed":45,"name":"gpt4 cat5: cat under table","username":"memo","description":"code created by chatgpt using gpt4\nsee code comments","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["chatgpt","gpt4"],"hasliked":0,"parentid":"cscXD4","parentname":"gpt4 cat4: cat on table"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\ncode created by chatgpt using gpt4\ncontinuing from before (See fork or https://www.shadertoy.com/user/memo )\nprompt:\nmake the cat sit under the table\n\ngpt4 outputted only relevant code changes:\n- new sceneSDF\n\nI had to make two minor compile errors in sceneSDF to change vec2 to vec3.\n*/\n\n\n/*\nTo make the cat sit under the table, we'll adjust the cat's position accordingly.\nHere's the updated fragment shader:\n\nIn this updated code, we've adjusted the positions of the cat's body, head, and ears,\nso the cat is now sitting under the table.\n\nCopy and paste this updated code into ShaderToy (https://www.shadertoy.com/) to see\nthe cat sitting under the table in the 3D scene.\n*/\n\n\nfloat sphereSDF(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat boxSDF(vec3 p, vec3 center, vec3 size) {\n    vec3 d = abs(p - center) - size;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat unionSDF(float d1, float d2) {\n    return min(d1, d2);\n}\n\n\nfloat sceneSDF(vec3 p) {\n    // Cat body\n    float body = sphereSDF(p, vec3(0.0, -0.4, 0.0), 1.0);\n\n    // Cat head\n    float head = sphereSDF(p, vec3(0.0, 0.1, 0.0), 0.7);\n\n    // Cat ears\n    float leftEar = boxSDF(p, vec3(-0.4, 0.8, 0.0), vec3(0.2, 0.3, 0.1)); // MEMO changed vec2 to vec3\n    float rightEar = boxSDF(p, vec3(0.4, 0.8, 0.0), vec3(0.2, 0.3, 0.1)); // MEMO changed vec2 to vec3\n\n    // Table\n    float table = boxSDF(p, vec3(0.0, 0.5, 0.0), vec3(2.0, 0.5, 2.0));\n\n    return unionSDF(unionSDF(unionSDF(body, head), unionSDF(leftEar, rightEar)), table);\n}\n\n\nvec3 getNormal(vec3 p) {\n    float eps = 0.001;\n    vec2 h = vec2(eps, 0.0);\n    return normalize(vec3(\n        sceneSDF(p + h.xyy) - sceneSDF(p - h.xyy),\n        sceneSDF(p + h.yxy) - sceneSDF(p - h.yxy),\n        sceneSDF(p + h.yyx) - sceneSDF(p - h.yyx)\n    ));\n}\n\n\nmat3 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(\n        oc * axis.x * axis.x + c,\n        oc * axis.x * axis.y - axis.z * s,\n        oc * axis.z * axis.x + axis.y * s,\n        oc * axis.x * axis.y + axis.z * s,\n        oc * axis.y * axis.y + c,\n        oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s,\n        oc * axis.y * axis.z + axis.x * s,\n        oc * axis.z * axis.z + c\n    );\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float t = iTime * 0.1;\n    vec3 cameraPos = vec3(5.0 * cos(t), 2.0, 5.0 * sin(t));\n    vec3 target = vec3(0.0, 1.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n\n    vec3 cameraForward = normalize(target - cameraPos);\n    vec3 cameraRight = normalize(cross(up, cameraForward));\n    vec3 cameraUp = cross(cameraRight, cameraForward); // MEMO swapped order of cross product\n    mat3 viewMatrix = mat3(cameraRight, cameraUp, -cameraForward);\n\n    vec3 rayDir = -normalize(viewMatrix * vec3(uv, 1.0)); // MEMO made this -ve\n\n    vec3 p = cameraPos;\n    for (int i = 0; i < 64; ++i) {\n        float t = sceneSDF(p);\n        if (t < 0.001) {\n            break;\n        }\n        p += rayDir * t;\n    }\n\n    vec3 normal = getNormal(p);\n    vec3 lightDir = normalize(vec3(-0.5, 1.0, -1.0));\n    float diffuse = max(dot(normal, lightDir), 0.0);\n    vec3 color = vec3(0.8, 0.6, 0.4) * diffuse;\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}