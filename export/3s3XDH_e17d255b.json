{"ver":"0.1","info":{"id":"3s3XDH","date":"1571865311","viewed":139,"name":"IFS Escape Time","username":"SSHantaram","description":"Visualisation for arbitrary 2D IFS fractals with 3 functions\nRendered using stochastic escape time accumulated over time.\nIts not fast but works as a fragment shader and is general purpose.\nPress Space to reset buffer","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["fractal","ifs","escapetime"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4( texelFetch( iChannel0, ivec2(fragCoord), 0 ).xxx, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nVisualisation for arbitrary 2D IFS fractals with 3 functions\nrendered using stochastic escape time accumulated over time.\nIts not fast but works as a fragment shader and is general purpose.\n\nFor each pixel one of three transformations is iteratively chosen randomly.\nAfter a number of iterations a value is determined based on the distance from the origin.\nIf this value is bigger than a threshold it gets added to the current pixel value.\n\nThis is repeated several times per pixel with slight variation of the starting position\nand differently seeded random transformations for better convergence.\nThe brightness values get accumulated over time.\n\nPress Space to reset buffer\n\nChange FRACTAL to see different examples:\n\n\t0: sierpinsky triangle\n\t1: barsley fern\n\t2: acorn leaf\n\t3: swirl\n\n*/\n\n#define FRACTAL 2\n\nconst float PI = 3.141592;\n\n//From http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint hash(uvec2 x) {\n    x = uvec2(0x3504f333, 0xf1bbcdcb)*x; \n    return (x.x^x.y) * 741103597u;\n}\n\n//From https://iquilezles.org/articles/sfrand\nfloat uintBitsToFloat01(uint x) {\n    return uintBitsToFloat((x >> 9u) | 0x3f800000u) - 1.0;\n}\n\nfloat hash(vec2 p) {\n    uvec2 x = floatBitsToUint(p);\n    return uintBitsToFloat01(hash(x));\n}\n\n// scale matrix\nmat3 scale(vec2 scale)\n{\n    return mat3(scale.x,\t0.0,\t\t0.0,\n                0.0,\t\tscale.y,\t0.0,\n                0.0,\t\t0.0,\t\t1.0);\n}\n\n// translation matrix\nmat3 translate(vec2 t)\n{\n    return mat3(1.0,\t0.0,\tt.x,\n                0.0,\t1.0,\tt.y,\n                0.0,\t0.0,\t1.0);\n}\n\n// rotation matrix\nmat3 rotate(float alpha)\n{\n \treturn mat3(cos(alpha),\t-sin(alpha),\t0.0,\n                sin(alpha),\t cos(alpha),\t0.0,\n                0.0,\t\t 0.0,\t\t\t1.0);\n}\n\nconst int SPACE_BAR = 32;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\t\n    /*\n    set up transformations and constants based on FRACTAL\n\titerations: number of transformations performed\n\t\tsmaller => faster, blurry, less details\n\t\tbigger  => slower, sharper, more details\n\n\tnumTries: number of tries for each pixel every frame\n\t\tif FPS < 60 more tries help to converge faster\n\n\tthreshold: min value to contribute to acumulated image\n\t\tsmaller => faster, blurry\n\t\tbigger  => slower, sharper\n    */\n    \n    #if FRACTAL==0\n\t// sierpinsky triangle\n    mat3 transform1 = scale(vec2(2.0, 2.0))*translate(vec2( 0.5,  0.5));\n    mat3 transform2 = scale(vec2(2.0, 2.0))*translate(vec2(-0.5,  0.5));\n    mat3 transform3 = scale(vec2(2.0, 2.0))*translate(vec2( 0.0, -0.5));\n\tint iterations = 8;\n    int numTries = 30;\n    float threshold = 0.05;\n    #endif\n    \n    #if FRACTAL==1\n   \t// barsley fern\n    mat3 transform1 = scale(vec2(2.3, 2.3))*translate(vec2( 0.35,  0.6))*rotate(-0.3*PI);\n    mat3 transform2 = scale(vec2(2.3, 2.3))*translate(vec2(-0.4,  0.7))*rotate(0.3*PI);\n    mat3 transform3 = scale(vec2(1.3, 1.3))*translate(vec2( -0.03, -0.1))*rotate(0.02*PI);;\n    int iterations = 13;\n    int numTries = 30;\n    float threshold = 0.01;\n    #endif\n    \n    #if FRACTAL==2\n   \t// acorn leaf\n    mat3 transform1 = scale(vec2(1.7, 1.7))*translate(vec2( 0.5,  0.1))*rotate(-0.3*PI);\n    mat3 transform2 = scale(vec2(1.7, 1.7))*translate(vec2(-0.5,  0.1))*rotate(0.3*PI);\n    mat3 transform3 = scale(vec2(1.9, 1.9))*translate(vec2( 0.0, -0.4));\n\tint iterations = 8;\n    int numTries = 30;\n    float threshold = 0.08;\n    #endif\n    \n    #if FRACTAL==3\n   \t// swirl\n    mat3 transform1 = scale(vec2(1.6, 1.6))*translate(vec2( 0.2,  -0.2))*rotate(0.7*PI);\n    mat3 transform2 = scale(vec2(1.45, 1.45))*translate(vec2(-0.5,  -0.1))*rotate(0.2*PI);\n    mat3 transform3 = scale(vec2(1.9, 1.9))*translate(vec2(-0.2, -0.4))*rotate(0.3*PI);\n\tint iterations = 10;\n    int numTries = 30;\n    float threshold = 0.08;\n    #endif\n    \n    float val = texelFetch(iChannel0, ivec2(fragCoord), 0).x;\t\t\t\t// get pixel value from last frame\n    if(texelFetch(iChannel1, ivec2(SPACE_BAR,0), 0 ).x > 0.1) val = 0.0;\t// reset with space bar\n    \n    for (int i = 0; i < numTries; i++)\t// try several times\n    {\n        // offset position slightly every try\n        vec2 offset = vec2(hash(fragCoord), hash(fragCoord + 1000.0));\n        vec3 uv = vec3((fragCoord + offset - 0.5*iResolution.xy)/iResolution.y, 1.0);\n        \n        // iteratively transform point\n    \tfor (int j = 0; j < iterations; j++)\n    \t{\n            // choose transformation at random\n        \tfloat rand = hash(uv.xy + vec2(float(j), float(iTime) + 3065.15573*float(i)));\t// between [0.0, 1.0]\n            if (3.0*rand < 1.0) uv *= transform1;\t\t// first transformation\n        \telse if (3.0*rand < 2.0) uv *= transform2;\t// second transformation\n        \telse uv *= transform3;\t\t\t\t\t\t// third transformation\n    \t}\n        // calculate value to add\n        // used pow to get a fast falloff, values experimentally chosen\n        val += 3.0*max(0.1/pow(length(uv), 2.5) - threshold, 0.0);\n    }\n    \n    fragColor = vec4(val, 0.0, 0.0, 0.0);\t// add to accumulated value\n}","name":"Buffer A","description":"","type":"buffer"}]}