{"ver":"0.1","info":{"id":"3ljBDc","date":"1600032373","viewed":109,"name":"Midnight Maya Pyramid ","username":"zproxy","description":"https://www.shadertoy.com/view/tlSfW3","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["pyramid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// textured + displaced + mouse control variant of https://shadertoy.com/view/wl2BWV\n// forest variant of https://shadertoy.com/view/tlSfDK\n\n#define rot(a)        mat2( cos( a + vec4(0,33,11,0)) )\n#define sfloor(x)   ( floor(x-pix/2.) + max( 0., 1.-fract(-x+pix/2.) / pix ) ) // https://www.shadertoy.com/view/tsyXzV \n#define hash2x3(p)    fract(sin((p)*mat3x2(127.1,311.7,  269.5,183.3,  113.5,271.9))*43758.5453123) // https://www.shadertoy.com/view/llySRh\n#define keyPress(a) ( texelFetch(iChannel3,ivec2(a,0),0).x > 0.) // https://www.shadertoy.com/view/llySRh\n#define T(V)          texture(iChannel1,V/4.)\n\nfloat pix, s;                                         // a: material id\n\n\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n \n\n//From Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec3 hash33(vec3 p)\n{\n    p = fract(p * vec3(443.8975,397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz+19.27);\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z));\n}\n\n//Very happy with this star function, cheap and smooth\nvec3 stars(in vec3 p)\n{\n    // 47fps\n    \n    vec3 c = vec3(0.);\n    float res = iResolution.x*1.5; // too small  and they will flicker\n    \n    // more stars?\n\tfor (float i=0.;i<2.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = hash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.25+0.75);\n        p *= 1.4;\n    }\n    return c*c*.7;\n}\n\nvec4 startrails(in vec3 rd)\n{\n    vec3 col0 = stars( normalize(rotx(rd, iTime * 0.1)));\n\n    vec3 col = col0;\n\n    for (int i = -160; i < 0; i++)\n    {\n    \tvec3 col1 = stars( normalize(rotx(rd, iTime * 0.1 + (float(i) * (1./600.) ))));\n        \n    \tcol += col1;    \n    }\n    \n    return vec4(3.*col,1);\n}\n\nfloat map( vec3 p ) {\n    float t,a; vec3 q = p;\n    q.xy = abs(q.xy), a = max(q.x,q.y);               // --- pyramid\n    t = max( (a==q.x?q.y:q.x) -2.,                    // slopes sides\n             a/1.3 + clamp(q.z,0.,9.) -9.25 );        // slopes top \n    t = max( t, q.z-7.);                              // top end\n    t = min( t, a + clamp(sfloor(q.z),0.,7.) - 9.);   // grades \n    t = max( t,-max(min(q.x,q.y)-.5,abs(q.z-7.5)-.5));// doors\n    t = max( t,-max(3.*abs(q.z-7.5),a)+1.5 );         // room\n    t = max( t, q.z-9.);                              // top end\n    s = q.z;                                          // --- forest. floor, then trees\n    q = .03*sin(15.*p); p += q.x+q.y+q.z;             // distortion\n    for (int k=0; k<9; k++) {                         // Worley-like dot structure\n        vec2 d = vec2(k%3-1,k/3-1);                   // seek for closest dot in 9x9 cells around\n        s = min(s, length( hash2x3(floor(p.xy)+d)           // random dot(cell)\n                          - vec3(fract(p.xy)-d,p.z) ) -.5); // raypos rel to cur cell\n    }\n    return min(t,s);\n}\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  R = iResolution.xy,\n          U = ( 2.*u - R ) / R.y,                     // normalized centered coords\n          M = iMouse.xy / R;\n    pix = .5; // 100./R.y;\n    float t = iTime*0.0125, _t = 1.+.5*sin(.2*(t+5.)), \n          c = 0.,z = 1.5;                              // color (pseudo-shading), zoom\n    t*=.3; if (iMouse.z>0.)                           // mouse control\n        _t = keyPress(32) ? z=9.*M.y,_t : 1.6*M.y, t = -3.*M.x;\n    vec3  D = normalize( vec3(U,-z) ),                // ray direction. z = field of view = zoom\n          p = vec3(0,1,25);                           // ray origin, then current point on ray\n    D.yz *= rot(_t); D.xy *= rot(0.8 + t);                  // rotate camera\n    p.yz *= rot(_t); p.xy *= rot(0.25 + t);\n    t = 1e5;\n    for ( ; c < 50. && t > .01 ; c++ )                // march scene\n        t = map(p),                                   // distance to objects\n        //t != s ? t += .3*( T(.3*p.xy)+T(.3*p.xz)+T(.3*p.yz) -1.5 ).r : t, // displacement (temple)\n        p += .5*t*D;                                  // sphere-tracing step\n    \n  //c = 1. - c/50.;                                   // pseudo-lighting\n    c = 3.*exp(-c/9.11);\n    O = t==s                                          // coloring\n             ?  p.z > 2. ? startrails(D)+vec4(0,0,4, 0)*(0.1 +tan(D.z)*0.7) // sky\n             :  vec4(0,.1127,0.115 ,1)*(.7+.3*p.z)                       // cyan forest\n              *(.5+1.5 )\n             : vec4(0.12,0.1,.6,1)  ;// temple\n    O = pow( c*O, vec4(1./2.2) );                     // to sRGB\n}\n","name":"Image","description":"","type":"image"}]}