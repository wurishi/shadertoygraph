{"ver":"0.1","info":{"id":"csjyRm","date":"1687532851","viewed":66,"name":"Subpixel line antialiasing","username":"stduhpf","description":"Depending on how your display is made, you could have to change the layout (line 172/174). (for more exotic subpixel layouts like whatever samsung does with their QD-OLED, this might need more work) \n\nThis assumes subpixels are rectangular. (and no WRGB) ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["antialiasing","subpixel","integration"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/** Single channel **/\nvec2 intersect(vec2 ro, vec2 rd, vec2 box){\n    // axis-aligned 2d box intersection\n    vec2 tmin = -ro/rd;\n    vec2 tmax = (box-ro)/rd;\n    vec2 t1 = min(tmin,tmax);\n    vec2 t2 = max(tmin,tmax);\n    return vec2(max(t1.x,t1.y),min(t2.x,t2.y));\n}\n\nbool float_eq(float x, float y){\n    float d = x-y;\n    return d*d<.00001;\n}\nfloat hitarea(vec2 p1, vec2 p2, vec2 box, vec2 n){\n    \n    vec2 diff = abs(p1-p2);\n    float triarea = diff.x*diff.y/2.;\n    \n    vec2 p1n = p1/box,p2n = p2/box;\n    vec2 p1ns = p1n*p1n,p2ns = p2n*p2n;\n    bool quadx = float_eq(p1ns.x,p1n.x) && float_eq(p2ns.x,p2n.x);\n    bool quady = float_eq(p1ns.y,p1n.y) && float_eq(p2ns.y,p2n.y);\n    bool quad = (quadx) || (quady) ;\n        \n    vec2 sn = -sign(n);\n    \n    float boxarea = box.x*box.y;\n    \n    p1 = min(p1,box-p1);\n    p2 = min(p2,box-p2);\n    \n    p1 = min(p1,p2)*box.yx;\n    \n    float quadarea = triarea + (quady?p1.x:p1.y);\n        \n    float area = quad?\n        quadarea:\n        triarea;\n    return area;\n}\n\n\nfloat edgeIntegral(vec2 lo, vec2 ln, vec2 box){\n    vec2 ld = vec2(-ln.y,ln.x);\n     vec2 i = intersect(lo,ld,box); \n        \n    vec2 p1 = lo+i.x*ld;\n    vec2 p2 = lo+i.y*ld;\n    \n    float boxarea = box.x*box.y;\n\n    bool hit = i.x<=i.y;\n    \n    float area = hit?hitarea(p1,p2,box,ln):0.;\n    area/=boxarea;\n    \n    area = dot(ln,box*.5-lo)>0.?area:1.-area;\n    \n    return area;\n}\n\nfloat lineAA(vec2 origin,vec2 orth,vec2 subpixelSize){\n    origin-=orth;\n    float pxarea = edgeIntegral(origin,orth,subpixelSize);\n\n    origin += 2.*orth;\n\n    pxarea += edgeIntegral(origin,-orth,subpixelSize);\n    return 1.-pxarea;\n}\n\n/** 3 channel version **/\n// (I'm not sure if this is actually faster than calling the single channel version 3 times)\n\nmat3x2 min32(mat3x2 a,mat3x2 b){\n    return mat3x2(min(a[0],b[0]),min(a[1],b[1]),min(a[2],b[2]));\n}\n\nmat3x2 max32(mat3x2 a,mat3x2 b){\n    return mat3x2(max(a[0],b[0]),max(a[1],b[1]),max(a[2],b[2]));\n}\nmat3x2 abs32(mat3x2 a){\n    return mat3x2(abs(a[0]),abs(a[1]),abs(a[2]));\n}\nmat2x3 sq23(mat2x3 a){\n   return mat2x3(a[0]*a[0],a[1]*a[1]);\n}\n\nvec3 vec3_eq(vec3 x, vec3 y){\n    vec3 d = x-y;\n    return step(vec3(0),d*d-vec3(.00001));\n}\n\nmat2x3 intersect3(mat3x2 ro, mat3x2 rd, mat3x2 box){\n    // axis-aligned 2d boxes intersection\n    mat3x2 tmin = -ro/rd;\n    mat3x2 tmax = (box-ro)/rd;\n    mat2x3 t1 = transpose(min32(tmin,tmax));\n    mat2x3 t2 = transpose(max32(tmin,tmax));\n    return mat2x3(max(t1[0],t1[1]),min(t2[0],t2[1]));\n}\n\nvec3 hitarea3(mat3x2 p1, mat3x2 p2, mat3x2 box, vec2 n){\n    \n    mat2x3 diff = transpose(abs32(p1-p2));\n    vec3 triarea = diff[0]*diff[1]/2.;\n    \n    mat2x3 p1n = transpose(p1/box),p2n = transpose(p2/box);\n    mat2x3 p1ns = sq23(p1n),p2ns = sq23(p2n);\n    \n    vec3 quadx = vec3_eq(p1ns[0],p1n[0]) * vec3_eq(p2ns[0],p2n[0]);\n    vec3 quady = vec3_eq(p1ns[1],p1n[1]) * vec3_eq(p2ns[1],p2n[1]);\n    vec3 quad = max((quadx) + (quady),1.);\n        \n    vec2 sn = -sign(n);\n    mat2x3 boxt = transpose(box);\n    vec3 boxarea = boxt[0]*boxt[1];\n    \n    p1 = min32(p1,box-p1);\n    p2 = min32(p2,box-p2);\n    \n    p1 = mat2(box[0].y,0,0,box[0].x)*min32(p1,p2);\n    \n    mat2x3 p1t = transpose(p1);\n\n    vec3 quadarea = triarea + (mix(p1t[0],p1t[1],quady));\n        \n    vec3 area = mix(triarea,quadarea,quad);\n    return area;\n}\n\nvec3 edgeIntegral3(mat3x2 lo, vec2 ln, vec2 box){\n    vec2 ld = vec2(-ln.y,ln.x);\n    \n    mat3x2 box3 = mat3x2(box,box,box);\n    mat3x2 ld3 = mat3x2(ld,ld,ld);\n     mat2x3 i = intersect3(lo,ld3,box3); \n       \n    mat3x2 p1 = lo+ld3*mat3(i[0].x,0,0,0,i[0].y,0,0,0,i[0].z);\n    mat3x2 p2 = lo+ld3*mat3(i[1].x,0,0,0,i[1].y,0,0,0,i[1].z);\n    \n    float boxarea = box.x*box.y;\n\n    vec3 hit = step(vec3(0),(i[1]-i[0]));\n    \n    vec3 area = hit*hitarea3(p1,p2,box3,ln);\n    area/=boxarea;\n    \n    area = mix(area,1.-area,step(ln*(box3*.5-lo),vec3(0.)));\n    \n    return area;\n}\n\n\nvec3 lineAA3(mat3x2 origin,vec2 orth,vec2 subpixelSize){\n    mat3x2 orth3 = mat3x2(orth,orth,orth);\n    origin-=orth3;\n    vec3 pxarea = edgeIntegral3(origin,orth,subpixelSize);\n\n    origin += 2.*orth3;\n\n    pxarea += edgeIntegral3(origin,-orth,subpixelSize);\n    return 1.-pxarea;\n}\n\nvec3 lineSPAA(vec2 origin,vec2 orth,vec2 subpixelSize){\n\n    const vec3 LAYOUT_RGB = vec3(0.,1./3.,2./3.);\n    const vec3 LAYOUT_BGR = LAYOUT_RGB.bgr;\n    \n    const bool LAYOUT_VERTICAL = false;\n    \n    vec3 subpixel_layout = LAYOUT_RGB;\n    if(LAYOUT_VERTICAL) subpixelSize=subpixelSize.yx;\n    vec3 col = vec3(0.);\n\n    mat3x2 subpixelOffsets = LAYOUT_VERTICAL?\n        mat3x2(0,subpixel_layout.r,0,subpixel_layout.g,0,subpixel_layout.b):\n        mat3x2(subpixel_layout.r,0,subpixel_layout.g,0,subpixel_layout.b,0);\n    \n    mat3x2 pxros = subpixelOffsets + mat3x2(origin,origin,origin);\n\n    return lineAA3(pxros,orth,subpixelSize);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 3.*(fragCoord-.5*iResolution.xy)/iResolution.y+.5;\n    vec2 um = 3.*(iMouse.xy-.5*iResolution.xy)/iResolution.y+.5;\n\n    \n    const float width = 1.\n                    /2.; //rather half-with (.5 => single pixel)\n    \n    vec2 ro = vec2(-1.,-.5);\n    vec2 rd = normalize(ro-vec2(um));\n    \n    \n    vec2 orth = rd.yx*vec2(1,-1)*width;\n\n\n\n    vec2 subpixelSize = vec2(1./3.,1.);\n    vec3 col = vec3(0.);\n    \n    vec2 pixro = ((ro-.5)*iResolution.y/3.+.5*iResolution.xy);\n    \n    col+=lineSPAA(fragCoord-pixro,orth,subpixelSize);\n    /*\n    const vec3 LAYOUT_RGB = vec3(0.,1./3.,2./3.);\n    const vec3 LAYOUT_BGR = LAYOUT_RGB.bgr;\n    \n    const bool LAYOUT_VERTICAL = false;\n    \n    vec3 subpixel_layout = LAYOUT_RGB;\n    if(LAYOUT_VERTICAL) subpixelSize=subpixelSize.yx;\n\n    for(int i=0;i<3;i++){\n    \n        vec2 subpixelOffset = vec2(subpixel_layout[i],0);\n        if(LAYOUT_VERTICAL) subpixelOffset=subpixelOffset.yx;\n\n        // a thick line can be made as the intersection of two parallel hard edges \n    \n        vec2 pro = subpixelOffset+fragCoord-pixro;\n    \n        col[i]+=lineAA(pro,orth,subpixelSize);\n    }\n    */\n     \n    vec2 box = vec2(1./3.,1.);\n\n    vec2 i = intersect(ro,rd,box); \n        \n    vec2 p1 = ro+i.x*rd;\n    vec2 p2 = ro+i.y*rd;\n\n    float area = edgeIntegral(ro,orth,box);\n    if(uv == abs(uv) && uv.x<box.x && uv.y <box.y)\n        col+=.5;\n    if(uv.y<-.6) col += vec3(1,0,0)*step(fragCoord.x/iResolution.x,area);\n\n    // gamma correction\n    fragColor = vec4(pow(col,vec3(1./2.2)),1.0);\n}","name":"Image","description":"","type":"image"}]}