{"ver":"0.1","info":{"id":"ftsBDM","date":"1650979103","viewed":122,"name":"Haru86_ray_220426","username":"Haru86_","description":"Haru86_ray_220426","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime\n#define resolution iResolution\n\n#define PI 3.14159265\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nstruct dobj\n{\n  float dm;\n  float d0;\n  float d1;\n};\n\nmat3 orthBas(vec3 z){\n  z=normalize(z);\n  vec3 up=abs(z.y) > 0.999 ? vec3(0,0,1) : vec3(0,1,0);\n  vec3 x=normalize(cross(up,z));\n  return mat3(x,cross(z,x),z);\n}\n\nvec3 cyclicNoise(vec3 p){\n  mat3 b=orthBas(vec3(3.0,-1.2,5.4));\n  float warp=1.0;\n  float amp=0.5;\n\n  vec3 result=vec3(0.0);\n\n  for(int i=0;i<4;i++){\n    p*=2.0*b;\n    p+=warp*sin(p.zxy);\n\n    result+=amp*cross(sin(p.yzx),cos(p));\n\n    warp*=1.2;\n    amp*=0.5;\n  }\n\n  return result;\n}\n\nvec2 pmod(vec2 p,float fnum){\n  float a= -atan(p.x,p.y) + PI/fnum;\n  float n=PI*2.0/fnum;\n  a=floor(a/n)*n;\n  p*=rot(a);\n  return p;\n}\n\nfloat cube(vec3 p,vec3 size){\n  return length(max(vec3(0.0),abs(p)-size));\n}\n\ndobj map(vec3 p){\n  //\n  dobj o;\n\n  //\n  vec3 p0=p;\n  p0.z-=time*5.;\n  p0+=0.32*cyclicNoise(p0+time);\n  float d0=p0.y+0.5;\n  o.d0=d0;\n\n  //\n  vec3 p1=p;\n  p1.y-=0.25;\n  p1.xy*=rot(PI/2.0);\n\n  vec3 p1r=p1;\n //p1.y=abs(p1.y);\n p1=abs(p1)-.35;\n p1=abs(p1)-0.2;\n\n  float edge=min(0.025,exp(-length(abs(p1r.z*10.0))));\n\n   p1.xy*=rot(0.5);\n\n   float dt=floor(time)+pow(fract(time),0.5);\n\n   p1.z=abs(p1.z)-0.1;\n   //p1.z-=0.1;\n   p1.xy*=rot(dt);\n   p1.xz*=rot(dt);\n   p1.yz*=rot(dt);\n\n   p1.xy=pmod(p1.xy,3.0);\n   p1.yz=pmod(p1.yz,12.0);\n   //p1.xz=pmod(p1.xz,12.0);\n\n  float d1=cube(p1,vec3(edge,edge,0.5));\n  o.d1=d1;\n\n  // combine\n  d0=min(d0,d1);\n  o.dm=d0;\n  return o;\n}\n\nvec3 gn(vec3 p){\n  vec2 e=vec2(0.001,0.0);\n  return normalize(vec3(\n      map(p+e.xyy).dm-map(p-e.xyy).dm,\n      map(p+e.yxy).dm-map(p-e.yxy).dm,\n      map(p+e.yyx).dm-map(p-e.yyx).dm\n    ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 col=vec3(0.0);\n\n  vec2 st=(fragCoord.xy*2.0-resolution.xy)/min(resolution.x,resolution.y);\n\n  vec3 ta=vec3(0.0);\n  float r=2.0;\n  float sp=0.5;\n  vec3 ro=vec3(r*cos(time*sp),sin(time*sp)*0.65+0.5,r*sin(time*sp));\n\n  vec3 cdir=normalize(ta-ro);\n  vec3 cside=normalize(cross(cdir,vec3(0.0,1.0,0.0)));\n  vec3 cup=normalize(cross(cside,cdir));\n\n  vec3 rd=normalize(vec3(cside*st.x+cup*st.y+cdir));\n\n  float d,t,acc=0.0;\n\n  //\n  dobj o;\n\n  for(int i=0;i<128;i++){\n    o=map(ro+rd*t);\n    d=o.dm;\n    if(d<0.001)break;\n    t+=d;\n    acc+=exp(-3.0*d);\n  }\n\n  vec3 p=ro+rd*t;\n\n  if(o.d0<0.001){\n      col+=vec3(1.0)*acc*0.015*vec3(0.8,0.2,0.1);\n  }else if(o.d1<0.001){\n      col+=vec3(1.0)*acc*0.2*vec3(0.5,0.1,0.45)*cyclicNoise(p)*vec3(0.8,0.1,0.45);\n  }else{\n\n      // sky box\n      col=col=cyclicNoise(vec3(st*5.,time))*vec3(0.8,0.1,0.45);\n  }\n   \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}