{"ver":"0.1","info":{"id":"wsf3DB","date":"1547391520","viewed":153,"name":"Sphere twist","username":"rodgzilla","description":"Sphere with psychedelic colors.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEP 100\n#define MIN_DIST 0.01\n#define MAX_DIST 30.\n#define FOV_PARAM 2.\n#define SURF_SHIFT 0.1\n\n\n// 0.8, 0.5, 0.4\t\t0.2, 0.4, 0.2\t2.0, 1.0, 1.0\t0.00, 0.25, 0.25\nvec3 palette( in float t ){\n    float wave = sin(iTime * .5) * 0.5 + 0.5;\n    vec3 a = vec3(.8, 0.5, .4);\n    vec3 b = vec3(.2, .4, .2);\n    vec3 c = vec3(2., 1., 1.);\n    vec3 d = vec3( 1. * wave, .25, .25);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nmat2 rot2d(float a) {\n\tfloat c = cos(a);\n    float s = sin(a);\n    \n    return mat2(c, s, -s, c);\n//    return mat2(c, s, c, s);\n}\n\nfloat GetDistSphere(vec3 p, vec4 sphere) {\n \treturn length(p - sphere.xyz) - sphere.w;   \n}\n\nfloat GetDistPlane(vec3 p, float d) {\n    return p.y + d;\n}\n\nfloat GetDistRepSphere(vec3 p, vec4 sphere, vec3 c) {\n    vec3 q = mod(p, c) - 0.5 * c;\n    \n    return GetDistSphere(q, sphere);\n}\n/*\nfloat GetDist_(vec3 p) {\n    vec4 sphere = vec4(0, 0, 1, 0.5);\n    float planeDist = .5;\n    float d = GetDistSphere(p, sphere);\n    d = min(d, GetDistPlane(p, planeDist));\n    \n    return d;\n}\n*/\n\nfloat GetDist(vec3 p) {\n    p.xy *= rot2d(sin(1. * iTime) * p.z / 10.);\n\tfloat wave      = cos(2. * iTime) * 0.5 + 0.5;\n    vec3 repSphere  = vec3(1, 1, 1);\n    vec4 sphere     = vec4(0, 0, .5, .3);\n    float planeDist = MAX_DIST;\n    float dSphere   = GetDistRepSphere(p, sphere, repSphere);\n    float dPlane    = GetDistPlane(p, planeDist);\n    float d         = min(dSphere, dPlane);\n\n    /*float wave = sin(iTime) * 0.5 + 0.5;\n    float d = (dSphere + (wave * 10. * dPlane)) / (1. + 10. * wave);\n\t*/\n    return d;\n}\n\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 n = GetDist(p) - vec3(\n        GetDist(p - e.xyy),\n        GetDist(p - e.yxy),\n        GetDist(p - e.yyx)\n    );\n    \n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float d = 0.;\n    \n    for (int i = 0; i < MAX_STEP; i++) {\n//        rd.xyz          = rd.yzx;\n        vec3 p      = ro + d * rd;\n       \tfloat dist  = GetDist(p);\n        d          += dist;\n        \n        if (dist < MIN_DIST || dist > MAX_DIST) break;\n    }\n    \n    return d;\n}\n\nfloat GetLight(vec3 p, vec3 light) {\n    vec3 toLight = light - p;\n    vec3 n       = GetNormal(p);\n    float dif    = dot(n, normalize(toLight));\n    float dScene = RayMarch(p + SURF_SHIFT * n, normalize(toLight));\n    \n    if (dScene < length(toLight)) dif *= 0.1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv          = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    uv.xy           *= FOV_PARAM * sin(iTime); \n    vec3 col         = vec3(0);\n    vec3 ro          = vec3(0.125, 3., 1);\n//    vec2 roRotCenter = vec2(0, 2);\n    vec2 roRotCenter = vec2(3, 3);\n    ro.xy            = (ro.xy - roRotCenter) * rot2d(.5 * iTime) + (.1 * sin(iTime)) * roRotCenter; \n    vec3 rd          = normalize(vec3(uv.x, uv.y, 1));\n    vec3 light       = vec3(1, 1, 0.5);\n\tfloat d          = RayMarch(ro, rd);\n    vec3 p           = ro + d * rd;\n\tfloat dif        = GetLight(p, light);\n    float wave       = sin(iTime) * 0.5 + 0.5;\n    vec3 palCol      = palette(d / 50.);\n//    col              = palCol * dif;\n    col              = palCol;\n//    col              = vec3(dif);\n    fragColor        = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}