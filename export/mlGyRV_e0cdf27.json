{"ver":"0.1","info":{"id":"mlGyRV","date":"1700412670","viewed":6,"name":"SimpleRayTracer","username":"Centerwing","description":"RayTracer with fresnel","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["shadow","fresnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SOLUTION_CYLINDER_AND_PLANE\n#define SOLUTION_SHADOW\n#define SOLUTION_REFLECTION_REFRACTION\n#define SOLUTION_FRESNEL\n//#define SOLUTION_BLOB\n\nprecision highp float;\n//uniform ivec2 viewport;\n\nstruct PointLight {\n\tvec3 position;\n\tvec3 color;\n};\n\nstruct Material {\n\tvec3  diffuse;\n\tvec3  specular;\n\tfloat glossiness;\n#ifdef SOLUTION_REFLECTION_REFRACTION\n\tfloat reflectionFactor;\n\tfloat refractionIndex;\n\tfloat refractionFactor;\n#endif\n};\n\nstruct Sphere {\n\tvec3 position;\n\tfloat radius;\n\tMaterial material;\n};\n\nstruct Plane {\n\tvec3 normal;\n\tfloat d;\n\tMaterial material;\n};\n\nstruct Cylinder {\n\tvec3 position;\n\tvec3 direction;  \n\tfloat radius;\n\tMaterial material;\n};\n\nconst int blobSphereCount = 3;\n\nstruct Blob {\n\tfloat isoValue;\n\tvec3 spherePositions[blobSphereCount];\n\tMaterial material;\n};\n\nconst int lightCount = 2;\nconst int sphereCount = 3;\nconst int planeCount = 1;\nconst int cylinderCount = 2;\n\nstruct Scene {\n\tvec3 ambient;\n\tPointLight[lightCount] lights;\n\tSphere[sphereCount] spheres;\n\tPlane[planeCount] planes;\n\tCylinder[cylinderCount] cylinders;\n\tBlob blob;\n};\n\nstruct Ray {\n\tvec3 origin;\n\tvec3 direction;\n};\n\n// Contains all information pertaining to a ray/object intersection\nstruct HitInfo {\n\tbool hit;\n\tfloat t;\n\tvec3 position;\n\tvec3 normal;\n\tMaterial material;\n\tbool enteringPrimitive;\n};\n\nHitInfo getEmptyHit() {\n\treturn HitInfo(\n\t\tfalse, \n\t\t0.0, \n\t\tvec3(0.0), \n\t\tvec3(0.0),\n#ifdef SOLUTION_REFLECTION_REFRACTION\t\t\n\t\tMaterial(vec3(0.0), vec3(0.0), 0.0, 0.0, 0.0, 0.0),  // default 1, 1 for empty hit\n#else\n\t\tMaterial(vec3(0.0), vec3(0.0), 0.0),\n#endif\n\t\tfalse);\n}\n\n// Sorts the two t values such that t1 is smaller than t2\nvoid sortT(inout float t1, inout float t2) {\n\t// Make t1 the smaller t\n\tif(t2 < t1)  {\n\t\tfloat temp = t1;\n\t\tt1 = t2;\n\t\tt2 = temp;\n\t}\n}\n\n// Tests if t is in an interval\nbool isTInInterval(const float t, const float tMin, const float tMax) {\n\treturn t > tMin && t < tMax;\n}\n\n// Get the smallest t in an interval\nbool getSmallestTInInterval(float t0, float t1, const float tMin, const float tMax, inout float smallestTInInterval) {\n  \n\tsortT(t0, t1);\n\n\t// As t0 is smaller, test this first\n\tif(isTInInterval(t0, tMin, tMax)) {\n\t\tsmallestTInInterval = t0;\n\t\treturn true;\n\t}\n\n\t// If t0 was not in the interval, still t1 could be\n\tif(isTInInterval(t1, tMin, tMax)) {\n\t\tsmallestTInInterval = t1;\n\t\treturn true;\n\t}  \n\n\t// None was\n\treturn false;\n}\n\nHitInfo intersectSphere(const Ray ray, const Sphere sphere, const float tMin, const float tMax) {\n              \n    vec3 to_sphere = ray.origin - sphere.position;\n  \n    float a = dot(ray.direction, ray.direction);\n    float b = 2.0 * dot(ray.direction, to_sphere);\n    float c = dot(to_sphere, to_sphere) - sphere.radius * sphere.radius;\n    float D = b * b - 4.0 * a * c;\n    if (D > 0.0)\n    {\n\t\tfloat t0 = (-b - sqrt(D)) / (2.0 * a);\n\t\tfloat t1 = (-b + sqrt(D)) / (2.0 * a);\n      \n      \tfloat smallestTInInterval;\n      \tif(!getSmallestTInInterval(t0, t1, tMin, tMax, smallestTInInterval)) {\n          return getEmptyHit();\n        }\n      \n      \tvec3 hitPosition = ray.origin + smallestTInInterval * ray.direction;      \n\t\t\n\t\t//Checking if we're inside the sphere by checking if the ray's origin is inside. If we are, then the normal \n\t\t//at the intersection surface points towards the center. Otherwise, if we are outside the sphere, then the normal \n\t\t//at the intersection surface points outwards from the sphere's center. This is important for refraction.\n      \tvec3 normal = \n          \tlength(ray.origin - sphere.position) < sphere.radius + 0.001? \n          \t-normalize(hitPosition - sphere.position): \n      \t\tnormalize(hitPosition - sphere.position);      \n\t\t\n\t\t//Checking if we're inside the sphere by checking if the ray's origin is inside,\n\t\t// but this time for IOR bookkeeping. \n\t\t//If we are inside, set a flag to say we're leaving. If we are outside, set the flag to say we're entering.\n\t\t//This is also important for refraction.\n\t\tbool enteringPrimitive = \n          \tlength(ray.origin - sphere.position) < sphere.radius + 0.001 ? \n          \tfalse:\n\t\t    true; \n\n        return HitInfo(\n          \ttrue,\n          \tsmallestTInInterval,\n          \thitPosition,\n          \tnormal,\n          \tsphere.material,\n\t\t\tenteringPrimitive);\n    }\n    return getEmptyHit();\n}\n\nHitInfo intersectPlane(const Ray ray,const Plane plane, const float tMin, const float tMax) {\n#ifdef SOLUTION_CYLINDER_AND_PLANE\n\tfloat d_n = dot(ray.direction, plane.normal);\n\tif (d_n == 0.0) {\n\t\t// plane parallel to ray\n\t\treturn getEmptyHit(); \n\t}\n\tvec3 planePosition = plane.normal * plane.d;\n\tfloat t = (dot(planePosition, plane.normal) - dot(ray.origin, plane.normal)) / d_n;\n\t\n\tvec3 normal;\n\tbool enteringPrimitive;\n\tif (ray.origin.y > planePosition.y) {  // if hitting from above\n\t\tnormal = plane.normal;\n\t\t//enteringPrimitive = true;\n\t} else {\n\t\tnormal = -plane.normal;\n\t\t//enteringPrimitive = false;\n\t}\n\tif (t >= 0.0 && isTInInterval(t, tMin, tMax)) {\n\t\treturn HitInfo(\n\t\t\ttrue,\n\t\t\tt,\n\t\t\tray.origin + t * ray.direction,\n\t\t\tnormal,\n\t\t\tplane.material,\n\t\t\tfalse\n\t\t);\n\t}\n#endif  \n\treturn getEmptyHit();\n}\n\nfloat lengthSquared(vec3 x) {\n\treturn dot(x, x);\n}\n\nHitInfo intersectCylinder(const Ray ray, const Cylinder cylinder, const float tMin, const float tMax) {\n#ifdef SOLUTION_CYLINDER_AND_PLANE\n\t// pa = cylinder position\n\t// va = cylinder direction\n\t// r = radius\n\t// p = ray position\n\t// v = ray direction\n\t// t = ray t\n\t\n\t// a = (v-(v,va)va)^2\n\t// b =2(v-(v,va)va, delta_p - (delta_p, va)va)\n\t// c = (delta_p - (delta_p, va)va)^2 -r^2\n\t// delta_p = p-pa\n\t\n\t//struct Cylinder {\n\t//\tvec3 position;\n\t//\tvec3 direction;  \n\t//\tfloat radius;\n\t//\tMaterial material;\n\t//};\n\t\n\tvec3 delta_p = ray.origin - cylinder.position;\n\tfloat vva = dot(ray.direction, cylinder.direction);\n\tvec3 vvvava = ray.direction - (vva * cylinder.direction);\n\tfloat a = dot(vvvava, vvvava);\n\tfloat b = 2.0 * dot(vvvava, delta_p - dot(delta_p, cylinder.direction) * cylinder.direction);\n\t\n\tvec3 dpdpvava = delta_p - dot(delta_p, cylinder.direction) * cylinder.direction;\n\tfloat c = dot(dpdpvava, dpdpvava) - pow(cylinder.radius, 2.0);\n\t\n\tfloat determinant = (b * b) - (4.0 * a * c);\n    if (determinant > 0.0)\n    {\n\t\tfloat t0 = (-b - sqrt(determinant)) / (2.0 * a);\n\t\tfloat t1 = (-b + sqrt(determinant)) / (2.0 * a);\n      \n      \tfloat smallestTInInterval;\n      \tif(!getSmallestTInInterval(t0, t1, tMin, tMax, smallestTInInterval)) {\n          return getEmptyHit();\n        }\n\t\tvec3 hitPosition = ray.origin + smallestTInInterval * ray.direction;\n\t\tvec3 hitPositionOnAxis = cylinder.position + dot((hitPosition-cylinder.position), cylinder.direction) * cylinder.direction;\n\t\tvec3 axisToHitPosition = hitPosition - hitPositionOnAxis;\n      \tvec3 normal = normalize(axisToHitPosition);   \n\t\tbool enteringPrimitive = length(ray.origin - hitPositionOnAxis) >= (cylinder.radius + 0.001);\n\n        return HitInfo(\n          \ttrue,\n          \tsmallestTInInterval,\n          \thitPosition,\n          \tnormal,\n          \tcylinder.material,\n\t\t\tenteringPrimitive\n\t\t);\n\t}\n\t\n#endif  \n    return getEmptyHit();\n}\n\nuniform float time;\n\nHitInfo intersectBlob(const Ray ray, const Blob blob, const float tMin, const float tMax) {\n#ifdef SOLUTION_BLOB\n#else\n\t// Put your blob intersection code here!\n#endif\n    return getEmptyHit();\n}\n\nHitInfo getBetterHitInfo(const HitInfo oldHitInfo, const HitInfo newHitInfo) {\n\tif(newHitInfo.hit)\n  \t\tif(newHitInfo.t < oldHitInfo.t)  // No need to test for the interval, this has to be done per-primitive\n          return newHitInfo;\n  \treturn oldHitInfo;\n}\n\nHitInfo intersectScene(const Scene scene, const Ray ray, const float tMin, const float tMax) {\n\tHitInfo bestHitInfo;\n\tbestHitInfo.t = tMax;\n\tbestHitInfo.hit = false;\n\t\n\tbool blobSolo = false;\t\n#ifdef SOLUTION_BLOB\n\tblobSolo = true;\n#endif\n\t\n\tif(blobSolo) {\n\t\tbestHitInfo = getBetterHitInfo(bestHitInfo, intersectBlob(ray, scene.blob, tMin, tMax));\t\t\n\t} else {\n\t\tfor (int i = 0; i < planeCount; ++i) {\n\t\t\tbestHitInfo = getBetterHitInfo(bestHitInfo, intersectPlane(ray, scene.planes[i], tMin, tMax));\n\t\t}\n\n\t\tfor (int i = 0; i < sphereCount; ++i) {\n\t\t\tbestHitInfo = getBetterHitInfo(bestHitInfo, intersectSphere(ray, scene.spheres[i], tMin, tMax));\n\t\t}\n\n\t\tfor (int i = 0; i < cylinderCount; ++i) {\n\t\t\tbestHitInfo = getBetterHitInfo(bestHitInfo, intersectCylinder(ray, scene.cylinders[i], tMin, tMax));\n\t\t}\n\t}\n\t\n\treturn bestHitInfo;\n}\n\nvec3 shadeFromLight(\n  const Scene scene,\n  const Ray ray,\n  const HitInfo hit_info,\n  const PointLight light)\n{ \n  vec3 hitToLight = light.position - hit_info.position;\n  \n  vec3 lightDirection = normalize(hitToLight);\n  vec3 viewDirection = normalize(hit_info.position - ray.origin);\n  vec3 reflectedDirection = reflect(viewDirection, hit_info.normal);\n  float diffuse_term = max(0.0, dot(lightDirection, hit_info.normal));\n  float specular_term  = pow(max(0.0, dot(lightDirection, reflectedDirection)), hit_info.material.glossiness);\n\n#ifdef SOLUTION_SHADOW\n\tfloat visibility = 1.0;\n\tif (hit_info.hit) {\n\t\tRay hitToLightRay;\n\t\thitToLightRay.origin = hit_info.position;\n\t\thitToLightRay.direction = lightDirection;\n\t\tHitInfo hitToLightHitInfo = intersectScene(scene, hitToLightRay, 0.0001, length(hitToLight));\n\t\tif (hitToLightHitInfo.hit) {\n\t\t\tvisibility = 0.0;\n\t\t}\n\t}\n#else\n  // Put your shadow test here\n  float visibility = 1.0;\n#endif\n\n  return \tvisibility * \n    \t\tlight.color * (\n    \t\tspecular_term * hit_info.material.specular +\n      \t\tdiffuse_term * hit_info.material.diffuse);\n}\n\nvec3 background(const Ray ray) {\n  // A simple implicit sky that can be used for the background\n  return vec3(0.2) + vec3(0.8, 0.6, 0.5) * max(0.0, ray.direction.y);\n}\n\n// It seems to be a WebGL issue that the third parameter needs to be inout instea dof const on Tobias' machine\nvec3 shade(const Scene scene, const Ray ray, inout HitInfo hitInfo) {\n  \n  \tif(!hitInfo.hit) {\n  \t\treturn background(ray);\n  \t}\n\t\n\t//return vec3(0.5) * hitInfo.normal + vec3(0.5);\n  \n    vec3 shading = scene.ambient * hitInfo.material.diffuse;\n    for (int i = 0; i < lightCount; ++i) {\n        shading += shadeFromLight(scene, ray, hitInfo, scene.lights[i]); \n    }\n    return shading;\n}\n\n\nRay getFragCoordRay(const vec2 frag_coord) {\n  \tfloat sensorDistance = 1.0;\n  \tvec2 sensorMin = vec2(-1, -0.5);\n  \tvec2 sensorMax = vec2(1, 0.5);\n  \tvec2 pixelSize = (sensorMax- sensorMin) / vec2(iResolution.x, iResolution.y);\n  \tvec3 origin = vec3(0, 0, sensorDistance);\n    vec3 direction = normalize(vec3(sensorMin + pixelSize * frag_coord, -sensorDistance));  \n  \n  \treturn Ray(origin, direction);\n}\n\nvoid reflected(const in Ray ray, const in HitInfo hitInfo, out vec3 reflectDirection) {\n\tvec3 hitToRay = normalize(ray.origin - hitInfo.position);\n\treflectDirection = -hitToRay + 2.0 * max(0.0, dot(hitInfo.normal, hitToRay)) * hitInfo.normal;\n}\n\nvoid refracted(const in Ray ray, const in HitInfo hitInfo, const in float sourceIOR, const in float destIOR,\n\t\t\t out bool totalInternalReflection, out vec3 refractDirection) {\n\tvec3 hitToRay = normalize(ray.origin - hitInfo.position);\n\n\tfloat eta12 = sourceIOR / destIOR;\n\tfloat alpha = acos(dot(hitToRay, hitInfo.normal));\n\tfloat root = 1.0 + pow(eta12, 2.0) * (pow(cos(alpha), 2.0) - 1.0);\n\t\n\ttotalInternalReflection = root < 0.0;\n\trefractDirection = (-eta12 * hitToRay) + (hitInfo.normal * (eta12 * cos(alpha) - sqrt(root)));\n}\n\nfloat fresnel(const in Ray ray, const in HitInfo hitInfo, const in float eta2, const in float eta1) {\n#ifdef SOLUTION_FRESNEL\n\t// https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-shading/reflection-refraction-fresnel\n\tbool totalInternalReflection;\n\tvec3 refractDirection;\n\trefracted(ray, hitInfo, eta2, eta1, totalInternalReflection, refractDirection);\n\tif (totalInternalReflection) {\n\t\treturn 1.0;\n\t}\n\t\n\tvec3 rayToHit = normalize(hitInfo.position - ray.origin);\n\tfloat cos1 = dot(rayToHit, hitInfo.normal);\n\tfloat cos2 = dot(refractDirection, hitInfo.normal);\n\t\n\tfloat reflectS = pow(((eta2 * cos1 - eta1 * cos2) / (eta2 * cos1 + eta1 * cos2)), 2.0);\n\tfloat reflectP = pow(((eta1 * cos2 - eta2 * cos1) / (eta1 * cos2 + eta2 * cos1)), 2.0);\n\t\n\tfloat reflectance = (reflectS + reflectP) / 2.0;\n\t\n\treturn reflectance;\n#else\n  \t// Put your code to compute the Fresnel effect here\n\treturn 1.0;\n#endif\n}\n\nvec3 colorForFragment(const Scene scene, const vec2 fragCoord) {\n      \n    Ray initialRay = getFragCoordRay(fragCoord);  \n  \tHitInfo initialHitInfo = intersectScene(scene, initialRay, 0.001, 10000.0);  \n  \tvec3 result = shade(scene, initialRay, initialHitInfo);\n\t\n  \tRay currentRay;\n  \tHitInfo currentHitInfo;\n  \t\n  \t// Compute the reflection\n  \tcurrentRay = initialRay;\n  \tcurrentHitInfo = initialHitInfo;\n  \t\n  \t// The initial strength of the reflection\n  \tfloat reflectionWeight = 1.0;\n\t\n  \tfloat currentIOR = 1.0;\n  \t\n  \tconst int maxReflectionStepCount = 2;\n  \tfor(int i = 0; i < maxReflectionStepCount; i++) {\n      \n      if(!currentHitInfo.hit) break;\n      \n#ifdef SOLUTION_REFLECTION_REFRACTION\n\t\treflectionWeight *= currentHitInfo.material.reflectionFactor;\n#else\n#endif\n      \n#ifdef SOLUTION_FRESNEL\n\t\tfloat reflectRate = fresnel(currentRay, currentHitInfo, currentIOR, currentHitInfo.material.refractionIndex);\n\t\treflectionWeight *= reflectRate;\n#else\n      // Replace with Fresnel code\n#endif\n      \n      Ray nextRay;\n#ifdef SOLUTION_REFLECTION_REFRACTION\n\t\tnextRay.origin = currentHitInfo.position;\n\t\treflected(currentRay, currentHitInfo, nextRay.direction);\n\t\tcurrentIOR = currentHitInfo.material.refractionIndex;\n#else\n#endif\n      currentRay = nextRay;\n      \n      currentHitInfo = intersectScene(scene, currentRay, 0.001, 10000.0);    \n            \n      result += reflectionWeight * shade(scene, currentRay, currentHitInfo);\n    }\n  \n  \t// Compute the refraction\n  \tcurrentRay = initialRay;  \n  \tcurrentHitInfo = initialHitInfo;\n   \n  \t// The initial medium is air\n  \tcurrentIOR = 1.0;\n\n  \t// The initial strength of the refraction.\n  \tfloat refractionWeight = 1.0;\n  \n  \tconst int maxRefractionStepCount = 2;\n  \tfor(int i = 0; i < maxRefractionStepCount; i++) {\n      \n#ifdef SOLUTION_REFLECTION_REFRACTION\n\t\trefractionWeight *= currentHitInfo.material.refractionFactor;\n#else\n      // Replace with Fresnel code\n#endif\n\n#ifdef SOLUTION_FRESNEL\n\t\tfloat reflectRate = fresnel(currentRay, currentHitInfo, currentIOR, currentHitInfo.material.refractionIndex);\n\t\trefractionWeight *= (1.0 - reflectRate);\n#else\n      // Put Fresnel code here\n#endif      \n\n      Ray nextRay;\n\n#ifdef SOLUTION_REFLECTION_REFRACTION      \n\t\tfloat sourceIOR = currentIOR;\n\t\tfloat destIOR = currentHitInfo.enteringPrimitive ? currentHitInfo.material.refractionIndex : 1.0;\n\t\t\n\t\tnextRay.origin = currentHitInfo.position;\n\n\t\tbool totalInternalRefraction;\n\t\trefracted(currentRay, currentHitInfo, sourceIOR, destIOR, totalInternalRefraction, nextRay.direction);\n\t\tif (totalInternalRefraction) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tcurrentRay = nextRay;\n\t\tcurrentIOR = destIOR;\n#else\n\t// Put your code to compute the reflection ray and track the IOR\n#endif\n      currentHitInfo = intersectScene(scene, currentRay, 0.001, 10000.0);\n            \n      result += refractionWeight * shade(scene, currentRay, currentHitInfo);\n      \n      if(!currentHitInfo.hit) break;\n    }\n  return result;\n}\n\n\nMaterial getDefaultMaterial() {\n#ifdef SOLUTION_REFLECTION_REFRACTION\n\treturn Material(vec3(0.3), vec3(0), 0.0, 0.0, 0.0, 0.0);  // default reflection and refrative index = 1\n#else\n  return Material(vec3(0.3), vec3(0), 0.0);\n#endif\n}\n\nMaterial getPaperMaterial() {\n#ifdef SOLUTION_REFLECTION_REFRACTION\n\treturn Material(vec3(0.7, 0.7, 0.7), \n\t\t\t\t\tvec3(0, 0, 0), \n\t\t\t\t\t5.0,\n\t\t\t\t\t0.0,\n\t\t\t\t\t0.0,  // https://www.engineeringtoolbox.com/light-material-reflecting-factor-d_1842.html\n\t\t\t\t   \t0.0  // https://www.spiedigitallibrary.org/conference-proceedings-of-spie/6053/60530X/Determination-of-the-refractive-index-of-paper-with-clearing-agents/10.1117/12.660416.short\n\t\t\t\t   );\n#else\n  return Material(vec3(0.7, 0.7, 0.7), vec3(0, 0, 0), 5.0);\n#endif\n}\n\nMaterial getPlasticMaterial() {\n#ifdef SOLUTION_REFLECTION_REFRACTION\n\treturn Material(vec3(0.9, 0.3, 0.1), \n\t\t\t\t\tvec3(1.0), \n\t\t\t\t\t10.0,\n\t\t\t\t\t0.5,  // lowered to make it closer to cwk pdf https://www.3rxing.org/question/91b899a2cd644117448.html#:~:text=%E4%BA%BA%E7%9A%84%E6%89%8B%E6%8E%8C%E5%BF%83%20%20%20%20%20%20%20%20%20%20%20%2075%25-,%E4%B8%8D%E9%80%8F%E6%98%8E%E7%99%BD%E8%89%B2%E5%A1%91%E6%96%99%20%20%20%20%20%20%20%2087%25,-%E7%99%BD%E7%94%BB%E7%BA%B8\n\t\t\t\t\t1.45, // https://www.addoptics.nl/optics-explained/refractive-index-of-plastic/#:~:text=Most%20plastics%20have%20a%20refractive,range%20of%201.3%20to%201.6.\n\t\t\t\t\t0.0\n\t\t\t\t   );\n#else\n\treturn Material(vec3(0.9, 0.3, 0.1), vec3(1.0), 10.0);\n#endif\n}\n\nMaterial getGlassMaterial() {\n#ifdef SOLUTION_REFLECTION_REFRACTION\n\treturn Material(vec3(0.0), \n\t\t\t\t\tvec3(0.0), \n\t\t\t\t\t5.0,\n\t\t\t\t\t// http://www1.udel.edu/chem/sneal/sln_tchng/CHEM620/CHEM620/Chi_4._Light_at_Interfaces.html#:~:text=For%20glass%20and%20air%2C%20which,the%20reflection\n\t\t\t\t\t0.96, \n\t\t\t\t\t1.5,\n\t\t\t\t\t1.0\n\t\t\t\t   );\n#else\n\treturn Material(vec3(0.0), vec3(0.0), 5.0);\n#endif\n}\n\nMaterial getSteelMirrorMaterial() {\n#ifdef SOLUTION_REFLECTION_REFRACTION\n\treturn Material(vec3(0.1), \n\t\t\t\t\tvec3(0.3), \n\t\t\t\t\t20.0,\n\t\t\t\t\t0.5,  // https://www.engineeringtoolbox.com/light-material-reflecting-factor-d_1842.html\n\t\t\t\t    3.3,  // https://www.filmetrics.com/refractive-index-database/Stainless-Steel#:~:text=For%20a%20typical%20sample%20of,nm%20are%202.75681%20and%203.792016.\n\t\t\t\t\t0.0\n\t\t\t\t   );\n#else\n\treturn Material(vec3(0.1), vec3(0.3), 20.0);\n#endif\n}\n\nMaterial getMetaMaterial() {\n#ifdef SOLUTION_REFLECTION_REFRACTION\n\treturn Material(vec3(0.1, 0.2, 0.5), vec3(0.3, 0.7, 0.9), 20.0, 0.0, 0.0, 0.0);  // TODO: what is meta material\n#else\n\treturn Material(vec3(0.1, 0.2, 0.5), vec3(0.3, 0.7, 0.9), 20.0);\n#endif\n}\n\nvec3 tonemap(const vec3 radiance) {\n  const float monitorGamma = 2.0;\n  return pow(radiance, vec3(1.0 / monitorGamma));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\t// Setup scene\n\tScene scene;\n\tscene.ambient = vec3(0.12, 0.15, 0.2);\n\n\t// Lights\n\tscene.lights[0].position = vec3(5, 15, -5);\n\tscene.lights[0].color    = 0.5 * vec3(0.9, 0.5, 0.1);\n\n\tscene.lights[1].position = vec3(-15, 5, 2);\n\tscene.lights[1].color    = 0.5 * vec3(0.1, 0.3, 1.0);\n\n\t// Primitives\n\tscene.spheres[0].position            \t= vec3(10, -5, -16);\n\tscene.spheres[0].radius              \t= 6.0;\n\tscene.spheres[0].material \t\t\t\t= getPaperMaterial();\n\n\tscene.spheres[1].position            \t= vec3(-7, -2, -13);\n\tscene.spheres[1].radius             \t= 4.0;\n\tscene.spheres[1].material\t\t\t\t= getPlasticMaterial();\n\n\tscene.spheres[2].position            \t= vec3(0, 0.5, -5);\n\tscene.spheres[2].radius              \t= 2.0;\n\tscene.spheres[2].material   \t\t\t= getGlassMaterial();\n\n\tscene.planes[0].normal            \t\t= normalize(vec3(0, 0.8, 0));\n\tscene.planes[0].d              \t\t\t= -4.5;\n\tscene.planes[0].material\t\t\t\t= getSteelMirrorMaterial();\n\n\tscene.cylinders[0].position            \t= vec3(-1, 1, -26);\n\tscene.cylinders[0].direction            = normalize(vec3(-2, 2, -1));\n\tscene.cylinders[0].radius         \t\t= 1.5;\n\tscene.cylinders[0].material\t\t\t\t= getPaperMaterial();\n\n\tscene.cylinders[1].position            \t= vec3(4, 1, -5);\n\tscene.cylinders[1].direction            = normalize(vec3(1, 4, 1));\n\tscene.cylinders[1].radius         \t\t= 0.4;\n\tscene.cylinders[1].material\t\t\t\t= getPlasticMaterial();\n\t\n\tscene.blob.isoValue \t\t\t\t\t= 0.3;\n\tscene.blob.material \t\t\t\t\t= getMetaMaterial();\t\n\t\n\tconst bool animateBlobs = false;\n\tif(animateBlobs) {\n\t\tscene.blob.spherePositions[0] \t\t\t= vec3(+3.0 + sin(time * 3.0) * 3.0, -1, -12);\n\t\tscene.blob.spherePositions[1] \t\t\t= vec3(-1, +3, -12.0 + 3.0 * sin(time));\n\t\tscene.blob.spherePositions[2] \t\t\t= vec3(-3, -1.0 + 3.0 * cos(2.0 * time), -9);\t\t\n\t} else {\n\t\tscene.blob.spherePositions[0] \t\t\t= vec3(+3, -0, -11);\n\t\tscene.blob.spherePositions[1] \t\t\t= vec3(-1, +4, -12);\n\t\tscene.blob.spherePositions[2] \t\t\t= vec3(-2, -2, -9);\t\t\n\t}\n    \n    // Output to screen\n    fragColor.rgb = tonemap(colorForFragment(scene, fragCoord.xy));\n    fragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"}]}