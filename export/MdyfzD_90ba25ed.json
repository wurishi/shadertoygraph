{"ver":"0.1","info":{"id":"MdyfzD","date":"1527779211","viewed":332,"name":"Atmospheric Maze","username":"NuSan","description":"Raymarching scene of an infinite maze on a strange planet. The maze is not certified to be traversable...","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarch","maze"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define KALEIDO 0\n#define MAXSTEPS 200\n#define SHADOWSTEPS 20\n\n#define v2Resolution iResolution\n#define out_color fragColor\n#define time iTime\n\n#define pi 3.141592\n\nfloat rnd(float a) {\n  return fract(sin(a*1328.478+3212.6534)*9863.1243986);\n}\n\nfloat rnd(vec2 a) {\n  return fract(dot(sin(a*vec2(1328.478,4351.3254)+a.yx*vec2(421.675,435.128)+vec2(3212.6534,9673.432)),vec2(9863.1243986,8765.34214)));\n}\n\nfloat plane(vec3 p, vec3 n, float v) {\n    return dot(p,n)-v;\n}\n\nfloat sph(vec3 p, float r) {\n  return length(p)-r;\n}\n\nfloat box(vec3 p, vec3 s) {\n  return length(max(abs(p)-s,0.0f))-.005;\n}\n\nfloat smin(float a,float b,float h) {\n  float k=clamp(0.5+0.5*(a-b)/h,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\nfloat smax(float a,float b,float h) {\n  float k=1.0-clamp(0.5+0.5*(a-b)/h,0.0,1.0);\n  return mix(a,b,k)+k*(1.0-k)*h;\n}\n\nvec3 rep(vec3 p, vec3 s) {\n  return (fract(p/s+0.5)-0.5)*s;\n}\n\nvec3 repid(vec3 p, vec3 s) {\n  return floor(p/s+0.5);\n}\n\nmat2 rot(float a) {\n  float ca=cos(a*pi);\n  float sa=sin(a*pi);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat block(vec3 p, float s, float s2, vec2 rr) {\n  vec3 b0 = rep(p, vec3(s,1.0,s));\n\n  vec2 id=repid(p, vec3(s,1.0,s)).xz;\n  float a=rnd(id+rr);\n  float b=rnd(id.yx+rr.yx);\n\n  b0.xz*=rot(floor(a*4.0)*0.5);\n  vec3 b0b=b0;\n  //b0b.xz*=rot(floor(b*3.0+1.0)*0.5);\n  b0b.xz*=rot(b>0.5?1.0:b>0.25?0.5:1.5); // more straight lines than turns\n\n  float ms2=(p.y>0.25)?s2:(b>0.65?s2*2.0:s2); // may produce cross lines\n  vec3 bsize=vec3(ms2,s2,0)+vec3(0.02);\n  vec3 boff=vec3(ms2,0,0);\n\n  float b1=box(b0-boff,bsize);\n  float b2=box(b0b-boff,bsize);\n\n  float final=min(b1,b2);\n  return final;\n}\n\nfloat map(vec3 p) {\n  \n  float d=plane(p,vec3(0,1,0),-0.15);\n\n  float s=(p.y>0.25)?1.6:0.4;\n  float s2=(p.y>0.25)?0.2:0.05;\n  float s3=0.02;\n  vec2 off=vec2(0,0.2);\n\n  float b0 = block(p, s,s2, vec2(0));\n  float b1 = block(p+off.yxx, s,s2, vec2(7845.356,134.623));\n  float b2 = block(p+off.xxy, s,s2, vec2(964.2365,123.658));\n  float b3 = block(p+off.yxy, s,s2, vec2(2761.986,347.642));\n\n  d=min(d,b0);\n  d=min(d,b1);\n  d=min(d,b2);\n  d=min(d,b3);\n\n  d=smin(d, plane(p,vec3(0,1,0),-0.05), 0.02);\n  //d=max(d,-plane(p,vec3(0,-1,0),-1.0));\n\n  return d;\n}\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0,0.001);\n  return normalize(map(p)-vec3(map(p+off.yxx),map(p+off.xyx),map(p+off.xxy)));\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n  vec3 p=ro;\n  for(int i=0; i<MAXSTEPS; ++i) {\n    float d=map(p);\n    if(d<0.001) {\n      break;\n    }\n    p+=d*rd*0.5;\n  }\n\n  return p;\n}\n\nfloat shadow(vec3 ro, vec3 rd) {\n  float md=1.0;\n  int steps=SHADOWSTEPS;\n  float s=0.2/float(steps);\n  float t=0.01;\n  for(int i=0; i<steps; ++i) {\n    float d=map(ro+rd*t);\n    md=min(md,4.0*d/t);\n    if(d<0.0001) {\n      //md=0.0;\n      break;\n    } \n    t+=s;\n  }\n\n  return md;\n}\n\nfloat ambient(vec3 p, vec3 n) {\n    \n    float scale = 0.02;\n    float d = scale;\n    vec3 pos = p - n * d;\n\n    float fac = 1.0;\n\n    for( int i=0; i<5; ++i) {\n    \n        float str = 5.5/float(1+i);\n        fac *= 1.0-clamp((d-map(pos))*str,0.0,1.0);\n        pos -= n * scale;\n        d += scale;\n    \n    }\n\n    return fac;\n}\n\nvec2 mir(vec2 uv, float a) {\n  mat2 ra=rot(a);\n  uv*=ra;\n  uv.x=abs(uv.x);\n  uv*=ra;\n  return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / v2Resolution.x, fragCoord.y / v2Resolution.y);\n  uv -= 0.5;\n  uv /= vec2(v2Resolution.y / v2Resolution.x, 1);\n\n #if KALEIDO\n  float mt=time*0.2;\n  uv=mir(uv,mt);\n  uv=mir(uv,-mt*0.3);\n  uv=mir(uv,mt*.5);\n  uv=mir(uv,-mt*.1);\n  float ma=time*0.5;\n  uv+=abs(vec2(cos(ma),sin(ma)))*0.5;\n #endif\n\n\n  float ct=time*0.2;\n  vec3 parc=vec3(0,0,ct);\n  vec3 cam=vec3(cos(ct),0.2,sin(ct))*1.0+parc;\n  vec3 ta=vec3(0,-0.3 + sin(ct*1.2)*0.4 + 0.3,0)+parc;\n  vec3 cz=normalize(ta-cam);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cx,cz));\n\n  vec3 ro=cam;\n  vec3 rd=normalize(uv.x*cx+uv.y*cy+cz);\n\n  vec3 p=march(ro,rd);\n\n  float depth=length(p-ro);\n  vec3 n=norm(p);\n\n  vec3 col=vec3(0);\n  \n  vec3 ldir=normalize(vec3(0.2,-0.7,0.4));\n\n  float shadd=shadow(p,-ldir);\n\n  float shad=clamp(shadd,0.0,1.0);\n\n  float lum=max(0.0, dot(n,ldir));\n  col += lum*shad*vec3(1.0,0.8,0.5);\n\n  float ao=ambient(p, n);\n\n  col += ao*0.6*vec3(0.4,0.5,0.7);\n  \n  //col *= min(vec3(1.0)/(depth*depth),vec3(1.0));\n  //col=vec3(shad);\n\n  //col=vec3(ao);\n\n  col += exp(-vec3(1.9,1.5,1.2)/depth);\n\n  out_color = vec4(col, 0);\n}","name":"Image","description":"","type":"image"}]}