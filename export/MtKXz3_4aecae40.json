{"ver":"0.1","info":{"id":"MtKXz3","date":"1485298736","viewed":210,"name":"Tunnel of thorns","username":"balkhan","description":"tunnel fx","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\nfloat \tt;\n\n#define I_MAX\t\t100\n#define E\t\t\t0.001\n\n//#define PULSE // uncomment this line to get it pulsing\n\nvec4\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvec3\tcalcNormal(in vec3 pos, float e, vec3 dir);\nvec2\trot(vec2 p, vec2 ang);\nvoid\trotate(inout vec2 v, float angle);\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    t  = iTime;\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2\tuv  = vec2(.35+sin(t)/2.+f.x/iResolution.x, sin(-t)/3.+f.y/iResolution.y);\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(.0, .0, 20.0);\n\tvec3\tbase;\n\n    pos.z -= 400.;\n    pos.z -= t*20.;\n\n    vec4\tinter = (march(pos, dir));\n\n\tif (inter.y == 1.)\n\t{\n\t\tvec3\tv = pos+inter.w*dir;\n        vec3\tn = calcNormal(v, E, dir);\n        vec3\tev = normalize(v - pos);\n\t\tvec3\tref_ev = reflect(ev, n);\n        vec3\tlight_pos   = pos+vec3(100.0, 10.0, -10.0);\n\t\tvec3\tlight_color = vec3(.3, .7, .5);\n        vec3\tvl = normalize( (light_pos - v) );\n\t\tfloat\tdiffuse  = max(0.15, dot(vl, n));\n\t\tfloat\tspecular = pow(max(0., dot(vl, ref_ev)), 3. );\n        base.xyz = texture(iChannel0, vec2( (v.zz)*.042)).xyz;\n        col.xyz = light_color * (specular) + diffuse * (base-inter.x/200.); // light + fake (AO distance based)\n        col.xyz += inter.w / 200.; // add more fake\n    }\n    c_out =  vec4(col,1.0);\n}    \n\nfloat\tde(vec3 p)\n{\n\tfloat\tmind = 1e5;\n\tfloat\ta = cos( cos(t/3.+(p.x*p.x+p.y*p.y)*.005)*- cos(t/4.+(p.z*p.z) *.03)) * 4.;\n\tvec3\tpr = p*.35;\n\n\trotate(pr.xy, (cos(a)*cos(t*8.+length(p.z+p.x+p.y) )*.05+sin(t) ));\n\n\tpr.xy*=2.;\n\tpr.xyz -= floor(pr.xyz);\n\tpr -= .5;\n    \n    mind = length(-abs(pr.zz)+abs(pr.xy)) - .1;\n    \n\treturn (mind);\n}\n\nfloat\tde_4(vec3 p) // cylinder\n{\n\tfloat\tmind = 1e5;\n\tvec3\tpr = p;\t\n\tvec2\tq;\n    \n\tq = vec2(length(pr.yx) - 4., pr.z );\n    #ifdef PULSE\n    q.y = rot(q.xy, vec2(-1.+sin(t*10.), 0.)).x;\n\t#else\n    q.y = rot(q.xy, vec2(-1., 0.)).x;\n    #endif\n\tmind = length(q) - 3.5;\n\n\treturn mind;\n}\n\nfloat\tde_2(vec3 p)\n{\n    return (de(p)-de_4(p)/8.);\n}\n\nfloat\tscene(vec3 p)\n{\n    float\tmind = 1e5;\n    vec2\trot = vec2( cos(t/2.), sin(t/2.) );\n\tp.x += rot.x*5.;\n\tp.y += rot.y*5.;\n\n\tmind = de_2(p);\n\t\n    return(mind);\n}\n\n\nvec4\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec4\tstep = vec4(0.0, 0.0, 0.0, 0.0);\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n        dist.x = scene(p);\n        dist.y += dist.x;\n        if (dist.x < E )\n        {\n            step.y = 1.;\n            break;\n        }\n        step.x++;\n    }\n    step.w = dist.y+dist.x;\n    return (step);\n}\n\n// Utilities\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    e /= 100.;\n    vec3 eps = vec3(e,0.0,0.0);\n\n\treturn normalize(vec3(\n           march(pos+eps.xyy, dir).w - march(pos-eps.xyy, dir).w,\n           march(pos+eps.yxy, dir).w - march(pos-eps.yxy, dir).w,\n           march(pos+eps.yyx, dir).w - march(pos-eps.yyx, dir).w ));\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x-.85) * right + (uv.y-0.5) * up + fov * forw));\n}\n","name":"Image","description":"","type":"image"}]}