{"ver":"0.1","info":{"id":"lffczH","date":"1720818396","viewed":82,"name":"WOS - Boundary & Ponctual","username":"PlathC","description":"Small experiment with Walk On Spheres.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["wos"],"hasliked":0,"parentid":"lcXczH","parentname":"WOS - Color interpolation"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor  = texture( iChannel0, fragCoord / iResolution.xy );\n    fragColor /= fragColor.w;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float Epsilon = 1e-3;\nconst int   Steps   = 10;\n\nconst float Pi  = 3.14159265359;\nconst float Tau = 2. * Pi;\n\n// Reference: https://iquilezles.org/articles/distfunctions2d/\n// Inigo Quilez\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat sdScene( in vec2 p )\n{\n    float d  = sdRoundedBox( p, vec2( .48 ), vec4( .1 ) );\n    float d1 = sdRoundedBox( p - vec2( .4, 0. ), vec2( .48 ), vec4( .2 ) );\n    float d2 = sdRoundedBox( p + vec2( .4, 0. ), vec2( .48 ), vec4( .2 ) );\n    \n    return min( d, min( d1, d2 ) );\n}\n\n// Reference: https://www.shadertoy.com/view/XlGcRh\n// Hash Functions for GPU Rendering. Mark Jarzynski, & Marc Olano (2020).\n// Journal of Computer Graphics Techniques (JCGT), 9(3), 20–38.\nuvec4 pcg4d(uvec4 v)\n{\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * v.w;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v.w += v.y * v.z;\n\n    v ^= v >> 16u;\n\n    v.x += v.y * v.w;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v.w += v.y * v.z;\n\n    return v;\n}\n\nvec4 prng(inout uvec4 p)\n{\n    p.w++;\n    return vec4(pcg4d(p)) * (1.0/float(0xffffffffu));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int SourceNumber  = 4;\nvec2 PonctualSources[ SourceNumber ] = vec2[4]( vec2( 0.8, 0. ),        vec2( -0.8, 0. ), vec2( 0., 0.4 ),      vec2( 0., -.4 ) );\nvec3 Strengths[ SourceNumber ]       = vec3[4]( vec3( 42., 40.5, 40. ), vec3( 42. ),      vec3( 15., 10., 10. ), vec3( 20. ) );\n\n// Stratified Sampling of 2-Manifolds, Jim Arvo\n// SIGGRAPH Course Notes 2001\n// Found: https://twitter.com/keenanisalive/status/1529490555893428226?s=20&t=mxRju6YioMmlMOJ1fDVBpw\nvec2 sampleCircle(vec2 u)\n{\n    float  r     = u.x;\n    float  theta = u.y * 2. * Pi;\n    return sqrt(r) * vec2(cos(theta), sin(theta));\n}\n\n// Reference: Monte Carlo Geometry Processing: A Grid-Free Approach to PDE-Based Methods on Volumetric Domains\n// ROHAN SAWHNEY and KEENAN CRANE\n// https://www.cs.cmu.edu/~kmcrane/Projects/MonteCarloGeometryProcessing/paper.pdf\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    uvec4 seed  = uvec4( uvec2( fragCoord ), iFrame, 0 );\n    vec2 jitter = prng( seed ).xy;\n    vec2 uv     = (fragCoord + (jitter * 2. - 1.) + .5 - iResolution.xy * 0.5) / iResolution.y;\n    uv.y = -uv.y;\n    \n    vec3  color = vec3( 0. );\n    \n    const int SampleNbBoundary = 1;\n    for( int s = 0; s < SampleNbBoundary; s++ )\n    {\n        vec2 p        = uv;        \n        vec3 ponctual = vec3( 0. );\n        for( int t = 0; t < Steps; t++ ) \n        {\n            float d = sdScene( p );            \n            for( int l = 0; l < SourceNumber; l++ )\n            {\n                vec2 source   = PonctualSources[ l ];\n                vec3 strength = Strengths[ l ];\n            \n                // \"If there is a single source δz inside the current ball B(x),\n                //  we can use an importance density p = δz, yielding an importance sampled estimator\"\n                if( length( p - source ) < abs( d ) )\n                {\n                    // Harmonic Green's Function (App. B.1)\n                    float g = ( 1. / Tau ) * log( abs( d ) / length( source - p ) ); \n                    vec3  f = strength;\n\n                    ponctual += g * f;\n                }\n\n            }\n            \n            if( abs( d ) < Epsilon && t > 0 ) \n            {\n                color += p.xyy + .75;\n                break;\n            }\n            p += sampleCircle( prng( seed ).xy ) * abs( d );\n        }\n        color += ponctual / float( Steps );\n    }\n    color /= float( SampleNbBoundary );\n    \n    if( sdScene( uv ) > Epsilon )\n        color = vec3( .2 );\n\n    \n    vec4 previous = texture( iChannel0, fragCoord / iResolution.xy );\n    if( iFrame == 0 || iMouse.z > 0. )\n        previous = vec4( 0. );\n    \n    fragColor = previous + vec4( color, 1. );\n}","name":"Buffer A","description":"","type":"buffer"}]}