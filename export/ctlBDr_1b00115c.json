{"ver":"0.1","info":{"id":"ctlBDr","date":"1693084189","viewed":164,"name":"Southwestern Sunset","username":"andrew741","description":"Rolling desert mesas with golden sunset light and god rays peeking through the dusty landscape.\n\nLook around using the mouse.","likes":19,"published":1,"flags":32,"usePreview":1,"tags":["3d","raymarching","sunset","rays","light","sky","godrays","sunlight","atmosphere","dust","sunrise","sand","desert","graphics","mesa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* different shader settings (optimized for the least glitches and best preformance) */\n\n// raymarching settings\n#define MAX_DEPTH 125  // there's so many optimizations that it just needs to be big enough, anything more won't change anything including preformance\n#define MIN_DST 0.02  // the distance to the terrain at which the ray will stop\n\n// additional terrain settings\n#define TERRAIN_HEIGHT 1.5  // the height of the terrain\n\n// atmosphere settings\n#define OPTICAL_STEPS 4  // doesnt matter too much\n#define ATMO_STEPS 56  // the more steps the smoother the boders of the god rays\n\n// color settings (there is only one non-simulated color)\n#define SOIL_COLOR vec3(0.85, 0.65, 0.2)  // the color of the ground (and dust in the air)\n\n// the coefficents for the scattering of different wave lengths of light\n#define scatteringCoefficents pow(vec3(400.) / vec3(700, 530, 440), vec3(4.)) * 2.  // the last number changes the separation of colors\n\n// from https://www.shadertoy.com/view/WtGXDD\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// from https://www.shadertoy.com/view/WtGXDD\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n// gets the terrain height\nfloat GetHeight(vec2 p)\n{\n    return texture(iChannel0, fract(p*0.1)).r;\n}\n\n// gets the distance to the terrain\nfloat GetDst(vec3 p)\n{\n    return (p.y - GetHeight(p.xz)*TERRAIN_HEIGHT) * 0.6;  // the * 0.6 is to account for the large inaccuracy in the distance approximation\n}\n\n// gets the normal\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDst(p);\n    vec2 e = vec2(0.1, 0);\n    \n    vec3 normal = d - vec3(\n        GetDst(p - e.xyy),\n        GetDst(p - e.yxy),\n        GetDst(p - e.yyx));\n    \n    return normalize(normal);\n}\n\n// stores informatino on a ray marched ray\nstruct Ray\n{\n    vec3 p;\n    float dst, totalDst;\n};\n\n// ray marches to render the terrain\nRay RayMarch(vec3 rd, vec3 ro, float maxRayDst)\n{\n    // ray marching\n    vec3 p = ro;\n    float dst, totalDst;\n    for (int i = 0; i < MAX_DEPTH; i++)\n    {    \n        // moving the ray based on the distance to the terrain\n        dst = GetDst(p);\n        totalDst += dst;\n        p += rd * dst;\n        \n        // checking if the ray should be stopped early (helps a lot with preformance)\n        if (dst<MIN_DST || totalDst>maxRayDst || p.y>TERRAIN_HEIGHT+0.1) break;\n    }\n    \n    // correcting totalDst if the ray goes into the sky (other wise weird bands happen)\n    if (dst >= 0.2) totalDst = 99999.;\n    \n    // returning the ray\n    return Ray(p, dst, totalDst);\n}\n\n// renders the ray\nvoid RenderRay(Ray ray, vec3 sunDir, vec3 rd, inout vec3 col)\n{    \n    // rendering the terrain\n    if (ray.dst < 0.2)\n    {\n        // getting the normal\n        vec3 normal = GetNormal(ray.p);\n        \n        // the amount of fog\n        float fog = exp(-ray.totalDst*0.15);\n\n        // getting the color\n        float steepness = smoothstep(0.6, 1., dot(normal, vec3(0.,1.,0.)));\n        float cliffText = mix(0.5+texture(iChannel1, vec2((ray.p.x+ray.p.z)*0.6, ray.p.y*5.)).x, 1., steepness);\n        cliffText *= cliffText*cliffText;\n        float groundText = 1.3*mix(0.5+texture(iChannel2, ray.p.xz).x, 1., 1.-steepness);\n        vec3 groundColor = SOIL_COLOR * cliffText*groundText * dot(sunDir, normal);\n        \n        // rendering the terrain and fog\n        col = mix(col, groundColor, fog);\n    }\n    else\n    {\n        col += smoothstep(0.998, 1., dot(rd, sunDir));\n    }\n}\n\n// the density at a given point in the atmosphere\nfloat GetDensity(float dstToPlannet)\n{\n    float density_fall_off = 6.5;  // the falloff speed for the atmospheric density\n    float h = dstToPlannet * 0.2;  // normalizeing the distance to the plannet based on the difference between the raidius of the atmosphere and the plannet\n    float density = exp(-h * density_fall_off) * (1. - h);\n    return density;\n}\n\n// finds the distance through a sphere (modified from a function I found on yt)\nfloat raySphere(vec3 ro, vec3 rd)\n{\n    float b = 2. * dot(ro, rd);\n    float c = dot(ro, ro) - 144.;  // 144. is the radius^2 (radius=12 and 12*12=144)\n\n    float discriminant = b * b - 4. * c;\n\n    float s = sqrt(discriminant);\n    float dstToSphereNear = max(0., (-b - s) * 0.5);\n    float dstToSphereFar = (-b + s) * 0.5;\n\n    return dstToSphereFar - dstToSphereNear;\n}\n\n// From https://www.shadertoy.com/view/4sjBDG\nfloat numericalMieFit(float costh)\n{\n    // This function was optimized to minimize (delta*delta)/reference in order to capture\n    // the low intensity behavior.\n    float bestParams[10];\n    bestParams[0]=9.805233e-06;\n    bestParams[1]=-6.500000e+01;\n    bestParams[2]=-5.500000e+01;\n    bestParams[3]=8.194068e-01;\n    bestParams[4]=1.388198e-01;\n    bestParams[5]=-8.370334e+01;\n    bestParams[6]=7.810083e+00;\n    bestParams[7]=2.054747e-03;\n    bestParams[8]=2.600563e-02;\n    bestParams[9]=-4.552125e-12;\n    \n    float p1 = costh + bestParams[3];\n    vec4 expValues = exp(vec4(bestParams[1] *costh+bestParams[2], bestParams[5] *p1*p1, bestParams[6] *costh, bestParams[9] *costh));\n    vec4 expValWeight= vec4(bestParams[0], bestParams[4], bestParams[7], bestParams[8]);\n    return dot(expValues, expValWeight);\n}\n\n// gets the optical depth based on the ray direction, length, and position\nfloat opticalDepth(vec3 ro, vec3 rd, float rl)\n{\n    // the rays position\n    vec3 p = ro;\n    // the step size\n    float step_size = rl / (float(OPTICAL_STEPS)+1.);\n    vec3 v3_step_size = rd * step_size;\n    // the optical depth\n    float odepth = 0.;\n    // the density\n    float ldense;\n    // stepping throught the atmosphere\n    for (int s = 0; s < OPTICAL_STEPS; s++)\n    {\n        // moving the ray/point\n        p += v3_step_size;\n        // sampling the atmospheric density\n        ldense = GetDensity(p.y);\n        // adding up the optical depth\n        odepth += ldense * step_size;\n    }\n    // returning the optical depth\n    return odepth;\n}\n\n// renders the atmosphere\nvec4 RenderAtmo(vec3 rd, vec3 ro, vec3 sunDir, vec3 col, float dst)\n{\n    // getting the distance to the atmosphere\n    float dstThroughAtmosphere = min(dst, 12.);  // the distance to the surface or sky/outter atmosphere\n    \n    // finding the step size going through the atmosphere\n    float step_size_f = dstThroughAtmosphere / (float(ATMO_STEPS) + 1.);\n    vec3 step_size = rd * step_size_f;\n    vec3 p = vec3(0.);\n    \n    // initizalizing some terms\n    float density;\n    float sun_length;\n    vec3 transmittance;\n    float sunRayOpticalDepth;\n    float veiwRayOpticalDepth;\n    vec3 inScatteredLight = vec3(0.);\n    float rayLeighPhase = numericalMieFit(dot(sunDir, rd));\n    rayLeighPhase = rayLeighPhase * max(dot(sunDir, rd), 0.) * 0.5 + 0.5;\n    \n    // stepping through the atmosphere\n    for (int s = 0; s < ATMO_STEPS; s++)\n    {\n        // moving the ray/point\n        p += step_size;\n        // fining the length through the atmosphere in the direction of the sun\n        sun_length = raySphere(p, sunDir);\n        \n        // checking for atmosphereic shadowing from terrain, this creates god rays\n        if (p.y+ro.y<TERRAIN_HEIGHT+0.1)\n        {\n            // casting a ray to check for terrain collision\n            Ray ray = RayMarch(sunDir, p+ro, 10.);\n            \n            // checking if the ray hit the terrain\n            if (ray.dst <= 0.025)\n            {\n                // finding how much atmosphereic shadowing is happening (a basic approximation)\n                inScatteredLight *= exp(-0.75*(dstThroughAtmosphere-step_size_f*float(s+1)));\n                break;  // leaving the loop (better preformance for little visual loss)\n            }\n        }\n        \n        // getting the optical depths\n        sunRayOpticalDepth = opticalDepth(p, sunDir, sun_length);\n        veiwRayOpticalDepth = opticalDepth(p, -rd, step_size_f * float(s));\n        // finding the transmittance\n        transmittance = exp(-(sunRayOpticalDepth + veiwRayOpticalDepth) * scatteringCoefficents) * rayLeighPhase;\n        // finding the atmospheric density at this point\n        density = GetDensity(p.y);\n        \n        // finding the amount of addition light\n        inScatteredLight += density * transmittance * scatteringCoefficents * step_size_f;\n    }\n    // applying the atmosphere\n    return vec4(inScatteredLight, exp(-veiwRayOpticalDepth));\n}\n\n// the main function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // getting the uv coord\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n    if (iMouse.z<0.||iMouse.xy==vec2(0.)) m=vec2(0.45, 0.575);  // so you load in looking in a good direction\n    vec3 col = vec3(0.);\n    \n    float time = iTime*0.25-1.5;\n    vec3 sunDir = normalize(vec3(0.75+0.2*sin(time), sin(time)*0.5+0.6, -1.));\n    \n    // getting the path which the camera follows (a bunch of sine waves)\n    time = iTime;\n    vec4 point = vec4(sin(time)*1.5, 1.9+sin(time*2.)*0.2, -time*3., sin(time+3.14159)*0.3);\n    uv.x+=sin(time)*0.35;\n    \n    // getting the cameras direction and position\n    vec3 ro = vec3(0, 8., -8.);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    vec3 rd = GetRayDir(uv*Rot(point.w), ro, vec3(0., 0., 0.), 1.);\n    ro = point.xyz;\n    \n    // getting the distance to the start of the terrain (which means less costly ray marching happens + allows for an optmization)\n    float startDst = 0.;\n    if (rd.y < 0.) startDst = ((ro.y-TERRAIN_HEIGHT-0.1)/(-rd.y));\n    vec3 dif = rd*startDst;\n    \n    // marching the ray\n    Ray ray = Ray(vec3(0.), 99., 999.);\n    if (rd.y < 0. && startDst < 25.) ray = RayMarch(rd, ro+dif, 25.-startDst);\n    ray.totalDst+=+startDst;\n    \n    // rendering the atmosphere\n    vec4 atmo = RenderAtmo(rd, ro, sunDir, vec3(0.), ray.totalDst);\n    col = atmo.rgb;\n    \n    // tone mapping and exposure/hdr corrections (only for the atmosphere to get pastel like colors which look nicer)\n    // the tone mapping and exposure/hdr corrections look really bad when used on the terrain\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    col =  sqrt(clamp((col*(a*col+b))/(col*(c*col+d)+e), 0., 1.));\n    \n    // rendering the terrain from the ray march\n    col = mix(col, SOIL_COLOR, smoothstep(0.5, -0.2, max(rd.y, -0.2)) * 0.35); // dust in the air\n    RenderRay(ray, sunDir, rd, col);\n    \n    // the final color\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n    Saving the terrain noise to a texture to improve preformance allowing more ray casts.\n    This makes the raymarching fast enough for god rays (upwards of 50 casts per pixel).\n    It also allows for more layers of perlin noise which improves the terrain.\n*/\n\n// the matrix for the hash function (weights are from the origonal Hash function from another shadertoy user)\n#define HashMat  mat3( vec3(127.1,311.7, 74.7), vec3(269.5,183.3,246.1),vec3(113.5,271.9,124.6))\n#define HashMat2 mat2( vec2(127.1, 311.7), vec2(269.5, 183.3))\n\n// this hash is from someone elses shader (with some modifactions)\nvec3 Hash(vec3 p) {  return fract(sin(p * HashMat ) * 43758.5453123) * 2. - 1.;  }\nvec2 Hash(vec2 p) {  return fract(sin(p * HashMat2) * 43758.5453123) * 2. - 1.;  }\n\n// from another persons shader\nfloat Perlin(vec3 x, float scale)\n{\n    // grid\n    vec3 i = floor(x);\n    vec3 w = fract(x);\n    \n    // cubic interpolant\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    // gradients\n    vec3 ga = Hash(mod(i+vec3(0.0,0.0,0.0), scale));\n    vec3 gb = Hash(mod(i+vec3(1.0,0.0,0.0), scale));\n    vec3 gc = Hash(mod(i+vec3(0.0,1.0,0.0), scale));\n    vec3 gd = Hash(mod(i+vec3(1.0,1.0,0.0), scale));\n    vec3 ge = Hash(mod(i+vec3(0.0,0.0,1.0), scale));\n\tvec3 gf = Hash(mod(i+vec3(1.0,0.0,1.0), scale));\n    vec3 gg = Hash(mod(i+vec3(0.0,1.0,1.0), scale));\n    vec3 gh = Hash(mod(i+vec3(1.0,1.0,1.0), scale));\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z;\n}\n\n// multiple layers of perlin noise (to provide more detial to it)\nfloat Fractal(vec3 p, float scale)\n{\n    float perlin  = Perlin(p      , 1.  * scale) * 0.4 ;\n    perlin       += Perlin(p * 2. , 2.  * scale) * 0.27;\n    perlin       += Perlin(p * 4. , 4.  * scale) * 0.17;\n    perlin       += Perlin(p * 8. , 8.  * scale) * 0.1 ;\n    perlin       += Perlin(p * 16., 16. * scale) * 0.06;\n    return perlin * 0.5 + 0.5;\n}\n\n// squares a value\nfloat Sqr(float v) {  return v*v;  }\n\n// shapes the height map to form mesas\nfloat ShapeFunction(float h)\n{\n    float height = pow(h*0.565, 1.65) * 2.;\n    return min(height*height*height*height*height, pow(height, 1./2.5))*0.841;\n}\n\n// generates the noise\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // generating the ground noise/shape\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // the terrain shape\n    float mesaNoise = Perlin(vec3(-uv*3., 0.), 3.) * 0.75;\n    mesaNoise += Perlin(vec3(-uv*6., 0.), 6.) * 0.25;\n    float height = ShapeFunction(mesaNoise+1.)*0.7 + 0.5*Fractal(vec3(uv*2., 0.), 2.);\n    \n    // adding tiny detailed bumps to the ground\n    height += texture(iChannel0, uv.xy*0.5).r*0.025-0.0125;\n    \n    // the final terrain height\n    fragColor = vec4(height);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}