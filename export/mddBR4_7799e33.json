{"ver":"0.1","info":{"id":"mddBR4","date":"1696934387","viewed":92,"name":"Single pass gaussian blur","username":"bytewave","description":"Tried to create a keep it simple implementation of a single pass gaussian blur ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["gaussianblur"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Copy paste this on your lasagna if you want. I don't care :)\n\n/**\n * Single pass gaussian blur\n * \n * Description: A keep it simple implementation of a single pass gaussian blur \n * Author: Bytewave\n * License: CC0 1.0 Universal (CC0 1.0) Public Domain Dedication\n */\n\nvec4 blur(sampler2D smp, vec2 uv, float kernelSize, float filterSize) {\n    vec4 res = vec4(0.,0.,0.,0.);\n    float weightSum = 0.;\n    \n    for (float x = 0.; x < kernelSize; x++) {\n        for (float y = 0.; y < kernelSize; y++) {\n            vec2 xy = vec2(x,y);\n            vec2 kuvCentered = xy/kernelSize - 0.5; // uv coord within the kernel\n\n            float bell = cos( length( kuvCentered ) * 3.14159265359 ) * 0.5 + 0.5;\n            bell *= float(abs(dot(kuvCentered,kuvCentered)) < 1.); //discard outside the bell curve\n            vec2 targOffSet = kuvCentered * filterSize;\n\n            vec4 sampledTex = texture(smp, uv + targOffSet );\n            res += sampledTex * bell;\n            weightSum += bell;\n        }\n    }\n    return res/weightSum;\n}\n\n// Bonus ¯\\_(ツ)_/¯\nvec4 sharpen(sampler2D smp, vec2 uv, float kernelSize, float filterSize, float amount) {\n    vec4 normal = texture(iChannel0, uv);\n    vec4 blurred = blur(iChannel0, uv, kernelSize, filterSize);\n    return normal + (normal - blurred) * amount;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    if (uv.x < 0.5) {\n        vec4 normal = texture(iChannel0, uv);\n        fragColor = normal;\n    }\n    else {\n        float animDriver = (sin(iTime * 2.) * 0.5 + 0.5);\n        float sampleCountAnimatedParam = 1. + animDriver * 50.;\n        float filterSize = mix (0.0001,0.1,animDriver);\n        vec4 blurred = blur(iChannel0, uv, sampleCountAnimatedParam, filterSize);\n        fragColor = blurred;\n    }\n}","name":"Image","description":"","type":"image"}]}