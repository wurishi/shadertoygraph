{"ver":"0.1","info":{"id":"432GRz","date":"1708365254","viewed":154,"name":"Accumulate","username":"Oskar123","description":"Accumulation","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).rgb / float(iFrame + 1);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Im Browser ausfÃ¼hrbar unter https://www.shadertoy.com/view/lXlGRr\n// Constants\nconst float c_twopi = 6.28318530718;\nconst float pi = 3.1415;\nconst int NUM_SPHERES = 5;\n\n// Sphere structure\nstruct Sphere {\n    vec3 pos;\n    float size;\n    vec3 color;\n    float spec;\n    float rough;\n    float emission;\n};\n\n// Global array of spheres\nSphere spheres[NUM_SPHERES];\n\n// Utility Functions\nuint wang_hash(inout uint seed) {\n    seed = (seed ^ 61u) ^ (seed >> 16);\n    seed *= 9u;\n    seed = seed ^ (seed >> 4);\n    seed *= 0x27d4eb2du;\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state) {\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec3 RandomUnitVector(inout uint state) {\n    float E1 = RandomFloat01(state) * 2.0 - 1.0;\n    float E2 = RandomFloat01(state);\n\n    float theta = acos(E1);\n    float phi = c_twopi * E2;\n    return vec3(cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta));\n}\n\n// Ray-Sphere Intersection\nfloat raySphereIntersect(vec3 r0, vec3 rd, vec3 s0, float sr) {\n    vec3 L = s0 - r0;\n    float tc = dot(L, rd);\n    if (tc < 0.0) return -1.0;\n    float d2 = dot(L, L) - tc * tc;\n    float sr2 = sr * sr;\n    if (d2 > sr2) return -1.0;\n    float t1c = sqrt(sr2 - d2);\n    float t1 = tc - t1c;\n    float t2 = tc + t1c;\n    return t1 > 0.0 ? t1 : (t2 > 0.0 ? t2 : -1.0);\n}\n\n// Hit Information Structure\nstruct HitInfo {\n    float t;\n    int sphereIndex;\n    vec3 N;\n    vec3 hitPoint;\n    vec3 color;\n    float spec;\n    float rough;\n    float emission;\n};\n\nfloat FresnelReflectAmount(float n1, float n2, vec3 normal, vec3 incident, float f0, float f90)\n{\n        // Schlick aproximation\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        if (n1 > n2)\n        {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            // Total internal reflection\n            if (sinT2 > 1.0)\n                return f90;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n \n        // adjust reflect multiplier for object reflectivity\n        return mix(f0, f90, ret);\n}\n\n\n// Intersection with All Spheres\nHitInfo intersectAll(vec3 ray_origin, vec3 rayDirection) {\n    HitInfo hitInfo;\n    hitInfo.t = 1e6;  \n    hitInfo.sphereIndex = -1;\n    for (int i = 0; i < NUM_SPHERES; i++) {\n        float dist = raySphereIntersect(ray_origin, rayDirection, spheres[i].pos, spheres[i].size);\n        if (dist >= 0.0 && dist < hitInfo.t) {\n            hitInfo.t = dist;\n            hitInfo.sphereIndex = i;\n        }\n    }\n    if (hitInfo.sphereIndex != -1) {\n        Sphere sphere = spheres[hitInfo.sphereIndex];\n        hitInfo.hitPoint = ray_origin + rayDirection * hitInfo.t;\n        hitInfo.N = normalize(sphere.pos - hitInfo.hitPoint) * -1.0;\n        hitInfo.color = sphere.color;\n        hitInfo.spec = sphere.spec;\n        hitInfo.rough = sphere.rough;\n        hitInfo.emission = sphere.emission;\n    }\n    return hitInfo;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    spheres[0].pos = vec3(0.0, 9.0, 22.0);\n    spheres[0].size = 10.0;\n    spheres[0].color = vec3(0.9, 0.4, 0.7);\n    spheres[0].spec = 0.16;\n    spheres[0].rough = 0.0;\n    spheres[0].emission = 0.0;\n    \n    spheres[1].pos = vec3(0.0, -1000001.0, 22.0);\n    spheres[1].size = 1000000.0;\n    spheres[1].color = vec3(0.7);\n    spheres[1].spec = 0.0;\n    spheres[1].rough = 1.0;\n    spheres[1].emission = 0.0;\n    \n    spheres[2].pos = vec3(sin(4.0)*10.0, 2,cos(4.0)*10.0+22.0);\n    spheres[2].size = 2.0;\n    spheres[2].color = vec3(0.2, 0.2, 1.0);\n    spheres[2].spec = 1.0;\n    spheres[2].rough = 0.4;\n    spheres[2].emission = 5.0;\n    \n    spheres[3].pos = vec3(22.0, 6.0, 17.0);\n    spheres[3].size = 4.0;\n    spheres[3].color = vec3(1, 0.2, 0.2);\n    spheres[3].spec = 1.0;\n    spheres[3].rough = 0.4;\n    spheres[3].emission = 7.0;\n    \n    spheres[4].pos = vec3(-19.0, 9.0, 17.0);\n    spheres[4].size =10.0;\n    spheres[4].color = vec3(1.0, 1.0, 1.0);\n    spheres[4].spec = 0.0;\n    spheres[4].rough = 0.5;\n    spheres[4].emission = 0.0;\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    \n    vec3 camera_center = vec3(-5,2,0);\n    vec3 col = vec3(uv.x, uv.y, 0);\n    float focal_length = 0.7;\n    float viewport_height = 2.0;\n    float viewport_width = viewport_height * (iResolution.x / iResolution.y);\n\n    vec3 viewport_u = vec3(viewport_width, 0, 0);\n    vec3 viewport_v = vec3(0, -viewport_height, 0);\n\n    vec3 pixel_delta_u = viewport_u / iResolution.x;\n    vec3 pixel_delta_v = viewport_v / iResolution.y;\n\n    vec3 viewport_upper_left = camera_center - vec3(0, 0, focal_length) - (viewport_u / 2.0) - (viewport_v / 2.0);\n    vec3 pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v);\n    float rndU = RandomFloat01(rngState) - 0.5;\n    float rndV = RandomFloat01(rngState) - 0.5;\n    vec3 pixel_center = pixel00_loc + ((fragCoord.x + rndU) * pixel_delta_u) + ((fragCoord.y + rndV) * pixel_delta_v);\n    int SAMPLES = 16;\n    vec3 color = vec3(0);\n    vec3 ray_direction = normalize(camera_center - pixel_center);\n    vec3 througput = vec3(1.0);\n    HitInfo hitInfo;\n    vec3 rayOrigin = camera_center;\n    vec3 throughput = vec3(1.0);\n    float samples = 0.0;\n    int maxBounces = 4;\n    \n    for(int S = 0; S < SAMPLES; S++){\n    \n    throughput = vec3(1.0);\n    rayOrigin = camera_center;\n    ray_direction = normalize(camera_center - pixel_center);\n    \n    for(int b = 0; b <maxBounces; b++){\n        //HIT ALL SPHERES\n        HitInfo hitInfo = intersectAll(rayOrigin,ray_direction);\n        \n        //CHECK IF HIT\n        if(hitInfo.sphereIndex == -1){\n            throughput *= texture(iChannel0, ray_direction).xyz;\n            break;\n        }else{\n            //DECIDE REFLECTION TYPE\n            float spec = FresnelReflectAmount(1.0,1.0,hitInfo.N,ray_direction,hitInfo.spec,1.0);\n            float chance = RandomFloat01(rngState);\n            //BREAK IF EMISSIVE\n            if(hitInfo.emission > 0.0){\n                throughput *= hitInfo.color * (1.0+hitInfo.emission);\n                break;\n            }\n            if(chance < spec){\n                //SPECULAR REFLECTION\n                vec3 specular_direction = reflect(ray_direction,hitInfo.N);\n                vec3 diffuse_direction = normalize(RandomUnitVector(rngState) + hitInfo.N);\n                ray_direction = normalize(mix(specular_direction,diffuse_direction,hitInfo.rough*hitInfo.rough));\n                rayOrigin = hitInfo.hitPoint;\n                throughput *= vec3(1.0) * (1.0+hitInfo.emission);\n\n            }else{\n                //DIFFUSE REFLECTION\n                ray_direction = normalize(RandomUnitVector(rngState) + hitInfo.N);\n                rayOrigin = hitInfo.hitPoint;\n                throughput *= hitInfo.color * (1.0+hitInfo.emission);\n                throughput /= 1.0-hitInfo.spec;\n            }\n            \n            if(maxBounces-1 == b){\n                throughput = vec3(0);\n            }\n\n        }\n    } \n    color += throughput;\n    }\n    \n    color = color / float(SAMPLES);\n    color =  sqrt(color) * 0.5;\n    //Firefly reduction\n    if(color.x > vec3(1.0).x){\n        color = vec3(1.0);\n    }\n    color = color + texture(iChannel1, uv).rgb;\n    \n    fragColor = vec4(color,1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}