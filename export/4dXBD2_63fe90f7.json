{"ver":"0.1","info":{"id":"4dXBD2","date":"1499126771","viewed":386,"name":"Lignettes","username":"leon","description":"A cylinder raymarching experiment","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Leon 04 / 07 / 2017\n// using lines of code from iq, mercury, lj, koltes, duke\n\n#define PI 3.14159\n#define TAU 2.*PI\n#define t iTime*.3\n#define DITHER\n#define STEPS 50.\n\nfloat rand(vec2 co) { return fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453); }\nfloat cyl (vec2 p, float r) { return length(p)-r; }\nmat2 rot (float a) { float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nvec3 moda (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an/2.;\n    float c = floor(a/an);\n    c = mix(c,abs(c),step(count/2., abs(c)));\n    a = mod(a,an)-an/2.;\n    return vec3(vec2(cos(a),sin(a))*length(p),c);\n}\nfloat smin (float a, float b, float r) {\n    float h = clamp(.5+.5*(b-a)/r, 0., 1.);\n    return mix(b, a, h) - r*h*(1.-h);\n}\n\nvec3 camera (vec3 p) {\n    p.xz *= rot((PI*(iMouse.x/iResolution.x-.5)*step(0.5,iMouse.z)));\n    p.yz *= rot((PI*(iMouse.y/iResolution.y-.5)*step(0.5,iMouse.z)));\n    p.yz *= rot(PI/2.);\n    return p;\n}\n\nfloat curve (float x) {\n   \treturn sin(x*4.-t*2.)*.1 + sin(x*2.+t*4.)*0.2;\n}\n\n// lines tunnel\nvec3 displace (vec3 p, float radius, float count) {\n    vec3 p1 = moda(p.xz, count);\n    p1.x -= radius;\n    p.xz = p1.xy;\n    p.z -= curve(p.y+p1.z)*.2;\n    return p;\n}\n\n// circles stuff\nvec3 displace2 (vec3 p, float radius, float count) {\n    float a = atan(p.y,p.x);\n    float l = length(p.xy);\n    p.x = l - radius;\n    return p;\n}\n\nfloat map (vec3 p) {\n    float scene = 1.;\n    vec3 p0 = p;\n    \n    // tunnel distortion\n    p.xy *= rot(sin(length(p)+t*4.)*.1);\n    p.yz *= rot(sin(length(p*.5)+t)*.2);\n    p.xz *= rot(sin(length(p*2.)+t*2.)*.1);\n    float radius = 2.;\n    float size = 0.02;\n    float count = 9.;\n    vec2 front = normalize(p.xz)*.1;\n    vec2 right = vec2(front.y,-front.x);\n    vec3 p2 = p;\n    p.y -= t*4.;\n    float repeat = 8.;\n    for (float i = 0.; i < repeat; ++i) {\n        \n        // lines tunnel\n        p.xz -= front*1.5;\n        p.xz -= right*.5;\n    \tscene = min(scene,cyl(displace(p, radius, count).xz,size));\n        \n        // circle stuff\n        p2.xz *= rot(.3*(i/repeat)+t*.5);\n        p2.yz *= rot(.2*i/repeat+t);\n        p2.yx *= rot(.4*i/repeat+t*2.);\n    \tscene = smin(scene,cyl(displace2(p2, radius*.5-i*.05, count).xz,size),.1);\n    }\n    return scene;\n}\n\nvec3 getNormal (vec3 p) {\n    float e = 0.01;\n    return normalize(vec3(map(p+vec3(e,0,0))-map(p-vec3(e,0,0)),\n                          map(p+vec3(0,e,0))-map(p-vec3(0,e,0)),\n                          map(p+vec3(0,0,e))-map(p-vec3(0,0,e))));\n}\n\nvoid mainImage( out vec4 color, in vec2 coord )\n{\n\tvec2 uv = (coord.xy-.5*iResolution.xy)/iResolution.y;\n    #ifdef DITHER\n\tvec2 dpos = ( coord.xy / iResolution.xy );\n\tvec2 seed = dpos + fract(iTime);\n\t#endif \n    vec3 eye = camera(vec3(uv,-3.));\n    vec3 ray = normalize(camera(vec3(uv,1.0)));\n    vec3 pos = eye;\n    float shade = 0.;\n    for (float i = 0.; i < STEPS; ++i) {\n        float dist = map(pos);\n        if (dist < 0.001) {\n            break;\n        }\n        #ifdef DITHER\n        dist=abs(dist)*(.8+0.2*rand(seed*vec2(i)));\n        #endif \n        pos += ray*dist;\n\t\tshade = i;\n    }\n    vec3 n = getNormal(pos);\n    color = vec4(1);\n    color.rgb = n*.5+.5;\n    color.rgb *= 1.-shade/(STEPS-1.);\n}","name":"Image","description":"","type":"image"}]}