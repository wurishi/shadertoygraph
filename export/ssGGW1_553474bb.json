{"ver":"0.1","info":{"id":"ssGGW1","date":"1632149541","viewed":34,"name":"CG1","username":"helgust","description":"Simple Shader","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["phong","cg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 eye = vec3(0,0,10);\nconst vec3 light = vec3(0.0,5.0,10.0);\nconst int maxSteps = 100;\nconst float eps = 0.01;\n\n\nfloat smin (float a, float b, float k)\n{\n    float res = exp(-k*a)+exp(-k*b);\n    return -log(res)/k;\n}\n\nfloat dCone ( vec3 p, vec2 c )\n{\n    float q = length( p.yz );\n    return dot ( c, vec2 ( q, p.x ) );\n}\n\nfloat dCyl ( vec3 p, vec3 c )\n{\nreturn length ( p.xz - c.xy ) - c.z+0.03* cos(5.0*p.y + iTime)+0.02 * sin(20.0*p.z + iTime) ;\n}\n\nfloat dSphere (vec3 p, vec3 c)\n{\n    return length(p - c) - 1.0 +0.03 * sin(20.0*p.y + iTime);\n}\n\nfloat dEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat length8 (in vec2 p)\n{\n    return pow(pow(p.x,8.0) + pow (p.y,8.0),1.0/8.0);\n}\n\n\nfloat length8 ( in vec3 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ) + pow ( p.z, 8.0 ), 1.0/ 8.0 );\n}\n\n\nfloat dTorus (vec3 p, vec3 t)\n{\n    vec2  q=vec2(length8 (p.xz) - t.x,p.y);\n    return length8(q) - t.y;\n}\n\nmat3 rotateX(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(vec3(1,0,0),\n            vec3(0,c,-s),\n            vec3(0,s,c));\n}\n\nmat3 rotateZ(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(vec3(c,-s,0),\n            vec3(s,c,0),\n            vec3(0,0,1));\n}\n\nmat3 rotateY(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(vec3(c,0,s),\n            vec3(0,1,0),\n            vec3(-s,0,c));\n}\n\nfloat sdf (in vec3 p,in mat3 m)\n{\n    vec3 q = m*p;\n    vec3 o = q*rotateX(90.0);\n    \n    return smin(smin(dEllipsoid(q,vec3(1,5,1)),dCyl(rotateX(-90.0)*q,vec3(0,0,1)),7.0),smin(dSphere(q,vec3(0,5,0)),dSphere(q,vec3(0,-5,0)),8.0),9.0);\n}  \nvec3 generateNormal (vec3 z, float d,in mat3 m)\n{\n    float e  = max(d * 0.5,eps);\n    float dx1 = sdf(z+ vec3(e,0,0),m);\n    float dx2 = sdf(z- vec3(e,0,0),m);\n    float dy1 = sdf(z+ vec3(0,e,0),m);\n    float dy2 = sdf(z- vec3(0,e,0),m);\n    float dz1 = sdf(z+ vec3(0,0,e),m);\n    float dz2 = sdf(z- vec3(0,0,e),m);\n    \n    return normalize (vec3 (dx1 - dx2,dy1-dy2,dz1-dz2));\n}\n\n\n\nvec3 trace(in vec3 from, in vec3 dir, out bool hit, in mat3 m)\n{\n    vec3 p = from;\n    float totalDist = 0.0;\n    \n    hit =false;\n    \n    for (int steps = 0; steps < maxSteps; steps++)\n    {\n        float dist = sdf(p,m);\n        \n        if(dist < 0.001)\n        {\n            hit = true;\n        }\n        totalDist+=dist;\n        \n        if(totalDist > 20.0)\n            break;\n           p+=dist*dir;\n    }\n    \n    return p;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    bool hit;\n    vec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z - 0.5);\n    mat3 m = rotateX(6.0*mouse.y) * rotateY(6.0*mouse.x);\n    vec2 scale = 12.0 * iResolution.xy / max(iResolution.x,iResolution.y);\n    vec2 uv = scale * (fragCoord/iResolution.xy - vec2 (0.5));\n    vec3 dir = normalize (vec3 (uv,0) - eye);\n    vec4 color = vec4(0,0,0,1);\n    vec3 p = trace(eye,dir,hit,m);\n    \n    if(hit)\n    {\n     vec3 l = normalize(light - p);\n     vec3 v = normalize(eye - p);\n     vec3 n = generateNormal(p,0.001,m);\n     vec3 r = l-2.0*max(0.0,dot(l,n))*n;\n     float nl = max(0.0,dot(n,l));\n     vec3 h = normalize(l+v);\n     float hn = max(0.0,dot(-v,r));\n     float sp = pow (hn,90.0);\n     \n     \n     color = 0.5*vec4(nl) + sp*vec4(1,0,0,1);\n    }\n\n    // Output   to screen\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}