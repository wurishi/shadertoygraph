{"ver":"0.1","info":{"id":"ldXBRS","date":"1496668116","viewed":95,"name":"beerpong","username":"macke","description":"beerpong","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","raytrace","beerpong"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.1415\n#define tm iTime\n\n\nstruct Object {\n    float d; // Distance\n    vec3 color;\n};\n    \n    \nObject omin(Object o1, Object o2) {\n    if(o1.d <= o2.d) {\n        return o1;\n    }\n    return o2;\n}\n\nObject omax(Object o1, Object o2) {\n    if(o1.d >= o2.d) {\n        return o1;\n    }\n    return o2;\n}\n    \nmat3 rotz(float t){\n     return mat3( cos(t),  -sin(t), 0,\n       \t          sin(t),   cos(t), 0,\n\t\t  \t\t  0,        0 ,     1);\n}\n\nmat3 roty(float t){\n    return  mat3( cos(t),  0,  sin(t),\n     \t    \t  0,       1,  0,\n           \t      -sin(t), 0,  cos(t)); \n\n}\n\nmat3 rotx(float t){\n     return mat3( 1, 0 ,      0,\n            \t  0, cos(t), -sin(t),\n\t   \t  \t      0, sin(t),  cos(t));\n}\n\nfloat modcenter(float t, float m) {\n    t += m/2.;\n    return mod(t, m) - m/2.;\n}\n\nfloat modax(float t, float m) {\n    return mod(t, m) - m/2.;\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p)-r;\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n   \treturn length(max(abs(p)-s,0.));\n    \n}\n\nObject sdCups(vec3 p) {\n    \n    //Cup (h,r1, r2)\n    vec3 ccfg = vec3(1.6, 1., 1.4);\n    \n    // Front\n    float frontbox = sdBox(p + vec3(.0,.0,3.), vec3(ccfg.z,2.,4.5));\n    \n    // Back\n    float backbox = sdBox(p, vec3(4.5,2., ccfg.z));\n    \n    //bCups\n    vec3 cb = p;\n    cb.x = modcenter(cb.x, 3.);\n    cb.z = modcenter(cb.z, 5.6);\n    float bouter = sdConeSection(cb, ccfg.x, ccfg.y, ccfg.z);\n    cb.y -= 0.1;\n    float binner = sdConeSection(cb, ccfg.x, ccfg.y - 0.01, ccfg.z - 0.01);\n   \tfloat bcups = max(-binner,bouter);\n    float backrow = max(bcups,backbox);\n    \n    // Mid\n    float midbox = sdBox(p + vec3(0.,0.,2.8), vec3(3.0,2., ccfg.z));\n    \n    //mCup\n    vec3 mb = p;\n    mb.z += 2.8;\n    mb.x = modax(cb.x, 3.);\n    float mouter = sdConeSection(mb, ccfg.x, ccfg.y, ccfg.z);\n    mb.y -= 0.1;\n    float minner = sdConeSection(mb, ccfg.x, ccfg.y - 0.01, ccfg.z - 0.01);\n   \tfloat mcups = max(-minner,mouter);\n    float midrow = max(mcups,midbox);\n    \n    //Front\n    float frontrow = max(bcups, frontbox);\n    \n    float d = min(midrow,min(frontrow, backrow));\n    return Object(d, vec3(1.,0.25,0.25));\n}\n\nObject sdTable(vec3 p, vec3 s, float h) {\n    float tabletop = sdBox(p, s);\n    p.x = abs(p.x) - s.x + .4;\n    p.z = abs(p.z) - s.z + 2.;\n    p.y += h;\n    float legs = sdCappedCylinder(p, vec2(0.4,h));\n    \n    if(tabletop < legs) {\n        return Object(tabletop, vec3(210.,105.,30.)/255.);\n    } else {\n        return Object(legs,vec3(210.,105.,30.)/255.);\n    }\n}\n\nvec3 parabolajump(vec3 start, vec3 end, float t) {\n    vec3 dir = normalize(end-start);\n    \n    vec3 cpos = start + vec3(dir.x*t, dir.y*t-sin(t*0.2)*4., dir.z*t);\n    \n    return cpos;\n}\n\n\nObject map(vec3 p) {\n    p *= roty(tm);\n    vec3 c = p + vec3(0.,-2.,-16.);\n    Object cups = sdCups(c);\n    vec3 c2 = p * roty(pi) + vec3(0.,-2.,-16.);;\n    Object cups2 = sdCups(c2);\n    cups2.color = vec3(0.1,0.1,.6);\n    Object table = sdTable(p, vec3(6.,.4,18.), 6.);\n    \n    // Ball not working\n    Object ball1 = Object(sdSphere(p + vec3(2.6,-0.6,0.), 0.3), vec3(1.,1.,1.));\n    Object ball2 = Object(sdSphere(p + vec3(2.,-0.6,0.), 0.3), vec3(1.,1.,1.));\n    Object balls = omin(ball1,ball2);\n    //ball.d = 100.;\n    \n    Object floor = Object(p.y + 16., vec3(1.));\n    \n    return omin(omin(cups,cups2),omin(omin(floor,table),balls));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv*2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 o = vec3(-10.,12, -20.);\n    vec3 r = normalize(vec3(uv,2.));\n    \n    //Mouse\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n  \tr *= rotx(pi/6.);\n   \tr *= roty(pi/6.);\n   \t//r *= roty(mo.x*4.);\n    //r *= rotx(mo.y*4.);\n    \n    //Distance, p = position of object\n   \tObject obj = Object(0., vec3(0.,0.,0.));\n    vec3 p;\n    for (int i = 0; i < 64; i++) {\n        p = o + r * obj.d;\n     \tObject m = map(p);\n        obj.d += m.d * 0.9;\n       obj.color = m.color;\n    }\n    \n   \t//Light\n    vec3 normal = normalize(-p);\n    vec3 light = normalize(vec3(.5, -6., 16.));\n    float a = acos(dot(normal, light));\n    \n    float fog = 1.0 / (0.001 * obj.d * obj.d + .7 + a*0.2);\n    \n\tfragColor = vec4(vec3(fog) * obj.color,1.0);\n}","name":"Image","description":"","type":"image"}]}