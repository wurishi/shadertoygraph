{"ver":"0.1","info":{"id":"ltBXW1","date":"1443448565","viewed":212,"name":"Snowmen","username":"buksy","description":"Just learning :), this is my very first shader :) ... I guess my code is way toooo long for such an easy animation, so any tips, recommendations, etc will be highly appreciated ;)","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","snow","winter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"vec3 circle(in vec2 r, in vec2 center, in float radius)\n{\n    float ret; // how much is it circle? (1.0 absolutely, 0.0 it is not)\n    \n    float a = smoothstep(0.0, 0.01, length(r-center)-radius);\n    ret = smoothstep(1.0, 0.0, a);\n    return vec3(ret);\n}\n\n\nvec3 rectangle(vec2 r, vec2 topLeft, vec2 bottomRight, in float angle) {\n    float ret;\n\tmat2 rotationMatrix = mat2(cos(angle), -sin(angle),\n                               sin(angle),  cos(angle));\n    // Shift to normalize coordinates\n    vec2 shift;\n    shift.x = (abs(topLeft.x)<abs(bottomRight.x)?topLeft.x:bottomRight.x) + (abs(topLeft.x)<abs(bottomRight.x)?bottomRight.x-topLeft.x:topLeft.x-bottomRight.x)*0.5;\n    shift.y = (abs(topLeft.y)<abs(bottomRight.y)?topLeft.y:bottomRight.y) + (abs(topLeft.y)<abs(bottomRight.y)?bottomRight.y-topLeft.y:topLeft.y-bottomRight.y)*0.5;\n\n    // all shifted coordinates\n    vec2 q = rotationMatrix * (r-shift);\n    vec2 shifted_tl = topLeft - shift;\n    vec2 shifted_br = bottomRight - shift;\n\t\n\tfloat d = 0.005;\n\tret = smoothstep(shifted_tl.x-d, shifted_tl.x+d, q.x);\n\tret *= smoothstep(shifted_tl.y-d, shifted_tl.y+d, q.y);\n\tret *= 1.0 - smoothstep(shifted_br.y-d, shifted_br.y+d, q.y);\n\tret *= 1.0 - smoothstep(shifted_br.x-d, shifted_br.x+d, q.x);\n\treturn vec3(ret);\n}\n\n\nvec3 mouth(in vec2 r, in vec2 center, in float radius, in float weight)\n{\n    float ret = smoothstep(0.0, 0.01, float(abs(length(r-center)-radius)<weight && r.y<center.y) );\n    return vec3(ret);\n}\n\nfloat sign(vec2 p1, vec2 p2, vec2 p3)\n{\n    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n}\nvec3 triangle(in vec2 r, in vec2 p1, in vec2 p2, in vec2 p3)\n{\n    // http://stackoverflow.com/questions/2049582/how-to-determine-a-point-in-a-triangle\n    bool b1, b2, b3;\n    \n    b1 = sign(r, p1, p2) < 0.0;\n    b2 = sign(r, p2, p3) < 0.0;\n    b3 = sign(r, p3, p1) < 0.0;\n    \n    // TODO: Add antialiasing\n    float a = float((b1==b2)&&(b2==b3));\n    return vec3(a);\n    //return vec3(smoothstep(0.0, 1.0, a));\n}\n\n// Snowman\n// Takes in:\n// ret - current pixel color so far\n// r - current pixel position from [-1, -1] to [1, 1]\n// center - center position of snowman\n// scale - scale factor\nvoid snowman2(inout vec3 ret, in vec2 r, in vec2 center, in float scale)\n{\n    vec3 membership;\n    \n    \n    // circles (body)\n    membership = circle(r, vec2(center.x, center.y+0.16*scale), 0.08*scale);\n    membership+= circle(r, center, 0.12*scale);\n    membership+= circle(r, vec2(center.x, center.y-0.25*scale), 0.2*scale);\n    ret = mix(ret, vec3(1.0), membership);\n    \n    // Dots in center\n    membership = circle(r, vec2(center.x, center.y+0.05*scale), 0.002*scale);\n    membership+= circle(r, center, 0.002*scale);\n    membership+= circle(r, vec2(center.x, center.y-0.05*scale), 0.002*scale);\n    ret = mix(ret, vec3(0.0), membership);\n    \n    // Eyes\n    membership+= circle(r, vec2(center.x+0.03, center.y+0.17*scale), 0.004*scale);\n    membership+= circle(r, vec2(center.x-0.03, center.y+0.17*scale), 0.004*scale);\n    ret = mix(ret, vec3(0.0), membership);\n    \n    // Carrot\n    membership = triangle(r, \n                          vec2(center.x, center.y+0.16*scale), \n                          vec2(center.x, center.y+0.14*scale), \n                          vec2(center.x+0.04, center.y+0.145*scale));\n    ret = mix(ret, vec3(0.7, 0.0, 0.0), membership);\n    \n    // Mouth\n    membership = mouth(r, vec2(center.x, center.y+0.136*scale), 0.02, 0.002);\n    ret = mix(ret, vec3(0.0, 0.0, 0.0), membership);\n    \n    \n    // Hands\n    membership = rectangle(r, vec2(center.x+0.15*scale, center.y-0.05*scale), vec2(center.x+0.16*scale, center.y+0.15*scale), -0.9);\n    membership+= rectangle(r, vec2(center.x-0.16*scale, center.y-0.05*scale), vec2(center.x-0.15*scale, center.y+0.15*scale), 0.9);\n    ret = mix(ret, vec3(0.0, 0.0, 0.0), membership);\n\n    \n    // Hat\n    membership = rectangle(r, vec2(center.x-0.085*scale, center.y+0.20*scale), vec2(center.x+0.085*scale, center.y+0.25*scale), 0.03);\n    ret = mix(ret, vec3(0.4, 0.0, 0.7), membership);\n}\n\n\n\nvoid snow(inout vec3 ret, in vec2 r, in float time)\n{\n    vec3 membership;\n    \n    membership = vec3(0.0);\n    float x;\n    for(float j=0.0; j < 1.0; j+=0.3)\n    {\n        for(float i=0.0; i < 1.0; i+=0.1)\n        {   \n            float y;\n            //y = iTime * 0.3;\n            y = (j*1.2) + iTime * 0.2 + 0.06*sin(i*25.0);\n            x = (0.01*j*iTime) + i*1.8 + 0.01*cos(iTime*i*5.0);\n            \n            membership+= circle(r, vec2(0.895 - mod(x, 1.8), 0.5 - mod(y, 1.0)), 0.001*j*i);\n            ret = mix(ret, vec3(0.9, 0.9, 1.0), membership);\n        }\n    }\n}\n\n\n// Draw hill\n// Hill is actually half of circle and most of the circle is moved out of the screen\nvoid hill(inout vec3 ret, in vec2 r, in vec2 center, in float scale)\n{\n    vec2 p = r;\n    vec3 membership;\n    float min_y = float(r.y > center.y);\n    \n    // Border\n    membership = circle(r, center, scale+0.005);\n    ret = mix(ret, vec3(0.8, 0.8, 1.0), membership * min_y);\n    \n    // Hill gradient\n    membership = circle(r, center, scale);    \n    ret = mix(ret, \n              mix(vec3(0.97), vec3(0.85), smoothstep(center.y+scale, -0.5, r.y)),\n              membership * min_y);\n}\n\n\n\nvoid nightsky(inout vec3 ret, in vec2 r, in float time)\n{\n    vec3 membership;\n    \n    membership = vec3(0.0);\n    float x;\n    for(float j=0.0; j < 1.0; j+=0.4)\n    {\n        for(float i=-1.0; i < 1.0; i+=0.4)\n        {   \n            float y;\n            //y = iTime * 0.3;\n            y = -0.2 + i + j + 0.05*sin(i*7.0);\n            x = i + j*0.1;\n            \n            membership+= circle(r, vec2(0.895 - mod(x, 1.8), 0.5 - mod(y, 1.0)), 0.005*sin(mod(iTime*0.4, 3.14)-0.0));\n            ret = mix(ret, vec3(1.0, 1.0, 0.0), membership);\n        }\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // to [-1, -1] x [1, 1] - not really :)\n    vec2 r = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y ;\n    // output color rgb\n    vec3 ret;\n    // Background gradient\n    ret = vec3(0.0, 1.0 - (r.y+1.4)*0.5, 1.0 - (r.y+0.9)*0.5);\n    \n    nightsky(ret, r, iTime);\n    \n    hill(ret, r, vec2(0.5, -1.2), 1.0);\n    hill(ret, r, vec2(-0.3, -1.1), 1.0);\n    \n    snowman2(ret, r, vec2(-0.5,0.1), 0.8);\n    snowman2(ret, r, vec2(-0.1, 0.04), 0.65);\n\n    snow(ret, r, iTime);\n    //ret = mix(ret, vec3(0.9, 0.1, 0.0), circle(r, vec2(0.0, -0.5), 0.01));\n    //ret = mix(ret, vec3(0.9, 0.1, 0.0), circle(r, vec2(0.0, 0.5), 0.01));\n    \n    fragColor = vec4(ret.x, ret.y, ret.z, 1.);\n}","name":"","description":"","type":"image"}]}