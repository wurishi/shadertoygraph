{"ver":"0.1","info":{"id":"llccD2","date":"1534313490","viewed":1370,"name":"Brute Force Accumulation","username":"mhnewman","description":"Brute force ambient occlusion, depth of field, spherical aberration, and anti aliasing using accumulation buffer.\n\nBased on www.shadertoy.com/view/4tlfDn Reusable Voxel Engine.\nCreate your scene by filling in setCamera(), voxelHit(), and voxelColor().","likes":60,"published":1,"flags":32,"usePreview":0,"tags":["voxel","aberration","occlusion","field","depth","ambient","spherical","of"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Brute force ambient occlusion, depth of field, spherical aberration,\n// and anti aliasing using accumulation buffer.\n//\n// Based on www.shadertoy.com/view/4tlfDn Reusable Voxel Engine.\n// Create your scene by filling in setCamera(), voxelHit(), and voxelColor().\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = pow(1.0 - pow(1.0 - texture(iChannel0, fragCoord.xy / iResolution.xy), vec4(5.0)), vec4(1.6));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Brute force ambient occlusion, depth of field, spherical aberration,\n// and anti aliasing using accumulation buffer.\n//\n// Based on www.shadertoy.com/view/4tlfDn Reusable Voxel Engine.\n// Create your scene by filling in setCamera(), voxelHit(), and voxelColor().\n\nconst float sphericalAberration = 0.1;\nconst float vignetting = 0.3;\nconst vec3 backgroundColor = vec3(0.2, 0.1, 0.2);\nconst int hitIter = 300;\nconst int shadeIter = 100;\n\n// Set Camera will position and aim the camera.\n//   eye := The location of the camera.\n//   center := The location at which the camera is looking.\n//   focalDist := Center of focus\n//   blurAmount := Amount of depth of field\n//   Return value := Camera focal length.\nfloat setCamera(out vec3 eye, out vec3 center, out float focalDist, out float blurAmount) {\n    focalDist = 85.0;\n    blurAmount = 0.01;    \n    \n    vec2 m = vec2(0.3, 0.83);\n    m *= 6.283185 * vec2(1.0, 0.25);    \n    float dist = 130.0;\n    center = vec3(0.0, 0.0, 0.0);\n    eye = center + vec3(dist * sin(m.x) * sin(m.y), dist * cos(m.x) * sin(m.y), dist * cos(m.y));\n    return 8.0;\n}\n\n// Voxel Hit returns true if the voxel at pos should be filled.\nbool voxelHit(vec3 pos) {\n    float height = 20.0 * pow(hash1(floor(pos.xy / 3.0)), 3.0) * pow(hash1(pos.xy), 0.3);\n    return pos.z < height * step(0.5, mod(pos.x, 3.0)) * step(0.5, mod(pos.y, 3.0));\n}\n\n// Voxel Color returns the color at pos with normal vector norm.\nvec3 voxelColor(vec3 pos, vec3 norm) {\n    vec3 low = vec3(1.0, 0.0, 0.5);\n    vec3 mid = vec3(0.8, 0.5, 1.0);\n    vec3 hi = vec3(0.0, 0.7, 1.0);\n    \n    float c = hash1(floor(pos.xy / 3.0) + vec2(0.1));\n    c = 0.7 * c + 0.3 * hash1(floor(8.0 * pos.z) + c);\n    float a = 0.5 + 0.5 * hash1(floor(8.0 * pos.z) + c);\n    c = clamp(2.0 * c, 0.0, 2.0);  \n    return a * mix(mix(low, mid, c), mix(mid, hi, c - 1.0), step(1.0, c));\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Fill in the functions above.\n// The engine below does not need to be modified.\n////////////////////////////////////////////////////////////////////////////////\n\nfloat castRay(vec3 eye, vec3 ray, int maxIter, out float dist, out vec3 norm) {\n    vec3 pos = floor(eye);\n    vec3 ri = 1.0 / ray;\n    vec3 rs = sign(ray);\n    vec3 ris = ri * rs;\n    vec3 dis = (pos - eye + 0.5 + rs * 0.5) * ri;\n    \n    vec3 dim = vec3(0.0);\n    for (int i = 0; i < maxIter; ++i) {\n        if (voxelHit(pos)) {\n            dist = dot(dis - ris, dim);\n            norm = -dim * rs;\n            return 1.0;\n        }\n    \n        dim = step(dis, dis.yzx);\n\t\tdim *= (1.0 - dim.zxy);\n        \n        dis += dim * ris;\n        pos += dim * rs;\n    }\n\n\treturn 0.0;\n}\n\nvec3 pass(vec2 coord, float time) {\n    vec3 eye, center;\n    float focalDist, blurAmount;\n    float zoom = setCamera(eye, center, focalDist, blurAmount);\n    \n    vec3 forward = normalize(center - eye);\n    vec3 right = normalize(cross(forward, vec3(0.0, 0.0, 1.0)));\n    vec3 up = cross(right, forward);\n\n    // Anti aliasing\n    vec2 hash = hash2(vec3(time, coord));\n    vec2 xy = (2.0 * (coord + hash - 0.5) - iResolution.xy) / iResolution.y;\n    \n    // Spherical aberration\n    xy /= cos(sphericalAberration * (1.0 + 0.3 * hash1(vec3(time, coord))) * length(xy));\n    \n    vec3 ray = normalize(xy.x * right + xy.y * up + zoom * forward);\n    \n    // Depth of field    \n    hash = hash2(vec3(time + 0.1, coord));\n    float a = sqrt(hash.x);\n    float b = a * cos(6.283185 * hash.y);\n    float c = a * sin(6.283185 * hash.y);\n\n    vec3 target = eye + ray * focalDist / dot(ray, forward);\n    eye += focalDist * blurAmount * (b * right + c * up);\n    ray = normalize(target - eye);\n    \n    // Cast Ray\n    float dist;\n    vec3 norm;\n    float hit = castRay(eye, ray, hitIter, dist, norm);\n    vec3 pos = eye + dist * ray;\n\n    vec3 color = voxelColor(pos - 0.001 * norm, norm);\n    \n    // Ambient occlusion\n    pos += 0.001 * norm;\n\n    vec3 z = norm;\n    vec3 x = normalize(cross(z, vec3(-0.36, -0.48, 0.8)));\n    vec3 y = normalize(cross(z, x));\n\n    hash = hash2(vec3(time + 0.2, coord));\n    a = sqrt(hash.x);\n    b = a * cos(6.283185 * hash.y);\n    c = a * sin(6.283185 * hash.y);\n    a = sqrt(1.0 - hash.x);\n    vec3 shadeDir = b * x + c * y + a * z;\n    color = mix(color, vec3(0.0, 0.0, 0.0), castRay(pos, shadeDir, shadeIter, dist, norm));\n    \n    return mix(backgroundColor, color, hit);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {    \n    // Restart accumulation on window resize\n    vec3 frame = texture(iChannel0, vec2(0.5) / iResolution.xy).xyz;\n    float resize = step(abs(frame.x - iResolution.x) + abs(frame.y - iResolution.y), 0.5);\n    frame.xy = iResolution.xy;\n    frame.z = mix(1.0, frame.z + 1.0, resize);\n    \n    // Render pass\n\tvec3 color = pass(fragCoord, iTime);\n    \n    // 10 passes on the first frame to render the preview.\n    if (resize < 0.5) {\n        for (int i = 1; i < 10; ++i)\n\t        color += pass(fragCoord, iTime + 0.01 * float(i));\n        color *= 0.1;\n    }\n\n    // Vignetting\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    color *= vignetting * pow((1.0 - uv.x * uv.x) * (1.0 - uv.y * uv.y), 0.2) + 1.0 - vignetting;\n    \n    // Accumulate color\n    vec3 oldColor = texture(iChannel0, fragCoord.xy / iResolution.xy).rgb;\n    vec3 accum = mix(oldColor, color, 1.0 / frame.z);\n    fragColor = vec4(mix(accum, frame, step(fragCoord.x + fragCoord.y, 1.5)), 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\nfloat hash1(float p) {\n\tvec2 p2 = fract(p * vec2(5.3983, 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nfloat hash1(vec2 p2) {\n\tp2 = fract(p2 * vec2(5.3983, 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nfloat hash1(vec3 p3) {\n    p3 = fract(p3 * vec3(5.3983, 5.4427, 6.9371));\n    p3 += dot(p3, p3.yxz + 19.19);\n    return fract(p3.x * p3.y * p3.z);\n}\n\nvec2 hash2(vec3 p3) {\n\tp3 = fract(p3 * vec3(5.3983, 5.4427, 6.9371));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n","name":"Common","description":"","type":"common"}]}