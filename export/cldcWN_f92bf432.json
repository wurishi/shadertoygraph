{"ver":"0.1","info":{"id":"cldcWN","date":"1699219694","viewed":68,"name":"rotate star galaxy","username":"nayk","description":"rotate star galaxy","likes":1,"published":1,"flags":1,"usePreview":0,"tags":["rotatestargalaxy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/* original https://www.shadertoy.com/view/lslyRn  https://www.shadertoy.com/view/4dcBzX*/\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n\n#define speed2 .2\n\nfloat chebychev(vec3 a, vec3 b)\n{\n    return max(max(abs(a.x - b.x), abs(a.y - b.y)), abs(a.z - b.z));\n}\n\n\nfloat manhattan(vec3 a, vec3 b)\n{\n    vec3 d = abs(a - b);\n    return d.x + d.y + d.z;\n}\n\n// iq\nvec3 random3f( vec3 p )\n{\n    return fract(sin(vec3( dot(p,vec3(1.0,57.0,113.0)), \n                           dot(p,vec3(57.0,113.0,1.0)),\n                           dot(p,vec3(113.0,1.0,57.0))))*43758.5453);\n}\n\nfloat voronoi3(vec3 p)\n{\n    vec3 fp = floor(p);\n    \n    float d1 = 1./0.;\n    float d2 = 1./0.;\n    \n    for(int i = -1; i < 2; i++)\n    {\n        for(int j = -1; j < 2; j++)\n        {\n            for(int k = -1; k < 2; k++)\n            {\n                vec3 cur_p = fp + vec3(i, j, k);\n                \n                vec3 r = random3f(cur_p);\n                \n                float cd = 0.0;                    \n                cd = chebychev(p, cur_p + r);\n                d2 = min(d2, max(cd, d1));\n                d1 = min(d1, cd);\n            }\n        }\n    }\n    return clamp(max(0.0, 16.0 * (d2-d1)), 0.0, 1.0);\n}\n\n\nvec2 rotate(vec2 v, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.03,1.);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,iTime*0.05);\n\tfloat time=iTime*speed+.25;\n\n\t float piT = iTime*3.14159*speed;\n    float linearT = iTime*speed;\n    fragCoord -= iResolution.xy*.5;\n    \n  \n    \n    uv*=5.+pow(smoothstep(.3, -.3, sin(piT+.8-length(uv)*.1)), 1.)*100.;\n    \n    \n\tvec3 c = vec3(0.);\n         uv.xy+=rotate(uv.xy,iTime/1.-length(uv.xy)*0.11);\n    uv = abs(uv);\n    uv.x-=linearT*.5;\n    float d = uv.x + uv.y;\n    linearT-= d*.1;\n    uv-=cos(iTime);\n    vec2 off = vec2(sin(cos(piT)-d), cos(sin(piT)+d))*.05;\n\n    float amp = 1.;\n    for(float i = 2.; i<8.; i++){\n        vec3 m = vec3(\n    \tvoronoi3(vec3(uv,i*5.+ abs(mod(linearT+.15, 2.5)-1.25))),\n    \tvoronoi3(vec3(uv,i*5.+ abs(mod(linearT+.1, 2.5)-1.25))),\n    \tvoronoi3(vec3(uv,i* 5.+ abs(mod(linearT+.05, 2.5)-1.25)))  //*/      \n        );\n        m = pow(m, vec3(2.));\n    \tuv*= .1;\n        \n        uv+=i;\n        if(floor(mod(i, 2.))==1.){\n            c*=m;\n            uv.x+=sin(piT)*amp;\n            //uv.y+=cos(t)*amp;\n        }else{\n            c+=m;\n            uv.x-=sin(piT)*amp;\n            //uv.y-=cos(t)*amp;\n        }\n    \n    }\n    c = c*.333;\n\t\n\tvec3 from=vec3(1.,.5,0.5)*c;\n\tfrom+=vec3(time*2.,time,-2.);\n\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\t\n}\n","name":"Image","description":"","type":"image"}]}