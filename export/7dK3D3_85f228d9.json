{"ver":"0.1","info":{"id":"7dK3D3","date":"1632346829","viewed":1371,"name":" Branchless Voxel Raycasting Tex","username":"jt","description":"Fork of [url]https://www.shadertoy.com/view/4dX3zl[/url] Branchless Voxel Raycasting by fb39ca4 (with loop optimization by kzy),\nbased on the article [url]http://lodev.org/cgtutor/raycasting.html[/url].\nAdded 3d-texture on the voxels by recovering hitpos.","likes":11,"published":1,"flags":0,"usePreview":1,"tags":["3d","raytracing","raycasting","voxel","fork","dda","textured"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/7dK3D3 Branchless Voxel Raycasting Tex\n// fork of https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting by fb39ca4\n// (with loop optimization by kzy), DDA based on http://lodev.org/cgtutor/raycasting.html\n// 3d-texture on voxels addon by jt\n\n// tags: 3d, raytracing, raycasting, voxel, dda, textured, fork\n\n#define pi 3.1415926\n\nmat3 yaw_pitch_roll(float yaw, float pitch, float roll)\n{\n    mat3 R = mat3(vec3(cos(yaw), sin(yaw), 0.0), vec3(-sin(yaw), cos(yaw), 0.0), vec3(0.0, 0.0, 1.0));\n    mat3 S = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, cos(pitch), sin(pitch)), vec3(0.0, -sin(pitch), cos(pitch)));\n    mat3 T = mat3(vec3(cos(roll), 0.0, sin(roll)), vec3(0.0, 1.0, 0.0), vec3(-sin(roll), 0.0, cos(roll)));\n\n    return R * S * T;\n}\n\nfloat checker(vec3 p)\n{\n    //return step(0.5, length(1.0 - abs(2.0 * fract(p) - 1.0))); // dots\n    return step(0.0, sin(pi * p.x + pi/2.0)*sin(pi *p.y + pi/2.0)*sin(pi *p.z + pi/2.0));\n    //return step(0.0, sin(p.x)*sin(p.y)*sin(p.z));\n}\n\nfloat sphere(vec3 p, float d)\n{ \n    return length(p) - d;\n} \n\nfloat box( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nbool get_voxel(ivec3 c) {\n\tvec3 p = vec3(c) + vec3(0.5);\n\tfloat d = min(max(-sphere(p, 7.5), box(p, vec3(6.0))), -sphere(p, 25.0));\n\treturn d < 0.0;\n}\n\n// \"The raycasting code is somewhat based around a 2D raycasting toutorial found here: \n//  http://lodev.org/cgtutor/raycasting.html\" (fb39ca4)\n\n#define MAX_RAY_STEPS 64\n\nvoid mainImage( out vec4 fragColor, in vec2 I )\n{\n    bool demo = all(lessThan(iMouse.xy, vec2(10.0)));\n    vec2 R = iResolution.xy;\n    //I = 2.0 * I.xy / R - 1.0;\n    //I.x *= R.x / R.y;\n    I = (2.0 * I - R) / R.y; // concise pixel-position mapping thanks to Fabrice\n    float yaw = 2.0 * pi * float(iMouse.x) / float(R.x);\n    float pitch = -pi/4.0 + pi - pi / 2.0 * float(iMouse.y) / float(R.y);\n    yaw = !demo ? yaw : 2.0 * pi * fract(iTime * 0.01);\n    pitch = !demo ? pitch : /* 1.5 * */ pi/2.0;\n\n    vec3 ray_pos = vec3(0.0, 0.0, -16.0);\n    vec3 ray_dir = vec3(I.x, I.y, 2.0); // NOTE: un-normalized direction appears to work fine here!\n    //ray_dir = normalize(ray_dir); // looks like ray-direction does not need to be normalized\n\n    mat3 M = yaw_pitch_roll(yaw, pitch, 0.0);\n    ray_pos = M * ray_pos;\n    ray_dir = M * ray_dir;\n    \n    //ray_pos.z -= 0.0;\n\n    ray_dir = normalize(ray_dir);\n\n    ivec3 map_pos = ivec3(floor(ray_pos + 0.));\n\n    vec3 color = vec3(1.0);\n    vec3 side_dist;\n    bvec3 mask;\n    // core of https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting by fb39ca4 (somewhat reduced)\n    vec3 delta_dist;\n    {\n        delta_dist = 1.0 / abs(ray_dir);\n        ivec3 ray_step = ivec3(sign(ray_dir));\n        side_dist = (sign(ray_dir) * (vec3(map_pos) - ray_pos) + (sign(ray_dir) * 0.5) + 0.5) * delta_dist; \n\n        for (int i = 0; i < MAX_RAY_STEPS; i++)\n        {\n            if (get_voxel(map_pos)) break; // forked shader used continue here\n\n            mask = lessThanEqual(side_dist.xyz, min(side_dist.yzx, side_dist.zxy)); // fb39ca4: \"Thanks kzy for the suggestion!\"\n            side_dist += vec3(mask) * delta_dist;\n            map_pos += ivec3(vec3(mask)) * ray_step;\n        }\n\n        color *= mask.x ? vec3(0.5) : mask.y ? vec3(1.0) : mask.z ? vec3(0.75) : vec3(0.0);\n    }\n\n    // jt's 3d-texture addon recovering distance & subvoxel intersection-position of ray \n    // as described in https://lodev.org/cgtutor/raycasting.html (see \"perpWallDist\" there)\n    //float d = (mask.x ? side_dist.x - delta_dist.x : mask.y ? side_dist.y - delta_dist.y : mask.z ? side_dist.z - delta_dist.z : 0.0) / length(ray_dir);\n    //float d = length(vec3(mask) * (sideDist - delta_dist)) / length(ray_dir); // ray_dir not normalized\n    float d = length(vec3(mask) * (side_dist - delta_dist)); // ray_dir normalized\n\n    vec3 dst = ray_pos + ray_dir * d;    \n    // simple 3d-texture as proof-of-concept\n    //color *= texture(iChannel0, dst).xyz;\n    color *= vec3(0.5 + 0.5 * checker(dst));\n\n    vec3 fogcolor = vec3(0.25, 0.4, 0.5); // fog\n    //vec3 fogcolor = vec3(0.75, 0.6, 0.3); // smog\n    color *= mix(fogcolor, color, exp(-d * d / 200.0)); // fog for depth impression & to suppress flickering\n    \n    //if(mask.x) color = texture(iChannel1, fract(dst.yz)).xyz; // try with video-texture :)\n    //if(mask.y) color = texture(iChannel2, fract(dst.xz)).xyz; // try with video-texture :)\n    //if(mask.z) color = texture(iChannel3, fract(dst.xy)).xyz; // try with video-texture :)\n\n\tfragColor.rgb = color;\n}\n","name":"Image","description":"","type":"image"}]}