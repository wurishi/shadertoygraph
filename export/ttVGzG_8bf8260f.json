{"ver":"0.1","info":{"id":"ttVGzG","date":"1595416259","viewed":83,"name":"Hexagon lighting","username":"Atchafalaya","description":"Playing around with some hexagon algorithms for my first shader","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["hexagons"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\n#define Focal 1000\n\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// Material as follow, ambiant, diffuse, specular, shininess.\nvec4 material() { return vec4(0.3, 0.5, 0.8, 0.9); }\n\nvec2 transformToHexBase(vec2 uv, float hexSize)\n{\n    mat2 toHexBase = mat2(sqrt(3.), 0., -1., 2.)/(3. * 2. * hexSize);\n    return toHexBase * uv;\n}\n\nivec2 roundHex(vec2 f)\n{\n    float fq = f.x;\n    float fr = f.y;\n    float q = round(fq);\n    float r = round(fr);\n    float s = round(-fq -fr);\n    vec3 diff = vec3(abs(q-fq), abs(r-fr), abs(s + fq + fr));\n    if (diff.x > diff.y && diff.x > diff.z) { q = -r -s; }\n    else if (diff.y > diff.z) \t\t\t\t{ r = -q -s; }\n    else \t\t\t\t\t\t\t\t\t{ s = -q -r; }\n    return ivec2(q, r);\n}\n\nvec3 getViewer(vec2 uv)\n{\n    return normalize(vec3(-uv, -Focal));\n}\n\nvec3 getNormal(vec2 uv, float hexSize)\n{\n    float hexHeight = 0.05;\n    float halfsqrt3 = sqrt(3.)/2.;\n    ivec2 ihexCoord = roundHex(transformToHexBase(uv, hexSize));\n    vec2 hexCoord = vec2(ihexCoord.x, ihexCoord.y);\n    mat2 toUVBase = mat2(sqrt(3.), 0., sqrt(3.)/2., 3./2.) * 2.*hexSize;\n    vec2 hexCenter = toUVBase * hexCoord;\n    vec2 diff = uv - hexCenter;\n    if (diff.x == 0.) return normalize(vec3(0., sign(diff.y) * hexHeight, -hexSize));\n    if (abs(atan(diff.y/diff.x)) < PI/6.)\n    {\n        return normalize(vec3(sign(diff.x) * hexHeight, 0., -halfsqrt3 * hexSize));\n    }\n    else if (atan(diff.y/diff.x) > PI/6.)\n    {\n        return normalize(vec3(rot2(PI/3.)*vec2(sign(diff.y) * hexHeight, 0.), -halfsqrt3 * hexSize));\n    }\n\telse if (atan(diff.y/diff.x) < -PI/6.)\n    { \n        return normalize(vec3(rot2(-PI/3.)*vec2(sign(-diff.y) * hexHeight, 0.), -halfsqrt3 * hexSize));\n    }\n    else { return vec3(length(diff)); }\n}\n\nvec3 getColor(vec2 uv, float hexSize)\n{\n    float t = 0.5 - uv.y;\n    float r = max(0., 1. - 3. * t) + min(max(0.,1.5 * t-1.), 1.);\n    float g = min(1., 1. - 3.*abs(t-1./3.));\n    float b = min(1., 1. - 3.*abs(t-2./3.));\n\treturn vec3(r,g,b);\n}\n\nvec3 phongIlluminate(vec2 uv, vec3 lightPos, float hexSize)\n{\n    vec3 viewer = getViewer(uv);\n    vec3 normal = getNormal(uv, hexSize);\n    vec3 objectPos = vec3(uv, 0.);\n    \n    vec3 L = normalize(lightPos - objectPos);\n    vec3 R = normalize(2.*dot(L,normal)*normal - L);\n    viewer = normalize(viewer - objectPos);\n    \n    if (dot(L, normal) > 0. && dot(viewer, normal) > 0.)\n    {\n        float kd = material().y;\n        float ks = material().z;\n        float shi = material().w;\n        float I = kd*dot(L, normal);\n        if (dot(R, viewer) > 0.)\n        {\n            I += pow(ks*dot(R, viewer), shi);\n        }\n        \n        return I*getColor(uv, hexSize);\n\t}\n    else\n    {\n        return vec3(0.);\n\t}\n}\n\nvec3 rayTrace(vec2 uv, float hexSize)\n{\n    vec3 result;\n    vec3 lightPos1 = float(Focal) * vec3(sin(iTime), -1./3., -abs(cos(iTime)));\n    result += phongIlluminate(uv, lightPos1, hexSize);\n    vec3 lightPos2 = vec3(sin(0.1*iTime), cos(0.1*iTime), -Focal);\n    result += phongIlluminate(uv, lightPos2, hexSize);\n    vec3 lightPos3 = vec3(-sin(0.1*iTime), -cos(0.1*iTime), -Focal);\n    result += phongIlluminate(uv, lightPos3, hexSize);\n    return result / 3.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Parameters\n    float hexSize = 0.05;\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n\tfloat scrWidth = iResolution.x/iResolution.y;\n\tfloat scrHeight = 1.;\n    uv.x *= scrWidth;\n    mousePos.x *= scrWidth;\n    uv -= vec2(scrWidth, scrHeight)/2.;\n    \n    vec3 col = rayTrace(uv, hexSize);\n\tfragColor = vec4(pow(col, vec3(0.6)), 1.0);\n\n    /*\n    mousePos -= vec2(scrWidth, scrHeight)/2.;\n    \n    ivec2 qr = roundHex(transformToHexBase(uv, hexSize));\n    int q = qr.x;\n    int r = qr.y;\n\tivec2 mouseqr = roundHex(transformToHexBase(mousePos, hexSize));\n    if (q == mouseqr.x && r == mouseqr.y)\n    {\n        fragColor = vec4(0.8, 0.8, 1., 1.);\n    }\n    else\n    {\n        // Output to screen\n        fragColor = vec4(abs(float(q)/6.),\n                         abs(float(r)/4.) ,\n                         0.0,\n                         1.0);\n    }*/\n}","name":"Image","description":"","type":"image"}]}