{"ver":"0.1","info":{"id":"NdBBWc","date":"1650494904","viewed":389,"name":"Temporal Upscaling","username":"DrDesten","description":"Temporal Upscaling using a Normal Distribution as weight\nAdditional options in 'Common'\n\nRegions:\n1. Temporally Upscaled Image\n2. Original Image\n3. Low-Resolution Input","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["upscaling","taau"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col;\n    \n    \n    col = texture(iChannel1, uv).rgb;\n    \n    #ifndef UPSCALED_IMAGE_ONLY\n    \n    if (uv.x > 0.5)  col = texture(iChannel0, uv).rgb;\n    if (uv.x > 0.75) col = texture(iChannel0, round( (uv * iResolution.xy) * RESOLUTION ) / (RESOLUTION * iResolution.xy)).rgb;\n    #ifdef TRUE_LR_OUTPUT\n    if (uv.x > 0.75) col = texture(iChannel2, uv).rgb;\n    #endif\n    \n    float lines = min(\n    abs(uv.x - 0.5),\n    abs(uv.x - 0.75));\n    \n    lines = 1. / (1.+lines);\n    lines = clamp(lines * 10000. - 9980., 0., 1.);\n    \n    col = mix(col, vec3(.9,.95,1.), lines);\n    \n    #endif\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 jitter() {\n    return (R2(float(iFrame % 1000)) * 1.2 - 0.1) / (iResolution.xy * RESOLUTION);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv  = floor( (uv * iResolution.xy) * RESOLUTION ) / (RESOLUTION * iResolution.xy);\n    uv += jitter();\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    fragColor = vec4(col, 1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Input Resolution\n#define RESOLUTION 0.0125\n// Blending Factor for hit pixels\n#define BLEND 0.75\n\n// Output the Actual Low-Res Input or a non-jittered version\n#define TRUE_LR_OUTPUT\n// Only Output Upscaled Image\n//#define UPSCALED_IMAGE_ONLY\n\n// Neighborhood Clipping Factor (Helps with videos)\n#define NEIGHBOR_CLIP 0.0\n\nconst float phi2 = 1.32471795724474602596;\nconst vec2  a    = vec2(1.0/phi2, 1.0/(phi2*phi2));\n\nvec2 R2(float n) {\n    return fract(a * n + 0.5);\n}\n\nfloat sqmag(vec2 x) {\n    return dot(x,x);\n}\n\nfloat maxc(vec3 v) {\n    return max(max(v.x,v.y),v.z);\n}\nfloat minc(vec3 v) {\n    return min(min(v.x,v.y),v.z);\n}\n\n\nstruct neighborhoodInfo {\n    vec3 maximum;\n    vec3 minimum;\n    vec3 mean;\n    \n    vec3 right;\n    vec3 left;\n    vec3 up;\n    vec3 upright;\n    vec3 upleft;\n    vec3 down;\n    vec3 downright;\n    vec3 downleft;\n};\n\nneighborhoodInfo getNeighborhoodInfo(sampler2D s, vec2 co, float scale) {\n    vec3 offs = vec3(scale / vec2(textureSize(s,0)), 0);\n    \n    vec3 r  = texture(s, co + offs.xz).rgb;\n    vec3 l  = texture(s, co - offs.xz).rgb;\n    vec3 u  = texture(s, co + offs.zy).rgb;\n    vec3 ur = texture(s, co + offs.xy).rgb;\n    vec3 ul = texture(s, co + offs.zy - offs.xz).rgb;\n    vec3 d  = texture(s, co - offs.zy).rgb;\n    vec3 dr = texture(s, co - offs.zy + offs.xz).rgb;\n    vec3 dl = texture(s, co - offs.xy).rgb;\n    \n    vec3 ma = max(max(max(max(max(max(max(u,ur),ul),d),dr),dl),r),l);\n    vec3 mi = min(min(min(min(min(min(min(u,ur),ul),d),dr),dl),r),l);\n    vec3 m  = (r+l+u+ur+ul+d+dr+dl) / 8.;\n    \n    return neighborhoodInfo(ma,mi,m,r,l,u,ur,ul,d,dr,dl);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec2 jitter() {\n    return (R2(float(iFrame % 1000)) * 1.2 - 0.1) / (iResolution.xy * RESOLUTION);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv  = fragCoord/iResolution.xy;\n    vec2 pix = 1./iResolution.xy;\n    \n    vec3  lastCol  = texture(iChannel1, uv).rgb;\n    float pixelAge = texture(iChannel1, uv).a;\n    \n    vec2 currJitter = jitter();\n    vec3 currCol    = texture(iChannel0, uv).rgb;\n    \n    vec2 lrCoord = floor( (uv * iResolution.xy) * RESOLUTION ) / (RESOLUTION * iResolution.xy) + currJitter;\n    \n    float pixelDistance = sqmag((lrCoord - uv) * iResolution.xy);\n    float confidence    = exp(-pixelDistance * RESOLUTION * 0.025 * exp2(2.*pixelAge));\n    \n    neighborhoodInfo ni = getNeighborhoodInfo(iChannel0, uv, 1./RESOLUTION);\n    vec3 diff = clamp(lastCol, ni.minimum, ni.maximum) - lastCol;\n    pixelAge /= length(diff) * NEIGHBOR_CLIP + 1.0;\n    \n    float finalBlend = BLEND + ((1.-BLEND) / (pixelAge + 1.));\n    vec3  col        = mix(lastCol, currCol, finalBlend * confidence);\n    \n    pixelAge += finalBlend * confidence;\n    \n    fragColor = vec4(col, pixelAge);\n}","name":"Buffer B","description":"","type":"buffer"}]}