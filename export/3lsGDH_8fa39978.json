{"ver":"0.1","info":{"id":"3lsGDH","date":"1556334914","viewed":349,"name":"581 Final Proj Part3","username":"zheng516","description":"Hand-drawn Sketch Effect by HLorenzi!","likes":13,"published":1,"flags":48,"usePreview":0,"tags":["handdrawnsketcheffectbyhlorenzi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//======================================\n//Modified the code from https://www.shadertoy.com/view/MsSGD1\n//======================================\n\n\n//===================\n//For debug Purpose\n//============================\n//keyboard constant\nconst int KEY_SPACE = 32;\nconst int KEY_A     = 65;\nconst int KEY_Z     = 90;\nconst int KEY_K     = 75;\nconst int KEY_M     = 77;\n\n\nfloat keyPres(int key)\n{\n\t//return texture( iChannel1, vec2(key, 0.5) ).x;\n    return texelFetch( iChannel1, ivec2(key,0), 0 ).x;\n}\n\n\n//===================================================\n\n\n// Hand-drawn Sketch Effect by HLorenzi!\n\n#define EDGE_WIDTH 0.05\n#define RAYMARCH_ITERATIONS 40\n#define SHADOW_ITERATIONS 50\n#define SHADOW_STEP 1.0\n#define SHADOW_SMOOTHNESS 256.0\n#define SHADOW_DARKNESS 0.75\n\n\n// storage register/texel addresses\nconst ivec2 txBallPosVel = ivec2(0,0);\nconst ivec2 txPaddleAPos  = ivec2(1,0);\nconst ivec2 txPaddleBPos  = ivec2(2,0);\n\n//const ivec2 txPoints     = ivec2(2,0);\nconst ivec2 txState      = ivec2(3,0);\nconst ivec2 txLastHit    = ivec2(4,0);\n\nconst float ballRadius = 0.035;\nconst float paddleSize = 0.30;\nconst float paddleWidth = 0.06;\n//const float paddlePosY  = -0.90;\n\n\n// Distance functions by iquilezles.org\nvoid fUnion(inout float d1, float d2) {d1 = min(d1,d2);}\nfloat pSphere(vec3 p, float s) {return length(p)-s;}\nfloat pRoundBox(vec3 p, vec3 b, float r) {return length(max(abs(p)-b,0.0))-r;}\n\nfloat distf(vec3 p)\n{\n    //get paddlePos from buffer\n    float paddleAPos = texelFetch( iChannel0, txPaddleAPos, 0 ).x;\n    float paddleBPos = texelFetch( iChannel0, txPaddleBPos, 0 ).x;\n    vec2  ballPos   = texelFetch( iChannel0, txBallPosVel, 0 ).xy;\n    \n //  paddleAPos +=0.1; \n    \n\tfloat d = 100000.0;\n    \n    fUnion(d, pSphere(p - vec3(0,-1.7,-3.)-vec3(ballPos.x, 0.0, ballPos.y) , 0.1));\n\t\n\t\n\tfUnion(d, pRoundBox(p-vec3(0,-2.,-3.0), vec3(2.,0.1,2.), 0.0));\n    \n    fUnion(d, pRoundBox(p-vec3(0,-1.8,-5.0), vec3(2.1,0.1,0.1), 0.0));\n    fUnion(d, pRoundBox(p-vec3(0,-1.8,-1.0), vec3(2.1,0.1,0.1), 0.0));\n    \n    \n    //paddle A on the left\n\tfUnion(d, pRoundBox(p-vec3(-2.,-1.8,-3.0-paddleAPos), vec3(0.1,0.1,2.0), 0.0));\n\t//paddle B on the right\n    fUnion(d, pRoundBox(p-vec3(2.,-1.8,-3.0-paddleBPos), vec3(0.1,0.1,2.0), 0.0));\n\t\n   \n    \n    /*\n    fUnion(d, pSphere(vec3(10,10,0) + p, 8.0));\n\tfUnion(d, pSphere(vec3(16,0,4) + p, 4.0));\n\tfUnion(d, pCapsule(p, vec3(10,10,12), vec3(15,15,-6.5), 1.5));\n\tfUnion(d, pCapsule(p, vec3(10,10,12), vec3(5,15,-6.5), 1.5));\n\tfUnion(d, pCapsule(p, vec3(10,10,12), vec3(10,5,-6.5), 1.5));\n\tfUnion(d, pTorus(vec3(15,-15,0) + p, vec2(6,2)));\n\tfUnion(d, pTorus2(vec3(10,-15,0) + p, vec2(6,2)));\n\tfUnion(d, pRoundBox(vec3(-10,10,-2) + p, vec3(1,1,9), 1.0));\n\tfUnion(d, pRoundBox(vec3(-10,10,-4) + p, vec3(0.5,6,0.5), 1.0));\n\tfUnion(d, pRoundBox(vec3(-10,10,2) + p, vec3(6,0.5,0.5), 1.0));\n\t*/\n\treturn d;\n}\n\n\nvec3 normal(vec3 p)\n{\n\tconst float eps = 0.01;\n\tfloat m;\n    vec3 n = vec3( (distf(vec3(p.x-eps,p.y,p.z)) - distf(vec3(p.x+eps,p.y,p.z))),\n                   (distf(vec3(p.x,p.y-eps,p.z)) - distf(vec3(p.x,p.y+eps,p.z))),\n                   (distf(vec3(p.x,p.y,p.z-eps)) - distf(vec3(p.x,p.y,p.z+eps)))\n\t\t\t\t );\n    return normalize(n);\n}\n\nvec4 raymarch(vec3 from, vec3 increment)\n{\n\tconst float maxDist = 200.0;\n\tconst float minDist = 0.001;\n\tconst int maxIter = RAYMARCH_ITERATIONS;\n\t\n\tfloat dist = 0.0;\n\t\n\tfloat lastDistEval = 1e10;\n\tfloat edge = 0.0;\n\t\n\tfor(int i = 0; i < maxIter; i++) {\n\t\tvec3 pos = (from + increment * dist);\n\t\tfloat distEval = distf(pos);\n\t\t\n\t\tif (lastDistEval < EDGE_WIDTH && distEval > lastDistEval + 0.001) {\n\t\t\tedge = 1.0;\n\t\t}\n\t\t\n\t\tif (distEval < minDist) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tdist += distEval;\n\t\tif (distEval < lastDistEval) lastDistEval = distEval;\n\t}\n\t\n\tfloat mat = 1.0;\n\tif (dist >= maxDist) mat = 0.0;\n\t\n\treturn vec4(dist, mat, edge, 0);\n}\n\nfloat shadow(vec3 from, vec3 increment)\n{\n\tconst float minDist = 1.0;\n\t\n\tfloat res = 1.0;\n\tfloat t = 1.0;\n\tfor(int i = 0; i < SHADOW_ITERATIONS; i++) {\n        float h = distf(from + increment * t);\n        if(h < minDist)\n            return 0.0;\n\t\t\n\t\tres = min(res, SHADOW_SMOOTHNESS * h / t);\n        t += SHADOW_STEP;\n    }\n    return res;\n}\n\nfloat rand(float x)\n{\n    return fract(sin(x) * 43758.5453);\n}\n\nfloat triangle(float x)\n{\n\treturn abs(1.0 - mod(abs(x), 2.0)) * 2.0 - 1.0;\n}\n\nfloat time;\nvec4 getPixel(vec2 p, vec3 from, vec3 increment, vec3 light)\n{\n\tvec4 c = raymarch(from, increment);\n\tvec3 hitPos = from + increment * c.x;\n\tvec3 normalDir = normal(hitPos);\n\t\n\t\n\tfloat diffuse = 1.0 + min(0.0, dot(normalDir, -light));\n\tfloat inshadow = 0.0;//(1.0 - shadow(hitPos, -light)) * SHADOW_DARKNESS;\n\t\n\tdiffuse = max(diffuse, inshadow);\n\t\n\tif (c.y == 0.0) diffuse = min(pow(length(p), 4.0) * 0.125,1.0);\n\t\n\t\n\tfloat xs = (rand(time * 6.6) * 0.1 + 0.9);\n\tfloat ys = (rand(time * 6.6) * 0.1 + 0.9);\n\tfloat hatching = max((clamp((sin(p.x * xs * (170.0 + rand(time) * 30.0) +\n\t\t\t\t\t\t\tp.y * ys * (110.0 + rand(time * 1.91) * 30.0)) * 0.5 + 0.5) -\n\t\t\t\t\t\t   \t\t(1.0 - diffuse), 0.0, 1.0)),\n\t\t\t\t\t\t (clamp((sin(p.x * xs * (-110.0 + rand(time * 4.74) * 30.0) +\n\t\t\t\t\t\t\tp.y * ys * (170.0 + rand(time * 3.91) * 30.0)) * 0.5 + 0.5) -\n\t\t\t\t\t\t   \t\t(1.0 - diffuse) - 0.4, 0.0, 1.0)));\n\t\n\tvec4 mCol = mix(vec4(1,0.9,0.8,1), vec4(1,0.9,0.8,1) * 0.5, hatching);\n\t\t\t\t\t\n\treturn mix(mCol,vec4(1,0.9,0.8,1) * 0.5,c.z);\n}\n\n\nvec3 CastRay( in vec2 sp, in vec3 origin, out vec3 camRight, out vec3 camUp ) // need the camRight vector in the hatching color function\n{\n    // Compute local camera vectors\n    vec3 refPoint = vec3(0.0, 0.4, 0.0);\n    vec3 camLook = normalize(refPoint - origin);\n    camRight = normalize(cross(camLook, vec3(0.0, 1.0, 0.0)));\n    camUp = normalize(cross(camRight, camLook));\n    \n    vec3 rayPoint = refPoint + sp.x * camRight + sp.y * camUp;\n    return normalize(rayPoint - origin);\n}\n\n/*\nfloat keyPres(int key)\n{\n\t//return texture( iChannel1, vec2(key, 0.5) ).x;\n    return texelFetch( iChannel1, ivec2(key,0), 0 ).x;\n}*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    //**load game status\n    //vec2  ballPos   = texelFetch( iChannel0, txBallPosVel, 0 ).xy;\n    //float paddlePos = texelFetch( iChannel0, txPaddlePos, 0 ).x;\n    //float points    = texelFetch( iChannel0, txPoints, 0 ).x;\n    float state     = texelFetch( iChannel0, txState, 0 ).x;\n    vec3  lastHit   = texelFetch( iChannel0, txLastHit, 0 ).xyz;\n   \n   \n    \n\ttime = floor(iTime * 16.0) / 16.0;\n\t// pixel position\n\t//vec2 q = fragCoord.xy / iResolution.xy;\n\t//vec2 p = -1.0+2.0*q;\n    //**\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n  \n\t//p.x *= -iResolution.x/iResolution.y;\n    \n    //rotate camera\n\tp += vec2(triangle(p.y * rand(time) * 4.0) * rand(time * 1.9) * 0.015,\n\t\t\ttriangle(p.x * rand(time * 3.4) * 4.0) * rand(time * 2.1) * 0.015);\n\tp += vec2(rand(p.x * 3.1 + p.y * 8.7) * 0.01,\n\t\t\t  rand(p.x * 1.1 + p.y * 6.7) * 0.01);\n\t\n\t// mouse\n    //vec2 mo = iMouse.xy/iResolution.xy;\n\tvec2 m = iMouse.xy / iResolution.xy;\n\tif (iMouse.x == 0.0 && iMouse.y == 0.0) {\n\t\tm = vec2( 0.06 + 1.67, 0.78);\t\n\t}\n\tm = -1.0 + 2.0 * m;\n\tm *= vec2(4.0,-0.75);\n\tm.y += 0.75;\n\n\t// camera position\n\tfloat dist = 5.0;\n\tvec3 ta = vec3(0,0,0);\n\tvec3 ro = vec3(cos(m.x) * cos(m.y) * dist, sin(m.x) * cos(m.y) * dist, sin(m.y) * dist);\n\t\n    //vec3 light = vec3(cos(m.x - 2.27) * 50.0, sin(m.x - 2.27) * 50.0, -20.0);\n    vec3 light = vec3(cos( 2.27) , sin( 2.27) , -20.0);\n    \n\t\n\t// camera direction\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 0.0, 1.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n    \n    \n\n\tfloat radius = 4.0;\n    float speed = 0.015625;\n    \n    vec3 rayOrigin = vec3(cos(iMouse.x * speed) * radius, -5.0 * ((iMouse.y / iResolution.y) - 0.8), sin(iMouse.x * speed) * radius);\n    //vec3 rayOrigin = vec3(cos(iTime * speed * 16.0 + 3.14) * radius, 1.0, sin(iTime * speed * 16.0 + 3.14) * radius);\n    vec3 camRight, camUp;\n    vec3 rayDirection = CastRay(p, rayOrigin, camRight, camUp);\n   \n    \n    \n\t// calculate color\n\tvec4 col = getPixel(p, rayOrigin, rayDirection, normalize(light));\n    //vec4 col = getPixel(p, ro, rd, normalize(light));\n\tfragColor = col;\n\t\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//keyboard constant\nconst int KEY_SPACE = 32;\nconst int KEY_A     = 65;\nconst int KEY_Z     = 90;\nconst int KEY_K     = 75;\nconst int KEY_M     = 77;\n\n// storage register/texel addresses\nconst ivec2 txBallPosVel = ivec2(0,0);\nconst ivec2 txPaddleAPos  = ivec2(1,0);\nconst ivec2 txPaddleBPos  = ivec2(2,0);\n//const ivec2 txPoints     = ivec2(2,0);\nconst ivec2 txState      = ivec2(3,0);\nconst ivec2 txLastHit    = ivec2(4,0);\n\nconst float ballRadius = 0.035;\nconst float paddleSize = 0.30;\nconst float paddleWidth = 0.06;\n\nconst float paddlePosY  = -0.90;\n\nconst float gameSpeed =  3.0;\nconst float inputSpeed = 2.0;\n\n//**utility functions============================\n\nfloat hash1( float n ) { return fract(sin(n)*138.5453123); }\n\n// intersect a disk sweept in a linear segment with a line/plane. \nfloat iPlane( in vec2 ro, in vec2 rd, float rad, vec3 pla )\n{\n    float a = dot( rd, pla.xy );\n    if( a>0.0 ) return -1.0;\n    float t = (rad - pla.z - dot(ro,pla.xy)) / a;\n    if( t>=1.0 ) t=-1.0;\n    return t;\n}\n\n// intersect a disk sweept in a linear segment with a box \nvec3 iBox( in vec2 ro, in vec2 rd, in float rad, in vec2 bce, in vec2 bwi ) \n{\n    vec2 m = 1.0/rd;\n    vec2 n = m*(ro - bce);\n    vec2 k = abs(m)*(bwi+rad);\n    vec2 t1 = -n - k;\n    vec2 t2 = -n + k;\n\tfloat tN = max( t1.x, t1.y );\n\tfloat tF = min( t2.x, t2.y );\n\tif( tN > tF || tF < 0.0) return vec3(-1.0);\n    if( tN>=1.0 ) return vec3(-1.0);\n\tvec2 nor = -sign(rd)*step(t1.yx,t1.xy);\n\treturn vec3( tN, nor );\n}\n\n//functions store game status to fragcolor================\nvec4 loadValue( in ivec2 re )\n{\n    return texelFetch( iChannel0, re, 0 );\n}\nvoid storeValue( in ivec2 re, in vec4 va, inout vec4 fragColor, in ivec2 p )\n{\n    fragColor = (p==re) ? va : fragColor;\n}\nvoid storeValue( in ivec4 re, in vec4 va, inout vec4 fragColor, in ivec2 p )\n{\n    fragColor = ( p.x>=re.x && p.y>=re.y && p.x<=re.z && p.y<=re.w ) ? va : fragColor;\n}\n\n\nfloat keyPres(int key)\n{\n\t//return texture( iChannel1, vec2(key, 0.5) ).x;\n    return texelFetch( iChannel1, ivec2(key,0), 0 ).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n      ivec2 ipx = ivec2(fragCoord-0.5);\n \n    \n     // don't compute gameplay outside of the data area\n    if( fragCoord.x > 14.0 || fragCoord.y>14.0 ) discard;\n   \n    \n    //**load game status==================================\n    vec4  balPosVel = loadValue( txBallPosVel );\n    float paddleAPos = loadValue( txPaddleAPos ).x;\n    float paddleBPos = loadValue( txPaddleBPos ).x;\n    \n    //float points    = loadValue( txPoints ).x;\n    float state     = loadValue( txState ).x;\n    vec3  lastHit   = loadValue( txLastHit ).xyz;        // paddle, brick, wall\n    \n    //**reset====================================================\n    if( iFrame==0 ) state = -1.0;\n\t\n    if( state < -0.5 )\n    {\n        state = 0.0;\n        balPosVel = vec4(0.0,ballRadius+paddleWidth*0.5+0.1, 1.2,2.4);\n        paddleAPos = 0.0;\n       \tpaddleBPos = 0.0;\n        //points = 0.0;\n        state = 0.0;\n        lastHit = vec3(-1.0);\n          \n\n    }\n    \n    \n    //**in game==========================================================\n    // game over (or won), wait for space key press to resume\n    if( state > 0.5 )\n    {\n        //float pressSpace = texelFetch( iChannel1, ivec2(KEY_SPACE,0.0), 0 ).x;\n        float pressSpace = keyPres(KEY_SPACE);\n        \n        \n        if( pressSpace>0.5 )\n        {\n            state = -1.0;\n        }\n    }\n    \n    // if game mode (not game over), play game\n    else if( state < 0.5 ) \n\t{\n\n        //-------------------\n        // paddle\n        //-------------------\n        float oldPaddleAPos = paddleAPos;\n        float oldPaddleBPos = paddleBPos;\n        \n        {\n            // move with keyboard\n           // float pressSpace = keyPres(KEY_SPACE);\n    \t\tfloat Aup = keyPres(KEY_A);\n    \t\tfloat Adn = keyPres(KEY_Z);\n    \t\tfloat Bup = keyPres(KEY_K);\n    \t\tfloat Bdn = keyPres(KEY_M);\n            \n            paddleAPos += 0.02*inputSpeed*(Aup - Adn);\n            //paddleAPos +=1.;\n            \n            paddleBPos += 0.02*inputSpeed*(Bup - Bdn);\n        \n        }\n        \n        //clamp paddle movement\n        paddleAPos = clamp( paddleAPos, -2.0+0.5*paddleSize+paddleWidth*0.5, 2.0-0.5*paddleSize-paddleWidth*0.5 );\n\t\tpaddleBPos = clamp( paddleBPos, -2.0+0.5*paddleSize+paddleWidth*0.5, 2.0-0.5*paddleSize-paddleWidth*0.5 );\n\n        float padAmoveTotal = sign( paddleAPos - oldPaddleAPos );\n\t\tfloat padBmoveTotal = sign( paddleBPos - oldPaddleBPos );\n\n        //-------------------\n        // ball\n\t\t//-------------------\n        float dis = 0.01*gameSpeed*(iTimeDelta*60.0);\n        \n        // do up to 3 sweep collision detections (usually 0 or 1 will happen only)\n        for( int j=0; j<3; j++ )\n        {\n            ivec3 oid = ivec3(-1);\n            vec2 nor;\n            float t = 1000.0;\n\n            // test walls\n            const vec3 pla1 = vec3( -5.0, 0.0,9.0 ); \n            //const vec3 pla1 = vec3( -0.0, 0.0,9.0 ); \n            const vec3 pla2 = vec3( 5.0, 0.0,9.0 ); \n            const vec3 pla3 = vec3( 0.0,-5.0,10.0 ); \n            const vec3 pla4 = vec3( 0.0, 5.0,9.0 ); \n            float t1 = iPlane( balPosVel.xy, dis*balPosVel.zw, ballRadius, pla1 ); if( t1>0.0         ) { t=t1; nor = normalize(pla1.xy); oid.x=1; }\n            float t2 = iPlane( balPosVel.xy, dis*balPosVel.zw, ballRadius, pla2 ); if( t2>0.0 && t2<t ) { t=t2; nor = normalize(pla2.xy); oid.x=2; }\n            float t3 = iPlane( balPosVel.xy, dis*balPosVel.zw, ballRadius, pla3 ); if( t3>0.0 && t3<t ) { t=t3; nor = normalize(pla3.xy); oid.x=3; }\n            float t4 = iPlane( balPosVel.xy, dis*balPosVel.zw, ballRadius, pla4 ); if( t4>0.0 && t3<t ) { t=t4; nor = normalize(pla4.xy); oid.x=4; }\n            \n            // test paddle\n            vec3  t5 = iBox( balPosVel.xy, dis*balPosVel.zw, ballRadius, vec2(paddlePosY,paddleAPos), vec2(paddleWidth*0.5,paddleSize*0.5) );\n            if( t5.x>0.0 && t5.x<t ) { t=t5.x; nor = t5.yz; oid.x=5;  }\n            vec3  t6 = iBox( balPosVel.xy, dis*balPosVel.zw, ballRadius, vec2(0.0,paddleBPos), vec2(paddleWidth*0.5,paddleSize*0.5) );\n            if( t6.x>0.0 && t6.x<t ) { t=t6.x; nor = t6.yz; oid.x=6;  }\n            \n         \n            // no collisions\n            if( oid.x<0 ) break;\n\n            \n            // bounce\n            balPosVel.xy += t*dis*balPosVel.zw;\n           dis *= 1.0-t;\n            \n            // did hit walls\n            if( oid.x<5 )\n            {\n                balPosVel.zw = reflect( balPosVel.zw, nor );\n                lastHit.z = iTime;\n            }\n            // did hit paddle\n            else if( oid.x<7 )\n            {\n                balPosVel.zw = reflect( balPosVel.zw, nor );\n                // borders bounce back\n                     if( balPosVel.x > (paddleAPos+paddleSize*0.5) ) balPosVel.z =  abs(balPosVel.z);\n                else if( balPosVel.x < (paddleAPos-paddleSize*0.5) ) balPosVel.z = -abs(balPosVel.z);\n                balPosVel.z += 0.37*padAmoveTotal;\n                balPosVel.z += 0.11*hash1( float(iFrame)*7.1 );\n                balPosVel.z = clamp( balPosVel.z, -0.9, 0.9 );\n                balPosVel.zw = (balPosVel.zw);\n                \n                // \n                lastHit.x = iTime;\n                lastHit.y = iTime;\n            }\n        }\n        \n      \tbalPosVel.xy += dis*balPosVel.zw;\n        \n        // detect miss\n        if( balPosVel.y<-10.0||balPosVel.y>10.0||balPosVel.x<-10.0||balPosVel.x>10.0 )\n        {\n            state = 1.0; // game over\n        }\n    }\n    \n  \n      \n    //**store game status=================================\n    fragColor = vec4(0.0,0.0,0.0,0.0);\n    \n  \n    storeValue( txBallPosVel,  vec4(balPosVel),             fragColor, ipx );\n    storeValue( txPaddleAPos,  vec4(paddleAPos,0.0,0.0,0.0), fragColor, ipx );\n    storeValue( txPaddleBPos,  vec4(paddleBPos,0.0,0.0,0.0), fragColor, ipx );\n    \n    //storeValue( txPoints,     vec4(points,0.0,0.0,0.0),    fragColor, ipx );\n    storeValue( txState,      vec4(state,0.0,0.0,0.0),     fragColor, ipx );\n    storeValue( txLastHit,    vec4(lastHit,0.0),           fragColor, ipx );\n  \n}","name":"Buffer A","description":"","type":"buffer"}]}