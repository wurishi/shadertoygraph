{"ver":"0.1","info":{"id":"MXXcWl","date":"1726811802","viewed":20,"name":"fork viqwy","username":"ARTS_syz","description":"developed","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["developed"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float Pi=3.14159265358979323846264338327950;\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)  \n{  \n    vec3 col = vec3(1.0);  \n    vec2 uv = fragCoord / iResolution.xy - 0.5; \n    uv.y-=0.07;\n    uv.x *= iResolution.x / iResolution.y;  \n  \n    // 圆形和椭圆  \n    float circle = smoothstep(0.1,0.101, pow(uv.x, 2.0) + pow(uv.y, 2.0));  \n    float ellipse = smoothstep(0.0, 0.005, pow(uv.x / 5.0, 2.0) + pow(uv.y + 0.47, 2.0));  \n  \n    // 正弦波  \n    bool isInsideSineL1 = uv.y >= sin(5.0 * (uv.x + iTime*0.8) + 0.5) / 8.0 + 0.1975 && uv.y <= sin(5.0 * (uv.x + iTime*0.8) + 0.5) / 8.0 + 0.2025;  \n    bool isInsideSineL2 = uv.y >= sin(3.0 * (uv.x + iTime*1.1) + 0.5) / 5.0 + 0.0975 && uv.y <= sin(3.0 * (uv.x + iTime*1.1) + 0.5) / 5.0 + 0.1025;  \n    bool isInsideSineR1 = uv.y >= sin(5.0 * (uv.x + iTime*0.9) + 0.5) / 8.0 - 0.2025 && uv.y <= sin(5.0 * (uv.x + iTime*0.9) + 0.5) / 8.0 - 0.1975;  \n    bool isInsideSineR2 = uv.y >= sin(3.0 * (uv.x + iTime*1.2) + 0.5) / 5.0 - 0.1025 && uv.y <= sin(3.0 * (uv.x + iTime*1.2) + 0.5) / 5.0 - 0.0975;\n    \n    // 调制颜色（考虑圆形和椭圆）  \n    vec3 modulatedColor = col * circle * ellipse;  \n  \n    // 设置 fragColor  \n    if (isInsideSineL1 || isInsideSineL2)  \n    {  \n        fragColor = vec4(0.0, 0.0, 0.0, 1.0); // 正弦波L1,2为黑色  \n    }  \n    else if (isInsideSineR1 || isInsideSineR2)  \n    {  \n        fragColor = vec4(1.0, 1.0, 1.0, 1.0); // 正弦波R1,2为白色  \n    }  \n    else \n    {  \n        fragColor = vec4(modulatedColor, 1.0); // 其他区域为圆形和椭圆的调制颜色\n                \n        vec3 backgroundColor;    //背景旋转处理\n        if (mod(iTime, 4.*Pi) > 2.*Pi && pow(uv.x, 2.0) + pow(uv.y, 2.0)>0.1)  \n        {  \n            backgroundColor = uv.x < 0.0 ? vec3(0.0) : vec3(1.0); \n            vec3 ellipseColor = 1.0 - backgroundColor;\n            vec3 finalColor = mix(backgroundColor, ellipseColor, ellipse);\n            fragColor = vec4(finalColor, 1.0);  \n        }\n        else if (mod(iTime, 4.*Pi) < 2.*Pi && pow(uv.x, 2.0) + pow(uv.y, 2.0)>0.1)\n        {  \n            backgroundColor = uv.x < 0.0 ? vec3(1.0) : vec3(0.0); \n            vec3 ellipseColor = 1.0 - backgroundColor;\n            vec3 finalColor = mix(backgroundColor, ellipseColor, ellipse);\n            fragColor = vec4(finalColor, 1.0);  \n        }  \n        \n        if (uv.y < uv.x * tan(iTime-Pi*0.5)*4.&& pow(uv.x, 2.0) + pow(uv.y, 2.0)<0.1)    //圆形旋转处理\n        {  \n            fragColor = vec4(1.0 - fragColor.rgb, fragColor.a);  \n        }\n       \n    }\n    fragColor = vec4(0.45 + fragColor.rgb, fragColor.a);\n}\n\n","name":"Image","description":"","type":"image"}]}