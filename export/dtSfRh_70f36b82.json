{"ver":"0.1","info":{"id":"dtSfRh","date":"1693750205","viewed":257,"name":"Shuffle gradient - random walk 3","username":"FabriceNeyret2","description":"not a black dots random walk: color dots are moving, sliding puzzle-like :-)\ninspiration: https://twitter.com/junkiyoshi/status/1697571241513910691\nmissing: soft swap of disc.\nadapted from  cellular automata random walk  https://shadertoy.com/view/dtsBWs\n","likes":18,"published":3,"flags":32,"usePreview":0,"tags":["short","cellularautomata","reproduction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// variant of https://shadertoy.com/view/dtsBWs\n\nM // O = sqrt( T(u)); \n     u*=C/R; O = sqrt( T(u) * smoothstep(1.5*(C/R).y,0.,length(fract(u)-.5)-.25)); \n //  if (u.y<5.) O = vec4( u.x/R.x < textureLod(iChannel0,vec2(.5),99.).w ); // shows propotion of dots\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define H(u)   fract(1e4*sin(dot(u+iTime,vec2(71.3,-93.7))))          // random\n#define D(u)   ( D = iFrame%2<1 ? e : e.yx, H(mod(u,C)[1-(iFrame%2)]+d-d)<.5 ? -D : D ) // random move\n#define hue(v) ( .6 + .6 * cos( 6.3*(v)  + vec3(0,23,21)  ) )         // hue\n //#define mod(u,C) vec2(ivec2(u+C)%ivec2(C))\n\nM\n    O = T(u);\n    vec2  e = vec2(1,0), d,D; \n    if (iFrame<1) { O = H(u) < .05 ? O-O : vec4( hue((u/C).x), 1 ) ; return; } // .w=0: random seeds .rgb: color gradient\n    if (iFrame<2) { (T(u+e)+T(u+e.yx)+T(u+1.)).w < 3.? O.w=1. :0.; return; } // neighbors forbidden\n    if (iFrame%6>1) return;                                           // slow down\n    O.w < 1. ? O = T(u+D(u)) : O;                                     // pull color\n    for (int k=1; k<9; k+=2 )                                         // check neiborhood\n        d = vec2(k%3,k/3%3) - 1.,                                     // local neighbor direction\n        D(u+d)==d && T(u+d).w < 1. ? O-=O : O;                        // comming here â†’ pull black\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define R iResolution.xy//\n#define C floor(50.*R/R.y)//\n#define T(U) texelFetch( iChannel0, ivec2(U+C) % ivec2(C), 0 )       //\n#define M void mainImage( out vec4 O, vec2 u ) {\n","name":"Common","description":"","type":"common"}]}