{"ver":"0.1","info":{"id":"4c2fzD","date":"1724733637","viewed":5,"name":"方体拆分 learn (Split the cube)","username":"shadertoyjiang","description":"Study from Elsio's work: (Split the cube)\nhttps://www.shadertoy.com/view/lf23DG\n\n颜色不好搞，不过我主要在学习算法","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["cube","split"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2024年8月27日\n// 方体拆分学习\n// Learn from:Elsio's Split the cube - https://www.shadertoy.com/view/lf23DG\n\nvec3 dir, rd, id3;\n\n\nvec3 hash33(vec3 p3)\n{// form Dave_Hoskins:  www.shadertoy.com/view/4djSRW\n        p3 = fract(p3*vec3(.1031, .1030,.0973));\n        p3 += dot(p3, p3.yxz+33.33);\n        return fract((p3.xxy+p3.yxx)*p3.zyx);\n}\n\n// Code Collation:\n// https://beautifier.io/\nfloat splitCube(vec3 p) {\n        vec3 mn = vec3(-20), md = vec3(0), mx = vec3(20);\n        vec3 mxi = mx, mni = mn;\n        vec3 dlt, cnt, edg, boxm, f3;\n        float dcub, dbox, f, i, N = 3.;\n        id3 = step(md, p);\n        for (i = 0.; i < N; i++) {\n                id3 = id3 * 2. + step(md, p);\n                mx = mix(md, mx, step(md, p));\n                mn = mix(mn, md, step(md, p));\n                f3 = hash33(mx + mn);\n                f3 = .2 + .6 * f3;\n                md = mix(mn, mx, f3);\n        }\n        edg = step(-.01, mni - mn) + step(-.01, mx - mxi);\n        cnt = (mx + mn) * .5;\n        cnt *= 1. + edg * (1.5 + hash33(id3)) * smoothstep(-.5, .5, sin(iTime));\n        dcub = length(max(abs(p - cnt) - ((mx - mn) * .5 - 1.), 0.)) - 1.;\n        boxm = abs(p - mix(mn, mx, step(0., rd))) / abs(rd);\n        dbox = min(boxm.x, min(boxm.y, boxm.z));\n        return min(dcub, dbox + .01);\n}\n\n\n/*float splitCube(vec3 p)\n{\n        vec3 mn = vec3(-20), md = vec3(0),  mx = vec3(20);\n        vec3 mxi = mx, mni = mn;\n        vec3 dlt, cnt, edg, boxm,f3;\n        float dcub, dbox, f, i, N=3.;\n        \n        // 包围盒\n        //float dk = length(max(abs(p)-mx*2. -.3,0.)); if(dk>0.)return dk+.1; \n        \n        // 标识\n        id3 = step(md, p);\n        \n        // for循环：方体拆分\n        // 输入:mn,md,mx\n        // 输出：mn,mx\n        // mn(min)方体各下边界，mx(max)方体上边界\n        for(i=0.;i<N;i++)\n        {\n                // 标识符，用于着色。 也可以在循环后用 id3.z*N*N+id3.y*N+id3.x 来表示 \n                id3 = id3*2.+step(md, p);               \n                \n                // 新边界\n                mx = mix(md, mx, step(md, p));\n                mn = mix(mn, md, step(md, p));\n                \n                // 中心是唯一的。两倍中心也是唯一的 mx+mn = cnt*2. = (mx+mn)*.5*2.\n                f3 = hash33(mx+mn); \n                \n                // 防止分界面太过靠近边界，导致过薄过小的方块\n                f3 = .2 + .6*f3;\n                \n                // 下一分割线位置\n                md = mix(mn, mx, f3);                 \n        }               \n                \n        // 选出表层小方块：在最表层的小块， edg 中有一到三个分量的值为“1” ，否则全为“0”。\n        edg = step(-.01,mni-mn)+step(-.01,mx-mxi);\n        \n        // 小方块中心\n        cnt = (mx+mn)*.5;\n        \n        // 将最外层小方体向外扩散，其它不动\n        // 若是表层小块，则它的中心在相关方向上乘以一个大于1的系数，表示散开。若不是表面小块，则系数为1，表示中心位置不变\n        // 仅最外层弹开的好处是代码简单的同时，小方块不会重叠，有聚有散还好看\n        cnt *=  1. + edg * (1.5+hash33(id3)) * smoothstep(-.5, .5, sin(iTime));\n        \n        // 画出小块\n        dcub = length(max(abs(p-cnt)- ((mx-mn)*.5-1.), 0.))-1.;    \n        \n        // 包围盒：\n        // 这句不需要外部变量，缺点是不能一次直达边界，运行慢\n        // 有时需要步数过多，速度慢，添加外部包围盒可以有效的优化\n        //boxm = abs(abs(mx-cnt)-abs(p - cnt));\n        \n        // 这句一次直达边界，缺点是要同步处理射线 rd.\n        boxm = abs(p - mix(mn, mx, step(0., rd)))/abs(rd);\n        \n        // 到边界距离（小包围盒）\n        dbox = min(boxm.x, min(boxm.y, boxm.z));                                             \n        \n        // 返回到方块和到边界的最小距离， 其中边界距离 dbox 加 .01 用于防止边界被识别成表面。\n        return min(dcub, dbox+.01);\n}*/\n\n\nfloat map(vec3 p)\n{\n        float t = iTime;\n        mat2 rot = mat2(cos(t),-sin(t),sin(t),cos(t));\n        rd = dir;\n        p.yz *=rot;rd.yz *=rot;\n        p.xz *=rot;rd.xz *=rot;\n        return splitCube(p);\n}\n\n\nvoid mainImage(out vec4 O, vec2 v)\n{\n        vec4 bk=O = vec4(.7,.8,1,1)*.7;\n        vec2 R = iResolution.xy,\n             u = 1. * (v+v+.1 - R) / R.y,      // 实际坐标\n             m = 1. * (iMouse.xy*2. - R) / R.y;// 实际鼠标\n        vec3 o = vec3(0, 0, -80),               // 眼睛坐标\n             r = normalize(vec3(u, 2)),        // 射线\n             e = vec3(0, 1e-3, 0),             // 微距\n             p,n,                                // 法向量\n             s = normalize(vec3(-1,2,-3));     // 太阳\n        dir=r;\n        float d,t,f,g,c;\n        for(int i;i<1256 && t < 220.;i++)\n        {\n                p = o + r * t;\n                d = map(p);\n                if(d<.01)\n                {\n                        O *= 0.;\n                        n = normalize(vec3(map(p+e.yxx),map(p+e),map(p+e.xxy))-d);\n                        f = .5 + .5 * dot(n, s);\n                        g = max(dot(n,s),0.);\n                        c = 1. + pow(f, 200.)-f*.3; // 665.352.6.542.9958.8.63\n                        O += c*hash33(id3).rgbb;\n                        O = mix(bk,O,   //smoothstep(-20.,20., -(t+o.z))       );  //    \n                                             smoothstep(-20.,20.,exp(-.1*(t+o.z - 20. ))));\n                        break;\n                }\n                t += d ;\n        }\n}\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}