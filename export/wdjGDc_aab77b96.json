{"ver":"0.1","info":{"id":"wdjGDc","date":"1550191316","viewed":461,"name":"SDF Reflections","username":"Sciman101","description":"First attempts at sdf rendering stuff. Most of the code is more or less copied from yx and other tutorials.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 color = vec3(.1,.4,.6);\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n//Thanks iq\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nint mat;\n\n//Main scene functon\nfloat scene(vec3 p) {\n\n   //float box = sdBox(p-vec3(.75,0,0),vec3(.5)) - .5;\n   float sphere = sdSphere(p+vec3(0,0,0),2.);\n    \n   p.y = abs(p.y);\n   sphere = opSmoothUnion(sphere,sdSphere(p+vec3(0,-1.5+sin(iTime),0),1.),.5);\n    \n   p = mod(p,10.) - 5.;\n   float box = sdSphere(p,1.5);\n    \n   float d = min(sphere,box);\n    \n    if (d == sphere) {\n        mat = 0;\n    }else{\n        mat = 1;\n    }\n    \n   return d;\n    \n}\n\n//Shadow calculation function\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    for( float t=mint; t < maxt; )\n    {\n        float h = scene(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        t += h;\n    }\n    return 1.0;\n}\n\n//Thanks yx\nvec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\nvoid cameraspin(inout vec3 p)\n{\n    p.yz = rotate(p.yz, -.3);\n    p.xz = rotate(p.xz, iTime*.5);\n}\n\nconst vec3 lDir = vec3(1,1,1);\n\nvec3 trace(vec3 cam, vec3 dir) {\n    //Perform raytrace\n    float t = 0.;\n    float k = 0.;\n    vec3 h;\n    for(int i=0;i<100;++i) {\n        k=scene(cam+dir*t);\n        t+=k;\n        if(k<.001)\n        {\n            h = cam+dir*t;\n            vec2 o=vec2(.02,0);\n            vec3 n= normalize(vec3(\n                scene(h+o.xyy)-scene(h-o.xyy),\n                scene(h+o.yxy)-scene(h-o.yxy),\n                scene(h+o.yyx)-scene(h-o.yyx)\n            ));\n\n            //Light comes from camera\n            float light = dot(n,normalize(lDir))*.5+.5;\n            \n            //Add specular reflections\n            light += pow(light,64.);\n            \n            float shad = shadow(h,lDir,0.,1000.);\n            \n            if (mat == 0) {\n                \n                //Reflection\n                //Change ray origin and direction so that it now points off the suface of the shape\n                cam = h;\n                dir = reflect(dir,n);\n                \n                //The distance MUST be greater than the minimum amount, or else it will just \n                t = 0.002;\n                \n            }else if (mat == 1){ \n                return n*light;\n            }\n        }\n    }\n    return vec3(0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = fragCoord/iResolution.xy - .5;\n\n    //Multiply by aspect\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //Define camera position and direction\n    vec3 cam = vec3(0,0,10);\n    vec3 dir = normalize(vec3(uv,-1));\n    \n    cameraspin(cam);\n    cameraspin(dir);\n    \n    fragColor.rgb = trace(cam,dir);\n    \n}","name":"Image","description":"","type":"image"}]}