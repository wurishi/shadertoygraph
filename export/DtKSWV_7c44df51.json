{"ver":"0.1","info":{"id":"DtKSWV","date":"1732031259","viewed":31,"name":"one more uv arrow on vector","username":"bythesword","description":"one uv arrow","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"mtKXzt","parentname":"one uv arrow on vector"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// copy form https://www.shadertoy.com/view/wsVfzc\n#define GRID_SCALE 1.\n#define CELL_SCALE 11.0\n#define VECTOR_SCALE 1.15\n#define pi 3.14159\n\nfloat thc(float a, float b) {\n    return tanh(a * cos(b)) / tanh(a);\n}\nfloat sdEquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// direction and normal for x and y (-1 to 1)\n// exp:xy1,xy2,xy3\nvec2 xy1=vec2(1.,1.);\nvec2 xy2=vec2(-1.,1.);\nvec2 xy3=vec2(-1,-1.);\nvec2 xy4=vec2(1,-1.);\nvec3 CM=vec3(1.0,0.50,0.0);\n\n\n\nfloat sdIsosceles(in vec2 p, in float b, in float h) {\n    p.x = abs(p.x);\n    float q = clamp((b - p.x + p.y) / (b + h), 0.0, 1.0);\n    vec2 re = vec2(p.x - b + b * q, p.y - h * q);\n    vec2 be = vec2(p.x - b * min(p.x / b, 1.0), p.y);\n    return sqrt(min(dot(re, re), dot(be, be))) * sign(p.x + (p.y - h) * b / h * sign(p.y));\n}\nfloat arrow(vec2 uv ) {\n    float h = 0.1 + 0.4 * thc(4.,2.  );\n    float d1 = sdEquilateralTriangle(uv-vec2(0.,0.25 - h));\n    float s1 = step(d1, -0.5);\n\n    float d2 = sdBox(uv - vec2(0.,-h), vec2(0.05,0.2));\n    float s2 = step(d2, 0.);\n    \n    return max(s1, s2);\n}\n\nfloat sdVerticalLine(in vec2 p, in float h) {\n    return length(vec2(p.x, p.y - h * clamp(p.y / h, 0.0, 1.0)));\n}\n\nfloat sdVectorArrow(in vec2 p, in vec2 v) {\n    float m = length(v);//长度\n    vec2 n = v / m;//sdf\n    p = vec2(dot(p, n.yx * vec2(1.0, -1.0)), dot(p, n));//方向判断，n控制长度\n   return   arrow(p  )  ;//shape \n   //return min(sdVerticalLine(p, m), sdIsosceles(p - vec2(0.0, m), 0.1, 0.15));//细线\n}\n\nvec3 CMC(vec2 uv,vec3 CM){\n    float step=12.0;\n    float perStep=step/4.0;\n    float stair=0.25;\n    float w1 = (1.0 - uv.x);\n    float w2 = (uv.x - uv.y);\n    float w3 = uv.y;\n    vec3 cmColor;\n      int i=0;\n    int j= int (perStep);\n    float vv = w1*CM[0] + w2*CM[1] + w3*CM[2];\n     if( vv <= 0.25 && vv>=0.0) {\n        for(i=0;i<j;i++){\n            if( vv >= float(i) *stair/perStep &&vv < (float(i)+1.0)*stair/perStep)\n            {\n                cmColor = vec3(0.0,  float(i)/perStep,  1.0);\n                break;\n            }\n        }\n    }   \n    else if ( vv > 0.25 && vv <= 0.5) {\n        for(i=0;i<j;i++){\n            if( vv >= 0.25+float(i) *stair/perStep &&vv <0.25+ (float(i)+1.0)*stair/perStep)\n            {\n                cmColor = vec3(0.0, 1.0 , 1.0-float(i)/perStep);\n                break;\n            }\n        }\n    }\n    else if ( vv > 0.5 && vv <= 0.75) {\n        for(i=0;i<j;i++){\n            if( vv >= 0.5+float(i) *stair/perStep &&vv <0.5+ (float(i)+1.0)*stair/perStep)\n            {\n                cmColor = vec3( float(i)/perStep, 1.0, 0.0);\n                break;\n            }\n        }\n    }\n    else if ( vv > 0.75 && vv <= 1.0) {\n        for(i=0;i<j;i++){\n            if( vv >= 0.75+float(i) *stair/perStep &&vv <0.75+ (float(i)+1.0)*stair/perStep)\n            {\n                cmColor = vec3( 1.0, 1.-float(i)/perStep, 0.0);\n                break;\n            }\n        }\n    }  \n    else{  \n        cmColor = vec3( 1.0 ,1.0, 1.); \n    }  \n    \n    return cmColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    \n    //vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;//0，0\n  \n    //vec2 uv = (fragCoord - 1. * iResolution.xy) / iResolution.y;//1.0,1.0\n    //vec2 uv = (fragCoord - 1.0 * iResolution.y) / iResolution.y; //0.5，1\n    \n    //vec2 uv;\n    //uv.x= (fragCoord.x - 0.50 * iResolution.x) / iResolution.y; \n    //uv.y= (fragCoord.x - 0.5 * iResolution.y) / iResolution.y; \n    \n    \n    vec2 uv4= (fragCoord - 0.5 * iResolution.xy)/min(iResolution.x, iResolution.y);\n    //vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.xy;//iResolution.xy，xy方向变形；iResolution.y，y比例不变；iResolution.x，X比例不变\n    //vector 4 左上角\n    uv4.x= uv4.x +0.5;                  //x复位到0.0 +0.5\n    uv4.y= uv4.y-0.5;                //y复位到 1.0  -0.5\n    float vector4 = sdVectorArrow(uv4, xy4*.13);\n    \n    //vector 3 右上角\n    vec2 uv3= (fragCoord - 0.5 * iResolution.xy)/min(iResolution.x, iResolution.y);\n    uv3.x= uv3.x -0.5;                  //x复位到 1.0\n    uv3.y= uv3.y-0.5;                //y复位到   1.0  \n    float vector3 = sdVectorArrow(uv3, xy3*.13);\n    \n    \n    //vector 2 右下角\n    vec2 uv2= (fragCoord - 0.5 * iResolution.xy)/min(iResolution.x, iResolution.y);\n    uv2.x= uv2.x -0.5;                  //x复位到 1.0\n    uv2.y= uv2.y+0.5;                //y复位到   0.0  \n    float vector2 = sdVectorArrow(uv2, xy2*.13);\n    \n    //vector 1 左下角\n    vec2 uv1= (fragCoord - 0.5 * iResolution.xy)/min(iResolution.x, iResolution.y);\n    uv1.x= uv1.x + 0.5;                  //x复位到 1.0\n    uv1.y= uv1.y + 0.5;                //y复位到   0.0  \n    float vector1 = sdVectorArrow(uv1, xy1*.13);\n   \n    float unit = 2. /iResolution.y / GRID_SCALE;//控制线轮廓粗细，模糊度,锐度\n    \n    // here is xy3 or othre vec2() \n    \n   \n    vec3 mixcolor = vec3(0.,0.,0.);//纯色\n    vec3 color = vec3(1.,0.,0.);//纯色\n    \n    \n    mixcolor = mix(mixcolor, color, vector1);//*0.5 暗，*1.0 亮\n    mixcolor = mix(mixcolor, color, vector2);//*0.5 暗，*1.0 亮\n    mixcolor = mix(mixcolor, color, vector3);//*0.5 暗，*1.0 亮\n    mixcolor = mix(mixcolor, color, vector4);//*0.5 暗，*1.0 亮\n     \n    //fragColor = vec4(smoothstep(0.0,unit,  vector));//白箭头 \n    //fragColor = vec4(smoothstep(unit,0.0,  vector));//黑箭头 \n\n    fragColor=vec4(mixcolor,1.0);\n}","name":"Image","description":"","type":"image"}]}