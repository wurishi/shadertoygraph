{"ver":"0.1","info":{"id":"NtVXzV","date":"1641070014","viewed":197,"name":"Voxel Staircase","username":"jt","description":"Working on a voxel-building, starting with a simple staircase (see source-code for previous versions & credits).\n","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","raycasting","voxel","dda","staircase","stairs","textured","walls","subobjects"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/NtVXzV Voxel Staircase 2022-1-1 by Jakob Thomsen\n// Previous versions:\n//     https://www.shadertoy.com/view/NlVXzG Voxels Containing Walls & Stairs\n//     https://www.shadertoy.com/view/flVXDw Voxels Containing Walls\n//     https://www.shadertoy.com/view/NstSR8 Cast Voxels March Sub-Objects\n// efficient voxel tracing based on https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting by fb39ca4\n// (with loop optimization by kzy) which implements DDA based on http://lodev.org/cgtutor/raycasting.html\n// Basic functionality (intersection & raymarching primitives) based on iq's https://iquilezles.org/articles/distfunctions\n\n// tags: 3d, raymarching, raycasting, voxel, dda, textured, subobjects, walls, stairs, staircase\n\n#define MAX_DIST 1000.0\n\n// https://iquilezles.org/articles/intersectors\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize )\n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0);\n    return vec2( tN, tF );\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere(vec3 p, float d)\n{\n    return length(p) - d;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat box2d(vec2 p)\n{\n    vec2 q = abs(p) - vec2(1.0);\n    return min(max(q.x,q.y), float(0.0)) + length(max(q, float(0.0)));\n}\n\n// https://www.shadertoy.com/view/NddGWs 2d Infinite Stairs SDF (my stairs function, improved by iq)\nfloat infinite_stairs_even2d(vec2 p, float n)\n{\n    p *= n; // scale by number of stairs\n    p = vec2(p.x+p.y,p.x-p.y)/float(4.0);\n    p = fract(p.x) + vec2(p.y,-p.y);\n    p = float(2.0)*p-float(1.0);\n    return box2d(p) / n;\n}\n\nfloat infinite_stairs_even(vec3 p, float n)\n{\n    return infinite_stairs_even2d(vec2(p.y, p.z), n);\n}\n\nfloat finite_stairs_even(vec3 p, float n)\n{\n    return max(infinite_stairs_even(p + 0.5 / n, n * 2.0), sdBox(p, vec3(1.0) / 2.0));\n    //return max(infinite_stairs_even(p + 0.5 / n - iTime * 0.1, n * 2.0), sdBox(p, vec3(1.0) / 2.0));\n}\n\n#define halfwallsize (1.0/32.0)\n\nfloat sdMixed(vec3 p, bvec3 walls0, bvec3 walls1, uint idx)\n{\n    float d = MAX_DIST;\n    if(walls0.x) d = min(d, sdBox(p + vec3(0.5 - halfwallsize, 0.0, 0.0), vec3(halfwallsize, 0.5, 0.5)));\n    if(walls0.y) d = min(d, sdBox(p + vec3(0.0, 0.5 - halfwallsize, 0.0), vec3(0.5, halfwallsize, 0.5)));\n    if(walls0.z) d = min(d, sdBox(p + vec3(0.0, 0.0, 0.5 - halfwallsize), vec3(0.5, 0.5, halfwallsize)));\n    if(walls1.x) d = min(d, sdBox(p - vec3(0.5 - halfwallsize, 0.0, 0.0), vec3(halfwallsize, 0.5, 0.5)));\n    if(walls1.y) d = min(d, sdBox(p - vec3(0.0, 0.5 - halfwallsize, 0.0), vec3(0.5, halfwallsize, 0.5)));\n    if(walls1.z) d = min(d, sdBox(p - vec3(0.0, 0.0, 0.5 - halfwallsize), vec3(0.5, 0.5, halfwallsize)));\n    //if(idx == 1u) d = min(d, sdBox(p, vec3(0.25)));\n    if(idx == 1u) d = min(d, finite_stairs_even(p.xyz, 8.0));\n    if(idx == 2u) d = min(d, finite_stairs_even(p.yxz, 8.0));\n    if(idx == 3u) d = min(d, finite_stairs_even(p.xyz * vec3(1,1,-1), 8.0));\n    if(idx == 4u) d = min(d, finite_stairs_even(p.yxz * vec3(1,1,-1), 8.0));\n    return d;\n}\n\n#define halfboundsize 6\n\n#define PI 3.1415926\n\nfloat checker(vec3 p)\n{\n    //return step(0.5, length(1.0 - abs(2.0 * fract(p) - 1.0))); // dots\n    return step(0.0, sin(PI * p.x + PI/2.0)*sin(PI *p.y + PI/2.0)*sin(PI *p.z + PI/2.0));\n    //return step(0.0, sin(p.x)*sin(p.y)*sin(p.z));\n}\n\nfloat blob(vec3 p)\n{\n    return step(0.5, length(fract(p)-0.5));\n}\n\nmat2 rotate(float t)\n{\n    return mat2(vec2(cos(t), sin(t)), vec2(-sin(t), cos(t)));\n}\n\n#define EPSILON 0.001\n\n// raymarch subobject\nfloat march(vec3 ro, vec3 rd, float tmin, float tmax, bvec3 walls0, bvec3 walls1, uint idx)\n{\n    for(float t = tmin; t < tmax;)\n    {\n        float h = sdMixed(ro + rd * t, walls0, walls1, idx);\n        if(h < EPSILON)\n            return t;\n        t += h;\n    }\n    return MAX_DIST;\n}\n\n// based on https://iquilezles.org/articles/normalsSDF tetrahedron normals\nvec3 normal(vec3 p, bvec3 walls0, bvec3 walls1, uint idx)\n{\n    const float h = EPSILON;\n    const vec2 k = vec2(1,-1);\n    return normalize(k.xyy * sdMixed(p + k.xyy * h, walls0, walls1, idx) +\n                     k.yyx * sdMixed(p + k.yyx * h, walls0, walls1, idx) +\n                     k.yxy * sdMixed(p + k.yxy * h, walls0, walls1, idx) +\n                     k.xxx * sdMixed(p + k.xxx * h, walls0, walls1, idx));\n}\n\nvec4 process_subobject(vec3 ro, vec3 rd, float tmin, float tmax, bvec3 walls0, bvec3 walls1, uint idx)\n{\n    float d = march(ro, rd, tmin, tmax, walls0, walls1, idx);\n    vec3 n = normal(ro + rd * d, walls0, walls1, idx);\n    return vec4(n, d);\n}\n\n//#define boundsize (uint(2 * halfboundsize))\n//\n//bvec3 getWall(uvec3 cell)\n//{\n//    bvec3 grid[boundsize * boundsize * boundsize];\n//    uint i = (cell.x % boundsize) + boundsize * ((cell.y % boundsize) + boundsize * (cell.z % boundsize));\n//    return grid[i];\n//}\n\nbvec3 getWall(ivec3 cell)\n{\n    //vec3 threshold = vec3(0.1, 0.1, 0.5);\n    //return lessThan(vec3(texelFetch(iChannel0, cell + 0 + halfboundsize, 0)), threshold); // use with random RGB volume\n    uvec3 code = uvec3(0, 0, 0); // WORKAROUND: use uvec3 min/max as replacement for missing bvec and/or\n    // ground plate\n    if(cell.z == -(halfboundsize-1)) code = max(code, uvec3(0, 0, 1));\n    // staircase-platforms\n    if(cell.x == -1 && cell.y == -1) code = max(code, uvec3(0, 0, 1));\n    if(cell.x == +1 && cell.y == -1) code = max(code, uvec3(0, 0, 1));\n    if(cell.x == +1 && cell.y == +1) code = max(code, uvec3(0, 0, 1));\n    if(cell.x == -1 && cell.y == +1) code = max(code, uvec3(0, 0, 1));\n    // elevator\n    if(cell.x == 0 && cell.y == 0) code = max(code, uvec3(1, 1, 0));\n    if(cell.x == 1 && cell.y == 0) code = max(code, uvec3(1, 0, 0));\n    if(cell.x == 0 && cell.y == 1) code = max(code, uvec3(0, 1, 0));\n    return bvec3(code);\n}\n\nuint getIdx(ivec3 cell)\n{\n    //return texelFetch(iChannel1, cell + 0 + halfboundsize, 0).x > 0.5 ? 1u : 0u;\n    //return uint(floor(texelFetch(iChannel1, cell + 0 + halfboundsize, 0).x * 8.0)); // use with random value volume\n    // staircase\n    if(cell.x == -1 && cell.y ==  0) return 1u;\n    if(cell.x ==  0 && cell.y == +1) return 2u;\n    if(cell.x == +1 && cell.y ==  0) return 3u;\n    if(cell.x ==  0 && cell.y == -1) return 4u;\n    return 0u;\n}\n\n#define MAX_RAY_STEPS 64\n\n// Coordinate-systems:\n//  * camera-coordinates: x,y aligned with screen, z towards viewer\n//  * world-coordinates: map-on-table, i.e. x,y on the map with additional z-coordinate for height\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    vec3 camx = vec3(1.0, 0.0, 0.0);\n    vec3 camy = vec3(0.0, 1.0, 0.0) * iResolution.y / iResolution.x;\n    vec3 camz = vec3(0.0, 0.0, 1.0);\n    vec3 rayPos = vec3(0.0, 2.0 * float(halfboundsize), 0.0);\n\n    vec3 rayDir = screenPos.x * camx + screenPos.y * camy + camz;\n    rayDir.yz = mat2(vec2(0.0, 1.0), vec2(-1.0, 0.0)) * rayDir.yz;\n\n    mat2 R = rotate(1.0 * iTime / 5.0);\n    rayPos.xy = R * rayPos.xy;\n    rayDir.xy = R * rayDir.xy;\n\n    rayDir = normalize(rayDir);\n\n    vec3 color = vec3(0.0);\n    vec4 result = vec4(vec3(0.0), MAX_DIST);\n\n    {\n        vec3 deltaDist = 1.0 / abs(rayDir);\n        ivec3 rayStep = ivec3(sign(rayDir));\n        ivec3 cell = ivec3(floor(rayPos + 0.));\n        vec3 sideDist = (sign(rayDir) * (vec3(cell) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist;\n\n        for (int i = 0; i < MAX_RAY_STEPS; i++)\n        //for (int i = min(iFrame,0); i < MAX_RAY_STEPS; i++) // prevent unrolling loop to prevent crash\n        {\n            if(min(abs(cell.x), min(abs(cell.y),abs(cell.z))) > halfboundsize) // WORKAROUND (letting loop run-out without hitting a wall results in weird blocky artifacts on my computer)\n                break;\n\n            if(all(lessThan(abs(cell), ivec3(halfboundsize)))) // odd\n            //if(all(greaterThanEqual(cell, -ivec3(halfboundsize))) && all(lessThan(cell, ivec3(halfboundsize)))) // even\n            {\n                bvec3 walls0 = getWall(cell + 0);\n                bvec3 walls1 = // can this be optimized?\n                    bvec3\n                    (\n                        getWall(cell  + ivec3(1,0,0)).x,\n                        getWall(cell  + ivec3(0,1,0)).y,\n                        getWall(cell  + ivec3(0,0,1)).z\n                    );\n                uint idx = getIdx(cell);\n                if(any(walls0) || any(walls1) || idx > 0u) // skip empty voxels\n                {\n                    // Near bounding-box side can be reconstructed from dda, howvever we need far bounding-box side, too.\n                    // float d = length(vec3(mask) * (sideDist - deltaDist)) / length(rayDir);\n                    // It appears to be easier to just do the box-intersection here (potential for optimization).\n                    vec2 bounds = boxIntersection( rayPos - vec3(cell) - vec3(0.5), rayDir, vec3(0.5) ); // bounding box\n\n                    result = process_subobject(rayPos - vec3(cell) - vec3(0.5), rayDir, bounds.x, bounds.y, walls0, walls1, idx);\n                    if(result.w > 0.0 && result.w < bounds.y)\n                    {\n                        //color = vec3(1.0); // plain\n                        color = 0.5 + 0.5 * vec3(texture(iChannel0, 0.1 * vec3(cell))); // some random colors to improve visualization\n                        //color = 0.5 + 0.5 * normalize(result.xyz); // normal colors\n                        vec3 dst = rayPos + rayDir * result.w;\n                        //color *= texture(iChannel0, dst).xyz;\n                        //color *= vec3(0.5 + 0.5 * checker(dst * 8.0));\n                        //color *= vec3(0.5 + 0.5 * checker(dst));\n                        //color *= vec3(0.5 + 0.5 * blob(dst));\n                        color *= 0.5 + 0.5 * vec3(texture(iChannel0, dst)); // 3d texture\n\n                        vec3 fogcolor = vec3(0.25, 0.4, 0.5); // fog\n                        //vec3 fogcolor = vec3(0.75, 0.6, 0.3); // smog\n                        color *= mix(fogcolor, color, exp(-result.w * result.w / 200.0)); // fog for depth impression & to suppress flickering\n\n                        break;\n                    }\n                }\n            }\n\n            // \"The raycasting code is somewhat based around a 2D raycasting toutorial found here:\n            //  http://lodev.org/cgtutor/raycasting.html\" (fb39ca4)\n            // Core of https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting\n            bvec3 mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n            sideDist += vec3(mask) * deltaDist;\n            cell += ivec3(vec3(mask)) * rayStep;\n        }\n    }\n\n    vec3 ambient = vec3(0.1);\n    vec3 lightdir = normalize(vec3(1.0, 2.0, 3.0));\n    color *= mix(ambient, vec3(1.0), clamp(dot(lightdir, result.xyz), 0.0, 1.0));\n\n    fragColor.rgb = sqrt(color);\n}\n","name":"Image","description":"","type":"image"}]}