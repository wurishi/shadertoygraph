{"ver":"0.1","info":{"id":"WlSSDt","date":"1567440050","viewed":422,"name":"Magnet Dynamics","username":"dr2","description":"Classical XY spin model - details in source","likes":4,"published":3,"flags":32,"usePreview":0,"tags":["mechanics","spin","physics","magnetism","statistical"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Magnet Dynamics\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n Classical XY spin model (a cousin of the Ising model).\n Spins are unit vectors on the sites of a 2D lattice with periodic boundaries.\n Interaction between neighboring spins depends on their scalar product.\n Although usually modelled using Monte Carlo, here the rotational equations\n of motion are solved numerically. Total kinetic energy is periodically\n rescaled to the nominal temperature.\n Slider controls temperature. Kinetic and potential energy values are shown\n (arbitrary units, computation uses parallel reduction).\n Observe the behavior as the temperature is gradually lowered (ordered state\n with transient defects, including vortices).\n*/\n\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\nvec4 Loadv4 (vec2 vId);\n\nconst float gSize = 32.;  // same value in buffer shader(s)\n\nconst float pi = 3.14159;\n\nvec3 ShowScene (vec2 uv)\n{\n  vec3 col;\n  vec2 ut, ur, gPos, cs;\n  float s;\n  col = vec3 (1., 1., 0.);\n  ut = gSize * (0.5 * uv + 0.5);\n  gPos = floor (ut);\n  cs = Loadv4 (gPos).xy;\n  ut -= gPos + 0.5;\n  ur = ut + vec2 (-0.11, 0.09);\n  if (length (ur) < 0.4) {\n    ur = Rot2Cs (ur, cs);\n    s = 0.06 - abs (ur.y);\n    if (ur.x > 0.05) s = max (s, 0.07 - abs (ur.x + 1.2 * abs (ur.y) - 0.35));\n    if (s > 0.) col = mix (col, vec3 (0.7, 0.7, 0.), smoothstep (0., 0.02, s));\n  }\n  ur = ut;\n  if (length (ur) < 0.4) {\n    ur = Rot2Cs (ur, cs);\n    s = 0.06 - abs (ur.y);\n    if (ur.x > 0.05) s = max (s, 0.07 - abs (ur.x + 1.2 * abs (ur.y) - 0.35));\n    if (s > 0.) col = mix (col, vec3 (0.2, 0.2, 1.), smoothstep (0., 0.02, s));\n  }\n  return col;\n}\n\nvec4 ShowWg (vec2 uv, vec2 canvas, float tVal)\n{\n  vec4 wgBx;\n  vec3 col;\n  vec2 ust;\n  float asp;\n  asp = canvas.x / canvas.y;\n  wgBx = vec4 (0.41 * asp, 0.05, 0.01 * asp, 0.15);\n  col = vec3 (0.);\n  ust = abs (0.5 * uv - wgBx.xy) - wgBx.zw;\n  if (abs (max (ust.x, ust.y)) * canvas.y < 1.5) col = vec3 (0.6, 0.3, 0.1);\n  ust = 0.5 * uv - wgBx.xy;\n  ust.y -= (tVal - 0.5) * 2. * wgBx.w;\n  ust = abs (ust);\n  if (abs (max (ust.x, ust.y) - 0.7 * wgBx.z) * canvas.y < 2.5)  col = (tVal < 0.5) ?\n     mix (vec3 (0.2, 0.2, 1.), vec3 (0.2, 1., 0.2), smoothstep (0.3, 0.36, tVal)) :\n     mix (vec3 (0.2, 1., 0.2), vec3 (1., 0.2, 0.2), smoothstep (0.63, 0.69, tVal));\n  return vec4 (col, step (0.001, length (col)));\n}\n\n#define AA  1\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 c4;\n  vec3 col;\n  vec2 canvas, uv, ut;\n  float asp, tVal, sr, uSum, vvSum;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  asp = canvas.x / canvas.y;\n  tVal = Loadv4 (vec2 (1., gSize)).y;\n  uSum = Loadv4 (vec2 (0., gSize)).z;\n  vvSum = Loadv4 (vec2 (0., gSize)).w;\n  ut = abs (uv) - vec2 (1.);\n  if (max (ut.x, ut.y) < 0.) {\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif  \n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = 0.; a < naa; a ++) \n       col += (1. / naa) * ShowScene (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n          sr * (0.667 * a + 0.5) * pi));\n  } else {\n    col = vec3 (0.82);\n    c4 = ShowWg (uv, canvas, tVal);\n    col = mix (col, c4.rgb, c4.a);\n    col = mix (col, vec3 (0.6, 0.3, 0.1), ShowInt (0.5 * uv - vec2 (0.44 * asp, -0.3),\n       vec2 (0.06 * asp, 0.03), 4., floor (100. * vvSum + 0.5)));\n    col = mix (col, vec3 (0.6, 0.3, 0.1), ShowInt (0.5 * uv - vec2 (0.44 * asp, -0.35),\n       vec2 (0.06 * asp, 0.03), 4., floor (100. * uSum + 0.5)));\n  }\n  fragColor = vec4 (clamp (col, 0., 1.), 1.);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat DigSeg (vec2 q)\n{\n  return (1. - smoothstep (0.13, 0.17, abs (q.x))) *\n     (1. - smoothstep (0.5, 0.57, abs (q.y)));\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    if (val < 0.5) sgn = 1.;\n    nDig = (val > 0.) ? floor (max (log (val + 0.01) / log (10.), 0.)) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (idChar == mxChar - nDig - 1. && sgn < 0.) s = ShowDig (q, -1);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// \"Magnet Dynamics\" by dr2 - 2019\n\nvec2 Rot2D (vec2 q, float a);\nvec4 Loadv4 (vec2 vId);\nfloat Hashff (float p);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst float gSize = 32.;\n\nfloat nStep, tVal;\nconst float pi = 3.14159;\n\nvoid Step (vec2 sv, out vec4 cspuv)\n{\n  vec4 dv;\n  vec2 csp, cspN, cspa;\n  float wv, wa, u, delT;\n  delT = 0.01;\n  dv = mod (vec4 (sv.xx, sv.yy) + vec4 (1., -1., 1., -1.), gSize);\n  cspuv = Loadv4 (sv);\n  csp = cspuv.xy;\n  cspa = csp * vec2 (1., -1.);\n  wv = cspuv.w;\n  wa = 0.;\n  u = 0.;\n  cspN = Loadv4 (vec2 (dv.x, sv.y)).yx;\n  wa += dot (cspa, cspN);\n  u -= dot (csp, cspN.yx);\n  cspN = Loadv4 (vec2 (dv.y, sv.y)).yx;\n  wa += dot (cspa, cspN);\n  u -= dot (csp, cspN.yx);\n  cspN = Loadv4 (vec2 (sv.x, dv.z)).yx;\n  wa += dot (cspa, cspN);\n  u -= dot (csp, cspN.yx);\n  cspN = Loadv4 (vec2 (sv.x, dv.w)).yx;\n  wa += dot (cspa, cspN);\n  u -= dot (csp, cspN.yx);\n  csp = Rot2D (csp, delT * wv);\n  wv += delT * wa;\n  cspuv = vec4 (csp, 0.5 * u, wv);\n}\n\nvoid Init (vec2 sv, out vec4 cspuv)\n{\n  cspuv.xy = vec2 (0., -1.);\n  cspuv.z = 0.;\n  cspuv.w = sqrt (5. * tVal) * (2. * Hashff (31. * sv.y + 37. * sv.x) - 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 wgBx, mPtr, mPtrP, stDat, fVal, cspuv;\n  vec2 canvas, iFrag, ust;\n  float asp, uSum, vvSum, t;\n  int wgSel, wgReg;\n  canvas = iResolution.xy;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas.xy - 0.5;\n  if (fragCoord.x >= gSize + 1. || fragCoord.y >= gSize + 1. ||\n     fragCoord.y == gSize && fragCoord.x >= 3.) discard;\n  asp = canvas.x / canvas.y;\n  wgBx = vec4 (0.41 * asp, 0.05, 0.01 * asp, 0.15);\n  iFrag = floor (fragCoord);\n  if (iFrame <= 5) {\n    mPtrP = mPtr;\n    wgSel = -1;\n    nStep = 0.;\n    tVal = 0.2;\n    if (max (iFrag.x, iFrag.y) < gSize) Init (iFrag, cspuv);\n    else if (iFrag.y == gSize && iFrag.x == 1.) {\n      uSum = 0.;\n      vvSum = 0.;\n    }\n  } else {\n    stDat = Loadv4 (vec2 (1., gSize));\n    nStep = stDat.x;\n    tVal = stDat.y;\n    stDat = Loadv4 (vec2 (2., gSize));\n    mPtrP.z = stDat.z;\n    wgSel = int (stDat.w);\n    ++ nStep;\n    if (mPtr.z > 0.) {\n      wgReg = 0;\n      ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx.xy) - wgBx.zw;\n      if (max (ust.x, ust.y) < 0.) wgReg = 1;\n      if (mPtrP.z <= 0.) wgSel = wgReg;\n    } else {\n      wgSel = -1;\n      wgReg = -1;\n    }\n    if (wgSel == 1) tVal = clamp (0.5 + 0.5 * (mPtr.y - wgBx.y) / wgBx.w, 0., 1.);\n    if (max (iFrag.x, iFrag.y) < gSize) {\n      Step (iFrag, cspuv);\n      if (nStep > 20. && mod (nStep, 10.) == 0.) {\n        t = max (0.1, 5. * tVal);\n        cspuv.w *= sqrt (t / Loadv4 (vec2 (0., gSize)).w);\n        cspuv.w = clamp (cspuv.w, -3. * sqrt (t), 3. * sqrt (t));\n      }\n    } else if (iFrag.y < gSize && iFrag.x == gSize) {\n      uSum = 0.;\n      vvSum = 0.;\n      for (float j = 0.; j < gSize; j ++) {\n        cspuv = Loadv4 (vec2 (j, iFrag.y));\n        uSum += cspuv.z;\n        vvSum += cspuv.w * cspuv.w;\n      }\n    } else if (iFrag.y == gSize && iFrag.x == 0.) {\n      uSum = 0.;\n      vvSum = 0.;\n      for (float j = 0.; j < gSize; j ++) {\n        cspuv = Loadv4 (vec2 (gSize, j));\n        uSum += cspuv.z;\n        vvSum += cspuv.w;\n      }\n    }\n  }\n  if (max (iFrag.x, iFrag.y) < gSize) fVal = cspuv;\n  else if (iFrag.y < gSize && iFrag.x == gSize) fVal = vec4 (0., 0., uSum, vvSum);\n  else if (iFrag.y == gSize && iFrag.x == 0.) fVal = vec4 (0., 0., uSum, vvSum) / (gSize * gSize);\n  else if (iFrag.y == gSize && iFrag.x == 1.) fVal = vec4 (nStep, tVal, 0., 0.);\n  else if (iFrag.y == gSize && iFrag.x == 2.) fVal = vec4 (mPtr.xyz, float (wgSel));\n  Savev4 (iFrag, fVal, fragColor, fragCoord);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n  \nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// \"Magnet Dynamics\" by dr2 - 2019\n\nvec2 Rot2D (vec2 q, float a);\nvec4 Loadv4 (vec2 vId);\nfloat Hashff (float p);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst float gSize = 32.;\n\nfloat nStep, tVal;\nconst float pi = 3.14159;\n\nvoid Step (vec2 sv, out vec4 cspuv)\n{\n  vec4 dv;\n  vec2 csp, cspN, cspa;\n  float wv, wa, u, delT;\n  delT = 0.01;\n  dv = mod (vec4 (sv.xx, sv.yy) + vec4 (1., -1., 1., -1.), gSize);\n  cspuv = Loadv4 (sv);\n  csp = cspuv.xy;\n  cspa = csp * vec2 (1., -1.);\n  wv = cspuv.w;\n  wa = 0.;\n  u = 0.;\n  cspN = Loadv4 (vec2 (dv.x, sv.y)).yx;\n  wa += dot (cspa, cspN);\n  u -= dot (csp, cspN.yx);\n  cspN = Loadv4 (vec2 (dv.y, sv.y)).yx;\n  wa += dot (cspa, cspN);\n  u -= dot (csp, cspN.yx);\n  cspN = Loadv4 (vec2 (sv.x, dv.z)).yx;\n  wa += dot (cspa, cspN);\n  u -= dot (csp, cspN.yx);\n  cspN = Loadv4 (vec2 (sv.x, dv.w)).yx;\n  wa += dot (cspa, cspN);\n  u -= dot (csp, cspN.yx);\n  csp = Rot2D (csp, delT * wv);\n  wv += delT * wa;\n  cspuv = vec4 (csp, 0.5 * u, wv);\n}\n\nvoid Init (vec2 sv, out vec4 cspuv)\n{\n  cspuv.xy = vec2 (0., -1.);\n  cspuv.z = 0.;\n  cspuv.w = sqrt (5. * tVal) * (2. * Hashff (31. * sv.y + 37. * sv.x) - 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 wgBx, mPtr, mPtrP, stDat, fVal, cspuv;\n  vec2 canvas, iFrag, ust;\n  float asp, uSum, vvSum, t;\n  int wgSel, wgReg;\n  canvas = iResolution.xy;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas.xy - 0.5;\n  if (fragCoord.x >= gSize + 1. || fragCoord.y >= gSize + 1. ||\n     fragCoord.y == gSize && fragCoord.x >= 3.) discard;\n  asp = canvas.x / canvas.y;\n  wgBx = vec4 (0.41 * asp, 0.05, 0.01 * asp, 0.15);\n  iFrag = floor (fragCoord);\n  if (iFrame <= 5) {\n    mPtrP = mPtr;\n    wgSel = -1;\n    nStep = 0.;\n    tVal = 0.2;\n    if (max (iFrag.x, iFrag.y) < gSize) Init (iFrag, cspuv);\n    else if (iFrag.y == gSize && iFrag.x == 1.) {\n      uSum = 0.;\n      vvSum = 0.;\n    }\n  } else {\n    stDat = Loadv4 (vec2 (1., gSize));\n    nStep = stDat.x;\n    tVal = stDat.y;\n    stDat = Loadv4 (vec2 (2., gSize));\n    mPtrP.z = stDat.z;\n    wgSel = int (stDat.w);\n    ++ nStep;\n    if (mPtr.z > 0.) {\n      wgReg = 0;\n      ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx.xy) - wgBx.zw;\n      if (max (ust.x, ust.y) < 0.) wgReg = 1;\n      if (mPtrP.z <= 0.) wgSel = wgReg;\n    } else {\n      wgSel = -1;\n      wgReg = -1;\n    }\n    if (wgSel == 1) tVal = clamp (0.5 + 0.5 * (mPtr.y - wgBx.y) / wgBx.w, 0., 1.);\n    if (max (iFrag.x, iFrag.y) < gSize) {\n      Step (iFrag, cspuv);\n      if (nStep > 20. && mod (nStep, 10.) == 0.) {\n        t = max (0.1, 5. * tVal);\n        cspuv.w *= sqrt (t / Loadv4 (vec2 (0., gSize)).w);\n        cspuv.w = clamp (cspuv.w, -3. * sqrt (t), 3. * sqrt (t));\n      }\n    } else if (iFrag.y < gSize && iFrag.x == gSize) {\n      uSum = 0.;\n      vvSum = 0.;\n      for (float j = 0.; j < gSize; j ++) {\n        cspuv = Loadv4 (vec2 (j, iFrag.y));\n        uSum += cspuv.z;\n        vvSum += cspuv.w * cspuv.w;\n      }\n    } else if (iFrag.y == gSize && iFrag.x == 0.) {\n      uSum = 0.;\n      vvSum = 0.;\n      for (float j = 0.; j < gSize; j ++) {\n        cspuv = Loadv4 (vec2 (gSize, j));\n        uSum += cspuv.z;\n        vvSum += cspuv.w;\n      }\n    }\n  }\n  if (max (iFrag.x, iFrag.y) < gSize) fVal = cspuv;\n  else if (iFrag.y < gSize && iFrag.x == gSize) fVal = vec4 (0., 0., uSum, vvSum);\n  else if (iFrag.y == gSize && iFrag.x == 0.) fVal = vec4 (0., 0., uSum, vvSum) / (gSize * gSize);\n  else if (iFrag.y == gSize && iFrag.x == 1.) fVal = vec4 (nStep, tVal, 0., 0.);\n  else if (iFrag.y == gSize && iFrag.x == 2.) fVal = vec4 (mPtr.xyz, float (wgSel));\n  Savev4 (iFrag, fVal, fragColor, fragCoord);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n  \nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}