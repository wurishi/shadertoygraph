{"ver":"0.1","info":{"id":"ttX3RS","date":"1557168487","viewed":411,"name":"Juggling Pong","username":"inbard2","description":"This is a playable game in a shader.\nThroughout the game new balls will be added, your goal is to juggle as many as you can.\nIf all the balls escape the screen, the game will restart with a score of 0.\n\n","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarching","game","shader","pong","playable","juggling","juggle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThis is a playable game in a shader.\nThroughout the game new balls will be added, your goal is to juggle as many as you can.\nIf all the balls escape the screen, the game will restart with a score of 0.\n\nThanks to everyone who created the shader toys and tutorials below, which helped me a lot.\n\nPong by barakooda\nhttp://barakooda.com/2018/01/27/gpu-pong/\n\nPacman by iq\nhttps://www.shadertoy.com/view/Ms3XWN\n\nRay marching tutorial by Jamie Wong\nhttp://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n\n*/\n\n/***********************************************************************************************/\n// Game rendering - View\n/***********************************************************************************************/\n\nfloat rect (vec2 pos, vec2 center, vec2 size)\n{\n    float halfWidth = size.x/2.0;\n    float halfHeight = size.y/2.0;\n    bool res= (pos.x >= center.x-halfWidth && pos.x <= center.x+halfWidth &&\n               pos.y >= center.y-halfHeight && pos.y <= center.y+halfHeight);\n    return res?1.:0.;                  \n}\n\nvec3 drawDigit(vec2 pos, vec2 center, int digit) \n{    \n    // the digits rects are from the image in the link: \n    // https://www.geeksforgeeks.org/check-if-number-can-be-displayed-using-seven-segment-led/\n\tfloat s1 = 0.05;\n    float s2 = 0.03;\n    float s3 = 0.015;\n    \n    float rect1 = rect(pos, vec2(center.x, center.y+s2+s3), vec2(s1,s3));\n    float rect2 = rect(pos, vec2(center.x+s1/2.+s3/2., center.y+s2/2.+s3/2.), vec2(s3,s2));\n    float rect3 = rect(pos, vec2(center.x+s1/2.+s3/2., center.y-s2/2.-s3/2.), vec2(s3,s2));\n    float rect4 = rect(pos, vec2(center.x, center.y-s2-s3), vec2(s1,s3));\n    float rect5 = rect(pos, vec2(center.x-s1/2.-s3/2., center.y-s2/2.-s3/2.), vec2(s3,s2));\n    float rect6 = rect(pos, vec2(center.x-s1/2.-s3/2., center.y+s2/2.+s3/2.), vec2(s3,s2));\n    float rect7 = rect(pos, center, vec2(s1,s3));\n\n\n    switch (digit){ \n        case 0:\n        return vec3(rect1+rect2+rect3+rect4+rect5+rect6);\n        case 1:\n        return vec3(rect2+rect3);\n        case 2:\n        return vec3(rect1+rect2+rect4+rect5+rect7);\n        case 3:\n        return vec3(rect1+rect2+rect3+rect4+rect7);\n        case 4:\n        return vec3(rect2+rect3+rect6+rect7);\n        case 5:\n        return vec3(rect1+rect3+rect4+rect6+rect7);\n        case 6:\n        return vec3(rect1+rect3+rect4+rect5+rect6+rect7);\n        case 7:\n        return vec3(rect1+rect2+rect3);\n        case 8:\n        return vec3(rect1+rect2+rect3+rect4+rect5+rect6+rect7);\n        case 9:\n        return vec3(rect1+rect2+rect3+rect4+rect6+rect7);\n\n    }\n}\n\nvec3 drawScore(vec2 pos)\n{\n    vec3 col = vec3(0);\n\tint digits[9];\n    int countDigits=0;\n\n    int tmp = clamp(score,0,999999999);\n    do\n    {\n        digits[countDigits] = tmp%10;\n        tmp /= 10;          \n        countDigits++;\n     \n    } while ( tmp > 0 );\n    \n    // draw the digits such that the score is centered\n    vec2 center = vec2(0., 1./aspect-BORDER_SIZE*1.1);\n    vec2 offset = vec2(float(countDigits-1)*0.05, 0.);\n    for(int i=0; i<countDigits; ++i){\n        col = col + drawDigit(pos, center+offset, digits[i]);            \n        offset.x -= 0.1;\n    }\n    \n    return col;\n        \n}\n\nfloat rayMarchToSurface(Ray ray, int surface) \n{\n    float depth = 0.0;\n    float dist = 0.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        \n        vec3 marchedRay = ray.origin + depth * ray.dir;\n        if (surface == BALLS_SURFACE)\n            dist = ballsSDF(marchedRay);\n        else\n            dist = racketsSDF(marchedRay);\n            \n        if (dist < EPSILON) {\n            return depth;\n        }\n        depth += dist;\n        if (depth >= MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n    return MAX_DIST;\n}\n\nfloat rayMarchToScene(Ray ray, out int surface)\n{\n    surface = -1;\n    float dist = MAX_DIST, tmp;\n    \n    tmp = rayMarchToSurface(ray, BALLS_SURFACE);\n    if (tmp < dist) {\n      \tsurface = BALLS_SURFACE;\n        dist = tmp;\n    }\n    \n    tmp = rayMarchToSurface(ray, RACKETS_SURFACE);\n    if (tmp < dist) {\n        surface = RACKETS_SURFACE;\n        dist = tmp;\n    }\n    return dist;\n}\n\nvec3 phongShade(vec3 surfacePos, vec3 color, vec3 lightPos, vec3 eyePos, vec3 normal) \n{\n    vec3 ambientColour =  vec3(0.35);\n\n    // Light direction from surface\n    vec3 lightDir = normalize(lightPos - surfacePos);\n\n    // The diffuse equation\n    float diffuse = max(0.0, dot(normal, lightDir));\n    \n    // The specular equation\n    vec3 viewDir = normalize(eyePos - surfacePos);\n    vec3 reflectDir = reflect(-lightDir, normal); \n    float specular = pow(max(dot(viewDir, reflectDir), 0.0), 2.3);\n\n    return color*(ambientColour + diffuse*0.5 + specular*0.3);\n}\n\nvec3 background (vec3 pos)\n{\n    // black is in the middle\n    float offset = pow(sin(pos.y),2.0);\n    float rightSide = smoothstep(0.0,0.8,pos.x-offset);\n    float leftSide = smoothstep(0.0,0.8,-pos.x-offset);\n    float lightness = leftSide+rightSide;\n    vec3 lighterColor = vec3(0.15, 0.67, 0.78);\n    vec3 darkerColor = vec3(0.16, 0.17, 0.31);\n    vec3 bg = mix(lighterColor,darkerColor,lightness);\n    if (abs(pos.y) >= (1./aspect-BORDER_SIZE/2.))\n        return vec3(0);\n    else\n        return bg;\n}\n\n\nvec3 drawScene(Ray ray, vec3 worldPos)\n{\n    // estimate surface normal in the ray hit point on the surface\n    int hitSurface;\n    float dist = rayMarchToScene(ray, hitSurface);\n    vec3 surfacePos = ray.origin + dist * ray.dir;\n    vec3 normal = estimateNormal(surfacePos, hitSurface);\n    \n    if (hitSurface == BALLS_SURFACE)\n    {        \n        vec3 diffuseColour = vec3(0.8, 0.95, 0.39);\n        vec3 lightPos = vec3(-3.0*surfacePos.x, 2.0, -3.0);\n        return phongShade(surfacePos, diffuseColour, lightPos, ray.origin, normal);\n    }\n    else if (hitSurface == RACKETS_SURFACE)\n    {\n        vec3 diffuseColour = vec3(0.6, 0.5, 0.72);\n        vec3 lightPos = vec3(0.0, 2.0, -3.0);\n        return phongShade(surfacePos, diffuseColour, lightPos, ray.origin, normal);\n    }\n\n    return background(worldPos);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tloadGameState(iChannel0);\n            \n    aspect = iResolution.x/iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 worldPos = toWorldSpace3D(uv);     \n    vec3 eyePos = vec3(0, 0, -4);\n    vec3 rayDir = normalize(worldPos - eyePos);\n    \n    Ray ray = Ray(eyePos, rayDir);\n    \n    vec3 color = drawScene(ray, worldPos) + 0.4*drawScore(worldPos.xy);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/***********************************************************************************************/\n// Game logic - Controller\n/***********************************************************************************************/\n\nvoid initGame()\n{\n    ballsPositions[0] = vec3(0);\n    ballsDirections[0] = normalize(INIT_DIR);\n    gameMode = GAME_RUNNING;\n    score = 0;\n    currBallsAmount = 1;\n    \n#ifdef TEST_MODE\n    currBallsAmount=10;\n    for (int i=0; i< currBallsAmount; ++i)\n    {\n        ballsPositions[i] = vec3(0);\n        vec3 dir = INIT_DIR + vec3(float(i)+0.1,0.0,0.);\n    \tballsDirections[i] = normalize(dir);\n        \n    }\n#endif\n}\n\nbool handleCollisions(int ballIndex, float threshold) // returns true if a ball was removed\n{\n    vec3 ballPos = ballsPositions[ballIndex];\n    vec3 ballDir = ballsDirections[ballIndex];\n    \n    if (racketsSDF(ballPos) <= 1.5*RADIUS)  \n    {    \n        // estimate normal in the collision point\n        vec3 normal = estimateNormal(ballPos, RACKETS_SURFACE);\n\n        // check if the ball moving towards the racket\n        if (dot(-normal,ballDir) > 0.0) {\n            \n            // the ball collided with a racket\n            normal = normalize(normal);\n            ballDir = reflect(ballDir, normal);\n            ballDir = normalize(ballDir);\n                        \n            score += currBallsAmount;\n            collisionsCount += 1;\n            \n            /* add a new ball every 5 ball-racket collisions\n    \t\tif hasn't reached the max amount allowed\n    \t\t*/\n    \t\tif (collisionsCount % 5 == 0 \n                && currBallsAmount < MAX_BALLS_AMOUNT)\n            {\n        \t\tballsPositions[currBallsAmount] = vec3(0); \n        \t\tballsDirections[currBallsAmount] = normalize(INIT_DIR); \n        \t\tcurrBallsAmount++;             \n    \t\t}\n        }\n    }\n\n    // if reach top or bottom border and moving towards the border               \n    if ((abs(ballPos.y) > (threshold+RADIUS)) && \n        (sign(ballPos.y) == sign(ballDir.y)))\n    {\n        ballDir.y *= -1.0;                    \n    }\n\n    // if reach left or right border\n    if (abs(ballPos.x) > (1.+RADIUS) && sign(ballPos.x) == sign(ballDir.x))\n    {\n        // remove the lost ball by replacing it with the last one\n        ballsPositions[ballIndex] = ballsPositions[currBallsAmount-1];\n        ballsDirections[ballIndex] = ballsDirections[currBallsAmount-1];\n\n        currBallsAmount--;\n\n        if (currBallsAmount == 0)\n            // the game is over when no balls left\n        \tgameMode = GAME_OVER; \n        \n        return true;\n    }\n\n    // check if collided with other balls\n    for (int i=ballIndex+1; i<currBallsAmount; ++i)\n    {\n        Sphere otherBall = Sphere(ballsPositions[i], RADIUS);\n        if (sphereSDF(ballPos, otherBall) <= RADIUS) \n        {\n        \tvec3 normal = normalize(otherBall.center - ballPos); \n            vec3 otherBallDir = ballsDirections[i];\n            // check if they are getting closer\n            if (dot(normal, otherBallDir) - dot(normal, ballDir) < 0.) {\n            \t// the ball collided with other ball\n            \tballDir = normalize(reflect(ballDir, -normal));\n            \tballsDirections[i] = normalize(reflect(otherBallDir, normal));\n            } \n                \n        }            \n    }\n\n    ballsDirections[ballIndex] = ballDir;\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 var = ivec2(fragCoord);\n    if (var.x > MAX_VAR.x || var.y > MAX_VAR.y)\n        discard;\n    \n    loadGameState(iChannel0);\n    \n    // get user input\n    aspect = iResolution.x/iResolution.y;\n    float threshold = 1./aspect-BORDER_SIZE;\n    vec2 mousePos = iMouse.xy/iResolution.xy;\n    rightRacketPos = toWorldSpace3D(mousePos);\n    rightRacketPos.y = clamp(rightRacketPos.y,-threshold,threshold);\n    rightRacketPos.x = clamp(rightRacketPos.x,0.72,0.82);\n    \n    if (gameMode == GAME_OVER) // also evaluates to true in a new game\n        initGame();\n    else if (gameMode == GAME_RUNNING)\n    {\n        // change balls directions and move them\n        int i=0;\n        while(i < currBallsAmount )\n        {\n            // if current ball was removed, it got replaced with the last ball,\n            // we will try again in the next iteration\n            if (handleCollisions(i, threshold))\n                continue;\n            \n            ballsPositions[i] += iTimeDelta * SPEED * ballsDirections[i]; \n            i++;\n        }\n    }\n    \t\n \n    fragColor = storeGameState(var);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/***********************************************************************************************/\n// Game data - Model\n/***********************************************************************************************/\n\n//#define TEST_MODE\n\n//////////////////////////////////////////////////////////////////////////////////////////\n// game constants\n//////////////////////////////////////////////////////////////////////////////////////////\n\nconst int   GAME_OVER = 0;\nconst int   GAME_RUNNING = 1;\nconst float SPEED = 1.0;\nconst vec3  INIT_DIR = vec3(1.,-1.7, 0.0);\nconst float RADIUS = 0.035;\nconst int   BALLS_SURFACE = 0;\nconst int   RACKETS_SURFACE = 1;\nconst int   MAX_MARCHING_STEPS = 128;\nconst float MAX_DIST = 60.0;\nconst float EPSILON = 0.00001;\nconst float BORDER_SIZE = 0.15;\nconst int   MAX_BALLS_AMOUNT = 10;\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////////\n// game state\n//////////////////////////////////////////////////////////////////////////////////////////\n\nvec3 ballsPositions[MAX_BALLS_AMOUNT];\nvec3 ballsDirections[MAX_BALLS_AMOUNT];\nvec3 rightRacketPos;\nint  gameMode;\nint  score;\nint  currBallsAmount;\nint  collisionsCount;\n\n\n/* game state texture coords for loading and storing vars.\nthe balls positions is in the most buttom row, directions are in the row above it\nall other vars are in the most left column.\n*/\nconst ivec2 RIGHT_RACKET_POS_VAR  = ivec2(0,2);\nconst ivec2 GAME_MODE_VAR         = ivec2(0,3);\nconst ivec2 CURR_BALLS_AMOUNT_VAR = ivec2(0,4);\nconst ivec2 SCORE_VAR             = ivec2(0,5);\nconst ivec2 COLLISIONS_COUNT_VAR  = ivec2(0,6);\n\nconst ivec2 MAX_VAR\t= ivec2(MAX_BALLS_AMOUNT-1,6);\n\n#define LOAD_VAR(var,tex) \\\n\ttexelFetch(tex, var, 0)\n        \n#define LOAD_BALL_POS(ball_index,tex) \\\n    texelFetch(tex, ivec2(ball_index,0), 0).xyz\n\n#define LOAD_BALL_DIR(ball_index,tex) \\\n    texelFetch(tex, ivec2(ball_index,1), 0).xyz\n\nvec4 storeGameState(ivec2 var)\n{\n    for (int i=0; i<currBallsAmount; ++i)\n    {\n        if (var == ivec2(i,0)) // if var is in the balls positions row\n        \treturn vec4(ballsPositions[i],0);\n        else if (var == ivec2(i,1)) // if var is in the balls directions row\n        \treturn vec4(ballsDirections[i],0);        \n    }\n    \n    if (var == RIGHT_RACKET_POS_VAR)\n        return vec4(rightRacketPos,0);\n    else if (var == GAME_MODE_VAR)\n        return vec4(gameMode,0,0,0);\n    else if (var == CURR_BALLS_AMOUNT_VAR)\n        return vec4(float(currBallsAmount)/255.,0,0,0);\n    else if (var == SCORE_VAR)\n        return vec4(float(score)/255.,0,0,0);\n    else if (var == COLLISIONS_COUNT_VAR)\n        return vec4(float(collisionsCount)/255.,0,0,0);\n}\n\nvoid loadGameState(sampler2D tex)\n{\n    gameMode = int(LOAD_VAR(GAME_MODE_VAR,tex).x);\n    currBallsAmount = int(LOAD_VAR(CURR_BALLS_AMOUNT_VAR,tex).x*255.);\n    score = int(LOAD_VAR(SCORE_VAR,tex).x*255.);\n    collisionsCount = int(LOAD_VAR(COLLISIONS_COUNT_VAR,tex).x*255.);\n    rightRacketPos = LOAD_VAR(RIGHT_RACKET_POS_VAR,tex).xyz;   \n    for (int i=0; i<currBallsAmount; ++i)\n    {\n        ballsPositions[i] = LOAD_BALL_POS(i,tex);\n    \tballsDirections[i] = LOAD_BALL_DIR(i,tex);\n    }\n}        \n        \n\n\n//////////////////////////////////////////////////////////////////////////////////////////\n// game objects and SDFs\n//////////////////////////////////////////////////////////////////////////////////////////\n\n\nstruct Ray {\n\tvec3 origin;\n\tvec3 dir; \n};\n    \nstruct Sphere {\n\tvec3 center;\n\tfloat radius; \n};\n    \nstruct Box {\n    vec3 center;\n    vec3 size;// width, height, depth\n    float roundness;\n};\n   \n    \n/*\nsigned distance function- calculates distance from p to the object surface. \ninside the object it's returning negative values, on the surface = 0, outside - positive\n*/\n\nfloat sphereSDF( vec3 p, Sphere sphere ) \n{   \n    return length(p - sphere.center) - sphere.radius;\n}\n\nfloat boxSDF( vec3 p, Box box )\n{\n    vec3 d = abs(p - box.center) - box.size/2.;\n    return length(max(d,0.0)) - box.roundness;  \n}\n\nfloat ballsSDF(vec3 p) \n{\n    float unionBallsSDF = MAX_DIST;\n    for (int i=0; i<currBallsAmount; ++i)\n    {\n    \tSphere sphere = Sphere(ballsPositions[i], RADIUS);\n    \tunionBallsSDF = min(unionBallsSDF, sphereSDF(p, sphere));\n    }\n    return unionBallsSDF;\n}\n\nfloat racketsSDF(vec3 p) \n{\n    vec3 boxPosRight = vec3(rightRacketPos.x,rightRacketPos.y,0.0);\n    vec3 boxPosLeft = -boxPosRight;\n\n    vec3 size = vec3(0.02,0.2,0.4); // width, height, depth \n    \n#ifdef TEST_MODE\n    size.y *= 4.0;\n#endif\n    \n    float roundness = 0.02;\n    Box boxLeft = Box(boxPosLeft,size,roundness);\n    Box boxRight = Box(boxPosRight,size,roundness);        \n    float racketLeftSDF = boxSDF(p, boxLeft);\n    float racketRightSDF = boxSDF(p, boxRight);\n    // union rackets SDFs\n    return min(racketLeftSDF, racketRightSDF); \n}\n\n//////////////////////////////////////////////////////////////////////////////////////////\n// common functions\n//////////////////////////////////////////////////////////////////////////////////////////\n\n#define GRADIENT(SDF) vec3(\\\n\tSDF(vec3(p.x + EPSILON, p.y, p.z)) - SDF(vec3(p.x - EPSILON, p.y, p.z)), \\\n\tSDF(vec3(p.x, p.y + EPSILON, p.z)) - SDF(vec3(p.x, p.y - EPSILON, p.z)), \\\n    SDF(vec3(p.x, p.y, p.z  + EPSILON)) - SDF(vec3(p.x, p.y, p.z - EPSILON)))\n\n\nvec3 estimateNormal(vec3 p, int surface) \n{\n    // Using an approximation of the gradient of the SDF. \n    vec3 gradient;\n    if (surface == BALLS_SURFACE) \n        gradient =  GRADIENT(ballsSDF);\n    else{\n        gradient =  GRADIENT(racketsSDF);\n    }\n    if (gradient == vec3(0.))\n        return vec3(0.);\n    return normalize(gradient);\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////////\n// coordinate transform\n//////////////////////////////////////////////////////////////////////////////////////////\n\nfloat aspect;\n\nvec3 toWorldSpace3D (vec2 uv) \n{\n    // Transfer from screen space to world space\n    uv.x = uv.x*2.0-1.0;\n    uv.y = (uv.y*2.0-1.0)/aspect;\n    return vec3(uv.x,uv.y,0.0);\n}\n\n","name":"Common","description":"","type":"common"}]}