{"ver":"0.1","info":{"id":"ctKBD3","date":"1702629374","viewed":70,"name":"Triangle AABB","username":"huangziji","description":"3d","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// From paper Fast 3D Triangle-Box Overlap Testing by Akenine-Moller\n\nbool aabbIntersect(vec3 a1, vec3 a2, vec3 b1, vec3 b2)\n{\n    return all(lessThanEqual(a1, b2)) && all(greaterThanEqual(a2,b1));\n}\n\nbool triangleAabbIntersect(vec3 p, vec3 q, mat3 v)\n{\n    vec3 tmin = min(min(v[0],v[1]),v[2]);\n    vec3 tmax = max(max(v[0],v[1]),v[2]);\n    if (!aabbIntersect(p, q, tmin, tmax)) {\n        return false;\n    }\n    \n    // triangle-normal\n\tvec3 n = normalize(cross(v[1]-v[0], v[2]-v[1]));\n\n\t// p & delta-p\n\tvec3 dp = q - p;\n\n\t// test for triangle-plane/box overlap\n\tvec3 c = max(sign(n),0.) * dp;\n\n\tfloat d1 = dot(n, c - v[0]);\n\tfloat d2 = dot(n, dp - c - v[0]);\n\n\tif ((dot(n, p) + d1) * (dot(n, p) + d2) > 0.f)\n\t\treturn false;\n\n    mat3 e = mat3(v[1],v[2],v[0]) - v;\n\n    // xy-plane projection-overlap\n    float xym = sign(n.z);\n\tvec2 ne0xy = vec2(-e[0].y, e[0].x) * xym;\n\tvec2 ne1xy = vec2(-e[1].y, e[1].x) * xym;\n\tvec2 ne2xy = vec2(-e[2].y, e[2].x) * xym;\n\n\tvec2 v0xy = v[0].xy;\n\tvec2 v1xy = v[1].xy;\n\tvec2 v2xy = v[2].xy;\n\n\tfloat de0xy = -dot(ne0xy, v0xy) + max(0.f, dp.x * ne0xy.x) + max(0.f, dp.y * ne0xy.y);\n\tfloat de1xy = -dot(ne1xy, v1xy) + max(0.f, dp.x * ne1xy.x) + max(0.f, dp.y * ne1xy.y);\n\tfloat de2xy = -dot(ne2xy, v2xy) + max(0.f, dp.x * ne2xy.x) + max(0.f, dp.y * ne2xy.y);\n\n\tif ((dot(ne0xy, p.xy) + de0xy) < 0.f ||\n        (dot(ne1xy, p.xy) + de1xy) < 0.f ||\n        (dot(ne2xy, p.xy) + de2xy) < 0.f)\n\t\treturn false;\n\n    // yz-plane projection overlap\n\tfloat yzm = sign(n.x);\n\tvec2 ne0yz = vec2(-e[0].z, e[0].y) * yzm;\n\tvec2 ne1yz = vec2(-e[1].z, e[1].y) * yzm;\n\tvec2 ne2yz = vec2(-e[2].z, e[2].y) * yzm;\n    \n\tvec2 v0yz = v[0].yz;\n\tvec2 v1yz = v[1].yz;\n\tvec2 v2yz = v[2].yz;\n\n\tfloat de0yz = -dot(ne0yz, v0yz) + max(0.f, dp.y * ne0yz.x) + max(0.f, dp.z * ne0yz.y);\n\tfloat de1yz = -dot(ne1yz, v1yz) + max(0.f, dp.y * ne1yz.x) + max(0.f, dp.z * ne1yz.y);\n\tfloat de2yz = -dot(ne2yz, v2yz) + max(0.f, dp.y * ne2yz.x) + max(0.f, dp.z * ne2yz.y);\n\n\tif ((dot(ne0yz, p.yz) + de0yz) < 0.f ||\n        (dot(ne1yz, p.yz) + de1yz) < 0.f ||\n        (dot(ne2yz, p.yz) + de2yz) < 0.f)\n\t\treturn false;    \n    \n    // zx-plane projection overlap\n\tfloat zxm = sign(n.y);\n\tvec2 ne0zx = e[0].xz * vec2(-1,1) * zxm;\n\tvec2 ne1zx = e[1].xz * vec2(-1,1) * zxm;\n\tvec2 ne2zx = e[2].xz * vec2(-1,1) * zxm;\n    \n\tvec2 v0zx = v[0].zx;\n\tvec2 v1zx = v[1].zx;\n\tvec2 v2zx = v[2].zx;\n\n\tfloat de0zx = -dot(ne0zx, v0zx) + max(0.f, dp.z * ne0zx.x) + max(0.f, dp.x * ne0zx.y);\n\tfloat de1zx = -dot(ne1zx, v1zx) + max(0.f, dp.z * ne1zx.x) + max(0.f, dp.x * ne1zx.y);\n\tfloat de2zx = -dot(ne2zx, v2zx) + max(0.f, dp.z * ne2zx.x) + max(0.f, dp.x * ne2zx.y);\n\n\tif ((dot(ne0zx, p.zx) + de0zx) < 0.f ||\n        (dot(ne1zx, p.zx) + de1zx) < 0.f ||\n        (dot(ne2zx, p.zx) + de2zx) < 0.f)\n\t\treturn false;\n    \n    return true;\n}\n\nvec3 v1,v2,v3;\n\nfloat map( in vec3 p )\n{\n    // triangle\t\n\tv1 = 1.5*cos( iTime + vec3(0.0,1.0,1.0) + 0.0 );\n\tv2 = 1.0*cos( iTime + vec3(0.0,2.0,3.0) + 2.0 );\n\tv3 = 1.0*cos( iTime + vec3(0.0,3.0,5.0) + 4.0 );\n\n    v1 *= 2.;\n    v2 *= 2.;\n    v3 *= 2.;\n    \n\tfloat d1 = udTriangle( v1, v2, v3, p ) - 0.01;\n\n    // ground plane\n\tfloat d2 = p.y + 2.0;\n\n    return min( d1, d2 );\t\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.002,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy) - map(pos-eps.xyy),\n           map(pos+eps.yxy) - map(pos-eps.yxy),\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = 0.0;\n\tfloat h = 1.0;\n    for( int i=0; i<20; i++ )\n    {\n        h = map(ro + rd*t);\n        res = min( res, k*h/t );\n\t\tt += clamp( h, 0.01, 1.0 );\n\t\tif( h<0.0001 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.02 + 0.025*float(i*i);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return 1.0 - clamp( occ, 0.0, 1.0 );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    float ti = iTime;\n\n    vec3 ta = vec3(0.0);\n\tvec3 ro = ta + vec3(2.0*sin(ti), 0.5, 2.0*cos(ti) )*3.;\n    mat3 ca = setCamera(ro, ta, 0.0);\n\tvec3 rd = ca*normalize( vec3(p,1.2) );\n\n    const float maxd = 10.0;\n\tfloat h = 1.0;\n    float t = 0.0;\n    for( int i=0; i<50; i++ )\n    {\n        if( h<0.001 || t>maxd ) break;\n\t    h = map( ro+rd*t );\n        t += h;\n    }\n\n\tvec3 col = vec3(0.0);\t\n    if( t<maxd ) {\n        const vec3 lig = normalize(vec3(1.0,0.9,0.7));\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\t\tfloat sha = calcSoftshadow( pos + nor*0.01, lig, 32.0 );\n\t\tfloat occ = calcOcclusion( pos, nor );\n\t\tcol =  vec3(0.9,0.6,0.3)*clamp( dot( nor, lig ), 0.0, 1.0 ) * sha;\n\t\tcol += vec3(0.5,0.6,0.7)*clamp( nor.y, 0.0, 1.0 )*occ;\n        col += 0.03;\n\t\tcol *= exp( -0.2*t );\n        col *= 1.0 - smoothstep( 5.0, 10.0, t );\n\t}\n\n\n    ivec3 mapPos = ivec3(floor(ro + 0.));\n\tivec3 rayStep = ivec3(sign(rd));\n\tvec3 deltaDist = abs(vec3(length(rd)) / rd);\n\tvec3 sideDist = ( vec3(mapPos)-ro + max(sign(rd),0.) ) / rd; \n\tvec3 mask;\n\n    float x = 0.;\n    for (int i=0; i<32; i++) {\n\t\tif (triangleAabbIntersect(vec3(mapPos), vec3(mapPos)+1., mat3(v1,v2,v3))) { x++; }\n            mask = step(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n\t\t\tsideDist += mask * deltaDist;\n\t\t\tmapPos += ivec3(mask) * rayStep;\n\t}\n\t\n    if (x > 0.) {\n        col += x*.03;//dot(mask, vec3(.5,1.,.75));\n    }\n\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//https://www.shadertoy.com/view/4sXXRN\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat udTriangle( in vec3 v1, in vec3 v2, in vec3 v3, in vec3 p )\n{\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v13 = v1 - v3; vec3 p3 = p - v3;\n    vec3 nor = cross( v21, v13 );\n\n    return sqrt( (sign(dot(cross(v21,nor),p1)) + \n                  sign(dot(cross(v32,nor),p2)) + \n                  sign(dot(cross(v13,nor),p3))<2.0) \n                  ?\n                  min( min( \n                  dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                  dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                  dot2(v13*clamp(dot(v13,p3)/dot2(v13),0.0,1.0)-p3) )\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor) );\n}","name":"Common","description":"","type":"common"}]}