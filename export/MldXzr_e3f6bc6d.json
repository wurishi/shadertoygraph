{"ver":"0.1","info":{"id":"MldXzr","date":"1477935879","viewed":155,"name":"WIP raymarching /w volumetric li","username":"efairbanks","description":"just workin' on it","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["wipraymarchin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MARCH_STEPS 100.0\n#define MARCH_EPSILON 0.01\n#define SHADOW_STEPS 50.0\n#define SHADOW_EPSILON 0.01\n#define GRADIENT_STEP 0.01\n#define MAX_REFLECTIONS 10.0\n#define MIN_DRAW_DISTANCE 1.0\n#define MAX_DRAW_DISTANCE 27.5\n#define SHADOWS_MIN_DISTANCE 1.0\n#define SHADOWS_MAX_DISTANCE 4.5\n\nconst vec3 FOG_COLOR = vec3(0.9, 0.95, 1.0);\n\nstruct Intersection\n{\n\tvec3 p; //pos\n    vec3 n; //normal\n\tfloat d; //distance\n    bool hit; //hit?\n};\n\nstruct Color\n{\n\tvec3 a; //ambient\n\tvec3 d; //diffuse\n\tvec3 s; //specular\n    vec3 r; //reflective\n};\n    \nstruct Surface\n{\n    Intersection i;\n    Color c;\n};\n\nstruct Light\n{\n\tvec3 p;\n\tvec3 c;\n};\n    \nstruct Ray\n{\n\tvec3 origin;\n\tvec3 dir;\n};\n    \n// ----- //\n// ----- //\n// ----- //\n\nSurface sphere(vec3 p, float s, Color c)\n{\n    Surface surf;\n    surf.i.d = length(p)-s;\n    surf.c = c;\n    return surf;\n}\n\nSurface box(vec3 p, vec3 b, float roundness, Color c)\n{\n    Surface surf;\n    surf.i.d = length(max(abs(p)-(b-vec3(roundness)),0.0))-roundness;\n    surf.c = c;\n    return surf;\n}\n\nSurface plane(vec3 p, float height, float radius, Color c)\n{\n\tSurface surf;\n    surf.i.d = max(length(p.xz)-radius, -p.y - height);\n    surf.c = c;\n    return surf;\n}\n\nSurface _min(Surface a, Surface b)\n{\n\tif(a.i.d > b.i.d) return b;\n    return a;\n}\n\nSurface _max(Surface a, Surface b)\n{\n\tif(a.i.d > b.i.d) return a;\n    return b;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5+0.5*(b-a)/k,0.0,1.0);\n    return mix(b,a,h)-k*h*(1.0-h);\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453 + iTime);\n}\n\n// ----- //\n// ----- //\n// ----- //\n\n#define FOV 0.85\n#define CAMERA_DISTANCE 12.\n\nSurface map(vec3 p)\n{\n    vec3 q = p;\n    Color c;\n    \n    c.a = vec3(0.1, 0.1, 0.1);\n    c.d = vec3(0.5, 0.9, 0.5);\n    c.s = vec3(0.5, 0.5, 0.5);\n    c.r = vec3(0.0, 0.0, 0.0);\n    Surface d = sphere(p, 1., c);\n    \n    q.x = q.x + 5.;\n    q.y = q.y + 1.;\n    c.a = vec3(0.0, 0.0, 0.0);\n    c.d = vec3(0.7, 0.45, 0.75);\n    c.s = vec3(0.6, 0.35, 0.75);\n    c.r = vec3(0.05, 0.05, 0.05);\n    d = _min(d, sphere(q, 2., c));\n    \n    q = p;\n    q.x = q.x - 5. + sin(q.y*5.+iTime*3.)/40.;\n    q.z = q.z + 2. + cos(q.y*5.+iTime*3.)/40.;\n    q.y = q.y + 1.;\n    c.a = vec3(0.0, 0.0, 0.0);\n    c.d = vec3(0.1, 0.05, 0.05);\n    c.s = vec3(0.1, 0.05, 0.05);\n    c.r = vec3(0.8, 0.8, 0.8);\n    d = _min(d, sphere(q, 2., c));\n    \n    float rings = (mod(length(p.xz), 1.) > 0.5 ? 0.0 : 1.0)/8.;\n    \n    c.a = vec3(0.1, 0.1, 0.2) + rings;\n    c.d = vec3(0.5, 0.5, 0.5);\n    c.s = vec3(0.1, 0.1, 0.1);\n    c.r = vec3(0.0, 0.0, 0.0);\n    d = _min(d, plane(p, -1., 10., c));\n    \n    return d;\n}\n\n// ----- //\n// ----- //\n// ----- //\n\nvec3 calcNormal(vec3 pos)\n{\n    const vec3 dx = vec3( GRADIENT_STEP, 0.0, 0.0 );\n    const vec3 dy = vec3( 0.0, GRADIENT_STEP, 0.0 );\n    const vec3 dz = vec3( 0.0, 0.0, GRADIENT_STEP );\n    return normalize(vec3(\n        map( pos + dx ).i.d - map( pos - dx ).i.d,\n        map( pos + dy ).i.d - map( pos - dy ).i.d,\n        map( pos + dz ).i.d - map( pos - dz ).i.d\n    ));\n}\n\n/*\n\tvec3 pos;\n    vec3 norm;\n\tfloat dist;\n    bool hit;\n*/\n\n/*\n\tvec3 ambient;\n\tvec3 diffuse;\n\tvec3 specular;\n    vec3 reflective;\n*/\n\n/*\n\tvec3 origin;\n\tvec3 dir;\n*/\n\nSurface castRay( in vec3 ro, in vec3 rd )\n{\n    Surface surface;\n    surface.i.hit = false;\n    \n    float tmin = MIN_DRAW_DISTANCE;\n    float tmax = MAX_DRAW_DISTANCE;\n\n    float precis = MARCH_EPSILON;\n    float t = tmin;\n    for(int i=0; i<int(MARCH_STEPS); i++)\n    {\n        surface = map( ro+rd*t );\n        float res = surface.i.d;\n        if(res<precis) {\n            surface.i.p = ro + t*rd;\n            surface.i.n = calcNormal(surface.i.p);\n            surface.i.d = t;\n            surface.i.hit = true;\n        }\n        if(t>tmax) break;\n        t += res;\n    }\n    return surface;\n}\n\nfloat calcDiffuse(Surface s, Light l)\n{\n    return max(dot(s.i.n ,normalize(l.p)),0.);\n}\n\nfloat calcSpecular(Surface s, Light l)\n{\n\treturn pow(calcDiffuse(s, l), 30.);\n}\n\nfloat calcShadows(Surface s, Light l)\n{\n    vec3 ro = s.i.p;\n    vec3 rd = l.p;\n    float res = 1.0;\n    float t = SHADOWS_MIN_DISTANCE;\n    for(int i=0; i<int(SHADOW_STEPS); i++)\n    {\n        float h = map(ro + rd*t).i.d;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if(h<SHADOW_EPSILON || t>SHADOWS_MAX_DISTANCE) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 calcLight(Surface s, Light l)\n{\n    vec3 c = vec3(0.0);\n    if(s.i.hit) {\n        c += vec3(calcDiffuse(s, l))*s.c.d;\n        c += vec3(calcSpecular(s, l))*s.c.s;\n        c *= calcShadows(s, l);\n        c += s.c.a;\n    } else {\n   \t\tc = FOG_COLOR;\n    }\n    return c;\n}\n\nvec3 calcLightAndReflections(Surface s, Light l) {\n\tvec3 c = calcLight(s, l);\n    Surface reflection = castRay(s.i.p, s.i.n);\n    c = c+calcLight(reflection, l)*s.c.r;\n    return c;\n}\n\nRay cameraRay(vec2 scanLines, vec3 cameraPosition, vec3 target, float fov)\n{\n    Ray camRay;\n    \n    vec3 forward = normalize(target-cameraPosition);\n    vec3 up = vec3(0.,1.,0.);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(forward,right));\n\n    right = right*scanLines.x*fov;\n    up = up*scanLines.y*fov;\n    \n    camRay.origin = cameraPosition;\n    camRay.dir = (right+up+forward);\n    \n    return camRay;\n}\n\nvec2 scaleCoords(vec2 coords) {\n    vec2 uv = coords.xy / iResolution.xy;\n    uv = uv*2.-1.;\n    uv.x = uv.x*iResolution.x/iResolution.y;\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = scaleCoords(fragCoord.xy);\n\n    Ray camRay = cameraRay(\n        \t\t\tuv,\n        \t\t\tvec3(\n                    \t-0.7,//-sin(iTime),\n        \t\t\t\t-0.2,\n        \t\t\t\t-0.7)*CAMERA_DISTANCE,//-cos(iTime))*CAMERA_DISTANCE,\n                    vec3(0.),\n                    FOV\n                );\n\n    Surface surf = castRay(camRay.origin, camRay.dir);\n\n    Light light;\n    vec3 color;\n    \n    //light.p = vec3(-1.);\n    //light.c = vec3(1.);\n    //color += calcLightAndReflections(surf, light)/2.;\n    light.p = vec3(cos(-iTime/3.3), -0.3, sin(-iTime/3.3));\n    light.c = vec3(0.9, 0.3, 0.7);\n    color += calcLightAndReflections(surf, light);\n\n    //volumetric???\n    float distFromCam = distance(surf.i.p, camRay.origin);\n    float distInterp = distFromCam/MAX_DRAW_DISTANCE;    \n    float volumetric = 0.;\n   \tconst float volume_step = 0.025;\n    for(float i=volume_step; i<1.; i+=volume_step) {\n        Surface s = surf;\n        s.i.p = camRay.origin + camRay.dir*distFromCam*i;\n        s.i.d = distFromCam*i;\n    \tvolumetric += min(calcShadows(s, light),1.)/(1./volume_step);\n    }\n   \tcolor = color*(1.-distInterp) + (FOG_COLOR*distInterp*min(volumetric,1.));\n    \n    // vignette and contrast\n    uv.y *= iResolution.x/iResolution.y;\n    color *= pow(min(max(2.6-length(uv), 0.), 1.), 0.125);\n    color.x = pow(color.x, 1.1);\n    color.y = pow(color.y, 1.1);\n    color.z = pow(color.z, 1.1);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}