{"ver":"0.1","info":{"id":"tldBRj","date":"1718212066","viewed":38,"name":"SphereTestPlanet","username":"Xadhoom","description":"sphere_test","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["blabla"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sphereSdf(in vec3 pos,in vec3 center,in float radius)\n{\n    return distance(pos,center)-radius;\n}\n\nmat3 worldSpaceToNewRf(vec3 newZ /*cameraDir*/)\n{\n    vec3 newXaxe;\n    vec3 newYaxe;\n    if(abs(dot(newZ,vec3(0.0,1.0,0.0)))!=1.0)\n    {\n    \tnewXaxe = normalize(cross(newZ,vec3(0.0,1.0,0.0)));\n        newYaxe = normalize(cross(newXaxe,newZ));\n    }\n    else\n    {\n        newYaxe = normalize(cross(newZ,vec3(1.0,0.0,0.0)));\n        newXaxe = normalize(cross(newYaxe,newZ));\n    }\n   \n    return mat3(newXaxe,newYaxe,newZ);\n}\n\nvec3 estimateSphereNormals(in vec3 pos,in vec3 center,in float radius)\n{\n    float epsilon = 0.001;\n    float nx = sphereSdf(pos+vec3(epsilon,0.0,0.0),center,radius)-sphereSdf(pos-vec3(epsilon,0.0,0.0),center,radius);\n    float ny = sphereSdf(pos+vec3(0.0,epsilon,0.0),center,radius)-sphereSdf(pos-vec3(0.0,epsilon,0.0),center,radius);\n    float nz = sphereSdf(pos+vec3(0.0,0.0,epsilon),center,radius) - sphereSdf(pos-vec3(0.0,0.0,epsilon),center,radius);\n    return normalize(vec3(nx,ny,nz));\n}\n\nvec2 sphericalUV(in vec3 surfacePoint, in vec3 sphereCenter, in float radius)\n{\n    vec3 dist = surfacePoint-sphereCenter;\n    float phi = atan(dist.y/dist.x);\n    float theta = acos(dist.z/radius);\n    return vec2(0.5*(2.0*phi/(3.14)+1.0),(theta/(3.14)+1.0)*0.5);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec3 cameraPos= vec3(10.0, 0.0,0.0);       \n    const vec3 cameraDir =normalize(vec3(-1.0, 0.0,0.0));\n    const float cameraFoV = 3.14*0.25;\n    vec3 starPos=vec3(0.0);\n    const float starRadius= 1.0;\n    const vec4 starColor=vec4(1.0,0.9,0.5,0.0);\n    \n    const vec3 orbitPlaneNormal = normalize(vec3(0.0,1.0,0.1));\n    mat3 tranfMat = worldSpaceToNewRf(orbitPlaneNormal);\n    const float ellipseMajorSemiAxis = 3.5;\n    const float ellipseMinorSemiAxis = 2.5;    \n    vec3 planetPos=tranfMat*vec3(ellipseMinorSemiAxis*cos(iTime),ellipseMajorSemiAxis*sin(iTime),0.0);\n    const float planetRadius= 0.5;\n    const vec4 planetColor=vec4(1.0,0.0,0.0,0.0);\n    \n    float diagonal = length(iResolution.xy);\n    vec2 uv =  2.0*((fragCoord-0.5*iResolution.xy)/diagonal);\n \n    const float epsilon = 0.0001;\n    \n    vec3 rayDir = normalize(vec3(uv,1.0/tan(cameraFoV*0.5))); \n    mat3 worldToCameraSpace = worldSpaceToNewRf(cameraDir);\n    rayDir = worldToCameraSpace*rayDir; //pay attention to the order of multiplication\n    \n    vec3 rayPos = cameraPos;\n    float sdf = 1.0;\n    float starSdf = 1.0;\n    float planetSdf =1.0;\n    vec4 color=vec4(0.0);\n    const float maxDist =20.0;\n    int steps =0;\n    \n    planetPos = worldToCameraSpace*planetPos;\n    starPos = worldToCameraSpace*starPos;\n    while(sdf <maxDist)\n    {\n        planetSdf = sphereSdf(rayPos,planetPos,planetRadius);\n        starSdf =  sphereSdf(rayPos,starPos,starRadius);\n        sdf = min(planetSdf,starSdf);\n        if(sdf>epsilon)\n        {\n            rayPos += rayDir*sdf;\n        }\n        else\n        {\n            if(starSdf<epsilon)\n            {\n                vec3 surfNormal = estimateSphereNormals(rayPos,starPos,starRadius);\n                vec4 brightness = (1.0-abs(dot(surfNormal,cameraDir)))*vec4(1.0,1.0,0.7,0.0);\n                vec2 uv = sphericalUV(rayPos,starPos,starRadius)+sin(iTime/50.0)+cos(iTime/50.0);\n                color=mix(starColor,planetColor,texture(iChannel0,uv))+brightness;                \n            }\n            else if(planetSdf<epsilon)\n            {\n                vec3 surfNormal = estimateSphereNormals(rayPos,planetPos,planetRadius);\n                vec4 light = max(0.0,dot(surfNormal,normalize(starPos-rayPos)))*starColor/dot(rayPos-starPos,rayPos-starPos);\n                vec2 uv = sphericalUV(rayPos,planetPos,planetRadius);\n                color=texture(iChannel0,uv)*(5.0*light+starColor*0.3);\n            }\n            break;\n        }\n    }\n    \n    fragColor =color+float(steps/100)*vec4(1.0,1.0,0.7,0.0);\n   \n}","name":"Image","description":"","type":"image"}]}