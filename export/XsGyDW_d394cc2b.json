{"ver":"0.1","info":{"id":"XsGyDW","date":"1522099138","viewed":985,"name":"Generalized Abelian Sandpile","username":"chronos","description":"Further improvements and generalization of the previous Abelian Sandpile shaders.\nGo ahead and play with parameters under the 'Common' tab!","likes":27,"published":1,"flags":48,"usePreview":0,"tags":["cellular","smooth","automaton","generalized","sandpile","abelian","criticality"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \n\t|------------------------------------------------------|\n\t|Generalized Smooth Abelian Sandpile Shader by  Chronos|\n\t|------------------------------------------------------|\n\t\n\tGo ahead and play with parameters under the 'Common' tab!\n\n\n\tGeneralizes the discrete abelian sandpile in several ways:\n\t\t- Smooth transition function\n\t\t- \"Virtual\" \"continuous\" cell model\n\t\t- Arbitrary sized cell neighborhoods\n\n\tGeneralized Model exhibits similar qualitative properties as the original\n\n\tSetting appropriate parameters reveals oscilating 'Reaction-Diffusion' - like patterns\n\n\tStandard Abelian Sandpile Model can be retrieved\n\tby setting appropriate parameters (Found in 'Common'-tab)\n\n\tNew: \n\t'Faithful' (to original model) update rule (off by default, found in 'Common' tab)\n\tremoves diffusive property from point density accumulation,\n\tcausing more intricate stable configurations, as in the original model.\n\n*/\nfloat SampleBuffer(ivec2 p) { return texelFetch(iChannel0, p, 0).x; }\nvec3 GetNormal(vec2 P)\n{\n    ivec2 p = ivec2(P);\n    float dx = \n        \t( SampleBuffer(p+ivec2( 1,  1)) - SampleBuffer(p+ivec2( -1,  1))\n        \t+ SampleBuffer(p+ivec2( 1,  0)) - SampleBuffer(p+ivec2( -1,  0))\n    \t\t+ SampleBuffer(p+ivec2( 1, -1)) - SampleBuffer(p+ivec2( -1, -1))\n    \t\t) / 3.;\n    \n    float dy =\n        \t( SampleBuffer(p+ivec2( 1,  1)) - SampleBuffer(p+ivec2( 1, -1))\n    \t\t+ SampleBuffer(p+ivec2( 0,  1)) - SampleBuffer(p+ivec2( 0, -1))\n    \t\t+ SampleBuffer(p+ivec2(-1,  1)) - SampleBuffer(p+ivec2( 1, -1))\n            ) / 3.;\n    \n    vec2 dxdy = vec2(dx, dy);\n    if(length(dxdy) < 0.0000001) return vec3(0.,0.,1.);\n    float dz = sqrt(abs(1.-dot(dxdy, dxdy)));\n    vec3 Normal = vec3(normalize(dxdy), dz);\n    Normal = normalize(Normal);\n    return Normal;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = vec3(0.);\n#if NO_LIGHTING\n    vec4 buffer = texture(iChannel0, uv);\n    color = buffer.rrr;\n#else\n    vec2 Aspect = iResolution.xy / iResolution.yy;\n    \n    vec3 N = GetNormal(fragCoord);\t\t\t\t\t// Normal\n    vec3 L = normalize(vec3(cos(iTime),sin(iTime), 1.));\t// Light Vector\n    vec3 V = normalize(vec3((2. * (uv - .5) / Aspect), 1.));// View Vector\n    vec3 R = 2. * dot(N, V) * N - V;\t\t\t\t\t\t// Reflection Vector\n    vec3 H = normalize((N+V)/2.);\t\t\t\t\t\t\t// Half vector\n    vec3 ReflectionColor = texture(iChannel1, -R).rgb;\n    color = \n        vec3(0.2, .1, .05) + \n        ( ReflectionColor * (1. + .1 * vec3(0.7, 0.7, 0.3))) * dot(N, L) +\n        vec3(1., 1., 1.) * pow(dot(H, L), 20.);\n#endif\n\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float transition(float x)\n{\n    //return min(floor(x), 1.); // or (1.-step(1., x)); // original rule\n    return \n        // modified rule\n        threshold * smoothstep(threshold-threshold_smoothing, threshold+threshold_smoothing, x); \n}\n\nfloat GetInnerWeight(float offset_length)\n{\n    //return step(offset_length, inner_radius); //offset_length <= inner_radius ? 1. : 0.;\n    float eps = max( cell_smoothing, 0.0001); // Fixes smoothstep not degenerating into step for some reason\n    return 1.-smoothstep(inner_radius-eps, inner_radius+eps, offset_length);\n}\n\nfloat GetOuterWeight(float offset_length)\n{\n    float InnerWeight = GetInnerWeight(offset_length); // TODO: Optimize away unnecessary recompute\n    float eps = max(cell_smoothing, 0.0001); // Fixes smoothstep not degenerating into step for some reason\n    float w = 1.-smoothstep(outer_radius-eps, outer_radius+eps, offset_length);\n    return (1. - InnerWeight) * w; // offset_length <= float(r) ? (1.-InnerWeight) : 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    ivec2 p = ivec2(fragCoord.xy); \n    // Fill with toppling neighbors\n    // Nonuniform weighting, sums to 1\n    // TODO: Generalize to larger neighborhoods with more general weights, weights should be normalized to 1 (Completed)\n    // TODO: Get previous frame topple activation indication from alpha channel of neighbors,\n    //       instead of recomputing transition function for each neighbor (Completed)\n    \n    float OuterAccumulation = 0.;\n    float InnerAccumulation = 0.;\n    \n    float InnerWeightTotal = 0.;\n    float OuterWeightTotal = 0.;\n    for(int i = -r; i <= r; i++)\n    {\n     \tfor(int j = -r; j <= r; j++)\n    \t{\n            // TODO: Combine inner and outer accumulation (and Weights) into vec2 operations\n            // Keeping it like this, as it is clearer\n        \tivec2 offset = ivec2(i, j);\n            float offset_length = DISTANCE_METRIC(vec2(offset));\n            vec4 NeighborSample = texelFetch(iChannel0, p + offset, 0);\n            float NeighborActivation = NeighborSample.a;\n            float LocalAccumulation  = NeighborSample.r;\n            float InnerWeight = GetInnerWeight(offset_length); \n            float OuterWeight = GetOuterWeight(offset_length);\n            \n            OuterAccumulation += OuterWeight * NeighborActivation;\n            InnerAccumulation += InnerWeight * LocalAccumulation;\n            \n            InnerWeightTotal += InnerWeight;\n            OuterWeightTotal += OuterWeight;\n    \t}   \n    }\n\n    // TODO: Decide toppling activation based on accumulation in small radius\n    // instead of only center pixel (Completed)\n    float AnnulusActivation = (OuterAccumulation / OuterWeightTotal);\n    float DiskAccumulation  = (InnerAccumulation / InnerWeightTotal);\n    float Accumulation = AnnulusActivation + DiskAccumulation;\n    \n    // Decide whether to topple, given by transition function\n    float Activation = transition(Accumulation);\n\n    #if FAITHFUL_UPDATE_RULE || CONTINUOUS_TIMESTEP\n    \tfloat PreviousAccumulation = texelFetch(iChannel0, p, 0).r;\n    #endif\n    \n    #if FAITHFUL_UPDATE_RULE\n    \tAccumulation = PreviousAccumulation + AnnulusActivation - Activation;\n    #else\n    \tAccumulation -= Activation;\n    #endif\n\n    #if CONTINUOUS_TIMESTEP\n    \tAccumulation = mix(PreviousAccumulation, Accumulation, timestep);\n    #endif\n\n    // TODO: Move initialization and interaction logic to separate buffer\n\t#if USE_MOUSE\n     \tAccumulation += 0.3*threshold*smoothstep(.04, 0.03, length((iMouse.xy - fragCoord)/iResolution.xx));\n\t#endif\n    if(iFrame < 10 || texture( iChannel1, vec2(32.5/256.0, 0.5) ).x > 0.5) \n    {\t\n        // (Re-)initialization logic\n        Accumulation = threshold*smoothstep(1.0, 0., length(fragCoord.xy/iResolution.xx- vec2(0.5,0.3)));\n        Activation = 0.;\n    }\n\n    // TODO: Pass topple activation result to next frame via alpha channel (Completed)\n    // TODO: Pass current neighbor count, so that neighbors may calculate contribusion strength\n    //       in case of simulation being run on a bounding region substrate\n\n    vec4 State = vec4(vec3(Accumulation), Activation);\n\tfragColor = clamp(State, 0., 1.);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\n\tNew: \n\t'Faithful' (to original model) update rule removes diffusive property from \n\tpoint density accumulation, causing more intricate stable configurations,\n\tas in the original model.\n*/\n#define FAITHFUL_UPDATE_RULE 0\n\n#define CONTINUOUS_TIMESTEP 0\n\n#define USE_MOUSE 1\n#define NO_LIGHTING 0\n\n#define EUCLIDEAN(P) (length(P))\n#define CHEBYSHEV(P) (max(abs((P).x), abs(P).y))\n#define MANHATTAN(P) (abs(P).x + abs(P).y)\n\n#define DISTANCE_METRIC EUCLIDEAN\n\nconst float threshold = 0.5;\nconst float threshold_smoothing = 0.04;\nconst float cell_smoothing = 1.5;\n\nconst float outer_radius = 6.;\nconst float inner_radius = outer_radius/3.0;\n\nconst int r = int(outer_radius)+1; // Neighbor sampling radius\n\n#if CONTINUOUS_TIMESTEP\n\tconst float timestep = 0.05;\n#endif\n\n\n\n// Various Parameter configurations:\n/* \n//Defaults\n#define DISTANCE_METRIC EUCLIDEAN\n\nconst float threshold = 0.5;\nconst float threshold_smoothing = 0.04;\nconst float cell_smoothing = 1.5;\n\nconst float outer_radius = 6.;\nconst float inner_radius = outer_radius/3.0;\n\nconst int r = int(outer_radius)+1; // Neighbor sampling radius\n*/\n\n/*\n// Regular Abelian Sandpile Model\n#define DISTANCE_METRIC MANHATTAN\n\nconst float threshold = 0.5;\nconst float threshold_smoothing = 0.00;\nconst float cell_smoothing = 0.0;\n\nconst float outer_radius = 1.;\nconst float inner_radius = outer_radius/2.0;\n\nconst int r = int(outer_radius)+1; // Neighbor sampling radius\n*/","name":"Common","description":"","type":"common"}]}