{"ver":"0.1","info":{"id":"wtyyWy","date":"1611717729","viewed":89,"name":"juliabulb","username":"milez770","description":"julia fork of mandelbulb","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["mandelbulb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ITER 3\n#define MAX_STEPS 100\n#define MAX_DIST 10.\n#define SURF_DIST 0.002\n#define SPEED 10.\n\nfloat dist(vec2 p, vec2 t){\n    float dx = p.x-t.x;\n    float dy = p.y-t.y;\n    return sqrt(dx*dx+dy*dy);\n}\n\n// 3d mandelbulb\nfloat mandel3(in vec3 v, in vec3 c, out vec3 map){\n    vec3 r = v;\n    vec3 rNext = r;\n    float m = dot(v, v);\n    vec4 trap = vec4(abs(r), m);\n    \n    int i = 0;\n    float d = 1.;\n    \n    float n =  9.;\n    \n    for(i=0; i<ITER; i++){\n        float cr = length(r);\n        float nr = pow(cr, n);\n        //*abs(sin(iTime/5.) )\n        float accos = acos(r.z/cr);\n        float actan = atan(r.y/r.x);\n        \n        d = pow(cr, n-1.) *n * d + 1.0;\n        \n        rNext.x = nr*sin(accos*n)*cos(n*actan);\n        rNext.y = nr*sin(accos*n)*sin(n*actan);\n        rNext.z = nr*cos(n*accos);\n        r = c + rNext;\n        \n        trap = min(trap, vec4(abs(r), m));\n        map = vec3(trap.yzw);\n\n        m = dot(r,r);\n        \n        if(m > 256.){\n            break;\n        }\n    }\n    \n    return  .25*log(m) * sqrt(m) / d;\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d; \n}\n\nfloat RayMarch(in vec3 ro, in vec3 rd, out vec3 col, in vec3 c){\n    float dO = 0.;\n    \n    for(int i=0; i<MAX_STEPS; i++){\n        vec3 p = ro+rd*dO;\n        p.xz *= Rot(iTime/SPEED);\n        p.yz *= Rot(iTime/SPEED-2.);\n\n        float mbd = mandel3(abs(p), c, col);\n        float dS = mbd;\n        \n        if(dO > MAX_DIST || dS<SURF_DIST) break;\n        dO += dS;\n    }\n    \n    return dO;\n}\nvec3 GetNormal(in vec3 p, in vec3 c){\n    vec3 col;\n    // my e value made black artifacts\n    // so I took a look at iq's normal epsilone. \n    // don't exactly know how this is calculated.\n    // looks like it is relevant to some screen pixel size calculation..?\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.25*2.0/(iResolution.y*1.5);\n    \n    // getting vector with very small vector\n    vec3 n = vec3(\n        e.xyy*mandel3(p+e.xyy, c, col)+\n        e.yxy*mandel3(p+e.yxy, c, col)+\n        e.yyx*mandel3(p+e.yyx, c, col)+\n        e.xxx*mandel3(p + e.xxx, c, col ) \n    );\n    \n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/(iResolution.y);\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0,1.3, 1.3);\n    vec3 rd = R(uv, ro, vec3(0,0,0), .7);\n    \n    vec3 c = vec3( 0.9*(cos(iTime/2.)*.5-.5)-.4, 0.8*(cos(iTime/2.)*.5-.5), 0.8*(cos(iTime/2.)*.5 -.5)-.1 );\n    \n    vec3 backgrounduv;\n    \n    col = vec3(.05, .12, .1);\n    float d = RayMarch(ro, rd, backgrounduv, c);\n    col *= 3.-d;\n    col += pow(clamp(backgrounduv.z, 0., .97), 10.)*vec3(.8, .1, .1);\n    \n    //light\n    vec3 lp = vec3(1000, 1, 0);\n    lp.xz *= Rot(iTime/3.);\n    lp.yz *= Rot(iTime/3.);\n    vec3 lr = ro+rd*d;\n    lr.xz *= Rot(iTime/SPEED);\n    lr.yz *= Rot(iTime/SPEED-2.);\n    lr = abs(lr);\n    vec3 l = normalize(lp - lr);\n    vec3 n = GetNormal(lr, c);\n    float shadow = clamp(dot(n, l), 0.2, 1.);\n    shadow *= 1.;\n    col += vec3(0.1); \n    col *= vec3(pow(shadow, 1.));\n    \n    fragColor = vec4(col, 0);\n}","name":"Image","description":"","type":"image"}]}