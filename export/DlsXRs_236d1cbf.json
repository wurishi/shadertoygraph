{"ver":"0.1","info":{"id":"DlsXRs","date":"1675215882","viewed":127,"name":"Pyramid and sphere","username":"ianertson","description":"A pyramid and a sphere","likes":10,"published":1,"flags":0,"usePreview":1,"tags":["3d","raytracing","raymarching","ray","raymarch","sphere","raytrace","pyramid","desert"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define T (iTime)\n\n#define ZERO (min(0, int(iTime)))\n\n#define NEAR 0.003\n#define FAR 100.0\n#define STEPS 70\n\n#define MAX_BOUNCES 2\n\n\nfloat noise21(vec2 p, float freq, float lod) {\n    float ag = (p.x + p.y) / 2.0;\n    vec3 n = textureLod(iChannel3, vec3(p.xy*freq, ag*freq), lod).xyz;\n    return (n.x + n.y + n.z) / 3.0;\n}\n\nvec3 noise33(vec3 p, float freq, float lod) { return textureLod(iChannel3, p*freq, lod).xyz; }\n\nvec3 randomDir(vec3 normal, vec3 point, vec3 rd, float freq) {\n  vec3 tangent = normalize(cross(rd, normal));\n  vec3 bitangent = cross(normal, tangent);\n  vec3 rr = noise33(point, freq, 0.0);\n  float r1 = 2.0 * M_PI * ((rr.x+rr.z) / 2.0);\n  float r2 = (rr.y+rr.z) / 2.0;\n  float r2s = sqrt(r2);\n  return normalize(tangent * cos(r1) * r2s + bitangent * sin(r1) * r2s + normal * sqrt(1.0 - r2));\n}\n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_PYRAMID 2\n#define ID_BALL 3\n\nstruct Material {\n    float rough;\n    float metallic;\n    vec3 spec;\n    \n    vec3 bump;\n};\n\nvoid materialInit(inout Material m) {\n    m.rough = 1.0;\n    m.metallic = 0.0;\n    m.spec = vec3(0.0);\n    m.bump = vec3(0.0);\n}\n\nstruct Data {\n    vec3 point;\n    vec3 normal;\n    vec2 uv;\n    float dist;\n    float depth;\n    \n    vec3 ro;\n    vec3 rd;\n    \n    int id;\n    int skip;\n    \n    bool hit;\n    \n    Material material;\n};\n\nvoid dataInit(inout Data data) {\n    data.point = vec3(0.0);\n    data.normal = vec3(0.0);\n    data.uv = vec2(0.0);\n    data.dist = FAR;\n    data.depth = 1.0;\n    data.ro = vec3(0.0);\n    data.rd = vec3(0.0);\n    data.id = 0;\n    data.skip = 0;\n    data.hit = false;\n    \n    materialInit(data.material);\n}\n\n#define LIGHT_POINT 0\n#define LIGHT_AMBIENT 1\n\n#define NUM_LIGHTS 1\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n    float strength;\n    int type;\n};\n\nvec3 lightGetDir(in Light light, in vec3 p) {\n    switch (light.type) {\n        case LIGHT_POINT: return normalize(light.pos - p); break;\n        case LIGHT_AMBIENT: return normalize(light.pos); break;\n    }\n    \n    return vec3(0.);\n}\n\nfloat lightGetAttPoint(in Light light, in vec3 p, in vec3 n) {\n    vec3 L = lightGetDir(light, p);\n    float NdotL = max(0.0, dot(n, L));\n    float dist = distance(p, light.pos);\n    \n    return NdotL * (pow(light.strength, 2.0) / max(0.001, pow(dist, 2.0)));\n}\n\nfloat lightGetAttAmbient(in Light light, in vec3 p, in vec3 n) {\n    vec3 L = lightGetDir(light, p);\n    float NdotL = max(0.0, dot(n, L));\n    return NdotL * light.strength;\n}\n\nfloat lightGetAtt(in Light light, in vec3 p, in vec3 n) {\n    switch (light.type) {\n        case LIGHT_POINT: return lightGetAttPoint(light, p, n); break;\n        case LIGHT_AMBIENT: return lightGetAttAmbient(light, p, n); break;\n    }\n    \n    return 0.0;\n}\n\nfloat boxSDF(vec3 p, vec3 s) {\n  p = abs(p) - s;\n  return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat cylinderSDF(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    vec3 c = a + t * ab;   \n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    return e + i;\n}\n\nfloat coneSDF(vec3 p, vec2 c) {\n    float q = length(p.xz);\n    return dot(c,vec2(q,p.y));\n}\n\n#define SAMPLE(var, id_) { if (data.skip != id_ && var < dist) { data.id = id_; dist = var; } }\n\nfloat groundSDF(inout Data data, vec3 p) {\n    return p.y;\n}\n\nfloat pyramidSDF(inout Data data, vec3 p) {\n    float h = 0.2;\n    float w = 2.5;\n    \n    float s = 0.8;\n\n    float y = h;\n    float a = boxSDF(p - vec3(0.0, y, 0.0), vec3(w, h, w)); y += h+h; w *= s;\n    float b = boxSDF(p - vec3(0.0, y, 0.0), vec3(w, h, w)); y += h+h; w *= s;\n    float c = boxSDF(p - vec3(0.0, y, 0.0), vec3(w, h, w)); y += h+h; w *= s;\n    float d = boxSDF(p - vec3(0.0, y, 0.0), vec3(w, h, w)); y += h+h; w *= s;\n    float e = boxSDF(p - vec3(0.0, y, 0.0), vec3(w, h, w)); y += h+h; w *= s;\n    float f = boxSDF(p - vec3(0.0, y, 0.0), vec3(w, h, w)); y += h+h; w *= s;\n    float g = boxSDF(p - vec3(0.0, y, 0.0), vec3(w, h, w)); y += h+h; w *= s;\n       \n    return min(g, min(f, min(e, min(d, min(c, min(a, b))))));\n}\n\nfloat ballSDF(inout Data data, vec3 p) {\n    p.y -= (0.5+(0.5*sin(T-1.)));\n    return sphereSDF(p - vec3(0.0, 4.0, 0.0), 0.8);\n}\n\nfloat getDist(inout Data data, vec3 p) {\n    float dist = FAR;\n    \n    float ground = groundSDF(data, p);\n    float pyramid = pyramidSDF(data, p);\n    float ball = ballSDF(data, p);\n    \n    SAMPLE(ground, ID_GROUND);\n    SAMPLE(pyramid, ID_PYRAMID);\n    SAMPLE(ball, ID_BALL);\n    \n    return dist;\n}\n\nvec3 getNormal(inout Data data, vec3 p, float s) {\n    vec2 e = vec2(s, 0.0);\n    return normalize(getDist(data, p) - vec3(\n        getDist(data, p - e.xyy),\n        getDist(data, p - e.yxy),\n        getDist(data, p - e.yyx)\n    ));\n}\n\nvec2 getUv(inout Data data) {\n    vec3 p = data.point;\n    vec3 n = data.normal;\n    vec2 uv = vec2(0.0);\n    uv = mix(uv, p.xy, abs(dot(n, vec3(0.0, 0.0, 1.0))));\n    uv = mix(uv, p.xz, abs(dot(n, vec3(0.0, 1.0, 0.0))));\n    uv = mix(uv, p.yz, abs(dot(n, vec3(1.0, 0.0, 0.0))));\n    return uv;\n}\n\nbool march(vec3 ro, vec3 rd, inout Data data) {\n    float dist = 0.0;\n    data.ro = ro;\n    data.rd = rd;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        \n        if (abs(next) <= NEAR || abs(dist) >= FAR) break;\n    }\n    \n    dist = abs(dist);\n    if (dist >= FAR) return false;\n    \n    vec3 p = ro+rd*dist;\n    data.point = p;\n    data.dist = dist;\n    data.depth = dist / FAR;\n    data.normal = getNormal(data, p, 0.02);\n    data.uv = getUv(data);\n    data.hit = true;\n    \n    return true;\n}\n\nvec3 getClouds(inout Data data, vec3 ro, vec3 rd) {\n    vec2 uv = rd.xz / rd.y;\n    float n = 0.0;\n    float freq = 0.02;\n    float lod = 0.0;\n    \n    n += noise21(uv, freq, lod); freq *= 2.0; \n    n += noise21(uv, freq, lod); freq *= 2.0; \n    n += noise21(uv, freq, lod); freq *= 2.0; \n    n += noise21(uv, freq, lod); freq *= 2.0; \n    n += noise21(uv, freq, lod); freq *= 2.0; \n    n += noise21(uv, freq, lod); freq *= 2.0; \n    \n    n /= 6.0;\n    \n    return vec3(n);\n}\n\nvec3 getSky(inout Data data, vec3 ro, vec3 rd, in Light lights[NUM_LIGHTS]) {\n    vec3 blue = vec3(0.4, 0.6, 0.7);\n    \n    vec3 clouds = getClouds(data, ro, rd);\n    \n    vec3 col = mix(blue, vec3(1.0), clouds);\n    \n    Light light = lights[0];\n    float dotLight = max(0.0, dot(rd, lightGetDir(light, vec3(0.))));\n    vec3 flare = light.color * (pow(dotLight, 16.0) * M_PI);\n    \n    col += flare + luma(flare);\n    \n    \n    return col;\n}\n\n#define GET_ALBEDO_CASE(ID, W) case ID: return W(data, uv); break;\n\nvec3 getAlbedoSandStone(inout Data data, vec2 uv) {\n    vec3 col = vec3(0.0);\n    vec3 albedo = getTexture(iChannel2, uv, vec2(0.5, 4.0)).rgb;\n    \n    vec3 tint = vec3(245.0,200.0,167.0) / 255.0;\n    \n    col = (albedo+tint)/1.2;\n\n    data.material.spec = vec3(1.);\n    \n    return col;\n}\n\nvec3 getAlbedoSand(inout Data data, vec2 uv) {\n    vec3 col1 = vec3(245.0,200.0,167.0) / 255.0;\n    vec3 col2 = vec3(222.0,156.0,108.0) / 255.0;\n    vec3 col3 = vec3(237.0, 201.0,175.0) / 255.0;\n    \n    uv *= 32.0;\n    \n    float n = noise21(uv, 0.01, 0.);\n    float n2 = n * 2.0 - 1.0;\n    n = pow(n, 2.0);\n    n = n * 2.0 - 1.0;\n    n = mix(n, n2, 0.5);\n    n *= 5.0;\n    \n    float x = 0.5+(0.5*cos(uv.x));\n    float y = 0.5+(0.5*sin(uv.y+(x*n)));\n    \n    vec3 col = mix(col1, col2, y);\n    col = mix(col, col3, clamp(abs(n2)*2., 0.0, 1.0));\n   \n    col = compress(col+0.12);\n    \n    return col;\n}\n\nvec3 getAlbedoBall(inout Data data, vec2 uv) {\n    data.material.rough = 0.0;\n    data.material.metallic = 0.3;\n    return vec3(1.);\n}\n\nvec3 getAlbedo(inout Data data, vec2 uv) {\n    switch (data.id) {\n        GET_ALBEDO_CASE(ID_GROUND, getAlbedoSand)\n        GET_ALBEDO_CASE(ID_PYRAMID, getAlbedoSandStone)\n        GET_ALBEDO_CASE(ID_BALL, getAlbedoBall)\n    }\n    \n    return vec3(0.0);\n}\n\nfloat getOcclusion(\n    in vec3 ro,\n    in vec3 rd,\n    float mind,\n    float maxd, \n    float f,\n    inout Data data\n){\n    float result = 1.0;\n    float travel = 1e20;\n    for(float t = mind; t<maxd;) {\n        float h = getDist(data, ro + rd*t);\n        if(h < 0.001)return 0.0;\n        float y = h*h/(2.0*travel);\n        float d = sqrt(h*h-y*y);\n        result = min( result, f*d/max(0.0,t-y) );\n        travel = h;\n        t += h;\n        data.dist = t;\n        data.point = ro+rd*t;\n    }\n    return result;\n}\n\nvoid computeMaterial(inout Data data, in vec2 uv, in vec3 col) {\n    float s = 0.5;\n    \n    vec3 right = getAlbedo(data, uv + vec2(s, 0));\n    vec3 rightUp = getAlbedo(data, uv + vec2(s, s));\n    vec3 up = getAlbedo(data, uv + vec2(0, s));\n    \n    float diffCR = colorDiff(col, right);\n    float diffCRU = colorDiff(col, rightUp);\n    float diffRU = colorDiff(right, rightUp);\n    float diffCU = colorDiff(col, up);\n    \n    vec3 n = normalize(vec3(diffCU - diffCR, diffCR - diffCRU, 0.3)) * -1.; \n    n = normalize(mix(n, data.normal, 0.8*max(0.0, 1.0 - dot(n, data.normal))));\n    \n    data.material.bump = n;\n    \n    if (data.material.rough >= 0.99) {\n        float diffSum = (diffCR + diffCRU + diffRU + diffCU + (1.0 - luma(col)));\n        data.material.rough = compress(diffSum);\n    }\n    \n    float specF = compress(3.0*(luma(col) * max(0.0, 1.0 - (data.material.rough*2.))));\n    data.material.spec = mix(vec3(specF), col, data.material.rough);\n    \n} \n\nstruct Ray {\n    vec3 ro;\n    vec3 rd;\n    bool valid;\n};\n\nvec3 forEachLight(inout Data data, in Light light, inout Ray ray) {\n    ray.valid = false;\n    vec3 albedo = getAlbedo(data, data.uv);\n    vec3 diffuse = albedo / M_PI;\n    vec3 p = data.point;\n    vec3 n = data.normal;\n    \n    computeMaterial(data, data.uv, albedo);\n    n = normalize(n + data.material.bump);\n    \n    vec3 L = lightGetDir(light, p);\n    float NdotL = max(0.0, dot(n, L));\n    float att = lightGetAtt(light, p, n);\n    \n    vec3 ref = normalize(reflect(L, n));\n    float VdotR = max(0.0, dot(data.rd, ref));\n    vec3 spec = (data.material.spec * pow(VdotR, 32.0)) / 2.;\n    \n    if (NdotL > 0.0) {\n        Data oc;\n        dataInit(oc);\n        oc.skip = data.skip;\n        att *= clamp(getOcclusion(data.point, L, NEAR*2.0, FAR, sqrt(sqrt(light.strength)), oc), 0.0, 1.0);\n    }\n \n    if (data.material.rough < 0.99) {\n        vec3 refdir = normalize(reflect(data.rd, n));\n        vec3 rdir = randomDir(n, p, refdir, M_PI);\n        refdir = normalize(mix(refdir, rdir, compress(data.material.rough)));\n        ray.ro = data.point;\n        ray.rd = refdir;\n        ray.valid = true;\n        data.skip = data.id;\n    }\n\n    return (diffuse + spec) * light.color * att;\n}\n\nvec3 render(vec3 ro, vec3 rd, inout Data data, in Light lights[NUM_LIGHTS]) {\n    vec3 col = vec3(0.0);\n    \n    Ray ray = Ray(ro, rd, true);\n    \n    bool hitAny = false;\n    \n    vec3 sky = getSky(data, ro, rd, lights);\n    \n    for (int i = ZERO; i < MAX_BOUNCES; i++) {\n        ro = ray.ro;\n        rd = ray.rd;\n        data.ro = ro;\n        data.rd = rd;\n        \n        vec3 sky = (getSky(data, ro, rd, lights) * float(i > 0));\n\n        \n        float dotup = max(0.0, dot(rd, vec3(0, 1, 0)));\n\n\n        if (march(ro, rd, data)) {\n            for (int j = ZERO; j < NUM_LIGHTS; j++) {\n                Light light = lights[j];\n                col += forEachLight(data, light, ray);\n            }\n            hitAny = true;\n        } else if (hitAny) {\n            col += (sky * max(0.0, 1.0 - (data.material.rough*2.))) * compress(luma(col)*TAU);\n        }\n\n        col += (data.depth / (1.0 + (dotup*48.))) * (1.0 + data.depth*2.);\n        \n        if (!ray.valid) break;\n    }\n    \n    if (!hitAny) { col += sky; }\n    \n    \n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec2 m = (iMouse.xy-0.5*R.xy)/R.y;\n    \n    \n    float Y = 2.2;\n    \n    vec3 ro = vec3(0.0, Y, -8.0);\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n    \n    if (iMouse.z > 0.01) {\n        ro.yz *= rot(m.y * TAU);\n        ro.xz *= rot(m.x * TAU);\n        \n        rd.yz *= rot(m.y * TAU);\n        rd.xz *= rot(m.x * TAU);\n        \n        ro.y = max(0.8, ro.y);\n    } else {\n        float moveT = T*0.5;\n        ro.xz *= rot(moveT);\n        ro.y = max(0.8, ro.y);\n        rd = look(uv, vec3(0.0, Y, 0.0), ro);\n    }\n    \n    \n    \n    rd = normalize(rd);\n    Data data;\n    dataInit(data);\n    \n    Light lights[NUM_LIGHTS];\n    vec3 sunColor1 = vec3(1.0, 0.9, 0.5);\n    vec3 sunColor2 = vec3(1., 1., 0.95);\n    vec3 sunColor = mix(sunColor1, sunColor2, 0.7);\n    lights[0] = Light(vec3(1, 2, -3), sunColor, 4.0, LIGHT_AMBIENT);\n    \n\n    col += render(ro, rd, data, lights);\n\n    col /= vec3(1.0) + col;\n    col = pow(col, vec3(1.0 / 1.2));\n\n    \n    O = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define M_PI (3.1416)\n#define TAU (M_PI * 2.0)\n\nconst float HASH_MAP[16] = float[16](\n    0.4484410750068152, 0.5604512254151961, 0.49955284268263, 0.40679892641422355,\n    0.5180849501908357, 0.5472588115354913, 0.6766984192813609, 0.9064048675129073,\n    0.39864570212504613, 0.21022362764468383, 0.9516217965343488, 0.7301211180314449,\n    0.9928938541159735, 0.9095016245648258, 0.34485129267821846, 0.9842958980653165\n);\n#define IDX(v) (int(abs(v)*16.0) % 16)\n#define HASH(v) HASH_MAP[IDX(v)]\nfloat rand(vec2 p, float seed) {\n    p += vec2(cos(seed), sin(seed));\n    vec2 a = vec2(HASH(p.x), HASH(p.y))*10.0215;\n    vec2 b = vec2(HASH(p*a.x), HASH(p*a.y))*10.3921;    \n    return fract(20.0154*(dot(a, b) * dot(p, b)));\n}\n\n\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\n\nvec4 getTexture(sampler2D tex, vec2 uv) {\n    vec2 id = floor(uv);\n    vec2 sv = smoothstep(0.0, 1.0, fract(uv));\n    float seed = 9.78376;\n    float self = rand(id, seed);\n    float right = rand(id+vec2(1.0, 0.0), seed);\n    float top = rand(id+vec2(0.0, 1.0), seed);\n    float topRight = rand(id+vec2(1.0, 1.0), seed);\n    vec2 dx = dFdx(uv);\n    vec2 dy = dFdy(uv);\n    return mix(\n        mix(textureGrad(tex, uv*rot(self*6.28), dx, dy),\n            textureGrad(tex, uv*rot(right*6.28), dx, dy), sv.x),\n        mix(textureGrad(tex, uv*rot(top*6.28), dx, dy),\n            textureGrad(tex, uv*rot(topRight*6.28), dx, dy), sv.x),\n        sv.y\n    );\n}\nvec4 textureAntiRepeatSingleLayer(sampler2D tex, vec2 uv, vec2 dx, vec2 dy) {\n    vec2 id = floor(uv);\n    vec2 sv = smoothstep(0.0, 1.0, fract(uv));\n    float seed = 9.78376;\n    float self = rand(id, seed);\n    float right = rand(id+vec2(1.0, 0.0), seed);\n    float top = rand(id+vec2(0.0, 1.0), seed);\n    float topRight = rand(id+vec2(1.0, 1.0), seed);\n    return mix(\n        mix(textureGrad(tex, uv*rot(self*6.28), dx, dy),\n            textureGrad(tex, uv*rot(right*6.28), dx, dy), sv.x),\n        mix(textureGrad(tex, uv*rot(top*6.28), dx, dy),\n            textureGrad(tex, uv*rot(topRight*6.28), dx, dy), sv.x),\n        sv.y\n    );\n}\nvec4 getTextureLayered(sampler2D tex, vec2 uv, vec2 scale) {\n    vec2 id = floor(uv);\n    vec2 sv = smoothstep(0.0, 1.0, fract(uv));\n    float seed = 3.31915;\n    float self = mix(scale.x, scale.y, rand(id, seed));\n    float right = mix(scale.x, scale.y, rand(id+vec2(1.0, 0.0), seed));\n    float top = mix(scale.x, scale.y, rand(id+vec2(0.0, 1.0), seed));\n    float topRight = mix(scale.x, scale.y, rand(id+vec2(1.0, 1.0), seed));\n    vec2 dx = dFdx(uv);\n    vec2 dy = dFdy(uv);\n    return mix(\n        mix(textureAntiRepeatSingleLayer(tex, (uv*self), dx, dy),\n            textureAntiRepeatSingleLayer(tex, (uv*right), dx, dy), sv.x),\n        mix(textureAntiRepeatSingleLayer(tex, (uv*top), dx, dy),\n            textureAntiRepeatSingleLayer(tex, (uv*topRight), dx, dy), sv.x),\n        sv.y\n    );\n}\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\nvec4 getTexture(sampler2D tex, vec2 uv, vec2 scale) {\n    return getTextureLayered(tex, uv, scale);\n}\n\nfloat colorDiff(vec3 a, vec3 b) {\n    return abs(luma(a) - luma(b));\n}\n\nvec3 compress(vec3 a) { return clamp(a, 0.0, 1.0); }\n\nfloat compress(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n    vec3 lookAt = point;\n    float zoom = 1.;\n    vec3 camForward = normalize(lookAt - ro);\n    vec3 camRight = -cross(camForward, vec3(0, 1, 0));\n    vec3 camUp = -cross(camRight, camForward);\n    vec3 screenCenter = ro + camForward * zoom;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}","name":"Common","description":"","type":"common"}]}