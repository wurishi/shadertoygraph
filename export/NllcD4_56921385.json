{"ver":"0.1","info":{"id":"NllcD4","date":"1649328137","viewed":68,"name":"Projet Shader Delafosm","username":"mathisdf","description":"Delafosse Mathis AW\n\nClick to change car dimensions\nPress C to change camera\n\nkeyboard from : https://www.shadertoy.com/view/XlGfzt","likes":6,"published":1,"flags":16,"usePreview":0,"tags":["vroom","vroom","vroom"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define DIST_MIN 0.5 // minimum distance to objects\n#define DIST_MAX 100.0 // maximum distance to objects\n#define RAY_MARCH_STEPS 100\n#define RAY_MARCH_PRECI 0.001\n#define PI 3.14159265359\n\n// Type de camera\n#define CAMERA_EXTERIOR 1.0\n#define CAMERA_INTERIOR 2.0\n\nbool isPressed(float keyCode) {\n        keyCode = (keyCode + 0.5) / 256.0;\n        vec2 uv = vec2(keyCode, 0.25);\n        float key = texture(iChannel0, uv).r;\n\n        return key > 0.0;\n}\n\nbool isToggled(float keyCode) {\n        keyCode = (keyCode + 0.5) / 256.0;\n        vec2 uv = vec2(keyCode, 0.75);\n        float key = texture(iChannel0, uv).r;\n\n        return key > 0.0;\n}\n\n#define KEY_1 67.0\n\n// Stucture pour les rayons\nstruct Ray {\n    vec3 o; // Origine\n    vec3 d; // Direction\n};\n\n// structure pour les surfaces\nstruct Surface {\n    float t; // surface distance\n    vec3 c; // surface color\n};\n\n// structure pour les surfaces\nstruct CarSurfaces {\n    Surface car; // surface de la voiture\n    Surface interior; // surface color\n};\n\n\n//SDF\nfloat sdSphere(in vec3 p, float r) {\n    return length(p)-r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n\n//OPERATOR\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\n/**\n    OPÉRATEUR SUR LES FONCTIONS DE DISTANCES\n*/\nfloat substract(float sd1,float sd2) {\n    return max(sd1,-sd2);\n}\n\nfloat add(float sd1,float sd2) {\n    return min(sd1,sd2);\n}\n\nfloat intersect(float sd1,float sd2) {\n    return max(sd1,sd2);\n}\n\n/**\n    MANIPULATION SCÈNE 2D\n*/\nvec2 translate(in vec2 p, in vec2 t) {\n    return p - t;\n}\n\nvec2 scale(in vec2 p, in vec2 f) {\n    return p*f;\n}\n\nvec2 rotate(in vec2 p, in float a) {\n    float ca = cos(a);\n    float sa = sin(a);\n\n    return vec2(ca*p.x-sa*p.y, sa*p.x+ca*p.y);\n}\n\nfloat degreToRadian(in int degre) {\n    return float(degre) *(PI/180.);\n}\n\n/* Creer une voiture \n   Renvoie les Surface de la voiture et de l'interieur de la voiture */\nCarSurfaces car(in vec3 p) {\n    vec2 mouse = vec2(iMouse.x/iResolution.x, iMouse.y/iResolution.y);\n    \n    /* Parametre de la voiture */\n        vec3 carSize = vec3(3. + mouse.y, 3., 6. + mouse.x * 2.); //Largeur, Hauteur, Longueur de la voiture\n        vec3 carColor = vec3(.2 + cos(iTime)/4., .2 + sin(iTime)/4., .4);\n        float smoothOfCar = .4; // Valeur pour le smooth des angles de la voiture\n\n        //Capot\n        float capotLength = 3.;\n        float capotHeight = 1.5;\n\n        // Roues\n        vec3 wheelColor = vec3(1., 1., 1.);\n        float wheelSize = 1.4; //Diametre d'une roue\n        \n        //Couleur des vitres\n        vec3 windowColor = vec3(1., 1., 1.);\n    /* ------------- */\n    \n    //Pave de la voiture\n    float distCar = sdRoundBox(p, carSize, smoothOfCar);\n    \n    //Capot\n    vec2 CRot = rotate(vec2(p.x, p.z), degreToRadian(90));\n    vec3 pC = vec3(CRot.x+(carSize.z/0.7)-capotLength, p.y-carSize.y-smoothOfCar, CRot.y);\n    vec2 sizeC = vec2(capotHeight*2.+smoothOfCar, carSize.x+smoothOfCar);\n    float distCapot = sdHexPrism(pC, sizeC);\n    distCar = opSmoothSubtraction(distCapot, distCar, smoothOfCar);\n    \n    //Interieur\n    vec3 pI = vec3(p.x, p.y, p.z+capotLength-.5);\n    vec3 sizeI = vec3(carSize.x, carSize.y, carSize.z-capotLength);\n    float distInt = sdBox(pI, sizeI);\n    distCar = opSmoothSubtraction(distInt, distCar, smoothOfCar);\n    \n    //Trou Roues Avants\n    vec2 FWrotation = rotate(vec2(p.x, p.y), degreToRadian(90)); // Rotation sur XY\n    vec3 pFW = vec3(FWrotation.x-carSize.y, FWrotation.y, p.z-(carSize.z/2.+.5));\n    float distFrontWheelHole = sdCappedCylinder(pFW, wheelSize+.1, carSize.x+1.);\n    distCar = opSmoothSubtraction(distFrontWheelHole, distCar, smoothOfCar);\n    \n    //Trou Roues Arrieres\n    vec2 BWrotation = rotate(vec2(p.x, p.y), degreToRadian(90)); // Rotation sur XY\n    vec3 pBW = vec3(BWrotation.x-carSize.y, BWrotation.y, p.z+(carSize.z/2.+.5));\n    float distBackWheelHole = sdCappedCylinder(pBW, wheelSize+.1, carSize.x+1.);\n    distCar = opSmoothSubtraction(distBackWheelHole, distCar, smoothOfCar);\n    \n    //Trou Fenetre Laterales\n    vec3 pSW = vec3(p.x, p.y-carSize.y+capotHeight, p.z-(carSize/2.).z+capotLength+1.);\n    vec3 sizeSW = vec3(carSize.x+smoothOfCar, capotHeight-.4, 1.);\n    float distSideWindows = sdBox(pSW, sizeSW);\n    distCar = opSmoothSubtraction(distSideWindows, distCar, smoothOfCar);\n    \n    //Trou Fenetre Avant/Arriere\n    vec3 pW = vec3(p.x, p.y-carSize.y+capotHeight, p.z);\n    vec3 sizeW = vec3(carSize.x-.4, capotHeight-.4, carSize.z+smoothOfCar);\n    float distWindows = sdBox(pW, sizeW);\n    distCar = opSmoothSubtraction(distWindows, distCar, smoothOfCar);\n    \n    // Carrosserie\n    Surface car = Surface(distCar, carColor);\n    \n    \n    /* ROUES */\n    //Roue Avant Gauche\n    vec2 WFLrotation = rotate(vec2(p.x, p.y), degreToRadian(90)); // Rotation sur XY\n    vec3 pWFL = vec3(WFLrotation.x-carSize.y, WFLrotation.y-(carSize.x/1.2), p.z-(carSize.z/2.+.5));\n    float distWFL = sdRoundedCylinder(pWFL, wheelSize/2., smoothOfCar, carSize.x/6.);\n    Surface WFL = Surface(distWFL, vec3(wheelColor));\n    \n    //Roue Avant Droite\n    vec2 WFRrotation = rotate(vec2(p.x, p.y), degreToRadian(90)); // Rotation sur XY\n    vec3 pWFR = vec3(WFLrotation.x-carSize.y, WFRrotation.y+(carSize.x/1.2), p.z-(carSize.z/2.+.5));\n    float distWFR = sdRoundedCylinder(pWFR, wheelSize/2., smoothOfCar, carSize.x/6.);\n    Surface WFR = Surface(distWFR, vec3(wheelColor));\n    \n    //Roue Arriere Gauche\n    vec2 WBLrotation = rotate(vec2(p.x, p.y), degreToRadian(90)); // Rotation sur XY\n    vec3 pWBL = vec3(WBLrotation.x-carSize.y, WBLrotation.y-(carSize.x/1.2), p.z+(carSize.z/2.+.5));\n    float distWBL = sdRoundedCylinder(pWBL, wheelSize/2., smoothOfCar, carSize.x/6.);\n    Surface WBL = Surface(distWBL, vec3(wheelColor));\n    \n    //Roue Arriere Droite\n    vec2 WBRrotation = rotate(vec2(p.x, p.y), degreToRadian(90)); // Rotation sur XY\n    vec3 pWBR = vec3(WBRrotation.x-carSize.y, WBRrotation.y+(carSize.x/1.2), p.z+(carSize.z/2.+.5));\n    float distWBR = sdRoundedCylinder(pWBR, wheelSize/2., smoothOfCar, carSize.x/6.);\n    Surface WBR = Surface(distWBR, vec3(wheelColor));\n    \n    \n    // Carrosserie + Roue\n    Surface carSurface = car;\n    \n    if(distWFL < carSurface.t){\n        carSurface = WFL;\n    } else if(distWFR < carSurface.t){\n        carSurface = WFR;\n    } else if(distWBL < carSurface.t){\n        carSurface = WBL;\n    } else if(distWBR < carSurface.t){\n        carSurface = WBR;\n    } \n    \n    Surface carInterior = Surface(distInt,windowColor); \n    \n    return CarSurfaces(carSurface, carInterior);\n}\n\n\n\n// Définition de la scène\nSurface scene(in vec3 p) {\n    \n    //Voiture\n    CarSurfaces cf = car(p);\n    \n    return cf.car;\n}\n\n// Fonction lancant le rayon et testant si le rayon touche la voiture\nSurface marchCar(in Ray r) {\n    float t = DIST_MIN;\n\n    \n    for(int i=0;i<RAY_MARCH_STEPS,t<=DIST_MAX;++i) {\n        CarSurfaces cf = car(r.o+t*r.d);\n        \n        Surface s = cf.car;\n\n        // Si on \"touche\" l'objet\n        if(s.t<RAY_MARCH_PRECI) {\n            return Surface(t+s.t,s.c);\n        }\n\n        t = t+s.t;\n    }\n\n    //Fond du shader\n    return Surface(DIST_MAX,vec3(.8, .8, 1.));\n}\n\n// Fonction lancant le rayon et testant si le rayon touche l'interieur de la voiture\nSurface marchInterior(in Ray r) {\n    float t = DIST_MIN;\n\n    \n    for(int i=0;i<RAY_MARCH_STEPS,t<=DIST_MAX;++i) {\n        CarSurfaces cf = car(r.o+t*r.d);\n        \n        Surface s = cf.interior;\n\n        // Si on \"touche\" l'objet\n        if(s.t<RAY_MARCH_PRECI) {\n            return Surface(t+s.t,s.c);\n        }\n\n        t = t+s.t;\n    }\n\n    //Fond du shader\n    return Surface(DIST_MAX,vec3(.8, .8, 1.));\n}\n\n// Fonction calculant la normal a une surface\nvec3 normalAt(in Surface s,in Ray r) {\n    const float e = 0.01;\n    vec3 p = r.o+s.t*r.d;\n    float nx = scene(vec3(p.x+e,p.y,p.z)).t-scene(vec3(p.x-e,p.y,p.z)).t;\n    float ny = scene(vec3(p.x,p.y+e,p.z)).t-scene(vec3(p.x,p.y-e,p.z)).t;\n    float nz = scene(vec3(p.x,p.y,p.z+e)).t-scene(vec3(p.x,p.y,p.z-e)).t;\n\n    return normalize(vec3(nx,ny,nz));\n}\n\nRay camRay(in vec2 p) {\n    // p is the current pixel coord, in [-1,1]\n    \n    float camera = CAMERA_INTERIOR;\n    \n    if (isToggled(KEY_1)) {\n        camera = CAMERA_EXTERIOR;\n    }\n    \n    // Parametres Camera\n    float camSpeed = .4;\n    float camDistance = 20.;\n    \n    // Camera Exterieur\n    vec3 camPos = vec3(camDistance*cos(iTime*camSpeed), 3.,camDistance*sin(iTime*camSpeed));\n    vec3 target = vec3(0.,0.,0.);\n    \n    // Camera Interieur\n    if(camera == CAMERA_EXTERIOR){\n        camPos = vec3(0., 2., -2.);\n        target = vec3(camDistance*cos(iTime*camSpeed),0.,camDistance*sin(iTime*camSpeed));\n    }\n\n\n    // camera view vector\n    vec3 camView = normalize(target-camPos);\n\n    // camera up vector (temporary)\n    vec3 cp = vec3(0.0,1.0,0.0);\n\n    // camera right vector\n    vec3 cu = normalize(cross(camView,cp));\n\n    // camera (normalized) up vector\n    vec3 cv = normalize(cross(cu,camView));\n    \n    float fovDeg = 45.;\n    float fovRad = (fovDeg/360.)*2.*PI;\n    float zf = 1./tan(fovRad/2.);\n    \n    // view vector, including perspective (the more you multiply cw, the less fovy)\n    vec3 rd = normalize(p.x*cu + p.y*cv*(R.y/R.x) + 2.*camView);\n\n    return Ray(camPos,rd);\n}\n\nvec3 shade(in Surface surf, in Ray ray) {\n    // tous les vecteurs nécessaires au shading\n    vec3 n = normalAt(surf,ray);\n    vec3 l = normalize(vec3(1., 1., 1.));\n    vec3 v = ray.d;\n    vec3 r = reflect(l,n);\n    \n    // parametres du materiau\n    vec3 kd = surf.c;\n    vec3 ks = vec3(1.);\n    float s = 20.;\n    \n    // coeficients diffus et spéculaires\n    float diff = max(dot(n,l),.25);\n    float spec = pow(max(dot(r,v),0.),s);\n    \n    vec3 reflection = reflect(v, n);\n    reflection = texture(iChannel1, reflection).xyz;\n    \n    return kd*diff + ks*spec + (reflection/3.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Définition du repère entre -1 et 1\n    vec2 uv = (fragCoord / R.xy)*2.-1.;\n    \n    // Création du rayon\n    Ray ray = camRay(uv);\n    \n    // March pour la surface de la carrosserie \n    Surface sCar = marchCar(ray);\n    \n    // Shading\n    vec3 color = sCar.c;\n    if(sCar.t<DIST_MAX) {\n        color = shade(sCar,ray);\n    }\n    \n    // March pour la surface de l'interieur de la voiture \n    Surface sInterior = marchInterior(ray);\n    \n    // Si on est a l'interieur de la voiture\n    if(sInterior.t < sCar.t) {\n       color -= .4;\n    }\n    \n    fragColor = vec4(color,1.);\n}","name":"Image","description":"","type":"image"}]}