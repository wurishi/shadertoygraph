{"ver":"0.1","info":{"id":"MfGcW1","date":"1731786137","viewed":96,"name":"cloud_PerlinFBM_rayMarching_","username":"deformanic","description":"perlin cloud, FBM, raymarching","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["cloud","perlinenoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//-----------------------------------------------------------------------------\n// Volumetric Clouds with FBM & Ray Marching\n// Reference FMB & Noise: https://www.shadertoy.com/view/lss3zr\n// Reference look at camera: https://inspirnathan.com/posts/47-shadertoy-tutorial-part-1\n//-----------------------------------------------------------------------------\n\n\n\n//3x3 rotation matrix used for transforming the points in fbm\n//Creating Complexity in the Noise: If the same transformation matrix were applied repeatedly \n//to the coordinates, it would ensure that the fractal pattern generated by fbm doesn't just repeat in a predictable way. \n//Instead, the rotation of the coordinates at each iteration introduces greater variation and complexity into the generated noise pattern.\nconst mat3 m = mat3(\n    0.00,  0.80,  0.60,\n    -0.80, 0.36, -0.48,\n    -0.60, -0.48, 0.64\n);\n\n\n// Hash function to generate pseudo-random values based on input\nfloat hash(float n) {\n    return fract(sin(n) * 123.123);\n}\n\n// Perlin-like noise function for 3D noise generation\nfloat noise(vec3 x) {\n    vec3 p = floor(x);        // Integer part of the input\n    vec3 f = fract(x);        // Fractional part of the input\n    f = f * f * (3.0 - 2.0 * f);  // Smoothstep interpolation\n    float n = p.x + p.y * 57.0 + 113.0 * p.z; // Unique value for each grid cell\n    // Interpolate between the hash values at the corners of the cell\n    return mix(\n        mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n            mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y),\n        mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n            mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z\n    );\n}\n\n//Fractional Brownian Motion, Sum of several layers (also called octaves) of noise, \n//Each layer or octave is created by applying a noise function at different scales.\n//(A)Amplitudes for each octave decreases as you go to higher octavesm (A0, A1,..,)\n//The frequency doubles with each octave (i.e., p * 2, p * 4, ...).\n//Each layer of noise is summed together to produce the final result.\nfloat fbm(vec3 p, int octaves) {\n    float f = 0.0;\n    float amp = 1.50;\n    for (int i=0; i<octaves; i++){\n        amp*=.5;\n        f += amp * noise(p); p = m * p * (2.0+ (float(i)*.1));\n    }\n    return f;\n}\n\n// Scene function that combines distance-based fog effect with fbm\nfloat scene(vec3 p) {    \n    return 0.1 - length(p) * 0.05 + fbm(p * 0.3 , 4);\n}\n\nmat3 cameraLookat(vec3 cameraPos, vec3 lookAtPoint) {\n    vec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n    vec3 cu = normalize(cross(cd, cr)); // camera up\n    return mat3(-cr, cu, -cd);\n}\n\n\nvec3 cameraLookatPosition(float cameraHeight, float cameraRadius, vec3 lookAtPos){\n    // Calculate the updated camera position based on time\n    vec3 cameraPosition;\n    cameraPosition.x = cameraRadius * cos(iTime * 0.5) + lookAtPos.x; // Convert to polar coordinates\n    cameraPosition.z = cameraRadius * sin(iTime * 0.5) + lookAtPos.z;\n    cameraPosition.y = cameraHeight;\n    return vec3(cameraPosition);\n}\n\n\n//-----------------------------------------------------------------------------\n// Main functions\n//-----------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    //camera lookat\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 lookAtPos = vec3(0, .0, 0); // Look-at point (camera target)\n    vec3 ro  = cameraLookatPosition(.0, 34., lookAtPos);\n    mat3 cam = cameraLookat(ro, lookAtPos);// Get the camera matrix\n    vec3 rd = cam * normalize(vec3(uv, -1)); // Calculate the ray direction\n\n\n    //////////////////////////////////////////////////////\n    // Ray Marching Setup:\n    vec4 color = vec4(0.0);\n    const int nbSample = 128;       // Number of samples for main ray marching\n    const int nbSampleLight = 16;   // Number of samples for light scattering\n    float zMax = 40.0;             // Maximum distance for ray marching\n    float step = zMax / float(nbSample);//The step size for each ray marching iteration. The ray advances by this amount each time.\n    float zMaxl = 22.0;            // Maximum distance for light sampling\n    float stepl = zMaxl / float(nbSampleLight);// The step size for light sampling.\n    vec3 p = ro;\n    float T = 1.0;                 // Transparency factor\n    float absorption = 100.0;      // Absorption coefficient\n    vec3 sun_direction = normalize(vec3(-1.0, .6, -1.0));\n\n    //////////////////////////////////////////////////////\n    // Main ray marching loop\n    //Density Check: If the density is greater than 0.0 (i.e., weâ€™re inside a volumetric medium like fog or clouds), the loop continues.\n    //T: The transparency factor of the ray. It accumulates over the iterations based on the density and absorption, \n    //simulating how the ray becomes more opaque as it travels through the medium.\n    for (int i = 0; i < nbSample; i++) {\n        float density = scene(p);\n        if (density > 0.0) {\n            float tmp = density / float(nbSample);\n            T *= 1.0 - tmp * absorption;\n            if (T <= 0.01) break;\n            // light scattering along the ray by sampling the light density in the direction of the sun.\n            float Tl = 1.0;\n            for (int j = 0; j < nbSampleLight; j++) {\n                float densityLight = scene(p + normalize(sun_direction) * float(j) * stepl);\n                if (densityLight > 0.0) {\n                    Tl *= 1.0 - densityLight * absorption / float(nbSample);\n                    if (Tl <= 0.01) break;\n                }\n            }\n            //Add ambient color+ light scattering color\n            //adds to the final color based on the density and light scattering. \n            //The color values are scaled by tmp, T, and Tl (transparency and light scattering factors).\n            vec4 ambientColor = vec4(.9,.9,.9,1.0) * 50.0 * tmp * T;\n            vec4 scatteringColor = vec4(1.0, .6, 0.1, 1.0) * 80.0 * tmp * T * Tl;\n            color += ambientColor + scatteringColor;\n        }\n        p += rd * step;\n    }\n\n    fragColor = color;\n}\n","name":"Image","description":"","type":"image"}]}