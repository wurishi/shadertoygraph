{"ver":"0.1","info":{"id":"lfsSWj","date":"1705754111","viewed":187,"name":"20240120_log rhythm","username":"0b5vr","description":"Inspired by https://www.youtube.com/watch?v=i9D0c0SW4pQ","likes":14,"published":1,"flags":40,"usePreview":0,"tags":["audio"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ** Music shader code is in \"Common\" tab **\n\nconst float SQRT2 = sqrt( 2.0 );\nconst float INV_SQRT2 = 1.0 / SQRT2;\n\nfloat plot( vec2 p ) {\n  int MAX_SAMPLES = min( 1024, int( iResolution.x ) );\n  float d = 2.0 / iResolution.y;\n  \n  float sum = 0.0;\n  for ( int i = 0; i < MAX_SAMPLES; i ++ ) {\n    vec2 s = texelFetch( iChannel0, ivec2( i, 0 ), 0 ).xy * mat2( -0.5, 0.5, 0.5, 0.5 );\n    float r = length( p - s );\n    sum += smoothstep( d, 0.0, r - 0.003 );\n  }\n  return sum;\n}\n\nfloat bgPattern( vec2 p ) {\n  float d = 2.0 / iResolution.y;\n\n  float rect = 0.0;\n  rect += smoothstep( 2.0 * d, 0.0, abs( p.x + p.y ) ) * smoothstep( 2.0 * d, 0.0, abs( p.x - p.y ) - 0.95 );\n  rect += smoothstep( 2.0 * d, 0.0, abs( p.x - p.y ) ) * smoothstep( 2.0 * d, 0.0, abs( p.x + p.y ) - 0.95 );\n  rect += smoothstep( 2.0 * d, 0.0, abs( abs( p.x + p.y ) - 1.0 ) ) * smoothstep( 2.0 * d, 0.0, abs( p.x - p.y ) - 1.0 );\n  rect += smoothstep( 2.0 * d, 0.0, abs( abs( p.x - p.y ) - 1.0 ) ) * smoothstep( 2.0 * d, 0.0, abs( p.x + p.y ) - 1.0 );\n  rect += smoothstep( 2.0 * d, 0.0, abs( p.x ) ) * smoothstep( d, 0.0, abs( p.y ) - 0.95 );\n  return min( rect, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord / iResolution.xy;\n  vec2 p = 2.0 * uv - 1.0;\n  p.x *= iResolution.x / iResolution.y;\n  \n  float shape = 0.0;\n  \n  shape += plot( p );\n  shape += 0.1 * bgPattern( p );\n\n  fragColor = vec4( vec3( shape ), 1.0 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define BPM 120.0\n#define SAMPLES_PER_SEC iSampleRate\n#define SAMPLES_PER_STEP int(iSampleRate * 15.0 / BPM)\n#define STEP2TIME (float(SAMPLES_PER_STEP) / SAMPLES_PER_SEC)\n\n#define TRANSPOSE 0.0\n\n#define saturate(x) clamp(x, 0., 1.)\n#define repeat(i, n) for (int i = 0; i < n; i++)\n\nconst float LN2 = log(2.0);\nconst float TAU = acos(-1.0) * 2.0;\n\nuvec3 hash3u(uvec3 x) {\n  const uint k = 1103515245u;\n  x = ((x >> 8U) ^ x.yzx) * k;\n  x = ((x >> 8U) ^ x.yzx) * k;\n  x = ((x >> 8U) ^ x.yzx) * k;\n  return x;\n}\n\nvec3 hash3f(vec3 v) {\n  uvec3 x = floatBitsToUint(v);\n  return vec3(hash3u(x)) / float(-1u);\n}\n\nvec2 cis(float t) {\n  return vec2(cos(t), sin(t));\n}\n\nmat2 rotate2D(float x) {\n  vec2 v = cis(x);\n  return mat2(v.x, v.y, -v.y, v.x);\n}\n\nvec2 boxMuller(vec2 xi) {\n  float r = sqrt(-2.0 * log(xi.x));\n  float t = xi.y;\n  return r * cis(TAU * t);\n}\n\nfloat p2f(float p) {\n  return exp2((p - 69.0) / 12.0) * 440.0;\n}\n\nmat3 orthBas(vec3 z) {\n  z = normalize(z);\n  vec3 x = normalize(cross(vec3(0, 1, 0), z));\n  vec3 y = cross(z, x);\n  return mat3(x, y, z);\n}\n\nvec3 cyclicNoise(vec3 p, float pump) {\n  vec4 sum = vec4(0);\n  mat3 rot = orthBas(vec3(2, -3, 1));\n\n  repeat(i, 5) {\n    p *= rot;\n    p += sin(p.zxy);\n    sum += vec4(cross(cos(p), sin(p.yzx)), 1);\n    sum *= pump;\n    p *= 2.;\n  }\n\n  return sum.xyz / sum.w;\n}\n\nivec4 seq16(int seq, int frame, int sps) {\n  int st = frame / sps;\n  int rotated = ((seq >> (15 - st)) | (seq << (st + 1))) & 0xffff;\n\n  int prevStepBehind = int(log2(float(rotated & -rotated)));\n  int prevStep = st - prevStepBehind;\n  int nextStepForward = 16 - int(floor(log2(float(rotated))));\n  int nextStep = st + nextStepForward;\n\n  return ivec4(\n    prevStep,\n    frame - sps * prevStep,\n    nextStep,\n    sps * nextStep - frame\n  );\n}\n\nvec2 mainAudio(int frame) {\n  vec4 time = vec4((frame) % (SAMPLES_PER_STEP * ivec4(1, 4, 16, 256))) / SAMPLES_PER_SEC;\n  float bars = float(frame) / SAMPLES_PER_SEC / 16.0 / STEP2TIME;\n\n  vec2 dest = vec2(0);\n  float sidechain;\n\n  { // chord\n    int chord[8] = int[](\n      0, 3, 7, 10, 14, 17, 24, 26\n    );\n\n    float t = time.z + 0.05;\n\n    float k = 1.2;\n    float lst = floor(log(t) / log(k));\n    float st = pow(k, lst);\n    float l = pow(k, lst + 1.0) - st;\n    t = t - st;\n    float q = l - t;\n\n    float env = smoothstep(0.0, 0.001, t) * smoothstep(0.0, 0.001, q);\n\n    vec2 sum = vec2(0.0);\n\n    float curve = exp(-t / (0.1 + l));\n    float radius = mix(0.1, 0.4, curve);\n    float pers = exp2(mix(2.0, -1.0, curve));\n\n    repeat(iUnison, 64) {\n      vec3 dice = hash3f(vec3(iUnison, 7, 7));\n      vec2 dicen = boxMuller(dice.xy);\n\n      int prog = 8 * (frame / 32 / SAMPLES_PER_STEP);\n      float pitch = 48.0 + TRANSPOSE + float(chord[iUnison % 8]);\n\n      float phase = t * p2f( pitch ) + dice.x;\n      phase *= exp(0.01 * dicen.x);\n\n      vec2 wave = cyclicNoise(vec3(radius * cis(TAU * phase), 15.0 + 0.1 * st), pers).xy;\n      sum += 0.04 * env * wave * rotate2D(float(iUnison));\n    }\n\n    dest += sum;\n  }\n\n  return tanh(dest);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  if ( fragCoord.y > 1.0 ) {\n    fragColor = vec4( 0.0 );\n  } else {\n    vec2 s = mainAudio( int( SAMPLES_PER_SEC * iTime - fragCoord.x ) );\n\n    fragColor = vec4( s, 0.0, 1.0 );\n  }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec2 mainSound( int samp, float _time ) {\n  return mainAudio( samp );\n}\n","name":"Sound","description":"","type":"sound"}]}