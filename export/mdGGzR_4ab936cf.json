{"ver":"0.1","info":{"id":"mdGGzR","date":"1678105839","viewed":176,"name":"decal demo","username":"yunhai","description":"try to add my first decal\ncore code starts from line:124","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["study"],"hasliked":0,"parentid":"NdG3Ry","parentname":"RayMarching Env"},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*------------OBJ DEFINE------------*/\nconst int OBJ_NUM=4;\nconst int ID_BOUND=0;\nconst int ID_BOX=1;\nconst int ID_LOWCUBE=2;\nconst int ID_3=3;\nMarchPoint sdf(in vec3 p)\n{\n    float[OBJ_NUM] objSDF;\n    for(int i=0;i<OBJ_NUM;i++)\n        objSDF[i]=INF;\n    objSDF[ID_BOUND]=-sdSphere(p,MAX_DIST);//Bound\n    \n    /*--------add objects begin--------*/\n    objSDF[ID_BOX]=-sdCube(p-vec3(0,0.,.5),vec3(1.4,1.2,2.2));\n    \n    vec3 np=p;np-=vec3(.2,.2,1.5);\n    mat2x2 rot=mrot(-20.*iTime);np.xz*=rot;\n    objSDF[ID_LOWCUBE]=sdCube(np,vec3(.2));\n    \n    np=p;np-=vec3(-.13,-.28,1.6);\n    rot=mrot(20.*iTime);np.yz*=rot;\n    objSDF[ID_3]=sdTorus(np,vec2(.8,.23)*.3);\n    /*--------add objects end--------*/\n    \n    MarchPoint tar=MarchPoint(objSDF[ID_BOUND],ID_BOUND);\n    for(int i=1;i<OBJ_NUM;i++)\n        if(tar.d>objSDF[i])\n            tar.d=objSDF[i],\n            tar.id=i;\n\n    return tar;\n}\nvec3 getNormal(in vec3 p)\n{\n    vec2 e=vec2(0,EPS);\n    float c=sdf(p).d;\n    return normalize(vec3(sdf(p+e.yxx).d-c,\n                          sdf(p+e.xyx).d-c,\n                          sdf(p+e.xxy).d-c));\n}\nstruct FragInfo\n{\n    vec3 worldPos,normal,kc;\n    float ao;\n};\nvec3 getLight()\n{\n    return vec3(0.,.1,1.);\n}\nvec3 pixelShade(in FragInfo I)\n{\n    vec3 pl=getLight()-I.worldPos,ld;\n    float plLen=length(pl);\n    ld=pl/plLen;\n    float tense=.08;\n    vec3 diff=vec3(1.,.7,.4)*max(dot(ld,I.normal),0.)/(plLen*plLen)*tense;\n    vec3 amb=vec3(.1,.2,.3)*.3*((1.-I.ao)*.7+.3);\n    return I.kc*(diff+amb);\n}\nMarchHit rayCast(in Ray r,inout float edge)\n{\n    float d=0.,i=0.,l=0.;edge=0.;\n    MarchPoint point;\n    \n    float lastD=1e9;\n    for(;i<MAX_STEP;i++)\n    {\n        point=sdf(r.o+d*r.d);\n        \n        /*edge*/\n        const float EDGE_WIDTH=.007;\n        if(lastD<EDGE_WIDTH&&point.d>lastD)\n            edge=1.;\n        /**/\n        \n        if(abs(point.d)<MIN_DIST)\n            break;\n\n        l=i/MAX_STEP;\n        float SUB_BOUND=.4,UPPER_BOUND=1.;\n        d+=point.d*clamp(SUB_BOUND,UPPER_BOUND,\n        mix(SUB_BOUND,UPPER_BOUND,point.d));//*((1.-l*l*l)*0.7+0.3);\n        if(point.id==ID_BOUND)\n        {\n            d=MAX_DIST;\n            break;\n        }\n        lastD=point.d;\n    }\n    return MarchHit(d,i,point.id);\n}\nvec4 render(in Ray r)\n{\n    float edge=0.;\n    MarchHit h=rayCast(r,edge);\n    \n    vec3 pos=r.o+r.d*h.d,nml=getNormal(pos);\n    vec3 col=vec3(0),t=col;\n    float ao=h.marchTimes/MAX_STEP;\n    switch (h.id)\n    {\n        case ID_BOUND:\n            break;\n        case ID_BOX:\n            vec3 kc=mix(vec3(1),\n            mix(vec3(.5,1,.1),vec3(1.,.2,.2),nml.x*.5+.5),\n                        step(.5,abs(nml.x)));kc=max(kc,0.);\n          \n            col=pixelShade(FragInfo(pos,nml,kc,ao));\n\n\n            break;\n        case ID_LOWCUBE:\n        case ID_3:\n            col=pixelShade(FragInfo(pos,nml,vec3(1),ao));\n            \n            break;\n    }\n    col=mix(col,vec3(0.),edge);//edge\n    \n    //decal cube\n    for(float i=0.,time=iTime;i<4.-.1;i++,time+=1.5)\n    {\n        vec3 cubeCenter=vec3(sin(time),cos(time),0.)*.3+vec3(0,0,1.4);\n        float cubeSize=.4;\n        if(sdCube(pos-cubeCenter,vec3(cubeSize))<0.)//test worldPos in decal cube\n        {\n            vec2 uv=pos.xy-cubeCenter.xy;//cube local uv\n            vec4 tex=texture(iChannel2,(uv/cubeSize+vec2(0.5)//(-.5,.5)->(0,1)\n            +vec2(floor(mod(time*5.,6.)),0.))* //frame animation \n            vec2(0.157,1.));//cut texture part\n            col=mix(col,pixelShade(FragInfo(pos,nml,tex.xyz,ao)),tex.w);\n    }\n    }\n\n    \n    return vec4(col,ao);\n}\nRay genRay(in vec2 C)\n{\n    \n    cam.pos=vec3(0,-.1,-.2);\n    cam.dir=vec3(0.,0.,1.);\n    cam.r=vec3(cam.dir.z,0.,-cam.dir.x);\n    cam.u=-cross(cam.r,cam.dir);\n    vec2 uv=(C-iR*.5)/iR.y;\n    //uv+=(iM.xy-.5*iR)/iR.y*2.;//handle input\n    Ray r=Ray(cam.pos,normalize(uv.x*cam.r+uv.y*cam.u+1.*cam.dir));\n    return r;\n}\nvoid mainImage( out vec4 O, in vec2 C )\n{\n#ifdef SSAA\n    vec2 e=vec2(.25,-.25);\n    O=render(genRay(C+e.yy))+render(genRay(C+e.xy))+\n      render(genRay(C+e.yx))+render(genRay(C+e.xx));\n    O*=.25;\n#else\n    O=render(genRay(C));\n#endif\n    O=ACESFilm(O);//tone mapping\n    O=pow(O,vec4(0.45));//linear to sRGB\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*------------Log------------*/\n//updated: QuickAO\n\n//updated: SSAA\n//NOTICE! this option cost 4x more calculations\n//#define SSAA\n\n//updated:Gamma Correction\n\n//updated: edge depict\n//updated: parallax map\n/*------------utilities------------*/\n#define iR iResolution.xy\n#define iT iTime\n#define iM iMouse\nconst float MAX_DIST=20.;\nconst float MIN_DIST=1e-4;\nconst float MAX_STEP=80.;\nconst float EPS=1e-4;\nconst float INF=1e9;\nconst float PI=3.14159265;\nconst float DTA=PI/180.;\nstruct Ray\n{\n    vec3 o,d;\n};\nstruct Cam\n{\n    vec3 pos,dir;\n    vec3 r,u;\n}cam;\nstruct MarchPoint\n{\n    float d;\n    int id;\n};\nstruct MarchHit\n{\n    float d,marchTimes;\n    int id;\n};\nmat2x2 mrot(float r)\n{\n    r*=DTA;\n    float c=cos(r),s=sin(r);\n    return mat2x2(c,s,-s,c);\n}\nfloat sdCube(vec3 p,vec3 size)\n{\n    vec3 np=abs(p)-size*.5;\n    float o=length(max(np,vec3(0)));\n    float i=min(0.,max(np.x,max(np.y,np.z)));\n    return o+i;\n}\nfloat sdTorus(vec3 pos,vec2 rs)\n{\n    vec3 xzPro=pos;\n    pos.xz=vec2(0.);\n    xzPro.y=0.;\n    xzPro-=normalize(xzPro)*rs.x;\n    xzPro+=pos;\n    return (length(xzPro)-rs.y);\n}\nfloat sdSphere(vec3 p,float s)//p=uv-origin\n{\n    return length(p)-s;\n}\n/*---------------------------*/\n\nvec4 ACESFilm(vec4 x)//1->0.8,10->1()\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\nvec4 triplanar(sampler2D sam,vec3 p,vec3 n)\n{\n    vec4 x = texture( sam, p.yz );\n    vec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n    n*=n;\n\treturn x*n.x + y*n.y + z*n.z;\n}","name":"Common","description":"","type":"common"}]}