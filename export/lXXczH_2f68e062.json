{"ver":"0.1","info":{"id":"lXXczH","date":"1725910128","viewed":50,"name":"Dynamic Forms Smoothing","username":"Kabanya","description":"just 4 figures","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["mipt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3  eye      = vec3 ( 0, 0, 10 );\nconst vec3  light    = vec3  ( 0.0, 6.0, 5.0 );\nconst int   maxSteps = 70;\nconst float eps      = 0.01;\nconst float maxDist = 15.0;\n\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * h * k * (1.0 / 6.0);\n}\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nfloat sdRoundedCylinder(vec3 p, float ra, float rb, float h) {\n    vec2 d = vec2(length(p.xz) - 2.0 * ra + rb, abs(p.y) - h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - rb;\n}\n\nfloat dTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat dSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nvec2 sdf(in vec3 p, in mat3 m) {\n    vec3 q = m * p;\n\n    // Cylinder\n    float cylinderSdf = sdRoundedCylinder(q, 0.5, 0.2, 0.8);\n\n    // Sphere - cylinder\n    float moveSpeed = sin(iTime * 1.5) * 2.4;\n    vec3 spherePosition = vec3(0.0, moveSpeed, 0.0);\n    float sphereSdf = dSphere(q - spherePosition, 0.6);\n\n    // Torus\n    float orbitRadius = 2.0;\n    float orbitSpeed = iTime;\n    vec3 torusPosition = vec3(orbitRadius * cos(orbitSpeed), 0.0, orbitRadius * sin(orbitSpeed));\n    float torusSdf = dTorus(q - torusPosition, vec2(0.6, 0.15));\n\n    // Sphere - torus\n    float ballSpeed = iTime;\n    float ballHeight = sin(ballSpeed) * 1.5; \n    vec3 ballPosition = torusPosition + vec3(0.0, ballHeight, 0.0);\n    float ballSdf = dSphere(q - ballPosition, 0.2);\n\n    float smoothFactor = 1.0;\n    float blendedSdf = smin(cylinderSdf, sphereSdf, smoothFactor);\n    \n    if (blendedSdf < torusSdf && blendedSdf < ballSdf) {\n        if (cylinderSdf < sphereSdf) {\n            return vec2(blendedSdf, 1.0);\n        } else {\n            return vec2(blendedSdf, 4.0);\n        }\n    } else if (torusSdf < ballSdf) {\n        return vec2(torusSdf, 2.0);\n    } else {\n        return vec2(ballSdf, 3.0); \n    }\n}\n\nvec3 trace(in vec3 from, in vec3 dir, out bool hit, out float id, in mat3 m) {\n    vec3 p = from;\n    float totalDist = 0.0;\n    id = -1.0;\n    hit = false;\n\n    for (int steps = 0; steps < maxSteps; steps++) {\n        vec2 distAndID = sdf(p, m);\n        float dist = abs(distAndID.x);\n        \n        if (dist < eps) {\n            hit = true;\n            id = distAndID.y; \n            break;\n        }\n        \n        totalDist += dist;\n        if (totalDist > maxDist) {\n            break;\n        }\n        p += dist * dir;\n    }\n    return p;\n}\n\nvec3 generateNormal(vec3 z, float d, in mat3 m) {\n    float e = max(d * 0.5, eps);\n    float dx1 = sdf(z + vec3(e, 0, 0), m).x;\n    float dx2 = sdf(z - vec3(e, 0, 0), m).x;\n    float dy1 = sdf(z + vec3(0, e, 0), m).x;\n    float dy2 = sdf(z - vec3(0, e, 0), m).x;\n    float dz1 = sdf(z + vec3(0, 0, e), m).x;\n    float dz2 = sdf(z - vec3(0, 0, e), m).x;\n\n    return normalize(vec3(dx1 - dx2, dy1 - dy2, dz1 - dz2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    bool hit;\n    float id;\n    vec3 mouse = vec3(iMouse.xy / iResolution.xy - 0.5, iMouse.z - .5);\n    mat3 m = rotateX(6.0 * mouse.y) * rotateY(6.0 * mouse.x);\n    vec2 scale = 9.0 * iResolution.xy / max(iResolution.x, iResolution.y);\n    vec2 uv = scale * (fragCoord / iResolution.xy - vec2(0.5));\n    vec3 dir = normalize(vec3(uv, 0) - eye);\n    vec4 color = vec4(0, 0, 0, 1);\n    vec3 p = trace(eye, dir, hit, id, m);\n    \n    vec3 backgroundColor = vec3(0.91, 0.91, 0.93);\n        \n    if (!hit) {\n        color = vec4(backgroundColor, 1.0);\n        \n    } else {\n        vec3 l = normalize      (light - p);\n        vec3 v = normalize      (eye - p);\n        vec3 n = generateNormal (p, 0.001, m);\n        vec3 h = normalize      (l + v);\n        float nl = max(0.0, dot(n, l));\n        float hn = max(0.0, dot(h, n));\n        float nh = max(0.0, dot(n, h));\n        float sp = pow(hn, 150.0);\n        float alpha = 0.2;\n        float R = 5.0;\n        float roughness = 150.0;\n\n        vec3 objColor;\n        if (id == 1.0) {\n           objColor = vec3(0.8, 0.4, 0.0);\n        } else if (id == 4.0) {\n            objColor =mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 0.0),\n                      p.y * 0.5 + 0.5) * (1.0 - (p.y * 0.5 + 0.5) * (p.y * 0.5 + 0.5)); \n        } else if (id == 2.0) {\n            objColor = vec3(0, 0.5, 1); \n        } else if (id == 3.0) {\n            objColor = vec3(0.8, 0.4, 0.0); \n        }\n\n        // Lighting model selection\n        int lightingModel = 1; \n \n        switch (lightingModel) {\n            case 0: // Lambert\n                color = vec4(objColor * nl, 1.0);\n                break;\n            case 1: // Lambert + Phong\n                color = vec4(objColor * nl, 1.0) + 3.5 * sp * vec4(1, 1, 1, 1);\n                break;\n        }\n    }\n\n    fragColor = color;\n}\n","name":"Image","description":"","type":"image"}]}