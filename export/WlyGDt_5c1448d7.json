{"ver":"0.1","info":{"id":"WlyGDt","date":"1580654806","viewed":197,"name":"Robo-Walk","username":"shau","description":"Noodling","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define EPS .005\n#define FAR 200.\n#define ZERO (min(iFrame,0))\n\n//SDF functions from IQ\nfloat smin(float a, float b, float k) \n{\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) \n{\n\tfloat h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n\treturn mix(a, b, h) + k * h * (1.0 - h);\n}\n\nfloat planeIntersect(vec3 ro, vec3 rd, vec3 n, vec3 o) \n{\n    return dot(o - ro, n) / dot(rd, n);\n}\n\nfloat sdBox(vec3 p, vec3 b) \n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdSphere(vec3 p, float r) \n{\n    return length(p) - r;\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r) \n{\n  vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) \n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba*h) - r;\n}\n\nfloat sdEllipsoid(vec3 p, vec3 r) \n{\n    return (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\nfloat sdConeSection(vec3 p, float h, float r1, float r2) \n{\n    float d1 = -p.y - h,\n          q = p.y - h,\n          si = 0.5 * (r1 - r2) / h,\n          d2 = max(sqrt(dot(p.xz, p.xz) * (1.0 - si * si)) + q * si - r2, q);\n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);\n}\n\n//Mercury\nfloat pModPolar(inout vec2 p, float repetitions) \n{\n    float angle = 2.0 * PI / repetitions,\n          a = atan(p.y, p.x) + angle / 2.0,\n          r = length(p),\n          c = floor(a / angle);\n    a = mod(a, angle) - angle / 2.0;\n    p = vec2(cos(a), sin(a)) * r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions / 2.0)) c = abs(c);\n    return c;\n}\n\n\nvec2 near(vec2 a, vec2 b)\n{\n \tfloat s = step(a.x, b.x);\n    return s*a + (1.0 - s)*b;\n}\n\nvec2 dfThigh(vec3 p, float sgn, float a)\n{\n    p.yz *= rot(a);\n    vec3 q = p;\n    pModPolar(q.zy, 12.0);\n    q.xz *= rot(-0.6*sgn);\n    float light = sdCappedCylinder(p, 1.8, 0.6);   \n    float dark = sdBox(q - vec3(0.2*sgn, 0.0, 1.0), vec3(0.5, 0.06, 0.3));       \n    light = min(light, sdBox(p - vec3(0.2*sgn, -0.6, 2.0), vec3(0.6, 0.4, 2.0)));\n    dark = min(dark, sdBox(p - vec3(0.2*sgn, -0.0, 2.0), vec3(0.4, 0.3, 2.0)));\n    light = max(light, -sdCappedCylinder(p, 0.4, 1.0));  \n    dark = min(dark, sdCappedCylinder(p, 0.30, 1.0));  \n    light = min(light, sdCappedCylinder(p - vec3(0.2*sgn, -0.3, 4.0), 0.6, 0.8));  \n    light = max(light, -sdCappedCylinder(p - vec3(0.2*sgn, -0.3, 4.0), 0.3, 0.9));  \n    dark = max(dark, -sdBox(p - vec3(0.2*sgn, -0.3, 4.0), vec3(0.3, 1.0, 2.0)));\n    \n    return near(vec2(light, 1.0),\n                vec2(dark, 2.0));\n}\n\n\nvec2 dfLeg(vec3 p, float a)\n{\n    p.yz *= rot(a);\n    float dark = sdCappedCylinder(p, 1.2, 0.2);\n    vec3 q = p;\n    pModPolar(q.yz, 3.0);\n    dark = max(dark, -sdCappedCylinder(q - vec3(0.0, 1.5, 0.0), 0.8, 0.4));\n    dark = min(dark,  sdCappedCylinder(p, 0.25, 1.0));    \n    float light = sdBox(p - vec3(0.0, -6.0, 0.0), vec3(0.24, 6.0, 0.24));\n    dark = min(dark,  sdBox(p - vec3(0.0, -6.0, 0.0), vec3(0.4, 3.0, 0.4)));\n    light = min(light,  sdBox(p - vec3(0.0, -6.0, 0.8), vec3(0.8, 6.0, 0.1)));\n    light = max(light, -sdBox(p - vec3(0.0, -6.0, 0.8), vec3(0.4, 5.0, 0.2)));\n    \n    return near(vec2(light, 1.0),\n                vec2(dark, 2.0));\n}\n\nvec2 dfFoot(vec3 p, float sgn)\n{\n \tfloat light = sdCappedCylinder(p, 0.8, 1.0);\n    vec3 q = p;\n    q.x = abs(q.x);\n \tlight = min(light, sdCappedCylinder(q - vec3(0.7, 0.0, 0.0), 1.0, 0.2));\n    //light = min(light, sdBox(q - vec3(0.7, -0.5, 0.0), vec3(0.2, 0.5, 1.0)));\n \tlight = max(light, -sdCappedCylinder(p, 0.3, 1.2));\n \tfloat dark = sdCappedCylinder(p, 0.25, 1.2);\n    float ft = sdBox(p - vec3(0.0, -1.5, 0.2), vec3(1.4, 0.3, 2.0));\n    ft = max(ft, -sdBox(p - vec3(0.5*sgn, -1.5, 2.0), vec3(1.0, 0.7, 1.0)));    \n    light = min(light, ft);\n    q.yz *= rot(-0.4);\n    dark = min(dark, sdBox(q - vec3(0.0, -1.0, -1.4), vec3(0.7, 1.0, 2.4)));\n    dark = max(dark, -sdBox(p - vec3(0.0, -2.6, -0.4), vec3(2.0, 1.0, 3.0)));\n    dark = min(dark, sdConeSection(p - vec3(0.0, -2.4, -3.0), 0.8, 1.6, 0.8));\n    \n    return near(vec2(light, 1.0),\n                vec2(dark, 2.0));\n}\n\nvec2 dfCab(vec3 p) {\n    \n    p.xz *= rot(sin(T*0.3)*0.3);\n    vec3 q = p;\n    q.yz *= rot(-0.3 + sin(T*0.23)*0.1);\n    \n    float light = sdEllipsoid(q - vec3(0.0, 0.6, 1.0), vec3(3.0, 3.0, 6.0));\n    light = smax(light, -sdEllipsoid(q - vec3(0.0, 0.6, 1.0), vec3(0.6, 3.9, 6.9)), 0.1);\n    light = smin(light, sdCappedCylinder(q - vec3(0.0, 0.0, 4.0), 2.4, 3.0), 0.4);\n    light = max(light, -sdCappedCylinder(q - vec3(0.0, 0.0, 4.0), 2.2, 3.2));\n    light = smax(light, -sdEllipsoid(q - vec3(0.0, 0.6, 3.0), vec3(2.6, 1.6, 6.0)), 0.2);\n\tlight = smax(light, -sdBox(q -  vec3(0.0, -1.6, 1.0), vec3(5.0, 1.0, 6.0)), 0.2);\n    float dark = sdEllipsoid(q.yxz - vec3(0.8, 0.0, -2.6), vec3(1.4, 2.0, 2.8));\n    dark = smax(dark, -sdBox(vec3(mod(q.y, 0.6) + 0.3, q.x, q.z) - vec3(0.8, 0.0, -2.5), vec3(0.2, 3.0, 3.0)), 0.06);\n    dark = min(dark, sdSphere(p, 2.0));\n    dark = smin(dark, sdEllipsoid(q - vec3(0.0, 0.6, 0.0), vec3(4.4, 1.0, 1.0)), 0.2);\n    \n    q.x = abs(q.x);\n    \n    light = min(light, sdCappedCylinder(q.zyx - vec3(0.0, 0.6, 4.2), 0.3, 1.0));\n    dark = min(dark, sdCappedCylinder(q.zyx - vec3(-1.0, 0.6, 4.2), 0.16, 3.0));\n    light = min(light, sdCappedCylinder(q.zyx - vec3(-3.6, 0.6, 4.2), 0.24, 0.1));\n    dark = max(dark, -sdCappedCylinder(q.zyx - vec3(-0.6, 0.6, 4.2), 0.1, 4.0));\n    light = min(light, sdCappedCylinder(q - vec3(3.6, 0.6, 0.0), 1.4, 0.1));\n\n    return near(vec2(light, 1.0), vec2(dark, 2.0));\n}\n\nvec2 map(vec3 p) {\n    \n    //animation\n    vec4 leftHip = texture(iChannel0, LH/R),\n         rightHip = texture(iChannel0, RH/R),\n         leftKnee = texture(iChannel0, LK/R),\n         rightKnee = texture(iChannel0, RK/R),\n         leftAnkle = texture(iChannel0, LA/R),\n         rightAnkle = texture(iChannel0, RA/R),\n         height = texture(iChannel0, H/R);\n    \n    p.y -= height.x;\n\n    //platform\n    float light = sdBox(p, vec3(0.4, 0.4, 2.0));\n    light = min(light, sdCappedCylinder(p.yxz - vec3(0.0, 0.0, -2.0),  1.6, 0.4));\n    light = min(light, sdCappedCylinder(p.yxz - vec3(0.3, 0.0, -2.0),  2.0, 0.2));\n    float dark = sdCappedCylinder(p - vec3(0.0, 0.0, 2.0),  1.0, 2.4);\n    light = min(light, sdCappedCylinder(p - vec3(0.0, 0.0, 2.0),  1.6, 0.8));\n\n    vec2 nearest = near(vec2(light, 1.0),\n                        vec2(dark, 2.0));\n    \n\tnearest = near(nearest, dfCab(p - vec3(0.0, 2.0, -2.0)));  \n    nearest = near(nearest, dfThigh(p - leftHip.xyz, -1.0, leftHip.w));    \n    nearest = near(nearest, dfThigh(p - rightHip.xyz, 1.0, rightHip.w));    \n    nearest = near(nearest, dfLeg(p - leftKnee.xyz, leftKnee.w));\n    nearest = near(nearest, dfLeg(p - rightKnee.xyz, rightKnee.w));\n    nearest = near(nearest, dfFoot(p - leftAnkle.xyz, -1.0));\n    nearest = near(nearest, dfFoot(p - rightAnkle.xyz, 1.0));\n\n    return nearest;\n}\n\nvec3 normal(vec3 p) {  \n    vec4 n = vec4(0.0);\n    for (int i=ZERO; i<4; i++) {\n        vec4 s = vec4(p, 0.0);\n        s[i] += EPS;\n        n[i] = map(s.xyz).x;\n    }\n    return normalize(n.xyz-n.w);\n}\n\n//IQ - https://iquilezles.org/articles/raymarchingdf\nfloat AO(vec3 p, vec3 n) {\n    float ra = 0., w = 1., d = 0.;\n    for (float i = 1.; i < 8.; i += 1.){\n        d = i / 5.;\n        ra += w * (d - map(p + n * d).x);\n        w *= .5;\n    }\n    return 1. - clamp(ra, 0., 1.);\n}\n\n//IQ - https://www.shadertoy.com/view/lsKcDD\nfloat shadow(vec3 ro, vec3 rd, float mint, float tmax) {\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10;\n    \n    for (int i = ZERO; i < 32; i++) {\n\t\tfloat h = map(ro + rd * t).x;\n        float y = h * h / (2.0 * ph);\n        float d = sqrt(h * h - y * y);\n        res = min(res, 10.0 * d / max(0.0, t-y));\n        ph = h;        \n        t += h;\n        if (res < 0.0001 || t > tmax) break;\n    }\n    \n    return mix(0.3, 1.0, smoothstep(0.2, 0.4, res));\n}\n\nvec3 camera(vec2 U, vec3 ro, vec3 la, float fl) \n{\n    vec2 uv = (U - R*.5) / R.y;\n    vec3 fwd = normalize(la-ro),\n         rgt = normalize(vec3(fwd.z, 0., -fwd.x));\n    return normalize(fwd + fl*uv.x*rgt + fl*uv.y*cross(fwd, rgt));\n}\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n    vec3 pc = vec3(0),\n         sc = vec3(0),\n         p = vec3(0),\n         n = vec3(0),\n         ld = normalize(vec3(4.0, 5.0, -2.0)),\n         la = vec3(0.0, 10.0, 0.0),\n         ro = vec3(0.0, 20.0 + sin(T*0.21)*10.0, -24.0 - cos(T*0.17) * 6.0),\n         fo = vec3(0.0, -3.2, 0.0),\n         fn = vec3(0.0, 1.0, 0.0);\n    \n    ro.xz *= rot(T*-0.2-PI*0.3);\n    vec3 rd = camera(U, ro, la, 1.4);\n    \n    float mint = FAR,\n          t = 0.0,\n          ft = planeIntersect(ro, rd, fn, fo); \n\n    if (ft>0.0 && ft<FAR)\n    {\n        mint = ft;\n     \tp = ro + rd*ft;\n        n = fn;\n        sc = vec3(1);\n    }\n    \n    for (int i=ZERO; i<120; i++)\n    {\n        vec3 rp = ro + rd*t;\n        vec2 ns = map(rp);\n        if (ns.x<EPS)\n        {\n            mint = t;\n            p = rp;\n            n = normal(p);\n            sc = ns.y==1.0 ? vec3(1) : vec3(0.5);;\n            break;\n        }\n        t += ns.x;\n        if (t>mint)\n            break;\n    }\n    \n    if (p!=vec3(0)) \n    {\n        float diff = mix(1.0, 0.8, smoothstep(0.6, 0.8, dot(ld, n))),\n              ao = AO(p, n), //,\n              sh = shadow(p + n*EPS, ld, 0.0, mint);        \n        pc = sc*diff*ao*sh;\n    }\n    \n    pc = pow(pc, vec3(1.0/2.4));\n    pc /= (1.0 + mint*mint*0.004);\n    \n    C = vec4(pc*2.0, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by SHAU - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n    float AT = mod(T*2.6, 2.0*PI);\n    \n    float a1L = cos((AT - PI) + max(0.0, sin(AT - PI)) )*0.3;\n    float a2L = sin(AT - PI)*-0.4 + 0.2;\n    float a1R = cos(AT + max(0.0, sin(AT)) )*0.3;\n    float a2R = sin(AT)*-0.4 + 0.2;\n    \n    vec4 leftHip = vec4(-3.0, 0.0, 2.0 + cos(AT), a1L);\n    vec4 rightHip = vec4(3.0, 0.0, 2.0 + cos(AT - PI), a1R);\n    \n    vec2 kyzL = vec2(-0.3, 4.0)*rot(-a1L);\n    vec2 kyzR = vec2(-0.3, 4.0)*rot(-a1R);\n    \n    vec4 leftKnee = vec4(-3.0, leftHip.y + kyzL.x, leftHip.z + kyzL.y, a2L);\n    vec4 rightKnee = vec4(3.0, rightHip.y + kyzR.x, rightHip.z + kyzR.y, a2R);\n    \n    vec2 ayzL = vec2(-12.0, 0.8)*rot(-a2L);\n    vec2 ayzR = vec2(-12.0, 0.8)*rot(-a2R);\n    \n    vec4 leftAnkle = vec4(-3.2, leftKnee.y + ayzL.x, leftKnee.z + ayzL.y, 0.0);\n    vec4 rightAnkle = vec4(3.2, rightKnee.y + ayzR.x, rightKnee.z + ayzR.y, 0.0);\n    \n    float height = abs(min(leftAnkle.y, rightAnkle.y));\n\n    if (U==LH)\n    {\n        C = leftHip;\n    }\n    else if (U==RH)\n    {\n        C = rightHip;\n    }\n    else if (U==LK)\n    {\n        C = leftKnee;\n    }\n    else if (U==RK)\n    {\n        C = rightKnee;\n    }\n    else if (U==LA)\n    {\n        C = leftAnkle;\n    }\n    else if (U==RA)\n    {\n        C = rightAnkle;\n    }\n    else if (U==H)\n    {\n        C = vec4(height, 0.0, 0.0, 0.0);\n    }\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Created by SHAU - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define LH vec2(0.5, 0.5)\n#define RH vec2(1.5, 0.5)\n#define LK vec2(2.5, 0.5)\n#define RK vec2(3.5, 0.5)\n#define LA vec2(4.5, 0.5)\n#define RA vec2(5.5, 0.5)\n\n#define H vec2(6.5, 0.5)\n\n#define PI 3.141592\n#define R iResolution.xy\n#define T iTime\n\n//Fabrice - compact rotation\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n","name":"Common","description":"","type":"common"}]}