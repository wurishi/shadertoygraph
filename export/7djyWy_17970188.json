{"ver":"0.1","info":{"id":"7djyWy","date":"1644038875","viewed":79,"name":"my balls2","username":"skk","description":"x","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["x"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.1415926535897932384626433832795\n\nuint lcg(inout uint rng)\n{\n    rng = rng * 1099087573U;\n    return rng;\n}\n\nmat3 rotate_y(float t)\n{\n    return mat3(cos(t), 0, -sin(t),\n                0, 1, 0,\n                sin(t), 0, cos(t));\n}\n\nfloat lcg_f(inout uint rng)\n{\n    return float(lcg(rng) % 1024U) / 1024.;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat field(vec3 x, out int id)\n{\n    id = 1;\n    float m;\n    \n    m = -1. / length(x - vec3(2. * cos(iTime), 0.5 * sin(iTime), 0.1))\n        - 1. / length(x - vec3(1., 1. * sin(iTime * 1.1), -0.3 * cos(iTime * 3.)))\n        - 1. / length(x - vec3(cos(iTime), 0.5, sin(iTime))) + 3.;\n    \n    m = min(m, length(x - vec3(2., -1., -0.5)) - 0.5);\n    m = min(m, sdBox(rotate_y(0.3) * x + vec3(-2., -0.5, 1.), vec3(0.5)));\n    return m;\n}\n\nvec3 field_normal(vec3 x, float eps)\n{\n    vec2 e = vec2(eps, 0.);\n    int id;\n    return normalize(vec3(field(x + e.xyy, id) - field(x - e.xyy, id),\n                          field(x + e.yxy, id) - field(x - e.yxy, id),\n                          field(x + e.yyx, id) - field(x - e.yyx, id)));\n}\n\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k)\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for (float t = mint; t < maxt;)\n    {\n        int id;\n        float h = field(ro + rd * t, id);\n        if (h < 0.001)\n            return 0.;\n\n        float y = h * h / (2. * ph);\n        float d = sqrt(h * h - y * y);\n        res = min(res, k * d / max(0., t - y));\n        ph = h;\n        t += h;\n    }\n\n    return res;\n}\n\nvec3 march(vec3 ro, vec3 rd, out int id)\n{\n    float t = 0.;\n    for (int i = 0; i < 32; i++)\n    {\n        vec3 nr = ro + rd * t;\n        float h = field(nr, id);\n        if (h < 0.001)\n        {\n            return nr;\n        }\n            \n        t += h;\n    }\n\n    id = 0;\n    return vec3(0.);\n}\n\nvec3 march_internal(vec3 ro, vec3 rd)\n{\n    for (float t = 0.04; t < 3.; t += 0.04)\n    {\n        vec3 nr = ro + rd * t;\n        int id;\n        float h = field(nr, id);\n        if (h > 0.04)\n            return nr;\n    }\n    \n    return ro + 3. * rd;\n}\n\nvec3 back_color(vec3 ro, vec3 rd)\n{\n    vec3 planenormal = vec3(0., 1., 0.);\n    vec3 planepoint = vec3(0., -2., 0.);\n    float dist = dot(planepoint - ro, planenormal) / dot(rd, planenormal);\n    vec3 floorpos = ro + dist * rd;\n    \n    if (dist < 0.) return vec3(0.5, 0.5, 1.);\n    \n    vec3 gridcolor = mix(vec3(0., 1., 0.), vec3(0.5, 0., 1.), float((int(floorpos.x * 1.1 + 100.) + int(floorpos.z * 1.1 + 100.)) % 2));\n    int id;\n    // gridcolor = vec3(sin(field(floorpos, id)));\n    vec3 withfog = mix(gridcolor, vec3(0.5, 0.5, 1.), clamp(length(floorpos) / 50., 0., 1.));\n    return withfog;\n}\n\nvec3 dielectric_interface(vec3 i, vec3 n, float r, inout uint rng, out bool refracted)\n{\n    float i_n = dot(i, n);\n    float on2 = 1. - r * r * (1. - i_n * i_n);\n    if (on2 > 0.)\n    {\n        float on = sqrt(on2);\n        float a = i_n / on;\n        float Rs = (1. + r * a) / (1. - r * a);\n        float Rp = (r + a) / (r - a);\n        float R = (Rs * Rs + Rp * Rp) / 2.;\n        if (lcg_f(rng) > R)\n        {\n            refracted = true;\n            return r * i - (r * i_n + on) * n;\n        }\n    }\n    refracted = false;\n    return i - 2. * i_n * n;\n}\n\nvec3 reflect(vec3 i, vec3 n)\n{\n    return i - 2. * dot(i, n) * n;\n}\n\n#define N_MC 15\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    uint rng = uint(fragCoord.x * fragCoord.y * iTime);\n    float swing_angle = iMouse.x / iResolution.x * 2. * M_PI + iTime * 0.5;\n    vec3 camera = rotate_y(swing_angle) * vec3(0., 0., -6.) + vec3(0., 1., 0.);\n \n\n    for (int mc = 0; mc < N_MC; mc++) {\n        float intensity = 1.;\n        vec2 xy = (((fragCoord + vec2(lcg_f(rng), lcg_f(rng))) / iResolution.xy) * 2. - 1.) * vec2(iResolution.x / iResolution.y, 1.);\n        vec3 ray = rotate_y(swing_angle) * normalize(vec3(xy - vec2(0., 0.5), 2.));\n        vec3 ro = camera, rd = ray;\n\n        bool inside = false;\n        \n        for (int i = 0; i < 4; i++) {\n            int hitid;\n            vec3 hitpos = inside ? march_internal(ro, rd) : march(ro, rd, hitid);\n\n            if (hitid > 0)\n            {\n                vec3 normal = field_normal(hitpos, 1e-4);\n                vec3 light = vec3(0., 5., sin(iTime));\n                float refractive_index = 2.;\n\n                bool refracted;\n                vec3 scattered = normalize(\n                    dielectric_interface(ray, normal, inside ? refractive_index : 1. / refractive_index, rng, refracted));\n                \n                if (refracted)\n                { \n                    rd = scattered;\n                    ro = hitpos + rd * 0.02;\n                }\n                else\n                {\n                    rd = scattered;\n                    ro = hitpos + rd * 0.02;\n                }\n                \n                intensity *= 0.9;\n                \n                inside = refracted ? !inside : inside;\n                \n                if (i == 3)\n                {\n                    fragColor.xyz += intensity * back_color(ro, rd) / float(N_MC);\n                }\n            }\n            else\n            {\n                fragColor.xyz += intensity * back_color(ro, rd) / float(N_MC);\n                break;\n            }\n        }\n    }\n    \n    fragColor.xyz = pow(fragColor.xyz, vec3(0.55));\n\n\n    fragColor.w = 1.;\n}","name":"Image","description":"","type":"image"}]}