{"ver":"0.1","info":{"id":"wtsBzf","date":"1597377441","viewed":150,"name":"Fluid Fork","username":"j91000","description":"based on https://www.shadertoy.com/view/XtGcDK\ninstead of tracking the pressure in one of the shader channels, i just try to enforce rough imcompressibility at each frame.\nClick and drag to add ink and velocity.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["fluid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvec4 t (vec2 v) {return texture(iChannel0,v/iResolution.xy);}\nvoid mainImage( out vec4 C, in vec2 U )\n{vec2 R = iResolution.xy;\n    vec4 me = t(U);\n    me.z-=1.;\n    \n    C = 1.-3.*me.wwww;\n    vec3 d = vec3(t(U+vec2(1,0)).w-t(U-vec2(1,0)).w,t(U+vec2(0,1)).w-t(U-vec2(0,1)).w ,2.);\n    \n    C.xyz -= max(vec3(0),sin(vec3(100.*length(me.xy),-5.*me.z,368.*d.y)*me.w));\n    //C=t(U);\n    //if(abs(U.x-R.x/1.2)<1.){C=mix(C,vec4(0.),.1);}\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//advection buffer\nvec2 R;\nfloat ln (vec2 p, vec2 a, vec2 b) { // returns distance to line segment for mouse input\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\nvec4 get ( vec2 U ) {return texture(iChannel0,U/R);} // samples fluid\n\nvoid mainImage( out vec4 Q, in vec2 pos )\n{   R = iResolution.xy;\n Q=get(pos);//Q is the output vector. x and y are velocity, while z is pressure. no touch w i guess\n const int dt=10;\n\n vec2 currentPos=pos;\n for(int i=0;i<dt;i++){\n     currentPos=currentPos-Q.xy;//advect step \n vec4 newField=get(currentPos);\n Q=newField;//this is the velocity/ink upstream from here.\n }\n /*just a little ink diffusion. not really worth the extra fetches?\n  vec4 qn=get(currentPos+vec2(0.,1.));\n vec4 qs=get(currentPos+vec2(0.,-1.));\n vec4 qe=get(currentPos+vec2(1.,0.));\n vec4 qw=get(currentPos+vec2(-1.,0.));\n vec4 meanVec=(qn+qs+qe+qw)/4.;\n Q.w=mix(Q.w,meanVec.w,0.01);\n */\n\n \n // get mouse pos and prev pos from buffer D\n \tvec4 mouse = texture(iChannel2,vec2(0.5));\n \t\t// find distance to line segment that is from mouse start to mouse end\n        float q = ln(pos,mouse.xy,mouse.zw);\n        vec2 m = mouse.xy-mouse.zw;\n        float ln = length(m);\n        if (mouse.z>0.&&ln>0.) {\n            // accelerate fluid and add ink\n            Q.xyw = mix(Q.xyw,vec3(-1,-1,1)*vec3(-normalize(m)*min(ln,20.)/25.,1.),max(0.,5.-q)/25.);\n        }\n \n \t// init zeros\n \tif (iFrame < 1) Q = vec4(0);\n \t// add some ink and velocity to the middle of the screen\n \tif (iFrame < 14 && length(pos-0.5*R) < 20.) Q.xyw = vec3(0,.1,1);\n \t// bound the edges and make them still\n \tif (pos.x<1.||pos.y<1.||R.x-pos.x<1.||R.y-pos.y<1.) Q.xyw*=0.;\n //if(length(R/2.-pos)<40.){Q.y+=.01;}\n}\n\t  \n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// keep track of mouse\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 p = texture(iChannel0,fragCoord/iResolution.xy);\n    if (iMouse.z>0.) {\n        if (p.z>0.) fragColor =  vec4(iMouse.xy,p.xy);\n    \telse fragColor =  vec4(iMouse.xy,iMouse.xy);\n    }\n    else fragColor = vec4(-iResolution.xy,-iResolution.xy);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//divergence buffer: B and C are identical, except for the sampling length they use to approximate divergence\nvec2 R;\nvec4 get ( vec2 U ) {return texture(iChannel0,U/R);} // samples fluid\nfloat divergenceAt(vec2 p,float sl,bool LEFT){//sL is sampling length\n    float netFlow=0.;\n    vec2 n=vec2(0.,-sl)+p;\n    vec2 nw=vec2(-sl,-sl)+p;\n    vec2 ne=vec2(sl,-sl)+p;\n    vec2 w=vec2(-sl,0.)+p;\n    vec2 s=vec2(0.,sl)+p;\n    vec2 sw=vec2(-sl,sl)+p;\n    vec2 se=vec2(sl,sl)+p;\n\tvec2 e=vec2(sl,0.)+p;\n    vec2[4] posList;\n    posList= vec2[](n,w,e,s);\n    float total=0.;\n for(int i=0;i<4;i++){\n     vec4 neighbField=get(posList[i]);\n     vec2 neighbPos=posList[i];\n     vec2 offsetVector=p-posList[i];//always gets normalized\n     float len=length(offsetVector);\n     if(len>0.){//unless its a 0 vector\n     total=total+1.;\n     offsetVector=offsetVector/len;\n     \n     //for each neighbor, add the dot product of their offset vector and their velocity vector to the sum.\n     //this is the portion of their velocity that points in your direction.\n     float contribution=dot(offsetVector,neighbField.xy);\n     netFlow+=contribution;\n     }\n }\n    return netFlow/float(total);\n}\nvec2 laplacianAt(vec2 p,float sl,bool LEFT){\n    //laplacian is the gradient of divergence. calculate divergence in a neighb and then sum offset*div() at each spot\n    \n    vec2 lap=vec2(0.,0.);\n    vec2 n=vec2(0.,-sl)+p;\n    vec2 nw=vec2(-sl*5.,-sl*5.)+p;\n    vec2 ne=vec2(sl*5.,-sl*5.)+p;\n    vec2 w=vec2(-sl,0.)+p;\n    vec2 s=vec2(0.,sl)+p;\n    vec2 sw=vec2(-sl*5.,sl*5.)+p;\n    vec2 se=vec2(sl*5.,sl*5.)+p;\n\tvec2 e=vec2(sl,0.)+p;\n    vec2[4] posList;\n    posList= vec2[](n,w,e,s);\n    int total=0;\n for(int i=0;i<4;i++){\n     vec2 offsetVec=posList[i]-p;\n     \n     float len=length(offsetVec);\n     if(len>0.){\n         total++;\n     float neighbDiv=divergenceAt(posList[i],sl,LEFT);//divergence at the neighbor's location\n     offsetVec=offsetVec/(len);\n     lap=lap+offsetVec*neighbDiv;\n     }\n }\n    return lap/float(total);\n}\nvoid mainImage( out vec4 Q, in vec2 pos )\n{\n    R = iResolution.xy;\n \tQ=get(pos);\n    float sampleLength=4.; \n bool LEFT=true;//pos.x<R.x/1.2;\n    vec2 lap=laplacianAt(pos,sampleLength,LEFT);//dt*dt?????????????? its a second order derivative\n Q.xy-=lap*1.;\n    \n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//divergence buffer: B and C are identical, except for the sampling length they use to approximate divergence\nvec2 R;\nvec4 get ( vec2 U ) {return texture(iChannel0,U/R);} // samples fluid\nfloat divergenceAt(vec2 p,float sL,bool LEFT){//sL is sampling length\n    float netFlow=0.;\n    vec2 n=vec2(0.,-sL)+p;\n    vec2 nw=vec2(-sL,-sL)+p;\n    vec2 ne=vec2(sL,-sL)+p;\n    vec2 w=vec2(-sL,0.)+p;\n    vec2 s=vec2(0.,sL)+p;\n    vec2 sw=vec2(-sL,sL)+p;\n    vec2 se=vec2(sL,sL)+p;\n\tvec2 e=vec2(sL,0.)+p;\n    vec2[8] posList;\n    if(LEFT){posList= vec2[](n,w,e,s,p,p,p,p);}\n    else{posList=vec2[](n,nw,ne,w,e,s,sw,se);}\n    float total=0.;\n for(int i=0;i<posList.length();i++){\n     vec4 neighbField=get(posList[i]);\n     vec2 neighbPos=posList[i];\n     vec2 offsetVector=p-posList[i];//always gets normalized\n     float len=length(offsetVector);\n     if(len>0.){//unless its a 0 vector\n     total=total+1.;\n     offsetVector=offsetVector/len;\n     \n     //for each neighbor, add the dot product of their offset vector and their velocity vector to the sum.\n     //this is the portion of their velocity that points in your direction.\n     float contribution=dot(offsetVector,neighbField.xy);\n     netFlow+=contribution;\n     }\n }\n    return netFlow/float(total);\n}\nvec2 laplacianAt(vec2 p,float sl,bool LEFT){\n    //laplacian is the gradient of divergence. calculate divergence in a neighb and then sum offset*div() at each spot\n    \n    vec2 lap=vec2(0.,0.);\n    vec2 n=vec2(0.,-sl)+p;\n    vec2 nw=vec2(-sl*5.,-sl*5.)+p;\n    vec2 ne=vec2(sl*5.,-sl*5.)+p;\n    vec2 w=vec2(-sl,0.)+p;\n    vec2 s=vec2(0.,sl)+p;\n    vec2 sw=vec2(-sl*5.,sl*5.)+p;\n    vec2 se=vec2(sl*5.,sl*5.)+p;\n\tvec2 e=vec2(sl,0.)+p;\n    vec2[8] posList;\n    if(LEFT){posList= vec2[](n,w,e,s,p,p,p,p);}\n    else{posList=vec2[](n,e,w,s,nw,ne,sw,se);}\n    int total=0;\n for(int i=0;i<posList.length();i++){\n     vec2 offsetVec=posList[i]-p;\n     \n     float len=length(offsetVec);\n     if(len>0.){\n         total++;\n     float neighbDiv=divergenceAt(posList[i],sl,LEFT);//divergence at the neighbor's location\n     offsetVec=offsetVec/(len);\n     lap=lap+offsetVec*neighbDiv;\n     }\n }\n    return lap/float(total);\n}\nvoid mainImage( out vec4 Q, in vec2 pos )\n{R = iResolution.xy;\n Q=get(pos);\n   float sampleLength=1.; \n bool LEFT=true;//pos.x<R.x/1.2;\n    vec2 lap=laplacianAt(pos,sampleLength,LEFT);//dt*dt?????????????? its a second order derivative\n Q.xy-=lap*1.;\n    \n    \n}","name":"Buffer C","description":"","type":"buffer"}]}