{"ver":"0.1","info":{"id":"tsfBWr","date":"1592595745","viewed":101,"name":"Diamond Voxels","username":"spalmer","description":"A simple way to get a good disc packing (not the best, but close); it's the 2d version of the Rhombic Dodecahedron Voxels tiling technique I came up with.  ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","voxel","tiling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// a simple 2D version of the technique in\n// Rhombic Dodecahedron Voxels at\n// https://shadertoy.com/view/WdXBR8\n\n// yeah, diamond tiling is completely equivalent\n// to square tiling, but only in 2 dimensions.\n// In any case doing it like this avoids\n// much of the rescaling and rotating of the\n// other diamond to square mapping technique.\n\n// FIXME simplify the parameterization\nconst float phi = (sqrt(5.)+1.)*.5\n, voxtile = 1./4.\n, discsize = sqrt(.5) //.9 //1. //.5 // relative to cell scale (1/voxtile)\n;\nconst vec2 voxorg = vec2(0);\n\nfloat shape(vec2 q)\n{\n    if (fract(iTime * .2) > .9) return length(q); // show inscribed disc\n    return abs(q.x) + abs(q.y) - .275*voxtile; // a diamond\n}\n\nvec2 voxpos(ivec2 i)\n{\n//    i.x += (i.x^i.y)&1; // ensure using a valid id\n    vec2 p = vec2(i);\n    return p * voxtile + voxorg;\n}\n\n// given world space position, return closest voxel id\nivec2 voxid(vec2 p)\n{\n    p -= voxorg;\n    p /= voxtile;\n    ivec2 i = ivec2(round(p)); //floor(p + .5)); //\n    // diamond voronoi cell tiling\n    if (((i.x^i.y)&1) != 0) {\n        vec2 d = p - vec2(i);\n        vec2 a = abs(d);\n        if (a.x > a.y) i.x += int(sign(d.x));\n        else           i.y += int(sign(d.y));\n    } // (rhombic dodecahedrons in 3D)\n    return i;\n}\n    // beware; GLES sign seems buggy and can have issues\n\nbool isVoxel(ivec2 i)\n{\n    return i.y >= 0 && i.y <= 1;\n}\n\n// even rows have odd cells empty, \n// odd rows have even cells empty.\nivec2 vstorage(ivec2 vid)\n{\n\t// divide x by 2 avoids interleaving data\n    vid.x >>= 1;\n\t// or just combine even & odd rows\n    //vid.y >>= 1;\n    return vid;\n}\n\nvec3 hue(float x)\n{\n    return cos(vec3(0,2,4) + x*6.28);\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec2 r = iResolution.xy\n    , m = iMouse.xy\n    , q = (p + p - r) / r.y\n    , n = (m + m - r) / r.y\n    ;\n    ivec2 i = voxid(q), mi = voxid(n);\n    vec2 qo = voxpos(i)\n    , x = q - qo // relative to closest cell's center\n    ;\n\tfloat d = shape(x) - discsize*voxtile\n    , g = clamp(.5 - r.y*.5*d, 0., 1.);\n    g *= pow(abs(sin(d*64.)), .25); // isolines - not antialiased\n    vec3 c = vec3(g);\n\tif (i != mi)\n    \tc *= hue(dot(vec2(i), vec2(7,1.3)) * phi);\n    c = pow(c, vec3(1./2.2));\n    o = vec4(c, 1);\n}\n\n\n// a bit different if you want cell corner on the origin instead,\n// here we put the cell center on the screen center\n\n// alternate rotated-grid implementation of voxpos\n//    vec2 p = (mat2(1,-1,1,1)) * vec2(i);\n// sqrt(.5) * // not needed\n// alternate rotated-grid implementation of voxid\n//    p = p * (.5 * mat2(1,-1,1,1));\n//    return ivec2(round(p)); // require change voxpos also\n// problematically does not aid packing results into\n// rectangular buffers efficiently like main way\n//    // now must shuffle coordinates to match\n//    //j.y -= j.x >> 1; j.y <<= 1; if ((j.x & 1) != 0) ++j.y; return j;  // ?\n// gave up trying to use equivalent id's, may as well use other way","name":"Image","description":"","type":"image"}]}