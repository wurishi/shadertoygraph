{"ver":"0.1","info":{"id":"Dt33zM","date":"1682074280","viewed":69,"name":"Raytracing pt 2: Lambert / Phong","username":"TotoShampoin","description":"Previously: https://www.shadertoy.com/view/Dt3Gz8 \nThis time, I was taught to do a Lambert light and a Phong light.\nSo here you go!","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","lambert"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NB_SPHERE 2\n#define NB_LIGHT  1\n\nstruct Scene {\n    Sphere spheres[NB_SPHERE];\n    Light lights[NB_LIGHT];\n};\n\nvoid basicLight(Intersection i, inout vec4 fragColor) {\n    fragColor = i.material.diffuse;\n}\n\nvoid lambertLight(Scene scene, Intersection i, inout vec4 fragColor) {\n    fragColor = vec4(0);\n    for(int n = 0; n < NB_LIGHT; n++) {\n        Light l = scene.lights[n];\n        vec3 IL = (l.position - i.position);\n        fragColor += (i.material.diffuse * l.color * dot(i.normal, normalize(IL)))/dot(IL, IL);\n    }\n}\n\n/*\n\nColorRGB& Id = I.material.diffuse;\nColorRGB& Is = I.material.specular;\nColorRGB& Lc = light.color;\nVector3D N = I.normal;\nPoint3D IL = (light.position - I.position);\nfloat& s = I.material.shininess;\nPoint3D R = reflect(IL, N).normalize();\nPoint3D V = I.position.normalize();\nfinal_color += (Id * Lc * (N * IL.normalize()))/(IL * IL) + \n    Is * Lc * (max(0, pow(R * V, s)))/(IL * IL);\n*/\n\nvoid phongLight(Scene scene, Intersection i, inout vec4 fragColor) {\n    fragColor = vec4(0);\n    for(int n = 0; n < NB_LIGHT; n++) {\n        Light l = scene.lights[n];\n        vec3 IL = (l.position - i.position);\n        float IL2 = dot(IL, IL);\n        vec3 R = normalize(IL - i.normal * (2. * dot(IL, i.normal)));\n        vec3 V = normalize(i.position);\n        fragColor += i.material.diffuse * l.color * dot(i.normal, normalize(IL))/IL2;\n        fragColor += i.material.specular * l.color * max(0., pow(dot(R, V), i.material.shininess))/IL2;\n    }\n}\n\n\nvoid rayTrace(Scene scene, vec2 uv, inout vec4 fragColor) {\n    Ray r;\n    Intersection i, _i;\n    r.direction = vec3(\n        uv.x,\n        uv.y,\n        -1.\n    );\n    bool touched = false, _touched = false;\n    float t = 0., _t = 0.;\n    for(int n = 0; n < NB_SPHERE; n++) {\n        _touched = intersectSphere(r, scene.spheres[n], _i, _t);\n        if(_touched) {\n            if(!touched || _t < t) {\n                t = _t;\n                i = _i;\n            }\n            touched = true;\n        }\n    }\n    if(touched) {\n        //basicLight(i, fragColor);\n        //lambertLight(scene, i, fragColor);\n        phongLight(scene, i, fragColor);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float AR = iResolution.x / iResolution.y;\n    uv = uv * 2. - 1.;\n    uv.x *= AR;\n    \n    Scene scene;\n    \n    // Beeg initializator\n    // I sure hope there is a better way to do that part\n    scene.spheres[0].position = vec3(0, 0, -5);\n    scene.spheres[0].radius = 1.5;\n    scene.spheres[0].material.diffuse = vec4(1,0,0,1);\n    scene.spheres[0].material.specular = vec4(1,1,0,1);\n    scene.spheres[0].material.shininess = 1.;\n    \n    scene.spheres[1].position = vec3(2, -.5, -4);\n    scene.spheres[1].radius = 1.;\n    scene.spheres[1].material.diffuse = vec4(0,1,0,1);\n    scene.spheres[1].material.specular = vec4(0,1,1,1);\n    scene.spheres[1].material.shininess = 1.;\n    \n    scene.lights[0].position = vec3(\n        cos(iTime) * 5.,\n        3.,\n        sin(iTime) * 5. - 5.\n    );\n    scene.lights[0].color = vec4(10, 10, 10, 1);\n    \n    \n    fragColor = vec4(.2, .2, .2, 1);\n    // And we ray trace everything :D\n    rayTrace(scene, uv, fragColor);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"struct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Light {\n    vec3 position;\n    vec4 color;\n};\n\nstruct Material {\n    vec4 diffuse;\n    vec4 specular;\n    float shininess;\n};\n\n\nstruct Intersection {\n    vec3 position;\n    vec3 normal;\n    Material material;\n};\nstruct Sphere {\n    vec3 position;\n    float radius;\n    Material material;\n};\n\n\nbool intersectSphere(Ray r, Sphere s, inout Intersection i, inout float t) {\n    vec3 rdir = normalize(r.direction);\n    vec3 CO = r.origin - s.position;\n    \n    float a = 1.;\n    float b = 2. * dot(rdir, CO);\n    float c = dot(CO, CO) - s.radius * s.radius;\n    float d = b * b - 4. * a * c;\n    \n    if(d < 0.) return false;\n    \n    float t1 = (-b - sqrt(d))/(2.*a);\n    float t2 = (-b + sqrt(d))/(2.*a);\n    t = min(t1, t2);\n    \n    bool is_ray_in_sphere = length(CO) < s.radius;\n    \n    i.position = r.origin + rdir * t;\n    i.normal = normalize(i.position - s.position) * (is_ray_in_sphere ? -1. : 1.);\n    i.material = s.material;\n    \n    return true;\n}\n\n","name":"Common","description":"","type":"common"}]}