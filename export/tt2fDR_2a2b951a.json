{"ver":"0.1","info":{"id":"tt2fDR","date":"1598713421","viewed":199,"name":"Minimalism #06","username":"Flopine","description":"Sixth piece of a shader serie about minimalism, how to do small and quick artwork that are about composition and animation.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","grid","animation","motion","hexagons","minimalist"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n#define PI acos(-1.)\n#define TAU 6.2831853\n\n#define BPM (120./60.)\n#define dt(speed) fract(iTime*speed)\n#define bouncy(speed) (abs(sqrt(sin(dt(speed)*PI))))\n\n#define AAstep(thre, val) smoothstep(-.7,.7,(val-thre)/min(0.07,fwidth(val-thre)))\n#define hexa(puv,s) (max(abs(puv.x),dot(abs(puv), normalize(vec2(1.,sqrt(3.))))))-s\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define moda(puv,r) puv=vec2(cos(mod(atan(puv.x,puv.y),TAU/r)-(TAU/r)*0.5),sin(mod(atan(puv.x,puv.y),TAU/r)-(TAU/r)*0.5))*length(puv)\n\n#define xor(a,b) ((1.-b)*a+(1.-a)*b)\n\nfloat equitri (vec2 p, float r)\n{\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/sqrt(3.);\n    if (p.x+sqrt(3.)*p.y>0.) p=vec2(p.x-sqrt(3.)*p.y,-sqrt(3.)*p.x-p.y)/2.;\n    p.x -= clamp( p.x, -2.*r, 0. );\n    return -length(p)*sign(p.y);\n}\n\nfloat frame (vec2 uv)\n{\n    vec2 ratio = vec2(1.,sqrt(3.));\n    vec2 ga = mod(uv,ratio)-ratio*0.5;\n    vec2 gb = mod(uv-ratio*0.5,ratio)-ratio*0.5;\n    vec2 guv = (dot(ga,ga) < dot(gb,gb)) ? ga : gb;\n\n    float mask = AAstep(0.02,abs(equitri(guv,0.47)));\n    mask *= AAstep(0.015,abs(hexa(guv,0.46)));\n    guv *= rot(PI);\n    mask *= AAstep(0.015,abs(equitri(guv,0.23)));\n    moda(guv,3.);\n    mask *= AAstep(0.02,abs(guv.y));\n\n    return mask;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    uv *= mix(1.,length(uv),(2.*bouncy(BPM/4.)-1.)*0.35); \n    \n    vec3 col = vec3(frame(uv*4.));\n    col = xor(col,vec3(0.,0.,0.2));\n    \n    fragColor = vec4(pow(col,vec3(0.2)),1.0);\n}","name":"Image","description":"","type":"image"}]}