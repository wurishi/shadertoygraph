{"ver":"0.1","info":{"id":"4lS3Wc","date":"1432907368","viewed":656,"name":"Perlin Sphere","username":"jozxyqk","description":"simple ray marching test","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","perlinnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\nfloat noise3D(vec3 p)\n{\n    p.z = fract(p.z)*256.0;\n    float iz = floor(p.z);\n    float fz = fract(p.z);\n    vec2 a_off = vec2(23.0, 29.0)*(iz)/256.0;\n    vec2 b_off = vec2(23.0, 29.0)*(iz+1.0)/256.0;\n    float a = texture(iChannel0, p.xy + a_off, -999.0).r;\n    float b = texture(iChannel0, p.xy + b_off, -999.0).r;\n    return mix(a, b, fz) - 0.5;\n}\n\nfloat perlin(vec3 p)\n{\n    float v = 0.0;\n    for (float i = 0.0; i < 6.0; i += 1.0)\n        v += noise3D(p * pow(2.0, i)) * pow(0.35, i);\n    return v;\n}\n\nfloat density(vec3 p)\n{\n    float n = perlin(p * 0.04);\n    //n *= abs(n);\n    n = sqrt(n+1.0) * 0.2 * (1.0+sin(iTime));\n    //n = n * 0.1;\n    float l = length(p);\n    return n + l*l*0.7;\n}\n\nfloat thresh = 1.0;\n\nbool trace(vec3 start, vec3 ray, out vec3 hit, out vec3 norm)\n{\n    bool hashit = false;\n    const float steps = 64.0;\n    vec3 p = start;\n    vec3 s = ray/steps;\n    for (float i = 0.0; i < steps; i += 1.0)\n    {\n        p += s;\n        if (density(p) > thresh)\n        {\n            hashit = true;\n            break;\n        }\n    }\n    if (!hashit)\n        return false;\n    for (int i = 0; i < 10; ++i)\n    {\n        s *= 0.5;\n        if (density(p) > thresh)\n            p -= s;\n       \telse\n            p += s;\n    }\n    hit = p;\n    const float e = 0.005;\n    float hit_density = density(hit);\n    norm = -normalize(vec3(density(p+vec3(e,0,0)), density(p+vec3(0,e,0)), density(p+vec3(0,0,e))) - hit_density);\n    return true;\n}\n\nvec3 getCol(vec3 start, vec3 dir, out vec3 hit, out vec3 norm, out vec3 ref)\n{\n    trace(start, dir, hit, norm);\n    vec3 eye = -normalize(dir);\n    vec3 light = -normalize(hit);\n    ref = reflect(-eye, norm);\n    float dist = length(hit-start);\n    float fog = exp(-dist);\n    float diffuse = max(0.0, dot(norm, light));\n    float specular = pow(max(0.0, dot(ref, light)), 100.0);\n    vec3 p = hit * 0.1;\n    vec3 col = normalize(vec3(noise3D(p), noise3D(p+1.234), noise3D(p+3.543))*0.2+0.5);\n    //vec3 col = vec3(1.0);\n    return vec3(col * (diffuse*0.6+0.4)+specular*0.3);\n}\n\n//http://code.google.com/p/qshaderedit/source/browse/qshaderedit/shaders/sancho/minnaertward.glsl?spec=svn165&r=165\nfloat fresnel(vec3 i, vec3 n)\n{\n    float idotn = dot(-i, n);\n    if (idotn < 0.0)\n        return 0.0;\n    const float ior = 1.3;\n\tfloat kr = (ior-1.0)/(ior+1.0);\n\tkr *= kr;\n\treturn kr + (1.0-kr)*pow( 1.0 - idotn, 5.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float fog_density = 0.3;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.z*iResolution.x/iResolution.y;\n    vec3 start = vec3(0,-0.8,-0.5);\n    vec3 dir = 2.5 * normalize(vec3((uv*2.0-1.0) * vec2(aspect,1.0) * 6.0, 10.0));\n \t//dir = dir.xzy;\n    \n    vec3 hit, norm, ref;\n    vec3 first = getCol(start, dir, hit, norm, ref);\n    vec3 qwe1, qwe2;\n    bool shadow = trace(hit, -hit, qwe1, qwe2);\n    float fog = exp(-length(hit-start)*fog_density);\n    float f = clamp(fresnel(normalize(dir), norm)*2.0, 0.0, 1.0);\n    vec3 second = getCol(hit, ref*3.0, hit, norm, ref);\n    float fog2 = exp(-length(hit-start)*fog_density);\n    vec3 col = fog * mix(first * (shadow?0.8:1.0), fog2 * second, f);\n    \n    fragColor = vec4(col, 1.0);\n    //fragColor = vec4(vec3(), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}