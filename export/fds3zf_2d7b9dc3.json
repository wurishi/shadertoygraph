{"ver":"0.1","info":{"id":"fds3zf","date":"1616384994","viewed":303,"name":"Simple voronoi water surface","username":"zxuccv","description":"Simple water effect based on Voronoi.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","voronoi","water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nAuthor:Xuan Yang\nSimple water surface effect based on voronoi noise.\n\nVoronoi implementation was based on:\nhttps://iquilezles.org/articles/voronoilines\n\nuntile texture was implemented based on:\nhttps://iquilezles.org/articles/texturerepetition\n*/\n\n#define Scale 3.\n\n//return the random offset of the block center and it's index\nvec2 random(vec2 block_index){\n    vec2 p = vec2(block_index);\n    vec2 ret = fract(sin(vec2(dot(p,vec2(123.1,311.7)),dot(p,vec2(269.5,183.3))))*4358.5453);\n    \n    return ret;\n    //return vec2(0., 0.);\n}\n\n//Effect: voronoi\nvec3 voronoi( in vec2 point )\n{\n    //index of the bottom-left block\n    vec2 block_index = floor(point);\n    \n    float waveSpeed = iTime / 0.9;\n    //local position of the point\n    vec2 f = fract(point);\n    \n    //loop through surrunding 9 block, find the closest center to the point.\n    vec2 min_offset, min_vec;\n    float min_dist = 50.;\n    for( int j=-1; j<=1; j++ ){\n        for( int i=-1; i<=1; i++ )\n        {\n            vec2 offset = vec2(i, j);\n            //local position of the current block center\n            vec2 block_center = random(block_index + offset);\n            block_center = .5 + .5 * sin(waveSpeed + 7. * block_center);\n            block_center += offset;\n            vec2 vec = block_center - f;\n            float dist = dot(vec, vec);//distance\n\n            if( dist < min_dist )\n            {\n                min_dist = dist;\n                min_offset = offset;\n                min_vec = vec;\n            }\n        }\n    }\n    \n    //loop through the surrunding blocks of the closest block and \n    //calculate the distance between the point and the border between these two centers, \n    //return the minimal distance found.\n    min_dist = 50.;\n    for( int j=-2; j<=2; j++ ){\n        for( int i=-2; i<=2; i++ )\n        {\n            vec2 offset = min_offset + vec2(i, j);\n            //local position of the current block center\n            vec2 block_center = random(block_index + offset);\n            block_center = .5 + .5 * sin(waveSpeed + 7. * block_center);\n            block_center += offset;\n            vec2 vec = block_center - f;\n            \n            min_dist = min(min_dist, dot( 0.5*(min_vec + vec), normalize(vec - min_vec)));\n        }\n    }\n    return vec3(min_dist, min_vec);\n}\n\n//return the highlight mask and the vec2 towars the center of it's block\nvec3 getBorder(in vec2 point)\n{\n    //real distance between the point and the seperate line\n    vec3 d = voronoi(point);\n    float fac = length(d.yz);\n    \n    //reduce highlight at position closer to center\n    float v = (1. - smoothstep(0.,0.4,d.x)) * fac * fac;\n    \n    //round the tip of the border\n    vec2 blend = d.yz * smoothstep(0., 0.5, d.x);\n    return vec3(v, blend);\n}\n\n//untile texture\n\nfloat sum( vec3 v ) { return v.x+v.y+v.z; }\nvec3 untileTexture( in vec2 x, float v ){\n    float k = texture( iChannel1, 0.005*x ).x;\n    \n    float l = k*5.0;\n    float f = fract(l);\n        \n    //index of the block\n    float index_a = floor(l);\n    float index_b = index_a + 1.0;\n    \n    //offset,scale,rotation modification of the blocks\n    vec2 offset_a = sin(vec2(1.0,5.0)*index_a);\n    vec2 offset_b = sin(vec2(1.0,5.0)*index_b);\n    \n    float scale_a = sin(0.5*index_a);\n    float scale_b = sin(0.5*index_b);\n    \n    float rangle_a = 1.7*index_a;\n    float rangle_b = 1.7*index_b;\n    mat2 rotate_a = mat2(cos(rangle_a), -sin(rangle_a), sin(rangle_a),  cos(rangle_a));\n    mat2 rotate_b = mat2(cos(rangle_b), -sin(rangle_b), sin(rangle_b),  cos(rangle_b));\n    \n    //find partial dirivative for both x and y for correct mipmap\n    vec2 duvdx = dFdx( x );\n    vec2 duvdy = dFdy( x );\n\n    vec3 cola = textureGrad( iChannel0, x*scale_a*rotate_a + v*offset_a, duvdx, duvdy ).xyz;\n    vec3 colb = textureGrad( iChannel0, x*scale_b*rotate_b + v*offset_b, duvdx, duvdy ).xyz;\n    \n    return mix( cola, colb, smoothstep(0.2,0.8,f-0.1*sum(cola-colb)) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1) based on y\n    vec2 defaultUV = fragCoord/iResolution.yy;\n    vec2 uv = defaultUV * Scale;\n    defaultUV *= 3.;\n    \n    //hightlight pass\n    vec3 vor = getBorder(uv + iTime * vec2(-0.2, 0.));\n    //shadow pass\n    vec3 svor = getBorder(uv + .3 + iTime * vec2(-0.2, 0.));\n    \n    //the highlight\n    float v = vor.x;\n    vec3 col = vec3(v, v, v*0.6) * 1.;\n    \n    //blend texture coord towards block center based on v\n    vec2 blend = vor.yz;\n    blend *= v;\n    vec3 baseTexture = untileTexture(defaultUV + (blend * 0.8), .8);//textureLod( iChannel0, defaultUV + (blend * 0.7), 0.0 ).xyz;\n    col += baseTexture;\n    \n    //add shadow\n    col -= smoothstep(.1, .2, svor.x) * svor.x / 2.6;\n    \n    //add some blue\n    col.b += 0.15;\n    \n    //output\n    fragColor = vec4(col,0.0);\n}","name":"Image","description":"","type":"image"}]}