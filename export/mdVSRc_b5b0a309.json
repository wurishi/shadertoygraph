{"ver":"0.1","info":{"id":"mdVSRc","date":"1681502428","viewed":78,"name":"Hallway through hell","username":"TrashProgrammer","description":"deforming a box sdf","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","bloom"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 sampleTex(vec2 uv, vec2 delta) {\n    return texture(iChannel0, uv + delta).xyzw;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n        \n    \n    float dx = 1.0 / iResolution.x;\n    float dy = 1.0 / iResolution.y;\n    \n    vec4 a = sampleTex(uv, vec2(-dx, dy));\n    vec4 b = sampleTex(uv, vec2(0.0, dy));\n    vec4 c = sampleTex(uv, vec2(dx, dy));\n    \n        \n    vec4 d = sampleTex(uv, vec2(-dx, 0.0));\n    vec4 e = sampleTex(uv, vec2(0.0, 0.0));\n    vec4 f = sampleTex(uv, vec2(dx, 0.0));\n    \n        \n    vec4 g = sampleTex(uv, vec2(-dx, -dy));\n    vec4 h = sampleTex(uv, vec2(0.0, -dy));\n    vec4 i = sampleTex(uv, vec2(dx, -dy));\n    \n    float sum = a.w + b.w + c.w + d.w + f.w + h.w;\n    vec4 upsample = e * 4.0 * sum;\n    upsample += (b + d + f + h ) * 2.0;\n    upsample += (a + c + g + i);\n    upsample /= 16.0;\n    \n    fragColor = vec4(upsample.xyz, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float rand(vec2 co) {\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 hash2( vec2  p ) { p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) ); return fract(sin(p)*43758.5453); }\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 d = vec2(1.0, 0.0);\n    \n    f = (f* (6.*f - 15.) + 10.)*f*f*f;\n    \n    float q11 = rand(i);\n    float q21 = rand(i + d.xy);\n    float q12 = rand(i + d.yx);\n    float q22 = rand(i + d.xx);\n    \n    float x1 = mix(q11, q21, f.x);\n    float x2 = mix(q12, q22, f.x);\n    \n    return mix(x1, x2, f.y);\n}\n\nfloat fbm(vec2 p) {\n    return 0.5 * noise(p + vec2(12.3435, 7.6483)) \n         + 0.25 * noise(2.0 * p + vec2(4.3334, 15.8788))\n         + 0.125 * noise(4.0 * p + vec2(1.2934, 8.4558));\n}\n\n\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nvec2 rotate(vec2 p, vec2 rot) {\n    vec2 s = sin(rot);\n    vec2 c = cos(rot);\n    \n    mat2 rotX = mat2(c.x, s.x, -s.x, c.x);\n    mat2 rotY = mat2(c.y, s.y, -s.y, c.y);\n    \n    return rotY * rotX * p;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int MAX_STEPS = 2000;\nconst float MIN_HIT_DIST = 0.01;\nconst float MAX_TRACE_DIST = 1000.0;\nconst float A = 0.25;\n\nfloat voronoi(in vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    \n    float res = 8.0;\n    for(int j = -1; j <= 1; j++)\n    for(int i = -1; i <= 1; i++) {\n        vec2 b = vec2(i, j);\n        vec2 r = b - f + hash2(p + b);\n        float d = dot(r, r);\n        res = min(res, d);\n    }\n    return sqrt(res);\n}\n\nvec3 applyFog(vec3 color, float dist) {\n    vec3 fog = vec3(0.4, 0.2, 0.0);\n    float b = 0.25;\n    float t = 1.0 - exp(-dist * b);\n    return mix(color, fog, t);\n}\n\nvec3 getPath(float z) {\n     return vec3(2.2 * cos(z * 0.25), 0.5 + 1.4 * sin(z * 0.25), z);\n}\n\nfloat sdBox( vec3 p, vec3 b) {\n  vec3 path = getPath(p.z);\n  p.xy -= path.xy;\n  vec3 q = abs(p) - b;\n  float A = 0.25; \n  q.z = 0.0;\n  q.x -= A * abs(noise(3.0 * p.yz));\n  q.y -= A * abs(noise(3.0 * p.zx));\n  return length(max(q,0.0)) + min(max(q.x, q.y),0.0);\n}\n\nfloat sdBoxDetailed(vec3 p, vec3 b) {\n  vec3 path = getPath(p.z);\n  p.xy -= path.xy;\n  vec3 q = abs(p) - b;\n  q.z = 0.0;\n  q.x -= A * abs(noise(3.0 * p.yz) + 0.1 * fbm(30.0 * p.yz));\n  q.y -= A * abs(noise(3.0 * p.zx) + 0.1 * fbm(30.0 * p.zx));\n  float t = voronoi((p.xy + path.xy) * 2.0);\n  return length(max(q,0.0)) + min(max(q.x, q.y),0.0) - 0.3 * t;\n}\n\nfloat mapWorld(vec3 p) {\n    return sdBox(p, vec3(0.75));\n}\n\n\nfloat mapWorldDetailed(vec3 p) {\n    return sdBoxDetailed(p, vec3(0.75));\n}\n\nvec3 calcNormal(vec3 pos) {\n    vec2 d = vec2(0.001, 0.0);\n    vec3 normal;\n    normal.x = mapWorldDetailed(pos + d.xyy) - mapWorldDetailed(pos - d.xyy);\n    normal.y = mapWorldDetailed(pos + d.yxy) - mapWorldDetailed(pos - d.yxy);\n    normal.z = mapWorldDetailed(pos + d.yyx) - mapWorldDetailed(pos - d.yyx);\n    return normalize(normal);\n}\n\n\nvec2 rayMarch(vec3 rayOrigin, vec3 rayDirection, float tStart) {\n    float t = tStart;\n    bool hit = false;\n    float minDist = 1E4;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 position = rayOrigin + t * rayDirection;\n        float dist;\n        if(abs(minDist) < 0.05) {\n            dist = mapWorldDetailed(position);\n        } else {\n            dist = mapWorld(position);\n        }\n     \n        minDist = min(abs(dist), abs(minDist));\n        if(dist > MIN_HIT_DIST) {\n            hit = true;\n            break;\n        }\n   \n        t += 0.01;\n        \n       \n        if(t > MAX_TRACE_DIST) {\n            break;\n        }\n    }\n    return vec2(t, hit);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xx;\n    vec2 ndc = 2.0 * uv - 1.0;\n   \n    vec3 cameraPos = getPath(iTime * 2.0);\n    vec2 rot = getPath((iTime + 0.5) * 2.0).xy - cameraPos.xy;\n    vec3 rayDirection = normalize(vec3(rotate(ndc, rot), 1.0));\n    vec2 result = rayMarch(cameraPos, rayDirection, 0.0);\n    vec3 col = vec3(0.0);\n\n    vec3 finalPos = cameraPos + result.x * rayDirection;\n    float t = voronoi(finalPos.xy * 2.0);\n    float t1 = cubicPulse(t, 1.0, 0.1);\n    col = mix(vec3(0.8118, 0.2627, 0.1255), vec3(0.3047, 0.1523, 0.1563), exp(-t1));\n    vec3 n = calcNormal(finalPos);\n    vec3 v = normalize(finalPos - cameraPos);\n\n    float k = 2.0 - 2.0 * t1;\n    float drop = k / (k + result.x * result.x);\n    \n    col *= drop;\n    col += col * max(0.0, dot(n, v));\n   \n    float dz = finalPos.z - cameraPos.z;\n    col = applyFog(col, dz);\n    \n    fragColor = vec4(col, 4.0 * exp(-t1) * drop);\n}","name":"Buffer A","description":"","type":"buffer"}]}