{"ver":"0.1","info":{"id":"slycWK","date":"1662204798","viewed":128,"name":"DDD Perth 2022","username":"slashrawr","description":"A small scene to celebrate the theme for DDD Perth 2022 - Illuminate. It uses raymarching with diffuse and specular lighting.\n\nhttps://dddperth.com/","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","lighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 250\n#define MAX_DIST 90.\n#define SURF_DIST .00001\n#define POINT_LIGHTS 2  \n#define AA 1.\n#define MOUSE 0\n#define LIGHT_ROTATION_SPEED .9\n#define GLOBAL_ILLUM 0\n\nstruct Material {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n}; \n  \nMaterial material;\n\nstruct DirLight {\n    vec3 direction;\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};  \n\nstruct PointLight {    \n    vec3 position;\n    float constant;\n    float linear;\n    float quadratic;  \n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n}; \n\nDirLight dirLight;\nPointLight pointLights[POINT_LIGHTS];\n\nmat2 rotate(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat box(vec3 p, vec3 s) \n{\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sphere(vec3 p, float r) \n{\n    return length(p)-r;\n}\n\nfloat theD(vec3 point) \n{\n    float beam = box(point, vec3(.6, 1.9, .5));\n    float sphere = sphere(point-vec3(.2,0,0), 2.0);\n    float bellymask = box(point-vec3(1.2,0,0), vec3(1,1.9,0.5));\n    return min(beam,max(sphere, bellymask));\n}\n\nfloat theO(vec3 point)\n{\n    float mainO = sphere(point-vec3(0., 1., 0.), 6.0);\n    float hole = sphere(point-vec3(0., 1., 0.), 5.0);\n    float mask = box(point,vec3(7.0, 7.0, .5));\n    return max(max(mainO, -hole), mask);\n}\n\n\nfloat theFloor(vec3 point) \n{ \n    float split = 5.;\n    float x = floor(point.x/split);\n    float z = floor(point.z/split);\n    float bump = sin(x*iTime/2.)*sin(z*iTime/5.)+sin(x*z*iTime/4.);\n\n    return point.y+6.0-clamp(bump,.6,1.);\n}\n\nvec3 calcFloorColour(vec3 point)\n{\n    float split = 5.;\n    float x = floor(point.x/split);\n    float z = floor(point.z/split);\n    \n    float bump = sin(x*iTime/2.)*sin(z*iTime/5.)+sin(x*z*iTime/4.);\n    vec3 colour = vec3(clamp(bump,.0,1.));\n    //colour += (sin(point.z/split)/sin(point.x/split))/(atan(iTime/.2));\n    return colour;\n}\n\nfloat theBackground(vec3 point)\n{\n    float backWall = length(point.z-35.);\n    float leftWall = point.x+35.;\n    \n    float x = floor(point.x/5.);\n    float y = floor(point.y/5.);\n    \n    float bump = sin(x*iTime/2.)*sin(y*iTime/5.)-cos(x*y*iTime*.4);\n    //backWall -= clamp(bump,.1,1.);\n    \n    return min(backWall, leftWall);\n}\n\nvec3 calcBackgroundColour(vec3 point)\n{\n    float a = sin(point.y/2.)+sin((point.x/10.)-iTime);\n    float b = sin(point.y/.2)+sin((point.z/10.)-iTime);\n    \n    return vec3((a+b));\n}\n\nvec2 getDist(vec3 point) \n{\n    vec2 ret = vec2(0,-1);\n    \n    float plane = theFloor(point);\n   \n    float d1 = theD(point+vec3(-2,-1,0));\n    float d2 = theD(point+vec3(0,-1,.1));\n    float d3 = theD(point+vec3(2,-1,.2));\n    \n    float o = theO(point);\n    \n    float background = theBackground(point);\n    \n    //float d = min(plane, min(o, min(d1, min(d2, d3))));\n    float d = min(background, min(plane, min(o, min(d1, min(d2, d3)))));\n    \n    if (d == plane)\n        ret = vec2(d, 0);\n    else if (d == d1)\n        ret = vec2(d, 1);\n    else if (d == d2)\n        ret = vec2(d, 2);\n    else if (d == d3)\n        ret = vec2(d, 3);\n    else if (d == o)\n        ret = vec2(d, 4);\n    else if (d == background)\n        ret = vec2(d, 5);\n    else\n        ret = vec2(d, -1);\n    \n    return ret;\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    vec2 ret = vec2(0);\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        vec2 dS = getDist(p);\n        dO += dS.x;\n        ret = dS;\n        if(dO>MAX_DIST || dS.x<SURF_DIST) \n            break;\n    }\n    ret.x = dO;\n    return ret;\n}\n\nvec3 getNormal(vec3 point) {\n\tvec2 dist = getDist(point);\n    vec2 epsilon = vec2(.001, 0);\n    \n    return normalize(dist.x - vec3(\n        getDist(point-epsilon.xyy).x,\n        getDist(point-epsilon.yxy).x,\n        getDist(point-epsilon.yyx).x));\n}\n\n\n\nvec3 getColor(int id, vec3 point)\n{\n    vec3 col = vec3(0);\n    \n    switch (id)\n    {\n        //plane\n        case 0: col = calcFloorColour(point);\n                break;\n        //d1\n        case 3: col = vec3(.9);\n                break;\n        //d2\n        case 2: col = vec3(.9);\n                break;\n        //d3\n        case 1: col = vec3(.9);\n                break;\n        //circle\n        case 4: col = vec3(1);\n                break;\n        //background\n        case 5: col = calcBackgroundColour(point);\n                break;\n    }\n    \n    return col;\n}\n\n\nvec3 calcDirLight(DirLight light, vec3 normal, vec3 viewDir, vec3 colour)\n{\n    vec3 lightDir = normalize(-light.direction);\n    // diffuse shading\n    float diff = max(dot(normal, lightDir), 0.0);\n    // specular shading\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\n    // combine results\n    vec3 ambient  = light.ambient  * colour;\n    vec3 diffuse  = light.diffuse  * diff * colour;\n    vec3 specular = light.specular * spec * colour;\n    return (ambient + diffuse + specular);\n}  \n\nvec3 calcPointLight(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir, vec3 colour)\n{\n    vec3 lightDir = normalize(light.position - fragPos);\n    // diffuse shading\n    float diff = dot(normal, lightDir);\n    // specular shading\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\n    // attenuation\n    float dist    = length(light.position - fragPos);\n    float attenuation = 1.0 / (light.constant + light.linear * dist + light.quadratic * (dist * dist));    \n    // combine results\n    vec3 ambient  = light.ambient  * colour;\n    vec3 diffuse  = light.diffuse  * diff * colour;\n    vec3 specular = light.specular * spec * colour;\n    ambient  *= attenuation;\n    diffuse  *= attenuation;\n    specular *= attenuation;\n    return (ambient + diffuse + specular);\n} \n\nvec3 calcRayDirection(vec2 uv, vec3 point, vec3 lookAt, float z) {\n    vec3 f = normalize(lookAt-point),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = point+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-point);\n    return d;\n}\n\nvoid setupLights()\n{ \n    material.shininess = 64.;\n    vec3 lightStartingPos = vec3(0,1,0);\n    float linearFalloff = .01;\n    float quadraticFalloff = .0095;\n    float lightOrbit = 18.;\n\n    dirLight.direction = vec3(.5,.25,-.1);\n    dirLight.ambient = vec3(.2,.2,.2);\n    dirLight.diffuse = vec3(.2,.2,.2);\n    dirLight.specular = vec3(.1,.1,.1);\n    \n    //Blue light\n    PointLight light1;\n    light1.position = lightStartingPos;\n    light1.position.x += sin(iTime/LIGHT_ROTATION_SPEED) * lightOrbit;\n    light1.position.z += cos(iTime/LIGHT_ROTATION_SPEED) * lightOrbit;\n    light1.constant = .01;\n    light1.linear = linearFalloff;\n    light1.quadratic = quadraticFalloff;\n    light1.ambient = vec3(.1, .7, .95);\n    light1.diffuse = vec3(.1, .7, .95);\n    light1.specular = vec3(.1, .7, .95);\n    \n    //Pink light\n    PointLight light2;\n    light2.position = lightStartingPos;\n    light2.position.x -= sin(iTime/LIGHT_ROTATION_SPEED) * lightOrbit;\n    light2.position.z -= cos(iTime/LIGHT_ROTATION_SPEED) * lightOrbit;\n    light2.constant = .01;\n    light2.linear = linearFalloff;\n    light2.quadratic = quadraticFalloff;\n    light2.ambient = vec3(.94,.3,.8);\n    light2.diffuse = vec3(.94,.3,.8);\n    light2.specular = vec3(.94,.3,.8);\n    \n    pointLights[0] = light1;\n    pointLights[1] = light2; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    setupLights();\n    vec3 colour = vec3(0);\n    \n    for(float m = 0.;m<AA;m++)\n    {\n    \tfor(float n = 0.;n<AA;n++)\n        {\n    \t\tvec2 uv = (fragCoord+(vec2(m,n)/AA)-(iResolution.xy*.5))/iResolution.x;\n            \n            vec2 mouse = iMouse.xy/iResolution.xy;\n\n            vec3 rayOrigin = vec3(0, 4, -30);\n            vec3 lookAt = vec3(0,1,0);\n            \n            if (MOUSE == 1)\n            {\n                rayOrigin.yz *= rotate(-mouse.y*7.);\n                rayOrigin.xz *= rotate(-mouse.x*14.);\n            }\n            else\n                rayOrigin.xz *= rotate(.1*6.2831);\n\n            vec3 rayDirection = calcRayDirection(uv, rayOrigin, lookAt, 1.);\n\n            vec2 dist = rayMarch(rayOrigin, rayDirection);\n\n            if(dist.x<MAX_DIST) \n            {\n                vec3 point = rayOrigin + rayDirection * dist.x;\n                vec3 normal = getNormal(point);\n                colour = getColor(int(dist.y), point);\n                vec3 result = vec3(0);\n                if (GLOBAL_ILLUM == 1)\n                    result = calcDirLight(dirLight, normal, rayDirection, colour);\n                \n                for(int i = 0; i < POINT_LIGHTS; i++)\n                    result += calcPointLight(pointLights[i], normal, point, rayDirection, colour);\n\n                colour = result;    \n            }\n    \t}\n    }\n    colour/=AA*AA;\n    fragColor = vec4(colour, 1.0);\n}","name":"Image","description":"","type":"image"}]}