{"ver":"0.1","info":{"id":"ldyfRy","date":"1529291409","viewed":149,"name":"Octave Noise Bezier","username":"Jeran","description":"Imagine a square. Now imagine that square, but with more pieces on top. Now add more pieces on top. Suddenly its squares all the way down divided into different octaves, all different colors. This is the result of the average color. Now in Shader Form!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","octave","octavenoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Octave Noise Algorithm by Jeran64. It's pretty, but not immedeatly useful.\nconst uint k = 1664525U;     // Numerical Recipes\nconst int tweenFrames=100;\nconst int octaveCount=9; //\n\nvec3 noise(int seedyBits, uvec3 x )\n{\n    uint q=uint(seedyBits);\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>3U)^x.yzx)*(k+q);\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\nvec3 bezierInterp(vec3 A, vec3 B, vec3 C, float time)\n{\n    float red=pow(1.0-time,2.0)*A.x+(2.0*(1.0-time)*time*B.x)+pow(time,2.0)*C.x;\n    float green=pow(1.0-time,2.0)*A.y+(2.0*(1.0-time)*time*B.y)+pow(time,2.0)*C.y;\n    float blue=pow(1.0-time,2.0)*A.z+(2.0*(1.0-time)*time*B.z)+pow(time,2.0)*C.z;\n    return (B+vec3(red,green,blue)-vec3(.5,.5,.5));//offset by B to account for the shifting positions, and also subtract .5 to account for the extra.\n}\nvec3 getOctave(int count,vec2 uv)//number of octaves to calculate, normalized screen coordinates\n{\n    vec3 runningTotalA;\n    vec3 runningTotalB;\n    vec3 runningTotalC;\n    vec3 runningFract;\n\n    int frame = iFrame / tweenFrames;//glitchgarden - Today at 12:43 AM\n    float t = fract(float(iFrame) / float(tweenFrames));//current time value for the interpolation.\n\n    for(int b=0;b<count;b++)\n       {\n\t\t\tfloat octaveScale=pow(2.0,float(b));\n            vec2 yyyr =uv* octaveScale;//get the current pixel we are on, accounting for octave resolution\n        \tvec3 previous = noise(b,uvec3(yyyr, frame));//we need 4 pixels with to make cubic interp work.\n        \tvec3 current = noise(b,uvec3(yyyr, frame + 1));\n           \tvec3 target = noise(b,uvec3(yyyr, frame + 2));\n            runningTotalA+= previous;\n            runningTotalB+= current;\n            runningTotalC+= target;\n       }\n\n    vec3 avg1 = runningTotalA / float(count);\n    vec3 avg2 = runningTotalB / float(count);\n    vec3 avg3 = runningTotalC / float(count);    \n    \n    return bezierInterp(avg1,avg2,avg3,t);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(getOctave(octaveCount,fragCoord.xy/iResolution.xy), 1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}