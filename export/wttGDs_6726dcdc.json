{"ver":"0.1","info":{"id":"wttGDs","date":"1578021388","viewed":52,"name":"Cruzv03","username":"jorge2017a1","description":"Cruzv03","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["cruzv03"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat Sphere(vec3 p, vec3 o, float r){\n        return length(p-o)-r;  \n}\n \nfloat Plane(vec3 p){\n\treturn p.y;\t\n}\n\nvec3 DR(vec3 p,vec3 q){\n\treturn mod(p,q)-q/2.;\n}\n\n\n///----------------------------\n\n\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n\n///por Iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///---------------------------------------------\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n// Create infinite copies of an object -  https://iquilezles.org/articles/distfunctions\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\n\n\n///-------------------------------\n\nfloat h(vec3 p) {\n   \n    float planeDist = p.y;\n    vec2 res;\n    float dm1, dm2,dm3,dm4;\n    float d;\n    \n    d=1000.0; \n    p.x=p.x+2.0;\n  \n    \n    \n    //d=min(d,planeDist);\n    \n    \n    //repetir\n    if (p.y>60.0) \n    {\n    \tp.y=mod(p.y,20.0) -6.0;\n     }       \n    p.z=mod(p.z,12.0) -6.0;\n    p.x=mod(p.x,12.0) -5.0;\n    \n    \n    float bx1 = sdBox (p-vec3(0.,6.5,5.0),vec3(0.8,7.0,1.0));   //vetical\n    //float bx1a = sdBox (p-vec3(0.,0.0,5.4),vec3(0.5,6.0,1.8));   //vertical cch1\n    \n    float bx2 = sdBox (p-vec3(0.,10.0,4.6),vec3(4.3,0.5,1.0));  //horizontal\n    float bx2a = sdBox (p-vec3(0.,10.0,4.6),vec3(3.0,0.4,1.0));  //horizontal\n    \n    float bx3 = sdBox (p-vec3(0.,1.0,5.0),vec3(3.0,0.5,2.0));  //escalon2\n    float bx4 = sdBox (p-vec3(0.,0.5,5.0),vec3(4.0,0.5,3.0)); //escalon1\n    \n    float bx5 = sdBox (p-vec3(0.,0.0,5.0),vec3(4.5,0.5,4.0)); //escalon3 \n    \n    \n    float sp1 = sdSphere (p-vec3(0.0,1.0,-4.0), 0.8);\n    \n    \n  \n    float dif1, dif2, dif3;\n    \n    \n    \n  \n    dif1=unionSDF(bx1,bx2);\n    dif1=unionSDF(dif1,bx3);\n    dif1=unionSDF(dif1,bx4);\n    dif1=unionSDF(dif1,bx2a);\n    dif1=unionSDF(dif1,bx5);\n    \n    \n    d=min(d, dif1);\n    \n    \n    return d;\n}\n\nvec3 GetNormal(vec3 p) {\n\tvec2 e=vec2(.001,0);\n\treturn normalize(vec3(\n\t\th(p+e.xyy)-h(p-e.xyy),\n\t\th(p+e.yxy)-h(p-e.yxy),\n\t\th(p+e.yyx)-h(p-e.yyx)\n\t));\n}\n\nfloat AO(vec3 p,vec3 q){\t\t\t// AO at point p with normal q\n\tfloat o=0.,s=1.,r,d;\n    \tfor(float i=0.;i<5.;i++){\n\t\tr=.01+.12*i/4.;\n\t\tvec3 a=q*r+p;\n\t\td=h(a);\n\t\to+=-(d-r)*s;\n\t\ts*=.95;\n    \t}\n    \treturn clamp(1.-3.*o,0.,1.);   \n}\n\nfloat SH(vec3 p, vec3 q){\t\t\t// Calculate shadow amount: p=intersection point; q=light direction\n\tvec3 r = p + q*.01;\n\tfloat d;\n\tfor(int i=0; i<16; i++) {\n\t\td = h(r);\n\t\tif (d < .001)\n\t\t\tbreak;\n\t\tr += q * d;\t\t\t\t// March along!\n\t}\n\tif (d < 0.001)\n\t\treturn 0.1;\n\telse\n\t\treturn 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2. - iResolution.xy) / iResolution.y;\n\t\n\t//vec3 ro = vec3(1.4, 1.6, -4+iTime);\t\t\t// Cam pos (ray origin)\n    //////vec3 ro = vec3(10.4, 4.6, -24.0+iTime*2.0);\t\t\t// Cam pos (ray origin)\n    //vec3 ro = vec3(1.4, 4.6, -12.0);\t\n    \n    vec3 ro = vec3(0.4, 4.6, -10.0+iTime*2.0);\t\t\n    \n    \n\tvec3 up = vec3(0, 1, 0);\t\t\t// Cam orientation vecs\n\tvec3 fd = vec3(0, 0, 1);\n\tvec3 right = -cross(fd,up);\n\t\n\tfloat fov=1.8;\n\tvec3 rd = normalize(right*uv.x + up*uv.y + fd*fov);\t// Ray dir \n\t\n\tvec3 p = ro;\t\t\t\t\t// Current test position\n\tfloat d;\t\t\t\t\t// Distance of p from surface\n\tfor(int i=0; i<128; i++) {\n\t\td = h(p);\n\t\tif (d < .001)\n\t\t\tbreak;\n\t\tp += rd * d;\t\t\t\t// March along!\n\t}\n\t\n    \n    \n    \n    \n\tif (d < .001) {\t\t\t\t\t// We hit something!\n\t\t//vec3 lp = vec3(10,10,-10);\t\t// Light position\n        //vec3 lp = vec3(0.5,5.,-10);\t\t// Light position\n        vec3 lp = vec3(0.0,100.,iTime);\t\t// Light position\n        \n\t\tvec3 ld = normalize(lp-p);\t\t// Light direction\n\t\tvec3 n = GetNormal(p); \t\t\t// Normal\n\t\tfloat diffuse = dot(n,ld);\t\t// Diffuse amount\n\t\tvec3 c = vec3(.8,.9,1) * diffuse * AO(p,n) * SH(p,ld);\n\t\tfragColor = vec4(c, 1);\n\t\n        /*\n       \n        vec3 lp1 = vec3(10.0,5.,iTime-23.0);\t\t// Light position\n        \n\t\tvec3 ld1 = normalize(lp1-p);\t\t// Light direction\n\t\t//vec3 n1 = GetNormal(p); \t\t\t// Normal\n        vec3 n1 =n;\n\t\tfloat diffuse1 = dot(n1,ld1);\t\t// Diffuse amount\n       \n\t\t//vec3 c1 = vec3(.3,.5,.8) * diffuse1 * AO(p,n1) * SH(p,ld1);\n        vec3 c1 = vec3(.8,.9,1)  * diffuse1 * AO(p,n1) * SH(p,ld1);\n\t\t\n\t\tfragColor =( vec4(c, 1)+vec4(c1, 1))/1.5;\n       */\n        \n        \n\t} else\t\t\t\t\t\t\n\t\t//fragColor = vec4(uv.x / 2., uv.y * 1.4, 1, 1);\n    \tfragColor = vec4(uv.x/2.0 , uv.y/2.0, 1.0, 1);\n}\n","name":"Image","description":"","type":"image"}]}