{"ver":"0.1","info":{"id":"XlfyR4","date":"1503535602","viewed":163,"name":"creepy cylinders","username":"serge_rgb","description":"playing with shadertoy","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["procedural","cylinder","repeat"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sphere(vec3 p, vec3 c, float r) {\n   return length(p-c) - r;\n}\n\nfloat cylinder(vec3 p, vec3 c, float r, float h) {\n   vec3 d = p-c;\n   return max(length(d.xz - c.xz) - r, abs(d.y) - h);\n}\n\nfloat box(vec3 p, vec3 b) {\n   vec3 d = abs(p) - b;\n   return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat plane(vec3 p, vec3 c, vec3 n) {\n   return dot(p-c, n);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdf(vec3 p) {\n   return smin(cylinder(vec3(mod(p.x, 1.1)-0.5*1.1,\n                             p.y,\n                             mod(p.z, 1.1)-1.1/2.0), vec3(0), 0.17, .3),\n               plane(p, vec3(0,-0.2,0), vec3(0.0,1.0,0.0)), 0.4);\n}\n\n\n#define MAXSTEP 300\n#define EPSILON 0.001f\n\nfloat march(vec3 eye, vec3 dir) {\n   float depth = 0.0f;\n   for (int s = 0; s < MAXSTEP; ++s) {\n      float dist = sdf(eye + depth * dir);\n      if (dist < EPSILON) {\n         return depth;\n      }\n      depth += dist;\n   }\n   return 0.0;\n}\n\nvec3 normal(vec3 p) {\n   vec3 normal = vec3(sdf(p + vec3(EPSILON,0.0,0.0)) - sdf(p - vec3(EPSILON,0.0,0.0)),\n                      sdf(p + vec3(0.0,EPSILON,0.0)) - sdf(p - vec3(0.0,EPSILON,0.0)),\n                      sdf(p + vec3(0.0,0.0,EPSILON)) - sdf(p - vec3(0.0,0.0,EPSILON)));\n   return normalize(normal);\n}\n\nfloat phong(vec3 eye, vec3 p, vec3 n, vec3 l) {\n   vec3 ld = normalize(l-p);\n   vec3 cd = normalize(eye-p);\n\n   float ka = 0.3;\n   float kd = 3.0;\n   float ks = 1.0;\n   vec3 r = 2.0*dot(ld,n)*n - ld;\n   r = normalize(r);\n   float ds = dot(r, cd);\n   float res = ka + kd*dot(ld, n);\n   return res + ks*pow(clamp(dot(r, cd),0.0,1.0), 50.0);\n}\n\nmat3 view(vec3 eye, vec3 c, vec3 up) {\n   vec3 f = normalize(c - eye);\n   vec3 s = normalize(cross(f, up));\n   vec3 u = cross(s, f);\n   return mat3(s,u,f);\n}\n\nvoid mainImage(out vec4 fragcolor, in vec2 fragcoord) {\n   float w = iResolution.x;\n   float h = iResolution.y;\n   float x = fragcoord.x / w;\n   float y = fragcoord.y / h;\n\n   float ar = float(w)/h;\n   x *= ar;\n\n   x = -ar + x*2.0;\n   y = -1.0 + y*2.0;\n\n   vec3 eye = vec3(0,0,-3);\n   vec3 px = vec3(x, y, -0.2);\n   vec3 dir = normalize( px - eye );\n\n   float t = iTime * 0.3;\n\n   vec3 cam = vec3(0,0.3,0) + vec3(cos(t),0.1*sin(iTime), sin(t));\n   mat3 v = view(cam, vec3(0), vec3(0,1,0));\n   eye = v * eye;\n   dir = v * dir;\n\n   vec3 l = vec3(-1,2,-3);\n\n   fragcolor = y*vec4(0.03,0.08,0.08,1);\n   float d = march(eye, dir);\n   vec3 p = eye + dir*d;\n   vec3 n = normal(p);\n   if (d > 0.0f) {\n      fragcolor = 0.5*vec4(0.1+0.1*pow(cos(1.3*iTime), 3.0),0.1,0.2, 1);\n      fragcolor *=  phong(eye, p, normal(p), l);\n      fragcolor *= 5.0/d;\n      if (march(p + n*EPSILON, normalize(l-p)) > 0.0f) {\n         fragcolor *= 0.3;\n      }\n   }\n}","name":"Image","description":"","type":"image"}]}