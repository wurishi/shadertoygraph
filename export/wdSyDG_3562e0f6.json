{"ver":"0.1","info":{"id":"wdSyDG","date":"1588090892","viewed":142,"name":"Octahedralis II","username":"sl2c","description":"Version of https://www.shadertoy.com/view/WdSyDh with anti-aliasing and a different zoom-in.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["fractal","circles","hyperbolic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright 2020 Google LLC\n// SPDX-License-Identifier: Apache-2.0\n// NOT an official Google project; see Google Open Source guidelines for more info on copyright transfer\n// written by William Cadegan-Schlieper \nfloat s = 0.4142135623730951; // silver ratio\n\nvoid octant1(inout vec2 z, inout float ds, inout vec3[3] colors) {\n    if (z.x < 0.0) {\n        z.x = -z.x;\n        colors[2]=1.0-colors[2];\n    }\n    if (z.y < 0.0) {\n        z.y = -z.y;\n        colors[1]=1.0-colors[1];\n    }\n    float r2 = dot(z,z);\n    if (r2 > 1.0) {\n        z /= r2; ds /= r2;\n        colors[0]=1.0-colors[0];\n    }\n}\n\nvec3 color(vec2 z, float ds, bool fl) {\n    vec3[3] colors;\n    colors[0]=vec3(1.0,0.5,0.0);\n    colors[1]=vec3(0.0,1.0,0.5);\n    colors[2]=vec3(0.5,0.0,1.0);\n    \n    if (fl) {\n        colors[0]=1.0-colors[0];\n        colors[1]=1.0-colors[1];\n        colors[2]=1.0-colors[2];\n    }\n    \n    float r2;\n    int n = 60;\n    int i;\n    for(i=0;i<n;i++) {\n        octant1(z, ds, colors);\n        z -= vec2(s,s);\n        r2 = dot(z,z);\n        if (r2 < s * s) {\n            z *= s * s / r2; ds *= s * s / r2;\n            fl = !fl;\n            z += vec2(s,s);\n        } else {\n            z += vec2(s,s);\n        \tbreak;\n        }\n    }\n    octant1(z, ds, colors);\n    r2 = dot(z,z);\n    float v = (r2 - 2.0 * (z.x + z.y) * s + s * s) / (2.0 * ds * s * s);\n    v = min(v,1.0);\n    v = 0.75 + 0.25 * float(n-i) / float(n) * v;\n    if (fl) v = 1.5 - v;\n    float zz = 0.5 * (1.0 - r2);\n    if (zz > z.x && zz > z.y) {\n        return colors[0] * v * min(1.0, min((zz - z.x) / ds, (zz - z.y) / ds));\n    }\n    if (z.y > z.x) {\n        return colors[1] * v * min(1.0, min((z.y - zz) / ds, (z.y - z.x) / ds));\n    }\n    return colors[2] * v * min(1.0, min((z.x - zz) / ds, (z.x-z.y) / ds));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = 2.0 * (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    float ds = 4.0 / iResolution.y;\n    \n    float period = 4.2549485065150545;\n    float t = iTime * 0.5;\n    bool r = false;\n    \n    while (t > period * 0.5) {\n        t -= period;\n        float c = 0.766311365; float s = -0.64246936;\n        uv = vec2(uv.x * c - uv.y * s, uv.x * s + uv.y * c);\n        r = !r;\n    }\n    \n    uv *= exp(-t); ds *= exp(-t);\n    \n    uv += vec2(0.25262046414724887,-1.0187347727326157);\n\tuv /= dot(uv,uv); ds *= dot(uv,uv);\n    uv += vec2(0.22732631827540598,0.4228686518338363);\n\n    fragColor = vec4(color(uv,ds,r),1.0);\n    fragColor = pow(fragColor, vec4(1./2.2));\n}","name":"Image","description":"","type":"image"}]}