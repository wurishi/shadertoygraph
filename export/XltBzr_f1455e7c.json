{"ver":"0.1","info":{"id":"XltBzr","date":"1538479584","viewed":376,"name":"RGB, YCbCr, HSV quantization","username":"vchizhov","description":"Quantizes a color image. Quantizes either the RGB channels, the Y channel for YCbCr, or the SV channels for HSV. WS - control quantization. Space - change video/image. Return - change RGB/Y/SV quantization.","likes":1,"published":1,"flags":48,"usePreview":1,"tags":["quantization","ycbcr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(texture(iChannel0,uv).xyz,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float keyDown(int ascii) {\n\treturn float(texture(iChannel2,vec2((.5+float(ascii))/256.,0.25)).x > 0.0);\n}\n\nbool keyHit(int ascii) {\n\treturn texture(iChannel2,vec2((.5+float(ascii))/256.,1.5/3.)).x == 1.0;\n}\n\nconst int KEY_W = 87;\nconst int KEY_S = 83;\nconst int KEY_SPACE = 32;\nconst int KEY_RETURN = 13;\n\nvec3 RGBToYCbCr(in vec3 c)\n{\n    return vec3(0.0, 0.5, 0.5) +  transpose(mat3( 0.2990, 0.5870, 0.1140,\n                \t\t\t\t\t\t\t\t-0.1687, -0.3313, 0.5000,\n                \t\t\t\t\t\t\t\t0.5000,-0.4187,-0.0813)) * c;\n}\n\n\n\nvec3 YCbCrToRGB(in vec3 c)\n{\n    return transpose(mat3(1.0000, 0.0000, 1.4020,\n                1.0000, -0.3441, -0.7141,\n                1.0000, 1.7720, 0.0000)) * (c - vec3(0.0, 0.5, 0.5));\n}\n\n#define PI 3.14159265359\n\nvec3 RGBToHSV(in vec3 c)\n{\n    float M = max(c.r, max(c.g, c.b));\n    float m = min(c.r, min(c.g, c.b));\n    \n    float H;\n    float diff = M-m;\n    if(diff==0.0) {H = 0.0;}\n    else if(M==c.r) {H = 60.0*(c.g-c.b)/diff;}\n    else if(M==c.g) {H = 60.0*(2.0+(c.b-c.r)/diff);}\n    else //if(M==c.b) \n    {\n        H = 60.0*(4.0+(c.r-c.g)/diff);\n    }\n    H = H<0.0? H+360.0 : H;\n    float S = M==0.0? 0.0 : diff/M;\n    return vec3(H,S,M);\n}\n\nvec3 HSVToRGB(in vec3 c)\n{\n    float angle = c.x/60.0;\n    int k = int(floor(angle));\n    float f = angle - float(k);\n    float p = c.z*(1.0-c.y);\n    float q = c.z*(1.0-c.y*f);\n    float t = c.z*(1.0-c.y*(1.0-f));\n    \n    vec3 col;\n    if(k==0)\n    {\n        col = vec3(c.b, t, p);\n    }\n    else if(k==1)\n    {\n        col = vec3(q, c.b, p);\n    }\n    else if(k==2)\n    {\n        col = vec3(p, c.b, t);\n    }\n    else if(k==3)\n    {\n        col = vec3(p, q, c.b);\n    }\n    else if(k==4)\n    {\n       col = vec3(t, p, c.b);\n    }\n    else //if(k==5)\n    {\n        col = vec3(c.b, p, q);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool mode = bool((int(texelFetch(iChannel3, ivec2(0), 0).w>0.5) + int(keyHit(KEY_SPACE)))%2);\n    int colorMode = (int(texelFetch(iChannel3, ivec2(0), 0).x) + int(keyHit(KEY_RETURN)))%3;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 c;\n    float numCols = clamp(texture(iChannel3,uv).w + keyDown(KEY_W)-keyDown(KEY_S), 0.0, 254.0);\n    if(mode)\n    {\n    \tc = texture(iChannel0, uv).xyz;\n    }\n    else\n    {\n        c = texture(iChannel1,uv).xyz;\n    }\n    \n    if(colorMode==0)\n    {\n        c = round(255.0*c/(255.0-numCols))*(255.0-numCols)/255.0;\n    }\n    else if(colorMode==1)\n    {\n        c = RGBToYCbCr(c);\n        c.x = round(255.0*c.x/(255.0-numCols))*(255.0-numCols)/255.0;\n        c = YCbCrToRGB(c);\n    }\n    else //if(colorMode==2)\n    {\n        c = RGBToHSV(c);\n        c.yz = round(255.0*c.yz/(255.0-numCols))*(255.0-numCols)/255.0;\n        c = HSVToRGB(c);\n    }\n    \n    if(all(equal(floor(fragCoord.xy),vec2(0))))\n    {\n        fragColor = vec4(float(colorMode),0.0,0.0,float(mode));\n    }\n    else\n    {\n        fragColor = vec4(c,numCols);\n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"}]}