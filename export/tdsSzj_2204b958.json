{"ver":"0.1","info":{"id":"tdsSzj","date":"1552230429","viewed":62,"name":"Hometask_1_Popkov","username":"popkover","description":".","likes":1,"published":1,"flags":0,"usePreview":0,"tags":[],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPS 0.0001\n#define COUNTER 100\n#define DIST 0.005\n#define FOCAL_LENGTH 1.2\n#define MIN 0.01\n#define MAX 6.0\n\nfloat Globe (vec3 param, float r)\n{\n\tfloat coord = length(param) - r;\n    return coord;\n}\n\nfloat Surface (vec3 param)\n{\n\treturn param.y;\n}\n\nfloat Cylinder (vec3 param, vec2 h)\n{\n    vec2 d = abs(vec2(length(param.xz),param.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat Cone (vec3 param, vec3 c)\n{\n    vec2 q = vec2(length(param.xz), param.y);\n    vec2 v = vec2(c.z*c.y/c.x, -c.z);\n    vec2 w = v - q;\n    vec2 vv = vec2(dot(v,v), v.x*v.x);\n    vec2 qv = vec2(dot(v,w), v.x*w.x);\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt(dot(w,w) - max(d.x,d.y)) * sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\nfloat Prism (vec3 param, vec2 h)\n{\n    vec3 q = abs(param);\n    return max(q.z-h.y,max(q.x*0.866025+param.y*0.5,-param.y)-h.x*0.5);\n}\n\nmat3 Rotation (vec2 alpha)\n{\n\tvec2 c = cos(alpha);\n\tvec2 s = sin(alpha );\n    vec3 first  = vec3(c.y,  0.0, -s.y);\n    vec3 second = vec3(s.y * s.x,  c.x,  c.y * s.x);\n    vec3 third = vec3(s.y * c.x, -s.x,  c.y * c.x);\n    return mat3(first, second, third);\n}\n\nfloat MakeFigure (vec3 p)\n{\n    float globe = Globe(p - vec3(0.5, 0.22, -1.1), 0.1);\n    float globe1 = Globe(p - vec3(0.3, 0.3, 0.0), 0.2);\n    float surface = Surface(p - vec3(0.0, 0.1, 0.0));\n    float cylinder = Cylinder(p - vec3(-0.3, 0.3, -1.0), vec2(0.1,0.2));\n    float cone = Cone(p - vec3(-1.2, 0.6, 0.6), vec3(0.3, 0.5, 0.4));\n    float prism = Prism(p - vec3(1.2, 0.2, 1.1), vec2(0.4, 0.2));\n    return min(min(min(globe, surface), min(cone, prism)), min(globe1, cylinder));\n}\n\nvec3 Normal (vec3 coord)\n{\n\treturn normalize(vec3(\n\t\tMakeFigure(coord + vec3(EPS, 0, 0)) - MakeFigure(coord - vec3(EPS, 0, 0)),\n\t\tMakeFigure(coord + vec3(0, EPS, 0)) - MakeFigure(coord - vec3(0, EPS, 0)),\n\t\tMakeFigure(coord + vec3(0, 0, EPS)) - MakeFigure(coord - vec3(0, 0, EPS))));\n}\n\nvoid RayMarching (vec3 ro, vec3 rd, out int steps, out float t)\n{\n\tt = 0.0;\n    for (int j = 0; j < COUNTER; ++j) {\n        vec3 p = ro + rd * t;\n        float d = MakeFigure(p);\n        if (d < DIST) {\n         \tsteps = j;   \n            break;\n        }\n        t += d;\n    }\n}\n\nfloat Darkness (vec3 p0, vec3 p1, float k)\n{\n\tvec3 rd = normalize(p1 - p0);\n\tfloat t = 10.0 * DIST;\n\tfloat maxt = length(p1 - p0);\n\tfloat f = 1.0;\n\tfor (int i = 0; i < COUNTER; ++i)\n\t{\n\t\tfloat d = MakeFigure(p0 + rd * t);\n\t\tif (d < DIST)\n\t\t\treturn 0.0;\n\t\tf = min(f, k * d / t);\n\t\tt += d;\n\t\tif (t >= maxt)\n\t\t\tbreak;\n\t}\n\treturn f;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 eye = vec3(0, 0, -2.0);\n    vec3 up = vec3(0, 1.0, 0);\n    vec3 right = vec3(1.0, 0, 0);\n    vec2 uv = fragCoord.xy * 2.0 / iResolution.xy - 1.0;\n    uv.y = uv.y * iResolution.y/iResolution.x;\n    vec3 ro = eye;\n    vec3 rd = normalize(vec3(0, 0, 1) * FOCAL_LENGTH + right * uv.x + up * uv.y);\n    \n    vec4 color1 = vec4(1.0, 0.6, 0.7, 1.0);\n    vec3 pos1 = vec3(sin(iTime) * 2.0, 2.0, cos(iTime) * 2.0);\n    vec4 color2 = vec4(0.5, 1.0, 0.8, 1.0);\n    vec3 pos2 = vec3(cos(iTime) * 2.0, 2.0, sin(iTime) * 2.0);\n    vec4 color = vec4(0.0, 0.8, 1.0, 1.0);\n    \n\tmat3 rot = Rotation(vec2(0.2, 0.0));\n\trd = rot * rd;\n\tro = rot * ro;\n    float t = 0.0;\n    int i = 0;\n    RayMarching(ro, rd, i , t);   \n    vec3 p;\n    if (t > MIN && t < MAX) {\n    \tp = ro + rd * t;\n        vec3 direct1 = normalize(pos1 - p);\n        vec3 direct2 = normalize(pos2 - p); \n    \tfloat intense1 = 0.0;\n        float intense2 = 0.0;\n    \tfloat shadow1 = Darkness(p, pos1, 6.0);\n        float shadow2 = Darkness(p, pos2, 8.0);\n        \n        if (shadow1 > 0.0) {\n            intense1 = clamp(dot(Normal(p), direct1), 0.0, 1.0) * shadow1;\n        }\n        \n        if (shadow2 > 0.0) {\n            intense2 = clamp(dot(Normal(p), direct2), 0.0, 1.0) * shadow2;\n        }\n        color = smoothstep(vec4(0.0), vec4(2.0), color1 * intense1 + color2 * intense2);\n        if (MakeFigure(p) == Globe(p - vec3(0.5, 0.22, -1.1), 0.1) ||\n            MakeFigure(p) == Cone(p - vec3(-1.2, 0.6, 0.6), vec3(0.3, 0.5, 0.4)))\n        {\n            color += vec4(0.1, 0.6, 0.0, 0.0) * (intense1 + intense2) * 1.5;\n        } \n        else if (MakeFigure(p) == Cylinder(p - vec3(-0.3, 0.3, -1.0), vec2(0.1,0.2)) ||\n                 MakeFigure(p) == Prism(p - vec3(1.2, 0.2, 1.1), vec2(0.4, 0.2)))\n        {\n            color += vec4(0.1, 0.1, 0.4, 0.0) * (intense1 + intense2) * 1.5;\n        }\n\n    }\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}