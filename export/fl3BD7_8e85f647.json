{"ver":"0.1","info":{"id":"fl3BD7","date":"1663261671","viewed":136,"name":"Rotating textured sdf tori","username":"exucutional","description":"MIPT - Gamedev - Graphics - Homework - 2","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["sdf","hw","graphics","mipt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int   TRACE_MAX_STEPS  = 255;\nconst float TRACE_MAX_DIST   = 10.;\nconst float TRACE_EPSILON    = .001;\nconst float NORMAL_EPSILON   = .001;\nconst float pi               = 3.1415926;\nconst float FDiel            = .04;\nconst float gamma            = 2.2;\n\nmat3 rotateX(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nmat2 rotate2D(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(\n        vec2(c, -s),\n        vec2(s, c)\n    );\n}\n\nmat3 view(vec3 camera, vec3 target, vec3 up)\n{\n    vec3 cameraZ = normalize(camera-target);\n    vec3 cameraX = normalize(cross(up, cameraZ));\n    vec3 cameraY = normalize(cross(cameraZ, cameraX));\n    return mat3(cameraX, cameraY, cameraZ);\n}\n\nfloat length8(in vec2 p)\n{\n    return pow(pow(abs(p.x), 8.)+pow(abs(p.y), 8.), 1./8.);\n}\n\nvec3 getTriplanarWeights(in vec3 n)\n{\n    vec3 w = abs(n);\n    w *= w;\n    return w/(w.x+w.y+w.z);\n}\n\nvec4 triplanarMap(sampler2D t, in vec3 p, in vec3 n)\n{\n    vec3 w = getTriplanarWeights(n);\n    vec4 txy = texture(iChannel0, p.xy);\n    vec4 tyz = texture(iChannel0, p.yz);\n    vec4 tzx = texture(iChannel0, p.zx);\n    vec4 map = w.x*tyz+w.y*tzx+w.z*txy;\n    return map;\n}\n\nfloat unionSDF(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\nfloat torusSDF(in vec3 p, in vec2 t)\n{\n    vec2 q = vec2(length8(p.xz)-t.x, p.y);\n    return length8(q)-t.y;\n}\n\nfloat planeSDF(in vec3 p, in float h)\n{\n    return p.y+h;\n}\n\nfloat sceneSDF(in vec3 p, in mat3 m)\n{\n    vec3 q = p*m;\n    float scene = 1.;\n    mat3 rot = mat3(1);\n    for (float i = 0.; i < 11.; i++)\n    {\n        if (mod(i, 2.) == 0.)\n            rot *= rotateX(.1*iTime); \n        else \n            rot *= rotateZ(.1*iTime);\n        scene = unionSDF(scene, torusSDF(q*rot, vec2(1.-.1*i, .05)));\n    }\n    float plane = planeSDF(q, 2.);\n    scene = unionSDF(scene, plane);\n    return scene;\n}\n\nvec3 traceSDF(in vec3 from, in vec3 dir, out bool hit, in mat3 m)\n{\n    vec3 p = from;\n    float totalDist = 0.;\n    hit = false;\n    for (int steps = 0; steps < TRACE_MAX_STEPS; steps++)\n    {\n        float dist = sceneSDF(p, m);\n        if (dist < TRACE_EPSILON)\n        {\n            hit = true;\n            break;\n        }\n        totalDist += dist;\n        if (totalDist > TRACE_MAX_DIST)\n            break;\n        p += .8*dir*dist;\n    }\n    return p;\n}\n\nvec3 calcNormal(vec3 p, float d)\n{\n    float e = max(d*.5, NORMAL_EPSILON);\n    mat3 m = mat3(1);\n    return normalize(vec3(\n        sceneSDF(p+vec3(e, 0, 0), m)-sceneSDF(p-vec3(e, 0, 0), m),\n        sceneSDF(p+vec3(0, e, 0), m)-sceneSDF(p-vec3(0, e, 0), m),\n        sceneSDF(p+vec3(0, 0, e), m)-sceneSDF(p-vec3(0, 0, e), m)\n    ));\n}\n\nfloat ambientOcclusion(in vec3 pos, in vec3 normal, mat3 m)\n{\n    float occ = .0;\n    float sca = 1.;\n    for (int i = 0; i < 5; i++)\n    {\n        float h = .01+.12*float(i)/4.;\n        float d = sceneSDF(pos+h*normal, m);\n        occ += (h-d)*sca;\n        sca *= .95;\n        if (occ > .35) \n            break;\n    }\n    return clamp(1.-3.*occ, 0., 1.)*(.5+.5*normal.y);\n}\n\nbool isShadow(in vec3 from, in vec3 l, in vec3 n, mat3 m)\n{\n    vec3 p = from+n*TRACE_EPSILON;\n    vec3 dir = normalize(l-from);\n    float totalDist = 0.;\n    for (int steps = 0; steps < TRACE_MAX_STEPS; steps++)\n    {\n        float dist = sceneSDF(p, m);\n        if (dist < TRACE_EPSILON)\n            break;\n\n        totalDist += dist;\n        if (totalDist > TRACE_MAX_DIST)\n            break;\n        p += .8*dir*dist;\n    }\n    if (totalDist < length(l-from))\n        return true;\n    \n    return false;\n}\n\nvec3 fresnel(in vec3 f0, in float product)\n{\n    product = clamp(product, 0., 1.);\n    return mix(f0, vec3(1.), pow(1.-product, 5.));\n}\n\nfloat D_GGX(in vec3 n, in vec3 l, in vec3 v, in float roughness)\n{\n    float r2 = roughness*roughness;\n    float r4 = r2*r2;\n    vec3 h = normalize(l+v);\n    float nh = dot(n, h);\n    float nh2 = nh*nh;\n    float d = (r4-1.)*nh2+1.;\n    return r4/(pi*d*d);\n}\n\nfloat G_neumann(in vec3 n, in vec3 l, in vec3 v)\n{\n    float nl = dot(n, l);\n    float nv = dot(n, v);\n    return nl*nv/max(nl, nv);\n}\n\nvec3 cookTorrance(in vec3 n, in vec3 l, in vec3 v, in vec3 f0, in float roughness)\n{\n    float D = D_GGX(n, l, v, roughness);\n    float G = G_neumann(n, l, v);\n    return f0*D*G;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 camera = vec3(0, 0, 3);\n    vec3 target = vec3(0.);\n    vec3 up = vec3(0., 1., 0.);\n    vec2 mouseUV = iMouse.xy/iResolution.xy-0.5;\n    camera *= rotateX(clamp(pi*mouseUV.y, -pi/2.5, pi/6.))*rotateY(-2.*pi*mouseUV.x);\n    mat3 viewMatrix = view(camera, target, up);\n    mat3 m = mat3(1);\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 dir = viewMatrix*normalize(vec3(uv, -1));\n    bool hit;\n    vec3 p = traceSDF(camera, dir, hit, m);\n    vec4 color = texture(iChannel1, dir);\n    vec3 light = vec3(0, 6, 0);\n    if (hit)\n    {\n        vec3 l = normalize(light-p);\n        vec3 n = calcNormal(p, .001);\n        vec3 v = normalize(camera-p);\n        float nv = dot(n, v);\n        float nl = max(.0, dot(n, l));\n        \n        vec3 colorLight = texture(iChannel1, reflect(-v, n)).rgb;\n        \n        vec3 gold = vec3(1.022, 0.782, 0.344);\n        vec3 silver = vec3(0.972, 0.960, 0.915);\n        float arg = 2.*iTime+2.*pi*p.x+2.*pi*p.z;\n        float sstep = smoothstep(0.1, 0.2, sin(arg)*cos(arg));\n        vec3 base = mix(gold, silver, sstep);\n        float metallness = 1.;//mix(0.1, 0.7, (sin(5.*iTime)+1.)/2.);\n        float roughness = 0.25;//mix(0.1, 0.9, (cos(5.*iTime)+1.)/2.);\n        \n        if (p.y < -1.) \n        {\n            //colorLight = vec3(1);\n            base = texture(iChannel0, p.xz).rgb*vec3(1.5);\n            metallness = 0.;\n            roughness = 0.25;\n        }\n        \n        base = pow(base, vec3(gamma));\n        vec3 F0 = mix(vec3(FDiel), base, metallness);\n        vec3 specFresnel = fresnel(F0, nv);\n        vec3 spec = cookTorrance(n, l, v, specFresnel, roughness)*nl/max(.001, 4.*nl*nv);\n        vec3 diff = (vec3(1.)-specFresnel)*nl/pi;\n        color = vec4((diff*mix(base, vec3(0.), metallness)+spec)*colorLight, 1.);\n        color = pow(color, vec4(1./gamma));\n        color += 0.25*vec4(base, 1.)*ambientOcclusion(p, n, m);\n        if (isShadow(p, light, n, m))\n        {\n            color *= vec4(0.2);\n        }\n\n    }\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}