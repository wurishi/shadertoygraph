{"ver":"0.1","info":{"id":"Xt23Dz","date":"1428244960","viewed":2852,"name":"20150405_sakura revisited","username":"FMS_Cat","description":"repetition rulez","likes":59,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define PI 3.1415926\n#define V vec2(0.,1.)\n\n#define t iTime\n#define r iResolution.xy\n#define c fragCoord\n#define cl(i) clamp(i,0.,1.)\n\n#define MAT_NULL -1.\n#define MAT_ANTHER 0.\n#define MAT_FILAMENT 1.\n#define MAT_PISTIL 2.\n#define MAT_PETAL 3.\n#define MAT_CALYX 4.\n#define MAT_TREE 5.\n\nfloat hash(vec2 _v)\n{\n    return fract(sin(dot(_v,vec2(89.44,19.36)))*22189.22);\n}\n\nfloat iHash(vec2 _v,vec2 _r)\n{\n    float h00 = hash(vec2(floor(_v*_r+V.xx)/_r));\n    float h10 = hash(vec2(floor(_v*_r+V.yx)/_r));\n    float h01 = hash(vec2(floor(_v*_r+V.xy)/_r));\n    float h11 = hash(vec2(floor(_v*_r+V.yy)/_r));\n    vec2 ip = vec2(smoothstep(V.xx,V.yy,mod(_v*_r,1.)));\n    return (h00*(1.-ip.x)+h10*ip.x)*(1.-ip.y)+(h01*(1.-ip.x)+h11*ip.x)*ip.y;\n}\n\nfloat noise(vec2 _v)\n{\n    float sum = 0.;\n    for(int i=1; i<9; i++)\n    {\n        sum += iHash(_v+vec2(i),vec2(2.*pow(2.,float(i))))/pow(2.,float(i));\n    }\n    return sum;\n}\n\nmat2 rotate( float _th )\n{\n    return mat2( cos(_th), -sin(_th), sin(_th), cos(_th) );\n}\n\nfloat pole( vec3 _p, float _r, float _l )\n{\n    vec2 d = abs( vec2( length( _p.xz ), _p.y ) ) - vec2( _r, _l );\n    return min( max( d.x, d.y ), 0. ) + length( max( d, 0. ) );\n}\n\nfloat pole( vec3 _p, float _r )\n{\n    return length( _p.xz ) - _r;\n}\n\nfloat smin( float _a, float _b, float _k )\n{\n    float h = cl( 0.5+0.5*( _b-_a )/_k );\n    return mix( _b, _a, h ) - _k*h*( 1.-h );\n}\n\nvec2 stamen( vec3 _p )\n{\n    vec2 dist = vec2( 1E2 );\n    vec2 distC = dist;\n    float phase = floor( atan( _p.z, _p.x )/PI/2.*13.-1. );\n    vec3 offset = vec3( .04, -.0, .04 ) * ( 1. + sin( t )*.1 );\n    offset.xz *= .6 + hash( vec2( phase*1.9873, 821.122 ) )*.6;\n    vec3 p = _p - V.xyx*.01;\n    p.xz = rotate( floor( phase )*PI*2./13. ) * p.xz;\n    vec3 pa = p + ( sin(p.x*200.)*sin(p.y*200.)*sin(p.z*200.) ) * .003 - offset - V.xyx*.1;\n    distC = vec2( length( pa ) - .005, MAT_ANTHER );\n    if( distC.x < dist.x ){ dist = distC; }\n    pa = p + vec3( sin(p.y*20.), 0., cos(p.y*20.) )*.003 - offset * ( .5+.5*sin( p.y/.1*PI/2. ) );\n    distC = vec2( pole( pa-V.xyx*.025,  sin( pa.y/.1*PI )*.001, .075 ), MAT_FILAMENT );\n    if( distC.x < dist.x ){ dist = distC; }\n    return dist;\n}\n\nvec2 pistil( vec3 _p )\n{\n    vec3 p = _p;\n    float pistil = pole( p - V.xyx*.01 + vec3( cos(p.y*50.), 0., sin(p.y*50.) )*.001, .004, .06 );\n    pistil = smin( pistil, length( vec2( length( p.xz )-.007, p.y-.07 ) )-.001, .01 );\n    return vec2( pistil, MAT_PISTIL );\n}\n\nvec2 petals( vec3 _p )\n{\n    float dist = 1E2;\n    vec3 p = _p;\n    p.y -= pow( length( p.xz ), .5)*.2-.055;\n    p.xz = rotate( floor( atan( p.z, p.x )/PI/2.*5.-2. )*PI*2./5. ) * p.xz;\n    p.xy = rotate( -.3 + sin( t )*.1 ) * p.xy;\n    p.x += .14;\n    p.x *= ( 1. - pow( abs( sin( atan( p.z, p.x ) ) ), .1 )*.3 )*1.4;\n    p += ( sin(_p.x*20.)*sin(_p.y*20.)*sin(_p.z*20.) ) * .018;\n    dist = min( dist, pole( p, .1, .001 ) );\n    return vec2( dist, MAT_PETAL + cl( length( _p.xz ) ) );\n}\n\nvec2 calyx( vec3 _p )\n{\n    float dist = 1E2;\n    \n    vec3 p = _p;\n    p.y -= pow( length( p.xz ), .2)*.2-.13;\n    p.xz = rotate( floor( atan( p.z, p.x )/PI/2.*5.-2. )*PI*2./5. ) * p.xz;\n    p.xy = rotate( -.3 ) * p.xy;\n\n    vec3 ptemp = p;\n    p.x += .04;\n    p.x *= max( pow( abs( sin( atan( p.z, p.x ) ) ), .1 ), .6 );\n    p += ( sin(_p.x*20.)*sin(_p.y*20.)*sin(_p.z*20.) ) * .018;\n    dist = smin( dist, pole( p, .03, .001 ), .02 );\n\n    p = ptemp + V.xyx*.15;\n    p.x -= .02;\n    p.x *= max( pow( abs( sin( atan( p.z, p.x ) ) ), .1 ), .6 );\n    p += ( sin(_p.x*20.)*sin(_p.y*20.)*sin(_p.z*20.) ) * .018;\n    dist = smin( dist, pole( p, .01, .001 ), .02 );\n    \n    dist = smin( dist, pole( _p + vec3( cos(_p.y*20.), 0., sin(_p.y*20.) )*.004 + V.xyx*.15, .01, .09 ), .02 );\n    \n    return vec2( dist, MAT_CALYX + cl( -_p.y-.05 ) );\n}\n\nvec2 blossom( vec3 _p, float _h )\n{\n    vec2 dist = vec2( 1E2 );\n    if( length( _p ) < .28 )\n    {\n        dist = stamen( _p );\n        vec2 distC = pistil( _p );\n        if( distC.x < dist.x ){ dist = distC; }\n        distC = petals( _p );\n        if( distC.x < dist.x ){ dist = distC; }\n        distC = calyx( _p );\n        if( distC.x < dist.x ){ dist = distC; }\n    }\n    else\n    {\n        dist = vec2( length( _p )-.27, MAT_NULL );\n    }\n\treturn dist;\n}\n\nvec2 branch( vec3 _p )\n{\n    vec2 dist = vec2( 1E2 );\n    vec3 p = _p;\n    p.xy = rotate( -1. )*p.xy;\n    vec3 pt = p + sin( p.x*10. )*sin( p.y*10. )*sin( p.z*10. ) * .03;\n    dist = vec2( pole( pt, .1 ), MAT_TREE );\n    p.zx = rotate( floor( p.y*2.+.5 )*.7 - .5 )*p.zx;\n    float th = atan( p.z, p.x );\n    if( th < 0. ){ p.zx = rotate( PI )*p.zx; }\n    p.yz = rotate( PI/2. )*p.yz;\n    p.y -= .3;\n    p.z = mod( p.z+.25, .5 )-.25;\n    vec2 distC = blossom( p, 12.4 );\n    if( distC.x < dist.x ){ dist = distC; }\n    return dist;\n}\n\nvec2 scene( vec3 _p )\n{\n    vec2 dist = branch( _p );\n    return dist;\n}\n\nvec3 sceneNormal( vec3 _p )\n{\n    vec2 d = V*1E-4;\n    return normalize( vec3(\n        scene( _p + d.yxx ).x - scene( _p - d.yxx ).x,\n        scene( _p + d.xyx ).x - scene( _p - d.xyx ).x,\n        scene( _p + d.xxy ).x - scene( _p - d.xxy ).x\n    ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (c*2.-r)/r.x;\n    \n    vec3 camPos = vec3( .8, 0., 1. );\n    vec3 camTar = vec3( sin(t*.72), sin(t*.83), sin(t*.37) )*.01 - vec3( sin( t*.21 )*.2, -.2, .0 );\n    vec3 camDir = normalize( camTar - camPos );\n    vec3 camAir = V.xyx;\n    vec3 camSid = normalize( cross( camDir, camAir ) );\n    vec3 camTop = normalize( cross( camSid, camDir ) );\n    \n    vec3 rayDir = normalize( camSid * p.x + camTop * p.y + camDir );\n    vec3 rayPos = camPos;\n    float rayLen = 0.;\n    vec2 dist = V.xx;\n    for( int i=0; i<64; i++ )\n    {\n        dist = scene( rayPos )*vec2( .6, 1. );\n        rayLen += dist.x;\n        rayPos = camPos + rayDir * rayLen;\n        if( dist.x < 2E-3 || 1E2 < rayLen ){ break; }\n    }\n    \n    vec3 col = V.xxx;\n    if( dist.x < 4E-3 )\n    { \n        vec3 ligPos = vec3( 0., 1., 11. );\n        vec3 nor = normalize( sceneNormal( rayPos ) );\n        float dif = cl( dot( normalize( rayPos-ligPos ), -nor ) )*.3;\n        float amb = .7;\n        float speDot = cl( dot( normalize( normalize( rayPos-ligPos ) + normalize( rayPos-camPos ) ), -nor ) );\n        float spe = cl( pow( speDot, 10. ) )*.1;\n        vec3 matCol = V.xxx;\n        if( floor( dist.y ) == MAT_NULL ){ amb = 1.; matCol = vec3( 1. ); }\n        else if( floor( dist.y ) == MAT_ANTHER ){ matCol = vec3( .9, .9, .5 ); }\n        else if( floor( dist.y ) == MAT_FILAMENT ){ matCol = vec3( .9, .9, .8 ); }\n        else if( floor( dist.y ) == MAT_PISTIL ){ matCol = vec3( .8, .9, .6 ); }\n        else if( floor( dist.y ) == MAT_PETAL ){ matCol = vec3( .9, .4, .8 ) + vec3( .1, .6, .2 ) * ( 1.-exp( -fract( dist.y )*16. ) ); }\n        else if( floor( dist.y ) == MAT_CALYX ){ matCol = vec3( .7, .1, .3 ) + vec3( -.4, .4, -.4 ) * cl( fract( dist.y )*8. ); }\n        else if( floor( dist.y ) == MAT_TREE ){\n            nor += vec3(\n                noise(vec2((rayPos.x+rayPos.z)*8.,rayPos.y*8.+27.1982))-.5,\n                noise(vec2((rayPos.x+rayPos.z)*8.,rayPos.y*8.+28.1982))-.5,\n                noise(vec2((rayPos.x+rayPos.z)*8.,rayPos.y*8.+29.1982))-.5\n            )*2.;\n            nor = normalize( nor );\n            dif = cl( dot( normalize( rayPos-ligPos ), -nor ) )*.6;\n            float speDot = cl( dot( normalize( normalize( rayPos-ligPos ) + normalize( rayPos-camPos ) ), -nor ) );\n            float spe = cl( pow( speDot, 10. ) )*.1;\n            matCol = vec3( .4, .3, .1 );\n        }\n       \tcol = ( dif + amb ) * matCol + spe;\n    }\n    else\n    {\n        col = vec3( .5, .7, .9 );\n        for( float i=12.; i<39.; i+=1. )\n        {\n            vec2 pos = ( vec2( hash(vec2(i,198.33)), hash(vec2(i,298.33)) ) - .5 )*r/r.x*2.;\n            pos += vec2( sin( t*.2*hash(vec2(i,19.233)) ), sin( t*.2*hash(vec2(i,29.233)) ) )*.01;\n            col += cl( 12.-length(p-pos)*50. ) * vec3( 1., .7, .9 )*.02;\n        }\n    }\n    \n    col -= length( p )*.4;\n    \n    fragColor = vec4( col, 1. );\n    \n    \n}","name":"","description":"","type":"image"}]}