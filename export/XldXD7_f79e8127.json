{"ver":"0.1","info":{"id":"XldXD7","date":"1480046046","viewed":757,"name":"cloudy voxel world","username":"SudoNhim","description":"A minecraft like world with rounded edges and fog. I have a lot more to do to this one :)","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["voxels","minecraft"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n\n#define VOXEL_NONE  0\n#define VOXEL_WATER 1\n#define VOXEL_SAND  2\n#define VOXEL_EARTH 3\n#define VOXEL_STONE 4\n#define VOXEL_GRASS 5\n\n// from https://www.shadertoy.com/view/4sfGzS\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n    vec2 uv = p.xy + f.xy;\n\tvec2 rg = vec2(texture( iChannel0, (uv+vec2(37.0,17.0)*p.z+0.5)/256.0, -100.0 ).x,\n                   texture( iChannel0, (uv+vec2(37.0,17.0)*(p.z+1.0)+0.5)/256.0, -100.0 ).x );\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nint getVoxelAndFogAt(ivec3 ip, out float fogStrength)\n{ \n    float cloudiness = noise(vec3(ip)/8.0);\n    fogStrength = smoothstep(0.6, 0.7, cloudiness)*0.3 + 0.1;\n    \n    if (ip.y <= 0) return VOXEL_WATER;\n    \n    // so this is like, grabbing the texture as a heightmap and\n    // then like twisting it in random directions as it goes up\n    // umm...\n    vec3 p = vec3(vec3(ip) + 0.5);\n    float theta = noise(p / 16.0) * PI * 2.0;\n    vec2 disp = vec2(cos(theta), sin(theta)) * p.y;\n    vec3 terr = texture(iChannel1, (p.xz + disp) / 128.0).rgb;\n\n    bvec3 contains = lessThanEqual(vec3(0.0), (terr - p.y/16.0));\n    if (contains.x && contains.y && !contains.z) return VOXEL_SAND;\n    if (contains.x && contains.z) return VOXEL_GRASS;\n    if (contains.y && contains.z && !contains.x) return VOXEL_STONE;\n    if (contains.x || contains.y || contains.z) return VOXEL_EARTH;\n\n    return VOXEL_NONE;\n}\n\nfloat dfVoxel(vec3 p, int voxelType)\n{\n    float r = 0.1;\n    if (voxelType == VOXEL_WATER) r = 0.0;\n    return length(max(abs(p)-vec3(0.5-r),0.0))-r;\n}\n\nvec3 nrmVoxel(vec3 p, int voxelType) \n{\n    vec2 dd = vec2(0.001,0.0);\n    float base = dfVoxel(p, voxelType);\n    return normalize(vec3(\n        dfVoxel(p+dd.xyy, voxelType) - base,\n        dfVoxel(p+dd.yxy, voxelType) - base,\n        dfVoxel(p+dd.yyx, voxelType) - base\n    ));\n}\n\nvoid voxelMarch(vec3 ro, vec3 rd, out ivec3 hitVoxels[4], out float fogAccums[5], out int hitCount) \n{\n    hitCount = 0;\n\n    ivec3 mapPos = ivec3(floor(ro));\n    vec3 deltaDist = abs(vec3(length(rd)) / rd);\n    ivec3 rayStep = ivec3(sign(rd));\n    vec3 sideDist = (sign(rd) * (vec3(mapPos) - ro) + (sign(rd) * 0.5) + 0.5) * deltaDist; \n    bvec3 mask;\n    float fogAccum = 0.0;\n    float prevDist = 0.0;\n\t\n    for (int i = 0; i < 96; i++) {\n\n        // check current position for voxel\n        float fogStrength;\n        if (getVoxelAndFogAt(mapPos, fogStrength) != VOXEL_NONE) {\n            // no non-const indexing? :<\n            if (hitCount == 0)      { hitVoxels[0] = mapPos; fogAccums[0] = fogAccum; }\n            else if (hitCount == 1) { hitVoxels[1] = mapPos; fogAccums[1] = fogAccum; }\n            else if (hitCount == 2) { hitVoxels[2] = mapPos; fogAccums[2] = fogAccum; }\n            else if (hitCount == 3) { hitVoxels[3] = mapPos; fogAccums[3] = fogAccum; }\n            hitCount++;\n            if (hitCount == 4) return;\n        }\n\n        // march forward to next position by discrete digital analyzer\n        float newDist = min( sideDist.x, min(sideDist.y, sideDist.z ));\n        vec3 mi = step( sideDist.xyz, sideDist.yzx ); \n        vec3 mm = mi*(1.0-mi.zxy);\n        sideDist += mm * vec3(rayStep) / rd;\n        mapPos += ivec3(mm)*rayStep;\n        \n        fogAccum += fogStrength * (newDist - prevDist);\n        prevDist = newDist;\n    }\n    \n    // did not intersect.\n    fogAccums[4] = fogAccum;\n}\n\nvoid resolveHitVoxels(\n    vec3 ro, vec3 rd, ivec3 hitVoxels[4], float fogAccums[5], int hitCount, \n    out ivec3 hitVoxel, out vec3 hit, out int terrainType, out float fogAccum) \n{ \n  for (int i=0; i<4; i++) {\n    if (i == hitCount) { \n      terrainType = VOXEL_NONE;\n      fogAccum = fogAccums[4];\n      return; // less than four hits, none intersected\n    }\n    \n    hitVoxel = hitVoxels[i]; float tmp;\n    terrainType = getVoxelAndFogAt(hitVoxel, tmp);\n    fogAccum = fogAccums[i];\n    vec3 hitVoxelCenter = vec3(hitVoxel) + 0.5;\n    \n    // intersect with voxel cube\n    vec3 cubeIntersect = (hitVoxelCenter - ro - 0.5*sign(rd))/rd;\n    float d = max(cubeIntersect.x, max(cubeIntersect.y, cubeIntersect.z));\n\n    // fallback in case of four no distance intersection\n    hit = ro + rd * (d - 0.01) - hitVoxelCenter;\n      \n    // attempt better intersect with distance marching\n    float diff;\n    vec3 p = ro + rd * d;\n    for (int j=0; j<4; j++) {\n      diff = dfVoxel(p - hitVoxelCenter, terrainType);\n      d += diff;\n      p = ro + rd * d;\n    }\n    if (diff < 0.05) { // good enough distance marched intersection\n      hit = p - hitVoxelCenter;\n      return;\n    }\n  }\n  // four hits, none intersected. Use the intersection with the cube to pretend we hit the last one.\n}\n\nvec3 doColoring(vec3 hit, int terrainType, vec3 hitGlobal, vec3 ldir)\n{\n    vec3 n = nrmVoxel(hit, terrainType);\n    float diffuse = max(dot(-ldir, n), 0.1);\n    \n    float f1 = noise(hitGlobal*19.0);\n    float f2 = noise(hitGlobal*33.0);\n    float f3 = noise(hitGlobal*71.0);\n    \n    // render\n    vec3 color = vec3(0.0);\n    if (terrainType == VOXEL_WATER) {\n        color = vec3(0.4, 0.4, 0.8) * (0.8 + f1*0.1 + f2*0.05 + f3*0.05);\n    } else if (terrainType == VOXEL_EARTH) {\n        color = vec3(1.0, 0.7, 0.3) * (f1*0.33 + f2*0.33 + f3*0.33);\n    } else if (terrainType == VOXEL_SAND) {\n        color = vec3(1.0, 1.0, 0.6) * (f1*0.1 + f2*0.1 + f3*0.5 + 0.3);\n    } else if (terrainType == VOXEL_STONE) {\n        color = vec3(0.5) * (f1*0.3 + f2*0.1 + 0.6);\n    } else if (terrainType == VOXEL_GRASS) {\n        color = vec3(0.3, 0.7, 0.4) * (f1*0.2 + f3*0.5 + 0.3);\n    }\n    \n    color *= diffuse;\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera stolen from Shane :) https://www.shadertoy.com/view/ll2SRy\n\tvec2 uv = (fragCoord - iResolution.xy*.5 )/iResolution.y;\n    vec3 rd = normalize(vec3(uv, (1.-dot(uv, uv)*.5)*.5));\n    vec3 ro = vec3(0., 10., iTime*10.0);\n    float t = sin(iTime * 0.2) + noise(ro/32.0);\n    ro.y += 4.0*t;\n\tfloat cs = cos( t ), si = sin( t );\n    rd.yz = mat2(cs, si,-si, cs)*rd.yz;\n    rd.xz = mat2(cs, si,-si, cs)*rd.xz;\n    \n    // voxel march into the scene storing up to four intersections\n    int hitCount;\n    ivec3 hitVoxels[4];\n    float fogAccums[5];\n    voxelMarch(ro, rd, hitVoxels, fogAccums, hitCount);\n\n    // resolve to one accurate intersection by distance marching\n    int terrainType = VOXEL_NONE;\n    ivec3 hitVoxel;\n    vec3 hit;\n    float fogAccum;\n    resolveHitVoxels(ro, rd, hitVoxels, fogAccums, hitCount, hitVoxel, hit, terrainType, fogAccum);\n\n    vec3 hitGlobal = vec3(hitVoxel) + hit;\n    float dist = length(hitGlobal - ro);\n    \n    // color\n    vec3 color;\n    if (terrainType == VOXEL_NONE) // sky\n    {\n        color = vec3 (0.5, 0.5, 0.6);\n        dist = 1000.0;\n    } else {\n        vec3 ldir = normalize(hitGlobal - ro);\n        color = doColoring(hit, terrainType, hitGlobal, ldir);\n    }\n    \n    // fog\n    float fog = smoothstep(0.0, 10.0, fogAccum);\n    color = mix(color, vec3(0.6), fog);\n    \n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}