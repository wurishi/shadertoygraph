{"ver":"0.1","info":{"id":"Nd3XDj","date":"1633931129","viewed":84,"name":"PetalRocks","username":"rudros","description":"Very small but (hopefully) readable ray-caster","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","mini"],"hasliked":0,"parentid":"fs3SDj","parentname":"Rocks1"},"renderpass":[{"inputs":[],"outputs":[],"code":"#define PI 3.1415326\n\nmat2 rotate2D(float r) {\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\n// Distance of point p to wave #waveNum\nfloat distanceTo(vec3 p, float waveNum) {\n    float frequency = exp(waveNum);\n    return p.y+(abs(cos(p.x*frequency*PI))+sin(p.z*frequency*PI))/frequency;\n}\n\nfloat minimumDist(vec3 p) {\n    float minDist = 1000.;\n    // This loop determines the number of waves being vizualized\n    for(float j=0.; j<mod(iTime, 15.); j++) {\n        float curDist = distanceTo(p, j);\n        minDist = min(minDist, curDist);\n    }\n    return minDist;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float i;\n    float eyeDist, minDist;\n    \n    vec3 eyePos = vec3(0, 0, -1);\n    vec3 ray = vec3((fragCoord.xy-.5*iResolution.xy)/iResolution.x, 1.);\n    ray = normalize(ray);\n\n    // Camera motion\n    eyePos.yz *= rotate2D(5.);\n    eyePos.xz *= rotate2D(iTime);\n    ray.yz *= rotate2D(5.);\n    ray.xz *= rotate2D(iTime);\n\n    for(minDist = 1.; i<100. && minDist>0.001; i++) {\n        // Point to check\n        vec3 p = eyePos+eyeDist*ray;\n         \n        minDist = minimumDist(p);\n        // Move point forward\n        eyeDist += minDist*.25;\n    }\n    i += 2.*(minDist*1000.+eyePos.z);\n    fragColor = vec4(1.-i/100.);\n}\n\n","name":"Image","description":"","type":"image"}]}