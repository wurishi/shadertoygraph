{"ver":"0.1","info":{"id":"WtBczz","date":"1593548012","viewed":119,"name":"cylindrical projection ?w?","username":"meteotrix","description":"eyelash-streak glare requires some type of 3D math, I think it kinda looks like a type of cylindrical projection.\n\nI think orthographic should be enough. warning: trippy :D","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["math"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x = uv.x * 1.777 - 0.38; //squarify UVs\n    vec2 uv0 = fragCoord/iResolution.xy; //original uvs\n    \n    vec3 col = vec3(0.0);\n   \n//pick one\n//#define V0\n//#define V1\n#define V2\n    \n    #ifdef V0\n    \tuv.y -= pow(abs(uv.x - 0.5),0.5)*0.5;    \n    \n    \tfloat distance_to_center = distance(uv.xy, vec2(0.5));\n        float angle_around_center = acos(dot(normalize(uv.xy - vec2(0.5)), vec2(0, 1)));    \t\n        bool draw = (fract((angle_around_center -0.03)*10.0 ) < 0.5 );\n        col = draw ? vec3(1.0) : col ;\n    #endif\n        \n    #ifdef V1\n    \tvec2 offset = vec2(sin(iTime)*0.1, sin(iTime*0.7)*0.1);    \n    \tuv0 += offset;\n    \n    \tfloat depth = sin(acos((uv0.x)*2.0-1.0));\n    \t//col.rgb = vec3(depth);\n    \tvec3 pos3D = vec3(uv0.x, uv0.y, depth);\n    \t\n    \tfloat angle = ((sin(iTime*2.0)+1.0)*0.2) * 3.14159;    \t\n    \tmat3x3 rot = mat3x3(\t1,0,0,\n                            \t0,cos(angle),-sin(angle),\n                            \t0,sin(angle),cos(angle));\n    \tpos3D = pos3D * rot;\n    \tvec2 center = (vec3(0.5,0.5,1) * rot).xy;\n    \t//col.rgb =  texture(iChannel0, pos3D.xy).rgb *0.15 ;\n    \n    \t//concentric lines\n        float distance_to_center = distance(pos3D.xy, center);\n        float angle_around_center = acos(dot(normalize(pos3D.xy - center), vec2(0, 1)));\n    \tif(pos3D.x < center.x) angle_around_center = (3.14159 - angle_around_center)+ 3.14159;\n        bool draw = (fract((angle_around_center - sin(iTime)*0.5)*10.0 ) < 0.5 && distance_to_center <0.5);\n        col = draw ? vec3(1.0) : col ;\n    #endif\n    \n    #ifdef V2\n    \tvec2 offset = vec2(sin(iTime)*0.1, sin(iTime*0.7)*0.1);    \n    \tuv0 += offset;\n    \n    \tfloat depth = sin(acos((uv0.x)*2.0-1.0));\n    \t//col.rgb = vec3(depth);\n    \tvec3 pos3D = vec3(uv0.x, uv0.y, depth);\n    \t\n    \tfloat angle = ((sin(iTime*2.0)+1.0)*0.1) * 3.14159;    \t\n    \tmat3x3 rot = mat3x3(\t1,0,0,\n                            \t0,cos(angle),-sin(angle),\n                            \t0,sin(angle),cos(angle));\n    \tpos3D.z -= 1.0;\n    \tpos3D = pos3D * rot;    \n    \tvec2 center = (vec3(0.5,0.5,1) * rot).xy;\n    \t//col.rgb =  texture(iChannel0, pos3D.xy).rgb  ;    \n    \tcol.rgb =  texture(iChannel1, pos3D.xy).rgb ;\n    #endif\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    //uv.x = uv.x * 1.777 - 0.38; //squarify UVs\n    vec2 uv0 = fragCoord/iResolution.xy; //original uvs\n    \n    //vec2 offset = vec2(sin(iTime)*0.1, sin(iTime*0.7)*0.1);    \n    //uv0 += offset;\n    \n    vec3 col = vec3(0.0);\n    \n    //concentric lines\n        float distance_to_center = distance(uv.xy, vec2(0.5));\n        float angle_around_center = acos(dot(normalize(uv.xy - vec2(0.5)), vec2(0, 1)));\n    \tif(uv.x < 0.5) angle_around_center = (3.14159 - angle_around_center)+ 3.14159;\n        bool draw = (fract((angle_around_center - sin(iTime)*0.5)*10.0 ) < 0.5 && distance_to_center <0.49);\n        col = draw ? vec3(1.0) : col ;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}