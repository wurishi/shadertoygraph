{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"\nfloat easeInOutQuad(float t) {\n    return t < 0.5 ? 2.0 * t * t : -1.0 + (4.0 - 2.0 * t) * t;\n}\n\n// Cubic Easing\nfloat easeInCubic(float t) {\n    return t * t * t;\n}\n\nfloat easeOutCubic(float t) {\n    float f = t - 1.0;\n    return f * f * f + 1.0;\n}\n\nfloat easeInOutCubic(float t) {\n    return t < 0.5 ? 4.0 * t * t * t : (t - 1.0) * (2.0 * t - 2.0) * (2.0 * t - 2.0) + 1.0;\n}\n\n// Quartic Easing\nfloat easeInQuart(float t) {\n    return t * t * t * t;\n}\n\nfloat easeOutQuart(float t) {\n    float f = t - 1.0;\n    return 1.0 - f * f * f * f;\n}\n\nfloat easeInOutQuart(float t) {\n    return t < 0.5 ? 8.0 * t * t * t * t : 1.0 - 8.0 * (t - 1.0) * (t - 1.0) * (t - 1.0) * (t - 1.0);\n}\n\n// Sine Easing\nfloat easeInSine(float t) {\n    return 1.0 - cos((t * 3.141592653589793) / 2.0);\n}\n\nfloat easeOutSine(float t) {\n    return sin((t * 3.141592653589793) / 2.0);\n}\n\nfloat easeInOutSine(float t) {\n    return -0.5 * (cos(3.141592653589793 * t) - 1.0);\n}\n\n// Exponential Easing\nfloat easeInExpo(float t) {\n    return t == 0.0 ? 0.0 : pow(2.0, 10.0 * (t - 1.0));\n}\n\nfloat easeOutExpo(float t) {\n    return t == 1.0 ? 1.0 : 1.0 - pow(2.0, -10.0 * t);\n}\n\nfloat easeInOutExpo(float t) {\n    if (t == 0.0) return 0.0;\n    if (t == 1.0) return 1.0;\n    return t < 0.5 ? 0.5 * pow(2.0, 20.0 * t - 10.0) : 1.0 - 0.5 * pow(2.0, -20.0 * t + 10.0);\n}\n\n// Back Easing\nfloat easeInBack(float t) {\n    const float c1 = 1.70158;\n    return (c1 + 1.0) * t * t * t - c1 * t * t;\n}\n\nfloat easeOutBack(float t) {\n    const float c1 = 1.70158;\n    float f = t - 1.0;\n    return 1.0 + (c1 + 1.0) * f * f * f + c1 * f * f;\n}\n\nfloat easeInOutBack(float t) {\n    const float c1 = 1.70158;\n    const float c2 = c1 * 1.525;\n    return t < 0.5\n        ? (pow(2.0 * t, 2.0) * ((c2 + 1.0) * 2.0 * t - c2)) / 2.0\n        : (pow(2.0 * t - 2.0, 2.0) * ((c2 + 1.0) * (t * 2.0 - 2.0) + c2) + 2.0) / 2.0;\n}\n\nfloat ZeroStartEnd(float x)\n{\n    return pow(x*2.0 -1.0,8.0) * -1.0  + 1.0;\n}\n\n// Remap for float\nfloat remap(float value, float oldMin, float oldMax, float newMin, float newMax) {\n    return newMin + (value - oldMin) * (newMax - newMin) / (oldMax - oldMin);\n}\n\nvec3 offsetHue(vec3 color, float hueOffset) {\n    // Convert RGB to HSV\n    float maxC = max(max(color.r, color.g), color.b);\n    float minC = min(min(color.r, color.g), color.b);\n    float delta = maxC - minC;\n\n    float hue = 0.0;\n    if (delta > 0.0) {\n        if (maxC == color.r) {\n            hue = mod((color.g - color.b) / delta, 6.0);\n        } else if (maxC == color.g) {\n            hue = (color.b - color.r) / delta + 2.0;\n        } else {\n            hue = (color.r - color.g) / delta + 4.0;\n        }\n    }\n    hue /= 6.0;\n\n    float saturation = (maxC > 0.0) ? (delta / maxC) : 0.0;\n    float value = maxC;\n\n    // Offset the hue\n    hue = mod(hue + hueOffset, 1.0);\n\n    // Convert HSV back to RGB\n    float c = value * saturation;\n    float x = c * (1.0 - abs(mod(hue * 6.0, 2.0) - 1.0));\n    float m = value - c;\n\n    vec3 rgb;\n    if (hue < 1.0 / 6.0) {\n        rgb = vec3(c, x, 0.0);\n    } else if (hue < 2.0 / 6.0) {\n        rgb = vec3(x, c, 0.0);\n    } else if (hue < 3.0 / 6.0) {\n        rgb = vec3(0.0, c, x);\n    } else if (hue < 4.0 / 6.0) {\n        rgb = vec3(0.0, x, c);\n    } else if (hue < 5.0 / 6.0) {\n        rgb = vec3(x, 0.0, c);\n    } else {\n        rgb = vec3(c, 0.0, x);\n    }\n\n    return rgb + m;\n}\n\n\nvec2 rotateUV(vec2 uv, float rotation)\n{\n    float mid = 0.5;\n    return vec2(\n        cos(rotation) * (uv.x - mid) + sin(rotation) * (uv.y - mid) + mid,\n        cos(rotation) * (uv.y - mid) - sin(rotation) * (uv.x - mid) + mid\n    );\n}\n\nvec2 rotateUV(vec2 uv, float rotation, vec2 mid)\n{\n    return vec2(\n      cos(rotation) * (uv.x - mid.x) + sin(rotation) * (uv.y - mid.y) + mid.x,\n      cos(rotation) * (uv.y - mid.y) - sin(rotation) * (uv.x - mid.x) + mid.y\n    );\n}\n\nvec2 rotateUV(vec2 uv, float rotation, float mid)\n{\n    return vec2(\n      cos(rotation) * (uv.x - mid) + sin(rotation) * (uv.y - mid) + mid,\n      cos(rotation) * (uv.y - mid) - sin(rotation) * (uv.x - mid) + mid\n    );\n}\n\nvec2 scaleUV(vec2 uv, vec2 scale)\n{\n  // Put texture coordinate origin to center of window.\n  uv = uv * 2.0 - 1.0;\n\n  //scale\n  uv /= mix(vec2(1.0,1.0), vec2(0.0,0.0), scale);\n\n  // scale from center\n  uv = uv * 0.5 + 0.5;\n\n  return uv;\n}\n\n// 2 out, 1 in...\nvec2 hash21(float p) {\n  vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n  p3 += dot(p3, p3.yzx + 33.33);\n  return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nfloat getSpark(vec2 uv, vec2 center, float brightness, float size, float rotation)\n{\n\n  brightness = clamp(brightness,0.001,1.0);\n  size = clamp(size,0.001,1.0);\n  float bn = mix(0.0,0.07,brightness); //recalculate size\n  \n  uv = (uv + vec2(0.5)) ;\n  uv = (uv - center) ;//Center UV coordinates, then scale to fit the star size\n  uv = scaleUV(uv, vec2(1.0 - size));\n  uv = rotateUV(uv, rotation); //rotate the UV\n\n  //this is basically the brightness\n  float p = mix(-1.0,1000.0,easeInExpo(bn));\n\n  float m = mix(\n      0.0,\n      1.0,\n      clamp(\n          pow(abs(uv.x-0.5)*2.0,p) + pow(abs(uv.y-0.5)*2.0,p),0.0,1.0\n      )\n      );\n\n  \n  float mask = easeInSine(1.0 - (m - bn)) - 0.004 ;\n  mask = clamp(mask,0.0,1.0);\n  \n  return mask;\n  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float T_MAX = 3.0;\n    float time = mod(iTime, T_MAX);\n    float t = time/ T_MAX;\n    \n    float aspect = iResolution.x/iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy * vec2(aspect,1.0);\n    \n    float sb = 0.5;\n    \n    float x = 0.66 * sin( hash21(t).x * 6.28);\n    x += 0.5* aspect;\n    //x *= aspect;\n    \n    float mask = getSpark(\n        uv,\n        //vec2( x,t),\n        vec2(0.5,0.5),\n        1.0,\n        sb,\n        6.28*3.0*t\n    );\n\n    fragColor = vec4(1.0 * mask);\n    \n  uv = (uv + vec2(0.5)) ;\n  vec2 center = vec2(0.5,t);\n  uv = (uv - center) ;//Center UV coordinates, then scale to fit the star size  \n  uv = scaleUV(uv, vec2(1.0 - sb));\n  uv = rotateUV(uv, 6.28*t); //rotate the UV\n  \n    //fragColor = vec4(uv.x,uv.y,mask,1.0);\n\n    /*\n    float T_MAX = 1.0;\n    float time = mod(iTime, T_MAX);\n    float t = time/ T_MAX;\n    //t = 1.0 - t;\n    t = 0.07;\n    //t += 0.2;\n    \n    //t = mix(0.1,0.0,t);\n    \n    float progress = t;\n    \n    float aspect = iResolution.x/iResolution.y;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Transform UV coordinates to maintain center\n    vec2 tuv = uv;\n    tuv -= 0.5; // Shift UV coordinates to center (from [-0.5 to 0.5])\n    tuv.x *= aspect; // Scale x-coordinate to match aspect ratio\n    tuv += 0.5; // Shift UV coordinates back (from [0 to 1])\n    \n    uv = tuv;\n    uv = rotateUV(uv,6.28*t*1.0);\n    \n    // this controls the shape ... turn 25.0 into 100.0 to be more square at the end \n    float p = mix(-1.0,1000.0,easeInExpo(progress));\n    //float p = -0.8;\n\n    //this will be used later to make a mask\n    float m = mix(\n        0.0,\n        1.0,\n        clamp(\n            pow(abs(uv.x-0.5)*2.0,p) + pow(abs(uv.y-0.5)*2.0,p),0.0,1.0\n        )\n        );\n\n    //this is the mask\n    //float mask = (m > progress) ? 0.0 : 1.0 ;\n    float mask = 1.0 - (m - progress);\n    mask = easeInSine(mask);\n    \n    fragColor = vec4(1.0 * mask);\n    */\n    \n    \n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4fyfDD","date":"1734035929","viewed":26,"name":"shine_20241212","username":"jgarza9788","description":"20241212","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["20241212"],"hasliked":0,"parentid":"","parentname":""}}