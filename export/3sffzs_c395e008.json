{"ver":"0.1","info":{"id":"3sffzs","date":"1588842704","viewed":275,"name":"Scanlines Demo","username":"ghogan42","description":"This is just to demo a few simple ways to compute scanlines that look ok.\nBasically just copied from my zfact_crt_shader for rpi3.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["scanlines","crt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// You should really just get the code for my retroarch shaders.\n// They're here: https://github.com/RetroPie/common-shaders/tree/rpi/shaders\n\n// Sorry for some nonsense in here. I didn't have too much time to think about it:\n\n// variable uv should be standard 0.0-1.0 texture coordinates.\n// for sharper scaling and for scanlines, you need to know pixel locations.\n// So p is that. Like 0.0-352.0 and 0.0-288.0 or whatever the input res is\n// Yeah that means that a couple of variables may be redundant but I'm copy/pasing here...\n\n// View full screen!  The preview window won't cut it.\n// Change the #define paramters to see what they do.\n// Normally I also have an aperture mask.\n// I didn't inlcude it here because I was asked for scanlines only.\n//  The MASK_FADE is still used because my real shader fades out the aperture mask\n//  when the pixels are bright.\n\n\n//Play with BLURSCALEX to control sharpness.\n#define BLURSCALEX 0.5\n#define BLURSCALEY 0.20\n#define LOWLUMSCAN 4.0  //Scanline Beam Profile\t\t\n#define HILUMSCAN 9.0  //Other scanline beam profile\n#define BRIGHTBOOST 1.1 //Brightness boost for dark parts.\n#define MASK_DARK 0.25   //unused because no aperture mask here.\n#define MASK_FADE 0.95    //Conttrols the transition between scanline profiles (and mask if there was one).\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;        \n \n    //The following slides the texture coordinate towards the center of the pixel. Makes scaling sharper.\n    //Based on this: https://iquilezles.org/articles/texture\n    \n\tvec2 p = uv*iChannelResolution[0].xy;\n\tvec2 i = floor(p) + 0.50; \n    vec2 f = p - i;\n    p = (i + 4.0*f*f*f)/iChannelResolution[0].xy;\n    \n    // But you can lerp between the sharper uv coords and original uv coords\n    // This gives you a basic sharpness control.\n    p.x = mix( p.x, uv.x, BLURSCALEX);\n    p.y = mix( p.y, uv.y, BLURSCALEY);\n    \n    \n    // Now lets do the scanline calculations. One with a thick scanline and one thin.\n    // Then by lerping based on pixel luma you get adaptive scanline thickness.\n    // More importantly you don't lose as much brightness when turing scanlines on.\n    // Look at the plots of the scanline profiles here.\n    // https://www.desmos.com/calculator/ki2fkwkq9f\n    // You can change the paramters to see what happens\n    float Y = f.y*f.y;\n    float YY = Y*Y;\n    float scanLineWeight = (BRIGHTBOOST - LOWLUMSCAN*(Y - 2.05*YY));\n    float scanLineWeightB = 1.0 - HILUMSCAN*(YY-2.8*YY*Y);\n        \n\n\n    //Fetch texture and apply scanlines. Mix based on pixel Luma.  This \"vec3(0.7,0.2,0.1)\" isn't luma but it's close enough...\n\tfragColor = texture(iChannel0,p);\n    \n    \n    // Only uncomment one line below. The bottom two are so you can look at just one scanline profile at a time.\n    // A simple cosine also makes \"ok\" scanlines btw.  This is just better.\n    \n\tfragColor.rgb = fragColor.rgb*mix(scanLineWeight, scanLineWeightB, MASK_FADE*dot(fragColor.rgb, vec3(0.7,0.2,0.1)));\n    //fragColor.rgb = fragColor.rgb*scanLineWeight;\n    //fragColor.rgb = fragColor.rgb*scanLineWeightB;\n    \n    \n}","name":"Image","description":"","type":"image"}]}