{"ver":"0.1","info":{"id":"4fS3DK","date":"1704709244","viewed":65,"name":"Assembly","username":"lukeriley","description":"marching","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"Mc23Dy","parentname":"Donuts 1"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float spacing = 0.;\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdSphere(vec3 p, float s) {\n    p.y += spacing * 0.5 * sin(2. * iTime);\n    return length(p) - s;\n}\n\nfloat smin(float a, float b, float k, out vec3 color) {\n    float res = exp2(-k * a) + exp2(-k * b);\n    vec3 colorA = vec3(1, 0, 0);\n    vec3 colorB = vec3(0, 0, 1);\n\n    float result = -log2(res) / k;\n    color = mix(colorA, colorB, smoothstep(0.0, 1.0, (b - a) / k));\n    return result;\n}\n\nfloat map(vec3 p, out vec3 color) {\n    p = mod(p,spacing) - spacing/2.;\n    float box = sdBox(p,vec3(0.5,0.5,0.5));\n    float sphere = sdSphere(p,0.5);\n    return smin(box,sphere,3.,color);\n}\n\nmat2 rot2D(float theta) {\n    float s = sin(theta);\n    float c = cos(theta);\n    return mat2(c,-s,s,c);\n}\n\nvec3 estimateNormal(vec3 p) {\n    const float eps = 0.001;\n    \n    p.x = mod(p.x,spacing)-spacing/2.;\n        p.y = mod(p.y,spacing)-spacing/2.;\n        p.z = mod(p.z,spacing)-spacing/2.;\n    vec3 colour = vec3(0,0,0);\n    vec3 n = vec3(\n        map(p + vec3(eps, 0, 0),colour) - map(p - vec3(eps, 0, 0),colour),\n        map(p + vec3(0, eps, 0),colour) - map(p - vec3(0, eps, 0),colour),\n        map(p + vec3(0, 0, eps),colour) - map(p - vec3(0, 0, eps),colour)\n    );\n    return normalize(n);\n}\n\nvec3 phongIllumination(vec3 viewDir, vec3 normal, vec3 lightDir, vec3 lightColor) {\n    float ambientStrength = 0.3;\n    float diffuseStrength = max(dot(normal, lightDir), 0.0);\n    float specularStrength = pow(max(dot(reflect(-lightDir, normal), viewDir), 0.0), 16.0);\n    \n    vec3 ambient = ambientStrength * lightColor;\n    vec3 diffuse = diffuseStrength * lightColor;\n    vec3 specular = specularStrength * vec3(1.0, 1.0, 1.0);\n    \n    return ambient + diffuse + specular;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float sensitivity = 2.f;\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 m = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y * sensitivity;\n\n    vec3 ro = vec3(0.5, 0, -3);\n    vec3 rd = normalize(vec3(uv, 1));\n    ro.xz *= rot2D(-m.x);\n    rd.xz *= rot2D(-m.x);\n    ro.yz *= rot2D(-m.y);\n    rd.yz *= rot2D(-m.y);\n    \n    vec3 col = vec3(0);\n\n    float t = 0.0;\n\n    for (int i = 0; i < 80; i++) {\n        vec3 p = ro + rd * t;\n        \n        p.x = mod(p.x,spacing)-spacing/2.;\n        p.y = mod(p.y,spacing)-spacing/2.;\n        p.z = mod(p.z,spacing)-spacing/2.;\n       \n        float d = map(p,col);\n\n        t += d;\n\n        if (d < 0.001) break;\n        if (t > 100.0) break;\n    }\n\n    vec3 point = ro + rd * t;\n    vec3 normal = estimateNormal(point);\n\n    vec3 lightDir = normalize(vec3(1.0, 1.0, -1.0)); // Directional light\n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n    vec3 viewDir = normalize(ro - point);\n    \n    //col = phongIllumination(viewDir, normal, lightDir, lightColor);\n    if(t>100.) {\n        col=vec3(0);\n    }\n\n    fragColor = vec4(col, 1);\n}\n","name":"Image","description":"","type":"image"}]}