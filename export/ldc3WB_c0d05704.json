{"ver":"0.1","info":{"id":"ldc3WB","date":"1452273633","viewed":972,"name":"2d ray tracer","username":"TioTio","description":"inspired by http://zenphoton.com/","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["2d","raytracer","line","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// lines per frame. increase for quality\n// should be the same on the \"Buf A\" tab\n#define LPF 10.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 b = texture(iChannel0, uv).xyz;\n\n    b /= float(iFrame+1) * LPF / 1000.0 * 6.0;\n    \n    fragColor = vec4(b, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// lines per frame. increase for quality\n// should be the same on the \"Image\" tab\n#define LPF 10.0\n\n// count of walls on scene\n// if you want to add/remove some walls\n// this should be changed too\n#define SEGS_COUNT 3\n\n// i don't know how to explain this =)\n// just set to 0.5 and see what will happen\n#define STEP_SIZE 0.0107\n\n// how many times ray can reflect\n#define BOUNCE_COUNT 5\n\n// uncomment and have fun!\n//#define USE_MOUSE\n\n// magick variable\n// DO NOT MODIFY!\n#define FLOAT_MAX 10000.0\n\n// array of walls\n// .xy -> starting point\n// .zw -> ending point\nvec4 segs[SEGS_COUNT];\n\n\n// my interpretation of Xiaolin Wu's line drawing algorithm\nfloat lineWu(vec2 a, vec2 b, in vec2 c)\n{   \n    float minX = min(a.x, b.x);\n    float maxX = max(a.x, b.x);\n    float minY = min(a.y, b.y);\n    float maxY = max(a.y, b.y);\n        \n    // crop line segment\n    if (c.x < floor(minX) || c.x > ceil(maxX))\n        return 0.0;\n    if (c.y < floor(minY) || c.y > ceil(maxY))\n        return 0.0;\n\n    // swap X and Y\n\tvec2 d = vec2(abs(a.x - b.x), abs(a.y - b.y));\n    if (d.y > d.x) \n    {\n        a = a.yx;\n        b = b.yx;\n        c = c.yx;\n        d = d.yx;\n        \n        minX = minY;\n        maxX = maxY;\n    } \n\n    // handle end points\n    float k = 1.0;\n    if (c.x == floor(minX))\n        k = 1.0 - fract(minX);\n    if (c.x == ceil(maxX))\n        k = fract(maxX);\n    \n    // find Y by two-point form of linear equation\n    // http://en.wikipedia.org/wiki/Linear_equation#Two-point_form\n    float y = (b.y - a.y) / (b.x - a.x) * (c.x - a.x) + a.y;\n\n    // calculate result brightness    \n    float br = 1.0 - abs(c.y - y);\n   \treturn max(0.0, br) * (0.5 * length(d) / d.x) * k;\n}\n\nfloat raySegmentIntersect(vec2 ro, vec2 rd, vec4 seg)\n{\n\tfloat rs = rd.y / rd.x;\n    vec2 v = seg.zw - seg.xy;\n    \n    float N = ((seg.x - ro.x) * rs + (ro.y - seg.y)) / (v.y - v.x * rs);\n    if (N < 0.0 || N > 1.0) \n        return -1.0;\n    \n    float M = 0.0;\n    if (abs(rs) < 1.0)\n    {\n        M = (seg.x + v.x * N - ro.x) / rd.x;\n    }\n    else\n    {\n        M = (seg.y + v.y * N - ro.y) / rd.y;\n    }\n    \n    return M;\n}\n\nfloat raySegmentIntersect2(vec2 ro, vec2 rd, vec4 seg)\n{\n    float a = rd.y / rd.x;\n    float b = (seg.w - seg.y) / (seg.z - seg.x);\n    if (a == b) \n        return -1.0;\n    \n    float c = a*(-ro.x)+ro.y;\n    float d = b*(-seg.x)+seg.y;\n    float x = (d - c) / (a - b);\n    float y = a*x + c;\n    \n    float p = 0.0;\n    float p1 = 0.0;\n    float p2 = 0.0;\n    if (abs(rd.y) / abs(rd.x) < 1.0)\n    {\n        p = x;\n        p1 = seg.x;\n        p2 = seg.z;\n    }\n    else\n    {\n        p = y;\n        p1 = seg.y;\n        p2 = seg.w;\n    }\n    //float minX = min(p1, p2);\n    //float maxX = max(p1, p2);\n    //if (p < floor(minX) || p > ceil(maxX))\n    //    return -1.0;\n    \n    if (abs(p1 - p2) < abs(p2 - p) + abs(p1 - p))\n    \treturn -1.0;\n    \n    p = 0.0;\n    p1 = 0.0;\n    p2 = 0.0;\n    if (abs(rd.y) / abs(rd.x) >= 1.0)\n    {\n        p = x;\n        p1 = ro.x;\n        p2 = ro.x+rd.x*1000.0;\n    }\n    else\n    {\n        p = y;\n        p1 = ro.y;\n        p2 = ro.y+rd.y*1000.0;\n    }\n    float minX = min(p1, p2);\n    float maxX = max(p1, p2);\n    if (p < floor(minX) || p > ceil(maxX))\n        return -1.0;\n    \n    vec2 intersection = vec2(x, y);\n    return length(intersection - ro);\n}\n\nfloat trace(vec2 ro, vec2 rd, vec2 c)\n{\n    vec4 closestSeg = vec4(-1.0);\n    float col = 0.0;\n    for (int j=0;j<=BOUNCE_COUNT;j++)\n    {\n        vec4 lastHit = vec4(-1.0);\n        float closest = FLOAT_MAX;\n        for (int i=0;i<SEGS_COUNT;i++)\n        {\n            if (closestSeg == segs[i])\n                continue;\n            \n            float inters = raySegmentIntersect2(ro, rd, segs[i]);\n            if (inters > 0.0 && inters < closest)\n            {\n                closest = inters;\n                lastHit = segs[i];\n            }\n        }\n        \n        vec2 ip = ro + rd * closest; // intersection point\n        col += lineWu(ro, ip, c);\n        \n        if (lastHit.x == -1.0) break;\n        \n        closestSeg = lastHit;\n        ro = ip;\n        vec2 nor = closestSeg.yz - closestSeg.wx;\n        float d = length(nor);\n        nor /= d;\n        float t = 2.0 * (nor.x * rd.x + nor.y * rd.y);\n        rd = rd - t * nor;        \n    }\n    \n\treturn col;\n}\n\nvec4 segBld(float x0, float y0, float x1, float y1)\n{\n    return vec4(iResolution.x*x0,iResolution.y*y0,iResolution.x*x1,iResolution.y*y1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // initialization segments relative to iResolution\n    segs[0] = segBld(0.3, 0.3,  0.25, 0.6);\n    segs[1] = segBld(0.3, 0.2,  0.5, 0.2);\n    segs[2] = segBld(0.6, 0.3,  0.6, 0.5);\n    //segs[0] = segBld(0.23, 0.1,  0.14, 0.5);\n    //segs[1] = segBld(0.81, 0.3,  0.8,  0.8);\n    //segs[2] = segBld(0.4,  0.5,  0.42, 0.8);\n\n    vec2 c = fragCoord - 0.5;\n    \n    vec2 ro = iResolution.xy * 0.5;\n    \n    // *** for tests =) ***\n    //vec2 end = iMouse.xy;\n    //vec2 end = start + vec2(0.6, 200.0);\n        \n    //float r = 100.0;\n    //float k = 0.01;\n        \n    //vec2 end = vec2(r * sin(k),r * cos(k));\n    //end += start;\n    //float n = lineWu(start, end, c);\n    //\n    //end = vec2(r * sin(k2),r * cos(k2));\n    //end += start;\n    //n += lineWu(start, end, c);\n    \n    //float n = 0.0;\n    //for(float i=0.0;i<LPF;i++)\n    //{\n    //    float r = 100.0;\n    //    float k = float(iFrame) * 0.107 + i * 0.107 / LPF;\n    //    float x = r*sin(k);\n    //    float y = r*cos(k);\n    //    vec2 end = vec2(x, y);\n    //    end += ro;\n    //    \n    //    n += lineWu(ro, end, c);\n    //}\n    \n    //float r = 1.0;\n    //float k = 4.0;\n    //float x = r*sin(k);\n    //float y = r*cos(k);\n    //vec2 rd = vec2(x, y);\n    //float n = trace(start, rd, c);\n    //n += lineWu(start, rd, c);\n    // **************\n    \n    float n = 0.0;\n  \n#ifdef USE_MOUSE\n    vec2 rd = normalize(iMouse.xy - ro);\n    n = trace(ro, rd, c);\n#else    \n    for(float i=0.0;i<LPF;i++)\n    {\n        float r = 1.0;\n        float k = float(iFrame) * STEP_SIZE + i * STEP_SIZE / LPF;\n        float x = r*sin(k);\n        float y = r*cos(k);\n        vec2 rd = vec2(x, y);\n        \n        n += trace(ro, rd, c);\n    }\n#endif\n    \n    vec3 old = texture(iChannel0, fragCoord/iResolution.xy).xyz;\n    fragColor = vec4(old+n, 1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}