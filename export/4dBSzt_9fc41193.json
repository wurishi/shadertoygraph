{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/*-----------------------------------------------------------------------------\nWritten by Alan Wolfe\nhttp://blog.demofox.org\n\nTaking advantage of the fact that the derivative (slope) of a point on sin(x) is cos(x),\nand the derivative (slope) of a point on cos(x) is -sin(x) to calculate sin iteratively,\nwithout actually using trig functions. (as read in game programming gems 8, chapter 6.1\n\"A Practical DSP Radio Effect\"\n\nGreen is the aproximated sin value, red is the actual sine value.\n\nTick marks are at PI/2\n\nDIVISIONS being a higher value results in more accurate results.\n\nAt the very end, it uses 1024 divisions (2^10)\n\nProbably pretty useful for trig based splines, not having them have to calculate\nsine in the inner loop.\n-----------------------------------------------------------------------------*/\n\n// number of steps in the aproximation\n#define DIVISIONS int(pow(2.0, min(floor(iTime / 0.5) + 1.0, 10.0)))\n\n// graph settings\n#define POINTSIZE 0.05\n#define LINEWIDTH 0.1\n#define LINEHEIGHT 0.5\n#define LINEINTERVAL (PI*0.5)\n\n// constants\n#define PI 3.14159265359\n#define MAXSTEPS 4700\n#define STEPDELTA (2.0*PI / float(DIVISIONS))\n\n//-----------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    // set up our coordinate system.\n    // x = 0 is the left side of the screen.\n    // y = 0 is the center of the screen\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 percent = ((fragCoord.xy / iResolution.xy) - vec2(0.0,0.5));\n    percent *= 16.0;\n    percent.x *= aspectRatio;\n    \n    // calculate our iterative sin up to the current X value.\n    // in code that isn't a pixel shader, you wouldn't have to iterate from 0 every time!\n    float vcos = 1.0;    \n    float vsin = 0.0;\n    float v = 0.0;\n    for (int i = 0; i < MAXSTEPS; ++i) {\n        float vcosscaled = vcos * STEPDELTA;\n        float vsinscaled = vsin * STEPDELTA;\n        \n        vsin += vcosscaled;\n        vcos -= vsinscaled;\n        \n        v += STEPDELTA;\n        if (v >= percent.x)\n            break;\n    }\n    \n    // draw the black graph markings and background\n    float bgColor = 0.3;\n    bgColor *= abs(percent.y) < LINEWIDTH ? 0.0 : 1.0;\n    if ((mod(percent.x, LINEINTERVAL) < LINEWIDTH * 0.5 || mod(percent.x, LINEINTERVAL) > (LINEINTERVAL - LINEWIDTH * 0.5))\n      &&(abs(percent.y) < LINEHEIGHT))\n        bgColor *= 0.0;\n    \n    // draw the sine values\n    vec3 color = vec3(bgColor);    \n    if (abs(percent.x - v) < POINTSIZE) {\n        // real\n        if (abs(percent.y - sin(v)) < POINTSIZE)\n            color.x = 1.0;\n        \n        // aproximated\n        if (abs(percent.y - vsin) < POINTSIZE)\n            color.y = 1.0;\n    }\n        \n\tfragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dBSzt","date":"1414700540","viewed":498,"name":"Sin without trig","username":"demofox","description":"Taking advantage of the fact that the derivative (slope) of a point on sin(x) is cos(x), and the derivative (slope) of a point on cos(x) is -sin(x) to calculate sin iteratively, without actually using trig functions.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","math","sin"],"hasliked":0,"parentid":"","parentname":""}}