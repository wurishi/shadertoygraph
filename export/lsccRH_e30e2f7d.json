{"ver":"0.1","info":{"id":"lsccRH","date":"1517922812","viewed":259,"name":"slit scan attempt 2","username":"pentaphobe","description":"slit scan attempt","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["fx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\n\nvec3 getAtScale(sampler2D chan, vec2 uv, float sc) {\n    vec2 h = vec2(0.5, 0.5);\n    \n    return texture(chan, (uv - h) * sc + h).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 color = texture(iChannel2, uv).rgb;\n \n    \n    vec3 col = color\n        + getAtScale(iChannel2, uv + vec2(-0.001, 0.001), 0.5) * 1.6\n        + getAtScale(iChannel2, uv + vec2(+0.001, -0.001), 0.29) * 0.8\n        + abs(getAtScale(iChannel2, uv, 1.01) * 1.0\n        - ( getAtScale(iChannel2, uv, 0.55)) * 1.0)\n    ;\n    \n    float overblow = 0.05f;\n    // move bright colours towards white\n    col += pow(dot(col * overblow, vec3(1.f, 1.f, 1.f)), 1.1f) * 0.15f;\n    \n    // linear to gamma\n    col = clamp(pow(col, vec3(2.2f)), 0.0, 1.0);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define ROTATION\n#define MOVEMENT\n#define OLD_MOVEMENT\n#define TIME_BLENDING\n\nfloat map( float v, float aMin, float aMax, float bMin, float bMax ) {\n\treturn (clamp(v, aMin, aMax) - aMin) * ((bMax-bMin)/(aMax-aMin)) + bMin;\n}\n\n\nfloat slit( vec2 uv, float size ) {\n    return 1.0f - smoothstep((size * iResolution.x - 50.f) / iResolution.x, size, abs(uv.x - 0.5f)*2.f);\n}\n\nfloat distanceMask( vec2 uv, float size ) {\n    return smoothstep(0.0, size, abs(uv.x - 0.5f)*2.f);\n}\n\nvec4 linear(sampler2D tex, vec2 uv) {\n    vec3 col = pow(texture(tex, vec2(uv.x, uv.y - sin(uv.x * 0.25))).rgb, vec3(1.0/2.f));\n        \n    return vec4(col, 1.0);\n    //return texture(tex,uv);\n}\n\nvec4 linearPerm(sampler2D tex, vec2 uv) {\n    return abs(sin(uv.x * iResolution.x * 0.2)) * linear(tex, uv);\n}\n\nvec2 gelUvMap( vec2 uv, float zoom, float zOffs ) {\n    vec2 c = (uv - vec2(0.5, 0.5)) * 2.0;\n    float z = map(pow(abs(c.x), 0.7), 0.0, 1.0, 0.25, 2.0);\n    // offset Z by our zoom factor\n    z += z * map(zoom, 1.0, 100.0, 0.5, 0.0);    \n    \n    // start off zoomed out\n    //z += (1.0 - clamp(iTime/10.0, 0.001, 1.0)) * 10.0;\n    \n    //z *= (100.0-zoom) / 10.0;\n    vec2 p = vec2(c.x/z * 4.0, c.y/pow(z, 0.8)) * 0.5;\n    \n    p += vec2(0.00001, 0.00000001) * zoom;\n    \n    vec2 uvMod = \n        // right side\n        vec2(abs(p.x), p.y + 23.371) * step(0.0, -c.x) +\n        // left side\n        vec2(abs(p.x), p.y) * step(0.0, c.x);\n       \n    //uvMod *= map(zoom, 0.f, 100.f, ;\n    \n#ifdef MOVEMENT\n  #ifdef OLD_MOVEMENT\n\tvec2 pos = vec2(-iTime * 1.38, iTime * 0.02);\n    pos += vec2(0.0, sin(iTime / 17.0) * sin(iTime / 50.0) * 1.25);\n  #else\n    vec2 pos = vec2(-z * 0.38, z * 0.002);\n    pos += vec2(0.0, sin(z / 17.0) * sin(z / 50.0) * 1.25);\n  #endif\n#else\n    vec2 pos = vec2(0.);\n#endif\n    \n    // uv map\n    return uvMod + pos;    \n}\n\nvec3 gel( vec2 uv, float zoom, float z ) {\n    vec2 uvMap = gelUvMap(uv, zoom, z);\n    \n    vec3 tex = vec3(0.0, 0.0, 0.0);\n\n    vec3 layer1 = linear(iChannel0, uvMap + cos(uvMap)).rgb * vec3(1.0, 0.6, 0.5);\n    vec3 layer2 = linear(iChannel1, vec2(uvMap.y, uvMap.x) * 0.5).rgb * vec3(1.0, 1.0, 1.0);\n    \n    vec3 layer3 = sin(linearPerm(iChannel1, vec2(uvMap.y, uvMap.x) * 0.1).rgb) * vec3(1.2, 0.2, 0.4);\n    vec3 layer4 = (vec3(1.0) - linear(iChannel2, (layer3.yx * 0.125) + gelUvMap(uv, zoom*2.0, z) * 0.5).rgb) * vec3(1.0, 0.2, 0.6);\n    \n#ifdef TIME_BLENDING\n    tex = \n        layer1  * \n        layer2 * smoothstep(-3.1, 1.5, 0.5 + cos(iTime * 0.333)) +\n        layer3 * smoothstep(0.0, 2.0, 0.25 + cos(iTime / 2.7) * sin(iTime / 2.3)) +\n        layer4 * smoothstep(-2.0, 3.1, 0.25 + sin(iTime / 4.0) * sin(iTime / 1.3))\n    ;\n#else\n    tex = \n        layer1 * smoothstep(-2.9, 2.9, 0.25 + sin(z * 1.11)) * \n        layer2 * smoothstep(-3.1, 1.5, 0.5 + cos(z * 0.333)) +\n        layer3 * smoothstep(0.0, 2.0, 0.25 + cos(z / 2.7) * sin(uv.y / 2.3)) +\n        layer4 * smoothstep(-2.0, 3.1, 0.25 + sin(z / 4.0) * sin(uv.y / 1.3))\n    ;\n#endif\n    \n    return (tex) / 2.0;\n}\n\nvec2 rotate2d( vec2 p, vec2 o, float angle ) {\n    float s = sin(angle);\n    float c = cos(angle);\n    p = p - o;\n\tp = vec2(p.x * c - p.y * s,\n                p.x * s + p.y * c);\n    p += o;\n    \n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n#ifdef ROTATION\n    float rotation = sin(iTime / 5.0) + sin(iTime / 3.0 + sin(iTime / 11.0));\n    \n\tuv = rotate2d(uv, vec2(0.5, 0.5), rotation);\n#endif    \n    \n    // accumulator\n    vec3 col = vec3(0, 0, 0);\n    \n    float zoomStep = 10.f;\n    //float zoom = 50.f; \n    //float zoom = clamp(abs(sin(iTime / 2.0))*100.f, 1.0, 100.0);\n    float totalSteps = 0.1;\n#ifdef MOVEMENT    \n    float z = iTime * 2.0;\n#else\n    float z = 0.;\n#endif\n    \n    for (float zoom = 0.f; zoom < 100.0f; zoom += zoomStep)\n    {\n        float realZoom = pow(zoom / 10.f, 2.1f) * 0.75f;\n        float slitSize = map(realZoom, 0.f, 100.f, 0.005f, 1.5f);        \n        \n        float mask = slit(uv, slitSize);\n        //col += vec3(1.f, 1.f, 1.f) * mask;\n        float stepMix = (1.0 / map(zoom, 0.0, 100.0, 1.0, 24.2)) * mask;\n        totalSteps += stepMix;\n        col += gel(uv, zoom, z) * stepMix;\n    }    \n    \n    col /= totalSteps;\n    col *= distanceMask(uv, 0.01) * 2.0;\n    // fade in   \n    col *= clamp(iTime / 2.0, 0.0, 1.0);\n    \n    // Output to buffer\n    fragColor = vec4(col,1.0);\n    \n}","name":"Buf A","description":"","type":"buffer"}]}