{"ver":"0.1","info":{"id":"DddfR7","date":"1696994298","viewed":65,"name":"Vector Operations","username":"MaxShaders","description":"Vector Addition, subtraction, dot, cross, angle\nClick on the window to override the second vector\nChange the operation mode on line 57","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["math"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///Vector functions demo created for a physics class assignment\n//Click and drag in the viewport to override the second vector\n//Change the operation bellow (See \"<---- OPERATION MODE\")\n\n#define ADDITION 1\n#define SUBTRACTION 2\n#define ANGLE 3\n#define DOT 4\n#define CROSS 5\n\n//Distance from a point in 2D to a line segment in 2D, written by ChatGPT\nfloat distanceToSegment(vec2 start, vec2 end, vec2 point) {\n    vec2 segment = end - start;\n    vec2 toPoint = point - start;\n    float segmentLength = length(segment);\n    \n    // Handle degenerate case where the start and end points are the same.\n    if (segmentLength < 0.0001) {\n        return length(toPoint);\n    }\n    \n    // Calculate the projection of the point onto the segment.\n    float t = dot(toPoint, segment) / (segmentLength * segmentLength);\n    \n    // If the projection is outside the segment, return the distance to the closest endpoint.\n    if (t < 0.0) {\n        return length(toPoint);\n    }\n    else if (t > 1.0) {\n        vec2 toEnd = point - end;\n        return length(toEnd);\n    }\n    \n    // Calculate the closest point on the segment to the point.\n    vec2 closestPoint = start + t * segment;\n    \n    // Return the distance between the closest point and the given point.\n    return length(point - closestPoint);\n}\n\n//Draws line segments\nvec3 drawSegment(vec3 start, vec3 end, vec2 pixel, float distThreshold)\n{\n    float dist = distanceToSegment(start.xy, end.xy, pixel.xy);\n    if(dist < distThreshold)\n    {\n        return vec3(clamp(distThreshold - dist, 0.0, 1.0));\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //CHANGE OPERATION HERE\n    //Operations:\n    //ADDITION, SUBTRACTION, ANGLE, DOT, CROSS\n    int operation = ADDITION; // <---------------------- OPERAATION MODE\n    \n    int numVectors = 2; //<---MAKE SURE THIS MATCHES LIST BELLOW\n    vec3[] vectors = vec3[] (\n    //CHANGE VECTORS HERE\n    vec3(100, 0, 0), \n    vec3(0, 100, 0)\n    );\n    \n    //Use Mouse for second vector\n    bool useMouseForVector2 = true;\n    if(useMouseForVector2 && iMouse.xy != vec2(0))\n    {\n        vectors[1] = vec3(iMouse.x - (iResolution.x / 2.0), iMouse.y - (iResolution.y / 2.0), 0);\n    }\n    \n    float[] scalars = float[] (\n    //CHANGE SCALARS HERE, must be 'numVectors' Scalars\n    1.0,\n    1.0\n    );\n    \n    \n    \n    //Currently 6 colors, therefore up to 6 vectors, add more colors to support more vectors\n    vec3[] colors = vec3[] (vec3(1, 0, 0), vec3(0, 1, 0), vec3(0, 0, 1), vec3(1, 1, 0), vec3(0, 1, 1), vec3(1, 0, 1));\n    vec2 pixel = fragCoord.xy;\n    vec3 origin = vec3(iResolution.xy / 2.0, 0);\n    vec3 col = vec3(0);\n    float distThreshold = 2.0;\n    \n    //Scales provided vectors by provided scalars\n    for(int i = 1; i < numVectors; i++)\n    {\n        vectors[i] *= scalars[i];\n    }\n    \n    if(operation == 1) // ADDITION\n    {\n        //Draws the sum of the vectors\n        vec3 sum = vectors[0];\n        for(int i = 1; i < numVectors; i++)\n        {\n            sum += vectors[i];\n        }\n        col += drawSegment(origin, origin + sum, pixel, distThreshold) * colors[numVectors];\n    }\n    else if(operation == 2) //SUBTRACTION\n    {\n        //Draws the difference of the vectors\n        vec3 difference = vectors[0];\n        for(int i = 1; i < numVectors; i++)\n        {\n            difference -= vectors[i];\n        }\n        col += drawSegment(origin, origin + difference, pixel, distThreshold) * colors[3];\n    }\n    else if(operation == 3) //ANGLE\n    {\n        //Calculates and draws the angle between the two vectors\n        float angle = acos(dot(normalize(vectors[0]), normalize(vectors[1])));\n        vec3 mid = (normalize(vectors[0]) + normalize(vectors[1])) / 2.0;\n        vec3 originToPixelNorm = normalize(vec3(pixel, 0) - origin);\n        float pxA1 = (acos(dot(originToPixelNorm, normalize(vectors[0]))));\n        float pxA2 = (acos(dot(originToPixelNorm, normalize(vectors[1]))));\n        float d = distance(pixel, origin.xy);\n        if(d < 50.0 && d > 48.0 && (pxA1 < angle && pxA2 < angle && dot(originToPixelNorm, mid) > 0.))\n        {\n            col = vec3(1);\n        }\n    }\n    else if(operation == 4) //DOT\n    {\n        //Draws a circle with radius proportional to the dot product of the two vectors, scaled by 1/100, filled if positive and hollow if negative \n        float dotProduct = dot(vectors[0], vectors[1]);\n        float d = distance(pixel, origin.xy);\n        float len = dotProduct / 100.0;\n        if(d < abs(len))\n        {\n            if(dotProduct < 0.0)\n            {\n                if(d + 8. >= abs(len))\n                {\n                    col += vec3(0.2);\n                }\n            }\n            else\n            {\n                col += vec3(0.2);\n            }\n        }\n    }\n    else if(operation == 5) //CROSS\n    {\n        //Draws a circle with radius proportional to the length of the cross product vector (scaled by 1/100), \n        // hollow if facing into the screen and filled if facing out of the screen\n        vec3 crossProduct = cross(vectors[0], vectors[1]);\n        float d = distance(pixel, origin.xy);\n        float len = length(crossProduct) / 100.;\n        if(d < len)\n        {\n            if(crossProduct.z < 0.)\n            {\n                if(d + 4. >= len)\n                {\n                    col += vec3(0.2);\n                }\n            }\n            else\n            {\n                col += vec3(0.2);\n            }\n        }\n    }\n    \n    \n    \n    //Draws original vectors\n    for(int i = 0; i < numVectors; i++)\n    {\n        col += drawSegment(origin, origin + vectors[i], pixel, distThreshold) * colors[i];\n    }\n\n    //Draws midpoint\n    if(distance(pixel, origin.xy) < 3.0)\n    {\n        col = vec3(1.0);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}