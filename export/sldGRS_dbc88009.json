{"ver":"0.1","info":{"id":"sldGRS","date":"1636304217","viewed":104,"name":"yee1212","username":"dspindler","description":"cool shader\n","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["yeex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\nvec3 rotate(vec3 v, vec3 axis, float angle) {\n    mat4 m = rotationMatrix(axis, angle);\n    return (m * vec4(v, 1.0)).xyz;\n}\n\nfloat sdSphere( vec3 p)\n{\n    return length(p)-.5;\n}\n\nfloat sdBox( vec3 p, vec3 b ){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0))+min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat SineCrazy(vec3 p) {\nreturn 1. - (sin(p.x) - sin(p.y) + sin(p.z))/3.;\n   // return 1.-(p.x*p.x - p.y +cos(p.z))/3.;\n}\nfloat CosCrazy(vec3 p) {\nreturn 1.-(cos(p.x) + 2.*cos(p.y) + cos(p.z))/3. ;\n}\n\nfloat sdOctahedron( vec3 p)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-0.8;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+0.5),0.0,0.5); \n  return length(vec3(q.x,q.y-0.5+k,q.z-k)); \n}\n\n       \n\nfloat scene(vec3 p){\n    vec3 p1 = rotate(p,vec3(0.1,1.,0.1),iTime/10.);\n    // return sdBox(p1, vec3(0.5,0.5,0.5));\n    float scale = 8.+ 5.*sin(iTime/12.);\n    \n    return max(sdOctahedron(p1), (0.85 - SineCrazy(p1*scale))/scale);\n}\n\nvec3 getNormal(vec3 p){\n\t\n\tvec2 o = vec2(0.001,0.);\n\t// 0.001,0,0\n\treturn normalize(\n\t\tvec3(\n\t\t\tscene(p + o.xyy) - scene(p - o.xyy),\n\t\t\tscene(p + o.yxy) - scene(p - o.yxy),\n\t\t\tscene(p + o.yyx) - scene(p - o.yyx)\n\t\t)\n\t);\n}\n\nvec3 GetColorAmount(vec3 p) {\n    float amount = clamp((1.5-length(p))/2. , 0., 1.);\n    vec3 col = 0.5 + 0.5 * cos(6.28319 * (vec3(0.2,0.0,0.0) + amount * vec3(1.0,1.0,0.5)));\n    return col*amount;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 newUV = fragCoord/iResolution.xy;\n    \n    vec2 p = newUV - vec2(0.5);\n    \n    \n    vec3 camPos = vec3(-0.5,0.,2.+0.5*sin(iTime/4.));\n    \n    \n    vec3 ray = normalize(vec3(p, -1.));\n    \n    vec3 rayPos = camPos;\n    float curDist = 0.;\n    float rayLen = 0.;\n    \n    vec3 light = vec3(-1.,1.,1.);\n    \n    vec3 color = vec3(0.);\n   \n    for(int i=0;i<64;++i){\n        curDist = scene(rayPos);\n        rayLen += 0.6*curDist;\n    \n        rayPos = camPos + ray*rayLen;\n        if(abs(curDist)<0.001){\n        \n            vec3 n = getNormal(rayPos);\n            \n            float diff = dot(n,light);\n            // color = GetColor(length(2.*rayPos));\n            break;\n        }\n        color += 0.04*GetColorAmount(rayPos);\n    }\n    // Output to screen\n    fragColor = vec4(color,1.);\n    \n}\n","name":"Image","description":"","type":"image"}]}