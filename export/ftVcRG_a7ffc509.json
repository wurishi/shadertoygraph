{"ver":"0.1","info":{"id":"ftVcRG","date":"1661715622","viewed":945,"name":"Raymarching Engine Demo","username":"KilledByAPixel","description":"This is a test of the new raymarching system I am developing. It includes soft shadows, ambient occlusion, reflections, roughness, and more. Let me know if you have any suggestions for improvements or any issues running it. This is a work in progress.","likes":22,"published":1,"flags":0,"usePreview":1,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Rendering Engine Demo\n// Copyright Frank Force 2022\n// https://frankforce.com\n\n// This demo includes 50 objects with a directional, ambient, and point light.\n// Each object also has it's own material properties.\n\n// global settings\nconst int maxRaycastIterations = 100;\nconst int maxReflectionIterations = 50;\nconst int maxShadowIterations = 80;\nconst bool enableShadows = true;\nconst bool enableAmbientOcclusion = true;\nconst bool enableAmbientLights = true;\nconst bool enableDirectionalLights = true;\nconst bool enablePointLights = false;\nconst bool enableReflections = true;\nconst bool enableSpecular = true;\nconst bool enableMaterials = true;\n\n// forward declarations for generated code\nvec3 getColor(vec3 startPosition, vec3 direction);\nvec2 sceneDistance(vec3 pos);\n\n// helper functions\nmat3 getRotationMatrix(vec3 direction)\n{\n\tvec3 f = direction;\n\tvec3 r = normalize(cross(vec3(0,1,0), f));\n\tvec3 u = -cross(r,f);\n    return mat3(r, u, f);\n}\nvec2 rotate(vec2 v, float angle)\n{ \n    return v*cos(angle) + vec2(-v.y,v)*sin(angle); \n}\nvec3 hash3( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\treturn fract(sin(p)*3e4);\n}\n\nvec3 noise3(vec3 p)\n{\n    // fast build noise, prevent inlining calls to hash33\n    const vec2 o = vec2(1, 0);\n    vec3 i = floor(p);\n    vec3 f = smoothstep(0., 1., fract(p));\n\n    vec3 hashResult[8]; \n    for(int j=0; j<8; ++j)\n    {\n        vec3 z = vec3(\n            (j&1)==0?0.:1.,\n            (j&2)==0?0.:1.,\n            (j&4)==0?0.:1.);\n        hashResult[j] = hash3(i+z);\n    }\n    \n    return mix(\n        mix\n        (\n            mix(hashResult[0], hashResult[1], f.x), \n            mix(hashResult[2], hashResult[3], f.x), \n            f.y\n        ),\n        mix\n        (\n            mix(hashResult[4], hashResult[5], f.x), \n            mix(hashResult[6], hashResult[7], f.x),\n            f.y\n        ),\n        f.z\n    );\n}\n\nvec3 fractalNoise3(vec3 p)\n{ return .52*noise3(p) + .28*noise3(p*2.) + .13*noise3(p*4.) + .07*noise3(p*8.); }\nfloat noise(vec3 p) { return noise3(p).x; }\nfloat fractalNoise(vec3 p) { return fractalNoise3(p).x; }\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    // input\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    // camera\n    float time = .2* iTime;\n    float cameraDistance = 90.;\n    vec3 cameraDirection = normalize(vec3(1.0,0,0));\n    cameraDirection.xy = rotate(cameraDirection.xy, mouse.y > 0. ? -1.4*(1.-mouse.y) : .3*cos(.1*iTime)-.5);\n    vec3 lookAtPosition = vec3( 0, mouse.x*15., 0);\n    cameraDirection.xz = rotate(cameraDirection.xz, iMouse.z > 0. ? -8.*mouse.x : .1*iTime);\n    vec3 cameraPosition = lookAtPosition - cameraDistance * cameraDirection;\n    float cameraZoom = 3.;\n    \n    // render the pixel\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    mat3 cameraTransform = getRotationMatrix(cameraDirection);\n    vec3 direction = cameraTransform * normalize(vec3(uv, cameraZoom));\n    fragColor = vec4(getColor(cameraPosition, direction), 1);\n}\n\n// distance shapes\nfloat distancePlane(vec3 p, vec3 n) { return dot(p, n); }\nfloat distanceSphere(vec3 p, float r) { return length(p) - r; }\nfloat distanceBox(vec3 p, vec3 s, float e)\n{\n    vec3 d = abs(p) - s + e;\n    return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.)) - e;\n}\nfloat distanceTorus(vec3 p, vec2 s)\n{ return length(vec2(length(p.xz) - s.x, p.y)) - s.y; }\nfloat distanceCylinder(vec3 p, vec2 s, float e)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - s + e;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - e;\n}\nfloat distanceCone(vec3 p, float a, float h)\n{\n    return max(cos(a)*length(p.xz) + sin(a)*(p.y-h), -h-p.y);\n}\nfloat distanceEllipsoid(vec3 p, vec3 s)\n{\n    float k0 = length(p / s);\n    float k1 = length(p / (s * s));\n    return k0 * (k0 - 1.) / k1;\n}\nfloat distanceBoxFrame(vec3 p, vec3 s, float f)\n{     \n    vec3 a = abs(p) - s;\n    vec3 b = abs(a + f) - f;\n    return min(min(\n        length(max(vec3(a.x,b.y,b.z),0.)) + min(max(a.x,max(b.y,b.z)),0.),\n        length(max(vec3(b.x,a.y,b.z),0.)) + min(max(b.x,max(a.y,b.z)),0.)),\n        length(max(vec3(b.x,b.y,a.z),0.)) + min(max(b.x,max(b.y,a.z)),0.));\n}\n\n// combine operators\nvec2 combineUnion(vec2 d1, vec2 d2)     { return d1.x  < d2.x ? d1 : d2; }\nvec2 combineSubtract(vec2 d1, vec2 d2)  { return -d1.x > d2.x ? d1 : d2; }\nvec2 combineIntersect(vec2 d1, vec2 d2) { return d1.x  > d2.x ? d1 : d2; }\n\nvec2 raycast(vec3 position, vec3 direction, bool isReflection)\n{\n    // cast the ray\n    const float range = 1e3;\n    const float minRange = .1;\n    const float accuracy = .001;\n    float total = minRange;\n    float nearestDistance = 1e9;\n    vec2 nearestResult = vec2(1e4);\n    for (int i = (isReflection ? maxReflectionIterations : maxRaycastIterations); accuracy < nearestDistance && --i > 0;)\n    {\n        vec2 distanceResult = sceneDistance(position + total * direction);\n        total += distanceResult.x;\n        if (distanceResult.x * nearestResult.x * nearestResult.x < nearestDistance * total * total)\n        {\n            // fix flickering pixel around edges\n            nearestDistance = distanceResult.x;\n            nearestResult = vec2(total, distanceResult.y);\n        }\n        if (total > range)\n            return vec2(range, -1);\n    }\n    \n    return nearestResult;\n}\n\nfloat getShadow(vec3 position, vec3 direction, float softness, float range)\n{\n    if (!enableShadows)\n        return 1.;\n\n    // cast the shadow\n    const float minRange = .1;\n    const float accuracy = .001;\n    float distanceLast = 1e9;\n    softness = max(softness, .001);\n    \n    float shadow = 1.;\n    float total = minRange;\n    for (int i = 0; accuracy < shadow && ++i < maxShadowIterations;)\n    {\n        // get estimated shadow distance\n        float distance = sceneDistance(position + total * direction).x;\n        float x = distance * distance / (2. * distanceLast);\n        float y = distance * distance - x * x;\n        if (y > 0. && total - x > accuracy)\n            shadow = min(shadow, sqrt(y) / (total - x) / softness);\n\n        // update distance\n        distanceLast = distance;\n        total += distance;\n        if (total > range)\n            return smoothstep(0., 1., shadow);\n    }\n    return 0.;\n}\n\n\nvec3 getNormal(vec3 p)\n{\n    // faster to compile normals\n    const float accuracy = .0001;\n    vec3 t=vec3(0);\n    for(int j=0;j<4;++j){\n    vec3 e=accuracy*(j==3?vec3(1):vec3(j==0?1:-1,j==1?1:-1,j==2?1:-1));\nt+=e*sceneDistance(p+e).x;}\n    return normalize(t);\n}\n\nfloat getAmbientOcclusion(vec3 position, vec3 normal)\n{\n    if (!enableAmbientOcclusion)\n        return 1.;\n\n    // cast the ambient occusion\n    const float strength = .2;\n    const float scale = .2;\n    const int stepCount = 5;\n\tfloat occlusion = 0.;\n    for (int i = 0; ++i < stepCount;)\n    {\n        float d = scale * float(i);\n        float distance = sceneDistance(position + d * normal).x;\n        occlusion += max((d - distance) / d, 0.); \n    }\n    return max(1. - occlusion * strength, 0.);\n}\n\nvec3 getAmbientLight(vec3 lightColor, vec3 position, vec3 direction, vec3 normal, vec3 diffuseColor, vec3 specularColor, float specularPower)\n{\n    if (!enableAmbientLights)\n        return vec3(0);\n\n    return lightColor * diffuseColor;\n}\n\nvec3 getDirectionalLight(vec3 lightDirection, vec3 lightColor, float lightSoftness, bool castShadow, vec3 position, vec3 direction, vec3 normal, vec3 diffuseColor, vec3 specularColor, float specularPower)\n{\n    float diffuseDot = dot(lightDirection, normal);\n    if (diffuseDot < 0. || !enableDirectionalLights)\n        return vec3(0);\n\n    // apply shadow and shading\n    float shadowAmount = castShadow ? getShadow(position, lightDirection, lightSoftness, 1e3) : 1.;\n    vec3 diffuse = (diffuseDot * shadowAmount) * lightColor * diffuseColor;\n    if (!enableSpecular || specularPower == 0.)\n        return diffuse;\n\n    // apply specular\n    vec3 reflectDirection = reflect(direction, normal);\n    float specularDot = pow(max(dot(lightDirection, reflectDirection), 0.), 1. + specularPower);\n    vec3 specular = (specularDot * shadowAmount) * lightColor * specularColor;\n    return diffuse + specular;\n}\n\n\nvec3 getPointLight(vec3 lightPosition, vec3 lightColor, float lightStrength, float lightSoftness, bool castShadow, vec3 position, vec3 direction, vec3 normal, vec3 diffuseColor, vec3 specularColor, float specularPower)\n{\n    // get direction to light\n    vec3 delta = lightPosition - position;\n    float distance = length(delta);\n    vec3 lightDirection = delta / distance;\n\n    // check if no shadow\n    float diffuseDot = dot(lightDirection, normal);\n    if (diffuseDot < 0. || !enableDirectionalLights)\n        return vec3(0);\n\n    // apply shadow and shading\n    float shadowAmount = castShadow ? getShadow(position, lightDirection, lightSoftness, distance) : 0.;\n    vec3 diffuse = (diffuseDot * shadowAmount) * lightColor * diffuseColor;\n    float falloff = min(lightStrength * lightStrength / distance / distance, 1.);\n    if (!enableSpecular || specularPower == 0.)\n        return diffuse * falloff;\n\n    // apply specular\n    vec3 reflectDirection = reflect(direction, normal);\n    float specularDot = pow(max(dot(lightDirection, reflectDirection), 0.), 1. + specularPower);\n    vec3 specular = (specularDot * shadowAmount) * lightColor * specularColor;\n    return (diffuse + specular) * falloff;\n}\n  \nvec2 sceneDistance(vec3 pos)\n{\n    vec2 d = vec2(1e9);\n    d = combineUnion(d, vec2(distanceCylinder(pos - vec3(0.000, -1000.000, 0.000), vec2(60.000, 1000.000), 0.500), 2.0));\n    d = combineUnion(d, vec2(distanceSphere(pos - vec3(-13.540, 12.892, 19.252), 12.892), 4.0));\n    d = combineUnion(d, vec2(distanceBox(pos - vec3(18.851, 8.314, 38.089), vec3(6.659, 8.314, 3.726), 0.386), 5.0));\n    d = combineUnion(d, vec2(distanceBox(pos - vec3(17.882, 20.367, 41.127), vec3(4.654, 3.739, 3.632), 0.219), 6.0));\n    d = combineUnion(d, vec2(distanceBox(pos - vec3(16.394, 28.057, 40.398), vec3(3.602, 3.951, 3.345), 0.089), 7.0));\n    d = combineUnion(d, vec2(distanceSphere(pos - vec3(16.210, 35.142, 40.576), 3.133), 8.0));\n    d = combineUnion(d, vec2(distanceCylinder(pos - vec3(-3.255, 6.169, -18.397), vec2(8.266, 6.169), 0.075), 9.0));\n    d = combineUnion(d, vec2(distanceBox(pos - vec3(-2.598, 14.133, -16.809), vec3(3.482, 1.794, 3.139), 0.240), 10.0));\n    d = combineUnion(d, vec2(distanceCylinder(pos - vec3(-3.073, 17.880, -15.599), vec2(2.520, 1.953), 0.429), 11.0));\n    d = combineUnion(d, vec2(distanceCylinder(pos - vec3(-38.595, 13.197, 6.349), vec2(13.335, 13.197), 0.092), 12.0));\n    d = combineUnion(d, vec2(distanceSphere(pos - vec3(-43.065, 36.220, 9.768), 9.826), 13.0));\n    d = combineUnion(d, vec2(distanceBox(pos - vec3(-17.205, 3.289, 35.662), vec3(2.773, 3.289, 2.429), 0.406), 14.0));\n    d = combineUnion(d, vec2(distanceCylinder(pos - vec3(-22.925, 2.917, -37.059), vec2(8.609, 2.917), 0.459), 15.0));\n    d = combineUnion(d, vec2(distanceBox(pos - vec3(-21.462, 6.865, -36.547), vec3(2.490, 1.031, 2.106), 0.240), 16.0));\n    d = combineUnion(d, vec2(distanceBox(pos - vec3(35.402, 8.886, -8.586), vec3(9.928, 8.886, 7.947), 0.331), 17.0));\n    d = combineUnion(d, vec2(distanceBox(pos - vec3(40.063, 22.214, -8.062), vec3(6.625, 4.442, 4.006), 0.291), 18.0));\n    d = combineUnion(d, vec2(distanceSphere(pos - vec3(42.883, 32.812, -9.959), 6.157), 19.0));\n    d = combineUnion(d, vec2(distanceBox(pos - vec3(-46.209, 2.265, -11.847), vec3(4.518, 2.265, 3.010), 0.361), 20.0));\n    d = combineUnion(d, vec2(distanceCylinder(pos - vec3(-47.907, 8.906, -13.685), vec2(4.793, 4.375), 0.287), 21.0));\n    d = combineUnion(d, vec2(distanceCylinder(pos - vec3(-46.990, 15.833, -12.723), vec2(3.161, 2.552), 0.468), 22.0));\n    d = combineUnion(d, vec2(distanceCylinder(pos - vec3(-47.374, 19.613, -11.907), vec2(2.503, 1.229), 0.473), 23.0));\n    d = combineUnion(d, vec2(distanceBox(pos - vec3(19.362, 2.470, 22.410), vec3(4.434, 2.470, 3.604), 0.259), 24.0));\n    d = combineUnion(d, vec2(distanceCylinder(pos - vec3(19.933, 6.815, 24.091), vec2(3.368, 1.875), 0.083), 25.0));\n    d = combineUnion(d, vec2(distanceBox(pos - vec3(18.109, 4.656, -19.523), vec3(4.540, 4.656, 2.479), 0.452), 26.0));\n    d = combineUnion(d, vec2(distanceCylinder(pos - vec3(17.198, 11.481, -20.542), vec2(3.046, 2.170), 0.163), 27.0));\n    d = combineUnion(d, vec2(distanceBox(pos - vec3(16.676, 15.425, -20.478), vec3(1.553, 1.775, 0.944), 0.134), 28.0));\n    d = combineUnion(d, vec2(distanceSphere(pos - vec3(7.089, 3.652, 11.667), 3.652), 29.0));\n    d = combineUnion(d, vec2(distanceCylinder(pos - vec3(-1.834, 3.296, -33.286), vec2(6.690, 3.296), 0.310), 30.0));\n    d = combineUnion(d, vec2(distanceBox(pos - vec3(-1.413, 9.996, -31.936), vec3(2.900, 3.404, 1.569), 0.038), 31.0));\n    d = combineUnion(d, vec2(distanceBox(pos - vec3(-0.728, 15.338, -31.453), vec3(1.614, 1.938, 1.375), 0.366), 32.0));\n    d = combineUnion(d, vec2(distanceBox(pos - vec3(23.881, 5.455, 10.980), vec3(4.257, 5.455, 2.912), 0.288), 33.0));\n    d = combineUnion(d, vec2(distanceBox(pos - vec3(22.026, 12.867, 12.222), vec3(2.925, 1.957, 1.659), 0.446), 34.0));\n    d = combineUnion(d, vec2(distanceCylinder(pos - vec3(23.385, 16.025, 11.778), vec2(2.990, 1.201), 0.389), 35.0));\n    d = combineUnion(d, vec2(distanceBox(pos - vec3(-39.781, 2.677, -23.828), vec3(5.096, 2.677, 4.992), 0.190), 36.0));\n    d = combineUnion(d, vec2(distanceCylinder(pos - vec3(-42.046, 6.750, -23.565), vec2(5.475, 1.396), 0.248), 37.0));\n    d = combineUnion(d, vec2(distanceCylinder(pos - vec3(-43.120, 9.321, -22.479), vec2(3.227, 1.175), 0.117), 38.0));\n    d = combineUnion(d, vec2(distanceBox(pos - vec3(19.231, 13.261, -40.233), vec3(9.857, 13.261, 9.260), 0.156), 39.0));\n    d = combineUnion(d, vec2(distanceSphere(pos - vec3(16.304, 33.630, -39.547), 7.108), 40.0));\n    d = combineUnion(d, vec2(distanceCylinder(pos - vec3(-26.274, 4.950, -17.369), vec2(7.764, 4.950), 0.326), 41.0));\n    d = combineUnion(d, vec2(distanceBox(pos - vec3(-24.204, 13.253, -16.541), vec3(3.231, 3.352, 3.185), 0.118), 42.0));\n    d = combineUnion(d, vec2(distanceBox(pos - vec3(-22.675, 19.087, -17.076), vec3(2.187, 2.481, 1.451), 0.265), 43.0));\n    d = combineUnion(d, vec2(distanceBox(pos - vec3(-0.072, 3.678, 30.631), vec3(3.351, 3.678, 3.193), 0.365), 44.0));\n    d = combineUnion(d, vec2(distanceBox(pos - vec3(-0.741, 8.767, 30.176), vec3(1.885, 1.411, 1.491), 0.100), 45.0));\n    d = combineUnion(d, vec2(distanceBox(pos - vec3(18.215, 1.585, 5.102), vec3(1.516, 1.585, 1.157), 0.203), 46.0));\n    d = combineUnion(d, vec2(distanceCylinder(pos - vec3(-12.592, 1.660, -28.562), vec2(4.769, 1.660), 0.133), 47.0));\n    d = combineUnion(d, vec2(distanceBox(pos - vec3(-12.053, 4.085, -29.204), vec3(1.579, 0.765, 1.437), 0.384), 48.0));\n    d = combineUnion(d, vec2(distanceCylinder(pos - vec3(31.493, 5.707, 26.149), vec2(6.424, 5.707), 0.072), 49.0));\n    d = combineUnion(d, vec2(distanceSphere(pos - vec3(31.900, 15.385, 26.955), 3.972), 50.0));\n    d = combineUnion(d, vec2(distanceCylinder(pos - vec3(-13.148, 4.810, 46.174), vec2(7.347, 4.810), 0.217), 51.0));\n    d = combineUnion(d, vec2(distanceBox(pos - vec3(-12.103, 12.677, 43.934), vec3(4.148, 3.057, 3.720), 0.231), 52.0));\n    d = combineUnion(d, vec2(distanceBox(pos - vec3(-12.010, 17.556, 43.241), vec3(2.888, 1.822, 1.682), 0.175), 53.0));\n    d = combineUnion(d, vec2(distanceCylinder(pos - vec3(-11.185, 20.167, 43.793), vec2(2.198, 0.788), 0.285), 54.0));\n    return d;\n}\n\nvoid materialInfo(float material, vec3 position, vec3 direction, out vec3 diffuse, out vec3 specular, out float specularPower, out float reflectivity, out float roughness)\n{\n    diffuse = specular = vec3(1);\n    specularPower = reflectivity = roughness = 0.;\n\n    if (material < 2.5) // material 2\n    {\n    diffuse = vec3(1.000, 1.000, 1.000);\n    specular = vec3(1.000, 1.000, 1.000);\n    specularPower = 1.000;\n    roughness = 0.05;\n    }\n    else if (material < 4.5) // material 4\n    {\n    diffuse = vec3(0.784, 0.360, 0.336);\n    specular = vec3(0.353, 0.888, 0.722);\n    specularPower = 39.771;\n    reflectivity = 0.681;\n    }\n    else if (material < 5.5) // material 5\n    {\n    diffuse = vec3(0.289, 0.230, 0.508);\n    specular = vec3(0.883, 0.458, 0.742);\n    specularPower = 45.595;\n    }\n    else if (material < 6.5) // material 6\n    {\n    diffuse = vec3(0.512, 0.241, 0.690);\n    specular = vec3(0.900, 0.490, 0.617);\n    specularPower = 19.602;\n    roughness = 0.016;\n    }\n    else if (material < 7.5) // material 7\n    {\n    diffuse = vec3(0.353, 0.312, 0.690);\n    specular = vec3(0.105, 0.928, 0.086);\n    specularPower = 74.871;\n    }\n    else if (material < 8.5) // material 8\n    {\n    diffuse = vec3(0.234, 0.989, 0.190);\n    specular = vec3(0.847, 0.334, 0.527);\n    specularPower = 75.620;\n    roughness = 0.029;\n    }\n    else if (material < 9.5) // material 9\n    {\n    diffuse = vec3(0.998, 0.926, 0.450);\n    specular = vec3(0.357, 0.067, 0.678);\n    specularPower = 95.442;\n    reflectivity = 0.821;\n    }\n    else if (material < 10.5) // material 10\n    {\n    diffuse = vec3(0.791, 0.488, 0.286);\n    specular = vec3(0.755, 0.820, 0.892);\n    specularPower = 4.661;\n    }\n    else if (material < 11.5) // material 11\n    {\n    diffuse = vec3(0.434, 0.759, 0.554);\n    specular = vec3(0.241, 0.091, 0.586);\n    specularPower = 98.599;\n    roughness = 0.002;\n    }\n    else if (material < 12.5) // material 12\n    {\n    diffuse = vec3(0.854, 0.481, 0.360);\n    specular = vec3(0.140, 0.168, 0.463);\n    specularPower = 98.449;\n    }\n    else if (material < 13.5) // material 13\n    {\n    diffuse = vec3(0.070, 0.661, 0.679);\n    }\n    else if (material < 14.5) // material 14\n    {\n    diffuse = vec3(0.152, 0.271, 0.929);\n    specular = vec3(0.327, 0.330, 0.535);\n    specularPower = 91.917;\n    roughness = 0.019;\n    }\n    else if (material < 15.5) // material 15\n    {\n    diffuse = vec3(0.977, 0.586, 0.540);\n    specular = vec3(0.520, 0.130, 0.246);\n    specularPower = 26.322;\n    reflectivity = 0.675;\n    roughness = 0.015;\n    }\n    else if (material < 16.5) // material 16\n    {\n    diffuse = vec3(0.375, 0.108, 0.489);\n    specular = vec3(0.510, 0.774, 0.636);\n    specularPower = 7.429;\n    roughness = 0.051;\n    }\n    else if (material < 17.5) // material 17\n    {\n    diffuse = vec3(0.693, 0.182, 0.022);\n    specular = vec3(0.892, 0.701, 0.384);\n    specularPower = 26.940;\n    }\n    else if (material < 18.5) // material 18\n    {\n    diffuse = vec3(0.718, 0.087, 0.459);\n    specular = vec3(0.372, 0.466, 0.383);\n    specularPower = 10.635;\n    }\n    else if (material < 19.5) // material 19\n    {\n    diffuse = vec3(0.568, 0.273, 0.838);\n    specular = vec3(0.648, 0.787, 0.862);\n    specularPower = 51.580;\n    }\n    else if (material < 20.5) // material 20\n    {\n    diffuse = vec3(0.251, 0.114, 0.278);\n    specular = vec3(0.189, 0.706, 0.972);\n    specularPower = 36.591;\n    roughness = 0.028;\n    }\n    else if (material < 21.5) // material 21\n    {\n    diffuse = vec3(0.171, 0.516, 0.162);\n    specular = vec3(0.043, 0.475, 0.842);\n    specularPower = 33.898;\n    roughness = 0.017;\n    }\n    else if (material < 22.5) // material 22\n    {\n    diffuse = vec3(0.525, 0.696, 0.018);\n    specular = vec3(0.480, 0.829, 0.299);\n    specularPower = 22.185;\n    }\n    else if (material < 23.5) // material 23\n    {\n    diffuse = vec3(0.583, 0.467, 0.632);\n    }\n    else if (material < 24.5) // material 24\n    {\n    diffuse = vec3(0.809, 0.354, 0.092);\n    specular = vec3(0.015, 0.442, 0.470);\n    specularPower = 97.282;\n    reflectivity = 0.725;\n    }\n    else if (material < 25.5) // material 25\n    {\n    diffuse = vec3(0.448, 0.844, 0.164);\n    specular = vec3(0.310, 0.444, 0.857);\n    specularPower = 26.815;\n    roughness = 0.009;\n    }\n    else if (material < 26.5) // material 26\n    {\n    diffuse = vec3(0.929, 0.742, 0.232);\n    specular = vec3(0.354, 0.704, 0.438);\n    specularPower = 84.774;\n    roughness = 0.036;\n    }\n    else if (material < 27.5) // material 27\n    {\n    diffuse = vec3(0.076, 0.316, 0.805);\n    specular = vec3(0.153, 0.397, 0.834);\n    specularPower = 36.428;\n    roughness = 0.085;\n    }\n    else if (material < 28.5) // material 28\n    {\n    diffuse = vec3(0.864, 0.760, 0.806);\n    specular = vec3(0.188, 0.136, 0.656);\n    specularPower = 4.874;\n    roughness = 0.036;\n    }\n    else if (material < 29.5) // material 29\n    {\n    diffuse = vec3(0.273, 0.654, 0.008);\n    roughness = 0.084;\n    }\n    else if (material < 30.5) // material 30\n    {\n    diffuse = vec3(0.909, 0.607, 0.947);\n    }\n    else if (material < 31.5) // material 31\n    {\n    diffuse = vec3(0.075, 0.956, 0.499);\n    }\n    else if (material < 32.5) // material 32\n    {\n    diffuse = vec3(0.439, 0.567, 0.563);\n    specular = vec3(0.073, 0.921, 0.264);\n    specularPower = 30.362;\n    roughness = 0.014;\n    }\n    else if (material < 33.5) // material 33\n    {\n    diffuse = vec3(0.162, 0.754, 0.990);\n    specular = vec3(0.658, 0.605, 0.129);\n    specularPower = 62.460;\n    roughness = 0.094;\n    }\n    else if (material < 34.5) // material 34\n    {\n    diffuse = vec3(0.379, 0.533, 0.819);\n    specular = vec3(0.649, 0.213, 0.743);\n    specularPower = 31.169;\n    reflectivity = 0.532;\n    }\n    else if (material < 35.5) // material 35\n    {\n    diffuse = vec3(0.914, 0.138, 0.424);\n    specular = vec3(0.281, 0.382, 0.448);\n    specularPower = 4.027;\n    roughness = 0.073;\n    }\n    else if (material < 36.5) // material 36\n    {\n    diffuse = vec3(0.268, 0.767, 0.540);\n    specular = vec3(0.501, 0.834, 0.476);\n    specularPower = 76.760;\n    roughness = 0.072;\n    }\n    else if (material < 37.5) // material 37\n    {\n    diffuse = vec3(0.928, 0.412, 0.801);\n    specular = vec3(0.393, 0.951, 0.654);\n    specularPower = 80.531;\n    }\n    else if (material < 38.5) // material 38\n    {\n    diffuse = vec3(0.854, 0.438, 0.621);\n    specular = vec3(0.231, 0.925, 0.649);\n    specularPower = 70.086;\n    }\n    else if (material < 39.5) // material 39\n    {\n    diffuse = vec3(0.003, 0.059, 0.403);\n    specular = vec3(0.564, 0.403, 0.036);\n    specularPower = 43.922;\n    roughness = 0.091;\n    }\n    else if (material < 40.5) // material 40\n    {\n    diffuse = vec3(0.719, 0.031, 0.394);\n    specular = vec3(0.434, 0.225, 0.648);\n    specularPower = 54.438;\n    }\n    else if (material < 41.5) // material 41\n    {\n    diffuse = vec3(0.918, 0.749, 0.086);\n    reflectivity = 0.885;\n    }\n    else if (material < 42.5) // material 42\n    {\n    diffuse = vec3(0.446, 0.046, 0.299);\n    specular = vec3(0.614, 0.660, 0.473);\n    specularPower = 35.002;\n    roughness = 0.028;\n    }\n    else if (material < 43.5) // material 43\n    {\n    diffuse = vec3(0.023, 0.844, 0.016);\n    specular = vec3(0.934, 0.684, 0.609);\n    specularPower = 80.289;\n    roughness = 0.059;\n    }\n    else if (material < 44.5) // material 44\n    {\n    diffuse = vec3(0.902, 0.318, 0.891);\n    specular = vec3(0.265, 0.905, 0.560);\n    specularPower = 5.755;\n    roughness = 0.036;\n    }\n    else if (material < 45.5) // material 45\n    {\n    diffuse = vec3(0.417, 0.817, 0.315);\n    specular = vec3(0.987, 0.795, 0.493);\n    specularPower = 17.932;\n    roughness = 0.059;\n    }\n    else if (material < 46.5) // material 46\n    {\n    diffuse = vec3(0.075, 0.141, 0.217);\n    specular = vec3(0.338, 0.645, 0.064);\n    specularPower = 35.961;\n    }\n    else if (material < 47.5) // material 47\n    {\n    diffuse = vec3(0.792, 0.576, 0.395);\n    specular = vec3(0.564, 0.051, 0.415);\n    specularPower = 18.434;\n    }\n    else if (material < 48.5) // material 48\n    {\n    diffuse = vec3(0.212, 0.218, 0.372);\n    specular = vec3(0.879, 0.226, 0.839);\n    specularPower = 52.305;\n    roughness = 0.014;\n    }\n    else if (material < 49.5) // material 49\n    {\n    diffuse = vec3(0.360, 0.323, 0.044);\n    specular = vec3(0.311, 0.822, 0.700);\n    specularPower = 26.318;\n    }\n    else if (material < 50.5) // material 50\n    {\n    diffuse = vec3(0.914, 0.962, 0.956);\n    specular = vec3(0.458, 0.366, 0.248);\n    specularPower = 54.191;\n    roughness = 0.077;\n    }\n    else if (material < 51.5) // material 51\n    {\n    diffuse = vec3(0.826, 0.757, 0.594);\n    specular = vec3(0.686, 0.451, 0.832);\n    specularPower = 27.426;\n    }\n    else if (material < 52.5) // material 52\n    {\n    diffuse = vec3(0.491, 0.521, 0.667);\n    }\n    else if (material < 53.5) // material 53\n    {\n    diffuse = vec3(0.076, 0.614, 0.060);\n    specular = vec3(0.050, 0.920, 0.011);\n    specularPower = 89.439;\n    roughness = 0.028;\n    }\n    else if (material < 54.5) // material 54\n    {\n    diffuse = vec3(0.855, 0.766, 0.029);\n    specular = vec3(0.042, 0.678, 0.674);\n    specularPower = 7.370;\n    roughness = 0.091;\n    }\n}\n\nvec3 getColor(vec3 startPosition, vec3 direction)\n{\n    vec3 passColor = vec3(1);\n    vec3 finalColor = vec3(0);\n    int maxReflects = 3;\n    for (int reflectCount = 0; ++reflectCount <= maxReflects;)\n    {\n        // raycast to find hit info\n        vec2 raycastResult = raycast(startPosition, direction, reflectCount > 1);\n        float hitDistance = raycastResult.x;\n        float hitMaterial = raycastResult.y;\n        \n        // get fog color\n        const vec3 fogColor1 = vec3(1);\n        const vec3 fogColor2 = vec3(0.05, 0.1, 0.175);\n        const vec3 fogFadeDirection = vec3(0.000, 1.000, 0.000);\n        float fog = dot(direction, fogFadeDirection);\n        fog = (fog - (-0.300)) / (0.600 - (-0.300));\n        vec3 fogColor = mix(fogColor2, fogColor1, fog);\n\n        // stop if nothing was hit\n        if (hitMaterial < 0.)\n        {\n            finalColor += fogColor * passColor;\n            break;\n        }\n        \n        // material info\n        vec3 position = startPosition + hitDistance * direction;\n        vec3 diffuse, specular;\n        float specularPower, reflectivity, roughness;\n        if (enableMaterials)\n            materialInfo(hitMaterial, position, direction, diffuse, specular, specularPower, reflectivity, roughness);\n\n        // hit normal\n        vec3 normal = getNormal(position);\n        normal += noise3(position * 20.) * roughness;\n        normal = normalize(normal);\n\n        // lighting\n        vec3 color = vec3(0);\n        color += getAmbientLight(vec3(0.003, 0.004, 0.005), position, direction, normal, diffuse, specular, specularPower);\n        color += getDirectionalLight(vec3(0.408, 0.816, -0.408), vec3(0.703, 0.637, 0.597), 0.100, true, position, direction, normal, diffuse, specular, specularPower);\n        color += getPointLight(vec3(0.000, 10.000, 0.000), vec3(0., 0.6, 0.1), 20.000, 0.100, true, position, direction, normal, diffuse, specular, specularPower);\n\n        // ambient occlusion\n        color *= getAmbientOcclusion(position, normal);\n        \n        // blend fog\n        const float fogStart = 900.000;\n        const float fogDistance = 100.000;\n        float fogPercent = clamp((hitDistance - fogStart) / fogDistance, 0., 1.);\n        color *= 1. - reflectivity;\n        finalColor += passColor * mix(color, fogColor, fogPercent);\n        \n        // check if reflecting\n        if (!enableReflections || reflectivity == 0.)\n            break;\n        \n        // apply reflections\n        startPosition = position;\n        direction = reflect(direction, normal);\n        passColor *= diffuse * reflectivity * (1. - fogPercent);\n    }\n    \n    // gamma\n    const float gamma = 0.4545;\n    return pow(clamp(finalColor, 0., 1.), vec3(gamma));\n}","name":"Image","description":"","type":"image"}]}