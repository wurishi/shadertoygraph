{"ver":"0.1","info":{"id":"3tGcDR","date":"1610750220","viewed":226,"name":"Waiting for injection in 2021 !","username":"sylvain69780","description":"Hopefully 2021 will be the end of the COVID ?","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["covid","syringe"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Waiting for injection in 2021 !\n    -------------------------------\n    \n    Hopefully 2021 will be the end of the COVID ?\n    \n    Related references\n    \n    RayMarching starting point - BigWIngs\n    https://shadertoy.com/view/WtGXDD\n\n    Space curvature - iapafoto (font texture)\n    https://www.shadertoy.com/view/tdyBDh\n    \n    Distance functions - IQ\n    https://iquilezles.org/articles/distfunctions\n    https://iquilezles.org/articles/distfunctions2d    \n    \n    Ray Intersection Functions - IQ\n    https://www.shadertoy.com/playlist/l3dXRf\n    https://iquilezles.org/articles/intersectors\n    \n*/\n\n#define MAX_STEPS 100\n#define MAX_DIST 10.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n#define AA\n\n#define ANIME_PISTON S(2.0,3.0,time)-S(3.5,5.0,time)\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://www.shadertoy.com/view/4lyfzw\nvec2 opRevolution( in vec3 p, float w )\n{\n    return vec2( length(p.xz) - w, p.y );\n}\nfloat opExtrussion( in vec3 p, in float sdf, in float h) {\n    vec2 w = vec2(sdf, abs(p.z) - h);\n  \treturn min(max(w.x,w.y),0.) + length(max(w,0.));\n}\n\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdRoundedX( in vec2 p, in float w, in float r )\n{\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\n// https://www.shadertoy.com/playlist/l3dXRf\n// https://iquilezles.org/articles/intersectors\n// cylinder defined by extremes pa and pb, and radious ra\nvec4 cylIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, float ra )\n{\n    vec3 ca = pb-pa;\n    vec3 oc = ro-pa;\n    float caca = dot(ca,ca);\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = caca - card*card;\n    float b = caca*dot( oc, rd) - caoc*card;\n    float c = caca*dot( oc, oc) - caoc*caoc - ra*ra*caca;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec4(-1.0); //no intersection\n    h = sqrt(h);\n    float t = (-b-h)/a;\n    // body\n    float y = caoc + t*card;\n    if( y>0.0 && y<caca ) return vec4( t, (oc+t*rd-ca*y/caca)/ra );\n    // caps\n    t = (((y<0.0)?0.0:caca) - caoc)/card;\n    if( abs(b+a*t)<h ) return vec4( t, ca*sign(y)/caca );\n    return vec4(-1.0); //no intersection\n}\n\n#define dot2(x) dot(x,x)\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// -- Text ------------------------------------------------\n// Adapted from [iapafoto] https://www.shadertoy.com/view/tdyBDh\n// --------------------------------------------------------\n\nint[] gtxt = int[] (50,48,50,48); // 2021\n\nfloat sdFont(in vec2 p, in int c) {\n    vec2 uv = (p + vec2(float(c%16), float(15-c/16)) + .5)/16.;\n    return max(max(abs(p.x) - .25, max(p.y - .35, -.38 - p.y)), textureLod(iChannel2, uv, 0.).w - 127./255.);\n}\n\nconst float letterSpacing=2.45;\n\nfloat sdMessage2D(in vec2 p, in int[4] txt) { \n \tfloat d = 99., w = letterSpacing; // letter width  spacing\n    for (int id = 0; id<4; id++){\n    \td = min(d, sdFont(p, txt[id]));   \n    \tp.x -= w; \n    }\n    return d-.015;\n}\n\n// extrussion replaced by Cylinder mapping\nfloat sdMessage3D(in vec3 p, in int[4] txt, in float scale, in float h) { \n    return opExtrussion(p, sdMessage2D(p.xy/scale, txt)*scale, h);\n}\n\nfloat sdPiston(vec3 p,float l) {\n    float pusher = sdCappedCylinder(p,0.3,0.01)-0.03;\n    float pilar=opExtrussion(p.yzx-vec3(0.0,0.0,l),sdRoundedX(p.yz,0.20,0.02),l);\n    return min(pusher,pilar);\n}\n\nfloat sdSyringeBody(vec3 p) {\n    float bottom = sdCappedCylinder(p,0.35,0.01)-0.03;\n    bottom=max(bottom,-(length(p.yz)-0.18));\n    float end = sdCappedCone(p.yxz-vec3(0.0,2.9,0.0),0.05,0.25,0.08)-0.01;\n    end = min(end,sdCappedCylinder(p-vec3(3.0,0.0,0.0),0.08,0.10));\n    float d = min(bottom,end);\n    return d;\n}\n\nfloat sdGraduations(vec3 p) {\n    float r=0.25;\n    p.x-=0.8;\n    // fold on a Cylinder along x\n    float d = abs(length(p.yz)-r)-0.001;\n    // box with the tube\n    if ( d > 0.1 ) return d;\n    float a=atan(p.y,p.z);\n    vec2 uv = vec2(p.x,a*r);\n    float scale=0.2;\n    // let's try some animation of numbers\n    float grad1 = letterSpacing*scale;\n    float grad2 = letterSpacing*scale/5.0;\n    float time=mod(T,6.0);\n    float atime = S(0.0,2.0,time);\n    float jump=0.0;\n    if ( uv.x > letterSpacing*scale*2.5 && uv.x < letterSpacing*scale*3.5 ) {\n        jump= atime > 0.5 ? (atime-1.0)*2.0 : atime*2.0;\n    }\n    gtxt[3]= time > 0.5 && time < 5.0 ? 49 : 48;   \n    float dtxt = sdMessage2D((uv-vec2(0.0,jump))/scale, gtxt)*scale;\n    uv.x -= round(uv.x/grad1)*grad1;\n    float dgrad = sdBox(uv-vec2(0.0,0.2+abs(jump)),vec2(0.01,0.1));\n    dgrad = min(dgrad,sdBox(uv-vec2(clamp(round(uv.x/grad2),1.0,2.0)*grad2,0.2+0.05),vec2(0.01,0.05)));\n    dgrad = min(dgrad,sdBox(uv-vec2(clamp(round(uv.x/grad2),-2.0,-1.0)*grad2,0.2+0.05),vec2(0.01,0.05)));\n    float dtxt3d = max(min(dtxt,dgrad),d);\n    return max(dtxt3d-0.003,max(p.x-2.0,-0.8-p.x));  \n}\n\nfloat sdNeedleBase(vec3 p) {\n    float d = sdCappedCylinder(p-vec3(3.1,0.0,0.0),0.15,0.01)-0.01;\n    d = min(d,sdCappedCylinder(p-vec3(3.19,0.0,0.0),0.09,0.07)-0.01);\n    float end = sdCappedCone(p.yxz-vec3(0.0,3.35,0.0),0.1,0.08,0.04);\n    d = min(d,end);\n    return d;\n}\n\nfloat sdNeedle(vec3 p) {\n    float dPlan=-dot(p,normalize(vec3(1.0,0.0,1.0)))+3.0;\n    return max(abs(sdCappedCylinder(p-vec3(4.30,0.0,0.0),0.015,0.9))-0.002, -dPlan);   \n}\n\nvec2 GetDistAndMat(vec3 p) {\n    p.x-=-1.5;\n    float d=sdSyringeBody(p-vec3(0.0,0.0,0.0));\n    float m=0.0;\n    float time=mod(T,6.0);\n    float atime = ANIME_PISTON;\n    float l=1.5;\n    float piston=sdPiston(p-vec3(-2.6+2.2*atime,0.0,0.0),l);\n    d = min(d,piston);\n    float graduations=sdGraduations(p);\n    d = min(d,graduations);\n    float joint = sdCappedCylinder(p-vec3(-2.6+2.0*l+2.2*atime,0.0,0.0),0.19,0.05)-0.03;\n    if ( joint < d ) { d=joint; m=1.0; };\n    float needleBase=sdNeedleBase(p);\n    if ( needleBase < d ) { d=needleBase; m=2.0; };\n    float needle=sdNeedle(p);\n    if ( needle < d ) { d=needle; m=3.0; };\n   \treturn vec2(d,m);\n}\n\nfloat GetDist(vec3 p) {\n   \treturn GetDistAndMat(p).x;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<24; i++ )\n    {\n\t\tfloat h = GetDist( ro + rd*t );\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));    \n    return normalize(n);\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\n// BigWings's template\n// https://www.youtube.com/watch?v=PBxuVlp7nuM\n// https://www.shadertoy.com/view/WtGXDD\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(f,vec3(0,1,0))),\n        u = cross(r,f),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec3 col = vec3(0);\n    vec3 tcol = vec3(0);\n    vec3 ro = vec3(0, 0.5, 4);\n    if ( iMouse.x > 10.0 ) {\n        vec2 m = iMouse.xy/iResolution.xy-0.5;\n        ro.yz *= Rot(-m.y*3.14);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        float time=mod(T,12.0);\n        float atime = S(3.0,6.0,time)-S(9.0,12.0,time);\n        ro.z-=(2.0-atime*2.0);\n        ro.xz *= Rot(-atime*6.28);\n    }\n\n#ifdef AA\n\tfor (float dx = 0.; dx <= 1.; dx++)\n\t\tfor (float dy = 0.; dy <= 1.; dy++) {\n\t\t\tvec2 uv = (fragCoord + vec2(dx, dy) * .5 - .5 * iResolution.xy) / iResolution.y;\n#else\n\t\t\tvec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n#endif\n    vec3 bgcol=vec3(.1+.01*Hash21(uv))*(.5-abs(uv.y));\n    col = bgcol;            \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n\n    vec3  sundir = normalize(vec3(2,1,1.5));\n    vec3  sun_hal = normalize( sundir-rd );    \n    vec3  sun_color = vec3(8.10,6.00,4.20);\n    float d = RayMarch(ro, rd);    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);        \n        float m = GetDistAndMat(p).y;\n        float ks = 1.0;\n        // https://iquilezles.org/articles/outdoorslighting\n        // lighting , in these few lines there is all the magic thanks to IQ \n        // I'am just starting to understand how it works, sorry\n        float occ = calcOcclusion( p, n ); // occusion has a big impact\n        vec3  sun_lig = sundir;\n        float sun_dif = clamp(dot( n, sun_lig ), 0.0, 1.0 );\n        float sun_sha = calcSoftshadow( p, sun_lig, 0.02, 3.5 );\n\t\tfloat sun_spe = ks*pow(clamp(dot(n,sun_hal),0.0,1.0),8.0)*sun_dif*(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n\t\tfloat sky_dif = sqrt(clamp( 0.5+0.5*n.y, 0.0, 1.0 ));\n        float bou_dif = sqrt(clamp( 0.1-0.9*n.y, 0.0, 1.0 ))*clamp(1.0-0.1*p.y,0.0,1.0);\n        vec3 c = vec3(0); // material color\n        if ( m < 1.0 ) {\n            // body is white\n            c = vec3(0.15);\n        } else if ( m < 2.0 ) {\n            // joint is black\n            c = vec3(0.01);\n        } else if ( m < 3.0 ) {\n            // needle base is blue\n            c = vec3(0.01,0.01,0.2);\n        } else if ( m < 4.0 ) {\n            // needle is metallic\n            c = vec3(0.1,0.1,0.1);\n        }\n  \t\tvec3 lin = vec3(0.0);\n        lin += sun_dif*sun_color*sun_sha*.7;\n        lin += sky_dif*vec3(0.50,0.70,1.00)*occ*2.0;\n        lin += bou_dif*vec3(0.40,1.00,0.40)*occ*2.0*1.3;\n\t\tcol = c*lin;\n\t\tcol += sun_spe*vec3(8.10,6.00,4.20)*sun_sha;\n        \n    }\n    \n    // inner liquid\n    vec4 liquid = cylIntersect(ro,rd,vec3(-1.5,0.0,0.0), vec3(1.37,0.0,0.0), 0.23 );\n    float d3 = liquid.x; //RayMarch3(ro, rd);    \n    if(d3 > 0.0 && d3 < d ) {\n    \tvec3 p = ro + rd * d3;\n    \tvec3 n = liquid.yzw;        \n    \tfloat dif = dot(n,sundir)*.5+.5;\n        float time=mod(T,6.0);\n        float atime = ANIME_PISTON;\n        float fre = max(0.0,-dot(n,rd));  // fake transparency factor\n        fre=sqrt(fre);\n        float position = (p.x-2.2*atime+1.05);\n        vec3 c = position > 0.0 ? vec3(0.1,0.01,0.2) : vec3(1)*0.2 ;\n        if ( position < 0.0 ) { fre=1.0-fre; }\n    \tcol = mix(col,c*dif,fre);\n    }\n    // second layer\n    vec4 glass = cylIntersect(ro,rd,vec3(-1.5,0.0,0.0), vec3(1.37,0.0,0.0), 0.24 );\n    float d2 = glass.x;    \n    if(d2> 0.0 && d2 < d ) {\n    \tvec3 p = ro + rd * d2;\n    \tvec3 n = glass.yzw;        \n    \tfloat dif = dot(n, sundir)*.5+.5;\n        float fre = max(0.0,-dot(n,rd));  // fake transparency factor\n        fre=1.0-fre;   \n        fre*=fre;\n        float ks = 2.0; \n        float sun_spe = ks*pow(clamp(dot(n,sun_hal),0.0,1.0),8.0)*dif*(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));   \n        vec3 c = vec3(1)*.2;\n    \tcol = mix(col,c,fre);  \n        col+=sun_spe*sun_color;\n    }\n    tcol+=col;\n#ifdef AA\n\t\t}\n\ttcol /= 4.;\n#endif\n    \n    col = pow(tcol, vec3(.4545));\t// gamma correction    \n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}