{"ver":"0.1","info":{"id":"XXfXDs","date":"1710132125","viewed":36,"name":"glass field idk","username":"jneen","description":"idk man","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["yeah"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float R = 2.;\n#define mksmin(T) T smin(T a,T b,float k){T h=max(k-abs(b-a),0.)/k;return min(a,b)-h*h*h*k/6.;}T smax(T a,T b,float k){return -smin(-a,-b,k);}\nmksmin(float)\nmksmin(vec3)\n#undef mksmin\n\nfloat T;\n\n\n// PARAMS //\nfloat ripple_x = 3.; // any number\nfloat ripple_y = 2.; // any number\nfloat ripple_z = 5.; // any number\nfloat ripple_amp = .4; // 0 - .4, will start seeing glitches around .3\n\nfloat focal_length = .5; // positive, not zero. .3 - 5 probably\n\nfloat cut = .5; // size of the cut. 0-2\nfloat cutSmoothness = 1.; // smoothness, nonzero positive\n\nvec4 surfaceColor = vec4(.2, .6, .8, 1.);\nvec4 reflColor = vec4(.8, .2, .6, 2.);\nvec4 glowColor = vec4(.6, .2, .8, 1.);\n\n// END PARAMS //\n\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,s,-s,c);}\n\nvec3 erot(vec3 p, vec3 ax, float a) {\n  return mix(dot(p,ax)*ax,p,cos(a)) + sin(a)*cross(ax,p);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nbool isBackplane = false;\nfloat G = 0.;\nfloat w(vec3 p) {\n    float o = -sdTorus(p.xyz, vec2(R, 1.));\n\n    o = smax(o, cut-abs(dot(p, normalize(vec3(0.,3.*sin(2.5*T),4.*sin(T))))),cutSmoothness);\n    //o = smax(o, .2-abs(p.y), 1.);\n    //o = smax(o, .5-abs(p.x), .5);\n    o += ripple_amp*cos(dot(vec3(ripple_x, ripple_y, ripple_z), p));\n    G += .005;\n    float backplane = R*2.-length(p.xz);\n    isBackplane = backplane < o; \n    return min(o,backplane);\n}\n\nvec3 P,N,dir;\nfloat D;\nfloat backoff = .5;\nvoid march(){D=0.;G=0.;for (int i=0;i<5000;i++){float d=w(P)*backoff;if(d*d<.000000001||D>20.)break;D+=d;P+=d*dir;}}\n\n\nvoid norm(){mat3 k=mat3(P,P,P)-mat3(.0001);N=normalize(w(P)-vec3(w(k[0]),w(k[1]),w(k[2])));}\n\nvec3 path(float t) {\n    return R*vec3(cos(t), 0., sin(t));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    uv *= rot(radians(-90.) + .1*sin(iTime));\n    \n    vec3 col = vec3(0);\n\n    T = iTime*.3;\n    float dt = R*.7;\n    P = path(T);\n    vec3 fwd = normalize(path(T+dt)-P);\n    vec3 up = erot(vec3(0,1,0),fwd,.2*sin(T));\n    vec3 right = cross(fwd, up);\n    vec3 realup = cross(right, fwd);\n    \n    mat3 orientation = mat3(right, realup, fwd);\n    \n    dir = normalize(vec3(uv, focal_length));\n    dir *= orientation;\n    \n    \n    march();\n    \n    float glow = G;\n    \n    if (!isBackplane) {\n        norm();\n        \n        float l0 = max(0., length(.5+.5*sin(N))/sqrt(3.));\n        dir = reflect(N, dir);\n        P += .3*dir;\n        \n        march();\n        norm();\n        float l1 = max(0., length(.5+.5*sin(N))/sqrt(3.));\n\n        col += l1*reflColor.rgb*reflColor.a;\n        col += l0*surfaceColor.rgb*surfaceColor.a;\n    }\n    \n    col += glow*glowColor.rgb*glowColor.a;\n\n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"}]}