{"ver":"0.1","info":{"id":"wdsXWr","date":"1555326580","viewed":189,"name":"sphere_volexs","username":"skaplun","description":"Voxelised sphere with different voxel size. \nAO is taken from  https://www.shadertoy.com/view/XlXyD4. It fast, but looks not very good) Need to be reworked\n","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","voxel","ao"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"bool nextVoxel(in Box box, in Ray cameraRay, out HitRecord rec){\n\tfor(int i=0; i<20; i++){\n        if(rect_inside_sphere(box)){\n            box_hit(box, cameraRay, rec);\n\t\t\treturn true;\n        }else{\n            box_hit(box, cameraRay, rec);\n            box.origin += rec.nrm[1] * VOXEL_SIZE;\n        }\n    }\n    return false;\n}\n\nfloat ao(vec3 p, vec3 n) {\n    p += n * .0001;\n    vec3 voxelCntr = p - mod(p, VOXEL_SIZE) + (VOXEL_SIZE * .5);\n    p -= n * .0002;\n    Box outerBox = Box(voxelCntr, VOXEL_SIZE * .5);\n    HitRecord rec;\n    Ray ray;\n    ray.origin = p;\n    ray.direction = n;\n    if(nextVoxel(outerBox, ray, rec)){\n    \treturn sqrt(rec.dist.y);\n    }\n    return .5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    VOXEL_SIZE = .125 + sin(iTime * .25) * .1;\n    vec2 p = (2. * fragCoord - iResolution.xy)/iResolution.y;\n    Ray cameraRay = getCameraRay(p, (iResolution.x - iMouse.x) * .01);\n    vec4 color = vec4(.5);\n    \n    float dist;\n    HitRecord rec;\n    if(sphere_intersect(cameraRay, Sphere(SCENE_CENTER, OUTER_SPHERE_RAD), rec)){\n        vec3 voxelCntr = rec.ptnt[0] - mod(rec.ptnt[0], VOXEL_SIZE) + (VOXEL_SIZE * .5);\n        Box outerBox = Box(voxelCntr, VOXEL_SIZE * .5);\n        if(nextVoxel(outerBox, cameraRay, rec)){\n        \tvec3 p = rec.ptnt[0];\n            vec3 n = rec.nrm[0];\n\n            mat3 mat = alignMatrix(n);\n            float col = 0.0;\n            for (int i = 0; i < 12; ++i) {\n                vec3 m = mat * aoDir[i];\n                col += ao(p, m) * (0.5 + 0.5 * dot(m, vec3(0.0, 0.0, 1.0)));\n            }\n\n            color = vec4(vec3(pow(0.2 * col, 0.7)), 1.0);\n        }\n    }\n    fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define OUTER_SPHERE_RAD 1.\n#define CAMERA_RAD (OUTER_SPHERE_RAD * 2.5)\n#define SCENE_CENTER vec3(0.)\n#define MAX_FLOAT 1e5\n\nfloat VOXEL_SIZE = .05;\n    \nstruct Ray{\n    vec3 origin, direction, axisSign, invdir;\n};\n    \nstruct Sphere{\n\tvec3 origin;\n    float rad;\n};\n\nstruct Box{ vec3 origin; float size; };\n    \nstruct HitRecord{\n\tvec2 dist;\n\tvec3 ptnt[2];\n    vec3 nrm[2];\n};\n\nRay getCameraRay(in vec2 p, float ang){\n    vec3 cameraPos = vec3(CAMERA_RAD * sin(ang), 1., CAMERA_RAD * cos(ang));\n    vec3 fo = normalize(SCENE_CENTER - cameraPos);\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n    float fov = .5;\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\n\n    return Ray(cameraPos, rayDir, sign(rayDir), 1./rayDir);\n}\n\nvec3 hash(vec3 p){\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise(in vec3 p){\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nfloat remappedNoise(in vec3 p){\n\treturn .3 + .2 * noise(p)/.6;\n}\n\nbool solveQuadratic(const in float a, const in float b, const in float c, out float x0, out float x1) { \n    float discr = b * b - 4. * a * c; \n    if (discr < 0.) return false; \n    else if (discr == 0.)\n        x0 = x1 = - .5 * b / a;\n    else { \n        float q = (b > 0.) ? \n            -.5 * (b + sqrt(discr)) : \n            -.5 * (b - sqrt(discr)); \n        x0 = q / a; \n        x1 = c / q; \n    } \n \n    return true; \n}    \n\nbool sphere_intersect(const in Ray ray, const in Sphere sphere, out HitRecord hr){ \n    vec3 L = ray.origin - sphere.origin;\n    float a = dot(ray.direction, ray.direction); \n    float b = 2. * dot(ray.direction, L);\n    float c = dot(L, L) - sphere.rad*sphere.rad;\n    if (!solveQuadratic(a, b, c, hr.dist.x, hr.dist.y)) return false; \n\n    if(hr.dist.x > hr.dist.y)\n        hr.dist = hr.dist.yx;\n    \n    bool res = hr.dist.x > 0. && hr.dist.y > 0.;\n    if(res){\n    \thr.ptnt = vec3[2](ray.origin + ray.direction * hr.dist.x,\n                          ray.origin + ray.direction * hr.dist.y);\n        hr.nrm = vec3[2](normalize(hr.ptnt[0] - sphere.origin),\n                         normalize(hr.ptnt[1] - sphere.origin));\n    }\n    return res;\n}\n\nvec3 box_normal_at(const in Box box, const in vec3 point) {\n    vec3 normal;\n    vec3 localPoint = point - box.origin;\n    float mindist = MAX_FLOAT;\n    float dist = abs(box.size - abs(localPoint.x));\n    if (dist < mindist) {\n        mindist = dist;\n        normal = vec3(1., 0., 0.);\n        normal *= sign(localPoint.x);\n    }\n    \n    dist = abs(box.size - abs(localPoint.y));\n    if (dist < mindist) {\n        mindist = dist;\n        normal = vec3(0, 1., 0);\n        normal *= sign(localPoint.y);\n    }\n    dist = abs(box.size - abs(localPoint.z));\n    if (dist < mindist) { \n        mindist = dist; \n        normal = vec3(0, 0, 1.);\n        normal *= sign(localPoint.z);\n    } \n    return normal;\n}\n\n#define MIN x\n#define MAX y\nbool box_hit(const in Box inbox, const in Ray inray, inout HitRecord rec){\n    vec2 tx, ty, tz;\n    vec3 maxbounds = inbox.origin + vec3(inbox.size);\n    vec3 minbounds = inbox.origin + vec3(-inbox.size);\n    tx = ((inray.direction.x >= 0.?vec2(minbounds.x, maxbounds.x):vec2(maxbounds.x, minbounds.x)) - inray.origin.x) / inray.direction.x;\n\tty = ((inray.direction.y >= 0.?vec2(minbounds.y, maxbounds.y):vec2(maxbounds.y, minbounds.y)) - inray.origin.y) / inray.direction.y;\n    if ((tx.MIN > ty.MAX) || (ty.MIN > tx.MAX))\n        return false;\n    tx = vec2(max(tx.MIN, ty.MIN), min(tx.MAX, ty.MAX));\n\ttz = ((inray.direction.z >= 0.?vec2(minbounds.z, maxbounds.z):vec2(maxbounds.z, minbounds.z)) - inray.origin.z) / inray.direction.z;\n    if ((tx.MIN > tz.MAX) || (tz.MIN > tx.MAX))\n        return false;\n    tx = vec2(max(tx.MIN, tz.MIN), min(tx.MAX, tz.MAX));\n    \n    if(tx.MIN >= 0.){\n    \trec.dist.x = tx.MIN;\n        rec.ptnt[0] = inray.origin + inray.direction * rec.dist.x;\n        rec.nrm[0] = box_normal_at(inbox, rec.ptnt[0]);\n        \n        rec.dist.y = tx.MAX;\n        rec.ptnt[1] = inray.origin + inray.direction * rec.dist.y;\n        rec.nrm[1] = box_normal_at(inbox, rec.ptnt[1]);\n        \n        return true;\n    }\n        \n    return false;\n}\n\nbool rect_inside_sphere(Box box){\n\tfloat diag = sqrt(pow(box.size, 2.) + sqrt(pow(box.size, 2.) * 2.));\n    return length(box.origin)  + diag * .5 <= OUTER_SPHERE_RAD;\n}\n\nconst float aoPower = 2.0;\nconst vec3 aoDir[12] = vec3[12](\n\tvec3(0.357407, 0.357407, 0.862856),\n\tvec3(0.357407, 0.862856, 0.357407),\n\tvec3(0.862856, 0.357407, 0.357407),\n\tvec3(-0.357407, 0.357407, 0.862856),\n\tvec3(-0.357407, 0.862856, 0.357407),\n\tvec3(-0.862856, 0.357407, 0.357407),\n\tvec3(0.357407, -0.357407, 0.862856),\n\tvec3(0.357407, -0.862856, 0.357407),\n\tvec3(0.862856, -0.357407, 0.357407),\n\tvec3(-0.357407, -0.357407, 0.862856),\n\tvec3(-0.357407, -0.862856, 0.357407),\n\tvec3(-0.862856, -0.357407, 0.357407)\n);\n\nmat3 alignMatrix(vec3 dir) {\n    vec3 f = normalize(dir);\n    vec3 s = normalize(cross(f, vec3(0.48, 0.6, 0.64)));\n    vec3 u = cross(s, f);\n    return mat3(u, s, f);\n}","name":"Common","description":"","type":"common"}]}