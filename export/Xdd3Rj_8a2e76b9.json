{"ver":"0.1","info":{"id":"Xdd3Rj","date":"1450968382","viewed":179,"name":"Volumetric fractal nexus","username":"public_int_i","description":"volumetric glowing version of my dynamic fractal nexus shader.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal","volumetric","nexus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"//Ethan Shulman/public_int_i 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//thanks to iq for the great tutorials, code and information\n\n\n//Click and move mouse to control camera direction\n\n\n\n#define FOV_SCALE 2.\n#define ITERATIONS 86\n#define EPSILON .01\n#define NORMAL_EPSILON .012\n\n#define VIEW_DISTANCE 64.\n\n\n#define pi 3.141592\n\nvec3 cameraLocation;\nvec2 cameraRotation;\n\n\n//distance functions from iq's site\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n    \nvec2 rot(in vec2 v, in float ang) {\n    float si = sin(ang);\n    float co = cos(ang);\n    return v*mat2(si,co,-co,si);\n}\n\n\n\nfloat df(in vec3 rp) {\n    vec3 p = rp+vec3(0.,4.,0.);\n    \n    for (int i = 0; i < 4; i++) {\n        float t = iTime*.003+float(i)*.14;\n        p.xy = rot(abs(p.xy),t+float(i)*.24);\n        p.zx = abs(rot(p.zx,t+float(i)*.194));\n    }\n    \n    vec3 lp = p;\n    lp.xy = rot(lp.xy, iTime*.04);\n    lp = mod(abs(lp),20.)-10.;\n    vec3 lp2 = abs(mod(abs(p),5.)-2.5)-1.;\n    for (int i = 0; i < 4; i++) {\n        float t = .24+iTime*.024+float(i)*.14;\n        lp2.xy = rot(abs(lp2.xy),t+float(i)*.24);\n        lp2.zx = abs(rot(lp2.zx,t+float(i)*.194));\n    }\n    return max( -sdBox(lp, vec3(8.)),\n        \tmin(sdTorus(lp2,vec2(1.,.2)), udBox(lp2, vec3(.3,.6,.9))));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n\tvec2 uv = (fragCoord.xy - R*.5)/R.x;\n\n    float time = iTime+143.;\n  \n    vec2 mxy = (iMouse.xy/iResolution.xy);\n    mxy.y -= 1.;\n    mxy *= 6.28;\n    if (iMouse.w < 1.) {\n        mxy = vec2(time*.1-2.4,-2.9);\n    }\n    cameraRotation = vec2(-mxy.x-1.71,mxy.y/4.+2.4);//x = yaw ,   y = pitch\n    cameraLocation = vec3(sin(time*.001-.084)*100.,\n                          0.,\n                          cos(time*.001397)*100.);\n\n    \n    vec3 rp = cameraLocation;\n    vec3 rd = normalize(vec3(uv*vec2(1.,-1.)*FOV_SCALE,1.));\n\n    rd.yz = rot(rd.yz,cameraRotation.y);\n    rd.xz = rot(rd.xz,cameraRotation.x);\n    \n    rp += rd*3.;\n\n    vec4 c = vec4(0.);\n    float s = 0.;\n    for (int i = 0; i < 86; i++) {\n        vec3 p = rp+rd*s+vec3(0.,4.,0.);\n    \n        for (int k = 0; k < 4; k++) {\n            float t = time*.003+float(k)*.14;\n            p.xy = rot(abs(p.xy),t+float(k)*.24);\n            p.zx = abs(rot(p.zx,t+float(k)*.194));\n        }\n\n        vec3 lp = p;\n        lp.xy = rot(lp.xy, time*.04);\n        vec3 fp = floor(lp/20.);\n        lp = mod(abs(lp),20.)-10.;\n        vec3 lp2 = abs(mod(abs(p),5.)-2.5)-1.;\n        for (int k = 0; k < 4; k++) {\n            float t = .24+time*.024+float(k)*.14;\n            lp2.xy = rot(abs(lp2.xy),t+float(k)*.24);\n            lp2.zx = abs(rot(lp2.zx,t+float(k)*.194));\n        }\n        \n        float d = max( -sdBox(lp, vec3(8.)),\n                min(sdTorus(lp2,vec2(1.,.2)), udBox(lp2, vec3(.3,.6,.9)))),\n            d2 = max( -sdBox(lp+.02, vec3(8.)),\n                min(sdTorus(lp2+.02,vec2(1.,.2)), udBox(lp2+.02, vec3(.3,.6,.9))));\n    \n        float lighting = .2+max(0., (d2-d)/.02)*.8;\n        float alpha = max(0., 1.-d/2.)*.014*lighting;\n    \tc += vec4(normalize(abs(cos(fp))+abs(cos(fp.yzx+1.3927)))*alpha, alpha);\n        if (c.w > .99) break;\n        \n        s += d*.4;\n    }\n    \n    fragColor = vec4(c.xyz, 1.);\n}\n","name":"","description":"","type":"image"}]}