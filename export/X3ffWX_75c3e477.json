{"ver":"0.1","info":{"id":"X3ffWX","date":"1728962002","viewed":81,"name":"Water and Lava Pool","username":"justdodumb","description":"Manipulates a checkerboard grid with a warp filter and color manipulation based on the position of the cursor","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["vector"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Hermite interpolation functions\nfloat H0(float t) {\n    return 1.0 - 3.0 * t * t + 2.0 * t * t * t;\n}\n\nfloat H1(float t) {\n    return 3.0 * t * t - 2.0 * t * t * t;\n}\n\nfloat H2(float t) {\n    return t - 2.0 * t * t + t * t * t;\n}\n\nfloat H3(float t) {\n    return -t * t + t * t * t;\n}\n\n// Function to check if a point is inside a triangle\nbool insideTriangle(vec2 p, vec2 v1, vec2 v2, vec2 v3) {\n    float area = 0.5 * (-v2.y * v3.x + v1.y * (-v2.x + v3.x) + v1.x * (v2.y - v3.y) + v2.x * v3.y);\n    float s = 1.0 / (2.0 * area) * (v1.y * v3.x - v1.x * v3.y + (v3.y - v1.y) * p.x + (v1.x - v3.x) * p.y);\n    float t = 1.0 / (2.0 * area) * (v1.x * v2.y - v1.y * v2.x + (v1.y - v2.y) * p.x + (v2.x - v1.x) * p.y);\n    return (s >= 0.0 && t >= 0.0 && (s + t) <= 1.0);\n}\n\n// Simple noise function for variation\nfloat noise(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 col = vec3(0.0); // Default background color\n\n    // Create a checkerboard pattern\n    float checkerSize = 20.0; // Size of each checker\n    vec2 uv = fragCoord / iResolution.xy; // Normalized coordinates\n    vec2 checkerCoord = floor(uv * checkerSize);\n    \n    // Calculate color factors based on mouse position\n    float mouseX = iMouse.x / iResolution.x;\n\n    // Define color ranges based on the cursor position\n    vec3 colorA = mix(vec3(0.1, 0.3, 0.5), vec3(1.0, 0.5, 0.2), mouseX); // Interpolate from blue to orange\n    vec3 colorB = mix(vec3(0.5, 0.7, 0.9), vec3(1.0, 0.8, 0.5), mouseX); // Interpolate from blue to orange\n\n    // Create a color gradient based on checker coordinates and noise\n    vec3 checkerColorA = colorA + 0.1 * noise(checkerCoord + mouseX);\n    vec3 checkerColorB = colorB + 0.1 * noise(checkerCoord + mouseX);\n\n    // Interpolate colors based on checker position\n    vec3 checkerColor = mix(checkerColorA, checkerColorB, step(0.5, mod(checkerCoord.x + checkerCoord.y, 2.0)));\n\n    // Store the original checker color\n    vec3 originalColor = checkerColor;\n\n    // Warp effect based on cursor position\n    vec2 p0 = vec2(iMouse.x, iMouse.y); // Mouse position\n    float warpStrength = iMouse.x -390.0; // Strength of the warp\n\n    // Calculate distance from the cursor for the warp effect\n    vec2 displacement = (fragCoord - p0) * warpStrength / length(fragCoord - p0);\n    vec2 warpedUV = fragCoord + displacement;\n\n    // Recalculate checkerboard color using warped coordinates\n    vec2 warpedCheckerCoord = floor(warpedUV / checkerSize);\n    vec3 warpedCheckerColorA = colorA + 0.1 * noise(warpedCheckerCoord + mouseX);\n    vec3 warpedCheckerColorB = colorB + 0.1 * noise(warpedCheckerCoord + mouseX);\n    vec3 warpedCheckerColor = mix(warpedCheckerColorA, warpedCheckerColorB, step(0.5, mod(warpedCheckerCoord.x + warpedCheckerCoord.y, 2.0)));\n\n    // Determine color based on whether the pixel is inside the triangle\n    float triangleSize = 50.0; // Size of the triangle\n    float angle = iTime * 3.0; // Rotation angle\n\n    // Calculate positions of the triangle vertices in 3D\n    vec3 v1 = vec3(0.0, triangleSize, 0.0); // Top vertex\n    vec3 v2 = vec3(-triangleSize, -triangleSize, 0.0); // Bottom left\n    vec3 v3 = vec3(triangleSize, -triangleSize, 0.0); // Bottom right\n\n    // Rotate around Y-axis\n    float cosA = cos(angle);\n    float sinA = sin(angle);\n\n    // Apply rotation\n    float y1 = v1.y * cos(angle);\n    float y2 = v2.y * cos(angle) - v2.z * sin(angle);\n    float z2 = v2.y * sin(angle) + v2.z * cos(angle);\n    float y3 = v3.y * cos(angle) - v3.z * sin(angle);\n    float z3 = v3.y * sin(angle) + v3.z * cos(angle);\n\n    // Project 3D coordinates to 2D\n    vec2 projectedV1 = vec2(v1.x, y1) + p0;\n    vec2 projectedV2 = vec2(v2.x, y2) + p0;\n    vec2 projectedV3 = vec2(v3.x, y3) + p0;\n\n    if (insideTriangle(fragCoord, projectedV1, projectedV2, projectedV3)) {\n        col = vec3(0.0); // Set triangle color to black\n    } else {\n        col = warpedCheckerColor; // Use warped checker color\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}