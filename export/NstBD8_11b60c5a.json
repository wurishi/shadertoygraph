{"ver":"0.1","info":{"id":"NstBD8","date":"1656469238","viewed":82,"name":"Quadratic Bezier trig solution","username":"saidwho12","description":"Quadratic bezier curve solution","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","bezier","distance","curve","cubic","trigonometry","cardano"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FLT_INFINITY .1e9\n#define FLT_EPSILON 1.e-7\n#define PI 3.141592653589793238\n#define dot2(v) dot(v,v)\n#define saturate(x) clamp(x,0.,1.)\n\nfloat cross2(in vec2 a, in vec2 b)\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nvec2 B1(in vec2 P0, in vec2 P1, in float t)\n{\n    return P0 + t * (P1 - P0);\n}\n\nfloat sd_line(in vec2 P0, in vec2 P1, in vec2 P) {\n    // P0 + t * (P1 - P0)\n    vec2 dv = P1 - P0;\n    float t = saturate(dot(P-P0,dv)/dot2(dv));\n    vec2 z = (P0+t*dv) - P;\n    return sign(cross2(dv,z)) * sqrt(dot2(z));\n}\n\n\nvec2 B2(in vec2 P0, in vec2 p1, in vec2 p2, in float t)\n{\n    return t*t*p2 + 2.0*t*p1 + P0;\n}\n\nvec2 B3(in vec2 P0, in vec2 p1, in vec2 p2, in vec2 p3, in float t)\n{\n    return t*t*t*p3 + 3.0*t*t*p2 + 3.0*t*p1 + P0;\n}\n\n// Taken from scholarius at https://www.shadertoy.com/view/wts3RX\n#define NEWTON_ITER 2\n#define HALLEY_ITER 0\n\nfloat cbrt( float x )\n{\n    if (sign(x) == 0.0) return 0.0;\n    \n    float y = sign(x) * uintBitsToFloat( floatBitsToUint( abs(x) ) / 3u + 0x2a514067u );\n        \n    \n    for( int i = 0; i < NEWTON_ITER; ++i )\n        y = ( 2. * y + x / ( y * y ) ) * .333333333;\n\n    for( int i = 0; i < HALLEY_ITER; ++i )\n    {\n        float y3 = y * y * y;\n        y *= ( y3 + 2. * x ) / ( 2. * y3 + x );\n    }\n    \n    return y;\n}\n\n\n// Complex cube root\nvec3 complex_cbrt(vec2 c) {\n    float m = pow(dot(c,c),1.0/6.0); // magnitude\n    float t = atan(c.y/c.x);// theta original angle\n    float t0 = (t+2.0*PI*0.)/3.0;\n    float t1 = (t+2.0*PI*1.0)/3.0;\n    float t2 = (t+2.0*PI*2.0)/3.0;\n    vec2 z0 = vec2(cos(t0),sin(t0))*m;\n    vec2 z1 = vec2(cos(t1),sin(t1))*m;\n    vec2 z2 = vec2(cos(t2),sin(t2))*m;\n    return vec3(z0[0], z1[0], z2[0]);\n}\n\nvec2 complex_conjugate(vec2 z) {\n    return vec2(z[0], -z[1]);\n}\n\n// iq\nfloat sdBox(vec2 p, vec2 b) {\n  vec2 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0); \n}\n\nvoid quadratic_bezier_bounds(vec2 u, vec2 v, vec2 w,\n                             out vec2 b0, out vec2 b1) {\n    // Find roots for first derivative of quadratic bezier function, this gives us\n    // the locations where the curve changes direction.    \n    // B'(t)d/dt = 2ct+2b\n    // 0 = 2ct+2b\n    // 2ct = -2b\n    // t = -2b/2c\n    vec2 v0 = u, v1 = w;\n    \n    vec2 det = 2.0*w;\n    vec2 t = (u-v)/(u-2.0*v+w);\n\n    if (t.x >= 0.0 && t.x <= 1.0) {\n        float tt = 1.0-t.x;\n        vec2 bound = u * tt*tt + 2.0*v*(1.0*-t.x)*t.x + w*t.x*t.x;\n        if (v.x < u.x) { v0.x = bound.x + (v.x-u.x); } else { v1.x = bound.x + (v.x-u.x); }\n    }\n    \n    if (t.y >= 0.0 && t.y <= 1.0) {\n        float tt = 1.0-t.y;\n        vec2 bound = u * tt*tt + 2.0*v*tt*t.y + w*t.y*t.y;\n        if (v.y < u.y) { v0.y = bound.y; } else { v1.y = bound.y; }\n    }\n    \n    b0 = v0, b1 = v1;\n}\n\nfloat sd_quadratic_bezier(vec2 P0, vec2 P1, vec2 P2, vec2 P)\n{\n    float res;\n    \n    vec2 p0 = P - P0;\n    vec2 p1 = P1 - P0;\n    vec2 p2 = P2 - 2.0*P1 + P0;\n\n    // declare coefficients for equation of form t^3 + at^2 + bt + c = 0\n    float a = dot2(p2);\n    float b = 3.0*dot(p1,p2);\n    float c = dot(2.0*p1,p1)-dot(p2,p0);\n    float d = -dot(p1,p0);\n\n    // declare y, p and q for depressed cubic form y^3 + py + q = 0 where:\n    // t = y - b/(3a)\n    // p = c/a - (b^2)/(3a^2) \n    // q = (2b^3)/(27a^3) - (bc)/(3a^2) + d/a\n    float p = c/a - (b*b)/(3.0*a*a);\n    float q = (2.0*b*b*b)/(27.0*a*a*a) - (b*c)/(3.0*a*a) + d/a;\n\n    // compute the difference between maxima and inflection point, \n    // this tells us how many roots the cubic has.\n    float z = pow(q/2.0,2.0) + pow(p/3.0,3.0);\n    float h = b/(3.0*a); // x-offset of inflextion point\n    float sgn = 1.0;\n\n    if (z>=0.0) {\n        // 1 root\n        z = sqrt(z);\n        vec2 x = vec2(z,-z)-q/2.0;\n        vec2 uv = sign(x)*pow(abs(x),vec2(1.0/3.0));\n        float t = clamp(uv.x+uv.y-h,0.0,1.0);\n        vec2 v = B2(P0,p1,p2,t) - P;\n        sgn = cross2(v, 2.*p2*t+2.*p1);\n        res = dot2(v);\n    } else {\n        // 3 roots\n        // Formula based on the paper on Joukowsky maps and their relation\n        // to the cubic equation.\n        // https://maa.tandfonline.com/doi/full/10.1080/00029890.2019.1528814#.YRBwTi295B1\n        // This solves the three-root case using an equilateral triangle's vertices\n        // projected onto the x-axis.\n        // h is the point of inflexion on the x-axis.\n        // h = b/(3a)\n        // tx = h+2rcos(theta)\n        // ty = h+2rcos(theta+(2pi)/3)\n        // only the first two of these roots are required.\n        float r = sqrt(p/-3.0), theta = acos(q/(-2.0*r*r*r))/3.0;\n        vec2 t = 2.0*r*vec2(cos(theta), cos(theta+2.09439510239));\n        t = saturate(t-h);\n        \n        vec2 vx = B2(P0,p1,p2,t.x) - P, vy = B2(P0,p1,p2,t.y) - P;\n        float xd = dot2(vx), yd = dot2(vy);\n        float sx = cross2(2.*p2*t.x+2.*p1,vx), sy = cross2(2.*p2*t.y+2.*p1,vy);\n        \n        if (xd<yd) { res=xd; sgn=sx; } else { res=yd; sgn=sy; }\n    }\n    \n    // sdDistance(t) = cross2((dBn/dt)(t), P-Bn(t)) * ||Bn(t)-P||\n    return sign(sgn) * sqrt(res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 R = iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (2.*fragCoord -R)/R.y;\n\n    vec3 col = vec3(0.0);\n    vec2 A = vec2(-.5,-.5);\n    vec2 B = vec2(.1,.325);\n    vec2 C = vec2(.5,-.1);\n    //B.y += sin(iTime*0.6)*.52;\n    //C.y += sin(iTime*0.6)*.52;\n    \n    if (iMouse.z > 0.5) {\n        B = (2.*iMouse.xy - R.xy)/R.y; \n    }\n\n#if 0\n    float t = sdLine(A,B,p);\n#else\n    vec2 b0,b1;\n    float t = sd_quadratic_bezier(A,B,C,p);\n    quadratic_bezier_bounds(A,B,C,b0,b1);\n#endif\n    \n    float alpha = smoothstep(1.5/R.y,-1.5/R.y,abs(t)-.008);\n    float kk = smoothstep(1.5/R.y,-1.5/R.y,t); // alpha for going from positive to negative distance\n    //col = vec3(alpha);\n    float K = 35.;\n    //float k = fract(t*K)*2.-1.;\n    float wav = pow(sin(abs(t)*K*PI)*.25+.55,2.15); //*(.5*1.-.5*exp(-abs(t)*3.));\n    \n    col = mix(col,mix(vec3(1),vec3(0,1,0),kk),wav);//wav);\n    col = mix(col,vec3(0,1,0), alpha);\n    //col = vec3(t);\n    float box_alpha = smoothstep(1.5/R.y,-1.5/R.y,abs(sdBox(p-(b0+b1)/2.0,(b1-b0)/2.0))-0.0045);\n    //col = mix(col,vec3(1,0,0), box_alpha);\n    \n    \n    {\n        float alpha = smoothstep(1.5/R.y,-1.5/R.y,distance(A,p)-.035);\n        col = mix(col,vec3(0,0,1),alpha);\n    }\n    \n    {\n        float alpha = smoothstep(1.5/R.y,-1.5/R.y,distance(B,p)-.035);\n        col = mix(col,vec3(0,0,1),alpha);\n    }\n    \n    {\n        float alpha = smoothstep(1.5/R.y,-1.5/R.y,distance(C,p)-.035);\n        col = mix(col,vec3(0,0,1),alpha);\n    }\n    \n    fragColor = vec4(abs(t),abs(t),abs(t),1.0);\n}","name":"Image","description":"","type":"image"}]}