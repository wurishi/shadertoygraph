{"ver":"0.1","info":{"id":"7scXzM","date":"1633132372","viewed":122,"name":"Nebula - Andrew","username":"andrew741","description":"This is a nebula and is a part of my project called \"Through The Cosmos\" which will be coming out sometime. I used volumetrics and ray tracing to render the stars and moving clouds of gas which use more noise to create the varying color. I hope you enjoy!","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["procedural","noise","volume","clouds","space","space","volumetric","stars","nebula","dynamic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n// from https://www.shadertoy.com/view/WtGXDD\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\n// from https://www.shadertoy.com/view/WtGXDD\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n// 2d rotation matrix\nvec2 rot2D(vec2 v, float a)\n{\n    mat2x2 rot = mat2x2(cos(a), -sin(a), sin(a), cos(a));\n    return v * rot;\n}\n\n\n// takes a uv coord and mouse pos and converts it to the rays direction\nvec3 Transform(vec2 uv, vec2 m, float roll)\n{\n    vec3 ro = vec3(0, 1, -1) * 20.;\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    vec3 rd = GetRayDir(rot2D(uv, roll), ro, vec3(0,0.,0), 1.);\n    return rd;\n}\n\n\n// from another shadertoy shader\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n// from another shadertoy shader\nvec4 noised( in vec3 x )\n{\n    // grid\n    vec3 i = floor(x);\n    vec3 w = fract(x);\n    \n    // cubic interpolant\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    // gradients\n    vec3 ga = hash( i+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( i+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( i+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( i+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( i+vec3(0.0,0.0,1.0) );\n\tvec3 gf = hash( i+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( i+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( i+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\n}\n\n\nvec2 RaySphere(vec3 ro, vec3 rd, vec3 sc, float r)\n{\n    vec3 offset = ro - sc;\n    float b = 2. * dot(offset, rd);\n    float c = dot(offset, offset) - r * r;\n\n    float discriminant = b * b - 4. * c;\n\n    if (discriminant > 0.)\n    {\n        float s = sqrt(discriminant);\n        float dstToSphereNear = max(0., (-b - s) / 2.);\n        float dstToSphereFar = (-b + s) / 2.;\n\n        if (dstToSphereFar > 0.)\n        {\n            return vec2(dstToSphereNear, dstToSphereFar - dstToSphereNear);\n        }\n    }\n    return vec2(999999999999999999., 0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y * 1.75;\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    if (iMouse.xy == vec2(0.))\n    {\n        m = vec2(1., 0.4);\n    }\n    \n    float roll = 0.;\n    \n    vec3 rd = Transform(uv, m, roll);\n    vec3 ro = vec3(0., 1., iTime * 0.5);\n    \n    vec3 sun_dir = normalize(vec3(0.2, 0.7, -0.2));\n\n    vec3 col = vec3(0.);\n    \n    col = mix(col, vec3(0.95, 0.75, 0.5) * 2., pow(max(dot(sun_dir, rd), 0.), 275.));\n\n    vec2 dstNebula = RaySphere(ro, rd, vec3(0., 0., 4.), 3.);\n    \n    if (dstNebula.y > 0.)\n    {\n        float transmission = 1.;\n        float step_size = dstNebula.y / 16.;\n        vec3 step_sizev = rd * step_size;\n        \n        vec3 total_color = vec3(0.);\n        vec3 p = ro + rd * dstNebula.x;\n        \n        for (int i = 0; i < 15; i++)\n        {\n            p += step_sizev;\n            \n            float colorBlend = noised(p * 0.5 + 20. + iTime * 0.75).x * 0.5 + 0.5;\n            float density = smoothstep(0., 0.7, max(noised(p).x + noised(p * 2. + 200. + iTime * 0.25).r * 0.5, 0.) / 1.5);\n            total_color += mix(vec3(0.8, 0.3, 0.2), vec3(0., 0., 0.9), smoothstep(0., 1., colorBlend)) * transmission * 0.3;\n            transmission *= exp(-density * step_size * 6. * smoothstep(3., 2.2, length(p - vec3(0., 0., 4.))));\n        }\n        col = col * transmission + total_color * 0.7 * (1. - transmission);\n        \n        float dst_sun;\n        dst_sun = RaySphere(ro, rd, vec3(0.1, 0., 3.), 0.05).x;\n        if (dst_sun < 9999999.) col += 4. * transmission;\n         dst_sun = RaySphere(ro, rd, vec3(1.7, 0.7, 5.), 0.05).x;\n        if (dst_sun < 9999999.) col += 4. * transmission;\n        dst_sun = RaySphere(ro, rd, vec3(-0.5, -1.8, 5.3), 0.05).x;\n        if (dst_sun < 9999999.) col += 4. * transmission;\n        dst_sun = RaySphere(ro, rd, vec3(1.5, 1.73, 4.3), 0.05).x;\n        if (dst_sun < 9999999.) col += 4. * transmission;\n        dst_sun = RaySphere(ro, rd, vec3(0.4, 1., 4.3), 0.05).x;\n        if (dst_sun < 9999999.) col += 4. * transmission;\n        dst_sun = RaySphere(ro, rd, vec3(-1.5, -0.72, 2.3), 0.05).x;\n        if (dst_sun < 9999999.) col += 4. * transmission;\n        dst_sun = RaySphere(ro, rd, vec3(1.2, -0.3, 4.63), 0.05).x;\n        if (dst_sun < 9999999.) col += 4. * transmission;\n        dst_sun = RaySphere(ro, rd, vec3(-0.82, 0.185, 4.2), 0.05).x;\n        if (dst_sun < 9999999.) col += 4. * transmission;\n        dst_sun = RaySphere(ro, rd, vec3(0.84, 1.4, 5.1), 0.05).x;\n        if (dst_sun < 9999999.) col += 4. * transmission;\n        dst_sun = RaySphere(ro, rd, vec3(-0.274, -1.63, 2.84), 0.05).x;\n        if (dst_sun < 9999999.) col += 4. * transmission;\n        //col = vec3(transmission);\n    }\n    \n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    col =  clamp((col*(a*col+b))/(col*(c*col+d)+e), 0., 1.);\n\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}