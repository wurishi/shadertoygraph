{"ver":"0.1","info":{"id":"XXfXzX","date":"1709748046","viewed":102,"name":"Improved Glow Analytic AA","username":"chronos","description":"Top half and green function: Improved glow\nBottom half and red function: Basic glow.\nShaded region indicates simulated pixel width.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["antialiasing","glow","function","plot","aa","analytic","alias","anti","improved"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Basic glow, no anti-aliasing, and one way trip to nan/inf-town.\nfloat glow(float x)\n{\n    return 1./abs(x);\n}\n\n/*\n    This function uses the integral of the function \n        \n            integral 1./sqrt(1e-4 + x*x) = asinh(100 * x)\n            \n    and\n        integrate 1/sqrt(0.0001 + x^2) from 0 to t = asinh(100 * t)\n        \n    to compute the integral from t0 to t1\n    \n        asinh(100 * t1) - asinh(100 * t0)\n        \n    to obtain the average, we divide by the interval width:\n    \n    \n    asinh(100 * t1) - asinh(100 * t0)\n    ---------------------------------\n                 t1 - t0\n                 \n                 \n    Above I used values \n    \n        eps = 1e-4\n        \n    so that the factor\n        \n        A = 1./sqrt(eps) = 100.\n        \n    but too high eps gives reduced brightness, so below I use 1e-5 as a compromise\n    between brightness and stability.\n    \n    If we instead had based integrated 1/(eps + abs(x)), we would have obtained an expression using logarithms instead,\n    but it's all related anyhow.\n*/\n#define INSTABILITY_FIX 2\nfloat improved_glow(float x, float pixel_size)\n{\n    float halfps = 0.5 * pixel_size;\n\n\n    const float eps = 1e-5;\n    const float A = 1./sqrt(eps);\n\n    #if INSTABILITY_FIX == 1\n    \n    // This is a fix for instabilities when asinh values become close\n    // due to x being large compared to pixel size, meaning that \n    // We end up evaluating the sigmoid like asinh funtion near each other on a very flat segment\n    // which causes catastrophic cancellation.\n    // Luckily, since these areas are very flat in the original function, it means we can accurately\n    // approximate their integrals by just sampling.\n    // You can see this by defining INSTABILITY_FIX as 0 and making the pixel size very small.\n    if(abs(x) > 2. * pixel_size) // the distance threshold is tunable. Depends on eps.\n        return 1./abs(x);\n    \n    return ( asinh(A*(x+halfps)) - asinh(A*(x-halfps)) ) / pixel_size;\n    \n    #elif INSTABILITY_FIX == 2\n    \n    // This is another fix exploiting the fact that this seems to mostly occur when x is negative\n    // and that this function is symmetric around 0, so we can split it into two parts,\n    // one for the positive side and one for the negative, \n    // flip the negative to the positive side using abs,\n    // and combine the results.\n    // \n    return ( sign(x+halfps)*asinh(A*abs(x+halfps)) - sign(x-halfps)*asinh(A*abs(x-halfps)) ) / pixel_size;\n    \n    #else\n    \n    // This is the basic version, seems to work well enough in practice afaict.\n    return ( asinh(A*(x+halfps)) - asinh(A*(x-halfps)) ) / pixel_size;\n    \n    #endif\n}\n\n\n// Distance from p to line segment from a to b\nfloat seg(vec2 a, vec2 b, vec2 p)\n{\n    p-= a; b-=a;\n    return length(clamp(dot(p,b)/dot(b,b), 0., 1.)*b - p);\n}\n\n\nvec3 plot(float function_value, vec2 uv)\n{\n    float pixel_size = length(fwidth(uv)) / sqrt(2.);\n    float threshold = 2. * pixel_size;\n    \n    vec3 color = vec3(0);\n    if(abs(uv.y - function_value) < threshold)\n        color += 1.;\n        \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    if(length(iMouse.xy) < 10.) mouse = vec2(cos(iTime),0);\n    \n    vec3 color = vec3(0);\n    \n    #if 0\n    // This can cause issues if \n    float pixel_size = length(fwidth(uv)) / sqrt(2.);\n    // Sanity check for pixel size calculation\n    // color += float(abs( pixel_size - (2. / iResolution.y) ) < 1e-7);\n    #else\n    float pixel_size = 2. / iResolution.y;\n    #endif\n\n    float simulated_pixel_size = 0.5 * max(mouse.x+1., 0.) + 0.01;\n    \n    color += vec3(0.1, 0.9, 0.3) * plot(improved_glow(uv.x, simulated_pixel_size), (uv-vec2(0, -1)) * 10.);\n    \n    color += vec3(0.8, 0.1, 0.3) * plot(glow(uv.x), (uv-vec2(0, -1)) * 10.);\n    \n    if(mouse.y <= uv.y)\n        color += 0.01*improved_glow(seg(vec2(0,-.1), vec2(0,.1), uv), pixel_size);\n    else\n        color += 0.01*glow(seg(vec2(0,-.1), vec2(0,.1), uv));\n        \n    color = mix(color, color*smoothstep(0.005-pixel_size,0.005+pixel_size, abs(mouse.y - uv.y)), float(abs(uv.x) > .5));\n\n    if( uv.x > simulated_pixel_size*.5 || uv.x < - simulated_pixel_size*.5)\n        color *= .5;\n    \n    // Since the glow function exceed 1 in brightness, we apply basic tonemapping:\n    #if 1\n    color = tanh(color);\n    #endif\n\n    color = pow(color, vec3(1./2.2));\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}