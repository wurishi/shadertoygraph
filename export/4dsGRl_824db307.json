{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"cubemap","id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Hazel Quantock - 20/08/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// constants\nconst float tau = 6.28318530717958647692;\nfloat Noise( in vec3 x );\nbool ReadKey( int key, bool toggle );\n\nbool toggleR = false;\nbool toggleS = false;\n\n\n// ---USER TWEAKABLE THINGS!---\n\nconst float epsilon = .003;\nconst float normalPrecision = .1;\nconst float shadowOffset = .1;\nconst int traceDepth = 500; // takes time\nconst float drawDistance = 100.0;\n\nconst vec3 CamPos = vec3(0,40.0,-40.0);\nconst vec3 CamLook = vec3(0,0,0);\n\nconst vec3 lightDir = vec3(.7,1,-.1);\nconst vec3 fillLightDir = vec3(0,0,-1);\nconst vec3 lightColour = vec3(1.1,1.05,1);\nconst vec3 fillLightColour = vec3(.38,.4,.42);\n\t\n// This should return continuous positive values when outside and negative values inside,\n// which roughly indicate the distance of the nearest surface.\nfloat Isosurface( vec3 ipos )\n{\n\t// animate the object rotating\n\tfloat ang = iTime*tau/25.0;\n\tfloat ang2 = iTime*tau/125.0;\n\tfloat s = sin(ang), c = cos(ang);\n\tfloat s2 = sin(ang2), c2 = cos(ang2);\n\tvec3 pos;\n\tpos.y = c*ipos.y-s*ipos.z;\n\tpos.z = c*ipos.z+s*ipos.y;\n\tpos.x = ipos.x*c2+pos.z*s2;\n\tpos.z = pos.z*c2-ipos.x*s2;\n\n\n\t// smooth csg\n\tfloat smoothing = .9-.65*cos(iTime*.05);\n\n\treturn\n\t\tlog(\n\t\t\t// intersection\n\t\t\t1.0/(\n\t\t\t\t// union\n\t\t\t\t1.0/(\n\t\t\t\t\t// intersection\n\t\t\t\t\texp((length(pos.xz)-10.0)/smoothing) +\n\t\t\t\t\texp((-(length(pos.xz)-7.0))/smoothing) +\n\t\t\t\t\texp((-(length(vec2(8.0,0)+pos.zy)-5.0))/smoothing) +\n\t\t\t\t\texp((pos.y-10.0)/smoothing) +\n\t\t\t\t\texp((-pos.y-10.0)/smoothing)\n\t\t\t\t\t)\n\t\t\t\t+ exp(-(length(pos+15.0*vec3(sin(iTime*.07),sin(iTime*.13),sin(iTime*.1)))-5.0))\n\t\t\t\t)\n\t\t\t// trim it with a plane\n\t\t\t//+ exp((dot(pos,normalize(vec3(-1,-1,1)))-10.0-10.0*sin(iTime*.17))/smoothing)\n\t\t)*smoothing\n\t\t;//+ Noise(pos*16.0)*.08/16.0; // add some subtle texture\n}\n\n\n// alpha controls reflection\nvec4 Shading( vec3 pos, vec3 norm, vec3 visibility, vec3 rd )\n{\n\tvec3 albedo = vec3(1);//mix( vec3(1,.8,.7), vec3(.5,.2,.1), Noise(pos*vec3(1,10,1)) );\n\n\tvec3 l = lightColour*mix(visibility,vec3(1)*max(0.0,dot(norm,normalize(lightDir))),.0);\n\tvec3 fl = fillLightColour*(dot(norm,normalize(fillLightDir))*.5+.5);\n\t\n\tvec3 view = normalize(-rd);\n\tvec3 h = normalize(view+lightDir);\n\tfloat specular = pow(max(0.0,dot(h,norm)),2000.0);\n\t\n\tfloat fresnel = pow( 1.0 - dot( view, norm ), 5.0 );\n\tfresnel = mix( .01, 1.0, min(1.0,fresnel) );\n\t\n\tif ( toggleR )\n\t\tfresnel = 0.0;\n\t\n\treturn vec4( albedo*(l+fl)*(1.0-fresnel) + visibility*specular*32.0*lightColour, fresnel );\n}\n\nconst vec3 FogColour = vec3(.1,.2,.5);\n\nvec3 SkyColour( vec3 rd )\n{\n\t// hide cracks in cube map\n\trd -= sign(abs(rd.xyz)-abs(rd.yzx))*.01;\n\n\t//return mix( vec3(.2,.6,1), FogColour, abs(rd.y) );\n\tvec3 ldr = texture( iChannel1, rd ).rgb;\n\t\n\t// fake hdr\n\tvec3 hdr = 1.0/(1.2-ldr) - 1.0/1.2;\n\t\n\treturn hdr;\n}\n\n// ---END OF USER TWEAKABLE THINGS!---\n\n\n// key is javascript keycode: http://www.webonweboff.com/tips/js/event_key_codes.aspx\nbool ReadKey( int key, bool toggle )\n{\n\tfloat keyVal = textureLod( iChannel2, vec2( (float(key)+.5)/256.0, toggle?.75:.25), 0.0 ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\n\n// backend code, hopefully needn't be edited:\n\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x.xzy);\n    vec3 f = fract(x.xzy);\n//\tf = f*f*(3.0-2.0*f);\n\tvec3 f2 = f*f; f = f*f2*(10.0-15.0*f+6.0*f2);\n\t\n//cracks cause a an artefact in normal, of course\n\t\n\t// there's an artefact because the y channel almost, but not exactly, matches the r channel shifted (37,17)\n\t// this artefact doesn't seem to show up in chrome, so I suspect firefox uses different texture compression.\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 ).ba;\n\treturn mix( rg.y, rg.x, f.z )-.5;\n}\n\nfloat Trace( vec3 ro, vec3 rd )\n{\n\tfloat t = 0.0;\n\tfloat dist = 1.0;\n\tfor ( int i=0; i < traceDepth; i++ )\n\t{\n\t\tif ( abs(dist) < epsilon || t > drawDistance || t < 0.0 )\n\t\t\tcontinue;\n\t\tdist = Isosurface( ro+rd*t );\n\t\tt = t+dist;\n\t}\n\t\n\t// reduce edge sparkles, caused by reflections on failed positions\n\tif ( dist > epsilon )\n\t\treturn drawDistance+1.0;\n\t\n\treturn t;//vec4(ro+rd*t,dist);\n}\n\nvec3 SubsurfaceTrace( vec3 ro, vec3 rd )\n{\n\tvec3 density = pow(vec3(.7,.5,.4),vec3(.4));\n\tconst float confidence = .01;\n\tvec3 visibility = vec3(1.0);\n\t\n\tfloat lastVal = Isosurface(ro);\n\tfloat soft = 0.0;\n\tfor ( int i=1; i < 50; i++ )\n\t{\n\t\tif ( visibility.x < confidence )\n\t\t\tcontinue;\n\t\t\n\t\tfloat val = Isosurface(ro);\n\n\t\tvec3 softened = pow(density,vec3(smoothstep(soft,-soft,val)));\n//tweak this to create soft shadows, by expanding with each step (linearly)\n\t\t\n\t\tif ( (val-soft)*lastVal < 0.0 )\n\t\t{\n\t\t\t// approximate position of the surface\n\t\t\tfloat transition = -min(val-soft,lastVal)/abs(val-soft-lastVal);\n\t\t\tvisibility *= pow(softened,vec3(transition));\n\t\t}\n\t\telse if ( val-soft < 0.0 )\n\t\t{\n\t\t\tvisibility *= softened;\n\t\t}\n\n\t\tsoft += .1;\n\t\tlastVal = val+soft;\n\t\tro += rd*.4;\n\t}\n\t\n\treturn visibility;\n}\n\n// get normal\nvec3 GetNormal( vec3 pos )\n{\n\tconst vec2 delta = vec2(normalPrecision, 0);\n\t\n\tvec3 n;\n\n// it's important this is centred on the pos, it fixes a lot of errors\n\tn.x = Isosurface( pos + delta.xyy ) - Isosurface( pos - delta.xyy );\n\tn.y = Isosurface( pos + delta.yxy ) - Isosurface( pos - delta.yxy );\n\tn.z = Isosurface( pos + delta.yyx ) - Isosurface( pos - delta.yyx );\n\treturn normalize(n);\n}\t\t\t\t\n\n// camera function by TekF\n// compute ray from camera parameters\nvec3 GetRay( vec3 dir, float zoom, vec2 uv )\n{\n\tuv = uv - .5;\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n\tdir = zoom*normalize(dir);\n\tvec3 right = normalize(cross(vec3(0,1,0),dir));\n\tvec3 up = normalize(cross(dir,right));\n\t\n\treturn dir + right*uv.x + up*uv.y;\n}\n\n\nvoid Humbug( inout vec4 result, inout vec3 ro, inout vec3 rd )\n{\n\tif ( result.a < .01 )\n\t\treturn; // continue; // break;\n\t\n\tfloat t = Trace(ro,rd);\n\t\n\tvec4 samplev = vec4( SkyColour( rd ), 0 );\n\t\n\tvec3 norm;\n\tif ( t < drawDistance )\n\t{\n\t\tro = ro+t*rd;\n\t\t\n\t\tnorm = GetNormal(ro);\n\t\t\n\t\t// shadow test\n\t\t/*float shadow = 1.0;\n\t\tif ( Trace( ro+lightDir*shadowOffset, lightDir ) < drawDistance )\n\t\t\tshadow = 0.0;*/\n\t\t\n\t\tvec3 subsurface;\n\t\tif ( toggleS )\n\t\t\tsubsurface = vec3(dot(norm,lightDir));\n\t\telse\n\t\t\tsubsurface = SubsurfaceTrace( ro+rd*1.0, lightDir );\n\t\t\n\t\t\n\t\tsamplev = Shading( ro, norm, subsurface, rd );\n\t}\n\t\n\tresult.rgb += samplev.rgb*result.a;\n\tresult.a *= samplev.a;\n\tresult.a = clamp(result.a,0.0,1.0); // without this, chrome shows black!\n\n\t//\t\t// fog\n\t//\t\tresult = mix ( vec4(FogColour, 0), result, exp(-t*t*.0002) );\n\t\n\trd = reflect(rd,norm);\n\t\n\tro += rd*shadowOffset;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\tvec3 camPos = CamPos;\n\tvec3 camLook = CamLook;\n\n\tvec2 camRot = vec2(iTime*.1,0)+.5*tau*(iMouse.xy-iResolution.xy*.5)/iResolution.x;\n\tcamPos.yz = cos(camRot.y)*camPos.yz + sin(camRot.y)*camPos.zy*vec2(1,-1);\n\tcamPos.xz = cos(camRot.x)*camPos.xz + sin(camRot.x)*camPos.zx*vec2(1,-1);\n\t\n\tif ( Isosurface(camPos) <= 0.0 )\n\t{\n\t\t// camera inside ground\n\t\tfragColor = vec4(0,0,0,0);\n\t\treturn;\n\t}\n\n\tvec3 ro = camPos;\n\tvec3 rd;\n\trd = GetRay( camLook-camPos, 2.0, uv );\n\trd = normalize(rd);\n\t\n\tvec4 result = vec4(0,0,0,1);\n\t\n\ttoggleR = ReadKey( 82, true );\n\ttoggleS = ReadKey( 83, true );\n\n\tHumbug( result, ro, rd );\n\tif ( !toggleR )\n\t{\n\t\tHumbug( result, ro, rd );\n\t\tHumbug( result, ro, rd );\n\t}\n\t\n\tfragColor = result;\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":true,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dsGRl","date":"1376951091","viewed":4872,"name":"Subsurface Scattering","username":"TekF","description":"UPDATE! Added keyboard controls: s toggles sub-surface scattering, r toggles reflections.\nI'm loving distance fields... My smooth CSG, with sub-surface scattering. The smoothing varies to \"melt\" the wax.\n","likes":119,"published":1,"flags":16,"usePreview":0,"tags":["raymarching","subsurfacescattering","isosurface"],"hasliked":0,"parentid":"","parentname":""}}