{"ver":"0.1","info":{"id":"tlj3W1","date":"1561218090","viewed":143,"name":"Pink Cardioid","username":"Polygon","description":"Click to see how it's constructed from two points on a circle.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["cardioid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 uvToPx(vec2 uv) {\n    return uv * min(iResolution.x, iResolution.y) / 3.0 + iResolution.xy / 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord.x, iResolution.y - fragCoord.y), 0);\n    \n    fragColor = vec4(1,1,1,1) * (1.0 - fragColor.x) + vec4(1.0,0.1,0.3,2.0) * fragColor.x;\n    \n    vec2 uv = (fragCoord - iResolution.xy / 2.0) / (min(iResolution.x, iResolution.y) / 3.0);\n    \n    float fragsPerUnit = iResolution.y / 3.0;\n    \n    float c = -sin(iTime);\n    float a = -cos(2.0 * iTime) + cos(iTime);\n    float b = -c - sin(2.0 * iTime);\n    float d = 2.0 * sin(iTime / 2.0);\n    if (iTime == 0.0) {\n        a = 0.0;\n        b = 1.0;\n        c = 1.0;\n        d = 1.0;\n    }\n\n    if (iMouse.z > -0.0) {\n    float alpha = min(\n        max(\n        \tclamp((uv.x*uv.x + uv.y*uv.y - 1.0 - 30.0 / iResolution.x) * iResolution.x / 15.0, 0.0, 1.0),\n        \t1.0 - clamp((uv.x*uv.x + uv.y*uv.y - 1.0 + 30.0 / iResolution.x) * iResolution.x / 15.0, 0.0, 1.0)\n        ),\n        1.0 - clamp(15.0 / iResolution.x - (abs((a * uv.x + b * uv.y + c) / d)), 0.0, (6.0 / iResolution.x)) / (6.0 / iResolution.x)\n    );\n    fragColor.xyz *= alpha;\n    \n    alpha = min(\n        clamp(distance(fragCoord, uvToPx(vec2(sin(iTime), -cos(iTime)))) - 10.0, 0.0, 1.0),\n        clamp(distance(fragCoord, uvToPx(vec2(sin(2.0 * iTime), -cos(2.0 * iTime)))) - 10.0, 0.0, 1.0)\n    );\n    fragColor.xyz = fragColor.xyz * alpha + vec3(0.0, 0.8, 1.0) * (1.0 - alpha);\n    }\n    \n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//const float minLineWidth = 0.03;\n//const float lineFade = 40.0;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    vec2 uv = (fragCoord - iResolution.xy / 2.0) / (min(iResolution.x, iResolution.y) / 3.0);\n    fragColor.x *= 0.998;\n    \n    \n    float a = cos(2.0 * iTime) - cos(iTime);\n    float b = sin(iTime) - sin(2.0 * iTime);\n    float c = sin(iTime);\n    float d = 2.0 * sin(iTime / 2.0);\n    \n    if (iTime == 0.0) {\t//\n        a = 0.0;\t\t//\tCorner case that would usually\n        b = 1.0;\t\t//  lead to a 0/0 error\n        c = 1.0;\t\t//\n        d = 1.0;\t\t//\n    }\n    \n    vec2 point = 1.0 / 3.0 * vec2(\n        2.0 * sin(iTime) + sin(2.0 * iTime),\n        2.0 * cos(iTime) + cos(2.0 * iTime)\n    );\n    \n    \n    float dist = (a * uv.x + b * uv.y + c) / d;\n    float alpha = 0.02 / (400.0 / (dot(uv-point, uv-point)) * dist * dist + 1.0);\n    //float alpha = 0.02 / (1.0 + pow(max(lineFade * abs(dist / minLineWidth), lineFade) - lineFade, 2.0));\n    fragColor.x = alpha + fragColor.x * (1.0 - alpha);\n}","name":"Buffer A","description":"","type":"buffer"}]}