{"ver":"0.1","info":{"id":"lXBfWm","date":"1729528722","viewed":102,"name":"ArcTan(normalized vec)","username":"TinyTexel","description":"An arcus tangens implementation optimized for normalized inputs.","likes":6,"published":3,"flags":0,"usePreview":0,"tags":["atan","arctan","arcus","tangens"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n    An arcus tangens implementation optimized for normalized inputs.\n    ArcTan seems to be about 2x faster than atan, while atan is about 4.54x more precise\n    (those numbers depend on the implementation of atan, which might vary between platforms).\n    \n    The implementation of ArcTan applies a polynomial transfer function to cos(ang) before deviding sin(ang) by it.\n    This way we don't end up with tan(ang), but with ang itself: ang ~ sin(ang) / polyTF(cos(ang))\n    \n    This works well because ideally we would like to devide sin(ang) by sin(ang)/ang (instead of cos(ang)), \n    which can already be coarsly approximated by a linear remapping of cos(ang).\n    \n    ArcTan is C2-continuous.\n    \n    \n    red   : ArcTan(vec2(cos(ang), sin(ang)))\n    green :   atan(     sin(ang), cos(ang) )\n    \n    purple: cos(ang)\n    blue  : sin(ang)\n    \n    \n    Related:\n    \n        ArcTan Perf-Test: https://www.shadertoy.com/view/MXSfDm\n*/\n\n// dir: normalized vector | out: angle in radians [-Pi, Pi] (max abs error ~0.000000546448 rad)\nfloat ArcTan(vec2 dir)\n{\n    const float Pi = 3.14159265359;\n\n    float x = abs(dir.x);\n    float y =     dir.y;\n    \n    float u = 0.63662 + x * (0.405285 + x * (-0.0602976 + x * (0.0289292 + x * (-0.0162831 + (0.0075353 - 0.00178826 * x) * x))));\n    //float u = 0.63662 + x * (0.405285 + x * (-0.0602976 + (0.0261141 - 0.00772104 * x) * x));// max abs err ~0.0000454545 rad\n          \n    float f = y / u;\n    \n    if(dir.x < 0.0) f = (dir.y < 0.0 ? -Pi : Pi) - f;\n    \n    return f;\n}\n\nfloat ArcTan11(vec2 dir)// == ArcTan(dir) / Pi\n{\n    float x = abs(dir.x);\n    float y =     dir.y;\n    \n    float u = 2.0 + x * (1.27324 + x * (-0.189431 + x * (0.0908837 + x * (-0.0511549 + (0.0236728 - 0.005618 * x) * x))));\n    //float u = 2.0 + x * (1.27324 + x * (-0.189431 + (0.08204 - 0.0242564 * x) * x));\n          \n    float f = y / u;\n    \n    if(dir.x < 0.0) f = (dir.y < 0.0 ? -1.0 : 1.0) - f;\n    \n    return f;\n}\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n\tvec2 uv = uv0 - 0.5;\n    uv0 += .0;\n    \n    vec2 tex = uv0;\n    tex -= iResolution.xy * 0.5;\n    tex /= iResolution.xx * 0.125;\n\n    tex *= 1.6;\n    \n    vec3 col = vec3(0.0);\n    \n\tcol = mix(vec3(1.0), vec3(0.95), Grid(tex.xy * 4.0, 0.0));        \n\tcol = mix(col, vec3(0.6), Grid(tex.xy * 1.0, 0.0));        \n\tcol = mix(col, vec3(0.125), Cross(tex.xy * 1.0, 0.)); \t\n    \n    \n    float ang = tex.x;\n    vec2 vec = vec2(cos(ang), sin(ang));\n    \n    col = mix(col, vec3(0.5, 0.5 , 1.0), Graph((vec.x) -tex.y, 0.5));// cos - purple\n    col = mix(col, vec3(0.5, 0.75, 1.0), Graph((vec.y) -tex.y, 0.5));// sin - blue\n    \n    col = mix(col, vec3(0.6, 1.0, 0.75), Graph(atan(vec.y, vec.x) -tex.y, 2.5));// atan - green (thick)\n    col = mix(col, vec3(1.0, 0.0, 0.0), Graph(ArcTan(vec) -tex.y, 0.));// ArcTan - red\n\n  #if 0\n    // visualize approximation error\n    #if 0\n    // atan\n    col = mix(col, vec3(0.5, .0, 1.0), Graph(abs(ang - atan(vec.y, vec.x))*8300000.0 -tex.y, 1.5));\n    #else\n    // ArcTan\n    col = mix(col, vec3(0.5, .0, 1.0), Graph(abs(ang - ArcTan(vec))*1830000.0 -tex.y, 1.5));\n    #endif\n  #endif\n  \n    #if 1\n    {\n        vec2 s = (uv0/iResolution.xy*2.0-1.0);\n        s.x = 1.0-Pow2(s.x);    s.y = 1.0-Pow2(s.y);\n        col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\n    }\n    #endif\n    \n    outCol = vec4(GammaEncode(clamp01(col)), 1.0);    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define Frame float(iFrame)\n#define Time iTime\n#define PixelCount iResolution.xy\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define rsqrt inversesqrt\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\nconst float Pi2  = Pi * 2.0;\nconst float RcpPi= 1.0 / Pi;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\nfloat ddxyLen(float v) { return length(vec2(dFdx(v), dFdy(v))); }\nfloat ddxyRcpLen(float v) { return rsqrt( Pow2(dFdx(v)) + Pow2(dFdy(v)) ); }\n\n\nfloat rescale(float v) { return v * ddxyRcpLen(v); }\n\nfloat Graph(float f, float b)\n{\n    return clamp01(1.0 - (abs(rescale(f))-0.5-b)); \n}\n\n\nfloat Line(float u, float b) { return Graph(u, b); }\nfloat Lines(float u, float b) { return Graph(sin(u * Pi), b); }\n\nfloat Grid(vec2 uv, float b)\n{\n    float xl = Lines(uv.x, b);    \n    float yl = Lines(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Cross(vec2 uv, float b)\n{\n    float xl = Line(uv.x, b);    \n    float yl = Line(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Dot(vec2 sp, vec2 dp, float dr)\n{\n    float v = length(sp - dp) - dr;\n    \n    if(v > dr) return 0.0;\n    \n    v *= ddxyRcpLen(v);\n    v = 1.0 - clamp(v * 1.0, 0.0, 1.0);\n    \n    return v;\n}\n","name":"Common","description":"","type":"common"}]}