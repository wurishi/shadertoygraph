{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//#define PURE_BRANCHLESS\n// math const\n#define MAX_RAY_STEPS 64\nconst float DEG_TO_RAD = 0.017453292519943295769236907684886127134428718885417;\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\n\tvec2 rg = texture( iChannel0,(uv+0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.x);\n}\n// height map\nfloat voxel( vec4 pos ) {\n\treturn clamp(noise(pos.xyz*2.0)-0.2+(0.2*cos(iTime)),0.2,0.63);\n}\nfloat voxel( vec3 pos ) {\n\t\n\treturn clamp(noise(pos*2.0)-0.2+(0.2*cos(iTime)),0.2,0.63);\n}\n\nbool sphereIntersectPOW(vec3 rayDir, vec3 rayOrigin, out float t1, in vec4 sCenter)\n{\n\tvec3 ro = rayOrigin - sCenter.xyz ;\n   \tfloat B = dot(rayDir,ro);//rd.x+rd.y+rd.z;\n   \tfloat C = dot(ro,ro) ;\n   \tfloat D = B*B - C + sCenter.w ;\n    return bool(t1 = (D>0.0) ? -B-pow(D,0.5) : 0.0); //since determinant of quadratic equation <0 so no solution and hence no intersection\n}\n\nbool raystep(inout vec3 grid, inout vec4 e, const vec3 b, const vec3 s, const vec3 dir){\n\t\n\tif ( 0.61 < voxel( vec4(grid.xyz,\n\t\t\t\t\t  (e+= ( e.x < 0.0 ) \n\t\t\t\t\t   ? ( e.y < 0.0 ) \n\t\t\t\t\t   ? vec4( b.y, b.z, 0.0,(grid.x+=s.x))\n\t\t\t\t\t   : vec4( 0.0, b.x, b.y,(grid.z+=s.z))\n\t\t\t\t\t   : ( e.z < 0.0 ) \n\t\t\t\t\t   ? vec4( 0.0, b.x, b.y,(grid.z+=s.z))\n\t\t\t\t\t   : vec4( b.x, 0.0,-b.z,(grid.y+=s.y))\n\t\t\t\t\t  ))))\n\t{\n\t\tfloat tnear;\n\t\tif (sphereIntersectPOW( dir, vec3( 0.0, 0.0, 27.0 ), tnear, vec4(floor(grid.xyz),.50))){\n\t\t\te.xyz=dir*tnear;\n\t\t\te.w=tnear;\n\t\t\treturn true;\n\t\t}else\n\t\t\treturn false;\n\t}else\n\t{\n\t\treturn false;\n\t}\n}\n// improvement based on fb39ca4's implementation to remove most of branches :\n// https://www.shadertoy.com/view/4dX3zl\n// min | x < y | y < z | z < x\n//  x  |   1   |   -   |   0  \n//  y  |   0   |   1   |   -  \n//  z  |   -   |   0   |   1  \nfloat ray_vs_world( vec3 pos, vec3 dir, out vec3 center ) {\n\t// grid space\n\tvec3 grid = vec3( pos );\n\tvec3 s = sign( dir );\n\tvec3 corner = max( s, vec3( 0.0 ) );\n\tvec3 a = vec3(abs(dir));\n\tvec3 b = a+a;\n\tb.x=-b.x;\n\t// dda using addition only\n\t// light on ALU\n\tfloat c=0.0;\n\tbool hit=false;\n\tvec4 e = vec4(a.y-a.x,  a.z-a.x, a.y-a.z,0.0);\n    for (int i = 0; i < MAX_RAY_STEPS; i++)\n\t{\n\t\t#ifdef PURE_BRANCHLESS\n\t\thit = (hit == false) ? raystep(grid,e,b,s,dir) : true;\n\t\t#else\n\t\tif (hit) {continue;}\n\t\thit = (hit == false) ? raystep(grid,e,b,s,dir) : true;\n\t\t#endif\n    } \n\t\n\tcenter = grid.xyz + vec3( 0.5 );\n\treturn e.w;\n}\n\n// pitch, yaw\nmat3 rot3xy( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\nvec3 ray_dir_spherical( float fov, vec2 size, vec2 pos ) {\n\tvec2 angle = ( pos - vec2( 0.5 ) * size ) * ( fov / size.y * DEG_TO_RAD );\n\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn normalize( vec3( c.y * s.x, s.y, -c.y * c.x ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// default ray dir\n\tvec3 dir = ray_dir( 60.0, iResolution.xy, fragCoord.xy );\n\t\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 27.0 );\n\n\t// rotate camera\n\tmat3 rot = rot3xy( vec2( -DEG_TO_RAD * 10.0, sin(iTime/6.0)-DEG_TO_RAD * 24.0 ) );\n\tdir = rot * dir;\n\tdir = normalize( dir );\n\t//vec3 mask;\n\tvec3 center = vec3(0.0);\n\n\tfloat depth = ray_vs_world( eye, dir,center );\n\n\tvec3 p = eye + (dir) * depth;\n\tdepth=depth/120.0;\n\t//vec3 n = -mask * sign( dir );\n\tfloat n = ( noise(p.xyz*56.0));\n\tn/=8.0;\n\tif (depth <60.0)\n\tfragColor = vec4( n+depth,n+depth,n+depth, 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lssSzn","date":"1396930175","viewed":581,"name":"voxgrid","username":"Panoptics","description":"voxel traversal with addition only.  Inner loop uses cmovs. You can try pushing this out to 256 loops. I can get 512 on my gpu before it stutters too much.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["voxel"],"hasliked":0,"parentid":"","parentname":""}}