{"ver":"0.1","info":{"id":"NsGGzc","date":"1631855263","viewed":258,"name":"Fractal Raymarching test","username":"samk9632","description":"fractal","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 rotate(vec3 pos, vec2 rotation) {\n    vec2 m4 = vec2(length(pos.xz), length(pos.xyz));\n\n    vec2 angle = vec2(acos(pos.x/m4.x), asin(pos.z/m4.y));\n    float l = length(pos);\n    vec3 poss = pos;\n    float xx = poss.x*cos(rotation.y)+poss.z*sin(rotation.y);\n    float yy = poss.y;\n    float zz = -pos.x*sin(rotation.y)+poss.z*cos(rotation.y);\n    \n    return vec3(xx, yy, zz);\n}\n\nfloat DE(vec3 pos, int Iterations, float Power, float xRot, bool limit) {\n    vec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n    vec3 c = vec3(sin(iTime*0.17), cos(iTime*0.193), sin(iTime*0.237));\n    // convert to polar coordinates\n\tfloat phi1 = atan(z.y,z.x)+xRot;\n    // convert back to cartesian coordinates\n    z = vec3(length(z.xy)*vec2(sin(phi1), cos(phi1)), z.z);\n    c = z;\n\tfor (int i = 0; i < Iterations ; i++) {\n\t\tr = length(z);\n\t\tif (r>2.0) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow(r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow(r, Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=c;\n\t}\n    if (limit == true) {\n        return max(0.5*log(r)*r/dr, 0.0009);\n    } else {\n        return abs(0.5*log(r)*r/dr);\n    }\n}\n\nvec3 rayCast(vec3 dir, vec3 pos, float xRot, vec2 coord, float threshold, int maxSteps, vec3 lightDir, int fractalSteps, float degree) {\n    float j = 0.0;\n    vec3 p = pos;\n    int i = 0;\n    bool intersect = false;\n    float f;\n    float lightInfo = 1.0;\n    vec3 normal = vec3(0.0);\n    float ambientLight = 0.1;\n    float a = dot(dir, dir);\n    float b = 2.0*dot(dir, pos);\n    float c = dot(pos, pos) - pow(2.0, 2.0);\n    float discriminant = b*b-4.0*a*c;\n    vec3 inPos = (-b - sqrt(discriminant))/(2.0*a)*dir+pos;\n    vec3 outPos = (-b + sqrt(discriminant))/(2.0*a)*dir+pos;\n    // convert to polar coordinates\n\tfloat phi1 = atan(lightDir.y,lightDir.x)+xRot;\n    // convert back to cartesian coordinates\n    lightDir = vec3(length(lightDir.xy)*vec2(sin(phi1), cos(phi1)), lightDir.z);\n    p = inPos;\n    if (discriminant > 0.0) {\n        for (int i = 0; i < maxSteps && length(p) < 2.01; i++) {\n            f = DE(p, fractalSteps, degree, xRot, false);\n            p += dir*f*0.9;\n\n            if (f < threshold*1.0) {\n                float fa = 3.1415926;\n                float fb = 3.1415926;\n                //get normals\n                float nx = DE(p - threshold*vec3(1.0, 0.0, 0.0), fractalSteps, degree, xRot, false);\n                float ny = DE(p - threshold*vec3(0.0, 1.0, 0.0), fractalSteps, degree, xRot, false);\n                float nz = DE(p - threshold*vec3(0.0, 0.0, 1.0), fractalSteps, degree, xRot, false);\n                normal = -normalize((vec3(nx, ny, nz) - f));\n                i = maxSteps + 1;\n                vec3 l = vec3(0.0);\n                \n                intersect = true;\n            }\n            j++;\n        }\n        if (intersect == true) {\n        f = 0.0;\n        vec3 l;\n        float fa = 3.1415;\n        float fb = 3.1415;\n            for (int k = 0; k < maxSteps && length(p+l) < 2.0; k++) {\n                float ff = DE(l+p, fractalSteps, degree, xRot, true);\n                f += ff;\n                l = -f * lightDir;\n                fa = ff/f;\n                //if (k > 1) {\n                    fa = min(fa, fb);\n                    fb = fa;\n                    lightInfo = min(clamp(fa*10.0, ambientLight, 1.0), (clamp(-dot(normal, lightDir), 0.0, 1.0)*(1.0-ambientLight)+ambientLight));\n                    \n                //}\n                if (k > 0 && f < threshold) {\n                    lightInfo = ambientLight;\n                    k = maxSteps;\n                }\n\n\n\n            }\n            return vec3(5.0/pow(1.02, j)*lightInfo);\n            return normal;\n        } else {\n            return vec3(0.0);\n        }\n        \n    } else {\n        return vec3(0.0);\n    }\n        \n    \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pi = 3.1415926;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouse = (iMouse.xy/iResolution.x-0.5);\n    float x = fragCoord.x/iResolution.x-0.5;\n    float y = (fragCoord.y-0.5*iResolution.y)/iResolution.x;\n    \n    //RayCasting\n    float dof = 1.0;\n    float r = 5.0;\n    float s = 10.0;\n    vec3 camPos = rotate(vec3(r, 0.0, 0.0), -vec2(-iTime*0.2, -s*(mouse.y+pi/2.0)));\n    vec3 lightDir = vec3(sin(0.5*iTime), cos(0.5*iTime), sin(0.327*iTime));\n    lightDir /= length(lightDir);\n    \n    vec3 camDir = rotate(vec3(-1.0, dof*x, dof*y), vec2(iTime*0.2, s*(mouse.y+pi/2.0)));\n    \n    // Time varying pixel color\n    vec3 col = rayCast(camDir, camPos, -s*mouse.x, fragCoord, 0.001, 75, lightDir, 12, 8.0);\n    \n    //col = (log(1.+col));\n    //col = clamp(col,0.,1.);\n    col *= 1.0;\n    col = col/(col+vec3(1.0));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}