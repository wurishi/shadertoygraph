{"ver":"0.1","info":{"id":"MtcfDr","date":"1539220417","viewed":910,"name":"CIE Daylight CCT White Balance","username":"Tynach","description":"White balances by color temperature along daylight locus. Click anywhere to select temperature; a gradient along the bottom shows the white point being adapted to. Darkens image only to fit white point within gamut.\n\nLeft: 4000K\nCenter: 6500K\nRight: 9000K","likes":12,"published":1,"flags":0,"usePreview":1,"tags":["d","light","color","blackbody","white","srgb","temperature","balance","cie","cct","adaptation","d50","d65","daylight","illuminant"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*********************************************************************\n * Scroll to just above mainImage() at the bottom to adjust settings *\n *********************************************************************/\n\nprecision highp float;\n\n#define PI 3.1415926535897932384626433832795\n#define EULER 2.7182818284590452353602874713527\n\n\n/*\n * Structures\n */\n\n// Parameters for transfer characteristics (gamma curves)\nstruct transfer {\n\t// Exponent used to linearize the signal\n\tfloat power;\n\n\t// Offset from 0.0 for the exponential curve\n\tfloat off;\n\n\t// Slope of linear segment near 0\n\tfloat slope;\n\n\t// Values below this are divided by slope during linearization\n\tfloat cutoffToLinear;\n\n\t// Values below this are multiplied by slope during gamma correction\n\tfloat cutoffToGamma;\n};\n\n// Parameters for a colorspace\nstruct rgb_space {\n\t// Chromaticity coordinates (xyz) for Red, Green, and Blue primaries\n\tmat4 primaries;\n\n\t// Chromaticity coordinates (xyz) for white point\n\tvec4 white;\n\n\t// Linearization and gamma correction parameters\n\ttransfer trc;\n};\n\n\n/*\n * Preprocessor 'functions' that help build colorspaces as constants\n */\n\n// Turns 6 chromaticity coordinates into a 3x3 matrix\n#define Primaries(r1, r2, g1, g2, b1, b2)\\\n\tmat4(\\\n\t\t(r1), (r2), 1.0 - (r1) - (r2), 0,\\\n\t\t(g1), (g2), 1.0 - (g1) - (g2), 0,\\\n\t\t(b1), (b2), 1.0 - (b1) - (b2), 0,\\\n\t\t0, 0, 0, 1)\n\n// Creates a whitepoint's xyz chromaticity coordinates from the given xy coordinates\n#define White(x, y)\\\n\tvec4(vec3((x), (y), 1.0 - (x) - (y))/(y), 1)\n\n// Automatically calculate the slope and cutoffs for transfer characteristics\n#define Transfer(po, of)\\\ntransfer(\\\n\t(po),\\\n\t(of),\\\n\t(pow((po)*(of)/((po) - 1.0), 1.0 - (po))*pow(1.0 + (of), (po)))/(po),\\\n\t(of)/((po) - 1.0),\\\n\t(of)/((po) - 1.0)*(po)/(pow((po)*(of)/((po) - 1.0), 1.0 - (po))*pow(1.0 + (of), (po)))\\\n)\n\n// Creates a scaling matrix using a vec4 to set the xyzw scalars\n#define diag(v)\\\n\tmat4(\\\n\t\t(v).x, 0, 0, 0,\\\n\t\t0, (v).y, 0, 0,\\\n\t\t0, 0, (v).z, 0,\\\n\t\t0, 0, 0, (v).w)\n\n// Creates a conversion matrix that turns RGB colors into XYZ colors\n#define rgbToXyz(space)\\\n\t(space.primaries*diag(inverse((space).primaries)*(space).white))\n\n// Creates a conversion matrix that turns XYZ colors into RGB colors\n#define xyzToRgb(space)\\\n\tinverse(rgbToXyz(space))\n\n\n/*\n * Chromaticities for RGB primaries\n */\n\n// CIE 1931 RGB\nconst mat4 primariesCie = Primaries(\n\t0.72329, 0.27671,\n\t0.28557, 0.71045,\n\t0.15235, 0.02\n);\n\n// Identity RGB\nconst mat4 primariesIdentity = mat4(1.0);\n\n// Original 1953 NTSC primaries\nconst mat4 primariesNtsc = Primaries(\n\t0.67, 0.33,\n\t0.21, 0.71,\n\t0.14, 0.08\n);\n\n// European Broadcasting Union primaries for SDTV and Rec. 601 (625 lines)\nconst mat4 primariesEbu = Primaries(\n\t0.64, 0.33,\n\t0.29, 0.6,\n\t0.15, 0.06\n);\n\n// P22 Phosphor primaries (allegedly; only found one source)\n// Used by older versions of SMPTE-C, before specific chromaticities were given\nconst mat4 primariesP22 = Primaries(\n\t0.61, 0.342,\n\t0.298, 0.588,\n\t0.151, 0.064\n);\n\n// Modern day SMPTE-C primaries, used in modern NTSC (Rec. 601) and SMPTE-240M\nconst mat4 primariesSmpteC = Primaries(\n\t0.63, 0.34,\n\t0.31, 0.595,\n\t0.155, 0.07\n);\n\n// Never-popular, antiquated, and idealized 'HDTV' primaries based mostly on the\n// 1953 NTSC colorspace. SMPTE-240M officially used the SMPTE-C primaries\nconst mat4 primaries240m = Primaries(\n\t0.67, 0.33,\n\t0.21, 0.71,\n\t0.15, 0.06\n);\n\n// Alleged primaries for old Sony TVs with a very blue whitepoint\nconst mat4 primariesSony = Primaries(\n\t0.625, 0.34,\n\t0.28, 0.595,\n\t0.155, 0.07\n);\n\n// Rec. 709 (HDTV) and sRGB primaries\nconst mat4 primaries709 = Primaries(\n\t0.64, 0.33,\n\t0.3, 0.6,\n\t0.15, 0.06\n);\n\n// DCI-P3 primaries\nconst mat4 primariesDciP3 = Primaries(\n\t0.68, 0.32,\n\t0.265, 0.69,\n\t0.15, 0.06\n);\n\n// Rec. 2020 UHDTV primaries\nconst mat4 primaries2020 = Primaries(\n\t0.708, 0.292,\n\t0.17, 0.797,\n\t0.131, 0.046\n);\n\n// If the HUNT XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat4 primariesHunt = Primaries(\n\t0.8374, 0.1626,\n\t2.3, -1.3,\n\t0.168, 0.0\n);\n\n// If the CIECAM97_1 XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat4 primariesCiecam971 = Primaries(\n\t0.7, 0.306,\n\t-0.357, 1.26,\n\t0.136, 0.042\n);\n\n// If the CIECAM97_2 XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat4 primariesCiecam972 = Primaries(\n\t0.693, 0.316,\n\t-0.56, 1.472,\n\t0.15, 0.067\n);\n\n// If the CIECAM02 XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat4 primariesCiecam02 = Primaries(\n\t0.711, 0.295,\n\t-1.476, 2.506,\n\t0.144, 0.057\n);\n\n// LMS primaries as chromaticity coordinates, computed from\n// http://www.cvrl.org/ciepr8dp.htm, and\n// http://www.cvrl.org/database/text/cienewxyz/cie2012xyz2.htm\n/*const mat3 primariesLms = Primaries(\n\t0.73840145, 0.26159855,\n\t1.32671635, -0.32671635,\n\t0.15861916, 0.0\n);*/\n\n// Same as above, but in fractional form\nconst mat4 primariesLms = Primaries(\n\t194735469.0/263725741.0, 68990272.0/263725741.0,\n\t141445123.0/106612934.0, -34832189.0/106612934.0,\n\t36476327.0/229961670.0, 0.0\n);\n\n\n/*\n * Chromaticities for white points\n */\n\n// Standard Illuminant C. White point for the original 1953 NTSC color system\nconst vec4 whiteC = White(0.310063, 0.316158);\n\n// Standard illuminant E (also known as the 'equal energy' white point)\nconst vec4 whiteE = White(1.0/3.0, 1.0/3.0);\n\n// Alleged whitepoint to use with the P22 phosphors (D65 might be more proper)\nconst vec4 whiteP22 = White(0.313, 0.329);\n\n// Standard illuminant D65. Note that there are more digits here than specified\n// in either sRGB or Rec 709, so in some cases results may differ from other\n// software. Color temperature is roughly 6504 K (originally 6500K, but complex\n// science stuff made them realize that was innaccurate)\nconst vec4 whiteD65 = White(0.312713, 0.329016);\n\n// Standard Illuminant D65 according to the Rec. 709 and sRGB standards\nconst vec4 whiteD65S = White(0.3127, 0.3290);\n\n// Standard illuminant D50. Just included for the sake of including it. Content\n// for Rec. 709 and sRGB is recommended to be produced using a D50 whitepoint.\n// For the same reason as D65, the color temperature is 5003 K instead of 5000 K\nconst vec4 whiteD50 = White(0.34567, 0.35850);\n\n// Standard Illuminant D50 according to ICC  specs\nconst vec4 whiteD50I = White(0.3457, 0.3585);\n\n// White point for DCI-P3 Theater\nconst vec4 whiteTheater = White(0.314, 0.351);\n\n// Very blue white point for old Sony televisions. Color temperature of 9300 K.\n// Use with the 'primariesSony' RGB primaries defined above\nconst vec4 whiteSony = White(0.283, 0.298);\n\n\n/*\n * Gamma curve parameters\n */\n\n// Linear gamma\nconst transfer gam10 = transfer(1.0, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 1.8; not linear near 0. This is what older Apple devices used\nconst transfer gam18 = transfer(1.8, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.2; not linear near 0. Was defined abstractly to be used by early\n// NTSC systems, before SMPTE 170M was modified to specify a more exact curve.\n// Also what Adobe RGB uses\nconst transfer gam22 = transfer(2.2, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.4; not linear near 0. Used as the gamma value for BT.1886\nconst transfer gam24 = transfer(2.4, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.5; not linear near 0. Approximately what old Sony TVs used\nconst transfer gam25 = transfer(2.5, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.8; not linear near 0. Loosely defined gamma for European SDTV\nconst transfer gam28 = transfer(2.8, 0.0, 1.0, 0.0, 0.0);\n\n// Modern SMPTE 170M, as well as Rec. 601, Rec. 709, and a rough approximation\n// for Rec. 2020 content as well. Do not use with Rec. 2020 if you work with\n// high bit depths!\nconst transfer gam170m = transfer(1.0/0.45, 0.099, 4.5, 0.0812, 0.018);\n\n// Proper Rec. 2020 gamma, made using the new Transfer macro\nconst transfer gam2020 = Transfer(1.0/0.45, 0.099);\n\n// Gamma for sRGB\nconst transfer gamSrgb = transfer(2.4, 0.055, 12.92, 0.04045, 0.0031308);\n\n// A more continuous version of sRGB, for high bit depths\nconst transfer gamSrgbHigh = Transfer(2.4, 0.055);\n\n// Gamma for the CIE L*a*b* Lightness scale\nconst transfer gamLab = transfer(3.0, 0.16, 243.89/27.0, 0.08, 216.0/24389.0);\n\n\n/*\n * RGB Colorspaces\n */\n\n// CIE 1931 RGB\nconst rgb_space Cie1931 = rgb_space(primariesCie, whiteE, gam10);\n\n// Identity RGB\nconst rgb_space Identity = rgb_space(primariesIdentity, whiteE, gam10);\n\n// Original 1953 NTSC\nconst rgb_space Ntsc = rgb_space(primariesNtsc, whiteC, gam22);\n\n// Mostly unused and early HDTV standard (SMPTE 240M)\nconst rgb_space Smpte240m = rgb_space(primaries240m, whiteD65S, gam22);\n\n// European Broadcasting Union SDTV\nconst rgb_space Ebu = rgb_space(primariesEbu, whiteD65S, gam28);\n\n// Original, imprecise colorspace for NTSC after 1987 (probably incorrect)\nconst rgb_space SmpteC = rgb_space(primariesP22, whiteD65S, gam22);\n\n// Modern SMPTE \"C\" colorimetry\nconst rgb_space Smpte170m = rgb_space(primariesSmpteC, whiteD65S, gam170m);\n\n// Old Sony displays using high temperature white point\nconst rgb_space Sony = rgb_space(primariesSony, whiteSony, gam25);\n\n// Rec. 709 (HDTV)\nconst rgb_space Rec709 = rgb_space(primaries709, whiteD65S, gam170m);\n\n// sRGB (mostly the same as Rec. 709, but different gamma and full range values)\nconst rgb_space Srgb = rgb_space(primaries709, whiteD65S, gamSrgb);\n\n// DCI-P3 D65\nconst rgb_space DciP3D65 = rgb_space(primariesDciP3, whiteD65S, gam170m);\n\n// DCI-P3 D65\nconst rgb_space DciP3Theater = rgb_space(primariesDciP3, whiteTheater, gam170m);\n\n// Rec. 2020\nconst rgb_space Rec2020 = rgb_space(primaries2020, whiteD65S, gam170m);\n\n// Hunt primaries, balanced against equal energy white point\nconst rgb_space HuntRgb = rgb_space(primariesHunt, whiteE, gam10);\n\n// CIE CAM 1997 primaries, balanced against equal energy white point\nconst rgb_space Ciecam971Rgb = rgb_space(primariesCiecam971, whiteE, gam10);\n\n// CIE CAM 1997 primaries, balanced against equal energy white point and linearized\nconst rgb_space Ciecam972Rgb = rgb_space(primariesCiecam972, whiteE, gam10);\n\n// CIE CAM 2002 primaries, balanced against equal energy white point\nconst rgb_space Ciecam02Rgb = rgb_space(primariesCiecam02, whiteE, gam10);\n\n// Lms primaries, balanced against equal energy white point\nconst rgb_space LmsRgb = rgb_space(primariesLms, whiteE, gam10);\n\n\n/*\n * Colorspace conversion functions\n */\n\n// Converts RGB colors to a linear light scale\nvec4 toLinear(vec4 color, const transfer trc)\n{\n\tbvec4 cutoff = lessThan(color, vec4(trc.cutoffToLinear));\n\tbvec4 negCutoff = lessThanEqual(color, vec4(-1.0*trc.cutoffToLinear));\n\tvec4 higher = pow((color + trc.off)/(1.0 + trc.off), vec4(trc.power));\n\tvec4 lower = color/trc.slope;\n\tvec4 neg = -1.0*pow((color - trc.off)/(-1.0 - trc.off), vec4(trc.power));\n\n\tvec4 result = mix(higher, lower, cutoff);\n\treturn mix(result, neg, negCutoff);\n}\n\n// Gamma-corrects RGB colors to be sent to a display\nvec4 toGamma(vec4 color, const transfer trc)\n{\n\tbvec4 cutoff = lessThan(color, vec4(trc.cutoffToGamma));\n\tbvec4 negCutoff = lessThanEqual(color, vec4(-1.0*trc.cutoffToGamma));\n\tvec4 higher = (1.0 + trc.off)*pow(color, vec4(1.0/trc.power)) - trc.off;\n\tvec4 lower = color*trc.slope;\n\tvec4 neg = (-1.0 - trc.off)*pow(-1.0*color, vec4(1.0/trc.power)) + trc.off;\n\n\tvec4 result = mix(higher, lower, cutoff);\n\treturn mix(result, neg, negCutoff);\n}\n\n// Calculate Standard Illuminant Series D light source XYZ values\nvec4 temperatureToXyz(float temperature)\n{\n\t// Calculate terms to be added up. Since only the coefficients aren't\n\t// known ahead of time, they're the only thing determined by mix()\n\tfloat x = dot(mix(\n\t\tvec4(0.244063, 99.11, 2967800.0, -4607000000.0),\n\t\tvec4(0.23704, 247.48, 1901800.0, -2006400000.0),\n\t\tbvec4(temperature > 7000.0)\n\t)/vec4(1, temperature, pow(temperature, 2.0), pow(temperature, 3.0)), vec4(1));\n\n\treturn White(x, -3.0*pow(x, 2.0) + 2.87*x - 0.275);\n}\n\n\n/*\n * Settings\n */\n\n// Minimum temperature in the range (defined in the standard as 4000)\nconst float minTemp = 4000.0;\n\n// Maximum temperature in the range (defined in the standard as 25000)\nconst float maxTemp = 9000.0;\n\n// Display colorspace\nconst rgb_space display = Srgb;\n\n// XYZ conversion matrices for the display colorspace\nconst mat4 toXyz = rgbToXyz(display);\nconst mat4 toRgb = xyzToRgb(display);\n\n// LMS conversion matrices for white point adaptation\nconst mat4 toLms = xyzToRgb(LmsRgb);\nconst mat4 frLms = rgbToXyz(LmsRgb);\n\n\n// Main function\nvoid mainImage(out vec4 color, in vec2 coord)\n{\n\t// Calculate color temperature for pixel\n\tvec2 uv = coord/iResolution.xy;\n\tfloat temp = uv.x*(maxTemp - minTemp) + minTemp;\n\n\t// Calculate color from temperature\n\tvec4 tempColor = toRgb*temperatureToXyz(temp);\n\n\t// Darken values to fit within gamut (for temperature chart on bottom)\n\ttempColor /= max(tempColor.r, max(tempColor.g, tempColor.b));\n\n\t// Calculate texture color\n\tvec2 texRes = vec2(textureSize(iChannel0, 0).xy);\n\tvec2 texCoord = (coord + vec2(0, -32))/texRes*texRes.x/iResolution.x;\n\tvec4 texColor = texture(iChannel0, texCoord);\n\ttexColor = toLinear(texColor, display.trc);\n\n\t// Calculate temperature conversion\n\tfloat selected = iMouse == vec4(0.0, 0.0, -0.0, -0.0)\n\t                 ? (6500.0 - minTemp)/(maxTemp - minTemp)\n\t                 : iMouse.x/iResolution.x;\n\n\tvec4 convWhite = temperatureToXyz(selected*(maxTemp - minTemp) + minTemp);\n\tmat4 adapt = toRgb*frLms*diag((toLms*convWhite)/(toLms*display.white))*toLms*toXyz;\n\ttexColor = adapt*texColor;\n\n\t// Darken values to fit within gamut (for texture)\n\tvec4 newWhite = adapt*vec4(1);\n\ttexColor.rgb /= max(newWhite.r, max(newWhite.g, newWhite.b));\n\n\tcolor = mix(tempColor, texColor, bvec4(coord.y > 32.0));\n\n\t// Convert to display gamma curve\n\tcolor = toGamma(color, display.trc);\n}","name":"Image","description":"","type":"image"}]}