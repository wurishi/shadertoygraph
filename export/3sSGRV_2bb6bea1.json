{"ver":"0.1","info":{"id":"3sSGRV","date":"1549303561","viewed":483,"name":"Raymarching sphere/shadow/normal","username":"darkeclipz","description":"// http://blog.hvidtfeldts.net/index.php/2011/06/distance-estimated-3d-fractals-part-i/\n// https://iquilezles.org/articles/distfunctions/distfunctions.htm","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// http://blog.hvidtfeldts.net/index.php/2011/06/distance-estimated-3d-fractals-part-i/\n// https://iquilezles.org/articles/distfunctions\n#define MaxRaySteps 128.\n#define MaxShadowRaySteps 64.\n#define MinDistance 0.0001\n#define R iResolution.xy\n\nstruct hit { float dist; vec3 n; bool shadow; };\n\nfloat SphereDE(vec3 z, float r) {\n\treturn max(.0, length(z) - r);    \n}\n\nfloat SphereSDE(vec3 z, float r) {\n\treturn length(z) - r;    \n}\n\nfloat YPlaneDE(vec3 z, float y) {\n    return z.y - y;\n}\n\nfloat scene(vec3 p) {\n    return min(YPlaneDE(p, -0.6), \n           min(SphereSDE(p, 0.5), \n               SphereSDE(p - vec3(.8*cos(iTime),0.5,-.8*sin(iTime)), 0.1)));\n}\n\nfloat sceneShadow(vec3 p) {\n    return min(YPlaneDE(p, -0.6), SphereSDE(p, 0.5));\n}\n\nbool traceShadow(vec3 from, vec3 direction) {\n    float totalDistance = 0.;\n\tfloat steps;\n    for(steps=0.; steps < MaxShadowRaySteps; steps++) {\n    \tvec3 p = from + totalDistance * direction;    \n        float dist = sceneShadow(p);\n        totalDistance += dist*.99;\n        if(dist < MinDistance) {\n        \treturn true;\n        }\n    }\n    return false;\n}\n\nhit trace(vec3 from, vec3 direction) {\n\tfloat totalDistance = 0.0;\n\tfloat steps;\n    bool shadow = false;\n    vec3 n = vec3(0);\n\tfor (steps=0.; steps < MaxRaySteps; steps++) {\n\t\tvec3 p = from + totalDistance * direction;\n\t\tfloat dist = scene(p);\n\t\ttotalDistance += dist;\n        if (dist < MinDistance) {\n            float h = 0.0001;\n            vec2 k = vec2(1,-1);\n            n = normalize( k.xyy*scene( p + k.xyy*h ) + \n                           k.yyx*scene( p + k.yyx*h ) + \n                           k.yxy*scene( p + k.yxy*h ) + \n                           k.xxx*scene( p + k.xxx*h ) ); \n            vec3 lp = vec3(.8*cos(iTime),0.5,-.8*sin(iTime));\n            shadow = traceShadow(p+0.05*n, lp-p);\n            break;\n        }\n\t}\n    \n    hit result = hit(totalDistance, n, shadow);\n\treturn result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-R)/iResolution.y;\n    vec3 o = vec3(0,0,-5);\n    vec3 r = normalize(vec3(uv, 0.) - o);\n    hit h = trace(o, r);\n    vec3 p = o + h.dist*r;\n    vec3 lightPos = vec3(.8*cos(iTime),0.5,-.8*sin(iTime));\n    float dist = length(lightPos - p);\n    vec3 col = (0.5*h.n+1.) * vec3(1./(4.*dist*dist));\n    if(h.shadow) col = mix(col, vec3(0), 0.5);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}