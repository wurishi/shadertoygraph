{"ver":"0.1","info":{"id":"X3lBWB","date":"1728882377","viewed":95,"name":"AleksandrovMandelbulb_copy","username":"kosalos","description":"based on mandelbulb by Aleksandrov.   Thank you.\nhttps://fractalforums.org/fractal-institute/47/formulas-of-aleksandrov/656\n","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["raymarching","3dfractal"],"hasliked":0,"parentid":"l3fBDB","parentname":"BoneMandel_copy"},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int maxSteps = 5;\nfloat power = 3.46;\nvec3 julia = vec3(0.6,0.3,0.3);\n\nvec3 camera = vec3(-0.07, -1.2, -2.1205378);\nvec3 aim = vec3(0., 0.6, 1.);\nfloat ostrength = 0.;\nfloat ocycle = 0.;\nvec4 orbit2 = vec4( 0.38347405, 1.86336986, -0.01788503, -2.71105793);\nvec4 orbit3 = vec4(0.87534959, 1.04847687, 0.03234359, 0.00505466);\nvec3 orbit4 = vec3(-2.19183836, 1.41098694, 1.56200985);\nvec3 phongColor =  vec3(0.6,0.2,0.);\nvec3 phongPosition = vec3(1.,-2.,6.);\nvec3 phongParam = vec3(1.1,0.2,1.1);\nvec4 spotLightParam = vec4(0.,2.1,-4.,0.09);\nvec3 spotLightColor = vec3(0.783,0.422,0.0056);\nfloat fogDistance = 0.;\nfloat fogAmount = 0.1;\nfloat fogColor = 0.3;\n\nvec3 direction;\nvec3 normal;\nvec3 position;\nvec3 color;\nfloat depth;\nint iter;\nvec4 orbitTrap;\n\nconst float PI = acos(-1.);\n\n// --------------------------------------------------------\n\nfloat DE(vec3 pos) {\n    float dr = 1.;\n    float st,r,mcangle,theta,pwr;\n  \n    orbitTrap = vec4(10000.);\n\n    for(int i=0; i < maxSteps; ++i) {\n        r = length(pos);\n        if(r > 4.) break;\n        \n        mcangle = abs(pos.y) / pos.x;\n        mcangle = atan(mcangle);\n        mcangle = (PI*0.5 - PI*abs(pos.x)* 0.5/pos.x + mcangle ) * power;\n        \n        theta = acos(pos.z/r) * power;\n        st = sin(theta);\n        \n        pwr = pow(r, power);\n        pos.x = pwr * cos(mcangle) * st;\n        pos.y = pwr * sin(mcangle) * st * abs(pos.y)/pos.y;\n        pos.z = pwr * cos(theta);\n        \n        pos += julia;\n\n        dr = (pow(r,power - 1.0) * power * dr ) + 1.0;\n        \n        if(i < 6) {\n            vec3 ot = pos - orbit4;\n            orbitTrap = min(orbitTrap, vec4(abs(ot), dot(ot,ot)));\n        }\n    }\n    \n    return 0.5 * log(r) * r/dr;\n}\n\n// --------------------------------------------------------\n// https://iquilezles.org/articles/normalsSDF\nvoid calcNormal() {\n    float d0 = DE(position);\n    float fudge = sin(iTime * 0.01) * 0.03;\n    vec2 epsilon = vec2(.01,fudge); // fudged values.  should be 0.0000,0.\n    vec3 d1 = vec3(\n        DE(position-epsilon.xyy),\n        DE(position-epsilon.yxy),\n        DE(position-epsilon.yyx));\n    normal = normalize(d0 - d1);\n}\n\n// --------------------------------------------------------\n\nvoid setDirection(vec2 U) {\n    vec3 viewVector = normalize(aim);\n    vec3 sideVector = vec3(0.,1.,0.);\n    sideVector = normalize(cross(sideVector,viewVector));\n    vec3 topVector = cross(viewVector,sideVector);\n    \n    vec2 vPos = (U - iResolution.xy * 0.5)/iResolution.y;\n    direction = normalize(viewVector + vPos.x * sideVector + vPos.y * topVector);\n}\n\n// --------------------------------------------------------\n\nvec3 generateColor(float weight,float x) {\n\tif(weight == 0.0) return vec3(0.0);\n\n\tx = cos(x);\n\tfloat r = (1.0-x)*(1.0-x);\n\tfloat g = x*x;\n\tfloat b = 2.0*(1.0-x)*x;\n\treturn vec3(r,g,b);\n}\n\nvec3 orbitTrapCycle(float cycle,vec3 c, float s) {\n    float ss = s * cycle;\n    return vec3(0.5) + 0.5 * vec3( cos(ss + c.x), cos(ss + c.y), cos(ss + c.z));\n}\n\nvec3 getOrbitColor() {\n    vec3 orbitColor;\n    \n    if (ocycle > 0.0) {\n        orbitColor =\n        orbitTrapCycle(ocycle,generateColor(orbit2.x,orbit2.y), orbitTrap.x) * orbit2.x * orbitTrap.x +\n        orbitTrapCycle(ocycle,generateColor(orbit2.z,orbit2.w), orbitTrap.y) * orbit2.z * orbitTrap.y +\n        orbitTrapCycle(ocycle,generateColor(orbit3.x,orbit3.y), orbitTrap.z) * orbit3.x * orbitTrap.z +\n        orbitTrapCycle(ocycle,generateColor(orbit3.z,orbit3.w), orbitTrap.w) * orbit3.z * orbitTrap.w;\n    } else {\n        orbitColor =\n        \tgenerateColor(orbit2.x,orbit2.y) * orbit2.x * orbitTrap.x +\n        \tgenerateColor(orbit2.z,orbit2.w) * orbit2.z * orbitTrap.y +\n        \tgenerateColor(orbit3.x,orbit3.y) * orbit3.x * orbitTrap.z +\n        \tgenerateColor(orbit3.z,orbit3.w) * orbit3.z * orbitTrap.w;\n    }\n    \n    return orbitColor;\n}\n\n// --------------------------------------------------------\n// phongParam = diffuse,spec,ambient\n\nvoid phongLight() {\n\tvec3 L = normalize(phongPosition - position);\n\tfloat dotLN = dot(L, normal);\n\tif (dotLN < 0.) return;\n\t\t\n\tfloat t1 = phongParam.x * dotLN;\n\tvec3 V = normalize(camera - position);\n\tvec3 R = normalize(reflect(-L, normal));\n\tfloat dotRV = dot(R, V);\n\n\tif (dotRV < 0.0) {\n\t\tcolor += phongColor * t1;\n        return;\n    }\n\n\tfloat t2 = phongParam.y * pow(abs(dotRV), phongParam.z);\n\tcolor += phongColor * (t1 + t2);\n}\n\n// --------------------------------------------------------\n// spotLightParam = strength,x,y,exp\n\nvoid spotLight() { \n\tfloat a1 = spotLightParam.y * PI;\n\tfloat a2 = spotLightParam.z * PI * 0.5;\n\tfloat s1 = sin(a1);\n\tvec3 spotDir = normalize(vec3(s1 * cos(a2), s1 * sin(a2), cos(a1)));\n\tvec3 halfVector = normalize(spotDir - direction);\n\n\tfloat nDotL = max(0., dot(normal, spotDir));\n\tfloat hDotN = max(0., dot(normal, halfVector));\n\n    vec3 c = spotLightColor;// * spotLightParam.x;\n    float sexp = spotLightParam.w;\n\n\tcolor += c * ((sexp + 2.) / 2.) * pow(hDotN, sexp) \n\t\t* (sexp + (1. - sexp) * pow(1. - hDotN, 5.)) * nDotL * spotLightParam.x;\n}\n\n// --------------------------------------------------------\n\nvoid ambient() { \n/*\n    const float amb = .0;\n    const float dim = 0.15;\n    const float contrast = .2;\n    const float vibrant = 0.01;\n    color += vec3(amb) + vec3(1.0 - (normal * vibrant + sqrt(float(iter) * dim)));\n    const float contrast = 1.2;\n    color = vec3(0.5) + (color - vec3(0.5)) * contrast; \n*/\n\n    phongLight();\n    spotLight();\n    \n    if(ostrength > 0.0) {\n        vec3 oColor = getOrbitColor();\n        color = mix(color, oColor, ostrength);\n    }    \n}\n\n// --------------------------------------------------------\nconst float MIN_DIST = 0.01;\nconst float MAX_DIST = 3.0;\nconst float EPSILON = 0.005; // large value works well with texture coloring\n\nvoid rayMarch() {\n\tfloat distance;\n\tposition = camera;\n\titer = 0;\n\tdepth = MIN_DIST;\n    \n    orbitTrap = vec4(10000.);\n\t\n\tfor(int i = 0;i < 50;++i) {\n\t\tdistance = DE(position);\n        if(abs(distance) < EPSILON || depth > MAX_DIST) break;\n        iter += 1;\n\t\t\n        depth += distance;\n        position += direction * distance;\n    }\n}\n\n// --------------------------------------------------------\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t) );\n}\n\nvec3 doPalette( in float val , in mat4 pType ){\n  return palette( val ,  pType[0].xyz , pType[1].xyz , pType[2].xyz , pType[3].xyz );\n}\n\n// --------------------------------------------------------\n\n#define animate(v,v1,v2,speed) v = mix(v1,v2,0.5 + sin(iTime * speed) * 0.5)\n#define animate2(v,base,delta,speed) v = mix(base-delta,base+delta,0.5 + sin(iTime * speed) * 0.5)\n    \nvoid mainImage(out vec4 O, vec2 U) {\n\n    animate2(power,5.,3.5,0.15);\n    animate2(julia.x,0.,0.64, 0.2);\n    animate2(julia.y,0.,0.64, 0.3);\n    animate2(julia.z,0.,0.64, 0.4);\n\n    animate2(spotLightParam.x,1.,0.5,0.3);\n    animate2(spotLightParam.y,0.,1.5,0.03);\n    animate2(spotLightParam.z,0.,1.5,0.035);\n    animate2(spotLightParam.w,0.7,0.2,0.4);\n    animate2(spotLightColor.x,0.5,0.5,0.1);\n    animate2(spotLightColor.y,0.5,0.5,0.2);\n    animate2(spotLightColor.z,0.5,0.5,0.4);\n\n    animate2(phongParam.x,0.2,0.3,0.3);\n    animate2(phongParam.y,0.,0.1,0.35);\n    animate2(phongParam.z,8.,2.,0.4);\n\n    animate2(phongColor.x,0.5,0.5,0.3);\n    animate2(phongColor.y,0.5,0.5,0.7);\n    animate2(phongColor.z,0.5,0.5,0.9);\n    animate2(phongPosition.x,0.,2.,0.01);\n    animate2(phongPosition.y,0.,2.,0.05);\n    animate2(phongPosition.z,-5.,2.,0.07);\n  \n    animate(ostrength,0.,0.1,0.1);\n    //animate(ocycle,0.,3.,0.18);\n    animate(orbit2.x,-3.,3.,0.011);  // X wt,color\n    animate(orbit2.y,-3.,3.,0.013);\n    animate(orbit2.z,-3.,3.,0.015);  // Y wt,color\n    animate(orbit2.w,-3.,3.,0.017);\n    animate(orbit3.x,-3.,3.,0.019);  // Z wt,color\n    animate(orbit3.y,-3.,3.,0.021);\n    animate(orbit4.x,-3.,3.,0.23);  // center\n    animate(orbit4.y,-3.,3.,0.25);\n    animate(orbit4.z,-3.,3.,0.27);\n  \n/*\n    animate2(camera.x,1.,.1,   0.35);\n    animate2(camera.y,-2.,.1,   0.4);\n    animate2(camera.z,0.,.1,   0.45);\n*/    \n//    animate2(aim.x,-1., 2.,  0.01);\n//    animate2(aim.y,0.5,  0.4,  0.03);\n//    animate2(aim.z,-1., 2.,  0.05);\n\n    color = vec3(0.);\n    setDirection(U);\n\trayMarch();\n    \n\tif(depth < MAX_DIST) {\n        calcNormal();\n \n        // 'crystal' effect ------------------------------ \n        vec3 refr = refract(direction,normal, 1./1.1);\n        vec3 refl = normalize(reflect(vec3(0.,3.,0.),normal));\n        \n        vec3 refrCol = texture(iChannel2,refr).xyz;\n        vec3 reflCol = texture(iChannel2,refl).xyz;\n        \n        float reflectVal = pow( max( 0., dot(refl,direction)), 20.);\n\n        //float face = pow( (10. -  max(0. , dot( nor , rd ))) , 1. );\n        const  mat4  paletteVal = mat4( .5 , .5 , .5 , 0. \n                 , .5 , .5 , .5 , 0.\n                 , 2. , 1. , 0. , 0.\n                 , .5 , .2 , .25 , 0.);\n        \n        vec3 palCol = doPalette(sin(iTime * .002) * 0.002, paletteVal);\n        vec3 refCol = doPalette( reflectVal , paletteVal ) * reflectVal;\n       \tcolor = refCol + (palCol * refrCol);\n        // ------------------------------------------------\n        \n        ambient();  // phong,spotlighting\n    }\n    \n    if(fogDistance != 0.0) {\n        float f = depth - fogDistance;\n        if(f > 0.0) {\n            f = min(1.0,f * fogAmount);\n            color = mix(color, vec3(0.2 + f * fogColor),f);\n        }\n    }\n\n    const float mb = 0.8; // max brightness\n    if(color.x > mb && color.y > mb && color.z > mb) color = vec3(1.0) - color;\n\n    O.xyz = color;\n}\n\n","name":"Image","description":"","type":"image"}]}