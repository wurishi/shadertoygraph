{"ver":"0.1","info":{"id":"MldXW7","date":"1480099688","viewed":507,"name":"Rotating Tesseract","username":"Vortex_","description":"A 4D Cube rendered as a  \"3D shadow\". \n\nUsing 4D matrices to rotate the Tesseract in the 4th dimension.\n\nPlease come with suggestions if I have done something utterly wrong. :)","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cube","4d","rotating","tesseract","hypercube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*//////////////////////////\nCreator: Andreas Sorman \naka. \"Vortex\"\n\n\n\n*///////////////////////////\n\nfloat PI = 3.14159265359;\nfloat eps = .0001;\n\n\n//Models\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat udBox4D( vec4 p, vec4 b)\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox4D( vec4 p, vec4 b )\n{\n  vec4 d = abs(p) - b;\n  return min(max(d.x ,max(d.y,max(d.z,d.w))),0.0) + length(max(d,0.0));\n}\n\nmat4 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, 1, 0, 0),\n        vec4(0, 0, c, -s),\n        vec4(0, 0, s, c)\n    );\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, c, 0, -s),\n        vec4(0, 0, 1, 0),\n        vec4(0, s, 0, c)\n    );\n}\n\nmat4 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, 0, s),\n        vec4(0, 1, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(-s, 0, 0, c)\n    );\n}\n\n\nmat3 rotateX3D(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    \n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY3D(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    \n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ3D(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    \n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1, d2);\n}\n\n//Scene Where You Can Place Objects\nfloat scene(vec3 pos) { \n    \n    float time = iTime;\n    \n    float d = sdBox4D(vec4(pos*rotateZ3D(time)*rotateY3D(time)*rotateX3D(time),0)*rotateZ(time)*rotateY(time)*rotateX(time), vec4(.6));\n    \n    //d = opS(sdBox4D(vec4(pos*rotateZ3D(time)*rotateY3D(time)*rotateX3D(time),0)*rotateZ(time)*rotateY(time)*rotateX(time), vec4(1., .5, .5, .5)), d);\n    //d = opS(sdBox4D(vec4(pos*rotateZ3D(time)*rotateY3D(time)*rotateX3D(time),0)*rotateZ(time)*rotateY(time)*rotateX(time), vec4(.5, 1., .5, .5)), d);\n    //d = opS(sdBox4D(vec4(pos*rotateZ3D(time)*rotateY3D(time)*rotateX3D(time),0)*rotateZ(time)*rotateY(time)*rotateX(time), vec4(.5, .5, 1., .5)), d);\n    //d = opS(sdBox4D(vec4(pos*rotateZ3D(time)*rotateY3D(time)*rotateX3D(time),0)*rotateZ(time)*rotateY(time)*rotateX(time), vec4(.5, .5, .5, 1.)), d);         \n    \n    \n    return d;//opS(sdSphere(pos, 0.4), udBox(pos, vec3(0.3)));\n}\n\n//Get Normal\nvec3 normal(vec3 pos) {\n    float eps = 0.001;\n    \n    return normalize(vec3(\n    scene(pos + vec3(eps,0.,0.)) - scene(pos - vec3(eps,0.,0.)),\n    scene(pos + vec3(0.,eps,0.)) - scene(pos - vec3(0.,eps,0.)),\n    scene(pos + vec3(0.,0.,eps)) - scene(pos - vec3(0.,0.,eps))));\n}\n\n//Marching Until It Hits Something\nvec3 march(vec3 pos, vec3 dir) {    \n    vec3 rayPos = pos;    \n    float dis = eps;\n    \n    vec3 c = vec3(rayPos);  \n    \n    for(int i = 0; i < 50; i++) {                         \n       \tc = rayPos;\n      \n        if(dis < eps) {\n            c = normal(rayPos);\n            \n            break;\n        }\n                    \n        dis = scene(rayPos); \n        rayPos += dir*dis;                                                         \n    }\n    \n    return c;\n}\n\n//Renders The Final Image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //UV Setup\n    vec2 uv = -1.0 + 2.0 * (fragCoord.xy / iResolution.xy);\n    uv.y *= -1.;\n    uv.x *= 1.7777;\n   \n    vec3 pos = vec3(0., 1., -2.);\n    vec3 target = vec3(0.);\n    \n    //Setting Up Camera Vector\n    vec3 ww = normalize(target - pos);\n    vec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    vec3 dir = normalize(uv.x*uu + uv.y*vv + ww);         \n    \n    vec3 c = normalize(abs(march(pos, dir)));       \n    \n    fragColor = vec4(c, 1.);\n}\n\n","name":"Image","description":"","type":"image"}]}