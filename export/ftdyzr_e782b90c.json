{"ver":"0.1","info":{"id":"ftdyzr","date":"1659235980","viewed":93,"name":"Point Mass Simulation","username":"glt","description":"You can click to reposition the ball.\n\nEach time you click, the energy at that moment is recorded, and then the top bar will show what percent of energy is KE (blue), PE (yellow), and lost due to friction (red).","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Set up scene\n    vec3 col = SKY_COLOR; // Sky color\n    if (uv.x + uv.y < RAMP_LEVEL) col = RAMP_COLOR; // Incline color\n    else if (uv.y < GROUND_LEVEL) col = GROUND_COLOR; // Friction Surface color\n    \n    // Draw Point Mass\n    vec2 p = texture(iChannel0, vec2(0.0)).xy;\n    vec2 delta = uv.xy - texture(iChannel0, vec2(0.0)).xy;\n    if (distance(vec2(0.0), delta * vec2(iResolution.x/iResolution.y, 1.0)) < MASS_RADIUS) col = MASS_COLOR;\n    \n    // Draw\n    fragColor = vec4(col,1.0);\n    \n    float KE = texture(iChannel0, vec2(KINETIC_ENERGY-EPS)).x;\n    float PE = texture(iChannel0, vec2(POTENTIAL_ENERGY-EPS)).x;\n    float E = texture(iChannel0, vec2(ENERGY-EPS)).x;\n    if (uv.y > 0.95) {\n        if (uv.x < (KE / E))\n            fragColor = vec4(0.0, 1.0, 1.0, 1.0);\n        else if (uv.x < ((KE + PE) / E))\n            fragColor = vec4(1.0, 1.0, 0.0, 1.0);\n        else\n            fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n    \n    // DEBUG OUTPUT\n    //if (uv.y > 0.95)\n    //    fragColor = texture(iChannel0, uv);\n    //else if (uv.y > 0.9 && uv.x < VELOCITY)\n    //    fragColor = vec4(1.0);\n    \n    //fragColor = texture(iChannel0, vec2(POSITION-1.0));\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get the position and the velocity of the previous frame.\n    // This is all we need.\n    vec2 x0 = texture(iChannel0, vec2(POSITION-PEPS)).xy;\n    vec2 v0 = texture(iChannel0, vec2(VELOCITY-PEPS)).xy;\n    float dt = iTimeDelta * TIME_SCALE;\n    \n    // Update position if mouse is held down\n    if (iMouse.z > 0.0) {\n        x0 = iMouse.xy/iResolution.xy;\n        v0 = vec2(0.0);//(iMouse.xy - iMouse.zw) * (1.0 / dt);\n        v0 = (iMouse.xy - vec2(abs(iMouse.z), abs(iMouse.w)))/iResolution.xy * (1.0 / (dt * 10.0));\n    }\n        \n    // Clamp mass outside of objects and inside the screen.\n    // The order of pushes is is important!\n    // This order guarantees the mass is not inside any boundary.\n    WORLD_PUSH(x0, v0, dt);\n    RAMP_PUSH(x0, v0, dt);\n    GROUND_PUSH(x0, v0, dt);\n        \n    // Gravity force\n    vec2 W = M * G * vec2(0.0, -1.0);\n    \n    // Contact forces\n    vec2 N = vec2(0.0);\n    vec2 F = vec2(0.0);\n    float ramp_dist = RAMP_DIST(x0);\n    float ground_dist = GROUND_DIST(x0);\n    if (ramp_dist < ground_dist && ramp_dist < EPS)\n        N = normalize(RAMP_NORMAL) * abs(dot(normalize(RAMP_NORMAL), W));\n    else if (ground_dist < ramp_dist && ground_dist < EPS) {\n        N = -W;\n        F = length(N) * -normalize(v0) * MU;\n    }\n        \n    // Sum all forces to find instantaneous acceleration\n    vec2 SUMF = W + N + F;\n    vec2 a = SUMF / M;\n       \n    // Compute new velocity and position\n    vec2 v = v0 + a * dt;\n    \n    // By work-energy theorem:\n    //float theta = atan(v.y / v.x);\n    //float A = 0.5 * M;\n    //float B = length(F) * dt + M * G * sin(theta) * dt;\n    //float C = -0.5 * M * dot(v0, v0);\n    //float mag_v = (-B + sqrt(B * B - 4.0 * A * C)) / (2.0 * A);\n    //v = normalize(v) * mag_v;\n    vec2 x = x0 + v * dt;\n    \n    WORLD_PUSH(x, v, dt);\n    RAMP_PUSH(x, v, dt);\n    GROUND_PUSH(x, v, dt);\n    \n    float KE = 0.5 * M * dot(v,v);\n    float PE = M * G * x.y;\n    float E;\n    \n    \n    // Update buffer\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    if (iMouse.z > 0.0)\n        E = KE + PE; // Reset energy\n    else\n        E = texture(iChannel0, uv).x;\n    if (uv.x < POSITION)\n        fragColor = vec4(x, 0.0, 0.0);\n    else if (uv.x < VELOCITY)\n        fragColor = vec4(v, 0.0, 0.0);\n    else if (uv.x < ACCELERATION)\n        fragColor = vec4(a, 0.0, 0.0);\n    else if (uv.x < KINETIC_ENERGY)\n        fragColor = vec4(KE, 0.0, 0.0, 1.0);\n    else if (uv.x < POTENTIAL_ENERGY)\n        fragColor = vec4(PE, 0.0, 0.0, 1.0);\n    else if (uv.x < ENERGY)\n        fragColor = vec4(E, 0.0, 0.0, 1.0);\n    else\n        fragColor = vec4(0.0, 0.0, 1.0, 0.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const vec2 RAMP_NORMAL = vec2(1.0,1.0); // Unnormalized!\nconst vec2 GROUND_NORMAL = normalize(vec2(0.0,1.0));\n\nconst vec2 RAMP_FORWARD = normalize(vec2(1.0, -1.0));\nconst vec2 GROUND_FORWARD = normalize(vec2(1.0, 0.0));\n\nconst float RAMP_LEVEL = 0.6;\nconst float GROUND_LEVEL = 0.15;\n\nconst vec3 SKY_COLOR = vec3(0.5,0.5,0.9);\nconst vec3 RAMP_COLOR = vec3(0.8,0.8,0.8);\nconst vec3 GROUND_COLOR = vec3(0.2,0.0,0.0);\nconst vec3 MASS_COLOR = vec3(1.0,0.0,0.0);\n\nconst float MASS_RADIUS = 0.05;\n\nconst float TIME_SCALE = 0.4;\n\nconst float EPS = 0.01;\n\n// Physics parameters\nconst float G = 9.81;\nconst float M = 1.0;\nconst float MU = 0.2; // Same coefficient for simplicity\n\n#define KofN(K, N) float(K) / float(N)\nconst int N = 6;\nconst float PEPS = KofN(1, 2 * N);\nconst float POSITION = KofN(1, N);\nconst float VELOCITY = KofN(2, N);\nconst float ACCELERATION = KofN(3, N);\nconst float KINETIC_ENERGY = KofN(4, N);\nconst float POTENTIAL_ENERGY = KofN(5, N);\nconst float ENERGY = KofN(6, N);\n\nconst float ROOT2 = sqrt(2.0);\n\n#define M_PI       3.14159265358979323846\n\nmat2 ROTATION_MATRIX(in float theta) {\n    return mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n}\n\nvoid RAMP_PUSH(inout vec2 p, inout vec2 v, in float dt) {\n    if (p.x + p.y > RAMP_LEVEL) return;\n    \n    // Perfectly elastic code\n    v = RAMP_FORWARD * length(v) * (v.x > 0.0 ? 1.0 : -1.0);\n    \n    // Inelastic code\n    //v -= normalize(RAMP_NORMAL) * dot(normalize(RAMP_NORMAL), normalize(v));\n    \n    // Perfectly elastic code v2\n    //v -= 2.0 * normalize(RAMP_NORMAL) * dot(normalize(RAMP_NORMAL), normalize(v));\n    \n    p += RAMP_NORMAL * (RAMP_LEVEL - p.x - p.y) * 0.5;\n}\n\nvoid GROUND_PUSH(inout vec2 p, inout vec2 v, in float dt) {\n    if (p.y > GROUND_LEVEL) return;\n    \n    // Perfectly elastic code\n    v = GROUND_FORWARD * length(v) * (v.x > 0.0 ? 1.0 : -1.0);\n    \n    // Inelastic code\n    //v -= normalize(GROUND_NORMAL) * dot(normalize(GROUND_NORMAL), normalize(v));\n    \n    \n    // Perfectly elastic code v2\n    //v -= 2.0 * normalize(GROUND_NORMAL) * dot(normalize(GROUND_NORMAL), normalize(v));\n    \n    p += GROUND_NORMAL * (GROUND_LEVEL - p.y);\n}\n\nvoid WORLD_PUSH(inout vec2 p, inout vec2 v, in float dt) {\n    if (v.x < 0.0 && p.x < 0.0)\n        v.x *= -1.0;\n    if (v.x > 0.0 && p.x > 1.0)\n        v.x *= -1.0;\n    /*if (v.y < 0.0 && p.y < 0.0)\n        v.y *= -1.0;\n    if (v.y > 0.0 && p.y > 1.0)\n        v.y *= -1.0;*/\n    p = vec2(min(1.0, max(0.0, p.x)), min(1.0, max(0.0, p.y)));\n} \n    \nfloat RAMP_DIST(in vec2 p) {\n    if (p.x + p.y < RAMP_LEVEL) return 0.0;\n    return (p.x + p.y - RAMP_LEVEL) * 0.5 * ROOT2;\n}\n\nfloat GROUND_DIST(in vec2 p) {\n    if (p.y < GROUND_LEVEL) return 0.0;\n    return (p.y - GROUND_LEVEL);\n}","name":"Common","description":"","type":"common"}]}