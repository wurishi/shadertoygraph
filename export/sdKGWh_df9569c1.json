{"ver":"0.1","info":{"id":"sdKGWh","date":"1631489794","viewed":68,"name":"Floating Bitmap ABC","username":"nkaretnikov","description":"A simple bitmap font demo (with parametric curves).","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","simple","tutorial","curves","bitmap","font","parametric","floating"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Public domain.\n\n#define SHIFT .5\n\n// Constants.\nconst float pi = 3.1415;\n\n// Parametric equation of a circle.\n// https://en.wikipedia.org/wiki/Parametric_equation#Circle\n// 't' from -pi to pi.\nvec2 pCircle(float r, float t)\n{\n    return vec2(r * sin(t), r * cos(t));\n}\n\n// Parametric equation of the Lemniscate of Gerono.\n// https://en.wikipedia.org/wiki/Lemniscate_of_Gerono\n// https://www.wolframalpha.com/input/?i=lemniscate\n// 't' from 0 to 2 * pi.\nvec2 pGerono(float r, float t)\n{\n    float x = r * (cos(t)) / (pow(sin(t), 2.) + 1.);\n    float y = r * (sin(t) * cos(t)) / (pow(sin(t), 2.) + 1.);\n    \n    return vec2(x, y);\n}\n\nvec3 rect(vec3 color, vec2 uv, vec2 bl, vec2 tr)\n{\n    float res = 1.;\n    \n    // Bottom left.\n    bl = step(bl, uv);  // if arg2 > arg1 then 1 else 0\n    res = bl.x * bl.y;  // similar to logic AND\n    \n    // Top right.\n    tr = step(SHIFT - tr, SHIFT - uv);\n    res *= tr.x * tr.y;\n    \n    return res * color;\n}\n\nvec3 square(vec3 color, vec2 uv, vec2 c, float sz)\n{\n    return rect(color, uv, c - sz, c + sz);\n}\n\nvec3 drawA(vec3 res, vec3 color, vec2 uv, vec2 pos, float sz)\n{\n    // A: top.\n    res += square(color, uv, vec2(pos.x +  0., pos.y +  .2), sz);\n    \n    // A: left side.\n    res += square(color, uv, vec2(pos.x + -.1, pos.y +  .1), sz);\n    res += square(color, uv, vec2(pos.x + -.1, pos.y +  .0), sz);\n    res += square(color, uv, vec2(pos.x + -.1, pos.y + -.1), sz);\n    res += square(color, uv, vec2(pos.x + -.1, pos.y + -.2), sz);\n    \n    // A: right side.\n    res += square(color, uv, vec2(pos.x +  .1, pos.y +  .1), sz);\n    res += square(color, uv, vec2(pos.x +  .1, pos.y +  .0), sz);\n    res += square(color, uv, vec2(pos.x +  .1, pos.y + -.1), sz);\n    res += square(color, uv, vec2(pos.x +  .1, pos.y + -.2), sz);\n    \n    // A: center.\n    res += square(color, uv, vec2(pos.x +  0., pos.y +  0.), sz);\n    \n    return res;\n}\n\nvec3 drawB(vec3 res, vec3 color, vec2 uv, vec2 pos, float sz)\n{\n    // B: top.\n    res += square(color, uv, vec2(pos.x +  0., pos.y +  .2), sz);\n    res += square(color, uv, vec2(pos.x + -.1, pos.y +  .2), sz);\n    \n    // B: left side.\n    res += square(color, uv, vec2(pos.x + -.1, pos.y +  .1), sz);\n    res += square(color, uv, vec2(pos.x + -.1, pos.y +  .0), sz);\n    res += square(color, uv, vec2(pos.x + -.1, pos.y + -.1), sz);\n    res += square(color, uv, vec2(pos.x + -.1, pos.y + -.2), sz);\n    \n    // B: right side.\n    res += square(color, uv, vec2(pos.x +  .1, pos.y +  .1), sz);\n    res += square(color, uv, vec2(pos.x +  .1, pos.y + -.1), sz);\n    \n    // B: center.\n    res += square(color, uv, vec2(pos.x +  0., pos.y + 0.), sz);\n    \n    // B: bottom.\n    res += square(color, uv, vec2(pos.x +  0., pos.y + -.2), sz);\n    \n    return res;\n}\n\nvec3 drawC(vec3 res, vec3 color, vec2 uv, vec2 pos, float sz)\n{\n    // C: top.\n    res += square(color, uv, vec2(pos.x +  0., pos.y +  .2), sz);\n    \n    // C: left side.\n    res += square(color, uv, vec2(pos.x + -.1, pos.y +  .1), sz);\n    res += square(color, uv, vec2(pos.x + -.1, pos.y +  .0), sz);\n    res += square(color, uv, vec2(pos.x + -.1, pos.y + -.1), sz);\n    \n    // C: right side.\n    res += square(color, uv, vec2(pos.x +  .1, pos.y +  .1), sz);\n    res += square(color, uv, vec2(pos.x +  .1, pos.y + -.1), sz);\n    \n    // C: bottom.\n    res += square(color, uv, vec2(pos.x +  0., pos.y + -.2), sz);\n    \n    return res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1).\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Remap coordinates to make 0.0 be at the center.\n    uv -= SHIFT;\n    \n    // Account for the aspect ratio.\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Colors.\n    vec3 red    = vec3(.667, .133, .141);\n    vec3 blue   = vec3(0.,   .369, .608);\n    vec3 yellow = vec3(1.,   .812, .337);\n    vec3 black  = vec3(0.);\n    \n    // Output color.\n    vec3 color = black;\n    \n    // Size.\n    float sz = .05;\n    \n    // Blinking.\n    float speed = 2.;\n    float t = iTime * speed;\n    float f = sin(t);\n    \n    // Position.\n    float g = mod(iTime * (speed * .6), 2. * pi);\n    // vec2 pos = pCircle(.25, g);\n    vec2 pos = pGerono(.71, g);\n\n    if (f >= .0 && f < .4 || f <= .0 && f > -.4) {\n        // B.\n        color += drawB(color, blue, uv, pos, sz);\n    } else if (f > 0.) {\n        // A.\n        color += drawA(color, red, uv, pos, sz);    \n    } else if (f < 0.) {\n        // C.\n        color += drawC(color, yellow, uv, pos, sz);\n    }\n    \n    // Output to screen.\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}