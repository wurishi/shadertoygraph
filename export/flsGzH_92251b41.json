{"ver":"0.1","info":{"id":"flsGzH","date":"1621556123","viewed":891,"name":"Cubic Bezier Spline Distance","username":"nr4","description":"Technique:\n* Determine a solution by interval approximation\n* Polynomial division\n* Solve resulting quartic\n* Determine solution with minimum distance\n* Profit","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["sdf","bezier","distance","curve","cubic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Cubic Bezier Spline Distance\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n * Update 1: Fixed a glitch related to the initial conditions of the\n *     interval approximation\n * Update 2: Used relative coordinates to simplify the equations\n * Update 3: Combined the dot products to save on computation time\n * \n */\n \nconst vec3 c = vec3(1.,0.,-1.);\nconst float pi = acos(-1.);\n\n// Cubic bezier curve\nvec2 B3(float t, vec2 P0, vec2 P1, vec2 P2, vec2 P3)\n{\n    float m1 = 1.-t;\n    return m1*m1*m1*P0 + 3.*m1*t*(m1*P1+t*P2) + t*t*t*P3;\n}\n\n// Cubic bezier partial derivative with respect to t\nvec2 B3Prime(float t, vec2 P0, vec2 P1, vec2 P2, vec2 P3)\n{\n    float m1 = 1.-t;\n    return 3.*(m1*m1*(P1-P0)+2.*m1*t*(P2-P1)+t*t*(P3-P2));\n}\n\n// Cubic bezier second partial derivative with respect to t\nvec2 B3Second(float t, vec2 P0, vec2 P1, vec2 P2, vec2 P3)\n{\n    float m1 = 1.-t;\n    return 6.*m1*(P2-2.*P1+P0)+6.*t*(P3-2.*P2+P1);\n}\n\n// This is the \"easy\" representation of the quintic that has to be solved\n// for the sdf.\nfloat D3Prime(vec2 x, float  t, vec2 P0, vec2 P1, vec2 P2, vec2 P3)\n{\n    return dot(x-B3(t,P0,P1,P2,P3), B3Prime(t,P0,P1,P2,P3));\n}\n\n// Determine zeros of a*x^2+b*x+c\nvec2 quadratic_zeros(float a, float b, float cc) {\n    if(a == 0.) return -cc/b*c.xx;\n    float d = b*b-4.*a*cc;\n    if(d<0.) return vec2(1.e4);\n    return (c.xz*sqrt(d)-b)/(2.*a);\n}\n\n// Determine zeros of a*x^3+b*x^2+c*x+d\nvec3 cubic_zeros(float a, float b, float cc, float d) {\n    if(a == 0.) return quadratic_zeros(b,cc,d).xyy;\n    \n    // Depress\n    vec3 ai = vec3(b,cc,d)/a;\n    \n    //discriminant and helpers\n    float tau = ai.x/3., \n        p = ai.y-tau*ai.x, \n        q = -tau*(tau*tau+p)+ai.z, \n        dis = q*q/4.+p*p*p/27.;\n        \n    //triple real root\n    if(dis > 0.) {\n        vec2 ki = -.5*q*c.xx+sqrt(dis)*c.xz, \n            ui = sign(ki)*pow(abs(ki), c.xx/3.);\n        return vec3(ui.x+ui.y-tau);\n    }\n    \n    //three distinct real roots\n    float fac = sqrt(-4./3.*p), \n        arg = acos(-.5*q*sqrt(-27./p/p/p))/3.;\n    return c.zxz*fac*cos(arg*c.xxx+c*pi/3.)-tau;\n}\n\n// Determine zeros of a*x^4+b*x^3+c*x^2+d*x+e\nvec4 quartic_zeros(float a, float b, float cc, float d, float e) {\n    if(a == 0.) return cubic_zeros(b, cc, d, e).xyzz;\n    \n    // Depress\n    float _b = b/a,\n        _c = cc/a,\n        _d = d/a,\n        _e = e/a;\n        \n    // Helpers\n    float p = (8.*_c-3.*_b*_b)/8.,\n        q = (_b*_b*_b-4.*_b*_c+8.*_d)/8.,\n        r = (-3.*_b*_b*_b*_b+256.*_e-64.*_b*_d+16.*_b*_b*_c)/256.;\n        \n    // Determine available resolvent zeros\n    vec3 res = cubic_zeros(8.,8.*p,2.*p*p-8.*r,-q*q);\n    \n    // Find nonzero resolvent zero\n    float m = res.x;\n    if(m == 0.) m = res.y;\n    if(m == 0.) m = res.z;\n    \n    // Apply newton iteration to fix numerical artifacts;\n    // Credit goes to NinjaKoala / epoqe :)\n    for(int i=0; i < 2; i++) {\n        float a_2 = p + m;\n        float a_1 = p*p/4.-r + m * a_2;\n        float b_2 = a_2 + m;\n\n        float f = -q*q/8. + m * a_1;\n        float f1 = a_1 + m * b_2;\n\n        m -= f / f1; // Newton iteration step\n    }\n    \n    // Apply Ferrari method\n    return vec4(\n        quadratic_zeros(1.,sqrt(2.*m),p/2.+m-q/(2.*sqrt(2.*m))),\n        quadratic_zeros(1.,-sqrt(2.*m),p/2.+m+q/(2.*sqrt(2.*m)))\n    )-_b/4.;\n}\n\n// minimum distance to a cubic spline with the following strategy:\nfloat dcubic_spline(in vec2 x, in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3)\n{\n    // Use relative coordinates to eliminate all terms containing p0.\n    x -= p0;\n    p1 -= p0;\n    p2 -= p0;\n    p3 -= p0;\n    p0 = c.yy;\n    \n    // Use interval approximation to determine a numerical solution for the quintic.\n    // TODO: find something better, I really would like an analytical approach\n    float tmin = -0.5, tmax = 1.5, tnew, \n        dmin = D3Prime(x,tmin,p0,p1,p2,p3),\n        dmax = D3Prime(x,tmax,p0,p1,p2,p3),\n        dnew;\n    \n    for(int i=0; i<20; ++i)\n    {\n        tnew = mix(tmin, tmax, .5);\n        dnew = D3Prime(x,tnew,p0,p1,p2,p3);\n        \n        if(dnew>0.)\n        {\n            tmin = tnew;\n            dmin = dnew;\n        }\n        else \n        {\n            tmax = tnew;\n            dmax = dnew;\n        }\n    }\n    \n    // Determine coefficients of quintic equation.\n    vec2 pa = p2-p1;\n    float a5 = -dot(p3,p3)+3.*dot(pa,2.*p3-3.*pa),\n        a4 = 5.*dot(p1-pa,p3)+15.*dot(pa,pa-p1),\n        a3 = -6.*dot(p2,p2)+4.*dot(p1,9.*pa-p3),\n        a2 = dot(p3-3.*pa,x)+9.*dot(p1,p1-pa),\n        a1 = 2.*dot(pa-p1,x)-3.*dot(p1,p1),\n        a0 = dot(p1,x);\n    \n    // Polynomial division of numerical solution.\n    float _a = a5,\n        _b = a4+_a*tmin,\n        _c = a3+_b*tmin,\n        _d = a2+_c*tmin,\n        _e = a1+_d*tmin;\n        \n    vec4 t = clamp(quartic_zeros(_a,_b,_c,_d,_e),0.,1.);\n    tmin = clamp(tmin, 0.,1.);\n    \n    return min(\n        length(x-B3(tmin,p0,p1,p2,p3)),\n        min(\n            min(\n                length(x-B3(t.x,p0,p1,p2,p3)),\n                length(x-B3(t.y,p0,p1,p2,p3))\n            ),\n            min(\n                length(x-B3(t.z,p0,p1,p2,p3)),\n                length(x-B3(t.w,p0,p1,p2,p3))\n            )\n        )\n    );\n}\n\nfloat dlinesegment(in vec2 x, in vec2 p1, in vec2 p2)\n{\n    vec2 da = p2-p1;\n    return length(x-mix(p1, p2, clamp(dot(x-p1, da)/dot(da,da),0.,1.)));\n}\n\n// paint with antialiasing\nfloat sm(in float d)\n{\n    return smoothstep(1.5/iResolution.y, -1.5/iResolution.y, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Ignore the drawing code, it's messy, I know :)\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    \n    // Control points.\n    vec2 p_0 = .5*vec2(sin(1.1*iTime), .5*cos(3.*iTime)), \n        p_1 = .5*vec2(1.-sin(1.3*iTime), .5-.5*sin(1.3*iTime)),\n        p_2 = .5*vec2(cos(1.5*iTime), .5*sin(1.1*iTime)),\n    \tp_3 = .5*vec2(-sin(1.15*iTime), .5-.5*cos(.2-iTime));\n    \n    float d, \n        da;\n    vec2 xn, n;\n    d = abs(dcubic_spline(uv,p_0,p_1,p_2,p_3))-.01;\n\n    // Draw distance isolines\n    float interval = clamp(.03 * (d-mod(d,.025))/.025, 0., 1.);\n    vec3 col = mix(vec3(1.00,0.90,0.68), vec3(0.98,0.64,0.67), 2.*interval);\n    if(interval > .5) col = mix(col, vec3(0.54,0.80,0.80), 2.*(interval-.5));\n    \n    // Draw handle lines\n    col = mix(col, c.yyx, sm(abs(dlinesegment(uv,p_0,p_1))-.002));\n    col = mix(col, c.yyx, sm(abs(dlinesegment(uv,p_2,p_3))-.002));\n    \n    // Draw bezier curve\n    col = mix(col, c.yyy, sm(d));\n    \n    // Draw control points\n    col = mix(col, .4*c.xxx, sm(abs(mod(d+.0125,.025)-.0125)-.001));\n    col = mix(col, c.xxx, sm(length(uv-p_0)-.015));\n    col = mix(col, c.yyy, sm(abs(length(uv-p_0)-.015)-.002));\n    col = mix(col, c.xxx, sm(length(uv-p_1)-.015));\n    col = mix(col, c.yyy, sm(abs(length(uv-p_1)-.015)-.002));\n    col = mix(col, c.xxx, sm(length(uv-p_2)-.015));\n    col = mix(col, c.yyy, sm(abs(length(uv-p_2)-.015)-.002));\n    col = mix(col, c.xxx, sm(length(uv-p_3)-.015));\n    col = mix(col, c.yyy, sm(abs(length(uv-p_3)-.015)-.002));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}