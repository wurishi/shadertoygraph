{"ver":"0.1","info":{"id":"NtlSWN","date":"1625719300","viewed":103,"name":"Koch Space Glow","username":"conceptblend","description":"Folding glow lights over space again and again.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["light","kifs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * Modified based on KIFS learnings from Art of Code on YouTube.\n * https://youtu.be/il_Qg9AqQkE\n **/\n#define PI 3.14159\n\nfloat sdfLine(vec2 P, vec2 A, vec2 B, float r) {\n    vec2 pa = P-A, ba = B-A;\n    float h = min(1.0,\n              max(0.0,\n                  dot(pa, ba)/\n                  dot(ba, ba)));\n    return length(pa-ba*h) - r;\n}\n\nvec3 lightSpace(vec2 uv) {\n    \n    vec2 A = vec2(-1., -1.);\n        A.y += sin(iTime * .8) * .85;\n\n    vec2 B = vec2(1., 1.);\n       B.y += sin(iTime * .7) * .45;\n    \n    //uv.y = abs(uv.y);\n    \n    vec3 col = vec3(0.);\n    \n    A.x -= 0.5;\n    B.x -= 0.5;\n\n    float strokeWidth = 3. * 1./iResolution.x; // Scale by N units of the X resolution\n    float line1 = sdfLine(uv, A, B, strokeWidth);\n\n    /* BLUE */\n    //line1 = smoothstep(.0, .03, line1);\n    col += (1.-line1) * vec3(.25, .55, 1.);\n    \n    A.x *= -.7;\n    B.x *= -.8;\n\n    /* GREEN */\n    float line2 = sdfLine(uv, A, B, strokeWidth);\n    //col = mix(col, vec3(.0, .95, .33), line2);\n    //line2 = smoothstep(.0, .03, line2);\n    col += (1.-line2) * vec3(.0, .95, .33);\n\n    //A.x -= .5;\n    A.y *= -1.;\n    //B.x -= 1.3;\n    B.y *= -.5;\n\n    /* PINK */\n    float line3 = sdfLine(uv, A, B, strokeWidth);\n    //col = mix(col, vec3(.8, .05, .4), line3);\n    //line3 = smoothstep(.0, .03, line3);\n    col += (1.-line3) * vec3(.8, .05, .4);\n\n    // Output to screen\n    return col * .6;\n}\n\n\nvec2 N(float angle) {\n    return vec2(abs(sin(angle)), cos(angle));\n}\n\nvec3 foldSpace( vec2 uv ) {\n\n    // Reflection angle changes over time\n    float angle = 6./7.*PI;\n    vec2 n = N(angle);\n    float recip = 1./iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    // Reflect x across y\n    uv.x = abs(uv.x);\n    // Move up to adjust for reflection angle `n`\n    uv.y += tan(angle) * .5;\n    \n    //uv.y = abs(uv.y);\n \n    \n    // Move the reflection origin to the right\n    float d = dot(uv - vec2(0.5, 0), n);\n    \n    // Calculate the distance from `uv` to the reflection line\n    uv -= n * max(0., d) * 2.;\n    \n    // Offset X to counter the increment in the first\n    // iteration of the loop.\n    uv.x += .5;\n    \n    n = N(-iTime * 0.26 * PI + PI);\n        \n    float scale = 1.;\n    for (int i=0; i<5; i++) {\n        uv *= 3.;\n        scale *= 3.;\n        uv.x -= 1.5;  \n\n        uv.x = abs(uv.x);\n        uv.x -= .5;\n        uv -= n * min(0., dot(uv, n)) * 2.;\n        \n        // paint the fold lines\n        //col.rgb += .1 * smoothstep(2.*recip, .0, abs(dot(uv,n))/scale);\n        col += .25 * clamp(lightSpace(uv), .0, .7);\n    }\n \n    // Paint the Koch line\n    //d = length(uv - vec2(clamp(uv.x, -1., 1.), 0.));\n    //col += .5 * smoothstep(4.*recip, .0, d/scale);\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.);\n\n    // Initial zoom\n    uv *= .95; //1.05\n    \n    // Fun vertical offset\n    uv.y += .25;\n    \n    // Reflectomatic\n    uv.y = abs(uv.y);\n    \n    // Paint the background\n    col += lightSpace(uv);\n    \n    // Fold and paint more!\n    col += foldSpace(vec2(uv.x, uv.y-.25));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}