{"ver":"0.1","info":{"id":"lltSRH","date":"1478201807","viewed":1747,"name":"Water shader(Sine wave)","username":"stduhpf","description":"Basically [url=https://www.shadertoy.com/view/Xt3XzH]Sine wave superposition by drivenbynostalgia[/url], but with angle variation and reflection+refraction.","likes":51,"published":1,"flags":0,"usePreview":0,"tags":["reflection","refraction","water","sinewaves"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//credits for most of the code: drivenbynostalgia https://www.shadertoy.com/view/Xt3XzH\n\n//this is a slighty modified version of this shader, but i added normal estimation,random rotation between each octave\n//and light effects on(and under) the surface\n\n// A simple implementation of sine waves along a given, unnormalized velocity\n\nconst float TAU = 6.2831852;\nconst float PI = 0.5 * TAU; // This is a political statement\n\nconst float octaves = 8.0;\nconst vec2 globalVelocity = vec2(6.,-3.);\n\n// Hash without Sine by Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    const float HASHSCALE1 = .1031;\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat getAmplitude(float octave)\n{\n    return 1.0 / pow(2.2, octave);\n}\n\nfloat getWavelength(float octave)\n{\n\tconst float maximumWavelength = 50.0;\n    \n    float wavelength = TAU * maximumWavelength / pow(2.0, octave);\n\n    // Make it aperiodic with a random factor\n    wavelength *= 0.75 + 0.5 * hash11(1.337 * octave);\n    \n    return wavelength;\n}\n\nfloat getSpeed(float octave)\n{\n    const float speedScaleFactor = 2.0;\n    \n    // Smallest waves travel twice as fast as given velocity,\n    // largest waves travel half as fast\n    const vec2 speedRange = vec2(2.0, 0.5);\n    \n    // Map octave to speed range\n    float speed = speedScaleFactor * mix(speedRange.x, speedRange.y, octave / (max(1.0, octaves - 1.0)));\n    \n    // Add some randomness\n    speed *= 0.5 + hash11(1.337 * octave);\n    \n    return speed;\n}\n\nfloat getHeight(vec2 position, vec2 velocity)\n{\n    float magnitude = length(velocity);\n\n    float height = 0.0;\n    \n    for (float octave = 0.0; octave < octaves; octave += 1.0)\n    {\n                vec2 direction = (magnitude > 1e-5) ? velocity / magnitude : vec2(0.0);\n\n        float amplitude = getAmplitude(octave);\n        float wavelength = getWavelength(octave);\n        float speed = magnitude * getSpeed(octave);\n        float frequency = TAU / wavelength;\n        float randomPhaseOffset = hash11(1.337 * octave) * TAU;\n        float phase = speed * frequency + randomPhaseOffset;\n        float theta = dot(-direction, position);\n    \n        height += amplitude * sin(theta * frequency + iTime * phase);\n        \n        float a = (hash11(octave+floor(iTime-iDate.w))-.5)*.3; //random seed\n        velocity*=mat2(cos(a),sin(a),-sin(a),cos(a));\n    }\n    \n    return height;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy-.5;\n    vec2 ut= iMouse.xy / iResolution.xy-.5;\n    if(iMouse.x==0.)\n        ut=vec2(-.3,.2);\n    \n \t\tvec2 e =vec2(.001,0);\n    \tfloat scale =100.,h=-1e-4;;\n    \n\t\tvec3 nor = normalize(vec3(getHeight((uv+e.xy)*scale, globalVelocity) -getHeight((uv-e.xy)*scale, globalVelocity) ,\n                             getHeight((uv+e.yx)*scale, globalVelocity) -getHeight((uv-e.yx)*scale, globalVelocity) ,h/e.x));\n\n    fragColor= mix(\n        /**/\n        vec4(\n        texture(iChannel0,refract(normalize(vec3(uv,.5)),nor,.704).xzy).r,\n        texture(iChannel0,refract(normalize(vec3(uv,.5)),nor,.714).xzy).g,\n        texture(iChannel0,refract(normalize(vec3(uv,.5)),nor,.724).xzy).b,\n        0),\n        /**/\n        //texture(iChannel0,refract(normalize(vec3(uv,.5)),nor,.724).xzy), //without chromatic aberration\n                   texture(iChannel0,reflect(normalize(vec3(uv,.5)),nor).xzy),smoothstep(0.,2.,length(uv)))\n        +.05/distance(reflect(normalize(vec3(ut,.8)),nor),normalize(vec3(uv,-1.)));\n}","name":"Image","description":"","type":"image"}]}