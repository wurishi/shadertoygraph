{"ver":"0.1","info":{"id":"fstSzB","date":"1635751608","viewed":97,"name":"Travelling in the mandelbox","username":"Haper","description":"Control the camera using mouse","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["fractal","marching","mandelbox"],"hasliked":0,"parentid":"fsGGzV","parentname":"Transforming mandelbulb"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat RayMarch(vec3 ro,vec3 rd)\n{\n    float dO=0.0;\n    for(int i=0; i<MAX_STEPS; i++)\n    { \n        steps = i;\n        vec3 p=ro+rd*dO;\n        SURF_DIST = length(p-r0)*0.004;\n        float ds=GetDist(p);\n        dO+=ds;\n        if(MAX_DIST<dO || ds<SURF_DIST)\n        break;\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(SURF_DIST,0);\n\n    vec3 n = d-vec3(\n       GetDist(p-e.xyy),\n       GetDist(p-e.yxy),\n       GetDist(p-e.yyx));\n     \n     return normalize(n);\n}\nvec3 GetLight(vec3 p)\n{\n    vec3 pos = vec3(5.*sin(iTime),5,-6.*cos(iTime)+6.);\n    vec3 l=vec3(1.,3.,-2.);\n    vec3 l2 = vec3(-5.,3.,-1.);\n    \n    l = normalize(l);\n    vec3 n = GetNormal(p);\n    float k = dot(normalize(reflect(p-r0,n)),l);\n    float dif = mix(0.0,1.,k);\n    \n    float d=RayMarch(p+n*0.01,l);\n    if(d<MAX_DIST)\n    dif/=1.0;\n    \n    \n    float k2 = dot(normalize(reflect(p-r0,n)),normalize(r0-p));\n    float k3 = dot(normalize(reflect(p-r0,n)),normalize(l2));\n    \n    return vec3(0.8,0.8,0.1)*max(dif,0.)+vec3(0.2,0.2,0.7)*max(k2,0.)+vec3(0.6,0.5,0.5)*max(k3,0.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    m = iMouse;\n    m.x /= iResolution.x;\n    m.y /= iResolution.y;\n    Power = 1.0+iTime/5.0;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    vec4 data = texture( iChannel0, uv);\n    \n    \n    \n    \n    \n    r0=data.xyz;\n    \n    vec3 rd = normalize(vec3(uv.xy,1.0));\n    \n    rd.zy *= rot((m.y-0.5)*2.0);\n    rd.zx *= rot((m.x-0.5)*8.0);\n    \n    \n    float d = RayMarch(r0,rd);\n    S=steps;\n    vec3 p=r0+rd*d;\n    \n    vec3 dif = GetLight(p);\n    \n    color = mix(vec3(0.0,0.0,0.7),vec3(0.0,1.0,0.0),length(p)/7.0);\n    if(d<MAX_DIST && steps<MAX_STEPS)\n    col=dif;\n\n    float k = float(S)/float(MAX_STEPS);\n    \n    fragColor = vec4(mix(col,vec3(0.1,0.1,0.3),k),1.0);\n    //fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec4 data = texture( iChannel0, uv);\n    float L = GetDist(data.xyz);\n    vec3 D;\n    D = vec3(0.0,0.0,1.0);\n    m = iMouse;\n    m.x /= iResolution.x;\n    m.y /= iResolution.y;\n    D.zy *= rot((m.y-0.5)*2.0);\n    D.zx *= rot((m.x-0.5)*8.0);\n    if(iFrame==0)\n    fragColor = vec4(-0.018,2.7,-20.81,1.0);\n    else\n    fragColor = vec4(data.xyz+D*L/15.,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define MAX_STEPS 50\n#define MAX_DIST 130.\nvec4 m;\nfloat SURF_DIST = .005;\nfloat Power = 1.0;\nvec3 r0;\nint steps=0;\nint S;\nvec3 color;\nfloat minRadius2 = 0.0;\nfloat scale = 2.5;\nfloat fixedRadius2 = 1.0;\nvoid sphereFold(inout vec3 z, inout float dz) {\n\tfloat r2 = dot(z,z);\n\tif (r2<minRadius2) { \n\t\t// linear inner scaling\n\t\tfloat temp = (fixedRadius2/minRadius2);\n\t\tz *= temp;\n\t\tdz*= temp;\n\t} else if (r2<fixedRadius2) { \n\t\t// this is the actual sphere inversion\n\t\tfloat temp =(fixedRadius2/r2);\n\t\tz *= temp;\n\t\tdz*= temp;\n\t}\n}\nvoid boxFold(inout vec3 z, inout float dz) {\n\tz = clamp(z, -1., 1.) * 2.0 - z;\n}\nfloat DE(vec3 z)\n{\n\tvec3 offset = z;\n\tfloat dr = 1.0;\n    int iterations=17;\n\tfor (int n = 0; n < iterations; n++) {\n\t\tboxFold(z,dr);       // Reflect\n\t\tsphereFold(z,dr);    // Sphere Inversion\n \t\t\n                z=scale*z + offset;  // Scale & Translate\n                dr = dr*abs(scale)+1.0;\n\t}\n\tfloat r = length(z);\n\treturn r/abs(dr);\n}\nvoid rot(inout vec2 p, float a){  \n \tfloat c,s;vec2 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.x = c * q.x + s * q.y;  \n  \tp.y = -s * q.x + c * q.y; \n } \nstruct complex\n{\n   float x;\n   float y;\n   float z;\n};\ncomplex plus(complex a, complex b)\n{\n    complex c;\n    c.x = a.x+b.x;\n    c.y = a.y+b.y;\n    c.z = a.z+b.z;\n    return c;\n}\ncomplex mult(complex a, complex b)\n{\n     complex c;\n     c.x = a.x*b.x - a.y*b.y + a.y*b.z + a.z*b.y - a.z*b.z;\n     c.y = a.x*b.y+a.y*b.x;\n     c.z = a.x*b.z + a.z*b.x;\n     return c;\n}\nfloat smin(float a,float b,float k)\n{\n     float h=clamp(0.5+0.5*(b-a)/k,.0,1.);\n     return mix(b,a,h)-k*h*(1.-h);\n}\nfloat mand(vec3 pos)\n{\n    pos/=2.0;\n    complex Z;\n    Z.x = pos.x;\n    Z.y = pos.y;\n    Z.z = pos.z;\n    \n    float dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 40 ; i++)\n    {\n         r = sqrt(Z.x*Z.x+Z.y*Z.y+Z.z*Z.z);\n         if(r>2.0) break;\n         Z = mult(Z,Z);\n         Z.x+=pos.x;\n         Z.y+=pos.y;\n         Z.z+=pos.z;\n         complex g;\n         g.x = Z.x*2.0*dr;\n         g.y = Z.y*2.0*dr;\n         g.z = Z.z*2.0*dr;\n         \n         dr = 1.0+sqrt(g.x*g.x+g.y*g.y+g.z*g.z);\n    }\n    return 0.5*log(r)*r/dr;\n}\nfloat SDF(vec3 pos) {\n\tvec3 z = pos;\n    z.x=pos.x;\n    z.y=pos.y;\n    z.z=pos.z;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 20 ; i++) {\n\t\tr = length(z);\n        \n\t\tif (r>4.0) break;\n\t\t\n\t\t\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n        \n\t}\n\n\treturn 0.5*log(r)*r/dr;\n}\nfloat sphere(vec4 s,vec3 p)\n{\n   return length(p-s.xyz)-s.w;\n}\nfloat GetDist(vec3 p)\n{\nrot(p.xz,sin(22./11.0+1.0)*3.14);\nrot(p.yz,cos(22./14.0)*3.14);\nfloat l = DE(p);\nfloat l2 = sphere(vec4(0.0,0.0,0.0,2.0),p);\n\nif(l2>20.0)\nreturn min(l,l2);\nelse\nreturn l;\n}\nmat2 rot(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(c, -s, s, c);\n}","name":"Common","description":"","type":"common"}]}