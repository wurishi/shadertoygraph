{"ver":"0.1","info":{"id":"wtK3RR","date":"1578173446","viewed":131,"name":"me learning about transforms","username":"markbehm","description":"me trying to wrap my head around simple transforms, parent/child spaces, rotating around points in space, etc. \n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","sdf","transforms"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// todo: triplanar, noise lookup, spline sdf\n\n\nstruct Hit {\n    vec3 p;\n    float t;\n    float d;\n    float s;\n};\n\nstruct Ray {\n    vec3 o;\n    vec3 d;\n}, _ray;\n\nstruct Cam {\n    vec3 p;\n    vec3 d;\n    vec3 u;\n    float f;\n}, _cam;\n\n// ---------------------------------------------------------------------------------------------\n\n\n\n\nvec4 LoadValue( vec2 tx )\n{\n    return floor( texture( iChannel1, ( tx + 0.5 ) / iChannelResolution[ 1 ].xy ) );\n}\n\n\n\n\n\n// ##########################################################################################\n// ##########################################################################################\nvec2 map(vec3 p) {\n    float plane = p.y;\n   float d;\n    float mat;\n    vec2 res = vec2(0.0);\n    \n    float wob = sin(iTime);\n\tfloat an = iTime;\n    vec3 p2 = p - vec3(0.,1.5,0.);\n    // axis\n    float worldx = sdBox(p2, vec3(10., .04, .04));\n    \n    float worldy = sdBox(p2, vec3(.04, 10., .04));\n    mat = 8.;\n    float worldz = sdBox(p2, vec3(.04, .04 , 10.));\n    mat = 7.;\n    // PARENT ------------------------------ ( rot around origin + local rot )\n\t// rotate parent around world\n    p2.xy *= Rot(.1*iTime*3.); \n    // translate\n    p2.x += 3.; \n    p2.z += 3.;\n    // rotate local\n    p2.xz *= Rot(.1*iTime*3.); \n    float parent = sdBox(p2, vec3(1.))-.2;\n    mat = 6.;\n    // CHILD 1 ------------------------------ ( follow parent + rot local )\n    // it's coords are relative to parent\n    vec3 p3 = p2 - vec3(0.,2.,0.); \n    // rotate local\n    p3.xz *= Rot(an*3.);\n    float kid1 = sdBox(p3, vec3(.2))-.2;\n    \n    \n    // CHILD 2 ------------------------------ ( follow parent + rot around point in space (rel to parent) )\n    // it's starting coords are relative to parent\n    vec3 off = vec3( 1.0, 3.0, .0);\n    vec3 p4 = p2 - off ;\n    \n\t// this is the point we want to rotate around\t\n    vec3 p5 = p2 - vec3( 1. ,2. ,1. ) ;\n    \t\n    \n    // offset by point we want to rotate around\n    p4 -= p5;\n   \n    //p4 +=  vec3( 1.0, 2.0, 1.0 );\n    p4 = RotAxisAngle (p4, vec3(0.,1.,0.), 1.6*iTime*3.);\n    \n    // offset by inverse of point we want to rot around \n    p4 += p5;\n\n    float kid2 = sdTorus(p4, vec2(.2));\n\n    \t\n    // ---------CHILD 2 AXIS VIS -------------------\n    float kid2Axis = sdBox(p5-vec3(0.0,1.1,0.0) , vec3(.04, 1. , .04));\n    \n    // catrom fCurve\n    CtrlPts fCurve;\n        fCurve.pointCount = 10;\n\n        fCurve.p[0] = vec2( 0.0 , -1.25); // lead-in dir\n        fCurve.p[1] = vec2( 2.0 , 0.0); // 2nd pt 0 (starting pos)\n        fCurve.p[2] = vec2( 3.0 , 2.25); \n        fCurve.p[3] = vec2( 4.0 , 0.0);\n        fCurve.p[4] = vec2( 5.0 , 0.85);  \n        fCurve.p[5] = vec2( 6.0 , 0.0); \n        fCurve.p[6] = vec2( 7.0 , 0.25); \n        fCurve.p[7] = vec2( 8.0 , 0.0);\n    \tfCurve.p[8] = vec2( 9.0 , 0.1); // 2nd to last is 0 (end/start pos in loop)\n    \tfCurve.p[9] = vec2( 10.0 , -0.1);  // trail-off dir\n        float fTime = iTime*0.19;\n        vec2 v = catmullRom(fract(fTime), fCurve);\n\n\t// curve-animated cube \n    vec3 p6 = p-vec3(6.,v.y,0.); \n    float ball = sdSphere(p6,0.8);\n    \n    // user touch surface\n    vec4 mouse_loc = LoadValue(data_loc_mouse);\n    vec4 hit = vec4(1.0,1.0,1.0,0.0);\n    float pointer = sdSphere(hit.xyz,.1);\n    \n    \n    \n    \n    // build world ------------------------\n    //\n    res = smin( vec2(worldx,9.0) , vec2(worldy,8.0) ,0.01);\n    res = smin (res ,vec2(worldz,7.0) ,0.01);\n    res = smin (res,vec2(parent,6.0) ,0.01);\n    res = smin (res,vec2(kid1,6.0) ,0.01);\n \tres = smin (res,vec2(kid2,6.0) ,0.01);\n    res = smin (res,vec2(kid2Axis,7.0) ,0.01);\n    res = smin (res,vec2(ball,6.0) , 0.01);\n\tres = smin (res,vec2(pointer,9.0) , 0.01);\n   \n    return res;\n}\n// ##########################################################################################\n  \n\n\n vec2 RayMarch(vec3 ro, vec3 rd, out float dO) {\n            dO=0.;\n            vec2 dS=vec2(0.0);\n            for(int i=0; i<MAX_STEPS; i++) {\n                vec3 p = ro + rd*dO;\n                dS = map(p);\n                dO += dS.x;\n                if(dO>MAX_DIST || dS.x<SURF_DIST) break;\n            }\n\n            return vec2(dO,dS.y);\n        }\n\n\n\n/*void lookAt(vec2 uv, inout vec3 p,inout vec3 d,inout vec3 u, out float f )\n{\n    vec3 r = normalize(cross(d,u));\n    u = cross(r,d);\n    p = p*f;\n    d = normalize(uv.x*r + uv.y*u + d*f);\n\n}\n      \nHit march(Ray r)\n{\n    float t = 0., s;\n    vec2 d;\n    vec3 p;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        d = map(p = r.o + r.d*t);\n\n        if (d.x < SURF_DIST || t > MAX_DIST)\n        {\n            s = float(i);\n            break;\n        }\n\n        t += d.x/max(2.+1.,1.);\n    }\n\n    return Hit(p, t, d.x, s);\n}\n\n*/\n\n        vec3 calcNormal( in vec3 pos )\n        {\n\n            // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n            vec3 n = vec3(0.0);\n            for( int i=0; i<4; i++ )\n            {\n                vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n                n += e*map(pos+0.0005*e).x;\n            }\n            return normalize(n);\n   \n        }\n\n\n\n       \n// -------------------------------- SHADING ---------------------------------------\n\n\n\t\t// IQ > https://iquilezles.org/\n\t\tfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n        {\n            // bounding volume\n            //float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n            float res = 1.;\n            float t = mint;\n            for( int i=0; i<16; i++ )\n            {\n                vec2 h = map( ro + rd*t );\n                float a = 8.0;\n                a = 1.0;\n                float s = clamp(a*h.x/t,0.0,1.0);\n                res = min( res, s*s*(3.0-2.0*s) );\n                t += clamp( h.x\n                           , 0.02, 0.10 );\n                if( res<0.005 || t>tmax ) break;\n            }\n            return clamp( res, 0.0, 1.0 );\n        }\n\n\n\n\t\t// IQ > https://iquilezles.org/\n        float calcAO( in vec3 pos, in vec3 nor )\n        {\n            float occ = 0.0;\n            float sca = 1.0;\n\n            for( int i=0; i<4; i++ )\n            {\n                float hr = 0.01 + 0.32*float(i)/4.2;\n                vec3 aopos =  nor * hr + pos;\n                vec2 dd = map( aopos );\n                occ += -(dd.x-hr)*sca;\n                sca *= 0.95;\n            }\n            return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n            //return clamp( 1.0 - 2.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n        }\n\n\n// IQ > https://iquilezles.org/\nvec3 render(vec3 p, in vec3 ro, in vec3 rd) {\n    vec3 lightPos = vec3(3, 5, 4);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = calcNormal(p);\n    \n    // sky dome\n    vec3 col = vec3(0.5, 0.8, 0.9) - max(rd.y,0.0)*0.5;\n    // sky horizon\n\tcol = mix( col, vec3(0.5, 0.7, .9), exp(-10.0*max(rd.y,0.0)) );  \n    \n    // all scene geo\n    float t=0.;\n    vec2 res = RayMarch(ro,rd,t);\n    if( res.y>-0.5 )\n        {\n        float t = res.x;\n        vec3 n = calcNormal( p );\n        vec3 ref = reflect( rd, n );\n       float focc = 1.0; // not quite right but neither calcing AO twice. \n       //float focc =    calcAO( p, n );\n\n        // material        \n        col = vec3(0.1); // base\n        float ks = 1.0;\t     // diffuse term\n        float matRough = .2; // default roughness\n            \n            \n\t\tif( res.y>=9. )  // R\n        \t{\n             \tcol = vec3(0.09,0.02,0.02);\t\n            }\n        else if( res.y>=8. )  // G\n        \t{\n             \tcol = vec3(0.02,0.09,0.02);\t\n            }\n            \n\t\telse if( res.y>=7. )  // B\n        \t{\n             \tcol = vec3(0.02,0.02,0.08);\t\n            }\n            \n        else if( res.y>=6. )  // gray\n        \t{\n             \tcol = vec3(0.2, 0.2, 0.2);\t\n            }    \n        // lighting (sun, sky, bounce, back, sss)\n        float occ = calcAO( p, n )*focc;\n        float fre = clamp(1.0+dot(n,rd),0.0,1.0);\n        \n        vec3  sun_lig = normalize( vec3(0.6, 0.35, 0.5) );\n        float sun_dif = clamp(dot( n, sun_lig ), 0.0, 1.0 );\n        vec3  sun_hal = normalize( sun_lig-rd );\n        float sun_sha = calcSoftshadow( p, sun_lig, 0.02, 2.5 );//in vec3 ro, in vec3 rd, in float mint, in float tmax\n        \n        float sun_spe = pow( clamp(dot(sun_hal,n), 0.0, 1.0 ), exp2( 10.0*(1.0-matRough)) ); \n            \n\t\t//float sun_spe = ks*pow(clamp(dot(n,sun_hal),0.0,1.0),8.0)*sun_dif*(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n\t\tfloat sky_dif = sqrt(clamp( 0.5+0.5*n.y, 0.0, 1.0 ));\n        float sky_spe = ks*smoothstep( 0.0, 0.5, ref.y )*(0.04+0.96*pow(fre,4.0));\n        float bou_dif = sqrt(clamp( 0.1-0.9*n.y, 0.0, 1.0 ))*clamp(1.0-0.1*p.y,0.0,1.0);\n        float bac_dif = clamp(0.1+0.9*dot( n, normalize(vec3(-sun_lig.x,0.0,-sun_lig.z))), 0.0, 1.0 );\n        float sss_dif = fre*sky_dif*(0.25+0.75*sun_dif*sun_sha);\n\n\t\tvec3 lin = vec3(0.0);\n        lin += sun_dif*vec3(8.10,6.00,4.20)*vec3(sun_sha,sun_sha*sun_sha*0.5+0.5*sun_sha,sun_sha*sun_sha);\n        lin += sky_dif*vec3(0.50,0.70,1.00)*occ;\n        lin += bou_dif*vec3(0.20,0.70,0.10)*occ;\n        lin += bac_dif*vec3(0.45,0.35,0.25)*occ;\n        lin += sss_dif*vec3(3.25,2.75,2.50)*occ;\n\t\tcol = col*lin;\n\t\tcol += sun_spe*vec3(9.90,8.10,6.30)*sun_sha;\n        col += sky_spe*vec3(0.20,0.30,0.65)*occ*occ;\n      \t\n        col = pow(col,vec3(0.8,0.9,1.0) );\n        \n         //fog\n        col = mix( col, vec3(0.38,0.67,0.9), 1.0-exp( -0.00001*t*t*t ) ); // fewer 0000's brings fog closer\n            \n            \n       \n        }\n    return col;\n}\n\n  \n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 mouse_loc = LoadValue(data_loc_mouse);\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  \tvec3 col = vec3(0);\n    vec3 ro = vec3(2, 6, 15);\n    vec3 rd = R(uv, ro, vec3(0,1,0), 1.);\n    float t=0.;\n    vec2 d = RayMarch(ro, rd, t);\n    \n    \n    \tvec3 p = ro + rd * d.x;\n\n    \t\t\tcol = render(p, ro, rd);\n    // color grading\n    col = col*vec3(1.2,1.2,1.1);\n\n    // compress        \n    col = 1.35*col/(1.0+col);\n\n    // gamma\n    col = pow( col, vec3(0.4545) );\n            \n    // s-surve    \n    col = clamp(col,0.0,1.0);\n    col = col*col*(3.0-2.0*col);\n\n    // vignetting        \n    vec2 q = fragCoord/iResolution.xy;\n    col *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);        \n        \n    \n\t \n    \n\t\n  //UI integration \n  //vec2 qq = fragCoord.xy/iResolution.xy;\n // vec4 ui = texture(iChannel0,qq);\n //col = mix(col,ui.rgb, ui.a*.8); \n   // write\n fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define CATROM_MAX_POINTS 32\n#define RES (1./1.)\n\n#define data_loc_mouse vec2(18.,0)\n\n\n#define inside(a) (fragCoord.x == a.x+0.5 && fragCoord.y == a.y+0.5)\n//#define inside_range(a) (fragCoord.x >= a.x+0.5 && fragCoord.x <= (a.x+a.z)+0.5 && fragCoord.y == a.y+0.5)\n#define load(a,b) texture(b,(a+0.5)/iResolution.xy)\n#define save(a,b) if(inside(a)){fragColor=b;return;}\n\n\n\n// Load/store from  knarkowicz - https://www.shadertoy.com/user/knarkowicz\n\t// const vec2 txPlayerState \t= vec2( 11.0, 0.0 ); \t// x - state, y - frame, z - jump tick, w - lifes\n    // StoreValue( txPlayerState, gPlayer, fragColor, fragCoord );\n\t// gPlayerState   \t= LoadValue( txPlayerState );\n\n\n\n    // catrom spline \n    struct CtrlPts\n    {\n        int pointCount; //  \t\t( pointCount must be set each time u (re)build new point list)\n        vec2 p[CATROM_MAX_POINTS];\n    };\n\n   vec2 catmullRom(float fTime, CtrlPts ctrlPts)\n    {\n        float t = fTime;\n        const float n = float(CATROM_MAX_POINTS);\n\n        int idxOffset = int(t*n);\n        vec2 p1 = ctrlPts.p[idxOffset];\n        vec2 p2 = ctrlPts.p[idxOffset+1];\n        vec2 p3 = ctrlPts.p[idxOffset+2];\n        vec2 p4 = ctrlPts.p[idxOffset+3];\n\n        //For some reason, fract(t*n) returns garbage on my machine with small values of t.\n        //return fract(n*t);\n        //Using this below yields the same results, minus the glitches.\n        t *= n;\n        t = (t-float(int(t)));\n\n        //A classic catmull-rom\n        //e.g.\n        //http://steve.hollasch.net/cgindex/curves/catmull-rom.html\n        //http://www.lighthouse3d.com/tutorials/maths/catmull-rom-spline/\n        vec2 val = 0.5 * ((-p1 + 3.*p2 -3.*p3 + p4)*t*t*t\n                   + (2.*p1 -5.*p2 + 4.*p3 - p4)*t*t\n                   + (-p1+p3)*t\n                   + 2.*p2);\n        return val;     \n    }\n    \n\n//-- TRANSFORMS --------------------------------------------------------------------------------------------------------------\n\t\t//by Martijn Steinrucken aka BigWings/CountFrolic\n        mat2 Rot(float a) {\n            float s = sin(a);\n            float c = cos(a);\n            return mat2(c, -s, s, c);\n        }\n\n        // IQ > https://iquilezles.org/articles/noacos\n        mat3x3 rotationAlign( vec3  d, vec3 z ){\n            vec3  v = cross( z, d );\n            float c = dot( z, d );\n            float k = 1.0f/(1.0f+c);\n            return mat3x3( v.x*v.x*k + c, v.y*v.x*k - v.z, v.z*v.x*k + v.y, v.x*v.y*k + v.z, v.y*v.y*k + c, v.z*v.y*k - v.x,v.x*v.z*k - v.y, v.y*v.z*k + v.x, v.z*v.z*k + c);\n            }\n\n\n        // http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n        vec3 RotAxisAngle(vec3 point, vec3 axis, float angle){\n            axis = normalize(axis);\n            float s = sin(angle);\n            float c = cos(angle);\n            float oc = 1.0 - c;\n\n            mat4 rot= mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,oc * axis.y * axis.z - axis.x * s,  0.0,\n                        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                        0.0,0.0,0.0,1.0);\n            return (rot*vec4(point,1.)).xyz;\n        }\n// -----------------Marching -------------------\n\n      \tvec3 lookAt(vec3 ro, vec3 rd)\n           {\n                vec3 dir = normalize(rd);\n                vec3 right = normalize(cross(rd, vec3(0,1,0)));\n                vec3 up = cross(right, rd);\n\n                return (normalize(right*rd.x + up*rd.y + dir) );\n           }\n\n        mat3 lookAt2(in vec3 eye, in vec3 tar, in float r){\n            vec3 cw = normalize(tar - eye);// camera w\n            vec3 cp = vec3(sin(r), cos(r), 0.);// camera up\n            vec3 cu = normalize(cross(cw, cp));// camera u\n            vec3 cv = normalize(cross(cu, cw));// camera v\n            return mat3(cu, cv, cw);\n        }\n \t\tvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n            vec3 f = normalize(l-p),\n                r = normalize(cross(vec3(0,1,0), f)),\n                u = cross(f,r),\n                c = p+f*z,\n                i = c + uv.x*r + uv.y*u,\n                d = normalize(i-p);\n            return d;\n        }\n\n     \n\n// ------- SDF SHAPES ----------------------------------------------------\n       // https://iquilezles.org/articles/smin\n\t\tfloat smin( float a, float b, float k ) {\n            float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n            return mix( b, a, h ) - k*h*(1.0-h);\n        }\n\t\t\n        // https://iquilezles.org/articles/smin\n        vec2 smin( vec2 a, vec2 b, float k )\n        {\n            float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n            return mix( b, a, h ) - k*h*(1.0-h);\n        }\n\t\tvec2 smax( vec2 a, vec2 b, float k ){\n            float h = clamp( 0.5 + 0.5*(b.x-a.x)/k, 0.0, 1.0 );\n            return vec2(mix( a.x, b.x, h ) + k*h*(1.0-h),mix(a.y,b.y,h));\n        }\n\n\n        float sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n            vec3 ab = b-a;\n            vec3 ap = p-a;\n\n            float t = dot(ab, ap) / dot(ab, ab);\n            t = clamp(t, 0., 1.);\n\n            vec3 c = a + t*ab;\n\n            return length(p-c)-r;\n        }\n\n        float sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n            vec3 ab = b-a;\n            vec3 ap = p-a;\n\n            float t = dot(ab, ap) / dot(ab, ab);\n            t = clamp(t, 0., 1.);\n\n            vec3 c = a + t*ab;\n\n            float x = length(p-c)-r;\n            float y = (abs(t-.5)-.5)*length(ab);\n            float e = length(max(vec2(x, y), 0.));\n            float i = min(max(x, y), 0.);\n\n            return e+i;\n        }\n\n        float sdTorus(vec3 p, vec2 r) {\n            float x = length(p.xz)-r.x;\n            return length(vec2(x, p.y))-r.y;\n        }\n\n        float sdBox(vec3 p, vec3 s) {\n            p = abs(p)-s;\n            return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n        }\n\n        // https://iquilezles.org/articles/distfunctions\n        float sdSphere( vec3 p, float s )\n        {\n            return length(p)-s;\n        }\n\n        // https://iquilezles.org/articles/distfunctions\n        float sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n        {\n            float k0 = length(p/r);\n            float k1 = length(p/(r*r));\n            return k0*(k0-1.0)/k1;\n        }\n\n        vec2 sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2) // approximated\n        {\n            vec3 pa = p-a, ba = b-a;\n            float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n            return vec2( length( pa - ba*h ) - mix(r1,r2,h*h*(3.0-2.0*h)), h );\n        }\n         //---- BEZ --------------------------------------------------------------\n                float det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\n                vec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) \n                {\n\n                  float a =     det(b0,b2);\n                  float b = 2.0*det(b1,b0);\n                  float d = 2.0*det(b2,b1);\n                  float f = b*d - a*a;\n                  vec2  d21 = b2-b1;\n                  vec2  d10 = b1-b0;\n                  vec2  d20 = b2-b0;\n                  vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n                  vec2  pp = -f*gf/dot(gf,gf);\n                  vec2  d0p = b0-pp;\n                  float ap = det(d0p,d20);\n                  float bp = 2.0*det(d10,d0p);\n                  float t = clamp( (ap+bp)/(2.0*a+b+d), 0.0 ,1.0 );\n                  return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n                }\n\t\tvec2 sdBezier( vec3 a, vec3 b, vec3 c, vec3 p )\n        {\n            vec3 w = normalize( cross( c-b, a-b ) );\n            vec3 u = normalize( c-b );\n            vec3 v =          ( cross( w, u ) );\n\n            vec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n            vec2 b2 = vec2( 0.0 );\n            vec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n            vec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n            vec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n\n            return vec2( sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z), cp.z );\n        }\n\n// ----------- TEXTURE STUFF -----------------------------------------------------------------------\nfloat tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).x;\n}\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n   \n    const float eps = 0.001;\n    float ref = tex3D(tex,  p , nor);                 \n    vec3 grad = vec3( tex3D(tex, vec3(p.x-eps, p.y, p.z), nor)-ref,\n                      tex3D(tex, vec3(p.x, p.y-eps, p.z), nor)-ref,\n                      tex3D(tex, vec3(p.x, p.y, p.z-eps), nor)-ref )/eps;\n             \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}","name":"Common","description":"","type":"common"}]}