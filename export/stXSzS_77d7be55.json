{"ver":"0.1","info":{"id":"stXSzS","date":"1641577863","viewed":199,"name":"Boids 2.0","username":"arifr123","description":"My second attempt implementing Boids, this time with an emphasis on run time.\nEnded up using this Voronoi-like data structure in order to be able to access particles' neighbors quickly.\nRed particles are predators. The mouse is also one.\nCLICK A OR/AND B.","likes":12,"published":1,"flags":48,"usePreview":0,"tags":["boids"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nNOTE: The code is not complete:\nI still have a problem of boids population decreasing over time.\n*/\n\n#define A 65\n#define B 66\n\nvec3 col_from_vel(vec2 vel);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    ivec2 resolution = ivec2(iResolution);\n    \n    vec3 col = vec3(0, 0, 0);\n\n    vec4 state = texelFetch(iChannel0, coord, 0);\n    \n    \n    const float period0 = 5.;\n    const float period1 = 5.;  // 10.\n    \n    const float total = period0 + period1;\n    \n    float time = mod(iTime + period0, total);  // [0., total)\n    float time1 = (time - period0) / period1;  // [0, 1)\n    \n    float click_A = 1. - texelFetch(iChannel1, ivec2(A, 2), 0).x;\n    float click_B = texelFetch(iChannel1, ivec2(B, 2), 0).x;\n    \n    switch(getMode(state))\n    {\n        case PARTICLE:\n            //col.xy = 0.5 * getVelocity(state) + 0.5;\n            //col.z = 1.;\n            \n            col = vec3(1);\n            \n            if(isPredator(state)) col = vec3(1, 0, 1);\n            \n            break;\n\n        case VORONOI:\n            vec4 particleState = bufferA(getOriginOffset(state) + coord);        \n        \n            col = click_A * col_from_vel(getVelocity(particleState));\n            \n            if(hasNeighbor(state))\n            {            \n                particleState = bufferA(getNeighborOffset(state) + coord);  \n\n                col += click_B * col_from_vel(getVelocity(particleState));\n            }\n            \n            col /= click_A + click_B + step(click_A + click_B, 0.1);\n                                    \n            break;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n// https://www.shadertoy.com/view/MsS3Wc\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 col_from_vel(vec2 vel)\n{\n    // 0.05 * vel + 0.5;\n    return hsv2rgb_smooth(vec3(atan(vel.y, vel.x) / (2. * PI) + 0.5, 1., 0.5 * length(vel)));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 centerOfPoints(vec2 p0, vec2 p1, vec2 p2);\nbool orientation(vec2 p0, vec2 p1, vec2 p2);\n\nvec4 particleUpdate(vec4 state)\n{\n    vec2 position = getPositionOffset(state);\n    vec2 velocity = getVelocity(state);\n        \n    setPositionOffset(state, position + velocity);\n    \n    return state;\n}\n\n\n///////////////////////////////////\n\nivec2 relSquare(int i)\n{\n    return clamp(abs((ivec2(0, 2) + i) % 8 - 3) - 2, -1, 1);\n}\n\nivec2 absSquare(int i, int n)\n{\n    if(n <= 0)\n    {\n        n++;  // weird\n        return ivec2(0);\n    }\n    return clamp(abs((ivec2(0, 2*n) + i) % (8*n) - 3*n) - 2*n, -n, n);\n}\n\n///////////////////////////////////\n\n\n\n\n#define SIZE 2\n\nivec2 particleCatchClamp(ivec2 newParticlePosition)\n{\n    return clamp(newParticlePosition, -SIZE, SIZE);\n    \n    //return crossClamp(newParticlePosition);\n}\n\n\nivec2 voronoiOffsetsUpdate(ivec2 linkedParticleCoordOffset, ivec2 coord)\n{    \n    if(linkedParticleCoordOffset == ivec2(0)) return ivec2(0);  // Optimization\n    \n    vec4 linkedParticleState = bufferA(linkedParticleCoordOffset + coord);  // TODO: Did I allredy accessed it?\n    \n    if(getMode(linkedParticleState) != PARTICLE) return ivec2(0);\n    \n    return linkedParticleCoordOffset + particleCatchClamp(ivec2(getPositionOffset(linkedParticleState)));\n}\n\nivec2 compareNeighbors(ivec2 iOrigin, ivec2 iNeighbor0, ivec2 iNeighbor1, vec2 fragCoord)\n{\n    if(iNeighbor0 == iNeighbor1) return iNeighbor0;\n    \n    vec2 origin = vec2(iOrigin);\n    vec2 neighbor0 = vec2(iNeighbor0);\n    vec2 neighbor1 = vec2(iNeighbor1);\n\n    vec2 center = centerOfPoints(origin, neighbor0, neighbor1);\n    \n    if(orientation(origin, center, fragCoord) == orientation(origin, neighbor1, neighbor0))\n    {\n        return iNeighbor0;\n    }\n    else\n    {\n        return iNeighbor1;\n    }\n}\n\n// returns whether a particle was caught.\nbool catchParticle(ivec2 coord, inout vec4 fragColor, ivec2 otherCoord, vec4 other)\n{            \n    if(particleCatchClamp(ivec2(getPositionOffset(other))) + otherCoord == coord)\n    {\n        vec4 newState = particleUpdate(other);\n        \n        setPositionOffset(fragColor, getPositionOffset(newState) + vec2(otherCoord) - vec2(coord));\n        setVelocity(fragColor, getVelocity(newState));\n        \n        if(isPredator(other)) setPredator(fragColor);\n        else setNotPredator(fragColor);\n        \n        return true;\n    }\n\n    return false;\n}\n\nvoid voroniHandleParticle(ivec2 coord, inout vec4 fragColor, ivec2 particleCoord, vec4 particle)\n{\n    if(\n        getMode(fragColor) != VORONOI \n        || \n        (\n            particleCoord != coord + getOriginOffset(fragColor)\n            &&\n            //                            TODO: Add position offset?\n            sq(vec2(particleCoord + ivec2(getPositionOffset(particle)) - coord)) < sq(vec2(getOriginOffset(fragColor)))\n        )\n    )\n    {\n        setOriginOffset(fragColor, particleCoord - coord);\n        setNoNeighbor(fragColor);\n    }\n}\n\n\nvoid voronoiHandelVoronoi(ivec2 coord, inout vec4 fragColor, ivec2 otherPosition, vec4 other)\n{\n    ivec2 otherOrigin = getOriginOffset(other) + otherPosition;\n    ivec2 otherNeighbor = getNeighborOffset(other) + otherPosition;\n    \n    if(getMode(fragColor) != VORONOI)  // THIS is (probably) NONE\n    {\n        setOriginOffset(fragColor, otherOrigin - coord);\n        \n        if(hasNeighbor(other))\n        {\n            setNeighborOffset(fragColor, otherNeighbor - coord);\n        }\n        else\n        {\n            setNoNeighbor(fragColor);\n        }\n        \n        return;\n    }\n    \n    // THIS is VORONOI.\n    \n    if(coord + getOriginOffset(fragColor) == otherOrigin)\n    {\n        if(!hasNeighbor(fragColor))\n        {\n            if(hasNeighbor(other))\n            {\n                setNeighborOffset(fragColor, otherNeighbor - coord);\n            }\n            \n            return;\n        }\n        if(!hasNeighbor(other))\n        {\n            // Don't change the current Neighbor.\n            \n            return;\n        }\n        \n        // Both THIS and OTHER has neighbors.\n        \n        //                                                                                                              TODO: ???\n        setNeighborOffset(fragColor, compareNeighbors(otherOrigin, getNeighborOffset(fragColor) + coord, otherNeighbor, vec2(coord)) - coord);\n        \n        return;\n    }\n    \n    // The origins are diffrent.\n    \n    if(sq(vec2(otherOrigin - coord)) < sq(vec2(getOriginOffset(fragColor))))\n    {\n        setOriginOffset(fragColor, otherOrigin - coord);\n        \n        if(hasNeighbor(other))\n        {\n            setNeighborOffset(fragColor, otherNeighbor - coord);\n        }\n        else\n        {\n            setNoNeighbor(fragColor);\n        }\n        \n        return;\n    }\n    \n    // Current origin (of THIS) is closer then OTHER's origin\n    \n    if(!hasNeighbor(fragColor))\n    {\n        setNeighborOffset(fragColor, otherOrigin - coord);\n        \n        return;\n    }\n    \n    // THIS has a neighbor\n    \n    setNeighborOffset(fragColor, compareNeighbors(coord + getOriginOffset(fragColor), getNeighborOffset(fragColor) + coord, otherOrigin, vec2(coord)) - coord);\n}\n\n\nmat2x2 updateForbiddenDirs(mat2x2 forbidden_dirs, vec2 newDir)\n{\n    mat2x2 new_forbidden_dirs = forbidden_dirs;\n\n    float d_ab = -dot(forbidden_dirs[0], forbidden_dirs[1]);\n    float d_bc = -dot(forbidden_dirs[1], newDir);\n    float d_ca = -dot(newDir, forbidden_dirs[0]);\n\n    if(d_ab < d_ca)\n    {\n        new_forbidden_dirs[0] = newDir;\n\n        if(d_bc < d_ca)\n        {\n            new_forbidden_dirs[1] = forbidden_dirs[0];\n        }\n    }\n    else\n    {\n        new_forbidden_dirs[0] = forbidden_dirs[1];\n\n        if(d_bc < d_ab)\n        {\n            new_forbidden_dirs[1] = forbidden_dirs[0];\n        }\n        else\n        {\n            new_forbidden_dirs[1] = newDir;\n        }\n    }\n    \n    return new_forbidden_dirs;\n}\n\n\n#define RING_SIZE 2\n\nvoid particleLogic(vec2 fragCoord, ivec2 coord, inout vec4 fragColor)\n{\n    vec2 velocity = getVelocity(fragColor);\n    vec2 position = fragCoord + getPositionOffset(fragColor);\n    \n    float neighborsNum = 0.;\n    float coefSum = 0.;\n    \n    vec2 separation = vec2(0);\n    vec2 alignment = vec2(0);\n    vec2 cohesion = vec2(0);\n    \n    ivec2 prevNeighbor = ivec2(-1);\n    ivec2 firstNeighbor = ivec2(-1);\n    \n    bool use_forbidden_dirs = false;\n    mat2x2 forbidden_dirs = mat2x2(0.);\n\n    for(int i = 0; i < RING_SIZE * 8; i++)\n    {\n        ivec2 shift = absSquare(i, RING_SIZE);\n        \n        ivec2 otherCoord = coord + shift;\n        vec4 other = bufferA(otherCoord);\n        \n        int mode = getMode(other);\n        \n        if(mode == VORONOI)// && getOriginOffset(other) + otherCoord == coord)  // TODO: Not compleate.  // TODO: Check this???\n        {\n            ivec2 currentNeighbor = getNeighborOffset(other) + otherCoord;\n            \n            //                       TODO: wtf\n            if(hasNeighbor(other) && sq(vec2(currentNeighbor - coord)) > sq(1.) && currentNeighbor != prevNeighbor && currentNeighbor != firstNeighbor)\n            {\n                vec4 neighborState = bufferA(currentNeighbor);\n                vec2 neighborPosition = vec2(currentNeighbor) + getPositionOffset(neighborState);\n                \n                if(isPredator(neighborState))\n                {\n                    vec2 delta = fragCoord - neighborPosition;\n                    separation += 4. * normalize(delta) * step(sq(delta), sq(40.)) * (40. - length(delta));\n                }\n                else\n                {\n                    vec2 delta = fragCoord - neighborPosition;\n                    separation += step(sq(delta), sq(12.)) * delta;\n                    \n                    //separation += 20. * normalize(delta) / sq(delta);\n                    \n                    //const float start_growing = 6.;\n                    //separation += step(sq(delta), sq(start_growing)) * normalize(delta) * (2. * (start_growing - length(delta)));\n\n                    float coef = exp(-sq(delta)/sq(8.));\n\n                    alignment += coef * getVelocity(neighborState);\n                    cohesion += coef * neighborPosition;\n\n                    coefSum += coef;\n\n                    neighborsNum += 1.;\n                }\n                \n                ///\n                vec2 delta = neighborPosition - position;\n                if(sq(delta) < sq(5.)) \n                {\n                    delta = normalize(delta);\n                    \n                    if(use_forbidden_dirs)\n                    {\n                        forbidden_dirs = updateForbiddenDirs(forbidden_dirs, delta);\n                    }\n                    else\n                    {\n                        use_forbidden_dirs = true;\n                        \n                        forbidden_dirs[0] = forbidden_dirs[1] = delta;\n                    }\n                }\n                ///\n                \n                if(firstNeighbor == ivec2(-1)) firstNeighbor = currentNeighbor;\n                \n                prevNeighbor = currentNeighbor;\n            }\n        }\n    }\n    \n    if(neighborsNum < 0.5 || coefSum < 0.000001)\n    {\n        alignment = vec2(0);\n        cohesion = vec2(0);\n    }\n    else\n    {\n        alignment /= coefSum;\n        alignment = alignment - velocity;\n\n        cohesion /= coefSum;\n        cohesion = cohesion - position;\n    }\n    \n    //velocity += 0.02 * separation;\n    //velocity += 0.002 * alignment;\n    //velocity += 0.005 * cohesion;\n    \n    vec2 a = vec2(0.);\n    \n    a += 2. * separation;\n    a += 30. * alignment;\n    a += 0.3 * cohesion;\n    \n    vec2 delta = iMouse.xy - position;\n    a += -10000. * step(0., iMouse.z) * normalize(delta) / sq(delta);\n    \n    velocity += 0.01 * a;\n    \n    //setVelocity(fragColor, velocity);\n    \n    \n    for(int i = 0; i < 2; i++)\n    {\n        vec2 forbidden_direction = forbidden_dirs[i];\n        velocity -= forbidden_direction * max(0., dot(forbidden_direction, velocity));\n    }\n    \n    \n    float velLen = length(velocity);\n    setVelocity(fragColor, min(velLen, float(SIZE)) * normalize(velocity));\n}\n\n\n#define voronoiSpreadFunction(n) ((2 * (2 * SIZE + 1) - 1) * n)\n//#define voronoiSpreadFunctionInverse(n) pow(n, 1./2.)\n//#define START_N int(floor(1. + voronoiSpreadFunctionInverse(float(SIZE))))\n#define START_N 1\n#define N_NUM 2\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    // ivec2 resolution = ivec2(iResolution);\n\n    if(iFrame == 0)\n    {\n        fragColor = getNone();\n    \n        uint index = uint(coord.x + coord.y * int(iResolution.x));\n        float hash_val = hash1(index);\n        const float total_percent = 0.002;\n        if(hash_val < total_percent)  // 0.0005\n        {\n            float angle = 2. * PI * hash1(index+1u);\n            \n            setPositionOffset(fragColor, 0.);\n            setVelocity(fragColor, 1.*cis(angle));\n            \n            if(hash_val < total_percent * 0.02)\n            {\n                setPredator(fragColor);\n            }\n        }\n    \n        return;\n    }\n    \n    fragColor = getNone();\n    \n    float minDist = -1.;\n    \n    bool caughtParticle = false;\n    \n    \n    for(int x = - SIZE; x <= SIZE && !caughtParticle; x++)\n    for(int y = - SIZE; y <= SIZE && !caughtParticle; y++)\n    {\n        ivec2 shift = ivec2(x, y);\n        \n        ivec2 otherCoord = coord + shift;\n        vec4 other = bufferA(otherCoord);\n        \n        //ivec2 otherPosition = closestTo(ivec2(getPosition(other)), coord);\n        //ivec2(getPosition(other)) - resolution * ((coord + shift) / resolution);\n        \n        switch(getMode(other))\n        {\n            case PARTICLE:\n                if(catchParticle(coord, fragColor, otherCoord, other))\n                {\n                    caughtParticle = true;\n                    break;\n                }\n                \n                voroniHandleParticle(coord, fragColor, otherCoord, other);\n\n                break;\n\n            case VORONOI:\n                voronoiHandelVoronoi(coord, fragColor, otherCoord, other);\n                \n                break;\n        }\n    }\n    \n    if(caughtParticle)\n    {\n        particleLogic(fragCoord, coord, fragColor);\n    }\n    else\n    {\n        for(int n = START_N; n < START_N + N_NUM; n++)\n        for(int i = 1; i < 8; i += 2)\n        {\n            ivec2 shift = voronoiSpreadFunction(n)*relSquare(i);\n\n            ivec2 otherCoord = coord + shift;\n            vec4 other = bufferA(otherCoord);\n            \n            //ivec2 otherPosition = closestTo(ivec2(getPosition(other)), coord);\n\n            switch(getMode(other))\n            {\n                case PARTICLE:\n                    voroniHandleParticle(coord, fragColor, otherCoord, other);\n\n                    break;\n\n                case VORONOI:\n                    voronoiHandelVoronoi(coord, fragColor, otherCoord, other);\n\n                    break;\n            }\n        }\n    }\n    \n    \n    if(getMode(fragColor) == VORONOI)\n    {\n        ivec2 newOriginOffset = voronoiOffsetsUpdate(getOriginOffset(fragColor), coord);\n        ivec2 newNeighborOffset = voronoiOffsetsUpdate(getNeighborOffset(fragColor), coord);\n    \n        if(newOriginOffset == ivec2(0))  // You can, not have a neighbor. But you can't not have a origin as a VORONOI.\n        {\n            fragColor = getNone();\n        }\n        else\n        {\n            setOriginOffset(fragColor, newOriginOffset);\n            setNeighborOffset(fragColor, newNeighborOffset);\n        }\n    }\n}\n\n\nvec2 centerOfPoints(vec2 p0, vec2 p1, vec2 p2)\n{\n    mat4x3 mat = mat4x3(vec3(1),\n                        vec3(p0.y, p1.y, p2.y),\n                        vec3(p0.x, p1.x, p2.x),\n                        vec3(sq(p0), sq(p1), sq(p2)));\n                        \n    float m11 = determinant(mat3x3(mat[0], mat[1], mat[2]));\n    \n    return vec2(determinant(mat3x3(mat[0], mat[1], mat[3])), \n                determinant(mat3x3(mat[0], mat[2], mat[3]))) * 0.5 * vec2(1, -1) / m11;\n}\n\nbool orientation(vec2 p0, vec2 p1, vec2 p2)\n{\n    return determinant(mat2x2(p1 - p0, p2 - p0)) > 0.;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\n    Format:\n        Particle: vec4(vec2({Position}), vec2({Velocity}))\n        Voronoi:  vec4(-vec2({Origin}) , vec2({Neighbor}))\n        None:     vec4()\n        \n    0. < {Position} <= iResolution.xy\n    \n    mode(state) = (state.x > 0.) ? PARTICLE : VORONOI\n*/\n\n#define sq(x) dot(x, x)\n#define iSq(x) x*x\n#define cis(x) vec2(cos(x), sin(x))\n\n#define PI 3.14159265359\n\n#define NONE 0\n#define PARTICLE 1\n#define VORONOI 2\n\n#define getMode(state) _getMode(state, iResolution.xy)\nint _getMode(vec4 state, vec2 iResolution)\n{\n    if(state.x < -iResolution.x / 2. - 1.) return NONE;\n    else if(state.x < iResolution.x / 2. - 0.01) return PARTICLE;\n    else return VORONOI;\n}\n\n#define bufferA(coord) texelFetch(iChannel0, ivec2(mod(vec2(coord), iResolution.xy)), 0)\n//#define bufferA(coord) texelFetch(iChannel0, coord, 0)\n\n\n#define offsetNormalize(v) (mod(v + iResolution.xy / 2., iResolution.xy) - iResolution.xy / 2.)\n\n#define setPositionOffset(state, pos) state.xy = offsetNormalize(pos)\n#define getPositionOffset(state) (state).xy\n\n#define setOriginOffset(state, origin) (state).xy = offsetNormalize(vec2(origin)) + iResolution.xy\n#define getOriginOffset(state) ivec2((state).xy - iResolution.xy)\n\n#define setVelocity(state, vel) (state).zw = iResolution.xy * round((state).zw / iResolution.xy) + offsetNormalize(vel)\n#define getVelocity(state) offsetNormalize((state).zw)\n#define setPredator(state) (state).zw = offsetNormalize((state).zw) + iResolution.xy\n#define setNotPredator(state) (state).zw = offsetNormalize((state).zw)\n#define isPredator(state) ((state).z >= iResolution.x / 2.)\n\n#define setNeighborOffset(state, nei) (state).zw = offsetNormalize(vec2(nei))\n#define getNeighborOffset(state) ivec2((state).zw)\n#define setNoNeighbor(state) state.zw = vec2(0)\n#define hasNeighbor(state) (sq(state.zw) > 0.5)\n\n\n#define getNone() vec4(-iResolution.xy, 0., 0.)\n\n\n// https://www.shadertoy.com/view/llGSzw\n\nfloat hash1( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n","name":"Common","description":"","type":"common"}]}