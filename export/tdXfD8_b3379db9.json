{"ver":"0.1","info":{"id":"tdXfD8","date":"1588123355","viewed":158,"name":"Simple DNA helis ","username":"MetRiko","description":"DNA helis","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","simple","depth","dna"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\n\nconst vec3 BACK = vec3(0,0,0);\nconst vec3 COLOR = vec3(0.8,0.8,0.7);\nconst vec3 SHADOW = vec3(0.2,0.2,0.35);\n\nconst float SPACE = 60.0; // space between lines\nconst float RADIUS = 80.0;\nconst float WIDTH = 4.0;\nconst float SQUARE_SIZE = 30.0;\nconst float MIN_SQUARE_SIZE = 15.0;\n\nconst float ANGLE = PI * 0.125 * 0.5;\nconst float Y_POSITION = 140.0;\nconst float TIME_SCALE = 16.0;\n\n// Draw rectangle\nfloat rectangle(vec2 coord, vec2 pos, vec2 size, float depth) { \n    vec2 bl = smoothstep(pos - size * 0.5 - 1.0 - depth, pos - size * 0.5 + 1.0 + depth, coord);\n\tvec2 tr = smoothstep(coord - 1.0 - depth, coord + 1.0 + depth, pos + size * 0.5);\n    return bl.x * bl.y * tr.x * tr.y;\n}\n\n// Range conversion: -1.0 - 1.0 -> 0.0 - 1.0\nfloat range(float x) { \n\treturn x * 0.5 + 0.5;\n}\n\n// 2D rotation matrix\nmat2 rotate(float a){\n    return mat2(cos(a), -sin(a),\n                sin(a), cos(a));\n}\n\nfloat linstep(float a, float b, float c) {\n\treturn clamp((c - a) / (b - a), 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float t = iTime * TIME_SCALE;\n    vec2 fc = rotate(ANGLE) * fragCoord;\n    float x = fc.x; // + t * 4.0;\n    float y = fc.y - Y_POSITION;\n       \n    // SINGLE ELEMENT COORD\n    \n    vec2 elCoord = vec2(mod(x, SPACE) - SPACE * 0.5, y);\n    x = floor(x / SPACE) * SPACE + t;\n    \n    // CALC\n    \n    float angle = -x * 0.097;\n    float sinV = sin(angle);\n    float cosV = cos(angle);\n    \n    // POSITIONS\n    \n    vec2 p1 = vec2(cosV, sinV);\n    vec2 p2 = vec2(-cosV, -sinV);\n    \n    // CONDITIONS\n    \n    bool condA = p1.x < p2.x; // amplitude condition\n    bool condI = p1.y < p2.y; // intersection condition\n    \n    // DEPTHS\n    \n    float lineDepth = mix(range(p1.x), range(p2.x), linstep(p1.y * RADIUS, p2.y * RADIUS, y));\n    float sq1Depth = range(p1.x);\n    float sq2Depth = range(p2.x);\n    \n    // SHAPES : LINE\n    \n    float lineHeight = abs(sinV) * RADIUS * 2.0 + 1.0;   \n    float line = rectangle(elCoord,  vec2(0.0), vec2(WIDTH, lineHeight), lineDepth * 3.0); \n    \n    // SHAPES : SQUARES\n    \n    float sqSize1 = mix(SQUARE_SIZE, MIN_SQUARE_SIZE, sq1Depth);\n    float sqSize2 = mix(SQUARE_SIZE, MIN_SQUARE_SIZE, sq2Depth);\n    \n    float[2] sq = float[2](\n    \trectangle(elCoord,  vec2(0.0, p1.y * RADIUS), vec2(sqSize1), sq1Depth * 3.0),\n    \trectangle(elCoord,  vec2(0.0, p2.y * RADIUS), vec2(sqSize2), sq2Depth * 3.0)\n    );\n    \n    // COLORS\n    \n    vec3[2] sqColors = vec3[2](\n        mix(COLOR, SHADOW, sq1Depth),\n        mix(COLOR, SHADOW, sq2Depth)\n    );\n    vec3 lineColor = mix(COLOR, SHADOW, lineDepth);\n    \n    vec3 color = mix(BACK, lineColor, float(line));\n    color = mix(mix(color, sqColors[int(condA)], float(sq[int(condA)])), sqColors[int(!condA)], sq[int(!condA)]);\n\n    fragColor = vec4(color, 0.0);\n    \n}\n\n","name":"Image","description":"","type":"image"}]}