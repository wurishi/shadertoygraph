{"ver":"0.1","info":{"id":"lcfSWj","date":"1705706388","viewed":101,"name":"basic sdf sphere","username":"cizenadam","description":"I tried to implement raymarching and sdf. Here is the basic implementation.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// scene variables\nfloat width = 3.46;\nfloat height = 1.95;\nvec3 cameraPos = vec3(0., 0., -1.);\n// raymarching variables\nbool intersectionFound = false;\nfloat epsilon = 0.001;\nvec3 rayDirOfThisFragment;\n// shading variables\nfloat kd = 0.4; // diffuse coefficient\nvec3 lightPos = vec3(1., 3., -4.);\nvec3 lightIntensity = vec3(3., 2.5, 5.);\nvec3 backGroundColor = vec3(0.65, 0.3, 0.45);\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n};\n\nSphere sphere;\n\nfloat sdfOfSphere(vec3 centerOfSphere, vec3 curPoint, float radius)\n{\n    return distance(centerOfSphere, curPoint) - radius;  // The distance from that point to the surface of the sphere (i.e., nearest distance)\n}\n\nvec3 colorOfSphere(vec3 pos)\n{\n    vec3 N = normalize(pos-sphere.center);\n    vec3 L = normalize(lightPos - pos);\n    \n    return max(dot(N, L), 0.0) * kd * lightIntensity;\n}\n\nvec3 marchRays()\n{\n    float marchStep = 0.01;\n    \n    vec3 curPoint = vec3(0.,0.,0.);\n    for (int i=0; i<150; i++)\n    {\n        curPoint += rayDirOfThisFragment * marchStep;\n        float distanceToSphere = sdfOfSphere(sphere.center, curPoint, sphere.radius);\n        if (distanceToSphere < epsilon)\n        {\n            intersectionFound = true;\n            return colorOfSphere(curPoint);\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize fragCoord in uv (-0.5,0.5)\n    vec2 uv = (fragCoord.xy / iResolution.xy) - 0.5;\n    vec2 mousePos = (iMouse.xy / iResolution.xy) - 0.5;\n    \n    lightPos.x *= cos(iTime)*2.;  // light moves with time\n    lightPos.y *= sin(iTime)*0.5;\n\n    sphere.center = vec3(mousePos.x, mousePos.y, 2.);\n    sphere.radius = 1.;\n        \n    rayDirOfThisFragment = vec3(uv.x * width, uv.y * height, 0.) - cameraPos;\n        \n    vec3 color = marchRays();\n    \n    if (!intersectionFound)\n        color = backGroundColor;\n    float gamma = 2.2;\n    color = pow(color, vec3(1.0/gamma));\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}