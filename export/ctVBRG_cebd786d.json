{"ver":"0.1","info":{"id":"ctVBRG","date":"1702223831","viewed":118,"name":"Hairs AA","username":"spalmer","description":"Improved antialiasing on an old unlisted toy.\nIt seems the official name is \"domain repetition\"","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["domainrepetition","grass","antialias","hair","lod","fur","tiling","kerning","cilia"],"hasliked":0,"parentid":"WtVGWR","parentname":"Hair Plane"},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fork of ollj / TomKH toy (see parent)\n\nconst int ray_steps = 256;\nconst float marchtune = .35, // my SDF isn't that great; TODO use sdRoundCone or whatever\n  cam_dist = 15.,\n  cam_rise = 30.,\n  floor_plane = 0.,\n  tSpace = 1., // tiling\n  hairLen = 2.,\n  cam_alt = floor_plane + hairLen + 4., // doesn't seem to work correctly, idk yet\n  tFar = 400.,\n  fog_start = 10.,\n  fog_density = .001,\n  tau = acos(-1.) * 2.;\n\n// FIXME need better hair SDF\nfloat dCyl(vec3 p, float r, float h)\n{\n\tr = max(.0, length(p.xz) - r);\n\th = max(.0, abs(p.y) - h);\n\treturn length(vec2(r, h));\n}\n\nfloat wind(vec2 p) \n{\n    return 3. * sin(p.x * .09 + iTime * .1) * sin(p.y * .07 + iTime * .12);\n}\n\n// evaluate tile content\nvoid gt(vec3 p, vec3 q, vec2 d, inout float a)\n{\n\tq.xz += d; \n\tp.xz -= (d - .5) * tSpace; \n\tfloat t = iTime * .00025,\n     s, st = texture(iChannel0, q.xz / vec2(iChannelResolution[0])).r;\n    //s = sin(q.x + t) * sin(q.z + t * .33); // random\n    //s = s * .5 + .5;\n    //s = mix(s, st, .9);\n    s = st;\n    //s = pow(s, 1.);\n    //s = mix(s, 1., .0);\n    s *= hairLen;\n    float f = clamp(1.-.5*p.y/s, 0., 1.); // \n    p.xz += vec2(cos(q.x * 13.9 + 59.1) * cos(q.z * 13.7 + 72.1)) * .45; // de-align from grid\n    p.y -= s; // align with ground at 0.\n    float u1 = .2 * s, u0 = .05;\n\tfloat u = u1 * f; // HACK shrink with height - surely a simpler cone would be better TODO\n    a = min(a, dCyl(p, u, s) - u0);\n}\n\n// HACK for combing\nfloat topShear = 0.;\n\nfloat gd(vec3 p)\n{\n    // shear the entire cells, not just the hairs in the cells (which would cause problems).  careful w normal!\n    float f = clamp(1.-.5*p.y/hairLen, 0., 1.);\n    //f = f*f; // nonlinear (curling upward)\n    f = 1.-(1.-f)*(1.-f); // nonlinear (curling downward)\n    //f = sqrt(f); // nonlinear (horizontal tips though)\n    p.x += (1.-f) * wind(p.xz); // bend with height as if there is wind\n\tp.z += (1.-f) * hairLen * topShear; // lay flat - *before* tiling\n\tvec3 c = vec3(floor(p.xz / tSpace), .0).xzy; // tile address\n    p.xz = (fract(p.xz / tSpace) - .5) * tSpace; // local coord\n\tfloat r = 1e9; //dist2frame(p, 4.25);\n\tgt(p, c, vec2(0   ), r);\n\tgt(p, c, vec2(1, 0), r);\n\tgt(p, c, vec2(0, 1), r);\n\tgt(p, c, vec2(1   ), r);\n\tr = min(r, abs(p.y - floor_plane));\n\treturn r;\n}\n\nvec3 get_normal(vec3 p, float e) // of gd by forward differential\n{\n\tvec2 x = vec2(e, 0);\n\treturn normalize(vec3(\n\t\t  gd(p + x.xyy)\n\t\t, gd(p + x.yxy)\n\t\t, gd(p + x.yyx))\n        - gd(p));\n}\n\n// http://shadertoy.com/view/MsfXDS although only using 1 transparent layer here\n// iq did pretty much the same thing here http://shadertoy.com/view/llXGR4, still multiple fragments,\n// probably unwise to put the lighting in the main raymarch loop\n// there was a closer example to this somewhere, only kept most front-overlapping fragment\n// checked whenever raymarch begins to recede away from the surface\nstruct NearMiss\n{\n    float t, d, a;\n};\n\n// was standard ray marcher of gd - returns hit distance\n// modified to return best near-miss too\nfloat trace(vec3 u, vec3 t, float e, out NearMiss miss)\n{\n    miss = NearMiss(tFar, tFar, 0.);\n\tfloat l = 0., d, od = tFar;\n\tvec3 p = u;\n\tfor (int k = 0; k < ray_steps && l < tFar; ++k) {\n\t\td = gd(p);\n\t\tif (d < e * l) break;\n        // can only have more coverage if prior coverage was < 50%, otherwise don't bother checking, we already found the best near-miss\n        if (miss.a < .5 && d > od && od < 2. * e * l) {\n            // moving away now, check if more coverage than prior best fragment\n            float c = 1. - (od - e * l) / e / l;\n            if (c * (1. - miss.a) > miss.a)\n                miss = NearMiss(l - .9 * od * marchtune, od, c);\n        }\n        od = d;\n\t\tl += d * marchtune;\n\t\tp = u + t*l;\n\t}\n    return l;\n}\n\n// I still didn't fix the names\nvec3 lighting(vec3 u, vec3 t, vec3 v, float e, float l)\n{\n    vec3 p = u + t * l\n        , n = get_normal(p, e); \n    vec3 hd = vec3(.5*topShear, 1., 0.); // HACK should match the actual hair direction, I hope!\n    // http://forums.cgsociety.org/t/reflection-mapping-hair/873777/3\n    vec3 T = hd, V = -t;\n    float TdV = dot(T, V);\n    vec3 pn = normalize(V - T * sign(TdV) * sqrt(max(0., 1. - TdV * TdV)));\n\tfloat m = tau * .75 // light angle\n\t    , d = gd(p);\n    // s = light direction\n\tvec3 s = normalize(vec3(sin(m), .49, cos(m)));\n    vec3 albedo, cSpec;\n    if (p.y < floor_plane + e * 2.) {\n\t\tfloat chx = mod(floor(p.x) + floor(p.z), 2.);\n\t\talbedo = mix(vec3(.4, .3, .2), vec3(.3, .2, .1), chx); // checks\n        cSpec = vec3(.9,.9,.9);\n    } else {\n        float hc = sin(.15 * (p.x + p.z)) * .5 + .5;\n\t\talbedo = mix(vec3(.4, .3, .15), vec3(.6, .6, .4), hc); // haircolor\n        cSpec = vec3(.9,.4,.2);\n    }\n    // low LOD approximation shading for when \n    // hairs are too far away to be seen individually,\n    // would otherwise turn into aliasy mess\n    float lod = exp2(-.01*l); // high(1) to low(0) blend\n    vec3 napprox = hd; //vec3(0,1,0); // aniso cross with hair dir\n    napprox = cross(t, napprox);\n    // blend normal to fake perp dir based on distance\n    n = mix(napprox, n, lod);\n    p.y = mix(hairLen, p.y, lod);\n    vec3 H = normalize(mix(s, -t, .5)); // blinn\n    float power = 32.;\n    power *= lod;\n    float spec = pow(abs(dot(n, H)), power) * power * .04 // /8./pi\n      , shad = max(0., mix(dot(n, s), 1., .5 - .5*lod));\n    shad *= mix(.0, 1., clamp(p.y / hairLen,0.,1.));\n    shad = mix(.05, 1., shad); // ambient level\n    // blend shading with light and fog\n    vec3 cLit = albedo * shad;\n    cLit += cSpec * spec;\n    //cLit = vec3(n*.5+.5); // DEBUG NORMAL\n    vec3 cFog = vec3(.99,.56,.22) * mix(.05,.45, exp2(16.*(dot(t,s) - 1.))) + vec3(.4,.6,.7)\n        + .2*(1.-abs(t.y)); //vec3(0.); //\n    float fog = exp2(-max(.0, l - fog_start) * fog_density);\n    if (l >= tFar) fog = 0.;\n    return mix(cFog, cLit, fog);\n}\n\nvoid mainImage(out vec4 c, vec2 u)\n{\n\tvec2 R = iResolution.xy;\n\tfloat e = 1. / min(R.x, R.y);\n    u = (u.xy - R * 0.5) * e; // / R.x;\n    float t = iTime;\n\tfloat a = iMouse.x / R.x * 16.;\n    float h = iMouse.y / R.y;\n    if (length(iMouse.xyz) < 2.) { a = t * .1; h = sin(t * .3) * .5 + .5; }\n\tfloat ca = cos(a), sa = sin(a);\n    vec3 p = vec3(-cam_dist * sa, cam_alt + h*h * cam_rise, -cam_dist * ca);\n\tvec3 n = normalize(vec3(u - vec2(0,.25+.25*h), 1));\n    mat2 rm = mat2(ca, -sa, sa, ca);\n    vec3 d = vec3(rm * n.xz, n.y).xzy; // world\n    topShear = hairLen * .7 * sin(.2 * .25 * t);\n    c = vec4(0,0,0,1);\n    // completely disabled old SSAA to demo this technique\n    //int AA = int(R.x*R.y <= 1920.*1080.) + 1; //const int AA = 1;\n    //for (int i = 0; i < AA; ++i) {\n        //float j = tau * float(i) / float(AA); // circle?  spiral would be better\n    \t//vec3 D = n + vec3(cos(j),sin(j),0.) * .5 / iResolution;\n        vec3 v = d; //vec3(rm * D.xz, D.y).xzy; // world\n        NearMiss miss;\n        float l = trace(p, v, e, miss);\n        l = min(l, tFar);\n        c.rgb += lighting(p, v, n, e * l, l); // / float(AA);\n        if (miss.a > 0.) // optimize 1 fragment case\n            c.rgb = mix(c.rgb, lighting(p, v, n, e * miss.t, miss.t), miss.a); // blend edge antialias fg fragment\n    //}\n    c.rgb = pow(c.rgb, vec3(1./2.2)); // sRGB OETF hack\n}\n","name":"Image","description":"","type":"image"}]}