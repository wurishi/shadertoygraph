{"ver":"0.1","info":{"id":"stGSz3","date":"1641319477","viewed":212,"name":"Rolling ball game","username":"kaki","description":"Use arrow keys or the mouse to move the ball.\nPlease enjoy!","likes":14,"published":1,"flags":48,"usePreview":0,"tags":["game","ball","rolling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3  light_dir = normalize( vec3( -0.5, -1.0, 0.5 ) );\n    vec3  col      = vec3( 0.2 );\n    vec3  normal   = vec3( 0.0, 1.0, 0.0 );\n    vec3  ball_pos = texelFetch( iChannel0, ivec2( 0, 0 ), 0 ).xyz;\n    vec3  mouse    = texelFetch( iChannel0, ivec2( 2, 0 ), 0 ).xyz;\n    vec2  time     = texelFetch( iChannel0, ivec2( 3, 0 ), 0 ).xy;\n    vec3  ray_pos  = vec3( 0.0, 10.0, 0.0 );\n    vec3  ray_dir  = normalize( vec3( uv.x, -1.0, uv.y ) );\n    float ray_off  = 8.0 / abs( ray_dir.y );\n    int   N = 25;\n    float d = ray_off;\n    col = texture( iChannel2, ray_dir.xyz ).xyz * 0.5;\n    for( int i=0; i<N; i++ )\n    {\n        ray_pos += ray_dir * d;\n        vec3 p = rotate( ray_pos, mouse.x * 0.08, vec3( 0.0, 0.0, 1.0 ) );\n        p = rotate( p, mouse.y * -0.08, vec3( 1.0, 0.0, 0.0 ) );\n        float d2 = sdBall( p - ball_pos, ball_rad, normal );\n        if( d2 < 0.001 )\n        {\n            col = mix(\n                ( dot( -normal, light_dir ) * 2.0 + 1.0 ) * vec3( 1.0, 0.3, 0.1 ),\n                texture( iChannel2, normal.xyz ).xyz,\n                0.05\n            );\n            break;\n        }\n        vec3 acc = vec3( 0.0 );\n        vec3 col2;\n        float d3 = intersectBoxes( float( iTime ), p, 0.0, normal, col2, acc );\n        if( d3 <= 0.01 )\n        {\n            col = col2 * ( dot( -normal, light_dir ) * 0.5 + 1.0 );\n            break;\n        }\n        d = min( d2, d3 );\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    vec4 TimeColor = vec4( 0.0 ); DrawTime( TimeColor, uv, time.x );\n    fragColor += TimeColor * mix( vec4( 1.0 ), vec4( 0.5, 1.0, 0.0, 1.0 ), time.y );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 index = ivec2( floor( fragCoord ) );\n    vec3 init_pos = vec3( -13.0, 0.2, -7.0 );\n    vec3 init_acc = vec3( 0.0, 0.0, 0.0 );\n    vec3 pos = init_pos;\n    vec3 acc = init_acc;\n    vec2 time = vec2( 0.0, 0.0 );\n    \n    vec2 mouse = texelFetch( iChannel0, ivec2( 2, 0 ), 0 ).xy;\n    bool is_move = false;\n    if( iMouse.z >= .5 )\n\t{\n        mouse = iMouse.xy / iResolution.xy - 0.5;\n        mouse.x *= iResolution.x/iResolution.y; // fix aspect ratio\n        mouse = clamp( mouse, vec2( -0.5 ), vec2( 0.5 ) );\n        is_move = true;\n    }\n    if( texelFetch( iChannel1, ivec2(KEY_LEFT,0),0 ).x > 0.0 )\n    {\n        mouse.x = -0.25;\n        is_move = true;\n    }\n    else if( texelFetch( iChannel1, ivec2(KEY_RIGHT,0),0 ).x > 0.0 )\n    {\n        mouse.x = 0.25;\n        is_move = true;\n    }\n    if( texelFetch( iChannel1, ivec2(KEY_UP,0),0 ).x > 0.0 )\n    {\n        mouse.y = 0.25;\n        is_move = true;\n    }\n    else if( texelFetch( iChannel1, ivec2(KEY_DOWN,0),0 ).x > 0.0 )\n    {\n        mouse.y = -0.25;\n        is_move = true;\n    }\n    if( !is_move )\n    {\n        mouse *= 0.95;\n    }\n    \n    fragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n    if( iFrame == 0 )\n    {\n        // Ball position\n        if( index == ivec2( 0, 0 ) )\n        {\n            fragColor.xyz = pos;\n        }\n        // Ball acceleration\n        else if( index == ivec2( 1, 0 ) )\n        {\n            fragColor.xyz = acc;\n        }\n        // Mouse position\n        else if( index == ivec2( 2, 0 ) )\n        {\n            fragColor.xy = mouse;\n        }\n    }\n    else\n    {\n        pos  = texelFetch( iChannel0, ivec2( 0, 0 ), 0 ).xyz;\n        acc  = texelFetch( iChannel0, ivec2( 1, 0 ), 0 ).xyz;\n        time = texelFetch( iChannel0, ivec2( 3, 0 ), 0 ).xy;\n        acc.y -= 0.04;\n        acc.xz += mouse.xy * 0.02;\n        if( time.y != 1.0 ) { time.x += iTimeDelta; }\n        pos += acc;\n        vec3 normal = vec3( 0.0, 1.0, 0.0 );\n        vec3 col    = vec3( 0.0 );\n        float d = intersectBoxes( float( iTime ), pos, ball_rad, normal, col, acc );\n        // fall down\n        if( pos.y < -50.0 )\n        {\n            pos  = init_pos;\n            acc  = init_acc;\n            time = vec2( 0.0 );\n        }\n        // Game clear\n        else if( pos.x > 5.0 && pos.y > -0.3 && pos.z > 3.0 )\n        {\n            time.y = 1.0;\n        }\n        if( d < ball_rad )\n        {\n            acc.xz *= 0.95;\n        }\n        \n        // Ball position\n        if( index == ivec2( 0, 0 ) )\n        {\n            fragColor.xyz = pos;\n        }\n        // Ball acceleration\n        else if( index == ivec2( 1, 0 ) )\n        {\n            fragColor.xyz = acc;\n        }\n        // Mouse position\n        else if( index == ivec2( 2, 0 ) )\n        {\n            fragColor.xy = mouse;\n        }\n        // Clear time\n        else if( index == ivec2( 3, 0 ) )\n        {\n            fragColor.xy = time;\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float ball_rad = 0.75;\n\nvec3 rotate( vec3 p, float angle, vec3 axis )\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nfloat sdBall( in vec3 p, in float radius, out vec3 normal )\n{\n    normal = normalize( p );\n    return length( p ) - radius;\n}\n\nfloat sdBox( in vec3 p, in vec3 b, out vec3 normal )\n{\n    vec3 d = abs(p) - b;\n    if( d.x > d.y && d.x > d.z )\n    {\n        normal = vec3( 1.0, 0.0, 0.0 ) * sign( p.x );\n    }\n    else if( d.y > d.x && d.y > d.z )\n    {\n        normal = vec3( 0.0, 1.0, 0.0 ) * sign( p.y );\n    }\n    else\n    {\n        normal = vec3( 0.0, 0.0, 1.0 ) * sign( p.z );\n    }\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nvoid apply( inout vec3 p, inout vec3 acc, in vec3 normal, in float d )\n{\n    // Collision response\n    p += normal * ( ball_rad - d );\n    // Friction\n    acc = mix( acc, vec3( 0.0 ), abs( normal ) );\n}\n\nvoid apply_r( inout vec3 p, inout vec3 acc, in vec3 normal, in float d, in float r )\n{\n    // Collision response\n    p += rotate( normal, -r, vec3( 0.0, 1.0, 0.0 ) ) * ( ball_rad - d );\n    // Friction\n    acc = rotate( mix(\n        rotate( acc, r, vec3( 0.0, 1.0, 0.0 ) ),\n        vec3( 0.0 ),\n        abs( normal )\n    ), -r, vec3( 0.0, 1.0, 0.0 ) );\n}\n\nvoid intersect(\n    in float r,\n    in vec3 p,\n    in vec3 s,\n    in vec3 c,\n    inout vec3 result_pos,\n    inout vec3 normal,\n    inout vec3 acc,\n    inout vec3 color,\n    inout float mind\n){\n    vec3 n;\n    float d = sdBox( p, s, n );\n    if( r > 0.0 && d < r )\n    {\n        apply( result_pos, acc, n, d );\n    }\n    if( d < mind )\n    {\n        color  = c;\n        mind   = d;\n        normal = n;\n    }\n}\n\nfloat intersectBoxes(\n    in float t, inout vec3 p, in float r,\n    inout vec3 normal,\n    inout vec3 color,\n    inout vec3 acc\n){\n    vec3 wall_color  = vec3( 0.33, 0.33, 0.52 );\n    vec3 floor_color = vec3( 0.47, 0.47, 0.52 );\n    vec3 result_pos = p;\n    float mind = 1000000.;\n    // Wall (Outside)\n    intersect( r,\n        p - vec3( -17.0, 0.0, 0.0 ),\n        vec3( 0.5, 0.375, 10.5 ),\n        wall_color, result_pos, normal, acc, color, mind\n    );\n    intersect( r,\n        p - vec3( 17.0, 0.0, 0.0 ),\n        vec3( 0.5, 0.375, 10.5 ),\n        wall_color, result_pos, normal, acc, color, mind\n    );\n    intersect( r,\n        p - vec3( 0.0, 0.0, -10.0 ),\n        vec3( 17.0, 0.375, 0.5 ),\n        wall_color, result_pos, normal, acc, color, mind\n    );\n    intersect( r,\n        p - vec3( 0.0, 0.0, 10.0 ),\n        vec3( 17.0, 0.375, 0.5 ),\n        wall_color, result_pos, normal, acc, color, mind\n    );\n    // Wall (Inside)    \n    intersect( r,\n        p - vec3( -10., -0.3, -5.0 ),\n        vec3( 0.4, 0.35, 7.0 ),\n        wall_color, result_pos, normal, acc, color, mind\n    );\n    intersect( r,\n        p - vec3( -10., -0.3, 8.0 ),\n        vec3( 0.4, 0.35, 2.0 ),\n        wall_color, result_pos, normal, acc, color, mind\n    );\n    intersect( r,\n        p - vec3( -3.7, -0.3, 1.9 ),\n        vec3( 0.4, 0.35, 4.3 ),\n        wall_color, result_pos, normal, acc, color, mind\n    );\n    intersect( r,\n        p - vec3( 0.6, -0.3, 3.8 ),\n        vec3( 0.4, 0.35, 2.2 ),\n        wall_color, result_pos, normal, acc, color, mind\n    );\n    intersect( r,\n        p - vec3( 0.6, -0.3, -4.2 ),\n        vec3( 0.4, 0.35, 2.2 ),\n        wall_color, result_pos, normal, acc, color, mind\n    );\n    intersect( r,\n        p - vec3( -6.7, -0.3, -2.0 ),\n        vec3( 3.2, 0.35, 0.4 ),\n        wall_color, result_pos, normal, acc, color, mind\n    );\n    intersect( r,\n        p - vec3( -2.5, -0.3, -6.0 ),\n        vec3( 3.5, 0.35, 0.4 ),\n        wall_color, result_pos, normal, acc, color, mind\n    );\n    intersect( r,\n        p - vec3( 2.5, -0.3, -2.0 ),\n        vec3( 2.3, 0.35, 0.4 ),\n        wall_color, result_pos, normal, acc, color, mind\n    );\n    intersect( r,\n        p - vec3( 5.0, -0.3, 3.5 ),\n        vec3( 0.4, 0.35, 5.8 ),\n        wall_color, result_pos, normal, acc, color, mind\n    );\n    intersect( r,\n        p - vec3( 5.0, -0.3, -7.5 ),\n        vec3( 0.4, 0.35, 2.2 ),\n        wall_color, result_pos, normal, acc, color, mind\n    );\n    intersect( r,\n        p - vec3( 7.4, -0.3, 2.0 ),\n        vec3( 2.2, 0.35, 0.4 ),\n        wall_color, result_pos, normal, acc, color, mind\n    );\n    intersect( r,\n        p - vec3( 15.0, -0.3, 2.0 ),\n        vec3( 2.2, 0.35, 0.4 ),\n        wall_color, result_pos, normal, acc, color, mind\n    );\n    // Floor\n    if( r > 0.0 ) { p = result_pos; }\n    intersect( r,\n        p - vec3( -14.0, -0.5, -2.0 ),\n        vec3( 3.6, 0.2, 8.0 ),\n        floor_color, result_pos, normal, acc, color, mind\n    );\n    intersect( r,\n        p - vec3( -7.0, -0.5, 6.5 ),\n        vec3( 3.6, 0.2, 4.5 ),\n        floor_color, result_pos, normal, acc, color, mind\n    );\n    intersect( r,\n        p - vec3( 0.8 - 3., -0.5, -6.0 ),\n        vec3( 7.4, 0.2, 4.4 ),\n        floor_color, result_pos, normal, acc, color, mind\n    );\n    intersect( r,\n        p - vec3( 12.0, -0.5, 6.5 ),\n        vec3( 6.6, 0.2, 4.5 ),\n        floor_color, result_pos, normal, acc, color, mind\n    );\n    // Moving Floor\n    float t2 = fract( t / 16.0 ) * 6.0;\n    vec3 pos2;\n    if( t2 < 1.0 )\n    {\n        pos2 = vec3( mix( -1.5, 2.8, t2 ), -0.5, 8.0 );\n    }\n    else if( t2 < 3.0 )\n    {\n        pos2 = vec3( 2.8, -0.5, mix( 8.0, 0.0, ( t2 - 1.0 ) * 0.5 ) );\n    }\n    else if( t2 < 4.0 )\n    {\n        pos2 = vec3( mix( 2.8, -1.5, t2 - 3.0 ), -0.5, 0.0 );\n    }\n    else\n    {\n        pos2 = vec3( -1.5, -0.5, mix( 0.0, 8.0, ( t2 - 4.0 ) * 0.5 ) );\n    }\n    intersect( r,\n        p - pos2,\n        vec3( 1.5, 0.2, 1.5 ),\n        floor_color, result_pos, normal, acc, color, mind\n    );\n    // Rotation Floor\n    float t3 = t * 0.5;\n    float d = 100000.0;\n    vec3 n;\n    if( ( d = sdBox(\n        rotate( p - vec3( 11.1, -0.3, -3.8 ), t3, vec3( 0.0, 1.0, 0.0 ) ),\n        vec3( 1.5, 0.35, 1.5 ),\n        n\n    ) ) < r )\n    {\n        if( r > 0.0 && d < r ) { apply_r( result_pos, acc, n, d, t3 ); }\n    }\n    if( d < mind )\n    {\n        color = wall_color;\n        mind = d;\n        normal = n;\n    }\n    if( ( d = sdBox(\n        rotate( p - vec3( 11.1, -0.5, -3.8 ), t3, vec3( 0.0, 1.0, 0.0 ) ),\n        vec3( 5.5, 0.2, 1.5 ),\n        n\n    ) ) < r )\n    {\n        if( r > 0.0 && d < r ) { apply_r( result_pos, acc, n, d, t3 ); }\n    }\n    if( d < mind )\n    {\n        color = floor_color;\n        mind = d;\n        normal = n;\n    }\n    \n    p = result_pos;\n    return mind;\n}\n\n// Time-o-matic 2 - 327 chars\n// https://www.shadertoy.com/view/MlXXzH\nint D(vec2 p, float n) {\n    int i=int(p.y), b=int(exp2(floor(30.-p.x-n*3.)));\n    i = ( p.x<0.||p.x>3.? 0:\n    i==5? 972980223: i==4? 690407533: i==3? 704642687: i==2? 696556137:i==1? 972881535: 0 )/b;\n \treturn i-i/2*2;\n}\n\n void DrawTime( out vec4 o, vec2 i, in float time ) {\n    i *= 30.0;\n    i += vec2( -15.0, -20.0 );\n    for (float n=3.; n>-4.; n--) { \n        if ((i.x-=4.)<3.) { o = vec4(D(i,floor(mod(time/pow(10.,n),10.)))); break; } \n    }\n}","name":"Common","description":"","type":"common"}]}