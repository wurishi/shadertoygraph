{"ver":"0.1","info":{"id":"3s23zz","date":"1548016212","viewed":236,"name":"More Accurate Ellipse Normal","username":"scratch13764","description":"An easy and fairly accurate way to calculate the surface normal for an ellipse without needing a perfect SDF. Can be used with ellipsoids using \"revolution\" from: https://iquilezles.org/articles/distfunctions/distfunctions.htm\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["normal","ellipsoid","ellipse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* IGNORE THE STEP BY STEP THINGY BELOW IT'S WRONG GIVE ME SOME TIME TO FIX IT\nHow to calculate the noral of an ellipse using my method:\n   1.) Start by finding the point on the ellipse where you want to calculate the normal\n   2.) Then,\"stretch\" the scene to make the ellipse into an oval:\n         - StretchedSceneHeight *= EllipseHeight/EllipseWidth;\n         - Similar to how one might fix an aspect ratio\n   3.) Now that you have your point on a circle with rescaled coordinates, find the \n       angle from the center of the circle to the point on the surface.\n         - Let vec2 a be the point on the surface, and vec2 o is the center of the circle\n         - the formula to find the angle is atan(( a.x - o.x ) / ( a.y - o.y ))\n         - See: https://www.youtube.com/watch?v=TTom8n3FFCw by Brian McLogan\n   4.) Now that you have this angle, you can forget about the scaled coordinates from earlier\n       and go back to the nonscaled original ellipse. Let's have the angle from earlier stored\n       in a float, let's call it \"t\".\n   5.) The next step is to take the width and height of the ellipse and add a certain number,\n       it doesn't matter what number just as long as it's above 0. In this case let's call it \"i\"\n       Now take the original angle \"t\" and find the second point. We'll call this point vec2 b. \n       The way to find this point is basically the opposite of what we did to find angle a. \n       First, set b to vec2(sin(t), cos(t)) next multiply b by the width and height of the \n       larger ellipse to get: \n       vec2 b = vec2(sin(t) * (w + i), cos(t) * (h + i));\n   6.) The final step is simply to get the normal of the line between a and b in a new vector,\n       let's call it \"n\":\n       vec2 n = normalize(a - b);\n\nWhy this is a useful method:\n   1.) It is very simple and easy to calculate, meaning it is very fast.\n   2.) It's much more accurate than simply using a normal from a stretched sphere\n   3.) It can be used along with revoluton from 2D to 3D to calculate ellipsoid normals\n   4.) In situations like raytracing, where you don't have SDF's to get normals,\n       this is a great way to get a normal without needing an SDF of any sort.\n\n\nNote that the red line is the standard, highly inaccurate normal and the black line\nis my improved normal. The code in this shader is not a great implementation of my\nmethod because it had to be modified for the visual comparison. The math is essentially\nthe same I just skipped the last step of actually calculating the normal.\n*/\n#define H .8\n#define W .5\n\nfloat Ellipse (vec2 p, float w, float h)\n{\n    if (length(vec2(p.x/w,p.y/h)) <= .5)\n        return 1.;\n    else return 0.;\n}\n\nvec2 EllipsePoint (float t, float w, float h) //Point on an ellipse at a certain angle, stretched circle\n{\n    return vec2(sin(t)*w / 2., cos(t)*h / 2.);\n}\n\nfloat sdLine( vec2 p, vec2 a, vec2 b ) //Line segment SDF made by Inigo Quilez (Thanks!)\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 u, in vec2 o )\n{\n    vec2 p = (o - .5*iResolution.xy)/iResolution.y;\n    vec4 c = vec4(.5);\n    \n    vec2 pw = 2. / iResolution.xy;\n    \n    \n    //Ellipse Normal Calculations and drawing\n    float t = iTime*.5;\n    vec2 a = EllipsePoint (t, W, H);\n    vec2 b = EllipsePoint (t, W + .2, H + .2); //My original incorrect normal\n    vec2 d = a + normalize(a * 2.)*.1;\n    vec2 e = a + normalize(EllipsePoint(t,H,W))*.1; //Correct normal - thanks IQ!\n    if ( sdLine(p, a, d) <= .005) c = mix(c, vec4(1,0,0,0), .5);//bad stretched circle normal\n    if ( sdLine(p, a, e) <= .005) c = mix(c, vec4(0), .5); //Much better normal made by expanding the ellipse evenly\n    \n    c = mix (c, vec4(.8), Ellipse (p, W + pw.x, H + pw.y)); //Antialaising...?\n    c = mix (c, vec4(1), Ellipse (p, W, H));\n    \n    \n    \n    u = c;\n}","name":"Image","description":"","type":"image"}]}