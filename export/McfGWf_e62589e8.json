{"ver":"0.1","info":{"id":"McfGWf","date":"1703612155","viewed":25,"name":"star floating","username":"nayk","description":"star, float, space,cosmos, rotate","likes":3,"published":1,"flags":1,"usePreview":0,"tags":["rotate","star","space","cosmos","float"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*originals  https://www.shadertoy.com/view/lslyRn  https://www.shadertoy.com/results?query=cheap+star https://www.shadertoy.com/view/4clGWB*/\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.00\n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\nvec3 firePalette(float i){\n\n    float T = 1400. + 1300.*i; // Temperature range (in Kelvin).\n    vec3 L = vec3(7.4, 5.6, 4.4); // Red, green, blue wavelengths (in hundreds of nanometers).\n    L = pow(L,vec3(5)) * (exp(1.43876719683e5/(T*L)) - 1.);\n    return 1. - exp(-5e8/L); // Exposure level. Set to \"50.\" For \"70,\" change the \"5\" to a \"7,\" etc.\n}\n\n\nvec3 hash33(vec3 p){\n   \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n);\n}\n\n\nfloat voronoi(vec3 p){\n\nvec3 b, r, g = floor(p);\np = fract(p);\nfloat d = 1.;\n   \nfor(int j = -1; j <= 1; j++) {\n   for(int i = -1; i <= 1; i++) {\n   \n   b = vec3(i, j, -1);\n   r = b - p + hash33(g+b);\n   d = min(d, dot(r,r));\n   \n   b.z = 0.0;\n   r = b - p + hash33(g+b);\n   d = min(d, dot(r,r));\n   \n   b.z = 1.;\n   r = b - p + hash33(g+b);\n   d = min(d, dot(r,r));\n   \n   }\n}\n\nreturn d; // Range: [0, 1]\n}\n\n\nfloat noiseLayers(in vec3 p) {\n\n \n    vec3 t = vec3(0., 0., p.z + iTime*1.5);\n\n    const int iter = 5; // Just five layers is enough.\n    float tot = 0., sum = 0., amp = 1.; // Total, sum, amplitude.\n\n    for (int i = 0; i < iter; i++) {\n        tot += voronoi(p + t) * amp; // Add the layer to the total.\n        p *= 2.; // Position multiplied by two.\n        t *= 1.5; // Time multiplied by less than two.\n        sum += amp; // Sum of amplitudes.\n        amp *= .5; // Decrease successive layer amplitude, as normal.\n    }\n   \n    return tot/sum; // Range: [0, 1].\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n//get coords and direction\nvec3 dir=rd;\nvec3 from=ro;\n\n//volumetric rendering\nfloat s=0.1,fade=1.;\nvec3 v=vec3(0.);\nfor (int r=0; r<volsteps; r++) {\nvec3 p=from+s*dir*.5;\np = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\nfloat pa,a=pa=0.;\nfor (int i=0; i<iterations; i++) {\np=abs(p)/dot(p,p)-formuparam; // the magic formula\na+=abs(length(p)-pa); // absolute sum of average change\npa=length(p);\n}\nfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\na*=a*a; // add contrast\nif (r>6) fade*=1.1-dm; // dark matter, don't render near\n//v+=vec3(dm,dm*.5,0.);\nv+=fade;\nv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\nfade*=distfading; // distance fading\ns+=stepsize;\n}\nv=mix(vec3(length(v)),v,saturation); //color adjust\nfragColor = vec4(v*.03,1.);\n}\nfloat cheap_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//get coords and direction\nvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\nvec3 dir=vec3(uv*zoom,1.);\nfloat time=iTime*speed+.25;\n\n//mouse rotation\n\n\n\nuv += vec2(sin(iTime*.5)*.25, cos(iTime*.5)*.125);\n\n   \nvec3 rd = normalize(vec3(uv.x, uv.y, 3.1415926535898/8.));\n\n \nfloat cs = cos(iTime*.25), si = sin(iTime*.25);\n   \nrd.xy = rd.xy*mat2(cs, -si, si, cs);\n\n\nfloat c = noiseLayers(rd*2.);\n\n// Optional: Adding a bit of random noise for a subtle dust effect.\nc = max(c + dot(hash33(rd)*2. - 1., vec3(.015)), 0.);\n\n    uv *= 2.0 * ( cos(iTime * 2.0) -2.5);\n   \n    // anim between 0.9 - 1.1\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;    \n\n   \n    c *= sqrt(c)*1.5; // Contrast.\n    vec3 col = firePalette(c); // Palettization.\n\n    col = mix(col, col.zyx*1.15 + c*.185, min(pow(dot(rd.xy, rd.xy)*1.2, 1.5), 1.)); // Color dispersion.\n    col = pow(col, vec3(.25)); // Tweaking the contrast a little.\n   \n   \nfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n\nvec3 from=vec3(1.,.5,0.5)+fragColor.xyz;\nfrom+=vec3(time*2.,time,-2.);\nmainVR(fragColor, fragCoord, from, dir);\n    fragColor*=vec4(sqrt(clamp(col, 0., 1.)), 1);\n    fragColor+= vec4(cheap_star(uv,anim) * vec3(0.5,0.5,0.55)*0.1, 1.0);\n}","name":"Image","description":"","type":"image"}]}