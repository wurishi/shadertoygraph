{"ver":"0.1","info":{"id":"4dByWd","date":"1494537394","viewed":208,"name":"Game of Life : Torus","username":"JCDjcd","description":"The famous (yet another) Conway's game of life... but on a torus!\nClick on 'Enter' key to re-initialize the game (especially if you switch to fullscreen).\nSee also my other shadertoys: /view/4sByDt for game of life on a plan and /view/XsBcWd for torus.","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["game","torus","life","conway"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//--------------------------------------------------------------------------\n#define NX \t\t\t\tiResolution.x\n#define NY \t\t\t\tiResolution.y\n#define TWOPI \t\t\t(2.0*3.1415926535)\n#define ROTATION(alpha) mat2(cos(alpha),-sin(alpha),sin(alpha),cos(alpha))\n#define COLORIZATION(h)\tclamp(abs(fract(h+vec4(3.0,2.0,1.0,0.0)/3.0)*6.0-3.0)-1.0,0.0,1.0)\n#define torus_R \t\t0.7\n#define torus_r \t\t0.4\n\n//--------------------------------------------------------------------------\n// complex multiplication (ax + i*ay) * (bx + i*by)\nvec2 complex_mul(vec2 a,vec2 b)\n{\n    return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);\n} // complex_mul()\n\n//--------------------------------------------------------------------------\n// square root\nvec2 complex_sqrt(vec2 z)\n{\n    float r2 \t= z.x*z.x + z.y*z.y;\n    float theta\t= atan(z.y,z.x);\n    return sqrt(sqrt(r2))*vec2(cos(0.5*theta),sin(0.5*theta));\n} // complex_sqrt()\n\n//--------------------------------------------------------------------------\n// cubic root\nvec2 complex_cbrt(vec2 z)\n{\n    float r2 \t= z.x*z.x + z.y*z.y;\n    float theta\t= atan(z.y,z.x);\n    return pow(r2,1.0/6.0)*vec2(cos(theta/3.0),sin(theta/3.0));\n} // complex_cbrt()\n\n//--------------------------------------------------------------------------\nvec2 complex_conj(vec2 z)\n{\n    return vec2(z.x,-z.y);\n} // complex_conj()\n\n//--------------------------------------------------------------------------\n// solve the equation A*u^3 + B*u^2 + C*u + D = 0\nvoid solve3(float A,float B,float C,float D,out vec2 u1,out vec2 u2,out vec2 u3)\n{\n    // First step consists on shifting u = v-B/(3*A)\n    // in order to write the equation v^3 + p*v + q = 0\n    // (no second term)\n    float p \t= (-B*B/(3.0*A)+C)/A;\n    float q \t= (2.0*B*B*B/(27.0*A*A)-B*C/(3.0*A)+D)/A;\n\n    float delta = q*q/4.0+p*p*p/27.0;\n    vec2 j  \t= vec2(cos(TWOPI/3.0),sin(TWOPI/3.0)); // j^3=1\n    vec2 j2 \t= complex_conj(j);\n    \n    if(delta < 0.0) // three real roots\n    {\n        vec2 x \t= complex_cbrt(vec2(-0.5*q,0.0)+complex_sqrt(vec2(delta,0.0)));\n\t\tu1 \t\t= vec2(2.0*(\t\t\t\tx).x\t,0.0);\n\t\tu2 \t\t= vec2(2.0*(complex_mul(j,\tx)).x\t,0.0);\n\t\tu3 \t\t= vec2(2.0*(complex_mul(j2,\tx)).x\t,0.0);\n    }\n    else if(delta > 0.0) // one real root and two (conjugated) complex roots\n    {\n        vec2 x \t= complex_cbrt(vec2(-0.5*q+sqrt(delta),0.0));\n        vec2 y  = -p/3.0*complex_conj(x)/dot(x,x);\n        u1 \t\t= \t\t\t\t\tx\t+\t\t\t\t\ty\t;\n        u2 \t\t= complex_mul(j,\tx)\t+\tcomplex_mul(j2,\ty)\t;\n        u3 \t\t= complex_mul(j2,\tx)\t+\tcomplex_mul(j,\ty)\t;\n    }\n    else // trivial cases\n    {\n        if(0.0 == p && 0.0 == q)\n        {\n            u1 \t= vec2(0.0,0.0);\n            u2 \t= vec2(0.0,0.0);\n            u3 \t= vec2(0.0,0.0);\n        }\n        else\n        {\n            u1 \t= vec2( 3.0*q/p,0.0);\n            u2 \t= vec2(-1.5*q/p,0.0);\n            u3 \t= vec2(-1.5*q/p,0.0);\n        }\n    }\n    \n    // From v to u:\n    u1.x -= B/(3.0*A);\n    u2.x -= B/(3.0*A);\n    u3.x -= B/(3.0*A);\n\n} // solve3()\n\n\n//--------------------------------------------------------------------------\n// solve the equation a*u^3 + b*u^2 + c*u + d = 0\nvoid solve4(float A,float B,float C,float D,float E,out vec2 t1,out vec2 t2,out vec2 t3,out vec2 t4)\n{\n    // We need to find the roots of the polynomial of degree 4.\n    // First step consists on shifting t = s - B/(4.0*A) such that\n    // s^4 + p*s^2 + q*s + r = 0 (no cubic terms)\n    float p = (-3.0*B*B/(8.0*A)+C)/A;\n    float q = (B*B*B/(8.0*A*A)-B*C/(2.0*A)+D)/A;\n    float r = (-3.0*B*B*B*B/(256.0*A*A*A)+B*B*C/(16.0*A*A)-B*D/(4.0*A)+E)/A;\n\n    // Now we must solve u^3 + 2*p*u^2 + (p^2-4*r)*u - q^2 = 0\n\tvec2 u1,u2,u3;\n    solve3(1.0,2.0*p,p*p-4.0*r,-q*q,u1,u2,u3);\n    \n    // Before finalizing, we need to compute the square root of u1, u2, and u3\n    // such that sqrt(u1)*sqrt(u2)*sqrt(u3) = -s\n    vec2 v1 = complex_sqrt(u1);\n    vec2 v2 = complex_sqrt(u2);\n    vec2 v3 = complex_sqrt(u3);\n    if(complex_mul(v1,complex_mul(v2,v3)).x*q > 0.0)\n    {\n        v3 = -v3; // take the other square root of u3\n    }\n    \n    // We finally got our four roots:\n    t1 = 0.5*( v1+v2+v3);\n    t2 = 0.5*( v1-v2-v3);\n    t3 = 0.5*(-v1+v2-v3);\n    t4 = 0.5*(-v1-v2+v3);\n    \n    // From s to t:\n    t1.x -= B/(4.0*A);\n    t2.x -= B/(4.0*A);\n    t3.x -= B/(4.0*A);\n    t4.x -= B/(4.0*A);\n\n} // solve4()\n\n\n//--------------------------------------------------------------------------\n// Ray is defined by M(t) = P + t.d\nvec4 compute(vec3 P,vec3 d)\n{\n    // Parametrization of the torus by phi and theta angles.\n    // x = (R+r*cos(theta))*cos(phi)\n    // y = (R+r*cos(theta))*sin(phi)\n    // z = r*sin(theta)\n    \n    // U*t^2 + V*t + W = 2*r*R*cos(theta)\n\tfloat U = dot(d,d);\n    float V = 2.0*dot(P,d);\n    float W = dot(P,P) - (torus_R*torus_R+torus_r*torus_r);\n    \n    // A*t^4 + B*t^3 + C*t^2 + D*t + E = 0\n    float A = U*U;\n    float B = 2.0*U*V;\n    float C = V*V + 2.0*U*W + 4.0*torus_R*torus_R*d.z*d.z;\n    float D = 2.0*V*W + 8.0*torus_R*torus_R*P.z*d.z;\n    float E = W*W + 4.0*torus_R*torus_R*(P.z*P.z-torus_r*torus_r);\n\n    vec2 t[4]; // complex roots\n    solve4(A,B,C,D,E,t[0],t[1],t[2],t[3]);\n\n    float sorted_t[4];\n    int   nb_intersection = 0;\n    for(int i=0;i<4;i++)\n    {\n        if(abs(t[i].y)<0.005) // if the root is real, we got an intersection\n        {\n            nb_intersection ++;\n            sorted_t[nb_intersection-1] = t[i].x;\n            for(int j=nb_intersection-2;j>=0;j--)\n            {\n                if(sorted_t[j] > sorted_t[j+1])\n                {\n                    float tmp \t\t= sorted_t[j];\n                    sorted_t[j] \t= sorted_t[j+1];\n                    sorted_t[j+1] \t= tmp;\n                }\n            } // for()\n        }\n    } // for()\n    \n    // colorization\n    vec4 color = vec4(0.4,0.4,0.4,1.0);\n    for(int i=0;i<nb_intersection;i++)\n    {\n        vec3 \tM \t\t= P+sorted_t[i]*d;\n        float \tphi \t= atan(M.y,M.x);\n        float   theta   = atan(M.z,sqrt(M.x*M.x+M.y*M.y)-torus_R);\n\n        // make sure phi and theta is between 0 and 2.pi\n        phi \t= mod(TWOPI+phi,TWOPI);\n        theta \t= mod(TWOPI+theta,TWOPI);\n        \n    \tvec4 c = texture(iChannel0,vec2(phi/TWOPI*NX/iResolution.x,theta/TWOPI*NY/iResolution.y));\t\t\n        color = c + 0.3*color;\n    } // for()\n    \n    \n    return vec4(color.rgb,1.0);\n} // compute()\n\n//--------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor,vec2 fragCoord)\n{\n    float m \t\t= min(iResolution.x,iResolution.y);\n\tvec2 uv \t\t= (fragCoord.xy / m - vec2(0.5,0.5))*2.5;\n    vec3 P \t\t\t= vec3(uv,-5.0);\n    vec3 d      \t= vec3(0.0,0.0,1.0);\n    \n    float alpha1\t= iTime*TWOPI/31.0;\n    float alpha2\t= iTime*TWOPI/43.0;\n    P.xy\t\t   *= ROTATION(alpha2);\n    P.zx\t\t   *= ROTATION(alpha1);\n    d.xy\t\t   *= ROTATION(alpha2);\n    d.zx \t\t   *= ROTATION(alpha1);\n\t\n\tfragColor \t\t= compute(P,d);\n            \n} // mainImage()\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//--------------------------------------------------------------------------\n#define NX \t\t\t\tiResolution.x\n#define NY \t\t\t\tiResolution.y\n#define COLORIZATION(h)\tclamp(abs(fract(h+vec4(3.0,2.0,1.0,0.0)/3.0)*6.0-3.0)-1.0,0.0,1.0)\n\n//--------------------------------------------------------------------------\nvec4 get(float x,float y)\n{\n    float normalized_x = mod(x,NX)/iChannelResolution[0].x;\n    float normalized_y = mod(y,NY)/iChannelResolution[0].y;\n    return texture(iChannel0,vec2(normalized_x,normalized_y));\n} // get()\n\n//--------------------------------------------------------------------------\n// return 0 if dead and 1 if alive\nint is_alive(vec4 c)\n{\n    return c.x + c.y + c.z > 0.0 ? 1 : 0;\n} // is_alive()\n\n//--------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{    \n    if(fragCoord.x >= 0.0 && fragCoord.x < NX && fragCoord.y >= 0.0 && fragCoord.y < NY)\n    {\n        if(0 == iFrame || texelFetch(iChannel1,ivec2(13 /* SPACE KEY */,0),0).x > 0.0)\n        {\n            // initialization\n            float density \t= 0.4; // density of the initial random cells\n            float r \t\t= fract(iTime+12345.6789*(0.2+0.4*sin(fragCoord.x)+0.4*cos(fragCoord.y*1.732)));\n            fragColor \t\t= r < density ? vec4(0.0,0.0,0.0,1.0) : vec4(1.0,1.0,1.0,1.0);\n        }\n        else\n        {\n            // neighborhood of current point M\n            // A B C\n            // D M E\n            // F G H\n            float x = fragCoord.x;\n            float y = fragCoord.y;\n            \n            vec4 A = get(x-1.0,y-1.0);\n            vec4 B = get(x+0.0,y-1.0);\n            vec4 C = get(x+1.0,y-1.0);\n\n            vec4 D = get(x-1.0,y+0.0);\n            vec4 M = get(x+0.0,y+0.0);\n            vec4 E = get(x+1.0,y+0.0);\n\n            vec4 F = get(x-1.0,y+1.0);\n            vec4 G = get(x+0.0,y+1.0);\n            vec4 H = get(x+1.0,y+1.0);\n\n            int nb_neighbors \t= is_alive(A)\n                \t\t\t\t+ is_alive(B)\n                \t\t\t\t+ is_alive(C)\n                \t\t\t\t+ is_alive(D)\n                \t\t\t\t+ is_alive(E)\n                \t\t\t\t+ is_alive(F)\n                \t\t\t\t+ is_alive(G)\n                \t\t\t\t+ is_alive(H)\n                \t\t\t\t;\n            int is_alive_M = is_alive(M);\n            if(3 == nb_neighbors || 1 == is_alive_M && 2 == nb_neighbors)\n                // we just have to be sure that COLORIZATION is never black\n            \tfragColor = 1 == is_alive_M ? M : COLORIZATION(iTime/10.0);\n            else\n                fragColor = vec4(0.0,0.0,0.0,1.0);\n        }\n    }\n} // mainImage()","name":"Buf A","description":"","type":"buffer"}]}