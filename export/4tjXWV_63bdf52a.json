{"ver":"0.1","info":{"id":"4tjXWV","date":"1446593391","viewed":2229,"name":"ubuntu logo","username":"MacSlow","description":"Just for fun I made the logo of ubuntu (Linux).","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","csg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"////////////////////////////////////////////////////////////////////////////////\n//\n// ubuntu-logo rendered with ray-marching\n//\n// Copyright 2015 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.14159265358979323846;\nconst vec4 laubergine = vec4 (float (0x77) / 255., float (0x21) / 255., float (0x6F) / 255., 1.);\nconst vec4 wgrey = vec4 (float (0xAE) / 255., float (0xA7) / 255., float (0x9F) / 255., 1.);\nconst vec4 uorange = vec4 (float (0xdd) / 255., float  (0x48) / 255., float  (0x14) / 255., 1.);\nconst int MAX_STEPS = 64;\nconst float epsilon = 0.0001;\n\nmat4 trans (vec3 t)\n{\n    mat4 mat = mat4 (vec4 (1., .0, .0, .0),\n                     vec4 (.0, 1., .0, .0),\n                     vec4 (.0, .0, 1., .0),\n                     vec4 (t.x, t.y, t.z, 1.));\n    return mat;\n}\n\nvec3 opTransf (vec3 p, mat4 m)\n{\n    return vec4 (m * vec4 (p, 1.)).xyz;\n}\n\nmat4 rotY (in float angle)\n{\n    float rad = radians (angle);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    mat4 mat = mat4 (vec4 (  c, 0.0,  -s, 0.0),\n                     vec4 (0.0, 1.0, 0.0, 0.0),\n                     vec4 (  s, 0.0,   c, 0.0),\n                     vec4 (0.0, 0.0, 0.0, 1.0));\n\n    return mat;\n}\n\nmat4 rotZ (in float angle)\n{\n    float rad = radians (angle);\n    float c = cos (rad);\n    float s = sin (rad);\n\n    mat4 mat = mat4 (vec4 (  c,   s, 0.0, 0.0),\n                     vec4 ( -s,   c, 0.0, 0.0),\n                     vec4 (0.0, 0.0, 1.0, 0.0),\n                     vec4 (0.0, 0.0, 0.0, 1.0));\n\n    return mat;\n}\n\nfloat opSubtract (float d1, float d2)\n{\n    return max (-d1, d2);\n}\n\nfloat box (vec3 p, vec3 b, float r)\n{\n    return length (max (abs (p) - b + vec3 (r), .0)) - r;\n}\n\nfloat cylinder (vec3 p, vec2 h)\n{\n  vec2 d = abs (vec2 (length (p.xy), p.z)) - h;\n  return min (max (d.x, d.y), .0) + length (max (d, .0));\n}\n\nfloat wavyfloor (vec3 p, vec4 n)\n{\n    return dot ((p).xyz, n.xyz) + n.w - .1 * sin (4. * p.x) * cos (4. * p.z);\n}\n\nfloat logo (vec3 np)\n{\n    float d1 = .0;\n    float d2 = .0;\n    const float angle = 120.;\n    const float offset = 60.;\n\n    vec3 p = opTransf (np, rotZ (90.));\n    const float a = 1.;          // outter circle\n    const float b = 164. / 284.; // cutout circle\n    const float c = 110. / 284.; // inner circle\n    const float d = 10.  / 284.; // beam\n    const float e = 53.  / 284.; // head-circle\n    const float f = 38.  / 284.; // head-circle cutout\n    const float g = 192. / 284.; // head-circle offset\n\n    // big outter and smaller inner \"circle\"\n    mat4 m1 = trans (vec3 (.0, .0, .0));\n    d1 = cylinder (opTransf (p, m1), vec2 (a, .1));\n    mat4 m2 = trans (vec3 (.0, .0, .0));\n    d2 = cylinder (opTransf (p, m2), vec2 (b, .4));\n    d1 = opSubtract (d2, d1);\n    d2 = cylinder (opTransf (p, m1), vec2 (c, .1));\n    d1 = min (d1, d2);\n\n    // three \"beams\"\n    m1 = trans (vec3 (.0, .2, .0));\n    d2 = box (opTransf (p, m1), vec3 (d, .4, .1), .0);\n    d1 = min (d1, d2);\n\n    m1 = trans (vec3 (.0, .2, .0)) * rotZ (angle);\n    d2 = box (opTransf (p, m1), vec3 (d, .4, .1), .0);\n    d1 = min (d1, d2);\n\n    m1 = trans (vec3 (.0, .2, .0)) * rotZ (2. * angle);\n    d2 = box (opTransf (p, m1), vec3 (d, .4, .1), .0);\n    d1 = min (d1, d2);\n\n    // three small \"circles\"\n    m1 = trans (vec3 (.0, g, .0)) * rotZ (offset);\n    d2 = cylinder (opTransf (p, m1), vec2 (e, .1));\n    d1 = min (d1, d2);\n\n    m1 = trans (vec3 (.0, g, .0)) * rotZ (offset + angle);\n    d2 = cylinder (opTransf (p, m1), vec2 (e, .1));\n    d1 = min (d1, d2);\n\n    m1 = trans (vec3 (.0, g, .0)) * rotZ (offset + 2. * angle);\n    d2 = cylinder (opTransf (p, m1), vec2 (e, .1));\n    d1 = min (d1, d2);\n\n    // three small \"circle\"-cutouts\n    m1 = trans (vec3 (.0, g, .0)) * rotZ (offset);\n    d2 = cylinder (opTransf (p, m1), vec2 (f, .2));\n    d1 = opSubtract (d2, d1);\n\n    m1 = trans (vec3 (.0, g, .0)) * rotZ (offset + angle);\n    d2 = cylinder (opTransf (p, m1), vec2 (f, .2));\n    d1 = opSubtract (d2, d1);\n\n    m1 = trans (vec3 (.0, g, .0)) * rotZ (offset + 2. * angle);\n    d2 = cylinder (opTransf (p, m1), vec2 (f, .2));\n    d1 = opSubtract (d2, d1);\n\n    return d1;\n}\n\nfloat map (vec3 p, inout int matindex)\n{\n    float ground = .0;\n    float ulogo = .0;\n    float t = iTime;\n\n    ground = wavyfloor (p, normalize (vec4 (.0, -.5, .0, 1.)));\n    mat4 m = rotY (40. * t);\n    ulogo = logo (opTransf (p, m));\n\n    float d = min (ground, ulogo);\n    if (d == ground) {\n        matindex = 1;\n    } else if (d == ulogo) {\n        matindex = 2;\n    }\n\n    return d;\n}\n\nvec3 normal (vec3 p)\n{\n    vec3 e = vec3 (.0001, .0, .0);\n    int matindex;\n    float d = map (p, matindex);\n\n    vec3 n = vec3 (map (p + e.xyy, matindex) - d,\n                   map (p + e.yxy, matindex) - d,\n                   map (p + e.yyx, matindex) - d);\n\n    return normalize (n);\n}\n\nfloat shadow (vec3 ro, vec3 rd, float tmin, float k)\n{\n    float s = 1.;\n    float d = .0;\n    float t = tmin;\n    int index = 0;\n    for (int i = 0; i < 32; i++) {\n        d = map (ro + rd * t, index);\n        if (d < epsilon) {\n            return .0;\n        }\n        s = min (s, k * d / t);\n        t += d;\n    }\n    return s;\n}\n\nvec4 shade (vec3 p, vec4 color)\n{\n    float t = 1.5 * iTime;\n    vec3 lPos0 = vec3 (3. * cos (t),       -4., 3. * sin (t));\n    vec3 lPos1 = vec3 (4. * cos (-t * .2), -3., 4. * sin (-t));\n\n    vec4 lCol = vec4 (.95, .95, .9, 1.);\n    vec3 n = normal (p);\n    vec3 lDir0 = normalize (lPos0 - p);\n    vec3 lDir1 = normalize (lPos1 - p);\n    vec4 lInt0 = lCol * dot (n, lDir0);\n    vec4 lInt1 = lCol * dot (n, lDir1);\n    vec4 col = shadow (p, normalize (lPos0 - p), 0.001, 64.) * lInt0 * color;\n    col += shadow (p, normalize (lPos1 - p), 0.001, 64.) * lInt1 * color;\n\n    return col;\n}\n\nmat3 camera (vec3 eye, vec3 aim, float r)\n{\n    vec3 cw = normalize (aim - eye);\n    vec3 cp = vec3 (sin (r), cos (r), .0);\n    vec3 cu = normalize (cross (cw, cp));\n    vec3 cv = normalize (cross (cu, cw));\n    return mat3 (cu, cv, cw);\n}\n\nfloat march (vec3 ro, vec3 rd, float pixelSize, inout int index)\n{\n    bool forceHit = false;\n    float infinity = 10000.0;\n    float t_min = .0001;\n    float t_max = 50.0;\n    float t = t_min;\n    float candidate = t_min;\n    float candidate_error = infinity;\n    float w = 1.4;\n    float lastd = .0;\n    float stepSize = .0;\n    float sign = map (ro, index) < .0 ? -1. : 1.;\n\n    for (int i = 0; i < MAX_STEPS; i++)\n\t{\n        float signedd = sign * map (ro + rd * t, index);\n        float d = abs (signedd);\n        bool fail = w > 1. && (d + lastd) < stepSize;\n\n        if (fail) {\n            stepSize -= w * stepSize;\n            w = 1.;\n        } else {\n            stepSize = signedd * w;\n        }\n\n\t\tlastd = d;\n\n        float error = d / t;\n        if (!fail && error < candidate_error) {\n            candidate_error = error;\n            candidate = t;\n        }\n\n        if (!fail && error < pixelSize || t > t_max) {\n        \tbreak;\n\t\t}\n\n        t += stepSize;\n \n\t}\n\n    if ((t > t_max || candidate_error > pixelSize) && !forceHit) {\n        return infinity;\n    }\n\n\treturn candidate;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec3 eye = vec3 (cos (4. * mouse.x) * 7., -3., sin (4. * mouse.x) * 7.);\n    vec3 aim = vec3 (.0, .0, .0);\n    mat3 cam = camera (eye, aim, .0);\n    vec2 uv = vec2 (-.9 + fragCoord.x / iResolution.y, .5 - fragCoord.y / iResolution.y);\n\n    vec3 ro = eye;\n    vec3 rd = cam * normalize (vec3 (uv, 1.8));\n    vec4 bg = laubergine;\n    float pixelSize = 1. / iResolution.x;\n    int matindex = 0;\n    float t = march (ro, rd, pixelSize, matindex);\n    vec4 color = bg;\n    if (matindex == 1) {\n\t\tcolor = mix (shade (ro + rd * t, wgrey), bg, length (rd * t) / 50.);\n    } else if (matindex == 2) {\n        color = mix (shade (ro + rd * t, uorange), bg, length (rd * t) / 50.);\n    }\n\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}