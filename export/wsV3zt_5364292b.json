{"ver":"0.1","info":{"id":"wsV3zt","date":"1570792256","viewed":397,"name":"halftone screening","username":"KeyJ","description":"A real-time halftoning algorithm with properly antialiased halftone dots.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["dither","halftone","raster"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// RGB/CMYK halftone screening post-process effect\n// with properly antialiased (not just blurred) dots\n\n// size of the halftone dots, in pixels\nconst float HALFTONE_DOT_SIZE = 3.5;\n\n// screen angles (in degrees) for the individual components\nconst vec4 HALFTONE_ANGLES = radians(vec4(15.0, 75.0, 0.0, 45.0));\n\n// \"smoothness\" of the dots, i.e. amount of anti-aliasing applied\n// 0.0 = no AA; 2.0 looks reasonable; more = blurrier dots\nconst float SMOOTHNESS = 2.0;\n\n// #define CMYK to perform halftoning in CMYK color space;\n// #undef  CMYK to perform halftoning in RGB color space\n#define CMYK\n\n// in CMYK mode, colors will always look \"washed out\" a bit\n// due to the very simple color space transform that is performed;\n// to regain a little fidelity, the K value is fudged a bit\n// to coarsely restore overall contrast\nconst float CMYK_K_GAMMA = 0.7;\n\n\n// macro to convert the halftone screen angles and dot sizes\n// to transform matrices\n#define ANGLE2MATRIX(a) (mat2(cos(a), sin(a), -sin(a), cos(a)) / HALFTONE_DOT_SIZE)\n\n\n// inverse smoothstep\n// Used to pre-process the color values to reduce contast,\n// because the halftoning again *increases* contast.\n// Smoothstep is definitely not the right function\n// to use here (we'd need the inverse of the radius-to-\n// cell-coverage function), but it's an approximation\n// that works well enough for our (purely artistic) purposes.\nfloat inv_smooth(float x) {\n    return x + (x - (x * x * (3.0 - 2.0 * x)));\n}\n\n\n// perform halftoning for a single color component\n// - coord: screen coordinate (in pixels)\n// - value: intensity value to dither (0..1)\n// - xform: rotation and scaling matrix for the screening pattern\nfloat halftone(in vec2 coord, in float value, in mat2 xform) {\n    coord = xform * coord;\n    value = inv_smooth(value);\n    float d = length(fract(coord) - 0.5);\n    float trans = SMOOTHNESS * length(dFdx(coord));\n    return smoothstep(0.0, trans, value * (1.0 + trans) - d * 1.4142);\n}\n\n\n// halftone an RGB image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 rgb = texture(iChannel0, uv).rgb;\n\n#ifdef CMYK\n    // poor man's RGB<->CMYK conversion\n    float k = 1.0 - max(max(rgb.r, rgb.g), rgb.b);\n    vec4 cmyk = vec4(1.0 - rgb / (1.0 - k), k);\n// /* // toggle comment on this line to disable halftoning\n    cmyk.a = pow(cmyk.a, CMYK_K_GAMMA);\n    cmyk = vec4(\n    \thalftone(fragCoord, cmyk.r, ANGLE2MATRIX(HALFTONE_ANGLES.r)),\n    \thalftone(fragCoord, cmyk.g, ANGLE2MATRIX(HALFTONE_ANGLES.g)),\n    \thalftone(fragCoord, cmyk.b, ANGLE2MATRIX(HALFTONE_ANGLES.b)),\n    \thalftone(fragCoord, cmyk.a, ANGLE2MATRIX(HALFTONE_ANGLES.a)));\n// */\n    rgb = (1.0 - cmyk.rgb) * (1.0 - cmyk.a);\n#else\n    rgb = vec3(\n    \thalftone(fragCoord, rgb.r, ANGLE2MATRIX(HALFTONE_ANGLES.r)),\n    \thalftone(fragCoord, rgb.g, ANGLE2MATRIX(HALFTONE_ANGLES.a)),\n    \thalftone(fragCoord, rgb.b, ANGLE2MATRIX(HALFTONE_ANGLES.g)));\n#endif\n\n    fragColor = vec4(sqrt(rgb),1.);\n}","name":"Image","description":"","type":"image"}]}