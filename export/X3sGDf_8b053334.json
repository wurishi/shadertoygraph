{"ver":"0.1","info":{"id":"X3sGDf","date":"1708878951","viewed":76,"name":"Triangles and Circles","username":"TheJinxedArtist","description":"A small visualization of how sin() and cos() are connected to circles and triangles.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["circles","triangles","visualization","sine","cosine"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Dont touch these\n#define px (1.0 / iResolution.y)\nconst float pi = 3.14159265;\n//Ok maybe touch this\n#define time (iTime * 2.0)\n\n//Comment this to control the angle (in degrees) manualy.\n#define ANIMATE\n\n#ifdef ANIMATE\n    #define angle time\n#else\n    #define angle radians(0.0)\n#endif\n\n//Basic functions for visualizing stuff\nfloat aastep(float x) {\n    return smoothstep(-px, px, x);\n}\n\nfloat circle(vec2 p, float r) {\n    return aastep(length(p) - r);\n}\n\nfloat ring(vec2 p, float r1, float r2) {\n    return circle(p, r1) - circle(p, r2);\n}\n\nfloat line(vec2 p, vec2 o, float s) {\n    return aastep(dot(p, o) + s) - aastep(dot(p, o) - s);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b, float r) {\n\tvec2 g = b - a;\n    float d = abs(dot(normalize(vec2(g.y, -g.x)), p - a));\n\treturn smoothstep(r, 0.5*r, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    //Probably shouldn't touch these\n    float s = sin(angle);\n    float c = cos(angle);\n    vec2 p = vec2(s, c);\n    //This just changes the radius of the circle, you can change it\n    const float r = 0.3;\n    //The value that will be output, changing it to -1.0 gives a cool effect\n    float v = 0.0;\n    \n    v += ring(uv, r, r + px);                                          //Circle\n    v += line(uv - vec2(0,c) * r, vec2(0,1), px);                      //Y Position on Cosine (Line)\n    v += line(uv - vec2(s,0) * r, vec2(1,0), px);                      //X Position on Sine (Line)\n    v += line(uv + vec2(s,c) * r, vec2(s,c), px);                      //Tangent Line (Kinda), Opposite Side of Circle for Clarity\n    v += line(uv - vec2(0,r), vec2(0,1), px) * 0.5;                    //Top Border\n    v += line(uv + vec2(0,r), vec2(0,1), px) * 0.5;                    //Bottom Border\n    v += line(uv - vec2(r,0), vec2(1,0), px) * 0.5;                    //Right Border\n    v += line(uv + vec2(r,0), vec2(1,0), px) * 0.5;                    //Left Border\n    v += line(uv - vec2(0, cos(uv.x*pi+angle))*r, vec2(0,1),px) * 0.5; //Cosine Wave (Y)\n    v += line(uv - vec2(sin(uv.y*pi+angle), 0)*r, vec2(1,0),px) * 0.5; //Sine Wave (X)\n    v += line(uv, vec2(0.0, c)*r, vec2(s, 0.0)*r, px);                 //Hypotenuse from X and Y positions\n    v += line(uv, vec2(s,c)*r, vec2(0), px) * 0.5;                     //Radius / Diameter / Angle / Normal (Depends What You're Looking For)\n    v += 1.0 - circle(uv - p * r, 0.01);                               //Position On Circle\n    v += 1.0 - circle(uv - vec2(0.0, c)*r, 0.01);                      //Y Position (Point)\n    v += 1.0 - circle(uv - vec2(s, 0.0)*r, 0.01);                      //X Position (Point)\n    v += 1.0 - circle(uv + vec2(s,c)*r, 0.01);                         //Opposite Position On Circle\n    v += 1.0 - circle(uv, 0.01);                                       //Middle Point\n    \n    fragColor = vec4(v);\n}","name":"Image","description":"","type":"image"}]}