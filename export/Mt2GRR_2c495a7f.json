{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define R iResolution.xy\n#define EPSILON 0.00001\n#define T iTime * 2.\n\nstruct\t\tobj\n{\n    int id;\n\tvec4 pos;\n\tvec3 dir;\n    vec3 col;\n    float ka;\n    float kt;\n    float kd;\n    float ks;\n    float kr;\n    float kl;\n    float n;\n};\n\nvec3 cam = vec3(0.0, 0.0, 8.0);\n\nobj olum = obj(0, vec4(0.0, 3.5, 0.0, 0.0), vec3(0.0), vec3(1.0, 1.0, 0.0), 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0);\nobj osph = obj(1, vec4(-1.0, 0.5, 0.0, 0.5), vec3(0.0), vec3(1.0, 1.0, 1.0), 0.15, 0.0, 0.5, 0.5, 1.0, 42.0, 1.0);\nobj osph2 = obj(2, vec4(0.0, 0.5, 1.0, 0.5), vec3(0.0), vec3(0.0, 1.0, 1.0), 0.15, 0.8, 0.5, 0.5, 0.0, 42.0, 1.33);\nobj opln = obj(3, vec4(0.0, -1.0, 0.0, -2.0), vec3(0.0), vec3(1.0, 0.0, 0.0), 0.15, 0.0, 0.5, 0.5, 0.2, 42.0, 1.0);\nobj opln2 = obj(4, vec4(-1.0, 0.0, 0.0, -5.0), vec3(0.0), vec3(0.0, 0.0, 1.0), 0.15, 0.0, 0.5, 0.5, 0.0, 42.0, 1.0);\nobj opln3 = obj(5, vec4(1.0, 0.0, 0.0, -5.0), vec3(0.0), vec3(0.0, 1.0, 0.0), 0.15, 0.0, 0.5, 0.5, 0.0, 42.0, 1.0);\nobj opln4 = obj(6, vec4(.0, -1.0, 0.0, 5.0), vec3(0.0), vec3(0.0, 1.0, 1.0), 0.3, 0.0, 0.5, 0.1, 0.0, 42.0, 1.0);\nobj opln5 = obj(7, vec4(.0, 0.0, -1.0, -15.0), vec3(0.0), vec3(1.0, 1.0, 1.0), 0.0, 0.0, 0.0, 0.5, 1.0, 142.0, 1.0);\nobj opln6 = obj(8, vec4(.0, 0.0, 1.0, -15.0), vec3(0.0), vec3(1.0, 1.0, 1.0), 0.0, 0.0, 0.0, 0.5, 1.0, 142.0, 1.0);\nobj ocyl = obj(9, vec4(-2.0, 0.0, -5.0, 0.3), vec3(0.0, 1.0, 0.0), vec3(1.0, 1.0, 0.0), 0.15, 0.0, 0.5, 0.5, 0.0, 24.0, 1.0);\nobj ocyl2 = obj(10, vec4(2.0, 0.0, -5.0, 0.3), vec3(0.0, 1.0, 0.0), vec3(1.0, 1.0, 0.0), 0.15, 0.0, 0.5, 0.5, 0.0, 24.0, 1.0);\nobj ocon = obj(11, vec4(0.0, 1.0, -10.0, 0.3), vec3(0.0), vec3(0.0, 0.0, 1.0), 0.15, 0.0, 0.5, 0.5, 0.0, 42.0, 1.0);\nobj otri = obj(12, vec4(0.0, 0.0, 0.0, 0.0), vec3(0.0), vec3(1.0, 0.95, 0.9), 0.15, 1.0, 0.0, 0.5, 0.2, 42.0, 1.05);\n//obj otor = obj(13, vec4(0.0, 1.0, -1.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(1.0, 1.0, 1.0), 0.15, 0.0, 0.5, 0.5, 0.0, 42.0, 1.0);\nvec3 ntri = vec3(0.0);\n\n//vec3 v;\n//float rand(vec2 n)\n//{\n//  return (0.5 + 0.5 * fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453));\n//}\n\nfloat rand;\nvoid randomize(vec2 c)\n{\n    rand = fract(sin(dot(c,vec2(113.421,17.329)))*3134.1234);\n}\n\nobj\t\tgetObj(in int id)\n{\n\tif (id == 1)\n        return (osph);\n    if (id == 2)\n        return (osph2);\n    if (id == 3)\n        return (opln);\n    if (id == 4)\n        return (opln2);\n    if (id == 5)\n        return (opln3);\n    if (id == 6)\n        return (opln4);\n    if (id == 7)\n        return (opln5);\n    if (id == 8)\n        return (opln6);\n    if (id == 9)\n        return (ocyl);\n    if (id == 10)\n        return (ocyl2);\n    if (id == 11)\n        return (ocon);\n    if (id == 12)\n        return (otri);\n    //if (id == 13)\n    //    return (otor);\n    return (olum);\n}\n\nfloat\tisphere(in vec3 ro, in vec3 rd, in int id)\n{\n\tobj o = getObj(id);\n    ro = ro - o.pos.xyz;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(ro, rd);\n    float c = dot(ro, ro) - o.pos.w * o.pos.w;\n    float d = b * b - 4.0 * a * c;\n    if (d < 0.001)\n        return (-1.0);\n    a *= 2.0;\n    return (min((-b - sqrt(d)) / a, (-b + sqrt(d)) / a));\n}\n\nvec3\tnsphere(in vec3 pos, in int id)\n{\n\tobj o = getObj(id);\n    return ((pos - o.pos.xyz) / o.pos.w);\n}\n\nfloat\tiplane(in vec3 ro, in vec3 rd, in int id)\n{\n    obj o = getObj(id);\n    float d = -(dot(ro, normalize(o.pos.xyz)) + o.pos.w) / dot(rd, normalize(o.pos.xyz));\n\n    return (d);\n}\n\nvec3\tnplane(in vec3 pos, int id)\n{\n    obj o = getObj(id);\n\treturn (o.pos.xyz * -1.0);\n}\n\nfloat\ticylender(in vec3 ro, in vec3 rd, in int id)\n{\n\tobj o = getObj(id);\n    ro = ro - o.pos.xyz;\n    ro *= 1.0 - o.dir;\n    rd *= 1.0 - o.dir;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(ro, rd);\n    float c = dot(ro, ro) - o.pos.w * o.pos.w;\n    float d = b * b - 4.0 * a * c;\n    if (d < 0.001)\n        return (-1.0);\n    a *= 2.0;\n    return (min((-b - sqrt(d)) / a, (-b + sqrt(d)) / a));\n}\n\nvec3\tncylender(in vec3 pos, in int id)\n{\n\tobj o = getObj(id);\n    vec3 n = ((pos - o.pos.xyz) * (1.0 - o.dir)) / o.pos.w;\n    return (n);\n}\n\nfloat\ticone(in vec3 ro, in vec3 rd, in int id)\n{\n\tobj o = getObj(id);\n    ro = ro - o.pos.xyz;\n    float a = dot(rd.xz, rd.xz) - o.pos.w * rd.y * rd.y;\n    float b = 2.0 * (dot(ro.xz, rd.xz) - o.pos.w * ro.y * rd.y);\n    float c = dot(ro.xz, ro.xz) - o.pos.w * ro.y * ro.y;\n    float d = b * b - 4.0 * a * c;\n    if (d < 0.001)\n        return (-1.0);\n    a *= 2.0;\n    return (min((-b - sqrt(d)) / a, (-b + sqrt(d)) / a));\n}\n\nvec3\tncone(in vec3 pos, in int id)\n{\n    obj o = getObj(id);\n\tvec3 n = pos - o.pos.xyz;\n    n.y = -n.y * tan(o.pos.w);\n    return (normalize(n));\n}\n\nfloat\titriangle(in vec3 ro, in vec3 rd, in int id)\n{\n\tvec3 p1 = vec3(-0.5, -0.45, 0.0);\n\tvec3 p0 = vec3(0.5, -0.45, 0.0);\n\tvec3 p2 = vec3(0.0, -0.5, 2.0);\n    \n    p1.y += (sin(iTime / 2.0) + 1.0) / 2.0;\n    p0.y += (sin(iTime / 2.0) + 1.0) / 2.0;\n    p1.x += sin(iTime / 2.0);\n    p0.x += sin(iTime / 2.0);\n    p2.x += sin(iTime / 2.0);\n    p1.z += cos(iTime) * 2.0;\n    p0.z += cos(iTime) * 2.0;\n    p2.z += cos(iTime);\n\n\tvec3 e1 = p1 - p0;\n\tvec3 e2 = p2 - p0;\n\tvec3 e1e2 = cross(e1, e2);\n\tvec3 p = cross(rd, e2);\n\te1e2 = normalize(e1e2);\n\tfloat a = dot(e1, p);\n\tif(a < 0.001)\t\n    \treturn (-1.0);\n\n\tfloat f =  1.0 / a;\n\tvec3 s = ro - p0;\n\tfloat u = f * (dot(s, p));\n\tif(u < 0.0 || u > 1.0)\n\t    return (-1.0);\n\t\n\tvec3 q = cross(s, e1);\n\tfloat v = f * (dot(rd, q));\n\tif(v < 0.0 || u + v > 1.0)\n\t    return (-1.0);\n    ntri = e1e2;\n\treturn (f * dot(e2, q));\n}\n\nfloat\titorus(in vec3 ro, in vec3 rd, in int id)\n{\n\tobj o = getObj(id);\n    ro -= o.pos.xyz;\n    float u = dot(o.dir, rd);\n    float v = dot(o.dir, rd);\n    float a = dot(rd, rd) - v * v;\n    float b = 2.0 * (dot(ro, rd) - u * v);\n    float c = dot(ro, ro) - u * u;\n\tfloat d = dot(ro, ro) + o.pos.w * o.pos.w - 0.8 * 0.8;\n    float A = pow(dot(rd, rd), 2.0);\n    float B = 4.0 * dot(ro, rd);\n    float C = 2.0 * d + (b * b) / 4.0 - 4.0 * o.pos.w * o.pos.w * (1.0 - v * v);\n    float D = B * d - 4.0 * o.pos.w * o.pos.w * b;\n    if (D < 0.001)\n        return (-1.0);\n    return (d * d - 4.0 * 1.0 * 1.0 * c);\n}\n\nfloat\tgetIntersect(in vec3 ro, in vec3 rd, in int id)\n{\n\tif (id > 0 && id < 3)\n        return (isphere(ro, rd, id));\n    if (id > 2 && id < 9)\n        return (iplane(ro, rd, id));\n    if (id > 8 && id < 11)\n\t    return (icylender(ro, rd, id));\n\tif (id == 11)\n    \treturn (icone(ro, rd, id));\n    if (id == 12)\n        return (itriangle(ro, rd, id));\n    //if (id == 13)\n    //    return (itorus(ro, rd, id));\n    return (-1.0);\n}\n\nvec3\tgetNormale(in vec3 pos, in int id)\n{\n\tif (id > 0 && id < 3)\n        return (nsphere(pos, id));\n    if (id > 2 && id < 9)\n        return (nplane(pos, id));\n    if (id > 8 && id < 11)\n    \treturn (ncylender(pos, id));\n    if (id == 11)\n    \treturn (ncone(pos, id));\n    if (id == 12)\n        return (ntri);\n    return (vec3(0.0));\n}\n\nint\t\tintersect(in vec3 ro, in vec3 rd, out float t)\n{\n    int id = -1;\n    \n    t = 1000.0;\n    for (int i = 1; i < 13; i++)\n    {\n        float ti = getIntersect(ro, rd, i);\n        if (ti > 0.001 && ti < t)\n        {\n            id = i;\n            t = ti;\n        }\n    }\n    return (id);\n}\n\nvec3\tprocessColor3(in vec2 uv, in vec3 ro, in vec3 rd, in float t, int id, int inside)\n{\n    obj o, l;\n\tvec3 amb, dif, spe, p, n, ln, lp, nlp;\n    float ps1, ps2, t1, tmp, coef;\n\n    o = getObj(id);\n    l = olum;\n    //p = ro + t * rd;\n    //n = getNormale(p, id);\n    //lp = normalize(l.pos.xyz - p);\n    //nlp = normalize(p - l.pos.xyz);\n    //ps1 = dot(n, lp);\n    //ps2 = -dot(n, nlp);\n    amb = o.col * (1.0 - o.kt) * o.ka;\n    dif = spe = vec3(0.0);\n    //if (ps1 > 0.0)\n    //{\n    //\tif ((intersect(l.pos.xyz, nlp, t1) == id))\n    //    {\n    //        dif = o.kd * o.col * ps1;\n    //\t\tif (ps2 > 0.0)\n    //\t\t    spe = l.col * o.ks * pow(ps2, o.kl);\n    //    }\n    //}\n    return (amb + dif + spe);\n}\n\nvec3\tgetPixelColor3(in vec2 uv, in vec3 ro, in vec3 rd, int inside)\n{\n    vec3 col = vec3(0.0);\n    float t = 1000.0;\n    int id = intersect(ro, rd, t);\n    \n    if (id > 0)\n    \treturn (processColor3(uv, ro, rd, t, id, inside));\n    return (col);\n}\n\nvec3\tprocessColor2(in vec2 uv, in vec3 ro, in vec3 rd, in float t, int id, int inside)\n{\n\t    obj o, l;\n\tvec3 amb, dif, spe, refl, refr, p, n, ln, lp, nlp;\n    float ps1, ps2, t1, tmp, coef;\n\n    o = getObj(id);\n    l = olum;\n    p = ro + t * rd;\n    n = getNormale(p, id);\n    lp = normalize(l.pos.xyz - p);\n    nlp = normalize(p - l.pos.xyz);\n    ps1 = dot(n, lp);\n    ps2 = -dot(n, nlp);\n    amb = o.col * (1.0 - o.kt) * o.ka;\n    dif = spe = refl = refr = vec3(0.0);\n    if (ps1 > 0.0)\n    {\n        if ((intersect(l.pos.xyz, nlp, t1) == id))\n        {\n            dif = o.kd * o.col * ps1;\n    \t\tif (ps2 > 0.0)\n    \t\t    spe = l.col *o.ks * pow(ps2, o.kl);\n        }\n    }\n    if (o.kr > 0.0)\n    \trefl = o.kr * getPixelColor3(uv, p, reflect(rd, n), inside);\n   \t//if (o.kt > 0.0)\n    //{\n    //    inside = ((o.n == 1.0) ? 0 : ((inside == 0) ? 1 : 0));\n    //    float dev = ((inside == 1) ? 1.0 / o.n : o.n);\n    //    float ps = dot(rd, n);\n    //    float ti = acos(ps);\n    //    float tt = asin(dev * sin(ti));\n    //    float coef = cos(tt) + dev * ps;\n    //    refr = o.kt * getPixelColor3(uv, p, rd * dev - coef * n, inside);\n\t//}\n    return (amb + dif + spe + refl + refr);\n}\n\nvec3\tgetPixelColor2(in vec2 uv, in vec3 ro, in vec3 rd, int inside)\n{\n    vec3 col = vec3(0.0);\n    float t = 10000.0;\n    int id = intersect(ro, rd, t);\n    \n    if (id > 0)\n    \treturn (processColor2(uv, ro, rd, t, id, inside));\n    return (col);\n}\n\nvec3\tprocessColor(in vec2 uv, in vec3 ro, in vec3 rd, in float t, int id, int inside)\n{\n    obj o, l;\n\tvec3 amb, dif, spe, refl, refr, p, n, ln, lp, nlp;\n    float ps1, ps2, t1, coef;\n    int id2;\n\n    o = getObj(id);\n    l = olum;\n    p = ro + t * rd;\n    n = getNormale(p, id);\n    lp = normalize(l.pos.xyz - p);\n    nlp = normalize(p - l.pos.xyz);\n    ps1 = dot(n, lp);\n    ps2 = -dot(n, nlp);\n    amb = o.col * (1.0 - o.kt) * o.ka;\n    dif = spe = refl = refr = vec3(0.0);\n    if (ps1 > 0.0)\n    {\n        id2 = intersect(l.pos.xyz, nlp, t1);\n    \tif (id2 == id)\n        {\n            dif = o.kd * o.col * ps1;\n    \t\tif (ps2 > 0.0)\n    \t\t    spe = l.col * o.ks * pow(ps2, o.kl);\n        }\n    }\n    if (o.kr > 0.0)\n    \trefl = o.kr * getPixelColor2(uv, p, reflect(rd, n), inside);\n    if (o.kt > 0.0)\n    {\n        inside = ((o.n == 1.0) ? 0 : ((inside == 0) ? 1 : 0));\n        float dev = ((inside == 1) ? 1.0 / o.n : o.n);\n        float ps = dot(rd, n);\n        float ti = acos(ps);\n        float tt = asin(dev * sin(ti));\n        float coef = cos(tt) + dev * ps;\n        refr = o.kt * getPixelColor2(uv, p, rd * dev - coef * n, inside);\n    }\n    return (amb + dif + spe + refl + refr);\n}\n\nvec3\tgetPixelColor(in vec2 uv, in vec3 ro, in vec3 rd)\n{\n    vec3 col = vec3(0.0);\n    float t = 1000.0;\n    int id = intersect(ro, rd, t);\n    \n    if (id > 0)\n    \treturn (processColor(uv, ro, rd, t, id, 0));\n    return (col);\n}\n\nmat3 mid = mat3(1.0, 0.0, 0.0,\n                0.0, 1.0, 0.0,\n                0.0, 0.0, 1.0);\n\nmat3\trotX(float a)\n{\n\tmat3 m;\n    \n    m = mid;\n    m[1][1] = cos(a);m[1][2] = -sin(a);\n    m[2][1] = sin(a);m[2][2] = cos(a);\n    return (m);\n}\n\nmat3\trotY(float a)\n{\n\tmat3 m;\n    \n    m = mid;\n    m[0][0] = cos(a);m[0][2] = sin(a);\n    m[2][0] = -sin(a);m[2][2] = cos(a);\n    return (m);\n}\n\nmat3\trotZ(float a)\n{\n\tmat3 m;\n    \n    m = mid;\n    m[0][0] = cos(a);m[0][1] = -sin(a);\n    m[1][0] = sin(a);m[1][1] = cos(a);\n    return (m);\n}\n\nmat3\trot(float x,float y, float z)\n{\n\tmat3 m;\n    \n    x = x * 3.1415 / 180.0;\n    y = y * 3.1415 / 180.0;\n    z = z * 3.1415 / 180.0;\n    m = mid;\n    m *= rotX(x);\n    m *= rotY(y);\n    m *= rotZ(z);\n    return (m);\n}\n\nmat3\trot2(vec2 a)\n{\n\tmat3 m;\n    \n    m = mid;\n    m *= rotX(a.x);\n    m *= rotY(a.y);\n    return (m);\n}\n\nvoid\tmainImage(out vec4 C, in vec2 U)\n{\n    float e = 2. * tan(radians(30.));\n    float ratio = R.x / R.y;\n\tvec2 uv = 1. * U / R - .5;\n    vec3 ro = texture(iChannel0, U/R).xyz;\n    vec3 rd = normalize(vec3(uv * vec2(e * ratio, e), 1.));\n    rd *= rot2(texture(iChannel1, U/R).xy);\n\n    olum.pos.x = cos(-iTime) * 3.0;\n    olum.pos.y += sin(-iTime);\n    olum.pos.z = sin(-iTime) * 3.0;\n    osph.pos.x = cos(iTime) * 3.0;\n    osph.pos.z = sin(iTime) * 3.0;\n    osph2.pos.y += cos(iTime);\n    osph2.pos.x += cos(iTime / 2.0) * 1.0;\n    osph2.pos.z += sin(iTime / 2.0) * 1.0;\n    opln5.pos.w += cos(iTime) * 5.0;\n    opln6.pos.w += sin(iTime) * 5.0;\n    olum.col.x = cos(iTime / 2.0) * 0.5 + 1.0;\n    olum.col.y = cos(iTime / 3.0) * 0.5 + 1.0;\n    olum.col.z = cos(iTime / 3.5) * 0.5 + 1.0;\n    opln.ka *= (cos(iTime / 4.2) + 1.0);\n    opln.kd *= (sin(iTime / 3.2) + 1.0);\n    opln2.ka *= (cos(iTime / 4.2) + 1.0);\n    opln2.kd *= (sin(iTime / 3.2) + 1.0);\n    opln3.ka *= (cos(iTime / 4.2) + 1.0);\n    opln3.kd *= (sin(iTime / 3.2) + 1.0);\n    opln4.ka *= (cos(iTime / 4.2) + 1.0);\n    opln4.kd *= (sin(iTime / 3.2) + 1.0);\n    opln5.ka *= (cos(iTime / 4.2) + 1.0);\n    opln5.kd *= (sin(iTime / 3.2) + 1.0);\n    opln6.ka *= (cos(iTime / 4.2) + 1.0);\n    opln6.kd *= (sin(iTime / 3.2) + 1.0);\n    osph2.n = (cos(iTime / 4.0) + 2.0);\n\tC = vec4(getPixelColor(uv, ro, rd),1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define T iTime\n#define R iResolution.xy\n\nmat3 mid = mat3(1.0, 0.0, 0.0,\n                0.0, 1.0, 0.0,\n                0.0, 0.0, 1.0);\n\nmat3\trotX(float a)\n{\n\tmat3 m;\n    \n    m = mid;\n    m[1][1] = cos(a);m[1][2] = -sin(a);\n    m[2][1] = sin(a);m[2][2] = cos(a);\n    return (m);\n}\n\nmat3\trotY(float a)\n{\n\tmat3 m;\n    \n    m = mid;\n    m[0][0] = cos(a);m[0][2] = sin(a);\n    m[2][0] = -sin(a);m[2][2] = cos(a);\n    return (m);\n}\n\nmat3\trot(vec2 a)\n{\n\tmat3 m;\n    \n    m = mid;\n    m *= rotX(a.x);\n    m *= rotY(a.y);\n    return m;\n}\n\nvoid mainImage(out vec4 C, in vec2 U)\n{\n    vec2 uv = U / R;\n    if (T < .1 || texelFetch(iChannel1, ivec2(13,0), 0).x > 0.)\n        C.xyz = vec3(0, 0, -15);\n\telse\n    {\n        vec3 pos = texture(iChannel0, uv, .5).xyz;\n        vec3 d = vec3(0);\n        float e = 2. * tan(radians(30.));\n    \tfloat ratio = R.x / R.y;\n\t\tuv = 1. * U / R - .5;\n        if (texelFetch(iChannel1, ivec2(65,0), 0).x > 0. || texelFetch(iChannel1, ivec2(81,0), 0).x > 0.)\n            d.x = -1.;\n        if (texelFetch(iChannel1, ivec2(68,0), 0).x > 0.)\n            d.x = 1.;\n        if (texelFetch(iChannel1, ivec2(87,0), 0).x > 0. || texelFetch(iChannel1, ivec2(90,0), 0).x > 0.)\n            d.z = 1.;\n        if (texelFetch(iChannel1, ivec2(83,0), 0).x > 0.)\n            d.z = -1.;\n        \n        C.xyz = pos + (d * rot(texture(iChannel2, uv, .5).xy)) * .25;\n        \n        /*\n        if (C.y - 1. > 0.)\n            C.y -= .2;\n        if (C.y - 1. < 0.)\n            C.y = 1.;\n        */\n        \n        if (texelFetch(iChannel1, ivec2(16,0), 0).x > 0.)\n            C.y -= .25;\n        if (texelFetch(iChannel1, ivec2(32,0), 0).x > 0.)\n            C.y += .25;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XsXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define T iTime\n#define R iResolution.xy\n#define s 3.14 / 90.\n\nvoid mainImage(out vec4 C, in vec2 U)\n{\n    vec2 uv = U / R;\n    if (T < .1 || texelFetch(iChannel1, ivec2(13,0), 0).x > 0.)\n        C.xy = vec2(0, 0);\n\telse\n    {\n        vec2 a = texture(iChannel0, uv, .5).xy;\n        if (texelFetch(iChannel1, ivec2(74,0), 0).x > 0.)\n            a.y -= s;\n        if (texelFetch(iChannel1, ivec2(76,0), 0).x > 0.)\n            a.y += s;\n        if (texelFetch(iChannel1, ivec2(73,0), 0).x > 0.)\n            a.x -= s;\n        if (texelFetch(iChannel1, ivec2(75,0), 0).x > 0.)\n            a.x += s;\n        if (texelFetch(iChannel1, ivec2(17,0), 0).x > 0.)\n            a.x = 0.;\n        C.xy = a;\n    }\n}","name":"Buffer B","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":true,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"Mt2GRR","date":"1426676951","viewed":640,"name":"My SimpleRayTracer","username":"Dermenslof","description":"cool","likes":4,"published":1,"flags":48,"usePreview":1,"tags":["raytracersimple"],"hasliked":0,"parentid":"","parentname":""}}