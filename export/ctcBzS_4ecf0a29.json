{"ver":"0.1","info":{"id":"ctcBzS","date":"1702997684","viewed":25,"name":"Damped Oscillator Visualizator","username":"Silbery","description":"Allows the user to apply a wind force to a modelized tree by mouse clicking. This is a visualization tool to customize the damping of a system (tree in this case). \n\nRed: Wind Blow (Mouse click)\nYellow: Static Tree\nBlue: Dynamic Tree\nGreen: Damping Curve","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["dampingoscillator"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    uv = (fragCoord.xy)/(iResolution.xy);\n    float time = uv.x;\n    \n    float curvatureFactor = flexibility * 1.0;\n\n    float windAmount = getData(iChannel0, WIND_AMOUNT_ADDR).x; // Load value from Buffer A (ichannel0)\n    \n    \n    float dampingCoeff = computeDampingCoeff(mass, springRateCoeff, criticalDampingCoeff);\n    float tau = computeDampingTime(mass, dampingCoeff);\n    float w0 = computeOriginalOscillationFrequency(mass, springRateCoeff);\n    float w = computeOscillationFrequency(tau, w0);\n    float dampingStatic = cos(time * w);\n    \n    if(isDamping)\n    {\n        dampingStatic *= 1.0 * exp(-time / tau);\n    }\n\n    float dampingState = getData(iChannel0, DAMPING_VALUE_ADDR).x; // Load value from Buffer A (ichannel0)\n    \n    float treeModel = 0.0;\n    float staticTreeModel = 0.0;\n    for(int i = 0; i < nbTreeNodes; ++i)\n    {\n        float previousTreeVertexHeight = float(i - 1) * 1.0 / float(nbTreeNodes - 1);\n        float currentTreeVertexHeight = float(i) * 1.0 / float(nbTreeNodes - 1);\n        \n        vec2 previousTreeVertex = vec2(0.0, previousTreeVertexHeight);\n        vec2 currentTreeVertex = vec2(0.0, currentTreeVertexHeight);\n\n        float previoustTreeCurvature = curvatureFactor * previousTreeVertexHeight * dampingState;\n        float currentTreeCurvature = curvatureFactor * currentTreeVertexHeight * dampingState;\n       \n        vec2 previousTreeVertexCurved = vec2(previousTreeVertex.x * cos(-previoustTreeCurvature) - previousTreeVertex.y * sin(-previoustTreeCurvature), previousTreeVertex.x * sin(-previoustTreeCurvature) + previousTreeVertex.y * cos(-previoustTreeCurvature));\n        vec2 currentTreeVertexCurved = vec2(currentTreeVertex.x * cos(-currentTreeCurvature) - currentTreeVertex.y * sin(-currentTreeCurvature), currentTreeVertex.x * sin(-currentTreeCurvature) + currentTreeVertex.y * cos(-currentTreeCurvature));\n        \n        treeModel += drawCircle(currentTreeVertexCurved, 0.01);\n        treeModel += drawLine(previousTreeVertexCurved, currentTreeVertexCurved, 0.2);\n        \n        staticTreeModel += drawCircle(currentTreeVertex, 0.01);\n        staticTreeModel += drawLine(previousTreeVertex, currentTreeVertex, 0.2);\n    }    \n    \n    float dampingValue = plot(dampingStatic);\n    \n    //color define\n    vec3 green = vec3(0.0,1.0,0.0);\n    vec3 red = vec3(0.5, 0.0, 0.0);\n    vec3 blue = vec3(0.0, 0.0, 1.0);\n    vec3 cyan = vec3(0.0, 1.0, 1.0);\n    vec3 yellow = vec3(1.0, 1.0, 0.0);\n    \n    const float sca = 4.0;\n    vec2  p = sca*(2.0*fragCoord-iResolution.xy) / iResolution.y;\n    float px = sca*2.0/iResolution.y;\n    vec3 col = vec3(0.3 + 0.04 * mod(floor(p.x) + floor(p.y), 2.0));  // Gray Chess Background\n    col *= smoothstep(0.5 * px, 1.5 * px, abs(p.x));                  // Y axis Black\n    col *= smoothstep(0.5 * px, 1.5 * px, abs(p.y));                  // X Axis Black\n    \n    col += dampingValue * green;\n    col += treeModel * cyan;\n    col += staticTreeModel * yellow;\n    col += rightArrow(4, 1) * red * windAmount;\n  \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(isData(fragCoord, DAMPING_VALUE_ADDR)) // Initial value\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0); \n    }\n    else if(isData(fragCoord, TIME_PRESSED_ADDR)) // Initial value\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0); \n    }\n    else if(isData(fragCoord, WIND_AMOUNT_ADDR)) // Initial value\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0); \n    }\n\n    // Mouse\n    vec4 mouse = iMouse / iResolution.x;\n    mousePressed = mouse.z > 0.0;\n    \n    if(iFrame > 0) // After initialization\n    {                  \n        if(isData(fragCoord, TIME_PRESSED_ADDR))\n        {\n            // Make time pass from mouse click (reset to 0 when mouse clicked)\n            float timePressed = getData(iChannel0, TIME_PRESSED_ADDR).x;\n            \n            if(mousePressed)\n            {\n                timePressed = 0.0;\n            }\n            else\n            {\n                timePressed += 1.0 / (timeMousePressedInterval * iFrameRate);\n            }\n            \n            fragColor = vec4(timePressed, 0.0, 0.0, 0.0); \n        }\n        else if(isData(fragCoord, WIND_AMOUNT_ADDR))\n        {\n            // Decrease or increase the Wind value depending on the mouse click\n            float windAmount = getData(iChannel0, WIND_AMOUNT_ADDR).x;\n            \n            if(mousePressed)\n            {\n                windAmount += 1.0 / (nbSecondsToFullyChargeWind * iFrameRate);\n            }\n            else\n            {\n                windAmount -= 1.0 / (nbSecondsToFullyDischargeWind * iFrameRate);\n            }\n            windAmount = clamp(windAmount, 0.0, 1.0);\n            \n            fragColor = vec4(windAmount, 0.0, 0.0, 0.0);\n        }\n        else if(isData(fragCoord, DAMPING_VALUE_ADDR))\n        {        \n            // Calculate the damping value of the tree in relation to the wind\n            timeMousePressed = getData(iChannel0, TIME_PRESSED_ADDR).x;\n            float windAmount = getData(iChannel0, WIND_AMOUNT_ADDR).x;\n            float previousDampingValue = getData(iChannel0, DAMPING_VALUE_ADDR).x;\n           \n            float dampingCoeff = computeDampingCoeff(mass, springRateCoeff, criticalDampingCoeff);\n            float tau = computeDampingTime(mass, dampingCoeff);\n            float w0 = computeOriginalOscillationFrequency(mass, springRateCoeff);\n            float w = computeOscillationFrequency(tau, w0);\n            \n            previousDampingValue = clamp(previousDampingValue + windAmount, -1.0, 1.0);\n\n            float dampingState = cos(timeMousePressed * w);\n            if(isDamping)\n            {\n                dampingState *= previousDampingValue * exp(-timeMousePressed / tau);\n            }\n            \n            fragColor = vec4(dampingState, 0.0, 0.0, 0.0); \n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec2 uv = vec2(0.0, 0.0);\nbool mousePressed = false;\nfloat timeMousePressed = 0.0;\nfloat timeMousePressedInterval = 2.0;\n\n\n// Damping Tree Model\nint nbTreeNodes = 6;\nfloat mass = 0.005;\nfloat springRateCoeff = 4.0;\nfloat criticalDampingCoeff = 0.1;\nfloat flexibility = 0.5;\nbool isDamping = true;\n    \n// Wind Model\nfloat nbSecondsToFullyChargeWind = 0.5;\nfloat nbSecondsToFullyDischargeWind = 2.0;\n\n\n// Transforms a value from interval A to interval B\nfloat remap(float value, float inMin, float inMax, float outMin, float outMax)\n{\n    return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\n// Calculates the damping coefficient from the mass, the spring rate coefficient and the damping criticality coefficient\nfloat computeDampingCoeff(float mass, float springRateConstant, float criticalDampingCoeff)\n{\n    return 2.0 * criticalDampingCoeff * mass * sqrt(springRateConstant / mass);\n}\n\n\n// Calculates the damping time from the mass and the damping coefficient\nfloat computeDampingTime(float mass, float dampingCoeff)\n{\n    return 2.0 * mass / dampingCoeff;\n}\n\n// Calculates the original oscillation frequency from the mass and spring rate coefficient\nfloat computeOriginalOscillationFrequency(float mass, float springRateCoeff)\n{\n    return sqrt(springRateCoeff / mass);\n}\n\n// Calculates the oscillation frequency from the original oscillation frequency\nfloat computeOscillationFrequency(float tau, float w0)\n{\n    return w0 * sqrt(1.0 - (1.0 / (pow(w0, 2.0) * pow(tau, 2.0))));\n}\n\n\n// Simplex 2D noise\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat simplex_noise(vec2 v)\n{\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n//\tClassic Perlin 2D Noise by Stefan Gustavson\nvec2 fade(vec2 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\nvec4 permute(vec4 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat perlin_noise(vec2 P)\n{\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n    vec4 i = permute(permute(ix) + iy);\n    vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n    vec4 gy = abs(gx) - 0.5;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n    vec2 g00 = vec2(gx.x,gy.x);\n    vec2 g10 = vec2(gx.y,gy.y);\n    vec2 g01 = vec2(gx.z,gy.z);\n    vec2 g11 = vec2(gx.w,gy.w);\n    vec4 norm = 1.79284291400159 - 0.85373472095314 * vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n    vec2 fade_xy = fade(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n}\n\n\nfloat distanceTo(vec2 a, vec2 b)\n{\n    return sqrt(pow(a.x - b.x, 2.0)+ pow(a.y - b.y, 2.0));\n}\n\nfloat plot(float y)\n{\n    float thickness = 0.02;\n    return smoothstep(y - thickness / 2.0, y, 2.0 * (uv.y - 0.5)) - smoothstep(y, y + thickness / 2.0, 2.0 * (uv.y - 0.5));\n}\n\nfloat drawLine(in vec2 a, in vec2 b, float thickness)\n{\n    // We offset A and B points by vec2(0.0, 0.5),in order to let them display on center of the screen in X axis\n    // Project p onto the line ab, then return the distance from p` to p\n    \n\t// Use a as 'origin'\n    vec2 origin = a + vec2(0.5, 0.0);    \n    vec2 p2 = uv - origin;\n    vec2 b2 = b + vec2(0.5, 0.0) - origin;\n\n    // Compute the dot product of vectors and divide to get the ratio\n\tfloat lineRatio = dot(p2, b2) / dot(b2, b2);\n\n    // Clamp the ratio between 0.0 and 1.0\n    lineRatio = clamp(lineRatio, 0., 1.);\n\n    // Nearest point on AB\n    vec2 pointOnLine = b2*lineRatio;\n\n    // compute distance from line to point\n    float dist = length(p2 - pointOnLine);\n\n    return 1.0 - step(thickness / 100.0, dist);\n}\n\nfloat drawCircle(vec2 p, float d)\n{\n    return (distance(p + vec2(0.5, 0.0), uv) <= d) ? 1. : 0.;\n}\n\nfloat square_wave(float freq, float ampMin, float ampMax, float time)\n{\n    return 0.5 * sin(freq - freq * time) + 0.5 > 0.5 ? ampMax : ampMin;\n}\n\nfloat leftArrow(int nbArrowsX, int nbArrowsY)\n{\n    vec2 divNum = vec2(float(nbArrowsX), float(nbArrowsY));\n    vec2 div = fract(uv * divNum);\n    \n    float xx = div.x;\n    float xx2 = div.x - 0.5;\n    \n    div.y *= 2.0;\n    float up = smoothstep(0.0, 0.0025, xx - (div.y - 1.0));\n    float down = smoothstep(0.0025, 0.0, 1.0 - xx - div.y);\n    \n   \tfloat up2 = smoothstep(0.0, 0.0025, xx2 - (div.y - 1.0));\n    float down2 = smoothstep(0.0025, 0.0, 1.0 - xx2 - div.y);\n    \n    float o = clamp(up * down, 0.0, 1.0);\n    float o2 = clamp(up2 * down2, 0.0, 1.0);\n    \n\treturn o - o2;\n}\n\nfloat rightArrow(int nbArrowsX, int nbArrowsY)\n{\n    vec2 divNum = vec2(float(nbArrowsX), float(nbArrowsY));\n    vec2 div = fract(uv * divNum);\n    float xx = div.x;\n    float xx2 = div.x + 0.5;\n    \n    div.y *= 2.0;\n    float up = smoothstep(0.0, 0.0025, 1.0 - xx - (div.y - 1.0));\n    float down = smoothstep(0.0, 0.0025, div.y - xx);\n    \n   \tfloat up2 = smoothstep(0.0, 0.0025, 1.0 - xx2 - (div.y - 1.0));\n    float down2 = smoothstep(0.0, 0.0025, div.y - xx2);\n    \n    float o = clamp(up * down, 0.0, 1.0);\n    float o2 = clamp(up2 * down2, 0.0, 1.0);\n    \n\treturn o - o2;\n}\n\n\n\n// Addresses:\n// The addresses must be ivec2 values containing pixel coordinates to save.\n// The coordinates aren't normalized and their range is (0, 0) to (iResolution.x, iResolution.y).\nconst ivec2 DAMPING_VALUE_ADDR = ivec2(0, 0);\nconst ivec2 TIME_PRESSED_ADDR = ivec2(1, 0);\nconst ivec2 WIND_AMOUNT_ADDR = ivec2(2, 0);\n\n\n// Get Data stored in buffer (iChannel) at specific address (ivec2)\n#define getData(buf, addr) texelFetch(buf, addr, 0)\n\n// Check if Data is the good one (addr : ivec2) regarding fragmentPosition (buf_pos : vec2)\n#define isData(buf_pos, addr) ivec2(buf_pos) == addr\n\n// The data is stored using fragColor","name":"Common","description":"","type":"common"}]}