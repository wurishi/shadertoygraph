{"ver":"0.1","info":{"id":"4tlyD8","date":"1504630133","viewed":2391,"name":"Transverse Chromatic Aberration","username":"FlexMonkey","description":"Transverse Chromatic Aberration\n\nThis is essentially a simple radial blur, but with different blur radii per color channel. \n\nLooks like Safari doesn't support matrices - works fine in Chrome :) ","likes":50,"published":1,"flags":32,"usePreview":0,"tags":["2d","aberration","transversechromaticaberration","lensfx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tTransverse Chromatic Aberration\n\n\tBased on https://github.com/FlexMonkey/Filterpedia/blob/7a0d4a7070894eb77b9d1831f689f9d8765c12ca/Filterpedia/customFilters/TransverseChromaticAberration.swift\n\n\tSimon Gladman | http://flexmonkey.blogspot.co.uk | September 2017\n*/\n\nint sampleCount = 50;\nfloat blur = 0.25; \nfloat falloff = 3.0; \n\n// use iChannel0 for video, iChannel1 for test grid\n#define INPUT iChannel0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 destCoord = fragCoord.xy / iResolution.xy;\n\n    vec2 direction = normalize(destCoord - 0.5); \n    vec2 velocity = direction * blur * pow(length(destCoord - 0.5), falloff);\n\tfloat inverseSampleCount = 1.0 / float(sampleCount); \n    \n    mat3x2 increments = mat3x2(velocity * 1.0 * inverseSampleCount,\n                               velocity * 2.0 * inverseSampleCount,\n                               velocity * 4.0 * inverseSampleCount);\n\n    vec3 accumulator = vec3(0);\n    mat3x2 offsets = mat3x2(0); \n    \n    for (int i = 0; i < sampleCount; i++) {\n        accumulator.r += texture(INPUT, destCoord + offsets[0]).r; \n        accumulator.g += texture(INPUT, destCoord + offsets[1]).g; \n        accumulator.b += texture(INPUT, destCoord + offsets[2]).b; \n        \n        offsets -= increments;\n    }\n\n\tfragColor = vec4(accumulator / float(sampleCount), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\tSimple grid for testing\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float foo = mod(fragCoord.x, 10.0) < 2.0 || mod(fragCoord.y, 10.0) < 2.0 ? 0.4 : 0.0;\n    foo += mod(fragCoord.x, 10.0) < 2.0 && mod(fragCoord.y, 10.0) < 2.0 ? 0.6 : 0.0;\n    \n    fragColor = vec4(foo , foo , foo, 1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}