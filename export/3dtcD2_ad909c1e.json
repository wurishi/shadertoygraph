{"ver":"0.1","info":{"id":"3dtcD2","date":"1660642054","viewed":163,"name":"Bubble Bead Circuit","username":"resontone","description":"Bubble Bead Circuit","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["bubblebeadcircuit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265359;\nconst float TWO_PI = 6.2831853071795;\n\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 rotate(vec3 v, vec3 axis, float angle) {\n\tmat4 m = rotationMatrix(axis, angle);\n\treturn (m * vec4(v, 1.0)).xyz;\n}\n\n\n\nfloat snoise(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat snoise(float co){\n    return fract(sin(co) * 43758.5453);\n}\n\n\n//x,y = local coordinates\n//z = square id\n//w = zoom\nvec4 irregularGridXYID(vec2 uv, float squareSize, int maxZoomLevel, float splitLikelihood)\n{\n    float zoom = 1./squareSize;\n    vec2 uv_irregular_grid; \n    vec2 uv_irregular_grid_id;\n    \n    bool endFlag = false;\n    int zoomIndex = 0;\n    float zoomFactor = 1.;\n    for(zoomIndex = 0; zoomIndex < maxZoomLevel && !endFlag; zoomIndex++)\n    {\n        uv_irregular_grid = fract(uv*zoom*zoomFactor) - 0.5;\n    \tuv_irregular_grid_id = floor(uv*zoom*zoomFactor);\n        \n        endFlag = snoise(uv_irregular_grid_id) > splitLikelihood;\n        \n        zoomFactor *= 2.;\n        \n    }\n\treturn vec4(uv_irregular_grid, length(uv_irregular_grid_id)/zoom, zoomFactor);\n}\n\nfloat circle(vec2 uv, float diam, float blur)\n{\n    return(1. - smoothstep(diam-blur,diam+blur, length(uv) ));\n}\n\nfloat square(vec2 uv, float diam, float blur)\n{\n    float val = 1. - smoothstep(diam-blur,diam+blur, max(abs(uv.x), abs(uv.y)) );\n    //val *= 1. - smoothstep(diam-blur,diam+blur, abs(uv.y) );\n    \n    \n    return(val);\n}\n\nvec3 bubbleBeadCircuit(vec2 uv, float loopFrequency)\n{\n    float chromSplit = 0.;//1.5/100.;\n    float zoom = 0.0625;\n    \n    \n    //uv.x += iTime;\n\t\n\tvec4 grid_R = irregularGridXYID(uv, zoom, 4, 0.75);\n    float grid_R_id = grid_R.z;\n    \n    vec4 grid_G = irregularGridXYID(uv + chromSplit, zoom, 4, 0.75);\n    float grid_G_id = grid_G.z;\n    \n    vec4 grid_B = irregularGridXYID(uv - chromSplit, zoom, 4, 0.75);\n    float grid_B_id = grid_B.z;\n    \n    \n    float squareTimeFreqR = (floor(snoise(grid_R.z))+1.)*loopFrequency;\n    //frequency must be a whole number multiple of loopFrequency\n    \n    \n    float squareTimePhaseR = snoise(grid_R.z+10.)*TWO_PI; //between 0 and 2 hz\n    float squareSizeR =  0.+abs(0.5*sin(TWO_PI*iTime*squareTimeFreqR + squareTimePhaseR));\n    \n    \n    float squareTimeFreqG = (floor(snoise(grid_G.z))+1.)*loopFrequency;\n    \n    \n    float squareTimePhaseG = snoise(grid_G.z+10.)*TWO_PI; //between 0 and 2 hz\n    float squareSizeG =  0.+abs(0.125*tan(TWO_PI*iTime*squareTimeFreqG + squareTimePhaseG));\n    \n    float squareTimeFreqB = (floor(snoise(grid_B.z))+1.)*loopFrequency;\n    \n    \n    float squareTimePhaseB = snoise(grid_B.z+10.)*TWO_PI; //between 0 and 2 hz\n    float squareSizeB =  0.5+(0.5*cos(TWO_PI*iTime*squareTimeFreqB + squareTimePhaseB));\n    \n    \n    \n    // Time varying pixel color\n    vec3 col = vec3(circle(grid_R.xy, 0.4 *squareSizeR, 0.0125 * grid_R.w),\n                   circle(grid_G.xy, 0.4 *squareSizeG, 0.0125 * grid_G.w),\n                   circle(grid_B.xy, 0.4 *squareSizeB, 0.0125 * grid_B.w)) ;\n\n    \n   \t\n    float setting = 1.15;//also try 2.45\n\tcol = rotate(col, vec3(4.,0.,8.), 0.25*(setting)*TWO_PI); \n    col = mix(col, vec3(col.g), 0.5);\n    col.rb = mix(col.rb, col.gg, 1.);\n    col *= 2.;\n    \n    return(clamp(col, 0., 1.));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    \n    vec3 col = bubbleBeadCircuit(uv, 1./3.);\n    col += vec3(0.25, 0., 0.2);\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}