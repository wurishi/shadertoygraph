{"ver":"0.1","info":{"id":"mdjczt","date":"1688067224","viewed":122,"name":"Mandelbrot set Draft","username":"Elyades","description":"Quick draft of the Mandelbrot Set","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["mandelbrotset"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 mandelbrotIteration(vec2 uv, vec2 c)\n{    \n    vec2 result = vec2( pow(uv.x,2.0) - pow(uv.y,2.0) , 2.0*uv.x*uv.y ) - vec2(uv.x*uv.x*uv.x - 3.0*uv.x*uv.y*uv.y, 3.0*uv.x*uv.x*uv.y - uv.y*uv.y*uv.y)+ c;\n    return result;\n}\n\n\nvec3 palette1( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.0,0.10,0.20);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvec3 palette2( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.6,0.5);\n    vec3 b = vec3(0.5,0.4,0.25+0.25*cos(iTime/3.0));\n    vec3 c = vec3(1.0,1.0,1.2);\n    vec3 d = vec3(0.1,0.1,0.4);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvec3 thirdDegreeProcessing(vec3 color)\n{\n    float a = 8.92587;\n    float b = -13.75;\n    float c = 5.82143;\n    return vec3(a*color*color*color - b*color*color + c*color );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //Offset\n    vec2 offset = vec2(0);\n    uv -= 0.5;\n    \n    \n    //Scale\n    uv *= 2.4;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //Choosing the Zoom\n    //vec2 zoomPoint = vec2(0.745668,-0.09999);\n    vec2 zoomPoint = vec2(-0.5,0.08);\n    //uv += zoomPoint;\n    \n    //Zoom\n    \n    //float zoomAmount = min(1.0,3.0/pow(min(max(iTime-5.0,1.0),32.0),3.0));\n    float zoomAmount = min(3.0/pow(max(iTime-5.0,1.0),3.0),1.0);\n    uv = uv*zoomAmount;\n    uv += zoomPoint;\n    \n    //Determining the interior of the set\n    vec2 c = uv;\n    \n    float tol = pow(10.0,-8.0);\n    float DistanceToPrevious = 1.0;\n    float currentModulus = length(uv);\n    vec2 previousIteration;\n    int iterationAmount;\n    int testAmount = 1000;\n    \n    vec2 dummyuv = uv;\n    \n    for (iterationAmount = 0; iterationAmount < testAmount; iterationAmount++)\n    {\n        previousIteration = dummyuv;\n        dummyuv = mandelbrotIteration(dummyuv,c);\n        currentModulus = length(dummyuv);\n        DistanceToPrevious = length(dummyuv - previousIteration);\n        \n        if(DistanceToPrevious < tol){break;}\n        if(currentModulus > 4.0)\n        {\n            break;\n        } \n    }\n\n    //Coloring the interior of the set\n    \n    if (currentModulus < 4.0)\n    {\n        \n        fragColor = vec4(0.0,0.0,0.0,1.0);\n    }\n    //Coloring the exterior of the set\n    \n    else\n    {\n        \n        if(iterationAmount <= 5)\n        {\n            float intensity = 1.0 - float(iterationAmount/10);\n            fragColor = vec4(intensity,intensity*0.9,intensity*0.2,1.0);\n        }\n        \n        else\n        {\n            \n            float period = 1.0;\n            float index = float(iterationAmount)/period;\n\n            vec3 color = (palette1(1.0-index)*index + palette2(1.0-index)*(1.0-index));\n            \n            //color = vec3 (palette(cos(color.y)));\n            \n            fragColor = vec4(color,1.0);\n            //fragColor = 1.0 - 2.0*fragColor + sin(1.5*fragColor);\n            //fragColor = (cos(sqrt(fragColor))-0.54)/0.46;\n            //fragColor.xyz = thirdDegreeProcessing(fragColor.xyz);\n            //fragColor = 0.05+0.95*sin(fragColor);\n            //fragColor.xyz = palette(fragColor.z+fragColor.x+fragColor.y);\n     }\n        \n        \n    }\n\n    \n}","name":"Image","description":"","type":"image"}]}