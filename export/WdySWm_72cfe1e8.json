{"ver":"0.1","info":{"id":"WdySWm","date":"1574129198","viewed":71,"name":"Here comes the balls","username":"RegularTetragon","description":"Sphere field","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define close 0.001\n#define PI 3.14159265\n#define PHI 2. * PI\n\nvec3 spacemap(vec3 point) {\n    \n    float scale = 10. * (sin(iTime)+1.2) ;//* (sin(iTime) + 1.);\n    point += vec3(iTime*scale, 0, 0);\n\treturn mod(point, 2.*scale) - scale;\n}\n\nfloat sdRoundBox( vec3 p )\n{\n  vec3 b = vec3(3,1,1.5);\n  float r = 1.;\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat sdSphere(vec3 p) {\n    return length(p) - 2.;\n}\n\nfloat dist(vec3 point) {\n\t//return sdLink(point, .25,1., .4);\n    return sdSphere(point);\n}\n\nvec3 norm(vec3 point) {\n\treturn normalize(point);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 aspect = iResolution.xy / iResolution.y;\n    vec2 uv = ((fragCoord/iResolution.xy)*2. - 1.)*aspect;\n\t\n    vec3 lookat = vec3(0,0,0);\n    vec3 light = vec3(cos(iTime), 2, sin(iTime));\n    vec3 ambient = vec3(.5, .5, .5);\n    vec3 cam = vec3(\n        3. * cos(iMouse.x / iResolution.x * PHI),\n        -10. * ((iMouse.y / (iResolution.y)) - .5),\n        3. * sin(iMouse.x/iResolution.x * PHI)\n     );\n    \n    float planedist = 0.5;\n    \n    vec3 worldup = vec3(0,1.,0);\n    vec3 forward = normalize(lookat - cam);\n    vec3 right = normalize(cross(worldup, forward));\n    vec3 up = normalize(cross(forward, right));\n    \n    \n    vec3 ray = normalize(uv.x * right + uv.y * up + forward * planedist);\n    \n    // Time varying pixel color\n    vec3 col = vec3(0.,.75 - ray.y * 3.,1. + ray.y);\n    \n    float surfaceDistance, cameraDistance;\n    vec3 point;\n    cameraDistance = 0.;\n    \n    \n    for (int i = 0; i < 150; i++) {\n        point = spacemap(cam + cameraDistance * ray);\n        surfaceDistance = dist(point);\n        if (surfaceDistance < close) break;\n        cameraDistance = cameraDistance + surfaceDistance;\n    }\n    //point = spacemap(point);\n    \n    if (surfaceDistance < close) {\n        vec2 surfuv = vec2(atan(point.z, point.x), point.y);\n    \tcol = texture(iChannel0, surfuv).xyz;\n        col *= (dot(norm(point), normalize(light)));\n        col += ambient;\n        \n    }\n    // Output to screen\n    fragColor = vec4(col,surfaceDistance);\n}","name":"Image","description":"","type":"image"}]}