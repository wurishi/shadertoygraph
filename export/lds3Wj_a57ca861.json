{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Hazel Quantock 2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// Divide the view into multiple viewports\n// Set global variables to replace iResolution and fragCoord for the local viewport\n// Returns index of which panel is being drawn for this pixel\n// in the range [0,numPanels.x*numPanels.y)\nvec2 view_Resolution;\nvec2 view_FragCoord;\nint SideMenu( ivec2 numPanels, in vec2 fragCoord, out vec4 fragColor )\n{\n\t// arrange so that the main view and the side views have the same aspect ratio\n\tvec2 dims = vec2(\n\t\t\t\t\t\tiResolution.x/float(numPanels.x+numPanels.y), // main view is sv.y times bigger on both axes!\n\t\t\t\t\t\tiResolution.y/float(numPanels.y)\n\t\t\t\t\t\t);\n\n\n\t// which one is selected?\n\tivec2 viewIndex = ivec2(floor(iMouse.xy/dims));\n\n\tint selectedPanel = 0;\n\tif ( viewIndex.x < numPanels.x )\n\t{\n\t\tselectedPanel = viewIndex.y+viewIndex.x*numPanels.y;\n\t}\n\t\n\n\t// figure out which one we're drawing\n\tviewIndex = ivec2(floor(fragCoord.xy/dims));\n\n\tint index;\n\tvec4 viewport;\n\tif ( viewIndex.x < numPanels.x )\n\t{\n\t\tviewport.xy = vec2(viewIndex)*dims;\n\t\tviewport.zw = dims;\n\t\tindex = viewIndex.y+viewIndex.x*numPanels.y;\n\t}\n\telse\n\t{\n\t\t// main view, determined by where the last click was\n\t\tviewport.x = float(numPanels.x)*dims.x;\n\t\tviewport.y = 0.0;\n\t\tviewport.zw = dims*float(numPanels.y);\n\t\tindex = selectedPanel;\n\t}\n\t\n\t\n\t// highlight currently selected\n\tif ( index == selectedPanel && viewIndex.x < numPanels.x &&\n\t\t( fragCoord.x-viewport.x < 2.0 || viewport.x+viewport.z-fragCoord.x < 2.0 ||\n\t\t  fragCoord.y-viewport.y < 2.0 || viewport.y+viewport.w-fragCoord.y < 2.0 ) )\n\t{\n\t\tfragColor = vec4(1,1,0,1);\n\t\treturn -1;\n\t}\n\t\n\t// compute viewport-relative coordinates\n\tview_FragCoord = fragCoord.xy - viewport.xy;\n\tview_Resolution = viewport.zw;\n\t\n\treturn index;\n}\n\n\n// --\n\nconst float tau = 6.28318530717958647692;\n\n// Gamma correction\n#define GAMMA (2.2)\n\nvec3 ToLinear( in vec3 col )\n{\n\t// simulate a monitor, converting colour values into light values\n\treturn pow( col, vec3(GAMMA) );\n}\n\nvec3 ToGamma( in vec3 col )\n{\n\t// convert back into colour values, so the correct light will come out of the monitor\n\treturn pow( col, vec3(1.0/GAMMA) );\n}\n\nvec2 Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n//\tvec3 f2 = f*f; f = f*f2*(10.0-15.0*f+6.0*f2);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\n#if (1)\n\tvec4 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 );\n#else\n\t// on some hardware interpolation lacks precision\n\tvec4 rg = mix( mix(\n\t\t\t\ttexture( iChannel0, (floor(uv)+0.5)/256.0, -100.0 ),\n\t\t\t\ttexture( iChannel0, (floor(uv)+vec2(1,0)+0.5)/256.0, -100.0 ),\n\t\t\t\tfract(uv.x) ),\n\t\t\t\t  mix(\n\t\t\t\ttexture( iChannel0, (floor(uv)+vec2(0,1)+0.5)/256.0, -100.0 ),\n\t\t\t\ttexture( iChannel0, (floor(uv)+1.5)/256.0, -100.0 ),\n\t\t\t\tfract(uv.x) ),\n\t\t\t\tfract(uv.y) );\n#endif\t\t\t  \n\n\treturn mix( rg.yw, rg.xz, f.z );\n}\n\n\n// Set up a camera looking at the scene.\n// origin - camera is positioned relative to, and looking at, this point\n// distance - how far camera is from origin\n// rotation - about x & y axes, by left-hand screw rule, relative to camera looking along +z\n// zoom - the relative length of the lens\nvec3 localRay;\nvoid CamPolar( out vec3 pos, out vec3 ray, in vec3 origin, in vec2 rotation, in float distance, in float zoom )\n{\n\t// get rotation coefficients\n\tvec2 c = vec2(cos(rotation.x),cos(rotation.y));\n\tvec4 s;\n\ts.xy = vec2(sin(rotation.x),sin(rotation.y)); // worth testing if this is faster as sin or sqrt(1.0-cos);\n\ts.zw = -s.xy;\n\n\t// ray in view space\n\tray.xy = view_FragCoord.xy - view_Resolution.xy*.5;\n\tray.z = view_Resolution.y*zoom;\n\tray = normalize(ray);\n\tlocalRay = ray;\n\t\n\t// rotate ray\n\tray.yz = ray.yz*c.xx + ray.zy*s.zx;\n\tray.xz = ray.xz*c.yy + ray.zx*s.yw;\n\t\n\t// position camera\n\tpos = origin - distance*vec3(c.x*s.y,s.z,c.x*c.y);\n}\n\nfloat DistanceField( vec3 pos );\n\nvec3 Normal( vec3 pos )\n{\n\tconst vec2 delta = vec2(0,.001);\n\tvec3 grad;\n\tgrad.x = DistanceField( pos+delta.yxx )-DistanceField( pos-delta.yxx );\n\tgrad.y = DistanceField( pos+delta.xyx )-DistanceField( pos-delta.xyx );\n\tgrad.z = DistanceField( pos+delta.xxy )-DistanceField( pos-delta.xxy );\n\treturn normalize(grad);\n}\n\nfloat Trace( vec3 pos, vec3 ray )\n{\n\tconst vec2 interval = vec2(0.0,10.0); // could do ray traced bounding shape to get tighter region\n\t\n\tfloat h = 1.0;\n\tfloat t = interval.x;\n\tfor ( int i=0; i < 100; i++ )\n\t{\n\t\tif ( t > interval.y || h < .01 )\n\t\t\tbreak;\n\t\th = DistanceField( pos+ray*t );\n\t\tt += h;\n\t}\n\t\n\tif ( t > interval.y || t < interval.x || h > .1 )\n\t\treturn 0.0;\n\t\n\treturn t;\n}\n\n\n\n// --- scene ---\n\nint type;\n\nfloat DistanceField( vec3 pos )\n{\n\tif ( type >= 5 )\n\t{\n\t\tvec3 a = max( abs(pos)-.354, vec3(0) );\n\t\treturn (dot( a, vec3(1) )-.5)/sqrt(3.0);\n\t}\n\telse\n\t{\n\t\t//return length(pos)-1.0;// + Noise(sqrt(pow(pos,vec3(2.0))+1.0)*10.0).x*.1;\n\t\t\n\t\tvec4 p;\n\t\tvec2 d = vec2(-1,1)/sqrt(3.0);\n\t\tp.x = dot(pos,d.yyy);\n\t\tp.y = dot(pos,d.yxx);\n\t\tp.z = dot(pos,d.xyx);\n\t\tp.w = dot(pos,d.xxy);\n\t\t\n\t\t//p += cos(p*15.0+iTime)*.1;\n\t\t//p += cos(p.yzwx*tau*2.0+iTime)*.1;\n\t\t\n\t\t//val += dot(cos(p*8.0+cos(p.yzwx*12.0)+sin(p.yzwx*12.0)+iTime)*.1,vec4(1,1,1,1));\n\t\t\n\t\tfloat time = iTime*.3;\n\t\ttime += sin(time);\n\t\t\n\t\tp.x += smoothstep(.0,1.,p.x)*sin(length(p.yzw)*17.0+time)*.1;\n\t\tp.y += smoothstep(.0,1.,p.y)*sin(length(p.zwx)*17.0+time)*.1;\n\t\tp.z += smoothstep(.0,1.,p.z)*sin(length(p.wxy)*17.0+time)*.1;\n\t\tp.w += smoothstep(.0,1.,p.w)*sin(length(p.xyz)*17.0+time)*.1;\n\t\t\n\t\tfloat val = length(p)-1.0;\n\t\t\n\t\t/*p.yzwx += cos(p*tau*1.0+iTime)*.1;\n\t\tp.zwxy += cos(p*tau*1.0+iTime+tau/3.0)*.1;\n\t\tp.wxyz += cos(p*tau*1.0+iTime+tau*2.0/3.0)*.1;*/\n\t\t\n\t\treturn val*.5;\n\t}\n}\n\n\nconst vec3 ambient = vec3(0);\nconst vec3 lightCol0 = vec3(1,.9,.8);\nconst vec3 lightCol1 = vec3(.5,.7,1);\nconst vec3 lightCol2 = vec3(.1,.05,.02);\nconst vec3 lightDir0 = vec3(-1,3,-2)*0.26726; //normalize(vec3(1,2,3)) silly compiler\nconst vec3 lightDir1 = vec3(0,1,0);\nconst vec3 lightDir2 = vec3(0,-1,0);\nvec3 Lighting( vec3 p, vec3 n )\n{\n\t// build a spherical harmonic matrix using directional lights\n\tconst vec3 sh0 = lightCol1*lightDir1.x+lightCol2*lightDir2.x;\n\tconst vec3 sh1 = lightCol1*lightDir1.y+lightCol2*lightDir2.y;\n\tconst vec3 sh2 = lightCol1*lightDir1.z+lightCol2*lightDir2.z;\n\tconst vec3 sh3 = lightCol1+lightCol2+ambient;\n\n\treturn .5*(\n\t\t\t\tn.x*sh0 +\n\t\t\t\tn.y*sh1 +\n\t\t\t\tn.z*sh2 +\n\t\t\t\tsh3)\n\t\t\t+ pow(max(.0,dot(n,lightDir0)),1.3)*lightCol0;\n}\n\nvec3 Sky( vec3 ray )\n{\n\t//return mix( vec3(1.05), vec3(0,.3,.7), abs(ray.y) );\n\treturn mix( vec3(.1,.05,.02), 1.5*pow( vec3( .01, .1, .5 ), vec3(abs(ray.y)) ), smoothstep( -.1, .1, ray.y ) );\n}\n\nvec4 Albedo( vec3 pos, vec3 normal )\n{\n\tint pattern = type;\n\tif ( pattern >= 5 ) pattern -= 5;\n\t\n\tif ( pattern == 0 )\n\t{\n\t\tvec3 p = pos;\n\t\tp.yz = p.yz*vec2(.5,sqrt(3.0)*.5)+p.zy*vec2(sqrt(3.0)*.5,-.5);\n\t\tp *= 32.0*vec3(1,2,1);\n\t\tfloat f = abs(Noise(p)*2.0-1.0).x; p *= .5;\n\t\tf = mix( f, abs(Noise(p)*2.0-1.0).x, .5 ); p *= .5;\n\t\tf = mix( f, abs(Noise(p)*2.0-1.0).x, .5 ); p *= .5;\n\t\tf = mix( f, abs(Noise(p)*2.0-1.0).x, .5 ); p *= .5;\n\t\tf = mix( f, abs(Noise(p)*2.0-1.0).x, .5 ); p *= .5;\n\t\t\n\t\tvec3 col = mix( vec3(1), vec3(0), pow(1.0-f,12.0) );\n\t\t\n\t\treturn vec4( col, .01);\n\t}\n\t\n\tif ( pattern == 1 )\n\t\treturn vec4(1,0,0,.01);\n\t\n\tif ( pattern == 2 )\n\t\treturn vec4(0,.2,0,.1);\n\t\n\tif ( pattern == 3 )\n\t{\n\t\tvec3 p = pos;\n\t\tp.yz = p.yz*vec2(.5,sqrt(3.0)*.5)+p.zy*vec2(sqrt(3.0)*.5,-.5);\n\t\tp *= 50.0;\n\t\tfloat f =   pow(Noise(p).x*2.0-1.0,2.0); p *= .5;\n\t\tf = mix( f, pow(Noise(p).x*2.0-1.0,2.0), .5 ); p *= .5;\n\t\tf = mix( f, pow(Noise(p).x*2.0-1.0,2.0), .5 ); p *= .5;\n\t\tf = mix( f, pow(Noise(p).x*2.0-1.0,2.0), .5 ); p *= .5;\n\t\tf = mix( f, pow(Noise(p).x*2.0-1.0,2.0), .5 ); p *= .5;\n\t\tf = sqrt(f);\n\t\t\n\t\tvec3 col = mix( vec3(.8-f*.5), vec3(0,.1,0)+f*vec3(.15,.15,.05), smoothstep( .6,.7, f+normal.y ) );\n\t\t\n\t\treturn vec4( col, 0 );\n\t}\n\t\n\treturn vec4(vec3(.01),.01);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 oFragColor;\n\ttype = SideMenu( ivec2(2,5), fragCoord, oFragColor );\n\tif ( type < 0 )\n\t\treturn; // menu rendering, e.g. border colours\n\t\n\tvec3 pos, ray;\n\tCamPolar( pos, ray, vec3(0), vec2(.2*sin(iTime*.3)+.2,iTime*.1), 3.0, 1.0 );\n\t\n\tvec3 col = Sky(ray);\n\n\tfloat t = Trace( pos, ray );\n\tpos += t*ray;\n\t\n\tif ( t > 0.0 )\n\t{\n\t\tvec3 normal = Normal(pos);\n\t\tvec4 albedo = Albedo(pos, normal);\n\t\tcol = albedo.xyz*Lighting(pos, normal);\n\n\t\t// rim lighting/vague specular\n\t\tvec3 reflectedRay = reflect(ray,normal);\n\t\tvec3 reflection = Sky(reflectedRay);\n\t\t//reflection += pow(Lighting(pos,reflectedRay),vec3(4.0))*0.0;\n\t\tvec3 h = normalize( lightDir0-ray );\n\n\t\treflection += pow( max(dot(h,normal),.0), 3000.0 ) * 3000.0/32.0;\n\n\t\tfloat fresnel = mix( albedo.w, min(1.0,albedo.w/.01), pow(1.0-abs(dot(ray,normal)),5.0) );\n\t\tcol = mix( col, reflection, fresnel );\n\t}\n\t\n\t// vignetting\n\tcol *= smoothstep( .4, .95, localRay.z );\n\n\tfragColor = vec4(ToGamma(col),1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lds3Wj","date":"1379933968","viewed":1914,"name":"Material Menu","username":"TekF","description":"The SideMenu function handles the menu, see comment for how to use it.\nAnnoyingly you have to drag to select things, if you don't move the mouse the click doesn't register.","likes":40,"published":1,"flags":0,"usePreview":0,"tags":["procedural","noise","menu","ui"],"hasliked":0,"parentid":"","parentname":""}}