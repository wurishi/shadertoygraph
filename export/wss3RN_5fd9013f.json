{"ver":"0.1","info":{"id":"wss3RN","date":"1545291271","viewed":240,"name":"Circle Loading ","username":"Tracy_zly","description":"The shader simulate the loading animation in the game of Detroit: Become Human.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["loading"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define INNER_WIDTH .24\n#define OUTER_WIDTH .3\n#define GAP_NUMBER 4.\n#define GAP_WIDTH .015\n#define PI 3.14159265\n#define SPEED 3.\n#define ANTIALIAS 0.01\n#define GAP_ARC_WIDTH 0.03\n\nvec2 GetIntersectantPointOfCircleAndLine(float k, vec2 pos, float r)\n{\n    float b = pos.y - k * pos.x;\n    float c = b * b - r * r;\n    float a = 1. + k * k;\n    float b1 = 2. * b * k;\n    float discriminant = sqrt(b1 * b1 - 4. * a * c);\n    float x1, y1, x2, y2;\n    x1 = (-b1 + discriminant) / (2. * a);\n    y1 = k * x1 + b;\n    x2 = (-b1 - discriminant) / (2. * a);\n    y2 = k * x2 + b;\n    vec2 pos1 = vec2(x1, y1);\n    if(dot(pos, pos1) < 0.0)\n    {\n        return vec2(x2, y2);\n    }\n    return pos1;\n}\n\nvec3 CalculateGap(vec2 pos, vec2 point1, vec2 point2, vec3 gapColor, vec3 color) \n{\n    if(dot(point1 - point2, pos - point2) < 0.)\n    {\n        return color;\n    }\n    float k = (point1.y - point2.y)/(point1.x - point2.x);\n    float b = point1.y - k * point1.x;\n    float d = abs(k * pos.x - pos.y + b) / sqrt(k * k + 1.);\n    float maxWidth = GAP_WIDTH / 2. + GAP_ARC_WIDTH;\n    if(d > maxWidth)\n    {\n        return color;\n    }\n    if(d < GAP_WIDTH / 2.)\n    {\n        return gapColor;\n    }\n    vec2 innerIntersectantPoint = GetIntersectantPointOfCircleAndLine(k, pos, INNER_WIDTH);\n    vec2 outerIntersectantPoint = GetIntersectantPointOfCircleAndLine(k, pos, OUTER_WIDTH);\n    float dis = length(outerIntersectantPoint - innerIntersectantPoint);\n    float f = length(pos - innerIntersectantPoint);\n    float width = dis / 2.0;\n    float v;\n    if(f > width)\n    {\n        v = f - width;\n    }\n    else\n    {\n        v = width - f;\n    }\n    float x = v / width / 1.2;\n    float newGapArcWidth = pow(x, 3.5) * GAP_ARC_WIDTH;\n    float newWidth = newGapArcWidth + GAP_WIDTH/2.;\n    float t = smoothstep(newWidth, newWidth + ANTIALIAS, d);\n    return mix(gapColor, color, t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n    float dist = length(uv);\n    vec3 backgroundColor = vec3(.9, .9, .9);\n    if(dist >= OUTER_WIDTH || dist <= INNER_WIDTH)\n    {\n        fragColor = vec4(backgroundColor, 1.);\n        return;\n    }\n    vec3 col = vec3(.3529, .4588, .5608);\n    float time = iTime;\n    float x,y = .0;\n    float gapCenter = (OUTER_WIDTH - INNER_WIDTH) / 2. + INNER_WIDTH;\n    for(float i = 0.0 ; i < GAP_NUMBER ; i++)\n    {\n        float angle = 2. * PI*i / GAP_NUMBER + time * (i + SPEED) / SPEED;\n\t\tx = gapCenter * cos(angle);\n\t\ty = gapCenter * sin(angle);\n        col = CalculateGap(uv, vec2(x, y), vec2(0.), vec3(1.), col) ;\n\t}\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}