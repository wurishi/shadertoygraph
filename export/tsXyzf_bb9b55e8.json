{"ver":"0.1","info":{"id":"tsXyzf","date":"1585232415","viewed":107,"name":"walking shadow","username":"tono","description":"I had a dream that only the shadow was walking when I slept twice.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["shade","walk"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FAR 195.\n#define M(x,y) mod(x,y) - y/2.\n#define RR(x) (x - .5) *2.\n\n#define ITR 128\n\nfloat dep,tt;\n\nfloat pi =acos(-1.);\nfloat pi2 = acos(-1.) * 2.;\n\nfloat owner = 0.;\n\nvec3 spos;\n\nfloat rsp(vec3 p, vec3 s,float r){return ( length(p / s) - r) * min(s.x,min(s.y,s.z));}\nvec2 rot(vec2 p,float a){return p * mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat bo( vec3 p, vec3 s ){p = abs(p) - s;return length(max(p,0.0)) + min(max(p.x,max(p.y,p.z)),0.0);}\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n                   dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nfloat noise(vec2 st) \n{\n    vec2 p = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f*f*(3.0-2.0*f);\n\n    vec2 v00 = random2(p+vec2(0,0));\n    vec2 v10 = random2(p+vec2(1,0));\n    vec2 v01 = random2(p+vec2(0,1));\n    vec2 v11 = random2(p+vec2(1,1));\n\n    return mix( mix( dot( v00, f - vec2(0,0) ), dot( v10, f - vec2(1,0) ), u.x ),\n                 mix( dot( v01, f - vec2(0,1) ), dot( v11, f - vec2(1,1) ), u.x ), \n                 u.y)+0.5;\n}\n\nfloat fbm (vec2 st) \n{\n    float f = 0.;\n    vec2 q = st/2.;\n    for(int i = 0 ;i < 4;i++){\n        f += noise(q)/pow(2.,float(i));\n        q = q * (2.00+float(i)/100.);\n    }\n\n    return f;\n}\n\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\n//https://www.shadertoy.com/view/XsX3zB\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n    /* 1. find current tetrahedron T and it's four vertices */\n    /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n    /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\n    /* calculate s and x */\n    vec3 s = floor(p + dot(p, vec3(F3,F3,F3)));\n    vec3 x = p - s + dot(s, vec3(G3,G3,G3));\n\n    /* calculate i1 and i2 */\n    vec3 e = step(vec3(0.,0.,0.), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\n    /* x1, x2, x3 */\n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n\n    /* 2. find four surflets and store them in d */\n    vec4 w, d;\n\n    /* calculate surflet weights */\n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n\n    /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n    w = max(0.6 - w, 0.0);\n\n    /* calculate surflet components */\n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n\n    /* multiply d by w^4 */\n    w *= w;\n    w *= w;\n    d *= w;\n\n    /* 3. return the sum of the four surflets */\n    return dot(d, vec4(52.0,52.0,52.0,52.0));\n}\n\nfloat smin(float d1, float d2, float k){\n    float h = exp(-k * d1) + exp(-k * d2);\n    return -log(h) / k;\n}\n\nvec3 rotmat(vec3 p,vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return p * mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n                    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n                    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c          );\n}\n\nfloat replim( float p, float s, float l )\n{\n    return p-s*clamp(floor(p/s + .5),-l,l);\n}\n\nfloat c(float x, float f)\n{\n    return x - (x - x * x) * -f;\n}\n\n\nfloat humanF(vec3 p,float s)\n{\n    vec3 fp = p;\n\tvec3 size = vec3(1.,7.5,1.7);\n    fp.xz = rot(fp.xz,sign(s) * fp.z/9.);\n    \n    float b = bo(p + vec3(0.,0.,.3),vec3(1.,10.5,.05));\n    float h = min(rsp(fp + vec3(0.,0.,-0.4),size,.5)\n                  ,rsp(p + vec3(0.,0.,.6),vec3(.7,7.5,.9),.5));\n    h = max(h,-b);\n    p.y -= abs( sin(clamp( p.z,-.2,1. ) * 16.)/30. );\n    b = bo(p + vec3(0.,-0.6,0.),vec3(1.8,0.5,1.8));\n    h = max(h ,-b);\n    return h;\n}\n\nfloat humanLL(vec3 p)\n{\n    p.x += 0.5;\n    float ttl = tt;\n    ttl += p.y/13.;\n    p.z -= (floor(ttl / pi2) + pow( fract(ttl / pi2),7.) )* pi2;\n    p.y += 2.5 + clamp(cos(tt + pi/7.),0.,1.);\n    float s = rsp(p - vec3(0.2,1.9,1.),vec3(.6,.5,1.5),.8);\n    p.z += 0.5;\n    float l = sdCappedCylinder(p,.4,1.9);\n    l = min(s,l);\n    return l;\n}\n\nfloat humanRL(vec3 p)\n{\n    p.x -= 0.5;\n    float ttl = tt;\n    ttl += p.y/13.;\n    p.z -= (floor(ttl / pi2 + .5) + pow( fract(ttl / pi2 + .5),7.) )* pi2 - pi;\n    p.y += 2.5 + clamp(sin(tt - pi/7.),0.,1.);\n    float s = rsp(p - vec3(0.2,1.9,1.),vec3(.6,.5,1.5),.8);\n    p.z += 0.5;\n    float l = sdCappedCylinder(p,.4,1.9);\n    l = min(s,l);\n    return l;\n}\n\nfloat human(vec3 p)\n{\n    vec3 pp = p ;\n    float s = sign(sin(p.z + pi/2.));\n    pp.z = replim(pp.z,pi,floor(tt/pi));\n    pp.x += sin(p.z)/5. + s/2.;\n    float f = humanF(pp,-s);\n    return f;\n}\n\nfloat hlegs(vec3 p)\n{\n     float leg = humanLL(p);\n    leg = min(humanRL(p),leg);\n    return leg;\n}\n\nfloat rf(vec3 p)\n{\n    p.y += 1.3;\n    vec3 size = vec3(.4,2.8,.5);\n    p.xz = rot(p.xz,pi/6.);\n    float s = 100.;\n    for(int i = 0; i< 3 ; i++)\n    {\n        s = smin(s, rsp(p,size,.5),16.);\n        s = smin(s,rsp(p - vec3(0.,.7,.4),vec3(1.8,3.8,7.9),.2 ),8.3);\n        p.z += 0.5;\n        p.xz = rot(p.xz,-pi/5.);\n        p.z -= 0.5;\n    }\n    return s;\n}\n\nfloat rr(vec3 p)\n{\n    vec3 pp = p ;\n    float s = sign(sin(p.z + pi/2.));\n    pp.z = replim(pp.z,pi,floor(tt/pi));\n    pp.x += sin(p.z)/5. + s/.8;\n    float f = rf(pp);\n    return f;\n}\n\nfloat rlegs(vec3 p)\n{\n     float leg = humanLL(p/vec3(1.9 - p.y/9.,1.5,1.) + vec3(.1,.0,-1.));\n    leg = min(humanRL(p/vec3(1.9 - p.y/9.,1.5,1.)+ vec3(-.38,.0,-1.)),leg);\n    return leg;\n}\n\nfloat map(vec3 p)\n{\n    float s = -p.y - ( fbm(p.xz/1.) - .8)/3.;\n    float hs = 100.;\n    float h = human(p);\n    float w = max( max(s,h) ,-h);\n\n    hs = max(s,-h);\n    hs = min(hs,w*.55);\n    \n    float rs = 100.;\n    float r = rr(p);\n    rs = max(s,-r);\n    \n    s = mix(hs,rs,owner);\n    \n    return s * .5;\n}\n\nfloat m(vec3 cp,vec3 rd)\n{\n    float dd = 0.;\n    \n    for(int i = 0; i< ITR;i++)\n    {\n        vec3 rp = rd * dd + cp;\n        float d = map(rp);\n        if(abs(d) < 0.00001 || dd > FAR){break;}\n        dd += d;\n    }\n    dep = dd;\n    if(dd > FAR){dd *= -1.;}\n    return dd ;\n}\n\nfloat shmap(vec3 p)\n{\n    p.y *= -1.;\n    float s = 100.;\n    float hs = 100.;\n    vec3 pp = p;\n    s = hlegs(pp);\n    pp -= vec3(0.,-7.,tt);\n    pp.xz = rot(pp.xz,pp.y + tt + sin(tt /2.413));\n    float b = bo(pp,vec3(2.5,2.,0.7));\n    hs = min(s,b);\n    \n    float rs = 100.;\n    s = rlegs(p);\n    p -= vec3(0.,-7.,tt);\n\n    p.x += sin(p.z/7. + tt/3.21);\n    float c = rsp(p + vec3(0.,-4.,19.9),vec3(1.5,.7,9.),1.8);\n  //  p.xz = rot(p.xz,p.y + tt + sin(tt /2.413));\n    c = min(c,rsp(p,vec3(1.9,2.5,1.7),1.8));\n    rs = min(s,c);\n    \n    s = mix(hs,rs,owner);\n    return s * .7;\n}\n\nfloat shm(vec3 cp,vec3 rd)\n{\n     float dd = 0.;\n    \n    for(int i = 0; i< ITR;i++)\n    {\n        vec3 rp = rd * dd + cp;\n        float d = shmap(rp);\n        if(abs(d) < 0.001 || dd > FAR){break;}\n        dd += d;\n    }\n    if(dd > FAR){dd *= -1.;}\n    return dd;\n}\n\nfloat moya(vec3 cp,vec3 rd)\n{\n    float o = 0.;\n    for(int i = 1; i < 8; i++)\n    {\n        vec3 p = cp  + rd * float(i) * .9 ;\n        if(map(p) < 0.01){break;}\n        o += simplex3d(p + tt/11.675) / ( float(i)+1. );\n    }\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 cp = vec3(.5,-18.9,-7.) ;\n    \n   // cp.xz = rot(cp.xz,(mouse.x - .5) * 4.);\n   // cp.yz = rot(cp.yz,(mouse.y) * 2.5);\n    vec3 cd;\n    vec3 target ;\n    float scene = mod(iTime,59.) + 30. ;\n    tt = scene * 4.34;\n    \n    vec3 fw = vec3(0.,0.,tt);\n   if(scene < 36.)\n    {//1\n        cp.xz = rot(cp.xz,4.5 );\n    \tcp.yz = rot(cp.yz,.8 );\n        cp.z += scene * 1.6; \n        target = vec3(.1,-0.5,6.6) ;\n        cd = normalize(target - cp);\n        cp += cd * -10.5; \n    }else if(scene < 48.)\n    {//2\n         cp = vec3(-.2,.9,-.5) ;\n        target = vec3(-0.13,.8,6.1);// + fw;\n    \t//cp += fw;\n        cd = normalize(target - cp);\n        cp += cd * 160.7;\n    }\n    else \n    if(scene < 68.)\n    {//walk main\n        cp.xz = rot(cp.xz,4.5);\n    \tcp.yz = rot(cp.yz,.8);\n        \n        cp = rotmat(cp,vec3(0.,1.,0.),scene/9.9 - .4);\n        target = vec3(.1,-.5,0.) + fw;\n    \tcp += fw;\n        cd = normalize(target - cp);\n        scene/=1.3;\n        owner = clamp( abs( floor(2.* sin(sin(scene * 1.35)+scene) /2.) ) ,0.,1.);\n    }\n    else if( scene < 73.)\n    {\n        cp.xz = rot(cp.xz,4.5);\n    \tcp.yz = rot(cp.yz,.8);\n        \n        cp = rotmat(cp,vec3(0.,1.,0.),-12.);\n        cp.z -= 0.;\n        target = vec3(.1,-.5,1.) ;\n        target.z += 68. * 4.34;\n    \tcp.z += 68. * 4.34;\n        cd = normalize(target - cp);\n        scene/=1.3;\n        owner = clamp( abs( floor(sin(scene/2.) + sin(scene/2.)) + sin(floor(scene/2.)))/2. ,0.,1.);\n    }\n    else if(scene < 89.)\n    {\n        cp.xz = rot(cp.xz,4.5);\n    \tcp.yz = rot(cp.yz,.8);\n        \n        cp = rotmat(cp,vec3(0.,1.,0.),-12.);\n        cp.z -= 68. ;\n        target = vec3(.1,-.5,1.) ;\n        target.z += 68. * 4.34;\n    \tcp.z += 68. * 4.34;\n        cd = normalize(target - cp);\n        scene/=1.3;\n        owner = clamp( abs( floor(sin(scene/2.) + sin(scene/2.)) + sin(floor(scene/2.)))/2. ,0.,1.);\n    }\n    \n    \n    vec3 cs = normalize(cross(vec3(0.,1.,0.),cd));\n    vec3 cu = normalize(cross(cs,cd));\n    \n    float fov = 2.5;\n    vec3 rd = normalize(p.x * cs + p.y * cu + cd * fov);\n    float d = m(cp,rd);\n    vec3 sun = normalize(vec3(0.2,.4,.8));\n    vec3 skycolor = vec3(.9,.9,.9) ;\n\tvec3 c = skycolor;\n   \n    \n    if(d > 0.)\n    {\n        spos = rd * dep + cp;\n        vec2 e = vec2(0.,0.01);\n        vec3 N = normalize(map(spos) - vec3(map(spos + e.xyy),map(spos + e.yxy) , map(spos + e.yyx)));\n        c = vec3(1.) ;\n        float sray = shm( (spos + N * .001) ,sun);\n        float shadow = step(sray,0.) * .4 + .6;\n        float diff = .1 + .8 * max( dot(sun,N),0.);\n        float skyc = max( dot(vec3(0.,1.,0.),N),0.);\n        float bouc = max( dot(vec3(0.,-1.,0.),N),0.);\n       // c = N;\n        c *= diff;\n        c *= shadow;\n        \n    }\n    c = mix(c,skycolor,1. - exp(-0.000003 * dep * dep * dep ));\n    c = mix(c,vec3(moya(cp,rd)*.2+.8),.3);\n    c = clamp(c,0.,1.);\n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]}