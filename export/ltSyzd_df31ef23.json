{"ver":"0.1","info":{"id":"ltSyzd","date":"1511008989","viewed":1283,"name":"peaceful post-apocalyptic","username":"zguerrero","description":"Wanted to try to make grass, it consist of a bunch of cone grids, rotated and distorded. It work better than i expected even if there are a lot of artefact due to the heavy distortion.","likes":67,"published":1,"flags":32,"usePreview":0,"tags":["ray","terrain","grass","marching","landscape","distance","field"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float sharpenAmount = 0.3f;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    //Sharpening using mipmap, recommended by FabriceNeyret2\n    vec4 t0 = texture(iChannel0, uv, 0.0);\n    vec4 t1 = textureLod(iChannel0, uv, 1.0);  \n    vec4 sharpened = t0*5.0 + t1*-4.0;\n    \n    vec2 vignet = smoothstep(vec2(1.5), vec2(0.0), abs(uv-0.5));\n    float v = vignet.x*vignet.y;\n    \n\tfragColor = pow(mix(t0, sharpened, sharpenAmount) * v, vec4(1.75));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Wanted to try to make grass, it consist of a bunch of cone grids, rotated and distorded. \n//It work better than i expected even if there are a lot of artefact due to the heavy distortion.\n//The main trick used to make it look ok is the normal sampling for the grass,\n//gass normals use the underlying terrain distance field, that make it look smooth and unified,\n//and hide the cone shape of the grass.\n\nconst float epsilon = 0.01;\nconst float pi = 3.14159265359;\n\n#define LIGHT normalize(vec3(0.0, 0.5, 1.0))\nconst vec3 color0 = vec3(1.0, 0.5, 0.5);\nconst vec3 color1 = vec3(0.1, 0.1, 0.4);\nconst vec3 color2 = vec3(0.9, 0.4, 0.3);\nconst vec3 lightColor = vec3(0.4, 0.4, 0.3);\n\nconst float height = 0.25;\nconst float heightvar = 1.0;\nconst float density = 0.5;\nconst float thickness = 0.1;\n\nconst mat2 rot1 = mat2(0.99500416527,0.0998334166,-0.0998334166,0.99500416527);\nconst mat2 rot2 = mat2(0.98006657784,0.19866933079,-0.19866933079,0.98006657784);\nconst mat2 rot3 = mat2(0.95533648912,0.29552020666,-0.29552020666,0.95533648912);\nconst mat2 rot4 = mat2(0.921060994,0.3894183423,-0.3894183423,0.921060994);\nconst mat2 rot5 = mat2(0.87758256189,0.4794255386,-0.4794255386,0.87758256189);\nconst mat2 rot6 = mat2(0.82533561491,0.56464247339,-0.56464247339,0.82533561491);\nconst mat2 rot7 = mat2(0.76484218728,0.64421768723,-0.64421768723,0.76484218728);\nconst mat2 rot8 = mat2(0.69670670934,0.7173560909,-0.7173560909,0.69670670934);\nconst mat2 rot9 = mat2(0.62160996827,0.78332690962,-0.78332690962,0.62160996827);\nconst mat2 rot10 = mat2(0.54030230586,0.8414709848,-0.8414709848,0.54030230586);\n\n//Some hashs function by Dave_Hoskins\n//https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n\nmat2 rot(float a) \n{\n    vec2 s = sin(vec2(a, a + pi/2.0));\n    return mat2(s.y,s.x,-s.x,s.y);\n}\n\nvec2 sinNoise(vec2 p)\n{\n    vec2 p1 = p;\n    vec2 p2 = p * rot2 * 0.4;\n    vec2 p3 = p * rot6 * 0.7;\n    vec2 p4 = p * rot10 * 1.5;\n\tvec4 s1 = sin(vec4(p1.x, p1.y, p2.x, p2.y));\n    vec4 s2 = sin(vec4(p3.x, p3.y, p4.x, p4.y));\n    \n    return (s1.xy + s1.zw + s2.xy + s2.zw) * 0.25;\n}\n\nvec4 hash(vec4 p)\n{\n    return fract(sin(p)*12345.0);\n}\n\n//iq's noise\nfloat iqNoise(vec2 x, float c) \n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    //f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*c;\n    \n    vec4 h = hash(vec4(n, n+1.0, n+c, n+c+1.0));\n    \n    return  mix(mix(h.x,h.y,f.x), mix(h.z,h.w,f.x), f.y);\n}\n\n//Simplified version of iq's noise, Output two 1D noise\nvec2 noise1D(vec2 x) \n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    vec2 n = p; \n    vec4 h = hash(vec4(n.x, n.x+1.0, n.y, n.y+1.0));\n    \n    return  mix(h.xz,h.yw,f);\n}\n\n//Distance Field function by iq :\n//https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(c.xy - p.xz) - c.z;\n}\n\n//https://www.shadertoy.com/view/Xds3zN\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n//taken from shane's desert canyon, originaly a modification of the smin function by iq\n//https://www.shadertoy.com/view/Xs33Df\nfloat smaxP(float a, float b, float s){\n    \n    float h = clamp( 0.5 + 0.5*(a-b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1.0-h)*s;\n}\n\nvec4 geom(vec3 pos)\n{\n    vec3 rep = vec3(40.0, 0.0, 40.0);\n    \n    vec3 hash = hash32(floor(pos.xz / rep.xz));\n    \n    vec3 p = pos + vec3(0.0, 2.0, 0.0);\n    vec3 boxPos1 = opRep(p, rep);\n    boxPos1.xz *= rot(hash.z*pi);\n\tfloat box1 = sdBox(boxPos1, vec3(5.0 + hash.z*2.0, 10.0 - hash.x*3.0, 7.0 + hash.y*2.0));\n\n    p.xz *= rot3;\n    p += vec3(0.25, 0.0, 0.0);\n    vec3 boxPos2 = opRep(p, vec3(7.0, 0.0, 7.0));\n\tfloat box2 = sdBox(boxPos2, vec3(7.0, 100.0, 1.0));\n    \n    p.xz *= rot7;\n    p += vec3(0.25, 0.0, 0.25);\n    vec3 boxPos3 = opRep(p, vec3(10.0, 0.0, 10.0));\n\tfloat box3 = sdBox(boxPos3, vec3(3.0, 100.0, 10.0));\n\n\tfloat box = max(-box3, max(-box2, box1));\n    \n    float roofNoise = iqNoise(pos.xz*0.35, 800.0)*3.0 - hash.y*10.0 + 3.0;\n    box = max(pos.y + roofNoise, box);\n    \n    vec2 trenchNoise = sinNoise(pos.xz*0.4);\n\n    vec3 trenchPos = (pos.xzy - vec3(120.0, 0.0, 5.0));\n    trenchPos.xy += trenchNoise*2.0;\n    float trench = sdCylinder(trenchPos, vec3(0.0, 0.0, 10.0));\n    \n    float terrain = -textureLod(iChannel0, pos.xz*0.005, 0.0).x*5.0;\n    \n    terrain += textureLod(iChannel0, pos.xz*0.015, 0.0).x*2.0 + trenchNoise.x*1.5 + trenchNoise.y;\n\n    float ground = smaxP(pos.y, -trench, 3.0);\n    ground += terrain;\n        \n    float geom = min(box, ground);\n    \n    return vec4(geom, ground, box, terrain);\n}\n\nvec3 distfunc(vec3 pos)\n{ \n\tvec4 baseGeomtry = geom(pos);\n       \n    pos.y = baseGeomtry.y;\n    float hvar = texture(iChannel0, pos.xz*0.075).x;\n    float h = height + hvar*heightvar;\n    \n    vec2 t = iTime * vec2(5.0, 4.3);\n    vec2 windNoise = sinNoise(pos.xz*2.5 + t);\n    vec2 windNoise2 = sin(vec2(iTime*1.5, iTime + pi) + pos.xz*1.0) * 0.5 + vec2(2.0, 1.0);\n    vec2 wind = (windNoise*0.45 + windNoise2*0.3) * (pos.y);\n\n    pos.xz += wind;\n\n    vec3 p1 = opRep(pos, vec3(density));\n    p1 = vec3(p1.x, pos.y - h, p1.z);\n    float g1 = sdCone(p1, vec3(1.0, thickness, h));\n    \n    pos.xz *= rot5;\n    vec3 p2 = opRep(pos, vec3(density)*0.85);\n    p2 = vec3(p2.x, pos.y - h, p2.z);\n    float g2 = sdCone(p2, vec3(1.0, thickness, h));\n    \n    pos.xz *= rot10;\n    vec3 p3 = opRep(pos, vec3(density)*0.7);\n    p3 = vec3(p3.x, pos.y - h, p3.z);\n    float g3 = sdCone(p3, vec3(1.0, thickness, h));\n    \n    pos.xz *= rot3;\n    vec3 p4 = opRep(pos, vec3(density)*0.9);\n    p4 = vec3(p4.x, pos.y - h, p4.z);\n    float g4 = sdCone(p4, vec3(1.0, thickness, h));\n    \n    float g = min(min(g1, g2), min(g3, g4));\n    \n    float id = 1.0;\n    \n    if(baseGeomtry.z < epsilon)\n        id = 0.0;\n    \n\treturn vec3(min(g, baseGeomtry.x), id, h);\n}\n\nvec4 rayMarch(vec3 rayDir, vec3 cameraOrigin)\n{\n    const int maxItter = 200;\n\tconst float maxDist = 70.0;\n    \n    float totalDist = 0.0;\n\tvec3 pos = cameraOrigin;\n\tvec3 dist = vec3(epsilon, 0.0, 0.0);\n    \n    for(int i = 0; i < maxItter; i++)\n\t{\n       \tdist = distfunc(pos);\n        \n\t\ttotalDist += dist.x; \n        \n\t\tpos += dist.x * rayDir;\n        \n        if(dist.x < epsilon || totalDist > maxDist)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n    \n    return vec4(dist.x, totalDist, dist.y, dist.z);\n}\n\n//Camera Function by iq :\n//https://www.shadertoy.com/view/Xds3zN\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n//Normal and Curvature Function by Nimitz;\n//https://www.shadertoy.com/view/Xts3WM\nvec4 norcurv(in vec3 p, float id)\n{\n    vec2 e = vec2(-epsilon, epsilon)*5.0;   \n    vec4 t1 = geom(p + e.yxx), t2 = geom(p + e.xxy);\n    vec4 t3 = geom(p + e.xyx), t4 = geom(p + e.yyy);\n\n    float curv = (0.25/e.y)*(t1.z + t2.z + t3.z + t4.z - 4.0 * geom(p).z);\n    \n    vec3 nGround = normalize(e.yxx*t1.y + e.xxy*t2.y + e.xyx*t3.y + e.yyy*t4.y);\n    vec3 nGroundBox = normalize(e.yxx*t1.z + e.xxy*t2.z + e.xyx*t3.z + e.yyy*t4.z);\n    \n    return vec4(mix(nGroundBox, nGround, id), curv);\n}\n\nvec3 lighting(vec3 n, vec3 rayDir, vec3 pos)\n{\n    float diff = dot(LIGHT, n);\n    float rim = (1.0 - max(0.0, dot(-n, rayDir)));\n    float spec = dot(reflect(LIGHT, n), rayDir);\n    spec = pow(spec, 30.0);\n    \n    return smoothstep(vec3(0.0, 0.5, 0.0), vec3(1.0, 1.0, 1.0), vec3(diff, rim, spec)); \n}\n\nvec3 sky(vec3 ray)\n{\n   vec3 diff = ray - LIGHT;\n   float sunDist = clamp(length(diff), 0.0, 1.0);\n   float at = (atan(diff.x, diff.y) + pi) / (2.0 * pi);\n   float rays = textureLod(iChannel2, vec2(iTime*0.01, at), 0.0).x * (1.0 - sunDist);\n    \n   vec3 sun = smoothstep(vec3(0.05, 0.2, 1.5), vec3(0.0), vec3(sunDist)) * vec3(1.0, 0.2, 1.0) + rays*0.025;\n    \n   vec3 grad = mix(vec3(1.0, 0.9, 0.9), vec3(0.4, 1.0, 0.95) + sun.z*0.15, smoothstep(0.0, 0.8, ray.y));\n    \n   vec3 res = mix(vec3(1.0, 0.5, 0.3), grad, smoothstep(-0.5, 0.0, ray.y)) + sun.x + sun.y + sun.z*0.075;\n       \n   return res;\n}\n\nfloat clouds(vec3 uv)\n{\n    vec4 s1 = -abs(sin(uv.y*vec4(2.0, 3.0, 12.0, 20.0) + iTime * vec4(0.1,0.2,0.05,0.15)));\n    vec4 s2 = -abs(sin(uv.x*vec4(3.0, 5.0, 13.0, 19.0) - iTime * vec4(0.15,0.1,0.2,0.1)));\n    \n    float res1 = (s1.x*0.5 + 0.4) + (s1.y*0.1 + 0.1) + s1.z*0.04 + s1.w*0.025;\n    float res2 = (s2.x*0.3 + 0.1) + s2.y*0.1 + s2.z*0.03 + s2.w*0.015;\n    \n    float mask = clamp(1.0 - uv.z*0.35, 0.0, 1.0);\n    \n    return clamp(1.0 - (smoothstep(0.0, 0.65, uv.z + (res1 + res2)/2.0) + mask), 0.0, 1.0);\n}\n\nvec3 backGround(vec3 ray)\n{  \n   vec3 s = sky(ray);\n   \n    vec2 at = vec2(atan(ray.z, ray.x), atan(ray.x, ray.z));\n    vec2 uv = abs(at) / pi;\n    \n   vec2 mNoise = noise1D(uv.xy * vec2(20.0, 15.0) + vec2(0.0, 1.3)) * vec2(0.1, 0.13);\n   mNoise += noise1D(uv.xy * vec2(40.0, 50.0) + vec2(0.2, 1.8)) * vec2(0.05, 0.04);\n   float m = mNoise.x + mNoise.y;            \n   float mountains = clamp(smoothstep(-0.01, 0.01, ray.y - m + 0.05) + (1.0 - ray.y), 0.0, 1.0);\n    \n   vec3 coloredMountains = mix(vec3(0.5, 0.5, 1.0), vec3(1.0), mountains);\n    \n   float c = clouds(vec3(at.x, at.y, ray.y)*2.0)*0.75;\n   float c2 = smoothstep(0.5, -0.4, abs(ray.x-0.8 + sin(ray.y*12.0)*0.1))*0.25 * (1.0 - ray.y);\n    \n   return s.xyz * coloredMountains + c*0.7 + c2*0.5;\n}\n\nvec3 TriplanarTexture(vec3 n, vec3 pos)\n{\n    n = abs(n);\n    vec3 t1 = texture(iChannel1, pos.yz).xyz * n.x;\n    vec3 t2 = texture(iChannel1, pos.zx).xyz * n.y;\n    vec3 t3 = texture(iChannel1, pos.xy).xyz * n.z;\n    \n    return t1 * n.x + t2 * n.y + t3 * n.z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime + iDate.z*10.0;\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 hash = hash21(floor(t*0.1)) * 2.0 - 1.0;\n    \n    float camX = 120.0;\n    float camY = 7.0 + hash.y;\n    float camZ = t*0.25 + floor(t*0.1)*50.0;                 \n    vec3 cameraOrigin = vec3(camX, camY, camZ);\n    \n\tvec3 cameraTarget = cameraOrigin + vec3(hash.x, 0.0, hash.y);\n    \n\tvec2 screenPos = uv * 2.0 - 1.0;\n    \n\tscreenPos.x *= iResolution.x/iResolution.y;\n    \n    mat3 cam = setCamera(cameraOrigin, cameraTarget, hash.x*0.3);\n    \n    vec3 rayDir = cam*normalize(vec3(screenPos.xy,1.0));\n    vec4 dist = rayMarch(rayDir, cameraOrigin);\n    \n    vec3 res;\n\n\tif(dist.x < epsilon)\n    {\n        vec3 pos = cameraOrigin + dist.y*rayDir;\n        vec4 n = norcurv(pos, dist.z);\n        vec3 r = reflect(rayDir, n.xyz);\n        vec3 t = max(TriplanarTexture(n.xyz, pos*vec3(0.2, 0.05, 0.2)), TriplanarTexture(n.xyz, pos*vec3(0.3, 0.1, 0.3)));\n\t\tvec3 l = lighting(n.xyz, rayDir, pos);\n        \n        float fog = smoothstep(60.0, 20.0, dist.y);\n        vec3 s = sky(r);\n        \n        vec3 col1 = mix(color1, color2, clamp(pos.y*0.1 + 0.5, 0.0, 1.0));\n        col1 *= 0.75 + dist.w*0.5;\n        col1 += l.x * lightColor + l.z * l.y * lightColor + s * l.y * 0.3;\n        \n        vec3 col2 = s * t * color0 + t*n.w;\n        col2 += lightColor * (l.x + (l.y + l.z) * t);\n        \n        vec3 col = mix(col2, col1, dist.z);\n            \n        res = mix(sky(rayDir), col, fog);\n    }\n    else\n    {\n        res = backGround(rayDir); \n    }\n    \n\tfragColor = vec4(max(vec3(0.0), res), 1.0);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    vec4 prev = texture(iChannel1, uv);\n    vec4 new = texture(iChannel0, uv);\n    \n\tfragColor = mix(prev, new, 0.2);\n}","name":"Buf B","description":"","type":"buffer"}]}