{"ver":"0.1","info":{"id":"XtcXzH","date":"1479131497","viewed":522,"name":"Water Ball Consume Curved Plane","username":"CyanSprite","description":"Using ray marching to make a 3d sphere of water consume a curved plane.\nUse the mouse to change the eleveation, if you make it low enough it will look like you are inside of the water.\nAlso use the mouse to change the z angle.","likes":19,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarching","noise","displacement","texture","lighting","water","blend","smin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//*****************************Constants*****************************//\n\n//math definitions\n#define mPi 3.14159\n#define m2Pi 6.28318\n\n//booleans\nconst bool doRotate = true;\nconst bool texBend = false;\n\n//operation floats for displacement\nconst float uvSize = 50.0;\nconst float noiseScaler = 5.1;\nconst float noiseMount = noiseScaler;\nconst float rotSpeed = 0.5;\nconst float speed = 1.0;\nconst float scale = 3.0;\n\n//values for tint color\nconst float tintIntensity = 1.0;\nconst vec3 tint = vec3(0.5,0.5,0.5) * tintIntensity;\n\n//values for how the object is rendered.\nconst int rayMarchSteps = 50;\nconst float li = 0.01; // light intensity\nconst float prec = 0.01; // ray marching precision\nconst float maxd = 50.; // ray marching distance max\nconst float refl_i = 0.2; // reflexion intensity\nconst float refr_a = 90.3; // refraction angle\nconst float refr_i = 0.15; // refraction intensity\nconst float bii = 0.1; // bright init intensity\nconst float marchPrecision = 1.000; // ray marching tolerance precision\n\n\n//*****************************End Constants*****************************//\n\n//--//\n\n//*****************************Operations*****************************//\nfloat sphere( vec3 p, float r ){ return length(p)-r;}\n\n//Rand noise 1D\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\nfloat noise(float p){\n    float fl = floor(p);\n    float fc = fract(p);\n    return mix(rand(fl), rand(fl + 1.0), fc);\n}\n\n//Rand noise 3D\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = fract(p);\n    \n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x) ;\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n//Combining 3D and 1D to make some rippling\nvec3 makeItNoisy(float t){\n\treturn vec3(t * noiseMount * .01);\n    //return vec3(noise(sin(t + .03 * 592.) + .03),noise(cos(t + .06 * 592.)  + .03),noise(cos(t + .09 * 592.) + .06)) * noiseMount;\n}\n\n//ensure clean tint\nvec3 tintPulse(vec3 color){\n    return normalize(tint) * noise(color.b);\n}\n\n//dis map gen and tex combined\nfloat disMap(vec3 p){\n    float dis = 0.0;\n    float time = mod(iTime * speed + 30.0,200.0);\n    float t = (sin(time) * 2.0);\n    vec4 texMap;\n    \n\tif(!texBend)\n        texMap = texture(iChannel1,(p.zx + vec2(1,1))) *.1;\n    if(doRotate){\n        float rot = time * mPi * .20 * rotSpeed;\n        p.xy *= mat2(cos(rot),-sin(rot),sin(rot),cos(rot));\n        p.yz *= mat2(cos(rot),-sin(rot),sin(rot),cos(rot));\n        p=normalize(p);\n    }\n    p = makeItNoisy(time) * p;\n\n\tif(texBend)\n        texMap = texture(iChannel1,p.xy);\n    \n\t\n    dis = length(texMap) ;\n    \n    dis += noise(p + time);\n    \n    return dis;\n}\n\n//dis operation\nfloat displacement( vec3 p , float primDist)\n{\n    float d2 = disMap(p);\n    return primDist+d2;\n}\nfloat curveSphereToPlane( vec3 p , float pSize)\n{\n    float c = cos(1.0*p.y) * .1;\n    float s = sin(1.0*p.y) * .1;\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sphere(q,pSize);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n//*****************************End Operations*****************************//\n\n//--//\n\n//*****************************Ray Marching*****************************//\n\n\nfloat map(vec3 p)\n{\n    vec4 tex = texture(iChannel2,p.xy / uvSize);\n    float scale = scale;\n\n\tfloat prim =  sphere(p,5.0+scale); \n\tfloat prim3 = curveSphereToPlane(p,prim+1.0);\n    \n    float dist  = displacement(p / uvSize, prim);\n    float dist3 = prim3;\n    \n    float time = mod(iTime,200.0) * .1;\n    dist = smin(dist,dist3, time);\n    \n    \n    return dist * length(tex);\n}\n\nvec3 rayMarch(vec3 rd, vec3 ro, out float d){\n    vec3 p = ro;\n    float s = prec;\n    for(int i=0;i<rayMarchSteps;i++)\n\t{      \n\t\tif (s<prec||s>maxd) break;\n\t\ts = map(p) * marchPrecision;\n\t\td += s;\n\t\tp = ro+rd*d;\n\t}\n    return p;\n}\n\n//*****************************End Ray Marching*****************************//\n\n//--//\n\n//*****************************Render*****************************//\nvec3 calcNormal( in vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n        map(pos+eps.xyy) - map(pos-eps.xyy),\n        map(pos+eps.yxy) - map(pos-eps.yxy),\n        map(pos+eps.yyx) - map(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\tfor( int i=0; i<5; i++ )\n    \n\t{\n\t\tfloat hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n\treturn clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 makeDomain(vec2 uv, out vec3 ro){\n\tvec4 mouse = normalize(iMouse);\n    float cam_a = (mouse.x) * m2Pi; \t // angle z    \n    float cam_e =  mouse.y * 15.0 + 6.0; // elevation\n    float cam_d =  10.5; \t\t\t\t // distance to origin axis\n   \t\n    if(length(iMouse) == 0.0){\n    \tcam_e = 10.0;\n        cam_a = 0.0;\n    }\n    \n    vec3 camUp=vec3(0,1,0);//Change camere up vector here\n  \tvec3 camView=vec3(0,0,0); //Change camere view here\n    \n    ro = vec3(-sin(cam_a)*cam_d, cam_e+1., cos(cam_a)*cam_d); //\n  \tvec3 rov = normalize(camView-ro);\n    vec3 u = normalize(cross(camUp,rov));\n  \tvec3 v = cross(rov,u);\n  \tvec3 rd = normalize(rov + uv.x*u + uv.y*v);\n    return rd;\n}\n\nvec3 draw(vec3 p, float d, vec3 rd){\n    //the color to return\n    vec3 col = vec3(0.);\n    \n    //light\n    float b = bii;\n    \n    //rays to hit/draw\n    vec3 ray, cubeRay;\n    \n    //if d < max distance...so if we want to draw it.\n\tif (d<maxd)\n\t{  \n\t\tvec2 e = vec2(-1., 1.)*0.005; \n\t\tvec3 n = calcNormal(p, 0.1);\n\n        //light\n\t\tb=li;\n\t\t\n        //reflection\n\t\tray = reflect(rd, n);\n        cubeRay = texture(iChannel0, ray).rgb  * refl_i ;\n        \n\t\t//refraction\n\t\tray = refract(ray, n, refr_a);\n\t\tcubeRay += texture(iChannel0, ray).rgb * refr_i;\n\n\t\tcol = cubeRay+pow(b,15.); \n            \n        // lighting        \n\t\tfloat occ = calcAO( p, n );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n\t\tfloat dif = clamp( dot( n, lig ), 0.0, 1.0 );\n\t\tfloat bac = clamp( dot( n, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-p.y,0.0,1.0);\n\t\tfloat dom = smoothstep( -0.1, 0.1, cubeRay.y );\n\t\tfloat fre = pow( clamp(1.0+dot(n,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( cubeRay, lig ), 0.0, 1.0 ),16.0);\n\n\t\tvec3 brdf = vec3(1.0);\n\t\tbrdf += 4.20 * dif*vec3(1.00,0.90,0.60);\n\t\tbrdf += .1 * spe*vec3(1.00,0.90,0.60)*dif;\n\t\tbrdf += 0.30 * amb*vec3(0.50,0.70,1.00)*occ;\n\t\tbrdf += 0.40 * dom*vec3(0.50,0.70,1.00)*occ;\n\t\tbrdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n\t\tbrdf += 0.1*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tbrdf += 0.02;\n\t\tcol = col*brdf;\n\n\t\t//col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0005*d*d ) );\n\n\t\t//col = mix(col, vec3(map(p)), 0.5) + tintPulse(tint);\n\n\t}\n    //background\n\telse\n\t{\n\t\t//col = texture(iChannel0, rd).rgb * 1.00;\n\t}\n    return col;\n}\n\n//*****************************End Render*****************************//\n\n//--//\n\n//*****************************Main*****************************//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy * 2. -1.;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    //out ro, return domain\n    vec3 ro;\n \tvec3 rd = makeDomain(uv,ro);\n    \n    //out dist, return prim\n    float d = 0.0;\n    vec3 p = rayMarch(rd,ro,d);\n    \n    //return color\n\tvec3 col = draw(p,d,rd);\n    \n\tfragColor.rgb = col;\n}\n//*****************************End Main*****************************//","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//uniform float rt_w; // render target width\n//uniform float rt_h; // render target height\nuniform float vx_offset;\n\n// float offset[3] = float[]\n//float weight[3] = float[]\nconst vec3 offset = vec3( 0.0, 1.3846153846, 3.2307692308 );\nconst vec3 weight = vec3( 0.2270270270, 0.3162162162, 0.0702702703 );\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{ \n  vec3 tc = vec3(1.0, 0.0, 0.0);\n  if (fragCoord.x<(vx_offset-0.01))\n  {\n    vec2 uv = fragCoord.xy;\n    tc = texture(iChannel0, uv).rgb * weight[0];\n    for (int i=1; i<3; i++) \n    {\n      tc += texture(iChannel0, uv + vec2(offset[i])/1.0, 0.0).rgb * weight[i];\n      tc += texture(iChannel0, uv - vec2(offset[i])/1.0, 0.0).rgb * weight[i];\n    }\n  }\n  else if (fragCoord.x >= (vx_offset+0.01))\n  {\n    tc = texture(iChannel1, fragCoord.xy).rgb;\n  }\n  \n  fragColor = vec4(tc, 1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}