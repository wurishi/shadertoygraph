{"ver":"0.1","info":{"id":"XlVGzR","date":"1472765153","viewed":285,"name":"GTC 16 Tutorial: Pacman WiP","username":"starea","description":"Code via the [url=http://on-demand.gputechconf.com/gtc/2016/video/S6717.html]video tutorial[/url] from GTC' 16 by iq and pol.\niq's pacman full version is at [url]https://www.shadertoy.com/view/Ms3XWN[/url] Arrow keys to move.","likes":7,"published":1,"flags":112,"usePreview":0,"tags":["2d","pacman","gtc","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dBGRW","filepath":"https://soundcloud.com/heart02/pacman-start-bgm-ver-3","previewfilepath":"https://soundcloud.com/heart02/pacman-start-bgm-ver-3","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// learning from GTC' 16 iq and pol's talk: http://on-demand.gputechconf.com/gtc/2016/video/S6717.html\n#define EMPTY 0. // empty\n#define WALL 1. // wall\n#define POINT 2. // point\n#define BALL 3. // ball\n#define TH 0.5\n\nconst float GRID_LEFT = 30.0; \nconst float GRID_WIDTH = 27.0;\nconst float GRID_HEIGHT = 31.0;\nconst float GRID_LENGTH = GRID_HEIGHT;\nconst vec3 PACMAN_COLOR = vec3(1.0, 1.0, 0.0);\nconst vec3 CELL_COLOR = vec3(1.0, 1.0, 0.0);\nconst vec3 WALL_COLOR = vec3(0.0, 0.0, 1.0);\nconst vec3 POINT_COLOR = vec3(1.0, 0.0, 1.0);\nconst vec3 BALL_COLOR = vec3(1.0, 0.0, 1.0);\nconst float PACMAN_SIZE = 0.50; \nconst float PACMAN_FADE_RADIUS = 0.01; \nconst float BALL_SIZE = 0.10; \nconst float BALL_FADE_RADIUS = 0.01; \nconst float GHOST_SIZE = 0.50; \nconst float GHOST_FADE_RADIUS = 0.01; \n\nvec2 getAPoint() {\n    return vec2(50.5 / iChannelResolution[0].xy);    \n}\n\nvec2 getPreviousPos(){\n    return texture(iChannel0, getAPoint()).xy + 0.5;\n}\n\nvec2 getGridPosition(in vec2 fragCoord)\n{\n    return GRID_LENGTH * fragCoord / iResolution.y - vec2(13.5, 0.0); \n}\n\nfloat sdCircle(vec2 gridPos, vec2 renderPos, float size, float radius)\n{\n    float r = length( gridPos - renderPos );\n    return 1.0 - smoothstep( size, size + radius, r ); \n}\n\nfloat sdCircle(float r, float size, float radius)\n{\n    return 1.0 - smoothstep( size, size + radius, r ); \n}\n\n\nfloat sdBox( vec2 p, vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( vec2 p, vec2 a, vec2 b )\n{\n    p -= (a+b)*0.5;\n    vec2 d = abs(p) - 0.5*(b-a);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length( p ) - r;\n}\n\nvec3 drawMap( vec3 col, in vec2 fragCoord)\n{\n    vec2 pp = getGridPosition(fragCoord); \n    vec2 pi = floor(pp); \n    vec2 pf = fract(pp); \n    \n    float cell = texture(iChannel0, vec2((pi + 0.5) / iChannelResolution[0].xy)).x;\n    \n    if (pi.x < GRID_WIDTH && pi.x > -0.5) \n    {\n        if (cell < EMPTY + TH)\n        {\n            \n        }\n        else if (cell < WALL + TH )\n        {\n            //col = WALL_COLOR; \n            float lc = texture(iChannel0, vec2((pi + 0.5 + vec2(-1.0, 0.0)) / iChannelResolution[0].xy)).x;\n            float rc = texture(iChannel0, vec2((pi + 0.5 + vec2( 1.0, 0.0)) / iChannelResolution[0].xy)).x;\n            float bc = texture(iChannel0, vec2((pi + 0.5 + vec2( 0.0,-1.0)) / iChannelResolution[0].xy)).x;\n            float tc = texture(iChannel0, vec2((pi + 0.5 + vec2( 0.0, 1.0)) / iChannelResolution[0].xy)).x;\n            \n            float lw = step(0.1, abs(lc - 1.0)); \n            float rw = step(0.1, abs(rc - 1.0)); \n            float bw = step(0.1, abs(bc - 1.0)); \n            float tw = step(0.1, abs(tc - 1.0)); \n            \n            \n            float ls = 0.5 - 0.4 * lw; \n            float bs = 0.5 - 0.4 * bw; \n            float rs = 0.5 - 0.4 * rw; \n            float ts = 0.5 - 0.4 * tw; \n            \n\t\t\tfloat r = sdBox( pf - 0.5, vec2(-ls, -bs), vec2(rs, ts) );\n            float f = 1.0 - smoothstep( 0.10, 0.11, r);\n            // vec3 wco = 0.5 + 0.5 * cos( (lw + rw + bw + tw) + vec3(0.0, 1.0, 2.0) ); \n            vec3 wco = 0.5 + 0.5 * cos( 3.5 + 0.25 * (lw + rw + bw + tw) + vec3(0.0, 1.0, 2.0) ); \n            wco += 0.1 * cos(300.0 * r); \n            col = mix(col, wco, f); \n        }\n        else if (cell < POINT + TH)\n        {\n            float r = length(pf - 0.5);\n            float f = sdCircle(r, BALL_SIZE, BALL_FADE_RADIUS );\n            col = mix(col, BALL_COLOR, f); \n            \n            col += vec3(1.0, 0.0, 1.0) * exp( -10.0 * r * r ); // glow\n        }\n        else \n   \t\t// GHOST\n        {\n            float r = length(pf - 0.5);\n            float f = sdCircle(r, GHOST_SIZE, GHOST_FADE_RADIUS );\n            f *= sin(iTime * 10.0); \n            col = mix(col, BALL_COLOR, f); \n        }\n    }\n    \n    return col; \n}\n\nvec3 drawPacman( vec3 col, in vec2 fragCoord)\n{\n    vec2 pp = getGridPosition(fragCoord);\n    vec2 pacmanPos = getPreviousPos();\n    \n    float r = length(pp - pacmanPos); \n    float f = sdCircle(r, PACMAN_SIZE, PACMAN_FADE_RADIUS); \n    col = mix( col, PACMAN_COLOR, f );\n            \n    col += 0.5 * PACMAN_COLOR * exp( -1.0 * r * r ); // glow\n    return col; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;    \n    vec3 col = vec3(0.0);\n    \n    col = drawMap( col, fragCoord ); \n    col = drawPacman( col, fragCoord ); \n    \n\tfragColor = vec4(col, 1.0);\n    fragColor.rgb *= 0.25 + 0.75 * pow( 16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.15 );\n\t// fragColor = vec4(texture(iChannel0, uv * 0.1).xyz, 1.0);\n\t// fragColor = vec4(texture(iChannel0, uv).xyz, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// data buffer\nconst float KEY_LEFT = 37.5;\nconst float KEY_DOWN = 38.5;\nconst float KEY_RIGHT = 39.5;\nconst float KEY_UP = 40.5;\nconst float KEY_ALL = 256.0;\nconst vec2 PACMAN_INIT_POS = vec2(13.0);\nconst float GRID_WIDTH = 27.0;\nconst float GRID_HEIGHT = 31.0;\n\n// find what kind of tile is the position x, y\n#define _ 0. // empty\n#define W 1. // wall\n#define P 2. // point\n#define B 3. // ball\n#define PA(a,b,c,d,e,f,g) (a+4.*(b+4.*(c+4.*(d+4.*(e+4.*(f+4.*(g)))))))\n#define DD(id,c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13) if(y==id) m=(x<7)?PA(c0,c1,c2,c3,c4,c5,c6):PA(c7,c8,c9,c10,c11,c12,c13);\n\n// map of walls and points and spaces\nfloat map( in vec2 p ) \n{\n    ivec2 q = ivec2( p );\n    if( q.x>13 ) q.x = q.x = 26-q.x;\n\tint x = q.x;\n\tint y = q.y;\n\tfloat m = 0.0;\n    DD(30, W,W,W,W,W,W,W,W,W,W,W,W,W,W)\n    DD(29, W,P,P,P,P,P,P,P,P,P,P,P,P,W)\n    DD(28, W,P,W,W,W,W,P,W,W,W,W,W,P,W)\n    DD(27, W,B,W,W,W,W,P,W,W,W,W,W,P,W)\n    DD(26, W,P,W,W,W,W,P,W,W,W,W,W,P,W)\n    DD(25, W,P,P,P,P,P,P,P,P,P,P,P,P,P)\n    DD(24, W,P,W,W,W,W,P,W,W,P,W,W,W,W)\n    DD(23, W,P,W,W,W,W,P,W,W,P,W,W,W,W)\n    DD(22, W,P,P,P,P,P,P,W,W,P,P,P,P,W)\n    DD(21, W,W,W,W,W,W,P,W,W,W,W,W,_,W)\n    DD(20, _,_,_,_,_,W,P,W,W,W,W,W,_,W)\n    DD(19, _,_,_,_,_,W,P,W,W,_,_,_,_,_)\n    DD(18, _,_,_,_,_,W,P,W,W,_,W,W,W,_)\n    DD(17, W,W,W,W,W,W,P,W,W,_,W,_,_,_)\n    DD(16, _,_,_,_,_,_,P,_,_,_,W,_,_,_)\n    DD(15, W,W,W,W,W,W,P,W,W,_,W,_,_,_)\n    DD(14, _,_,_,_,_,W,P,W,W,_,W,W,W,W)\n    DD(13, _,_,_,_,_,W,P,W,W,_,_,_,_,_)\n    DD(12, _,_,_,_,_,W,P,W,W,_,W,W,W,W)\n    DD(11, W,W,W,W,W,W,P,W,W,_,W,W,W,W)\n    DD(10, W,P,P,P,P,P,P,P,P,P,P,P,P,W)\n    DD( 9, W,P,W,W,W,W,P,W,W,W,W,W,P,W)\n    DD( 8, W,P,W,W,W,W,P,W,W,W,W,W,P,W)\n    DD( 7, W,B,P,P,W,W,P,P,P,P,P,P,P,_)\n    DD( 6, W,W,W,P,W,W,P,W,W,P,W,W,W,W)\n    DD( 5, W,W,W,P,W,W,P,W,W,P,W,W,W,W)\n    DD( 4, W,P,P,P,P,P,P,W,W,P,P,P,P,W)\n    DD( 3, W,P,W,W,W,W,W,W,W,W,W,W,P,W)\n    DD( 2, W,P,W,W,W,W,W,W,W,W,W,W,P,W)\n    DD( 1, W,P,P,P,P,P,P,P,P,P,P,P,P,P)\n    DD( 0, W,W,W,W,W,W,W,W,W,W,W,W,W,W)\n\treturn mod(floor(m/pow(4.,mod(float(x),7.0))),4.);\n}\n\nbool getKeyDown(float key) {\n    return texture(iChannel1, vec2(key / KEY_ALL, 0.5)).x > 0.1;\n}\n\nvec2 getAPoint() {\n    return vec2(50.5 / iChannelResolution[0].xy);    \n}\n\nvec2 getPreviousPos(){\n    return texture(iChannel0, getAPoint()).xy;\n}\n\n\n\n// Data Buffer from keyboard\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pacmanPos = vec2(0.0, 0.0); \n    float cell = 0.0; \n    \n    if ( iFrame == 0 )\n    {\n        pacmanPos = PACMAN_INIT_POS;\n        if (fragCoord.x < 27.0 && fragCoord.y < 31.0)\n        cell = map( fragCoord - 0.5 ); \n        \n    }\n    else \n    {\n        cell = texture(iChannel0, fragCoord / iChannelResolution[0].xy).x;\n        vec2 previousPos = getPreviousPos();\n    \tpacmanPos = previousPos; \n        if ( getKeyDown(KEY_LEFT) )  pacmanPos.x--;\n        if ( getKeyDown(KEY_DOWN) )  pacmanPos.y++;\n        if ( getKeyDown(KEY_RIGHT) ) pacmanPos.x++;\n        if ( getKeyDown(KEY_UP) )    pacmanPos.y--;\n        \n        float tt = texture(iChannel0, (pacmanPos + 0.5) / iChannelResolution[0].xy).x;\n        if ( abs(tt - P) < 0.1 || abs(tt - B) < 0.1 )\n        {\n            if (abs(pacmanPos.x - fragCoord.x + 0.5) < 0.1 && \n                abs(pacmanPos.y - fragCoord.y + 0.5) < 0.1\n                )\n                cell = _;\n        } else \n        if ( abs(tt - W) < 0.1) \n        {\n        \tpacmanPos = previousPos;     \n        }\n    }\n    \n    fragColor = vec4(pacmanPos, 0.0, 1.0);\n    if (fragCoord.x < GRID_WIDTH && fragCoord.y < GRID_HEIGHT)\n        fragColor = vec4(cell, 0.0, 0.0, 0.0); \n}","name":"Buf A","description":"","type":"buffer"}]}