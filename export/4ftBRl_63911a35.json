{"ver":"0.1","info":{"id":"4ftBRl","date":"1733380887","viewed":86,"name":"2D CCD IK Solver","username":"ZhouboLi","description":"2D CCD IK Solver","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","ik","ccd"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define S(a, b, t) smoothstep(a, b, t)\n\nfloat df_line( in vec2 a, in vec2 b, in vec2 p)\n{\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n\nfloat line(vec2 a, vec2 b, vec2 uv) {\n    float r1 = .02;\n    float r2 = .01;\n    \n    float d = df_line(a, b, uv);\n    float d2 = length(a-b);\n    float fade = S(1.5, .1, d2);\n    \n    fade += S(.05, .02, abs(d2-.75));\n    float dd = min(length(uv-a),length(uv-b));\n    float s = S(0.02, 0., dd)* 5.0;\n    \n    return S(r1, r2, d)*fade*0.9 + s;\n}\n\nvec2 Pos(float x, float y){\n    return vec2(x, y) * vec2(iResolution.x/iResolution.y, 1.);\n}\n\nvec2 Rotate(vec2 xy, float theta){\n    return vec2(xy.x*cos(theta)-xy.y*sin(theta),xy.x*sin(theta)+xy.y*cos(theta));\n}\n\nvec3 GetStepIK(vec2 uv, vec2 start, vec2 a, vec2 b, vec2 c, vec2 end){\n    for (int iter = 0; iter < 1000; iter++){\n        vec2 delta_c = c-b;\n        vec2 nc = normalize(c-b);\n        vec2 nt = normalize(end-b);\n        float signed = sign(cross(vec3(nc,1.0), vec3(nt,1.0)).z);\n        float theta = acos(clamp(dot(nc, nt),-1.,1.));\n        c = Rotate(delta_c, signed*theta) + b;\n        \n        delta_c = c-a;\n        vec2 delta_b = b-a;\n        nc = normalize(c-a);\n        nt = normalize(end-a);\n        signed = sign(cross(vec3(nc,1.0), vec3(nt,1.0)).z);\n        theta = acos(clamp(dot(nc, nt),-1.,1.));\n        c = Rotate(delta_c, signed*theta) + a;\n        b = Rotate(delta_b, signed*theta) + a;\n\n        delta_c = c-start;\n        delta_b = b-start;\n        vec2 delta_a = a-start;\n        nc = normalize(c-start);\n        nt = normalize(end-start);\n        signed = sign(cross(vec3(nc,1.0), vec3(nt,1.0)).z);\n        theta = acos(clamp(dot(nc, nt),-1.,1.));\n        c = Rotate(delta_c, signed*theta) + start;\n        b = Rotate(delta_b, signed*theta) + start;\n        a = Rotate(delta_a, signed*theta) + start;\n        \n        if (length(c - end) < 1e-5)\n            break;\n    }\n    return vec3(line(a,b,uv)) * vec3(0.5,1.0,0.1) \n        + vec3(line(start,a,uv)) * vec3(1.0,0.4,0.9)\n        + vec3(line(b,c,uv)) * vec3(.0,1.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy;\n    vec2 m = iMouse.xy/iResolution.yy;\n    \n    vec2 start = vec2(0.3,0.8), end = Pos(0.6,0.5);\n    \n    if (length(m) < 0.01)\n        m = end;\n    float dd = min(length(uv-start),length(uv-m));\n    float ss = S(0.035, 0., dd)*S(0.015, 0.035, dd);\n    vec3 se = vec3(ss) * vec3(0.0,10.0,0.0);\n    \n    vec2 a = Pos(0.2,0.4), b = Pos(0.45,0.2), c = Pos(0.6,0.6);\n    vec3 col = GetStepIK(uv, start, a, b, c, m);\n\n    fragColor = vec4(col + se ,1.0) ;\n}","name":"Image","description":"","type":"image"}]}