{"ver":"0.1","info":{"id":"Xdd3WB","date":"1452126071","viewed":291,"name":"abstract alien ship","username":"public_int_i","description":"alien ship rendered with monte carlo ray tracing","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["ray","abstract","alien","march","ship"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\nconst int nFramesPerShot = 300;\nconst int nCameraShots = 3;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = mix(vec4(0.),\n        pow( texture(iChannel0, fragCoord/iResolution.xy)/mod(float(iFrame-120),float(nFramesPerShot)), vec4(1.24)),\n                    1.-pow(length(fragCoord.xy/iResolution.xy*2.-1.),1.7)*.25);\n\n    //fragColor =  texture(iChannel0, fragCoord/iResolution.xy);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Ethan Shulman/public_int_i 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//thanks to iq for the great tutorials, code and information\n//thanks to XT95 for the ambient occlusion function\n\n\n\n\n\n#define FOV_SCALE 2.\n#define ITERATIONS 512\n#define SHADOW_ITERATIONS 86\n#define EPSILON .001\n#define NORMAL_EPSILON .012\n\n#define VIEW_DISTANCE 2047.\n\n#define PATH_TRACE\n//#define REFLECTIONS\n\n#define pi 3.141592\n\n\nvec3 cameraLocation;\nvec2 cameraRotation;\n\n\nstruct material {\n    vec3 diffuse,specular,emissive;\n    float metallic,roughness, opacity, refrIndex;\n};\nstruct light {\n    vec3 position, color;\n    float size;\n};\n\n\nconst vec3 moonDir = vec3(100.,-200.,300.);\nconst vec3 moonLight = vec3(.5,.6,.7);\nconst vec3 ambient = vec3(1.);//moonLight*2.2;\n#define fogColor moonLight*.3\n\n\n\n\nconst int nFramesPerShot = 300;\nconst int nCameraShots = 3;\nvec3 cameraLocations[nCameraShots];\nvec2 cameraRotations[nCameraShots];\n\nvoid initCamera() {\n    cameraLocations[0] = vec3(-160.,-250.,-860.);\n    cameraRotations[0] = vec2(1.4,1.6);\n    \n    cameraLocations[1] = vec3(120.,-350.,860.);\n    cameraRotations[1] = vec2(4.53,1.2);\n    \n    cameraLocations[2] = vec3(-550.,-900.,400.);\n    cameraRotations[2] = vec2(5.9,.75);\n    \n    \n    int shot = int(mod(float((iFrame-120)/nFramesPerShot),float(nCameraShots)));\n    for (int i = 0; i < nCameraShots; i++) {\n        if (shot == i) {\n            cameraLocation = cameraLocations[i];\n            cameraRotation = cameraRotations[i];\n            return;\n        }\n    }\n}\n\n\n#define nLights 0\n\n#if nLights != 0\nlight lights[nLights];\n#endif    \n\nvoid initLights() {\n    #if nLights != 0\n    lights[0] = light(moonDir,\n                      moonLight,\n                      100000.);\n\t#endif\n}\nvoid initDynamicLights(vec3 p) {\n    #if nLights != 0\n    lights[1] = light(vec3( (floor(min(abs(p.xz/140.),1.))*140.*sign(p.xz)+70.*sign(p.xz)), 0.).xzy-vec3(0.,16.,20.), vec3(1.2,.9,.99), 50.);\n    \n    lights[2] = light(vec3( (floor(min(abs(p.xz/300.),0.))*300.*sign(p.xz)+150.*sign(p.xz)), 0.).xzy-vec3(0.,20.,0.) , vec3(1.2,.9,.99), 190.);\n    #endif\n}\n\n//distance functions from iq's site\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*.5,-p.y)-h.x*0.5);\n}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n    \nvec2 rot(in vec2 v, in float ang) {\n    float si = sin(ang);\n    float co = cos(ang);\n    return v*mat2(si,co,-co,si);\n}\n\n\nfloat core(in vec3 rp) {\n    return length(rp-vec3(0.,-180.,30.))-80.;\n}\n\nfloat ground(in vec3 rp) {\n    return -rp.y+11.5;\n}\n\nfloat ship(in vec3 rp) {\n    vec3 p = rp+vec3(0.,4.,0.);\n    \n    for (int i = 0; i < 4; i++) {\n        float t = .623+float(i)*.14;\n        p.xy = rot(abs(p.xy),t+float(i)*.24);\n        p.zx = abs(rot(p.zx,t+float(i)*.194));\n    }\n    \n    vec3 lp2 = abs(mod(abs(p),10.)-5.)-1.;\n    \n    vec3 lp = p;\n    lp.xy = rot(abs(lp.xy), 1.528);\n    vec3 lp3 = lp;\n    lp.xz = mod(abs(lp.xz),60.)-30.;\n    \n    return max( sdBox(lp3, vec3(600.,30.,600.)),\n        max( max(-sdBox(lp,vec3(12.,24.,28.)), sdBox(lp, vec3(26.))),\n        \tmin(sdTorus(lp2,vec2(4.,.5)), sdBox(lp2, vec3(1.5,2.15,3.8)))));\n}\n\n\nfloat df(in vec3 rp) {\n\treturn min(core(rp), min(ship(rp),ground(rp)));\n}\nfloat df_hq(in vec3 rp) {\n\treturn df(rp);\n}\n\n\n\nconst vec3 ne = vec3(NORMAL_EPSILON,0.,0.);\nvec3 normal2(in vec3 rp) {\n    return normalize(vec3(df(rp+ne)-df(rp-ne),\n                          df(rp+ne.yxz)-df(rp-ne.yxz),\n                          df(rp+ne.yzx)-df(rp-ne.yzx)));\n}\n\n\nvec3 normal(in vec3 rp) {\n    return normalize(vec3(df_hq(rp+ne)-df_hq(rp-ne),\n                          df_hq(rp+ne.yxz)-df_hq(rp-ne.yxz),\n                          df_hq(rp+ne.yzx)-df_hq(rp-ne.yzx)));\n}\n\nmaterial mat(vec3 rp) {\n    material m;\n    \n    if (ground(rp) < EPSILON) {\n        m = material(vec3(1.74, 1.36, 1.17)/2.55,\n                     vec3(.8),\n                     vec3(0.),\n                     0.,\n                     1.,\n                     1.,\n                     1.);\n                     \n    }\n    if (ship(rp) < EPSILON) {\n        m = material(vec3(.975,.94,.99),\n                     vec3(.975,.94,.99),\n                     vec3(max(0., cos(floor(abs(rp.x)*.004+abs(rp.y)*.04+abs(rp.z)*.4)*.1 )-.9)*30.),\n                     0.1,\n                     0.,\n                     0.,\n                     1.04);\n    }\n    if (core(rp) < EPSILON) {\n        m = material(vec3(1.), vec3(1.),\n                     vec3(2.1,1.75,2.2)*2.0,\n                     0.,\n                     1.,\n                    1.,\n                    1.);\n    }\n    \n    return m;\n}\n\n\n\nfloat trace(in vec3 rp, inout vec3 rd, float maxDist) {\n    \n    float d,s = 0.;\n    for (int i = 0; i < ITERATIONS; i++) {\n        d = df(rp+rd*s);\n        if (d < EPSILON || s > maxDist) break;\n        s += d;\n    }\n    \n    if (d < EPSILON) return s;\n    \n    return -1.0;\n}\n\nvec3 randomHemiRay(in vec3 d, in vec3 p, in float amount) {\n    vec3 rand = normalize(cos(cos(p)*512.124+cos(p.yzx*16.234)*64.3249+cos(p.zxy*128.234)*12.4345));\n    return rand*sign(dot(d,rand));\n}\n//ambient occlusion function is XT95's from https://www.shadertoy.com/view/4sdGWN\nfloat ambientOcclusion(in vec3 rp, in vec3 norm) {\n    float sum = 0., s = 0.5;\n    vec3 lastp;\n    \n    for (int i = 0; i < 32; i++) {\n        vec3 p = rp+randomHemiRay(norm,lastp,.4)*s;\n        sum += max(0., (s-df(p))/(s*s));//randomHemiRay(norm,rp,.5)*s);\n        lastp = p;\n        s += .2;\n    }\n    \n    return clamp(1.-sum*.05, 0., 1.);\n}\n\nfloat softShadowTrace(in vec3 rp, in vec3 rd, in float maxDist, in float penumbraSize, in float penumbraIntensity) {\n    vec3 p = rp;\n    float sh = 0.;\n    float d,s = 0.;\n    for (int i = 0; i < SHADOW_ITERATIONS; i++) {\n        d = df(rp+rd*s);\n        sh += max(0., penumbraSize-d)*float(s>penumbraSize*4.);\n        s += d;\n        if (d < EPSILON || s > maxDist) break;\n    }\n    \n    if (d < EPSILON) return 0.;\n    \n    return max(0.,1.-sh/penumbraIntensity);\n}\n\nvec3 background(in vec3 rd) {\n    float md = dot(rd, normalize(moonDir));\n    return mix(mix(fogColor, texture(iChannel2,rd.xy*10.).xyz*.6, texture(iChannel1,rd.xy*.3).x)+max(0., md)*moonLight*.1,\n               moonLight*12., max(0., (md-.995)/.005 ));\n}\n\nvec3 locateSurface(in vec3 rp) {    \n    vec3 sp = rp;\n    for (int i = 0; i < 3; i++) {\n        float sd = abs(df(rp));\n        if (sd < EPSILON) return sp;\n        sp += normal2(sp)*sd*.5;\n    }\n    return sp;\n}\nvoid lighting(in vec3 td, in vec3 sd, in vec3 norm, in vec3 reflDir, in material m, inout vec3 dif, inout vec3 spec) {\n    float ao = ambientOcclusion(td,norm);\n    dif = ambient*ao;\n    spec = vec3(0.);\n        \n    #if nLights != 0\n    initDynamicLights(td);\n    for (int i = 0; i < nLights; i++) {\n        vec3 lightVec = lights[i].position-td;\n        float lightAtten = length(lightVec);\n        lightVec = normalize(lightVec);\n        float shadow = softShadowTrace(sd, lightVec, lightAtten, 0.3, 1.5);\n        lightAtten = max(0., 1.-lightAtten/lights[i].size)*shadow;\n        \n    \tdif += max(0., dot(lightVec,norm))*lights[i].color*lightAtten;\n        spec += pow(max(0., dot(reflDir, lightVec)), 4.+(1.-m.roughness)*78.)*shadow*lightAtten*lights[i].color;\n    }\n\t#endif\n    \n    //dif *= .5+ao*.5;\n}\n\n//copy of shade without reflection trace\nvec3 shadeNoReflection(in vec3 rp, in vec3 rd, in vec3 norm, in material m) {\n    vec3 sd = rp+normal2(rp)*EPSILON*10.;//locateSurface(rp)-rd*EPSILON*2.;\n    \n    //lighting\n    vec3 reflDir = reflect(rd,norm);\n\n    vec3 lightDif,lightSpec;\n    lighting(rp,sd,norm,reflDir,m,lightDif,lightSpec);\n\n    return (1.-m.metallic)*lightDif*m.diffuse +\n        \t(.5+m.metallic*.5)*lightSpec*m.specular +\n        \tm.emissive ;\n}\n\nvec3 shade(in vec3 rp, in vec3 rd, in vec3 norm, material m) {\n    vec3 sd = rp+normal2(rp-rd*EPSILON*40.)*EPSILON*10.;//locateSurface(rp)-rd*EPSILON*2.;\n    \n    //lighting\n    vec3 dlc = vec3(0.);\n    \n   \n    vec3 slc = vec3(0.);\n    vec3 reflDir = reflect(rd,norm);\n    vec3 tReflDir = normalize(reflDir+cos(rp*245.245-rd*cos(rp*9954.345)*3532.423)*m.roughness*0.25);\n    tReflDir *= sign(dot(tReflDir,reflDir));\n    \n    #ifdef REFLECTIONS\n    float rtd = trace(sd,tReflDir,VIEW_DISTANCE);\n    if (rtd < 0.) {\n        slc = background(tReflDir);\n    } else {\n        vec3 rhp = sd+tReflDir*rtd;\n        slc = shadeNoReflection(rhp,reflDir,normal(rhp),mat(rhp));\n    }\n    #endif\n    \n    vec3 lightDif,lightSpec;\n    lighting(rp,sd,norm,reflDir,m,lightDif,lightSpec);\n    dlc += lightDif;\n    slc += lightSpec;\n    \n    float fres = 1.-max(0., dot(-rd,norm));\n    \n    return (1.-m.metallic)*dlc*m.diffuse +\n        \tslc*m.specular*((.5-m.metallic*.5)*fres+m.metallic*(.5+m.metallic*.5)) +\n        \tm.emissive ;\n}\n\n\nfloat hash3(in vec3 p) {\n    return fract(abs(cos(p.x)*128.234)+abs(cos(p.y)*124.234)+abs(cos(p.z)*128.234)+\n                 abs(cos(p.x*128.234)*18.234)+abs(cos(p.y*128.234)*18.234)+abs(cos(p.z*128.234)*18.234));\n}\nvec3 pathtrace(vec3 rp, vec3 rd) {\n    material m;\n    vec3 norm;\n    vec3 sd = rp;//locateSurface(rp)-rd*EPSILON*2.;\n    \n\n    //lighting\n    vec3 c = vec3(0.),\n         nextCMult = vec3(1.);\n\n    float ifrm = float(iFrame);\n    #define rndifrm cos(vec3(ifrm*.0004923))*512.2479\n    \n\n    float d,s = 0.,lastD = 9999999.;\n    for (int i = 0; i < ITERATIONS; i++) {\n    \td = df(sd+rd*s);\n        if (d < EPSILON && lastD > EPSILON) {\n                        \n        \tvec3 tp = sd+rd*s;\n            m = mat(tp);\n            tp -= rd*lastD;\n            norm = normal(tp);\n            if (hash3(tp+(rndifrm).yzx)-.0001 < max(m.opacity,m.metallic*.5)) {\n                c += nextCMult*m.emissive;\n                if (hash3(tp+rndifrm)-.0001 < m.opacity*.5*(1.-m.metallic)) {\n                    nextCMult *= m.diffuse;\n                    rd = randomHemiRay(norm,tp+rndifrm,1.);\n                } else {\n                    nextCMult *= m.specular;\n                    rd = mix(reflect(rd,norm),\n                             randomHemiRay(norm,tp+rndifrm,1.),\n                              m.roughness);\n                }\n                d = EPSILON;\n            } else {\n                tp += rd*lastD;\n                rd = mix(refract(rd,norm,1./m.refrIndex),\n                             randomHemiRay(norm,tp+rndifrm,1.),\n                              m.roughness);\n\n                nextCMult *= m.specular;\n            }\n            sd = tp;\n            s = 0.;\n       \n        } else {\n            if (d > EPSILON && lastD < EPSILON) {\n\n                sd += rd*s;\n                norm = normal(sd);\n                rd = mix(refract(rd,-norm,m.refrIndex),\n                             randomHemiRay(norm,sd+rndifrm,1.),\n                              m.roughness);\n                           \t\n               s = 0.;\n                \n                nextCMult *= m.specular;\n            }\n        }\n        lastD = d;\n        s += max(EPSILON,abs(d));\n        if (s > VIEW_DISTANCE) break;\n     }\n    if (d > EPSILON) {\n        c += nextCMult*background(rd);\n    }\n    \n    return c;\n}\n\nvec2 randUv(vec2 uv) {\n    return cos(float(iFrame)*.10924+abs(cos(float(iFrame)*2.345+uv)*128.345)+abs(cos(uv.yx*32.345)*16.234));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n\tvec2 uv = (fragCoord - R*.5)/R.x;\n\n    initLights();\n    initCamera();\n  \n    #ifndef PATH_TRACE\n        vec3 rp = cameraLocation;\n    vec3 rd = normalize(vec3(uv*vec2(1.,-1.)*FOV_SCALE,1.));\n\n    rd.yz = rot(rd.yz,cameraRotation.y);\n    rd.xz = rot(rd.xz,cameraRotation.x);\n        \n\tfloat itd = trace(rp,rd,VIEW_DISTANCE);\n    if (itd < 0.) {\n        fragColor = vec4(background(rd),1.);\n        return;\n    }\n    \n\n    vec3 hp = rp+itd*rd;\n    fragColor = vec4(mix(shade(hp,\n                      rd,\n                      normal(hp),\n                      mat(hp)), fogColor, max(0.,itd/VIEW_DISTANCE)),1.);\n\t#else\n    if (iFrame < 120 || mod(float(iFrame-120),float(nFramesPerShot)) > float(nFramesPerShot-10) ) {\n        fragColor = vec4(0.);\n        return;\n    }\n\tinitCamera();\n    \n    vec3 rp = cameraLocation;\n    vec3 rd = normalize(vec3((uv+randUv(uv)*(1./iResolution.y)*.25)*vec2(1.,-1.)*FOV_SCALE,1.));\n\n    rd.yz = rot(rd.yz,cameraRotation.y);\n    rd.xz = rot(rd.xz,cameraRotation.x);\n    \n\tfragColor = vec4(texture(iChannel0, fragCoord/R).xyz+pathtrace(rp,rd), 1.);\n    #endif\n}","name":"Buf A","description":"","type":"buffer"}]}