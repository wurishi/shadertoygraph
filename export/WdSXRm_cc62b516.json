{"ver":"0.1","info":{"id":"WdSXRm","date":"1557418245","viewed":99,"name":"Beto produit scalaire 3D","username":"msafadi","description":"beto","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["beto"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//////////////////////////////////////////////////////////////////////////\n// ATELIER MATHS : ECLAIRAGE\n// https://docs.google.com/presentation/d/1yq5WnAdE0Ch1hT_-KXkJ7ezQ9FVOWaGD8wUebL17b80/edit#slide=id.p\n//////////////////////////////////////////////////////////////////////////\n\nconst vec3 PURPLE = vec3(0.44,0.0,0.76);\n\nvec4 computeColor(in vec3 ray, in vec3 m, in vec3 normal, in vec3 light, in vec3 eye) {\n\n    vec3 reflection = light - 2. * dot(light, normal)*normal;\n\n    \n    float ambiant = 0.3;\n    float diffuse = -dot(light, normal);\n    float specular = pow(max(-dot(ray, reflection), 0.), 20.);\n    \n    vec3 couleurDeBase = PURPLE;\n    \n    vec3 render = couleurDeBase * (ambiant+diffuse) + specular;\n    \n    vec3 reflectray = reflect(ray, normal);\n    vec3 envmap = texture(iChannel0, reflectray).xyz;\n    \n    return vec4(mix(render, envmap, 0.3), 1.0);\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n// PRIVATE !\n//////////////////////////////////////////////////////////////////////////\n\nfloat smin( float a, float b) {\n    float k = 10.0;\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nfloat map(in vec3 m) {\n   \n    vec3 sphere0 = vec3(-1.0, 0.0, 4.0);\n    vec3 sphere1 = vec3(+1.0, 0.0, 4.0);\n    vec3 sphere2 = vec3(0.0, -1.0, 4.0);\n    vec3 sphere3 = vec3(0.0, +1.0, 4.0);\n    vec3 sphere4 = vec3(0.0, 0.0, 4.0);    \n    \n    float r = 0.5;\n    float d0 = length(m-sphere0) - r;\n    float d1 = length(m-sphere1) - r;\n    float d2 = length(m-sphere2) - 1.;\n    float d3 = length(m-sphere3) - r;\n    float d4 = length(m-sphere4) - r;    \n    \n    return smin(smin(smin(d0, d1), smin(d2, d3)), d4);\n}\n\nconst float zNear = 1.0;\nconst float zFar  = 400.0;\n\nbool rayMarching(in vec3 origin, in vec3 ray, out vec3 m) {\n    \n    float\tmarchingDist = 0.0;\n    float \tnbIter \t\t = 0.0;\n\n    for(int i = 0; i<250; i++) {\n        \n        m = origin + ray * marchingDist;    \n        \n    \tfloat dist = map(m);\n        \n        if(dist < 0.01) {\n            return true;\n        }\n        else {\n            marchingDist += dist/4.0;\n            \n            if(marchingDist >= zFar) {\n                break;\n            }\n        }\n    }\n    \n\treturn false;    \n}\n\n\n\n\nvec3 computeNormal(in vec3 pos)\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t     map(pos+eps.xyy) - map(pos-eps.xyy),\n\t     map(pos+eps.yxy) - map(pos-eps.yxy),\n\t     map(pos+eps.yyx) - map(pos-eps.yyx));\n\treturn normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float \tratio \t\t\t= iResolution.x/iResolution.y;\n    vec3 \tviewportCoord \t= vec3(fragCoord.xy/iResolution.y - vec2(ratio/2.0, 0.5), zNear);\n    \n    vec3\teye\t\t\t\t= vec3(0.0, 0.0, 0.0);\n    vec3\tray\t\t\t\t= normalize(viewportCoord-eye);\n    vec3\tlight\t\t\t= normalize(vec3(-15.0*cos(iTime*0.2), 25.0*cos(iTime/3.0), 5.0));\n    \n    vec3\tm;\n    \n    if(rayMarching(eye, ray, m)) {\n        \n        vec3 normal = computeNormal(m);\n        \n        fragColor = computeColor(ray, m, normal, light, eye);\n    }\n    else {\n        fragColor = vec4(0.0, 0, 0, 1.0);        \n    }\n}","name":"Image","description":"","type":"image"}]}