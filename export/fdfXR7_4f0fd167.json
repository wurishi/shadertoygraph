{"ver":"0.1","info":{"id":"fdfXR7","date":"1618390544","viewed":54,"name":"RayTracer Learning Program","username":"wind_flows","description":"RayTracing Learning Program","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Ref Mtls \n// https://iquilezles.org/articles/intersectors\n// https://www.shadertoy.com/view/4d2XWV\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pos = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    \n\tvec3 rayOrigin = vec3(0.0, 0.0, 4.0 );\n\tvec3 rayDir = normalize( vec3(pos,-2.0) );\n\t\n    // sphere animation\n    vec4 sphere = vec4( cos( iTime + vec3(2.0,1.0,1.0) + 0.0 )*vec3(1.5,0.0,1.0), 1.0 );\n\n    if( iMouse.z>0.0 ) { sphere.x = -1.0+2.0*iMouse.x/iResolution.x;\n                         sphere.y =      4.0*iMouse.y/iResolution.y; }\n    \n    vec3 light = normalize( vec3(0.6,0.3,0.4) );\n    vec3 color = vec3(0.0);\n\n    float tmin = 1e10;\n    vec3 normal;\n    float occlusion = 1.0;\n    \n\t// RayTracing of The Floor Plane\n    float distToPlane = iPlane( rayOrigin, rayDir );\n    if( distToPlane > 0.0 )\n    {\n        tmin = distToPlane;\n        vec3 pos = rayOrigin + distToPlane*rayDir;\n        normal = vec3(0.0,1.0,0.0);\n        occlusion = 1.0 - sphereOcclusion( pos, normal, sphere );\n    }\n\t\n\t// RayTracing of Sphere\n    float distToSphere = sphereIntersect( rayOrigin, rayDir, sphere );\n    if( distToSphere > 0.0 && distToSphere < tmin )\n    {\n        tmin = distToSphere;\n        vec3 pos = rayOrigin + distToSphere * rayDir;\n        normal = sphereNormal(pos, sphere);\n        occlusion = 0.5 + 0.5 * normal.y;\n\t}\n\t\n    if( tmin < 1000.0 )//Find Intersection\n    {\n        vec3 pos = rayOrigin + tmin * rayDir;\n        \n\t\tcolor = vec3(1.0);//base color\n\t\t\n        color *= clamp( dot(normal,light), 0.0, 1.0 );// light attenuation\n\t\t\n        //Shadow Calculated From RayTracing in Light View From Solid Intersection Point\n        color *= sphereSoftShadow( pos, light, sphere, 2.0 );//shadow attenuation\n\t\t\n        color += 0.05*occlusion;//occlusion attenuation\n\t\t\n\t    color *= exp( -0.05*tmin );//fog attenuation\n    }\n\n    color = sqrt(color);\n    fragColor = vec4( color, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// \nfloat sphereIntersect( in vec3 rayOrigin, in vec3 rayDir, in vec4 sphere )\n{\n    vec3 originToCenter = rayOrigin - sphere.xyz;\n    \n\t//Projection Length of Vector originToCenter On rayDir\n    float projLen = dot(originToCenter, rayDir);\n    \n    float toSphereSqure = dot(originToCenter, originToCenter) - sphere.w * sphere.w;\n    \n\t// radius^2 - distToRayDir^2\n    float lenFromIntersectionSquqre = projLen*projLen - toSphereSqure;\n    \n\t// projLen*projLen < dot(originToCenter, originToCenter) - sphere.w * sphere.w\n\t// originToCenter^2 - projLen^2 > radius^2\n    if( lenFromIntersectionSquqre < 0.0 ) \n        return -1.0; // no intersection\n    \n\t//    \n    float lenFromIntersection = sqrt( lenFromIntersectionSquqre );\n    \n\t// projLen < 0\n    return -projLen - lenFromIntersection;\n}\n\nfloat sphereSoftShadow( in vec3 rayOrigin, in vec3 rayDir, in vec4 sphere, in float k )\n{\n    vec3 originToCenter = rayOrigin - sphere.xyz;\n\t\n    float projLen = dot( originToCenter, rayDir );\n\t\n    float toSphereSqure = dot( originToCenter, originToCenter ) - sphere.w * sphere.w;\n\t\n    float h = projLen * projLen - toSphereSqure;\n\n    // cheap but not plausible alternative\n    return (projLen > 0.0) ? step(-0.0001, toSphereSqure) : smoothstep( 0.0, 1.0, h*k/projLen );\n   \n}    \n            \nfloat sphereOcclusion( in vec3 pos, in vec3 normal, in vec4 sphere )\n{\n    vec3  r = sphere.xyz - pos;\n    float l = length(r);\n    return dot(normal,r)*(sphere.w*sphere.w)/(l*l*l);\n}\n\nvec3 sphereNormal( in vec3 pos, in vec4 sphere )\n{\n    return normalize(pos-sphere.xyz);\n}\n\n//=====================================================\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\nfloat iPlane( in vec3 rayOrigin, in vec3 rayDir )\n{\n    return (-1.0 - rayOrigin.y)/rayDir.y;\n}","name":"Common","description":"","type":"common"}]}