{"ver":"0.1","info":{"id":"dsKcRW","date":"1695934582","viewed":389,"name":"Relativistic Cartwheels 3D","username":"Amirk","description":"You can look around and move with WASD. Brake with SPACE. Notice also that the speed and rotation rate of the wheels seem to slow down as they are moving away. (Due to information delay.)","likes":14,"published":1,"flags":48,"usePreview":0,"tags":["wheel","relativity","lorentz","acceleration","retardation","terrell"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Terrell-Penrose 3D\" by Amirk. https://shadertoy.com/view/mdGyzR\n// 2023-09-27 19:47:00\n\n// Fork of \"Relativistic Space Drive\" by Amirk. https://shadertoy.com/view/7sKBzz\n// 2023-09-26 03:58:36\n\n\n#define MAX_ITER 1500.\n#define MAX_DIST 70.\n#define SURF .0001\n\n\nvec4 fourvel = vec4(0,0,0,1);\nvec4 position =vec4(0);\nvec4 boost=vec4(0,0,0,0);\nvec3 orientation=vec3(1,0,0);\n\n\n//delay effect ON/OFF  1./0.:\nfloat RETARD = 1.;\n//ray origin in the moving coords.\nvec4 RO, rd;\nvec2 m;\nmat4 TransformMatrix;\n\nvec3 col = vec3(0);\nfloat speed=-.6;\nfloat radius=1.;\n#define rotSpeed speed/radius\n\n\n\nvec3 color( float s){\n    return vec3(1) - vec3(1.,1.,0)*smoothstep(.0,1., s)-\n            vec3(0.,.6,.6)*smoothstep(0.,1., -s);\n}\n\nvoid updateVel(){\n    // Fetch the fourvelocity from the Buffer A\n    boost= texelFetch( iChannel0, ivec2(5,5), 0);\n    orientation=texelFetch( iChannel0, ivec2(6,6), 0).xyz;\n    fourvel=texelFetch( iChannel0, ivec2(0,0), 0 );\n}\n\nvoid updatePos(){\n    // Fetch the fourposition from the Buffer B\n    \n    position =texelFetch( iChannel0, ivec2(1,0), 0 );\n    \n    //uncomment to freeze velocity\n    position.xyz*=1.;\n}\n\n\nfloat sdSphere(vec4 q, float r){\n    float d1=length(q.xyz)-r;\n    \n    float r2=length(q.xyz);\n    //hollow sphere;\n    float d2= -(r2-r*.9) ;\n    \n    return smax(d1,d2,.01);\n}\n\n\nfloat sdBox(vec4 p , vec3 s){\n    p.y*=5.;\n    p.y=fract(p.y)-.5; //this creates the grid of reference cubes\n    p.y/=5.;\n    p.xyz= abs(p.xyz)-s;\n    return length(max(p.xyz,0.))+ min(max(p.x,max(p.y,p.z)),0.);  \n}\n\nfloat sdBox2(vec4 p , vec3 s, float spokes){\n    float sectorAngle=6.283185/spokes;\n    \n    float sector=round(atan(p.z,p.x)/sectorAngle);\n    \n    float an=sector*sectorAngle;\n    \n    p.xz*=rot(-an);\n    \n   // p.y=fract(p.y)-.5; //this creates the grid of reference cubes\n   \n    p.xyz= abs(p.xyz)-s;\n    return length(max(p.xyz,0.))+ min(max(p.x,max(p.y,p.z)),0.);  \n}\n\n\nvec4 sdCartWheel(vec4 p, float rad){\n    p.x-=speed*p.w;\n    p.x*=gamma(speed);\n    \n    p.x=(fract(p.x*.25)-.5)/.25;\n    //ring\n    float d= abs(length(p.yx)-rad)-.1;\n    d=smax(d, abs(p.z)-.1,.1);\n    //clipping\n    p.yz*=rot(PI*.5);\n    float rotTime=(RETARD!=0. ) ? p.w : position.w;\n    p.xz*=rot(rotTime*rotSpeed);\n    float d2=sdBox2(p, 1.*vec3(radius,1.5,.04),6.);\n    d2=smax(d2, abs(p.y)-.1,.01);\n    d= min(d, d2);\n    \n    \n    return vec4(p.xyz,d*.5);\n}\n\n\nvec4 getDist(vec4 p){\n    \n    vec4 ground= vec4(p.xyz, p.y+radius*1.1);\n\n    p-=vec4(7.,0.,-2.9,0);\n    \n    vec4 d=sdCartWheel(p,radius);\n    \n    d= (d.w<ground.w)? d : ground;\n    \n    return vec4(d.xyz,d.w);\n}\n\n\n\nvec4 getRayDir(vec2 uv, vec4 lookAt, float zoom){\n\n    vec3 f= normalize(lookAt.xyz);\n    vec3 r= normalize(cross(vec3(0,1,0),f));\n    vec3 u= cross(f,r);\n    \n    return vec4(normalize(f*zoom+uv.x*r+uv.y*u),lookAt.w/c);\n\n    //the w-component determines how we look into past/future/present.\n}\n\nvec4 RayMarch(vec4 ro, vec4 rd){\n    float dO=0.;\n    vec4 dS=vec4(0);\n    float i=0.;\n   while(i<MAX_ITER){\n      vec4 p= ro+dO*rd; //if rd.w =-c we look back in time as we march further away\n      \n      dS=getDist(p); \n        \n      dO+=dS.w;\n  \n      if(dO>MAX_DIST||abs(dS.w)<SURF){\n          break;\n      }\n      i++;\n    } \n    \n      return vec4(dS.xyz, dO);\n}\n\nvec3 getNormal(vec4 p){\n   vec2 e= vec2(0.01,0);\n   float d=getDist(p).w;\n   vec3 n = d-vec3(getDist(p- e.xyyy).w,getDist(p- e.yxyy).w,getDist(p- e.yyxy).w);\n   \n   return normalize(n);\n}\n\nvoid getMaterial(vec4 p){\n    \n}    \n\nmat4 getTransform(){\n    mat4 M= mat4(1,0,0,0,\n                 0,1,0,0,\n                 0,0,1,0,\n                 0,0,0,1);\n    if(iFrame>10){\n           for(int j=1; j<=4; j++)\n              M[j-1]=texelFetch( iChannel0, ivec2(0, j), 0);\n    }\n    return M;\n}\n\n\n\n#define C(c) U.x-=.5; O+= char(U,c)\n\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel2, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\nvec4 text( out vec4 O, vec2 uv )\n{\n    O = vec4(0.0);\n    uv /= iResolution.y;\n    vec2 pos = vec2(.0,.8);\n    float FontSize = 6.;\n    vec2 U = ( uv - pos)*64.0/FontSize;\n   \n   \n   \n   float k = abs(speed); \n   C(111);C(98);C(106);C(101);C(99);C(116);\n   C(32);\n   C(115);C(112);C(101);C(101);C(100);C(32);\n   \n   \n   C(46);\n   C(48+int(10.*fract(k)));\n   C(99);\n   \n   return O.xxxx;\n}\n\n\nfloat ambOcc( in vec4 pos, in vec3 normal )\n{\n\tfloat occlusion = 0.0;\n    float scaling =1.5;\n    for( int i=0; i<4; i++ )\n    {\n        float height = 0.01 + 0.12*float(i)/4.0;\n        float dist = getDist( pos+height*vec4(normal,0)).w;\n        occlusion += (height-dist)*scaling;\n        scaling *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occlusion, 0.0, 1.0 );\n}\n\n\nfloat softShadow( in vec4 ro, in vec4 rd, float k )\n{\n    float res = 1.0;\n    \n    // raymarch\n    float dmax = 2.0;\n    float d    = 0.001;\n    for( int i=0; i<64; i++ )\n    {\n        vec4 p=ro + d*rd;\n        float h = getDist(p).w;\n        res = min( res, k*h/d );\n        d += clamp( h, 0.012, 0.2 );\n        if( res<0.001 || d>dmax ) break;\n    }\n    \n    return clamp( res, 0.0, 1.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    if(iMouse.xy==vec2(0))\n         m = vec2(.5);\n    else{\n        m = (iMouse.xy-.5)/iResolution.xy;\n    } \n    \n    updateVel();\n    //coordinate transform:  \n    TransformMatrix=getTransform();\n    updatePos();\n    \n    //ray's spacetime origin represented in \"stationary coordinates\":\n    RO=position;\n    float zoom= 1.5;\n    \n    //four-direction in our moving coords:\n    vec4 lookAt;\n    if(RETARD>0.) //what we actually see as light reaches our eyes:\n        lookAt = vec4(c, 0, 0, -1);\n    else //the \"instantaneous geometry\" of spacetime/coordinates: \n        lookAt = vec4(c, 0, 0, 0);\n       \n    if(sign(iMouse.z)!=0.){\n        lookAt.xy*=rot((m.y-.5)*PI);\n        lookAt.xz*=rot(-(m.x-.5)*2.*PI);\n    }else{\n        lookAt.xz=vec2(11.+t*speed,-2.9);\n    }\n      \n    //ray in our moving coords:\n    vec4 ray= getRayDir(uv, lookAt, zoom);\n   \n    \n    \n    //ray direction from moving coords to stationary coords:\n    rd= TransformMatrix*ray; \n    //some rescaling for accuracy:\n    if(RETARD!=0.){\n        rd.xyz=normalize(rd.xyz);\n        rd.w= -RETARD;\n    }\n    \n    \n    \n    \n    \n    \n    //RAYMARCH IN SPACETIME calculated in stationary coordinates:\n    vec4 p=RO;          \n    \n    vec4 d= RayMarch(p, rd);\n    \n    \n     if(d.w<MAX_DIST){ //if we hit an object:\n          p= p+ d.w*rd;\n          \n          col=vec3(1); //color(dot(normalize(rd.xyz), fourvel.xyz));\n          vec3 material=.5*texture(iChannel3,d.xz).xyz\n                         +.5*texture(iChannel1,d.yz).xyz;\n                         \n          vec3 n= getNormal(p);\n          \n          float occlusion= ambOcc(p,n);\n          vec3 light=vec3(-3,1,1);\n          float dif= dot(n, normalize(light))*.5+.5;\n          //col/=length(d*rd)*.1;\n          col*=dif*dif;           \n          float beaming=clamp(dot(rd.xyz,fourvel.xyz),.0,1.)+1.;\n          col*=1.6*vec3(.4,.6,1.1) *occlusion*material*beaming;\n          \n          vec3 light2=vec3(10,4,-1);\n          \n          float dif2= dot(n, normalize(light2))*.5+.5;\n          col+=.8*vec3(.9,.7,.1)*dif2*dif2*occlusion;\n          vec3 l= lambda(d.w);\n          col*=l;\n          col+=1.-l;\n    }else{\n        col+=vec3(.3,.5,1.) - .8*rd.y;\n    }\n    \n\n    col.xyz+=text(fragColor, fragCoord).xyz;\n\n\n    fragColor = vec4(col,1.0);\n    \n   \n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float frames = 70.;\n\n//t is the proper time in rockets moving frame (counted in frames so\n//fps would not affect the physics)\n#define t float(iFrame)/frames\n#define PI 3.14159265359\n\nconst float c=1.;//Not sure if everything works if you change c.\n\nmat4 I = mat4(1,0,0,0,\n            0,1,0,0,\n            0,0,1,0,\n            0,0,0,1);\n\nfloat gamma(float b){\n\n    return pow(1.-b*b,-.5);\n}\n\n//for infinitesimal lorentz transforms it is faster to use this generator:\nmat4 LorentzGenerator(vec3 e){\n     float cc=c*c;\n        \n     return mat4(0 ,0  , 0 , -e.x/cc ,\n                0,   0,  0 ,  -e.y/cc ,\n                 0, 0,   0,   -e.z/cc  , \n                 -e.x, -e.y  , -e.z ,0);                            \n}\n\nmat4 Lorentz(vec3 v){\n     float beta= length(v)/c;\n     float gamma = gamma(beta);\n    \n    float v2=dot(v,v);\n        \n    return mat4(1.+(gamma-1.)*v.x*v.x/v2, (gamma-1.)*v.x*v.y/v2, (gamma-1.)*v.x*v.z/v2, -gamma*v.x/c,\n                 (gamma-1.)*v.y*v.x/v2, 1.+(gamma-1.)*v.y*v.y/v2, (gamma-1.)*v.y*v.z/v2, -gamma*v.y/c,\n                 (gamma-1.)*v.z*v.x/v2, (gamma-1.)*v.z*v.y/v2, 1.+(gamma-1.)*v.z*v.z/v2, -gamma*v.z/c ,\n                 -gamma*v.x/c, -gamma*v.y/c, -gamma*v.z/c,   gamma);                            \n}\n\nmat2 rot(float a){ \n    return mat2(cos(a), -sin(a),sin(a),cos(a));\n}\n\nfloat smax(float a, float b, float k){\n    float h=max(k-abs(a-b),0.);\n    \n    return max(a,b)+(.25/k)*h*h;\n}\n\nvec3 lambda(float dist){\n    return exp(-.005*dist*vec3(1,2,5));\n    \n}\n\nvec3 velAdd(vec3 v, vec3 u){\n    float beta= length(v)/c;;   \n    float gamma=pow(1.-dot(beta,beta),-.5);\n        \n    \n    return 1./(1.+dot(u,v)/(c*c))*( v-u/gamma+gamma/(c+c*gamma)*dot(u,v)*v );   \n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// For details on how the keyboard input works, see iq's tutorial: https://www.shadertoy.com/view/lsXGzf\n\n// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_A  = 65;\nconst int KEY_W  = 87;\nconst int KEY_D =68;\nconst int KEY_S  = 83;\n\n\nconst float dt = .02;\n\nvec2 m;\n\nvec3 handleKeyboard() {     \n    if(iMouse.xy==vec2(0))\n         m = vec2(.5);\n    else{\n        m = (iMouse.xy-.5)/iResolution.xy;\n    } \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n    vec3 left = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x * vec3(0, 0,1)\n    +texelFetch(iChannel1, ivec2(KEY_A, 0), 0).x * vec3(0, 0,1);\n    vec3 up = texelFetch(iChannel1, ivec2(KEY_UP,0), 0).x * vec3(1, 0,0)\n    +texelFetch(iChannel1, ivec2(KEY_W,0), 0).x * vec3(1, 0,0);\n    vec3 right = texelFetch(iChannel1, ivec2(KEY_D, 0), 0).x * vec3(0, 0,-1)\n    + texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x * vec3(0, 0,-1);\n    vec3 down = texelFetch(iChannel1, ivec2(KEY_S, 0), 0).x * vec3(-1, 0,0)\n    +texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x * vec3(-1, 0,0);\n    \n    \n    vec3 acceleration=( up +  down+left+right) ;\n       \n    // steer with mouse\n    // acceleration.xy*=rot((m.y-.5)*PI);\n   // acceleration.xz*=rot(-(m.x-.5)*2.*PI);\n    \n    return acceleration*c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.x>7.|| fragCoord.y>7. ) discard;\n    //coordinates of the boost are in rockect coordinates\n    vec3  boost=vec3(0,0,0);\n    vec3 orientation=vec3(1,0,0);\n    \n    boost = handleKeyboard();\n    float brake= texelFetch(iChannel1, ivec2(32, 0), 0).x ;\n    vec4 fourvel=texelFetch( iChannel0, ivec2(0, 0), 0);\n    boost-=fourvel.xyz*brake*1.1; \n    \n    orientation = texelFetch( iChannel0, ivec2(6, 6), 0).rgb;\n    \n    \n    //orientation is for the rockets alignment\n    orientation +=(boost-orientation)*.01;\n    if(ivec2(fragCoord)==ivec2(6,6))\n             fragColor= vec4(orientation,0);\n             \n    //this will transform coordinates from rockets frame to stationary\n    mat4 TransformMat = mat4(1,0,0,0,\n                        0,1,0,0,\n                        0,0,1,0,\n                        0,0,0,1);\n                                           \n    \n    if(boost==vec3(0)){ //if no keys are pressed we just copy from the previous frame\n        TransformMat=TransformMat+(I-TransformMat)*.01*brake;\n        fragColor= texelFetch( iChannel0, ivec2(fragCoord), 0);\n        if(ivec2(fragCoord)==ivec2(5,5)){\n            fragColor= vec4(texelFetch( iChannel0, ivec2(5, 5), 0).rgb,0);\n        }else if(ivec2(fragCoord)==ivec2(1,0)){\n            fragColor= texelFetch( iChannel0, ivec2(1, 0), 0)\n                        +dt*texelFetch( iChannel0, ivec2(0, 0), 0);\n        }\n        if(iFrame<10){\n            if(ivec2(fragCoord)==ivec2(0,0)){\n                 vec4 fourvel = TransformMat*vec4(0,0,0,1); \n                 fragColor= fourvel;          \n            }\n            else if(ivec2(fragCoord)==ivec2(1,0)){\n            fragColor= vec4(0);\n            }\n            else if(ivec2(fragCoord)==ivec2(5,5)){\n            fragColor= vec4(boost,0);\n            }else if(ivec2(fragCoord)==ivec2(6,6)){\n            fragColor= vec4(orientation,0);\n            }\n            for(int j=1; j<=4; j++)\n                if(ivec2(fragCoord)==ivec2(0,j))\n                    fragColor=TransformMat[j-1];\n        }\n    }else{\n        boost/= texelFetch( iChannel0, ivec2(0, 0), 0).w; //to scale boost according to speed\n        //next the boost transform\n        mat4 NextBoost= Lorentz(-boost*dt);//mat4(1)+LorentzGenerator(-boost*dt); // \n                        \n        if(iFrame>10){\n                for(int j=1; j<=4; j++){\n                     TransformMat[j-1]=texelFetch( iChannel0, ivec2(0, j), 0);\n                 }  \n        }\n    \n        //how to transform to stationary coords\n        TransformMat*=NextBoost;\n        TransformMat=TransformMat+(I-TransformMat)*.01*brake;\n        fourvel =TransformMat*vec4(0,0,0,1);\n        \n        if(ivec2(fragCoord)==ivec2(0,0)){\n             fragColor= fourvel;          \n        }else if(ivec2(fragCoord)==ivec2(1,0)){\n             vec4 fourPos=texelFetch( iChannel0, ivec2(1, 0), 0);\n             fourPos+=dt*fourvel;\n             fragColor= fourPos;\n        }\n        else if(ivec2(fragCoord)==ivec2(5,5)){\n             fragColor= vec4(boost,1);\n        }else{\n            //StoreMatrix:\n            for(int j=1; j<=4; j++)\n                if(ivec2(fragCoord)==ivec2(0,j))\n                    fragColor=TransformMat[j-1];\n       }\n     }\n}","name":"Buffer A","description":"","type":"buffer"}]}