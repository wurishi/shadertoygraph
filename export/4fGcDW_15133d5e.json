{"ver":"0.1","info":{"id":"4fGcDW","date":"1731854404","viewed":143,"name":"Black Hole Trace","username":"Rugged","description":"Black Hole","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["blackhole"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 prop = iResolution.xy / iResolution.x;\n    vec2 uvc = prop * (2. * (uv - 0.5));\n    \n    vec4 col = vec4(0.);\n    \n    \n    \n    float oneThird = 1. / 3.;\n    float root3 = sqrt(3.);\n    vec3 rayD = vec3(sqrt(1. - (oneThird * dot(uvc, uvc))), uvc.x / root3, uvc.y / root3);\n    \n    \n    float phi = .05 * iTime;\n    phi -= 2.;\n    float theta = .1 * iTime;\n    \n    \n    float camCL = -2. * (.2 * sin(iTime * .5) + 1.);\n    vec3 camC = camCL * vec3(1., 0., 0.);\n    \n    \n    rayD = rotate3D(rayD, phi, theta);\n    \n    camC = rotate3D(camC, phi, theta);\n    \n    \n    vec3 lightDir = normalize(vec3(1., 0., -1.));\n    vec3 p = camC;\n    \n    float l = 0.;\n    float l2 = 0.;\n    \n    float g = 0.008;\n    \n    float noiseFactor = 0.0;\n    \n    //for film grain\n    float blurStrength = 0.00025;\n    float blurPhi = 0.0;\n    float blurTheta = 0.0;\n    \n    for(int i = 0; i < 1000; i++){\n        \n        \n        l = length(p);\n        l2 = (l * l) + .0001;\n        \n        //add gravity to the ray direction\n        rayD -= (g * p / (l2)) * .2;\n        rayD = normalize(rayD);\n        \n        //this just turns the ray a tiny bit in a random direction causing a noisy blur effect\n        //(basically film grain)\n        // VERY EXPENSIVE due to rotate3D function in the ray loop\n        // so I have it off for now\n        /*\n        blurPhi = blurStrength * ((2. * hash3(p.xy)) - 1.);\n        blurTheta = blurStrength * ((2. * hash3(p.yz)) - 1.);\n        rayD = rotate3D(rayD, blurPhi, blurTheta);\n        */\n        \n        \n        \n        //variance in the ray stepping\n        noiseFactor = cloudNoise1(p.xy + (float(i) * .01), 200.);\n        \n        //step the ray point\n        p += rayD * (  .01  + (.0025 * (noiseFactor - .5))  );\n        \n        if(l < .1){\n            \n            //col -=  .01 / l2;\n            break;\n        }\n        \n        if(abs(p.z * (l / .1)) < 0.05){\n            \n            float rotAng = iTime + 1. / l;\n            \n            mat2 nrot;\n            nrot[0] = vec2(cos(rotAng), -sin(rotAng));\n            nrot[1] = vec2(sin(rotAng), cos(rotAng));\n            \n            col +=  .07 * texture(iChannel0, nrot * (p.xy * .1)).r *  vec4(1., .77, .53, 1.) / (l2*l + .12);\n            //cloudNoise1(nrot * p.xy , 70.)\n        }\n        \n    }\n    \n    \n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float hash3(vec2 xy){\n    xy = mod(xy, .19);\n    float h = dot(xy.yyx,vec3(.013, 27.15, 2027.3));\n    h *= h;\n    h *= fract(h);\n    \n    return fract(h);\n}\n\n\nvec2 rotate(vec2 v, float theta){\n    mat2 rot;\n    rot[0] = vec2(cos(theta), -sin(theta));\n    rot[1] = vec2(sin(theta), cos(theta));\n    \n    \n    return rot * v;\n}\n\nvec3 rotate3D(vec3 v, float phi, float theta){\n    mat3 rot = mat3(\n        vec3( cos(phi)*cos(theta), -sin(phi), cos(phi)*sin(theta)),\n        vec3( sin(phi)*cos(theta), cos(phi), sin(phi)*sin(theta)),\n        vec3( -sin(theta), 0., cos(theta))\n    );\n    \n    \n    return rot * v;\n}\n\n\nfloat cloudNoise1(vec2 frag, float scale){\n    \n    frag *= scale;\n    \n    frag = floor(frag);\n    \n    frag += 1000.0f;\n    \n    vec2 frag2 = rotate(frag, frag.y);\n    vec2 frag3 = rotate(frag, frag.x);    \n    \n    \n    \n    return fract(frag2.y - frag3.x);// * frag2.y;\n}","name":"Common","description":"","type":"common"}]}