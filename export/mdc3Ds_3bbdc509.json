{"ver":"0.1","info":{"id":"mdc3Ds","date":"1681477740","viewed":59,"name":"Ray Marching: 3 Spheres","username":"Sergio_2357","description":"Ray Marching Experiment\nWASD to move\nArrows to rotate camera","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define S(a, b, c) smoothstep(a, b, c)\n\nconst float M_PI = 3.14159265358979323846264338327950288;\n\nvec3 sky = vec3(0.52941, 0.80784, 0.98039);\n\nvec3 sun = vec3(0.0, -20.0, 100.0);\n\nfloat rad(float deg) {\n    return deg/180.0*M_PI;\n}\n\nfloat Lerp(float a, float b, float t) {\n    return a*(1.0-t)+b*t;\n}\n\nvec3 Lerp(vec3 a, vec3 b, float t) {\n    return a*(1.0-t)+b*t;\n}\n\n//k = 32\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n\nvec3 rotate(vec3 p, vec3 rt) {\n    float cx = cos(rt.x);\n    float sx = sin(rt.x);\n    mat3 rx = mat3(1.0, 0.0, 0.0,\n                   0.0, cx,  -sx,\n                   0.0, sx,  cx);\n    float cy = cos(rt.y);\n    float sy = sin(rt.y);\n    mat3 ry = mat3(cy,  0.0, sy,\n                   0.0, 1.0, 0.0,\n                   -sy, 0.0, cy );\n    float cz = cos(rt.z);\n    float sz = sin(rt.z);\n    mat3 rz = mat3(cz,  -sz, 0.0,\n                   sz,  cz,  0.0,\n                   0.0, 0.0, 1.0);\n    p *= rx;\n    p *= ry;\n    p *= rz;\n    return p;\n}\n\nfloat distanceToFloor(vec3 p, float h) {\n    return p.z - h;\n}\n\nfloat distanceToSphere(vec3 p, vec3 s, float r) {\n    return length(p - s) - r;\n}\n\nvec4 spheres[3] = vec4[3](vec4(5.0, 0.0, 0.0, 1.0), vec4(6.0, 0.0, 0.0, 1.2), vec4(5.0, -1.0, 0.5, 0.8)); \nfloat distanceToScene(vec3 p, int ig, out int cl) {\n    float d = 1000000.0;\n    int cnt = 0;\n    float ds;\n    for (int i = 0; i < 3; i++) {\n        ds = distanceToSphere(p, spheres[i].xyz, spheres[i].w);\n        if (ig != cnt && ds < d) {\n            d = ds;\n            cl = cnt;\n        }\n        cnt++;\n    }\n    ds = distanceToFloor(p, -2.0);\n    if (ig != cnt && ds < d){\n        d = ds;\n        cl = cnt;\n    }\n    cnt++;\n    return d;\n}\n\nvec3 shadowMarch(vec3 cm, vec3 ray, int ig, out vec3 ps, out float mi, out float mid, out int obj) {\n    ps = cm;\n    float md = 0.00001;\n    float mad = 1000.0;\n    mi = 100000.0;\n    float st = 0.0;\n    float ms = 1000.0;\n    float pd = -1.0;\n    for (; st < ms; st++) {\n        float d = distanceToScene(ps, ig, obj);\n        if (pd > d) {\n            mi = min(mi, d);\n            mid = length(ps-cm);\n        }\n        pd = d;\n        if (d <md)\n            return vec3(1.0);\n        if (d > mad)\n            break;\n        ps += ray * d;\n    }\n    return sky;\n}\n\nvec3 march(vec3 cm, vec3 ray, int ig, out float d, out vec3 ps, out float mi, out int obj) {\n    ps = cm;\n    float md = 0.00001;\n    float mad = 1000.0;\n    mi = 100000.0;\n    float st = 0.0;\n    float ms = 1000.0;\n    for (; st < ms; st++) {\n        d = length(ps-cm);\n        float d = distanceToScene(ps, ig, obj);\n        mi = min(mi, d);\n        if (d < md)\n            return vec3(1.0);\n        if (d > mad)\n            break;\n        ps += ray * d;\n    }\n    d = 0.0;\n    return sky;\n}\n\nvec3 normal(vec3 p) {\n    float epsilon = 0.0001; // arbitrary â€” should be smaller than any surface detail in your distance function, but not so small as to get lost in float precision\n    int useless = 0;\n    float centerDistance = distanceToScene(p, -1, useless);\n    float xDistance = distanceToScene(p + vec3(epsilon, 0, 0), -1, useless);\n    float yDistance = distanceToScene(p + vec3(0, epsilon, 0), -1, useless);\n    float zDistance = distanceToScene(p + vec3(0, 0, epsilon), -1, useless);\n    vec3 res = (vec3(xDistance, yDistance, zDistance) - centerDistance) / epsilon;\n    return res;\n}\n\nvec3 uvToForwardVector(vec2 uv, vec3 camRot) {\n    float FOV = rad(30.0);\n    float sz = tan(FOV);\n    vec3 camDir = vec3(1.0, sz*uv.x, sz*uv.y);\n    camDir = normalize(camDir);\n    vec3 rot = vec3(0.0, camRot.y, camRot.z);\n    return rotate(camDir, rot);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    \n    vec3 cam = texelFetch(iChannel0, ivec2(0, 0), 0).xyz*1000.0;\n    \n    vec3 srot = (texelFetch(iChannel0, ivec2(1, 0), 0).xyz);\n    srot *= 360.0;\n    srot = vec3(rad(srot.x), rad(srot.y), rad(srot.z));    \n    vec3 ray = uvToForwardVector(uv, srot);\n    \n    vec3 imp = cam;\n    float d = 0.0;\n    float mid = 10000.0;\n    int obj = -1;\n    vec3 col = vec3(march(cam, ray, -1, d, imp, mid, obj));\n    \n    if (mid < 0.00001) {\n        vec3 dirToSun = sun / length(sun);\n        float d2 = 0.0;\n        float mid2 = 10000.0;\n        vec3 imp2 = imp;\n        int obj2 = -1;\n        shadowMarch(imp, dirToSun, obj, imp2, mid2, d2, obj2);\n        float shadow = S(0.0, 0.0001, mid2*mid2);\n        //shadow = 1.0;\n        \n        vec3 nm = normal(imp);\n        nm /= length(nm);\n        float vl = dot(nm, dirToSun);\n        vl = S(-0.8, 0.0, vl);\n        shadow = min(shadow+0.2, vl);\n        \n        vec3 toSunPr = nm * dot(nm, dirToSun);\n        vec3 reflV = 2.0*toSunPr-dirToSun;\n        float refl = -dot(reflV, ray);\n        float sunre = S(0.9, 1.0, refl);\n        refl *= .15;\n        refl += .85;\n        refl += sunre;\n        refl = min(1.2, refl);\n        \n        \n        shadow = shadow*0.4 + 0.6;\n        col *= shadow;\n        col *= refl;\n        \n    }\n    col = Lerp(sky, col, exp(-d/250.0));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n//Key code viewer: https://www.shadertoy.com/view/4tt3Wn\n\nconst int W = 87;\nconst int A = 65;\nconst int S = 83;\nconst int D = 68;\n\nconst int UP = 38;\nconst int DOWN = 40;\nconst int RIGHT = 39;\nconst int LEFT = 37;\n\nconst float M_PI = 3.14159265358979323846264338327950288;\n\nvec3 rad(vec3 deg) {\n    return deg/180.0*M_PI;\n}\n\nvec3 rotate(vec3 p, vec3 rt) {\n    float cx = cos(rt.x);\n    float sx = sin(rt.x);\n    mat3 rx = mat3(1.0, 0.0, 0.0,\n                   0.0, cx,  -sx,\n                   0.0, sx,  cx);\n    float cy = cos(rt.y);\n    float sy = sin(rt.y);\n    mat3 ry = mat3(cy,  0.0, sy,\n                   0.0, 1.0, 0.0,\n                   -sy, 0.0, cy );\n    float cz = cos(rt.z);\n    float sz = sin(rt.z);\n    mat3 rz = mat3(cz,  -sz, 0.0,\n                   sz,  cz,  0.0,\n                   0.0, 0.0, 1.0);\n    p *= rx;\n    p *= ry;\n    p *= rz;\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rot = texelFetch(iChannel0, ivec2(1, 0), 0).xyz;\n    float rots = .2;\n    if (length(fragCoord-fract(fragCoord.xy)-vec2(0.0, 0.0))<0.1) {\n        float speed = 5.0;\n        vec3 pos = texelFetch(iChannel0, ivec2(0, 0), 0).xyz*1000.0;\n        vec3 forward = vec3(1.0, 0.0, 0.0);\n        forward = rotate(forward, rad(rot*360.0));\n        vec3 right = vec3(0.0, 1.0, 0.0);\n        right = rotate(right, rad(rot*360.0));\n        if (texelFetch(iChannel1, ivec2(W, 0), 0).x > 0.5) {\n            pos += forward * speed * iTimeDelta;\n        } else if (texelFetch(iChannel1, ivec2(S, 0), 0).x > 0.5) {\n            pos += -forward * speed * iTimeDelta;\n        } else if (texelFetch(iChannel1, ivec2(A, 0), 0).x > 0.5) {\n            pos += -right * speed * iTimeDelta;\n        } else if (texelFetch(iChannel1, ivec2(D, 0), 0).x > 0.5) {\n            pos += right * speed * iTimeDelta;\n        } \n        fragColor = vec4(pos/1000.0, 1.0);\n    } else if (length(fragCoord-fract(fragCoord.xy)-vec2(1.0, 0.0))<0.1) {\n        if (texelFetch(iChannel1, ivec2(UP, 0), 0).x > 0.5) {\n            rot.y += -iTimeDelta * rots;\n        } else if (texelFetch(iChannel1, ivec2(DOWN, 0), 0).x > 0.5) {\n            rot.y += iTimeDelta * rots;\n        } else if (texelFetch(iChannel1, ivec2(RIGHT, 0), 0).x > 0.5) {\n            rot.z += iTimeDelta * rots;\n        } else if (texelFetch(iChannel1, ivec2(LEFT, 0), 0).x > 0.5) {\n            rot.z += -iTimeDelta * rots;\n        }\n        rot = fract(rot);\n        fragColor = vec4(rot, 1.0);\n    } else {\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}