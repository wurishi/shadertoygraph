{"ver":"0.1","info":{"id":"MtjSDV","date":"1446764691","viewed":313,"name":"SAT Collision Test","username":"kuvkar","description":"Shader implementation of SAT(Separating axis test). Can be used to detect collisions between convex polygons. Mouse to move the other object. Object vertex count can be changed from code.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["collision","sat"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"//////////////////////////////////////////////\n// Implementation of Separating Axis Test (SAT)\n// SAT test can be used to find collision between convex polygons. Visualization a bit lacking,\n// basicly the black lines coming out of the objects are showing the axis that were found to separate the objects, and \n// the gap between the objects in that axis.\n// reference: http://gamedevelopment.tutsplus.com/tutorials/collision-detection-using-the-separating-axis-theorem--gamedev-169\n///////////////////////////////////////////////\n\n// change this to have more vertices in the objects (more vertices will create more round objects)\n#define POINTS 3\n\n#define COL1 vec4(0.0, 1.0, 1.0, 0.0)\n#define COL2 vec4(1.0, 0.0, 1.0, 0.0)\n\n\nvec2 g_uv;    \nstruct Poly\n{\n    vec2 origin;\n\tvec2 points[POINTS];\n    vec2 normals[POINTS];\n};\n\nPoly polys[2];\n\nfloat drawvec(vec2 from, vec2 to)\n{\n    vec2 uvv = g_uv - from;\n    vec2 a = to - from;\n    if(dot(uvv, uvv) - dot(a, a) > 0.0) return 0.0;\n    float d = dot(normalize(uvv), normalize(a)) * length(uvv);\n    if(d < 0.0) return 0.0;\n    float b = length((d * normalize(a)) - uvv);\n    float w = 0.002;\n    return max(w - b, 0.0) / w;\n}\n\nfloat drawPoly(in Poly p)\n{\n    float x = 0.0;\n    for (int i = 0; i < POINTS - 1; ++i)\n    {\n\t    x += drawvec(p.origin + p.points[i], p.origin + p.points[i + 1]);\n    }\n    x += drawvec(p.origin + p.points[POINTS - 1], p.origin + p.points[0]);\n    return clamp(x, 0.0, 1.0);\n}\n\nvec2 rotate(vec2 point, float angle)\n{\n    float x = point.x; float y = point.y;\n    point.x = x * cos(angle) - y * sin(angle);\n    point.y = y * cos(angle) + x * sin(angle);\n    return point;\n}\n\nvoid rotate(inout Poly p, float angle)\n{\n    for (int i = 0; i < POINTS; ++i)\n    {\n\t    p.points[i] = rotate(p.points[i], angle);\n    }\n}\n\n// finds minimum and maximum values \n// (dot product between axis and the vertex position gives the projected length on that axis)\nvec2 minmax(in Poly p, in vec2 axis)\n{\n    float m = dot(p.origin + p.points[0], axis);\n    vec2 mm = vec2(m, m);\n    for (int i = 1; i < POINTS; ++i)\n    {\n        float d = dot(p.origin + p.points[i], axis);\n        mm.y = max(mm.y, d);\n        mm.x = min(mm.x, d);\n    }\n    return mm;\n}\n\nvoid calcNormals(inout Poly p)\n{\n    for (int i = 0; i < POINTS - 1; ++i)\n    {\n        p.normals[i] = (normalize(p.points[i] - p.points[i+1])).yx * vec2(-1.0, 1.0);\n    }\n    p.normals[POINTS - 1] = (normalize(p.points[POINTS - 1] - p.points[0])).yx * vec2(-1.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y /= iResolution.x / iResolution.y;\n    g_uv = uv;\n    \n\tconst int GRID = 30;\n    for (int i = 0; i < GRID; ++i)\n    {\n        float x = -0.5 + float(i) * 1.0 / float(GRID); \n        fragColor -= drawvec(vec2(x, -0.5), vec2(x, 0.5)) * (i == GRID / 2 ? 0.4 : 0.2);\n        fragColor -= drawvec(vec2(-0.5, x), vec2(0.5, x)) * (i == GRID / 2 ? 0.4 : 0.2);\n    }\n    \n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    m -= 0.5;\n    m.y /= iResolution.x / iResolution.y;\n    \n    if(iMouse.xy == vec2(0.0)) { m = vec2(0.0);}\n    \n    // creating polygons\n    float size = 0.1;\n    polys[0].origin = vec2(sin(iTime * 0.15) * 0.2, cos(iTime * 0.15) * 0.2);\n    polys[1].origin = m;\n\t    \n    float stp = (3.14159 * 2.0) / float(POINTS);\n    \n    for (int i = 0; i < POINTS; ++i)\n    {\n        polys[0].points[i] = vec2(rotate(vec2(size, size), float(i) * stp));\n        polys[1].points[i] = vec2(rotate(vec2(size, size), float(i) * stp));\n    }\n    \n    rotate(polys[0], iTime * 0.1);\n    rotate(polys[1], iTime * 0.2);\n    \n    calcNormals(polys[0]);\n    calcNormals(polys[1]);\n    \n    // the actual SAT test happens here.\n    bool hit = true;\n    float gap = 0.0;\n    for (int j = 0; j < 2; ++j)\n    {\n        for (int i = 0; i < POINTS; ++i)\n        {\n            vec2 axis = polys[j].normals[i];\n\n            vec2 minm1 = minmax(polys[0], axis);\n            vec2 minm2 = minmax(polys[1], axis);\n            \n            // values need to be swapped\n            // if maximum of first object is smaller than minimum of second object\n            if(minm1.y > minm2.x)\n            {\n                vec2 tmp = minm2;\n                minm2 = minm1;\n                minm1 = tmp;\n            }\n\n            float gap = minm2.x - minm1.y;\n            gap = max(gap, 0.0);\n            \n            \n            if(gap > 0.0)\n            {\n                hit = false;    \n            }\n            \n\t\t\t// some visualization         \n            fragColor -= drawvec(polys[j].origin, polys[j].origin + axis * gap);\n        }\n    }\n    \n    fragColor -= drawPoly(polys[0]) * (hit ? COL1 : COL2);\n    fragColor -= drawPoly(polys[1]) * (hit ? COL1 : COL2);        \n    \n    \n    \n}","name":"","description":"","type":"image"}]}