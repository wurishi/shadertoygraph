{"ver":"0.1","info":{"id":"NstGzl","date":"1630485639","viewed":48,"name":"old_sands","username":"dronn","description":"created with material maker","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["materialmaler"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//---\n\nfloat rand(vec2 x) {\n    return fract(cos(mod(dot(x, vec2(13.9898, 8.141)), 3.14)) * 43758.5453);\n}\n\nvec2 rand2(vec2 x) {\n    return fract(cos(mod(vec2(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t      dot(x, vec2(3.4562, 17.398))), vec2(3.14))) * 43758.5453);\n}\n\nvec3 rand3(vec2 x) {\n    return fract(cos(mod(vec3(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t\t  dot(x, vec2(3.4562, 17.398)),\n                              dot(x, vec2(13.254, 5.867))), vec3(3.14))) * 43758.5453);\n}\n\nvec3 rgb2hsv(vec3 c) {\n\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n\tvec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat fbm_value(vec2 coord, vec2 size, float seed) {\n\tvec2 o = floor(coord)+rand2(vec2(float(seed), 1.0-float(seed)))+size;\n\tvec2 f = fract(coord);\n\tfloat p00 = rand(mod(o, size));\n\tfloat p01 = rand(mod(o + vec2(0.0, 1.0), size));\n\tfloat p10 = rand(mod(o + vec2(1.0, 0.0), size));\n\tfloat p11 = rand(mod(o + vec2(1.0, 1.0), size));\n\tvec2 t = f * f * (3.0 - 2.0 * f);\n\treturn mix(mix(p00, p10, t.x), mix(p01, p11, t.x), t.y);\n}\n\nfloat fbm_perlin(vec2 coord, vec2 size, float seed) {\n\tvec2 o = floor(coord)+rand2(vec2(float(seed), 1.0-float(seed)))+size;\n\tvec2 f = fract(coord);\n\tfloat a00 = rand(mod(o, size)) * 6.28318530718;\n\tfloat a01 = rand(mod(o + vec2(0.0, 1.0), size)) * 6.28318530718;\n\tfloat a10 = rand(mod(o + vec2(1.0, 0.0), size)) * 6.28318530718;\n\tfloat a11 = rand(mod(o + vec2(1.0, 1.0), size)) * 6.28318530718;\n\tvec2 v00 = vec2(cos(a00), sin(a00));\n\tvec2 v01 = vec2(cos(a01), sin(a01));\n\tvec2 v10 = vec2(cos(a10), sin(a10));\n\tvec2 v11 = vec2(cos(a11), sin(a11));\n\tfloat p00 = dot(v00, f);\n\tfloat p01 = dot(v01, f - vec2(0.0, 1.0));\n\tfloat p10 = dot(v10, f - vec2(1.0, 0.0));\n\tfloat p11 = dot(v11, f - vec2(1.0, 1.0));\n\tvec2 t = f * f * (3.0 - 2.0 * f);\n\treturn 0.5 + mix(mix(p00, p10, t.x), mix(p01, p11, t.x), t.y);\n}\n\nfloat fbm_perlinabs(vec2 coord, vec2 size, float seed) {\n\treturn abs(2.0*fbm_perlin(coord, size, seed)-1.0);\n}\n\nvec2 rgrad2(vec2 p, float rot, float seed) {\n\tfloat u = rand(p + vec2(seed, 1.0-seed));\n\tu = fract(u) * 6.28318530718; // 2*pi\n\treturn vec2(cos(u), sin(u));\n}\n\nfloat fbm_simplex(vec2 coord, vec2 size, float seed) {\n\tcoord *= 2.0; // needed for it to tile\n\tcoord += rand2(vec2(seed, 1.0-seed)) + size;\n\tsize *= 2.0; // needed for it to tile\n\tcoord.y += 0.001;\n    vec2 uv = vec2(coord.x + coord.y*0.5, coord.y);\n    vec2 i0 = floor(uv);\n    vec2 f0 = fract(uv);\n    vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n    vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\n    vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n    i1 = i0 + i1;\n    vec2 i2 = i0 + vec2(1.0, 1.0);\n    vec2 d0 = coord - p0;\n    vec2 d1 = coord - p1;\n    vec2 d2 = coord - p2;\n    vec3 xw = mod(vec3(p0.x, p1.x, p2.x), size.x);\n    vec3 yw = mod(vec3(p0.y, p1.y, p2.y), size.y);\n    vec3 iuw = xw + 0.5 * yw;\n    vec3 ivw = yw;\n    vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), 0.0, seed);\n    vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), 0.0, seed);\n    vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), 0.0, seed);\n    vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\n    vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\n    t = max(t, vec3(0.0));\n    vec3 t2 = t * t;\n    vec3 t4 = t2 * t2;\n    float n = dot(t4, w);\n    return 0.5 + 5.5 * n;\n}\n\nfloat fbm_cellular(vec2 coord, vec2 size, float seed) {\n\tvec2 o = floor(coord)+rand2(vec2(float(seed), 1.0-float(seed)))+size;\n\tvec2 f = fract(coord);\n\tfloat min_dist = 2.0;\n\tfor(float x = -1.0; x <= 1.0; x++) {\n\t\tfor(float y = -1.0; y <= 1.0; y++) {\n\t\t\tvec2 node = rand2(mod(o + vec2(x, y), size)) + vec2(x, y);\n\t\t\tfloat dist = sqrt((f - node).x * (f - node).x + (f - node).y * (f - node).y);\n\t\t\tmin_dist = min(min_dist, dist);\n\t\t}\n\t}\n\treturn min_dist;\n}\n\nfloat fbm_cellular2(vec2 coord, vec2 size, float seed) {\n\tvec2 o = floor(coord)+rand2(vec2(float(seed), 1.0-float(seed)))+size;\n\tvec2 f = fract(coord);\n\tfloat min_dist1 = 2.0;\n\tfloat min_dist2 = 2.0;\n\tfor(float x = -1.0; x <= 1.0; x++) {\n\t\tfor(float y = -1.0; y <= 1.0; y++) {\n\t\t\tvec2 node = rand2(mod(o + vec2(x, y), size)) + vec2(x, y);\n\t\t\tfloat dist = sqrt((f - node).x * (f - node).x + (f - node).y * (f - node).y);\n\t\t\tif (min_dist1 > dist) {\n\t\t\t\tmin_dist2 = min_dist1;\n\t\t\t\tmin_dist1 = dist;\n\t\t\t} else if (min_dist2 > dist) {\n\t\t\t\tmin_dist2 = dist;\n\t\t\t}\n\t\t}\n\t}\n\treturn min_dist2-min_dist1;\n}\n\nfloat fbm_cellular3(vec2 coord, vec2 size, float seed) {\n\tvec2 o = floor(coord)+rand2(vec2(float(seed), 1.0-float(seed)))+size;\n\tvec2 f = fract(coord);\n\tfloat min_dist = 2.0;\n\tfor(float x = -1.0; x <= 1.0; x++) {\n\t\tfor(float y = -1.0; y <= 1.0; y++) {\n\t\t\tvec2 node = rand2(mod(o + vec2(x, y), size))*0.5 + vec2(x, y);\n\t\t\tfloat dist = abs((f - node).x) + abs((f - node).y);\n\t\t\tmin_dist = min(min_dist, dist);\n\t\t}\n\t}\n\treturn min_dist;\n}\n\nfloat fbm_cellular4(vec2 coord, vec2 size, float seed) {\n\tvec2 o = floor(coord)+rand2(vec2(float(seed), 1.0-float(seed)))+size;\n\tvec2 f = fract(coord);\n\tfloat min_dist1 = 2.0;\n\tfloat min_dist2 = 2.0;\n\tfor(float x = -1.0; x <= 1.0; x++) {\n\t\tfor(float y = -1.0; y <= 1.0; y++) {\n\t\t\tvec2 node = rand2(mod(o + vec2(x, y), size))*0.5 + vec2(x, y);\n\t\t\tfloat dist = abs((f - node).x) + abs((f - node).y);\n\t\t\tif (min_dist1 > dist) {\n\t\t\t\tmin_dist2 = min_dist1;\n\t\t\t\tmin_dist1 = dist;\n\t\t\t} else if (min_dist2 > dist) {\n\t\t\t\tmin_dist2 = dist;\n\t\t\t}\n\t\t}\n\t}\n\treturn min_dist2-min_dist1;\n}\n\nfloat fbm_cellular5(vec2 coord, vec2 size, float seed) {\n\tvec2 o = floor(coord)+rand2(vec2(float(seed), 1.0-float(seed)))+size;\n\tvec2 f = fract(coord);\n\tfloat min_dist = 2.0;\n\tfor(float x = -1.0; x <= 1.0; x++) {\n\t\tfor(float y = -1.0; y <= 1.0; y++) {\n\t\t\tvec2 node = rand2(mod(o + vec2(x, y), size)) + vec2(x, y);\n\t\t\tfloat dist = max(abs((f - node).x), abs((f - node).y));\n\t\t\tmin_dist = min(min_dist, dist);\n\t\t}\n\t}\n\treturn min_dist;\n}\n\nfloat fbm_cellular6(vec2 coord, vec2 size, float seed) {\n\tvec2 o = floor(coord)+rand2(vec2(float(seed), 1.0-float(seed)))+size;\n\tvec2 f = fract(coord);\n\tfloat min_dist1 = 2.0;\n\tfloat min_dist2 = 2.0;\n\tfor(float x = -1.0; x <= 1.0; x++) {\n\t\tfor(float y = -1.0; y <= 1.0; y++) {\n\t\t\tvec2 node = rand2(mod(o + vec2(x, y), size)) + vec2(x, y);\n\t\t\tfloat dist = max(abs((f - node).x), abs((f - node).y));\n\t\t\tif (min_dist1 > dist) {\n\t\t\t\tmin_dist2 = min_dist1;\n\t\t\t\tmin_dist1 = dist;\n\t\t\t} else if (min_dist2 > dist) {\n\t\t\t\tmin_dist2 = dist;\n\t\t\t}\n\t\t}\n\t}\n\treturn min_dist2-min_dist1;\n}\nfloat wave_constant(float x) {\n\treturn 1.0;\n}\n\nfloat wave_sine(float x) {\n\treturn 0.5-0.5*cos(3.14159265359*2.0*x);\n}\n\nfloat wave_triangle(float x) {\n\tx = fract(x);\n\treturn min(2.0*x, 2.0-2.0*x);\n}\n\nfloat wave_sawtooth(float x) {\n\treturn fract(x);\n}\n\nfloat wave_square(float x) {\n\treturn (fract(x) < 0.5) ? 0.0 : 1.0;\n}\n\nfloat wave_bounce(float x) {\n\tx = 2.0*(fract(x)-0.5);\n\treturn sqrt(1.0-x*x);\n}\n\nfloat mix_mul(float x, float y) {\n\treturn x*y;\n}\n\nfloat mix_add(float x, float y) {\n\treturn min(x+y, 1.0);\n}\n\nfloat mix_max(float x, float y) {\n\treturn max(x, y);\n}\n\nfloat mix_min(float x, float y) {\n\treturn min(x, y);\n}\n\nfloat mix_xor(float x, float y) {\n\treturn min(x+y, 2.0-x-y);\n}\n\nfloat mix_pow(float x, float y) {\n\treturn pow(x, y);\n}vec4 brick(vec2 uv, vec2 bmin, vec2 bmax, float mortar, float round, float bevel) {\n\tfloat color;\n\tvec2 size = bmax - bmin;\n\tfloat min_size = min(size.x, size.y);\n\tmortar *= min_size;\n\tbevel *= min_size;\n\tround *= min_size;\n\tvec2 center = 0.5*(bmin+bmax);\n    vec2 d = abs(uv-center)-0.5*(size)+vec2(round+mortar);\n    color = length(max(d,vec2(0))) + min(max(d.x,d.y),0.0)-round;\n\tcolor = clamp(-color/bevel, 0.0, 1.0);\n\tvec2 tiled_brick_pos = mod(bmin, vec2(1.0, 1.0));\n\treturn vec4(color, center, tiled_brick_pos.x+7.0*tiled_brick_pos.y);\n}\n\nvec3 brick_random_color(vec2 bmin, vec2 bmax, float seed) {\n\tvec2 center = 0.5*(bmin + bmax);\n\treturn rand3(fract(center + vec2(seed)));\n}\n\nvec3 brick_uv(vec2 uv, vec2 bmin, vec2 bmax, float seed) {\n\tvec2 center = 0.5*(bmin + bmax);\n\tvec2 size = bmax - bmin;\n\tfloat max_size = max(size.x, size.y);\n\treturn vec3(0.5+(uv-center)/max_size, rand(fract(center)+vec2(seed)));\n}\n\nvec3 brick_corner_uv(vec2 uv, vec2 bmin, vec2 bmax, float mortar, float corner, float seed) {\n\tvec2 center = 0.5*(bmin + bmax);\n\tvec2 size = bmax - bmin;\n\tfloat max_size = max(size.x, size.y);\n\tfloat min_size = min(size.x, size.y);\n\tmortar *= min_size;\n\tcorner *= min_size;\n\treturn vec3(clamp((0.5*size-vec2(mortar)-abs(uv-center))/corner, vec2(0.0), vec2(1.0)), rand(fract(center)+vec2(seed)+ceil(vec2(uv-center))));\n}\n\nvec4 bricks_rb(vec2 uv, vec2 count, float repeat, float offset) {\n\tcount *= repeat;\n\tfloat x_offset = offset*step(0.5, fract(uv.y*count.y*0.5));\n\tvec2 bmin = floor(vec2(uv.x*count.x-x_offset, uv.y*count.y));\n\tbmin.x += x_offset;\n\tbmin /= count;\n\treturn vec4(bmin, bmin+vec2(1.0)/count);\n}\n\nvec4 bricks_rb2(vec2 uv, vec2 count, float repeat, float offset) {\n\tcount *= repeat;\n\tfloat x_offset = offset*step(0.5, fract(uv.y*count.y*0.5));\n\tcount.x = count.x*(1.0+step(0.5, fract(uv.y*count.y*0.5)));\n\tvec2 bmin = floor(vec2(uv.x*count.x-x_offset, uv.y*count.y));\n\tbmin.x += x_offset;\n\tbmin /= count;\n\treturn vec4(bmin, bmin+vec2(1.0)/count);\n}\n\nvec4 bricks_hb(vec2 uv, vec2 count, float repeat, float offset) {\n\tfloat pc = count.x+count.y;\n\tfloat c = pc*repeat;\n\tvec2 corner = floor(uv*c);\n\tfloat cdiff = mod(corner.x-corner.y, pc);\n\tif (cdiff < count.x) {\n\t\treturn vec4((corner-vec2(cdiff, 0.0))/c, (corner-vec2(cdiff, 0.0)+vec2(count.x, 1.0))/c);\n\t} else {\n\t\treturn vec4((corner-vec2(0.0, pc-cdiff-1.0))/c, (corner-vec2(0.0, pc-cdiff-1.0)+vec2(1.0, count.y))/c);\n\t}\n}\n\nvec4 bricks_bw(vec2 uv, vec2 count, float repeat, float offset) {\n\tvec2 c = 2.0*count*repeat;\n\tfloat mc = max(c.x, c.y);\n\tvec2 corner1 = floor(uv*c);\n\tvec2 corner2 = count*floor(repeat*2.0*uv);\n\tfloat cdiff = mod(dot(floor(repeat*2.0*uv), vec2(1.0)), 2.0);\n\tvec2 corner;\n\tvec2 size;\n\tif (cdiff == 0.0) {\n\t\tcorner = vec2(corner1.x, corner2.y);\n\t\tsize = vec2(1.0, count.y);\n\t} else {\n\t\tcorner = vec2(corner2.x, corner1.y);\n\t\tsize = vec2(count.x, 1.0);\n\t}\n\treturn vec4(corner/c, (corner+size)/c);\n}\n\nvec4 bricks_sb(vec2 uv, vec2 count, float repeat, float offset) {\n\tvec2 c = (count+vec2(1.0))*repeat;\n\tfloat mc = max(c.x, c.y);\n\tvec2 corner1 = floor(uv*c);\n\tvec2 corner2 = (count+vec2(1.0))*floor(repeat*uv);\n\tvec2 rcorner = corner1 - corner2;\n\tvec2 corner;\n\tvec2 size;\n\tif (rcorner.x == 0.0 && rcorner.y < count.y) {\n\t\tcorner = corner2;\n\t\tsize = vec2(1.0, count.y);\n\t} else if (rcorner.y == 0.0) {\n\t\tcorner = corner2+vec2(1.0, 0.0);\n\t\tsize = vec2(count.x, 1.0);\n\t} else if (rcorner.x == count.x) {\n\t\tcorner = corner2+vec2(count.x, 1.0);\n\t\tsize = vec2(1.0, count.y);\n\t} else if (rcorner.y == count.y) {\n\t\tcorner = corner2+vec2(0.0, count.y);\n\t\tsize = vec2(count.x, 1.0);\n\t} else {\n\t\tcorner = corner2+vec2(1.0);\n\t\tsize = vec2(count.x-1.0, count.y-1.0);\n\t}\n\treturn vec4(corner/c, (corner+size)/c);\n}vec2 transform(vec2 uv, vec2 translate, float rotate, vec2 scale, bool repeat) {\n \tvec2 rv;\n\tuv -= translate;\n\tuv -= vec2(0.5);\n\trv.x = cos(rotate)*uv.x + sin(rotate)*uv.y;\n\trv.y = -sin(rotate)*uv.x + cos(rotate)*uv.y;\n\trv /= scale;\n\trv += vec2(0.5);\n    if (repeat) {\n\t\treturn fract(rv);\n\t} else {\n\t\treturn clamp(rv, vec2(0.0), vec2(1.0));\n\t}\t\n}vec3 blend_normal(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*c1 + (1.0-opacity)*c2;\n}\n\nvec3 blend_dissolve(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\tif (rand(uv) < opacity) {\n\t\treturn c1;\n\t} else {\n\t\treturn c2;\n\t}\n}\n\nvec3 blend_multiply(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*c1*c2 + (1.0-opacity)*c2;\n}\n\nvec3 blend_screen(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*(1.0-(1.0-c1)*(1.0-c2)) + (1.0-opacity)*c2;\n}\n\nfloat blend_overlay_f(float c1, float c2) {\n\treturn (c1 < 0.5) ? (2.0*c1*c2) : (1.0-2.0*(1.0-c1)*(1.0-c2));\n}\n\nvec3 blend_overlay(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blend_overlay_f(c1.x, c2.x), blend_overlay_f(c1.y, c2.y), blend_overlay_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nvec3 blend_hard_light(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*0.5*(c1*c2+blend_overlay(uv, c1, c2, 1.0)) + (1.0-opacity)*c2;\n}\n\nfloat blend_soft_light_f(float c1, float c2) {\n\treturn (c2 < 0.5) ? (2.0*c1*c2+c1*c1*(1.0-2.0*c2)) : 2.0*c1*(1.0-c2)+sqrt(c1)*(2.0*c2-1.0);\n}\n\nvec3 blend_soft_light(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blend_soft_light_f(c1.x, c2.x), blend_soft_light_f(c1.y, c2.y), blend_soft_light_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nfloat blend_burn_f(float c1, float c2) {\n\treturn (c1==0.0)?c1:max((1.0-((1.0-c2)/c1)),0.0);\n}\n\nvec3 blend_burn(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blend_burn_f(c1.x, c2.x), blend_burn_f(c1.y, c2.y), blend_burn_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nfloat blend_dodge_f(float c1, float c2) {\n\treturn (c1==1.0)?c1:min(c2/(1.0-c1),1.0);\n}\n\nvec3 blend_dodge(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blend_dodge_f(c1.x, c2.x), blend_dodge_f(c1.y, c2.y), blend_dodge_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nvec3 blend_lighten(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*max(c1, c2) + (1.0-opacity)*c2;\n}\n\nvec3 blend_darken(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*min(c1, c2) + (1.0-opacity)*c2;\n}\n\nvec3 blend_difference(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*clamp(c2-c1, vec3(0.0), vec3(1.0)) + (1.0-opacity)*c2;\n}\nvec2 scale(vec2 uv, vec2 center, vec2 scale) {\n\tuv -= center;\n\tuv /= scale;\n\tuv += center;\n    return uv;\n}vec3 color_dots(vec2 uv, float size, int seed) {\n\tvec2 seed2 = rand2(vec2(float(seed), 1.0-float(seed)));\n\tuv /= size;\n\tvec2 point_pos = floor(uv)+vec2(0.5);\n\treturn rand3(seed2+point_pos);\n}vec3 rgb_to_hsv(vec3 c) {\n\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n\tvec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv_to_rgb(vec3 c) {\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nconst float p_o8424_amount = 0.500000000;\nconst float p_o8367_cx = 0.000000000;\nconst float p_o8367_cy = 0.000000000;\nconst float p_o8367_scale_x = 1.705000000;\nconst float p_o8367_scale_y = 0.250000000;\nconst float p_o8342_amount = 0.925000000;\nconst float p_o8342_eps = 0.315000000;\nconst int seed_o8341 = 42468;\nconst float p_o8341_scale_x = 4.000000000;\nconst float p_o8341_scale_y = 5.000000000;\nconst float p_o8341_folds = 0.000000000;\nconst float p_o8341_iterations = 4.000000000;\nconst float p_o8341_persistence = 0.720000000;\nfloat o8341_fbm(vec2 coord, vec2 size, int folds, int octaves, float persistence, float seed) {\n\tfloat normalize_factor = 0.0;\n\tfloat value = 0.0;\n\tfloat scale = 1.0;\n\tfor (int i = 0; i < octaves; i++) {\n\t\tfloat noise = fbm_value(coord*size, size, seed);\n\t\tfor (int f = 0; f < folds; ++f) {\n\t\t\tnoise = abs(2.0*noise-1.0);\n\t\t}\n\t\tvalue += noise * scale;\n\t\tnormalize_factor += scale;\n\t\tsize *= 2.0;\n\t\tscale *= persistence;\n\t}\n\treturn value / normalize_factor;\n}\nfloat o8342_input_d(vec2 uv) {\nfloat o8341_0_1_f = o8341_fbm((uv), vec2(p_o8341_scale_x, p_o8341_scale_y), int(p_o8341_folds), int(p_o8341_iterations), p_o8341_persistence, float(seed_o8341));\n\nreturn o8341_0_1_f;\n}\nvec2 o8342_slope(vec2 uv, float epsilon) {\n\treturn vec2(o8342_input_d(fract(uv+vec2(epsilon, 0.0)))-o8342_input_d(fract(uv-vec2(epsilon, 0.0))), o8342_input_d(fract(uv+vec2(0.0, epsilon)))-o8342_input_d(fract(uv-vec2(0.0, epsilon))));\n}const float p_o8385_amount = 1.000000000;\nconst float p_o8386_x_scale = 1.000000000;\nconst float p_o8386_y_scale = 4.000000000;\nfloat o8386_fct(vec2 uv) {\n\treturn mix_mul(wave_sine(p_o8386_x_scale*uv.x), wave_constant(p_o8386_y_scale*uv.y));\n}const float p_o8369_translate_x = 0.975000000;\nconst float p_o8369_translate_y = 0.000000000;\nconst float p_o8369_rotate = 30.125000000;\nconst float p_o8369_scale_x = 0.500000000;\nconst float p_o8369_scale_y = 1.000000000;\nconst int seed_o8383 = -50677;\nconst float p_o8383_repeat = 1.000000000;\nconst float p_o8383_rows = 1.000000000;\nconst float p_o8383_columns = 1.000000000;\nconst float p_o8383_row_offset = 0.500000000;\nconst float p_o8383_mortar = 0.100000000;\nconst float p_o8383_bevel = 0.100000000;\nconst float p_o8383_round = 0.000000000;\nconst float p_o8383_corner = 0.000000000;\nconst float p_o8370_gradient_0_pos = 0.000000000;\nconst float p_o8370_gradient_0_r = 0.437500000;\nconst float p_o8370_gradient_0_g = 0.437500000;\nconst float p_o8370_gradient_0_b = 0.437500000;\nconst float p_o8370_gradient_0_a = 1.000000000;\nconst float p_o8370_gradient_1_pos = 1.000000000;\nconst float p_o8370_gradient_1_r = 1.000000000;\nconst float p_o8370_gradient_1_g = 1.000000000;\nconst float p_o8370_gradient_1_b = 1.000000000;\nconst float p_o8370_gradient_1_a = 1.000000000;\nvec4 o8370_gradient_gradient_fct(float x) {\n  if (x < p_o8370_gradient_0_pos) {\n    return vec4(p_o8370_gradient_0_r,p_o8370_gradient_0_g,p_o8370_gradient_0_b,p_o8370_gradient_0_a);\n  } else if (x < p_o8370_gradient_1_pos) {\n    return mix(vec4(p_o8370_gradient_0_r,p_o8370_gradient_0_g,p_o8370_gradient_0_b,p_o8370_gradient_0_a), vec4(p_o8370_gradient_1_r,p_o8370_gradient_1_g,p_o8370_gradient_1_b,p_o8370_gradient_1_a), ((x-p_o8370_gradient_0_pos)/(p_o8370_gradient_1_pos-p_o8370_gradient_0_pos)));\n  }\n  return vec4(p_o8370_gradient_1_r,p_o8370_gradient_1_g,p_o8370_gradient_1_b,p_o8370_gradient_1_a);\n}\nconst float p_o8384_x_scale = 1.000000000;\nconst float p_o8384_y_scale = 4.000000000;\nfloat o8384_fct(vec2 uv) {\n\treturn mix_mul(wave_sine(p_o8384_x_scale*uv.x), wave_constant(p_o8384_y_scale*uv.y));\n}const float p_o8425_hue = 0.000000000;\nconst float p_o8425_saturation = 0.531882000;\nconst float p_o8425_value = 1.000000000;\nvec4 o8425_f(vec4 c) {\n\tvec3 hsv = rgb_to_hsv(c.rgb);\n\treturn vec4(hsv_to_rgb(vec3(fract(hsv.x+p_o8425_hue), clamp(hsv.y*p_o8425_saturation, 0.0, 1.0), clamp(hsv.z*p_o8425_value, 0.0, 1.0))), c.a);\n}const float p_o8408_gradient_0_pos = 0.000000000;\nconst float p_o8408_gradient_0_r = 1.000000000;\nconst float p_o8408_gradient_0_g = 0.000000000;\nconst float p_o8408_gradient_0_b = 0.000000000;\nconst float p_o8408_gradient_0_a = 1.000000000;\nconst float p_o8408_gradient_1_pos = 0.652283000;\nconst float p_o8408_gradient_1_r = 1.000000000;\nconst float p_o8408_gradient_1_g = 0.968750000;\nconst float p_o8408_gradient_1_b = 0.000000000;\nconst float p_o8408_gradient_1_a = 1.000000000;\nconst float p_o8408_gradient_2_pos = 0.744552000;\nconst float p_o8408_gradient_2_r = 0.843750000;\nconst float p_o8408_gradient_2_g = 0.000000000;\nconst float p_o8408_gradient_2_b = 1.000000000;\nconst float p_o8408_gradient_2_a = 1.000000000;\nconst float p_o8408_gradient_3_pos = 0.888080000;\nconst float p_o8408_gradient_3_r = 0.000000000;\nconst float p_o8408_gradient_3_g = 0.062500000;\nconst float p_o8408_gradient_3_b = 1.000000000;\nconst float p_o8408_gradient_3_a = 1.000000000;\nconst float p_o8408_gradient_4_pos = 1.000000000;\nconst float p_o8408_gradient_4_r = 0.000000000;\nconst float p_o8408_gradient_4_g = 1.000000000;\nconst float p_o8408_gradient_4_b = 0.125000000;\nconst float p_o8408_gradient_4_a = 1.000000000;\nvec4 o8408_gradient_gradient_fct(float x) {\n  if (x < p_o8408_gradient_0_pos) {\n    return vec4(p_o8408_gradient_0_r,p_o8408_gradient_0_g,p_o8408_gradient_0_b,p_o8408_gradient_0_a);\n  } else if (x < p_o8408_gradient_1_pos) {\n    return mix(vec4(p_o8408_gradient_0_r,p_o8408_gradient_0_g,p_o8408_gradient_0_b,p_o8408_gradient_0_a), vec4(p_o8408_gradient_1_r,p_o8408_gradient_1_g,p_o8408_gradient_1_b,p_o8408_gradient_1_a), 0.5-0.5*cos(3.14159265359*(x-p_o8408_gradient_0_pos)/(p_o8408_gradient_1_pos-p_o8408_gradient_0_pos)));\n  } else if (x < p_o8408_gradient_2_pos) {\n    return mix(vec4(p_o8408_gradient_1_r,p_o8408_gradient_1_g,p_o8408_gradient_1_b,p_o8408_gradient_1_a), vec4(p_o8408_gradient_2_r,p_o8408_gradient_2_g,p_o8408_gradient_2_b,p_o8408_gradient_2_a), 0.5-0.5*cos(3.14159265359*(x-p_o8408_gradient_1_pos)/(p_o8408_gradient_2_pos-p_o8408_gradient_1_pos)));\n  } else if (x < p_o8408_gradient_3_pos) {\n    return mix(vec4(p_o8408_gradient_2_r,p_o8408_gradient_2_g,p_o8408_gradient_2_b,p_o8408_gradient_2_a), vec4(p_o8408_gradient_3_r,p_o8408_gradient_3_g,p_o8408_gradient_3_b,p_o8408_gradient_3_a), 0.5-0.5*cos(3.14159265359*(x-p_o8408_gradient_2_pos)/(p_o8408_gradient_3_pos-p_o8408_gradient_2_pos)));\n  } else if (x < p_o8408_gradient_4_pos) {\n    return mix(vec4(p_o8408_gradient_3_r,p_o8408_gradient_3_g,p_o8408_gradient_3_b,p_o8408_gradient_3_a), vec4(p_o8408_gradient_4_r,p_o8408_gradient_4_g,p_o8408_gradient_4_b,p_o8408_gradient_4_a), 0.5-0.5*cos(3.14159265359*(x-p_o8408_gradient_3_pos)/(p_o8408_gradient_4_pos-p_o8408_gradient_3_pos)));\n  }\n  return vec4(p_o8408_gradient_4_r,p_o8408_gradient_4_g,p_o8408_gradient_4_b,p_o8408_gradient_4_a);\n}\nconst int seed_o8407 = -35741;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\nfloat minSize = min(iResolution.x, iResolution.y);\nvec2 UV = vec2(0.0, 1.0) + vec2(1.0, -1.0) * (fragCoord-0.5*(iResolution.xy-vec2(minSize)))/minSize;\nvec2 o8342_0_slope = o8342_slope((scale((UV), vec2(0.5+p_o8367_cx, 0.5+p_o8367_cy), vec2(p_o8367_scale_x, p_o8367_scale_y))), p_o8342_eps);\nvec2 o8342_0_warp = o8342_0_slope;float o8386_0_1_f = o8386_fct(((scale((UV), vec2(0.5+p_o8367_cx, 0.5+p_o8367_cy), vec2(p_o8367_scale_x, p_o8367_scale_y)))+p_o8342_amount*o8342_0_warp));\nvec4 o8383_0_rect = bricks_rb(((scale((UV), vec2(0.5+p_o8367_cx, 0.5+p_o8367_cy), vec2(p_o8367_scale_x, p_o8367_scale_y)))+p_o8342_amount*o8342_0_warp), vec2(p_o8383_columns, p_o8383_rows), p_o8383_repeat, p_o8383_row_offset);\nvec4 o8383_0 = brick(((scale((UV), vec2(0.5+p_o8367_cx, 0.5+p_o8367_cy), vec2(p_o8367_scale_x, p_o8367_scale_y)))+p_o8342_amount*o8342_0_warp), o8383_0_rect.xy, o8383_0_rect.zw, p_o8383_mortar*1.0, p_o8383_round*1.0, max(0.001, p_o8383_bevel*1.0));\nvec3 o8383_1_2_rgb = brick_random_color(o8383_0_rect.xy, o8383_0_rect.zw, float(seed_o8383));\nfloat o8384_0_1_f = o8384_fct((transform(((scale((UV), vec2(0.5+p_o8367_cx, 0.5+p_o8367_cy), vec2(p_o8367_scale_x, p_o8367_scale_y)))+p_o8342_amount*o8342_0_warp), vec2(p_o8369_translate_x*(2.0*(dot(o8383_1_2_rgb, vec3(1.0))/3.0)-1.0), p_o8369_translate_y*(2.0*1.0-1.0)), p_o8369_rotate*0.01745329251*(2.0*1.0-1.0), vec2(p_o8369_scale_x*(2.0*1.0-1.0), p_o8369_scale_y*(2.0*1.0-1.0)), true)));\nvec4 o8370_0_1_rgba = o8370_gradient_gradient_fct(o8384_0_1_f);\nvec4 o8369_0_1_rgba = o8370_0_1_rgba;\nvec4 o8385_0_s1 = vec4(vec3(o8386_0_1_f), 1.0);\nvec4 o8385_0_s2 = o8369_0_1_rgba;\nfloat o8385_0_a = p_o8385_amount*1.0;\nvec4 o8385_0_2_rgba = vec4(blend_multiply(((scale((UV), vec2(0.5+p_o8367_cx, 0.5+p_o8367_cy), vec2(p_o8367_scale_x, p_o8367_scale_y)))+p_o8342_amount*o8342_0_warp), o8385_0_s1.rgb, o8385_0_s2.rgb, o8385_0_a*o8385_0_s1.a), min(1.0, o8385_0_s2.a+o8385_0_a*o8385_0_s1.a));\nvec4 o8342_0_1_rgba = o8385_0_2_rgba;\nvec4 o8367_0_1_rgba = o8342_0_1_rgba;\nvec3 o8407_0_1_rgb = color_dots((UV), 1.0/512.000000000, seed_o8407);\nvec4 o8408_0_1_rgba = o8408_gradient_gradient_fct((dot(o8407_0_1_rgb, vec3(1.0))/3.0));\nvec4 o8425_0_1_rgba = o8425_f(o8408_0_1_rgba);\nvec4 o8424_0_s1 = o8367_0_1_rgba;\nvec4 o8424_0_s2 = o8425_0_1_rgba;\nfloat o8424_0_a = p_o8424_amount*1.0;\nvec4 o8424_0_2_rgba = vec4(blend_normal((UV), o8424_0_s1.rgb, o8424_0_s2.rgb, o8424_0_a*o8424_0_s1.a), min(1.0, o8424_0_s2.a+o8424_0_a*o8424_0_s1.a));\nfragColor = o8424_0_2_rgba;\n}\n","name":"Image","description":"","type":"image"}]}