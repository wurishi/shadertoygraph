{"ver":"0.1","info":{"id":"clSBWK","date":"1694477065","viewed":52,"name":"Landscape X","username":"Domenic3000","description":"Vaporwave landscape.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["simple","landscape","vaporwave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float noisea(vec2 pos) {\n    return fract(sin(dot(pos, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat fade(float t) {\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nint hash(vec3 p) {\n    vec3 hashVec = vec3(dot(p, vec3(127.1, 311.7, 419.2)),\n                        dot(p, vec3(269.5, 183.3, 372.9)),\n                        dot(p, vec3(416.8, 238.7, 144.2)));\n    float hashValue = fract(sin(hashVec.x + hashVec.y + hashVec.z) * 43758.5453123);\n    return int(mod(hashValue * 12.0, 12.0));\n}\n\nfloat grad(int hash, vec3 p) {\n    // 12 possible 3D gradient directions\n        const vec3[12] gradients = vec3[12](\n        vec3(1,1,0),vec3(-1,1,0),vec3(1,-1,0),vec3(-1,-1,0),\n        vec3(1,0,1),vec3(-1,0,1),vec3(1,0,-1),vec3(-1,0,-1),\n        vec3(0,1,1),vec3(0,-1,1),vec3(0,1,-1),vec3(0,-1,-1));\n\n    // Reduce the hash to one of the 12 gradient directions\n    int h = hash & 11;\n\n    // Compute the dot product\n    return dot(gradients[h], p);\n}\n\nfloat noise(vec3 p) {\n    vec3 Pi = floor(p);\n    vec3 Pf = p - Pi;\n    int ix0 = int(Pi.x);\n    int ix1 = ix0 + 1;\n    int iy0 = int(Pi.y);\n    int iy1 = iy0 + 1;\n    int iz0 = int(Pi.z);\n    int iz1 = iz0 + 1;\n    float n000 = grad(hash(vec3(ix0, iy0, iz0)), Pf);\n    float n001 = grad(hash(vec3(ix0, iy0, iz1)), Pf - vec3(0, 0, 1));\n    float n010 = grad(hash(vec3(ix0, iy1, iz0)), Pf - vec3(0, 1, 0));\n    float n011 = grad(hash(vec3(ix0, iy1, iz1)), Pf - vec3(0, 1, 1));\n    float n100 = grad(hash(vec3(ix1, iy0, iz0)), Pf - vec3(1, 0, 0));\n    float n101 = grad(hash(vec3(ix1, iy0, iz1)), Pf - vec3(1, 0, 1));\n    float n110 = grad(hash(vec3(ix1, iy1, iz0)), Pf - vec3(1, 1, 0));\n    float n111 = grad(hash(vec3(ix1, iy1, iz1)), Pf - vec3(1, 1, 1));\n    float fadePfX = fade(Pf.x);\n    float fadePfY = fade(Pf.y);\n    float fadePfZ = fade(Pf.z);\n    float nx00 = mix(n000, n100, fadePfX);\n    float nx01 = mix(n001, n101, fadePfX);\n    float nx10 = mix(n010, n110, fadePfX);\n    float nx11 = mix(n011, n111, fadePfX);\n    float nxy0 = mix(nx00, nx10, fadePfY);\n    float nxy1 = mix(nx01, nx11, fadePfY);\n\n    return mix(nxy0, nxy1, fadePfZ);\n}\n\n\nfloat layeredNoise(vec3 p) {\n    float total = 0.7;\n    float frequency = 0.2;\n    float amplitude = 1.0;\n    float maxAmplitude = 0.8;\n    for(int i = 0; i < 3; i++) { // 3 octaves for example, adjust as needed\n        total += noise(p * frequency) * amplitude;\n        maxAmplitude += amplitude;\n        frequency *= 2.0;\n        amplitude *= 0.5; // each octave has half the amplitude of the previous\n    }\n    return total / maxAmplitude;\n}\n\nfloat grid(vec2 uv, float battery)\n{\n    vec2 size = vec2(uv.y, uv.y * uv.y * 0.2) * 0.01;\n    uv += vec2(0.0, iTime * 4.0 * (battery + 0.05));\n    uv = abs(fract(uv) - 0.5);\n \tvec2 lines = smoothstep(size, vec2(0.0), uv);\n \tlines += smoothstep(size * 5.0, vec2(0.0), uv) * 0.4 * battery;\n    return clamp(lines.x + lines.y, 0.0, 3.0);\n}\n\nvec3 clouds(vec2 uv) {\n    // You can tweak these numbers to get the look you want.\n    float scale = 50.2;\n    float speed = 0.1;\n    vec3 cloudColor = vec3(0.5, 0.5, 0.7);  // Pastel color for clouds.\n    \n    float n = noisea(uv * scale + vec2(iTime * speed, 0.0));\n    n += noisea(uv * (scale*2.0) + vec2(iTime * speed, 0.0)) * 0.5;\n    n += noisea(uv * (scale*4.0) + vec2(iTime * speed, 0.0)) * 0.25;\n    \n    return mix(vec3(0.0), cloudColor, n);\n}\n\nvec3 bloom(vec2 uv, vec3 col) {\n    // Sample around the pixel\n    vec3 bloomColor = vec3(0.0);\n    float kernel[3] = float[](0.6, 0.2, 0.1); // Basic kernel\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n            vec2 offset = vec2(i, j) * 0.01; // Change 0.01 to adjust the blur size\n            bloomColor += texture(iChannel0, uv + offset).rgb * kernel[abs(i) + abs(j)];\n        }\n    }\n\n    col += bloomColor; // Add bloom on top\n    return clamp(col, 0.0, 1.0); // Make sure the colors don't go out of bounds\n}\n\n\nvec3 sun(vec2 uv, vec2 center, float radius)\n{\n    float dist = length(uv - center);\n    vec3 sunColor = vec3(1.000,0.451,0.000); // Reddish sun color\n    float sunMask = smoothstep(0.00, 0.08, radius - dist);\n\n    // Moving Transparent Lines\n    float lineSpeed = 0.1;\n    float lineDist = mod(uv.y + iTime * lineSpeed, 0.1) / 0.1;\n\n    // Making lines bigger as they move down\n    float lineSizeFactor = mix(0.0, 3.5, uv.y * 0.6 + 0.3); \n    float upperBound = 0.95 * lineSizeFactor;\n    float lowerBound = 0.3 * lineSizeFactor;\n\n    float lineMask = step(lowerBound, lineDist) * step(lineDist, upperBound);\n\n    vec3 color;\n    if (lineMask > 0.5) { // When the lineMask is active (greater than 0.5)\n        color = vec3(0.000,0.000,0.000); // Make it black\n    } else {\n        color = sunColor;\n    }\n\n    color *= sunMask;\n\n    return color;\n}\n\n\nfloat mountainShape(float x) {\n    const float PI = 3.14159265359;\n    float repeated = mod(x, PI) / PI;  // Repeat every [0, 1] interval\n    return pow(abs(cos(repeated * PI)), 3.05);\n}\n\nfloat adjustContrastAndBrightness(float n, float contrast, float brightness) {\n    return (n - 0.5) * contrast + 0.5 + brightness;\n}\n\nfloat crackedTexture(vec2 uv) {\n    const int GRADIENT_LENGTH = 5;\n\n    const float gradientValues[GRADIENT_LENGTH] = float[](\n        0.2,  // Gray1\n        0.4,  // Gray2\n        0.6,  // Gray3\n        0.8,  // Gray4\n        1.0   // Gray5\n    );\n\n    uv = uv * 2.0 - 1.0;\n    float scale = 8.0; \n    float n = layeredNoise(vec3(uv * scale, 0.0));\n\n    // Adjust contrast and brightness (adjust these as needed)\n    n = adjustContrastAndBrightness(n, 2.0, 0.4);\n    \n    // Ensure the noise value stays between 0 and 1\n    n = clamp(n, 0.0, 1.0);\n\n    // Gradient sampling for sharp transitions\n    float scaledNoise = n * float(GRADIENT_LENGTH - 1);\n    int index = int(scaledNoise);\n\n    float cracks = gradientValues[index];\n\n    return cracks;\n}\n\n\n\n\n\nvec3 mountains(vec2 uv) {  \n    uv.x -= iTime * 0.05;  // The 0.05 value determines the speed of the scrolling. Adjust as needed.\n    \n    float modulation = 0.29 * sin(uv.x * 3.0) + 0.3; // Modulating factor varying between 0 and 1.\n    \n    // Getting the base mountain shape with sharp peaks using the mountainShape function\n    float baseShape = mountainShape(uv.x * 3.0) * 0.2 + mountainShape(uv.x * 8.0) * 0.05 + 0.25;\n    \n    // Modulating the base mountain shape with the sine function for height variation\n    float mountainHeight = baseShape * modulation * 1.4;\n    float cracks = crackedTexture(uv);  // Get the cracked texture value\n    vec3 crackedColor = vec3(0.000,0.000,0.000);  // A dark color to represent cracks\n    \n    vec3 baseMountainColor = vec3(1.000,0.000,0.816); \n    vec3 gradientMountainColor = vec3(0.537,0.800,0.141);\n    vec3 outlineColor = vec3(0.204,0.043,0.996); // Outline color\n\n    // Check the height value slightly below and above the current point\n    float below = mountainHeight - (uv.y - 0.005);\n    float above = mountainHeight - (uv.y + 0.005);\n\n    float outlineMask = float((below < 0.0 && above > 0.0) || (below > 0.0 && above < 0.0)); // Check if we're transitioning in or out of the mountain\n\n    vec3 mountainColor = mix(gradientMountainColor, baseMountainColor, uv.y*7.2); // Gradient color based on height\n    mountainColor = mix(mountainColor, crackedColor, cracks * 0.5);  // Blend the mountain color with cracks\n    \n    float mountainMask = smoothstep(0.0, 0.0, mountainHeight - uv.y);\n\n    vec3 color = mix(mountainColor, outlineColor, outlineMask); // Mix between regular mountain color and outline based on the mask\n    \n    return color * mountainMask;\n}\n\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvec3 stars(vec2 uv) {\n    vec2 starPos = floor(uv * 50.0);  \n    float starCenterValue = rand(starPos);\n\n    // Brightness threshold: Only allow stars above this value\n    if (starCenterValue < 0.8) return vec3(0.0, 0.0, 0.0);  // Ignore stars that are too dim\n\n    // Compute the relative UV around the star's position\n    vec2 rUV = fract(uv * 50.0) - starCenterValue;\n    \n    // \"+ sign\" shape effect for each star\n    float starShapeX = exp(-20.0 * abs(rUV.x));\n    float starShapeY = exp(-20.0 * abs(rUV.y));\n    float starShape = starShapeX + starShapeY - starShapeX * starShapeY;\n    \n    // Twinkling effect with a unique time factor for each star\n    float timeOffset = starCenterValue * 20.0;\n    float twinklingFactor = (sin(iTime + timeOffset) + 1.0) * 0.7; \n    float brightness = starShape * starCenterValue * twinklingFactor;\n    \n    brightness = clamp(brightness, 0.0, 1.0);\n    return vec3(brightness, brightness, brightness);\n}\n\n\nfloat verticalLaser(vec2 uv)\n{\n    float segmentLength = 0.05; \n    float gapLength = 2.07; \n    float speed = 0.2; \n\n    float ySegment = mod(uv.y + iTime * speed, segmentLength + gapLength);\n    \n    if(ySegment < segmentLength) return 1.0;\n    else return 0.0;\n}\n\nvec4 applyGradient(vec4 color, float position)\n{\n    float gradientStart = -6.5;\n    float gradientEnd = 8.0;\n    \n    float gradientFactor = mix(gradientStart, gradientEnd, position);\n    \n    return vec4(color.rgb, gradientFactor);\n}\n\nvec4 getLaserColor(vec2 uv, float numLasers)\n{\n    vec3 color = vec3(0.0);\n    float alpha = 0.0;\n    \n    for(float i = 0.0; i < numLasers; i++)\n    {\n        float randomXOffset = rand(vec2(i, 12.0)) * 1.2 - 0.75;\n        \n        bool withinLaserSegment = abs(uv.x - randomXOffset) < 0.001 && verticalLaser(uv) > 0.5;\n\n        if(withinLaserSegment)\n        {\n            vec4 gradientColor = applyGradient(vec4(0.220,0.365,0.600,1.0), uv.y);\n            color += gradientColor.rgb;\n            alpha += gradientColor.a;\n        }\n    }\n\n    return vec4(color, alpha);\n}\n\n\nvec4 computeFinalColor(vec2 uv, vec2 sunCenter, float sunRadius, float battery) {\n    vec3 sunVal = sun(uv, sunCenter, sunRadius);\n    vec3 mountainVal = mountains(uv);\n    vec3 starVal = stars(uv);\n    \n    vec2 distortedUV = uv;\n    distortedUV.y = 3.0 / (abs(distortedUV.y + 0.0) + 0.05);\n    distortedUV.x *= distortedUV.y;\n    \n    float gridVal = grid(distortedUV, battery);\n    \n    vec3 gridColor = vec3(0.522,0.851,0.188);\n    vec3 bgColorTop = vec3(0.765,0.031,0.969); \n    vec3 bgColorBottom = vec3(0.000,0.000,0.000);\n    \n    vec3 backgroundColor = mix(bgColorBottom, bgColorTop, uv.y);\n    vec3 gridFinalColor = mix(backgroundColor, gridColor, gridVal);\n    \n    vec3 topPart;\n    if (length(sunVal) > 0.01) {\n        topPart = sunVal; // This ensures the sun is completely opaque\n    } else if (length(mountainVal) < 0.01) {\n        topPart = starVal; // Render stars where mountains are not present\n    } else {\n        topPart = mountainVal;\n    }\n    \n    vec3 finalColorWithoutClouds;\n    if(uv.y < 0.0) {\n        finalColorWithoutClouds = gridFinalColor;\n    } else {\n        finalColorWithoutClouds = topPart;\n    }\n    \n    vec3 cloudColor = clouds(uv);\n    finalColorWithoutClouds = mix(finalColorWithoutClouds, cloudColor, 0.3);  // This blends the cloud over the scene\n\n    vec3 finalBloomedColor = bloom(uv, finalColorWithoutClouds);\n    \n    // Convert the vec3 to vec4 with an alpha value of 1.0 (fully opaque).\n    return vec4(finalBloomedColor, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    // Original Scene Color\n    vec2 sunCenter = vec2(0.85, 0.65);\n    float sunRadius = 0.34;\n    float batteryValue = 0.3;\n    vec4 sceneColor = computeFinalColor(uv, sunCenter, sunRadius, batteryValue);\n    \n    // Laser Color\n    vec2 laserUv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y; \n    float shiftAmount = uv.y * -1.4;  // Adjust 0.3 to control the shift amount\n    laserUv.x = laserUv.x - sign(laserUv.x) * min(abs(laserUv.x), shiftAmount); \n    float numLasers = 0.0; \n    vec4 laserColor = getLaserColor(laserUv, numLasers);\n    \n    // Glow (from the laser shader)\n    float glowRadius = 0.02; \n    for(float x = -glowRadius; x <= glowRadius; x += glowRadius/2.0)\n    {\n        for(float y = -glowRadius; y <= glowRadius; y += glowRadius/2.0)\n        {\n            laserColor += getLaserColor(laserUv + vec2(x, y), numLasers) * 0.15;\n        }\n    }\n\n    // Blend the two colors, but only for the bottom half (where uv.y is negative)\n    vec4 finalColor;\n    if (uv.y < 0.0) {\n        finalColor = mix(sceneColor, laserColor, length(laserColor));\n    } else {\n        finalColor = sceneColor;\n    }\n    \n    fragColor = vec4(finalColor);\n}","name":"Image","description":"","type":"image"}]}