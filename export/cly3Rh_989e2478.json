{"ver":"0.1","info":{"id":"cly3Rh","date":"1683502510","viewed":170,"name":"Another Mandelbulb lol","username":"ShelbyLynn","description":"A simple mandelbulb path tracer using blinn phong and fresnel","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["mandelbulblolmandelbulbblinnphongreflectionsplasticsequence"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 256\n#define STOP_DIST 0.001\n#define MAX_DIST 3.\n\n#define SHADOW_STEPS 256\n#define AO_STEPS 8\n#define AO_SCALE 0.02\n\n#define BOUNCES 0\n#define ROUGHNESS 0.6\n#define SAMPLES 9\n\n#define EXPOSURE 4.4\n#define GAMMA 2.2\n\n#define PI   3.1415926535\n#define PI_2 1.5707963267\n\nfloat atan2(float y, float x) {\n    return atan(y / (x+0.001)) + (PI_2*sign(y)*sign(x)*(sign(x) - 1.));\n}\n\nfloat mandelbulb(vec3 p) {\n    vec3 c = p;\n    vec3 z = c;\n    int i = 0;\n    float r = 0.;\n    float dr = 1.;\n    while (i < 8) {\n        r = length(z);\n        if (r > 2.) break;\n        float theta = acos(z.z / r);\n        float phi = atan2(z.y, z.x);\n        float rppm1 = r*r*r*r*r;\n        dr = rppm1 * 6. * dr + 1.;\n        float zr = rppm1 * r;\n        theta *= 6.;\n        phi *= 6.;\n        \n        z = zr * vec3(\n            sin(theta) * cos(phi),\n            sin(phi) * sin(theta),\n            cos(theta)\n        ) + c;\n        \n        i += 1;\n    }\n    r = length(z);\n    return 0.5 * log(r) * r / (dr);\n}\n\nfloat de(vec3 p) {\n    return mandelbulb(p);\n}\n\nfloat trace(int steps, float sd, vec3 ro, vec3 rd) {\n    float d = sd;\n    vec3 p = ro + (sd * rd);\n    int s = 0;\n    while (s < steps) {\n        p = ro + (d * rd);\n        float de = de(p);\n        if (de < STOP_DIST) break;\n        if (d > MAX_DIST) break;\n        d += de;\n        s+=1;\n    }\n    return d;\n}\n\nfloat ao(int steps, float sd, vec3 ro, vec3 rd) {\n    float d = sd ;\n    int i = 0;\n    float mn = 0.;\n    float mx = 0.;\n    while (i < steps) {\n        vec3 p = ro + (rd * d);\n        float de = de(p);\n        float decay = 1. / pow(2.,float(i + 1));\n        d += de;\n        mn += de *decay ;\n        mx += d * decay; \n        if (de < STOP_DIST) break;\n        if (d > MAX_DIST) break;\n        i += 1;\n    }\n    return   max(0.,(max(sd,mn) / min(sd,mx)));\n}\n\nvec3 norm(float d, vec3 p) {\n    return normalize(vec3(\n        de(p + vec3(STOP_DIST, 0.,0.)),\n        de(p + vec3(0.,STOP_DIST, 0.)),\n        de(p + vec3(0.,0., STOP_DIST))\n    ) - d);\n}\n\n// Wang hash\nuint hash(inout uint  state) {\n\tstate = (state ^ 61U) ^ (state >> 16U);\n\tstate = state * 9U;\n\tstate = state ^ (state >> 4);\n\tstate = state * 0x27d4eb2dU;\n\tstate = state ^ (state >> 15);\n\treturn state;\n}\n\nfloat random_float_01(inout uint  state) {\n    return float(hash(state)) / float(0xFFFFFFFFU);\n}\n\nvec3 hemisphere_rand(inout uint  state) {\n    float z = random_float_01(state) * 2. - 1.;\n    float theta = random_float_01(state) * 2. * PI;\n    float mu2sqrt = sqrt(1. - (z * z));\n    return vec3(\n        mu2sqrt * cos(theta),\n        abs(mu2sqrt * sin(theta)),\n        z\n    );\n}\n\nfloat schlick(float ior, float theta) {\n    float coeff = (1. - ior) / (1. + ior);\n    coeff *= coeff;\n    return coeff + ((1.- coeff)*pow(1. - theta,5.));\n}\n\nvec3 rt(inout uint rand, vec3 ro, vec3 rd) {\n    vec3 throughput = vec3(1.);\n    float t = iMouse.y / iResolution.y * 2. ;\n    vec3 lp = vec3(-t,1., -2.);\n    \n    int b = 0;\n    while (b < BOUNCES+1) {\n        float d = trace(MAX_STEPS, 0., ro, rd);\n        vec3 n = vec3(0.);\n        vec3 p = ro + (rd * d);\n        float tde = de(p);\n        if (tde < STOP_DIST) {\n            n = norm(tde, p);\n            p += n * STOP_DIST;\n            float light_d = length(lp - p);\n            float ldist2 = light_d * light_d;\n            vec3 ld = normalize(lp - p);\n            vec3 ord = normalize(ro - p);\n            vec3 h = normalize(ld + ord);\n            float ambience = ao(8, STOP_DIST, p, n);\n            float gi = AO_SCALE*ambience*ao(8, STOP_DIST, p, ld) / ldist2;\n            float rough = mix(ROUGHNESS, 1., schlick(1.5, max(0.,-dot(n, ord))));\n            vec3 lc = pow(max(AO_SCALE * ambience,dot(h,n)), (1. - rough) * (1. - rough)) * 4. * vec3(0.8, 0.7, 0.8) / ldist2;\n            \n            vec3 color = pow((n * 0.5 + 0.5), vec3(1. / 2.2));\n            \n            float sd = trace(SHADOW_STEPS, STOP_DIST , p, ld);\n            float shadow_decay =  (1. / ((sd+ 1.) * (sd+ 1.)));\n            if (de(p + (ld * sd)) > STOP_DIST) {\n                throughput *= color*lc;\n            } else {\n               throughput *= mix( color * AO_SCALE* ambience,color*lc,1. - shadow_decay);\n            }\n            //hroughput *=   ;\n            if (BOUNCES > 0) {\n                vec3 nf = normalize(n);\n                vec3 nr = cross(vec3(0., 1., 0.), nf);\n                vec3 nu = cross(nf, nr);\n                vec3 hemi = hemisphere_rand(rand);\n                vec3 ray_diff = normalize(hemi.y * nr + hemi.z * nf + hemi.x * nu);\n                vec3 ray_spec = rd - (2. * n * dot(rd,n));\n\n                rd = (rough * ray_diff) + ((1. - rough) * ray_spec);\n                ro = p;\n            }\n            //throughput *= ambience;\n            //throughput  *= ao(64, STOP_DIST, p, n);\n        } else {\n            throughput *= AO_SCALE;\n            //throughput *= pow(vec3(texture(iChannel0, rd).xyz),vec3(1. / 2.2));\n            break;\n        }\n        b+=1;\n    }\n    return throughput ;\n}\n\nvec3 post_process(vec3 color) {\n  color *= EXPOSURE;\n  color = 1. - exp2(-color);\n  return pow(color, vec3(GAMMA));\n}\n\nfloat tridist(float f) {\n    float o = f * 2. - 1.;\n    float v = o * sqrt(abs(o));\n    v = max(v, -1.f);\n    return v - sign(o);\n}\nfloat fract_fr(float x) {\n    return x - floor(x);\n}\nvec2 plastic(int s)  {\n    float g = 1.324717957244f;\n    float a1 = 1.f / g;\n    float a2 = 1.f / (g * g);\n    return vec2(\n        tridist(fract_fr(0.5f + a1 * float(s + 1))),\n        tridist(fract_fr(0.5f + a2 * float(s + 1)))\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint rand = uint(fragCoord.x) + (uint(fragCoord.y) << 5);\n    hash(rand);\n    float t = iMouse.x / iResolution.x * PI * 0.5;\n    \n    vec3 ro = -mix(1.,1.2,t) * vec3(abs(cos(t)*cos(t)),mix(0.0,-0.1,t)-abs(sin(t) * sin(t)) * 0.5,1. + abs(sin(t) * sin(t)));\n    vec3 wu = vec3(0., 1., 0.);\n    vec3 la = vec3(0.,0.,mix(-0.25,0.,t));\n    \n    vec3 cf = normalize(la - ro );\n    vec3 cr = cross(wu, cf);\n    vec3 cu = cross(cf, cr);\n    vec3 col = vec3(0.);\n    int s = 0;\n    while (s < SAMPLES) {\n        vec2 offset = plastic(s);\n        hash(rand);\n        vec2 vp =   mix(3.,2.,t) * ((fragCoord + 0.5 + offset)/iResolution.xy - 0.5);\n        vp.y *= iResolution.y / iResolution.x;\n        vec3 rd = normalize((vp.x) * cr + (vp.y) * cu + cf);\n        col += rt(rand, ro, rd);\n        s += 1;\n    }\n    vec3 srgb = post_process(col / float(SAMPLES));\n    // Output to screen\n    fragColor = vec4(srgb,1.0);\n}","name":"Image","description":"","type":"image"}]}