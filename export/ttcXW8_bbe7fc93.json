{"ver":"0.1","info":{"id":"ttcXW8","date":"1657381983","viewed":268,"name":"Tutorial Starfield","username":"oalpha","description":"Following starfield tutorial","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["tutorial","stars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 uv_vis(vec2 uv) {\n    vec3 col = vec3(0.);\n    if(uv.x < 0.) {\n        col.yz -= 0.5 * uv.x;\n    }\n    else {\n        col.x += uv.x;\n    }\n    if(uv.y < 0.) {\n        col.xz -= 0.5 * uv.y;\n    }\n    else {\n        col.y += uv.y;\n    }\n    return col;\n}\n\nfloat hash(vec2 uv) {\n    //return fract(dot(uv, vec2(1244.35251, 4721.54621)));\n    uv = fract(uv * vec2(1244.35251, 4721.54621));\n    return fract(dot(uv, uv + 48.83));\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nvec3 circle(vec2 uv, vec2 c, float r, float s, vec3 base, vec3 col) {\n    float d = distance(uv, c);\n    return mix(base, col, 1. - smoothstep(r - s, r + s, d));\n}\n\nvec3 light(vec2 uv, vec2 c, float r, float f, vec3 base, vec3 col) {\n    float d = distance(uv, c);\n    vec3 c1 = mix(base, col, pow(min(1., r / d), f));\n    vec3 c2 = mix(c1, base, smoothstep(.3, 1., d));\n    return c2;\n}\n\nvec3 ray(vec2 uv, float f, float g, vec3 base, vec3 col) {\n    float ray = max(0., 1. - (f * abs(uv.x) * abs(uv.y) + g * length(uv)));\n    return mix(base, col, ray);\n}\n\nvec3 star(vec2 uv, float size, vec3 base, vec3 col) {\n    //return mix(uv_vis(uv), vec3(0), smoothstep(.9, 1., length(uv)));\n    base = light(uv, vec2(.0), .1 * size, 1.5, base, col);\n    //return base;\n    base = ray(uv, 256. / size, 1. / size, base, col);\n    base = ray(rot(3.1415 / 4.) * uv, 512. / size, 3. / size, base, col);\n    base = ray(rot(3.1415 / 8.) * uv, 512. / size, 4. / size, base, col);\n    base = ray(rot(3. * 3.1415 / 8.) * uv, 512. / size, 4. / size, base, col);\n    return base;\n}\n\nvec3 star_layer(vec2 uv, float t, float f, vec3 col) {\n    vec3 icol = col;\n    vec2 gv = fract(uv) - .5;\n    ivec2 id = ivec2(floor(uv));\n    for(ivec2 off = ivec2(-1); off.y < 2; off.y += 1) {\n        for(off.x = -1; off.x < 2; off.x += 1) {\n            vec2 gv_cur = gv - vec2(off);\n            vec2 id_cur = vec2(id + off);\n            float h = hash(id_cur);\n            vec2 p = vec2(h - .5, fract(h * 100.) - .5);\n            float size = fract(h * 124.542);\n            float size_off = 2. * 3.1415 * fract(h * 845.562);\n            float st = t * 2.;\n            size = mix(.1, 2., fract(h * 124.542) * (cos(st + size_off) * .25 + .75));\n            size *= .1;\n            vec3 scol = sin(vec3(53.67358,95.527,45.542)*h)*.5+.5;\n            //scol.g = min(scol.r, scol.g);\n            scol.g *= scol.r;\n            scol = mix(scol, vec3(1.), .5);\n            col = star(gv_cur - p, size, col, scol);\n        }\n    }\n    return mix(icol, col, f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n    vec2 mp = (iMouse.xy - iResolution.xy*0.5)/iResolution.y;\n    vec2 cp = (iMouse.zw - iResolution.xy*0.5)/iResolution.y;\n    float t = iTime * 3.;\n    \n    //uv *= 4.;\n\n    vec3 col = vec3(0);\n    //col = circle(uv, mp, .1, .025, col, vec3(0,1,0));\n    //col = circle(uv, mp, .1, .025, col, vec3(1,0,0));\n    const float NUM_LAYERS = 8.;\n    for(float i = 0.; i < 1.; i += 1. / NUM_LAYERS) {\n        float lt = t * 0.02;\n        float ip = fract(i + lt);// / NUM_LAYERS;\n        float f = 1.;\n        f = mix(0., 1., ip * smoothstep(1., .9, ip));\n        f *= 2.;\n        vec2 shift = 16.*(fract(i * vec2(41351.43522,431653.3416))*2.-1.);\n        col = star_layer(shift + uv * mix(50., .1, ip), t, f, col);\n    }\n    //if(gv.x > .49 || gv.y > .49) col = vec3(1,0,0);\n    //col = vec3(hash(uv));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}