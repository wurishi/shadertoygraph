{"ver":"0.1","info":{"id":"7lVcz3","date":"1661952937","viewed":376,"name":"Walk on spheres for Laplace eqn","username":"lisyarus","description":"Solving the Laplace equation in a domain specified by an SDF using the walk-on-spheres algorithm","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["montecarlo","pde","laplace","walkonspheres"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.141592653589793;\nconst float PHI = 1.61803398874989484820459;\nconst int ITERATIONS = 256;\nconst int STEPS = 8;\nconst float B = 0.02;\n\nfloat rand(vec2 p, float seed){\n    p *= 100.0;\n    return fract(tan(distance(p * PHI, p) * seed) * (1.0 + abs(p.x)));\n}\n\nfloat borderValue(vec2 p)\n{\n    float phase = fract(atan(p.y, p.x) / 2.0 / PI + 0.5 + 0.5 * length(p) + iTime / 40.0);\n    \n    int n = int(floor(phase * 12.0));\n    \n    if (rand(vec2(float(n), float(n) + PHI), 3.0) > 0.5)\n        return 1.0;\n    else\n        return -1.0;\n}\n\nfloat circleSDF(vec2 p, vec2 center, float radius){\n    return radius - length(p - center);\n}\n\nfloat boxSDF(vec2 p, vec2 center, float size){\n    vec2 s = abs(p - center);\n    return min(size - s.x, size - s.y);\n}\n\nfloat distanceToBorder(vec2 p)\n{\n    float d = 10000.0;\n    \n    d = min(d, boxSDF(p, vec2(0.0, 0.0), 1.0));\n    d = min(d, -circleSDF(p, vec2( 1.0,  1.0), 0.4));\n    d = min(d, -circleSDF(p, vec2(-1.0,  1.0), 0.7));\n    d = min(d, -circleSDF(p, vec2( 1.0, -1.0), 0.5));\n    d = min(d, -circleSDF(p, vec2(-1.0, -1.0), 0.8));\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    m = 2.0 * m - vec2(1.0);\n    m.x *= iResolution.x / iResolution.y;\n    m *= 1.0 + B;\n    d = min(d, -circleSDF(p, m, 0.5));\n    \n    return d;\n}\n\nfloat solve(vec2 p){\n    float value = 0.0;\n    for (int i = 0; i < ITERATIONS; ++i){\n        vec2 s = p;\n        for (int j = 0; j < STEPS; ++j){\n            float r = distanceToBorder(s);\n            float a = rand(s, float(i) + iTime) * 2.0 * PI;\n            s += r * vec2(cos(a), sin(a));\n        }\n        value += borderValue(s) / float(ITERATIONS);\n    }\n    return value;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (fragCoord/iResolution.xy * 2.0 - vec2(1.0));\n    p.x *= iResolution.x / iResolution.y;\n    p *= 1.0 + B;\n    \n    float M = 1.25;\n    \n    float value;\n    if (distanceToBorder(p) < -B)\n        value = 0.0;\n    else if (distanceToBorder(p) < 0.0)\n        value = borderValue(p) * M;\n    else\n        value = solve(p);\n        \n    if (value > 0.0)\n        fragColor = vec4(value / M, 0.0, 0.0, 1.0);\n    else\n        fragColor = vec4(0.0, 0.0, - value / M, 1.0);\n}","name":"Image","description":"","type":"image"}]}