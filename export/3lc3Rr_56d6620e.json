{"ver":"0.1","info":{"id":"3lc3Rr","date":"1575921096","viewed":196,"name":"Raymarching experiment D1","username":"MeDope","description":" ","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","kifs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Thanks IQ for distance functions\n//https://iquilezles.org/articles/distfunctions\n\n//Thanks BigWings for KIFS Fractals explained\n//https://www.youtube.com/watch?v=il_Qg9AqQkE&t=\n\n#define pi 3.14159\n#define SURF_DIST .001\n#define MAX_DIST 100.\n#define MAX_STEPS 100\n\nconst float eps = 0.001;\n\nmat2 rot(float a)\n{\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvec2 KIFS(vec2 uv)\n{\n    uv *= 1.5;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    vec3 col = vec3(0.);\n    uv.x = abs(uv.x);\n    float angle = 5./6. * pi;\n    uv.y += tan(angle)*0.5;\n    vec2 norm = vec2(sin(angle), cos(angle));\n    float dist = dot(uv - vec2(0.5, 0.0), norm);\n    uv -= norm * 2. * max(dist, 0.);\n    angle = 2./3. * pi * (1. - mouse.y);\n    norm = vec2(sin(angle), cos(angle));\n\tuv.x += 0.5;\n    float scale = 1.0;\n    for(int i = 0; i < 4; i++){\n        scale *= 3.;\n        uv *= 3.;\n    \tuv.x -= 1.5;\n        uv.x = abs(uv.x);\n        uv.x -= .5;\n        uv *= rot(iTime*0.2 + mouse.x*10.);\n        uv -= norm * 2. * min(dot(uv, norm), 0.);\n    }\n    uv/= scale;\n    return uv;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdf(vec3 p)\n{\n    p *= 0.5;\n    float f = max(min(abs(KIFS(p.xy).y), 1.0), sdBox(p, vec3(0.5, 0.5, 0.05))) - 0.0005;\n\treturn min(f, -p.z + 0.1);\n}\n\nvec2 march(vec3 ro, vec3 rd)\n{\n\tfloat t = 0.0 , d = MAX_DIST, it = 0.;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        d = sdf(ro+t*rd);\n     \tt += d;\n        if(abs(d) < SURF_DIST || t > MAX_DIST) break;\n        it += 1.0;\n    }\n    return vec2(t, it/float(MAX_STEPS));\n}\n\nfloat getShadow(vec3 p, vec3 n, vec3 ld)\n{\n    p += 2. * eps * n;\n    float t = 0.0, d = MAX_DIST;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        d = sdf(p + t * ld);\n        t += d;\n        if (abs(d) < eps || t > 3.0) break;\n    }\n    return t <= 3.0 ? 0.05 : 1.0;\n}\n\nvec3 getNorm(vec3 p)\n{\n    vec2 e = vec2(eps, 0);\n    return normalize(vec3(sdf(p+e.xyy)-sdf(p-e.xyy), sdf(p+e.yxy)-sdf(p-e.yxy), sdf(p+e.yyx)-sdf(p-e.yyx)));\n}\n\nvec3 light(vec3 p)\n{\n    vec3 col = vec3(0.0);\n    vec3 ld = normalize(vec3(-1.0,1.0,-5.0));\n    vec3 n = getNorm(p);\n    float diff = max(dot(n, ld), 0.);\n    diff *= getShadow(p, n, ld);\n    col += diff;\n    return col;\n}\n\nvec3 bg(vec2 uv)\n{\n    vec2 ouv = uv;\n   \tuv.x += sin(ouv.y*40. + 3.5*iTime) * 0.01;\n    uv.y += sin(ouv.x*40. + 5.5*iTime) * 0.005;\n    uv = KIFS(uv);\n\tfloat l = abs(sin(uv.y*10.+iTime));\n    l = pow(0.1/l, 2.0);\n    return vec3(l) * vec3(0.07,0.25, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\tvec3 rd = normalize(vec3(uv, 1.0));\n    vec3 ro = vec3(0., 0., -1.5);\n    vec3 col;\n\tvec2 m = march(ro, rd);\n    vec3 p = ro + rd * m.x;\n    col += p.z > 0.1 ? (light(p) * pow(0.01/(abs(KIFS(p.xy*0.5))).y, 2.2)) * vec3(0.2, 0.4, 2.3) + light(p) * 0.1 : light(p);\n    col += (m.y*m.y*m.y*m.y*m.y)*vec3(0.2, 0.4, 2.3)*100.;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}