{"ver":"0.1","info":{"id":"clSSzG","date":"1676232470","viewed":142,"name":"Block of ice","username":"ianertson","description":"Look around with the mouse :)","likes":5,"published":1,"flags":0,"usePreview":1,"tags":["3d","raymarch","refraction","ice","refract"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ======== Block of ice! =============\n\n\n//////////// settings\n\n// Set this (AA_SAMPLES) to something above 1 to get rid of the noise :)\n#define AA_SAMPLES 0\n#define NEAR 0.003\n#define FAR 60.0\n#define STEPS 100\n\n\n#define ZERO (min(0, int(iTime)))\n#define ZEROF (min(0.0, float(iTime)))\n#define adot(x, y) (abs(dot(x, y)))\n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_ICE 2\n\n\nstruct Material {\n    float roughness;\n    float ior;\n    vec3 spec;\n};\n\nvoid materialInit(inout Material m) {\n    m.ior = 0.0;\n    m.roughness = 1.0;\n    m.spec = vec3(0.1);\n}\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    vec2 uv;\n    float dist;\n    float depth;\n    int id;\n    int skip;\n    float mixf;\n    float sig;\n    Material m;\n};\n\nvoid dataInit(inout Data data) {\n    data.p = vec3(0.0);\n    data.n = vec3(0.0);\n    data.uv = vec2(0.0);\n    data.dist = FAR;\n    data.depth = 1.0;\n    data.id = 0;\n    data.skip = 0;\n    data.mixf = 1.0;\n    data.sig = 1.0;\n    materialInit(data.m);\n}\n\nstruct Light {\n    vec3 p;\n    vec3 c;\n    float s;\n};\n\n#define SAMPLE(var, id_) if (id_ != data.skip && var < dist) { data.id = id_; dist = var; }\nfloat boxSDF(vec3 p, vec3 s) {\n  p = abs(p) - s;\n  return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\nfloat groundSDF(vec3 p) { return p.y; }\nfloat iceSDF(vec3 p) {\n    float h = 0.25;\n    float wx = 1.0;\n    float wz = 1.0;    \n    float x = noise2D(iChannel3, p.yz*0.5, 0.21);\n    float z = noise2D(iChannel3, p.yx*0.6, 3.3918);\n    float y = noise2D(iChannel3, p.xz*1.5, 9.92359);\n    wx += (0.2+(x*2.0-1.0));\n    wz += (0.2+(z*2.0-1.0));\n    h += y*0.8;\n    return boxSDF(p - vec3(0, h, 0), vec3(wx, h, wz));\n}\n\nfloat getDist(inout Data data, vec3 p) {\n    float dist = FAR;\n    \n    float ground = groundSDF(p);\n    float ice = iceSDF(p);\n    \n    SAMPLE(ground, ID_GROUND);\n    SAMPLE(ice, ID_ICE);\n    \n    return dist;\n}\n\nvec3 getNormal(inout Data data, vec3 p) {\n    vec2 e = vec2(0.01, 0.0);\n    return normalize(getDist(data, p) - vec3(\n        getDist(data, p - e.xyy),\n        getDist(data, p - e.yxy),\n        getDist(data, p - e.yyx)\n    ));\n}\n\nvec2 getUv(inout Data data, vec3 p) {\n    if (data.id == ID_GROUND) return p.xz;\n    vec3 n = data.n;\n    vec2 uv = p.xz;\n    uv = mix(uv, p.xy, adot(n, vec3(0, 0, 1)));\n    uv = mix(uv, p.xz, adot(n, vec3(0, 1, 0)));\n    uv = mix(uv, p.zy, adot(n, vec3(1, 0, 0)));\n    return uv;\n}\n\nbool march(inout Data data, vec3 ro, vec3 rd) {\n    float dist = 0.0;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p)*data.sig;\n        dist += next;\n        if (abs(next) <= NEAR) break;\n        if (abs(dist) >= FAR) return false;\n    }\n    \n    vec3 p = ro+rd*dist;\n    data.p = p;\n    data.dist = dist;\n    data.depth = dist/FAR;\n    data.n = getNormal(data, p);\n    data.uv = getUv(data, p);\n    \n    return true;\n}\n\nfloat getShadow(int skip, vec3 ro, vec3 rd, float near, float far) {\n    float dist = 0.0;\n    Data data;\n    dataInit(data);\n    data.skip = skip;\n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        if (abs(next) <= NEAR || abs(dist) >= far) break;\n    }\n    dist = abs(dist);\n    if (dist >= far) return 1.0;\n    return dist/max(0.01, near);\n}\n\nvec3 checker(vec2 uv, float tile) {\n    vec2 id = floor(uv*tile);\n    return mix(\n        vec3(223.0, 230.0, 233.0) / 255.0,\n        vec3(45.0, 52.0, 54.0) / 255.0,\n        float(mod(id.x-id.y, 2.0) > 0.0)\n    );\n}\n\nvec3 iceTexture(vec2 uv, inout float edges, inout float region) {\n    vec3 col = vec3(0.0);\n    vec3 blue = rgb(0,111,185);\n    vec3 white = rgb(241,247,254);\n    col += blue;\n    region = noise2D(iChannel3, uv, 0.0, 6.);\n    region = pow(region, 3.3)*6.3;\n    region = smoothstep(0.06, 0.5, region);\n    float invRegion = noise2D(iChannel3, uv, 3.253, 6.3);\n    invRegion = max(0.0, invRegion - region);\n    edges = max(0.0, 1.0-smoothstep(0.04, abs(region - invRegion), 1.0));\n    col += region * white;\n    col += fract(cos((edges+invRegion)*TAU*TAU))*0.5;\n    col += (white*fract(tan((edges+region)*TAU*TAU)))/TAU;\n    return col;\n}\n\nvec3 iceNormal(vec2 uv) {\n    float e = 0.02;\n    float edges = 0.0;\n    float region = 0.0;\n    return normalize(luma(iceTexture(uv, edges, region)) - vec3(\n        luma(iceTexture(uv + vec2(e, 0), edges, region)),\n        luma(iceTexture(uv + vec2(0, e), edges, region)),\n        luma(iceTexture(uv + vec2(e, e), edges, region))\n    ));\n}\n\n\nvec3 getAlbedoGround(inout Data data, vec2 uv) {\n    vec3 col = checker(uv, 0.5);\n    data.m.spec = (col*luma(col)*2.)+0.02;\n    data.m.roughness = 0.5;\n    return col;\n}\n\nvec3 getAlbedoIce(inout Data data, vec2 uv) {\n    vec3 col = vec3(0.0);\n    uv *= 2.0;\n    float edges = 0.0;\n    float region = 0.0;\n    col += iceTexture(uv, edges, region);\n    vec3 n = iceNormal(uv);\n    float m = length(n);\n    \n    vec3 normal = mix(data.n, data.n+n, 0.6*length(n)*clamp(2.0*max(0.01, dot(n, data.n)), 0.0, 1.0));\n    data.n = normalize(normal);\n    \n    data.m.spec = col;\n    data.m.roughness = max(edges*0.25, 1.0 - (luma(col)*2.));\n    data.m.ior = 1.309 + (1.9 * region);\n    \n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_GROUND: return getAlbedoGround(data, data.uv); break;\n        case ID_ICE: return getAlbedoIce(data, data.uv); break;\n    }\n    \n    return vec3(0.48);\n}\n\n\nvec3 renderForRefract(inout Data data, in Light light, vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.0);\n        \n    if (march(data, ro, rd)) {\n        vec3 albedo = getAlbedo(data);\n        vec3 diffuse = albedo / M_PI;\n        vec3 n = data.n;\n        vec3 L = normalize(light.p);\n        float NdotL = max(0.0, dot(n, L));\n        vec3 att = light.c * light.s * NdotL;\n\n        vec3 ref = reflect(L, n);\n        float VdotR = max(0.0, dot(rd, ref));\n        vec3 spec = pow(VdotR, 16.0) * data.m.spec;\n\n        return ((((diffuse + spec) * att) * data.mixf));\n    }\n    \n    return texture(iChannel2, rd).rgb * data.mixf;\n}\n\n\nvec3 renderRefract(in Light light, float ior, vec3 rd, vec3 p, vec3 n) {\n    vec3 enterColor = vec3(0.0);\n    vec3 exitColor = vec3(0.0);\n    \n    Data enterData;\n    dataInit(enterData);\n    Data exitData;\n    dataInit(exitData);\n    \n    vec3 rEnter = (refract(rd, n, 1.0/ior));\n    \n    enterData.sig = -1.;\n    enterColor += renderForRefract(enterData, light, p - (n*NEAR*2.), rEnter);\n    \n    vec3 rExit = (refract(rEnter, -enterData.n, ior));\n    \n    if (length(rExit) <= 0.0001) {\n        rExit = reflect(rEnter,-enterData.n);\n    }\n    \n    exitData.skip = enterData.id;\n    exitData.sig = 1.0;\n    exitColor += renderForRefract(exitData, light, enterData.p, rExit);\n    \n    \n    return enterColor+exitColor;\n}\n\nvec3 render(inout Data data, vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.0);\n    \n    Light light = Light(vec3(1, 2, -3), vec3(0.92, 0.89, 0.69), 2.0);\n    \n    bool hit = false;\n    \n    vec3 ord = rd;\n    vec3 oro = ro;\n    float primDist = FAR;\n    \n    for (int i = ZERO; i < 2; i++) {\n        float pwr = 1.0 / (1.0 + float(i));\n        if (march(data, ro, rd)) {\n            if (i <= 0) primDist = data.dist;\n            hit = true;\n            vec3 albedo = getAlbedo(data);\n            vec3 diffuse = albedo / M_PI;\n            vec3 n = data.n;\n            vec3 L = normalize(light.p);\n            float NdotL = max(0.0, dot(n, L));\n            vec3 att = light.c * light.s * NdotL;\n\n            vec3 ref = reflect(L, n);\n            float VdotR = max(0.0, dot(rd, ref));\n            vec3 spec = pow(VdotR, 16.0) * data.m.spec;\n            \n            float shadow = 1.0;\n            if (NdotL > 0.001) {\n               shadow = getShadow(data.id, data.p, L, data.dist, FAR);\n            }\n\n            col += ((((diffuse + spec) * att) * data.mixf) * pwr) * shadow;\n            \n            if (data.m.ior > 0.01) {\n                col += renderRefract(light, data.m.ior, rd, data.p - data.n, data.n);\n            }\n            \n            data.skip = data.id;\n            ro = data.p;\n            rd = reflect(rd, n);\n            data.mixf = max(0.0, 1.0 - data.m.roughness) * shadow * luma(att);\n        } else {\n            col += texture(iChannel2, rd).rgb * pwr * data.mixf;\n            break;\n        }\n    }\n    \n    float depth = primDist / FAR;\n    \n    col += (depth*depth) *max(0.0, 1.0-max(0.0, 3.0*dot(ord, vec3(0, 1, 0))));\n    float dotL = pow(max(0.0, dot(ord, normalize(light.p))), 3.2);\n    col += ((((light.c * dotL)) * pow(primDist, 0.2)) / M_PI)*2.;\n    \n    return col;\n}\n\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n    vec3 camForward = normalize(point - ro);\n    vec3 camRight = -cross(camForward, vec3(0, 1, 0));\n    vec3 camUp = -cross(camRight, camForward);\n    vec3 screenCenter = ro + camForward;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\n\nvec3 getRayDir(vec2 uv, vec3 ro, vec3 rd, vec2 m) {\n    if (iMouse.z <= 0.01) return look(uv, vec3(0.0, 0.25, 0.0), ro);\n    rd.yz *= rot(m.y*TAU);\n    rd.xz *= rot(m.x*TAU);\n    return rd;\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec2 m = (iMouse.xy-0.5*R.xy)/R.y;\n    \n    vec3 ro = vec3(0, 1., -5.5);\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n    \n    \n    if (iMouse.z > 0.01) {\n        ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n    } else {\n        ro.y += (0.5+(0.5*cos(T+3.15)))*4.;\n        ro.xz *= rot(T*0.6);\n    }\n    \n    \n    #if AA_SAMPLES > 0\n    \n    ro.y = max(0.2, ro.y);\n    \n    for(float i=ZEROF; i < float(AA_SAMPLES); i++) {\n       for(float j=ZEROF; j < float(AA_SAMPLES); j++) {\n\t\t\n        vec2 deltaUV = (vec2(i, j) / float(AA_SAMPLES) - 0.5) / iResolution.y;\n        uv.xy += deltaUV / 2.0;\n        \n        \n        rd = getRayDir(uv, ro, normalize(vec3(uv.xy, 1.0)), m);\n        \n        Data data;\n        dataInit(data);\n        col += render(data, ro, rd);\n      }\n    }\n    \n    col /= float(AA_SAMPLES*AA_SAMPLES);\n    \n    #else\n    \n    rd = getRayDir(uv, ro, rd, m);\n    \n    ro.y = max(0.2, ro.y);\n    \n    Data data;\n    dataInit(data);\n    \n    col += render(data, ro, rd);\n    #endif\n    \n    col += (col*luma(col)) / M_PI;\n    col = max(col, 0.0);\n    \n    col /= vec3(1.0) + col;\n    col = pow(col, vec3(1.0 / 2.2));\n    \n    O = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R iResolution.xy\n#define T (iTime+5.75)\n#define M_PI (3.1416)\n#define TAU (M_PI * 2.0)\n#define rgb(r,g,b) (vec3(r,g,b)/255.0)\n#define SM(v) ((v) * (v) * (3.0 - 2.0 * (v)))\n\n\nfloat hash21(sampler2D ch, vec2 p, float seed) {\n    return textureLod(ch, (p+seed)/256., 0.).r;\n}\n\nfloat noise2D(sampler2D ch, vec2 p, float seed) {\n    vec2 id = floor(p);\n    vec2 fp = fract(p);\n    vec2 lv = SM(fp);\n    \n    return mix(mix(hash21(ch, id, seed), hash21(ch, id+vec2(1, 0), seed), lv.x),\n        mix(hash21(ch, id+vec2(0, 1), seed), hash21(ch, id+vec2(1, 1), seed), lv.x), lv.y);\n}\n\nfloat noise2D(sampler2D ch, vec2 p, float seed, float freq) {\n    float amp = 1.0;\n    float div = 0.0;\n    vec2 g = vec2(0.);\n    g += amp*noise2D(ch, p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    g += amp*noise2D(ch, p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    g += amp*noise2D(ch, p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    g += amp*noise2D(ch, p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n   // g += amp*noise2D(ch, p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n  //  g += amp*noise2D(ch, p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    \n    return ((g.x / div) + (g.y/6.))/2.;\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nmat2 rot(float a) { float s = sin(a); float c = cos(a); return mat2(c, s, -s, c); }","name":"Common","description":"","type":"common"}]}