{"ver":"0.1","info":{"id":"Wt2Xzy","date":"1566365554","viewed":173,"name":"Yet another cloud","username":"Albeforia","description":"Click to move the camera.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//=======================================================================================\n// Struct Definitions\n//=======================================================================================\n\nstruct sRay {\n    vec3\to;\n    vec3\tdir;\n    float\ttMin;\n    float\ttMax;\n};\n\nstruct sDirLight {\n\tvec3    color;\n    vec3    dir;\n};\n\n//=======================================================================================\n// Light Definitions\n//=======================================================================================\n\nsDirLight gDirLight0 = sDirLight(\n    5.0*vec3(1.0, 0.9, 0.8),\n    normalize(vec3(0.35, -0.45, 1.0))\n);\n\n//=======================================================================================\n// Participating Media\n//=======================================================================================\n\n#define HG_g\t\t\t0.6\n#define CLOUD_THICKNESS\t3.5\n#define FOG\t\t\t\t0.002\n\n/**\n * Define the media.\n */\nvoid getMedia(vec3 p, out float sigmaS, out float sigmaT) { \n    vec3 movement = 0.15*vec3(1.5, 0.0, 3.0) * iTime;\n    \n    //float f = fbm2(p*0.5 - movement);\n    \n    float f = tilableFbm6(p*0.08 - movement, 4.0);\n    f = 2.3*clamp(f, 0.0, 1.0);\n    float r = (1.0-step(CLOUD_THICKNESS, p.y))*step(0.0, p.y);\n    sigmaS = r*clamp(f-p.y, 0.0, f) + FOG;\n    \n    sigmaT = sigmaS;\n}\n\n/**\n * Isotropic phase function.\n */\nfloat phaseIsotropic(float cosTheta) {\n\treturn 1.0 / (4.0 * PI);\n}\n\n/**\n * HG phase function.\n */\nfloat phaseHG(float cosTheta, float g) {\n\tfloat tmp = 1.0 + pow2(g) - 2.0 * g * cosTheta;\n\treturn (1.0 - pow2(g)) / (4.0 * PI * tmp * sqrt(tmp));\n}\n\n/**\n * Calculate the transmittance.\n */\nfloat Tr(vec3 a, vec3 dir, float dist) {    \n    float ds = dist / VOL_SHADOW_RAY_MAX_STEPS;\n    float sigmaS, sigmaT;\n    \n    float tau = 0.0;\n    for (float i = 0.5; i < VOL_SHADOW_RAY_MAX_STEPS; i += 1.0) {\n        vec3 p = a + (i/VOL_SHADOW_RAY_MAX_STEPS) * dir;\n        getMedia(p, sigmaS, sigmaT);\n\n        tau += sigmaT * ds;\n    }\n    \n    return exp(-tau);\n}\n\n/**\n * Calculate the inscattering from point light.\n */\nvec3 inscatterDirLight(const in sRay ray, vec3 p, float ds,\n                       sDirLight light, out float segmentTr) {\n    float sigmaS, sigmaT;\n    getMedia(p, sigmaS, sigmaT);\n\n#if 1\n    /* hard-coded distance */\n    float trLight = Tr(p, -light.dir, 2.0);\n#else\n    float trLight = 1.0;\n#endif\n\n    vec3 S = sigmaS * (trLight * light.color);\n    \n    // should take the Tr inside the segment into account\n    // ref slide 29: http://www.frostbite.com/2015/08/physically-based-unified-volumetric-rendering-in-frostbite/\n    segmentTr = exp(-sigmaT * ds);\n    return (S - S * segmentTr) / sigmaT;\n}\n\n/**\n * Medium-aware ray marching.\n *\n * inscatter:\taccumulated inscattering along the ray\n */\nvoid rayMarchVol(const in sRay ray, out vec3 inscatter, out float totalTr) {\n    float t = ray.tMin;\n    float ds = VOL_RAY_MARCHING_STEP;\n\n    totalTr = 1.0;\n    \n    // for directional light,\n    // phase function is constant along the view ray\n    float phase = phaseHG(dot(gDirLight0.dir, -ray.dir), HG_g);\n    \n    for (int i = 0; ; i++) {\n        vec3 p = ray.o + t * ray.dir;\n        \n        // accumulate inscattering\n        float segmentTr;\n        inscatter += totalTr *\n            phase * inscatterDirLight(ray, p, ds, gDirLight0, segmentTr);\n        \n        // accumulate transmittance\n        totalTr *= segmentTr;\n        if (totalTr < 1e-2) {\n        \tbreak;\n        }\n        \n        // increase the step if not in the clouds\n        ds = mix(VOL_RAY_MARCHING_STEP*10.0,\n                 VOL_RAY_MARCHING_STEP,\n                 step(abs(p.y), CLOUD_THICKNESS));\n        \n        t += ds;\n        if (t >= ray.tMax) {\n            break;\n        }\n    }\n}\n\n//=======================================================================================\n// Camera\n//=======================================================================================\n\nmat3 viewMatrix(vec3 eye, vec3 target, vec3 up) {\n    vec3 f = normalize(target - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 cameraRay(float fov, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = (size.y / 2.0) / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n//=======================================================================================\n\nvec3 linearToGamma(vec3 value, float gammaFactor) {\n\treturn pow(value, vec3(1.0 / gammaFactor));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = vec2(0.0);\n    if (iMouse.z > 0.0)\n    \tmouse = (iMouse.xy / iResolution.xy)-0.5;\n    \n    vec3 eye = vec3(0.0, -2.2 + mouse.y*4.0, 6.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(mouse.x*16.0, 1.0, 1.0), vec3(0.0, 1.0, 0.0));\n\n    sRay viewRay;\n    viewRay.o = eye;\n    viewRay.tMax = VIEW_RAY_MAX_LENGTH;\n\tviewRay.dir = viewToWorld * cameraRay(60.0, iResolution.xy, fragCoord);\n    \n    // turn banding due to low marching steps into noise\n    // https://www.shadertoy.com/view/WsfBDf\n    float startRayOffset = texture(iChannel0, fragCoord / 1024.0f).r;\n    viewRay.tMin = fract(startRayOffset);\n    \n    vec3 inscatter;\n    float totalTr;\n    rayMarchVol(viewRay, inscatter, totalTr);\n\tvec3 sky = 2.0*vec3(0.05, 0.2, 0.5);\n    vec3 col = inscatter + totalTr * sky;\n\n    fragColor = vec4(linearToGamma(col, 2.2), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//=======================================================================================\n// Constants\n//=======================================================================================\n\nconst float PI = 3.14159265359;\n\nconst float VIEW_RAY_MAX_LENGTH = 25.0;\n\nconst float VOL_RAY_MARCHING_STEP = 0.5;\nconst float\tVOL_SHADOW_RAY_MAX_STEPS = 3.0;\n\n//=======================================================================================\n// Math\n//=======================================================================================\n\nfloat pow2(float x) {\n\treturn x * x;\n}\n\nfloat hash(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise( vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f       = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+0.0  ), hash(n+1.0  ),f.x),\n                   mix( hash(n+57.0 ), hash(n+58.0 ),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\nfloat valueNoise( in vec3 x, float tile ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash13(mod(p+vec3(0,0,0),tile)), \n                        hash13(mod(p+vec3(1,0,0),tile)),f.x),\n                   mix( hash13(mod(p+vec3(0,1,0),tile)), \n                        hash13(mod(p+vec3(1,1,0),tile)),f.x),f.y),\n               mix(mix( hash13(mod(p+vec3(0,0,1),tile)), \n                        hash13(mod(p+vec3(1,0,1),tile)),f.x),\n                   mix( hash13(mod(p+vec3(0,1,1),tile)), \n                        hash13(mod(p+vec3(1,1,1),tile)),f.x),f.y),f.z);\n}\n\nfloat fbm2( vec3 p ) {\n\tfloat f;\n    f  = 0.50000*noise( p ); p = p*2.02;\n    f += 0.25000*noise( p );\n    return f;\n}\n\n// ref: https://www.shadertoy.com/view/MdGfzh\nfloat tilableFbm6( vec3 p, float tile ) {\n    float f = tile;\n    float a = 1.;\n    float c = 0.;\n    float w = 0.;\n\n    for( int i=0; i<6; i++ ) {\n        c += a*valueNoise( p * f, f );\n        f *= 2.0;\n        w += a;\n        a *= 0.5;\n    }\n\n    return c / w;\n}","name":"Common","description":"","type":"common"}]}