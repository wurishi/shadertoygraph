{"ver":"0.1","info":{"id":"msfSzB","date":"1669581584","viewed":291,"name":"Let me out!","username":"Alpaga","description":"Turn your head with the mouse.","likes":36,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","gyroid","slices"],"hasliked":0,"parentid":"md2GRw","parentname":"Sliced world"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 color = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n\n    #ifndef MAP\n  //  color = 1.-exp(-color);\n    // Gamma\n    color = sqrt(color);\n\n    // Vignette\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv *=  1. - uv.yx;\n    color *= pow(uv.x*uv.y * 15.0, 0.25);\n    #endif\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Here we compute the walker's position and velocity.\n// Pixel (0,0) stores position in .xy and velocity in .zw\n// Pixel (1,0) stores frame time, to compute correct delta t\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if(fragCoord.y < 1.) {\n        if(fragCoord.x < 1.) {\n            // Position, velocity    \n            vec2 p, v;\n            if(iFrame==0) {\n                p = initialPosition;\n                v = initialVelocity;\n            } else {\n                // Previous position and velocity\n                vec4 tex = texelFetch(iChannel0, ivec2(0), 0);\n                vec2 pp = tex.xy, vv = tex.zw;\n\n                // Previous frame time\n                float pt = texelFetch(iChannel0, ivec2(1,0), 0).x;\n                float dt = iTime - pt;\n\n                // Update position\n                p = pp + .3*dt * vv;\n\n                // Update velocity\n                // If coming too close to the walls (g small)\n                // and velocity is oriented towards the wall (dot(vv,gNormal) negative)\n                // then orient velocity towards normal.\n                float g = shape(vec3(pp.x,0,pp.y));\n                vec2 gNormal = normalize(vec2(shape(vec3(pp.x+.01,0,pp.y    )),\n                                              shape(vec3(pp.x    ,0,pp.y+.01)))-g);\n                float x = max(g-.4,dot(vv,gNormal));//max(g-.4,.0) + max(dot(vv,gn),0.);\n                v = normalize(vv-smoothstep(.2,-.2,x)*dot(vv,gNormal)*gNormal);\n            }\n            fragColor = vec4(p,v);\n        } else if(fragCoord.x < 2.) {\n            // Time\n            fragColor = vec4(iTime);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//#define MAP // Uncomment to see the map with the player's position\n#define SLICES // Comment it out for a flat structure\n#define HOLLOW // Comment it out for plain slices, rather than \"wires\"\n\nconst vec2 initialPosition = vec2(-15,-13);\nconst vec2 initialVelocity = normalize(vec2(-2,-1));\n\n// Rotated gyroid\nfloat rotatedGyroid(vec3 p) {\n    const float a = .9, b = 1.2;\n    const mat2 ma = mat2(cos(a),sin(a),-sin(a),cos(a));\n    const mat2 mb = mat2(cos(b),sin(b),-sin(b),cos(b));\n    p.xy = ma * p.xy;\n    p.xz = mb * p.xz;\n    return dot(sin(p),cos(p.yzx));\n}\n\n//const vec2 initialPosition = vec2(1,0);\n//const vec2 initialVelocity = vec2(0,1);\nfloat galleries(vec3 p) {\n    const float a = .8, b = 1.1;\n    const mat2 ma = mat2(cos(a),sin(a),-sin(a),cos(a));\n    const mat2 mb = mat2(cos(b),sin(b),-sin(b),cos(b));\n    p.xy = ma * p.xy;\n    p.xz = mb * p.xz;\n    return dot(sin(p),cos(p));// What's the name of this shape???\n}\n\n//const vec2 initialPosition = vec2(2,0);\n//const vec2 initialVelocity = normalize(vec2(-1));\nfloat torus(vec3 p) {\n    return .5-length(vec2(length(p.xz)-2.,p.y));\n}\n\nfloat shape(vec3 p) {\n    //return torus(p);\n    \n    //return galleries(p);\n    return rotatedGyroid(p);\n}\n\n// Try any shape (the walker sits at p.y=0, where shape is positive):\n// return 3.-length(p);\n// return dot(sin(p),cos(p));\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const int STEPS = 1000;\nconst float FAR = 100.;\n\nconst float fov = 35.0;\nconst float cameraSpeed = 0.2;\nvec3 cam, forward;\n\nconst float SPACEX = .15, THICKNESSX = .05, ROUNDX = .002;\nconst float SPACEZ = .1, THICKNESSZ = .05, ROUNDZ = .002;\n\nconst vec2 floorParam = vec2(.8,.7);\nconst vec3 bulbColor = vec3(1,.8,.3);\n\nvec3 fogColor() {\n    float day = max(cos(.1*iTime),0.);\n    float k = min(cos(.1*iTime),0.)+1.;\n    return mix(k*vec3(.98,.14,.11),vec3(.7,.9,1),day);\n    return day*vec3(.98,.14,.11);//mix(day*vec3(.98,.14,.11),vec3(.7,.9,1),day);\n}\n\n\n// Hash functions from Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec2 hash21(float p) {\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash31(float p) {\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\nvec4 hash41(float p) {\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);   \n}\n\nfloat noise(vec3 p) {\n    const vec2 u = vec2(1,0);\n    vec3 fl = floor(p);\n    vec3 fr = p - fl;\n    return mix(mix(mix(hash13(fl+u.yyy),hash13(fl+u.xyy),fr.x),\n                   mix(hash13(fl+u.yxy),hash13(fl+u.xxy),fr.x),fr.y),\n               mix(mix(hash13(fl+u.yyx),hash13(fl+u.xyx),fr.x),\n                   mix(hash13(fl+u.yxx),hash13(fl+u.xxx),fr.x),fr.y),fr.z);\n}\n\nfloat fbm4(vec3 p) {\n    float h = 0.;\n    float f = 1.;\n    float a = .5;\n    h += a*noise(f*p); f *= 2.; a *= .5;\n    h += a*noise(f*p); f *= 2.; a *= .5;\n    h += a*noise(f*p); f *= 2.; a *= .5;\n    h += a*noise(f*p);\n    return h;\n}\n\n// Signed distance fields\nfloat sdShape(vec3 p) {\n    #ifdef HOLLOW\n    return .5*abs(shape(p))-.02;\n    #else\n    return .5*shape(p)-.02;\n    #endif\n}\n\n// Cuts the scene into slices of given thickness and space between them\nfloat sdSlicesX(vec3 p, float space, float thickness) {\n \tfloat c = space*(floor(p.x/space)+.5);\n    float d = 1e6;\n    for(float i=-1.; i<=1.; i++) {\n        d = min(d, length(max(vec2(\n            sdShape(vec3(c+i*space,p.y,p.z)),\n            abs(p.x-(c+i*space))-.5*thickness),0.)));\n    }\n    return d;\n}\nfloat sdSlicesY(vec3 p, float space, float thickness) {\n \tfloat c = space*(floor(p.y/space)+.5);\n    float d = 1e6;\n    for(float i=-1.; i<=1.; i++) {\n        d = min(d, length(max(vec2(\n            sdShape(vec3(p.x,c+i*space,p.z)),\n            abs(p.y-(c+i*space))-.5*thickness),0.)));\n    }\n    return d;\n}\nfloat sdSlicesZ(vec3 p, float space, float thickness) {\n \tfloat c = space*(floor(p.z/space)+.5);\n    float d = 1e6;\n    for(float i=-1.; i<=1.; i++) {\n        d = min(d, length(max(vec2(\n            sdShape(vec3(p.x,p.y,c+i*space)),\n            abs(p.z-(c+i*space))-.5*thickness),0.)));\n    }\n    return d;\n}\n\nfloat sdFloor(vec3 p) {\n    return p.y;\n}\n// Low wall is a kind of tube around the intersection between shape and floor\nfloat sdLowWall(vec3 p) {\n    return length(max(vec2(sdShape(p),.5*sdFloor(p)),0.))-.03;\n}\n\nvec3 closestLight(vec3 p,float i) {\n    vec3 q;\n    q.y = .04;\n    q.xz = floor(.25*p.xz);\n    q.xz = 4.*q.xz+1.+2.*hash22(q.xz+123.456*i);\n    q = shape(q)>.1 ? q : vec3(1e6); // No light if on the negative side of shape\n    return q;\n}\nfloat sdLight(vec3 p,float i) {\n    vec3 l = closestLight(p,i);\n    return length(p-l)-.05;//min(length(p-l)-.03,max(length(p.xz-l.xz)-.005,p.y-l.y));\n}\nfloat sd(vec3 p) {\n    float d;\n    #ifdef SLICES\n    d = min(sdSlicesX(p,SPACEX,THICKNESSX)-ROUNDX,sdSlicesZ(p,SPACEZ,THICKNESSZ)-ROUNDZ);\n    #else\n    d = sdShape(p);\n    #endif\n    float dl = min(sdLight(p,0.),sdLight(p,1.));\n    return min(d,min(sdFloor(p),min(sdLowWall(p),dl)));\n}\n\nvec3 normal(vec3 p) {\n    const vec2 delta = vec2(0,.001);\n    float d = sd(p);\n    vec3 n = vec3(\n        sd(p+delta.yxx),\n        sd(p+delta.xyx),\n        sd(p+delta.xxy)) - d;\n    float l = length(n);\n    // We don't use normalize() here because it outputs garbage when\n    // length is 0, producing black pixels.\n    return l>0. ? n/l : vec3(1,0,0);\n}\n\n// Returns hit distance\nfloat march(vec3 start, vec3 dir) {\n\tfloat total = 0.0, d;\n    vec3 p;\n    float epsilon = 0.1/iResolution.y;\n    for(int i=0; i<STEPS; i++) {\n        p = start + total * dir;\n        d = sd(p);\n        if(d<epsilon*total || total>=FAR) return total;\n        total += d;\n    }\n    return FAR;\n}\n\n// Triplanar or boxmapping\n// From iq\n// https://www.shadertoy.com/view/MtsGWH\nvec3 boxmap(in vec3 p, in vec3 n, in float k )\n{\n    // project+fetch\n\tvec3 x = texture(iChannel2, p.yz).rgb;\n\tvec3 y = texture(iChannel2, p.zx).rgb;\n\tvec3 z = texture(iChannel2, p.xy).rgb;\n    \n    // and blend\n    vec3 m = pow( abs(n), vec3(k) );\n\treturn (x*x*m.x + y*y*m.y + z*z*m.z) / (m.x + m.y + m.z);\n}\n\nvec3 rayColor(vec3 start, vec3 dir) {\n    vec3 color = vec3(0);    \n    vec3 coef = vec3(1);\n    vec3 p = start;\n    \n    for(int i=0; i<3; i++) {\n        float d = march(p, dir);\n        p += d * dir;\n        vec3 n = normal(p);\n\n        if(d >= FAR) {//No ray intersection\n            color += coef * fogColor();\n            return color;\n        } else {\n            float dx = sdSlicesX(p,SPACEX,THICKNESSX)-ROUNDX;\n            float dz = sdSlicesZ(p,SPACEZ,THICKNESSZ)-ROUNDZ;\n            float df = sdFloor(p);\n            float dw = sdLowWall(p);\n            float dl = min(sdLight(p,0.),sdLight(p,1.));\n            \n            float dxz = min(dx,dz);\n            float dfxz = min(df,dxz);\n            \n            vec3 alb;\n            vec3 spe;\n            // Soft shadows are produced by fake ambient occlusion:\n            // if you're on the structure and close to the floor,\n            // or on the floor and close to the wall, then you receive less light.\n            float ao = smoothstep(-.1,2.,df);//pow(df,2.);\n\n            if(dl<min(dw,dfxz)) {\n                color += 2.*coef * bulbColor;\n                return color;\n            }\n            if(dw<dfxz) {// Low wall\n                const vec3 rustColor = vec3(0.06, 0.01, 0.);\n                float rust = smoothstep(.4,.6,fbm4(50.*p));\n                alb = rust*rustColor;\n                spe = mix(.1*vec3(0.95, 0.93, 0.88),rustColor,rust);    \n            } else if(df<dxz) {// Floor\n                ao = dw;\n                alb = texture(iChannel1, p.xz).rgb;\n                alb = alb*alb;\n                spe = vec3(.04);\n            } else if(dz<dx) { // Wood\n                alb = texture(iChannel2, p.xy).rgb;\n                alb = alb*alb;\n                alb = boxmap(p,n,1.);\n                spe = vec3(.01);\n            } else {// Mirror\n                const vec3 rustColor = vec3(0.06, 0.01, 0.);\n                float rust = smoothstep(.4,.6,fbm4(50.*p));\n                alb = rust*rustColor;\n                spe = mix(.2*vec3(0.95, 0.93, 0.88),rustColor,rust);\n            }\n\n            // diffuse + ambient occlusion\n            const vec3 lightDir = vec3(.707,.707,0);\n            float dif = 3.*ao*(.1+max(dot(n,lightDir),0.));\n            vec3 col = dif*alb*fogColor();\n\n            for(float i=0.; i<2.; i++) {\n                vec3 toLight = closestLight(p,i)-p;\n                float lightDist = length(toLight);\n                toLight /= lightDist;\n                float att = smoothstep(1.,0.,lightDist);\n                col += 10.*bulbColor*alb*(max(dot(toLight,n),0.)*att);///(1.+100.*lightDist*lightDist));\n                col += 10.*bulbColor*att*spe*pow(max(dot(normalize(toLight-dir),n),0.),100.);\n            }\n            // Fog\n            float fog = smoothstep(30.,4.,d);\n            col = mix(fogColor(),col,fog);\n            color += coef * col;\n            \n            // Reflection\n            vec3 ref = reflect(dir, n);\n            dir = ref;\n            p += .05*dir;\n            coef *= spe * fog;\n            \n            // If after bounces, the contribution becomes low, stop\n            if(dot(coef,vec3(1))<.05) break;\n        }\n    }\n    return color;\n}\n\nvec3 rayColorWithoutSlices(vec3 start, vec3 dir) {\n    vec3 color = vec3(0);    \n    vec3 coef = vec3(1);\n    vec3 p = start;\n    \n    for(int i=0; i<3; i++) {\n        float d = march(p, dir);\n        p += d * dir;\n        vec3 n = normal(p);\n\n        if(d >= FAR) {//No ray intersection\n            color += coef * fogColor();\n            return color;\n        } else {\n            float ds = sdShape(p);\n            float df = sdFloor(p);\n            float dw = sdLowWall(p);\n            float dl = min(sdLight(p,0.),sdLight(p,1.));\n            \n            float dfs = min(df,ds);\n            \n            vec3 alb;\n            vec3 spe;\n            // Soft shadows are produced by fake ambient occlusion:\n            // if you're on the structure and close to the floor,\n            // or on the floor and close to the wall, then you receive less light.\n            float ao = smoothstep(-.1,2.,df);//pow(df,2.);\n\n            if(dl<min(dw,dfs)) {// Light bulb\n                color += 2.*coef * bulbColor;\n                return color;\n            }\n\n            if(dw<dfs) {// Low wall\n                const vec3 rustColor = vec3(0.06, 0.01, 0.);\n                float rust = smoothstep(.4,.6,fbm4(50.*p));\n                alb = rust*rustColor;\n                spe = mix(.1*vec3(0.95, 0.93, 0.88),rustColor,rust);    \n            } else if(df<ds) {// Floor\n                ao = dw;\n                alb = texture(iChannel1, p.xz).rgb;\n                alb = alb*alb;\n                spe = vec3(.04);\n            } else { // Wood\n                alb = texture(iChannel2, p.xy).rgb;\n                alb = alb*alb;\n                alb = boxmap(p,n,1.);\n                spe = vec3(.01);\n            }/* else {// Mirror\n                const vec3 rustColor = vec3(0.06, 0.01, 0.);\n                float rust = smoothstep(.4,.6,fbm4(50.*p));\n                alb = rust*rustColor;\n                spe = mix(.2*vec3(0.95, 0.93, 0.88),rustColor,rust);\n            }*/\n\n            // diffuse + ambient occlusion\n            const vec3 lightDir = vec3(.707,.707,0);\n            float dif = 3.*ao*(.1+max(dot(n,lightDir),0.));\n            vec3 col = dif*alb*fogColor();\n\n            for(float i=0.; i<2.; i++) {\n                vec3 toLight = closestLight(p,i)-p;\n                float lightDist = length(toLight);\n                toLight /= lightDist;\n                float att = smoothstep(1.,0.,lightDist);\n                col += 10.*bulbColor*alb*(max(dot(toLight,n),0.)*att);///(1.+100.*lightDist*lightDist));\n                col += 10.*bulbColor*att*spe*pow(max(dot(normalize(toLight-dir),n),0.),100.);\n            }\n            // Fog\n            float fog = smoothstep(30.,4.,d);\n            col = mix(fogColor(),col,fog);\n            color += coef * col;\n            \n            // Reflection\n            vec3 ref = reflect(dir, n);\n            dir = ref;\n            p += .05*dir;\n            coef *= spe * fog;\n            \n            // If after bounces, the contribution becomes low, stop\n            if(dot(coef,vec3(1))<.05) break;\n        }\n    }\n    return color;\n}\n\nmat3 viewMatrix(vec3 forward, vec3 up) {\n \tvec3 w = -normalize(forward);\n    vec3 u = normalize(cross(up, w));\n    vec3 v = cross(w, u);\n    \n    return mat3(u,v,w);\n}\n\n// Get camera position from Buffer A\nvec2 camPos(float t, out vec3 forward) {\n    forward.xz = texelFetch(iChannel3, ivec2(0), 0).zw;\n    forward.y = .1;\n    return texelFetch(iChannel3, ivec2(0), 0).xy;\n}\nvec3 headDirection() {\n    float a = 0., b = 0.;\n    if(iMouse.z>0.) {\n        a = 3.14159*((2.*iMouse.x/iResolution.x)-1.);\n        b = (2.*iMouse.y/iResolution.y)-1.;\n    } else {\n        float t = 2.*iTime;\n        float fr = mod(t,20.);\n        float fl = t - fr;\n        \n      //  vec2 h1 = hash21(fl); h1.x = 2.*h1.x-1.;\n      //  vec2 h2 = hash21(fl+183.152); h2.x = 2.*h2.x-1.;\n        vec4 h = hash41(fl); h.xz=2.*h.xz-1.;\n        vec3 dt = hash31(fl+135.18);\n        \n        vec2 angles = mix(vec2(0),\n                    mix(h.xy,\n                        mix(h.zw,\n                            vec2(0),\n                            smoothstep(11.+dt.z,13.+dt.z,fr)),\n                        smoothstep(8.+dt.y,10.+dt.y,fr)),\n                    smoothstep(5.+dt.x,7.+dt.x,fr));\n        a = angles.x;//(smoothstep(8.,10.,fr)-smoothstep(12.,1.,fr))*(2.*h.x-1.);//sin(2.*3.14159*fr);\n        b = angles.y;//(smoothstep(0.,.5,fr)-smoothstep(.6,1.,fr))*h.y;//.5-.5*cos(2.*3.14159*fr);\n    }\n    return vec3(sin(a)*cos(b),sin(b),-cos(a)*cos(b));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float t = iTime;\n    cam.xz = camPos(t,forward);\n\n    #ifdef MAP\n    // Map\n    float aa = 30./iResolution.y;\n    vec2 uv = aa*(fragCoord-.5*iResolution.xy);\n    vec2 p = uv + cam.xz;\n    vec3 col = vec3(smoothstep(-aa,aa,shape(vec3(p.x,0,p.y))));\n    \n    for(float i=0.; i<2.; i++) {\n        vec2 l = closestLight(vec3(p.x,0.,p.y),i).xz;\n        col = mix(col, .75*bulbColor, smoothstep(-aa,aa,.4-length(p-l)));\n    }\n    \n    mat2 m = mat2(forward.x,-forward.z,forward.z,forward.x);\n    p = m * uv;\n    col = mix(col, vec3(0,0,1), smoothstep(-aa,aa,min(p.x+2.,-.4*p.x-abs(p.y))));\n    fragColor = vec4(col, 1.);\n    \n    #else\n    // Walker's view\n    // - bouncing up and down\n    cam.y = .1+.01*pow(abs(cos(6.*iTime)),3.);\n    const vec3 up = vec3(0,1,0);\n    mat3 m = viewMatrix(forward, up);\n    // - sight direction\n    forward = m * headDirection();\n    m = viewMatrix(forward, up);\n    \n    vec2 uv = 2.0*(fragCoord - .5* iResolution.xy)/iResolution.y;\n    vec3 pix = vec3(tan(0.5*fov*0.01745)*uv,-1);\n    vec3 dir = normalize(m*pix);\n\n    #ifdef SLICES\n    vec3 color = rayColor(cam, dir);\n    #else\n    vec3 color = rayColorWithoutSlices(cam, dir);\n    #endif\n    \n    // Mix with previous image to reduce flickering due\n    // to lots of mirrors and edges.\n    vec3 prevColor = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    color = mix(prevColor, color, .9);\n\n    fragColor = vec4(color,1.0);\n    #endif\n}","name":"Buffer B","description":"","type":"buffer"}]}