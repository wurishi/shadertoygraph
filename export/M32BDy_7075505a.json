{"ver":"0.1","info":{"id":"M32BDy","date":"1729916551","viewed":29,"name":"Processor chip 101","username":"kukovisuals","description":"processor chip","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["cpu"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    .-@kukovisuals \n*/\n// Function to rotate a point by a given angle\nvec2 rotate(vec2 p, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec2(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n// Function to check if point `p` is within the square or its edge\nbool isSquare(vec2 p, float edgeThickness) {\n    bool insideSquare = (p.x > 0.44 && p.x < 0.55 && p.y > 0.44 && p.y < 0.55);\n    bool onSquareEdge = (abs(p.x - 0.44) < edgeThickness || abs(p.x - 0.55) < edgeThickness ||\n                         abs(p.y - 0.44) < edgeThickness || abs(p.y - 0.55) < edgeThickness);\n    return insideSquare && onSquareEdge;\n}\nbool isCenterLine(vec2 p, float lineThickness, float dashFrequency, float dashDutyCycle, float timeOffset) {\n    // Center lines\n    bool verticalLine = abs(p.x - 0.5) < lineThickness;\n    bool horizontalLine = abs(p.y - 0.5) < lineThickness;\n    // Create moving dashes by offsetting with `timeOffset`\n    bool dashedVertical = mod(p.y * dashFrequency + (timeOffset * 2.3) , 1.0) < dashDutyCycle;\n    bool dashedHorizontal = mod(p.x * dashFrequency + timeOffset, 1.0) < dashDutyCycle;\n    // Combine line and dash conditions\n    return (verticalLine && dashedVertical) || (horizontalLine && dashedHorizontal);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv * 1.2;\n\n    float edgeThickness = 0.03;\n    float lineThickness = 0.001;\n    float dashFrequency = 10.0; // Adjust for number of dashes\n    float dashDutyCycle = 0.1;  // 50% dash, 50% gap\n    float timeOffset = iTime * 0.5;\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    // Apply initial rotation and bend\n    p = rotate(p, radians(0.0));\n    // apply wave movement\n    //p.y += 0.1 * sin(p.x * 1.0 + iTime);\n    for (int i = 0; i < 6; i++) {\n        p = fract(p); // Wrap `p` in range [0, 1]\n        p.x = abs(p.x - 0.5) + 0.5; // Mirror horizontally\n        p.y = abs(p.y - 0.5) + 0.5; // Mirror vertically\n        // Check for square and center line patterns\n        if (isSquare(p, edgeThickness)) {\n            color = vec3(0.0, 0.5, 0.7); // White for square edges\n        } else if (isCenterLine(p, lineThickness, dashFrequency, dashDutyCycle, timeOffset)) {\n            color = vec3(1.0, 1.0, 1.0); // White for center lines\n        }\n        p *= 1.6; // Scale down for next fractal level\n    }\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}