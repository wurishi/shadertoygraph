{"ver":"0.1","info":{"id":"lflSRH","date":"1717047145","viewed":54,"name":"MengerBob Tesseract","username":"entropynine","description":"from: https://www.shadertoy.com/view/lsyBDD","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["tesseract","mengerbob"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define asgt(i) abs(sin(i * iTime))\n#define acgt(i) abs(cos(i * iTime))\n#define sgt(i) sin(i * iTime)\n#define cgt(i) cos(i * iTime)\n#define A 2. * iTime\n#define Giter 6\n#define MaxSteps 20\n#define MinimumDistance 0.0009\n#define Iterations 10\n#define Offset vec3(0.92858,0.92858,0.32858)\n\n\nfloat DE(in vec3 z) \n{\n    float Scale = 2.0 + 1.2*asgt(0.1);\n    Scale += 0.2*sgt(1.);\n\n\tz  = abs(2.-mod(z,4.0));\n\n    z.x *= (1. - 0.01*sgt(1.));\n    z.y *= (1. + 0.01*cgt(1.0));\n    z.z *= (1. + 0.01*sgt(1.0));\n\n\tfloat d = 10.0;\n\tfor (int m = 0; m < Iterations; m++) {\t\n\t\tz = abs(z);\n\t\tif (z.x<z.y){ z.xy = z.yx;}\n\t\tif (z.x< z.z){ z.xz = z.zx;}\n\t\tif (z.y<z.z){ z.yz = z.zy;}\n\t\tz = Scale*z-Offset*(2.*Scale-1.);\n\t\tif( z.z < -0.5*Offset.z*(Scale-1.0))  z.z+=Offset.z*(Scale-1.0);\n\n        d = min(d, length(z) * pow(Scale, float(-m)-1.0));\n\t}\n\n\treturn d-0.001;\n}\n    \n\nvec3 Glow(vec3 z, float b){\n    z = fract( z * .2) * 2. -1.; \n\n    for( int i = 0; i < Giter; ++i){ \n        float d = clamp( dot(z, z), .05, .65); \n        z = abs( z ) / d - 1.31;\n    }\n    return z;\n}\n\n\nvec3 fog(float a,vec3 b,float c){ \n    return 1. / (( 1. + 2.*b/a + b * b/(a*a))*c );\n}\n\n\nvec3 W(vec3 fr,float b,float c,float d){\n    vec3 e=(fog( .1, abs(fr), d)*1. +\n            fog( .1, vec3(length( fr.yz ), length( fr.zx ), length( fr.xy )), d) * 5.0 \n            * (sin( A * vec3(2.1, 1.3, 1.7) + b*10.) + 1.)); \n\n    return (e * 7. + e.yzx * 1.5 + e.zxy * 1.5) * max( .5 -c *(200.+500.*asgt(1.)) / d, 0. ) / d * 70.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy / iResolution.xy *2. -1.;\n\n    float speed = 0.5;\n \n    vec3 base = vec3(0.1, 0.3*sgt(0.1), 0.3*cgt(0.1)) * speed;\n\n    vec3 camPos = 0.2*iTime * base;\n\tvec3 target = camPos + base;\n\tvec3 camUp  = vec3(0.0,1.0,0.0);\n\n\tvec3 camDir   = normalize(target-camPos);\n\tcamUp = normalize(camUp-dot(camDir,camUp)*camDir);\n\tvec3 camRight = normalize(cross(camDir,camUp));\n\n    vec3 rayDir = normalize( (camRight * uv.x  + camUp * uv.y + camDir));\n    vec3 pos, color; float totalDistance, distance, v;\n\n    for(int i = 0; i < 64; ++i){\n        pos = camPos + rayDir * totalDistance;\n        distance = DE(pos);        \n        v = sin( A * .1 + pos.z);\n        vec3 x = Glow( pos, v);\n        totalDistance += distance + .001; \n        //color += ( 0.5*W( x, v, distance, 1.) ) * (distance + 0.001);\n        color +=  0.2*W( x, v, distance, 1.)  * (distance + 0.001)+ \n                   0.2*W( x, v, distance, 21.0 )  * (distance + 0.002)+ \n                   1.2*W( x, v, distance, 51.0 )  * (distance + 0.004);        \n    }\n    fragColor = vec4( pow( color, vec3( .45 )), .5);\n}","name":"Image","description":"","type":"image"}]}