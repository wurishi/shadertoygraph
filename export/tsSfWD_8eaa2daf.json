{"ver":"0.1","info":{"id":"tsSfWD","date":"1590532165","viewed":215,"name":"Fly With Me - Happy Together","username":"ayquo","description":"Happy little butterflies doing the thing they do best.\nWe are Hork.\n","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["ribbon","ray","sdf","marching","butterfly"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Fly With Me-Happy Together\n * By Haico ten Lohuis - Ayquo 2020\n */\n\n/* Base: \"RayMarching starting point\" by BigWings https://www.shadertoy.com/view/WtGXDD */\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\n/* Iq https://iquilezles.org/articles/distfunctions */\nfloat sdEllipsoid(vec3 p,vec3 r)\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdSphere(vec3 p,float r)\n{\n    return length(p)-r;\n}\n\nfloat sdBox(vec3 p,vec3 s) {\n    p = abs(p)-s;\n    return length(max(p,0.))+min(max(p.x,max(p.y,p.z)),0.);\n}\n\n/* https://github.com/glslify/glsl-look-at/blob/gh-pages/index.glsl */\nmat3 calcLookAtMatrix(vec3 origin,vec3 target,float roll) \n{\n  vec3 rr = vec3(sin(roll),cos(roll),0.0);\n  vec3 ww = normalize(target-origin);\n  vec3 uu = normalize(cross(ww,rr));\n  vec3 vv = normalize(cross(uu,ww));\n  return mat3(uu,vv,ww);\n}\n\n/* Butterfly SDF by Ayquo 2020 */\nfloat sdButterfly(vec3 p,out int colorIndex)\n{    \n    // Mirror space\n    p.x = abs(p.x); \n    \n    /* Body */\n    float butterfly = sdEllipsoid(p+vec3(0,0,.1),vec3(.15,.15,.6));\n    \n    /* Antenna */\n    // Rotate space for antenna\n    vec3 pr = p;\n    pr.xz *= Rot(-.2);\n    butterfly = min(butterfly,sdEllipsoid(pr+vec3(0.1,0,1.),vec3(.05,.05,.5)));\n    \n    /* Front wing */\n    // Rotate space for front wing flutter\n    pr = p;\n    pr.xy *= Rot(sin(iTime*FLUTTER_FREQ));\n\n    // Front wing\n    vec3 pp = pr+vec3(-.9,0,0.7);\n    pp.xz *= Rot(.7);\n    float wing = sdEllipsoid(pp,vec3(1.,.1,.5));\n    wing = max(wing,-sdEllipsoid(pp,vec3(1.,.5,.5)*.75));\n    // Inner front wing\n    float innerFrontWing = sdEllipsoid(pp,vec3(1.,.1,.5)*.5);\n    \n    // Front wing bridge\n    pp = pr+vec3(-.95,0,0.7)*.5;\n    pp.xz *= Rot(.7);\n    wing = min(wing,sdEllipsoid(pp,vec3(1.,.25,.1)*.75));\n    butterfly = min(butterfly,wing);\n    \n    /* Back wing */\n    // Rotate space for back wing flutter\n    pr = p;\n    pr.xy *= Rot(-cos(iTime*FLUTTER_FREQ));    \n\n    // Back wing\n    pp = pr+vec3(-.7,0,-0.5);\n    pp.xz *= Rot(-.7);\n    \n    wing = sdEllipsoid(pp,vec3(1.,.1,.5)*.75);\n    wing = max(wing,-sdEllipsoid(pp,vec3(1.,.5,.5)*.75*.75));\n    butterfly = min(butterfly,wing);\n    // Inner back wing\n    float innerBackWing = sdEllipsoid(pp,vec3(1.,.1,.5)*.35);\n\n    // Back wing bridge\n    pp = pr+vec3(-.8,0,-0.5)*.5;\n    pp.xz *= Rot(-.7);\n    wing = min(wing,sdEllipsoid(pp,vec3(1.,.25,.1)*.5));\n    butterfly = min(butterfly,wing);\n    \n    // Decide which color and distance to return\n    if (butterfly < min(innerFrontWing,innerBackWing)) {\n        colorIndex = 0;    \n        return butterfly;        \n    } else {\n        colorIndex = 1;    \n        return (innerFrontWing<innerBackWing)?innerFrontWing:innerBackWing;\n    }\n}\n\nvec3 getPosFromOffset(vec3 p,float off)\n{\n    p.x+= sin(off)-sin(off*.834)-sin(off*.255)-sin(off*.184)-sin(off*1.179)+sin(off*.346);\n    p.y+= cos(off)-cos(off*.345)-cos(off*.598)-cos(off*.253)-cos(off*1.179)+cos(off*.346);\n    return p;\n}\n\nfloat getButterflyFromPos(vec3 p,out int colorIndex)\n{\n    vec3 origin = getPosFromOffset(p,-t);\n    vec3 target = getPosFromOffset(p,-t-.1);\n    float roll = (origin.x-target.x)*5.;\n    mat3 lookAt = calcLookAtMatrix(origin,target+vec3(0,0,.1),roll);    \n    return sdButterfly(target*lookAt,colorIndex);\n}\n\nfloat GetDist(vec3 p,out int colorIndex) \n{      \n    float off = p.z-t;\n    \n    vec3 q = vec3(\n        sin(off*.407),\n        cos(off*.407),\n        0.\n   )*2.;\n    \n    int butterfly1ColorIndex = 0;\n    float butterfly1 = getButterflyFromPos(p-q,butterfly1ColorIndex);\n    butterfly1ColorIndex = butterfly1ColorIndex==0?BUTTERFLY_1_COLORINDEX_1:BUTTERFLY_1_COLORINDEX_2;\n    \n    vec3 trail1pos = getPosFromOffset(p,off);    \n    float trail1 = sdBox(trail1pos-q-vec3(0.,0.,MAX_DIST),vec3(.2,.025,MAX_DIST)); \n    if (trail1 < butterfly1) {\n        butterfly1 = trail1;\n        if (mod(p.z,1.) < .5) {\n            butterfly1ColorIndex = BUTTERFLY_1_COLORINDEX_1;\n        } else {\n            butterfly1ColorIndex = BUTTERFLY_1_COLORINDEX_2;\n        }\n    }\n\n    int butterfly2ColorIndex = 0;\n    float butterfly2 = getButterflyFromPos(p+q,butterfly2ColorIndex);\n    butterfly2ColorIndex = butterfly2ColorIndex==0?BUTTERFLY_2_COLORINDEX_1:BUTTERFLY_2_COLORINDEX_2;\n\n    vec3 trail2pos = getPosFromOffset(p,off);       \n    float trail2 = sdBox(trail2pos+q*1.-vec3(0.,0.,MAX_DIST),vec3(.2,.025,MAX_DIST));\n    if (trail2 < butterfly2) {\n        butterfly2 = trail2;\n        if (mod(p.z,1.) < .5) {\n            butterfly2ColorIndex = BUTTERFLY_2_COLORINDEX_1;\n        } else {\n            butterfly2ColorIndex = BUTTERFLY_2_COLORINDEX_2;\n        }\n    }\n    \n    if (butterfly1<butterfly2) {\n        colorIndex = butterfly1ColorIndex;\n        return butterfly1;\n    } else { \n        colorIndex = butterfly2ColorIndex;\n        return butterfly2;\n    }\n}\n\nfloat GetDist(vec3 p) {    \n    int dontCare;\n    return GetDist(p,dontCare);\n}\n\nfloat RayMarch(vec3 ro,vec3 rd,out int colorIndex) {\n    float dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro+rd*dO;\n        float dS = GetDist(p,colorIndex);\n        dO+= dS*.6;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p);\n    vec2 e = vec2(.001,0);\n    \n    vec3 n = d-vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv,vec3 p,vec3 l,float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0),f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c+uv.x*r+uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;    \n    vec3 col = vec3(0);    \n    vec3 co = vec3(4,2,-3)*2.;    \n    co.xz *= Rot(-(iTime+34.5)*.1);    \n    vec3 cd = GetRayDir(uv,co,vec3(2,1,0),1.);    \n    cd *= STEP_FACTOR;\n    \n    int colorIndex;\n    float d = RayMarch(co,cd,colorIndex);\n    \n    if(d<MAX_DIST) {\n        if (BUTTERFLY_1_COLORINDEX_1==colorIndex) {\n            col = BUTTERFLY_1_COLOR_1;\n        } else if (BUTTERFLY_1_COLORINDEX_2==colorIndex) {\n            col = BUTTERFLY_1_COLOR_2;\n        } else if (BUTTERFLY_2_COLORINDEX_1==colorIndex) {\n            col = BUTTERFLY_2_COLOR_1;\n        } else if (BUTTERFLY_2_COLORINDEX_2==colorIndex) {\n            col = BUTTERFLY_2_COLOR_2;\n        }\n        vec3 p = co+cd*d;\n        vec3 n = GetNormal(p);\n        \n        float dif = dot(n,normalize(vec3(1,2,3)))*.5+.5;\n        col *= dif;  \n    }\n    \n    // Increase contrast for bright trippy colors\n    col = clamp(col*1.5,0.,1.);\n    \n    // Fog\n    col *= clamp(exp(-0.00008*d*d),0.02,1.);\n    \n    // Gamma correction\n    col = pow(col,vec3(.4545));\n    \n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_STEPS \t\t\t\t\t250\n#define MAX_DIST \t\t\t\t\t200.\n#define SURF_DIST \t\t\t\t\t.001\n#define STEP_FACTOR \t\t\t\t.40\n#define t \t\t\t\t\t\t\t((iTime*5.)+52.4)\n#define FLUTTER_FREQ \t\t\t\t35.\n\n#define COLOR_TEAL \t\t\t\t\t(vec3(0.,   175., 210.)/255.)\n#define COLOR_ORANGE \t\t\t\t(vec3(210., 140.,   0.)/255.)\n#define COLOR_RED \t\t\t\t\t(vec3(210.,   0.,  70.)/255.)\n#define COLOR_PURPLE \t\t\t\t(vec3(128.,   0., 255.)/255.)\n\n#define BUTTERFLY_1_COLORINDEX_1 \t0\n#define BUTTERFLY_1_COLORINDEX_2 \t1\n#define BUTTERFLY_2_COLORINDEX_1\t2\n#define BUTTERFLY_2_COLORINDEX_2\t3\n\n#define BUTTERFLY_1_COLOR_1 \t\tCOLOR_RED\n#define BUTTERFLY_1_COLOR_2 \t\tCOLOR_TEAL\n#define BUTTERFLY_2_COLOR_1 \t\tCOLOR_ORANGE\n#define BUTTERFLY_2_COLOR_2 \t\tCOLOR_PURPLE\n","name":"Common","description":"","type":"common"}]}