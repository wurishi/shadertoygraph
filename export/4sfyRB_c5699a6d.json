{"ver":"0.1","info":{"id":"4sfyRB","date":"1488585337","viewed":173,"name":"RayMarch Template","username":"rhino1181","description":"Basic raymarcher","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarched"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdSphere(vec3 pos, float radius)\n{\n    //return sqrt(pos.x*pos.x + pos.y*pos.y + pos.z*pos.z)-radius;\n    return length(pos) - radius;\n}\n\n\nfloat distFunc(vec3 pos)\n{\n    vec3 spherePos = vec3(0.0, 0.0, 5.0);\n    vec3 spherePos2 = spherePos + vec3(3.0 * sin(iTime), 3.0 * cos(iTime), 0.0);\n    vec3 delta = spherePos - pos;\n    vec3 delta2 = spherePos2 - pos;\n    float s1 = sdSphere(delta, 1.0);\n    float s2 = sdSphere(delta2, 0.5);\n    return min(s1, s2);\n}\n\nvec2 rotateAroundPoint(vec2 p, vec2 o, float offset, float speed)\n{\n    vec2 newPos;\n    newPos.x = sin((iTime * speed) + offset) * (p.x - o.x) - cos((iTime * speed) + offset) * (p.y - o.y) + o.x;\n    newPos.y = cos((iTime * speed) + offset) * (p.x - o.x) + sin((iTime * speed) + offset) * (p.y - o.y) + o.y;\n    return newPos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 camPos = vec3(0.0, 0.0, 10.0);\n    //camPos.xz = rotateAroundPoint(camPos.xz, vec2(0.0), 0.0, 1.0);\n    //camPos.xz = vec2(2.0 * sin(iTime), 2.0 * cos(iTime));\n    \n    vec3 camTarget = vec3(0.0);\n    vec3 worldUp = vec3(0.0, 1.0, 0.0);\n    \n    vec3 camDir = normalize(camTarget - camPos);\n    \n    vec3 camRight = normalize(cross(worldUp, camPos));\n    vec3 camUp = cross(camDir, camRight); \n    \n    vec3 lightPos = vec3(3.0 * sin(iTime), 0.0, 10.0);\n    \n    vec2 screenPos = -1.0 + (2.0 * fragCoord.xy / iResolution.xy);\n    screenPos.x *= iResolution.x / iResolution.y;\n    \n    vec3 rayDir = normalize(camRight * screenPos.x + camUp * screenPos.y + camDir);\n    \n    const int MAX_ITER = 100;\n    const float MAX_DIST = 20.0;\n    const float EPSILON = 0.001;\n    \n    float totalDist = 0.0;\n    vec3 pos = camPos;\n    float dist = EPSILON;\n    \n    for(int i = 0; i < MAX_ITER; i++)\n    {\n        if(dist < EPSILON || totalDist > MAX_DIST)\n            break;\n        \n        dist = distFunc(pos);\n        totalDist += dist;\n        pos += rayDir * dist;\n    }\n    \n    if(dist < EPSILON)\n    {\n     \tvec2 eps = vec2(0.0, EPSILON);\n        vec3 normal = normalize(vec3(\n            distFunc(pos + eps.yxx) - distFunc(pos - eps.yxx),\n            distFunc(pos + eps.xyx) - distFunc(pos - eps.xyx),\n            distFunc(pos + eps.xxy) - distFunc(pos - eps.xxy)));\n        \n        float diffuse = dot(normalize(lightPos-pos), normal);\n        float spec = pow(diffuse, 50.0);\n        vec3 ambient = vec3(0.05, 0.05, 0.05);\n        vec3 diffuseColor = vec3(0.42, 0.25, 1.0) * diffuse;\n        vec3 color = vec3(diffuseColor + spec + ambient);\n        fragColor = vec4(color, 1.0);\n    }\n    else\n    {\n        fragColor = vec4(0.0);\n    }\n    \n}","name":"Image","description":"","type":"image"}]}