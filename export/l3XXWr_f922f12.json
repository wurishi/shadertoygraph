{"ver":"0.1","info":{"id":"l3XXWr","date":"1709374666","viewed":73,"name":"RayTracing Spheres (Final)","username":"Chifsmoothskillz","description":"RayTracing, the final version of my first Project\n(Made with the help of \"Computer Graphics from Scratch\")","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int lights = 3;\nconst int spheres = 4;\n\nconst float planeD = 1.0;\nfloat time;\nfloat cw, ch;\nfloat vw = 1.0, vh;\nfloat gamma = 1.0;\n\nvec2 coord;\n\n\nstruct light {\n    //1 = ambient, 2 = point, 3 = directional; \n    int type;\n    float intensity;\n    vec3 position;\n};\n\n\nstruct sphere {\n    vec3 center;\n    float radius;\n\n    vec3 color;\n    float specular;\n    float reflective;\n};\n\n\n\n\n//lights\nlight ambient = light(\n    1,\n    0.1,\n    vec3(0.0)\n);\n\n\nlight point = light(\n    2,\n    0.3,\n    vec3(2.0, 9.0, 0.0)\n);\n\nlight directional = light(\n    3,\n    0.2,\n    vec3(3.0, 1.0, -1.0)\n);\n\n\n\n//sphere\nsphere s1 = sphere(\n    vec3(0.0, -1.0, 3.0),\n    1.0,\n    \n    vec3(255.0, 0.0, 0.0),\n    10.0,\n    0.1\n);\nsphere s2 = sphere(\n    vec3(2.0, 0.0, 4.0),\n    1.0,\n    \n    vec3(0.0, 0.0, 255.0),\n    -1.0,\n    0.2\n);\nsphere s3 = sphere(\n    vec3(-2.0, 0.0, 4.0),\n    1.0,\n    \n    vec3(128.0, 128.0, 128.0),\n    500.0,\n    0.9\n);\n\nsphere sbg = sphere(\n    vec3(0.0,-5001.0, 0.0),\n    5000.0,\n    \n    vec3(91.0, 58.0, 41.0),\n    0.8,\n    0.01\n);\n\n\n//sonstige Funktionen\nvec3 canvas2viewport(float x, float y, float d){\n    return vec3(x * vw / cw, y * vh / ch, d);\n}\n\nvec3 background(){\nvec2 uv = coord/iResolution.xy;\nreturn vec3(texture(iChannel0, uv+time));\n//return vec3(0.0);\n}\n\n\n//RayIntersection function\nvec2 IntersectRaySphere(vec3 O, vec3 D, sphere sp){\n    float r = sp.radius;\n    vec3 CO = O-sp.center;\n\n    float a = dot(D, D);\n    float b = 2.0*dot(CO, D);\n    float c = dot(CO,CO)-r*r;\n    \n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0) {\n        return vec2(100000000.0, 100000000.0);\n    }\n    \n    float t1 = (-b + sqrt(discriminant)) / (2.0 * a);\n    float t2 = (-b - sqrt(discriminant)) / (2.0 * a);\n    \n    return vec2(t1, t2);\n}\n\n//Next closest Intersection\n\nstruct clst_Sphere {\n    //1 = ambient, 2 = point, 3 = directional; \n    float t;\n    sphere sp;\n};\n\n\nclst_Sphere ClosestIntersection(vec3 O, vec3 D, float t_min, float t_max){\n    float clst_t = 10000000000.0;\n\n    sphere clst_sphere;\n    bool get = false;\n\n\n\n    sphere sp[spheres] = sphere[spheres](s1,s2,s3,sbg);\n\n    for(int i =0; i<=spheres-1; i++){\n        vec2 t = IntersectRaySphere(O, D, sp[i]);\n        \n        if( t.x > t_min && t.x < t_max && t.x < clst_t){\n            clst_t = t.x;\n            clst_sphere = sp[i];\n            get = true;\n        }\n        if( t.y > t_min && t.y < t_max && t.y < clst_t){\n            clst_t = t.y;\n            clst_sphere = sp[i];\n            get = true;\n        }\n        \n    }\n    \n if(get == false){\n clst_t = 0.0;\n }\n clst_Sphere clst = clst_Sphere(clst_t, clst_sphere);\n \n return clst;\n}\n\n\n\n//Licht Berechnungen\nfloat ComputeLighting(vec3 P,vec3 N, vec3 V, float s){\n    float i = 0.0;\n    light l[lights] = light[lights](ambient, directional, point);\n    vec3 L = vec3(0.0);\n\nfor(int j =0; j<=lights; j++){\n    \n    //Diffuse\n    if(l[j].type == 1){\n        i+= l[j].intensity;\n    }else{\n        if(l[j].type == 2){\n            L = l[j].position - P;\n        }\n        else if(l[j].type == 3){\n            L = l[j].position;\n        }\n        \n        clst_Sphere clst = ClosestIntersection(P, L, 0.001, 100000.0);\n        float cl_t = clst.t;\n            if(cl_t == 0.0){\n\n                   if(dot(N,L) > 0.0){\n                       i+= l[j].intensity * dot(N,L)/(length(N)*length(L));\n                   }\n\n\n                //Specular\n                if(s>=0.0 && l[j].type != 1){\n                    vec3 R = 2.0 * N * dot(N, L) -L;\n\n                    float r_d_v = dot(R, V);\n                    if(r_d_v >0.0){\n                        i += l[j].intensity * pow(r_d_v/(length(R) * length(V)), s);\n            }\n            }\n        }\n    } \n}\nreturn i/255.0;\n}\n\n\n\nvec3 ReflectRay(vec3 R, vec3 N) {\n    return 2.0 * N * dot(N, R) - R;\n}\n\n\n//\n//\nvec3 TraceRay1(vec3 O, vec3 D,float t_min,float t_max){\nfloat clst_t = 10000000000.0;\n\nsphere clst_sphere;\nbool get = false;\n\nclst_Sphere clst = ClosestIntersection(O, D, t_min, t_max);\nsphere cl_sphere = clst.sp;\nfloat cl_t = clst.t;\n\n\nif(cl_t == 0.0){\n    return background();\n}\n    \nvec3 P = O + cl_t * D;\nvec3 N = P - cl_sphere.center;\nreturn cl_sphere.color * ComputeLighting(P,N,-D,cl_sphere.specular);\n}\n//\n//\n\n//Farbe zur√ºck geben\nvec3 TraceRay(vec3 O, vec3 D,float t_min,float t_max, int recursion){\nfloat clst_t = 10000000000.0;\n\nsphere clst_sphere;\nbool get = false;\n\nclst_Sphere clst = ClosestIntersection(O, D, t_min, t_max);\nsphere cl_sphere = clst.sp;\nfloat cl_t = clst.t;\n\n\nif(cl_t == 0.0){\n    return background();\n}\n    \nvec3 P = O + cl_t * D;\nvec3 N = P - cl_sphere.center;\nvec3 localColor = cl_sphere.color * ComputeLighting(P,N,-D,cl_sphere.specular);\n\nfloat r = cl_sphere.reflective;\n\nif(recursion <= 0 || r <= 0.0){\nreturn localColor;\n}\n\nvec3 R = ReflectRay(-D, N);\nvec3 reflectedColor = TraceRay1(P, R, 0.1, 1000000.0);\n\nreturn localColor * (1.0 -  r) + reflectedColor * r;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    coord = fragCoord;\n    time = iTime/20.0;\n    cw = iResolution.x;\n    ch = iResolution.y;\n    vh = iResolution.y/iResolution.x;\n    float x = fragCoord.x - cw / 2.0;\n    float y = fragCoord.y - ch / 2.0;\n    vec3 d = canvas2viewport(x, y, planeD);\n    //d.y += (iMouse.y/iResolution.y)-0.5;\n    //d.x += (iMouse.x/iResolution.x)-0.5;\n    \n    \n    vec3 o = vec3(0.0, 0.5, -5.0);\n    \n    vec3 col = TraceRay(o, d, 1.0, 1000000.0, 3);\n    \n    \n    col.x = pow(col.x, gamma);\n    col.y = pow(col.y, gamma);\n    col.z = pow(col.z, gamma);\n    \n    fragColor = vec4(col,1.0);\n\n}","name":"Image","description":"","type":"image"}]}