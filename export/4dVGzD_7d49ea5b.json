{"ver":"0.1","info":{"id":"4dVGzD","date":"1453517299","viewed":523,"name":"fishing village","username":"ejang","description":"fishing village. . Reference image: https://www.youtube.com/watch?v=3ehuu3Zq8L8\nwork in progress. TODO : optimizations, fix swimming textures on boat, add raymarched fog to horizon.","likes":10,"published":1,"flags":0,"usePreview":1,"tags":["procedural","3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Eric Jang (c) 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#define clamp01(a) clamp(a,0.0,1.0)\n#define opS(d1,d2) max(-d1,d2)\n// union 2 objects carrying material info\n#define opU(a,b) ((a.x < b.x) ? a : b)\n\n#define PI 3.14159\n\n// implicitly specifies shading rules\n#define WOOD_MAT 0.\n#define STRAW_MAT 1.\n#define VILLAGE_MAT 2.\n\n#define ID_NONE -1\n#define ID_SKY 0\n#define ID_WATER 1\n#define ID_MOUNTAIN 2\n#define ID_VILLAGE 3\n\n// hash maps sequences to random-ish values\nfloat hash(float u)\n{\n    float f=u*13.1;\n    return fract(sin(f)*134735.3);\n}\n\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\n\nvec3 hash3( float n ) {\n\treturn fract(sin(vec3(n,n+1.0,n+2.0))*vec3(84.54531253,42.145259123,23.349041223));\n}\n\nvec3 rX(const in vec3 v, const in float cs, const in float sn) {return mat3(1.0,0.0,0.0,0.0,cs,sn,0.0,-sn,cs)*v;}\nvec3 rY(const in vec3 v, const in float cs, const in float sn) {return mat3(cs,0.0,-sn,0.0,1.0,0.0,sn,0.0,cs)*v;}\nvec3 rZ(const in vec3 v, const in float cs, const in float sn) {return mat3(cs,sn,0.0,-sn,cs,0.0,0.0,0.0,1.0)*v;}\n\n// modeling functions\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )// h = radius, height\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat dPlane(in vec3 ro, in vec3 rd)\n{\n    vec3 p0=vec3(0.);\n    vec3 n=vec3(0.,1.,0.);\n    return dot(p0-ro,n)/dot(rd,n);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    // 4 slightly different shifted versions\n    // of the same set of blocky tiles.\n    // we blend them together in x,y directions via\n    // 3 mix operations\n    // a=mix h00, h10 across x axis, \n    // b=mix h10, h11 across x axis\n    // c=mix a,b across y axis\n    // to get smooth clouds texture.\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + vec2(1,0));\n    float h01 = Hash2d(fl + vec2(0,1));\n    float h11 = Hash2d(fl + vec2(1,1));\n    return mix(mix(h00, h10, fr.x), mix(h01, h11, fr.x), fr.y);\n}\n\nfloat clouds(in vec3 rd)\n{\n    vec2 p=rd.xz/rd.y; // rd.xz/rd.y scales down farther in horizon \n \tfloat n = noise2d(p*1.0); \n    n += noise2d(p*2.0)*0.5;\n    n += noise2d(p*4.0)*0.25;\n    n += noise2d(p*8.0)*0.125;\n    n = mix(n * 0.4, n, clamp01(abs(rd.y*3.)));  // fade clouds in distance\n    return n;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz)-c.z;\n}\nfloat sdCappedCone( in vec3 p, in vec3 c ) // c=vec3(bottom radius, angle , height)\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdHouse(vec3 p, vec3 i, vec3 o, float h1, float h2) \n{ \n    // implemented as the intersection of an inner\n    // udroundbox and outer udroundbox rotated 45 degrees\n    // i and o are the xyz scales, respectively.\n    // o is shifted down h units prior\n    \n    return max(udRoundBox(p-vec3(0.,-h1,0.),i,.01),\n               udRoundBox(rZ(p-vec3(0.,-h2,0.),0.707106,0.707106),o,.01));\n}\n\n// TODO - village will be done in for loop that creates triangular \n// prisms atop each other in scattered manner\n// windows traced using heightmap function\nvec2 sdvillage(in vec3 p, float seed)\n{\n    \n    vec3 R;\n    float d;\n    vec3 q,q2;\n    vec3 scale=vec3(.5,1.,1.);\n    \n    vec2 dm=vec2(1000.,ID_NONE);\n    \n    for (float i=0.; i<4.; i+=1.)\n    {\n        R=hash3(seed+i)-.5; // dx, dy, ry\n        q=p-vec3(i*3.2-R.x,R.y,-R.x);\n        // rotate\n        q=rY(q,cos(R.z),sin(R.z));\n        \n        d=sdHouse(q, vec3(1.,1.,1.), vec3(2.), -.6, 1.);\n        dm=opU(dm,vec2(d,VILLAGE_MAT));\n        \n        q.y-=1.1;\n        float roof=opS(sdTriPrism((q-vec3(0.,-.1,0.))*scale,vec2(.8,1.4)),\n                       sdTriPrism(q*scale,vec2(.8,1.3)));\n        dm=opU(dm,vec2(roof,STRAW_MAT));\n        \n        // second story\n        if (hash(seed+i)>0.3)\n        {\n            q2=q-vec3(0.,1.,0.);\n            d=sdHouse(q2, vec3(1.,2.,1.), vec3(2.), -.6, 1.);\n            dm=opU(dm,vec2(d,VILLAGE_MAT));\n            q2.y-=1.1;\n            float roof=opS(sdTriPrism((q2-vec3(0.,-.1,0.))*scale,vec2(.8,1.4)),\n                           sdTriPrism(q2*scale,vec2(.8,1.3)));\n            dm=opU(dm,vec2(roof,STRAW_MAT));\n        }    \n    }\n    \n    return dm;\n}\n\n// signed distance function for village\nfloat sdBoardWalk(in vec3 p, in vec2 s)\n{\n    // s = width, half length\n    float d= udRoundBox(p,vec3(s.x,0.03,s.y/2.),0.03);\n    float rx, dx, dz;\n    float l; vec3 q;\n    float k=0.;\n    for (float i=-2.; i<2.; i+=1.)\n    {\n        dz=i*s.y/4.+s.y/8.;\n        for (float j=0.; j<2.; j+=1.)\n        {\n            if (hash(k)>.05)\n            {\n               dx=(2.*j-1.)*s.x+.04;\n                q=p-vec3(dx,0.,dz);\n                rx=(Hash2d(vec2(i,j))-.5)*.4;\n                q=rX(q,cos(rx),sin(rx));\n                d=min(d,sdCappedCylinder(q,vec2(.01,.7)));\n            }\n        }\n        k+=1.;\n    }\n    \n    return d;\n}\n\n\nvec2 sddocks(in vec3 p)\n{   \n    vec2 s=vec2(.5,2.); // .5 wide, 4. long\n    float d=10000.;\n    float t, ry;\n    for (float i=0.; i<3.; i+=1.)\n    {\n        t=hash(i);\n        ry=(t-.5)*.8;\n        d=min(d,sdBoardWalk(rY(p-vec3(0.,0.,i*1.5),cos(ry),sin(ry)),vec2(.5,1.7+.1*t)));\n    }\n\treturn vec2(d,WOOD_MAT);\n}\n\nvec2 sdboat(in vec3 p) // sanpan-style boat.\n{\n    // wood stuff\n    // hull\n    vec3 q=rZ(p,cos(.03),sin(.03));\n    float d=sdTriPrism((q-vec3(0.,-1.2,0.))*vec3(1.,-1.,1.),vec2(3.,.5)); // size, z-thickness\n    \n    vec2 offset=vec2(0.2,14.6);\n    float cylinder= length(q.xy-offset)-14.5;\n    d=opS(cylinder,d);\n    \n    float inner=udRoundBox(q-vec3(0.,0.3,0.),vec3(2.4,.2,.4),.03);\n    d=opS(inner,d);\n    \n    // dude\n   q=p-vec3(1.8,0.,0.2);\n   float dude=sdSphere(q-vec3(0.,1.04,0.),.15); \n   float torso=udRoundBox(q-vec3(0.,0.6,0.),vec3(.07,.2,.12),.05);\n   dude=smin(dude,torso,.1);\n   float legs=sdCappedCylinder(q-vec3(0.,0.,.08), vec2(.06,.5));\nlegs=min(sdCappedCylinder(q-vec3(0.,0.,-.08), vec2(.06,.5)),legs);    \n   dude=smin(legs,dude,.2);\n   \n    // arms and pole\n   float pole=sdCappedCylinder(rZ(q-vec3(1.2,0.,0.16),cos(-1.),sin(-1.)),vec2(.02,2.4));\n   d=min(min(d,dude),pole);\n   \n   vec2 wood=vec2(d,WOOD_MAT);\n    \n    // straw stuff\n    // roof\n   vec3 q1=p-vec3(-0.5,0.,0.);\n   \n   float roof=opS(\n   \tsdCappedCylinder(q1.yxz,vec2(.48,.9)),\n   \tsdCappedCylinder(q1.yxz,vec2(.5,.8 ))\n   );\n   q1.x-=0.6;\t\n   q1=rZ(q1,cos(.05),sin(.05));\n   float roof1=opS(sdCappedCylinder(q1.yxz,vec2(.51,.6)),\n                   sdCappedCylinder(q1.yxz, vec2(.54,.5)));\n   roof1=opS(udRoundBox(q1-vec3(0.,-.85,0.),vec3(1.),0.01),roof1);\n   roof=min(roof,roof1);\n    \n   // hat\n   vec3 q2=rX(q-vec3(0.,1.25,0.), cos(.1), sin(.1));\n   float hat=sdCappedCone(q2,vec3(.2,.4,.18));\n    \n    vec2 straw=vec2(min(hat,roof),STRAW_MAT);\n    return opU(wood,straw);\n}\n\n#define BOAT_SPEED .5\n#define START_POS vec3(3.,0.,1.4)\nvec2 scene(in vec3 p)\n{\n    // TMP\n    //return vec2(10000.,ID_NONE);\n    \n    // houses\n\tvec2 v1= sdvillage(rY(p-vec3(-2.,1.,20.),cos(-2.),sin(-2.)),0.);\n    vec2 v2= sdvillage(rY(p-vec3(16.,.5,25.),cos(2.),sin(2.)),221.);\n    \n    // docks\n    float ry=1.2;\n    vec3 q1=rY(p-vec3(-1.4,0.3,7.),cos(ry),sin(ry));\n  \tvec2 docks=sddocks(q1);\n    \n    // boat\n    ry=-1.7+sin(iTime)*.01;\n    \n    vec3 q2=rY(p-START_POS,cos(ry),sin(ry))-vec3(-mod(iTime*BOAT_SPEED+8.,50.),0.,0.);\n \tvec2 boat= sdboat(q2);\n  \n    vec2 tm=opU(docks,opU(v1,v2)); \n    return opU(tm,boat);\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    vec3 e = vec3( 0.001, 0.0, 0.0 );\n    vec3 n = vec3(\n        scene(p+e.xyy).x - scene(p-e.xyy).x,\n        scene(p+e.yxy).x - scene(p-e.yxy).x,\n        scene(p+e.yyx).x - scene(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec3 background(in vec3 rd)\n{\n    vec3 col;\n    \n    // skycol fades into horizoncol closer to horizon\n    vec3 skyCol = vec3(.454, .298, .261);\n    vec3 horizonCol = vec3(0.866667, 0.47451, 0.270588);\n    col=skyCol;\n    col=mix(horizonCol,skyCol,clamp01(rd.y)*7.);\n    \n    // sunlight\n    vec3 sun_dir=normalize(vec3(0.18,0.1,1.));\n    float sunlight=clamp01(pow(dot(rd,sun_dir),4.));\n    \n    // add sun\n    //float sundot = smoothstep(.996,.999,sunlight);\n    float sundot=1.-smoothstep(0.03,0.06,length(rd-sun_dir));\n    col+=sundot*vec3(1.0,0.913725,0.458824);\n    //col+=sunlight*vec3(1.0,0.913725,0.458824)*.3;\n\n    // clouds\n    vec3 cloudcol=vec3( 0.623529,  0.298039,  0.164706)*1.5;\n\n    //return cloudcol*sunlight;\n    //col=vec3(clouds(rd));\n    col=mix(col,cloudcol*sunlight,clouds(rd));\n    \n    return clamp01(col);  \n}\n\n\n// FBM loop is inlined via macro\n#define F (texture(iChannel0,p*s/1e3)/(s+=s)).x\n\nfloat fbm(in vec2 p, in float s)\n{\n  return F+F+F;\n}\n\nvec3 raymarchFog(in vec3 ro, in vec3 rd, in vec3 bgc)\n{\n  // TODO\n    return mix(bgc,vec3(1.),.1);\n}\n\nfloat watermap( in vec2 p ) { // -.04,.2 controls water direction\n\treturn fbm((p-iTime*vec2(-.04,.2))*10.,.5);\n}\n\nvec3 shade(vec3 p, float m)\n{\n    vec3 n=calcNormal(p);\n   \tvec3 sun_dir=normalize(vec3(-0.28,2.,1.));\n    //vec3 light_dir=normalize(vec3(-0.1,0.1,1.));\n\t//vec3 light_dir=reflect(sun_dir,n); // key light opposite sun\n    \n    vec3 col;\n\tif (m==WOOD_MAT)\n    {\n        col=vec3(0.152941,0.0627451,0.0392157);\n    }\n    else if (m==STRAW_MAT)\n    {\n        // todo - get p as offset in boat coordinates\n        vec4 t=texture(iChannel1,p.xz/2.);\n        col=t.xyz;\n    }\n    else if (m==VILLAGE_MAT)\n    {\n        col=vec3(0.152941,0.0627451,0.0392157)*.1;\n        // add windows\n        vec3 wcol1=vec3(0.972549, 0.294118, 0.137255);\n        vec3 wcol2=vec3( 1.0,0.709804,0.415686);\n        \n        vec4 t=texture(iChannel1,.2+p.xy*vec2(.15,.05));\n        //return vec3(1.-t.x*t.y);\n        float w1=smoothstep(0.7,.8,1.-t.x); // cooler orange glow\n        float w2=smoothstep(0.8,0.9,1.-t.x); // hotter yellow light\n        //return vec3(w2);\n        // skip phong lighting and go straight to color\n        return mix(col,mix(wcol1,wcol2,w2*w1),pow(w1,.2));\n    }\n    \n    col*=1.1*clamp01( dot( n, sun_dir ) ); // phong lighting   \n    return col;\n}\n\n// render subcall (for water refl). returns object id and color.\n// this does shading calculations.\nint trace(in vec3 ro, in vec3 rd, out vec3 col)\n{\n    int obj=ID_SKY;   \n    col=background(rd); // default color = sky\n    \n    // mountains\n    // exponential jump + binary search refinement is a better choice\n    // but this is easier to read\n    vec3 p; float h; float h2;\n    for (float t=0.; t<100.0; t+=0.1)\n    {\n        p=ro+t*rd;\n        \n        // foreground mountains\n        float vwidth=0.7;// valley width\n        float xscale=abs(rd.x-.2)*2.; // valley centered around sun\n\t\tfloat zscale=abs(p.z)/15.; // river gets wider closer to camera        \n        h=fbm(p.xz*3.,.3)*xscale*zscale-.25;///(p.z*.1);\n        \n        // background karst mountains\n        float yscale=p.z/20.-.7; // only show up in background\n        vec4 tex=texture(iChannel2,p.xz/100.);\n        h2=((tex.x-.4)*yscale*(xscale+h*.5)-.2)*15.5;\n        //h2=yscale;\n        if (p.y<h)\n      \t{\n            col=vec3(0.180392, 0.0745098, 0.031372)*2.*(1.-sqrt(h));\n            obj=ID_MOUNTAIN;\n           break;\n        } else if (p.y < h2) {\n            col=mix(vec3(0.180392, 0.0745098, 0.031372)*.5,vec3(0.72549,  0.392157,  0.231373)*.8,t/300.);\n            obj=ID_MOUNTAIN;\n            break;\n        } else if (p.y<0.){\n            obj=ID_NONE;\n        }\n    }\n    \n    // trace village\n    float t=0.1;\n    vec2 dm;\n    vec3 p2;\n    for (int i=0; i<40; i++)\n    {\n        p2=ro+rd*t;\n        dm=scene(p2);\n        if (dm.x<0.01 || t>500.) break;\n        t+=dm.x;\n    }\n   \tif (t<1000. && t<length(p-ro))\n    {\n        col=shade(p2,dm.y);\n    \tobj=ID_VILLAGE;\n    }\n    \n    // is water\n    if (p.y<0. && p2.y<0.){obj=ID_NONE;}\n    \n\treturn obj;\n}\n\n#define BUMP 0.1\n// dx,dz control turbulence of normal displacement for reflection\n#define dx vec2(.1,0.)\n#define dz vec2(0.,.1)\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 p; float d;\n\t// default color is black\n    vec3 col=vec3(0.);\n    \n  \t// intersect foreground\n    int obj=trace(ro,rd,col);\n    \n    if (obj==ID_NONE) // we must have hit water == ID_NONE\n    {   \n        //return vec3(1.);\n        d=dPlane(ro,rd);\n        float fresnel;// bool refl;\n        p=ro+d*rd;\n        vec3 n=normalize(vec3(\n            -BUMP*(watermap(p.xz+dx)-watermap(p.xz-dx))/(2.*BUMP), // second-order finite difference approx\n            1.,\n            -BUMP*(watermap(p.xz+dz)-watermap(p.xz-dz))/(2.*BUMP)\n        ));\n        fresnel = pow(1.0-abs(dot(n,rd)),5.);\n        rd = reflect( rd, n);\n        ro=p;\n        trace(ro,rd,col);    \n        vec3 watercol=vec3( 0.439216  ,0.270588 , 0.203922);\n        col=mix(col,watercol,1.-fresnel);\n    }\n    \n    // TODO - add fog contribution\n    // col=raymarchFog(ro,rd,col);\n    \n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // p.y (-1,1) p.x (-1.5, 1.5)\n    vec2  p = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n    \n    vec3 ro=vec3(0.,1.5,0.); // eye location\n    vec3 ta=vec3(0.,3.,20.); // look location\n    vec3 up = vec3( 0.0, 1.0, 0.0 ); // up axis of world\n    float d = 2.5; // distance between eye and focal plane\n    \n    // build ray\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross( up, ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + d*ww );\n    \n    vec3 col=render(ro,rd);\n    \n    // vignette\n    vec2 q = fragCoord.xy/iResolution.xy;\n    col *= 0.5 + 0.5*pow(20.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.4);\n\n    fragColor=vec4(col,1.);   \n}\n","name":"","description":"","type":"image"}]}