{"ver":"0.1","info":{"id":"tlBGDV","date":"1561129234","viewed":422,"name":"Neat pixel ops","username":"Atheuz","description":"Apply some binary operation to the x and y positions, then sum the digits of the result and draw that color at that x,y position.\n\nPress W or S to add/subtract from the f variable used in the code.\n\nInteresting views (line 333-351)\nxor\nand\nmul\nor\n","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["pixelops"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Thanks to tpfto\n//https://www.shadertoy.com/view/wtSGzh\n\n#define C(c) U.x-=.5; fragColor+= char(U,64+c)\n\nint int_to_char(int i) {\n    if (i == 0) {\n    \treturn -16;\n    }\n    if (i == 1) {\n    \treturn -15;\n    }\n    if (i == 2) {\n    \treturn -14;\n    }\n    if (i == 3) {\n    \treturn -13;\n    }\n    if (i == 4) {\n    \treturn -12;\n    }\n    if (i == 5) {\n    \treturn -11;\n    }\n    if (i == 6) {\n    \treturn -10;\n    }\n    if (i == 7) {\n    \treturn -9;\n    }\n    if (i == 8) {\n    \treturn -8;\n    }\n    if (i == 9) {\n    \treturn -7;\n    }\n}\n\nint get_nth_digit(int x, int n) {\n\treturn x / int(pow(10., float(n-1))) % 10;\n\n}\n\nint get_significant_digits(int x) {\n\tint digits = 0;\n    \n    while (x > 0) {\n        x /= 10;\n        digits += 1;\n    }\n    \n    return digits;\n}\n\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\nbool state(int frame, int n) {\n\tint x = frame / n;\n    return x % 2 == 0;\n}\n\nint sumDigits(int num)\n{\n \tint sum = 0;\n    \n    while (num > 0) {\n        sum += (num % 10);\n        num /= 10;\n    }\n    \n    return sum;\n}\n\nint vortexSum(int num)\n{\n\tint sum = 0;\n    \n    while (true) \n    {\n        sum = 0;\n    \twhile (num > 0) {\n            sum += (num % 10);\n            num /= 10;\n        }\n        if (sum >= 0 && sum <= 9) {\n            break;\n        }\n        num = sum;\n    }\n\treturn sum;\n}\n\nvec4 CountToColor(int count)\n{\n    vec4 startColor = vec4(0.0, 0.0, 1, 1);\n    vec4 perCountDelta = vec4(0.0, 0.025, -0.075, 0.0);\n    \n    return startColor + perCountDelta * float(count);\n}\n\nvec4 CountToColorf(float count)\n{\n    vec4 startColor = vec4(0.0, 0.0, 1, 1);\n    vec4 perCountDelta = vec4(0.0, 0.025, -0.075, 0.0);\n    \n    return startColor + perCountDelta * count;\n}\n\nint xIdentity(int x, int y){\n\treturn x;\n}\nint yIdentity(int x, int y){\n\treturn y;\n}\nint mul(int x, int y){\n\treturn x*y;\n}\nint nmul(int x, int y){\n\treturn ~(x*y);\n}\nint add(int x, int y){\n\treturn x+y;\n}\nint nadd(int x, int y){\n\treturn ~(x+y);\n}\nint sub(int x, int y){\n\treturn x-y;\n}\nint nsub(int x, int y){\n\treturn ~(x-y);\n}\nint divide(int x, int y){\n\treturn x/y;\n}\nint ndivide(int x, int y){\n\treturn ~(x/y);\n}\nint and(int x, int y){\n\treturn (x&y);\n}\nint nand(int x, int y){\n\treturn ~(x&y);\n}\nint or(int x, int y){\n\treturn (x|y);\n}\nint nor(int x, int y){\n\treturn ~(x|y);\n}\nint xor(int x, int y){\n\treturn (x^y);\n}\nint powxy(int x, int y){\n\treturn int(pow(float(x),float(y)));\n}\nint nth_root(int x, int y, int n){\n\treturn int(exp(log(float(n))/(float(x)*float(y))));\n}\nint xnor(int x, int y){\n\treturn ~(x^y);\n}\nint squared_xy(int x, int y){\n    int result = x;\n    for (int i=0; i < y; i++) {\n    \tresult *= x;\n    }\n\treturn result;\n}\nint squared_add(int x, int y){\n\treturn (x*x + y*y);\n}\nint nsquared_add(int x, int y){\n\treturn ~(x*x + y*y);\n}\nint squared_mul(int x, int y){\n\treturn (x*x) * (y*y);\n}\nint nsquared_mul(int x, int y){\n\treturn ~((x*x) * (y*y));\n}\nint squared_sub(int x, int y){\n\treturn (x*x - y*y);\n}\nint nsquared_sub(int x, int y){\n\treturn ~(x*x - y*y);\n}\nint sqrt_add(int x, int y){\n\treturn int(sqrt(float(x) + float(y)));\n}\nint nsqrt_add(int x, int y){\n\treturn ~int(sqrt(float(x) + float(y)));\n}\nint sqrt_sub(int x, int y){\n\treturn int(sqrt(float(x) - float(y)));\n}\nint nsqrt_sub(int x, int y){\n\treturn ~int(sqrt(float(x) - float(y)));\n}\nint sqrt_mul(int x, int y){\n\treturn int(sqrt(float(x) * float(y)));\n}\nint nsqrt_mul(int x, int y){\n\treturn ~int(sqrt(float(x) * float(y)));\n}\nint sqrt_div(int x, int y){\n\treturn int(sqrt(float(x) / float(y)));\n}\nint nsqrt_div(int x, int y){\n\treturn ~int(sqrt(float(x) / float(y)));\n}\nint mod1(int x, int y) {\n\treturn int(x % y);\n}\nint gcd(int a, int b){\n    int temp;\n    while (b != 0)\n    {\n        temp = a % b;\n\n        a = b;\n        b = temp;\n    }\n    return a;\n}\n\nint coprime(int a, int b){\n\tint result = gcd(a,b);\n    if (result == 1) {\n    \treturn 1;\n    }\n    else {\n    \treturn 255;\n    }\n}\nbool check_prime(int a)\n{\n   int c;\n \n   for ( c = 2 ; c <= a - 1 ; c++ )\n   { \n      if ( a%c == 0 )\n     return false;\n   }\n   return true;\n}\nint oneofprime(int a, int b){\n    bool a_check = check_prime(a);\n    bool b_check = check_prime(b);\n    if (a_check == true && b_check == false) {\n    \treturn 10;\n    }\n    if (b_check == true && a_check == false) {\n    \treturn 20;\n    }\n    if (a_check || b_check) {\n    \treturn 30;\n    }\n    if (a_check == false && b_check == false) {\n    return 100;\n       }\n}\n\nvec4 load(in vec2 fragCoordRead)\n{\n    return texture(iChannel0, (0.5 + fragCoordRead) / iChannelResolution[0].xy, -100.0 );\n}\n\nvoid renderCoords(out vec4 fragColor, in vec2 fragCoord) {\n\n\t\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    float pi = 3.1415926;\n    //int f = iFrame;\n    int resX = int(iResolution.x / 2.0);\n    int resY = int(iResolution.y / 2.0);\n    int x = int(fragCoord.x) - resX;\n    int y = int(fragCoord.y) - resY;\n    //int f = int(iMouse.x);\n    vec4 loadedState = load(fragCoord);\n    int f = int(loadedState.y - loadedState.x);\n    int right = int(loadedState.x);\n    int left = int(loadedState.y);\n    int down = int(loadedState.z);\n    int up = int(loadedState.w);\n    int my = int(iMouse.y);\n    int updown = (up-down);\n    int downup = (down-up);\n    int leftright = (left-right);\n    int rightleft = (right-left);\n    \n    // xIdentity\n    // yIdentity\n    // mul\n    // nmul\n    // add\n    // nadd\n    // sub\n    // nsub\n    // divide\n    // ndivide\n    // and\n    // nand\n    // or\n    // nor\n    // xor\n    // powxy\n    // nth_root\n    // xnor\n    // squared_xy\n    // squared_add\n    // nsquared_add\n    // squared_mul\n    // nsquared_mul\n    // squared_sub\n    // nsquared_sub\n    // sqrt_add\n    // nsqrt_add\n    // sqrt_sub\n    // nsqrt_sub\n    // sqrt_mul\n    // nsqrt_mul\n    // sqrt_div\n    // nsqrt_div\n    // gcd\n    // coprime\n    // oneofprime\n    \n    // *only* Static:\n    //int pixelProduct = mul(x,y);\n    //int pixelProduct = mul(y+rightleft, \tx+updown);\n    \n    // *only* Evolves:\n    int pixelProduct = mul(x,y) + rightleft;\n    //int pixelProduct = mul(x,y) * rightleft;\n    \n    // *only* Zooms:\n    //int pixelProduct = squared_add(x * updown,y * rightleft);\n    //int pixelProduct = squared_add(x * rightleft,y * rightleft) + rightleft;\n    //int pixelProduct = mul(x * updown,y * leftright);\n    \n    // *mixes* Moves & Evolves:\n    //int pixelProduct = squared_add(x + rightleft,y + rightleft) + rightleft;\n    //int pixelProduct = squared_add(x + rightleft,y + rightleft) * rightleft;\n    \n    // *mixes* Evolves & Zooms:\n    //int pixelProduct = mul(x * rightleft,y * rightleft) * rightleft;\n    \n    // ???:\n\t//float pixelProduct = float(gcd(x + updown,y + leftright)) * pi*2.;\n    \n    int count = 0;\n    //if (state(iFrame, 20)) {\n    //\tcount = sumDigits(pixelProduct); // vortexSum\n    //}\n    //else {\n    \tcount = sumDigits(pixelProduct);\n    //}\n    //count = pixelProduct;\n    \n    // Output to screen\n    //fragColor = CountToColor(pixelProduct);\n    //fragColor = CountToColor(count);\n    \n    // Add text for leftright, updown, f\n    fragColor = vec4(0.0);\n    fragCoord /= iResolution.y;\n    vec2 position = vec2(.0,.925);\n    float FontSize = 3.;\n    vec2 U = ( fragCoord - position)*64.0/FontSize;\n    \n    // Draw leftright\n    if (leftright < 0) {\n    \tC(-19); // Minus sign -\n    } else if (leftright > 0) {\n    \tC(-21); // Plus sign +\n    }\n    int sig_digits = get_significant_digits(abs(leftright));\n    while (sig_digits > 0) {\n        C(int_to_char(get_nth_digit(abs(leftright), sig_digits)));\n        sig_digits -= 1;\n    }\n    // Draw updown\n    C(-5); // Semicolon ;\n    if (updown < 0) {\n    \tC(-19); // Minus sign -\n    } else if (updown > 0) {\n    \tC(-21); // Plus sign +\n    }\n    int sig_digits2 = get_significant_digits(abs(updown));\n    while (sig_digits2 > 0) {\n        C(int_to_char(get_nth_digit(abs(updown), sig_digits2)));\n        sig_digits2 -= 1;\n    }\n    // Draw f\n    C(-5); // Semicolon ;\n    if (f < 0) {\n    \tC(-19); // Minus sign -\n    } else if (f > 0) {\n    \tC(-21); // Plus sign +\n    }\n    int sig_digits3 = get_significant_digits(abs(f));\n    while (sig_digits3 > 0) {\n        C(int_to_char(get_nth_digit(abs(f), sig_digits3)));\n        sig_digits3 -= 1;\n    }\n    fragColor = fragColor.xxxx + CountToColor(count);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int Key_W = 87;\nconst int Key_A = 65;\nconst int Key_S = 83;\nconst int Key_D = 68;\n\n\nfloat ReadKeyInternal( int key, bool toggle )\n{\n\treturn textureLod( iChannel1, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ), 0.0 ).x;\n}\n\nfloat ReadKey( int key )\n{\n\treturn ReadKeyInternal(key,false);\n}\n\nfloat ReadKeyToggle( int key )\n{\n\treturn ReadKeyInternal(key,true);\n}\nvoid store( in vec2 fragCoordWrite, in vec4 value, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = value;\n}\nvec4 load(in vec2 fragCoordRead)\n{\n    return texture(iChannel0, (0.5 + fragCoordRead) / iChannelResolution[0].xy, -100.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0.0, 0.0, 0.0, 0.0);\n    // Initialize variables\n    vec4  history = load( fragCoord );\n    if (iFrame == 0)\n    {\n       vec4 history = vec4(0.0);\n    }\n    history.x += ReadKey(Key_W) * 100.;\n    history.y += ReadKey(Key_S) * 100.;\n    history.z += ReadKey(Key_A) * 100.;\n    history.w += ReadKey(Key_D) * 100.;\n    fragColor = history;\n}","name":"Buffer A","description":"","type":"buffer"}]}