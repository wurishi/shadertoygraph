{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"music","id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":3,"type":"texture","id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//use or not object raymarch in raytrace\n#if 0\n\tbool useRaymarch = false;\n\tconst float t = 64.0;\n#else\n\tbool useRaymarch = true;\n\tconst float t = 8.0;\n#endif\n\n#define pi acos(-1.0)\n#define pi2 pi/2.0\n\n//for transparency change, change first number in mref() to -1\nstruct Material\n{\n    vec4 color;\n    vec2 brdf;\n};\n\nstruct Sphere\n{\n\tvec4 center_radius;\n\tint idmaterial;\n};\n\nstruct Box\n{\n    vec3 min, max;\n   int idmaterial;\n};\n    \nstruct Cylinder \n{\n    vec3 c;\n    float r,h;\n    int idmaterial;\n};\n\nBox box0;\nSphere sfere[6];\nBox boxe[4];\nCylinder cylinder[3];\nMaterial material[5];\n\nvec3 light = vec3(0.0, 0.0, 0.0);\nvec3 pq, cub, lcub, nrm, crm;\nvec2 p,rv2;\nvec2 randv2;\nfloat side = 1.0;\nfloat time ;//= iTime;\nfloat f0, f1,f2,f3;\n\n\nvec2 rand2(){// implementation derived from one found at: lumina.sourceforge.net/Tutorials/Noise.html\n   randv2+=vec2(1.0,1.0);\n   return vec2(fract(sin(dot(randv2.xy ,vec2(12.9898,78.233))) * 43758.5453),\n      \t\t   fract(cos(dot(randv2.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec3 CosineWeightedSampleHemisphere ( vec3 normal, vec2 rnd )\n{\n   //rnd = vec2(rand(vec3(12.9898, 78.233, 151.7182), seed),rand(vec3(63.7264, 10.873, 623.6736), seed));\n   float phi = acos( sqrt(1.0 - rnd.x)) ;\n   float theta = 2.0 * 3.14 * rnd.y ;\n\n   vec3 sdir = cross(normal, (abs(normal.x) < 0.5001) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0));\n   vec3 tdir = cross(normal, sdir);\n\n   return normalize(phi * cos(theta) * sdir + phi * sin(theta) * tdir + sqrt(1.0 - rnd.x) * normal);\n}\n\nvec3 cosPowDir(vec3  dir, float power) \n{//creates a biased random sample\n   vec2 r=rand2()*vec2(6.2831853,1.0);\n   vec3 sdir=cross(dir,((abs(dir.x)<0.5)?vec3(1.0,0.0,0.0):vec3(0.0,1.0,0.0)));\n   vec3 tdir=cross(dir,sdir); \n   r.y=pow(r.y,0.01/power);\n   float oneminus = sqrt(1.0-r.y*r.y);\n   return cos(r.x)*oneminus*sdir + sin(r.x)*oneminus*tdir + r.y*dir;\n}\n\n/*vec3 RandomPointOnLight(vec4 sfera)\n{\n   float r3 = rand2().x;\n   float r4 = rand2().y;\n   vec3 C = vec3(2.0 * cos(2.0 * 3.141592 * r3) * sqrt(r4 * (1.0 - r4)),\n                           2.0 * sin(2.0 * 3.141592 * r3) * sqrt(r4 * (1.0 - r4)),\n                           1.0 - 2.0 * r4 );    \n   return (C * sfera.w*1.05 + sfera.xyz );\n}*/\n\nvec2 intersectCube(vec3 origin, vec3 ray, Box cube) {      \n   vec3   tMin = (cube.min - origin) / ray;      \n   vec3   tMax = (cube.max - origin) / ray;      \n   vec3     t1 = min(tMin, tMax);      \n   vec3     t2 = max(tMin, tMax);\n   float tNear = max(max(t1.x, t1.y), t1.z);\n   float  tFar = min(min(t2.x, t2.y), t2.z);\n   return vec2(tNear, tFar);   \n}\n\nvec3 normalForCube(vec3 hit, Box cube)\n{  \n   if(hit.x < cube.min.x + 0.0001) return vec3(-1.0, 0.0, 0.0);   \n   else if(hit.x > cube.max.x - 0.0001) return vec3( 1.0, 0.0, 0.0);   \n   else if(hit.y < cube.min.y + 0.0001) return vec3(0.0, -1.0, 0.0);   \n   else if(hit.y > cube.max.y - 0.0001) return vec3(0.0, 1.0, 0.0);      \n   else if(hit.z < cube.min.z + 0.0001) return vec3(0.0, 0.0, -1.0);   \n   else return vec3(0.0, 0.0, 1.0);   \n}\n\nfloat intersectSphere(vec3 origin, vec3 ray, Sphere s) {   \n   vec3 toSphere = origin - s.center_radius.xyz;      \n   float sphereRadius = s.center_radius.w;\n   float a = dot(ray, ray);      \n   float b = 2.0 * dot(toSphere, ray);   \n   float c = dot(toSphere, toSphere) - sphereRadius*sphereRadius;   \n   float discriminant = b*b - 4.0*a*c;      \n   if(discriminant > 0.0) {      \n      float t = (-b - sqrt(discriminant)) / (2.0 * a);   \n      if(t > 0.0) return t;      \n   }   \n   return 10000.0;   \n}  \n\nvec3 normalForSphere(vec3 hit, Sphere s) {   \n   return (hit - s.center_radius.xyz+pq) / s.center_radius.w;   \n} \n\nfloat iCylinder(vec3 ro, vec3 rd, Cylinder cylinder)\n{\n\tvec3  rc = ro - cylinder.c;\n    float a = dot( rd.xz, rd.xz );\n\tfloat b = dot( rc.xz, rd.xz );\n\tfloat c = dot( rc.xz, rc.xz ) - cylinder.r*cylinder.r;//0.249;\n\tfloat d = b*b - a*c;\n\tif( d>=0.0 )\n\t{\n\t\t// cylinder\t\t\t\n\t\tfloat s = (-b - sqrt( d ))/a;\n        float hy = ro.y+s*rd.y;\n\t\tif( s>0.0 && hy<cylinder.h && hy>-cylinder.h )\n\t\t{\n\t\t\treturn s;\n\t\t}\n\t\t// cap\t\t\t\n\t\ts = (cylinder.h - ro.y)/rd.y;\n\t\tif( s>0.0 && (s*s*a+2.0*s*b+c)<0.0 )\n\t\t{\n\t\t\treturn s;\n\t\t}\n\t}\n    return 100000.0;\n}\n\nvec3 normalforCylinder(vec3 hit,Cylinder cylinder)\n{\n    vec3 nor;\n\tnor.xz = hit.xz - cylinder.c.xz;\n    nor.y = 0.0;\n    nor = nor/cylinder.r;\n    return nor;\n}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n/*vec3 doBump( in vec3 pos, in vec3 nor, in float signal, in float scale )\n{\n    // build frame   \n    vec3  s = dFdx( pos );\n    vec3  t = dFdy( pos );\n    vec3  u = cross( t, nor );\n    vec3  v = cross( nor, s );\n    float d = dot( s, u );\n\n    // compute bump   \n    float bs = dFdx( signal );\n    float bt = dFdy( signal );\n   \n    // offset normal   \n#if 1\n   return normalize( nor - scale*(bs*u + bt*v)/d );\n#else\n    // if you cannot ensure the frame is not null   \n   vec3 vSurfGrad = sign( d ) * ( bs * u + bt * v );\n    return normalize( abs(d)*nor - scale*vSurfGrad );\n#endif\n}*/\n\n//raymarch stuff\nfloat rmSphere( vec3 p, vec3 c, float r )\n{\n   return length(p-c) - r;\n}\n\nfloat rmCube(vec3 p,vec3 size)\n{\n   return max(max(abs(p.x) - size.x, abs(p.y) - size.y), abs(p.z) - size.z);\n}\n\nfloat CylinderXY( vec3 p, vec3 c ) {\n   return length(p.xy-c.xy)-c.z;\n}\n\nfloat CylinderXZ( vec3 p, vec3 c ) {\n   return length(p.xz-c.xy)-c.z;\n}\n\nfloat CylinderYZ( vec3 p, vec3 c ) {\n   return length(p.yz-c.xy)-c.z;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.yz),p.x)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvoid oprep2(inout vec2 p, float l, float s, float k) \n{\n   float r=1./l;\n   float ofs=s+s/(r*2.0);\n   float a= mod( atan(p.x, p.y) + pi2*r*k, pi*r) -pi2*r;\n   p.xy=vec2(sin(a),cos(a))*length(p.xy) -ofs;\n   p.x+=ofs;\n}\n\nfloat scene(vec3 p)\n{\n   float f = 1000.0;\n   vec3 q = p-crm;\n//-------------------------------------\n   float box = 24.0;\n   oprep2(q.yz, box, 0.042, 0.0);\n\n   int ind = int((atan(p.z,p.y)/pi)*box)*1;//+ box-1;\n   if(ind<0) ind = -ind;\n   float h = texture(iChannel1, vec2( float(ind)/box, 0.3)).x * 0.2;\n   f = rmCube(q, vec3(0.025,0.0250,0.025+h));\n//-----------------------------------------   \n    vec3 tcol = texture(iChannel3, 1.0-(p.zy+1.0)/2.0).rgb;\n    h = tcol.y*0.01;\n    float f1 = CylinderYZ( p-crm, vec3(0.0, 0.0, 0.55) );\n    p.x += h;\n    float f2 = sdCylinder( p-crm, vec2(0.53, 0.01) );\n    \n   f = max(f,-f1);\n   f = min(f,f2);\n   return f;\n}\n\nfloat rmIntersect(vec3 ro, vec3 rd, float maxd)\n{\n   float d = 0.005;\n   side = sign(scene(ro+rd*d));//keep track of which side you are on\n\n   for( int i=0; i<60; i++)\n   {\n      float f = scene (ro + rd * d);\n      if(abs(f) < 0.001)\treturn d;     \n      d += f * side;\n      if(d > maxd) {return 10000.0; }\n   }\n    return d;\n}\n//end raymarch stuff\n\nvoid initscene()\n{\n   //light = vec3(sin(time)*0.0-0.0, +0.1, cos(time)*0.0+0.4);\n\n    sfere[0].center_radius = vec4( 0.0, 0.0+f0, 0.0,    0.323);//rosu\n   \tsfere[1].center_radius = vec4( 0.0, 0.0+f1, 1.0,    0.323);//verde\n   \tsfere[2].center_radius = vec4( 0.0, 0.0+f2,-1.0,    0.323);//albastru\n   \tsfere[3].center_radius = vec4( 0.0, 0.0-f0, 0.0,    0.323);//rosu\n    sfere[4].center_radius = vec4( 0.0, 0.0-f1, 1.0,    0.323);//verde\n    sfere[5].center_radius = vec4( 0.0, 0.0-f2,-1.0,    0.323);//albastru\n    \n    cylinder[0].c = vec3(0.0,0.0,0.0);\n    cylinder[0].r = 0.1;\n    cylinder[0].h = 1.0;\n    \n    cylinder[1].c = vec3(0.0,0.0,1.0);\n    cylinder[1].r = 0.1;\n    cylinder[1].h = 1.0;\n    \n    cylinder[2].c = vec3(0.0,0.0,-1.0);\n    cylinder[2].r = 0.1;\n    cylinder[2].h = 1.0;\n\n   \tbox0.min = vec3(-2.0, -1.0, -2.0);\n   \tbox0.max = vec3( 2.0,  1.0,  2.0);\n\n   \tcub = vec3(-1.8, -0.0,0.0);\n   \tlcub = vec3(0.03, 0.5, 0.81);\n\n   \tboxe[0].min = cub - lcub;\n   \tboxe[0].max = cub + lcub;\n    \n    crm = vec3(1.8, 0.0,0.0); //position of raymarch scene\n    cub = crm;\n   \tlcub = vec3(01.03, 0.8, 0.8);\n\n   \tboxe[1].min = cub - lcub;\n   \tboxe[1].max = cub + lcub;\n    \n    //vec4 mat[7];//vec3 color and float power of emisive\n\tmaterial[0].color = vec4(vec3(0.9 ,0.3 , 0.3), 1.0); //0 - rosu                    \n\tmaterial[1].color = vec4(vec3(0.3 ,0.9 , 0.3), 1.0); //1 - verde\n\tmaterial[2].color = vec4(vec3(0.3 ,0.3 , 0.9), 1.0); //2 - albastru\n\tmaterial[3].color = vec4(vec3(0.9 ,0.9 , 0.9), 0.0); //3 - light\n    material[4].color = vec4(vec3(1.0 ,1.0 , 1.0), 0.0); //3 - light\n\n\t//reflect/refract(-1 <> 1) and difusse refl/refr (0 <> 1)\n\tmaterial[0].brdf = vec2( 0.0 ,0.0 ); //0 - rosu               \n\tmaterial[1].brdf = vec2( 0.0 ,0.0 ); //1 - verde\n\tmaterial[2].brdf = vec2( 0.0 ,0.0 ); //2 - albastru\n\tmaterial[3].brdf = vec2( 0.0 ,0.0 ); //3 - diff\n    material[4].brdf = vec2( 0.0 ,0.0 ); //3 - light\n\n}\n\nvoid intersectscene(vec3 ro, vec3 rd, inout float t, inout int i)\n{\n   //pq = cos(rd*20.0*length(ro-vec3(-0.8,0.1,-0.7))+(ro-vec3(-0.8,0.1,-0.7))*50.+time*10.)*0.02;\n\n   float tSphere0 = intersectSphere(ro, rd, sfere[0]);\n   float tSphere1 = intersectSphere(ro, rd, sfere[1]);\n   float tSphere2 = intersectSphere(ro, rd, sfere[2]);\n   float tSphere3 = intersectSphere(ro, rd, sfere[3]);\n   float tSphere4 = intersectSphere(ro, rd, sfere[4]);\n   float tSphere5 = intersectSphere(ro, rd, sfere[5]);\n\n   if(tSphere0 < t) { t = tSphere0;i=0;}\n   if(tSphere1 < t) { t = tSphere1;i=1;}   \n   if(tSphere2 < t) { t = tSphere2;i=2;}\n   if(tSphere3 < t) { t = tSphere3;i=3;} \n   if(tSphere4 < t) { t = tSphere4;i=4;} \n   if(tSphere5 < t) { t = tSphere5;i=5;} \n\n\tfloat tcyl = iCylinder(ro, rd, cylinder[0]);\n    if(tcyl<t) {t = tcyl; i = 10;}\n    tcyl = iCylinder(ro, rd, cylinder[1]);\n    if(tcyl<t) {t = tcyl; i = 11;}\n    tcyl = iCylinder(ro, rd, cylinder[2]);\n    if(tcyl<t) {t = tcyl; i = 12;}\n    \n   \n    vec2 tbox = intersectCube(ro, rd, boxe[0]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 20;} \n\n  if(useRaymarch)\n  {\n     bool b = boxe[1].min.x <= ro.x && boxe[1].max.x >= ro.x &&\n              boxe[1].min.y <= ro.y && boxe[1].max.y >= ro.y &&\n              boxe[1].min.z <= ro.z && boxe[1].max.z >= ro.z;\n      tbox = vec2(0.0);\n      \n    if(!b)\n    {\n    \ttbox = intersectCube(ro, rd, boxe[1]); \n        if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) b = true;\n    }\n    //if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t || b)\n    if(b)\n    {\n        tbox.x = 0.0;\n        float rm = rmIntersect(ro+rd*tbox.x, rd, tbox.y);\n        if(rm < t)\n        {\n            t = rm; i = 30; float e = 0.0001;\n            ro = ro + rd * t;\n            nrm = vec3(scene(ro + vec3(e, 0.0, 0.0)) - scene(ro - vec3(e, 0.0, 0.0)), \n                       scene(ro + vec3(0.0, e, 0.0)) - scene(ro - vec3(0.0, e, 0.0)), \n                       scene(ro + vec3(0.0, 0.0, e)) - scene(ro - vec3(0.0, 0.0, e)));\n            nrm = side * normalize(nrm);\n        }\n    } \n  }\n}\n\nfloat distanceToSegment( vec2 a, vec2 b, vec2 p )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn length( pa - ba*h );\n}\n\nvoid ColorAndNormal(vec3 hit, inout vec4 mcol, inout vec3 normal, vec2 tRoom, inout vec2 mref, inout float t, const int id)\n{\n\tif(t == tRoom.y)\n\t{            \n        mref = vec2(0.0,0.0);\n        normal =-normalForCube(hit, box0);   \n        //if(hit.x < box0.min.x+0.001) \n           // mcol = vec4(0.9, 0.9, 0.9, 0.0);   \n       // else\n        if(hit.x > box0.max.x-0.001 ) \n        {\n            float cc = -0.3;\n            mcol = vec4(0.9, 0.9, 0.9, 0.0);\n            float d1 = distanceToSegment( vec2(0.22,0.00+cc), vec2(-0.22,0.00+cc), hit.yz );//T\n            float d2 = distanceToSegment( vec2(0.22,0.12+cc), vec2(0.22,-0.12+cc), hit.yz );\n            \n            float d3 = distanceToSegment( vec2(0.05,0.25+cc), vec2(-0.22,0.25+cc), hit.yz );//i\n            float d4 = distanceToSegment( vec2(0.22,0.25+cc), vec2( 0.22,0.25+cc), hit.yz );\n            \n            float d5 = distanceToSegment( vec2(0.22,0.50+cc), vec2(-0.22,0.50+cc), hit.yz );//t\n            float d6 = distanceToSegment( vec2(0.12,0.58+cc), vec2( 0.12,0.42+cc), hit.yz );\n            \n            float d7 = distanceToSegment( vec2(0.05,0.75+cc), vec2(-0.22,0.75+cc), hit.yz );//i\n            float d8 = distanceToSegment( vec2(0.22,0.75+cc), vec2( 0.22,0.75+cc), hit.yz );\n            \n            float d = min(d1,min(d2,min(d3,d4)));//Ti\n                  d = min(d,min(d5,min(d6,min(d7,d8))));//ti\n            d = clamp(d, 0.0, 1.0);\n\t\t\tmcol.w = smoothstep( 0.24, 0.97,1.0- d*10.5 )*1.0;\n        }\n           // mcol = vec4(0.9, 0.9, 0.9, 0.0);//mcol = vec4(texture(iChannel0, 1.0-(hit.zy+1.5)/3.0).rgb, 0.0);    \n        if(hit.z > box0.max.z-0.001)    \n            mcol = vec4(0.2, 0.7, 0.2, 0.0);\n        else if(hit.z < box0.min.z+0.001)    \n           mcol = vec4(0.2, 0.2, 0.7, 0.0);//vec4(texture(iChannel0, 1.-(hit.xy+1.5)/3.0).rgb,0.0);  \n        else if(hit.y<box0.min.y+0.001)  //floor \n        {\n            vec3 tcol = texture(iChannel2, 1.0-(hit.xz-1.5)/3.0).rgb;\n            float rf = clamp(1.0-tcol.z*14.0, 0.0,1.0);\n            rf = mix(0.01,70.0,rf+0.003);\n            mref = vec2(1.0,rf);\n            normal.xz = normal.xz + (tcol.xz*2.0-1.0)*0.1;\n            //normal.yz = normal.yz + (tcol.yz)*0.55;\n            normal = normalize(normal);\n            mcol.xyz = mix(vec3(1.0),tcol,0.5);;\n        } \n\t\telse if(hit.y > box0.max.y-0.001)//ceiling\n        {\n            mcol.xyz = vec3(0.3,0.3,0.3); mref= vec2(0.0,0.0);\n            float gr = 1.95; float rost = 0.04;\n            float v0 = dot(vec3(0, gr, gr),hit);\n            float v1 = dot(vec3(gr, gr, 0),hit);\n            v0 -= floor(v0);\n            v1 -= floor(v1);\n            if(v0>rost && v1> rost)  {mcol.xyz = vec3(0.99,0.99,0.99); mref = vec2(1.0,0.01);}\n        } \n\t}     \n\telse   \n\t{\n\t\t     if(id==0) {normal = normalForSphere(hit, sfere[0]); mcol = material[0].color;mref = material[0].brdf;}\n        else if(id==1) {normal = normalForSphere(hit, sfere[1]); mcol = material[1].color;mref = material[1].brdf;}\n        else if(id==2) {normal = normalForSphere(hit, sfere[2]); mcol = material[2].color;mref = material[2].brdf;}\n        else if(id==3) {normal = normalForSphere(hit, sfere[3]); mcol = material[0].color;mref = material[0].brdf;}\n    \telse if(id==4) {normal = normalForSphere(hit, sfere[4]); mcol = material[1].color;mref = material[1].brdf;}\n        else if(id==5) {normal = normalForSphere(hit, sfere[5]); mcol = material[2].color;mref = material[2].brdf;}\n    \telse if(id==10) {normal = normalforCylinder(hit, cylinder[0]); mcol = material[3].color;mref = material[3].brdf;}\n        else if(id==11) {normal = normalforCylinder(hit, cylinder[1]); mcol = material[3].color;mref = material[3].brdf;}\n        else if(id==12) {normal = normalforCylinder(hit, cylinder[2]); mcol = material[3].color;mref = material[3].brdf;}\n\t\telse if(id==20) {normal = normalForCube(hit, boxe[0]); mcol = material[4].color;mref = material[4].brdf;}\n//box on wall      \n        if(id==20 /*&& hit.x > boxe[0].max.x-0.001*/)\n        {\n            //dont work bunp :(((\n            //vec3 mate = texcube( iChannel0, 0.25*hit, normal ).xyz;\n            //normal = doBump( hit, normal, dot(mate,vec3(0.2)), 0.01*1.9 );\n            vec3 tcol = texture(iChannel0, 1.0-(hit.zy-vec2(sin(time*0.0),1.5))/2.0).rgb;\n            float rf = clamp(1.0-tcol.y*1.9,0.0,1.0);;\n            rf = (rf+0.1)*4.0;\n            mref = vec2( 1.0, rf);\n            normal.yz = normal.yz + (tcol.yz*2.0-1.0)*0.3;\n            normal = normalize(normal);\n            //mcol.xyz = tcol; \n        }\n        \n        if(id==30)//raymarch object\n        {\n            normal = nrm;\n            vec3 tcol = texture(iChannel3, 1.0-(hit.zy+1.0)/2.0).rgb;\n            float rf = clamp(1.0-tcol.y*3.0,0.0,1.0);\n            rf = mix(0.1,10.0,rf+0.01);\n            mref = vec2( 1.0, rf);\n            mcol.xyz = mix(vec3(1.0),tcol,0.0);\n        }\n    }  \n}\n\nvec3 getColor(vec3 ro, vec3 rd)\n{\n    vec3 color = vec3(0.0);\n    vec3 col = vec3(1.0);\n    int id=-1;\n    \n    for(int i=0; i<6; i++)\n    {\n    \tfloat t = 10000.0; //seed++;\n\n   \t\tvec2 tRoom = intersectCube(ro, rd, box0);          \n   \t\tif(tRoom.x < tRoom.y)   t = tRoom.y; \n   \t\t//else return col;\n    \n    \tintersectscene(ro, rd, t, id);\n    \n    \tvec3 hit = ro + rd * t;        \n\t\tvec4 mcol = vec4(vec3(0.9),0.0);                 \n    \tvec3 normal; \n    \tvec2 mref = vec2(0);\n      \n    \tColorAndNormal(hit, mcol, normal, tRoom, mref, t, id);\n    \thit = hit - normal * 0.0001;\n        vec3 nl = dot(rd,normal)>0.0? normal : -normal;\n         \n        col *= mcol.xyz*1.0;\n        if(mcol.w>0.0) \n        {\n            float df=max(dot(rd,-normal),0.0)*3.0+0.0;\n            color += col*mcol.xyz*mcol.w *df;\n            break;\n        }\n\n        if(mref.x==0.0)\n        {\n        \trd = CosineWeightedSampleHemisphere ( normal, rand2());      \n        \tfloat rnd = rand2().x;\n        \tvec3 rl;       \n        \trl = sfere[0].center_radius.xyz;\n        \tif(rnd>0.16) rl = sfere[1].center_radius.xyz;\n        \tif(rnd>0.32) rl = sfere[2].center_radius.xyz;\n            if(rnd>0.48) rl = sfere[3].center_radius.xyz;\n            if(rnd>0.64) rl = sfere[4].center_radius.xyz;\n            if(rnd>0.80) rl = sfere[5].center_radius.xyz;\n        \trl = normalize(rl-hit);\n        \tfloat p = 5.0; //if(i==0) p=3.0;\n        \tp = max(0.0,dot(rd,rl))*p;\n        \trd = normalize(rd + rl*p);\n        \n        \tcol *= clamp(dot(normal,rd),0.0,1.0)/pi;\n        }       \n        else if(mref.x>0.0)\n        {\n            rd = reflect(rd,normal); col *= 1.0;\n            vec3 rnd = vec3(rand2(),rand2().x);           \n            //rd = normalize(rd + rnd*mref.y);\n            rd = cosPowDir(rd, mref.y);\n        }\n        else if(mref.x<0.0)\n        {\n            vec3 nrd = reflect(rd,normal); \n            vec3 ior=vec3(1.0,1.52,1.0/1.52);\n            vec3 refr=refract(rd,normal,(side>=0.0)?ior.z:ior.y);//calc the probabilty of reflecting instead\n            vec2 ca=vec2(dot(normal,rd),dot(normal,refr)),n=(side>=0.0)?ior.xy:ior.yx,nn=vec2(n.x,-n.y);\n            if(rand2().y>0.5*(pow(dot(nn,ca)/dot(n,ca),2.0)+pow(dot(nn,ca.yx)/dot(n,ca.yx),2.0)))\n               nrd=refr;\n            \n            rd = nrd;\n\n            col *= 1.2;\n        }\n        \n        ro = hit + rd * 0.0001; //seed++;\n        \n        if(dot(col,col)<0.002) break;\n    }\n    \n    \t//color = mcol.xyz;\n \treturn color;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n    float seed = iTime + iResolution.y *(p.x+1.0) + p.y;\n\t\n\trandv2=fract(cos((fragCoord.xy+fragCoord.yx*vec2(1000.0,1000.0))+vec2(iTime))*10000.0);\n\t\n    //move camera with mouse\n\tvec3 ro = vec3( 0.0+3.0*cos(8.0*mo.x), -0.3 + 1.5*(mo.y), 0.0 + 3.0*sin(8.0*mo.x) );\n\tvec3 ta = vec3( 0.0, 0.0, 0.0 );\n\t\n    //camera path\n    time = 0.2 * iTime;;\n    vec3 path = vec3(sin(time)*0.7 + 0.0, 0.4, cos(time)*1.9 + 0.0);    \n    ro = path; ta = path + vec3(cos(time*0.5)*1.5+0.0, -0.1, sin(time*0.0)+0.1);\n    \n    //view of raymarch\n    //ro = vec3(0.1,0.0,0.0); ta = vec3(1.0,0.0,0.0);\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n    \n    f0 = texture( iChannel1, vec2( 0.01, 0.0 ) ).x;\n    f1 = texture( iChannel1, vec2( 0.56, 0.0 ) ).x;\n    f2 = texture( iChannel1, vec2( 0.96, 0.0 ) ).x;\n    \n    f0 = pow(f0*1.0,5.0);\n    \n    initscene();\n\t\n\tvec3 col = vec3(0.0);\n\n    for(float i=0.0; i<t; i++)\n    {\n        p += (rand2() * 2.0 - 1.0) * 0.5 / iResolution.x;\n        rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n    \tcol += getColor( ro, rd );\n    }\n\n    col = pow( clamp( col/t, 0.0, 1.0 ), vec3(0.75) );\n    //col.g += tc;\n    fragColor=vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4s2XR1","date":"1409242136","viewed":777,"name":"Light & Music","username":"predatiti","description":"test light, music & minimal path tracing","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"","parentname":""}}