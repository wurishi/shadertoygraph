{"ver":"0.1","info":{"id":"Ml2cDd","date":"1510685018","viewed":533,"name":"Antialiasing Demo","username":"olano","description":"Demo of aliasing and different antialiasing kernels.\n  Left = horribly aliased one sample per pixel.\n  Right = 256 samples per pixel, quasi-random distribution, Lanczos weights\nEdit constants at top of shader to explore different antialiasing strategies","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["aliasing","filtering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Aliasing and antialiasing demo\n// infinitely scrolling checkerboard\n// change parameters below to adjust kernel, jitter, sample pattern, etc.\n\n// worst: samples=1, DIST=GRID, FILT=BOX\n// good: samples=8, DIST=JITTER, FILT=GAUSS_SAMP\n\n// sample distribution, options for dist[]\n#define GRID 0\t\t\t/* uniform grid */\n#define JITTER 1\t\t/* random jitter */\n\n// filter kernel, options for filt[]\n#define BOX 0\t\t\t\t/* Equal-weight spatial box filter */\n#define LANCZOS 1\t\t\t/* Lanczos filter of order given by lanczosOrder */\n#define LANCZOS_RADIAL 2\t/* Radially symmetric Lanczos filter */\n#define GAUSSIAN 3\t\t\t/* Gaussian weights */\n#define GAUSS_SAMP 4\t\t/* Gaussian-distributed importance samples */\n\n// sampling parameters\nstruct Parameters {\n    int samples;\t// samples * samples per pixel\n    int dist;\t\t// sample distribution\n    int filt;\t\t// filter kernel\n    int order;\t\t// Lanczos order (for Lanczos) integer >= 1\n};\n    \n\n///////////////////////////////////////////////////////////////////////\n// begin changable parameters\n\n// scrolling speed\nconst float speed = 0.1;\n\n// number of options to compare\nconst int splits = 2;\n\n// Parameters(samples, sample distribution, filter kernel, Lanzos order)\nconst Parameters param[splits] = Parameters[splits](\n    Parameters(1, GRID, BOX, 1),\n    Parameters(8, JITTER, GAUSS_SAMP, 2)\n    );\n\n// end of parameters\n///////////////////////////////////////////////////////////////////////\n\n// Epic PCG3D generator\nuvec3 PCG3D(uvec3 v) {\n    v = 1664525u * v + 1013904223u;\n    v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n    v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n    return v>>16u;\n}\n\n// jitter for sample i,j\nvec2 jitter(int dist, int i, int j) {\n    // random jitter within cell\n    if (dist == JITTER)\n    \treturn vec2(PCG3D(uvec3(gl_FragCoord.xy,0)).xy)/float(0xffff);\n    \n    // no jitter\n    return vec2(0.5);\n}\n\n// compute new location for importance sampling\nvec2 distribution(int filt, vec2 offset) {\n    if (filt == GAUSS_SAMP) {\n        // Box-Mueller transform to get Gaussian-distributed sample locations\n        // assumes components of offset are distributed between -1 and 1\n        float radius = sqrt(-2.0 * log(offset.x*.5 + .5));\n        float theta = 3.14159265359 * offset.y;\n        return vec2(radius * cos(theta), radius * sin(theta));\n    }\n\n    // all others use weights\n    return offset;\n}\n\n// Lanczos kernel of order a\nfloat lanczos(float x, float a) {\n    // basic Lanczos function: sinc(x) * sinc(x/a)\n    float f = a * sin(x) * sin(x/a) / (x*x);\n\n    if (abs(x)>a) f = 0.0;        // Lanczos is 0 for x past window\n    if (f != f) f = 1.0;          // NaN for x=0, in the limit = 1\n    return f;\n}\n\n// filter weight\nfloat weight(int filt, vec2 offset, float order) {\n    // Gaussian with standard deviation width/2:\n    if (filt == GAUSSIAN)\n        return exp(-2. * dot(offset,offset));\n\n    if (filt == LANCZOS)\n   \t\treturn lanczos(offset.x, order)*lanczos(offset.y, order);\n\n    if (filt == LANCZOS_RADIAL)\n    \treturn lanczos(length(offset), order);\n\n    // equal-weight for box filter or Gaussian importance sampling\n    return 1.0;\n}\n\n// filter width in pixels\nfloat filterWidth(int filt, float order) {\n    if (filt == GAUSSIAN)\n    \treturn 1.66;\n\n    if (filt == LANCZOS || filt == LANCZOS_RADIAL)\n   \t\treturn order;\n\n    // equal-weight box filter\n    return 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // which set of options?\n    int s = splits * int(fragCoord.x) / int(iResolution.x);\n    int samples = param[s].samples;\n    int dist = param[s].dist;\n    int filt = param[s].filt;\n    float order = float(param[s].order);\n    \n    vec2 pix = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    vec2 kernelSize = filterWidth(filt, order) / iResolution.xy;\n\n    vec4 color = vec4(0);\n\tfor(int i=0; i < samples; ++i) {\n\t    for(int j=0; j < samples; ++j) {\n    \t    // sample offset (possibly with jitter)\n        \tvec2 offset = (vec2(i,j) + jitter(dist, i,j)) / float(samples) - 0.5;\n            offset = distribution(filt, offset);\n\n\t        // ray direction\n    \t    vec3 ray = vec3(pix + offset*kernelSize,2);\n\n        \tvec3 samp = vec3(0.5, 0.7, 0.9); // background color\n            if (ray.y < 0.0) { // ray intersects x/z plane through 0,-1,0\n\t            // where is intersection\n    \t        vec2 p = -ray.xz / ray.y + speed * iTime;\n                samp = vec3((int(p.x)&1) == (int(p.y)&1));\n            }\n \t\t\n\t        // accumulate with weight\n    \t    color += vec4(samp,1) * weight(filt, offset, order);\n \t   }\n\t}\n    \n\tfragColor = color / color.a;\n}","name":"Image","description":"","type":"image"}]}