{"ver":"0.1","info":{"id":"dsfyz8","date":"1686565955","viewed":48,"name":"ORB       ","username":"khlorghaal","description":"i forgot how this works lol","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","epileptic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//author khlorghaal\n//copyright most rights reserved\n\n\n//utils\n#define wh (iResolution.xy)\n#define time iTime\n#define lerp mix\n#define norm normalize\n#define len length\n#define smooth(x) smoothstep(0.,1.,x)\n#define quan(x,q) (floor((x)*(q))/(q))\nfloat sum( vec2 v){ return v.x+v.y; }\nfloat prod(vec2 v){ return v.x*v.y; }\n#define about(v,a) (sat(1.-abs(v-(a))))\nfloat maxv(vec2 v){ return max(v.x,v.y);}\nfloat minv(vec2 v){ return min(v.x,v.y);}\nfloat sat(float v){ return max(0.,min(1.,v)); }\nvec2 sat(vec2 v){ return max(vec2(0.),min(vec2(1.),v)); }\n#define nmu(x) x*.5+.5\n#define nms(x) x*2.-1.\n#define tri(x) abs(nms(fract(x)))\n\n#define hashf(x) fract(sqrt(tri(( x*7.321 ))) *9876.54321)\n//sqrt gens irrationals cheaper than sine\nfloat rand21(vec2 v){ return hashf(v.x + v.y + v.x*v.y);  }\nfloat rand31(vec3 v){ return hashf(v.x*v.y + v.y*v.z + v.z*v.x);  }\n\n\nfloat checker(ivec2 i){ return float((i.x+i.y)&1); }\n\n#define res iResolution\n#define time iTime\nvoid mainImage( out vec4 fragColor, in vec2 v_fc ){\n    //vertex/uniform uv-space\n    vec2 fc= v_fc - res.xy/2.;\n    vec2 fc0= fc;\n    fc= floor(fc);\n            \n    float R= minv(res.xy)/2. *.95;//sphere radius\n    float L0= len(fc);//uv len \n    float L2;\n    {//distort\n        vec2 p= fc;\n        float r= R;\n        float l= len(p);\n        vec2 n= norm(p);\n\n        float rm= nms(tri(time*9.1234567));\n        rm= sqrt(rm);\n        p= ((l+(l>=R?r:-R*rm))*n);\n        L2= len(p);\n        if(l<R){\n            p*= .5;//reduce noise\n        }\n        \n        //p= pow(abs(p),vec2(1.2));\n        p= abs(p);\n\n        fc= p;\n    }\n    \n    ivec2 ifc= ivec2(fc);//floored\n    \n    vec2 tuv0= vec2(ifc)/minv(res.xy)*1.05 +.5;\n    \n    vec4 im= vec4(\n        #ifdef TEXTURE\n            tex(tuv0),\n        #endif\n        1.);\n           \n    vec4 E; {//pattern\n        vec2 p= fc;\n        float t= time;\n\n        ivec2 i= ivec2(p)/2;\n\n        float m= tri(time*1.);//modulator, not modulus\n        float l;\n\n        l= checker(i);\n\n        vec3 sq= quan(vec3(p,p.x+p.y+t*17.),1.5);\n        l= hashf(sq.x)*hashf(sq.y)*hashf(sq.z);\n        //l= 1.-((1.-l)*(1.-l));\n        //l= lerp(l, hashf(p.x)*hashf(p.y), m);\n        //l*= sat(.420+hashf(p.x)*hashf(p.y));\n        l= step(.35,l);\n    \n        E= vec4(vec3(l), 1.);\n    }\n    im*= E;\n    \n    float l= L0>=R?.75:1.;//darken outer\n    if(L0<R)\n        l*= sat(R*.022- L0*.020);//sphere shading\n    im.a*= l;\n    //im.a*= sat(L2/20.);\n    im.rgb*= im.a;\n        \n    vec4 c= im;\n    fragColor= vec4(c.rgb*c.a,1.);\n}","name":"Image","description":"","type":"image"}]}