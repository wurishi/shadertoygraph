{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"const int MAX_ITERATIONS = 12;\nconst float ESCAPE_BOUNDARY = 4.0;\n\nfloat hash( float n ) {\n    return fract(sin(n)*95239.5453123);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n\n// add two complex numbers together\nvec2 add(vec2 a, vec2 b) {\n    return a + b;\n}\n\nvec2 mult(vec2 a, vec2 b) {\n    return vec2(a.x*b.x - a.y*b.y, 2.0*a.x*b.y);\n}\n\nvec4 palette(float i, vec2 c) {\n    vec4 s = vec4(i, 0.0, 0.0, 1.0);\n    return mix(vec4(0.0), s, i) + vec4(1.0) * 0.8 * i*i;\n}\n\n// N is escape iteration\n// p is z exponent (probably 2)\n// z is the final iteration position\nfloat smoothIterationCount(int N, float p, vec2 z) {\n    if (N < MAX_ITERATIONS) {\n    \treturn float(N) + 1.0 + (1.0 / log(p)) * log( log(ESCAPE_BOUNDARY) / log(length(z)) );\n    } else {\n        return float(MAX_ITERATIONS);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    float height = 3.0;\n    vec2 extent = vec2(height * (iResolution.x / iResolution.y), height);\n    \n    vec2 center = extent * (iMouse.xy / iResolution.xy - 0.5); center = center / length(center) * sqrt(length(center));\n    //vec2 center = vec2(0.0, 0.0);\n\tvec2 z = fragCoord.xy / iResolution.xy * extent + (center - extent / 2.0);\n    //vec2 c = vec2(0.5, 0.25);\n    vec2 c = (iMouse.xy / iResolution.xy - vec2(0.5)) * 4.0;\n    \n    c += vec2(noise(vec3(12.0, 91.0, iTime * 0.5)),\n              noise(vec3(19.0, 0.962, iTime * 0.5 + 14.0))) * 0.2;\n    \n    float M = 4.0;\n    \n    int i = 0;\n    for(int ii = 0; ii < MAX_ITERATIONS; ii++) {\n        z = mult(z, z) - mult(z, c) + c;\n        \n        if(length(z) > M) break;\n        i = ii + 1;\n    }\n    float smoothcolor = smoothIterationCount(i, 2.0, z);\n    fragColor = palette(smoothcolor / float(MAX_ITERATIONS) * 1.0, z);\n    //fragColor = palette(float(i) / float(MAX_ITERATIONS) * 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Mtl3zS","date":"1424203412","viewed":210,"name":"Julia Set Experiments","username":"hellochar","description":"Messing around with the julia set","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbrot","juliaset","escapetime"],"hasliked":0,"parentid":"","parentname":""}}