{"ver":"0.1","info":{"id":"3tVGRz","date":"1578329363","viewed":689,"name":"Plane Checker AA","username":"spalmer","description":"draws an analytically antialiased checkered plane.\ncan split-window using mouse click\nand number keys switch right panel methods \nto compare with unfiltered left panel\n","likes":21,"published":1,"flags":16,"usePreview":0,"tags":["grid","antialias","checker","plane","splitscreen"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// see also https://shadertoy.com/view/wt3Sz2\n\n// a simple testbed for rendering an antialiased checkered plane.\n// can contrast various filtering methods.\n// no texture samplers used!\n\nconst vec3 // check colors\n  C1 = vec3(1.,1.,.9) //1.,1.,1.) //1.,1.,0.) //\n, C2 = vec3(0.,0.,0.) //1.,0.,1.)\n, Csky = vec3(.8,.9,1.);\n\n#define R iResolution.xy\n\nconst float pi = acos(-1.); //3.141592;\n\n// refactored out the common derivative filtering portion:\n// trivial to change to any dimension.  \n// can ignore the axis not being striped.\n// wound up using fwidth instead, as it's far more convenient!\nfloat filterWidth1(float u)\n{\n    float dx = dFdx(u), dy = dFdy(u);\n    return dx * dx + dy * dy + .0001;\n}\n\nfloat filterWidth2(vec2 uv)\n{\n     vec2 dx = dFdx(uv), dy = dFdy(uv);\n    return dot(dx, dx) + dot(dy, dy) + .0001;\n}\n//    vec2 fw = fwidth(uv); return dot(fw, fw) + .0001; //max(fw.x, fw.y) + .0001; //\n\nfloat filterWidth3(vec3 uvw)\n{\n    vec3 dx = dFdx(uvw), dy = dFdy(uvw);\n    return dot(dx, dx) + dot(dy, dy) + .0001;\n}\n\nfloat filterWidthb2(vec2 uvw)\n{\n    vec2 dx = dFdx(uvw), dy = dFdy(uvw);\n    return max(dot(dx, dx), dot(dy, dy)) + .0001; // tried; looks same to me\n}\n\nfloat filterWidthc2(vec2 uvw)\n{\n    vec2 w = fwidth(uvw);\n    return dot(w, w) + .0001; //max(w.x, w.y) + .0001; //\n}\n\nfloat filterWidthc3(vec3 uvw)\n{\n    vec3 w = fwidth(uvw);\n    return dot(w, w) + .0001; //max(w.x, max(w.y, w.z)) + .0001;\n}\n\nfloat tentbox2(vec2 f) // tent box?\n{\n    return min(min(f.x, 1.-f.x), min(f.y, 1.-f.y)) * 2.;\n}\n\nfloat parabox2(vec2 f) // parabola box?\n{\n    return min(f.x * (1.-f.x), f.y * (1.-f.y)) * 4.;\n}\n\nfloat paraboloid2(vec2 f) // paraboloid\n{\n\treturn f.x * (1.-f.x) * f.y * (1.-f.y) * 16.;\n}\n\n// exp2 filters return 1 when should blur completely out\n// g is a positive distance to an edge to be smoothed\n// idk if I really needed to refactor this, after all.\nfloat smoothCheck(float x, float g, float w)\n{\n    return mix(x, .5, exp2(-clamp(g / w, 0., 1.)));\n}\n\n\n// simple unfiltered checkerboard texture as reference; aliases badly.\nfloat checkerUnfiltered(vec2 p)\n{\n\treturn float((int(floor(p.x))^int(floor(p.y)))&1);\n}\n\nfloat checkerIso(vec2 p)\n{\n\treturn smoothCheck(checkerUnfiltered(p)\n        , .25 //, tentbox2(fract(p)) //\n        , exp2(max(0., fwidth(p.x) + fwidth(p.y))) - 1.);\n}\n\n// for @FabriceNeyret2; parameterized like a texlodbias but takes a log2 of fraction, so is -1 .. 0 range?! idk\nfloat checkerIso(vec2 p, float miplodbias)\n{\n\treturn smoothCheck(checkerUnfiltered(p)\n        , .25 //, tentbox2(fract(p)) //\n        , 1./(1.-min(0., miplodbias))/*exp2(max(0., .05*miplodbias))*/ - 1.);\n}\n\n// considers each check axis separately\nfloat checkerAA(vec2 p)\n{\n    vec2 f = fract(p);\n    float x = checkerUnfiltered(p)\n    , gx = min(f.x, 1.-f.x)\n    , gy = min(f.y, 1.-f.y)\n    , fx = fwidth(p.x)\n    , fy = fwidth(p.y)\n    , lx = gx / (1./R.x + fx*(1.+16.*fx))\n    , ly = gy / (1./R.y + fy*(1.+16.*fy))\n    , l = 2. * min(lx, ly);\n    return mix(.5, x, clamp(l, 0., 1.));\n}\n\n//, s = .01*R.y\n//gx / (1. + s * fx) //gx * exp2(-16./R.x*(fx - 64.)) //\n//gy / (1. + s * fy) //gy * exp2(-16./R.y*(fy - 64.)) //\n\n// like checkerAASimple but with squared falloff for\n// distance blur, similar to how checkerExp works; decent\nfloat checkerAA2(vec2 p)\n{\n    vec2 f = fract(p);\n    float x = checkerUnfiltered(p)\n    , g = tentbox2(f) //\n    , w = max(fwidth(p.x), fwidth(p.y)) //\n    , r = 2.*R.y\n    , l = r*g / (1. + r*w*(8.*w+1.)); //r*g / (1. + 2.*r*w); //\n    return mix(.5, x, clamp(l, 0., 1.));\n}\n\n// it's simple because it uses simple tent function\n// and simple fwidth with relatively simple rational function inlined\nfloat checkerAASimple(vec2 p)\n{\n    vec2 f = fract(p); //p - floor(p); //\n    float x = checkerUnfiltered(p)\n    , g = tentbox2(f) //min(min(f.x, 1.-f.x), min(f.y, 1.-f.y)) * 2. //\n    , w = max(fwidth(p.x), fwidth(p.y)) //fwidth(p.x) + fwidth(p.y) //\n    , r = 2.*R.y // can scale more for more blur in distance\n    , l = r*g / (1. + r*w); //min(.5*iResolution.y*g, 1.-w); //8. * g - .5 * w; //8. * g / w; //g; // can try different functions\n    return mix(.5, x, clamp(l, 0., 1.)); // smoothCheck\n}\n// the tent shape is not the main problem\n// the filter width measurement is not the main problem\n// those are both different yet the result\n// appears identical to checkerAASimple\nfloat checkerAAAlt(vec2 p)\n{\n    float x = checkerUnfiltered(p);\n    vec2 f = fract(p);\n    float g = parabox2(f);\n    float w = fwidth(p.x) + fwidth(p.y); //filterWidthc2(p);\n    //w = sqrt(w); // ALL of my filter width measurement wrappers are squared.\n    return mix(x, .5, exp2(-2. * max(0., g / (w + 1e-7))));\n     //min(.5*R.y*g, 1.-w); //8. * g - .5 * w; //8. * g / w; // can try different functions\n}\n\n// my exponential blending over edges, works pretty well but axes are joined awkwardly\nfloat checkerExp(vec2 p)\n{\n    float x = checkerUnfiltered(p);\n    vec2 f = fract(p);\n    float g = parabox2(f);\n    float w = filterWidth2(p);\n    // g and w just get multiplied together anyway; just simplify this?  currently shared with the stripe toy\n    return smoothCheck(x, .125 * g, w);\n}\n\n// my axis-separated exponentiated sinusoid\nfloat checkerSine2(vec2 p)\n{\n    float x = sin(p.x * -pi) * exp2(-24.*fwidth(p.x) + 3.)\n            * sin(p.y *  pi) * exp2(-24.*fwidth(p.y) + 3.); // tune blur rate\n    return clamp(x, -1., 1.) * .5 + .5;\n}\n// mine.  Doesn't hold up when very close.\nfloat checkerSine(vec2 p)\n{\n    float x = sin(p.x * -pi) * sin(p.y * pi);\n    float w = max(fwidth(p.x), fwidth(p.y));\n    x *= exp2(-16.*w + 4.); // tune blur rate\n    return clamp(x, -1., 1.) * .5 + .5;\n}\n\n// I tried a bunch of stuff!\n//\t  float w = abs(f.x) + abs(f.y); w *= 4.;\n//    \n//    g = 1. - g; // HACK reverse\n//    float w = max(dot(dx,dx), dot(dy,dy)); //(length(dx) + length(dy)); //max(length(dx), length(dy)); //;\n//    w *= 4.; // HACK\n//    w *= (1. + g); //(1.-g);\n//    float e = exp2(-.125*(g)/(w+.001)); //1.-g; //(1.-g) * exp2(-.2/w); //0.; //1.- ; //g; //\n\n// I hackjob'd iq checkersTextureGradBox and squared the derivatives; looks much better imho\nfloat checkerSquared(vec2 p)\n{\n    vec2 w = max(abs(dFdx(p)), abs(dFdy(p)));\n    w *= w; // not in iq's original code - I find it works much better and keeps the nearby edges sharp\n    w = w * 12. + .001;\n    vec2 i = 2.*(abs(fract((p - .5*w) * .5) - .5)\n                -abs(fract((p + .5*w) * .5) - .5)) / w;\n    return .5 - .5 * i.x * i.y;\n}\n\n#if 1\n// iq's newest http://shadertoy.com/view/llffWs\n// The MIT License\n// Copyright © 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// http://shadertoy.com/view/MtffWs\nvec2 pri(vec2 x)\n{\n    vec2 h = fract(.5*x)-.5;\n    return x*.5 + h*(1.-2.*abs(h));\n}\n// http://iquilezles.org/articles/morecheckerfiltering/\nfloat checkersTextureGradTri(vec2 p, vec2 ddx, vec2 ddy)\n{\n    vec2 w = max(abs(ddx), abs(ddy)) + .01;       // filter kernel\n    vec2 i = (pri(p+w) - 2.*pri(p) + pri(p-w)) / (w*w); // analytical integral (box filter)\n    return .5 - .5*i.x*i.y;                  // xor pattern\n}\n\nfloat checkerIq2(vec2 p)\n{\n\treturn checkersTextureGradTri(p, 1.4*dFdx(p), 1.4*dFdy(p));\n}\n#endif\n\n#if 1\n// iq's older one is good, but doesn't completely suppress aliasing in the extreme distance,\n// where it may as well fade completely to .5, and it gets too blurry on edges up close.\n// I probably just have it tuned wrongly.\n// iq's http://shadertoy.com/view/XlcSz2, originating from GPU Gems ch 25\n// The MIT License\n// Copyright © 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// --- analytically box-filtered checkerboard ---\nfloat checkersTextureGradBox(vec2 p, vec2 d_x, vec2 d_y)\n{\n    // filter kernel - iso\n    vec2 w = max(abs(d_x), abs(d_y)) + 0.01;\n    // analytical integral (box filter)\n    vec2 i = 2.*(abs(fract((p - .5*w) * .5) - .5)\n                -abs(fract((p + .5*w) * .5) - .5)) / w;\n    // xor pattern\n    return .5 - .5*i.x*i.y;                  \n}\n// my wrapper computes derivatives\nfloat checkerIq(vec2 p) // unscaled matches the gpu gem better\n{\n\treturn checkersTextureGradBox(p, dFdx(p), dFdy(p));\n}\n// rescaled; aliases less but gets excessively blurry when very close\nfloat checkerIqx4(vec2 p)\n{\n\treturn checkersTextureGradBox(p, dFdx(p) * 4., dFdy(p) * 4.);\n}\n#endif\n\n#if 1\n// FabriceNeyret2's 16x aniso sampler\n// from https://shadertoy.com/view/4lXfzn\nfloat checkerFabriceAniso(vec2 p) \n{\n    mat2 J = inverse(mat2(dFdx(p),dFdy(p)));       // dFdxy: pixel footprint in texture space\n    J = transpose(J)*J;                            // quadratic form\n    float d = determinant(J), t = J[0][0]+J[1][1], // find ellipse: eigenvalues, max eigenvector\n          D = sqrt(t*t-4.*d), \n          V = (t-D)/2., v = (t+D)/2.,                     // eigenvalues \n          M = 1./sqrt(V), m = 1./sqrt(v), l = log2(m*R.y); // = 1./radii^2\n  //if (M/m>16.) l = log2(M/16.*R.y);                     // optional\n    vec2 A = M * normalize(vec2( -J[0][1] , J[0][0]-V )); // max eigenvector = main axis\n    float O = 0.;\n    for (float i = -7.5; i<8.; ++i) {                      // sample x16 along main axis at LOD min-radius\n        vec2 q = p+(i/16.)*A;\n        O += checkerUnfiltered(q); //checkerIso(q); //checkerIso(q, l); //\n    }\n    O /= 16.;\n    //O = mix(.5, O, clamp(1./m, 0., 1.)); // TODO fade in distance to replace lacking mipmaps\n    return O;\n}\n#endif\n\n#if 1\n// oneshade https://shadertoy.com/view/7sKSDV\n// Error function approximation\nfloat erf(float x) \n{\n    return sign(x) * sqrt(1.0 - exp2(-1.787776 * x * x));\n}\n\n// Gaussian filtered checkerboard\nconst float k = 4.; //3.; //\nfloat checkerOneshade(vec2 p)\n{\n    vec2 w = clamp(vec2(fwidth(p.x), fwidth(p.y)), 1e-9, 2.); //vec2(.1,.01); // TODO dFdx, dFdy, may need to rotate to grid somehow\n    p = mod(p, 2.);\n    float s = 1.0 - 2. * mod(k, 2.);\n    float u = 0., v = 0.;\n    for (float n = -k; n <= k; ++n) {\n        u += s * erf((p.x - n) / w.x);\n        v += s * erf((p.y - n) / w.y);\n        s = -s;\n    }\n    return (1. - u * v) / 2.;\n}\n#endif\n// is that a Weierstrass transform? I'm unsure.  You tell me!\n// https://wikipedia.org/wiki/Weierstrass_transform\n\n#if 1\n// TODO 'check' out fizzer's http://shadertoy.com/view/tlcXRX\nfloat integrateCheckerboard(vec2 uv0, vec2 uv1)\n{\n  \tvec2 rd = uv1 - uv0;\n    \n    vec2 dt = abs(vec2(1) / rd);\n    vec2 t = (floor(uv0) + max(sign(rd), 0.) - uv0) * dt * sign(rd);\n    int e = int(floor(uv0.x) + floor(uv0.y)) & 1;\n    \n    float mt = 0., pt, a = 0.;\n    \n    for(int i = 0; i < 8; ++i)\n    {\n        pt = mt;\n        mt = min(t.x, t.y);\n        \n        if((i & 1) == e)\n        \ta += min(1., mt) - pt;\n\n        if(mt > 1.)\n            break;\n        \n        t += step(t, t.yx) * dt;\n    }\n    \n    return 1.-a; // reversed pattern from mine\n}\n// almost works now, needs some more love on the sky etc.\nfloat checkerFizzer(vec2 uv)\n{\n    vec2 w = fwidth(uv); //gradient(uv);\n    return integrateCheckerboard(uv - w, uv + w);\n}\n#endif\n\nint mode;\n\n// shown on right side of split screen\nfloat ImageR(vec2 uv)\n{\n    switch (mode) {\n      default:\n      case 0:  return checkerAA(uv);\n      case 1:  return checkerOneshade(uv); //checkerFizzer(uv); //\n      case 2:  return checkerSquared(uv); // iq^2\n\t  case 3:  return checkerIq2(uv); //checkerIqx4(uv); //\n      case 4:  return checkerAA2(uv);\n\t  case 5:  return checkerFabriceAniso(uv);\n      case 6:  return checkerIq(uv); //checkerAAAlt(uv); //\n      case 7:  return checkerSine2(uv); //checkerSine(uv); //\n      case 8:  return checkerAASimple(uv);\n      case 9:  return checkerExp(uv); //checkerIso(uv); //checkerUnfiltered(uv);\n    }\n}\n// shown on left half of split screen\nfloat ImageL(vec2 uv)\n{\n//    return checkerOneshade(uv);\n\t  return checkerIq2(uv);\n//\t  return checkerIqx4(uv);\n//\t  return checkerIq(uv);\n//    return checkerFabriceAniso(uv);\n//\t  return checkerIso(uv);\n\treturn checkerUnfiltered(uv);\n}\n\n\nconst float maxd = 85000.;\n\n// halfspace\nfloat tracePlaneY(vec3 rp, vec3 rd)\n{\n    return rp.y <= 0. ? 0. :\n    \trd.y >= 0. ? -1. : //maxd :\n    \trp.y / -rd.y;\n}\n\nvoid rot(inout vec2 v, float radian)\n{\n    float c = cos(radian), s = sin(radian);\n    v *= mat2(c, s,-s, c);\n}\n\nvec3 CameraRay(vec2 p)\n{\n    vec2 q = (2. * p - iResolution.xy) / iResolution.y;\n    vec3 rd = normalize(vec3(q / 2., 1.));\n    float pitch = -.4, yaw = iTime * -.04;\n    rot(rd.yz, pitch);\n    rot(rd.xz, yaw);\n    return rd;\n}\n\nbool key(int k) \n{\n    return texelFetch(iChannel3, ivec2(k, 0), 0).x > .5;\n}\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    // a simple camera\n    vec3 rp = vec3(0,1,0);\n    rp.y += sin(.07 * iTime) * .99; // bob slowly up and down\n    vec3 rd = CameraRay(p);\n    \n    // Y plane distance\n    float d = maxd;\n    float dplane = tracePlaneY(rp, rd);\n    vec2 cc = vec2(1., 0.);\n    if (dplane >= 0.) {\n        d = min(d, dplane);\n\t    cc = rp.xz + rd.xz * d; // grid uv at hit point\n    \tcc *= 4.; // tiling\n    }\n    \n    // number keys 1 thru 3 control bit of a binary number mode selector\n    mode = 0;\n    for (int i = 1; i < 10; ++i) \n        if (key(48 + i)) mode = i;\n    \n    // split screen at mouse click\n    float splits = p.x - (iMouse.z == 0. ? .5 * iResolution.x : iMouse.x);\n    bool left = splits < 0.;\n    // depending on last mouse click, split screen between two different functions\n    float check = left \n        ? ImageL(cc)\n        : ImageR(cc);\n\n    c.rgb = mix(C1, C2, check); // colorize\n    \n    float fog = 1.0 - exp2(-.02*d); //0.; //\n    c.rgb = mix(c.rgb, Csky, fog);\n    // green vertical line at split\n    c.rgb = mix(c.rgb, vec3(.0,.5,.0), exp2(-2. * abs(splits)));\n    \n    c.rgb = pow(c.rgb, vec3(1./2.2)); // to srgb gamut\n    c.a = 1.;\n}\n\n    \n    // no actual lighting in this simple test,\n    // but a few dot products would do it.\n\n//  if (!(d >= 0.)) d = maxd; // handle possible nan\n//  float dflat = d / rd.z;\n//  float aa = 1.0 - exp2(-.03*d); // HACK\n//    float g = exp2(-.03*d);\n//    c = vec3(g); // debug depths\n//    if (!left) fog = 0.; // fog hides the worst of the aliasing at the horizon, though.  So you might want to unhide it, but maybe only for right half?\n//   c = vec3(fract(cc), 0); // show hit uv\n ","name":"Image","description":"","type":"image"}]}