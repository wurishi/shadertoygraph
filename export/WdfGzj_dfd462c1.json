{"ver":"0.1","info":{"id":"WdfGzj","date":"1546799302","viewed":1373,"name":"Stateless Analytic Ball Physics","username":"fizzer","description":"Here is a method to do a sort of physics \"simulation\" without needing to store anything between frames. The ball paths are split in to parabolic arcs, one arc for each sphere-disc collision.","likes":29,"published":1,"flags":0,"usePreview":1,"tags":["collision","sphere","balls","bounce","stateless"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Here is a method to do a sort of physics \"simulation\" without needing to store anything\n// between frames. The ball paths are split in to parabolic arcs, one arc for each sphere-disc\n// collision.\n//\n// This allows for cool effects such as making time go backwards. Change the GO_BACKWARDS\n// macro to 1 to see this in action.\n//\n// This approach was used in this 4kb demo too: http://www.pouet.net/prod.php?which=71550\n\n#define NUM_SPHERES\t\t18\n#define GO_BACKWARDS\t0\n\nfloat time;\n\nvec4 discP[5];\nvec3 discN[5];\nvec4 spheres[NUM_SPHERES];\n\n// Ray vs. sphere intersection\nvec2 intersectSphere(vec3 ro, vec3 rd, vec3 org, float rad)\n{\n    float a = dot(rd, rd);\n    float b = 2. * dot(rd, ro - org);\n    float c = dot(ro - org, ro - org) - rad * rad;\n    float desc = b * b - 4. * a * c;\n    \n    if (desc < 0.)\n        return vec2(1, 0);\n\n    return vec2((-b - sqrt(desc)) / (2. * a), (-b + sqrt(desc)) / (2. * a));\n}\n\nvec3 traceSpherePath(int index, out float radscale)\n{\n    // Set up initial position and velocity\n    vec3 origin = vec3(0, 2, 0);\n    vec3 initial_velocity = vec3(.6, 1.5 + cos(float(index)) * .4, 0);\n\n    // Rotate velocity\n    float ya = float(index);\n    initial_velocity.xz *= mat2(cos(ya), sin(ya), -sin(ya), cos(ya));\n    \n    // Gravity\n    vec3 acceleration = vec3(0, -1.2, 0) * 3.;\n\n    vec3 pos, norm;\n\n    float tt = time + float(index)*.2;\n\n    float lifetime = 2.5;\n    tt = mod(tt, lifetime);\n    radscale = 1.;\n    radscale = smoothstep(0., .1, tt) - smoothstep(lifetime - .1, lifetime, tt);\n\n    float rad;\n\n    // Go through the whole particle motion up to the current timepoint, one parabolic arc at a time.\n    // Gravity is kept constant, so acceleration is not changed.\n    for(int j = 0; j < 3; ++j)\n    {\n        float minq = tt;\n\n        // Candidate arc resulting from a collision\n        vec3 new_origin, new_initial_velocity;\n\n        for(int i = 0; i < 5; ++i)\n        {\n            pos = discP[i].xyz;\n            rad = discP[i].w;\n            norm = discN[i];\n\n            // Set up a quadratic equation representing the intersection of the current\n            // parabolic arc with the plane which this disc lies on.\n            // This works because the arc of motion lies in a plane. The intersection of that\n            // plane with the disc's plane is a line. This line can be projected back in to the\n            // arc's plane and the intersection test then becomes a test for intersection between\n            // a parabola and a line in 2D, which is a quadratic equation.\n            float b = initial_velocity.y + dot(initial_velocity.xz, norm.xz) / norm.y;      \n            float d = b * b - acceleration.y * dot(origin - pos, norm) / norm.y * 4.;            \n            float q = (-b - sqrt(d)) / acceleration.y / 2.;\n\n            if(d > 0.)\n            {\n                // The equation has a real root\n                vec3 o = origin + initial_velocity * q + acceleration * q * q;\n\n                if(q > 0.&& q < minq && length(o - pos) < rad)\n                {\n                    // The intersection timepoint is valid, and the intersection point is\n                    // contained by the disc. So, update the collision candidate.\n                    new_origin = o;\n                    new_initial_velocity = reflect(initial_velocity + acceleration * q * 2., norm) * .6;\n                    minq = q;\n                }\n            }\n        }\n\n        if(tt>minq)\n        {\n            // The current arc collided with a disc, so replace it\n            // with a new arc representing the deflected particle motion.\n            origin = new_origin;\n            initial_velocity = new_initial_velocity;\n            tt -= minq;\n        }\n        else\n            break;\n    }\n\n    // Calculate the final particle position by evaluating the final parabola.\n    pos = origin + initial_velocity * tt + acceleration * tt * tt;\n\n    return pos;\n}\n\n// Returns an attentuated shadow amount and intersection distance of ray\nvec2 traceDiscs(vec3 ro, vec3 rd, float cone, out vec3 mn, float time)\n{\n    float l = 1.;\n    float mt = 1e4, t, w, d;\n    float rad;\n    vec3 pos, norm;\n    for(int i = 0; i < 5; ++i)\n    {\n        pos = discP[i].xyz;\n        rad = discP[i].w;\n        norm = discN[i];\n        t = dot(pos - ro, norm) / dot(rd, norm);\n        if(t > 0.)\n        {\n            w = t * cone;\n            d = length(ro + rd * t - pos) - rad;\n            l *= smoothstep(-w, w, d);\n            if(t < mt && d < 0.)\n            {\n                mt = t;\n                mn = norm * -sign(dot(norm, rd));\n            }\n        }\n    }\n    return vec2(l, mt);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n\n    uv.x *= iResolution.x / iResolution.y;\n\n    time = iTime;\n    \n    // Set up disc positions, orientations, sizes\n    discP[0] = vec4(1, -.8, 0, 1);\n    discN[0] = normalize(vec3(.3, -1, 0));\n\n    discP[1] = vec4(-1, -.4, 0, 1);\n    discN[1] = normalize(vec3(-.3, -1, 0.4));\n\n    discP[2] = vec4(0, -.8, 1.4, 1.1);\n    discN[2] = normalize(vec3(0, -1, .3));\n\n    discP[3] = vec4(.4, 0.1, .1, .4);\n    discN[3] = normalize(vec3(0, -1, 0.1));\n\n    discP[4] = vec4(0, -1.5, 0, 1);\n    discN[4] = normalize(vec3(.0, -1, 0));\n\n    // Motion jitter\n    time += texelFetch(iChannel0, ivec2(mod(fragCoord.xy, 1024.)), 0).x * .015;\n\n    // Set up primary ray\n    float an = 1. + time / 2.;\n    an = 2.3 + sin(time / 2.);\n\n    vec3 ro = vec3(0., 0., 4.4);\n    vec3 rd = normalize(vec3(uv.xy, -1.9));\n\n    rd.xz = mat2(cos(an), sin(an), sin(an), -cos(an)) * rd.xz;\n    ro.xz = mat2(cos(an), sin(an), sin(an), -cos(an)) * ro.xz;\n\n\n#if GO_BACKWARDS\n    time = -time;\n#endif\n\n    vec3 norm;\n    float t = 1e4;\n\n    vec3 hitcol = vec3(1);\n\n    // Test intersection with spheres\n    for(int j = 0; j < NUM_SPHERES; ++j)\n    {\n        float radscale;\n        vec3 p = traceSpherePath(j, radscale);\n\t\tfloat r = 1.2 * radscale * mix(.06, .1, .5 + .5 * cos(float(j)));\n        \n        spheres[j] = vec4(p, r);\n        \n        vec2 i = intersectSphere(ro, rd, p, r);\n        \n        if(i.x > 0. && i.x < i.y && i.x < t)\n        {\n            t = i.x;\n            norm = ro + rd * t - p;\n            hitcol = mix(vec3(1, .4, .05), vec3(.3, 1, .1), .5 + .5 * cos(float(j) * 8.));\n        }\n\n    }\n\n    // Test intersection with discs\n    vec3 dn;\n    vec2 dt = traceDiscs(ro, rd, 0., dn, time);\n\n    if(dt.y < t)\n    {\n        t = dt.y;\n        norm = dn;\n        hitcol = vec3(1);\n    }\n\n    if(t > 1e3)\n    {\n        // Background\n        fragColor.rgb = vec3(.05 - length(uv) / 40.);\n    }\n    else\n    {\n        // Intersected with sphere or disc\n        vec3 hitp = ro + rd * t;\n        float l = 1.;\n\n        norm = normalize(norm);\n\n        vec3 ld = normalize(vec3(1, 1, 1));\n        vec3 r = reflect(rd, norm);\n\n        // Do some soft shadowing\n        l *= mix(.125, 1., traceDiscs(hitp + norm * 1e-4, ld, .2, dn, time).x);\n        l *= mix(.25, 1., traceDiscs(hitp + norm * 1e-4, vec3(0, 1, 0), .53, dn, time).x);\n\n\t\t// Trace hard sphere shadows\n        for(int j = 0; j < NUM_SPHERES; ++j)\n        {\n            vec4 sph = spheres[j];\n\n            vec2 i = intersectSphere(hitp + norm * 1e-4, ld, sph.xyz, sph.w);\n            \n            if(i.x > 0. && i.x < i.y)\n            {\n                l *= 0.5;\n                break;\n            }\n\n        }\n\n        // Shading\n        vec3 h = normalize(ld - rd);\n\n        float fr = (1. - dot(-rd, norm)) * .3;\n\n        fragColor.rgb = l * (vec3(max(0., dot(norm, ld))) * hitcol + vec3(fr * .7 + pow(max(0., dot(norm,h)), 64.)) / 2.);\n        fragColor.rgb += .01;\n    }\n    \n    fragColor.rgb = clamp(fragColor.rgb, 0., 1.);\n    \n    // Gamma\n    fragColor.rgb = pow(fragColor.rgb, vec3(1. / 2.2));\n\n    // Dither\n    fragColor.rgb += texelFetch(iChannel0, ivec2(mod(fragCoord.xy, 1024.)), 0).y / 100.;\n}\n\n","name":"Image","description":"","type":"image"}]}