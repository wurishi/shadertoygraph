{"ver":"0.1","info":{"id":"Nll3zB","date":"1622339859","viewed":372,"name":"God Rays - Andrew","username":"andrew741","description":"A god ray simulation using ray tracing, and sphere tracing (a type of ray marching). The god rays are created by using volumetrics (transmittance = e ^ -total_density). The scene is very basic and could be further extended (I've made an improved version).","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raymarching","shadows","godrays","spheretracing","volumetrics","specularhighlights"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat DstSphere(vec3 samp, vec3 p, float r) {return length(samp - p) - r;}\n\n\nfloat DstTorus(vec3 p, vec2 r) {\n\tfloat x = length(p.xz) - r.x;\n    return length(vec2(x, p.y)) - r.y;\n}\n\n\nfloat distToCone(vec3 p, float rBase, float height)\n{\n\tfloat dst1 = length(p.xz) - ((-p.y + height / 2.) / height * rBase);\n    dst1 = abs(p.y) > height / 2. ? 200000. : dst1;\n    return dst1;\n}\n\n\nfloat GetDst(vec3 p)\n{\n    float dst1 = DstSphere(p, vec3(1., 2., 4.), 2.);\n    float dst2 = DstSphere(p, vec3(4., 4., 3.), 2.);\n    float dst3 = DstSphere(p, vec3(-2., 0., 6.), 2.);\n    //float dst3 = distToCone(p - vec3(-2., 0., 6.), 2., 3.);\n    float dst4 = p.y + 3.;\n    float dst5 = DstTorus(p - vec3(8., 0., 3.), vec2(3., 1.));\n    \n    return min(min(min(min(dst1, dst2), dst3), dst4), dst5);\n}\n\n\nvec3 GetCol(vec3 p)\n{\n    float dst1 = DstSphere(p, vec3(1., 2., 4.), 2.);\n    float dst2 = DstSphere(p, vec3(4., 4., 3.), 2.);\n    float dst3 = DstSphere(p, vec3(-2., 0., 6.), 2.);\n    //float dst3 = distToCone(p - vec3(-2., 0., 6.), 2., 3.);\n    float dst4 = p.y + 3.;\n    float dst5 = DstTorus(p - vec3(8., 0., 3.), vec2(3., 1.));\n    \n    float dst = min(min(min(min(dst1, dst2), dst3), dst4), dst5);\n    \n    if (dst == dst1) return vec3(0.2, 1. , 0.2);\n    if (dst == dst2) return vec3(1. , 0.2, 0.2);\n    if (dst == dst3) return vec3(0.2, 0.2, 1. );\n    if (dst == dst4) return vec3(1. , 0.2, 1. );\n    if (dst == dst5) return vec3(1. , 1. , 0.2);\n    \n    return vec3(0);\n}\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDst(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 normal = d - vec3(\n        GetDst(p - e.xyy),\n        GetDst(p - e.yxy),\n        GetDst(p - e.yyx));\n    \n    return normalize(normal);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 camera_pos = vec3(0., 0., -8.);\n    vec3 rd = normalize(vec3(uv + iMouse.xy / iResolution.xy, 1.));\n\n    vec3 sun_derection = normalize(vec3(sin(iTime * 1.5) * 0.4, sin(iTime * 0.1) * 0.5 + 0.5, cos(iTime * 1.5) * 0.4));\n    vec3 sun_col = vec3(1., 0.95, 0.85);\n\n    vec3 col = vec3(0., 0., 0.);\n    \n    float dst;\n    float dfs = 0.;\n    vec3 p = camera_pos;\n    float shadowed = 0.;\n    for (int s = 0; s < 200; s++)\n    {\n        dst = 0.1;\n        p += rd * dst;\n        dfs += dst;\n        \n        float dfs2;\n        float dst2;\n        vec3 p2 = p;\n        for (int s2 = 0; s2 < 50; s2++)\n        {\n            dst2 = GetDst(p2);\n            p2 += sun_derection * dst2;\n            dfs2 += dst2;\n            \n            if (dst2 < 0.01)\n            {\n                shadowed += (25. - dfs2) * 0.0075;\n                break;\n            }\n            else if (dfs2 > 25.) break;\n        }\n        \n        if (dfs > 25. || GetDst(p) < 0.01) break;\n    }\n    \n    float god_ray = exp(-shadowed * 0.05);\n    \n    if (GetDst(p) < 0.05)\n    {\n        float d;\n        vec3 np = p + sun_derection * 2.25;\n        for (int s = 0; s < 50; s++)\n        {\n            d = GetDst(np);\n            np += sun_derection * d;\n        }\n        vec3 normal = GetNormal(p);\n        float shadow = 1.;\n        if (dot(normal, sun_derection) < -0.5 || d < 0.01) shadow = 0.4;\n        \n        vec3 object_color = GetCol(p);\n        \n        float smoothness = 0.65;\n        float specularAngle = acos(dot(normalize(sun_derection - rd), normal));\n        float specularExponent = specularAngle / (1. - smoothness);\n        float specularHighlight = exp(-specularExponent * specularExponent);\n        float diffseLighting = clamp(dot(normal, sun_derection), 0., 1.);\n        \n        col = object_color * (dot(normal, sun_derection) * 0.5 + 0.5) * shadow + (sun_col * specularHighlight * shadow) * pow(god_ray, 20.);\n    }\n    else\n    {\n        col = vec3(0.35, 0.35, rd.y * 0.5 + 0.5);\n        col = mix(col, sun_col * 1.2, clamp(pow(dot(rd, sun_derection), 120.), 0., 1.));\n    }\n    col *= god_ray;\n\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}