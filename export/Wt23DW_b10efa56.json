{"ver":"0.1","info":{"id":"Wt23DW","date":"1559787908","viewed":424,"name":"Parallax Depth Texture","username":"oalpha","description":"Parallax Bump map test","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["texture","parallax","depth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define i3 vec3(1.,0.,0.)\n#define j3 vec3(0.,1.,0.)\n#define k3 vec3(0.,0.,1.)\n#define I3 mat3(1.)\n\nivec2 square(vec2 p, vec2 s)\n{\n\t\tivec2 o = ivec2(0);\n\t\tif(p.x < 0.) o.x = -1;\n\t\telse if(p.x > s.x) o.x = 1;\n\t\tif(p.y < 0.) o.y = -1;\n\t\telse if(p.y > s.y) o.y = 1;\n\t\treturn o;\n}\n\nvec4 tracePlane(vec3 ro, vec3 rd, mat3 o, vec2 s, bool quad, out vec2 ip)\n{\n\t// rd = normalize(rd);\n\tmat3 io = inverse(o);\n\tvec3 iro = io * ro;\n\tvec3 ird = io * rd;\n\tfloat t = -iro.z / ird.z;\n\tip = iro.xy + ird.xy * t;\n\tvec3 p = o * (iro + ird * t);\n\tip /= s;\n\treturn vec4(p, t > 0. && (!quad || all(lessThan(ip, vec2(1.))) && all(greaterThan(ip, vec2(0.)))) ? 1. : 0.);\n}\n\nvec4 tracePlaneDepth(vec3 ray_origin, vec3 ray_dir, mat3 o, vec2 size, float max_depth, vec3 depth_filter, bool height, bool quad, out vec2 point_quad)\n{\n\t// calculate inverse model map\n\tmat3 io = inverse(o);\n\n\t// calculate ray in model space\n\tvec3 ray_origin_model = io * ray_origin;\n\tvec3 ray_dir_model = io * ray_dir;\n\n\t// calculate plane coordinates of ray\n\tvec2 ray_origin_plane = ray_origin_model.xy;\n\tvec2 ray_dir_plane = ray_dir_model.xy;\n\tivec2 ray_origin_plane_square = square(ray_origin_plane, size);\n\n\t// calculate ray distance to plane\n\tfloat ray_distance_shallow, ray_distance_deep;\n\tif(height)\n\t{\n\t\tray_distance_shallow = -(ray_origin_model.z-max_depth) / ray_dir_model.z;\n\t\tray_distance_deep = -ray_origin_model.z / ray_dir_model.z;\n\t}\n\telse {\n\t\tray_distance_shallow = -ray_origin_model.z / ray_dir_model.z;\n\t\tray_distance_deep = -(ray_origin_model.z+max_depth) / ray_dir_model.z;\n\t}\n\n\t// calculate plane coordinates of intersection\n\tvec2 point_plane_shallow = ray_origin_model.xy + ray_dir_model.xy * ray_distance_shallow;\n\tivec2 point_plane_shallow_square = square(point_plane_shallow, size);\n\tvec2 point_plane_deep = ray_origin_model.xy + ray_dir_model.xy * ray_distance_deep;\n\tivec2 point_plane_deep_square = square(point_plane_deep, size);\n\n\t// calculate quad coordinates of intersection\n\tvec2 point_quad_shallow = point_plane_shallow / size;\n\tif(quad) point_quad_shallow = fract(point_quad_shallow);\n\tvec2 point_quad_deep = point_plane_deep / size;\n\tif(quad) point_quad_deep = fract(point_quad_deep);\n\n\tfloat step_size = max_depth / 1., ray_step_size = (ray_distance_deep - ray_distance_shallow) * step_size / max_depth;\n\tfloat depth_estimate_shallow = 0., depth_estimate_deep = step_size;\n\tray_distance_deep = ray_distance_shallow + ray_step_size;\n\tfloat depth_shallow, depth_deep;\n\tif(!quad || all(equal(point_plane_shallow_square, ivec2(0)))) {\n\t\t\tdepth_shallow = max_depth * (1. - dot(texture(iChannel0, point_quad).rgb, depth_filter));\n\t}\n\telse if(all(equal(ray_origin_plane_square, ivec2(0)))) depth_shallow = 0.;\n\telse if(ray_origin_plane_square.x == point_plane_shallow_square.x && ray_origin_plane_square.x != 0 || ray_origin_plane_square.y == point_plane_shallow_square.y && ray_origin_plane_square.y != 0) depth_shallow = 1.;\n\telse depth_shallow = 0.;\n\tif(!quad || all(equal(point_plane_deep_square, ivec2(0)))) {\n\t\tdepth_deep = max_depth * (1. - dot(texture(iChannel0, point_quad_deep).rgb, depth_filter));\n\t}\n\telse if(all(equal(ray_origin_plane_square, ivec2(0)))) depth_deep = 0.;\n\telse if(ray_origin_plane_square.x == point_plane_deep_square.x && ray_origin_plane_square.x != 0 || ray_origin_plane_square.y == point_plane_deep_square.y && ray_origin_plane_square.y != 0) depth_deep = 1.;\n\telse depth_deep = 0.;\n\twhile(depth_deep > depth_estimate_deep && depth_deep < max_depth)\n\t{\n\t\tdepth_estimate_shallow = depth_estimate_deep;\n\t\tray_distance_shallow = ray_distance_deep;\n\t\tpoint_plane_shallow = point_plane_deep;\n\t\tpoint_plane_shallow_square = point_plane_deep_square;\n\t\tpoint_quad_shallow = point_quad_deep;\n\t\tdepth_shallow = depth_deep;\n\t\tdepth_estimate_deep += step_size;\n\t\tray_distance_deep += ray_step_size;\n\t\tpoint_plane_deep = ray_origin_model.xy + ray_dir_model.xy * ray_distance_deep;\n\t\tpoint_plane_deep_square = square(point_plane_deep, size);\n\t\tpoint_quad_deep = point_plane_deep / size;\n\t\tif(quad) point_quad_deep = fract(point_quad_deep);\n\t\tif(!quad || all(equal(point_plane_deep_square, ivec2(0)))) {\n\t\t\tdepth_deep = max_depth * (1. - dot(texture(iChannel0, point_quad_deep).rgb, depth_filter));\n\t\t}\n\t\telse if(all(equal(ray_origin_plane_square, ivec2(0)))) depth_deep = 0.;\n\t\telse if(ray_origin_plane_square.x == point_plane_deep_square.x && ray_origin_plane_square.x != 0 || ray_origin_plane_square.y == point_plane_deep_square.y && ray_origin_plane_square.y != 0) depth_deep = 1.;\n\t\telse depth_deep = 0.;\n\t}\n\tint i = 0;\n\tconst int steps = 7;\n\twhile(i < steps)\n\t{\n\t\tfloat depth_estimate_mid = (depth_estimate_shallow + depth_estimate_deep) * .5;\n\t\tfloat ray_distance_mid = (ray_distance_shallow + ray_distance_deep) * .5;\n\t\tvec2 point_plane_mid = ray_origin_model.xy + ray_dir_model.xy * ray_distance_mid;\n\t\tivec2 point_plane_mid_square = square(point_plane_mid, size);\n\t\tvec2 point_quad_mid = point_plane_mid / size;\n\t\tif(quad) point_quad_mid = fract(point_quad_mid);\n\t\tfloat depth_mid;\n\t\tif(!quad || all(equal(point_plane_mid_square, ivec2(0)))) {\n\t\t\tdepth_mid = max_depth * (1. - dot(texture(iChannel0, point_quad_mid).rgb, depth_filter));\n\t\t}\n\t\telse if(all(equal(ray_origin_plane_square, ivec2(0)))) depth_mid = 0.;\n\t\telse if(ray_origin_plane_square.x == point_plane_mid_square.x && ray_origin_plane_square.x != 0 || ray_origin_plane_square.y == point_plane_mid_square.y && ray_origin_plane_square.y != 0) depth_mid = 1.;\n\t\telse depth_mid = 0.;\n\t\tif(depth_mid > depth_estimate_mid)\n\t\t{\n\t\t\tdepth_estimate_shallow = depth_estimate_mid;\n\t\t\tray_distance_shallow = ray_distance_mid;\n\t\t\tpoint_plane_shallow = point_plane_mid;\n\t\t\tpoint_plane_shallow_square = point_plane_mid_square;\n\t\t\tpoint_quad_shallow = point_quad_mid;\n\t\t\tdepth_shallow = depth_mid;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdepth_estimate_deep = depth_estimate_mid;\n\t\t\tray_distance_deep = ray_distance_mid;\n\t\t\tpoint_plane_deep = point_plane_mid;\n\t\t\tpoint_plane_deep_square = point_plane_mid_square;\n\t\t\tpoint_quad_deep = point_quad_mid;\n\t\t\tdepth_deep = depth_mid;\n\t\t}\n\t\ti++;\n\t}\n\n  bool shallow_in = all(lessThanEqual(point_plane_shallow, size)) && all(greaterThanEqual(point_plane_shallow, vec2(0.)));\n  bool deep_in = all(lessThanEqual(point_plane_deep, size)) && all(greaterThanEqual(point_plane_deep, vec2(0.)));\n  if(ray_distance_shallow > 0. && ray_distance_deep > 0. && (shallow_in && deep_in || !quad))\n\t{\n    float error_shallow = depth_shallow - depth_estimate_shallow;\n    float error_deep = depth_deep - depth_estimate_deep;\n\t\tfloat ray_distance = (ray_distance_shallow*error_deep-ray_distance_deep*error_shallow)/(error_deep-error_shallow);\n\t\tvec2 point_plane = ray_origin_model.xy + ray_dir_model.xy * ray_distance;\n\t\tpoint_quad = point_plane / size;\n\t\tif(quad) point_quad = fract(point_quad);\n\t\tfloat depth = max_depth * (1. - dot(texture(iChannel0, point_quad).rgb, depth_filter));\n\t\treturn vec4(point_quad,-depth,1.);\n\t}\n\treturn vec4(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float t = iTime * .2;\n    vec2 suv = uv * 2. - 1.;\n    suv.y *= iResolution.y / iResolution.x;\n\n    float zoom = .5;\n    float r = zoom * 2.;\n    float h = zoom * 1.;\n    vec3 target = vec3(.5,.5,0.);\n    vec3 camera = vec3(r*cos(t)+.5,r*sin(t)+.5,h);\n\n    vec3 z = normalize(camera - target);\n    vec3 x = normalize(cross(vec3(0.,0.,1.),z));\n    vec3 y = normalize(cross(z,x));\n    mat3 c = mat3(x, y, z);\n    \n    bool height = false, quad = false;\n\n    vec3 col;\n    const int SAMPLES = 4;\n    for(int i = 0; i < SAMPLES; i++)\n    for(int j = 0; j < SAMPLES; j++)\n    {\n        vec2 shift = (vec2(ivec2(i,j)) + .5) / float(SAMPLES) - .5;\n        //shift *= 0.;\n        uv = (fragCoord+shift)/iResolution.xy;\n        suv = uv * 2. - 1.;\n        suv.y *= iResolution.y / iResolution.x;\n    vec3 uv3 = vec3(suv, -1.);\n    vec3 ro = camera;\n    vec3 rd = normalize(c * uv3);\n\n    vec2 ip;\n    float depth = .1;\n    mat3 o = mat3(1.);\n    vec2 size = vec2(1.);\n    vec3 df = i3;\n    vec4 p = tracePlaneDepth(ro, rd, o, size, depth, df, height, quad, ip);\n    vec3 n;\n    if(p.w > .5) {\n    float shift = .001;\n    vec3 p_n = vec3(p.xy + vec2(0.,shift),1.);\n    vec3 p_s = vec3(p.xy + vec2(0.,-shift),1.);\n    vec3 p_e = vec3(p.xy + vec2(shift,0.),1.);\n    vec3 p_w = vec3(p.xy + vec2(-shift,0.),1.);\n    p_n = tracePlaneDepth(p_n, vec3(0.,0.,-1.), o, size, depth, df, height, quad, ip).xyz;\n    p_s = tracePlaneDepth(p_s, vec3(0.,0.,-1.), o, size, depth, df, height, quad, ip).xyz;\n    p_e = tracePlaneDepth(p_e, vec3(0.,0.,-1.), o, size, depth, df, height, quad, ip).xyz;\n    p_w = tracePlaneDepth(p_w, vec3(0.,0.,-1.), o, size, depth, df, height, quad, ip).xyz;\n    n = normalize(cross(p_e-p_w,p_n-p_s));\n    }\n    else n = vec3(0.);\n\n    vec3 l = vec3(4.,3.,2.);\n    float i = 2.;\n    vec3 lr = l - p.xyz;\n    float il = dot(normalize(lr), n) * i / length(lr);\n\n    vec3 c = vec3(il) * p.w;\n        col += c;\n    }\n    col /= float(SAMPLES * SAMPLES);\n\n    //fragColor = vec4(suv,.0,1.0);\n    //fragColor = vec4(abs(suv),.0,1.0);\n    fragColor = vec4(col,1.0);\n\n    /*\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    */\n}","name":"Image","description":"","type":"image"}]}