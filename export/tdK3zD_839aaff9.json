{"ver":"0.1","info":{"id":"tdK3zD","date":"1569910698","viewed":466,"name":"buffer trails noise example","username":"edapx","description":"noise trails test","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["noise","trails","buffers"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 toGamma(vec3 rcolor){\n  return pow(abs(rcolor), vec3(1.0/2.2));\n}\n\nvec3 saturation(vec3 c, float t) {\n    return mix(vec3(dot(c,vec3(0.2126,0.7152,0.0722))),c,t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // read buffer\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    // add colors. Comment this block for B/W version\n    vec3 red = vec3(1.0, 0.353, 0.208);\n\tvec3 blu = vec3(0.086, 0.29, 0.8);\n    col = vec3(col.x)*red;\n    col += blu*(1.0 -col.x);\n\n    // Color correction\n    col = toGamma(col);\n    col = saturation(col, 0.7);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float hash(float n) { return fract(sin(n) * 1e4); }\nfloat fnoise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat circle(vec2 uv, float rad, float speed, float tOff, float dim, float clockwise){\n    vec2 pos = vec2(cos((iTime+tOff)*speed)*rad,\n               sin((iTime+tOff)*speed)*rad);\n    if (clockwise > 0.) {\n    \tpos = vec2(sin((iTime+tOff)*speed)*rad,\n                   cos((iTime+tOff)*speed)*rad);\n    }\n    return 1.0-smoothstep(distance(pos, uv)*dim,0.0, 0.095);\n}\n\nfloat circles(vec2 uv){\n    float a = circle(uv, 0.2, 4.5, 0.1, 12.2, 0.0);\n    float b = circle(uv, 0.4, 3.5, 0.732, 9.2, 1.0);\n    float c = circle(uv, 0.6, 2.5, 0.437, 5.2, 0.0);\n    float d = circle(uv, 0.9, 1.5, 0.333, 3.2, 1.0);\n\n    return a+b+c+d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // sample the previous buffer, shifting the coordinates\n    // using noise\n\tvec2 st = fragCoord.xy / iResolution.xy;\n\tfloat mag_time = iTime * 0.4;\n\tfloat rx = st.x *= (0.99 + (fnoise(mag_time) * 0.02));\n\tfloat ry = st.y *= (0.99 + (fnoise(mag_time+0.3) * 0.02));\n    \n\tvec4 old = texture(iChannel1, vec2(rx,ry));    \n    // decrease, so that it will tend to disappear\n\told*= 0.96;\n\n    // draw circles, with pivot in the center of the screen.\n    vec2 uv =  (2. * fragCoord.xy - iResolution.xy ) / iResolution.y;\n    vec4 new = vec4(vec3(circles(uv)), 1.0);\n \n    fragColor = new+old;\n}","name":"Buffer A","description":"","type":"buffer"}]}