{"ver":"0.1","info":{"id":"Xsycz3","date":"1522722896","viewed":194,"name":"Sphere Cube Morphing","username":"nawafuji","description":"morphing sphere and cub","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Sebastien Durand - 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define U(a,b) (a.x*b.y-b.x*a.y)\n\nconst float PI = 3.14159265359;\nconst float ONE_OVER_PI = 1.0/PI;\n\n// rolled brass\n/*\nconst vec2 lo = vec2(0.100, 0.330);\nconst vec2 alpha= vec2(0.050, 0.160);\nconst vec3 Scale = vec3(1.0, 1.0, 1.0);\nvec3 surfaceColor = vec3(1.0,0.62,0.31);\n*/\n\n// semi-gloss paint, rolled\n\nconst vec2 lo = vec2(0.450, 0.048);\nconst vec2 alpha = vec2(0.045, 0.068);\nconst vec3 Scale = vec3(1.0, 20.0, 10.0);\nvec3 surfaceColor = vec3(0.45,0.54,1.0);\n\n\n// lightly brushed aluminum\n/*\nconst vec2 lo = vec2(0.150, 0.190);\nconst vec2 alpha = vec2(0.088, 0.130);\nconst vec3 Scale = vec3(2.0, 2.0, 2.0);\nvec3 surfaceColor = vec3(1.0,0.99,1.0);\n*/\n\n// white ceramic tile\n/*\nconst vec2 lo = vec2(0.700, 0.050);\nconst vec2 alpha = vec2(0.071, 0.071);\nconst vec3 Scale = vec3(1.0, 10.0, 10.0);\nvec3 surfaceColor = vec3(1.0,1.0,1.0);\n*/\n\nvec2 A[15];\nvec2 T1[5];\nvec2 T2[5];\n\nconst vec3 L = normalize(vec3(1,.72, 1)), Y = vec3(0,1,0), E = Y*.01;\n\nfloat tMorph;\nmat2 mat2Rot;\n\n// Distance to Bezier\n// inspired by [iq:https://www.shadertoy.com/view/ldj3Wh]\n// calculate distance to 2D bezier curve on xy but without forgeting the z component of p\n// total distance is corrected using pytagore just before return\nvec2 B(vec2 m, vec2 n, vec2 o, vec3 p) {\n\tvec2 q = p.xy;\n\tm-= q; n-= q; o-= q;\n\tfloat x = U(m, o), y = 2. * U(n, m), z = 2. * U(o, n);\n\tvec2 i = o - m, j = o - n, k = n - m, \n\t\t s = 2. * (x * i + y * j + z * k), \n\t\t r = m + (y * z - x * x) * vec2(s.y, -s.x) / dot(s, s);\n\tfloat t = clamp((U(r, i) + 2. * U(k, r)) / (x + x + y + z), 0.,1.); // parametric position on curve\n\tr = m + t * (k + k + t * (j - k)); // distance on 2D xy space\n\treturn vec2(sqrt(dot(r, r) + p.z * p.z), t); // distance on 3D space\n}\n\n            \n\nfloat smin(float a, float b, float k){\n    float h = clamp(.5+.5*(b-a)/k, 0., 1.);\n    return mix(b,a,h)-k*h*(1.-h);\n}\n\n\n//#define METHOD_2\n\nvoid basis(in vec3 n, out vec3 xp, out vec3 yp)\n{\n#if defined(METHOD_2)\n  // method 2a variant\n  float sz = n.z >= 0.0 ? 1.0 : -1.0;\n  float a  =  n.y/(1.0+abs(n.z));\n  float b  =  n.y*a;\n  float c  = -n.x*a;\n    \n  xp = vec3(n.z+sz*b, sz*c, -n.x);\n  yp = vec3(c, 1.0-b, -sz*n.y);\n#else\n    \n  // method 1: ignoring n approaching -z\n#if 1\n  float a =  n.y/(1.0+n.z);\n  float b =  n.y*a;\n  float c = -n.x*a;\n    \n  xp = vec3(n.z+b, c, -n.x);\n  yp = vec3(c, 1.0-b, -n.y);\n    \n#else\n    \n  // nimitz's impl of frisvad\n  float a = 1./(1. + n.z);\n  float b = -n.x*n.y*a;\n  xp = vec3(1. - n.x*n.x*a, b, -n.x);\n  yp = vec3(b, 1. - n.y*n.y*a , -n.y);\n#endif\n#endif\n}\n\nvec3 computeLambert(vec3 p, vec3 n, vec3 l, vec3 e, vec3 h, vec3 surfaceColor, vec3 lightColor){\n \n    vec3 lightVector = l;\n    vec3 eyeVector = e;\n    vec3 halfVector = h;\n    \n    float nDotLV = max(0.0, dot(lightVector, n));\n    float nDotHV = max(0.0, dot(halfVector, n));\n  \n    float attenuation = 1.0;\n    float shininess = 10.0;\n    float pf;\n    if(nDotLV == 0.0)\n        pf = 0.0;\n \telse\n        pf = pow(nDotHV, shininess);\n    \n    vec3 ambient = vec3(0.1) * attenuation;\n    vec3 diffuse = vec3(1.0,1.0,1.0) * nDotLV * attenuation;\n    vec3 specular = vec3(1.0,1.0,1.0) * pf * attenuation*1.0;\n    return min(((ambient + diffuse)*surfaceColor + specular * vec3(1.0)) * lightColor, vec3(1.0));\n}\n\nvec3 computeBRDF(vec3 n, vec3 l, vec3 h, vec3 r, vec3 t, vec3 b, vec2 p, vec2 a, vec3 s, vec3 color){\n    \n    float e1, e2, E, cosThetaI, cosThetaR, brdf, intensity;\n    \n    e1 = dot(h,t)/a.x;\n    e2 = dot(h,b)/a.y;\n    E = -2.0*((e1*e1+e2*e2)/(1.0+dot(h,n)));\n    \n    cosThetaI = dot(n,l);\n    cosThetaR = dot(n,r);\n    \n    brdf = p.x * ONE_OVER_PI + p.y * (1.0 / sqrt(cosThetaI * cosThetaR)) * ( 1.0 / (4.0 * PI * a.x * a.y)) * exp(E);\n    \n    intensity = s[0] * p.x * ONE_OVER_PI + s[1] * p.y * cosThetaI * brdf + s[2] * dot(h,n) * p.y;\n    return intensity * color;\n}   \n\nfloat cube(vec3 p){\n    float s = 1.0;\n    vec3 d = abs(p) - vec3(s);\n    return min(max(d.x, max(d.y,d.z)), 0.0)\n        + length(max(d,0.0));\n}\n\nfloat sphere(vec3 p){\n    return length(vec3(0.0) - p) - 1.0;\n}\n\nfloat teapot(vec3 p){\n    \n// Distance to Teapot --------------------------------------------------- \n\t// precalcul first part of teapot spout\n\tvec2 h = B(T1[2],T1[3],T1[4], p);\n\tfloat a = 99., \n    // distance to teapot handle (-.06 => make the thickness) \n\t\tb = min(min(B(T2[0],T2[1],T2[2], p).x, B(T2[2],T2[3],T2[4], p).x) - .06, \n    // max p.y-.9 => cut the end of the spout \n                max(p.y - .9,\n    // distance to second part of teapot spout (abs(dist,r1)-dr) => enable to make the spout hole \n                    min(abs(B(T1[0],T1[1],T1[2], p).x - .07) - .01, \n    // distance to first part of teapot spout (tickness incrase with pos on curve) \n                        h.x * (1. - .75 * h.y) - .08)));\n\t\n    // distance to teapot body => use rotation symetry to simplify calculation to a distance to 2D bezier curve\n    vec3 qq= vec3(sqrt(dot(p,p)-p.y*p.y), p.y, 0);\n    // the substraction of .015 enable to generate a small thickness arround bezier to help convergance\n    // the .8 factor help convergance  \n\tfor(int i=0;i<13;i+=2) \n\t\ta = min(a, (B(A[i], A[i + 1], A[i + 2], qq).x - .015) * .7); \n    // smooth minimum to improve quality at junction of handle and spout to the body\n\tfloat dTeapot = smin(a,b,.02);\n    return dTeapot;\n}\n\n// Distance to scene\nfloat M(vec3 p) {\n\n    //float dTeapot = teapot(p);\n    float dSphere = sphere(p);\n    \n    float dCube = cube(p);\n\t// !!! The morphing is here !!!\n    return mix(dCube, dSphere, abs(sin(iTime)));\n}\n\n// HSV to RGB conversion \n// [iq: https://www.shadertoy.com/view/MsS3Wc]\nvec3 hsv2rgb_smooth(float x, float y, float z) {\n    vec3 rgb = clamp( abs(mod(x*6.+vec3(0.,4.,2.),6.)-3.)-1., 0., 1.);\n\trgb = rgb*rgb*(3.-2.*rgb); // cubic smoothing\t\n\treturn z * mix( vec3(1), rgb, y);\n}\n\nvec3 normal(in vec3 p, in vec3 ray, in float t) {\n\tfloat pitch = .4 * t / iResolution.x;\n\t\n    vec2 d = vec2(-1,1) * pitch;\n    \n\tvec3 p0 = p+d.xxx; // tetrahedral offsets\n\tvec3 p1 = p+d.xyy;\n\tvec3 p2 = p+d.yxy;\n\tvec3 p3 = p+d.yyx;\n\t\n\tfloat f0 = M(p0);\n\tfloat f1 = M(p1);\n\tfloat f2 = M(p2);\n\tfloat f3 = M(p3);\n\t\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - p*(f0+f1+f2+f3);\n\t//return normalize(grad);\t// prevent normals pointing away from camera (caused by precision errors)\n\treturn normalize(grad - max(.0,dot (grad,ray ))*ray);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat aa=3.14159/4.;\n\tmat2Rot = mat2(cos(aa),sin(aa),-sin(aa),cos(aa));\n\t\n\t// Teapot body profil (8 quadratic curves) \n\tA[0]=vec2(0,0);A[1]=vec2(.64,0);A[2]=vec2(.64,.03);A[3]=vec2(.8,.12);A[4]=vec2(.8,.3);A[5]=vec2(.8,.48);A[6]=vec2(.64,.9);A[7]=vec2(.6,.93);\n    A[8]=vec2(.56,.9);A[9]=vec2(.56,.96);A[10]=vec2(.12,1.02);A[11]=vec2(0,1.05);A[12]=vec2(.16,1.14);A[13]=vec2(.2,1.2);A[14]=vec2(0,1.2);\n\t// Teapot spout (2 quadratic curves)\n\tT1[0]=vec2(1.16, .96);T1[1]=vec2(1.04, .9);T1[2]=vec2(1,.72);T1[3]=vec2(.92, .48);T1[4]=vec2(.72, .42);\n\t// Teapot handle (2 quadratic curves)\n\tT2[0]=vec2(-.6, .78);T2[1]=vec2(-1.16, .84);T2[2]=vec2(-1.16,.63);T2[3]=vec2(-1.2, .42);;T2[4]=vec2(-.72, .24);\n\n\t// Configure camera\n\tvec2 r = iResolution.xy, m = iMouse.xy / r,\n\t     q = fragCoord.xy/r.xy, p =q+q-1.;\n\tp.x *= r.x/r.y;\n\tfloat j=.0, s=1., h = .1, t=5.+.2*iTime + 4.*m.x;\n\tvec3 o = 2.9*vec3(cos(t), .7- m.y,sin(t)),\n\t     w = normalize(Y * .4 - o), u = normalize(cross(w, Y)), v = cross(u, w),\n         d = normalize(p.x * u + p.y * v + w+w), n, x;\n\t\t\t\n\t// Ray marching\n\tt=0.;\n    for(int i=0;i<48;i++) { \n\t\tif (h<.0001 || t>4.7) break;\n        t += h = M(o + d*t);\n    }\n    \n\t// Background colour change as teapot complementaries colours (using HSV)\n\tvec3 c = mix(hsv2rgb_smooth( .5+iTime*.02,.35,.4), \n\t\t\t \t hsv2rgb_smooth(-.5+iTime*.02,.35,.7), q.y);\n\t\t\n    // Calculate color on point\n\tif (h < .001) {\n\t\tx = o + t * d;\n\t\tn = normal(x,d,t);//normalize(vec3(M(x+E.yxx)-M(x-E.yxx),M(x+E)-M(x-E),M(x+E.xxy)-M(x-E.xxy)));\n\n        vec3 N = n;\n        vec3 V = normalize(o-x);\n        vec3 H = normalize(L+V);\n        vec3 R = normalize(reflect(-L, N));\n        \n        vec3 T;\n        vec3 B;\n        \n        basis(N,T,B);\n       // vec3 T = normalize(vec3(-N.y, N.x, 0));\n        //vec3 B = normalize(cross(N,T));\n        \n            \n        //vec3 pixelColor = computeLambert(x, N, L, V, H, vec3(0,0.0,1.0), vec3(1.0));\n\t\tvec3 pixelColor = computeBRDF(N,L,H,R,T,B,lo,alpha,Scale,surfaceColor);\n        \n\t\t// Calculate Shadows\n\t\tfor(int i=0;i<20;i++){\n\t\t\tj += .02;\n\t\t\ts = min(s, M(x+L*j)/j);\n\t\t}\n\t\t// Teapot color rotation in HSV color space\n\t\tvec3 c1 = hsv2rgb_smooth(.9+iTime*.02, 1.,1.); \n\t\t// Shading\n\t    c = pixelColor;\n        //mix(c,mix(sqrt((clamp(3.*s,0.,1.)+.3)*c1),\n\t\t//\t          vec3(pow(max(dot(reflect(L,n),d),0.),99.)),.4),2.*dot(n,-d));\n\t} \n\n\tc *= pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y), .16); // Vigneting\n\tfragColor=vec4(c,1);\t\n\t\n}","name":"Image","description":"","type":"image"}]}