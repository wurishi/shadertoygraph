{"ver":"0.1","info":{"id":"mdt3Wl","date":"1678077162","viewed":108,"name":"Happy gun","username":"ianertson","description":"A happy gun in a happy rainbow room.\nUse the mouse to look around :)","likes":6,"published":1,"flags":0,"usePreview":1,"tags":["3d","raymarching","raymarch","sdf","colors","gun","weapon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NEAR 0.003\n#define FAR 100.0\n#define STEPS 100\n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_BOX 2\n\n#define ID_GUN 3\n#define ID_GUN_HANDLE 4\n#define ID_GUN_BARREL 5\n#define ID_GUN_BODY 6\n#define ID_GUN_CLUTCH 7\n#define ID_GUN_TRIGGER 8\n#define ID_GUN_AIM 9\n\nfloat rand(in vec2 p, in float seed) {\n    vec2 p2 = (p-(seed*2.29283125))*2.0-1.0;\n    float r1 = fract(dot(p, p2)*3.2928312512);\n    return fract(sin(r1*6.282387812) * dot(p-p2, vec2(32.209328125, 44.92838195)));\n}\n\nvec3 noiseLod(in vec2 p, in float seed, in float lod) { return textureLod(iChannel3, (p+(seed*1.902823812))/256., lod).xyz; }\nvec3 noise(in vec2 p, in float seed) { return textureLod(iChannel3, (p+(seed*1.902823812))/256., 0.0).xyz; }\nvec3 snoise(in vec2 p, in float seed) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p); lv = lv*lv*(3.0-2.0*lv);\n    return mix(mix(noise(id, seed), noise(id + vec2(1, 0), seed), lv.x),\n        mix(noise(id + vec2(0, 1), seed), noise(id + vec2(1, 1), seed), lv.x),\n        lv.y);\n}\n\nvec3 snoiseLod(in vec2 p, in float seed, in float lod) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p); lv = lv*lv*(3.0-2.0*lv);\n    return mix(mix(noiseLod(id, seed, lod), noiseLod(id + vec2(1, 0), seed, lod), lv.x),\n        mix(noiseLod(id + vec2(0, 1), seed, lod), noiseLod(id + vec2(1, 1), seed, lod), lv.x),\n        lv.y);\n}\n\nvec3 snoise(in vec2 p, in float seed, in float freq, in int levels) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    \n    for (int i = 0; i < levels; i++) {\n        n += amp * snoise(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    }\n    \n    return n / div;\n}\n\nvec3 snoiseLod(in vec2 p, in float seed, in float freq, in float lod, in int levels) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    \n    for (int i = 0; i < levels; i++) {\n        n += amp * snoiseLod(p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0; lod /= 2.0;\n    }\n    \n    return n / div;\n}\n\nfloat sphereSDF(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat torusSDF(in vec3 p, in float r1, float r2) {\n    p = p.yzx;\n    float ll = length(p.yz)-r1;\n    return length(vec2(ll,p.x))-r2;\n}\n\nfloat cylSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    vec3 c = a + t * ab;\n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    return e + i;\n}\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat groundSDF(in vec3 p) {\n    return p.y;\n}\n\nfloat gunSDF(in vec3 point, in int skip, inout int id) {\n    id = ID_GUN;\n    float dist = FAR;\n    float handle = FAR;\n    float body = FAR;\n    float barrel = FAR;\n    float barrelInside = FAR;\n    float barrelInside2 = FAR;\n    float clutch = FAR;\n    float trigger = FAR;\n    float triggerHole = FAR;\n    float aim = FAR;\n    Object o = NEW_OBJECT;\n    const float scale = 1.;\n    \n    float handleY = 0.21*scale;\n    float handleZ = 0.15*scale;\n    \n    {\n        vec3 p = point;\n        \n        float sizeX = 0.06 * scale;\n        float sizeY = handleY;\n        float sizeZ = handleZ;\n        \n        float z2 = sizeZ + max(0.0, \n        \n        \n        exp(cos(max(0.0, 0.6+sclamp(p.y, 0.0, 0.4, 0.1)*16.))*0.1)-1.)\n        \n        *smoothstep(0.0, 1.0, max(0.0, p.z+(0.5*scale)));\n        \n        sizeZ += smoothstep(0.02, 1.6, abs(p.y-0.25)+max(0.0, -(p.z+0.16)));\n        sizeZ = mix(sizeZ, z2, 0.25);\n        \n        handle = boxSDF(p - vec3(0, sizeY, 0.0), vec3(sizeX, sizeY, sizeZ));\n        handle += smoothstep(0.0, 1.0, max(0.0, -p.z))*smoothstep(0.0, 1.0, max(0.0, p.y+0.3));\n        handle -= 0.009;\n        handle /= 2.0;\n    }\n    \n    float bodyZ = 0.3 * scale;\n    float bodyY = 0.14 * scale;\n    vec3 bodyPos = vec3(0, bodyY+handleY*2., (bodyZ-handleZ)+0.06);\n    \n    {\n        vec3 p = point;\n        \n        \n        float sizeX = 0.06 * scale;\n        float sizeY = bodyY;\n        float sizeZ = bodyZ;\n        \n        //sizeY -= smoothstep(0.0, 0.5, max(0.0, -p.z)*max(0.0, p.y));\n        \n        body = boxSDF(p - bodyPos, vec3(sizeX, sizeY, sizeZ));\n        body += smoothstep(0.0, 0.6*scale, max(0.0, (-p.y+(0.6*scale))*max(0.0, p.z)));\n        body += smoothstep(0.0, 1.0, max(0.0, (-p.y)+0.6))*smoothstep(0.21, 0.3, max(0.0, p.z+0.01));\n        body += 0.05*smoothstep(0.0, 0.3, max(0.0, p.y-0.6)*max(0.0, -p.z+0.9));\n        \n        float clutchHole = sphereSDF(p - (bodyPos + vec3(0.0, 0.1*scale, -0.34*scale)), 0.16*scale);\n        body = smax(body-0.01, -clutchHole, 0.05);\n        \n        float ss = smoothstep(0.09, 0.9, max(0.0, -p.y+0.5));\n        triggerHole = torusSDF((p.yxz) - ((vec3(-0.0,(bodyPos.y-0.1)+ss, 0.3).yxz)), 0.1, 0.02);\n        \n       // body = smax(body, - triggerHole, 0.01);\n    }\n    \n    {\n        vec3 p = point;\n        \n        \n        float len = 0.8 * scale;\n        float r = 0.05 * scale;\n        \n        barrel = cylSDF(p - vec3(0, bodyPos.y+r+0.04, (bodyZ-handleZ)+r), vec3(0, 0, 0), vec3(0, 0, len), r);\n        barrelInside = cylSDF(p - vec3(0, bodyPos.y+r+0.04, (bodyZ-handleZ)+r+0.1), vec3(0, 0, 0), vec3(0, 0, len), r*0.7);\n        barrelInside -= 0.002;\n        barrel = smax(barrel, -barrelInside, 0.01);\n        \n        float barrelBot = cylSDF(p - vec3(0, bodyPos.y+r-0.02, (bodyZ-handleZ)+r), vec3(0, 0, 0), vec3(0, 0, len*0.86), r*0.5);\n        barrelInside2 = cylSDF(p - vec3(0, bodyPos.y+r-0.02, (bodyZ-handleZ)+r+0.1), vec3(0, 0, 0), vec3(0, 0, len*0.86), (r*0.5)*0.7);\n\n        barrelBot = max(barrelBot, -barrelInside);\n        barrelBot = max(barrelBot, -barrelInside2);\n        barrel = min(barrel, barrelBot);\n        \n    }\n    \n    {\n        vec3 p = point;\n        float r = 0.04;\n        float len = 0.011;\n        aim = cylSDF(p - vec3(0, bodyPos.y+0.05+(r*2.)+0.01, (bodyZ-handleZ)+(0.8-(len/2.))), vec3(0, 0, 0), vec3(len, 0, 0), r);\n        aim += smoothstep(0.0, 0.5, max(0.0, p.y-0.68)) * smoothstep(0.95, 1.01, max(0.0, 1.0-(p.z-0.93)));//clamp(1.0-(p.z-0.93), 0.0, 1.0);//loat(p.z < 0.93);\n        aim /= 1.2;\n        aim = max(aim, -barrelInside);\n    }\n    \n    {\n        vec3 p = point;\n        \n        \n        float len = 0.16 * scale;\n        float r = 0.03 * scale;\n        \n        p.x *= (1.0+(0.7*smoothstep(0.0, 0.1, max(0.0, (-p.z)))));\n        vec3 dir = normalize(vec3(0, 1, -4.));\n        dir = normalize(mix(dir, normalize(vec3(0, -0.1, -0.3)), smoothstep(0.0, 1.0, max(0.0, p.z+0.5))));\n        r /= (1.0+(0.5*smoothstep(0.0, 0.1, max(0.0, (-p.z)))));\n        p += dir*0.1*scale;\n        p.z -= 0.08*scale;\n        p.y -= 0.02*scale;\n        \n        clutch = cylSDF(p - vec3(0, bodyPos.y+r, (-bodyZ)+len), vec3(0, 0, 0), dir*len, r)-0.001;\n        clutch = clutch / 1.5;\n    }\n    \n    {\n        vec3 p = point;\n        float r = 0.012;\n        r -= smoothstep(0.01, 0.99, max(0.0, -p.y+0.45));\n        vec3 dir = vec3(0, 1, 0);\n        dir = mix(dir, vec3(0.0, 0.4, -1.), smoothstep(0.1, 1., max(0.0, -p.y+0.8)));\n        dir = normalize(dir);\n        float len = 0.14;\n        trigger = cylSDF(p - vec3(0.0, bodyPos.y-0.15, 0.323), vec3(0, 0, 0), dir*len, r);\n    }\n    \n    body = max(body, -barrelInside);\n    \n    int pid = body < handle ? ID_GUN_BODY : ID_GUN_HANDLE;\n    \n    body = (skip == ID_GUN_BODY || skip == ID_GUN_HANDLE) ? FAR : smin(body, handle, 0.4*smoothstep(0.0, 1.5, max(0.0, point.y)));\n    handle = skip == ID_GUN_HANDLE ? FAR : handle;\n    body = skip == ID_GUN_BODY ? FAR : body;\n\n    SAMPLE(trigger, o, ID_GUN_TRIGGER);\n    SAMPLE(clutch, o, ID_GUN_CLUTCH);\n    SAMPLE(barrel, o, ID_GUN_BARREL);\n    SAMPLE(aim, o, ID_GUN_AIM);\n    SAMPLE(body, o, pid);\n    SAMPLE(handle, o, pid);\n    SAMPLE(triggerHole, o, ID_GUN_TRIGGER);\n    \n    \n    return dist;\n}\n\nfloat sdf(inout Data data, in vec3 p) {\n    int skip = data.skip;\n    int id = 0;\n    Object o = NEW_OBJECT;\n    float dist = FAR;\n    \n    \n    float box = boxSDF(p - vec3(0, -1., 0), vec3(1.0));\n    float ground = groundSDF(p);\n    \n    SAMPLE(box, o, ID_BOX);\n    //SAMPLE(ground, o, ID_GROUND);\n    \n    int gunId = 0;\n    float gun = gunSDF(p - vec3(0, 0.001, 0), skip, gunId);\n    \n    SAMPLE(gun, o, gunId);\n    \n    data.id = id;\n\n    return dist;\n}\n\nbool march(inout Data data, in vec3 ro, in vec3 rd) {\n    float d = 0.0;\n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        d += next;\n        if (abs(next) <= NEAR) break;\n        if (abs(next) >= FAR) return false;\n    }\n    vec3 p = ro+rd*d;\n    vec2 e = vec2(0.001, 0.0);\n    vec3 n = normalize(sdf(data, p) - vec3(\n        sdf(data, p - e.xyy),\n        sdf(data, p - e.yxy),\n        sdf(data, p - e.yyx)\n    ));\n    vec2 uv = boxUv(p, n);\n    data.d = d;\n    data.p = p;\n    data.n = n;\n    data.uv = uv;\n    return true;\n}\n\nfloat getShadow(in int skip, in vec3 ro, in vec3 rd, in float far) {\n    Data data = NEW_DATA;\n    data.skip = skip;\n    float d = 0.0;\n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        d += next;\n        if (abs(next) <= NEAR) break;\n        if (abs(next) >= far) return 1.0;\n    }\n    return clamp(d/(1.0+d), AMBIENT, 1.0);\n}\n\n\n//#define DEBUG_TEXTURE woodTexture\n\nvec3 woodTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = rgb(142, 107, 86);\n    vec3 c2 = rgb(111, 81, 81);\n    vec3 c3 = rgb(171, 95, 57);\n    vec3 c4 = rgb(219, 171, 123);\n    \n    vec3 hf1 = snoiseLod(uv, 0.02312512, 125.0, 0.5, 6);\n    vec3 lf1 = snoiseLod(uv*0.5, 2.29392915, 2.5, 0.5, 3);\n    \n    vec3 woodCol = mix(mix(mix(c1, c2, hf1.x), c3, hf1.y), c4, hf1.z);\n    \n    col += woodCol;\n    \n    float tile = 2.0;\n    \n    vec2 id = floor(uv*tile);\n    vec2 lv = fract(uv*tile);\n    vec2 slv = lv*lv*(3.0-2.0*lv);\n    vec2 alv = abs(lv*2.0-1.0);\n    vec2 salv = abs(slv*2.0-1.0);\n    \n    float seed = 1.929195912;\n    float ra = mix(\n        mix(rand(id, seed), rand(id+vec2(1, 0), seed), slv.x),\n        mix(rand(id + vec2(0, 1), seed), rand(id+vec2(1, 1), seed), slv.x),\n        slv.y\n    );\n    \n    float stripes = exp(cos(length(salv-(hf1.x*0.15))*TAU*TAU*ra) -1.);\n    \n    float stripes2 = exp((sin(((uv.y*TAU*ra) - cos(uv.x*TAU-uv.y*ra))*TAU) * cos(((uv.x*TAU*ra) - sin(uv.y*TAU-uv.x*ra)) * TAU))-1.);\n    stripes = mix(stripes*hf1.y*lf1.x, stripes2, lf1.z);\n    stripes *= ra;\n    stripes = pow(stripes, 2.);\n    col = mix(col, col*col, clamp(stripes*2., 0.0, 1.0));\n    \n    vec3 grain = textureLod(iChannel3, uv, 0.0).xyz;\n    \n    col = mix(col, col*col, grain.x*hf1.y);\n    \n    m.spec = clamp((stripes+stripes2)*hf1.y, grain.z*grain.x, 1.0);\n    \n    return col;\n}\n\nvec3 metalTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 m1 = rgb(104, 120, 142);\n    vec3 m2 = rgb(136, 136, 136);\n    vec3 m3 = rgb(96, 90, 91);\n    vec3 m4 = rgb(60, 56, 61);\n    vec3 m5 = rgb(166, 150, 131);\n    \n    vec3 hf1 = snoiseLod(uv, 0.32912254, 64.0, 1.5, 4);\n    vec3 hf2 = snoiseLod(uv, 9.38281256, 24.0, 0.5, 6);\n    \n    vec3 lf1 = snoiseLod(uv, 12.9992838125, 2.5, 0.3, 4);\n    vec3 lf2 = snoiseLod(uv+(lf1.xz*0.05), 3.2918245123+(hf2.y*0.09), 9.5, 0.6, 4);\n    \n    vec3 metCol = mix(mix(mix(m1, m2, hf1.x), m3, hf1.y), m4, hf1.z);\n    col += metCol;\n    \n    float scratches = abs(hf2.x*2.0-1.0);\n    float scratches2  = max(0.0, 1.0-smoothstep(0.02, 0.025, scratches));\n    scratches = max(0.0, 1.0-smoothstep(0.02, 0.06, scratches));\n    \n\n    col = mix(col, m5, scratches*smoothstep(0.5, 1.0, lf1.x)*scratches);\n    col = mix(col, m4*m4, scratches2*smoothstep(0.5, 1.0, clamp((lf1.x+lf1.y)/1.6, 0.0, 1.0)));\n    \n    vec3 grain = textureLod(iChannel3, uv, 0.0).xyz;\n    col = mix(col, col*col, grain.x*lf1.z);\n    float spots = smoothstep(0.3, 1.0, lf2.x*grain.z);\n    float spots2 = smoothstep(0.3, 1.0, lf2.y);\n    col = mix(col, vec3(1.0), spots);\n    col = mix(col, col*col, spots2);\n    \n    m.spec = clamp((lf1.y*hf1.y)*max(0.0, 1.0-scratches2), clamp((scratches*hf2.z)+spots, 0.0, 1.0), 1.0);\n    \n   \n    m.rough = clamp(scratches+scratches2, grain.x*0.1, 1.0);\n    m.metallic = lf1.x;\n    \n    return col;\n}\n\nvec3 metalTexture2(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 m1 = rgb(104, 120, 142);\n    vec3 m2 = rgb(136, 136, 136);\n    vec3 m3 = rgb(96, 90, 91);\n    vec3 m4 = rgb(60, 56, 61);\n    vec3 m5 = rgb(166, 150, 131);\n    \n    vec3 hf1 = snoiseLod(uv, 0.32912254, 64.0, 1.5, 4);\n    vec3 hf2 = snoiseLod(uv, 9.38281256, 24.0, 0.5, 6);\n    \n    vec3 lf1 = snoiseLod(uv, 12.9992838125, 2.5, 0.3, 4);\n    vec3 lf2 = snoiseLod(uv+(lf1.xz*0.05), 3.2918245123+(hf2.y*0.09), 9.5, 0.6, 4);\n    \n    vec3 metCol = mix(mix(mix(m1, m2, hf1.x), m3, hf1.y), m4, hf1.z);\n    col += metCol;\n    \n    float scratches = abs(hf2.x*2.0-1.0);\n    float scratches2  = max(0.0, 1.0-smoothstep(0.02, 0.025, scratches));\n    scratches = max(0.0, 1.0-smoothstep(0.02, 0.06, scratches));\n    \n\n    col = mix(col, m5, scratches*smoothstep(0.5, 1.0, lf1.x)*scratches);\n    col = mix(col, m4*m4, scratches2*smoothstep(0.5, 1.0, clamp((lf1.x+lf1.y)/1.6, 0.0, 1.0)));\n    \n    vec3 grain = textureLod(iChannel3, uv, 0.0).xyz;\n    col = mix(col, col*col, grain.x*lf1.z);\n    float spots = smoothstep(0.3, 1.0, lf2.x*grain.z);\n    float spots2 = smoothstep(0.3, 1.0, lf2.y);\n    col = mix(col, vec3(1.0), spots);\n    col = mix(col, col*col, spots2);\n    \n    m.spec = clamp((lf1.y*hf1.y)*max(0.0, 1.0-scratches2), clamp((scratches*hf2.z)+spots, 0.0, 1.0), 1.0);\n    \n    m.metallic = 1.0;\n    m.rough = clamp(scratches+scratches2, (hf1.x+grain.z)/1.5, 1.0);\n    \n    return col;\n}\nvec3 getAlbedoGround(inout Data data) {\n    vec2 uv = data.p.xz;\n    return vec3(1.0);//snoise(uv, 2.392291255);\n}\n\nvec3 getAlbedoBox(inout Data data) {\n    vec2 uv = data.uv;\n    vec3 col = snoise(uv, 0.239812124);\n    data.m.rough = 0.5;\n    data.m.metallic = 1.;\n    return col;\n}\n\nvec3 getAlbedoGunBarrel(inout Data data) {\n    vec2 uv = data.uv*2.;\n    vec3 p = data.p;\n    vec3 n = data.n;\n    \n    vec3 col = metalTexture(uv, p, data.m);\n    col = mix(col, col*col, 0.5);\n    \n    return col;\n}\n\nvec3 getAlbedoGunHandle(inout Data data) {\n    vec2 uv = data.uv;\n    vec3 p = data.p;\n    vec3 n = data.n;\n    \n    vec3 col = woodTexture(uv, p, data.m);\n    \n    float e = 0.001;\n    vec3 bump = fixNormal(n, normalize(luma(col) - vec3(\n        luma(woodTexture(uv + vec2(e, 0), p, data.m)),\n        luma(woodTexture(uv + vec2(0, e), p, data.m)),\n        0.5\n    )), 0.1, 0.6);\n    data.n = bump;\n    \n    return col;\n}\n\nvec3 getAlbedoGunBody(inout Data data) {\n    vec2 uv = data.uv;\n    vec3 p = data.p;\n    vec3 n = data.n;\n    \n    vec3 col = metalTexture2(uv, p, data.m);\n    \n    float e = 0.003;\n    vec3 bump = fixNormal(n, normalize(luma(col) - vec3(\n        luma(metalTexture2(uv + vec2(e, 0), p, data.m)),\n        luma(metalTexture2(uv + vec2(0, e), p, data.m)),\n        0.5\n    )), 0.1, 0.6);\n    \n    data.n = bump;\n    \n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_GROUND: return getAlbedoGround(data); break;\n        case ID_BOX: return getAlbedoBox(data); break;\n        case ID_GUN_BARREL: return getAlbedoGunBarrel(data); break;\n        case ID_GUN_TRIGGER: return getAlbedoGunBarrel(data); break;\n        case ID_GUN_CLUTCH: return getAlbedoGunBarrel(data); break;\n        case ID_GUN_AIM: return getAlbedoGunBarrel(data); break;\n        case ID_GUN_HANDLE: return getAlbedoGunHandle(data); break;\n        case ID_GUN_BODY: return getAlbedoGunBody(data); break;\n    }\n    \n    return vec3(0.77);\n}\n\nvec3 forEachLight(inout Data data, in Light light, in vec3 diffuse, in vec3 ro, in vec3 rd) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 L = getLightDir(light, p);\n    vec3 ref = reflect(L, n);\n    float VdotR = cdot(rd, ref);\n    float spec = data.m.spec * pow(VdotR, 64.);\n    vec3 att = getLightAtt(light, p, n);\n    int skip = data.id;\n    float shadow = getShadow(skip, p+(n*NEAR*2.), L, light.type == LIGHT_AMBIENT ? FAR : \n        distance(light.p, p));\n        \n    return (diffuse + spec) * att * shadow;\n}\n\n#define NUM_LIGHTS 1\n\nvec3 getSky(in vec3 rd) {\n    vec3 n = texNoise(iChannel3, rd, 3.0, 0.329124, vec2(0.0));\n    return n;\n    //return texture(iChannel2, rd).xyz;\n}\n\nvec3 render(inout Data data, in vec3 ro, in vec3 rd) {\n    vec3 col = vec3(0.0);\n    \n    Light light = Light(vec3(1, 2, -3), vec3(0.0), vec3(0.97, 0.71, 0.69), 2.0, LIGHT_AMBIENT);\n    \n    float dist = FAR;\n    vec3 mixf = vec3(1.0);\n    vec3 p = vec3(0.0);\n    for (int j = 0; j < 2; j++) {\n        if (march(data, ro, rd)) {\n            if (j <= 0) {\n                dist = data.d;\n                p = data.p;\n            }\n            vec3 on = data.n;\n            vec3 albedo = getAlbedo(data);\n            vec3 diffuse = albedo / M_PI;\n            col += forEachLight(data, light, diffuse, ro, rd)*mixf;\n            \n            float rough = data.m.rough;\n            if (rough >= 0.9999) break;\n            \n            vec3 n = normalize(mix(on, data.n, rough));//data.n;\n            vec3 p = data.p;\n            float metallic = data.m.metallic;\n            \n            float NdotV = dot(n, -rd);\n            rd = reflect(rd, n);\n            ro = p+(n*NEAR*2.);\n            \n            \n            vec3 f0 = mix(vec3(0.04), diffuse, metallic);\n            vec3 F = fresnelSchlickRoughness(NdotV, f0, rough*rough);\n            mixf = F;\n            \n        } else {\n            col += getSky(rd)*mixf;\n            break;\n        }\n    }\n    \n    float depth = dist / FAR;\n    \n    return col;\n}\n\nvoid getRay(in vec2 uv, in vec4 m, inout vec3 ro, inout vec3 rd) {\n    ro = vec3(0, 0, -1.5);\n    rd = normalize(vec3(uv.xy, 1.0));\n    \n    if (length(m.xy) > 0.001 && m.z > 0.0001) {\n        ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n    \n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n    } else {\n        float time = T*0.5;\n        ro.xz *= rot(time);\n        rd.xz *= rot(time);\n    }\n    \n    float Y = 0.5;\n    ro.y += Y;\n    ro.y = max(Y, ro.y);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y, iMouse.zw);\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    getRay(uv, m, ro, rd);\n    Data data = NEW_DATA;\n    \n    #ifdef DEBUG_TEXTURE\n    Material ma = NEW_MATERIAL;\n    col += DEBUG_TEXTURE(fc.xy/R.xy, ro+rd, ma);\n    #else\n    col += render(data, ro, rd);\n    col += (col*col*luma(col));\n    col /= 1.0 + max(col-0.5, 0.0);\n    col = pow(col, vec3(1.0 / 2.2));\n    #endif\n    \n    \n    O = vec4(clamp(col, 0.0, 1.0), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R (iResolution.xy)\n#define T (iTime+5.529)\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n#define SAMPLE(var, OB, id_) if (skip != id_ && var < dist) { dist = var; id = id_; o =  OB; }\n#define AMBIENT 0.04\nfloat luma(in vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\nstruct Material { float rough; float spec; float metallic; };\n#define NEW_MATERIAL Material(1.0, 1.0, 0.0)\n\nstruct Object { vec3 p; vec3 r; };\n#define NEW_OBJECT Object(vec3(0.0), vec3(0.0))\n\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    vec2 uv;\n    float d;\n    int id;\n    int skip;\n    Material m;\n    Object o;\n};\n\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), vec2(0.0), FAR, 0, 0, NEW_MATERIAL, NEW_OBJECT)\n\nstruct Light {\n    vec3 p;\n    vec3 d;\n    vec3 c;\n    float s;\n    int type;\n};\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n\nvec3 getLightDir(in Light light, in vec3 p) {\n    return light.type == LIGHT_AMBIENT ? normalize(light.p) :\n        light.type == LIGHT_POINT ? normalize(light.p - p) : normalize(light.d);\n}\n\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(AMBIENT, dot(n, L));\n    switch (light.type) {\n        case LIGHT_AMBIENT: return light.c * light.s * NdotL; break;\n        case LIGHT_POINT: return light.c * NdotL * \n            (pow(light.s, 2.0) / max(0.0001, distance(light.p, p))); break;\n        case LIGHT_DIR: return light.c * light.s * smoothstep(0.8, 1.0, dot(\n            normalize(light.p - p),\n            L\n        )); break;\n    }\n    return vec3(0.0);\n}\n\nvec2 boxUv(in vec3 p, in vec3 n) {\n    return mix(mix(p.xy, p.yz, round(adot(n, vec3(1, 0, 0)))), p.xz, round(adot(n, vec3(0, 1, 0))));\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return smin(a, b, -k);\n}\n\nvec3 smin(vec3 a, vec3 b, float k) {\n    vec3 h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nvec3 smax(vec3 a, vec3 b, float k) {\n    return smin(a, b, -k);\n}\n\nfloat sclamp(float v, float mi, float ma, float k) {\n    return smax(mi, smin(ma, v, k), k);\n}\n\nfloat sabs(float a, float k) {\n    return smax(-a, a, k);\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) *\n                  pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\n\nvec3 fixNormal(vec3 wn, vec3 n, float th, float mixf) {\n    vec3 t = cross(wn, vec3(0, 1, 0));\n    vec3 b = vec3(0.0);\n    if (abs(length(t)) == 0.0) t = cross(wn, vec3(0, 0, 1));\n    t = normalize(t);\n    b = normalize(cross(wn, t));\n    mat3 tbn = mat3(t, b, -wn);\n    n = normalize((tbn)*n);\n    return normalize(mix(wn, n, mixf*max(th, dot(wn, n))));\n}\n\nvec3 texHash33(sampler2D ch, vec3 p, float div, float seed, vec2 lod) {\n    return textureLod(ch, (vec2(p.x, p.y) +\n        div*(textureLod(ch, (vec2((p.y*p.z), p.z)+seed)/div, lod.x).xy*2.0-1.0))/div, lod.y).xyz;\n}\n\nvec3 texNoise(sampler2D tex, vec3 p, float seed, vec2 lod) {\n    vec3 id = floor(p);\n    vec3 lv = fract(p);\n    lv = lv * lv * (3.0 - 2.0 * lv);\n\n    float div = vec2(textureSize(tex, 0).xy).y;\n\n    return mix(\n        mix(mix(\n              texHash33(tex, id + vec3(0, 0, 0), div, seed, lod),\n              texHash33(tex, id + vec3(1, 0, 0), div, seed, lod), lv.x),\n          mix(texHash33(tex, id + vec3(0, 1, 0), div, seed, lod),\n              texHash33(tex, id + vec3(1, 1, 0), div, seed, lod), lv.x),\n          lv.y),\n        mix(mix(\n              texHash33(tex, id + vec3(0, 0, 1), div, seed, lod),\n              texHash33(tex, id + vec3(1, 0, 1), div, seed, lod), lv.x),\n          mix(texHash33(tex, id + vec3(0, 1, 1), div, seed, lod),\n              texHash33(tex, id + vec3(1, 1, 1), div, seed, lod), lv.x),\n          lv.y),\n        lv.z\n    );\n}\n\nvec3 texNoise(sampler2D tex, vec3 p, float freq, float seed, vec2 lod) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    n += amp * texNoise(tex, p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0;\n    n += amp * texNoise(tex, p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0;\n    n += amp * texNoise(tex, p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0;\n    n += amp * texNoise(tex, p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0;\n    return n / div;\n}","name":"Common","description":"","type":"common"}]}