{"ver":"0.1","info":{"id":"l3GXWy","date":"1720426979","viewed":56,"name":"Crossing Wormholes","username":"Capo","description":"I used IFS and symmetry, and through color rendering, I obtained the colorful colors of crossing wormholes to pay tribute to Star Trek","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractal","color","ifs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//reference:https://www.shadertoy.com/view/mtyGWy\nprecision highp float;\n#define PI 3.14159265359\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nconst float pi = acos(-1.0);\nconst float pi2 = pi * 2.0;\n\nvec2 pmod(vec2 p, float r) {\n    float a = atan(p.x, p.y) + pi / r;\n    float n = pi2 / r;\n    a = floor(a / n) * n;\n    return p * rot(-a);\n}\n\nfloat box(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat cylinder(vec3 p, float r, float h) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat heart(vec3 p) {\n    float slowTime = iTime * 0.75;\n    p.y -= 0.5 * abs(sin(slowTime));\n    p.xy = abs(p.xy);\n    float k = 2.0 / sqrt(3.0);\n    return p.x * p.x + p.y * p.y - k * p.x * p.y - k * k * p.y * p.y + p.z * p.z - 0.1;\n}\n\nfloat ifsShape(vec3 p) {\n    float d = 1e10;\n    float slowTime = iTime * 0.75; \n    for (int i = 0; i < 5; i++) { \n        p = abs(p) - 1.0;\n        p.xy *= rot(slowTime * 0.3);\n        p.xz *= rot(slowTime * 0.1);\n        p.yz *= rot(slowTime * 0.2); \n        p *= 0.9 + 0.1 * sin(slowTime + float(i));\n        p += vec3(0.5 * sin(slowTime * 0.5), 0.5 * cos(slowTime * 0.3), 0.5 * sin(slowTime * 0.7)); \n\n        p.x += 0.3 * sin(p.y * 3.0 + slowTime);\n        p.y += 0.3 * cos(p.z * 3.0 + slowTime);\n        p.z += 0.3 * sin(p.x * 3.0 + slowTime);\n\n        float dist1 = box(p, vec3(0.4, 0.8, 0.3));\n        float dist2 = sphere(p, 0.5);\n        float dist3 = cylinder(p, 0.3, 0.6);\n        float dist4 = heart(p);\n        float dist5 = length(p) - 0.7; \n\n        d = min(d, min(min(dist1, dist2), min(dist3, dist4)));\n        d = min(d, dist5);\n\n        p = pmod(p.xy, 3.0).xyx; \n        p = abs(p) - 0.5; \n    }\n    p.xz *= rot(slowTime);\n    d = min(d, box(p, vec3(0.4, 0.8, 0.3)));\n    return d;\n}\n\nfloat map(vec3 p, float t) {\n    vec3 p1 = p;\n    p1.x = mod(p1.x - 5.0, 10.0) - 5.0;\n    p1.y = mod(p1.y - 5.0, 10.0) - 5.0;\n    p1.z = mod(p1.z, 16.0) - 8.0;\n    p1.xy = pmod(p1.xy, 5.0);\n    return ifsShape(p1);\n}\n\nvec3 palette(float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 cPos = vec3(0.0, 0.0, -3.0 * iTime * 0.7);\n    vec3 cDir = normalize(vec3(0.0, 0.0, -1.0));\n    vec3 cUp = vec3(sin(iTime * 0.7), 1.0, 0.0); \n    vec3 cSide = cross(cDir, cUp);\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir);\n\n    float acc = 0.0;\n    float acc2 = 0.0;\n    float t = 0.0;\n    for (int i = 0; i <160; i++) {\n        vec3 pos = cPos + ray * t;\n        float dist = map(pos, iTime * 0.7); \n        dist = max(abs(dist), 0.02);\n        float a = exp(-dist * 3.0);\n        if (mod(length(pos) + 24.0 * iTime * 0.75, 30.0) < 3.0) {\n            a *= 2.0;\n            acc2 += a;\n        }\n        acc += a;\n        t += dist * 0.5;\n    }\n\n    vec3 col = vec3(acc * 0.01, acc * 0.011 + acc2 * 0.002, acc * 0.012 + acc2 * 0.005);\n    col = palette(col.x); \n    fragColor = vec4(col, 1.0 - t * 0.03);\n}\n","name":"Image","description":"","type":"image"}]}