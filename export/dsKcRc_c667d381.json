{"ver":"0.1","info":{"id":"dsKcRc","date":"1696419600","viewed":57,"name":"chrysanthemum with 40 leafs","username":"Efim","description":"simple chrysanthemum","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","sphere","plane"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define TAU 6.28318530718\n#define nn 20.\nconst float dist_infin = 1000.0;\n#define AA 3\n\n\nstruct HIT\n{\n    float dist;\n    vec3 nor;\n    vec3 pos;\n};\n\nconst HIT hit_inf = HIT(dist_infin, vec3(0.0), vec3(0.0));\n\n\nvec3 ccolor(vec3 col_in, vec3 backcol, vec3 rd, vec3 light1, vec3 light2, vec3 nor)\n{\n    vec3 col = col_in;\n    float d = dot(rd, nor);\n    if (d < 0.0)\n        col = backcol;\n    \n    nor *= -sign(d);\n    float difu1 = dot(nor, light1);\n    float difu2 = dot(nor, light2);\n    float difu = max(difu1, difu2);\n        col *= clamp(difu, 0.5, 1.0);\n    return col;   \n}\n\nfloat aafi(vec2 p) {\n    float fi = atan(p.y, p.x);\n    fi += step(p.y, 0.0)*TAU;\n    return fi;\n}\n//===================https://www.shadertoy.com/view/wsXGWS======================\nfloat sgn(float x) {\n  return x < 0.0? -1.0: 1.0; // Return 1 for x == 0\n}\n\nint quadratic(float A, float B, float C, out vec2 res) {\n  float x1,x2;\n  float b = -0.5*B;\n  float q = b*b - A*C;\n  if (q < 0.0) return 0;\n  float r = b + sgn(b)*sqrt(q);\n  if (r == 0.0) {\n    x1 = C/A; x2 = -x1;\n  } else {\n    x1 = C/r; x2 = r/A;\n  }\n  res = vec2(x1,x2);\n  return 2;\n}\n\n//https://www.shadertoy.com/view/wsXGWS\n\n\nmat3 rotateX(float f)\n{\n    return mat3(vec3(1.0,    0.0,      0.0), vec3(0.0,\t cos(f),  -sin(f)), \tvec3(.0, sin(f), cos(f)));\n}\n\nmat3 rotateY(float f)\n{\n    return mat3(vec3(cos(f), 0.0,  sin(f)),vec3(0.0,\t 1.0,  0.0),vec3(-sin(f), 0.0, cos(f)));\n}\n\nmat3 rotateZ(float f)\n{\n    return mat3(vec3(cos(f),    -sin(f),  0.0),vec3(sin(f),\t cos(f),  0.0), \tvec3(0.0, 0.0, 1.0));\n}\n\n\n\nfloat plane(vec3 ro, vec3 rd, vec3 po, vec3 nor)\n{\n    float t = dot(nor, (po - ro)) / dot(nor, rd);\n    if (t < 0.)\n        t = dist_infin;\n    return t;\n}\n\n\nHIT grid(vec3 ro, vec3 rd)\n{\n    float dist = dist_infin;\n    vec3 pos = vec3(0.0);\n    vec3 nor = vec3(0.0);\n\n    float a = ro.x;\n    float b = rd.x;\n    float c = ro.y;\n    float d = rd.y;\n    float e = ro.z;\n    float f = rd.z;\n\n    float t = 2.5;\n    float a0 = 1.*a*a + 1.*c*c + 1.*e*e-1.*t*t;\n    float a1 = 2.*a*b + 2.*c*d + 2.*e*f;\n    float a2 = 1.*b*b + 1.*d*d + 1.*f*f;\n\n    vec2 roots = vec2(dist_infin);\n    int nroots = quadratic(a2, a1, a0, roots);  // quartic(a4, a3, a2, a1, a0, roots);\n    for (int i = 0; i < 2; i++)\n    {\n        if (i >= nroots)\n            break;\n        if (roots[i] < 0.0)\n            continue;\n        vec3 p = vec3(a, c, e) + roots[i]*rd;\n        if (roots[i] < dist)    \n        {\n            dist = roots[i];\n            pos = p;\n        }\n\n    }\n    if (dist < dist_infin)\n    {\n        float fi = aafi(pos.xy);\n        float f = fract(fi/TAU * nn);\n        float fn = floor(fi/TAU * nn);\n        \n        if (f < 0.03)\n        {\n            nor = vec3(0.+2.*pos.x, 0.+2.*pos.y, 0.+2.*pos.z);\n            nor = normalize(nor);\n            pos = vec3(0., 0., 1.);\n            // if (mod(fn, 2.0) == 0.)\n            //     pos = vec3(0., 1., 0.);\n            // else    \n            //     pos = vec3(0., 0., 1.);\n\n            return HIT(dist, nor, pos); \n        }\n        \n        else\n        {\n            dist = dist_infin;\n            float tdist = dist;\n            float p1 = fn*TAU/nn;\n            float p2 = fn*TAU/nn + TAU/nn;\n            vec3 po = vec3(0.);\n            vec3 nr = vec3(-sin(p1), cos(p1), 0.);\n            tdist = plane(ro, rd, po, nr);\n            pos = ro + rd*tdist;\n            if (length(pos) > t)\n                tdist = dist_infin;\n            if (tdist < dist && tdist > 0.0)\n            {\n                nor = nr;\n                dist = tdist;\n            }\n           \n            nr = vec3(-sin(p2), cos(p2), 0.);\n            tdist = plane(ro, rd, po, nr);\n            pos = ro + rd*tdist;\n            if (length(pos) > t)\n                tdist = dist_infin;\n            if (tdist < dist && tdist > 0.0)\n            {\n                nor = nr;\n                dist = tdist;\n            }\n\n            if (dist < dist_infin)\n            {\n                pos = vec3(1., 1., 0.);\n                return HIT(dist, nor, pos);\n            }\n        }\n        \n    }\n\n\n    return hit_inf;\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 light = normalize(vec3(5.0, 5.0, 0.0)); //light\n    vec3 light2 = -light;\n    float t = iTime/2.0;\n    vec2 m = vec2(0.0, 0.0);\n    if  (iMouse.z > 0.0)\n    {\n       m = (-iResolution.xy + 2.0*(iMouse.xy))/iResolution.y;\n       //t = 0.;\n    }\n    vec3 ro = vec3(0.0, -3., 5.); // camera\n    const float fl = 1.5; // focal length\n    \n    ro = rotateY(-m.x*TAU)*rotateX(-m.y*PI)*ro; //camera rotation\n    mat3 rota  = rotateZ(t);\n    mat3 rota_1  = rotateZ(-t);\n    vec3 tot = vec3(0.0);\n    \n    //antiblick\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        float dist = dist_infin;\n        vec3 col = vec3(0.7, 0.7, 0.9); // background    \n            // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        vec3 rd = GetRayDir(p, ro, vec3(0,0.,0), fl); //ray direction\n        HIT gr = grid(rota*ro, rota*rd);\n        if (gr.dist < dist)\n        {\n            col = gr.pos;//vec3(0.5, 0.5, 1.0);\n            vec3 backcol = col;//vec3(1.0, 0.2, 0.2);\n            vec3 nor = rota_1*gr.nor;\n            col = ccolor(col, backcol, -rd, light, light2, nor);\n        }\n        tot += col;\n    }\n\n    //antiblick\n    tot /= float(AA*AA);\n    fragColor = vec4(tot,1.0);\n    \n}","name":"Image","description":"","type":"image"}]}