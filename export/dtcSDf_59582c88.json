{"ver":"0.1","info":{"id":"dtcSDf","date":"1685816151","viewed":52,"name":"Fork Montecarlo knighty 621","username":"knighty","description":"Other ways to deal with epsilon near boundaries. I don't think this is very useful but maybe good to know.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["2d","montecarlo","pde"],"hasliked":0,"parentid":"WsXBzl","parentname":"Montecarlo PDE (1)"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Playing with Keenan Crane's latest paper in collab with\n// Rohan Sawhney: http://www.cs.cmu.edu/~kmcrane/Projects/MonteCarloGeometryProcessing/paper.pdf[/url]\n//\n// See https://www.shadertoy.com/view/WdXfzl for a more complex example\n\n//This fork is to show two other simple ways to deal with the epsilon thing near the boundary.\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = texelFetch(iChannel0,ivec2(fragCoord),0);\n    fragColor = vec4(data.xyz/data.w, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Playing with Keenan Crane's latest paper in collab with\n// Rohan Sawhney\n//\n// http://www.cs.cmu.edu/~kmcrane/Projects/MonteCarloGeometryProcessing/paper.pdf[/url]\n//\n\n//uncomment one of the two following defines.\n\n//Original method: One can always set the epsilon value to be very small. here set to 0.001 as in original shader\n//#define ORIGINAL\n\n//In This method, the bailout is postponed a prescribed number of times.\n//the epsilon is set to a high value just to show the effect.\n//on screen from left to right: number of times to postpone bailout(0 to 3)\n#define POSTPONE\n\n//the epsilon is function of the distance from the probe (pixel) to the boundaries.\n//Left : eps == 0.01*firstDist; Right: eps = 0.001;\n//Maybe useful because it sets the epsilon value automatically.\n//default//#define RELATIVE\n\n// https://iquilezles.org/articles/distfunctions\nvec4 sdLine( in vec2 p, in vec2 a, in vec2 b, in vec3 ca, in vec3 cb )\n{\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    float d = length(pa-h*ba);\n    float s = step(0.0,pa.x*ba.y-pa.y*ba.x);\n    return vec4(d, mix(ca,cb,s)*smoothstep(-0.1,0.1,sin(50.0*h)) );\n}\n\n// sdf map\nvec4 map( in vec2 p )\n{\n    vec4 d  = sdLine(p, vec2(-1.0,0.4), vec2(1.1,-0.1), vec3(1.0,0.4,0.1),vec3(0.2,0.5,0.8) )-0.0;\n    vec4 d2 = sdLine(p, vec2(-0.3,0.8), vec2(0.2,-0.6), vec3(1.0,1.0,0.2), vec3(0.1,0.7,0.3) )-0.0;\n    if( d2.x<d.x ) d = d2;\n    \n    return d;\n}\n\n\n// --------------------------------------\n// oldschool rand() from Visual Studio\n// --------------------------------------\nint   seed = 1;\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\nvoid  srand( ivec2 p, int frame )\n{\n    int n = frame;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589; // by Hugo Elias\n    n += p.y;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    n += p.x;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    seed = n;\n}\n\n// --------------------------------------\n\n\n// --------------------------------------\n// hash to initialize the random sequence (copied from Hugo Elias)\n// --------------------------------------\nint hash( int n )\n{\n\tn = (n << 13) ^ n;\n    return n * (n * n * 15731 + 789221) + 1376312589;\n}\n\n// --------------------------------------\n\nvec2 randomInCircle( void )\n{\n    float an = 6.283185*float(rand())/32767.0;\n    return vec2(cos(an),sin(an));\n}\n\n// WoS\n#ifdef ORIGINAL\nvec3 march( in vec2 p )\n{\n    vec4 h=vec4(0.0);\n\tfor( int i=0; i<32; i++ )\n    {\n        h = map(p);\n        if( h.x<0.001 ) break;\n        p = p + h.x*randomInCircle();\n    }\n    return h.yzw;\n}\n#else\n\n// Slice the screen\nint cse=0;\n\n#ifdef POSTPONE\nvec3 march( in vec2 p )\n{\n    vec4 h=vec4(0.0);\n    int j=cse;\n\tfor( int i=0; i<32; i++ )\n    {\n        h = map(p);\n        if( h.x<0.05 ) {\n            if(j--<=0)\n                break;\n        }\n        p = p + h.x*randomInCircle();\n    }\n    return h.yzw;\n}\n#else  //RELATIVE\nvec3 march( in vec2 p )\n{\n    vec4 h=vec4(0.0);\n    h = map(p);\n    float eps = cse<2 ? h.x*0.01 : 0.001;\n\tfor( int i=0; i<32; i++ )\n    {\n        if( h.x < eps ) break;\n        p = p + h.x*randomInCircle();\n        h = map(p);\n    }\n    return h.yzw;\n}\n#endif\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// init randoms\n    srand( ivec2(fragCoord), iFrame );\n#ifndef ORIGINAL\n    //set value for j based on x coord\n    if(   int(fragCoord.x) == int(iResolution.x * 0.5) \n#ifdef POSTPONE\n       || int(fragCoord.x) == int(iResolution.x * 0.25)\n       || int(fragCoord.x) == int(iResolution.x * 0.75)\n#endif\n      ){fragColor = vec4(1); return;}\n    cse = int(4. * fragCoord.x/iResolution.x);\n#endif\n\n    // solve\n    vec2 p = 0.7*(2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 col = march(p);\n\n    // display map()\n    #if 0\n    vec4 dcol = map(p);\n    float f = 1.0-smoothstep(0.0,0.01,dcol.x);\n    col = mix(col,dcol.yzw,f);\n    col *= smoothstep(0.0,0.01,abs(dcol.x));\n    #endif\n\n    // montecarlo\n    vec4 data = texelFetch(iChannel0,ivec2(fragCoord),0);\n    fragColor = data + vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}