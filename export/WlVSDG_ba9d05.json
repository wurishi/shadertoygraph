{"ver":"0.1","info":{"id":"WlVSDG","date":"1583502305","viewed":87,"name":"SphereMirror_ZJUMSJ","username":"ZJUMSJ","description":"A toy application of environment map.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["mirror"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// author:   ZJUMSJ\n// date:     2020/03/06\n\n// do some anti-aliasing\n#define SR_SAMPLE 4\n\nconst float PI = 3.14159265359;\n\nvoid gen_frame(in float fovy,out vec3 u,out vec3 v,out vec3 w){\n\t\n    float half_fovy_in_radius = tan(fovy * PI / 360.f);\n    w = vec3(0.f,0.f,-1.f);\n    v = vec3(0.f,half_fovy_in_radius,0.f);\n    u = vec3(half_fovy_in_radius/iResolution.y * iResolution.x,0.f,0.f);\n}\n\nbool intersection_sphere(\n    in vec3 eye, in vec3 dir,\n    in vec3 center, in float radius,\n    out vec3 pos, out vec3 normal\n    )\n{\n    vec3 O = eye - center;\n    float b = dot(O,dir);\n    float c = dot(O,O) - radius * radius;\n    float disc = b * b - c;\n    if (disc > 0.0f){\n    \tfloat sdisc = sqrt(disc);\n        float root1 = (-b-sdisc);\n        //float root11 = 0.0f;\n        \n        \n        vec3 shading_normal = (O + (root1 /* + root11*/) * dir)/radius;\n        normal = shading_normal;\n        \n        pos = eye + root1 * dir;\n        return true;\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float fovy = 60.f;\n    const vec3 eye = vec3(0.f);\n    //    \n    vec3 sphere_center = vec3(0.f,0.f,-10.f);\n    float sphere_radius = 4.f;\n    //    \n    float t = iTime * 0.05;\n    mat3 rot;\n    float c = cos(t), s = sin(t);\n    rot[0] = vec3(c,0.f,-s);\n    rot[1] = vec3(0.f,1.f,0.f);\n    rot[2] = vec3(s,0.f,c);\n    \n    vec3 U;\n\tvec3 V;\n\tvec3 W;\n    \n    gen_frame( fovy, U, V, W );\n    \n    U = rot * U;\n    V = rot * V;\n    W = rot * W;\n    sphere_center = rot * sphere_center;\n    \n#ifndef SR_SAMPLE\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy * 2.f - vec2(1.f);\n    \n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec3 vdir_nonorm = uv.x * U + uv.y * V + W;\n    vec3 dir = normalize(vdir_nonorm);\n    \n    vec3 hit,hit_normal;\n    \n    if(\n        intersection_sphere( eye, dir,\n                            sphere_center, sphere_radius,\n                            hit, hit_normal\n                           )){\n        \n        //fragColor = vec4(0.f); // debug black color\n        vec3 reflect_dir = reflect(dir,hit_normal);\n        fragColor = texture( iChannel0, reflect_dir);\n    \n    }\n    else{\n    \tfragColor = texture( iChannel0, dir );\n    }\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n#else\n    \n    float weight = 1.f / float(SR_SAMPLE * SR_SAMPLE);\n    vec4 result = vec4(0.f);\n    float dw,dh;\n    for( int iw = 0; iw < SR_SAMPLE; iw++){\n        dw = (float(iw) + 0.5f)/ float(SR_SAMPLE) - 0.5f;\n        \n        for(int ih = 0; ih < SR_SAMPLE; ih++){\n            dh = (float(ih) + 0.5f)/ float(SR_SAMPLE) - 0.5f;\n            \n            vec2 ipos_offset = fragCoord + vec2(dw,dh);\n       \t\tvec2 uv = ipos_offset/iResolution.xy * 2.f - vec2(1.f);\n            vec3 vdir_nonorm = uv.x * U + uv.y * V + W;\n            vec3 dir = normalize(vdir_nonorm);\n            vec3 hit,hit_normal;\n\n            if(\n                intersection_sphere( eye, dir,\n                    sphere_center, sphere_radius,\n                    hit, hit_normal\n            )){\n                vec3 reflect_dir = reflect(dir,hit_normal);\n                result += texture( iChannel0, reflect_dir);\n            }\n            else{\n                result += texture( iChannel0, dir );\n            }\n       }\n    }\n    fragColor = result * weight;\n    \n#endif\n}","name":"Image","description":"","type":"image"}]}