{"ver":"0.1","info":{"id":"Ddl3zj","date":"1666437935","viewed":147,"name":"Anisotropic Kuwahara Filter, KS","username":"stormsc1","description":"Anisotropic Kuwahara Filter\n\nhttps://code.google.com/archive/p/gpuakf/source/default/source","likes":1,"published":1,"flags":0,"usePreview":1,"tags":["kuwahara"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int N = 8;\nconst float radius = 15.0;\nconst float q  = 12.0;\nconst float alpha = 5.0;\n\nvec4 k0123(vec2 uv)\n{\n    float n = float((radius + 1.0f) * (radius + 1.0f));\n\n    vec3 m[4];\n    vec3 s[4];\n    for (int k = 0; k < 4; ++k) {\n        m[k] = vec3(0.0);\n        s[k] = vec3(0.0);\n    }\n\n    for (int j = int(-radius); j <= 0; ++j)  {\n        for (int i = int(-radius); i <= 0; ++i)  {\n            vec3 c = texture(iChannel0, uv + vec2(i,j) / iResolution.xy).rgb;\n            m[0] += c;\n            s[0] += c * c;\n        }\n    }\n\n    for (int j = int(-radius); j <= 0; ++j)  {\n        for (int i = 0; i <= int(radius); ++i)  {\n            vec3 c = texture(iChannel0, uv + vec2(i,j) / iResolution.xy).rgb;\n            m[1] += c;\n            s[1] += c * c;\n        }\n    }\n\n    for (int j = 0; j <= int(radius); ++j)  {\n        for (int i = 0; i <= int(radius); ++i)  {\n            vec3 c = texture(iChannel0, uv + vec2(i,j) / iResolution.xy).rgb;\n            m[2] += c;\n            s[2] += c * c;\n        }\n    }\n\n    for (int j = 0; j <= int(radius); ++j)  {\n        for (int i = int(-radius); i <= 0; ++i)  {\n            vec3 c = texture(iChannel0, uv + vec2(i,j) / iResolution.xy).rgb;\n            m[3] += c;\n            s[3] += c * c;\n        }\n    }\n\n\n    float min_sigma2 = 1e+2;\n    for (int k = 0; k < 4; ++k) {\n        m[k] /= n;\n        s[k] = abs(s[k] / n - m[k] * m[k]);\n\n        float sigma2 = s[k].r + s[k].g + s[k].b;\n        if (sigma2 < min_sigma2) {\n            min_sigma2 = sigma2;\n            return vec4(m[k], 1.0);\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    // tfm\n    \n    vec3 g = texture(iChannel0, uv).xyz;\n\n    float lambda1 = 0.5 * (g.y + g.x +\n        sqrt(g.y*g.y - 2.0*g.x*g.y + g.x*g.x + 4.0*g.z*g.z));\n    float lambda2 = 0.5 * (g.y + g.x -\n        sqrt(g.y*g.y - 2.0*g.x*g.y + g.x*g.x + 4.0*g.z*g.z));\n\n    vec2 v = vec2(lambda1 - g.x, -g.z);\n    vec2 t;\n    if (length(v) > 0.0) { \n        t = normalize(v);\n    } else {\n        t = vec2(0.0, 1.0);\n    }\n\n    float phi = atan(t.y, t.x);\n\n    float A = (lambda1 + lambda2 > 0.0)?\n        (lambda1 - lambda2) / (lambda1 + lambda2) : 0.0;\n\n    vec4 tfm = vec4(t, phi, A);\n    \n    // akf\n    vec4 m[8];\n    vec3 s[8];\n    for (int k = 0; k < N; ++k) {\n        m[k] = vec4(0.0);\n        s[k] = vec3(0.0);\n    }\n\n    float a = radius * clamp((alpha + tfm.w) / alpha, 0.1, 2.0); \n    float b = radius * clamp(alpha / (alpha + tfm.w), 0.1, 2.0);\n\n    float cos_phi = cos(tfm.z);\n    float sin_phi = sin(tfm.z);\n\n    mat2 R = mat2(cos_phi, -sin_phi, sin_phi, cos_phi);\n    mat2 S = mat2(0.5/a, 0.0, 0.0, 0.5/b);\n    mat2 SR = S * R;\n\n    int max_x = int(sqrt(a*a * cos_phi*cos_phi +\n                          b*b * sin_phi*sin_phi));\n    int max_y = int(sqrt(a*a * sin_phi*sin_phi +\n                          b*b * cos_phi*cos_phi));\n\n    {\n        vec3 c = texture(iChannel0, uv).rgb;\n        float w = k0123(vec2(0.5, 0.5)).x;\n        for (int k = 0; k < N; ++k) {\n            m[k] +=  vec4(c * w, w);\n            s[k] += c * c * w;\n        }\n    }\n\n    for (int j = 0; j <= max_y; ++j)  {\n        for (int i = -max_x; i <= max_x; ++i) {\n            if ((j !=0) || (i > 0)) {\n                vec2 v = SR * vec2(i,j);\n\n                if (dot(v,v) <= 0.25) {\n                    vec3 c0 = texture(iChannel0, uv + vec2(i,j)/iResolution.xy).rgb;\n                    vec3 c1 = texture(iChannel0, uv - vec2(i,j)/iResolution.xy).rgb;\n\n                    vec3 cc0 = c0 * c0;\n                    vec3 cc1 = c1 * c1;\n\n                    vec4 w0123 = k0123(vec2(0.5, 0.5) + v);\n                    for (int k = 0; k < 4; ++k) {\n                        m[k] += vec4(c0 * w0123[k], w0123[k]);\n                        s[k] += cc0 * w0123[k];\n                    }\n                    for (int k = 4; k < 8; ++k) {\n                        m[k] += vec4(c1 * w0123[k-4], w0123[k-4]);\n                        s[k] += cc1 * w0123[k-4];\n                    }\n\n                    vec4 w4567 = k0123(vec2(0.5, 0.5) - v);\n                    for (int k = 4; k < 8; ++k) {\n                        m[k] += vec4(c0 * w4567[k-4], w4567[k-4]);\n                        s[k] += cc0 * w4567[k-4];\n                    }\n                    for (int k = 0; k < 4; ++k) {\n                        m[k] += vec4(c1 * w4567[k], w4567[k]);\n                        s[k] += cc1 * w4567[k];\n                    }\n                }\n            }\n        }\n    }\n\n    vec4 o = vec4(0.0);\n    for (int k = 0; k < N; ++k) {\n        m[k].rgb /= m[k].w;\n        s[k] = abs(s[k] / m[k].w - m[k].rgb * m[k].rgb);\n\n        float sigma2 = s[k].r + s[k].g + s[k].b;\n        float w = 1.0 / (1.0 + pow(255.0 * sigma2, 0.5 * q));\n\n        o += vec4(m[k].rgb * w, w);\n    }\n\n    vec4 akf =  vec4(o.rgb / o.w, 1.0);\n    \n\n    fragColor = akf;\n}","name":"Image","description":"","type":"image"}]}