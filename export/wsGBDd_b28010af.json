{"ver":"0.1","info":{"id":"wsGBDd","date":"1608228116","viewed":103,"name":"Analytic AO + Bleed - Step","username":"athibaul","description":"In the simple setting of a \"step\" in the middle of an infinite plane, ambient occlusion can be computed exactly. An approximation of low-order color bleeding in this specific setup is also given.\n\nLeft = without bleeding, right = with bleeding.\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ambientocclusion","analytic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Analytic Ambient Occlusion\n\n// In the simple setting of a \"step\" in the middle of an infinite plane,\n// the integral of ambient occlusion can be computed exactly.\n\n// An approximation of low-order color bleeding in this specific setup is also given.\n// Left = without bleeding, right = with bleeding.\n\nvec3 worldColor( vec3 ro, vec3 rd )\n{\n    vec3 col1 = vec3(0.5); // Back floor color\n    vec3 col2 = vec3(0.5); // Wall color\n    vec3 col3 = vec3(0.8,0.5,0.1); // Front floor color\n    \n    \n    // Calculate ray intersection with each plane\n    float tmin = 1e10;\n    vec3 col = vec3(1);\n    float t; vec3 p;\n    \n    // Plane 1 is z=1 for x<0 : \"back floor\"\n    // AO = 1.0\n    t = (1.0-ro.z)/rd.z;\n    p = ro+t*rd;\n    if(t > 0.0 && p.x < 0.001 && t < tmin)\n    {\n        tmin = t;\n        col = col1;\n    }\n    \n    \n    // Plane 2 is x=0, for z between 0 and 1 : \"wall\"\n   \tt = -ro.x/rd.x;\n    p = ro+t*rd;\n    if(t > 0.0 && p.z > 0.0 && p.z < 1.0 && t < tmin)\n    {\n        tmin = t;\n        // Analytic ambient occlusion (exact):\n        // The floor occludes exactly half of the hemisphere visible from the wall\n        col = col2*0.5;\n        \n        if(p.y > 0.)\n        {\n            float zp1sq = (p.z+1.)*(p.z+1.);\n            \n            // Bleeding from the floor.\n            // Approximation obtained by fitting some terms with\n            // exponentials, so they can be integrated by hand (whereas the\n            // actual terms can't).\n            // The formula is only valid for this specific setting for now.\n            \n            // First order bleeding (approximation)\n            //col += col0*col0*0.25*(2.*zp1sq-1.)/zp1sq;\n            \n            // Second order bleeding (approximation)\n            col += col2*col3*0.5*mix(0.5*col2, vec3(1), (zp1sq-0.5)/zp1sq);\n        }\n    }\n    \n    \n    // Plane 3 is z=0, for x>0\n    t = -ro.z/rd.z;\n    p = ro+t*rd;\n    if(t > 0.0 && p.x > -0.001 && t < tmin)\n    {\n        tmin = t;\n        // Analytic Ambient Occlusion (exact)\n        // If the distance from the wall is x, then\n        // AO = 0.5+0.5*x/sqrt(1.0+x*x)\n        col = col3*(0.5+0.5*p.x/sqrt(1.0+p.x*p.x));\n        \n        if(p.y > 0.)\n        {\n            // Bleeding from the wall, first order (exact):\n            // the wall occupies exactly the remaining portion of the hemisphere\n            // and is lit by 0.5*col2.\n            col += col3*0.5*col2 * (0.5-0.5*p.x/sqrt(1.0+p.x*p.x));\n        }\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n\n    float th = 0.5*iTime-1.5;\n    float th2 = 0.1*iTime;\n    //vec3 ro = vec3(3.0*cos(th), 3.0*sin(th), 2.0 - 1.5*cos(th));\n    vec3 ro = vec3(3.0, 0.3*sin(th), 2.0-0.3*cos(th));\n    vec3 camFwd = normalize(vec3(0) - ro);\n    vec3 camRight = normalize(cross(camFwd, vec3(0,0,1)));\n    vec3 camUp = cross(camRight, camFwd);\n   \tfloat fov = 0.7;\n    vec3 rd = normalize(camFwd + fov * (uv.x*camRight + uv.y * camUp));\n    \n    //vec3 col = 0.5+0.5*rd;\n    vec3 col = worldColor(ro, rd);\n    \n    col = pow(col, vec3(1.0/2.2));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}