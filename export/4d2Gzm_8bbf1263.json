{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// The below code makes assumes the View Frustrum has a width of 1 unit\n// In screen space, the origin is at the center of the screen\n// In camera space, the origin is at the camera\n// In world space, the origin is at (0.0,0.0,0.0)\n\n// The coordinate system is as follows, both for camera and world:\n\n// +x is left, -x is right\n// +y is forward, -y is backwards \n// +z is up, -z is down\n\n// The rotation matrices are as follows:\n\n// x-axis = pitch\n// y-axis = roll\n// z-axis = yaw\n\n// unfortunately i have muffed this up somehow, as everything is upside down\n\n//=========RENDERING QUALITY==========\n\n// max number of ray marches. also controls distance fog\nconst float MAX_T = 200.0;\n\n// start value for ray march delta\nconst float DELT = 0.0003;\n\n// controls exponential scaling of ray march delta\nconst float LOD = 1.5;\n\n\n//============WORLD OBJECTS===========\n\nconst vec4 FOG_COLOR = vec4(0.3, 0.3, 0.5, 1.0);\n\nconst float FLOOR_HEIGHT = -0.1;\n\nconst float TERRAIN_HEIGHT = 0.1;\nconst float TERRAIN_DETAIL_HEIGHT = 0.0;\n\nconst float TERRAIN_SCALE = 10.0;\nconst float TERRAIN_DETAIL_SCALE = 0.3;\n\t\nconst float INVERSE_SCALE = 1.0/ TERRAIN_SCALE;\nconst float INVERSE_DETAIL_SCALE = 1.0 / TERRAIN_DETAIL_SCALE;\nconst float MAX_TERRAIN_HEIGHT = FLOOR_HEIGHT + TERRAIN_HEIGHT + TERRAIN_DETAIL_HEIGHT;\n\n//============CAMERA================\n\nconst float CAMERA_SPEED = 1.5;\nconst float CAMERA_HEIGHT = 0.0;\n\nconst float CAMERA_YAW_DEG = 45.0;\nconst float CAMERA_ROLL_DEG = 0.0;\nconst float CAMERA_PITCH_DEG = 10.0;\n\nfloat CAMERA_YAW_RAD = radians(CAMERA_YAW_DEG);\nfloat CAMERA_ROLL_RAD = radians(CAMERA_ROLL_DEG);\nfloat CAMERA_PITCH_RAD = radians(CAMERA_PITCH_DEG);\n\n\n//vec3 CAMERA_VECTOR = vec3(sin(CAMERA_ROLL_RAD), cos(CAMERA_YAW_RAD), sin(CAMERA_PITCH_RAD));\n\n\n\n\n//===CAMERA/SCREEN CALCULATIONS=====\n\n// Dimensions of screen, with 1.0 defined as width of screen\n//vec2 SCREEN_DIMENSIONS = vec2(1.0, iResolution.y / iResolution.xy);\n\n// The viewing reference point of the near frustum in uv coordinates\n//vec2 VRP_UV = vec2(SCREEN_DIMENSIONS.x/2.0, SCREEN_DIMENSIONS.y/2.0);\n\nconst float FOV = 107.0;\n//float CAMERA_FRUSTUM_DEPTH = SCREEN_DIMENSIONS.x / atan(radians(FOV));\n\n\n//=========ANIMATION==========\n\n// Camera Position\nvec3 CameraPositionInWorld()\n{\n\treturn vec3(0.0, CAMERA_SPEED * iTime, CAMERA_HEIGHT);\n}\n\n// Camera Orientation Vector\nvec3 CameraOrientationInWorld()\n{\t\n\treturn vec3(sin(CAMERA_ROLL_RAD), cos(CAMERA_YAW_RAD), sin(CAMERA_PITCH_RAD));\n}\n\n//==========COLORING=========\n\nvec4 FloorColor(vec2 coord)\n{\n\treturn texture(iChannel0, INVERSE_SCALE * coord).zzzz;\n}\n\n//=======SOLID MODELING======\n\nfloat FloorHeight(vec2 coord)\n{\n\t// Base floor height + amount of green in texture + detail\n\treturn \n\t\tFLOOR_HEIGHT + \n\t\tTERRAIN_HEIGHT * (texture(iChannel0, INVERSE_SCALE * coord)).z +\n\t\tTERRAIN_DETAIL_HEIGHT * (texture(iChannel0, INVERSE_DETAIL_SCALE * coord.xy)).z;\n}\n\n\n//=======RAY MARCHING========\n\n// p0 = \"initial ray location\"\n// rd = \"ray direction\", must be normalized\nvec4 RayMarch(vec3 p0, vec3 rd) \n{\n\tvec3 lp = p0; // last ray location\n\tvec3 p = lp; // current ray location\n\t\n\tfloat h = FloorHeight(p0.xy); // terrain height at current ray location\n\tfloat lh = h; // terrain height at last ray location\n\t\n\tfloat dist = 0.0;\n\t\n\tfor (float t = 0.0; t < MAX_T; t++)\n\t{\t\n\t\t// terrain miss\n\t\tif (p.z > MAX_TERRAIN_HEIGHT && rd.z >= 0.0)\n\t\t{\n\t\t\treturn 0.0 * FOG_COLOR;\n\t\t}\n\t\t\n\t\t// analytically jump to max_terrain_height optimization\n\t\tif (p.z > MAX_TERRAIN_HEIGHT && rd.z < 0.0)\n\t\t{\n\t\t\t//return vec4(0.0, 1.0, 0.0, 1.0);\n\t\t\tp = p0 + rd * (p.z - MAX_TERRAIN_HEIGHT)/rd.z;\n\t\t}\n\t\t\n\t\tdist += DELT * t;\n\t\t\n\t\tlp = p;\n\t\tp = p0 + rd * dist;\n\t\t\n\t\tlh = h;\n\t\th = FloorHeight(p.xy);\t\t\n\t\t\n\t\tif (p.z < h)\n\t\t{\n\t\t\t// this isn't working for whatever reason...\n\t\t\t// interpolate between p and last p based on terrain penetration\n\t\t\t//p = mix(lp, p, (p.z - h) / (h - lh));\n\t\t\t\n\t\t\t// if we are getting near MAX_T, fade to black\n\t\t\t//return vec4(0.0, 0.0, 1.0, 1.0);\n\t\t\treturn mix(FOG_COLOR, FloorColor(p.xy), (MAX_T - t) / MAX_T);\n\t\t}\n\t}\n\t\n\t//return vec4(1.0, 0.0, 0.0, 1.0);\n\treturn FOG_COLOR;\n}\n\n//=====Transforms=============\n\nvec2 GetUVCoord(vec2 fragCoord)\n{\n\treturn fragCoord.xy / iResolution.x;\n}\n\nvec2 ToScreenSpace(vec2 uv)\n{\n    vec2 SCREEN_DIMENSIONS = vec2(1.0, iResolution.y / iResolution.xy);\n    vec2 VRP_UV = vec2(SCREEN_DIMENSIONS.x/2.0, SCREEN_DIMENSIONS.y/2.0);\n\treturn uv - VRP_UV * vec2(1.0, -1.0);\n}\n\nvec3 ToCameraSpace(vec2 uv)\n{\n    vec2 SCREEN_DIMENSIONS = vec2(1.0, iResolution.y / iResolution.xy);\n    vec2 VRP_UV = vec2(SCREEN_DIMENSIONS.x/2.0, SCREEN_DIMENSIONS.y/2.0);\n    float CAMERA_FRUSTUM_DEPTH = SCREEN_DIMENSIONS.x / atan(radians(FOV));\n\t// \"up\" in screen coordinates is y, but \"up\" in camera coordinates is z\n\treturn vec3(uv.x, CAMERA_FRUSTUM_DEPTH, uv.y);\n}\n\n\nvec3 ToWorldCoord(\n\t\tvec3 pixelCoord, \n\t\tvec3 cameraOrientation, \n\t\tvec3 cameraPositionInWorld,\n\t\tout vec3 rayVector)\n{\t\n\t// sin/cos for rotation about x-axis (pitch)\n\tfloat yzPlaneDist = length(pixelCoord.yz);\n\tfloat xAxisSin = pixelCoord.z / yzPlaneDist;\t\n\tfloat xAxisCos = pixelCoord.y / yzPlaneDist;\n\n\t// x-axis rotation matrix\n\tmat3 xAxisRotation = mat3(1.0, 0.0, \t\t0.0,\n\t\t\t\t\t\t\t  0.0, xAxisCos,\t-1.0 * xAxisSin,\n\t\t\t\t\t\t\t  0.0, xAxisSin,\txAxisCos);\t\n\t\n\t// sin/cos for rotation about z-axis (yaw)\n\tfloat xyPlaneDist = length(pixelCoord.xy);\t\n\tfloat zAxisSin = pixelCoord.x / xyPlaneDist;\n\tfloat zAxisCos = pixelCoord.y / xyPlaneDist;\t\n\t\n\t// z-axis rotation matrix\n\tmat3 zAxisRotation = mat3(\n\t\t\t\t\t\tzAxisCos,\t-1.0 * zAxisSin, \t0.0,\n\t\t\t\t\t\t1.0 * zAxisSin,\tzAxisCos, \t\t\t0.0,\n\t\t\t\t\t\t0.0,\t\t0.0,\t\t\t\t1.0);\n\t\n\n\t// apply rotation matrices to camera orientation to get ray vector\n\trayVector = normalize(xAxisRotation * zAxisRotation * cameraOrientation);\n\t\n\t// transform current pixel from camera coordinates to world coordinates\n\treturn pixelCoord + CameraPositionInWorld();\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 pixel_coord = ToCameraSpace(ToScreenSpace(GetUVCoord(fragCoord)));\n\tvec3 rayVector = vec3(0.0, 0.0, 0.0);\n\tvec3 world_coord = ToWorldCoord(pixel_coord, CameraOrientationInWorld(), CameraPositionInWorld(), rayVector);\n\tfragColor = RayMarch(world_coord, rayVector);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4d2Gzm","date":"1385341671","viewed":221,"name":"Rolling Clouds","username":"kp1197","description":"Experiments with different optimization methods for the terrain raymarch","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["terrain","raymarch","lod"],"hasliked":0,"parentid":"","parentname":""}}