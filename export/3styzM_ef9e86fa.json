{"ver":"0.1","info":{"id":"3styzM","date":"1600658136","viewed":648,"name":"Reaction-Diffusion Simulation","username":"vug","description":"simulating an RD system. ","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 tex = texture(iChannel0, uv);\n    fragColor = vec4(vec3(smoothstep(0.2, 0.4, tex.y)), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// implementing https://www.karlsims.com/rd.html in GLSL since computing each pixel in parallel \n// will make it run very fast!\n\n// Main Buffer to be used by Image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col;\n    // Initial state\n    if (iFrame == 0) {\n        col = vec3(1.0, 0.0, 0.0);\n        if ( distance(uv, vec2(0.5, 0.5)) < 0.2 ) {\n            col = vec3(1.0, 1.0, 0.0);\n        }\n        fragColor = vec4(col, 1.0);\n        return;\n    }\n\tfragColor = render(iResolution, iChannel3, uv);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tfragColor = render(iResolution, iChannel0, uv);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tfragColor = render(iResolution, iChannel1, uv);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tfragColor = render(iResolution, iChannel2, uv);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec3 gRes;\n// sampler2D gChannel; // Error: sampler2Ds must be uniform\n// uniform sampler2D gChannel;\n\nvec4 sample1(sampler2D channel, vec2 uv, float i, float j) {\n    vec2 px = 1. / gRes.xy;\n    vec2 r = vec2(i, j);\n\n    return texture(channel, uv + px * r);\n}\n\nvec2 diffuse(sampler2D channel, vec2 p) {\n\tvec4 diagonals = sample1(channel, p, 1., 1.) + sample1(channel, p, 1., -1.) + sample1(channel, p, -1., -1.) + sample1(channel, p, -1., 1.);\n    vec4 sides = sample1(channel, p, 1., 0.) + sample1(channel, p, 0., -1.) + sample1(channel, p, -1., 0.) + sample1(channel, p, 0., 1.);\n    vec4 center = sample1(channel, p, 0., 0.);   \n    return (diagonals * 0.05 + sides * 0.20 - center).xy;\n    //return (diagonals + sides * 2. - center * 12.).xy / 21.;\n}\n\nvec4 render(vec3 res, sampler2D channel, vec2 uv ) {\n    gRes = res;\n    // gChannel = channel; // l-value required (can't modify a uniform \"gChannel\")\n    vec3 col = vec3(0.0);\n    vec2 diff_rate = vec2(1.025, 0.302);\n    float feed = 0.031;\n    float kill = 0.056;\n    float dt = 1.0;\n    \n    vec2 ab = sample1(channel, uv, 0., 0.).xy;\n    vec2 delta_ab = diff_rate * diffuse(channel, uv).xy;\n    float reaction = ab.x * ab.y * ab.y;\n    delta_ab += vec2(-1., 1.) * reaction;\n    delta_ab += vec2(feed * (1. - ab.x), - (kill + feed) * ab.y);\n    col.xy = clamp(ab + delta_ab, 0., 1.);\n\n    vec4 fragColor = vec4(col.x, col.y, 0.0, 1.0);\n    return fragColor;\n}\n","name":"Common","description":"","type":"common"}]}