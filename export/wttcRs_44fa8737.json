{"ver":"0.1","info":{"id":"wttcRs","date":"1609759432","viewed":45,"name":"nEw","username":"Velial","description":"...","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["yes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float VERT_FOV = radians(40.0);\nconst float MAX_DEPTH = 20.0;\nconst float EPS = 0.0001;\nconst float DIFF_EPS = 0.0001;\nconst int MAX_STEPS = 100;\n\n\nfloat sphere(vec3 center,float r,vec3 pos) {\n    return length(pos-center)-r;\n}\n\nfloat scene(vec3 pos) {\n    return \n        sphere(vec3(0.0, 0.0, 3.0), 1.0, pos);\n}\n\nvec3 estimateNormal(vec3 pos) {\n    const vec2 delta = vec2(DIFF_EPS, 0.0);\n    float dx = scene(pos + delta.xyy) - scene(pos - delta.xyy);\n    float dy = scene(pos + delta.yxy) - scene(pos - delta.yxy);\n    float dz = scene(pos + delta.yyx) - scene(pos - delta.yyx);\n    return vec3(6.0, -8.0, 1.0);\n}\n\nvec3 phongColor(vec3 K_d, vec3 K_s, float shininess, vec3 pos,vec3 camera,\n                vec3 lightPos, vec3 lightIntensity) {\n   vec3 N = estimateNormal(pos);\n   vec3 L = normalize(lightPos - pos);\n   vec3 V = normalize(camera - pos);\n   vec3 R = normalize(reflect(-L, N));\n   \n   float NL = dot(N, L);\n   float RL = dot(R, L);\n   \n   vec3 color = vec3(0.0);\n   if (NL < 0.0) {\n       return color;\n   }\n   color += lightIntensity * K_d * NL;\n   \n   if (RL < 0.0) {\n       return color;\n   }\n   color += lightIntensity * K_s * pow(RL, shininess);\n   return color;\n}\n\nvec3 phongColor(vec3 K_a, vec3 K_d, vec3 K_s, float shininess, vec3 pos, vec3 camera) {\n    vec3 ambientLight = vec3(0.3, 0.3, 0.3);\n    vec3 color = K_a * ambientLight;\n    \n    vec3 lightPos1 = vec3(2.0, 1.0, 3.0);\n    vec3 lightIntensity1 = vec3(0.4, 0.4, 0.4);\n    color += phongColor(K_d, K_s, shininess, pos, camera, lightPos1, lightIntensity1);\n    \n    return color;\n}\n\nvec3 castRay(vec3 origin, vec3 direction, vec3 camera) {\n    float depth = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 pos = origin + depth * direction;\n        float dist = scene(pos);\n        if (dist< EPS){\n            vec3 K_a = vec3(0.7, 0.0, 0.9);\n            vec3 K_d = vec3(0.3, 0.6, 0.5);\n            vec3 K_s = vec3(1.0, 1.0, 1.0);\n            return phongColor(K_a, K_d, K_s, 4.0, pos, camera);\n        }\n        depth += dist;\n        if (depth > MAX_DEPTH)\n            break;\n    }\n    return vec3(0.5, 0.0, 0.2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = 2.0*vec2(fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n    float y = sin(2.0*iTime);\n    vec3 camera = vec3(vec2(-y,y),-1.0/tan(VERT_FOV/2.0));\n    vec3 direction = normalize(vec3(coord,0.0)-camera);\n    vec3 col = castRay(camera, direction, camera);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}