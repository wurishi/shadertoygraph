{"ver":"0.1","info":{"id":"XtdGz4","date":"1468487966","viewed":2530,"name":"[SH16B] Infinite Acceleration","username":"Neper","description":"My entry to the 2nd week of 2016 Shadertoy competition.","likes":23,"published":1,"flags":40,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor \t= texture(iChannel0, uv);        \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsfGRr","channel":0}],"code":"const float Pi \t\t= 3.141592653589793;\n\nfloat waveform(float t, float freq)\n{\n    float lfo = 0.85 + 0.15 * sin(t * 2.0 * Pi * 0.5);\n    float noise1 = texture(iChannel0, vec2(t * 0.17, t * 0.94)).x;\n    float noise2 = texture(iChannel0, vec2(t * 0.44, t * 0.73)).x;\n    float wave1 = fract(t * freq) < 0.2 ? 1.0 : 0.0;\n    float wave2 = fract(t * freq * 0.5) < 0.1 ? 1.0 : 0.0;\n    \n    return lfo * (wave1 * noise1 + wave2 * noise2);\n}\n\nfloat engineSound(float time)\n{\n    float freq = 50.0 * (1.0 + 0.1 * mod(time, 4.0));\n    return waveform(time, freq);\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    float a = 0.2 * engineSound(time);\n    \n    // Some fake echo\n    float b1 = 0.1 * engineSound(time - 0.07 + 0.01 * sin(time + 0.1));\n    float b2 = 0.05 * engineSound(time - 0.14 + 0.02 * sin(time + 1.9));\n    float b3 = 0.03 * engineSound(time - 0.24 + 0.03 * sin(time + 2.3));\n    \n    return vec2(a + b1 - b2 + b3, -a - b1 + b2 - b3);\n}","name":"Sound","description":"","type":"sound"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float Speed\t= 10.0;\nconst float Pi \t\t= 3.141592653589793;\n\nconst float LightAzi\t= radians(-35.0);\nconst float LightEle \t= radians(70.0);\nconst vec3 LightColor \t= vec3(1.0, 0.9, 0.7) * 3.0;\t// Yellowish and bright\n\n// Some geometry\nconst vec4 Plane\t= vec4(0.0, 1.0, 0.0, 0.33);\nconst vec2 Tire \t= vec2(0.24, 0.09);\t// r1 = 330 mm, r2 = 150 mm\nconst vec2 Groove \t= vec2(0.33, 0.01);\nconst vec2 Rim\t\t= vec2(0.15, 0.04);\n\n// IDs for detecting were the ray hits\nconst float PlaneId \t= 1.0;\nconst float HullId \t\t= 2.0;\nconst float TireId \t\t= 3.0;\nconst float RimId \t\t= 4.0;\nconst float AxelId\t\t= 5.0;\nconst float BuildingsId\t= 6.0;\nconst float SidewalksId = 7.0;\n\nconst vec3 AmbientColor = vec3(0.5, 0.6, 0.7) * 0.5;\n\nconst vec3 Luminance \t= vec3(0.2126, 0.7152, 0.0722);\n\nfloat length6(vec2 p)\n{\n    vec2 p3 = p * p * p;\n    return pow(dot(p3, p3), 1.0 / 6.0);\n}\n\nfloat mapPlane(vec3 pos, vec4 plane)\n{\n    return dot(vec4(pos, 1), plane);\n}\n\nfloat mapBox(vec3 pos, vec3 b)\n{\n    vec3 d = abs(pos) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\nfloat mapBoxRound(vec3 pos, vec3 b, float r)\n{\n    return length(max(abs(pos)-b, 0.0)) - r;\n}\n\nfloat mapCappedCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.zy), p.x)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat mapRim(vec3 p, vec2 h)\n{\n    return mapCappedCylinder(p, h);\n}\n\nfloat mapTorus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.zy)  - t.x, p.x);\n    return length6(q) - t.y;\n}\n\nfloat mapTire(vec3 p, vec2 t, float w)\n{    \n    vec2 uv = vec2(iTime * 0.74, iTime * 1.24);\n    vec3 q \t= vec3(p.x / w, p.y, p.z) + 0.05 * texture(iChannel2, uv).xyz;\n    return mapTorus(q, t);\n}\n\nfloat mapCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nvec3 bend(vec3 pos, float angle)\n{\n    float c\t= cos(angle * pos.z);\n    float s\t= sin(angle * pos.z);\n    mat2 m \t= mat2(c, -s, s, c);\n    vec2 n \t= m * pos.yz;\n    return vec3(pos.x, n.x, n.y);\n}\n\nfloat repBox(vec3 p, vec3 c, vec3 b)\n{\n    vec3 q = mod(p, c) - 0.5 * c;\n    return mapBox(q, b);\n}\n\nconst float HalfAxel \t= 0.9;\nconst float Length \t\t= 3.0;\n\nfloat mapSuspension(vec3 pos)\n{\n    return min(mapCapsule(pos, vec3(-HalfAxel, 0, -Length), vec3(0.2, 0.25, -Length), 0.02),\n        min(\n        min(mapCapsule(pos, vec3(-HalfAxel, 0.1, -Length), vec3(0, 0.1, -Length+0.1), 0.02),\n            mapCapsule(pos, vec3(-HalfAxel, 0.1, -Length), vec3(0, 0.1, -Length-0.1), 0.02)),\n        min(mapCapsule(pos, vec3(-HalfAxel, -0.1, -Length), vec3(0, 0.0, -Length+0.1), 0.02),\n            mapCapsule(pos, vec3(-HalfAxel, -0.1, -Length), vec3(0, 0.0, -Length-0.1), 0.02))));\n}\n\nfloat getSpeed()\n{\n    return 1.0 + Speed * 0.1 * iTime;\n}\n\nvec4 makeQuat(vec3 axis, float angle)\n{\n    return vec4(axis * sin(angle / 2.), cos(angle / 2.));\n}\n\nvec4 mulQuat(vec4 a, vec4 b)\n{\n    return vec4(a.w * b.xyz + b.w * a.xyz + cross(a.xyz, b.xyz),\n                a.w * b.w - dot(a.xyz, b.xyz));\n}\n\nvec3 rotQuat(vec4 q, vec3 r)\n{\n    return mulQuat(q, mulQuat(vec4(r, 0), vec4(-q.xyz, q.w))).xyz;\n}\n\nvec3 opRotX(vec3 p, float angle)\n{\n    return rotQuat(makeQuat(vec3(1, 0, 0), -angle), p);\n}\n\nvec2 map(vec3 pos)\n{\n    // Ground plane and sidewalks\n    float t_plane = mapPlane(pos, Plane);\n    float t_sidewalks = \n    \trepBox(pos - vec3(0, -0.25, 0),\n               vec3(30.0, 0.0, 30.0),\n               vec3(8.0, 0.1, 8.0));\n    \n    // Buildings        \n    vec2 uv = floor(pos.xz / 30.0) * 0.1;\n    float height = 60.0 - 3.0 * floor(15.0 * texture(iChannel2, uv).x);\n    float t_buildings = repBox(pos,\n                               vec3(30.0, 0.0, 30.0),\n                               vec3(6.0, height, 6.0));\n\n    // Car position with some noise to emulate uneveness of the road\n    vec3 dpos = 0.05 * texture(iChannel2, vec2(iTime * 0.12, iTime * 0.87)).xyz;\n    vec3 car_pos = vec3(pos.x, pos.y, pos.z + getSpeed() * iTime) + dpos;\n    \n    // Hull\n    float airhole_left =\n        mapBoxRound(car_pos - vec3(0.45, -0.1, -2.5),\n                    vec3(0.08, 0.1, 0.5), 0.1);\n    float airhole_right =\n        mapBoxRound(car_pos - vec3(-0.45, -0.1, -2.5),\n                    vec3(0.08, 0.1, 0.5), 0.1);    \n    float airholes = min(airhole_left, airhole_right);\n    float lower_body = min(\n        mapBoxRound(car_pos - vec3(0, -0.1, -1.35),\n                    vec3(0.6, 0.25, 0.9), 0.1),\n    \tmapBoxRound(car_pos - vec3(0, -0.1, -0.15),\n                    vec3(0.4, 0.25, 0.25), 0.1));\n    float nose =\n        mapBoxRound(bend(car_pos - vec3(0, 0.1, -2.5), 30.0 * Pi / 180.0),\n                    vec3(0.1, 0.2, 0.6), 0.1);\n    float nose_cutoff =\n        mapBoxRound(bend(car_pos - vec3(0, -0.6, -2.6), -30.0 * Pi / 180.0),\n                    vec3(0.3, 0.2, 0.6), 0.1);\n    \n    vec3 stretch = opRotX(vec3(car_pos.x, car_pos.y * 0.5, car_pos.z), radians(18.0));\n    float rearhood =\n        mapCapsule(stretch, vec3(0.0, -0.25, 0.0), vec3(0.0, -0.25, -1.0), 0.4);\n    \n    float rearwing =\n        min(\n            min(mapBoxRound(car_pos - vec3(-0.4, 0.5, 0.2),\n                    \tvec3(0.01, 0.3, 0.15), 0.01),\n        \t\tmapBoxRound(car_pos - vec3(0.4, 0.5, 0.2),\n                    \tvec3(0.01, 0.3, 0.15), 0.01)),\n        \tmapBoxRound(opRotX(car_pos - vec3(0, 0.7, 0.2), radians(-18.0)),\n                        vec3(0.4, 0.01, 0.15), 0.02));\n    \n    float frontwing =\n        mapBoxRound(car_pos - vec3(0, 0.0, -3.2),\n                    \tvec3(0.7, 0.02, 0.1), 0.02);\n    \n    float cockpit =\n        mapCapsule(car_pos, vec3(0.0, 0.0, -1.0), vec3(0.0, 0.0, -1.7), 0.4);\n    \n    float cavities = min(airholes, cockpit);\n    \n    float t_hull = max(-cavities,\n                       min(frontwing,\n                       min(min(rearhood, rearwing),\n                           min(lower_body, max(-nose_cutoff, nose)))));\n      \n    // Tires\n    float t_tires = min(\n        min(mapTire(car_pos + vec3(-HalfAxel, 0, 0), Tire, 2.0),\n            mapTire(car_pos + vec3(HalfAxel, 0, 0), Tire, 2.0)),\n        min(mapTire(car_pos + vec3(-HalfAxel, 0, Length), Tire, 1.5),\n        \tmapTire(car_pos + vec3(HalfAxel, 0, Length), Tire, 1.5)));\n    \n    // Rims\n    float t_rims = min(\n        min(mapRim(car_pos + vec3(-HalfAxel, 0, 0), Rim),\n        \tmapRim(car_pos + vec3(HalfAxel, 0, 0), Rim)),\n        min(mapRim(car_pos + vec3(-HalfAxel, 0, Length), Rim),\n        \tmapRim(car_pos + vec3(HalfAxel, 0, Length), Rim)));\n        \n    // Axels\n    float t_axels = min(\n        mapCapsule(car_pos, vec3(-HalfAxel, 0, 0), vec3(HalfAxel, 0, 0), 0.05),\n        \tmin(min(mapSuspension(car_pos),\n            \t\tmapSuspension(vec3(-car_pos.x, car_pos.y, car_pos.z))),\n       \t\t\tmin(mapSuspension(vec3(car_pos.x, car_pos.y, car_pos.z-3.0)),\n            \t\tmapSuspension(vec3(-car_pos.x, car_pos.y, car_pos.z-3.0))))\n    );    \n\n    vec2 t = vec2(t_plane, PlaneId);\n    if (t_hull \t\t< t.x)\tt = vec2(t_hull, HullId);    \n    if (t_tires \t< t.x) \tt = vec2(t_tires, TireId);\n    if (t_rims \t\t< t.x) \tt = vec2(t_rims, RimId);\n    if (t_axels \t< t.x) \tt = vec2(t_axels, AxelId);\n    if (t_buildings < t.x)\tt = vec2(t_buildings, BuildingsId);\n    if (t_sidewalks < t.x)\tt = vec2(t_sidewalks, SidewalksId);\n        \n    return t;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    vec3 e = vec3(0.01, 0, 0);\n    vec3 n = vec3(map(pos+e.xyy).x - map(pos-e.xyy).x,\n                  map(pos+e.yxy).x - map(pos-e.yxy).x,\n                  map(pos+e.yyx).x - map(pos-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 march(vec3 pos, vec3 dir)\n{\n    const float t_min = 0.01;\n    const float t_max = 500.0;\n    \n    vec2 t = vec2(t_min, 0);\t// Small offset, surface id 0\n    \n    for (int i = 0; i < 200; i++)\n    {\n        vec2 res = map(pos + t.x * dir);\n        if ((res.x < 1e-3) || (t.x > t_max)) break;        \n        t.x += res.x;\n        t.y = res.y;\n    }\n    \n    if (t.x > t_max) t.y = 0.0;\n    \n    return t;\n}\n\nvec4 lightingModel(vec3 albedo, float F, float alpha, vec3 N, vec3 L, vec3 V)\n{\n    float a2 \t= alpha * alpha;    \n    float NoL \t= max(dot(N, L), 0.0);\n    vec3 H \t\t= normalize(V + L);\n    float NoH \t= dot(N, H);\n    float denom\t= NoH * NoH * (a2 - 1.0) + 1.0;\n    float D \t= a2 / (3.14159 * denom * denom);       \n    float NoV \t= dot(N, V);    \n    float G_V \t= NoV + sqrt((NoV - NoV * a2) * NoV + a2);\n    float G_L \t= NoL + sqrt((NoL - NoL * a2) * NoL + a2);\n    float ggx \t= D * F / (G_V * G_L);    \n    \n    return vec4(AmbientColor + (albedo + ggx) * NoL * LightColor, 1.0 - F);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 L = vec3(cos(LightAzi) * cos(LightEle), sin(LightEle), sin(LightAzi) * cos(LightEle));\n        \n    vec3 pos = vec3(sin(iTime), 1, 1.0 - getSpeed() * iTime), prev_pos = pos;\n\tvec3 dir = normalize(vec3(fragCoord.xy - iResolution.xy / 2., iResolution.y / 2.) / iResolution.yyy);\n    \n    float angle\t= radians(-170.0);\n    vec3 axis \t= vec3(0, 1, 0);\n    vec4 camRot = makeQuat(axis, angle);\n    \n    dir = rotQuat(camRot, dir);\n    \n    vec4 color = vec4(0, 0, 0, 0);\n    for (int k = 0; k < 4; k++)\n    {\n        vec2 t \t= march(pos, dir);\n        pos \t+= t.x * dir;\n\n        // Fog\n        float d = distance(prev_pos, pos);\n        float fog_factor = exp(-0.02 * d);\n\n        vec3 N = calcNormal(pos);\n\n        // Material properties:\n        //\t- albedo\n        //\t- reflection coefficient in normal direction\n        //\t- roughness\n        vec3 albedo \t= mix(vec3(0.5, 0.6, 0.7),\n                              vec3(0.2, 0.3, 0.9), dir.y) * 2.0;\n        float R0 \t\t= 0.0;\n        float roughness\t= 1.0;\n        if (t.y == PlaneId)\n        {     \n            albedo \t\t= texture(iChannel0, pos.xz * 3.1).xyz * 0.06\n                \t\t+ texture(iChannel0, pos.xz * 1.7).xyz * 0.06\n                \t\t+ texture(iChannel0, pos.xz * 0.9).xyz * 0.06;\n            R0 \t\t\t= 0.01;\n            roughness \t= 0.9;\n        }\n        else if (t.y == HullId)\n        {            \n            albedo \t\t= (pos.y > 0.6 && pos.y < 0.8) ? vec3(0.9, 0.9, 0.95) : vec3(1.0, 0.157, 0.0);\t// Ferrari red\n            R0 \t\t\t= 0.2;\n            roughness \t= 0.6;\n        }\n        else if (t.y == TireId)\n        {\n            vec2 uv \t= vec2(pos.x + iTime, iTime);\n            albedo \t\t= vec3(0.0, 0.0, 0.0) + 0.05 * texture(iChannel2, uv).xyz;\n            R0 \t\t\t= 0.01;\n            roughness \t= 1.0;\n        }\n        else if (t.y == RimId)\n        {\n            albedo \t\t= vec3(0.5, 0.5, 0.5);\n            R0 \t\t\t= 0.9;\n            roughness \t= 0.04;\n        }\n        else if (t.y == AxelId)\n        {\n            albedo \t\t= vec3(0.2, 0.2, 0.2);\n            R0 \t\t\t= 0.4;\n            roughness \t= 0.2;\n        }\n        else if (t.y == BuildingsId)\n        {            \n            vec2 uv \t= floor(vec2(0.5 + pos.x + pos.z, pos.y / 3.0)) * 0.1;\n    \t\tvec3 f \t\t= texture(iChannel2, uv).xyz;\n            vec3 b \t\t= vec3(0.1 + 0.9 * f.x);\n            if (pos.y < 3.0)\n            {                \n                b = pos.y > 0.6 && pos.y < 2.2 ? f : f * 0.4;\n            }                \n            vec3 \t\ta = (mod(pos.y + 0.4, 3.0) < 0.4) ||\n                \t\t\t(fract(pos.x + 0.15) < 0.1) ||\n                \t\t\t(fract(pos.z - 0.5) < 0.1) ? vec3(0.0) : b;\n            albedo \t\t= a;\n            R0 \t\t\t= 0.8 * a.x;\n            roughness \t= 0.1;\n        }\n        else if (t.y == SidewalksId)\n        {\n            albedo \t\t= vec3(0.2, 0.2, 0.2);\n            R0 \t\t\t= 0.01;\n            roughness \t= 0.8;\n        }\n\n        bool primary_ray_hit = t.y > 0.0;\n\n        vec4 c;\n        if (primary_ray_hit)\n        {\n            t = march(pos + 0.01 * N, L);\n\n            bool shadow_ray_hit = t.y > 0.0;\n\n            // Fresnel term\n            vec3 H \t\t= normalize(-dir + L);\n    \t\tfloat NoH \t= dot(N, H);\n            float F \t= R0 + (1.0 - R0) * pow(1.0 - NoH, 5.0);\n            \n            // GGX-Schlick-reflection model\n            c \t= lightingModel(albedo, F, roughness * roughness, N, L, -dir);\n            \n            if(shadow_ray_hit)\n            {\n               c.xyz =  AmbientColor * albedo;\n            }\n            \n            // Apply fog\n            c = mix(vec4(0.5, 0.6, 0.7, 1.0), c, fog_factor);\n        }\n        else\n        {\n            c = vec4(albedo, 1.0);\n        }\n        \n        prev_pos = pos;\n        pos \t+= 0.01 * N;\n        dir \t= reflect(dir, N);\n        color \t+= c * (1.0 - color.w);\n        \n        if (color.w > 0.99) break;\n    }\n    \n\n    // Reinhard tonemapping + simple gamma corrrection\n    float l \t= dot(color.xyz, Luminance);\n    float s \t= l / (1.0 + l);    \n    \n    // Cheap motion blur\n    vec4 prev_color = texture(iChannel1, fragCoord / iResolution.xy);\n\tvec4 curr_color = vec4(pow(s * color.xyz, vec3(0.45)), 1.0);\n    \n    float blur_factor = 1.0 / (1.0 + Speed * 0.01 * iTime);\n    \n    fragColor = blur_factor * curr_color + (1.0 - blur_factor) * prev_color;\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor \t= texture(iChannel0, uv);\n}","name":"Buf B","description":"","type":"buffer"}]}