{"ver":"0.1","info":{"id":"4sByzy","date":"1492625211","viewed":84,"name":"GRAPPROG FINALS - LIM","username":"marcoolim","description":"Miguel Enrico G. Lim\ngrapprog finals","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n#define SWITCH 8\n\n/* \n1- checkered static\n2- lava\n3- clouds\n4- cork board\n5- tartan\n6- twinkling stars\n7- lava lamp with rotating light\n8-\n*/\n\nvec3 red = vec3(1.0, 0.0, 0.0);\nvec3 yellow = vec3(.900, .300, 0.0);\nvec3 blue = vec3(0.0, 0.0, 1.0);\nvec3 green = vec3(0.0, 1.0, 0.0);\t\nvec3 black = vec3(0.0,0.0,0.0);\nvec3 white = vec3(1.0, 1.0, 1.0);\nvec3 orange = vec3(1.0,0.7,0.0);\nvec3 brown = vec3(0.930,0.493,0.502);\nvec3 cyan = vec3(0.0,1.0,1.0);\nvec3 sky = vec3(0.541, 0.729, 0.827);\nvec3 cloud = vec3(0.941, 0.945, 0.941);\nvec3 lava = vec3(0.929, 0.203, 0.572);\n\n\nfloat rand(in vec2 uv) {\n    return fract(sin(dot(uv.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nfloat noise (in vec2 uv) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 uv) {\n    // Initial values\n    float value = 0.0;\n    float amplitud = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitud * noise(uv);\n        uv *= 2.;\n        amplitud *= .5;\n    }\n    return value;\n}\n\n// Value noise\nfloat noise2(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\n// Gradient noise\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat gnoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// Simplex noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nvec3 circle(vec2 uv, vec2 center, float r){\n    float color = distance(center+(noise(uv*6.5+(iTime/1.2))*0.06), uv);\n    return vec3(smoothstep(color, r, 1.0));\n}\n\nfloat circlePoly(vec2 circle, vec2 uv, float r) { \n    float diameter = distance(circle,uv)* 2.0;\n    uv -= circle;\n    float angle = atan(uv.y, uv.x);\n   \tangle += iTime * 2.;\n    r = sin(13.*angle);\n    float color = 1.0 - step(r,diameter);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    float ratio = iResolution.x / iResolution.y;\n    \n    #if (SWITCH == 1)\n    uv *= 0.7;\n    vec3 value = white;\n    //vec3 clouds = vec3(fbm((uv)*15.0))*0.15;\n    vec3 clouds = vec3(fbm((uv * 60. + iTime / 2.)*11.0))*.20;\n    \n    value = mix(value, black,(smoothstep(0.02,0.1,clouds) - smoothstep(0.1, 0.3,clouds)));\n    fragColor = vec4(value, 1.0);\n    #endif\n    \n    #if (SWITCH == 2)\n  \tfloat lava = (fbm(uv  * 30.5 + iTime /2.) * .13);\n    vec3 value = yellow * abs(sin(uv.x + lava *50. + iTime) +.3 );\n    float off = noise(uv * 5. + iTime) * .3;\n    value = mix(value, yellow , off) + mix(value, red , off) * mix(value, red , off) ;\n\tvalue -= red * 0.05;\n    fragColor = vec4(vec3(value),1.0);\n    #endif\n    \n    #if (SWITCH == 3)\n    uv *= 0.7;\n    vec3 value = sky;\n    vec3 clouds = vec3(fbm((uv * 14. + iTime / 2.)*1.0))*.15;\n    value = mix(value, cloud,(smoothstep(0.02,0.1,clouds) - smoothstep(0.1, 0.3,clouds)));\n    fragColor = vec4(value, 1.0);\n    #endif\n    \n    #if (SWITCH == 4)\n    float value = fract(sin(uv.x * uv.y*10000.0) * 10000.0);\n    uv *= 1.0;\n    vec2 idx= floor(uv) + (iTime / 10000.0);\n    value = rand(uv);    \n\tfragColor = vec4(vec3(value) * brown + orange/2.0,1.0);\n    #endif\n    \n    #if (SWITCH == 5)\n    uv *= 2.0 ;\n    uv = fract(uv);\n    vec3 value = red;\n    float blackBox = 0.0;\n    blackBox += step(0.15, uv.x) - step(0.35, uv.x);\n    blackBox += step(0.65, uv.x) - step(0.85, uv.x);\n    blackBox += step(0.15, uv.y) - step(0.35, uv.y);\n    blackBox += step(0.68, uv.y) - step(0.85, uv.y);\n    value = mix(value, black, vec3(blackBox * noise(uv* 100000.)));\n    value = mix(value, green, .7*vec3(fbm(uv.yy*40.)));    \n    value += (noise(uv.x*vec2(5000.0, 20.0) - noise(uv.x*vec2(2000., 60.))) * 0.06);\n    value -= vec3((snoise(uv.x*vec2(600.0, 7.0)) - gnoise(uv.y*vec2(300.0, 1.0))) * 0.1);    \n\tfragColor =vec4(value,1.0);\n    #endif\n    \n    #if (SWITCH == 6)\n    float stars = step(.99, rand(uv)) * ((abs(sin(iTime))) * 1.0)/ 0.5;\n    stars  += step(.999, rand(uv));\n    fragColor = vec4(vec3(stars), 1.0);\n    #endif\n    \n    #if (SWITCH == 7)\n    float lava = (fbm(uv  * 999.5 + iTime /2.) * .13);\n    vec3 value = white * abs(sin(uv.x + lava *30. + iTime) +.3 );\n    float off = noise(uv * 5. + iTime) * .3;\n    value = mix(value, red , off) * mix(value, red , off) / mix(value, blue , off) ;\n\tvalue -= red * 0.5;\n    fragColor = vec4(vec3(value),1.0);\n    #endif\n    \n    #if (SWITCH == 8)\n    vec2 pos = vec2(0.350 * ratio,0.0);\n    uv -= pos;\n    vec3 value = red;\n    value = mix(value, green , .7*vec3(fbm(uv.yy*40.)));\n    value += vec3((snoise(uv.x*vec2(1000.0, 1.0)) - gnoise(uv.y*vec2(300.0, 1.0))) * 1.0) * green; \n    value += circlePoly(vec2(0.3, 0.5), uv, 5.0);\n    \n    fragColor = vec4(vec3(value),1.0);    \n    #endif\n    \n    \n}","name":"Image","description":"","type":"image"}]}