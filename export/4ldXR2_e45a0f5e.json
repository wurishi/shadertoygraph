{"ver":"0.1","info":{"id":"4ldXR2","date":"1480727747","viewed":764,"name":"Path Explorer","username":"KylBlz","description":"Use WASD, Shift, Space, Mouse to explore! Click on screen to start converging.\n1080p render after a few minutes: http://imgur.com/krFXQNu","likes":28,"published":1,"flags":48,"usePreview":0,"tags":["trace","path","explorer","monte","carlo","controls"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* About this thing\n\nThanks to reinder, effie, public_int_i, iq, Tom94, and zackpudil for inspiration\n\n-Buffer A is the path tracer\n-Buffers B,C,D accumulate 4 frames of the RGB channels of Buffer A respectively\n\nThere are still some problems:\n\tThis is just a niave forward path tracer and has such limitations\n\tRandom number distributions are bad\n\tNo real transmission model yet\n\tNo wave nature of light is simulated (plan to use plane-wave)\n\tThe moving average buffers (B, C, D) take up room that could be used for other features like Metropolis Light Transport (keep your eyes peeled for that one!)\n\t\t-Going fullscreen overwrites state pixels, teleporting you\n\n*/\n\n#define tex(a,b) textureLod(a,b,0.)\n#define GAMMA\t\t.3\n\n// tone mapping https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x) {\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), vec3(0), vec3(1));\n}\n\n//reads the state from channel 3\nmat4 getState() {\n    //half pixel\n    vec2 pxSz = 0.5 / iResolution.xy;\n    return mat4(\n        tex(iChannel3, vec2(pxSz.x,1.)),\t //loc\n        tex(iChannel3, vec2(pxSz.x*3.,1.)),\t //vel\n        tex(iChannel3, vec2(1.-pxSz.x,1.)),\t //rot\n        tex(iChannel3, vec2(1.-pxSz.x*3.,1.))//mou\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    mat4 state = getState();\n    \n    //if scene isnt changing\n    if ((iResolution.y < 300. || iMouse.z < 0.) && dot(state[1].xyz, state[1].xyz) < 0.01) {\n        vec4 bufferA = tex(iChannel3, uv);\n        fragColor.rgb = pow(ACESFilm(bufferA.rgb / bufferA.a), vec3(GAMMA));\n    } else {\n        //these are the channels over time\n    \tvec4 st1 = tex(iChannel0, uv),\n        \t st2 = tex(iChannel1, uv),\n\t\t\t st3 = tex(iChannel2, uv);\n    \t//average buffers B through D\n   \t\tfragColor.rgb = pow(ACESFilm(vec3(\n        \tst1.r + st1.g + st1.b + st1.a,\n        \tst2.r + st2.g + st2.b + st2.a,\n        \tst3.r + st3.g + st3.b + st3.a)\n        \t* 0.25), vec3(GAMMA));\n    }\n} //buffers b, c, d, a","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":3,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//TODO:\n//find a physically based material profile and brdf\n//implement opal metamaterial\n//make planes/spheres finite using UV mapping and clipping\n//implement dispersion: multiply fresnel by hit.i.y to calculate probablitiy?\n\n#define MAX_ACCELERATION    16.\n#define MAX_VELOCITY        4.\n#define FRICTION            8.\n\n#define BOUNCE_PXL\t5\n#define SMP_PXL\t\t15\n#define EXPOSURE\t2.\n\n#define minPositive(a, b) (a < b)? zfar: (b < 0.)? (a > 0.)? a: zfar: b\n#define vec3max(a) max(a.x, max(a.y, a.z))\n#define vec3min(a) min(a.x, min(a.y, a.z))\n#define inRange(a,x,b) step(a,x)*step(x,b)\n#define tex(a,b) textureLod(a,b,0.)\n\nconst vec2 KEY_W \t = vec2(87.5 / 256.0, 0.0),\n    \t   KEY_S \t = vec2(83.5 / 256.0, 0.0),\n    \t   KEY_A \t = vec2(65.5 / 256.0, 0.0),\n    \t   KEY_D \t = vec2(68.5 / 256.0, 0.0),\n\t\t   KEY_LEFT  = vec2(37.5 / 256.0, 0.0),\n\t\t   KEY_UP    = vec2(38.5 / 256.0, 0.0),\n\t\t   KEY_RIGHT = vec2(39.5 / 256.0, 0.0),\n\t\t   KEY_DOWN  = vec2(40.5 / 256.0, 0.0),\n    \t   KEY_SHIFT = vec2(16.0 / 256.0, 0.0),\n    \t   KEY_SPACE = vec2(32.0 / 256.0, 0.0);\n\nconst vec4 INIT_POS = vec4(4., 3., -6., 1.),\n    \t   INIT_VEL = vec4(0.),\n    \t   INIT_ROT = vec4(-.3, -.7, 0., 0.),\n    \t   INIT_MOU = vec4(0.);\n\nconst float zfar = 1000.,\n\t\t\teps  = 0.0001,\n    \t\tsml  = 0.001,\n    \t\tsc45 = 0.7071067,\n\t\t    pi_5 = 1.5707963,\n            pi   = 3.1415926,\n    \t\tpi2  = 6.2831853,\n    \t\tpi4  = 12.566368,\n\t\t\tpi_rcp = 0.3183098;\n\n//a: Absorb rgb wavelengths\n//e: Emit rgb wavelengths\n//s: Surface roughness (minimum scatter), surface gloss (maximum scatter)\n//u: sUbsurface minimum scatter, subsurface maximum scatter\n//r: Refractive index\n//eu: Emission Uniformity (0 = mostly paralell photons, 1 = total chaos)\n//d: unique iDentifier\nstruct mat { vec3 a, e; vec2 s, u; float r, eu; int d; };\n//Location, Normal, Info(distance, thickness, nothing), material\nstruct hit { vec3 l, n, i; mat m; };\n//Origin, Direction, Color, current material\nstruct ray { vec3 o, d, c; mat m; };\n//center Location, Radius, Material\nstruct sph { vec3 l; float r; mat m; };\n//Location, Normal, Tangent, Info(size x,y,'depth'), Material\nstruct pln { vec3 l, n, t, i; mat m; };\n//aabb miN, maX, Rotation, Material\nstruct box { vec3 n, x; mat3 r; mat m; };\n\n//useful stuff\nconst mat nullMat = mat(vec3(0.), vec3(0.), vec2(0.), vec2(0.), 0., 0., 0);\nconst hit nullHit = hit(vec3(0.), vec3(0.), vec3(zfar, 0., 0.), nullMat);\n\n////////////////////// random number (distribution sucks)\nfloat hash12( in vec2 p ) {\n\tfloat h = dot(p,vec2(101.7, 683.11));\n    return fract(sin(h)*467.709);\n}\nfloat hash13( in vec3 p ) {\n\tfloat h = dot(p,vec3(571.127, 467.311, 881.521));\n    return fract(sin(h)*467.197);\n}\nvec2 hash22( in vec2 p ) {\n\tvec2 h = vec2(dot(p,vec2(467.127, 881.311)),\n                  dot(p,vec2(7.101, 11.683)));\n    return fract(sin(h)*467.281);\n}\nvec3 hash33( in vec3 p ) {\n\tvec3 h = vec3(dot(p,vec3(467.127, 881.311, 571.521)),\n                  dot(p,vec3(7.101, 11.683, 13.331)),\n                  dot(p,vec3(683.331, 761.101, 823.127)));\n    return fract(sin(h)*467.281);\n}\n\n////////////////////// normal(ish) distribution\nfloat bell12( in vec2 n ) {\n\tfloat r0 = hash12(n + 0.07),\n\t r1 = hash12(n + 0.11);\n\treturn (r0+r1) * 0.5;\n}\nfloat bell13( in vec3 n ) {\n\tfloat r0 = hash13(n + 0.07),\n\t r1 = hash13(n + 0.11);\n\treturn (r0+r1) * 0.5;\n}\nvec3 bell33( in vec3 n ) {\n\tvec3 r0 = hash33(n + 17.07),\n\t r1 = hash33(n + 13.11);\n\treturn (r0+r1) * 0.5;\n}\n\n////////////////////// perlin noise with scale, smoothsteped to 0. - 1.\nfloat fade(float t) { return t * t * t * (t * (t * 6. - 15.) + 10.); }\nfloat pnoise12(vec2 p, float scl) {\n    vec2 i = floor(p*scl),\n     f = fract(p*scl),\n     u = vec2(fade(f.x), fade(f.y)),\n     o = vec2(0., 1.),\n     g00 = hash22(i).xy, g01 = hash22(i + o.xy).xy,\n     g11 = hash22(i + o.yy).xy, g10 = hash22(i + o.yx).xy,\n     d00 = f, d01 = f - o.xy,\n     d11 = f - o.yy, d10 = f - o.yx;\n    float s00 = dot(g00, d00), s01 = dot(g01, d01),\n     s11 = dot(g11, d11), s10 = dot(g10, d10),\n     x1 = mix(s01,s11, u.x), x2 = mix(s00,s10, u.x);\n    return mix(x2, x1, u.y);\n}\n////////////////////// some tools\nvec3 rotateY(vec3 p, float angle) {\n    float c = cos(angle), s = sin(angle);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\nvec3 rotateXY(in vec3 p, in vec2 angle) {\n    vec2 c=cos(angle), s=sin(angle); vec3 o = p;\n    o.yz *= mat2(c.x,s.x,-s.x,c.x);  o.xz *= mat2(c.y,s.y,-s.y,c.y);\n    return o;\n}\nvec3 slerp(in vec3 start, in vec3 end, in float percent) {\n    float dt = dot(start, end), theta = acos(dt)*percent;\n    return start*cos(theta) + normalize(end - start*dt)*sin(theta);\n}\nhit lt(in hit l, in hit r) {\n    if (l.i.x < r.i.x) return l;\n    else return r;\n}\nvec3 rndHemi(in vec3 norm, in vec3 chaos) {\n    vec3 guess = normalize(bell33(chaos + norm)*2.-1.);\n    float negate = step(0., dot(norm, guess))*2.-1.;\n    return guess * negate;\n}\nfloat schlick(in float r1, in float r2, in float vn) {\n    float r0 = (r1 - r2) / (r1 + r2);\n\treturn mix(r0*r0, 1., pow(1. - vn, 5.));\n}\n//use microfacet model?\nfloat getRoughness(in vec3 rd, in mat m, in float rnd) {\n    return clamp(abs(bell13(rd + rnd)*2.-1.) * m.s.y + m.s.x, 0., 1.);\n}\n//need better control\nfloat getEmission(in vec3 rd, in vec3 nrm, in mat m) {\n\treturn pow(clamp(-dot(nrm, rd), m.eu, 1.), 2.);   \n}\n// https://iquilezles.org/articles/texture\nvec4 textureGood(sampler2D sam, in vec2 x, in int bits) {\n\tivec2 p = ivec2(floor(x));\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec4 a = texelFetch(sam, (p+ivec2(0,0)) & bits, 0);\n\tvec4 b = texelFetch(sam, (p+ivec2(1,0)) & bits, 0);\n\tvec4 c = texelFetch(sam, (p+ivec2(0,1)) & bits, 0);\n\tvec4 d = texelFetch(sam, (p+ivec2(1,1)) & bits, 0);\n\treturn mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\n//input is normalized visible spectrum wavelength (0. = 400nm violet/uv, 1. = 700nm red/ir)\nvec3 spectrum(float _l) {\n    float t, l = _l *300.+400.;\n    float[] fr1 = float[] (400.,410.,545.,595.,650.,415.,475.,585.,400.,475.),\n\t\t\tfr2 = float[] (410.,475.,595.,650.,700.,475.,585.,639.,475.,560.),\n        \tdv1 = float[] (10., 65., 50., 55., 50., 60., 115.,54., 75., 85.);\n    vec3[] c = vec3[] (vec3(0.,.33,-.2),vec3(.14,0.,-.13),vec3(0.,1.98,-1.),\n        vec3(.98,.06,-.4),vec3(.65,-.84,.2),vec3(0.,0.,.8), vec3(.8,.76,-.8),\n        vec3(.84,-.84,0.),vec3(0.,2.2,-1.5),vec3(.7,-1.,.3));\n    vec3 r = vec3(0.);\n    for (int i=0; i < 5; i++) { t = (l-fr1[i])/dv1[i];\n        r.r += inRange(fr1[i],l,fr2[i])*(c[i].x + c[i].y*t + c[i].z*t*t); }\n    for (int i=5; i < 8; i++) { t = (l-fr1[i])/dv1[i];\n        r.g += inRange(fr1[i],l,fr2[i])*(c[i].x + c[i].y*t + c[i].z*t*t); }\n    for (int i=8; i < 10; i++) { t = (l-fr1[i])/dv1[i];\n        r.b += inRange(fr1[i],l,fr2[i])*(c[i].x + c[i].y*t + c[i].z*t*t); }\n    return r;\n}\n\n////////////////////// Input\nmat4 getState() {\n    vec2 pxSz = 0.5 / iResolution.xy;\n    return mat4(\n        tex(iChannel0, vec2(pxSz.x,1.)),\t //loc xyz, material\n        tex(iChannel0, vec2(pxSz.x*3.,1.)),\t //vel\n        tex(iChannel0, vec2(1.-pxSz.x,1.)),\t //rot\n        tex(iChannel0, vec2(1.-pxSz.x*3.,1.))//mou\n    );\n}\nvec3 getAcceleration() {\n    return vec3(\n        tex(iChannel1, KEY_D).x - tex(iChannel1, KEY_A).x + tex(iChannel1, KEY_RIGHT).x - tex(iChannel1, KEY_LEFT).x,\n        tex(iChannel1, KEY_SPACE).x - tex(iChannel1, KEY_SHIFT).x,\n        tex(iChannel1, KEY_W).x - tex(iChannel1, KEY_S).x + tex(iChannel1, KEY_UP).x - tex(iChannel1, KEY_DOWN).x\n    );\n}\nbool getInput(inout mat4 state, inout vec4 fragColor, inout vec2 fragCoord) {\n    //shadertoy covers up 3 pixels on each top corner, use them for state storage\n    if (fragCoord.y > iResolution.y - 1.) {\n        //store/read location\n        if (fragCoord.x < 1.) {\n            if (iFrame == 0) fragColor = INIT_POS;\n            else fragColor = vec4(state[0].xyz + state[1].xyz * iTimeDelta, 1.);\n            //collision detection?\n    \t    return true;\n        //store/read velocity\n        } else if (fragCoord.x < 2.) {\n    \t  \tfloat rot = state[2].y;\n    \t    vec3 acc = rotateY(getAcceleration(), rot);\n        \tfragColor = vec4(state[1].xyz + acc * MAX_ACCELERATION * iTimeDelta, 1.);\n            //limit speed\n \t        float speed = length(fragColor.xyz);\n    \t    if (speed > MAX_VELOCITY) fragColor.xyz *= MAX_VELOCITY / speed;\n        \telse if (speed > FRICTION * iTimeDelta) fragColor.xyz *= (speed - FRICTION * iTimeDelta) / speed;\n            else fragColor.xyz = vec3(0.0, 0.0, 0.0);\n\t        return true;\n        //store/read rotation\n        } else if (fragCoord.x > iResolution.x - 1.) {\n        \tif (iMouse.z > 0.) {\n\t\t        vec4 mouse = 2.0 * abs(iMouse) / iResolution.y;\n\t\t        vec4 rot = state[3];\n\t\t\t\tfragColor = vec4(clamp(mouse.y - mouse.w + rot.x, -pi_5, pi_5),\n                                 \t   mouse.x - mouse.z + rot.y, 0.,0.);\n            } else fragColor = state[2];\n            return true;\n        //store/read mouse\n        } else if (fragCoord.x > iResolution.x - 2.) {\n            if (iFrame == 0) fragColor = INIT_ROT;\n            else if (iMouse.z < 0.) fragColor = state[2];\n            else fragColor = state[3];\n            return true;\n        }\n    }\n    return false;\n}\nvoid setInput(inout vec4 fragColor, inout vec2 fragCoord) {\n    //shadertoy covers up 3 pixels on each top corner, use them for state storage\n    if (fragCoord.y > iResolution.y - 1.) {\n        //store/read location\n        if (fragCoord.x < 1.) {\n            fragColor = INIT_POS;\n        //store/read velocity\n        } else if (fragCoord.x < 2.) {\n    \t  \tfragColor = INIT_VEL;\n        //store/read rotation\n        } else if (fragCoord.x > iResolution.x - 1.) {\n        \tfragColor = INIT_ROT;\n        //store/read mouse\n        } else if (fragCoord.x > iResolution.x - 2.) {\n            fragColor = INIT_ROT;\n        }\n    }\n}\n\n////////////////////// Intersection functions\nhit traceSphere(in ray r, in sph s) {\n    vec3 oc = r.o - s.l;\n    float c = dot(oc, oc) - s.r * s.r;\n    float b = dot(oc, r.d),\n\t\t  h = sqrt(b * b - c),\n          d = (h > 0.)? minPositive(-b+h,-b-h): zfar;\n    vec3 l = r.d * d + r.o;\n    return hit(l, (l - s.l) / s.r,\n               vec3(max(0., d), h, 0.), s.m);   \n}\nfloat sdSphere(in ray r, in sph s) {\n    vec3 oc = r.o - s.l;\n    return dot(oc, oc) - s.r * s.r;\n}\n\nhit tracePlane(in ray r, in pln p) {\n    float a = dot(p.n, r.d),\n    \t  d = dot(p.n, p.l - r.o) / a;\n    d = (d < 0. || d > zfar)? zfar: d;\n    return hit(r.o + r.d * d, p.n,\n               vec3(max(0., d), a + 1.0 + p.i.x, 0.), p.m);\n}\n//sdPlane is pointless, you can't be \"inside\" a 2D plane\n\nhit traceBox(in ray r, in box b) {\n    vec3 t1 = (b.n - r.o)/r.d,\n         t2 = (b.x - r.o)/r.d,\n         tn = min(t1, t2), tx = max(t1, t2);\n    float tmin = vec3max(tn),\n    \t  tmax = vec3min(tx),\n   \t\t  f = minPositive(tmax, tmin);\n    vec3 l = r.o + r.d*f*.9999,\n         c = (b.x - b.n)*.5,\n         d = b.n+c-l;\n    return hit(l, step(c,abs(d)), vec3(max(0., f), tmax-tmin, 0.), b.m);\n}\nfloat sdBox(in ray r, in box b) {\n    vec3 s = (b.x - b.n)*.5, //size\n         c = b.n + s, //center\n         d = abs(c - r.o) - s; //displacement\n    return vec3max(d);\n}\n\n////////////////////// Materials\nconst mat\n//conductors\n    _air = mat(vec3(.99), vec3(0.), vec2(0., .7071), vec2(.2), 1.0003, 0., 0),\n\t_gls = mat(vec3(.7,.8,.7), vec3(0.), vec2(0.,.01), vec2(0.), 1.45, 0., 1),\n    _dmn = mat(vec3(.7,.8,.7), vec3(0.), vec2(0.,.01), vec2(0.), 2.42, 0., 2),\n    _smk = mat(vec3(.8), vec3(0.), vec2(0.), vec2(.8), 1.0003, 0., 3),\n//reflective insulator\n    _chr_g = mat(vec3(.8,.8,.8), vec3(0.), vec2(0.), vec2(0.), -1., 0., 10),\n//diffuse insulator\n    _wht = mat(vec3(.9), vec3(0.), vec2(.5,1.), vec2(0.), -1., 0., 20),\n    _red = mat(vec3(.8,.2,.1), vec3(0.), vec2(.5,1.), vec2(0.), -1., 0., 21),\n\t_grn = mat(vec3(.1,.8,.05), vec3(0.), vec2(.5,1.), vec2(0.), -1., 0., 11),\n\t_blu = mat(vec3(.1,.2,.8), vec3(0.), vec2(.5,1.), vec2(0.), -1., 0., 22),\n//emissive\n\t_wht_e = mat(vec3(1.), vec3(1.), vec2(.05,1.), vec2(0.), -1., 1., 30),\n\t_blu_e = mat(vec3(1.), vec3(.01,.05,.75), vec2(.1,.5), vec2(0.), -1., 0., 31),\n\t_red_e = mat(vec3(1.), vec3(.75,.05,.01), vec2(.1,.5), vec2(0.), -1., 0., 32);\n\n////////////////////// Materials who's properties are not constant\nconst mat _meta = mat(vec3(0.), vec3(0.), vec2(0.), vec2(0.), 1., 0., 40);\nmat meta(inout hit h, ray r) {\n    vec2 rap = vec2(atan(h.n.z, h.n.x) + pi, acos(-h.n.y)) / vec2(pi2, pi); //texture map\n    vec3 col = textureGood(iChannel2, rap * 256., 1023).rgb; //use as outside?\n    vec3 ior = normalize(h.n + (col - .5) * 1.9); //instead of changing the normal, just use it for spectrum\n    float wvlngth = clamp(1. + dot(ior, r.d), 0., 1.), //find the wavelength for given angle\n          pattern = step(fract(rap.x * -rap.y * 10.), .5);\n    vec3 fcol = normalize(spectrum(wvlngth * 2.5 - .25)) * 1.414; //wavelength to RGB\n    h.n = normalize(h.n + (col-.5) * .25);\n    return mat(\n        .25 + pattern*.5 + clamp(fcol - .00999, vec3(.01), vec3(.99)),\n    \tvec3(0.),\n        vec2(0., pattern*.5),\n        vec2(0.),\n        1.2 + pattern*10., 0., 40\n    );\n}\nconst mat _tiles = mat(vec3(0.), vec3(0.), vec2(0.), vec2(0.), 1., 0., 41);\nmat tiles(inout hit h, ray r) {\n    vec3 f = textureGood(iChannel3, h.l.xz * 128., 511).rgb; //blue channel is close to lumin. and its lit from above\n    float l = f.b*.9375+.0625, //lumin for bump\n    \t  s = 1. - (smoothstep(f.r-.05, f.r-.15, f.b) + length(f)) * .5; //gloss map\n    h.n = normalize(h.n+vec3((f.g*1.2-f.r),.25,l*1.1-.6)); //change the normal (z from lighting, x fudged from hues)\n    return mat(\n    \tpow(f,vec3(4.))*(1.-s),\n    \tvec3(0.),\n        vec2(s, .7071),\n        vec2(0.),    \n        .0, 0., 41\n    );\n}\nconst mat _lights = mat(vec3(0.), vec3(0.), vec2(0.), vec2(0.), 1., 0., 42);\nmat lights(inout hit h, ray r) {\n    vec3 l = h.l*2.4-1.4; //scale and translate lights\n    float b = (1.+sin(l.x-cos(l.x))) * (1.+sin(l.z-cos(l.z))), //brightness\n          f = step(b, 0.1); //light or mirror\n    return mat(\n    \tvec3(f*.8),\n    \tvec3(1.,.8,.6)*pow(b, 5.)*.01,\n        vec2(1.-f, .1),\n        vec2(0.),\n        -1., 0., 42\n    );\n}\nconst mat _bars = mat(vec3(0.), vec3(0.), vec2(0.), vec2(0.), 1., 0., 43);\nmat bars(inout hit h, ray r) {\n    float lz = fract(h.l.z) * pi2 - pi, //repeat space\n\t\t  sl5 = cos(lz - pi),\n    \t  nm = step(-.7,sl5), //section off metal\n          nw = step(0.,h.l.y)*step(h.l.y,4.), //section off walls\n          w = max(0.,(1.-nm*nw)-(1.-nm)),\n          no = -lz; //adjust normal\n    h.n = (nm > 0.)? h.n: normalize(h.n + vec3(0.,0.,no));\n    vec3 c = (w > 0.)? vec3(.1,.2,.8): vec3(nm*nw*.99+.1); //color walls blue and metal dark\n    return mat(\n    \tc,\n    \tvec3(0.),\n        vec2(0.,w + (1.-nm)*.25),\n        vec2(0.1),\n        nm*2.-1.+nm*.0003, 0., 43\n    );\n}\n\n////////////////////// Primitives\nsph sph1 = sph(vec3(-1.,1.5,-1.5), 1., _blu),\n\tsph2 = sph(vec3(1.5,2.,1.), 1., _meta),\n\tsph3 = sph(vec3(-1.,2.5,1.), .5, _chr_g),\n//lights\n\tlit1 = sph(vec3(-4.,4.5,1.25), .5, _wht_e),\n\tlit2 = sph(vec3(1.5,-.8,-1.5), .2, _blu_e),\n\tlit3 = sph(vec3(-1.,-.8,-3.5), .2, _red_e);\n//planes\npln pln1 = pln(vec3(0.,-1.,0.), vec3(0.,1.,0.), vec3(0., 0., -1), vec3(1.,1.,.1), _tiles),\n    pln2 = pln(vec3(0.,0.,7.5), vec3(0.,0.,-1.), vec3(0., 0., -1), vec3(1.,1.,.1), _wht),\n\tpln3 = pln(vec3(0.,5.,0.), vec3(0.,-1.,0.), vec3(0., 0., -1), vec3(1.,1.,.1), _lights),\n\tpln4 = pln(vec3(15.5,0.,0.), vec3(-1.,0.,0.), vec3(0., 0., -1), vec3(1.,1.,.1), _bars),\n\tpln5 = pln(vec3(-15.5,0.,0.), vec3(1.,0.,0.), vec3(0., 0., -1), vec3(1.,1.,.1), _bars);\n//boxes\nbox box1 = box(vec3(-2., -.99, -.5), vec3(.5, 2., 2.), mat3(0.), _dmn),\n    box2 = box(vec3(0.6, -.99, 0.), vec3(2.5,1.,2.), mat3(0.), _grn),\n    box3 = box(vec3(-2., -.99, -2.5), vec3(0.,.5,-.6), mat3(0.), _red);\n\n//calculates where the ray intersects\nhit traceScene(in ray r) {\n    //trace objects\n    hit ret = lt(tracePlane(r, pln1),\n                 tracePlane(r, pln2));\n    ret = lt(ret,tracePlane(r, pln3));\n    ret = lt(ret,tracePlane(r, pln4));\n    ret = lt(ret,tracePlane(r, pln5));\n    ret = lt(ret,traceSphere(r, lit1));\n    ret = lt(ret,traceSphere(r, lit2));\n    ret = lt(ret,traceSphere(r, lit3));\n    ret = lt(ret,traceSphere(r, sph1));\n    ret = lt(ret,traceSphere(r, sph2));\n    ret = lt(ret,traceSphere(r, sph3));\n    ret = lt(ret,traceBox(r, box1));\n    ret = lt(ret,traceBox(r, box2));\n    ret = lt(ret,traceBox(r, box3));\n\t//mirror normal if needed\n    float nmod = step(dot(r.d, ret.n), 0.)*2.-1.;\n    ret.n *= nmod;\n    return ret;\n}\n\n//mat mapScene(in vec3 l) { }\n\n//updates dynamic materials (ghetto, find better solution)\nvoid updateMaterials(inout hit ret, in ray r) {\n    if (ret.m.d < 40) return;\n    else if (ret.m.d == _meta.d) ret.m = meta(ret, r);\n    else if (ret.m.d == _lights.d) ret.m = lights(ret, r);\n    else if (ret.m.d == _tiles.d) ret.m = tiles(ret, r);\n    else if (ret.m.d == _bars.d) ret.m = bars(ret, r);\n}\n\n//so far refraction doesnt work as intended\nvoid brdf(inout ray r, inout hit res, in float rnd) {\n    //calculate roughness (randomness) of surface\n    float roughness = getRoughness(r.d, res.m, rnd),\n          //calculate view angle of surface\n          ndotr = dot(res.n, -r.d),\n\t\t  //decide the ray's fate\n          sch = schlick(r.m.r, res.m.r, ndotr),\n\t\t  //reflect or refract chance if \n\t\t  ror = step(hash13(r.d - rnd), sch) * 2. - 1.;\n\t//for insulators reduce roughness instead of refracting?\n\tvec3 newDir = (ror < 0.)? refract(r.d, res.n, r.m.r / res.m.r): reflect(r.d, res.n);\n    //new ray properties\n\tr.o = res.l + res.n*eps*ror;\n\tr.d = normalize(mix(newDir, rndHemi(res.n , res.l + rnd), roughness));\n    r.c *= res.m.a; // * (1.-dot(res.n, r.d));\n    if(ror < 0.) r.m = res.m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    mat4 state;\n    //if not the first frame get last state\n    if (iFrame != 0) state = getState();\n    //wtf this is glitchy\n    else { setInput(fragColor, fragCoord); return; }\n    //get input\n    if (getInput(state, fragColor, fragCoord)) return;\n    \n    //ghetto\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.y *= iResolution.y / iResolution.x;\n\t//begin\n    hit res;\n    //final color\n    vec3 final = vec3(0.);\n    //find out what material ray is starting in\n        \n\t//shoot a few rays out of the camera for this pixel\n    for (int j = 0; j < SMP_PXL; j++) {\n        float aa = iTime*sml - float(j*SMP_PXL);\n        //add some sub-pixel noise (anti-aliasing by vibrating the camera)\n    \tvec2 _uv = uv + vec2(bell12(uv.xy - aa), bell12(uv.yx + aa))/(iResolution.y*0.75);    \n        //start the ray at the camera\n        ray r = ray(state[0].xyz, normalize(rotateXY(normalize(vec3(_uv, 1.)), state[2].xy)), vec3(EXPOSURE), _air);\n        //bounce around a few times\n        for (int i = 0; i < BOUNCE_PXL; i++) {\n            //new random seed\n            float rnd = aa + float(i);\n            //trace scene\n            res = traceScene(r);\n            //chance the air refracts the light\n            float rft = hash13(r.d + rnd);\n            //probability increases with distance\n            if (rft < r.m.u.x * sqrt(res.i.x)) {\n                //add emmisive color\n                final += r.m.e * r.c * getEmission(r.d, res.n, r.m);\n                //get random point between ro and dist\n                float d = hash13(r.d - rnd)*res.i.x,\n                      //how much the air changes the ray\n                \t  roughness = getRoughness(r.d, r.m, rnd);\n                //new origin is randomly along ray\n                r.o = r.o + r.d*d;\n                r.d = slerp(r.d, rndHemi(r.d, r.o - rnd), roughness);\n                r.c *= r.m.a;\n                continue;\n            }\n            //if collision\n            if (res.i.x < zfar) {\n                //only update dynamic materials before lighting calculation\n                updateMaterials(res, r);\n                //add colors\n                final += r.c * res.m.e * getEmission(r.d, res.n, res.m);\n                //modify ray properties\n                brdf(r, res, rnd);\n                \n            } else break;\n        }\n    }\n    //final = clamp(final, vec3(0), vec3(1));\n    vec4 lastFrame = tex(iChannel0, fragCoord.xy / iResolution.xy);\n    //either average or sum if not looking or moving or in preview mode\n    if ((iResolution.y < 300. || iMouse.z < 0.) && dot(state[1].xyz, state[1].xyz) < 0.01) {\n        fragColor = vec4(lastFrame.rgb + final, lastFrame.a + 1.);\n    } else {\n \t    fragColor = vec4(final, 1.);\n    }\n} //buffers a, keyboard","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//this is the red channel moving average\n#define tex(a,b) textureLod(a,b,0.)\n\nmat4 getState() {\n    //half pixel\n    vec2 pxSz = 0.5 / iResolution.xy;\n    return mat4(\n        tex(iChannel1, vec2(pxSz.x,1.)),\t //loc\n        tex(iChannel1, vec2(pxSz.x*3.,1.)),\t //vel\n        tex(iChannel1, vec2(1.-pxSz.x,1.)),\t //rot\n        tex(iChannel1, vec2(1.-pxSz.x*3.,1.))//mou\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    mat4 state = getState();\n    vec4 oldState = tex(iChannel0, uv);\n    vec4 curState = tex(iChannel1, uv);\n \tfragColor = vec4(curState.r / curState.a, oldState);\n} //buffers self, a","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//this is the green channel moving average\n#define tex(a,b) textureLod(a,b,0.)\n\nmat4 getState() {\n    //half pixel\n    vec2 pxSz = 0.5 / iResolution.xy;\n    return mat4(\n        tex(iChannel1, vec2(pxSz.x,1.)),\t //loc\n        tex(iChannel1, vec2(pxSz.x*3.,1.)),\t //vel\n        tex(iChannel1, vec2(1.-pxSz.x,1.)),\t //rot\n        tex(iChannel1, vec2(1.-pxSz.x*3.,1.))//mou\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    mat4 state = getState();\n    vec4 oldState = tex(iChannel0, uv);\n    vec4 curState = tex(iChannel1, uv);\n    fragColor = vec4(curState.g / curState.a, oldState);\n} //buffers self, a","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//this is the blue channel moving average\n#define tex(a,b) textureLod(a,b,0.)\n\nmat4 getState() {\n    //half pixel\n    vec2 pxSz = 0.5 / iResolution.xy;\n    return mat4(\n        tex(iChannel1, vec2(pxSz.x,1.)),\t //loc\n        tex(iChannel1, vec2(pxSz.x*3.,1.)),\t //vel\n        tex(iChannel1, vec2(1.-pxSz.x,1.)),\t //rot\n        tex(iChannel1, vec2(1.-pxSz.x*3.,1.))//mou\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    mat4 state = getState();\n    vec4 oldState = tex(iChannel0, uv);\n    vec4 curState = tex(iChannel1, uv);\n    fragColor = vec4(curState.b / curState.a, oldState);\n} //buffers self, a\n","name":"Buffer D","description":"","type":"buffer"}]}