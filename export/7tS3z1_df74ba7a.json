{"ver":"0.1","info":{"id":"7tS3z1","date":"1623341934","viewed":78,"name":"Dancing Floor","username":"Holanderman","description":"Sphere traced sdf","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Thanks Iquizles\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// Thanks Iquizles\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Thanks Iquizles\nfloat opRepBox( in vec3 p, vec3 b, in vec3 c )\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return sdBox( q, b );\n}\n\n// Thanks Iquizles\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \n// Thanks Iquizles\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n\n// For complex scenes features such as as shadows become more difficult in shadertoy since\n// each reflecting / refreacting ray needs to be tested against the rest of the scene,\n// it's for this reason that I'm opting to move the entire scene into a single sdf\nfloat sceneSDF(vec3 testPoint)\n{\n    float cubeSet0Time = iTime;\n    float cubeSet1Time = iTime + 3.14159;\n    float cubeSet2Time = iTime - 2.0;\n    float cubeSet0Y = sin(cubeSet0Time) * 0.25;\n    float cubeSet0X = cos(cubeSet0Time);\n    float cubeSet1Y = sin(iTime * 0.7 + 3.14159) * 0.25;\n    float cubeSet2Y = sin(cubeSet2Time) * 0.25;\n    float cubeSet2z = cos(cubeSet2Time);\n    \n    float sdfSphere = sdSphere(testPoint - vec3(0.0, 1.0, 0.0), 1.0);\n    float frame = sdBoxFrame(testPoint - vec3(0.0, 1.0, 0.0), vec3(4.0, 4.0, 4.0), 0.2);\n    float sdfCubeSet0 = opRepBox(testPoint + vec3(cubeSet0X, cubeSet0Y, 0.0),vec3(0.5, 0.5, 0.5), vec3(2.0, 0.0, 2.0));\n    float sdfCubeSet1 = opRepBox(testPoint + vec3(0.0, cubeSet1Y, 0.0),vec3(0.5, 0.75, 0.5), vec3(2.0, 0.0, 2.0));\n    float sdfCubeSet2 = opRepBox(testPoint + vec3(0.0, cubeSet2Y, cubeSet2z),vec3(0.5, 0.5, 0.5), vec3(2.0, 0.0, 2.0));\n   \n   \n    float sdf = opSmoothUnion(sdfCubeSet0, sdfCubeSet1, 0.2);\n    sdf = opSmoothUnion(sdf, sdfCubeSet2, 0.2);\n    sdf = opSmoothUnion(sdf, sdfSphere, 0.5);\n    sdf = opSmoothUnion(sdf, frame, 0.5);\n    return sdf;\n}\n\n// Thanks Iquizles\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float h = 0.0001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sceneSDF( p + k.xyy*h ) + \n                      k.yyx*sceneSDF( p + k.yyx*h ) + \n                      k.yxy*sceneSDF( p + k.yxy*h ) + \n                      k.xxx*sceneSDF( p + k.xxx*h ) );\n}\n\n\n\n//\n\nbool sphereCast(vec3 rayOrigin, vec3 rayDirection, int iterations, out vec3 hitPosition)\n{\n    const float epsilon = 0.001;\n\n    vec3 currentPosition = rayOrigin;\n    for(int i = 0; i < iterations; ++i)\n    {\n        float distanceFrom = sceneSDF(currentPosition);\n        if(distanceFrom <= epsilon)\n        {\n            hitPosition = currentPosition;\n            return true;\n        }\n        \n        currentPosition += (rayDirection * distanceFrom);\n    }\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 camera_pos = vec3(0.0, 3.0, -7.0);\n    vec3 camera_lookat = vec3(0.0, 0.0, 0.0);\n\n    // Animate camera\n    camera_pos.x += sin(iTime * 0.3) * 5.0;\n    camera_pos.y += sin(iTime * 0.7);\n\n    // Screen\n    vec3 camera_z = normalize(camera_lookat - camera_pos);\n    vec3 camera_x = normalize(cross(vec3(0.0, 1.0, 0.0), camera_z));\n    vec3 camera_y = normalize(cross(camera_z, camera_x));\n\n    float fov_y = 1.0;\n    float fov_x = iResolution.x / iResolution.y;\n    \n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 screen_uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    vec3 pos_on_screen = camera_pos + camera_z + camera_x * fov_x * screen_uv.x + camera_y * fov_y * screen_uv.y;\n\n    vec3 ray_origin = camera_pos;\n    vec3 ray_dir = normalize(pos_on_screen - camera_pos);\n\n    vec3 lightPosition1 = vec3(0.0, 3.0, -1.0);\n    lightPosition1.x += sin(iTime) * 2.0;\n    lightPosition1.z += cos(iTime) * 2.0;\n    \n    // Collect our first ray color\n    vec3 castHitPosition;// The position in worldspace if the sdf intersection\n    if (sphereCast(ray_origin, ray_dir, 64, castHitPosition))\n    {\n        vec3 lightToHitPostitionDirection = normalize(castHitPosition - lightPosition1);\n        // Cast a ray from our lightsource in the direction of the hit point on the sdf\n        vec3 lightHitPosition;\n        bool lightHit = sphereCast(lightPosition1, lightToHitPostitionDirection, 32, lightHitPosition);\n        \n        if(lightHit)\n        {\n            vec3 normal = calcNormal(castHitPosition);\n            float cosAng = dot(-normal, lightToHitPostitionDirection);\n            cosAng = clamp(cosAng, 0.0, 1.0);\n\n            // Hit sphere.\n            fragColor = vec4(vec3(231.0 / 255.0, 236.0 / 255.0, 134.0 / 255.0) * cosAng, 1.0) * float( (distance(lightHitPosition, castHitPosition) < 0.01));\n            fragColor.a = 1.0;\n        }\n    }\n    \n\n\n    fragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"}]}