{"ver":"0.1","info":{"id":"MtXSRn","date":"1433964161","viewed":287,"name":"Box Frames 3","username":"Justaway","description":"Box frames with chromatic dispersion.  Separate rays are casted for the three primary colors with a different index of refraction for each.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#if 1\n\n#define MAXITER 80\n#define MINDIST 0.0001\n#define NORMALSAMPLE 0.01\n#define DISPERSION 0.02\n\n#else\n\n#define MAXITER 20\n#define MINDIST 0.1\n#define NORMALSAMPLE 0.1\n#define DISPERSION 0.05\n\n#endif\n\nmat3 rotX(float a);\nmat3 rotY(float a);\nmat3 rotZ(float a);\nmat3 rot(vec3 z,float a);\nfloat dist(vec3 p);\nvec3 normal(vec3 p);\nvec3 myRefract(vec3 i, vec3 n, float r);\n\nmat3 rotX(float a)\n{\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(1.0,0.0,0.0,0.0,c,-s,0.0,s,c);\n}\n\nmat3 rotY(float a)\n{\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(c,0.0,s,0.0,1.0,0.0,-s,0.0,c);\n}\n\nmat3 rotZ(float a)\n{\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(c,-s,0.0,s,c,0.0,0.0,0.0,1.0);\n}\n\nmat3 rot(vec3 z,float a)\n{\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\tfloat ic=1.0-c;\n\treturn mat3(\n\t\tic*z.x*z.x+c,ic*z.x*z.y-z.z*s,ic*z.z*z.x+z.y*s,\n\t\tic*z.x*z.y+z.z*s,ic*z.y*z.y+c,ic*z.y*z.z-z.x*s,\n\t\tic*z.z*z.x-z.y*s,ic*z.y*z.z+z.x*s,ic*z.z*z.z+c);\n}\n\nfloat dist(vec3 p)\n{\n    float r,r2,d1,d2;\n    float d = 100.0;\n    vec3 pt;\n    \n    r = 0.2;\n    r2 = 0.2;\n    \n    for(int i = 0; i < 5; i++)\n    {\n        pt = rotX(iTime/float(i))*p;\n        pt *= rotZ(iTime/float(i));\n        d1 = max(abs(pt.x),max(abs(pt.y),abs(pt.z))) - r;\n        d2 = max(abs(pt.x),abs(pt.y))-r+r2;\n        d2 = min(d2,max(abs(pt.y),abs(pt.z))-r+r2);\n        d2 = min(d2,max(abs(pt.z),abs(pt.x))-r+r2);\n        d = min(d,max(d1,-d2));\n        r += 0.3;\n    }\n    \n    return d;\n}\n\nvec3 normal(vec3 p, float d)\n{\n    vec3 s=vec3(NORMALSAMPLE,0.0,0.0);\n    return normalize(vec3(\n        dist(p+s.xyy-d),\n        dist(p+s.yxy-d),\n        dist(p+s.yyx-d)));\n}\n\nvec3 myRefract(vec3 i, vec3 n, vec3 r)\n{\n    float d = abs(dot(i,n));\n    return normalize(i+n*abs(dot(i,n))*0.1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /*screen coordinates (sc)*/\n\tvec2 sc = vec2(fragCoord.x-0.5*iResolution.x,fragCoord.y-0.5*iResolution.y);\n    sc /= iResolution.xy;\n    sc.x *= iResolution.x/iResolution.y;\n    \n    /*calculate vectors for raymarching*/\n    vec3 upVec = vec3(0.0,-1.0,0.0);/*up vector is on y-axis*/\n    vec3 lookPos = vec3(0.0,0.0,0.0); /*eye looking at origin*/\n    vec3 eyePos = vec3(0.0,0.0,-5.0); /*eye offset on z-axis*/\n    \n    /*animate camera*/\n    eyePos *= rotX(sin(0.1*iTime));\n    eyePos *= rotY(sin(0.2*iTime));\n    \n    vec3 rayVec = normalize(lookPos - eyePos); /*direction of ray*/\n    \n    /*calculate a vector pointing directly to the left of the eye*/\n    vec3 leftVec = normalize(cross(upVec,rayVec));\n    /*calculate the up for the eye*/\n    vec3 eyeUpVec = normalize(cross(rayVec,leftVec));\n    \n    rayVec *= rot(eyeUpVec,sc.x*0.8);\n    rayVec *= rot(leftVec,sc.y*0.8);\n    \n    /*march ray*/\n    float d;\n    float marchLen;\n    vec3 rayPos = eyePos;\n    vec3 rays[3];\n    vec3 rayDirs[3];\n    \n    rays[0] = eyePos;\n    rays[1] = eyePos;\n    rays[2] = eyePos;\n    \n    rayDirs[0] = rayVec;\n    rayDirs[1] = rayVec;\n    rayDirs[2] = rayVec;\n    \n    float attenuation[3];\n    attenuation[0] = 1.0;\n    attenuation[1] = 1.0;\n    attenuation[2] = 1.0;\n    \n    bool hit[3];\n    hit[0] = false;\n    hit[1] = false;\n    hit[2] = false;\n    \n    vec3 n;\n    \n    for(int i = 0; i < MAXITER; i++)\n    {\n        /* red component*/\n        d = dist(rays[0]);\n        n = normal(rays[0], d);\n        if(d < 0.0 && hit[0] == false)\n        {\n            hit[0] = true;\n            rayDirs[0] = refract(rayDirs[0], n, 1.0/(1.5+DISPERSION));\n            attenuation[0] *= abs(dot(rayDirs[0],n));\n        }\n        else if(d > 0.0 && hit[0] == true)\n        {\n            hit[0] = false;\n            rayDirs[0] = refract(rayDirs[0], -n, 1.0/(1.5+DISPERSION));\n            attenuation[0] *= abs(dot(rayDirs[0],n));\n        }\n        marchLen = max(MINDIST,abs(d));\n        rays[0] += rayDirs[0]*marchLen;\n        \n        /* green component */\n        d = dist(rays[1]);\n        n = normal(rays[1], d);\n        if(d < 0.0 && hit[1] == false)\n        {\n            hit[1] = true;\n            rayDirs[1] = refract(rayDirs[1], n, 1.0/1.5);\n            attenuation[1] *= abs(dot(rayDirs[1],n));\n        }\n        else if(d > 0.0 && hit[1] == true)\n        {\n            hit[1] = false;\n            rayDirs[1] = refract(rayDirs[1], -n, 1.0/1.5);\n            attenuation[1] *= abs(dot(rayDirs[1],n));\n        }\n        marchLen = max(MINDIST,abs(d));\n        rays[1] += rayDirs[1]*marchLen;\n        \n        /* blue component */\n        d = dist(rays[2]);\n        n = normal(rays[2], d);\n        if(d < 0.0 && hit[2] == false)\n        {\n            hit[2] = true;\n            rayDirs[2] = refract(rayDirs[2], n, 1.0/(1.5-DISPERSION));\n            attenuation[2] *= abs(dot(rayDirs[2],n));\n        }\n        else if(d > 0.0 && hit[2] == true)\n        {\n            hit[2] = false;\n            rayDirs[2] = refract(rayDirs[2], -n, 1.0/(1.5-DISPERSION));\n            attenuation[2] *= abs(dot(rayDirs[2],n));\n        }\n        marchLen = max(MINDIST,abs(d));\n        rays[2] += rayDirs[2]*marchLen;\n    }\n    \n    vec4 color;\n    color.r = texture(iChannel0,rayDirs[0]).r*attenuation[0];\n    color.g = texture(iChannel0,rayDirs[1]).g*attenuation[1];\n    color.b = texture(iChannel0,rayDirs[2]).b*attenuation[2];\n    color.a = 1.0;\n\tfragColor = color;\n\n}\n","name":"","description":"","type":"image"}]}