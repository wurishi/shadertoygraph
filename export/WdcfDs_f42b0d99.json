{"ver":"0.1","info":{"id":"WdcfDs","date":"1606227599","viewed":353,"name":"Mouseable Looper Caterpillar","username":"sylvain69780","description":"Use the mouse to make the caterpillar fat or slim, long or short.\nNoob challenges : change the dot patterns of the caterpillar to Diamonds, Squares, Hexagons or Stars.\nChange the size of the Antennas in Common ( l=0.5 variable )","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","distance","bend","joint","caterpillar","kawaii"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Mouseable Looper Caterpillar\n    ----------------------------\n\n    This started from the idea to copy Fabrice\"s Crawl shader but using IQ 2D Joints.\n    I encourage you to modify the code and have fun.\n\n    Related references\n    \n    Joint 2D - distance 2D - IQ\n    https://www.shadertoy.com/view/WldGWM\n\n    Making a smiley in ShaderToy - BigWings aka The Art of Code\n    https://www.youtube.com/watch?v=ZlNnrpM0TRg\n\n    Fab31 #inktober2020 \"crawl\" - Fabrice Neyret\n    https://www.shadertoy.com/view/3d3fRr\n    \n    Hexagonal Maze Flow - Shane \n    https://www.shadertoy.com/view/llSyDh\n    \n*/\n\n#define PI acos(-1.)\n#define TAU 6.283185\n\n#define MAX_ANGLE .7*PI*.5\n#define MIN_ANGLE .1*PI*.5\n\n// Shane dot patterns. Play with it uncomment some lines !!!\nfloat dots(in vec2 p){\n\tp = abs(fract(p) - .5);\n    // return (p.x + p.y)/1.5 + .035; // Diamonds.\n    // return max(p.x, p.y) + .03; // Squares.\n    // return max(p.x*.866025 + p.y*.5, p.y) + .01; // Hexagons.\n    // return min((p.x + p.y)*.7071, max(p.x, p.y)) + .08; // Stars.\n    return length(p); // Circles.\n}\n\n\n// Fork of \"Joint 2D - distance\" by iq. https://shadertoy.com/view/WldGWM\nvec3 sdJoint2DFlat( in vec2 p, in float l, in float a, float w, out vec2 inTop)\n{\n    // if perfectly straight\n    if( abs(a)<0.001 )\n    {\n        float v = p.y;\n        p.y -= clamp(p.y,0.0,l);\n\t\treturn vec3( length(p), p.x, v );\n    }\n    \n    // parameters\n    vec2  sc = vec2(sin(a),cos(a));\n    float ra = 0.5*l/a;\n    \n    // SLC - compute next part coordinates\n    {\n        inTop=p;\n        inTop -=vec2(ra,0.0);\n        inTop*=Rot(a*2.0);\n        inTop -=vec2(-ra,0.0);\n    }\n\n    // recenter\n    p.x -= ra;\n    \n    // reflect\n    vec2 q = p - 2.0*sc*max(0.0,dot(sc,p));\n\n\t// distance\n    float u = abs(ra)-length(q);\n    float d = max(length( vec2(q.x+ra-clamp(q.x+ra,-w,w), q.y) )*sign(-q.y),abs(u) - w);\n\n    // parametrization (optional)\n    float s = sign(a);\n    float v = ra*atan(s*p.y,-s*p.x);\n    u = u*s;\n    \n    return vec3( d, u, v );\n}\n\nvec3 sdCatBody( in vec2 p, in vec4 l, in vec4 a, float w, out vec2 inTop)\n{\n    p = vec2(-p.y,p.x);\n    vec3 duv=vec3(min(length(p-vec2(0.0,-w))-w,sdBox(p-vec2(0.0,-w*0.5),vec2(w,w*0.5))),p); // tail\n    float tl=0.0;\n    for ( int i=0 ; i<4 ; i++ ) {\n        vec3 duv2 = sdJoint2DFlat(p,l[i],a[i],w,inTop);\n        duv2.z+=tl;\n        tl+=l[i];\n        duv = (duv2.x<duv.x) ? duv2 : duv;\n        p=inTop;\n    }\n    vec3 neck=vec3(min(length(p-vec2(0.0,w))-w,sdBox(inTop-vec2(0.0,w*0.5),vec2(w,w*0.5))),inTop);\n    neck.z+=tl;\n    duv = (neck.x<duv.x) ? neck : duv;\n    duv.x-=0.01;  // to avoid separation line / there is propably a smarter way to connect the trunks\n    return duv;\n}\n\n\n// https://www.shadertoy.com/view/3tKGDW\n// All the parametters for an animation pose\nstruct KeyFrame\n{\n    bool  mirror; // inverse the body when the head is pulling\n    float start;  // horizontal draw start position\n    vec4  len;\n    vec4  angles;\n};\n\n\nKeyFrame calcPosition(float time,float l) {\n    float le = 0.4;\n    time=mod(time,4.0); // cycle of 4s \n    KeyFrame res;\n    res.mirror = false;\n    res.len=vec4(le)*(1.0+l);\n    float tlen=dot(res.len,vec4(1.0)); // total length \n\n    // this below means you should start at symetrical position in order to have the animation to work\n    float stride = tlen*(sin(MIN_ANGLE*2.0)/(MIN_ANGLE*2.0)-sin(MAX_ANGLE*2.0)/(MAX_ANGLE*2.0)); \n    res.start=stride-stride*time/4.0+0.3;\n    // The caterpillar start in grouped position and is pushing on its tail.\n    if ( time >= 0.0 && time < 2.0 )\n    {\n        time = fract(time*.5);\n        time = time*time*(3.-2.*time);\n        float a = mix(MAX_ANGLE,MIN_ANGLE,time);\n        float delta = .2*smoothstep(0.,1.0,sin(time*PI));\n        res.angles = vec4(-a-delta,a,a,-a-delta);\n        res.start -= tlen*sin(MIN_ANGLE*2.0)/(MIN_ANGLE*2.0);\n    }\n    // The caterpillar start in elongated position and is pulling on its head.\n    if ( time >= 2.0 && time < 4.0 )\n    {\n        res.mirror = true;\n        time = fract(time*.5);\n        time = time*time*(3.-2.*time);\n        float a = mix(MIN_ANGLE,MAX_ANGLE,time);\n        float delta = .2*smoothstep(0.,1.0,sin(PI*time));\n        res.angles = vec4(-a-delta,a,a,-a+delta*sin(time*PI*5.)); // tail moving \n    }\n    return res;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    vec2 m=vec2(0); // mouse\n    if ( iMouse.x > 0.0 ) {\n        m = (iMouse.xy-0.5*iResolution.xy)/iResolution.xy;\n    }\n    \n    // animation\n\tfloat wi = 0.1+0.1*m.x;\n    uv = uv*0.8-vec2(0.0,-0.6+wi);\n    \n    float time=iTime*1.5;\n    KeyFrame kf=calcPosition(time,m.y);\n    vec2 inTop=vec2(0);\n    float tl = dot(kf.len,vec4(1.0));\n    vec2 p= uv-vec2(kf.start,0.0);\n    vec3 duv = sdCatBody(kf.mirror ? vec2(-p.x,p.y) : p,kf.len,kf.angles,wi,inTop);\n    vec2 inHead = kf.mirror ? vec2(-p.y,p.x) : inTop;\n    duv.z=  ! kf.mirror ? tl-duv.z : duv.z;\n    inHead-=-vec2(0.0,-wi*1.5);\n    vec3 head = vec3(length(inHead)-wi*1.5,inHead/(wi*1.5));\n   \n    // coloring\n\n    vec3 col = vec3(0.15,0.5,0.9); // a basic sky !!         \n    float floor = uv.y+wi;\n    float r=atan(uv.y+0.2,uv.x);\n    col+=vec3(0.9,0.9,0.1)*(1.0-(0.9+0.1*sin(r*10.0+iTime*2.0))*0.7*length(uv));\n    col=mix(col,1.2*vec3(0.6,0.6,0.7),exp(-3.*floor)); // horizon\n    col=mix(col,vec3(0.1,0.9,0.1)*sin(-floor*5.0),smoothstep(0.01,0.0,floor)) ;\n\n    if( duv.x<=0.0 )\n    {\n        vec2 cuv=duv.yz;\n        cuv.x/=wi;\n        vec3 green = vec3(.29,.99,.3);\n        vec3 yellow = vec3(.99,.99,.3);\n        float strips = abs(fract(cuv.y*10.0)-0.5);\n        vec3 bcol = yellow*1.4*smoothstep(0.05,0.20,strips);\n        green*=.7+.3*smoothstep(0.0,0.3,strips); // green segments\n        col = mix(bcol,green,smoothstep(.3,.01,cuv.x));\n        col = mix(col,vec3(0),smoothstep(.15,.05,abs(cuv.x-.01))); // black line\n        if ( cuv.x < 0.0 ) {\n            float y = cos(cuv.x)-0.05;\n\t        float c = 2.*dots(vec2(y,5.*cuv.y));\n\t        col = mix(col,vec3(0.),smoothstep(.90,.75,c));\n            col = mix(col,vec3(1.,.1,.1),smoothstep(.75,.70,c));\n    \t    col = mix(col,yellow*1.5,smoothstep(.50,.45,c));\n        } \n        col *= .3+.7*cos(0.5*PI*cuv.x); // shadow \n        if ( cuv.y > tl+wi ) col *= .3+.7*cos(5.0*PI*(cuv.y-(tl+wi))); // color of the tail\n    }\n    // added head and antenna\n    {\n        float blur = 3.0*3.0/iResolution.x;\n        vec2 uv=head.zy;\n        uv.y=-uv.y;\n        uv/=2.0;\n        vec4 face = Head(uv,blur,time);\n     \tcol = mix(col, face.rgb, face.a);       \n        vec4 antenna = Antenna(vec2(abs(uv.x-.05),uv.y)-vec2(0.20,0.40),blur,sign(uv.x),time);\n        col = mix(col, antenna.rgb, antenna.a); \n    }\n    // outline\n    float d = head.x < duv.x ? head.x : duv.x;\n\tcol = mix( col, vec3(0.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define S(a, b, t) smoothstep(a, b, t)\n#define B(a, b, blur, t) S(a-blur, a+blur, t)*S(b+blur, b-blur, t)\n#define sat(x) clamp(x, 0., 1.)\n\nmat2 Rot(float a) {\n\tfloat s=sin(a);\n\tfloat c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat remap01(float a, float b, float t) {\n\treturn sat((t-a)/(b-a));\n}\n\nfloat remap(float a, float b, float c, float d, float t) {\n\treturn sat((t-a)/(b-a)) * (d-c) + c;\n}\n\nvec2 within(vec2 uv, vec4 rect) {\n\treturn (uv-rect.xy)/(rect.zw-rect.xy);\n}\n\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nvec4 Antenna(vec2 uv,float blur,float side,float time) {\n    vec3 col=vec3(0);\n    float d=length(uv);\n    float a=1.-S(-blur,blur,d-0.06);\n    float l=0.5;\n    float bend=3.14*.25+0.2*sin(time*3.0);\n    float r=l/bend;\n    vec2 sc=vec2(sin(bend),cos(bend));\n    vec2 start = uv-vec2(r,0.0);\n    float d2=sdArc(start,sc,sc,r,0.03);\n    a=max(a,1.-S(-blur,blur,d2));\n    vec2 offset = start*Rot(2.*bend)+vec2(r,0.0);\n    float d3=length(offset);\n    a=max(a,1.-S(-blur,blur,d3-0.1));\n    return vec4(col,a);    \n}\n\nvec4 Mouth(vec2 uv, float blur,float time) {\n    vec3 col=vec3(1.0,0.5,0.5)*.7;\n    uv.y *= 2.9;\n    uv.y-=uv.x*uv.x*(0.8+0.3*sin(time*3.0));\n    float d=length(uv);\n    float a=1.-S(-blur*2.0,blur*2.0,d-.8);\n    float td=length(uv-vec2(0.0,-0.5));\n    col = mix(col,col*1.5, 1.0-S(.4,.6,td));            \n    return vec4(col,a);\n}\n\nvec4 Eye(vec2 uv, float blur, float side) {\n    vec3 col=vec3(0);\n    float d=length(uv);\n    float a=1.-S(-blur,blur,d-.5);\n    float d2=length(uv-vec2(-0.1*side,0.15));\n\tcol = mix(col,vec3(1.),1.-S(-blur,blur,d2-0.15));\n    float d3=length(uv-vec2(0.1*side,-0.15));\n\tcol = mix(col,vec3(1.),1.-S(-blur,blur,d3-0.07));\n    return vec4(col,a);\n}\n\nvec4 Head(vec2 uv,float blur,float time) {\n    vec3 green = vec3(.29,.99,.3);\n    float d=length(uv);\n    vec3 col = green*S(0.5,0.43,d);\n    float a = 1.-S(-blur,blur,d-.5);\n    float edgeShade = remap01(.10,.5,d);\n    edgeShade*=edgeShade;\n    col *= 1.-.5*edgeShade;\n    float factor = 3.0;\n    vec4 eye = Eye((uv-vec2(.33,0.05))*factor,blur*factor,1.0);\n    col = mix(col,eye.rgb,eye.a);\n    eye = Eye((uv-vec2(-0.05,0.05))*factor,blur*factor,1.0);\n    col = mix(col,eye.rgb,eye.a);\n\n    float side = sign(uv.x);\n    uv.x=abs(uv.x);\n    float cheeks = length(uv-vec2(0.25+side*.1,-0.2));\n    col+= vec3(1.0,0.0,0.0) * S(0.15,0.0,cheeks);\n    factor = 5.0;\n    vec4 mouth = Mouth((uv-vec2(0.0+side*.1,-0.30))*factor,blur*factor,time);\n    col = mix(col,mouth.rgb,mouth.a);\n    return vec4(col,a);    \n}\n","name":"Common","description":"","type":"common"}]}