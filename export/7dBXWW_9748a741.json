{"ver":"0.1","info":{"id":"7dBXWW","date":"1620219427","viewed":70,"name":"SDF Mandelbulb rows","username":"Dude","description":"SDF Mandelbulb rows","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdfmandelbulbrows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXIMUM_STEPS 260\n#define DISTANCE_THRESHOLD 0.01\n#define FAR_CLIP 90.0\n\n#define BASE_COLOR vec4(.5, .0, .5, 1)\n#define SPEC_COLOR vec4(0, 1., 0, 1)\n\n\n#define bailout 4.0\n#define iterations 6\n\n// Constants\n#define pi 3.14159265\n\nvoid rX(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.y = c * q.y - s * q.z;\n    p.z = s * q.y + c * q.z;\n}\n\nvoid rY(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.x = c * q.x + s * q.z;\n    p.z = -s * q.x + c * q.z;\n}\n\nvoid rZ(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.x = c * q.x - s * q.y;\n    p.y = s * q.x + c * q.y;\n}\n\nfloat mandelbulb(vec3 pos){\n\tfloat power = float(4.0);\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < iterations; i++){\n\t\tr = length(z);\n\t\tif (r>bailout) break;\n\t\t// Convert to Polar Coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow(r, power-1.0)*power*dr+1.0;\n\t\t// Scale and Rotate the Point\n\t\tfloat zr = pow(r, power);\n\t\ttheta = theta*power + iTime;\n\t\tphi = phi*power + iTime;\n\t\t// Convert Back to Cartesian Coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sphereCopies(vec3 z)\n{\n  vec3 id = fract(z * 1.);\n  z = mod(z,6.);\n  \n  z -= vec3(3.);\n  \n  \n  return mandelbulb(z); // sphere DE\n}\n\nfloat scene(vec3 p){\n    return sphereCopies(p);\n}\n\nfloat nearestSurface(vec3 rp) {\n    rp += vec3(0, 0, 10.);\n    float msd = 9999999.;\n    msd = min(msd, scene(rp)); \n    return msd;\n}\n\nvec4 screenBlend(vec4 a, vec4 b){\n    return 1.-(1.-a)*(1.-b);\n}\n\nvec3 normal(vec3 rp){\n    vec2 e = vec2(0.1,0.);\n    float d = nearestSurface(rp);\n    vec3 n = vec3(\n        d-nearestSurface(rp-e.xyy),\n        d-nearestSurface(rp-e.yxy),\n        d-nearestSurface(rp-e.yyx)\n    );\n    return normalize(n);\n}\n\nvec4 marchRay(vec3 ro, vec3 rd) {\n\n    float d = 10.0; //distance marched\n    vec4 pc = vec4(0.); //pixel colour\n\n    for (int i = 0; i < MAXIMUM_STEPS; ++i) {\n        vec3 rp = ro + rd * d;\n        \n        \n        float ns = nearestSurface(rp);\n        d += ns;\n        \n        if (ns < DISTANCE_THRESHOLD) {\n            vec3 sunPos = vec3(sin(iTime)*-32., 12., cos(iTime)*-32.);\n            vec3 norm = normal(rp);\n            \n            float diffuse = dot(normalize(sunPos), norm);\n            \n            vec3 reflection = reflect(normalize(sunPos), normalize(norm));\n            float specularAngle = max(0.0, dot(reflection, vec3(0,0,1.)));\n            vec4 illuminationSpecular = clamp(pow(specularAngle, 0.01), 0., 0.01) * vec4(1.);\n            \n            vec4 clr = vec4(diffuse) * 0.2;\n            pc = BASE_COLOR + clr + illuminationSpecular;\n            break;\n        }\n        \n        if (d > FAR_CLIP) {\n            break;\n        }\n    }\n\n    return pc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord- .5 * iResolution.xy)/iResolution.y;\n    vec3 rd = normalize(vec3(uv, 2.));\n    rY(rd, iTime* 0.1);\n    vec3 ro = vec3(0, 0, iTime * 10.);\n    \n\tfragColor = marchRay(ro, rd);\n}","name":"Image","description":"","type":"image"}]}