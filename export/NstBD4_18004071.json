{"ver":"0.1","info":{"id":"NstBD4","date":"1656745883","viewed":239,"name":"Sigmoid curve color correction","username":"dougfractal","description":"A tone colour editor using a Sigmoid curve  \n","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["contrast","colorcorrection","tool","tonecurve"],"hasliked":0,"parentid":"WttyDs","parentname":"Tone curve"},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define LINK_RGB 1\n#define MAX_ADJ 4.0 \n\n/* Sigmoid Contrast (Adjustable) \nTags: curve, cubic, sigmoid, lut, exposure\nCreated by Loadus  https://www.shadertoy.com/view/MlXGRf\n*/\nfloat SCurve (float value, float amount, float correction) {\n\t float  curve = (value < 0.5) ? pow(value, amount) * pow(2.0, amount) * 0.5 :\n                    1.0 - pow(1.0 - value, amount) * pow(2.0, amount) * .5;\n    return pow(curve, correction);\n}\n///////////////\n    \n\n\n/* \nGUI moddifided from Tone curve \nTags: contrast, colorcorrection, tool, tonecurve\nCreated by iY0Yi https://www.shadertoy.com/view/WttyDs\n*/\n\nvec3 drawTCGraph(vec2 gv, float low, float lmid, float mid, float hmid, float high ,float vhigh ,vec2 sc_r, vec2 sc_g, vec2  sc_b ){    \n          \n      // curves\n        vec3 curve = vec3(1.);\n        curve.r  =SCurve (gv.x, sc_r.x, sc_r.y);\n        curve.g  =SCurve (gv.x, sc_g.x, sc_g.y);\n        curve.b  =SCurve (gv.x, sc_b.x, sc_b.y);\n        curve = sms(.01,.012,abs(curve-gv.y));\n     \n   \n     // grid\n       vec3 line = vec3(1.);\n        line *= sms(.005,.0055,abs(0.001-gv.x));\n        line *= sms(.0,.0025,abs(0.2-gv.x));\n        line *= sms(.0,.0025,abs(0.4-gv.x));\n        line *= sms(.0,.0025,abs(0.6-gv.x));\n        line *= sms(.0,.0025,abs(0.8-gv.x));\n        line *= sms(.005,.0055,abs(.999-gv.x));\n\n        line *= sms(.005,.0055,abs(0.001-gv.y));\n        line *= sms(.0,.0025,abs(0.2-gv.y));\n        line *= sms(.0,.0025,abs(0.4-gv.y));\n        line *= sms(.0,.0025,abs(0.6-gv.y));\n        line *= sms(.0,.0025,abs(0.8-gv.y));\n        line *= sms(.005,.0055,abs(.999-gv.y));\n\n    \n    vec3 hndls = vec3(1.0);\n    \n    // outline handle\n    hndls /= sms(0.002,0.003,abs(.023-distance(gv, vec2(.01, low+.0))));\n    hndls /= sms(0.002,0.003,abs(.023-distance(gv, vec2(.2, lmid+.2))));\n    hndls /= sms(0.002,0.003,abs(.023-distance(gv, vec2(.4, mid+.4))));\n    hndls /= sms(0.002,0.003,abs(.023-distance(gv, vec2(.6, hmid+.6))));\n    hndls /= sms(0.002,0.003,abs(.023-distance(gv, vec2(.8, high+.8))));\n    hndls /= sms(0.002,0.003,abs(.023-distance(gv, vec2(.99, vhigh+1.))));\n    \n    //fill handle \n    hndls.r *= (sms(.02,.022, distance(gv, vec2(0.01, low))));\n    hndls.r *= sms(.02,.022, distance(gv, vec2(.2, lmid+.2)));\n    hndls.g *= sms(.02,.022, distance(gv, vec2(.4, mid+.4)));\n    hndls.g *= sms(.02,.022, distance(gv, vec2(.6, hmid+.6)));\n    hndls.b *= sms(.02,.022, distance(gv, vec2(.8, high+.8)));\n    hndls.b *= sms(.02,.022, distance(gv, vec2(.99, vhigh+1.)));\n\n    return line * hndls * curve ;\n}\n\n\n // from https://iquilezles.org/articles/distfunctions\nfloat BoxSDF(vec2 CenterPosition, vec2 Size) {\n    return  step(1.,length(max(abs(CenterPosition)-Size,0.0)));\n }\n////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    #define fetch(st) u2s(texture(iChannel1, vec2(st,0)).r)*.5\n\n    float low = fetch(.5-.5*iResolution.y/iResolution.x);\n    float lmid = fetch(.5-.3*iResolution.y/iResolution.x);\n#if LINK_RGB \n    float mid = low - .4; \n    float hmid = lmid -.4; \n\tfloat high = low- .8; \n    float vhigh = lmid -.8; \n#else \n    float mid = fetch(.5-.1*iResolution.y/iResolution.x);\n    float hmid = fetch(.5+.1*iResolution.y/iResolution.x);\n\tfloat high = fetch(.5+.3*iResolution.y/iResolution.x);\n    float vhigh = fetch(.5+.5*iResolution.y/iResolution.x);\n#endif\n\n\n\n\t\n    vec2 uv = fragCoord.xy / (iResolution.xy -.5);\n    vec2 nuv = normalizeUVx(fragCoord.xy/iResolution.xy, iResolution.xy);\n   \n\n    // Applies an S curve to the image, you can adjust the steepness\n    // of the curve with the control values SCurve(input, steepness, gamma)\n    vec2 lowrange = vec2( 1.0  , 2.0);\n    vec2 lmidrange = vec2( 0.8  , 1.8);\n    vec2 midrange = vec2( 0.6  , 1.6);\n    vec2 hmidrange = vec2( 0.4  , 1.4);\n    vec2 highrange = vec2( 0.2  , 1.2);\n    vec2 vhighrange = vec2( 0.0  , 1.0);\n  \n  \n  vec2 sc_r = (vec2( low - lowrange.x, lmid - lmidrange.x) +1.) * MAX_ADJ;\n  vec2 sc_g = (vec2(mid- midrange.x, hmid - hmidrange.x) +1.) * MAX_ADJ;\n  vec2 sc_b = (vec2(high- highrange.x, vhigh- vhighrange.x) +1.) * MAX_ADJ;\n \n vec3 tex = vec3(0.); \n  \n // split texture into 4  using step fn\n // The pixel space scale of the rectangle.\n \n # define box BoxSDF(fragCoord.xy - location , size)\n vec2 size =  iResolution.xy *.25;\n        \n// the pixel space location of the rectangle.\nvec2 location = vec2(iResolution.x *.25, iResolution.y *.75); \n tex.r = mix(texture(iChannel0,vec2( uv.x,uv.y-1.)*2. ).r, tex.r, box );\n     \nlocation = vec2(iResolution.x *.25, iResolution.y *.25); \ntex.b  = mix(texture(iChannel0, uv *2.   ).b, tex.b ,box );\n\n location = vec2(iResolution.x *.75, iResolution.y *.75); \ntex.g  = mix(texture(iChannel0, (uv-.5)*2. ).g, tex.g ,box );\n\nlocation = vec2(iResolution.x *.75, iResolution.y *.25); \ntex  = mix(texture(iChannel0, vec2( uv.x-1. , uv.y)*2.  ).rgb, tex ,box );\n\n /*\n // split texture into 4  using ifs\n    if (uv.x<.5)  {\n     if (uv.y>.5)\n       tex.r = texture(iChannel0,vec2( uv.x / .5,( uv.y-.5)/.5 )  ).r;\n        else \n        tex.b = texture(iChannel0,( uv)/ (.5 )  ).b;  \n       }\n    else {\n       if (uv.y>.5)\n       tex.g = texture(iChannel0,( uv-.5)/ (.5 )  ).g; \n       else \n       tex = texture(iChannel0, vec2( (uv.x-.5 )/ .5, uv.y/.5) ).rgb; // + vec2(uv.x/.5, 0) )  ).rgb;\n    }\n*/\n\n\n  tex = vec3(SCurve(tex.r,sc_r.x, sc_r.y), SCurve(tex.g,sc_g.x, sc_g.y ), SCurve(tex.b,sc_b.x, sc_b.y )); \n\n\n\n\n/*\n//  Split tex diaganonally to compare\ntex = mix(vec3(SCurve(tex.r,sc_r.x, sc_r.y), SCurve(tex.g,sc_g.x, sc_g.y ), SCurve(tex.b,sc_b.x, sc_b.y )), tex, step((uv.x+uv.y)/2., 0.5 )); \n*/\n \n /*\n // Vibrance and Exposure adjust compare\n \n  if (uv.x + uv.y <1. && uv.x - uv.y > 0.  )  {\n    tex = vibrance(tex, 4.);  \n  //  adjustExposure\n    tex = tex * pow(2., .150);\n }\n */\n \n \n vec3 gui = drawTCGraph(nuv , low, lmid, mid, hmid, high ,vhigh, sc_r, sc_g,sc_b) ;//step(.0,nuv.x );\n // crop gui\n gui =  mix( vec3(1.) , gui , step(abs(nuv.x-.5),.5 )); \n\n //overlay gui\n tex = mix( vec3(1.,0,0) ,tex  , gui.r);  \n tex = mix( vec3(0,1.,0) ,tex  , gui.g);\n tex = mix( vec3(0,0,1.) ,tex  ,gui.b); \n tex = mix( vec3( 1.),tex, gui);\n  \n // text output\n float pixel = text(fragCoord.xy,sc_r,sc_g,sc_b , iResolution.xy);\n  \n fragColor = vec4(mix(tex, vec3(.0,1.,.0), pixel) ,1.0);\n    \n    \n  // fragColor = texture(iChannel1, uv );\n    \n    }","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = normalizeUVx(fragCoord.xy/iResolution.xy, iResolution.xy);\n    vec2 mou = normalizeUVx(iMouse.xy/iResolution.xy, iResolution.xy);\n  \n    const float THRES = .08;  \n    #define isIn(pos, mou) uv.x >= pos-THRES && uv.x < pos+THRES  && mou >= pos-THRES && mou< pos+THRES \n    #define barColor(val) vec4( .5 - uv.x+.25*val, .25*val, 0, 1)\n    #define drawBar(val , pos) fragColor = mix(barColor(val), fragColor, step (THRES,  abs(uv.x-pos) ))     \n \n   \n    if(iFrame<=10){\n      fragColor = vec4( (1.- uv.x)-.25,.25, 0, 1);          \n      drawBar(3.9 , .0) ; \n      drawBar(1.0 , .2) ; \n      drawBar(3.7 , .4) ; \n      drawBar(.7 , .6) ; \n      drawBar(2.6 , .8) ;\n      drawBar(.6 , 1.) ;\n      return;\n    }\n    \n  fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    //vec4 col; \n\n  if (iMouse.z>.5 && abs(mou.y-fragColor.y) <THRES/2.) {\n     mou.y *= 4.;  \n      \n     if (isIn (.0, mou.x)) \n        drawBar(mou.y , .0);  \n     else if (isIn(.2, mou.x))  \n        drawBar(mou.y , .2);        \n     else if (isIn(.4, mou.x))\n        drawBar(mou.y  , .4);       \n     else if (isIn(.6, mou.x)) \n        drawBar(mou.y  , .6); \n     else if (isIn(.8, mou.x))  \n        drawBar(mou.y  , .8);\n     else if (isIn(1., mou.x)) \n        drawBar(mou.y  , 1.);\n     \n    \n         \n  }\n  \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define sat(x) clamp(x, 0.0, 1.0)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n\nvec2 normalizeUVx(vec2 uv, vec2 res){\n    uv.x*=res.x/res.y;\n    uv.x-=.5*res.x/res.y-.5;\n    return uv;\n}\n\n// Interpolation funcs from:\n// https://www.shadertoy.com/view/MsXGDj\nfloat tcCatmullRom(float x, float v0,float v1, float v2,float v3){\n    if(abs(v1-v2)<.001)return v1; // edited\n    float c2 = -.5 * v0\t+ 0.5*v2;\n\tfloat c3 = v0\t\t+ -2.5*v1 + 2.0*v2 + -.5*v3;\n\tfloat c4 = -.5 * v0\t+ 1.5*v1 + -1.5*v2 + 0.5*v3;\n\treturn (((c4 * x + c3) * x + c2) * x + v1);\n}\nfloat tcThirdOrderSpline(float x, float L1,float L0, float H0,float H1){\n\treturn \t\t  L0 +.5 *\n\t\t\tx * ( H0-L1 +\n\t\t\tx * ( H0 + L0 * -2.0 +  L1 +\n\t\t\tx * ((H0 - L0)* 9.0\t + (L1 - H1)*3.0 +\n\t\t\tx * ((L0 - H0)* 15.0 + (H1 - L1)*5.0 +\n\t\t\tx * ((H0 - L0)* 6.0\t + (L1 - H1)*2.0 )))));\n}\nfloat tcCubic(float x, float v0,float v1, float v2,float v3){\n\tfloat p = (v3 - v2) - (v0 - v1);\n\treturn p*(x*x*x) + ((v0 - v1) - p)*(x*x) + (v2 - v0)*x + v1;\n}\nfloat tcSmoothstep(float x, float v0, float v1, float v2,float v3){\n\tx = x*x*(3.0-2.0*x);\n\treturn (v2-v1)*x + v1;\n}\nfloat tcLinear(float x, float v0, float v1, float v2,float v3){\n\treturn (v2-v1)*x + v1;\n}\n\n#define INTP tcCatmullRom\n\n\n\n///// Text \n#define DOWN_SCALE 1.0\n\n#define MAX_INT_DIGITS 4\n\n#define CHAR_SIZE vec2(8, 12)\n#define CHAR_SPACING vec2(8, 12)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n#define NORMAL 0\n#define INVERT 1\n#define UNDERLINE 2\n\nint TEXT_MODE = NORMAL;\n\n/*\n--------\n-###----\n##-##---\n##-##---\n-###----\n#####-#-\n##-####-\n##--##--\n##-###--\n-###-##-\n--------\n--------\n\n00000000\n01110000\n11011000\n11011000\n01110000\n11111010\n11011110\n11001100\n11011100\n01110110\n00000000\n00000000\n\n//Broken up into 4 8x3 (24 bit) chunks for each component of the vec4.\n//Hexadecimal is being used to reduce clutter in the code but decimal still works.\n\n00000000\n01110000 -> 00000000 01110000 11011000 -> 0x0070D8\n11011000\n\n11011000\n01110000 -> 11011000 01110000 11111010 -> 0xD870FA\n11111010\n\n11011110\n11001100 -> 11011110 11001100 11011100 -> 0xDECCDC\n11011100\n\n01110110\n00000000 -> 01110110 00000000 00000000 -> 0x760000\n00000000\n\nvec4(0x0070D8,0xD870FA,0xDECCDC,0x760000)\n*/\n\n//Automatically generated from the 8x12 font sheet here:\n//http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n\nvec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000);\nvec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000);\nvec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000);\nvec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000);\nvec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000);\nvec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000);\nvec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000);\nvec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000);\nvec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000);\nvec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000);\nvec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000);\nvec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000);\nvec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000);\nvec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000);\nvec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000);\nvec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000);\nvec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000);\nvec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000);\nvec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000);\nvec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000);\nvec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000);\nvec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000);\nvec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000);\nvec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000);\nvec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000);\nvec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000);\nvec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000);\nvec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000);\nvec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000);\nvec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000);\nvec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000);\nvec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000);\nvec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000);\nvec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000);\nvec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000);\nvec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000);\nvec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000);\nvec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000);\nvec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000);\nvec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000);\nvec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000);\nvec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000);\nvec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000);\nvec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000);\nvec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000);\nvec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000);\nvec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000);\nvec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000);\nvec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000);\nvec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00);\nvec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000);\nvec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000);\nvec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000);\nvec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000);\nvec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000);\nvec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000);\nvec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000);\nvec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000);\nvec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000);\nvec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000);\nvec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000);\nvec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000);\nvec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000);\nvec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00);\nvec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000);\nvec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000);\nvec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000);\nvec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000);\nvec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000);\nvec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000);\nvec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78);\nvec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000);\nvec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000);\nvec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78);\nvec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000);\nvec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000);\nvec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000);\nvec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000);\nvec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000);\nvec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0);\nvec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E);\nvec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000);\nvec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000);\nvec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000);\nvec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000);\nvec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000);\nvec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000);\nvec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000);\nvec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0);\nvec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000);\nvec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000);\nvec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000);\nvec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000);\nvec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000);\nvec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n\nvec2 res = vec2(0);\nvec2 print_pos = vec2(0);\n\n//Extracts bit b from the given number.\n//Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat extract_bit(float n, float b)\n{\n    b = clamp(b,-1.0,24.0);\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(vec4 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    \n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));\n    \n    float pixels = 0.0;\n    pixels += extract_bit(spr.x, bit - 72.0);\n    pixels += extract_bit(spr.y, bit - 48.0);\n    pixels += extract_bit(spr.z, bit - 24.0);\n    pixels += extract_bit(spr.w, bit - 00.0);\n    \n    return bounds ? pixels : 0.0;\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat char(vec4 ch, vec2 uv)\n{\n    if( TEXT_MODE == INVERT )\n    {\n      //Inverts all of the bits in the character.\n      ch = pow(2.0,24.0)-1.0-ch;\n    }\n    if( TEXT_MODE == UNDERLINE )\n    {\n      //Makes the bottom 8 bits all 1.\n      //Shifts the bottom chunk right 8 bits to drop the lowest 8 bits,\n      //then shifts it left 8 bits and adds 255 (binary 11111111).\n      ch.w = floor(ch.w/256.0)*256.0 + 255.0;  \n    }\n\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\n\n//Returns the digit sprite for the given number.\nvec4 get_digit(float d)\n{\n    d = floor(d);\n    \n    if(d == 0.0) return ch_0;\n    if(d == 1.0) return ch_1;\n    if(d == 2.0) return ch_2;\n    if(d == 3.0) return ch_3;\n    if(d == 4.0) return ch_4;\n    if(d == 5.0) return ch_5;\n    if(d == 6.0) return ch_6;\n    if(d == 7.0) return ch_7;\n    if(d == 8.0) return ch_8;\n    if(d == 9.0) return ch_9;\n    return vec4(0.0);\n}\n\n\n// vibrance\n\n// https://www.shadertoy.com/view/llGSzK\nconst int BIT_COUNT = 32;\n\nint modi(int x, int y) {\n    return x - y * (x / y);\n}\n\nint and(int a, int b) {\n    int result = 0;\n    int n = 1;\n\n    for(int i = 0; i < BIT_COUNT; i++) {\n        if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {\n            result += n;\n        }\n\n        a = a / 2;\n        b = b / 2;\n        n = n * 2;\n\n        if(!(a > 0 && b > 0)) {\n            break;\n        }\n    }\n    return result;\n}\n\n\n\n\nvec3 vibrance(vec3 inCol, float vibrance) //r,g,b 0.0 to 1.0,  vibrance 1.0 no change, 0.0 image B&W.\n{\n       //float rf, gf, bf;\n \n       //rf = *r;\n       //gf = *g;\n       //bf = *b;\n \tvec3 outCol;\n    if (vibrance <= 1.0)\n    {\n        float avg = (inCol[0]*0.3 + inCol[1]*0.6 + inCol[2]*0.1);\n        //outCol = inCol * avg;\n        outCol[0] = inCol[0] * vibrance + avg*(1.0 - vibrance);\n        outCol[1] = inCol[1] * vibrance + avg*(1.0 - vibrance);\n        outCol[2] = inCol[2] * vibrance + avg*(1.0 - vibrance);\n    }\n    else // vibrance > 1.0\n    {\n        float hue_a, a, f, p1, p2, p3, i, h, s, v, amt, _max, _min, dlt;\n        float br1, br2, br3, br4, br5, br2_or_br1, br3_or_br1, br4_or_br1, br5_or_br1;\n        int use;\n\n        _min = min(min(inCol[0], inCol[1]), inCol[2]);\n        _max = max(max(inCol[0], inCol[1]), inCol[2]);\n        dlt = _max - _min + 0.00001 /*Hack to fix divide zero infinities*/;\n        h = 0.0;\n        v = _max;\n\n\t\tbr1 = 1.0 - float(_max > 0.0);\n        s = (dlt / _max)*(1.0 - br1);\n        h = -1.0*br1;\n\n        br2 = float((_max - inCol[0]) > 0.0);\n        br2_or_br1 = max(br2, br1);\n        h = ((inCol[1] - inCol[2]) / dlt)*(1.0 - br2_or_br1) + (h*br2_or_br1);\n\n        br3 = float((_max - inCol[1]) > 0.0);\n\n        \n        br3_or_br1 = max(br3, br1);\n        h = (2.0 + (inCol[2] - inCol[0]) / dlt)*(1.0 - br3_or_br1) + (h*br3_or_br1);\n\n        br4 = 1.0 - br2*br3;\n        br4_or_br1 = max(br4, br1);\n        h = (4.0 + (inCol[0] - inCol[1]) / dlt)*(1.0 - br4_or_br1) + (h*br4_or_br1);\n\n        h = h*(1.0 - br1);\n\n\n        hue_a = abs(h); // between h of -1 and 1 are skin tones\n        a = dlt;      // Reducing enhancements on small rgb differences\n\n        a = float(hue_a < 1.0)*a*(hue_a*0.67 + 0.33) + float(hue_a >= 1.0)*a;       //Reduce the enhancements on skin tones.                                        \n        a *= (vibrance - 1.0);\n        s = (1.0 - a) * s + a*pow(s, 0.25);\n\n\n\n        i = floor(h);\n        f = h - i;\n\n        p1 = v * (1.0 - s);\n        p2 = v * (1.0 - (s * f));\n        p3 = v * (1.0 - (s * (1.0 - f)));\n\n        inCol[0] = inCol[1] = inCol[2] = 0.0;\n        i += 6.0;\n        //use = 1 << ((int)i % 6);\n        use = int(pow(2.0,mod(i,6.0)));\n        a = float(and(use , 1)); // i == 0;\n        use /= 2;\n        inCol[0] += a*v;\n        inCol[1] += a*p3;\n     \tinCol[2] += a*p1;\n \n        a = float(and(use , 1)); // i == 1;\n        use /=2;\n        inCol[0] += a*p2;\n        inCol[1] += a*v;\n        inCol[2] += a*p1;\n\n        a = float( and(use,1)); // i == 2;\n        use /=2;\n        inCol[0] += a*p1;\n        inCol[1] += a*v;\n        inCol[2] += a*p3;\n\n        a = float(and(use, 1)); // i == 3;\n        use /= 2;\n        inCol[0] += a*p1;\n        inCol[1] += a*p2;\n        inCol[2] += a*v;\n\n        a = float(and(use, 1)); // i == 4;\n        use /=2;\n        inCol[0] += a*p3;\n        inCol[1] += a*p1;\n        inCol[2] += a*v;\n\n        a = float(and(use, 1)); // i == 5;\n        use /=2;\n        inCol[0] += a*v;\n        inCol[1] += a*p1;\n        inCol[2] += a*p2;\n\n        outCol = inCol;\n        //*r = rf;\n        //*g = gf;\n        //*b = bf;\n    }\n    return outCol;\n}\n\n\n\n//Prints out the given number starting at pos.\nfloat print_number(float number, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = 4;i >= -1;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n        \n        if(i == -1) //Add a decimal point.\n        {\n            result += char(ch_per,uv);\n        }\n        \n        if(abs(number) > pow(10.0, float(i)) || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\nfloat print_integer(float number, int zeros, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = MAX_INT_DIGITS;i >= 0;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n\n        if(abs(number) > pow(10.0, float(i)) || zeros > i  || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\nfloat text(vec2 uv, vec2 sc_r,vec2  sc_g,vec2  sc_b, vec2 res)\n{\n    float col = .0;\n    \n   // vec2 center = res/2.0;\n   // uv -= center; \n    print_pos = vec2(2, 2.0 + STRHEIGHT(2.0));\n    \n    TEXT_MODE = INVERT;\n \n    col += char(ch_R, uv);\n    col += char(ch_e, uv);\n    col += char(ch_d, uv);\n    \n    \n    TEXT_MODE = NORMAL;\n    col += char(ch_col, uv);\n    col += char(ch_spc, uv);\n    col += char(ch_spc, uv);\n    \n  //  TEXT_MODE = UNDERLINE;\n    \n    col += print_number(sc_r.x, uv);\n    col += char(ch_spc, uv);\n    col += print_number(sc_r.y, uv);\n    \n    //Time Text\n    \n    print_pos = vec2(2, 2.0 + STRHEIGHT(1.0));\n    \n    TEXT_MODE = INVERT;\n    col += char(ch_G, uv);\n    col += char(ch_r, uv);\n    col += char(ch_e, uv);\n    col += char(ch_e, uv);\n    col += char(ch_n, uv);\n    \n    TEXT_MODE = NORMAL;\n    col += char(ch_col, uv);\n    \n      \n  //  TEXT_MODE = UNDERLINE;\n    \n    col += print_number(sc_g.x, uv);\n    col += char(ch_spc, uv);\n    col += print_number(sc_g.y, uv);\n    \n    \n    print_pos = vec2(2, 2.0 + STRHEIGHT(0.0));\n    \n    TEXT_MODE = INVERT;  \n    col += char(ch_B, uv);\n    col += char(ch_l, uv);\n    col += char(ch_u, uv);\n    col += char(ch_e, uv);\n    \n    \n    TEXT_MODE = NORMAL;\n    col += char(ch_col, uv);\n    col += char(ch_spc, uv);\n      \n  //  TEXT_MODE = UNDERLINE;\n    \n    col += print_number(sc_b.x, uv);\n    col += char(ch_spc, uv);\n    col += print_number(sc_b.y, uv); \n    \n    print_pos = vec2(2, 2.0 + STRHEIGHT(0.0));\n    \n    return col;\n}\n\n","name":"Common","description":"","type":"common"}]}