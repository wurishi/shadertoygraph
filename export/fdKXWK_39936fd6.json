{"ver":"0.1","info":{"id":"fdKXWK","date":"1635350266","viewed":106,"name":"twin dragon curve","username":"fpsunflower","description":"An implementation of the twin dragon fractal by decomposing gaussian integers into binary digits in base -1+i.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fractal","dragon","gaussian","integers"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Inspired by this nice video: https://youtu.be/zJSBL1XWFDc\n// Every integer in the complex plane can be turned into a natural number n\n// Consecutive values of n follow an interesting fractal pattern that tiles the plane\n\n#define AA 3\n#define MAXBITS 64 // anything > 31 will overflow an int - but we don't actually use the value of n here\n\nvec2 rand(uvec2 v)\n{\n    // https://www.shadertoy.com/view/XlGcRh\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n    v = v ^ (v>>16u);\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n    v = v ^ (v>>16u);\n    // return float in [0,1)\n    return vec2(v >> 8) / float(0x01000000);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // zoom in/out\n    float S = 12500.0;\n    float scale = 2.0 * (S * cos(0.3 * iTime) + S + 50.0);\n    vec3 result = vec3(0.0);\n    for (int y = 0; y < AA; y++)\n    for (int x = 0; x < AA; x++) {\n        // stratified tent filter sampling\n        vec2 j = (vec2(x,y)+rand(uvec2(fragCoord) * uvec2(AA) + uvec2(x,y)))/float(AA);\n        j.x *= 2.; j.x = j.x < 1. ? sqrt(j.x) - 1. : 1. - sqrt(2. - j.x);\n        j.y *= 2.; j.y = j.y < 1. ? sqrt(j.y) - 1. : 1. - sqrt(2. - j.y);\n        // jitter around pixel center and scale coordinates\n        vec2 uv = scale * (fragCoord + j + 0.5 - 0.5 * iResolution.xy) / iResolution.x;\n        // get nearest gaussian integer\n        ivec2 g = ivec2(round(uv));\n        // decompose the gaussian integer g one digit at a time\n        // to extract the binary value n in base -1+i\n        // we don't actually need the value n, we just care about the highest bit index\n        // left the code in as an example\n        int n = 0, b = 1, bit = 0;\n        for (; bit < MAXBITS; bit++)\n        {\n            int r = (g.x ^ g.y) & 1; // remainder (1 only when x or y is odd)\n            g = (ivec2(g.y, -g.x) - g + r) / 2;\n            if (g== ivec2(0))\n            {\n                // done decomposing g, return index of current bit\n                break;\n            }\n            n += b * r;\n            b *= 2;\n        }\n        // color based on highest bit index (each colored region has the same number of digits)\n        float rx = 6.0*rand(uvec2(bit, 0)).x;\n        // hash to get a random color\n        result += 0.5 + 0.5*cos(rx+vec3(0,2,4));\n    }\n    fragColor=vec4(result / float(AA * AA), 1.0);\n}","name":"Image","description":"","type":"image"}]}