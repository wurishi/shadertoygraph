{"ver":"0.1","info":{"id":"X3y3DG","date":"1718125391","viewed":57,"name":"Curved mirror reflection","username":"Gariam","description":"Made because I needed to visualize this for a project of mine.\nUSE MOUSE TO POINT THE RAY.\n\nCan be used while paused.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","raymarch","sdf","reflections","mirror"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//mirror\n#define RADIUS 0.3\n#define SIZE 0.25\n#define POS vec2(1.2, 0.2)\n#define ANGLE -1.0\n\n//source\n#define ORIGIN vec2(0.2, 0.15)\n\n//appereance\n#define AA 1.0\n#define LINE_THICKNESS 0.002\n#define NORMALS 1\n\n//ray marching\n#define MAX_STEPS 40\n#define MAX_DIST 2.0\n#define MIN_DIST 0.001\n\n//constants\n#define SIN_COS_45 0.7071\n#define DEG2RAD 0.0174533\n\nfloat circleSDF(vec2 uv, vec2 pos, float radius){\n    return distance(uv, pos) - abs(radius);\n}\n\n//from: https://www.shadertoy.com/view/3tdSDj\nfloat lineSDF(vec2 a, vec2 b, vec2 p) {\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - h * ba) - LINE_THICKNESS;\n}\n\nvec2 rotateVec2(vec2 vec, float angle){\n    float s = sin(angle);\n\tfloat c = cos(angle);\n    return vec * mat2(c, s, -s, c);\n}\n\nfloat mirrorSDF(vec2 uv){ //made out of 3 circles\n    vec2 pos1 = POS + rotateVec2(vec2(-SIN_COS_45, SIN_COS_45) * RADIUS, ANGLE * DEG2RAD);\n    float circle = max(circleSDF(uv, pos1, RADIUS), -circleSDF(uv, pos1, abs(RADIUS) - 0.01));\n    return max(circle, circleSDF(uv, POS, SIZE));\n}\n\nvec2 getNormal(vec3 p){\n    vec2 e = vec2(MIN_DIST, 0.0);\n    vec2 normal = vec2(\n        p.z - mirrorSDF(p.xy - e.xy),\n        p.z - mirrorSDF(p.xy - e.yx)\n    );\n    return normalize(normal);\n}\n\nvec4 rayMarch(vec2 ray, vec2 origin){\n    float dist = MIN_DIST + MIN_DIST, d;\n    vec2 point = origin + ray * dist;\n    \n    for(int i = 0; i < MAX_STEPS; i++){\n        d = mirrorSDF(point);\n        if (abs(d) < MIN_DIST) return vec4(point, dist, d);\n        dist += d;\n        point += ray * d;\n        if (dist > MAX_DIST) return vec4(point, dist, d);\n    }\n    return vec4(point, dist, d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.y;\n    float aa = AA / iResolution.y;\n\n    vec3 col = vec3(0.0);\n    col.r += smoothstep(aa, -aa, circleSDF(uv, ORIGIN, 0.02)); //draw origin\n    col.yz += smoothstep(aa, -aa, mirrorSDF(uv)); //draw mirror\n    \n    vec2 ray = normalize(mouse - ORIGIN); //create ray\n    vec4 point = rayMarch(ray, ORIGIN); //find point of contact\n    col += smoothstep(aa, -aa, lineSDF(ORIGIN, point.xy, uv)); //draw ray\n    \n    while (point.z < MAX_DIST){ //if there is a point of contact\n        vec2 normal = getNormal(point.xyw); //find normal\n    #if NORMALS\n        col.xy += smoothstep(aa, -aa, lineSDF(point.xy, point.xy + normal * 0.5, uv)); //draw normal\n    #endif\n        \n        ray = reflect(ray, normal); //reflect ray\n        vec4 prevPoint = point;\n        point = rayMarch(ray, point.xy); //find next point of contact\n        col += smoothstep(aa, -aa, lineSDF(prevPoint.xy, point.xy, uv)); //draw reflected ray\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}