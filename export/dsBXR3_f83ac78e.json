{"ver":"0.1","info":{"id":"dsBXR3","date":"1670609925","viewed":139,"name":"Harmonograph __","username":"Envy24","description":"Source: https://www.shadertoy.com/view/ftyGDm","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["antialiasing","graph","plot","harmonograph","parametric","thickness"],"hasliked":0,"parentid":"dss3R7","parentname":"Parametric plotter __"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y  )\n#define ORIGIN                    ( vec2(0) )\n#define SCENE_SCALE               ( 1.5 )\n#define UNIT                      ( 5.0*SCENE_SCALE / R.y  )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n#define PI                          3.1415926535897932\n#define HALF_PI                     1.5707963267948966\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R) { return length(C - NDC)-R; }\n\nfloat segmentSDF_L2(in vec2 NDC, in vec2 B, in vec2 E, in float R)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - R;\n}\n\n// Source: https://www.shadertoy.com/view/ftyGDm\nfloat pendulum(float t, vec4 param) {\n    // https://en.wikipedia.org/wiki/Harmonograph\n    // vec4 -> (amplitude, frequency, phase, damping)  \n    return param.x * sin(t * param.y + param.z) * exp(-t * param.w);\n}\n\n// Source: https://www.shadertoy.com/view/ftyGDm\nvec2 func(float t)\n{\n    vec4 p1 = vec4(0.15, 2, 3.0 * HALF_PI, 0.005);\n    vec4 p2 = vec4(0.25, 4, PI, 0.005);\n    vec4 p3 = vec4(0.15, 7, HALF_PI, 0.0005);\n    vec4 p4 = vec4(0.25, 5, HALF_PI, 0.0005);\n    return 2.5*vec2(\n        pendulum(t, p1) + pendulum(t, p2),\n        pendulum(t, p3) + pendulum(t, p4)\n    );\n}\n\nfloat linear_remap(\n    float val,\n    vec2 from,\n    vec2 to)\n{\n    // inverse linear map from [from.x; from.y] to [0; 1].\n    val = (val - from.x) / (from.y - from.x);\n    // linear map from [0; 1] to [to.x; to.r].\n    return val * (to.y - to.x) + to.x;        \n}\n\n// https://www.shadertoy.com/view/NtVfWG\nfloat parametric_sdf(\n    in vec2 NDC,\n    in vec2 from, // NDC.x range\n    in vec2 to,   // t range\n    in float count,\n    in float thickness)\n{\n    float dt = (from.y - from.x) / (count - 1.);\n    \n    float minimal_distance = 99.;\n    vec2 B = func(linear_remap(from.x, from, to));\n      \n    for (float i = 1.; i < count; i += 1.)\n    {\n        float t = linear_remap(from.x + dt * i, from, to);\n    \n        vec2 E = func(t);\n        minimal_distance = \n            min(minimal_distance, segmentSDF_L2(NDC, B, E, 0.));\n        B = E;\n    }\n    \n    return minimal_distance - thickness;\n}\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - R.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse)\n{\n    vec2 M = MOUSE_OFFSET * (mouse == true ? 1. : 0.);\n    return ((2. * (SC - M) - R.xy) / R.y) * scale - origin;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, true);\n\n    vec3 color = vec3(1.); // background color\n         color -= x_axis(NDC); color -= y_axis(NDC);         \n         \n         \n    \n    /* Parametric function (x,y)=f(t) */\n    vec2 from = vec2(-AR*SCENE_SCALE, AR*SCENE_SCALE),\n         to = vec2(0, 2.*PI);\n    color = mix( color, vec3(1,0,0), SMAA(parametric_sdf(NDC, from, to, 256., 0.)) );      \n         \n  \n  \n    /* Moving point */\n    float t = mod(iTime * 0.1, to.y);\n    vec2 P = func(t);\n    color = mix(color, vec3(0,0,1), SMAA(diskSDF_L2(NDC, P, UNIT)));\n\n\n\n    /* Cells */\n    NDC = fract(NDC); \n    color -= vertical_line(NDC, 0.)*.2;  color -= horizontal_line(NDC, 0.)*.2;\n    color -= vertical_line(NDC, -1.)*.2; color -= horizontal_line(NDC, -1.)*.2;         \n    color -= vertical_line(NDC, 1.)*.2;  color -= horizontal_line(NDC, 1.)*.2; \n    /* */ \n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}","name":"Common","description":"","type":"common"}]}