{"ver":"0.1","info":{"id":"fstXDS","date":"1633875823","viewed":1015,"name":"Parallax Occlusion Map","username":"yunhai","description":"try to adjust \"HEIGHT\" in \"Image\"","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["bumpmapping","pom"],"hasliked":0,"parentid":"7dcSWB","parentname":"Parallax Map"},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//reference to:\n//https://learnopengl-cn.readthedocs.io/zh/latest/05%20Advanced%20Lighting/05%20Parallax%20Mapping/\n\n//compare with \"Bump Map\":\n//https://www.shadertoy.com/view/fdG3Dc\n\n//compare with \"Parallax Map\":\n//https://www.shadertoy.com/view/7dcSWB\n\nconst float HEIGHT=.2;\nconst float LAYERNUM=140.;\nconst float MAX_BUMP_MARCH=.5;\n/*------------OBJ DEFINE------------*/\nconst int OBJ_NUM=2;\nconst int ID_BOUND=0;\nconst int ID_S=1;\nMarchPoint sdf(in vec3 p)\n{\n    float[OBJ_NUM] objSDF;\n    for(int i=0;i<OBJ_NUM;i++)\n        objSDF[i]=INF;\n    objSDF[ID_BOUND]=-sdSphere(p-vec3(0,0,0),MAX_DIST);//Bound\n    \n    \n    /*--------add objects begin--------*/\n    objSDF[ID_S]=sdSphere(p,.4);\n    //objSDF[ID_S]=sdCube(p,vec3(.6));\n    /*--------add objects end----------*/\n    \n    \n    MarchPoint tar;tar.d=objSDF[ID_BOUND];tar.id=ID_BOUND;\n    for(int i=1;i<OBJ_NUM;i++)\n        if(tar.d>objSDF[i])\n            tar.d=objSDF[i],\n            tar.id=i;\n    return tar;\n}\nvec3 getNormal(in vec3 p)\n{\n    vec2 e=vec2(0,EPS);\n    float c=sdf(p).d;\n    return normalize(vec3(sdf(p+e.yxx).d-c,\n                          sdf(p+e.xyx).d-c,\n                          sdf(p+e.xxy).d-c));\n}\nstruct FragInfo\n{\n    vec3 worldPos,normal,kc,viewDir;\n};\n/*-------------exp code-------------*/\n//square n is from spalmer's advice\nvec4 triplanar( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n    n*=n;\n\treturn x*n.x + y*n.y + z*n.z;\n}\n\nvec4 pixelShade(in FragInfo I)\n{\n/*\n//my \"above\" version, is not that right\n    vec3 oPos=I.worldPos,seePos=oPos;\n    #define H (HEIGHT*triplanar(iChannel1,seePos,I.normal).x)\n    float times=LAYERNUM,dh=(HEIGHT/times)/(dot(-I.viewDir,I.normal)+EPS);\n    float subN=0.,subP=0.;\n    for(float i=0.;i<times;i++)\n    {\n        subN=subP;\n        subP=dot(seePos-oPos,I.normal)-H;\n        if(subP>0.)\n        {\n            subN=-subN;\n            seePos-=I.viewDir*dh*(subN)/(subN+subP);\n            break;\n        }\n        seePos-=I.viewDir*dh;\n    }\n*/\n//my \"below\" version\n    vec3 oPos=I.worldPos,seePos=oPos;\n    #define H (HEIGHT*(1.-triplanar(iChannel1,seePos,I.normal).x))\n//variable times from Arrangemonk's advice\n    float times=LAYERNUM *(1.-(dot(-I.viewDir,I.normal)*0.9)),\n    dh=(HEIGHT/times)/(max(0.,dot(-I.viewDir,I.normal))+.07),\n    a=1.,maxMarch=MAX_BUMP_MARCH;\n    float subN=0.,subP=0.;\n    for(float i=0.;i<times;i++)\n    {\n        subN=subP;\n        subP=dot(seePos-oPos,-I.normal)-H;\n        if(subP>0.)\n        {\n            subN=-subN;\n            seePos+=I.viewDir*dh*(subN)/(subN+subP);\n            break;\n        }\n        float d=dh*i;\n//dist cull, from spalmer's advice\n        if(d>maxMarch)\n        {\n            a=0.;\n            break;\n        }\n        seePos=oPos+I.viewDir*d;\n        \n    }\n \n    \n   \n    I.worldPos=seePos;\n    vec3 tagent=dFdx(I.worldPos),\n         bitagent=dFdy(I.worldPos);\n    I.normal=normalize(-cross(tagent,bitagent));\n    I.kc=triplanar(iChannel2,seePos*2.,I.normal).xyz;\n    \n    vec3 lightPos=cam.pos+vec3(0,.5,0);\n    vec3 pl=lightPos-I.worldPos;\n    vec3 ld;\n    float plLen=length(pl);\n    ld=pl/plLen;\n    vec3 diff=vec3(1)*max(dot(ld,I.normal),0.)/(plLen*plLen)*.67;\n    vec3 amb=vec3(.2);\n    return vec4(I.kc*(diff+amb),a);\n}\n/*-------------exp code end-------------*/\nMarchHit rayCast(in Ray r)\n{\n    float d=0.,i=0.,l=0.;\n    MarchPoint point;\n    for(;i<MAX_STEP;i++)\n    {\n        point=sdf(r.o+d*r.d);\n        if(abs(point.d)<MIN_DIST)\n            break;\n        l=i/MAX_STEP;\n        d+=point.d*((1.-l*l*l)*0.7+0.3);\n        if(point.id==ID_BOUND)\n        {\n            d=MAX_DIST;\n            break;\n        }\n    }\n    return MarchHit(d,i,point.id);\n}\nvec4 render(in Ray r)\n{\n    MarchHit h=rayCast(r);\n    \n    vec3 pos=r.o+r.d*h.d,nml=getNormal(pos);\n    vec3 col=vec3(0);\n    float quickAO=h.marchTimes/MAX_STEP;\n\n    switch (h.id)\n    {\n        case ID_BOUND:\n//Note:\n//When I tried to turn on the skyBox, \n//the sphere texture will be wrong, \n//(the iTime maybe the same problem)\n//I'cant tell the reason.\n            //col=texture(iChannel0,normalize(pos)).xyz;\n            break;\n        case ID_S:\n            vec4 ct=pixelShade(FragInfo(pos,nml,vec3(1),r.d));\n            col=mix(col,ct.xyz,ct.w);\n            break;\n    }\n    return vec4(col,quickAO);\n}\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    float t=iT,ct=mod(t,2.),rt=step(1.,ct)*(ct-1.)+floor(t*.5);\n    cam.pos=vec3(0,0,0)+vec3(cos(rt),0,sin(rt))*1.;\n    cam.dir=normalize(-cam.pos);\n    cam.pos-=cam.dir*((1.-floor(ct))*sin(fract(t)*2.*PI)*.3);\n    \n    cam.r=-cross(cam.dir,vec3(0,1,0));\n    cam.u=-cross(cam.r,cam.dir);\n    vec2 uv=(C-iR*.5)/iR.y;\n    Ray r=Ray(cam.pos,normalize(uv.x*cam.r+uv.y*cam.u+1.*cam.dir));\n    O=render(r);\n#ifdef SHOW_RAYMARCH_STEPS\n    O.rgb=mix(vec3(0,1,0),vec3(1,0,0),O.w);\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define iR iResolution.xy\n#define iT iTime\n#define iM iMouse\n\n\n/*------------Env Settings------------*/\n// #define SHOW_RAYMARCH_STEPS\n/*------------Env Settings------------*/\nconst float MAX_DIST=20.;\nconst float MIN_DIST=1e-4;\nconst float MAX_STEP=50.;\nconst float EPS=1e-4;\nconst float PI=3.14159265;\nconst float DTA=PI/180.;\nconst float INF=1e20;\nstruct Ray\n{\n    vec3 o,d;\n};\nstruct Cam\n{\n    vec3 pos,dir;\n    vec3 r,u;\n}cam;\nstruct MarchPoint\n{\n    float d;\n    int id;\n};\nstruct MarchHit\n{\n    float d,marchTimes;\n    int id;\n};\n\nfloat sdSphere(vec3 p,float s)\n{\n    return length(p)-s;\n}\nfloat sdCube(vec3 p,vec3 size)\n{\n    vec3 np=abs(p)-size*.5;\n    float o=length(max(np,vec3(0)));\n    float i=min(0.,max(np.x,max(np.y,np.z)));\n    return o+i;\n}\n","name":"Common","description":"","type":"common"}]}