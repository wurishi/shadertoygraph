{"ver":"0.1","info":{"id":"NttGzS","date":"1636363534","viewed":66,"name":"Ray marching sphere (((","username":"marchingcube","description":"Sphere rendered using ray marching algorithm \n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float SDFSphere( vec3 p, vec3 center, float radius )\n{\n    return distance(center, p) - radius;\n}\n\nfloat SDFPlane( vec3 p, float level)\n{\n    return p.y - level;\n}\n\nfloat SDF( vec3 p)\n{\n    return min( SDFSphere( p, vec3(0.), 0.2), SDFPlane(p, -0.5) );\n}\n\nvec4 raymarch( vec3 camera, vec3 ray_direction)\n{\n    vec3 p = camera;\n    for ( int i = 0; i < 500; i++ ){\n        float sd = SDF(p);\n        if (sd >= 10.){\n            return vec4(p, sd);\n        }\n        p += sd * ray_direction; \n        \n        if (sd <= 0.001){\n            return vec4(p, sd);\n        }\n    }\n    return vec4(p, SDF(p));\n}\nvec3 get_normal(vec3 p)\n{\n    float delta = 0.05;\n    float sd = SDF(p);\n    float dfdx = (sd + SDF(p + vec3(delta, 0., 0.))) / delta;\n    float dfdy = (sd + SDF(p + vec3(0., delta, 0.))) / delta;\n    float dfdz = (sd + SDF(p + vec3(0., 0., delta))) / delta;\n    return vec3(dfdx, dfdy, dfdz);\n    \n}\n\nfloat get_light(vec3 p, vec3 point_light)\n{\n    return dot(normalize(get_normal(p)), normalize(point_light - p)) + .5;\n}\n\nfloat get_shadow( vec3 p, vec3 point_light)\n{\n    vec3 to_point_light = normalize(point_light - p);\n    vec4 res = raymarch(p, to_point_light);\n    return res.w;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = 2.0 * fragCoord/iResolution.xy - 1.;\n    \n    // Fixing aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 camera_pos = vec3(0., 0., -0.3);\n    vec3 ray_direction = normalize(vec3(uv.x, uv.y, 0.6)); \n    vec3 point_light = normalize(vec3(0., 2.2, 0.));\n    vec3 color = vec3(.0);\n    \n    vec4 res = raymarch(camera_pos, ray_direction);\n    \n    if (res.w < 0.001){\n        float lightning = get_light(res.xyz, point_light);\n        lightning -= distance(camera_pos, res.xyz) * 0.01; \n        float shadow = get_shadow(res.xyz, point_light);\n        //if (shadow < 0.0001){\n        //    color -= vec3(0.5);\n        //}\n        color += vec3(lightning);\n    }\n    \n    else{ \n        color = vec3(.3 - distance(camera_pos, res.xyz)); \n    }\n    \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}