{"ver":"0.1","info":{"id":"csfcWs","date":"1687290189","viewed":45,"name":"Constrained Bicubic Filter","username":"lowellcamp","description":"A modification of bicubic pixel filtering that aims to reduce or even eliminate overshoot, while maintaining a smooth second derivative and hitting exact pixel values.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["filter","bicubic","cubic","interpolation","upscaling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Prevents numerical instability around 0 divisors\n#define d0(x) (x + 1e-6 * (step(x, vec4(0.0)) - 0.5))\n\n// ref: https://www.deriscope.com/docs/Kruger_CubicSpline.pdf\nvec4 constrainedCubic(float x, vec4 v0, vec4 v1, vec4 v2, vec4 v3) {\n    \n    vec4 n1 = max((v1 - v0) * (v2 - v1), vec4(0.0));\n    vec4 m1 = 3.0 * v1 + (2.0 * n1) / d0(v2 - v0);\n    vec4 n2 = max((v2 - v1) * (v3 - v2), vec4(0.0));\n    vec4 m2 = 3.0 * v2 - (2.0 * n2) / d0(v3 - v1);\n    \n    float xi = (1.0 - x);\n    return v1 * (xi * xi * xi) + \n        m1 * (xi * xi) * x + \n        m2 * xi * (x * x) + \n        v2 * (x * x * x);\n}\n\nivec2 _mod(ivec2 a, ivec2 b) {\n    return ((a % b) + b) % b;\n}\n\nvec4 constrainedBicubic(vec2 uv) {\n    ivec2 ires = ivec2(iChannelResolution[0].xy);\n    vec2 pixelPos = uv * iChannelResolution[0].xy;\n    pixelPos -= 0.5;\n    ivec2 pixel = ivec2(pixelPos);\n    vec2 fpixel = fract(pixelPos);\n    \n    vec4 row0 = constrainedCubic(\n        fpixel.x,\n        texelFetch(iChannel0, _mod(pixel + ivec2(-1, -1), ires), 0),\n        texelFetch(iChannel0, _mod(pixel + ivec2( 0, -1), ires), 0),\n        texelFetch(iChannel0, _mod(pixel + ivec2( 1, -1), ires), 0),\n        texelFetch(iChannel0, _mod(pixel + ivec2( 2, -1), ires), 0));\n    \n    vec4 row1 = constrainedCubic(\n        fpixel.x,\n        texelFetch(iChannel0, _mod(pixel + ivec2(-1,  0), ires), 0),\n        texelFetch(iChannel0, _mod(pixel + ivec2( 0,  0), ires), 0),\n        texelFetch(iChannel0, _mod(pixel + ivec2( 1,  0), ires), 0),\n        texelFetch(iChannel0, _mod(pixel + ivec2( 2,  0), ires), 0));\n    \n    vec4 row2 = constrainedCubic(\n        fpixel.x,\n        texelFetch(iChannel0, _mod(pixel + ivec2(-1,  1), ires), 0),\n        texelFetch(iChannel0, _mod(pixel + ivec2( 0,  1), ires), 0),\n        texelFetch(iChannel0, _mod(pixel + ivec2( 1,  1), ires), 0),\n        texelFetch(iChannel0, _mod(pixel + ivec2( 2,  1), ires), 0));\n        \n    vec4 row3 = constrainedCubic(\n        fpixel.x,\n        texelFetch(iChannel0, _mod(pixel + ivec2(-1,  2), ires), 0),\n        texelFetch(iChannel0, _mod(pixel + ivec2( 0,  2), ires), 0),\n        texelFetch(iChannel0, _mod(pixel + ivec2( 1,  2), ires), 0),\n        texelFetch(iChannel0, _mod(pixel + ivec2( 2,  2), ires), 0));\n    \n    return constrainedCubic(fpixel.y, row0, row1, row2, row3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 texcoord = uv / 8.0 + iTime / vec2(128.0, 207.10835056);\n    \n    fragColor = vec4(uv.x > 0.5 ? \n        vec3(constrainedBicubic(texcoord).rgb) :\n        texture(iChannel0, texcoord).rgb, 1.0);\n}","name":"Image","description":"","type":"image"}]}