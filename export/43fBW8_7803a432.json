{"ver":"0.1","info":{"id":"43fBW8","date":"1728309567","viewed":22,"name":"Wave and stars","username":"asadeporco","description":"Wave and stars","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["wave","stars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    \n    vec4 color = vec4(0.);\n    vec4 wave = wave(uv, iTime);   \n    color += wave;\n    \n    vec4 sky = sky(uv, iTime);\n    color += sky;\n    \n    \n    \n    fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n/*\n\n\tPCG random number generators ported to an NPM package, so that you can require it from glslify.\n\n\tThe code is based (mostly copied) from https://www.shadertoy.com/view/XlGcRh by Mark Jarzynski.\n\n\tReferences:\n\n\t* Mark Jarzynski and Marc Olano, Hash Functions for GPU Rendering, Journal of\n\t  Computer Graphics Techniques (JCGT), vol. 9, no. 3, 21-38, 2020\n\t  Available online http://jcgt.org/published/0009/03/02/\n\n\t* https://www.pcg-random.org/\n\n*/\n\nuint pcg(uint v) {\n\tuint state = v * uint(747796405) + uint(2891336453);\n\tuint word = ((state >> ((state >> uint(28)) + uint(4))) ^ state) * uint(277803737);\n\treturn (word >> uint(22)) ^ word;\n}\n\nfloat prng (float p) {\n\treturn float(pcg(uint(p))) / float(uint(0xffffffff));\n}\n\nfloat prng (vec2 p) {\n\treturn float(pcg(pcg(uint(p.x)) + uint(p.y))) / float(uint(0xffffffff));\n}\n\nuvec3 pcg(uvec3 v) {\n\tv = v * uint(1664525) + uint(1013904223);\n\n\tv.x += v.y * v.z;\n\tv.y += v.z * v.x;\n\tv.z += v.x * v.y;\n\n\tv ^= v >> uint(16);\n\n\tv.x += v.y * v.z;\n\tv.y += v.z * v.x;\n\tv.z += v.x * v.y;\n\n\treturn v;\n}\n\nvec3 prng (vec3 p) {\n\treturn vec3(pcg(uvec3(p))) / float(uint(0xffffffff));\n}\n\nuvec4 pcg(uvec4 v) {\n\tv = v * uint(1664525) + uint(1013904223);\n\n\tv.x += v.y * v.w;\n\tv.y += v.z * v.x;\n\tv.z += v.x * v.y;\n\tv.w += v.y * v.z;\n\n\tv.x += v.y * v.w;\n\tv.y += v.z * v.x;\n\tv.z += v.x * v.y;\n\tv.w += v.y * v.z;\n\n\tv = v ^ (v >> uint(16));\n\n\treturn v;\n}\n\nvec4 prng (vec4 p) {\n\treturn vec4(pcg(uvec4(p))) / float(uint(0xffffffff));\n}\n\n#pragma glslify: export(prng)\n\n \n\nfloat sinFun( float x, float a, float b, float c, float d )\n{\n    return a * sin(x * b + c) +d;\n}\n\nfloat waveFunc(vec2 uv, float t) {\n    float wave_a = sinFun(uv.x, .1, .2, t, 0.);\n    float wave_b = sinFun(uv.x, .02, 10., t*2., -0.2);\n    float wave_c = sinFun(uv.x, .2, .2, t*.5, 0.);\n   \n    float waves = wave_a + wave_b + wave_c;\n    \n    return waves;\n\n}\n\nvec4 wave(vec2 uv, float t) {\n    \n    \n    float waves = waveFunc(uv, t);\n    \n    vec4 color = vec4(0.035, 0.054, 0.243, 1.);\n    \n    float isUp = step(uv.y, waves);\n    \n    return color * isUp;\n\n}\n\nvec4 sky(vec2 uv, float t) {\n    vec4 color = vec4(1.,1.,1.,1.);\n    \n    float waves = waveFunc(uv, t);\n    vec2 grid_id = abs(floor((uv) * 10.));\n\n    float r = prng(grid_id);\n    \n    vec2 grid = fract(uv * 10.) - r;\n    \n    float d = length(grid) + (abs(sin(t)) + .5) / 70.;\n    d = smoothstep(.03, .02, d);\n    \n    float isDown = step(waves, uv.y);\n    \n    return color * d * isDown;\n}\n","name":"Common","description":"","type":"common"}]}