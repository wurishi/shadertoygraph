{"ver":"0.1","info":{"id":"4lcBDf","date":"1541223372","viewed":77,"name":"tunnel optimized 2","username":"ruko","description":"use a distance field instead of a boolean function\n\ncode is now simpler and achieves a good result in far fewer iterations","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["tunnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Set to true to see where the image is likely to be distorted\n#define debug false\n\nfloat tunnel(vec3 p) {\n    float d = sqrt(p.x * p.x + p.y * p.y);\n    return 10.0 - d;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 rotate(vec2 p, float th) {\n    return vec2(\n        p.x * cos(th) - p.y * sin(th),\n        p.x * sin(th) + p.y * cos(th)\n    );\n}\n\nfloat disc(vec3 p) { \n    //p.x += cos(iTime) * 10.0;\n    //p.y += sin(iTime) * 10.0;\n    \n    //p.yz = rotate(p.yz, iTime);\n    \n    p.xy = rotate(p.xy, iTime);\n    \n    return sdCappedCylinder(p, vec2(2.0, 0.1));\n}\n\nfloat scene(vec3 p) {\n    //return tunnel(p);\n    float d = tunnel(p);\n    //d = min(d, disc(p + vec3(0.0, 0.0, -40.0)));\n    d = min(d, disc(p + vec3(0.0, 0.0, -20.0)));\n    //d = min(d, disc(p + vec3(0.0, 0.0, -80.0)));\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.yy;\n    \n    fragCoord.x -= iResolution.x / 2.;\n    fragCoord.y -= iResolution.y / 2.;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec3 p = vec3(0.);   \n    p.x += cos(iTime) * 5.0;\n    p.y += sin(iTime*1.1) * 3.0;\n\n    vec3 direction = normalize(vec3(fragCoord, iResolution.x));\n    direction.x += cos(iTime) * .01;\n    direction.y += sin(iTime) * .01;\n    \n    \n    int maxSteps = min(500, int(floor(iTime)) * int(floor(iTime)));\n    float dist = 1.;\n    vec3 ray_t = p + dist * direction;\n    while (maxSteps-- > 0) {\n        float minDist = scene(ray_t);\n        if (abs(minDist) < 0.001) {\n            break;\n        }\n        dist += minDist;\n        ray_t = p + dist * direction;\n    }\n\n    float d = dist;\n    \n    float fogginess = 1./exp(d*.02);\n\n    col = vec3(fogginess*(0.5+0.5*sin(d+iTime*10.0)));\n    \n    if (debug)\n        col.x -= float(maxSteps);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}