{"ver":"0.1","info":{"id":"slfSD2","date":"1626555791","viewed":66,"name":"Cel Shaded Noise ","username":"ethann","description":"Using Raymarching to render 3D noise with a cel shaded palette","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"tdXBRS","parentname":"Rainbow Noise Raymarching"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Define some constants\nconst int steps = 100; // This is the maximum amount a ray can march.\nconst float smallNumber = 0.001;\nconst float maxDist = 15.; // This is the maximum distance a ray can travel.\n\n// cosine based palette, 4 vec3 params\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n \nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat scene(vec3 position){\n    // So this is different from the sphere equation above in that I am\n    // splitting the position into its three different positions\n    // and adding a 10th of a cos wave to the x position so it oscillates left \n    // to right and a (positive) sin wave to the z position\n    // so it will go back and forth.\n    float sphere = noise(\n        vec3(\n            position.x + sin(iTime*.1), \n            position.y + cos(iTime*.5), \n            position.z + iTime*.5+1.0)\n        ) - sin(iTime*.4)*.05-.2;\n    \n    // This is different from the ground equation because the UV is only \n    // between -1 and 1 we want more than 1/2pi of a wave per length of the \n    // screen so we multiply the position by a factor of 10 inside the trig \n    // functions. Since sin and cos oscillate between -1 and 1, that would be \n    // the entire height of the screen so we divide by a factor of 10.\n    //float ground = position.y + sin(position.x * 5.) / 10. \n    //                          + cos(position.z * 10.) / 10. + 1.0;\n    \n    // We want to return whichever one is closest to the ray, so we return the \n    // minimum distance.\n    return sphere;\n}\n \n // Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.0*3.1415/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions/2.0)) c = abs(c);\n    return c;\n}\n\n \nvec4 trace (vec3 origin, vec3 direction){\n    \n    float dist = 0.;\n    float totalDistance = 0.;\n    vec3 positionOnRay = origin;\n    \n    for(int i = 0 ; i < steps; i++){\n        \n        dist = scene(positionOnRay);\n        \n        // Advance along the ray trajectory the amount that we know the ray\n        // can travel without going through an object.\n        positionOnRay += dist * direction;\n        \n        // Total distance is keeping track of how much the ray has traveled\n        // thus far.\n        totalDistance += dist;\n        \n        // If we hit an object or are close enough to an object,\n        if (dist < smallNumber){\n            // return the distance the ray had to travel normalized so be white\n            // at the front and black in the back.\n            return 1.0 - vec4(totalDistance / maxDist);\n \n        }\n        \n        if (totalDistance > maxDist){\n \n            return vec4(0.); // Background color.\n        }\n    }\n    \n    return vec4(0.);// Background color.\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 pos = fragCoord/iResolution.xy-vec2(.5,.5);\n    \n    //pModPolar(pos,4.0);\n    \n    vec3 camOrigin = vec3(0,0,-1);\n\tvec3 rayOrigin = vec3(pos + camOrigin.xy, camOrigin.z + 1.0);\n\tvec3 dir = rayOrigin - camOrigin;\n\t\n\tvec4 dist = trace(rayOrigin,dir);\n    //palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n    vec4 color = vec4(0);\n    if(dist.z < .3){\n        color = vec4(dist.z*5.0,0,dist.x*1.0-.5,0);\n    }\n    if(dist.z < .4){\n        color = vec4(dist.z*4.0,0,dist.x*2.0-.5,0);\n    }\n    else if(dist.z < .6){\n        color = vec4(dist.z*3.0,0,dist.x*3.0-.5,0);\n    }\n    else if(dist.z < .9){\n        color = vec4(dist.z*2.0,0,dist.x*4.0-.5,0);\n    }\n    else{\n        color = vec4(dist.z*1.0,0,dist.x*5.0-.5,0);\n    }\n    //vec4 color = vec4(palette(dist.x*2.0, vec3(.5),vec3(.5),vec3(1.0),vec3(0.0,.33,.67)), dist.yzw);\n    \n    fragColor = color;\n    \n}","name":"Image","description":"","type":"image"}]}