{"ver":"0.1","info":{"id":"MccGRS","date":"1711816350","viewed":89,"name":"Inverse Distance Weighting 2","username":"mrboggieman","description":"Inverse Distance Weighting. Version of https://www.shadertoy.com/view/7t23Wz with colour and draggable point","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["interpolation","idw"],"hasliked":0,"parentid":"7t23Wz","parentname":"IDW Interpolation 1"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// original: https://www.shadertoy.com/view/7t23Wz\n\n// changing the power drastically changes the image\nconst float POWER = 2.0; //10.0; // larger numbers look voronoi\n\nconst float EPSILON = 0.00001;\n\nstruct Point {\n    vec2 pos;\n    vec3 colour;\n};\n\nPoint[] points = Point[](\n  Point(vec2(0.25, 0.25), vec3(0.9, 0.1, 0.3)),\n  Point(vec2(0.5, 0.25), vec3(0.1, 0.9, 0.2)),\n  Point(vec2(0.75, 0.25), vec3(0.9, 0.8, 0.2)), \n  Point(vec2(0.25, 0.5), vec3(0.1, 0.2, 1.0)),\n  Point(vec2(0.5, 0.5), vec3(0.0)),\n  Point(vec2(0.75, 0.5), vec3(0.9, 0.1, 0.7)),\n  Point(vec2(0.25, 0.75), vec3(0.9, 0.7, 0.6)),\n  Point(vec2(0.5, 0.75), vec3(0.5, 1.0, 1.0)),\n  Point(vec2(0.75, 0.75), vec3(0.2, 0.4, .2))\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n    \n    // allow dragging the center point\n    points[4].pos = iMouse.xy / iResolution.y;\n    \n    // calculate the mean using inverse distance weighting\n    float inv_dist_sum = 0.0;\n    vec3 mean = vec3(0.0);  \n    \n    for (int i = 0; i < points.length(); ++i) {\n        float dist = max(EPSILON, distance(uv, points[i].pos));                           \n        float inv_dist = 1.0 / pow(dist, POWER);\n\n        inv_dist_sum += inv_dist;\n        mean += points[i].colour * inv_dist;\n    }\n\n    mean /= inv_dist_sum; \n    \n    fragColor = vec4(mean, 1.0);\n}","name":"Image","description":"","type":"image"}]}