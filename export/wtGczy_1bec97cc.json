{"ver":"0.1","info":{"id":"wtGczy","date":"1702481531","viewed":148,"name":"Amorphous Being","username":"UnstableLobster","description":"If you try to do things right you might miss all the interesting wrong things that could happen along the way.","likes":25,"published":1,"flags":32,"usePreview":0,"tags":["particles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float smin(float a, float b, float k, float p, out float t)\n{\n    float h = max(k - abs(a-b), 0.0)/k;\n    float m = 0.5 * pow(h, p);\n    t = (a < b) ? m : 1.0-m;\n    return min(a, b) - (m*k/p);\n}\n\nvoid mainImage( out vec4 O, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    \n    O.xyz = vec3(1.0);   \n    float d = 100.0;\n    vec3 c = vec3(1.0);\n    float m = 1.0;\n    \n    //rendering\n    int I = int(ceil(particle_size*0.5))+2; \n    range(i, -I, I) range(j, -I, I)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch0, tpos);\n        particle P0 = getParticle(data, tpos);\n        \n        if (P0.M == 0.0) continue;\n         \n        float nd = distance(pos, P0.NX) - P0.R;\n            \n        //smin\n        float k = (border(pos) < 0.0) ? 3.5 : 4.0;\n        float t;\n        d = smin(d, nd, k, 2.3, t);\n        \n        m = mix(m, P0.M, t);\n    }  \n    \n    //shadow\n    float s = 100.0;\n    vec2 off = vec2(7.0, 5.0);\n    if (d > 0.0)\n    {\n        range(i, -I, I) range(j, -I, I)\n        {\n            vec2 tpos = pos-off + vec2(i,j);\n            vec4 data = texel(ch0, tpos);\n            particle P0 = getParticle(data, tpos);\n            \n            if (tpos.x < 0.0\n            ||  tpos.x > R.x\n            ||  tpos.y < 0.0\n            ||  tpos.y > R.x) { s = 0.0; break; }\n            if (P0.M == 0.0)  { continue; }\n\n            float nd = distance(pos - off, P0.NX) - P0.R;\n            float t;\n            s = smin(s, nd, 3.0, 2.0, t);\n        } \n    }\n    \n    \n    if (d < 1.0)        \n        O.xyz *= vec3(abs(sin(d)));\n        \n    if (d < 0.0)\n    {\n        O.xyz *= c;\n        O.xyz /= m;\n    }\n    \n    //shadow    \n    O.xyz *= mix(vec3(0.85), vec3(1.0), saturate(s));\n        \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define Bf(p) p\n#define Bi(p) ivec2(p)\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define G(x) exp(-dot(x*2.0,x*2.0))\n#define GS(x) exp(-length(x*2.0))\n#define dot2(x) dot(x,x)\n\n\n#define UV (pos/R)\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.*time-0.0)*(p - R*vec2(0.5, 0.6)) , R*vec2(0.05, 0.01));\n    return min(bound-10.0, box);\n}\n\n#define hh 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-hh,0,hh);\n    vec4 idx = vec4(-1./hh, 0., 1./hh, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\n\n//-------------\n// Particle\n//-------------\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x); \n    return unpackHalf2x16(X);\n}\n\nfloat encode(vec2 x)\n{\n    uint X = packHalf2x16(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 NX;\n    float R;\n    float M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.NX = decode(data.y) + pos;\n    P.R = data.z;\n    P.M = data.w;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = P.X - pos;\n    P.NX = P.NX - pos;\n    return vec4(encode(P.X), encode(P.NX), (P.R), (P.M));\n}\n\nvec2 vel(particle P)\n{\n    return P.NX - P.X;\n}\n\nparticle getParticleAt(sampler2D ch, vec2 pos)\n{\n    vec4 data = texel(ch, pos);\n    return getParticle(data, pos);\n}\n\n\n//-------------\n// RNG\n//-------------\nuvec4 s0; \n\nvoid rng_initialize(vec2 p, int frame)\n{\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n}\n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n}\n\nfloat rand() { pcg4d(s0); return float(s0.x)/float(0xffffffffu);  }\nvec2 rand2() { pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);  }\nvec3 rand3() { pcg4d(s0); return vec3(s0.xyz)/float(0xffffffffu); }\nvec4 rand4() { pcg4d(s0); return vec4(s0)/float(0xffffffffu);     }\n\n\n\n//-------------\n// Kernels\n//-------------\nvec2 snormalize(vec2 x)\n{\n\treturn (length(x) > 0.0) ?\n        normalize(x) :\n\t\tvec2(0.0);\n}\n\n\n//-------------\n// Border\n//-------------\nbool imBorder(vec2 pos)\n{\n    return border(pos) < 0.0\n        && mod(pos.x, 1.8) < 1.0\n        && mod(pos.y, 1.8) < 1.0;\n}\n\nparticle getVP(vec2 pos)\n{\n    particle P;\n    \n    P.X = pos;\n    P.NX = pos;\n    P.M = 1.0;\n    P.R = 0.8; \n    return P;\n}\n\n\n//-------------\n// Sim\n//-------------\n#define dt 1.0\n#define relax_value 1.0 / 3.0\n#define particle_rad 0.8\n#define particle_size (2.0*particle_rad)\n\nfloat stiffness(float k)\n{\n    return 1.0 - pow(1.0 - k, relax_value);   \n}\n\nvoid Simulation(sampler2D ch, sampler2D chd, inout particle P, vec2 pos)\n{\n    vec2 F = vec2(0.0);\n    vec3 n = vec3(0.0);\n    \n    vec4 pr = texel(chd, pos);\n    \n    int I = int(ceil(particle_size))+2; \n    range(i, -I, I) range(j, -I, I)\n    {\n        if (i == 0 && j == 0) continue;\n        \n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);       \n        particle P0 = getParticle(data, tpos);\n        \n        if (P0.M == 0.0 || tpos.x < 0.0 || tpos.y < 0.0) continue;\n        \n        vec2 dx = P.NX - P0.NX;\n        float d = length(dx);\n        float r = P.R + P0.R;\n        float  m = P0.M/(P.M+P0.M);   \n        \n        float rMult = 2.0;\n        float l = rMult*r - d;\n        \n        //collision and attraction\n        if (d < 4.0)\n        {\n            F += normalize(dx) * max(l - 0.0, 0.0) * m * 2.0 * stiffness(0.985);\n            F += normalize(dx) * min(l + 0.0, 0.0) * m * 2.0 * stiffness(0.985);\n        }\n        else\n            F += normalize(dx) * max(rMult*r*1.5-d, 0.0) * m * stiffness(0.2);\n    }\n      \n    P.NX += F * relax_value;\n}\n\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid Integrate(sampler2D ch, inout particle P, vec2 pos)\n{\n    int I = 2; \n    range(i, -I, I) range(j, -I, I)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        \n        if (tpos.x < 0.0 || tpos.y < 0.0) continue;\n       \n        particle P0 = getParticle(data, tpos);\n\n        //falls in this pixel\n        if (P0.NX.x >= pos.x-0.5\n        &&  P0.NX.x < pos.x+0.5\n        &&  P0.NX.y >= pos.y-0.5\n        &&  P0.NX.y < pos.y+0.5\n        &&  P0.M > 0.0)\n        {\n            vec2 P0V = vel(P0)/dt;\n        \n            //external forces\n            if(iMouse.z > 0.0)\n            {\n                vec2 dm =(iMouse.xy - iMouse.zw)/10.; \n                float d = distance(iMouse.xy, P0.NX)/20.;\n                P0V += 0.005*dm*exp(-d*d) * 1.5;\n            }\n\n            P0V += vec2(0., -0.005);//*P0.M;\n\n            float v = length(P0V);\n            P0V /= (v > 1.0) ? v : 1.0;\n\n            //\n            P0.X = P0.NX;     \n            P0.NX = P0.NX + P0V*dt;\n            P = P0;\n            break;\n        }\n    }\n}\n\nint emitTime(float area, float pc)\n{\n    float ppf = area/particle_size;\n    return int(((R.x*R.y) / ppf) * pc);\n}\n\nvoid mainImage( out vec4 O, in vec2 pos )\n{\n    R = iResolution.xy;\n    rng_initialize(pos, iFrame);\n\n    particle P;    \n\n    Integrate(ch0, P, pos);\n    \n    if (imBorder(pos)) P = getVP(pos); \n    \n    if (P.M == 0.0 && pos.x > 10.0 && pos.x < 11.0 && pos.y/R.y > 0.5 && pos.y/R.y < 0.65\n    && mod(pos.y, particle_size*2.0) < 1.0 && rand() > 0.5 && iFrame < emitTime(R.y*0.15*0.5, 0.055))\n    {\n        P.X = pos;\n        P.NX = pos + vec2(1.0, 0.0);\n        P.M = 2.0;\n        P.R = particle_rad;\n    }\n    \n    O = saveParticle(P, pos);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 O, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;     \n    vec4 data = texel(ch0, pos); \n    particle P = getParticle(data, pos);\n      \n    if (P.M > 0.0 && !imBorder(P.NX))\n        Simulation(ch0, ch1, P, pos);\n \n    O = saveParticle(P, pos);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 O, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;     \n    vec4 data = texel(ch0, pos); \n    particle P = getParticle(data, pos);\n      \n    if (P.M > 0.0 && !imBorder(P.NX))\n        Simulation(ch0, ch1, P, pos);\n \n    O = saveParticle(P, pos);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 O, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;     \n    vec4 data = texel(ch0, pos); \n    particle P = getParticle(data, pos);\n      \n    if (P.M > 0.0 && !imBorder(P.NX))\n        Simulation(ch0, ch1, P, pos);\n \n    O = saveParticle(P, pos);\n}","name":"Buffer D","description":"","type":"buffer"}]}