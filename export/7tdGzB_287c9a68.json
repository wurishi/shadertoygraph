{"ver":"0.1","info":{"id":"7tdGzB","date":"1636326730","viewed":232,"name":"Simplex Game Of Life","username":"Yusef28","description":"Fullscreen isn't as good\nBuffer A: Get texture as simplex\nBuffer B: Draw borders (unused)\nBuffer C: create Conway\nBuffer D: Blur Conway\nImage: Show","likes":11,"published":3,"flags":48,"usePreview":0,"tags":["triangles","simplex","gameoflife","gol"],"hasliked":0,"parentid":"Nld3DH","parentname":"Simplex Experiment #3"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\nBuilding off of my Conway at Night shader:\nhttps://www.shadertoy.com/view/stfXDN\n\nI basically start where that one ends by grabbing it\nas a texture through the coordinates of a simplex grid.\nUsing the code from My Briteny Simplex Shader:\nhttps://www.shadertoy.com/view/Nld3DH\n\n\n\nBuffer A: Get texture as simplex\nBuffer B: Draw borders (unused)\nBuffer C: create Conway\nBuffer D: Blur Conway\nImage: Show\n\npoints of interest:\n\n    The combination of texture uv scale in bufferD and the \n    conway scaled defined in common is what I explored, leading\n    to this illusion of drawing cubes.\n   \n    \n    //changing the scale in the texture look up\n    Buffer D: vec4 tex = texture(iChannel0,uv/10.);\n    \n    //changing the scale of the conway grid\n    Common: #define scale 40.\n    \n    I've mapped both to a \"keyScale\" variable in common\n    but there could be other ratios!\n    \nThe things this doesn't have are:\n\n1: a unique pattern of \ncubes or triangles based on the unique shape of the conway\n\"ship\". So things resolve as just random cuboid structures.\n\n2. Fullscreen\n\n\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv =  (fragCoord.xy)/iResolution.x;\n    vec3 col = texture(iChannel0,uv).rgb;\n    fragColor = vec4(col,1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = scale*(fragCoord)/iResolution.xy;\n    //uv.x += iTime/4.;\n\n    uv *= (skew);\n    vec2 uvFL = floor(uv);\n    uv = fract(uv);\n    float side = sign(uv.x-uv.y);\n    uvFL += vec2(1., 0.);\n    uvFL += (vec2(0.,0.5))*float(side<0.);\n    \n    uvFL *= inverse(skew);\n    //uv *= inverse(skew);\n    \n    //uvFL+=vec2(side<0.)*0.5;\n    \n    vec3 col = texture(iChannel0, (uvFL/scale) ).rgb;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define keyScale 1.4\n\n#define eps 10./iResolution.y\n#define S smoothstep\n#define scale (50.*keyScale)//or 40\n#define cross2D(a,b) (a).y*(b).x-(a).x*(b).y\n#define asp iResolution.y/iResolution.x\n#define golS 1.\n\nmat2 skew = mat2(2./sqrt(3.), 0., 1./sqrt(3.), 1.); \n\n\n//scaling and aspect ration have to happen for st and not the orig uv\n\n#define skale vec2(1.)\n//*(iResolution.y/iResolution.x))\n//#define off vec2(iResolution.x/skale.x,iResolution.y/skale.y)\n\nfloat rnd(vec2 id){\n    return fract(sin(id.x*12.99+id.y*800.+40.)*51343.);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//barycentric\n\n//skew matrix often written as \n//mat2 skew = mat2(1.1547, 0., 1.1547/2., 1.);\n\n\n//This hash is pretty bad\nfloat badHash(vec2 x){\n    return fract(sin(dot(vec2(23.,72.),x)*134.)*43143.);\n}\n\n// based on comments from FabriceNeyret2\n// https://www.shadertoy.com/view/7d3SDS\n// super elegant\nvec2 bary(vec2 A, vec2 B, vec2 C, vec2 P){\n    \n    //We want areas for the three triangles created\n    //with out point P and the 3 sides\n    //we get a triangle with vectors AtoB and AtoP\n    //Repeat with B and C\n    vec3 tri = vec3(length(cross2D(B-A,P-A)),\n                    length(cross2D(C-B,P-B)),\n                    length(cross2D(A-C,P-C))\n                    );\n    //If P is in the middle, all areas are equal\n    //If P lays between two sub triangles, those areas\n    //will be equal and there will be one other area\n    \n    \n    //chill sort to find the smallest area triangle\n   \n    //id which we will swap simultenously\n    vec3 id = vec3(1.,2.,3.);\n   \n    //swap to get minumum at x\n    //swap remaining two to get minumum at y\n    if(tri.z < tri.y) tri = tri.xzy, id = id.xzy;\n    if(tri.y < tri.x) tri = tri.yxz, id = id.yxz;\n    if(tri.z < tri.y) tri = tri.xzy, id = id.xzy;\n    //with tri sorted, can do smoothstep without abs\n    \n    \n    //Those areas become a coordinate system because together \n    //they tell us relatively how close P is to any of \n    //the three sides.\n    \n    //so \"borders\" are like with uv.x-uv.y but now 3d \n    //border of area1 and area2 like (uv.y-uv.x)\n    float f1 = S(0.,eps, tri.y-tri.x - 0.02);\n    //border of area1 and area3 (uv.z-uv.y)\n    float f2 = S(0.,eps, tri.z-tri.x - 0.02);\n    return vec2(id.x,f1*f2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor =vec4(0.);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = scale*(fragCoord)/iResolution.xy;\n    //uv.x += iTime/4.;\n    uv *= skew;\n    vec2 uvFL = floor(uv);\n    uv = fract(uv);\n    \n    vec2 f = 1.0 - S(0.0, eps*2., abs(uv-0.5)-0.45 );\n    float fd =  S(0., eps*3., abs(uv.x-uv.y)-eps*1. );\n    \n    float side = sign(uv.x-uv.y);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(vec3(0,2,4));\n    \n    vec2 stuff = bary(vec2(0.), \n                       vec2(1.,side<0.), \n                       vec2(side>0.,1.),\n                       uv);\n                       \n    col = 0.5 + 0.5*cos(vec3(1.,2.,4.)/3. + \n          badHash(uvFL+side*0.5 + stuff.x/3.)*80. + iTime/2. );\n  \n    col = texture(iChannel0, (fragCoord)/iResolution.xy).rgb;\n    \n    col *= f.x;\n    col *= f.y;\n    col *= fd;\n    //col *= stuff.y;\n    \n    // Output to screen\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n\n\nfloat count(vec2 p, vec2 off){\n\n    float cnt = 0.;\n    \n    cnt += texture(iChannel0, p + vec2(off.x,off.y)).y;\n    cnt += texture(iChannel0, p + vec2(off.x,0.0)).y;\n    cnt += texture(iChannel0, p + vec2(off.x,-off.y)).y;\n    cnt += texture(iChannel0, p + vec2(0.,off.y)).y;\n    cnt += texture(iChannel0, p + vec2(0.,-off.y)).y;\n    cnt += texture(iChannel0, p + vec2(-off.x,off.y)).y;\n    cnt += texture(iChannel0, p + vec2(-off.x,0.0)).y;\n    cnt += texture(iChannel0, p + vec2(-off.x,-off.y)).y;\n    \n    return cnt;\n    \n}\n\nvoid mainImage( out vec4 data, in vec2 fragCoord )\n{\n\n   //fragCoord -= mod(fragCoord, float(S));\n    vec2 off = golS/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;//  + (off * .5);\n    vec2 st = fract(uv*skale);\n    vec2 id = floor(uv*skale);\n    vec3 mouse = iMouse.xyz;\n    \n    float c;\n    \n    float state,val,speed,resx;\n    \n    \n    //set up / spacebar reset\n    if(iFrame == 0 || texture(iChannel1,  vec2(0.126953125, .25)).x > 0.){\n    \n        uv = fragCoord/iResolution.xy;\n        \n        //st = fract(uv*skale);        \n        id = floor(uv*skale);\n\n        \n        //val = rnd(id);\n        state = step(0.65,rnd(uv));\n        val = 0.;\n        //speed = rnd(id+vec2(1.))*0.002+0.99;\n        //resx = iResolution.x;\n        \n    }\n    else{\n        //get own texture\n        vec4 tex = texture(iChannel0, uv);\n        \n        float c = count(uv,off);\n        \n        state = tex.y;\n        \n            if((c == 2. && state == 1.) || c == 3.){\n            \n            //this variation is like a tiling\n            //if((c == 2. && state == 1.) || c == 1.){\n            \n                state = 1.;\n            }\n            \n            //if cell dies, increment val, the death counter\n            //\"Death Counting\"\n            else{\n            \n            \n                state = step(0.998,rnd(uv));//0.;\n                val += 1.;\n            }    \n    \n    }\n\n\n    data = vec4(val, state, speed, rnd(vec2(uv.x*uv.y)));\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates 0 (from to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //for color\n    \n    //the 256 effects the highlights. lower for more highlights.\n    vec2 st = uv;// fract(uv*iResolution.xy/256.);\n\n    vec4 tex = texture(iChannel0,uv/(8./keyScale));\n    \n    vec3 col;// = vec3(step(0.5,tex.y));// * (1.0-length(st-vec2(0.5))-0.3);\n\n       //glow \n    col = 0.5+0.5*cos(vec3(tex.y*tex.x*tex.y*1.)+vec3(0,2,4)/4.+tex.y*tex.x*3. +3.);\n       \n\n    \n    col = pow(col,vec3(2.))*7.;\n    col = mix(col, texture(iChannel1,uv).rgb, .9);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer D","description":"","type":"buffer"}]}