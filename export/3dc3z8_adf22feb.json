{"ver":"0.1","info":{"id":"3dc3z8","date":"1571429787","viewed":71,"name":"square asdfasdf","username":"patrickgh3","description":"asdf","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["neon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"bool inSquare(float x, float y, float w, float h,\n              float px, float py) {\n \treturn px > x-w/2.0 && px < x+w/2.0\n        && py > y-h/2.0 && py < y+h/2.0;\n}\n\nbool inSquareOutline(float x, float y, float w, float h,\n                     float px, float py) {\n    return inSquare(x, y, w, h, px, py)\n        && !inSquare(x, y, w-0.012, h-0.012, px, py);\n}\n\nbool inArc(float x, float y, float r,\n           float angle, float timeScalar, float timeOffset,\n           float size,\n           float px, float py) {\n    float dist = distance(vec2(x, y), vec2(px, py));\n    \n    bool inAngle = dot(vec2(px-x, py-y),\n        vec2(cos(angle), sin(angle))) < size;\n    float angleShift = iTime*timeScalar + timeOffset;\n    bool inAngleShifting = dot(vec2(px-x, py-y),\n        vec2(cos(angleShift), sin(angleShift))) < size;\n    \n    return dist < r && dist > r-0.005 && inAngle && inAngleShifting;\n}\n\nbool inCircle(float x, float y, float r,\n              float px, float py) {\n    float dist = distance(vec2(x, y), vec2(px, py));\n    return dist < r && dist > r-0.005;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Temp scale it down so it's a square in ShaderToy\n    uv.x *= 800.0/450.0;\n    \n    // Mirror x and y\n    uv.x = abs(uv.x-0.5)+0.5;\n    uv.y = abs(uv.y-0.5)+0.5;\n    \n    vec4 outColor = vec4(0, 0, 0, 0);\n\n    // White glow from center\n    //float r = distance(uv, vec2(0.5, 0.5));\n    //float alpha = 1.0-r*2.0;\n    //outColor = vec4(alpha, alpha, alpha, 1);\n    \n    vec4 squareColor = vec4(0.9, 0.4, 0.7, 1.0);\n    \n    // Static square\n    outColor += float(inSquareOutline(0.5, 0.5, 0.25, 0.25, uv.x, uv.y))\n        \t* (-outColor + squareColor*0.3);\n    \n    // Moving squares\n    float squareT = mod(iTime*0.25, 1.0);\n    float w0 = mix(0.05, 0.2, squareT);\n    float a0 = mix(0.0, 1.0, squareT);\n    float w1 = mix(0.2, 0.4, squareT);\n    float a1 = 1.0;\n    float w2 = mix(0.4, 0.65, squareT);\n    float a2 = mix(1.0, 0.0, squareT);\n    outColor += float(inSquareOutline(0.5, 0.5, w0, w0, uv.x, uv.y))\n        \t* (-outColor + squareColor*a0);\n    outColor += float(inSquareOutline(0.5, 0.5, w1, w1, uv.x, uv.y))\n        \t* (-outColor + squareColor*a1);\n    outColor += float(inSquareOutline(0.5, 0.5, w2, w2, uv.x, uv.y))\n        \t* (-outColor + squareColor*a2);\n    \n    // Center square\n    outColor += float(inSquareOutline(0.5, 0.5, 0.05, 0.05, uv.x, uv.y))\n        \t* (-outColor + squareColor);\n    \n    // Inner arcs\n    float inX = 0.013;\n    float inY = 0.12;\n    float inR = 0.1;\n    float inA = 0.2;\n    float inAS = 3.0;\n    float inAO = 3.0;\n    float inSize = -0.03;\n    vec4 inArcColor = vec4(1.0, 1.0, 0.7, 1.0);\n    \n    outColor += float(inArc(0.5-inX, 0.5+inY, inR,\n                            inA, -inAS, 0.0, inSize,\n                            uv.x, uv.y))\n        \t* (-outColor + inArcColor);\n    \n    outColor += float(inArc(0.5-inX, 0.5-inY, inR,\n                            -inA, inAS, 0.0, inSize,\n                            uv.x, uv.y))\n        \t* (-outColor + inArcColor);\n    \n    outColor += float(inArc(0.5+inX, 0.5+inY, inR,\n                            3.14-inA, inAS, inAO, inSize,\n                            uv.x, uv.y))\n        \t* (-outColor + inArcColor);\n    \n    outColor += float(inArc(0.5+inX, 0.5-inY, inR,\n                            3.14+inA, -inAS, inAO, inSize,\n                            uv.x, uv.y))\n        \t* (-outColor + inArcColor);\n    \n    // Outer arcs\n    inX = 0.22;\n    inY = 0.15;\n    inR = 0.2;\n    inA = 4.3;\n    inAS = -3.0;\n    inAO = 3.0;\n    inSize = -0.05;\n    inArcColor = vec4(0.7, 0.8, 1.0, 1.0);\n    \n    outColor += float(inArc(0.5-inX, 0.5+inY, inR,\n                            inA, -inAS, 0.0, inSize,\n                            uv.x, uv.y))\n        \t* (-outColor + inArcColor);\n    \n    outColor += float(inArc(0.5-inX, 0.5-inY, inR,\n                            -inA, inAS, 0.0, inSize,\n                            uv.x, uv.y))\n        \t* (-outColor + inArcColor);\n    \n    outColor += float(inArc(0.5+inX, 0.5+inY, inR,\n                            3.14-inA, inAS, inAO, inSize,\n                            uv.x, uv.y))\n        \t* (-outColor + inArcColor);\n    \n    outColor += float(inArc(0.5+inX, 0.5-inY, inR,\n                            3.14+inA, -inAS, inAO, inSize,\n                            uv.x, uv.y))\n        \t* (-outColor + inArcColor);\n    \n    // Static circles\n    //outColor += float(inCircle(0.7, 0.5, 0.012, uv.x, uv.y))\n    //    \t* (-outColor + vec4(0.5, 1.0, 0.7, 1.0));\n    \n    // Final output assignment\n    fragColor = outColor;\n}\n\n// Time varying pixel color\n//vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n// Output to screen\n//fragColor = vec4(col,1.0);","name":"Image","description":"","type":"image"}]}