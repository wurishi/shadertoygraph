{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define OCTAVES  8\n\n#define MAX_STEPS  64\n#define THRESHOLD .0001\n\n#define SHARP_MODE 0 // Just for fun.\n\nfloat rand(vec2 co){\n   return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand2(vec2 co){\n   return fract(cos(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat valueNoiseSimple(vec2 vl) {\n\n   const vec2 helper = vec2(0., 1.);\n    vec2 interp = smoothstep(vec2(0.), vec2(1.), fract(vl));\n    vec2 grid = floor(vl);\n\n    float rez = mix(mix(rand2(grid + helper.xx),\n                        rand2(grid + helper.yx),\n                        interp.x),\n                    mix(rand2(grid + helper.xy),\n                        rand2(grid + helper.yy),\n                        interp.x),\n                    interp.y);\n#if SHARP_MODE==1    \n    return abs(rez*2. -1.);\n#else\n    return rez;\n#endif\n}\n\nconst mat2 unique_transform = mat2( 0.85, -0.65, 0.65, 0.85 );\n\nfloat fractalNoise(vec2 vl, out float mainWave) {\n    \n#if SHARP_MODE==1\n    const float persistance = 2.4;\n    float frequency = 2.2;\n    const float freq_mul = 2.2;\n    float amplitude = .4;\n#else\n    const float persistance = 3.0;\n    float frequency = 2.3;\n    const float freq_mul = 2.3;\n    float amplitude = .7;\n#endif\n    \n    float rez = 0.0;\n    vec2 p = vl;\n    \n    float mainOfset = (iTime + 40.)/ 2.;\n    \n    vec2 waveDir = vec2(p.x+ mainOfset, p.y + mainOfset);\n    float firstFront = amplitude + \n\t\t\t        (valueNoiseSimple(p) * 2. - 1.);\n    mainWave = firstFront * valueNoiseSimple(p + mainOfset);\n    \n    rez += mainWave;\n    amplitude /= persistance;\n    p *= unique_transform;\n    p *= frequency;\n    \n\n    float timeOffset = iTime / 4.;\n\n    \n    for (int i = 1; i < OCTAVES; i++) {\n        waveDir = p;\n        waveDir.x += timeOffset;\n        rez += amplitude * sin(valueNoiseSimple(waveDir * frequency) * .5 );\n        amplitude /= persistance;\n        p *= unique_transform;\n        frequency *= freq_mul;\n\n        timeOffset *= 1.025;\n\n        timeOffset *= -1.;\n    }\n\n    return rez;\n}\n\n\nfloat scene(vec3 a) {\n   float mainWave;\n   float zVal = fractalNoise(vec2(a.x - 5., a.z ), mainWave);\n   return a.y + 0.2 + sin(zVal / 6.5);\n}\n\nfloat fractalNoiseLow(vec2 vl, out float mainWave) {\n    #if SHARP_MODE==1\n    const float persistance = 2.4;\n    float frequency = 2.2;\n    const float freq_mul = 2.2;\n    float amplitude = .4;\n#else\n    const float persistance = 3.0;\n    float frequency = 2.3;\n    const float freq_mul = 2.3;\n    float amplitude = .7;\n#endif\n    \n    float rez = 0.0;\n    vec2 p = vl;\n    \n    float mainOfset = (iTime + 40.)/ 2.;\n    \n    vec2 waveDir = vec2(p.x+ mainOfset, p.y + mainOfset);\n    float firstFront = amplitude + \n\t\t\t        (valueNoiseSimple(p) * 2. - 1.);\n    mainWave = firstFront * valueNoiseSimple(p + mainOfset);\n    \n    rez += mainWave;\n    amplitude /= persistance;\n    p *= unique_transform;\n    p *= frequency;\n    \n\n    float timeOffset = iTime / 4.;\n\n    \n    for (int i = 1; i < OCTAVES - 5; i++) {\n        waveDir = p;\n        waveDir.x += timeOffset;\n        rez += amplitude * sin(valueNoiseSimple(waveDir * frequency) * .5 );\n        amplitude /= persistance;\n        p *= unique_transform;\n        frequency *= freq_mul;\n\n        timeOffset *= 1.025;\n\n        timeOffset *= -1.;\n    }\n\n    return rez;\n}\n\nfloat sceneLow(vec3 a) {\n   float mainWave;\n   float zVal = fractalNoiseLow(vec2(a.x - 5., a.z ), mainWave);\n   return a.y + 0.2 + sin(zVal / 6.5);\n}\n\nvec3 snormal(vec3 a) {\n   vec2 e = vec2(.0001, 0.);\n   float w = scene(a);\n   return normalize(vec3(\n       scene(a+e.xyy) - w,\n       e.x,\n       scene(a+e.yyx) - w));\n}\n\nfloat trace(vec3 O, vec3 D, out float hill) {\n    float L = 0.;\n    int steps = 0;\n    float d = 0.;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        d = sceneLow(O + D*L);\n        L += d;\n        \n        if (d < THRESHOLD*L)\n            break;\n    }\n    \n    hill = d;\n    return L;\n}\n\nfloat occluded(vec3 p, float len, vec3 dir) {\n    return max(0., scene(p + len * dir));\n}\n\n\nfloat occlusion(vec3 p, vec3 normal) {\n    vec3 rotZccw = vec3(-normal.y, normal.xz);\n    vec3 rotZcw = vec3(normal.y, -normal.x, normal.z);\n    \n    vec3 rotXccw = vec3(normal.x, normal.z, -normal.y);\n    vec3 rotXcw = vec3(normal.x, -normal.z, normal.y);\n    \n    vec3 rotYccw = vec3(normal.z, normal.y, -normal.x);\n    vec3 rotYcw = vec3(-normal.z, normal.y, normal.x);\n    \n    float rez = 0.;\n    float dst = .28;\n\n   \trez+= occluded(p, dst, normal);\n    \n    rez+= occluded(p, dst, rotXccw);\n    rez+= occluded(p, dst, rotXcw);\n\n    rez+= occluded(p, dst, rotYccw);\n    rez+= occluded(p, dst, rotYcw);\n\n    rez+= occluded(p, dst, rotZccw);\n    rez+= occluded(p, dst, rotZcw);\n\n    return (pow(min(rez, 1.), 4.5) - 0.13725) * 1.7;\n}\n\nvec3 enlight(vec3 p, vec3 normal, vec3 eye, vec3 lightPos) {\n    vec3 dir = lightPos - p;\n    vec3 eyeDir = eye - p;\n    vec3 I = normalize(dir);\n    const vec3 color0 = vec3(0.0470588, 0.1921569, 0.2980392);\n    const vec3 color1 = vec3(0.0470588, 0.3450980, 0.4078431);\n    const vec3 color2 = vec3(0.1294117, 0.5137254, 0.6901961);\n    const vec3 color3 = vec3(0.1686274, 0.7176471, 0.8156863);\n\n    vec3 diffuse = vec3(max(dot(normal, I), 0.));\n\n    vec3 diffuse0 = clamp(diffuse * color0.rgb, 0., 1.);\n    vec3 diffuse1 = clamp(diffuse * color1.rgb, 0., 1.);\n    vec3 diffuse2 = clamp(diffuse * color2.rgb, 0., 1.);\n    vec3 diffuse3 = clamp(diffuse * color3.rgb, 0., 1.);\n\n    vec3 refl = normalize(-reflect(I, normal));\n    float spec = max(dot(refl, normalize(eyeDir)), 0.);\n\n    const vec3 spec_clr = vec3(.8, .9, 1.);\n    float dst = clamp(length(eyeDir),1. , 500.);\n    spec = pow(spec, 0.3 * 300.)* pow(.85, dst);\n\n    spec = clamp(spec, 0., 1.);\n    \n    vec3 Ispec = spec * spec_clr;\n    \n    float dist = length(eyeDir);\n    float atten = pow(0.93, dist * 7. );\n    float deep = occlusion(p, normal) * atten;\n    const float one_of_third = 1./3.;\n    \n    // Some logic workaround, hard to say what is better from performance reason\n    float third1 = max(0., sign(one_of_third - deep));\n    float third2 = (1. - third1) * max(0., sign(2. * one_of_third - deep));\n    float third3 = (1. - third1) * (1. - third2);\n        \n    return Ispec + third1 * mix(diffuse0, diffuse1, deep * 3.) + \n        third2 * mix(diffuse1, diffuse2, (deep - one_of_third) * 3.) +\n        third3 * mix(diffuse2, diffuse3, (deep - 2. * one_of_third) * 3.)\n        ;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 centered_uv = uv * 2. - 1.;\n    centered_uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 sunPos = vec2(.845 * iResolution.x / iResolution.y, .75);\n\n    float timeOffset = iTime / 5.;\n    \n    vec3 O = vec3(0., 0.1, 1. - timeOffset);\n    float h = scene(O) * 0.65;\n    O.y -= h;\n    \n    vec3 D = normalize(vec3(centered_uv, -2.0)); //fov\n\n    float hill;\n    float path = trace(O, D, hill);\n    vec3 coord = O + path * D;\n\n    vec3 resColor;\n    const vec3 skyBlueColor = vec3(0.529411765, 0.807843137, 0.980392157); // nice blue color\n    const vec3 sunColor = vec3(1.0, 1.0, 1.);\n    const vec3 sunGalo = vec3(.9, .9, .8);\n\n    // Background color\n    vec3 bgColor = mix(vec3(1.), skyBlueColor, clamp(centered_uv.y, 0., 1.));\n    float sunDst = length(centered_uv - sunPos) ;\n    float sunFluctuation = valueNoiseSimple(centered_uv - sunPos + timeOffset);\n    sunFluctuation = clamp(sunFluctuation * .25, 0.1, .2);\n    \n    float galoVal= exp(-pow(sunDst * 0.35, 1.15));\n    float val  = clamp(1. / (sunDst *110.5), 0., 1.);\n    \n    bgColor = mix(bgColor, sunColor*val + (galoVal + sunFluctuation) * sunGalo, galoVal);\n\n    vec3 lightPos = vec3(20., 90. -h, -95. - timeOffset);\n    vec3 normal = snormal(coord);\n        \n    resColor = enlight(coord, normal, O, lightPos);\n    resColor = mix(resColor, bgColor, min(hill, 1.));\n\n\n    fragColor = vec4(resColor, 1.);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4tX3WM","date":"1422457012","viewed":3470,"name":"MagicSea","username":"FatumR","description":"My naive attempt in water simulation.","likes":28,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","sea","water","ocean"],"hasliked":0,"parentid":"","parentname":""}}