{"ver":"0.1","info":{"id":"XtffDj","date":"1513250458","viewed":1095,"name":"JPG (de)compressor","username":"Ultraviolet","description":"Inspired by [url=https://www.shadertoy.com/view/llsfWS]this[/url] entry.\nControls:\n [b]Space[/b] for showing spectrum\n [b]A[/b] disable quantification\n [b]B[/b] shows difference\nSee the code for comments.","likes":21,"published":1,"flags":48,"usePreview":1,"tags":["compression","jpg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Most of the code is in other buffers\n// Buf A : Input\n// Buf B : DCT\n// Buf C : Quantification\n// Buf D : IDCT\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //*\n    if(fragCoord.x>(iMouse.z>.5?iMouse.x:(iResolution.x*.5*(1.+.8*cos(iTime)))))\n    {\n        fragColor=texture(iChannel0, fragCoord/iResolution.xy);\n        return;\n    }\n\t//*/\n    \n    \n    if(texelFetch(iChannel2, ivec2(32, 0), 0).x>0.5)\n    \tfragColor = abs(texture(iChannel1, fragCoord/iResolution.xy));\n    else if(texelFetch(iChannel2, ivec2(66, 0), 0).x>0.5)\n    \tfragColor = abs(texture(iChannel0, fragCoord/iResolution.xy) - texture(iChannel3, fragCoord/iResolution.xy));\n    else\n    \tfragColor = texture(iChannel3, fragCoord/iResolution.xy);\n    \n        \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n/// This is the input to the pipeline, you may put anything here\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    //fragColor = vec4(length((fragCoord/iResolution.xy - .5)*vec2(iResolution.x/iResolution.y, 1.0)) < 0.3 ? 1.0 : 0.0);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n/// This is the discrete cosine transform step, where 8x8 blocs are converted into frequency space\n/// Nice ref: https://unix4lyfe.org/dct/\n\n\n#define PI    3.1415972\n#define SQRT2 0.70710678118\n\n\nfloat DCTcoeff(vec2 k, vec2 x)\n{\n    return cos(PI*k.x*x.x)*cos(PI*k.y*x.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 k = mod(fragCoord, 8.)-.5;\n    vec2 K = fragCoord - .5 - k;\n    \n    vec3 val = vec3(0.);\n    \n    for(int x=0; x<8; ++x)\n    \tfor(int y=0; y<8; ++y)\n            val += (texture(iChannel0, (K+vec2(x,y)+.5)/iResolution.xy).rgb) * DCTcoeff(k, (vec2(x,y)+0.5)/8.) * (k.x<.5?SQRT2:1.) * (k.y<.5?SQRT2:1.);\n        \n    fragColor=vec4(val/4.,0.);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n/// This is the Quantification step, where frequency values are discretized.\n/// This is where the lossy compression happens: this step is non invertible\n\n\n/// You may change the number of level to achieve different effects\n\n#define NB_LEVELS 10.\n//#define NB_LEVELS (1.+5.*fragCoord.x/iResolution.x)\n//#define NB_LEVELS (1.+7.*iMouse.x/iResolution.x)\n//#define NB_LEVELS floor(1.+7.*iMouse.x/iResolution.x)\n//#define NB_LEVELS (1.+5.*(.5+.5*sin(iTime)))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    \n    if(texelFetch(iChannel2, ivec2(65, 0), 0).x<0.5)\n        // this assumes data between 0 and 1.\n        fragColor = round(fragColor/8.*NB_LEVELS)/NB_LEVELS*8.;\n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\n/// This is the reconstruction step, where each 8x8 bloc is converted back to the spatial domain\n\n\n#define PI 3.1415972\n#define SQRT2 0.70710678118\n\n\n// You may change the number of frequencies used for the reconstruction for achieving different effects.\n#define NB_FREQ\t\t8\n//#define NB_FREQ\t\tint(mod(iTime, 7.)+1.)\n\nfloat DCTcoeff(vec2 k, vec2 x)\n{\n    return cos(PI*k.x*x.x)*cos(PI*k.y*x.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 k = mod(fragCoord, 8.)-.5;\n    vec2 K = fragCoord-k-.5;\n        \n    vec3 val = vec3(0.);\n    for(int u=0; u<NB_FREQ; ++u)\n    \tfor(int v=0; v<NB_FREQ; ++v)\n        {\n            val += texture(iChannel0, (K+vec2(u,v)+0.5)/iResolution.xy).rgb * DCTcoeff(vec2(u,v), (k+.5)/8.) * (u==0?SQRT2:1.) * (v==0?SQRT2:1.);\n        }\n    \n    fragColor=vec4(val/4.,1.);\n}","name":"Buf D","description":"","type":"buffer"}]}