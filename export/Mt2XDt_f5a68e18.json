{"ver":"0.1","info":{"id":"Mt2XDt","date":"1447457301","viewed":201,"name":"RayMarching Notes","username":"gilesruscoe","description":"Further learning of ray marching. Keeping notes of what everything does.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarchingnotes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define MAX_STEP 100 //Maximum raymarch loop iterations  \n#define MAX_DIST 200.0 //Max distance before it is assumed the ray hit nothing\n#define EPSILON  0.01 //Minimum distance\n\n//borrowed from somewhere.. i forgot...\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n\n//Sphere distance function\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat maggot(vec3 pos)\n{\n    pos.y -= 0.5;\n    pos.y *= 0.3;\n    pos.xz *= 1.0 + smoothstep(0.0, 3.0, sin(pos.y * 120.0)) * 0.055;\n    pos.x += sin(iTime * 5.0 - pos.y * 10.0) * 0.1;\n\tfloat nl = noise(pos * 6.0) * 0.3;\n    float endMask = smoothstep(0.1, 0.2, pos.y);\n    return (length(pos) - 1.0 + clamp(pos.y * 3.0, 0.5, 1.0)) + nl * endMask;\n}\n\n//Box distance function\nfloat box(vec3 pos, vec3 size)\n{\n    return length(max(abs(pos) - size, 0.0));\n}\n//Torus distance funciton\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Smooth polynominal min function, smoothly joins objects\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n//Distance function\nfloat distfunc(vec3 pos)\n{\n    float st = sin(iTime);\n    float ct = cos(iTime);\n    mat2 rotMat = mat2(st, ct, -ct, st); \n    //pos.xy *= rotMat;\n    //float n = noise(pos * 6.0) * 0.3;    \n    //float s = sphere(pos, 1.0 + n);\n    float s = maggot(pos);\n    return s;\n}\n\n//Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    /////SCENE SETUP/////\n    //Uv coordinates in -1 to 1 space\n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    //Aspect ratio correction\n    uv.x *= iResolution.x / iResolution.y;\n    //Camera Position with some tilting animation\n    vec3 cameraOrigin = vec3(0.0, 0.0, 2.0);\n    //Camera Target\n    vec3 cameraTarget = vec3(0.0);\n    //World Up Direction\n    vec3 upDirection = vec3(0.0, 1.0, 0.0);\n    //Camera Direction\n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    //Camera Right Direction\n    vec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n    //Camera Up Direction\n    vec3 cameraUp = cross(cameraDir, cameraRight);\n    //Ray Direction\n    vec3 rayDir = normalize(cameraRight * uv.x + cameraUp * uv.y + cameraDir);\n    \n    /////RAY MARCHING////\n    //How far the ray has travelled so far\n    float totalDist = 0.0;\n    float dist = EPSILON;\n    //Point to start at\n    vec3 pos = cameraOrigin;\n    \n    for(int i = 0; i < 32; i++)\n    {\n        //If the object has been hit or the ray has gone out of bounds, break.\n        if(dist < EPSILON || totalDist > 20.0)\n            break;\n        //Evaluate the distance at current point using a distance function\n        dist = distfunc(pos);\n        //Progress the total distance covered\n        totalDist += dist;\n        //Progress the point along the ray vector by the distance travelled\n        pos += dist * rayDir;\n    }\n    \n    /////Lighting/////\n    //Check if object was hit\n    if(dist < EPSILON)\n    {\n        //Calculate the surface normal by sampling fragments of EPSILON distance from this fragment \n        vec2 eps = vec2(0.0, EPSILON);\n        vec3 normal = normalize(vec3(\n        \tdistfunc(pos + eps.yxx) - distfunc(pos - eps.yxx),\n            distfunc(pos + eps.xyx) - distfunc(pos - eps.xyx),\n            distfunc(pos + eps.xxy) - distfunc(pos - eps.xxy)));\n        \n        //NDotL lighting, assuming the light source is the camera\n        float brightness = 0.5;\n        vec3 lightSource = normalize(vec3(1.0, 0.0, 2.0)) * brightness;\n        float diffuse = max(0.0, dot(lightSource, normal));\n        float specular = pow(diffuse, 32.0) * 0.15;\n        vec3 baseColor = vec3(0.8, 0.3, 0.0);\n        vec3 result = baseColor + vec3(diffuse + specular);\n        //Final frag result\n\t\tfragColor = vec4(result, 1.0);\n        \n    }\n    //If not hit, use background colour\n    else\n    {\n        fragColor = vec4(0.1,0.15,0.25,0.1);\n    }\n}","name":"Image","description":"","type":"image"}]}