{"ver":"0.1","info":{"id":"wljyWG","date":"1595429618","viewed":52,"name":"RayMarching learning","username":"Amirh","description":"Learning to make sense of Ray Marching.\nAny feedback or suggestions appreciated!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST  100.0\n#define SURF_DIST 0.01\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0.0, 1.0);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p - c)- r;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n\n    vec3 c = a + t*ab;\n    \n    float x = length(p - c)- r;\n    float y = (abs(t - 0.5) - 0.4)*length(ab);\n    float e = length(max(vec2(x,y), 0.0));\n    float i = min(max(x,y), 0.0);\n    \n    return e + i;\n}\n\n\nfloat sdTorus(vec3 p, vec2 r)\n{\n    float x = length(p.xz) - r.x;\n    return length(vec2(x, p.y)) - r.y;\n}\n\nfloat dCube(vec3 p, vec3 s)\n{\n    return length(max(abs(p) - s, 0.0));\n}\n\n\nfloat GetDist(vec3 p)\n{\n  vec4 s = vec4(0, 3, 8, 1);\n  \n  float sphereDist = length(p-s.xyz)-s.w;\n  float planeDist = p.y;\n\n  float cyld = sdCylinder(p, vec3(4, 1, 7), vec3(3, 4, 5), 0.3);  \n  float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), 0.2);\n  float td = sdTorus(p-vec3(0, 0.5, 7), vec2(1.5, 0.5));\n  float bd = dCube(p - vec3(-3.0, 0.5, 6), vec3(0.5));\n    \n  float d = min(cd , planeDist);\n  d = min(d, sphereDist);\n  d = min(d , td);\n  d = min(d, bd);\n  d = min(d, cyld);\n    \n  return d;\n}\n\nfloat RayMarch (vec3 rayorg, vec3 raydir) {\n    float d0 = 0.;\n    \n    for (int i=0; i < MAX_STEPS; i++)\n    {\n        vec3 p = rayorg + raydir*d0;\n        float dS = GetDist(p);\n        d0 += dS;\n        if(d0 > MAX_DIST || dS < SURF_DIST) break;\n    }\n    \n    return d0;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\nfloat GetLight (vec3 p) \n{\n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.0;\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    \n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    float d = RayMarch(p+n*SURF_DIST*2.0, l);\n    if(d<length(lightPos-p)) dif *= 0.1;\n    return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 rayorg = vec3(0, 4, 0);\n    \n    vec3 raydir = normalize(vec3(uv.x, uv.y-0.4, 1));\n \n    float d = RayMarch( rayorg, raydir);\n    \n    vec3 p = rayorg + raydir * d;\n    \n    float dif = GetLight(p);\n    col = vec3(dif);\n    \n\n\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}