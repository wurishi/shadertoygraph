{"ver":"0.1","info":{"id":"lX3GR2","date":"1716743304","viewed":512,"name":"Kimi No Shiranai","username":"panna_pudi","description":"Hiraragi","likes":38,"published":1,"flags":0,"usePreview":0,"tags":["2d","3d","sdf","polygon","anime","reproduction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Pudi by Pudi\n// Email: krems.pudi@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Reproduction of the scene from the ending of anime Bakemonogatari\n// https://www.youtube.com/watch?v=lnKyr-vI3u8\n\nfloat timer() {\n    float t = floor(iTime * 3.55);\n    t = mod(t, 4.);\n    return t;\n}\n\nfloat REP_ID = 0.;\n// https://www.shadertoy.com/view/3syGzz\nvec2 op_rep(in vec2 p, in float s, in vec2 lima, in vec2 limb) {\n    vec2 id = clamp(round(p / s), lima, limb);\n    REP_ID = id.x + 1.;\n\n    return p - s * id;\n}\n\nfloat diplane(vec3 p, vec3 b, vec3 rd) {\n    vec3 dir = sign(rd) * b;\n    vec3 rc = (dir - p) / rd;\n    return rc.z + 0.01;\n}\n\nfloat nolim(float p, float s) { return p - s * round(p / s); }\nfloat noidlim(float p, float s) { return round(p / s); }\n\nfloat primitive(vec3 p, float r, float w) {\n    float ring = sd_torus(p, r, w);\n    ring = max(ring, -sd_box(p - vec3(0., -r, 0.), vec3(0.14, 0.06, 0.2)));\n    ring = min(ring, sd_sphere(p - vec3(0., -r, 0.), 0.006));\n    return ring;\n}\n\nvec2 map(vec3 p, vec3 rd) {\n    float t = iTime * 8.;\n    vec3 rr = rd;\n    vec3 pos = p;\n\n    float s = 0.029;\n    float id = round(p.z / s);\n    id = clamp(id, -29., 1.);\n    p.z = p.z - s * id;\n\n    vec2 shift = hash12(id + 10.);\n    vec3 ax = vec3(0., 0., 1.) + vec3(shift, 0.) * 0.007;\n    p = erot(p, normalize(ax), -t + TAU * hash11(id));\n    rr = erot(rr, normalize(ax), -t + TAU * hash11(id));\n    float a = 0.11;\n    p.xy -= (hash12(id + 8.) - 0.5) * a;\n    rr.x -= (hash11(id + 8.) - 0.5) * a;\n\n    float r = 0.61, w = 0.0007;\n    float ring = primitive(p, r, w);\n\n    float grid = diplane(p, vec3(0.5, 0.5, 0.022), rr);\n\n    float plane = sd_box(pos - vec3(0., 0., -0.10), vec3(0.36, 0.01, 0.47));\n\n    vec2 res = vec2(ring, 2.);\n    res = _min(res, vec2(grid, 1.));\n    res = _min(res, vec2(plane, 3.));\n\n    return res;\n}\n\nfloat point_line(vec2 p, vec2 a, vec2 b, float r) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float k = dot(pa, ba) / dot(ba, ba);\n    vec2 q = p - a - (b - a) * clamp(k, 0., 1.);\n    return length(q) - r;\n}\n\nfloat simple_line(vec2 p, float l, float r, float d) {\n    r = max(0.001, r);\n    d = min(d, r - 0.001);\n    l = max(0., l);\n    p.y -= clamp(p.y, -l / 2., l / 2.);\n    return sd_vesica(p, r, d);\n}\n\nvec4 points_to_p(vec2 p, vec2 a, vec2 b) {\n    vec2 ba = b - a;\n    float l = length(b - a);\n    float angle = atan(ba.x, ba.y);\n    p = p - (b + a) / 2.;\n\n    return vec4(p, l, angle);\n}\n\nbool EYES = false;\nfloat sd_line(vec2 p, float l, float angle, float r, float d) {\n    p *= rot(angle);\n\n    r = max(0.001, r);\n    d = min(d, r - 0.001);\n    p.y -= clamp(p.y, -l / 2., l / 2.);\n    if (EYES) {\n        return length(p) - r / 30.;\n    } else {\n\n        return sd_vesica(p, r, d);\n    }\n}\n\nfloat sd_aline(vec2 p, vec2 a, vec2 b, float r, float d) {\n    vec4 params = points_to_p(p, a, b);\n\n    return sd_line(params.xy, params.z, params.w, r, d);\n}\n\n// https://www.shadertoy.com/view/wdBXRW\nconst int N = 12;\nvec2[N] POINTS;\nfloat dot2(in vec2 v) { return dot(v, v); }\nfloat cross2d(in vec2 v0, in vec2 v1) { return v0.x * v1.y - v0.y * v1.x; }\nvec2 sd_polygon(in vec2 p, in vec2[N] v, in int num) {\n    float dlines = 1e9;\n    float d = dot(p - v[0], p - v[0]);\n    float s = 1.0;\n    for (int i = 0, j = num - 1; i < num; j = i, i++) {\n        float t = timer();\n        int n = REP_ID == 0. ? 2 : 1;\n        float force = 1.;\n        if (EYES) {\n            n = 1;\n            force = 0.1;\n        }\n        for (int k = 0; k < n; k++) {\n            float seed = t + float(i) + float(k) + REP_ID;\n            if (hash11(seed) < 0.50 && k > 0) {\n                continue;\n            }\n            vec4 params = points_to_p(p, v[j], v[i]);\n            float lrand = hash11(seed);\n            params.z *= map01(lrand, 0.75, 1.15);\n            float amp = k == n - 1 ? 0.015 : 0.01;\n            params.xy +=\n                (hash12(seed + 1.) * 2. - 1.) * amp * force * (1. - lrand);\n            float shift = 0.05;\n            params.w += map01(hash11(seed + 2.), -shift, shift) * force;\n\n            dlines = min(dlines,\n                         sd_line(params.xy, params.z, params.w, 0.05, 0.0475));\n        }\n\n        vec2 e = v[j] - v[i];\n        vec2 w = p - v[i];\n        vec2 b = w - e * clamp(dot(w, e) / dot(e, e), 0.0, 1.0);\n        d = min(d, dot(b, b));\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3(p.y >= v[i].y, p.y<v[j].y, e.x * w.y> e.y * w.x);\n        if (all(cond) || all(not(cond))) {\n            s = -s;\n        }\n    }\n\n    return vec2(s * sqrt(d), dlines);\n}\n\nfloat sd_hair_strand(vec2 p, float id, float t) {\n    id = t + id + REP_ID;\n    float l = 0.7 + 0.2 * hash11(id);\n    p -= vec2(0.11 + l, -0.0) + (hash12(id + 1.) - 0.5) * 0.03;\n    p *= rot(4.73);\n    float h = hash11(id + 2.17) * 0.058;\n    return sd_triangle(p, vec2(.004 + h, l));\n}\n\nfloat sd_hair(vec2 p, float t, int n, float l, float r) {\n    float sp = TAU / float(n);\n    float an = atan(p.y, p.x);\n    float id = floor(an / sp);\n\n    float a1 = sp * (id + 0.0);\n    float a2 = sp * (id + 1.0);\n    a1 = clamp(a1, l, r);\n    a2 = clamp(a2, l, r);\n    vec2 r1 = mat2(cos(a1), -sin(a1), sin(a1), cos(a1)) * p;\n    vec2 r2 = mat2(cos(a2), -sin(a2), sin(a2), cos(a2)) * p;\n\n    return min(sd_hair_strand(r1, id + 0.0, t),\n               sd_hair_strand(r2, id + 1.0, t));\n}\n\nfloat full_hair(vec2 uv) {\n    float t = timer();\n    float d = 1e9;\n    vec2 luv = vec2(abs(uv.x) - 0.11, uv.y);\n    luv *= rot(0.09);\n    luv -= vec2(0.0, -3.7);\n    float legs = sd_triangle(luv, vec2(0.06, 3.4));\n    legs = max(legs, -d);\n    d = min(d, legs);\n\n    vec2 huv = uv - vec2(0., 0.57);\n    float l = -2.0, r = -1.14;\n    float hair = 1e9;\n    hair = min(hair, sd_hair(huv, t, 58, l, r));\n    huv = vec2(abs(uv.x) - 0.1, uv.y);\n    REP_ID += 1.;\n    if (uv.x > 0.) {\n        REP_ID += 1.;\n    }\n    hair = min(hair, sd_hair(trot(huv, vec2(-0.207, 0.7), -0.25), t, 58, l, r));\n    hair = max(hair, (uv.y - 0.46));\n    huv = uv - vec2(0., -0.25);\n    float back_hair = sd_cyl(huv, 0.69, 0.15);\n    hair = smin(hair, back_hair, 0.009);\n    // hair = max(hair, -head);\n    hair = max(hair, -d);\n    d = min(d, hair);\n    return d;\n}\n\nfloat DAY;\nvec4 sd_hitagi(vec2 uv) {\n    float t = timer();\n\n    POINTS[0] = vec2(-0.3, -0.35);\n    POINTS[1] = vec2(-0.15, -0.27);\n    POINTS[2] = vec2(-0.05, -0.16);\n    POINTS[3] = vec2(-0.04, -0.02);\n    POINTS[4] = vec2(-0.05, 0.21);\n    POINTS[5] = vec2(0.05, 0.21);\n    POINTS[6] = vec2(0.04, -0.05);\n    POINTS[7] = vec2(0.07, -0.16);\n    POINTS[8] = vec2(0.20, -0.27);\n    POINTS[9] = vec2(0.32, -0.41);\n    POINTS[10] = vec2(0.07, -0.43);\n    POINTS[11] = vec2(-0.14, -0.37);\n\n    vec2 dress = sd_polygon(uv, POINTS, 12);\n    float d = dress.x;\n    float lines = dress.y;\n\n    vec2 auv = vec2(abs(uv.x) - 0., uv.y);\n    if (sign(uv.x) < 0.) {\n        auv -= vec2(-0.02, 0.02);\n        auv *= rot(0.14);\n    }\n\n    POINTS[0] = vec2(0.29, -0.22);\n    POINTS[1] = vec2(0.22, -0.14);\n    POINTS[2] = vec2(0.13, -0.08);\n    POINTS[3] = vec2(0.10, 0.10);\n    POINTS[4] = vec2(0.06, 0.16);\n    POINTS[5] = vec2(0.105, 0.26);\n    POINTS[6] = vec2(0.17, 0.15);\n    POINTS[7] = vec2(0.14, 0.1);\n    POINTS[8] = vec2(0.15, -0.05);\n    POINTS[9] = vec2(0.15, -0.05);\n    POINTS[10] = vec2(0.34, -0.1);\n    POINTS[11] = vec2(0.304, -0.161);\n\n    vec2 arms = sd_polygon(auv, POINTS, 12);\n    d = min(d, arms.x);\n    lines = min(lines, arms.y);\n\n    POINTS[0] = vec2(0.30, -0.12);\n    POINTS[1] = vec2(0.42, -0.12);\n    POINTS[2] = vec2(0.42, -0.14);\n    POINTS[3] = vec2(0.37, -0.14);\n    POINTS[4] = vec2(0.44, -0.196);\n    POINTS[5] = vec2(0.33, -0.23);\n    POINTS[6] = vec2(0.28, -0.17);\n\n    vec2 hands = sd_polygon(auv, POINTS, 7);\n    d = min(d, hands.x);\n    lines = max(lines, -hands.x);\n    float hide =\n        sd_box(rot(-0.40) * auv - vec2(0.310, -0.009), vec2(0.02, 0.05));\n    hide = min(\n        hide, sd_box(rot(-1.36) * auv - vec2(0.30, 0.337), vec2(0.025, 0.070)));\n    hands.y = max(hands.y, -hide);\n    lines = min(lines, hands.y);\n\n    POINTS[0] = vec2(-0.01, -0.024);\n    POINTS[1] = vec2(-0.005, 0.030);\n    POINTS[2] = vec2(0.01, 0.038);\n    POINTS[3] = vec2(0.005, -0.021);\n\n    auv -= vec2(0.36, -0.2);\n    auv = op_rep(auv, 0.0305, vec2(-1., 0.), vec2(2., 0.));\n    vec2 fingers = sd_polygon(auv, POINTS, 4);\n    //lines = max(lines, -fingers.x);\n    //d = min(d, fingers.x);\n    lines = min(lines, fingers.y);\n    REP_ID = 0.;\n\n    vec2 luv = vec2(abs(uv.x) - 0.11, uv.y);\n    luv *= rot(0.09);\n    luv -= vec2(0.0, -3.7);\n    float legs = sd_triangle(luv, vec2(0.06, 3.4));\n    legs = max(legs, -d);\n    d = min(d, legs);\n\n    float head = sd_box(uv - vec2(0., 0.23), vec2(0.013, 0.04));\n    head = min(head, sd_egg(uv * vec2(1., -1.) - vec2(0., -0.41), 0.13, 0.08));\n    head = max(head, (uv.y - 0.41));\n    // head = max(head, -d);\n    lines = max(lines, -head);\n    d = min(d, head);\n\n    vec2 suv = uv - vec2(0., 0.29);\n    float smile = sd_sphere(suv, 0.02);\n    smile = max(abs(smile) - 0.002, suv.y + 0.015);\n\n    EYES = true;\n    vec2 euv = vec2(abs(uv.x) - 0.06, uv.y);\n    euv -= vec2(0., 0.33);\n    float eyes = sd_sphere(euv, 0.03);\n    eyes = eyes < 0. ? abs(mod(eyes + 0.0, 0.0088)) - 0.003 : eyes;\n    // eyes = eyes < 0. ? abs(mod(eyes + 0.0, pc.pos.x / 100.)) - 0.003 : eyes;\n    POINTS[0] = vec2(0.038, -0.007);\n    if (DAY > 0.5) {\n        POINTS[1] = vec2(-0.00, 0.02);\n    } else {\n        POINTS[1] = vec2(-0.00, -0.02);\n    }\n    POINTS[2] = vec2(-0.04, -0.008);\n    POINTS[3] = vec2(0., -0.02);\n    vec2 peyes = sd_polygon(euv, POINTS, 4);\n    eyes = max(eyes, peyes.x);\n    float eyelashes = peyes.y;\n    if (DAY > 0.5) {\n        float trig = sd_triangle(euv * vec2(1., -1.) + vec2(0., 0.002),\n                                 vec2(0.016, 0.03));\n        eyes = max(eyes, -trig);\n        eyelashes = max(eyelashes, -trig);\n    }\n\n    vec2 huv = uv - vec2(0., 0.57);\n    float l = -2.0, r = -1.14;\n    float hair = 1e9;\n    hair = min(hair, sd_hair(huv, t, 58, l, r));\n    huv = vec2(abs(uv.x) - 0.1, uv.y);\n    REP_ID += 1.;\n    if (uv.x > 0.) {\n        REP_ID += 1.;\n    }\n    hair = min(hair, sd_hair(trot(huv, vec2(-0.207, 0.7), -0.25), t, 58, l, r));\n    hair = max(hair, (uv.y - 0.46));\n    huv = uv - vec2(0., 0.281);\n    float back_hair = sd_cyl(huv, 0.15, 0.15);\n    hair = smin(hair, back_hair, 0.009);\n    hair = max(hair, -head);\n    hair = max(hair, -d);\n    d = min(d, hair);\n\n    vec2 buv = trot(uv, vec2(0.003, 0.41), -0.26);\n    float bangs = sd_box(vec2(abs(buv.x) - 0.117, buv.y), vec2(0.0175, 0.09));\n    bangs = max(bangs, back_hair);\n    buv = trot(uv, vec2(0.076, 0.4), -0.24);\n    float rbang = sd_box(buv, vec2(0.06, 0.06));\n    buv -= (hash12(t) - 0.5) * 0.006;\n    rbang = max(rbang, -(buv.y + abs(fract(buv.x * 100.) - 0.5) * 0.01 + 0.05));\n    bangs = min(bangs, rbang);\n\n    buv = trot(uv, vec2(-0.037, 0.343), -0.22);\n    buv = op_rep(buv, 0.025, vec2(-2., 0.), vec2(2., 0.));\n    buv -= (hash12(t + REP_ID + 4.) - 0.5) * vec2(0.0025, 0.010);\n    buv = rot((hash11(t + REP_ID) - 0.5) * 0.10) * buv;\n    bangs = min(bangs, sd_triangle(buv, vec2(0.024, 0.102)));\n\n    d = min(d, lines);\n\n    vec3 col = vec3(0.);\n\n    col = mix(col, vec3(0.), step(hair, 0.));\n\n    // col = mix(col, vec3(0.7, 0.7, 0.), smoothstep(0.01, 0.00, max(d,\n    // 0.005)));\n    col = mix(col, vec3(0.), AAstep(legs, 0.));\n    col = mix(col, vec3(1.), step(head, 0.));\n    col = mix(col, vec3(0.), AAstep(abs(head) - 0.002, 0.));\n    col = mix(col, vec3(1.), step(dress.x, 0.));\n    col = mix(col, vec3(1.), step(hands.x, 0.));\n    col = mix(col, vec3(1.), step(arms.x, 0.));\n    //col = mix(col, vec3(1.), step(fingers.x, 0.));\n\n    col = mix(col, vec3(0.), AAstep(smile, 0.));\n    col = mix(col, vec3(0.), step(eyes, 0.));\n    col = mix(col, vec3(0.), AAstep(eyelashes - 0.001, 0.));\n    col = mix(col, vec3(0.), AAstep(lines, 0.));\n    col = mix(col, vec3(0.), step(bangs, 0.));\n\n    return vec4(col, d);\n}\n\nvec3 GLOW = vec3(0.);\nvec3 GIRL = vec3(0.);\nvec2 trace(vec3 ro, vec3 rd) {\n    float t = 0.;\n    for (int i = 0; i < 50; ++i) {\n        vec3 pos = ro + rd * t;\n        vec2 d = map(pos, rd);\n        float ad = abs(d.x);\n        if (ad < 0.0025) {\n            if (d.y > 2.5 && d.y < 3.5) {\n                vec4 hitagi = sd_hitagi((pos.xz - vec2(-0.01, -0.23)) * 1.47);\n                float mask = hitagi.w;\n                GIRL = hitagi.rgb;\n                if (step(0., mask) > 0.) {\n                    t += 0.1;\n                    continue;\n                }\n            }\n            return vec2(t, d.y);\n        }\n\n        const float gd = .05;\n        if (d.y > 1.5 && d.y < 2.5) {\n            ad += (hash11(iTime * dot(rd, rd)) - 0.5) * 0.001;\n            float gl = .02 * (gd - ad) / gd / (1. + ad * ad / gd / gd * 10.);\n            GLOW += gl;\n        }\n\n        t += d.x;\n        if (t > 2.) {\n            break;\n        }\n    }\n    return vec2(-1.);\n}\n\nmat3 get_cam(vec3 ro, vec3 lo) {\n    vec3 cw = normalize(lo - ro);\n    vec3 cu = normalize(cross(cw, vec3(0, 0, 1)));\n    vec3 cv = cross(cu, cw);\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord/iResolution.xy - 0.5)\n            * vec2(iResolution.x / iResolution.y, 1.);\n   \n    float upoff = 0.013;\n    vec3 ro = vec3(0., -1., 0.18) - vec3(0., -0.01, -0.0);\n    mat3 cam = get_cam(ro, vec3(0., 0., upoff));\n    vec3 rd = cam * normalize(vec3(uv, 1.));\n\n    vec3 col = vec3(.6, 0.01, 0.00);\n\n    float time = iTime;\n    float n = 24. / 2.;\n    // https://www.desmos.com/calculator/w4u0k6gejv\n    float release = smoothstep(1., 0., abs(mod(2. * time + 1., n) - 1.));\n    release = pow(release, 5.);\n    float type = step(n / 2., mod(time, n));\n    DAY = type;\n\n    if (DAY > 0.5) {\n        col = vec3(0.9);\n    }\n\n    float s = 2.0;\n    vec2 buv = uv + vec2(time, 0.);\n    float id = round(buv.x / s);\n    float off = (hash11(id) - 0.5) * s / 2.;\n    buv = uv - vec2(id * s - off - time, -0.1);\n    float c = full_hair(buv * 1.4);\n\n    s = 2.30;\n    buv = uv + vec2(time * 1.2, 0.);\n    id = round(buv.x / s);\n    off = (hash11(id + 0.1) - 0.5) * s / 2.;\n    buv = uv - vec2(id * s - off - time * 1.2, -0.1);\n    float c2 = full_hair(buv * 1.4);\n\n    c = min(c, c2);\n\n    col = mix(col, col * 0.3, smoothstep(0.013, 0.00, c));\n\n    vec2 hit = trace(ro, rd);\n    if (hit.y > 1.5) {\n        vec3 pos = ro + rd * hit.x;\n\n        col = vec3(1.);\n        if (hit.y == 3.) {\n            col = GIRL;\n        }\n        if (DAY > 0.5 && (hit.y > 1.5 && hit.y < 2.5)) {\n            col = vec3(0.9, 0., 0.);\n        }\n    }\n    if (DAY < 0.5) {\n        col += GLOW;\n    }\n\n    col = mix(col, vec3(1.), release);\n\n    // vignette\n    vec2 in_uv = fragCoord / iResolution.xy;\n    in_uv.y += 0.025;\n    col *= smoothstep(-0.02, .05,\n                      in_uv.x * in_uv.y * (1. - in_uv.x) * (1. - in_uv.y));\n    \n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = acos(-1.);\nconst float TAU = 2. * PI;\nconst float EPS = 0.0001;\n\n\nfloat AAstep(float thre, float val) {\n    return smoothstep(-.5, .5, (val - thre) / min(0.005, fwidth(val - thre)));\n}\nfloat AAstep(float val) {\n    return AAstep(val, 0.);\n}\n\nfloat map01(float val, float start, float stop) {\n    return start + val * (stop - start);\n}\n\nvec2 _min(vec2 a, vec2 b) {\n    if (a.x < b.x) {\n        return a;\n    }\n    return b;\n}\n\nvec3 erot(vec3 p, vec3 ax, float a) {\n    return mix(dot(ax, p) * ax, p, cos(a)) + cross(ax, p) * sin(a);\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvec2 trot(in vec2 p, in vec2 off, in float a) {\n    p = p - off;\n    p *= rot(a);\n    return p;\n}\n\nfloat hash11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 hash12(float p) {\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nfloat smin(float a, float b, float k) {\n    k *= 6.0;\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * h * k * (1.0 / 6.0);\n}\n\nfloat sd_sphere(vec3 p, float r) { return length(p) - r; }\nfloat sd_sphere(vec2 p, float r) { return length(p) - r; }\n\nfloat sd_torus(vec3 p, float rring, float width) {\n    vec2 q = vec2(sd_sphere(p.xy, rring), p.z);\n    return sd_sphere(q, width);\n}\n\nfloat sd_cyl(vec3 p, float l, float r) {\n    p.z -= min(l, max(p.z, 0.));\n    return length(p) - r;\n}\nfloat sd_cyl(vec2 p, float l, float r) {\n    p.y -= min(l, max(p.y, 0.));\n    return length(p) - r;\n}\n\nfloat sd_box(vec3 p, vec3 h) {\n    p = abs(p) - h;\n    return length(max(p, 0.)) + min(0., max(p.x, max(p.y, p.z)));\n}\nfloat sd_box(vec2 p, vec2 h) {\n    p = abs(p) - h;\n    return length(max(p, 0.)) + min(0., max(p.x, p.y));\n}\n\nfloat sd_triangle(in vec2 p, in vec2 q) {\n    p.x = abs(p.x);\n    vec2 a = p - q * clamp(dot(p, q) / dot(q, q), 0.0, 1.0);\n    vec2 b = p - q * vec2(clamp(p.x / q.x, 0.0, 1.0), 1.0);\n    float s = -sign(q.y);\n    vec2 d = min(vec2(dot(a, a), s * (p.x * q.y - p.y * q.x)),\n                 vec2(dot(b, b), s * (p.y - q.y)));\n    return -sqrt(d.x) * sign(d.y);\n}\n\nfloat sd_egg(in vec2 p, in float ra, in float rb) {\n    const float k = sqrt(3.0);\n    p.x = abs(p.x);\n    float r = ra - rb;\n    return ((p.y < 0.0)             ? length(vec2(p.x, p.y)) - r\n            : (k * (p.x + r) < p.y) ? length(vec2(p.x, p.y - k * r))\n                                    : length(vec2(p.x + r, p.y)) - 2.0 * r) -\n           rb;\n}\n\nfloat sd_vesica(vec2 p, float r, float d) {\n    p = abs(p);\n    float b = sqrt(r * r - d * d);\n    return ((p.y - b) * d > p.x * b) ? length(p - vec2(0.0, b))\n                                     : length(p - vec2(-d, 0.0)) - r;\n}","name":"Common","description":"","type":"common"}]}