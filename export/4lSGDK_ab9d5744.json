{"ver":"0.1","info":{"id":"4lSGDK","date":"1432261736","viewed":155,"name":"heart mess","username":"ddddddddd","description":"messing around. ran out of time. bye","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["heart"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// simple sphere cheat map.\n// modified. playing around.\n// dean alex\n\n// USE MOUSE\n\n\nfloat PI = 3.14159265358979586;\n\nfloat focal = 0.5;\nfloat heartY = 0.4;\n\n\n\n\n\nvec2 warp( float x, float y, float radius ){\n    \n    // width of radius at y\n    float rad_w = sqrt( radius*radius - y*y );\n    float warp_x = x / rad_w;\n    \n    // height of radius at x\n    float rad_h = sqrt( radius*radius - x*x );\n    float warp_y = y / rad_h;\n    \n    //\n    warp_x = warp_x + (cos( x * PI ));\n    warp_y = warp_y + (cos( y * PI ));\n    \n    return vec2( warp_x, warp_y );\n}\n\nvec4 hext( float x, float y ){\n    float sides = 4.0;\n    float spotCount = 15.0;\n    float spotRatio = 0.75;\n    \n    float ox = iTime * 0.11;\n    float oy = iTime * 0.13 * y * 0.1;\n    \n    float spdx = mod( x * spotCount + ox, 2.0 ) - 1.0;\n    float spdy = mod( y * spotCount + oy, 2.0 ) - 1.0;\n    \n    float sptheta = atan( spdy, spdx );\n    float spdis = sqrt( spdx * spdx + spdy * spdy );\n    \n    if( spdis > spotRatio ){\n        return vec4( sin(x)*0.7, 0.0, sin(x), 1.0 );\n    }else{\n        \n        float hexangle = (2.0 * PI / sides );\n        float hextheta = mod( sptheta / hexangle, 1.0 );\n        \n        float Ax = 1.0;\n        float Ay = 0.0;\n        float Bx = cos( hexangle );\n        float By = sin( hexangle );\n        \n        float Mx = Bx * hextheta + Ax * (1.0 - hextheta);\n        float My = By * hextheta + Ay * (1.0 - hextheta);\n        float Mdis = sqrt( Mx * Mx + My * My );\n        Mdis *= Mdis;\n        \n        if( spdis > Mdis ){\n            return vec4( 0.0, sin(x), 0.0, 1.0 );\n        }else{\n            return vec4( sin(x)*1.4, 0.0, 0.0, 1.0 );\n        }\n    }\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \nfloat aspect = iResolution.x / iResolution.y;\nfloat heartRadius = 0.7 + sin( iTime * 6.0) * 0.05;\nfloat heartX = 0.5 * aspect;\n    \n    \n    \n    \n    //----- pixel coords -----\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float s = uv.s * aspect;\n    float t = 1.0 - uv.t;\n    \n    \n    //----- get heart shape -----\n    float dx = (s - heartX) / heartRadius;\n    float dy = (t - heartY) / heartRadius;\n    \n    float theta = atan( dy, dx ) + PI / 2.0;\n    theta = abs( PI - abs( theta - PI));\n    float thetamf = theta / PI;\n    \n    float outlineRadius0 = 0.4;\n    float outlineRadius1 = 0.7;\n    \n    float outline = sin( theta * 1.1) * (1.0 - thetamf * thetamf) * outlineRadius0 * heartRadius + outlineRadius1 * heartRadius * thetamf * thetamf;\n    \n    float dis = sqrt( dx*dx + dy*dy );\n    float dismf = dis / outline;\n    \n    if( dismf > 1.0 ){\n        fragColor = texture( iChannel0, vec2( s * 2.0, t * 2.0 )) * 0.4;\n        fragColor = hext( s * 2.0, t * 2.0 );\n        return;\n    }\n    \n    vec3 surfaceNorm = vec3( dx, dy, sqrt( dismf*dismf - dy*dy - dx*dx));\n    \n    \n    \n    \n    \n    \n    \n    \n    //----- get coordinates of texture -----\n    \n    vec2 d = warp( dx, dy, outline );\n    \n    float px = (s - heartX) * 2.0;\n    float py = (t - heartY) * 2.0;\n    vec2 p = warp( px, py, heartRadius );\n    \n   float qx = p.x * 0.15 + d.x * 0.85;\n   float qy = p.y * 0.15 + d.y * 0.85;\n    \n    \n    \n    //----- shading -----\n    dismf = 1.0 - dismf;\n    \n    \n    vec4 texs = texture( iChannel0, vec2( qx * focal + heartX, qy * focal + heartY ) );\n    vec4 tex = hext( qx * focal + heartX, qy * focal + heartY );\n    \n    tex.rgb *= (dismf * 0.9) + 0.1;\n    \n    // specular\n    dismf = dismf * dismf;\n    tex.rgb += dismf * texs.rgb * 10.0;\n        \n    fragColor = tex;\n}\n","name":"Image","description":"","type":"image"}]}