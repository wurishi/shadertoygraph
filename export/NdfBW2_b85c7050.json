{"ver":"0.1","info":{"id":"NdfBW2","date":"1645479191","viewed":106,"name":"Dizziness Inducer I","username":"rucksack","description":"Infinitely repeating model with (crude) fog. Using Inigo Quilez' SDFs and a base hacked together from The Art of Code's tutorial.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Raymarching parameters\n#define MAX_STEPS 512\n#define NEAR_ENOUGH 0.001\n#define TOO_FAR 85.0\n\n// Lighting parameters\n#define DIFFUSE_FACTOR 0.6\n#define SPECULAR_FACTOR .9\n#define SHININESS 16.\n\n// Materials (some random industrial color palette)\n#define BACKGROUND_COLOR vec3(100./255., 110./255., 120./255.)\n#define GRID_COLOR vec3(161./255., 175./255., 176./255.)\n\n// Dizziness parameters\n#define ROTATION_SPEED 0.4\n#define MOVE_SPEED 1.5\n\n// SDFs (from https://iquilezles.org/articles/distfunctions)\n\nfloat sphereDistance(vec3 point, vec3 center, float radius) {\n    return length(point - center) - radius;\n}\n\nfloat boxDistance( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat cylinderDistance( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nvec3 repeat(vec3 point, vec3 period) {\n    return mod(point + .5*period, period) - .5*period;\n}\n\n// The scene\n\nconst mat3 rot90z = transpose(mat3(\n    0, -1, 0,\n    1, 0, 0,\n    0, 0, 1));\nconst mat3 rot90x = transpose(mat3(\n    1, 0, 0,\n    0, 0, -1,\n    0, 1, 0));\n\nfloat distanceFromEverything(vec3 point) {\n\n    vec3 repeated = repeat(point, vec3(2, 2, 2));\n    float sphereDist = sphereDistance(repeated, vec3(0), .3);\n    float boxDist = boxDistance(repeated, vec3(.25));\n    float cyly = cylinderDistance(repeat(point, vec3(2, 0, 2)), vec3(0, 0, .1));\n    float cylx = cylinderDistance(repeat(rot90z * point, vec3(2, 0, 2)), vec3(0, 0, .1));\n    float cylz = cylinderDistance(repeat(rot90x * point, vec3(2, 0, 2)), vec3(0, 0, .1));\n\n    float dist = max(boxDist, sphereDist);\n    dist = min(dist, cyly);\n    dist = min(dist, cylx);\n    dist = min(dist, cylz);\n    return dist;\n}\n\n// Rays and lighting\n\nfloat rayMarch (vec3 rayorig, vec3 raydir) {\n    // How far we've traveled\n    float dist = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        // Where we stand\n        vec3 point = rayorig + raydir*dist;\n        // How far anything is from us\n        float scenedist = distanceFromEverything(point);\n        // March on\n        dist += scenedist;\n        // Check status - have we reached a surface?\n        if (scenedist < NEAR_ENOUGH || dist > TOO_FAR)\n            break;\n    }\n    return dist;\n}\n\nvec3 normal(vec3 point) {\n    vec2 e = vec2(NEAR_ENOUGH, 0); // x smol, y none\n    float dist = distanceFromEverything(point);\n    // Find normal as tangent of distance function\n    return normalize(dist - vec3(\n        distanceFromEverything(point - e.xyy),\n        distanceFromEverything(point - e.yxy),\n        distanceFromEverything(point - e.yyx)\n    ));\n}\n\nfloat light(vec3 point, vec3 lightpos, vec3 n, vec3 cam) {\n    vec3 l = normalize(lightpos-point);\n    // Standard diffuse term\n    float diffuse = max(dot(n, l), 0.);\n    float specular = pow(max(dot(reflect(-l, n), -cam), 0.), SHININESS);\n\n    return DIFFUSE_FACTOR * diffuse + SPECULAR_FACTOR * specular;\n}\n\n\nvec3 fullLighting(vec3 point, vec3 camPos, vec3 camDir, float dist) {\n    // Avoid casting specular highlight from the void\n    if (length(point - camPos) > TOO_FAR*0.99)\n        return BACKGROUND_COLOR;\n\n    // Light moves with camera\n    vec3 lightpos = vec3(0, 5, camPos.z);\n    vec3 l = normalize(lightpos-point);\n    vec3 n = normal(point);\n\n    // Get the standard light\n    float base = light(point, lightpos, n, camDir);\n    return mix(BACKGROUND_COLOR, base * GRID_COLOR, smoothstep(0.3*TOO_FAR, 0., dist));\n}\n\n\n// From assignment template code in TDT4230\nfloat rand(vec2 co) { return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453); }\nfloat dither(vec2 uv) { return (rand(uv)*2. - 1.) / 256.; }\n\n// Start!\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n        \n    // Ray origin -- Camera moves over time.\n    vec3 campos = vec3(1, 1, mod(iTime, 2./MOVE_SPEED) * MOVE_SPEED);\n    // Ray direction -- Camera rotates over time.\n    float rot = -ROTATION_SPEED * iTime;\n    mat3 rotz = transpose(mat3(\n        cos(rot), -sin(rot), 0,\n        sin(rot),  cos(rot), 0,\n               0,         0, 1));\n    vec3 raydir = normalize(rotz * vec3(uv, 1.));\n\n    float dist = rayMarch(campos, raydir);\n    \n    vec3 surfacePoint = campos + raydir * dist;\n    \n    vec3 color = fullLighting(surfacePoint, campos, raydir, dist);\n\n    // Gamma correction not from the video :))))\n    color = pow(color, vec3(.4545));\n\n    // Output to screen\n    fragColor = vec4(color + dither(fragCoord),1.0);\n}\n","name":"Image","description":"","type":"image"}]}