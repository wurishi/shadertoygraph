{"ver":"0.1","info":{"id":"wdSBzK","date":"1590408003","viewed":1415,"name":"Voxel raycasting","username":"vizaxo","description":"Voxel raycasted sphere","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","sphere","voxel","shading","minecraft"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.141592;\nconst float tau = 2.0*pi;\n\n//#define TIME (3.0*tau/4.0)\n#define TIME iTime/2.0\n\nconst float sphereRadius = 15.0;\nconst float camRadius = 2.0*sphereRadius;\n\nstruct hit {\n    bool didHit;\n    vec3 col;\n};\n\nhit getVoxel(ivec3 p) {\n    if (length(vec3(p)) < sphereRadius)\n        return hit(true, vec3(p) / (sphereRadius * 2.0) + 0.6);\n    else\n        return hit(false, vec3(0,0,0));\n\n}\n\nvec3 lighting(vec3 norm, vec3 pos, vec3 rd, vec3 col) {\n    vec3 lightDir = normalize(vec3(-1.0, 3.0, -1.0));\n    float diffuseAttn = max(dot(norm, lightDir), 0.0);\n    vec3 light = vec3(1.0,0.9,0.9);\n    \n    vec3 ambient = vec3(0.2, 0.2, 0.3);\n    \n    vec3 reflected = reflect(rd, norm);\n    float specularAttn = max(dot(reflected, lightDir), 0.0);\n    \n    return col*(diffuseAttn*light*1.0 + specularAttn*light*0.6 + ambient);\n}\n\n// Voxel ray casting algorithm from \"A Fast Voxel Traversal Algorithm for Ray Tracing\" \n// by John Amanatides and Andrew Woo\n// http://www.cse.yorku.ca/~amana/research/grid.pdf\nhit intersect(vec3 ro, vec3 rd) {\n    //Todo: find out why this is so slow\n    vec3 pos = floor(ro);\n    \n    vec3 step = sign(rd);\n    vec3 tDelta = step / rd;\n\n    \n    float tMaxX, tMaxY, tMaxZ;\n    \n    vec3 fr = fract(ro);\n    \n    tMaxX = tDelta.x * ((rd.x>0.0) ? (1.0 - fr.x) : fr.x);\n    tMaxY = tDelta.y * ((rd.y>0.0) ? (1.0 - fr.y) : fr.y);\n    tMaxZ = tDelta.z * ((rd.z>0.0) ? (1.0 - fr.z) : fr.z);\n\n    vec3 norm;\n    const int maxTrace = 100;\n    \n    for (int i = 0; i < maxTrace; i++) {\n        hit h = getVoxel(ivec3(pos));\n        if (h.didHit) {\n            return hit(true, lighting(norm, pos, rd, h.col));\n        }\n\n        if (tMaxX < tMaxY) {\n            if (tMaxZ < tMaxX) {\n                tMaxZ += tDelta.z;\n                pos.z += step.z;\n                norm = vec3(0, 0,-step.z);\n            } else {\n                tMaxX += tDelta.x;\n            \tpos.x += step.x;\n                norm = vec3(-step.x, 0, 0);\n            }\n        } else {\n            if (tMaxZ < tMaxY) {\n                tMaxZ += tDelta.z;\n                pos.z += step.z;\n                norm = vec3(0, 0, -step.z);\n            } else {\n            \ttMaxY += tDelta.y;\n            \tpos.y += step.y;\n                norm = vec3(0, -step.y, 0);\n            }\n        }\n    }\n\n \treturn hit(false, vec3(0,0,0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    vec3 worldUp = vec3(0,1,0);\n    vec3 camPos = vec3(camRadius*sin(TIME), 10, 1.0*camRadius*cos(TIME));\n    vec3 lookAt = vec3(0,0,0);\n    vec3 camDir = normalize(lookAt - camPos);\n    vec3 camRight = normalize(cross(camDir, worldUp));\n    vec3 camUp = cross(camRight, camDir);\n    \n    vec3 filmCentre = camPos + camDir*0.3;\n    vec2 filmSize = vec2(1,iResolution.y / iResolution.x);\n    \n    vec3 filmPos = filmCentre + uv.x*filmSize.x*camRight + uv.y*filmSize.y*camUp;\n    vec3 ro = camPos;\n    vec3 rd = normalize(filmPos - camPos);\n    \n    hit h = intersect(ro, rd);    \n    if(h.didHit) {\n        fragColor = vec4(h.col,0);\n    } else{\n        fragColor = vec4(0,0,0,0);\n    }\n}","name":"Image","description":"","type":"image"}]}