{"ver":"0.1","info":{"id":"3dSczy","date":"1586819185","viewed":90,"name":"Pulse 2D - generate pulse in 2d","username":"mikelsv","description":"Generate 2d pulse from formula.","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["pulse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// <--- Moved to buffer A ---\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //fragColor = vec4(0.0,0.0,1.0,1.0);\n    vec3 buf = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    fragColor = vec4(buf, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Pulse 2d - Generate 2d pulse from formula.\n// Research for Maticals http://maticals.senin.world/\n\n// Prev project: Pulse - generate 1d pulse: https://www.shadertoy.com/view/WdBcRG\n// Next project: Pulse 3D - generate pulse in 3d.\n// Child project: Buffer - use video memory buffer: https://www.shadertoy.com/view/tdSczK\n\n// You can see how work any functions on 1d dimensional.\n// See function names and colors in Configure section.\n\n// Created: 2020-04-13\n//\n// Update: 2020-04-14.\n// [!] Refactoring code.\n// [+] box_sin & box_cos - sin and cos for box.\n// [+] Angle function.\n//\n// Update: 2020-04-15\n// [!] Refactoring, delete double define.\n// [+] Add buffer for shadow.\n\n// [~] Project in process ...\n// [?] Draw path for circle, box, diamond.\n\nconst float SCALE_X = 1.5;\nconst float SCALE_Y = 1.5;\n\nconst float PULSE_TIME = 2.000; // Pulse one time = PI / 2\nconst float PULSE_TIMES = 2. * PULSE_TIME; // Pulse all times\nconst float PULSE_STEP = PULSE_TIMES / PULSE_TIME;\n\n// Add shadow buffer for objects\n#define SBUF_ILEN\t32\n#define SBUF_LEN\t(1. * float(SBUF_ILEN))\nvec3 shadow[SBUF_ILEN * SBUF_ILEN];\n\n#define RGBC_GREEN vec4(19. / 255., 229. / 225., 19. / 225., 1.)\n#define RGBC_BLUE vec4(47. / 255., 206. / 225., 208. / 225., 1.)\n#define RGBC_RED vec4(222. / 255., 52. / 225., 81. / 225., 1.)\n#define RGBC_PURPLE vec4(224. / 255., 15. / 225., 222. / 225., 1.)\n#define RGBC_YELLOW vec4(148. / 255., 134. / 225., 78. / 225., 1.)\n#define RGBC_ORANGE vec4(255. / 255., 165. / 225., 0. / 225., 1.)\n#define PI 3.141592653589793\n\nfloat box_sin(float angle);\nfloat box_cos(float angle);\nfloat ms_angle(float angle);\n\n// Configure <------------------ Comment to disable, set function name for color\n#define PULSE_CALL_GREEN\tpulseFuncCircle\n#define PULSE_CALL_BLUE\t\tpulseFuncBox\n#define PULSE_CALL_RED\t\tpulseFuncDia\n#define PULSE_CALL_ORANGE\tpulseFuncAngle\n#define PULSE_CALL_PURPLE\tpulseFuncAny\n\n// Use buffer <----------------- Comment define to disable buffer\n#define PULSE_BUFFER\n\nvec2 pulseFuncSin(float val){ // return (val, sin);\n    return vec2(val / PI - 1., sin(val));\n}\n\nvec2 pulseFuncCos(float val){ // return (val, cos);\n    return vec2(val / PI - 1., cos(val));\n}\n\nvec2 pulseFuncBoxSin(float val){ // return (val, box sin);\n    return vec2(val / PI - 1., box_sin(val));\n}\n\nvec2 pulseFuncBoxCos(float val){ // return (val, box cos);\n   return vec2(val / PI - 1., box_cos(val));\n}\n\nvec2 pulseFuncAngle(float val){ // return (val, angle);\n    return vec2(val / PI - 1., ms_angle(val));\n}\n\nvec2 pulseFuncCircle(float val){ // return (sin, cos); Circle;\n    return vec2(sin(val), cos(val));\n}\n\nvec2 pulseFuncBox(float val){ // return (box sin, box cos); Box;\n    return vec2(box_sin(val), box_cos(val));\n}\n\nvec2 pulseFuncDia(float val){ // return (ms_angle, ms_angle); Diamond;\n    return vec2(ms_angle(val), ms_angle(val + PI * .5));\n}\n\nvec2 pulseFuncAny(float val){ // <------- Use for test\n    //return vec2(sin(val) * sin(val) - .5, val / PI - 1.);\n    return vec2(val / PI - 1., sin(val) * sin(val) - .5);\n    \n    //return vec2(val / PI - 1., 0);\n}\n\n// Maticals core functions\nfloat box_sin(float angle){\n\tif(angle < 0.)\n    \tangle = -1. * ( - PI * 2. - angle);\n    angle = mod(angle, PI * 2.);\n    \n\tif(angle <= PI * 0.75)\n\t\treturn min(angle / (PI * 0.25), 1.);\n \n\tif(angle <= PI * 1.75)\n\t\treturn max(-1., 1. - (angle - PI * 0.75) / (PI * 0.25));\n    \n    if(angle <= PI * 2.)\n\t\treturn -1. + (angle - PI * 1.75) / (PI * 0.25);\n\n\treturn 0.;\n}\n\nfloat box_cos(float angle){\n    if(angle < 0.)\n        angle = -1. * ( - PI * 2. - angle);\n    angle = mod(angle, PI * 2.);\n\n    if(angle <= PI * 0.25)\n        return 1.;\n    if(angle <= PI * 0.75)\n        return 1. - (angle - PI * 0.25) / (PI * 0.25);\n    if(angle <= PI * 1.25)\n        return -1.;\n    if(angle <= PI * 1.75)\n        return -1. + (angle - (PI * 1.25)) / (PI * 0.25);\n    if(angle <= PI * 2.)\n        return 1.;\n\n    return 0.;\n}\n\nfloat ms_angle(float angle){\n    if(angle < 0.)\n        angle = -1. * ( - PI * 2. - angle);\n    angle = mod(angle, PI * 2.);\n\n    if(angle <= PI * 0.5)\n\t\treturn angle / (PI * 0.5);\n    \n\tif(angle <= PI * 1.5)\n\t\treturn 1. - (angle - PI * 0.5) / (PI * 0.5);\n    \n    if(angle <= PI * 2.)\n\t\treturn -1. + (angle - PI * 1.5) / (PI * 0.5);\n\n    return 0.;\n}\n\n// Buffer core\n#define SBUF_X_LEN\t256.\n#define SBUF_Y_LEN\t32.\n\n// Get array position\nfloat getArrayPosX(float val){\n    return floor(val * SBUF_X_LEN);\n}\n    \nfloat getArrayPosY(float val){\n    return floor(val * SBUF_Y_LEN) * SBUF_X_LEN;\n}\n\n// in x & y from 0 to 1, out array pos from 0 to 1.\nfloat getArrayPos(float x, float y){\n    return (getArrayPosX(x) + getArrayPosY(y)) / SBUF_Y_LEN / SBUF_X_LEN;        \n}\n\n// Get vec2(x, y) from float, range 0 to 1.\nvec2 getArrayPos2(float val){\n\tvec2 ret;\n\tret.y = floor(val * SBUF_Y_LEN) / SBUF_Y_LEN;\n    ret.x = (val - ret.y) * SBUF_Y_LEN;\n    return ret;\n}\n\n// Call extension\n#define PULSE_FUNC_CALL(call)\t\\\nsx = call(coord.x * PI * PULSE_STEP * SCALE_X - SCALE_X); \\\nsy = call(coord.y * PI * PULSE_STEP * SCALE_Y - SCALE_Y); \\\npv = call(x * PI * PULSE_STEP);\n\nvec4 pulseDrawFunc(in vec2 coord, vec2 pixel, float time, vec2 pv, vec2 sx, vec2 sy, vec4 color){\n    // Draw shadow\n    \n    // Vertical\n    if(abs(sx.y - coord.y * 2. * SCALE_Y + SCALE_Y) < pixel.y * 5.)\n        return color;\n    \n\t// Horizontal\n    if(abs(sy.x - coord.x * 2. * SCALE_X + SCALE_X) < pixel.x * 5.)\n\t\treturn color;    \n    \n    // Draw point\n    if(sqrt(pow(abs(pv.y - coord.y * 2. * SCALE_Y + SCALE_Y) / pixel.y * 1., 2.)\n       + pow(abs(pv.x - coord.x * 2. * SCALE_X + SCALE_X) / pixel.x * 1., 2.)) < 30.\n      )\n        return color;\n    \n    return vec4(0, 0, 0, 1.0);  \n}\n\nvec4 pulseDrawShadowsFunc(in vec2 coord, float time, vec2 pv, vec2 sx, vec2 sy, vec4 color){\n    // Draw point\n    vec2 pixel = vec2(1., 1.);\n    \n    if(sqrt(pow(abs(pv.y - coord.y * 2. * SCALE_Y + SCALE_Y) / pixel.y * 1., 2.)\n       + pow(abs(pv.x - coord.x * 2. * SCALE_X + SCALE_X) / pixel.x * 1., 2.)) < .1\n      )\n        return color * .7;\n    \n    return vec4(0, 0, 0, 1.0);\n}\n\nvec4 pulseDrawShadows(vec2 coord, float time){\n    time = mod(time, PULSE_TIMES);\n    \n    vec4 r = vec4(0, 0, 0, 1.0);\n    \n    // Pulse variables\n    float x = time / PULSE_TIMES, y;// = PULSE_FUNC(x * PI * PULSE_STEP);\n    float px = coord.x, py; // = PULSE_FUNC(coord.x * PI * PULSE_STEP);\n    vec2 pv, sx, sy;\n    \n#ifdef PULSE_CALL_GREEN\n    if(r == vec4(0, 0, 0, 1.0)){\n    \tPULSE_FUNC_CALL(PULSE_CALL_GREEN);\n        r = pulseDrawShadowsFunc(coord, time, pv, sx, sy, RGBC_GREEN);\n    }\n#endif\n    \n#ifdef PULSE_CALL_GREEN\n    if(r == vec4(0, 0, 0, 1.0)){\n    \tPULSE_FUNC_CALL(PULSE_CALL_GREEN);\n        r = pulseDrawShadowsFunc(coord, time, pv, sx, sy, RGBC_GREEN);\n    }\n#endif\n    \n#ifdef PULSE_CALL_BLUE\n    if(r == vec4(0, 0, 0, 1.0)){\n    \tPULSE_FUNC_CALL(PULSE_CALL_BLUE);\n        r = pulseDrawShadowsFunc(coord, time, pv, sx, sy, RGBC_BLUE);\n    }\n#endif  \n\n#ifdef PULSE_CALL_RED\n    if(r == vec4(0, 0, 0, 1.0)){\n    \tPULSE_FUNC_CALL(PULSE_CALL_RED);\n        r = pulseDrawShadowsFunc(coord, time, pv, sx, sy, RGBC_RED);\n    }\n#endif \n    \n#ifdef PULSE_CALL_ORANGE\n    if(r == vec4(0, 0, 0, 1.0)){\n    \tPULSE_FUNC_CALL(PULSE_CALL_ORANGE);\n        r = pulseDrawShadowsFunc(coord, time, pv, sx, sy, RGBC_ORANGE);\n    }\n#endif   \n    \n#ifdef PULSE_CALL_PURPLE\n    if(r == vec4(0, 0, 0, 1.0)){\n    \tPULSE_FUNC_CALL(PULSE_CALL_PURPLE);\n        r = pulseDrawShadowsFunc(coord, time, pv, sx, sy, RGBC_PURPLE);\n    }\n#endif\n    \n    return r;\n}\n\n// Draw interface: coord, pixel size, time\nvec4 pulseDraw(in vec2 coord, vec2 pixel, float time){\n    time = mod(time, PULSE_TIMES);\n    \n    // Interface monitor\n    if((mod(coord.x - .5, 1. / PULSE_STEP / SCALE_X / 5.) <= pixel.x\n       || mod(coord.x - .5, 1. / PULSE_STEP / SCALE_X) <= pixel.x * 4.\n       || mod(coord.x - .5, .5) <= pixel.x * 8.)\n      &&\n       (mod(coord.y - .5, 1. / PULSE_STEP / SCALE_Y / 5.) <= pixel.y\n       || mod(coord.y - .5, 1. / PULSE_STEP / SCALE_Y) <= pixel.y * 4.\n       || mod(coord.y - .5, .5) <= pixel.y * 8.\n      )\n\t) return vec4(1, 1, 0, 1.0);\n    \n    float lx = time / PULSE_TIMES / SCALE_X;\n    //if(abs(lx - coord.x + (coord.x * SCALE_X - .5) / 2.) < pixel.x)\n    if(abs(lx - coord.x + .5 - .5 / SCALE_X) < pixel.x)\n        return vec4(1, 1, 1, 1.0);\n    \n    // Draw pulse\n    vec4 r = vec4(0, 0, 0, 1.0);\n    \n    // Pulse variables\n    float x = time / PULSE_TIMES, y;// = PULSE_FUNC(x * PI * PULSE_STEP);\n    float px = coord.x, py; // = PULSE_FUNC(coord.x * PI * PULSE_STEP);\n    vec2 pv, sx, sy;\n    \n#ifdef PULSE_CALL_GREEN\n    if(r == vec4(0, 0, 0, 1.0)){\n    \tPULSE_FUNC_CALL(PULSE_CALL_GREEN);\n        r = pulseDrawFunc(coord, pixel, time, pv, sx, sy, RGBC_GREEN);\n    }\n#endif\n    \n#ifdef PULSE_CALL_BLUE\n    if(r == vec4(0, 0, 0, 1.0)){\n    \tPULSE_FUNC_CALL(PULSE_CALL_BLUE);\n        r = pulseDrawFunc(coord, pixel, time, pv, sx, sy, RGBC_BLUE);\n    }\n#endif  \n\n#ifdef PULSE_CALL_RED\n    if(r == vec4(0, 0, 0, 1.0)){\n    \tPULSE_FUNC_CALL(PULSE_CALL_RED);\n        r = pulseDrawFunc(coord, pixel, time, pv, sx, sy, RGBC_RED);\n    }\n#endif \n    \n#ifdef PULSE_CALL_ORANGE\n    if(r == vec4(0, 0, 0, 1.0)){\n    \tPULSE_FUNC_CALL(PULSE_CALL_ORANGE);\n        r = pulseDrawFunc(coord, pixel, time, pv, sx, sy, RGBC_ORANGE);\n    }\n#endif   \n    \n#ifdef PULSE_CALL_PURPLE\n    if(r == vec4(0, 0, 0, 1.0)){\n    \tPULSE_FUNC_CALL(PULSE_CALL_PURPLE);\n        r = pulseDrawFunc(coord, pixel, time, pv, sx, sy, RGBC_PURPLE);\n    }\n#endif\n   \n    // Use shadow buffer\n#ifdef PULSE_BUFFER\n    if(r == vec4(0, 0, 0, 1.0)){\n        // Get pixel color in buffer\n    \tvec3 buf = texture(iChannel0, vec2(getArrayPos(coord.x, coord.y), 0)).rgb; \n        return vec4(buf, 1);\n    }\n#endif\n    \n    return r;\n}\n\n// Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    \n    // Get coord from 0 to 1.\n    vec2 coord = fragCoord/iResolution.xy;\n    float box_scale = .8;\n    vec2 coord_box = vec2((coord.x - .1) / .8, (coord.y - .1) / .8);\n    \n    // Use buffer in texture\n    if(fragCoord.y <= 1.){\n        vec3 buf = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n        \n        buf.x *= .99;// + 0.01 * sin(fragCoord.x) + 0.01 * sin(fragCoord.y);\n        buf.y *= .99;// + 0.01 * sin(fragCoord.x) + 0.01 * sin(fragCoord.y);\n        buf.z *= .99;// + 0.01 * sin(fragCoord.x) + 0.01 * sin(fragCoord.y);        \n        \n        // Set white color if limit\n        if( (buf.x < 0.0001 || buf.x > 99999.)\n          && (buf.y < 0.0001 || buf.y > 99999.)\n          && (buf.z < 0.0001 || buf.z > 99999.)\n        \t)\n        \tbuf = vec3(0, 0, 0);\n        \n        // Draw shadow\n        vec2 cd = getArrayPos2(coord.x);// vec2(coord.x, floor(coord.x * SBUF_Y_LEN));\n        \n        vec4 shadow = pulseDrawShadows(cd, iTime);\n        if(shadow != vec4(0, 0, 0, 1.0)){\n            fragColor = shadow;// vec4(1., 0., 1., 1.0);\n        \treturn ;\n        }\n        \n        // Draw red box on mouse click\n        vec2 mouse = iMouse.xy / iResolution.xy;\n        mouse = vec2((mouse.x - .1) / .8, (mouse.y - .1) / .8);\n        if(iMouse.z > 0. && abs(getArrayPos(mouse.x, mouse.y) - coord.x) < 0.001){\n            buf.x = 1.;\n        }\n        \n        fragColor = vec4(buf.x, buf.y, buf.z, 1.);// vec4(1., 0., 1., 1.0);\n        return ;\n    }    \n    \n    // Draw pulse    \n    if(coord.x >= .1 && coord.x < .9 && coord.y >= .1 && coord.y <= .9){\n        fragColor = vec4(0, 0, 0, 1.0);\n        fragColor = pulseDraw(coord_box, vec2(1. / iResolution.x / .8, 1. / iResolution.y / .8), iTime);\n        return ;\n    }    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}