{"ver":"0.1","info":{"id":"MtlSWS","date":"1439416397","viewed":187,"name":"Learning Raymarching 1","username":"dmarcos","description":"Learning how to apply raymarching","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Author: Diego Marcos\n// Learning Computer Graphics Techniques\n// \n// 1. The Basics of Raymarching\n// --------------------------\n//\n// Raymarching is a technique to paint (shade) a 3d scene.\n// \n// We throw rays (lines) from each pixel of the image on the z direction.\n// Advancing over those lines we evaluate how far we are \n// from each object of the scene.\n//\n// If we hit the surface or fall inside an object we will shade (or color) the pixel.\n// In this example I just make the pixels red. No fancy shading, shadows or illumination is applied\n// to keep the code simple and not introduce too many concepts simultaneously.\n// \n// They way to represent objects is a bit different than the usual triangle\n// based geometry you're probably used to. To describe objects we use special functions \n// that given a point in the space they tell us how far we're from the object. \n// This why they are called distance functions.\n//\n// In the example we have a distance function to represent a sphere but there are many others \n// to describe many kinds of geometries e.g: https://iquilezles.org/articles/distfunctions\n//\n// Why is not everybody using this functions and storing millions of vertices instead? \n// It's easy to define functions that describe shapes like spheres, boxes, ellipses, cones, \n// cylinders and combinations of them. \n// It's not that easy to come up with a function that describes for instance, your dog or a tree or any other complex shape.\n// People have tried in the past to build tools that allow artist to create complex objects based on the shapes\n// we can easily represent with distance functions. \n\n\n// The function describes a sphere centered on the origin of coordinates (0,0,0) \n// Aditional transformations are required if you want to place the object somewhere else.\n// Given a point and float that represent the radius\n// the function returns the distance to the surface of the sphere\n// > 0 if the point is outside the sphere\n// < 0 if it's inside\n// == 0 right on the surface of the sphere\nfloat sphereMap( vec3 p, float radius )\n{\n  return length(p)- radius;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Fragment coordinate in NDC (Normalized Device Coordinates)\n\t// Coordinates of the fragment in the range of [-1,1]\n    vec2 q = ( 2.0 * fragCoord.xy - iResolution.xy ) / iResolution.y;\n        \n    // ray origin\n    // the camera position\n    vec3 ro = vec3( 0.0, 0.0, 1.0 );\n    \n    // ray direction pointing deep in the scene (z < 0)\n    // We want a unit vector to keep things tidy\n    vec3 rd = normalize( vec3(q , -1.0) );\n    \n    // Default / background color\n    vec3 col = vec3( 0.7, 0.8, 1.0 );\n\n    // Raymarcher\n    //\n    // We stop raymarching if we are very far from the object.\n    // This behaves a like your far clipping plane of a camera frustum\n    float tmax = 125.0;\n    // Acumulated distance to the object\n    float t = 0.0;\n    // We advance a maximum i steps in the direction of the ray\n    for( int i=0; i<200; i++ )\n    {\n        // That's the current position over the ray\n        // we move over the ray the previous distance\n        // calculated to the object\n        vec3 pos = ro + rd*t;\n        // We evaluate how far we're from the objects\n        // In this case we just have sphere of radius 0.5\n        // centered in the origin\n        float h = sphereMap( pos, 0.5 );\n        // If h is very very small or negative we stop because we're either very close or inside the object\n        // If t > tmax we stop as well because we're very far from it.\n        if( h < 0.001 || t > tmax ) break;\n        // It accumulates the distances to the object calculated in each step\n        // We want this so for a rays passing close to an object but not hitting it. \n        // This cases might not trigger the t > max condition above and we could end up painting those pixels\n        t += h;\n    }\n\n    // If t is less than the max distance we stablished we color the pixel\n    if( t < tmax )\n    {\n        col = vec3( 1.0, 0.0, 0.0 );\n    }\n\n    // We set the final color of the pixel\n\tfragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}