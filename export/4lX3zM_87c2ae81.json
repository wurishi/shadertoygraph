{"ver":"0.1","info":{"id":"4lX3zM","date":"1475494912","viewed":1868,"name":"Dancers","username":"BGC","description":"Heavily based on raymarch algos around shadertoy\nRaymarch study for personal understanding of the following techniques\nRaymarch - Sphere - Normals - Diffuse - Specular - Ambient - Motion blur - Vignette - Gamma ","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["distancefield","motionblur","dancefloor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////\n//\n// DANCERS\n//\n// Heavily based on raymarch algos around shadertoy\n// Raymarch study for personal understanding of the following techniques\n//\n// Raymarch - Sphere - Normals - Diffuse - Specular - Ambient - Motion blur - Vignette - Gamma \n//\n////////////////////////////////////////////////////\n\n//#define debug_sphere\n\nprecision highp float;\n\n// Test color\nvec3 mag = vec3(1.5454,0.5464,1.161981);\nvec3 test = vec3(1.5454,0.5464,1.161981);\n\n// pixel XY\nvec2 xy;\n\n\n// frustum limits\nconst float ncp = 0.;\nconst float fcp = 2.;\nconst float step = 0.03;\n\n// lights\nstruct light{\n\tvec3 p;\n\tfloat di;\n\tfloat si;\n\tvec4 c;\t\n};\nlight KL;\nlight FL;\n\n// time\nfloat T = 0.;\n\n// sin-cos\nfloat sn = 0.;\nfloat cn = 1.;\n\n// ray data\nstruct ray{\n \tvec3 o;\n\tvec3 d;\n\tbool h;\n\tvec3 hp;\n\tvec3 n;\n    float m;\n};\t\n\t\nvoid sincos(float t)\n{\n\tsn = sin(t);\n\tcn = cos(t);\n}\t\n\n//--------------------------------------------------\n\t\nfloat sphere(vec3 _p, vec3 _c, float _r)\n{\n\treturn length(_p-_c)-_r;\n}\n\nfloat plane(vec3 _p, float _h)\n{\n\treturn _p.y - _h;\n}\n\nvec2 opU(vec2 _d, vec2 _o)\n{\n    return _d.x < _o.x ? _d : _o;\n}\n\nvec2 opI(vec2 _d, vec2 _o)\n{\n    return _d.x > _o.x ? _d : _o;\n}\n\n//--------------------------------------------------\n\n// Materials\n#define MAT_PLANE 0.01\n#define MAT_KEYLIGHT 0.02\n\nvec2 map(vec3 _p)\n{\n\tvec2 d0 = vec2(100000.,0.);\n    vec2 d = d0;\n\t\n    vec2 sphere1 = vec2(sphere(_p,vec3(.0,0.,.0),.6),.5);\n    vec2 sphere2 = vec2(sphere(_p,vec3(sn,-.5,cn),.8),.8);\n    vec2 sphere3 = vec2(sphere(_p,vec3(-sn,-.5,-cn),.8),.8);\n    vec2 plane1 = vec2(plane(_p,-1.),MAT_PLANE);\n    vec2 light1 = vec2(sphere(_p,KL.p/30.,.1),MAT_KEYLIGHT);\n    vec2 light2 = vec2(sphere(_p,FL.p/30.,.1),MAT_KEYLIGHT);\n    \n\td = opU(sphere2,sphere3);\n\td = opI(d,sphere1);\n    d = opU(d,plane1);\n    \n    // lights\n    //d = opU(d,light1);\n    //â‰¥d = opU(d,light2);\n    \n    #ifdef debug_sphere\n    d = opU(d0,sphere1);\n    d = opU(d,plane1);\n    #endif\n    \n\treturn d;\t\n}\n\nray camera(vec3 _pos, vec3 _target, vec2 _xy, float _fov)\n{    \n    // initialize ray\n    ray cr;\n\tcr.o = vec3(_xy,0.);\n\tcr.d = normalize(vec3(_fov * _xy,1.));\n\tcr.h = false;\n    \n    // rotation matrix\n    vec3 la = normalize(_target - _pos);\n    vec3 up = vec3(0.,1.,0.);\n    vec3 ri = normalize(cross(up,la));\n    up = cross(la,ri);\n    \n    mat3 m = mat3(ri,up,la);\n    \n    // translation\n    vec3 t = _pos;\n    \n    // apply transforms\n    cr.d = m * cr.d;\n    cr.o = m * cr.o;\n    cr.o = t + cr.o;\n    \n    return cr;\n}\t\n\nray setupCamera(float t, vec2 xy)\n{\n    vec3 cam = vec3(sn,1.5,cn*.5) * .3;\n    vec3 target = vec3(0.);\n    ray cr = camera(cam, target, xy, .2);\n    \n    return cr;\n}\n\n\n//--------------------------------------------------\n\nvoid rayCast(inout ray _r)\n{\t\n\t// ray start point\n\tvec3 p = _r.o;\n\tvec2 d = vec2(0.);\n\tfloat ld = 0.;\n    \n    sincos(iTime*-4.);\n    \n    // traverse map\n    for(int t = 0; t < 1000; t++)\n    {\n        d = map(p);        \n        p += _r.d * d.x;\n        if(d.x < 0.001)\n        {\n            _r.h = true;\n            _r.hp = p;\n            _r.m = d.y;\n                       \n            break;\n        }\n    }\n}\n\nvoid rayMarch(inout ray _r)\n{\n\t// ray start point\n\tvec3 p = _r.o;\n\tvec2 d = vec2(0.);\n\tfloat ld = 0.;\n\t\t\n\t// traverse frustum\n\tfor(float s=ncp; s<fcp; s+=step)\n\t{\n\t\t// step in front\n\t\tp += _r.d*step;\n\t\t\n\t\t// check hit\n\t\td = map(p);\n\t\tif(!_r.h && d.x<0.)\n\t\t{\n\t\t\t_r.h = true;\n\t\t\t\n\t\t\t// interpolate p\n\t\t\tfloat i = step*ld/(ld-d.x);\n\t\t\t_r.hp = p;//_r.o + _r.d * (s-step+i);            \n            break;\n\t\t}\n\t\t\n\t\t//last d\n\t\tld = d.x;\n\t}\n}\n\nvoid normal(inout ray _r)\n{\n    vec2 eps = vec2(.001,.0);\n    float dx = map(_r.hp + eps.xyy).x - map(_r.hp - eps.xyy).x;\n    float dy = map(_r.hp + eps.yxy).x - map(_r.hp - eps.yxy).x;\n    float dz = map(_r.hp + eps.yyx).x - map(_r.hp - eps.yyx).x; \n    _r.n = normalize(vec3(dx,dy,dz));\n}\n\n//--------------------------------------------------\n\nvec4 material(ray _r)\n{\n    if(_r.m == MAT_PLANE)\n    {\n        float f = mod( floor(5.*_r.hp.z) + floor(5.*_r.hp.x), 2.0);\n        return vec4(f);\n    }\n    else if(_r.m == MAT_KEYLIGHT)\n    {\n        return KL.c;\n    }\n    \n\treturn vec4(.5,.2,.3,1.)/2.;\t\n}\n\t\t\nvec4 diffuse(ray _r, light _l)\n{\t\t\n\t// diffuse\n\tvec3 ld = normalize(_l.p - _r.hp);\n\tfloat LdotN = max(dot(ld,_r.n),0.);\n\t\n\tvec4 diff = LdotN * _l.di * _l.c;\n\t\n\treturn vec4(diff);\n}\n\nvec4 specular(ray _r, light _l)\n{\t\t\n\t// specular\n\tvec3 ld = normalize(_l.p - _r.hp);\n\tvec3 rf = reflect(ld,_r.n);\n\tfloat RdotE = max(dot(normalize(rf),normalize(_r.d)),0.);\n\t\n\tvec4 spec = RdotE * _l.si * _l.c;\n\t\n\tspec = pow(spec,vec4(12.)) * 4.;\n\t\n\treturn vec4(spec);\n}\n\nvec4 ambient(light _l)\n{\n\treturn .05 * _l.c;\t\n}\n\nfloat hardShadow(ray _r, vec3 _light)\n{\n    ray r = _r;\n    r.o = _r.hp;\n    r.d = normalize(_light - _r.hp);\n    \n    float s = 1.;\n    float t = 0.02;    \n    for(int i=0; i<30; i++)\n    {        \n        vec3 p = r.o + r.d * t;\n        \n        float d = map(p).x;\n        \n        if(d < 0.002)\n            return 0.;\n        \n        t += d;\n    }\n    \n    return 1.;\n}\n\nfloat softShadow(ray _r, vec3 _light)\n{\n    float tmin = 0.02;\n    float tmax = 2.5;\n        \n    ray lr = _r;\n    lr.o = _r.hp;\n    lr.d = normalize(_light - _r.hp );\n    \n    float t = tmin;    \n    float ss = 1.;\n    for(int i=0; i<30; i++)\n    {                \n        vec3 p = lr.o + lr.d * t;\n        float d = map(p).x;\n        \n        ss = min(ss, 1. * d / t);\n        \n        if(d < 0.002 || t > tmax)\n            break;        \n        \n        t += clamp(d, .02, .1);\n    }\n    \n    return clamp(ss,0.,1.);\n}\n\n\nvec4 colorize(ray _r)\n{\n\tvec4 c = vec4(0.);\n\t\n\t// normal\n\tnormal(_r);\n\t\n\t// material\n\tc = material(_r);\n\t\n\t// lighting\n\tc *= diffuse(_r,KL) * softShadow(_r,KL.p) + diffuse(_r,FL) * softShadow(_r,FL.p);\n\t//c *= diffuse(_r,KL) * hardShadow(_r,KL.p) + diffuse(_r,FL) * hardShadow(_r,FL.p);\n\tc += specular(_r,KL);\n\tc += specular(_r,FL);\n\t//c += ambient(KL);\n\t//c += ambient(FL);\n    \n ///debug\n //test = vec3(softShadow(_r,KL.p));\n    \t\n\treturn c;\n}\n\n//--------------------------------------------------\n\nvec4 render()\n{\n\tvec4 c = vec4(0.);\n\tT = iTime;\n\tray r;\n\tconst float loops = 5.;\n\t\n\t// motion blur\n\tfor(float i=0.; i<loops; i++)\n\t{\n\t\t// cast ray\n\t\tsincos(T);\n        \n        // camera\n\t\tr = setupCamera(T,xy);\n        \n\t\trayCast(r);\t\t\n\t\n\t\t// hit\n\t\tif( r.h )\n\t\t{\n\t\t\t// Colorize\n\t\t\tc += colorize(r)/loops;\n\t\t}\t\n\t\t// miss\n\t\telse\n\t\t{\n\t\t\tc += vec4(0.,0.,.2,0.)/loops;\n\t\t}\t\t\n\t\t\n\t\t// move time for interframe\n\t\tT -= 1./(loops*20.);\n\t}\n\t\n\treturn c;\n}\n\n//=================================================\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n     T = iTime;\n    \n\t// uv\n\txy = fragCoord.xy / iResolution.xy;\n\txy = 2.*xy - 1.;\n\tvec2 uv = xy;\n\txy.x *= iResolution.x / iResolution.y;\n\t\n\t// output color\n\tvec4 c = vec4(0.);\t\n\t\n\t// key light\n\tsincos(iTime*.2);\n\tKL.p = vec3(-2.*sn,10.1,-4.*cn)/3., \n\tKL.si = float(.8), \n\tKL.di = float(1.), \n\tKL.c = vec4(.9,.4,.6,1.)*1.2;\n\t\n\t// fill light\n\tFL.p = vec3(10.,18.,10.);// vec3(-KL.p.x,KL.p.y,-KL.p.z); //\n\tFL.si = float(.7), \n\tFL.di = float(.7), \n\tFL.c = vec4(.3,.3,1.,1.);\n\t\t\n\t// trace\n\tc = render();\n\t\n\t// gamma\n\tc = pow(c,vec4(1./2.2));\n\t\n\t// vignette\n\tc *= exp(-.5*dot(uv,uv));\t\t\n\t\n\t// Output\n\tfragColor = c;\n\t\n\t// tests\n\tif(test != mag) //notEqual\n\t\tfragColor.rgb = test;\n}","name":"Image","description":"","type":"image"}]}