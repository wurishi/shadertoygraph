{"ver":"0.1","info":{"id":"cltGz4","date":"1682027732","viewed":48,"name":"Assignment1 - BO3FCZ","username":"Baigalmaa","description":"copy","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["assignment1bo3fcz"],"hasliked":0,"parentid":"mlc3R8","parentname":"Ass1 v1 Baigalmaa 662"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) //fragment is one unit of primitive in this case, primitive is rectangle and fragment is one pixel point of the screen/rectangle\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n   // vec3 col = uv.xyx;\n\n    // Output to screen\n    //fragColor = vec4(vec3(0.),255.0);\n    //fragColor = vec4(col,1.0);\n    //fragColor = vec4(vec3(0.86231887228*0.5+0.5,0.86231887228*0.5+0.5,-0.83907152907*0.5+0.5),1.);\n    /*\n    int k = 10;\n    ivec2 pix = ivec2(fragCoord);\n    fragColor = vec4(0);\n    for(int i = -k; i <= k; ++i)\n    {\n    \n        for(int j = -k; j <= k; ++j)\n        {\n           // fragColor += texelFetch(iChannel0,pix+ivec2(i,j),0);\n            \n        }\n    }\n    fragColor /= float((2*k+1)*(2*k+1));\n    */\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n    \n    \n    //cos(100) - 0.86231887228\n    //cos(10) - -0.83907152907\n    \n    //R G B\n    //0,1,0 - (0,1) - green\n    //1,1,1 - (1,1) - white\n    //0,0,0 - (0,0) - black\n    //1,0,1 - (1,0) - combination of red and blue\n    //1,0,1 + 0,2,4 - (1,2,5) - combination of red and blue\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float pi = 3.1415926535897932384626433832795;\n\nstruct Sphere {\n    vec3 c;    // center\n    float r;   // radius\n    int MaterialIndex; \n};\n\nstruct Plane {\n    vec3 q0;    // any point on the plane\n    vec3 n;     // normal\n    int MaterialIndex; \n};\n\nstruct Triangle\n{\n    vec3 a;\n    vec3 b;\n    vec3 c;\n    int MaterialIndex;\n};\n\nstruct Ray\n{\n\tvec3 p0;    // ray origin if tmin=0\n\tfloat tmin; // omit solutions t<tmin\n\tvec3 v;     // direction\n\tfloat tmax; // omit solutions t>tmax\n};\n\nstruct TraceResult\n{\n    vec3 n;  // Normal vector on surface\n    float t; // Distance taken on ray\n    int MaterialIndex;\n    vec3 uv; // triangle\n};\n\nstruct Material {\n     vec3  color; // [0,1/pi]\n     float roughness; // [0,~7]\n     vec3  emission; // [0, inf] ambient color\n     float metalness; // 0.02-0.05 for non-metals, 0.6-0.9 for metals\n};","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_DEPTH 3\n#define IoRVacuum 1.0\n#define IoRWater 1.333\n#define IoRGlass 1.5\n#define IoRPlastic 1.58\n#define IoRDaimond 2.42\n\nconst int spheresNo = 3;\nSphere spheres[spheresNo];\n\nconst int planeNo = 4;\nPlane planes[planeNo];\n\nconst int triangleNo = 8;\nTriangle triangles[triangleNo];\n\nconst int materialNo = 4;\nMaterial materials[materialNo];\n\n// ---- CAMERA and EVENTs ----\n// Common key codes (WASD instead of arrows)\n\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nconst vec3 EyeStartPosition = vec3(30,5,5);\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw+EyeStartPosition;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.2;\n    if (isKeyHeld(KeyLeft )) eye -= u*speed;\n    if (isKeyHeld(KeyRight)) eye += u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//P\n               0.5,\t\t\t\t\t\t    //minT\n               normalize(w+px.x*u+px.y*v),\t//V\n               500.);\t\t\t\t\t\t//maxT\n}\n\nconst float maxT = 1000.0;\n\nTraceResult intersectSphere(Ray ray, Sphere s)\n{\n    vec3 p0c = ray.p0 - s.c;\n    float a = dot(ray.v, ray.v);\n    float b = 2.0 * dot(p0c, ray.v);\n    float c = dot(p0c,p0c) - s.r*s.r;\n    float discriminant = b*b - 4.0*a*c;\n    if(discriminant < 0.0)\n        return TraceResult(vec3(0),ray.tmax, s.MaterialIndex, vec3(0)); // no intersection\n    float sqd = sqrt(discriminant);\n    float numerator = -b - sqd;\n    if(numerator < 0.0)\n        numerator = -b + sqd;\n    float t = 0.5 * numerator / a;\n    vec3 p = ray.p0 + t * ray.v;\n    vec3 normal = normalize(p - s.c);\n    return TraceResult(normal, t, s.MaterialIndex, vec3(0));\n}\n\nTraceResult intersectPlane(Ray ray, Plane plane)\n{\n    float t = dot(plane.q0-ray.p0,plane.n)/dot(ray.v,plane.n);\n    return TraceResult(plane.n,t, plane.MaterialIndex, vec3(0));\n}\n\nTraceResult intersectTriangle(Ray ray, Triangle triangle)\n{\n\n\n    vec3 p0 = ray.p0;\n    vec3 ab = triangle.b - triangle.a;\n    vec3 ac = triangle.c - triangle.a;\n    vec3 ap = p0 - triangle.a;    \n    vec3 f = cross(ray.v, ac);\n    vec3 g = cross(ap, ab);\n    vec3 n = cross(ab, ac);\n    float t, u, v;\n    float denom = 1./dot(f,ab);\n    \n    t = denom*dot(g,ac);\n    u = denom*dot(f,ap);\n    v = denom*dot(g,ray.v);\n    \n    float invDet = 1./dot(ab,f);\n    \n    vec3 baryInvdec = vec3(t*invDet, u*invDet, v*invDet);\n   \n    if(t < 0.0 || u < 0.0 || v < 0.0 || (1.-u-v) < 0. )\n        t = -1.;\n        \n    //return TraceResult(n, t, triangle.MaterialIndex, vec3(baryInvdec));\n    //return TraceResult(vec3(0.,t, 0.), t, triangle.MaterialIndex, vec3(baryInvdec));\n    \n    float x = t*triangle.a.x + u*triangle.b.x + v*triangle.c.x;\n    float y = t*triangle.a.y + u*triangle.b.y + v*triangle.c.y;\n    float z = t*triangle.a.z + u*triangle.b.z + v*triangle.c.z;\n    \n    vec3 point = vec3(x,y,z);\n    vec3 pointA = point - triangle.a;\n    \n    return TraceResult(cross(pointA, ab), t, triangle.MaterialIndex, vec3(baryInvdec));\n    \n    \n   \n}\n\nbool intersectPlane1(Ray ray1, Triangle triangle, out TraceResult res) \n{\n    /* Calculate edges. */\n    \n    vec3 rayDir = ray1.v;\n    vec3 ray = ray1.p0;\n\tvec3 BA = triangle.b - triangle.a;\n\tvec3 CA = triangle.c - triangle.a;\n    vec3 n = cross(BA, CA);\n\n\tvec3 RDIRcrossCA = cross(rayDir,CA);\n    \n    /* Calculate determinant using triple product dot(BA, cross(rayDit, CA)) */\n\tfloat det = dot(BA,RDIRcrossCA);\n\n    /* Avoiding division by zero. */\n\tif (det > -0.00001 && det < 0.00001) { return false; }\n\n\tfloat invDet = 1.0 / det;\n    \n\tvec3 RA = ray - triangle.a; // distance from ray origin to A vertex of triangle\n    \n\tfloat baryU = invDet * dot(RA, RDIRcrossCA);\n\n    /* Checking edge CA */\n\tif (baryU < 0.0 || baryU > 1.0) { return false; }\n\n\tvec3 RAcrossBA = cross(RA,BA);\n\tfloat baryV = invDet * dot(rayDir, RAcrossBA);\n\n    /* Checking edge BA */\n\tif (baryV < 0.0 || baryU + baryV > 1.0) { return false; }\n\n\t// at this stage we can compute t to find out where\n\t// the intersection point is on the line\n\tfloat dist = invDet * dot(CA, RAcrossBA);\n\n\tif (dist > 0.00001) // ray intersection\n    {\n        res = TraceResult(vec3(0.,dist, 0.) , dist, 0, vec3(baryU, baryV, dist));\n\t\treturn true;\n    }\n\n    // this means that there is a line intersection\n    // but not a ray intersection\n\treturn false;       \n}\n\n\nTraceResult raycast(Ray ray)\n{\n\n    TraceResult res = TraceResult(vec3(0), ray.tmax, 0, vec3(0));\n    \n    for(int i = 0; i < spheresNo; ++i)\n    {\n        TraceResult res2 = intersectSphere(ray, spheres[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    \n    for(int i = 0; i < planeNo; ++i)\n    {\n        TraceResult res2 = intersectPlane(ray, planes[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    \n    \n    for(int i = 0; i < triangleNo; ++i)\n    {\n        TraceResult res2 = intersectTriangle(ray, triangles[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    return res;\n}\n\n\nvec4 missColor(Ray ray)\n{\n    return vec4(texture(iChannel2, ray.v).xyz,1.);\n}\n\nvec3 fresnel(vec3 l, vec3 n , float metalness, vec3 color, float n2) {\n    float ln = max(dot(l,n), 0.);\n    float n1 = 1.000292; //air\n    vec3 F0;\n    \n    \n    if (metalness >= 0.6 && metalness <= 0.9)\n        F0=vec3((n2-n1)*(n2-n1)/(n2+n1)*(n2+n1));\n    else {\n        if (n2 == IoRWater)//Water\n            F0 = vec3(0.02);\n        else if (n2 == IoRGlass)//Glass\n            F0 = vec3(0.04);\n        else if (n2 == IoRPlastic)//Plastic 1.5 - 1.58\n            F0 = vec3(0.05);\n        else if (n2 == IoRDaimond)//Daimond\n            F0 = vec3(0.17);\n    \n    }\n    F0 = mix(F0, color, metalness);\n    \n    return F0 + (1.0 - F0) * pow(1.0 - ln, 5.0);\n    \n\n}\n\nvec3 cookTorrance(vec3 l, vec3 v, vec3 n, float roughness, vec3 color, float metalness, bool refraction, bool fresnelOnly) {//toLight, toEye, intersection obj normal, roghtness\n   \n    vec3 h = normalize(l+v);\n    float hn = max(dot(h,n), 0.);\n    float vn = max(dot(v,n), 0.);\n    \n    float ln = max(dot(l,n), 0.);\n    float vh = max(dot(v,h), 0.);\n    float lightInt = 0.7;\n  \n    \n    //Geometric attenuation factor\n    float G = min(min(2.*hn*vn/vh, 2.*hn*ln/vh), 1.);\n    \n    //Microfacet density, normal distribution\n    float hn2 = hn*hn;\n    float roughness2 = roughness*roughness;\n    float D = exp((hn2-1.)/(hn2*roughness2))/(roughness2*hn2*hn2*pi);\n    \n    //Fresnel Schlick approximation\n    vec3 f = vec3(0.);\n    \n    if(metalness >= 0.6 && metalness <= 0.9)\n        f = fresnel(l, n , metalness, color, float(IoRVacuum));\n    else \n        f = fresnel(l, n , metalness, color, float(IoRGlass));\n    \n    //Cook-Torrance BRDF\n    vec3 brdf_spec, brdf_diffuse;\n        \n    if(refraction == true)\n        f = 1.- f;\n    if(fresnelOnly == true)\n        return f;\n    else{\n        brdf_spec = vec3(f*D*G/(vn*ln));\n        brdf_diffuse = color * (1. - f);\n        return (brdf_diffuse + brdf_spec) * lightInt * ln;\n    }\n    \n    \n    \n    \n}\n\n\nvec4 hitColor(Ray ray, TraceResult tr)\n{\n\n    vec3 col = vec3(0); \n    vec3 ratio;\n    vec3 valRefl = vec3(0.);\n    vec3 valRefr = vec3(0.);\n    vec3 val = vec3(0.);\n    vec3 v = ray.v;\n    bool rayHit = false;\n    \n    \n        \n        vec3 p = ray.p0 + ray.v*tr.t; //camera ray intersect with object and t is distance\n        vec3 n = tr.n; //normal of camera ray intersected object\n        float metalness = materials[tr.MaterialIndex].metalness;\n        float roughness = materials[tr.MaterialIndex].roughness;\n        vec3 color = materials[tr.MaterialIndex].color;     \n        vec3 emission = materials[tr.MaterialIndex].emission;\n\n        vec3 light1Pos=vec3(9.,19.,10.);\n        vec3 light2Pos=vec3(10.,20.,9.);\n\n        //Light 1\n        vec3 l1 = light1Pos-p;\n        float light1Dist = length(l1);\n        l1 /= light1Dist; // normalized direction to the light\n\n        Ray shadowray1 = Ray(p+0.001*n, 0.001, l1, light1Dist);\n        TraceResult res1 = raycast(shadowray1);\n        \n        //Light 2 \n        vec3 l2 = light2Pos-p;\n        float light2Dist = length(l2);\n        l2 /= light2Dist; // normalized direction to the light\n\n        Ray shadowray2 = Ray(p+0.001*n, 0.001, l2, light2Dist);\n                          /*     p0  , tmin , v,    tmax  */\n        TraceResult res2 = raycast(shadowray2);\n        \n        float costheta, lightInt = 0.7, nv;\n        vec3 k_d, diff, toLight1, toEye, h1, k_s, spec, diffCook;\n\n       \n    \n        if(res1.t==shadowray1.tmax)\n        {\n        \n            //diffuse\n             costheta = max(dot(n,l1),0.); \n             k_d = materials[tr.MaterialIndex].color;\n             lightInt = 0.7;\n             diff = lightInt*k_d *costheta;\n\n             nv = max(dot(n,v),0.); \n\n            //specular\n             toLight1 = normalize(light1Pos - p);\n             toEye = -ray.v;\n             h1 = normalize(toLight1+toEye);\n             k_s = vec3(metalness); //reflection light intensity\n             spec = max(k_s*lightInt*pow(dot(h1,n), 100.),0.);  //Blinn- Phong BRDF\n             diffCook = cookTorrance(toLight1, toEye, n, roughness, k_d, metalness, false, false); //Cook-Torrance BRDF\n                \n             bool rayHit = false;\n             //vec3 amb = ambientColor * k_d * nv;\n\n             col += diffCook;\n             \n   }\n   \n   if(res2.t==shadowray2.tmax)\n    {\n        //diffuse\n             costheta = max(dot(n,l1),0.); \n             k_d = materials[tr.MaterialIndex].color;\n             lightInt = 0.7;\n             diff = lightInt*k_d *costheta;\n\n             nv = max(dot(n,v),0.); \n\n            //specular\n             toLight1 = normalize(light2Pos - p);\n             toEye = -ray.v;\n             h1 = normalize(toLight1+toEye);\n             k_s = vec3(metalness); //reflection light intensity\n             spec = max(k_s*lightInt*pow(dot(h1,n), 100.),0.);  //Blinn- Phong BRDF\n             diffCook = cookTorrance(toLight1, toEye, n, roughness, k_d, metalness, false, false); //Cook-Torrance BRDF\n                \n             \n             //vec3 amb = ambientColor * k_d * nv;\n\n             col += diffCook;\n             \n             \n         \n        \n    }\n   \n   vec3 h;\n   //Light reflect\n   h1 /= length(h1);\n   Ray reflRay = Ray(p+0.001*n, 0.001, h1, length(h1));\n   TraceResult resRefl = raycast(reflRay);\n   vec3 rayO = reflRay.p0;\n   vec3 rayd = reflRay.v;\n   vec3 valtext;\n   for(float j = 0.0; j < float(MAX_DEPTH); j++){\n                \n             //vec3 col = res1.uv;\n             \n             if(resRefl.t==reflRay.tmax){\n                 int blockNo = int(0.0) / int(pow(2.0, float(MAX_DEPTH) - j - 1.0));\n                 vec3 pRef = rayO + rayd*resRefl.t;\n                 vec3 normal = resRefl.n;\n                 rayHit = true;\n                 vec3 frefl = cookTorrance(h1, rayd, normal, roughness, k_d, metalness, false, true); \n                 vec3 frefr = cookTorrance(h1, rayd, normal, roughness, k_d, metalness, true, true); \n                \n                 normal = dot(rayd, normal) <= 0.0 ? normal : -normal;\n                 \n                 if(blockNo % 2 == 0){\n                     rayd = reflect(rayd, normal);\n                     val = texture(iChannel2, rayd).xyz;\n                     val *= pow(val, vec3(1.0)) * frefl;\n                    // h1 = h;\n                   //  ratio*=frefl;\n                 } else{\n                     rayd = refract(rayd, normal, IoRGlass/1.0);\n                     //h1 = h;\n                     //ratio*=frefr;\n                     val = texture(iChannel2, rayd).xyz;\n                     val *= pow(val, vec3(1.0)) * frefr;\n                 }\n                //col += cookTorrance(h1, toEye, n, roughness, k_d, metalness, false); //Cook-Torrance BRDF\n                // col += cookTorrance(h1, toEye, n, roughness, k_d, metalness, true);\n               // toLight1 = h1;\n               //  toEye = reflect(toEye, n);\n               //  h1 = normalize(toLight1+toEye);\n                 rayO =  pRef + rayd * 0.001;\n             \n             }\n             \n             \n             \n    }\n    col += val;\n    /*\n    \n   //Refraction\n   h1 /= length(h1);\n   Ray reflRay = Ray(p+0.001*n, 0.001, h1, length(h1));\n   TraceResult resRefl = raycast(reflRay);\n   vec3 rayO = reflRay.p0;\n   vec3 rayd = reflRay.v;\n   vec3 valtext;\n   for(float j = 0.0; j < float(MAX_DEPTH); j++){\n                \n             //vec3 col = res1.uv;\n             \n             if(resRefl.t==reflRay.tmax){\n                 int blockNo = int(0.0) / int(pow(2.0, float(MAX_DEPTH) - j - 1.0));\n                 vec3 pRef = rayO + rayd*resRefl.t;\n                 vec3 normal = resRefl.n;\n                 rayHit = true;\n                 vec3 frefl = cookTorrance(h1, rayd, normal, roughness, k_d, metalness, false, true); \n                 vec3 frefr = cookTorrance(h1, rayd, normal, roughness, k_d, metalness, true, true); \n                \n                 normal = dot(rayd, normal) <= 0.0 ? normal : -normal;\n                 \n                 if(blockNo % 2 == 0){\n                     rayd = reflect(rayd, normal);\n                     val = texture(iChannel2, rayd).xyz;\n                     val *= pow(val, vec3(1.0)) * frefl;\n                    // h1 = h;\n                   //  ratio*=frefl;\n                 } else{\n                     rayd = refract(rayd, normal, IoRGlass/1.0);\n                     //h1 = h;\n                     //ratio*=frefr;\n                     val = texture(iChannel2, rayd).xyz;\n                     val *= pow(val, vec3(1.0)) * frefr;\n                 }\n                //col += cookTorrance(h1, toEye, n, roughness, k_d, metalness, false); //Cook-Torrance BRDF\n                // col += cookTorrance(h1, toEye, n, roughness, k_d, metalness, true);\n               // toLight1 = h1;\n               //  toEye = reflect(toEye, n);\n               //  h1 = normalize(toLight1+toEye);\n                 rayO =  pRef + rayd * 0.001;\n             \n             }\n             \n             \n             \n    }\n    col += val;*/\n    return vec4(col, 1.0);\n   \n    \n}\n\nvec3 fourthPointTetrahedron(vec3 v0, vec3 v1, vec3 v2) {\n    vec3 centerOfBase = (v0 + v1 + v2)/3.;\n    \n    vec3 ab = v1 - v0;\n    vec3 ac = v2 - v0;\n    vec3 n = -cross(ab, ac);\n    \n    vec3 unit_normal = n/length(n);\n    vec3 scaled_normal = unit_normal * length(ab);\n    vec3 topOftetrahedron = centerOfBase + scaled_normal;\n    \n    return topOftetrahedron;\n}\n\nvec3 rotateAroundY(vec3 p, float a)\n{\n    float s = sin(-a);\n    float c = cos(-a);\n\n    return vec3(\n        p.x * c + p.z * s,\n        p.y,\n        p.z * c - p.x * s);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   // spheres[0] = Sphere(vec3(3.f*sin(iTime*3.f),0, 2), 1.f, 0);\n    spheres[0] = Sphere(vec3(10.,10., 3.), 1.f, 2);\n    spheres[1] = Sphere(vec3(9,14,10), 1.f, 2);\n    spheres[2] = Sphere(vec3(9,14,14), 1.f, 1);\n    \n   // spheres[1] = Sphere(vec3(11.,11.,11.), 1.f, 2);\n    planes[0] = Plane(vec3(0), normalize(vec3(0,1,0)), 0); //floor\n   // planes[1] = Plane(vec3(0, 0,0), normalize(vec3(1,0,0)), 0); //\n   // planes[2] = Plane(vec3(0), normalize(vec3(0,0,1)), 0);\n    //planes[3] = Plane(vec3(0,0,30), normalize(vec3(0,0,1)), 0); //left wall\n    \n    \n    float t = iTime;\n    /*\n    vec3 v0 = vec3(1,0,2)*1.8*cos( 0.1*t + vec3(1.0,1.0,0.0) + 0.0 );\n    vec3 v1 = vec3(2,0,1)*1.8*cos( 0.1*t + vec3(1.0,1.0,0.0) + 1.0 );\n    vec3 v2 = vec3(3,0,2)*1.8*cos( 0.1*t + vec3(1.0,1.0,0.0) + 2.0 );\n    */\n    \n    vec3 v0 = rotateAroundY(vec3(0,0,0),t)*4.0;\n    vec3 v1 = rotateAroundY(vec3(1,0,0),t)*4.0;\n    vec3 v2 = rotateAroundY(vec3(0,0,1),t)*4.0;\n    \n    /*\n    vec3 v0 = rotateAroundY(vec3(0,0,0),t)*1.8;//+ vec3(1.0,1.0,0.0) + 0.0 );\n    vec3 v1 = rotateAroundY(vec3(1,0,0),t)*1.8;//*cos( 0.1*t + vec3(1.0,1.0,0.0) + 0.0 );\n    vec3 v2 = rotateAroundY(vec3(0,0,1),t)*1.8;//*cos( 0.1*t + vec3(1.0,1.0,0.0) + 0.0 );\n    */\n    /*\n    vec3 v0 = vec3(0,3,0);//+ vec3(1.0,1.0,0.0) + 0.0 );\n    vec3 v1 = vec3(1,3,0);//*cos( 0.1*t + vec3(1.0,1.0,0.0) + 0.0 );\n    vec3 v2 = vec3(0,3,1);//*cos( 0.1*t + vec3(1.0,1.0,0.0) + 0.0 );\n    */\n    //float baseHeight = length(fourthPointTetrahedron(v0,v1,v2));\n   \n    \n    \n    triangles[0] = Triangle(v0,v1,v2,2);  \n    triangles[1] = Triangle(v0,v1,fourthPointTetrahedron(v0,v1,v2),2);  \n    triangles[2] = Triangle(v1,v2,fourthPointTetrahedron(v0,v1,v2),2);  \n    triangles[3] = Triangle(v0,v2,fourthPointTetrahedron(v0,v1,v2),2); \n    /*\n    vec3 v00 = rotateAroundY(vec3(0,baseHeight,0),t)*1.8;//+ vec3(1.0,1.0,0.0) + 0.0 );\n    vec3 v11 = rotateAroundY(vec3(baseHeight,baseHeight,0),t)*1.8;//*cos( 0.1*t + vec3(1.0,1.0,0.0) + 0.0 );\n    vec3 v22 = rotateAroundY(vec3(0,baseHeight,baseHeight),t)*1.8;//*cos( 0.1*t + vec3(1.0,1.0,0.0) + 0.0 );\n    */\n   // vec3 center = (v00+v11+v22)/3;s\n    \n    /*vec3 v0 = vec3(6,0,4)*1.8;\n    vec3 v1 = vec3(2,0,2)*1.8;\n    vec3 v2 = vec3(4,0,6)*1.8;\n    \n    triangles[0] = Triangle(v0,v1,v2,3);  \n    triangles[1] = Triangle(v0,v1,fourthPointTetrahedron(v0,v1,v2),3);  \n    triangles[2] = Triangle(v1,v2,fourthPointTetrahedron(v0,v1,v2),3);  \n    triangles[3] = Triangle(v0,v2,fourthPointTetrahedron(v0,v1,v2),3); \n    */\n    /*\n    vec3 v00 = vec3(v0.x,0,v0.z)*1.8;\n    vec3 v11 = vec3(v1.x, 0, v1+length(v2-v0))*1.8;\n    vec3 v22 = vec3(v2.x, 0, v2+length(v1-v0))*1.8;\n    \n    vec3 v00 = vec3(6, 1, 4);\n    vec3 v11 = vec3(2, 1, 2);//*1.8;\n    vec3 v22 = vec3(4, 1, 6);//*1.8;\n    \n    */\n    /*\n    vec3 v00 = vec3(22, 0, 15);\n    vec3 v11 = vec3(16, 0, 16);//*1.8;\n    vec3 v22 = vec3(15, 0, 22);//*1.8;\n    */\n    /*\n    triangles[4] = Triangle(v00,v11,v22,2);  \n    triangles[5] = Triangle(v00,v11,fourthPointTetrahedron(v00,v11,v22),2);  \n    triangles[6] = Triangle(v11,v22,fourthPointTetrahedron(v00,v11,v22),2);  \n    triangles[7] = Triangle(v00,v22,fourthPointTetrahedron(v00,v11,v22),2); \n    */\n    \n    \n    \n    \n    \n    vec3 eye; vec2 data;  \n    Ray ray = Camera(fragCoord, eye, data);\n    \n    \n    TraceResult result = raycast(ray);      // Raycast - camera position \n    \n    vec2 uv = vec2(atan(result.n.x, result.n.z), acos(result.n.y));\n    materials[0] = Material(texture(iChannel3, uv).xyz, 5.5, vec3(0., 0., 0.), 0.9);\n    materials[1] = Material(vec3(0.68, 0.5, 0.3), 6., vec3(1.), 0.05);\n    \n    materials[2] = Material(vec3(0.972,0.960, 0.915), 1., vec3(0.8, 0.6, 0.4), 0.9);\n    materials[3] = Material(vec3(0.,100., 0), 0.15, vec3(0., 0., 0.), 0.9);\n    \n    if(ray.tmax<=result.t)\n        fragColor = missColor(ray);    \n    else\n        fragColor = hitColor(ray, result);\n    /*\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = 0.2*prev + 0.8*fragColor;   // Motion blur\n    fragColor.w = result.t;\n    */\n    \n    // First two pixels are reserved\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.yzw = eye-EyeStartPosition;\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.zw = data;\n        \n  // vec2 uvTriangle = result.uv;\n   //fragCoord = vec2(fragCoord.x + uvTriangle.x, fragCoord.y + uvTriangle.y);\n   \n   /* Test for changing triangle color\n   vec2 p0XZ = vec2(v0.x, v0.z);\n   vec2 p1XZ = vec2(v1.x, v1.z);\n   vec2 p2XZ = vec2(v2.x, v2.z);\n   \n   \n   if (uvTriangle != vec2(0.))\n       if(fragCoord.x ==  uvTriangle.x*p0XZ.x + uvTriangle.y*p1XZ.x + result.t*p2XZ.x \n         && fragCoord.y ==  uvTriangle.x*p0XZ.y + uvTriangle.y*p1XZ.y + result.t*p2XZ.y )\n           fragColor = vec4(vec3(100.,100., 0), 1.);\n  \n    */\n   // vec3 sunPos=vec3(9.,10.,10.);\n   // vec3 sunPos=vec3(9.,10.,10.);\n    //fragColor = vec4(1.);\n    \n}","name":"Buffer A","description":"","type":"buffer"}]}