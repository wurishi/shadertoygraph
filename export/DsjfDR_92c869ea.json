{"ver":"0.1","info":{"id":"DsjfDR","date":"1689600718","viewed":39,"name":"The Poooo","username":"Ronush","description":"it is a magical poo","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"cdjBDR","parentname":"Ronush Raymarch Template"},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*most of this was adapted from evvvvil's code https://www.shadertoy.com/view/3sdXWB\n\nThis was me trying to learn lighting... which devolved into finding out about noise and then poos\n\n\n*/\n#define MAX_STEPS 3000\n#define MAX_DIST 100.\n#define SURF_DIST .0001\n#define PI 3.14159\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\nvec2 smin2(vec2 a,vec2 b,float h){float k=clamp((a.x-b.x)/h*.5+.5,0.,1.);return mix(a,b,k)-k*(1.-k)*h;}\n//NOISE\nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);}\nfloat noise(vec3 p){//Noise function stolen from Virgil who stole it from Shane who I assume understands this shit, unlike me who is too busy throwing toilet paper at my math teacher's house\n  vec3 ip=floor(p),s=vec3(7,157,113);\n  p-=ip; vec4 h=vec4(0,s.yz,s.y+s.z)+dot(ip,s);\n  p=p*p*(3.-2.*p);\n  h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n  h.xy=mix(h.xz,h.yw,p.y);\n  return mix(h.x,h.y,p.z);\n}\nvec4 texNoise(vec2 uv){ float f = 0.; f+=texture(iChannel0, uv*.125).r*.5;\n    f+=texture(iChannel0,uv*.25).r*.25;f+=texture(iChannel0,uv*.5).r*.125;\n    f+=texture(iChannel0,uv*1.).r*.125;f=pow(f,1.2);return vec4(f*.45+.05);\n}\n\n//sdf's\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n//global variables\nvec3 ld = vec3(0, 0, -1);\nvec3 lightPos = vec3(3., 3, -7.);\nfloat tt;\nfloat noi;\nfloat bb;\nvec4 np;\nfloat mm;\nfloat g;\nvec2 t;\n\nmat2 r2(float r){return mat2(cos(r), sin(r), -sin(r), cos(r));}\n\n\n\n//PLACE SHAPES HERE\nvec2 GetDist(vec3 p) {\n    vec3 q = p;\n    vec2 h;\n    noi=texNoise(vec2(.1,.2)*vec2(p.y,dot(p.xz,vec2(.7)))).r;\n    q.y+=noi;\n    t = vec2(sdSphere(q, noise(q+tt)+1.), 0.1);\n    \n    \n    \n    //h = vec2(q.y, 1.);\n    \n    //merge\n    //t = (t.x<h.x)?t:h;\n    \n    t.x*=0.5;\n    return t;\n}\n\n\n\n\n\n\nvec2 map(vec3 p)\n{\n    float tt=mod(iTime,100.);\n    \n    \n    np=vec4(p,1);\n  vec2 h,t=GetDist(p);\n  mm=sin(tt-p.y*.5)*2.;\n  for(int i=0;i<2;i++){\n    np*=2.;\n    np.xyz=abs(np.xyz)-vec3(8.5+mm,8.5,8.5+mm);\n    np.xy*=r2(-.4);\n    np.yz*=r2(.2);\n    h=GetDist(np.xyz);\n    h.x/=np.w;\n    t=smin2(t,h,0.5);\n  }\n  np.xz*=r2(.785);\n  h=vec2(bo(abs(np.xyz)-3.*mm,vec3(0,100,0)),1.);\n  g+=.01/(.1+h.x*h.x*.2);\n  h.x=.7*h.x/np.w;\n  t=t.x<h.x?t:h;\n  bb=texNoise(p.xz*.05).r*.5;\n  h=vec2(0.45*length(p+vec3(0,81.5,0)-mm+bb*3.)-32.,1.-bb*3.);\n  t=smin2(t,h,.5);\n  h=vec2(length(cos(np.xyz*.2-tt))-.0,1);\n  g+=.1/(.1+h.x*h.x*60.);\n  t=t.x<h.x?t:h;\n  return t;\n    \n    \n    \n    t = GetDist(p);\n    \n    return t;\n}\n\n\n\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = map(p).x;\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    if(dO>MAX_DIST) dO=0.;\n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = map(p).x;\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    \n    \n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(max(dot(n, l), 0.), 0.1, 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    d=0.000001/d;\n    if(d<length(lightPos-p)) dif *= 0.4; //shadow\n    \n    \n    dif = smoothstep(0.0, 1., dif);\n    \n    \n    return dif;\n}\n\nfloat logk(float x, float k){\n    return (log(x) / log(k));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    tt = mod(iTime, 100.);\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 backgroundColor=vec3(.1,.1,.1)-length(uv)*.1;\n    vec3 col = backgroundColor;\n    //col = vec3(1., 0., 0.);\n    vec3 ro = vec3(0, 0., -5.);\n    vec3 cw=normalize(vec3(0)-ro);\n\tvec3 cu = normalize(cross(cw, vec3(0, 1, 0)));\n\tvec3 cv = normalize(cross(cw, cu));\n\tvec3 rd = mat3(cu, cv, cw)*normalize(vec3(-uv, 0.5));\n\n    float d = RayMarch(ro, rd);\n    vec3 p = ro + rd * d;\n    \n    float dif = GetLight(p);\n    vec3 n = GetNormal(p);\n    \n    if (d>0.){ //we inside broski\n        float id = map(p).y;\n        vec3 hue;\n\n        \n        //colour id's\n        if (id ==5.) hue = vec3(1., 0, 0);\n        if (id ==3.) hue = vec3(0, 0, 1.);\n        if (id ==1.) hue = vec3(1, 1, 1.);\n        if (id ==2.) hue = vec3(.0,.2,.4);\n        if (id ==4.) hue = vec3(.0,.0,.0);\n        if (id<1.)(hue = mix(vec3(0.3, 0.1, 0.0),vec3(0, 0.1, 0.3), id));\n        col = hue*dif;\n        \n        float fogstrength = 1.;\n        float fog = logk(length(p-ro), 10./fogstrength);\n        //col*=min(1./fog, 1.);\n    \n    \n    //RANDOM LIGHTING SHENANIGANS\n    ld = normalize(lightPos-p);\n    float diffuse=max(0.,dot(n,ld)); // SIMPLE DIFFUSE LIGHTING\n    \n    float fresnel=pow(1.+dot(n,rd),10.); // FRESNEL = BACKGROUND REFLECTIONS ADDED TO EDGES OF GEOMETRY TO COMPOSITE IT BETTER IN THE SCENE\n    fresnel = 0.;\n    float specular=pow(max(dot(reflect(-ld, n),-rd),0.),15.);// SPECULAR LIGHTING = Bright highlights, the shiny white flashy bit especially visible on metallic objects\n    //specular = 0.;\n    float sss=smoothstep(0.,1.,map(p+ld*.4).x/.4);// SSS = Sub surface scattering = Light penetrating through edges of a translucent object, especially visible on candle wax or skin. Can be used as backlight too.\n    //sss=0.;\n    col=mix(hue*(dif+sss*.1)+specular,backgroundColor,fresnel); // Final lighting result made of all the above and then mixed with fresnel\n    col=mix(backgroundColor,col,exp(-.0002*t.x*t.x*t.x)); //fog\n    \n    \n    }\n    \n    \n    \n    \n    \n    \n    \n    fragColor = vec4(pow(col+g*0.04,vec3(.4545)),1);\n}","name":"Image","description":"","type":"image"}]}