{"ver":"0.1","info":{"id":"MXyXDy","date":"1720444577","viewed":101,"name":"Sphere area lights","username":"frostbyte","description":"Sphere area lights based on the Decima 2017 SIGGRAPH presentation.\n\nOriginal shadertoy here: \nhttps://www.shadertoy.com/view/ldfGWs","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["area"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//  Original license:\n//\tCreative Commons CC0 1.0 Universal (CC-0)\n//\t\n//\tarea lights based on Brian Karis's Siggraph 2013 presentation\n//\thttp://blog.selfshadow.com/publications/s2013-shading-course/\n//\t\n//\tkind of pointless for a ray marched scene, but they work with rasterized stuff too.\n//\tI still need to do attenuation and some noodling. comments too, though everything's\n//\tin the course notes at the site above for anyone interested.\n//\t\n//\traymarching code and anything else that looks well written courtesy of iq.\n//\t\n//\t~bj.2013\n\n// Modified to implement Decima's sphere area lights. \n\n//#define DISABLE_ALBEDO\n//#define DISABLE_NORMALS\n//#define DISABLE_ROUGHNESS\n\n\nfloat sphereRad;\nvec3 spherePos1; // old implementation using representative point\nvec3 spherePos2; // old implementation, but using the formulation of Decima based on Karis' implementation\nvec3 spherePos3; // new implementation, based on the NoH maximisation technique by Decima.\n\n#define PI 3.1415\n\nfloat Pow2(float v) { return v * v; }\nfloat Pow4(float v) { return v * v * v * v; }\nfloat rsqrt(float a) { return inversesqrt(a); }\nfloat saturate(float v) { return clamp(v, 0., 1.); }\nvec3 saturate(vec3 v) { return clamp(v, 0., 1.); }\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return saturate((x*(a*x+b))/(x*(c*x+d)+e));\n}\n\nstruct BxDFContext\n{\n\tfloat NoV;\n\tfloat NoL;\n\tfloat VoL;\n\tfloat NoH;\n\tfloat VoH;\t\n};\n\nfloat specTrowbridgeReitz_Legacy( float HoN, float a, float aP )\n{\n\tfloat a2 = a * a;\n\tfloat aP2 = aP * aP;\n\treturn ( a2 * aP2 ) / pow( HoN * HoN * ( a2 - 1.0 ) + 1.0, 2.0 );\n}\n\nfloat specTrowbridgeReitz( float a2, float NoH )\n{\n\tfloat d = ( NoH * a2 - NoH ) * NoH + 1.;\n\treturn a2 / ( PI*d*d );\n}\n\nfloat visSchlickSmithMod( float NoL, float NoV, float r )\n{\n\tfloat k = pow( r * 0.5 + 0.5, 2.0 ) * 0.5;\n\tfloat l = NoL * ( 1.0 - k ) + k;\n\tfloat v = NoV * ( 1.0 - k ) + k;\n\treturn 1.0 / ( 4.0 * l * v );\n}\n\nfloat Vis_SmithJointApprox( float a2, float NoV, float NoL )\n{\n\tfloat a = sqrt(a2);\n\tfloat Vis_SmithV = NoL * ( NoV * ( 1. - a ) + a );\n\tfloat Vis_SmithL = NoV * ( NoL * ( 1. - a ) + a );\n\treturn 0.5 * 1.0 / ( Vis_SmithV + Vis_SmithL );\n}\n\nfloat fresSchlickSmith( float HoV, float f0 )\n{\n\treturn f0 + ( 1.0 - f0 ) * pow( 1.0 - HoV, 5.0 );\n}\n\nfloat New_a2( float a2, float SinAlpha, float VoH )\n{\n\t//return a2 + 0.25 * SinAlpha * (3.0 * sqrt(a2) + SinAlpha) / ( VoH + 0.001 );\n\t//return a2 + 0.25 * SinAlpha * ( saturate(12. * a2 + 0.125) + SinAlpha ) / ( VoH + 0.001 );\n    \n    // the following seems more pleasing and energy conserving:\n\treturn a2 + 0.25 * SinAlpha * ( a2 * 2. + 1. + SinAlpha ) / ( VoH + 0.001 );\n}\n\nfloat EnergyNormalization( inout float a2, float VoH, float SinAlpha )\n{\n\tfloat Sphere_a2 = a2;\n\tfloat Energy = 1.;\n\tif( SinAlpha > 0. )\n\t{\n\t\tSphere_a2 = New_a2( a2, SinAlpha, VoH );\n\t\tEnergy = a2 / Sphere_a2;\n\t}\n\treturn Energy;\n}\n\nvoid SphereMaxNoH( inout BxDFContext Context, float SinAlpha, bool bNewtonIteration )\n{\n\tif( SinAlpha > 0. )\n\t{\n\t\tfloat CosAlpha = sqrt( 1. - Pow2( SinAlpha ) );\n\t\n\t\tfloat RoL = 2. * Context.NoL * Context.NoV - Context.VoL;\n\t\tif( RoL >= CosAlpha )\n\t\t{\n\t\t\tContext.NoH = 1.;\n\t\t\tContext.VoH = abs( Context.NoV );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfloat rInvLengthT = SinAlpha * rsqrt( 1. - RoL*RoL );\n\t\t\tfloat NoTr = rInvLengthT * ( Context.NoV - RoL * Context.NoL );\n\t\t\tfloat VoTr = rInvLengthT * ( 2. * Context.NoV*Context.NoV - 1. - RoL * Context.VoL );\n\n\t\t\tif (bNewtonIteration)\n\t\t\t{\n\t\t\t\t// dot( cross(N,L), V )\n\t\t\t\tfloat NxLoV = sqrt( saturate( 1. - Pow2(Context.NoL) - Pow2(Context.NoV) - Pow2(Context.VoL) + 2. * Context.NoL * Context.NoV * Context.VoL ) );\n\n\t\t\t\tfloat NoBr = rInvLengthT * NxLoV;\n\t\t\t\tfloat VoBr = rInvLengthT * NxLoV * 2. * Context.NoV;\n\n\t\t\t\tfloat NoLVTr = Context.NoL * CosAlpha + Context.NoV + NoTr;\n\t\t\t\tfloat VoLVTr = Context.VoL * CosAlpha + 1.   + VoTr;\n\n\t\t\t\tfloat p = NoBr   * VoLVTr;\n\t\t\t\tfloat q = NoLVTr * VoLVTr;\n\t\t\t\tfloat s = VoBr   * NoLVTr;\n\n\t\t\t\tfloat xNum = q * ( -0.5 * p + 0.25 * VoBr * NoLVTr );\n\t\t\t\tfloat xDenom = p*p + s * (s - 2.*p) + NoLVTr * ( (Context.NoL * CosAlpha + Context.NoV) * Pow2(VoLVTr) + q * (-0.5 * (VoLVTr + Context.VoL * CosAlpha) - 0.5) );\n\t\t\t\tfloat TwoX1 = 2. * xNum / ( Pow2(xDenom) + Pow2(xNum) );\n\t\t\t\tfloat SinTheta = TwoX1 * xDenom;\n\t\t\t\tfloat CosTheta = 1.0 - TwoX1 * xNum;\n\t\t\t\tNoTr = CosTheta * NoTr + SinTheta * NoBr;\n\t\t\t\tVoTr = CosTheta * VoTr + SinTheta * VoBr;\n\t\t\t}\n\n\t\t\tContext.NoL = Context.NoL * CosAlpha + NoTr;\n\t\t\tContext.VoL = Context.VoL * CosAlpha + VoTr;\n\n\t\t\tfloat InvLenH = rsqrt( 2. + 2. * Context.VoL );\n\t\t\tContext.NoH = saturate( ( Context.NoL + Context.NoV ) * InvLenH );\n\t\t\tContext.VoH = saturate( InvLenH + InvLenH * Context.VoL );\n\t\t}\n\t}\n}\n\nfloat sphereLight( bool newtonIteration, vec3 sphPos, vec3 pos, vec3 N, vec3 V, float f0, float roughness, float NoV, out float NoL, out float atten )\n{\n    vec3 lightV         = sphPos - pos;\n\tvec3 L\t\t\t\t= normalize(lightV);\n\tvec3 H\t\t\t\t= normalize( V + L );\n\t\n    float distSq = dot(lightV, lightV);\n    float invDist = rsqrt(distSq);\n    \n    BxDFContext context;\n    context.NoL = saturate(dot( N, L ));\n    context.NoV = NoV;\n    context.NoH = saturate(dot( H, N ));\n    context.VoH = saturate(dot( H, V ));\n    context.VoL = dot(V, L);\n    \n    // radius multiplied by the inverse distance for the sin alpha of the sphere light - see Decima presentation\n    // Modified based on roughness.\n    float SinAlpha = saturate(sphereRad * invDist * (1. - roughness * roughness));\n    SphereMaxNoH(context, SinAlpha, newtonIteration);\n    \n    context.NoV = saturate(abs(context.NoV) + 1e-5);\n    \n    float a2 = Pow4(roughness);\n    float energy = EnergyNormalization(a2, context.NoV, SinAlpha);\n\tfloat specD\t\t= specTrowbridgeReitz( a2, context.NoH ) * energy;\n\tfloat specF\t\t= fresSchlickSmith( context.VoH, f0 );\n\tfloat specV\t\t= Vis_SmithJointApprox(a2, context.NoV, context.NoL );\n\t\n    NoL = context.NoL;\n    \n    atten = 1.0 / max(1e-4, distSq);\n\treturn specD * specF * specV * context.NoL;\n}\n\nfloat sphereLight_Legacy( vec3 sphPos, vec3 pos, vec3 N, vec3 V, vec3 r, float f0, float roughness, float NoV, out float NoL )\n{\n\tvec3 L\t\t\t\t= sphPos - pos;\n\tvec3 centerToRay\t= dot( L, r ) * r - L;\n\tvec3 closestPoint\t= L + centerToRay * clamp( sphereRad / length( centerToRay ), 0.0, 1.0 );\t\n\tvec3 l\t\t\t\t= normalize( closestPoint );\n\tvec3 h\t\t\t\t= normalize( V + l );\n\t\n\tNoL\t\t\t\t= clamp( dot( N, l ), 0.0, 1.0 );\n\tfloat HoN\t\t= clamp( dot( h, N ), 0.0, 1.0 );\n\tfloat HoV\t\t= dot( h, V );\n\t\n\tfloat distL\t\t= length( L );\n\tfloat alpha\t\t= roughness * roughness;\n\tfloat alphaPrime\t= saturate( sphereRad / ( distL * 2.0 ) + alpha);\n\t\n\tfloat specD\t\t= specTrowbridgeReitz_Legacy( HoN, alpha, alphaPrime );\n\tfloat specF\t\t= fresSchlickSmith( HoV, f0 );\n\tfloat specV\t\t= visSchlickSmithMod( NoL, NoV, roughness );\n\t\n\treturn specD * specF * specV * NoL;\n}\n\nvec3 areaLights( vec3 pos, vec3 nor, vec3 rd )\n{\n\tfloat noise\t\t=  texture( iChannel1, pos.xz ).x * 0.5;\n\tnoise\t\t\t+= texture( iChannel1, pos.xz * 0.5 ).y;\n\tnoise\t\t\t+= texture( iChannel1, pos.xz * 0.25 ).z * 2.0;\n\tnoise\t\t\t+= texture( iChannel1, pos.xz * 0.125 ).w * 4.0;\n\t\n\tvec3 albedo\t\t= pow( texture( iChannel0, pos.xz ).xyz, vec3( 2.2 ) );\n\talbedo\t\t\t= mix( albedo, albedo * 1.3, noise * 0.35 - 1.0 );\n\tfloat roughness = 0.7 - clamp( 0.5 - dot( albedo, albedo ), 0.05, 0.95 );\n\tfloat f0\t\t= 0.3;\n\t\n\t#ifdef DISABLE_ALBEDO\n\talbedo\t\t\t= vec3(0.1);\n\t#endif\n\t\n\t#ifdef DISABLE_ROUGHNESS\n\troughness\t\t= 0.05;\n\t#endif\n\t\n\tvec3 v\t\t\t= -normalize( rd );\n\tfloat NoV\t\t= saturate( dot( nor, v ));\n\tvec3 r\t\t\t= reflect( -v, nor );\n\t\n\tfloat NdotLSphere1;\t    \n    float NdotLSphere2;\n    float NdotLSphere3;\n    \n    float atten2, atten3;\n    float specSph1\t= sphereLight_Legacy(spherePos1, pos, nor, v, r, f0, roughness, NoV, NdotLSphere1 );\n\tfloat specSph2\t= sphereLight(false, spherePos2, pos, nor, v, f0, roughness, NoV, NdotLSphere2, atten2 );\n    float specSph3\t= sphereLight(true, spherePos3, pos, nor, v, f0, roughness, NoV, NdotLSphere3, atten3 );\n    \n    \n    float lumens = 500.0;\n    float luminance = lumens / (4. * 3.1415 * (sphereRad * sphereRad * 10000.));\n    \n\tvec3 color\t\t= luminance * albedo * 0.3183 * saturate( NdotLSphere1 + NdotLSphere2 * atten2 + NdotLSphere3 * atten3) + specSph1 + specSph2 * atten2 + specSph3 * atten3;\n    color = ACESFilm(color);\n    \n\treturn pow( color, vec3( 1.0 / 2.2 ) );\n}\n\nvec3 rotYaw( vec3 v, float a )\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn v * mat3( c, 0,-s,\t0, 1, 0,\ts, 0, c );\n}\n\nvec3 rotPitch( vec3 v, float a )\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn v * mat3( 1, 0, 0,\t0, c,-s,\t0, s, c );\n}\n\nvoid updateLights()\n{\n\tsphereRad\t\t= 0.05;\n    spherePos1\t= vec3(0.5, sphereRad+abs(sin(iTime)) * 0.5, 0);\n    spherePos2\t= vec3(0.0, sphereRad+abs(sin(iTime)) * 0.5, 0);\n    spherePos3\t= vec3(-0.5, sphereRad+abs(sin(iTime)) * 0.5, 0);\n}\n\n//--------------------------------------------------------------------------\n//\teverything below here is based on iq's Raymarching - Primitives shader\t\n//\thttps://www.shadertoy.com/view/Xds3zN\n//\t\n//--------------------------------------------------------------------------\n\n\n\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A list of usefull distance function to simple primitives, and an example on how to \n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: https://iquilezles.org/articles/distfunctions\n\n\nvec2 map( in vec3 pos )\n{\n\tvec2 sphere1\t\t= vec2( length( pos - spherePos1 ) - sphereRad, 2.0 );\n    vec2 sphere2\t\t= vec2( length( pos - spherePos2 ) - sphereRad, 2.0 );\n    vec2 sphere3\t\t= vec2( length( pos - spherePos3 ) - sphereRad, 2.0 );\n\nfloat bump\t\t= 0.0;\n\t\n\t#ifndef DISABLE_NORMALS\n\tbump\t\t\t= texture( iChannel0, pos.xz * 6.0 ).x * 0.002;\n\t#endif\n\t\n\tvec2 res\t\t= vec2( pos.y + bump, 1.0 );\n\tres\t\t\t\t= ( res.x < sphere1.x ) ? res : sphere1;\n    res\t\t\t\t= ( res.x < sphere2.x ) ? res : sphere2;\n    res\t\t\t\t= ( res.x < sphere3.x ) ? res : sphere3;\n\t\n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd )\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float t = 0.0;\n    float m = -1.0;\n    for( int i=0; i<60; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) continue;//break;\n        t += h;\n\t    vec2 res = map( ro+rd*t );\n        h = res.x;\n\t    m = res.y;\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec2( t, m );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.0);      \n    vec2 res = castRay(ro,rd,20.0);\n    \n    if( res.y>-0.5 )\n    {\n\t\tif( res.y == 2.0 )\n\t\t\treturn vec3(1);\n\n        vec3 pos = ro + res.x * rd;\n        vec3 nor = calcNormal( pos );\n\n\t\tcol = areaLights( pos, nor, rd );        \n\t}\n    \n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\n\tvec3 ro = vec3(0,0.1,-1.5);\n\tvec3 ta = vec3(0,0,0);\n\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\t\n\tupdateLights();\n    vec3 col = render( ro, rd );\n\n\tfragColor=vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}