{"ver":"0.1","info":{"id":"4ddSzM","date":"1481676488","viewed":300,"name":"Morphing domain coloring","username":"MBR","description":"Blends between checkerboard and lifted domain coloring.  For highlighting different behaviors of quantites.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["complex","domaincoloring"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// GOTO FULLSCREEN - click on sub-plot\n\n// HACKED version of this shader: https://www.shadertoy.com/view/Mt2GDV\n//   Created by David Bargo - davidbargo/2015\n//   License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Morphing between lifted coloring:\n//    https://www.shadertoy.com/view/4s3SRM\n// and showing a checker-pattern.  In between has similar information\n// as the standard coloring, the the unmodifed shader this is a hack of.\n\n// XXXX\n#define R_GRID 1.0\n#define R_GRID_M 0.75\n//#define SUPERSAMPLE\n#define ANIMATE\n\n#define PI (52707180.0/16777216.0)\n\n\n// --------------------------------------------\n// start of https://www.shadertoy.com/view/Mt2GDV\n\n#define E  2.71828182845\n\nvec2 sinz(vec2 c) \n{\n    float a = pow(E, c.y);\n    float b = pow(E,-c.y);\n    return vec2(sin(c.x)*(a + b)*0.5, cos(c.x)*(a - b)*0.5);\n}\n\nvec2 cosz(vec2 c) \n{\n    float a = pow(E, c.y);\n    float b = pow(E,-c.y);\n    return vec2(cos(c.x)*(a + b)*0.5, -sin(c.x)*(a - b)*0.5);\n}\n\nvec2 tanz(vec2 c) \n{\n    float a = pow(E, c.y);\n    float b = pow(E,-c.y);\n    float cosx = cos(c.x);\n    float sinhy = (a - b)*0.5;\n    return vec2(sin(c.x)*cosx, sinhy*(a + b)*0.5)/(cosx*cosx + sinhy*sinhy);\n}\n\nvec2 logz(vec2 c) \n{\n    return vec2(log(sqrt(dot(c, c))), atan(c.y, c.x));\n}\n\nvec2 sqrtz(vec2 c) \n{\n    float n = c.x + sqrt(dot(c, c));\n    return vec2(n, c.y)/sqrt(2.0*n);\n}\n\nvec2 exp2z(vec2 c) \n{\n\treturn vec2(c.x*c.x - c.y*c.y, 2.*c.x*c.y);   \n}\n\nvec2 epowz(vec2 c) \n{\n\treturn vec2(cos(c.y), sin(c.y))*pow(E, c.x);   \n}\n\nvec2 mulz(vec2 c1, vec2 c2)\n{\n    return c1*mat2(c2.x, -c2.y, c2.y, c2.x);\n}\n\nvec2 divz(vec2 n, vec2 d)\n{\n    return n*mat2(d.x, d.y, -d.y, d.x)/dot(d, d);\n}\n\nvec2 invz(vec2 c)\n{\n\treturn vec2(c.x, -c.y)/dot(c, c);\n}\n\nvec2 func(float cellID, vec2 c)\n{\n    vec2 fz = c;\n    if (cellID == 0.)       fz = c;\n    else if (cellID == 1.)  fz = sinz(c);\n   \telse if (cellID == 2.)  fz = sqrtz(divz(logz(vec2(-c.y - 6.0, c.x)), logz(vec2(-c.y + 2.0, c.x))));\n   \telse if (cellID == 3.)  fz = epowz(c);\n   \telse if (cellID == 4.)  fz = tanz(tanz(c));\n   \telse if (cellID == 5.)  fz = tanz(sinz(c));\n   \telse if (cellID == 6.)  fz = sqrtz(vec2(1.0 + c.x, c.y)) + sqrtz(vec2(1.0 - c.x, -c.y));\n   \telse if (cellID == 7.)  fz = divz(tanz(exp2z(c)), c);\n   \telse if (cellID == 8.)  fz = sinz(cosz(sinz(c)));\n   \telse if (cellID == 9.)  fz = invz(vec2(1.0, 0.0) + epowz(vec2(c.y, c.x)));\n   \telse if (cellID == 10.) fz = epowz(invz(sqrtz(-c)));\n   \telse if (cellID == 11.) fz = exp2z(invz(c));\n   \telse if (cellID == 12.) fz = epowz(sinz(epowz(cosz(c))));   \t\n    else if (cellID == 13.) fz = divz(sinz(c), c);\n   \telse if (cellID == 14.) fz = exp2z(c);\n   \telse if (cellID == 15.) fz = divz(sinz(c), cosz(exp2z(c)));\n    else if (cellID == 16.) fz = invz(c + vec2(1.0, 0.0)) + invz(c - vec2(1.0, 0.0));\n    else if (cellID == 17.) fz = logz(c - invz(c));\n   \telse if (cellID == 18.) fz = divz(sqrtz(vec2(c.x + 1.0, c.y)), sqrtz(vec2(c.x - 1.0, c.y)));\n   \telse if (cellID == 19.) fz = invz(vec2(1.0, 0.0) + mulz(c, exp2z(exp2z(c))));\n\n    return fz;   \n}\n\nvec2 animate(vec2 v) \n{\n#if defined(ANIMATE)\n\tfloat s = sin(iTime);\n    float c = cos(iTime);\n#else\n    float s = 0.0;\n    float c = 1.0;\n#endif\n    return v*mat2(c, -s, s, c);\n}\n\nvec2 gridSize = vec2(5.,4.);\n\nvec3 getCell(vec2 s, vec2 h) \n{\n    float cx = floor(h.x*gridSize.x/s.x);\n    float cy = floor(h.y*gridSize.y/s.y);\n    return vec3(cx, cy, (gridSize.y - 1.0 - cy)*gridSize.x + cx);\n}\n\nvec3 getSmallCells(vec2 s, vec2 h)\n{\n    vec3 c = getCell(s, h);\n    vec2 size = s/gridSize;\n    float ratio = size.x/size.y;\n    vec2 uv = PI*((2.*h-size)/size.y - 2.*vec2(c.x*ratio,c.y));    \n    return vec3(c.z, uv);\n}\n\n//--------------------------------------------------------------------\n//  Lifted domain coloring: https://www.shadertoy.com/view/4s3SRM\n//\n\n\n// coloring tweekable constants\n\n// growth indication constant (>=0). larger is less pronounced.\n// \n#define GROW_K  .9  \n\n// grid line scale (radial & concentric)\n#define GRID_K  0.04\n\n// radial grid lines: shown if defined\n#define RADIAL_GRID\n\n// number of radial lines\n#define RADIAL_LINES 12.0\n\n// concentric grid lines: shown if defined\n#define CONCENTRIC_GRID\n\n\n\n//----------------------\n\n// derived constants\n#define GROW_M  (1.0/(GROW_K+1.0))\n#define GRID_IK (1.0/GRID_K)\n#define RL (RADIAL_LINES/(2.0*PI))\n\nvec3 hsv2rgb(vec3 c)\n{\n  const vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat grid_step(float t)\n{\n  t = min(t, 1.0-t);\n  return smoothstep(0.0, GRID_K, t);\n}\n\n// lifted domain plot color for point 'c'\nvec3 domainPlot(vec2 c)\n{\n  float d     = dot(c,c);\n  float theta = atan(c.y,c.x);\n  \n  // growth indication\n  float b1 = fract(0.5*log2(d));\n  float b0 = b1+b1;\n  \n  if (b0 >= 1.0) b0 -= 1.0;    // b0 = fract(2*b1) \n    \n  float b = GROW_M*(b0+GROW_K);\n    \n  // concentric grid covers branch-point\n  //if (b1 < 0.5) b = 1.0;    \n    \n  // saturation and value\n  float sat = 1.0;\n  float val = 1.0;\n\n  \n  // rectangular grid\n#if defined(R_GRID)\n  {\n    float x = floor(R_GRID*c.x);\n    float y = floor(R_GRID*c.y);\n    if (mod(x+y,2.0)==1.0)  \n      sat*= sin(iTime);\n      else val *= sin(iTime);\n  }\n#endif\n    \n  // radial and concentric grid lines\n  b   = mix(0.0, b,   grid_step(fract(theta*RL))); \n  //sat = mix(0.0, sat, grid_step(b0));\n  \n  // convert to RGB\n  float hue = theta*(1.0/(2.0*PI));\n  vec3  v   = hsv2rgb(vec3(hue,sat,val))*b;\n    \n   v = mix(vec3(1.0), v, grid_step(b0));\n    \n  return v;\n}\n\n// end: Lifted domain coloring\n//--------------------------------------------------------------------\n\n\n// Lazy..half-hearted supersamping rather than cleaning up the\n// base coloring function. This doesn't improve the quality\n// enough to really be worthwhile.\nvec3 domainColorQSS(vec3 cell)\n{ \n  vec2 z  = animate(func(cell.x, cell.yz));\n  vec2 dx = dFdx(z);\n  vec2 dy = dFdy(z);\n  vec2 dm = max(dx,dy);\n  vec3 c0 = 4.0*domainPlot(z);\n  vec3 c1 = domainPlot(animate(func(cell.x, cell.yz+dm)));\n  vec3 c2 = domainPlot(animate(func(cell.x, cell.yz-dm))); dm.y = -dm.y;\n  vec3 c3 = domainPlot(animate(func(cell.x, cell.yz+dm)));\n  vec3 c4 = domainPlot(animate(func(cell.x, cell.yz-dm)));\n  return (1.0/8.0)*(c0+c1+c2+c3+c4);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    vec2 coord = fragCoord.xy;\n    \n    vec3 cell = iMouse.z>0.? \n        vec3(getCell(res, iMouse.xy).z, PI*(2.*coord-res)/(res.y)) : \n    \tgetSmallCells(res, coord);\n      \n#if !defined(SUPERSAMPLE)\n    vec2 z = animate(func(cell.x, cell.yz));\n   fragColor = vec4(domainPlot(z),1.0);\n#else\n   fragColor = vec4(domainColorQSS(cell),1.0);\n#endif\n}","name":"Image","description":"","type":"image"}]}