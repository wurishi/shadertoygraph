{"ver":"0.1","info":{"id":"XfdGD4","date":"1712147973","viewed":53,"name":"DancingHorizon","username":"steinklo","description":"Dancing horizon audio visualizer","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["audio"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","previewfilepath":"/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float rand(vec2 co) {\n    return fract(fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453));\n}\n\nfloat interpolate(float a, float b, float x) {\n    return mix(a, b, smoothstep(0.0, 1.0, x));\n}\n\nfloat valueNoise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Interpolate along x\n    float ab = interpolate(a, b, f.x);\n    float cd = interpolate(c, d, f.x);\n\n    // Interpolate along y\n    return interpolate(ab, cd, f.y);\n}\n\nfloat fbm(vec2 position) {\n    float total = 0.0;\n    float persistence = 0.5;\n    float frequency = 1.0;\n    float amplitude = 1.0;\n\n    for (int i = 0; i < 4; i++) {\n        total += valueNoise(position * frequency) * amplitude;\n        frequency *= 2.0;\n        amplitude *= persistence;\n    }\n\n    return clamp(total, 0.0, 1.0);\n}\nfloat waveEffect(vec2 uv, float time)\n{\n    float wave = sin(uv.x + time) * 0.5 + 0.5;\n    return wave * cos(uv.y + time) * 0.5 + 0.5;\n}\nfloat hash(float n) {\n    return fract(sin(n) * 43758.5453123);\n}\nfloat starIntensity(vec2 st) {\n    float intensity = 0.0;\n    float pixelSize = 1920.0; \n    vec2 uv = floor(st * pixelSize) / pixelSize;\n    float seed = hash(uv.x * 4321.0 + uv.y * 6789.0);\n\n    if (seed > 0.999) {\n        intensity = smoothstep(0.0, 1.0, hash(seed));\n    }\n    return intensity;\n}\nvec3 circle(vec3 backColor, vec3 circleColor, vec2 pos, vec2 uvCoords, float size, float audioValue, float waveValue) {\n    float maxDist = size + audioValue;\n    float dist = distance(uvCoords, pos + waveValue);\n\n    if (dist < maxDist)\n    {\n        return mix(backColor, circleColor, 1.0 - smoothstep(maxDist - size / 3.0, maxDist, dist));\n    }\n    return backColor;\n}\nvec3 illumination(vec3 color, vec2 pos, vec2 uvCoords, float gain, float dayNightValue) {\n return (1.0 - smoothstep(0.0, 2.0, distance(uvCoords, pos))) * smoothstep(0.45, 0.55, dayNightValue) * color * gain;\n}\n\nconst float PI = 3.141592653589793;\n\nfloat horizonLine = 0.4;\nconst vec3 horizonColorNight = vec3(0.9, 0.8, 1.0);\nconst vec3 horizonColorDay = vec3(1.0, 0.3, 0.0);\nconst vec3 skyColorNight = vec3(0.051, 0.067, 0.090);\nconst vec3 skyColorDay = vec3(0.051, 0.04, 0.090) * 7.0;\nconst vec3 oceanColorNight = vec3(0.02, 0.05, 0.1);\nconst vec3 oceanColorDay = vec3(0.02, 0.05, 0.1) * 5.0;\nconst vec3 moonColor = vec3(1.0, 0.98, 0.85);\nconst vec3 sunColor = vec3(1.0, 0.95, 0.45);\nconst float timeGain = 0.1;\nconst float noiseGain = 0.1;\nconst float cloudGain = 0.2;\nconst float cloudDensity = 6.0;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Day/nigth cycle\n    float timeGainer = iTime * timeGain; \n\n    float dayNigthCycle = smoothstep(-1.0, 1.0, sin(timeGainer));\n\n    // Coords\n    vec2 uv = fragCoord/iResolution.xy;\n    float pixelSize = 256.0; // Increase for more pixelation\n    //uv = floor(uv * pixelSize) / pixelSize;\n    vec2 centeredCoords = uv * 2.0 - 1.0;\n\n    // Colors\n    float dayNightValue = smoothstep(0.4, 0.6, dayNigthCycle);\n    float starValue = starIntensity(uv);\n    vec3 nightSkyColor = mix(skyColorNight, vec3(1.0), starValue * smoothstep(horizonLine, horizonLine + 0.1, uv.y));\n    vec3 colorOceanNigth = mix(oceanColorNight, vec3(1.0), starValue * 0.15);\n\n    vec3 colorMoon = moonColor;\n    vec3 colorSun = sunColor;\n    vec3 skyColor = mix(nightSkyColor, skyColorDay, dayNigthCycle);\n    vec3 oceanColor  = mix(colorOceanNigth, oceanColorDay, dayNigthCycle);\n    vec3 horizonColor = mix(horizonColorNight, horizonColorDay, dayNightValue);   \n\n    // Audio animation\n    float audioValue = texture(iChannel0, vec2(uv.x, 0.0)).x;\n\n\n\n    float wave = waveEffect(centeredCoords * vec2(90.0, 67.0), dayNigthCycle);\n    float reflectWave = waveEffect(centeredCoords * vec2(40.0), dayNigthCycle * 2.0);\n\n    // Moon\n    float moonSize = 0.15;\n    vec2 moonPos = vec2(-cos(timeGainer + PI), sin(timeGainer + PI));\n    float diminishMoonGain = 1.0 - smoothstep(0.4, 1.0, moonPos.y) * 0.3;\n    float moonReflectSize = moonSize * diminishMoonGain;\n    moonPos.y += horizonLine - 0.5;\n    vec2 moonReflectPos = moonPos;\n    moonReflectPos.y = -(0.5 - horizonLine) * 4.0 - moonPos.y;\n    moonReflectPos.y *= diminishMoonGain;\n\n\n    skyColor = circle(skyColor, colorMoon, moonPos, centeredCoords, moonSize, audioValue * 0.05,  wave * 0.012);\n    oceanColor = mix(oceanColor, circle(oceanColor, colorMoon, moonReflectPos, centeredCoords, moonReflectSize, audioValue * 0.05,  reflectWave * 0.012), 0.2);\n\n\n    // Sun\n    float sunSize = 0.2;\n    vec2 sunPos = vec2(-cos(timeGainer) * 1.0, sin(timeGainer));\n    float diminishSunGain = 1.0 - smoothstep(0.4, 1.0, sunPos.y) * 0.3;\n    float sunReflectSize = sunSize * diminishSunGain;\n    sunPos.y -= (0.5 - horizonLine) * 2.0;\n    vec2 sunReflectPos = sunPos;\n    sunReflectPos.y = -(0.5 - horizonLine) * 4.0 - sunPos.y;\n    sunReflectPos.y *= diminishSunGain;\n\n    skyColor = circle(skyColor, colorSun, sunPos, centeredCoords, sunSize, audioValue * 0.05,  wave * 0.012);\n    oceanColor = mix(oceanColor, circle(oceanColor, colorSun, sunReflectPos, centeredCoords, sunReflectSize , audioValue * 0.05,  reflectWave * 0.012), 0.2);\n\n    // Illumination\n    skyColor += illumination(colorSun, sunPos, centeredCoords, 0.25, dayNigthCycle);\n    oceanColor += illumination(colorSun, sunReflectPos, centeredCoords, 0.25, dayNigthCycle);\n    skyColor += illumination(colorMoon, moonPos, centeredCoords, 0.15, 1.0 - dayNigthCycle);\n    oceanColor += illumination(colorMoon, moonReflectPos, centeredCoords, 0.15, 1.0 - dayNigthCycle);\n\n\n    // Clouds\n    vec2 pos = fragCoord/iResolution.xy;\n    pos.x += iTime * 0.03;\n    pos.y = pos.y * 2.0 + iTime * 0.01;\n    float n = fbm(pos * cloudDensity); \n    skyColor = mix(skyColor, vec3(1.0), n * cloudGain);\n    oceanColor = mix(oceanColor, vec3(1.0), n * cloudGain * 0.33);\n\n    // Horizon\n    float audioGain = audioValue * 0.2;\n    float horizonCurve = sin(uv.x * PI) * 0.015;\n    float horizonAudio = audioGain + horizonCurve ;\n    float horizonReflectAudio = -audioGain + horizonCurve;\n    vec3 skyBlend = mix(horizonColor, skyColor, smoothstep(horizonLine + horizonCurve, horizonLine*1.01 + horizonCurve, uv.y));\n    vec3 oceanBlend = mix(oceanColor, horizonColor, smoothstep(horizonLine*0.99 + horizonCurve, horizonLine + horizonCurve, uv.y));\n    vec3 color = mix(oceanBlend, skyBlend, smoothstep(horizonLine*0.99 + horizonReflectAudio, horizonLine*1.01 + horizonAudio, uv.y));   \n\n\n    // Audio flicker\n    color = mix(color, horizonColor, audioValue * sin(uv.y * 2.0 + timeGainer * 10.0) * noiseGain * 0.5);\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}