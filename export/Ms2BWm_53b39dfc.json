{"ver":"0.1","info":{"id":"Ms2BWm","date":"1500760436","viewed":118,"name":"Starwars Narrow Path","username":"yumcyawiz","description":".","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n\nfloat df(vec3 p) {\n    p = abs(p);\n    p = mod(p, 4.0) - vec3(2.0);\n    int n = 0;\n    while(n < 10) {\n        if(p.x + p.y < 0.0) p.xy = -p.yx;\n        if(p.x + p.z < 0.0) p.xz = -p.zx;\n        if(p.y + p.z < 0.0) p.yz = -p.yz;\n        p = p*2.0 - (2.0 - 1.0)*vec3(1.5);\n        p = p*vec3(-0.5, 1, 1);\n        n++;\n    }\n    return length(p)*pow(2.0, -float(n));\n}\n\n\nvec3 calcNormal(vec3 p) {\n    float eps = 0.001;\n    return normalize(\n        vec3(df(p + vec3(eps, 0, 0)) - df(p + vec3(-eps, 0, 0)),\n             df(p + vec3(0, eps, 0)) - df(p + vec3(0, -eps, 0)),\n             df(p + vec3(0, 0, eps)) - df(p + vec3(0, 0, -eps))\n        ));\n}\n\n\nstruct Ray {\n    bool hit;\n    vec3 hitPos;\n    vec3 hitNormal;\n    int steps;\n    float t;\n};\n\n\nconst int maxStep = 100;\nRay trace(vec3 from, vec3 rayDir) {\n    bool hit = false;\n    vec3 hitPos = vec3(0);\n    vec3 hitNormal = vec3(0);\n    int steps = 0;\n    float t = 0.0;\n    for(int i = 0; i < maxStep; i++) {\n        vec3 p = from + t*rayDir;\n        float d = df(p);\n        if(d < 0.005) {\n            hit = true;\n            hitPos = p;\n            hitNormal = calcNormal(p);\n            steps = i;\n            break;\n        }\n        t += d;\n    }\n    return Ray(hit, hitPos, hitNormal, steps, t);\n}\n\n\nvec3 shading(vec3 from, vec3 rayDir) {\n    Ray tr = trace(from, rayDir);\n    if(!tr.hit) {\n        return vec3(0);\n    }\n    \n    //StepsAO\n    float stepsAO = float(tr.steps)/float(maxStep);\n    \n    //DetailedAO\n    float detailedAO = 0.0;\n    for(int i = 1; i <= 10; i++) {\n        float d1 = float(i)/float(10)*0.17;\n        vec3 p = tr.hitPos + tr.hitNormal * d1;\n        float d2 = df(p);\n        detailedAO += (d1 - d2)*1.0;\n    }\n    \n    float aoFactor = max(1.0 - detailedAO, 0.0);\n    float fogFactor = max(1.0 - tr.t/10.0, 0.0);\n    \n    vec3 n = tr.hitNormal;\n    float dist = length(tr.hitPos - from);\n    float diffuse = max(dot(-rayDir, n), 0.0);\n    float geometryTerm = 1.0/(pow(0.2*dist, 2.0) + 1.0);\n    \n    vec3 matColor = n + vec3(1);\n    \n    return (geometryTerm*diffuse*matColor*aoFactor);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy/2.0)/iResolution.y;\n    \n    vec3 camPos = vec3(0, 0, -3.0 + iTime*0.5);\n    vec3 camFront = normalize(vec3(0.3*cos(iTime), 0.3*sin(iTime), 1));\n    vec3 camUp = vec3(0, 1, 0);\n    vec3 camRight = cross(camFront, camUp);\n    vec3 rayDir = normalize(0.5*camFront + uv.x*camRight + uv.y*camUp);\n    \n    vec3 color = shading(camPos, rayDir);\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}