{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"vec3 colors[22] = vec3[22](\n    vec3(0.929, 0.949, 0.984),\n    vec3(0.886, 0.917, 0.988),\n    vec3(0.843, 0.890, 0.988),\n    vec3(0.800, 0.859, 0.992),\n    vec3(0.757, 0.827, 0.996),\n    vec3(0.714, 0.800, 0.996),\n    vec3(0.671, 0.768, 1.000),\n    vec3(0.678, 0.843, 0.965),\n    vec3(0.529, 0.749, 1.000),\n    vec3(0.247, 0.557, 0.988),\n    vec3(0.149, 0.404, 1.000),\n    vec3(0.231, 0.157, 0.800),\n    vec3(0.247, 0.757, 0.753),\n    vec3(0.125, 0.729, 0.773),\n    vec3(0.000, 0.698, 0.792),\n    vec3(0.016, 0.651, 0.761),\n    vec3(0.033, 0.600, 0.729),\n    vec3(0.059, 0.502, 0.667),\n    vec3(0.086, 0.404, 0.604),\n    vec3(0.104, 0.357, 0.573),\n    vec3(0.110, 0.333, 0.557),\n    vec3(0.114, 0.306, 0.537)\n);\n\nvec2 rotatePoint(vec2 p, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    mat2 rotationMatrix = mat2(c, -s, s, c);\n    return rotationMatrix * p;\n}\n\nfloat exponentialSin(float t, float freq) {\n    float low = 0.005;\n    float high = 0.05;\n    float sinVal = cos(2.0 * 3.14159265 * freq * t+3.14159265) * 0.5 + 0.5;\n    return low * exp(sinVal * log(high / low));\n}\n\nint kochSnowflake(vec2 p, int max_iterations, float zoomDiv, out float dist) {\n    int current_iterations = 0;\n    \n    float lineWidth = exponentialSin(iTime, 0.02) * zoomDiv;\n    while (current_iterations < max_iterations) {\n        float angle = atan(p.y, p.x); \n        if (angle < 0.0) angle += 2.0 * 3.141592653589793;\n\n        if (angle >= radians(330.0) || angle < radians(90.0)) {\n            p = rotatePoint(p, radians(-60.0));         \n        } else if (angle >= radians(90.0) && angle < radians(210.0)) {\n            p = rotatePoint(p, radians(60.0));         \n        } else {\n            p = rotatePoint(p, radians(180.0));         \n        }\n\n        float diff = abs(p.y-0.5);\n        if (diff <= lineWidth) {\n            dist = diff / lineWidth;\n            return current_iterations;\n        }\n\n        p.y -= 0.75;\n        p *= 2.0;\n        lineWidth *= 2.0;\n        current_iterations++;\n    }\n\n    return -1;\n}\n\n// Taken from https://www.reedbeta.com/blog/hash-functions-for-gpu-rendering/\nuint pcg_hash(uint inputt)\n{\n    uint state = inputt * 747796405u + 2891336453u;\n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    return (word >> 22u) ^ word;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    float iTimeMod = iTime / 1.5;\n    int permutations = int(iTimeMod/2.0);\n    if(permutations > 0){\n         iTimeMod = 2.0 + mod(iTimeMod, 2.0);\n         permutations -= 1;\n    }\n    float zoomDiv = 1.0 / pow(2.0, iTimeMod);\n    p *= 4.0 * zoomDiv;\n    p += vec2(0.4330127018922, 0.25);\n    \n    float dist;\n    int depth = kochSnowflake(p, 60, zoomDiv, dist);\n    if(depth < 0){\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    if (depth > 0) {\n        depth += 2 * permutations;\n    }\n    uint v = pcg_hash(uint(depth)) % uint(colors.length());\n\n    vec3 color = colors[int(v)];\n    fragColor = vec4(color * (1.0-pow(dist, 5.0)), 1.0);\n    return;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"M3ccDM","date":"1735152635","viewed":50,"name":"Koch Snowflake Variation","username":"ITR","description":"An ever-zooming snowflake. Has a bunch of random colors from coolors.co.\nNot actually a koch snowflake, but inspired by it.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["procedural","fractal","christmas","snowflake","snow","koch"],"hasliked":0,"parentid":"","parentname":""}}