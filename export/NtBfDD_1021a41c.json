{"ver":"0.1","info":{"id":"NtBfDD","date":"1652190332","viewed":140,"name":"Collide ","username":"jvb","description":"Particle collider ","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["animation","whiteroom"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#if 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(texture(iChannel0,uv).xyz,1.0);\n}\n#endif","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n//uniform float time;\n//uniform vec2 mouse;\n//uniform vec2 resolution;\n//uniform sampler2D texture; \n\nvec3 rotatey(in vec3 p, float ang) { return vec3(p.x*cos(ang)-p.z*sin(ang),p.y,p.x*sin(ang)+p.z*cos(ang)); }\nvec3 rotatex(in vec3 p, float ang) { return vec3(p.x, p.y*cos(ang)-p.z*sin(ang),p.y*sin(ang)+p.z*cos(ang)); }\nvec3 rotatez(in vec3 p, float ang) { return vec3(p.x*cos(ang)-p.y*sin(ang),p.x*sin(ang)+p.y*cos(ang),p.z); }\n\nvec2 sph(in vec3 p, float r, float o) { return vec2(length(p)-r, o); }\nvec2 rbox(in vec3 p, in vec3 b, float r, float o) { return vec2(length(max(abs(p)-b,0.0))-r, o); }\nvec2 sdbox( vec3 p, vec3 b, float o ) { vec3 d = abs(p) - b; return vec2(min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)), o); }\nvec2 plane(in vec3 p, in vec3 n, float d, float o) { return vec2(dot(p,n)-d, o); }\n\nvec2 min2(in vec2 o1, in vec2 o2) { if (o1.x < o2.x) return o1; else return o2; }\nvec2 max2(in vec2 o1, in vec2 o2) { if (o1.x > o2.x) return o1; else return o2; }\n\nfloat rep(float x, float h) { return mod(x+h,2.0*h)-h; }\n\nfloat time;\nfloat time2;\n\nvec3 get_sph_pos()\n{\n\treturn vec3(0,-1,-5); \n}\nvec2 scene(in vec3 p)\n{\n\tvec3 op = p; \n\tvec2 d = vec2(1000.0, 0.0); \n\n\tfloat t = iMouse.x*10.0; \n\t\n\tif (time2 > 5.5 && p.y < 0.0) {\n\t\tp.y += sin(length(p.xz-vec2(0,-5))*7.0-time2*0.5)*0.05*clamp(time2-5.5,0.0,1.0)*exp(-0.2*(time2-5.5)); \n\t}\n\td = min2(d,sdbox(p-vec3(0,0,0), vec3(16,16,64), 1.0)); \n\td = max2(d,vec2(-1,1)*sdbox(p-vec3(0,0,0), vec3(4,2,8), 1.0)); \n\n\tp.z = rep(p.z, 2.0); \n\td = min2(d,sdbox(p-vec3(0,2.2,-0), vec3(10,0.5,1), 1.0)); \n\n\t//p = op; \n\t//d = min2(d,sdbox(p-vec3(0,2,-5), vec3(2,0.1,1), 1.0)); \n\t\n\tp = op; \n\tif (time2 < 4.5) {\n\t\td = min2(d,sph(p-vec3(4.5-(time2),0,0)-get_sph_pos(), 0.05, 3.0)); \n\t\td = min2(d,sph(p-vec3(-4.5+(time2),0,0)-get_sph_pos(), 0.05, 3.0)); \n\t}\n\telse {\n\t\tp -= get_sph_pos(); \n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfloat scx = 0.05/( time2-4.5); \n\t\t\tp = rotatex(p, p.x*1.0+time2*0.1); \n\t\t\tp = rotatey(p, p.x*0.2); \n\t\t\td = min2(d,sph((p-vec3(0,0.1,0))*vec3(scx,1,1), 0.05+0.1+sin(p.x)*0.1,2.0)); \n\t\t}\n\t\tp = op; \n\t\td = min2(d,sph(p-vec3(0,-(time2-4.5),0)-get_sph_pos(), 0.05+(time2-4.5)*0.01, 3.0)); \n\t}\n\treturn d; \n}\n\nvec3 get_normal(in vec3 p)\n{\n\tvec3 eps = vec3(0.001, 0, 0); \n\tfloat nx = scene(p + eps.xyy).x - scene(p - eps.xyy).x; \n\tfloat ny = scene(p + eps.yxy).x - scene(p - eps.yxy).x; \n\tfloat nz = scene(p + eps.yyx).x - scene(p - eps.yyx).x; \n\treturn normalize(vec3(nx,ny,nz)); \n}\n\nfloat tri(float x) {\n\tx = mod(x, 1.0); \n\tif (x > 0.5) x = 1.0 - x; \n\treturn x; \n}\nvec3 get_tex(in vec3 p) \n{\n\tvec3 op = p; \n\tvec3 col2 = vec3(0.4); \n\tvec3 col3 = vec3(0.75); \n\n\tfloat LT = 0.01; \n    \n    if (length(p.yz-vec2(-1,-5)) < 0.3) return vec3(0);\n\nif (abs(p.y-1.9) < LT) return col3; \n\tif (abs(p.y+1.9) < LT) return col3; \n\treturn vec3(1); \n}\n\n\n// ambient occlusion approximation\n// multiply with color\nfloat ambientOcclusion(vec3 p, vec3 n, float time)\n{\n    const int steps = 3;\n    const float delta = 0.5;\n\n    float a = 0.0;\n    float weight = 1.0;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - scene(p + n*d).x);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nfloat random(vec3 scale, float seed) { \n\treturn fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed); \n} \n\nvec3 cosineWeightedDirection(float seed, vec3 normal) {\n\tfloat u = random(vec3(12.9898, 78.233, 151.7182), seed); \n\tfloat v = random(vec3(63.7264, 10.873, 623.6736), seed); \n\tfloat r = sqrt(u); \n\tfloat angle = 6.283185307179586 * v; \n\tvec3 sdir, tdir; \n\tif (abs(normal.x)<.5) { \n\t\tsdir = cross(normal, vec3(1,0,0)); \n\t} else { \n\t\tsdir = cross(normal, vec3(0,1,0)); \n\t} \n\ttdir = cross(normal, sdir); \n\treturn r*cos(angle)*sdir + r*sin(angle)*tdir + sqrt(1.-u)*normal; \n} \n\nvec3 uniformlyRandomDirection(float seed) { \n\tfloat u = random(vec3(12.9898, 78.233, 151.7182), seed); \n\tfloat v = random(vec3(63.7264, 10.873, 623.6736), seed); \n\tfloat z = 1.0 - 2.0 * u; float r = sqrt(1.0 - z * z); \n\tfloat angle = 6.283185307179586 * v; \n\treturn vec3(r * cos(angle), r * sin(angle), z); \n} \n\nvec3 uniformlyRandomVector(float seed) { \n\treturn uniformlyRandomDirection(seed) * sqrt(random(vec3(36.7539, 50.3658, 306.2759), seed)); \n} \n\n\nvec2 scene2(in vec3 p) {\n\tvec2 d = vec2(1000.0, 0.0); \n\t\n\t\n\tp.x = rep(p.x, 1.0); \n\tp.z = rep(p.z, 1.0); \n\td = min2(d, sdbox(p-vec3(0,2,0), vec3(1,1,1)*0.2, 1.0)); \n\treturn d; \n}\nvec3 rm2(in vec3 ro, in vec3 rd, float time) \n{\n\tvec3 color = vec3(0.0);  \t\n\tvec3 pos = ro; \n\tfloat dist = 0.0; \n\tvec2 d; \n\t\n\tfor (int i = 0; i < 64; i++) {\n\t\td = scene2(pos); \n\t\tpos += rd*d.x;\n\t\tdist += d.x; \n\t}\n\tif (dist < 10000.0 && abs(d.x) < 1.0) {\n\t\tfloat o = d.y; \n\t\tvec3 n = get_normal(pos); \n\t\tfloat fres = clamp(dot(n,-rd), 0.0, 1.0); \n\t\tvec3 tex = get_tex(pos); \n\t\tvec3 col = vec3(0); \n\t\t\tif (o == 0.0) {\n\t\t\t}\n\t\t\telse if (o == 1.0) {\n\t\t\t\tcol = tex*mix(vec3(1,1,1)*1.0,vec3(1,1,1)*0.8, fres); \n\t\t\t}\n\t\t\telse if (o == 2.0) {\n\t\t\t\tcol = mix(vec3(1,1,1)*1.0,vec3(1,1,1)*0.8, fres); \t\t\n\t\t\t}\n\t\t\n\t\tcolor = col; \n\t\t\n\t}\n\t\n\treturn color;\n}\n\nvec3 rm(in vec3 ro, in vec3 rd, float time)\n{\n\tvec3 colorMask = vec3(1.0); \n\tvec3 color = vec3(0.0);  \n\t\n\tif (true) {\n\t\tvec3 pos = ro; \n\t\tfloat dist = 0.0; \n\t\tvec2 d; \n\t\t\n\t\tfor (int i = 0; i < 80; i++) {\n\t\t\td = scene(pos); \n\t\t\tpos += rd*d.x*0.5;\n\t\t\tdist += d.x*0.5; \n\t\t}\n\t\tif (dist < 10000.0 && abs(d.x) < 1.0) {\n\t\t\tfloat o = d.y; \n\t\t\tvec3 n = get_normal(pos); \n\t\t\tvec3 l = normalize(vec3(0,1,0)); \n\t\t\tvec3 lightpos = vec3(10,0,+40); \n\t\t\tfloat fres = clamp(dot(n,-rd), 0.0, 1.0); \n\t\t\tvec3 tex = get_tex(pos); \n\t\t\tvec3 surfaceColor = vec3(0); \n\t\t\tif (o == 0.0) {\n\t\t\t}\n\t\t\telse if (o == 1.0) {\n\t\t\t\tsurfaceColor = tex*mix(vec3(1,1,1)*1.0,vec3(1,1,1)*0.8, fres); \n\t\t\t}\n\t\t\telse if (o == 2.0) {\n\t\t\t\tsurfaceColor = mix(vec3(1,1,1)*1.0,vec3(1,1,1)*0.8, fres); \t\t\n\t\t\t}\n\t\t\telse if (o == 3.0) {\n\t\t\t\tvec3 sph_pos = get_sph_pos(); \n\t\t\t\tsurfaceColor = mix(vec3(1,1,1)*0.4,vec3(1,1,1)*0.0, pow(fres,1.0)); \t\n\t\t\t\tfloat spec0 = 1.0*pow(clamp(dot(reflect(n,l), normalize(vec3(0.0,-2,1.0))),0.0,1.0), 10.0); \n\t\t\t\tsurfaceColor += spec0*vec3(1,1,1);\n\t\t\t}\n\t\t\tfloat shade = 1.0;//+0.0*ambientOcclusion(pos+0.01*n, n, time); \n\t\t\tcolorMask *= surfaceColor; \n\t\t\tcolor += colorMask*(0.25*surfaceColor*shade)*clamp(dist*0.25, 0.0, 2.5); \n\t\t\t\n\t\t\tfor (int bounce = 1; bounce < 3; bounce++) {\n\t\t\tro = pos+n*0.01; \n\t\t\trd = normalize(cosineWeightedDirection(time+float(bounce), n));\t\n\t\tvec3 pos = ro; \n\t\tfloat dist = 0.0; \n\t\tvec2 d; \n\t\t\n\t\tfor (int i = 0; i < 16; i++) {\n\t\t\td = scene(pos); \n\t\t\tpos += rd*d.x;\n\t\t\tdist += d.x; \n\t\t}\n\t\tif (dist < 1000.0 && abs(d.x) < 1.0) {\n\t\t\tfloat o = d.y; \n\t\t\tvec3 n = get_normal(pos); \n\t\t\tvec3 l = normalize(vec3(0,1,0)); \n\t\t\tfloat diff = clamp(dot(n,l), 0.0, 1.0); \n\t\t\tfloat fres = clamp(dot(n,-rd), 0.0, 1.0); \n\t\t\tvec3 tex = get_tex(pos); \n\n\t\t\tvec3 surfaceColor = vec3(0); \n\t\t\tif (o == 0.0) {\n\t\t\t}\n\t\t\telse if (o == 1.0) {\n\t\t\t\tsurfaceColor = tex*mix(vec3(1,1,1)*1.0,vec3(1,1,1)*0.8, fres); \t\t\n\t\t\t}\n\t\t\telse if (o == 2.0) {\n\t\t\t\tsurfaceColor = mix(vec3(1,1,1)*1.0,vec3(1,1,1)*0.8, fres); \t\t\n\t\t\t}\n\t\t\telse if (o == 3.0) {\n\t\t\t\tsurfaceColor = mix(vec3(1,1,1)*0.4,vec3(1,1,1)*0.0, fres); \t\t\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsurfaceColor = vec3(0);\t\n\t\t\t}\n\t\t\tfloat shade = 1.0; //ambientOcclusion(pos+0.01*n, n, time); \n\t\t\tcolorMask *= surfaceColor; \n\t\t\tcolor += colorMask*(0.25*surfaceColor*shade)*clamp(dist*0.25, 0.0, 100.0); \n\t\t}\t\n\t\t\telse {\n\t\t\t}\n\t\t}\n\t\t}\t\n\t\telse {\n\t\t\tcolor= vec3(0,0,0); \n\t\t}\n\t\t\n\t}\n\t\n\n\treturn color; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = 2.0*fragCoord/iResolution.xy-1.0;\n\tp.x *= iResolution.x/iResolution.y; \n\n\ttime = mod(iTime,10.0); \n    time2 = mod(iTime, 10.0);\n\n    vec3 campos = vec3(sin(time)*10.0,1,0); \n\tvec3 camtar = vec3(0,1,1); \n\tvec3 camup = vec3(0,1,0);\n\t\n\tvec3 camdir = normalize(camtar-campos);\n\tvec3 cu = normalize(cross(camdir, camup)); \n\tvec3 cv = normalize(cross(cu, camdir)); \n\t\n\tvec3 color = vec3(0.0); \n\t\n\tp.xy += uniformlyRandomVector(time).xy*0.002*1.0;\n\tvec3 ro = vec3(0,0,2.0);\n\tvec3 rd = normalize(vec3(p.x,p.y,-2.0)); \n\n\t// barrel distortion\n\t#if 1\n\trd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z - dot(rd.xy, rd.xy)*0.2, 0.))));\n    rd.z *= -1.0;\n\t#endif\n\t\n\tro.z -= time2*0.2;\n\tfloat aa = 0.01; \n\tcolor += rm(ro+uniformlyRandomVector(time)*aa*0.0, rd, time); \n\n\tcolor = pow(color, vec3(1.0/2.6)); \n\tcolor = mix(color, texture(iChannel0,fragCoord.xy/iResolution.xy).xyz, 0.7);\n\tfragColor = vec4(color, 1.0); \n}\t\t\n\n","name":"Buffer A","description":"","type":"buffer"}]}