{"ver":"0.1","info":{"id":"7d2fD3","date":"1647294397","viewed":79,"name":"First assignment - w5u6vq","username":"dtamaas","description":"Assignment for Computer Graphics course","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["cg","elte"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Image\n// iChannel0: Buffer A\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Common\nstruct Plane {\n    vec3 q0;\n    vec3 n;\n    int materialId;\n};\n\nstruct Sphere {\n    vec3 c;\n    float r;\n    int materialId;\n};\n \nstruct Triangle {\n    vec3 a;\n    vec3 b;\n    vec3 c;\n    int materialId;\n};\n\nstruct Material {\n    vec3 color;\n    vec3 diffuse;\n    vec3 specular;\n    vec3 emission;\n    float shininess;    \n};\n\nstruct Light {\n    vec3 position;\n    float radius;\n    int materialId;\n};\n\nstruct Ray {\n    vec3 p0;    // ray origin if tmin=0\n    float tmin; // omit solutions t<tmin\n    vec3 v;     // direction\n    float tmax; // omit solutions t>tmax\n};\n \nstruct TraceResult {\n    vec3 n;           // Normal vector on surface\n    float t;          // Distance taken on ray\n    int materialId;    // Objects's material id\n};\n\n// Containers\nMaterial materials[10];\nSphere spheres[8];\nPlane planes[3];\nTriangle triangles[1];\nLight lights[1];\n\n// ---- CAMERA and EVENTs ----\n// Common key codes (WASD instead of arrows)\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n// Consts\nconst vec3 EyeStartPosition = vec3(-30,3,0);\nconst float maxT = 1000.0;\nconst int iterations = 16;\nconst float pi = 3.1415926535897932384626433832795;\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Buffer A\n// iChannel0: Buffer A\n// iChannel1: Keyboard\n\nTraceResult raycast(Ray ray, bool shadow);\n\nvec3 missColor(Ray ray) {\n    return vec3(0);\n}\n\nvec3 hitColor(Ray ray, TraceResult tr) {\n    Light light = lights[0];\n    Material mat = materials[tr.materialId];\n    \n    vec3 p = ray.p0 + ray.v * tr.t;\n    vec3 n = tr.n;\n    vec3 v = -ray.v;\n    vec3 l = normalize(light.position - p);\n    \n    // Emission\n    vec3 emission = mat.emission * dot(n,v);\n    \n    // Shadow\n    Ray shadowray = Ray(p,0.001,l,length(light.position-p));\n    TraceResult shadowRes = raycast(shadowray, true);\n    \n    if (shadowRes.t < shadowray.tmax) {\n         return emission;\n    }\n    \n    // Diffuse\n    float costheta = max(dot(n,l),0.);\n    vec3 k_d = mat.color * mat.diffuse;\n       \n    // Specular\n    vec3 toLight = normalize(light.position - p);\n    vec3 toEye = -ray.v;\n    vec3 k_s = vec3(mat.specular);\n    vec3 h = normalize(toLight+toEye);\n    \n    // Shininess\n    float si = pow(clamp(dot(h,n),0.,1.),mat.shininess);\n    \n    // Final color\n    vec3 color = emission+(k_d+si*k_s)*costheta;\n        \n    return color;\n}\n\n/*\nWe will use the first 2 pixels of the buffer to store the information we need.\nEvery pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n    pixel0 = (empty, cameraX, cameraY, cameraZ)\n    pixel1 = (empty, empty, U, V)\nwhere \n    cameraX, cameraY and cameraZ describe the position of the camera respectively\n    U,V give the current rotation of the camera in spherical coordinates\n*/\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2) {\n   \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw+EyeStartPosition;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z > 0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.2;\n    if (isKeyHeld(KeyLeft )) eye -= u*speed;\n    if (isKeyHeld(KeyRight)) eye += u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//P\n               0.5,\t\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//V\n               500.);\t\t\t\t\t\t//maxT\n}\n\n// ---- MAIN ----\n// From lecture notes\nTraceResult intersect(Ray ray, Triangle tr) {\n    vec3 ab = tr.b - tr.a;\n    vec3 ac = tr.c - tr.a;\n    vec3 ap = ray.p0 - tr.a;\n    vec3 f = cross(ray.v,ac);\n    vec3 g = cross(ap,ab);\n    \n    float multiplier = 1.0 / dot(f,ab);\n    float t = multiplier * dot(g,ac);\n    float u = multiplier * dot(f,ap);\n    float v = multiplier * dot(g,ray.v);\n    \n    // Condition taken from: https://www.shadertoy.com/view/MlGcDz\n    if (t <= 0.0 || u < 0.0 || v < 0.0 || (u + v) > 1.0) {\n        return TraceResult(vec3(0), ray.tmax, tr.materialId);\n    }\n    \n    vec3 p = ray.p0 + t * ray.v;\n    vec3 normal  = normalize(p - cross(ab, ac));\n    \n    return TraceResult(normal, t, tr.materialId);\n}\n\nTraceResult intersect(Ray ray, Sphere s) {\n    vec3 p0c = ray.p0 - s.c;\n    \n    float a = dot(ray.v, ray.v);\n    float b = 2.0 * dot(ray.v, p0c);\n    float c = dot(p0c,p0c) - s.r*s.r;\n    \n    float discriminant = b*b - 4.0*a*c;\n\n    if(discriminant < 0.0)\n        return TraceResult(vec3(0),ray.tmax,s.materialId); // no intersection\n\n    float sqd = sqrt(discriminant);\n    float numerator = -b - sqd;\n\n    if(numerator < 0.0)\n        numerator = -b + sqd;\n\n    float t = 0.5 * numerator / a;\n    vec3 p = ray.p0 + t * ray.v;\n    vec3 normal = normalize(p - s.c);\n \n    return TraceResult(normal, t, s.materialId);\n}\n\nTraceResult intersect(Ray ray, Light l) {\n    vec3 p0c = ray.p0 - l.position;\n    \n    float a = dot(ray.v, ray.v);\n    float b = 2.0 * dot(ray.v, p0c);\n    float c = dot(p0c,p0c) - l.radius * l.radius;\n    \n    float discriminant = b*b - 4.0*a*c;\n\n    if(discriminant < 0.0)\n        return TraceResult(vec3(0), ray.tmax, l.materialId); // no intersection\n\n    float sqd = sqrt(discriminant);\n    float numerator = -b - sqd;\n\n    if(numerator < 0.0)\n        numerator = -b + sqd;\n\n    float t = 0.5 * numerator / a;\n    vec3 p = ray.p0 + t * ray.v;\n    vec3 normal = normalize(p - l.position);\n \n    return TraceResult(-normal, t, l.materialId);\n}\n\n\nTraceResult intersect(Ray ray, Plane plane) {\n    float t = dot(plane.q0-ray.p0,plane.n) / dot(ray.v,plane.n);\n\n    return TraceResult(plane.n,t,plane.materialId);\n}\n\nTraceResult raycast(Ray ray, bool shadow) {\n    TraceResult res = TraceResult(vec3(0), ray.tmax, 0);\n    \n    for(int i = 0; i < triangles.length(); ++i) {\n        TraceResult res2 = intersect(ray, triangles[i]);\n\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t)\n            res = res2;\n    }\n    \n    for(int i = 0; i < spheres.length(); ++i) {\n        TraceResult res2 = intersect(ray, spheres[i]);\n\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t)\n            res = res2;\n    }\n\n    for(int i = 0; i < planes.length(); ++i) {\n        TraceResult res2 = intersect(ray, planes[i]);\n\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t)\n            res = res2;\n    }\n    \n    if (!shadow) {\n        for(int i = 0; i < lights.length(); ++i) {\n            TraceResult res2 = intersect(ray, lights[i]);\n\n            if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t)\n                res = res2;\n        }\n    }\n\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Materials\n    materials[0] = Material(vec3(0.2),vec3(1.),vec3(0.),vec3(0.),100.); // Walls mat\n    materials[1] = Material(vec3(0.937,0.556,0.219),vec3(1.0),vec3(0.0),vec3(0.0),100.0); // Sun mat\n    materials[2] = Material(vec3(0.807,0.800,0.819),vec3(0.5),vec3(0.7),vec3(1.0),100.0); // Mercury mat\n    materials[3] = Material(vec3(0.933,0.796,0.545),vec3(1.0),vec3(0.0),vec3(0.0),100.0); // Venus mat\n    materials[4] = Material(vec3(0.423,0.811,1.000),vec3(1.0),vec3(0.0),vec3(0.0),100.0); // Earth mat\n    materials[5] = Material(vec3(0.886,0.482,0.345),vec3(1.0),vec3(0.0),vec3(0.0),100.0); // Mars mat\n    materials[6] = Material(vec3(0.866,0.737,0.650),vec3(1.0),vec3(0.0),vec3(0.0),100.0); // Jupiter mat\n    materials[7] = Material(vec3(0.886,0.749,0.490),vec3(1.0),vec3(0.3),vec3(0.0),0.000); // Saturn mat\n    materials[8] = Material(vec3(0.776,0.827,0.890),vec3(1.0),vec3(0.0),vec3(0.0),100.0); // Uranus mat\n    materials[9] = Material(vec3(0.243,0.400,0.976),vec3(3.0),vec3(0.0),vec3(0.0),100.0); // Neptune mat\n    \n    // Planes\n    planes[0] = Plane(vec3(0,-30,0), normalize(vec3(0,1,0)),0);\n    planes[1] = Plane(vec3(30,0,0), normalize(vec3(-1,0,0)),0);\n    planes[2] = Plane(vec3(0,0,30), normalize(vec3(0,0,-1)),0);\n    \n    // Lights\n    lights[0] = Light(vec3(0.,sin(iTime),0.),5.,1);\n    \n    // Planets\n    spheres[0] = Sphere(vec3(12.*sin(iTime*1.0),0,12.*cos(iTime*1.0)), 0.15, 2); // Mercury\n    spheres[1] = Sphere(vec3(14.*sin(iTime*0.9),0,14.*cos(iTime*0.9)), 0.3, 3); // Venus\n    spheres[2] = Sphere(vec3(16.*sin(iTime*0.8),0,16.*cos(iTime*0.8)), 0.25, 4); // Earth\n    spheres[3] = Sphere(vec3(18.*sin(iTime*0.7),0,18.*cos(iTime*0.7)), 0.18, 5); // Mars\n    spheres[4] = Sphere(vec3(20.*sin(iTime*0.6),0,20.*cos(iTime*0.6)), 0.9, 6); // Jupiter\n    spheres[5] = Sphere(vec3(22.*sin(iTime*0.5),2.*sin(iTime*0.05),22.*cos(iTime*0.5)), 0.8, 7); // Saturn\n    spheres[6] = Sphere(vec3(24.*sin(iTime*0.4),5.*sin(iTime*0.1),24.*cos(iTime*0.4)), 0.5, 8); // Uranus\n    spheres[7] = Sphere(vec3(26.*sin(iTime*0.3),10.*sin(iTime*0.2),26.*cos(iTime*0.3)), 0.5, 9); // Neptune\n    \n    // Triangles\n    triangles[0] = Triangle(vec3(5,-10,0), vec3(5,-10,5), vec3(0,-10,5),9);\n    \n    // Camera\n    vec3 eye; vec2 data;                           // this will be saved into first two pixels\n    Ray ray = Camera(fragCoord, eye, data);        // Generate ray from pixel\n    TraceResult result = raycast(ray, false);      // Raycast\n    \n    vec3 color = vec3(0);\n    if(ray.tmax <= result.t)\n        color = missColor(ray);    \n    else\n        color = hitColor(ray, result);\n    \n    fragColor = vec4(color,1.);\n    \n    // First two pixels are reserved\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5)    // pixel (0,0)\n        fragColor.yzw = eye-EyeStartPosition;\n\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5)     //pixel (1,0)\n        fragColor.zw = data;\n}\n","name":"Buffer A","description":"","type":"buffer"}]}