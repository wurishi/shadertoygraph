{"ver":"0.1","info":{"id":"fdV3Dw","date":"1631661351","viewed":404,"name":"Ray Tracing :: Accumulative","username":"ENDESGA","description":"chenglou's improved ray tracer had great qualities even with a single sample, so I made it accumulative!","likes":11,"published":3,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"7tBXDh","parentname":"Ray Tracing One Weekend Improved"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 O, in vec2 I )\n{\n    // Naive AA + sRGB Mapping + Contrast adjustments\n    vec3 C = (((texture( iChannel0, ((I + vec2(-1.,0.)))/iResolution.xy ).rgb +\n                texture( iChannel0, ((I + vec2(1.,0.)))/iResolution.xy ).rgb +\n                texture( iChannel0, ((I + vec2(0.,-1.)))/iResolution.xy ).rgb +\n                texture( iChannel0, ((I + vec2(0.,1.)))/iResolution.xy ).rgb +\n                texture( iChannel0, (I)/iResolution.xy ).rgb) * .2) +\n                texture( iChannel0, (I)/iResolution.xy ).rgb) * .5;\n    \n    O = vec4(clamp(C,vec3(0.),vec3(1.)), 1.0f); // clamp() isn't necessarily needed\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//https://raytracing.github.io/books/RayTracingInOneWeekend.html\n#define PI 3.14159265359\n#define T 6.9\n//(sqrt(abs(sin(iTime*PI)))*.02)\n#define DEPTH 8\n\nfloat hash12(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * vec3(.5671, .2235, .9346));\n    p3 += dot(p3, p3.yzx + 77.777);\n    return fract((p3.x + p3.y) * p3.z*7.777);\n}\nvec2 hash22(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.5671, .2235, .9346));\n    p3 += dot(p3, p3.yzx + 77.777);\n    return fract(((p3.xx+p3.yz)*p3.zy));\n\n}\nvec3 hash32(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.5671, .2235, .9346));\n    p3 += dot(p3, p3.yxz + 77.777);\n    return fract(((p3.xxy+p3.yzz)*p3.zyx));\n}\n\nvec3 random_in_unit_sphere(vec2 p) {\n    vec3 rand = hash32(p);\n    float phi = 2.0 * PI * rand.x;\n    float cosTheta = 2.0 * rand.y - 1.0;\n    float u = rand.z;\n\n    float theta = acos(cosTheta);\n    float r = pow(u, 1.0 / 3.0);\n\n    float x = r * sin(theta) * cos(phi);\n    float y = r * sin(theta) * sin(phi);\n    float z = r * cos(theta);\n\n    return vec3(x, y, z);\n}\n\nvec3 random_unit_vector(vec2 p) {\n    return normalize(random_in_unit_sphere(p));\n}\n\nvec3 random_in_unit_disk(vec2 p) {\n    return vec3(random_in_unit_sphere(p).xy, 0);\n}\n\nconst int material_lambertian = 0;\nconst int material_metal = 1;\nconst int material_dielectric = 2;\n\nstruct ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct material {\n    int type;\n    vec3 albedo;\n    float metal_fuzz;\n    float dielectric_index_of_refraction;\n};\n\nstruct hit_record {\n    vec3 p;\n    vec3 normal;\n    float t;\n    material material;\n};\n\nstruct sphere {\n    vec3 center;\n    float radius;\n    material material;\n};\n\n#define REF_ID 1.0777\n\nsphere s1 = sphere(vec3( 0.0, -1000., -1.0), 1000., material(material_metal, vec3(0.25), .1, REF_ID));\nsphere s2 = sphere(vec3(-4.0,    1.0, 2.),   1.0, material(material_dielectric, vec3(0), 0., REF_ID));\nsphere s3 = sphere(vec3( 0.0,    1.0, 0.),   1.0, material(material_lambertian, vec3(0.7, 0.6, 0.5), 0., REF_ID));\nsphere s4 = sphere(vec3( 4.0,    1.0, 2.),   1.0, material(material_dielectric, vec3(0.7, 0.3, 0.3), 0., REF_ID));\nsphere s5 = sphere(vec3(-6, 0.4, 2.8), 0.2, material(material_lambertian, vec3(0, 0, 0.2), 0., REF_ID));\nsphere s6 = sphere(vec3(1.6, 0.2, -0.9), 0.2, material(material_dielectric, vec3(0), 0., REF_ID));\nsphere s7 = sphere(vec3(-5.7, 0.2, -2.7), 0.2, material(material_lambertian, vec3(0.8, 0.3, 0.3), 0., REF_ID));\nsphere s8 = sphere(vec3(-3.6, 0.4, -4.4), 0.2, material(material_dielectric, vec3(0.9, 0.3, 0.2), 0., REF_ID));\nsphere s9 = sphere(vec3(0.8, 0.2, 2.3), 0.2, material(material_lambertian, vec3(0.2, 0, 0.5), 0., REF_ID));\nsphere s10 = sphere(vec3(3.8, 0.2, 4.2), 0.2, material(material_dielectric, vec3(0.4, 0.3, 0.7), 0., REF_ID));\nsphere s11 = sphere(vec3(-0.1, 0.2, -1.9), 0.2, material(material_lambertian, vec3(0.4, 0, 0.4), 0., REF_ID));\nsphere s12 = sphere(vec3(-2.5, 0.2, 5.4), 0.2, material(material_dielectric, vec3(0.3, 0.7, 0.9), 0.3, REF_ID));\nsphere s13 = sphere(vec3(-3.9, 0.2, -0.3), 0.2, material(material_lambertian, vec3(0.9, 0.8, 0.5), 0., REF_ID));\nsphere s14 = sphere(vec3(-6, 0.4, 4), 0.2, material(material_dielectric, vec3(0.9, 0.9, 0.5), 0., REF_ID));\nsphere s15 = sphere(vec3(4.4, 0.2, -0.5), 0.2, material(material_lambertian, vec3(0.5, 0.4, 0.8), 0., REF_ID));\nsphere s16 = sphere(vec3(3.4, 0.2, 5.3), 0.2, material(material_dielectric, vec3(0.1, 0.6, 0.2), 0., REF_ID));\nsphere s17 = sphere(vec3(4.6, 0.4, -3.8), 0.2, material(material_lambertian, vec3(0.2, 0.2, 0.2), 0., REF_ID));\nsphere s18 = sphere(vec3(0.7, 0.2, -2.5), 0.2, material(material_dielectric, vec3(0, 0.2, 0.1), 0., REF_ID));\nsphere s19 = sphere(vec3(2.4, 0.2, -4.3), 0.2, material(material_lambertian, vec3(0.8, 0.9, 0), 0., REF_ID));\nsphere s20 = sphere(vec3(4.4, 0.4, 4.9), 0.2, material(material_dielectric, vec3(0.8, 0.8, 0), 0., REF_ID));\nsphere s21 = sphere(vec3(-4.7, 0.2, 4.6), 0.2, material(material_lambertian, vec3(0.8, 0.8, 0.7), 0., REF_ID));\nsphere s22 = sphere(vec3(4.2, 0.2, -3.5), 0.2, material(material_dielectric, vec3(0.8, 0.8, 0.6), 0., REF_ID));\nsphere s23 = sphere(vec3(-5.2, 0.4, 0.5), 0.2, material(material_lambertian, vec3(0.2, 0.7, 0.9), 0., REF_ID));\nsphere s24 = sphere(vec3(5.7, 0.2, -0.8), 0.2, material(material_dielectric, vec3(0.3, 0, 0.7), 0., REF_ID));\n\nvoid hit_sphere(sphere sph, ray r, inout hit_record rec, inout bool hit_anything) {\n    float closest_so_far = rec.t;\n    vec3 oc = r.origin - sph.center;\n    float a = dot(r.dir, r.dir);\n    float half_b = dot(oc, r.dir);\n    float c = dot(oc, oc) - sph.radius * sph.radius;\n    float discriminant = half_b * half_b - a * c;\n    if (discriminant < 0.) {\n        return;\n    }\n\n    float sqrtd = sqrt(discriminant);\n\n    // Find the nearest root that lies in the acceptable range\n    float root = (-half_b - sqrtd) / a; // the t. from -b - sqrt(dis) / 2a\n    if (root < 0.001 || closest_so_far < root) {\n        root = (-half_b + sqrtd) / a;\n        if (root < 0.001 || closest_so_far < root) {\n            return;\n        }\n    }\n\n    hit_anything = true;\n    vec3 p = r.origin + r.dir * root;\n    rec = hit_record(p, (p - sph.center) / sph.radius, root, sph.material);\n}\n\nbool hit(ray r, out hit_record rec) {\n    bool hit = false;\n    // dummy. Set initial hit distance to max\n    rec = hit_record(vec3(0), vec3(0), 9999., material(material_lambertian, vec3(0), 0., 0.));\n\n    // unrolling this loop gave 4x perf boost...\n    hit_sphere(s1, r, rec, hit);\n    hit_sphere(s2, r, rec, hit);\n    hit_sphere(s3, r, rec, hit);\n    hit_sphere(s4, r, rec, hit);\n    hit_sphere(s5, r, rec, hit);\n    hit_sphere(s6, r, rec, hit);\n    hit_sphere(s7, r, rec, hit);\n    hit_sphere(s8, r, rec, hit);\n    hit_sphere(s9, r, rec, hit);\n    hit_sphere(s11, r, rec, hit);\n    hit_sphere(s12, r, rec, hit);\n    hit_sphere(s13, r, rec, hit);\n    hit_sphere(s14, r, rec, hit);\n    hit_sphere(s15, r, rec, hit);\n    hit_sphere(s16, r, rec, hit);\n    hit_sphere(s17, r, rec, hit);\n    hit_sphere(s18, r, rec, hit);\n    hit_sphere(s19, r, rec, hit);\n    hit_sphere(s21, r, rec, hit);\n    hit_sphere(s22, r, rec, hit);\n    hit_sphere(s23, r, rec, hit);\n    hit_sphere(s24, r, rec, hit);\n    return hit;\n}\n\nbool near_zero(vec3 p) {\n    float s = 1e-8;\n    return p.x < s && p.y < s && p.z < s;\n}\n\nfloat reflectance(float cosine, float ref_idx) {\n    // Use Schlick's approximation for reflectance\n    float r0 = (1. - ref_idx) / (1. + ref_idx);\n    r0 = r0 * r0;\n    return r0 + (1. - r0) * pow((1. - cosine), 5.);\n}\n\nvoid scatter(hit_record rec, ray r, vec2 seed, inout vec3 attenuation, inout ray scattered) {\n    material m = rec.material;\n\n    if (m.type == material_lambertian) {\n        vec3 scatter_direction = normalize(rec.normal + random_unit_vector(seed));\n\n        // catch degenerate scatter direction\n        if (near_zero(scatter_direction)) {\n            scatter_direction = rec.normal;\n        }\n\n        scattered = ray(rec.p, scatter_direction);\n        attenuation = m.albedo;\n    } else if (m.type == material_metal) {\n        vec3 reflected = reflect(r.dir, rec.normal);\n        ray scattered_ = ray(rec.p, normalize(reflected + m.metal_fuzz * random_in_unit_sphere(seed)));\n        if (dot(scattered_.dir, rec.normal) > 0.) {\n            scattered = scattered_;\n            attenuation = m.albedo;\n        }\n    } else if (m.type == material_dielectric) {\n        bool front_face = dot(r.dir, rec.normal) < 0.;\n        vec3 adjusted_normal = front_face ? rec.normal : -rec.normal;\n        float ref = m.dielectric_index_of_refraction;\n        float refraction_ratio = front_face ? 1.0/ref : ref;\n\n        float cos_theta = min(dot(-r.dir, adjusted_normal), 1.0);\n        float sin_theta = sqrt(1.0 - cos_theta * cos_theta);\n\n        bool cannot_refract = refraction_ratio * sin_theta > 1.0;\n        vec3 direction;\n\n        if (cannot_refract || reflectance(cos_theta, refraction_ratio) > hash12(seed)) {\n            direction = reflect(r.dir, adjusted_normal);\n        } else {\n            direction = refract(r.dir, adjusted_normal, refraction_ratio);\n        }\n\n        scattered = ray(rec.p, direction);\n        attenuation = vec3(1);\n    }\n}\n\nvec3 ray_color(in ray r, vec2 seed) {\n    vec3 color = vec3(1);\n    hit_record rec;\n    int depth;\n    for (depth = 0; depth < DEPTH; depth++) {\n        if (hit(r, rec)) {\n            ray scattered;\n            vec3 attenuation;\n            scatter(rec, r, seed * 999. + float(depth), attenuation, scattered);\n            r = scattered;\n            color *= attenuation;\n        } else break;\n    }\n\n    if (depth == DEPTH) {\n        return vec3(0);\n    }\n    return color;\n}\n\n\nvoid mainImage( out vec4 O, in vec2 I ) {\n    // camera\n    vec3 lookfrom = vec3(cos(T) * 8., 2.0, sin(T) * 8.);\n    vec3 lookat = vec3(0, 0, 0);\n    vec3 vup = vec3(0, 1, 0);\n    float vfov = 45.0;\n    float aspect_ratio = iResolution.x / iResolution.y;\n    float aperture = 0.1;\n    float focus_dist = 10.0;\n\n    float theta = radians(vfov);\n    float h = tan(theta / 2.);\n    float viewport_height = 2.0 * h;\n    float viewport_width = aspect_ratio * viewport_height;\n\n    vec3 w = normalize(lookfrom - lookat);\n    vec3 u = normalize(cross(vup, w));\n    vec3 v = cross(w, u);\n\n    vec3 origin = lookfrom;\n    vec3 horizontal = focus_dist * viewport_width * u;\n    vec3 vertical = focus_dist * viewport_height * v;\n    vec3 lower_left_corner = origin - horizontal / 2. - vertical / 2. - focus_dist * w;\n\n    float lens_radius = aperture / 2.;\n\n    // render\n    vec3 C = vec3(0);\n    \n    // REMOVED THE LOOP\n    vec2 rand = hash22(I * 999. + float(iFrame)*7.777);\n\n    vec2 normalizedCoord = (I + rand) / iResolution.xy;\n    vec3 rd = lens_radius * random_in_unit_disk(normalizedCoord * 999. + T);\n    vec3 offset = u * rd.x + v * rd.y;\n    ray r = ray(\n        origin + offset,\n        normalize(lower_left_corner + normalizedCoord.x * horizontal + normalizedCoord.y * vertical - origin - offset)\n    );\n    C += ray_color(r, normalizedCoord);\n    \n    // tone mapping (brings out the colour in the shadows!)\n    C = mix(12.92 * C, 1.055 * pow(C, vec3(1.0 / 2.4)) - 0.055, step(vec3(0.0031308), C));\n\n    O = vec4(mix(texture(iChannel0, I / iResolution.xy).rgb, clamp(C,vec3(0.),vec3(1.)), 1./float(iFrame + 1)), 1.0);\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}