{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"cubemap","id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"/*\nHOWTO Get Started With Ray Marching\nby Michael Pohoreski aka MysticReddit\nVersion 0.51, July 2017\n\n= Introduction =\n\nAre you wondering how some of those awesome ShaderToy demos are created?\nWant to learn about ray marching but have NO idea how to start?\n\nThis is a mini-tutorial on how to get started with ray marching\nin the spirit of the famous \"NeHe OpenGL Tutorials\".\nI dub it the PoHo of Ray Marching. :-)\n\nFor now we're not going to write a ray marching renderer; instead we'll\nsimply play around with an existing one to get familiar the techniques\nof constructive solid geometry and distance functions to see how they work.\n\n= Steps =\n\n1. First, you'll want to read this introduction:\n   Don't worry if it seems complicated and you don't understand everything.\n   This is just to get familiar with some concepts.\n\n       https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf\n\n2. Next, try out the provided examples!\n   I've provided some \"lessons\" where you can try out small demos.\n\n   Change the # to the lesson you want. (See Table of Contents below)\n   Then hit the |> triangle button below the code but above the 'iChannel0' picture.\n*/\n\n#define LESSON 1\n\n/*\n= Lesson Table of Contents =\n\n    Lesson  0 --- see \"Creative time!\" note below ---\n\n    // Primitives\nok  Lesson  1 Primitive: Sphere\nok  Lesson  2 Primitive: Two Spheres\nok  Lesson  3 Primitive: Three Spheres\nok  Lesson  4 Primitive: (Signed) Box\nok  Lesson  5 Primitive: (Unsigned) Round Box\nok  Lesson  6 Primitive: Torus\nok  Lesson  7 Primitive: Cone\nfix Lesson  8 Primitive: Plane\nok  Lesson  9 Primitive: Pyramid\nok  Lesson 10 Primitive: Cylinder\nok  Lesson 11 Primitive: Capsule\nok  Lesson 12 Composite: Capsule (sin + Box)\n\n    // Constructive Solid Geometry FTW!\nok  Lesson 13 Distance:  Operation: Union (Box + Sphere)\nok  Lesson 14 Distance:  Operation: Subtraction (Box - Sphere)\nok  Lesson 15 Distance:  Operation: Intersection\n\n    // Scale, Rotate, Translate: p' = S*R*T*p\nok  Lesson 16 Domain:    Operation: Translation (Box)\nok  Lesson 17 Domain:    Operation: Rotation (Box)\nok  Lesson 18 Domain:    Operation: Scale\nok  Lesson 19 Domain:    Operation: Matrix: Translation\nok  Lesson 20 Domain:    Operation: Matrix: Translation & Rotation (box)\n\nok  Lesson 21 Domain:    Operation: Repetition (Spere)\nok  Lesson 22 Domain:    Operation: Repetition (Box -> Cube)\n\n    // Deformations\nok  Lesson 23 Domain:    Deformation: (Cheap) Bend X (Box)\nok  Lesson 24 Domain:    Deformation: (Cheap) Bend Y (Box)\nok  Lesson 25 Domain:    Deformation: (Cheap) Bend Z (Box)\n\nfix Lesson 26 Domain:    Deformation: Twist X (Box)\nfix Lesson 27 Domain:    Deformation: Twist Y (Box)\nfix Lesson 28 Domain:    Deformation: Twist Z (Box)\n\nok  Lesson 29 Distance:  Deformation: Displacement (Torus)\nok  Lesson 30 Distance:  Deformation: Blend (Box + Torus)\n\nok  Lesson 101 Empty Glass\nok  Lesson 102 Crystal Skull\n\nNOTE: Not all the lessons work (yet)!\n\n    Legend:\n        ok   means it has been verified working.\n        fix  means it is partially working but needs debugging\n        BAD  means it is completely broken\n\n\n= HOW TO (cont.) =\n\n3. Distance Functions\n\n   As you go through the examples you'll want to become familiar with these distance functions:\n\n       https://iquilezles.org/articles/distfunctions\n\n4. View iq's \"Reference\" implementation\n\n    \"Raymarching - Primitives\n    https://www.shadertoy.com/view/Xds3zN\n\n\n5. Creative time!\n\n   a) Change the lesson to zero via:\n      #define LESSON 0\n\n   b) Modify the draw() function\n      Create your masterpiece code in the section labeled 'CREATE ME!\n\nRemember:\n\n *Everyone* was a \"noob\" at one point!\n *None* of us was born knowing this stuff!\n\nHave fun!\n\n\nMaster Refence:\n\n    http://d.hatena.ne.jp/hanecci/20131005/p1\n\nMore references:\n\n    Raymarching - Primitives\n    https://www.shadertoy.com/view/Xds3zN\n\n    http://blog.ruslans.com/2015/01/raymarching-christmas-tree.html\n    https://www.shadertoy.com/view/XlXGRM\n\n    http://www.hugi.scene.org/online/hugi37/hugi%2037%20-%20coding%20adok%20on%20ray%20casting,%20ray%20tracing,%20ray%20marching%20and%20the%20like.htm\n\n    http://www.pouet.net/topic.php?which=7931&page=1\n\n    A \"simple\" ray marcher\n    Menger Sponge\n    https://www.shadertoy.com/view/4sX3Rn\n    https://iquilezles.org/articles/menger]\n\nNote: This code was shamelessly copied and cleaned up from the excellent demo:\n\n    \"Crystal Skull\"\n    https://www.shadertoy.com/view/MsS3WV\n\nOnce you start feeling comfortable you can distill shaders down to their bare essence.\n\n    \"Empty Glass\"\n    https://www.shadertoy.com/view/4s2GDV\n\nAs an homage I've provided them here as lessons. :-)\n\nSpecial Thanks:\n\n* Inigo Quilez - for ShaderToy and for sharing his rendering knowledge!\n\n    Can you _please_ fix the typos in distfunctions.htm ? :-)\n    If you need a technical editor I'd be more then happy to be one. :-)\n\n* Everyone who posted their cool shaders!\n\n  * \"Chocolux\"\n  * \"Road to Ribbon\"\n\n\"If I have seen further it is by standing on the shoulders of giants.\" -- Isaac Newton\n\nHistory:\n\n    0.51 Fixed VIEW_ISOMETRIC to be independent of VIEW_ZERO\n    0.50 Added Median 333 (July 2017)\n    0.49 Fix uncomment for AUTO_ROTATE\n    0.48 cleanup grammar\n    0.47 rename transpose to transposeM4() for matrix shenanigans \n    0.46 Uncomment transpose() for WebGL 2.0 Shadertoy upgrade\n    0.45 Clarified compile button\n    0.44 Provided instruction on HOW TO test the next lesson\n    0.43 Provide second material\n    0.42 Cleanup introduction\n    0.41 Rot4Y\n    0.40 cleanup\n    0.38 fixed Lesson 30\n    0.37 fixed Lesson 29\n*/\n\n#define AUTO_ROTATE     // uncomment to stop auto camera rotation\n//#define BACKGROUND_BLUE // uncomment for blue background, else cubemap background\n//#define VIEW_ZERO       // uncomment to default OpenGL look down z-axis view\n//#define VIEW_ISOMETRIC  // Nice isometric camera angle\n\n//#define LOW_Q // uncomment for low quality if your GPU is a potato\n\n#ifdef LOW_Q\n    #define MARCHSTEPS 25\n#else\n    #define MARCHSTEPS 50\n    #define AMBIENT_OCCLUSION\n    #define DOUBLE_SIDED_TRANSPARENCY\n#endif\n\n#define MAX_DIST 10.0\n\n#define SPECULAR\n#define REFLECTIONS\n#define TRANSPARENCY\n#define SHADOWS\n#define FOG\n\n//TODO: FIXME: Do Displacement and Blend need flat shading?\n#if LESSON == 26 || LESSON == 27\n    #undef AMBIENT_OCCLUSION\n    #undef DOUBLE_SIDED_TRANSPARENCY\n    #undef TRANSPARENCY\n#endif\n\n#define DIRECTIONAL_LIGHT\n#define DIRECTIONAL_LIGHT_FLARE\n\n#define PI 3.141592654\n\n#define kNt  -1.0 //no trans\n#define kTt   1.0 //yes trans\n#define kIt   0.0 //inverse trans\n\nconst float MATERIAL_1 = 1.0;\nconst float MATERIAL_2 = 2.0;\n/* */ float gMaterial  = MATERIAL_1;\n\n// TODO: Document these structure member fields!\n// rd Ray Direction\n// rl Ray Length\nstruct sRay   { vec3 ro ; vec3  rd ; float sd; float rl; };\nstruct sHit   { vec3 hp ; float hd ; vec3 oid; };\nstruct sSurf  { vec3 nor; vec3  ref; vec3 tra; };\nstruct sMat   { vec3 ctc; float frs; float smt; vec2 par; float trs; float fri; };\nstruct sShade { vec3 dfs; vec3  spc; };\nstruct sLight { vec3 rd ; vec3  col; };\n\n// __ Matrix functions __ _____________________________________\n\n    // Return 2x2 rotation matrix\n    // With vector swizzle/mask can use as a 3x3 xform\n    // For y, you need to invert \n    // angle in radians\n    // ========================================\n    mat2 Rot2(float a ) {\n        float c = cos( a );\n        float s = sin( a );\n        return mat2( c, -s, s, c );\n    }\n\n    // http://www.songho.ca/opengl/gl_anglestoaxes.html\n\n    // Return 4x4 rotation X matrix\n    // angle in radians\n    // ========================================\n    mat4 Rot4X(float a ) {\n        float c = cos( a );\n        float s = sin( a );\n        return mat4( 1, 0, 0, 0,\n                     0, c,-s, 0,\n                     0, s, c, 0,\n                     0, 0, 0, 1 );\n    }\n\n    // Return 4x4 rotation Y matrix\n    // angle in radians\n    // ========================================\n    mat4 Rot4Y(float a ) {\n        float c = cos( a );\n        float s = sin( a );\n        return mat4( c, 0, s, 0,\n                     0, 1, 0, 0,\n                    -s, 0, c, 0,\n                     0, 0, 0, 1 );\n    }\n\n    // Return 4x4 rotation Z matrix\n    // angle in radians\n    // ========================================\n    mat4 Rot4Z(float a ) {\n        float c = cos( a );\n        float s = sin( a );\n        return mat4(\n            c,-s, 0, 0,\n            s, c, 0, 0,\n            0, 0, 1, 0,\n            0, 0, 0, 1\n         );\n    }\n\n    // Translate is simply: p - d\n    // opTx will do transpose(m)\n    // p' = m*p\n    //    = [m0 m1 m2 m3 ][ p.x ]\n    //      [m4 m5 m6 m7 ][ p.y ]\n    //      [m8 m9 mA mB ][ p.z ]\n    //      [mC mD mE mF ][ 1.0 ]\n    // ========================================\n    mat4 Loc4( vec3 p ) {\n        p *= -1.;\n        return mat4(\n            1,  0,  0,  p.x,\n            0,  1,  0,  p.y,\n            0,  0,  1,  p.z,\n            0,  0,  0,  1\n        );\n    }\n\n\n    // if no support for GLSL 1.2+\n    //     #version 120\n    // ========================================\n    mat4 transposeM4(in mat4 m ) {\n        vec4 r0 = m[0];\n        vec4 r1 = m[1];\n        vec4 r2 = m[2];\n        vec4 r3 = m[3];\n\n        mat4 t = mat4(\n             vec4( r0.x, r1.x, r2.x, r3.x ),\n             vec4( r0.y, r1.y, r2.y, r3.y ),\n             vec4( r0.z, r1.z, r2.z, r3.z ),\n             vec4( r0.w, r1.w, r2.w, r3.w )\n        );\n        return t;\n    }\n\n\n// __ Smoothing functions _____________________________________\n\n    // Smooth Min\n    // https://iquilezles.org/articles/smin\n\n    // Min Polynomial\n    // ========================================\n    float sMinP( float a, float b, float k ) {\n        float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n        return mix( b, a, h ) - k*h*(1.0-h);\n    }\n\n    // Min Exponential\n    // ========================================\n    float sMinE( float a, float b, float k) {\n        float res = exp( -k*a ) + exp( -k*b );\n        return -log( res )/k;\n    }\n\n    // Min Power\n    // ========================================\n    float sMin( float a, float b, float k ) {\n        a = pow( a, k );\n        b = pow( b, k );\n        return pow( (a*b) / (a+b), 1.0/k );\n    }\n\n// __ Surface Primitives ____________________________\n\n    // Return max component x, y, or z\n    // ========================================\n    float maxcomp(in vec3 p ) {\n        return max(p.x,max(p.y,p.z));\n    }\n\n// Signed\n\n    // b.x = Width\n    // b.y = Height\n    // b.z = Depth\n    // Leave r=0 if radius not needed\n    // ========================================\n    float sdBox(vec3 p, vec3 b, float r) {\n        vec3 d = abs(p) - b;\n        return min(maxcomp(d),0.0) - r + length(max(d,0.0));\n        // Inlined maxcomp\n        //return min(max(d.x,max(d.y,d.z)),0.0) - r + length(max(d,0.0));\n    }\n\n    // ========================================\n    float sdCappedCylinder( vec3 p, vec2 h ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n\n    // ========================================\n    float sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n        vec3 pa = p - a, ba = b - a;\n        float h = clamp( dot(pa,ba) / dot(ba,ba), 0.0, 1.0 );\n        return length( pa - ba*h ) - r;\n    }\n\n    // c.x Width\n    // c.y Base Radius\n    // c.z Depth\n    // Note: c must be normalized\n    // ========================================\n    float sdCone( vec3 p, vec3 c) // TODO: do we need to use 'in' for all primitives?\n    {\n        // c.x = length\n        // c.y = base radius\n        //float q = length( p.xy );\n        //return dot( c, vec2( q, p.z ) ); // BUG in iq's docs -- laying on side\n\n        float q = length( p.xz );\n        return dot( c.xy, vec2( q, p.y ) );\n\n        // Alt. cone formula given in: ???\n        //vec2 q = vec2( length( p.xz ), p.y );\n        //float d1 = -p.y - c.z;\n        //float d2 = max( dot(q,c.xy), p.y );\n        //return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.0);\n    }\n\n    // ========================================\n    float sdCylinder( vec3 p, vec3 c ) {\n        return length(p.xz - c.xy) - c.z;\n    }\n\n    // n.xyz = point on plane\n    // n.w   = distance to plane\n    // Note: N must be normalized!\n    // ========================================\n    float sdPlane( vec3 p, vec4 n ) {\n        return dot( p, n.xyz ) + n.w;\n    }\n\n    // 4 sided pyramid\n    // h.x = base X\n    // h.y = height\n    // h.z = base Z (usually same as h.x)\n    // ========================================\n    float sdPyramid4( vec3 p, vec3 h ) {\n        p.xz = abs(p.xz);                   // Symmetrical about XY and ZY\n        vec3 n = normalize(h);\n        return sdPlane(p, vec4( n, 0.0 ) ); // cut off bottom\n    }\n\n    // ========================================\n    float sdSphere( vec3 p, float r ) {\n        return length(p) - r;\n    }\n\n    // ========================================\n    float sdSphere2( vec3 p, float r ) {\n        return abs(length(p) - r);\n    }\n\n    // ========================================\n    float sdTorus( vec3 p, vec2 t ) {\n        vec2 q = vec2(length(p.xy) - t.x, p.z);\n        return length(q) - t.y;\n    }\n\n    // TODO: document/derive magic number 0.866025\n    // ========================================\n    float sdTriPrism( vec3 p, vec2 h ) {\n        vec3 q = abs(p);\n        return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n    }\n\n// Unsigned\n\n    // Box\n    // ========================================\n    float udBox( vec3 p, vec3 b ) {\n        return length( max( abs(p) - b, 0.0 ) );\n    }\n\n    // Round Box\n    // ========================================\n    float udRoundBox(vec3 p, vec3 b, float r)\n    {\n        return length(max(abs(p) - b, 0.0))- r;\n    }\n\n// __ Distance Operations _____________________________________\n\n// Basic\n    // Op Union\n    // ========================================\n    float opU( float d1, float d2 ) {\n        return min( d1, d2 );\n    }\n\n    // Op Union\n    // ========================================\n    vec4 opU2( vec4 d1, vec4 d2 ) {\n        return min( d1, d2 );\n    }\n\n    // Op Union\n    // ========================================\n    vec4 opU( vec4 a, vec4 b ) {\n        return mix(a, b, step(b.x, a.x));\n    }\n\n    // Op Subtraction\n    // ========================================\n    float opS( float a, float b ) {\n        return max( -b, a ); // BUG in iq's docs: -a, b\n    }\n    // Op Subtraction\n    // ========================================\n    vec4 opS( vec4 a, vec4 b ) {\n        return max( -b, a );\n    }\n\n    // Op Intersection\n    // ========================================\n    float opI( float a, float b ) {\n        return max( a, b );\n    }\n\n    // Op Intersection\n    // ========================================\n    vec4 opI( vec4 a, vec4 b ) {\n        return max( a, b );\n    }\n\n// Advanced\n    // ========================================\n    float opBlend( float a, float b, float k ) {\n        return sMin( a, b, k );\n    }\n\n    // a angle\n    // ========================================\n    float displacement( vec3 p, float a ) {\n        return sin(a*p.x)*sin(a*p.y)*sin(a*p.z); // NOTE: Replace with your own!\n    }\n\n    // ========================================\n    float opDisplace( vec3 p, float d1, float d2 ) {\n        return d1 + d2;\n    }\n\n    // Op Union Translated\n    // ========================================\n    vec4 opUt( vec4 a, vec4 b, float fts ){\n        vec4 vScaled = vec4(b.x * (fts * 2.0 - 1.0), b.yzw);\n        return mix(a, vScaled, step(vScaled.x, a.x) * step(0.0, fts));\n    }\n\n\n// __ Domain Operations _______________________________________\n\n// NOTE: iq originally inlined the primitive inside the Domain operations. :-(\n// This implied that you would have needed to provide \n// a primitive with one of the sd*() functions above\n// since we can't have a generic pointer to a function!\n// However we have moved them back out to the caller\n// for clarity and flexibility without general loss of precision.\n\n// Basic\n\n    // Op Repetition\n    // ========================================\n    vec3 opRep( vec3 p, vec3 spacing ) {\n        return mod(p,spacing) - 0.5*spacing;\n    }\n\n// Deformations\n\n    // Op Twist X\n    // ========================================\n    vec3 opTwistX( vec3 p, float angle ) {\n        mat2 m = Rot2( angle * p.x );\n        return   vec3( m*p.yz, p.x );\n    }\n\n    // Op Twist Y\n    // ========================================\n    vec3 opTwistY( vec3 p, float angle ) {\n#if 0 // original\n        float c = cos( angle * p.y );\n        float s = sin( angle * p.y );\n        mat2  m = mat2( c, -s, s, c );\n        vec3  q = vec3( m*p.xz, p.y );\n        // return primitive(q); // BUG in iq's docs, should be: return q\n        return q;\n#else // cleaned up\n        mat2 m = Rot2( angle * p.y );\n        return   vec3( m*p.xz, p.y );\n#endif\n    }\n\n    // Op Twist Z\n    // ========================================\n    vec3 opTwistZ( vec3 p, float angle ) {\n        mat2 m = Rot2( angle * p.z );\n        return   vec3( m*p.xy, p.z );\n    }\n\n    // iq's bend X\n    // ========================================\n    vec3 opCheapBend( vec3 p, float angle ) {\n#if 0 // original // broken :-(\n        float c = cos( angle * p.y );\n        float s = sin( angle * p.y );\n        mat2  m = mat2( c, -s, s, c );\n        vec3  q = vec3( m*p.xy, p.z ); // BUG in iq's docs, should be: p.yx\n#else\n        mat2  m = Rot2( angle * p.y );\n        vec3  q = vec3( m*p.yx, p.z );\n#endif\n        return q;\n    }\n\n    // Op Cheap Bend X\n    // ========================================\n    vec3 opBendX( vec3 p, float angle ) {\n        mat2 m = Rot2( angle * p.y );\n        return   vec3( m*p.yx, p.z );\n    }\n\n    // Op Cheap Bend Y\n    // ========================================\n    vec3 opBendY( vec3 p, float angle ) {\n        mat2 m = Rot2( angle * p.z );\n        return   vec3( m*p.zy, p.x );\n    }\n\n    // Op Cheap Bend Z\n    // ========================================\n    vec3 opBendZ( vec3 p, float angle ) {\n        mat2 m = Rot2( angle * p.x );\n        return   vec3( m*p.xz, p.y );\n    }\n\n    // d = distance to move\n    // ========================================\n    vec3 opTrans( vec3 p, vec3 d ) {\n        return p - d;\n    }\n\n    // Note: m must already be inverted!\n    // TODO: invert(m) transpose(m)\n    // Op Rotation / Translation\n    // ========================================\n    vec3 opTx( vec3 p, mat4 m ) {   // BUG in iq's docs, should be q\n        return (transposeM4(m)*vec4(p,1.0)).xyz;\n    }\n\n    // Op Scale\n    // ========================================\n    float opScale( vec3 p, float s ) {\n        return sdBox( p/s, vec3(1.2,0.2,1.0), 0.01 ) * s; // TODO: FIXME: NOTE: replace with primative sd*()\n    }\n\n// The fun starts here!\n// ========================================\nfloat draw( vec3 p )\n{\n    vec3  q = p  ; // save original point\n    float d = 0.0; // distance function; default to no intersection\n\n#define BOX_W  1.50\n#define BOX_H  0.25\n#define BOX_D  0.75\n#define RADIUS 0.666\n\n#if LESSON == 1 // Primitive: Sphere\n    p = q;\n    d = sdSphere( p, 0.5 ); // position, radius\n#endif\n\n\n#if LESSON == 2 // Primitive: Two Spheres\n    float r;\n\n    p = q;\n    r = 0.5;\n    p.x -= r;\n    float o1 = sdSphere( p, r );\n\n    p = q;\n    r = 0.25;\n    p.x += r;\n    float o2 = sdSphere( p, r );\n    d = opU( o1, o2 );\n#endif\n\n\n#if LESSON == 3 // Primitive: Three Spheres\n    p = q;\n    d = MAX_DIST;\n    for( int i = 0; i < 3; i++ )\n    {\n       // [ radius         ] // i\n       // [ 1     2    3   ] // i+1\n       // [ 0.25, 0.5, 1.5 ] // (i+1)/4\n       float r = 0.25*(float(i) + 1.0);\n       float a = sdSphere( p, r );\n       d = opU( d, a );\n       p.x -= 3.0*r;\n    }\n#endif\n\n\n#if LESSON == 4 // Primitive: (Signed) Box\n    // X = Width\n    // Y = Height\n    // Z = Depth\n    d = sdBox( p, vec3(BOX_W,BOX_H,BOX_D), 0.0 ); // 0.0 = edge radius\n#endif\n\n#if LESSON == 5 // Primitive: (Unsigned) Round Box\n    d = udRoundBox(p, vec3(BOX_W,BOX_H,BOX_D),0.1);\n#endif\n\n\n#if LESSON == 6 // Primitive: Torus\n    d = sdTorus(p, vec2(BOX_D,BOX_H) ); // outer radius, inner radius\n#endif\n\n\n#if LESSON == 7 // Primitive: Cone\n    d = sdCone( p, normalize(vec3( 1.0, 1.0, 2.0) ) );\n#endif\n\n\n#if LESSON == 8 // Primitive: Plane\n    d = sdPlane( p, vec4( 0, 1, 0, 0 ) );\n    gMaterial = MATERIAL_2;\n#endif\n\n#if LESSON == 9 // Primitive: Pyramid\n    d = sdPyramid4( p, vec3( BOX_W, BOX_H, BOX_W ) );\n#endif\n\n\n#if LESSON == 10 // Primitive: Cylinder\n    d = sdCappedCylinder( p, vec2( BOX_H, BOX_D ) ); // radius, height\n#endif\n\n\n#if LESSON == 11 // Primitive: Capsule\n    d = sdCapsule( p,\n        vec3(0.0 ,0.68,-0.7),\n        vec3(0.02,0.07, 0.8),\n        0.27\n    );\n#endif\n\n\n#if LESSON == 12 // Composite: Capsule (sin + Box)\n    p = q;\n    //p.y += sin(p.y*PI/2.0)*0.25; // original *1.7)*0.3\n    d = sdBox(\n        vec3(0.0 ,0.68,-0.7) + p,\n        vec3(0.02,0.07, 0.8),\n        0.27\n    );\n#endif\n\n\n#if LESSON == 13 // Distance:  Operation: Union (Box + Sphere)\n    float d1 = sdBox( p, vec3(BOX_W,BOX_H,BOX_D), 0.0 );\n    float d2 = sdSphere( p, RADIUS );\n    d = opU( d1, d2 );\n#endif\n\n\n#if LESSON == 14 // Distance:  Operation: Subtraction (Box - Sphere)\n    float d1 = sdBox( p, vec3(BOX_W,BOX_H,BOX_D), 0.0 );\n    float d2 = sdSphere( p, RADIUS );\n    d = opS( d1, d2 );\n#endif\n\n\n#if LESSON == 15 // Distance:  Operation: Intersection\n    float d2 = sdBox( p, vec3(BOX_W,BOX_H,BOX_D), 0.0 );\n    float d1 = sdSphere( p, RADIUS );\n    d = opI( d1, d2 );\n#endif\n\n\n#if LESSON == 16 // Domain:    Operation: Translation (Box)\n    vec3 t = vec3( BOX_W, BOX_D, -BOX_W*2. );\n    q = opTrans( p, t ); // Loc4( t ) );\n    d = sdBox( q, vec3(BOX_W,BOX_H,BOX_D), 0.01 );\n#endif\n\n#if LESSON == 17 // Domain:    Operation: Rotation (Box)\n    // http://upload.wikimedia.org/wikipedia/commons/thumb/e/ed/30_degree_rotations_expressed_in_radian_measure.svg/400px-30_degree_rotations_expressed_in_radian_measure.svg.png\n    // http://etc.usf.edu/clipart/43200/43216/unit-circle8_43216_lg.gif\n    float angle = PI/4.0; // 45 degrees\n    q = opTx( p, Rot4X( angle ) );\n    d = sdBox( q, vec3(BOX_W,BOX_H,BOX_D), 0.01 );\n#endif\n\n\n#if LESSON == 18 // Domain:    Operation: Scale (Box)\n    d = opScale( p, 1.0/4.0 );\n#endif\n\n\n#if LESSON == 19 // Domain:    Operation: Translation & Rotation (Box)\n    vec3  t     = vec3( BOX_W, BOX_D, -BOX_W*2. );\n    float angle = PI/8.0;\n    q = opTx( p, Loc4( t ) );\n    d = sdBox( q, vec3(BOX_W,BOX_H,BOX_D), 0.01 );\n#endif\n\n\n#if LESSON == 20 // Domain:    Operation: Translation & Rotation (Box)\n    vec3  t     = vec3( BOX_W, BOX_D, -BOX_W*2. );\n    float angle = PI/8.0;\n    q = opTx( p, Rot4Z( angle ) * Loc4( t ) );\n    d = sdBox( q, vec3(BOX_W,BOX_H,BOX_D), 0.01 );\n#endif\n\n\n#if LESSON == 21 // Domain:    Operation: Repetition (Box -> Cube)\n    q = opRep( p, vec3(1.0) );\n    d = sdSphere( q, BOX_H );\n#endif\n\n\n#if LESSON == 22 // Domain:    Operation: Repetition (Box -> Cube)\n    q = opRep( p, vec3(1.0) );\n    d = sdBox( q, vec3(BOX_H), 0.01 );\n#endif\n\n\n#if LESSON == 23 // Domain:    Deformation: (Cheap) Bend X\n    q = opBendX( p, PI/4.0 );\n    d = sdBox( q, vec3(BOX_W,BOX_H,BOX_D), 0.0 );\n#endif\n\n\n#if LESSON == 24 // Domain:    Deformation: (Cheap) Bend Y\n    q = opBendY( p, PI/4.0 );\n    d = sdBox( q, vec3(BOX_W,BOX_H,BOX_D), 0.0 );\n#endif\n\n\n#if LESSON == 25 // Domain:    Deformation: (Cheap) Bend Z\n    q = opBendZ( p, PI/4.0 );\n    d = sdBox( q, vec3(BOX_W,BOX_H,BOX_D), 0.0 );\n#endif\n\n\n#if LESSON == 26 // Domain:    Deformation: Twist X (Box)\n    q = opTwistX( p, 4.0 );\n    d = sdBox( q, vec3(BOX_W,BOX_H,BOX_D), 0.0 );\n    gMaterial = MATERIAL_2;\n#endif\n\n\n#if LESSON == 27 // Domain:    Deformation: Twist Y (Torus)\n    q = opTwistY( p, 5.0 );\n    d = sdBox( q, vec3(BOX_W,BOX_H,BOX_D), 0.0 );\n  //d = sdTorus(q,vec2(BOX_D,BOX_H)); // TODO: FIXME:\n    gMaterial = MATERIAL_2;\n#endif\n\n\n#if LESSON == 28 // Domain:    Deformation: Twist Z (Box)\n    q = opTwistZ( p, 4.0 );\n    d = sdBox( q, vec3(BOX_W,BOX_H,BOX_D), 0.0 );\n    gMaterial = MATERIAL_2;\n#endif\n\n\n#if LESSON == 29 // Distance:  Deformation: Displacement (Torus)\n    float d1 = sdTorus(p, vec2(BOX_D,BOX_H) );\n    float d2 = displacement(p, 1.25 ); // k = 1.25\n    d = opDisplace( p, d1, d2 );\n#endif\n\n\n#if LESSON == 30 // Distance:  Deformation: Blend (Box + Torus)\n    float d1 = sdBox( p, vec3(BOX_D,BOX_H,BOX_W), 0.0 ); // 0.0 = edge radius\n    float d2 = sdTorus( p, vec2(BOX_D,BOX_H) );\n    d = opBlend( d1, d2, 0.4 ); // d1^k d2^k, k = 0.4\n#endif\n\n/*\n#if LESSON == 31 // Domain:    Deformation: Cheap Bend Z\n    q = opCheapBend( p, PI/4.0 );\n    d = sdBox( q, vec3(BOX_W,BOX_H,BOX_D), 0.0 );\n#endif\n*/\n\n#if LESSON == 0\n    // - - - 8< - - -\n    d = return 0; // Masterpiece creative time!\n    // - - - 8< - - -\n#endif\n\n\n#if LESSON == 101 // Empty Glass\n    // https://www.shadertoy.com/view/4s2GDV\n    // df_obj()\n    // Slightly cleaned up\n    // p *= 1.25; // Sadly we can't scale down as we run into precision issues...\n\n    float a  = (length(p.xz)-1.0-p.y*.15)*.85,\n          a2 = (length(p.xz)-0.9-p.y*.15)*.85;\n          a  = max(abs(p.y)-1.0,a);\n          a  = max(a,-max(-.8-p.y,a2));\n          a  = max(a,-length(p+vec3(.0,4.0,.0))+3.09);\n    //a = a; // WTF?\n\n    vec3 p2 = p;\n    p2.xz*=(1.0-p.y*.15);\n    float angle = atan(p2.x,p2.z);\n    float mag = length(p2.xz);\n    angle = mod(angle,PI*.125)-PI*.125*.5;\n    p2.xz = vec2(cos(angle),sin(angle))*mag;\n    a     = max(a,(-length(p2+vec3(-7.0,0.0,0.0))+6.05)*.85);\n\n    d = a;\n#endif\n\n\n#if LESSON == 102 // Crystal Skull\n    // https://www.shadertoy.com/view/MsS3WV\n    // skull()\n    // replaced 'float d = ...' with 'd = ...'\n    p.y += sin(p.y*1.6)*0.2;\n    p.z -= p.x*0.05;\n    float e = sdTorus(p+vec3(-0.4,0.0,0.0),vec2(0.3,0.1));   //eye\n\n    p.z = q.z;\n    p.z+=p.x*0.05;\n    float f = sdTorus(p+vec3( 0.4,0.0,0.0),vec2(0.3,0.1));   //eye\n    p.x+=sin(p.x);\n    float n = sdTorus(p+vec3( 0.0,0.45,0.19),vec2(0.2,0.05));  //nose\n\n    p = q;\n    p.x+=sin(p.x*0.07);\n    p.x*= cos(p.y*0.6+abs(cos(3.7+p.y)*0.2)*1.1) ;\n    float s = length(p+vec3( 0.0,-0.14,-0.79))-0.98; //back\n\n    p = q;\n    p.y += sin(p.y*1.7)*0.3;\n    d = length(p+vec3(-0.4,0.0,0.1))-0.25; //eyehole\n        s = max(s,-d);\n            d = length(p+vec3( 0.4,0.0,0.1))-0.25;  //eyehole\n        s = max(s,-d);\n\n    p = q;\n    p.z += p.z-p.y*0.4;\n    float v = sdBox(p+vec3(0.0,0.68,-0.7),vec3(0.02,0.07,0.8), 0.27);   //chin\n    float o = sMinP(e,f,0.5);\n    o = sMinE(o,n,14.0);\n    o = sMinP(o,s,0.09);\n    d = sMinE(o,v,12.0);\n#endif\n\n#if LESSON == 333 // Median\n    float d1 = sdBox( p, vec3(BOX_W,BOX_H,BOX_D), 0.0 );\n    float d2 = sdSphere( p, RADIUS );\n    p.y -= 2.0;\n    float d3 = sdPyramid4( p, vec3( 0.75*BOX_H, 0.5*BOX_H, BOX_W ) );\n\n#if 0\n    d = opU(\n            opU( d1, d2 ),\n            d3\n        );\n#else\n    d = opI(\n        opU( d1, d2 ),\n        opU( \n            opI( d1, d2 ),\n            d3\n        )\n    );\n#endif\n#endif // 333\n    \n    return d;\n}\n\n// ========================================\nvec4 DE( vec3 hp, float fts ) {\n    vec4 vResult = vec4(MAX_DIST, -1.0, 0.0, 0.0);\n    vec4 vDist = vec4( draw(hp), MATERIAL_1, hp.xz);\n    vDist.y = gMaterial; // v0.42 draw may over-ride material\n    return opUt(vResult, vDist, fts);\n}\n\n\n// ========================================\nsMat getMaterial( sHit hitInfo ) {\n    sMat mat;\n    if(hitInfo.oid.x == MATERIAL_1) {\n        mat.frs = 0.31;\n        mat.smt = 1.0;\n        mat.trs = 1.0;\n        mat.fri = 0.75;\n        const float fExtinctionScale = 2.0;\n        vec3 tc = vec3(0.93,0.96,1.0);        //tex/col\n        mat.ctc = (vec3(1.0) - tc) * fExtinctionScale; \n    } else\n    if(hitInfo.oid.x == MATERIAL_2) {\n        mat.frs = 0.0;\n        mat.smt = 1.0;\n        mat.trs = 0.0;\n        mat.fri = 0.0;\n        mat.ctc = vec3(0.25,0.5,0.75); // Beautiful Baby Blue\n    }\n    return mat;\n}\n\n// ========================================\nvec3 getBackground( vec3 rd ) {\n#ifdef BACKGROUND_BLUE\n    const vec3  tc = vec3(0.65, 0.78, 1.0);\n    const vec3  cc = tc * 0.5;\n          float f  = clamp(rd.y, 0.0, 1.0);\n    return mix(cc, tc, f);\n#else\n    return texture(iChannel0, rd).xyz;\n#endif\n}\n\n// ========================================\nsLight getDirLight() {\n    sLight result;\n    result.rd  = normalize(vec3(-0.2, -0.3, 0.5));\n    result.col = vec3(8.0, 7.5, 7.0);\n    return result;\n}\n\n// ========================================\nvec3 getAmbient( vec3 nor ) {\n    return getBackground(nor);\n}\n\n// ========================================\nvec3 normal( vec3 p, float fts ) {\n    vec3 e = vec3(0.01,-0.01,0.0);\n    return normalize( vec3(\n        e.xyy*DE(p+e.xyy,fts).x +\n        e.yyx*DE(p+e.yyx,fts).x +\n        e.yxy*DE(p+e.yxy,fts).x +\n        e.xxx*DE(p+e.xxx,fts).x)\n    );\n}\n\n// ========================================\nvoid march( sRay ray, out sHit res, int maxIter, float fts ) {\n    res.hd = ray.sd;\n    res.oid.x = 0.0;\n\n    for( int i=0;i<=MARCHSTEPS;i++ ) {\n        res.hp = ray.ro + ray.rd * res.hd;\n        vec4 r = DE( res.hp, fts );\n        res.oid = r.yzw;\n        if((abs(r.x) <= 0.01) || (res.hd >= ray.rl) || (i > maxIter))\n            break;\n        res.hd = res.hd + r.x;\n    }\n    if(res.hd >= ray.rl) {\n        res.hd = MAX_DIST;\n        res.hp = ray.ro + ray.rd * res.hd;\n        res.oid.x = 0.0;\n    }\n}\n\n// ========================================\nfloat getShadow( vec3 hp, vec3 nor, vec3 lrd, float d ) {\n#ifdef SHADOWS\n    sRay ray;\n    ray.rd = lrd;\n    ray.ro = hp;\n    ray.sd = 0.05 / abs(dot(lrd, nor));\n    ray.rl = d - ray.sd;\n    sHit si;\n    march(ray, si, 32, kNt);\n    float s = step(0.0, si.hd) * step(d, si.hd );\n    return s;\n#else\n    return 1.0;\n#endif\n}\n\n// ========================================\nfloat getAmbientOcclusion( sHit hi, sSurf s ) {\n#ifdef AMBIENT_OCCLUSION\n    vec3 hp = hi.hp;\n    vec3 nor = s.nor;\n    float ao = 1.0;\n\n    float d = 0.0;\n    for( int i=0; i<=5; i++ ) {\n        d += 0.1;\n        vec4 r = DE(hp + nor * d, kNt);\n        ao *= 1.0 - max(0.0, (d - r.x) * 0.2 / d );\n    }\n    return ao;\n#else\n    return 1.0;\n#endif\n}\n\n// ========================================\nvec3 getFog( vec3 color, sRay ray, sHit hi ) {\n#ifdef FOG\n    float a = exp(hi.hd * - 0.05);\n    vec3 fog = getBackground(ray.rd);\n\n    #ifdef DIRECTIONAL_LIGHT_FLARE\n        sLight lig = getDirLight();\n        float f = clamp(dot(-lig.rd, ray.rd), 0.0, 1.0);\n        fog += lig.col * pow(f, 10.0);\n    #endif \n\n    color = mix(fog, color, a);\n#endif\n\n    return color;\n}\n\n// http://en.wikipedia.org/wiki/Schlick's_approximation\n// Anisotropic scattering Schlick phase function\n// \"Interactive Manycore Photon Mapping\"\n// See: https://www.scss.tcd.ie/publications/tech-reports/reports.11/TCD-CS-2011-04.pdf\n//\n// More complex empirically motivated phase functions are efficiently approximated by the Schluck function [BLS93].\n// ========================================\nfloat getSchlick(vec3 nor, vec3 v, float frs, float sf) {\n    float f = dot(nor, -v);\n    f = clamp((1.0 - f), 0.0, 1.0);\n    float fDotPow = pow(f, 5.0);\n    return frs + (1.0 - frs) * fDotPow * sf;\n}\n\n// http://en.wikipedia.org/wiki/Fresnel_equations\n// ========================================\nvec3 getFresnel( vec3 dif, vec3 spe, vec3 nor, vec3 v, sMat m ) {\n    float f = getSchlick(nor, v, m.frs, m.smt * 0.9 + 0.1);\n    return mix(dif, spe, f);\n}\n\n// ========================================\nfloat getPhong( vec3 ird, vec3 lrd, vec3 nor, float smt ) {\n    vec3  v  = normalize(lrd - ird);\n    float f  = max(0.0, dot(v, nor));\n    float sp = exp2(4.0 + 6.0 * smt);\n    float si = (sp + 2.0) * 0.125;\n    return pow(f, sp) * si;\n}\n\n// ========================================\nsShade setDirLight( sLight l, vec3 p, vec3 d, vec3 nor, sMat m ) {\n    sShade s;\n    vec3 lrd = -l.rd;\n    float sf = getShadow( p, nor, lrd, 8.0 );\n    vec3 il = l.col * sf * max(0.0, dot(lrd, nor));\n    s.dfs = il;\n    s.spc = getPhong( d, lrd, nor, m.smt ) * il;\n    return s;\n}\n\n// ========================================\nvec3 setColor( sRay ray, sHit hi, sSurf sc, sMat m ) {\n    vec3 color;\n    sShade s;\n    s.dfs = vec3(0.0);\n    s.spc = vec3(0.0);\n    float ao = getAmbientOcclusion(hi, sc);\n    vec3 al = getAmbient(sc.nor) * ao;\n    s.dfs += al;\n    s.spc += sc.ref;\n\n#ifdef DIRECTIONAL_LIGHT\n    sLight dl = getDirLight();\n    sShade sh = setDirLight(dl, hi.hp, ray.rd, sc.nor, m);\n    s.dfs += sh.dfs;\n    s.spc += sh.spc;\n#endif\n\n    vec3 dr = s.dfs * m.ctc;\n\n    dr = mix(dr, sc.tra, m.trs);\n\n#ifdef SPECULAR\n    color = getFresnel(dr , s.spc, sc.nor, ray.rd, m);\n#else\n    color = dr;\n#endif\n\n    return color;\n}\n\n// ========================================\nvec3 getColor( sRay ray ) {\n    sHit hi;\n    march(ray, hi, 32, kNt);\n    vec3 color;\n\n    if(hi.oid.x < 0.5) {\n        color = getBackground(ray.rd);\n    } else {\n        sSurf s;\n        s.nor  = normal(hi.hp, kNt);\n        sMat m = getMaterial( hi );\n        s.ref  = getBackground(reflect(ray.rd, s.nor));\n        m.trs  = 0.0;\n        color  = setColor(ray, hi, s, m);\n    }\n\n    color = getFog(color, ray, hi);\n    return color;\n}\n\n// ========================================\nvec3 getReflection( sRay ray, sHit hitInfo, sSurf s ) {\n#ifdef REFLECTIONS\n    sRay rRay;\n    rRay.rd = reflect(ray.rd, s.nor);\n    rRay.ro = hitInfo.hp;\n    rRay.rl = 16.0;\n    rRay.sd = 0.1 / abs(dot(rRay.rd, s.nor));\n    return getColor(rRay);\n#else\n    return getBackground(reflect(ray.rd, s.nor));\n#endif\n}\n\n// ========================================\nvec3 getTransparency( sRay ray, sHit hit, sSurf s, sMat m ) {\n#ifdef TRANSPARENCY\n    sRay rRay;\n    rRay.rd = refract(ray.rd, s.nor, m.fri);\n    rRay.ro = hit.hp;\n    rRay.rl = 16.0;\n    rRay.sd = 0.05 / abs(dot(rRay.rd, s.nor));\n\n    #ifdef DOUBLE_SIDED_TRANSPARENCY\n        sHit hit2;\n        march(rRay, hit2, 32, kIt);\n        vec3 nor = normal(hit2.hp, kIt);\n            sRay rRay2;\n            rRay2.rd = refract(rRay.rd, nor, 1.0 / m.fri);\n            rRay2.ro = hit2.hp;\n            rRay2.rl = 16.0;\n            rRay2.sd = 0.0;\n        float ed = hit2.hd;\n        vec3 color = getColor( rRay2 );\n    #else\n        vec3 color = getColor( rRay );\n        float ed = 0.5;\n    #endif\n\n    return color * clamp(exp(-(m.ctc * ed)),0.0,1.0);\n#else\n    return getBackground(reflect(ray.rd, s.nor));\n#endif\n}\n\n// ========================================\nvec3 getRayColor( sRay ray ) {\n    sHit i;\n    march(ray, i, MARCHSTEPS, kTt); //256\n\n    vec3 color;\n    if(i.oid.x < 0.5) {\n        color = getBackground(ray.rd);\n    } else  {\n        sSurf s;\n        s.nor  = normal(i.hp, kTt);\n        sMat m = getMaterial( i );\n        s.ref  = getReflection(ray, i, s);\n        if(m.trs > 0.0) s.tra = getTransparency(ray, i, s, m);\n        color  = setColor(ray, i, s, m);\n    }\n\n    getFog(color, ray, i); // BUG? Is this intentional that color is not updated??\n    return color;\n}\n\n// ========================================\nsRay setCameraRay( vec3 hp, vec3 i , vec2 fragCoord) {\n    float fRatio = iResolution.x / iResolution.y; // Aspect Ratio\n\n    vec3 f   = normalize(i - hp);\n    vec3 vUp = vec3(0.0, 1.0, 0.0);\n    vec2 vvc = 2.*fragCoord.xy/iResolution.xy-1.;\n    vvc.y /= fRatio;\n\n    sRay ray;\n    ray.ro = hp;\n    vec3 r = normalize(cross(f, vUp));\n    vUp    = cross(r, f);\n    ray.rd = normalize( r * vvc.x + vUp * vvc.y + f);\n    ray.sd = 0.0;\n    ray.rl = MAX_DIST;\n    return ray;\n}\n\n// ========================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = vec2(0.0); // Default OpenGL camera: Look down -z axis\n\n#ifdef VIEW_ISOMETRIC\n    m = vec2( 3.5, 1.0 ) / PI; // fake isoemetric\n#else\n  #ifdef VIEW_ZERO\n    // m.x = 0.0; // +z // h -> 0      =   0\n    // m.x =+1.0;; //-z // h -> PI     = 180\n    // m.x = 0.5; // +x // h -> PI  /2 =  90\n    // m.x =-0.5; // -x // h -> PI*3/2 = 270\n    //m.y = iMouse.y / iResolution.y; // uncomment to allow Y rotation\n  #else\n    m += 2.* iMouse.xy / iResolution.xy;\n    m.x += 1.;\n  #endif // ZERO\n#endif // ISOMETRIC\n\n    float nRotate = 0.0; // no rotation\n#ifdef AUTO_ROTATE\n    nRotate = iTime *0.05; // slow rotation\n#endif\n\n    //float h  = mix(0.0, PI , m.x - nRotate);\n    float h  = PI * (m.x - nRotate);\n    float e  = mix(0.0, 2.5, m.y                ); // eye\n    // Hold down mouse button to zoom out & rotate the camera!\n    float d  = mix(2.5, 2.5 + (iMouse.z > 0.0 ? 4.0 : 2.0), m.y); // eye distance\n\n    // ro RayOrigin\n    vec3 ro  = vec3(sin(h) * cos(e), sin(e), cos(h) * cos(e)) * d;\n    vec3 ta  = vec3(0.0, 0.0, 0.0);\n\n    sRay ray = setCameraRay( ta + ro, ta, fragCoord);\n    vec3 col = getRayColor( ray );\n    fragColor = vec4( col, 1.0 );\n}\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XllGW4","date":"1422079099","viewed":23071,"name":"HOWTO: Ray Marching","username":"MichaelPohoreski","description":"A mini tutorial on How To get started with Ray Marching with zero experience.\nThe NeHe, er, PoHo of Ray Marching Tutorials. :-)\n    0.49 Fix uncomment for AUTO_ROTATE","likes":333,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","tutorial","howto"],"hasliked":0,"parentid":"","parentname":""}}