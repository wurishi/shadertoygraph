{"ver":"0.1","info":{"id":"MXjyDy","date":"1727894199","viewed":24,"name":"(WIP)voronoi SDF experimentation","username":"dottedboxguy","description":"IT IS A WIP RIGHT NOW, it's public because desktop shadertoy needs public+api shaders, and i'm using it for debugging purposes","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["voronoi","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//i'm initializing all my vars because it's good practice in order to avoid UB in desktop apps, idc about code size.\n\nuvec3 murmurHash33(uvec3 src) {\n    const uint M = 0x5bd1e995u;\n    uvec3 h = uvec3(1190494759u, 2147483647u, 3559788179u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 3 outputs, 3 inputs\nvec3 hash(vec3 src) {\n    uvec3 h = murmurHash33(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n// returns offset to the center of the cell in the current tile\nvec2 get_point(vec2 p){\n    vec3 rng = hash(vec3(floor(p-1.)*2., floor(iTime)))-.5;\n    return rng.xy*.9;\n}\n\nconst vec2 offsets_direct[4] = vec2[4](\n    vec2(0., -1.),\n    vec2(-1., 0.),\n    vec2(1., 0.),\n    vec2(0., 1.)\n);\n\nconst vec2 offsets_diagonal[4] = vec2[4](\n    vec2(-1., -1.),\n    vec2(1., -1.),\n    vec2(-1., 1.),\n    vec2(1., 1.)\n);\n\nvec3 sdVoronoi(vec2 pos){\n    //how a voronoi cell is represented : https://www.geogebra.org/m/qkunybcx\n    \n    pos-=.5;\n    vec2 p = fract(pos)-.5;\n    \n    //nearest is initialized to the center cell in order to reduce iteration count, considering the worst case scenario of the furthest possible point within a cell\n    vec4 nearest = vec4(get_point(pos), vec2(0.));\n    vec2 current = vec2(0.);\n    vec2 current_offset = vec2(0.);\n    \n    //offset of within the diagonal offsets array, to avoid a specific offest you would never need to calculate\n    //https://www.desmos.com/calculator/6ycntrapqw\n    int offset = int(ceil(.5*sign(p)+.5));\n    \n    //i'm keeping track of square distances instead of full distances here, because for the math in the loops it's all i need, and it means i don't need to compute distance in every single loop\n    vec2 squaredists = vec2(\n        dot(p-nearest.xy, p-nearest.xy),\n        dot(p-current, p-current));\n    \n    //finding the two nearest points to the sampling point\n    for (int i = 0; i<4; i++){\n    \n        current_offset = offsets_direct[i];\n        current = current_offset + get_point(pos + current_offset);\n        \n        squaredists.y = dot(p - current, p - current);\n        if (squaredists.y < squaredists.x){\n        \n            squaredists.xy = squaredists.yx;\n            nearest = vec4(current, current_offset);\n        }\n    }\n    \n    //3 iterations, for a great total of 7 iterations (8 counting the middle cell). you can do that only if the generated voronoi points are constrained to their cell boundaries, -1 to 1 in local space.\n    for (int i = 1; i<4; i++){\n    \n        current_offset = offsets_diagonal[(i+offset)&3];\n        current = current_offset + get_point(pos+current_offset);//mod(i,4) but faster\n        \n        squaredists.y = dot(p - current, p - current);\n        if (squaredists.y < squaredists.x){\n        \n            squaredists.xy = squaredists.yx;\n            nearest = vec4(current, current_offset);\n        }\n    }\n    \n    //if the point generation you have is very expensive (which it probably is, most RNGs are), you should make an array to keep track of the points you already generated, in order to not recalculate them here. i should probably do that to be honest\n    //i'm just not sure since it's going to bring a lot of actual branching instead of cheap little branches, and i'm not really sure if the cost of these is worth it.\n    \n    squaredists.y = 1000000000.; //i'm lazy, didn't want to bother and this works so idc\n    \n    vec2 midpoint = vec2(0.);\n    vec2 projected = vec2(0.);\n    \n    //https://www.desmos.com/calculator/cwl1qu54ld\n    //the projection math might be doable faster ? it's honestly beyond me though...\n    for (int i = 0; i < 4; i++){\n    \n        current_offset = offsets_direct[i]+nearest.zw; //nearest.zw is the offset to the nearest point, i technically don't need it, but i did not want to recalculate it from the nearest point's coordinates itself\n        current = current_offset + get_point(pos+current_offset);\n        \n        midpoint = mix(nearest.xy, current, .5);\n        \n        projected = vec2(nearest.y - current.y, current.x - nearest.x); //this is p4 in the graph\n        \n        projected = projected*(dot(projected, p-midpoint)/dot(projected, projected)) + midpoint;\n        \n        projected = p-projected;\n        squaredists.y = min(squaredists.y, dot(projected,projected));\n        \n    }\n    \n    for (int i = 1; i < 4; i++){\n    \n        current_offset = offsets_diagonal[(i+offset)&3] + nearest.zw;\n        current = current_offset + get_point(pos + current_offset);\n        \n        midpoint = mix(nearest.xy, current, .5);\n        \n        projected = vec2(nearest.y - current.y, current.x - nearest.x); //this is p4 in the graph\n        \n        projected = projected * (dot(projected, p - midpoint)/dot(projected, projected)) + midpoint;\n        \n        projected = p - projected;\n        squaredists.y = min(squaredists.y, dot(projected, projected));\n        \n    }\n    \n    float d = sqrt(squaredists.y);\n    \n    return vec3(d, nearest) - .1;\n}\n\nfloat scene(vec2 p){\n    float d = sdVoronoi(p).x;\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=.5;\n    uv.x *= iResolution.x/iResolution.y;\n    uv*=8.;\n    vec2 m = iMouse.xy/iResolution.xy;\n    m-=.5;\n    m.x *= iResolution.x/iResolution.y;\n    m*=8.;\n\n    float d = scene(uv);\n\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)));\n    \n    d = length(uv-m)-abs(scene(m));\n    \n    if (d<0.01 && d>0.){col = vec3(0.);}\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}