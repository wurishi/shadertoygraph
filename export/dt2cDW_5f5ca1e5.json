{"ver":"0.1","info":{"id":"dt2cDW","date":"1692166608","viewed":35,"name":"bezier -j","username":"jussa","description":"bezier study\n\napplying the polynomial representation of a cubic bezier and curve flattening ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["bezier"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// based on principles from https://pomax.github.io/bezierinfo/\n\n// polynomial function for points on a cubic bezier curve\nvec2 bezy(float t, vec2 P0, vec2 P1, vec2 P2, vec2 P3) {\n    float t2 = t*t;\n    float t3 = t*t2;\n    float mt = 1.-t;\n    float mt2 = mt*mt;\n    float mt3 = mt*mt2;   \n    return P0*mt3+3.*P1*mt2*t+3.*P2*mt*t2+P3*t3;\n}\n\n// determine if a point (p = uv) is close enough to the curve\n// to be drawn\nfloat distanceToSegment(vec2 p, vec2 v, vec2 w) {\n    vec2 vw = w - v;\n    float l2 = dot(vw, vw);\n    if (l2 == 0.0) {\n        return distance(p, v);\n    }\n    float t = clamp(dot(p - v, vw) / l2, 0.0, 1.0);\n    vec2 projection = v + t * vw;\n    return distance(p, projection);\n}\n\n// set line width and return a color for the curve\nvec3 drawLine(vec2 p, vec2 p1, vec2 p2) {\n    float lineWidth = .005;\n    float distToSegment = distanceToSegment(p, p1, p2);\n    if (distToSegment < lineWidth) {\n        return vec3(1.);\n    } else {\n        return vec3(0.);\n    }   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // define uv.x as [0, 1.78] and uv.y as [0, 1]  \n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // set control points for the curve\n    vec2 P0 = vec2(.1, .1);\n    vec2 P1 = vec2(.1, .9);\n    vec2 P2 = vec2(1.67, .1);\n    vec2 P3 = vec2(1.67, .9);\n    \n    // number of line segments making up the curve\n    float numSegments = 100.;\n    float stepSize = 1./numSegments;\n    \n    // background color\n    vec3 color = vec3(0.);\n    \n    // define two adjacent points along the curve using t1 and t2,\n    // which range from 0 to 1. call drawLine to color the line segment\n    // connecting the bezier points.\n    for (float i = 0.; i < numSegments; i++) {\n        float t1 = i*stepSize;\n        float t2 = (i+1.)*stepSize;\n        vec2 p1 = bezy(t1, P0, P1, P2, P3);\n        vec2 p2 = bezy(t2, P0, P1, P2, P3);\n        color += drawLine(uv, p1, p2);\n    }\n    fragColor = vec4(color, 1.);    \n}","name":"Image","description":"","type":"image"}]}