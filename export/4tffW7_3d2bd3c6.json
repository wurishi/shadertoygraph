{"ver":"0.1","info":{"id":"4tffW7","date":"1512090106","viewed":150,"name":"wilderness","username":"aadebdeb","description":"wilderness","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define FAR 1000.0\n# define TERRAIN_HEIGHT  50.0\n\nconst mat2 m = mat2(0.8, 0.6, -0.6, 0.8);\nconst vec3 sundir = normalize(vec3(-0.72, 0.43, -0.63));\n\nfloat hash(vec2 p) {\n\treturn texture(iChannel0, p / 256.0).x;\t\n}\n\nfloat noise(vec2 p) {\n\tvec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    vec2 u = f * f * (3.0 - 2.0 * f);\n    \n    float a = hash(i + vec2(0.0, 0.0));\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n    \n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y) * 2.0 - 1.0;\n}\n\n\nfloat turbulence2(vec2 p) {\n\tfloat sum = 0.0;\n    float amp = 0.5;\n    for (int i = 0; i < 3; i++) {\n    \tsum += amp * abs(noise(p));\n        amp *= 0.5;\n        p *= m * 2.0;\n    }\n    return sum;\n}\n\nfloat fbm5(vec2 p) {\n\tfloat sum = 0.0;\n    float amp = 1.0;\n    for (int i = 0; i < 5; i++) {\n    \tsum += amp * noise(p);\n        amp *= 0.5;\n        p *= m * 2.0;\n    }\n    return sum;\n}\n\nfloat turbulence5(vec2 p) {\n\tfloat sum = 0.0;\n    float amp = 0.5;\n    for (int i = 0; i < 5; i++) {\n    \tsum += amp * abs(noise(p));\n        amp *= 0.5;\n        p *= m * 2.0;\n    }\n    return sum;\n}\n\n\nfloat fbm10(vec2 p) {\n\tfloat sum = 0.0;\n    float amp = 1.0;\n    for (int i = 0; i < 10; i++) {\n    \tsum += amp * noise(p);\n        amp *= 0.5;\n        p *= m * 2.0;\n    }\n    return sum;\n}\n\nfloat turbulence10(vec2 p) {\n\tfloat sum = 0.0;\n    float amp = 0.5;\n    for (int i = 0; i < 10; i++) {\n    \tsum += amp * abs(noise(p));\n        amp *= 0.5;\n        p *= m * 2.0;\n    }\n    return sum;\n}\n\nfloat roughterrain(vec2 p) {\n\treturn smoothstep(0.1, 0.8, turbulence2(p * 0.01)) * TERRAIN_HEIGHT;\n}\n\nfloat terrain5(vec2 p) {\n\treturn smoothstep(0.1, 0.8, turbulence5(p * 0.01)) * TERRAIN_HEIGHT + fbm5(p * 0.12 + 100.0) * TERRAIN_HEIGHT * 0.05;\n}\n\n\nfloat terrain10(vec2 p) {\n\treturn smoothstep(0.1, 0.8, turbulence10(p * 0.01)) * TERRAIN_HEIGHT + fbm10(p * 0.12 + 100.0) * TERRAIN_HEIGHT * 0.05;\n}\n\nvec3 terrainnormal(vec2 p, float t) {\n\tvec2 eps = vec2(0.002 * t, 0.0);\n    return normalize(vec3(\n    \tterrain10(p + eps.xy) - terrain10(p - eps.xy),\n        2.0 * eps.x,\n        terrain10(p + eps.yx) - terrain10(p - eps.yx)\n    ));\n}\n\nfloat intersect(vec3 ro, vec3 rd) {\n\t\n    float t = 0.001;\n    for (int i = 0; i< 100; i++) {\n    \tvec3 p = ro + t * rd;\n        float h = terrain5(p.xz);\n        float d = p.y - h;\n        if (d < 0.01 * t || t > FAR) break;\n        t += 0.3 * d;\n    }\n    \n    return t;\n}\n\nvec3 rendersky(vec3 rd) {\n\treturn mix(vec3(0.89, 0.73, 0.54), vec3(0.65, 0.84, 0.72), smoothstep(-1.0, 1.0, rd.y));\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\t\n    float t = intersect(ro, rd);\n    \n    vec3 col = vec3(0.0);\n    \n    if (t < FAR) {\n        vec3 p = ro + t * rd;        \n        \n        col = 0.2 * mix(vec3(0.98, 0.53, 0.21), vec3(0.95, 0.32, 0.05), fbm10(p.xz * 20.0) * 0.5 + 0.5); \n        vec3 n = terrainnormal(p.xz, t);\n        \n        vec3 lin = vec3(0.0);\n        float amb = clamp(n.y * 0.5 + 0.5, 0.0, 1.0);\n    \tfloat dif = clamp(dot(n, sundir), 0.0, 1.0);\n        float bac = clamp(dot(n, vec3(-sundir.x, 0.0, -sundir.y)), 0.0, 1.0);\n        \n        lin += 1.1 * amb * rendersky(n);\n        lin += 3.2 * dif * vec3(0.98, 0.83, 0.62);\n        lin += 0.54 * bac * vec3(0.83, 0.45, 0.15);\n        \n        col *= lin;\n        \n        col = mix(rendersky(rd), col, exp(-0.000001 * t * t));\n        \n    } else {\n    \tcol = rendersky(rd);\n    }\n        \n    col = sqrt(col);\n    \n    return col;\n}\n\nvec3 camerapath(float t) {\n    vec2 p = vec2(50.0, -t);\n\tfloat h = roughterrain(p);\n    return vec3(p.x, h + 20.0, p.y);\n}\n\nmat3 lookat(vec3 ro, vec3 ta, vec3 up) {\n\tvec3 nz = normalize(ta - ro);\n    vec3 nx = cross(nz, normalize(up));\n    vec3 ny = cross(nx, nz);\n    return mat3(nx, ny, nz);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 st = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    float t = iTime * 70.0;\n    vec2 m = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec3 ro = camerapath(t) + vec3(0.0, (m.y * 0.5 + 0.5) * 75.0, 0.0);\n    vec3 ta = camerapath(t + 100.0) +vec3(m.x * 100.0, 0.0, 0.0);\n    vec3 rd = lookat(ro, ta, vec3(0.0, 1.0, 0.0)) * vec3(st, 1.5);\n    \n    vec3 col = render(ro, rd);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}