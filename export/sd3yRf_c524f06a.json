{"ver":"0.1","info":{"id":"sd3yRf","date":"1653832756","viewed":73,"name":"Uniform B-Spline","username":"Envy24","description":"BufferA - drawing spline\nBufferB - drawing control points\nBufferC - drawind dashed convex hull\nImage - mixing and coloroing\n\nFour passes used for better readability of code.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["cubic","interpolation","uniform","curvebspline"],"hasliked":0,"parentid":"ft2Bzy","parentname":"Uniform Cubic B-Spline"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 O, in vec2 SC )\n{\n    vec4 spline      = TEXF0(SC);\n    vec4 knot        = TEXF1(SC);\n    vec4 convex_hull = TEXF2(SC);\n    \n    float min = MIN3(spline.r, knot.r, convex_hull.r);\n    \n    O = \n        min == 1.0 ?\n            vec4(1) :                            // Background color\n            min == spline.r ?\n                vec4(0, spline.r, spline.r, 1) : // Spline color\n                min == knot.r ?\n                    vec4(0, knot.r, 0, 1) :      // Knot color\n                    vec4(convex_hull);           // Convex hull  color\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R                           iResolution\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define INITIALLY_FAR               9e30\n#define TEXF0(SC)                 ( texelFetch(iChannel0, ivec2(SC), 0) )\n#define TEXF1(SC)                 ( texelFetch(iChannel1, ivec2(SC), 0) )\n#define TEXF2(SC)                 ( texelFetch(iChannel2, ivec2(SC), 0) )\n#define MIN3(a, b, c)             ( min(min((a), (b)), (c)) )\n#define NMY                       ( iMouse.y / R.y )                 // in range [0.0; 1.0]\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n\n#define RANDOM\n\n/*\n    order = 2   -  linear\n            3   -  quadratic\n            4   -  cubic\n            5   -  quartic\n            6   -  quintic\n            e.t.c\n*/\nconst int order = 6; // 2 minimum (linear).\nconst int matrix_size = order * order;\nconst int row_size = order;\nfloat M[matrix_size];\n\nconst int num_of_ctrls = max(order, 10); /* \"order\" knots minimum, then +1 per segment */\nvec2 ctrls[num_of_ctrls];\n/**\nvec2 ctrls[num_of_ctrls] = vec2[num_of_ctrls](\n    vec2( -1.7, 0.9),\n    vec2( -1.5, -0.9),\n    vec2( -0.1,  0.9), \n    vec2(  0.0,  0.0), \n    vec2(  0.1, -0.9),\n    \n    vec2(  1.0,  0.9),\n    vec2(  1.5,  0.9),\n    vec2(  1.5,  0.9)\n);\n/**/\n\nfloat circleSQSDF(\n    in vec2 S,           // sample coordinates\n    in vec2 C,           // circle center\n    in float r,          // circle radius\n    in float smoothness) // AA parameter\n{\n    // Sample coordinates relative to circle center.\n    float _x = S.x - C.x; float _y = S.y - C.y;\n    \n    // Signed distance of areas (squared distancies).\n    float sds = _x * _x + _y *_y - r * r;\n    \n    float ss = smoothness * smoothness;\n    \n    // Smoothstep interpolation.\n    return smoothstep(-ss, ss, sds);\n    //return smoothstep(-ss, ss, sds * sds); // outline\n}\n\n/* \n    Returns random vec2([-1.0; 1.0], [-1.0; 1.0]).\n*/\nvec2 vector2HashUI32(\n    const uint x,\n    const uint y)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 123u;\n    const uint entropy1 = 456u;\n    const uint entropy2 = 789u;\n\n    // Use linear offset method to mix coordinates.\n    uint value0 = y * entropy2 + x;\n    uint value1 = x * entropy2 + y;\n\n    // Calculate hash.\n\tvalue0 += entropy1; value0 *= 445593459u; value0 ^= entropy0;\n    value1 += entropy1; value1 *= 445593459u; value1 ^= entropy0;\n    \n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return \n        vec2(\n            float(value0 * value0 * value0) * 4.6566128730773926e-10f - 1.0f,\n            float(value1 * value1 * value1) * 4.6566128730773926e-10f - 1.0f);\n}\n\nvoid randomize_ctrls(float time)\n{\n    time *= 0.5;\n    float t = fract(time);\n    uint T = uint(time);\n\n    for (int k = 0; k < num_of_ctrls; ++k)\n    {\n        uint x = T + uint(k);\n        uint y = 2u * T + uint(k * 2);\n        vec2 c = vector2HashUI32(x, y);\n        vec2 n = vector2HashUI32(x + 1u, y + 2u);\n    \n        ctrls[k] = c * (1. - t) + n * t;\n    }\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"uint factorialTableM12(uint n)\n{\n    switch (n)\n    {\n    case 0u:\n    case 1u: return 1u;\n    case 2u: return 2u;\n    case 3u: return 6u;\n    case 4u: return 24u;\n    case 5u: return 120u;\n    case 6u: return 720u;\n    case 7u: return 5040u;\n    case 8u: return 40320u;\n    case 9u: return 362880u;\n    case 10u: return 3628800u;\n    case 11u: return 39916800u;\n    case 12u: return 479001600u;\n    default: break;\n    }\n    return 0u;\n}\n\nuint binomialCoefficient32(\n    uint rowIdx, // [0; 34]\n    uint colIdx) // [0; 34]\n{\n    if (rowIdx == 0u || colIdx == 0u || rowIdx == colIdx) { return 1u; }\n    if (rowIdx <= 12u)\n    {\n        return\n            factorialTableM12(rowIdx) /\n            (factorialTableM12(colIdx) * factorialTableM12(rowIdx - colIdx));\n    }\n\n    uint buffer[70];\n    buffer[0] = 1u;   buffer[1] = 13u;   buffer[2] = 78u;   buffer[3] = 286u;\n    buffer[4] = 715u; buffer[5] = 1287u; buffer[6] = 1716u; buffer[7] = 1716u;\n\n    if (rowIdx == 13u) { return buffer[colIdx > 6u ? 13u - colIdx : colIdx]; }\n\n    for (uint c = 13u, b = 0u; c >= 7u; --c, ++b) { buffer[c] = buffer[b]; }\n\n    uint r_buff = 0u;\n    buffer[35] = 1u;\n\n    for (uint r = 14u; r <= rowIdx; ++r)\n    {\n        uint r_offset = r_buff * 35u;\n        uint w_offset = ((r_buff + 1u) & 1u) * 35u;\n        buffer[w_offset + r] = 1u;\n\n        for (uint c = 1u; c < r; ++c)\n        {\n            buffer[w_offset + c] = buffer[r_offset + c - 1u] + buffer[r_offset + c];\n        }\n\n        r_buff = (r_buff + 1u) & 1u;\n    }\n\n    return buffer[r_buff * 35u + colIdx];\n}\n\nfloat martixCoefficient(\n    uint row_idx,\n    uint col_idx,\n    uint degree)\n{\n    float m = 0.;\n    float _sign = 1.;\n\n    for (uint k = col_idx; k <= degree; ++k)\n    {\n        float diff = float(degree - k);\n        float power = 1.;\n\n        for (uint p = 1u; p <= row_idx; ++p)\n        {\n            power *= diff;\n        }\n\n        m += power * _sign * float(binomialCoefficient32(degree + 1u, k - col_idx));\n\n        _sign *= -1.;\n    }\n\n    return m;\n}\n\nvoid calculateMatrix(\n    inout float[matrix_size] M,\n    uint degree)\n{\n    float invN = 1. / float(factorialTableM12(degree));\n\n    int w_offset = 0;\n    for (uint r = 0u; r <= degree; ++r)\n    {\n        M[w_offset] = 0.;\n        \n        float bc= float(binomialCoefficient32(degree, r));\n        \n        for (uint c = 0u; c <= degree; ++c)\n        {\n            M[w_offset++] = invN * martixCoefficient(r, c, degree) * bc;\n        }\n    }\n}\n\nvec2 uniformBSplineSegment(\n    vec2[order] ctrls,\n    float[matrix_size] M,\n    float t)\n{\n    float pows[order];    // powers of t in decreasing order.\n    pows[order - 1] = 1.;\n    \n    for (int p = order - 2; p >= 0; --p)\n    {\n        pows[p] = pows[p + 1] * t;\n    }\n    \n    float W[order]; // weights for blending between control points\n    \n    // Matrix-Vector multiplication\n    for (int r = 0; r < row_size; ++r)\n    {\n        W[r] = 0.;\n        for (int c = 0; c < row_size; ++c)\n        {\n            W[r] += M[c * row_size + r] * pows[c];\n            //coef[r] += M[r * row_size + c] * pows[c]; // other order\n        }\n    }\n\n    vec2 P = vec2(0);\n    \n    for (int c = 0; c < row_size; ++c)\n    {\n        P += W[c] * ctrls[c];\n    }\n\n    return P;\n}\n\nvec2 find_closest_spline_point_to_pixel(\n    in vec2[num_of_ctrls] ctrls,\n    in vec2 NDC)\n{\n    vec2 closestP = vec2(0);\n    float minSqDist = INITIALLY_FAR;\n    \n    float dt = 0.02;  \n    \n    int num_of_segments = num_of_ctrls - (order - 1);\n    \n    calculateMatrix(M, uint(order - 1));\n\n    for (int s = 0; s < num_of_segments; ++s)\n    {       \n        vec2 _ctrls[order];\n        \n        // Copy segment points\n        for (int c = 0; c < order; ++c)\n        {\n            _ctrls[c] = ctrls[s+c];\n        }\n    \n        for (float t = 0.; t <= 1.; t += dt)\n        {\n            //vec2 P = uniformCubicBSplineSegmentM(_ctrls, t);\n            vec2 P = uniformBSplineSegment(_ctrls, M, t);\n            //vec2 P = uniformCubicBSplineSegmentWithTensionM(_ctrls, t, NMY * 20.);\n\n            vec2 diff = P - NDC;\n            float sqDist = dot(diff, diff);\n\n            minSqDist = min(minSqDist, sqDist);\n\n            closestP = \n                minSqDist == sqDist ? \n                    P :\n                    closestP;\n        }\n    }\n    \n    return closestP;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = TO_CENTERED_NDC(SC);\n\n#ifdef RANDOM\n    randomize_ctrls(iTime);\n#endif\n\n    O = vec4(circleSQSDF(\n        find_closest_spline_point_to_pixel(ctrls, NDC),\n        NDC,\n        0.01,\n        0.011));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec2 find_closest_control_point_to_pixel(\n    in vec2[num_of_ctrls] ctrls,\n    in vec2 NDC)\n{\n    vec2 closestP = vec2(0);\n    float minSqDist = INITIALLY_FAR;\n\n    for (int k = 0; k < num_of_ctrls; ++k)\n    {\n        vec2 diff = ctrls[k] - NDC;\n        float sqDist = dot(diff, diff);\n       \n        minSqDist = min(minSqDist, sqDist);\n        \n        closestP = \n            minSqDist == sqDist ? \n                ctrls[k] :\n                closestP;\n    }\n    \n    return closestP;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = TO_CENTERED_NDC(SC);\n\n#ifdef RANDOM\n    randomize_ctrls(iTime);\n#endif\n\n    O = vec4(circleSQSDF(\n        find_closest_control_point_to_pixel(ctrls, NDC),\n        NDC,\n        0.02,\n        0.018));\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"vec2 find_closest_convex_hull_point_to_pixel(\n    in vec2[num_of_ctrls] ctrls,\n    in vec2 NDC)\n{\n    vec2 closestP = vec2(0);\n    float minSqDist = INITIALLY_FAR;\n    \n    int num_of_lines = num_of_ctrls - 1; // 2 knots per line\n     \n    for (int l = 0; l < num_of_lines; ++l)\n    {\n        for (float t = 0.; t <= 1.; t += 0.1)\n        {\n            vec2 P = ctrls[l] * (1. - t) + ctrls[l + 1] * t;\n\n            vec2 diff = P - NDC;\n            float sqDist = dot(diff, diff);\n\n            minSqDist = min(minSqDist, sqDist);\n\n            closestP = \n                minSqDist == sqDist ? \n                    P :\n                    closestP;\n        }\n    }\n    \n    return closestP;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = TO_CENTERED_NDC(SC);\n\n#ifdef RANDOM\n    randomize_ctrls(iTime);\n#endif\n\n    O = vec4(circleSQSDF(\n        find_closest_convex_hull_point_to_pixel(ctrls, NDC),\n        NDC,\n        0.008,\n        0.0088));\n}","name":"Buffer C","description":"","type":"buffer"}]}