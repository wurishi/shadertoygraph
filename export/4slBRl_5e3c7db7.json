{"ver":"0.1","info":{"id":"4slBRl","date":"1497546479","viewed":143,"name":"Simple shadows","username":"phuidn","description":"a basic implementation of shadows in diffuse lighting, plenty of room for improvement","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","shadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPS (0.0005)\n#define TAU (6.2832)\n\n// SDF for a sphere\nfloat sphereSDF(vec3 point, vec3 centre, float radius)\n{\n \treturn (length(centre - point) - radius);   \n}\n\n// SDF for a cube\nfloat cubeSDF(vec3 point, vec3 centre, float side_length)\n{\n    point -= centre;\n    float half_side = side_length * 0.5;\n    \n \treturn max(max(abs(point.x) - half_side, abs(point.y) - half_side),\n               abs(point.z) - half_side);\n}\n\n// a sphere with cubes rotating around it\nfloat sceneSDF(vec3 point)\n{\n    float dist,\n          phi = atan(point.y, point.x),\n          r = sqrt(point.x * point.x + point.y * point.y),\n          omega = TAU / 8.0;\n    \n    phi = mod(phi + omega * iTime,radians(15.0)) - 0.5 * radians(15.0);\n    float r_x = r * cos(phi),\n    \t  r_y = r * sin(phi);\n\n    dist = sphereSDF(point, vec3(0,0,0), 1.0);\n    dist = min(dist, cubeSDF(vec3(r_x, r_y, point.z), \n                             1.3 * vec3(1.0, 0.0, 0.0), \n                             0.2));\n         \n    \n    return dist;\n}\n\n//checks whether there is an uninterrupted line between a point on the surface and\n//another point (the light source in this instance)\nbool clearLine(vec3 surface_point, vec3 point2)\n{\n \tvec3 dir = normalize(surface_point - point2);\n    \n    float dist_to_point = length(surface_point - point2),\n          dist;\n    \n    const int max_its = 200;\n    \n    for (int i = 0; i < max_its; i++)\n    {\n    \tdist = sceneSDF(point2);\n        \n        if (dist_to_point - dist < EPS)\n        {\n            return true;\n        }\n        \n        if (dist < 0.0)\n        {\n         \treturn false;   \n        }\n        \n        point2 += dir * dist;\n        dist_to_point -= dist;\n    }\n    \n    return false;\n}\n\n//basic diffuse reflection from the phong reflection model\nvec3 diffuseReflection(vec3 k_d, vec3 surface_point, vec3 surface_normal,\n                        vec3 light_pos, vec3 light_col)\n{\n    float intensity = max( dot(surface_normal, normalize(light_pos - surface_point)), 0.0);\n    \n    return k_d * light_col * intensity;   \n}\n\n//adds an ambient term everywhere, and diffuse reflection everywhere where there is a\n//clear path to the light source\nvec3 calculateLighting(vec3 surface_point, vec3 surface_normal, vec3 light_pos)\n{\n \tvec3 col;\n    \n    if (clearLine(surface_point, light_pos))\n    {\n    \tcol = diffuseReflection(vec3(1.0,1.0,0.85), surface_point, surface_normal, light_pos, vec3(1.0,1.0,1.0));\n    }\n\n    return col + vec3(0.0,0.0,0.075);\n}\n\n//estimate the normal of a point (on the surface of the scene geometry)\nvec3 normalEstimate(vec3 point)\n{\n    vec3 dx = vec3(EPS, 0, 0),\n         dy = vec3(0, EPS, 0),\n         dz = vec3(0, 0, EPS);\n    \n \treturn normalize(vec3(sceneSDF(point + dx) - sceneSDF(point - dx),\n                          sceneSDF(point + dy) - sceneSDF(point - dy),\n                          sceneSDF(point + dz) - sceneSDF(point - dz)));\n}\n\n\n//a matrix which transforms from camera space to world space\nmat4 transformMat(vec3 position, vec3 lookAt, vec3 up)\n{\n    vec3 z_c = -normalize(lookAt - position),\n         x_c = normalize(cross(up, z_c)),\n         y_c = normalize(cross(z_c, x_c));\n    \n    return mat4( vec4(x_c, 0),\n                 vec4(y_c, 0),\n                 vec4(z_c, 0),\n                 vec4(position, 1) );\n}\n\n//calculate the raytracing path for this pixel in camera space\nvec3 pathVector(float fov_angle, vec2 px_coord, vec3 resolution)\n{\n \tvec2 xy = (px_coord - 0.5 * resolution.xy);\n    float z = -resolution.x / (2.0 * tan(radians(fov_angle) * 0.5));\n\t\n    return normalize(vec3(xy, z));\n}\n\n//calculate the closest distance from the camera to the geometry, for the current pixel\nfloat closestDistance(vec3 camera, vec3 rayVec, float minDist, float maxDist)\n{\n \tfloat dist,\n          totDist = minDist;\n    \n    const int max_its = 300;\n    \n    for (int i = 0; i < max_its; i++)\n    {\n    \tdist = sceneSDF(camera + totDist * rayVec);\n        totDist += dist;\n        \n        if (totDist > maxDist)\n        {\n         \treturn maxDist;   \n        }\n        if (dist < EPS)\n        {\n         \treturn totDist;   \n        }\n    }\n    \n    return maxDist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float camera_rad = 5.0,\t\n          x = camera_rad * cos (TAU * iTime * 0.05),\n          z = camera_rad * sin (TAU * iTime * 0.05),\n          y = 3.0;\n    \n\tvec3 camera_pos =  vec3(x,y,z);\n    vec3 initial_path = pathVector(60.0, fragCoord, iResolution);\n    mat4 camera_to_world = transformMat(camera_pos, vec3(0), vec3(0,1,0));\n    \n    float minDist = 0.1,\n  \t\t  maxDist = 10.0;\n    \n    initial_path = (camera_to_world * vec4(initial_path,0)).xyz;\n    \n    float dist = closestDistance(camera_pos, initial_path, minDist, maxDist);\n    \n    if (dist > maxDist - EPS)\n    {\n     \tfragColor = vec4(0,0,0,0);   \n        return;\n    }\n    \n    vec3 scene_point = camera_pos + dist * initial_path;\n    \n    vec3 surface_normal = normalEstimate(scene_point);\n    vec3 colour = calculateLighting(scene_point, surface_normal, \n                                    vec3(camera_pos.x*0.1, 3.0, camera_pos.z*0.1));\n    \n    fragColor = vec4(colour,1.0);\n    //fragColor = vec4(0.5 * (normalEstimate(scene_point) + 1.0), 1.0);\n    \n\n}\n\n","name":"Image","description":"","type":"image"}]}