{"ver":"0.1","info":{"id":"7ssSR2","date":"1618919069","viewed":89,"name":"312_kamkia_v5","username":"nina_kamkia","description":"v5__icosahedron_v1_fire","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["hometask"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv)/float(iFrame + 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float INF = 1e10;\nconst float AIR_N = 1.0;\nconst float GLASS_N = 1.5;\nconst vec3  CAMERA_POS = vec3(0, 1.2, -6);\nconst vec3  Light1_pos = vec3(-2, 1, 3);\nconst float Light1_radius = 0.5;\nconst vec3  Light1_color = vec3(0.35,0.65,0);\nconst float Light1_int = 20.0;\nconst vec3  Light2_pos = vec3(-2, 1.5, 1);\nconst float Light2_radius = 0.25;\nconst vec3  Light2_color = vec3(0,0.23,0.23);\nconst float Light2_int = 20.0;\nconst vec3  Light3_pos = vec3(2, 1.5, 3);\nconst float Light3_radius = 0.25;\nconst vec3  Light3_color = vec3(1,0,1);\nconst float Light3_int = 10.0;\nconst float k = 0.1;\nint         MAX_STEPS = 50;\nvec3        FIRE_COLOR = vec3(1, 0, 0);\nfloat       ABSN = -12.0;\nvec3        randDir;\n\nfloat powf(float x, int a) {\n    float q = x;\n    int i = a;\n    while (i-- > 1) q *= x;\n    return a == 0 ? 0.0 : q;\n}\n\nfloat noise(vec3 p) {\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1, 57, 21)) + vec4(0, 57, 21, 78);\n\tvec3 f = cos((p-i)*acos(-1.0))*(-0.5) + 0.5;\n\ta = mix(sin(cos(a)*a),sin(cos(1.0 + a)*(1.0 + a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z);\n}\n\nfloat rand(float frame) {\n    return fract(sin(dot(vec3(frame), vec3(12.9898, 78.233, 45.5432)))*43758.5453);\n}\n\nstruct Material {\n    float emission;\n    float diffusion;\n    float reflection;\n    float refraction;\n    float n;\n    int spectral_exp;\n    vec3 col;\n};\n\nstruct Sphere {\n    vec3 pos;\n    float radius;\n    Material m;\n};\n\nstruct Light {\n    Sphere sphere;\n    float intensity;\n};\n\nstruct Quad {\n    vec3 p[3];\n    Material m;\n};\n\nstruct Square {\n    vec3 v[4];\n};\n\nstruct Triangle {\n    vec3 vertecies[3];\n};\n\n\nstruct Icosahedron {\n    vec3 vertecies[12];\n    Material m;\n};\n\n\n//const Material emissive = Material(1.0, 0.0, 0.0, 0.0, AIR_N,0, vec3(0));\n//const Material diffusive = Material(0.0, 1.0, 0.0, 0.0, AIR_N,50, vec3(0));\n//const Material reflective = Material(0.0, 0.0, 1.0, 0.0, AIR_N,0,  vec3(0));\n//const Material refractive = Material(0.0, 0.0, 0.0, 1.0, GLASS_N,0, vec3(0));\n//const Material glass = Material(0.0, 0.4, 1.0, 1.0, GLASS_N,50, vec3(0.5));\n\nconst Material emissive = Material(1.0, 0.0, 0.0, 0.0, AIR_N, 0, vec3(0));\nconst Material diffusive = Material(0.1, 1.0, 0.0, 0.0, AIR_N, 50, vec3(1));\nconst Material reflective = Material(0.0, 0.0, 1.0, 0.0, AIR_N, 0, vec3(0));\nconst Material refractive = Material(0.0, 0.0, 0.0, 1.0, GLASS_N, 0, vec3(0));\nconst Material glass = Material(0.0, 0.4, 1.0, 1.0, GLASS_N, 50, vec3(1));\n\nIcosahedron ico = Icosahedron(\nvec3[12](vec3(-0.5,  0.809, 0),\n         vec3( 0.5,  0.809, 0),\n         vec3(-0.5, -0.809, 0),\n         vec3( 0.5, -0.809, 0),\n         vec3(0, -0.5,  0.809),\n         vec3(0,  0.5,  0.809),\n         vec3(0, -0.5, -0.809),\n         vec3(0,  0.5, -0.809),    \n         vec3( 0.809, 0, -0.5),\n         vec3( 0.809, 0,  0.5),\n         vec3(-0.809, 0, -0.5),\n         vec3(-0.809, 0,  0.5)),  glass);\n\nstruct Cylinder {\n    vec3 pos;\n    float radius;\n    Material m;\n};\n\nstruct Scene {\n    Light[3] lights;\n    Icosahedron i;\n    Cylinder cyl;\n} scene;\n\nfloat flame(vec3 p)\n{\n    float d = length(vec3(0, 1, 0) - p*vec3(1, 0.7, 1)) - 1.0;\n\treturn d + (noise(p + vec3(0, 5, 0)) + noise(p * 3.0)* 0.5)* 0.25 *(p.y) ;\n}\n\nvec4 raymarch(vec3 org, vec3 dir)\n{\n\tfloat d = 0.0, glow = 0.0, eps = 0.02;\n\tvec3  p = org;\n\tbool glowed = false;\n    float k = 64.0;\n\t\n\tfor(int i = 0; i < int(k); i++)\n\t{\n\t\td = min(150.0 - length(p), abs(flame(p))) + eps;\n\t\tp += d * dir;\n\t\tif (d > eps)\n\t\t{\n            glowed = glowed || flame(p) < 0.0;\n\t\t\tglow = glowed ? float(i)/k : 0.0;\n\t\t}\n\t}\n\treturn vec4(p,glow);\n}\n\nfloat tracePlane(vec3 camPos, vec3 dir, out vec3 N) {\n    float t = (-1.5 - camPos.y)/ dir.y;\n    vec3 worldPos = t * dir + camPos;\n    if (t < 0.0 || dot(worldPos.xz, worldPos.xz) > 100.0) return INF;\n    N = vec3(0, 1, 0);\n    return t;\n}\n\nfloat traceTriangle(vec3 pos, vec3 dir, Triangle tr, out vec3 N)\n{\n    const float EPSILON = 0.0000001;\n    vec3 vertex0 = tr.vertecies[0];\n    vec3 vertex1 = tr.vertecies[1];  \n    vec3 vertex2 = tr.vertecies[2];\n    vec3 edge1 = vertex1 - vertex0;\n    vec3 edge2 = vertex2 - vertex0;\n    vec3 h = cross(dir, edge2);\n    float a = dot(edge1, h);\n    if (a > -EPSILON && a < EPSILON) return INF;\n    float f = 1.0/a;\n    vec3 s = pos - vertex0;\n    float u = f * dot(s, h);\n    if (u < 0.0 || u > 1.0) return INF;\n    vec3 q = cross(s, edge1);\n    float v = f * dot(dir, q);\n    if (v < 0.0 || u + v > 1.0) return INF;\n    float t = f * dot(edge2, q);\n    if (t < EPSILON) return INF;\n    vec3 v1 = vertex2 - vertex0;\n    vec3 v2 = vertex1 - vertex0;\n    N = normalize(cross(v1,v2));\n    return t;\n}\n\nbool iBox(vec3 orig, vec3 dir, vec3 cen, vec3 rad ) \n{\n    vec3 m = 1.0/dir;\n    vec3 n = m*(orig-cen);\n    vec3 k = abs(m)*rad;\n  \n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n  \n    return !( tN > tF || tF < 0.0);\n}\n\nfloat traceIcosahedron(vec3 pos, vec3 dir, Icosahedron i, out vec3 N) {\n    Triangle tr[20];\n    tr[0] = Triangle(vec3[3](i.vertecies[5], i.vertecies[11], i.vertecies[0])); \n    tr[1] = Triangle(vec3[3](i.vertecies[1], i.vertecies[5], i.vertecies[0]));\n    tr[2] = Triangle(vec3[3](i.vertecies[7], i.vertecies[1], i.vertecies[0])); \n    tr[3] = Triangle(vec3[3](i.vertecies[10], i.vertecies[7], i.vertecies[0]));\n    tr[4] = Triangle(vec3[3](i.vertecies[11], i.vertecies[10], i.vertecies[0]));\n\n    tr[5] = Triangle(vec3[3](i.vertecies[9], i.vertecies[5], i.vertecies[1])); \n    tr[6] = Triangle(vec3[3](i.vertecies[4], i.vertecies[11], i.vertecies[5]));\n    tr[7] = Triangle(vec3[3](i.vertecies[2], i.vertecies[10], i.vertecies[11]));\n    tr[8] = Triangle(vec3[3](i.vertecies[6], i.vertecies[7], i.vertecies[10]));\n    tr[9] = Triangle(vec3[3](i.vertecies[8], i.vertecies[1], i.vertecies[7])); \n\n    tr[10] = Triangle(vec3[3](i.vertecies[4], i.vertecies[9], i.vertecies[3]));   \n    tr[11] = Triangle(vec3[3](i.vertecies[2], i.vertecies[4], i.vertecies[3])); \n    tr[12] = Triangle(vec3[3](i.vertecies[6], i.vertecies[2], i.vertecies[3]));\n    tr[13] = Triangle(vec3[3](i.vertecies[8], i.vertecies[6], i.vertecies[3]));\n    tr[14] = Triangle(vec3[3](i.vertecies[9], i.vertecies[8], i.vertecies[3]));\n\n    tr[15] = Triangle(vec3[3](i.vertecies[5], i.vertecies[9], i.vertecies[4])); \n    tr[16] = Triangle(vec3[3](i.vertecies[11], i.vertecies[4], i.vertecies[2])); \n    tr[17] = Triangle(vec3[3](i.vertecies[10], i.vertecies[2], i.vertecies[6]));\n    tr[18] = Triangle(vec3[3](i.vertecies[7], i.vertecies[6], i.vertecies[8]));\n    tr[19] = Triangle(vec3[3](i.vertecies[1], i.vertecies[8], i.vertecies[9]));\n    vec3 tmpN;\n    float t = INF;\n    for (int i = 0; i < tr.length(); i++) {\n        float triangleT = traceTriangle(pos, dir, tr[i], tmpN);\n        if (triangleT < t) {\n            t = triangleT;\n            N = tmpN;\n        }\n    }\n    return t;\n}\n\nvec4 InFire(vec3 pos, vec3 dir, float r){\n\n    float t = length(pos) - r/4.0;\n    const float MARCH_SIZE = 0.01;\n    float opacity = 1.0;\n    float totalAbs = 0.0;\n    for (int i = 0; i < 50; ++i) {\n        vec3 curPos = pos + (float(i) * MARCH_SIZE + t) * dir;\n        float sdf =  length(curPos) - r/4.0;\n        if (sdf < -0.05 && sdf > -0.3) {\n            float prevOpacity = opacity;\n            float ok = ABSN * (\n            texture(iChannel2, curPos).r +\n            texture(iChannel2, curPos *  3.0).r\n            )/2.0 * abs(sdf);\n            opacity *= exp(-ok * MARCH_SIZE);\n            float absorptionLastStep = prevOpacity - opacity;\n            totalAbs += absorptionLastStep;\n        }\n    }\n    vec4 rp = vec4(FIRE_COLOR * 2.0 * totalAbs, 1.0 - opacity);\n    return rp;\n}\n\nfloat traceSphere(vec3 camPos, vec3 dir, Sphere s, out vec3 N) {\n    vec3 pos = camPos - s.pos;\n    float b = dot(pos, dir);\n    float D = b * b - dot(pos, pos) + s.radius * s.radius;\n    if (D < 0.0) return INF;\n    float t = -b - sqrt(D);\n    t = t < 0.0 ? -b + sqrt(D) : t;\n    if (t < 0.0) return INF;\n    N = normalize(pos + t * dir);\n    return t;\n}\n\nfloat traceplane(vec3 orig, vec3 dir, vec3 p0, vec3 p1, vec3 p2, out vec3 N) {\n    N = normalize(cross(p2-p0, p1-p0));\n    float denom = dot(N, dir);\n    if (abs(denom) < 0.0001f) return INF;\n    float t = dot(p0 - orig, N) / denom;\n    return t < 0.0 ? INF : t;\n}\n\n#define orient(a, b, c, N) dot(cross(b-a, c-a), N)\n\nfloat traceSquare(vec3 orig, vec3 dir, Square sq, out vec3 N) {\n    float t = traceplane(orig, dir, sq.v[0], sq.v[1], sq.v[3], N);\n    if (t == INF) return INF;\n    vec3 q = orig + dir * t;\n    float o1 = orient(q, sq.v[0], sq.v[1], N);\n    float o2 = orient(q, sq.v[1], sq.v[2], N);\n    float o3 = orient(q, sq.v[2], sq.v[3], N);\n    float o4 = orient(q, sq.v[3], sq.v[0], N);\n    if (o1 * o2 > 0.0 && o2 * o3 > 0.0 && o3 * o4 > 0.0) return t;\n    return INF;\n}\n\nfloat traceCylinder(vec3 pos, vec3 dir, float r, out vec3 normal) {\n    const float h = -0.8;\n    float t = (h - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    vec3 worldPos = pos + t * dir;\n    if (dot(worldPos.xz, worldPos.xz) < r * r) {\n        normal = vec3(0, 1, 0);\n        return t;\n    }\n    \n    float b = dot(pos.xz, dir.xz);\n    float D = b * b - (dot(pos.xz, pos.xz) - r * r) * dot(dir.xz, dir.xz);\n    if (D < 0.0) {\n        return INF;\n    }\n    t = (-b - sqrt(D)) / dot(dir.xz, dir.xz);\n    worldPos = pos + t * dir;\n    if (worldPos.y < h && worldPos.y >= -2.0) {\n        if (t >= 0.0) {\n            normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n            return t;\n        }\n    }\n    return INF;\n}\n\n\nfloat traceScene(vec3 pos, vec3 dir, out vec3 N, out Material m) {\n    vec3 tmpN;\n    float t = INF;\n    float icoT = traceIcosahedron(pos, dir, scene.i, tmpN);\n    if (icoT < t) {\n        t = icoT;\n        N = tmpN;\n        m = scene.i.m;\n    }\n    \n    float cylT = traceCylinder(pos, dir, scene.cyl.radius, tmpN);\n    if (cylT < t) {\n        t = cylT;\n        N = tmpN;\n        m = scene.cyl.m;\n    }\n    return t;\n}\n\nbool isOccluded(vec3 pos, Light light) {\n    vec3 dir = light.sphere.pos - pos + randDir * light.sphere.radius;\n    float dist = length(dir);\n    dir /= dist;\n    vec3 tmpN;\n    Material tmpM;\n    float t = traceScene(pos + dir * 1e-3, dir, tmpN, tmpM);\n    return t < dist;\n}\n\nvec3 computeLight(vec3 pos, vec3 dir, vec3 N, Material m) {\n    vec3 lightPower = vec3(0);\n    vec3 spectralLight = vec3(0);\n    for (int i = 0; i < scene.lights.length(); i++) {\n        vec3 toLight = scene.lights[i].sphere.pos - pos;\n        float att = isOccluded(pos, scene.lights[i]) ? 0.5 : scene.lights[i].intensity / dot(toLight, toLight);\n        lightPower += max(0.0, dot(N, normalize(toLight))) * att * scene.lights[i].sphere.m.col;\n        spectralLight += powf(max(0.0, dot(dir, reflect(normalize(toLight), N))), m.spectral_exp) * vec3(1) * att;\n    }\n    lightPower += texture(iChannel1, N).rgb * 0.1;\n    return m.col * (0.1 + lightPower) + spectralLight;\n}\n\nvec3 refraction(vec3 v, vec3 N, float n1, float n2) {\n    if (dot(v,N) < 0.0) N = -N;\n    float cosA = dot(v, N);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tg = normalize(v - cosA*N);\n    float sinB = sinA/n2 * n1;\n    float cosB = sqrt(1.0 - sinB*sinB);\n    return sinB * tg + cosB * N;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    bool b = false;\n    vec3 randV = vec3(rand(float(iFrame)), rand(float(iFrame +5)), rand(float(iFrame + 15)));\n    randDir = normalize(randV - 0.5);\n    Material light1_m = emissive;\n    light1_m.col = Light1_color;\n    Material light2_m = emissive;\n    light2_m.col = Light2_color;\n    Material light3_m = emissive;\n    light3_m.col = Light3_color;\n    Light light1 = Light(Sphere(Light1_pos, Light1_radius, light1_m), Light1_int);\n    Light light2 = Light(Sphere(Light2_pos, Light2_radius, light2_m), Light2_int);\n    Light light3 = Light(Sphere(Light3_pos, Light3_radius, light3_m), Light3_int);\n    Light lights[3] = Light[3](light1, light2, light3);\n    float ang = 0.3;\n    mat2 rot = mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\n    scene.lights = lights;\n    scene.i = ico;\n    scene.cyl = Cylinder(vec3(0,0,0), 0.75, diffusive);\n\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randV.xy - 0.5) * 2.0)/iResolution.x;\n    vec3 front = normalize(vec3(-CAMERA_POS));\n    vec3 up = vec3(0,1,0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    vec3 viewVec = normalize(front + right * uv.x + up* uv.y);\n    \n    vec3 curPos = CAMERA_POS;\n    vec3 curDir = viewVec;\n    float n1 = AIR_N;\n    float n2 = AIR_N;\n    vec3 col = vec3(0);\n    \n    \n    for (int j = 0; j < 10; j++) {\n        float t = INF;\n        bool intersect;\n        vec3 N;\n        vec3 tmpN;\n        \n        Material material;\n        \n        \n        for (int i = 0; i < lights.length(); i++) {\n            float lightT = traceSphere(curPos, curDir, lights[i].sphere, tmpN);\n            if (lightT < t) {\n                t = lightT;\n                N = tmpN;\n                material = lights[i].sphere.m;\n            }\n        }\n        \n        Material tmpM;\n        float sceneT = traceScene(curPos, curDir, tmpN, tmpM);\n        if (sceneT < t) {\n            t = sceneT;\n            N = tmpN;\n            material = tmpM;\n        }\n        \n        vec3 worldPos = t * curDir + curPos;\n        float planeT = tracePlane(curPos, curDir, tmpN);\n        if (planeT < t) {\n            t = planeT;\n            N = tmpN;\n            worldPos = t * curDir + curPos;\n            material = diffusive;\n            material.col = texture(iChannel0, worldPos.xz * 0.1).rgb;\n        }\n        \n        bool isEmissive = material.emission > 0.0;\n        bool isDiffusive = material.diffusion > 0.0;\n        bool isReflective = material.reflection > 0.0;\n        bool isRefractive = material.refraction > 0.0;\n        if (isReflective) {\n            n1 = n2;\n            n2 = material.n;\n        }\n        float R = powf((n1-n2)/(n1+n2), 2);\n        bool reflAndRefr = isReflective && isRefractive;\n        isReflective = (reflAndRefr && randV.x * 0.2 < R) || (!reflAndRefr && isReflective);\n        isRefractive = (reflAndRefr && !isReflective) || (!reflAndRefr && isRefractive);\n        \n        if (isEmissive) {\n            col +=  material.col * material.emission * k;\n        }\n        if (isDiffusive) {\n            col += computeLight(worldPos, curDir, N, material) * material.diffusion * k;\n        }\n        if (isReflective) {\n            curDir = reflect(curDir,N);\n            curPos = worldPos + curDir * 1e-3;\n        }\n        vec3 blue_tint = vec3(0.3, 0.3, 0.5);\n         if (isRefractive) {\n            curDir = refraction(curDir, N, n1, n2);\n            curPos = worldPos + curDir / INF;\n            if (b == false) {\n                float mult = 2.0;\n                    vec4 fog = InFire(curPos, curDir, 2.8);\n                    col += fog.rgb * fog.a * mult;\n                    fog = InFire(curPos, curDir, 1.4);\n                    col += fog.rgb * fog.a * mult;\n                    mult *= 1.0 + fog.a;\n                    \n                    float tmp = n1;\n                    n1 = n2;\n                    n2 = tmp;\n                    b = true;\n            }\n        }\n\n        if (t == INF) {\n            col += k * 2.0 * texture(iChannel1, curDir).rgb * blue_tint;\n        }\n    }\n        \n    fragColor = vec4(col, 1.0);  \n}","name":"Buffer A","description":"","type":"buffer"}]}