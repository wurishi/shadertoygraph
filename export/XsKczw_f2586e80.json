{"ver":"0.1","info":{"id":"XsKczw","date":"1521534939","viewed":194,"name":"Moebius thingy","username":"Ultraviolet","description":"My go at the classical Moebius / torus  mutant.\nClick to select the number of sides and of twists.\nPress space to visualise strands.","likes":13,"published":1,"flags":16,"usePreview":0,"tags":["triangle","illusion","penrose"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Penrose Triangle II\" by Ultraviolet. https://shadertoy.com/view/XdccDX\n// 2018-03-19 15:09:36\n\n\n#define PI\t\t\t\t3.1415926535\n#define LIGHT_DIR\t\tnormalize(vec3(1., 2., 1.5))\n\n//#define CAM_PARAM\t\tsmoothstep( 0., 1., max(mod(iTime*.2, 1.)-.8, 0.)*5.)\n//#define CAM_PARAM\t\t(iTime*.3)\n#define CAM_PARAM\t\t0.\n#define CAM_POS \t\tvec3(2./sqrt(2.)*1.5*cos(CAM_PARAM*2.*PI+PI*.25), 1.5, 2./sqrt(2.)*1.5*sin(CAM_PARAM*2.*PI+PI*.25))\n\n#define WIDTH\t.1\n#define SIZE\t1.25\n\n#define CAM_CTRL\tfalse\n\n#define NB_SIDES\t4.\n#define NB_LOOPS\t.5\n\n#define AA\t\t2.\n\n\nfloat polyDist(vec2 p, float n, float rad, out vec2 norm, out float mat)\n{    \n    float alpha = atan(p.y, p.x)*.5/PI+.5;\n    float alpha0 = (floor(alpha*n)/n-.5)*2.*PI;\n    float alpha1 = (ceil(alpha*n)/n-.5)*2.*PI;\n    \n    vec2 p0 = rad*vec2(cos(alpha0), sin(alpha0));\n    vec2 p1 = rad*vec2(cos(alpha1), sin(alpha1));\n    \n\tvec2 pa = p-p0, ba = p1-p0;\n    norm = normalize(ba.yx)*vec2(-1., 1.);\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h )*sign(dot(pa, norm));\n    \n    mat = alpha0/PI*.5+.5;\n    \n    if(texelFetch(iChannel0, ivec2(32, 2), 0).x < .5)\n    \treturn -d;\n    \n    vec2 pp = rad*vec2(cos((alpha0+alpha1)*.5), sin((alpha0+alpha1)*.5));\n    norm = -normalize(p-pp);\n    return length(p-pp)-0.03;\n}\n\n\n\nvec2 sdBeam(vec3 p, out vec3 n)\n{\n    vec3 p_circle = normalize(p*vec3(1., 0., 1.));\n    vec3 dif = p-p_circle;\n    \n    n = normalize(dif);\n    float d = length(dif)-.2;\n    \n    vec3 X = normalize(p_circle);\n    vec3 Y = vec3(0., 1., 0.);\n    vec3 Z = cross(X, Y);\n    \n    float nb_side = 1.+ceil(0.01+iMouse.x/iResolution.x*7.);\n    float nb_loops = round(2.*iMouse.y/iResolution.y*nb_side)/nb_side;\n    \n    if(CAM_CTRL)\n    {\n        nb_side  = NB_SIDES;\n        nb_loops = NB_LOOPS;\n    }\n    else if(length(iMouse.xy)<1.)\n    {\n        nb_side  = 4.;\n        nb_loops = 3./4.;\n    }\n    \n    float alpha = atan(p_circle.z, p_circle.x)*nb_loops+iTime*.3;\n    X = cos(alpha)*X+sin(alpha)*Y;\n    Y = cross(Z, X);\n    \n    vec2 norm2d;\n    float mat;\n    d = polyDist(vec2(dot(dif, X), dot(dif, Y)), nb_side, .2, norm2d, mat);\n    \n    n = -norm2d.x*X-norm2d.y*Y;\n    \n    if(nb_loops*nb_side > .5)\n      mat += (alpha/nb_loops/PI*.5+.5)*nb_loops;\n    \n    return vec2(d, mat);\n}\n\n\nvec2 map(vec3 p, out vec3 n )\n{\n    vec2 res = vec2( 1000., 1.0 );\n        \n    res = sdBeam(p,  n);\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, out vec3 n )\n{\n    float tmin = 0.1;\n    float tmax = 20.0;\n   \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<64; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    vec2 res = map( ro+rd*t, n );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x*.75;\n        //t += 0.05;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    \n    return vec2( t, m );\n}\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 colorMap(float t)\n{\n    return hsv2rgb(vec3(t, 1., 1.));\n}\n\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 col = .6+.4*vec3(pow(max(0., dot(rd, LIGHT_DIR)), 2.));\n    \n    vec3 nor;\n    vec2 res = castRay(ro,rd, nor);\n    if( res.y>-0.5 )\n    {\n        col = colorMap(res.y);\n        //col = vec3(1.);\n        col = (.1+.9*max(0., dot(nor, LIGHT_DIR))) * (.2+.8*col);\n        \n        //col = nor;\n    }\n    \n    return col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n    //*\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\t/*/\n    vec3 cv = normalize(cp - dot(cp, cw)*cw);\n    vec3 cu = vec3(1., 0.,0.);\n    cu = normalize(cu-dot(cu, cv)*cv-dot(cu, cw)*cw);\n    cu *= -determinant(mat3( cu, cv, cw ));\n    //*/\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/ iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n        \n    // ray computation\n    vec3 ro = vec3(0.,1.,0.) + 2.*vec3(cos(mo.x*PI*2.)*cos(mo.y*.5*PI), sin(mo.y*.5*PI), sin(mo.x*PI*2.)*cos(mo.y*.5*PI));\n    if(!CAM_CTRL)\n        ro = CAM_POS;\n    \n    vec3 ta = vec3(0.);\n    mat3 m = setCamera(ro, ta, 0.0);\n    vec3 rd = m*normalize(vec3(p, 2.));\n    \n    ro = ro + m[0]*p.x + m[1]*p.y;\n    rd = m[2];\n    \n    // scene rendering (using oversampling)\n    vec3 col;\n    \n    \n    for(float ii=0.; ii<AA; ii+=1.)\n    for(float jj=0.; jj<AA; jj+=1.)\n    {\n    \tcol += render( ro, rd+(m[0]*ii+m[1]*jj)/AA/iResolution.y/2.);\n    }\n    col /= AA*AA;\n    \n    // gamma correction\n    col = sqrt(col);\n    \n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}