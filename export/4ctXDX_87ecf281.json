{"ver":"0.1","info":{"id":"4ctXDX","date":"1714624631","viewed":95,"name":"A Simple Raytraced Planet","username":"Ruzzyr","description":"A raytraced planet. Nothing out of the ordinary. A result of a couple of hours of personal exploration.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","simple","sphere","planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// a very simple raytracing example.\n#define PI 3.1415926\nvec2 rotateUv(in vec2 uv, float angle)\n{\n    return vec2(uv.x*cos(angle) - uv.y*sin(angle), uv.x*sin(angle) +uv.y*cos(angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy-0.5)*2.;\n    uv.x *= iResolution.x/iResolution.y;\n    // Time varying pixel color\n    vec3 cameraPosition = vec3( 0., 0., 3.);\n    vec3 cameraDirection = normalize(vec3(uv, -2.));\n    vec3 spherePosition = vec3(0., 0., 0.);\n    float sphereRadius = 1.;\n    \n    float distanceToRay = length(cross(cameraDirection, spherePosition - cameraPosition));\n    float t = 10000.;\n    vec3 normal = vec3(0.);\n    \n    // stars are in the background.\n    fragColor = vec4(vec3(length(texture(iChannel1, uv)) < 0.5)*0.5*(length(uv-0.1)), 1.);\n    \n    vec3 lightPosition = normalize(vec3(-2., 3., 3.));\n    \n    // making sure that the ray from the camera intersects with the sphere.\n    if (distanceToRay <= sphereRadius)\n    {\n        // solving a quadratic equation. \n        vec3 cameraSphereDelta = cameraPosition - spherePosition;\n        float a = dot(cameraDirection, cameraDirection);\n        float b = 2.*dot(cameraDirection, cameraSphereDelta);\n        float c = dot(cameraSphereDelta, cameraSphereDelta) - pow(sphereRadius, 2.);\n        float discriminant = pow(b, 2.) - 4.*a*c;\n        float t1 = (-b + sqrt(discriminant))/(2.*a);\n        float t2 = (-b - sqrt(discriminant))/(2.*a);\n        t = min(t1, t2);\n        \n        normal = normalize(t*cameraDirection + cameraPosition - spherePosition);\n        vec2 sphereUv = vec2(0.5 + atan(normal.z, normal.x)/(2.*PI), 0.5 +asin(normal.y)/PI)*4.;\n        float rotationAngle = 0.4;\n        \n        //add a fake rotation via uv\n        sphereUv += rotateUv(vec2(iTime*0.02, 0.), rotationAngle);\n        sphereUv = rotateUv(sphereUv, -rotationAngle);\n        // very simple lighting.\n        fragColor = vec4(vec3(max(0.,dot(lightPosition, normal))*texture(iChannel0, sphereUv) + 0.07*texture(iChannel0, sphereUv)), 1.0);\n    }\n    \n    // A normal of a ring. slightly under the angle to make it more scenic.\n    vec3 planeNormal = normalize(vec3(0.1, 1., 0.2));\n    \n    float tPlane = 10000.;\n    vec3 planePosition = spherePosition + vec3(0., 0.2, 0.);\n    \n    // ring.\n    // checking if there is an intersection and if there is, calculating the exact position.\n    if (dot(planeNormal, cameraDirection) < 0.)\n    {\n        tPlane = dot(planePosition-cameraPosition, planeNormal)/ dot(cameraDirection, planeNormal);\n        // addint a bit of a jitter based on screen coordinates to make the ring look less uniform.\n        vec3 intersectionPoint = tPlane * cameraDirection + cameraPosition -0.3*cameraDirection*texture(iChannel1, uv).x;\n        float distaceToPoint = length(intersectionPoint - planePosition);\n        \n        if (tPlane < t && (distaceToPoint > sphereRadius + 0.5 && distaceToPoint < sphereRadius + 0.9))\n        {\n            \n            vec2 planeUv = intersectionPoint.xz * 1. / (sphereRadius + 0.7) + vec2(iTime*0.02, 0.);\n            planeNormal += vec3( texture(iChannel1, planeUv+0.1).x, texture(iChannel1, planeUv).x, texture(iChannel1, planeUv-0.1).x);\n            planeNormal = normalize(planeNormal);\n            // attenuate the brightness of the ring based on the distance from camera.\n            fragColor.xyz += texture(iChannel2, planeUv).xyz*max(0.,dot(lightPosition, planeNormal)*2.)*1./pow(tPlane, 1.2);\n        }\n    }\n}","name":"Image","description":"","type":"image"}]}