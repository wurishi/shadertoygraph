{"ver":"0.1","info":{"id":"4dGSDw","date":"1464736866","viewed":237,"name":"LittleIsland","username":"kuvkar","description":"I was playing around with complex number rotation on distance fields and this thing popped out, gave it a littlebit of shade and color :) ","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","island"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\nvec3 lightDir = normalize(vec3(2.0, 1.0, -1.));\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nvec2 rotate(in vec2 pt, in vec2 b)\n{\n    float x = pt.x * b.x - pt.y * b.y;\n    float y = pt.x * b.y + pt.y * b.x;\n    return vec2(x, y);\n}\n\nfloat map(in vec3 rp)\n{\n    rp *= 2.;\n    \n    for (int i = 0; i < 5;++i)\n    {\t\n\t    rp.xz = abs(rp.xz) - 0.2;\n\t    rp.xy = rotate(rp.xy, (vec2(1., sin( rp.y  * 1.2) * .26) ));\n\t    rp.xz = rotate(rp.xz, (vec2(1., cos(rp.x) * sin(rp.y * 2.) * .7) ));\n        \n\t    rp.xz = abs(rp.xz) - 0.01;\n\t    rp.xz = rotate(rp.xz, (vec2(1., cos(rp.x * .1) * sin( rp.y  * 1.1) * .8) ));\n        rp.xz += .32;\n    }\n    return sdBox(rp, vec3(1.8, 2.3, 1.8));\n}\n\nvec3 grad(in vec3 rp)\n{\n    vec2 off = vec2(0.005, 0.0);\n    vec3 g = vec3(map(rp + off.xyy) - map(rp - off.xyy),\n                  map(rp + off.yxy) - map(rp - off.yxy),\n                  map(rp + off.yyx) - map(rp - off.yyx));\n    return normalize(g);\n}\n\nvec3 waterBump(in vec3 rp)\n{\n\tvec2 uv = rp.xz * .5;\n    vec2 _uv = vec2(atan(uv.y / uv.x), length(uv) + sin(iTime * 0.4) * 0.1);\n    \n    vec2 off = vec2(0.01, 0.0);\n    \n    float c = texture(iChannel0, _uv).r * 0.75;\n    float r = texture(iChannel0, _uv + off).r * 0.75;\n    float u = texture(iChannel0, _uv + off.yx).r * 0.75;\n    \n    _uv = vec2(atan(uv.y / uv.x), length(uv) + sin(iTime * 0.4) * 0.05);\n    c += texture(iChannel0, _uv * 2.0).r * 0.35;\n    r += texture(iChannel0, (_uv + off) * 2.0).r * 0.35;\n    u += texture(iChannel0, (_uv + off.yx) * 2.0).r * 0.35;\n    \n    float bump = 1.;\n\tvec3 rt = normalize(vec3(bump, c - r, 0.0));\n    vec3 fw = normalize(vec3(0.0, c - u, bump));\n    return normalize(cross(fw, rt));\n}\n\n\n\nvec3 fwd;\n\nvoid trace(in vec3 rp, in vec3 rd, inout vec4 color)\n{\n    \n    bool hit = false;\n    vec3 ro = rp;\n    \n    rp += rd * 1.0 / dot(fwd, rd);\n    \n    for (int i = 0; i < 550; ++i)\n    {\n        float dist = map(rp);\n        \n        if(dist < 0.0)\n        {\n            hit = true;\n            break;\n        }\n        rp += rd * max(dist, 0.02) * 0.025;\n        if(length(ro - rp) > 5.0) break;\n    }\n    \n    if(hit)\n    {\n        color = vec4(1.0);\n        vec3 g = grad(rp);\n        float specAmount = 0.0;\n        float specpow = 1.0;\n        \n        if(rp.y < -0.04) \n        {\n\t\t\tcolor = vec4(0.4, 0.3, 0.3, 0.0) * 0.1;\n        }\n        \n        else if (length(rp) > 0.55 && rp.y < 0.03) \n        {\n            \n\t\t\tcolor = vec4(0.1, 0.5, 1.0, 0.0);\n            g = waterBump(rp);\n            color += texture(iChannel1, reflect(rd, g)) * 1.6;\n            specAmount = 0.4;\n            specpow = 120.0;\n            \n        }else if(rp.y > 0.)\n        {\n            vec4 color1 = vec4(0., 0.2, 0.0, 0.0);\n            vec4 color2 = vec4(0.7, 0.3, .1, 0.0);\n            color = mix(color2, color1, smoothstep(0.1, 0.8, rp.y));\n            \n            vec4 groundcol = vec4(0.4, 0.2, 0.2, 0.0);\n            color = mix(color, groundcol, smoothstep(0.3, 0., rp.y));\n         \t\n            specAmount = 0.04;\n\t\t\tspecpow = 1.0;\n        }\n        \n        float d = dot(g, lightDir);\n        d = clamp(d, 0., 1.0);\n        float wrap = 0.2;\n        d = d + wrap / (1.0 + wrap);\n        color *= d;\n        \n        vec3 H = normalize(-rd + vec3(0.0, 1.0, 1.0));\n        float spcd = clamp(dot(H, g), .0, 1.);\n        spcd = pow(spcd, specpow) * specAmount;\n        color += vec4(spcd);\n        \n    }\n    \n    color.rgb = pow(color.rgb, vec3(1.0 / 2.2));\n    \n}\n\nmat3 lookat(vec3 from, vec3 to)\n{\n    vec3 f = normalize(to - from);\n    vec3 _tmpr = normalize(cross(f, vec3(0.0, 1.0, 0.0)));\n    vec3 u = normalize(cross(_tmpr, f));\n    vec3 r = normalize(cross(u, f));\n    return mat3(r, u, f);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(1.0, iResolution.y / iResolution.x) * ((fragCoord.xy / iResolution.xy) - 0.5);\n    vec2 im = vec2(10.0, 3.0) * (-0.5 + (iMouse.xy / iResolution.xy));\n\n    fragColor = ((uv.y - 0.1) * .7) + vec4(0.2, 0.3, 0.35, 0.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 rp = vec3(0.0, 3., -2.);\n    vec3 _rp = rp;\n    rp = roty(im.x) * rp;\n    \n    if(iMouse.z <= 0.0)\n    {\n        rp.x += sin(iTime * 0.1);\n        rp.z += sin(iTime) * 0.1;\n    }\n    \n    rp.y = (rotx(im.y) * _rp).y;\n    rd = lookat(rp, vec3(0.0)) * rd;\n    fwd = lookat(rp, vec3(0.0)) * vec3(0.0, 0.0, 1.0);\n    trace(rp, rd, fragColor);\n}","name":"Image","description":"","type":"image"}]}