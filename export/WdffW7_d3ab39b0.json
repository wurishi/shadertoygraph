{"ver":"0.1","info":{"id":"WdffW7","date":"1588330503","viewed":201,"name":"heightmap version mandelbrot","username":"henry","description":"attempt to view mandel as a heightmap, can definitely see the babymandels springing up and down. had a go with IQ's smoother code, also a bit aliased: https://www.shadertoy.com/view/3dXBD7","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fractspheres"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"fract_spheres\" by foran. https://shadertoy.com/view/wljSzR\n// 2020-05-01 10:27:11\n\n\n\n\n#ifdef GL_ES\nprecision mediump float;\nconst vec3 df = vec3(0.05, 0.0, 0.0);\n#else\nconst vec3 df = vec3(0.01, 0.0, 0.0);\n#endif\n\n#define AUTO_CAMERA\n\n// input\n\n// Constants\n// Camera\nconst vec3 origin = vec3(0, 0, 0);\nconst int steps = 64;\nconst vec3 sun = vec3(1.0, .5, -1.0);\n\nconst int miterations = 32;\n\n// Ball\nstruct Ball \n{\n\tvec3 pos;\n\tfloat size;\n};\n\nconst Ball ball = Ball(vec3(10, 10, -10.), 0.0002);\n\nstruct Balls\n{\n\tvec3 dir;\n\tvec3 p;\n\tfloat dist;\n};\n\t\nconst Balls balls = Balls(vec3(1, 0, 0), vec3(0, 0, 0), 2.0);\n\n// Floor\n\nstruct Plane \n{\n\tvec3 n;\n\tfloat d;\n};\n\t\nconst Plane plane = Plane(vec3(0, 1, 0), -1.0);\n\n// Distance\nstruct Dist\n{\n\tfloat dist;\n\tint id;\n};\n\n\t\nDist and(Dist a, Dist b)\n{\n\tif (a.dist < b.dist) \n\t{\n\t\treturn a;\n\t}\n\t\n\treturn b;\n}\n\nDist fBall(Ball ball, vec3 p) \n{\n\treturn Dist(length(ball.pos - p) - ball.size, 0);\n}\n\nBall get(Balls balls, float t) \n{\n\tfloat a = abs(mod(t, 3.0) - 1.0);\n\tvec3 p = balls.p + balls.dir * t * balls.dist + a * a * vec3(0, -0.15, 0);\n\treturn Ball(p, ball.size);\n}\n\nDist fBalls(Balls balls, vec3 p) \n{\n\tfloat t = dot(p - balls.p, balls.dir) / balls.dist;\n\tfloat t0 = t - fract(t + fract(iTime) * 1.0);\n\tfloat t1 = t0 + 1.0;\n\n\treturn and(\n\t\tfBall(get(balls, t0), p),\n\t\tfBall(get(balls, t1), p));\n}\n\nfloat mandel(vec2 c)\n{\n\tvec2 z = c;\n\n\tfor(int i = 0; i < miterations; ++i)\n\t{\n\t\tz = vec2(z.x*z.x - z.y*z.y, 1.5*z.x*z.y) + c;\n\t\tif (length(z) > 40.0) return float(i) / float(miterations);\n\t}\n\t\n\treturn 0.0;\n}\n\nDist fPlane(Plane plane, vec3 p)\n{\n\treturn Dist(dot(plane.n, p) - plane.d +sign(sin(iTime)) *mandel(p.xz), 1);\n}\n\nDist f(vec3 p) \n{\n\treturn and(\n\t\tfBalls(balls, p),\n\t\tfPlane(plane, p));\n}\n\nvec3 grad(vec3 p) \n{\n\tfloat f0 = f(p).dist;\n\n\treturn normalize(vec3(\n\t\tf(p + df.xyz).dist,\n\t\tf(p + df.yxz).dist,\n\t\tf(p + df.yzx).dist) - f0);\n}\n\n\n\nvec3 floorTexture(vec3 p) \n{\n\tmat2 rot = mat2(vec2(1, 1), vec2(1, -1));\n\tvec2 c = 1. * (p.xz + vec2(0,0)) * 1.;\n\tfloat i = mandel(c);\n\treturn clamp(vec3(i * 10.0, i * i *10.0, i*i*i*5.0).zyx, vec3(0,0,0), vec3(2,2,2));\n}\n\n\nvec4 shade(vec3 p, vec3 ray, int id) \n{\n\tvec3 n = grad(p);\n\tfloat diffuse = clamp(dot(normalize(sun), n), 0.0, 1.0);\n\n\tvec3 color;\n\tfloat ref;\n\n\tif (id == 0) \n\t{\n\t\tcolor = vec3(0,1,0);\n\t\tref = 0.1;\n\t} \n\telse \n\t{\n\t\tcolor = floorTexture(p);\n\t\tref = 0.5;\n\t}\n\n\treturn vec4(color * diffuse*2.5, 1) * ref;\n}\n\nvec4 combine(vec4 a, vec4 b) \n{\n\treturn a + b * (1.0 - a.w); \n}\n\nvec4 sky(vec3 ray) \n{\n\tfloat sun = dot(ray, normalize(sun));\n\tsun = (sun > 0.0) ? pow(sun, 150.0) * 3.0 : 0.0;\n\tfloat horizon = 1.0 - abs(ray.y);\n\tvec3 blue = vec3(0.1, 0.3, 0.6);\n\tvec3 red = vec3(0.6, 0.3, 0.) * 2.0;\n\treturn vec4(vec3(0.9, 0.8, 0.5) * sun + blue * horizon + red * pow(horizon, 8.0), 1);\n}\n\nvec4 trace(vec3 origin, vec3 ray) \n{\n\tvec3 p = origin;\n\tDist dist = Dist(10.0, 2);\n\tvec4 result = vec4(0, 0, 0, 0);\n\n\tfor(int i = 0; i < steps; ++i) \n\t{\n\t\tdist = f(p);\n\t\tif (dist.dist > 0.01) \n\t\t{ \n\t\t\tp += ray * dist.dist;\n\t\t\tfloat absorb = exp(-dist.dist * 0.05);\n\t\t\tvec4 s = sky(ray) * (1.0 - absorb);\n\t\t\t\n\t\t\tresult = combine(result, s);\n\t\t}\n\t\telse if (result.w < 0.99) \n\t\t{\n\t\t\tvec3 n = grad(p);\n\t\t\tvec4 s = shade(p, ray, dist.id);\n\t\t\tray = reflect(ray, n);\n\t\t\tp += n * 0.01;\n\t\t\t\n\t\t\tresult = combine(result, s);\n\t\t} \n\t\telse \n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn combine(result, sky(ray));\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tfloat scale = 1.0 / max(iResolution.x, iResolution.y);\n\tvec3 ray = vec3((fragCoord.xy - iResolution.xy / 2.0) * scale, 1);\n\n//#ifdef AUTO_CAMERA\n\tfloat yaw = cos(iTime*0.001) * -0.25 + 0.5;\n\tfloat angle = iTime * 0.05;\n//#else\n\t//float yaw = iMouse.y - 0.15;\n\t//float angle = iMouse.x * 8.0;\n//#endif\n\t\n\tvec3 from = (vec3(sin(angle), 0, cos(angle)) * cos(yaw) + vec3(0, sin(yaw) * 1.0, 0)) * 5.0; \n\t//vec3 from = origin + vec3((iMouse.xy - vec2(0.5,0.0)) * vec2(15.0, 3.0), -5);\n\tvec3 to = vec3(0, -1, 0);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 dir = normalize(to - from);\n\tvec3 left = normalize(cross(up, dir));\n\tmat3 rot = mat3(left, cross(dir, left), dir);\n\n\tfragColor = trace(from, rot * normalize(ray));\n}","name":"Image","description":"","type":"image"}]}