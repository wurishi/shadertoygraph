{"ver":"0.1","info":{"id":"ttVfWm","date":"1614512334","viewed":201,"name":"folding (paper)","username":"sukupaper","description":"\"Minimalist\" aesthetic is quite interesting ðŸ¤”","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","folding","paper","minimalist","redandwhite"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: paperu\n// Title: folding\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\n#define PRC .0001\n#define MAX_D 10.\n#define MAX_IT 20\n\n#define P 3.14159265359\n\nmat2 rotv, rotv2;\n\nfloat rand(in vec2 st){ return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.585); }\n\n\nmat2 rot(in float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat rcub(in vec2 p, in float s, in float r) { return length(max(abs(p) - s, 0.)) - r; }\nfloat cub(in vec2 p, in float s) { p = abs(p); return max(p.x,p.y) - s; }\nfloat anim1(in float x, in float s) { x += .5; return smoothstep(-s,s,mod(x, 1.) - .5) + floor(x); }\nfloat df(in vec3 p) {\n    p.yz *= rotv2;\n    float d = 10e9;\n    const float maxI = 10.;\n    for(float i = 1.; i <= maxI; i++) {\n    \tp.xz *= rotv;\n        p.x = abs(p.x);\n    \tp.xy *= rotv;\n        p.y = abs(p.y);\n    \tp.xy *= rot(P/8.);\n        d = min(d,cub(vec2(rcub(p.xy, .2 - i/maxI*.15, 0.), p.z), .0001));\n    }\n    return d;\n}\n\nvec3 normal(in vec3 p) { vec2 u = vec2(0., PRC); float d = df(p); return normalize(vec3(df(p + u.yxx), df(p + u.xyx), df(p + u.xxy)) - d); }\n\nstruct rmres { vec3 p; bool h; int i; };\nrmres rm(in vec3 c, in vec3 r) {\n    rmres res;\n    res.h = false;\n    res.p = c;\n    for(int i = 0; i < MAX_IT; i++) {\n        float d = df(res.p);\n        if(d < PRC) { res.h = true; res.i = i; break; }\n        if(distance(c, res.p) > MAX_D) { res.i = i; break; }\n        res.p += r*d;\n    }\n    return res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = (fragCoord.xy - .5*iResolution.xy)/iResolution.y;\n    vec2 m = (iMouse.xy/iResolution.xy) - .5;\n\n    st -= m*.05;\n    \n    if(abs(cub(st,.49) + .02) - .01 < 0.) {\n        fragColor = vec4(vec3(1.), 1.);\n    } else {\n        float t = iTime*.5 + length(st*.5) + rand(floor(st*100.))*.15;\n        float tt = iTime;\n        \n    \trotv = rot(P*anim1(t,.3)/3.);\n        rotv2 = rot(P*anim1(t*.5,.1)/12.);\n        \n        st += m*.1;\n\n        rmres res = rm(vec3(st*.6,-5.), normalize(vec3(0.,0.,1.)));\n\n        vec3 color = res.h ? vec3(1.) : vec3(0.900,0.247,0.325);\n\n        fragColor = vec4(color, 1.);\n    }\n}","name":"Image","description":"","type":"image"}]}