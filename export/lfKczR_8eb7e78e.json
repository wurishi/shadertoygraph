{"ver":"0.1","info":{"id":"lfKczR","date":"1731436851","viewed":84,"name":"SDF_Hotdog","username":"kosalos","description":"SDF with depth","likes":1,"published":3,"flags":32,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 uv;\n\nfloat ptLineDistance(vec2 pt,vec2 lineP1,vec2 lineP2) {\n    vec2 ab = lineP2-lineP1;\n    vec2 be = pt-lineP2;     \n    if(dot(ab,be) > 0.) return length(be);\n\n    vec2 ae = pt-lineP1;\n    if(dot(ab,ae) < 0.) return length(ae); \n    return abs(ab.x * ae.y - ab.y * ae.x) / length(ab);\n}\n\nvoid drawLine(vec2 p1,vec2 p2, float width, vec3 color,float depth,inout vec4 O) {\n    float d = ptLineDistance(uv,p1,p2);\n    if(d < width && depth < O.w) {\n        float w2 = width * sin(iTime);\n        float d2 = ptLineDistance(uv - vec2(-w2,w2),p1,p2);\n        O = vec4(color - vec3(d2 / (width * 2.)),depth);\n        \n        if(abs(d - width) < 0.002) O = vec4(0.,0.,0.,depth);\n    }\n}\n\n// --------------------------------------------------------------------\n\nvoid mainImage( out vec4 O,vec2 U) {\n    uv = U/iResolution.xy;\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    O = vec4(col,10.0);\n    \n    loadData(iChannel0);\n    \n    for(int i;i<QSIZE;i+=QWIDTH) {\n        float d = abs(sin(qDepth * 0.3));\n        float w = 0.1 + sin(iTime * 0.5) * d * 0.2;\n        drawLine(qPoint1,qPoint2,w,qColor,d,O);\n    }\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define qPoint1  q[i].xy\n#define qDelta1  q[i].zw\n#define qPoint2  q[i+1].xy\n#define qDelta2  q[i+1].zw\n#define qColor   q[i+2].xyz\n#define qDepth   q[i+2].w\n\nconst int QWIDTH = 3;\nconst int QCOUNT = 20;\nconst int QSIZE = QCOUNT * QWIDTH;\n\nvec4 q[QSIZE];\n\nvoid loadData(sampler2D channel) {\n    for(int i=0;i<QSIZE;++i) \n        q[i] = texelFetch(channel,ivec2(i,0),0);\n}\n\nvoid saveData(inout vec4 O,vec2 U) {\n    if(U.y < 1.) {\n        int x = int(U.x);\n        if(x < QSIZE) O = q[x];\n    }\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float VMIN = -0.4;\nconst float VMAX =  1.4;\n    \nvoid wrap(inout float value, inout float delta) {\n    value += delta;    \n    if(value < VMIN) { value = VMIN; delta = -delta; } else\n    if(value > VMAX) { value = VMAX; delta = -delta; }    \n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    if(U.x > float(QSIZE) || U.y > 1.0) return;\n    \n    if(iFrame < 2) {\n        float speed = 0.002;\n        \n        for(int i;i<QSIZE;i+=QWIDTH) {\n            float fi = float(i) * 0.01;\n            qPoint1 = vec2(0.1+fi,0.);\n            qDelta1 = vec2(speed + fi * 0.018,speed + fi * 0.012);\n            qPoint2 = vec2(0.3+fi,0.3+fi);\n            qDelta2 = vec2(speed + fi * 0.02,speed + fi * 0.01);\n            qColor = vec3(0.9 + fi,0.5,0.);\n            qDepth = fi;\n        }\n\n        saveData(O,U);\n        return;\n    }\n    \n    loadData(iChannel0);\n    \n    for(int i;i<QSIZE;i+=QWIDTH) {\n        wrap(qPoint1.x,qDelta1.x);\n        wrap(qPoint1.y,qDelta1.y);\n        wrap(qPoint2.x,qDelta2.x);\n        wrap(qPoint2.y,qDelta2.y);\n        qDepth += 0.001 + float(i) * 0.001;\n    }\n       \n    saveData(O,U);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}