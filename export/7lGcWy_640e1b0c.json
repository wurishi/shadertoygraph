{"ver":"0.1","info":{"id":"7lGcWy","date":"1662440522","viewed":63,"name":"hw3-texture","username":"wangxunstu","description":"homework level3","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["proceduraltexture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100   \n#define MAX_DIST 100.0  \n#define SURF_BIAS 0.01 \n\n\nfloat SphereSDF(vec3 p,vec4 sphere)\n{\n    return length(p-sphere.xyz)-sphere.w;\n}\n\nfloat CapsuleSDF(vec3 p,vec3 a,vec3 b,float r)\n{\n    vec3 ap = p-a;\n    vec3 ab = b-a;\n\n    float t = dot(ab,ap)/dot(ab,ab);\n    t = clamp(t,0.0,1.0);\n    vec3 c = a+t*ab;\n    \n    return length(p-c)-r;\n}\n\n\n\nfloat BoxSDF(vec3 ap,vec3 size)\n{\n    return length(max(abs(ap)-size,0.0));\n}\n\n\nfloat CylinderSDF(vec3 p,vec3 a,vec3 b,float r)\n{\n    vec3 ap = p-a;\n    vec3 ab = b-a;\n    \n    float t = dot(ap,ab)/dot(ab,ab);   \n    vec3 c = a+t*ab;\n    \n    float d = length(p-c)-r;\n    float y = abs(t-0.5)-0.5;\n    y *= length(ab);\n    \n    float dist = length(max(vec2(d,y),0.0));\n    \n    return dist+min(max(d,y),0.0);\n}\n\n\nfloat GetDist(vec3 p)\n{   \n    \n    vec4 sphere = vec4(-3,1,10,1);\n    \n\n    vec3 a = vec3(-1.0,2.0,10.0);\n    vec3 b = vec3(-3.0,0.5,10.0);\n    float t = 0.5;    \n    \n    \n    //盒子参数\n    vec3 a2 = vec3(3.0,1.0,10.0);//立方体中心坐标\n    vec3 a2p = a2-p;\n    \n    vec3 size = vec3(1);\n    \n    //圆柱体参数\n    vec3 a3 = vec3(6.0,2.0,10.0);\n    vec3 b3 = vec3(6.0,0.0,10.0);\n    float r3 = 0.5;\n    \n  \n    float sphereDist = SphereSDF(p,sphere);\n    float planeDist = p.y;\n    float capsuleDist = CapsuleSDF(p,a,b,t);\n\n    float boxDist = BoxSDF(a2p,size);\n    float cylinderDist = CylinderSDF(p,a3,b3,r3);\n    \n  \n    float d = min(sphereDist,planeDist);\n    d = min(d,capsuleDist);\n\n    d = min(d,boxDist);\n    d = min(d,cylinderDist);\n    \n    return d;\n}\n\nfloat RayMarching(vec3 ro,vec3 rd)\n{\n    float d0 = 0.0;\n    \n    for(int i=0;i<MAX_STEPS;i++)\n    {\n        vec3 p = ro+rd*d0;\n        float ds = GetDist(p);\n        d0 += ds;\n        if(d0>MAX_DIST || ds<SURF_BIAS) break;\n    }\n    \n    return d0;\n}\n\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(0.0001,0);\n    \n    vec3 normal = d-vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx)\n    );\n    \n    return normalize(normal);\n}\n\nvec3 GetColor(vec3 p,vec3 ro)\n{\n    vec3 lightPos = vec3(3,5,5);\n    vec3 lightCol = vec3(1.0);\n\n    vec3 lightDir = normalize(lightPos-p);\n    vec3 normal = GetNormal(p);\n    \n\n    float dif = clamp(dot(lightDir,normal),0.0,1.0);\n    vec3 diffuse = lightCol*dif;\n    \n    p += normal*SURF_BIAS*2.0;\n    float d = RayMarching(p,lightDir);\n    if(d<length(lightPos-p)) return vec3(0.001);\n    \n    if(length(p)>100.0)\n        return vec3(0.0);    \n    \n    float c = p.x + p.y;\n    if(int(c)%2 == 0)\n        return vec3(1,1,0)*dif;\n    else \n        return vec3(1,0,0)*dif;\n    \n    return diffuse;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n  \n    vec3 col = vec3(0.0);\n    \n    float time = iTime;\n    \n    vec3 ro = vec3(0.0,3.0,1.0);\n\n    vec3 rd = normalize(vec3(uv.x,uv.y,1.0));\n    \n    float d = RayMarching(ro,rd);\n    vec3 p = ro+rd*d;\n    \n    col = GetColor(p,ro);    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}