{"ver":"0.1","info":{"id":"ttSyR3","date":"1595088831","viewed":1159,"name":"Cube Fall","username":"shau","description":"quick sketch, rendering some cubes using partitioned space marching from Nimitz","likes":54,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n/**\n * Loosley inspired by GIF animation on Pouet\n * and Sparse grid marching by Nimitz\n **/\n\n#define R iResolution.xy\n#define ZERO (min(iFrame,0))\n#define EPS .005\n#define FAR 140.\n#define T iTime\n#define TORUS vec2(40.0,18.0)\n\n//Fabrice - compact rotation\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//Nimitz\n//https://www.shadertoy.com/view/XlfGDs\nconst float c = 1.0;\nconst float ch = c * 0.5;\nconst float ch2 = ch + 0.01;\nfloat dBox(vec3 ro, vec3 rd)  \n{\n    vec3 m = 1. / rd;\n    vec3 t = -m * ro + abs(m) * ch2;\n\treturn min(min(t.x, t.y), t.z);\n}\n\n//Shane - Perspex Web Lattice - one of my favourite shaders\n//https://www.shadertoy.com/view/Mld3Rn\n//Standard hue rotation formula... compacted down a bit.\nvec3 rotHue(vec3 p, float a)\n{\n    vec2 cs = sin(vec2(1.570796,0) + a);\n\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n        \t  mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n        \t  mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n\t\t\t\t\t\t\t \n    return clamp(p*hr,0.,1.);\n}\n\n//Dave Hoskins - Hash without sin\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//SDF functions IQ\nfloat sdTorus(vec3 p, vec2 t) \n{\n    vec2 q = vec2(length(p.yz) - t.x, p.x);\n    return length(q) - t.y;\n}\n\nfloat sdBox(vec3 p, vec3 b) \n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat boxedTorus(vec3 p, vec3 rd)\n{\n    float AT = T*0.4;\n    vec3 q = p;\n    q.yz *= rot(AT);\n    rd.yz *= rot(AT);\n    vec3 qd = fract(q/c)*c -ch;\n    vec3 qid = floor(q/c) + 0.5;\n    vec2 h2 = hash23(qid);\n    float t = dBox(qd, rd); //Base distance is cell exit distance\n    if (sdTorus(floor(q/c)+.5,TORUS) < 0. && p.y < 0.)\n    {\n        qd.yz *= rot(h2.y + h2.x*T);\n        qd.zx *= rot(h2.x + h2.y*T);\n        t = min(t, sdBox(qd, vec3(0.3)));    \n    }\n    return t;\n}\n\nfloat boxedWall(vec3 p, vec3 rd)\n{\n    float AT = T*0.4;\n    p.y += AT * 25.;\n    vec3 qd = fract(p/c)*c -ch;\n    vec3 qid = floor(p/c);\n    vec2 h2 = hash23(qid);\n    float t = dBox(qd, rd); //Base distance is cell exit distance\n    if (p.z > (TORUS.x - TORUS.y))\n    {\n        qd.yz *= rot(h2.y + h2.x*T);\n        qd.zx *= rot(h2.x + h2.y*T);\n        t = min(t, sdBox(qd, vec3(0.3)));    \n    }\n    return t;\n}\n\nfloat map(vec3 p, vec3 rd) \n{    \n    return min(boxedTorus(p, rd), boxedWall(p, rd));\n}\n\nvec3 normal(vec3 p, vec3 rd) \n{  \n    vec4 n = vec4(0.0);\n    for (int i=ZERO; i<4; i++) \n    {\n        vec4 s = vec4(p, 0.0);\n        s[i] += EPS;\n        n[i] = map(s.xyz, rd);\n    }\n    return normalize(n.xyz-n.w);\n}\n\nvec4 render(vec3 ro, vec3 rd)\n{\n    vec3 pc = vec3(0),\n         lp = vec3(-10,8,-8),\n        sc = rotHue(vec3(1,0.5,0.1), T*0.3);\n\n    float t = 0.0, mint = FAR;   \n    for (int i=0; i<360; i++)\n    {\n        float ns = map(ro + rd*t, rd);\n        if (ns<EPS)\n        {\n            break;\n        }\n        t += ns;\n        if (t>FAR) \n        {\n            t = -1.0;\n            break;\n        }\n    }\n    \n    if (t>0.0)\n    {\n        mint = t;\n        vec3 p = ro + rd*t;\n        vec3 n = normal(p,rd);\n        vec3 ld = normalize(lp - p);\n        float lt = length(lp - p); \n        float spec = pow(max(dot(reflect(-ld, n), -rd), 0.0), 32.0);\n        \n        pc += sc*0.4*max(0.05,dot(ld,n)) / (1. + lt*lt*0.02);\n        pc += sc*spec*2.;\n        pc += vec3(0.6,0.1,0.8)*0.01*max(0.,n.y);\n    }\n\n    pc *= exp(-0.06 * mint); \n    pc = pow(pc,vec3(.43545));\n    \n    return vec4(pc,mint);\n}\n\n//IQ\nmat3 camera(vec3 la, vec3 ro, float cr)\n{\n\tvec3 cw = normalize(la - ro),\n\t     cp = vec3(sin(cr),cos(cr),0.0),\n\t     cu = normalize(cross(cw,cp)),\n\t     cv =          (cross(cu,cw));\n    return mat3(cu,cv,cw); \n}\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n    float AT = T - 4.1;\n    vec3 pc = vec3(0),\n         la = vec3(0,-10,TORUS.x),\n         ro = vec3(sin(AT*0.2)*20.,\n                   -20.0,\n                   -5. + cos(AT*0.31)*3.);\n    ro.y -= ro.x*ro.x*0.02*sin(AT*0.3);\n    \n    float fl = 1.4;\n    mat3 cam = camera(la,ro,0.);  \n\n    vec2 uv = (2.0*(U) - R.xy)/R.y;\n    vec3 rd = cam*normalize(vec3(uv,fl));        \n    vec4 scene = render(ro,rd);\n    pc = scene.xyz;\n\n    pc = 1.15*pow(pc,vec3(0.9,0.95,1.0)) + vec3(-0.04,-0.04,0.0); //IQ\n    pc = pow(pc,vec3(0.80,0.85,0.9));\n    pc *= 1. / (1. + length(uv)*length(uv)*0.2);\n\n    C = vec4(pc*2.4,1.0);\n}","name":"Image","description":"","type":"image"}]}