{"ver":"0.1","info":{"id":"Xdsczr","date":"1486757528","viewed":235,"name":"Playing around with circles","username":"kodde","description":"Was inspired by a cool gif with similar growing circles where odd/even areas are visualized as 1/0.","likes":3,"published":1,"flags":64,"usePreview":0,"tags":["circles","pattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"MlSGDc","filepath":"https://soundcloud.com/faders/faders-avalon-one","previewfilepath":"https://soundcloud.com/faders/faders-avalon-one","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SMOOTH_SHAPE_CONTOURS 1\n\n//Functions\nvec2 rotate2dVec(vec2 uv, float rotation)\n{\n    float cs = cos(rotation);\n\tfloat sn = sin(rotation);\n    \n    float px = uv.x * cs - uv.y * sn; \n\tfloat py = uv.x * sn + uv.y * cs;\n    \n    return vec2(px,py);\n}\n\nfloat drawSmoothCircle(vec2 uv, float distance, float rotation, float size, float smoothStepMin)\n{\n    vec2 circleCenter = rotate2dVec(uv,rotation) - vec2(0.0, distance);\n    float circleShape = 1.0 - smoothstep(smoothStepMin,1.0,length(circleCenter)*size);\n    \n    return circleShape;\n}\n\nfloat drawCircle(vec2 uv, float distance, float rotation, float size)\n{\n    vec2 circleCenter = rotate2dVec(uv,rotation) - vec2(0.0, distance);\n    float circleShape = 1.0 - min(floor(length(circleCenter)*size),1.0);\n    \n    return circleShape;\n}\n\n\nfloat smoothCheckIfOdd(float value)\n{\n    float result = abs(mod(value*0.5-0.5,1.0)-0.5)*2.0;\n    return result;\n}\n\n//This palette solution is from https://iquilezles.org/articles/palettes\nvec3 colorPalette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n\treturn a+b*cos(6.28318530718*(c*t+d));\n}\n\n\n//Constants\nfloat myTime;\nfloat pi = 3.14159265358979323846264338327950288419716;\nfloat numCircles;\nfloat sinTime;\nfloat circleSize;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    myTime = iTime * 2.0;\n    numCircles = (floor((myTime+pi) * 0.5 * (1.0/(2.0*pi)))*2.0)+3.0;\n    sinTime = (sin(myTime*0.5)+1.0)*0.35;\n    circleSize = 1.0/sinTime;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 centeredUv = uv - 0.5;\n    centeredUv.x *= iResolution.x/iResolution.y;\n    centeredUv = rotate2dVec(centeredUv,(sin(myTime)+myTime*1.5)*0.25);\n\n    float circlesResult;\n    float smoothStepMin = 1.0-0.002-circleSize*0.002;\n    \n    if(SMOOTH_SHAPE_CONTOURS==1)\n    {    \n        for(int i = 0; i < 48; i++)\n        {\n            if(i > int(numCircles))\n            {\n                break;\n            }\n            circlesResult += drawSmoothCircle(centeredUv, 0.45, ((pi*2.0)/min(numCircles+1.0,48.0))*float(i),circleSize, smoothStepMin);\n        }\n    }\n    else \n    {\n        for(int i = 0; i < 48; i++)\n        {\n            if(i > int(numCircles))\n            {\n                break;\n            }\n            circlesResult += drawCircle(centeredUv, 0.45, ((pi*2.0)/min(numCircles+1.0,48.0))*float(i),circleSize);\n        }\n    }\n    \n    circlesResult = smoothCheckIfOdd(circlesResult);\n\t\n    vec3 outColor = colorPalette(myTime*0.05 + length(centeredUv), vec3(0.5,0.5,0.5), vec3(0.5,0.5,0.5), vec3(1.0,1.0,1.0), vec3(0.0,0.33,0.67)) * circlesResult;\n    \n    fragColor = vec4(outColor,1.0);\n        \n}","name":"Image","description":"","type":"image"}]}