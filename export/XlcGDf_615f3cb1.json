{"ver":"0.1","info":{"id":"XlcGDf","date":"1472038287","viewed":490,"name":"chroma key test","username":"ZeBestNickname","description":"test shader for chroma keying","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["chromakey"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 rgbToYCrCb(vec4 rgb){\n    float y = 0.2989 * rgb.x + 0.5866 * rgb.y + 0.1145 * rgb.z;\n\tfloat cb = -0.1687 * rgb.x - 0.3313 * rgb.y + 0.5000 * rgb.z;\n\tfloat cr = 0.5000 * rgb.x - 0.4184 * rgb.y - 0.0816 * rgb.z;\n    \n    return vec4(y, cb, cr, rgb.w);\n}\n\nvec4 YCbCrToRGB(vec4 ycbcr){\n\tfloat r = ycbcr.x + 0.0000 * ycbcr.y + 1.4022 * ycbcr.z;\n\tfloat g = ycbcr.x - 0.3456 * ycbcr.y - 0.7145 * ycbcr.z;\n\tfloat b = ycbcr.x + 1.7710 * ycbcr.y + 0.0000 * ycbcr.z;\n    \n    return vec4(r, g, b, ycbcr.w);\n}\n\nconst float PI = 3.14159265;\n\nvec4 despill(vec4 col){\n    float avg = (col.z + col.x) / 2.0;\n    avg *= 1.1;\n    \n    vec4 despilled_col = col;\n    \n    if(col.y > avg){\n        float green_rat = 0.0;\n        \n        float fixed_avg = col.y;\n        float inc_rat = fixed_avg / avg;\n        despilled_col.x *= inc_rat;\n        despilled_col.z *= inc_rat;\n        \n        float diff = despilled_col.y - avg;\n        \n        despilled_col.y -= diff * green_rat;\n    }\n    \n    return despilled_col;\n}\n\nfloat rescale(float v, float minimum, float maximum, float new_max){\n\tfloat range = maximum - minimum;\n    float t = (v - minimum) / range;\n    \n    return t * new_max;\n}\n\nfloat dist(vec3 v1, vec3 v2){\n\tvec3 diff = v1 - v2;\n    return sqrt(dot(diff, diff));\n}\n\nvec4 primatte(vec4 fgcol, vec4 bgcol, vec4 keycol){\n    float sd1 = 0.5;\n    float sd2 = 0.7;\n    float sd3 = 0.9;\n    \n    float d = dist(fgcol.xyz, keycol.xyz);\n    \n    float kfg;\n    \n    if(d < sd1){\n    \tkfg = 0.0;\n    }\n    else if(d >= sd1 && d < sd2){\n    \tkfg = rescale(d, sd1, sd2, 1.0);\n        fgcol = despill(fgcol);\n    }\n    else if(d >= sd2){\n        if(d < sd3){\n        \tfgcol = despill(fgcol);\n        }\n        kfg = 1.0;\n    }\n    \n    float kbg = 1.0 - kfg;\n    \n\treturn kfg * fgcol + kbg * bgcol;\n}\n\nvec4 ultimatte(vec4 fgcol, vec4 bgcol){\n\tfloat dif = max(0.0, fgcol.y - max(fgcol.x, fgcol.z));\n    \n    float threshold = 0.15;\n    float cutoff = 0.3;\n    \n    float kfg;\n    \n    if(dif > cutoff){\n    \tkfg = 0.0;\n    }\n    else if(dif < cutoff && dif > threshold){\n    \tkfg = 1.0 - rescale(dif, threshold, cutoff, 1.0);\n    }\n    else{\n    \tkfg = 1.0;\n    }\n    \n    float kbg = 1.0 - kfg;\n    \n    return kfg * despill(fgcol) + kbg * bgcol;\n}\n\nvec4 hqck(vec4 fgcol, vec4 bgcol, vec4 keycol){\n\tvec4 keycol_yuv = rgbToYCrCb(keycol);\n    vec4 col_yuv = rgbToYCrCb(fgcol);\n    \n    float hypot = 2.0 * sqrt(dot(keycol_yuv.yz, keycol_yuv.yz));\n    float sin_k = 2.0 * keycol_yuv.y / hypot;\n    float cos_k = 2.0 * keycol_yuv.z / hypot;\n    \n    float x = 2.0 * col_yuv.y * cos_k + 2.0 * col_yuv.z * sin_k;\n    float z = 2.0 * col_yuv.z * cos_k - 2.0 * col_yuv.y * sin_k;\n    \n    float acceptance = PI / 3.0;\n    float suppression = PI / 6.0;\n    \n    float kfg = max(0.0, x - abs(z) / tan(acceptance / 2.0));\n    float suppress_mult = x - abs(z) / tan(suppression / 2.0) > 0.0 ? 0.0 : 1.0;\n    \n    vec4 new_col = col_yuv;\n    new_col.y = clamp(new_col.y - kfg * cos_k / 2.0 * suppress_mult, -0.5, 0.5);\n    new_col.z = clamp(new_col.z - kfg * sin_k / 2.0 * suppress_mult, -0.5, 0.5);\n    \n    float ys = keycol_yuv.x / (hypot / 2.0);\n    new_col.x -= ys * kfg;\n    \n    /*float luma_threshold = 0.3;\n    \n    if(col_yuv.x < luma_threshold){\n    \tkfg = 1.0;\n    }*/\n    \n    float kbg = 1.0 - kfg;\n    \n    //return vec4(kfg, kfg, kfg, 1);\n    \n    //return vec4(new_col.x - ys * kfg, new_col.x - ys * kfg, new_col.x - ys * kfg, 1);\n    \n    //return vec4(ys * kfg, ys * kfg, ys * kfg, 1);\n    \n    return YCbCrToRGB(new_col);\n    \n    return kfg * despill(fgcol) + kbg * bgcol;\n}\n\nvec4 chromaDistKey(vec4 fgcol, vec4 bgcol, vec4 keycol){\n    vec4 keycol_yuv = rgbToYCrCb(keycol);\n    vec4 col_yuv = rgbToYCrCb(fgcol);\n    \n    vec2 dif = col_yuv.yz - keycol_yuv.yz;\n    \n    float d = sqrt(dot(dif, dif));\n        \n    float threshold = 0.4;\n    float cutoff = 0.45;\n    \n    float kbg;\n    \n    if(d > cutoff){\n    \tkbg = 0.0;\n    }\n    else if(d < cutoff && d > threshold){\n    \tkbg = 1.0 - rescale(d, threshold, cutoff, 1.0);\n    }\n    else{\n    \tkbg = 1.0;\n    }\n    \n    float kfg = 1.0 - kbg;\n    \n    return kfg * despill(fgcol) + kbg * bgcol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec4 col = texture(iChannel0, uv);\n    int x_grid = int(iResolution.x) / 15;\n    int y_grid = int(iResolution.y) / 15;\n    \n    bool black = mod(fragCoord.x / 15.0, 2.0) < 1.0 == mod(fragCoord.y/ 15.0, 2.0) < 1.0;\n    vec4 bg_col = black ? vec4(0.3, 0.3, 0.3, 1) : vec4(0.95, 0.95, 0.95, 1);\n    \n    vec4 despilled_col = despill(col);\n\n    //vec4 key_col = rgbToYCrCb(vec4(0, 1, 0, 1));\n    vec4 key_col = rgbToYCrCb(vec4(0, 1, 0, 1));\n    vec4 converted_col = rgbToYCrCb(col);\n\n    float dp = clamp(dot(normalize(key_col.yz), normalize(converted_col.yz)), -1.0, 1.0);\n    \n    float d = acos(dp);\n    \n    float dmax = PI / 6.0;\n    float kfg_min = 0.2;\n    \n    float kfg = min(1.0, d / dmax);\n    \n    float luma_range = 0.25;\n    \n    if(converted_col.x < luma_range){\n    \tkfg = 1.0;\n    }\n    \n    kfg = kfg < kfg_min ? 0.0 : rescale(kfg, kfg_min, 1.0, 1.0);\n    \n    float kbg = 1.0 - kfg;\n    \n    //bg_col = vec4(0, 0, 0, 1);\n    \n    //fragColor = kfg * despilled_col +kbg * bg_col;\n    \n    //fragColor = primatte(col, bg_col, vec4(0, 1, 0, 1));\n    \n    //fragColor = col;\n    \n    //fragColor = vec4(kfg, kfg, kfg, 1);\n    \n    //fragColor = hqck(col, bg_col, vec4(0, 1, 0, 1));\n    \n    //fragColor = ultimatte(col, bg_col);\n    \n    fragColor = chromaDistKey(col, bg_col, vec4(0, 1, 0, 1));\n    \n    //fragColor = col;\n}","name":"Image","description":"","type":"image"}]}