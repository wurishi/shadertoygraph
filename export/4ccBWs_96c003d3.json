{"ver":"0.1","info":{"id":"4ccBWs","date":"1733600755","viewed":65,"name":"self name ","username":"nayk","description":"originals from  https://glslsandbox.com/e#65724.0","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["text","name","words","graffity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// custom font , Xavierseb 2019\n#define _ mat4( vec4(-1.3,-1.3,1.3,1.3), vec4(-1.), vec4(0.), vec4(-1.))\n#define UP mat4( vec4(0.), vec4(10.), vec4(0.), vec4(10.))\n#define A mat4( .75,-1.32,-1.44,.75,.77,1.95,-2.28,-.59,.75,1.05,.32,1.,-.59,1.82,.78,-1. )\n#define B mat4( -1.,.3,-1.66,-.8, .2,3.3,5.,-1., -1.,.6,2.,-.8, .2,2.6,-1.6,-1.)\n#define C mat4( .8,-.5,-2.1,.94, .8,1.8,-1.8,-.8, .7,-.5,-2.1,.94, .8,1.8,-1.8,-.8)\n#define D mat4( .64,-.8,-1.8,.74, .78,1.9,-1.7,-.86, .74,1.3,-.63,1., -.43,4.8,3.8,0.)\n#define E mat4( -.8,2.8,-.65,-.8, 0.,-.27,2.3,-.1, -.8,-.82,-.92,1., -.1,-.32,-1.2,-1.)\n#define F mat4( -.33,2.54,-.69,-.12,2.38,1.94,5.28,-.99, -.5,-.5,.5,.5,1.,1.,1.,1.)\n#define G mat4( .9,-.4,-2.3,.84, .34,2.4,-1.8,-.99, .9,1.,-1.,-.9, 0.,-4.7,-3.5,-2.9)\n#define H mat4( -1.,.9,-1.1,-.75, .43,4.5,3.4,-.5, -.75,-.24,.78,.94, -1.,3.7,-1.35,-1.)\n#define I mat4( 0.,-.14,-1.19,.64, .8,-.48,-1.07,-1., -.05,.43,-.34,.07, 2.88,2.71,2.67,2.86)\n#define J mat4( 0.,-.3,-1.,-.8, .5,-5.19,-1.7,-2.5, -.05,.43,-.34,.03, 2.88,2.71,2.67,2.96)\n#define K mat4( -.94,.58,-1.1,-.94, .6,4.35,3.6,-1.05, .4,-2.4,.3,.8, .8,0.,0.,-1.)\n#define L mat4( -.4,1.,.3,-.17, -.95,1.2,3.8,2.8, -.17,-.8,.38,.84, 2.8,1.8,-1.,-.95)\n#define M mat4( -.9,-.9,-.33,0., -1.,1.6,1.6,-.7, 0.,.33,.9,.9, -.7,1.6,1.6,-1.)\n#define N mat4( -1.07,-.64,-.9,-.76, .35,.93,.85,-1., -.75,-.9,.7,.94, -1.,.85,1.9,-1.)\n#define O mat4( 0.,-1.1,-1.1,0., 1.,.82,-.8,-1., 0.,1.1,1.1,0., -1.,-.8,.82,1.)\n#define P mat4( -1,-.43,-.58,-.73, .43,1.5,-1.9,-3., -.7,.83,1.75,-.7, .8,1.9,-1.75,-.8)\n#define Q mat4( .7,-.83,-1.75,0., .8,1.9,-1.75,-.8, .7,-.5,-.54,.93, .26,-2.7,-4.76,-2.5)\n#define R mat4( -.88,-.28,-.43,-.5, .86,1.5,-.67,-1., -.5,-.54,.22,.9, -1.,1.,1.,.8)\n#define S mat4( .78,-.7,-1.5,0., .88,1.34,.55,0., 0.,1.5,.67,-.9, 0.,-.55,-1.35,-.8)\n#define T mat4( -.55,.35,-1.37,.76, 3.,1.16,-1.1,-1., -1.,-.7,-1.4,.9, 1.64,1.54,1.7,1.7)\n#define U mat4( -.9,-1.1,1.,.72, .9,-1.6,-1.7,.9, .72,.7,1.,1.4, .9,-1.6,-1.,-.77)\n#define V mat4( -1.,-.83,-.236,0., .88,1.5,-.73,-1., 0.,1.55,-.25,1., -1.,1.8,.9,.65)\n#define W mat4( -.9,-1.2,-.33,0., .9,-1.6,-1.6,.7, 0.,.33,.9,.9, .7,-1.6,-1.6,.9)\n#define X mat4( .83,.25,-.3,-1., .95,.6,-.5,-1., -.9,.48,-.43,1., .87,.35,-.5,-1.)\n#define Y mat4( -.9,-.2,.9,.9, .9,-2.9,0.,.9, .9,-.37,-1.,-.9, .2,-4.7,-3.5,-2.9)\n#define Z mat4( -.9,1.1,1.3,0., .9,.9,1.5,0., 0.,-1.3,-1.1,.9, 0.,-1.5,-.9,-.9)\n#define LV mat4( 0.,-.45,-2.,0., .58,1.4,1.,-1., 0.,2.,.45,0., -1.,1.,1.4,.58)\n#define QU mat4( -.66,2.7,-.3,-.05, 2.9,3.3,1.6,.58, -.05,.43,-.34,.03, -.42,-.59,-.63,-.44)\n#define ST mat4( -.3,1.1,2.,-1.,1.,-1.13,-.27,0., -1.,1.87,1.21,-.3,0.,.96,2.03,-1.)\n#define NN mat4(0)\n#define _G mat4( vec4(-1,-1,1.75,1.75), vec4(-1), vec4(-1,-1,1.75,1.75), vec4(-1))\n#define BG mat4( 1,-3.8,-1.14,1.53, 2.3,3.5,-3.5,0, 1.53,1.54, 1.75,.54, 0.,.97,.59,.66)\n\n#define BOUNDINGBOX_W 1.1\n#define BOUNDINGBOX_H 1.32\n#define CHAR_W .04\n#define CHAR_H .08\n#define THICKNESS .5\n#define TEST(X2,X3) distance(getPos(nn,X2*CHAR_W,X3*CHAR_H),pos)\n#define TEST1(X2,X3) distance(getPos(nn.wzyx,X2*CHAR_W,X3*CHAR_H),pos)\n#define IS_INSIDE pos.x<BOUNDINGBOX_W && pos.x>-BOUNDINGBOX_W && pos.y<BOUNDINGBOX_H && pos.y>-BOUNDINGBOX_H\n#define DO_TEST(t_,ux,uy) nn=getN(t_); c = min(c,min(TEST(ux,uy),TEST1(ux,uy)));\n#define a2z_1(ux,uy)  { DO_TEST(t-.005,ux,uy) DO_TEST(t-.015,ux,uy) DO_TEST(t-.025,ux,uy); DO_TEST(t-.035,ux,uy); }\n#define a2z0(ux,uy)  { DO_TEST(t-.01,ux,uy) DO_TEST(t-.03,ux,uy); if(c<.02) a2z_1(ux,uy); }\n#define a2z1(ux,uy)  { DO_TEST(t-.02,ux,uy);  if(c<.04) a2z0(ux,uy); }\n#define a2z(ux,uy,color)  if(IS_INSIDE) for(float t=0.;t<.52;t+=.04) { float c1=c; vec4 nn; DO_TEST(t,ux,uy) if(abs(c)<.0002)break; else if(c<.04&&t>0.) a2z1(ux,uy) ; if(c<c1) col=color; }\n\n#define  mx( u, v, t)  mix(u,v,clamp(t1-t,0.,1.))\n#define  mx2( u, v, t)  mix(u,v,clamp((t1-t)/2.,0.,1.))\n#define  mx3( u, v, t)  mix(u,v,clamp((t1-t)*4.,0.,1.))\n#define  A2Z(X,color) pos+=pstep; a2z((gl=X)[0],gl[1],color) a2z(gl[2],gl[3],color)  \n#define  A2L(X,color) if((gl=X)[0]==LV[0]) gl*=heartbeat;  A2Z(gl,color)  \n#define time iTime\n#define resolution iResolution.xy\n\n\nuniform vec2 mouse;\n\n\nvec2 rotate(vec2 p, float a)\n{\n\treturn vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n}\n\n// 1D random numbers\nfloat rand(float n)\n{\n    return fract(sin(n) * 43758.5453123);\n}\n\n// 2D random numbers\nvec2 rand2(in vec2 p)\n{\n\treturn fract(vec2(sin(p.x * 591.32 + p.y * 154.077), cos(p.x * 391.32 + p.y * 49.077)));\n}\n\n// 1D noise\nfloat noise1(float p)\n{\n\tfloat fl = floor(p);\n\tfloat fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\n// voronoi distance noise, based on iq's articles\nfloat voronoi(in vec2 x)\n{\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\t\n\tvec2 res = vec2(8.0);\n\tfor(int j = -1; j <= 1; j ++)\n\t{\n\t\tfor(int i = -1; i <= 1; i ++)\n\t\t{\n\t\t\tvec2 b = vec2(i, j);\n\t\t\tvec2 r = vec2(b) - f + rand2(p + b);\n\t\t\t\n\t\t\t// chebyshev distance, one of many ways to do this\n\t\t\tfloat d = max(abs(r.x), abs(r.y));\n\t\t\t\n\t\t\tif(d < res.x)\n\t\t\t{\n\t\t\t\tres.y = res.x;\n\t\t\t\tres.x = d;\n\t\t\t}\n\t\t\telse if(d < res.y)\n\t\t\t{\n\t\t\t\tres.y = d;\n\t\t\t}\n\t\t}\n\t}\n\treturn res.y - res.x;\n}\n\n\nmat4 mix(in mat4 u,in mat4 v, in float t) { return v*t+u*(1.-t); }   // comment this line out if error or mix is already implemented for mat4\nvec4 getN(in float t) {\tfloat t1=1.-t; return vec4(t1*t1*t1, 3.*t1*t1*t, 3.*t1*t*t, t*t*t); }\nvec2 getPos(in vec4 n, in vec4 x, in vec4 y) { return vec2(dot(x,n), dot(y,n)); }\n\n#define  T1 mod(time*0.,9.)\n//#define  mx( u, v, t)  mix(u,v,clamp(t,0.,1.))\n#define tim mod(time/1.,314.)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 pos = gl_FragCoord.xy/resolution.xy -vec2(0., sin(tim*8.+(gl_FragCoord.xy/resolution.xy).x*4.)/15.),pstep;\n\tfloat c=1.,\n    x=-.4,\n    t1=mod(time,7.),\n    heartbeat=(2.-max(1.2,.5+(t1*0.)))*1.6, \n    co=cos(max(6.,t1*2.-6.)),\n    si=sin(max(6.,t1*0.-6.));  \n\tvec4 col=vec4(1);\n\tmat4 gl;\n\tpos += vec2(-.1,-.55); pstep=vec2(-.11,.0);\n\n\t// a2z ( x-position, offset (draw 1, 2 or more times depending on extents), char data )\nA2Z(mx(_,mx(N,_,7.5),1.),vec4(0,0,1,1)) \n\tA2Z(mx(_,mx(A,_,7.5),1.),vec4(1,0,1,1)) \n\tA2Z(mx(_,mx(Y,_,7.5),1.),vec4(.9,.9,0,1)) \n\tA2Z(mx(_,mx(K,_,7.5),1.),vec4(0,0,1,1)) \n\n\t\t\t\n\tfloat mc=c;\n\t\t  float flicker = noise1(time * 0.0) * 0.8 + 0.4;\n\n    vec2 uv = fragCoord.xy / resolution.xy;\n\tuv = (uv - 0.5) * 2.0;\n\tvec2 suv = uv;\n\tuv.x *= resolution.x / resolution.y;\n\t\n\t\n\tfloat v = 0.0;\n\t\n\t// that looks highly interesting:\n\t//v = 1.0 - length(uv) * 1.3;\n\t\n\t\n\t// a bit of camera movement\n\n\t\n\t// add some noise octaves\n\tfloat a = 0.6, f = 1.0;\n\tuv.x+=iTime;\n\tfor(int i = 0; i < 5; i ++) // 4 octaves also look nice, its getting a bit slow though\n\t{\t\n\t\tfloat v1 = voronoi(uv * f + 5.0);\n\t\tfloat v2 = 0.0;\n\t\t\n\t\t// make the moving electrons-effect for higher octaves\n\t\tif(i > 0)\n\t\t{\n\t\t\t// of course everything based on voronoi\n\t\t\tv2 = voronoi(uv * f * 0.5 + 50.0 + time);\n\t\t\t\n\t\t\tfloat va = 0.0, vb = 0.0;\n\t\t\tva = 1.0 - smoothstep(0.0, 0.1, v1);\n\t\t\tvb = 1.0 - smoothstep(0.0, 0.08, v2);\n\t\t\tv += a * pow(va * (0.5 + vb), 2.0);\n\t\t}\n\t\t\n\t\t// make sharp edges\n\t\tv1 = 1.0 - smoothstep(0.0, 0.3, v1);\n\t\t\n\t\t// noise is used as intensity map\n\t\tv2 = a * (noise1(v1 * 5.5 + 0.1));\n\t\t\n\t\t// octave 0's intensity changes a bit\n\t\tif(i == 0)\n\t\t\tv += v2 * flicker;\n\t\telse\n\t\t\tv += v2;\n\t\t\n\t\tf *= 3.0;\n\t\ta *= 0.7;\n\t}\n\n\t// slight vignetting\n\tv *= exp(-0.6 * length(suv)) * 1.2;\n\t\n\t// use texture channel0 for color? why not.\n\tvec3 cexp = vec3(1.0) * 3.0 + vec3(1.0);//vec3(1.0, 2.0, 4.0);\n\tcexp *= 1.4;\n\t\n\t// old blueish color set\n\tcexp = vec3(6.0, 4.0, 2.0);\n\t\n\tvec3 col2 = vec3(pow(v, cexp.x), pow(v, cexp.y), pow(v, cexp.z)) * 2.0;\t\n\tfragColor = \n\t\tmx(\n\t\t\tc<.0317? pow(mc,3.)*col*11.:vec4(1),\n\t\tmx3(\n\t\t\tvec4( vec3(0.848*mc,0.975*mc,0.975*(1.-1.47*(smoothstep(c*c*c*4.+.00455,.0,.002)))), 1.0 ),\n\t\tmx2(\n\t\t\tvec4( 7.*vec3(0.848,.89,2.999)*mc, 1.0 ),\t\n\t\t\tc<.0317? pow(mc,3.)*col*11.:vec4(1),\t\n\t\t7.),\n\t\t6.),\n\t\t5.);\t\n        fragColor+=vec4(col2,1.);\n}","name":"Image","description":"","type":"image"}]}