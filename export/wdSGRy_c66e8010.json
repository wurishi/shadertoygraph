{"ver":"0.1","info":{"id":"wdSGRy","date":"1549143996","viewed":109,"name":"Rayfish","username":"edapx","description":"raymarching rayfish","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["rayfish"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\nconst int MAX_MARCHING_STEPS = 128;\nconst float EPSILON = 0.0015;\nconst float NEAR_CLIP = 0.0;\nconst float FAR_CLIP = 80.00;\n\nvec3 lightDirection = vec3(1.0, 1.0, 0.);\n\nfloat sdBox( vec3 p, vec3 b ){\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec3 opRep( vec3 p, vec3 c ){\n    return mod(p,c)-0.5*c;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat smin( float a, float b, float k ){    \n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ){\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r ){\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat map(vec3 pos){\n    pos.z += fract(iTime*0.001) * 900.0;\n    float side = 1.5;\n    //raviolo\n    pos = opRep(pos, vec3(11.0 ,17.,11.));\n    float c = cos(sin(iTime)*0.1 *pos.z);\n    float s = sin(sin(iTime)*0.1 *pos.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*pos.xy,pos.z);\n    float osc = 11.0/side;\n    q.y+= sin(((iTime+q.z)*osc)) * abs(q.x) * side*0.01;\n    q.xz *= rotate2d(-PI/4.);\n    float raviolo =  sdRoundBox(q,vec3(side, side*0.01, side), side*0.01);\n    //body\n    vec3 posBody = pos;\n    posBody.z+= side*0.4;\n    float body = sdEllipsoid(posBody, vec3(side*0.2, side*0.1, side*1.));\n    //tail\n    vec3 posTail = pos;\n    posTail.z-= side*1.9;\n    posTail.y += sin(iTime+posTail.z * 1.2)* side*0.03;\n    float tail = sdEllipsoid(posTail, vec3(side*0.02, side*0.03, side*1.6));\n\n    return smin(tail,smin(raviolo,body, side*0.14), side*0.07);\n}\n\nvec2 squareFrame(vec2 res, vec2 coord){\n    vec2 uv = 2.0 * coord.xy / res.xy - 1.0;\n    uv.x *= res.x / res.y;\n    return uv;\n}\n\nfloat raymarching(vec3 eye, vec3 marchingDirection){\n    float depth = NEAR_CLIP;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = map(eye + depth * marchingDirection);\n        if (dist < EPSILON){\n            return depth;\n        }\n\n        depth += dist;\n\n        if (depth >= FAR_CLIP) {\n            return FAR_CLIP;\n        }\n    }\n    return FAR_CLIP;\n}\n\nvec3 computeNormal(vec3 pos){\n    vec2 eps = vec2(0.01, 0.);\n    return normalize(vec3(\n        map(pos + eps.xyy) - map(pos - eps.xyy),\n        map(pos + eps.yxy) - map(pos - eps.yxy),\n        map(pos + eps.yyx) - map(pos - eps.yyx)\n    ));\n}\n\nfloat diffuse(vec3 normal){\n    float ambient = 0.3;\n    return clamp( dot(normal, lightDirection) * ambient + ambient, 0.0, 1.0 );\n}\n\nfloat specular(vec3 normal, vec3 dir){\n    vec3 h = normalize(normal - dir);\n    float specularityCoef = 100.;\n    return clamp( pow(max(dot(h, normal), 0.), specularityCoef), 0.0, 1.0);\n}\n\n\nfloat fresnel(vec3 normal, vec3 dir){\n    return pow( clamp(1.0+dot(normal,dir),0.0,1.0), 2.0 );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ){\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 eye = vec3(2.5,\n                15.0,\n                11.0\n    );\n    \n    vec3 ta = vec3(9.0, -1.0, -9.0 );\n    mat3 camera = setCamera( eye, ta, 0.0 );\n    float fov = 1.5;\n    vec3 dir = camera * normalize(vec3(uv, fov));\n    float shortestDistanceToScene = raymarching(eye, dir);\n\n    vec3 color;\n    vec3 bgColor = mix(vec3(0.3,0.3,1.),vec3(0.06,0.1,0.34),pow(uv.y-1.3,2.)); \n    // This bg is horrible\n    // suggestion to have a better quick&dirty BG are welcome!\n\n    if (shortestDistanceToScene < FAR_CLIP - EPSILON) {\n        vec3 collision = (eye += (shortestDistanceToScene*0.995) * dir );\n        vec3 normal = computeNormal(collision);\n        float diffLight = diffuse(normal);\n        float specLight = specular(normal, dir);\n        float fresnelLight = fresnel(normal, dir);\n        color = (diffLight + specLight + fresnelLight) * vec3(0.744, 0.613, 0.589);\n        \n\n    } else {\n        color = bgColor;\n    }\n    \n\n    float fogFactor = exp(eye.z * 0.05);\n    color = mix(vec3(bgColor), color, fogFactor);\n    fragColor = vec4(clamp(color,0.0,1.0) , 1.0);\n}","name":"Image","description":"","type":"image"}]}