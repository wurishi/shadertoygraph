{"ver":"0.1","info":{"id":"43BSDy","date":"1710988751","viewed":93,"name":"Conway's Fuzzy Game of Life","username":"complexbezier","description":"Each cell has a float value in the range [0.0, 1.0] and the state-update function treats these as probabilities, updating cells in the next generation based on these probabilities. Entropy and decay abounds.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["conway","probabilistic"],"hasliked":0,"parentid":"43BSWG","parentname":"Probabilistic Conway Life"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (floor(fragCoord/3.0)+0.5)/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0,uv,1.0);\n    float r = fragColor.r;\n    if (r > 0.0 && r < 0.1)\n        fragColor.r=0.1;\n    if (r < 1.0 && r > 0.9)\n        fragColor.b=0.9;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 step = 1.0/iResolution.xy;\n    \n    //If we're just starting, randomize\n    if (iFrame==1) {\n        float f = 0.0;\n        if (rand(uv*iTime*(iTime+4.0))>0.91)\n            f=1.0;\n        fragColor=vec4(f,f,f,1.0);\n        //fragColor=vec4(0.0,0.0,0.0,1.0);\n        return;\n    }\n    \n    //If close to mouse, fix value\n    if ((length((iMouse.xy/3.0+0.5) - fragCoord.xy)<=1.0) && (iMouse.z>0.5)) {\n        float f=0.9999999;\n        fragColor=vec4(f,f,f,1.0);\n        //fragColor.r = 0.0;\n        return;\n    }\n    //Get Neighbors\n    float P[9];\n    P[0] = texture(iChannel0,uv).b;\n    P[1] = texture(iChannel0,vec2(uv.x-step.x,uv.y-step.y)).b;\n    P[2] = texture(iChannel0,vec2(uv.x,uv.y-step.y)).b;\n    P[3] = texture(iChannel0,vec2(uv.x+step.x,uv.y-step.y)).b;\n    P[4] = texture(iChannel0,vec2(uv.x+step.x,uv.y)).b;\n    P[5] = texture(iChannel0,vec2(uv.x+step.x,uv.y+step.y)).b;\n    P[6] = texture(iChannel0,vec2(uv.x,uv.y+step.y)).b;\n    P[7] = texture(iChannel0,vec2(uv.x-step.x,uv.y+step.y)).b;\n    P[8] = texture(iChannel0,vec2(uv.x-step.x,uv.y)).b;\n    \n    //Perform Summation\n    float term;\n    float sum2 = 0.0;\n    float sum3 = 0.0;\n    float Qij;\n    float Qijk;\n    for (int i = 1; i < 9; ++i) {\n        for (int j = i+1; j < 9; ++j) {\n            Qij=1.0;\n            for (int n = 1; n < 9; ++n) {\n                if (n == i || n == j)\n                    Qij *= P[n];\n                else\n                    Qij *= (1.0 - P[n]);\n            }\n            sum2 += Qij;\n            for (int k = j+1; k<9; ++k) {   \n                Qijk=1.0;\n                for (int n = 1; n < 9; ++n) {\n                    if (n == i || n == j || n == k)\n                        Qijk *= P[n];\n                    else\n                        Qijk *= (1.0 - P[n]);\n                }\n                sum3 += Qijk;\n            }\n        }\n    }\n    \n    float newProb = P[0]*sum2 + sum3;\n    if (newProb < 0.0) newProb = 0.0;\n    if (newProb > 1.0) newProb = 1.0;\n\n    fragColor = vec4(newProb,newProb,newProb,1.0);\n    return;\n}","name":"Buffer A","description":"","type":"buffer"}]}