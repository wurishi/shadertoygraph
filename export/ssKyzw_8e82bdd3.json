{"ver":"0.1","info":{"id":"ssKyzw","date":"1654740246","viewed":148,"name":"Dodecaplex_3","username":"afoksha","description":"After coding distance function to 927 vertices in hyperbolic space, it does not make sense not to code distance function to 600 dodecaplex vertices and render it with balls and edges, not as something that remain after removing 120 balls from 3-Sphere.\n\n","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["3sphere","poincarespace","binaryicosahedralgroup"],"hasliked":0,"parentid":"NdtcD8","parentname":"Dodecaplex2"},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//==============================================================================================================================================================\n//  Created by Alexander Foksha\n//\n//  Do with this or without this code whatever you wish at your own risk.\n//  You have been warned !!\n//==============================================================================================================================================================\n\n//==========================================================================================================================\n//\n//      This shader is able to render all the six 4-dimensional regular polytopes that exist in nature. Since we are\n// not able to render four-dimensional space we render how these polytopes will look when observed from inside 3-dimensional\n// sphere S, where they all recide:\n//\n//          S = { (x, y, z, w) : xx + yy + zz + ww = 1 }\n//\n//      We also think of S as a group of unit quaternions, the point { x, y, z, w } being identified with quaternion\n// w + xi + yj + zk. The north pole { 0, 0, 0, 1 } thus becomes the unit element of the group and we call it 'origin'\n//\n//                             | vertices | edges |        2-faces |        3-cells  |\n//                 ===================================================================\n//                 SIMPLEX     |        5 |    10 |   10 triangles |   5 tetrahedra  |\n//                 TESSERACT   |       16 |    32 |   24 squares   |   8 cubes       |\n//                 ORTHOPLEX   |        8 |    24 |   32 triangles |  16 tetrahedra  |\n//                 OCTAPLEX    |       24 |    96 |   96 triangles |  24 octahedra   |\n//                 DODECAPLEX  |      600 |  1200 |  720 pentagons | 120 dodecahedra |\n//                 TETRAPLEX   |      120 |   720 | 1200 triangles | 600 tetrahedra  |\n//\n//      First thing that we can compute is minimal distance to the vertices of a given polytope. Inverting it we can cut out\n// spherical holes from S, leaving the object which quite resembles dual polytope to the one which vertices were used. To\n// render edges, we need more information and out of all the distances to vertices we need not just the minimal one, but two\n// minimal ones. Adding them we get a function that has a minimum equal to the length of the edge of this (not dual) polytope\n// and the neighbourhood of the minimum is a tube around the edge. It is possible often to split the set of vertices into\n// disjoint subsets such that two minimal distance never belong to the vertices from the same subset, this will hold if and\n// only if subsets do not contain neighbouring vertices. At the end we find minimum in each subset and from this list by two\n// iterations we find minimal and the second minimal value.\n//\n//      All this works smoothly for the first 4 polyhedra in the list as they are simple enough for just writing their\n// distance functions without much thinking. The last two polytopes simply have too much vertices. Direct computations were\n// tried and, in particular, the rendering dodecaplex edges, thus finding two minimal distance to its vertices, is\n// particularly slow and unacceptable. The rest are not fast too.\n//\n//      At the end, the correct way of doing this was found. The vertices of tetraplex, when selected appropriately, form\n// elements of the binary icosahedral group, call it B. It is a group of (orientation-preserving) symmetries of icosahedron\n// thought of as a subgroup of SO(3), lifted to the group of unit quaternions. The elements of B are listed below. We need\n// not all, but only part of them.\n//\n//      Using multiplication by elements of B we can push every point p as close to the origin (unit group element) as\n// possible. Since quaternionic multiplications are isometries and since tetraplex and dodecaplex are invariant under group\n// multiplication (tetraplex because it simply the group itself, and dodecaplex as a dual object), this push preserves all\n// the possible distance functions we might be interested in. Function bounce(p) does it. It does it by computing which of\n// the 12 pushes of p to the neighbouring dodecahedral chambers lies closest to the origin. If none, e.g p itself is the\n// closest point then we are done, otherwise replace p with the closest one repeat. No more than 4 iterations are needed.\n//\n//      At the end we have a point lying in the main dodecahedral chamber around the origin. From here, minimal distance to\n// tetraplex vertices is simply the distance to origin. To find the second minimal we need to find another 12 distances and\n// minimum among them is the second minimal distance. We know explicitly the vertices of the chamber dodecahedron. We can\n// compute these 20 distances and select minimum, this gives distance to dodecaplex vertices. To compute 2 minimal ones we\n// split them into 5 tetrahedral groups, etc. Everything works.\n//\n//      The 12 quaternions that push point p into 12 neighbouring dodecahedral cells are:\n//\n//              phi + psi * i + 0.5 * k\n//              phi + psi * i - 0.5 * k\n//              phi - psi * i + 0.5 * k\n//              phi - psi * i - 0.5 * k\n//              phi + psi * k + 0.5 * j\n//              phi + psi * k - 0.5 * j\n//              phi - psi * k + 0.5 * j\n//              phi - psi * k - 0.5 * j\n//              phi + psi * j + 0.5 * i\n//              phi + psi * j - 0.5 * i\n//              phi - psi * j + 0.5 * i\n//              phi - psi * j - 0.5 * i\n//\n//      The last note is that distances in the 3-sphere are directly related with dot products of 4-vectors via arccos\n// function, and thus they are minimal when dot products are maximal.\n//\n//==========================================================================================================================\n\n//==========================================================================================================================\n//      Binary icosahedral group\n//==========================================================================================================================\n// const vec4 B[120] = vec4[]\n// (\n//     /* 4-vector with components {x, y, z, w} represents quaternion w + xi + yj + zk */\n//\n//     /* 8 basic unit quaternions :: ±1, ±i, ±j, ±k */\n//     /* these eight elements form a subgroup S */\n//     vec4( 0.0,  0.0,  0.0,  1.0),            /* +1, order :: 1  */\n//     vec4( 0.0,  0.0,  0.0, -1.0),            /* -1, order :: 2  */\n//     vec4( 1.0,  0.0,  0.0,  0.0),            /* +i, order :: 4  */\n//     vec4(-1.0,  0.0,  0.0,  0.0),            /* -i, order :: 4  */\n//     vec4( 0.0,  1.0,  0.0,  0.0),            /* +j, order :: 4  */\n//     vec4( 0.0, -1.0,  0.0,  0.0),            /* -j, order :: 4  */\n//     vec4( 0.0,  0.0,  1.0,  0.0),            /* +k, order :: 4  */\n//     vec4( 0.0,  0.0, -1.0,  0.0),            /* -k, order :: 4  */\n//\n//     /* 16 unit Hurwitz quaternions */\n//     /* these 16 elements together with first 8 form a subgroup H (Hurwitz subgroup) */\n//     /* as a union of right conjugacy classes H = { S * g0, S * g8, S * g16 } */\n//     /* as a point set they form vertices of the octaplex, self-dual 24-cell in spherical space */\n//     vec4( 0.5,  0.5,  0.5,  0.5),            /* order :: 6  */\n//     vec4(-0.5, -0.5, -0.5, -0.5),            /* order :: 3  */\n//     vec4( 0.5,  0.5,  0.5, -0.5),            /* order :: 6  */\n//     vec4(-0.5, -0.5, -0.5,  0.5),            /* order :: 3  */\n//     vec4( 0.5,  0.5, -0.5,  0.5),            /* order :: 6  */\n//     vec4(-0.5, -0.5,  0.5, -0.5),            /* order :: 3  */\n//     vec4( 0.5,  0.5, -0.5, -0.5),            /* order :: 6  */\n//     vec4(-0.5, -0.5,  0.5,  0.5),            /* order :: 3  */\n//     vec4( 0.5, -0.5,  0.5,  0.5),            /* order :: 6  */\n//     vec4(-0.5,  0.5, -0.5, -0.5),            /* order :: 3  */\n//     vec4( 0.5, -0.5,  0.5, -0.5),            /* order :: 6  */\n//     vec4(-0.5,  0.5, -0.5,  0.5),            /* order :: 3  */\n//     vec4( 0.5, -0.5, -0.5,  0.5),            /* order :: 6  */\n//     vec4(-0.5,  0.5,  0.5, -0.5),            /* order :: 3  */\n//     vec4( 0.5, -0.5, -0.5, -0.5),            /* order :: 6  */\n//     vec4(-0.5,  0.5,  0.5,  0.5),            /* order :: 3  */\n//\n//     /* 96 special quaternions :: in lexical order w.r.t. w, z, y, x, but obeying oppositeness rule */\n//\n//     /* 24 quaternions with w = ± phi */\n//     vec4( phi,  psi,  0.0,  0.5),            /* order :: 10 */\n//     vec4(-phi, -psi,  0.0, -0.5),            /* order :: 5  */\n//     vec4( phi, -psi,  0.0,  0.5),            /* order :: 10 */\n//     vec4(-phi,  psi,  0.0, -0.5),            /* order :: 5  */\n//     vec4( phi,  0.0,  0.5,  psi),            /* order :: 10 */\n//     vec4(-phi,  0.0, -0.5, -psi),            /* order :: 5  */\n//     vec4( phi,  0.0, -0.5,  psi),            /* order :: 10 */\n//     vec4(-phi,  0.0,  0.5, -psi),            /* order :: 5  */\n//     vec4( phi,  0.5,  psi,  0.0),            /* order :: 10 */\n//     vec4(-phi, -0.5, -psi,  0.0),            /* order :: 5  */\n//     vec4( phi, -0.5,  psi,  0.0),            /* order :: 10 */\n//     vec4(-phi,  0.5, -psi,  0.0),            /* order :: 5  */\n//     vec4( phi,  0.5, -psi,  0.0),            /* order :: 10 */\n//     vec4(-phi, -0.5,  psi,  0.0),            /* order :: 5  */\n//     vec4( phi, -0.5, -psi,  0.0),            /* order :: 10 */\n//     vec4(-phi,  0.5,  psi,  0.0),            /* order :: 5  */\n//     vec4( phi,  0.0,  0.5, -psi),            /* order :: 10 */\n//     vec4(-phi,  0.0, -0.5,  psi),            /* order :: 5  */\n//     vec4( phi,  0.0, -0.5, -psi),            /* order :: 10 */\n//     vec4(-phi,  0.0,  0.5,  psi),            /* order :: 5  */\n//     vec4( phi,  psi,  0.0, -0.5),            /* order :: 10 */\n//     vec4(-phi, -psi,  0.0,  0.5),            /* order :: 5  */\n//     vec4( phi, -psi,  0.0, -0.5),            /* order :: 10 */\n//     vec4(-phi,  psi,  0.0,  0.5),            /* order :: 5  */\n//\n//     /* 24 quaternions with w = ± 0.5 */\n//     vec4( 0.5,  0.0,  psi,  phi),            /* order :: 6  */\n//     vec4(-0.5,  0.0, -psi, -phi),            /* order :: 3  */\n//     vec4( 0.5,  0.0, -psi,  phi),            /* order :: 6  */\n//     vec4(-0.5,  0.0,  psi, -phi),            /* order :: 3  */\n//     vec4( 0.5,  0.0,  psi, -phi),            /* order :: 6  */\n//     vec4(-0.5,  0.0, -psi,  phi),            /* order :: 3  */\n//     vec4( 0.5,  0.0, -psi, -phi),            /* order :: 6  */\n//     vec4(-0.5,  0.0,  psi,  phi),            /* order :: 3  */\n//     vec4( 0.5,  phi,  0.0,  psi),            /* order :: 6  */\n//     vec4(-0.5, -phi,  0.0, -psi),            /* order :: 3  */\n//     vec4( 0.5, -phi,  0.0,  psi),            /* order :: 6  */\n//     vec4(-0.5,  phi,  0.0, -psi),            /* order :: 3  */\n//     vec4( 0.5,  phi,  0.0, -psi),            /* order :: 6  */\n//     vec4(-0.5, -phi,  0.0,  psi),            /* order :: 3  */\n//     vec4( 0.5, -phi,  0.0, -psi),            /* order :: 6  */\n//     vec4(-0.5,  phi,  0.0,  psi),            /* order :: 3  */\n//     vec4( 0.5,  psi,  phi,  0.0),            /* order :: 6  */\n//     vec4(-0.5, -psi, -phi,  0.0),            /* order :: 3  */\n//     vec4( 0.5, -psi,  phi,  0.0),            /* order :: 6  */\n//     vec4(-0.5,  psi, -phi,  0.0),            /* order :: 3  */\n//     vec4( 0.5,  psi, -phi,  0.0),            /* order :: 6  */\n//     vec4(-0.5, -psi,  phi,  0.0),            /* order :: 3  */\n//     vec4( 0.5, -psi, -phi,  0.0),            /* order :: 6  */\n//     vec4(-0.5,  psi,  phi,  0.0),            /* order :: 3  */\n//\n//     /* 24 quaternions with w = ± psi */\n//     vec4( psi,  0.5,  0.0,  phi),            /* order :: 10 */\n//     vec4(-psi, -0.5,  0.0, -phi),            /* order :: 5  */\n//     vec4( psi, -0.5,  0.0,  phi),            /* order :: 10 */\n//     vec4(-psi,  0.5,  0.0, -phi),            /* order :: 5  */\n//     vec4( psi,  0.0,  phi,  0.5),            /* order :: 10 */\n//     vec4(-psi,  0.0, -phi, -0.5),            /* order :: 5  */\n//     vec4( psi,  0.0, -phi,  0.5),            /* order :: 10 */\n//     vec4(-psi,  0.0,  phi, -0.5),            /* order :: 5  */\n//     vec4( psi,  phi,  0.5,  0.0),            /* order :: 10 */\n//     vec4(-psi, -phi, -0.5,  0.0),            /* order :: 5  */\n//     vec4( psi, -phi,  0.5,  0.0),            /* order :: 10 */\n//     vec4(-psi,  phi, -0.5,  0.0),            /* order :: 5  */\n//     vec4( psi,  phi, -0.5,  0.0),            /* order :: 10 */\n//     vec4(-psi, -phi,  0.5,  0.0),            /* order :: 5  */\n//     vec4( psi, -phi, -0.5,  0.0),            /* order :: 10 */\n//     vec4(-psi,  phi,  0.5,  0.0),            /* order :: 5  */\n//     vec4( psi,  0.0,  phi, -0.5),            /* order :: 10 */\n//     vec4(-psi,  0.0, -phi,  0.5),            /* order :: 5  */\n//     vec4( psi,  0.0, -phi, -0.5),            /* order :: 10 */\n//     vec4(-psi,  0.0,  phi,  0.5),            /* order :: 5  */\n//     vec4( psi,  0.5,  0.0, -phi),            /* order :: 10 */\n//     vec4(-psi, -0.5,  0.0,  phi),            /* order :: 5  */\n//     vec4( psi, -0.5,  0.0, -phi),            /* order :: 10 */\n//     vec4(-psi,  0.5,  0.0,  phi),            /* order :: 5  */\n//\n//     /* 24 pure imaginary quaternions */\n//     vec4( 0.0,  psi,  0.5,  phi),            /* order :: 4  */\n//     vec4( 0.0, -psi, -0.5, -phi),            /* order :: 4  */\n//     vec4( 0.0, -psi,  0.5,  phi),            /* order :: 4  */\n//     vec4( 0.0,  psi, -0.5, -phi),            /* order :: 4  */\n//     vec4( 0.0,  psi, -0.5,  phi),            /* order :: 4  */\n//     vec4( 0.0, -psi,  0.5, -phi),            /* order :: 4  */\n//     vec4( 0.0, -psi, -0.5,  phi),            /* order :: 4  */\n//     vec4( 0.0,  psi,  0.5, -phi),            /* order :: 4  */\n//     vec4( 0.0,  phi,  psi,  0.5),            /* order :: 4  */\n//     vec4( 0.0, -phi, -psi, -0.5),            /* order :: 4  */\n//     vec4( 0.0, -phi,  psi,  0.5),            /* order :: 4  */\n//     vec4( 0.0,  phi, -psi, -0.5),            /* order :: 4  */\n//     vec4( 0.0,  phi, -psi,  0.5),            /* order :: 4  */\n//     vec4( 0.0, -phi,  psi, -0.5),            /* order :: 4  */\n//     vec4( 0.0, -phi, -psi,  0.5),            /* order :: 4  */\n//     vec4( 0.0,  phi,  psi, -0.5),            /* order :: 4  */\n//     vec4( 0.0,  0.5,  phi,  psi),            /* order :: 4  */\n//     vec4( 0.0, -0.5, -phi, -psi),            /* order :: 4  */\n//     vec4( 0.0, -0.5,  phi,  psi),            /* order :: 4  */\n//     vec4( 0.0,  0.5, -phi, -psi),            /* order :: 4  */\n//     vec4( 0.0,  0.5, -phi,  psi),            /* order :: 4  */\n//     vec4( 0.0, -0.5,  phi, -psi),            /* order :: 4  */\n//     vec4( 0.0, -0.5, -phi,  psi),            /* order :: 4  */\n//     vec4( 0.0,  0.5,  phi, -psi),            /* order :: 4  */\n// );\n\n/* helper function :: exchanges the values if necessary so on return we have v0 <= v1 */\nvoid order(inout float v0, inout float v1)\n{\n    float vm = max(v0, v1);\n    v0 = min(v0, v1);\n    v1 = vm;\n}\n\n/* helper function :: smoothed minimum */\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5f + 0.5f * (b - a) / k, 0.0f, 1.0f);\n    return mix(b, a, h) - k * h * (1.0f - h);\n}\n\n/* helper function :: smootherstep order-5 Hermite polynomial */\nfloat smootherstep(float edge0, float edge1, float x)\n{\n    float t = clamp((x - edge0) / (edge1 - edge0), 0.0f, 1.0f);\n    return t * t * t * ((6.0f * t - 15.0f) * t + 10.0f);\n}\n\n/* generic constants */\nconst float pi     = 3.14159265358979324f;\nconst float two_pi = 6.28318530717958648f;\nconst float inv_pi = 0.31830988618379067f;          /* 1 / pi */\nconst float gamma  = 2.2f;                          /* the gamma is for coloring */\n\n/* constants for binary icosahedral group elements */\nconst float phi    = 0.8090169943749474f;           /* (sqrt(5) + 1) / 4 = psi + 0.5 */\nconst float psi    = 0.3090169943749474f;           /* (sqrt(5) - 1) / 4 */\n\n/* SIMPLEX */\nconst float sigma  = 0.5590169943749474f;           /* sqrt(5) / 4 */\n\n/* TETRAPLEX - DODECAPLEX */\nconst float nu     = 0.3535533905932738f;           /* 1 / sqrt(8) */\nconst float chi    = 0.2185080122244106f;           /* (sqrt(5) - 1) / (4 * sqrt(2)) */\nconst float tau    = 0.9256147934109581f;           /* (3 + sqrt(5)) / (4 * sqrt(2)) */\nconst float ksi    = 0.1350453783688632f;           /* (3 - sqrt(5)) / (4 * sqrt(2)) */\nconst float lambda = 0.1909830056250526f;           /* (3 - sqrt(5)) / 4 */\n\n/* right multiplications by basic quaternions i, j, k */\nvec4 mulr_i(vec4 p) { return vec4(p.wz, -p.yx); }\nvec4 mulr_j(vec4 p) { return vec4(-p.z, p.wx, -p.y); }\nvec4 mulr_k(vec4 p) { return vec4(p.y, -p.x, p.w, -p.z); }\n\n/* left multiplications by basic quaternions i, j, k */\nvec4 mull_i(vec4 p) { return vec4(p.w, -p.z, p.y, -p.x); }\nvec4 mull_j(vec4 p) { return vec4(p.zw, -p.xy); }\nvec4 mull_k(vec4 p) { return vec4(-p.y, p.x, p.w, -p.z); }\n\n/* will keep information wherether we reached main or dual polytope */\nfloat id = 0.0f;\n\n//==========================================================================================================================\n//      SIMPLEX\n//==========================================================================================================================\n/*\n   returns maximal dot product of p with the vertices of the simplex,\n   which does not fit into general scheme of working with binary icosahedral\n   group and quaternions, so we just compute distances directly, also note that\n   simplex is not symmetric about the origin, e.g if v is the vertex,\n   then -v is not, so absolute values of the dot products should not be taken\n\n   5 points\n*/\nfloat simplex_max_dp(vec4 p)\n{\n    /* {  sigma, -sigma, -sigma, -0.25 } */\n    /* { -sigma,  sigma, -sigma, -0.25 } */\n    /* { -sigma, -sigma,  sigma, -0.25 } */\n    /* {  sigma,  sigma,  sigma, -0.25 } */\n    /* {    0.0,    0.0,    0.0,   1.0 } */\n\n    /* four dot products without -0.25f * p.w */\n    vec3 q = sigma * p.xyz;\n    vec4 dp = vec4(q - q.yzx - q.zxy, q.x + q.y + q.z);\n\n    dp.xy = max(dp.xy, dp.zw);\n    float dpm = max(dp.x, dp.y) - 0.25f * p.w;\n\n    /* the 5th dot product is simply p.w */\n    return max(dpm, p.w);\n}\n\n/* returns pair of maximal dot products of p with the vertices of the simplex */\nvec2 simplex_max_dp_pair(vec4 p)\n{\n    /* four dot products */\n    vec3 q = sigma * p.xyz;\n    vec4 dp = vec4(q - q.yzx - q.zxy, q.x + q.y + q.z) - 0.25f * p.w;\n\n    /* the last dot product */\n    float dp4 = p.w;\n\n    order(dp.x, dp.y);\n    order(dp.y, dp.z);\n    order(dp.z, dp.w);\n    order(dp.w, dp4);       /* dp4 is now maximal */\n\n    dp.zw = max(dp.zw, dp.xy);\n    return vec2(max(dp.z, dp.w), dp4);\n}\n\nfloat dual_simplex_sdf(vec4 p)\n{\n    float dp = clamp(simplex_max_dp(p), -1.0f, 1.0f);\n    float s = acos(dp);\n    return 1.108f - s;\n}\n\nfloat simplex_sdf(vec4 p)\n{\n    vec2 dp = clamp(simplex_max_dp_pair(p), -1.0f, 1.0f);\n    float a1 = acos(dp.x);\n    float a2 = acos(dp.y);\n    float e_sdf = a1 + a2 - 1.838f;\n    float v_sdf = a2 - 0.243f;\n    return smin(e_sdf, v_sdf, 0.005f);\n}\n\nfloat simplex_dual_simplex_sdf(vec4 p)\n{\n    vec2 dp = clamp(simplex_max_dp_pair(p), -1.0f, 1.0f);\n    float a1 = acos(dp.x);\n    float a2 = acos(dp.y);\n    float e_sdf = a1 + a2 - 1.838f;\n    float v_sdf = a2 - 0.243f;\n    float sdf1 = smin(e_sdf, v_sdf, 0.005f);\n    float sdf2 = 1.108f - a2;\n    id = step(sdf1, sdf2);\n    return min(sdf1, sdf2);\n}\n\n//==========================================================================================================================\n//      TESSERACT\n//==========================================================================================================================\n/*\n   returns maximal dot product of p with the vertices of the tesseract, which,\n   as a point set, coincide with half-integral Hurwitz quaternions\n\n   16 points\n*/\nfloat tesseract_max_dp(vec4 p)\n{\n    vec4 s = mulr_i(p) + mulr_j(p) + mulr_k(p);\n    vec4 p8 = 0.5 * (s + p);\n    vec4 p16 = 0.5 * (s - p);\n    vec4 dp = max(abs(p8), abs(p16));\n    dp.xy = max(dp.xy, dp.zw);\n    return max(dp.x, dp.y);\n}\n\n/*\n    returns pair of maximal dot products of p with the vertices of the tesseract\n    these two maximal dot products always belong to different orthoplectic subsets\n*/\nvec2 tesseract_max_dp_pair(vec4 p)\n{\n    vec4 s = mulr_i(p) + mulr_j(p) + mulr_k(p);\n    vec4 p8 = 0.5 * (s + p);\n    vec4 p16 = 0.5 * (s - p);\n    vec4 dp0 = abs(p8);\n    vec4 dp1 = abs(p16);\n    dp0.xy = max(dp0.xy, dp0.zw);\n    dp1.xy = max(dp1.xy, dp1.zw);\n\n    float q0 = max(dp0.x, dp0.y);\n    float q1 = max(dp1.x, dp1.y);\n    return vec2(min(q0, q1), max(q0, q1));\n}\n\nfloat dual_orthoplex_sdf(vec4 p)\n{\n    float dp = min(tesseract_max_dp(p), 1.0f);\n    float s = acos(dp);\n    return 0.761f - s;\n}\n\nfloat tesseract_sdf(vec4 p)\n{\n    vec2 dp = min(tesseract_max_dp_pair(p), 1.0f);\n    float a1 = acos(dp.x);\n    float a2 = acos(dp.y);\n    float e_sdf = 0.812f * (a1 + a2 - 1.062f);\n    float v_sdf = a2 - 0.173f;\n    return smin(e_sdf, v_sdf, 0.005f);\n}\n\nfloat tesseract_dual_orthoplex_sdf(vec4 p)\n{\n    vec2 dp = min(tesseract_max_dp_pair(p), 1.0f);\n    float a1 = acos(dp.x);\n    float a2 = acos(dp.y);\n    float e_sdf = a1 + a2 - 1.062f;\n    float v_sdf = a2 - 0.173f;\n    float sdf1 = smin(e_sdf, v_sdf, 0.005f);\n    float sdf2 = 0.761f - a2;\n    id = step(sdf1, sdf2);\n    return min(sdf1, sdf2);\n}\n\n//==========================================================================================================================\n//      ORTHOPLEX\n//==========================================================================================================================\n/*\n   returns maximal dot product of p with the vertices of the orthoplex, which,\n   as a point set, coincide with basic quaternions { ±1, ±i, ±j, ±k }\n\n   8 points\n*/\nfloat orthoplex_max_dp(vec4 p)\n{\n    vec4 d = abs(p);\n    d.xy = max(d.xy, d.zw);\n    return max(d.x, d.y);\n}\n\n/* returns pair of maximal dot products of p with the vertices of the orthoplex */\nvec2 orthoplex_max_dp_pair(vec4 p)\n{\n    vec4 q = abs(p);\n    order(q.x, q.y);\n    order(q.y, q.z);\n    order(q.z, q.w);                /* q.w is now maximal */\n    q.z = max(q.z, max(q.x, q.y));  /* q.z is second maximal */\n    return q.zw;\n}\n\nfloat dual_tesseract_sdf(vec4 p)\n{\n    float dp = min(orthoplex_max_dp(p), 1.0f);\n    float s = acos(dp);\n    return 0.914f - s;\n}\n\nfloat orthoplex_sdf(vec4 p)\n{\n    vec2 dp = min(orthoplex_max_dp_pair(p), 1.0f);\n    float a1 = acos(dp.x);\n    float a2 = acos(dp.y);\n    float e_sdf = a1 + a2 - 1.584f;\n    float v_sdf = a2 - 0.181f;\n    return smin(e_sdf, v_sdf, 0.005f);\n}\n\nfloat orthoplex_dual_tesseract_sdf(vec4 p)\n{\n    vec2 dp = min(orthoplex_max_dp_pair(p), 1.0f);\n    float a1 = acos(dp.x);\n    float a2 = acos(dp.y);\n    float e_sdf = a1 + a2 - 1.584f;\n    float v_sdf = a2 - 0.181f;\n    float sdf1 = smin(e_sdf, v_sdf, 0.005f);\n    float sdf2 = 0.914f - a2;\n    id = step(sdf1, sdf2);\n    return min(sdf1, sdf2);\n}\n\n//==========================================================================================================================\n//      OCTAPLEX\n//==========================================================================================================================\n/*\n   returns maximal dot product of p with the vertices of the octaplex\n   which, as a point set, coincide with the Hurwitz subgroup of the\n   binary icosahedral group\n\n   24 points\n*/\nfloat octaplex_max_dp(vec4 p)\n{\n    /* (xi + yj + zk + w) * g8  = (s + p) / 2 */\n    /* (xi + yj + zk + w) * g16 = (s - p) / 2 */\n    /* s = p * (i + j + k) */\n\n    vec4 s = mulr_i(p) + mulr_j(p) + mulr_k(p);\n    vec4 p8 = 0.5 * (s + p);\n    vec4 p16 = 0.5 * (s - p);\n\n    /* taking absolute value of the dot product computes minimum\n       distance to the pair of opposite points on the sphere */\n\n    vec4 dp = max(abs(p), max(abs(p8), abs(p16)));\n    dp.xy = max(dp.xy, dp.zw);\n    return max(dp.x, dp.y);\n}\n\n/*\n    returns pair of maximal dot products of p with the vertices of the octaplex\n    these two maximal dot products always belong to different orthoplectic subsets\n*/\nvec2 octaplex_max_dp_pair(vec4 p)\n{\n    vec4 s = mulr_i(p) + mulr_j(p) + mulr_k(p);\n    vec4 p8 = 0.5 * (s + p);\n    vec4 p16 = 0.5 * (s - p);\n\n    vec4 q0 = abs(p);\n    vec4 q1 = abs(p8);\n    vec4 q2 = abs(p16);\n\n    q0.xy = max(q0.xy, q0.zw);\n    q1.xy = max(q1.xy, q1.zw);\n    q2.xy = max(q2.xy, q2.zw);\n\n    float s0 = max(q0.x, q0.y);\n    float s1 = max(q1.x, q1.y);\n    float s2 = max(q2.x, q2.y);\n\n    order(s0, s1);\n    order(s1, s2);      /* s2 is maximal */\n\n    s1 = max(s0, s1);   /* s1 is second maximal */\n    return vec2(s1, s2);\n}\n\nfloat dual_octaplex_sdf(vec4 p)\n{\n    float dp = octaplex_max_dp(p);\n    dp = min(dp, 1.0f);\n    float s = acos(dp);\n    return 0.604f - s;\n}\n\nfloat octaplex_sdf(vec4 p)\n{\n    vec2 dp = min(octaplex_max_dp_pair(p), 1.0f);\n    float a1 = acos(dp.x);\n    float a2 = acos(dp.y);\n    float e_sdf = 1.211f * (a1 + a2 - 1.051f);\n    float v_sdf = a2 - 0.137f;\n    return smin(e_sdf, v_sdf, 0.005f);\n}\n\nfloat octaplex_dual_octaplex_sdf(vec4 p)\n{\n    vec2 dp = min(octaplex_max_dp_pair(p), 1.0f);\n    float a1 = acos(dp.x);\n    float a2 = acos(dp.y);\n    float e_sdf = 1.211f * (a1 + a2 - 1.051f);\n    float v_sdf = a2 - 0.137f;\n    float sdf1 = smin(e_sdf, v_sdf, 0.005f);\n    float sdf2 = 0.604f - a2;\n    id = step(sdf1, sdf2);\n    return min(sdf1, sdf2);\n}\n\n//==========================================================================================================================\n//      The main function: finds the point in the orbit of p under the action of binary icosahedral group that lies\n// closest to the origin, or, the same finds point equivalent to p in the main fundamental domain of the B-action.\n//==========================================================================================================================\nvec4 bounce(vec4 p)\n{\n    if (p.w < 0.0)\n        p = -p;\n\n    int k = 0;\n\n    /* no more than 4 bounces needed if we start from upper hemisphere + to avoid\n       possible infinite loops for points equidistant to two elements of B, e.g.\n       lying on the faces of the main dodecahedron */\n\n    while (k < 4)\n    {\n        vec3 q = abs(p.xyz);\n        q = psi * q + 0.5f * q.zxy;\n\n        float M = max(q.x, max(q.y, q.z));\n        float W = lambda * p.w;\n\n        if (M >= W)\n        {\n            if (q.x >= M)       /* q.x = psi * |p.x| + 0.5f * |p.z| is maximal */\n                p = phi * p - sign(p.x) * psi * mulr_i(p) - sign(p.z) * 0.5f * mulr_k(p);\n            else if (q.y >= M)  /* q.y = psi * |p.y| + 0.5f * |p.x| is maximal */\n                p = phi * p - sign(p.y) * psi * mulr_j(p) - sign(p.x) * 0.5f * mulr_i(p);\n            else /* q.z >= M */ /* q.z = psi * |p.z| + 0.5f * |p.y| is maximal */\n                p = phi * p - sign(p.z) * psi * mulr_k(p) - sign(p.y) * 0.5f * mulr_j(p);\n\n            ++k;\n            continue;\n        }\n        else\n            break;\n    }\n\n    return p;\n}\n\n//==========================================================================================================================\n//      TETRAPLEX\n//==========================================================================================================================\nfloat dual_dodecaplex_sdf(vec4 p)\n{\n    p = bounce(p);\n    float dp = min(p.w, 1.0f);\n    return 0.351f - acos(dp);\n}\n\nfloat tetraplex_sdf(vec4 p)\n{\n    p = bounce(p);\n    vec3 q = abs(p.xyz);\n    vec3 r = psi * q.xyz + 0.5f * q.zxy;\n\n    vec2 dp = vec2(phi * p.w + max(r.x, max(r.y, r.z)), p.w);\n\n    dp = min(dp, 1.0f);\n    float a1 = acos(dp.x);\n    float a2 = acos(dp.y);\n    float e_sdf = a1 + a2 - 0.631f;\n    float v_sdf = a2 - 0.094f;\n    return smin(e_sdf, v_sdf, 0.005f);\n}\n\nfloat tetraplex_face_sdf(vec4 p)\n{\n    p = bounce(p);\n    vec3 q = abs(p.xyz);\n    vec3 r = psi * q.xyz + 0.5f * q.zxy;\n\n    vec2 dp = vec2(phi * p.w + max(r.x, max(r.y, r.z)), p.w);\n\n    dp = min(dp, 1.0f);\n    float a1 = acos(dp.x);\n    float a2 = acos(dp.y);\n    float e_sdf = a1 + a2 - 0.631f;\n    float v_sdf = a2 - 0.094f;\n    float sdf1 = smin(e_sdf, v_sdf, 0.005f);\n\n    /* face sdf */\n    vec4 c = vec4(ksi, -ksi, nu, -nu);\n\n    vec4 A = p.x * c.yxyx + p.y * c.wzzw;\n    vec4 B = p.y * c.xyyx + p.z * c.zzww;\n    vec4 C = p.z * c.yyxx + p.x * c.zwzw;\n    vec4 D = chi * vec4(p.yxz - p.zyx - p.xzy, p.x + p.y + p.z);\n    vec4 E = -D.yxzw;\n\n    vec4 abcd = max(max(A, B), max(C, D));\n\n    E.xy = max(E.xy, E.zw);\n    float e = max(E.x, E.y);\n\n    order(abcd.x, abcd.y);\n    order(abcd.y, abcd.z);\n    order(abcd.z, abcd.w);\n    order(abcd.w, e);\n\n    abcd.xy = max(abcd.xy, abcd.zw);\n\n    vec2 dp1 = tau * p.w + vec2(max(abcd.x, abcd.y), e);\n\n    dp1 = min(dp1, 1.0f);\n    float l1 = acos(dp1.x);\n    float l2 = acos(dp1.y);\n    float f_sdf = 0.5f * (l1 - l2 - 0.0131f);\n    float b_sdf = 0.185f - l2;\n    float sdf2 = max(f_sdf, b_sdf);\n\n    id = step(sdf2, sdf1);\n    return min(sdf1, sdf2);\n}\n\nfloat tetraplex_dual_dodecaplex_sdf(vec4 p)\n{\n    p = bounce(p);\n    vec3 q = abs(p.xyz);\n    vec3 r = psi * q.xyz + 0.5f * q.zxy;\n\n    vec2 dp = vec2(phi * p.w + max(r.x, max(r.y, r.z)), p.w);\n\n    dp = min(dp, 1.0f);\n    float a1 = acos(dp.x);\n    float a2 = acos(dp.y);\n    float e_sdf = a1 + a2 - 0.631f;\n    float v_sdf = a2 - 0.094f;\n    float sdf1 = smin(e_sdf, v_sdf, 0.005f);\n\n    float sdf2 = 0.351f - a2;\n    id = step(sdf1, sdf2);\n    return min(sdf1, sdf2);\n}\n\n//==========================================================================================================================\n//      DODECAPLEX\n//==========================================================================================================================\nfloat dual_tetraplex_sdf(vec4 p)\n{\n    p = bounce(p);\n    vec3 q = abs(p.xyz);\n    float dp0 = chi * (q.x + q.y + q.z);\n    vec3 r = ksi * q.xyz + nu * q.yzx;\n    float dp1 = max(r.x, max(r.y, r.z));\n\n    float dp = tau * p.w + max(dp0, dp1);\n    dp = min(dp, 1.0f);\n    float s = acos(dp);\n    return 0.219f - s;\n}\n\nfloat dodecaplex_sdf(vec4 p)\n{\n    p = bounce(p);\n\n    vec4 c = vec4(ksi, -ksi, nu, -nu);\n\n    vec4 A = p.x * c.yxyx + p.y * c.wzzw;\n    vec4 B = p.y * c.xyyx + p.z * c.zzww;\n    vec4 C = p.z * c.yyxx + p.x * c.zwzw;\n    vec4 D = chi * vec4(p.yxz - p.zyx - p.xzy, p.x + p.y + p.z);\n    vec4 E = -D.yxzw;\n\n    vec4 abcd = max(max(A, B), max(C, D));\n\n    E.xy = max(E.xy, E.zw);\n    float e = max(E.x, E.y);\n\n    order(abcd.x, abcd.y);\n    order(abcd.y, abcd.z);\n    order(abcd.z, abcd.w);\n    order(abcd.w, e);\n\n    abcd.xy = max(abcd.xy, abcd.zw);\n\n    vec2 dp = tau * p.w + vec2(max(abcd.x, abcd.y), e);\n\n    dp = min(dp, 1.0f);\n    float a1 = acos(dp.x);\n    float a2 = acos(dp.y);\n    float e_sdf = 0.75f * (a1 + a2 - 0.274f);\n    float v_sdf = a2 - 0.051f;\n    return smin(e_sdf, v_sdf, 0.005f);\n}\n\nfloat dodecaplex_face_sdf(vec4 p)\n{\n    p = bounce(p);\n\n    vec4 c = vec4(ksi, -ksi, nu, -nu);\n\n    vec4 A = p.x * c.yxyx + p.y * c.wzzw;\n    vec4 B = p.y * c.xyyx + p.z * c.zzww;\n    vec4 C = p.z * c.yyxx + p.x * c.zwzw;\n    vec4 D = chi * vec4(p.yxz - p.zyx - p.xzy, p.x + p.y + p.z);\n    vec4 E = -D.yxzw;\n\n    vec4 abcd = max(max(A, B), max(C, D));\n\n    E.xy = max(E.xy, E.zw);\n    float e = max(E.x, E.y);\n\n    order(abcd.x, abcd.y);\n    order(abcd.y, abcd.z);\n    order(abcd.z, abcd.w);\n    order(abcd.w, e);\n\n    abcd.xy = max(abcd.xy, abcd.zw);\n\n    vec2 dp = tau * p.w + vec2(max(abcd.x, abcd.y), e);\n\n    dp = min(dp, 1.0f);\n    float a1 = acos(dp.x);\n    float a2 = acos(dp.y);\n    float e_sdf = 0.75f * (a1 + a2 - 0.274f);\n    float v_sdf = a2 - 0.051f;\n    float sdf1 = smin(e_sdf, v_sdf, 0.005f);\n\n    /* face sdf */\n    vec3 q = abs(p.xyz);\n    vec3 r = psi * q.xyz + 0.5f * q.zxy;\n\n    vec2 dp1 = vec2(phi * p.w + max(r.x, max(r.y, r.z)), p.w);\n\n    dp1 = min(dp1, 1.0f);\n    float l1 = acos(dp1.x);\n    float l2 = acos(dp1.y);\n    float f_sdf = 0.5f * (l1 - l2 - 0.014f);\n    float b_sdf = 0.334f - l2;\n    float sdf2 = max(f_sdf, b_sdf);\n\n    id = step(sdf2, sdf1);\n    return min(sdf1, sdf2);\n}\n\nfloat dodecaplex_dual_tetraplex_sdf(vec4 p)\n{\n    p = bounce(p);\n\n    vec4 c = vec4(ksi, -ksi, nu, -nu);\n\n    vec4 A = p.x * c.yxyx + p.y * c.wzzw;\n    vec4 B = p.y * c.xyyx + p.z * c.zzww;\n    vec4 C = p.z * c.yyxx + p.x * c.zwzw;\n    vec4 D = chi * vec4(p.yxz - p.zyx - p.xzy, p.x + p.y + p.z);\n    vec4 E = -D.yxzw;\n\n    vec4 abcd = max(max(A, B), max(C, D));\n\n    E.xy = max(E.xy, E.zw);\n    float e = max(E.x, E.y);\n\n    order(abcd.x, abcd.y);\n    order(abcd.y, abcd.z);\n    order(abcd.z, abcd.w);\n    order(abcd.w, e);\n\n    abcd.xy = max(abcd.xy, abcd.zw);\n\n    vec2 dp = tau * p.w + vec2(max(abcd.x, abcd.y), e);\n\n    dp = min(dp, 1.0f);\n    float a1 = acos(dp.x);\n    float a2 = acos(dp.y);\n    float e_sdf = 0.75f * (a1 + a2 - 0.274f);\n    float v_sdf = a2 - 0.051f;\n    float sdf1 = 0.219f - a2;\n    float sdf2 = smin(e_sdf, v_sdf, 0.005f);\n    id = step(sdf1, sdf2);\n    return min(sdf1, sdf2);\n}\n\nfloat sdf(vec4 p)\n{\n    /* SIMPLEX */\n    //return dual_simplex_sdf(p);\n    //return simplex_sdf(p);\n    //return simplex_dual_simplex_sdf(p);\n\n    /* TESSERACT */\n    //return dual_orthoplex_sdf(p);\n    //return tesseract_sdf(p);\n    //return tesseract_dual_orthoplex_sdf(p);\n\n    /* ORTHOPLEX */\n    //return dual_tesseract_sdf(p);\n    //return orthoplex_sdf(p);\n    //return orthoplex_dual_tesseract_sdf(p);\n\n    /* OCTAPLEX */\n    //return dual_octaplex_sdf(p);\n    //return octaplex_sdf(p);\n    //return octaplex_dual_octaplex_sdf(p);\n\n    /* DODECAPLEX */\n    //return dual_tetraplex_sdf(p);\n    return dodecaplex_sdf(p);\n    //return dodecaplex_face_sdf(p);\n    //return dodecaplex_dual_tetraplex_sdf(p);\n\n    /* TETRAPLEX */\n    //return dual_dodecaplex_sdf(p);\n    //return tetraplex_sdf(p);\n    //return tetraplex_face_sdf(p);\n    //return tetraplex_dual_dodecaplex_sdf(p);\n}\n\n/* ambient occlusion : from this website */\nfloat ambient_occlusion(vec4 p, vec4 n)\n{\n    const float step = 0.0117f;\n    const float scale = 7.5f;\n\n    float s = 0.0f;\n    float decay = 1.0f;\n\n    for (int i = 1; i < 9; ++i)\n    {\n        float theta = step * i;\n\n        /* should be q = cos(theta) * p + sin(theta) * n\n           but for small theta cos(theta) ~ 1, sin(theta) ~ theta\n           and non-uniform steps along normal is acceptable and\n           may even be better than uniform */\n\n        vec4 q = normalize(p + n * theta);\n        s += (theta - sdf(q)) * decay;\n\n        decay *= 0.75f;\n    }\n\n    return max(1.0f - scale * s, 0.0f);\n}\n\n//==============================================================================================================================================================\n//   SDF gradient :: 4-point tetrahedral evaluation\n//\n//   A good thing is that 3-sphere is a parallelizable manifold, so that at any point\n// one can explicitly specify tangent basis triple, which smoothly varies with the point\n//\n//   Such a basis for example is: { p*i, p*j, p*k }\n//==============================================================================================================================================================\nvec4 spherical_gradient4(vec4 p)\n{\n    const float eps = 0.0525f;\n\n    vec4 pi = mulr_i(p);\n    vec4 pj = mulr_j(p);\n    vec4 pk = mulr_k(p);\n\n    float v0 = sdf(normalize(p + eps * (+ pi - pj - pk)));\n    float v1 = sdf(normalize(p + eps * (- pi - pj + pk)));\n    float v2 = sdf(normalize(p + eps * (- pi + pj - pk)));\n    float v3 = sdf(normalize(p + eps * (+ pi + pj + pk)));\n\n    vec3 g = normalize(\n        vec3(\n              v0 - v1 - v2 + v3,\n            - v0 - v1 + v2 + v3,\n            - v0 + v1 - v2 + v3\n        )\n    );\n\n    return g.x * pi + g.y * pj + g.z * pk;\n}\n\n//==============================================================================================================================================================\n//   SDF gradient :: standard 6-point evaluation\n//==============================================================================================================================================================\nvec4 spherical_gradient6(vec4 p)\n{\n    const float eps = 0.0125f;\n\n    vec4 pi = mulr_i(p);\n    vec4 pj = mulr_j(p);\n    vec4 pk = mulr_k(p);\n\n    float norm = sqrt(1.0 + eps * eps);\n    float inv_norm = 1.0f / norm;\n    float f = eps * inv_norm;\n    vec4 pn = inv_norm * p;\n\n\n    float di = sdf(pn + f * pi) - sdf(pn - f * pi);\n    float dj = sdf(pn + f * pj) - sdf(pn - f * pj);\n    float dk = sdf(pn + f * pk) - sdf(pn - f * pk);\n\n    vec3 g = normalize(vec3(di, dj, dk));\n    return g.x * pi + g.y * pj + g.z * pk;\n}\n\nvec4 raymarch(vec4 origin, vec4 ray, out float dist)\n{\n    const float eps = 0.00005f;\n    dist = -1.0f;\n\n    vec4 p = origin;\n    float d = sdf(p);\n    float t = 0.0f;\n\n    while (t < two_pi && d > eps)\n    {\n        t += d;\n        p = cos(t) * origin + sin(t) * ray;\n        d = sdf(p);\n    }\n\n    if (d < eps)\n        dist = t;\n\n    return p;\n}\n\n/* p and n are assumed perpendicular and lie on the unit sphere */\nvec3 sample_tex4d(sampler2D sampler, vec4 p, vec4 n, out vec4 b)\n{\n    /* we use the same idea as the idea going around for 3d case --\n       sample in all planes and blend with appropriate weights */\n    const float scale = 7.0f;\n\n    /* we have 6 possible planes xy, yz, zw, wz, xz and yw */\n    vec3 rgb_xy = texture(sampler, scale * p.xy).rgb;\n    vec3 rgb_yz = texture(sampler, scale * p.yz).rgb;\n    vec3 rgb_zw = texture(sampler, scale * p.zw).rgb;\n    vec3 rgb_wx = texture(sampler, scale * p.wx).rgb;\n    vec3 rgb_xz = texture(sampler, scale * p.xz).rgb;\n    vec3 rgb_yw = texture(sampler, scale * p.yw).rgb;\n\n    vec3 normal_xy = texture(normal_tex, scale * p.xy).rgb;\n    vec3 normal_yz = texture(normal_tex, scale * p.yz).rgb;\n    vec3 normal_zw = texture(normal_tex, scale * p.zw).rgb;\n    vec3 normal_wx = texture(normal_tex, scale * p.wx).rgb;\n    vec3 normal_xz = texture(normal_tex, scale * p.xz).rgb;\n    vec3 normal_yw = texture(normal_tex, scale * p.yw).rgb;\n\n    /* projections of the area element spanned by vectors p and n\n       onto 6 coordinates planes are */\n\n    vec3 area_012 = p.xyz * n.yzw - p.yzw * n.xyz; /* xy, yz and zw */\n    vec3 area_345 = p.wxy * n.xzw - p.xzw * n.wxy; /* wx, xz and yw */\n\n    /* when the shaded fragment position { x, y, z, w } varies, it varies in such a way\n       that the differential in the neighbourhood stays orthogonal to both n and p directions,\n       so samples in 'perpendicular' planes should obtain higher weights, which means, in terms\n       of areas, the lower the area the higher should be the weight\n\n       also note, that sum of squares of elements of area_012 and area_345 should\n       add to 1 = the square of the area element spanned by p and n\n    */\n\n    const float tau = 7.0f;\n    area_012 = exp(-tau * area_012 * area_012);\n    area_345 = exp(-tau * area_345 * area_345);\n\n    vec4 X = vec4(area_012.xy + area_345.yz, area_012.z, area_345.x);\n    vec4 Y = vec4(area_345.x, area_012.x, area_012.yz + area_345.yz);\n\n    X -= dot(X, p) * p;\n    X -= dot(X, n) * n;\n    X = normalize(X);\n\n    Y -= dot(Y, p) * p;\n    Y -= dot(Y, n) * n;\n    Y = normalize(Y);\n\n    float w = dot(area_012 + area_345, vec3(1.0f));     /* total weight */\n    float inv_w = 1.0f / w;\n\n    vec3 Q = inv_w * (area_012.x * normal_xy +\n                      area_012.y * normal_yz +\n                      area_012.z * normal_zw +\n                      area_345.x * normal_wx +\n                      area_345.y * normal_xz +\n                      area_345.z * normal_yw);\n\n    b = (Q.x - 0.5f) * X + (Q.y - 0.5f) * Y + Q.z * n;\n    b = normalize(b);\n\n    return inv_w * (area_012.x * rgb_xy +\n                    area_012.y * rgb_yz +\n                    area_012.z * rgb_zw +\n                    area_345.x * rgb_wx +\n                    area_345.y * rgb_xz +\n                    area_345.z * rgb_yw);\n}\n\nconst int LIGHT_COUNT = 8;\n\nconst vec4 light_ws[LIGHT_COUNT] = vec4[]\n(\n    vec4( 0.0f,  0.0f,  0.0f,  1.0f),\n    vec4( 1.0f,  0.0f,  0.0f,  0.0f),\n    vec4( 0.0f,  1.0f,  0.0f,  0.0f),\n    vec4( 0.0f,  0.0f,  1.0f,  0.0f),\n    vec4( 0.0f,  0.0f,  0.0f, -1.0f),\n    vec4(-1.0f,  0.0f,  0.0f,  0.0f),\n    vec4( 0.0f, -1.0f,  0.0f,  0.0f),\n    vec4( 0.0f,  0.0f, -1.0f,  0.0f)\n);\n\nfloat DistributionGGX(float cos_phi, float roughness)\n{\n    float a = roughness * roughness;\n    float a_sqr = a * a;\n    float cos_phi_sqr = cos_phi * cos_phi;\n    float q = (cos_phi_sqr * (a_sqr - 1.0f) + 1.0f);\n    return a_sqr / (pi * q * q);\n}\n\nfloat GeometrySchlickGGX(float cos_angle, float roughness)\n{\n    float r = 1.0f + roughness;\n    float k = 0.125f * r * r;\n    return cos_angle / (cos_angle * (1.0f - k) + k);\n}\n\nfloat GeometrySmith(float cos_theta, float cos_gamma, float roughness)\n{\n    return GeometrySchlickGGX(cos_theta, roughness) * GeometrySchlickGGX(cos_gamma, roughness);\n}\n\nvec3 fresnel_schlick(float cos_alpha, vec3 F0)\n{\n    return F0 + (1.0f - F0) * pow(1.0f - cos_alpha, 5.0f);\n}\n\nvec3 fresnel_schlick_roughness(float cos_theta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cos_theta, 5.0);\n}\n\nconst vec3 albedo_silver   = vec3(0.971519f, 0.959915f, 0.915324f);\nconst vec3 albedo_copper   = vec3(0.955008f, 0.637427f, 0.538163f);\nconst vec3 albedo_gold     = vec3(1.000000f, 0.765557f, 0.336057f);\nconst vec3 albedo_chromium = vec3(0.549585f, 0.556114f, 0.554256f);\nconst vec3 albedo_nickel   = vec3(0.659777f, 0.608679f, 0.525649f);\nconst vec3 albedo_titanium = vec3(0.541931f, 0.496791f, 0.449419f);\nconst vec3 albedo_cobalt   = vec3(0.662124f, 0.654864f, 0.633732f);\nconst vec3 albedo_platinum = vec3(0.672411f, 0.637331f, 0.585456f);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 1.83f * (fragCoord - 0.5f * iResolution.xy) / iResolution.y;\n\n    float t = 0.5f * iTime;\n\n    float t0 = 0.375f * t -  0.213f;\n    float t1 = 0.151f * t +  2.091f;\n    float t2 = 0.253f * t - 11.512f;\n    float t3 = 0.853f * t +  3.277f;\n\n    float c0 = cos(t0);\n    float s0 = sin(t0);\n    float c1 = cos(t1);\n    float s1 = sin(t1);\n    float c2 = cos(t2);\n    float s2 = sin(t2);\n    float c3 = cos(t3);\n    float s3 = sin(t3);\n\n    /* if anyone knows how to smoothly fly through without entering areas\n       with sdf < 0 let me know */\n\n    vec4 camera_ws = vec4(-c1 * s0, s1 *  c0 * s2, c0 * c2, s0 * s1);\n    camera_ws = normalize(camera_ws);\n\n    vec4 X = mulr_i(camera_ws);\n    vec4 Y = mulr_j(camera_ws);\n\n    vec4 camera_X =  c3 * X + s3 * Y;\n    vec4 camera_Y = -s3 * X + c3 * Y;\n    vec4 camera_Z = mulr_k(camera_ws);\n\n    vec4 view_ray = uv.x * camera_X + uv.y * camera_Y - camera_Z;\n    view_ray = normalize(view_ray);\n\n    float dist;\n    vec4 position = raymarch(camera_ws, view_ray, dist);\n    vec3 color = vec3(0.0f);\n\n    if (dist >= 0.0f)\n    {\n        /*\n           normal, view, and light vectors should be tangent at 'position' point on the sphere\n           for the light calculations to make sense, which actually means that they must be normal\n           to 'position' viewed as 4-vectors\n\n           !! view_ray can not be used as a view vector because it is tangent at 'camera_ws'\n           point, but we need a vector tangent at 'position' point\n        */\n\n        bool dual = id > 0.0f;                      /* save the value as normal computation will modify it */\n        vec4 normal = spherical_gradient6(position);\n        \n        vec4 b;\n        float roughness;\n        float metalness;\n        \n        vec3 rgb = sample_tex4d(iChannel0, iChannel1, position, normal, \n            b, roughness, metalness);\n\n        // albedo_silver\n        // albedo_gold\n        // albedo_copper\n        // albedo_chromium\n        // albedo_nickel\n        // albedo_titanium\n        // albedo_cobalt\n        // albedo_platinum\n        \n        vec3 metal_albedo = dual ? albedo_gold : albedo_copper;\n        vec3 albedo = mix(metal_albedo, rgb, roughness);\n        normal = b;\n\n        /* some pseudo-scientific computations from online OpenGL pbr tutorials */\n        vec3 F0 = vec3(0.04f);\n        F0 = mix(F0, albedo, metalness);\n\n        vec4 view = normalize(camera_ws - dot(camera_ws, position) * position);\n        float ao = ambient_occlusion(position, normal);\n        float cos_gamma = clamp(dot(normal, view), 0.0f, 1.0f);\n\n        vec3 F = fresnel_schlick_roughness(cos_gamma, F0, roughness);\n        vec3 kS = F;\n        vec3 kD = 1.0f - kS;\n        kD *= 1.0f - metalness;\n        \n        /* TODO :: raymarch in the normal direction to get environment color */\n        vec3 diffuse = albedo;\n        vec3 specular = 0.45f * F + 0.05f;\n        vec3 ambient = 0.171f * exp(-2.27f * dist) * ao * (kD * diffuse + specular);\n\n        /* for now ambient term looks like a crap, something to be done here, \n           or, since the final result is more or less acceptable, maybe ambient term\n           should be like this ? */\n           \n        color = ambient;                            \n        vec3 R = vec3(0.0f);                        /* will accumulate inputs from all light sources */\n        \n        for (int i = 0; i < LIGHT_COUNT; ++i)\n        {\n            vec4 light = light_ws[i];\n            float dp = dot(light, position);\n            light = light - dp * position;\n            light = normalize(light);\n            vec4 h = normalize(light + view);       /* should be orthogonal to position as both light and view are */\n\n            vec3 radiance = vec3(1.0f);             /* light color */\n            float intensity = 1.07f * (0.5f + 0.5f * dp) * exp(-2.47f * dist);\n\n            float cos_theta = clamp(dot(normal, light), 0.0f, 1.0f);\n            float cos_alpha = clamp(dot(h, view), 0.0f, 1.0f);\n            float cos_phi   = clamp(dot(normal, h), 0.0f, 1.0f);\n\n            float NDF = DistributionGGX(cos_phi, roughness);\n            float G = GeometrySmith(cos_theta, cos_gamma, roughness);\n            vec3 F = fresnel_schlick(cos_alpha, F0);\n            vec3 specular = (NDF * G * F) / (4.0f * cos_gamma * cos_theta + 0.001f);\n\n            vec3 kS = F;\n            vec3 kD = vec3(1.0f) - kS;\n            kD *= 1.0f - metalness;\n\n            R += (inv_pi * kD * albedo + specular) * radiance * (intensity * cos_theta);\n        }\n        \n        color += R;\n       \n        //color = ambient;\n        //color = diffuse;\n        //color = specular;\n        //color = vec3(roughness);\n        //color = vec3(metalness);\n    }\n\n    /* everyone does it, i will do it also */\n    color = color / (1.0f + color);\n    color = sqrt(color);\n\n    fragColor = vec4(color, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n/* ============================== normal generation ============================== */\n\nconst vec3 rgb_power = vec3(0.299f, 0.587f, 0.114f);\n\nfloat luminosity(sampler2D sampler, vec2 uv, int lod)\n{\n    return dot(textureLod(sampler, uv, float(lod)).rgb, rgb_power);\n}\n\nvec3 symm_diff(sampler2D sampler, vec2 uv, int lod)\n{\n    const float amplitude = 2.7f;\n    \n    vec2 texel_size = 1.0f / vec2(textureSize(iChannel0, lod));\n\n    vec2 uv0 = uv;\n    vec2 uvp = uv + texel_size;\n    vec2 uvm = uv - texel_size;\n\n    float b = luminosity(sampler, vec2(uv0.x, uvm.y), lod);             /* bottom */\n    float l = luminosity(sampler, vec2(uvm.x, uv0.y), lod);             /* left   */\n    float r = luminosity(sampler, vec2(uvp.x, uv0.y), lod);             /* right  */\n    float t = luminosity(sampler, vec2(uv0.x, uvp.y), lod);             /* top    */\n\n    vec2 dL = vec2(r - l, t - b);\n    vec3 n = vec3(amplitude * dL, 1.0);\n    return normalize(n);\n}\n\nconst int MAX_LOD = 8;\nconst float lod_intensity[MAX_LOD] = float[]\n(\n    1.001f,\n    2.774f,\n    2.549f,\n    1.363f,\n    0.924f,\n    0.673f,\n    0.297f,\n    0.125f\n);\n\n/* ============================== roughness generation ============================== */\nconst float two_pi = 6.28318530717958648f;\n\nfloat hash(uint a, uint b, uint q)\n{\n    a *= uint(9629);\n    b *= uint(7853);\n    a += uint(10709) * q;\n    b += uint(11311) * q;    \n    a = (a ^ uint(61)) ^ b;\n    b = b + (a << 3);\n    a = a ^ (b >> 4);\n    b = a * uint(0x27d4eb2d);\n    a = b ^ (a >> 15);\n    a = a & uint(0xFFFF);\n    return float(a) / 65535.0;\n}\n\nconst float roughness_intensity[MAX_LOD] = float[]\n(\n    0.075f,\n    0.374f,\n    0.949f,\n    1.263f,\n    0.724f,\n    0.373f,\n    0.102f,\n    0.057f\n);\n\nfloat roughness(sampler2D sampler, vec2 uv, int lod)\n{\n    const float amplitude = 140.0f;\n    \n    float h = hash(uint(uv.x * iResolution.x), uint(uv.y * iResolution.y), uint(lod));\n    float alpha = two_pi * h;\n    \n    vec2 texel_size = 3.781f * vec2(cos(alpha), sin(alpha)) / vec2(textureSize(iChannel0, lod));\n\n    vec2 uv0 = uv;\n    vec2 uvp = uv + h * texel_size;\n    vec2 uvm = uv - h * texel_size;\n    \n    float c = luminosity(sampler, uv, lod);                             /* center */\n\n    float b = luminosity(sampler, vec2(uv0.x, uvm.y), lod);             /* bottom */\n    float l = luminosity(sampler, vec2(uvm.x, uv0.y), lod);             /* left   */\n    float r = luminosity(sampler, vec2(uvp.x, uv0.y), lod);             /* right  */\n    float t = luminosity(sampler, vec2(uv0.x, uvp.y), lod);             /* top    */\n\n    float q = min(\n                 min(abs(b - c), abs(l - c)),\n                 min(abs(r - c), abs(t - c))\n              );\n\n    return amplitude * q;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 A = normalize(texture(iChannel0, uv, 16.0f).rgb);\n    vec3 T = texture(iChannel0, uv).rgb;  \n    \n    /* ==================================================== */\n    vec3 n = vec3(0.0f);\n    \n    for (int l = 0; l < MAX_LOD; ++l)\n        n += lod_intensity[l] * symm_diff(iChannel0, uv, l);\n    \n    n = normalize(n);\n\n    /* ==================================================== */\n    const float min_r = 0.05f;\n    float r = 0.0f;\n    for (int l = 0; l < MAX_LOD; ++l)\n        r += roughness_intensity[l] * roughness(iChannel0, uv, l);\n\n    r *= length(A - T);\n    r = (min_r + r) / (1.0f + r);\n    \n    /* ==================================================== */\n    float max_m = 0.97f;\n    float m = max_m * pow(1.0f - r, 2.2f);\n\n    fragColor = vec4(0.5f + 0.5f * n.x, 0.5f + 0.5f * n.y, r, m);\n    //fragColor = vec4(0.5f + 0.5f * n, 1.0f);\n    //fragColor = vec4(vec3(r), 1.0f);\n    //fragColor = vec4(vec3(m), 1.0f);\n}","name":"Buffer A","description":"","type":"buffer"}]}