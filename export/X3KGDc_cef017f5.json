{"ver":"0.1","info":{"id":"X3KGDc","date":"1718333751","viewed":42,"name":"ray_tracing_8","username":"shanebenlolo","description":"djflksadjf","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float random_double(vec2 seed) {\n    return fract(sin(dot(seed.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvec3 random_vec3(vec2 seed) {\n    // Generates a random vec3 with each component between 0 and 1\n    return vec3(\n        random_double(seed),\n        random_double(seed + vec2(1.0, 0.0)),\n        random_double(seed + vec2(0.0, 1.0))\n    );\n}\n\nvec3 random_vec3_range(vec2 seed, float min, float max) {\n    // Generates a random vec3 with each component between min and max\n    return vec3(\n        mix(min, max, random_double(seed)),\n        mix(min, max, random_double(seed + vec2(1.0, 0.0))),\n        mix(min, max, random_double(seed + vec2(0.0, 1.0)))\n    );\n}\n\nvec3 random_in_unit_sphere(vec2 seed) {\n    while (true) {\n        vec3 p = random_vec3_range(seed, -1.0, 1.0);\n        if (dot(p, p) < 1.0) {  // equivalent to p.length_squared() < 1 in C++\n            return p;\n        }\n        seed += vec2(1.0);  // Modify seed to get a new random vector\n    }\n}\n\nvec3 random_on_hemisphere (vec3 normal, vec3 random_in_unit_sphere){\n    if(dot(random_in_unit_sphere, normal) > 0.0) {\n        return random_in_unit_sphere;\n    } else{\n        return random_in_unit_sphere * -1.0;\n\n    }\n}\n\nvec3 ray_color (vec3 ray){\n    return 0.5*(ray + vec3(1.0));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Aspect ratio correction for ray direction\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    // Normalized pixel coordinates to center the screen at (0,0)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Camera setup\n    vec3 cameraPos = vec3(0.0, 0.0, 0.0);\n    vec3 rayDir = normalize(vec3(uv, 1.0)); \n\n    // Sphere properties\n    vec3 sphereCenter = vec3(0.0, 0.0, 5.0);\n    float sphereRadius = 1.0;\n    \n    // ground properties\n    vec3 groundCenter = vec3(0.0, -100.0,25.0);\n    float groundRadius = 100.0;\n\n    vec3 lightPos = vec3(5.0, -5.0, -10.0);\n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n    vec4 objects[2] = vec4[](\n        vec4(groundCenter, groundRadius),\n        vec4(sphereCenter, sphereRadius)\n    );\n    \n    bool hitObject = false;\n    \n    // Ray-sphere intersection for all objects\n    for (int i = 0; i < 2; i++) {\n        vec3 objectCenter = objects[i].xyz;\n        float objectRadius = objects[i].w;\n\n        vec3 oc = cameraPos - objectCenter; // offset of camera (oc)\n        float b = dot(oc, rayDir);\n        float c = dot(oc, oc) - objectRadius * objectRadius;\n        float discriminant = b * b - c;\n\n        if (discriminant > 0.0) {\n            float dist = -b - sqrt(discriminant);\n            if (dist > 0.0) { // ensure the instersection is in front of camera\n              hitObject = true;    \n               \n               vec3 hitPoint = cameraPos + rayDir * dist;\n               vec3 normal = normalize(hitPoint - objectCenter); \n              \n               vec3 random_in_unit_sphere = normalize(random_in_unit_sphere(uv));\n               vec3 direction = random_on_hemisphere(normal, random_in_unit_sphere);\n               \n               \n               vec3 finalColor = ray_color(normal);\n               \n               fragColor = vec4(finalColor, 1.0); \n            } else {\n                fragColor = vec4(0.0, 0.0, 0.0, 1.0); // Background color if no hit\n            }\n        } \n    \n    }\n    \n    // fill in background where ray did not hit objects\n    if(hitObject == false){\n      vec3 a = 0.5*vec3(rayDir.y + 1.0);\n      vec3 bgColor = (1.0-a)*vec3(1.0) + a*vec3(0.5, 0.7, 1.0);\n      fragColor = vec4(bgColor, 1.0); // Background color if no intersection\n}\n}\n","name":"Image","description":"","type":"image"}]}