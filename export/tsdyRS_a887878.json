{"ver":"0.1","info":{"id":"tsdyRS","date":"1601205540","viewed":146,"name":"17 - Sea of Distortion","username":"Krabcode","description":"Can't make a good looking 3D scene? Just do a glitchy plane instead! Learn this one simple sinewave trick! Raymarching programmers hate him!!!","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sin","glitch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Made with love by Krabcode\n\n// Based on Ray Marching for Dummies!\"\n// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/XlGBW3\n\n\nconst int MAX_STEPS = 200;\nconst float MAX_DIST = 500.;\nconst float SURF_DIST = 0.001;\nconst float NORMAL_DIST = 0.05;\nconst float SHININESS = 2.;\nconst float PI = 3.14159;\n\nfloat time; \nvec2 uv;\nvec2 lightOffset; \nvec3 lightPos;\n\nfloat rayLength;\nfloat closestDist;\nfloat hitDist;\nvec3 hit;\nvec3 intersect;\n\nmat2 rotate(float a){\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdSphere(vec3 p, float radius)\n{\n    return length(p)-radius;\n}\n\nfloat sdf(vec3 p){ \n    p.y = 1.-abs(p.y);\n    float wave = .15*sin(p.x*-0.05+p.z+p.z*13.15+p.y+time);    \n    return p.y+5.+wave;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) \n{\n    float dO=0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO;\n        float dS = sdf(p);\n        closestDist = min(dS, closestDist);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 normal(vec3 p) \n{\n    float d = sdf(p);\n    vec2 e = vec2(NORMAL_DIST, 0);\n    vec3 n = d - vec3(\n        sdf(p-e.xyy),\n        sdf(p-e.yxy),\n        sdf(p-e.yyx));\n    return normalize(n);\n}\n\nfloat diffuseLight(vec3 p, vec3 normal) \n{\n    vec3 l = normalize(lightPos-p);\n    float dif = clamp(dot(normal, l), 0., 1.);\n    float d = rayMarch(p+normal*SURF_DIST*2., l);\n    if(d<length(lightPos-p)){ dif *= .1; }\n    return dif;\n}\n\n\nfloat specularLight(vec3 p, vec3 rayDir, vec3 normal) {\n    vec3 lightDir = normalize(p-lightPos);\n    vec3 reflectionDirection = reflect(-lightDir, normal);\n    float specularAngle = max(dot(reflectionDirection, rayDir), 0.);\n    return pow(specularAngle, SHININESS);\n}\n\nfloat render(vec2 uv)\n{\n    vec3 rayOrigin = vec3(uv*0.1, 0);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, 1.));\n    hitDist = rayMarch(rayOrigin, rayDir);\n    hit = rayOrigin + rayDir * hitDist;\n    vec3 normal = normal(hit);\n    float diff = diffuseLight(hit, normal);   \n    float spec = specularLight(hit, rayDir, normal);\n    return .5*diff + .5*spec;\n}\n\nvec3 gammaCorrection(vec3 rgb){\n    float gamma = 2.2;\n    rgb = smoothstep(0., 1., rgb);\n    return pow(max(rgb, 0.), vec3(1.0/gamma));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = float(iFrame)*.0025;\n    lightPos = vec3(0,10,1000);\n    uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float lit = render(uv);\n    lit *= smoothstep(MAX_DIST, MAX_DIST*.1, hitDist);\n    fragColor = vec4(gammaCorrection(vec3(lit)),1.0);\n}\n","name":"Image","description":"","type":"image"}]}