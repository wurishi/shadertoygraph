{"ver":"0.1","info":{"id":"NdVcDw","date":"1654977278","viewed":189,"name":"CG_Rain","username":"helgust","description":"Little homework for cg course","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["rain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float PI = acos(-1.0);\n\nfloat rnd(float t) {\n\n  return fract(sin(t*745.523)*7894.552);\n\n}\n\nfloat rain(vec3 p) {\n\n  p.y -= iTime*4.0;\n  p.xy *= 60.0;\n  \n  p.y += rnd(floor(p.x))*80.0;\n  \n  return clamp(1.0-length(vec2(cos(p.x * PI), sin(p.y*0.1) - 1.7)), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float CAMERA_RADIUS = 17.0;\n    vec3 cameraPos = vec3(sin(iTime * 0.2) * CAMERA_RADIUS, 7.5, cos(iTime * 0.2) * CAMERA_RADIUS);\n    vec3 targetPoint = vec3(0, 0, 0);\n    vec3 front = normalize(targetPoint - cameraPos);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = cross(right, front);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy / 2.0) / iResolution.x;\n    vec3 viewVec = normalize(front + up * uv.y + right * uv.x);\n    \n    fragColor = texture(iChannel2, fragCoord / iResolution.xy);\n    \n    // cameraPos.y + viewVec.y * t = 0.2;\n    float t = (0.2 - cameraPos.y) / viewVec.y;\n    vec3 worldPos = cameraPos + viewVec * t;\n    \n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    \n    //raindrops\n    vec2 u = fragCoord / iResolution.xy,\n         n = texture(iChannel2, u * .1).rg;  // Displacement\n    fragColor = textureLod(iChannel0, u, 2.5);\n     // Loop through the different inverse sizes of drops\n    for (float r = 4. ; r > 0. ; r--) {\n        vec2 x = iResolution.xy * r * .055,  // Number of potential drops (in a grid)\n             p = 6.28 * u * x + (n - .5) * 4.,\n             s = sin(p);\n        \n        // Current drop properties. Coordinates are rounded to ensure a\n        // consistent value among the fragment of a given drop.\n        vec4 d = texture(iChannel2, round(u * x - 0.25) / x);\n        \n        // Drop shape and fading\n        float t = (s.x+s.y) * max(0., 1. - fract(iTime * (d.b + .1) + d.g) * 2.);;\n        \n        // d.r -> only x% of drops are kept on, with x depending on the size of drops\n        if (d.r < (5.-r)*.08 && t > .5) {\n            // Drop normal\n            vec3 v = normalize(-vec3(cos(p), mix(.2, 2., t-.5)));\n            // fragColor = vec4(v * 0.5 + 0.5, 1.0);  // show normals\n            \n            // Poor man's refraction (no visual need to do more)\n            fragColor = texture(iChannel0, u - v.xy * .3);\n        }\n    }\n         \n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tfloat dis = 1.;\n\tfor (int i = 0; i < 12; i++)\n\t{\n\t\tvec3 plane = cameraPos + viewVec * dis;\n\t\t//plane.z -= (texture(iChannel3, q*iTime).x*3.5);\n\t\t//if (plane.z < vHitPos.z)\n        if(true)\n\t\t{\n\t\t\tfloat f = pow(dis, .45)+.25;\n\n\t\t\tvec2 st =  f * (q * vec2(1.5, .05)+vec2(-iTime*.1+q.y*.5, iTime*.12));\n\t\t\tf = (texture(iChannel2, st * .5, -99.0).x + texture(iChannel2, st*.284, -99.0).y);\n\t\t\tf = clamp(pow(abs(f)*.5, 29.0) * 140.0, 0.00, q.y*.4+.05);\n\n\t\t\tvec3 bri = vec3(.55);\n\t\t\tfragColor.xyz += bri*f;\n\t\t}\n\t\tdis += 3.5;\n\t}\n\tfragColor = clamp(fragColor, 0.0, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float landSDF(vec3 pos) {\n    return pos.y;\n}\n\nvec3 calcNormal( in vec3 p) // for function f(p)\n{\n    const float h = 0.1; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*landSDF( p + k.xyy*h ) + \n                      k.yyx*landSDF( p + k.yyx*h) + \n                      k.yxy*landSDF( p + k.yxy*h) + \n                      k.xxx*landSDF( p + k.xxx*h ) );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 calcNormalBox( in vec3 p, vec3 b) // for function f(p)\n{\n    const float h = 0.001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sdBox( p + k.xyy*h, b ) + \n                      k.yyx*sdBox( p + k.yyx*h, b) + \n                      k.yxy*sdBox( p + k.yxy*h, b) + \n                      k.xxx*sdBox( p + k.xxx*h, b ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float CAMERA_RADIUS = 17.0;\n    vec3 cameraPos = vec3(sin(iTime * 0.2) * CAMERA_RADIUS, 7.5, cos(iTime * 0.2) * CAMERA_RADIUS);\n    vec3 targetPoint = vec3(0, 0, 0);\n    vec3 front = normalize(targetPoint - cameraPos);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = cross(right, front);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy / 2.0) / iResolution.x;\n    vec3 viewVec = normalize(front + up * uv.y + right * uv.x);\n    \n    fragColor = texture(iChannel2, fragCoord / iResolution.xy);\n    \n    // cameraPos.y + viewVec.y * t = 0.2;\n    float t = (0.2 - cameraPos.y) / viewVec.y;\n    vec3 worldPos = cameraPos + viewVec * t;\n    if (t < 30.0) {\n        for (int i = 0; i < 30; ++i) {\n            if (landSDF(worldPos) < 0.0) {\n                break;\n            }\n            t += 0.05;\n            worldPos = cameraPos + viewVec * t;\n        }\n        vec3 normal = calcNormal(worldPos);\n        vec3 n1 = normalize(texture(iChannel1, worldPos.xz * 0.2).xyz * 2.0 - 1.0);\n        if (dot(n1, normal) < 0.0) {\n            n1 = -n1;\n        }\n\n        float spec = pow(max(dot(reflect(normalize(normal + n1), vec3(0, 1, 0)), viewVec), 0.0), 64.0);\n        if (spec > 0.0) {\n            normal = normalize(normal + n1);\n        }\n\n        vec3 snowColor = vec3(0.8, 0.8, 0.8);\n        float diffuse = max(normal.y, 0.0) * 0.5;\n\n        vec3 H = normalize(vec3(0, 1, 0) + normal * 0.6);\n        vec3 VdotH = pow(max(0.0, dot(viewVec, -H)), 0.25) * 0.25 * snowColor;\n\n        float height = texture(iChannel0, worldPos.xz * 0.05).x;\n\n        // Output to screen\n        fragColor = vec4(diffuse * snowColor + VdotH + spec,1.0);\n    }\n    \n    const float MARCH_SIZE = 0.05;\n    float boxT = 0.0;\n    vec3 currentPos;\n    bool intFound = false;\n    bool tex = false;\n    float size = 0.0;\n    vec3 color;\n    vec3 normal;\n    for (int i = 0; i < 700; ++i) {\n        if (boxT > t) {\n            break;\n        }\n        boxT += MARCH_SIZE;\n        currentPos = cameraPos + viewVec * boxT;\n        if (sdBox(currentPos, vec3(1, 1, 1)) < 0.0) {\n            intFound = true;\n            size = 1.0;\n            color = vec3(0.5, 0.1, 0.1);\n            normal = calcNormalBox(currentPos, vec3(1, 1, 1));\n            break;\n        }\n        \n        if (sdBox(currentPos - vec3(4.0, 0, 0), vec3(1, 2, 1)) < 0.0) {\n            intFound = true;\n            size = 2.0;\n            color = vec3(0.0, 0.6, 0.0);\n            normal = calcNormalBox(currentPos - vec3(4.0, 0, 0), vec3(1, 2, 1));\n            break;\n        }\n        \n        if (sdBox(currentPos - vec3(0.0, 0, 4.0), vec3(2, 1, 1)) < 0.0) {\n            intFound = true;\n            size = 1.0;\n            color = vec3(0.0, 1.0, 0.8);\n            normal = calcNormalBox(currentPos - vec3(0.0, 0.0, 4.0), vec3(2, 1, 1));\n            break;\n        }\n    }\n    if (intFound) {\n        fragColor.xyz = color * (normal.y + 0.5) / 1.5;\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}