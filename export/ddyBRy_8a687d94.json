{"ver":"0.1","info":{"id":"ddyBRy","date":"1698532519","viewed":533,"name":"HEAVENLY CREATURE","username":"alro","description":"\"Yonder cloud\nThat rises upward always higher,\nAnd onward drags a laboring breast,\nAnd topples round the dreary west,\nA looming bastion fringed with fire.\"\n- Alfred, Lord Tennyson","likes":53,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarch","cloud","light","volumetric","cubemap","bloom","glow","stars","scattering","data","rabbit"],"hasliked":0,"parentid":"dsKfWR","parentname":"UNSTABLE FLAME"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Further adventures in texture storage and volumetric rendering. \n    Use mouse to move camera.\n\n    Using blackle's excellent rabbit SDF: https://www.shadertoy.com/view/wtVyWK\n    Inspired by https://www.shadertoy.com/view/tdjBR1\n    \n    Store both main density and density along the light ray in Cubemap A\n    We then do not need the expensive inner sampling loop when we render in Buffer B\n    The tradeoff is that the shape is static but the surface could still be\n    moved if light rays do not need detail.\n    \n    There are 2 more channels in the cubemap which allow us to either increase\n    the resolution or add more variables such as colour or ambient lighting.\n    \n    See Common tab for resolution and light sampling constants\n\n    EDIT: Force a second render in frame 10 to fix CubemapA loading error\n\n*/\n\nconst float bloomStrength = 0.5;\n\n//-------------------------------- Bicubic blur --------------------------------\n\n// https://www.shadertoy.com/view/Dl2SDW\n\n// Cubic B-spline weighting\nvec2 w0(vec2 a){\n    return (1.0/6.0)*(a*(a*(-a + 3.0) - 3.0) + 1.0);\n}\n\nvec2 w1(vec2 a){\n    return (1.0/6.0)*(a*a*(3.0*a - 6.0) + 4.0);\n}\n\nvec2 w2(vec2 a){\n    return (1.0/6.0)*(a*(a*(-3.0*a + 3.0) + 3.0) + 1.0);\n}\n\nvec2 w3(vec2 a){\n    return (1.0/6.0)*(a*a*a);\n}\n\n// g0 is the amplitude function\nvec2 g0(vec2 a){\n    return w0(a) + w1(a);\n}\n\n// h0 and h1 are the two offset functions\nvec2 h0(vec2 a){\n    return -1.0 + w1(a) / (w0(a) + w1(a));\n}\n\nvec2 h1(vec2 a){\n    return 1.0 + w3(a) / (w2(a) + w3(a));\n}\n\nvec4 bicubic(sampler2D tex, vec2 uv, vec2 textureLodSize, float lod){\n\t\n    uv = uv * textureLodSize + 0.5;\n    \n\tvec2 iuv = floor(uv);\n\tvec2 f = fract(uv);\n\n    // Find offset in texel\n    vec2 h0 = h0(f);\n    vec2 h1 = h1(f);\n\n    // Four sample points\n\tvec2 p0 = (iuv + h0 - 0.5) / textureLodSize;\n\tvec2 p1 = (iuv + vec2(h1.x, h0.y) - 0.5) / textureLodSize;\n\tvec2 p2 = (iuv + vec2(h0.x, h1.y) - 0.5) / textureLodSize;\n\tvec2 p3 = (iuv + h1 - 0.5) / textureLodSize;\n\t\n    // Weighted linear interpolation\n    // g0 + g1 = 1 so only one is needed for a mix\n    vec2 g0 = g0(f);\n    return mix( mix(textureLod(tex, p3, lod), textureLod(tex, p2, lod), g0.x),\n                mix(textureLod(tex, p1, lod), textureLod(tex, p0, lod), g0.x), g0.y);\n}\n\nvec4 textureBicubic(sampler2D s, vec2 uv, float lod) {\n\n    vec2 lodSizeFloor = vec2(textureSize(s, int(lod)));\n    vec2 lodSizeCeil = vec2(textureSize(s, int(lod + 1.0)));\n\n    vec4 floorSample = bicubic(s, uv, lodSizeFloor.xy, floor(lod));\n    vec4 ceilSample = bicubic(s, uv, lodSizeCeil.xy, ceil(lod));\n\n    return mix(floorSample, ceilSample, fract(lod));\n}\n\nvec4 getBlur(sampler2D s, vec2 uv, float blur){\n    float maxLod = floor(log2(iChannelResolution[0].x));\n    float lod = mix(0.0, maxLod-1.0, blur);\n    return textureBicubic(s, uv, lod);\n}\n\n//----------------------------- Tonemapping and output ------------------------------\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n\n    if(bloomStrength > 0.0){\n        vec3 bloom = getBlur(iChannel0, uv, 0.2).rgb;\n        bloom += getBlur(iChannel0, uv, 0.3).rgb;\n        bloom += getBlur(iChannel0, uv, 0.55).rgb;\n        bloom += getBlur(iChannel0, uv, 0.6).rgb;\n        bloom /= 4.0;\n        col += bloomStrength * bloom;\n    }\n    \n    // Tonemapping\n    col = ACESFilm(col);\n    \n    // Gamma\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n    Copyright (c) 2023 al-ro\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\n\n#define PI 3.14159\n#define TWO_PI (2.0 * PI)\n\n// Side length of domain\n// Max 184 as we use 4 channnels of a 1024 cubemap\n// For single channel data the max would be 293\nconst uint width = 184u;\nconst uint maxIdx = width * width * width;\nconst vec3 scale = vec3(width);\n\n// For light ray density marching\n// Restart to see effects after change\nconst uint lightSteps = 32u;\nconst float lightRayDistance = float(width);\nconst float stepL = lightRayDistance / float(lightSteps);\nconst vec3 sunDirection = normalize(vec3(0, 1, -0.5));\n\n\nfloat saturate(float x){\n\treturn clamp(x, 0.0, 1.0);\n}\n\nfloat remap(float x, float low1, float high1, float low2, float high2){\n\treturn low2 + (x - low1) * (high2 - low2) / (high1 - low1);\n}\n\nvec3 remap(vec3 x, vec3 low1, vec3 high1, vec3 low2, vec3 high2){\n\treturn low2 + (x - low1) * (high2 - low2) / (high1 - low1);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// ----------------- Data lookup -----------------\n\nvec3 idxToPoint(uint idx){\n    return min(scale, vec3(idx % width, \n                           uint(float(idx)/float(width)) % width, \n                           uint(float(idx)/float(width * width))));\n}\n\nuint pointToIdx(vec3 p){\n    p = clamp(p, vec3(0), scale-1.0);\n    return uint(p.z * float(width * width) + p.y * float(width) + p.x);\n}\n\nvec3 idxToDir(uint idx){\n       \n    uint face = uint(float(idx)/float(1024u * 1024u));\n    vec2 fragCoord = vec2(idx % 1024u, uint(float(idx)/float(1024u)) % 1024u) + 0.5;\n    vec2 uv = 2.0 * (fragCoord/1024.0) - 1.0;\n\n    vec3 rayDir;\n    switch(face){\n        case 0u: rayDir = vec3( 1,  -uv.yx); break;\n        case 1u: rayDir = vec3(-1,  -uv.y, uv.x); break;\n        case 2u: rayDir = vec3(uv.x,   1,  uv.y); break;\n        case 3u: rayDir = vec3(uv.x,  -1,  -uv.y); break;\n        case 4u: rayDir = vec3(uv.x, -uv.y,  1); break;\n        case 5u: rayDir = vec3(-uv,  -1);  break;\n    }\n\n    return rayDir;\n}\n\nvec4 getDataInterpolated(vec3 p, samplerCube s){\n    p += vec3(0.5 * scale);\n    p = clamp(p, vec3(0), scale-1.0);\n\n    vec3 f = fract(p);\n    vec3 c = floor(p);\n            \n    return mix( mix(  mix(texture(s, idxToDir(pointToIdx(c+vec3(0,0,0)))), \n                          texture(s, idxToDir(pointToIdx(c+vec3(1,0,0)))), f.x),\n                      mix(texture(s, idxToDir(pointToIdx(c+vec3(0,1,0)))), \n                          texture(s, idxToDir(pointToIdx(c+vec3(1,1,0)))), f.x), f.y),\n                 mix( mix(texture(s, idxToDir(pointToIdx(c+vec3(0,0,1)))), \n                          texture(s, idxToDir(pointToIdx(c+vec3(1,0,1)))), f.x),\n                      mix(texture(s, idxToDir(pointToIdx(c+vec3(0,1,1)))), \n                          texture(s, idxToDir(pointToIdx(c+vec3(1,1,1)))), f.x), f.y), f.z);\n}\n\nvec4 getData(vec3 p, samplerCube s){\n    p += vec3(0.5 * scale);\n    p = clamp(p, vec3(0), scale-1.0);\n    return texture(s, idxToDir(pointToIdx(floor(p))));\n}\n\n//-------------------------- AABB -------------------------\n\n// https://gist.github.com/DomNomNom/46bb1ce47f68d255fd5d\n// Compute the near and far intersections using the slab method.\n// No intersection if tNear > tFar.\nvec2 intersectAABB(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {\n    vec3 tMin = (boxMin - rayOrigin) / rayDir;\n    vec3 tMax = (boxMax - rayOrigin) / rayDir;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    return vec2(tNear, tFar);\n}\n\nbool insideAABB(vec3 p, vec3 boxMin, vec3 boxMax){\n    float eps = 1e-4;\n\treturn  (p.x > boxMin.x-eps) && (p.y > boxMin.y-eps) && (p.z > boxMin.z-eps) && \n\t\t\t(p.x < boxMax.x+eps) && (p.y < boxMax.y+eps) && (p.z < boxMax.z+eps);\n}\n\nbool testAABB(vec3 org, vec3 dir, vec3 boxMin, vec3 boxMax){\n    return insideAABB(org, boxMin, boxMax);\n\tvec2 intersections = intersectAABB(org, dir, boxMin, boxMax);\n\t\n    if(insideAABB(org, boxMin, boxMax)){\n        intersections.x = 1e-4;\n    }\n    \n    return intersections.x > 0.0 && (intersections.x < intersections.y);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Track mouse movement and resolution change between frames and set camera position.\n\n#define CAMERA_DIST 5.3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Work with just the first four pixels.\n    if((fragCoord.x == 0.5) && (fragCoord.y < 4.0)){\n        \n        vec4 oldData = texelFetch(iChannel0, ivec2(0.5), 0).xyzw;\n\n        vec2 oldPolarAngles = oldData.xy;\n        vec2 oldMouse = oldData.zw;\n\n        vec2 polarAngles = vec2(0);\n        vec2 mouse = iMouse.xy / iResolution.xy; \n        \n        // Stop camera going directly above and below\n        float angleEps = 0.01;\n\n        float mouseDownLastFrame = texelFetch(iChannel0, ivec2(0.5, 3.5), 0).x;\n        \n        // If mouse button is down and was down last frame.\n        if(iMouse.z > 0.0 && mouseDownLastFrame > 0.0){\n            // Difference between mouse position last frame and now.\n            vec2 mouseMove = mouse - oldMouse;\n            polarAngles = oldPolarAngles + vec2(5.0, 3.0) * mouseMove;\n            \n        }else{\n            polarAngles = oldPolarAngles;\n        }\n        \n        polarAngles.x = mod(polarAngles.x, 2.0 * PI - angleEps);\n        polarAngles.y = min(PI - angleEps, max(angleEps, polarAngles.y));\n\n        // Store mouse data in the first pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 0.5)){\n            // Set value at first frames.\n            if(iFrame < 10){\n                polarAngles = vec2(0.2, 1.5);\n                mouse = vec2(0);\n            }\n            \n            // Set value at first frames.\n            fragColor = vec4(polarAngles, mouse);\n        }\n\n        // Store camera position in the second pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 1.5)){\n            // Cartesian direction from polar coordinates.\n            vec3 cameraPos = normalize(vec3(-cos(polarAngles.x) * sin(polarAngles.y), \n                                             cos(polarAngles.y), \n                                            -sin(polarAngles.x) * sin(polarAngles.y)));\n\n            fragColor = vec4(CAMERA_DIST * cameraPos, 1.0);\n        }\n        \n        // Store resolution change data in the third pixel of Buffer B.\n        if(fragCoord == vec2(0.5, 2.5)){\n            float resolutionChangeFlag = 0.0;\n            // The resolution last frame.\n            vec2 oldResolution = texelFetch(iChannel0, ivec2(0.5, 2.5), 0).yz;\n            \n            if(iResolution.xy != oldResolution){\n            \tresolutionChangeFlag = 1.0;\n            }\n            \n        \tfragColor = vec4(resolutionChangeFlag, iResolution.xy, 1.0);\n        }\n           \n        // Store whether the mouse button is down in the fourth pixel of Buffer A\n        if(fragCoord == vec2(0.5, 3.5)){\n            if(iMouse.z > 0.0){\n            \tfragColor = vec4(vec3(1.0), 1.0);\n            }else{\n            \tfragColor = vec4(vec3(0.0), 1.0);\n            }\n        }\n        \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n\n    Render cloud by raymarching a volume and sampling from Cubemap A\n    See https://www.shadertoy.com/view/3sffzj for more details about cloud lighting\n    \n*/\n\n// Scattering coefficient based on Earth's atmosphere but tweaked for this look\nconst vec3 BETA_RAYLEIGH = 100.0 * vec3(0.05802, 0.14558, 0.331);\nconst vec3 BETA_OZONE = vec3(0.650, 1.881, 0.085);\n\n// Scattering\nconst vec3 sigmaS = 3.0 * BETA_RAYLEIGH;\n// Absorption\nconst vec3 sigmaA = 2.0 * (BETA_RAYLEIGH + 3.0 * BETA_OZONE);\n// Extinction\nconst vec3 sigmaE = sigmaA + sigmaS;\n\n// Main light strength\nconst float power = 128.0;\n\nconst float starStrength = 0.1;\n\nconst float densityMultiplier = 0.2;\nconst float lightDensityMultiplier = 0.15;\n\n// Raymarching\nconst int STEPS = 32;\n\n// -------------------- Camera --------------------\n\nvec3 rayDirection(float fieldOfView, vec2 fragCoord, vec2 resolution) {\n    vec2 xy = fragCoord - resolution / 2.0;\n    float z = (0.5 * resolution.y) / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n// https://www.geertarien.com/blog/2017/07/30/breakdown-of-the-lookAt-function-in-OpenGL/\nmat3 lookAt(vec3 targetDir, vec3 up){\n  vec3 zaxis = normalize(targetDir);    \n  vec3 xaxis = normalize(cross(zaxis, up));\n  vec3 yaxis = normalize(cross(xaxis, zaxis));\n\n  return mat3(xaxis, yaxis, -zaxis);\n}\n\n//-------------------------------- Lighting --------------------------------\n\nfloat HenyeyGreenstein(float g, float costh){\n\treturn (1.0 / (4.0 * 3.1415))  * ((1.0 - g * g) / pow(1.0 + g*g - 2.0*g*costh, 1.5));\n}\n\n// https://twitter.com/FewesW/status/1364629939568451587/photo/1\nvec3 multipleOctaves(float extinction, float mu){\n\n    vec3 luminance = vec3(0);\n    const float octaves = 6.0;\n    \n    // Attenuation\n    float a = 1.0;\n    // Contribution\n    float b = 1.0;\n    // Phase attenuation\n    float c = 1.0;\n    \n    float phase;\n    \n    for(float i = 0.0; i < octaves; i++){\n        // Two-lobed HG\n        phase = mix(HenyeyGreenstein(-0.1 * c, mu), HenyeyGreenstein(0.3 * c, mu), 0.7);\n        luminance += b * phase * exp(-stepL * extinction * sigmaE * a);\n        // Lower is brighter\n        a *= 0.3;\n        // Higher is brighter\n        b *= 0.5;\n        c *= 0.5;\n    }\n    return luminance;\n}\n\n// Get the amount of light that reaches a sample point.\nvec3 lightRay(vec3 org, vec3 p, float phaseFunction, float mu){\n\n\tfloat lightRayDensity = lightDensityMultiplier * getDataInterpolated(p, iChannel1).r;\n    \n\tvec3 beersLaw = multipleOctaves(lightRayDensity, mu);\n\t\n    // Return product of Beer's law and powder effect depending on the \n    // view direction angle with the light direction.\n\treturn mix(beersLaw * 2.0 * (1.0 - (exp( -stepL * lightRayDensity * 2.0 * sigmaE))), \n               beersLaw, \n               0.5 + 0.5 * mu);\n}\n\n\n//-------------------------------- Raymarching --------------------------------\n\nvec4 cloud(vec3 p){\n    return getDataInterpolated(p, iChannel1);\n}\n\n// Get the colour along the view ray.\nvec3 marchCloud(vec3 org, vec3 dir, inout vec3 totalTransmittance, float totalDistance, float dither){\n    \n    org *= 0.5 * scale;\n    totalDistance *= 0.5 * float(width);\n\t// Variable to track transmittance along view ray. \n    // Assume clear sky and attenuate light when encountering clouds.\n\ttotalTransmittance = vec3(1.0);\n\n\t// Default to black.\n\tvec3 colour = vec3(0.0);\n    \n    // The distance at which to start ray marching.\n    float distToStart = 0.0;\n    \n\t// Sampling step size.\n    float stepS = totalDistance / float(STEPS); \n    \n    // Offset the starting point by blue noise.\n    distToStart += stepS * dither;\n    \n    // Track distance to sample point.\n    float dist = distToStart;\n\n    // Initialise sampling point.\n    vec3 p = org + dist * dir;\n    \n    float mu = dot(dir, sunDirection);\n\n    // Combine backward and forward scattering to have details in all directions.\n\tfloat phaseFunction = mix(HenyeyGreenstein(-0.3, mu), HenyeyGreenstein(0.3, mu), 0.7);\n    \n    vec3 sunLight = vec3(1);\n\n\tfor(int i = 0; i < STEPS; i++){\n\n        vec4 data = cloud(p);\n        \n        float density = densityMultiplier * data.a;\n\n        vec3 sampleSigmaS = sigmaS * density;\n        vec3 sampleSigmaE = sigmaE * density;\n\n        // If there is a cloud at the sample point.\n        if(density > 0.0 ){\n           \n            vec3 ambient = vec3(0.08) * smoothstep(0.025, -0.03, density) + starStrength * data.ggg;\n            \n            // Scale ambient by the density at the sample point\n            ambient *= smoothstep(1e-3, 8e-3, density);\n\n            // Amount of sunlight that reaches the sample point through the cloud \n            // is the combination of ambient light and attenuated direct light.\n            vec3 luminance = ambient + \n                    sunLight * phaseFunction * power * lightRay(org, p, phaseFunction, mu);\n\n            // Scale light contribution by density of the cloud.\n            luminance *= sampleSigmaS;\n\n            // Beer-Lambert.\n            vec3 transmittance = exp(-sampleSigmaE * stepS);\n\n            // Better energy conserving integration\n            // \"From Physically based sky, atmosphere and cloud rendering in Frostbite\" 5.6\n            // by Sebastian Hillaire.\n            colour += totalTransmittance * (luminance - luminance * transmittance) / sampleSigmaE; \n\n            // Attenuate the amount of light that reaches the camera.\n            totalTransmittance *= transmittance;  \n\n            // If ray combined transmittance is close to 0, nothing beyond this sample \n            // point is visible, so break early.\n            if(length(totalTransmittance) <= 0.001){\n                totalTransmittance = vec3(0.0);\n                break;\n            }\n        }\n\n        dist += stepS;\n\n\t\t// Step along ray.\n\t\tp = org + dir * dist;\n\t}\n\n\treturn colour;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    //----------------- Define a camera -----------------\n\n    // Get the default direction of the ray (along the negative Z direction)\n    vec3 rayDir = rayDirection(25.0, fragCoord, iResolution.xy);\n\n\n    vec3 cameraPos = texelFetch(iChannel0, ivec2(0.5, 1.5), 0).xyz;\n    vec3 targetDir = -cameraPos;\n    vec3 up = vec3(0.0, 1.0, 0.0);\n\n    // Get the view matrix from the camera orientation\n    mat3 viewMatrix = lookAt(targetDir, up);\n\n    // Transform the ray to point in the correct direction\n    rayDir = normalize(viewMatrix * rayDir);\n\n    //---------------------------------------------------\n\n    vec3 col = 0.05 * vec3(0.25, 0.3, 0.35);\n    vec3 data;\n\n    vec2 intersections = intersectAABB(cameraPos, rayDir, vec3(-1.0, -1.0, -1.0)-(1.0 / scale), \n                                                          vec3(1.0, 1.0, 1.0)+(1.0 / scale));\n    if(intersections.x < intersections.y){\n        vec3 totalTransmittance = vec3(1);\n   \n        float dither = 0.0;\n        const float goldenRatio = 1.61803398875;\n        if(iChannelResolution[2].xy == vec2(1024)){\n            float blueNoise = texture(iChannel2, fragCoord / 1024.0).r;\n            dither = fract(blueNoise + float(iFrame%32) * goldenRatio);\n        }\n        \n        data = marchCloud(  cameraPos + rayDir * max(0.0, intersections.x), \n                            rayDir,\n                            totalTransmittance,\n                            intersections.y - intersections.x,\n                            dither);\n        \n        col = mix(data, col, totalTransmittance);\n    }\n\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"/*\n\n    Store signed distance field in the first frame in the alpha channel.\n    Find density along light ray in the second frame and store it in the red channel.\n    Store some glow gradients for stars in the green channel.\n    Second to fourth frames mix surrounding data to get rid of voxel artefacts.\n    From the on copy data every frame.\n\n*/\n\n// Does exactly what it says. Compile and reset timer to see change.\nconst bool eightRabbits = false;\n\n\n//-------------------------------- Shape --------------------------------\n\n// A neural representation of the Stanford rabbit taken from https://www.shadertoy.com/view/wtVyWK\n// Can be replaced with any arbitrary shape\nfloat getSDF(vec3 p) {\n    if(eightRabbits){\n        p = mod(p*2.0, 1.0);\n    }\n    // Flip, position and scale the rabbit\n    p = p.xzy;\n    p -= vec3(0.55, 0.47, 0.435);\n    p *= 1.325;\n    \n\n    // What follows is sinister magic not meant for mortal minds\n    \n    if (length(p) > 1.0) {\n        return length(p) - 0.8;\n    }\n\n    vec4 f00=sin(p.y*vec4(-3.02,1.95,-3.42,-.60)+p.z*vec4(3.08,.85,-2.25,-.24)-p.x*\n    vec4(-.29,1.16,-3.74,2.89)+vec4(-.71,4.50,-3.24,-3.50));\n    vec4 f01=sin(p.y*vec4(-.40,-3.61,3.23,-.14)+p.z*vec4(-.36,3.64,-3.91,2.66)-p.x*\n    vec4(2.90,-.54,-2.75,2.71)+vec4(7.02,-5.41,-1.12,-7.41));\n    vec4 f02=sin(p.y*vec4(-1.77,-1.28,-4.29,-3.20)+p.z*vec4(-3.49,-2.81,-.64,2.79)-p.x*\n    vec4(3.15,2.14,-3.85,1.83)+vec4(-2.07,4.49,5.33,-2.17));\n    vec4 f03=sin(p.y*vec4(-.49,.68,3.05,.42)+p.z*vec4(-2.87,.78,3.78,-3.41)-p.x*\n    vec4(-2.65,.33,.07,-.64)+vec4(-3.24,-5.90,1.14,-4.71));\n    vec4 f10=sin(mat4(-.34,.06,-.59,-.76,.10,-.19,-.12,.44,.64,-.02,-.26,.15,-.16,.21,.91,.15)*f00+\n        mat4(.01,.54,-.77,.11,.06,-.14,.43,.51,-.18,.08,.39,.20,.33,-.49,-.10,.19)*f01+\n        mat4(.27,.22,.43,.53,.18,-.17,.23,-.64,-.14,.02,-.10,.16,-.13,-.06,-.04,-.36)*f02+\n        mat4(-.13,.29,-.29,.08,1.13,.02,-.83,.32,-.32,.04,-.31,-.16,.14,-.03,-.20,.39)*f03+\n        vec4(.73,-4.28,-1.56,-1.80))/1.0+f00;\n    vec4 f11=sin(mat4(-1.11,.55,-.12,-1.00,.16,.15,-.30,.31,-.01,.01,.31,-.42,-.29,.38,-.04,.71)*f00+\n        mat4(.96,-.02,.86,.52,-.14,.60,.44,.43,.02,-.15,-.49,-.05,-.06,-.25,-.03,-.22)*f01+\n        mat4(.52,.44,-.05,-.11,-.56,-.10,-.61,-.40,-.04,.55,.32,-.07,-.02,.28,.26,-.49)*f02+\n        mat4(.02,-.32,.06,-.17,-.59,.00,-.24,.60,-.06,.13,-.21,-.27,-.12,-.14,.58,-.55)*f03+\n        vec4(-2.24,-3.48,-.80,1.41))/1.0+f01;\n    vec4 f12=sin(mat4(.44,-.06,-.79,-.46,.05,-.60,.30,.36,.35,.12,.02,.12,.40,-.26,.63,-.21)*f00+\n        mat4(-.48,.43,-.73,-.40,.11,-.01,.71,.05,-.25,.25,-.28,-.20,.32,-.02,-.84,.16)*f01+\n        mat4(.39,-.07,.90,.36,-.38,-.27,-1.86,-.39,.48,-.20,-.05,.10,-.00,-.21,.29,.63)*f02+\n        mat4(.46,-.32,.06,.09,.72,-.47,.81,.78,.90,.02,-.21,.08,-.16,.22,.32,-.13)*f03+\n        vec4(3.38,1.20,.84,1.41))/1.0+f02;\n    vec4 f13=sin(mat4(-.41,-.24,-.71,-.25,-.24,-.75,-.09,.02,-.27,-.42,.02,.03,-.01,.51,-.12,-1.24)*f00+\n        mat4(.64,.31,-1.36,.61,-.34,.11,.14,.79,.22,-.16,-.29,-.70,.02,-.37,.49,.39)*f01+\n        mat4(.79,.47,.54,-.47,-1.13,-.35,-1.03,-.22,-.67,-.26,.10,.21,-.07,-.73,-.11,.72)*f02+\n        mat4(.43,-.23,.13,.09,1.38,-.63,1.57,-.20,.39,-.14,.42,.13,-.57,-.08,-.21,.21)*f03+\n        vec4(-.34,-3.28,.43,-.52))/1.0+f03;\n    f00=sin(mat4(-.72,.23,-.89,.52,.38,.19,-.16,-.88,.26,-.37,.09,.63,.29,-.72,.30,-.95)*f10+\n        mat4(-.22,-.51,-.42,-.73,-.32,.00,-1.03,1.17,-.20,-.03,-.13,-.16,-.41,.09,.36,-.84)*f11+\n        mat4(-.21,.01,.33,.47,.05,.20,-.44,-1.04,.13,.12,-.13,.31,.01,-.34,.41,-.34)*f12+\n        mat4(-.13,-.06,-.39,-.22,.48,.25,.24,-.97,-.34,.14,.42,-.00,-.44,.05,.09,-.95)*f13+\n        vec4(.48,.87,-.87,-2.06))/1.4+f10;\n    f01=sin(mat4(-.27,.29,-.21,.15,.34,-.23,.85,-.09,-1.15,-.24,-.05,-.25,-.12,-.73,-.17,-.37)*f10+\n        mat4(-1.11,.35,-.93,-.06,-.79,-.03,-.46,-.37,.60,-.37,-.14,.45,-.03,-.21,.02,.59)*f11+\n        mat4(-.92,-.17,-.58,-.18,.58,.60,.83,-1.04,-.80,-.16,.23,-.11,.08,.16,.76,.61)*f12+\n        mat4(.29,.45,.30,.39,-.91,.66,-.35,-.35,.21,.16,-.54,-.63,1.10,-.38,.20,.15)*f13+\n        vec4(-1.72,-.14,1.92,2.08))/1.4+f11;\n    f02=sin(mat4(1.00,.66,1.30,-.51,.88,.25,-.67,.03,-.68,-.08,-.12,-.14,.46,1.15,.38,-.10)*f10+\n        mat4(.51,-.57,.41,-.09,.68,-.50,-.04,-1.01,.20,.44,-.60,.46,-.09,-.37,-1.30,.04)*f11+\n        mat4(.14,.29,-.45,-.06,-.65,.33,-.37,-.95,.71,-.07,1.00,-.60,-1.68,-.20,-.00,-.70)*f12+\n        mat4(-.31,.69,.56,.13,.95,.36,.56,.59,-.63,.52,-.30,.17,1.23,.72,.95,.75)*f13+\n        vec4(-.90,-3.26,-.44,-3.11))/1.4+f12;\n    f03=sin(mat4(.51,-.98,-.28,.16,-.22,-.17,-1.03,.22,.70,-.15,.12,.43,.78,.67,-.85,-.25)*f10+\n        mat4(.81,.60,-.89,.61,-1.03,-.33,.60,-.11,-.06,.01,-.02,-.44,.73,.69,1.02,.62)*f11+\n        mat4(-.10,.52,.80,-.65,.40,-.75,.47,1.56,.03,.05,.08,.31,-.03,.22,-1.63,.07)*f12+\n        mat4(-.18,-.07,-1.22,.48,-.01,.56,.07,.15,.24,.25,-.09,-.54,.23,-.08,.20,.36)*f13+\n        vec4(-1.11,-4.28,1.02,-.23))/1.4+f13;\n    return dot(f00,vec4(.09,.12,-.07,-.03))+dot(f01,vec4(-.04,.07,-.08,.05))+\n        dot(f02,vec4(-.01,.06,-.02,.07))+dot(f03,vec4(-.05,.07,.03,.04))-0.16;\n}\n\n//-------------------------------- Detail --------------------------------\n\n// Noise for carving cloud surface detail\n\n// https://en.wikipedia.org/wiki/Gyroid\n// https://www.shadertoy.com/view/wddfDM\nfloat gyroid(vec3 p, float thickness, float bias, float frequency){\n    return clamp(abs(dot(sin(p*0.5), cos(p.zxy*1.23) * frequency) - bias) - thickness, 0.0, 3.0)/3.0;\n}\n\n// Gyroid noise based on https://www.shadertoy.com/view/3l23Rh\nfloat fbm(vec3 p){\n\n    const int octaves = 12;\n    const float fbmScale = 1.95;\n\n    // Rotation of the gyroid every iteration to produce a noise look\n    const float a = PI / float(octaves);\n    const mat3 m3 = fbmScale * mat3(cos(a), sin(a), 0, -sin(a), cos(a), 0, 0, 0, 1);\n\n\n    float weight = 0.0;\n    float amplitude = 1.0;\n    float frequency = 1.0;\n    float res = 0.0;\n    \n    for(int i = min(0, iFrame); i < octaves; i++){\n        res += amplitude * gyroid(p, 0.1, 0.0, frequency);\n        p *= m3;\n        weight += amplitude;\n        amplitude *= (i < 4 ? 0.9 : 0.7);\n        frequency *= 0.78;\n    }\n    \n    return saturate(res / weight);\n}\n\n//---------------------- Light density sampling -------------------------\n\n// Get orthonormal basis\n// https://graphics.pixar.com/library/OrthonormalB/paper.pdf\nvoid pixarONB(vec3 n, out vec3 b1, out vec3 b2){\n\tfloat sign_ = n.z >= 0.0 ? 1.0 : -1.0;\n\tfloat a = -1.0 / (sign_ + n.z);\n\tfloat b = n.x * n.y * a;\n\tb1 = vec3(1.0 + sign_ * n.x * n.x * a, sign_ * b, -sign_ * n.x);\n\tb2 = vec3(b, sign_ + n.y * n.y * a, -n.y);\n}\n\n// Collect total density along light ray\nfloat lightDensity(vec3 p){\n\tfloat lightRayDensity = 0.0;\n    \n    vec3 tangent;\n    vec3 bitangent;\n\n    pixarONB(sunDirection, tangent, bitangent);\n\n    tangent = normalize(tangent);\n    bitangent = normalize(bitangent);\n    \n\tfor(uint j = 0u; j < lightSteps; j++){\n        vec3 samplePoint = p + sunDirection * float(j) * stepL;\n        \n        // Disperse farther samples away from the light vector and reduce the strength of those samples\n        float dist = mix(0.0, 25.0, float(j) / float(lightSteps));\n        float weight = mix(1.0, 0.0, float(j) / float(lightSteps));\n        \n        vec2 rand = dist * (2.0 * hash33(samplePoint).xz - 1.0);\n        samplePoint += tangent * rand.x + bitangent * rand.y;\n        \n        // Do not read beyond the domain\n        if(insideAABB(samplePoint, -0.5 * scale, 0.5 * scale)){\n            lightRayDensity += weight * getDataInterpolated(samplePoint, iChannel0).a;\n        }\n\t}\n    return lightRayDensity;\n}\n\n//-------------------------------- Stars --------------------------------\n\nfloat getGlow(float dist, float radius, float intensity){\n    dist = max(dist, 1e-6);\n\treturn pow(radius/dist, intensity);\n}\n\n// Stars with random placement and strength\nfloat getStars(vec3 p){\n    p *= 0.02;\n    p += 80.0;\n    vec3 rand;\n    float d = 1e10;\n    vec3 cell;\n    \n    for(int x = -1; x <= 1; x++){\n        for(int y = -1; y <= 1; y++){\n            for(int z = -1; z <= 1; z++){\n                vec3 c = floor(p) + vec3(x, y, z);\n                vec3 h = hash33(c);\n                vec3 f = c + 0.5 + 0.5 * h;\n                float dd = length(p - f);\n                if(dd < d){\n                    d = dd;\n                    rand = h;\n                    cell = c;\n                }\n            }\n        }\n    }\n    rand = clamp(0.5 + 0.5 * rand, 0.0, 1.0);\n    vec3 rand2 = clamp(0.5 + 0.5 * hash33(cell+vec3(3.12, 104.9, -9.5)), 0.0, 1.0);\n    return  rand.z * \n            step(0.9, rand2.z) * \n            smoothstep(0.5, 0.0, d) * \n            min(getGlow(d, 0.5, 1.0), 256.0);\n}\n\n\n//-------------------------------- Storage --------------------------------\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir ){\n    \n    vec3 rd = abs(rayDir);\n\n    uint face;\n    if(rd.x > rd.y && rd.x > rd.z){\n        face = rayDir.x > 0.0 ? 0u : 1u;\n    }else if(rd.y > rd.z){\n        face = rayDir.y > 0.0 ? 2u : 3u;\n    }else{\n        face = rayDir.z > 0.0 ? 4u : 5u;\n    }\n\n    uint idx = face * 1024u * 1024u + uint(fragCoord.y) * 1024u + uint(fragCoord.x);\n    \n    if(idx < maxIdx){\n    \n        if(iFrame == 0 || iFrame == 10){\n\n            vec3 pos = idxToPoint(idx);\n            // Carve away density from cloud based on noise.\n            float cloud = getSDF(pos / float(width));\n            cloud = smoothstep(0.3, -0.1, cloud);\n            cloud = saturate(remap(cloud, 0.9 * (1.0 - fbm(pos / 8.0)), 1.0, 0.0, 0.15));\n            fragColor = vec4(cloud);\n\n        }else if(iFrame < 4 || (iFrame > 10 && iFrame < 14)){\n        \n            int frame = iFrame < 4 ? iFrame - 1 : iFrame - 11;\n        \n            // Sample neighbouring data to get rid of voxel artefacts and smooth the volume\n            // This also blurs the staggered sampling of the light density\n            vec3 pos = idxToPoint(idx)+mix(-0.5, 0.5, float(frame)/2.0) - 0.5 * scale;\n            fragColor = getDataInterpolated(pos, iChannel0);\n\n            if(iFrame == 1 || iFrame == 11){\n                float lightRayDensity = lightDensity(pos);\n                fragColor.r = lightRayDensity;\n                \n                // Stars\n                fragColor.g = getStars(3.5*pos + 17.51) + \n                              getStars(2.4*pos - 6.2) +\n                              getStars(3.7*pos + 109.9);\n            }\n\n        }else{\n            fragColor = texture(iChannel0, rayDir);\n       }\n    }else{\n       fragColor = vec4(0);\n    }\n}","name":"Cube A","description":"","type":"cubemap"}]}