{"ver":"0.1","info":{"id":"4stGD8","date":"1449364949","viewed":303,"name":"Bubbles space","username":"And390","description":"Geometry creates by simplex noise. You can enable morphing or shadows. Point lights, shadows and morphing are expensive.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","noise","light","shadows","simplex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// uncomment to enable\n//#define MORPHING 0.05\n//#define SHADOWS 1\n//#define DIRECT_LIGHT vec3(1.0, 1.0, -1.0)\n//#define BEND_PATH 1   //move on sin path\n#define NAVIGATE 1    //navigate in four directions around the bubbles\nconst float bubbleSize = 0.5;\nconst int lightsCount = 2;\nconst bool headlamp = false;  //additional light\nconst float lightPower = 0.8;\nconst float lightSpeed = 1.0;\nconst float epsilon = 0.0001;\n\n\nfloat simplex(vec3 v);\nfloat simplex(vec4 v);\n\nfloat noise(vec3 p) {\n    #ifdef MORPHING\n    \treturn simplex(vec4(p, iTime*MORPHING));\n    #else\n    \treturn simplex(p);\n    #endif\n}\n\nfloat map(vec3 p) {\n    // bubbles are less with simplex4d, so increase the size\n    #ifdef MORPHING\n    float finaBubblesSize = bubbleSize * 1.3;\n    #else\n    float finaBubblesSize = bubbleSize;\n    #endif\n    return noise(p) + (1.0 - finaBubblesSize);\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(epsilon, 0.0);\n    return normalize(vec3(map(p+e.xyy) - map(p-e.xyy),\n                          map(p+e.yxy) - map(p-e.yxy),\n                          map(p+e.yyx) - map(p-e.yyx)));\n}\n\nvec3 getLightPos(vec3 origin, int i) {\n    vec3 p = 1.0 * sin(lightSpeed * vec3(iTime*0.3, iTime*0.1, iTime*0.2) + 500.*vec3(i));\n    p.z += 1.2;\n    p.xy *= p.z / 2.;\n    return origin + p;\n}\n\nfloat mapLight(vec3 p, vec3 origin) {\n    float d = 1000.;\n    for (int i=0; i<lightsCount; i++)  d = min(d, length(p - getLightPos(origin, i)) - 0.05);\n    return d;\n}\n\nfloat mapAll(vec3 p, vec3 origin, out bool matchLight) {\n    float d = map(p);\n    if (d < epsilon) {\n        matchLight = false;\n        return d;\n    } else {\n        matchLight = true;\n        return min(d, mapLight(p, origin));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1. + 2.*uv;\n    \n    p.y /= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0., 0., 0.);  //view position\n    vec3 right = (vec3(1., 0., 0.));  //view direction\n    vec3 up = vec3(0., 1., 0.);\n    \n    //    move by z\n    float mz = 0.10;\n    ro.z += iTime * mz;\n    \n        #ifdef BEND_PATH\n    //    move by x\n    float mxa = 0.05;\n    float mxr = 4.;\n    ro.x += sin(iTime*mxa)*mxr;\n    float a = atan(cos(iTime*mxa)*mxr*mxa/mz);\n    right = vec3(right.z*sin(a)+right.x*cos(a), right.y, right.z*cos(a)-right.x*sin(a));  //rotate by y\n    up = vec3(up.z*sin(a)+up.x*cos(a), up.y, up.z*cos(a)-up.x*sin(a));  //rotate by y\n    \n    //    move by y\n    float mya = 0.10;\n    float myr = 4.;\n    ro.y += sin(iTime*mya)*myr;  \n    a = -atan(cos(iTime*mya)*myr*mya/mz);\n    right = vec3(right.x, right.y*cos(a)-right.z*sin(a), right.y*sin(a)+right.z*cos(a));  //rotate by x\n    up = vec3(up.x, up.y*cos(a)-up.z*sin(a), up.y*sin(a)+up.z*cos(a));  //rotate by x\n    #endif\n\n    //    move around the bubbles\n    vec3 origin = ro;\n    vec3 dir = cross(right, up);\n    #ifdef NAVIGATE\n    vec3 down = -up;\n    vec3 left = -right;\n    float turnK = 0.3;\n    for (int i=0; i<2; i++) {\n        float baseD = map(ro + dir);\n        if (baseD > 1.)  break;\n        float dUp = map(ro + dir + up) - baseD;\n        float dDown = map(ro + dir + down) - baseD;\n        float dLeft = map(ro + dir + left) - baseD;\n        float dRight = map(ro + dir + right) - baseD;    \n        ro += turnK * (1. - baseD) * \n            (up * dUp + down * dDown + left * dLeft + right * dRight);\n    }\n    #else\n    ro += up * noise(ro);  //simple navigation\n    #endif\n    \n    vec3 rd = p.x * right + p.y * up + dir;\n    \n    //    ray tracing\n    float tmax = 20.0;\n    float t = 0.0;  //distance from point of view\n    float dist;\n    bool open = false;\n    bool matchLight = false;    \n    for (int i=0; i<1000; i++) {\n        dist = mapAll(ro + t*rd, origin, matchLight);  //distance to target\n        if (dist<epsilon) {\n            if (open)  break;\n            else  t += epsilon + epsilon - dist/5.;\n        }\n        else {\n            open = true;\n            // different accuracy relate to distance\n            t += dist < 0.01 ? dist : dist < 0.1 ? dist/3. : dist/5.;\n        }\n        if (t > tmax)  break;\n    }\n    \n    //    lighting\n    vec3 col = vec3(0);\n    if (dist<epsilon) {\n        if (matchLight) {\n            col = vec3(1., 1., 1.);\n        }\n        else {\n            vec3 pos = ro + t*rd;\n            vec3 normal = calcNormal(pos);\n            float lightness = 0.0;\n            #ifdef DIRECT_LIGHT\n            {\n                vec3 lightDir = normalize(DIRECT_LIGHT);\n                lightness += dot(normal, lightDir);\n            }\n            #endif\n            for (int l=0; l<lightsCount + (headlamp ? 1 : 0); l++) {\n                vec3 lightPos = l==lightsCount ? ro+up/2. : getLightPos(origin, l);\n                vec3 lightDir = normalize(lightPos-pos);\n                float lightDist = length(lightPos-pos);\n                //if (lightDist >= lightDistance)  continue;\n                \n                // shadows\n                #ifdef SHADOWS\n                float t = epsilon+epsilon-dist;\n                float tmax = length(pos - lightPos);\n                for (int i=0; i<300; i++) {\n                    float dist = map(pos + t*lightDir);\n                    if (dist<epsilon)  break;\n                    else  t += dist < 0.01 ? dist : dist < 0.1 ? dist/3. : dist/5.;\n                    if (t > tmax)  break;\n                }\n                if (t > tmax)\n                #endif\n                {\n                     //float attenuation = pow(max(0.0, 1.0 - lightDist / lightDistance), lightDecay);\n                     float attenuation = min(1.0, lightPower / lightDist);\n                     lightness += dot(normal, lightDir) * attenuation;\n                     if (lightness > (1.0/0.6))  break;\n                }\n            }\n            col = vec3(1.0, 0.8, 0.6) * lightness;\n        }\n    }\n        \n    \n\tfragColor = vec4(col, 1.);\n}\n\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nfloat permute(float x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat taylorInvSqrt(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat simplex(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvec4 grad4(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n  return p;\n  }\n\t\t\t\t\t\t\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat simplex(vec4 v)\n  {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289(i); \n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) );\n\n  }","name":"","description":"","type":"image"}]}