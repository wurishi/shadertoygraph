{"ver":"0.1","info":{"id":"4cccz2","date":"1730864389","viewed":66,"name":"Alien Satellite","username":"akr51","description":"A massive extraterrestrial satellite that for some reason transforms into a ball of plasma","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","glow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThanks evvvvil_ for the twitch streams,\nThe Art of Code for the YouTube tutorials,\nNuSan FX for the streams on YouTube,\nflopine for further twitch streams\n\nlearning content above ^^^\n*/\n\n\n// number of scene objects\n#define NSO 3\n// iterations\n#define ITR 120\n// maximum ray distance\n#define DST 100.0\n// hit surface distance\n#define SRF 0.0001\n// rotation\n#define RT(X) mat2(cos(X), -sin(X), sin(X), cos(X))\n// PI\n#define PI acos(-1.0)\n// Epsilon for normal\n#define EPS vec2(0.00035, -0.00035)\n\n// globals\nfloat t = 0.0;\nfloat tt = 0.0;\nfloat g0 = 0.0;\n\n\nfloat box(vec3 sp, vec3 d)\n{\n\tsp = abs(sp) - d;\n\treturn max(max(sp.x, sp.y), sp.z);\n\t\n}\n\n// scene\nvec2 map(vec3 sp)\n{\n\tfloat dst[NSO];\n\n\tvec3 sp1 = sp;\n\tsp.xy *= RT(t * 0.25);\n\tsp.xz *= RT(t * 0.5);\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tsp = abs(sp) - vec3(3.0, 4.0, 0.0);\n\t\tsp.xz *= RT(float(i));\n\t\tsp1 = sp;\n\t\tsp.zy *= RT(23.3);\n\t\tsp.xy *= RT(24.0);\n\t\tsp1.zy *= RT(0.5);\n\t\tsp1.xy *= RT(0.5);\n\t}\n\t\n\tsp = mix(sp, sp1, tt);\n\tvec3 spc = sp;\n\tspc.y = 0.0;\n\tspc.xz *= RT(sp.y * 0.125);\n\tdst[0] = box(spc, vec3(5.0, 1.0, 1.0));\n\t\n\tvec3 spd = sp;\n\tspd.xz *= RT(sp.y * 0.125);\n\tspd.y = mod(spd.y + t, 4.0) - 2.0;\n\tdst[1] = box(abs(spd) - vec3(2, 0, 2), vec3(2.0, 0.25, 1.0));\n\n\tg0 += pow(0.35 / max(dst[1], 0.001), 3.0);\n\t\n\tvec3 spe = sp;\n\tspe.y = 0.0;\n\tspe.xz = abs(sp.xz) - vec2(2, 0);\n\tdst[2] = length(spe.xz) - 1.25;\n\n\tfloat id = 0.0;\n\tfor (int i = 1; i < NSO; i++)\n\t{\n\t\tif (dst[i] < dst[0])\n\t\t{\n\t\t\tdst[0] = dst[i];\n\t\t\tid = float(i);\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\treturn vec2(dst[0] * 0.7, id);\n}\n\n// ray marching loop\nvec2 mrch(vec3 ro, vec3 rd)\n{\n\tfloat d0 = 0.0;\n\tfloat id = 0.0;\n\tfor (int i = 0; i < ITR; i++)\n\t{\n\t\tvec3 sp = ro + rd * d0;\n\t\tvec2 ds = map(sp);\n\t\tif (d0 > DST || abs(ds.x) < SRF) break;\n\t\td0 += ds.x;\n\t\tid = ds.y;\n\t\t\n\t\t\n\t}\n\tif (d0 > DST) d0 = 0.0;\n\treturn vec2(d0, id);\n\t\n\t\n}\n\n\n// normal for lighting \nvec3 nml(vec3 sp)\n{\n\treturn normalize(EPS.xyy * map(sp + EPS.xyy).x + \n\t\t\t EPS.yyx * map(sp + EPS.yyx).x + \n\t\t         EPS.yxy * map(sp + EPS.yxy).x + \n\t\t         EPS.xxx * map(sp + EPS.xxx).x); \n\t\n\t\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 uu)\n{\n\tvec2 rr = iResolution.xy;\n    vec2 uv = (uu + uu - rr) / rr.y;\n\tuv *= 0.5;\n    \n    // time and animation\n\tt =  mod(iTime, 100.0 * PI);\n\ttt = clamp(sin(t * 0.5) * 2.0, 0.0, 1.0);\n\t\n    // camera\n\tvec3 ro = vec3(sin(t * 0.5) * 14.0, 0.5, -41.0);\n\tvec3 w = normalize(vec3(0) - ro);\n\tvec3 u = normalize(cross(w, vec3(0, 1, 0)));\n\tvec3 v = normalize(cross(u, w));\n\tvec3 rd = normalize(mat3(u, v, w) * vec3(uv, 0.25));\n\t\n    // ambience\n    vec3 amb = vec3(0.25, 0.22, 0.21);\n\t\n    // light position\n    vec3 lp = vec3(0.1, 0.6, -3.0);\n\t\n    // colors indexed by scene id\n\tvec3 clrs[NSO] = vec3[NSO](\n\t\tvec3(0.75, 0.75, 0.75),\n\t\tvec3(0.0),\n\t\tvec3(0.6)\n\t);\n\t\n    // march the scene\n\tvec2 sc = mrch(ro, rd); float d = sc.x; int id = int(sc.y);\n\t\n\tvec3 clr = vec3(0.0);\n\tvec3 fog = clr;\n    \n\tif (d > 0.0)\n\t{\n\t\t// select color by scene id (hardly noticable since mostly black is used.\n        amb = clrs[id];\n        // point of collision with surface\n\t\tvec3 sp = ro + rd * d;\n        // surface normal\n\t\tvec3 n = nml(sp);\n        // light direction\n\t\tvec3 ld = normalize(lp - sp);\n        // diffuse lighting\n\t\tfloat df = max(0.0, dot(n, ld));\n        // lighting taken from evvvvil_'s twitch stream\n        // specular\n\t\tfloat spc = pow(max(dot(reflect(-ld, n), -rd), 0.0), 30.0);\n\t\t// cheap ambient occlusion\n        float ar = d / DST;\n\t\tfloat ao = exp2(-2.0 * pow(max(0.0, 1.0 - map(sp + n * ar).x / ar), 2.0));\n\t\t// fresnel \n        float fr = pow(1.0 + dot(n, ld), 4.0);\n\t\tclr = mix(amb * (0.8 + ao * 0.2) * df + spc, fog, min(fr, 0.5));\n        // fog\n        clr = mix(clr, fog, 1.0 - exp(-0.0000003 * pow(d, 3.0)));\n    }\t\n\t\n\t// glow effect\n\tclr += g0 * mix(0.0, 1.0, tt) * vec3(0.25, 1.0, 0.25);\n\tfragColor = vec4(pow(clr, vec3(0.45)), 1.0);\n}","name":"Image","description":"","type":"image"}]}