{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define marchsteps 60\n\n#define scaleheight 5.0\n\n\nvec2 opU(vec2 a, vec2 b) {\n\treturn mix(a, b, step(b.x, a.x));\n}\n\nvec3 experimentalMap(vec3 p) {\n\tvec3 uvw=normalize(p);\n\tvec3 a1=texture(iChannel0, uvw.yz).xyz;\n\tvec3 a2=texture(iChannel0, uvw.zx).xyz;\n\tvec3 a3=texture(iChannel0, uvw.xy).xyz;\n//\treturn vec3( a1 + a2 + a3);\n\treturn vec3( a1*abs(uvw.x) + a2*abs(uvw.y) + a3*abs(uvw.z));\n}\n\n\nfloat sphere(vec3 p) {\n\tvec3 uvw= experimentalMap(p);\n\t\t\t\t\t\t\t\t\t\t\t \n\tfloat d=((uvw.x/3.+uvw.y/3.+uvw.z/3.)/3.)*(1./scaleheight);\n\t\n\treturn length(p) -1.0 -d;\n}\n\n\n\nvec2 map(vec3 p) {\n\tvec2 ret=vec2(100.0,0.0);\n\t\n\tret=opU(ret, vec2( sphere(p) , 1.0) );\n\n\n\treturn ret;\n}\n\nvec3 normal(vec3 p ) {\n\tvec3 e=vec3(0.01,-0.01,0.0);\n\treturn normalize( vec3(\te.xyy*map(p+e.xyy).x +\te.yyx*map(p+e.yyx).x +\te.yxy*map(p+e.yxy).x +\te.xxx*map(p+e.xxx).x));\n}\n\n// \t\t   ray ori\tray dir\t start    max dist steps  hit ori\nvec2 march(vec3 ro, vec3 rd, float s, float d, int e, out vec3 ho) {\n\tvec2 r=vec2(0.0);\n\tfor(int i=0; i<marchsteps; i++) {\n\t\tho=ro+rd*s;\n\t\tr=map(ho);\n\t        if((abs(r.x) < 0.01) || (r.x > d) || (i > e) || (r.y>0.5))  { break; }\n\t\ts+=r.x;\n\t}\n\tif (s >= d) { r.y=0.0; }\n\tr.x=s;\n\treturn r;\n}\n\nfloat cao(vec3 pos, vec3 nor ){\n\tfloat sca = 1.0;\n\tfloat totao = 0.0;\n\tfor (int i=0; i<5; i++) {\n        \tfloat hr = 0.01 + 0.05*float(i);\n        \tvec3 aopos =  nor * hr + pos;\n        \tfloat dd = map( aopos ).x;\n        \ttotao += -(dd-hr)*sca;\n        \tsca *= 0.75;\n    \t}\n    return clamp( totao, 0.0, 1.0 );\n}\n\n\nfloat csh(vec3 ro, vec3 rd, float t, float k ) {\n    float res = 1.0;\n    for( int i=0; i<10; i++ ) {\n    \tfloat h = map(ro + rd*t).x;\n        res = min( res, k*h/t );\n        t += h;\n\t}\n    return clamp(res,0.0,1.0);\n}\n\nvec3 shade(vec3 rgb, vec3 ro, vec3 rd, vec3 nor, vec3 lig, vec3 ho, float d ) {\n\tfloat amb =0.5;//*1./(d);\t\t\n\tfloat dif =0.5*clamp(dot(lig, nor), 0.0,1.0);\n\tfloat bac =0.2*clamp(dot(nor,-lig), 0.0,1.0);\n//\tfloat rim =0.3*pow(1.+dot(nor,rd), 5.0);\n//\tfloat spe =0.5*pow(clamp( dot( lig, reflect(rd,nor) ), 0.0, 1.0 ) ,32.0 );\n\tfloat ao=cao(ho, nor);\n\tfloat sh=csh(ho, lig, 0.01, 1.0);\n\t\n\tvec3 col  = (amb+dif+bac-ao+sh )*vec3(1.);\n\t\t col *= rgb;\n//\t\t col += (rim+spe)*vec3(1.);\n\n\t\n    return col;\n}\n\nvec3 getmat(vec2 o, vec3 uvw) {\n\tvec3 col=vec3(0.0);\n\tif (o.y==1.0) { \n\t\t\n\t\tvec3 uvw=experimentalMap(uvw);\n\t\tfloat d=((uvw.x/3.+uvw.y/3.+uvw.z/3.)/3.)*(1./scaleheight);\n\t\t\t\t// 0.0-1.0 *sch ->  0.0-> 0.2\n\n\t\tfloat f=(d*scaleheight)*5.;\n\n//to lazy for smoothsteps....\n\t\tif(d>0.0) col=vec3(0.0,0.0,1.0)*f;\t\t\n\t\tif(d>0.02) col=vec3(0.7,0.5,0.0)*f;\t\t\n\t\tif(d>0.03) col=vec3(0.0,0.1,0.0)*f;\t\t\n\t\tif(d>0.04) col=vec3(0.0,0.3,0.0)*f;\t\t\n\t\tif(d>0.07) col=vec3(0.5,0.5,0.5)*f;\t\t\n\t\tif(d>0.08) col=vec3(1.0,1.0,1.0)*f;\t\t\n\n\t\t\n\t}\n\n\treturn col;\t\n}\n\n\n\n\n\nvec3 getbg(vec3 rd) {\n\treturn vec3(0.0,0.0,0.0);\n}\n\nvec2 rot(vec2 k, float t) {\n    return vec2(cos(t)*k.x-sin(t)*k.y,sin(t)*k.x+cos(t)*k.y);\n}\n\n\nvoid animate(inout vec3 ta, inout vec3 ro, inout vec3 lig) {\n\tfloat t=iTime*0.027;\n\t\n\tvec2 move=iMouse.xy/iResolution.xy;\n\tro.z+=move.y;\n\n\n\tro.xz=rot(ro.xz, t );\n\t\n\tlig.xz=rot(lig.xz, t );\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n\tvec3 ro = vec3(0.0, 0.0, -2.0);\n\tvec3 lig=normalize(vec3(1.5, 1.5, -1.0));\n\tanimate(ta,ro,lig);\n\tvec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n\t\n\tvec3 ho;\n\tvec2 o=march(ro,rd,0.0,30.0,marchsteps, ho);\n\t\n\tvec3 col=vec3(0.0);\n\n\tif (o.y<0.5) {\n\t\tcol=getbg(rd);\n\t\to.x=(iResolution.y-fragCoord.y)*0.3;\n\t} else {\n\t\tvec3 nor=normal(ho);\t\n\t\tcol=getmat(o,ho);\n\t\tcol=shade(col, ro, rd, nor, lig, ho, o.x);\n\t}\n\t\n\tcol*=exp(.01*o.x); col*=1.1;\n\n\tfragColor=vec4( col, 1.0);\n}\t\t ","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdjGzG","date":"1390068891","viewed":380,"name":"displace map","username":"avix","description":"experiment in sphere displacing with texture map...\ntry changing textures, videos,music...","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","experiment"],"hasliked":0,"parentid":"","parentname":""}}