{"ver":"0.1","info":{"id":"llSyWy","date":"1509967131","viewed":99,"name":"ShaderTP2","username":"Quentin","description":"Le shader du tp2","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["tp2"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// In GLSL, IEEE 754 infinity can conveniently be achieved by dividing by zero:\nconst float FLT_MAX = 1.0 / 0.0;    \n\n// We can define a structure that will contain the parameters needed\n// by an object to specify its shading according to Phong shading.\nstruct Material\n{\n    float Ka;\t// ambiant        coefficient\n    float Kd;\t// diffuse        coefficient\n    float Ks;\t// specular       coefficient\n    float Kn;\t// specular power coefficient\n};\n    \nstruct ShadeInfo\n{\n    vec3 shadedCol;\n    float Ks;\n    \n};\n\nconst int MAX_NB_BOUNCES = 5;\n    \n    // ~ ~ ~ ~ ~ ~ ~ ~ \n        \n// Camera parameters\nvec3\t   cameraPos    = vec3(6,  4, -5);\n vec3\t   cameraTarget = vec3(3,  1, -8);\nconst float    cameraFovY   = 80.0;\t\t\t\t// NOTE: angle in degree\n\n// Sky parameters\nconst vec3     skyCol       = vec3(0.3,0.4,0.5);\t\t\t// black\nconst int      skyId        = 0;\n\n// Sphere parameters\n vec3     spherePos  = vec3(3,  0, -8) + vec3(0, 1.1, 2);\n float    sphereRadius = 1.0;\n vec3     sphereCol    = vec3(1,0,0);\t\t// red\nconst Material sphereMat    = Material(0.2/*Ka*/, 0.7/*Kd*/, 1.0/*Ks*/, 50.0/*Kn*/);\nconst int      sphereId     = 1;\n\n// Plane parameters\nconst vec3     planePos     = vec3(0, 0.1, 0);\nconst vec3     planeNormal  = vec3(0, 1.0, 0);\nvec3     planeCol1    = vec3(1.0);\t\t// white\nvec3     planeCol2    = vec3(0.4);\t\t// gray\nconst Material planeMat     = Material(0.2/*Ka*/, 1.0/*Kd*/, 0.2/*Ks*/,  5.0/*Kn*/);\nconst int      planeId      = 2;\n\n// Light(s) parameters\nconst vec3     ambiantCol   = vec3(0,0,1);\t\t// blue\nconst vec3     lightCol     = vec3(1,1,1);\t\t// white\nvec3     lightPos     = vec3(8, 10, -12);\n\nvoid computeCameraRayFromPixel(in vec2 fragCoord,out vec3  rayPos,out vec3 rayDir){\n    \n    float focal = 1.0 / tan(radians(cameraFovY) / 2.0);\n    vec3 cz = normalize(cameraTarget - cameraPos);\n    vec3 up = vec3(0,1,0);\t\t\t\t\t\t\t\n    vec3 cx = normalize(cross(-up, cz));\n    vec3 cy = normalize(cross( cz, cx));\n    vec2 pt = (2.*fragCoord - iResolution.xy) / iResolution.y;\n    \n    rayPos = cameraPos;\n    rayDir = normalize(pt.x * cx - pt.y * cy + focal * cz);\n}\n\n\n\nfloat raySphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float sphereRadius,out vec3 intersecS, out vec3 normalS){\n \tvec3 diff = rayPos - spherePos;\n    \n    float a = dot(rayDir, rayDir);\n    float b = 2.0 * dot(diff,rayDir);\n    float c = dot(diff,diff) - sphereRadius * sphereRadius;\n    \n    float di = b*b - 4.0*a*c;\n    \n    if (di >= 0.0)\n    {\n        float sdi = sqrt(di);\n        float den = 1. / (2.0 * a);\n        float t1  = (-b - sdi) * den;\n        float t2  = (-b + sdi) * den;\n        float resDist = min(t1,t2);\n\t\tintersecS = rayPos + rayDir * resDist;\n        normalS = normalize(intersecS - spherePos);\n        return resDist;\n    }\n    \n    return 0.;\n}\n\n\nfloat rayPlane(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal, out vec3 intersecPt, out vec3 normalP){\n \tfloat d = dot(planePos,planeNormal);\n    float den = dot(planeNormal, rayDir);\n    if (abs(den) <= 0.000001){\n        return -1.;\n    } \n    \n    float t = dot(planeNormal, planePos - rayPos) / den;\n\n    intersecPt = rayPos + t * rayDir;\n\tnormalP = -sign(den) * planeNormal;\n\treturn t;\n    \n}\n\nvec3 computePhongShading(vec3 sphereCol, Material sphereMat,float shadowFactor, vec3 normalS, vec3 L, vec3 R, vec3 V){\n \t\n\tfloat shadowS = shadowFactor < 1. ? 0. : 1.;\n    \n    //lumière ambiant\n    vec3 A = sphereMat.Ka * ambiantCol;\n    float angleTeta = max(dot(L,normalS),0.); /*angle entre lumière et normale de intersecS*/\n    //lumière diffuse\n    vec3 D = sphereMat.Kd * sphereCol * lightCol * angleTeta * shadowFactor;\n    float angleAlpha = dot(V,normalS); /*angle entre l'objet et l'observateur*/\n    //lumière spéculaire\n    vec3 S = sphereMat.Ks * lightCol * pow(max(dot(R,V),0.),sphereMat.Kn) * shadowS;\n    vec3 phong = A + D + S;\n    return phong;\n    \n}\n\nfloat computeNearestInteraction(vec3 rayPos, vec3 rayDir, out int objectId, out vec3 intersecT, out vec3 normalT){\n \t\n    objectId = skyId;\n    float minDist = FLT_MAX;\n    vec3 intersecS, normalS;\n\tfloat distSphere = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    \n    vec3 intersecP, normalP;\n\tfloat distPlane = rayPlane(rayPos,rayDir,planePos,planeNormal,intersecP,normalP);\n    \n    if((distSphere > 0.0) && (distSphere < minDist)){\n       objectId  =  sphereId;\n        minDist   =     distSphere;\n        intersecT = intersecS;\n          normalT =   normalS;\n    }\n    \n    if ((distPlane > 0.0) && (distPlane < minDist))\n    {\n        objectId  =   planeId;\n        minDist   =     distPlane;\n\t    intersecT = intersecP;\n    \t  normalT =   normalP;\n    }\n    \n   if (objectId == skyId)\n        minDist = -1.0;\n    \n    return minDist;\n    \n}\n\n\nvec3 getSphereColorAtPoint(vec3 pt)\n{\n    return sphereCol;\n}\n\n\nvec3 getPlaneColorAtPoint(vec3 pt)\n{\n  \n\n    vec3 worldX = vec3(1,0,0);\n    vec3 axisX  = normalize(worldX - dot(worldX, planeNormal) * planeNormal);\n    \n    vec3 axisY  = normalize(cross(planeNormal, axisX));\n\n    vec3 diff = pt - planePos; \n    float u = dot(diff, axisX);\n    float v = dot(diff, axisY);\n    \n    return mod(floor(u * 0.5) + floor(v * 0.5), 2.0) < 1.0  ? planeCol1 : planeCol2;\n}\n\n\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat)\n{\n    if (objectId == sphereId)\n    {\n        objectMat = sphereMat;\n        return getSphereColorAtPoint(pt);\n    }\n    else if (objectId == planeId)\n    {\n        objectMat = planeMat;\n        return getPlaneColorAtPoint(pt);\n    }\n        \n    return skyCol;\n}\n\nfloat getShadowFactorAtPoint(vec3 intersec, vec3 normal, Material objectMat, vec3 L, float Ldist){\n\t\t\n    intersec = intersec + normal*0.001;\n    vec3 intersecS, normalS;\n    float distSphere = raySphere(intersec, L, spherePos, sphereRadius, intersecS, normalS);\n    \n    vec3 intersecP, normalP;\n   \tfloat distPlane = rayPlane(intersec,L,planePos,planeNormal,intersecP,normalP);\n    \n    if ((distSphere > 0.) && (distSphere < Ldist) || (distPlane > 0. && distPlane < Ldist)){\n    \treturn objectMat.Ka;\n    }\n    \n\t\n    return 1.;\n}\n\nvoid animation() {\n    cameraTarget = vec3(3,  0, -8) + vec3(0, 1.1, 2);\n    cameraPos = cameraTarget +  vec3(10. * sin(-iTime * 0.2),3. + 3. * sin(0.15*iTime),10. * cos(-iTime * 0.2));\n    sphereRadius = 1.5 + 0.01 * cos(iTime * 20.);\n    spherePos = cameraTarget + vec3(0.02 * sin(iTime * 50.),sphereRadius - 1., 0.02 * sin(iTime * 50.));\n    spherePos = spherePos + vec3(4. * sin(iTime),0.,4. * cos(iTime)); \n\tsphereCol = spherePos + vec3(2. * sin(iTime),0.,2. * cos(iTime));\n    \n    lightPos = cameraTarget + vec3(7. * cos(iTime * 0.6),10. + 10. * cos(iTime),7. * cos(iTime));\n    \n    planeCol1=  vec3(1,1,1) + cameraPos * sin(iTime) * 0.3 ;\n    planeCol2 =  -planeCol1 ;\n\t    \n}\n\nvec3 RaytraceAtPixelCoord(vec2 pixCoord)\n{\n //compute the ray to be casted through the pixel towards the 3D scene\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(pixCoord,rayPos,rayDir);\n    \n    ShadeInfo infos[MAX_NB_BOUNCES];\n    int nbBounces = 0;\n    do\n    {\n        //Test ray-objects intersections and find the nearest one\n        // with its asociated intersection point and normal at the object surface)\n        int objectId;\n        vec3 intersecI, normalI;\n        float distI = computeNearestInteraction(rayPos,rayDir,objectId,intersecI,normalI);\n        \n        //We did not hit the spehere so we have the sky color\n        if(distI <= 0.0)\n        {\n         infos[nbBounces].shadedCol = skyCol;\n         infos[nbBounces].Ks = 0.0;\n         break;\n        }\n        // Apply the shading to the points that are on the surface and seen by the camera\n\n        //Store the information we gathered for that surface point\n\n        //Bounce from the surface towards the reflected direction of the ray\n        \n        \n    }\n    while (nbBounces < MAX_NB_BOUNCES);\n    \n    vec3 resCol = vec3(0);\n    \n    //...\n    \n    return resCol;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    animation();\n    \n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(fragCoord, rayPos, rayDir);\n    \n    //vec3 intersecS, normalS;\n    //float distS = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    vec3 intersecT, normalT;\n    int objectId;\n    float distT = computeNearestInteraction(rayPos, rayDir,objectId, intersecT, normalT);\n    if (distT > 0.0) {\n        //unit-vector going from the surface point toward the light\n        vec3 L = normalize(lightPos - intersecT)  ;\n        \n        //unit vector of the reflection direction of the light at the surface point\n        vec3 R = 2. * normalT * (dot(normalT,L)) - L ;\n        \n        //unit-vector going from the surface point toward the camera\n        vec3 V =  normalize(cameraPos - intersecT);\n        \n        //Apply the Phong shading o compute the color\n        // of the surface point as seen from the camera\n        Material objectMat;\n        vec3 objectCol = getObjectColorAtPoint(objectId, intersecT, objectMat);\n        \n        float Ldist = distance(lightPos,intersecT);\n        float shadowFactor = getShadowFactorAtPoint( intersecT, normalT, objectMat, L, Ldist);\n        \n        fragColor = vec4(computePhongShading(objectCol, objectMat, shadowFactor, normalT, L, R, V), 1);\n\n    } else\n        \tfragColor = vec4(skyCol,1);\n   \n}","name":"Image","description":"","type":"image"}]}