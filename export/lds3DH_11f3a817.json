{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"/*by mu6k, Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n A shape changing object. Use mouse to move the camera around the object.\n\n The original idea was to make a box that bends its shape, but then I though it's\n a lot more interesting if there are more shapes involved. I also implemented a \n plane itersection for the background. I'll be needing more of that plane intersection\n for another idea I had.\n\n The plane and background are done 100% seperately from the distance field. This allows\n me to calculate the shadow cast on the plane separately from the long loop and I don't\n run out of instructions.\n\n This should run at high framerates, even at fullscreen...\n\n 25/05/2013:\n - published\n - added comments\n\n 30/05/2013:\n - added the fix which was suggested by iq\n\n muuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuusk!*/\n\nfloat hash(float x)\n{\n\treturn fract(sin(x*.0127863)*17143.321);\n}\n\nfloat hash(vec2 x)\n{\n\treturn fract(cos(dot(x.xy,vec2(2.31,53.21))*124.123)*412.0); \n}\n\nfloat hashmix(float x0, float x1, float interp)\n{\n\tx0 = hash(x0);\n\tx1 = hash(x1);\n\t#ifdef noise_use_smoothstep\n\tinterp = smoothstep(0.0,1.0,interp);\n\t#endif\n\treturn mix(x0,x1,interp);\n}\n\nfloat hashmix(vec2 p0, vec2 p1, vec2 interp)\n{\n\tfloat v0 = hashmix(p0[0]+p0[1]*128.0,p1[0]+p0[1]*128.0,interp[0]);\n\tfloat v1 = hashmix(p0[0]+p1[1]*128.0,p1[0]+p1[1]*128.0,interp[0]);\n\t#ifdef noise_use_smoothstep\n\tinterp = smoothstep(vec2(0.0),vec2(1.0),interp);\n\t#endif\n\treturn mix(v0,v1,interp[1]);\n}\n\nfloat hashmix(vec3 p0, vec3 p1, vec3 interp)\n{\n\tfloat v0 = hashmix(p0.xy+vec2(p0.z*143.0,0.0),p1.xy+vec2(p0.z*143.0,0.0),interp.xy);\n\tfloat v1 = hashmix(p0.xy+vec2(p1.z*143.0,0.0),p1.xy+vec2(p1.z*143.0,0.0),interp.xy);\n\t#ifdef noise_use_smoothstep\n\tinterp = smoothstep(vec3(0.0),vec3(1.0),interp);\n\t#endif\n\treturn mix(v0,v1,interp[2]);\n}\n\nfloat hashmix(vec4 p0, vec4 p1, vec4 interp)\n{\n\tfloat v0 = hashmix(p0.xyz+vec3(p0.w*17.0,0.0,0.0),p1.xyz+vec3(p0.w*17.0,0.0,0.0),interp.xyz);\n\tfloat v1 = hashmix(p0.xyz+vec3(p1.w*17.0,0.0,0.0),p1.xyz+vec3(p1.w*17.0,0.0,0.0),interp.xyz);\n\t#ifdef noise_use_smoothstep\n\tinterp = smoothstep(vec4(0.0),vec4(1.0),interp);\n\t#endif\n\treturn mix(v0,v1,interp[3]);\n}\n\nfloat noise(float p) // 1D noise\n{\n\tfloat pm = mod(p,1.0);\n\tfloat pd = p-pm;\n\treturn hashmix(pd,pd+1.0,pm);\n}\n\nfloat noise(vec2 p) // 2D noise\n{\n\tvec2 pm = mod(p,1.0);\n\tvec2 pd = p-pm;\n\treturn hashmix(pd,(pd+vec2(1.0,1.0)), pm);\n}\n\nfloat noise(vec3 p) // 3D noise\n{\n\tvec3 pm = mod(p,1.0);\n\tvec3 pd = p-pm;\n\treturn hashmix(pd,(pd+vec3(1.0,1.0,1.0)), pm);\n}\n\nfloat noise(vec4 p) // 4D noise\n{\n\tvec4 pm = mod(p,1.0);\n\tvec4 pd = p-pm;\n\treturn hashmix(pd,(pd+vec4(1.0,1.0,1.0,1.0)), pm);\n}\n\nvec2 rotate(vec2 v, float angle)\n{\n\tvec2 vo = v; float cosa = cos(angle); float sina = sin(angle);\n\tv.x = cosa*vo.x - sina*vo.y;\n\tv.y = sina*vo.x + cosa*vo.y;\n\treturn v;\n}\n\nvec2 rotate_z(vec2 v, float angle)\n{\n\tvec2 vo = v; float cosa = cos(angle); float sina = sin(angle);\n\tv.x = cosa*vo.x - sina*vo.y;\n\tv.y = sina*vo.x + cosa*vo.y;\n\treturn v;\n}\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tvec3 vo = v; float cosa = cos(angle); float sina = sin(angle);\n\tv.x = cosa*vo.x - sina*vo.y;\n\tv.y = sina*vo.x + cosa*vo.y;\n\treturn v;\n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tvec3 vo = v; float cosa = cos(angle); float sina = sin(angle);\n\tv.x = cosa*vo.x - sina*vo.z;\n\tv.z = sina*vo.x + cosa*vo.z;\n\treturn v;\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tvec3 vo = v; float cosa = cos(angle); float sina = sin(angle);\n\tv.y = cosa*vo.y - sina*vo.z;\n\tv.z = sina*vo.y + cosa*vo.z;\n\treturn v;\n}\n\t\nvec3 cc(vec3 color, float factor,float factor2) //a wierd color modifier\n{\n\tfloat w = color.x+color.y+color.z;\n\treturn mix(color,vec3(w)*factor,w*factor2);\n}\n\nvec2 material0(vec2 uv) //material used for the infinite plane\n{\n\t//make a checkerboard pattern\n\tvec2 uv2 = mod(uv,vec2(2.,2.));\n\tuv2 -= mod(uv,vec2(1.0,1.0));\n\tfloat d = uv2.x+uv2.y; \n\td = pow(d-1.0,2.0)*.4;\n\t\n\t//sample the texture\n\tfloat s = textureLod(iChannel0,uv*.3,0.0).y+0.5-d;\n\td += s*.2;\n\n\t//d - diffuse, s - specular\n\treturn vec2(d,s*s*.5+.1);\n}\n\nfloat dist(vec3 p) //the distance function for raymarching\n{\n\t//warp time to get that crazy bending efect\n\tfloat time = p.x*sin(iTime*2.312)*sin(iTime)*.9+\n\t\tp.z*cos(iTime*3.12)*sin(iTime)*.9+\n\t\tiTime+max(mod(iTime*.1,1.0),mod(-iTime*.1,1.0));\n\t\n\t//rotate the space, bp <- transform(p)\n\tvec3 bp = rotate_z(p,time*.6);\n\tbp = rotate_y(bp,time*.7);\n\tbp = rotate_x(bp,time*.5);\n\t\n\t//now we have the distance function for 4 shapes\n\tfloat diamond = abs(bp.x)+abs(bp.y)+abs(bp.z)-0.6;//length(p+vec3(.0,.0,.0))-0.5;\n\tfloat box = max(abs(bp.x),max(abs(bp.y),abs(bp.z)))-0.35;//length(p+vec3(.0,.0,.0))-0.5;\n\tfloat torus = pow((0.4-length(bp.xy)),2.0)+pow(bp.z,2.0)-0.02;\n\tfloat sphere = length(bp)-.5;\n\t\n\t//these values are used to blend them together\n\tfloat change = sin(iTime)*0.99;\n\tfloat change2 = sin(iTime*.4)*0.99;\n\t\n\t//set0 <- mix(sphere,diamond), set1 <- mix(torus,box)\n\tfloat set0 = mix(sphere,diamond,smoothstep(-1.0,1.0,change));\n\tfloat set1 = mix(torus,box,smoothstep(-1.0,1.0,change));\n\n\t//return mix(sphere,diamond,torus,box)\n\treturn mix(set0,set1,smoothstep(-1.0,1.0,change2));\n}\n\nvec3 normal(vec3 p,float e) //returns the normal, uses the distance function\n{\n\tfloat d=dist(p);\n\treturn normalize(vec3(dist(p+vec3(e,0,0))-d,dist(p+vec3(0,e,0))-d,dist(p+vec3(0,0,e))-d));\n}\n\nvec3 light; //global variable that holds light direction\n\nvec3 plane(vec3 p, vec3 d) //returns the intersection with a predefined plane\n{\n\t//http://en.wikipedia.org/wiki/Line-plane_intersection\n\tvec3 n = vec3(.0,1.0,.0);\n\tvec3 p0 = -n*.8;\n\tfloat f=dot(p0-p,n)/dot(n,d);\n \treturn p+d*f;\n}\n\nfloat sun(vec3 d) //makes a bright dot on the sky\n{\n\tfloat s = dot(d,light);\n\ts+=1.0; s*=.5;\n\ts=pow(s*1.001,100.0);\n\treturn s;\n}\n\nvec3 stars(vec3 d) //render stars using 3d noise\n{\n\td.y=abs(d.y);\n\tfloat s = noise(d*364.0)*noise(d*699.0);\n\ts=pow(s,13.0)*10.0;\n\treturn vec3(s);\n}\n\nvec3 backdrop(vec3 p,vec3 d) //render background layer, also used for reflection\n{\n\tfloat s = sun(d); //sun\n\tvec3 a = vec3(.3,.4,0.7)*(1.0-abs(d.y))*1.5; //atmosphere\n\tvec3 n = vec3(.0,1.0,.0); //plane normal\n\t\n\tfloat diffuse = dot(n,light)*.5+.5; //diffuse lighting for the plane\n\t\n\tfloat alpha = dot(d,-n); //this coefficient is used\n\tif (alpha<.0) alpha=.0;  //to blend the plane with the sky\n\t\n\tvec3 pp = plane(p,d); //get the intersection position\n\tfloat lpp= length(pp);\n\tvec2 mat = material0(pp.xz); //get the floor material, \n\t//mat.x = diffuse coefficient, mat.y = specular coefficient\n\t\n\t//calculate the planes color\n\tvec3 c = mat.x*vec3(.4,.4,.4)*diffuse + (mat.y*.7)*(a*.2+vec3(sun(reflect(d,n))));\n\t\n\talpha=pow(alpha,.5); //make the scene less foggy\n\t\n\treturn mix(a+s,c,alpha); //mix the plane with the sky\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n\t\n\tmouse.x+=iTime*.00015;\n\t\n\tvec3 p = vec3(sin(mouse.x*7.0)*2.1,0.0,cos(mouse.x*7.0)*2.1); //ray position\n\tvec3 d = rotate_y(vec3(uv,1.0),3.14159-7.0*mouse.x); \n\td = normalize(d); //ray direction\n\t\n\tlight = normalize(vec3(sin(iTime),sin(iTime*.44)+1.2,sin(iTime*.24)));\n\n\tvec3 c; //color\n\t\n\t//first we calculate the background\n\t\n\tvec3 back = backdrop(p,d);\n\tc=back;\n\t\n\tif (d.y<.0) //ground\n\t{\n\t\tvec3 p = plane(p,d);\n\t\tfloat alpha=0.3/length(p); //shadow alpha\n\t\tfloat s = 1.0; \n\t\tfor (int i=0; i<20; i++) //cast shadows for the shapeshifting object\n\t\t{\n\t\t\tfloat ss = dist(p);\n\t\t\tp+=light*ss;\n\t\t\tss*=2.0;\n\t\t\tss = min(ss,1.0);\n\t\t\ts*=ss;\n\t\t}\n\t\tc = mix(c,c*s,alpha)+stars(d)*.2; //mix + add star reflection\n\t}\n\telse\n\t{\n\t\tc+=stars(d); // add stars to the sky\n\t}\n\t\n\t//now we do the raymarch, if the ray hits the object, the color\n\t//is overwritten, otherwise the background color stays . . .\n\t\n\tfor (int i=0; i<100; i++) //raymarching\n\t{\n\t\tfloat di = dist(p); //evaluate the distance fucntion\n\t\tp+=d*(di*(hash(p.xy+uv.xy)*0.3+.7))*.4; //move the ray\n\n\t\tif (di>5.0) //too far away from the object, escape from this long loop\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tif (di<.01) //close enough to the object\n\t\t{\n\t\t\tvec3 n = normal(p,0.002);\n\t\t\tfloat ao = dist(p+n)*.5+.5; //self occlusion\n\t\t\t\t\t\t\n\t\t\t// a bit more wierd diffuse lighting, but looks great\n\t\t\tfloat diffuse = (dot(light,n)*.5+.5); \n\t\t\tdiffuse=pow(diffuse,2.0); \n\t\t\t\n\t\t\tc = vec3(2.4,.4,.4) * diffuse; //object color\n\t\t\t\n\t\t\t//now we add the beautiful raytraced reflection\n\t\t\tc = mix(c,backdrop(p,reflect(d,n)),(1.0+dot(d,n))*.6+.2); \n\t\t\tc *= ao; //mix in the self occlusion\n\t\t\tbreak; //escape the loop\n\t\t}\n\t}\n\t\n\tc-=vec3(length(uv)*.1); //vignette\n\tfragColor = vec4(cc(c*.4+hash(uv.xy+c.xy)*.007,.8,0.9),1.0); //post process\n\t//fragColor = vec4(c,1.0); //uncomment this to remove post processing\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lds3DH","date":"1369505336","viewed":1253,"name":"Shapeshifter","username":"mu6k","description":"A shape changing object. Use mouse to move the camera around the object.","likes":59,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raymarching"],"hasliked":0,"parentid":"","parentname":""}}