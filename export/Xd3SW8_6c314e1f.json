{"ver":"0.1","info":{"id":"Xd3SW8","date":"1458877079","viewed":3260,"name":"Filling Tiles","username":"Hanley","description":"Playing with moving square fills. ","likes":38,"published":1,"flags":0,"usePreview":0,"tags":["loop","tiles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n#define TWO_PI 6.283185\n\nfloat polygonDistanceField(in vec2 pixelPos, in int N) {\n    // N = number of corners\n    float a = atan(pixelPos.y, pixelPos.x) + PI/2.; // angle\n    float r = TWO_PI/float(N); // ~?\n    // shapping function that modulates the distances\n    float distanceField = cos(floor(0.5 + a/r) * r - a) * length(pixelPos);\n    return distanceField;\n}\n\nfloat minAngularDifference(in float angleA, in float angleB) {\n    // Ensure input angles are -Ï€ to Ï€\n    angleA = mod(angleA, TWO_PI);\n    if (angleA>PI) angleA -= TWO_PI;\n    if (angleA<PI) angleA += TWO_PI;\n    angleB = mod(angleB, TWO_PI);\n    if (angleB>PI) angleB -= TWO_PI;\n    if (angleB<PI) angleB += TWO_PI;\n\n    // Calculate angular difference\n    float angularDiff = abs(angleA - angleB);\n    angularDiff = min(angularDiff, TWO_PI - angularDiff);\n    return angularDiff;\n}\n\nfloat map(in float value, in float istart, in float istop, in float ostart, in float ostop) {\n    return ostart + (ostop - ostart) * ((value - istart) / (istop - istart));\n}\nfloat mapAndCap(in float value, in float istart, in float istop, in float ostart, in float ostop) {\n    float v = map(value, istart, istop, ostart, ostop);\n    v = max( min(ostart,ostop), v);\n    v = min( max(ostart,ostop), v);\n    return v;\n}\n\n\n// Matrix Transforms\nmat2 rotate2d(float angle);\nmat2 scale(vec2 scale);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float u_time = iTime;\n  \tvec2 u_mouse = iMouse.xy;\n  \tvec2 u_resolution = iResolution.xy;\n    \n    vec3 color = vec3(0.2);\n    float t = u_time;\n    vec2 mouse_n = u_mouse.xy / u_resolution;\n\n    vec2 st = fragCoord.xy / u_resolution.xy;\n    st.x *= u_resolution.x / u_resolution.y; // quick aspect ratio fix\n\n    // manip st grid - into 3x3 tiles\n    float divisions = 4.;\n    vec2 mst = st;\n    mst *= divisions;\n\n    // give each cell an index number according to position (left-right, down-up)\n    float index = 0.;\n    float cellx = floor(mst.x);\n    float celly = floor(mst.y);\n    index += floor(mst.x);\n    index += floor(mst.y)*divisions;\n\n    // tile mst\n    mst = mod(mst, 1.);\n    \n    ////\n    // draw square tile\n    \n    // t = 1.6;\n    float tt = t-(sin(cellx*.3)+cos(celly*.3))*.5; //t * .3;\n    float squareProgress = mod(tt*.3, 1.); //0.22; // mouse_n.x; //0.2; //mod(t*.3, 1.);\n    float squareEntryProgress = mapAndCap(squareProgress, 0., 0.6, 0., 1.); //mod(t*.7, 1.); //mouse_n.x;\n    float squareExitProgress = mapAndCap(squareProgress, 0.9, .999, 0., 1.);\n        squareExitProgress = pow(squareExitProgress, 3.);\n\n    float borderProgress = mapAndCap(squareEntryProgress,0.,0.55,0.,1.);\n        borderProgress = pow(borderProgress, 1.5);\n    float fillProgress = mapAndCap(squareEntryProgress,0.4, 0.9, 0., 1.);\n        fillProgress = pow(fillProgress, 4.);\n\n    // MATRIX MANIP\n    mst = mst*2.-1.; // centre origin point\n    // rotate\n    // mst = rotate2d(floor(mod(index,2.))*PI*.5 + PI*.25)*mst;\n    mst = rotate2d(cellx*PI*.5 + celly*PI*.5 + PI*.25)*mst;\n\n    float d = polygonDistanceField(mst, 4);\n    float r = map(squareExitProgress, 0., 1., 0.7, 0.); // 0.5;\n    float innerCut = map(fillProgress, 0., 1., 0.9, 0.0001); //0.9; //mouse_n.x;\n    float buf = 1.01;\n    float shape = smoothstep(r*buf, r, d) - smoothstep(r*innerCut, r*innerCut/buf, d);\n    // add smoother shape glow\n    buf = 1.5;\n    float shape2 = smoothstep(r*buf, r, d) - smoothstep(r*innerCut, r*innerCut/buf, d);\n    // shape += shape2*.5;\n\n\n    // angular mask on square tile\n    float sta = atan(mst.y, mst.x); // st-angle - technically its msta here\n    float targetAngle = map(borderProgress, 0., 1., 0., PI)+PI*.251;\n    float adiff = minAngularDifference(sta, targetAngle);\n    float arange = map(borderProgress, 0., 1., 0., PI);\n    float amask = 1. - smoothstep(arange, arange, adiff);\n    shape *= amask;\n\n\n    // color\n    // color = vec3(shape) * vec3(0.8, 0.6, 0.8)*2.;\n    color = vec3(shape) * (vec3(1.-st.x, st.y, st.y)+vec3(.2));\n    // color += vec3(mst.y, 0., mst.x);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(color,1.0);\n}\n\n\n// rotate matrix\nmat2 rotate2d(float angle) {\n    return mat2(cos(angle), -sin(angle),\n                sin(angle),  cos(angle) );\n}\n\n// scale matrix\nmat2 scale(vec2 scale) {\n    return mat2(scale.x, 0,\n                0, scale.y);\n}","name":"Image","description":"","type":"image"}]}