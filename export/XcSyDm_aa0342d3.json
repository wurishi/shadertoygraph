{"ver":"0.1","info":{"id":"XcSyDm","date":"1722658137","viewed":94,"name":"Faster Grass Plain","username":"Timbrhoggvandi","description":"Rewritten version of my grass plain shader https://www.shadertoy.com/view/l3dSR7 to just use capsules rather than finding the sdf of a parabola. Performance is much better.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","grass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord.xy), 0).xyz;\n    \n    col = pow(col, vec3(1.0/2.2));\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\n#define E 2.718281828459045235360287471352\n\n// Supersampling, set to 1 to turn SSAA off\n#define AA_SAMPLES 1\n\n#define VERTICAL_FOV 1.0\n#define MAX_ITERATIONS 512\n#define MAX_DISTANCE 256.0\n#define HIT_DISTANCE 0.001\n#define BOUNDING_BOX_BUFFER 0.03\n\n#define REPETITION_PERIOD 0.125\n#define LENGTH_MIN 0.4\n#define LENGTH_RANGE 0.25\n\n#define ID_ATMOSPHERE 0\n#define ID_GROUND 1\n#define ID_GRASS 2\n\n#define COL_SUNLIGHT vec3(1.0, 1.0, 0.97)\n#define COL_ATMOSPHERE vec3(0.396,0.788,0.984)\n#define COL_GROUND vec3(0.055,0.043,0.027)\n#define COL_GRASS vec3(0.17,0.9,0.17)\n\n#define SUN_DIRECTION normalize(vec3(-0.1,1,-0.2))\n\nstruct RaymarchInfo {\n    vec3 point;\n    float rayDistance;\n    bool hit;\n};\n\nstruct MapInfo {\n    vec3 coord;\n    float dist;\n    int matId;\n};\n\nstruct GrassInfo {\n    vec3 coord;\n    float dist;\n};\n\n// Not good hash functions. They're fast though\nfloat hash12(vec2 p) {\n    p = fract(23.745783*p + 7.5491549) / vec2(PI, E);\n    return fract((p.x*p.y)*513.324765);\n}\n\nvec2 hash22(vec2 p) {\n    p = fract(23.745783*p + 7.5491549) / vec2(PI, E);\n    return fract((p.x*p.y)*vec2(319.6731201, 193.83039));\n}\n\nvec2 rotate2D(vec2 p, float angle) {\n    return vec2(p.x*cos(angle) - p.y*sin(angle), p.x*sin(angle) + p.y*cos(angle));\n}\n\nMapInfo minDist(MapInfo a, MapInfo b) {\n    if(a.dist < b.dist) {\n        return a;\n    }\n    return b;\n}\n\nfloat getTilt(vec2 point) {\n    float tilt = cos(0.5*point.x+0.25*sin(point.y - iTime) - iTime);\n    return tilt*tilt - 0.07;\n}\n\nfloat getRotation(vec2 point) {\n    return 2.3*cos(0.15 * point.x + 0.1*iTime) + 2.0*sin(0.18 * point.y + 0.11*iTime) + 0.1 * cos(2.2*iTime);\n}\n\nfloat sdSphere(vec3 point, float radius) {\n    return length(point) - radius;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdV(vec3 point, float w1, float w2) {\n    return min(sdCapsule(point, vec3(-w1/2.0, 0.0, 0.0), vec3(w1/2.0, 0.0, w2/2.0), w2/7.0),\n               sdCapsule(point, vec3(-w1/2.0, 0.0, 0.0), vec3(w1/2.0, 0.0, -w2/2.0), w2/7.0));\n}\n\nfloat sdPlane(vec3 point) {\n    return point.y;\n}\n\n/* These versions of the functions only return distance, used for raymarching */\nfloat sdGrassBlade( vec3 p, float h, float r, float crossSectionRotation ) {\n    r*= 1.0 - (p.y*p.y/(h*h));\n    float py = p.y - clamp( p.y, 0.0, h );\n    float tilt = getTilt(p.xz);\n    p.xz = rotate2D(p.xz, crossSectionRotation);\n    return sdV(vec3(p.x, py, p.z), 0.2*r, r);\n}\n\nfloat evalDomain(vec3 point, vec2 id) {\n    float tilt = getTilt(point.xz);\n    float rotation = getRotation(point.xz);\n    vec2 translation = 0.02 + (REPETITION_PERIOD - 0.04) * hash22(id);\n    vec2 globalCellCoord = REPETITION_PERIOD * id + translation;\n    point.xz -= globalCellCoord;\n    point.xz = rotate2D(point.xz, rotation);\n    point.xy = rotate2D(point.xy, point.y*tilt);\n    float len = LENGTH_MIN + LENGTH_RANGE*hash12(13.1894*id);\n    float crossSectionRotation = 2.0*PI*hash12(41.6921*id) - rotation;\n    return sdGrassBlade(point, len, len/5.0, crossSectionRotation);\n}\n\nfloat sdGrassField(vec3 point, float stepScale) {\n    float tilt = getTilt(point.xz);\n    float rotation = getRotation(point.xz);\n    float py = clamp(point.y, 0.0, 1.0);\n    \n    vec2 id = point.xz;\n    id -= vec2(cos(rotation), -sin(rotation))*py*py*tilt;\n    id = floor(id / REPETITION_PERIOD - 0.5);\n    \n    float dist = REPETITION_PERIOD;\n    for(int i = 0; i <= 1; i++) {\n        for(int j = 0; j <= 1; j++) {\n            float domainDist = evalDomain(point, id + vec2(i,j));\n            if(domainDist < dist) {\n                dist = domainDist;\n            }\n        }\n    }\n    dist *= stepScale;\n    return dist;\n}\n\nfloat map(vec3 point, float stepScale) {\n    float minDist = 999.0;\n    \n    // grass\n    float boundingBox = sdPlane(point - vec3(0,LENGTH_MIN + LENGTH_RANGE,0));\n    if(boundingBox < BOUNDING_BOX_BUFFER) {\n        float grass = sdGrassField(point, stepScale);\n        minDist = min(grass, minDist);\n    }\n    else {\n        minDist = boundingBox;\n    }\n    \n    // ground\n    float plane = sdPlane(point);\n    minDist = min(plane, minDist);\n    \n    return minDist;\n}\n/* ------------------------------------------------------------------------------------------- */\n\n/* These versions of the functions also return material ID and local coords, used for lighting */\nGrassInfo sdGrassBlade2( vec3 p, float h, float r, float crossSectionRotation ) {\n    GrassInfo grassInfo;\n    r*= 1.0 - (p.y*p.y/(h*h));\n    float py = p.y - clamp( p.y, 0.0, h );\n    float tilt = getTilt(p.xz);\n    p.xz = rotate2D(p.xz, crossSectionRotation);\n    grassInfo.dist = sdV(vec3(p.x, py, p.z), 0.2*r, r);\n    r = max(0.0001,r);\n    grassInfo.coord = vec3(p.x/r, p.y/h, p.z/r);\n    return grassInfo;\n}\n\n\nGrassInfo evalDomain2(vec3 point, vec2 id) {\n    float tilt = getTilt(point.xz);\n    float rotation = getRotation(point.xz);\n    vec2 translation = 0.02 + (REPETITION_PERIOD - 0.04) * hash22(id);\n    vec2 globalCellCoord = REPETITION_PERIOD * id + translation;\n    point.xz -= globalCellCoord;\n    point.xz = rotate2D(point.xz, rotation);\n    point.xy = rotate2D(point.xy, point.y*tilt);\n    float len = LENGTH_MIN + LENGTH_RANGE*hash12(13.1894*id);\n    float crossSectionRotation = 2.0*PI*hash12(41.6921*id) - rotation;\n    return sdGrassBlade2(point, len, len/5.0, crossSectionRotation);\n}\n\nGrassInfo sdGrassField2(vec3 point) {\n    float tilt = getTilt(point.xz);\n    float rotation = getRotation(point.xz);\n    float py = clamp(point.y, 0.0, 1.0);\n    \n    vec2 id = point.xz;\n    id -= vec2(cos(rotation), -sin(rotation))*py*py*tilt;\n    id = floor(id / REPETITION_PERIOD - 0.5);\n    \n    GrassInfo dist = GrassInfo(point, REPETITION_PERIOD);\n    for(int i = 0; i <= 1; i++) {\n        for(int j = 0; j <= 1; j++) {\n            GrassInfo domainDist = evalDomain2(point, id + vec2(i,j));\n            if(domainDist.dist < dist.dist) {\n                dist = domainDist;\n            }\n        }\n    }\n    return dist;\n}\n\nMapInfo map2(vec3 point) {\n    MapInfo mapInfo = MapInfo(point, 999.0, ID_ATMOSPHERE);\n    \n    // grass\n    float boundingBox = sdPlane(point - vec3(0,LENGTH_MIN + LENGTH_RANGE,0));\n    if(boundingBox < BOUNDING_BOX_BUFFER) {\n        GrassInfo grassInfo = sdGrassField2(point);\n        MapInfo grass = MapInfo(grassInfo.coord, grassInfo.dist, ID_GRASS);\n        mapInfo = minDist(grass, mapInfo);\n    }\n    else {\n        mapInfo = MapInfo(point, boundingBox, ID_GRASS);\n    }\n    \n    // ground\n    MapInfo plane = MapInfo(point, sdPlane(point), ID_GROUND);\n    mapInfo = minDist(plane, mapInfo);\n    \n    return mapInfo;\n}\n/* ------------------------------------------------------------------------------------------- */\n\nRaymarchInfo raymarch(vec3 ro, vec3 rd, int maxIterations, float maxDistance) {\n    RaymarchInfo info = RaymarchInfo(ro, 0.0, false);\n    \n    for(int i = 0; i < maxIterations; i++) {\n        float stepScale = clamp(info.rayDistance * 0.08, 0.8, 1.0);\n        float dist = map(info.point, stepScale);\n        \n        if(dist < HIT_DISTANCE) {\n            info.hit = true;\n            break;\n        }\n        \n        info.rayDistance += dist;\n        info.point = ro + info.rayDistance*rd;\n        \n        if(info.rayDistance > MAX_DISTANCE) {\n            break;\n        }\n    }\n    \n    return info;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0001;\n    return normalize(\n        e.xyy * map(p + e.xyy, 1.0) +\n        e.yyx * map(p + e.yyx, 1.0) +\n        e.yxy * map(p + e.yxy, 1.0) +\n        e.xxx * map(p + e.xxx, 1.0));\n}\n\nfloat shadow(vec3 point, vec3 lightDirection, float lightDistance, float penumbraCoefficient) {\n    float light = 1.0;\n    float rayDist = 0.0;\n    point += 0.01*calcNormal(point);\n    for(int i = 0; i < 32; i++) {\n        float dist = map(point + lightDirection*rayDist, 1.0);\n        if(dist < 0.05*HIT_DISTANCE) {\n            light = 0.0;\n            break;\n        }\n        light = min(light, penumbraCoefficient*dist/rayDist);\n        rayDist += max(dist, 0.01);\n        if(rayDist > lightDistance) {\n            return light;\n        }\n    }\n    return light;\n}\n\n// this ambient occlusion isn't great, rewrite at some point\nfloat ambientOcclusion(vec3 point) {\n    float ao = 1.0;\n    float d = 0.02;\n    float scale = 0.25;\n    vec3 normal = calcNormal(point);\n    for(float i = 0.0; i < 4.0; i++) {\n        float distField = map(point + d * normal, 1.0);\n        ao -= scale * (d - distField)/d;\n        d += 0.05;\n    };\n    \n    return clamp(ao, 0.0, 1.0);\n}\n\nfloat valueNoise(vec2 coord) {\n    vec2 f = fract(coord);\n    vec2 i = floor(coord);\n    \n    vec2 a = f * f * (3.0 - 2.0 * f);\n    \n    float v00 = hash12(i);\n    float v10 = hash12(i + vec2(1, 0));\n    float v01 = hash12(i + vec2(0, 1));\n    float v11 = hash12(i + vec2(1, 1));\n    \n    return mix(\n        mix(v00, v10, f.x),\n        mix(v01, v11, f.x),\n        f.y);\n}\n\nfloat fbm(vec2 coord, int octaves) {\n    float scale = 0.45;\n    float sum = 0.0;\n    for(int i = 0; i < octaves; i++) {\n        sum += scale * valueNoise(coord);\n        scale *= 0.6;\n        coord /= 0.42;\n    }\n    return sum;\n}\n\nvec3 lighting(RaymarchInfo info, vec3 rd) {\n    vec3 col;\n    vec3 colApprox;\n    MapInfo mapInfo = map2(info.point);\n    if(!info.hit) {\n        mapInfo.matId = ID_ATMOSPHERE;\n    }\n    float distanceScale = exp2(-0.1*info.rayDistance);\n    switch(mapInfo.matId) {\n        case ID_ATMOSPHERE:\n            return COL_ATMOSPHERE - 0.5*rd.y;\n            break;\n        case ID_GROUND:\n            col = COL_GROUND;\n            col *= fbm(mapInfo.coord.xz*15.0, 5);\n            colApprox = COL_GROUND * 0.7;\n            break;\n        case ID_GRASS:\n            col = COL_GRASS;\n            col *= mix(0.65, 0.65 - 0.2*cos(2.0*PI*mapInfo.coord.z) + 0.15*cos(20.0*mapInfo.coord.z), distanceScale);\n            col *= 0.25 + 0.75*mapInfo.coord.y;\n            colApprox = COL_GRASS * 0.55;\n            break;\n    }\n    vec3 normal = calcNormal(info.point);\n    vec3 directLight = COL_SUNLIGHT*clamp(dot(SUN_DIRECTION, normal), 0.0, 1.0);\n    directLight *= shadow(info.point, SUN_DIRECTION, 100.0, 12.0);\n    \n    vec3 indirectLight = vec3(0.04,0.09,0.04)*ambientOcclusion(info.point);\n    \n    vec3 normApprox = normalize(vec3(1.0, getTilt(info.point.xz), 0.0));\n    normApprox.xz = rotate2D(normApprox.xz, getRotation(info.point.xz));\n    vec3 directLightApprox = COL_SUNLIGHT*((abs(dot(normApprox, SUN_DIRECTION)) + 0.2) * 0.6);\n    directLight = mix(directLightApprox, directLight, distanceScale);\n    \n    vec3 indirectLightApprox = vec3(0.05,0.11,0.05)*0.5;\n    indirectLight = mix(indirectLightApprox, indirectLight, distanceScale);\n    \n    col = mix(colApprox, col, distanceScale);\n    \n    vec3 light = directLight + indirectLight;\n    col = col*light;\n    \n    vec3 fog = exp2(-0.005*info.rayDistance*vec3(1,1.5,2));\n    col = mix(vec3(0.8), col, fog);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n    uv -= 1.0 / iResolution.y;\n    \n    vec3 ro = vec3(0, 1.2, 0);\n    \n    vec3 sampleSum = vec3(0);\n    \n    // bad anti aliasing\n    for(int i = 0; i < AA_SAMPLES; i++) {\n        vec2 uvSample = uv + (2.0 / iResolution.y) * hash12(fract(0.1*(uv+iTime+float(i))));\n        \n        vec3 rd = normalize(vec3(uvSample, 1.0 / tan(0.5 * VERTICAL_FOV)));\n    \n        rd.yz = rotate2D(rd.yz, 0.3*PI*iMouse.y/iResolution.y);\n        rd.xz = rotate2D(rd.xz, 2.0*PI*iMouse.x/iResolution.x);\n    \n        RaymarchInfo info = raymarch(ro, rd, MAX_ITERATIONS, MAX_DISTANCE);\n\n        vec3 col = lighting(info, rd);\n        \n        sampleSum += col;\n    }\n    sampleSum /= float(AA_SAMPLES);\n\n    // Blurs everything, but makes it slightly less aliasy at least\n    // also makes the random sample AA look less bad\n    sampleSum = mix(sampleSum, texelFetch(iChannel0, ivec2(fragCoord.xy), 0).xyz, 0.45);\n    fragColor = vec4(sampleSum,1.0);  \n}","name":"Buffer A","description":"","type":"buffer"}]}