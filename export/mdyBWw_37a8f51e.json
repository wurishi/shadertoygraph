{"ver":"0.1","info":{"id":"mdyBWw","date":"1698261469","viewed":30,"name":"Catmull-Rom Spline Stream","username":"DigitalShadow","description":"After failing to achieve a smooth knot transition with cubic bezier splines on a larger project, I spent some time trying to get this effect working for a continual stream of psuedorandom points","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["spline","interpolation","catmullrom"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 colBlue = vec3(0,0,1);\nvec3 colYellow = vec3(1,1,0);\n\nvec2 splineInterpolation(vec2 s[4], float t)\n{\n    float alpha = 1.;\n    float tension = 0.0;\n    \n    float tAB = pow(distance(s[0], s[1]), alpha);\n    float tBC = pow(distance(s[1], s[2]), alpha);\n    float tCD = pow(distance(s[2], s[3]), alpha);\n    \n    vec2 m1 = (1.0 - tension) * (s[2] - s[1] + tBC * ((s[1] - s[0]) / tAB - (s[2] - s[0]) / (tAB + tBC)));\n    vec2 m2 = (1.0 - tension) * (s[2] - s[1] + tBC * ((s[3] - s[2]) / tCD - (s[3] - s[1]) / (tBC + tCD)));\n    \n    vec2 a = 2.  * (s[1] - s[2]) + m1 + m2;\n    vec2 b = -3. * (s[1] - s[2]) - m1 - m1 - m2;\n    vec2 c = m1;\n    vec2 d = s[1];\n    \n    return a * t * t * t +\n           b * t * t +\n           c * t +\n           d;\n}\n\n\nfloat sdCircle(vec2 p, float d)\n{\n    return length(p) - d;\n}\n\nfloat sdLine(vec2 p, vec2 a, vec2 b, float r)\n{\n    vec2 g = b - a;\n    vec2 h = p - a;\n    float d = length(h - g * clamp(dot(g, h) / dot(g, g), 0., 1.));\n    return smoothstep(r, 0.5 * r, d);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p,p,p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    float iT = floor(iTime / 1.);   //Time index\n    float iM = fract(iTime / 1.);   //Mix ammount\n    \n    //define spline control points\n    vec2 s[4];\n    \n    //prep background color\n    vec3 col = vec3(0);\n\n    \n    //get control points based on time index and draw\n    for(int i=0; i < 4; i++)\n    {\n        s[i] = hash21(iT + float(i)) - 0.5;\n        col += smoothstep(0.001, 0., sdCircle(uv - s[i], .0125)) * colBlue;\n    }\n    \n    //draw some lines between points\n    col += sdLine(uv, s[0], s[1], 0.002) * colBlue;\n    col += sdLine(uv, s[1], s[2], 0.002) * colYellow;\n    col += sdLine(uv, s[2], s[3], 0.002) * colBlue;\n    \n    //get moving point\n    vec2 mP = splineInterpolation(s, iM);\n    \n    //draw point\n    col += smoothstep(0.001, 0., sdCircle(uv - mP, .0125));\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}