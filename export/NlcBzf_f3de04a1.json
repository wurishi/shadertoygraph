{"ver":"0.1","info":{"id":"NlcBzf","date":"1663431342","viewed":471,"name":"Octahedron Grid Raycasting","username":"Poisson","description":"A raycasted octahedron grid with motion blur. Thanks to @fizzer for the octahedron raycasting algorithm:\nhttps://www.shadertoy.com/view/4lcfDB\n","likes":34,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","raymarching","tunnel","raytracer","ray","raycasting","voxel","raymarcher","octahedron","raycaster","traversal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// thanks to @fizzer for the octahedron raycasting algorithm\n// https://www.shadertoy.com/view/4lcfDB\n\n#define AA 2 // antialiasing\n#define PI 3.141592\n#define TAU 6.283185\n#define MAX_DIST 24.\n\n// rotation function\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// terrain\nfloat map(vec3 p) {\n    p += vec3(0,-.5,1);\n    return sin(p.x-cos(p.z))-sin(cos(p.z)-p.y)-sin(p.z+sin(p.x));\n}\n\n// intersect the scene\nfloat intersect(vec3 ro, vec3 rd, out vec3 n) {\n    vec3 p = ro;\n\n    for(int i=0; i<512; i++) {\n        vec3 q = fract(p)-.5; \n        vec3 r = abs(q); \n        vec3 s = step(r.yzx,r)*step(r.zxy,r) * sign(q); \n        vec3 c = floor(p)+.5 + s*.5;\n        \n        if(map(c) > .65) break;\n\n        vec3 na = s + s.yzx;\n        vec3 nb = s - s.yzx;\n        vec3 nc = s + s.zxy;\n        vec3 nd = s - s.zxy;\n\n        float da = dot(rd,na);\n        float db = dot(rd,nb);\n        float dc = dot(rd,nc);\n        float dd = dot(rd,nd);\n\n        float ta = (sign(da)*.5 - dot(ro-c, na)) / da;\n        float tb = (sign(db)*.5 - dot(ro-c, nb)) / db;\n        float tc = (sign(dc)*.5 - dot(ro-c, nc)) / dc;\n        float td = (sign(dd)*.5 - dot(ro-c, nd)) / dd;\n\n        float t = min(ta, min(tb, min(tc, td)));\n        p = ro + rd * (t + 1e-3);\n        if(t > MAX_DIST) break;\n        \n        vec2 u = vec2(dot(p-c,s.yzx), dot(p-c,s.zxy));\n        vec2 v = abs(u);\n        u = step(v.yx, v) * sign(u);\n        n = -normalize(u.x*s.yzx + u.y*s.zxy + sign(dot(p-c,s))*s);\n    }\n    float t = length(p - ro);\n    return t;\n}\n\nvec3 background(vec3 rd) {\n    return mix(vec3(1), vec3(.6,.8,1), .5+.5*rd.y);\n}\n\n// rendering\nvec3 render(vec3 ro, vec3 rd, float time) {\n    vec3 col = background(rd);\n    vec3 n;\n    float t = intersect(ro, rd, n);\n    if (t < MAX_DIST) {\n        // color and lighting\n        vec3 p = ro + rd * t;\n        vec3 ref = reflect(rd, n);\n        \n        // get octahedron coordinates\n        vec3 q = fract(p)-.5; \n        vec3 r = abs(q); \n        vec3 s = step(r.yzx,r)*step(r.zxy,r) * sign(q); \n        vec3 c = floor(p)+.5 + s*.5;\n        \n        // octahedron edges\n        vec3 b = vec3(abs(dot(p-c,s)), abs(dot(p-c,s.yzx + s.zxy)), abs(dot(p-c,s.yzx - s.zxy)));\n        \n        float edg = b.x*b.y*b.z;\n                      \n        float lin = smoothstep(.01,.02,b.x)*\n        \t\t\tsmoothstep(.01,.02,b.y)*\n        \t\t\tsmoothstep(.01,.02,b.z);\n                    \n        float focc = smoothstep(-.01,.02,edg); // fake occlusion\n        \n        // apply color\n        float f = .5+.5*sin(c.x*7. + 5. + c.y+c.z*3.);\n        vec3 mat = mix(vec3(1), mix(vec3(1,.6,.3), vec3(.5,.7,1), step(f,.25)), step(f,.75));\n        \n        if (f > .99) // lights\n            mat = smoothstep(0.,.05,edg)*200.*vec3(.2,.5,1);\n        \n        // apply texture\n        vec3 xy = texture(iChannel1, p.xy*2.).rgb;\n        vec3 xz = texture(iChannel1, p.xz*2.).rgb;\n        vec3 yz = texture(iChannel1, p.yz*2.).rgb;\n        vec3 m = abs(n);\n        vec3 tex = yz*m.x + xz*m.y + xy*m.z;\n        \n        vec3 lig = normalize(ro-p); // light direction\n        float dif = clamp(dot(n ,lig), 0., 1.); // diffuse lighting\n        float occ = .5+.5*n.y; // fake occlusion\n        float spe = clamp(dot(n, ref), 0., 1.); // specular light\n         \n        col = vec3(0);\n        col += mat*tex*.2*(dif*occ*focc+vec3(.05,.1,.15)*occ*focc); // base layer\n        col += 2.*focc*mat*tex*tex*vec3(1,.5,.3)*pow(spe, 8.); // orange reflection\n        col += tex*mat*pow(spe, 64.)*dif; // highlight\n        col *= mix(.2,1.,lin); // dark edges\n                \n        // fog\n        float fog = 1.-exp(-.005*t*t);\n        col = mix(col, background(rd), fog*vec3(.4,.6,1));\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0);\n    for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n        vec2 o = vec2(i, j) / float(AA) - .5;\n        \n        // motion blur\n        float mb = float(i*AA+j) + texelFetch(iChannel0, ivec2(fragCoord)&1023, 0).x;\n        float time = iTime - .04*mb/float(AA*AA);\n        \n        // setup camera\n        vec3 ro = vec3(0,0,-.3);\n        \n        vec3 rd = vec3(2.*(fragCoord+o) - iResolution.xy, iResolution.y);\n        rd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z - dot(rd.xy,rd.xy)*.2, 0.))));\n        \n        rd.yz *= rot(.5*sin(.3*PI*time));\n        rd.xz *= rot(.5*PI-.3*sin(PI*.6*time));\n        ro.x -= 4.*time;\n        \n        vec3 col = render(ro, rd, time); // render\n        \n        tot += clamp(col,0.,1.);\n    }\n    }\n    tot /= float(AA*AA);\n    \n    tot = pow(tot, vec3(.4545)); // gamma correction\n    // contrast\n    float f0 = .3;\n    tot = tot*(1.+f0)-.5*f0;\n    // vignetting\n    \n    vec2 p = fragCoord / iResolution.xy;\n    tot *= clamp(pow(80. * p.x*p.y*(1.-p.x)*(1.-p.y), .2), 0., 1.);    \n                    \n    fragColor = vec4(tot,1.0);\n}","name":"Image","description":"","type":"image"}]}