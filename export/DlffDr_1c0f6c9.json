{"ver":"0.1","info":{"id":"DlffDr","date":"1692797836","viewed":55,"name":"Simple Raymarching Cloud","username":"Luna5ama","description":"My attempt to rendering cloud","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["cloud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat4 setupPerspective(float fovY, float aspect, float near, float far) {\n    mat4 m = mat4(1.0);\n    float h = tan(fovY / 2.0) * near;\n    float w = h * aspect;\n    m[0][0] = near / w;\n    m[1][1] = near / h;\n    m[2][2] = -(far + near) / (far - near);\n    m[3][2] = -2.0 * far * near / (far - near);\n    return m;\n}\n\nconst float PI = 3.1415926;\nconst vec3 SUN_COLOR = vec3(1.0, 0.98, 0.9);\nconst vec3 SUN_DIR = normalize(vec3(0.0, 0.5, -1.0));\nconst float M_FOV = 90.0 * PI / 180.0;\nconst float M_NEAR = 0.01;\nconst float M_FAR = 128.0;\n\nmat4 projectionM;\nmat4 invProjectionM;\nvec2 nFragCoord;\nvec2 clipCoord;\nvec3 sunViewCoord = SUN_DIR * M_FAR;\n\n/* \n    \"Fast pseudo-3d Perlin noise\" by LukeRissacher\n    https://www.shadertoy.com/view/MtcGRl\n*/\nvec2 getGradient(vec2 intPos, float t) {\n    float rand = texture(iChannel0, intPos / 1024.0).r;\n    \n    // Rotate gradient: random starting rotation, random rotation rate\n    float angle = 6.283185 * rand + 4.0 * t * rand;\n    return vec2(cos(angle), sin(angle));\n}\n\n\nfloat pseudo3dNoise(vec3 pos) {\n    vec2 i = floor(pos.xz);\n    vec2 f = pos.xz - i;\n    vec2 blend = f * f * (3.0 - 2.0 * f);\n    float noiseVal = \n        mix(\n            mix(\n                dot(getGradient(i + vec2(0, 0), pos.y), f - vec2(0, 0)),\n                dot(getGradient(i + vec2(1, 0), pos.y), f - vec2(1, 0)),\n                blend.x),\n            mix(\n                dot(getGradient(i + vec2(0, 1), pos.y), f - vec2(0, 1)),\n                dot(getGradient(i + vec2(1, 1), pos.y), f - vec2(1, 1)),\n                blend.x),\n        blend.y\n    );\n    return noiseVal / 0.7; // normalize to about [-1..1]\n}\n\nfloat beer(float x) {\n    return exp(-x);\n}\n\nfloat powder(float x) {\n    return 1.0 - exp(-2.0 * x);\n}\n\nfloat beersPowder(float x) {\n    return 2.0 * beer(x) * powder(x);\n}\n\nconst int CLOUD_FBM_ITER = 8;\nconst float CLOUD_LIGHTING_ITER = 512.0;\nconst float CLOUD_RAYMARCH_ITER = 16.0;\nconst float CLOUD_DENSITY = 0.9;\nconst vec3 CLOUD_VELOCITY = vec3(0.1, -0.002, -0.05);\n    \n    \nfloat cloudNoise(vec3 coord) {\n    const float DE = sqrt(CLOUD_DENSITY);\n    const vec3 S_COORD_MUL = vec3(1.49, 1.329, 1.47);\n    const vec3 S_COORD_OFFSET = vec3(13.37, 4.111, 69.42);\n    const float S_TIME_OFFSET = 1.64514;\n    \n    float n = 0.0;\n    \n    vec3 sCoord = coord * 2.0;\n    sCoord.y *= 2.0;\n    float sMul = 1.0;\n    vec3 sTime = iTime * CLOUD_VELOCITY;\n    float sAdd = 0.7 * DE;\n    \n    \n    for (int i = 0; i < CLOUD_FBM_ITER; i++) {\n        n += sAdd + sMul * pseudo3dNoise(sCoord + sTime);\n        \n        sCoord = sCoord * S_COORD_MUL + S_COORD_OFFSET;\n        sMul *= 0.65;\n        sTime = sTime * 1.069 + S_TIME_OFFSET;\n        sAdd *= DE * 0.3;\n    }\n    \n    n *= smoothstep(-0.4, 0.4, coord.y);    \n    n *= 1.0 - smoothstep(0.8, 1.6, coord.y);\n    n = clamp(n, 0.0, 1.0);\n\n    \n    return smoothstep(0.3, 0.6, n);\n}\n\nfloat raymarchCloudLight(vec3 samplePos) {\n    const float RAYMARCH_DELTA = 1.0 / CLOUD_LIGHTING_ITER;\n    vec3 startPos = samplePos;\n    vec3 endPos = sunViewCoord;\n    vec3 rayDir = endPos - startPos;\n    \n    float result = 0.0;\n    float count = 0.1;\n    \n    for (float i = 0.0; i < CLOUD_LIGHTING_ITER; i += 1.0) {\n        vec3 sampleCoord = startPos + rayDir * (i * RAYMARCH_DELTA * 0.5);\n        float sd = cloudNoise(sampleCoord);\n        if (sd <= 0.1) break;\n        result += sd;\n        count++;\n    }\n    \n    result /= count;\n    \n    return beersPowder(result);\n}\n\nfloat hgp(float cosTheta) {\n    const float G = 0.3;\n    const float GSQ = G * G;\n    const float ONE_MINUS_GSQ = 1.0 - GSQ;\n    const float ONE_PLUS_GSQ = 1.0 + GSQ;\n    const float QUARTER_INV_PI = 1.0 / (4.0 * 3.1415926);\n    \n  \n//    return QUARTER_INV_PI * (ONE_MINUS_GSQ / pow(ONE_PLUS_GSQ - 2.0 * G * cosTheta, 1.5));\n    float result = 1.0f - GSQ;\n    result /= 4.0f * PI * pow(1.0f + GSQ - 2.0f * G * cosTheta, 1.5f);\n    return result;\n}\n\nvec4 raymarchCloud() {\n    const float RAYMARCH_DELTA = 1.0 / CLOUD_RAYMARCH_ITER;\n\n    vec4 startView = invProjectionM * vec4(clipCoord, 0.0, 1.0);\n    startView /= startView.w;\n    \n    vec4 endView = invProjectionM * vec4(clipCoord, 1.00, 1.0);\n    endView /= endView.w;\n    \n    vec3 rayDir = endView.xyz - startView.xyz;\n    \n    float phase = hgp(dot(normalize(endView.xyz), SUN_DIR));\n    float cloudDensity;\n    float cloudLight;\n    \n    for (float i = 0.0; i < CLOUD_RAYMARCH_ITER; i += 1.0) {\n        vec3 sampleCoord = startView.xyz + rayDir * (i * RAYMARCH_DELTA);\n        float sd = cloudNoise(sampleCoord);\n        if (sd <= 0.1) continue;\n        \n        sd *= RAYMARCH_DELTA;\n        \n        float lum = raymarchCloudLight(sampleCoord);\n        \n        cloudLight += beer(cloudDensity) * sd * lum;\n        cloudDensity += sd;\n    }\n    \n    cloudLight *= 1.6 + sqrt(phase) * 1.2;\n    \n    vec4 result = vec4(1.0);\n    \n    result.rgb *= cloudLight;\n    \n    result.a = cloudDensity * cloudLight;\n    result.a = smoothstep(0.4, 1.0, result.a);\n    \n    return result;\n}\n\nvec4 cloud() {\n    \n    vec4 col = vec4(1.0);\n    col *= raymarchCloud();\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    nFragCoord = fragCoord / iResolution.xy;\n    clipCoord = nFragCoord * 2.0 - 1.0;\n\n    projectionM = setupPerspective(M_FOV, iResolution.x / iResolution.y, M_NEAR, M_FAR);\n    invProjectionM = inverse(projectionM);\n        \n    vec4 viewCoord = invProjectionM * vec4(clipCoord, 1.0, 1.0);\n    viewCoord.xyz /= viewCoord.w;\n\n    \n    fragColor.a = 1.0;\n    \n    if (clipCoord.y < -0.2) {\n        fragColor.rgb = vec3(0.5);\n    } else {\n        fragColor.rgb = vec3(0.6, 0.75, 1.0);\n        vec4 cloudColor = cloud();\n        fragColor.rgb = mix(fragColor.rgb, cloudColor.rgb, cloudColor.a);\n        \n        fragColor.rgb += SUN_COLOR * smoothstep(0.99, 1.0, dot(SUN_DIR, normalize(viewCoord.xyz))); \n    }\n    \n    //fragColor.rgb = viewCoord.rgb * 0.5 + 0.5;\n}","name":"Image","description":"","type":"image"}]}