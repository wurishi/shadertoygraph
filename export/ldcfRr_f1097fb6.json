{"ver":"0.1","info":{"id":"ldcfRr","date":"1523946145","viewed":1253,"name":"Image Filters","username":"imagire","description":"A test for some image filtering methods.\n\n 1 | 2 | 3\n-----------\n 4 | 5 | 6\n\n1: nearest neighbor\n2: bi-linear\n2: bi-cubic\n4: Lanczos3\n5: BlackmanSinc\n6: Nonlinear Filtering (Seiichi GOHSHI, \"A New Signal Processing Method for Video\")","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["filtering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 Nearlest(vec2 uv, vec2 InvResolution)\n{\n    return texture(iChannel0, uv - (mod(uv / InvResolution, 1.0)-0.5) * InvResolution).rgb;\n}\n\nvec3 Bilinear(vec2 uv)\n{\n    return texture(iChannel0, uv).rgb;\n}\n\nfloat bicubicWeight(float d)\n{\n    d = abs(d); \n    \n    if(2.0 < d){\n        return 0.0;\n    }\n    \n    const float a = -1.0;\n    float d2 = d * d;\n    float d3 = d * d * d;\n    \n    if(1.0 < d){\n        return a * d3 - 5.0 * a * d2 + 8.0 * a * d - 4.0 * a;\n    }\n    \n    return (a + 2.0) * d3 - (a+3.0) * d2 + 1.0;\n}\n\nvec3 BiCubic(vec2 uv, vec2 InvResolution)\n{\n    vec2 center = uv - (mod(uv / InvResolution, 1.0)-0.5) * InvResolution;// texel center\n    vec2 offset = (uv - center)/InvResolution;// relevant texel position in the range -0.5～+0.5\n    \n    vec3 col = vec3(0,0,0);\n    float weight = 0.0;\n    for(int x = -2; x <= 2; x++){\n    for(int y = -2; y <= 2; y++){\n        \n        float wx = bicubicWeight(float(x)-offset.x);\n        float wy = bicubicWeight(float(y)-offset.y);\n        float w = wx * wy;\n        \n        col += w * texture(iChannel0, center + vec2(x,y) * InvResolution).rgb;\n        weight += w;\n    }\n    }\n    col /= weight;\n    \n    return col;\n}\n\nfloat sinc(float x)\n{\n    return sin(x * 3.1415926535897932384626433) / (x * 3.1415926535897932384626433); \n}\nfloat lanczosWeight(float d, float n)\n{\n    return (d == 0.0) ? (1.0) : (d*d < n*n ? sinc(d) * sinc(d / n) : 0.0);\n}\nvec3 Lanczos3(vec2 uv, vec2 InvResolution)\n{\n    vec2 center = uv - (mod(uv / InvResolution, 1.0)-0.5) * InvResolution;// texel center\n    vec2 offset = (uv - center)/InvResolution;// relevant texel position in the range -0.5～+0.5\n    \n    vec3 col = vec3(0,0,0);\n    float weight = 0.0;\n    for(int x = -3; x < 3; x++){\n    for(int y = -3; y < 3; y++){\n        \n        float wx = lanczosWeight(float(x)-offset.x, 3.0);\n        float wy = lanczosWeight(float(y)-offset.y, 3.0);\n        float w = wx * wy;\n        \n        col += w * texture(iChannel0, center + vec2(x,y) * InvResolution).rgb;\n        weight += w;\n    }\n    }\n    col /= weight;\n    \n    return col;\n}\n\nfloat blackmanWin(float d, float n) \n{\n    const float pi = 3.14159265358979323846;\n    return 0.42 + 0.5  * cos(2.0 * pi * d / n)\n                 + 0.08 * cos(4.0 * pi * d / n);\n}\nfloat BlackmanSincWeight(float d, float n)\n{\n    return (d == 0.0) ? (1.0) : (d*d < n*n ? sinc(d) * blackmanWin(d, n) : 0.0);\n}\n\nvec3 BlackmanSinc(vec2 uv, vec2 InvResolution)\n{\n    vec2 center = uv - (mod(uv / InvResolution, 1.0)-0.5) * InvResolution;// texel center\n    vec2 offset = (uv - center)/InvResolution;// relevant texel position in the range -0.5～+0.5\n    \n    vec3 col = vec3(0,0,0);\n    float weight = 0.0;\n    for(int x = -4; x <= 4; x++){\n    for(int y = -4; y <= 4; y++){\n        \n        float wx = BlackmanSincWeight(float(x)-offset.x, 4.0);\n        float wy = BlackmanSincWeight(float(y)-offset.y, 4.0);\n        float w = wx * wy;\n        \n        col += w * texture(iChannel0, center + vec2(x,y) * InvResolution).rgb;\n        weight += w;\n    }\n    }\n    col /= weight;\n    \n    return col;\n}\n    \nfloat spline36_weight(float d)\n{\n    d = abs(d); \n    \n    if(3.0 < d){\n        return 0.0;\n    }\n\n    float d2 = d*d;\n    float d3 = d*d*d;\n    if(2.0 < d){\n        return 1.0/11.0*d3 - 159.0/209.0*d2 + 434.0/209.0*d - 384.0/209.0;\n    }else\n    if(1.0 < d){\n        return -6.0/11.0*d3 + 612.0/209.0*d2 - 1038.0/209.0*d + 540.0/209.0;\n    }\n    \n    return 13.0/11.0*d3 - 453.0/209.0*d2 - 3.0/209.0*d + 1.0;\n\n}\nvec3 Spline36(vec2 uv, vec2 InvResolution)\n{\n    vec2 center = uv - (mod(uv / InvResolution, 1.0)-0.5) * InvResolution;// texel center\n    vec2 offset = (uv - center)/InvResolution;// relevant texel position in the range -0.5～+0.5\n    \n    vec3 col = vec3(0,0,0);\n    float weight = 0.0;\n    for(int x = -3; x < 3; x++){\n    for(int y = -3; y < 3; y++){\n        \n        float wx = spline36_weight(float(x)-offset.x);\n        float wy = spline36_weight(float(y)-offset.y);\n        float w = wx * wy;\n        \n        col += w * texture(iChannel0, center + vec2(x,y) * InvResolution).rgb;\n        weight += w;\n    }\n    }\n    col /= weight;\n    \n    return col;\n}\n\nvec3 gamma(vec3 src)\n{\n    vec3 dest;\n    dest.r = pow(src.r, 1.0/2.2);\n    dest.g = pow(src.g, 1.0/2.2);\n    dest.b = pow(src.b, 1.0/2.2);\n    return dest;\n}\nvec3 inv_gamma(vec3 src)\n{\n    vec3 dest;\n    dest.r = pow(src.r, 2.2);\n    dest.g = pow(src.g, 2.2);\n    dest.b = pow(src.b, 2.2);\n    return dest;\n}\n\nvec3 NonlinearFiltering(vec2 uv, vec2 InvResolution)\n{\n    vec2 center = uv;\n\n    vec3 original = texture(iChannel0, center).rgb;\n    original = inv_gamma(original);\n    \n    // blurring\n    vec3 low \n        = 4.0 * original \n        + 2.0 * texture(iChannel0, center + vec2(-1.5,+0.0) * InvResolution).rgb\n        + 2.0 * texture(iChannel0, center + vec2(+1.5,+0.0) * InvResolution).rgb\n        + 2.0 * texture(iChannel0, center + vec2(+0.0,+1.5) * InvResolution).rgb\n        + 2.0 * texture(iChannel0, center + vec2(+0.0,-1.5) * InvResolution).rgb\n        + 1.0 * texture(iChannel0, center + vec2(-1.5,-1.5) * InvResolution).rgb\n        + 1.0 * texture(iChannel0, center + vec2(-1.5,+1.5) * InvResolution).rgb\n        + 1.0 * texture(iChannel0, center + vec2(+1.5,-1.5) * InvResolution).rgb\n        + 1.0 * texture(iChannel0, center + vec2(+1.5,+1.5) * InvResolution).rgb;\n    float weight = 4.0 + 2.0 * 4.0 + 1.0 * 4.0;\n    low = inv_gamma(low / weight); // inverse gamma correct (wanna before averaging...)\n    \n    // high frequency term (subtract blurred component)\n    vec3 high = original - low;\n        \n    // non-linear transform\n    high = high * high * high;\n    high *= 20.0;// enhance\n    \n    // limitation\n    float intensity = 0.2126*high.r + 0.7152*high.g + 0.0722*high.b;\n    intensity = abs(intensity);\n    float k = 0.5;\n    float ToneMapping = 1.0 - exp(-k*intensity);    // exponential tone mapping\n    if(0.0 < intensity) high *= ToneMapping / intensity;\n    \n    // add non-linear high frequency term\n    vec3 col = original + high;\n    \n    return gamma(col);// gamma correct\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n     vec3 col = vec3(0.0);\n\n    // for london texture\n//    float scale = 3.0;\n//    vec2 uv = fragCoord/iResolution.xy / scale + 0.5 - 0.5 / scale;\n\n    // for Nyancat\n    vec2 uv = fragCoord/iResolution.xy * vec2(1.0/2.1, 2.0/1.0);\n    \n    vec2 InvResolution = 1.0 / iChannelResolution[0].xy;\n    \n    vec2 idx = fragCoord/iResolution.xy * vec2(3.0, 2.0);// for fix features\n    \n    if(1.0 < idx.y){\n        if(idx.x < 1.0){\n\t\t    col = Nearlest(uv, InvResolution);\n        }else if(idx.x < 2.0){\n\t\t    col = Bilinear(uv);\n        }else{\n\t\t    col = BiCubic(uv, InvResolution);\n        }\n    }else{\n        if(idx.x < 1.0){\n    \t\tcol = Lanczos3(uv, InvResolution);\n        }else if(idx.x < 2.0){\n//\t\t    col = Spline36(uv, InvResolution);\n    \t\tcol = BlackmanSinc(uv, InvResolution);\n        }else{\n\t\t    col = NonlinearFiltering(uv, InvResolution);  \n        }\n    }\n    \n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}