{"ver":"0.1","info":{"id":"ttlGWs","date":"1558129842","viewed":263,"name":"Cubewave","username":"fydrenak","description":"A nice effect with value noise & rounded cubes. I am very new to raymarching. I'd really appreciate tips on how to remove the artifacts that appear If you increase the height of the noise.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","ray","wave","cube","cubes","marching","value","roundcube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 300.\n#define SURF_DIST .01\n\n\n//NOISE GENERATION\nfloat noise2D(vec2 p)\n{\n\treturn fract(sin(p.x * 67. + p.y * 1231.57) * 5723.);\n}\n\n\nfloat smoothNoise(vec2 uv)\n{\n\t//grid local UV\n\tvec2 lv = fract(uv);\n\t//grid ID\n\tvec2 id = floor(uv);\n\n\t//smooth lv\n\tlv = lv*lv*(3.-2.*lv);\n\n\tfloat bl = noise2D(id);\n\tfloat br = noise2D(id + vec2(1, 0));\n\tfloat b = mix(bl, br, lv.x);\n\n\tfloat tl = noise2D(id + vec2(0, 1));\n\tfloat tr = noise2D(id + vec2(1));\n\tfloat t = mix(tl, tr, lv.x);\n\n\treturn mix(b, t, lv.y);\n}\n\n\n//4 octaves of lerp'd noise\nfloat valueNoise(vec2 uv)\n{\n\tfloat value = smoothNoise(uv * 4.)\n\t            + smoothNoise(uv * 8.) * .5;\n\t            + smoothNoise(uv * 16.) * .25;\n\t            + smoothNoise(uv * 32.) * .125;\n\n\tvalue /= 2.;\n\n\treturn value;\n}\n\n\n//END NOISE GENERATION\n\n\nvec3 repeatXZ(vec3 p, float c)\n{\n\tvec3 q = mod(p, c) - .5 * c;\n\tq.y = p.y;\n\n\treturn q;\n}\n\n\nmat2 rot(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\n\treturn mat2(-c, -s, s, -c);\n}\n\n\nfloat getSphereDist(vec3 p)\n{\n\treturn length(p) - 1.;\n}\n\n\nfloat getCubeDist(vec3 p)\n{\n\tvec3 toCorner = abs(p) - 1.;\n\n\tfloat extDist = length(max(toCorner, 0.));\n\tfloat intDist = max(toCorner.x, max(toCorner.y, toCorner.z));\n\n\treturn extDist + min(intDist, 0.);\n}\n\n\nfloat getSceneDist(vec3 p)\n{\n\tfloat c = 2.5;\n\tvec2 cubeCoords = floor(abs(p.xz) / c) * .06;\n\tfloat yOffset = valueNoise(cubeCoords + vec2(iTime*.5,0) );\n    \n    //scale the offset which is between 0 - 1\n    yOffset *= 4.;\n\t\n\tvec3 cubePos = vec3(0, .5, 0);\n\tcubePos.y += yOffset;\n\n\tfloat dist = getCubeDist(repeatXZ(p, c) - cubePos) - .2;\n\n\treturn min(dist, p.y);\n}\n\n\nfloat rayMarch(vec3 ro, vec3 rd, out int objFound)\n{\n\tfloat dist = 0.;\n\tobjFound = -1;\n\n\tfor (int i = 0; i < MAX_STEPS; ++i)\n\t{\n\t\tvec3 p = ro + dist * rd;\n\t\tfloat sceneDist = getSceneDist(p);\n\n\t\tdist += sceneDist * .3;\n\n\t\tif (sceneDist < SURF_DIST)\n\t\t{\n\t\t\tobjFound = 1;\n\t\t\tbreak;\n\t\t}\n\t\telse if (dist > MAX_DIST)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn dist;\n}\n\n\nvec3 getNormal(vec3 p)\n{\n\tfloat dist = getSceneDist(p);\n\n\tvec2 e = vec2(.02, 0.);\n\n\tvec3 normal = dist - vec3(\n\t\tgetSceneDist(p - e.xyy),\n\t\tgetSceneDist(p - e.yxy),\n\t\tgetSceneDist(p - e.yyx)\n\t);\n\n\treturn normalize(normal);\n}\n\n\nfloat getLight(vec3 p)\n{\n\tvec3 lightPos = vec3(112, 10, 0);\n\n\tvec3 toLight = normalize(lightPos - p);\n\tvec3 normal = getNormal(p);\n\n\tfloat angle = dot(normal, toLight);\n\tfloat diff = clamp(angle, 0., 1.);\n\n\t//shadows\n\tint oFound;\n\tfloat dist = rayMarch(p+normal*SURF_DIST*10., toLight, oFound);\n\n\tif (oFound == 1 && dist < length(p - lightPos))\n\t{\n\t\tdiff *= .1;\n\t}\n\n\treturn diff;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\tvec3 ro = vec3(112, 32, 0);\n\tvec3 rd = normalize(vec3(uv.x, uv.y - .6, 1));\n\n\tint oFound;\n\tfloat dist = rayMarch(ro, rd, oFound);\n\tvec3 col = vec3(0);\n\n\tif (oFound == 1)\n\t{\n\t\tvec3 collidePoint = ro + dist * rd;\n\t\tfloat diff = getLight(collidePoint);\n\n\t\tcol = vec3(diff);\n\t}\n\n\tfragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}