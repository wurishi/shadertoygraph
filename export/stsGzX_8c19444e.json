{"ver":"0.1","info":{"id":"stsGzX","date":"1622561534","viewed":183,"name":"Infinite Stars","username":"IamWiki","description":"This is the first time I used fractional parts of the rays in order to create an infinite number of shapes. I used it on one of my experimental shaders and this is the result. * - *","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["star","stars","infinite","infinity","dimension"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100.\n\nmat2 rot(float a)\n{\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\n#define rep(p,s) (fract(p/s-0.5)-0.5)*s\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat box(vec3 p, vec3 s)\n{\n    p = abs(p) - s;\n    return max(p.x, max(p.y, p.z));\n}\n\nfloat smin(float a, float b, float h)\n{\n    float k = clamp((a-b)/ h * .5 + .5, 0., 1.);\n    return mix(a,b,k) - k * (1.-k) * h;\n}\n\nvec3 smin(vec3 a, vec3 b, float h)\n{\n    vec3 k = clamp((a-b)/ h * .5 + .5, 0., 1.);\n    return mix(a,b,k) - k * (1.-k) * h;\n}\n\nvec3 tunnel(vec3 p)\n{\n    vec3 off = vec3(0);\n    float dd = p.z * 0.02;\n    dd = floor(dd) + smoothstep(0., 1., smoothstep(0., 1., fract(dd)));\n    dd *= 1.7;\n    off.x += sin(dd) * 10.;\n    off.y += sin(dd * 0.7) * 10.;\n\n    return off;\n}\n\nvec3 kif(vec3 p, float t)\n{\n  float d;\n  float s = 10.;\n  for(int i = 0; i < 5; ++i)\n  {\n    p.xy *= rot(t);\n    p.xz *= rot(t*.7);\n    p = smin(p, -p, -1.);\n    p -= s;\n    \n    //p -= s + sin(t - length(p));\n    s *= 0.4;\n  }\n  \n  return p;\n}\n\nfloat at = 0.;\nfloat atsph = 0.;\nfloat atbsph = 0.;\nfloat map(vec3 p)\n{\n    \n    vec3 p1 = p;\n    vec3 p2 = rep(p, 100.);\n    \n    p1 = kif(p2, iTime * 0.1);\n    p1.xy *= rot(iTime * 0.3);\n    p1.xz *= rot(iTime * 0.7);\n    float d1 = box(p1, vec3(0.01));\n    float d2 = sphere(p2, 10.5);\n    float d3 = sphere(p2, .8);\n    float d4 = sphere(p2, 3.);\n    \n    float d = max(d1, d2);\n\n    at += 0.1 / (0.01 + abs(d2));\n    atsph += 0.1 / (0.0 + abs(d3));\n    d3 = min(d3, d4);\n    atbsph += 0.3 / (0.01 + abs(d4));\n    d = min(d, d3);\n\n    return d;\n}\n\nvoid cam(inout vec3 p)\n{\n    float t = iTime * 0.05;\n    p.xy *= rot(t);\n    p.xz *= rot(t * 0.7);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1.);\n\n    vec3 s = vec3(0, 0, -50);\n    vec3 r = vec3(uv, 1);\n    //s -= tunnel(s);\n\n    cam(s);\n    cam(r);\n\n    s.z += iTime * 10.;\n    s.x += sin(iTime / 16.) * 25.;\n\n    vec3 p = s;\n    float d = 0.;\n\n    float i = 0.;\n    float dd = 0.;\n    vec3 off = vec3(0.1, 0, 0);\n    for(i = 0.; i < MAX_STEPS; i++)\n    {\n        d = map(p);\n        dd += d;\n        d *= 0.4;\n        //vec3 n = normalize(map(p) - vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n        if(d < 0.001)\n        {\n            d = 0.1;\n        }\n        p += r*d;\n    }\n    \n    atsph *= 50.;\n    \n    vec3 col = vec3(0);\n    //col += vec3(pow(1.-i/(MAX_STEPS + 1.), 3.)) * 1.;\n    col += pow(at * 0.016, 6.) * vec3(0.5,0,0.5);\n    col += pow(atsph * 0.016, 3.) * vec3(1,0,0);\n    col += pow(atbsph * 0.2, sin(iTime * 2.)*.1+1.1) * vec3(0,1.,0.);\n\n    //float dist = length(p-s);\n    //col -= 1. / dist;\n    \n\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}