{"ver":"0.1","info":{"id":"WsyXWR","date":"1573733829","viewed":334,"name":"4.6.12 Truchet Weave","username":"fizzer","description":"A 'weaved' version of my 4.6.12 semi-regular Truchet tiling ([url=https://www.shadertoy.com/view/llyBRG]this one[/url]).","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["hexagon","truchet","tiling","weaving","weave","dodecagon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This is a 'weaved' version of my 4.6.12 semi-regular truchet tiling, which\n// you can see here: https://www.shadertoy.com/view/llyBRG\n\nconst float pi = 3.141592653589;\nconst float r = .017;\nconst float r2 = .005;\nconst float slope = .05;\nconst vec2 dir = vec2(.06, slope);\nconst float r3 = (r + r2 * 0.15) / (dir.x / length(dir));\n\n// Pixel width for anti-aliasing.\nfloat w;\n\n\nfloat hash(vec2 p)\n{\n    return texelFetch(iChannel0, ivec2(p) & 255, 0).r;\n}\n\n// (via comments on https://www.shadertoy.com/view/wdBSRm):\n// adx's considerably more concise version of the method above.\n// On a side note, if you haven't seen it before, his \"Quake / Introduction\" \n// shader is well worth the look: https://www.shadertoy.com/view/lsKfWd\nvoid solveCircle(vec2 a, vec2 b, out vec2 o, out float r){\n    \n    vec2 m = a + b;\n    o = dot(a, a)/dot(m, a)*m;\n    r = length(o - a);\n    \n}\n\nfloat arcDistance(vec2 p, vec2 a, vec2 b)\n{\n    if(abs(a.x * b.y - a.y * b.x) < 1e-5)\n        return distance(p, mix(a, b, clamp(dot(p - a, b - a) / dot(b - a,b - a), 0., 1.)));\n\n    vec2 o;\n    float r;\n    solveCircle(a, b, o, r);\n    return abs(distance(p, o) - r);\n}\n\n// Draws a line or arc connecting a and b inside a polygon.\nfloat l(vec2 p, vec2 a, vec2 b)\n{\n    float d = arcDistance(p, a, b);\n    return smoothstep(0.03, 0.03 - w * 2., d - .04);\n}\n\n// Based on https://www.shadertoy.com/view/llGSzw\nuint hash1( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\n\nvoid sdRope(vec2 p, out float mask_d, out float outline_d)\n{    \n    float pd = dot(p, vec2(dir.y, -dir.x)) / ((r + r2 * 0.15) * 2. * length(dir));\n    \n    p.y += 2. * r3 * floor(pd) + r3;\n    \n    vec2 q = dir * clamp(dot(p, dir) / dot(dir, dir), -.5, +.5);\n    \n    float d = distance(p, q) - r;\n    \n    mask_d = d - r2;\n    outline_d = min(max(-d, abs(p.x) - r * 2.5), abs(d) - r2);\n}\n\nvec4 arcDistanceRope(vec2 p, vec2 a, vec2 b)\n{\n    float mask_d;\n    float outline_d;\n    float mask2;\n\n    float sr = r3 * 2.;\n\n    if(abs(a.x * b.y - a.y * b.x) < 1e-5)\n    {\n    \tfloat ld = distance(p, mix(a, b, clamp(dot(p - a, b - a) / dot(b - a,b - a), 0., 1.)));\n        \n        vec2 n = normalize(b - a);\n\n        float da = dot(a, n);\n        float db = dot(b, n);\n        float d = dot(p, n);\n        \n        vec2 q = vec2(dot(p, -vec2(n.y,-n.x)), mix(round(da / sr) * sr, round(db / sr) * sr, (d - da) / (db - da)));\n\n        sdRope(q + vec2(0., r3), mask_d, outline_d);\n\n        mask2 = ld-.033;\n    }\n    else\n    {    \n        vec2 o;\n        float r;\n        solveCircle(a, b, o, r);\n        \n        vec2 nm = normalize((a + b) / 2. - o);\n        \n        vec2 na = normalize(a - o);\n        vec2 nb = normalize(b - o);\n        vec2 np = normalize(p - o);\n\n        float tha = asin(na.x * nm.y - na.y * nm.x) * r;\n        float thb = asin(nb.x * nm.y - nb.y * nm.x) * r;\n        float th = asin(np.x * nm.y - np.y * nm.x) * r;\n\n        vec2 q = vec2(length(p - o) - r, mix(round(tha / sr) * sr, round(thb / sr) * sr, (th - tha) / (thb - tha)));\n\n        sdRope(q + vec2(0., r3), mask_d, outline_d);\n\n        mask2 = abs(distance(p, o) - r)-.033;\n    }\n\n    vec3 col = vec3(mix(vec3(.02), vec3(.8), smoothstep(0.0, w, outline_d)));\n    \n    return vec4(col, 1. - smoothstep(0.0, w, mask2 - 0.03));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n\n    fragColor = vec4(1);\n\n    vec2 p = uv.xy * 4.5 + iMouse.xy / iResolution.xy * 10.;\n\n    w = max(length(dFdx(p)), length(dFdy(p)));\n\n    p.x += iTime / 3.;\n\n    // The plane is first divided in to equilaterial triangles.\n    \n    float s = 1. / sqrt(3.);\n\n    vec2 op = p;\n\n    p.x /= s;\n    p.x += mod(floor(p.y), 2.);\n\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n\n    if(fp.x > mix(fp.y, 1. - fp.y, mod(ip.x, 2.)))\n        ip.x += 1.;\n\n    fp = p - ip;\n\n    fp.x *= s;\n    fp.y -= 1. / 3. + mod(ip.x + 1., 2.) / 3.;\n\n    if(mod(ip.x, 2.) > .5)\n        fp.y =- fp.y;\n\n    vec4 a = vec4(vec3(.8), 0.);\n\n    fp.x = abs(fp.x);\n\n    float th = pi * 2. / 3.;\n\n    // Use the symmetry of the figure within the triangular tile.\n    \n    if(dot(fp, vec2(cos(th), sin(th))) < 0.)\n        fp = fp - vec2(cos(th), sin(th)) * dot(fp, vec2(cos(th), sin(th))) * 2.;\n\n    fp.x = abs(fp.x);\n\n    float dd = fp.y;\n    dd = max(dd, dot(fp, vec2(sin(th), -cos(th))));\n\n\t// Get the precise distances of the tile edges.\n    \n    float c = tan(pi * 2. / 6.) / (3. * tan(pi * 2. / 6.) + 3.);\n    float e = 1. / 3. - c;\n    float f = 1. / (3. * cos(pi * 2. / 6.)) - c;\n\tfloat g = 0.;\n    \n    uint num_inds = 0U;\n    float outth = 0., thoffset = 0.;\n    float r = 1.;\n    \n    if(dd - c < 0.)\n    {\n        // Hexagon.\n        op = op * vec2(1. / s, 1) + vec2(.5, 0);\n        ip = floor(op);\n\n        num_inds = 6U;\n        \n        fp = op - ip - .5;\n\n        fp.x *= s;\n        fp.y -= 1. / 6. * (1. - 2. * mod(ip.x + ip.y, 2.));\n\n        float th = pi * 2. / 6.;\n\n        outth = th;\n        r = c;\n\n        float tha = th*(floor(6. * hash(ip * 3. + 2.)) + .5);\n        fp *= mat2(cos(tha), sin(tha), -sin(tha), cos(tha));\n\n        int i = int(floor(hash(ip * 13. + 99.) * 1.999));\n\n        g = max(g, smoothstep(-w * 2., 0., dd - c));\n\n    }\n    else if((abs(fp.x)-e)<0.)\n    {\n        // Square.\n        op = op * vec2(1. / s, 2) + vec2(.5 + .5 * mod(floor(op.y * 2. + .5), 2.), .5);\n        ip = floor(op);\n\n        num_inds = 4U;\n\n        fp = op - ip - .5;\n\n        fp.x *= s;\n        fp.y /= 2.;\n\n        float th = pi * 2. / 4.;\n\n        outth = th;\n        r = e;\n\n        float tha = th * floor(3.999 * hash(ip * 3. + 2.));\n\n        if(mod(ip.y, 2.) > .5)\n            tha += pi * 2. / 3. * .5 * (2. - mod(ip.x + floor(ip.y / 2.), 2.));\n\n        fp *= mat2(cos(tha), sin(tha), -sin(tha), cos(tha));\n\n        g = max(g, smoothstep(e - w * 2., e, max(abs(fp.x), abs(fp.y))));\n    }\n    else\n    {\n        // Dodecagon.\n        op = op * vec2(1. / s / 2., 1.) + vec2(.5 + .5 * mod(floor(op.y + .5), 2.), .5);\n        ip = floor(op);\n\n        num_inds = 12U;\n\n        fp = op - ip - .5;\n\n        fp.x *= s * 2.;\n\n        float th = pi * 2. / 12.;\n\n        outth = th;\n        r = f;\n\n        float tha = th * floor(12. * hash(ip * 3.));\n        fp *= mat2(cos(tha), sin(tha), -sin(tha), cos(tha));\n\n        int i = int(floor(hash(ip * 13. + 99.) * 28.999));\n\n        float d = -1.;\n\n        for(int j = 0; j < 6; j+=1)\n            d = max(d, abs(dot(fp, vec2(cos(th * float(j)), sin(th * float(j))))) - f);\n\n        g = max(g, smoothstep(-w * 2., 0., d));\n    }\n\n    // Shuffle the indices by using the Fisher-Yates algorithm\n    // https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle\n\n    uint inds[12];\n    \n\tinds[0] = 0U;\n    \n    uint seed = uint(ip.x + ip.y * 8192.)*319U;\n    for(uint j = 1U; j < num_inds; ++j)\n    {\n        seed = hash1(seed);\n        uint k = seed % j;\n        uint temp = inds[k];\n        inds[k] = j;\n        inds[j] = temp;\n    }\n\n    // Draw the arcs.\n    \n    for(uint j = 0U; j < num_inds; j += 2U)\n    {\n        uint ia = inds[j];\n        uint ib = inds[j + 1U];\n        vec2 pa = vec2(cos(outth * float(ia) - thoffset), sin(outth * float(ia) - thoffset)) * r;\n        vec2 pb = vec2(cos(outth * float(ib) - thoffset), sin(outth * float(ib) - thoffset)) * r;\n        vec4 d = arcDistanceRope(fp, pa, pb);\n        a = mix(a, d, d.a);\n    }\n    \n    \n    // Shade.\n    vec3 col = mix(vec3(1), vec3(.3), g);\n\n    float l = 1. - (min(fract(iTime / 6.) * 2., 2. - 2. * fract(iTime / 6.)) - .5) * 16.;\n\n    fragColor.rgb = mix(a.rgb, a.rgb * col, (1. - a.a) * smoothstep(0., 1., l));\n\n    // Gamma etc.\n    fragColor.rgb = pow(fragColor.rgb, vec3(1. / 2.2));\n}\n","name":"Image","description":"","type":"image"}]}