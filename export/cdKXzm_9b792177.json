{"ver":"0.1","info":{"id":"cdKXzm","date":"1680882279","viewed":39,"name":"Mario Bros","username":"YanisHlali","description":"Ce shader reproduit une scène assez basique du célèbre jeu vidéo mario","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["videogame"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Cette variable uniforme indique si le joueur est actuellement hors de l'écran\nuniform bool isPlayerOffScreen;\n\n// Cette fonction génère des nombres aléatoires en utilisant une formule mathématique\nfloat random(vec2 st, float seed) {\n    // La formule utilise la fonction sin pour générer un nombre compris entre 0 et 1\n    return fract(sin(dot(st + seed, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n// Cette fonction dessine un nuage sur le ciel en utilisant une texture\nvec3 drawCloud(vec2 uv, vec2 cloudPos, vec3 bgColor) {\n    // La taille du nuage\n    float cloudRadius = 0.07;\n    // La distance entre la texture actuelle et la position du nuage\n    float cloudDist = length(uv - cloudPos);\n    // La largeur du bord du nuage\n    float cloudEdgeWidth = 0.01;\n    // Le coefficient de transition pour mélanger la couleur du nuage et la couleur d'arrière-plan\n    float t = smoothstep(cloudRadius - cloudEdgeWidth, cloudRadius, cloudDist);\n\n    vec3 cloudColor = vec3(1.0);\n    // Mélange entre la couleur du nuage et la couleur d'arrière-plan\n    return mix(cloudColor, bgColor, t);\n}\n\n// Cette fonction dessine le ciel avec des nuages\nvec3 drawSky(vec2 uv) {\n    // La couleur initiale du ciel\n    vec3 skyColor = vec3(0.3, 0.6, 0.9);\n\n    // La vitesse de déplacement des nuages\n    float cloudSpeed = -0.2;\n    // Dessine 10 nuages sur le ciel\n    for (int i = 0; i < 10; i++) {\n        // La position du nuage en fonction du temps et de son numéro\n        vec2 cloudPos = vec2(mod(cloudSpeed * iTime + float(i) * 0.1, 1.0), 0.3 + random(vec2(float(i), 0.0), 0.0) * 0.4);\n        // Dessine le nuage sur le ciel\n        skyColor = drawCloud(uv, cloudPos, skyColor);\n    }\n\n    // Mélange final entre la couleur du ciel et la couleur blanche\n    return mix(skyColor, vec3(1.0), pow(1.0 - uv.y, 3.0));\n}\n\n\n// Cette fonction génère du bruit de Perlin en utilisant des formules mathématiques\nfloat perlinNoise(vec2 uv) {\n    // Arrondit la valeur `uv` à l'entier inférieur\n    vec2 p = floor(uv);\n    // Calcule la fraction de la valeur `uv`\n    vec2 f = fract(uv);\n    // Applique une formule mathématique à la fraction pour obtenir une valeur entre 0 et 1\n    f = f * f * (3.0 - 2.0 * f);\n\n    // Calcule la valeur `a` en utilisant la formule dot et la constante `vec2(12.9898, 78.233)`\n    float a = dot(p, vec2(12.9898, 78.233));\n    // Calcule la valeur `b` en utilisant la formule dot et la constante `vec2(12.9898, 78.233)`\n    float b = dot(p + vec2(1, 0), vec2(12.9898, 78.233));\n    // Calcule la valeur `c` en utilisant la formule dot et la constante `vec2(12.9898, 78.233)`\n    float c = dot(p + vec2(0, 1), vec2(12.9898, 78.233));\n    // Calcule la valeur `d` en utilisant la formule dot et la constante `vec2(12.9898, 78.233)`\n    float d = dot(p + vec2(1, 1), vec2(12.9898, 78.233));\n\n    // Calcule la valeur finale en utilisant la fonction `mix`\n    float n = mix(\n        mix(fract(sin(a) * 43758.5453123),\n            fract(sin(b) * 43758.5453123), f.x),\n        mix(fract(sin(c) * 43758.5453123),\n            fract(sin(d) * 43758.5453123), f.x), f.y);\n    return n;\n}\n\n\n// Cette fonction crée une texture de sol en utilisant de l'herbe\nvec3 groundTexture(vec2 uv) {\n    // Un facteur de mise à l'échelle pour la texture\n    float scale = 1000.0;\n    // Une variable `st` qui représente la position de la texture\n    vec2 st = uv * scale;\n    // Génère du bruit de Perlin en utilisant la position `st`\n    float noise = perlinNoise(st);\n\n    // Couleur claire pour l'herbe\n    vec3 lightGrassColor = vec3(0.3, 0.7, 0.3);\n    // Couleur foncée pour l'herbe\n    vec3 darkGrassColor = vec3(0.1, 0.5, 0.1);\n    // Mélange les couleurs claires et foncées en fonction du bruit de Perlin\n    vec3 texColor = mix(lightGrassColor, darkGrassColor, noise);\n\n    return texColor;\n}\n\n// Cette fonction dessine le sol en utilisant la texture d'herbe\nvec3 drawGround(vec2 uv) {\n    return groundTexture(uv);\n}\n\n// Cette fonction dessine un bloc avec des bords arrondis\nvec3 drawBlock(vec2 uv) {\n    // Couleur du bloc\n    vec3 blockColor = vec3(0.5, 0.3, 0.0);\n    // Rayon des coins du bloc\n    float cornerRadius = 0.2;\n    // Épaisseur des bords du bloc\n    float edgeWidth = 0.01;\n\n    // La position relative par rapport au centre du bloc\n    vec2 relPos = uv - vec2(0.5, 0.5);\n    // La distance entre la position relative et le coin du bloc\n    vec2 distToCorner = abs(relPos) - vec2(0.5 - cornerRadius, 0.5 - cornerRadius);\n    // La distance la plus courte entre la position relative et un coin du bloc\n    float shortestDistToCorner = length(max(distToCorner, 0.0));\n    // Un coefficient pour un fondu en douceur des bords arrondis\n    float t = smoothstep(cornerRadius - edgeWidth, cornerRadius, shortestDistToCorner);\n\n    // Mélange la couleur du bloc avec du noir en fonction de `t` pour créer les bords arrondis\n    return mix(blockColor, vec3(0.0), t);\n}\n\n// Fonction pour dessiner Mario\nvec3 drawMario(vec2 uv) {\n    // Couleurs pour les différentes parties de Mario\n    vec3 hatColor = vec3(0.9, 0.2, 0.2);\n    vec3 faceColor = vec3(0.98, 0.8, 0.6);\n    vec3 shirtColor = vec3(0.2, 0.5, 0.9);\n    vec3 pantsColor = vec3(0.0, 0.0, 0.7);\n    vec3 shoesColor = vec3(0.1, 0.1, 0.1);\n    // Régions pour les différentes parties de Mario\n    float hatRegion = 0.6;\n    float faceRegion = 0.4;\n    float shirtRegion = 0.25;\n    float pantsRegion = 0.1;\n    // Détermination de la partie de Mario en utilisant la coordonnée Y de l'UV\n    if (uv.y > hatRegion) {\n        return hatColor;\n    } else if (uv.y > faceRegion) {\n        return faceColor;\n    } else if (uv.y > shirtRegion) {\n        return shirtColor;\n    } else if (uv.y > pantsRegion) {\n        return pantsColor;\n    } else {\n        return shoesColor;\n    }\n}\n\n// Temps depuis la dernière fois que le joueur était sur le bord gauche\nfloat lastTimePlayerOnLeftEdge = -100.0;\n\n// Fonction pour dessiner une pièce\nvec3 drawCoin(vec2 uv, vec3 bgColor) {\n    // Couleur dorée de la pièce\n    vec3 coinColor = vec3(1.0, 0.84, 0.0);\n    // Rayon du cercle représentant la pièce (50% de la largeur/hauteur)\n    float radius = 0.5;\n    // Largeur de l'interpolation entre la pièce et l'arrière-plan\n    float edgeWidth = 0.01;\n    \n    // Distance entre le centre de la pièce et la position de la texture\n    float dist = length(uv - vec2(0.5, 0.5));\n    // Contrôle de l'interpolation entre la pièce et l'arrière-plan\n    float t = smoothstep(radius - edgeWidth, radius, dist);\n\n    // Retourne la couleur de la pièce mélangée avec l'arrière-plan en utilisant l'interpolation\n    return mix(coinColor, bgColor, t);\n}\n\n// Ce code est la fonction principale qui détermine la couleur de chaque pixel à afficher sur l'écran.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy; // Convertit les coordonnées de pixel en coordonnées normalisées\n    vec3 col; // Déclare la variable de couleur\n\n    // Détermine si le fond est le ciel ou le sol en fonction de la position Y de l'UV\n    if (uv.y < 0.2) {\n        col = drawGround(uv); // Dessine le sol\n    } else {\n        col = drawSky(uv); // Dessine le ciel\n    }\n\n    float playerSpeed = 0.5; // La vitesse du joueur\n    float playerPosX = mod(playerSpeed * iTime, 1.); // La position horizontale du joueur est déterminée en fonction du temps\n    float jumpHeight = 0.38; // Hauteur du saut du joueur\n    float jumpDuration = 1.0; // Durée du saut du joueur\n    float playerPosY = 0.1 + jumpHeight * abs(sin(iTime / jumpDuration * 3.14159)); // La position verticale du joueur est déterminée en fonction du temps\n\n    // Définit les dimensions et la forme du joueur\n    float playerWidth = 0.07;\n    float playerHeight = 0.2;\n    float cornerRadius = 0.02;\n    float edgeWidth = 0.01;\n\n    // Vérifie si le joueur n'est pas en dehors de l'écran et si l'UV se trouve dans la région du joueur\n    if (!isPlayerOffScreen && abs(uv.x - playerPosX) < playerWidth / 2.0 && abs(uv.y - playerPosY) < playerHeight / 2.0) {\n        vec2 playerUV = (uv - vec2(playerPosX, playerPosY)) / vec2(playerWidth, playerHeight) + 0.5;\n        col = drawMario(playerUV); // Dessine le joueur\n    }\n\n    // Dessine les blocs\n    float blockSizeX = 0.1; // Largeur d'un bloc\n    float blockSizeY = blockSizeX * iResolution.x / iResolution.y; // Hauteur d'un bloc en fonction de la largeur\n    float blockPosY = 0.65; // Position Y des blocs\n    float horizontalShift = 0.2; // Décalage horizontal des blocs\n    float blockSpacing = 0.15; // Espacement entre les blocs\n    vec3 blockColor = vec3(0.5, 0.3, 0.0); // Couleur des blocs\n    // Boucle qui dessine 4 blocs sur l'écran\n    for (int i = 0; i < 5; i++) {\n        float blockPosX = (blockSizeX + blockSpacing) * float(i) + horizontalShift; // Calcul de la position X du bloc\n        vec2 blockCenter = vec2(blockPosX, blockPosY); // Centre du bloc\n        vec2 relPos = uv - blockCenter; // position relative de l'UV par rapport au centre du bloc\n        vec2 distToCorner = abs(relPos) - vec2(0.5 * blockSizeX - cornerRadius, 0.5 * blockSizeY - cornerRadius); // Distance à l'angle du bloc\n        float shortestDistToCorner = length(max(distToCorner, 0.0)); // Distance la plus courte à l'angle du bloc\n\n        // Vérifie si l'UV se trouve dans la région du bloc\n        float t = smoothstep(cornerRadius - edgeWidth, cornerRadius, shortestDistToCorner);\n        // Mélange la couleur du bloc avec l'arrière-plan en utilisant l'interpolation\n        col = mix(col, blockColor, 1.0 - t);\n    }\n\n    float coinDuration = 3.0; // Durée de l'affichage de la pièce\n    float coinPosY = 0.85; // Position Y de la pièce\n    \n    if (playerPosY > 0.46) {\n        // Affiche une pièce au-dessus de la position du joueur lorsque Mario est au-dessus de 0.45\n        float playerPosX = mod(playerSpeed * iTime, 1.);\n        float coinWidth = 0.08;\n        float coinHeight = coinWidth * iResolution.x / iResolution.y;\n\n        // Trouvez l'index du bloc le plus proche\n        int closestBlockIndex = int(floor((playerPosX - horizontalShift) / (blockSizeX + blockSpacing)));\n\n        // Calculez la position x du bloc le plus proche\n        float closestBlockPosX = (blockSizeX + blockSpacing) * float(closestBlockIndex) + horizontalShift;\n\n        // Calculez la position y du bloc le plus proche\n        float closestBlockPosY = blockPosY;\n\n        // Modifiez la valeur de coinPosY pour correspondre à celle du bloc le plus proche\n        float newCoinPosY = (closestBlockPosY + blockSizeY / 2.0 + coinHeight / 2.0) + 0.05;\n\n        // Modifiez la valeur de coinPosX pour correspondre à celle du bloc le plus proche\n        float newCoinPosX = closestBlockPosX;\n\n        // Vérifie si la position actuelle de l'UV est à l'intérieur des limites de la pièce\n        if (abs(uv.x - newCoinPosX) < coinWidth / 2.0 && abs(uv.y - newCoinPosY) < coinHeight / 2.0) {\n            // Calcule la position relative de l'UV par rapport à la pièce\n            vec2 coinUV = (uv - vec2(newCoinPosX, newCoinPosY)) / vec2(coinWidth, coinHeight) + 0.5;\n            // Dessine la pièce en utilisant la position relative de l'UV\n            col = drawCoin(coinUV, col);\n        }\n    }\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}