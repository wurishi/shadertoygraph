{"ver":"0.1","info":{"id":"ttXSzl","date":"1563979166","viewed":1071,"name":"simple npr experiments","username":"cdyk","description":"Some simple experiments with NPR rendering. Outlines between object id, outlines between shadow-nonshadow, binary gradients and raster gradients.","likes":20,"published":1,"flags":32,"usePreview":0,"tags":["cube","sphere","cylinder","outline","npr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 id00 = texture(iChannel0, (fragCoord+vec2(0,0))/iResolution.xy);\n    vec4 id01 = texture(iChannel0, (fragCoord+vec2(0,1))/iResolution.xy);\n    vec4 id10 = texture(iChannel0, (fragCoord+vec2(1,0))/iResolution.xy);\n    vec4 id11 = texture(iChannel0, (fragCoord+vec2(1,1))/iResolution.xy);\n    \n    bool noLine = \n        int(id00.a) == int(id01.a) &&\n        int(id10.a) == int(id11.a) &&\n        int(id00.a) == int(id10.a) &&\n        0.1 < dot(id00.xyz, id10.xyz) &&\n        0.1 < dot(id10.xyz, id11.xyz);\n\n    \n    \n    vec4 tmp = texture(iChannel0, uv);\n\n    int id = int(tmp.a);\n    float diffuse = fract(tmp.a);\n\n    vec3 baseColor = 0.5*(vec3((id>>2)&1,(id>>1)&1,id & 1)+vec3(1));\n    if(id==0) {\n        diffuse = 1.0;\n        baseColor = vec3(0.5, 0.7, 1.0);\n    }\n  \n    int m = int(0.5*iTime)%6;\n    \n    if(m == 0) {\n        // Regular rendering\n\t    fragColor = vec4(max(0.3, diffuse) * baseColor, 1.0);\n    }\n    else if(m==1) {\n        // Outlines between objects\n\t    fragColor = vec4(noLine ? vec3(0.7) : vec3(0), 1);\n    }\n    else if(m==2) {\n        // Outlines and object basecolor\n\t    fragColor = vec4(noLine ? vec3(0.7) + 0.3*baseColor : vec3(0), 1);\n    }\n    else if (m==3) {\n        // Outlines and object base color binary shaded\n\t    fragColor = vec4(noLine ? vec3(diffuse < 0.2 ? 0.5 : 0.7) + 0.3*baseColor : vec3(0), 1);\n    }\n    else if (m==4) {\n        // Outlines and lines between shadow and non-shadow\n        noLine =\n            noLine &&\n            abs(fract(id00.a)-fract(id10.a)) < 0.1 &&\n            abs(fract(id00.a)-fract(id01.a)) < 0.1 &&\n            abs(fract(id10.a)-fract(id11.a)) < 0.1 &&\n            abs(fract(id01.a)-fract(id11.a)) < 0.1;\n        \n        fragColor = vec4(noLine ? vec3(diffuse < 0.2 ? 0.5 : 0.7) + 0.3*baseColor : vec3(0), 1);\n    }\n    else {\n        // Outlines and raaster shading\n        const float rasterSize = 8.0;\n        float raster = 0.2 + 0.6*length(mod(fragCoord.xy, vec2(rasterSize))/rasterSize-vec2(0.5));\n\t    fragColor = vec4(noLine ? vec3(diffuse < raster ? 0.5 : 0.7) + 0.3*baseColor : vec3(0), 1);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct Ray\n{\n    vec3 o;\n    vec3 d;\n};\n\n    \nfloat intersectSphere(out vec3 normal,\n\t                  in Ray v,\n                      in vec3 o,\n                      in float r2)\n{\n    vec3 g = v.o - o;\n    \n    //<g + t*v.d, g + t*v.d> = r^2\n    //<g,g> - r^2 + 2*t*<g,v.d> + t^2 <v.d,v.d> = 0\n\n    float a = dot(v.d, v.d);\n    float b = 2.0*dot(g, v.d);\n    float c = dot(g, g) - r2;\n    \n    float disc = b*b - 4.0*a*c;\n    if(disc < 0.0) return -1.0;\n    \n    float d = sqrt(disc);\n    float t0 = (-b - d)/(2.0*a);\n    \n    vec3 w = g + t0*v.d;\n    normal = normalize(w);\n\n    return t0;\n}\n   \nfloat intersectCube(out vec3 normal,\n                    in Ray r,\n                    in vec3 o,\n                    in vec3 s)\n{\n    vec3 rcp = 1.0/r.d;\n    vec3 a = rcp*(o - r.o);\n    vec3 ta = a - abs(rcp)*s;\n    vec3 tb = a + abs(rcp)*s;\n\n\n\n    normal = vec3(0,1,1);\n    \n    float tn = max(max(ta.x, ta.y), ta.z);\n    float tf = min(min(tb.x, tb.y), tb.z);\n    if( tf < max(0.001, tn)) {\n        return -1.0;\n    }\n    \n    // find channel that is less than the two other channels.\n    // flip sign to choose correct face.\n    vec3 lessThan1 = step(ta.yzx, ta.xyz);\n    vec3 lessThan2 = step(ta.zxy, ta.xyz);\n    normal = -sign(r.d)*lessThan1*lessThan2;\n   \n    return tn;\n}\n\nfloat intersectCylinder(out vec3 normal,\n                        in Ray r,\n                        in vec3 o,\n                        float hl,\n                        float r2)\n{\n    vec2 g = r.o.xy - o.xy;\n    \n    //<g + t*v.d, g + t*v.d> = r^2\n    //<g,g> - r^2 + 2*t*<g,v.d> + t^2 <v.d,v.d> = 0\n\n    float a = dot(r.d.xy, r.d.xy);\n    float b = 2.0*dot(g.xy, r.d.xy);\n    float c = dot(g.xy, g.xy) - r2;\n    \n    float disc = b*b - 4.0*a*c;\n    if(disc < 0.0) return -1.0;\n\n    \n    float d = sqrt(disc);\n    float t0 = (-b - d)/(2.0*a);\n    float t1 = (-b + d)/(2.0*a);\n\n    float rcp = 1.0/r.d.z;\n    float aa = rcp*(o - r.o).z;\n    float ta = aa - abs(rcp)*hl;\n    float tb = aa + abs(rcp)*hl;\n\n    // cylinder is between near and far cap\n    if(ta <= t0 && t0 <= tb) {\n        vec2 w = g + t0*r.d.xy;\n\t    normal = normalize(vec3(w,0));\n        return t0;\n    }\n            \n    // near cap is inside infinite cylinder\n    if(t0 < ta && ta < t1) {\n     \tnormal = vec3(0,0,-sign(r.d.z));\n        return ta;\n    }\n\n    return -1.0;\n}\n\nfloat intersectPlane(out vec3 normal,\n                     in Ray r,\n                     in vec3 n,\n                     float d)\n{\n    normal = n;\n    return -(d - dot(r.o, n))/dot(r.d, n);\n}\n\n\nfloat castRay(out vec3 n, out int id, in Ray r)\n{\n    id = 0;\n    float t = 1e37;\n    for(int k=0; k<3; k++) {\n        for(int j=0; j<3; j++) {\n            for(int i=0; i<3; i++) {\n                vec3 nn;\n                float tt;\n\n                int kk = i+j+k;\n                \n                vec3 o = vec3(i-1, j-1, k-1);\n                \n                if((kk % 3)==0) {\n\t                tt = intersectSphere(nn, r, o, 0.45*0.45);\n                }\n                else if((kk %3)==1) {\n                    tt = intersectCylinder(nn, r, o, 0.45, 0.45*0.45);\n                }\n                else {\n\t                tt = intersectCube(nn, r, o, vec3(0.45));\n                }\n                 if(0.0 < tt && tt < t) {\n                    t = tt;\n                    n = nn;\n                    id = 3*(3*k+j) + i + 2; \n                }\n            }\n        }\n    }\n \n    {\n        vec3 nn;\n        float tt = intersectPlane(nn, r, vec3(0,1,0), 2.0);\n        if(0.0 < tt && tt < t) {\n            t = tt;\n            n = nn;\n            id = 1;\n        }\n    }\n    \n    return t < 1e37 ? t : -1.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float ww = 0.3;\n    float c0 = cos(ww*iTime);\n    float s0 = sin(ww*iTime);\n    float c1 = cos(ww*iTime+0.6);\n    float s1 = sin(ww*iTime+0.6);\n    \n    float w = 2.0/max(iResolution.x, iResolution.y);\n    vec3 q = vec3(w*(fragCoord.xy - 0.5*iResolution.xy), -1.0);\n    \n    Ray r;\n\n    r.d.x = c0*q.x - s0*q.z;\n    r.d.y = q.y+0.0000001;\t// Quick-fix for rcp is nan in box.\n    r.d.z = s0*q.x + c0*q.z;\n    r.d = normalize(r.d);\n\n    r.o = 5.0*vec3(-s0,0,c0);\n   \n    int id;\n\tvec3 n;\n    float t = castRay(n, id, r);\n\n    if(0.0 < t) {\n        vec3 lp = 7.0*vec3(-s1, 0.75, c1);\n        \n        Ray s;\n        s.o = r.o + t*r.d;\n        s.d = normalize(lp-s.o);\n        //s.o += 0.01*s.d;\n        \n        vec3 foo;\n        int bar;\n        float tt = castRay(foo, bar, s);\n        bool inShadow = 0.0 < tt;\n        \n        float diffuse = inShadow ? 0.0 : dot(s.d, n);\n        \n    \tfragColor = vec4(n, float(id) + fract(max(0.0, diffuse)));\n    }\n    else {\n\t    fragColor = vec4(0,0,1,0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}