{"ver":"0.1","info":{"id":"4lycWw","date":"1536407446","viewed":204,"name":"Simple Ray March With Shadow","username":"Bridgy","description":"Simple ray marching with solid shading (no penumbra). Used the distance functions from iquilezles.org","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","shading"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int RAY_STEPS = 128;\nconst float MAX_DIST = 10000.0;\nconst float MIN_HIT_DIST = 0.001;\n\nvec3 color = vec3(0.2, 0.5, 0.8);\nvec3 specMat = vec3(1.0, 1.0, 1.0);\nint object = 0;\n\nvec3 rotateX(vec3 pos, float angle)\n{\n    vec4 p = vec4(pos, 0.0);\n    \n    mat4 rotX = mat4(\n        1.0, \t\t0.0,        0.0,0.0,\n        0.0, cos(angle), sin(angle),0.0,\n        0.0,-sin(angle), cos(angle),0.0,\n        0.0,\t\t0.0, \t\t0.0,1.0\n    );\n    \n    p *= rotX;\n    \n    return p.xyz;\n}\n\nvec3 rotateY(vec3 pos, float angle)\n{\n    vec4 p = vec4(pos, 0.0);\n    \n    mat4 rotY = mat4(\n        \tcos(angle), 0.0, -sin(angle), \t0.0,\n        \t0.0, \t\t1.0, 0.0, \t\t\t0.0,\n        \tsin(angle), 0.0, cos(angle), \t0.0,\n        \t0.0,\t\t0.0, 0.0,\t\t\t1.0\n    );\n    \n    p *= rotY;\n    \n    return p.xyz;\n}\n\nvec3 rotateZ(vec3 pos, float angle)\n{\n    vec4 p = vec4(pos, 0.0);\n    \n    mat4 rotZ = mat4(\n        cos(angle), sin(angle), 0.0, \t0.0,\n        -sin(angle),cos(angle), 0.0, \t0.0,\n        0.0,  \t\t0.0, \t\t1.0, \t0.0,\n        0.0,\t\t0.0, \t\t0.0,\t1.0\n    );\n    \n    p *= rotZ;\n    \n    return p.xyz;\n}\n\nfloat distFromSphere(vec3 pos, vec3 center, float radius)\n{\n    pos = rotateY(pos, iTime);\n    \n\treturn length(pos - center) - radius;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h, vec3 c)\n{   \n    p = rotateZ(p, iTime);\n    p= rotateY(p, iTime);\n    \n\tvec3 q = abs(p - c);\n    \n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h, vec3 c)\n{\n    p= rotateY(p, iTime);\n    \n    vec3 q = abs(p - c);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\t\t\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat mapTheWorld(vec3 pos)\n{   \n    float hitObj = sdHexPrism(pos, vec2(1.5, 0.8), vec3(0.0, 0.0, 0.0));\n\tif(hitObj < MIN_HIT_DIST)\n    {\n        object = 0;\n    \treturn hitObj;\n    }\n    \n    hitObj = min(hitObj,distFromSphere(pos, vec3(7.0, 0.0, 0.0), 2.0));\n    if(hitObj < MIN_HIT_DIST)\n    {\n        object = 1;\n    \treturn hitObj;\n    }\n    \n    hitObj = min(hitObj,sdTriPrism(pos, vec2(2.0, 1.0), vec3(-7.0, 0.0, 0.0)));\n    if(hitObj < MIN_HIT_DIST)\n    {\n      \tobject = 2;\n    \treturn hitObj;\n    }\n    \n    hitObj = min(hitObj,udQuad(pos,vec3(-100.0,-3.5,-100.0),vec3(-100.0,-3.5,100.0),vec3(100.0,-3.5,100.0),vec3(100.0,-3.5,-100.0)));\n\tif(hitObj < MIN_HIT_DIST)\n    {\n        object = 3;\n    \treturn hitObj;\n    }\n    \n    return hitObj;\n}\n\nvec3 calculate_normal(in vec3 p)\n{\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n\n    float gradient_x = mapTheWorld(p + small_step.xyy) - mapTheWorld(p - small_step.xyy);\n    float gradient_y = mapTheWorld(p + small_step.yxy) - mapTheWorld(p - small_step.yxy);\n    float gradient_z = mapTheWorld(p + small_step.yyx) - mapTheWorld(p - small_step.yyx);\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n    return normalize(normal);\n}\n\nbool inShade(vec3 lightPos, vec3 pos)\n{\n\tvec3 toLight = lightPos - pos;\n    float distanceToLight = length(toLight);\n    float distTravelled = 0.01;\n    toLight = normalize(toLight);\n    \n    for(int i = 0; i < RAY_STEPS; i++)\n    {\n        vec3 currentPos = pos + distTravelled * toLight;\n        \n        float distToClosest = mapTheWorld(currentPos);\n        \n        if(distToClosest < MIN_HIT_DIST)\n        {\n            return true;\n        }\n        \n        if(distTravelled > distanceToLight)\n        {\n        \tbreak;\n        }\n        \n        distTravelled += distToClosest;\n    }\n    \n    return false;\n}\n\nvoid setColor()\n{\n\n    if(object == 0){ color = vec3(1.0,0.0,0.0); }\n    else if(object == 1){ color = vec3(1.0,0.0,1.0); }\n    else if(object == 2){ color = vec3(0.0,0.0,1.0); }\n    else if(object == 3)\n    { \n        color = vec3(0.5,1.0,0.0);\n        specMat = vec3(0.0, 0.0, 0.0);\n    }\n}\n\nvec3 rayMarch(vec3 rayOrigin, vec3 direction)\n{    \n    float distTravelled = 0.0;\n    \n    for(int i = 0; i < RAY_STEPS; i++)\n    {\n    \tvec3 currentPos = rayOrigin + distTravelled * direction;\n        \n        float distToClosest = mapTheWorld(currentPos);\n        \n        if(distToClosest < MIN_HIT_DIST)\n        {\n\t\t\tvec3 norm = calculate_normal(currentPos);\n            vec3 lightPos = vec3(10.0, 10.0, -10.0);\n            \n            vec3 lightDirection = normalize(lightPos - currentPos);\n            \n            //calculate shadow\n            if(inShade(lightPos, currentPos))\n            {\n                return color * 0.05;\n            }\n            else\n            {\n                setColor();\n                \n                float diffuseIntensity = max(dot(norm, lightDirection), 0.0); \n                vec3 diffuseColor = color * diffuseIntensity;\n\n                //specular\n                vec3 toEye = normalize(currentPos - rayOrigin); \n                vec3 reflectLight = normalize(reflect(lightDirection, norm));\n                float specPower = 70.0;\n\n                vec3 specColor = specMat * pow(max(dot(toEye, reflectLight), 0.0), specPower);\n\n                return diffuseColor + specColor;\n            }\n        }\n        \n        if(distTravelled > MAX_DIST)\n        {\n        \tbreak;\n        }\n        \n        distTravelled += distToClosest;\n    }\n    \n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 CAMERA_POS = vec3(0.0, 6.0, -10.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //Convert to -1 to 1 range\n    uv = uv * 2.0 - 1.0;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 rayDirection = normalize(vec3(uv, 1.0));\n    rayDirection = rotateX(rayDirection, 3.141 * -0.2);\n   \t\n    vec3 col = rayMarch(CAMERA_POS, rayDirection);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}