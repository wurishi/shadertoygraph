{"ver":"0.1","info":{"id":"XcdSRH","date":"1713572509","viewed":69,"name":"Spewcumber","username":"FatLenny","description":"@kishimisu youtube tutorial for raymarching","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","tutorial","canvas"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Beating Membrane\" by FatLenny. https://shadertoy.com/view/4ftSRH\n// 2024-04-20 00:20:04\n\n// Fork of \"Raymarching Starter Testing\" by FatLenny. https://shadertoy.com/view/lfdSzr\n// 2024-04-20 00:17:32\n\n// Fork of \"Raymarching Starter Template\" by FatLenny. https://shadertoy.com/view/XfcXzn\n// 2024-04-19 11:30:50\n\nvec3 hash( vec3 p )      // this hash is not production ready, please\n{                        // replace this by something better\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n  \nvec4 noised( in vec3 x )\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    \n    // gradients\n    vec3 ga = hash( p+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( p+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( p+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( p+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( p+vec3(0.0,0.0,1.0) );\n    vec3 gf = hash( p+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( p+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( p+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolation\n    float v = va + \n              u.x*(vb-va) + \n              u.y*(vc-va) + \n              u.z*(ve-va) + \n              u.x*u.y*(va-vb-vc+vd) + \n              u.y*u.z*(va-vc-ve+vg) + \n              u.z*u.x*(va-vb-ve+vf) + \n              u.x*u.y*u.z*(-va+vb+vc-vd+ve-vf-vg+vh);\n              \n    vec3 d = ga + \n             u.x*(gb-ga) + \n             u.y*(gc-ga) + \n             u.z*(ge-ga) + \n             u.x*u.y*(ga-gb-gc+gd) + \n             u.y*u.z*(ga-gc-ge+gg) + \n             u.z*u.x*(ga-gb-ge+gf) + \n             u.x*u.y*u.z*(-ga+gb+gc-gd+ge-gf-gg+gh) +   \n             \n             du * (vec3(vb-va,vc-va,ve-va) + \n                   u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + \n                   u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + \n                   u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) );\n                   \n    return vec4( v, d );                   \n}\n\nfloat sdSphere(vec3 p, float s) {\n       \n    //distance to a sphere of radius 1.0 located at the origin\n    return length(p) - s;  \n    \n}\n\nfloat sdCube( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat sdCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nmat2 rot2d(float angle){\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nvec3 rot3d(vec3 p, vec3 axis, float angle)\n{\n    return mix(dot(axis, p) * axis, p, cos(angle))\n               + cross(axis, p) *sin(angle);\n}\n\n// SMOOTH COMBINING OF SHAPES WHERE K IS SMOOTHIG FACTOR\nfloat smin( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat ssub( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat sint( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{    \n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat map(vec3 p) {\n    vec2 mp = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;// Normalize mouse position to fit canvas\n    \n    vec3 pNoise = p;\n    vec4 fullNoise = noised(pNoise+iTime*0.5);     \n    \n    \n    //BENDING\n    const float k = 0.1; // or some other amount\n    float c = -cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    \n    vec3 uv = p;\n    uv.xz*= 0.4;\n    //uv.y-=1.0;\n    uv.xz = mod(uv.xz, 1.0) - 0.5;\n    vec3 suv = q;\n    suv.y += 0.7 * fullNoise.z*0.3;\n    vec3 tuv = suv;\n    //tuv.y -= 5.1;\n    tuv.x += iTime*1.;\n    suv.x += iTime*1.;\n    suv.y += iTime*5.0;\n    //tuv.xz += iTime;\n    //tuv.y += 1.0;\n    suv.xz = mod(suv.xz, 1.0) - 0.5;\n    suv.y = mod(suv.y, 1.0)-0.5;\n    //tuv.xyz = mod(tuv.xyz, 1.0) - 0.5;// wild\n    tuv.xz = mod(tuv.xz, 1.0) - 0.5;\n    tuv.xz*= 0.4;\n    \n    \n    float delta = iTime;\n    float scale = 0.02;// Scaling factor\n    \n    //float sphere = sdSphere(suv , scale); \n            \n    float cap = sdCapsule(suv , 0.1, scale);\n    float smoothtorus = sdTorus(tuv , vec2(0.21, 0.13));\n    float torus = sdTorus(tuv , vec2(0.25, 0.5));\n\n    //uv.z = mod(es.y, 13.0) - 6.5;\n    \n    //uv.z = fract(cs.xz) - 0.5;\n    \n    //uv.yz *= rot2d(delta);// Rotate around x axis\n    //uv.xz *= rot2d(delta);// Rotate around y axis\n    //uv.xy *= rot2d(delta);// Rotate around z axis\n      \n    // Order of operations for transformations is important because you will get a \n    // different outcome depending on the order they are applied in\n       \n    //float tground = sdTorus(uv , vec2(0.0, 1.6));// The ground is wherever is directly under the ray, ot its y position plus an offset    \n    float ground = p.y + 4.5;\n    \n    \n    float shapes;\n    \n    shapes = smin(ground, cap, 0.0);\n    //shapes = smin(cap, ground, 0.5);// Combining all of our shapes and the ground with smoothing \n    shapes = smin(shapes, torus, 1.);// Combining all of our shapes and the ground with smoothing\n    //shapes = min(shapes, torus);\n  \n    return shapes;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    float fov = 1.5;\n    \n    // INITIALIZATION FOR RAYMARCHING\n\n    // fragCoord holds coords of every pixel\n    vec2 uv =(fragCoord *2.0 - iResolution.xy) / iResolution.y; \n    \n    vec3 uvNoise = vec3(uv,0.0);\n    vec4 fullNoise = noised(uvNoise+iTime*0.005+iTime*0.05);\n    uvNoise = fullNoise.yzw;\n    \n    // Normalize mouse position to fit canvas\n    vec2 mp = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 mp2 = (iMouse.zw * 2.0 - iResolution.xy) / iResolution.y;\n    \n    // corresponds to the camera's curent position in our world\n    vec3 ro = vec3(0, 0, -3);// Ray origin \n  \n    // we can use UV as x and y coords because we decided to alignd the world x and y axis with our UV coords\n    // this allows each pizel to have a unique direction spreading out from the center of our screen\n    // this effectively creates a virtual canvas to project the world to\n    // now we normalize the vectors to ensure they all have a length of 1.0 which is crucial for distance calcs    \n    // step 2:\n    vec3 rd = normalize(vec3(uv * fov, 1)); // Ray direction\n\n    // this represents the final pixel color once we have completed the raymarch\n    vec3 col = vec3(0.0);   \n    \n    //create a float to keep track of the current distance the point has traveled from rayOrigin \n    float dt = 0.0;// Distance traveled\n    \n    // CAMERA ROTATION\n    \n    // Vertical rotation\n    //ro.yz *= rot2d(+0.4);\n    //rd.yz *= rot2d(+0.4);\n    ro.yz *= rot2d(1.1+sin(iTime*0.5)*0.1);\n    rd.yz *= rot2d(1.1+sin(iTime*0.5)*0.1);\n    \n    \n    // Horizontal rotation\n    //ro.xz *= rot2d(-mp.x*2.0);\n    //rd.xz *= rot2d(-mp.x*2.0);\n    ro.xz *= rot2d(0.75+iTime*0.1);\n    rd.xz *= rot2d(0.75+iTime*0.1);\n    \n    // END OF INITIALIZATION\n\n    // BEGIN RAYMARCHING\n    \n    // i represents the current raymarching step with a max of 80 iterations\n    // the max iterations affects the QUALITY of the result and the PERFORMANCE\n    // too few steps may not allow the ray to reach an object, while too many will impast shader performance\n    // this parameter needs to be adjusted to fit your specific scene\n    int i;\n    vec3 p;\n    for(i = 0; i < 80; i++)\n    {\n    \n        // create a vec3 that indicates the position along the ray based on its distance from the origin\n        // we use this point to compute the distance to the closest object in the scene\n        // the point starts at the ray's origin because distTraveled is initialized to 0.0\n        // we do this using signed distance functions (SDF)\n        // info on SDF related to raymarching: https://iquilezles.org/articles/distfunctions/\n        p = ro + rd * dt;// Position along ray\n        //p.xy *= cos(dt-iTime*0.0001)*0.09;\n        // use mapDistance function to get the distance to the scene given our current position along the ray\n        // this value represents the distance the point can travel in any direction until encountering an object\n        float ds = map(p); // Distance to scene\n\n        // here we are \"marching\" the ray forward based on the distance we got from getDistance()\n        // in other words we are calculating the distance to the closest object in the scene\n        // we then use this distance to \"safely\" march the ray forward, knowing we will not hit an object at that distance\n        // now we repeat the for loop until we either hit an object or exceed the max marching steps we set \n        dt += ds;\n        \n        // This stops the raymarching when the distance to the object is so small that we nonnot need to do 80 iterations\n        // withouy this the max number of iterations would be performed every time and could greatly reduce performance \n        // if the threshold is set too high, you will lose deatil\n        // if too low the performance gains will be negligible\n        //finalColor = vec3(i) / 80.0;\n        if (ds < 0.001) break;\n        \n        // stops loop early if the ray has travaeled too far by putting a cap on the distance it is allowed to travel\n        if (dt > 100.0) break;\n        \n        // we can combine the previous 2 checks into one line: if(distanceToScene < 0.001 || distTraveled > 100.0) break;\n        \n    }\n    \n    //COLORING\n    \n    // this outputs a greyscale image based on distance from the origin\n    // by default this will display any value greater than 1 as pure white, so we need to fix that\n    // we can either move the camera closer to the objects or divide distTraveled by an arbitrary number until we can see things\n    // here I am using the divide by an arbitrary number method\n    \n    // Gradients\n    vec3 newgradient = palette(\n        dt * 0.006 + float(i)*0.005,\n        vec3(0.0, 0.0, 0.0),\n        vec3(0.0, 0.0, 0.0),\n        vec3(0.0, 0.0, 0.0),\n        vec3(0.0, 0.0, 0.0));\n        \n    vec3 testgradient = palette(\n        dt * 0.006 + float(i)*0.005,\n        vec3(0.500, 0.500, 0.500),\n        vec3(-0.542, 0.500, 0.500),\n        vec3(1.000, 1.000, 1.000),\n        vec3(-0.543, -0.210, 0.123));\n   \n    vec3 skybluetowhite = palette(\n        dt * 0.006 + float(i)*0.005,\n        vec3(0.640, 0.540, 0.660),\n        vec3(3.138, 0.718, 0.938),\n        vec3(0.041, 0.158, 0.130),\n        vec3(-1.262, -0.182, -0.182));\n    \n    vec3 bluewhitered = palette(\n        dt * 0.0088 + float(i)*0.009,\n        vec3(0.660, 0.560, 0.680),\n        vec3(0.718, 0.438, 0.720),\n        vec3(0.520, 0.800, 0.520),\n        vec3(-0.430, -0.397, -0.083));\n    \n    vec3 celbluewhitered = palette(\n        dt * 0.0088 + float(i)*0.009,\n        vec3(0.660, 0.560, 0.680),\n        vec3(0.718, 0.438, 0.720),\n        vec3(0.520, 0.800, 0.520),\n        vec3(-0.430, -0.397, -0.083));\n    \n    vec3 smoothrainbow = palette(\n        dt * 0.0088 + float(i)*0.007,\n        vec3(0.500, 0.500, 0.500),\n        vec3(0.500, 0.500, 0.500),\n        vec3(1.000, 1.000, 1.000),\n        vec3(0.000, 0.333, 0.667)+iTime*0.05);\n        \n    vec3 celrainbow = palette(\n        dt * 0.0088 + float(i)*0.007,\n        vec3(0.500, 0.500, 0.500),\n        vec3(0.500, 0.500, 0.500),\n        vec3(1.000, 1.000, 1.000)-iTime*0.005,\n        vec3(0.000, 0.333, 0.667)-sin(iTime*0.05));    \n        \n    vec3 pastelyellowpurplemagenta = palette(\n        dt * 0.006 + float(i)*0.005,\n        vec3(0.881, 1.248, 0.342),\n        vec3(0.286, 0.872, 0.526),\n        vec3(0.872, 0.292, 0.266),\n        vec3(1.953, 3.253, 1.825));\n        \n    vec3 bluehole = palette(\n        dt * 0.004 + float(i)*0.006,\n        vec3(0.918, 0.722, 0.686),\n        vec3(1.028, 0.718, 0.048),\n        vec3(0.918, 1.278, 0.648),\n        vec3(2.068, 2.908, 4.177));\n        \n    vec3 radioactivepeach = palette(\n        dt * 0.006 + float(i)*0.003,\n        vec3(0.500, 0.500, 0.500),\n        vec3(-0.542, 0.500, 0.500),\n        vec3(1.000, 1.000, 1.000),\n        vec3(-0.543, -0.210, 0.123+iTime*0.05));    \n                  \n    //(0.660, 0.560, 0.680), \n    //(0.718, 0.438, 0.720), \n    //(0.872 0.292 0.266), \n    //(-0.430, -0.397, -0.083));\n    \n    vec3 a = vec3(0.660, 0.560, 0.680);\n    vec3 b = vec3(0.718, 0.438, 0.720);\n    vec3 c = vec3(0.520, 0.800, 0.520);\n    vec3 d = vec3(-0.430, -0.397, -0.083);\n    \n    //vec3 a = vec3(0.660, 0.560, 0.680);\n    //vec3 b = vec3(0.718, 0.438, 0.720);\n    //vec3 c = vec3(0.520, 0.800, 0.520);\n    //vec3 d = vec3(-0.430, -0.397, -0.083);\n    \n    if (dt > 80.0) {\n        // Didn't hit anything\n        // col = palette(dt * 0.006 + float(i)*0.005);\n        fragColor = vec4(0.0, 0.0, 0.0, 1);\n\t\treturn;\n    }\n    if (p.y > -4.49) {\n        // Didn't hit anything\n        // col = palette(dt * 0.006 + float(i)*0.005);\n        fragColor = vec4(radioactivepeach, 1);\n\t\treturn;\n    }\n    else{fragColor = vec4(radioactivepeach*cos(radioactivepeach), 1);}\n    \n    //col = dt * vec3(0.604,0.620,0.788)* 0.01 + float(i)*0.005;\n    //col = palette(dt * 0.006 + float(i)*0.005);\n     \n    // fragColor holds RGB and alpha values of a pixel\n    // we use finalColor as the output of our shader instead of displaying the UV coords like it normally would\n    ///fragColor = vec4(bluehole, 1);\n\n}","name":"Image","description":"","type":"image"}]}