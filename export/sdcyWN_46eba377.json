{"ver":"0.1","info":{"id":"sdcyWN","date":"1653456293","viewed":620,"name":"Mars [453 chars]","username":"Xor","description":"Even more experiments with depth of field","likes":37,"published":1,"flags":32,"usePreview":1,"tags":["golf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    \"Mars [453 chars]\" by @XorDev\n    Tweet: twitter.com/XorDev/status/1529323740026261505\n    Twigl: t.co/Co5lc2OKDP\n    \n    Also see \"Ocean\": shadertoy.com/view/7stcWn\n\n    Bokeh pass:\n    Based on: shadertoy.com/view/fljyWd\n    \n    <512 Chars playlist: shadertoy.com/playlist/N3SyzR\n*/\nvoid mainImage(out vec4 O, vec2 I)\n{\n    //Resolution, center coordinates (COMMON) and variable for iteration\n    R .yy/9e2, i=r/r;\n    //Iterate with \"i\" approximating the sqrt of the number of iterations.\n    for(vec4 S; i.x<16.; i+=1./i)\n        //Rotate sample point with golden angle\n        u *= mat2(0,.061,1.413, 0)-.737,\n        //Sample texture\n        S = T,I/r+u*i/r),\n        //Add sample to total (weighted towards brightness)\n        O += S*(S*S).r;\n    \n    //Compute average\n    O /= O.a;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n    Mars render pass:\n    \n    Some logarthmic texturing\n    Using derivatives for lighting\n*/\n#define S(p) T,vec2(log(length(p))-t,sin(atan(p.y,p.x)+s-t*.2)/.6)*s).r/s\n\nvoid mainImage(out vec4 O, vec2 I)\n{\n    //Define resolution, centered coordinates (COMMON) and perspective\n    R ,p=u/(2.-u/r).y;\n    //Scale, iteration, length and time\n    float s=.1,i=1.,t=iTime;\n    //Iterate through scales\n    for(; s<6.4; s+=s)\n        //Sample texture for heightmap (using log/polar coordinates)\n        //Derivative for lighting\n        O += S(p) - S((vec2(0,1)+p));\n    \n    //Generate coloring from lighting\n    O = clamp(O/8e1*length(p)+vec4(.4,.1,0,9),0.,1.);\n}\n\n//Original version (206 chars):\n/*\nvoid mainImage(out vec4 O, vec2 I)\n{\n    //Define resolution, centered coordinates (COMMON) and perspective\n    R ,p=u/(2.-u/r).y;\n    //Scale, iteration, length and time\n    float s=1.,i=s,l=length(p),t=iTime;\n    //Iterate through scales\n    for(; s<64.; s+=s)\n        //Sample texture for heightmap (using log/polar coordinates)\n        O += T,vec2(log(l)-t,sin(atan(p.y,p.x)+s-t*.2)/.6)*s*.1).r/s;\n    \n    //Compute lighting and color from derivative\n    O = clamp(dFdy(O)*.1*l+vec4(.4,.1,0,9),0.,1.);\n}\n*/","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//Define reslution and centered coordinates\n#define R O-=O; vec2 r=iResolution.xy, u=(I+I-r)\n//Texture function used in both shaders\n#define T texture(iChannel0","name":"Common","description":"","type":"common"}]}