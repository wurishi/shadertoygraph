{"ver":"0.1","info":{"id":"cssyRB","date":"1686926743","viewed":67,"name":"OEIS Dice a(6)","username":"mdonahoe","description":"testing a(6) for A363609\nhttps://oeis.org/A363609","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf","dice","die","oeis"],"hasliked":0,"parentid":"csySDG","parentname":"Simple & Cheap Die SDF"},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Adapted from\n// \"Simple & Cheap Die SDF\"\n// by fizzer\n// https://www.shadertoy.com/view/csySDG\n\n// Distance to hemisphere-shaped hole in a plane.\nfloat hole(vec3 p, float r)\n{\n    float c = min(0., length(p.xz) - r);\n    return (p.y > 0.) ? length(vec2(c, p.y)) : r - length(p);\n}\n\n// the body of the die\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\nbool includePips = true;\n// Die SDF.\nfloat die(vec3 p)\n{\n    if (!includePips) {\n        // hack for coloring\n        return sdRoundBox(p, vec3(.38), .1);\n    }\n    \n    // Get index of closest face on die, and local point b.\n    vec3 q = abs(p);\n\n    bvec3 dots = sign(p.z) > 0. ? bvec3(false, true, true) : bvec3(true, true, false);\n    vec3 b = p.xzy * sign(p.z);\n\n    if(q.x > q.y && q.x > q.z)\n    {\n        b = p.zxy * sign(p.x);\n        b.z = -b.z;\n        dots = sign(p.x) > 0. ? bvec3(false, true, false) : bvec3(true, true, true);\n    }\n    else if(q.y > q.z)\n    {\n        b = p.zyx * sign(p.y);\n        dots = sign(p.y) > 0. ? bvec3(false, false, true) : bvec3(false, false, false);\n    }\n    \n    // Some parameteric constants.\n    float r = .02, r2 = .04 ,r3 = .13;\n\n    b.y -= .5 - r;\n    \n    float d;\n\n    if(all(not(dots)))\n    {\n        // Special case for side 6.\n        b.x = abs(b.x);\n        b.z = mod(b.z + .3 / 2., .3) - .3 / 2.;\n        d = hole(b - vec3(.2, 0, 0), r3);\n    }\n    else\n    {\n        // The sides other than 6 have reflective symmetry in two lines.\n        if(b.x > -b.z)\n            b.xz = -b.zx;\n\n        if(b.x > b.z)\n            b.xz = b.zx;\n\n        // Thanks to this symmetry, the presence of only three dots account\n        // for all of the sides. So the effective LUT contains 3 bits per face.\n        if(b.z - b.x > .25)\n            d = dots.y ? hole(b - vec3(-1, 0, +1) / 4., r3) : b.y;\n        else if(-b.x - b.z > .25)\n            d = dots.x ? hole(b - vec3(-1, 0, -1) / 4., r3) : b.y;\n        else\n            d = dots.z ? hole(b, r3): b.y;\n    }\n    \n    // Use sdRoundBox to bevel the outer edges of the die.\n    return max(d - r, sdRoundBox(p, vec3(.5) - r2, r2));\n}\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\nfloat dist(vec3 p)\n{\n    //if (p.x < -2.0) {\n    //    return 0.0;\n    //}\n\n    // helper rotations\n    float halfpi = 3.14159 / 2.0;\n    mat3 none = identity();\n    vec3 zero = vec3(0.);\n    mat3 rx90 = rotateX(halfpi);\n    mat3 rx270 = rotateX(3.0*halfpi);\n    mat3 ry90 = rotateY(halfpi);\n    mat3 ry270 = rotateY(3.*halfpi);\n    mat3 rz90 = rotateZ(halfpi);\n    \n    // offset between dice\n    float s = 1.1;\n    \n    // 6 dice arranged to hide their biggest numbers\n    return min(die(rx90 * p + zero),\n           min(die(ry90 * rx270 * (p + vec3(0,0,s))),\n           min(die(rx270*ry90*ry90 * (p + vec3(s,0,0))),\n           min(die(rx90*ry90*ry90 * (p + vec3(s,0,s))),\n           min(die(ry90 * (p + vec3(0,-s,s))),\n               die(ry270 * (p + vec3(0,-s,0)))\n              )))));\n}\n\nvec3 norm(vec3 p)\n{\n    // The usual.\n    vec3 e = vec3(1e-4, 0, 0);\n    float d = dist(p);\n    return normalize(vec3(dist(p + e.xyy), dist(p + e.yxy), dist(p + e.yyx)) - d);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\n    // Camera position and target.\n    vec3 campos = vec3(cos(iTime) * 2., sin(iTime / 2.) * 2., sin(iTime) * 2.);\n    \n    if(iMouse.z > 0.)\n    {\n        float u = -iMouse.x / iResolution.x * 6.;\n        float v = -(iMouse.y - iResolution.y / 2.) / iResolution.y * 3.;\n        campos = vec3(cos(u) * 2., v, sin(u) * 2.);\n    }\n    \n    campos = normalize(campos) * 5.0;\n    vec3 camtarget = vec3(0);\n\tvec3 ro = campos, rd = normalize(vec3(uv, 1.));\n    \n    // Camera lookat.\n    vec3 w = normalize(camtarget - campos);\n    vec3 u = normalize(cross(vec3(0, 1, 0), w));\n    vec3 v = cross(w, u);\n    rd = mat3(u, v, w) * rd;\n    \n    float t = 0.;\n    for(int i = 0; i < 100; ++i)\n    {\n        float d = dist(ro + rd * t);\n        if(abs(d) < 1e-4 || t > 10.)\n            break;\n        t += d;\n    }\n\n    vec3 rp = ro + rd * t;\n    vec3 col = vec3(.12);\n        \n    if(t < 10.)\n    {\n        // Typical lighting and shading.\n        vec3 l = normalize(vec3(1, 2, 1.5));\n        vec3 n = norm(rp);\n        // adjust global so we can paint the cube white and leave the pips black.\n        includePips = false;\n        float foo = dist(rp);\n        vec3 baseColour = mix(vec3(0), vec3(1), smoothstep(.01, .02, foo));\n        vec3 rr = reflect(rd, n);\n        vec3 spec = textureLod(iChannel0, rr, 1.).rgb;\n        vec3 diff = vec3(0.5 + 0.5 * dot(n, l)) + vec3(0.5 + 0.5 * -n.y) * vec3(.1, .1, .2) * 1.5;\n        float fresnel = mix(0.01, .4, pow(clamp(1. + dot(rd, n), 0., 1.), 2.));\n\n        col = mix(baseColour * diff, spec, fresnel);\n    }\n\n    // Output and gamma correction.\n    fragColor = vec4(pow(col, vec3(1. / 2.2)), 1.);\n}","name":"Image","description":"","type":"image"}]}