{"ver":"0.1","info":{"id":"3sVGDR","date":"1571406982","viewed":450,"name":"Bloomin' Partition","username":"104","description":"2d partitioning in layers","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["2d","partition"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define POINTS 9.\n#define PARTITIONS 7.\n\nconst float PI2 = 6.28;\n\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvoid mainImage( out vec4 o, vec2 C)\n{\n    vec2 R = iResolution.xy;\n    vec2 N = C/R-.5;\n    vec2 uv = N;\n    uv.x *= R.x/R.y;\n    float t = iTime  *.5;\n    uv *= 1.7;\n\n    vec4 nearestPt = vec4(1e4);//xy=pt, z = seed, w=dist\n    vec4 nearestPt2;// second-nearest point. xy=pt, z = seed, w=dist\n\to = vec4(1.);\n    float ipartition = 0.;\n    for (; ipartition < PARTITIONS; ++ ipartition) {\n        vec4 hpart = hash41(1e2+ipartition);\n        for (float i = 0.; i < POINTS; ++ i) {\n            vec4 h = hash41((i+1.)*PARTITIONS+(ipartition+1.));\n            vec4 pt = vec4(\n                sin((h.x)*PI2+t*h.z)*.5,// generating points could be improved; this is pretty bad 4real\n                cos((h.y)*PI2+t*h.w)*.5,\n                h.z,// some kind of random seed\n                0);\n\n            pt.w = length(uv - pt.xy);\n            o.rgb /= clamp(pt.w*3.,0.1,1.);\n\n           \tpt.w *= pt.w;\n            if (pt.w < nearestPt.w) {\n                nearestPt2 = nearestPt;\n                nearestPt = pt;\n            } else if (pt.w < nearestPt2.w) {\n                nearestPt2 = pt;\n            }\n        }\n\n        // just for performance, trying to avoid a 2nd hash here. but it means\n        // certain colors will be favored visually. i don't mind, that's an opportunity\n        // to stylize\n        //o *= hash41(nearestPt.z*1e2);\n        o.rgb *= nearestPt.zxy;\n        float d = nearestPt2.w - nearestPt.w;\n        if (d < 0.02) {\n            // if dist to 2nd-nearest point is small, then we're on a border\n            break;\n        }\n        \n        uv -= nearestPt.xy*(sin(t*1.5)+.2);// blossom effect\n        uv *= 1.1;\n        uv = uv.yx; // cheap attempt to reduce regularity\n    }\n    \n\to /= ipartition + 1.;\n    o = clamp(o,0.,1.);\n    o = pow(o, o-o+.5);\n}\n\n\n\n\n","name":"Image","description":"","type":"image"}]}