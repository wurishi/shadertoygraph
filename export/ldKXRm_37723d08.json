{"ver":"0.1","info":{"id":"ldKXRm","date":"1463633577","viewed":208,"name":"Passage Infinitum","username":"JasonD","description":"Inspiration from my own EvalDraw demo that essentially did the same thing. This time on the GPU.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["floor","textured","ceiling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Jason Allen Doucette\n// http://xona.com/jason/\n//\n// Passage Infinitum\n// May 18, 2016\n\n\n// ---- SETTINGS ----------------------------------------------------------------\n\n#define X_SCALE 0.3     // size of texture stretch horizontally\n#define Z_SCALE 0.2     // size of texture stretch into screen\n\n#define Z_SPEED     0.3    // speed of motion into screen\n#define X_SPEED_MAX 0.5    // max speed horizontally \n#define X_CYCLE_SPEED 0.1  // cycle of horizontal (left/right) motion switch\n\n#define CAM_YAW_CYCLE_SPEED 0.225     // cycle of camera rotate left/right angle\n#define CAM_YAW_MAX_ANGLE 1.570796    // max camera rotate left/right angle\n\n#define CAM_ROLL_CYCLE_SPEED 0.168    // cycle of camera tilt angle\n#define CAM_ROLL_MAX_ANGLE 0.6642     // max camera rotate tilt angle\n\n#define CEN_POINT_CYCLE_SPEED1 0.562 // how fast the point goes around in a circle\n#define CEN_POINT_CYCLE_SPEED2 0.383 // how fast the point goes around in a circle\n#define CEN_POINT_CYCLE_MAG    0.3   // radius of the circle\n\n#define COLOR_CYCLE 0.25\n#define FADE_POWER 0.3\n\n\n// ---- CONSTANTS ----------------------------------------------------------------\n\n#define PI 3.1415926535897932384626\n\n\n// ---- CODE ----------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // isotropic scaling, ensuring entire texture fits into the view.\n    // After this, you should consider fragCoord = 0..1, usually,\n    // aside from overflow for wide-screen.\n    float minRes = min(iResolution.x, iResolution.y);\n    fragCoord /= minRes;\n   \n    // center point on screen\n    vec2 center = (iResolution.xy / minRes) / 2.0;    \n\n    // select a point on screen, upon which to rotate the screen\n    //vec2 p = center;\n    float angle1 = CEN_POINT_CYCLE_SPEED1 * iTime;\n    float angle2 = CEN_POINT_CYCLE_SPEED2 * iTime;\n    vec2 p = center + vec2(cos(angle1), sin(angle2)) * CEN_POINT_CYCLE_MAG;\n        \n    \n    // rotate point on screen (rotate entire screen)\n    // around point P\n    float angle = sin(iTime * CAM_ROLL_CYCLE_SPEED) * CAM_ROLL_MAX_ANGLE;\n    float cs = cos(angle);\n    float sn = sin(angle);\n\n    // ----------------------------------------------\n    // TODO -- MAKE FUNCTION FOR THIS, AND RE-USE:\n    fragCoord.xy -= p;\n    vec2 newCoord;\n#if 0\n    newCoord = vec2(\n        fragCoord.x * cs + fragCoord.y * sn,\n        fragCoord.y * cs - fragCoord.x * sn);\n    fragCoord.xy = newCoord;\n#else\n    mat2 m = mat2( \n        cs, -sn,\n        sn,  cs\n        );\n    fragCoord = m * fragCoord;    \n#endif\n    fragCoord.xy += p;\n    // ----------------------------------------------\n    \n    \n    \n    // distance from center\n    vec2 dCenter = center - fragCoord.xy;\n    \n    // height of screen\n    float height = (iResolution.y / minRes) / 2.0;\n    \n    // 3D perspective: 1/Z = constant\n    float zCamera = 1.0 / abs(dCenter.y);\n    float xCamera = X_SCALE * dCenter.x * zCamera;\n    float yCamera = Z_SCALE * zCamera;\n\n    // static texture coordinates\n    fragCoord.xy = vec2(xCamera, yCamera);\n    \n    \n    // rotate camera\n    // via rotating texture\n    angle = sin(iTime * CAM_YAW_CYCLE_SPEED) * CAM_YAW_MAX_ANGLE;\n    cs = cos(angle);\n    sn = sin(angle);\n    newCoord = vec2(\n        fragCoord.x * cs + fragCoord.y * sn,\n        fragCoord.y * cs - fragCoord.x * sn);\n    fragCoord.xy = newCoord;    \n\n    // move\n    fragCoord.y += iTime * Z_SPEED;\n    fragCoord.x += cos(iTime * X_CYCLE_SPEED) * X_SPEED_MAX;\n\n    // textured\n    if (dCenter.y > 0.0)\n        fragColor = texture(iChannel0, fragCoord);\n    else\n        fragColor = texture(iChannel1, fragCoord);\n    \n    \n    // get rainbow color\n    angle = iTime * COLOR_CYCLE; // 0...1...2...\n    float mag = mod(angle, 1.0/6.0) * 6.0; // 0..1\n    vec3 fadeColor = clamp(\n        abs(\n            fract(\n                vec3( angle + 2./3. ) + vec3(3,2,1) / 3.\n            ) * 6. - 3.\n        ) - 1., \n        0., \n        1.\n    );\n        \n\n    // fade into distance\n    // y=1-(1/x)\n    // x=0..infinity, y=0..1=fade\n\n    // 0=no fade, 1=full fade\n    float fade = 1.0 - (1.0 / (1.0 + zCamera * FADE_POWER));\n    fragColor.rgb = mix( fragColor.rgb, fadeColor.rgb, fade );\n}\n","name":"Image","description":"","type":"image"}]}