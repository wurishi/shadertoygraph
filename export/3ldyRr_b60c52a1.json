{"ver":"0.1","info":{"id":"3ldyRr","date":"1608369640","viewed":178,"name":"Dragon spine","username":"gaz","description":"3d","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI atan(1.)*4.\n#define TAU atan(1.)*8.\n\nvec3 lookAt(vec3 rd,vec3 ro,vec3 ta,vec3 up){\n    vec3 w=normalize(ta-ro),u=normalize(cross(w,up));\n    return rd.x*u+rd.y*cross(u,w)+rd.z*w;\n}\n\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nvec3 ta;\nfloat g1=0.;\n\n#define sabs(x,k)sqrt((x)*(x)+k)\nvec2 sFold90(vec2 p, float k)\n{\n    return (p.x+p.y+vec2(1,-1)*sabs(p.x-p.y,k))*.5;\n}\n\nfloat doragonSpine(vec3 p)\n{\n    p.z-=iTime*4.;\n    float s=1.;\n    float c=1.2;\n    p.z=mod(p.z,c)-.5*c;\n    for(float i=0.;i<3.;i++){\n        p=abs(p)-.25;\n        p.yz=sFold90(p.yz,1e-3);\n        p.xz=sFold90(p.xz,1e-3);\n        p.xy=sFold90(p.xy,1e-3);\n        p-=vec3(3.3,-1.,.3);\n        p.xy*=rot(.23);\n        p.yz*=rot(-.05);\n        p.z+=.6;\n        float b=.06;\n        p=b-abs(abs(p-2.*b)-b);\n        p*=2.;\n        s*=2.;\n    }\n    p/=s;\n    float h=.6;\n    p.x-=clamp(p.x,-h,h);\n    return max(abs(length(p.xy)-.7)-.03,abs(p.z)-.007);\n}\n\nfloat stella(vec3 p)\n{\n    p-=ta+vec3(\n        cos(iTime*.5+cos(iTime*.3)*.3),\n        sin(iTime*.5+sin(iTime*.5)*.2),\n        cos(iTime*.3+cos(iTime*.3)*.5)*.3\n        );\n    p.xy*=rot(iTime*1.);\n    p.xz*=rot(iTime*1.);\n    float k=1e-3;\n    p=sabs(p,k);\n    p.xz=sFold90(p.xz,k);\n\tp.yz=sFold90(p.yz,k);\n    p.xy=sFold90(p.xy,k);\n    vec3 v = normalize(vec3(2,3,1));\n    return dot(p,v)-1.;\n}\n\n\nfloat map(vec3 p)\n{\n    float de=stella(p);\n    g1+=.5/(.1+de*de); // Distance glow by balkhan    \n    return min(de,doragonSpine(p));\n}\n\n\nvec3 calcNormal(vec3 p)\n{\n  vec3 n=vec3(0);\n  for(int i=0; i<4; i++){\n    vec3 e=.01*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\n    n+=e*map(p+e);\n  }\n  return normalize(n);\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<70;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<.001) return t;\n        if (t>=far) return far;\n    }\n    return far;\n}\n\nvec3 doColor(vec3 p)\n{\n    if(stella(p)<.001)return vec3(0);\n    return vec3(.0,.2,.3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y;\n    ta=vec3(cos(iTime*.5+1.3*cos(iTime*.3))*4.,sin(iTime*.3)*4.,0);\n    vec3 ro=vec3(sin(iTime*.3)*4.,cos(iTime*.4+.5*cos(iTime*.3))*4.,2.5);\n    vec3 rd=lookAt(normalize(vec3(uv,1)),ro,ta,vec3(0,1,0));\n    vec3 col= vec3(.02,.02,.06);\n\tconst float maxd=50.;\n    float t=march(ro,rd,0.3,maxd);\n    if(t<maxd)\n    {\n        vec3 p=ro+rd*t;\n        col=doColor(p); \n        vec3 n=calcNormal(p);      \n\t\tvec3 lightPos=ro+vec3(2,15,2);\n    \tvec3 li=lightPos-p;\n\t\tfloat len=length(li);\n\t\tli/=len;\n\t\tfloat dif=clamp(dot(n,li),0.,1.);\n        col*=max(dif,.2);\n        float rimd=pow(clamp(1.-dot(reflect(-li,n),-rd),0.,1.),2.5);\n\t\tfloat frn=rimd+2.2*(1.-rimd);\n    \tcol*=frn*.6;\n        col*=max(.5+.5*n.y,.3);\n        col*=exp2(-2.*pow(max(0.,1.-map(p+n*.8)/.8),2.));\n        col+=vec3(.7,.2,.1)*pow(clamp(dot(reflect(rd,n),li),0.,1.),10.);\n        col=mix(vec3(0),col,exp(-t*t*.01));\n        if(stella(p)<.001)g1*=.1;\n    }\n    g1*=.1;\n    col+=vec3(.9,.3,0.)*smoothstep(0.,1.,g1);\n    col+=vec3(.5,.4,0.)*smoothstep(.2,.9,g1*.1);\n    fragColor.xyz=col;\n}","name":"Image","description":"","type":"image"}]}