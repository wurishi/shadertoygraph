{"ver":"0.1","info":{"id":"Ml2yzD","date":"1560355441","viewed":418,"name":"Double Triangle Truchet Doodle","username":"BigWIngs","description":"Just a doodle of an idea.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["triangle","truchet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Double Traingle Truchet Doodle by Martijn Steinrucken aka BigWings - 2017\n// countfrolic@gmail.com  Twitter: @The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// One of many doodles I have lying around.\n//\n// Since truchet tiling only works on tiles that have an even number of edges, \n// you can't normally do it on a triangular tiling. So I figured I'd just double\n// the connections per edge to get back to an even number.\n//\n// For a more polished example of 'double' truchet, check out my double quad truchet example:\n// https://www.shadertoy.com/view/wlSGDD\n// Or Shanes version of the same idea:\n// https://www.shadertoy.com/view/wl2GRG\n\n#define S(a, b, t) smoothstep(a, b, t)\n#define GRID 20.\n\n#define R2  1.41421356\n#define HR2 0.70710678\n#define TR2 0.47140452\n#define SR2 0.23570226\n#define PI  3.14159265\n\n// from Dave Hoskins' 'Hash without Sine'\nvec3 N23(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec4 UvCirc(vec2 uv, float radius, float thickness) {\n\tvec2 st = vec2(atan(uv.x, uv.y), length(uv));\n    \n    float t = thickness/2.;\n    float w = .01;\n    \n    float r1 = radius-t;\n    float r2 = radius+t;\n    \n    float mask = S(t+w, t, abs(radius-st.y));\n    float alpha = S(t+.1, t, abs(radius-st.y));\n    alpha = alpha*alpha*mix(.5, 1., mask);\n    \n    return vec4(st.x*radius, st.y, mask, alpha);\n}\n\nvec4 TriCoords(vec2 uv) {\n\t// normal uv in, center, barycentric coords out\n    vec2 id = floor(uv);\n    uv = fract(uv);\n    \n    vec2 c;  // the center of the triangle\n    float e; // the distance to the closest edge\n    float s; // the side the triangle is facing\n    \n    if(uv.x<uv.y) {\n    \tc = vec2(.333, .666);\n        e = min(min(uv.x, 1.-uv.y), (uv.y-uv.x));\n        uv = 1.-vec2(uv.x, uv.y);\n        s = -1.;\n    } else {\n        c = vec2(.666, .333);\n        e = min(min(1.-uv.x, uv.y), (uv.x-uv.y));\n        s = 1.;\n    }\n    c += id;\n    \n    \n    return vec4(c, uv);\n}\n\nfloat Band(float v, float y, float t, float b) {\n\tt/=2.;\n    return S(t, t-b, abs(v-y));\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n\tU = (U-iResolution.xy*.5)/iResolution.x;\n    vec2 m = (iMouse.xy/iResolution.xy);\n    \n    float t = iTime*.2;\n    \n    \n    U *= mix(2., GRID, sin(t*.5)*.5+.5);\n\tU += iTime;\n    mat2 tt;\n    \n    //U.x *= .5*sqrt(2.)*sqrt(3./4.);\t\t\t// stretch so sides are of equal length\n   // tt = mat2(-HR2, HR2, HR2, HR2);\n    \n    float f = .942;\n    tt = mat2(-.433013*f, HR2, .433013*f, HR2); // triangle transform\n    //tt = mat2(1,0,0,1);\n   U *= tt; \t\t\t\t\t// apply rotation\n    \n    vec4 tc = TriCoords(U);\n    vec3 n = N23(tc.xy);\n    vec2 uv = tc.zw+tc.xy;\n    \n    //uv *= inverse(tt);\n    \n    vec3 col = vec3(tc.zw, 0);\n   \n    //m.x *= tc.a;\n    tt = inverse(tt);\n    //tc.zw *= inverse(tt);\n    \n    vec2 a = tc.zw*tt;\n    vec2 b = (tc.zw-vec2(1,0))*tt;\n    vec2 c = (tc.zw-vec2(1,1))*tt;\n    vec3 d = vec3(length(a), length(b), length(c));\n    \n    vec2 a2 = (tc.zw-vec2(.5, .5))*tt;\n    vec2 b2 = (tc.zw-vec2(.5,0))*tt;\n    vec2 c2 = (tc.zw-vec2(1.,.5))*tt;\n    vec3 d2 = vec3(length(a2), length(b2), length(c2));\n    \n    //col = d;\n    float blur = .01;\n    float w = .2;\n    float ma=0., mb=0., mc=0.;\n    \n    float tile = n.z;\n    if(tile<.1) {\n    \tma = Band(d.r, TR2, w, blur);\t\t// jump 1\n    \tmb = Band(d.g, TR2, w, blur);\t\t// jump 1\n    \tmc = Band(d.b, TR2, w, blur);\t\t// jump 1\n    } else if(tile<.2){\n    \tma = Band(d2.r, SR2, w, blur);\t\t// jump 1\n    \tmb = Band(d2.g, SR2, w, blur);\t\t// jump 1\n    \tmc = Band(d2.b, SR2, w, blur);\t\t// jump 1\n    } else if(tile<.4) {\t\t\n    \tma = Band(d.r, TR2, w, blur);\t\t// jump 1\n    \tmb = Band(d2.b, SR2, w, blur);\t\t// jump 1\n        mc = Band(d.r, TR2*2., w, blur);\t// jump 3\t\n    } else if(tile<.6) {\n    \tma = Band(d.r, TR2*2., w, blur);\t// jump 3\n    \tmb = Band(d.g, TR2*2., w, blur);\t// jump 3\n        mc = Band(d.b, TR2*2., w, blur);\t// jump 3\t\n    }else if(tile<.8) {\n        float f = (atan(tc.z, tc.w)/6.28)+.5;\n        f = fract(f*8.);\n        f = S(0.,1.,f);\n\n        ma = Band(d2.b, TR2/2., w, blur);\t// jump 1\n        mb = Band(d.r, TR2+TR2*f, w, blur);\t// jump 2\n        \n    \tf = 1.-f;\n        f *= f;\n        mc = Band(d.r, TR2+TR2*f, w, blur);\t// jump2\n    } else {\n    \n        f = (atan(tc.z-1., tc.w)/6.28);\n        f = fract(f*4.);\n        f = S(0.,1.,f);\n\n        ma = Band(d.r, TR2, w, blur);\t\t// jump 1\n        mb = Band(d.g, TR2+f*TR2, w, blur);\t\t// jump 2\n\n        f = (atan(tc.z-1., tc.w-1.)/6.28);\n        f = fract(f*8.);\n        f = S(0.,1.,f);\n        f = 1.-f;\n\n        mc = Band(d.b, TR2+f*TR2, w, blur);\t\t// jump 2\n    }\n    \n    vec3 ribCol = vec3(.1, .1, 1.);\n    vec4 v1 = vec4(1,0,0, ma);\n    vec4 v2 = vec4(0,1,0, mb);\n    vec4 v3 = vec4(0,0,1, mc);\n    \n    // composite in different orders\n    vec4 v = n.x<.166 ? mix(v1, mix(v2, v3, v3.a), max(v2.a, v3.a))\n           : n.x<.333 ? mix(v1, mix(v3, v2, v2.a), max(v2.a, v3.a))\n           : n.x<.5   ? mix(v2, mix(v1, v3, v3.a), max(v1.a, v3.a))\n           : n.x<.666 ? mix(v2, mix(v3, v1, v1.a), max(v1.a, v3.a))\n           : n.x<.833 ? mix(v3, mix(v1, v2, v2.a), max(v1.a, v2.a))\n           :           mix(v3, mix(v2, v1, v1.a), max(v1.a, v2.a));    \n\n    \n    col = mix(col*.2, v.rgb, v.a);\n   // col = mix(col, vec3(f), .5) ;\n    O = vec4(col, 1);\n    \n}","name":"Image","description":"","type":"image"}]}