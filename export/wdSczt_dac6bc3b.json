{"ver":"0.1","info":{"id":"wdSczt","date":"1587149451","viewed":140,"name":"Crazy Shaker","username":"creationix","description":"Playing with bend.","likes":4,"published":1,"flags":1,"usePreview":0,"tags":["sdf","vr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst int MAX_MARCHING_STEPS=256;\nconst float MIN_DIST=4.;\nconst float MAX_DIST=6.;\nconst float EPSILON=.0001;\n\n// Primitives from https://iquilezles.org/articles/distfunctions\n\nfloat sdSphere(vec3 p,float s)\n{\n    return length(p)-s;\n}\n\nfloat sdBox(vec3 p,vec3 b)\n{\n    vec3 q=abs(p)-b;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat sdRoundBox(vec3 p,vec3 b,float r)\n{\n    vec3 q=abs(p)-b;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.)-r;\n}\n\nfloat sdVerticalCapsule(vec3 p,float h,float r)\n{\n    p.y-=clamp(p.y,0.,h);\n    return length(p)-r;\n}\n\nfloat sdCapsule(vec3 p,vec3 a,vec3 b,float r)\n{\n    vec3 pa=p-a,ba=b-a;\n    float h=clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n    return length(pa-ba*h)-r;\n}\n\nfloat opUnion(float d1,float d2){return min(d1,d2);}\n\nfloat opSubtraction(float d1,float d2){return max(-d1,d2);}\n\nfloat opIntersection(float d1,float d2){return max(d1,d2);}\n\nfloat opSmoothUnion(float d1,float d2,float k){\n    float h=clamp(.5+.5*(d2-d1)/k,0.,1.);\nreturn mix(d2,d1,h)-k*h*(1.-h);}\n\nfloat opSmoothSubtraction(float d1,float d2,float k){\n    float h=clamp(.5-.5*(d2+d1)/k,0.,1.);\nreturn mix(d2,-d1,h)+k*h*(1.-h);}\n\nfloat opSmoothIntersection(float d1,float d2,float k){\n    float h=clamp(.5-.5*(d2-d1)/k,0.,1.);\nreturn mix(d2,d1,h)+k*h*(1.-h);}\n\nvec3 rotateX(vec3 p,float angle){\n    return vec3(mat4(\n            1,0,0,0,\n            0,cos(angle),-sin(angle),0,\n            0,sin(angle),cos(angle),0,\n            0,0,0,1\n        )*vec4(p,0)\n    );\n}\n\nvec3 rotateY(vec3 p,float angle){\n    return vec3(mat4(\n            cos(angle),0,sin(angle),0,\n            0,1,0,0,\n            -sin(angle),0,cos(angle),0,\n            0,0,0,1\n        )*vec4(p,0)\n    );\n}\n\nvec3 rotateZ(vec3 p,float angle){\n    return vec3(mat4(\n            cos(angle),-sin(angle),0,0,\n            sin(angle),cos(angle),0,0,\n            0,0,1,0,\n            0,0,0,1\n        )*vec4(p,0)\n    );\n}\n\nvec3 repeat(in vec3 p,in vec3 c){\n    return mod(p+.5*c,c)-.5*c;\n}\n\nvec3 twist(in vec3 p,float k){\n    float c=cos(k*p.y);\n    float s=sin(k*p.y);\n    mat2 m=mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nvec3 cheapBend(in vec3 p,float k){\n    float c=cos(k*p.x);\n    float s=sin(k*p.x);\n    mat2 m=mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nfloat sdGrid(in vec3 p){\n    return sdSphere(repeat(p,vec3(.2,.8,.4)),.05);\n}\n\nfloat grimace(in vec3 p) {\n    return opSmoothUnion(\n        sdBox(cheapBend(p,sin(iTime*8.)),vec3(.8,.1,.3)),\n        sdBox(cheapBend(rotateY(p, iTime),cos(iTime*8.)),vec3(.8,.1,.3)),\n        .4\n    );\n}\n\nfloat sceneSDF(in vec3 p){\n    return grimace(rotateZ(rotateX(p, iTime),iTime*1.5));\n}\n\nvec4 render(in vec3 ro,in vec3 rd){\n    float depth=MIN_DIST;\n    int cost=MAX_MARCHING_STEPS;\n    for(int i=0;i<MAX_MARCHING_STEPS;i++){\n        float dist=sceneSDF(ro+depth*rd);\n        if(dist<EPSILON){\n            cost=i;\n            break;\n        }\n        depth+=dist;\n        if(depth>=MAX_DIST){\n            cost=i;\n            depth=MAX_DIST;\n            break;\n        }\n    }\n    if(cost==MAX_MARCHING_STEPS)depth=MAX_DIST;\n    \n    float hard=clamp(log(float(cost))/log(float(MAX_MARCHING_STEPS)),0.,1.);\n    float deep=clamp(1.-(depth-MIN_DIST)/(MAX_DIST-MIN_DIST),0.,1.);\n    \n    if(depth>MAX_DIST-EPSILON){\n        return vec4(hard*.5,hard,1.,hard*hard);\n    }\n    return vec4(vec3(deep-hard),1.);\n    //return vec4(hard*hard*1.5,hard*hard*hard*1.2,deep*deep*(1.-hard),1);\n    \n}\n\nvec3 rayDirection(float fieldOfView,vec2 size,vec2 fragCoord){\n    vec2 xy=fragCoord-size/2.;\n    float z=size.y/tan(radians(fieldOfView)/2.);\n    return normalize(vec3(xy,-z));\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    fragColor=render(\n        vec3(0.,0.,5.),// ray origin\n        rayDirection(50.,iResolution.xy,fragCoord)\n    );\n}\n\nvoid mainVR(out vec4 fragColor,in vec2 fragCoord,in vec3 fragRayOri,in vec3 fragRayDir)\n{\n    fragColor=render(\n        fragRayOri+vec3(0.,0.,2.),\n    fragRayDir);\n}\n\n","name":"Image","description":"","type":"image"}]}