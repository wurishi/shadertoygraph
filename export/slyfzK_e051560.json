{"ver":"0.1","info":{"id":"slyfzK","date":"1664823131","viewed":192,"name":"Styled Voronoi Experiment","username":"ChristinaCoffin","description":"hacking up voronoi code + distance values and color mappings to create more stylized results","likes":31,"published":1,"flags":0,"usePreview":0,"tags":["2d","voronoi","palette"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2022-10-03 cac- Styled Voronoi Experiment\n//\n// inspired from simplified https://www.shadertoy.com/view/MtlyR8 (VoronoÃ¯ with various metrics)\n// + tilability, multiple seed per cell\n\n\n//visuals are extra sensitive to large changes in these values\n#define C 99.  // cell size\n#define B  8.  // number of blob per cell. B=1 -> Poisson disk. Large or random B -> Poisson\n#define R  .5  // jittering blob location. .5 = anywhere in the tile. could be < or >\n#define dr 0.85  // blob radius fluctuates in [1-r,1+r]\n// nice values are  between 0.65-> 1.99\n#define N  5   // tested neighborhood. Make it odd > 3 if R is high , larger search needed due to larger and shifted blobs\n\n#define srnd(p)  ( 2.* fract(43758.5453*sin( dot(p, vec2(12.9898, 78.233) )      ) ) - 1. )\n#define srnd2(U) ( 2.* fract(4567.89* sin(4567.8*(U)* mat2(1,-13.17,377.1,-78.7) ) ) - 1. )\n\n\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    //https://www.shadertoy.com/view/ll2GD3\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 fragCoord = U;//save for Post\n    vec2 scr_uv = fragCoord.xy / iResolution.xy;  \n\tvec2 suv = fragCoord.xy / iResolution.xy;  \n    suv *=  1.0 - suv.yx;   //vec2(1.0)- uv.yx; -> 1.-u.yx; Thanks FabriceNeyret !  \n\n\n    float H = iResolution.y*1.50,\n          S = round(H/C);             // make number of cells integer for tilability\n          \n    U.y += (iTime*33.0);//vertical scroll    \n    U /= H;\n    U *= S; \n    float m=1e9,m2, v,w, r, r0=1e2;\n    \n    for (int k=0; k<N*N; k++)                  // neihborhood search\n        for (float i=0.; i<B; i++) {                // loop over blobs\n            vec2 iU = floor(U),\n                  g = mod( iU + vec2(k%N,k/N)-1. , S),  // cell location within neighborhood\n                  p = g+.05 + R* srnd2((g+i)*.71)\n                      +.1*sin(iTime+vec2(1.6,0)+3.14*srnd(g+i+i))         // time jittering\n                  ;         // blob location\n            \n            p = mod( p - U +S/2. , S) - S/2.;           // distance to blob center                                  \n            r =  1. + dr* srnd(g+i*.91+.01);            // blob radius\n            \n            // radius growth animation, cellular pulsing \n            r += sin(iTime *0.1 *srnd(g+i+i))*fract(srnd(g+i+i))*0.1;         \n            r = clamp(r, 0.01 , 0.999);// shouldnt need this, but the above radius code can vary wildly\n            r+= 0.951;//scalar value offsetting, hack to adjust visuals\n            v = length(p) / r*r*r*r*r*r;  \n  \n         if (v < m) m2 = m, m = v;        // keep 1st and 2nd min distances to node\n            else if (v < m2) m2 = v;  \n    }\n\n    v = m2-m;                            \n    vec4 map_6 =  vec4( 1.-m );            \n    vec4 map_9 =  vec4( 1.-m-v );\n    O = vec4(.025,.05,.1,0)/v;\n\n    //capture grayscale version of mapping before extra modification\n    float graySrc = dot(O.rgb, vec3(0.2126, 0.7152, 0.0722));\n\n    O = (vec4(0.71,0.3,0.1,0)*vec4(smoothstep(-0.31,1.,1.*v)));//smoothstep away the cell borders\n\n\n    vec3 col = pal( v+U.x/S, vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25));\n    vec3 col2a = pal( -m2-v+U.x+U.y/S, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20));   \n\n    if(scr_uv.x < 0.5)\n       col2a = pal( m2-v+U.x+U.y/S, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20));\n\n\n    /*\n    // alternate space warp visualizations\n       m2-v+U.y*U.x/S\n       m2-v+U.y-U.x/S\n    */\n\n  //  vec3 col2 = pal( m2-v+U.y-U.x*U.x/S, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );   \n\n   \n  // vec4 baseColor = O.rgba;\n  // O*=O*0.5;\n   O.rgb *= col/col2a*vec3(0.23,0.5,0.13);\n   \n  // O.bg -= v*v*v*v;\n   O.r += v*(v*0.2);\n   O.b += v*(v*0.16);\n   O.g += v*(v*0.13);\n   \n    //channel contrasting\n    // O.b *= m2;\n    //  O.r /= m2;\n    // O.g -= col2.b;\n   \n       O.rgb = O.gbr;//channel swizzle for nicer starter palette\n       O.rgb = smoothstep(0.0, 1.3, O.rgb);\n   \n    //---------------------\n    // grayscale conversion\n    float gray = dot(O.rgb, vec3(0.2126, 0.7152, 0.0722));\n    // regamma\n    float gammaGray = sqrt(gray);  \n    \n    \n    if(scr_uv.x > 0.5)\n    {\n        O.rgb -= vec3(graySrc);//subrtractive effect to break up lines using src mapping\n        O.rgb = O.bgr*vec3(0.35,1,1)*m2*-m2;\n        \n    }\n    else\n    {\n        if(scr_uv.x < 0.25) O.b *= (m2*0.5)*m2*m2*m2;//extra edge glow on far left one\n        \n        \n        O.rgb += vec3(gammaGray);// glow the lefthand side versions\n    }\n   \n   O.r += map_6.r+map_9.r;//visual style\n   \n   //O.rgb += min(O.rgb,map_3.rgb);\n   \n   if(scr_uv.x < 0.25)\n   {\n         O.rgb *= col/m2;\n         O.rgb = O.brg;\n         O.b -= 12.0*graySrc;\n   }\n   \n   \n   \n   \n//Post   \n    float vig = suv.x*suv.y * 15.0; // multiply with sth for intensity    \n    vig = pow(vig, 0.125); // change pow for modifying the extend of the  vignette\n    O.rgb *= vec3(vig);//final mix\n\n\n    //section dividers\n    O.rgb *= smoothstep( 0.003, 0.005, abs(scr_uv.x-0.5) );\n    O.rgb *= smoothstep( 0.003, 0.005, abs(scr_uv.x-0.25) );\n\n}","name":"Image","description":"","type":"image"}]}