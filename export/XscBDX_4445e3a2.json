{"ver":"0.1","info":{"id":"XscBDX","date":"1526928165","viewed":337,"name":"The Chase (version 2.0)","username":"dpiponi","description":"A chase through a deserted city in space.\nNow with depth of field, but camera focussed on target.\nTrimmed down the focus","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["ambientocclusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec4 color = texture(iChannel0, uv, 0.0); \n    float z = color.w;\n    float theTime = 0.5*iTime;\n    vec3 p = path(theTime);\n    vec3 target = path(theTime+0.5);\n    \n    float focus = length(target-p);\n    float c = (1.0-focus/z);\n    float lod = 0.0;//3.0*log(0.02*(1.0-focus/z))/log(2.0);\n    //color = texture(iChannel0, uv, lod);\n    //color += 0.1*texture(iChannel0, uv, 1.0);\n    color = vec4(0.0);\n\n    \n    for (int i = -1; i < 2; ++i) {\n        for (int j= -1; j < 2; ++j) {\n            if (i*i+j*j <= 1) {\n            \tcolor += 0.2*texture(iChannel0, uv+0.001*c*vec2(float(i),float(j)), lod);\n            }\n        }\n    }\n    fragColor = vec4(color.xyz, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvec3 target;\n\n// Hash and noise from iq\nfloat hash(vec3 p){\n    p  = fract(p*0.3183099+.1);\n    p *= 17.0;\n    return fract(p.x*p.y*p.z*(p.x+p.y+p.z));\n}\n\nfloat noise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix(mix(hash(p+vec3(0,0,0)), \n                       hash(p+vec3(1,0,0)),f.x),\n                   mix(hash(p+vec3(0,1,0)), \n                       hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix(hash(p+vec3(0,0,1)), \n                       hash(p+vec3(1,0,1)),f.x),\n                   mix(hash(p+vec3(0,1,1)), \n                       hash(p+vec3(1,1,1)),f.x),f.y),f.z)-0.5;\n}\n\nfloat turb(vec3 uvw) {\n    float c = 0.0;\n//    int i;\n    float s1 = 2.0;\n    float s2 = 1.0;\n    float t = 0.0;\n    for (int i = 0; i < 7; ++i) {\n        c += s2*noise(s1*uvw);\n        //c += s2*noise1(s1*uv);\n        t += s2;\n        s1 *= 2.0;\n        s2 *= 1.0;\n    }\n    return c/t;\n}\n\nfloat concrete(vec3 uvw) {\n    float d = turb(1.0*uvw+vec3(23.45, 763.1, -123.2));\n    float c = 0.1+0.26*smoothstep(-0.4, 0.4, d);\n\n    d = turb(1.0*uvw+vec3(-13.12, 1245.0, 12.11));\n    c += -0.1*smoothstep(0.0, 0.1, d);\n\n    //d = turb(40.0*uv+vec2(12.0, 152.11));\n    //c += d > 0.2 ? 0.1 : 0.0;\n\n    return 0.5+1.0*c;\n}\nfloat theTime = 0.0;\n\nmat4 translate(vec3 p) {\n    return mat4(1.0,  0.0,  0.0,  -p.x,\n              0.0,  1.0,  0.0,  -p.y,\n              0.0,  0.0,  1.0,  -p.z,\n              0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 scale(vec3 s) {\n    return mat4(s.x,  0.0,  0.0,  0.0,\n              0.0,  s.y,  0.0,  0.0,\n              0.0,  0.0,  s.z,  0.0,\n              0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat4(c,  -s,  0.0,  0.0,\n              s,  c,  0.0,  0.0,\n              0.0,  0.0,  1.0,  0.0,\n              0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat4(c,  0.0, s,  0.0,\n              0.0,  1.0, 0.0, 0.0,\n              -s,  0.0, c,  0.0,\n              0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, c,  -s,  0.0, \n                0.0, s,  c,  0.0,\n                0.0,  0.0,  0.0,  1.0);\n}\n\n// Assume n normalised\nvec3 fold(vec3 n, vec3 x) {\n    float nx = dot(n, x);\n    return nx >= 0.0 ? x : x-2.0*nx*n;\n}\n\nvec4 myreflect(vec3 n, vec3 p, vec4 x) {\n    vec3 xyz = x.xyz-p;\n    n = normalize(n);\n    float nx = dot(n, xyz);\n    vec4 nn;\n    nn.xyz = p+(nx >= 0.0 ? xyz : xyz-2.0*nx*n);\n    nn.w = 2.0*x.w+(nx >= 0.0 ? 1.0 : 0.0);\n    return nn;\n}\n\nfloat cube(vec3 x) {\n    //return length(x)-0.9;\n    return max(x.z,max(-x.z,max(x.y,max(-x.y,max(x.x, -x.x)))))-1.25;\n}\n\nfloat sphere(vec3 x) {\n    return length(x)-0.2;\n}\n\n#if 0\nfloat h(vec3 x) {\n    mat4 m = rotateZ(0.2101*theTime-3.128)*rotateY(0.1311*theTime+1.234);\n    return g((vec4(x, 1.0)*m).xyz);\n}\n#endif\n\nvec2 xy;\n\n// {{1., 0., 0.}, {0., -1., 0.}, {0.809017, 0.5, -0.309017}}\n//vec3 pc = vec3(1.95, -0.82, -0.94);\n//vec3 pc = vec3(0.80, 0.5, -0.3);\nvec3 pc = vec3(0.809017, 0.5, -0.309017);\n\nvec3 dodecafold(vec3 x) {\n    x.xy = -abs(x.xy);\n    x = fold(pc, x);\n    x.xy = -abs(x.xy);\n    x = fold(pc, x);\n    x.xy = -abs(x.xy);\n    x = fold(pc, x);\n    x.xy = -abs(x.xy);\n    x = fold(pc, x);\n    x.xy = -abs(x.xy);\n    x = fold(pc, x);\n\n    return x;\n}\n\n\nvec4 scene(vec3 x0) {\n    vec4 x = vec4(x0, 0.0);\n    x = myreflect(vec3(0.0, 1.0,2.00), vec3(0.0, -26.00, -26.25), x);\n    x = myreflect(vec3(1.0, 0.0,1.00), vec3(-21.0, 0.00, -26.50), x);\n    x = myreflect(vec3(1.0, 1.0,0.00), vec3(-33.0, 0.00, 0.00), x);\n    x = myreflect(vec3(0.0, -1.0,0.00), vec3(0.0, 20.00, 0.00), x);\n    x = myreflect(vec3(0.0, 1.0,0.00), vec3(0.0, -25.00, 0.00), x);\n    x = myreflect(vec3(-1.0, 0.0,0.00), vec3(18.0, 0.00, 0.00), x);\n    x = myreflect(vec3(1.0, 1.0,0.00), vec3(-9.0, -19.00, 0.00), x);\n    x = myreflect(vec3(0.0, 0.0, 1.00), vec3(0.0, 0.00, -35.00), x);\n    x = myreflect(vec3(0.0, 1.0, 1.00), vec3(5.0, 5.00, -11.00), x);\n    x = myreflect(vec3(1.0, 0.0, -1.00), vec3(-3.0, 5.00, 11.00), x);\n    x = myreflect(vec3(0.0, 1.0, -1.00), vec3(-2.0, 6.00, 8.00), x);\n    x = myreflect(vec3(1.0, -1.0, 0.00), vec3(-4.0, 21.00, -8.00), x);\n    x = myreflect(vec3(1.0, 0.0, 0.00), vec3(-4.0, 12.00, -10.00), x);\n    x = myreflect(vec3(0.0, 0.0, 1.00), vec3(4.0, 10.00, -8.00), x);\n    x = myreflect(vec3(1.0, 0.0, 1.00), vec3(-1.0, 8.00, -2.00), x);\n    x = myreflect(vec3(0.0, 1.0, 1.00), vec3(8.0, -10.00, 4.00), x);\n    x = myreflect(vec3(1.0, -1.0, 0.00), vec3(-6.0, 4.00, 1.00), x);\n    x = myreflect(vec3(0.0, -1.0, 0.00), vec3(2.0, 1.00, 3.00), x);\n    x = myreflect(vec3(0.0, -1.0, 1.00), vec3(4.0, 0.00, 0.00), x);\n    x = myreflect(vec3(1.00, 0.0, 1.0), vec3(-2.00, 5.0, -6.00), x);\n    x = myreflect(vec3(0.0, 1.00, 1.0), vec3(1.0, -4.0, -4.0), x);\n    x = myreflect(vec3(1.0, 1.0, 0.0), vec3(-5.00, -1.0, -1.0), x);\n    x = myreflect(vec3(1.0, -1.0, 0.0), vec3(-7.0, -4.0, 8.0), x);\n    x = myreflect(vec3(-1.0, 1.0, 0.0), vec3(0.0, -3.0, 2.0), x);\n    x = myreflect(vec3(-1.0, 0.0, 1.0), vec3(7.0, -5.0, 4.00), x);\n    x = myreflect(vec3(-1.0, 1.0, 0.0), vec3(1.0, -0.0, -2.0), x);\n    x = myreflect(vec3(1.0, 1.0, 0.0), vec3(6.0, -8.0, 0.0), x);\n    x = myreflect(vec3(0.0, 1.0, 0.0), vec3(-1.0, -4.0, -1.0), x);\n    x = myreflect(vec3(0.0, 1.0, 1.0), vec3(1.0, -5.0, -3.0), x);\n    x = myreflect(vec3(0.0, -1.0, 1.0), vec3(2.0, 3.0, 0.0), x);\n    x = myreflect(vec3(1.0, 0.0, 1.0), vec3(1.0, -5.0, -3.0), x);\n    x = rotateZ(theTime)*x;\n    //x = rotateY(0.5*theTime)*x;\n\n//    float d = cube(x.xyz);\n//    for (int i = 0; i < 5; ++i) {\n//        d = min(d, sphere(x0-path(theTime+0.5+0.5*i)));\n//    }\n//    return vec4(x.xyz, d);\n    return vec4(x.xyz, min(cube(x.xyz), sphere(x0-target)));\n    //return vec4(x.xyz, sphere(x0-target));\n}\n\nfloat eps = 0.0001;\nfloat lambda = 2.0;\n\nvec3 ico[12];\n\n//vec3 hash3(vec3 x) {\n//    float u = 1000.0*sin(x.x*x.y+3.3*x.z-2.2*x.y+10.123*x.y+11.12*x.y*x.z);\n//    float v = 1000.0*sin(x.z*x.y-2.1*x.z+3.0*x.z+7.211*x.y+32.12*x.y*x.x);\n//    float w = 1000.0*cos(x.z*x.y+3.4*x.z-3.0*x.x+17.97*x.y+11.12*x.x*x.y);\n//    return vec3(u-floor(u), v-floor(v), w-floor(w));\n//}\n\nfloat lighting(vec3 x, vec3 n) {\n    float t = 0.0;\n    for (int i = 0; i < 12; ++i) {\n        //float p = scene(x-0.05*n+0.10*ico[i]);\n        //t += 0.8+10.0*p;\n        vec3 dd = ico[i];//faceforwrd(ico[i], ico[i], n);\n        float p = scene(x+0.85*n+2.0*dd).w;\n        t += 0.5*p;\n    }\n    return t/12.0-0.5;\n}\n\nmat4 view() {\n    return rotateY(0.25*theTime)*rotateX(0.00*theTime);\n}\n\nvec4 march(vec3 p, vec3 d) {\n    vec3 p0 = p;\n    float c;\n    c = scene(p).w;\n    if (c < 0.0) {\n        return vec4(0.0, 0.0, 0.0, 100.0);\n    }\n    for (int i = 0; i < 100; ++i) {\n        float step = max(0.004, c);\n        p = p+step*d;\n        vec4 ff = scene(p);\n        vec3 x = ff.xyz;\n        c = ff.w;\n        if (c <= 0.0) {\n            float ex, ey, ez;\n            ex = scene(p+vec3(eps, 0.0, 0.0)).w;\n            ey = scene(p+vec3(0.0, eps, 0.0)).w;\n            ez = scene(p+vec3(0.0, 0.0, eps)).w;\n            vec3 n = vec3(ex-c, ey-c, ez-c)/eps;\n            n = normalize(n);\n            mat4 m = view();\n            vec3 light = (vec4(1.0,1.0,-1.0,1.0)*m).xyz;\n            float l0 = 0.25+0.75*max(dot(n, light)/sqrt(3.0), 0.0);\n            float l1 = 0.75*lighting(p, n);\n            float s = concrete(0.5*p);+(length(p-target)<0.201 ? 0.2 : 0.0);\n            //float l3 = 1.0+min(1.0/length(p-target),2.0);\n            //float l3 = length(p-target) < 0.201 ? 100000.0 : 0.0;\n            //return 2.5*s*(0.1+0.7*l0+0.7*l1)*vec3(0.74, 0.72, 0.7);\n            return vec4(1.1*s*(0.3+0.5*l0+0.7*l1)*vec3(1.61, 1.36, 1.27), length(p-p0));\n        }\n    }\n    return vec4(0.0, 0.0, 0.0, 20.0);\n}\n\nmat3 complete(vec3 y, vec3 z) {\n    vec3 x = normalize(cross(y, z));\n    y = normalize(cross(z, x));\n    return mat3(x, y, z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    theTime = 0.5*iTime;\n    pc = normalize(pc);\n\n    ico[0] = vec3(-0.26286500, 0.0000000, 0.42532500);\n    ico[1] = vec3(0.26286500, 0.0000000, 0.42532500);\n    ico[2] = vec3(-0.26286500, 0.0000000, -0.42532500);\n    ico[3] = vec3(0.26286500, 0.0000000, -0.42532500);\n    ico[4] = vec3(0.0000000, 0.42532500, 0.26286500);\n    ico[5] = vec3(0.0000000, 0.42532500, -0.26286500);\n    ico[6] = vec3(0.0000000, -0.42532500, 0.26286500);\n    ico[7] = vec3(0.0000000, -0.42532500, -0.26286500);\n    ico[8] = vec3(0.42532500, 0.26286500, 0.0000000);\n    ico[9] = vec3(-0.42532500, 0.26286500, 0.0000000);\n    ico[10] = vec3(0.42532500, -0.26286500, 0.0000000);\n    ico[11] = vec3(-0.42532500, -0.26286500, 0.0000000);    \n    \n    vec2 uv = fragCoord.xy-0.5*iResolution.xy;\n    uv = 2.0*uv/iResolution.y;\n    xy = iMouse.xy/iResolution.xy;\n\n//    theTime = N*xy.x;\n//    theTime = 13.7;\n//    theTime = 14+mod(theTime, 4.0);\n\n    vec3 p = path(theTime);//ec3(-4.0, 0.0, -41.0);\n    vec3 z = normalize(path(theTime+0.5)-p);\n    mat3 m = complete(vec3(0.0, 1.0, 0.0), z);\n    vec3 d = normalize(vec3(0.5*uv, 0.75));\n    target = path(theTime+0.5);\n    d = m*d;\n    //mat4 m = view();\n    //p = (m*vec4(p, 1.0)).xyz;\n    //d = (m*vec4(d, 1.0)).xyz;\n    vec4 color = march(p, d);\n    fragColor = color;//vec4(color, 1.0);\n}\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec3 bezier(vec3 pos0, vec3 pos1, vec3 pos2, vec3 pos3, float ft) {\n    pos0 = mix(pos0, pos1, ft);\n    pos1 = mix(pos1, pos2, ft);\n    pos2 = mix(pos2, pos3, ft);\n    pos0 = mix(pos0, pos1, ft);\n    pos1 = mix(pos1, pos2, ft);\n    return mix(pos0, pos1, ft);\n}\n\nvec3 cv(int i) {\n    if (i== 0) return vec3(-3.75, -3.2, -18.0);\n    if (i== 1) return vec3(-4.25, -1.6, -14.0);\n    if (i== 2) return vec3(-5.0, -0.8, -10.0);\n    if (i== 3) return vec3(-3.0, 0.0, -9.0);\n    if (i== 4) return vec3(-4.0, 0.0, -10.0);\n    if (i== 5) return vec3(-10.0, 1.0, -8.0);\n    if (i== 6) return vec3(-10.0, 2.0, -5.0);\n    if (i== 7) return vec3(-10.0, 4.1, -2.0);\n    if (i== 8) return vec3(-9.0, 6.0, 0.3);\n    if (i== 9) return vec3(-7.5, 7.0, 0.7);\n    if (i== 10) return vec3(-6.0, 6.0, -2.0);\n    if (i== 11) return vec3(-3.5, 6.5, -5.0);//\n    if (i== 12) return vec3(-4.6, 8.0, -6.0);//\n    if (i== 13) return vec3(-3.9, 6.2, -7.0);\n    if (i== 14) return vec3(-3.3, 7.5, -8.2);//beam\n    if (i== 15) return vec3(-4.9, 6.1, -7.0);//step\n    if (i== 16) return vec3(-2.5, 3.2, -12.0);\n    if (i== 17) return vec3(-1.5, -1.0, -22.0);\n    if (i== 18) return vec3(0.5, -4.0, -21.0);\n    if (i== 19) return vec3(-2.5, -6.0, -21.0);\n    if (i== 20) return vec3(-2.3, -8.0, -19.0);\n    if (i== 21) return vec3(-3.0, -10.0, -20.0);\n    if (i== 22) return vec3(-4.0, -11.0, -21.0);\n    if (i== 23) return vec3(-2.0, -12.0, -19.0);\n    if (i== 24) return vec3(-4.0, -6.6, -18.0);\n}\n\n#define N 25\nvec3 path(float t) {\n    int it = int(floor(t));\n    it = it-N*(it/N);\n//    while (it >= N) {\n//        it -= N;\n//    }\n    float ft = fract(t);\n    vec3 qos0 = cv(it);\n    ++it;\n    if (it >= N) {\n        it = 0;\n    }\n    vec3 qos1 = cv(it);\n    ++it;\n    if (it >= N) {\n        it = 0;\n    }\n    vec3 qos2 = cv(it);\n    ++it;\n    if (it >= N) {\n        it = 0;\n    }\n    \n    // Catmull-Rom -> Bezier\n    vec3 qos3 = cv(it);\n    vec3 pos0 = 2.0*qos1;\n    vec3 pos1 = -0.333333*qos0+2.0*qos1+0.333333*qos2;\n    vec3 pos2 = 0.333333*qos1+2.0*qos2-0.333333*qos3;\n    vec3 pos3 = 2.0*qos2;\n//    pos0 = mix(pos0, pos1, ft);\n//    pos1 = mix(pos1, pos2, ft);\n//    pos2 = mix(pos2, pos3, ft);\n//    pos0 = mix(pos0, pos1, ft);\n//    pos1 = mix(pos1, pos2, ft);\n//    pos0 = mix(pos0, pos1, ft);\n    return bezier(pos0, pos1, pos2, pos3, ft);\n}\n\n","name":"Common","description":"","type":"common"}]}