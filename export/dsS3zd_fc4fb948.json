{"ver":"0.1","info":{"id":"dsS3zd","date":"1668216540","viewed":264,"name":"beveled voxels","username":"jt","description":"A beveled voxel structure - could be used to model a simple space-station or SciFi building.\nWORK IN PROGRESS. CURRENTLY PROBLEMS ON WINDOWS!\nThe structure is mostly complete but there are some gaps / errors left to fix. Also not yet optimized.","likes":13,"published":1,"flags":0,"usePreview":1,"tags":["voxels","structure","beveled","bitobj"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/dsS3zd beveled voxels 2022-11-11 by jt\n\n// A beveled voxel structure - could be used to model a simple space-station or SciFi building.\n// WORK IN PROGRESS.\n// The structure is mostly complete but there are some gaps / errors left to fix. Also not yet optimized.\n\n// Inspired by http://mathieudutour.altervista.org/UniformTiling/index.html\n// Structure number 9 (DS-18, A-17, C, W-12, J-14)\n// cuboctahedron, rhombicuboctahedra, cube, ratio 1:1:3, vertex figure 1:2:2\n// Space group Pm-3m\n// (not the exact structure but the general idea)\n\n// tags: voxels, structure, beveled, bitobj\n\n// MIT License, as in https://www.shadertoy.com/terms\n\n/*\n\nCopyright (c) 2022 Jakob Thomsen\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n\n//#define ISOMETRIC_VIEW\n\n#define pi 3.1415926\n\n#define EPSILON 0.001\n\n#define MAX_DIST 1000.0\n\n\n// https://www.shadertoy.com/view/WttXWX \"Best\" Integer Hash by FabriceNeyret2\n// implementing Chris Wellons https://nullprogram.com/blog/2018/07/31/\nuint triple32(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\nuint uhash(ivec3 v)\n{\n    if(any(greaterThan(abs(v), ivec3(2)))) return 0u;\n    return triple32(uint(v.x) + triple32(uint(v.y) + triple32(uint(v.z))));\n}\n\nbool bhash(ivec3 v)\n{\n//if(any(greaterThan(abs(v), ivec3(1)))) return false;\n    return (uhash(v) & 1u) != 0u;\n}\n\n// modified https://iquilezles.org/articles/intersectors\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 s )\n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*s;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(MAX_DIST);\n    return vec2( tN, tF );\n}\n\nfloat dot2( in vec3 v )\n{\n    return dot(v,v);\n}\n\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c ) // https://iquilezles.org/articles/distfunctions/\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat min3(float a, float b, float c)\n{\n    return min(min(a, b), c);\n}\n\n// Triangle with vertices (+1,-1,-1), (-1,+1,-1), (-1,-1,+1)\nfloat unit_cube_triangle(vec3 p) // https://www.shadertoy.com/view/dsjGDt\n{\n    float d = (p.x + p.y + p.z + 1.0) / 3.0;\n\n    if(all(greaterThan(p + 1.0, vec3(d)))) // projected point inside triangle?\n        return abs(d) * sqrt(3.0); // ...then use orthogonal distance\n\n    vec3 q = clamp(p.zxy - p.yzx,-2.0,+2.0) * 0.5;\n\n    return // ...else use distance to edges\n        min3\n        (\n            length(p + vec3(1,+q.x,-q.x)),\n            length(p + vec3(-q.y,1,+q.y)),\n            length(p + vec3(+q.z,-q.z,1))\n        );\n}\n\n/*\nfloat dot2(vec2 v)\n{\n    return dot(v,v);\n}\n\n// Triangle with vertices (+1,-1,-1), (-1,+1,-1), (-1,-1,+1)\nfloat unit_cube_triangle(vec3 p) // https://www.shadertoy.com/view/dsjGDt\n{\n    float d = (p.x + p.y + p.z + 1.0) / 3.0;\n\n    if(all(greaterThan(p + 1.0, vec3(d)))) // projected point inside triangle?\n        return abs(d) * sqrt(3.0); // ...then use orthogonal distance\n\n    vec3 q = clamp(p.zxy - p.yzx,-2.0,+2.0) * 0.5;\n\n    return // ...else use distance to edges\n        sqrt(min3\n        (\n            dot2(p + vec3(1,+q.x,-q.x)),\n            dot2(p + vec3(-q.y,1,+q.y)),\n            dot2(p + vec3(+q.z,-q.z,1))\n        ));\n}\n*/\nfloat cube_triangle(vec3 p, float r)\n{\n    return unit_cube_triangle(p/r)*r;\n}\n\nfloat half_unit_square_triangle(vec2 p, float s) // https://www.shadertoy.com/view/ddfGD7\n{\n    p = (p.x > p.y) ? p.xy : p.yx;\n    float h = min((p.x - p.y + s)/2.0, s);\n    vec2  a = vec2(p.x - h, p.y + h - s);\n    vec2  b = vec2(p.x - clamp(p.x, 0.0, s), p.y);\n    vec2  d = min(vec2(dot(a, a), s - p.x - p.y),\n                  vec2(dot(b, b), p.y));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat half_unit_square_triangle(vec3 p, float s)\n{\n    float d = half_unit_square_triangle(p.xy, s);\n    // extrusion https://iquilezles.org/articles/distfunctions/\n    vec2 w = vec2(d, abs(p.z));\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat box( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat rounded_box(vec3 p, vec3 b, float r) // rounded box keeping face-distances\n{\n    return box(p, b - r) - r;\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat open_cylinder(vec3 p, float r)\n{\n    return length(p.xy) - r;\n}\n\nfloat halfspace(vec3 p)\n{\n    return p.z;\n}\n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    return length(pa - ba*h);\n}\n/*\nfloat diagonal(vec3 p, float g, float h)\n{\n    float d = line(p.xy, vec2(-g),vec2(+g));\n    vec2 w = vec2(d, abs(p.z) - h);\n    return min(max(w.x,w.y), 0.0) + length(max(w, 0.0));\n}\n*/\nfloat diagonal_x(vec3 p, float offset, vec2 a, vec2 b, float h)\n{\n    p.x += offset;\n    float d = line(p.yz, a, b);\n    vec2 w = vec2(d, abs(p.x) - h);\n    return min(max(w.x,w.y), 0.0) + length(max(w, 0.0));\n}\n\nfloat diagonal_y(vec3 p, float offset, vec2 a, vec2 b, float h)\n{\n    p.y += offset;\n    float d = line(p.zx, a, b);\n    vec2 w = vec2(d, abs(p.y) - h);\n    return min(max(w.x,w.y), 0.0) + length(max(w, 0.0));\n}\n\nfloat diagonal_z(vec3 p, float offset, vec2 a, vec2 b, float h)\n{\n    p.z += offset;\n    float d = line(p.xy, a, b);\n    vec2 w = vec2(d, abs(p.z) - h);\n    return min(max(w.x,w.y), 0.0) + length(max(w, 0.0));\n}\n\nfloat test(vec3 p)\n{\n    return abs(p.x+p.y+p.z)/sqrt(3.0);\n}\n\nvec2 Union(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nvec2 Intersect(vec2 a, vec2 b)\n{\n    return a.x > b.x ? a : b;\n}\n\nvec2 structure(vec3 p, ivec3 cell) // returns distance & material\n{\n    //float r = 0.25;\n    float r = mix(0.25, 0.5, 0.5 + 0.5 * cos(iTime));\n    float s = 1.0 - r;\n\n    vec2 res = vec2(MAX_DIST, 0.0);\n\n    bvec3 octant = bvec3(cell & 1);\n    cell = cell >> 1;\n\n    float guard = box(p-vec3(0,0,0), vec3(0.5));\n\n    ivec4 o = ivec4(2*ivec3(octant)-1, 0);\n    bvec3 nb1 = bvec3(bhash(cell+o.xww), bhash(cell+o.wyw), bhash(cell+o.wwz));\n    bvec3 nb2 = bvec3(bhash(cell+o.wyz), bhash(cell+o.xwz), bhash(cell+o.xyw));\n\n    bool center = bhash(cell+o.www); // could be included in nb1\n    bool opposite = bhash(cell+o.xyz); // could be included in nb2\n\n    if(center) // full\n    {\n        nb1 = not(nb1);\n        nb2 = not(nb2);\n        opposite = !opposite;\n        //res = Union(res, vec2(sphere(p, 0.5), 0.0));\n    }\n\n    // other triangles\n    if(nb1.x && !nb1.y && nb1.z && nb2.x && nb2.y && !nb2.z)\n//        res = Union(res, vec2(udTriangle(vec3(o)*s*0.5-p, vec3(-r,r,r)*vec3(o)*0.5, vec3(r,r,-r)*vec3(o)*0.5, vec3(-r,-r,-r)*vec3(o)*0.5) - 0.01, 0.2));\n        res = Union(res, vec2(cube_triangle((s*0.5-vec3(o)*p)*vec3(+1,-1,+1), r*0.5) - 0.01, 0.2));\n\n    if(!nb1.x && nb1.y && nb1.z && nb2.x && nb2.y && !nb2.z)\n//        res = Union(res, vec2(udTriangle(vec3(o)*s*0.5-p, vec3(r,-r,r)*vec3(o)*0.5, vec3(r,r,-r)*vec3(o)*0.5, vec3(-r,-r,-r)*vec3(o)*0.5) - 0.01, 0.2));\n        res = Union(res, vec2(cube_triangle((s*0.5-vec3(o)*p)*vec3(-1,+1,+1), r*0.5) - 0.01, 0.2));\n\n    if(!nb1.x && !nb1.y && nb1.z && nb2.x && !nb2.y && /*!nb2.z &&*/ opposite)\n        res = Union(res, vec2(udTriangle(vec3(o)*s*0.5-p, vec3(r,-r,-r)*vec3(o)*0.5, vec3(r,r,-r)*vec3(o)*0.5, vec3(-r,-r,-r)*vec3(o)*0.5) - 0.01, 0.2));\n\n    if(!nb1.x && !nb1.y && nb1.z && !nb2.x && nb2.y && !nb2.z && opposite)\n        res = Union(res, vec2(udTriangle(vec3(o)*s*0.5-p, vec3(-r,r,-r)*vec3(o)*0.5, vec3(r,r,-r)*vec3(o)*0.5, vec3(-r,-r,-r)*vec3(o)*0.5) - 0.01, 0.2));\n\n\n    if(nb1.x && nb1.y && !nb1.z && nb2.x && !nb2.y && nb2.z)\n//        res = Union(res, vec2(udTriangle(vec3(o)*s*0.5-p, vec3(-r,r,r)*vec3(o)*0.5, vec3(r,-r,r)*vec3(o)*0.5, vec3(-r,-r,-r)*vec3(o)*0.5) - 0.01, 0.2));\n        res = Union(res, vec2(cube_triangle((s*0.5-vec3(o)*p)*vec3(+1,+1,-1), r*0.5) - 0.01, 0.2));\n\n    if(!nb1.x && nb1.y && nb1.z && nb2.x && !nb2.y && nb2.z)\n//        res = Union(res, vec2(udTriangle(vec3(o)*s*0.5-p, vec3(r,r,-r)*vec3(o)*0.5, vec3(r,-r,r)*vec3(o)*0.5, vec3(-r,-r,-r)*vec3(o)*0.5) - 0.01, 0.2));\n        res = Union(res, vec2(cube_triangle((s*0.5-vec3(o)*p)*vec3(-1,+1,+1), r*0.5) - 0.01, 0.2));\n\n    if(!nb1.x && nb1.y && !nb1.z && !nb2.x && /*!nb2.y &&*/ nb2.z && opposite)\n        res = Union(res, vec2(udTriangle(vec3(o)*s*0.5-p, vec3(-r,-r,r)*vec3(o)*0.5, vec3(r,-r,r)*vec3(o)*0.5, vec3(-r,-r,-r)*vec3(o)*0.5) - 0.01, 0.2));\n\n    if(!nb1.x && nb1.y && !nb1.z && nb2.x && !nb2.y && !nb2.z && opposite)\n        res = Union(res, vec2(udTriangle(vec3(o)*s*0.5-p, vec3(r,-r,-r)*vec3(o)*0.5, vec3(r,-r,r)*vec3(o)*0.5, vec3(-r,-r,-r)*vec3(o)*0.5) - 0.01, 0.2));\n\n\n    if(nb1.x && nb1.y && !nb1.z && !nb2.x && nb2.y && nb2.z)\n//        res = Union(res, vec2(udTriangle(vec3(o)*s*0.5-p, vec3(-r,r,r)*vec3(o)*0.5, vec3(r,-r,r)*vec3(o)*0.5, vec3(-r,-r,-r)*vec3(o)*0.5) - 0.01, 0.2));\n        res = Union(res, vec2(cube_triangle((s*0.5-vec3(o)*p)*vec3(+1,+1,-1), r*0.5) - 0.01, 0.2));\n\n    if(nb1.x && !nb1.y && nb1.z && !nb2.x && nb2.y && nb2.z)\n//        res = Union(res, vec2(udTriangle(vec3(o)*s*0.5-p, vec3(-r,r,r)*vec3(o)*0.5, vec3(r,r,-r)*vec3(o)*0.5, vec3(-r,-r,-r)*vec3(o)*0.5) - 0.01, 0.2));\n        res = Union(res, vec2(cube_triangle((s*0.5-vec3(o)*p)*vec3(+1,-1,+1), r*0.5) - 0.01, 0.2));\n\n    if(nb1.x && !nb1.y && !nb1.z && /*!nb2.x &&*/ !nb2.y && nb2.z && opposite)\n        res = Union(res, vec2(udTriangle(vec3(o)*s*0.5-p, vec3(-r,r,r)*vec3(o)*0.5, vec3(-r,-r,r)*vec3(o)*0.5, vec3(-r,-r,-r)*vec3(o)*0.5) - 0.01, 0.2));\n\n    if(nb1.x && !nb1.y && !nb1.z && !nb2.x && nb2.y && !nb2.z && opposite)\n        res = Union(res, vec2(udTriangle(vec3(o)*s*0.5-p, vec3(-r,r,r)*vec3(o)*0.5, vec3(-r,r,-r)*vec3(o)*0.5, vec3(-r,-r,-r)*vec3(o)*0.5) - 0.01, 0.2));\n\n\n  //  if(nb1.y && nb1.z && !nb1.x)\n//        res = Union(res, vec2(udTriangle(vec3(o)*s*0.5-p, vec3(-r,r,r)*vec3(o)*0.5, vec3(r,-r,r)*vec3(o)*0.5, vec3(-r,-r,-r)*vec3(o)*0.5) - 0.01, 14.0));\n\n    // center patch\n    if(nb1.z && !nb1.y && !nb1.x && !nb2.z && nb2.y && nb2.x) res = Union(res, vec2(box(p+0.5*vec3(-s,-s,-1)*vec3(o),0.5*vec3(r,r,0)) - 0.01, 0.66));\n    if(nb1.y && !nb1.x && !nb1.z && !nb2.y && nb2.x && nb2.z) res = Union(res, vec2(box(p+0.5*vec3(-s,-1,-s)*vec3(o),0.5*vec3(r,0,r)) - 0.01, 0.66));\n    if(nb1.x && !nb1.z && !nb1.y && !nb2.x && nb2.z && nb2.y) res = Union(res, vec2(box(p+0.5*vec3(-1,-s,-s)*vec3(o),0.5*vec3(0,r,r)) - 0.01, 0.66));\n\n    // intermediate wall\n    if(nb1.x && nb2.z && !nb1.y) res = Union(res, vec2(box(p+0.5*vec3(-1,-s,r)*vec3(o),0.5*vec3(0,r,s)) - 0.01, 0.9));\n    if(nb1.y && nb2.x && !nb1.z) res = Union(res, vec2(box(p+0.5*vec3(r,-1,-s)*vec3(o),0.5*vec3(s,0,r)) - 0.01, 0.9));\n    if(nb1.z && nb2.y && !nb1.x) res = Union(res, vec2(box(p+0.5*vec3(-s,r,-1)*vec3(o),0.5*vec3(r,s,0)) - 0.01, 0.9));\n    if(nb1.x && nb2.y && !nb1.z) res = Union(res, vec2(box(p+0.5*vec3(-1,r,-s)*vec3(o),0.5*vec3(0,s,r)) - 0.01, 0.9));\n    if(nb1.y && nb2.z && !nb1.x) res = Union(res, vec2(box(p+0.5*vec3(-s,-1,r)*vec3(o),0.5*vec3(r,0,s)) - 0.01, 0.9));\n    if(nb1.z && nb2.x && !nb1.y) res = Union(res, vec2(box(p+0.5*vec3(r,-s,-1)*vec3(o),0.5*vec3(s,r,0)) - 0.01, 0.9));\n\n    // wall\n    if(nb1.x) res = Union(res, vec2(box(p+0.5*vec3(-1,r,r)*vec3(o), 0.5*vec3(0,s,s)) - 0.01, 0.1));\n    if(nb1.y) res = Union(res, vec2(box(p+0.5*vec3(r,-1,r)*vec3(o), 0.5*vec3(s,0,s)) - 0.01, 0.1));\n    if(nb1.z) res = Union(res, vec2(box(p+0.5*vec3(r,r,-1)*vec3(o), 0.5*vec3(s,s,0)) - 0.01, 0.1));\n\n    // beveled walls\n    if(nb1.y && nb1.z) res = Union(res, vec2(diagonal_x(p, 0.5*r*float(o.x),0.5*vec2(s+r,s-r)*vec2(o.yz),0.5*vec2(s-r,s+r)*vec2(o.yz), 0.5*s) - 0.01, 0.2));\n    if(nb1.z && nb1.x) res = Union(res, vec2(diagonal_y(p, 0.5*r*float(o.y),0.5*vec2(s+r,s-r)*vec2(o.zx),0.5*vec2(s-r,s+r)*vec2(o.zx), 0.5*s) - 0.01, 0.2));\n    if(nb1.x && nb1.y) res = Union(res, vec2(diagonal_z(p, 0.5*r*float(o.z),0.5*vec2(s+r,s-r)*vec2(o.xy),0.5*vec2(s-r,s+r)*vec2(o.xy), 0.5*s) - 0.01, 0.2));\n\n    // intermediate beveled walls\n    if(!nb1.x && nb1.y && nb1.z && nb2.x && nb2.y && nb2.z /*&& opposite*/)\n       res = Union(res, vec2(diagonal_x(p,-0.5*s*float(o.x),0.5*vec2(s+r,s-r)*vec2(o.yz),0.5*vec2(s-r,s+r)*vec2(o.yz), 0.5*r) - 0.01, 0.3));\n    if(nb1.x && !nb1.y && nb1.z && nb2.x && nb2.y && nb2.z /*&& opposite*/)\n       res = Union(res, vec2(diagonal_y(p,-0.5*s*float(o.y),0.5*vec2(s+r,s-r)*vec2(o.zx),0.5*vec2(s-r,s+r)*vec2(o.zx), 0.5*r) - 0.01, 0.3));\n    if(nb1.x && nb1.y && !nb1.z && nb2.x && nb2.y && nb2.z /* && opposite*/)\n       res = Union(res, vec2(diagonal_z(p,-0.5*s*float(o.z),0.5*vec2(s+r,s-r)*vec2(o.xy),0.5*vec2(s-r,s+r)*vec2(o.xy), 0.5*r) - 0.01, 0.3));\n\n    // inout triangles\n    //if(nb1.x && nb1.y && !nb1.z && !nb2.x && !nb2.y && nb2.z) res = Union(res, vec2(udTriangle(vec3(o)*s*0.5-p, vec3(-r,r,r)*vec3(o)*0.5, vec3(r,-r,r)*vec3(o)*0.5, vec3(-r,-r,-r)*vec3(o)*0.5) - 0.01, 14.0));\n    if(nb1.x && nb1.y && !nb1.z && !nb2.x && !nb2.y && nb2.z) res = Union(res, vec2(cube_triangle((s*0.5-vec3(o)*p)*vec3(+1,+1,-1), r*0.5) - 0.01, 0.0));\n    //if(nb1.x && !nb1.y && nb1.z && !nb2.x && nb2.y && !nb2.z) res = Union(res, vec2(udTriangle(vec3(o)*s*0.5-p, vec3(-r,r,r)*vec3(o)*0.5, vec3(-r,-r,-r)*vec3(o)*0.5, vec3(r,r,-r)*vec3(o)*0.5) - 0.01, 14.0));\n    if(nb1.x && !nb1.y && nb1.z && !nb2.x && nb2.y && !nb2.z) res = Union(res, vec2(cube_triangle((s*0.5-vec3(o)*p)*vec3(+1,-1,+1), r*0.5) - 0.01, 0.0));\n    //if(!nb1.x && nb1.y && nb1.z && nb2.x && !nb2.y && !nb2.z) res = Union(res, vec2(udTriangle(vec3(o)*s*0.5-p, vec3(r,-r,r)*vec3(o)*0.5, vec3(-r,-r,-r)*vec3(o)*0.5, vec3(r,r,-r)*vec3(o)*0.5) - 0.01, 14.0));\n    if(!nb1.x && nb1.y && nb1.z && nb2.x && !nb2.y && !nb2.z) res = Union(res, vec2(cube_triangle((s*0.5-vec3(o)*p)*vec3(-1,+1,+1), r*0.5) - 0.01, 0.0));\n\n    // triangular corners\n    //if(all(nb1)) res = Union(res, vec2(udTriangle(vec3(o)*s*0.5-p, vec3(-r,r,r)*vec3(o)*0.5, vec3(r,-r,r)*vec3(o)*0.5, vec3(r,r,-r)*vec3(o)*0.5) - 0.01, 0.5));\n    if(all(nb1)) res = Union(res, vec2(cube_triangle(-s*0.5+vec3(o)*p, r*0.5) - 0.01, 0.5));\n\n    return res;\n}\n\nfloat checker(vec3 p)\n{\n    //return step(0.5, length(1.0 - abs(2.0 * fract(p) - 1.0))); // dots\n    return step(0.0, sin(pi * p.x + pi/2.0)*sin(pi *p.y + pi/2.0)*sin(pi *p.z + pi/2.0));\n    //return step(0.0, sin(p.x)*sin(p.y)*sin(p.z));\n}\n\nmat2 rotate(float t)\n{\n    return mat2(vec2(cos(t), sin(t)), vec2(-sin(t), cos(t)));\n}\n\n#define MAX_ITER 50u // make sure not to stall when ray passes very close parallel to a surface\n\n// raymarch subobject\nvec2 march(vec3 ro, vec3 rd, float tmin, float tmax, ivec3 cell)\n{\n    float t;\n    uint i;\n    for(t = tmin, i = 0u; t < tmax && i < MAX_ITER; i++)\n    {\n        vec2 res = structure(ro + rd * t, cell);\n        if(res.x < EPSILON)\n            return vec2(t, res.y);\n        t += res.x;\n    }\n    return vec2(MAX_DIST, 0.0);\n}\n\n// based on https://iquilezles.org/articles/normalsSDF tetrahedron normals\nvec3 normal(vec3 p, ivec3 cell)\n{\n    const float h = EPSILON;\n    const vec2 k = vec2(1,-1);\n    return normalize(k.xyy * structure(p + k.xyy * h, cell).x +\n                     k.yyx * structure(p + k.yyx * h, cell).x +\n                     k.yxy * structure(p + k.yxy * h, cell).x +\n                     k.xxx * structure(p + k.xxx * h, cell).x);\n}\n\n// voxel with environment (3x3x3) slow!\nfloat sdMixedWithEnv(ivec3 cell, vec3 offset)\n{\n    float d = MAX_DIST;\n    // naive method: 3x3x3 voxels\n    for(int z = -1; z <= +1; z++)\n    {\n        for(int y = -1; y <= +1; y++)\n        {\n            for(int x = -1; x <= +1; x++)\n            {\n\n    // kastorp's optimization: traverse only 2x2 tiles (instead of 3x3),\n    // chosen depending on where in the tile the current point is located.\n    //ivec3 oo = -ivec3(step(vec3(0), offset));\n    //for(int z = oo.y; z <= oo.z+1; z++)\n    //{\n    //    for(int y = oo.y; y <= oo.y+1; y++)\n    //    {\n    //        for(int x = oo.x; x <= oo.x+1; x++)\n    //        {\n                d = min(d, structure(offset - vec3(x, y, z), cell + ivec3(x, y, z)).x);\n            }\n        }\n    }\n    return d;\n}\n\n// https://www.shadertoy.com/view/Xds3zN Raymarching - Primitives by iq\n// https://iquilezles.org/articles/distfunctions\nfloat calcAO(vec3 pos, vec3 nor)\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 5; i++)\n    {\n        float h = 0.01 + 0.12*float(i) / 4.0;\n        ivec3 cell = ivec3(floor(pos + h*nor));\n        //uint id = getVoxelIndex(cell);\n        //float d = SDF_Voxel(pos + h*nor - vec3(cell) - vec3(0.5), id);\n        float d = sdMixedWithEnv(cell, pos + h*nor - vec3(cell) - vec3(0.5));\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if(occ > 0.35) break;\n    }\n    return clamp(1.0 - 3.0*occ, 0.0, 1.0);\n}\n\n#define MAX_GRID_STEPS 64\n\nstruct result\n{\n    float dist;\n    ivec3 cell;\n    float material;\n};\n\nresult voxelray(vec3 ro, vec3 rd, ivec3 ext)\n{\n    result res;\n/*\n    {\n        vec2 bounds = boxIntersection(ro-0.5, rd, vec3(ext)+0.5); // bounding box\n        if(bounds.x < MAX_DIST)\n        {\n            ro += rd * bounds.x;\n        }\n        else\n        {\n            res.dist = 1.0;\n            res.material = 10.0;\n            return res;\n        }\n    }\n*/\n    vec3 dd = 1.0 / abs(rd);\n    ivec3 rs = ivec3(sign(rd));\n    res.dist = MAX_DIST;\n    res.cell = ivec3(floor(ro));\n    res.material = 0.0;\n\n    vec3 sd = (sign(rd) * (vec3(res.cell) - ro) + (sign(rd) * 0.5) + 0.5) * dd; // Setup of https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting\n\n    for (int i = 0; i < MAX_GRID_STEPS; i++)\n    //for (int i = min(iFrame,0); i < MAX_RAY_STEPS; i++) // prevent unrolling loop to avoid crash on some systems\n    {\n        //if (any(greaterThan(sign(rd) * vec3(res.cell), vec3(ext)))) break; // proceed until ray LEAVES level-box (but ENTER is OK, so level can be seen from outside)\n        if(all(lessThanEqual(abs(res.cell), ivec3(ext)))) // inside (odd)\n        //if(all(greaterThanEqual(res.cell, -ext)) && all(lessThan(res.cell, ext))) // inside (even)\n        {\n            //uint idx = getIdx(res.cell);\n            //if(idx > 0u) // skip empty voxels\n            {\n                // Near bounding-box side can be reconstructed from dda, howvever we need far bounding-box side, too.\n                // float d = length(vec3(mask) * (sideDist - deltaDist)) / length(rayDir);\n                // It appears to be easier to just do the box-intersection here (potential for optimization).\n                vec2 bounds = boxIntersection( ro - vec3(res.cell) - vec3(0.5), rd, vec3(0.5) ); // bounding box\n\n                //if(idx != 0u)\n                {\n                    vec2 r = march(ro - vec3(res.cell) - vec3(0.5), rd, bounds.x, bounds.y, res.cell);\n\n                    if(r.x >= bounds.x && r.x <= bounds.y)\n                    {\n                        if(r.x >= 0.0) // required to catch corner-cases when ray starts in wall behind camera (duplicate close objects bug)\n                        {\n                            res.dist = r.x;\n                            res.material = r.y;\n\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        //else\n        //    return res;\n\n        // \"The raycasting code is somewhat based around a 2D raycasting toutorial found here:\n        //  http://lodev.org/cgtutor/raycasting.html\" (fb39ca4)\n        // Core of https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting\n        bvec3 mask = lessThanEqual(sd.xyz, min(sd.yzx, sd.zxy));\n        sd += vec3(mask) * dd;\n        res.cell += ivec3(vec3(mask)) * rs;\n    }\n\n    return res;\n}\n\n// Coordinate-systems:\n//  * camera-coordinates: x,y aligned with screen, z towards viewer\n//  * world-coordinates: map-on-table, i.e. x,y on the map with additional z-coordinate for height\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 ndc = 2.0 * uv - 1.0;\n    ndc.x *= float(iResolution.x) / float(iResolution.y);\n    float mx = 2.0 * pi * float(iMouse.x) / float(iResolution.x);\n    float my = pi - pi * float(iMouse.y) / float(iResolution.y);\n    mx = (iMouse.x > 10.0) ? mx : 2.0 * pi * fract(iTime * 0.05);\n    my = (iMouse.y > 10.0) ? my : 1.25*pi / 2.0;\n\n    vec3 ro = vec3(0);\n    vec3 rd = vec3(0);\n#ifdef ISOMETRIC_VIEW\n    {\n        float zoom = 5.0;\n        ro = 10.0+zoom*(vec3(+1,-1,0)*ndc.x+vec3(-1,-1,1)*ndc.y);\n        rd = normalize(-vec3(1,1,1));\n        // NOTE: rotation looks wrong in isometric view due to lack of perspective\n        mat3 yaw = mat3(vec3(cos(mx), sin(mx),0.0), vec3(-sin(mx), cos(mx),0.0),vec3(0,0,1));\n        ro = yaw * ro;\n        rd = yaw * rd;\n    }\n#else\n    {\n        ro = vec3(0.0, 0.0, -10.5);\n        mat2 yaw = mat2(vec2(cos(mx), sin(mx)), vec2(-sin(mx), cos(mx)));\n        mat2 pitch = mat2(vec2(cos(my), sin(my)), vec2(-sin(my), cos(my)));\n        ro.yz = pitch * ro.yz;\n        ro.xy = yaw * ro.xy;\n        rd = normalize(vec3(0.5 * ndc.xy, 1.0)); // NOTE: omitting normalization results in clipped edges artifact\n        rd.yz = pitch * rd.yz;\n        rd.xy = yaw * rd.xy;\n    }\n#endif\n    ro += 0.5; // center odd grid\n    ivec3 ext = ivec3(7,7,7);\n\n    vec3 color = vec3(0.0);\n/*\n    {\n        vec2 bounds = boxIntersection(ro-0.5, rd, vec3(ext)+0.5); // bounding box\n        if(bounds.x < MAX_DIST)\n        {\n            ro += rd * bounds.x;\n        }\n        else\n        {\n            fragColor = vec4(0,0,0.5,1.0);\n            return;\n        }\n    }\n*/\n    result res = voxelray(ro, rd, ext);\n    /*\n    {\n        // p.z = o.z+d.z*t\n        // p.z-o.z = d.z*t\n        // (p.z-o.z)/d.z = t\n        float t = (0.5-ro.z)/rd.z;\n        if(t < res.dist)\n        {\n            res.dist = t;\n            res.material = 5.0;\n        }\n    }\n    */\n    if(res.dist < MAX_DIST)\n    {\n        vec3 lightdir = normalize(vec3(1.0,-2.0, 3.0));\n\n        vec3 dst = ro + rd * res.dist;\n\n        vec3 n = normal(dst - vec3(res.cell) - vec3(0.5), res.cell);\n\n        //color = vec3(1.0); // plain\n        //color = 0.5 + 0.5 * normalize(result.xyz); // normal colors\n        color = 0.5 + 0.5 * sin(2.0 * pi * (res.material + vec3(0.0, 1.0, 2.0)/3.0));\n\n        float diffuse = max(dot(lightdir, n), 0.0);\n        vec3 hal = normalize(lightdir - rd);\n        float specular = pow(clamp( dot(n, hal), 0.0, 1.0), 16.0);\n             specular *= diffuse;\n             specular *= 0.04+0.96*pow(clamp(1.0-dot(hal,lightdir),0.0,1.0),5.0);\n        color += 5.0 * specular * vec3(1.30,1.00,0.70);\n\n        color *= vec3(0.5 + 0.5 * checker(dst));\n\n        //vec3 fogcolor = vec3(0.25, 0.4, 0.5); // fog\n        //vec3 fogcolor = vec3(0.75, 0.6, 0.3); // smog\n      //color *= mix(fogcolor, color, exp(-res.dist * res.dist / 200.0)); // fog for depth impression & to suppress flickering\n\n        //float ao = calcAO(ro + rd * res.dist, n);\n        float ao = 1.0; // disabled\n        result shadow = voxelray(dst+0.01*n, lightdir, ext);\n        float brightness = 0.1 * ao + diffuse * step(MAX_DIST, shadow.dist);\n\n        color *= brightness;\n    }\n\n    fragColor.rgb = sqrt(color);\n}\n","name":"Image","description":"","type":"image"}]}