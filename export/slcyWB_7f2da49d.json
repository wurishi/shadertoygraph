{"ver":"0.1","info":{"id":"slcyWB","date":"1660446119","viewed":134,"name":"d12 madness 2","username":"pb","description":"one more version of the d12 system starting from the outside and working in","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["fractal","ifs","dodecahedron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//philip.bertani@gmail.com\n//Gaussian blur here instead of casting more rays for antialiasing\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    //size of one texel in iChannel0\n    vec2 texel = 1./iResolution.xy;\n\n    vec4 total_color;\n    //see 5x5 gaussian weights in Common \n    for (int i=0;i<5;i++){\n        float fi = float(i)-2.;\n        for (int j=0;j<5;j++){ \n            float fj = float(j)-2.;\n            vec4 color = texture(iChannel0, \n                uv + vec2( texel.x*fi,texel.y*fj )  );\n            total_color += color * gkhs[i*5 + j];\n        }\n    }\n    \n    fragColor = total_color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//philip.bertani@gmail.com\n\n#define PI 3.14159265\n\nint   max_iter;\nvec3  ifs_color;\nfloat ifs_scale;\n\nvec3 ambientL  = vec3(.2,.2,.3);\nvec3 diffuseL  = vec3(.4,.4,.5);\nvec3 specularL = vec3(.8,.8,0.);\nvec3 ambdir    = normalize(vec3(-.2,.4,0.));\n\n\nstruct RAYMARCH_RESULT {\n    vec3  raypos;\n    float dist_from_origin;\n    float object_id;\n};\n\n\nvec3  light_pos;\nvec2  myMouse;\nvec3  ro,rd;\nfloat threshold;\nvec3  adj_p;\nmat3  rot;\n\nmat3 rot_xz(float an) {\n    float cc = cos(an), ss=sin(an);\n    return mat3(cc,0.,ss,0.,1.,0.,-ss,0.,cc);\n\n}\n\nvec2 dist_func01(vec3 z) {\n    \n    vec3 min_vtx;\n    vec3 orig_z = z;\n    int n=0;\n    float min_dist,dist_to_vtx;\n\n    ifs_color = vec3(0.);\n\n    for (int i=0; i<30; i++) {\n       \n        if ( i > max_iter ) break;\n\n        vec3 dd_0 = d12[0];\n        min_vtx = dd_0;\n        min_dist=length(z-dd_0);\n        for (int j=1; j<20; j++) {\n            vec3 ddj = d12[j];\n            dist_to_vtx=length(z-ddj); \n            if (dist_to_vtx<min_dist) {min_vtx=ddj; min_dist=dist_to_vtx;}\n            \n        }\n        \n        z = min_vtx + ifs_scale*(z-min_vtx);\n        \n        n++;\n\n        //potentially interesting colors\n        \n        if ( z.x * z.y > 0. ) ifs_color.x ++;\n        if ( z.y * z.z > 0. ) ifs_color.y ++;\n        if ( z.z * z.x > 0. ) ifs_color.z ++;\n        \n        \n    }\n\n    ifs_color /= float(n);\n\n    float dz = pow(ifs_scale, float(n) );\n    //dz is simply the constant Scale factor to the power of number of times used\n\n    float scene_dist = length(z) / dz;  \n    float objid = 0.;\n\n    //tunnelling through when we are close enough\n    scene_dist = max( scene_dist, -(length(orig_z-ro) - .01) );\n    \n    return vec2( scene_dist, objid );\n}\n\n\n\nvec3 estimate_normal_vec( vec3 pos, float neps, float dist ) {\n\n    \n    float norm_sign = 1.; \n\n    vec2  np = norm_sign * vec2( 1., -1);\n\n    float neps_final = neps * (1.+dist*60.);\n    vec2  dp = vec2( neps_final, -neps_final);\n   \n    vec3 df1 = np.xxx * dist_func01( pos + dp.xxx ).x;\n    vec3 df2 = np.xyy * dist_func01( pos + dp.xyy ).x;\n    vec3 df3 = np.yxy * dist_func01( pos + dp.yxy ).x;\n    vec3 df4 = np.yyx * dist_func01( pos + dp.yyx ).x;\n    \n    \n    return normalize( df1 + df2 + df3 + df4 );\n\n}\n\n\nRAYMARCH_RESULT raymarch( vec3 ro, vec3 rd, float eps, float initial_object_id ) {\n\n    float dist_from_origin = 0.; \n    vec3 raypos = ro;\n    RAYMARCH_RESULT result;\n    result.object_id = initial_object_id; \n    result.dist_from_origin = 0.;\n   \n    float init_threshold = eps;\n    threshold = init_threshold;\n    \n    for (int i=0; i<300; i++) {\n    \n        vec3 raypos = ro + dist_from_origin * rd;\n        vec2 dist_to_closest = dist_func01(raypos);\n        \n        if ( dist_to_closest.x < threshold ) {\n        \n            result.object_id = dist_to_closest.y;\n            result.raypos = raypos;\n            result.dist_from_origin = dist_from_origin;\n            \n            adj_p = raypos - 2.*abs(dist_to_closest.x-threshold)*rd;\n            \n            break;\n        }\n        \n        if ( dist_from_origin > 1. ) {\n            result.object_id = -10.;\n            break;\n        }\n\n\n        dist_from_origin += .8*dist_to_closest.x;\n        \n        raypos += dist_from_origin*rd;\n        \n        threshold = init_threshold*(1.+dist_from_origin*30.);\n        \n    }\n       \n    return result;\n    \n}\n\nvec3  main_loop( vec3 ro, vec3 rd ) {\n    \n    RAYMARCH_RESULT prime_ray = raymarch( ro, rd, 4e-4, 100. );\n    \n    vec3 color = vec3(0.);\n    \n    if (prime_ray.object_id > -1. ) { \n    \n        vec3 nn = estimate_normal_vec( adj_p, 1e-5, prime_ray.dist_from_origin);\n        \n        vec3 lt_pos = light_pos;   \n        float spec_pow = 32.; \n        float spec_amp = 4.;\n        \n\n        vec3 view_dir = rd;\n        vec3 light_dir = normalize(lt_pos-prime_ray.raypos); \n        float diffuse_light = clamp(dot(light_dir, nn), 0., 1.);\n        float ambient_light =  -dot(nn, ambdir);\n     \n        vec3 refl=reflect(view_dir,nn);\n        float specular_light=pow(max(dot(refl,light_dir),0.0),spec_pow);\n        \n        vec3 fractal_color = cos( vec3(ifs_color.x * 2.,\n                                       ifs_color.y * 3., \n                                       ifs_color.z * 2. ) );\n        \n        fractal_color  = vec3( fractal_color.x*vec3(0.,1.,1.) \n                              +fractal_color.y*vec3(1.,0.,1.)\n                              +fractal_color.z*vec3(1.,1.,0.) );\n        \n        //give a hint at what happens during function iteration\n        fractal_color = pow(fractal_color,vec3(2.) );\n        \n        {\n            color = ambient_light  * ambientL + \n                diffuse_light  * (2.*diffuseL-.3*fractal_color)  +\n                spec_amp*specular_light * specularL;\n        }       \n\n\n        color *= exp(-prime_ray.dist_from_origin*prime_ray.dist_from_origin*5.) ;       \n                   \n    }\n\n\n    return clamp(color, 0., 1.);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n      \n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y*2.;\n    \n    float myTime = mod(iTime,100.);\n    \n\n    rot = rot_xz(PI/4.);\n    \n    max_iter = 17;\n    \n    ro = vec3(.08,0., -.1)  ;\n    rd = rot * normalize( vec3(uv, 2.) ); \n    \n\n    if (myTime < 4.) {\n        ifs_scale = 1.001;\n        ro += myTime/100.*rot[2];     \n    }\n   \n    else {\n        float myTime2 = myTime - 4.;\n        \n        ro += 4./100.*rot[2];\n        \n        if (myTime2 > 3. ) rot = rot_xz(PI/4.-(myTime2-3.)/10.);\n        \n\n        {\n            ifs_scale = 1.001 + min(.007*myTime2,.08);\n        }\n        ro += 1.1*sin(myTime2/25.) * rot[2];\n    }\n        \n    \n    light_pos = ro -  .3*rot[2] + .5* rot[0] + .3*rot[1];\n    \n    \n    vec3 color = main_loop(ro, rd);\n \n    fragColor = vec4(color,1.);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//gaussian_kernel_half_stdev\nfloat[] gkhs = float[] (\n        0.000002,0.000212,0.000922,0.000212,0.000002,\n        0.000212,0.024745,0.107391,0.024745,0.000212,\n        0.000922,0.107391,0.466066,0.107391,0.000922,\n        0.000212,0.024745,0.107391,0.024745,0.000212,\n        0.000002,0.000212,0.000922,0.000212,0.000002 );\n        \n        \n\n//hard coding the vertices for a dodecahedron\nconst float gmh=(sqrt(5.)+1.)/2.;\nconst float gmi=1./gmh;\n\nvec3[] d12 = vec3[]  (\nvec3(1.,1.,1.),\nvec3(1.,1.,-1.),\nvec3(1.,-1,1.),\nvec3(1.,-1,-1.),\nvec3(-1,1.,1.),\nvec3(-1.,1.,-1),\nvec3(-1.,-1.,1.),\nvec3(-1.,-1.,-1.),\nvec3(0.,gmh,gmi),\nvec3(0.,gmh,-gmi),\nvec3(0.,-gmh,gmi),\nvec3(0.,-gmh,-gmi),\nvec3(gmi,0.,gmh),\nvec3(gmi,0.,-gmh),\nvec3(-gmi,0.,gmh),\nvec3(-gmi,0.,-gmh),\nvec3(gmh,gmi,0.),\nvec3(gmh,-gmi,0.),\nvec3(-gmh,gmi,0.),\nvec3(-gmh,-gmi,0.)\n);\n","name":"Common","description":"","type":"common"}]}