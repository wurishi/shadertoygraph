{"ver":"0.1","info":{"id":"7dByWK","date":"1644085707","viewed":213,"name":"Fake vortices (noise sketch)","username":"stegu","description":"More \"Gabor-like\" wavelets in a regular grid, with animated phase and direction. There is no actual motion here. Not even the grid moves. This relates very closely to how Gabor patches are used in perception research: to play tricks on our visual system.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["noise","waves","vortex","directional","gabor"],"hasliked":0,"parentid":"fsjcWG","parentname":"Wave noise (sketch)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A quick sketch made for research discussions.\n// \"Is this something?\" (And, in that case, what?)\n// If you take this idea and run with it, please\n// let me know in the comments where you end up!\n\n// Note that almost every parameter in here is brittle:\n// the grid density, the rate of change of the gradient field,\n// the two Gabor wiggle spatial frequencies and the phase\n// animation speed all contribute to the illusion, and changing\n// one even a little without also tweaking the others can weaken\n// or completely destroy the already weak visual impression of\n// \"swirly motion\".\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/(iResolution.x+iResolution.y)*2.0;\n\n\tvec2 p0, p1, p2;\n\tvec2 i0, i1, i2;\n\n\tvec2 p = uv*48.0; // Grid density\n\thexgrid(p, p0, i0, p1, i1, p2, i2);\n\n\t// A vector field to fiddle with: the gradient of 2-D psrdnoise\n\tvec2 g;\n\tvec2 d = vec2(0.05*iTime, 0.0); // Lateral motion of the vector field\n    float r = 0.2*iTime;            // \"Morphing\" of noise (rotating gradients)\n\tfloat n = 0.5 + 0.5*psrdnoise(uv*2.5+d, vec2(0.0), r, g);\n\n    // \"A\" determines the amplitude of our wiggles\n\tfloat A = 1.5*sqrt(max(0.0, length(g)-0.2)); // Mask out vortex centers (they flicker)\n\tA *= smoothstep(0.0, 0.25, abs(n-0.5)); // Fade out between the spinny parts\n\n    vec2 g_ = vec2(-g.y, g.x); // Orthogonal to the gradient, in iso-line direction\n    vec2 g1 = g + g_;          // Rotate 45 deg to make strongly sloped log-spirals\n\n\tg1 = normalize(g1);          // If left unnormalized: changes the wavelength\n    vec2 g2 = vec2(-g1.y, g1.x); // Orthogonal second frequency for the wavelets\n\n    // A pseudo-random \"neutral phase\" works best\n\tvec3 ph = hashphase(vec3(i0.x,i1.x,i2.x), vec3(i0.y,i1.y,i2.y));\n\t\n\tfloat a1 = 0.0; // This could be animated, but in that case slower than a2\n\tfloat a2 = 1.0*iTime;\n\n    // \"Special\" Gabor patches with two waves in each (saves on multiplications)\n\tfloat w0 = wavelet(p, p0, 2.0*g1, ph.x + a1, 0.5*g2, ph.x + a2);\n\tfloat w1 = wavelet(p, p1, 2.0*g1, ph.y + a1, 0.5*g2, ph.y + a2);\n\tfloat w2 = wavelet(p, p2, 2.0*g1, ph.z + a1, 0.5*g2, ph.z + a2);\n\t\n\tfloat f = 0.6*A*(w0 + w1 + w2);\n\n\tvec3 bg = vec3(0.125, 0.25, 0.625);\n\tvec3 fg = vec3(1.0, 1.0, 1.0);\n\n\tvec3 col = mix(bg, fg, f);\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// psrdnoise (c) Stefan Gustavson and Ian McEwan,\n// ver. 2021-12-02, published under the MIT license:\n// https://github.com/stegu/psrdnoise/\nfloat psrdnoise(vec2 x, vec2 period, float alpha, out vec2 gradient)\n{\n\tvec2 uv = vec2(x.x+x.y*0.5, x.y);\n\tvec2 i0 = floor(uv), f0 = fract(uv);\n\tfloat cmp = step(f0.y, f0.x);\n\tvec2 o1 = vec2(cmp, 1.0-cmp);\n\tvec2 i1 = i0 + o1, i2 = i0 + 1.0;\n\tvec2 v0 = vec2(i0.x - i0.y*0.5, i0.y);\n\tvec2 v1 = vec2(v0.x + o1.x - o1.y*0.5, v0.y + o1.y);\n\tvec2 v2 = vec2(v0.x + 0.5, v0.y + 1.0);\n\tvec2 x0 = x - v0, x1 = x - v1, x2 = x - v2;\n\tvec3 iu, iv, xw, yw;\n\tif(any(greaterThan(period, vec2(0.0)))) {\n\t\txw = vec3(v0.x, v1.x, v2.x);\n\t\tyw = vec3(v0.y, v1.y, v2.y);\n\t\tif(period.x > 0.0)\n\t\t\txw = mod(vec3(v0.x, v1.x, v2.x), period.x);\n\t\tif(period.y > 0.0)\n\t\t\tyw = mod(vec3(v0.y, v1.y, v2.y), period.y);\n\t\tiu = floor(xw + 0.5*yw + 0.5); iv = floor(yw + 0.5);\n\t} else {\n\t\tiu = vec3(i0.x, i1.x, i2.x); iv = vec3(i0.y, i1.y, i2.y);\n\t}\n\tvec3 hash = mod(iu, 289.0);\n\thash = mod((hash*51.0 + 2.0)*hash + iv, 289.0);\n\thash = mod((hash*34.0 + 10.0)*hash, 289.0);\n\tvec3 psi = hash*0.07482 + alpha;\n\tvec3 gx = cos(psi); vec3 gy = sin(psi);\n\tvec2 g0 = vec2(gx.x, gy.x);\n\tvec2 g1 = vec2(gx.y, gy.y);\n\tvec2 g2 = vec2(gx.z, gy.z);\n\tvec3 w = 0.8 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2));\n\tw = max(w, 0.0); vec3 w2 = w*w; vec3 w4 = w2*w2;\n\tvec3 gdotx = vec3(dot(g0, x0), dot(g1, x1), dot(g2, x2));\n\tfloat n = dot(w4, gdotx);\n\tvec3 w3 = w2*w; vec3 dw = -8.0*w3*gdotx;\n\tvec2 dn0 = w4.x*g0 + dw.x*x0;\n\tvec2 dn1 = w4.y*g1 + dw.y*x1;\n\tvec2 dn2 = w4.z*g2 + dw.z*x2;\n\tgradient = 10.9*(dn0 + dn1 + dn2);\n\treturn 10.9*n;\n}\n\n\n// The remainder of this tab is public domain code.\n// Use however you want. Credit is appreciated but not required.\n\n// Return the three nearest points in a hexagonal grid\n// (the simplex neighbors)\nvoid hexgrid(vec2 v,\n\tout vec2 p0, out vec2 i0,\n\tout vec2 p1, out vec2 i1,\n\tout vec2 p2, out vec2 i2) {\n\t\n\tconst float stretch = 1.0/0.8660; // No use for tiling here,\n\tconst float squash = 0.8660;  // use isotropic simplex grid\n\t\n  //  v.y = v.y + 0.0001; // needed w/ stretched grid (rounding errors)\n  v.y = v.y * stretch;\n  // Transform to grid space (axis-aligned, modified \"simplex\" grid)\n  vec2 uv = vec2(v.x + v.y*0.5, v.y);\n  // Determine which simplex we're in, with i0 being the \"base\"\n  i0 = floor(uv);\n  vec2 f0 = fract(uv);\n  // o1 is the offset in simplex space to the second corner\n  float cmp = step(f0.y, f0.x);\n  vec2 o1 = vec2(cmp, 1.0-cmp);\n  // Enumerate the remaining simplex corners\n  i1 = i0 + o1;\n  i2 = i0 + vec2(1.0, 1.0);\n  // Transform corners back to texture space\n  p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n  p1 = vec2(p0.x + o1.x - o1.y * 0.5, p0.y + o1.y);\n  p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n  p0.y = p0.y * squash;\n  p1.y = p1.y * squash;\n  p2.y = p2.y * squash;\n}\n\n// Compute the value of a \"Gabor-ish wavelet\" from point p\n// in direction g, evaluated at point x with phase shift alpha\nfloat wavelet(vec2 x, vec2 p, vec2 g, float alpha) {\n\tvec2 d = x - p;\n\tfloat w = 0.8 - dot(d,d);\n\tw = max(w, 0.0);\n\tfloat w2 = w * w;\n\treturn w2 * sin(mod(dot(d,g)+alpha,1.0)*6.2832);\n}\n\n// Compute the value of a \"Gabor-ish wavelet\" from point p\n// with two independent wave components in directions g1, g2,\n// evaluated at point x with phase shifts alpha1, alpha2\nfloat wavelet(vec2 x, vec2 p, vec2 g1, float alpha1, vec2 g2, float alpha2) {\n\tvec2 d = x - p;\n\tfloat w = 0.8 - dot(d,d);\n\tw = max(w, 0.0);\n\tfloat w2 = w * w;\n\treturn w2 * sin(mod(dot(d,g1)+alpha1,1.0)*6.2832)\n        * sin(mod(dot(d,g2)+alpha2,1.0)*6.2832);\n}\n\n// Permutation functions for the hash values\nvec3 perm1(vec3 i) {\n  vec3 im = mod(i, 289.0);\n  return mod(((im*34.0)+10.0)*im, 289.0);\n}\n\nvec3 perm2(vec3 i) {\n\tvec3 im = mod(i, 361.0);\n\treturn mod((im*38.0+8.0)*im, 361.0);\n}\n\nvec3 hashphase(vec3 iu, vec3 iv) {\n\treturn perm1(perm2(iu)+iv)*(1.0/289.0);\n}\n","name":"Common","description":"","type":"common"}]}