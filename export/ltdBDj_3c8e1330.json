{"ver":"0.1","info":{"id":"ltdBDj","date":"1546313471","viewed":169,"name":"Water World","username":"WB","description":"Raymarched procedural water planet shader made from layered noise functions. Moving the mouse up and down simulates climate by increasing/decreasing latitude of polar ice caps.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raymarching","planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 64\n#define MIN_DIST 0.0002\n#define PI = 3.14159265\n//Comment this out disable rotation\n#define ROTATE \n\n//Input Parameters\nconst float _Radius = 5.0;\nconst float _Oblateness = 1.02;\nconst vec3 _Center = vec3(0.0,0.0,0.0);\n\nconst vec3 _LightPos = vec3(-10.0, 0.0, -20.0);\nconst vec3 _LightCol = vec3(1.0, 1.0, 1.0);\n\nconst vec4 _Color = vec4(0.5,0.7,0.8, 1.0);\nconst vec3 _Emissive = vec3(0.0, 0.0, 0.0);\nconst float _Specular = 0.5;\nconst float _SpecularHardness = 10.0;\nconst float _FresnelPow = 16.0;\nconst float _FresnelBias = 0.1;\n\nconst vec4 _OceanColor = vec4(0.2, 0.3, 0.45, 1.0);\nconst float _OceanDepth = 0.1;\n\nconst vec4 _UpperCloudColor = vec4(1.0,1.0,1.0,1.0);\nconst float _UpperCloudScale = 10.0;\nconst float _UpperCloudSkew = 2.0;\nconst float _UpperCloudStrength = 0.5;\nconst float _UpperCloudExponent = 2.0;\nconst float _LowerCloudStrength = 0.4;\nconst float _LowerCloudTurbulence = 2.5;\nconst float _LowerCloudFrequency = 0.4;\n\n//Signed distance function for a spheroid. \n//For oblateness(O), O == 1 : Sphere, O < 1 : Prolate Spheroid, O > 1 : Oblate Spheroid \nfloat sdSpheroid(vec3 position, float oblateness)\n{\n    vec3 center = _Center;\n    position.y *= oblateness;\n    return length(center - position) - _Radius;\n}\n\n//Raymarching loop\nvec3 raymarch(vec3 position, vec3 direction)\n{\n    float dist;\n    vec3 center = _Center;\n\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        dist = sdSpheroid(position, _Oblateness);\n        if (dist < MIN_DIST)\n        {\n            return position;\n        }\n\n        position += direction * dist;\n    }\n\n    return vec3(0.0, 0.0, 0.0);\n}\n\n//Fast geodesic normal calculation\nvec3 fastNormal(vec3 p)\n{\n    p.y *= _Oblateness;\n    return normalize(p - _Center);\n}\n\n//Correct geodetic normal for a non-spherical ellipsoid\nvec3 geodeticNormal(vec3 p)\n{\n    vec3 axes = vec3(1.0, _Oblateness*_Oblateness, 1.0);\n    vec3 R = p - _Center;\n    return normalize(R/axes);\n}\n\n//Simplex noise from https://www.shadertoy.com/view/XtBGDG\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,128.852))) * 43758.5453)*2.0-1.0;\n}\n\nfloat snoise(vec3 p)\n{\n\t\n\tfloat f3 = 1.0/3.0;\n\tfloat s = (p.x+p.y+p.z)*f3;\n\tint i = int(floor(p.x+s));\n\tint j = int(floor(p.y+s));\n\tint k = int(floor(p.z+s));\n\t\n\tfloat g3 = 1.0/6.0;\n\tfloat t = float((i+j+k))*g3;\n\tfloat x0 = float(i)-t;\n\tfloat y0 = float(j)-t;\n\tfloat z0 = float(k)-t;\n\tx0 = p.x-x0;\n\ty0 = p.y-y0;\n\tz0 = p.z-z0;\n\t\n\tint i1,j1,k1;\n\tint i2,j2,k2;\n\t\n\tif(x0>=y0)\n\t{\n\t\tif(y0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n\t\telse if(x0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n\t\telse { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }  // Z X Z order\n\t}\n\telse \n\t{ \n\t\tif(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n\t\telse if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n\t\telse { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n\t}\n\t\n\tfloat x1 = x0 - float(i1) + g3; \n\tfloat y1 = y0 - float(j1) + g3;\n\tfloat z1 = z0 - float(k1) + g3;\n\tfloat x2 = x0 - float(i2) + 2.0*g3; \n\tfloat y2 = y0 - float(j2) + 2.0*g3;\n\tfloat z2 = z0 - float(k2) + 2.0*g3;\n\tfloat x3 = x0 - 1.0 + 3.0*g3; \n\tfloat y3 = y0 - 1.0 + 3.0*g3;\n\tfloat z3 = z0 - 1.0 + 3.0*g3;\t\n\t\t\t\t \n\tvec3 ijk0 = vec3(i,j,k);\n\tvec3 ijk1 = vec3(i+i1,j+j1,k+k1);\t\n\tvec3 ijk2 = vec3(i+i2,j+j2,k+k2);\n\tvec3 ijk3 = vec3(i+1,j+1,k+1);\t\n            \n\tvec3 gr0 = normalize(vec3(noise3D(ijk0),noise3D(ijk0*2.01),noise3D(ijk0*2.02)));\n\tvec3 gr1 = normalize(vec3(noise3D(ijk1),noise3D(ijk1*2.01),noise3D(ijk1*2.02)));\n\tvec3 gr2 = normalize(vec3(noise3D(ijk2),noise3D(ijk2*2.01),noise3D(ijk2*2.02)));\n\tvec3 gr3 = normalize(vec3(noise3D(ijk3),noise3D(ijk3*2.01),noise3D(ijk3*2.02)));\n\t\n\tfloat n0 = 0.0;\n\tfloat n1 = 0.0;\n\tfloat n2 = 0.0;\n\tfloat n3 = 0.0;\n\n\tfloat t0 = 0.5 - x0*x0 - y0*y0 - z0*z0;\n\tif(t0>=0.0)\n\t{\n\t\tt0*=t0;\n\t\tn0 = t0 * t0 * dot(gr0, vec3(x0, y0, z0));\n\t}\n\tfloat t1 = 0.5 - x1*x1 - y1*y1 - z1*z1;\n\tif(t1>=0.0)\n\t{\n\t\tt1*=t1;\n\t\tn1 = t1 * t1 * dot(gr1, vec3(x1, y1, z1));\n\t}\n\tfloat t2 = 0.5 - x2*x2 - y2*y2 - z2*z2;\n\tif(t2>=0.0)\n\t{\n\t\tt2 *= t2;\n\t\tn2 = t2 * t2 * dot(gr2, vec3(x2, y2, z2));\n\t}\n\tfloat t3 = 0.5 - x3*x3 - y3*y3 - z3*z3;\n\tif(t3>=0.0)\n\t{\n\t\tt3 *= t3;\n\t\tn3 = t3 * t3 * dot(gr3, vec3(x3, y3, z3));\n\t}\n\treturn 96.0*(n0+n1+n2+n3);\n\t\n}\n\nfloat ridgedNoise(vec3 position, float frequency, float amplitude)\n{\n    return((1.0 - abs(snoise(position * frequency))) * 2.0 - 1.0) * amplitude;\n}\n\n//This function generates the planet from layered noise and handles shading\nvec4 renderSurface(vec3 normal, vec3 sp, vec3 camPos, float h)\n{\n    //Get direction to center for parallel light rays\n    vec3 lightDir = -normalize(_Center - _LightPos);\n    //float dist = length(_Center - _WorldSpaceCameraPos);\n    vec3 worldNormal = normal;\n\n    vec3 seed = worldNormal;\n\n    //Terrain Generation\n\n    //Fractal Noise\n    const int octaves = 8;\n    float scale = 3.0;\n    float falloff = 1.0;\n\n    float offset = 0.0;\n    for (int i = 0; i < octaves; i++)\n    {\n        offset += snoise(seed * scale * float(i * i)) / falloff;\n        falloff *= 2.0;\n    }\n\n    //Scales noise based on lattitude to simulate polar climate\n    offset += abs(h * h);\n\n    //Ground color\n    float t = clamp((1.0 + offset) / 2.0, 0.0, 1.0);\n    vec4 texCol = mix(_Color, vec4(1.0, 1.0, 1.0, 1.0), t);\n\n    //Set Sea Level\n    float depth = _OceanDepth * clamp(iMouse.y * 0.5, 0.0, 1000.0);\n    float ocean = step(offset, depth);\n    texCol = mix(texCol, _OceanColor, ocean);\n\n    //Upper Cloud Layer\n    vec3 skewedSeed = vec3(worldNormal.x, worldNormal.y * _UpperCloudSkew, worldNormal.z);\n    vec3 mirroredSeed = worldNormal;\n    mirroredSeed.xy *= -1.0;\n    float uCloud = clamp(max(snoise(skewedSeed * 2.0) - ridgedNoise(seed, 4.0, 1.0) + snoise(skewedSeed * _UpperCloudScale)+ snoise(normal * 8.0) + snoise(skewedSeed * 32.0) + snoise(mirroredSeed * 64.0) / 4.0 + snoise(normal * 128.0)/4.0, 0.0) * _UpperCloudStrength, 0.0, 1.0);\n    float cloudFade = pow(uCloud, _UpperCloudExponent);\n    texCol.rgb = mix(texCol.rgb, _UpperCloudColor.rgb * 2.0, cloudFade);\n\n    //Lower Cloud Layer\n    if (_LowerCloudStrength > 0.0)\n    {\n        seed *= 8.0 * _LowerCloudFrequency;\n        seed.y *= 2.0;\n        float lowerClouds = pow(abs(snoise(seed)), 4.0);\n        lowerClouds -= snoise(seed) + snoise(seed) + snoise(normal * 4.0)/2.0 + snoise(seed * 2.0) / 4.0 + snoise(seed * 8.0) / 3.0 + snoise(seed * 16.0) / 6.0;\n        lowerClouds -= abs(snoise(seed * _LowerCloudTurbulence));\n        lowerClouds = clamp(lowerClouds, 0.0, 1.0);\n        texCol.rgb = mix(texCol.rgb, _UpperCloudColor.rgb * 2.0, clamp(lowerClouds, 0.0, 1.0) * _LowerCloudStrength);\n    }\n\n    //Lambert Reflectance\n    float NdotL = dot(normal, lightDir);\n\n    //Blinn-Phong Specular\n    vec3 viewDir = -normalize(sp - camPos);\n    vec3 halfangle = (lightDir + viewDir)/length(lightDir + viewDir);\n    float NdotH = dot(normal, halfangle);\n    float intensity = pow(clamp(NdotH, 0.0, 1.0), _SpecularHardness);\n\n    vec4 col;\n    col.rgb = clamp(texCol.rgb * _LightCol * NdotL + (intensity * ocean * (1.0-cloudFade) * _Specular) + _Emissive, 0.0, 1.0);\n\n    //Fresnel-based atmosphere effect. Not physically accurate but looks good from most distances and relatively cheap.\n    float fresnel = clamp(_FresnelBias + (40.0) * pow(1.0 + dot(normalize(sp - camPos), normal), _FresnelPow), 0.0, 1.0);\n    //col.a = max(0.0,1.0 - fresnel);\n\n//    float NdotV = dot(normal, viewDir);\n//    col.rgb *= saturate(tex1D(_ScatteringTex, -NdotL * _ScatteringTex_ST.x + _ScatteringTex_ST.z));\n//    col.rgb += saturate(tex1D(_ScatteringTex, -NdotL * _ScatteringTex_ST.y + _ScatteringTex_ST.w)) * fresnel * NdotL;\n//    col.a *= 1-fresnel;\n    col.rgb += (fresnel + _Emissive) * NdotL;\n    col.rgb *= 1.0-fresnel;\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Y-axis rotation matrix\n    float cosTheta = cos(iTime * 0.2);\n    float sinTheta = sin(iTime * 0.2);\n    mat3 rot = mat3(cosTheta, 0.0, sinTheta,\n        \t\t\t0.0, 1.0, 0.0,\n    \t\t\t    -sinTheta, 0.0, cosTheta);\n    \n    //World camera position\n    vec3 camPos = vec3(0.0,0.0,-25.0);\n    #ifdef ROTATE\n    camPos = rot * camPos;\n    #endif\n    \n    //Screen space uv coords\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //Eye vector\n    vec3 viewDir = normalize(vec3((-1.0 + 2.0 * uv) * vec2(iResolution.x/iResolution.y, 1), 4));\n    #ifdef ROTATE\n    viewDir = rot * viewDir;\n    #endif\n    \n    //Get world position on sphere\n    vec3 wPos = raymarch(camPos, viewDir);\n    \n    vec3 col;\n    \n    if (wPos != vec3(0.0))\n    {\n\n        //Calculate surface normal\n        vec3 wNormal = geodeticNormal(wPos);\n\n        col = renderSurface(wNormal, wPos, camPos, abs(wPos.y)).rgb;\n    }\n    else\n    {\n        col.rgb += smoothstep(0.85, 0.9, abs(snoise(rot * viewDir * 32.0)));\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}