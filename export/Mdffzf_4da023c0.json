{"ver":"0.1","info":{"id":"Mdffzf","date":"1497245024","viewed":394,"name":"Burger","username":"FMS_Cat","description":"I'm at Burger King 🤔\nPerformance is sooo bad","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["raymarcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://twitter.com/FMS_Cat\n\n// ------\n\n#define MARCH_ITER 50\n#define INIT_LEN 0.01\n#define MARCH_MULT 0.8\n\n#define material float\n#define MTL_NONE 0.0\n#define MTL_BASE 1.0\n#define MTL_MEAT 2.0\n#define MTL_HAPPA 3.0\n#define MTL_CHEESE 4.0\n#define MTL_TOMATO 5.0\n\n#define V vec2(0.,1.)\n#define PI 3.14159265\n#define HUGE 1E9\n#define saturate(i) clamp(i,0.,1.)\n#define lofi(i,d) floor(i/d)*d\n\n// ------\n\n// 浮動小数点の精度の設定\nprecision mediump float;\n\n// JSから渡される変数の定義\nuniform float time;\nuniform vec2 resolution;\nuniform vec2 mouse;\n\n// ------\n\n// 二次元回転行列\nmat2 rotate2D( float _t ) {\n  return mat2(\n    cos( _t ), sin( _t ),\n    -sin( _t ), cos( _t )\n  );\n}\n\n// smooth minimum : https://iquilezles.org/articles/smin\nfloat smin( float _a, float _b, float _k, out float h ) {\n  h = clamp( 0.5 + 0.5 * ( _b - _a ) / _k, 0.0, 1.0 );\n  return mix( _b, _a, h ) - _k * h * ( 1.0 - h );\n}\n\nfloat smin( float _a, float _b, float _k ) {\n  float h;\n  return smin( _a, _b, _k, h );\n}\n\nfloat random( vec2 _uv ) {\n  return fract( sin( dot( vec2( 12.563, 21.864 ), _uv ) ) * 19934.54 );\n}\n\nfloat iRandom( vec2 _uv ) {\n  float v00 = random( floor( _uv + V.xx ) );\n  float v10 = random( floor( _uv + V.yx ) );\n  float v01 = random( floor( _uv + V.xy ) );\n  float v11 = random( floor( _uv + V.yy ) );\n  return mix(\n    mix( v00, v10, smoothstep( 0.0, 1.0, fract( _uv.x ) ) ),\n    mix( v01, v11, smoothstep( 0.0, 1.0, fract( _uv.x ) ) ),\n    smoothstep( 0.0, 1.0, fract( _uv.y ) )\n  );\n}\n\nfloat noise( vec2 _uv ) {\n  float sum = 0.0;\n  for ( int i = 0; i < 4; i ++ ) {\n    float p = pow( 2.0, float( i ) + 1.0 );\n    sum += iRandom( _uv * p * 4.0 ) / p;\n  }\n  return sum;\n}\n\nvec3 rainbow( vec3 _i, float _p ) {\n  float p = fract( _p );\n  return mix(\n    mix(\n      mix(\n        _i.xyz,\n        _i.yzx,\n        saturate( p * 3.0 )\n      ),\n      _i.zxy,\n      saturate( p * 3.0 - 1.0 )\n    ),\n    _i.xyz,\n    saturate( p * 3.0 - 2.0 )\n  );\n}\n\n// ------\n\n// カメラの構造体\nstruct Camera {\n  vec3 pos;\n  vec3 dir;\n  vec3 sid;\n  vec3 top;\n  float fov;\n};\n\n// レイの構造体\nstruct Ray {\n  vec3 dir;\n  vec3 ori;\n};\n\n// ------\n\n// カメラの初期化\nCamera camInit( in vec3 _pos, in vec3 _tar, in float _fov ) {\n  Camera cam;\n  cam.pos = _pos;\n  cam.dir = normalize( _tar - _pos );\n  cam.sid = normalize( cross( cam.dir, V.xyx ) );\n  cam.top = normalize( cross( cam.sid, cam.dir ) );\n  cam.fov = _fov;\n\n  return cam;\n}\n\n// レイの初期化\nRay rayInit( in vec3 _ori, in vec3 _dir ) {\n  Ray ray;\n  ray.dir = _dir;\n  ray.ori = _ori;\n  return ray;\n}\n\n// カメラから出るレイを求める\nRay rayFromCam( in vec2 _p, in Camera _cam ) {\n  vec3 dir = normalize(\n    _p.x * _cam.sid\n    + _p.y * _cam.top\n    + _cam.dir / tan( _cam.fov * PI / 360.0 ) // Is this correct?\n  );\n  return rayInit( _cam.pos, dir );\n}\n\n// ------\n\n// 球体の距離関数\nfloat distFuncSphere( vec3 _p, float _r ) {\n  return length( _p ) - _r;\n}\n\n// 箱の距離関数\nfloat distFuncBox( vec3 _p, vec3 _s ) {\n  vec3 d = abs( _p ) - _s;\n  return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\n// トーラスの距離関数\nfloat distFuncTorus( vec3 _p, float _r, float _R ) {\n  vec2 q = vec2( length( _p.xz ) - _R, _p.y );\n  return length( q ) - _r;\n}\n\n// 円柱の距離関数\nfloat distFuncPillar( vec3 _p, float _r, float _t ) {\n  return max( abs( _p.y ) - _t, length( _p.xz ) - _r );\n}\n\n// xz円状にRepetition\nvec3 circleRep( vec3 _p, float _r, float _c ) {\n  vec3 p = _p;\n  float intrv = PI * 2.0 / _c;\n  p.zx = rotate2D( floor( atan( p.z, p.x ) / intrv ) * intrv ) * p.zx;\n  p.zx = rotate2D( intrv / 2.0 ) * p.zx;\n  p.x -= _r;\n  return p;\n}\n\n// 距離関数\nfloat distFunc( vec3 _p, out material mtl ) {\n  vec3 p = _p;\n  float dist = HUGE;\n  \n  { // base\n    vec3 p = p;\n    p.y -= -0.3;\n    vec3 ps = p;\n    ps.y += ( noise( p.xz * 0.2 - 0.7 ) - 0.5 ) * 0.1;\n    float distt = distFuncPillar( p, 0.85, 0.02 );\n    distt = smin( distt, distFuncTorus( ps, 0.1, 0.9 ), 0.1 );\n    mtl = distt < dist ? MTL_BASE : mtl;\n    dist = distt < dist ? distt : dist;\n  }\n  \n  { // top\n    vec3 p = p;\n    p.y *= 2.5;\n    p.y -= 0.3;\n    vec3 ps = p;\n    ps.y += ( noise( p.xz * 0.2 - 0.7 ) - 0.5 ) * 0.2;\n    float distt = max(\n      distFuncSphere( ps, 1.0 ),\n      -p.y\n    );\n    mtl = distt < dist ? MTL_BASE : mtl;\n    dist = distt < dist ? distt : dist;\n  }\n  \n  { // niku\n    vec3 p = p;\n    p.y += ( noise( p.zx * 0.4 - 0.4 ) - 0.5 ) * 0.1;\n    p.x += ( noise( p.yz * 0.4 - 0.4 ) - 0.5 ) * 0.1;\n    p.z += ( noise( p.xy * 0.4 - 0.4 ) - 0.5 ) * 0.1;\n    p.y -= -0.15;\n    float distt = distFuncPillar( p, 1.0, 0.03 );\n    distt = smin( distt, distFuncTorus( p, 0.05, 1.0 ), 0.1 );\n    mtl = distt < dist ? MTL_MEAT : mtl;\n    dist = distt < dist ? distt : dist;\n  }\n  \n  { // happa\n    vec3 p = p;\n    p += vec3(\n      noise( p.yz * 0.4 - 0.7 ) - 0.5,\n      noise( p.zx * 0.4 - 0.7 ) - 0.5,\n      noise( p.xy * 0.4 - 0.7 ) - 0.5\n    ) * 0.4 * smoothstep( 1.0, 1.1, length( p.xz ) );\n    p.y -= 0.1;\n    p.xz = rotate2D( 1.0 ) * p.xz;\n    float distt = distFuncPillar( p, 1.15, 0.02 );\n    mtl = distt < dist ? MTL_HAPPA : mtl;\n    dist = distt < dist ? distt : dist;\n  }\n  \n  { // cheese\n    vec3 p = p;\n    p.y -= -0.05;\n    p.y -= -0.2 * smoothstep( 1.0, 1.5, length( p.xz ) );\n    p.xz = rotate2D( 1.0 ) * p.xz;\n    float distt = distFuncBox( p, vec3( 0.95, 0.02, 0.95 ) );\n    mtl = distt < dist ? MTL_CHEESE : mtl;\n    dist = distt < dist ? distt : dist;\n  }\n  \n  { // tomato\n    vec3 p = p;\n    p.y -= 0.02;\n    p = circleRep( p, 0.6, 3.0 );\n    p.xz = rotate2D( 1.0 ) * p.xz;\n    float distt = distFuncPillar( p, 0.5, 0.05 );\n    float fresh = 0.99 * smoothstep( 0.15, 0.4, length( p ) ) * smoothstep( 0.45, 0.4, length( p ) );\n    fresh *= 0.5 + 0.5 * sin( atan( p.z, p.x ) * 16.0 );\n    mtl = distt < dist ? ( MTL_TOMATO + fresh ) : mtl;\n    dist = distt < dist ? distt : dist;\n  }\n  \n  return dist;\n}\n\nfloat distFunc( vec3 _p ) {\n  material dummy = MTL_NONE;\n  return distFunc( _p, dummy );\n}\n\n// 距離関数から法線を求める\nvec3 normalFunc( in vec3 _p ) {\n  vec2 d = V * 1E-3;\n  return normalize( vec3(\n    distFunc( _p + d.yxx ) - distFunc( _p - d.yxx ),\n    distFunc( _p + d.xyx ) - distFunc( _p - d.xyx ),\n    distFunc( _p + d.xxy ) - distFunc( _p - d.xxy )\n  ) );\n}\n\n// ------\n\nvec4 draw( vec2 p, float time ) { \n  // カメラとレイを定義\n  Camera cam = camInit(\n    vec3( cos( time ) * 4.0, 1.0, sin( time ) * 4.0 ),\n    vec3( 0.0, -0.2, 0.0 ),\n    50.0\n  );\n  Ray ray = rayFromCam( p, cam );\n\n  // ------\n\n  float rayLen = INIT_LEN; // 探索レイの長さ\n  vec3 rayPos = ray.ori + rayLen * ray.dir; // 探索レイの位置\n  float rayDist = 0.0; // 探索レイ到達点から物体までの距離\n  material mtl = MTL_NONE;\n\n  // raymarch\n  for ( int i = 0; i < MARCH_ITER; i ++ ) {\n    rayDist = distFunc( rayPos, mtl );\n    rayLen += rayDist * MARCH_MULT;\n    rayPos = ray.ori + rayLen * ray.dir;\n    if ( 10.0 < rayLen ) { return vec4( 0.0 ); }\n    if ( abs( rayDist ) < 1E-4 ) { break; }\n  }\n\n  vec4 col = V.xxxx; // 出力する色\n  if ( abs( rayDist ) < 1E-2 ) { // もし物体に衝突したなら\n    // 各ベクトルを求める\n    vec3 normal = normalFunc( rayPos );\n    vec3 camDir = normalize( rayPos - cam.pos );\n    vec3 ligPos = cam.pos + cam.sid + cam.top * 1.0 - cam.dir;\n    vec3 ligDir = normalize( rayPos - ligPos );\n\n    // 拡散反射・光源の鏡面反射を求める\n    float dif = 0.5 + 0.5 * dot( -normal, ligDir );\n    float spe = pow( dot( normalize( camDir - normal ), ligDir ), 40.0 );\n    \n    // 材質に応じて色と反射率を変化させる\n    vec3 mtlCol = vec3( 0.0 );\n    float mtlSpe = 0.0;\n\t  \n    if ( floor( mtl ) == MTL_BASE ) {\n      mtlCol = vec3( 1.0, 0.4, 0.1 );\n      mtlSpe = 0.5;\n\t  \n    } else if ( floor( mtl ) == MTL_MEAT ) {\n      float yaki = smoothstep( 0.4, 0.8, noise( rayPos.xz * 4.0 ) );\n      mtlCol = mix( vec3( 0.6, 0.4, 0.2 ), vec3( 0.1 ), yaki * 0.4 );\n      mtlSpe = 0.2;\n\t    \n    } else if ( floor( mtl ) == MTL_HAPPA ) {\n      mtlCol = vec3( 0.6, 0.8, 0.2 );\n      mtlSpe = 0.5;\n\t    \n    } else if ( floor( mtl ) == MTL_CHEESE ) {\n      mtlCol = vec3( 0.9, 0.7, 0.1 );\n      mtlSpe = 0.4;\n\t    \n    } else if ( floor( mtl ) == MTL_TOMATO ) {\n      float fresh = fract( mtl );\n      mtlCol = mix( vec3( 0.9, 0.2, 0.2 ), vec3( 1.0, 0.9, 0.7 ), fresh );\n      mtlSpe = mix( 0.5, 0.8, fresh );\n    }\n\n    // 色を決定\n    col.xyz += mtlCol * dif;\n    col.xyz += mtlSpe * spe;\n    col.w = 1.0;\n\t  \n    return col;\n  } else { // 物体に当たらなかったら\n    return vec4( 0.0 );\n  }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 p = ( fragCoord.xy * 2.0 - iResolution.xy ) / iResolution.x;\n  fragColor = draw( p, iTime );\n}","name":"Image","description":"","type":"image"}]}