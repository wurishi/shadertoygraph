{"ver":"0.1","info":{"id":"DlKfD1","date":"1702043145","viewed":29,"name":"Webcam frame","username":"Ciubix8513","description":"A frame for my webcam for my streams","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf","overlay"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float computeDistanceToFrame(vec2 position){\n   //The size of the gradient around it\n   float compression = 10.0;\n   position *= compression;\n   vec2 frameDimensions = vec2(498.0, 280.0) / iResolution.y * compression / 2.1;\n   //Where the frame is located\n   vec2 framePosition = vec2(1633.0,903.0) / iResolution.y * compression;\n   \n   float box = sdBox(position - framePosition, frameDimensions);\n   float noise = fbm((length(position) + position.y * .54 + PI)/TAU * NOISE_PERIOD + (iTime / 20.0), 5, 0.5) * .5;\n   \n   return  box + noise;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    float dist = 1.0 - computeDistanceToFrame(fragCoord/ iResolution.y);\n    vec4 col = vec4(dist);\n    if (dist < 0.0 || dist > 1.0) {\n        fragColor = vec4(0.0);\n        return;\n    }   \n\n    float variance =  fbm(float(iTime / 20.0),3,20.0) * .1;\n    // Output to screen\n    fragColor = col * vec4(0.0,0.0 ,0.25 + variance,0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Thx IQ\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n//---------------------------------------------------------------------------\n//1D Perlin noise implementation  https://www.shadertoy.com/view/NtdSDN Thank you Betalord\n//---------------------------------------------------------------------------\n#define NOISE_PERIOD 3. // needs to be an integer value\n#define PI 3.14159265359\n#define TAU 6.2831853071\n#define HASHSCALE 0.1031\nfloat hash(float p) {\n    #ifdef NOISE_PERIOD\n\tp = mod(p, NOISE_PERIOD);\n    #endif\n    \n\tvec3 p3 = fract(vec3(p) * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat fade(float t) { return t*t*t*(t*(6.*t-15.)+10.); } // interpolation\nfloat grad(float hash, float p) { // gradient\n    int i = int(1e4*hash);\n\treturn (i & 1) == 0 ? p : -p;\n}\nfloat perlinNoise1D(float p) {\n\tfloat pi = floor(p); // integer part of the p\n\tfloat pf = p - pi; // fractional part of the p\n\tfloat w = fade(pf); // use fractional part of the p to interpolate between two integer edges\n    return mix(grad(hash(pi), pf), grad(hash(pi + 1.0), pf - 1.0), w) * 2.0;\n}\n// returns value in interval [-1..+1]\nfloat fbm(float pos, int octaves, float persistence) {\n\tfloat total = 0., frequency = 1., amplitude = 1., maxValue = 0.;\n\tfor(int i = 0; i < octaves; ++i) {\n\t\ttotal += perlinNoise1D(pos * frequency) * amplitude;\n\t\tmaxValue += amplitude;\n\t\tamplitude *= persistence;\n\t\tfrequency *= 2.;\n\t}\n\treturn total / maxValue;\n}","name":"Common","description":"","type":"common"}]}