{"ver":"0.1","info":{"id":"XdlyD2","date":"1490439930","viewed":178,"name":"Gambling","username":"tonynogo","description":"First test with sdf and camera\nI tried to do this shader based on :\nhttps://www.shadertoy.com/view/4ljXRh \nhttps://cis700-procedural-graphics.github.io/files/implicit_surfaces_2_21_17.pdf\nhttp://iquilezles.org/articles/distfunctions/distfunctions.htm","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf","camera"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Camera\nvec3 CameraPos = vec3(7.0, 3.0, -7.0);\nvec3 TargetPoint = vec3(2.0, 0.0, 0.0);\n\nvec3 currentColor = vec3(1.0, 1.0, 1.0);\nconst float EPSILON_RAYMARCH = 0.01;\nconst float EPSILON_NORMAL = 0.0001;\nconst int RAYMARCHING_STEP = 64;\nconst float MOVE_SPEED = 2.0;\nconst float ROTATION_SPEED = 0.2;\n\n// -----TRANSFORMATION-------------------------\n// Repetition (Thx abje)\nvec3 Repetition(vec3 p, vec3 c)\n{\n    return mod(p, c) - 0.5 * c;\n}\n\n// Rotation\nvec3 Rotation( vec3 p, mat3 m )\n{\n    // Removing inverse for better performance (Thx coyote)\n    return m * p;\n}\n\n// Translation\nvec3 Translation(vec3 p, vec3 displacement)\n{\n    return p + displacement;\n}\n//---------------------------------------------\n\n// Union\nfloat Union(float previous, float current, vec3 color)\n{\n    if(previous < current)\n        return previous;\n    \n    currentColor = color;\n\treturn current;\n}\n\n// Intersection\nfloat Intersection(float previous, float current, vec3 color)\n{\n    if(previous > current)\n        return previous;\n    \n    currentColor = color;\n\treturn current;\n}\n\n// Soustraction\nfloat Substract(float previous, float current, vec3 color)\n{\n    if(previous > -current)\n        return previous;\n    \n    currentColor = color;\n\treturn current;\n}\n\n//------SHAPES---------------------------------\n// Sphere\nfloat SD_Circle(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\n// Round Box\nfloat SD_RoundBox(vec3 p, vec3 b, float r)\n{\n  return length(max(abs(p) - b, 0.0)) - r;\n}\n\n// Points of the dice\nfloat SD_DicePoints(vec3 pos)\n{\n    // 1\n    float val = SD_Circle(pos - vec3(-1.5, 0.0, 0.0), 0.3);\n    \n    // 2\n    val = min(val, SD_Circle(pos - vec3(-0.70, 0.70, 1.5), 0.3));\n    val = min(val, SD_Circle(pos - vec3(0.70, -0.70, 1.5), 0.3));\n    \n    // 3\n    val = min(val, SD_Circle(pos - vec3(-0.70, -1.5, 0.7), 0.3));\n    val = min(val, SD_Circle(pos - vec3(0.70, -1.5, -0.7), 0.3));\n    val = min(val, SD_Circle(pos - vec3(0.0, -1.5, 0.0), 0.3));\n    \n    // 4\n    val = min(val, SD_Circle(pos - vec3(0.7, 1.5, 0.7), 0.3));\n    val = min(val, SD_Circle(pos - vec3(-0.70, 1.5, 0.7), 0.3));\n    val = min(val, SD_Circle(pos - vec3(-0.7, 1.5, -0.7), 0.3));\n    val = min(val, SD_Circle(pos - vec3(0.70, 1.5, -0.7), 0.3));\n    \n    // 5\n    val = min(val, SD_Circle(pos - vec3(0.0, 0.0, -1.5), 0.3));\n    val = min(val, SD_Circle(pos - vec3(0.70, 0.70, -1.5), 0.3));\n    val = min(val, SD_Circle(pos - vec3(-0.70, -0.70, -1.5), 0.3));\n    val = min(val, SD_Circle(pos - vec3(0.70, -0.70, -1.5), 0.3));\n    val = min(val, SD_Circle(pos - vec3(-0.70, 0.70, -1.5), 0.3));\n    \n    // 6 \n    val = min(val, SD_Circle(pos - vec3(1.5, 0.70, 0.5), 0.3));\n    val = min(val, SD_Circle(pos - vec3(1.5, 0.70, -0.5), 0.3));\n    val = min(val, SD_Circle(pos - vec3(1.5, 0.0, 0.5), 0.3));\n    val = min(val, SD_Circle(pos - vec3(1.5, 0.0, -0.5), 0.3));\n    val = min(val, SD_Circle(pos - vec3(1.5, -0.70, 0.5), 0.3));\n    val = min(val, SD_Circle(pos - vec3(1.5, -0.70, -0.5), 0.3));\n    return val;\n}\n//---------------------------------------------\n\n\n// Test all the SD function to determine the nearest point\nfloat SceneSDF(vec3 pos)\n{\n    float moveTime = MOVE_SPEED * iTime;\n    //pos = Translation(pos, vec3(moveTime, moveTime, moveTime));\n    pos = Repetition(pos, vec3(12.0, 12.0, 12.0));\n    \n    float rotationTime = ROTATION_SPEED * iTime;\n    \n    pos = Rotation(pos, mat3(1.0, 0.0, 0.0,\n                             0.0, cos(rotationTime), sin(rotationTime),\n                             0.0, -sin(rotationTime),cos(rotationTime)));\n    \n    pos = Rotation(pos, mat3(cos(rotationTime), 0.0, sin(rotationTime),\n                             0.0, 1.0, 0.0,\n                             -sin(rotationTime), 0.0, cos(rotationTime)));\n    \n    float result = 999999999999999999.0;\n    result = Union(result, SD_RoundBox(pos, vec3(1.5, 1.5, 1.5), 0.1), vec3(1.0, 0.0, 0.0));\n    result = Intersection(result, SD_Circle(pos, 2.3), vec3(1.0, 0.0, 0.0));\n    result = Substract(result, SD_DicePoints(pos), vec3(1.0, 1.0, 1.0));\n    return result;\n}\n\n// Lambert lighting\nfloat Lambert(vec3 lightDir, vec3 normal)\n{\n    return max(0.1, dot(lightDir, normal));\n}\n\n// Compute the normal by approximating the nearest points\nvec3 ComputeNormal(vec3 pos, float currentDistance)\n{\n    return normalize(\n        vec3(\n            SceneSDF(pos + vec3(EPSILON_NORMAL, 0.0, 0.0)) - currentDistance,\n            SceneSDF(pos + vec3(0.0, EPSILON_NORMAL, 0.0)) - currentDistance,\n            SceneSDF(pos + vec3(0.0, 0.0, EPSILON_NORMAL)) - currentDistance)\n    );\n}\n\n// Determine the distance of the objects\nfloat RayMarching(vec3 origin, vec3 rayDir)\n{\n    float dist = 0.0;\n    float nearest = 0.0;\n    float result = 0.0;\n    \n    for(int i = 0; i < RAYMARCHING_STEP; i++)\n    {\n        vec3 currentPos = origin + rayDir * dist;\n        nearest = SceneSDF(currentPos);\n        if(nearest <= EPSILON_RAYMARCH)\n        {\n            vec3 lightDir1 = normalize(vec3(1.0, 1.0, -1.0));\n            vec3 normal = ComputeNormal(currentPos, nearest);\n            result = Lambert(lightDir1, normal);\n            return result;\n        }\n        dist += nearest;\n    }\n    return result;\n}\n\n// LookAt Camera\nmat3 setCamera()\n{  \n    vec3 zaxis = normalize(TargetPoint - CameraPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 xaxis = cross(up, zaxis);\n    vec3 yaxis = cross(zaxis, xaxis);\n    \n    return mat3(xaxis, yaxis, zaxis);\n}\n\n// Pixel function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Move the camera\n    CameraPos.z += iTime * MOVE_SPEED;\n    \n    // Move the lookAt point\n    TargetPoint.z += iTime * MOVE_SPEED;\n\n    // Compute LookAt Matrix\n    mat3 lookAtMat = setCamera();\n    \n    // ray direction\n    vec2 p = fragCoord.xy / iResolution.xy - 0.5;\n\tp.x *= iResolution.x / iResolution.y;\n    vec3 RayDir = lookAtMat * normalize( vec3(p.xy,2.0) );\n    \n    float val = RayMarching(CameraPos, RayDir);\n    vec3 col =  val * currentColor;\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}