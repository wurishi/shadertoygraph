{"ver":"0.1","info":{"id":"7ltBzl","date":"1663565520","viewed":66,"name":"ATLS 5660 Accumulation","username":"grahamsz","description":"Could definitely use some cleanup!\n\nIf i had more time I'd have liked to apply some noise variation to the rising ground plane so it's not completely flat. Could also render the snow with a non-flat color scheme and add specular highlights","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["snow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nbool intersectsFlakeOnSnowPlane(float planeZ, vec3 ro, vec3 rd, out vec3 point) {\n  // first calculate distance from camera which is in the ray origin.\n  // note both distance and planeZ are negative\n  \n  // Each snow plane is just an offset version of the red color noise from iChannel0\n  // we advance them with time and consider that a ray hits a flake if it happens to \n  // hit a pixel with a color value higher tha .85\n\n  float distance = -ro.z + planeZ;\n\n  // we can take the rd vector (which is normalized) and mulitply it by the distance/rd.Z\n  float factor = distance / rd.z;\n\n  point = ro + rd * factor;\n\n  vec4 texture = texture(iChannel0, vec2(point.x +cos(point.y/2.) +sin(point.z/2.)+ planeZ * 1.233, point.y + planeZ * .123 + iTime * 1.5) / 15.);\n  point.z += texture.z; // add a bit of variation here so things aren't quite in levels\n\n  float flakeColor = texture.x;\n\n  return (flakeColor > 0.9);\n\n}\n\nbool intersectsGroundPlane(vec3 ro, vec3 rd, out vec3 point) {\n\n  // adapted from https://www.shadertoy.com/view/3sGXWw\n  // plane equation\n  \n  // Though note that this plane definition is a bit different from the simplified\n  // vec4 one used in the illumination calculation below.\n  \n  \n  \n  // (point - p0) . n = 0\n\n  // ray equation\n  // point = ro + rd * t\n\n  // solve for parameter t\n  // t = ((p0 - ro) . n) / (rd . n)\n  \n  \n\n  //plane normal\n  vec3 n = vec3(0.0, -1.0, 0.15);\n\n  //plane origin\n  vec3 p0 = vec3(-1.0, -0.5 + (iTime / 20.), -8.0);\n\n  float denom = dot(n, rd);\n\n  if (denom > 1e-6) {\n    float t = dot((p0 - ro), n) / denom;\n\n    if (t > 15.) {\n      return false; // don't consider 15 units away as a hit\n    }\n    point = ro + rd * t;\n\n    return true;\n  } else {\n    return false;\n  }\n\n}\n\nfloat getIlluminationBrightness(vec3 p) {\n\n\n  // Light shaft is defined by four planes. We can work out\n  // whether a point is illuminated by the sign of its\n  // dot product\n  \n  vec4 lightPlane1 = vec4(-.65, -.8, .45, 4.5);\n  vec4 lightPlane2 = vec4(1.95, 1.4, -.45, -1.5);\n  vec4 lightPlane3 = vec4(0, 0, 1, 7);\n  vec4 lightPlane4 = vec4(0, 0, -1., -2.);\n\n  if ((dot(lightPlane1, vec4(p, 1)) < 0.) ||\n      (dot(lightPlane2, vec4(p, 1)) < 0.) ||\n      (dot(lightPlane3, vec4(p, 1)) < 0.) ||\n      (dot(lightPlane4, vec4(p, 1)) < 0.))\n  {\n    return 0.3;\n  }\n\n  // if we get here then it must be illuminated\n  return 1. - distance(vec3(0., 1., 0.), p) / 30.;\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 3., 3.); // ray origin that represents camera position\n  vec3 rd = normalize(vec3(uv.x + 0.2, uv.y, -1)); // ray direction\n\n  vec3 pGround, pFlake;\n\n  // First we check if this ray intersects the ground\n  bool rayIntersectsGround = intersectsGroundPlane(ro, rd, pGround);\n  bool rayIntersectsStick=false;\n\n  // Now we draw the stick - this is really hacky but it's late\n  // we define the X and Y by the uv coordinates and place it at Z=-3.2\n  \n  // If the ray intersects the ground in front of the stick then we don't draw it\n  if ((uv.x > 0.2) && (uv.x < 0.23) && (!rayIntersectsGround || pGround.z < -3.2) && (uv.y < -0.1)) {\n\n    // first calculate distance from camera which is in the ray origin.\n    // note both distance and planeZ are negative\n\n    float distance = -ro.z - 3.2;\n\n    // we can take the rd vector (which is normalized) and mulitply it by the distance/rd.Z\n    float factor = distance / rd.z;\n\n    vec3 pStick = ro + rd * factor;\n    rayIntersectsStick=true;\n    float bright = getIlluminationBrightness(pStick);\n    \n    // use a modulo operation to create markings on the stick\n    if (int(uv.y * 50.) % 2 == 0) {\n      fragColor = vec4(bright - 0.1);\n    } else {\n\n      fragColor = vec4(bright / 2. - 0.2);\n    }\n\n  }\n  else\n  {\n      // start by assuming we hit the sky\n      fragColor = vec4(0.1);\n      \n      // but also check if we hit the ground\n      if (rayIntersectsGround) {\n        fragColor = vec4(getIlluminationBrightness(pGround)+pGround.z/50.);\n      }\n  }\n  \n  // Finally we replace those numbers with 6 vertical snow planes calculated with noise\n  // from z=-1 to -11 \n  // We need to check here that the ray doens't intersect the ground in front of the flake\n  // or the stick in front of the flake\n  \n  for (float snowPlane = -1.; snowPlane >= -11.; snowPlane -= 2.) {\n    if ((!rayIntersectsGround) || (pGround.z < snowPlane)) {\n      if (intersectsFlakeOnSnowPlane(snowPlane, ro, rd, pFlake)\n      && (!rayIntersectsStick || snowPlane<-3.2)) {\n        fragColor = vec4(getIlluminationBrightness(pFlake));\n\n      }\n    }\n  }\n\n}","name":"Image","description":"","type":"image"}]}