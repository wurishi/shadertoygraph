{"ver":"0.1","info":{"id":"ssKcD3","date":"1655842921","viewed":96,"name":"Wsh - Simplex Noise","username":"Wonshtrum","description":"Simplex noise and layered noise","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["noise","simplex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 permute(vec3 x){\n    return mod(((x*34.0)+1.0)*x,289.0);\n}\nvec3 taylorInvSqrt(vec3 r){\n    return 1.79284291400159-0.85373472095314*r;\n}\nfloat snoise(vec2 P){\n    const vec2 C = vec2(0.211324865405187134,//(3.0-sqrt(3.0))/6.0;\n                        0.366025403784438597);//0.5*(sqrt(3.0)-1.0);\n    //Firstcorner\n    vec2 i  = floor(P+dot(P,C.yy));\n    vec2 x0 = P-i+dot(i,C.xx);\n    //Othercorners\n    vec2 i1;\n    i1.x = step(x0.y,x0.x);//1.0ifx0.x>x0.y,else0.0\n    i1.y = 1.0-i1.x;\n    //x1=x0-i1+1.0*C.xx;x2=x0-1.0+2.0*C.xx;\n    vec4 x12 = x0.xyxy+vec4(C.xx,C.xx*2.0-1.0);\n    x12.xy -= i1;\n    //Permutations\n    i = mod(i,289.0);//Avoid truncation in polynomial evaluation\n    vec3 p = permute(permute(i.y+vec3(0.0,i1.y,1.0))\n            +i.x+vec3(0.0,i1.x,1.0));\n    //Circularly symmetric blending kernel\n    vec3 m = max(0.5-vec3(dot(x0,x0),dot(x12.xy,x12.xy),\n                 dot(x12.zw,x12.zw)),0.0);\n    m=m*m;\n    m=m*m;\n    //Gradients from 41 points on a line, mapped on to a diamond\n    vec3 x  = fract(p*(1.0/41.0))*2.0-1.0;\n    vec3 gy = abs(x)-0.5;\n    vec3 ox = floor(x+0.5);//round(x)isaGLSL1.30feature\n    vec3 gx = x-ox;\n    //Normalise gradient simplicitly by scaling m\n    m *= taylorInvSqrt(gx*gx+gy*gy);\n    //Compute final noise value at P\n    vec3 g;\n    g.x  = gx.x*x0.x+gy.x*x0.y;\n    g.yz = gx.yz*x12.xz+gy.yz*x12.yw;\n    //Scale output to span range[-1,1]\n    //(scaling factor determined by experiments)\n    return 130.0*dot(m,g);\n}\n\nfloat lnoise(vec2 P, int n){\n    float s = 0.0;\n    float r = 0.0;\n    for (int i = 0; i<n ; i++) {\n        float e = 1.0/float(1<<i);\n        s += e;\n        r += snoise(P/e)*e;\n    }\n    return r/s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float s1 = 0.01;\n    vec2 coords = fragCoord+100.0;\n    vec2 delta = vec2(\n        lnoise(coords*s1, 5),\n        lnoise(coords.yx*s1, 5));\n    coords = (coords+delta*50.0)*0.005;\n    float v = lnoise(coords, 5)*0.5+0.5;\n    v = v > 0.5 ? v : 0.0;\n    const float l = 10.0;\n    v = floor(v*l)/l;\n    fragColor = vec4(v);\n}","name":"Image","description":"","type":"image"}]}