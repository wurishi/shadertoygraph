{"ver":"0.1","info":{"id":"DdycDw","date":"1696177578","viewed":38,"name":"FDTD bend mixed formulation","username":"athibaul","description":"Using a mixed formulation of acoustic waves (pressure + velocity) for FDTD simulation of a bent tube + some advection","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["tube","bend","fdtd","acoustics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Inspired by https://www.shadertoy.com/view/mdycWW\n// but using a more stable formulation\n\n\nMain {\n    Q = A(U);\n    Q = 50.*(max(Q.z*vec4(1.,0.2,-1.,0.),0.) + 0.03 * abs(Q.z) * vec4(1,1,1,0));\n    Q = 1.-exp(-Q);\n    //Q = sqrt(Q);\n    Q += 0.5*(1.-TUBE(U));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float init (vec2 u, float t) {\n    return float(u.y < 0. && (u.x)*1.02<-(1.-28./R.x))*exp(-.2*t)*smoothstep(0.,10.,t);\n    //u -= vec2(-0.5,0.5); return 1.*exp(-1000.*dot(u,u)) * smoothstep(1.,0.,t);\n}\n\nMain {\n    Q = A(U);\n    \n    vec4 c = A(U);\n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    \n    // p is inside the volume of the cell, vx is at the left edge, vy is at the bottom edge\n    // dP/dt = -div(V)\n    \n    Q.z -= dt * (e.x-c.x + n.y-c.y);\n    \n    // dV/dt = -grad(P)\n    // Kill any pressure or velocity that goes outside the tube\n    Q.z = mix(Q.z, 1., init(uu(U), float(iFrame)));\n    Q.z *= TUBE(U);\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define R iResolution.xy\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texelFetch(iChannel1,ivec2(U),0)\n#define C(U) texelFetch(iChannel2,ivec2(U),0)\n#define uu(U) (2.*(floor(U)-.5*R)/R.y)\n#define TUBE(U) tubeF(uu(U))\n\n#define pi 3.14159265359\n#define ei(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n\n#define ADVECTION 0.5\n#define ABSORBING_BC\n\nconst float dt = 1./sqrt(2.);\n\nfloat tubeF(vec2 u) {\n    u *= 1.02;\n    if (abs(u.x)>1.||abs(u.y)>1.) return 0.;\n    if (u.x < 0.) {\n        return (abs(u.y)>.15) ? 1. : 0.;\n    }\n    return (abs(length(u)-.575) < .425) ? 1. : 0.;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"Main {\n    // Advection of the pressure\n    Q = A(U);\n    vec2 v = A(U).xy * ADVECTION;\n    Q.z = texture(iChannel0,(U - v)/R).z;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"Main {\n    Q = A(U);\n    \n    // Make sure to use the updated pressure calculated by Buffer A!\n    vec4 c = A(U);\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n    \n    Q.x -= dt * (c.z-w.z);\n    Q.y -= dt * (c.z-s.z);\n    \n    Q.x *= TUBE(U) * TUBE(U-vec2(1,0));\n    Q.y *= TUBE(U) * TUBE(U-vec2(0,1));\n    \n    // It's also very easy to make a basic absorbing boundary condition here\n    #ifdef ABSORBING_BC\n    vec2 u = uu(U);\n    if(u.y > 0. && u.x < -0.95) {\n        Q.y = 0.;\n        Q.x = -c.z;\n    }\n    #endif\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"Main {\n    // Advection of the velocity\n    Q = A(U);\n    vec2 v = A(U).xy * ADVECTION;\n    Q.xy = texture(iChannel0,(U - v)/R).xy;\n}","name":"Buffer D","description":"","type":"buffer"}]}