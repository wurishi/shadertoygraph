{"ver":"0.1","info":{"id":"4csGzs","date":"1703377952","viewed":48,"name":"Truchets study 2","username":"Elsio","description":"Não é só mudar o código. É, primeiro, tentar entender o que o cara fez. E enquanto a gente refaz a gente entende alguma coisa. ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","refraction","truchet","aa"],"hasliked":0,"parentid":"XflGzs","parentname":"Truchets (and domain rep) study"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot(a) mat2(cos(a + vec4(0, 11, 33, 0)))\n#define PI 3.14\n#define PI2 6.28\n#define t iTime\n#define SIZE vec3(1.5)\n#define HLF (SIZE / 2.)\n\nfloat lsp(float b, float e, float t) {\n    return clamp((t - b) / (e - b), 0., 1.);\n}\n\nfloat eoc(float t) {\n    t --;\n    return t * t * t + 1.;\n}\n\nfloat box(vec3 p, vec3 b) {\n    return length(max(b = abs(p) - b, 0.)) + min(max(b.x, max(b.y, b.z)), 0.);\n}\n\n\nfloat torus(vec3 p) {\n    vec2 q = vec2(length(p.zx) - HLF.x, p.y);\n    return length(q) - .1;\n}\n\nfloat closestWall(vec3 p) {\n    vec3 d = min(fract(p), 1. - fract(p));\n    return min(min(d.x, d.y), d.z);\n}\n\n\nfloat map(vec3 p) {\n    p.yz *= rot(t * .07);\n    p.xz *= rot(t * .06);\n    p.xz *= rot(1.57);\n    \n    float tmod = mod(t * 1.6, 25.),\n          res = 1e5,\n          sn, t1, t2, ret,\n          trh, trx, jre;\n    \n    vec3 GRID = vec3(1, 1, 2),\n         id = floor((p + HLF) / SIZE) + GRID,\n         q = p - SIZE * clamp(round(p / SIZE), - GRID, GRID);\n    \n    if(true){\n        \n        t1 = lsp(sn     , sn +  2., tmod); \n        t1 = eoc(t1); \n        t1 = t1 * t1 * t1;\n\n        t2 = lsp(sn + 8., sn + 10., tmod); \n        t2 = eoc(t2); \n        t2 = t2 * t2 * t2;\n\n        mod(id.y + mod(id.z + id.x, 2.), 2.) * 2. - 1. > .5\n            ? q.zx *= rot((t1 - t2) * 1.57)\n            : q.xy *= rot((t1 - t2) * 1.57);\n    }\n    \n    else{\n    \n        if(id == floor(vec3(1, 1, 2)))\n            q.yx *= rot(5. * t);\n    }\n        \n    \n    trh = torus((vec3(0, HLF.x, -HLF.y) + q).yxz);\n    trx = torus(vec3(HLF.x, 0, HLF.z) + q);\n    jre = torus((q - vec3(HLF.xy, 0)).yzx);\n    \n    ret = max(\n               abs(min(trx, min(trh, jre))) - .03, \n               box(q, HLF * .98)\n           );\n           \n    return ret;\n}\n\n\n\n\n\n\n\nvoid mainImage(out vec4 o, vec2 u) {\n    vec3 R = iResolution, q, p,\n         D = (vec3(u, R.y) - R/2.) / R.y;\n    float d, s, f, i, j;\n    \n    o *= i; \n    p.z = -6.7;\n    \n    while(i++ < 64.) {\n        q = p + d * D;\n        \n        s = map(q) * .8;\n        \n        s = abs(s) - .0, \n        f = 1. - s * 2e2, \n        f > .01 \n            ? o += f / d * i / 310. \n            : o;\n        \n        d += max(s, 2e-3);\n    }\n     \n    o *= vec4(1, 1, 1.3, 0) / 1.7;\n}\n","name":"Image","description":"","type":"image"}]}