{"ver":"0.1","info":{"id":"wl2XW1","date":"1573338438","viewed":75,"name":"Raymarcher with lighting","username":"thiezar","description":"simple raymarcher implementing lighting inspired by iquilez video sessions","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","lighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 20.\n#define MIN_DIST .001\n#define MAX_ITER 100\n\nfloat sdSphere(in vec3 p , vec3 c, float r){\n    return length(p-c)-r;\n}\nfloat sdPlane(in vec3 p, float h){\n    return p.y-h;\n}\n\nfloat sdBox(in vec3 p, vec3 c, vec3 s){\n    return length(max(abs(p-c)-s, 0.0));\n}\n\nfloat opUnion(float d1, float d2){\n    return min(d1, d2);\n}\n\nfloat opDiff(float d1, float d2){\n    return max(-d1, d2);\n}\n\nvec3 opRepeat(vec3 p, vec3 c){\n    return mod(p,c)-0.5*c;\n}\n\nfloat map(in vec3 p){\n    p = opRepeat(p, vec3(1,0,0));\n    float d0 = sdPlane(p, -0.5);\n    float d1 = sdSphere(p, vec3(0,0,0), 0.65);\n    float d2 = sdBox(p, vec3(0,0,0), vec3(0.5));\n    float d3 = sdSphere(p, vec3(0,0,0), 0.2);\n    float d = opDiff(d1,d2);\n    d = opUnion(d, d3);\n    d = opUnion(d0,d);\n\t\n    return d;\n}\nvec3 sNormal(in vec3 p){\n    float e = 0.001;\n    float d = map(p);\n    float xd = map(p+vec3(e,0,0));\n    float yd = map(p+vec3(0,e,0));\n    float zd = map(p+vec3(0,0,e));\n    vec3 n = (vec3(xd,yd,zd)-d)/e;\n    return n;\n}\n\nfloat castRay(vec3 ro, vec3 rd){\n    float t = 0.0; // marching distance on ray\n    for(int i=0; i<MAX_ITER; i++){\n        vec3 p = ro + t*rd; // marching point\n        float h = map(p);\t// hit distance\n        if(h<MIN_DIST) break;\n        t+=h;\n        if(t>MAX_DIST) break;\n    }\n    if(t>MAX_DIST) t = -1.0;\n    return t;\n}\n\nfloat castShadow(in vec3 ro, vec3 rd){\n    float shadow = 1.0;\t// 1.0 = no shadow\n    float t = MIN_DIST; // marching distance on ray\n    for(int i=0; i < MAX_ITER; i++){\n        vec3 p = ro + t*rd; // marching point\n        float h = map(p); // hit distance\n        shadow = min(shadow, 10.*h/t);\n        t+=h;\n        if(t>MAX_DIST) break;\n    }\n    return shadow;\n}\n\nvec3 camera(in vec2 uv, in vec3 ro, vec3 ta, float fd){\n    vec3 up = vec3(0,1,0); // global up vector\n    vec3 ww = normalize(ta-ro); // direction to the target\n    vec3 uu = normalize(cross(ww, up)); // camera right direction\n    vec3 vv = normalize(cross(uu, ww)); // camera up direction\n    \n    vec3 rd = normalize(uv.x*uu + uv.y*vv + fd*ww); // camera direction to uv\n    return rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy)-.5; // normalized pixel coordinates (from 0 to 1)\n    uv.x *= iResolution.x/iResolution.y; // adjust aspect ratio\n\t\n    float a = 10.0 * iMouse.x/iResolution.x;\n    float taDist = 2.0; // target distance\n    vec3 ro = vec3(taDist*sin(a),iMouse.y/iResolution.y,taDist*cos(a)); // camera origin\n    vec3 ta = vec3(0,0,0); // target\n    \n    vec3 rd = camera(uv, ro, ta, 1.0);\n    \n    vec3 col = vec3(0.4,0.7,1.0) - 0.5*rd.y; // sky color\n    col = mix(col, vec3(0.7, 0.75, 0.8), exp(-10.0*rd.y)); // horizon color \n    if(rd.y<-0.1) col = vec3(0.2);\n    \n    float t = castRay(ro, rd);\n    \n    if(t>0.0){ // we hit something\n        vec3 pos = ro + t*rd;\n        vec3 nor = sNormal(pos);\n        \n        vec3 mat = vec3(0.18);\t// albedo\n        \n        vec3 sunDir = normalize(vec3(0.8,0.4,0.2));\n        float sunDif = clamp(dot(nor, sunDir), 0.0, 1.0);\n        float sunShadow = castShadow(pos+nor*MIN_DIST, sunDir);\n        float skyDif = clamp(0.5 + 0.5*dot(nor, vec3(0,1,0)), 0.0, 1.0);\n        float bouDif = clamp(dot(nor, vec3(0,-1,0)), 0.0, 1.0);\n        col = mat * vec3(7.0,5.0,3.0) * sunDif * sunShadow; // sun color\n        col += mat * vec3(0.5,0.8,0.9) * skyDif; // sky color\n        col += mat * vec3(0.7, 0.5, 0.3) * bouDif; // bounce color\n    }\n    \n    col = pow(col, vec3(0.4545)); // gamma correction\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}