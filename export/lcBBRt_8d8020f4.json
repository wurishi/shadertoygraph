{"ver":"0.1","info":{"id":"lcBBRt","date":"1725339288","viewed":2,"name":"Platonic Solids + Refraction II","username":"vmohit","description":"Added some animations on top of this shader: https://www.shadertoy.com/view/4cGXR3","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","platonicsolids"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// experiment with different ways of lighting like refraction, reflection, etc.\n\n// this code was written by learning and referring from these sources\n// https://www.youtube.com/watch?v=NCpaaLkmXI8&ab_channel=TheArtofCode\n// https://www.youtube.com/watch?v=Ff0jJyyiVyw&list=PLGmrMu-IwbgtMxMiV3x4IrHPlPmg7FD-P&ab_channel=TheArtofCode\n// https://www.shadertoy.com/view/WtGXDD\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define MIN_SURF_DIST 0.01\n#define REFRACTION_MAX_STEPS 100\n#define PI 3.141592\n\nmat2 RotationMatrix(float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\n/*A sphere's signed distance field. Can be used to render spheres in 3d*/\nfloat sphereSDF(vec3 targetPoint, vec3 sphereCenter, float radius) {\n    return length(targetPoint - sphereCenter) - radius;\n}\n\n/*A 2d plane's signed distance field in 3d*/\nfloat planeSDF(vec3 targetPoint, vec3 pointOnPlane, vec3 planeNormalVector) {\n    return dot(targetPoint - pointOnPlane, planeNormalVector);\n}\n\n/*Plane SDF given three points on the plane. Order of the points decides\nthe orientation. Normal is given by cross product of (p2 - p1) x (p3 - p2)\n*/\nfloat planeSDF(vec3 targetPoint, vec3 point1, vec3 point2, vec3 point3) {\n    vec3 normalVector = normalize(cross(point2-point1, point3-point2));\n    return planeSDF(targetPoint, point1, normalVector);\n}\n\nfloat capsuleSDF(vec3 targetPoint, vec3 pointA, vec3 pointB, float radius) {\n    vec3 vectorAtoB = pointB - pointA;\n    vec3 vectorAtoTarget = targetPoint - pointA;\n\n    // t is the linear interpolation co-efficient between a and b\n    // it represents the closest point to the target point on the line segment\n    // the closest point is given as t*b + (1-t)*a\n    float t = dot(vectorAtoTarget, vectorAtoB) / dot(vectorAtoB, vectorAtoB);\n    t = clamp(t, 0.0, 1.0);\n    vec3 closestPointToTargetOnLineSegment = t * pointB + (1.0 - t) * pointA;\n    return length(targetPoint - closestPointToTargetOnLineSegment) - radius;\n}\n\nfloat torusSDF(vec3 targetPoint, vec3 torusCenter, vec3 torusPlaneNormal, float torusRadius, float torusThickness) {\n    // idea: distance from torus = distance of target point from the closest point on the ring - radius\n    // project the parget point onto the plane of the torus. Call projected point p\n    // closest point on the ring is radius * unit vector from center to p\n\n    vec3 centerToTargetPoint = targetPoint - torusCenter;\n    vec3 centerToProjectedPoint = centerToTargetPoint - dot(centerToTargetPoint, torusPlaneNormal) * torusPlaneNormal;\n    vec3 closestPointOnRingToTheTarget = torusCenter + torusRadius * normalize(centerToProjectedPoint);\n    return length(targetPoint - closestPointOnRingToTheTarget) -  torusThickness;\n}\n\nfloat boxSDF(vec3 targetPoint, vec3 boxCenter, vec3 boxDimensions) {\n    vec3 positionRelativeToBoxCenter = targetPoint - boxCenter;\n    vec3 weirdVectorThatICantGiveAGoodName = abs(positionRelativeToBoxCenter) - boxDimensions / 2.0;\n\n    // 2nd term is for when the point is inside the box so we should return negative distance\n    // if we don't do this, we get spooky (but cool!) artifacts on the box's surface\n    return length(max(weirdVectorThatICantGiveAGoodName, 0.0))\n        + min(max(max(weirdVectorThatICantGiveAGoodName.x, weirdVectorThatICantGiveAGoodName.y), \n            weirdVectorThatICantGiveAGoodName.z), 0.);\n}\n\nfloat regularOctahedronSDF(vec3 p) {\n    return planeSDF(abs(p), vec3(1.0, 0.0, 0.0), normalize(vec3(1.0)));\n}\n\nfloat cubeSDF(vec3 p) {\n    return boxSDF(p, vec3(0.0), vec3(1.0));\n}\n\nfloat regularTetrahedronSDF(vec3 p) {\n    // the below code is copied from this shader: https://www.shadertoy.com/view/Ws23zt\n    // strategy: take intersection of two v-shaped infinite trains\n    // one V shaped train going along y=x line with the sharp edge at z=-1\n    // other inverted V shaped train along x+y=0 line with the sharp edge at z = 1\n\n    // v shape is formed by reflecting the plane x - y - z = 1 along y = x plane\n    // the side where x > y is reflected along y = x plane to psate the same thing \n    // in the region where x < y\n    float distanceFromFirstVshape = (abs(p.x-p.y) - p.z - 0.5) / sqrt(3.0);\n\n    // the below inverted V shape is formed in a similar way\n    float distanceFromSecondInvertedVshape = (abs(p.x+p.y) + p.z - 0.5) / sqrt(3.0);\n\n    // take intersection of the two V shaped infinite toblerons\n    return max(distanceFromFirstVshape, distanceFromSecondInvertedVshape);\n}\n\nfloat regularDodecahedronInscribedCubeOppositeFacesSDF(vec3 p) {\n    // this function give SDF of 4 planes corresponding to two opposite faces of the inscribed cube of \n    // regular dodecahedron from this image: https://www.matematicasvisuales.com/images/geometry/space/dodecahedron/zome/DSC_8969.jpg\n\n    // first reflect along both y and z directions\n    vec3 pReflectedAlongYandZ = vec3(p.x, abs(p.y), abs(p.z));\n\n    // now apply the SDF of the plane that is in positive y and z space\n    // it passes through the vertex (1, 1, 1) of the cube\n    // and makes angle (dodecahedron dihedral angle) / 2 with the xz plane\n    float normalAngle = (PI / 2.0) - (PI * 116.56505 / 180.0) / 2.0;\n    return planeSDF(pReflectedAlongYandZ, vec3(0.5, 0.5, 0.5), normalize(vec3(0.0, sin(normalAngle), cos(normalAngle))));\n}\n\nfloat regularDodecahedronSDF(vec3 p) {\n    // this video explains why dihedral angle of dodecahedron is 116.56505 = 2 arcsin(cos(36) / cos(18))\n    // https://www.youtube.com/watch?v=PepzbC9I_wI&ab_channel=FredB%27sTechChannel\n    // wow! a cube can be inscribed into a regular dodecahedron! That makes it so much easier!\n    // https://www.matematicasvisuales.com/english/html/geometry/space/dodecahedroncube.html\n    // the below construction is based on this image below taken from the above link\n    // https://www.matematicasvisuales.com/images/geometry/space/dodecahedron/zome/DSC_8969.jpg\n\n    // strategy: break it into intersection of 3 sets of plane.\n    // each set contains 4 planes each and they correspond to a face of the inscribed cube\n\n    float distanceFromPlaneSet1 = regularDodecahedronInscribedCubeOppositeFacesSDF(p);\n\n    // for plane set 2, remap xyz coordinates as follows:\n    // x -> z, y -> -x, z -> -y\n    vec3 remappedCoordinatesForPlaneSet2 = vec3(p.z, -p.x, -p.y);\n    float distanceFromPlaneSet2 = regularDodecahedronInscribedCubeOppositeFacesSDF(remappedCoordinatesForPlaneSet2);\n\n    // for plane set 3, remap xyz coordinates as follows:\n    // x -> y, y -> -z, z -> -x\n    vec3 remappedCoordinatesForPlaneSet3 = vec3(p.y, -p.z, -p.x);\n    float distanceFromPlaneSet3 = regularDodecahedronInscribedCubeOppositeFacesSDF(remappedCoordinatesForPlaneSet3);\n\n    // now intersect to form the regular dodecahedron! tada!\n    return max(distanceFromPlaneSet1, max(distanceFromPlaneSet2, distanceFromPlaneSet3));\n}\n\nfloat pentagonalPyramidCapOfIcosahedronSDF(vec3 p) {\n    // returns SDF for the pentagonal pyramid cap with the corner at (0, 1, 0)\n    // reflect around yz plane to take advantage of some symmetry\n    vec3 pReflectedOnYZplane = vec3(abs(p.x), p.y, p.z);\n\n    // now draw the three planes in brute force fashion\n    vec3 topVertex = vec3(0.0, 1.0, 0.0);\n    \n    float theta = atan(0.5, 1.0); // computed on paper\n\n    // vertices on the base of the cap in counter-clockwise orientation. Starting from the vertex with 0 x-coordinate\n    vec3 p1 = vec3(0.0, sin(theta), cos(theta));\n    vec3 p2 = vec3(cos(theta) * sin(2.0 * PI / 5.0), sin(theta), cos(theta) * cos(2.0 * PI / 5.0));\n    vec3 p3 = vec3(cos(theta) * sin(PI / 5.0), sin(theta), -cos(theta) * cos(PI / 5.0));\n    vec3 p4 = vec3(-cos(theta) * sin(PI / 5.0), sin(theta), -cos(theta) * cos(PI / 5.0));\n\n    // take intersection of the three plane sdfs on the reflected point\n    return max(\n            planeSDF(pReflectedOnYZplane, topVertex, p1, p2),\n            max(\n                planeSDF(pReflectedOnYZplane, topVertex, p2, p3),\n                planeSDF(pReflectedOnYZplane, topVertex, p3, p4)\n            )\n        );\n}\n\nfloat regularIcosahedronSDF(vec3 p) {\n    // TODO: use symmetry more and simplify the code\n    // strategy: use brute force to calculate each point and construct planes while using some symmetry\n    // assume the icosahedron is inscribed in unit circle.\n    // points (0, 1, 0) and (0, -1, 0) are the extremes endpoints repsenting the corners of the two pentagonal pyramid caps\n    // then there are two flipped bases of pentagonal pyramids at heights sin(theta) and sin(-theta)\n    // theta is calculated on paper and it turns out to be = arctan(0.5)\n    \n    // reflect in yz plane to take advantage of symmetry\n    vec3 pReflectedOnYZplane = vec3(abs(p.x), p.y, p.z);\n\n    float distanceFromTopCap = pentagonalPyramidCapOfIcosahedronSDF(p);\n\n    float theta = atan(0.5, 1.0); // computed on paper\n    \n    // just brute force reflect the cap around 3 planes (one for each side of the pentagon base of the cap)\n    // vertices on the base of the cap in counter-clockwise orientation. Starting from the vertex with 0 x-coordinate\n    vec3 p1 = vec3(0.0, sin(theta), cos(theta));\n    vec3 p2 = vec3(cos(theta) * sin(2.0 * PI / 5.0), sin(theta), cos(theta) * cos(2.0 * PI / 5.0));\n    vec3 p3 = vec3(cos(theta) * sin(PI / 5.0), sin(theta), -cos(theta) * cos(PI / 5.0));\n    vec3 p4 = vec3(-cos(theta) * sin(PI / 5.0), sin(theta), -cos(theta) * cos(PI / 5.0));\n\n    // reflect along the plane (p1, p2, origin). Map all points with negative distance onto their reflected image with negative distance\n    vec3 normal1 = normalize(cross(p2-p1, vec3(0.0)-p2));\n    vec3 pReflectedOnPlane1 = pReflectedOnYZplane - 2.0 * normal1 * min(0.0, dot(normal1, pReflectedOnYZplane));\n    float distanceFromCap1 = pentagonalPyramidCapOfIcosahedronSDF(pReflectedOnPlane1);\n\n    // do the same thing for cap2\n    vec3 normal2 = normalize(cross(p3-p2, vec3(0.0)-p3));\n    vec3 pReflectedOnPlane2 = pReflectedOnYZplane - 2.0 * normal2 * min(0.0, dot(normal2, pReflectedOnYZplane));\n    float distanceFromCap2 = pentagonalPyramidCapOfIcosahedronSDF(pReflectedOnPlane2);\n\n    // finally one more time for cap3!\n    vec3 normal3 = normalize(cross(p4-p3, vec3(0.0)-p4));\n    vec3 pReflectedOnPlane3 = pReflectedOnYZplane - 2.0 * normal3 * min(0.0, dot(normal3, pReflectedOnYZplane));\n    float distanceFromCap3 = pentagonalPyramidCapOfIcosahedronSDF(pReflectedOnPlane3);\n\n    // take intersection of all caps to obtain the final icosahedron distance!\n    float icosahedronDistance = max(distanceFromTopCap, max(distanceFromCap1, max(distanceFromCap2, distanceFromCap3)));\n\n    return icosahedronDistance;\n}\n\nvec3 setMaxToZero(vec3 v) {\n    // sets the max element of the vector to 0 but only if its between 0 and 1.1\n    float maxVal = clamp(max(max(v.x, v.y), v.z), 0.0, 1.1);\n    return vec3(v.x == maxVal ? 0.0 : v.x, v.y == maxVal ? 0.0 : v.y, v.z == maxVal ? 0.0 : v.z);\n}\n\n\nfloat GetDistanceFromSurface(vec3 point) {\n    // float shapeDist = sphereSDF(point, vec3(0.0), 0.8);\n    // float shapeDist = capsuleSDF(point, vec3(0.0, -0.7, -0.7), vec3(0.7, 0.0, 0.7), 0.2);\n    // float shapeDist = torusSDF(point, vec3(0.0), normalize(vec3(0.0, 0.0, 1.0)), 0.8, 0.2);\n    //float shapeDist = boxSDF(point, vec3(0.0), vec3(1.0, 0.5, 1.5));\n\n    // float shapeDist = regularOctahedronSDF(point);\n    // float shapeDist = cubeSDF(point);\n    // float shapeDist = regularTetrahedronSDF(point);\n    // float shapeDist = regularDodecahedronSDF(point);\n    // float shapeDist = regularIcosahedronSDF(point);\n\n    float currTime = mod(iTime, 15.0);\n\n    float shapeDist = 1.0;\n    if (currTime < 2.0) {\n        shapeDist = regularIcosahedronSDF(point);\n    }\n    else if (currTime < 3.0) {\n        float d1 = regularIcosahedronSDF(point);\n        float d2 = regularDodecahedronSDF(point);\n        shapeDist = mix(d1, d2, currTime - 2.0);\n    }\n    else if (currTime < 5.0) {\n        shapeDist = regularDodecahedronSDF(point);\n    }\n    else if (currTime < 6.0) {\n        float d1 = regularDodecahedronSDF(point);\n        float d2 = regularOctahedronSDF(point);\n        shapeDist = mix(d1, d2, currTime - 5.0);\n    }\n    else if (currTime < 8.0) {\n        shapeDist = regularOctahedronSDF(point);\n    }\n    else if (currTime < 9.0) {\n        float d1 = regularOctahedronSDF(point);\n        float d2 = regularTetrahedronSDF(point);\n        shapeDist = mix(d1, d2, currTime - 8.0);\n    }\n    else if (currTime < 11.0) {\n        shapeDist = regularTetrahedronSDF(point);\n    }\n    else if (currTime < 12.0) {\n        float d1 = regularTetrahedronSDF(point);\n        float d2 = cubeSDF(point);\n        shapeDist = mix(d1, d2, currTime - 11.0);\n    }\n    else if (currTime < 14.0) {\n        shapeDist = cubeSDF(point);\n    }\n    else {\n        float d1 = cubeSDF(point);\n        float d2 = regularIcosahedronSDF(point);\n        shapeDist = mix(d1, d2, currTime - 14.0);\n    }\n\n    // // visualize grid lines and points\n    // vec3 gridDiffVector = abs(point - clamp(round(point), -2.0, 2.0));\n    // float gridPointsDist = length(gridDiffVector) - 0.02;\n    // float gridLinesDist = length(setMaxToZero(gridDiffVector)) - 0.0005;\n    // float gridDist = min(gridPointsDist, gridLinesDist);\n\n    //float planeDist = planeSDF(point, vec3(0.0, -2.0, 0.0), vec3(0.0, 1.0, 0.0));\n    //float minDistanceFromObjects = min(shapeDist, planeDist);\n\n    // float minDistanceFromObjects = min(shapeDist, gridDist);\n\n    float minDistanceFromObjects = shapeDist;\n\n    return minDistanceFromObjects;\n}\n\nfloat RayMarch(vec3 rayOrigin, vec3 rayDirection, float rayMarchingFromOutside) {\n    // rayMarchingFromOutside must either be +1 or -1\n    // if its +1 then it means the ray origin is outside the surface and we're marching till we hit the surface from outside\n    // if its -1 then it means the ray origin is inside the surface and we're marching till we hit the surface from inside\n\n    float distanceMarchedFromOrigin = 0.0;\n\n    // ray marching loop\n    for (int marchStep=0; marchStep < MAX_STEPS; marchStep++) {\n        vec3 currentLocation = rayOrigin + rayDirection * distanceMarchedFromOrigin;\n        // get a conservative estimate (a.k.a lower bound) of the distance to the scene\n        float distanceLBFromScene = rayMarchingFromOutside * GetDistanceFromSurface(currentLocation); // all shapes in the scene are inside this funciton\n        distanceMarchedFromOrigin += distanceLBFromScene;\n        if ((distanceMarchedFromOrigin > MAX_DIST)  // marched too far\n            || (distanceLBFromScene < MIN_SURF_DIST)) // we are already very close to the surface so no need to march further\n            break;\n    }\n\n    return distanceMarchedFromOrigin;\n}\n\nvec3 GetNormal(vec3 point) {\n    float distanceFromSurface = GetDistanceFromSurface(point);\n    vec2 epsilon = vec2(0.01, 0.0);\n\n    vec3 normal = vec3(\n        GetDistanceFromSurface(point + epsilon.xyy),\n        GetDistanceFromSurface(point + epsilon.yxy),\n        GetDistanceFromSurface(point + epsilon.yyx)\n    ) - distanceFromSurface;\n\n    return normalize(normal);\n}\n\n// lights up the scene using light from a point source\nfloat GetLightFromPointLightSource(vec3 pointOnSurface, vec3 pointLightSourceLocation) {\n\n    vec3 lightVector = normalize(pointLightSourceLocation - pointOnSurface);\n\n    vec3 surfaceNormal = GetNormal(pointOnSurface);\n\n    float diffusedLighting = clamp(dot(surfaceNormal, lightVector), 0.0, 1.0);\n\n    // add shawdows by ray marching from the surface to the light and see if\n    // the distance is less than shortest path between the light and the point\n    // if it is then it means we hit something in between and the point should be in the shadow\n    // move away from the surface a little before starting the ray march or else\n    // the second ray march loop will exit right away as the loop break condition is already met\n    float rayMarchDistanceFromPointToLight = RayMarch(pointOnSurface + surfaceNormal * MIN_SURF_DIST * 2.0, lightVector, 1.0);\n\n    if (rayMarchDistanceFromPointToLight < length(pointLightSourceLocation - pointOnSurface)) {\n        diffusedLighting *= 0.1;\n    }\n\n    return diffusedLighting;\n}\n\n// light up with scene by combining all light sources\nfloat GetLight(vec3 pointOnSurface) {\n    vec3 pointLightSource1_Location = vec3(1, 1, 1) * 3.0; \n    vec3 pointLightSource2_Location = vec3(1, -1, -1) * 3.0; \n    vec3 pointLightSource3_Location = vec3(-1, 1, -1) * 3.0; \n    vec3 pointLightSource4_Location = vec3(-1, -1, 1) * 3.0; \n\n    float lightFromSource1 = GetLightFromPointLightSource(pointOnSurface, pointLightSource1_Location);\n    float lightFromSource2 = GetLightFromPointLightSource(pointOnSurface, pointLightSource2_Location);\n    float lightFromSource3 = GetLightFromPointLightSource(pointOnSurface, pointLightSource3_Location);\n    float lightFromSource4 = GetLightFromPointLightSource(pointOnSurface, pointLightSource4_Location);\n\n    return lightFromSource1 + lightFromSource2 + lightFromSource3 + lightFromSource4;\n}\n\n/* Given the centered and aspect resolution corrected pixel location, return the ray direction that passes through\nthat pixel location if the ray originated from rayOrigin and the camera was oriented such that\nits center pointed to the centerLocation. zoomFactor is how far away from camera is the projection plane.\nincreasing zoomFactor zooms the image by moving the projective plane away from the raOrigin\n*/\nvec3 GetRayDirection(vec2 originalPixelLocation, vec3 rayOrigin, vec3 centerLocation, float zoomFactor) {\n    vec3 zAxisDirection = normalize(centerLocation - rayOrigin);\n    // vec3(0, 1, 0) is the default y-axis direction so if zAxisDirection happens to coincide\n    // with the actual z-axis (i.e. vec(0, 0, 1)) then x-axis will coincide with the actual\n    // x-axis vec(1, 0, 0)\n    vec3 xAxisDirection = normalize(cross(vec3(0, 1, 0), zAxisDirection));\n    vec3 yAxisDirection = cross(zAxisDirection, xAxisDirection);\n    return normalize(originalPixelLocation.x * xAxisDirection \n        + originalPixelLocation.y * yAxisDirection\n        + zoomFactor * zAxisDirection);\n}\n\n\n/* This function simulates the refraction and total internal reflection on the ray and spits out the transformed ray. \nINPUTS:\npointOnSurface : point on the surface where the ray enters\nrayDirection : direction of the entering ray\nindexOfRefraction : index of refraction of the material\n    index of refraction depends on material. Related to ratio between between the speed of light in vacuum v/s the speed of light in the medium. \n    TODO: investigate further.\n    it is > 1 when the light enter from a less dense material into a denser material. It is < 1 otherwise\n    it is 1 for vacuum and increases as the material becomes more dense. Some sample values\n    vacuum -> 1, air -> 1.01, water -> 1.33, glass -> 1.45, diamond -> 2.4\n\nOUTPUT:\nvec4 object \"refractionOutput\" such that:\n    refractionOutput.xyz is outputrayDirectionOutOfObject : direction at which the ray outputs the object\n    refractionOutput.w is optical distance\n*/\nvec4 RefractRay(vec3 pointOnSurface, vec3 rayDirection, float indexOfRefraction) {\n    // refract the ray at the point of entry\n    vec3 surfaceNormal = GetNormal(pointOnSurface);\n\n    // third parameter in the function below is: (IOR of source material) / (IOR of destination material). I think. Not sure how exactly the below thing works too.\n    vec3 refractedRayDirection = refract(rayDirection, surfaceNormal, 1.0 / indexOfRefraction);\n\n    // loop until we're able to refract out of the object\n    // until then, keep total internal reflecting the ray\n\n    vec3 rayDirectionOutOfObject = vec3(0.0);\n    // nudge the point form where we start the ray march a little bit inside of the object or else the ray march loop will exit right away\n    vec3 rayMarchingStartPoint = pointOnSurface - surfaceNormal * MIN_SURF_DIST * 3.0;\n\n    // keep track of the total distance traversed inside the object to apply dimming effect based on density\n    float opticalDistance = 0.0;\n\n    for (int refractionStep=0; refractionStep < REFRACTION_MAX_STEPS; refractionStep++) {\n        // now that we are in the object, simulate another refraction when the ray goes outside of the object\n        // ray march from the point inside the object where the light is refracted to find the \n        // closest point inside the object in the new refracted ray direction\n        float distanceToSurfaceFromInside = RayMarch(rayMarchingStartPoint, refractedRayDirection, -1.0);\n        opticalDistance += distanceToSurfaceFromInside;\n\n        vec3 potentialExitPoint = rayMarchingStartPoint + refractedRayDirection * distanceToSurfaceFromInside;\n        vec3 normalAtPotentialExitPoint = -1.0 * GetNormal(potentialExitPoint); // flip the normal since we're going from inside to outside\n        rayDirectionOutOfObject = refract(refractedRayDirection, normalAtPotentialExitPoint, indexOfRefraction);\n\n        if (length(rayDirectionOutOfObject) == 0.0) {\n            // need to simulate total internal reflection since the refract function outputted 0 vector\n            refractedRayDirection = reflect(refractedRayDirection, normalAtPotentialExitPoint);\n            rayMarchingStartPoint = potentialExitPoint + normalAtPotentialExitPoint * MIN_SURF_DIST * 3.0;\n        }\n        else {\n            break;\n        }\n    }\n\n    if (length(rayDirectionOutOfObject) == 0.0) {\n        // if there was too much total internal reflection and we couldn't get the ray out of the object \n        // then pick the last refracted ray direction as the way out\n        rayDirectionOutOfObject = refractedRayDirection;\n    }\n\n    vec4 refractionOutput = vec4(rayDirectionOutOfObject, opticalDistance);\n\n    return refractionOutput;\n}\n\n/*\nThis function is called for each value of pixelCoordinate on the screen to compute its color\n\nbottom left is (0, 0) and top right is (800, 450), assuming the screensize is 800 x 450\n\noutputPixelColor has 4 dimensions: Red, Green, Blue, Alpha. \nAlpha is transparency level where 0.0 means fully transparent (invisible) and 1.0 means fully opaque (solid).\nRGB vary from 0 to 1, so (0, 0, 0) is black and (1, 1, 1) is white\n*/\nvoid mainImage(out vec4 outputPixelColor, in vec2 pixelCoordinate)\n{\n    // center on origin and make y vary from -0.5 to 0.5\n    // iResolution is (800, 450) if that is the resolution\n    vec2 originalPixelLocation = (pixelCoordinate - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // iMouse is the location of mouse\n    vec2 mouseLocation = iMouse.xy / iResolution.y;\n    // // move mouse clockwise along rectangle with a period of 15 seconds\n    vec2 point1 = vec2(0.0, 0.4);\n    vec2 point2 = vec2(-0.4, 0.4);\n    vec2 point3 = vec2(-0.4, 0.6);\n    vec2 point4 = vec2(0.0, 0.6);\n    float tm = mod(iTime, 15.0);\n    if (tm < 15.0 / 4.0) {\n        mouseLocation = mix(point1, point2, tm / (15.0 / 4.0));\n    }\n    else if (tm < 2.0 * 15.0 / 4.0) {\n        mouseLocation = mix(point2, point3, (tm - 15.0 / 4.0) / (15.0 / 4.0));\n    }\n    else if (tm < 3.0 * 15.0 / 4.0) {\n        mouseLocation = mix(point3, point4, (tm - 2.0 * 15.0 / 4.0) / (15.0 / 4.0));\n    }\n    else {\n        mouseLocation = mix(point4, point1, (tm - 3.0 * 15.0 / 4.0) / (15.0 / 4.0));\n    }\n    \n    // some adjustments to make the mouse control a bit less painful\n    mouseLocation.y = 0.42 * mouseLocation.y + 0.9 * (1.0 - mouseLocation.y);  // clamp(mouseLocation.y, 0.42, 0.9);\n    \n    // start from black canvas\n    vec3 pixelColor = vec3(0);\n    \n    // camera is at this position and looking towards origin\n    vec3 cameraPosition = vec3(0., 0., -3.);\n    // moving mouse along y axis rotates around x axis\n    // moving mouse down rotates camera position in clockwise direction when looking in the direction of x-axis\n    cameraPosition.yz *= RotationMatrix(-mouseLocation.y * 2.0 * PI + 1.0);\n    // moving mouse along x axis rotates around y axis\n    // moving mouse left rotates camera position in clockwise direction when looking in the direction of y-axis\n    cameraPosition.xz *= RotationMatrix(-mouseLocation.x * 1.1 * PI);\n\n    // imagine if camera was at origin and the shader screen was \n    // parallel to xy plane and centered at x=0, y=0, z=1\n    // then the vector from camera (origin) to the pixel would be\n    // the direction of the ray corresponding to that pixel\n    // x is negative to account for x-axis being to the left isntead of right\n    vec3 rayDirection = GetRayDirection(originalPixelLocation, cameraPosition, vec3(0., 0., 0.), 1.0);\n\n    // ray march from the camera position into the ray direction and find the distance to the object in that direction\n    float distanceToSurface = RayMarch(cameraPosition, rayDirection, 1.0);\n\n    // weird how this texture works! TODO: investigate\n    pixelColor = texture(iChannel0, rayDirection).rgb;\n\n    if (distanceToSurface < MAX_DIST) {\n        vec3 pointOnSurface = cameraPosition + rayDirection * distanceToSurface;\n        vec3 surfaceNormal = GetNormal(pointOnSurface);\n\n        // //////////////////////////// use this for point lights        \n        //float diffusedLighting = GetLight(pointOnSurface);\n        ////////////////////////////////////////////\n        \n        // //////////////////////////// use this for simulating beam of light comming from infinity. Like sunrays\n        // float diffusedLighting = dot(surfaceNormal, normalize(vec3(1, 2, 3))) * 0.5 + 0.5;\n\n        // pixelColor = vec3(diffusedLighting);\n        // pixelColor = pow(pixelColor, vec3(0.4545)); // gamma correction. What??? TODO: look into this\n        ////////////////////////////////////////////\n\n        // //////////////////////////// use this to cover the object with mirror\n        // vec3 reflectedRayDirection = reflect(rayDirection, surfaceNormal);\n        // pixelColor = texture(iChannel0, reflectedRayDirection).rgb;  // why does this work? TODO: have a good explanation for why it works\n        ////////////////////////////////////////////\n\n        // //////////////////////////// use this to visualize surface normal\n        // pixelColor = surfaceNormal * 0.5 + 0.5;\n        ////////////////////////////////////////////\n\n        //////////////////////////// use this for refraction\n\n        float chromaticAbberation = 0.005;\n        float density = 0.05; // for denser objects, more light will be lost the more time it spends inside the object during refraction\n        float redIOR = 1.77;\n        vec3 rubyColor = vec3(0.88, 0.05, 0.37);\n        vec3 diamondColor = vec3(1.0);\n        vec3 sapphireColor = vec3(0.06, 0.32, 0.72);\n        vec3 emeraldColor = vec3(0.31, 0.78, 0.47);\n        vec3 objectColor = vec3(1.0);\n\n        float currTime = mod(iTime, 15.0);\n        if (currTime < 2.0) {\n            density = 0.05;\n            redIOR = 2.41;\n            objectColor = diamondColor;\n        }\n        else if (currTime < 3.0) {\n            density = mix(0.05, 0.1, currTime - 2.0);\n            redIOR = mix(2.41, 1.77, currTime - 2.0);\n            objectColor = mix(diamondColor, rubyColor, currTime - 2.0);\n        }\n        else if (currTime < 5.0) {\n            density = 0.1;\n            redIOR = 1.77;\n            objectColor = rubyColor;\n        }\n        else if (currTime < 6.0) {\n            density = mix(0.1, 0.05, currTime - 5.0);\n            redIOR = mix(1.77, 1.6, currTime - 5.0);\n            objectColor = mix(rubyColor, emeraldColor, currTime - 5.0);\n        }\n        else if (currTime < 8.0) {\n            density = 0.05;\n            redIOR = 1.6;\n            objectColor = emeraldColor;\n        }\n        else if (currTime < 9.0) {\n            density = mix(0.05, 0.01, currTime - 8.0);\n            redIOR = mix(1.6, 1.76, currTime - 8.0);\n            objectColor = mix(emeraldColor, sapphireColor, currTime - 8.0);\n        }\n        else if (currTime < 11.0) {\n            density = 0.01;\n            redIOR = 1.76;\n            objectColor = sapphireColor;\n        }\n        else if (currTime < 12.0) {\n            density = mix(0.01, 0.05, currTime - 11.0);\n            redIOR = mix(1.76, 1.6, currTime - 11.0);\n            objectColor = mix(sapphireColor, emeraldColor, currTime - 11.0);\n        }\n        else if (currTime < 14.0) {\n            density = 0.05;\n            redIOR = 1.6;\n            objectColor = emeraldColor;\n        }\n        else {\n            density = mix(0.05, 0.1, currTime - 14.0);\n            redIOR = mix(1.6, 2.41, currTime - 14.0);\n            objectColor = mix(emeraldColor, diamondColor, currTime - 14.0);\n        }\n\n        // /////// ruby\n        // density = 0.1;\n        // float redIOR = 1.77;\n        // vec3 objectColor = vec3(0.88, 0.05, 0.37);\n\n        // /////// diamond\n        // density = 0.05;\n        // float redIOR = 2.41;\n        // vec3 objectColor = vec3(1.0);\n\n        // /////// sapphire \n        // density = 0.01;\n        // float redIOR = 1.76;\n        // vec3 objectColor = vec3(0.06, 0.32, 0.72);\n\n        // /////// emerald \n        // density = 0.05;\n        // float redIOR = 1.6;\n        // vec3 objectColor = vec3(0.31, 0.78, 0.47);\n\n        float greenIOR = redIOR + chromaticAbberation;\n        float blueIOR = greenIOR + chromaticAbberation;\n\n        vec4 refractionOutputForRed = RefractRay(pointOnSurface, rayDirection, redIOR);\n        vec3 rayDirectionOutOfObjectForRed = refractionOutputForRed.xyz;\n        pixelColor.r = texture(iChannel0, rayDirectionOutOfObjectForRed).r * exp(-refractionOutputForRed.w * density);\n\n        vec4 refractionOutputForGreen = RefractRay(pointOnSurface, rayDirection, greenIOR);\n        vec3 rayDirectionOutOfObjectForGreen = refractionOutputForGreen.xyz;\n        pixelColor.g = texture(iChannel0, rayDirectionOutOfObjectForGreen).g * exp(-refractionOutputForGreen.w * density);\n\n        vec4 refractionOutputForBlue = RefractRay(pointOnSurface, rayDirection, blueIOR);\n        vec3 rayDirectionOutOfObjectForBlue = refractionOutputForBlue.xyz;\n        pixelColor.b = texture(iChannel0, rayDirectionOutOfObjectForBlue).b * exp(-refractionOutputForBlue.w * density);\n\n        pixelColor *= objectColor;\n\n        //TODO: fix the fresnel effect. Something wrong with it\n        // float fresnel = pow(1.0 + dot(rayDirection, surfaceNormal), 2.0);\n\n        // vec3 reflectedRayDirection = reflect(rayDirection, surfaceNormal);\n        // vec3 reflectedTexture = texture(iChannel0, reflectedRayDirection).rgb;\n        // pixelColor = mix(pixelColor, reflectedTexture, fresnel);\n        ////////////////////////////////////////////\n    }\n\n    // // visualize normals instead of lighting from ray marching\n    // if (distanceToSurface < MAX_DIST) {\n    //     pixelColor = GetNormal(pointOnSurface) * 0.5 + 0.5;\n    // }\n\n    outputPixelColor = vec4(pixelColor,1.0);\n}","name":"Image","description":"","type":"image"}]}