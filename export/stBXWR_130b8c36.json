{"ver":"0.1","info":{"id":"stBXWR","date":"1627478877","viewed":113,"name":"Chaotic Balls","username":"Ouid","description":"I'm trying to replicate this : https://www.youtube.com/watch?v=6z4qRhpBIyA\n\n","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["ball","chaotic","simplephysic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 Min ( vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nconst vec3 BKG = vec3(0.05,0.12,0.25);\n\nconst float BALLLINE_WIDTH = 1.0;\nconst float OUTLINE_WIDTH = 3.0;\n\nvec3 ComputeColorFromIndex(int Index)\n{\n    vec3 a = vec3(0.28,0.5,0.5)*1.3;\n    vec3 b = vec3(0.5,0.2,0.5);\n    vec3 c = vec3(1.0,1.0,0.0);        \n    vec3 d = vec3(0.5,0.3, 0.25);\n    \n    float Ratio = float(Index) / float(BALL_COUNT+1);\n        \n    //https://iquilezles.org/articles/palettes\n    return a+b*cos(2.0*3.141592*(c*Ratio+d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec2 d = vec2(CIRCLE_RADIUS - length(p), -1.0);\n    \n    for (int i=0; i<BALL_COUNT; ++i)\n    {\n        State CurrState = FetchState(iChannel0, i);\n        \n        vec2 CurrD = vec2(length(CurrState.pos-p) - BALL_RADIUS, float(i));\n        \n        d = Min(d, CurrD);\n    }\n    \n    float ObjAlpha = 0.0;\n    vec3 ObjCol = vec3(0.0);\n    \n    d.x *= iResolution.y;\n       \n    if(d.x < 0.0)\n    {\n        if(d.y < 0.0)\n        {\n            ObjAlpha = smoothstep(0.0, 1.0, max(0.0, min(-d.x/OUTLINE_WIDTH, 2.0 + d.x/OUTLINE_WIDTH)));\n            ObjCol = vec3(1.0);           \n        }\n        else\n        {\n            ObjAlpha = clamp(-d.x/BALLLINE_WIDTH, 0.0, 1.0);\n            ObjCol = ComputeColorFromIndex(int(d.y));\n        }\n    }\n    \n    vec3 col = mix(BKG, ObjCol, ObjAlpha);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// This \"Time Intersection\" physics seams to be stable (no energy gain/loss)\nState RunPhysics(State CurrState, vec3 Circle, float DeltaTime)\n{\n    Trajectory CurrTraj = MakeTrajectory(CurrState);\n    \n    float IntersectTime = IntersectTrajectoryCircle(CurrTraj, Circle);\n    \n    if(IntersectTime <= DeltaTime)\n    {\n        CurrTraj = IntegrateTrajectory(CurrTraj, IntersectTime);\n        \n        vec2 N = normalize(Circle.xy - CurrTraj.pos);\n        \n        CurrTraj.vel = ReflectVec(-CurrTraj.vel, N);\n        CurrTraj = IntegrateTrajectory(CurrTraj, DeltaTime - IntersectTime);\n    }\n    else\n    {\n        CurrTraj = IntegrateTrajectory(CurrTraj, DeltaTime);\n    }\n    \n    return ExtractState(CurrTraj);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int CurrIndex = CoordToIndex(ivec2(fragCoord));\n    \n    vec3 Circle = vec3(0.0,0.0,CIRCLE_RADIUS - BALL_RADIUS);\n      \n    State CurrState = FetchState ( iChannel0, CurrIndex );\n    \n    if(iMouse.z > 0.0 || iTime < INIT_TIME)\n    {\n        CurrState = InitState(CurrIndex);\n    }\n    \n    State NewState = RunPhysics(CurrState, Circle, iTimeDelta * TIME_SCALE);\n    \n    fragColor = SaveState(NewState);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float TIME_SCALE = 1.0;\nconst float G = -9.81;\nconst float INIT_DELTA = 0.0000001;\nconst float INIT_TIME = 0.1;\nconst float EPSILON = 0.0000001;\nconst float MAX = 10000000000.0;\n\nconst float CIRCLE_RADIUS = 0.9;\nconst float BALL_RADIUS = 0.04;\n\nconst int MAX_STATE_PER_LINE = 100;\n\nconst int BALL_COUNT = 100;\n\nstruct State\n{\n    vec2 pos;\n    vec2 vel;\n};\n\nstruct Trajectory\n{\n    vec2 pos;\n    vec2 vel;\n    vec2 acc;\n};\n\nivec2 IndexToCoord(int Index)\n{\n    return ivec2(Index / MAX_STATE_PER_LINE, Index % MAX_STATE_PER_LINE);\n}\n\nint CoordToIndex(ivec2 Coord)\n{\n    return Coord.y + Coord.x * MAX_STATE_PER_LINE;\n}\n\nState FetchState ( sampler2D Sampler , int Index )\n{\n    vec4 Loaded = texelFetch(Sampler, IndexToCoord(Index), 0);\n    return State(Loaded.xy, Loaded.zw);\n}\n\nvec4 SaveState(State state)\n{\n    return vec4(state.pos, state.vel);\n}\n\nTrajectory MakeTrajectory(State state)\n{\n    return Trajectory(state.pos, state.vel, vec2(0.0, G));\n}\n\nState ExtractState(Trajectory traj)\n{\n    return State(traj.pos, traj.vel);\n}\n\nState InitState(int Index)\n{    \n    return State(vec2(float(Index+1)*INIT_DELTA, 0.0), vec2(0.0));\n}\n\n//https://en.wikipedia.org/wiki/Verlet_integration\n\nTrajectory IntegrateTrajectory(Trajectory traj, float dt)\n{\n    vec2 pos = traj.pos + traj.vel * dt + 0.5 * traj.acc * dt*dt;\n    vec2 vel = traj.vel + traj.acc * dt;\n    \n    return Trajectory(pos, vel, traj.acc);\n}\n\nfloat IntersectRayCircle(in vec2 Start, in vec2 Dir, in vec3 Circle )\n{\n    float Dir2 = dot(Dir,Dir);\n    \n    if(Dir2 < EPSILON)\n        return MAX;\n\n    float Ratio = dot(Circle.xy - Start, Dir) / Dir2;\n    \n    vec2 ProjCenter = Start + Ratio * Dir;\n    \n    float ProjDist2 = dot(ProjCenter - Circle.xy, ProjCenter - Circle.xy);\n    \n    float Radius2 = Circle.z*Circle.z; \n    \n    if(ProjDist2 > Radius2)\n        return MAX;\n    \n    float PerpRatio = sqrt((Radius2 - ProjDist2) / Dir2);\n    \n    return Ratio + PerpRatio;\n}\n\nfloat IntersectTrajectoryCircle(Trajectory traj, vec3 Circle)\n{\n    return IntersectRayCircle(traj.pos, traj.vel, Circle);\n}\n\nvec2 ReflectVec(vec2 I, vec2 N)\n{\n    vec2 NI = dot(I, N) * N;\n    \n    return 2.0 * NI - I;\n}","name":"Common","description":"","type":"common"}]}