{"ver":"0.1","info":{"id":"XdyGDy","date":"1456095192","viewed":337,"name":"Transparency and refractions","username":"dine909","description":"More experiments, this time with refractions - this has issues, but is convincing enough.\n\nSomehow need to work out marching to the back face of an sdf object, once a ray has determined transparency, in order to complete the proper refraction angle.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","transparency","material","refract"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SHADERTOY\n\nprecision highp float;\nprecision highp int;\n\n#ifndef SHADERTOY\n#define iResolution resolution\n#define iTime time\n#define iMouse mouse\nuniform float time;\nuniform vec2 resolution;\nuniform vec2 mouse;\n#endif\n\n//----8<----- SETTINGS ----8<-----//\n\n#define LIGHT_AMOUNT 1.\n//#define ANIMATE_TABLET // <<-- I get corruption with this enabled - hmm.\n#define AUTO_CAMERA\n#define MAX_REFLECT_BOUNCES 2\n#define ENABLE_TRANSPARENCY\n//#define ENABLE_SHADOWS\n//#define ENABLE_FOG\n//#define ENABLE_AO\n//#define SCREEN_POWER 1\n\n//----8<----- /SETTINGS ----8<----//\n\n\n#ifndef SCREEN_POWER\n#define SCREEN_POWER (iTime>4.8?1:0)\n#endif\n#ifndef LIGHT_AMOUNT\n#define LIGHT_AMOUNT .2 + 0.5+0.5*sin(0.5+0.5*cos(iTime*0.5)*PI); \n#endif\n\n#define hz1 (.5+0.5*sin(iTime))\n#define SSW mod(iTime*0.5,1.)>0.5?1.:0.\n\nfloat remap(float value, float low1,float high1, float low2,float high2,bool c){float r=low2 + (value - low1) * (high2 - low2) / (high1 - low1);return c?clamp(r,min(low2,high2),max(low2,high2)):r;}\nfloat remap(float value, float low2,float high2,bool c){return remap(value,0.,1.,low2,high2,c);}\nfloat antiAlias(float x) {return (x-(1.0-2.0/iResolution.y))*(iResolution.y/2.0);}\nfloat blur(float x) {return pow(smoothstep(.945,1.0,x),10.);}\n\n#define PI 3.14159265359\n\nconst float KEY_A = 65.5/256.0;\nconst float KEY_B = 66.5/256.0;\n\nfloat rand (in vec2 seed) {\n    seed = fract (seed * vec2 (5.3983, 5.4427));\n    seed += dot (seed.yx, seed.xy + vec2 (21.5351, 14.3137));\n    return fract (seed.x * seed.y * 95.4337);\n}\n\nfloat isKeyPressed(float key)\n{\n    #ifndef SHADERTOY\n    return 0.;\n    #else\n    return texture( iChannel0, vec2(key, 3.5) ).x;\n    #endif\n}\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nfloat sdPlane( vec3 p ){ return p.y;}\nfloat udBox( vec3 p, vec3 b ){ return length(max(abs(p)-b,0.0));}\nfloat sdBox( vec3 p, vec3 b ){ vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));}\nfloat sdSphere( vec3 p, float s ){ return length(p)-s;}\n\nstruct Reflectivity{ float amount; float chromacity;}T_Reflectivity;\nstruct SDPrim{ int type; vec3 tra,rot,siz; float sca; vec3 utp;}T_SDPrim;\nstruct Material{ int type; vec3 col; Reflectivity ref; float trans; float emis;}T_Material;\nstruct SDObject{int id; SDPrim def; Material mat; float d,t; vec3 mpos,nor;}T_SDObject;\nstruct Ray{vec3 ro,rd;float tmin ,tmax;float a;int id;bool solo;}T_Ray;\n\nRay newRay(vec3 ro,vec3 rd){float tmin = .10;float tmax = 20.0;return Ray(ro,rd,tmin,tmax,0.,-1,false);}\nconst SDObject NoSDObject = SDObject(-1,SDPrim(0,vec3(0.),vec3(0.),vec3(1.),(1.),vec3(0.)),Material(0,vec3(.0),Reflectivity(0.,0.),0.,0.),1000.,1000.,vec3(0.),vec3(0.));\nSDObject newSDObject(int id,Material mat, SDPrim sdo){ return SDObject(id,sdo,mat,0.,0.,vec3(0.),vec3(0.));}\nSDObject SDUnion(SDObject oa ,SDObject ob,int id,bool solo){ if((ob.id==id)?!solo: solo?true:oa.d<ob.d) return oa; else return ob;}\n\nvoid rotp(inout vec3 rp,vec3 r)\n{\n    mat2 mx=mm2(r.x);\n    mat2 my=mm2(r.y);\n    mat2 mz=mm2(r.z);\n    rp.xy*=mz;\n    rp.xz*=my;\n    rp.zy*=mx;\n\n}\nvoid transform(inout vec3 rp,in SDPrim d)\n{\n\n    // rotp(rp,d.rot);\n    rotp(rp,d.rot);\n    rp-=d.tra;\n    rp/=(d.sca);\t\t\t\n}\n\n\nSDObject SDOMap(in SDObject o,vec3 p)\n{\n    // o.ray=ray;\n    // o.ray.ro+=o.pos;\n    //o.d=iSphere(o.ray.ro,o.ray.rd);\n    SDPrim d=o.def;\n\n    o.mpos=p;\n    vec3 rp=p;\n    transform(rp,d);\n    o.def.utp=rp;\n\n\n    if(d.type==1) o.d=sdPlane(rp);\n    if(d.type==2) o.d=sdSphere(rp,1.);\n    if(d.type==3) o.d=udBox(rp,d.siz);\n\n    o.d*=d.sca;\n    return o;\n}\nSDObject mapTablet(vec3 p,vec3 pos,vec3 ori,float tanim,int ignore,bool solo)\n{\n\n    SDObject body=newSDObject(10,Material(3,vec3(.04),Reflectivity(.60,0.45),0.,0.),\n                              SDPrim(3,vec3((1.-tanim)*-1.,.5,-1.)+pos-(1.-tanim)*2.,ori,vec3(1.6,.1,.9),(1.),vec3(0.)));\n\n    SDObject screen=newSDObject(10,Material(2,vec3(0.5),Reflectivity(.60,0.95),0.,.94),\n                                SDPrim(3,vec3((1.-tanim)*-1.,.551,-1.)+pos+(1.-tanim),ori,vec3(1.6*0.9,.05,.9*0.85),(1.),vec3(0.)));\n\n    SDObject led=newSDObject(10,Material(3,SCREEN_POWER==1?vec3(0.1,0.1,2.2):vec3(0.2),Reflectivity(.0,0.05),0.,.94*float(SCREEN_POWER)),\n                             SDPrim(3,vec3(0.,.551,-1.+.9*0.92)+pos,ori,vec3(0.1,.05,0.025),(1.),vec3(0.)));\n\n    SDObject res= SDOMap(body,p);\n    res= SDUnion(res,SDOMap(screen,p),ignore,solo);\n    res= SDUnion(res,SDOMap(led,p),ignore,solo);\n    return res;\n}\nSDObject mapScene(vec3 p,int ignore,bool solo)\n{\n    vec3 testcol=vec3(1.,0.5,0.25);\n    SDObject gr=newSDObject(1,Material(1,testcol.ggg,Reflectivity(.001,0.5),0.,0.),SDPrim(1,vec3(0.,0.,0.),vec3(0.),vec3(1.),1.,vec3(0.)));\n    SDObject cu2=newSDObject(2,Material(3,testcol.gbb,Reflectivity(.70,.50),0.5,0.),SDPrim(3, vec3(2.,1.,2.6), vec3(0.,0.,0.), vec3(1.), (1.),vec3(0.)));\n    SDObject cu=newSDObject(3,Material(3,testcol.bgb,Reflectivity(.70,.50),0.5,0.),SDPrim(2,vec3(-2.,1.,2.6),vec3(0.,0.,0.),vec3(1.),(1.),vec3(0.)));\n\n\n    #ifdef ANIMATE_TABLET\n    float tanim=0.5-0.5*cos(remap(iTime,0.,1.,0.,1.,true)*PI);\n    #else\n    #define tanim 1.\n    #endif\n    SDObject tablet=mapTablet(p,\n                              mix(vec3(0.,1.,-1.),vec3(0.),tanim),\n                              mix(vec3(1.4,1.4*-2.,0),vec3(1.4,0.,0.),tanim),tanim,ignore,solo);\n\n    SDObject res= NoSDObject;\n    res= SDUnion(res,SDOMap(gr,p),ignore,solo);\t\n    res= SDUnion(res,tablet,ignore,solo);\t\n    res= SDUnion(res,SDOMap(cu2,p),ignore,solo);\n    res= SDUnion(res,SDOMap(cu,p),ignore,solo);\n\n    return res;\n}\nSDObject render(in vec3 bcol,out vec3 ocol, Ray ray);\nSDObject castRay( in Ray ray )\n{\n    int cd=1;\n    float precis =0.00001;//(state.y+1.<iTime)?0.0001:0.003;\n    float t = ray.tmin;\n    SDObject res=NoSDObject;\n    SDObject  ores=NoSDObject;\n    vec3 p;\n    int citer=0;\n    for( int i=0; i<200; i++ )\n    {\n        p=ray.ro+ray.rd*t;\n        res = mapScene( p,ray.id,ray.solo );\n        if( res.d<precis || t>ray.tmax) {              \n            break;\n        }\n        t += res.d;\n    }\n    res.t=t;\n    if( t>ray.tmax ) return NoSDObject;\n    //   res.ray.ro=p;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3( 0.004, 0.0, 0.0 );\n    vec3 nor = vec3(\n        mapScene(pos+eps.xyy,-1,false).d - mapScene(pos-eps.xyy,-1,false).d,\n        mapScene(pos+eps.yxy,-1,false).d - mapScene(pos-eps.yxy,-1,false).d,\n        mapScene(pos+eps.yyx,-1,false).d - mapScene(pos-eps.yyx,-1,false).d );\n    return normalize(nor);\n}\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    #ifndef ENABLE_AO\n    return 1.;\n    #endif\n\n    float occ = 0.20;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos = nor * hr + pos;\n        float dd = mapScene( aopos,-1,false ).d;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ); \n}\nvec2 softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    vec2 res = vec2(1.,1.);\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n        SDObject hit=mapScene( ro + rd*t ,-1,false);\n        float h = hit.d;\n        #ifdef ENABLE_TRANSPARENCY\n        if(hit.mat.type>0 && hit.mat.trans>0.)\n        {\n            res.y=min(res.y,1.-hit.mat.trans);\n        }\n        #endif\n        res.x = min( res.x, (32.0*h/t) );\n        t += clamp( h, 0.00001, 0.99999 );\n        if( h<(0.00001) || t>tmax ) break;\n    }\n    return clamp( res,1.2-res.y, 1.0 );\n\n}\n\nvec3 render(vec3 incol,vec3 col,float d)\n{\n    float aares=smoothstep(((d)), .9740, .0);\n    return clamp(mix(incol,col,aares),0.,1.);\n}\n\n#define LINE(a,b) line(p,a,b)\n\nfloat line( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h );\n\n    return (1.0 - d);\n}\nvec3 _mainImage( in vec2 uv )\n{\n\n    return vec3(uv,0.5+0.5*sin(iTime));\n}\nvec3 hitColor(inout SDObject hit)\n{\n    Material m=hit.mat;\n    vec3 col=hit.mat.col;\n\n    if(m.type==1)\n    {\n        vec2 texm=hit.mpos.zx*.2;\n    }\n\n    if(m.type==2 )\n    {\n        if(SCREEN_POWER==1)\n        {\n            //video texture\n            vec2 ssres=hit.def.siz.xz;\n            vec2 texm=hit.def.utp.xz;\n            texm/=ssres;\n            texm/=2.;\n            texm.y=-texm.y;\n            texm+= .5;\n            #define fringe 0.015\n            col=clamp( _mainImage(texm).rgb ,0.,1.)\n                *smoothstep(0.0,fringe,texm.x)\n                *smoothstep(0.0,fringe,texm.y)\n                *smoothstep(1.,1.-fringe,texm.x)\n                *smoothstep(1.,1.-fringe,texm.y);\n        }else{\n            col=vec3(0.);\n        }\n    }\n    return col;\n}\n\nSDObject render(in vec3 bcol,out vec3 ocol,in Ray ray)\n{\n    SDObject hit=castRay(ray);\n    vec3 col=ocol;\n\n    float tamnt=LIGHT_AMOUNT;\n    if (hit.mat.type >0)\n    {\n\n        Material m=hit.mat;\n        col=hitColor(hit);\n\n        vec3 nor = calcNormal( hit.mpos );\n        vec3 ref = reflect( ray.rd, nor );\n\n        hit.nor=nor;\n\n        float occ = calcAO( hit.mpos, nor );\n        vec3 lig = normalize( vec3(-0.0, 1., 1.) );\n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig )*tamnt, m.emis, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-hit.mpos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y )*m.ref.amount;\n        float fre = pow( clamp(1.0+dot(nor,ray.rd),0.0,1.0), 2.0 )*m.ref.amount;\n        float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0)*m.ref.amount;\n\n        //\tif (hit.mat.m >0)\n        // col+=rfm;\n        // shadows\n        vec3 lin = vec3(0.0);\n        #ifdef ENABLE_SHADOWS\n        {\n            vec2 difss=softshadow( hit.mpos, lig, 0.02, 2.5 );\n            dif *= mix(1.,difss.x,1.-m.emis);\n            vec2 domss=softshadow( hit.mpos, ref, 0.02, 2.5 );\n            dom *= domss.x;\n            // dom*=1.-domss.y;//1.-difss.y;\n        } \n        #endif\n        lin += 1.20*dif*mix(vec3(1.00,1.,0.75),vec3(1.),m.emis);\n        lin += 1.20*spe*vec3(1.00,1.,0.75)*dif;\n        lin += 0.20*amb*vec3(0.50,.70,1.00)*occ;\n        // lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n        // col*=1.+0.3*m.emis;\n        col = col*lin;\n\n        #ifdef ENABLE_FOG\n        col = mix( col, vec3(0.8,0.9,1.0)*0.3*tamnt, (0.9)-exp( -0.002*hit.t*hit.t ) );\n        #endif\n\n        ocol=mix(col,ocol,ray.a);\n    }else{\n        ocol=\tmix(bcol*tamnt,col,ray.a);\n\n    }\n    return hit;\n}\nRay getCamera(vec2 p,vec2 um)\n{\n    #ifdef AUTO_CAMERA\n    if(iMouse.z<0.5)\n    {\n        um=0.5+0.4*vec2(-1.25-0.5*sin(-2.8+iTime*0.6),cos(-1.18+iTime*0.3));\n    }\n    #endif\n  vec2 cr=um;\n  \n    float srat=iResolution.y/iResolution.x;\n\n    cr.x=cr.x+.45;\n    float flip=0.5-0.5*cos(remap(cr.y,0.3,0.7,0.,1.,true)*PI);\n\n \n    //camera\n    #define CENTER_CAM vec3(0.,1.95,2.45)\n    vec3 cam=vec3(0.,0.4*(1.-2.*flip),3.2);\n    vec3 ro = cam*2.5;//vec3(0.,.95,.4);\n    vec3 rd = normalize(vec3(p,-1.5));\n    vec3 rdc= normalize(vec3(p ,-1.5));\n\n    mat2 mx = mm2(flip*\tPI); \n    mat2 mz = mm2(PI*2.*(-cr.x*srat)-PI*0.5);\n    mat2 my = mm2(PI*cr.y); \n\n    rd.xy*=mx;\n\n    ro.zy *= my;rd.zy *= my;\n    ro.zx *= mz;rd.zx *= mz;\n\n    rdc.zy*=my;\n    rdc.zx*=mz;\n\n    return newRay(ro,rd);\n\n}\nvec3 globalImage( in vec2 fragCoord )\n{\t\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = fragCoord.xy/iResolution.xy-0.5;\n    vec2 um = iMouse.xy / iResolution.xy;\n    float srat=iResolution.y/iResolution.x;\n\n    um.x /= srat; p.x/=srat;\n\n    Ray ray=getCamera(p,um);\n\n    vec3 ocol,col=vec3(0.);\n #define BACKGROUND ((vec3(0.1, 0.2, .30)+ray.rd.y*-0.8)*LIGHT_AMOUNT)    \n    vec3 bcol = BACKGROUND ;\n    \n    bcol*=LIGHT_AMOUNT;\n    SDObject o=render(bcol,col,ray);\n    float tr=0.;\n    #ifdef ENABLE_TRANSPARENCY\n    {\n        SDObject bob;\n        Ray rob;\n\n        SDObject tob=o;\n        Ray tray=ray;\n\n        o.mat.trans=0.;\n                for(int ti=0;ti<5;ti++)\n        {\n            tr=tob.mat.trans;\n\n            \n           \n//            col=mix(col,bacol,tr);\n\n            if(tr>0.) \n            {\n                tray.id=tob.id;\n                vec3 tcol=vec3(0.);\n                //i have no idea what i'm doing\n                tray.rd=refract(tray.rd,(2.*tob.nor)-bob.nor,1.1);\n                //     tray.rd=-refract(rob.rd,bob.nor,1.5);\n                tray.ro=tob.mpos;\n                tob=render(((vec3(0.1, 0.2, .30)+tray.rd.y*-0.8)*LIGHT_AMOUNT)   ,tcol,tray);\n                col=mix(col,tcol,tr);\n            }\n                        else break;\n        }\n    }\n    #endif\n    ocol=col;\n    float refval=1.0 ;//.25;\n    vec3 rcol=vec3(1.,1.,1.);\n    #ifdef MAX_REFLECT_BOUNCES\n    for(int i=0;i<MAX_REFLECT_BOUNCES;i++)\n    {\n        float cref=o.mat.ref.amount;\n        rcol*=mix(vec3(1.),o.mat.col*cref,o.mat.ref.chromacity);\n        if(cref==0.) break;\n        refval*=cref+0.12;\n        col=vec3(0.);\n        ray=newRay(o.mpos,reflect(ray.rd,o.nor*(1.+0.03*(1.-smoothstep(0.,.7,o.mat.ref.amount))*rand(o.mpos.xy*1000.))));\n        o=render(bcol,col,ray);\n\n        ocol+=(1.-tr)*clamp(((col/float(i+1))*(refval*(1.+.35*o.mat.emis)))*rcol,0.,1.)*(1.-cref);\n    }\n    #endif\n\n    return ocol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=vec4(globalImage(fragCoord),1.);\n}\n\n\n#ifndef SHADERTOY\nvoid main(){mainImage(gl_FragColor,gl_FragCoord.xy);}\n#endif\n","name":"Image","description":"","type":"image"}]}