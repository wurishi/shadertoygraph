{"ver":"0.1","info":{"id":"Mst3Rn","date":"1447893177","viewed":190,"name":"Paint Spill","username":"jackdavenport","description":"A spilled can of paint! Shadows look a little crappy, but I can't work out a fix for them.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarcher","paint","spill"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define MAX_ITERATIONS 124\n#define MIN_DISTANCE  .001\n#define EPSILON .002\n#define SHADOW_BIAS .002\n\n#define SUN_DIR vec3(45.,45.,-45.)\n\nstruct Ray{\n  vec3 ori;\n  vec3 dir;\n};\nstruct Dist{\n  float dist;\n  int id;\n};\nstruct Hit{\n  vec3 p;\n  Dist dist;\n};\n    \n// Many thanks to iq!\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 rot2D(vec2 p, vec2 angle) {\n \n    angle = radians(angle);\n    return p * mat2(cos(angle.x),sin(angle.y),-sin(angle.x),cos(angle.y));\n    \n}\n\nfloat distFloor(vec3 p, float y) {\n \n   \tfloat dst = p.y - y;\n    float dsp = 0.;\n    \n    vec2 uv = mod(p.xz / 5., 1.);\n    vec3 tc = texture(iChannel1,uv).xyz;\n    if(((tc.x+tc.y+tc.z)/3.) > .5) dsp = .006;\n    else dsp = 0.;\n    \n    return dst - dsp;\n    \n}\n\nfloat distCone(vec3 p, vec3 pos, vec3 c) {\n \n    p = pos - p;\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n    \n}\n\nfloat distCan(vec3 p, vec3 pos) {\n \n    p = pos - p;\n    vec2 r = rot2D(p.yz,vec2(90.,90.));\n    vec3 q = vec3(p.x,r.x,r.y);\n    vec2 h = vec2(.2,.2);\n    vec2 d = abs(vec2(length(q.xz),q.y)) - h;\n    float dist = min(max(d.x,d.y),0.) + length(max(d,0.));\n    \n    q.y -= 0.1;\n   \th = vec2(.19,.19);\n    d = abs(vec2(length(q.xz),q.y))-h;\n    float cut = min(max(d.x,d.y),0.)+length(max(d,0.));\n    \n    return max(-cut,dist);\n    \n}\n\nDist distScene(vec3 p) {\n \n    float theFloor = distFloor(p, 0.);\n    float paintCan = distCan(p, vec3(-0.6,0.2,-0.1));\n    float paintSpl = distCone(p, vec3(-0.6,-0.07,-0.3), vec3(.1,.5,.1));\n    \n    float dst = min(theFloor,paintCan);\n    dst = min(dst, paintSpl);\n    \n    return Dist(dst, dst == paintCan ? 0 : dst == paintSpl ? 2 : 1);\n    \n}\n\nHit raymarch(Ray ray) {\n \n    vec3 p = ray.ori;\n    Dist d = Dist(0., -1);\n    \n    for(int i = 0; i < MAX_ITERATIONS; i++) {\n     \n        Dist dst = distScene(p);\n        p += ray.dir * dst.dist;\n        \n        if(dst.dist <= MIN_DISTANCE) {\n         \n            d = dst;\n            break;\n            \n        }\n        \n    }\n    \n    return Hit(p,d);\n    \n}\n\n// Thanks again iq!\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( EPSILON, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    distScene(pos+eps.xyy).dist - distScene(pos-eps.xyy).dist,\n\t    distScene(pos+eps.yxy).dist - distScene(pos-eps.yxy).dist,\n\t    distScene(pos+eps.yyx).dist - distScene(pos-eps.yyx).dist );\n\treturn normalize(nor);\n}\n\nvec3 clearColor(vec3 dir) {\n \n    return texture(iChannel0,dir).xyz;\n    \n}\n\nvec3 getLighting(Hit hit, Ray ray, vec3 n, float shininess) {\n    \n    const float ambient = .1;\n    vec3 ld = normalize(SUN_DIR);\n    vec3 rd = normalize(reflect(ray.dir,n));\n    \n    float diffuse = ambient + max(dot(ld,n),0.);\n    float spec    = pow(max(dot(rd,ld),0.), shininess);\n    \n    Ray sr = Ray(hit.p + (ld*SHADOW_BIAS), ld);\n    Hit sh = raymarch(sr);\n    \n    if(sh.dist.id != -1) {\n     \n        diffuse = ambient;\n        spec    = 0.;\n        \n    }\n    \n    return vec3(diffuse) + vec3(spec);\n    \n}\n\nvec3 renderFloor(Ray ray, Hit hit) {\n \n    vec3 n = calcNormal(hit.p);\n    vec2 uv = mod(hit.p.xz / 5., 1.);\n    \n    vec3 tc = texture(iChannel1,uv).xyz;\n    if(((tc.x+tc.y+tc.z)/3.) > .5) tc = vec3(.8);\n    else tc = vec3(.3);\n    \n    return tc * getLighting(hit,ray,n,60.);\n    \n}\n\nvec3 getPaintColor(Ray ray, Hit hit, vec3 n) {\n \n    return abs(hit.p.yzx) * getLighting(hit,ray,n,90.);\n    \n}\n\nvec3 getCanColor(Ray ray, Hit hit, vec3 n) {\n    \n    return vec3(.4);\n    \n}\n\nvec3 getReflection(Hit scene, vec3 rd) {\n \n    Ray rr = Ray(scene.p + (rd * EPSILON), rd);\n    Hit rh = raymarch(rr);\n        \n    vec3 rc = vec3(0.);\n    if(rh.dist.id == 0) rc = getCanColor(rr,rh,calcNormal(rh.p))*getLighting(rh,rr,calcNormal(rh.p),60.);\n    else if(rh.dist.id == 1) rc = renderFloor(rr,rh);\n    else if(rh.dist.id == 2) rc = getPaintColor(rr,rh,calcNormal(rh.p));\n    else rc = clearColor(rd);\n    \n    return rc;\n        \n}\n\nvec3 render(Ray ray) {\n \n    Hit scene = raymarch(ray);\n    \n    if(scene.dist.id == 0) {\n    // shade paint can\n        vec3 n = calcNormal(scene.p);\n        vec3 rd = reflect(ray.dir, n);\n        \n        return mix(getReflection(scene,rd),getCanColor(ray,scene,n),.6) * getLighting(scene,ray,n,60.);\n        \n    } else if(scene.dist.id == 1) {\n    // shade floor\n        return renderFloor(ray,scene);\n        \n    } else if(scene.dist.id == 2) {\n    // shade paint\n        vec3 n = calcNormal(scene.p);\n        \n        vec3 col = getPaintColor(ray,scene,n);\n        vec3 ref = getReflection(scene,reflect(ray.dir,n));\n        \n        return mix(col,ref,.2);\n        \n    }\n    \n    return clearColor(ray.dir);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy / 2.) / iResolution.y;\n    \n    float ss = smoothstep(0., 1., abs(sin(iTime / 5.)));\n    float x = mix(-.3, -1., ss);\n    float z = mix(-1., -1.2, ss);\n    \n    vec3 ori = vec3(x, 0.2, z);\n    vec3 dir = vec3(uv, 1.);\n    \n\tvec3 col = render(Ray(ori,dir));\n    col = pow(col, vec3(.45));\n    \n    fragColor = vec4(clamp(col,0.,1.), 1.);\n}","name":"Image","description":"","type":"image"}]}