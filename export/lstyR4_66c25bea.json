{"ver":"0.1","info":{"id":"lstyR4","date":"1518174505","viewed":1050,"name":"Kleinian Anaglyph 3d Fractal","username":"tholzer","description":"Modified version of Anaglyph Kleinian 3d Fractal, see source code header.\nSlightly modified color merging & rearranged code to use common code.\nPut on your red-cyan glasses or press mouse button to view original coloring.\nEnable antialsing: set WITH_AA.","likes":31,"published":1,"flags":64,"usePreview":0,"tags":["3d","raymarching","fractal","anaglyph","red","stereo","kleinian","cyan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XtfSRH","filepath":"https://soundcloud.com/thomasbarrandon/fledge","previewfilepath":"https://soundcloud.com/thomasbarrandon/fledge","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//------------------------------------------------------------------------------\n// Kleinian_Anaglyph_3d_Image.glsl\n//\n//  v1.0  2018-02-09  initial release\n//  v1.1  2018-10-20  simplified version by ollj\n//\n// Modified version of Anaglyph kleinian 3d fractal, see source code header.\n// Slightly modified color merging & rearranged code to use common code.\n// Put on your red-cyan glasses or press mouse button to view original coloring.\n//\n// Original by sebastien durand  https://www.shadertoy.com/view/ldSyRd\n// Anaglyph by iapafoto          https://www.shadertoy.com/view/4lXyDM\n//\n// tags: 3d, anaglyph, stereo, fractal, kleinian, red, cyan, raymarching\n//------------------------------------------------------------------------------\n\n#define VIGNETTING\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n vec2 uv = fragCoord / iResolution.xy;\n float t = 0.1 * iTime;\n vec4 color1 = commonRender(fragCoord, true,  t, iResolution.xy);\n vec4 color2 = commonRender(fragCoord, false, t, iResolution.xy);\n\n/* original code\n  float b = (color1.r + color1.g + color1.b)/3.;\n  float r = (color2.r + color2.g + color2.b)/3.;\n  col = vec4(r*1.5,b,b,1.);\n*/\n\n if (iMouse.z < 1.0)   // MousePressed ?\n {                               // gray scale conversion\n   float r = (color1.r*0.30 + color1.g*0.59 + color1.b*0.11);\n   float c = (color2.r*0.30 + color2.g*0.59 + color2.b*0.11);\n   color1 = vec4(r, c, c, 1.0);\n }\n #ifdef VIGNETTING\n   color1.rgb *= pow(16.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y), .3);\n #endif\n fragColor = 1.5*pow(color1,vec4(.6,.6,.6,1.));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n//------------------------------------------------\n// Kleinian_Anaglyph_3d_Common.glsl\n//\n//  v1.0  2018-02-09  initial release\n//  v1.1  2018-10-20  beautified\n//------------------------------------------------\n\n// uncomment for 2*2 antialiasing\n#define WITH_AA\n\n// set number of iterations\n#define NB_ITERATION 7\n\n#define WITH_SHADOWS\n#define WITH_AO\n\n#define BACK_COLOR vec3(.08, .16, .34)\n\n#define PRECISION_FACTOR 5e-4\n#define MIN_DIST_RAYMARCHING .01\n#define MAX_DIST_RAYMARCHING 4.\n#define MAX_RAYMARCHING_ITERATION 132\n\n#define MIN_DIST_SHADOW 10.*PRECISION_FACTOR\n#define MAX_DIST_SHADOW .25\n#define PRECISION_FACTOR_SHADOW 3.*PRECISION_FACTOR\n\n#define MIN_DIST_AO .5*PRECISION_FACTOR\n#define MAX_DIST_AO .02\n\n#define LIGHT_VEC normalize(vec3(.2,.7, 1.6) )\n\n//------------------------------------------------\nvec2 kColor;\nvec4 mins;\nvec4 maxs;\n\n//knighty's pseudo kleinian\nfloat distFunc(vec3 p)\n{\n    float k, scale=1.;\n    for(int i=0; i < NB_ITERATION; i++)\n    {\n        p = 2.*clamp(p, mins.xyz, maxs.xyz)-p;\n        k = max(mins.w/dot(p,p), 1.);\n        p *= k;\n        scale *= k;\n    }\n    float rxy = length(p.xy);\n    return .7*max(rxy-maxs.w, /*abs*/(rxy*p.z) / length(p))/scale;\n}\n\nfloat getDistance(vec3 pos)\n{\n    float k,r2, orb = 1.;\n    for(int i=0; i < NB_ITERATION; i++)\n    {\n        pos = 2.*clamp(pos, mins.xyz, maxs.xyz)-pos;\n        r2 = dot(pos,pos);\n        orb = min(orb, r2);\n        k = max(mins.w/r2,1.);\n        pos *= k;\n    }\n    return kColor.x + kColor.y*sqrt(orb);\n}\n\nfloat rayIntersect(const vec3 ro, const vec3 rd, const float prec, const float mind, const float maxd)\n{\n    float h, t = mind;\n    for(int i=0; i < MAX_RAYMARCHING_ITERATION; i++)\n    {\n        h = distFunc(ro+rd*t);\n        if (h<prec*t||t>maxd)break;\n        t += h;\n    }\n    return t;\n}\n\nvec2 trace(const vec3 ro, const vec3 rd)\n{\n    float d = rayIntersect(ro, rd, PRECISION_FACTOR, MIN_DIST_RAYMARCHING, MAX_DIST_RAYMARCHING);\n    if (d<=0.)\n      return vec2(-1., 1.);   // no intersection\n    else return vec2(d, getDistance(ro+rd*d));  // get distance\n}\n\n\n#ifdef WITH_SHADOWS\nfloat shadow(vec3 ro, vec3 rd)\n{\n    float d = rayIntersect(ro, rd, PRECISION_FACTOR_SHADOW, MIN_DIST_SHADOW, MAX_DIST_SHADOW);\n    return (d>0.) ? smoothstep(0., MAX_DIST_SHADOW, d) : 1.;\n}\n#endif\n\n\n#ifdef WITH_AO\nfloat calcAO4(const vec3 pos, const vec3 nor )\n{\n    float hr, occ = 0., sca = 1.;\n    for(int i=0; i<5; i++ ) {\n        hr = MIN_DIST_AO + MAX_DIST_AO*float(i)/4.;\n        occ += -(getDistance( nor * hr + pos)-hr)*sca;\n        sca *= .95;\n    }\n    return clamp(1. - 10.*occ, 0., 1.);\n}\n#endif\n\n\nvec3 calcNormal(const vec3 pos, const float t )\n{\n    vec3 e = (PRECISION_FACTOR * t * .57) * vec3(1, -1, 0);\n    return normalize\n        (e.xyy*getDistance(pos + e.xyy) +\n\t\t e.yyx*getDistance(pos + e.yyx) +\n\t\t e.yxy*getDistance(pos + e.yxy) +\n         e.xxx*getDistance(pos + e.xxx) );\n}\n\n/*\nvec3 RD(const vec3 ro, const vec3 ww, const vec3 vv, const vec3 uu\n       ,const vec2 xy, const vec2 r, const float fov)\n{\n    vec3 er = normalize(vec3((2. * (xy.x/r.x) - 1.)* r.x/r.y,  (2. * (xy.y/r.y) - 1.), fov));\n    return normalize( er.x*uu + er.y*vv + er.z*ww );\n}\n*/\n\nvec4 renderScene(const vec3 ro, const vec3 rd)\n{\n  vec3 col = BACK_COLOR;\n  vec2 res = trace(ro, rd);\n  float t = res.x;\n\n  vec3 pos = ro + t*rd,\n       nor = calcNormal( pos, t),\n       ref = reflect( rd, nor),\n       lig = LIGHT_VEC;\n  // Color\n  col = .5 + .5*cos( 6.2831*res.y + vec3(0,1,2) );\n\n  // lighting\n  #ifdef WITH_AO\n    float occ = calcAO4(pos, nor);\n  #else\n    float occ = 1.;\n  #endif\n\n  #ifdef WITH_SHADOWS\n    float sh = .2+.8*shadow( pos, lig); //, 0.1, t );\n  #else\n    float sh = 1.;\n  #endif\n\n  #ifdef ONLY_AO\n    col = (vec3)occ*(.5+.5*sh);\n  #else\n    float amb = .3;\n    float dif = clamp( dot( nor, lig ), 0., 1.);\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.,-lig.z))), 0., 1. )*clamp( 1.-pos.y,0.,1.);\n    float dom = smoothstep( -.1, .1, ref.y );\n    float fre = clamp(1.+dot(nor,rd),0.,1.);\n    fre *= fre;\n    float spe = pow(clamp( dot( ref, lig ), 0., 1. ),99.);\n\n    vec3 lin = vec3(.3) +\n        + 1.3*sh*dif*vec3(1., 0.8, 0.55)\n        + 2.0*spe*vec3(1., 0.9, 0.7)*dif\n        + 0.5*occ*(0.4*amb*vec3(0.4, 0.6, 1.) +\n                   0.5*sh *vec3(0.4, 0.6, 1.) +\n                  0.25*fre*vec3(1., 1., 1.));\n    col *= lin;\n  #endif\n\n  // Shading.\n  float atten = 1./(1. + t*.2 + t*.1); // + distlpsp*distlpsp*0.02\n  col *= atten*col*occ;\n  col = mix(col, BACK_COLOR, smoothstep(0.2, 1., t/MAX_DIST_RAYMARCHING));\n  return vec4((col),t);\n}\n\n// - Interpolation -------------------------------\n\n#define NB 16\n\nfloat[]\n  camx = float[] ( .2351, 1.2351, 1.2351, 1., .2, .41, /*.545,.545,*/ .5,.084,.145,  3.04,.12, .44,.44,.416, -1.404, .21,.2351, .2351),\n  camy = float[] (-.094,  .35,     .28,  .38,  .04, .11, /*-.44,-.44,*/.35,.0614,.418, 1.,-.96, .67,.8,.0, -1., -.06,-.094),\n  camz = float[] ( .608,  .608,    .35,   .3608, -.03, .48,/*.032,.032,*/ .47,0.201,.05,.28,.3, 1.445,1.,1.4, 2.019, .508,.608),\n\n  lookx = float[] (-.73, -.627, -1., -.3, -1., -.72, /*-.82,-.82,*/-.67,-.5,-.07,-.67,-.27, -.35,-.35,-.775, .08, -.727),\n  looky = float[] (-.364, -.2,   -.2,  -.2,  0., -.39, /*-.5, -.5,*/-.56,-.37,-.96,-.74,-.94, -.35,-.35,-.1, .83,-.364),\n  lookz = float[] (-.582, -.582, -.5, -.35, -.0, -.58, /*-.2776,-.2776,*/-.48,-.79,-.25,.06,-.18, -.87,-.87,.23, .55, -.582),\n\n  minsx = float[] (-.3252,-.3252,-.3252,-.3252,-.3252,-.3252,/*-.3252,-1.1,*/ -1.05,-1.05,-1.21,-1.22,-1.04,-0.737,-.62,-10., -.653,  -.653, -.3252),\n  minsy = float[] (-.7862,-.7862,-.7862,-.7862,-.7862,-.7862,/*-.7862,-.787,*/ -1.05,-1.05,-.954,-1.17,-.79,-0.73,-.71,-.75, -2.,   -2., -.7862),\n  minsz = float[] (-.0948,-.0948,-.0948,-.0948,-.0948,-.0948,/*-.0948,-.095,*/-0.0001,-0.0001,-.0001,-.032,-.126,-1.23,-.85,-.787, -.822, -1.073, -.0948),\n  minsw = float[] ( .69, .69, .69, .69, .69, .678, /*.678,  .678,*/.7,.73,1.684,1.49,.833, .627,.77,.826,  1.8976, 1.8899, .69),\n\n  maxsx = float[] ( .35,.3457,.3457,.3457,.3457, .3457,/*.3457,.3457,*/ 1.05,1.05,.39,.85,.3457,.73,.72,5., .888,  .735, .35),\n  maxsy = float[] (1.,1.0218,1.0218,1.0218,1.0218,/*1.0218,1.0218,*/1.0218,1.05,1.05,.65,.65,1.0218,0.73,.74,1.67, .1665, 1.),\n  maxsz = float[] (1.22,1.2215,1.2215,1.2215,1.2215,1.2215,/*1.2215,1.2215, */1.27,1.4,1.27,1.27,1.2215,.73,.74,.775, 1.2676, 1.22),\n  maxsw = float[] ( .84, .84, .84, .84, .84, .9834,/*.9834,.9834,*/.95,.93,2.74,1.23,.9834, .8335,.14,1.172, .7798, .84);\n\n// Deph of field animation\nfloat[] deph = float[] ( 1.,.65,.6,.4,.2,.4,/*.055,.055,*/.65,.11,.13,1.3,.49,1.2,1.2,.5,.65,.45,1.,1.);\n\nvec4 commonRender (vec2 fragCoord, bool left, float time, vec2 res)\n{\n    float kt = smoothstep(0.,1.,fract(time));\n\n    //--- Interpolate positions and fractal configuration ---\n    int  i0 = int(time)%NB, i1 = i0+1;\n\n    vec4 csum = vec4(0);\n    vec2 q = fragCoord / res;\n #ifdef WITH_AA\n   for (int ii=0;ii<2;ii++)\n    for (int jj=0;jj<2;jj++)\n     { q = (fragCoord+.5*vec2(ii,jj))/res;\n #endif\n\n    float d1 = left ? -0.0025 : +0.0025;\n    float d2 = left ? -0.0001 : +0.0001;\n\n    vec3 ro = mix(vec3(camx[i0],camy[i0],camz[i0]), vec3(camx[i1],camy[i1],camz[i1]), kt),\n    ww = mix(vec3(lookx[i0],looky[i0],lookz[i0]), vec3(lookx[i1],looky[i1],lookz[i1]), kt),\n    vv = -normalize(cross(ww, vec3(0,1,0))),\n    uu = -normalize(cross(vv,ww)),\n    er = vec3((2. * q.x - 1.) * res.x/res.y,  (2. * q.y - 1.), 3.),\n    rd = normalize(er.x*uu + er.y*vv + er.z*ww );\n\n    //--------------------------------------------\n\n    ro += uu * d1,\n    ww = mix(vec3(lookx[i0],looky[i0],lookz[i0]), vec3(lookx[i1],looky[i1],lookz[i1]), kt),\n    vv = -normalize(cross(ww, vec3(0,1,0))),\n    uu = -normalize(cross(vv,ww)),\n    er = vec3((2. * q.x - 1.) * res.x/res.y,  (2. * q.y - 1.), 3.),\n    rd = normalize(er.x*(uu - d2) + er.y*vv + er.z*ww );\n\n    //--------------------------------------------\n\n    mins = mix(vec4(minsx[i0],minsy[i0],minsz[i0],minsw[i0]), vec4(minsx[i1],minsy[i1],minsz[i1],minsw[i1]), kt),\n    maxs = mix(vec4(maxsx[i0],maxsy[i0],maxsz[i0],maxsw[i0]), vec4(maxsx[i1],maxsy[i1],maxsz[i1],maxsw[i1]), kt);\n\n    kColor = vec2(.25,1.);\n\n    // - Rendering -------------------------------\n    csum += renderScene(ro, rd);\n\n #ifdef WITH_AA\n   }\n   csum /= 4.;\n #endif\n  return csum;\n}","name":"Common","description":"","type":"common"}]}