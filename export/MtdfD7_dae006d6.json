{"ver":"0.1","info":{"id":"MtdfD7","date":"1539928002","viewed":134,"name":"Cannon-Thurston V2 (wrong!)","username":"DaveBachman","description":"In this test we count how many fund domain hops we need to do to get close to the origin\nin the Poincare ball, and color the sphere accordingly.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["hyperbolic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Joint work with Dave Bachman. \n// In this test we count how many fund domain hops we need to do to get close to the origin\n//in the Poincare ball, and color the sphere accordingly\n\nvec4 c2q(in vec2 a){\n    return vec4(a.x, a.y, 0.0, 0.0);\n}\n\nvec4 qonj(in vec4 q){\n    return vec4(q.x, -q.y, -q.z, -q.w);\n}\n\nvec4 qinv(in vec4 q){\n \treturn qonj(q) / (q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w);\n}\n\nvec4 qmul(in vec4 p, in vec4 q){\n    return vec4(p.x*q.x - p.y*q.y - p.z*q.z - p.w*q.w,\n                p.x*q.y + p.y*q.x + p.z*q.w - p.w*q.z,\n                p.x*q.z - p.y*q.w + p.z*q.x + p.w*q.y,\n                p.x*q.w + p.y*q.z - p.z*q.y + p.w*q.x);\n}\n\nvec4 qdiv(in vec4 p, in vec4 q){\n    return qmul(p, qinv(q));\n}\n\nvec4 qmob(in vec2[4] M, in vec4 z){ // see Ahlfors 1981 Mob tsfms p14\n    vec4 a = c2q(M[0]);\n    vec4 b = c2q(M[1]);\n    vec4 c = c2q(M[2]);\n    vec4 d = c2q(M[3]);\n    return qdiv( qmul(a,z)+b, qmul(c,z)+d ); // if z.w = 0 then result.w = 0\n}\n\n    \nconst float sqrt3 = sqrt(3.0);\nconst vec2 w = vec2(0.5, 0.5*sqrt3);\nconst vec2 winv = vec2(0.5, -0.5*sqrt3);\nconst vec2 c0 = vec2(0.0,0.0);\nconst vec2 c1 = vec2(1.0,0.0);\nconst vec2 ci = vec2(0.0,1.0);\nconst vec4 qj = vec4(0.0,0.0,1.0,0.0);\n\nfloat origin_distance(in vec4 q){\n    //vec4 x  = qdiv(q-qj,c2q(c1)-qmul(q,qj));\n    vec4 x = qmul(qinv(qmul(q,qj)-c2q(c1)),qj-q);\n    return length(x);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 t1[4];\n\tt1[0] = c1;\n\tt1[1] = -w;\n\tt1[2] = c1;\n\tt1[3] = winv;  // is this really the only way to assign values to the array??\n    vec2 t1inv[4];\n    t1inv[0] = winv;\n    t1inv[1] = w;\n    t1inv[2] = -c1;\n    t1inv[3] = c1;\n    vec2 t2[4];\n    t2[0] = c1;\n    t2[1] = w;\n    t2[2] = c0;\n    t2[3] = c1;\n    vec2 t2inv[4];\n    t2inv[0] = c1;\n    t2inv[1] = -w;\n    t2inv[2] = -c0;\n    t2inv[3] = c1;\n    vec2 t3[4];\n    t3[0] = -winv;\n    t3[1] = -w;\n    t3[2] = w;\n    t3[3] = -w - c1;\n    vec2 t3inv[4];\n    t3inv[0] = -w - c1;\n    t3inv[1] = w;\n    t3inv[2] = -w;\n    t3inv[3] = -winv; //all these should have det 1 now\n    \n    vec2 p = vec2(0.1,0.001) + 1.0*(-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n    //vec4 q = vec4(p, 0.001+0.1*(0.75 + cos(iTime) + 0.25*cos(2.0*iTime)), 0.0);\n\t//vec4 q = vec4(0.0,1.0, 0.0001, 0.0);\n    \n    float ball_radius = 0.9999;\n    \n    vec4 q;\n    vec3 col;\n    \n    if(length(p)<1.0){\n\t\tvec4 ball_pt = vec4(sqrt(1.0-length(p)*length(p)),p,0.0);\n        ball_pt = vec4(ball_pt.x * cos(iTime) + ball_pt.y * sin(iTime), -ball_pt.x * sin(iTime) + ball_pt.y * cos(iTime), ball_pt.z, ball_pt.w);\n        //ball_pt = (0.999-0.15*cos(iTime))*ball_pt;\n        ball_pt = 0.999*ball_pt;\n      \tq = qdiv(ball_pt + qj,qmul(qj,ball_pt)+c2q(c1));\n        int crossing_count = 0;\n\t    for(int i=0;i<512;i++){\n    \t    vec4 q1=qmob(t1,q);\n        \tfloat d1=origin_distance(q1);\n\n\t        vec4 q2=qmob(t2,q);\n\t        float d2=origin_distance(q2);\n\n\t        vec4 q3=qmob(t3,q);\n    \t    float d3=origin_distance(q3);\n\n        \tvec4 q1inv=qmob(t1inv,q);\n        \tfloat d1inv=origin_distance(q1inv);\n\n\t        vec4 q2inv=qmob(t2inv,q);\n    \t    float d2inv=origin_distance(q2inv);\n\n\t        vec4 q3inv=qmob(t3inv,q);\n    \t   \tfloat d3inv = origin_distance(q3inv);\n\n\t        float dbest=d1;\n    \t    vec4 qbest=q1;\n        \tint crossing_change = 0;\n        \n\t        if (d2 < dbest){\n    \t    \tdbest = d2;\n        \t    qbest=q2;\n            \tcrossing_change=-1;\n\t        }\n\n    \t    if (d3 < dbest){\n        \t\tdbest = d3;\n            \tqbest=q3;\n      \t      crossing_change=-1;\n        \t}\n        \n\t        if (d1inv < dbest){\n    \t    \tdbest = d1inv;\n        \t    qbest=q1inv;\n            \tcrossing_change=0;\n\t        }\n        \n    \t    if (d2inv < dbest){\n        \t\tdbest = d2inv;\n            \tqbest=q2inv;\n           \t \tcrossing_change=1;\n\t        }\n\n\t        if (d3inv < dbest){\n    \t    \tdbest = d3inv;\n        \t    qbest=q3inv;\n            \tcrossing_change=1;\n\t        }\n        \n     \t   if (dbest < origin_distance(q)){\n        \t    q=qbest;\n            \tcrossing_count=crossing_count+crossing_change;\n\t        }\n    \t    else break;\n\t}                \n    float c = 0.5+float(crossing_count)/10.0;\n    col = vec3(c,c,c);\n    }\n    \t\n    else{\n        col = vec3(0.0,0.0,0.0);\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}