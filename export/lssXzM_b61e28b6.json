{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"\n// hash based 3d value noise\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n\nconst float KAPPA = 0.16;  // extinction coefficient\n\nvec3 sun_direction()\n{\n\treturn normalize(vec3(-1.0, 1.0, 0.0));\n}\n\n// returns clouds extinction coeff. as a function of world position\nfloat clouds_extinction( in vec3 p )\n{\t\n\tfloat spatial_period = 35.0;\n\tp /= spatial_period;\n\t\n\tfloat timefreq = 0.2;\n\tvec3 q = p - 10.0*vec3(sin(timefreq*iTime),0.0,cos(timefreq*iTime));//*timefreq*iTime;\n\t\n\tfloat cloud_height = 1.4;\n\tfloat m = sin(0.05*timefreq*iTime*2.0*3.14);\n\tfloat layer_y = -1.2*(1.0+0.5*m*m)*cloud_height;\n\tfloat N;\n\tfloat g = 1.0;\n\tfloat beta = 0.5;\n    N  = g * noise( q ); q *= 2.0; g *= beta;\n    N += g * noise( q ); q *= 2.0; g *= beta;\n    N += g * noise( q ); q *= 2.0; g *= beta;\n    N += g * noise( q );\n\t\n\tfloat s = 0.4; // edge smoothness (0=hard, 1=smooth)\n\t\n\tfloat cloudtop_y = layer_y + cloud_height*pow(abs(N), 0.7);\n\treturn KAPPA * (smoothstep(p.y-s*cloud_height, p.y+s*cloud_height, cloudtop_y));\n}\n\n\n// return sun+sky radiance\nvec3 sky_color( in vec3 rd )\n{\n\tvec3 skyColor = vec3(0.33,0.51,0.88) - rd.y*0.95*vec3(1.0,0.5,1.0);\n\tfloat sp = dot(sun_direction(), rd) - cos(radians(5.0));\n\tvec3 sun = 3.5e6 * vec3(1.0,1.0,0.8) * pow(sp * step(0.0, sp), 2.3);\n\tskyColor += sun;\n\treturn skyColor;\n}\n\n\n// return radiance reaching the point pos from the sun\nvec3 reduced_sun( in vec3 pos )\n{\n\tconst int num_steps = 3;\n\tconst float max_dist = 10.0;\n\tfloat dl = max_dist/float(num_steps);\n\tfloat Transmittance = 1.0;\n\tfor(int i=0; i<num_steps; i++)\n\t{\n\t\tif(Transmittance < 0.01) break;\n\t\tpos += dl*sun_direction();\n\t\tfloat kappa = clouds_extinction( pos );\n\t\tTransmittance *= exp(-kappa*dl);\n\t}\n\treturn Transmittance * sky_color(sun_direction());\n}\n\n\n// Henyey-Greenstein phase function\nfloat phasefunction(in vec3 a, in vec3 b)\n{\n\tfloat mu = dot(a, b);\n\tfloat g = 0.6;\n\tfloat gSqr = g*g;\n\tfloat oofp = 1.0/(4.0*3.141592);\n\treturn oofp * (1.0 - gSqr) / pow(1.0 - 2.0*g*mu + gSqr, 1.5);\t\n}\n\n\n// raymarch to complete volume rendering integral\nvec3 primary( in vec3 ro, in vec3 rd )\n{\n\tconst float max_dist = 300.0;\n\tconst int num_steps = 50;\n\tfloat dl = max_dist/float(num_steps);\n\t\n\tvec3 pos = ro;\n\tfloat Transmittance = 1.0;\n\t\n\t// Calculate volume rendering integral along primary ray\n\tvec3 InScattered = vec3(0.0);\n\tfor(int i=0; i<num_steps; i++)\n\t{\n\t\tif(Transmittance < 0.01) break;\n\t\tpos += dl*rd;\n\t\tfloat kappa = clouds_extinction( pos );\n\t\tTransmittance *= exp(-kappa*dl);\n\t\t\n\t\t// single scattering given by in-scatter of sunlight\n\t\tconst vec3 albedo = vec3(0.85, 0.85, 0.85);\n\t\tvec3 single_scatt = albedo * kappa * dl * reduced_sun(pos) * phasefunction(sun_direction(), rd);\n\t\t\n\t\t// Fake multiple scattering by a constant emission field (power is an ad-hoc aesthetic tune-\n\t\t// though the power 1.0 possibly has some physical basis, since the diffuse light can be expected\n\t\t// to be roughly proportional to the density of scatterers\n\t\tvec3 fake_multiple_scatt = albedo * kappa * dl * pow(2.0*kappa/KAPPA, 0.5) * vec3(0.85, 0.9, 0.93);\n\t\t\n\t\t// Accumulate integrand\n\t\tInScattered += Transmittance * (single_scatt + fake_multiple_scatt);\n\t}\n\n\tvec3 AttenuatedBackground = Transmittance*sky_color(rd);\n\treturn InScattered + AttenuatedBackground;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n    vec2 mo = -1.0 + 2.0*iMouse.xy / iResolution.xy;\n    \n    // camera\n    vec3 ro = 4.0*normalize(vec3(cos(2.75-3.0*mo.x), 1.5+(2.0*mo.y+1.0), sin(2.75-3.0*mo.x)));\n\tvec3 ta = vec3(0.0, 1.0, 0.0);\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n\t// raymarch to obtain transmittance along ray through clouds\n    vec3 L = primary( ro, rd );\n\n    fragColor = vec4( L, 1.0 );\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lssXzM","date":"1398636556","viewed":2270,"name":"Clouds physically-based III","username":"jamiep","description":"refinement","likes":41,"published":1,"flags":0,"usePreview":0,"tags":["clouds"],"hasliked":0,"parentid":"","parentname":""}}