{"ver":"0.1","info":{"id":"NlK3Wt","date":"1639050222","viewed":848,"name":"Cyberspace data warehouse","username":"bitless","description":"Should look good on full screen.","likes":77,"published":1,"flags":0,"usePreview":0,"tags":["2d","grid","hexagonal","cyberspace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: bitless\n// Title: Cyberspace data warehouse\n\n// Thanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\"\n// and Fabrice Neyret (FabriceNeyret2) for https://shadertoyunofficial.wordpress.com/\n// and Inigo Quilez (iq) for  https://iquilezles.org/www/index.htm\n// and whole Shadertoy community for inspiration.\n\n#define h21(p) ( fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453) ) //hash21\n#define BC vec3(.26,.4,.6) //base color\n\n//  Minimal Hexagonal Grid - Shane\n//  https://www.shadertoy.com/view/Xljczw\nvec4 getHex(vec2 p) //hex grid coords \n{\n    vec2 s = vec2(1, 1.7320508);\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/s.xyxy) + .5;\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + .5);\n}\n\nfloat noise( in vec2 f ) //gradient noise\n{\n    vec2 i = floor( f );\n    f -= i;\n    \n    vec2 u = f*f*(3.-2.*f);\n\n    return mix( mix( h21( i + vec2(0,0) ), \n                     h21( i + vec2(1,0) ), u.x),\n                mix( h21( i + vec2(0,1) ), \n                     h21( i + vec2(1,1) ), u.x), u.y);\n}\n\nvec3 HexToSqr (vec2 st, inout vec2 uf) //hexagonal cell coords to square face coords \n{ \n    vec3 r;\n    uf = vec2((st.x+st.y*1.73),(st.x-st.y*1.73))-.5; //upper face coord space\n    if (st.y > 0.-abs(st.x)*0.57777)\n        if (st.x > 0.) \n            r = vec3(fract(vec2(-st.x,(st.y+st.x/1.73)*0.86)*2.),2.); //right face\n        else\n            r = vec3(fract(vec2(st.x,(st.y-st.x/1.73)*0.86)*2.),3.); //left face\n    else \n        r = vec3 (fract(uf+.5),1); //top face\n    return r;\n} \n\n\nvoid sphere (vec4 hx, vec2 st, float sm,  inout vec4 R) //memory sphere full of data\n{\n    R -= R;\n\n    float   T = mod(iTime+h21(hx.zw*20.)*20.,20.)        //local time\n        ,   d = .4* ((T < 3.) ? sin(T*.52) :      //hole diameter\n                    ((T < 6.) ? 1. :   \n                    ((T < 9.) ? sin((9.-T)*.52) : \n                                0.)))\n        ,   y = .4* ((T < 4.) ? sin((T-1.)*.52) :  //sphere position\n                    ((T < 5.5) ? 1. :   \n                    ((T < 8.5) ? sin((8.5-T)*.52) : \n                    0.))) - .06          \n        ,   f = (.9 + noise(vec2(hx.x*50.+iTime*4.))*.3) //hole inner noise\n                * smoothstep(-.57,1.7,st.y-st.x); \n\n    R = mix (vec4(0), vec4(BC*f,1.), smoothstep(d+sm, d-sm, length(st)));//hole inner surface \n    R = mix (R, vec4(BC*.5,1.), smoothstep(sm, -sm, abs(length(st)-d)-.02)*smoothstep(0.,.02,d)); //hole ring\n\n    f = noise(hx.xy*vec2(12,7)+vec2(0,iTime*-4.))*.25+.5; //sphere noise\n\n    R = mix (R, \n                vec4(mix(\n                vec3(BC*8.)*f,          //sphere start color + noise\n                vec3(.15,.1,.1)             //sphere final color\n                ,sin(T*.48-1.8))             //transition timer\n                *(smoothstep(.1,.2,length(hx.xy+vec2(.0,y)))*.5 + .5) //brightness gradient from centre \n                *(smoothstep(-.02,-0.52,hx.y)),1.) ,             //illumination of the top of the sphere\n            smoothstep (.2+sm,.2-sm,length(hx.xy+vec2(.0,y))) //sphere mask\n            *((st.y-st.x >0.) ? 1. : smoothstep(d-.02+sm, d-.02-sm, abs(length(st)))) //hole mask\n        );\n}\n\nvoid pixel (float hh, float sm, vec2 st, vec2 s, float n,  vec4 R, inout vec4 C) //blinking pixels\n{\n    st = vec2(st.x,1.-st.y);\n    vec2    lc = 1.-fract(st*10.) //pixel local coords\n        ,   id = floor(st*10.) + s; //id of pixel or neigbour \n\n    float   b = ((4.-n)*2.2+.8)*.05 //face lightness\n        ,   th = .05            //pixel border thickness\n        ,   T = mod(iTime+hh*20.,20.) //local timer\n        ,   d = ((T < 3.) ? sin((T)*.52) :  //hole diameter\n                        ((T < 6.5) ? 1. :   \n                        ((T < 9.5) ? sin((9.5-T)*.52) : \n                                0.)))\n        ,   f =  min(\n                (pow(noise(id*hh*n+iTime*(.75+h21(id)*.15)*1.),8.)*2. //small picks\n                + (noise(id*.2 + iTime*(.5+hh*n)*.5)-.1)) //big noise\n                * smoothstep (6.,2.,length(id-4.5)) //fade noise to face edges\n                * ((n == 1.) ? (smoothstep(d*5., d*5.+2. ,length(id-4.5)+.5)) : 1.) //remove noise on top face while sphere is up \n                , 0.95); \n\n    vec4 P =  vec4(BC*(1.+hh*.75)*b,1); // pixel base color\n    if (s == vec2(0)) C = mix (P*.7, P*.9, step(0.,lc.x-lc.y)); //pixel background\n\n    vec2 m = s*2.-1.;\n    \n    if (s.x!=s.y) C = mix (C\n                            ,   mix(    P*.7\n                                    ,   P*.9\n                                    ,   step(lc.x-lc.y,0.))\n                            , step(lc.x+lc.y,f+f)\n                    *((m.y==-1.)?step(lc.x-lc.y+1.,1.):step(1.,lc.x-lc.y+1.))); //pixel side faces\n    C = mix (C, P,smoothstep(f+sm*m.x,f-sm*m.x,lc.x)*smoothstep(f+sm*m.y,f-sm*m.y,lc.y)); //pixel top face background\n    C = mix (C, mix(P*(.4+(f+pow(f,2.))*4.),R,.25) \n    ,smoothstep(f-(th-sm)*m.x,f-(th+sm)*m.x,lc.x)*smoothstep(f-(th-sm)*m.y,f-(th+sm)*m.y,lc.y)); //pixel top face color + sphere reflection\n}\n\nvoid tile(vec2 uv,inout vec4 C) \n{\n    vec4 hx = getHex(uv);\n    vec2 s; //top face square coordiantes \n    vec3 sqr = HexToSqr(hx.xy, s);\n    float n = sqr.z       //face id\n          ,sm = 3./iResolution.y  //smoothness\n          ,hh = h21(hx.zw*20.); //random value for tile\n          \n    vec2 st = sqr.xy; //  face square coordinates\n\n    vec4 R; //sphere or sphere reflection\n    \n    if (n == 1.) sphere (hx, st-vec2(.5), sm, R);  //sphere on top face\n    else if (n == 2.) sphere (hx +  vec4(0,-.6,.5,.5), s + vec2(0,1), .01, R);  //sphere reflection on right face \n    else sphere (hx + vec4(0,-.6,-.5,.5), s + vec2(0,1), .01, R);   //sphere reflection on left face\n\n    pixel (hh, sm, st, vec2(0,0), n,  R, C); //drawing pixel and his neighbors\n    pixel (hh, sm, st, vec2(1,0), n,  R, C);\n    pixel (hh, sm, st, vec2(0,1), n,  R, C);\n    pixel (hh, sm, st, vec2(1,1), n,  R, C);\n\n    if (n==1.) C = mix (C,R,R.a); //draw sphere on top face\n}\n\nvoid mainImage( out vec4 C, in vec2 g)\n{\n    vec2 rz = iResolution.xy\n        ,uv = (g+g-rz)/-rz.y;\n\n    uv *= .8+sin(iTime*.3)*.25; //camera scale\n    uv -= uv * pow(length(uv),2.5-sin(iTime*.3)*.5)*.025 +  //camera distortion\n        vec2(iTime*.2,cos(iTime*.2));   //camera translate\n    \n    C -= C;\n    tile(uv,C);\n}","name":"Image","description":"","type":"image"}]}