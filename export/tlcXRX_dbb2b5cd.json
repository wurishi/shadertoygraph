{"ver":"0.1","info":{"id":"tlcXRX","date":"1581427270","viewed":516,"name":"Checkerboard Analytic MotionBlur","username":"fizzer","description":"Linear motion blurring of a checkerboard pattern. I looked at this problem from some different perspectives including Calculus and spectral analysis, but I always arrived at a slow solution involving for-loops. So for now this is as close as I can get.","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["motionblur","checkerboard","analytic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// Analytic Linear Motion Blur Series:\n//\n// Self-Intersecting Polygon (XOR Rule) - https://www.shadertoy.com/view/tltXRS\n// Concave Polygon - https://www.shadertoy.com/view/tldSzS\n// Square - https://www.shadertoy.com/view/wtcSzB\n// Checkerboard - https://www.shadertoy.com/view/tlcXRX\n//\n\nvec2 cameraTransformation(vec2 p, float t)\n{\n    float a = t * 2. + sin(-t) * 1.5;\n    mat2 r = mat2(cos(a), sin(a), -sin(a), cos(a));\n    return (r * (p - vec2(cos(t / 2.), sin(t / 3.))) * 5. / pow(2., 1. + cos(t)));\n}\n\nfloat integrateCheckerboard(vec2 uv0, vec2 uv1)\n{\n  \tvec2 rd = uv1 - uv0;\n    \n    vec2 dt = abs(vec2(1) / rd);\n    vec2 t = (floor(uv0) + max(sign(rd), 0.) - uv0) * dt * sign(rd);\n    int e = int(floor(uv0.x) + floor(uv0.y)) & 1;\n    \n    float mt = 0., pt, a = 0.;\n    \n    for(int i = 0; i < 8; ++i)\n    {\n        pt = mt;\n        mt = min(t.x, t.y);\n        \n        if((i & 1) == e)\n        \ta += min(1., mt) - pt;\n\n        if(mt > 1.)\n            break;\n        \n        t += step(t, t.yx) * dt;\n    }\n    \n    return a;\n}\n\nfloat tri(float x)\n{\n    return abs(fract(x / 2. + .5) - .5) * 2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y * 2.;\n    \n    vec2 uv2 = uv;\n\n    if(uv.x < 0.)\n        uv.x += iResolution.x / iResolution.y;\n    \n    float t1 = iTime, t0 = iTime - 1. / 30.;\n    \n    vec2 uv0 = cameraTransformation(uv, t0);\n    vec2 uv1 = cameraTransformation(uv, t1);\n    \n    vec3 col = vec3(0);\n\n    float a = 0.;\n    \n    if(uv2.x < 0.)\n    {\n        // Product of integrals\n  \t\tvec2 d = uv1 - uv0;\n        vec2 b = vec2(tri(uv1.x) - tri(uv0.x), tri(uv1.y) - tri(uv0.y)) / d;\n\n    \ta = b.x * b.y * .5 + .5;\n    }\n    else\n    {\n        // Integral of products\n    \ta = integrateCheckerboard(uv0, uv1);\n    }\n    \n    col = mix(vec3(.1), vec3(.9), a);\n    \n    col = mix(col, vec3(1., .2, .1), step(abs(uv2.x), .01));\n\n    fragColor = vec4(pow(col, vec3(1. / 2.2)),1.0);\n}","name":"Image","description":"","type":"image"}]}