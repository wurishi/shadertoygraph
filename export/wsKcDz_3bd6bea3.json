{"ver":"0.1","info":{"id":"wsKcDz","date":"1602698667","viewed":195,"name":"Raymarching in Jumpflood v2","username":"wilsnat","description":"https://www.shadertoy.com/view/lsKGDV & https://www.shadertoy.com/view/lltcRN\nIdea from https://www.reddit.com/r/godot/comments/ief8xc/working_on_2d_global_illumination_for_godot/\n\nOptimized with:\n-texelFetch\n-better temporal blending\n-cheaty inital rays","likes":9,"published":1,"flags":48,"usePreview":0,"tags":["raymarch","lighting","jumpflood"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Raymarching in jump flood\" by wilsnat. https://shadertoy.com/view/tlSfzh\n// 2020-10-14 03:07:24\n\nconst float c_gamma = 2.2;\n\nconst float KEY_1 = 49.5/256.0;\nconst float KEY_2 = 50.5/256.0;\n\n//============================================================\nvoid DecodeData (in vec4 data, out vec2 coord, out vec3 color)\n{\n    coord = data.xy;\n    color.x = floor(data.z / 256.0) / 255.0;\n    color.y = mod(data.z, 256.0) / 255.0;\n    color.z = mod(data.w, 256.0) / 255.0;\n}\n\nvec3 Linear2sRGB(vec3 color){\n    vec3 x = color * 12.92;\n    vec3 y = 1.055 * pow(clamp(color,0.,1.),vec3(0.4166667)) - 0.055;\n    vec3 clr = color;\n    clr.r = (color.r < 0.0031308) ? x.r : y.r;\n    clr.g = (color.g < 0.0031308) ? x.g : y.g;\n    clr.b = (color.b < 0.0031308) ? x.b : y.b;\n    return clr;\n}\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 outColor = vec3(0);\n    // if the 1 key is pressed, show distance info instead\n    if (texture(iChannel2, vec2(KEY_1,0.25)).x > 0.1)\n    {\n        vec4 data =texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n        // decode this pixel\n        vec2 seedCoord;\n        vec3 seedColor;\n        vec3 outColor = vec3(0);\n        DecodeData(data, seedCoord, seedColor);\n        float dist = length(seedCoord - fragCoord) / 25.0;\n        //seedColor = vec3(seedCoord-fragCoord,0);\n        outColor = vec3(dist);\n\n    } \n    else if (texture(iChannel2, vec2(KEY_2,0.25)).x > 0.1)\n    {\n            vec4 data =texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n            // decode this pixel\n            vec2 seedCoord;\n            vec3 seedColor;\n            DecodeData(data, seedCoord, seedColor);\n    \t    // highlight the seeds a bit\n            if (length(fragCoord-seedCoord) > 5.0)\n                outColor *= 0.75;\n    }\n    else\n    {\n    \toutColor = Linear2sRGB(texelFetch(iChannel1, ivec2(fragCoord), 0).rgb);\n    }\n    \n    // gamma correct\n\toutColor = pow(outColor, vec3(1.0/c_gamma));\n    fragColor = vec4(outColor, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//chance of a pixel being a seed, assuming rand() is a good rng\nconst float c_seedChance = 0.0004;\n\n// how many frames between steps.  1.0 = full speed.\nconst float c_frameStepDelay = 7.0;\n\n// how many JFA steps to do.  2^c_maxSteps is max image size on x and y\nconst float c_maxSteps = 10.0;\n\n//============================================================\n// Hash without sine from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 .1031\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//============================================================\n// returns 0..1\nfloat Rand(vec2 co)\n{\n    co.x += fract(iDate.w * 5.342);\n    co.y += fract(iDate.w * 11.214);\n    return hash12(co);\n}\n\n//============================================================\nvec3 RandColor (vec2 co)\n{\n    return vec3\n    (\n        Rand(co),\n        Rand(co*2.143),\n        Rand(co*3.163)\n\t);\n}\n\n//============================================================\nvec4 EncodeData (in vec2 coord, in vec3 color)\n{\n    vec4 ret = vec4(0.0);\n    ret.xy = coord;\n    ret.z = floor(color.x * 255.0) * 256.0 + floor(color.y * 255.0);\n    ret.w = floor(color.z * 255.0);\n    return ret;\n}\n\n//============================================================\nvoid DecodeData (in vec4 data, out vec2 coord, out vec3 color)\n{\n    coord = data.xy;\n    color.x = floor(data.z / 256.0) / 255.0;\n    color.y = mod(data.z, 256.0) / 255.0;\n    color.z = mod(data.w, 256.0) / 255.0;\n}\n\n//============================================================\nvec4 StepJFA (in vec2 fragCoord, in float level)\n{\n    level = clamp(level, 0.0, c_maxSteps);\n    float stepwidth = floor(exp2(c_maxSteps - level)+0.5);\n    \n    float bestDistance = 9999.0;\n    vec2 bestCoord = vec2(0.0);\n    vec3 bestColor = vec3(0.0);\n    \n    for (int y = -1; y <= 1; ++y) {\n        for (int x = -1; x <= 1; ++x) {\n            vec2 sampleCoord = fragCoord + vec2(x,y) * stepwidth;\n            \n            vec4 data = texture( iChannel0, sampleCoord / iChannelResolution[0].xy);\n            vec2 seedCoord;\n            vec3 seedColor;\n            DecodeData(data, seedCoord, seedColor);\n            float dist = length(seedCoord - fragCoord);\n            if ((seedCoord.x != 0.0 || seedCoord.y != 0.0) && dist < bestDistance)\n            {\n                bestDistance = dist;\n                bestCoord = seedCoord;\n                bestColor = seedColor;\n            }\n        }\n    }\n    \n    return EncodeData(bestCoord, bestColor);\n}\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // initialize random seed locations and colors\n    if (iFrame == 0) {\n        if (Rand(fragCoord) > (1.0 - c_seedChance))\n           fragColor = EncodeData(fragCoord, RandColor(fragCoord));\n        else\n           fragColor = vec4(0.0);\n        return;\n    }\n    \n    //fragColor = StepJFA(fragCoord, floor(float(iFrame-1)));\n    \n    // periodic steps\n\tif (mod(float(iFrame), c_frameStepDelay) == 0.0)\n        fragColor = StepJFA(fragCoord, floor(float(iFrame) / c_frameStepDelay));\n    else\n        fragColor = texture( iChannel0, fragCoord.xy / iChannelResolution[0].xy);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define EPSILON .5\n#define PI 3.141596\nconst float KEY_3 = 51.5/256.0;\n\n//size of circles from SDF\n#define circSizeMult 1./60.\n//if defined, bounces are directional\n#define WEIGHTED 1\n//rays from each pixel (very costly)\nconst float RAYS_PER_PIXEL = 4.;\n//temporal denoiser\nconst float BLEND = 7.;\n//number of steps each ray takes to find contact point\nconst int TRACE_STEPS = 32;\n\n#define HASHSCALE1 .1031\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Rand(vec2 co)\n{\n    co.x += fract(iDate.w * 5.342);\n    co.y += fract(iDate.w * 11.214);\n    return hash12(co);\n}\n\nvoid DecodeData (in vec4 data, out vec2 coord, out vec3 color)\n{\n    coord = data.xy;\n    color.x = floor(data.z / 256.0) / 255.0;\n    color.y = mod(data.z, 256.0) / 255.0;\n    color.z = mod(data.w, 256.0) / 255.0;\n}\n\nfloat sdSphere( vec2 p, float s )\n{\n  return length(p)-s;\n}\n\nvec2 seedCoord;\nvec3 seedColor;\nfloat seedSize = .01;\n\nstruct Material{\n\tfloat emission;\n    vec3 color;\n};\n\n#define lightTime iTime * 0.6\n//define LIGHT_DIST sdSphere((uv+1.)*.5 - vec2(sin(lightTime),cos(lightTime)*(sin(lightTime*1.2123341) + 1.)*0.5), 0.1)\n#define LIGHT_DIST sdSphere(f - iMouse.xy, 10.)/800.\n#define LIGHT_DIST2 sdSphere(f - iMouse.xy, 10.)\n\nMaterial getSeedMaterial(vec2 f)\n{\n    DecodeData(texelFetch( iChannel0, ivec2(f),0), seedCoord, seedColor);\n\tif(LIGHT_DIST2 < EPSILON)\n    {\n        return Material(1., vec3(1.));\n    }\n    else if(length((floor(seedCoord)-floor(f))/iResolution.x)-seedColor.z*circSizeMult < 4.)\n    {\n        return Material(0., seedColor);\n    }\n    else\n    {\n    \treturn Material(0., vec3(1.));\n    }\n}\n\nfloat mapSeedNoLight(vec2 f)\n{\n    DecodeData(texelFetch( iChannel0, ivec2(f),0), seedCoord, seedColor);\n    return length((floor(seedCoord)-floor(f)))-seedColor.z*circSizeMult*iResolution.x;\n}\n\nfloat mapSeed(vec2 f)\n{\n    return min(LIGHT_DIST2, mapSeedNoLight(f));\n}\n\nfloat mapSeed01(vec2 f)\n{\n    //uv = (uv + 1.)/2.;\n    DecodeData(texelFetch( iChannel0, ivec2(f),0), seedCoord, seedColor);\n    return min(LIGHT_DIST, length((floor(seedCoord)-floor(f))/iResolution.x)-seedColor.z*circSizeMult);\n}\n\nfloat maxmax(float a, float b, float c){return max(max(a,b),c);}\n\nfloat getEmissionFromBuffer(vec2 st)\n{\n    ivec2 ist = ivec2(st);\n\tfloat a0 = texelFetch(iChannel1, ist, 0).a;\n    float a1 = texelFetch(iChannel1, ist + ivec2(-1, 1), 0).a;\n    float a2 = texelFetch(iChannel1, ist + ivec2(0, 1), 0).a;\n    float a3 = texelFetch(iChannel1, ist + ivec2(1, 1), 0).a;\n    float a4 = texelFetch(iChannel1, ist + ivec2(-1, 0), 0).a;\n    float a5 = texelFetch(iChannel1, ist + ivec2(1, 0), 0).a;\n    float a6 = texelFetch(iChannel1, ist + ivec2(-1, -1), 0).a;\n    float a7 = texelFetch(iChannel1, ist + ivec2(0, -1), 0).a;\n    float a8 = texelFetch(iChannel1, ist + ivec2(1, -1), 0).a;\n    return maxmax(maxmax(a0,a1,a2),maxmax(a3,a4,a5),maxmax(a6,a7,a8));  \n}\n\nvec4 getAvgFromBuffer(vec2 st)\n{\n    ivec2 ist = ivec2(st);\n    vec4 a0 = texelFetch(iChannel1, ist, 0);\n    vec4 a1 = texelFetch(iChannel1, ist + ivec2(-1, 1), 0);\n    vec4 a2 = texelFetch(iChannel1, ist + ivec2(0, 1), 0);\n    vec4 a3 = texelFetch(iChannel1, ist + ivec2(1, 1), 0);\n    vec4 a4 = texelFetch(iChannel1, ist + ivec2(-1, 0), 0);\n    vec4 a5 = texelFetch(iChannel1, ist + ivec2(1, 0), 0);\n    vec4 a6 = texelFetch(iChannel1, ist + ivec2(-1, -1), 0);\n    vec4 a7 = texelFetch(iChannel1, ist + ivec2(0, -1), 0);\n    vec4 a8 = texelFetch(iChannel1, ist + ivec2(1, -1), 0);\n    vec4 avg = (a0+a1+a2+a3+a4+a5+a6+a7+a8)/9.;\n    avg.a = maxmax(maxmax(a0.a,a1.a,a2.a),maxmax(a3.a,a4.a,a5.a),maxmax(a6.a,a7.a,a8.a));\n    return avg;\n}\n\nbool traceSeed(vec2 origin, vec2 ray, out vec2 hitPos, out float d)\n{\n    float t = 0.;\n    float dist;\n    vec2 samplePoint;\n    for(int i = 0; i < TRACE_STEPS; i++)\n    {\n        samplePoint = origin + ray * t;\n        if(samplePoint.x < 0. || samplePoint.x > iResolution.x) return false;\n        if(samplePoint.y < 0. || samplePoint.y > iResolution.y) return false;\n        dist = mapSeed(samplePoint);\n        t += dist;\n        d = t;\n        if(dist < EPSILON)\n        {\n            hitPos = samplePoint;\n            return true;\n        }   \n    }\n    return false;\n}\n\nvec2 estimateNormal(vec2 p) {\n    return normalize(vec2(\n        mapSeed01(vec2(p.x + 1., p.y)) - mapSeed01(vec2(p.x - 1., p.y)),\n        mapSeed01(vec2(p.x, p.y + 1.)) - mapSeed01(vec2(p.x, p.y - 1.))\n    ));\n}\n\nvec2 blend(vec2 old, vec2 new, float i){return (1.-(1./i))*old + (1./i) * new;}\nvec3 blend(vec3 old, vec3 new, float i){return (1.-(1./i))*old + (1./i) * new;}\nvec4 blend(vec4 old, vec4 new, float i){return (1.-(1./i))*old + (1./i) * new;}\nfloat attenuate(float d){return pow(max(1.0 - (d*d)/(iResolution.y*iResolution.y),0.),4.);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//black if in a cirlce\n    if(mapSeedNoLight(fragCoord)<0.){fragColor = vec4(0);return;}\n    \n    //fetch last frame\n    DecodeData(texelFetch( iChannel0, ivec2(fragCoord),0), seedCoord, seedColor);\n    vec4 oldCol  = texelFetch(iChannel1, ivec2(fragCoord),0);\n    vec4 avg = getAvgFromBuffer(fragCoord);\n    \n    vec3 col = vec3(0.);\n    float emis = 0.;\n    \n    //noise sample and ray angle\n    vec2 time = vec2(iTime * 0.923213456123, -iTime *0.99584367);\n    float rand02pi = Rand(seedCoord*time*fragCoord/iResolution.xy)*2.*PI;\n    float golden_angle = PI * (3. - sqrt(5.));\n    \n    //send out rays from pixel looking for emitting surface\n    Material mat;\n    for(float i = 0.; i < RAYS_PER_PIXEL; i++)\n    {\n        vec2 hitPos;\n        float dist;\n        float curAngle = rand02pi + golden_angle * i;\n        vec2 randDirection = vec2(cos(curAngle),sin(curAngle));\n        //cheaty first ray\n        if(i==0.)\n        {\n            vec2 v  = iMouse.xy-fragCoord;\n            if(sign(randDirection.x) == sign(v.x) && sign(randDirection.y)==sign(v.y))\n            {\n            \trandDirection = blend(v/length(v),randDirection,50.);\n            \trandDirection = randDirection/length(randDirection);\n            }\n        }\n        //cheaty second ray\n        if(i==1.)\n        {\n            vec2 v  = seedCoord-fragCoord;\n            if(sign(randDirection.x) == sign(v.x) && sign(randDirection.y)==sign(v.y))\n            {\n            \trandDirection = blend(v/length(v),randDirection,50.);\n            \trandDirection = randDirection/length(randDirection);\n            }\n        }\n        bool hit = traceSeed(fragCoord, randDirection, hitPos, dist);\n        if(hit)\n        {\n            mat = getSeedMaterial(hitPos);\n            float d = max(dist,0.);\n            vec2 st = hitPos;   \n\n            float lastEmission = 0.;\n            if(mat.emission <= EPSILON)\n            {\n            \tlastEmission = getEmissionFromBuffer(st);\n                #ifdef WEIGHTED\n                vec2 normal = estimateNormal(hitPos);\n            \tfloat c = clamp(dot(-randDirection,normal),0.,1.);\n                lastEmission *= c;\n                #endif\n            }\n            if( iFrame==0 || d < EPSILON) lastEmission = 0.0;\n            \n            float emission = mat.emission + lastEmission;\n            float att = attenuate(d);\n            emis += emission*att;\n            col += (mat.emission + lastEmission)*mat.color*att;\n        }\n    }\n    col *= (1./RAYS_PER_PIXEL);\n    emis *= (1./RAYS_PER_PIXEL);\n\n    if(length(oldCol)>0.) oldCol.rgb = avg.rgb;\n    vec3 total = col;\n    \n    if( iFrame==0 ) oldCol.rgb = vec3(0.0);\n    \n    fragColor = vec4(blend(oldCol.rgb,total,BLEND), max(emis,avg.a-1./BLEND));\n\t\n    if (texture(iChannel2, vec2(KEY_3,0.25)).x > 0.1)\n    {\n    \tfragColor = vec4(vec3(mapSeed(fragCoord.xy)/iResolution.y),1.);\n\n    }\n\n}","name":"Buffer B","description":"","type":"buffer"}]}