{"ver":"0.1","info":{"id":"tsXSRs","date":"1551871125","viewed":2137,"name":"Unity (Shadertoy port)","username":"noby","description":"This is my port of Unity3D to Shadertoy. The rest will be done Some Day.\n\nReference image: https://unity3d.com/sites/default/files/reflectionsource_0.png","likes":29,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","engine","unity","unity3d","rtx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float gamma = 2.2;\n\nstruct Plane{\n\tvec3 position;\n    float width;\n    float height;\n};\n\nstruct Sphere{\n    vec3 position;\n    float diameter;\n};\n\nPlane plane;\nSphere sphere;\n\nvec2 sphere_coordinates(vec3 p){\n    float u = atan(p.x, p.z);\n    float v = acos(p.y);\n    return vec2(u, v);\n}\n\nvec3 skydome(vec2 uv){\n    const float pi = 3.14159;\n    const vec3 ground   = pow(vec3(0.416, 0.396, 0.382), vec3(gamma));\n    const vec3 horizon  = pow(vec3(0.915, 0.97, 0.99),   vec3(gamma));\n    const vec3 sky_low  = pow(vec3(0.827, 0.94, 0.96),   vec3(gamma));\n    const vec3 sky_mid  = pow(vec3(0.541, 0.637, 0.78),  vec3(gamma));\n    const vec3 sky_high = pow(vec3(0.403, 0.5, 0.655),   vec3(gamma));\n    const vec3 sky_top  = pow(vec3(0.271, 0.345, 0.482), vec3(gamma));\n    \n    vec3 h = vec3(0); \n    h = mix(ground, horizon, smoothstep(pi*0.5-0.02, pi*0.51, uv.y));\n    h = mix(h, sky_low,  smoothstep(pi*0.5-0.02, pi*0.53, uv.y));\n    h = mix(h, sky_mid,  smoothstep(pi*0.5, pi*0.6, uv.y));\n    h = mix(h, sky_high, smoothstep(pi*0.52, pi*0.8, uv.y));\n    h = mix(h, sky_top,  smoothstep(pi*0.54, pi, uv.y));\n    \n    return mix(h+sky_low*0.01, h, smoothstep(pi*0.2, pi*0.6, uv.y));\n}\n\nfloat intersect_sphere(vec3 ro, vec3 rd){\n    vec3 oc = ro - sphere.position;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - pow(sphere.diameter, 2.0);\n    float h = b*b - c;\n    if(h < 0.0)\n        return -1.0;\n    return -b - sqrt(h);\n}\n\nfloat intersect_plane(vec3 ro, vec3 rd){\n    ro -= plane.position;\n    float t = (-ro.y/rd.y);\n    vec3 pos = ro+rd*t;\n    \n    if(abs(plane.position.x-pos.x) > plane.width)  return -1.0;\n    if(abs(plane.position.z-pos.z) > plane.height) return -1.0;\n    return t;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    float a = -1.49;\n    float b = 2.34;\n    if(iMouse.z > 0.0){\n        a = 0.5*3.14159*(-1.0+2.0* (iMouse.y/iResolution.y-0.51));\n        b =     3.14159*(-1.0+2.0*-(iMouse.x/iResolution.x-0.39));\n    }\n    \n    fragColor = vec4(0);\n    const int AA = 2;\n    \n    for(int i = 0; i < AA; ++i)\n    for(int j = 0; j < AA; ++j){\n        vec2 p = fragCoord + (-1.0+2.0*vec2(i, j))/(2.0*float(AA));\n        vec2 uv = -1.0+2.0*p/iResolution.xy;\n        \n        uv.x *= iResolution.x / iResolution.y;\n\n        vec3 cam = vec3(-5, -0.2, 5);\n        vec3 dir = normalize(vec3(uv, 2.2));\n        dir.yz *= mat2(sin(a), cos(a), -cos(a), sin(a));\n        dir.xz *= mat2(sin(b), cos(b), -cos(b), sin(b));\n        dir = normalize(dir);\n\n        plane  = Plane(vec3(-1.3, 1, 1.4), 3.0, 3.0);\n        sphere = Sphere(vec3(-2.5, 0, 2.5), 1.0);\n        float plane_intersection = intersect_plane(cam, dir);\n        float sphere_intersection = intersect_sphere(cam, dir);\n        bool plane_hit  = (plane_intersection > 0.0 &&\n                            (sphere_intersection > 0.0 &&\n                             plane_intersection < sphere_intersection ||\n                             sphere_intersection <= 0.0));\n        bool sphere_hit = (sphere_intersection > 0.0 &&\n                            (plane_intersection > 0.0 &&\n                             sphere_intersection < plane_intersection ||\n                             plane_intersection <= 0.0));\n\n        vec3 color = vec3(0);\n        const vec3 light_position = vec3(-6.5, 7, -1);\n\n        if(plane_hit){\n            const vec3 ground_color = pow(vec3(0.5), vec3(gamma));\n            const vec3 ambient = pow(vec3(0.207, 0.255, 0.333), vec3(gamma));\n\n            vec3 intersection = cam + plane_intersection*dir;\n            vec3 light_direction = normalize(intersection-light_position);\n            float in_shadow = intersect_sphere(intersection, light_direction);\n\n            color = mix(ground_color, ambient, step(0.0, in_shadow));\n            color *= mix(1.1, 0.9, smoothstep(0.0,6.0,distance(cam, intersection)));\n\n        } else if(sphere_hit) {\n            vec3 intersection = cam + sphere_intersection*dir;\n            vec3 normal = normalize(sphere.position - intersection);\n            vec3 reflection_dir = reflect(dir, normal);\n\n            vec3 sky_reflection = skydome(sphere_coordinates(reflection_dir));\n            color = sky_reflection;\n\n            vec3 specular_direction = normalize(intersection-light_position);\n            float specular_spot = max(0.0, dot(reflection_dir, specular_direction));\n            color += smoothstep(0.9985, 0.999, specular_spot);\n\n        } else {\n            vec3 sky = skydome(sphere_coordinates(dir));\n            color = sky;\n        }\n        \n        fragColor.rgb += color;\n    }\n    \n    fragColor.rgb = pow(fragColor.rgb/float(AA*AA), vec3(1.0/gamma));\n}\n\n// In case it wasn't clear, this shader is of course a joke.\n// Unity and Unity3D are (probably) registered trademarks\n// owned by Unity Technologies.\n// No copyrights intended.","name":"Image","description":"","type":"image"}]}