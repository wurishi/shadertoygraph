{"ver":"0.1","info":{"id":"tstfRN","date":"1605004488","viewed":135,"name":"penguin","username":"zchajax","description":"A simple penguin\n\n","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","penguin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\n\n#define MATERIAL_BODY 1.0\n#define MATERIAL_MOUTH 2.0\n#define MATERIAL_EYE 3.0\n#define MATERIAL_NECK 4.0\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdTorus(vec3 p, vec2 r)\n{\n    float x = length(p.xz) - r.x;\n    return length(vec2(x, p.y)) - r.y;\n}\n\nfloat sdEllipsoid(vec3 p, vec3 r)\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h)\n{\n    p.z *= 3.0;\n    vec2 q = vec2(length(p.xz), p.y);\n      \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n      \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n          \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdCappedTorus(vec3 p, vec2 sc, float ra, float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvec3 rotateX(vec3 p, float t)\n{\n    float cost = cos(t);\n    float sint = sin(t);\n    mat3 mat = mat3(\n        1.0,  0.0,  0.0,\n        0.0, cost, -sint,\n        0.0, sint, cost);\n    return mat * p;\n}\n\nvec3 rotateY(vec3 p, float t)\n{\n    float cost = cos(t);\n    float sint = sin(t);\n    mat3 mat = mat3(\n         cost,  0.0, sint,\n         0.0,   1.0, 0.0,\n         -sint, 0.0, cost);\n    return mat * p;\n}\n\nvec3 rotateZ(vec3 p, float t) \n{\n    float cost = cos(t);\n    float sint = sin(t);\n    mat3 mat = mat3(\n         cost,-sint, 0.0,\n         sint, cost, 0.0,\n          0.0,  0.0, 1.0);\n    return mat * p;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 sdf(vec3 p) \n{\n    p = rotateZ(p, sin(iTime * 8.0) * 0.03);\n    \n    vec2 res = vec2( 1e10, 0.0 );\n    \n    // body\n    float dist = opSmoothUnion(\n        sdEllipsoid(p - vec3(0.0, 1.0, 0.0), vec3(2.1, 2.2, 1.8)),\n        sdSphere(p - vec3(0.0, 3.0, 0.0), 1.6), 0.5);\n\n    // arms\n    const vec3 leftArmPos = vec3(-2.35, 1.1, 0);\n    const vec3 rightArmPos = leftArmPos * vec3(-1.0, 1.0, 1.0);\n    const vec3 armThickness = vec3(1.0, 0.3, 0.8);\n    dist = opSmoothUnion(dist,\n        sdEllipsoid(rotateZ(p - leftArmPos, 0.95 + sin(iTime* 8.0) * 0.05), armThickness), 0.1);\n    dist = opSmoothUnion(dist,\n        sdEllipsoid(rotateZ(p - rightArmPos, -0.95 - sin(iTime* 8.0) * 0.05), armThickness), 0.1);\n    \n    res = opU(res, vec2(dist, MATERIAL_BODY));\n    \n    // belly\n    dist = sdEllipsoid(p - vec3(0.0, 1.0, 0.4), vec3(2.1, 2.2, 1.8)*0.9);\n    res = opU(res, vec2(dist, MATERIAL_EYE));\n    \n    // foot\n    const vec3 leftFootPos = vec3(-1.2, -0.9, 0.3);\n    const vec3 rightFootPos = vec3(-leftFootPos.x, leftFootPos.y, leftFootPos.z);\n    const vec3 footSize = vec3(1.0, 0.4, 1.0);\n    dist = min(\n        sdEllipsoid(rotateX(p - leftFootPos, 0.0), footSize),\n        sdEllipsoid(rotateX(p - rightFootPos, 0.0), footSize));\n\n    // mouth\n    dist = min(dist, sdRoundCone(rotateX(p - vec3(0.0, 2.5, 2.0), 3.23 * PI/2.0), 0.1, 0.7, 0.6));\n    res = opU(res, vec2(dist, MATERIAL_MOUTH));\n\n    // eyes\n\tconst vec3 leftEyePos = vec3(-0.5, 3.4, 1.0);\n    const vec3 rightEyePos = leftEyePos*vec3(-1.0, 1.0, 1.0);\n    const vec3 eyeSize = vec3(0.5, 0.68, 0.68);\n    dist = min(\n        sdEllipsoid(p - leftEyePos, eyeSize), \n        sdEllipsoid(p - rightEyePos, eyeSize));\n    res = opU(res, vec2(dist, MATERIAL_EYE));\n    \n    // eyeball\n    vec3 leftEyeballPos = vec3(-0.43 , 3.45, 1.67);\n    vec3 rightEyeballPos = vec3(0.43, 3.45, 1.67);\n    \n    // left\n    dist = sdEllipsoid(p - leftEyeballPos, vec3(0.2, 0.22, 0.1));\n    res = opU(res, vec2(dist, MATERIAL_BODY));\n    \n    // right\n    dist = mix(\n        sdCappedTorus(rotateZ(p - rightEyeballPos, -0.1) * vec3(1.1, 0.8, 0.8), vec2(0.7,-0.5), 0.15, 0.05),\n        sdEllipsoid(p - rightEyeballPos, vec3(0.2, 0.22, 0.1)), \n        step(fract(iTime * 0.5), 0.5));\n    res = opU(res, vec2(dist, MATERIAL_BODY));\n    \n    // neck\n    vec3 neckPos = p - vec3(0.0, 2.27, 0.0);\n\tneckPos.y *= 0.7;\n    dist = opSmoothUnion(\n        \t\tsdTorus(neckPos, vec2(1.7, 0.2)),\n               \tsdEllipsoid(p - vec3(-1.0, 1.8, 1.6), vec3(0.3, 0.5, 0.1)), 0.25);\n    res = opU(res, vec2(dist, MATERIAL_NECK));\n    return res;\n}\n\nvec3 normal(in vec3 p)\n{\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          sdf(p + epsilon.xyy).x - sdf(p - epsilon.xyy).x,\n          sdf(p + epsilon.yxy).x - sdf(p - epsilon.yxy).x,\n          sdf(p + epsilon.yyx).x - sdf(p - epsilon.yyx).x);\n    return normalize(n);\n}\n\nvec2 rayMarching(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    vec2 res;\n\n    for(int i=0; i < 300; ++i) \n    {\n        vec3 p = ro + t * rd;\n        res = sdf(p);\n        t += res.x;\n        if(res.x < 0.0001)\n            break;\n    }\n   \n    res.x = t;\n    return res;\n}\n\nvec3 getAlbedo(float material)\n{\n    if (material == MATERIAL_BODY)\n    {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    else if (material == MATERIAL_MOUTH)\n    {\n        return vec3(1.0, .3, 0.0);\n    }\n   \telse if (material == MATERIAL_EYE)\n    {\n        return vec3(1.0, 1.0, 1.0);\n    }\n    else if (material == MATERIAL_NECK)\n    {\n        return vec3(1.0, 0.0, 0.0);\n    }\n    else\n    {\n        return vec3(1.0, 1.0, 1.0);\n    }\n}\n\nvec3 getSpecular(float material)\n{\n    if (material == MATERIAL_BODY)\n    {\n        return vec3(0.5, 0.5, 0.5);\n    }\n    else if (material == MATERIAL_MOUTH)\n    {\n        return vec3(1.0, 0.7, 0.0);\n    }\n   \telse if (material == MATERIAL_EYE)\n    {\n        return vec3(1.0, 1.0, 1.0);\n    }\n    else if (material == MATERIAL_NECK)\n    {\n        return vec3(0.3, 0.3, 0.3);\n    }\n    else\n    {\n        return vec3(0.0, 0.0, 0.0);\n    }\n}\n\nvec3 lighting(vec3 eyeDir, vec3 p, float mat)\n{\n    vec3 diffuse = vec3(0);\n    vec3 specular = vec3(0);\n    vec3 normal = normal(p);\n\n    // direct light\n    vec3 lightPos = vec3(5.0, 25.0, 10.0);\n    vec3 lightColor = vec3(1., .956, .839);\n    vec3 lightDir = normalize(lightPos - p);\n    float directDiffuse = clamp(dot(normal, lightDir), 0.0, 1.0);\n    float directspecular = pow(clamp(dot(reflect(lightDir, normal), eyeDir), 0.0, 1.0), 10.0);\n    diffuse  += lightColor * directDiffuse;\n    specular += lightColor * directspecular;\n\n    // ambient\n    diffuse += vec3(0.5, 0.7, 1.0) * 0.3;\n\n    // final color\n    vec3 col = diffuse * getAlbedo(mat) + specular * getSpecular(mat);\n\n    // Gamma correction\n    col = pow(col, vec3(0.4545));\n\n    return col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll, float fov)\n{\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 lookdir = normalize(target - origin);\n    vec3 uu = normalize(cross(lookdir, rr));\n    vec3 vv = normalize(cross(uu, lookdir));\n    vec3 ww = lookdir * (1.0 / tan(fov*PI/360.0));\n\n    return mat3(uu, vv, ww);\n}\n\nvec3 render(vec2 uv)\n{\n    vec3 camPos = vec3(0, 11.0, 30.0);\n    vec3 camTarget = vec3(0, 1, 0);\n    \n    mat3 mat = lookAt(camPos, camTarget, 0.0, 20.0);\n    vec3 ro = camPos;\n    vec3 rd = normalize(mat * vec3(uv, 1.0));\n    \n    vec2 res = rayMarching(ro, rd);\n    if (res.y == 0.0)\n    {\n        return vec3(0.5);\n    }\n    vec3 p = ro + rd * res.x;\n    vec3 col = lighting(rd, p, res.y);\n    return col;\n}\n\nvoid mainImage(out vec4 fragcolor, in vec2 fragcoord) \n{\n    vec2 uv = 2.0 * ((fragcoord- 0.5 * iResolution.xy) / iResolution.y);\n    vec3 col = render(uv);\n    fragcolor = vec4(col,1);\n}\n","name":"Image","description":"","type":"image"}]}