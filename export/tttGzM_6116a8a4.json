{"ver":"0.1","info":{"id":"tttGzM","date":"1576412124","viewed":160,"name":"Grill Meat","username":"MapleSyrupCS6","description":"Grilled meat","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["maplestudy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int   OCT  = 8;         // オクターブ\nconst float PST  = 0.5;       // パーセンテージ\nconst float PI   = 3.1415926; // 円周率\n\n// 補間関数\nfloat interpolate(float a, float b, float x){\n    float f = (1.0 - cos(x * PI)) * 0.5;\n    return a * (1.0 - f) + b * f;\n}\n// 乱数生成（その１）\n// float rnd(vec2 p){\n//     return fract(sin(dot(p ,vec2(12.9898,78.233))) * 43758.5453);\n// }\n// 乱数生成器（その２）\nfloat rnd(vec2 n){\n    float a = 0.129898;\n    float b = 0.78233;\n    float c = 437.585453;\n    float dt= dot(n ,vec2(a, b));\n    float sn= mod(dt, 3.14);\n    return fract(sin(sn) * c);\n}\n// 補間＋乱数\nfloat irnd(vec2 p){\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec4 v = vec4(rnd(vec2(i.x,       i.y      )),\n                  rnd(vec2(i.x + 1.0, i.y      )),\n                  rnd(vec2(i.x,       i.y + 1.0)),\n                  rnd(vec2(i.x + 1.0, i.y + 1.0)));\n    return interpolate(interpolate(v.x, v.y, f.x), interpolate(v.z, v.w, f.x), f.y);\n}\n// ノイズ\nfloat noise(vec2 p){\n    float t = 0.0;\n    for(int i = 0; i < OCT; i++){\n        float freq = pow(2.0, float(i));\n        float amp  = pow(PST, float(OCT - i));\n        t += irnd(vec2(p.x / freq, p.y / freq)) * amp;\n    }\n    return t;\n}\n// シームレスノイズ\nfloat snoise(vec2 p, vec2 q, vec2 r){\n    return noise(vec2(p.x,       p.y      )) *        q.x  *        q.y  +\n           noise(vec2(p.x,       p.y + r.y)) *        q.x  * (1.0 - q.y) +\n           noise(vec2(p.x + r.x, p.y      )) * (1.0 - q.x) *        q.y  +\n           noise(vec2(p.x + r.x, p.y + r.y)) * (1.0 - q.x) * (1.0 - q.y);\n}\n\n\nvec3 BackImage(vec2 uv ){\n\n     vec3 col = vec3(0.0);\n    \n    //col = texture(iChannel0, uv).rgb;\n    //vec2 col2 = texture(iChannel0, uv).rg;\n    \n    vec3 c1 = vec3(0.9, 0.9, 0.9);\n    vec3 c2 = vec3(0.9, 0.9, 0.9);\n    float noiseStrength = 1.0;\n    \n    vec2 firstOffset = vec2(0.0, iTime * 300.0); //この300の部分がスクロールする速度の差\n    float first = snoise(gl_FragCoord.st - firstOffset, col.rg , iResolution.xy);\n    // シームレスなバリューノイズを生成する（その２） @@@\n    vec2 secondOffset = vec2(0.0, iTime * 500.0);\n    float second = snoise(gl_FragCoord.st - secondOffset, col.rg, iResolution.xy);\n    // ２つのノイズを加算して強度係数を乗算 @@@\n    vec3 noiseColor = (c1 * first + c2 * second) * noiseStrength;\n\n    // ２つのノイズを加算した結果をグラデーション風にする @@@\n    float y = 1.0 - uv.t;    \n\n    // Output to screen\n    return  col + noiseColor *y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    \n    \n     \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAT_NIKU 0.\n#define MAT_FLOOR 1.\n#define MAT_RICE 2.\n\nconst int   OCT  = 8;         // オクターブ\nconst float PST  = 0.5;       // パーセンテージ\nconst float PI   = 3.1415926; // 円周率\n\n// めちゃくちゃ小さい数字\n#define FLT_EPS  5.960464478e-8\n\nconst float pi = 3.141592;\nconst float pi2 = pi * 2.0;\n\n\n// 補間関数\nfloat interpolate(float a, float b, float x){\n    float f = (1.0 - cos(x * PI)) * 0.5;\n    return a * (1.0 - f) + b * f;\n}\n// 乱数生成（その１）\n// float rnd(vec2 p){\n//     return fract(sin(dot(p ,vec2(12.9898,78.233))) * 43758.5453);\n// }\n// 乱数生成器（その２）\nfloat rnd(vec2 n){\n    float a = 0.129898;\n    float b = 0.78233;\n    float c = 437.585453;\n    float dt= dot(n ,vec2(a, b));\n    float sn= mod(dt, 3.14);\n    return fract(sin(sn) * c);\n}\n// 補間＋乱数\nfloat irnd(vec2 p){\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec4 v = vec4(rnd(vec2(i.x,       i.y      )),\n                  rnd(vec2(i.x + 1.0, i.y      )),\n                  rnd(vec2(i.x,       i.y + 1.0)),\n                  rnd(vec2(i.x + 1.0, i.y + 1.0)));\n    return interpolate(interpolate(v.x, v.y, f.x), interpolate(v.z, v.w, f.x), f.y);\n}\n// ノイズ\nfloat noise(vec2 p){\n    float t = 0.0;\n    for(int i = 0; i < OCT; i++){\n        float freq = pow(2.0, float(i));\n        float amp  = pow(PST, float(OCT - i));\n        t += irnd(vec2(p.x / freq, p.y / freq)) * amp;\n    }\n    return t;\n}\n// シームレスノイズ\nfloat snoise(vec2 p, vec2 q, vec2 r){\n    return noise(vec2(p.x,       p.y      )) *        q.x  *        q.y  +\n           noise(vec2(p.x,       p.y + r.y)) *        q.x  * (1.0 - q.y) +\n           noise(vec2(p.x + r.x, p.y      )) * (1.0 - q.x) *        q.y  +\n           noise(vec2(p.x + r.x, p.y + r.y)) * (1.0 - q.x) * (1.0 - q.y);\n}\n\n\n\nvec2 min2(vec2 a, vec2 b){\n    return a.x < b.x ? a : b;\n}\n\nvec3 rotate(vec3 p, float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nfloat dfCir(vec3 p, float s){\n    return length(p)-s;\n}\n\nfloat dfBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\nfloat dfEllip( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nvec2 map(vec3 p){\n    \n    vec3 r = rotate(p, radians(15.0), vec3(.0, 1., 0.0));\n    float box =  dfBox(r + vec3(0.0, -1.0, 0.0), vec3(14., 1.0, 7.), 0.8);\n    float flo = dfBox(p+vec3(0.0, 1.0, 0.0), vec3(50.0, 0.1, 50.), 0.0);\n    float ellip = dfEllip(p, vec3(3., 1., 1.)); \n    \n    vec3 q = p;\n    q.xz = mod(q.xz, 10.) - 1. * 5.;\n    float box2 = dfBox(q+vec3(0.0, 0.5, 0.0), vec3(3.), 0.2);\n    flo = max(flo, -box2);\n    \n    \n    vec2 m = min2(vec2(box, MAT_NIKU), vec2(flo, MAT_FLOOR));\n    //m = min2(m, vec2(box2, MAT_FLOOR));\n    \n    return m;\n}\n\n/*vec3 normal(vec3 p){\n    vec2 e = vec2(0.0001, 0.0);\n    vec2 d = map(p);\n    vec3 n = d.x - vec3(\n        map(p - e.xyy).x,\n        map(p - e.yxy).x,\n        map(p - e.yyx).x);\n    return normalize(n);\n}*/\n\nvec3 normal(vec3 p) {\n\tvec2 e = vec2(1.0, -1.0) * 0.001;\n    return normalize(\n        e.xyy * map(p+e.xyy).x+\n        e.yxy * map(p+e.yxy).x+\n        e.yyx * map(p+e.yyx).x+\n        e.xxx * map(p+e.xxx).x\n        );\n}\n\nvec3 BackImage(vec2 uv ){\n\n     vec3 col = vec3(0.0);\n    \n    //col = texture(iChannel0, uv).rgb;\n    //vec2 col2 = texture(iChannel0, uv).rg;\n    \n    vec3 c1 = vec3(0.9, 0.2, 0.2);\n    vec3 c2 = vec3(0.8, 0.9, 0.2);\n    float noiseStrength = 1.0;\n    \n    vec2 firstOffset = vec2(0.0, iTime * 300.0); //この300の部分がスクロールする速度の差\n    float first = snoise(gl_FragCoord.st - firstOffset, col.rg , iResolution.xy);\n    // シームレスなバリューノイズを生成する（その２） @@@\n    vec2 secondOffset = vec2(0.0, iTime * 500.0);\n    float second = snoise(gl_FragCoord.st - secondOffset, col.rg, iResolution.xy);\n    // ２つのノイズを加算して強度係数を乗算 @@@\n    vec3 noiseColor = (c1 * first + c2 * second) * noiseStrength;\n\n    // ２つのノイズを加算した結果をグラデーション風にする @@@\n    float y = 1.0 - uv.t;    \n\n    // Output to screen\n    return  col + noiseColor *y;\n}\n\nvec3 shadowImage(vec2 uv){\n    vec3 col = vec3(0.0);\n    float d = distance(vec2(0.0, 0.0), uv);\n    d = smoothstep(0.0, 3.,d );\n    col = vec3(d);\n    \n    return col;\n}\n\n\n\nvec3 nikuImage(vec2 uv){\n    \n    vec3 c1 = vec3(0.9, 0.3,0.2);\n    vec3 c2 = vec3(0.9, 0.3, 0.2) + 0.3;\n    \n    vec3 col = vec3(0.);\n    vec4 im = texture(iChannel0, uv);\n    float gray = dot(vec3(1.0), im.rgb)/3.;\n    \n    col = vec3(gray);\n    col = mix(c2, c1, gray);\n\tcol -= abs(sin(0.1*iTime));\n    \n    return col;\n}\n\n\n// 滑らか(0)から粗い(1)で表現するroughnessというパラメータを計算で使用する指数にマッピングする関数\nfloat roughnessToExponent(float roughness)\n{\n    return clamp(2.0 * (1.0 / (roughness * roughness)) - 2.0, FLT_EPS, 1.0 / FLT_EPS);\n}\n\n// サーフェイス位置・法線・視線方向・ライト位置・マテリアル情報でライティングする関数\nvec3 light(vec3 p, vec3 n, vec3 v, vec3 lp, vec3 baseColor, float roughness, float reflectance, float metallic, vec3 radiance) {\n    // 反射率をメタリックパラメータで分岐する\n    vec3 ref = mix(vec3(reflectance), baseColor, metallic);\n\n    // ライトベクトルと距離を計算する\n    vec3 l = lp - p;\n    float len = length(l);\n    l /= len;\n    \n    // ハーフベクトルを計算\n    vec3 h = normalize(l + v);\n    \n    // 正規化diffuseを評価\n    vec3 diffuse = mix(1.0 - ref, vec3(0.0), metallic) * baseColor / pi;\n    \n    // 正規化blin-phongを評価\n    float m = roughnessToExponent(roughness);\n\tvec3 specular = ref * pow( max( 0.0, dot( n, h ) ), m ) * ( m + 2.0 ) / ( 8.0 * pi );\n\t\n\t// diffuse項とspecular項を合算してポイントライトを評価\n    return (diffuse + specular) * radiance * max(0.0, dot(l, n)) / (len*len);\n}\n\n\n\nvoid SurfaceCol(vec2 uv, vec2 dist, vec3 rayPos, out vec3 color, out vec3 outEmission, out float outRoughness, out float outReflectance, out float outMetallic){\n    \n    color = vec3(0.0);\n    outEmission = vec3(0.0);\n    // 粗さパラメータを追加\n    outRoughness = 1.0;\n    // 反射率パラメータを追加\n    outReflectance = 0.04;\n    // メタリックパラメータを追加\n    outMetallic = 0.0;\n    \n    if(dist.y == MAT_NIKU){\n        \n        //color = vec3(0.9, 0.3,0.2)-1.0;\n        outEmission =vec3(0.1);\n        vec3 im = nikuImage(rayPos.xz*0.1);\n        color = im;\n        \n        \n    }else if(dist.y == MAT_FLOOR){\n        \n        color = vec3(0.6, 0.6, 0.6);\n        outReflectance = 30.;\n        outMetallic = 8.0;\n        \n    }else if(dist.y == MAT_RICE){\n        color = vec3(1.);\n    }else{\n        color =   vec3(0.0);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy)/ min(iResolution.x, iResolution.y);\n    \n    vec3 cameraPos = vec3(2.0+sin(iTime), 40.0, -10.+cos(iTime));\n    //vec3 cameraPos = vec3(2.0, 40.0, -10.);\n    vec3 targetPos = vec3(0.0, 0.0, 0.0);\n    vec3 forward = normalize(targetPos - cameraPos);\n    vec3 right   = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up      = normalize(cross(forward, right));\n    vec3 ray     = normalize(forward * 2.5 + right * uv.x + up * uv.y);\n    float screenZ = 2.5;\n    vec3 rayDir = normalize(vec3(uv, screenZ));\n    vec3 lightDir = normalize(vec3(0.0, 10., -10.));\n    \n    vec2 dist = vec2(0.0);\n    float depth = 0.0;\n    vec3 rayPos = vec3(0.0);\n\tvec3 col = vec3(0.0);\n    \n    for(int i = 0; i < 256; i++){\n      \n        rayPos = cameraPos + (depth * ray);\n        dist = map(rayPos);\n        \n        if(dist.x < 0.0001){\n            \n            vec3 color, emission;\n            float roughness, reflectance, metallic;\n            vec3 n = normal(rayPos);\n            float diff = dot(n, lightDir);\n            \n            SurfaceCol(uv,dist, rayPos, color, emission, roughness, reflectance, metallic);\n            col = color;\n            col *= 1.0 - vec3(float(i) / 99.0);\n            // 法線を推定\n            n = normal(rayPos);\n            \n            col += light(rayPos, n, -ray, cameraPos, color, roughness, reflectance, metallic, vec3(3.0));\n            // 発光色を加える\n            col += emission;\n            break;\n        }else{\n            vec3 im = BackImage(uv);\n            vec3 im2 = shadowImage(uv);\n            col =im*im2;  \n        }\n        \n        depth += dist.x;\n        \n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}