{"ver":"0.1","info":{"id":"MlByWy","date":"1509968217","viewed":79,"name":"[TD2]FlatDesignSphere","username":"Sando","description":"Design of sphere with perspective view in 3D","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","td2"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Camera Parameters\nconst vec3  cameraPos \t\t= vec3(6, 4, -5);\nconst vec3 \tcameraTarget\t= vec3(3, 1, -8);\nconst float cameraFovY\t\t= 80.0;\n\n// Sphere Parameters\nconst vec3 \tspherePos\t\t= cameraTarget + vec3(0, 1, 2);\nconst float sphereRadius\t= 1.0;\n\n\nvoid computeCameraRayFromPixel(vec2 fragCoord, out vec3 rayPos, out vec3 rayDir)\n{\n    float fragX = fragCoord.x - iResolution.x/2.0;\n    float fragY = iResolution.y/2.0 - fragCoord.y;\n    float fragZ = iResolution.y/(2.0*tan(radians(cameraFovY/2.0)));\n \n    vec3 cz = normalize(cameraTarget - cameraPos); \n    \n    vec3 tmpCy = vec3(0, -1, 0);\n    vec3 tmpCx = cross(tmpCy, cz);\n    \n    vec3 cx = normalize(tmpCx);\n    vec3 cy = cross(cz, cx);\n    \n    rayDir = normalize(fragX*cx + fragY*cy + fragZ*cz);\n    rayPos = cameraPos;\n}\n\n\nbool raySphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float sphereRadius)\n{\n    vec3 camSph = rayPos - spherePos;\n\tfloat proj = dot(camSph, rayDir);\n    return  pow(sphereRadius, 2.0) + pow(proj,2.0) - pow(length(camSph),2.0) > 0.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Compute the ray to be casteed through the pixel towards the 3D scene\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(fragCoord, rayPos, rayDir);\n    \n    //Test ray-sphere intersection\n    bool res = raySphere(rayPos, rayDir, spherePos, sphereRadius);\n    \n    fragColor = vec4((res ? 1.0 : 0.0), 0.0, 0.0, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}