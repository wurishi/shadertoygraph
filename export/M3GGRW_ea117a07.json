{"ver":"0.1","info":{"id":"M3GGRW","date":"1717519203","viewed":84,"name":"Bouncing ball and ground","username":"uk0141","description":"bouncing ball test","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","ball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ID_NONE -1.\n#define ID_BOX 1.\n#define ID_SPHERE 1.1\n#define ID_FLOOR 1.2\n#define TMIN 0.01\n#define TMAX 40.\n#define ITR 256\n#define EPS 0.0001\n#define PI acos(-1.)\n#define mouseR iMouse.x*360./iResolution.x\n\n\nmat2 rotate(float angle){\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin(float d1, float d2){\n    return min(d1, d2) - max(.8 - abs(d1-d2), 0.)*max(0.2 - abs(d1-d2), 0.)*0.3;\n}\n\n//primitives\n// sdBox\nfloat sdBox(in vec3 p, in vec3 box) {\n   vec3 d = abs(p) - box;\n   return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n// sdSphere\nfloat sdSphere(in vec3 p, in float r){\n    return length(p) - r;\n}\n\n\n// distance function hub\nvec2 intersect(vec3 p){\n    vec2 res = vec2(ID_NONE, 20.);\n    vec2 obj;\n    vec3 pos;\n    \n    float t = fract(iTime/2.);\n    pos = p - vec3(0., 20.*t*(1.-t), 0.);\n    vec2 obj_1 = vec2(ID_SPHERE, sdSphere(pos, 1.));\n    //if(obj.y < res.y)res = obj;\n    \n    \n    pos = p - vec3(0., -0.5, 0.);\n    //float f =  0.2*sin(p.x*4. - 3.*iTime) + 0.2*sin(p.z*4. - 3.*iTime);\n    float f = 0.2*sin(length(p.xz*2.) - fract(iTime/4.)*4.*PI)*exp(-2.*fract(iTime/2.))*smoothstep(0., .1, fract(iTime/2.)) ;\n    float h = p.y > vec3(p-pos).y ?f : 0.;\n    vec2 obj_2 = vec2(ID_BOX, sdBox(pos, vec3(PI, .5+h, PI)));\n    //if(obj.y < res.y)res = obj;\n    obj = vec2(ID_SPHERE, smin(obj_1.y, obj_2.y));\n    if(obj.y < res.y)res = obj;\n    \n    obj = vec2(ID_FLOOR, p.y + 1.);\n    if(obj.y < res.y)res = obj;\n    \n    return res;\n}\n\n//raymarch scene\nvec2 rayMarching(vec3 ro, vec3 rd){\n    vec2 obj = vec2(ID_NONE);\n    float t = TMIN;\n    vec3 ray;\n    int i;\n    for(i = 0;i < ITR;i++){\n        ray = ro + rd*t;\n        obj = intersect(ray);\n        if(obj.y < EPS || t > TMAX){\n            break;\n        }\n        t += .7*obj.y;\n    }\n    if(t > TMAX || i > ITR-1){\n        t = -1.;\n        obj.x = ID_NONE;\n    }\n    return vec2(obj.x, t);\n}\n\nvec3 genNormal(vec3 p){\n    vec2 e = vec2(EPS, 0.);\n    return normalize(vec3(intersect(p+e.xyy).y - intersect(p-e.xyy).y, \n                                            intersect(p+e.yxy).y - intersect(p-e.yxy).y,\n                                            intersect(p+e.yyx).y - intersect(p-e.yyx).y));\n}\n\nvec3 lighting_1(vec2 obj, vec3 pos, vec3 rd, vec3 nor){\n    vec3 destColor;\n    vec3 mate = vec3(0.18);\n    vec3 sunDir = normalize(vec3(cos(iTime/8.), 0.5, sin(iTime/8.)));\n    \n    float sunDif = clamp(dot(nor, sunDir), 0. ,1.);\n    float sunSha = step(rayMarching(pos+EPS*nor, sunDir).y, 0.);\n    float skyDif = clamp(0.3 + 0.7*dot(nor, vec3(0. , 1., 0.)), 0. ,1.);\n    float bounceDif = clamp(0.3 + 0.7*dot(nor, vec3(0., -1., 0.)), 0., 1.);\n    \n    destColor = mate*vec3(8., 5.5, 4.0)*sunDif*sunSha;\n    destColor += mate*vec3(0.5, 0.8, 0.9)*skyDif;\n    destColor += mate*vec3(1.4, 0.6, 0.4)*bounceDif;\n    return destColor;\n}\n\nvec3 floorColor(vec2 obj, vec3 pos, vec3 rd, vec3 nor){\n    vec3 destColor;\n    //vec3 mate = vec3(1.8);\n    float tile = 5.;\n    vec3 mate = mod(pos.x, tile) < tile/2. ? mod(pos.z, tile) < tile/2. ? vec3(0.01) : vec3(0.1) : mod(pos.z, tile) < tile/2. ? vec3(0.1) : vec3(0.01);\n    vec3 sunDir = normalize(vec3(cos(iTime/8.), 0.5, sin(iTime/8.)));\n    \n    float sunDif = clamp(dot(nor, sunDir), 0. ,1.);\n    float sunSha = step(rayMarching(pos+EPS*nor, sunDir).y, 0.);\n    float skyDif = clamp(0.3 + 0.7*dot(nor, vec3(0. , 1., 0.)), 0. ,1.);\n    float bounceDif = clamp(0.3 + 0.7*dot(nor, vec3(0., -1., 0.)), 0., 1.);\n    \n    vec2 refObj = rayMarching(pos+EPS*nor, normalize(reflect(rd, nor)));\n    vec3 refColor = vec3(0.);\n    if(refObj.x != ID_NONE)refColor = lighting_1(refObj, pos+(EPS+refObj.y)*nor, normalize(reflect(rd, nor)), genNormal(pos+(EPS+refObj.y)*nor) );\n    \n    destColor = mate*vec3(8., 5.5, 4.0)*sunDif*sunSha;\n    destColor += mate*vec3(0.5, 0.8, 0.9)*skyDif;\n    destColor += mate*vec3(1.4, 0.6, 0.4)*bounceDif;\n    destColor += mate*refColor*3.;\n    return destColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 p = (fragCoord*2. - iResolution.xy)/min(iResolution.x, iResolution.y);\n\n    vec3 ro = vec3(0., 2., 9.);\n    ro.xz = ro.xz*rotate(radians(iTime+mouseR));\n    vec3 rd = normalize(vec3(p, -1.));\n    rd.xz = rd.xz*rotate(radians(iTime+mouseR));\n    rd = normalize(rd);\n    vec3 col = vec3(.4, .75, 1.) - .7*rd.y;\n    col = mix(col, vec3(.7, .75, .8), exp(-10.*rd.y));\n    vec2 obj = rayMarching(ro, rd);\n    \n    vec3 pos = ro + rd*obj.y;\n    if(obj.x == ID_SPHERE)col = lighting_1(obj, pos, rd, genNormal(pos));\n    else if(obj.x == ID_BOX)col = lighting_1(obj, pos, rd, genNormal(pos));\n    else if(obj.x == ID_FLOOR)col = floorColor(obj, pos, rd, genNormal(pos));\n    \n    // Output to screen\n    col = pow(col, vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}