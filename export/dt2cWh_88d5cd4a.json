{"ver":"0.1","info":{"id":"dt2cWh","date":"1691741743","viewed":55,"name":"[zznewclear13] Identicon","username":"zznewclear13","description":"Generate identicons based on random 6x8 bytes values (HSV mode) or random 10x8 bytes values (RGB mode).","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["2d","identicon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// [zznewclear13] Identicon\n// https://www.shadertoy.com/view/dt2cWh\n// Generate identicons based on random 6x8 bytes values (HSV mode) or random 10x8 bytes values (RGB mode).\n\n// Comment this line to use RGB mode.\n#define HSV_MODE\n\n// https://www.shadertoy.com/view/MsS3Wc\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nstruct Identity\n{\n    vec3 color1;\n    vec3 color2;\n    int bitmask;\n};\n\nint makeBitmask(float f1, float f2, float f3, float f4)\n{\n    int i1 = int(f1);\n    int i2 = int(f2);\n    int i3 = int(f3);\n    int i4 = int(f4);    \n    return (i1<<24) | (i2<<16) | (i3<<8) | i4;\n}\n\nIdentity getIdentity(vec4 v1, vec4 v2, vec4 v3)\n{\n    Identity identity;\n\n#ifdef HSV_MODE\n    identity.color1 = hsv2rgb_smooth(vec3(v1.r / 255.0f, 0.3f, 0.85f));\n    identity.color2 = hsv2rgb_smooth(vec3(v1.g / 255.0f, 0.6f, 0.45f));\n    identity.bitmask = makeBitmask(v1.b, v1.a, v2.r, v2.g);\n#else\n    identity.color1 = v1.rgb / 255.0f;\n    identity.color2 = v2.rgb / 255.0f;\n    identity.bitmask = makeBitmask(v1.a, v2.a, v3.r, v3.g);\n#endif\n\n    return identity;\n}\n\nfloat getMaskFromIdentity(Identity identity, ivec2 coord)\n{\n    int index = coord.x * 8 + coord.y;\n    float bitMask = (identity.bitmask & (1<<index)) == 0 ? 0.0f : 1.0f;\n    return bitMask;\n}\n\nvec3 getColorFromIdentity(Identity identity, ivec2 coord)\n{\n    int index = coord.x * 8 + coord.y;\n    float bitMask = (identity.bitmask & (1<<index)) == 0 ? 0.0f : 1.0f;\n    return mix(identity.color1, identity.color2, bitMask);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 v1 = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 v2 = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec4 v3 = texelFetch(iChannel0, ivec2(2, 0), 0);\n    Identity identity = getIdentity(v1, v2, v3);\n    \n    vec2 foreCoord = 8.0f * (fragCoord - iResolution.xy * 0.5f) / iResolution.y * 1.2f + 4.0f;\n    foreCoord.x = 3.5f - abs(floor(foreCoord.x) - 3.5f);\n    \n    if(foreCoord.x < 0.0f || foreCoord.y > 8.0f || foreCoord.y < 0.0f)\n    {\n        vec2 backCoord = 8.0f * (fragCoord - iResolution.xy * 0.5f) / iResolution.x + 4.0f;\n        backCoord.x = 4.0f - abs(backCoord.x - 4.0f);\n        ivec2 iBackCoord = ivec2(backCoord);\n \n        vec2 offset = fract(backCoord) - 0.5f;\n        ivec2 dir = ivec2(sign(offset));\n        float cMask = getMaskFromIdentity(identity, clamp(iBackCoord, ivec2(0, 0), ivec2(3, 7)));\n        float tMask = getMaskFromIdentity(identity, clamp(iBackCoord + ivec2(0, dir.y), ivec2(0, 0), ivec2(3, 7)));\n        float rMask = getMaskFromIdentity(identity, clamp(iBackCoord + ivec2(dir.x, 0), ivec2(0, 0), ivec2(3, 7)));\n        float trMask = getMaskFromIdentity(identity, clamp(iBackCoord + dir, ivec2(0, 0), ivec2(3, 7)));\n        \n        float r = 0.2f;\n        offset = abs(offset);\n        float cWeight = smoothstep(r, -r, sdRoundedBox(offset, vec2(0.5f), vec4(r)));\n        float tWeight = smoothstep(r, -r, sdRoundedBox(vec2(offset.x, 1.0f - offset.y), vec2(0.5f), vec4(r)));\n        float rWeight = smoothstep(r, -r, sdRoundedBox(vec2(1.0f - offset.x, offset.y), vec2(0.5f), vec4(r)));\n        float trWeight = smoothstep(r, -r, sdRoundedBox(1.0f - offset, vec2(0.5f), vec4(r)));\n        float totalWeight = cWeight * cMask + tWeight * tMask + rWeight * rMask + trWeight * trMask;\n        totalWeight = clamp(totalWeight, 0.0f, 1.0f);\n        \n        vec3 backColor = mix(identity.color1, identity.color2, vec3(totalWeight));\n        fragColor = vec4(backColor * 0.3f, 1.0f);\n    }\n    else\n    {\n        ivec2 iForeCoord = ivec2(foreCoord);\n        vec3 foreColor = getColorFromIdentity(identity, iForeCoord);\n        fragColor = vec4(foreColor, 1.0f);\n    }\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.4545f));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Generates 32 bit random numbers.\n// [RGBA]: 0.0-255.0\n\n// https://www.shadertoy.com/view/4djSRW\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n    ivec2 iFragCoord = ivec2(fragCoord);\n    if(iFragCoord.y == 0 && iFragCoord.x <= 2)\n    {\n        vec4 randomVal = hash43(vec3(fragCoord, floor(iDate.w * 0.3f)));\n        randomVal = floor(randomVal * 255.99f);\n        fragColor = randomVal;\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}