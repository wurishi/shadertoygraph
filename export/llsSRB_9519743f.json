{"ver":"0.1","info":{"id":"llsSRB","date":"1437709842","viewed":248,"name":"Soccer Ball (ray traced)","username":"rubixcom","description":"Raytraced soccer ball, in very bad need of better shading, bug fixing and optimization.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","ball","soccer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define NO_INTERSECTION 10000000.\n#define PI 3.14159265359\n#define TWO_PI (2.*PI)\n//#define TRANSPARENT\n//#define DOTS\n#define BALL_TEXTURE\n\nvec3 rayVector(in vec3 position, in vec3 target, in vec2 fragCoord)\n{\n    vec3 eye = normalize(target - position);\n    vec3 up = vec3(0., 1., 0.);\n    vec3 right = cross(eye, up);\n    up = cross(eye,right);\n\n    mat3 cameraMatrix = mat3(right.x, up.x, eye.x,\n                \t\t\t right.y, up.y, eye.y,\n                \t\t\t right.z, up.z, eye.z);\n\n    vec2 uv = fragCoord.xy / iResolution.xy - vec2(.5);\n    uv.x = uv.x * iResolution.x/iResolution.y;\n    float focalDistance =4.0;\n    return normalize(vec3(uv.x,uv.y,focalDistance)) * cameraMatrix;\n}\n\n// Calculates the intersection between a vector (o = origin, I = direction) and a sphere (c = origin, r = radius) and returns distance along vector I. Returns NO_INTERSECTION if there isn't one.\nfloat lineSphereIntersection(in vec3 o, in vec3 I, in vec3 c, float r, float inner)\n{\n\tfloat det = pow(dot(I,o-c),2.) - pow(length(o-c),2.) + pow(r,2.);\n\n\tif (det <= 0.0)\n\t\treturn NO_INTERSECTION;\n\telse\n\t{\n\t\tfloat d = -dot(I, o-c) + inner * sqrt(det);\n\t\tif (d < 0.0)\n\t\t\treturn NO_INTERSECTION;\n\t\treturn d;\n\t}\n}\n\nvoid minCheck(in vec3 uv, in vec3 v, in vec4 ct, in float fact, in float maxR, in float od, out float d, in vec4 oc, out vec4 c, in vec3 ov, out vec3 vv, in vec3 opv, out vec3 pv, out float dep)\n{\n    float l = //length(v - uv);\n        acos(dot(normalize(v),normalize(uv))) * fact;\n\tvv = ov;\n    pv = opv;\n    if (od - l > 0.0)\n    {\n\t\tdep = abs(od - l);\n\n        if ((l/fact) > maxR * 1.1)\n        {\n            c = vec4(0.0,1.0,0.0,0.0);\n        }\n        else if ((l/fact) > maxR)\n        {\n            c = vec4(0.0,.5,0.0,0.0);\n        }\n        else if (dep < .01)\n        {\n            c = vec4(0.0,0.0,0.0,0.0);\n        }\n#ifdef DOTS\n        else if (l < 0.06)\n        {\n            c = vec4(cos(l*30.),0.0,0.0,0.0) + ct;\n        }\n#endif\n        else\n\t        c = ct;\n        dep = 50. * clamp(dep,0.,0.02);\n        d = l;\n        pv = ov;\n\t\tvv = normalize(uv-v);\n    }\n}\n\nvec4 soccerColor(in vec3 uv, in bool pentaOnly, in bool hexaOnly, in float maxR, out float dep, out float d, out float angl)\n{\n\td = 10000000.0;\n    vec4 c = vec4(1.0);\n\n    vec4 pentaColor = vec4(.6,.3,0.,0.);\n    vec4 hexaColor = vec4(1.0,.6,0.,0.);\n    vec3 v= vec3(0.);\n    vec3 pv= vec3(0.);\n    float pentaFact = 1.333;\n    float hexaFact = 1.0;\n\n\n    float t = (1.0 + sqrt(5.0)) / 2.0;\n    if (!hexaOnly)\n    {\n        minCheck(uv, vec3(-1.,t,0.), pentaColor, pentaFact, maxR, d, d, c, c, v,v, pv,pv, dep);\n        minCheck(uv, vec3(1.,t,0.), pentaColor, pentaFact, maxR, d, d, c, c, v,v, pv,pv, dep);\n        minCheck(uv, vec3(-1.,-t,0.), pentaColor, pentaFact, maxR, d, d, c, c, v,v, pv,pv, dep);\n        minCheck(uv, vec3(1.,-t,0.), pentaColor, pentaFact, maxR, d, d, c, c, v,v, pv,pv, dep);\n\n        minCheck(uv, vec3(0.,-1.,t), pentaColor, pentaFact, maxR, d, d, c, c, v,v, pv,pv, dep);\n        minCheck(uv, vec3(0.,1.,t), pentaColor, pentaFact, maxR, d, d, c, c, v,v, pv,pv, dep);\n        minCheck(uv, vec3(0.,-1.,-t), pentaColor, pentaFact, maxR, d, d, c, c, v,v, pv,pv, dep);\n        minCheck(uv, vec3(0.,1.,-t), pentaColor, pentaFact, maxR, d, d, c, c, v,v, pv,pv, dep);\n\n        minCheck(uv, vec3(t,0.,-1.), pentaColor, pentaFact, maxR, d, d, c, c, v,v, pv,pv, dep);\n        minCheck(uv, vec3(t,0.,1.), pentaColor, pentaFact, maxR, d, d, c, c, v,v, pv,pv, dep);\n        minCheck(uv, vec3(-t,0.,-1.), pentaColor, pentaFact, maxR, d, d, c, c, v,v, pv,pv, dep);\n        minCheck(uv, vec3(-t,0.,1.), pentaColor, pentaFact, maxR, d, d, c, c, v,v, pv,pv, dep);\n    }\n\n    if (!pentaOnly)\n    {\n        minCheck(uv, (vec3(-1.,t,0.)+vec3(0.,1.,t)+vec3(-t,0.,1.))/3., hexaColor, hexaFact, maxR, d, d, c, c, v,v, pv,pv, dep);\n        minCheck(uv, (vec3(1.,t,0.)+vec3(0.,1.,t)+vec3(-1.,t,0.))/3., hexaColor, hexaFact, maxR, d, d, c, c, v,v, pv,pv, dep);\n        minCheck(uv, (vec3(0.,1.,t)+vec3(0.,-1.,t)+vec3(-t,0.,1.))/3., hexaColor, hexaFact, maxR, d, d, c, c, v,v, pv,pv, dep);\n        minCheck(uv, (vec3(-t,0.,1.)+vec3(-t,0.,-1.)+vec3(-1.,t,0.))/3., hexaColor, hexaFact, maxR, d, d, c, c, v,v, pv,pv, dep);\n\n        minCheck(uv, (vec3(1.,-t,0.)+vec3(0.,-1.,-t)+vec3(t,0.,-1.))/3., hexaColor, hexaFact, maxR, d, d, c, c, v,v, pv,pv, dep);\n        minCheck(uv, (vec3(0.,-1.,-t)+vec3(0.,1.,-t)+vec3(t,0.,-1.))/3., hexaColor, hexaFact, maxR, d, d, c, c, v,v, pv,pv, dep);\n        minCheck(uv, (vec3(t,0.,-1.)+vec3(t,0.,1.)+vec3(1.,-t,0.))/3., hexaColor, hexaFact, maxR, d, d, c, c, v,v, pv,pv, dep);\n        minCheck(uv, (vec3(-1.,-t,0.)+vec3(1.,-t,0.)+vec3(0.,-1.,-t))/3., hexaColor, hexaFact, maxR, d, d, c, c, v,v, pv,pv, dep);\n\n        minCheck(uv, (vec3(-1.,t,0.)+vec3(1.,t,0.)+vec3(0.,1.,-t))/3., hexaColor, hexaFact, maxR, d, d, c, c, v,v, pv,pv, dep);\n        minCheck(uv, (vec3(1.,t,0.)+vec3(t,0.,1.)+vec3(0.,1.,t))/3., hexaColor, hexaFact, maxR, d, d, c, c, v,v, pv,pv, dep);\n        minCheck(uv, (vec3(0.,1.,t)+vec3(t,0.,1.)+vec3(0.,-1.,t))/3., hexaColor, hexaFact, maxR, d, d, c, c, v,v, pv,pv, dep);\n        minCheck(uv, (vec3(-t,0.,1.)+vec3(0.,-1.,t)+vec3(-1.,-t,0.))/3., hexaColor, hexaFact, maxR, d, d, c, c, v,v, pv,pv, dep);\n        minCheck(uv, (vec3(-t,0.,-1.)+vec3(-t,0.,1.)+vec3(-1.,-t,0.))/3., hexaColor, hexaFact, maxR, d, d, c, c, v,v, pv,pv, dep);\n        minCheck(uv, (vec3(0.,1.,-t)+vec3(-1.,t,0.)+vec3(-t,0.,-1.))/3., hexaColor, hexaFact, maxR, d, d, c, c, v,v, pv,pv, dep);\n\n        minCheck(uv, (vec3(0.,1.,-t)+vec3(t,0.,-1.)+vec3(1.,t,0.))/3., hexaColor, hexaFact, maxR, d, d, c, c, v,v, pv,pv, dep);\n        minCheck(uv, (vec3(1.,t,0.)+vec3(t,0.,1.)+vec3(t,0.,-1.))/3., hexaColor, hexaFact, maxR, d, d, c, c, v,v, pv,pv, dep);\n        minCheck(uv, (vec3(t,0.,1.)+vec3(1.,-t,0.)+vec3(0.,-1.,t))/3., hexaColor, hexaFact, maxR, d, d, c, c, v,v, pv,pv, dep);\n        minCheck(uv, (vec3(1.,-t,0.)+vec3(0.,-1.,t)+vec3(-1.,-t,0.))/3., hexaColor, hexaFact, maxR, d, d, c, c, v,v, pv,pv, dep);\n        minCheck(uv, (vec3(-1.,-t,0.)+vec3(-t,0.,-1.)+vec3(0.,-1.,-t))/3., hexaColor, hexaFact, maxR, d, d, c, c, v,v, pv,pv, dep);\n        minCheck(uv, (vec3(-t,0.,-1.)+vec3(0.,-1.,-t)+vec3(0.,1.,-t))/3., hexaColor, hexaFact, maxR, d, d, c, c, v,v, pv,pv, dep);\n    }\n\n\n    angl = asin(dot(v,pv));\n    return c;\n}\n\nvoid soccer(in vec3 o, in vec3 cc, in vec3 l, in vec2 fragCoord, in float rot, out vec4 c)\n{\n\n    vec3 v = rayVector(o, cc, fragCoord);\n    float i = lineSphereIntersection(o, v, cc, .3, -1.);\n\n    if (i == NO_INTERSECTION)\n    {\n\t\t//c = vec4(0.0,.9,.3,0.) * 5.* dot(v,vec3(0.,1.0,0.));\n        c = texture(iChannel0, -1.*v);\n        return;\n    }\n    \n    mat3 mr = mat3(cos(rot), sin(rot),0.,-sin(rot),cos(rot),0.,0.,0.,1.);\n\n\n    vec3 p = i * v  + o;\n    vec3 uv = normalize(p - cc);\n    float dep = 0.;\n\n\tfloat d = 10000000.0;\n\tfloat angl = 0.;\n    c = soccerColor(mr*uv, false, false, 100., dep, d, angl);\n\n    float depu = 0.;\n    float ang = 0.01;\n    mat3 mx = mat3(cos(ang), sin(ang),0.,-sin(ang),cos(ang),0.,0.,0.,1.);\n    soccerColor(mx * mr*uv, false, false, 100., depu, d, angl);\n\n    float depv = 0.;\n    mat3 my = mat3(1.,0.,0.,0.,cos(ang), sin(ang),0.,-sin(ang),cos(ang));\n    soccerColor(my * mr*uv, false, false, 100., depv, d, angl);\n\n    vec3 nx = normalize(vec3(0.,dep,0.) - vec3(.01,depu,0.));\n    vec3 ny = normalize(vec3(0.,dep,0.) - vec3(.0,depv,.01));\n    vec3 bump = -cross(nx,ny);\n\n    vec3 normal = normalize(uv + bump\n#ifdef BALL_TEXTURE\n                            //+ texture(iChannel0, vec2(angl*10.,d*10.)).xyz\n                            + 0.50*abs(vec3(sin(angl*120.)*cos(d*200.),0.,sin(angl*120.)*cos(d*200.)))\n#endif\n                           );\n\n    c += soccerColor(mr*uv, true, false, .5, dep, d, angl);\n    //c += soccerColor(uv, true, false, .55, dep, d, angl);\n\n   c *= dot(normal,normalize(l-p));\n\n    //c = soccerColor(uv, false, false, .25, dep, d, angl);\n\n\n#ifdef TRANSPARENT\n    i = lineSphereIntersection(o, v, cc, .3, 1.);\n    p = i * v  + o;\n    uv = normalize(p - cc);\n\n    c += soccerColor(mr*uv, false, false, 1.0, depv, d, angl)  * .5 * dot(uv,v);\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//vec2 uv = fragCoord.xy / iResolution.xy - .5;\n    //uv.y *= iResolution.y / iResolution.x;\n\n    vec3 o  = vec3(sin(iTime)*.0+1.,-0.5+0.5*sin(.2*iTime),cos(iTime)*0.+1.);\n    vec3 l  = 3.*o;\n    vec3 cc = vec3(0.+10.*sin(.1*iTime),2.*-abs(sin(iTime*1.))+2.,0.);\n\tvec4 c = vec4(0.);\n\n\tsoccer(o, cc, l, fragCoord, 30.*sin(.1*iTime), c);\n\n\tfragColor += c;\n}\n","name":"","description":"","type":"image"}]}