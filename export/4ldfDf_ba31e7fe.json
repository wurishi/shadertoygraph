{"ver":"0.1","info":{"id":"4ldfDf","date":"1546313453","viewed":216,"name":"Volumetric Gas Giant","username":"WB","description":"Procedural volumetric gas giant made using gradient noise. Move mouse left/right to change color and up/down to change temperature.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raymarching","planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 32\n#define MIN_DIST 0.002\n#define NOISE_SIMPLEX_1_DIV_289 0.00346020761245674740484429065744\n#define _FoV 45.0\n#define _Deg2Rad 0.01745329\n#define ROTATE\n\nconst vec3 _Center = vec3(0.0,0.0,0.0);\nconst vec3 _LightCol = vec3(1.0,1.0,1.0);\nconst vec3 _LightPos = vec3(-10.0,0.0,-10.0);\n\n//const vec3 _Color = vec3(0.1, 0.1, 0.8);\n//const vec3 _Emissive = vec3(0.0, 0.0, 0.0);\nconst vec3 _UpperCloudColor = vec3(0.8,0.8, 0.8);\nconst float _FresnelPow = 23.5;\nconst float _FresnelBias = 0.0;\n\nconst float _WindSpeed1 = -0.5;\nconst float _WindSpeed2 = 1.0;\nconst float _BandScale = 0.4;\nconst float _UpperCloudStrength = 0.2;\nconst float _UpperCloudExponent = 2.0;\nconst float _Radius = 1.0;\nconst float _Oblateness = 1.06;\nconst float _TimeScale = 0.02;\nconst float _StormSpeed = 0.1;\nconst float  _StormSize = 0.34;\nconst float _StormDepth = 0.98;\nconst float _CycloneStability = -0.31;\n\n//Signed distance function for a sphere\nfloat sdSphere(vec3 position)\n{\n    position.y *= _Oblateness;\n    float d = length(_Center - position) - _Radius;\n    return d;\n}\n\n//Raymarching loop\nvec3 raymarch(vec3 position, vec3 direction)\n{\n    float dist;\n    vec3 center = _Center;\n\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        dist = sdSphere(position);\n        if (dist < MIN_DIST)\n        {\n            return position;\n        }\n\n        position += direction * dist;\n    }\n\n    return vec3(0.0, 0.0, 0.0);\n}\n\n//Correct geodetic normal for a non-spherical ellipsoids\nvec3 geodeticNormal(vec3 p)\n{\n    vec3 axes = vec3(1.0, _Oblateness*_Oblateness, 1.0);\n    vec3 R = p - _Center;\n    return normalize(R/axes);\n}\n\n//Y-axis rotation matrix\nvec3 rotateY(vec3 p, float s)\n{\n    float cosTheta = cos(iTime * s);\n    float sinTheta = sin(iTime * s);\n    mat3 rot = mat3(cosTheta, 0.0, sinTheta,\n        \t\t\t0.0, 1.0, 0.0,\n    \t\t\t    -sinTheta, 0.0, cosTheta);\n    \n    return rot * p;\n}\n\n//-------------------------------------------------------------------\n// Description : Array and textureless GLSL 4D simplex\n//               noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//-------------------------------------------------------------------\n\nfloat mod289(float x) {\n\treturn x - floor(x * NOISE_SIMPLEX_1_DIV_289) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n\treturn x - floor(x * NOISE_SIMPLEX_1_DIV_289) * 289.0;\n}\n\nvec3 mod289(vec3 x) {\n\treturn x - floor(x * NOISE_SIMPLEX_1_DIV_289) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n\treturn x - floor(x * NOISE_SIMPLEX_1_DIV_289) * 289.0;\n}\n\nfloat permute(float x) {\n\treturn mod289(\n\t\tx*x*34.0 + x\n\t);\n}\n\nvec3 permute(vec3 x) {\n\treturn mod289(\n\t\tx*x*34.0 + x\n\t);\n}\n\nvec4 permute(vec4 x) {\n\treturn mod289(\n\t\tx*x*34.0 + x\n\t);\n}\n\nfloat taylorInvSqrt(float r) {\n\treturn 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n\treturn 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip)\n{\n\tconst vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n\tvec4 p, s;\n\tp.xyz = floor( fract(j * ip.xyz) * 7.0) * ip.z - 1.0;\n\tp.w = 1.5 - dot( abs(p.xyz), ones.xyz );\n\t\n\t// GLSL: lessThan(x, y) = x < y\n\t// HLSL: 1 - step(y, x) = x < y\n\ts = vec4(\n\t\t1.0 - step(0.0, p)\n\t);\n\tp.xyz = p.xyz + (s.xyz * 2.0 - 1.0) * s.www; \n\t\n\treturn p;\n}\n\n//3D\nfloat snoise(vec3 v)\n{\n\tconst vec2 C = vec2(\n\t\t0.166666666666666667, // 1/6\n\t\t0.333333333333333333  // 1/3\n\t);\n\tconst vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\t\n// First corner\n\tvec3 i = floor( v + dot(v, C.yyy) );\n\tvec3 x0 = v - i + dot(i, C.xxx);\n\t\n// Other corners\n\tvec3 g = step(x0.yzx, x0.xyz);\n\tvec3 l = 1.0 - g;\n\tvec3 i1 = min(g.xyz, l.zxy);\n\tvec3 i2 = max(g.xyz, l.zxy);\n\t\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\tvec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\t\n// Permutations\n\ti = mod289(i);\n\tvec4 p = permute(\n\t\tpermute(\n\t\t\tpermute(\n\t\t\t\t\ti.z + vec4(0.0, i1.z, i2.z, 1.0 )\n\t\t\t) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )\n\t\t) \t+ i.x + vec4(0.0, i1.x, i2.x, 1.0 )\n\t);\n\t\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n\tfloat n_ = 0.142857142857; // 1/7\n\tvec3 ns = n_ * D.wyz - D.xzx;\n\t\n\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p,7*7)\n\t\n\tvec4 x_ = floor(j * ns.z);\n\tvec4 y_ = floor(j - 7.0 * x_ ); // mod(j,N)\n\t\n\tvec4 x = x_ *ns.x + ns.yyyy;\n\tvec4 y = y_ *ns.x + ns.yyyy;\n\tvec4 h = 1.0 - abs(x) - abs(y);\n\t\n\tvec4 b0 = vec4( x.xy, y.xy );\n\tvec4 b1 = vec4( x.zw, y.zw );\n\t\n\t//vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n\t//vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n\tvec4 s0 = floor(b0)*2.0 + 1.0;\n\tvec4 s1 = floor(b1)*2.0 + 1.0;\n\tvec4 sh = -step(h, vec4(0.0));\n\t\n\tvec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n\tvec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\t\n\tvec3 p0 = vec3(a0.xy,h.x);\n\tvec3 p1 = vec3(a0.zw,h.y);\n\tvec3 p2 = vec3(a1.xy,h.z);\n\tvec3 p3 = vec3(a1.zw,h.w);\n\t\n//Normalise gradients\n\tvec4 norm = taylorInvSqrt(vec4(\n\t\tdot(p0, p0),\n\t\tdot(p1, p1),\n\t\tdot(p2, p2),\n\t\tdot(p3, p3)\n\t));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\t\n// Mix final noise value\n\tvec4 m = max(\n\t\t0.6 - vec4(\n\t\t\tdot(x0, x0),\n\t\t\tdot(x1, x1),\n\t\t\tdot(x2, x2),\n\t\t\tdot(x3, x3)\n\t\t),\n\t\t0.0\n\t);\n\tm = m * m;\n\treturn 42.0 * dot(\n\t\tm*m,\n\t\tvec4(\n\t\t\tdot(p0, x0),\n\t\t\tdot(p1, x1),\n\t\t\tdot(p2, x2),\n\t\t\tdot(p3, x3)\n\t\t)\n\t);\n}\n\n//4D\nfloat snoise(vec4 v)\n{\n\tconst vec4 C = vec4(\n\t\t0.138196601125011, // (5 - sqrt(5))/20 G4\n\t\t0.276393202250021, // 2 * G4\n\t\t0.414589803375032, // 3 * G4\n\t -0.447213595499958  // -1 + 4 * G4\n\t);\n\n// First corner\n\tvec4 i = floor(\n\t\tv +\n\t\tdot(\n\t\t\tv,\n\t\t\tvec4(0.309016994374947451) // (sqrt(5) - 1) / 4\n\t\t)\n\t);\n\tvec4 x0 = v - i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n\tvec4 i0;\n\tvec3 isX = step( x0.yzw, x0.xxx );\n\tvec3 isYZ = step( x0.zww, x0.yyz );\n\ti0.x = isX.x + isX.y + isX.z;\n\ti0.yzw = 1.0 - isX;\n\ti0.y += isYZ.x + isYZ.y;\n\ti0.zw += 1.0 - isYZ.xy;\n\ti0.z += isYZ.z;\n\ti0.w += 1.0 - isYZ.z;\n\n\t// i0 now contains the unique values 0,1,2,3 in each channel\n\tvec4 i3 = clamp(i0, 0.0, 1.0);\n\tvec4 i2 = clamp(i0-1.0, 0.0, 1.0);\n\tvec4 i1 = clamp(i0-2.0, 0.0, 1.0);\n\n\t//\tx0 = x0 - 0.0 + 0.0 * C.xxxx\n\t//\tx1 = x0 - i1  + 1.0 * C.xxxx\n\t//\tx2 = x0 - i2  + 2.0 * C.xxxx\n\t//\tx3 = x0 - i3  + 3.0 * C.xxxx\n\t//\tx4 = x0 - 1.0 + 4.0 * C.xxxx\n\tvec4 x1 = x0 - i1 + C.xxxx;\n\tvec4 x2 = x0 - i2 + C.yyyy;\n\tvec4 x3 = x0 - i3 + C.zzzz;\n\tvec4 x4 = x0 + C.wwww;\n\n// Permutations\n\ti = mod289(i); \n\tfloat j0 = permute(\n\t\tpermute(\n\t\t\tpermute(\n\t\t\t\tpermute(i.w) + i.z\n\t\t\t) + i.y\n\t\t) + i.x\n\t);\n\tvec4 j1 = permute(\n\t\tpermute(\n\t\t\tpermute(\n\t\t\t\tpermute (\n\t\t\t\t\ti.w + vec4(i1.w, i2.w, i3.w, 1.0 )\n\t\t\t\t) + i.z + vec4(i1.z, i2.z, i3.z, 1.0 )\n\t\t\t) + i.y + vec4(i1.y, i2.y, i3.y, 1.0 )\n\t\t) + i.x + vec4(i1.x, i2.x, i3.x, 1.0 )\n\t);\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n\tconst vec4 ip = vec4(\n\t\t0.003401360544217687075, // 1/294\n\t\t0.020408163265306122449, // 1/49\n\t\t0.142857142857142857143, // 1/7\n\t\t0.0\n\t);\n\n\tvec4 p0 = grad4(j0, ip);\n\tvec4 p1 = grad4(j1.x, ip);\n\tvec4 p2 = grad4(j1.y, ip);\n\tvec4 p3 = grad4(j1.z, ip);\n\tvec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n\tvec4 norm = taylorInvSqrt(vec4(\n\t\tdot(p0, p0),\n\t\tdot(p1, p1),\n\t\tdot(p2, p2),\n\t\tdot(p3, p3)\n\t));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\tp4 *= taylorInvSqrt( dot(p4, p4) );\n\n// Mix contributions from the five corners\n\tvec3 m0 = max(\n\t\t0.6 - vec3(\n\t\t\tdot(x0, x0),\n\t\t\tdot(x1, x1),\n\t\t\tdot(x2, x2)\n\t\t),\n\t\t0.0\n\t);\n\tvec2 m1 = max(\n\t\t0.6 - vec2(\n\t\t\tdot(x3, x3),\n\t\t\tdot(x4, x4)\n\t\t),\n\t\t0.0\n\t);\n\tm0 = m0 * m0;\n\tm1 = m1 * m1;\n\t\n\treturn 49.0 * (\n\t\tdot(\n\t\t\tm0*m0,\n\t\t\tvec3(\n\t\t\t\tdot(p0, x0),\n\t\t\t\tdot(p1, x1),\n\t\t\t\tdot(p2, x2)\n\t\t\t)\n\t\t) + dot(\n\t\t\tm1*m1,\n\t\t\tvec2(\n\t\t\t\tdot(p3, x3),\n\t\t\t\tdot(p4, x4)\n\t\t\t)\n\t\t)\n\t);\n}\n\nfloat ridgedNoise(vec4 position, float frequency, float amplitude)\n{\n    return((1.0 - abs(snoise(position * frequency))) * 2.0 - 1.0) * amplitude;\n}\n\nvec4 renderSurface(vec3 normal, vec3 sp, vec3 camPos, float h)\n{\n    //Mouse inputs\n    float lerp = clamp(iMouse.x/iResolution.x, 0.0, 1.0);\n    float temp = clamp(-0.5 + iMouse.y/iResolution.y, 0.0, 0.15);\n    vec3 _Color = mix(vec3(0.1,0.1,0.8), vec3(0.8,0.5,0.3), lerp);\n    vec3 _Emissive = vec3(temp, 0.0, 0.0);\n    \n    float dist = length(_Center - camPos);\n\n    vec4 seed;\n    float fade = min(0.5, max(1.0 - dist / 24.0, 0.0));\n\n    vec3 worldNormal = normal;\n\n    //Surface Distortion\n    //Calculate uv offsets\n    seed.xyz = worldNormal;\n    seed.x += _WindSpeed1 * iTime * _TimeScale;\n    seed.w = iTime * _TimeScale * 0.000001;\n    float n1 = ridgedNoise(seed, 12.0, 1.0);\n    float n2 = snoise(seed * 24.0) + n1;\n    float n3 = snoise(seed * 64.0) + n2;\n    float n4 = min(0.25,ridgedNoise(seed, 16.0, n3) - n3);\n    float offset = mix(n1 + n2, n4, fade);\n\n    //Calculate second layer of noise to simulate contra-rotation of cloud bands/zones\n    seed *= -0.5;\n    seed.x += _WindSpeed2 * iTime * _TimeScale;\n    seed.w *= 10000.0;\n    float n12 = ridgedNoise(seed, 12.0, 1.0);\n    float n22 = snoise(seed * 24.0);\n    float n32 = snoise(seed * 64.0);\n    float n42 = ridgedNoise(seed, 32.0, n32);\n    offset += mix(n12 + n22, n42, fade) * 0.9;\n\n    //Modulate noise bands by cos of lattitude\n    float factor = cos(h * 4.0) * 0.7;\n    offset *= 1.0 - factor;\n\n    //Calculate Cyclone Locations\n    float s = _StormSize;\n    vec3 n = vec3(worldNormal.x, worldNormal.y * 1.5, worldNormal.z);\n    n.x += iTime * _TimeScale * _StormSpeed;\n    float t1 = snoise(n * 2.0) - s;\n    float t2 = snoise((n + 400.0) * 2.0) - s;\n    float t3 = snoise((n + 800.0) * 2.0) - s;\n    float threshold = max(t1 * t2 * t3, 0.0) * _StormDepth;\n\n    //Cyclone offsets\n    seed.xyz = worldNormal;\n    float cycloneOffset = (snoise(seed.xyz * threshold * 0.2 + t1 + (iTime * _TimeScale * 0.2)) + snoise(seed.xyz * 0.2 + t2) + n2*_CycloneStability + snoise(seed.xyz * 0.001) + snoise(seed * 0.0001) * t3) * threshold * threshold * 175.0;\n    cycloneOffset *= sin(abs(h)/_Radius);\n    offset += cycloneOffset;\n\n    //Calculate lookup coordinate\n    float u =  h * _BandScale + offset/150.0;\n\n    //Lighting Model\n\n    //Sample texture\n    vec3 texCol = texture(iChannel0, vec2(u,0.0)).r * _Color;\n    \n    worldNormal = rotateY(worldNormal, -0.02 * _TimeScale);\n\n    //Upper Cloud Layer\n    float cloudScale = 10.0;\n    vec3 skewedSeed = vec3(worldNormal.x, worldNormal.y * 8.0 + iTime * _TimeScale * _WindSpeed1, worldNormal.z);\n    float uCloud = clamp(max(snoise(normal*2.0) + snoise(skewedSeed * cloudScale) + snoise(skewedSeed * 8.0) + snoise(skewedSeed*32.0) + n4, 0.0) * _UpperCloudStrength, 0.0, 1.0);\n    texCol.rgb = mix(texCol.rgb, _UpperCloudColor, pow(uCloud, _UpperCloudExponent));\n\n    //seed *= 8;\n    //seed.y *= 2;\n    //float spots = pow(abs(snoise(seed)), 4);\n    //texCol.rgb = lerp(texCol.rgb, _UpperCloudColor, saturate(spots));\n\n    //Calculate screen space normal from partial derivatives of color values\n    float value = dot(texCol.rgb, texCol.rgb);\n    float snx = dFdx(value);\n    float sny = dFdy(value);\n    float snz = sqrt(1.0 - snx * snx - sny * sny);\n    vec3 ssn = -vec3(snx, sny, snz);\n\n    vec3 N = mix(ssn, normal, clamp(dist/(2.5*_Radius), 0.5, 1.0));\n    //float3 N = normalize(ssn + normal*((dist)/(_Radius)));\n\n    //Calculate lambertian reflection\n    //float NdotL = max(dot(N, lightDir), 0);\n    vec3 _LightDir = -normalize(sp - _LightPos);\n    float NdotL = clamp(dot(N, _LightDir), 0.0, 1.0);\n\n    vec4 col;\n    col.rgb = texCol * _LightCol * NdotL + _Emissive;\n\n    //float w = 0.1;\n    //float3 wrappedDiffuse = lightCol * saturate((NdotL + w) / ((1 + w) * (1 + w)));\n\n    //Fresnel-based atmosphere effect. Not physically accurate but looks good from most distances and relatively cheap.\n    float fresnel = max(0.0, min(1.0, _FresnelBias + ((40.0) * pow(1.0 + dot(normalize(sp - camPos), normal), _FresnelPow))));\n    col.r *= 1. - fresnel * 1.44;\n    col.g *= 1. - fresnel * 0.9;\n    col.b *= 1. - fresnel * 0.7;\n    col.rgb += (fresnel + _Emissive) * NdotL;\n    col.rgb += _Emissive * fresnel;\n    col.a = max(0.0,1.0 - fresnel);\n\n    //if (col.a <= 0.0)\n    //{\n    //    col.rgb = vec3(0.0);\n    //}\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, -5.0);\n        \n    //Compute eye vector from field of view\n    float ar = iResolution.x/iResolution.y;\n    float d = ar/tan((_FoV/2.0) * _Deg2Rad);    \n    vec3 rayDir = normalize(vec3((-1.0 + 2.0 * uv) * vec2(ar, 1.0), d));\n    \n    #ifdef ROTATE\n    rayOrigin = rotateY(rayOrigin, 0.1);\n    rayDir = rotateY(rayDir, 0.1);\n    #endif\n        \n\tvec3 sp = raymarch(rayOrigin, rayDir);\n    \n    vec3 col;\n    \n    if (sp != vec3(0.0))\n    {\n        //fragColor = vec4(0.0,0.0,0.0,1.0);\n        vec3 normal = geodeticNormal(sp);\n    \n        vec4 color = renderSurface(normal, sp, rayOrigin, sp.y);\n\t\t\t\n        col.rgb = color.rgb * color.a * color.a;\n    }\n    else\n    {\n        col.rgb += smoothstep(0.85, 0.95, abs(snoise(rotateY(rayDir, 0.1) * 128.0)));\n    }\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}