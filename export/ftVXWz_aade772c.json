{"ver":"0.1","info":{"id":"ftVXWz","date":"1640509967","viewed":274,"name":"2D VOXEL DODECA","username":"ENDESGA","description":"///////","likes":9,"published":3,"flags":0,"usePreview":0,"tags":["2d","voxels","sdf"],"hasliked":0,"parentid":"4slXW7","parentname":"2D Voxels"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//2D Voxels by nimitz (stormoid.com) (twitter: @stormoid)\n\n//try the other maps\n#define MAP 3\n#define NUM_LAYERS 200.\n\n#define time (iTime*.25)\n\n\n//\nconst float PI = 3.1415926535;\nconst float PHI = (1.+sqrt(5.))/2.;\nconst float A = PHI / sqrt( 1. + PHI*PHI );\nconst float B = 1. / sqrt( 1. + PHI*PHI );\nconst float J = 0.309016994375;\nconst float K = J+.5;\n\nconst mat3 R0 = mat3(0.5,-K,J        ,K,J,-0.5                       ,J,0.5,K                          );\nconst mat3 R1 = mat3(K,J,-0.5        ,J,0.5,K                        ,0.5,-K,J                         );\nconst mat3 R2 = mat3(-J,-0.5,K       ,0.5,-K,-J                      ,K,J,0.5                          );      \nconst mat3 R4 = mat3(0.587785252292,-K,0.,-0.425325404176,-J,0.850650808352,0.688190960236,0.5,0.525731112119);\nconst vec3 O4 = vec3(A/3./tan(PI/5.),A/3.,0.63147573033330584);\n\nfloat sphere( vec3 p, float r )\n{\n\treturn length(p) - r;\n}\n\nvec3 op_icoso( vec3 p )\n{    \n    p = R0 * abs( p );\n    p = R1 * abs( p );\n    p = R2 * abs( p );\n    return abs( p );  \n} \n\nvec3 op_dodeca( vec3 p, float r )\n{         \n    return R4 * op_icoso( p ) - O4 * r;\n}  \n\nfloat dodeca( vec3 p, float r, float w )\n{         \n    p = R4 * op_icoso( p ) - O4 * r;\n    return sphere( vec3( p.x, max(p.y, 0.), p.z ), w );\n}\n//\n\n\nmat3 rotXY( vec2 angle ) \n{\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\t\n\treturn mat3(c.y      ,  0.0, -s.y,\n\t\t\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\t\t\ts.y * c.x, -s.x,  c.y * c.x\t);\n}\n\nfloat map( vec3 p ) \n{\n    p *= rotXY(vec2(time*0.6,time*.9));\n\treturn dodeca(p,40.,4.);\n}\n\nvec3 lgt;\n\n//modified from iq's \"Hexagons - distance\" (https://www.shadertoy.com/view/Xd2GR3)\n//return values: x = trigger, y = voxel shading, z = distance to voxel edge, w = lighting\nvec4 voxelize( vec2 p, float bias ) \n{\n\t//displace based on layer\n\tp.x += 0.866025*bias;\n\tp.y += 0.5*bias;\n\t\n\t//setup coord system\n\tvec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\tvec2 pi = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(pi.x + pi.y, 3.0);\n\n\tfloat ca = step(1.0,v);\n\tfloat cb = step(2.0,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n    // distance to borders\n\tvec2 bz = 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy);\n\tfloat e = dot( ma, bz );\t\n\t\n\t//voxel shading\n\tfloat top = cb*ma.y+clamp((1.-(ca+ma.y)),0.,1.);\n\tfloat left = 0.5+step(ca,cb)*0.75;\n\t\n\tvec2 j = pi + ca - cb*ma;\n\tfloat sdf = map(vec3(j,bias));\n\t\n\t//faked light (using the normal only, actual lighting gets pretty heavy)\n\tfloat nl = max(dot(normalize(lgt),normalize(vec3(j,bias))),0.);\n\treturn vec4( step(sdf,.01),left+top, e, pow(nl,2.)*2. );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    lgt =  vec3(1,1,10.);\n    vec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x *= iResolution.x/iResolution.y;\n\tvec2 bp = p;\n\tp *= 100.;\n\t\n\tfloat st = sin(time*0.2)*0.3+1.;\n\tvec3 col = vec3(0.);\n\tfor (float i=-NUM_LAYERS/2.;i<NUM_LAYERS/2.;i++) \n\t{\n\t\tvec4 rz = voxelize(p,i);\n\n\t\tvec3 colx = vec3(.25,0.,0.07)*rz.x*2.;\n\n\t\t//voxel shading\n\t\t//colx = (colx + (colx * (rz.y*.5)))*.5;\n\t\t//faked lighting + outline\n\t\tcolx = (colx + (colx * ((rz.w * smoothstep(0., 0.25, rz.z) * rz.y)+0.5)))*.5;\n\t\t//painter's algo\n\t\tcol = col*step(colx,vec3(0.))+colx;\n\t}\n\t\n\tfragColor = vec4( col*1.3, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}