{"ver":"0.1","info":{"id":"3s2cWV","date":"1587359289","viewed":151,"name":"Mandelbrot particles","username":"rory618","description":"https://codepen.io/KilledByAPixel/full/GRpJEzO?fbclid=IwAR0UCQfH3-TgAKLCXyu1ZLlV4E2jtGtcOvpHXkwFX9C5azItkcPeDDmIkIc\nMouse to start orbits\nBest at 8x speed\n\nSpace to toggle conjugate symmetry","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["mandelbrot","interactive","orbits","reproduction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//Strided sort and spatial decorrelation fit into buf a and b over 7 frames\n//Particles get a twisty force applied based on the gradient of a sort of potential feild created by the particles\n//Rendering in buf A\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    //O=abs(texture(iChannel0,I/R.xy))/1e3;//textureLod(iChannel0,vec2(.5),6.)/2.;\n    O=texture(iChannel1,I/R.xy);\n    O = pow(O,vec4(0.5));\n    //O += texelFetch(iChannel2, ivec2(I),0);\n}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \t \t \t \t","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvec2 ptom(vec2 p){\n    return (p - R.xy/2.)/R.y*3.;\n}\n\nvec2 mtop(vec2 m){\n    return m/3.*R.y+R.xy/2.;\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    \n    int stage = iFrame%8;\n    \n    vec2 uv = I/R.xy;\n    vec2 r1 = rand2(IHash3(I.x,I.y,iFrame));\n    vec2 r2 = rand2(IHash3(I.x,I.y/100.,34526324^iFrame));\n    \n    \n    O = texture(iChannel0,uv);\n\n    if(I.x<1.){\n        O.xy = iMouse.xy + randn(r1)*.0005;\n        if(iMouse.xy==vec2(0)) O.xy = R.xy/2. + vec2(sin(iTime),cos(iTime*1.1))*R.y/3.6 + randn(r1)*.0005;\n        if(I.y>R.y/2. && texelFetch(iChannel3,ivec2(32,2),0).x>.5 ) O.y = R.y-O.y;\n        O.zw = O.xy;\n    } else {\n        O = texture(iChannel0,(I-vec2(1,0))/R.xy);\n    \tif(iFrame%8==0){\n            vec2 z = ptom(O.xy);\n            vec2 c = ptom(O.zw);\n            z = mat2(z,-z.y,z.x)*z+c;\n            O.xy = mtop(z);\n        }\n        \n        \n    }\n    \n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define R iResolution\n#define iR ivec3(R)\n#define uR uvec3(R)\n#define IHash3(x,y,z) IHash(int(x)^IHash(int(y)^IHash(int(z))))\n#define dot2(o) dot((o),(o))\n#define tx(ch,p,R) texelFetch(ch, Zmod(p,iR.xy),0)\n\n//Roboust/universal integer modulus function\n#define Zmod(x,y) (((x)+(y)+(y)+(y))-(((x)+(y)+(y)+(y))/(y))*(y))\n//#define Zmod(x,y) ((x+y*10)%y)\n\nfloat packVec2(vec2 x){\n    return uintBitsToFloat(packSnorm2x16(x/10.));\n}\nvec2 umpackVec2(float x){\n    return unpackSnorm2x16(floatBitsToUint(x))*10.;\n}\n\nbool inbounds(vec2 x, vec2 y){\n    return (x.x>0.&&x.y>0.&&x.x<y.x&&x.y<y.y);\n}\n\n//RNG\nint IHash(int a){\n\ta = (a ^ 61) ^ (a >> 16);\n\ta = a + (a << 3);\n\ta = a ^ (a >> 4);\n\ta = a * 0x27d4eb2d;\n\ta = a ^ (a >> 15);\n\treturn a;\n}\n\nfloat Hash(int a){\n\treturn float(IHash(a)) / float(0x7FFFFFFF);\n}\nvec4 rand4(int seed){\n    return vec4(Hash(seed^0x34F85A93),\n                Hash(seed^0x85FB93D5),\n                Hash(seed^0x6253DF84),\n                Hash(seed^0x25FC3625));\n}\nvec3 rand3(int seed){\n    return vec3(Hash(seed^0x348CD593),\n                Hash(seed^0x8593FD5),\n                Hash(seed^0x62A5D384));\n}\nvec2 rand2(int seed){\n    return vec2(Hash(seed^0x348C5F93),\n                Hash(seed^0x8593D5BB));\n}\n\n\nvec2 randn(vec2 randuniform){\n    vec2 r = randuniform;\n    r.x = sqrt(-2.*log(1e-9+abs(r.x)));\n    r.y *= 6.28318;\n    r = r.x*vec2(cos(r.y),sin(r.y));\n    return r;\n}\n\n//Random injective mapping from each pixel to a random new pixel\n//By alternatively adding some randomness from y into x and then \n//x into y, a reversible hash function is made. To take the inverse,\n//simply undo the last \"add randomness to y\" step by subtracting the\n//same random value. You can calculate the random value that was used\n//to modify y because it depends only on x.\n//Reversible == one to one == injective\n//input iFrame/2 to re randoize the mapping every frame\n#define mapping_iters 2\nvec2 forward_mapping(vec2 Z,int p, int q, int Fover2){\n    //int seed = 0;        // Optionaly keep seed constant for that static randomness look\n\tint seed = Fover2;\n    if(!inbounds(Z,vec2(p,q))){return vec2(0);} //Dont map points from outside the boundry\n    int x=int(Z.x);\n    int y=int(Z.y);\n    \n    //Change iterations here to zero to use the identity function as a mapping\n    //Some particles seem to have a better chance of getting drawn...\n    //But it shows off the artifacts in all their glory, looks pretty cool after a reset\n    for(int i = 0; i < mapping_iters; i++){\n        x = Zmod(x + IHash(y^seed)%p,p);\n        y = Zmod(y + IHash(x^seed)%q,q);\n    }\n    \n\t//This is the inverse mapping, only difference is - instead of + and the order of x and y\n    //uncommenting should have the same effect as reducing iterations above to zero\n    //This is a pretty good test of the one to one property of the mapping\n    //Originally it seemed to not be working quite right on some platforms so\n    //this can confirm if that is happening. The effect of a non injective mapping is collisions\n    //And thus many particles getting lost near the final pass.\n    /*\n    for(int i = 0; i < 5; i++){\n        y = Zmod(y - IHash(x)%q,q);\n        x = Zmod(x - IHash(y)%p,p);\n    }\n\t*/\n    \n    return vec2(x,y)+fract(Z);\n    \n}\nvec2 reverse_mapping(vec2 Z,int p, int q, int Fover2){\n    //int seed = 0;        // Optionaly keep seed constant for that static randomness look\n\tint seed = Fover2;\n    if(!inbounds(Z,vec2(p,q))){return vec2(0);} //Dont map points from outside the boundry\n    int x=int(Z.x);\n    int y=int(Z.y);\n    \n    \n    \n    for(int i = 0; i < mapping_iters; i++){\n        y = Zmod(y - IHash(x^seed)%q,q);\n        x = Zmod(x - IHash(y^seed)%p,p);\n    }\n    \n    return vec2(x,y)+fract(Z);\n    \n}\n\nfloat score(vec2 p, vec2 I, vec3 R){\n    if(!inbounds(p,R.xy)) return 1e6; //Bad score for points outside boundry\n    //This should get revamped, there is no reasoning to use\n    //euclidean distance, this metric probably should reflect the tree strtucture\n    //Maybe even output a simple 1 or 0 if the index of this texel leads to the leaf\n    //node that this particle p is going towards\n    \n    //Difference in the noise when using this other metric suggests that \n    //this is indeed screwing performance (likelyhood of missing particles)\n    vec2 D = p-I;\n    D = mod(D+R.xy/2.,R.xy)-R.xy/2.;\n    return max(abs(D.x),abs(D.y));\n    //use l infinity in toroidal space\n    \n    //return dot2(I-p);\n}\n\nvoid updateRank(vec4 t, inout vec4 O, inout float s, vec2 I, vec3 R){\n    float sp = score(t.xy,I,R);\n    if(sp<s){\n        s=sp;\n        O=t;\n    }\n}\n\n//Update ranking, save a list of two particle xy indices. O.xy is better particle, O.zw is a different not as good one\nvoid updateRank2x(vec2 t, inout vec4 O, inout float s0, inout float s1, vec2 I, vec3 R){\n    float sp = score(t,I,R);\n    if(sp<s0){\n        //Shift down the line\n        s1=s0;\n        O.zw=O.xy;\n        s0=sp;\n        O.xy=t;\n    } else if(sp<s1){\n        //Bump off the bottom one\n        s1=sp;\n        O.zw=t;\n        \n    }\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Strided sort ~= jump flood\n//Strided sort summarry:\n//Each pass looks at 9 xy locations stored in the previous pass and selects the closest one\n//The locations sampled are arranged in a 3x3 with the center located at I, and the spacing\n//a power of 3\n//Total 7 passes over two frames sized large to small\n//A->B->C->D->B->C->D->Image\n//Spacing 3^6 ..., 3^1, 3^0\n//I think this gives an optimal data path from each pixel to each other pixel under the constraint of 7 passes\n\n//In each buffer, the pixel to get drawn at index is saved in xy and a second particle in zw.\n\n//large to small\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    //Split frames into 7 stages\n    int stage = iFrame%7;\n    int size = int(.5+pow(3.,float(6-stage)));\n    \n    vec2 r = rand2(IHash3(iFrame,I.x,I.y));\n   // if (stage==6) discard;\n    \n    //int size = stage==0?729:27; //729=3^6\n    float s0;\n    float s1;\n    //init with top left corner and center\n    if(stage==0){\n        vec2 t0 = tx(iChannel0, ivec2(I)-size,R).xy;\n        vec2 t1 = tx(iChannel0, ivec2(I),R).xy;\n                                                                         \n        s0 = score(t0,I,R);\n        s1 = score(t1,I,R);\n        \n        O.xy=t0==vec2(0)?vec2(0):forward_mapping(t0, iR.x, iR.y,iFrame/7);\n        O.zw=t1==vec2(0)?vec2(0):forward_mapping(t1, iR.x, iR.y,iFrame/7);\n        \n        //Select the better one, make sure scores are in order with s0<s1\n        if(s0>s1){\n            vec2 _ = O.xy;\n            O.xy = O.zw;\n            O.zw = _;\n            _.x = s0;\n            s0 = s1;\n            s1 = _.x;\n        }\n    } else {\n        O = tx(iChannel1, ivec2(I)-size,R );\n        s0 = score(O.xy,I,R);\n        s1 = score(O.zw,I,R);\n    }\n    for(int i = 1; i < 9; i++){\n        if(stage==0){\n        \tvec2 t = tx(iChannel0,ivec2(I)-size+size*ivec2(i/3,i%3),R).xy;\n            t = forward_mapping(t, iR.x, iR.y,iFrame/7);\n            updateRank2x(t,O,s0,s1,I,R);\n            \n        } else {\n        \tvec4 t;\n            t = tx(iChannel1,ivec2(I)-size+size*ivec2(i/3,i%3),R); \n            updateRank2x(t.xy,O,s0,s1,I,R);\n            updateRank2x(t.zw,O,s0,s1,I,R);\n        }\n        \n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\n//Use O.w for render pass\n\n\n\nvoid splat(inout float O, vec2 I, vec2 ip, vec2 p){\n    \n    //O = min(O,vec4(length(p-I))/3.);\n    float d2 = dot2(I-p);\n    O += exp(-d2*.6);\n    \n    //if(floor(ip)==floor(p)) O += (.255);\n    \n}\n\n\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    \n    int stage = iFrame%7;\n    \n    vec2 uv = I/R.xy;\n    vec2 r1 = rand2(IHash3(I.x,I.y,iFrame));\n    vec2 r2 = rand2(IHash3(I.x,I.y,34526324^iFrame));\n    \n    \n    \n    O = vec4(0);\n\t//float Owp = texture(iChannel0,uv).w;\n    \n    if(stage==6) {\n    \n        \n    for(int i = 0; i < 9; i++){\n    \tvec2 ip = forward_mapping(I-1.+vec2(i/3,i%3),iR.x,iR.y,(iFrame)/7);\n        vec4 t = texelFetch(iChannel1,ivec2(ip),0);\n        \n        t.xy = reverse_mapping(t.xy,iR.x,iR.y,(iFrame)/7);\n        t.zw = reverse_mapping(t.zw,iR.x,iR.y,(iFrame)/7);\n        \n        splat(O.w,I,I,t.xy);\n        splat(O.w,I,I,t.zw);\n        \n        \n    }\n    } else {\n        O = texture(iChannel0,uv);\n    }\n    //Smooth over time\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 O, in vec2 I )\n{\n    O = .99*texture(iChannel0, I/R.xy);\n    O += .1*texture(iChannel1, I/R.xy).w*(cos(float(iFrame)/60./5.*vec4(2,3,4,1))*.5+.5);\n}","name":"Buffer C","description":"","type":"buffer"}]}