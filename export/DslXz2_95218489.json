{"ver":"0.1","info":{"id":"DslXz2","date":"1669754785","viewed":659,"name":"Edge detection from depth","username":"leoneruggiero","description":"Comparison between two different methods to extract silhouette-edges from depth/viewZ data.","likes":47,"published":1,"flags":32,"usePreview":0,"tags":["postprocessing","edge","npr","silhouettes"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//-----------------------------------------//\n// This is an attempt to detect 1px wide   //\n// silhouette edges* from depth data while //\n// trying to avoid the shortcomings of     //\n// gradient based methods (such as  dark   //\n// triangles when looking edge-on).        // \n//                                         //\n// *by silhouette edges I mean edges       //\n// shared by a front-facing and a          //\n// back-facing triangle (with respect to   //\n// the view direction).                    //\n//-----------------------------------------//\n\n// Uncomment to get better settings for\n// 4K displays.\n// ----------------------------------------\n// #define HI_RES_DISPLAY\n\n// Uncomment to switch to a sobel filter\n// based method (for comparison).\n// Sobel filter implementation from:\n// https://github.com/ssell/UnitySobelOutline\n// ----------------------------------------\n// #define USE_SOBEL\n#define SOBEL_SENSITIVITY 1.8\n#define SOBEL_BIAS 1.8\n\n// Makes edges thicker. \n// Roughly as wide as the value, in pixels.\n// ----------------------------------------\n#ifdef HI_RES_DISPLAY\n    #define INFLATE 2\n#else\n    #define INFLATE 1\n#endif\n\n// Uncomment to show silhouette-edges only.\n// ----------------------------------------\n// #define SILHO_ONLY\n\n// Shading constants\n// ----------------------------------------\n#define LIGHT_DIR  vec3(0.0 , 0.0 , 1.0) \n#define COL_BRIGHT vec3(1.0 , 0.51, 0.4)\n#define COL_DIM    vec3(0.05, 0.53, 0.5)\n#define COL_BG     vec3(0.8 , 0.6 , 0.4)\n#define COL_GRND   vec3(1.0 , 0.9 , 0.8)\n\n// Macros\n// ----------------------------------------\n#define GOOCH(NdotL) (mix(COL_DIM, COL_BRIGHT, NdotL))\n\n#ifdef HI_RES_DISPLAY\n    #define DITHER(intCoords) ( float((intCoord.x+int(intCoord.y%8>=4)*4)%8>=4) )\n#else\n    #define DITHER(intCoords) ( float((intCoord.x+int(intCoord.y%4>=2)*2)%4>=2) )\n#endif\n\n#define SAT(x) ( clamp(x, 0.0, 1.0) )\n\n\nfloat GetTolerance(float d, float k)\n{\n    // -------------------------------------------\n    // Find a tolerance for depth that is constant\n    // in view space (k in view space).\n    //\n    // tol = k*ddx(ZtoDepth(z))\n    // -------------------------------------------\n    \n    float A=-   (FAR+NEAR)/(FAR - NEAR);\n    float B=-2.0*FAR*NEAR /(FAR -NEAR);\n    \n    d = d*2.0-1.0;\n    \n    return -k*(d+A)*(d+A)/B;   \n}\n\nfloat DetectSilho(ivec2 fragCoord, ivec2 dir)\n{\n    // -------------------------------------------\n    //   x0 ___ x1----o \n    //          :\\    : \n    //       r0 : \\   : r1\n    //          :  \\  : \n    //          o---x2 ___ x3\n    //\n    // r0 and r1 are the differences between actual\n    // and expected (as if x0..3 where on the same\n    // plane) depth values.\n    // -------------------------------------------\n    \n    float x0 = abs(texelFetch(iChannel0, (fragCoord + dir*-2), 0).a);\n    float x1 = abs(texelFetch(iChannel0, (fragCoord + dir*-1), 0).a);\n    float x2 = abs(texelFetch(iChannel0, (fragCoord + dir* 0), 0).a);\n    float x3 = abs(texelFetch(iChannel0, (fragCoord + dir* 1), 0).a);\n    \n    float d0 = (x1-x0);\n    float d1 = (x2-x3);\n    \n    float r0 = x1 + d0 - x2;\n    float r1 = x2 + d1 - x1;\n    \n    float tol = GetTolerance(x2, 0.04);\n    \n    return smoothstep(0.0, tol*tol, max( - r0*r1, 0.0));\n\n}\n\nfloat DetectSilho(ivec2 fragCoord)\n{\n    return max(\n        DetectSilho(fragCoord, ivec2(1,0)), // Horizontal\n        DetectSilho(fragCoord, ivec2(0,1))  // Vertical\n        );\n}\n\n// Sobel-based edge detection.\n// From: https://github.com/ssell/UnitySobelOutline\n// ------------------------------------------------\nfloat SobelDepth(float ldc, float ldl, float ldr, float ldu, float ldd)\n{\n    return \n        abs(ldl - ldc) +\n        abs(ldr - ldc) +\n        abs(ldu - ldc) +\n        abs(ldd - ldc);\n}\n\nfloat SobelDepth(vec2 uvCoord, vec3 offset)\n{\n    return SobelDepth\n    (\n        texture(iChannel0, uvCoord + offset.zz).b, \n        texture(iChannel0, uvCoord - offset.xz).b, \n        texture(iChannel0, uvCoord + offset.xz).b, \n        texture(iChannel0, uvCoord + offset.zy).b, \n        texture(iChannel0, uvCoord - offset.zy).b\n    );\n}\n\nfloat SobelDepth(vec2 fragCoord)\n{\n    // The size is ~2px to be consistent with the other\n    // approach (1px wide edges + inflate later).\n    // If you were to use the SobelDepth approach you could just\n    // set a bigger offset here to increase edge thickness.\n    vec3 offset = vec3\n    (\n        1.0/iChannelResolution[0].x,\n        1.0/iChannelResolution[0].y,\n        0.0\n    );\n    \n    vec2 uvCoord = fragCoord/iChannelResolution[0].xy;\n    \n    return pow(SobelDepth(uvCoord, offset) * SOBEL_SENSITIVITY, SOBEL_BIAS);\n}\n\nfloat DetectSilhoWithSobel(vec2 fragCoord)\n{\n    return SobelDepth(fragCoord);\n}\n// -----------------------------------------------------\n\n\nfloat Silho(vec2 fragCoord)\n{\n    return\n    \n#ifdef USE_SOBEL\n         DetectSilhoWithSobel(fragCoord.xy);\n#else\n         DetectSilho(ivec2(fragCoord.xy));         \n#endif\n}\n\nvec3 getEyePos(vec4 buffVal)\n{ \n    return buffVal.xyz * vec3(1,1,-1); \n}\n\nvec3 getEyeNormal(ivec2 intCoord)\n{\n    // Compute view space normals from view positions.\n    // For each dimension (x/y) take the derivative with the lowest\n    // absolute value to avoid some of the artifacts of the\n    // cross(dFdx, dFdy) method.\n    float sgn = 1.0;\n    \n    vec3 c   = getEyePos(texelFetch(iChannel0, intCoord.xy, 0));\n    vec3 pDx = getEyePos(texelFetch(iChannel0, intCoord.xy + ivec2( 1.0, 0.0), 0));\n    vec3 nDx = getEyePos(texelFetch(iChannel0, intCoord.xy + ivec2(-1.0, 0.0), 0));\n    vec3 pDy = getEyePos(texelFetch(iChannel0, intCoord.xy + ivec2( 0.0, 1.0), 0));\n    vec3 nDy = getEyePos(texelFetch(iChannel0, intCoord.xy + ivec2( 0.0,-1.0), 0));\n    \n    vec3 dx = pDx;\n    vec3 dy = pDy;\n    \n    if(abs(nDx.z-c.z)<abs(pDx.z-c.z)) {dx = nDx; sgn*=-1.0;}\n    if(abs(nDy.z-c.z)<abs(pDy.z-c.z)) {dy = nDy; sgn*=-1.0;}\n    \n    return normalize(cross(dx-c, dy-c))*sgn;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  \n  vec2 uv = fragCoord.xy / iResolution.xy;\n  ivec2 intCoord= ivec2(fragCoord);\n  vec4 buf = texture(iChannel0, fragCoord.xy / iResolution.xy);\n  \n  float depth = buf.a;\n  vec3 eyeNormal = getEyeNormal(intCoord);\n  \n  vec3 col = COL_BG;\n  \n  // Silhouette-edge value\n  float s = Silho(fragCoord.xy); \n\n#ifdef INFLATE \n\n  // Makes silhouettes thicker.\n  for(int i=1;i<=INFLATE; i++)\n  {\n     s = max(s, Silho(fragCoord.xy + vec2(i, 0)));\n     s = max(s, Silho(fragCoord.xy + vec2(0, i)));\n  }   \n#endif\n  \n#ifndef SILHO_ONLY\n\n  // Gooch shading.\n  float NdotL = dot(eyeNormal, normalize(LIGHT_DIR));\n  col = GOOCH(NdotL);\n  \n  // Dither effect for low-lit areas\n  col = mix(col,vec3(0.0, 0.2, 0.2), DITHER(intCoord) * SAT(0.4-NdotL)*4.);\n  \n  // Background with kind of vignette.\n  col = mix(col, COL_BG  , float(depth==1.0));\n  col = mix(col, COL_GRND, float(depth==1.0) * SAT(1.0-length(uv-0.5)));  \n   \n  // Silhouettes\n  col = mix(col, vec3(0.0, 0.0, 0.0),s);\n  \n#else\n  \n  // Shows only silhouettes on a white bg.\n  col = mix(vec3(1.0), vec3(0.0), s);\n  \n#endif\n  \n  fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define ROTATION_SPEED 0.12\n#define ANIMATION_SPEED 0.5\n#define LIGHT_DIR vec3(0.3, 1.0, -1.0)\n#define PI_3 1.0471975512\n#define PI_4 0.78539816339\n#define TWO_PI 6.28318530718\n#define TOWER_SIZE 0.26\n#define PLATFORM_SIZE 0.26\n#define STAIRS_SIZE 0.12\n#define PLATFORM_THICKNESS 0.1\n#define FLOOR_HEIGHT 0.5\n\n// SDFs\n// from: https://iquilezles.org/articles/distfunctions\n// ------------------\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n// ------------------\n\n\n// Utils\n// ------------------\nvec2 mirrorXZ(vec2 p)\n{\n    return abs(p);\n}\n\nvec2 rotate2D(vec2 p, float a) {\n  return p * mat2(cos(a), -sin(a), sin(a),  cos(a));\n}\n\n// Rotates on the XZ plane by a multiple of PI/2.\nvec2 rotate2D_PI2(vec2 p, int i) \n{\n  return vec2(((i>0&&i<3)?-1.0:1.0)*((i%2==0)?p.x:p.y), ((i>1)?-1.0:1.0)*((i%2==0)?p.y:p.x));\n}\n\nvec3 rotate3D_PI2(vec3 p, int i)\n{\n    vec2 xz=rotate2D_PI2(p.xz, i);\n    return vec3(xz.x, p.y, xz.y);\n}\n\n// Function that transforms the animation parameter [0, 1]\n// to give a bit of anticipation and \"overshoot\" feel to the motion.\nfloat overshoot(float t)\n{\n    return smoothstep(0.0, 1.0, t) - sin(t*TWO_PI)*0.15;\n}\n\nfloat overshootInterp(float a, float b, float s)\n{\n    float t=overshoot(s);\n    return (1.0-t)*a + t*b;\n}\n\nvec3 overshootInterp(vec3 a, vec3 b, float s)\n{\n    float t=overshoot(s);\n    return (1.0-t)*a + t*b;\n}\n\n// ------------------\n\nfloat drawTower(vec3 p, float h1, float h2, float t, float minDist)\n{\n    float h = mix(h1, h2, t);\n    float thickness = PLATFORM_THICKNESS;\n    float towH = (h*0.5)+thickness;\n    \n    vec3 pTower = p-vec3(0.0, h*0.5-thickness, 0.0);\n    minDist = sdBox(pTower, vec3(TOWER_SIZE, towH, TOWER_SIZE));\n    \n    vec3 pRoof =  p     - vec3(0.0, h+TOWER_SIZE, 0.0);\n    vec3 pRoof2 = pRoof - vec3(0., TOWER_SIZE*1.2, 0.);\n    vec3 pRoof3 = pRoof - vec3(0., TOWER_SIZE*1.2, 0.);\n    vec3 pRoof4 = p     - vec3(0., h +.6*TOWER_SIZE, 0.);\n    \n    \n    if(minDist<sdBox(pRoof - vec3(0., .2, 0.)*TOWER_SIZE, vec3(1., 1.2, 1.)*TOWER_SIZE))\n        return minDist;\n    \n    minDist = min(minDist, sdBox(pRoof, vec3(1.)*TOWER_SIZE));\n    \n    // Doors\n    // -----\n    pRoof4.xz = rotate2D(pRoof4.xz, PI_4);\n    pRoof4.xz = mirrorXZ(pRoof4.xz);\n    pRoof4.xz = rotate2D(pRoof4.xz, -PI_4);\n    minDist = max(minDist, -sdBox(pRoof4-vec3(.9*TOWER_SIZE, 0., 0.), vec3(.2*TOWER_SIZE, .6*TOWER_SIZE, STAIRS_SIZE)));\n    minDist = max(minDist, -sdCappedCylinder((pRoof4-vec3(.9*TOWER_SIZE, .6*TOWER_SIZE, 0.)).zxy, STAIRS_SIZE, .2*TOWER_SIZE));\n    \n    // Battlements\n    // -----------\n    float k = .2*TOWER_SIZE;\n    pRoof2.xz = min(pRoof.xz+4.*k, max( pRoof.xz-4.*k,mod(pRoof.xz+0.5*4.*k,4.*k)-0.5*4.*k));\n    minDist = min(minDist,  sdBox(pRoof2, vec3(k)));\n    minDist = max(minDist, -sdBox(pRoof3, vec3(.8, .5,.8)*TOWER_SIZE));\n\n    return minDist;   \n}\n\nfloat drawPlatform(vec3 p, float h1, float h2, float t)\n{\n    float h = mix(h1, h2, t);\n    float thickness = PLATFORM_THICKNESS;\n    return sdBox(p-vec3(0.0, h-thickness, 0.0), vec3(PLATFORM_SIZE, thickness, PLATFORM_SIZE));\n}\n\nfloat drawStairs(vec3 p, float hFrom1,float hTo1, float hFrom2, float hTo2, float t, float minDist)\n{\n    float stairs = 5.0;\n    float k = 2.0;\n    float o = 1.0/(float(stairs)*k);\n    float thickness = PLATFORM_THICKNESS*0.6;\n    float minX = TOWER_SIZE+0.05;\n    float maxX = 1.0 - PLATFORM_SIZE-0.05;\n    float deltaX = (maxX-minX)/(stairs-1.0);\n    \n    float minH1 = min(hFrom1, hTo1);\n    float maxH1 = max(hFrom1, hTo1);\n    float minH2 = min(hFrom2, hTo2);\n    float maxH2 = max(hFrom2, hTo2);\n    \n    float minH = mix(minH1, min(minH1, minH2), float(t>0.0))-2.0*thickness;\n    float maxH = mix(maxH1, max(maxH1, maxH2), float(t>0.0));\n    \n    \n    // Bbox test\n    // ---------\n    vec3 boxCenter = vec3(0.5*(minX+maxX),0.5*(minH+maxH), 0.0);\n    vec3 boxSize   = vec3(0.5*(maxX-minX) + STAIRS_SIZE,0.5*(maxH-minH)*1.0 /*account for animation*/,STAIRS_SIZE);\n    \n    if(sdBox(p-boxCenter,boxSize)>minDist)\n       return minDist;\n   \n    // Debug bounding box for culling\n    // minDist = min(minDist, sdBox(p-boxCenter,boxSize));\n    // return minDist;\n    // ------------------------------\n  \n    for(float s=0.0; s<stairs; s++)\n    {\n        // Each stair has its animation offset.\n        float tOff = min(max(0.0, (t-o*s)*k), 1.0);\n        \n        // The animation parameter is transformed to avoid \n        // perfectly linear motion.\n        float hFrom = overshootInterp(hFrom1, hFrom2, tOff);\n        float hTo   = overshootInterp(hTo1  , hTo2  , tOff);\n        float h = ((hFrom) + s*(hTo-hFrom)/(stairs -1.0)) - thickness;\n        \n        minDist = min(sdBox(p-vec3(minX + deltaX*s, h, 0.0), vec3(deltaX*0.55, thickness, STAIRS_SIZE)), minDist);\n    }\n    \n    return minDist;\n}\n\n\nfloat drawStairs(vec3 p, mat3 config, mat3 nextConfig,int fromCol, int fromRow, int toCol, int toRow, float t, float minDist)\n{\n    float hFrom1 =     config[fromCol][fromRow];\n    float hTo1   =     config[toCol][toRow];\n    float hFrom2 = nextConfig[fromCol][fromRow];\n    float hTo2   = nextConfig[toCol][toRow];\n    \n    int dC = toCol-fromCol;\n    int dR = toRow-fromRow;\n\n    p.xz-=vec2(fromCol-1, fromRow-1);\n    p=rotate3D_PI2(p, (((abs(dC)>abs(dR))?1:4)-(dC+dR))%4);\n        \n    return drawStairs(p, hFrom1, hTo1, hFrom2, hTo2, t, minDist);\n}\n\n\nfloat drawScene(vec3 p, mat3 config, mat3 nextConfig, float t)\n{\n    // ----------------------------------------------------------------------------------------------------------\n    // The scene is layed out as a 3x3 grid. A \"random\" height is generated for each tower ([0, 2]*FLOOR_HEIGHT).\n    // Each platform is placed at an appropriate height  to allow the towers to be connected.\n    // Stairs are drawn to connect the towers through  the platforms.\n    // ----------------------------------------------------------------------------------------------------------\n    //\n    //   XX         ||         XX\n    // X 00 X --- | 10 | --- X 20 X\n    //   XX         ||         XX\n    //   !          !          !\n    //   !  IV quad ! III quad !\n    //   !          !          !\n    //   ||         XX         ||\n    // | 01 | --- X 11 X --- | 21 |\n    //   ||         XX         ||\n    //   !          !          !\n    //   !  I quad  !  II quad !\n    //   !          !          !\n    //   XX         ||         XX\n    // X 02 X --- | 12 | --- X 22 X\n    //   XX         ||         XX\n    //\n    //\n    //   XX             //   ||                //\n    // X nn X -> TOWER  // | nn | -> PLATFORM  // --- -> STAIRS\n    //   XX             //   ||                //\n    \n    float minDist = FAR;\n    \n    vec3 quadS  = vec3( 0.5 + TOWER_SIZE, FLOOR_HEIGHT + 1.2*TOWER_SIZE + PLATFORM_THICKNESS, .5);\n    vec3 quad1C = vec3(-0.5, FLOOR_HEIGHT + 1.2*TOWER_SIZE, 0.5);\n    vec3 quad2C = vec3( 0.5, FLOOR_HEIGHT + 1.2*TOWER_SIZE, 0.5);\n    vec3 quad3C = vec3( 0.5, FLOOR_HEIGHT + 1.2*TOWER_SIZE,-0.5);\n    vec3 quad4C = vec3(-0.5, FLOOR_HEIGHT + 1.2*TOWER_SIZE,-0.5);\n    \n    float boxDist;\n   \n    // BBoxes used for culling, one for each quadrant\n    // minDist = sdBox((p - quad1C)     -vec3(0.0, 0.0, TOWER_SIZE), quadS);\n    // minDist = sdBox((p - quad2C).zyx -vec3(0.0, 0.0, TOWER_SIZE), quadS);\n    // minDist = sdBox((p - quad3C)     +vec3(0.0, 0.0, TOWER_SIZE), quadS);\n    // minDist = sdBox((p - quad4C).zyx +vec3(0.0, 0.0, TOWER_SIZE), quadS);\n   \n   \n    // Quadrant I\n    // ----------\n    if((boxDist = sdBox((p - quad1C)-vec3(0.0, 0.0, TOWER_SIZE), quadS))<=minDist)\n    {\n        minDist = min(drawPlatform(p-vec3( 0.0, 0.0, 1.0), config[1][2], nextConfig[1][2], t), minDist);\n        minDist = min(drawTower(p-vec3(-1.0, 0.0, 1.0), config[0][2], nextConfig[0][2], t, minDist), minDist);\n        minDist = min(drawStairs(p, config, nextConfig, 1,2,  0,2, t, minDist), minDist);\n        minDist = min(drawStairs(p, config, nextConfig, 0,1,  0,2, t, minDist), minDist);\n        minDist = min(drawStairs(p, config, nextConfig, 1,2,  1,1, t, minDist), minDist);\n        \n    } \n    \n    // Quadrant II\n    // -----------\n    if((boxDist = sdBox((p - quad2C).zyx-vec3(0.0, 0.0, TOWER_SIZE), quadS))<=minDist)\n    {\n        minDist = min(drawPlatform(p-vec3( 1.0, 0.0, 0.0), config[2][1], nextConfig[2][1], t), minDist);\n        minDist = min(drawTower(p-vec3(1.0, 0.0, 1.0), config[2][2], nextConfig[2][2], t, minDist), minDist);\n        minDist = min(drawStairs(p, config, nextConfig, 1,2,  2,2, t, minDist), minDist);\n        minDist = min(drawStairs(p, config, nextConfig, 2,1,  2,2, t, minDist), minDist);\n        minDist = min(drawStairs(p, config, nextConfig, 2,1,  1,1, t, minDist), minDist);\n    }\n    \n    // Quadrant III\n    // ------------\n    if((boxDist = sdBox((p - quad3C)+vec3(0.0, 0.0, TOWER_SIZE), quadS))<=minDist)\n    {\n        minDist = min(drawPlatform(p-vec3( 0.0, 0.0,-1.0), config[1][0], nextConfig[1][0], t), minDist);\n        minDist = min(drawTower(p-vec3(1.0, 0.0, -1.0), config[2][0], nextConfig[2][0], t, minDist), minDist);\n        minDist = min(drawStairs(p, config, nextConfig, 1,0,  2,0, t, minDist), minDist);\n        minDist = min(drawStairs(p, config, nextConfig, 2,1,  2,0, t, minDist), minDist);\n        minDist = min(drawStairs(p, config, nextConfig, 1,0,  1,1, t, minDist), minDist);\n        \n    }\n    \n    // Quadrant IV\n    // -----------\n    if((boxDist = sdBox((p - quad4C).zyx +vec3(0.0, 0.0, TOWER_SIZE), quadS))<=minDist)\n    {\n        minDist = min(drawPlatform(p-vec3(-1.0, 0.0, 0.0), config[0][1], nextConfig[0][1], t), minDist);\n        minDist = min(drawTower(p-vec3(-1.0, 0.0, -1.0), config[0][0], nextConfig[0][0], t, minDist), minDist);\n        minDist = min(drawStairs(p, config, nextConfig, 1,0,  0,0, t, minDist), minDist);\n        minDist = min(drawStairs(p, config, nextConfig, 0,1,  0,0, t, minDist), minDist);\n        minDist = min(drawStairs(p, config, nextConfig, 0,1,  1,1, t, minDist), minDist);\n        \n    }\n    \n    minDist =min(drawTower(p-vec3( 0.0, 0.0, 0.0), config[1][1], nextConfig[1][1], t, minDist), minDist);\n    \n    return minDist;\n}\n\n\nfloat solvePlatform(float t0, float t1, float t2)\n{\n    float m = min(min(t0, t1), t2);\n    float M = max(max(t0, t1), t2);\n    \n    return  m + floor((M-m)/2.0);\n\n}\n\nvoid solveConfig(inout mat3 config)\n{\n    config[1][0] = solvePlatform(config[0][0], config[2][0], config[1][1]);\n    config[1][2] = solvePlatform(config[0][2], config[2][2], config[1][1]);\n    config[0][1] = solvePlatform(config[0][0], config[0][2], config[1][1]);\n    config[2][1] = solvePlatform(config[2][0], config[2][2], config[1][1]);\n\n    // Adjust tower and platforms heights\n    config*=FLOOR_HEIGHT;\n\n}\n\nint getTimedIndex()\n{\n    return int(iTime*ANIMATION_SPEED);\n\n}\n\nfloat getTimeParam()\n{\n    float t = fract(iTime*ANIMATION_SPEED);\n    float ratio = 0.7;\n    return max(0.0, t-ratio) * 1.0/(1.0-ratio);\n}\n\nvoid getConfiguration(int index, out mat3 config)\n{\n \n    // Random enough for its purpose...\n    int texIdx = index%64;\n    float rnd0 = floor(texelFetch(iChannel1, ivec2(texIdx, 0), 0).r*2.999);\n    float rnd1 = floor(texelFetch(iChannel1, ivec2(texIdx, 1), 0).r*2.999);\n    float rnd2 = floor(texelFetch(iChannel1, ivec2(texIdx, 2), 0).r*2.999);\n    float rnd3 = floor(texelFetch(iChannel1, ivec2(texIdx, 3), 0).r*2.999);\n    float rnd4 = floor(texelFetch(iChannel1, ivec2(texIdx, 4), 0).r*2.999);\n    \n    config = mat3(\n    rnd0, 0.0,  rnd3,\n    0.0 , rnd2, 0.0,\n    rnd3, 0.0,  rnd4\n    );\n   \n}\n\nfloat sdScene(vec3 p)\n{\n    int index = getTimedIndex();\n    float t = getTimeParam();\n    \n    mat3 config;\n    mat3 nextConfig;\n    \n    getConfiguration(index, config);\n    getConfiguration(index+1, nextConfig);\n    \n    solveConfig(config);\n    solveConfig(nextConfig);\n    \n    return drawScene(p, config, nextConfig, t);\n}\n\nmat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nvec3 getRay(mat3 camMat, vec2 screenPos, float lensLength) {\n  return normalize(camMat * vec3(screenPos, lensLength));\n}\n\nfloat calcRayIntersection(vec3 rayOrigin, vec3 rayDir, float mind, float maxd, float precis) {\n  float latest = precis;\n  float dist   = mind;\n  float type   = -1.0;\n  float res    = -1.0;\n\n  for (int i = 0; i < 30; i++) {\n    if (latest < precis) break;\n    if (dist > maxd)     return -1.0;\n\n    float result = sdScene(rayOrigin + rayDir * dist);\n\n    latest = result;\n    dist  += latest;\n  }\n\n  if (dist < maxd) {\n    res = dist;\n  }\n\n  return res;\n}\n\nvec2 squareFrame(vec2 screenSize, vec2 coord) {\n  vec2 position = 2.0 * (coord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\n\nfloat calcDepth(float zEye, float rayMinDist, float rayMaxDist)\n{\n        if(zEye == rayMaxDist) return -0.0001; // Background\n        \n        float dn = 1.0 / (rayMaxDist - rayMinDist);\n        float zn = (-(rayMaxDist + rayMinDist)*dn*zEye - (2.0*rayMaxDist*rayMinDist*dn)) / -zEye;\n        return zn * 0.5 + 0.5;\n}\n\nfloat calcZEye(vec3 rayDir, vec3 rayOrigin, vec3 rayTarget, float rayDist, float rayMinDist, float rayMaxDist)\n{\n    if(rayDist<0.0||rayDist>rayMaxDist - 0.001) return rayMaxDist; // No hit\n    \n    float ze =\n        dot(rayDir, normalize(rayTarget - rayOrigin))*-rayDist;\n        \n    return  ze;\n}\n\nvec3 calcEyePos(vec3 camOrigin, vec3 ray, float t, mat3 viewMat)\n{\n    return transpose(viewMat) * (ray* t);\n   \n}\n\nvec3 getCameraPositionSphere()\n{\n    bool mouseDown = (iMouse.z > 0.);\n    return vec3\n    (\n        /* R     */ 5.4,\n        /* Phi   */ mouseDown ? (iMouse.x/iChannelResolution[0].x)*12.5-6.25  : iTime * ROTATION_SPEED,\n        /* Theta */ 0.48\n    );\n}\n\nvec3 SphereToCartesian(vec3 s)\n{\n    float sinTetha = sin(s.z);\n    float cosTetha = cos(s.z);\n    float cosPhi   = cos(s.y);\n    float sinPhi   = sin(s.y);\n    \n    return vec3\n    (\n        s.x*sinTetha*cosPhi,\n        s.x*cosTetha,\n       -s.x*sinTetha*sinPhi\n    );\n}\n\nvec3 getCameraPosition()\n{\n    return SphereToCartesian(getCameraPositionSphere());\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n  vec2 uv = squareFrame(iResolution.xy, fragCoord.xy);\n  vec3 ro = getCameraPosition();\n  vec3 ta = vec3(0, 0, 0);\n  mat3 camMat = calcLookAtMatrix(ro, ta, 0.0);\n  vec3 rd = getRay(camMat, uv, 2.0);\n  float t = calcRayIntersection(ro, rd, NEAR, FAR, 0.001);\n  vec3 pos = ro + rd * t;\n  vec3 eyePos = calcEyePos(ro, rd, t, camMat);\n  \n  float depth = \n      (t < 0.0 )\n      ? 1.0\n      : calcDepth(-eyePos.z, NEAR, FAR);\n   \n  fragColor = vec4(\n      eyePos.xyz, \n      depth);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define NEAR 1.0\n#define FAR  7.0\n","name":"Common","description":"","type":"common"}]}