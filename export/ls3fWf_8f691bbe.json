{"ver":"0.1","info":{"id":"ls3fWf","date":"1527015810","viewed":251,"name":"improved puzzle generator","username":"Emil","description":"based on the same gameplay as here:\nhttp://emilmeiton.com/Experiments/Sweeper/index.html\n\nclick to zoom in to an individual level/cell\nImagine starting at the green pixel and try to get to one of the red pixels with as few moves as possible.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["2d","recursive","puzzle","level"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 cs = vec4(0.2,0.2,0.0,0.0); // color startPosition\nvec4 ch = vec4(0.1,0.0,0.0,0.0); // color horizontal\nvec4 cv = vec4(0.0,0.1,0.0,0.0); // color vertical\nvec4 chv = vec4(0.1,0.1,0.0,0.0);//ch+cv; // color horizontal and vertical\nvec4 nothing = vec4(0.0,0.0,0.0,-1.0); // color empty\nvec4 rock = vec4(0.0,0.0,0.1,0.0); // color rock\nvec4 cg = vec4(1.0,0.0,0.0,0.0); // color goal\n\nvec2 roomSize = vec2(16.0,9.0);\nint roomSizeX = 16;\nint roomSizeY = 9;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord;\n    float zoom = smoothstep(0.0,1.0,texture(iChannel1,vec2(0.25)).r); // mix value for zoom\n    vec2 zoomMouse = texture(iChannel1,vec2(0.75)).xy; // holding mouse position for zoom\n    //if(iMouse.z > 0.0){\n    vec2 zoom_uv = uv;\n    if(zoom>0.0){\n        zoom_uv *= 1.0-(zoom)*0.9;\n        zoom_uv += zoomMouse.xy*iResolution.xy;\n        zoom_uv -= (iResolution.xy*0.1)*0.5;\n        //uv *= 0.3;\n    }\n    uv = mix(uv,zoom_uv,zoom);\n    uv /= iResolution.xy;\n    //uv *= 0.1;\n\tvec4 val = texture(iChannel0, uv);\n    \n    if(val==nothing){\n        fragColor = vec4(0.2,0.4,0.5,1.0);\n    }\n    \n    if(val==rock){\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n    }\n    /*\n    if(val.r>0.0){ // horizontal\n        fragColor += vec4(0.5,0.0,0.3,1.0);\n    }\n    if(val.g>0.0){ // vertical\n        fragColor += vec4(0.0,0.7,0.3,1.0);\n    }\n    */\n    \n    if(length(val.rg)>0.0){ // horizontal and vertical\n        fragColor = vec4(0.5,0.5,0.3,1.0);\n    }\n    \n    if(length(val.rg)>0.0){\n        fragColor += val.a*10.0;\n    }\n    \n    if(val==cs){ // start\n        fragColor = vec4(0.0,1.0,0.0,1.0);\n    }\n    \n    if(iFrame>=230){\n        if(val==chv||val.x==ch.x||val.y==cv.y){\n            fragColor = vec4(0.2,0.4,0.5,1.0);\n        }\n        if(val==cg){\n            fragColor = vec4(1.0,0.0,0.0,1.0);\n        }\n    }\n    //fragColor = val;\n    //fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 cs = vec4(0.2,0.2,0.0,0.0); // color startPosition\nvec4 ch = vec4(0.1,0.0,0.0,0.0); // color horizontal\nvec4 cv = vec4(0.0,0.1,0.0,0.0); // color vertical\nvec4 chv = vec4(0.1,0.1,0.0,0.0);//ch+cv; // color horizontal and vertical\nvec4 nothing = vec4(0.0,0.0,0.0,-1.0); // color empty\nvec4 rock = vec4(0.0,0.0,0.1,0.0); // color rock\nvec4 extraStep = vec4(0.0,0.0,0.2,0.0); // color remove extra step\nvec4 step = vec4(0.0,0.0,0.0,0.003); // incremental step to take for player movement\nvec4 cg = vec4(1.0,0.0,0.0,0.0); // color goal\n\nvec2 roomSize = vec2(16.0,9.0);\nint roomSizeX = 16;\nint roomSizeY = 9;\nfloat random()\n{\n\treturn fract(sin(dot(gl_FragCoord.xy, vec2(12.9898,78.233))) * 43758.5453);  \n}\n\nvec2 cellrandom(vec2 xy)\n{\n    return vec2((fract(sin(dot(xy, vec2(12.9898,78.233))) * 43758.5453)-0.5)*2.0,(fract(sin(dot(xy, vec2(156.561,3651.685))) * 65132.6516)-0.5)*2.0);\n}\n\nvec4 get_pixel(float x_offset, float y_offset)\n{\n\treturn texture(iChannel0, (gl_FragCoord.xy / iResolution.xy) + (vec2(x_offset, y_offset) / iResolution.xy));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec4 currentPixel = get_pixel(0.0, 0.0);\n    vec4 rp = get_pixel(-1.0,0.0);\n    vec4 lp = get_pixel(1.0,0.0);\n    vec4 dp = get_pixel(0.0,-1.0);\n    vec4 up = get_pixel(0.0,1.0);\n\n    float cellx = floor(gl_FragCoord.x) - floor(mod(gl_FragCoord.x,roomSize.x));\n    float celly = floor(gl_FragCoord.y) - floor(mod(gl_FragCoord.y,roomSize.y));\n    vec2 startPosition = cellrandom(vec2(cellx,celly));\n    float cellRandom = startPosition.x;\n\t\n\n    if(iFrame==0){\n        //placing walls\n        currentPixel = nothing;\n        currentPixel = mod(gl_FragCoord.x,roomSize.x)<=1.0?rock:mod(gl_FragCoord.y,roomSize.y)<=1.0?rock:currentPixel;\n    }\n    vec4 newPixel = currentPixel;\n\n    bool imAStartPosition = false;\n    // placing startpositions    \n    if(floor(mod(gl_FragCoord.x,roomSize.x))==floor((roomSize.x*.5)+(roomSize.x*0.5-1.0)*startPosition.x)){\n        if(floor(mod(gl_FragCoord.y,roomSize.y))==floor((roomSize.y*.5)+(roomSize.y*0.5-1.0)*startPosition.y)){\n            currentPixel = cs;\n            newPixel = currentPixel;\n            imAStartPosition = true;\n        }\n    }\n    if(iFrame<240){\n        if(imAStartPosition == false) {\n            newPixel = currentPixel;\n            if(currentPixel.b == nothing.b){ // \"untouched\" pixel (we check r and g below)\n\n                // check horizontal and vertical\n                if(currentPixel.x == nothing.x){\n                    if(rp!=rock && rp.x>0.0){\n                        newPixel += ch; // right\n                        if(/*newPixel.a>rp.a||newPixel.a==nothing.a*/true){ // player steps\n                            newPixel.a = rp.a;\n                        }\n                    }\n                    if(lp!=rock && lp.x>0.0){\n                        newPixel += ch; // left\n                        if(/*newPixel.a>lp.a||*//*newPixel.a==nothing.a*/true){ // player steps\n                            newPixel.a = lp.a;\n                        }\n                    }\n                }\n                if(currentPixel.y == nothing.y){\n                    if(dp!=rock && dp.y>0.0){\n                        newPixel += cv; // down\n                        if(/*newPixel.a>dp.a||*//*newPixel.a==nothing.a*/true){ // player steps\n                            newPixel.a = dp.a;\n                        }\n                    }\n                    if(up!=rock && up.y>0.0){\n                        newPixel += cv; // up\n                        if(/*newPixel.a>up.a||*//*newPixel.a==nothing.a*/true){ // player steps\n                            newPixel.a = up.a;\n                        }\n                    }\n                }\n            }\n            newPixel.r = clamp(newPixel.r,0.0,0.1);\n            newPixel.g = clamp(newPixel.g,0.0,0.1);\n\n            if(currentPixel==nothing&&newPixel!=nothing){ // we are \"traveling\" ontop of this pixel\n\n                // place rocks\n                if(random()>0.8+0.1*cellRandom){\n                    newPixel = rock;\n                }\n            }\n\n            if(currentPixel!=nothing&&newPixel!=nothing){ // we are on stuff that isn't nothing\n\n                if(currentPixel.b!=rock.b){ // not interested of checking on top of rocks\n\n                    if(rp.b==rock.b){ // rock to the right\n                        if(currentPixel.x==0.1){\n                            if (newPixel.y != chv.y){\n                                newPixel.xy = chv.xy;\n                                newPixel += step;\n                                newPixel.b = extraStep.b;\n                            }\n                        }\n                    }\n                    if(lp.b==rock.b){ // rock to the left\n                        if(currentPixel.x==0.1){\n                            if (newPixel.y != chv.y){\n                                newPixel.xy = chv.xy;\n                                newPixel += step;\n                                newPixel.b = extraStep.b;\n                            }\n                        }\n                    }\n                    if(up.b==rock.b){ // rock above\n                        if(currentPixel.y==0.1){\n                            if (newPixel.x != chv.x){\n                                newPixel.xy = chv.xy;\n                                newPixel += step;\n                                newPixel.b = extraStep.b;\n                            }\n                        }\n                    }\n                    if(dp.b==rock.b){ // rock below\n                        if(currentPixel.y==0.1){\n                            if (newPixel.x != ch.x){\n                                newPixel.xy = chv.xy;\n                                newPixel += step;\n                                newPixel.b = extraStep.b;\n                            }\n                        }\n                    }\n\n                    //// we need to correct the added step above, the step added above is needed but needs to correct itself\n\n                    if(currentPixel.b==extraStep.b){\n                        newPixel.b = 0.0;\n                        newPixel.a -= step.a;\n                    }\n                    if(iFrame>=180){\n                        if(currentPixel.xy==chv.xy){\n                            //newPixel.a += 5.0;\n                            if(rp.a<currentPixel.a && rp!=rock){\n                                newPixel.a = rp.a;\n                            }\n                            if(lp.a<currentPixel.a && lp!=rock){\n                                newPixel.a = lp.a;\n                            }\n                            if(up.a<currentPixel.a && up!=rock){\n                                newPixel.a = up.a;\n                            }\n                            if(dp.a<currentPixel.a && dp!=rock){\n                                newPixel.a = dp.a;\n                            }\n                        }\n                    }\n                }\n\n                if(newPixel.b==rock.b){ // if we placed a rock then make sure we dont travel \"through\" it\n                    newPixel.rg = nothing.rg;\n                }\n            }\n        }\n    }\n    //if(iFrame>=240){   \n        if(iFrame==240){\n            if(fract(fragCoord.x/roomSize.x)<=1.0/roomSize.x && fract(fragCoord.y/roomSize.y)<=1.0/roomSize.y){\n                float highestStep = 0.0;\n                for (float x = 0.0; x < roomSize.x; x++){ \n                    for (float y = 0.0; y < roomSize.y; y++){ \n                        if(highestStep<get_pixel(x,y).a){\n                            highestStep = get_pixel(x,y).a;\n                        }\n                    }\n                }\n                newPixel = vec4(highestStep);\n            }\n        }\n    //}\n    \n    if(iFrame==241){\n        float highestStep = get_pixel(-floor(mod(fragCoord.x,roomSize.x)),-floor(mod(fragCoord.y,roomSize.y))).a;\n        if(highestStep<step.a*10.0){\n            newPixel = vec4(0.0);\n        } else {\n            if(highestStep==currentPixel.a){\n                if(currentPixel!=rock){\n                    //newPixel = vec4(highestStep);\n                    newPixel = cg;\n                }\n            }\n        }\n    }\n    \n    \n    \n    fragColor = newPixel;\n    if(iFrame>=242){\n        if(currentPixel == cs && rp == vec4(0.0)){\n            fragColor = vec4(0.0,0.0,0.0,0.0);\n        }\n        if(fragCoord.xy==fragCoord.xy+vec2(-floor(mod(fragCoord.x,roomSize.x)),-floor(mod(fragCoord.y,roomSize.y)))){\n            \n            fragColor = rock;\n        }\n    }\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float speed = 1.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec4 oldPixel = texture(iChannel1, vec2(0.25));\n    vec4 oldMousePixel = texture(iChannel1, vec2(0.75));\n    vec4 newMousePixel = oldMousePixel;\n    vec4 newPixel = oldPixel;\n    if(fragCoord.x/iResolution.x<0.5){\n        if(oldPixel.b==0.0){ // use blue to see if change is happening\n            if(iMouse.z > 0.0){\n                newPixel.b = 1.0;\n                newPixel.g *= -1.0;\n            }\n        }\n    \n    \n        if(oldPixel.b==1.0){ // it's going to 1.0 or 0.0\n            if(oldPixel.g>0.0){\n                if(oldPixel.r<1.0){\n                    newPixel.r += oldPixel.g;\n                } else {\n                    newPixel.b = 0.0;\n                }\n            } else {\n                if(oldPixel.r>0.0){\n                    newPixel.r += oldPixel.g;\n                } else {\n                    newPixel.r = 0.0;\n                    newPixel.b = 0.0;\n                }\n            }\n        }\n    \n    \n    \n    \tfragColor = newPixel;\n    \n        if(iFrame==0){\n            fragColor = vec4(0.0,-0.01*speed,0.0,1.0);\n        }\n    } else {\n        if(oldPixel.b==0.0){ // use blue to see if change is happening\n            if(iMouse.z > 0.0){\n                if(oldPixel.r == 0.0){\n                \tnewMousePixel = vec4(iMouse.xy/iResolution.xy,0.0,1.0);\n                }\n            }\n        }\n        fragColor = vec4(newMousePixel);\n        /*if(oldPixel.r == 0.0){ // we are about to do a zoom\n            if(fragCoord.x/iResolution.x>0.5){\n            \tnewPixel.rg = iMouse.xy/iResolution.xy;\n            }\n        }*/\n    }\n    //fragColor = vec4(0.3);\n}","name":"Buf B","description":"","type":"buffer"}]}