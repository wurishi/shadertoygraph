{"ver":"0.1","info":{"id":"l3XSWn","date":"1709658578","viewed":117,"name":"Perlin Combinations Vol.2","username":"Voakie","description":"Created by simply experimenting with different combinations of perlin noise. Nyan cat was used for top right.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["noise","perlinnoise","gradient","random","hash","murmur"],"hasliked":0,"parentid":"l3sXR4","parentname":"Different Combinations of Perlin"},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 position = fragCoord / iResolution.xy * 10.0;\n    position.x *= iResolution.x / iResolution.y;\n    position += iTime * 0.25;\n    uint seed = 0x578437adU; // can be set to something else if you want a different set of random values\n\n    if (fragCoord.y < iResolution.y / 2.0) {\n        if (fragCoord.x > iResolution.x / 2.0) {\n            position /= 5.0;\n            float value = perlinNoise(position, 2, 4, seed);\n            fragColor = vec4(vec3(0.5 + cos(60.0 * value + position.x)), 1.0);\n        } else {\n            float value1 = perlinNoise(position, 2, 4, seed);\n            float value2 = perlinNoise(vec2((position.y + position.x)/10.0 + value1), 2, 4, seed);\n            value2 = abs(value2);\n            fragColor = vec4(vec3(value2), 1.0);\n        }\n    } else {\n        if (fragCoord.x > iResolution.x / 2.0) {\n            float value = perlinNoise(position, 1, 1, seed);\n            vec4 value2 = texture(iChannel0, position.yx + vec2(value, -value));\n            fragColor = vec4(vec3(value2.x), 1.0);\n        } else {\n            float value = perlinNoise(position, 1, 1, seed);\n            value = (value + 1.0) * 0.5;\n            fragColor = vec4(vec3(abs((cos(value * (10.0 + sin(iTime) * 2.0) - position.y*5.0) + cos(value * 5.0 - position.y*2.0)) * value)), 1.0);\n        }\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// stolen from https://www.shadertoy.com/view/NlSGDz\n// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a \n// single unsigned integer.\n\nuint hash(uint x, uint seed) {\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    // process input\n    uint k = x;\n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\n// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a  \n// 2-dimensional unsigned integer input vector.\n\nuint hash(uvec2 x, uint seed){\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    // process first vector element\n    uint k = x.x; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // process second vector element\n    k = x.y; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n\t// some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\n\nvec2 gradientDirection(uint hash) {\n    switch (int(hash) & 3) { // look at the last two bits to pick a gradient direction\n    case 0:\n        return vec2(1.0, 1.0);\n    case 1:\n        return vec2(-1.0, 1.0);\n    case 2:\n        return vec2(1.0, -1.0);\n    case 3:\n        return vec2(-1.0, -1.0);\n    }\n}\n\nfloat interpolate(float value1, float value2, float value3, float value4, vec2 t) {\n    return mix(mix(value1, value2, t.x), mix(value3, value4, t.x), t.y);\n}\n\nvec2 fade(vec2 t) {\n    // 6t^5 - 15t^4 + 10t^3\n\treturn t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat perlinNoise(vec2 position, uint seed) {\n    vec2 floorPosition = floor(position);\n    vec2 fractPosition = position - floorPosition;\n    uvec2 cellCoordinates = uvec2(floorPosition);\n    float value1 = dot(gradientDirection(hash(cellCoordinates, seed)), fractPosition);\n    float value2 = dot(gradientDirection(hash((cellCoordinates + uvec2(1, 0)), seed)), fractPosition - vec2(1.0, 0.0));\n    float value3 = dot(gradientDirection(hash((cellCoordinates + uvec2(0, 1)), seed)), fractPosition - vec2(0.0, 1.0));\n    float value4 = dot(gradientDirection(hash((cellCoordinates + uvec2(1, 1)), seed)), fractPosition - vec2(1.0, 1.0));\n    return interpolate(value1, value2, value3, value4, fade(fractPosition));\n}\n\nfloat perlinNoise(vec2 position, int frequency, int octaveCount, uint seed) {\n    float value = 0.0;\n    float amplitude = 1.0;\n    uint currentSeed = seed;\n    for (int i = 0; i < octaveCount; i++) {\n        currentSeed = hash(currentSeed, 0x0U); // create a new seed for each octave\n        float octaveScaling = pow(float(frequency), float(i));\n        value += perlinNoise(position * octaveScaling, currentSeed) * (amplitude / octaveScaling);\n    }\n    return value;\n}\n","name":"Common","description":"","type":"common"}]}