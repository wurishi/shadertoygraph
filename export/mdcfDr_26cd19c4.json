{"ver":"0.1","info":{"id":"mdcfDr","date":"1701249913","viewed":26,"name":"LancÃ© de rayon sur Cyl","username":"Smouvie","description":"tp","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["tp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n    Camera C;\n    vec3 vertical=vec3(0,0,1);\n    C.Obs=Obs;\n    C.View= normalize(LookAt-Obs);\n    C.Horiz= normalize(cross(vertical,C.View));\n    C.Up= normalize(cross(C.View,C.Horiz));\n    C.H = iResolution.y;\n    C.W = iResolution.x;\n    C.z = C.H/(2.*tan(aperture/360.*3.14));\n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   Ray r;\n   r.Origin = C.Obs;\n   vec3 p =C.Obs+C.z*C.View+(XY.x-C.W/2.)*C.Horiz+(XY.y-C.H/2.)*C.Up;\n   r.Dir = p-C.Obs;\n   return r;\n}\n\nstruct Lum {\n   vec3 Center;\n   float R;\n   vec3 Color;\n};\n\n// Les objets :\n\nstruct Sphere {\n   vec3 Center;\n   float R;\n   vec3 Color;\n};\n\nstruct Plan {\n    vec3 P;\n    vec3 N;\n    vec3 Color;\n};\n\nstruct Plan_Def {\n    vec3 Vec1;\n    vec3 Vec2;\n    vec3 Origin;\n    float Length1;\n    float Length2;\n    vec3 Color;\n};\n\nstruct Cube {\n    Plan_Def P;\n    float Height;\n};\n\nstruct Cylinder {\n    vec3 Origin;\n    vec3 Dir;\n    vec3 Color;\n    float R;\n    float H;\n};\n\n// Les fonctions Intersect avec Objets:\n\nbool intersect_sphere(in Ray R, in Sphere S, out float t) {\n    float a = pow(length(R.Dir),2.);\n    float b = 2.*dot(R.Dir,(R.Origin-S.Center));\n    float c = pow(length(R.Origin-S.Center),2.)-pow(S.R,2.);\n    float delta = pow(b,2.)-4.*a*c;\n    if(delta>=0.){\n        t=(-b-sqrt(delta))/(2.*a);\n        if(t<=0.){return false;};\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\nbool intersect_plan(in Ray R, in Plan P, out float t) {\n    if (dot(R.Dir,P.N)==0.) {return false;}\n    else {\n        float D = -dot(P.N,P.P);\n        float a = dot(P.N,R.Origin) + D;\n        float b = dot(R.Dir,P.N);\n        t = -a/b;\n        if (t<=0.){return false;}\n        else {return true;}\n    }\n}\n\nbool intersect_plan_def(in Ray R, in Plan_Def P, out float t) {\n    vec3 N = normalize(cross(P.Vec1,P.Vec2));\n    \n    if (dot(R.Dir,N)==0.) {return false;}\n    else {\n        float D = -dot(N,P.Origin);\n        float a = dot(N,R.Origin) + D;\n        float b = dot(R.Dir,N);\n        t = -a/b; vec3 M = R.Origin +R.Dir*t;\n        \n        vec3 P2 = P.Origin + normalize(P.Vec1)*P.Length1;\n        vec3 P3 = P.Origin + normalize(P.Vec2)*P.Length2;\n        \n        float alpha = dot(M-P.Origin,P2-P.Origin)/dot(P2-P.Origin,P2-P.Origin);\n        float beta = dot(M-P.Origin,P3-P.Origin)/dot(P3-P.Origin,P3-P.Origin);\n        \n        if (t<=0.){return false;}\n        else if (0.<=alpha && alpha<=1. && 0.<=beta && beta<=1.) {return true;}\n        else {return false;}\n    }\n}\n\nbool intersect_cube (in Ray R, in Cube C, out float t, out Plan_Def PlanSol) {\n    vec3 N = normalize(cross(C.P.Vec1,C.P.Vec2));\n    vec3 OriginBis = C.P.Vec1*C.P.Length1 + C.P.Vec2*C.P.Length2 + C.P.Origin+ C.Height*N;\n    \n    bool intercept = false; float ti;\n    \n    PlanSol.Color = C.P.Color;\n    \n    if(intersect_plan_def(R, C.P, ti)) { if(ti<t) {t=ti; PlanSol=C.P;}; intercept = true;};\n    /*\n    float tii;;\n    Plan_Def Pi; Pi.Color=C.P.Color; Pi.Origin=C.P.Origin; Pi.Vec1=C.P.Vec2; Pi.Vec2=N; Pi.Length2=C.Height; Pi.Length1=C.P.Length2;\n    if(intersect_plan_def(R, Pi, tii)) { if(tii<t) {t=tii; PlanSol=Pi;}; intercept = true;};\n    /*\n    Pi.Vec2=C.P.Vec1; Pi.Vec1=N; Pi.Length2=C.P.Length1; Pi.Length1=C.Height;\n    if(intersect_plan_def(R, Pi, ti)) { if(ti<t) {t=ti; PlanSol=Pi;}; intercept = true;};\n    \n    Pi.Origin=OriginBis; Pi.Vec1=-C.P.Vec1; Pi.Vec2=-C.P.Vec2; Pi.Length1=C.P.Length1; Pi.Length2=C.P.Length2;\n    if(intersect_plan_def(R, Pi, ti)) { if(ti<t) {t=ti; PlanSol=Pi;}; intercept = true;};\n    \n    Pi.Origin=OriginBis; Pi.Vec1=-N; Pi.Vec2=-C.P.Vec1; Pi.Length1=C.Height; Pi.Length2=C.P.Length1;\n    if(intersect_plan_def(R, Pi, ti)) { if(ti<t) {t=ti; PlanSol=Pi;}; intercept = true;};\n    \n    Pi.Origin=OriginBis; Pi.Vec1=-C.P.Vec2; Pi.Vec2=-N; Pi.Length1=C.P.Length2; Pi.Length2=C.Height;\n    if(intersect_plan_def(R, Pi, ti)) { if(ti<t) {t=ti; PlanSol=Pi;}; intercept = true;};\n    */\n    return intercept;\n}\n\nbool intersect_cyl (in Ray R, in Cylinder C, out float t) { //Attention a normaliser\n    vec3 x = R.Dir-dot(C.Dir,R.Dir)*C.Dir;\n    vec3 y = R.Origin-C.Origin-(dot((R.Origin-C.Origin),C.Dir)*C.Dir);\n    \n    float a = dot(x,x); \n    float b = 2.*dot(x,y); \n    float c = dot(y,y)-pow(C.R,2.);\n    \n    float delta = pow(b,2.)-4.*a*c;\n    float tp1; Plan P1; P1.P=C.Origin+C.Dir*C.H/2.; P1.N=C.Dir; P1.Color=C.Color;\n    float tp2; Plan P2; P2.P=C.Origin-C.Dir*C.H/2.; P2.N=-C.Dir; P2.Color=C.Color;\n    \n    if(delta>=0.){\n        float t1 = (-b-sqrt(delta))/(2.*a);\n        float t2 = (-b-sqrt(delta))/(2.*a);\n        float t=min(t1,t2);\n        if (t<=0.){t=max(t1,t2);}\n        vec3 M = R.Origin + R.Dir*t;\n        vec3 Mproj = C.Origin + C.Dir*dot(C.Dir,M-C.Origin);\n        \n        if(t<=0.){return false;};\n        if (length(Mproj-C.Origin)<C.H/2.){return true;}\n    }\n    if(intersect_plan(R,P1,tp1)){\n        if(intersect_plan(R,P2,tp2)){\n            if(length (R.Origin + R.Dir*tp2 - P2.P)<=C.R){return true;} //plan + ciruclaire\n        }\n        if(length(R.Origin + R.Dir*tp1 - P1.P)<=C.R){return true;}\n        else{return false;}\n    }\n    else if(intersect_plan(R,P2,tp2)){\n            if(length (R.Origin + R.Dir*tp2 - P2.P)<=C.R){return true;} //plan + ciruclaire\n        }\n    else{return false;};\n}\n\nbool intersect_cyl_empty (in Ray R, in Cylinder C, out float t1, out float t2) { //Attention a normaliser\n    vec3 x = R.Dir-dot(C.Dir,R.Dir)*C.Dir;\n    vec3 y = R.Origin-C.Origin-(dot((R.Origin-C.Origin),C.Dir)*C.Dir);\n    \n    float a = dot(x,x); \n    float b = 2.*dot(x,y); \n    float c = dot(y,y)-pow(C.R,2.);\n    \n    float delta = pow(b,2.)-4.*a*c;\n    bool result = false;\n    \n    if(delta>=0.){\n        t1 = (-b-sqrt(delta))/(2.*a);\n        t2 = (-b+sqrt(delta))/(2.*a);\n        if(t1>=0.){\n            vec3 M = R.Origin + R.Dir*t1;\n            vec3 Mproj = C.Origin + C.Dir*dot(C.Dir,M-C.Origin);\n            if (length(Mproj-C.Origin)<C.H/2.){result = true;}\n            else {t1 = 0.;};\n        }\n        if(t2>=0.){\n            vec3 M = R.Origin + R.Dir*t2;\n            vec3 Mproj = C.Origin + C.Dir*dot(C.Dir,M-C.Origin);\n            if (length(Mproj-C.Origin)<C.H/2.){result = true;}  \n            else {t2 = 0.;};\n        }\n    }\n    return result;\n}\n\n// Les fonctions Interact avec Objets et Lum:\n\nbool is_shadow_plan(in Lum L, in Sphere[1] ListSphere, in vec3 M) {\n    int i;\n    float t;\n    Ray R; R.Origin = M; R.Dir = L.Center - M;\n    for(i=0; i<ListSphere.length(); i++){\n        if (intersect_sphere(R,ListSphere[i],t)) {\n            if (0.0001<t && t<1.){return true;}\n        }\n    }\n    return false;\n}\n\nvec3 interact_lum_plan(in Lum[1] ListLum, in Plan P, in Sphere[1] ListSphere, in vec3 M) {\n    vec3 col;\n    int i;\n    for(i=0; i<ListLum.length(); i++){\n        Lum L = ListLum[i];\n        vec3 d = normalize(L.Center - M);\n        vec3 n = normalize(P.N);\n        float cosTheta = dot(n,d);\n        if (cosTheta<0.) {cosTheta=0.;};\n        if ((is_shadow_plan(L,ListSphere,M))) {cosTheta=0.;};\n        col = col + P.Color*L.Color*cosTheta;\n    }\n    return col;\n}\n\nvec3 interact_lum_plan_def(in Lum[1] ListLum, in Plan_Def P, in vec3 M) {\n    vec3 col;\n    int i; \n    for(i=0; i<ListLum.length(); i++){\n        Lum L = ListLum[i];\n        vec3 d = normalize(L.Center - M);\n        vec3 n = normalize(cross(P.Vec1,P.Vec2));\n        //if (length (n) <=1.001 && length(n)>= 0.999) {col=vec3(1,0,1);};\n        float cosTheta = dot(n,d);\n        if (cosTheta<=0.) {cosTheta=0.; col = vec3(1,1,0);};\n        if (cosTheta>=0.) {col = vec3(0.,1.,0.);};\n        col = col + P.Color*L.Color*cosTheta;\n    }\n    return col;\n}\n\nvec3 interact_lum_sphere(in Lum[1] ListLum, in Sphere S, in vec3 M) {\n    vec3 col;\n    int i;\n    for(i=0; i<ListLum.length(); i++){\n        Lum L = ListLum[i];\n        vec3 d = normalize(L.Center - M);\n        vec3 n = normalize(M - S.Center);\n        float cosTheta = dot(n,d);\n        if (cosTheta<0.) {cosTheta=0.;};\n        col = col + S.Color*L.Color*cosTheta;\n    }\n    return col;\n}\n\nvec3 interact_lum_cyl_empty_ext(in Lum[1] ListLum, in Cylinder C, in vec3 M) {\n    vec3 col;\n    int i;\n    for(i=0; i<ListLum.length(); i++){\n        Lum L = ListLum[i];\n        vec3 Mproj = C.Origin + C.Dir*dot(C.Dir,M-C.Origin);\n        \n        vec3 d = normalize(L.Center - M);\n        vec3 n = normalize(M - Mproj);\n\n        float cosTheta = dot(n,d);\n        if (cosTheta<0.) {cosTheta=0.;};\n        col = col + C.Color*L.Color*cosTheta;\n    }\n    return col;\n}\n\nvec3 interact_lum_cyl_empty_int(in Lum[1] ListLum, in Cylinder C, in vec3 M) {\n    vec3 col;\n    int i;\n    for(i=0; i<ListLum.length(); i++){\n        Lum L = ListLum[i];\n        vec3 Mproj = C.Origin + C.Dir*dot(C.Dir,M-C.Origin);\n        \n        vec3 d = normalize(L.Center - M);\n        vec3 n = -normalize(M - Mproj);\n\n        // Verifie que pas d'intersection du premier bord\n        Ray R; R.Origin = L.Center; R.Dir = -d;\n        float t1; float t2;\n        float cosTheta = dot(n,d);\n        \n        bool doublinter = intersect_cyl_empty (R, C, t1, t2);\n        if (t1>0. && t2>0.) {cosTheta=0.;};\n        if (cosTheta<0.) {cosTheta=0.;};\n        col = col + C.Color*L.Color*cosTheta;\n    }\n    return col;\n}\n\nvec3 print_color_sphere(in Lum[1] ListLum, in Sphere[1] ListSphere, in Ray R, in Camera C) {\n    vec3 col;\n    int i;\n    float ti; float t; bool intercept = false;\n    int nbBoule;\n    for(i=0; i<ListSphere.length(); i++){\n        if (intersect_sphere(R, ListSphere[i], ti)){\n            if (ti<t || intercept ==false){\n                t=ti; nbBoule=i; intercept =true;\n            }\n        }\n    }\n    vec3 M = C.Obs +R.Dir*t;\n    if(nbBoule == 1){col=interact_lum_sphere(ListLum, ListSphere[nbBoule], M);}\n    else {col = ListSphere[nbBoule].Color;};\n    return col;\n}\n\nvec3 print_color_cyl(in Cylinder Cyl, in Lum[1] ListLum, in Sphere[1] ListSphere, in Plan[1] ListPlan, in Ray R, in Camera C) {\n    vec3 col; vec3 M;\n    float t1; float t2;\n    bool i = intersect_cyl_empty (R, Cyl, t1, t2);\n    if (t1 > 0.) {\n        M = C.Obs +R.Dir*t1;\n        col=interact_lum_cyl_empty_ext(ListLum, Cyl, M);\n    }\n    else if (t2 > 0.) {\n            M = C.Obs +R.Dir*t2;\n            col=interact_lum_cyl_empty_int(ListLum, Cyl, M);\n    };\n    \n    return col;\n}\n\n// Affichage de l'image\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec3 col = vec3(0.9,0.9,0.9);\n    fragColor = vec4(col,1.0);\n    \n    //float l_squared = pow(fragCoord.x,2.)+pow(fragCoord.y,2.);\n \n    Camera C = camera(vec3(.5, 1.0, -2.), vec3(0.5, 0.5, 0.5), 50.0); \n    \n    \n    Sphere Boule; Boule.Center=vec3(0.5,0.5,0.5); Boule.R=0.45;\n    Boule.Color=vec3(1,1,1);\n\n    float Dist = 1.;\n    \n    Lum L1; L1.Center=vec3(5.*sin(iTime), 2., 5.*cos(iTime));\n    L1.R=0.1; L1.Color=vec3(1,1,1);\n    Sphere Sol1; Sol1.Center=L1.Center; Sol1.R=L1.R; Sol1.Color = L1.Color;\n    Sphere B; B.Center=vec3(100., 100., 100.); Sol1.R=L1.R; Sol1.Color = L1.Color;\n    \n    \n    Cylinder Cyl; Cyl.Origin=vec3(0.5,0.5,1.); Cyl.Dir=normalize(vec3(sin(0.2*iTime),0.,cos(0.2*iTime))); Cyl.R = 0.5; Cyl.H=3.; Cyl.Color=vec3(0.0,0.7,0.7);\n    float tCyl1; float tCyl2;\n    \n    Plan P; P.P=vec3(0.,0.,0.); P.N=normalize(vec3(1.,1.,0.)); P.Color=vec3(1,0.5,0); float tp; float tCyl;\n    \n    Plan_Def P_def; P_def.Color = vec3(0.8,0,0); P_def.Origin=vec3(0.,0.,0.);\n    P_def.Vec1=normalize(vec3(0.,1.,0.)); P_def.Vec2=normalize(vec3(1.,0.,0.));\n    P_def.Length1=2.; P_def.Length2=0.5;\n    \n    Cube Cube1; Cube1.Height=0.3; Cube1.P=P_def;\n    \n    Plan ListPlan[1] = Plan[1] (P);\n    Lum ListLum[1] = Lum[1] (L1);\n    Sphere ListSphere[1] = Sphere[1] (Sol1);\n    \n    Ray R = launch(C,fragCoord);\n    \n    /*\n    if (intersect_plan(R,P,tp)) {\n        vec3 Mp = C.Obs +R.Dir*tp;\n        col = interact_lum_plan(ListLum, P, Sphere[1] (B), Mp);\n    }\n    */\n    \n    /*\n    Plan_Def Ptest; float tp2;\n    if (intersect_cube(R,Cube1, tp2, Ptest)) {\n        vec3 Mcube = C.Obs +R.Dir*tp2;\n        col = interact_lum_plan_def(ListLum, Ptest, Mcube);\n    }\n    \n    */\n    if (intersect_sphere(R,Sol1,tp)) {\n        vec3 Mp = C.Obs +R.Dir*tp;\n        col = Sol1.Color;\n    }\n    \n    if (intersect_cyl_empty(R,Cyl,tCyl1,tCyl2)) {\n        //vec3 Mc = C.Obs +R.Dir*tCyl;\n        col = print_color_cyl(Cyl, ListLum, ListSphere, ListPlan, R, C);\n    }\n    \n\n    \n    fragColor = vec4(col,1.0);\n\n    \n}\n","name":"Image","description":"","type":"image"}]}