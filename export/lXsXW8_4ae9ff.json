{"ver":"0.1","info":{"id":"lXsXW8","date":"1710360914","viewed":38,"name":"Acerola Jam Twisted Snow","username":"Hyeve","description":"The base visual for the in-game background of Dreality, a tiny puzzle game I made for the Acerola Jam 0.\nPlay it online here! https://hyeve.itch.io/dreality","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarching","transparency","reflections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 CHROMA_OFFSET = vec4(0.0);\n\nvec4 read(vec2 uv) {\n    float r = texture(iChannel0, uv + CHROMA_OFFSET.xy).x;\n    float g = texture(iChannel0, uv).y;\n    float b = texture(iChannel0, uv + CHROMA_OFFSET.zw).z;\n    return vec4(r, g, b, 1.0);\n}\n\nvec4 fxaa(vec2 frag) {\n    //Manually minified FXAA antialiasing\n    \n    const float CONTRAST_THRESHOLD = 0.05;\n    const float RELATIVE_CONTRAST_THRESHOLD = 0.5;\n    const float OFFSETS[10] = float[10]( 1., 1., 1., 1.5, 2., 2., 2., 3., 4., 5. );\n    \n    #define re(x) read((x)/iResolution.xy)\n    #define lu(x) (x.r*.2126+x.g*.7152+x.b*.0722)\n    #define rl(x) lu(re((x)))\n    #define r(x, y) rl(frag+vec2(x,y))\n    \n    float M = r(0,0),N =r(0,1),NE=r(1,1),E =r(1,0),SE=r(1,-1),S =r(0,-1),SW=r(-1,-1),W =r(-1,0),NW=r(-1,1),\n    LC=min(N,min(E,min(S,min(W,M)))),HC=max(N, max(E, max(S, max(W, M)))),CT=HC-LC;\n    if(CT<max(CONTRAST_THRESHOLD,RELATIVE_CONTRAST_THRESHOLD*HC)) return re(frag);\n    \n    float LA = smoothstep(0.,1.,clamp(0.,1., abs((2.*(N+E+S+W)+NE+NW+SE+SW)*(1./12.)-M)/CT));\n\tbool IH = abs(N+S-2.*M)*2.+abs(NE+SE-2.*E)+abs(NW+SW-2.*W)>abs(E+W-2.*M)*2.+abs(NE+NW-2.*N)+abs(SE+SW-2.*S);\n    \n    float PL=IH?N:E,NL=IH?S:W,PG=abs(PL-M),NG=abs(NL-M),DR=1.,GR,OL;\n\n    OL=PL;GR=PG;\n\tif (PG<NG) {DR=-1.0;OL=NL;GR=NG;}\n\n    vec2 EF=frag,ES=vec2(0,1);EF.x+=.5*DR;\n    if(IH){EF.y+=.5*DR;ES=vec2(1,0);}\n    \n    float EL=(M+OL)*.5,GT=GR*.25;\n\tvec2 PF=EF+ES,NF=EF-ES,FO=vec2(0.);\n\tfloat PLD=rl(PF)-EL,NLD=rl(NF)-EL;\n\tbool PE=abs(PLD)>=GT,NED=abs(NLD)>=GT;\n    int i;\n    for(i=0;i<10&&!PE;i++){PF+=ES*OFFSETS[i];PLD=rl(PF)-EL;PE=abs(PLD)>=GT;}\n    for(i=0;i<10&&!NED;i++){NF-=ES*OFFSETS[i];NLD=rl(NF)-EL;NED=abs(NLD)>=GT;}\n    \n    float PD=PF.y-frag.y,ND=frag.y-NF.y,MD,EB=0.,BL;\n\tif(IH){PD=PF.x-frag.x;ND=frag.x-NF.x;}\n    MD=min(PD,ND);\n    bool DS=PD<=ND?PLD>=0.:NLD>=0.;\n\tif(DS!=(M-EL>=0.))EB=0.5-MD/(PD+ND);\n    BL=max(LA*LA,EB)*DR;\n\n\tif(IH)FO.y+=BL;\n\telse FO.x+=BL;\n    \n    return re(frag+FO);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    CHROMA_OFFSET = vec4(-1, -1, -1, 1) * 0.;\n    fragColor = fxaa(fragCoord);\n    //fragColor = read(fragCoord / iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float TIME; //Global time, usually modulo'd to loop ever few minutes\nbool LIGHTING_PASS = false; //True while doing lighting effects\n\n//--------- GENERAL CONSTANTS ---------\nconst float FPS_MULTIPLIER = 1.0; //Decrease this if you need the performance\nconst float SPEED_MULTIPLIER = 1.0; //Mess with how fast the shader time runs!\n                                    \nconst float MAX_SCENE_DEPTH = 128.; //Minor performance impact\nconst int MAX_SCENE_STEPS = 256; //Medium performance impact\nconst int MAX_SURFACES = 20; //Major performance impact with transparent/reflective surfaces\nconst float MAX_SHADOW_DIST = 64.; //Minor performance impact if shadows are used\nconst int MAX_SHADOW_STEPS = 64; //Medium performance impact if shadows are used\nconst float HIT_DIST = 1e-4; //Minor-Medium performace impact (dependent on geometry)\n\nconst float OFFSET_DIST = HIT_DIST * 2.; //For transparent object surfaces and normal calculations\nconst float SKIP_DIST = OFFSET_DIST * 3.; //For rays passing through transparent surfaces\n\nconst float VIGNETTE_STRENGTH = 0.8;\nconst float VIGNETTE_POWER = 5.;\n\nconst float GAMMA = 1.;\n//--------- ----------------- ---------\n\n\n\n//--------- LIGHTING PARAMATERS ---------\nvec3 LIGHT_POS = vec3(0, 0, -100);\nvec3 LIGHT_COLOR = vec3(1.0, 1.0, 1.0);\nfloat LIGHT_BRIGHTNESS = 1.;\n\nvec3 AMBIENT_COLOR = vec3(1.0, 1.0, 1.0);\nfloat AMBIENT_BRIGHTNESS = 0.3;\n\nfloat FOG_ONSET = 100.;\nfloat FOG_SMOOTH = 28.;\nfloat FOG_POWER = 1.8;\n\nfloat AO_DIST = 12.;\nfloat AO_POWER = 0.2;\n\nfloat SHADOW_SOFTNESS = 0.05;\nfloat SHADOW_STRENGTH = 0.0;\n\nfloat SUBSURF_DIST = 4.;\nfloat SUBSURF_BRIGHTNESS = 0.9;\n\nfloat UMBRA_POINT = 0.5;\nfloat UMBRA_CONTRAST = 1.;\n\nint SURFACE_SKIPS = 1; //Skips rendering surfaces after passing into a transparent object - fakes backface culling.\n//--------- --------- --------- ---------\n\n\n\n//--------- MISC PARAMETERS ---------\nvec4 TONEMAP_VALUES = vec4(1., 1., 0., 999.); //Contrast, brightness, lift, quantization steps.\nvec4 TONEMAP_HUESAT = vec4(1.5, 0., 1.3, 0.5); //Controls hue and sat shifting based on brightness.\n\nvec3 GLOW = vec3(0.); //For raymarching-accumulated fake glow.\n//--------- --------------- ---------\n\n\n\n//--------- SURFACE PARAMATERS ---------\nvec3 COLOR = vec3(1.);\nfloat GLOSS = 1.;\nfloat SPECULAR = 1.;\nfloat OPACITY = 1.; //Opacity must be < 1 for refraction or reflection to have any effect.\nfloat REFRACTION = 1.05; //Refraction < 0 results in reflection instead.\nfloat BACKGROUND_REFLECTION = 0.1; //Blurry reflections of background only\nvec3 NORMAL_ROTATIONS = vec3(0.0); //Normal mapping effect\nfloat MATERIAL_ID = -1.0;\n//--------- ------------------ ---------\n\n\n\n\n\n//--------- SCENE CONTROL FUNCTIONS ---------\nfloat scene(vec3 pos)\n{\t\t   \n    vec3 opos = pos;\n    \n    pos = rotate(pos, vec3(0.,0.05*TIME,0.));\n    float xm = cos(pos.x * 0.2 + TIME * 0.1);\n    float zm = sin(pos.z * 0.1 + xm * 0.5 + TIME * 0.1);\n    vec3 ground_nmap = vec3(zm * 0.3, 0., 0.);\n   \n    NORMAL_ROTATIONS = ground_nmap;\n   \n    float scene_dist = pos.y + 2.;\n\n\n    for(float i = 0.; i < 12.; i++) {\n        pos.xy = abs(pos.xy) - i * 2.1;\n        pos = rotate(pos, vec3(cos(i), TIME*0.01, sin(i)));\n        scene_dist = smooth_min(scene_dist, sdf_box(pos, vec3(i*0.7))-0., 2.);\n    }\n\n\n    scene_dist = max(scene_dist, -opos.z - 7.);\n\n    GLOW += exp(-scene_dist * 0.3) * vec3(0., 0.8, 1.) * 0.005;\n    \n    \n    if(OPACITY < 1.) scene_dist = abs(scene_dist) - OFFSET_DIST;\n\n\treturn scene_dist;\n}\n\nvec3 background(vec3 dir, float blur) {\n    float y = -dir.y;\n    \n    y += pow(abs(dir.x) * 1., 2.5);\n    float yal = y;\n    \n   \n    \n    vec2 vn1 = vec2(TIME, cos(TIME * 0.2));\n    vec2 vn2 = vec2(TIME, sin(TIME * 0.2));\n    vec2 vn3 = vec2(TIME, cos(TIME * 0.1));\n    \n    float sn1 = hash(floor(dir.xy * 20. + vn1 + 3.189273));\n    float sn2 = hash(floor(dir.xy * 30. + vn2 + 1.213807));\n    float sn3 = hash(floor(dir.xy * 40. + vn3 + 7.987615));\n    \n    vec2 g1 = mod(dir.xy * 20. + vn1, 1.) - 0.5;\n    float s1 = step(0.7, 1.0 - length(g1) * 3.);\n\n    vec2 g2 = mod(dir.xy * 30. + vn2, 1.) - 0.5;\n    float s2 = step(0.7, 1.0 - length(g2) * 3.);\n\n    vec2 g3 = mod(dir.xy * 40. + vn3, 1.) - 0.5;\n    float s3 = step(0.7, 1.0 - length(g3) * 3.);\n    \n    float starfield = (s1 * step(0.9, sn1)) + (s2 * step(0.9, sn2)) + (s3 * step(0.9, sn3));\n    vec3 base = vec3(0., 0., 0.3);\n    \n    vec3 starbg = mix(base, vec3(1.), starfield);\n   \n    return starbg;\n}\n\nvec3 camera_path() {\n    return vec3(0, 0, -10);\n}\n\nvec3 camera_look(vec2 uv) {\n    return normalize(vec3(uv, 1));\n}\n\nvec2 uv(vec2 frag, vec2 res) {\n    return centered_uv(frag, res);\n}\n//--------- ----------------------- ---------\n\n\n\n\n//--------- RENDERING FUNCTIONS ---------\nvec2 raymarch(vec3 ray_origin, vec3 ray_dir, float surf_dist, float max_dist, int max_steps) {\n    float current_dist = 0.;\n    float min_dist = max_dist;\n    \n    for(int i = 0; i < max_steps; i++) {\n        float scene_dist = scene(ray_origin + ray_dir * current_dist);\n        current_dist += scene_dist;\n\n        if(scene_dist < min_dist && current_dist < max_dist) min_dist = scene_dist;\n        if(scene_dist < surf_dist || scene_dist > max_dist) break;\n    }\n\n    return vec2(current_dist, min_dist);\n}\n  \nvec4 calc_lighting(vec3 hit_pos, vec3 normal, vec3 mapped_normal, vec3 ray_dir, float total_dist)\n{\n    vec3 background_col = background(ray_dir, 0.0);\n    \n    if(total_dist > MAX_SCENE_DEPTH) {\n        vec3 result = background_col + GLOW;\n        result *= max(max(result.r, max(result.g, result.b)), 1.);\n        return vec4(result, 1.);\n    }\n  \n    vec3 light_dir = normalize(LIGHT_POS - hit_pos);\n    vec3 reflection_dir = reflect(ray_dir, mapped_normal);\n\n    float diffuse = dot(mapped_normal, light_dir);\n    if(diffuse > 0.) diffuse = UMBRA_POINT + pow(diffuse, 1.0 - UMBRA_CONTRAST) * (1. - UMBRA_POINT);\n    else diffuse = UMBRA_POINT - pow(abs(diffuse), 1.0 + UMBRA_CONTRAST) * UMBRA_POINT;\n    diffuse = max(diffuse * LIGHT_BRIGHTNESS, AMBIENT_BRIGHTNESS);\n    \n    vec3 diffuse_color = COLOR;\n    vec3 light_color = mix(AMBIENT_COLOR, LIGHT_COLOR, diffuse);\n   \n    float reflected_diffuse = dot(reflection_dir, light_dir) * 0.5 + 0.5;\n    diffuse += pow(reflected_diffuse,  1.0 + SPECULAR * 50.) * SPECULAR; \n\n    vec3 background_reflection = background(reflection_dir, 1.0 - BACKGROUND_REFLECTION);\n    diffuse_color = mix(diffuse_color, background_reflection * COLOR, BACKGROUND_REFLECTION);\n    \n    float glossiness = (dot(ray_dir, mapped_normal) * 0.5 + 0.5) * GLOSS;\n    vec3 gloss_color = background(reflection_dir, 1.0 - glossiness) * 2.0;\n    diffuse_color = mix(diffuse_color, gloss_color, glossiness);\n    \n\n    //does not work (properly) on transparent objects\n    if(SUBSURF_BRIGHTNESS > 0.) {\n        float subsurf_level = pow(max(scene(hit_pos + light_dir * SUBSURF_DIST) / SUBSURF_DIST, 0.), 1.5);\n        diffuse = max(diffuse, subsurf_level * SUBSURF_BRIGHTNESS);\n    }\n\n\n    if(AO_POWER > 0.) {\n        float occlusion = raymarch(hit_pos + normal * 0.005, normal, 1e-3, AO_DIST, 12).x;            \n        diffuse *= pow(clamp(occlusion / AO_DIST, 1e-5, 1.), AO_POWER);\n    }\n\n    if(SHADOW_STRENGTH > 0.) {\n       float min_dist = raymarch(hit_pos + normal * SHADOW_SOFTNESS, light_dir, 1e-3, MAX_SHADOW_DIST, MAX_SHADOW_STEPS).y;\n       float occlusion = clamp(min_dist / SHADOW_SOFTNESS, 0.0, 1.);\n       diffuse *= occlusion * SHADOW_STRENGTH + (1.0 - SHADOW_STRENGTH);\n    }\n    \n\n    vec3 result = recolor(diffuse_color, diffuse, light_color, TONEMAP_HUESAT, TONEMAP_VALUES);\n\n    result += GLOW;\n    result *= max(max(result.r, max(result.g, result.b)), 1.);\n    \n    float fog = pow(min(max(total_dist - FOG_ONSET, 0.0) * (1.0 / FOG_SMOOTH), 1.0), FOG_POWER);\n    result = mix(result, background_col, fog); \n    \n    return vec4(result, OPACITY);\n}\n\nvec3 calc_normal(vec3 pos) {\n    mat3 k = mat3(pos, pos, pos) - mat3(OFFSET_DIST);\n    return normalize(scene(pos) - vec3(scene(k[0]), scene(k[1]), scene(k[2])));\n}\n\nvec4 render(vec2 frag, vec2 res, float real_time)\n{\n    TIME = mod(real_time + 20., 500.);\n    \n    vec2 uv = uv(frag, res);\n    vec3 ray_origin = camera_path();\n    vec3 ray_dir = camera_look(uv);\n    \n    int skip_count = 0;\n    float total_dist = 0.;\n    vec4 final_color = vec4(0);\n    \n    vec3 first_surface_normal;\n    float first_surface_depth;\n    float first_surface_id = -1.0;\n    \n    for(int i = 0; i < MAX_SURFACES; i++)\n    {\n        float dist = raymarch(ray_origin, ray_dir, HIT_DIST, MAX_SCENE_DEPTH, MAX_SCENE_STEPS).x;\n        vec3 hit_pos = ray_origin + ray_dir * dist;\n        total_dist += dist;\n \n        \n        vec3 normal = calc_normal(hit_pos);\n        \n        if(i == 0 && total_dist < MAX_SCENE_DEPTH) {\n            first_surface_depth = dist;\n            first_surface_normal = normal;\n            first_surface_id = MATERIAL_ID;\n        }\n        \n        vec3 mapped_normal = rotate(normal, NORMAL_ROTATIONS);\n        mapped_normal = dot(mapped_normal, -ray_dir) > 0. ? mapped_normal : reflect(mapped_normal, ray_dir);\n        \n        \n        float refraction = i % 2 == 0 ? 1. / REFRACTION : REFRACTION;\n        vec3 new_ray = refract(ray_dir, mapped_normal, refraction);\n        if(REFRACTION < 0. || length(new_ray) == 0.) new_ray = reflect(ray_dir, mapped_normal);\n       \n        LIGHTING_PASS = true;\n        vec4 color = calc_lighting(hit_pos, normal, mapped_normal, ray_dir, total_dist);\n        LIGHTING_PASS = false;\n        \n        ray_origin = hit_pos - normal * (REFRACTION < 0. ? -SKIP_DIST : SKIP_DIST);\n        ray_dir = new_ray;\n    \n\t  \tif(skip_count < 1) final_color += vec4(color.rgb * color.a, color.a) * (1. - final_color.a);\n\t  \tif(final_color.a >= 1.) break;\n        \n        skip_count = skip_count == 0 ? REFRACTION < 0. ? 0 : SURFACE_SKIPS : skip_count - 1;\n    }\n    \n    \n    final_color /= final_color.a; //Fix any < 1. alphas\n\t \n    if(VIGNETTE_STRENGTH > 0.) final_color *= 1. - pow(length(uv), VIGNETTE_POWER) * VIGNETTE_STRENGTH;\n    \n    vec3 color = clamp(pow(final_color, vec4(1.0 / GAMMA)).rgb, vec3(5e-2), vec3(3.95));\n    \n    float packed_color = pack3(color, 4.0);\n    float packed_normal = pack_normal(first_surface_normal);\n    \n    if(first_surface_depth > MAX_SCENE_DEPTH) first_surface_depth = MAX_SCENE_DEPTH;\n    \n    return vec4(packed_color, packed_normal, first_surface_depth, first_surface_id);\n}\n//--------- ------------------- ---------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(mod(float(iFrame), 1.0 / FPS_MULTIPLIER) < 1. || iFrame < 5) {\n        vec4 data = render(fragCoord.xy, iResolution.xy, iTime * SPEED_MULTIPLIER);\n        fragColor = data;\n    }   \n    else fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//Consts\n\n#define PI 3.1415926535\n#define TAU (PI * 2.0)\n#define DEGS_TO_RADS 0.01745329\n\n#define AUDIO_RATE 22050.0\n#define AUDIO_VOL -1.\n\n//\"Generic\" functions\n\n//Rotation matrix for an angle in radians\n#define angle(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\n//Min by X component - for combined distance/ID sdfs\n#define vector_min(a, b) (a.x < b.x ? a : b)\n\n//Splits a value into hard-edge segments. B = steps per 1 unit\n#define quantize(value, steps) (floor((value)*(steps))/(steps))\n\n//Repeats a range with a given spacing a particular number of times\n#define repeat(value, space, min, max) (value - space*clamp(round(value / space), -min, max))\n\n//Repeats a range with a given spacing an infinite number of times\n#define repeat_inf(value, space) (value - space*round(value / space))\n\n//Maths\nuint to_bits(float value, uint range, int offset) {\n    return uint(value * float(range)) << offset;\n}\n\nfloat from_bits(uint bits, uint range, int offset) {\n    return float((bits >> offset) & range) * (1./float(range)); //Avoid division by zero\n}\n\nfloat pack4(vec4 value, float value_max)\n{\n    return uintBitsToFloat(\n      to_bits(value.x / value_max, 255u, 0) \n    | to_bits(value.y / value_max, 255u, 8) \n    | to_bits(value.z / value_max, 255u, 16) \n    | to_bits(value.w / value_max, 255u, 24)\n    );\n}\n\nvec4 unpack4(float value, float value_max)\n{\n    uint packed = floatBitsToUint(value);\n    return vec4(\n    from_bits(packed, 255u, 0) * value_max, \n    from_bits(packed, 255u, 8) * value_max, \n    from_bits(packed, 255u, 16) * value_max, \n    from_bits(packed, 255u, 24) * value_max\n    );\n}\n\nfloat pack3(vec3 value, float value_max)\n{\n    return uintBitsToFloat(\n      to_bits(value.x / value_max, 1023u, 0) \n    | to_bits(value.y / value_max, 1023u, 10) \n    | to_bits(value.z / value_max, 1023u, 20)\n    );\n}\n\nvec3 unpack3(float value, float value_max)\n{\n    uint packed = floatBitsToUint(value);\n    return vec3(\n    from_bits(packed, 1023u, 0) * value_max, \n    from_bits(packed, 1023u, 10) * value_max, \n    from_bits(packed, 1023u, 20) * value_max\n    );\n}\n\n\n\nfloat pack_normal(vec3 value)\n{\n    value = value * 0.5 + 0.5; \n    uint sign_bit = uint(sign(value.z + 1e-5) < 0. ? 0u : 1u) << 30;\n    return uintBitsToFloat(to_bits(value.x, 0x7fffu, 0) | to_bits(value.y, 0x7fffu, 15) | sign_bit);\n}\n\nvec3 unpack_normal(float value)\n{\n    uint packed = floatBitsToUint(value);\n    uint sign_bit = (packed >> 30) & 0x7fffu;\n    vec3 result = vec3(from_bits(packed, 0x7fffu, 0), from_bits(packed, 0x7fffu, 15), 0.) * 2. - 1.;\n    result.z = sqrt(1.0 - min(dot(result.xy, result.xy), 1.0)) * (sign_bit == 0u ? 1.0 : -1.0);\n    return result;\n}\n\nvec2 sample_audio(sampler2D audio, float x) {\n\n  float idx = 55.0 / AUDIO_RATE * 0.5 * pow(2.0, x);\n\n  if (x < 0. || idx > 1.0) return vec2(0);\n  \n  float fft = texture(audio, vec2(idx, 0)).x;\n  \n  fft *= 2.0 * log(1.0 + x);\n  fft += AUDIO_VOL;\n  fft = max(0.0, fft);\n  fft *= 1.0 + idx;\n  \n  return vec2(fft); //Shadertoy only provides mono audio :(\n}\n\nvec2 centered_uv(vec2 frag, vec2 res) {\n    return vec2(frag.xy - .5 * res.xy) / res.y;\n}\n\nfloat hash(float value) {\n    return fract(sin((value) * 12.9898) * 43758.5453123);\n}\n\nfloat hash(vec2 value) {\n    return fract(sin(dot(value,vec2(127.1,311.7)))*43758.545);\n}\n\nfloat hash(vec3 value) {\n    return hash(value.xz*value.zy);\n}\n\nfloat noise(float value) {\n    float i = floor(value), f = fract(value);\n    return mix(hash(i - 0.5), hash(i + 0.5), f);\n}\n\nfloat noise(vec2 value) {\n    vec2 i = floor(value), f = fract(value);\n  \n    float S = 0.098157123;\n  \n    float tl = hash(i + vec2(-0.5, -0.5) + S);\n    float tr = hash(i + vec2(0.5, -0.5) + S);\n    float bl = hash(i + vec2(-0.5, 0.5) + S);\n    float br = hash(i + vec2(0.5, 0.5) + S);\n  \n    float t = mix(tl, tr, f.x);\n    float b = mix(bl, br, f.x);\n    float v = mix(t, b, f.y);\n  \n    return v;\n}\n\n//\"Sharpens\" a 0-1 value by powing both ends\nfloat sharpen(float value, float scale) {\n    return 1.-pow(1.-pow(value, scale), scale * 2.);\n}\n\nfloat fbm_sine(float pos, float intensity, int iters, float offset)\n{    \n    vec2 g = vec2(2, exp2(-intensity));\n\tvec3 f = vec3(1, 1, 0);\n\tpos -= offset * .5;\n    for(int i = 0; i < iters; i++) {\n        f = vec3(f.xy * g, f.z + f.y * sin(f.x * pos + offset));\n    }\n    return f.z;\n}\n\nfloat wave_saw(float value) {\n    return mod(value, 2.);\n}\n\n//Is this a good way to calculate a triangle wave? No idea, but it works, so...\nfloat wave_tri(float value) {\n    return wave_saw(value*sign(mod(value, 2.)-1.)) - 1.5; \n}\n\n\nvec3 rotate(vec3 a, vec3 r) {\n    a.zy *= angle(r.x);\n    a.xz *= angle(r.y);\n    a.yx *= angle(r.z);\n    return a;\n}\n\nfloat luma(vec3 col) {\n    return col.r * 0.2126 + col.g * 0.7152 + col.b * 0.0722;\n}\n\nvec3 normalize_luma(vec3 col) {\n    return col / luma(col);\n}\n\nvec3 rgb_to_hsv(vec3 col) {\n    vec4 k = vec4(0., -1./3., 2./3., -1.),\n    p = mix(vec4(col.bg, k.wz), vec4(col.gb, k.xy), step(col.b, col.g)),\n    q = mix(vec4(p.xyw, col.r), vec4(col.r, p.yzx), step(p.x, col.r));\n    \n    float d = q.x - min(q.w, q.y);\n    \n    return vec3(abs(q.z + (q.w - q.y) / (6. * d)), d / (q.x), q.x);\n}\n\n\nvec3 hsv_to_rgb(vec3 col) {\n    vec4 k = vec4(1., 2./3., 1./3., 3.);\n    vec3 p = abs(fract(col.xxx + k.xyz) * 6. - k.www);\n    return col.z * mix(k.xxx, clamp(p - k.xxx, 0., 1.), col.y);\n}\n\nvec2 to_radial(vec2 xy) {\n    return vec2(length(xy), atan(xy.x,xy.y));\n}\n\nvec2 from_radial(vec2 ra) {\n    return vec2(sin(ra.y), cos(ra.y)) * ra.x;\n}\n\n\n//My tonemapping function. Does a pass through HSV and back to adjust hue, sat, & value\n\n//Hue/Sat params:\n//XY = Hue shift by value, X = exponent, Y = strength\n//ZW = Sat shift by value, Z = exponent, W = strength\n\n//Value params:\n//X = Contrast (value exponent)\n//Y = Intensity (value multiplier)\n//Z = Brightness (value gain)\n//W = Quantization (Number of colour steps)\n\nvec3 recolor(vec3 base_color, float diffuse, vec3 light_color, vec4 hs_params, vec4 v_params) {\n\n  vec3 base_hsv = rgb_to_hsv(base_color);\n  vec3 tinted_hsv = rgb_to_hsv(base_color * light_color);\n  \n  \n  float value = quantize(pow(max(diffuse * base_hsv.z  +v_params.z, 0.),v_params.x)*v_params.y,v_params.w);\n \n  \n  float hueShiftLow = pow(max(0.5 - value * 0.5,0.), hs_params.x);\n  float hueShiftHigh = -pow(max(value * 0.5 - 0.5, 0.), hs_params.x);\n  float hueShiftDir = mix(-1., mix(1., -1., smoothstep(0.69, 0.75, base_hsv.x)), smoothstep(0.19, 0.24, base_hsv.x));\n  float hueShift = (hueShiftLow + hueShiftHigh) * hs_params.y * hueShiftDir;\n  \n  \n  \n  float hue = tinted_hsv.x + hueShift;\n\n  \n  float satShift = pow(max(0.5 - value * 0.5, 0.), hs_params.z) * hs_params.w;\n  float sat = tinted_hsv.y + satShift * step(1e-3, tinted_hsv.y);\n  \n\n  return hsv_to_rgb(vec3(hue,sat,value));\n  \n}\n\nvec3 bezier(vec3 a, vec3 b, vec3 c, float v) {\n    return mix(mix(a, b, v), mix(b, c, v), v);\n}\n\nvec3 bezier(vec3 a, vec3 b, vec3 c, vec3 d, float v) {\n    return mix(bezier(a, b, c, v),bezier(b, c, d, v), v);\n}\n\nvec3 bezier(vec3 a, vec3 b, vec3 c, vec3 d, vec3 e, float v) {\n    return mix(bezier(a, b, c, d, v),bezier(b, c, d, e, v), v);\n}\n\n\n//Custom refraction that ignores total internal reflection\n//Not at all physically realistic, but (sometimes) looks better for shaders.\nvec3 refract_abs(vec3 incident, vec3 normal, float refraction) {\n   float ndi = dot(normal, incident);\n   float k = 1. - pow(refraction, 2.) * (1. - pow(ndi,2.));\n   k = max(abs(k),1e-4);  //Negative K would be TIR\n   return refraction * incident - (refraction * ndi + sqrt(k)) * normal;\n}\n\n\n//Quantization with a smoothed boundary between values.\nfloat smooth_quantize(float value, float steps, float smoothing, float sharpness) {\n    float l = floor(value * steps) / steps,\n    h = ceil(value * steps) / steps, \n    s = (h - l),\n    m = l + s * .5;\n    return mix(l, h, pow(smoothstep(m - smoothing * s,m + smoothing * s, value), sharpness));\n}\n\nvec3 smooth_quantize(vec3 value, float steps, float smoothing, float sharpness) {\n    vec3 l = floor(value * steps) / steps,\n    h = ceil(value * steps) / steps, \n    s = (h - l),\n    m = l + s * .5;\n    return mix(l, h, pow(smoothstep(m - smoothing * s,m + smoothing * s, value), vec3(sharpness)));\n}\n\n\n//Clamps a 0-1 range around..?\nfloat snip(float v, float w, float a) {\n    return clamp(v - (a - w / 2.), 0., w) * (1. / w);\n}\n\n\n\n//SDF Maths\n\n//IQ's smooth min for SDFs\nfloat smooth_min(float a, float b, float smoothing) {\n    float h = clamp(.5 + .5 * (b - a) / smoothing, 0., 1.);\n    return mix(b, a, h) - smoothing * h * (1. - h);\n}\n\n\n//Range dividing for better and more dynamic domain repetition\nvec2 divide(vec2 range, float pos, float axis, inout float id) {\n    float z = range.x + range.y * pos;\n    if(z < axis) {\n        range.y = range.x + range.y - z;\n        range.x = z;\n        id += 1.0;\n    }\n    else {\n        range.y = z - range.x;\n        id *= 1.5;\n    }\n    return range;\n}\n\n//Generates a sharp impulse designed for use as a normal offset to create an indent/bump line\nfloat normal_edge(vec2 vs, vec2 mm) {\n    return mix(mix(mm.x, mm.y, smoothstep(.5 - vs.y, .5 + vs.y, vs.x)),0., abs(vs.x - .5) * 2.);\n}\n\n\n\n//3D Shapes\n\nfloat sdf_box(vec3 pos, vec3 size) {\n    vec3 q = abs(pos) - size;\n    return min(max(q.x, max(q.y, q.z)), 0.) + length(max(q, 0.));\n}\n\nfloat sdf_cylinder(vec3 pos, vec2 size) {\n    vec2 w = vec2(length(pos.xy) - size.x, abs(pos.z) - size.y);\n    return min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\nfloat sdf_tube(vec3 position, vec3 size) {\n   vec2 d = abs(vec2(length(position.xz) - size.y, position.y)) - vec2(size.z * 0.5, size.x * 0.5);\n   return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdf_torus(vec3 pos, vec2 size) {\n    return length(vec2(length(pos.xz) - size.x, pos.y)) - size.y;\n}\n\nfloat sdf_gyroid(vec3 pos, vec3 size) {\n    return (abs(dot(sin(pos*size.x),cos((pos*size.y).zxy)))-size.z)/(max(size.x,size.y)*1.8);\n}\n\n\n//Params = offset for fbm A, offset for fbm B, and scaling\nfloat sdf_fluid(vec3 pos, vec3 params)\n{\n\tfloat v = pos.y;\n\tv -= fbm_sine(pos.z * .5, 1., 3, params.x)*params.z+.5;\n\tv -= fbm_sine(pos.x * .5, 1., 3, params.y)*params.z+.5;\n\treturn v;\n}\n\n\n//4D Shapes\n\nfloat sdf_hyper_cube(vec4 pos, vec4 size) {\n    vec4 q = abs(pos) - size;\n    return min(max(q.x, max(q.y, max(q.z, q.w))), 0.) + length(max(q, 0.));\n}\n\n\nfloat sdf_hyper_gyroid(vec4 pos, vec3 size) {\n    return (abs(dot(sin(pos*size.x),cos((pos*size.y).zxyw)))-size.z)/(max(size.x,size.y)*1.8);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define ONE_PIXEL vec2(1.0 / iResolution.xy)\n#define TO_RELATIVE(x) (x * iResolution.y / 500.)\n\nvec4 read_data(vec2 uv, vec2 pixel_offset) {\n    return texture(iChannel0, uv + pixel_offset * ONE_PIXEL);\n}\n\nfloat edge_detect(vec2 uv, float range) {\n\n    vec4 center = texture(iChannel0, uv);\n    float rrange = TO_RELATIVE(range);\n    ivec2 irange = ivec2(ceil(rrange));\n    float edgeness = 0.0;\n    \n    for(int x = -irange.x; x < irange.x; x++) {\n        for(int y = -irange.y; y < irange.y; y++) {\n            vec2 offset = vec2(x, y);\n            vec4 data = read_data(uv, offset);\n            \n            if(data.w != center.w) {\n                float pix_dist = length(offset);\n                edgeness = max(edgeness, 1.0 - (pix_dist - rrange));\n            }\n        }\n    }\n    \n    return edgeness;\n}\n\nvec4 process(vec2 uv) {\n    vec4 data = texture(iChannel0, uv);\n    vec3 color = unpack3(data.x, 4.);\n    vec3 normal = unpack_normal(data.y);\n    \n    float edges = edge_detect(uv, 1.0);\n    \n    return vec4(clamp(color, vec3(.01), vec3(.99)), 1.0) + edges;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = process(fragCoord / iResolution.xy);\n}","name":"Buffer B","description":"","type":"buffer"}]}