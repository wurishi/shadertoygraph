{"ver":"0.1","info":{"id":"tt2GRy","date":"1560163718","viewed":189,"name":"Racaman sequence","username":"shau","description":"Racaman integer sequence. Sounds good too ","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["sequence","integer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n/*\n    From Numberphile\n*/\n\nconst float xOffs = -0.8;\n\nfloat semiCircle(vec2 uv, vec2 c, float r, float d) {    \n    float t = smoothstep(1.5/R.y, 0., abs( length(uv - c) - r ) );\n    return t * step((uv.y - c.y)* -d, 0.0);\n}\n\nvoid mainImage(out vec4 C, vec2 U) {\n\n    vec3 col = vec3(0);\n    vec2 uv = (U - R*.5) / R.y;        \n    float scale = 0.014 - clamp((iTime-0.0) *0.0002, 0.0, 0.0112),\n          dir = 1.0;\n    \n    for (float i=0.0; i<HOPS; i+=1.0) {\n        vec4 slot = load(iChannel0, R, i)*scale;  \n        float r = (slot.y - slot.x)*0.5,\n              sc = semiCircle(uv, vec2(slot.x+r+xOffs, 0.0), abs(r), dir);\n        col += palette(float(i)/HOPS) * sc;\n        dir *= -1.0;\n    }\n    \n    C = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define R iResolution.xy\n\n#define BUF(C, P, RES) texture(C, P/RES)\n#define HOPS 300.0\n\n//IQ cosine palattes\n//https://iquilezles.org/articles/palettes\nvec3 palette(float t) {return vec3(.5) + vec3(.5) * cos(6.28318 * (vec3(1.) * t + vec3(0., .33, .67)));}\n\nvec4 load(sampler2D channel, vec2 RES, float fidx) {\n    return BUF(channel, vec2(fidx+0.5, 0.5), RES);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nbool backSlot(float fidx) {\n    bool available = true;\n    if (fidx<=0.0) available = false;\n    for (float i=0.0; i<HOPS; i+=1.0) {\n        vec4 slot = load(iChannel0, R, i);\n        if (slot.x==fidx) {\n            available = false;\n            break;\n        }\n    }\n    return available;\n}\n\nvoid mainImage(out vec4 C, vec2 U) {\n    \n    float AT = floor(iTime * 6.0);\n\n    int idx = int(U.x-.5);\n    float fidx = float(idx),\n          type = U.y;\n    \n    vec4 currentSlot = load(iChannel0, R, float(idx));\n    \n    if (AT<HOPS && AT==fidx) {\n        float stepSize = AT + 1.0;\n        float startX =  (AT>0.0) ? load(iChannel0, R, AT-1.0).y : 0.0;\n        if (backSlot(startX  - stepSize)) stepSize *= -1.0;\n        currentSlot.x = startX;\n        currentSlot.y = startX + stepSize;\n    }\n    \n    //save\n    if (U.y==0.5) {\n        C = currentSlot;\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}