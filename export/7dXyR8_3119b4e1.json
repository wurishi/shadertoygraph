{"ver":"0.1","info":{"id":"7dXyR8","date":"1642635794","viewed":170,"name":"Gyroid Experiments","username":"Arry","description":"gyroid","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["gyroidtut"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"RayMarching starting point\"/ \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n//\n// ShaderToy Tutorials - https://www.youtube.com/watch?v=u5HAYVHsasc&list=PLGmrMu-IwbguU_nY2egTFmlg691DN7uE5\n// Videos pertaining to Raymarching such as simple shapes, basic operators & gyroids, have been utilised to create this shader\n\n//Max values used in raymarching\n#define MAX_STEPS 100 \n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\nfloat T;\n\n//rotation function\nmat2 Rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n\n//gyroid constructor\n//a gyroid is a complex mathematical shape\n//p = point, scale = scale/repetitions, thickness = thickness of gyroid struct, bias = shifts size of holes\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) //signed distance Gyroid\n{\n    //if the shape if scaled the final distance must be divided by the scale \n    p *=scale;\n    //dot product of (sine point & swizzeled zxy of point) divided by the scale\n    float gyroid = dot(sin(p), cos(p.zxy))/scale;\n    //must add absolute to prevent dot product ranging from -1 to 1, but this now makes a surface with 0 thickness\n    //subtract a small value from the absolute dot product to get some thickness  \n    //returns positive outside of the shape and negative inside of the shape\n    return abs(dot(sin(p), cos(p.zxy))-bias)/scale-thickness;\n   \n}\n\nvec3 Transform(vec3 p)\n{\n    p.xy *= Rot(p.z*.5); //remove tunneling by rotating p (basically twisting the end of the gyroid structure)\n    p.z -= T*.8; //move through the world forward\n    p.y -= .42; //roughly position world to camera centre\n    return p;\n}\n\nfloat GetDist(vec3 p) \n{\n    p = Transform(p);\n    \n    //first gyroid's bias determines the lattice structure\n    //small decimal values make repetition slightly different\n    float g1 = sdGyroid(p, 5.223, .06, 1.4);\n    float g2 = sdGyroid(p, 10.8111, .06, .1);\n\n    //roughly doubled scales of gyroids to be used in fractalizing\n    float g3 = sdGyroid(p, 23.55, .06, .1);\n    float g4 = sdGyroid(p, 34.534, .06, .1);\n    float g5 = sdGyroid(p, 62.987, .06, .1);\n    float g6 = sdGyroid(p, 87.213, .06, .1);\n    float g7 = sdGyroid(p, 120.546, .06, .1);\n   \n   //boolean subtraction of g2 from g1\n   //raymarch will always give g1 because -g2 is always smaller than g1\n   //g1 will be the surface raymarching is trying to reach\n   //therefor raymarch will only march to g1 where g2 isn't\n    float g = max(g1, -g2); \n    \n    //using other gyroids as bumpmaps for the subtraction of g2 from g1\n    g += g3*.2;\n    g -= g4*.1;\n    g -= g5*.1;\n    g -= g5+g6*.4;\n    g = g*.7;\n   \n    //use mix function with sin(Time) to blend between the two distance functions\n    float mixer = mix(g, g1, sin(T)*.5+.5);\n    \n    mixer = mixer*.65; //arbitrary multiplication to counter overstepping based on thickness \n   \n    return mixer;\n    \n}\n\n\n//Ray Marching (Sphere Tracing - using a radius to find distance to surface)\n//march forward from each new point\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    float dO=0.; //how far from distance origin (the camera)\n    \n    for(int i=0; i < MAX_STEPS; i++)\n    {\n        //ray origin * ray direction\n        vec3 p = ro + rd*dO; //point along the ray of which new distance from object is determined\n        float dS = GetDist(p); //calculate distance to object from p\n        dO +=  dS; //add to distance origin\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break; //if either hit object or exceed max distance break\n    }\n    //return distance origin\n    return dO;\n}\n\n\n//light requires a light and normal vector\nvec3 GetNormal(vec3 p) \n{\n\tfloat d = GetDist(p); //distance around p\n    vec2 e = vec2(.001, 0); //distance very close to p (the smaller the number the closer the sample is to p)\n    \n    //swizzles (e.xyy) = vec3(.01, 0, 0)\n    //sample two points to find a slope\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    //these vectors are direction only and are required to be the same length\n    return normalize(n);\n}\n\nvec3 Background(vec3 rd)\n{\n    vec3 col = vec3(0);\n\n    \n    float x = rd.x*.5; //x of ray direction points lines along x axis\n    col += (1.+x)*0.5+0.5*cos(iTime+vec3(0,2,4)); //rgb over time\n    float a = atan(rd.x, rd.y); //compass heading of z\n    float rainbow = sin(a*10.+T)*sin(a*7.+T)*sin(a*6.+T); //sine waves around pi (circle of light lines)\n    col += rainbow;\n    col = max(col, 0.); //colour cannot go negative\n    \n    return col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    T = mod(iTime,400.);//stop time getting to big (refresh every 400 seconds)\n    \n    uv += sin(uv*20.0+T)*.01; //small distortion\n    vec3 ro = vec3(0, 0, -.01);\n   \n   //camera warp\n    vec3 rd = normalize(vec3(uv.x, uv.y, (sin(T*.66)+1.)*.4)+.2);\n   \n   //perform raymarching\n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    //if hit add colour\n        vec3 p = ro + rd * d;\n        \n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        \n        p = Transform(p);\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        //add some contrast \n        col+= dif*dif;\n        \n        //full rbg spectrum over time\n        col += 0.5-0.5*cos(iTime+vec3(0,2,4));\n        \n        //HIGHLIGHTED CRACKS\n        float g2 = sdGyroid(p+T*.1, 10.8111, .06, .1);\n        \n        //controls width of highlights, making highlights at the bottom of the structure larger than the ones at the top\n        float highlightWidth = -.1+S(0., -.1, n.y)*.04;\n        float highlights = S(highlightWidth, -.05, g2);\n        \n        //use g3 and g4 to determine where some highlights do and don't appear\n        //subtle highlight shimmer using time\n        float g3 = sdGyroid(p+T*.1, 23.55, .06, .1);\n        float g4 = sdGyroid(p+T*.05, 34.534, .06, .1);\n        //Smooth step used to control hightlight brightness at the top and bottom\n        highlights *= g3*g4*20.+.2*S(.2, .0, n.y);\n        \n        //amplify brightness of highlights\n        col += highlights*4.;\n        \n        //rolling subtle highlights in the shape of g5\n        float g5 = sdGyroid(p+vec3(0,T, 0), 62.987, .06, .1);\n        col += g5*8.;\n        \n    }\n    //mix the final scene with the background with smoothstep\n    //start blend at 0, end at 7\n    col = mix(col, Background(rd), S(0., 7., d));\n\n    col *= 1.-dot(uv,uv); //vignette around screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}