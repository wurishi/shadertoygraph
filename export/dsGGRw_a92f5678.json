{"ver":"0.1","info":{"id":"dsGGRw","date":"1678306384","viewed":390,"name":"Windows Pipe Dream 3D","username":"gunthern","description":"Windows Pipes Screensaver (https://www.youtube.com/watch?v=Uzx9ArZ7MUU) in Raymarched 3D. \nTry changing the grid size, seed, number of pipes or speed in the common tab to see different results!\n\n2D version here: https://www.shadertoy.com/view/mdGGRw","likes":22,"published":1,"flags":32,"usePreview":1,"tags":["screen","windows","screensaver","dream","microsoft","saver","xp","pipe","pipes","pipes","windows95","95","y2k","pipedream","2000","windows98"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 3D version of the classic Microsoft \"Pipe Dream\" screensaver\n\n// Big thanks to @morimea for many tips on improving the first \n// version of this shader, specifically using voxels for each pipe\n// point instead of a very slow for loop when drawing the pipes.\n\n// Also thanks @ttg for the suggestion to use a depth buffer \n// instead of raymarching all geometry on each frame \n\nvoid getFade(out float fade, out int iter) {\n\n    iter = iFrame / (duration + fadeDuration);\n    \n    fade = 1.0 - (float(max((iFrame - (duration+fadeDuration)*iter) - duration, 0)) / float(fadeDuration));\n\n}\n\n#ifdef AA\nvoid mainImageRaw(out vec4 fragColor, in vec2 fragCoord)\n#else\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n#endif\n{\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    // Fade amount and iteration\n    float fade;\n    int iter;\n    getFade(fade, iter);\n    \n    // id, lighting, depth buffer\n    vec4 buffer = texture(iChannel1, fragCoord/iResolution.xy);\n    \n    // Color\n    vec3 col = color(buffer.r, iter);\n    \n    // Lighting\n    float light = buffer.g;\n    \n    // Draw pipes\n    fragColor = vec4(clamp(col * light + light * 0.25, 0.0, 1.0), 1.0) * fade;\n    \n    // Buffer debug\n    \n    //fragColor = texture(iChannel0, fragCoord/iResolution.xy * 0.1);\n    //fragColor = texture(iChannel1, fragCoord/iResolution.xy);\n    \n}\n\n#ifdef AA\n// Antialiasing \"module\" by FabriceNeyret2 https://www.shadertoy.com/view/WlfyW8\nvoid mainImage(out vec4 O, vec2 U) {\n    vec4 T;  \n    O = vec4(0);                                          \n    for (int k=0; k<AA*AA; k++, O+=T) {              \n        mainImageRaw(T, U + 0.33 * vec2(k%AA - AA/2, k/AA - AA/2));\n    }\n    O /= float(AA*AA);\n}\n#endif","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Global Variables //\n\n// Max FPS\n#define fps 60\n// Cube grid size\n#define gridSize 10\n// Random seed (for start positions, directions, and colors)\n#define randomSeed 74.24\n// Number of pipes\n#define numPipes 5\n// Speed (frames between updates)\n#define speed int(3.0 * max((float(iFrame) / max(iTime, 0.01)) / float(fps), 1.0))\n// Duration (length of one arrangement in frames)\n#define duration int(160.0 * max((float(iFrame) / max(iTime, 0.01)) / float(fps), 1.0))\n// Fade (length of fade out)\n#define fadeDuration int(30.0 * max((float(iFrame) / max(iTime, 0.01)) / float(fps), 1.0))\n// Pipe radius\n#define pipeRadius 0.1\n// Cap radius\n#define capRadius 0.15\n\n// Raymarching Globals //\n\n#define MAX_STEPS 100\n#define  MAX_DIST 100.0\n#define SURFACE_DIST 0.005\n\n// Antialiasing level (uncomment to enable) //\n//#define AA 4\n\n// Global Functions //\n\n// Random function from the Book of Shaders - returns random value between 0 and 1\nfloat random (in vec2 uv) {\n    \n    return fract(sin(dot(uv.xy, vec2(12.98,78.23))) * randomSeed);\n    \n}\n\n// Randomly generate colors\nvec3 color(in float p, in int iter) {\n    \n    float ti = float(iter) * random(vec2(p+1.));\n    \n    float r = random(vec2(p+ti,p+ti+1.));\n    float g = random(vec2(p+ti+2.,p+ti+3.));\n    float b = random(vec2(p+ti+4.,p+ti+5.));\n    \n    vec3 col = vec3(r,g,b);\n    return col;\n    \n}\n\n// Raymarched surface constructor\nstruct Surface {\n\n    float dist;\n    float id;\n    \n};\n\n// Surface min\nSurface surfaceMin(Surface a, Surface b) {\n    \n    float id = a.dist > b.dist ? b.id : a.id;\n    \n    return Surface(min(a.dist, b.dist), id);\n    \n}\n\n// Raymarched sphere (iquilezles.org/articles/distfunctions)\nSurface sdSphere(vec3 p, float r, float id) {\n    \n    return Surface(length(p)-r, id);\n    \n}\n\n// Raymarched capsule (iquilezles.org/articles/distfunctions)\nSurface sdCapsule(vec3 p, vec3 a, vec3 b, float r, float id)\n{\n\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n  return Surface(length(pa - ba*h) - r, id);\n  \n}\n\n// Lookat\nmat3 lookAt(vec3 eye , vec3 at, vec3 up)\n{\n\n  vec3 ww = normalize(at - eye);\n  vec3 uu = normalize(cross(ww, up));\n  vec3 vv = cross(uu , ww);\n\n  return mat3(uu, vv, ww);\n\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Initialize grid and start points\nvoid initGrid(inout vec4 fragColor, in ivec2 ipx, in int iter) {\n    \n    fragColor = vec4(0.0);\n    \n    vec3 point;\n    \n    // Unique start points, one per pipe\n    int startPoints[numPipes];\n    const int maxPoints = int(gridSize*gridSize*gridSize);\n    int allPoints[maxPoints];\n    \n    for (int i=0; i < maxPoints; i++) {\n        allPoints[i] = i;\n    }\n    \n    for (int i=0; i < numPipes; i++) {\n        int randomStart = int(floor(random(vec2(1.0 + float(i) + float(iter) * randomSeed)) * float(maxPoints - i)));\n        startPoints[i] = allPoints[randomStart];\n        allPoints[randomStart] = allPoints[maxPoints - (1+i)];\n    }\n    \n    int pointIncrement = 0;\n    \n    // Populate grid with available points and start points\n    for (int i=0; i < gridSize*gridSize*gridSize; i++) {\n    \n        int x = int(mod(float(i), float(gridSize)));\n        int y = int(floor(float(i) / float(gridSize * gridSize)));\n        int z = int(floor((float(i) - float(y * gridSize * gridSize)) / float(gridSize)));\n        \n        int startPoint = 0;\n\n        for (int i=0; i < numPipes; i++) {\n            if (pointIncrement == startPoints[i]) {\n                startPoint = i + 1;\n            }\n        }\n\n        if (\n            int(mod(float(ipx.x), float(gridSize))) == x\n            && ipx.y == y\n            && ipx.x / gridSize == z\n            && startPoint != 0\n        )\n        {\n            point = vec3(float(startPoint) / float(numPipes), 1.5, 0.0);\n        }\n\n        pointIncrement++;\n\n    }\n    \n    fragColor = vec4(point, 1.0);\n    \n}\n\n// Possible directions for next point\nconst ivec3 up = ivec3(0, 1, 0);\nconst ivec3 down = ivec3(0, -1, 0);\nconst ivec3 left = ivec3(-1, 0, 0);\nconst ivec3 right = ivec3(1, 0, 0);\nconst ivec3 back = ivec3(0, 0, -1);\nconst ivec3 front = ivec3(0, 0, 1);\n\nconst int directionCount = 6;\n\nconst ivec3 directions[directionCount] = ivec3[](up, down, left, right, back, front);\n\n// Update grid points\nvoid updateGrid(inout vec4 fragColor, in ivec2 ipx, in vec4 previousTex) {\n    \n    fragColor = previousTex;\n    \n    // Get point states\n    bool pointStates[int(gridSize*gridSize*gridSize)];\n    \n    for (int i=0; i < int(gridSize*gridSize*gridSize); i++) {\n        pointStates[i] = true;\n    }\n\n    ivec3 nextPoint;\n    \n    // Find active points\n    for (int i=0; i < gridSize*gridSize*gridSize; i++) {\n    \n        int x = int(mod(float(i), float(gridSize)));\n        int y = int(floor(float(i) / float(gridSize * gridSize)));\n        int z = int(floor((float(i) - float(y * gridSize * gridSize)) / float(gridSize)));     \n        \n        vec3 state = texelFetch(iChannel0, ivec2(float(x+z*gridSize)+0.5, float(y)+0.5), 0).rgb;\n\n        if (int(state.g) == 1) {\n\n            int randomDirIter = 0;\n\n            int directionKey = 0;\n\n            // Generate next point\n            ivec3 dirDynamic[directionCount] = directions;\n            if (y == gridSize - 1) dirDynamic[0] = down;\n            if (y == 0) dirDynamic[1] = up;\n            if (x == 0) dirDynamic[2] = right;\n            if (x == gridSize - 1) dirDynamic[3] = left; \n            if (z == 0) dirDynamic[4] = front;\n            if (z == gridSize - 1) dirDynamic[5] = back;\n            \n            bool validNextPoint = false;\n\n            for (int i=0; i < directionCount; i++) {\n                float newRandom = random(vec2(x + y + randomDirIter + iFrame)) * 0.999;\n                int randomDir = int(floor(newRandom*float(directionCount-i-1)));\n                nextPoint = ivec3(x,y,z) + dirDynamic[randomDir];\n                vec3 nextPointState = texelFetch(iChannel0, ivec2(float(nextPoint.x + nextPoint.z*gridSize)+0.5, float(nextPoint.y)+0.5), 0).rgb;\n                // Check point availability\n                if (nextPointState.r == 0.0 && pointStates[int(nextPoint.x + nextPoint.y*gridSize + nextPoint.z*gridSize*gridSize)]) {\n                    validNextPoint = true;\n                    // Mark point as taken\n                    pointStates[int(nextPoint.x + nextPoint.y*gridSize + nextPoint.z*gridSize*gridSize)] = false;\n                    directionKey = dirDynamic[randomDir] == up ? 1 :\n                       dirDynamic[randomDir] == down ? 2 :\n                       dirDynamic[randomDir] == left ? 3 :\n                       dirDynamic[randomDir] == right ? 4 : \n                       dirDynamic[randomDir] == back ? 5 : \n                       dirDynamic[randomDir] == front ? 6 : 0;\n                    break;\n                }\n\n                dirDynamic[randomDir] = dirDynamic[directionCount-i-1];\n                randomDirIter++;\n\n            }\n\n            // Update next point\n            if (\n                validNextPoint\n                && ipx == ivec2(nextPoint.x + nextPoint.z*gridSize, nextPoint.y)\n            )\n            {\n\n                fragColor = vec4(state.r, 1.0, directionKey, 1.0);\n            }\n\n            // Update this point\n            if (\n                ipx == ivec2(x+z*gridSize, y)\n            )\n            {\n                fragColor = vec4(state.r, 2.5, state.b, 1.0);\n                if (validNextPoint) {\n                    float thisPointDir = mod(state.b, 10.0) + float(directionKey)*10.0;\n                    fragColor = vec4(state.r, fract(state.g) + 2.0, thisPointDir, 1.0);\n                    if (directionKey != int(state.b) && random(vec2(nextPoint.xy + nextPoint.xz + nextPoint.yz)) > 0.5) {\n                        fragColor = vec4(state.r, 2.5, thisPointDir, 1.0);\n                    }\n                } \n            }\n\n        }\n        \n        if (int(state.g) == 2 && ipx == ivec2(x+z*gridSize, y)) { \n        \n            fragColor.g = 3.0;\n        \n        }\n\n    }\n\n}\n\n// Stop all pipes\nvoid stopPipes(inout vec4 fragColor, in ivec2 ipx, in vec4 previousTex) {\n    \n    fragColor = previousTex;\n    \n    // Find active points\n    for (int i=0; i < gridSize*gridSize*gridSize; i++) {\n    \n        int x = int(mod(float(i), float(gridSize)));\n        int y = int(floor(float(i) / float(gridSize * gridSize)));\n        int z = int(floor((float(i) - float(y * gridSize * gridSize)) / float(gridSize)));\n        \n        vec3 state = texelFetch(iChannel0, ivec2(float(x+z*gridSize)+0.5, float(y)+0.5), 0).rgb;\n\n        if (\n            int(mod(float(ipx.x), float(gridSize))) == x\n            && ipx.y == y\n            && ipx.x / gridSize == z\n            && int(state.g) == 1\n        )\n        {\n            fragColor = vec4(state.r, 2.5, state.b, 1.0);\n        }\n\n    }\n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    if (fragCoord.x > float(gridSize*gridSize) || fragCoord.y > float(gridSize)) discard;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Current iChannel0\n    vec4 previousTex = texture(iChannel0, uv);\n    \n    // Iteration\n    int iter = iFrame / (duration + fadeDuration);\n    \n    // Draw buffer texture\n    fragColor = previousTex;\n    \n    bool stopCondition = false;\n    \n    // Int fragCoord\n    ivec2 ipx = ivec2(fragCoord);\n    \n    // Initialize\n    if (iFrame == 0 || iFrame % (duration + fadeDuration) == 0) {\n        \n    \tinitGrid(fragColor, ipx, iter);\n        \n        stopCondition = true;\n        \n    }\n    \n    // Stop pipes at duration\n    if ((iFrame - iter*fadeDuration) % duration == 0 && !stopCondition) {\n        \n        stopPipes(fragColor, ipx, previousTex);\n        \n        stopCondition = true;\n    \n    }\n    \n    // Update every s frames\n    if (iFrame % speed == 0 && !stopCondition) {\n    \n        updateGrid(fragColor, ipx, previousTex);\n    \n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"Surface getDist(vec3 p, in vec3 rd) {\n    \n    p += vec3(vec2(float(gridSize)/2.0), -float(gridSize));\n    \n    p = clamp(p, vec3(0.0), vec3(gridSize));\n    \n    // Get point state from buffer\n    int x = int(p.x) + int(p.z)*gridSize;\n    int y = int(p.y);\n    vec3 state = texelFetch(iChannel0, ivec2(x,y), 0).rgb;\n    \n    // 3D repetition from iquilezles.org/articles/distfunctions/\n    vec3 q = fract(p)-0.5;\n    \n    // Overstep correction\n    vec2 rC = ((2.0 * step(0.0, rd.xz) - 1.0) * vec2(0.5) - q.xz) / rd.xz; // ray to cell boundary\n    float dC = min(rC.x, rC.y) + 0.01; // distance to cell just past boundary\n    if (p.x >= float(gridSize) || p.x <= 0.0\n     || p.y >= float(gridSize) || p.y <= 0.0\n     || p.z >= float(gridSize) || p.z <= 0.0 ) \n    { dC += MAX_DIST; }\n    Surface dCS = Surface(dC, 0.0);\n   \n    // Update current point\n    if (int(state.g) == 1) {\n    \n        // Get point attributes\n        bool pipeJoint = fract(state.g) == 0.5;\n        \n        int joinDir = int(mod(state.b, 10.0));\n        vec3 jd = joinDir == 1 ? vec3(0.0, -1.0, 0.0) :\n        joinDir == 2 ? vec3(0.0, 1.0, 0.0) : \n        joinDir == 3 ? vec3 (1.0, 0.0, 0.0) :\n        joinDir == 4 ? vec3(-1.0, 0.0, 0.0) :\n        joinDir == 5 ? vec3(0.0, 0.0, 1.0) :\n        joinDir == 6 ? vec3(0.0, 0.0, -1.0) : vec3(0.0);\n        \n        Surface jc = sdCapsule(q, vec3(0.0), jd, pipeRadius, state.r);\n        \n        if (pipeJoint) {\n        \n            Surface sphere = sdSphere(q, capRadius, state.r);\n        \n            return surfaceMin(surfaceMin(sphere, jc), dCS);\n            \n        }\n        \n        return surfaceMin(jc, dCS);\n        \n    }\n    \n    // Update last point\n    if (int(state.g) == 2) {\n    \n        // Get point attributes\n        bool pipeJoint = fract(state.g) == 0.5;\n        \n        int reachDir = int(state.b * 0.1);\n        vec3 rd = reachDir == 1 ? vec3(0.0, 1.0, 0.0) :\n        reachDir == 2 ? vec3(0.0, -1.0, 0.0) : \n        reachDir == 3 ? vec3 (-1.0, 0.0, 0.0) :\n        reachDir == 4 ? vec3(1.0, 0.0, 0.0) :\n        reachDir == 5 ? vec3(0.0, 0.0, -1.0) :\n        reachDir == 6 ? vec3(0.0, 0.0, 1.0) : vec3(0.0);\n        \n        Surface rc = sdCapsule(q, vec3(0.0), rd, pipeRadius, state.r);\n        \n        if (pipeJoint) {\n        \n            Surface sphere = sdSphere(q, capRadius, state.r);\n        \n            return surfaceMin(surfaceMin(sphere, rc), dCS);\n            \n        }\n        \n        return surfaceMin(rc, dCS);\n        \n    }\n\n    return surfaceMin(Surface(float(gridSize) * 0.05, 0.0), dCS);\n    //return surfaceMin(sdSphere(q, 0.01, 0.0), dCS);\n\n}\n\n// Raymarch\nSurface rayMarch(vec3 ro, vec3 rd){\n\n    float dO = 0.0;\n    \n    float id = 0.0;\n    vec3 p;\n    Surface distColor;\n    \n    for (int i=0; i<MAX_STEPS; i++){\n    \n        p = ro + rd*dO;\n        \n        distColor = getDist(p, rd);\n        float dS = distColor.dist;\n        \n        dO += dS;\n        if (dO>MAX_DIST || dS<SURFACE_DIST) break;\n    }\n    \n    id = distColor.id;\n    \n    return Surface(dO, id);\n    \n}\n\n// Get normal\nvec3 getNormal(vec3 p, vec3 rd) {\n\n    float d = getDist(p, rd).dist;\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy, rd).dist,\n        getDist(p-e.yxy, rd).dist,\n        getDist(p-e.yyx, rd).dist);\n        \n    return normalize(n);\n    \n}\n\n// Get light\nvec3 getLight(vec3 p, vec3 c, vec3 lp, vec3 rd) {\n\n    vec3 l = normalize(lp - p);\n    vec3 n = getNormal(p, rd); \n    \n    float diff = dot(n, l);\n    float d = rayMarch(p+n*SURFACE_DIST*2.0, l).dist;\n    if (d<length(lp-p)) diff *= 0.01;\n    \n    return diff * c;\n      \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    // Iteration\n    int iter = iFrame / (duration + fadeDuration);\n    \n    // Get previous texture\n    vec4 previousTex = texture(iChannel1, fragCoord/iResolution.xy);\n    fragColor = previousTex;\n    \n    bool is_resize = texelFetch(iChannel1, ivec2(iResolution.xy)-1,0).a<0.5;\n    \n    // Initialize new sequence\n    if (iFrame % (duration + fadeDuration) == 0 || is_resize) {\n        fragColor = vec4(vec3(0.0), 1.0);\n        return;\n    }\n    \n    // Draw pipes\n    if (iFrame % speed == 0 || (iFrame - iter*fadeDuration) % duration == 0) {\n        \n        // Random offset for rotation\n        float rr = random(vec2(iter+1, iter+2))*20.0 - 10.0;\n        \n        // Ray origin\n        vec3 ro = vec3(rr, 0.0, 0.0);\n        // Ray direction with rotation\n        vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n        rd *= lookAt(ro, vec3(0.0, 0.0, float(gridSize)), vec3(0.0, 1.0, 0.0));\n        \n        // Raymarch and get pipe id\n        Surface rs = rayMarch(ro, rd);\n        float d = rs.dist;\n        float id = rs.id;\n\n        vec3 p = (ro + rd * d);\n        \n        // Diffuse lighting\n        /*vec3 diffuse = getLight(p, vec3(1.0), vec3(2.0));\n        diffuse = clamp(diffuse, 0.15, 1.0);\n        diffuse = d == 0.0 ? vec3(0.0) : diffuse;\n\n        vec3 color = vec3(clamp(diffuse * col, 0.0, 1.0));*/\n\n        // Normal lighting\n        vec3 normal = getNormal(p, rd);\n        float nl = clamp((normal.r)*0.33 + (1.0-normal.b)*0.33 + normal.g*0.33, 0.25, 1.0);\n        if (d > float(gridSize)*3.0) nl = 0.0;   \n        \n        // Depth\n        float dm = 1.0 - d/MAX_DIST;\n        \n        vec3 idLightingDepth = vec3(id, nl, dm);\n        \n        //fragColor = vec4(max(previousTex.b, dm));\n        //fragColor = vec4(vec3(diffuse), 1.0);\n        //fragColor = vec4(vec3(nl), 1.0);\n        //fragColor = vec4(vec3(id), 1.0);\n        \n        // If the distance is greater than previous, add new segment to fragColor\n        if (dm > previousTex.b) {\n        \n            fragColor = vec4(idLightingDepth, 1.0);\n            \n        }\n        \n    }\n    \n    // Buffer debug\n    //fragColor = texture(iChannel0, fragCoord/iResolution.xy * 0.2);\n    \n}","name":"Buffer B","description":"","type":"buffer"}]}