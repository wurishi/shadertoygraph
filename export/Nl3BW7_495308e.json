{"ver":"0.1","info":{"id":"Nl3BW7","date":"1663257797","viewed":320,"name":"Volume Path Tracing Test","username":"w450468524","description":"Learn volumetric path tracing, currently only closed form tracking.\nI'm not sure if the multiple importance sampling is correctly implemented :)\n\nMouse to rotate camera","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["volume","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nbool rayBoxIntersection(float extent, vec3 position, vec3 ro, vec3 rd, bool externOnly, out vec2 result)\n{\n    vec3 bMin = vec3(-extent, -extent, -extent) + position;\n    vec3 bMax = vec3(extent, extent, extent) + position;\n\n    vec3 t1 = (bMin - ro) / rd;\n    vec3 t2 = (bMax - ro) / rd;\n    vec3 minT = vec3(min(t1.x, t2.x), min(t1.y, t2.y), min(t1.z, t2.z));\n    vec3 maxT = vec3(max(t1.x, t2.x), max(t1.y, t2.y), max(t1.z, t2.z));\n\n    float startT = max(max(minT.x, minT.y), minT.z);\n    float endT = min(min(maxT.x, maxT.y), maxT.z);\n    // intersect and at least one intersection in front of ray\n    if(startT < endT)\n    {\n        result = vec2(startT, endT);\n        if (externOnly)\n            return startT > 0.0;\n        else\n            return endT > 0.0;\n    }\n\n    return false;\n}\n\nbool sphereIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra, bool externOnly, out vec2 result)\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return false; // no intersection\n    h = sqrt( h );\n    result = vec2( -b-h, -b+h );\n    \n    if (externOnly)\n        return result.x > 0.0;\n    else\n        return result.y > 0.0;\n}\n\nvec3 getUniformSphereSample(float r1, float r2)\n{\n    float x = cos(2.0 * PI * r1) * 2.0 * sqrt(r2 * (1.0 - r2));\n    float y = sin(2.0 * PI * r1) * 2.0 * sqrt(r2 * (1.0 - r2));\n    float z = 1.0 - 2.0 * r2;\n    return vec3(x, y, z);\n}\n\nvoid isotropicPhase(vec3 inDir, float rand1, float rand2, out vec3 sampleDir, out float pdf, out float weight)\n{\n    /*sampleDir.z = rand1 * 2.0 - 1.0;\n    float sinTheta = 1.0 - sampleDir.z * sampleDir.z;\n    if (sinTheta > 0.0)\n    {\n    \tsinTheta = sqrt(sinTheta);\n    \tfloat phi = rand2 * 2.0 * PI;\n    \tsampleDir.x = sinTheta * cos(phi);\n     \tsampleDir.y = sinTheta * cos(phi);\n    }\n    else\n    \tsampleDir.x = sampleDir.y = 0.0;*/\n    sampleDir = getUniformSphereSample(rand1, rand2);\n    pdf = 1.0/ (4.0 * PI);\n    weight = pdf;\n}\n\nconst int maxRayDepth = 100;\nconst vec3 lightIntensity = vec3(15.0, 15.0, 10.0);\nconst vec3 bgColorTop = vec3(0.3, 0.3, 0.2);\nconst vec3 bgColorBottom = vec3(0.2, 0.2, 0.2);\n\nconst vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\nconst float density = 10.0;\nconst float scatterCoeff = 0.5f;\nconst float absorptionCoeff = 0.05f;\nconst float epsilon = 0.001f;\n\n// slightly backward phase fucntion\n#define G -0.1\n#define ONE_PLUS_G2 (1.0 + G*G)\n#define ONE_MINUS_G2 (1.0 - G*G)\n#define ONE_OVER_2G (0.5f / G)\n\n// scatter phase related\nfloat calcpdf(float cosTheta)\n{\n    return 0.25 * ONE_MINUS_G2 / (PI * pow(ONE_PLUS_G2 - 2.0 * G * cosTheta, 1.5));\n}\n\nfloat invertcdf(float xi)\n{\n    float t = ONE_MINUS_G2 / (1.0 - G + 2.0 * G * xi);\n    return ONE_OVER_2G * (ONE_PLUS_G2 - t*t);\n}\n\nvoid orthonormalBasis(vec3 n, out vec3 t1, out vec3 t2)\n{\n    if (abs(n.y) < 0.9)\n    {\n        vec3 up = vec3(0.0, 1.0, 0.0);\n        t1 = normalize(cross(n, up));\n        t2 = normalize(cross(t1, n));\n    }\n    else\n    {\n        vec3 right = vec3(1.0, 0.0, 0.0);\n        t1 = normalize(cross(n, right));\n        t2 = normalize(cross(t1, n));\n    }\n}\n\nvoid evaluatePhaseSample(vec3 rd, vec3 sampleDir, out float pdf)\n{\n    // isotropic\n    if (abs(G) < epsilon)\n    {\n        pdf = 0.25 / PI;\n    }\n    // anisotropic\n    else\n    {\n        float cosTheta = dot(rd, sampleDir);\n        pdf = calcpdf(cosTheta);\n    }\n}\n\nvoid generatePhaseSample(vec3 rd, out vec3 sampleDir, out float pdf)\n{\n    if (abs(G) < epsilon)\n    {\n        sampleDir = getUniformSphereSample(rand(), rand());\n        pdf = 0.25 / PI;\n    }\n    // anisotropic\n    else\n    {\n        float phi = rand() * 2.0 * PI;\n        float cosTheta = invertcdf(rand());\n        float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n        vec3 t1, t2;\n        orthonormalBasis(rd, t1, t2);\n        sampleDir = sinTheta * sin(phi) * t1 + sinTheta * cos(phi) * t2 + cosTheta * rd;\n        pdf = calcpdf(cosTheta);\n    }\n}\n\nvec3 backgroundColor(vec3 dir)\n{\n    vec3 unit_direction = normalize(dir);\n    float t = 0.5*(unit_direction.y + 1.0);\n    return (1.0-t)*bgColorBottom + t*bgColorTop;\n}\n\nvec3 emission(vec3 pos)\n{\n    // return length(pos) < 0.4 ? vec3(0.0, 2.0, 0.0):vec3(0.0);\n    return normalize(abs(pos)) * 2.0;\n}\n\n#define BOX 1\n\nvec3 traceRayMIS(vec3 ro, vec3 rd)\n{\n    vec3 boxCenter = vec3(0, 0, 0);\n    float boxExtent = 0.5;\n    vec3 attenuation = vec3(1.0);\n    \n    vec2 result;\n    vec3 lastRd;\n    float pdf;\n    \n    float extinctionCoeff = scatterCoeff + absorptionCoeff;\n#if BOX\n    if (rayBoxIntersection(boxExtent, boxCenter, ro, rd, true, result))\n#else\n    if (sphereIntersect(ro, rd, boxCenter, boxExtent, true, result))\n#endif\n    {\n        ro = ro + rd * result.x;\n        for (int i = 0; i < maxRayDepth; ++i)\n        {\n#if BOX\n            if (rayBoxIntersection(boxExtent, boxCenter, ro, rd, false, result))\n#else\n            if (sphereIntersect(ro, rd, boxCenter, boxExtent, false, result))\n#endif\n            {\n                float zeta = rand();\n                float scatterDistance = -log(1.0 - zeta) / (density * scatterCoeff);\n\n                // scatter out of box\n                if (scatterDistance > result.y)\n                {\n                    vec3 col = vec3(0.0);\n                    vec3 bgColor = backgroundColor(rd);\n                    // no scatter before\n                    if (i == 0)\n                        return bgColor;\n                    \n                    // MIS lighting at point before scatter out\n                    float scatterWeight = balanceHeuristic(1, pdf, 1, 1.0);\n                    float lightWeight = balanceHeuristic(1, 1.0, 1, pdf);\n                    \n                    // Sample phase, almost impossible to sample directional light\n                    col += scatterWeight * (bgColor + (dot(rd, lightDir) > 0.99999 ? lightIntensity : vec3(0.0)));\n                    \n                    // sample directional light\n                    vec2 tempResult;\n#if BOX                    \n                    rayBoxIntersection(boxExtent, boxCenter, ro, lightDir, false, tempResult);\n#else\n                    sphereIntersect(ro, lightDir, boxCenter, boxExtent, false, tempResult);\n#endif\n                    float transmitance = exp(-tempResult.y * density * scatterCoeff);\n                    float lightSamplePhase;\n                    evaluatePhaseSample(lastRd, lightDir, lightSamplePhase);\n                    col += lightWeight * lightSamplePhase * (lightIntensity + backgroundColor(lightDir)) * transmitance;\n                    return col;\n                }\n                else\n                {\n                    if (zeta < scatterCoeff / extinctionCoeff)\n                    {\n                        // scatter event\n                        ro = ro + rd * scatterDistance;\n                        \n                        lastRd = rd;\n                        generatePhaseSample(lastRd, rd, pdf);\n                        /*float pdf, weight;\n                        isotropicPhase(rd, rand(), rand(), rd, pdf, weight);\n                        attenuation *= vec3(1.0, 1.0, 1.0);*/\n                    }\n                    else\n                    {\n                        // absorb/emission event\n                        return emission(ro + rd * scatterDistance);\n                    }\n                }\n            }\n            else\n            {\n                break;\n            }\n        }\n        return vec3(0.0);\n    }\n    else\n    {\n        return backgroundColor(rd);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    INIT_RNG;\n    vec4 oldColor = texelFetch(iChannel0, ivec2(fragCoord), 0).rgba;\n    float sampleCount = (iFrame == 0 ? 0.0 : oldColor.a);\n    if (iMouse.z > 0.0)\n        sampleCount = 0.0;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy * 2.0;\n    if (iMouse.xy==vec2(0))\n        mouse = vec2(0.25, -0.5);\n    float cosPhi = cos(mouse.y * 0.5 * PI);\n    float sinPhi = sin(mouse.y * 0.5 * PI);\n    vec3 camPos = vec3(sinPhi * cos(mouse.x * PI), cosPhi, sinPhi * sin(mouse.x * PI)) * 2.0;\n    vec3 front = vec3(0, 0, 0) - camPos;\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    \n    // restore aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 rd = normalize(uv.x * right + uv.y * up + front);\n    vec3 ro = camPos;\n\n    vec3 col = traceRayMIS(ro, rd);\n    // accumulate with last frame\n    col = (sampleCount * oldColor.rgb + col) / (sampleCount + 1.0);\n    \n    // Output to screen\n    fragColor = vec4(col, sampleCount + 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415936f\n\n// High-Quality Random Numbers from Michael0884, proper demo: https://www.shadertoy.com/view/wltcRS\nuint ns;\n#define INIT_RNG ns = 185730U*uint(iFrame)+uint(fragCoord.x + fragCoord.y*iResolution.x);\nvoid pcg(){\n    uint state = ns*747796405u+2891336453u;\n    uint word = ((state >> ((state >> 28u)+4u))^state)*277803737u;\n    ns = (word >> 22u)^word;\n}\n\nfloat rand(){pcg(); return float(ns)/float(0xffffffffu);}\nvec2 rand2(){return vec2(rand(), rand());}\nvec3 rand3(){return vec3(rand(), rand(), rand());}\nvec4 rand4(){return vec4(rand(), rand(), rand(), rand());}\n\nfloat balanceHeuristic(int nf, float fPdf, int ng, float gPdf) {\n    return (float(nf) * fPdf) / (float(nf) * fPdf + float(ng) * gPdf);\n}\n\n#define PIX_ARE_EQUAL(a, b)  (int(a.x)==int(b.x) && int(a.y)==int(b.y) ? true : false)","name":"Common","description":"","type":"common"}]}