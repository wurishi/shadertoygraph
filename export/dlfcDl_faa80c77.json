{"ver":"0.1","info":{"id":"dlfcDl","date":"1691326334","viewed":95,"name":"Waveshaper","username":"Envy24","description":"Drag point with mouse to change signal shape.\nBlue - input signal in range [0, 1],\nRed - output signal in range [0, 1].\nArrows explain how to read graph.\nTry another shaping functions)","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["wave","shape","waveshaper"],"hasliked":0,"parentid":"cllcWj","parentname":"Gamma correction graph"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCENE_SCALE               ( 0.51 )\n#define UNIT                      ( (SCENE_SCALE*4.0) / iResolution.y  )\n#define SMAA(d)                   ( smoothstep(UNIT, 0., d) )\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nvec2 MP    = vec2(0); // Mouse control.\n\nfloat two_lines_shaper(float x)\n{\n    vec2 P0 = vec2(0),\n         P1 = MP,\n         P2 = vec2(1),\n         A0 = vec2(x, 0),\n         A1 = vec2(x, 1);\n        \n    vec2 I = vec2(0);\n    if (x < P1.x)\n        I = segment_segment_intersection(P0, P1, A0, A1);\n    else\n        I = segment_segment_intersection(P1, P2, A0, A1);\n         \n    return I.y;\n}\n\n//#define SHAPE_FUNC(IN) ( mix(0., 1., IN) ) // bypass\n//#define SHAPE_FUNC(IN) ( smoothstep(0., 1., IN) )\n#define SHAPE_FUNC(IN) ( two_lines_shaper(IN) )\n\nfloat waveshaper(in float T)\n{\n    return SHAPE_FUNC(T);\n}\n\n/* Returns sine wave in range [min, max]. Starts at min. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n// Other oscillators:\n// https://www.shadertoy.com/view/cllyWf\n// https://www.shadertoy.com/view/DlscDf\n// https://www.shadertoy.com/view/mllcWX\n// https://www.shadertoy.com/view/dtscWX\n// https://www.shadertoy.com/view/dllyDX\n// https://www.shadertoy.com/view/dlsyWf\n// https://www.shadertoy.com/view/DtscWX\n\n// Explicit function definition.\nint func_idx = 0;\nfloat explicit(float x) \n{ \n    const float TAU = 6.2831853071795862;        \n    float t = linear_remap(x, vec2(1, 1.8), vec2(0., 2.*TAU));\n\n    float y = 0.;\n    switch (func_idx)\n    {\n    case 0: y = 0.5*sinOSC(0., 1., t); break;\n    case 1: y = 0.5*waveshaper(sinOSC(0., 1., t)); break;\n    case 2: y = SHAPE_FUNC(x); break;\n    }\n    \n    return y;\n} \n\nfloat explicitSDF(\n    in vec2 NDC,\n    in float pixel_size,\n    in float thickness)\n{\n    float quality = 18.,  \n          order = thickness + quality,\n          minimal_distance = 9e5;\n          \n    vec2 B = \n        vec2(NDC.x-order*pixel_size,\n             explicit(NDC.x-order*pixel_size));\n      \n    for (float i = -order + 1.; i <= order; i += 1.)\n    {\n        vec2 E = vec2(B.x + pixel_size, explicit(B.x + pixel_size));\n        minimal_distance = \n            min(minimal_distance, segmentSDF(NDC, B, E, 0.));\n        B = E;\n    }\n    \n    return minimal_distance - pixel_size * thickness;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    // Initialize global variables.\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0.9, 0.5), false);\n         MP = map_to_centered_ndc(iMouse.xy, SCENE_SCALE, vec2(0.9, 0.5), false);\n         MP = iMouse.xy == vec2(0) ? vec2(0.5,0.75) : clamp(MP, vec2(0), vec2(1));\n         \n    vec3 color = vec3(1);     \n         color = mix( color, vec3(0.8), smoothstep(3./iResolution.y, 0., cellsSDF(NDC)) );        \n         color = mix( color, vec3(0), SMAA(vertical_lineSDF(NDC, 0.)) );\n         color = mix( color, vec3(0), SMAA(horizontal_lineSDF(NDC, 0.)) );\n         color = mix( color, vec3(0), SMAA(vertical_lineSDF(NDC, 1.)) );\n         color = mix( color, vec3(0), SMAA(horizontal_lineSDF(NDC, 1.)) );\n         color = mix( color, vec3(0), SMAA(vertical_lineSDF(NDC, 1.8)) );\n        \n    if (NDC.x > 1. && NDC.x < 1.8) {\n        color = mix( color, vec3(0), SMAA(horizontal_lineSDF(NDC, 0.5)) );\n        color = mix( color, vec3(0.8), SMAA(horizontal_lineSDF(NDC, 0.75)) );\n        color = mix( color, vec3(0.8), SMAA(horizontal_lineSDF(NDC, 0.25)) );\n\n        vec2 ndc = NDC;\n            ndc.y = NDC.y - 0.5;\n            func_idx = 0;\n        color = mix(color, vec3(0,0,1), SMAA(explicitSDF(ndc, 1./iResolution.y, 0.1)));\n            ndc.y = NDC.y;\n            func_idx = 1;\n        color = mix(color, vec3(1,0,0), SMAA(explicitSDF(ndc, 0.1/iResolution.y, 0.1)));       \n    }\n    else if (NDC.x > 0. && NDC.x < 1.)\n    {\n        func_idx = 2;\n        color = mix(color, vec3(1,0,1), SMAA(explicitSDF(NDC, 1./iResolution.y, 0.1)));\n    }\n\n    /* UV parameter picker. */\n    color = mix(color, vec3(0.5), SMAA(diskSDF(NDC, MP, 0.01)));\n    \n    /* Mapping path */\n    float y_in = 0.5, y_out = waveshaper(y_in);   \n    color = mix(color, vec3(0.8), SMAA(arrowSDF(NDC, vec2(1, y_in*0.5+0.5), vec2(y_in, 0),      0.)));\n    color = mix(color, vec3(0.7), SMAA(arrowSDF(NDC, vec2(0, y_out),        vec2(1, y_out*0.5), 0.)));\n    color = mix(color, vec3(0.6), SMAA(arrowSDF(NDC, vec2(y_in, 0),         vec2(y_in, y_out),  0.)));\n    color = mix(color, vec3(0.5), SMAA(arrowSDF(NDC, vec2(y_in, y_out),     vec2(0, y_out),     0.)));\n    /**/\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float linear_remap(float val, vec2 from, vec2 to)\n{\n    // inverse linear map from [from.x; from.y] to [0; 1].\n    val = (val - from.x) / (from.y - from.x);\n    // linear map from [0; 1] to [to.x; to.r].\n    return val * (to.y - to.x) + to.x;        \n}\n\n// https://www.shadertoy.com/view/cdjXRG\n//float cross_2d(vec2 L, vec2 R) { return L.x*R.y - L.y*R.x; }\nfloat cross_2d(vec2 L, vec2 R) { return determinant(mat2(L, R)); }\nvec2 segment_segment_intersection(vec2 P0, vec2 P1, vec2 P2, vec2 P3)\n{\n    /* Variant 1: *\n    float a = P1.x - P0.x, // A.x\n          b = P3.x - P2.x, // B.x\n          \n          c = P1.y - P0.y, // A.y\n          d = P3.y - P2.y, // B.y\n          \n          e = P2.x - P0.x, // C.x\n          f = P2.y - P0.y; // C.y        \n    return vec2(\n        (e*d-b*f)/(a*d-b*c),\n        (c*e-a*f)/(a*d-c*b) );\n        \n    /* Variant 2: *\n    vec2 A = P1 - P0, B = P3 - P2, C = P2 - P0;\n    float inv = 1. / (A.x*B.y-A.y*B.x);\n    return vec2(\n        (B.y*C.x-B.x*C.y)*inv,\n        (A.y*C.x-A.x*C.y)*inv);\n        \n    /* Variant 3: */\n    vec2 A = P1 - P0, B = P3 - P2, C = P2 - P0;\n    float inv = 1. / cross_2d(A, B);\n    return vec2(\n        cross_2d(C, B)*inv,\n        cross_2d(C, A)*inv);\n}\n\nfloat diskSDF(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\nfloat vertical_lineSDF(vec2 NDC, float x0) { return abs(NDC.x-x0); }\nfloat horizontal_lineSDF(vec2 NDC, float y0) { return abs(NDC.y-y0); }\nfloat cellsSDF(vec2 NDC)\n{\n    //NDC *= 10.; // Finer cells\n    NDC = fract(NDC);\n    NDC = fract(min(NDC, 1. - NDC));\n    return\n        min(vertical_lineSDF(NDC, 0.), horizontal_lineSDF(NDC, 0.));\n}\nfloat segmentSDF(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}\nfloat arrowSDF(\n    in vec2 NDC,\n    in vec2 B,\n    in vec2 E,\n    in float R)\n{\n    float len = length(B-E);    \n    vec2 dir = normalize(E-B),\n         //up = cross(vec3(dir, 0.), vec3(0, 0, -1)).xy,   \n         up = vec2(-dir.y, dir.x),\n         C = E - dir * 0.0275, //      U--\n         U = C + up  * 0.010,  // B----C----E\n         D = C - up  * 0.010;  //      D--\n    \n    vec3 BARY = inverse(mat3(\n            U.x, U.y, 1.0,\n            D.x, D.y, 1.0,\n            E.x, E.y, 1.0)) * vec3(NDC.x, NDC.y, 1.0);\n    \n    float sign = \n        BARY.x >= 0.0 &&    \n        BARY.y >= 0.0 && \n        BARY.z >= 0.0 ?  // inside triangle?\n            -1. : 1.;\n    \n    float d = segmentSDF(NDC, U, D, 0.);\n          d = min(d, segmentSDF(NDC, U, E, 0.));\n          d = min(d, segmentSDF(NDC, D, E, 0.));\n          d = \n              len < 0.0275 ? \n                  d :\n                  min(d, segmentSDF(NDC, B, C, 0.));\n    \n    return sign*d-R;           \n}","name":"Common","description":"","type":"common"}]}