{"ver":"0.1","info":{"id":"Xd3Gzl","date":"1451518775","viewed":119,"name":"Metabolic","username":"Avo","description":"Playing with raymarching for the first time.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","blending"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"/// Credit to Iq for having such great examples :)\n\n\n///Distance functions\nfloat sphereDist(vec3 point, float r)\n{\n    return length(point) - r;\n}\n\nfloat planeDist(vec3 point, vec3 n, float d)\n{\n    return (dot(point, n) + d) / dot(n, n);\n}\n\n///Operators\nfloat smoothBlend(float a, float b, float k)\n{\n    float res = exp(-k * a) + exp(-k * b);\n    return -log(res) / k;\n}\n\nvec2 unionOp(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nfloat fluidHeight(float x, float z)\n{\n    vec2 dir = vec2(1,0);\n    vec2 pos = vec2(x,z);\n    float phase = 0.01;\n    float freq = 2.0;\n    float height = 0.0;\n    for (int i = 0; i < 5; ++i)\n    {\n        float fi = float(i);\n   \t\theight += cos(1.0 / (1.0 + fi) * freq * dot(dir, pos) + 100.0 * iTime * phase * fi);\n    }\n    \n    return height;\n}\n    \nvec2 map(vec3 point)\n{\n    //Ballthingy\n    float s = sin(iTime);\n    float c = s * cos(iTime);\n    float d1 = sphereDist(point,1.0);\n    float d2 = sphereDist(point + vec3(s,c,0),0.5);\n    float d3 = sphereDist(point + vec3(c,s,0),0.5);\n    float d4 = smoothBlend(smoothBlend(d1,d2,10.0), smoothBlend(d2,d3,10.0), 10.0);\n\tvec2 metaball = vec2(d4, 5.0);\n    \n    //Plane\n    d1 = planeDist(point, vec3(0,1,0), 2.0 + 0.1 * fluidHeight(point.x, point.z)); // + 0.1 * sin(20.0 * point.x));\n    vec2 plane = vec2(d1, 1.0);\n\n    //Result\n    vec2 r = unionOp(metaball, plane);\n    return r;\n}\n\nvec3 grad(vec3 point)\n{\n    vec3 epsilon = vec3(0.001,0,0);\n    float dx = 0.5 * (map(point + epsilon.xzz).x - map(point - epsilon.xzz).x);\n    float dy = 0.5 * (map(point + epsilon.zxz).x - map(point - epsilon.zxz).x);\n    float dz = 0.5 * (map(point + epsilon.zzx).x - map(point - epsilon.zzx).x);\n    return normalize(vec3(dx,dy,dz));\n}\n\nmat3 base(vec3 eye, vec3 target, vec3 up)\n{\n    vec3 f = normalize(target - eye);\n    vec3 r = normalize(cross(f, up));\n    vec3 u = normalize(cross(r, f));\n    return mat3(r, u, f); \n}\n\nvec3 sky(float height, vec2 coord)\n{\n    coord.x += iTime * 0.1;\n    float cloud = 0.5 * texture(iChannel0, 0.5 * (1.0 + coord)).x; \n    return vec3(0.6,0.8,1.0) * (1.0 + height) + height * cloud;\n}\n\nvec2 raymarch(vec3 origin, vec3 dir)\n{\n    float dmin = 1.0;\n    float dmax = 20.0;\n    float step = dmin;\n    float epsilon = 0.001;\n    float m = -1.0;\n    for (int i = 0; i < 50; ++i)\n    {\n        vec3 point = origin + dir * step;\n        vec2 dist = map(point);   \n        if (dist.x < epsilon || step > dmax)\n        {         \n            break;\n        }\n        \n        m = dist.y;\n       \tstep += dist.x;\n    }    \n    \n    if (step > dmax)\n    {\n        m = -1.0;\n    }\n    \n    return vec2(step, m);\n}\n\nvec3 lighting(vec3 view, vec3 normal, vec3 light)\n{  \n    const vec3 skyc = vec3(0.16,0.20,0.28);\n    const vec3 sunc = vec3(1.64,1.27,0.99);\n    const vec3 indc = vec3(0.40,0.28,0.20);\n    const vec3 specc = vec3(1.0,1.0,1.0);\n   \n    float sun = clamp(dot(normal, light), 0.0, 1.0);\n    float sky = clamp(0.5 + 0.5 * normal.y, 0.0, 1.0);\n    float ind = clamp(dot(normal, normalize(light * vec3(-1.0,0.0,-1.0))), 0.0, 1.0);\n    \n    float spec = 0.0;\n    if (sun > 0.0)\n    {\n        vec3 refl = -normalize(reflect(view, normal));\n        vec3 h = normalize(refl + normal);\n        spec = max(dot(h, light), 0.0);\n        spec = pow(spec, 20.0);\n    }\n    \n    return sun * sunc + sky * skyc + ind * indc + spec * specc;\n}\n\nvec3 render(vec3 origin, vec3 dir)\n{\n    vec2 dist = raymarch(origin, dir);\n    vec3 color = sky(dir.y, dir.xy);\n    vec3 pos = origin + dist.x * dir;\n    vec3 normal = grad(pos);\n    \n    //If anything\n    if (dist.y > -0.5)\n    {\n        color = vec3(0.2,0.5,0.9); \n        \n        if (dist.y < 1.5)\n        {\n            color = vec3(0.43,0.43,0.38) + (1.0 - exp(-dist.x * 0.1)) * color + 0.1 * dist.y * vec3(0.2,0.2,0.6);\n            \n        }\n\n        color *= lighting(-normalize(dir), normal, normalize(vec3(0,1,-1)));\n    }\n    \n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pos = 2.0 * uv - 1.0;\n    pos.x *= iResolution.x / iResolution.y;\n    vec3 eye = vec3(0,0,-4);\n    vec3 target = vec3(0,0,0);\n    vec3 up = vec3(0,1,0);\n    vec3 dir = base(eye,target,up) * normalize(vec3(pos,2.0));\n\tfragColor = vec4(render(eye,dir),1.0);\n}","name":"","description":"","type":"image"}]}