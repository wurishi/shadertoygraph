{"ver":"0.1","info":{"id":"Nt33Rs","date":"1636526713","viewed":190,"name":"Ball in Fog","username":"LuncyTB","description":"draw some balls and cube with raytrace.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytrace","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Copyright (c) 2021 LuncyTB. All rights reserved.\n */\n\nvec3 light0 = normalize(vec3(3.0, -6, 2.0));\nfloat light0Force = 0.33;\nvec3 light0Color = vec3(1.0, 0.9, 0.7);\nvec3 fog = vec3(0.35, 0.38, 0.42);\nfloat far = 10.0;\nfloat spaceFar = 20.0;\nfloat env = 1.0;\nfloat fov = 0.7;\nfloat merge = 8.0;\n\nstruct material\n{\n    vec3 color;\n    float smoothness;\n    float metallic;\n    vec3 emission;\n};\n\nstruct pix\n{\n    float z;\n    vec3 vr;\n    vec3 normal;\n    vec3 color;\n    float smoothness;\n    float metallic;\n    vec3 emission;\n};\n\nmat3 rotate(in vec3 rot)\n{\n    float z = radians(rot.z);\n    float x = radians(rot.x);\n    float y = radians(rot.y);\n    float cz = cos(z), sz = sin(z);\n    float cx = cos(x), sx = sin(x);\n    float cy = cos(y), sy = sin(y);\n    return mat3(cz * cy - sz * sy  * sx, -sz * cy - sy * sx * cz, -sy * cx,\n        sz * cx, cx * cz, -sx,\n        sy * cz + cy * sx * sz, -sz * sy + cy * sx * cz, cy * cx);\n}\n\npix castSphere(in vec3 viewDir, in vec3 pos, in float r, in material matr)\n{\n    pix o;\n    \n    vec3 dis = pos;\n    vec3 vr = viewDir * abs(dot(viewDir, dis));\n    float x = distance(dis, vr);\n    \n    if (x < r)\n    {\n        float y = sqrt(abs(r * r - x * x));\n        o.z = min(spaceFar, length(vr) - y);\n        if (o.z > 0.0)\n        {\n            vr = viewDir * o.z;\n            o.vr = vr;\n            o.normal = normalize(vr - dis);\n            o.color = matr.color;\n            o.metallic = matr.metallic;\n            o.smoothness = matr.smoothness;\n            o.emission = matr.emission;\n        }\n        else\n        {\n            o.z = spaceFar;\n        }\n    }\n    else\n    {\n        o.z = spaceFar;\n    }\n    \n    return o;\n}\n\npix castFace(in vec3 viewDir, in vec3 pos, in mat3 rot, in vec2 wh, in material matr)\n{\n    vec3 vr = viewDir;\n    vec3 org = -pos;\n    vec3 nor = vec3(0.0, 1.0, 0.0);\n    \n    pix p;\n    \n    vr = vr * rot;\n    org = org * rot;\n    \n    if (vr.y < 0.0 && org.y > 0.0)\n    {\n        nor = rot * nor;\n        vec3 touch = vr * org.y / -vr.y + org;\n        if (abs(touch.x) < wh.x && abs(touch.z) < wh.y)\n        {\n            p.z = length(touch - org);\n            p.vr = viewDir * p.z;\n            p.normal = nor;\n            p.color = matr.color;\n            p.metallic = matr.metallic;\n            p.smoothness = matr.smoothness;\n            p.emission = matr.emission;\n        }\n        else\n        {\n            p.z = spaceFar;\n        }\n    }\n    else\n    {\n        p.z = spaceFar;\n    }\n    \n    return p;\n}\n\npix mixm(pix a, pix b, float l)\n{\n    pix c;\n    c.z = mix(a.z, b.z, l);\n    c.vr = mix(a.vr, b.vr, l);\n    c.normal = normalize(mix(a.normal, b.normal, l));\n    c.color = mix(a.color, b.color, l);\n    c.metallic = mix(a.metallic, b.metallic, l);\n    c.smoothness = mix(a.smoothness, b.smoothness, l);\n    c.emission = mix(a.emission, b.emission, l);\n    return c;\n}\n\nvoid update(in pix n, inout pix todraw)\n{\n    if (n.z >= far) return;\n    if (todraw.z >= far) { todraw = n; return; }\n    float oz = todraw.z;\n    vec3 onor = todraw.normal;\n    float diff = (oz - n.z) * 30.0;\n    float lerp = diff > 0.0 ? pow(merge, -diff) / 2.0 : 1.0 - pow(merge, diff) / 2.0;\n    if (n.z < todraw.z)\n    {\n        // todraw = n;\n        todraw = mixm(n, todraw, lerp);\n        // todraw.z -= pow(0.6, lerp);\n        \n    }\n    else\n    {\n        todraw = mixm(n, todraw, lerp);\n        // todraw.z -= pow(0.6, lerp);\n    }\n}\n\nvoid cube(in vec3 viewDir, in vec3 pos, in mat3 rot, in vec3 size, in material matr, inout pix p)\n{\n    vec3 lr = vec3(-size.x, 0.0, 0.0);\n    vec3 bt = vec3(0.0, -size.y, 0.0);\n    vec3 bf = vec3(0.0, 0.0, -size.z);\n    mat3 r4 = rotate(vec3(90.0, 0.0, 0.0));\n    mat3 _r4 = rotate(vec3(0.0, -90.0, 0.0));\n    mat3 rt = rotate(vec3(180.0, 0.0, 0.0));\n    update(castFace(viewDir, pos - rot * lr, rot * _r4 * r4, size.zy, matr), p);\n    update(castFace(viewDir, pos - rot * bf, rot * _r4 * _r4 * r4, size.xy, matr), p);\n    update(castFace(viewDir, pos + rot * lr, rot * _r4 * _r4 * _r4 * r4, size.zy, matr), p);\n    update(castFace(viewDir, pos + rot * bf, rot * _r4 * _r4 * _r4 * _r4 * r4, size.xy, matr), p);\n    update(castFace(viewDir, pos - rot * bt, rot, size.xz, matr), p);\n    update(castFace(viewDir, pos + rot * bt, rot * rt, size.xz, matr), p);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - vec2(iResolution.x, iResolution.y) * 0.5)\n        / min(iResolution.x, iResolution.y);\n    \n    vec3 viewDir = normalize(vec3(uv, fov));\n    float mr = (iMouse.x - 13.) / 90.0;\n    mat2 mouseRot = mat2(cos(mr), -sin(mr), sin(mr), cos(mr));\n    vec2 xz = mouseRot * viewDir.xz;\n    viewDir = vec3(xz.x, viewDir.y, xz.y);\n    \n    vec3 col;\n    \n    material matr1 = material(vec3(1.0, 0.75, 0.5), 0.4, 0.06, vec3(0.0));\n    material matr2 = material(vec3(1.0, 0.5, 0.7), 0.99, 0.81, vec3(0.0));\n    material matr3 = material(vec3(0.7, 0.9, 1.0), 0.1, 1.0, vec3(0.0));\n    material matr4 = material(vec3(1.0, 1.0, 1.0), 0.001, 0.0, vec3(0.0));\n    material matr5 = material(vec3(1.0, 1.0, 1.0), 0.01, 0.1, vec3(0.3, 0.7, 0.5));\n    material matr6 = material(vec3(0.8, 1.0, 0.95), 0.9, 0.9, vec3(0.0));\n    \n    pix p = castSphere(viewDir, vec3(0.4, 0.1 + cos(iTime) * 0.4, 2.0), 0.4, matr1);\n    update(castSphere(viewDir, vec3(0.7, 0.0 + cos(iTime + 0.3) * 0.2, 1.8), 0.2, matr2), p);\n    update(castSphere(viewDir, vec3(0.8, -0.1 + cos(iTime + 0.78) * 0.3, 1.7), 0.14, matr3), p);\n    update(castSphere(viewDir, vec3(-0.5, 0.1 + cos(iTime - 1.45) * 0.1, 0.7), 0.14, matr2), p);\n    update(castSphere(viewDir, vec3(-0.3, 0.3 + cos(iTime + 3.23) * 0.2, 5.7), 0.34, matr3), p);\n    update(castSphere(viewDir, vec3(-1.36, 0.24 + cos(iTime - 0.99) * 0.33, 4.7), 0.44, matr4), p);\n    update(castSphere(viewDir, vec3(-1.36, -0.14 + cos(iTime - 0.54) * 0.24, 4.7), 0.24, matr5), p);\n    \n    // update(castFace(viewDir, vec3(-0.6, -0.0, 0.6), rotate(vec3(30.0, 20.0, 10.0)), vec2(0.2, 0.2), matr6), p);\n    \n    cube(viewDir, vec3(-0.6, 0.13, 0.78), rotate(vec3(0.0 + iTime * 4.0, 0.0 + iTime * 10.0, 0.0)), vec3(0.2, 0.2, 0.2), matr4, p);\n    cube(viewDir, vec3(-0.0, -0.43, 1.78), rotate(vec3(0.0 + iTime * 4.0, 0.0 + iTime * 10.0, 0.0)), vec3(0.2, 0.2, 0.2), matr6, p);\n    cube(viewDir, vec3(-0.0, -0.43, 1.78), rotate(vec3(0.0 + iTime * 4.0, 0.0 + iTime * 10.0, 0.0)), vec3(0.3, 0.1, 0.1), matr5, p);\n    cube(viewDir, vec3(-0.0, -0.43, 1.78), rotate(vec3(0.0 + iTime * 4.0, 0.0 + iTime * 10.0, 0.0)), vec3(0.1, 0.3, 0.1), matr5, p);\n    cube(viewDir, vec3(-0.0, -0.43, 1.78), rotate(vec3(0.0 + iTime * 4.0, 0.0 + iTime * 10.0, 0.0)), vec3(0.1, 0.1, 0.3), matr5, p);\n    \n    if (p.z < far)\n    {\n        float spl = p.smoothness * 110.0;\n        vec3 ref = reflect(viewDir, p.normal);\n        col = (1.0 - p.metallic) * p.color * light0Color * light0Force * max(0.0, dot(-light0, p.normal)) + \n            p.color * textureLod(iChannel0, ref, (pow(max(0.0, dot(-p.vr, p.normal)), 0.3) * 0.9 + 0.1) * (1.0 - p.smoothness) * 6.4).rgb * env * p.metallic + \n            p.color * textureLod(iChannel0, ref, 10.0).rgb * env * (1.0 - p.metallic) + \n            pow(max(0.0, dot(-light0, ref)), spl) * 3.0 * pow(p.smoothness, 0.6) * pow(p.metallic, 0.25) * light0Color * light0Force;\n        col += p.emission;\n        col = mix(col, fog, p.z / spaceFar);\n    }\n    else\n    {\n        col = texture(iChannel0, viewDir).rgb * env;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col, p.vr.z / spaceFar);\n}","name":"Image","description":"","type":"image"}]}