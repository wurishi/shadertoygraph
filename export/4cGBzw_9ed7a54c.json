{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// Parameters\n#define MAX_MARCH_STEPS    400\n#define MIN_MARCH_DISTANCE 0.00025\n\n#define MAX_SHADOW_MARCH_STEPS    20\n#define MIN_SHADOW_MARCH_DISTANCE 0.001\n\n#define AO_MARCH_STEPS 20\n#define AO_POWER       2.0\n#define AO_ITERATIONS  4\n\n#define DISTANCE_ESTIMATOR_ITERATIONS 50\n#define DISTANCE_ESTIMATOR_BAILOUT    4.0\n#define DISTANCE_ESTIMATOR_POWER      8.0\n\n#define CAMERA_DISTANCE     1.4\n#define CAMERA_ROTATE_SPEED 0.1\n\n#define PHASE_SHIFT\n#define PHASE_SHIFT_SPEED 0.05\n\nconst vec3 BACKGROUND_COLOR = vec3(0.4, 0.2, 0.3);\n\n// Code from here:\n// http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nfloat distanceEstimator(vec3 pos) {\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n    \n    const float power = DISTANCE_ESTIMATOR_POWER;\n\n\tfor (int i = 0; i < DISTANCE_ESTIMATOR_ITERATIONS; ++i) {\n\t\tr = length(z);\n\t\tif (r > DISTANCE_ESTIMATOR_BAILOUT) break;\n\t\t\n\t\t// convert to polar coordinates\n        #ifdef PHASE_SHIFT\n\t\tfloat theta = acos(z.z/r) + iTime * PHASE_SHIFT_SPEED;\n        #else\n        float theta = acos(z.z/r);\n        #endif\n        \n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr = pow(r, power - 1.0) * power * dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow(r, power);\n\t\ttheta = theta * power;\n\t\tphi = phi * power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n\t\tz += pos;\n\t}\n\n\treturn 0.5 * log(r) * r / dr;\n}\n\n// Raymarching loop\nvec2 march(vec3 from, vec3 direction, out bool converged) {\n\tfloat totalDistance = 0.0;\n    int steps = 0;\n\n    converged = false;\n\n\tfor (; steps < MAX_MARCH_STEPS; ++steps) {\n\t\tvec3 p = from + totalDistance * direction;\n\t\tfloat dist = distanceEstimator(p);\n\t\ttotalDistance += dist;\n\t\tif (dist < MIN_MARCH_DISTANCE) {\n            converged = true;\n            break;\n        }\n\t}\n    \n    float stepRatio = float(steps) / float(MAX_MARCH_STEPS);\n\n    return vec2(totalDistance, stepRatio);\n}\n\n// Calculate normal using Tetrahedron technique\n// Code from here: https://iquilezles.org/articles/normalsSDF/\nvec3 calculateNormal(vec3 p) {\n    float h = 0.0001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy * distanceEstimator( p + k.xyy * h ) + \n                      k.yyx * distanceEstimator( p + k.yyx * h ) + \n                      k.yxy * distanceEstimator( p + k.yxy * h ) + \n                      k.xxx * distanceEstimator( p + k.xxx * h ) );\n}\n\n\n\n\nvec3 calculateAlbedo(float stepRatio) {\n    vec3 albedo = hsv2rgb(vec3(7.0 * stepRatio, 0.6, 1.0));\n    return (1.0 - stepRatio) * albedo;\n}\n\n// Code from here: \n// https://www.shadertoy.com/view/MdXSWn\nfloat softShadow(vec3 ro, vec3 rd, float k) { \n    float result = 1.0;\n\tfloat t = 0.01;\n\n    for(int i = 0; i < MAX_SHADOW_MARCH_STEPS; ++i) {\n        float h = distanceEstimator(ro + rd * t);\n        if (h < MIN_SHADOW_MARCH_DISTANCE) return 0.02;\n\n        result = min(result, k * h / t);\n \t\tt += clamp(h, 0.01, 2.0);\n    }\n\n    return result;\n}\n\n\n// Ambient occlusion\n// Inspired by https://www.shadertoy.com/view/XlXyD4, but using much fewer directions\nconst vec3 AO_DIRS[AO_ITERATIONS] = vec3[AO_ITERATIONS](\n\tvec3(0.357407, 0.357407, 0.862856),\n\tvec3(-0.357407, 0.357407, -0.862856),\n\tvec3(0.357407, -0.357407, 0.862856),\n\tvec3(-0.357407, -0.357407, 0.862856)\n);\n\nfloat ao(vec3 p, vec3 dir) {\n    float dist = 0.01;\n    float occ = 1.0;\n    \n    for (int i = 0; i < AO_MARCH_STEPS; ++i) {\n        occ = min(occ, distanceEstimator(p + dist * dir) / dist);\n        dist *= AO_POWER;\n    }\n    \n    occ = max(occ, 0.0);\n    return occ;\n}\n\n\n\nvec3 render(vec3 from, vec3 direction) {\n    // Raymarch on the distance estimator\n    bool converged;\n    vec2 marchResult = march(from, direction, converged);\n\n    vec3 color = BACKGROUND_COLOR;\n\n    if (converged) {\n        float totalDistance = marchResult.x;\n        float stepRatio = marchResult.y;\n\n        vec3 endPoint = from + totalDistance * direction;\n\n        vec3 normal = calculateNormal(endPoint);\n\n        vec3 lightDir1 = normalize(vec3(0.1, 0.8, 0.6));\n        vec3 lightDir2 = normalize(vec3(-0.5, 0.2, -0.5));\n\n        // Calculate shadow\n        float diffuse = softShadow(endPoint, lightDir1, 2.5)\n                      + softShadow(endPoint, lightDir2, 2.5);\n\n        // Calculate ambient occlusion\n        float occlusion = 0.0;\n        for (int i = 0; i < AO_ITERATIONS; ++i) {\n            occlusion += ao(endPoint, AO_DIRS[i]);\n        }\n        occlusion = pow(0.5 * occlusion, 0.5);\n\n        // Calculate result\n        color = calculateAlbedo(stepRatio) * diffuse * occlusion;\n    }\n\n    return color;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n\n    // Camera\n    float camAngle    = iTime * CAMERA_ROTATE_SPEED;\n    float camDistance = CAMERA_DISTANCE;\n    \n    mat2 rotMatrix = rot2D(camAngle);\n    \n    vec2 camOriginInXZPlane = rotMatrix * vec2(0.0, 1.0);\n    vec3 camOrigin = camDistance * vec3(camOriginInXZPlane.x, 0.0, camOriginInXZPlane.y);\n    \n    vec3 camDirection = normalize(vec3(uv, 1.0));\n    camDirection.xz = rotMatrix * -camDirection.xz; // Invert direction to point towards the center\n\n    // Calculate final color\n    vec3 color = render(camOrigin, camDirection);\n    \n    // Vignette\n    float vignetteStrength = pow(length(0.45 * uv), 1.5);\n    color *= vec3(1. - vignetteStrength);\n    \n    // Gamma correction\n    color = pow(color, vec3(0.65));\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"// 2D rotation matrix\nmat2 rot2D(float a) {\n    return mat2(\n        cos(a), -sin(a), \n        sin(a), cos(a)\n    );\n}\n\n#ifndef saturate\n#define saturate(v) clamp(v,0.,1.)\n#endif\n\n//HSV (hue, saturation, value) to RGB.\n//Sources: https://gist.github.com/yiwenl/745bfea7f04c456e0101, https://gist.github.com/sugi-cho/6a01cae436acddd72bdf\nvec3 hsv2rgb(vec3 c){\n\tvec4 K = vec4(1., 2./3., 1./3., 3.);\n\treturn c.z * mix(K.xxx, saturate(abs(fract(c.x + K.xyz) * 6. - K.w) - K.x), c.y);\n}","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4cGBzw","date":"1733845985","viewed":73,"name":"Mandelbulb Fractal (Shaded)","username":"jarvarvarvis","description":"Inspired by http://blog.hvidtfeldts.net/index.php/2011/06/distance-estimated-3d-fractals-part-i/","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","mandelbulb"],"hasliked":0,"parentid":"","parentname":""}}