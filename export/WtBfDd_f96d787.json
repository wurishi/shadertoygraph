{"ver":"0.1","info":{"id":"WtBfDd","date":"1600119820","viewed":429,"name":"Triangle Grid Traversal","username":"fizzer","description":"Simple and robust triangle grid traversal. It's similar in nature to IQ's hexagon traversal: [url]https://www.shadertoy.com/view/WtSfWK[/url].\nThis was put together quickly, so it's not as polished but takes some inspiration in the visuals too. :)","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["grid","prism","triangular","traversal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.14159265358979323;\n\nconst mat3x2 m = mat3x2(vec2(2, 0), vec2(-1., +sqrt(3.)), vec2(-1., -sqrt(3.))) / 2.;\n\nfloat heightField(ivec2 uv)\n{\n    return cos(texelFetch(iChannel1, (uv * 2) & 255, 0).r * pi * 12. + iTime / 2.) * .9 +\n        \tcos(float(uv.x) + iTime * 2.) * .15;\n}\n\nvec4 traceTriangleGrid(vec3 ro, vec3 rd, out vec2 texuv, out ivec2 triID, int max_steps)\n{\n    vec3 ds = ro.xz * m;\n    vec3 rs = rd.xz * m;\n    \n    vec3 cell = floor(ds);\n    vec3 p = cell + max(sign(rs), 0.);\n    \n    vec3 q = (p - ds) / rs;\n    vec3 dr = abs(vec3(1) / rs);\n    vec3 pos = ro;\n    \n    float inv_ry = 1. / rd.y;\n    float mint = 0.;\n    float h;\n\n    int faceID;\n    \n    rs = sign(rs);\n    \n    for(int i = 0; i < max_steps; ++i)\n    {\n        triID = ivec2(cell.x * 2. + mod(cell.z, 2.), cell.y);\n        \n        h = heightField(triID) - ro.y;\n        \n        if(rd.y * mint < h)\n            break;\n        \n        mint = min(q.x, min(q.y, q.z));\n        \n        float ht = h * inv_ry;\n        \n        if(h < 0. && ht > 0. && ht < mint)\n        {\n            texuv = ro.xz + rd.xz * ht;\n            return vec4(vec3(0, 1, 0), ht);\n        }\n\n        if(q.x < q.y && q.x < q.z)\n            faceID = 0;\n        else if(q.y < q.z)\n            faceID = 1;\n        else\n            faceID = 2;\n        \n        q[faceID] += dr[faceID];\n        cell[faceID] += rs[faceID];\n    }\n\n    pos = ro + rd * mint;\n    \n    texuv.x = dot(pos.xz, m[faceID].yx * vec2(-1, 1));\n    texuv.y = pos.y - h - ro.y;\n        \n    vec3 normal;\n    normal.xz = m[faceID];\n    normal.y = 0.;\n    return vec4(normal, mint);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y * 2.;\n\n    // Camera position and target.\n    vec3 campos = vec3(0., 5.2, iTime);\n    vec3 camtarget = vec3(cos(iTime / 3.) * 3., -1.5, iTime + 8.);\n\tvec3 ro = campos, rd = normalize(vec3(uv, 1.8));\n    \n    // Camera lookat.\n    vec3 w = normalize(camtarget - campos);\n    vec3 u = normalize(cross(vec3(0, 1, 0), w));\n    vec3 v = cross(w, u);\n    rd = mat3(u, v, w) * rd;\n\n    vec2 texuv;\n    ivec2 triID;\n    \n    vec4 res = traceTriangleGrid(ro, rd, texuv, triID, 120);\n    \n    if(dot(res.xyz, rd) > 0.)\n        res.xyz = -res.xyz;\n    \n    vec3 p = ro + rd * res.w;\n\n    vec3 ld = normalize(vec3(-2.2, 4, -1.5));\n    float wrap = .5 + .5 * dot(res.xyz, ld);\n\n    vec2 dummy_texuv;\n    ivec2 dummy_triID;\n    vec4 shadow_res = traceTriangleGrid(p + res.xyz * 1e-4, ld, dummy_texuv, dummy_triID, 10);\n    \n    if(shadow_res.w < 4.)\n        wrap *= .5;\n\n    vec3 col = vec3(1);\n    \n    col = mix(col, vec3(1, 0, 0), pow(texelFetch(iChannel0, (triID + 20) & 255, 0).r, 3.));\n    col = mix(col, vec3(0, 0, 0), texelFetch(iChannel0, (triID + 80) & 255, 0).r * 0.9);\n    col *= texture(iChannel1, texuv).rgb;\n    \n    col *= wrap;\n    \n    vec3 refl = reflect(rd, res.xyz);\n    \n    vec4 refl_res = traceTriangleGrid(p + res.xyz * 1e-4, refl, dummy_texuv, dummy_triID, 10);\n    \n    vec3 spec = texture(iChannel2, refl).rgb * step(4., refl_res.w);\n    \n    float fr = mix(.08, .25, pow(max(0., 1. - dot(-rd, res.xyz)), 3.));\n    \n    col = mix(col, spec, fr);\n    \n    fragColor = vec4(sqrt(col * 1.5), 1.0);\n}","name":"Image","description":"","type":"image"}]}