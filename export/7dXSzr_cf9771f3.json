{"ver":"0.1","info":{"id":"7dXSzr","date":"1618197628","viewed":142,"name":"Improved Perlin Noise 2D","username":"khalladay","description":"Implementation of \"Improved\" Perlin Noise in 2D. Reference Paper: https://mrl.cs.nyu.edu/~perlin/paper445.pdf","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["noise","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//A heavily commented 2D implementation of \"Improved\" Perlin Noise\n//from Ken Perlin's 2002 Paper (https://www.shadertoy.com/view/4djSRW)\n\n//The basic gist of perlin noise is that every coordinate in space can be thought of as\n//existing on a grid of unit cubes (or squares in 2D). So coord (2.5, 1.24) is within square\n//(2,1). \n\n//The basic algorithm is: \n// 1. Determine the unit square the sample point is within\n// 2. For each corner of that cube, calculate a \"gradient\" vector (random vector value) \n// 3. Also calculate the \"distance\" vector from each corner to the sample point\n// 4. Calculate the dot product between each gradient and corresponding distance vector\n// 5. Blend these dot products together based on a \"fade\" value, determined from the sample point\n\n\n#define NUM_OCTAVES 4\n#define UV_SCALE 15.0\n\n//uncomment below for original recipe perlin noise\n//#define OLD_PERLIN\n\n//not perfect, but the best looking hash function that I found after\n//trying out a couple. No jarring discontinuities as UVs scroll and less\n//repetitive than others I tried. Taken from https://www.shadertoy.com/view/4djSRW\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//the \"fade\" function defines the value used to blend values\n//from each corner of the unit cube\n//The \"Improving Noise\" paper updates\n//this from 3t^2-2t^3 to 6t^5-15t^4+10t^3\nfloat fade(float t)\n{\n#ifdef OLD_PERLIN\n    return t * t * (3.0-2.0*t);\n#else\n    return  t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n#endif\n}\n\n//original perlin noise calculates gradient functions randomly, whereas \"improved\" perlin\n//selects randomly from a fixed array of vectors.\nvec2 grad(vec2 p)\n{\n#ifdef OLD_PERLIN\n    return -1.0 + 2.0 *vec2(hash31(p.xyx), hash31(p.yxy));\n#else\n    float r = hash31(p.xyx)*8.0;\n    int ri = int(r);\n    \n    vec2 grads[8];\n    \n    grads[0] = vec2(1.0,1.0);\n    grads[1] = vec2(-1.0,-1.0);\n    grads[2] = vec2(1.0,-1.0);\n    grads[3] = vec2(-1.0,1.0);\n    \n    grads[4] = vec2(-1.0,0.0);\n    grads[5] = vec2(0.0,1.0);\n    grads[6] = vec2(0.0,-1.0);\n    grads[7] = vec2(1.0,0.0);\n\n    return grads[ri%8];\n#endif\n}\n\nfloat perlin(vec2 p)\n{\n    //floorP is used to generate the gradient vectors for the 4 corners of the unit cube\n    //that surround point p. Since we already need floorP, it's easier to get fractP\n    //via subtraction than a fract()\n    vec2 floorP = floor(p);\n    vec2 fractP = p - floorP;\n    \n    //calculate distance vectors from the input coordinate to the 4 corners of the unit cube\n    //these are used to weight the contributions from each corner's gradient vector\n    vec2 topLeft = fractP - vec2(0.0, 1.0);\n    vec2 topRight = fractP - vec2(1.0,1.0);\n    vec2 bottomLeft = fractP;\n    vec2 bottomRight = fractP - vec2(1.0,0.0);\n    \n    //determine gradient vectors for each corner of the cube\n    //must be uniform for all sample points within the same \"tile\" of the noise plane.\n    //(so (2.4,1.2)'s gradient vectors will be the same as (2.7,1.6)'s)\n    vec2 topLeftGrad = grad(floorP + vec2(0.0,1.0));\n    vec2 topRightGrad = grad(floorP + vec2(1.0,1.0));\n    vec2 bottomLeftGrad = grad(floorP);\n    vec2 bottomRightGrad = grad(floorP + vec2(1.0,0.0));\n    \n    float g1 = dot(topLeft, topLeftGrad);\n    float g2 = dot(topRight, topRightGrad);\n    float g3 = dot(bottomLeft, bottomLeftGrad);\n    float g4 = dot(bottomRight, bottomRightGrad);\n    \n    //mix 2 bottom influences together, left to right, according to fade(fractP.x)\n    //then blend them bottom to top according to fade(fractP.y)\n    return mix( mix(g3,g4,fade(fractP.x)), mix(g1,g2,fade(fractP.x)), fade(fractP.y) );\n}\n\nfloat fbm( in vec2 x)\n{    \n    float H = 1.0;\n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<NUM_OCTAVES; i++ )\n    {\n        t += a*perlin(f*x);\n        f *= 2.0;\n        a *= -G/1.5;\n    }\n    return t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy; //normalized uv (from 0 to 1)\n    vec2 uv = p * vec2(iResolution.x/iResolution.y, 1.0); //adjust for aspect ratio\n\n    //scroll uv over time\n    uv += vec2(iTime*0.5,0.0);\n       \n    // Time varying pixel color\n    vec3 col = vec3( fbm(uv*UV_SCALE) *0.5 + 0.5);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}