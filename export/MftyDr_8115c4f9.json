{"ver":"0.1","info":{"id":"MftyDr","date":"1730521238","viewed":273,"name":"Wave bloom","username":"ChunderFPV","description":".","likes":34,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarch","wave","blur","flower","buffer","cosmic","aquatic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"csc attractor\" by ChunderFPV. https://shadertoy.com/view/4f3yRM\n// 2024-11-02 02:19:03\n\n// blend\nvoid mainImage( out vec4 C, vec2 U ) { C = tanh( T1 + (T0(.2)+T0(2.))/2. ); }\n\n/*\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec4 a = texture(iChannel0, U/iResolution.xy, .2),  // buffer A with slight mipmap aa\n         c = texture(iChannel0, U/iResolution.xy, 2.),  // buffer A with heavy mipmap aa\n         b = texture(iChannel1, U/iResolution.xy);      // buffer B\n    C = tanh(b + (a+c)*.5);  // combine layers, tanh limits brightness to 1\n}\n*/","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define A(v) mat2(cos(m.v*3.1416 + vec4(0, -1.5708, 1.5708, 0)))    // rotate\n#define O(x,a,b) ((cos((x)*6.2832)*.5+.5)*(a-b)+b)                  // oscillate x between a & b\n#define H(v) (cos((v)*6.2832 + radians(vec3(-20, 70, 140)))*.5+.5)  // hue\n\n// quick 2d hex coords (by Fabrice)\nvec2 hex(vec2 u)\n{\n    vec2 o = vec2(.5, .866),\n         a = mod(u,   o+o)-o,\n         b = mod(u-o, o+o)-o;\n    return dot(a,a) < dot(b,b) ? a : b;\n}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    float t = 5.5 + iTime/4.,         // start time & speed\n          y = t/10.,                  // oscillation time\n          n = O(y, 50., 20.)/6.2832,  // points per wavelength\n          f = O(y,  7., 10.),         // wave spacing\n          e = O(y,  1.,  2.),         // point spacing\n          i = 0., d = i, s, z, a, b, r, w, j;\n    \n    vec2 //R = iResolution.xy,  // set in common\n         k = (U - R/2.)/R.y,            // 2d coords\n         m = (iMouse.z > 0.) ?          // clicking?\n               (iMouse.xy - R/2.)/R.y:  // mouse coords\n               vec2(t/7., sin(t)*.1);   // coords from time\n    \n    vec3 o = vec3(0, 0, -40),        // camera\n         u = normalize(vec3(k, 1)),  // 3d coords\n         c = vec3(0), p, q;\n    \n    r = dot(k, k);       // 2d radius²\n    k = k/r -m;          // transform coords & move with mouse\n    k = abs(hex(k*5.));  // 2d hex coords\n    c += .002*r*min(.03/abs(1.-max(k.x, dot(k, vec2(.5, .866)))*2.), 1.);  // draw hexagons\n    \n    mat2 v = A(y),  // pitch\n         h = A(x);  // yaw\n    \n    for (; i++<1e2;)  // raymarch\n    {\n        p = u*d;\n        s = 1.3-length(p);  // boolean the camera for when objects are close\n        p += o;\n        p.xz *= h;\n        p.yz *= v;\n        \n        z = max(sqrt(abs(p.z)), 1.)*.6;           // used to shade z\n        r = dot(p, p)/3e2;                        // 3d radius²\n        p /= r;                                   // transform coords\n        b = fract(p.z/1e2 -t/2.);                 // color coords\n        a = O(b-.35, .7, .0);                     // size & shade coords\n        \n        if (b < .4) q = p, w = .35, j = .4;       // tubes\n        else q = round(p/e)*e, w = a*.3, j = -.8; // spheres\n        \n        p.xy -= sin(q.z/n +t+vec2(0, 1.5708))*n;  // wave xy\n        p.xy = hex(p.xy/f)*f;                     // hex tile waves\n        s = max(s, length(p - q*vec3(0,0,1))-w);  // add to scene\n        \n        c += min(s, exp(-s/.07))   // black & white\n           / z                     // shade z\n           * H(j-b)                // color\n           * a;                    // shade color\n        \n        if (s < 1e-3 || d > 1e3) break;  // limits\n        d += s*r*.3;  // step\n    }\n    \n    C = vec4(max(sqrt(c)+c, 0.), 1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// frame blur (TAA)\nvoid mainImage( out vec4 C, vec2 U ) { C = mix( T0(0.), T1, .93 ); }\n\n/*\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    float s = .93;  // blur strength\n    C = texture(iChannel1, U/iResolution.xy)*s\n      + texture(iChannel0, U/iResolution.xy)*(1.-s);\n}\n*/","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define R     iResolution.xy\n#define T0(l) texture(iChannel0, U/R, l)\n#define T1    texture(iChannel1, U/R   )","name":"Common","description":"","type":"common"}]}