{"ver":"0.1","info":{"id":"WtGcRK","date":"1613447504","viewed":145,"name":"Ray Marching Jiggle","username":"BGrater","description":"Ray marching some simple shapes with a lil' jiggle.\n\nMouse (hold left click):  Move camera","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","artofcode"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_STEPS = 100;\nconst float MAX_DIST = 100.0;\nconst float SURF_DIST = 0.01;\n\nconst float CAM_AUTO_SPEED = 0.1;\nconst float MOUSE_SPEED = 8.0;\n\n\nmat2 Rot2D(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return mat2(c, -s, s, c);\n}\n\n\nfloat Sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n\nfloat Capsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0.0, 1.0);\n    \n    vec3 c = a + t * ab;\n    return length(p - c) - r;\n}\n\n\nfloat Cylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t * ab;\n    float x = length(p - c) - r;\n    float y = abs(t - 0.5) - length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    \n    return e + i;\n}\n\n\nfloat Torus(vec3 p, vec2 r)\n{\n    float x = length(p.xz) - r.x;\n    return length(vec2(x, p.y)) - r.y;\n}\n\n\nfloat Box(vec3 p, vec3 s)\n{\n    return length(max(abs(p) - s, 0.0));\n}\n\n\nfloat GetDist(vec3 p)\n{\n    // Jiggle\n    float st = sin((iTime - 2.0) * 0.5) * 3.0;\n    float mask = smoothstep(st - 1.0, st, p.x) * smoothstep(st + 1.0, st, p.x);\n    float jiggle = mask * sin((p.x + iTime) * 10.0) * 0.1;\n    \n    // Shapes\n    float planeDist = p.y;\n    float sphereDist = Sphere(p - vec3(-3.0, jiggle + 1.0, 1.0), 1.0);\n    float capsuleDist = Capsule(p - vec3(0.0, jiggle + 0.5, 1.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.5);\n    float cylinderDist = Cylinder(p - vec3(3.0, jiggle + 1.0, 1.0), vec3(0.0, 0.0, 0.4), vec3(0.0, 0.0, -0.4), 0.5);\n    float torusDist = Torus(p - vec3(-1.2, jiggle + 0.5, -1.0), vec2(0.7, 0.2));\n    float boxDist = Box(p - vec3(1.5, jiggle + 1.0, -1.0), vec3(0.5));\n    \n    float d = min(sphereDist, planeDist);\n    d = min(d, capsuleDist);\n    d = min(d, cylinderDist * 0.8);\n    d = min(d, torusDist);\n    d = min(d, boxDist * 0.5);\n    \n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    float dO = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * dO;\n        float dS = GetDist(p);\n        dO += dS;\n        \n        if(dO > MAX_DIST || abs(dS) < SURF_DIST)\n            break;\n    }\n    \n    return dO;\n}\n\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(0.01, 0.0);\n    \n    vec3 n = d - vec3(\n        GetDist(p - e.xyy),\n        GetDist(p - e.yxy),\n        GetDist(p - e.yyx));\n    \n    return normalize(n);\n}\n\n\nfloat GetLight(vec3 p)\n{\n    const vec3 lightPos = vec3(1.5, 6.0, -3.0);\n    \n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    float d = RayMarch(p + n * 0.02, l);\n    \n    if(d < length(lightPos - p))\n        dif *= 0.1;\n    \n    return dif;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Input\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    float mouseEnable = float(iMouse.xy != vec2(0.0));\n    \n    \n    // Camera\n    float camRot = (iTime - 7.0) * CAM_AUTO_SPEED;\n    float camHeight = 3.0;\n    \n    camHeight += mouseEnable * (-camHeight + (mouse.y * MOUSE_SPEED));\n    camRot += mouseEnable * (-camRot + (mouse.x - 0.5) * MOUSE_SPEED);\n    \n    vec3 camPos = vec3(0.0, camHeight, -5.0);\n    camPos.xz *= Rot2D(camRot);\n    \n    vec3 lookAt = vec3(0.0, 0.0, 0.5);\n    float zoom = 0.8;\n    \n    vec3 fwd = normalize(lookAt - camPos);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), fwd));\n    vec3 up = cross(fwd, right);\n    \n    \n    // Ray march\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 center = camPos + (fwd * zoom);\n    vec3 i = center + (uv.x * right) + (uv.y * up);\n    vec3 rayDir = normalize(i - camPos);\n    \n    float d = RayMarch(camPos, rayDir);\n    vec3 p = camPos + rayDir * d;\n    \n    float shade = GetLight(p);\n    vec3 col = vec3(shade);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}