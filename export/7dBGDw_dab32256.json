{"ver":"0.1","info":{"id":"7dBGDw","date":"1618151166","viewed":159,"name":"cg_task2","username":"sver","description":"Task: pyramid and flame","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["basicrt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv)/float(iFrame + 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float INF = 1e10;\nconst float AIR_N = 1.0;\nconst float GLASS_N = 1.5;\nconst vec3 CAMERA_POS = vec3(0, 1.2, -7);\nconst vec3 Light1_pos = vec3(2, 1, 0);\nconst float Light1_r = 0.25;\nconst vec3 Light1_col = vec3(1,1,0);\nconst float Light1_int = 20.0;\nconst vec3 Light2_pos = vec3(-2, 1.5, 1);\nconst float Light2_r = 0.25;\nconst vec3 Light2_col = vec3(0,1,1);\nconst float Light2_int = 20.0;\nconst vec3 Light3_pos = vec3(2, 1.5, 3);\nconst float Light3_r = 0.25;\nconst vec3 Light3_col = vec3(1,0,1);\nconst float Light3_int = 10.0;\nconst float k = 0.1;\nvec3 randDir;\n\nfloat powf(float x, int a) {\n    float q = x;\n    int i = a;\n    while (i-- > 1) q *= x;\n    return a == 0 ? 0.0 : q;\n}\n\nfloat noise(vec3 p) {\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1, 57, 21)) + vec4(0, 57, 21, 78);\n\tvec3 f = cos((p-i)*acos(-1.0))*(-0.5) + 0.5;\n\ta = mix(sin(cos(a)*a),sin(cos(1.0 + a)*(1.0 + a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z);\n}\n\nfloat rand(float frame) {\n    return fract(sin(dot(vec3(frame), vec3(12.9898, 78.233, 45.5432)))*43758.5453);\n}\n\nstruct Material {\n    float emission;\n    float diffusion;\n    float reflection;\n    float refraction;\n    float n;\n    int spectral_exp;\n    vec3 col;\n};\n\nstruct Sphere {\n    vec3 pos;\n    float radius;\n    Material m;\n};\n\nstruct Light {\n    Sphere sphere;\n    float intensity;\n};\n\nstruct Quad {\n    vec3 p[3];\n    Material m;\n};\n\nstruct Square {\n    vec3 v[4];\n};\n\nstruct Triangle {\n    vec3 vertecies[3];\n};\n\nstruct Pyramid {\n    vec3 vertecies[5];\n    vec3 center;\n    vec3 radius;\n    Material m;\n};\n\nstruct Scene {\n    Light[3] lights;\n    Pyramid pyramid;\n    Quad quad;\n} scene;\n\nfloat flame(vec3 p)\n{\n    float d = length(vec3(0, 1, 0) - p*vec3(1, 0.7, 1)) - 1.0;\n\treturn d + (noise(p + vec3(0, 5, 0)) + noise(p * 3.0)* 0.5)* 0.25 *(p.y) ;\n}\n\nvec4 raymarch(vec3 org, vec3 dir)\n{\n\tfloat d = 0.0, glow = 0.0, eps = 0.02;\n\tvec3  p = org;\n\tbool glowed = false;\n    float k = 64.0;\n\t\n\tfor(int i = 0; i < int(k); i++)\n\t{\n\t\td = min(150.0 - length(p), abs(flame(p))) + eps;\n\t\tp += d * dir;\n\t\tif (d > eps)\n\t\t{\n            glowed = glowed || flame(p) < 0.0;\n\t\t\tglow = glowed ? float(i)/k : 0.0;\n\t\t}\n\t}\n\treturn vec4(p,glow);\n}\n\nfloat tracePlane(vec3 camPos, vec3 dir, out vec3 N) {\n    float t = (-1.5 - camPos.y)/ dir.y;\n    vec3 worldPos = t * dir + camPos;\n    if (t < 0.0 || dot(worldPos.xz, worldPos.xz) > 100.0) return INF;\n    N = vec3(0, 1, 0);\n    return t;\n}\n\nfloat traceTriangle(vec3 pos, vec3 dir, Triangle tr, out vec3 N)\n{\n    const float EPSILON = 0.0000001;\n    vec3 vertex0 = tr.vertecies[0];\n    vec3 vertex1 = tr.vertecies[1];  \n    vec3 vertex2 = tr.vertecies[2];\n    vec3 edge1 = vertex1 - vertex0;\n    vec3 edge2 = vertex2 - vertex0;\n    vec3 h = cross(dir, edge2);\n    float a = dot(edge1, h);\n    if (a > -EPSILON && a < EPSILON) return INF;\n    float f = 1.0/a;\n    vec3 s = pos - vertex0;\n    float u = f * dot(s, h);\n    if (u < 0.0 || u > 1.0) return INF;\n    vec3 q = cross(s, edge1);\n    float v = f * dot(dir, q);\n    if (v < 0.0 || u + v > 1.0) return INF;\n    float t = f * dot(edge2, q);\n    if (t < EPSILON) return INF;\n    vec3 v1 = vertex2 - vertex0;\n    vec3 v2 = vertex1 - vertex0;\n    N = normalize(cross(v1,v2));\n    return t;\n}\n\nbool iBox(vec3 orig, vec3 dir, vec3 cen, vec3 rad ) \n{\n    vec3 m = 1.0/dir;\n    vec3 n = m*(orig-cen);\n    vec3 k = abs(m)*rad;\n  \n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n  \n    return !( tN > tF || tF < 0.0);\n}\n\nfloat tracePyramid(vec3 pos, vec3 dir, Pyramid p, out vec3 N) {\n    if (!iBox(pos, dir, p.center, p.radius)) return INF;\n    Triangle t1 = Triangle(vec3[3](p.vertecies[0], p.vertecies[1], p.vertecies[2]));\n    Triangle t2 = Triangle(vec3[3](p.vertecies[0], p.vertecies[2], p.vertecies[3]));\n    Triangle t3 = Triangle(vec3[3](p.vertecies[0], p.vertecies[3], p.vertecies[4]));\n    Triangle t4 = Triangle(vec3[3](p.vertecies[0], p.vertecies[4], p.vertecies[1]));\n    Triangle t5 = Triangle(vec3[3](p.vertecies[1], p.vertecies[2], p.vertecies[3]));\n    Triangle t6 = Triangle(vec3[3](p.vertecies[3], p.vertecies[4], p.vertecies[1]));\n    Triangle tr[6] = Triangle[6](t1, t2, t3, t4, t5, t6);\n    vec3 tmpN;\n    float t = INF;\n    for (int i = 0; i < tr.length(); i++) {\n        float triangleT = traceTriangle(pos, dir, tr[i], tmpN);\n        if (triangleT < t) {\n            t = triangleT;\n            N = tmpN;\n        }\n    }\n    return t;\n}\n\n\nfloat traceSphere(vec3 camPos, vec3 dir, Sphere s, out vec3 N) {\n    vec3 pos = camPos - s.pos;\n    float b = dot(pos, dir);\n    float D = b * b - dot(pos, pos) + s.radius * s.radius;\n    if (D < 0.0) return INF;\n    float t = -b - sqrt(D);\n    t = t < 0.0 ? -b + sqrt(D) : t;\n    if (t < 0.0) return INF;\n    N = normalize(pos + t * dir);\n    return t;\n}\n\nfloat traceplane(vec3 orig, vec3 dir, vec3 p0, vec3 p1, vec3 p2, out vec3 N) {\n    N = normalize(cross(p2-p0, p1-p0));\n    float denom = dot(N, dir);\n    if (abs(denom) < 0.0001f) return INF;\n    float t = dot(p0 - orig, N) / denom;\n    return t < 0.0 ? INF : t;\n}\n\n#define orient(a, b, c, N) dot(cross(b-a, c-a), N)\n\nfloat traceSquare(vec3 orig, vec3 dir, Square sq, out vec3 N) {\n    float t = traceplane(orig, dir, sq.v[0], sq.v[1], sq.v[3], N);\n    if (t == INF) return INF;\n    vec3 q = orig + dir * t;\n    float o1 = orient(q, sq.v[0], sq.v[1], N);\n    float o2 = orient(q, sq.v[1], sq.v[2], N);\n    float o3 = orient(q, sq.v[2], sq.v[3], N);\n    float o4 = orient(q, sq.v[3], sq.v[0], N);\n    if (o1 * o2 > 0.0 && o2 * o3 > 0.0 && o3 * o4 > 0.0) return t;\n    return INF;\n}\n\nfloat traceQuad(vec3 orig, vec3 dir, Quad q, out vec3 N) {\n    vec3 p0 = q.p[0];\n    vec3 p1 = q.p[1];\n    vec3 p2 = q.p[2];\n    vec3 a = p2 - p0;\n    vec3 b = p1 - p0;\n    vec3 c = normalize(cross(a,b)) * length(a);\n    vec3 cen = p0 + (a + b + c)/2.0;\n    vec3 r = vec3(length(a)/1.5);\n    if (!iBox(orig, dir, cen, r)) return INF;\n    vec3 p3 = p2 + b;\n    vec3 p4 = p0 + c;\n    vec3 p5 = p4 + b;\n    vec3 p6 = p4 + a;\n    vec3 p7 = p6 + b;\n    Square sq1 = Square(vec3[4](p0, p1, p3, p2));\n    Square sq2 = Square(vec3[4](p0, p4, p6, p2));\n    Square sq3 = Square(vec3[4](p2, p6, p7, p3));\n    Square sq4 = Square(vec3[4](p3, p7, p5, p1));\n    Square sq5 = Square(vec3[4](p1, p5, p4, p0));\n    Square sq6 = Square(vec3[4](p4, p5, p7, p6));\n    Square sq[6] = Square[6](sq1, sq2, sq3, sq4, sq5, sq6);\n    float t = INF;\n    vec3 tmpN;\n    for (int i = 0; i < sq.length(); i++) {\n        float tt = traceSquare(orig, dir, sq[i], tmpN);\n        if (tt < t) {\n            t = tt;\n            N = tmpN;\n        }\n    }\n    return t;\n}\n\nfloat traceScene(vec3 pos, vec3 dir, out vec3 N, out Material m) {\n    vec3 tmpN;\n    float t = INF;\n    float pyrT = tracePyramid(pos, dir, scene.pyramid, tmpN);\n    if (pyrT < t) {\n        t = pyrT;\n        N = tmpN;\n        m = scene.pyramid.m;\n    }\n    \n    float quadT = traceQuad(pos, dir, scene.quad, tmpN);\n    if (quadT < t) {\n        t = quadT;\n        N = tmpN;\n        m = scene.quad.m;\n    }\n    return t;\n}\n\nbool isOccluded(vec3 pos, Light light) {\n    vec3 dir = light.sphere.pos - pos + randDir * light.sphere.radius;\n    float dist = length(dir);\n    dir /= dist;\n    vec3 tmpN;\n    Material tmpM;\n    float t = traceScene(pos + dir * 1e-3, dir, tmpN, tmpM);\n    return t < dist;\n}\n\nvec3 computeLight(vec3 pos, vec3 dir, vec3 N, Material m) {\n    vec3 lightPower = vec3(0);\n    vec3 spectralLight = vec3(0);\n    for (int i = 0; i < scene.lights.length(); i++) {\n        vec3 toLight = scene.lights[i].sphere.pos - pos;\n        float att = isOccluded(pos, scene.lights[i]) ? 0.5 : scene.lights[i].intensity / dot(toLight, toLight);\n        lightPower += max(0.0, dot(N, normalize(toLight))) * att * scene.lights[i].sphere.m.col;\n        spectralLight += powf(max(0.0, dot(dir, reflect(normalize(toLight), N))), m.spectral_exp) * vec3(1) * att;\n    }\n    lightPower += texture(iChannel1, N).rgb * 0.1;\n    return m.col * (0.1 + lightPower) + spectralLight;\n}\n\nvec3 refraction(vec3 v, vec3 N, float n1, float n2) {\n    if (dot(v,N) < 0.0) N = -N;\n    float cosA = dot(v, N);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tg = normalize(v - cosA*N);\n    float sinB = sinA/n2 * n1;\n    float cosB = sqrt(1.0 - sinB*sinB);\n    return sinB * tg + cosB * N;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    //init\n    vec3 randV = vec3(rand(float(iFrame)), rand(float(iFrame +5)), rand(float(iFrame + 15)));\n    randDir = normalize(randV - 0.5);\n    Material emissive = Material(1.0, 0.0, 0.0, 0.0, AIR_N, 0, vec3(0));\n    Material diffusive = Material(0.1, 1.0, 0.0, 0.0, AIR_N, 50, vec3(1));\n    Material reflective = Material(0.0, 0.0, 1.0, 0.0, AIR_N, 0, vec3(0));\n    Material refractive = Material(0.0, 0.0, 0.0, 1.0, GLASS_N, 0, vec3(0));\n    Material glass = Material(0.0, 0.4, 1.0, 1.0, GLASS_N, 50, vec3(1));\n    Material light1_m = emissive;\n    light1_m.col = Light1_col;\n    Material light2_m = emissive;\n    light2_m.col = Light2_col;\n    Material light3_m = emissive;\n    light3_m.col = Light3_col;\n    Light light1 = Light(Sphere(Light1_pos, Light1_r, light1_m), Light1_int);\n    Light light2 = Light(Sphere(Light2_pos, Light2_r, light2_m), Light2_int);\n    Light light3 = Light(Sphere(Light3_pos, Light3_r, light3_m), Light3_int);\n    Light lights[3] = Light[3](light1, light2, light3);\n    float ang = 0.3;\n    mat2 rot = mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\n    vec2 pyrXZ1 = rot * vec2(1, -1);\n    vec2 pyrXZ2 = rot * vec2(1, 1);\n    vec2 pyrXZ3 = rot * vec2(-1, 1);\n    vec2 pyrXZ4 = rot * vec2(-1, -1);\n    Pyramid pyramid = Pyramid(vec3[5](vec3(0., 1., 0.), vec3(pyrXZ1.x, -0.99, pyrXZ1.y),\n            vec3(pyrXZ2.x, -0.99, pyrXZ2.y), vec3(pyrXZ3.x, -0.99, pyrXZ3.y),\n            vec3(pyrXZ4.x, -0.99, pyrXZ4.y)), vec3(0), vec3(1.25), glass);\n    vec2 quadXZ1 = rot * vec2(-0.5, -0.5);\n    vec2 quadXZ2 = rot * vec2(0.4999, -0.5);\n    vec2 quadXZ3 = rot * vec2(-0.5, 0.5);\n    Quad quad = Quad(vec3[3](vec3(quadXZ1.x, -1.99, quadXZ1.y), \n                    vec3(quadXZ2.x, -1.9999, quadXZ2.y), vec3(quadXZ3.x, -1.99, quadXZ3.y)), diffusive);\n    scene.lights = lights;\n    scene.pyramid = pyramid;\n    scene.quad = quad;\n    \n    //calculate coord and viewVec\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randV.xy - 0.5) * 2.0)/iResolution.x;\n    vec3 front = normalize(vec3(-CAMERA_POS));\n    vec3 up = vec3(0,1,0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    vec3 viewVec = normalize(front + right * uv.x + up* uv.y);\n    \n    //trace\n    vec3 curPos = CAMERA_POS;\n    vec3 curDir = viewVec;\n    float n1 = AIR_N;\n        float n2 = AIR_N;\n    vec3 col = vec3(0);\n    \n    \n    for (int j = 0; j < 10; j++) {\n        float t = INF;\n        bool intersect;\n        vec3 N;\n        vec3 tmpN;\n        \n        Material material;\n        \n        \n        //trace lights(models)\n        for (int i = 0; i < lights.length(); i++) {\n            float lightT = traceSphere(curPos, curDir, lights[i].sphere, tmpN);\n            if (lightT < t) {\n                t = lightT;\n                N = tmpN;\n                material = lights[i].sphere.m;\n            }\n        }\n        \n        //traceScene\n        Material tmpM;\n        float sceneT = traceScene(curPos, curDir, tmpN, tmpM);\n        if (sceneT < t) {\n            t = sceneT;\n            N = tmpN;\n            material = tmpM;\n        }\n        \n        vec3 worldPos = t * curDir + curPos;\n        //trace plane\n        float planeT = tracePlane(curPos, curDir, tmpN);\n        if (planeT < t) {\n            t = planeT;\n            N = tmpN;\n            worldPos = t * curDir + curPos;\n            material = diffusive;\n            material.col = texture(iChannel0, worldPos.xz * 0.1).rgb;\n        }\n        \n        //calculate color\n        bool isEmissive = material.emission > 0.0;\n        bool isDiffusive = material.diffusion > 0.0;\n        bool isReflective = material.reflection > 0.0;\n        bool isRefractive = material.refraction > 0.0;\n        if (isReflective) {\n            n1 = n2;\n            n2 = material.n;\n        }\n        float R = powf((n1-n2)/(n1+n2), 2);\n        bool reflAndRefr = isReflective && isRefractive;\n        isReflective = (reflAndRefr && randV.x * 0.2 < R) || (!reflAndRefr && isReflective);\n        isRefractive = (reflAndRefr && !isReflective) || (!reflAndRefr && isRefractive);\n        \n        if (isEmissive) {\n            col +=  material.col * material.emission * k;\n        }\n        if (isDiffusive) {\n            col += computeLight(worldPos, curDir, N, material) * material.diffusion * k;\n        }\n        if (isReflective) {\n            curDir = reflect(curDir,N);\n            curPos = worldPos + curDir * 1e-3;\n        }\n        else if (isRefractive) {\n            curDir = refraction(curDir, N, n1, n2);\n            curPos = worldPos + curDir * 1e-3;\n            \n            if (n1 == AIR_N && n2 == GLASS_N) {\n                vec4 p = raymarch(curPos + vec3(1.4, 6.8, -15), curDir);\n                float glow = p.w;\n                vec3 flamecol = mix( vec3(0.1, 0.5, 1), vec3(1, 0.5, 0.1), p.y * 0.022 + 2.5) ;\n                col += mix(vec3(0), flamecol, pow(glow * 2.0, 4.0));\n            }\n        }\n\n        if (t == INF) {\n            col += k * texture(iChannel1, curDir).rgb;\n        }\n    }\n        \n    fragColor = vec4(col, 1.0);\n             \n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}","name":"Buffer B","description":"","type":"buffer"}]}