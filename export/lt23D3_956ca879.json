{"ver":"0.1","info":{"id":"lt23D3","date":"1433278566","viewed":3799,"name":"Brush Experiment 2","username":"104","description":"Brush strokes / calligraphy experiments. Use the mouse. All you need to apply the effect is distance-to-geometry, and \"how far along the path\". So if you can get those 2 things for bezier curves for example, this can get curvy. Working on a circle version","likes":121,"published":1,"flags":0,"usePreview":0,"tags":["2d","brush"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"////////////////////////////////////////////////////////////////\n// BOILERPLATE UTILITIES...................\nconst float pi = 3.14159;\nconst float pi2 = pi * 2.;\n\nmat2 rot2D(float r)\n{\n    float c = cos(r), s = sin(r);\n    return mat2(c, s, -s, c);\n}\nfloat nsin(float a){return .5+.5*sin(a);}\nfloat ncos(float a){return .5+.5*cos(a);}\nvec3 saturate(vec3 a){return clamp(a,0.,1.);}\nfloat opS( float d2, float d1 ){return max(-d1,d2);}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat rand(float n){\n \treturn fract(cos(n*89.42)*343.42);\n}\nfloat dtoa(float d, float amount)\n{\n    return clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.);\n}\nfloat sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br)\n{\n    vec2 d = max(tl-uv, uv-br);\n    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\n}\n\n// 0-1 1-0\nfloat smoothstep4(float e1, float e2, float e3, float e4, float val)\n{\n    return min(smoothstep(e1,e2,val), 1.-smoothstep(e3,e4,val));\n}\n\n// hash & simplex noise from https://www.shadertoy.com/view/Msf3WH\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n// returns -.5 to 1.5. i think.\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\t\n}\nfloat noise01(vec2 p)\n{\n    return clamp((noise(p)+.5)*.5, 0.,1.);\n}\n\n\n////////////////////////////////////////////////////////////////\n// APP CODE ...................\n\nvec3 colorAxisAlignedBrushStroke(vec2 uv, vec2 uvPaper, vec3 inpColor, vec4 brushColor, vec2 p1, vec2 p2)\n{\n    // how far along is this point in the line. will come in handy.\n    vec2 posInLine = smoothstep(p1, p2, uv);//(uv-p1)/(p2-p1);\n\n    // wobble it around, humanize\n    float wobbleAmplitude = 0.13;\n    uv.x += sin(posInLine.y * pi2 * 0.2) * wobbleAmplitude;\n\n    // distance to geometry\n    float d = sdAxisAlignedRect(uv, p1, vec2(p1.x, p2.y));\n    d -= abs(p1.x - p2.x) * 0.5;// rounds out the end.\n    \n    // warp the position-in-line, to control the curve of the brush falloff.\n    posInLine = pow(posInLine, vec2((nsin(iTime * 0.5) * 2.) + 0.3));\n\n    // brush stroke fibers effect.\n    float strokeStrength = dtoa(d, 100.);\n    float strokeAlpha = 0.\n        + noise01((p2-uv) * vec2(min(iResolution.y,iResolution.x)*0.25, 1.))// high freq fibers\n        + noise01((p2-uv) * vec2(79., 1.))// smooth brush texture. lots of room for variation here, also layering.\n        + noise01((p2-uv) * vec2(14., 1.))// low freq noise, gives more variation\n        ;\n    strokeAlpha *= 0.66;\n    strokeAlpha = strokeAlpha * strokeStrength;\n    strokeAlpha = strokeAlpha - (1.-posInLine.y);\n    strokeAlpha = (1.-posInLine.y) - (strokeAlpha * (1.-posInLine.y));\n\n    // fill texture. todo: better curve, more round?\n    const float inkOpacity = 0.85;\n    float fillAlpha = (dtoa(abs(d), 90.) * (1.-inkOpacity)) + inkOpacity;\n\n    // todo: splotches ?\n    \n    // paper bleed effect.\n    float amt = 140. + (rand(uvPaper.y) * 30.) + (rand(uvPaper.x) * 30.);\n    \n\n    float alpha = fillAlpha * strokeAlpha * brushColor.a * dtoa(d, amt);\n    alpha = clamp(alpha, 0.,1.);\n    return mix(inpColor, brushColor.rgb, alpha);\n}\n\nvec3 colorBrushStroke(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 p1, vec2 p2, float lineWidth)\n{\n    // flatten the line to be axis-aligned.\n    vec2 rectDimensions = p2 - p1;\n    float angle = atan(rectDimensions.x, rectDimensions.y);\n    mat2 rotMat = rot2D(-angle);\n    p1 *= rotMat;\n    p2 *= rotMat;\n    float halfLineWidth = lineWidth / 2.;\n    p1 -= halfLineWidth;\n    p2 += halfLineWidth;\n\tvec3 ret = colorAxisAlignedBrushStroke(uv * rotMat, uv, inpColor, brushColor, p1, p2);\n    // todo: interaction between strokes, smearing like my other shader\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord / iResolution.y * 2.0) - 1.;\n    vec2 mouse = (iMouse.xy / iResolution.y * 2.0) - 1.;\n    \n    vec3 col = vec3(1.,1.,0.86);// bg\n    float dist;\n    \n    // black stroke\n    col = colorBrushStroke(uv, col, vec4(vec3(.8,.1,0),.8),// red fixed line\n                           vec2(1.7, .8),\n                           vec2(-0.6, -.6), 0.1);\n\n    col = colorBrushStroke(uv, col, vec4(vec3(0.),.8),// black fixed line\n                           vec2(.6, -.8),\n                           vec2(2.3, .2),\n                           0.1);\n\n    if(iMouse.x == 0.)\n        mouse = vec2(1.1,.8);\n    col = colorBrushStroke(uv, col, vec4(vec3(0.),.9),// black movable line\n                           vec2(-0.4, 0.0),\n                           mouse,0.3);\n\n    // red-orangeish signature\n    dist = sdAxisAlignedRect(uv, vec2(-0.68), vec2(-0.55));\n    float amt = 90. + (rand(uv.y) * 100.) + (rand(uv.x / 4.) * 90.);\n    float vary = sin(uv.x*uv.y*50.)*0.0047;\n    dist = opS(dist-0.028+vary, dist-0.019-vary);// round edges, and hollow it out\n    col = mix(col, vec3(0.99,.4, 0.0), dtoa(dist, amt) * 0.7);\n    col = mix(col, vec3(0.85,0.,0.), dtoa(dist, 700.));\n\n    // grain\n    col.rgb += (rand(uv)-.5)*.08;\n    col.rgb = saturate(col.rgb);\n\n    uv -= 1.0;// vignette\n\tfloat vignetteAmt = 1.-dot(uv*0.5,uv* 0.12);\n    col *= vignetteAmt;\n    \n    \n    fragColor = vec4(col, 1.);\n}\n\n","name":"","description":"","type":"image"}]}