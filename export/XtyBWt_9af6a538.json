{"ver":"0.1","info":{"id":"XtyBWt","date":"1544497821","viewed":624,"name":"jello","username":"bitnenfer","description":"simple scene. playing around with some effects, nothing serious. everything is fake and it breaks!","likes":28,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 0.0001\n#define NEARCLIP 0.0001\n#define FARCLIP 100.0\n#define MARCHSTEPS 500\n\n#define ALL 1\n#define CUBEMAP_REFLECTION 1\n#define BLINN_PHONG 1\n#define AO 1\n#define SHADOWS 1\n#define SCENE_REFLECTION 1\n#define SSS 1\n#define VIGNETTE 1\n#define COLOR 1\n\n#define SSS_STEPS 25\n\nstruct Material\n{\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n    float reflection;\n    float sss;\n};\n\nstruct DirLight\n{\n    vec3 dir;\n    vec3 color;\n};\n\nstruct RayResult\n{\n    float dist;\n    Material material;\n};\n\nconst Material kNoMaterial = Material(\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.0, 0.0),\n    0.0,\n    0.0,\n    0.0\n);\n\nconst Material kMaterialRed = Material(\n    vec3(0.2, 0.0, 0.0),\n    vec3(0.9, 0.0, 0.0),\n    vec3(1.0, 0.9, 0.9),\n    512.0,\n    0.0,\n    5.0\n);\n\nconst Material kMaterialGreen = Material(\n    vec3(0.0, 0.1, 0.0),\n    vec3(0.0, 0.9, 0.0),\n    vec3(0.9, 1.0, 0.9),\n    0.0,\n    0.09,\n    4.0\n);\n\nconst Material kMaterialBlue = Material(\n    vec3(0.0, 0.0, 0.1),\n    vec3(0.0, 0.0, 0.9),\n    vec3(0.9, 9.0, 1.0),\n    1024.0,\n    0.3,\n    9.0\n);\n\n\nDirLight kDirLight = DirLight(\n    vec3(0.3, 0.35, 0.1),\n    vec3(1.0)\n);\n\nconst vec3 kAmbientColor = vec3(0.376, 0.0, 0.10);\n\nvec3 hash( vec3 p )\n{\n    p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n              dot(p,vec3(269.5,183.3,246.1)),\n              dot(p,vec3(113.5,271.9,124.6)));\n\n    return fract(sin(p)*43758.5453123);\n}\n\nRayResult opUnion(in RayResult a, in RayResult b)\n{\n    if (a.dist < b.dist) return a;\n    return b;\n}\n\nRayResult opUnion2(in RayResult a, in RayResult b)\n{\n    if (-a.dist < b.dist) return a;\n    return b;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdSphere(in vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat opDisp(vec3 p)\n{\n    return sin(20.0*p.x)*sin(20.0*p.y)*sin(20.0*p.z);\n}\n\nvoid opRotate(inout vec2 v, float r)\n{\n    float c = cos(r);\n    float s = sin(r);\n    float vx = v.x * c - v.y * s;\n    float vy = v.x * s + v.y * c;\n    v.x = vx;\n    v.y = vy;\n}\n\nRayResult mapScene(in vec3 p)\n{   \n    p.y += 0.2;\n    float t= iTime * 0.5;\n    float a = sdSphere(p + vec3(1.5 * cos(t), -0.9, 1.5 * sin(t)), 0.8);\n    a += opDisp(p * 0.3) * 0.19;\n    vec3 bp = p + vec3(1.5 * cos(t + 2.5), -1.02, 1.5 * sin(t + 2.5));\n    opRotate(bp.xz, t* 1.8);\n\n    float b = sdBox(bp, vec3(0.88));\n    b -= opDisp(sin(iTime) * p * 0.2) * 0.3;\n    float c = sdBox(p + vec3(0.0, 0.2, 0.0), vec3(4.0, 0.2, 4.0));\n\n\n    return opUnion(RayResult(c, kMaterialBlue),opUnion(RayResult(a, kMaterialRed), RayResult(b, kMaterialGreen)));\n}\n\nvec3 opNormal(in vec3 p)\n{\n    const vec2 e = vec2(0.0, EPSILON);\n    return normalize(vec3(\n        mapScene(p + e.yxx).dist - mapScene(p - e.yxx).dist,\n        mapScene(p + e.xyx).dist - mapScene(p - e.xyx).dist,\n        mapScene(p + e.xxy).dist - mapScene(p - e.xxy).dist\n    ));\n}\n\nRayResult rayMarch(in vec3 ro, in vec3 rd)\n{\n    float total = NEARCLIP;\n    \n    for (int i = 0; i < MARCHSTEPS; ++i)\n    {\n        RayResult ray = mapScene(ro + rd * total);\n        if (ray.dist < EPSILON)\n        {\n            return RayResult(total, ray.material);\n        }\n        \n        total += ray.dist * 0.5;\n        if (total > FARCLIP)\n        {\n            break;\n        }\n    }\n    \n    return RayResult(FARCLIP, kNoMaterial);\n}\n\nfloat opAO(in vec3 p, in vec3 n)\n{\n    float value = 0.0;\n    float s = 1.0;\n    for (int i = 0; i < 3; ++i)\n    {\n        float stepSize = 0.13;\n        float dist = mapScene(p + n * stepSize).dist;\n        value += (stepSize - dist) * s;\n        s *=0.7;\n    }\n    value = value;\n    return clamp(sqrt((0.9 - value) * sqrt(1.0)), -1.0, 1.0);\n}\n\nfloat opHardShadow(in vec3 p, in vec3 ld)\n{\n    float value = 0.0;\n    float total = 0.0;\n    float s = 1.0;\n    for (int i = 0; i < 75; ++i)\n    {\n        float dist = mapScene(p + ld * total * 1.).dist;\n        value += dist * s;\n        total += dist;\n        s *= 0.5;\n    }\n    value = 1.0 - value;\n    vec3 h = p + ld * total;\n    float occ = max(0.0, dot(h, ld));\n    return clamp(value, 0.0, 1.0);\n}\n\nfloat opSSS(in vec3 ro, in vec3 rd, in vec3 n, float dist, float factor);\n\nvec3 opReflection(float dist, in vec3 p, in vec3 dir, in vec3 n)\n{\n    vec3 color = vec3(0.2);\n    vec3 rd = normalize(reflect(dir, n));\n    float ft = max(0.0, dot(rd, n));\n    RayResult ray = rayMarch(p, rd);\n   \n    if (ray.dist < FARCLIP && ft > 0.0)\n    {\n        Material material = ray.material;\n        vec3 hitPoint = p + rd * ray.dist;\n        vec3 n = opNormal(hitPoint);\n        vec3 nld = normalize(kDirLight.dir);\n        vec3 h = normalize(n + nld);\n        float diffuse = max(0.0, dot(n, nld));\n        float specular = pow(max(0.0, dot(h, n)), material.shininess);\n        vec3 sss = opSSS(hitPoint, nld, n, dist, material.sss) * material.diffuse;\n        \n        if (material.shininess == 0.0) specular = 0.0;\n        \n        vec3 color = (material.ambient) / 2.0;\n        \n        #if defined(BLINN_PHONG) && defined(ALL)\n        color += \n            ((material.diffuse + kDirLight.color) / 2.0) * diffuse +\n            ((material.specular * specular));\n        #endif\n        \n        #if defined(SSS) && defined(ALL)\n        color += sss * clamp(material.sss, 0.0, 1.0);\n        #endif\n            \n        return color;\n    }\n    return kAmbientColor.rgb;\n}\n\nfloat opSSS(in vec3 ro, in vec3 rd, in vec3 n, float dist, float factor)\n{\n    #if 1\n    float value = 0.0;\n    vec3 nrd = refract(rd, n, 1.0);\n    float s = 1.0;\n    #if __VERSION__ == 100\n    const int steps = SSS_STEPS;\n    #else\n    int steps = int(factor);\n    #endif\n    for (int i = 0; i < steps; ++i)\n    {\n        float stepSize = (float(i) / float(steps));\n        float d = mapScene(ro + nrd * stepSize).dist;\n        value += (stepSize - d) * s;\n        s *= 0.6;\n    }\n    value = pow(value, 0.2);\n    value = clamp(abs(1.0 - value), 0.0, 1.0000001);\n    return value;\n    \n    #else\n    float value = 0.0;\n    vec3 nrd = refract(rd, n, 1.0);\n    float s = 1.0;\n    #if __VERSION__ == 100\n    const int steps = SSS_STEPS;\n    #else\n    int steps = int(factor);\n    #endif\n    for (int i = 0; i < steps; ++i)\n    {\n        float stepSize = float(i) / factor;\n        float d = mapScene(ro + nrd * stepSize).dist;\n        value += (stepSize - d) * s;\n        s *=0.75;\n    }\n    value = pow(value, 0.2);\n    value = clamp(1.0 - value, 0.0, 1.0);\n    return value;\n    #endif\n}\n\nfloat opShadow(in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n        float h = mapScene( ro + rd * t ).dist;\n        res = min( res, 2.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 shade(float dist, in vec3 ro, in vec3 rd, in vec3 hitPoint, in Material material)\n{\n    vec3 n = opNormal(hitPoint);\n    vec3 nld = normalize(kDirLight.dir);\n    vec3 h = normalize(n + nld);\n    float diffuse = max(0.0, dot(n, nld));\n    float specular = pow(max(0.0, dot(h, n)), material.shininess);\n    float ao = opAO(hitPoint, n);\n    float shadow = opShadow(hitPoint, nld, 0.1, 0.9);\n//    float shadow = opHardShadow(hitPoint, nld);\n    vec3 reflectionColor = opReflection(dist, hitPoint, rd, n);\n    vec3 sss = opSSS(hitPoint, nld, n, dist, material.sss) * (material.diffuse * 1.2);\n    vec3 color = n;\n    \n    if (material.shininess == 0.0) specular = 0.0;\n    \n    #if defined(BLINN_PHONG) && defined(ALL)\n    color = (material.ambient + kAmbientColor.rgb) / 2.0 +\n        ((material.diffuse + kDirLight.color) / 2.0) * diffuse +\n        ((material.specular * specular));\n    #endif\n    #if defined(SCENE_REFLECTION) && defined(ALL)\n    color = mix(color, clamp(reflectionColor, vec3(0.0), vec3(1.0)),  clamp(material.reflection, 0.0, 1.0));\n    #endif\n    #if defined(CUBEMAP_REFLECTION) && defined(ALL)\n    color = mix(color, texture(iChannel0, reflect(rd, n)).rgb, material.reflection);\n    #endif\n    #if defined(AO) && defined(ALL)\n    color *= ao;\n    #endif\n    #if defined(SHADOWS) && defined(ALL)\n    color *= shadow * 0.2 + 0.7;\n    #endif\n    #if defined(SSS) && defined(ALL)\n    color += sss * clamp(material.sss, 0.0, 1.0);\n    #endif\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float ar = iResolution.x / iResolution.y;\n    vec3 color = kAmbientColor.rgb;\n    vec2 uv = (fragCoord.xy / iResolution.xy - 0.5) * vec2(ar, 1.0);\n    vec3 ro = vec3(0.0, 4.0, -9.5);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    opRotate(ro.xz, (iMouse.x / iResolution.x * 2.0 - 1.0) * 0.5);\n    opRotate(rd.xz, (iMouse.x / iResolution.x * 2.0 - 1.0) * 0.5);\n    opRotate(rd.yz, 0.4);\n    opRotate(kDirLight.dir.xz, iTime * 1.5);\n    \n    RayResult ray = rayMarch(ro, rd);\n    \n    if (ray.dist < FARCLIP)\n    {\n        vec3 hitPoint = ro  + rd * ray.dist;\n        color = shade(ray.dist, ro, rd, hitPoint, ray.material);\n    }\n\n    #if defined(COLOR)\n    color = pow(color, vec3(1.0/1.6));\n    #endif\n    \n    #if defined(VIGNETTE)\n    color = mix(color, color * 0.2, max(0.0, pow(length(1.0 * uv / vec2(ar, 1.0)), 2.9)));\n    #endif\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}