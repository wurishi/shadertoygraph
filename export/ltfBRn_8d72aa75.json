{"ver":"0.1","info":{"id":"ltfBRn","date":"1510739741","viewed":427,"name":"MyCircles2.0","username":"Arseny","description":"Fixed one","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat H, W, fr;\nfloat thickness = 0.5;\nfloat a = 0.;\nfloat intensive = 1.25;\nconst int k = 3;\nconst int N = int(pow(3., float(k) + 1.) - 1.) / 2;\nconst int M = int(pow(3., float(k)) - 1.) / 2;\nvec2 fcenter, mainvec;\nfloat multiplier = sqrt(3.) / (2. + sqrt(3.)); // constant which provides tangency of circles\nfloat pi = 4. * atan(-1.);\n\nfloat circle_influence(vec2 center,float r,vec2 uv){\n    float delta = abs(distance(center, uv) - r);\n    return pow(thickness / delta, intensive);\n}\n\n#define _R (0.3089)\n#define _G (0.5670)\n#define to_gray (vec3(_R, _G, 1. - _R - _G))\n\nvec3 from_RGrayB(vec2 RB, float gray){\n    float g = (gray - dot(RB, to_gray.xz)) / to_gray.y;\n    if (g < 0.){\n        g = 0.;\n        RB *= gray / dot(RB, to_gray.xz);\n    }\n    if (g > 1.){\n        g = 1.;\n        RB *= (gray - to_gray.y) / dot(RB, to_gray.xz);\n    }\n    return vec3(RB.x, g, RB.y);\n}\n\nvoid mainImage( out vec4 ans, in vec2 fragCoord )\n{\n    ans = vec4(0, 0, 0, 0);\n    H = iResolution.y;\n    W = iResolution.x;\n\tvec2 uv = fragCoord.xy;\n    fcenter = vec2(W / 2., H / 2.);\n    fr = min(H, W) / 2.1;\n    mainvec = vec2(fr, 0);\n    a = iTime; \n    mainvec = mainvec * rot(a);\n    vec3 queue[N]; // queue of circles (center and radius)\n    int l = 0;\n    queue[0] = vec3(fcenter, fr);\n    int r = 1;\n    ans += circle_influence(fcenter, fr, uv);\n    while (l < M){\n        vec2 nowvec = mainvec;\n        vec2 nowc = vec2(queue[l].x, queue[l].y);\n        for (int j = 0; j < 3; j++){\n            vec2 newc = (fcenter + nowvec) + (nowc - (fcenter + nowvec)) * multiplier;\n            float newr = queue[l].z * multiplier;\n            ans += vec4(1) * circle_influence(newc, newr, uv);\n            queue[r] = vec3(newc.xy, newr);\n            r++;\n            nowvec = nowvec * rot(2. * pi / 3.);\n        }\n        l++;\n    }\n    vec2 RB = vec2(0.3);\n    RB += iMouse.xy / iResolution.xy;\n    RB = fract(RB);\n    ans = vec4(from_RGrayB(RB, ans.x), 1.);\n    /*if (ans.x < 0.1){\n        ans = vec4(from_RGrayB(RB, 0.5), 1.);\n    }*/\n}","name":"Image","description":"","type":"image"}]}