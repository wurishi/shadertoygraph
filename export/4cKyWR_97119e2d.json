{"ver":"0.1","info":{"id":"4cKyWR","date":"1731707792","viewed":44,"name":"Mandelbulb fractal :)","username":"naty_kappa","description":"playing around with raymarching and mandelbulb","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","mandelbulb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Signed Distance Function for the Mandelbulb\nfloat mandelbulbSDF(vec3 p) {\n    const int maxIterations = 4;\n    const float power = 9.0;\n    vec3 z = p;\n    float dr = 1.0;  // Derivative for distance estimation\n    float r = 0.0;\n\n    for (int i = 0; i < maxIterations; i++) {\n        r = length(z);\n        if (r > 3.0) break;\n\n        // Convert to spherical coordinates\n        float theta = acos(z.z / r);\n        float phi = atan(z.y, z.x);\n        dr = pow(r, power - 1.0) * power * dr + 1.0;\n\n        // Scale and rotate\n        float zr = pow(r, power);\n        theta *= power;\n        phi *= power;\n\n        // Convert back to Cartesian coordinates\n        z = zr * vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta)) + p;\n    }\n\n    // Return the signed distance\n    return 0.5 * log(r) * r / dr;\n}\n\n// Normal calculation using finite differences\nvec3 calculateNormal(vec3 p, float epsilon) {\n    vec2 e = vec2(epsilon, 0.0);\n    return normalize(vec3(\n        mandelbulbSDF(p + e.xyy) - mandelbulbSDF(p - e.xyy), // x-derivative\n        mandelbulbSDF(p + e.yxy) - mandelbulbSDF(p - e.yxy), // y-derivative\n        mandelbulbSDF(p + e.yyx) - mandelbulbSDF(p - e.yyx)  // z-derivative\n    ));\n}\n\n\n// Mandelbulb fractal shader with normals and lighting\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize screen coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Camera setup\n    vec3 camPos = vec3(0.0, 0.0, 2.0);\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n    vec3 forward = normalize(lookAt - camPos);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    vec3 rayDir = normalize(forward + uv.x * right + uv.y * up);\n\n    // Ray marching parameters\n    float totalDist = 0.0;\n    const int maxSteps = 100;\n    const float maxDist = 100.0;\n    float surfaceEpsilon = 0.001;\n    \n    vec3 hitPos;\n    bool hit = false;\n\n    for (int i = 0; i < maxSteps; i++) {\n        vec3 pos = camPos + totalDist * rayDir;\n        float dist = mandelbulbSDF(pos);\n        if (dist < surfaceEpsilon) {\n            hit = true;\n            hitPos = pos;\n            break;\n        }\n        totalDist += dist;\n        if (totalDist > maxDist) break;\n    }\n\n    // Basic background color\n    vec3 color = vec3(0.0);\n\n    if (hit) {\n        // Compute the normal at the hit position\n        vec3 normal = calculateNormal(hitPos, surfaceEpsilon);\n\n        // Simple lighting: directional light\n        vec3 lightDir = normalize(vec3(cos(iTime), cos(iTime), sin(iTime)));\n        float diffuse = max(dot(normal, lightDir), 0.0);\n\n        // Shading with a gradient\n        color = mix(vec3(0.1, 0.1, 0.4), vec3(0.9, 0.8, 1.0), diffuse);\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}