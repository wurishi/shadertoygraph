{"ver":"0.1","info":{"id":"wdlXRf","date":"1552045495","viewed":86,"name":"317_Дарья_Петренко","username":"daria_snz","description":"Задание №1 курса по компьютерной графике.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\nconst int MAX_MARCHING_STEPS = 500;\nconst float EPS = 0.01;\nconst float MAX_DEPTH = 500.0;\n\nmat3\nrotateY(float theta) \n{\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat3(\n        vec3(c, 0., s),\n        vec3(0., 1., 0),\n        vec3(-s, 0., c)\n    );\n}\n\nmat3\nrotateX(float theta) \n{\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat3(\n        vec3(1., 0., 0),\n        vec3(0., c,  s),\n        vec3(0.,-s, c)\n    );\n}\n\nmat3\nrotateZ(float theta) \n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c,  s, 0.),\n        vec3(-s, c, 0.),\n        vec3(0., 0., 1.)\n    );\n}\n\nstruct Sphere {\n    vec3 p;\n    float r;\n    vec3 a_col;\n    vec3 d_col;\n    vec3 s_col;\n    float shininess;\n};\n   \nstruct Box {\n    vec3 p;\n    float b;\n    vec3 a_col;\n    vec3 d_col;\n    vec3 s_col;\n    float shininess;\n};\n    \nstruct Plane {\n    vec4 norm;\n    vec3 a_col;\n    vec3 d_col;\n    vec3 s_col;\n    float shininess;\n};\n    \nstruct Torus {\n    vec3 p;\n    vec2 t;\n    vec3 a_col;\n    vec3 d_col;\n    vec3 s_col;\n    float shininess;\n};\n  \n// initialization of objects;\n    \nSphere sph_1 = Sphere(vec3(0.5, 3., 0.5), 0.5, vec3(0.05, 0.18, 0.45), vec3(0.2, 0.3, 0.7), vec3(1.0, 1.0, 1.0), 32.0);\nSphere sph_2 = Sphere(vec3(0.5, 3., 0.5), 0.5, vec3(0.05, 0.18, 0.45), vec3(0.2, 0.3, 0.7), vec3(1.0, 1.0, 1.0), 32.0);\nSphere sph_3 = Sphere(vec3(0.5, 3, 0.5), 1.5, vec3(0.4, 0.03, 0.1), vec3(0.9, 0.04, 0.23), vec3(1.0, 1.0, 1.0), 32.0);\n\nBox box_1 = Box(vec3(0.5, 3., 0.5), 1.2, vec3(0.4, 0.03, 0.1), vec3(0.9, 0.04, 0.23), vec3(1.0, 1.0, 1.0), 32.0);\nTorus torus_1 = Torus(vec3(0.5, 3., 0.5), vec2(2.1, 0.2), vec3(0.4, 0.4, 0.18), vec3(0.8, 0.9, 0.07), vec3(1.0, 1.0, 1.0), 20.0);\nPlane pl_1 = Plane(normalize(vec4(0., 1., 0., 1.)), vec3(0.2, 0.2, 0.2), vec3(0.5, 0.5, 0.45), vec3(1.0, 1.0, 1.0), 10.0);\nvec3 background_col = vec3(0.5, 0.5, 0.5);\n\nfloat \nintersection(float d1, float d2)\n{\n    return max(d1, d2);\n}\n    \nfloat \nsphere_dist_1(Sphere s, vec3 point) \n{\n    vec3 p = point - s.p - vec3(-3. * sin(iTime), 0., 3. * cos(iTime));\n\treturn length(p) - s.r;\n}\n\nfloat \nsphere_dist_2(Sphere s, vec3 point) \n{\n    vec3 p = point - s.p - vec3(0., 3. * sin(iTime), -3. * cos(iTime));\n\treturn length(p) - s.r;\n}\n\n\nfloat \nsphere_dist_3(Sphere s, vec3 point) \n{\n    vec3 p = point - s.p;\n\treturn length(p) - s.r;\n}\n\n  \nfloat box_dist(Box b, vec3 point)\n{\n  vec3 p = (point - b.p) * rotateZ(45.) * rotateY(45.) * rotateX(45.);\n  vec3 d = abs(p) - b.b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat\nplane_dist(Plane p, vec3 point) \n{\n  return dot(point, p.norm.xyz) + p.norm.w;\n}\n\nfloat \ntorus_dist(Torus tor, vec3 point)\n{\n  vec3 p = (point - tor.p) * rotateX(sin(iTime)) * rotateZ(cos(iTime));\n  vec2 q = vec2(length(p.xz)-tor.t.x,\n                p.y);\n  return length(q)-tor.t.y;\n}\n\n\nfloat\nget_dist(vec3 dot)\n{\n    float sph_dist_1 = sphere_dist_1(sph_1, dot);\n    float sph_dist_2 = sphere_dist_2(sph_2, dot);\n    float sph_dist_3 = sphere_dist_3(sph_3, dot);\n    float box_dist_1 = box_dist(box_1, dot);\n    float its = intersection(sph_dist_3,box_dist_1);\n    float pl_dist_1 = plane_dist(pl_1, dot); \n    float torus_dist_1 = torus_dist(torus_1, dot);\n    return min(torus_dist_1, min(pl_dist_1, min(sph_dist_1, min(sph_dist_2, its))));\n}\n\nvec3 \nestimate_normal(vec3 dot) \n{\n    float dx = get_dist(vec3(dot.x + EPS, dot.y, dot.z)) - \n        get_dist(vec3(dot.x - EPS, dot.y, dot.z));\n    float dy = get_dist(vec3(dot.x, dot.y + EPS, dot.z)) - \n        get_dist(vec3(dot.x, dot.y - EPS, dot.z));\n    float dz = get_dist(vec3(dot.x, dot.y, dot.z + EPS)) - \n        get_dist(vec3(dot.x, dot.y, dot.z - EPS));\n    return normalize(vec3(dx, dy, dz)); \n}\n                    \nstruct Ray{\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Hit{\n    bool exist;\n    vec3 point;\n    vec3 a_col;\n    vec3 d_col;\n    vec3 s_col;\n    float shininess;\n};\n    \nstruct Light {\n    vec3 pos;\n    vec3 intensity;\n};\n        \n\n// lights initialization\nLight lights[2] = Light[](Light(vec3(0., 7., 0.), vec3(30.0, 30., 30.)),\n                          Light(vec3(3., 2., 8.), vec3(30.0, 30., 30.)));\n    \nHit\nhit_info(vec3 dot) {\n    Hit rez;\n    if(intersection(box_dist(box_1, dot), \n                    sphere_dist_3(sph_3, dot)) < EPS) {\n        rez.a_col = box_1.a_col;\n        rez.d_col = box_1.d_col;\n        rez.s_col = box_1.s_col;\n        rez.shininess = box_1.shininess;\n        return rez;\n    } else if(torus_dist(torus_1, dot) < EPS) {\n        rez.a_col = torus_1.a_col;\n        rez.d_col = torus_1.d_col;\n        rez.s_col = torus_1.s_col;\n        rez.shininess = torus_1.shininess;\n        return rez;\n    } else if(sphere_dist_1(sph_1, dot) < EPS) {\n        rez.a_col = sph_1.a_col;\n        rez.d_col = sph_1.d_col;\n        rez.s_col = sph_1.s_col;\n        rez.shininess = sph_1.shininess;\n        return rez;\n    } else if(sphere_dist_2(sph_2, dot) < EPS) {\n        rez.a_col = sph_2.a_col;\n        rez.d_col = sph_2.d_col;\n        rez.s_col = sph_2.s_col;\n        rez.shininess = sph_2.shininess;\n        return rez;\n    } else if(plane_dist(pl_1, dot) < EPS) {\n        rez.a_col = pl_1.a_col;\n        rez.d_col = pl_1.d_col;\n        rez.s_col = pl_1.s_col;\n        rez.shininess = pl_1.shininess;\n        return rez;\n    }  \n}\n\n\nvec3 \nray_dir(float fov, vec2 size, vec2 pos) \n{\n\tvec2 xy = pos - size * 0.5;\n    float cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD);\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\treturn normalize( vec3( xy, -z ));\n}\n \n\nHit\nray_marching(Ray ray)\n{\n    Hit hit;\n    float depth = 0.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++){\n        float dist = get_dist(ray.pos + depth * ray.dir);\n        if(dist < EPS){\n            hit = hit_info(ray.pos + depth * ray.dir);\n            hit.point = ray.pos + depth * ray.dir;\n            hit.exist = true;\n            return hit;\n        }\n        depth += abs(dist);\n        if(depth > MAX_DEPTH) {\n            hit.exist = false;\n    \t\treturn hit;\n        }\n    }\n    hit.exist = false;\n    return hit;\n}\n\nbool \nis_visible(Light light, vec3 point)\n{\n    vec3 dir = normalize(point - light.pos);\n    Ray ray = Ray(light.pos, dir);\n    Hit hit = ray_marching(ray);\n    if(distance(point, hit.point) < EPS * 1.5) {\n        return true;\n    } else {\n    \treturn false;\n    }\n}\n\n/*\ndiffuse_colour - diffuse colour\nspecular_colour - specular colour\nshininess - shininess coefficient\nhit - information about the hit\nray - ray from camera\nlight_pos - position of light\nlight_intensity - intensity of light\n*/\nvec3 \nPhong_light(Ray ray, Hit hit, Light light ) \n{\n    float att = distance(hit.point, light.pos);\n    att = 1. / (att * att);\n    vec3 N = estimate_normal(hit.point); \n    vec3 L = normalize(light.pos - N); \n    vec3 V = -ray.dir; \n    vec3 R = reflect(-L, N); \n    \n    float dotLN = dot(L, N); \n    float dotRV = dot(R, V); \n    vec3 colour = vec3(0.);\n    if (dotLN > 0.) { \n        colour += hit.d_col * dotLN * att;\n    }\n    if (dotRV > 0.) { \n        colour += hit.s_col * pow(dotRV, hit.shininess) * att;\n    }\n    colour *= light.intensity; \n    return colour;\n}\n  \n        \n\nvec3 \nray_trace(Ray ray)\n{\n    Hit hit = ray_marching(ray);\n    if(!hit.exist) {\n        return background_col;\n    }\n    vec3 colour = hit.a_col;\n    for(int i = 0; i < 2; i++) {\n        if(is_visible(lights[i], hit.point)) {\n            colour += Phong_light(ray, hit, lights[i]);\n        }\n    }\n    return colour;\n}\n \n\n      \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   \tRay ray;\n   \tray.pos = vec3(1, 1, 15.);\n    ray.dir = ray_dir(45.0, iResolution.xy, fragCoord.xy);\n    \n    fragColor = vec4(ray_trace(ray),1.0);\n}\n    \t\n","name":"Image","description":"","type":"image"}]}