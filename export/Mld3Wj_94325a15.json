{"ver":"0.1","info":{"id":"Mld3Wj","date":"1471783374","viewed":211,"name":"researching WASD-movement","username":"ollj","description":"understanding the \"wasd movement\" shader by  benq, commented and reformated\nshortened down from 29xx to 17xx chars\nflying by default\nsome very minor optimizations (for code that only changes 4 fraggments)","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["wasd","benq"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ben Quantock 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec4 pattern(in vec3 p){\n vec4   o=vec4(texture(iChannel2,(p.xz + p.xy)/11.).rgb,1.);//texture\n return o     *texture(iChannel1,(p.xz + p.xy)/ 7.).r*(sin(iTime)*.5+.6)*4.;}  //heightmap\n\nfloat scene(in vec3 p){float f=p.y+2.;//distance field\n f=min(f,length(fract(p.xz/20.+.4)-.5)*20.- .8);//thick columns\n f=min(f,length(fract(p.xz/31.   )-.5)*30.-1.8);//thin columns\n f=max(f,p.y-4.);//top cap of otherwise endless columns\n return f-.2*pattern(p).a;}\n\nvec4 readChan(sampler2D s, float x){return texture(s,vec2(x,.5)/iResolution.xy,-100.0 );}\n\n#define ColSky vec3(.3,.5,.9)\n#define ColGro vec3(.4,.2,.1)\n\n#define TAU 6.28318530718\n\nvoid mainImage( out vec4 r,in vec2 i ){\n vec4 camPos=readChan(iChannel0, .5);\n vec4 camRot=readChan(iChannel0,1.5)*TAU;\n vec2 j=i.xy/iResolution.xy;\n \n /*if(j.x<30./iResolution.x&&j.y<30./iResolution.y){\n   if(j.x<15./iResolution.x)r=camPos;\n   else r=camRot/TAU;\n }else*/\n{\n //read camera position & orientation\n\n //cast ray \n vec3 ray=normalize(vec3((i.xy-iResolution.xy*.5)/iResolution.x,1.));\n ray.zy=ray.zy*cos(camRot.x)+sin(camRot.x)*vec2(1,-1)*ray.yz;\n ray.xz=ray.xz*cos(camRot.y)+sin(camRot.y)*vec2(1,-1)*ray.zx;\n vec3 p=camPos.xyz;\n float h=1.;\n for(int i=0;i<200;i++){\n  if(h<.001)break;\n     h=scene(p+=ray*h*.5);}//rm loop\n //sample scene colour\n vec3 col;\n if(h<.001)col=pattern(p).rgb;\n else{//no surface reached\n  col=(ray.y<.0)? ColGro:ColSky;\n  //p +=ray*(p.y+2.)/max(-ray.y,.01);//fake horizon line\n }\n col=mix(ColSky,col,exp2(-length(p-camPos.xyz)/200.));//distance fog\n r = vec4(pow(col,vec3(1.0/2.2)),1.0);\n}}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Ben Quantock 2016\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//shortened&modified by ollj \n#define fl float\n#define ff const fl\nff minY=0.;//minimum height.\nff yMul=-1.;//negate to invert y-axis in controls\nff acc =.01;//acceleration \nff fri =.95;//friction\n\n#define cf 256.;\n#define cfc cf ff\nff Key_Space=32.5/cfc Key_0=48.5/cfc Key_1=49.5/cfc Key_2=50.5/cfc Key_3=51.5/cfc Key_4=52.5/cfc Key_5=53.5/cfc Key_6=54.5/cfc Key_7=55.5/cfc Key_8=56.5/cfc Key_9=57.5/cfc Key_A=65.5/cfc Key_B=66.5/cfc Key_C=67.5/cfc Key_D=68.5/cfc Key_E=69.5/cfc Key_F=70.5/cfc Key_G=71.5/cfc Key_H=72.5/cfc Key_I=73.5/cfc Key_J=74.5/cfc Key_K=75.5/cfc Key_L=76.5/cfc Key_M=77.5/cfc Key_N=78.5/cfc Key_O=79.5/cfc Key_P=80.5/cfc Key_Q=81.5/cfc Key_R=82.5/cfc Key_S=83.5/cfc Key_T=84.5/cfc Key_U=85.5/cfc Key_V=86.5/cfc Key_W=87.5/cfc Key_X=88.5/cfc Key_Y=89.5/cfc Key_Z=90.5/cf\nfl rkInternal(fl k,fl t){return texture(iChannel3,vec2(k,t)).x;}\nfl rk      (fl k){return rkInternal(k,.25);}\nfl rkToggle(fl k){return rkInternal(k,.75);}\nvec4 chan0(fl x){return texture(iChannel0,vec2(x,.5)/iResolution.xy,-100.);}\n\nvoid mainImage(out vec4 r, in vec2 i){r=vec4(0.,0.,0.,1.);if(int(i.y)==0){\n if(int(i.x)==0){//x=0 stores CameraPosition.xyz; .w stores if the camera is flying: if(camPos.w>.0) is flying, no gravity|jumping\n  vec4 camPos=chan0(.5);\n  vec4 camVel=chan0(3.5);\n  r=camPos+camVel;\n  //if(camPos.y<.0)r.y=minY;//no flying below .y<minY\n  r.w=rkToggle(Key_F);\n }else if(int(i.x)<2){//x=1. stores [cameraRot=0] in radians; .w stores iMouse.z, if mouse was held down at the last frame.\n  vec4 b=chan0(2.5);vec4 o=chan0(1.5);\n  vec2 m=(iMouse.yx/iResolution.yx-.5)*vec2(.5*yMul,1.);\n  o.w=iMouse.z;bool p=o.w>.0;\n  if(p&&!(b.w >.0))b.xy-=m;if(p)o.xy=b.xy+m;else b=o;b.w=o.w;\n  r=(int(i.x)==1)?o:b;\n  //x=2. stores [BASE-cameraRot=b] in radians; the last [camRot=o] were the mouse was being held down.\n }else if(int(i.x)==3){//x=3. stores [cameraVel=v] for acceleration and friction.\n  vec4 p=chan0(.5);vec4 v=chan0(3.5);vec4 o=chan0(1.5)*6.28318530718;\n  bool fly=p.w>.0;\n  vec3 f=acc*vec3(0,0,1);vec3 l=f.zxx;\n  if(!fly){fl s=sin(o.x);fl c=cos(o.x);\n   f.zy=f.zy*c+s*vec2(1,-1)*f.yz;\n   l.zy=l.zy*c+s*vec2(1,-1)*l.yz;}\n  fl s=sin(o.y);fl c=cos(o.y);\n  f.xz=f.xz*c+s*vec2(1,-1)*f.zx;\n  l.xz=l.xz*c+s*vec2(1,-1)*l.zx;\n  v.xyz+=(rk(Key_W)-rk(Key_S))*f;\n  v.xyz+=(rk(Key_D)-rk(Key_A))*l;\n  v*=fri;\n  if(fly){v.y-=.01;\n   if(p.y<=.0)v.y=(rk(Key_Space)!=.0)?.3:minY;\n  }r=v;}}}","name":"Buf A","description":"","type":"buffer"}]}