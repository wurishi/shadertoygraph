{"ver":"0.1","info":{"id":"llBfRK","date":"1517773378","viewed":713,"name":"Ball-E Game","username":"AntoineC","description":"Try to match the top/left pattern using paint and masks! The game has 25 levels. Use the X ball to restart a level. Read tutorial at the top of Image code. Updated to 1.05!\n\nCurrent limitations:\n - No win screen (game restart)!\n - Level number not show\n","likes":38,"published":1,"flags":96,"usePreview":1,"tags":["game"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ----------------------------------------------------------------------------------------\n//\t\"Ball-E Game\" by Antoine Clappier - Feb 2018\n//\n//\tLicensed under:\n//  A Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n//\thttp://creativecommons.org/licenses/by-nc-sa/4.0/\n// ----------------------------------------------------------------------------------------\n\n// Game mechanics inspired by \"Factory Ball\" by Bart Bonte. \n\n// Tutorial:\n\n// Level 1:\n//   - Use \"eyes\" mask    (click top/right sphere)\n//   - Paint in blue      (click blue ball)\n//   - Remove \"eyes\" mask (click again top/right sphere)\n//   - Done!\n\n// Level 2:\n//   - Paint in black    (click black ball)\n//   - Use \"pupils\" mask (click middle/right sphere)\n//   - Paint in white\n//   - Remove \"pupils\" mask\n//   - Add eyes mask\n//   - ...\n\n\n\n//----------------------------------------------------------------------------------------------\n// Change Log:\n//\n// Ball-E 1.04:\n//  - Now partially using Common tab!\n//  - Used mask ball are highlighted\n//  - Better code to toggle mask on/off\n//  - Chrome mask lightly textured for better visibility \n\n// Ball-E 1.05:\n//  - Fixed click issue introduced by iMouse API change.\n\n\n\n// Image\n// Inputs: Buffer A-n, Forest Blurred cubemap, Buffer C-l, Buffer D-l\n\n\n\n//----------------------------------------------------------------------------------------------\n// Load/Store from IQ (https://www.shadertoy.com/view/MddGzf)\n\nvec4 Load( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\n\n\n//----------------------------------------------------------------------------------------------\n// Rendering\n\nvec4 BallIntersect(in vec2 uv, in vec2 center, in float radius)\n{\n    uv -= center;\n    float zSq = radius*radius - dot(uv, uv);\n\treturn vec4(uv, sqrt(zSq), zSq) / radius;\n}\n\n\nvec4 BallTexture(vec3 hit, sampler2D sampler)\n{\n    vec2 uv = vec2((hit.y+1.0)/2.0, abs(hit.x));\n    return texture(sampler, uv);\n}\n\n\nvec4 ResetBallTexture(vec3 hit)\n{\n    float e = step(abs(hit.x-hit.y)-0.2, 0.0);\n    e += step(abs(hit.x+hit.y)-0.2, 0.0);\n    e *= step(length(hit.xy)-0.50, 0.0);\n    \n    vec3 color = mix(white, black, min(1.0, e));\n    return vec4(color, 0.0);\n}\n\n\nvec2 MaskBallCenter(in float maskId)\n{\n    maskId--;\n    if(maskId < 5.0)\n    {\n        float a = 90.0*(maskId/4.0 - 0.5)*Pi/180.0;\n        return 0.95*vec2(cos(a), sin(a));\n    }\n    else\n    {\n        float a = 38.0*((maskId-5.0)/2.0 - 0.5)*Pi/180.0;\n        return 1.35*vec2(cos(a), sin(a));\n    }\n}\n\n\nvec2 PaintBallCenter(in float id)\n{\n    float a = (180.0 + 90.0 * (id/4.0 - 0.5)) * Pi/180.0;\n    return 0.95*vec2(cos(a), sin(a));\n}\n\n\nvec3 Shade(in vec3 hit, in vec3 hitR, in vec4 layer, in float levelTransi)\n{\n    // Light:\n    vec3 light     = normalize(vec3(sin(iTime/10.0), 1.0, 1.5));\n\t\n\t// Geometry:\n    vec3 rayDir    = vec3(0.0, 0.0, -1.0);\n    vec3 backLight = normalize(-light * vec3(1.0, 1.0, 0.7));\n    vec3 normal    = normalize(hit);\n    vec3 reflected = reflect(rayDir, normal);\n\n\t// Model:    \n    float ambient  = min(1.0, 0.43*normal.y+0.50);\n    float diffuse  = max(0.0, dot(normal, light));\n    float backward = max(0.0, dot(normal, backLight));\n    float specular = max(0.0, dot(reflected, light));\n    \n\t// Smooth diffuse a bit: \n    diffuse = pow(diffuse, 1.5);\n    \n    // Shade:\n    vec3 color = vec3(0.0);\n    if(layer.a == 0.0)\n    {\n        // Rubbery:\n        color += 0.15 * ambient  * vec3(0.60,0.80,1.00);\n        color += 0.99 * diffuse  * vec3(1.00,0.90,0.75);\n        color += 0.15 * backward * vec3(0.25,0.25,0.25);\n\n        color *= 0.90 * layer.rgb;\n        color += 0.08 * pow(specular, 3.0);\n        \n        // Win:\n        float t = min(1.0, 5.0*levelTransi);\n    \tfloat smt = smoothstep(0.0, 1.0, 1.0-abs(2.0*t-1.0));\n        color *= 1.0 + 2.0*smt;\n    }\n    else\n    {\n        // Checker pattern:\n        vec2 rs = vec2(atan(hitR.x, hitR.z), acos(-hitR.y))/vec2(2.0*Pi,Pi) + vec2(0.5,0.0);\n        rs = floor(vec2(60.0, 30.0)*rs);\n        float checker = mod(rs.x + mod(rs.y, 2.0), 2.0); \n        \n        // \"Fresnel\" with color shift:\n        vec3 Kr = pow(0.65 + 0.3*vec3(0.9, 1.0, 1.4)*vec3(1.0 + dot(normal, rayDir)), 1.1*vec3(1.5, 1.5, 1.8));\n        Kr *= 0.97 + 0.03*checker;\n\n        \n        // Hack texture to get a skydome:\n        vec3 tex = texture(iChannel1, reflected).rgb;\n        vec3 sky = mix(vec3(0.90, 0.90, 1.0), 0.9*vec3(0.7, 0.80, 1.0), reflected.y);\n        \n        color  = 1.00 * Kr*mix(1.1*pow(1.0*tex, vec3(0.5)), sky, tex.r);\n        color += 0.04 * diffuse * vec3(1.00);\n        color += 0.56 * pow(specular, 8.0) * vec3(1.0, 0.92, 0.75) * (0.95 + 0.05*checker);\n        \n        color  = pow(color, vec3(4.0));\n    }\n\n    return color;\n}\n\n\nvec3 Shade(in vec3 hit, in vec4 layer, in float levelTransi)\n{\n    return Shade(hit, hit, layer, levelTransi);\n}\n\n\nvoid MaskBall(in vec2 uv, in float maskId, in float levelTransi, inout vec3 color)\n{\n    // Random scale anim:\n    float t = min(1.0, mod(2.0*iTime+11.5*maskId, 277.0));\n    float smt = 1.0 + 0.15*smoothstep(0.0, 1.0, 1.0-abs(2.0*t-1.0));\n   \n    // Intersect and shade:\n    vec2 center = MaskBallCenter(maskId);\n    vec4 hitS = BallIntersect(uv, center, smt*PlayBallRadius);\n    if(hitS.w > 0.0)\n    {\n        // Random rotation anim:\n        t = min(1.0, mod(2.0*iTime+23.5*maskId, 367.0));\n        float a = smoothstep(0.0, 1.0, 1.0-abs(2.0*t-1.0));\n        vec3 hit = vec3(cos(a)*hitS.x + sin(a)*hitS.y, -sin(a)*hitS.x + cos(a)*hitS.y, hitS.z);\n\n        // Spherical coordinates:\n        vec2 rs = vec2(atan(hit.x, hit.z), acos(-hit.y))/vec2(2.0*Pi,Pi) + vec2(0.5,0.0);\n\n        // Get mask based on id:\n        float mask = 0.0;\n        if(      maskId == 1.0 ) { mask = Hat(rs);      }\n        else if( maskId == 2.0 ) { mask = Belt(rs);     }\n        else if( maskId == 3.0 ) { mask = Strap(rs);    }\n        else if( maskId == 4.0 ) { mask = StripesH(rs); }\n        else if( maskId == 5.0 ) { mask = StripesV(rs); }\n        else if( maskId == 6.0 ) { mask = Smile(rs);    }\n        else if( maskId == 7.0 ) { mask = Pupils(rs);   }\n        else                     { mask = Eyes(rs);     }\n        \n        // Shade:\n        color = Shade(hit, vec4(vec3(0.02 + 0.85*(1.0 - mask)), 0.0), levelTransi);\n    }\n}\n\n\n\n\nvoid PaintBall(in vec2 uv, in float id, in vec3 paint, in float levelTransi, inout vec3 color)\n{\n    // Random scale anim:\n    float t = min(1.0, mod(2.0*iTime+13.5*id, 97.0));\n    float smt = 1.0 + 0.15*smoothstep(0.0, 1.0, 1.0-abs(2.0*t-1.0));\n\n    // Intersect and shade:\n    vec2 center = PaintBallCenter(id);\n    vec4 hitS = BallIntersect(uv, center, smt*PlayBallRadius);\n    if(hitS.w > 0.0)\n    {\n        color = Shade(hitS.xyz, vec4(paint, 0.0), levelTransi);\n    }\n}\n\n\n\nfloat Shadow(in vec2 uv, in vec2 center, in float radius)\n{\n    uv -= center + 0.05*vec2(-sin(iTime/10.0), -1.0);\n    radius = max(0.0, radius);\n    float d = length(uv) - radius;\n    \n    return smoothstep(-0.12, 0.12, d); \n}\n\nfloat Highlight(in vec2 uv, in float maskId)\n{\n    float isUsed = Load(mActiveMasks + vec2(maskId)).r;\n\n    uv -= MaskBallCenter(maskId);\n    float d = length(uv) - PlayBallRadius;\n    \n    return 0.9*isUsed*(1.0-smoothstep(-0.015, 0.03, d)); \n}\n\n\n\nvec3 Scene(in vec2 uv, in vec3 back, in float levelTransi)\n{\n    vec3 color = back;\n    \n    // Animation:\n    float t  = max(0.0, (levelTransi - 1.0/5.0)*5.0/4.0);\n    float t0 = 2.0*t;\n    float t1 = 2.0*(t-0.5);\n    float smt = smoothstep(0.0, 1.0, 1.0-abs(2.0*t-1.0));\n    float dy = t < 0.5 ? -pow(t0, 2.0) : pow(1.0-t1, 2.0);\n    vec2  duv = vec2(-0.5*smt, 0.0);\n\n    \n    // Player ball:\n    vec4 hitS = BallIntersect(uv, vec2(0.0, 2.0*dy), 0.7);\n    if(hitS.w > 0.0)\n    {\n        vec3 hit = hitS.xyz;\n\n        // Rotate:\n        float a = 0.2*cos(1.0*iTime)+0.2;\n        vec3 hitR = vec3(cos(a)*hit.x + sin(a)*hit.z, hit.y, -sin(a)*hit.x + cos(a)*hit.z);\n        \n        vec4 layer = BallTexture(hitR, iChannel3);\n        color = Shade(hit, hitR, layer, levelTransi);\n    }\n\n     \n    // Solution ball:\n    hitS = BallIntersect(uv, vec2(-1.37, 0.60+smt), 0.3);\n    if(hitS.w > 0.0)\n    {\n        vec3 hit = hitS.xyz;\n        vec4 layer = BallTexture(hit, iChannel2);\n        color = Shade(hit, layer, levelTransi);\n    }\n    \n    \n    // Reset ball:\n    hitS = BallIntersect(uv, vec2(-1.37, 0.0) + duv, PlayBallRadius);\n    if(hitS.w > 0.0)\n    {\n        vec3 hit = hitS.xyz;\n        vec4 layer = BallTexture(hit, iChannel2);\n        color = Shade(hit, ResetBallTexture(hit), levelTransi);\n    }\n   \n    \n    // Mask balls:\n    MaskBall(uv+duv, 1.0, levelTransi, color);\n    MaskBall(uv+duv, 2.0, levelTransi, color);\n    MaskBall(uv+duv, 3.0, levelTransi, color);\n    MaskBall(uv+duv, 4.0, levelTransi, color);\n    MaskBall(uv+duv, 5.0, levelTransi, color);\n    MaskBall(uv+duv, 6.0, levelTransi, color);\n    MaskBall(uv+duv, 7.0, levelTransi, color);\n    MaskBall(uv+duv, 8.0, levelTransi, color);\n\n    // Paint balls:\n    PaintBall(uv-duv, 0.0, blue,   levelTransi, color);\n    PaintBall(uv-duv, 1.0, yellow, levelTransi, color);\n    PaintBall(uv-duv, 2.0, red,    levelTransi, color);\n    PaintBall(uv-duv, 3.0, black,  levelTransi, color);\n    PaintBall(uv-duv, 4.0, white,  levelTransi, color);\n\n    return color;\n}\n\n\nvec3 Background(in vec2 uv, float levelTransi)\n{\n    // Animation:\n    float t  = max(0.0, (levelTransi - 1.0/5.0)*5.0/4.0);\n    float t0 = 2.0*t;\n    float t1 = 2.0*(t-0.5);\n    float smt = smoothstep(0.0, 1.0, 1.0-abs(2.0*t-1.0));\n    float dy = t < 0.5 ? -pow(t0, 2.0) : pow(1.0-t1, 2.0);\n    vec2  duv = vec2(-0.5*smt, 0.0);\n   \n    // Background:\n    vec3 color;\n    color = 0.6*vec3(0.4,0.6,0.7)*(1.0-0.4*length( uv ));\n    \n    // Adapted from: \"wave greek frieze (165 chars)\" by FabriceNeyret2\n    vec2 suv = 8.0*(uv + 1.0);\n    suv = fract(suv) - 0.5;\n    float a = 12.0 * max(0.0, 1.0 - 2.0*length(suv));\n    suv *= mat2(cos(a), -sin(a), sin(a), cos(a));\n\tcolor *= 0.88 + 0.12*smoothstep(-1.,1.,suv.y/fwidth(uv.y));\n\n  \n    // Shadows:\n    color = pow(color, vec3(2.2));\n    \n    float shadow = 1.0;\n    shadow *= Shadow(uv, vec2(0.0, 2.0*dy), 0.7);\n    shadow *= Shadow(uv, vec2(-1.37, 0.60+smt), 0.3);\n    shadow *= Shadow(uv-duv, vec2(-1.37, 0.0), PlayBallRadius);\n     \n    shadow *= Shadow(uv+duv, MaskBallCenter(1.0), PlayBallRadius);\n    shadow *= Shadow(uv+duv, MaskBallCenter(2.0), PlayBallRadius);\n    shadow *= Shadow(uv+duv, MaskBallCenter(3.0), PlayBallRadius);\n    shadow *= Shadow(uv+duv, MaskBallCenter(4.0), PlayBallRadius);\n    shadow *= Shadow(uv+duv, MaskBallCenter(5.0), PlayBallRadius);\n    shadow *= Shadow(uv+duv, MaskBallCenter(6.0), PlayBallRadius);\n    shadow *= Shadow(uv+duv, MaskBallCenter(7.0), PlayBallRadius);\n    shadow *= Shadow(uv+duv, MaskBallCenter(8.0), PlayBallRadius);\n    \n    \n    shadow *= Shadow(uv-duv, PaintBallCenter(0.0), PlayBallRadius);\n    shadow *= Shadow(uv-duv, PaintBallCenter(1.0), PlayBallRadius);\n    shadow *= Shadow(uv-duv, PaintBallCenter(2.0), PlayBallRadius);\n    shadow *= Shadow(uv-duv, PaintBallCenter(3.0), PlayBallRadius);\n    shadow *= Shadow(uv-duv, PaintBallCenter(4.0), PlayBallRadius);\n\n    color *= shadow;\n\n    // Highlights:\n    const vec3 hl = vec3(0.95,0.5,0.05);\n    color = mix(color, hl, Highlight(uv+duv, 1.0));\n    color = mix(color, hl, Highlight(uv+duv, 2.0));\n    color = mix(color, hl, Highlight(uv+duv, 3.0));\n    color = mix(color, hl, Highlight(uv+duv, 4.0));\n    color = mix(color, hl, Highlight(uv+duv, 5.0));\n    color = mix(color, hl, Highlight(uv+duv, 6.0));\n    color = mix(color, hl, Highlight(uv+duv, 7.0));\n    color = mix(color, hl, Highlight(uv+duv, 8.0));\n    \n    return color;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Load state:\n    float levelTransi  = Load(mLevelTransi).r;\n    levelTransi = clamp(1.0-(levelTransi-iTime)/LevelTransiDur, 0.0, 1.0);\n    \n   \n    // Render background:\n    vec2 uvr = (2.0*fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec3 back = Background(uvr, levelTransi);\n    \n    // Render scene:\n    float du = 2.0 / iResolution.y;\n    const float aa = 4.0;\n \n    vec3 color = vec3(0.0);\n    for(float y=0.0; y<aa; y++)\n    {\n        for(float x=0.0; x<aa; x++)\n        {\n            vec2 uvaa = uvr + du*(0.5+vec2(x,y))/aa;\n\t\t    color += Scene(uvaa, back, levelTransi);\n        }\n    }\n    \n    color /= aa*aa;\n    color = pow(color, vec3(0.4545));\n    \n    fragColor = vec4(color, 0.0);\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"ldSSWz","filepath":"https://soundcloud.com/adhesivewombat/adhesivewombat-8-bit-adventure","previewfilepath":"https://soundcloud.com/adhesivewombat/adhesivewombat-8-bit-adventure","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Buffer A\n// Inputs: Buffer A-n, Buffer B-l, ---, ---\n\n\n//----------------------------------------------------------------------------------------------\n// Load/Store from IQ (https://www.shadertoy.com/view/MddGzf)\n\n\nvec4 Load(in vec2 re)\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\n\n\n//----------------------------------------------------------------------------------------------\n\n\nbool IsLevelCompleted(in vec2 fragCoord)\n{\n    return length(texture(iChannel1, vec2(0.0))) <= 0.0001;\n\n}\n\nvec2 MaskBallCenter(in float maskId)\n{\n    maskId--;\n    if(maskId < 5.0)\n    {\n        float a = 90.0*(maskId/4.0 - 0.5)*Pi/180.0;\n        return 0.95*vec2(cos(a), sin(a));\n    }\n    else\n    {\n        float a = 38.0*((maskId-5.0)/2.0 - 0.5)*Pi/180.0;\n        return 1.35*vec2(cos(a), sin(a));\n    }\n}\n\n\nvec2 PaintBallCenter(in float id)\n{\n    float a = (180.0 + 90.0 * (id/4.0 - 0.5)) * Pi/180.0;\n    return 0.95*vec2(cos(a), sin(a));\n}\n\n\nvoid ClickedMaskBall(in vec2 uv, in float maskId, inout vec4 clicked)\n{\n    uv -= MaskBallCenter(maskId);\n    if(dot(uv, uv) < PlayBallRadius*PlayBallRadius)\n    {\n        clicked.a = maskId;\n    }\n}\n\nvoid ClickedPaintBall(in vec2 uv, in float id, in vec3 color, inout vec4 clicked)\n{\n    uv -= PaintBallCenter(id);\n    if(dot(uv, uv) < PlayBallRadius*PlayBallRadius)\n    {\n        clicked.rgb = color;\n    }\n}\n\n\nvec4 ClickedBall(vec2 mouse)\n{\n    vec2 uvM = (2.0*mouse.xy - iResolution.xy) / iResolution.y;\n    \n    // Mask Balls:\n    vec4 clicked = vec4(0.0);\n    ClickedMaskBall(uvM, 1.0, clicked);\n    ClickedMaskBall(uvM, 2.0, clicked);\n    ClickedMaskBall(uvM, 3.0, clicked);\n    ClickedMaskBall(uvM, 4.0, clicked);\n    ClickedMaskBall(uvM, 5.0, clicked);\n    ClickedMaskBall(uvM, 6.0, clicked);\n    ClickedMaskBall(uvM, 7.0, clicked);\n    ClickedMaskBall(uvM, 8.0, clicked);\n    \n    // Paint Balls:\n    ClickedPaintBall(uvM, 0.0, blue,   clicked);\n    ClickedPaintBall(uvM, 1.0, yellow, clicked);\n    ClickedPaintBall(uvM, 2.0, red,    clicked);\n    ClickedPaintBall(uvM, 3.0, black,  clicked);\n    ClickedPaintBall(uvM, 4.0, white,  clicked);\n    \n    // Reset ball:\n    vec2 uvc = uvM - vec2(-1.37, 0.0);\n    if(dot(uvc, uvc) < PlayBallRadius*PlayBallRadius)\n    {\n        clicked = vec4(-1.0);\n    }\n    \n    return clicked;\n}\n\n\n\nvec4 PlayTurn(in vec4 clicked, in float turn, inout vec4 fragColor, in vec2 fragCoord)\n{\n    \n    vec4 playedTurn = vec4(0.0);\n    \n    if(clicked.a > 0.0)\n    {\n        // User clicked a mask ball.\n        float maskId = clicked.a;\n\n        // Get current state:\n        float isUsed = Load(mActiveMasks + vec2(maskId)).r;\n        \n        // Toggle:\n        maskId *= 1.0-2.0*isUsed;\n        isUsed = abs(isUsed - 1.0);\n        \n        \n        // Store mask on/off operation:\n        Store(vec2(turn,0.0), vec4(0.0, 0.0, 0.0,  maskId), fragColor, fragCoord);\n        playedTurn.a = maskId;\n        \n        // Store state:\n        Store(mActiveMasks + vec2(abs(maskId)), vec4(isUsed), fragColor, fragCoord);\n    }\n    else if(clicked.r > 0.0)\n    {\n        // User clicked a paint ball.\n        vec3 color = clicked.rgb;\n\n        // Add color if different from previous one:\n        if(color != Load(vec2(turn, 0.0)).rgb)\n        {\n            Store(vec2(turn,0.0), vec4(color,0.0), fragColor, fragCoord);\n            playedTurn.rgb = color;\n        }\n    }\n    \n    return playedTurn;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Default:\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    \n    // Load state:\n    float level          = Load(mLevel).r;\n    float turnCount      = Load(mTurnCount).r;\n    vec4  playedTurn     = vec4(0.0);\n    vec4  mouse          = Load(mMouse);\n    bool  reset          = (iFrame < 10);\n    float levelTransi    = Load(mLevelTransi).r;\n    bool  levelCompleted = Load(mLevelCompleted).r == 1.0;\n    vec2  resolution     = Load(mResolution).xy;\n\n     \n    // Events:\n    //bool mouseClick = (mouse.z > 0.5) && (iMouse.z < 0.0);\n    bool mouseWasDown = mouse.z > 0. || mouse.w > 0.;\n    bool mouseIsUp = iMouse.z < 0. && iMouse.w < 0.;\n    bool mouseUp = mouseWasDown && mouseIsUp;\n    //if(mouseClick)\n    if(mouseUp)\n    {\n        //vec4 clicked = ClickedBall(mouse.zw);\n        vec4 clicked = ClickedBall(abs(mouse.zw));\n        \n        if(clicked.r == -1.0)\n        {\n            // User clicked the reset ball.\n            reset = true;\n            turnCount = 0.0;\n        }\n        else\n        {\n            // Play new turn:\n            turnCount++;\n            playedTurn = PlayTurn(clicked, turnCount, fragColor, fragCoord);\n        }\n\n    }\n    \n \n    \n    // Level Completed?\n    if((iTime > levelTransi) && (iFrame % 5 == 4) && (iFrame > 20))\n    {\n        levelCompleted = IsLevelCompleted(fragCoord);\n        if(levelCompleted)\n        {\n            levelTransi = iTime + LevelTransiDur;\n        }\n    }\n\n    \n    // Level Transition:\n    if(levelCompleted && (levelTransi - iTime < LevelTransiDur*4.0/10.0))\n    {\n        levelCompleted = false;\n        level = (level != 24.0) ? level + 1.0 : 0.0;\n        reset = true;\n        turnCount = 0.0;\n    }\n    \n    \n    // Reset all on resolution change:\n    if(resolution.xy != iResolution.xy)\n    {\n        levelCompleted = false;\n        level = 0.0;\n        reset = true;\n        turnCount = 0.0;\n        levelTransi = 0.0;\n    }\n    \n    if(reset)\n    {\n        // Clear masks:\n        Store(mActiveMasks + vec2(abs(1.0)), vec4(0.0), fragColor, fragCoord);\n        Store(mActiveMasks + vec2(abs(2.0)), vec4(0.0), fragColor, fragCoord);\n        Store(mActiveMasks + vec2(abs(3.0)), vec4(0.0), fragColor, fragCoord);\n        Store(mActiveMasks + vec2(abs(4.0)), vec4(0.0), fragColor, fragCoord);\n        Store(mActiveMasks + vec2(abs(5.0)), vec4(0.0), fragColor, fragCoord);\n        Store(mActiveMasks + vec2(abs(6.0)), vec4(0.0), fragColor, fragCoord);\n        Store(mActiveMasks + vec2(abs(7.0)), vec4(0.0), fragColor, fragCoord);\n        Store(mActiveMasks + vec2(abs(8.0)), vec4(0.0), fragColor, fragCoord);\n    }\n    \n    \n    // Save State:\n    Store( mLevel,          vec4(level),        fragColor, fragCoord);\n    Store( mTurnCount,      vec4(turnCount),    fragColor, fragCoord);\n    Store( mPlayedTurn,     playedTurn,         fragColor, fragCoord);\n    Store( mLevelCompleted, levelCompleted,     fragColor, fragCoord);\n    Store( mMouse,          iMouse,             fragColor, fragCoord);\n    Store( mReset,          reset,              fragColor, fragCoord);\n    Store( mLevelTransi,    vec4(levelTransi),  fragColor, fragCoord);\n    Store( mResolution,     iResolution.xyxy,   fragColor, fragCoord);\n}\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Buffer B\n// Inputs: Buffer A-n, Buffer B-n, Buffer C-l, Buffer B-l\n\n\n\n\n#define k 1.55\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n \tconst vec2 count = vec2(40.0, 20.0);\n    if((fragCoord.x < count.x) && (fragCoord.y < count.y))\n    {\n        int frame = iFrame % 5;\n        if(frame == 0)\n        {\n            // Optimized non-uniform sampling:\n            vec2 uv = fragCoord / count;\n\n            float xf = 2.0*(uv.x - 0.5);\n            uv.x = 0.5 + sign(xf)*(exp(k*abs(xf)) - 1.0) / (exp(k) - 1.0)/2.0;\n            uv.y = (exp(k*uv.y) - 1.0) / (exp(k) - 1.0);\n            uv.y = 0.05 + 0.92*uv.y;            \n\n            // Store solution buffer:\n            fragColor = texture(iChannel2, uv);\n        }\n        else if(frame == 1)\n        {\n            // Optimized non-uniform sampling:\n            vec2 uv = fragCoord / count;\n\n            float xf = 2.0*(uv.x - 0.5);\n            uv.x = 0.5 + sign(xf)*(exp(k*abs(xf)) - 1.0) / (exp(k) - 1.0)/2.0;\n            uv.y = (exp(k*uv.y) - 1.0) / (exp(k) - 1.0);\n            uv.y = 0.05 + 0.92*uv.y;            \n\n            // Store solution/play difference:  \n            vec4 play     = texture(iChannel3, uv);\n            vec4 solution = texture(iChannel1, fragCoord/iResolution.xy);\n            fragColor = abs(play - solution);\n        }\n        else if(frame == 2)\n        {\n            vec4 sum = vec4(0.0);\n            for(float i=0.0; i<count.x; i++)\n            {\n                sum += texture(iChannel1, vec2(i, fragCoord.y)/iResolution.xy);\n            }\n        \tfragColor = sum;\n        }\n        else if(frame == 3)\n        {\n            vec4 sum = vec4(0.0);\n            for(float i=0.0; i<count.y; i++)\n            {\n                sum += texture(iChannel1, vec2(fragCoord.y, i)/iResolution.xy);\n            }\n\t        fragColor = sum;\n        }\n        else\n        {\n            discard;\n        }\n    }\n   \n }\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Buffer C\n// Inputs: Buffer A-n, Buffer C-l, ---, ---\n#define IsBufferC\n\n\n// Beyond this point, Buffer C and D use the exact same code.\n//----------------------------------------------------------------------------------------------\n\n\n\n//----------------------------------------------------------------------------------------------\n// Load / Store (from IQ)\n\nvec4 Load( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\n\n\n//----------------------------------------------------------------------------------------------\n\nvec2 TextureCoord(in vec2 fragCoord)\n{\n    vec2 uv = vec2(fragCoord.y, 2.0*fragCoord.x - iResolution.x) / iResolution.yx;\n\n    float distSq = dot(uv, uv);\n    vec3 hit = vec3(uv.x, uv.y, sqrt(1.0 - min(1.0, distSq)));\n    vec2 rs = vec2(atan(hit.x, hit.z), acos(-hit.y/1.0))/vec2(2.0*Pi,Pi) + vec2(0.5,0.0);\n\treturn rs;    \n}\n\n\n\n#ifdef IsBufferC\n//----------------------------------------------------------------------------------------------\n// Draw solution:\n\n\n#define ooooo color.rgb  = mix(white , color.rgb, min(color.a, 1.0));\n#define ooooO color.rgb  = mix(black , color.rgb, min(color.a, 1.0));\n#define oooOo color.rgb  = mix(red   , color.rgb, min(color.a, 1.0));\n#define oooOO color.rgb  = mix(yellow, color.rgb, min(color.a, 1.0));\n#define ooOoo color.rgb  = mix(blue  , color.rgb, min(color.a, 1.0));\n#define ooOoO color.a   += Hat      (uv);\n#define ooOOo color.a   += Belt     (uv);\n#define ooOOO color.a   += Strap    (uv);\n#define oOooo color.a   += StripesH (uv);\n#define oOooO color.a   += StripesV (uv);\n#define oOoOo color.a   += Smile    (uv);\n#define oOoOO color.a   += Pupils   (uv);\n#define oOOoo color.a   += Eyes     (uv);  \n#define oOOoO color.a   -= Hat      (uv);\n#define oOOOo color.a   -= Belt     (uv);\n#define oOOOO color.a   -= Strap    (uv);\n#define Ooooo color.a   -= StripesH (uv);\n#define OoooO color.a   -= StripesV (uv);\n#define OooOo color.a   -= Smile    (uv);\n#define OooOO color.a   -= Pupils   (uv);\n#define OoOoo color.a   -= Eyes     (uv);\n\n\nvec4 Level0_14(in vec2 uv, in float level)\n{\n    vec4 color = vec4(white, 0.0);\n    \n    if(level == 0.0)\n    {\n        oOOoo ooOoo OoOoo\n    }\n    else if(level == 1.0)\n    {\n        ooooO oOoOO ooooo OooOO oOOoo oOoOo oooOo OooOo OoOoo\n    }\n    else if(level == 2.0)\n    {\n        oooOO ooOOO ooooO ooOoO oOOOO oooOo ooOOO ooOoo oOOOO oOOoO\n    }\n    else if(level == 3.0)\n    {\n        oooOO oOooO ooOoo oOooo OoooO ooOoo oOooO oooOO Ooooo OoooO\n    }\n    else if(level == 4.0)\n    {\n        ooooO ooOoO oOOoo ooOoo oOooO oooOO OoooO OoOoo oOOoO \n    }\n    else if(level == 5.0)\n    {\n        ooooO oOoOO ooooo OooOO ooOoO ooOoo oOOoO oOOoo oooOO OoOoo\n    }\n    else if(level == 6.0)\n    {\n        oooOo oOooo oooOO ooOOo Ooooo oooOO oOooo oooOo Ooooo oOOOo\n    }\n    else if(level == 7.0)\n    {\n        oOooO oOooo ooOoo Ooooo OoooO ooOOO ooOoo oOOOO ooOOo ooOoo oOOOo\n    }\n    else if(level == 8.0)\n    {\n        ooooO oOoOo oOOoo ooOOo oooOO oOOOo ooOoO oooOO oOOoO OooOo OoOoo\n    }\n    else if(level == 9.0)\n    {\n        ooooO oOoOO oOoOo ooooo OooOO ooOOO ooOOo ooOoo oOOOO oOOOo oOOoo ooOoo OooOo OoOoo\n    }\n    if(level == 10.0)\n    {\n        ooooO oOooO oOooo oooOO OoooO Ooooo ooOOo ooOOO oooOO oOOOO oOOOo \n    }\n    else if(level == 11.0)\n    {\n        oooOO ooOoO oooOo oOooO ooOoo OoooO oOooo oooOO ooOOo Ooooo oooOO oOOOo oOOoO\n    }\n    else if(level == 12.0)\n    {\n        ooOoo oOooO ooooo oOooo OoooO ooooo oOooO ooOoo OoooO ooooO oOooO oooOo OoooO Ooooo\n    }\n    else if(level == 13.0)\n    {\n        ooooO oOoOO ooooo oOOoo ooOoo OoOoo OooOO ooOoO oooOo oOOoO oOooo oooOo Ooooo oOOoo ooOoo OoOoo \n    }\n    else if(level == 14.0)\n    {\n        ooOoo ooOOo ooOoo oOooO oOooo ooooo oOOOo Ooooo OoooO ooOoO ooooo oOooO oooOo OoooO oOOoO\n    }\n    \n    return color;\n}\n\n\n\nvec4 Level15_24(in vec2 uv, in float level)\n{\n    vec4 color = vec4(white, 0.0);\n    \n\n    if(level == 15.0)\n    {\n        ooooO oOoOO ooooo oOOoo oooOo ooOOo ooOoO ooooO oOooO ooooo oOoOo OoooO oooOo oOOOo oOOoO OooOo OooOO OoOoo \n    }\n    else if(level == 16.0)\n    {\n        ooooO oOoOo oOoOO ooooo OooOO oOOoo oooOO oOooO ooOoo OoooO ooOOo oooOO oOOOo ooOOO oooOO oOOOO OooOo OoOoo \n    }\n    else if(level == 17.0)\n    {\n        ooooO oOoOo oOoOO ooooo oOooO oooOo OoooO oOooo oooOo oOooO ooooo OoooO Ooooo oOOoo oooOO OoOoo OooOO OooOo \n    }\n    else if(level == 18.0)\n    {\n        oooOo oOooo ooOoo oOooO ooooo OoooO ooOOO ooooo oOOOO Ooooo ooOOo ooOoo oOooO ooooo OoooO ooOOO ooooo oOOOO oOOOo\n    }\n    else if(level == 19.0)\n    {\n        ooooO oOoOO oOoOo ooOOo ooooo oOOOo oOooo ooooo Ooooo ooOoO ooooo oOOoO oOOoo ooooO ooOOo ooOoo oOOOo oOooo ooOoo Ooooo ooOoO ooOoo ooOOo oooOO oOOoO oOOOo OooOo OooOO OoOoo \n    }\n    else if(level == 20.0)\n    {\n        ooOoo oOooO oooOO OoooO oOooo oooOO oOooO ooOoo OoooO Ooooo ooOoO oooOO oOooO ooOoo OoooO oOooo ooOoo oOooO oooOO Ooooo OoooO ooOOo ooOoo oOooO oooOO OoooO oOooo oooOO oOooO ooOoo OoooO Ooooo oOOOo oOOoO \n    }\n    else if(level == 21.0)\n    {\n        ooooO oOooO oOooo oooOo ooOOO oooOO oOOOO ooOOo ooOoo Ooooo OoooO ooOOO oooOo oOooO ooooo OoooO oOooo ooooo oOooO oooOo OoooO Ooooo ooOoO ooooo oOooO oooOo OoooO oOooo oooOo oOooO ooooo Ooooo OoooO oOOoO oOOOO oOOOo \n    }\n    else if(level == 22.0)\n    {\n        oooOo oOooo ooOoo oOooO oooOO OoooO ooOOO oooOO oOOOO Ooooo ooOOo ooOoo oOooO oooOO OoooO ooOOO oooOO oOOOO oOOOo ooOoO ooOoo oOooO oooOo oOooo oooOO Ooooo ooOOo oooOO OoooO oOOOo ooOOO oooOo oOooo oooOO Ooooo ooOOo oooOO oOOOO oOOOo oOOoO \n    }\n    else if(level == 23.0)\n    {\n        ooooO oOooO oooOo OoooO oOooo oooOO oOooO ooOoo OoooO Ooooo ooOOO oooOo oOooO ooooO OoooO oOooo ooOoo oOooO oooOO OoooO Ooooo ooOOo oooOO oOooO ooOoo OoooO oOooo ooooO oOooO oooOo Ooooo OoooO oOOOO oOOOo\n    }\n    else\n    {\n        ooooO oOooO ooooo OoooO ooOOO ooooo oOooO ooooO OoooO oOOOO oOoOo ooooO ooOOo ooOOO ooooo oOOOo oOOOO oOoOO ooooo ooOOo oOooo ooooO Ooooo oOOOo OooOO oOOoo ooOoo ooOOo oOooo ooooo oOooO ooOoo Ooooo ooOoO OoooO oooOO oOooO ooOoo OoooO ooOOO oooOo oOooO ooooo oOOOO oOOOo oOOoO OoooO OooOo OoOoo\n    }\n\n    return color;\n}\n\n\nvoid DrawSolution(inout vec4 fragColor, in vec2 fragCoord)\n{\n    if(Load(mReset).r == 1.0)\n    {\n        // Get level:\n        float level = Load(mLevel).r;\n        \n        // Draw level:\n        vec2 rs = TextureCoord(fragCoord);\n        if(level < 15.0)\n        {\n\t        fragColor = Level0_14(rs, level);\n        }\n        else\n        {\n\t        fragColor = Level15_24(rs, level);\n        }\n    }\n    else\n    {\n        vec2 uv = fragCoord / iResolution.xy;\n        fragColor = texture(iChannel1, uv);\n    }\n}\n\n#endif \n\n\n\n#ifdef IsBufferD\n//----------------------------------------------------------------------------------------------\n// Draw player turn:\n\nvec4 AddLayer(in vec4 background, in vec2 rs, in vec4 opCode)\n{\n    // Initial color is background:\n    vec4 color = background;\n    \n    if(opCode != vec4(0.0))\n    {\n        // Add turn:\n        if(opCode.a == 0.0)\n        {\n            // Paint unmasked area:\n            color.rgb = mix(opCode.rgb, color.rgb, min(color.a, 1.0));\n        }\n        else\n        {\n            // Combine current mask with new shape layer:\n            float maskOp  = abs(opCode.a);\n            float newMask = 1.0;\n            \n            if(      maskOp == 1.0 ) { newMask = Hat(rs);      }\n            else if( maskOp == 2.0 ) { newMask = Belt(rs);     }\n            else if( maskOp == 3.0 ) { newMask = Strap(rs);    }\n            else if( maskOp == 4.0 ) { newMask = StripesH(rs); }\n            else if( maskOp == 5.0 ) { newMask = StripesV(rs); }\n            else if( maskOp == 6.0 ) { newMask = Smile(rs);    }\n            else if( maskOp == 7.0 ) { newMask = Pupils(rs);   }\n            else                     { newMask = Eyes(rs);     }\n                  \n            color.a += newMask*sign(opCode.a);\n        }\n    }\n   \n    return color;\n}\n\n\nvoid DrawTurn(inout vec4 fragColor, in vec2 fragCoord)\n{\n    if(Load(mReset).r == 1.0)\n    {\n        fragColor = vec4(white, 0.0);\n    }\n    else\n    {\n        // Get opcode:\n        vec4 opcode = Load(mPlayedTurn);\n\n        // Get backgound layer:\n        vec2 uv = fragCoord/iResolution.xy;\n        vec4 background = texture(iChannel1, uv);\n            \n        // Add layer:\n        vec2 rs = TextureCoord(fragCoord);\n        fragColor = AddLayer(background, rs, opcode);\n    }\n}\n\n\n\n\n//----------------------------------------------------------------------------------------------\n#endif\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n#ifdef IsBufferC\n    DrawSolution(fragColor, fragCoord);\n#else\n    DrawTurn(fragColor, fragCoord);\n#endif\n}\n\n\n\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Buffer D\n// Inputs: Buffer A-n, Buffer D-l, ---, ---\n#define IsBufferD\n\n\n// Beyond this point, Buffer C and D use the exact same code.\n//----------------------------------------------------------------------------------------------\n\n\n\n//----------------------------------------------------------------------------------------------\n// Load / Store (from IQ)\n\nvec4 Load( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\n\n\n//----------------------------------------------------------------------------------------------\n\nvec2 TextureCoord(in vec2 fragCoord)\n{\n    vec2 uv = vec2(fragCoord.y, 2.0*fragCoord.x - iResolution.x) / iResolution.yx;\n\n    float distSq = dot(uv, uv);\n    vec3 hit = vec3(uv.x, uv.y, sqrt(1.0 - min(1.0, distSq)));\n    vec2 rs = vec2(atan(hit.x, hit.z), acos(-hit.y/1.0))/vec2(2.0*Pi,Pi) + vec2(0.5,0.0);\n\treturn rs;    \n}\n\n\n\n#ifdef IsBufferC\n//----------------------------------------------------------------------------------------------\n// Draw solution:\n\n\n#define ooooo color.rgb  = mix(white , color.rgb, min(color.a, 1.0));\n#define ooooO color.rgb  = mix(black , color.rgb, min(color.a, 1.0));\n#define oooOo color.rgb  = mix(red   , color.rgb, min(color.a, 1.0));\n#define oooOO color.rgb  = mix(yellow, color.rgb, min(color.a, 1.0));\n#define ooOoo color.rgb  = mix(blue  , color.rgb, min(color.a, 1.0));\n#define ooOoO color.a   += Hat      (uv);\n#define ooOOo color.a   += Belt     (uv);\n#define ooOOO color.a   += Strap    (uv);\n#define oOooo color.a   += StripesH (uv);\n#define oOooO color.a   += StripesV (uv);\n#define oOoOo color.a   += Smile    (uv);\n#define oOoOO color.a   += Pupils   (uv);\n#define oOOoo color.a   += Eyes     (uv);  \n#define oOOoO color.a   -= Hat      (uv);\n#define oOOOo color.a   -= Belt     (uv);\n#define oOOOO color.a   -= Strap    (uv);\n#define Ooooo color.a   -= StripesH (uv);\n#define OoooO color.a   -= StripesV (uv);\n#define OooOo color.a   -= Smile    (uv);\n#define OooOO color.a   -= Pupils   (uv);\n#define OoOoo color.a   -= Eyes     (uv);\n\n\nvec4 Level0_14(in vec2 uv, in float level)\n{\n    vec4 color = vec4(white, 0.0);\n    \n    if(level == 0.0)\n    {\n        oOOoo ooOoo OoOoo\n    }\n    else if(level == 1.0)\n    {\n        ooooO oOoOO ooooo OooOO oOOoo oOoOo oooOo OooOo OoOoo\n    }\n    else if(level == 2.0)\n    {\n        oooOO ooOOO ooooO ooOoO oOOOO oooOo ooOOO ooOoo oOOOO oOOoO\n    }\n    else if(level == 3.0)\n    {\n        oooOO oOooO ooOoo oOooo OoooO ooOoo oOooO oooOO Ooooo OoooO\n    }\n    else if(level == 4.0)\n    {\n        ooooO ooOoO oOOoo ooOoo oOooO oooOO OoooO OoOoo oOOoO \n    }\n    else if(level == 5.0)\n    {\n        ooooO oOoOO ooooo OooOO ooOoO ooOoo oOOoO oOOoo oooOO OoOoo\n    }\n    else if(level == 6.0)\n    {\n        oooOo oOooo oooOO ooOOo Ooooo oooOO oOooo oooOo Ooooo oOOOo\n    }\n    else if(level == 7.0)\n    {\n        oOooO oOooo ooOoo Ooooo OoooO ooOOO ooOoo oOOOO ooOOo ooOoo oOOOo\n    }\n    else if(level == 8.0)\n    {\n        ooooO oOoOo oOOoo ooOOo oooOO oOOOo ooOoO oooOO oOOoO OooOo OoOoo\n    }\n    else if(level == 9.0)\n    {\n        ooooO oOoOO oOoOo ooooo OooOO ooOOO ooOOo ooOoo oOOOO oOOOo oOOoo ooOoo OooOo OoOoo\n    }\n    if(level == 10.0)\n    {\n        ooooO oOooO oOooo oooOO OoooO Ooooo ooOOo ooOOO oooOO oOOOO oOOOo \n    }\n    else if(level == 11.0)\n    {\n        oooOO ooOoO oooOo oOooO ooOoo OoooO oOooo oooOO ooOOo Ooooo oooOO oOOOo oOOoO\n    }\n    else if(level == 12.0)\n    {\n        ooOoo oOooO ooooo oOooo OoooO ooooo oOooO ooOoo OoooO ooooO oOooO oooOo OoooO Ooooo\n    }\n    else if(level == 13.0)\n    {\n        ooooO oOoOO ooooo oOOoo ooOoo OoOoo OooOO ooOoO oooOo oOOoO oOooo oooOo Ooooo oOOoo ooOoo OoOoo \n    }\n    else if(level == 14.0)\n    {\n        ooOoo ooOOo ooOoo oOooO oOooo ooooo oOOOo Ooooo OoooO ooOoO ooooo oOooO oooOo OoooO oOOoO\n    }\n    \n    return color;\n}\n\n\n\nvec4 Level15_24(in vec2 uv, in float level)\n{\n    vec4 color = vec4(white, 0.0);\n    \n\n    if(level == 15.0)\n    {\n        ooooO oOoOO ooooo oOOoo oooOo ooOOo ooOoO ooooO oOooO ooooo oOoOo OoooO oooOo oOOOo oOOoO OooOo OooOO OoOoo \n    }\n    else if(level == 16.0)\n    {\n        ooooO oOoOo oOoOO ooooo OooOO oOOoo oooOO oOooO ooOoo OoooO ooOOo oooOO oOOOo ooOOO oooOO oOOOO OooOo OoOoo \n    }\n    else if(level == 17.0)\n    {\n        ooooO oOoOo oOoOO ooooo oOooO oooOo OoooO oOooo oooOo oOooO ooooo OoooO Ooooo oOOoo oooOO OoOoo OooOO OooOo \n    }\n    else if(level == 18.0)\n    {\n        oooOo oOooo ooOoo oOooO ooooo OoooO ooOOO ooooo oOOOO Ooooo ooOOo ooOoo oOooO ooooo OoooO ooOOO ooooo oOOOO oOOOo\n    }\n    else if(level == 19.0)\n    {\n        ooooO oOoOO oOoOo ooOOo ooooo oOOOo oOooo ooooo Ooooo ooOoO ooooo oOOoO oOOoo ooooO ooOOo ooOoo oOOOo oOooo ooOoo Ooooo ooOoO ooOoo ooOOo oooOO oOOoO oOOOo OooOo OooOO OoOoo \n    }\n    else if(level == 20.0)\n    {\n        ooOoo oOooO oooOO OoooO oOooo oooOO oOooO ooOoo OoooO Ooooo ooOoO oooOO oOooO ooOoo OoooO oOooo ooOoo oOooO oooOO Ooooo OoooO ooOOo ooOoo oOooO oooOO OoooO oOooo oooOO oOooO ooOoo OoooO Ooooo oOOOo oOOoO \n    }\n    else if(level == 21.0)\n    {\n        ooooO oOooO oOooo oooOo ooOOO oooOO oOOOO ooOOo ooOoo Ooooo OoooO ooOOO oooOo oOooO ooooo OoooO oOooo ooooo oOooO oooOo OoooO Ooooo ooOoO ooooo oOooO oooOo OoooO oOooo oooOo oOooO ooooo Ooooo OoooO oOOoO oOOOO oOOOo \n    }\n    else if(level == 22.0)\n    {\n        oooOo oOooo ooOoo oOooO oooOO OoooO ooOOO oooOO oOOOO Ooooo ooOOo ooOoo oOooO oooOO OoooO ooOOO oooOO oOOOO oOOOo ooOoO ooOoo oOooO oooOo oOooo oooOO Ooooo ooOOo oooOO OoooO oOOOo ooOOO oooOo oOooo oooOO Ooooo ooOOo oooOO oOOOO oOOOo oOOoO \n    }\n    else if(level == 23.0)\n    {\n        ooooO oOooO oooOo OoooO oOooo oooOO oOooO ooOoo OoooO Ooooo ooOOO oooOo oOooO ooooO OoooO oOooo ooOoo oOooO oooOO OoooO Ooooo ooOOo oooOO oOooO ooOoo OoooO oOooo ooooO oOooO oooOo Ooooo OoooO oOOOO oOOOo\n    }\n    else\n    {\n        ooooO oOooO ooooo OoooO ooOOO ooooo oOooO ooooO OoooO oOOOO oOoOo ooooO ooOOo ooOOO ooooo oOOOo oOOOO oOoOO ooooo ooOOo oOooo ooooO Ooooo oOOOo OooOO oOOoo ooOoo ooOOo oOooo ooooo oOooO ooOoo Ooooo ooOoO OoooO oooOO oOooO ooOoo OoooO ooOOO oooOo oOooO ooooo oOOOO oOOOo oOOoO OoooO OooOo OoOoo\n    }\n\n    return color;\n}\n\n\nvoid DrawSolution(inout vec4 fragColor, in vec2 fragCoord)\n{\n    if(Load(mReset).r == 1.0)\n    {\n        // Get level:\n        float level = Load(mLevel).r;\n        \n        // Draw level:\n        vec2 rs = TextureCoord(fragCoord);\n        if(level < 15.0)\n        {\n\t        fragColor = Level0_14(rs, level);\n        }\n        else\n        {\n\t        fragColor = Level15_24(rs, level);\n        }\n    }\n    else\n    {\n        vec2 uv = fragCoord / iResolution.xy;\n        fragColor = texture(iChannel1, uv);\n    }\n}\n\n#endif \n\n\n\n#ifdef IsBufferD\n//----------------------------------------------------------------------------------------------\n// Draw player turn:\n\nvec4 AddLayer(in vec4 background, in vec2 rs, in vec4 opCode)\n{\n    // Initial color is background:\n    vec4 color = background;\n    \n    if(opCode != vec4(0.0))\n    {\n        // Add turn:\n        if(opCode.a == 0.0)\n        {\n            // Paint unmasked area:\n            color.rgb = mix(opCode.rgb, color.rgb, min(color.a, 1.0));\n        }\n        else\n        {\n            // Combine current mask with new shape layer:\n            float maskOp  = abs(opCode.a);\n            float newMask = 1.0;\n            \n            if(      maskOp == 1.0 ) { newMask = Hat(rs);      }\n            else if( maskOp == 2.0 ) { newMask = Belt(rs);     }\n            else if( maskOp == 3.0 ) { newMask = Strap(rs);    }\n            else if( maskOp == 4.0 ) { newMask = StripesH(rs); }\n            else if( maskOp == 5.0 ) { newMask = StripesV(rs); }\n            else if( maskOp == 6.0 ) { newMask = Smile(rs);    }\n            else if( maskOp == 7.0 ) { newMask = Pupils(rs);   }\n            else                     { newMask = Eyes(rs);     }\n                  \n            color.a += newMask*sign(opCode.a);\n        }\n    }\n   \n    return color;\n}\n\n\nvoid DrawTurn(inout vec4 fragColor, in vec2 fragCoord)\n{\n    if(Load(mReset).r == 1.0)\n    {\n        fragColor = vec4(white, 0.0);\n    }\n    else\n    {\n        // Get opcode:\n        vec4 opcode = Load(mPlayedTurn);\n\n        // Get backgound layer:\n        vec2 uv = fragCoord/iResolution.xy;\n        vec4 background = texture(iChannel1, uv);\n            \n        // Add layer:\n        vec2 rs = TextureCoord(fragCoord);\n        fragColor = AddLayer(background, rs, opcode);\n    }\n}\n\n\n\n\n//----------------------------------------------------------------------------------------------\n#endif\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n#ifdef IsBufferC\n    DrawSolution(fragColor, fragCoord);\n#else\n    DrawTurn(fragColor, fragCoord);\n#endif\n}\n\n\n\n","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n//----------------------------------------------------------------------------------------------\n// Memory\n\nconst vec2 mTurnCount      = vec2(0.0,  0.0);\nconst vec2 mLevelCount     = vec2(0.0,  4.0);\nconst vec2 mMouse          = vec2(0.0,  8.0);\nconst vec2 mLevelCompleted = vec2(0.0,  9.0);\nconst vec2 mPlayedTurn     = vec2(1.0,  9.0);\nconst vec2 mReset          = vec2(2.0,  9.0);\t// Reset a level (redraw buffer C and D)\nconst vec2 mLevel          = vec2(3.0,  9.0);\nconst vec2 mLevelTransi    = vec2(4.0,  9.0);\nconst vec2 mResolution     = vec2(5.0,  9.0);\nconst vec2 mActiveMasks    = vec2(0.0, 10.0);\t// 1 to 8\n\n\nconst vec2 mDebug0         = vec2(0.0, 10.0);\nconst vec2 mDebug1         = vec2(1.0, 10.0);\nconst vec2 mDebug2         = vec2(2.0, 10.0);\n\n\n//----------------------------------------------------------------------------------------------\n// Defines and const\n\nconst vec3 gray   = vec3(0.5, 0.5, 0.5);\n\nconst vec3 black  = vec3(0.03, 0.03, 0.03);\nconst vec3 white  = vec3(0.90, 0.90, 0.90);\nconst vec3 red    = vec3(0.90, 0.05, 0.05);\nconst vec3 yellow = vec3(0.90, 0.90, 0.05);\nconst vec3 blue   = vec3(0.10, 0.10, 0.90);\n\n\nconst float hat      = 1.0;\nconst float belt     = 2.0;\nconst float strap    = 3.0;\nconst float stripesH = 4.0;\nconst float stripesV = 5.0;\nconst float smile    = 6.0;\nconst float pupils   = 7.0;\nconst float eyes     = 8.0;\n\n\n#define PlayBallRadius 0.15\n#define LevelTransiDur 2.25\n\n#define Pi 3.14159265359\n\n\n//----------------------------------------------------------------------------------------------\n// Load/Store from IQ (https://www.shadertoy.com/view/MddGzf)\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\n\n\nvoid Store(in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\nvoid Store(in vec2 re, in bool va, inout vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? vec4(va) : fragColor;\n}\n\n\n\n//----------------------------------------------------------------------------------------------\n// Masks\n\nfloat Hat(vec2 uv)\n{\n    return step(0.5, uv.y);\n}\n\nfloat Strap(vec2 uv)\n{\n    float x = cos(2.0*Pi*uv.x-Pi/2.0)*cos(Pi*uv.y-Pi/2.0);\n    return step(abs(x)-0.2, 0.0);\n}\n\nfloat Belt(vec2 uv)\n{\n    float y = sin(Pi*uv.y-Pi/2.0);\n    return step(abs(y)-0.2, 0.0);\n}\n\nfloat Eyes(vec2 uv)\n{\n    float e;\n    uv.x *= 2.0;    \n    e  = step(length(uv-vec2(1.118,0.55))-0.098, 0.0);\n    e += step(length(uv-vec2(0.88,0.55))-0.1, 0.0);\n    return e;\n}\n\nfloat Pupils(vec2 uv)\n{\n    float e;\n    uv.x *= 2.0;    \n    e  = step(length(uv-vec2(1.08,0.55))-0.05, 0.0);\n    e += step(length(uv-vec2(0.92,0.55))-0.05, 0.0);\n    return e;\n}\n\nfloat SmileOld(vec2 uv)\n{\n    float e;\n    uv.x *= 2.0;    \n    e  = step(length(uv-vec2(1.00,0.50))-0.25, 0.0);\n    e -= step(length(uv-vec2(1.00,0.85))-0.50, 0.0);\n    \n    return max(e, 0.0);\n}\n\nfloat Smile(vec2 uv)\n{\n    float e;\n    uv.x *= 2.0;    \n    e  = step(length(uv-vec2(1.00,0.50))-0.25, 0.0);\n    e -= step(length(uv-vec2(1.00,0.50))-0.20, 0.0);\n    e *= step(length(uv-vec2(1.00,0.08))-0.35, 0.0);\n    return max(e, 0.0);\n}\n\n\nfloat StripesV(vec2 uv)\n{\n    float x = cos(2.0*Pi*uv.x-Pi/2.0)*cos(Pi*uv.y-Pi/2.0);\n    x = fract(2.0*x-0.25);\n    return step(abs(x)-0.5, 0.0);\n}\n\n\nfloat StripesH(vec2 uv)\n{\n    float y = sin(Pi*uv.y-Pi/2.0);\n    y = fract(2.0*y-0.25);\n    return step(abs(y)-0.5, 0.0);\n}\n\n","name":"Common","description":"","type":"common"}]}