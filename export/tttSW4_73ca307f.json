{"ver":"0.1","info":{"id":"tttSW4","date":"1580980009","viewed":152,"name":"My Raytracing 101","username":"Eikins","description":"Learning raytracing","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ===== PARAM =====\n#define NB_STEPS 5\n\n// ===== SCENE =====\n#define PLANE_LEN 6\n#define SPHERE_LEN 3\nconst Plane[PLANE_LEN] planes = Plane[](\n    Plane(vec3(0.0, 1.0, 0.0), 2.0),\n\tPlane(vec3(0.0, 0.0, -1.0), 10.0),\n\tPlane(vec3(-1.0, 0.0, 0.0), 10.0),\n\tPlane(vec3(1.0, 0.0, 0.0), 10.0),\n\tPlane(vec3(0.0, -1.0, 0.0), 10.0),\n\tPlane(vec3(0.0, 0.0, 1.0), 10.0)\n);\nconst PhongMat[PLANE_LEN] planeMats = PhongMat[](\n    PhongMat(vec3(0.1, 0.1, 0.1), 0.5, vec3(1.0, 1.0, 1.0) * 0.2, 5.0, 0.1),\n    PhongMat(vec3(0.75, 0.31, 0.31), 0.5, vec3(1.0, 1.0, 1.0) * 0.2, 4.0, 0.1),\n    PhongMat(vec3(0.0, 0.0, 0.0), 0.5, vec3(1.0, 1.0, 1.0) * 0.2, 4.0, 1.0),\n    PhongMat(vec3(0.31, 0.31, 0.75), 0.5, vec3(1.0, 1.0, 1.0) * 0.2, 4.0, 0.1),\n    PhongMat(vec3(0.55, 0.61, 0.71), 0.5, vec3(1.0, 1.0, 1.0) * 0.2, 4.0, 0.1),\n    PhongMat(vec3(0.31, 0.55, 0.31), 0.5, vec3(1.0, 1.0, 1.0) * 0.0, 4.0, 0.1)\n);\n\n\nconst Sphere[SPHERE_LEN] spheres = Sphere[](\n    Sphere(vec3(0.0, 4.0, 7.0), 1.0),\n\tSphere(vec3(7.0, -1, 4.0), 2.0),\n    Sphere(vec3(-6.0, 0.0, 6.0), 3.0));\nconst PhongMat[SPHERE_LEN] sphereMats = PhongMat[](\n    PhongMat(vec3(0.0, 0.6, 0.86), 0.2, vec3(1.0, 1.0, 1.0) * 0.2, 3.0, 0.25),\n    PhongMat(vec3(0.24, 0.54, 0.28), 0.4, vec3(1.0, 1.0, 1.0) * 0.2, 2.0, 0.1),\n    PhongMat(vec3(0, 0, 0), 0.2, vec3(0.0, 0.0, 0.0), 3.0, 1.0));\n\nconst PointLight[1] pointLights = PointLight[](\n    PointLight(vec3(-3.0, 2.0, 2.0), vec3(1.0, 0.0, 1.0), 1.0));\n\nconst vec3 LIGHT_DIRECTION = normalize(vec3(1.0, 1.0, 1.0));\n\n// ===== CAMERA =====\n#define NEAR_DISTANCE 2.0\n#define FAR_DISTANCE 200.0\n\nFrame CAMERA = Frame(vec3(1, 0, 0), vec3(0, 1, 0), vec3(0, 0, 1));\nvec3 EYE_POS = vec3(0.0, 1.0, -8.0);\nconst vec4 BACKGROUND_COLOR = vec4(.45, .85, .92, 1);\n\nISObj raycast(in Ray ray) {\n    ISObj nearestObj = ISObj(FAR_DISTANCE, -1, -1, vec3(0.0, 0.0, 0.0));\n    \n    for (int i = 0; i < PLANE_LEN; i++) {\n   \t\tISObj raycast = intersectPlane(planes[i], ray, i);\n        if(raycast.dist < nearestObj.dist) {\n            nearestObj = raycast;\n        }\n    }\n    for (int i = 0; i < SPHERE_LEN; i++) {\n   \t\tISObj raycast = intersectSphere(spheres[i], ray, i);\n        if(raycast.dist < nearestObj.dist) {\n            nearestObj = raycast;\n        }\n    }\n    return nearestObj;\n}\n\nPhongMat getMat(in ISObj hit) {\n     if (hit.type == OBJECT_TYPE_SPHERE) {\n   \t\treturn sphereMats[hit.id];\n    } else if (hit.type == OBJECT_TYPE_PLANE) {\n        return planeMats[hit.id];\n    }   \n    \n}\n\nvec3 phong(in ISObj hit, in PhongMat mat, in vec3 lightDir, in vec3 viewDir, in vec3 reflection) {\n    return mat.ambient * mat.diffuse\n        + mat.diffuse * max(0.0, dot(hit.normal, lightDir))\n        + mat.specular * pow(max(0.0, dot(reflection, viewDir)), mat.shininess);\n}\n\nvec3 globalIllumination(in Ray ray, in ISObj hit, in PhongMat mat, out vec3 hitPos, out vec3 reflection) {\n    for (int i = 0; i < 1; i++) {\n        // Intersection pos\n        vec3 inPos = vec3(hit.dist * ray.dir + ray.origin);\n        vec3 toLight = pointLights[i].position - inPos;\n        vec3 lightDir = normalize(toLight);\n        \n        vec3 viewDir = normalize(ray.origin - inPos);\n        reflection = -reflect(viewDir, hit.normal);\n        hitPos = inPos + hit.normal * 1e-5;\n        \n        Ray shadowRay = Ray(hitPos, lightDir);\n        ISObj shadowHit = raycast(shadowRay);\n        \n        if(shadowHit.dist > length(toLight)) {\n        \treturn phong(hit, mat, lightDir, viewDir, -reflect(lightDir, hit.normal));\n        } else {\n        \treturn mat.diffuse * mat.ambient;   \n        }\n    }\n\n}\n\nvec4 trace(in Ray ray) {\n\n    vec3 accum = vec3(0.0, 0.0, 0.0);\n    vec3 mask = vec3(1.0, 1.0, 1.0);\n    \n    for (int i = 0; i < NB_STEPS; i++) {\n    \tISObj hit = raycast(ray); \n        \n    \tif (hit.type == OBJECT_TYPE_NONE) {\n    \t\treturn vec4(accum, 1.0);\n    \t} else {\n            \n            PhongMat mat = getMat(hit);\n            \n            vec3 reflection, hitPos;\n\t\t\tvec3 color = globalIllumination(ray, hit, mat, hitPos, reflection);\n            accum = accum + mask * color;\n            mask = mask * mat.reflexivity;\n            ray = Ray(hitPos, reflection);\n    \t}\n         \n    }\n    \n    return vec4(accum, 1.0);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Move Camera\n    EYE_POS = EYE_POS + vec3(3.0 * cos(iTime), 1.0 * sin(iTime), 0.0);\n    \n    // Setup Viewport\n    // Pixel coordinates mapped to [-aspectRatio, aspectRatio] x [-1, 1]\n    vec2 uv = 2.0 * fragCoord / iResolution.y - vec2(iResolution.x / iResolution.y, 1.0);\n\tRay ray = Ray(EYE_POS, normalize(vec3(uv.x * CAMERA.X + uv.y * CAMERA.Y + NEAR_DISTANCE * CAMERA.Z)));\n    fragColor = trace(ray);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define OBJECT_TYPE_NONE -1\n#define OBJECT_TYPE_PLANE 0\n#define OBJECT_TYPE_SPHERE 1\n\n#define FLOAT_MAX 1e+5\n\nstruct Frame {\n    vec3 X, Y, Z;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Sphere \n{\n\tvec3 center;\n\tfloat radius;\n};\n    \nstruct Plane {\n    vec3 normal;\n    float offset;\n};\n    \nstruct PointLight {\n\tvec3 position;\n    vec3 color;\n    float intensity;\n};\n    \n// Intersected Object\nstruct ISObj \n{\n\tfloat dist;\n\tint type;\n\tint id;\n    vec3 normal;\n};\n    \nstruct PhongMat {\n    vec3 diffuse;\n    float ambient;\n    vec3 specular;\n    float shininess;\n    float reflexivity;\n};\n    \nvec3 computeSphereNormal(in Sphere s, in Ray r, in float dist) {\n    return normalize((r.origin + r.dir * dist) - s.center);\n}\n    \nISObj intersectPlane(in Plane p, in Ray r, in int id) {\n    float t = - (p.offset + dot(r.origin, p.normal)) / dot(r.dir, p.normal);\n    \n    if (t > 0.0) {\n        return ISObj(t, OBJECT_TYPE_PLANE, id, p.normal);\n    } else {\n        return ISObj(FLOAT_MAX, OBJECT_TYPE_NONE, -1, vec3(0.0, 0.0, 0.0));\n    }\n\n}\n    \nISObj intersectSphere(in Sphere s, in Ray r, in int id) {\n    vec3 offset = (r.origin - s.center);\n\tfloat a = dot(r.dir, r.dir);\n    float b = 2.0 * dot(offset, r.dir);\n    float c = dot(offset, offset) - s.radius * s.radius;\n    \n    float det = sqrt(b*b - 4.0*a*c);\n    \n    if (det < 0.0) {\n        return ISObj(FLOAT_MAX, OBJECT_TYPE_NONE, -1, vec3(0.0, 0.0, 0.0));\n    } else {\n        float t = min(- b - det, - b + det) / (2.0 * a);\n        if (t > 0.0) {\n        \treturn ISObj(t, OBJECT_TYPE_SPHERE, id, computeSphereNormal(s, r, t));  \n        } else {\n            return ISObj(FLOAT_MAX, OBJECT_TYPE_NONE, -1, vec3(0.0, 0.0, 0.0));        \n        }\n\n    }\n\n}","name":"Common","description":"","type":"common"}]}