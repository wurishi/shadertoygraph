{"ver":"0.1","info":{"id":"3lVyRd","date":"1611601392","viewed":69,"name":"Bad Perlin Noise - Andrew","username":"andrew741","description":"A blocky version of perlin noise. Used three different layers of it for the rgb values. Each of the layers is a layer of fractal noise (noise in a fractal pattern made with layers of perlin noise with decreasing scale and amplitude)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["perlinnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nBest when vewing in full screen\n\n*/\n\nfloat seed = 2.;  // the seed for the perlin noise\n\n// changes the range of a number\nfloat map(float val, float cMin, float cMax, float nMin, float nMax)\n{\n    float nVal = val - cMin;\n    nVal *= (nMax - nMin) / (cMax - cMin);\n    nVal += nMin;\n    return nVal;\n}\n\n// a persuado random number generator (not my own generator)\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(round(co.xy) ,vec2(12.,78.))) * 43758.);\n}\n\n// a random range number generator\nfloat randRange(vec2 co, float Min, float Max)\n{\n    return map(rand(co), 0., 1., Min, Max);\n}\n\n// a working smoothstep\nfloat Smoothstep(float x)\n{\n    float k = clamp(x, 0., 1.);\n    return k*k*(3. - 2. * k);\n}\n\n// a 2D perlin noise\nfloat perlin2D(float scale, vec2 p)\n{\n    vec2 np = p / scale;\n    vec2 offset = fract(np);\n    \n    float lu = randRange(vec2(floor(np.x), ceil(np.y)), 0., 1.);\n    float ru = randRange(vec2(ceil (np.x), ceil(np.y)), 0., 1.);\n    float ld = randRange(vec2(floor(np.x), floor (np.y)), 0., 1.);\n    float rd = randRange(vec2(ceil (np.x), floor (np.y)), 0., 1.);\n    \n    return mix(mix(ld, lu, Smoothstep(offset.y)), mix(rd, ru, Smoothstep(offset.y)), Smoothstep(offset.x));\n}\n\n// main loop\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // non-streched uv coordinates\n    vec2 uv = fragCoord/iResolution.y * 2. - 1.;\n\n    // sample position for perlin noise\n    vec2 p = fragCoord + seed * 100000. + round(vec2(iTime * 450., -iTime * 150. + sin(iTime) * 400.) + iMouse.xy);\n    \n    // the r layer of fractal noise (stacked layers of decreasing amplitude and scale perlin noise)\n    float noise1 = 0.;\n    noise1 += perlin2D(200., p         )     ;\n    noise1 += perlin2D(100., p + 500.  ) / 2.;\n    noise1 += perlin2D(50. , p + 1000. ) / 4.;\n    noise1 = map(noise1, 0., 1.75, 0., 1.);\n    \n    // the g layer of fractal noise\n    float noise2 = 0.;\n    noise2 += perlin2D(200., p + 1500. )     ;\n    noise2 += perlin2D(100., p + 2000. ) / 2.;\n    noise2 += perlin2D(50. , p + 2500. ) / 4.;\n    noise2 = map(noise2, 0., 1.75, 0., 1.);\n    \n    // the b layer of fractal noise\n    float noise3 = 0.;\n    noise3 += perlin2D(200., p + 3000. )     ;\n    noise3 += perlin2D(100., p + 3500. ) / 2.;\n    noise3 += perlin2D(50. , p + 4000. ) / 4.;\n    noise3 = map(noise3, 0., 1.75, 0., 1.);\n    \n    // combining the three (rgb) layers of noise\n    vec3 col = vec3(noise1, noise2, noise3);\n\n    // outputing the final color\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}