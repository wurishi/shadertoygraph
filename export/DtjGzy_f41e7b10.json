{"ver":"0.1","info":{"id":"DtjGzy","date":"1685183643","viewed":98,"name":"Very Simple Desert","username":"Fuergu","description":"2156489","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["desert2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const mat2 m1 = mat2(1.6,-1.2,\n                     1.2, 1.6);\nfloat cosNoise( in vec2 p )\n{\n    return 0.4*( sin(p.x) + sin(p.y) );\n}\nfloat terrain2( in vec3 pos )\n{\n    float h = 0.0;\n    vec2 q = pos.xz*0.5;\n    \n    float s = 0.5;\n    for( int i=0; i<6; i++ )\n    {\n        h += s*cosNoise( q ); \n        q = m1*q*0.9; \n        q += vec2(2., 5.);\n        s *= 0.45 + 0.2*h;\n    }\n    h *= 2.0;\n    return pos.y - h;\n}\n//******************************************\nvec2 hash( vec2 p ) \n{\n    const vec2 k = vec2( 0.083099, 0.0678794 );\n    float n = 111.0*p.x + 113.0*p.y;\n    return fract(n*fract(k*n));\n}\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n#define SC (250.0)\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\nfloat terrain( in vec2 x )\n{\n    vec3 noise=noised(x);\n    vec3 moise1=vec3(0.);\n    vec2 d=vec2(0.);\n    vec2 d2=noise.yz;\n    float a=noise.x;\n\tfor(int i=1;i<3;i++)\n    {\n     \n     vec3 noise1=noised(noise.yz);\n     noise=noise1*0.25;\n     d = noise1.yz;\n     d =m2*d;\n     d2+=d;\n     //a+=d2.x;\n     a += noise.x/(1.0+dot(d2,d2));\n    }\n    return a;\n}\nfloat map(in vec3 pos)\n{\n    //float sphere=length(pos)-.25;//length(a point in space from a sphere)\n    float ground=pos.y-(-0.25)-terrain(pos.xz);//generate a plane\n    return ground;//min(sphere,ground);//make sure always see the closer thing\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 p) {\n    const float h = 0.0001;\n    const vec2 k = vec2(1, -1);\n    return normalize(k.xyy * map(p + k.xyy * h) +\n        k.yyx * map(p + k.yyx * h) +\n        k.yxy * map(p + k.yxy * h) +\n        k.xxx * map(p + k.xxx * h));\n}\nfloat castRay(in vec3 ro,vec3 rd)\n{\n    float t=0.;\n    for(int i0=0;i0<101;i0++)\n    {\n        vec3 pos= ro+t*rd;\n        \n        float h=map(pos);\n        if(h<0.001)  break;//if h is negative, light is outside the sphere\n        t+=h;\n        if(t>20.)    break;//distance is too large,dismiss\n    }\n    if(t>20.) t= -1.0;\n    return t;\n}\n\nvec3 fog( in vec3 col, float t )\n{\n    vec3 ext = exp2(-t*0.0075*vec3(1,1.5,4)); \n    return col*ext + (1.0-ext)*vec3(0.55,0.55,0.58); // 0.55\n}\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        /**********************************************\n          Normalized pixel coordinates (from 0 to 1)\n        **********************************************/\n    vec2 p=(2. * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    float zoom=2.;\n    float an=10.*iMouse.x/iResolution.x;\n    \n    vec3 ro=vec3(1.*sin(an),0.2,1.*cos(an));\n    \n    float idle = float(iMouse.z<0.||iMouse.x<0.001)*0.1;\n    if(idle>0.)\n    {\n    ro=vec3(sin(iTime/2.)+iTime,0.3+0.1*sin(iTime*2.),cos(iTime/2.)+iTime);\n    }\n    \n            /********set up camera system********/\n            vec3 ta=vec3(0.,.1,0.);//camera target direction vector\n            vec3 f = normalize(ta-ro);\n            vec3 r = normalize(cross(f,vec3(0., 1., 0.)));\n            vec3 u = normalize(cross(r,f));\n            \n    vec3 rd=normalize(p.x*r+p.y*u+zoom*f);\n    \n    vec3 origin_sky_color=vec3(.4,.75,1.);\n    vec3 horizon_color=vec3(.7,.75,.8);\n    origin_sky_color -= 0.5*rd.y;//make the sky upwards darker,create variation\n    vec3 col=origin_sky_color;\n    col=mix(col,horizon_color,exp(-10.*rd.y));//add horizon\n    \n    float t = castRay(ro,rd);\n    if(t>0.) \n    {\n        vec3 pos= ro+t*rd;\n        vec3 nor=calcNormal(pos);\n        //col=nor;      //dispaly normal\n        //col=nor.zzz;  //dispaly normal\n        \n        \n        vec3 mate=vec3(.17647054,.113725,.0431372);    //mate is material\n        vec3 sun_dir=normalize(vec3(.8,.4,.2));\n        float sun_diff=clamp( dot(nor,sun_dir), 0., 1.);//sun_dir is the direction of the sun\n        float sun_sha = step(castRay(pos+nor*0.001, sun_dir),0.);//step is kinda conpare the first component and the second one 0..//if larger than 0,return 1;else return 0.\n        vec3 sky_dir=normalize(vec3(0.,1.,0.));\n        float sky_diff=clamp(0.5+0.5*dot(nor,sky_dir), 0., 1.);//enhance skylight\n        float bou_diff = clamp(0.5+0.5*dot(nor,vec3(sky_dir.x,-sky_dir.y,sky_dir.z)), 0., 1.);//bounce light from the ground\n        col=vec3(7.,6.,4.)*sun_diff*sun_sha; \n        col+=vec3(.5,.8,.9)*sky_diff; \n        col+=vec3(.8,.6,.5)*bou_diff; \n        \n        \n        \n        \n        col*=mate;\n        col = fog( col, 25.);\n    }    \n        \n\n    \n    \n    //col= pow(col,vec3(0.6556));    //gamma correction\n        // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}