{"ver":"0.1","info":{"id":"tljXDd","date":"1567576396","viewed":285,"name":"EggLikeMen","username":"Fogrex","description":"Many EggLikeMen","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define PI 3.14159265\n#define PI2 6.28318531\n#define saturate(a) clamp(a, 0.0, 1.0)\n\nconst vec3 LIGHT_DIR = normalize(vec3(1.0,-1.0,1.0));\nconst int STEP = 64;\n\n\nstruct Field\n{\n    float dist;\n    vec4 color;\n    float metallic;\n    float lim;\n    float specular;\n};\n\nstruct Intersection\n{\n    vec3 pos;\n    vec3 normal;\n    Field field;\n};\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n    vec4 color;\n    bool isReflect;\n    vec4 rayColor;\n    float intensity;\n};\n\n\nField initField()\n{\n    Field f;\n    f.dist = 99999.0;\n    f.color = vec4(1.0,1.0,1.0,1.0);\n    f.metallic = 0.0;\n    f.lim = 0.0;\n    f.specular = 1.0;\n    return f;\n}\n\nField mixField(in Field f2, in Field f1, in float h)\n{\n    Field f;\n    f.color = mix(f2.color, f1.color, h);\n    f.metallic = mix(f2.metallic, f1.metallic, h);\n    f.lim = mix(f2.lim, f1.lim, h);\n    f.specular = mix(f2.specular, f1.specular, h);\n    return f;\n}\n    \n// transform functions\n\nmat4 transform(vec3 move, vec3 rot)\n{\n    mat4 m = mat4(\n        1.0,    0.0,    0.0,    0.0,\n        0.0,    1.0,    0.0,    0.0,\n        0.0,    0.0,    1.0,    0.0,\n        -move.x,    -move.y,    -move.z,    1.0\n    );\n    mat4 rx = mat4(\n        1.0,    0.0,        0.0,            0.0,\n        0.0,    cos(-rot.x), sin(-rot.x),    0.0,\n        0.0,    -sin(-rot.x), cos(-rot.x),     0.0,\n        0.0,    0.0,        0.0,            1.0\n    );\n    mat4 ry = mat4(\n        cos(-rot.y),     0.0,    -sin(-rot.y), 0.0,\n        0.0,            1.0,    0.0,        0.0,\n        sin(-rot.y),    0.0,    cos(-rot.y), 0.0,\n        0.0,            0.0,    0.0,        1.0\n    );\n    mat4 rz = mat4(\n        cos(-rot.z), sin(-rot.z),    0.0,    0.0,\n        -sin(-rot.z), cos(-rot.z),     0.0,    0.0,\n        0.0,        0.0,            1.0,    0.0,\n        0.0,        0.0,            0.0,    1.0\n    );\n\n    return (ry * rx * rz * m);\n}\n\nmat4 translate(vec3 move)\n{\n    mat4 m = mat4(\n        1.0,    0.0,    0.0,    0.0,\n        0.0,    1.0,    0.0,    0.0,\n        0.0,    0.0,    1.0,    0.0,\n        -move.x,    -move.y,    -move.z,    1.0\n    );\n   \n    return (m);\n}\n\nmat4 rotate(vec3 rot)\n{\n    mat4 rx = mat4(\n        1.0,    0.0,        0.0,            0.0,\n        0.0,    cos(-rot.x), sin(-rot.x),    0.0,\n        0.0,    -sin(-rot.x), cos(-rot.x),     0.0,\n        0.0,    0.0,        0.0,            1.0\n    );\n    mat4 ry = mat4(\n        cos(-rot.y),     0.0,    -sin(-rot.y), 0.0,\n        0.0,            1.0,    0.0,        0.0,\n        sin(-rot.y),    0.0,    cos(-rot.y), 0.0,\n        0.0,            0.0,    0.0,        1.0\n    );\n    mat4 rz = mat4(\n        cos(-rot.z), sin(-rot.z),    0.0,    0.0,\n        -sin(-rot.z), cos(-rot.z),     0.0,    0.0,\n        0.0,        0.0,            1.0,    0.0,\n        0.0,        0.0,            0.0,    1.0\n    );\n\n    return (ry * rx * rz);\n}\n\nmat3 camera(vec3 pos, vec3 tar)\n{\n    vec3 cw = normalize(tar - pos);\n    vec3 cp = vec3(0.0, 1.0, 0.0);\n    vec3 cu = cross(cw, cp);\n    vec3 cv = cross(cu, cw);\n    return mat3(cu, cv, cw);\n}\n\n\n// distance function\n\nField sdSphere(in vec4 pos, in float r)\n{\n    Field f = initField();\n    f.dist = length(pos.xyz) - r;\n    return f;\n}\n\nField sdBox(in vec4 pos, in vec3 size)\n{\n    vec3 d = abs(pos.xyz) - size;\n    Field f = initField();\n    f.dist = length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0);\n    return f;\n}\n\nField sdCylinder(in vec4 pos, in float r)\n{\n    Field f = initField();\n    f.dist = length(pos.xz) -r;\n    return f;\n}\n\nField sdPlane(in vec4 pos, in float h)\n{\n    Field f = initField();\n    f.dist = pos.y - h;\n    return f;\n}\n\nField sdCappedTorus(in vec4 pos, in float theta, in float ra, in float rb)\n{\n    vec2 sc = vec2(sin(theta), cos(theta));\n    pos.x = abs(pos.x);\n    float k = (sc.y*pos.x>sc.x*pos.y) ? dot(pos.xy,sc) : length(pos.xy);\n    Field f = initField();\n    f.dist = sqrt( dot(pos.xyz,pos.xyz) + ra*ra - 2.0*ra*k ) - rb;\n    return f;\n}\n\n// Shape Adding\n\nField nsUnion(in Field f1, in Field f2)\n{\n    if(f1.dist < f2.dist) return f1;\n    return f2;\n}\n\nField nsSubtraction(Field f1, Field f2)\n{\n    if(-f1.dist < f2.dist) return f2;\n    f1.dist *= -1.0;\n    return f1;\n}\nField nsIntersection(Field f1, Field f2)\n{\n    if(f1.dist < f2.dist) return f2;\n    return f1;\n}\n\nField sUnion(Field f1, Field f2, float k, in bool flag)\n{\n    float h = clamp(0.5 + 0.5*(f2.dist-f1.dist)/k, 0.0, 1.0);\n    Field f;\n    if(!flag) f = mixField(f2, f1, h);\n    f.dist = mix(f2.dist, f1.dist, h) - k*h*(1.0-h);\n    return f;\n}\n\nField sSubtraction(Field f1, Field f2, float k, in bool flag)\n{\n    float h = clamp(0.5 - 0.5*(f2.dist+f1.dist)/k, 0.0, 1.0);\n    Field f;\n    if(!flag) f = mixField(f2, f1, h);\n    f.dist = mix(f2.dist, -f1.dist, h) + k*h*(1.0-h);\n    return f;\n}\nField sIntersection(Field f1, Field f2, float k, in bool flag)\n{\n    float h = clamp(0.5 - 0.5*(f2.dist-f1.dist)/k, 0.0, 1.0);\n    Field f;\n    if(!flag) f = mixField(f2, f1, h);\n    f.dist = mix(f2.dist, f1.dist, h) + k*h*(1.0-h);\n    return f;\n}\n\n\n\n// mapping\nField map(in vec3 pos, in bool isDist)\n{\n    \n    vec3 m = vec3(4.0,0.0,4.0);\n    vec4 p = vec4(mod(pos, m)-m/2.0, 1.0);\n    // Floor\n    vec4 col = texture(iChannel1, pos.xz*0.1);\n    vec4 fp = p;\n    fp.y -= col.x*0.3;\n   \tField flo = sdPlane(fp, -2.0);\n    flo.metallic = 0.0;\n    flo.color = vec4(col.x);\n    \n    \n    vec4 pa = vec4(-abs(p.x),p.y,p.z,p.w);\n    \n    \n    // Body\n    Field b1 = sdSphere(translate(vec3(0.0,1.0,0.0))*pa, 0.5);\n    Field b2 = sdSphere(pa,1.2);\n    mat4 trans = translate(vec3(-0.5,0.9,-0.7));\n    Field eyelids = sdSphere(trans*pa, 0.15);\n    trans = transform(vec3(0.0,1.3,-1.1), vec3(0.0,0.0,PI));\n    Field mouth = sdCappedTorus(trans*pa,PI/10.0, 1.0, 0.1 );\n    mouth.color = vec4(1.0,0.5,0.8,1.0);\n    Field body = sUnion(b1,b2,1.0,isDist);\n    body = sUnion(body, eyelids, 0.4, isDist);\n    body.color = vec4(1.0,0.0,0.0,1.0);\n    body.specular = 0.0;\n    body = sSubtraction(mouth, body, 0.1, isDist);\n    \n    // Eyes\n    \n    trans = translate(vec3(-0.4,0.8,-0.9));\n    Field whiteeye = sdSphere(trans*pa, 0.2);\n    trans = trans * translate(vec3(0.0,0.03,-0.09));\n    Field blackeye = sdSphere(trans*pa, 0.14);\n    blackeye.color = vec4(vec3(0.0),1.0);\n    Field eyes = nsUnion(whiteeye,blackeye);\n    \n    \n    // Arms\n    float theta = PI / 3.0;\n    float r = 0.7;\n    trans = transform(vec3(-1.0,0.0,-0.2), vec3(0.0,0.0,theta));\n    mat4 mv = translate(vec3(sin(-theta)*r, cos(-theta)*r,0.0));\n    Field arm = sdCappedTorus(trans*pa,theta, r, 0.1 );\n    Field hand = sdSphere(mv*trans*pa, 0.2);\n    Field arms = nsUnion(arm,hand);\n    arms.specular = 0.0;\n    \n    // Feet\n    trans = translate(vec3(-0.4,-1.3,0.0));\n    Field thigh = sdCylinder(trans*pa, 0.15);\n    Field intersect = sdSphere(trans*pa, 0.4);\n    trans = translate(vec3(-0.4,-1.6,-0.2));\n    Field foot = sdSphere(trans*pa, 0.2);\n    Field feet = nsIntersection(thigh, intersect);\n    feet = sUnion(feet, foot,0.2,isDist);\n    feet.specular = 0.0;\n    \n    Field res;\n    res = nsUnion(flo, body);\n    res = nsUnion(res, eyes);\n    res = nsUnion(res, arms);\n    res = nsUnion(res, feet);\n    res.lim = 0.7;  \n    return res;\n}\n\nfloat distMap(in vec3 pos)\n{\n    return map(pos, true).dist;\n}\nField colorMap(in vec3 pos)\n{\n    return map(pos, false);\n}\n\n// CalcNorm\nvec3 calcNorm(in vec3 pos)\n{\n    vec2 d = vec2(0.0, 0.0001);\n    return normalize(vec3(\n        distMap(pos + d.yxx) - distMap(pos - d.yxx),\n        distMap(pos + d.xyx) - distMap(pos - d.xyx),\n        distMap(pos + d.xxy) - distMap(pos - d.xxy)\n    ) / d.y);\n}\n\nIntersection initIntersection(in vec3 pos, in Field f)\n{\n    Intersection its;\n    its.pos = pos;\n    its.normal = calcNorm(pos);\n    its.field = f;\n    return its;\n}\n\nRay initRay(vec2 uv, vec3 pos, vec3 tar, float fl)\n{\n    Ray r;\n    r.origin = pos;\n    mat3 c = camera(pos, tar);\n\tvec3 rd = vec3(uv, fl)*0.01;\n    r.direction = normalize(c * vec3(rd.xy, sqrt(max(rd.z * rd.z - dot(rd.xy, rd.xy) * 0.2, 0.0))));\n    r.color = vec4(0.0);\n    r.rayColor = vec4(1.0);\n    r.isReflect = true;\n    r.intensity = 1.0;\n    return r;\n}\n\nfloat limLighting(in Ray ray, in Intersection its)  \n{\n    return pow(1.0 - saturate(dot(-ray.direction, its.normal)),2.0);\n}\n\nvec4 lambert(in Ray ray, in Intersection its)\n{\n    vec3 n = its.normal;\n    float diff = max(0.0, dot(n, -LIGHT_DIR));\n    float base = 0.2;\n    return saturate(ray.rayColor * its.field.color * mix(diff, 1.0, base));\n}\n\nvoid lighting(inout Ray ray, in Intersection its)\n{\n    Field f = its.field;\n    float lim = f.lim * limLighting(ray, its);\n    float spec = pow(max(dot(ray.direction, reflect(-LIGHT_DIR, its.normal)), 0.0), 32.0);\n    vec4 col = mix(saturate(lambert(ray,its) + vec4(1.0) * spec * f.specular), vec4(1.0), lim) ;\n    float h = max((1.0 - f.metallic), max(lim, spec));\n    ray.color += col * ray.intensity * h;\n    ray.rayColor *= f.color;\n    ray.intensity -= ray.intensity * h;\n    ray.isReflect = !(ray.intensity==0.0);\n    if(ray.isReflect)\n    {\n    \tray.direction = reflect(ray.direction, its.normal);\n    \tray.origin = its.pos + ray.direction * 0.001;\n    }else ray.origin = its.pos;\n}\n\nvoid raymarch(inout Ray ray)\n{\n    vec3 pos = ray.origin;\n    vec3 dir = ray.direction;\n    \n    float d;\n    for(int i=0;i<STEP;i++)\n    {\n        d = distMap(pos);\n        if(d < 0.0001)\n        {\n            lighting(ray, initIntersection(pos, colorMap(pos)));\n            return;\n        }\n        pos += dir * d;\n    }\n    ray.isReflect = false;\n    return;\n}\n\n\nvoid castPoorShadow(inout Ray ray)\n{\n    \n    vec3 dir = -LIGHT_DIR;\n    vec3 pos = ray.origin + dir*0.01;\n    \n    float d;\n    for(int i=0;i<STEP;i++)\n    {\n        d = distMap(pos);\n        if(d < 0.0001)\n        {\n      \t\tray.color = vec4(0.0,0.0,0.0,1.0);\n            ray.intensity = 0.0;\n            return;\n        }\n        pos += dir * d;\n    }\n    return;\n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec3 pos = vec3(0.0,2.0,10.0);\n    pos = (rotate(vec3(0.0,iTime*0.5,0.0))*vec4(pos, 1.0)).xyz;\n    \n    Ray r = initRay(uv,pos,vec3(0.0,0.0,0.0), 0.9);\n    \n    for(int i=0;i<2;i++)\n    {\n        raymarch(r);\n        if(!r.isReflect) break;\n    }\n    castPoorShadow(r);\n\tvec4 col = r.rayColor * texture(iChannel0, r.direction);\n    fragColor = r.color + r.intensity * mix(col, vec4(1.0), pow(saturate(dot(r.direction, -LIGHT_DIR)), 32.0));\n}","name":"Image","description":"","type":"image"}]}