{"ver":"0.1","info":{"id":"M3fBWS","date":"1728829390","viewed":30,"name":"Rendu_TP_Info_Graphique","username":"abdouxmata","description":"TP Informatique graphique","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["tp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray{\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\nstruct Val {\n  float v; // Signed distance\n  int c; // Cost\n};\n\n\n\n/*\nstruct Val {\n    float v;      // Signed distance\n    int c;        // Cost\n    float metallic; // How metallic/reflective the material is (0 = mat, 1 = fully reflective)\n};\n*/\n\n\n// Compute point on ray\n// ray : The ray\n//   t : Distance\nvec3 Point(Ray ray,float t)\n{\n    return ray.o+t*ray.d;\n}\n\n// Random direction in a hemisphere\n// seed : Integer seed, from 0 to N\n//    n : Direction of the hemisphere\nvec3 Hemisphere(int seed,vec3 n)\n{\n    float a=fract(sin(176.19*float(seed)));// Uniform randoms\n    float b=fract(sin(164.19*float(seed)));\n   \n    float u=2.*3.1415*a;// Random angle\n    float v=acos(2.*b-1.);// Arccosine distribution to compensate at poles\n   \n    vec3 d=vec3(cos(u)*cos(v),sin(u)*cos(v),sin(v));// Direction\n    if(dot(d,n)<0.){d=-d;}// Hemisphere\n   \n    return d;\n}\n\n\n\n\n// Camera -------------------------------------------------------------------------------\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 Rz(float a)\n{\n  float sa=sin(a);float ca=cos(a);\n  return mat3(ca,sa,0.,-sa,ca,0.,0.,0.,1.);\n}\n\n\n\n// Rotation matrix around y axis\n// a : Angle\nmat3 Ry(float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return mat3(ca, 0.0, -sa,\n                 0.0, 1.0, 0.0,\n                 sa, 0.0, ca);\n}\n\n\n// Rotation matrix around x axis\n// a : Angle\nmat3 Rx(float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return mat3(1.0, 0.0, 0.0,\n                 0.0, ca, sa,\n                 0.0, -sa, ca);\n}\n\n\n\n\n// Compute the ray\n//      m : Mouse position\n//      p : Pixel\nRay CreateRay(vec2 m,vec2 p)\n{\n  float a=3.*3.14*m.x;\n  float b = 1. * 3.14 * m.y; // Rotation around Y\n      float c = 0.3 * 3.14 * m.y; // Rotation around X\n  float le=3.5;\n \n  // Origin\n  vec3 ro=vec3(37.,0.,15.);\n  ro*=Rz(a);\n  //ro *= Ry(b);\n  //ro *= Rx(c);\n  // Target point\n  vec3 ta=vec3(0.,0.,1.);\n \n  // Orthonormal frame\n  vec3 w=normalize(ta-ro);\n  vec3 u=normalize(cross(w,vec3(0.,0.,1.)));\n  vec3 v=normalize(cross(u,w));\n  vec3 rd=normalize(p.x*u+p.y*v+le*w);\n  return Ray(ro,rd);\n}\n\n\n\n\n\n\n\n\n\n//Rotation--------------------------------------------------------------\n// Fonction de rotation d'un point autour de l'axe X\nvec3 RotateX(vec3 p, float angle) {\n    float sa = sin(angle);\n    float ca = cos(angle);\n    return vec3(p.x, ca * p.y - sa * p.z, sa * p.y + ca * p.z);\n}\n\n// Fonction de rotation d'un point autour de l'axe Y\nvec3 RotateY(vec3 p, float angle) {\n    float sa = sin(angle);\n    float ca = cos(angle);\n    return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\n\n// Fonction de rotation d'un point autour de l'axe Z\nvec3 RotateZ(vec3 p, float angle) {\n    float sa = sin(angle);\n    float ca = cos(angle);\n    return vec3(ca * p.x - sa * p.y, sa * p.x + ca * p.y, p.z);\n}\n\n// Fonction de rotation combinée\nvec3 Rotate(vec3 p, vec3 angles) {\n    p = RotateX(p, angles.x);\n    p = RotateY(p, angles.y);\n    p = RotateZ(p, angles.z);\n    return p;\n}\n\n\n\n\n//translation\n\nvec3 Translate(vec3 p, vec3 translation) {\n    return p + translation; // Ajouter le vecteur de translation à la position\n}\n\n\n\n// Primitives -------------------------------------------------------------------------------\n\n\n\n\n\n\n// Modification de fonction primitive (matériau réfléchissant) \n\n/*\nVal Sphere(vec3 p, vec3 c, float r, float metallic) {\n    return Val(length(p-c)-r, 1, metallic);\n}\n*/\n\n\n\n// Sphere\n// p : point\n// c : center of skeleton\n// r : radius\nVal Sphere(vec3 p,vec3 c,float r)\n{\n  return Val(length(p-c)-r,1);\n}\n\n\n\n\n\n// Ellipsoid SDF\n// p: point in space\n// c: center of the ellipsoid\n// r: radii for the x, y, and z axes\nVal Ellipsoid(vec3 p, vec3 c, vec3 r)\n{\n  vec3 q = (p - c) / r;  // Scale the space by the radii\n  return Val(length(q) - 1.0, 1);  // Normalized ellipsoid\n}\n\n\n\n// Box SDF\n// p: point in space\n// c: center of the box\n// b: half-dimensions of the box (extents in each direction from the center)\nVal Box(vec3 p, vec3 c, vec3 b) {\n\n\n   \n\n    p = Rotate(p - c, vec3(45,0,0)) + c;\n    vec3 d = abs(p - c) - b;  // Calculate distance to each side of the box\n    float outsideDist = length(max(d, 0.0)); // Distance outside the box\n    float insideDist = min(max(d.x, max(d.y, d.z)), 0.0); // Distance inside the box\n    return Val(outsideDist + insideDist, 1);  // Combine inside and outside distances\n}\n\n\n\n\n// Fonction de translation dynamique d'une boîte\nVal TranslateBoxDynamic(vec3 p, float time, vec3 c, vec3 b) {\n\n    // Appliquer une translation basée sur le temps\n    // (ou une entrée contrôlée par l'utilisateur, comme la position de la souris)\n   \n   \n   vec3 translation = vec3(sin(time*2.0+5.0),1, 0.0); // Mouvement circulaire en X et Y\n   \n        //vec3 translation = vec3(sin(time), 0.0, 0.0); // Mouvement sinusoïdal uniquement en X\n   \n    // Appliquer la translation au centre de la boîte\n    vec3 translatedCenter = c + translation;\n   \n    // Calculer la distance entre le point p et le centre traduit\n    p = p - translatedCenter; // Déplacer le point p en fonction de la translation\n    vec3 d = abs(p) - b;  // Calculer la distance à chaque côté de la boîte\n   \n    float outsideDist = length(max(d, 0.0)); // Distance en dehors de la boîte\n    float insideDist = min(max(d.x, max(d.y, d.z)), 0.0); // Distance à l'intérieur de la boîte\n   \n    return Val(outsideDist + insideDist, 1);  // Combiner les distances internes et externes\n}\n\n\n\n\nVal BoxRotating(vec3 p, vec3 c, vec3 b , float time) {\n\n // Animation de rotation\n    vec3 angles = vec3(0.0, radians(45.0 * time), radians(45.0 * time));  // Rotate on Y and Z based on time\n\np = Rotate(p - c, angles) + c;\n   \n\n    p = Rotate(p - c, vec3(45,0,0)) + c;\n    vec3 d = abs(p - c) - b;  // Calculate distance to each side of the box\n    float outsideDist = length(max(d, 0.0)); // Distance outside the box\n    float insideDist = min(max(d.x, max(d.y, d.z)), 0.0); // Distance inside the box\n    return Val(outsideDist + insideDist, 1);  // Combine inside and outside distances\n}\n\n\n\n\n// Cylinder SDF\n// p: point dans l'espace\n// c: centre du cylindre\n// r: rayon du cylindre\n// h: hauteur du cylindre\nVal Cylinder(vec3 p, vec3 c, float r, float h) {\n    // Calculer la distance pour la base du cylindre\n    float d = max(length(p.xz - c.xz) - r, p.y - h * 0.5);\n    // Si la base est en dessous, retourner la distance par rapport à la base\n    d = max(d, -p.y - h * 0.5);\n    return Val(d, 1);\n}\n\n\n\n// Capsule SDF\n// p: point in space\n// a, b: centers of the capsule's ends\n// r: radius of the capsule\nVal Capsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    vec3 closestPoint = a + h * ba;  // Closest point on the line segment\n    return Val(length(p - closestPoint) - r, 1);\n}\n\n\n\n// Torus SDF\n// p: point in space\n// c: center of the torus\n// t: vec2 containing the radii (t.x = major radius, t.y = minor radius)\nVal Torus(vec3 p, vec3 c, vec2 t)\n{\n    vec3 q = p - c;\n    vec2 temp = vec2(length(vec2(q.x, q.z)) - t.x, q.y); // Project on xz plane\n    return Val(length(temp) - t.y, 1);\n}\n\n\n\n// Plane\n// p : point\n// n : Normal of plane\n// o : Point on plane\nVal Plane(vec3 p, vec3 n, vec3 o)\n{\n    return Val(dot((p-o),n),1);\n}\n\n// Operators\n\n/*\n// Modified Union operator to handle materials\nVal Union(Val a, Val b) {\n    if(a.v < b.v) {\n        return Val(a.v, a.c + b.c + 1, a.metallic);\n    }\n    return Val(b.v, a.c + b.c + 1, b.metallic);\n}\n*/\n\n\n// Union\n// a,b : field function of left and right sub-trees\nVal Union(Val a,Val b)\n{\n  return Val(min(a.v,b.v),a.c+b.c+1);\n}\n\n\n// Intersection : conserve seulement la partie commune entre les deux objets\nVal Intersection(Val a, Val b) {\n    return Val(max(a.v, b.v), a.c + b.c + 1);\n}\n\n// Différence : soustrait l'objet b de l'objet a\nVal Difference(Val a, Val b) {\n    return Val(max(a.v, -b.v), a.c + b.c + 1);\n}\n\n\n//Objets Complexes Croissant -------------------------------------------------\n\n// Fonction pour créer un croissant\nVal Croissant(vec3 p) {\n    // Grand tore pour la base du croissant\n    Val largeTorus = Torus(p, vec3(0., 0., 0.), vec2(3.0, 1.0));  // Grand rayon 3, petit rayon 1\n\n    // Utilisation d'une sphère pour découper une partie du tore\n    Val cuttingSphere = Sphere(p, vec3(1.55, 0., 0.), 2.5);  // Sphère de découpe\n\n    // Différence pour créer la forme en croissant\n    Val croissant = Difference(largeTorus, cuttingSphere);\n\n    return croissant;\n}\n\n\n\n//Deformation ----------------------------------------------------------\n\n//fonction de bruit simple\nfloat Noise(vec3 p) {\n    // Implémentez votre propre fonction de bruit ici ou utilisez une bibliothèque\n    return sin(p.x * 10.0) * sin(p.y * 10.0) * sin(p.z * 10.0);\n}\n\n// Fonction de déformation pour ajouter des bosses ou des creux\nVal DeformedObject(Val v, vec3 p, float scale) {\n    float deformation = Noise(p * scale) * 0.5;\n    return Val(v.v + deformation, v.c);\n}\n\n\n\nVal SphereWithDeformation(vec3 p, vec3 center, float radius, float scale) {\n    Val sphere = Sphere(p, center, radius);\n    return DeformedObject(sphere, p, scale);\n}\n\n\n\nVal CrescentWithDeformation(vec3 p, float scale) {\n    Val largeTorus = Torus(p, vec3(0., 0., 0.), vec2(3.0, 1.0));\n    Val cuttingSphere = Sphere(p, vec3(1.55, 0., 0.), 2.5);\n    Val croissant = Difference(largeTorus, cuttingSphere);\n    return DeformedObject(croissant, p, scale);\n}\n\n\n\n\nVal EllipsoidWithDeformation(vec3 p, vec3 center, vec3 radius, float scale) {\n    Val ellipsoid = Ellipsoid(p, center, radius);\n    return DeformedObject(ellipsoid, p, scale);\n}\n\n\n\n\n\nVal cochon(vec3 p) {\n    // Sphère\n    Val face = Sphere(p, vec3(0., 2., 0.), 2.5); // Sphère centrée à (0, 2, 0) avec un rayon de 2.5\n\n    Val cuttingBox = Box(p, vec3(0., 2., 0.), vec3(1.5, 0.5, 1.5)); // Petite boîte au centre de la sphère\n   \n    // Cylindre à ajouter au-dessus de la sphère\n    Val cylinder = Cylinder(p, vec3(0., 5., 0.), 1.0, 3.0); // Cylindre au-dessus de la sphère\n        Val eye1 = Cylinder(p, vec3(1., 5., 1.5), 0.5, 1.0); // Cylindre au-dessus de la sphère\n        Val eye2 = Cylinder(p, vec3(-1., 9., 1.5), 0.5, 1.0); // Cylindre au-dessus de la sphère\n\n    Val cochon = Union(face, cylinder);\n   \n    cochon  = Union(cochon,eye1);\n    cochon  = Union(cochon,eye2);\n\n    cochon = Difference(cochon, cuttingBox);\n\n    Val ears = Capsule(p, vec3(-3., 2., 1.), vec3(3., 2., 1.), 0.7); // Capsule horizontale\n\n    cochon = Union(cochon, ears);\n\n    return cochon;\n}\n\n\n\n// Function to calculate reflection\n/*\nvec3 reflect(vec3 I, vec3 N) {\n    return I - 2.0 * dot(N, I) * N;\n}\n*/\n\n\n// Potential field of the object\n// p : point\nVal object(vec3 p)\n{\n  //Val v=Union(\n //   Sphere(p,vec3(0.,2.,2.),2.25),\n \n   // Sphere(p,vec3(3.,0.,-1.),3.));\n     \n        Val b2 = BoxRotating(p, vec3(-3., 0.0, 0.0), vec3(1.0, 1.5, 1.75), iTime);\n          Val b = TranslateBoxDynamic(p, 5.0*iTime, vec3(-3., 0.0, 1.0), vec3(1.0, 1.5, 1.75));\n\n    Val v = Union(\n        Sphere(p, vec3(-13., 0., 0.), 3.0),\n        Union(\n            Ellipsoid(p, vec3(-7., 0.,0.), vec3(2.0, 1.0, 3.0)),\n           Box(p, vec3(-3., 0.0, 0.0), vec3(1.0, 1.5, 1.75))\n        )\n    );\n   \n       \n    Val v1 = Union(\n        SphereWithDeformation(p, vec3(-11., 0., 0.), 3.0,0.9),\n        Union(\n           SphereWithDeformation(p, vec3(-1., 0.,0.), 3.0,0.5),\n            SphereWithDeformation(p,vec3(9., 0.0, 0.0), 3.0,0.15)\n        )\n    );\n   \n   \n    Val f2 = Union( Cylinder(p, vec3(0.5, 20., 0.), 1.0, 2.5),\n   \n    Union(\n            Capsule(p, vec3(4., 0., 0.), vec3(6., 0., 0.), 1.0),\n            Torus(p,vec3(13., 0., 1), vec2(4.0, 1.0))\n        ));\n   \n   \n   \n    Val final = Union(v,f2 );\n\n   \n   //if u want union intersection or differnce do it here\n   //et Fait des captures\n   \n\n     \n      //pour un croissant\n     \n   Val croissant = Croissant(p);\n  Val cochon =  cochon(p);\n     \n   Val r = Union(croissant,cochon);\n   \n   final = Union(final,Plane(p,vec3(0.,0.,1.),vec3(0.0,0.0,-4.0)));\n\n\n  return final;\n}\n\n\n\n/*\n\n// Modified object function to specify materials\n\nVal object(vec3 p) {\n    // Metallic sphere\n    Val metallicSphere = Sphere(p, vec3(-13., 0., 0.), 3.0, 0.8);\n    \n    // Regular matte sphere\n    Val matteSphere = Sphere(p, vec3(-7., 0., 0.), 3.0, 0.0);\n    \n    // Semi-reflective box\n    Val semiReflectiveBox = Box(p, vec3(-3., 0.0, 0.0), vec3(1.0, 1.5, 1.75), 0.5);\n    \n    // Combine objects\n    Val scene = Union(metallicSphere, Union(matteSphere, semiReflectiveBox));\n    \n    // Ground plane\n    Val ground = Val(dot((p-vec3(0.0,0.0,-4.0)), vec3(0.,0.,1.)), 1, 0.2);\n    \n    return Union(scene, ground);\n}\n\n*/\n\n\n\n\n\n\n\n// Analysis of the scalar field -----------------------------------------------------------------\n\n\nconst int Steps=200;// Number of steps\nconst float Epsilon=.01;// Marching epsilon\n\n// Object normal\n// p : point\nvec3 ObjectNormal(vec3 p)\n{\n  const float eps=.001;\n  vec3 n;\n  Val val=object(p);\n  float v=val.v;\n  n.x=object(vec3(p.x+eps,p.y,p.z)).v-v;\n  n.y=object(vec3(p.x,p.y+eps,p.z)).v-v;\n  n.z=object(vec3(p.x,p.y,p.z+eps)).v-v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// ray : The ray\n//   e : Maximum distance\n//   h : hit\n//   s : Number of steps\n//   c : cost\nbool SphereTrace(Ray ray,float e,out float t,out int s,out int c)\n{\n  bool h=false;\n \n  // Start at the origin\n  t=0.0;\n  c=0;\n \n  for(int i=0;i<Steps;i++)\n  {\n    s=i;\n    vec3 p=Point(ray,t);\n    Val val=object(p);\n    float v=val.v;\n    c+=val.c;\n    // Hit object\n    if(v<0.)\n    {\n      h=true;\n      break;\n    }\n    // Move along ray\n    t+=max(Epsilon,v);\n    // Escape marched too far away\n    if(t>e)\n    {\n      break;\n    }\n  }\n  return h;\n}\n\n// Lighting -------------------------------------------------------------------------------\n\n\n\n\n\n\nvec3 GradientColor(float depth) {\n \n    float t = smoothstep(0.0, 10.0, depth);\n    return mix(vec3(0.5, 0.0, 0.5), vec3(0.0, 0.0, 1.0), t);\n\n}\n\n\n// Background color\n// ray : Ray\n\n\n\n\nvec3 background(Ray ray)\n{\n    float depth = (ray.d.z + 1.0) * 0.5;\n    //return GradientColor(depth);\n      return mix(vec3(.45,.55,.99),vec3(.65,.69,.99),ray.d.z*.5+.5);\n\n   \n}\n\n// Shadowing\n// p : Point\n// n : Normal\n// l : Light direction\nfloat Shadow(vec3 p,vec3 n,vec3 l)\n{\n  float t;\n  int s;\n  int c;\n  bool hit=SphereTrace(Ray(p+Epsilon*n,l),100.,t,s,c);\n  if(!hit)\n  {\n    return 1.;\n  }\n  return 0.;\n}\n\n\n\n// Compute ambient occlusion by sampling along the surface normal\n// p: The surface point\n// n: The normal at the surface point\n// k: Attenuation factor\n\nfloat AmbientOcclusion(vec3 p, vec3 n, float k) {\n    float ao = 0.0;\n    float scale = 1.0;\n    for (int i = 0; i < 5; i++) { // Number of samples\n        float dist = float(i) * 0.1; // Distance increment for each sample\n        vec3 samplePoint = p + n * dist;\n        Val sampleVal = object(samplePoint);\n        ao += (dist - sampleVal.v) * scale; // Accumulate occlusion based on distance to object\n        scale *= 0.75; // Gradually reduce scale for smooth falloff\n    }\n    return clamp(1.0 - k * ao, 0.0, 1.0); // Clamp to [0, 1]\n}\n\n\n\n// Hash function pour le bruit de Perlin\nvec3 hash33(vec3 p) {\n    p = vec3(dot(p, vec3(127.1, 311.7, 74.7)),\n             dot(p, vec3(269.5, 183.3, 246.1)),\n             dot(p, vec3(113.5, 271.9, 124.6)));\n    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\n// Bruit de Perlin 3D optimisé\nfloat perlinNoise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(mix(dot(hash33(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0)),\n                      dot(hash33(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0)), u.x),\n                  mix(dot(hash33(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0)),\n                      dot(hash33(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0)), u.x), u.y),\n              mix(mix(dot(hash33(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0)),\n                      dot(hash33(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0)), u.x),\n                  mix(dot(hash33(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0)),\n                      dot(hash33(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0)), u.x), u.y), u.z) * 0.5 + 0.5;\n}\n\n// Mouvement Brownien fractionnaire (fBm)\nfloat fbm(vec3 p) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 1.0;\n    // Nombre d'octaves pour le fBm\n    const int OCTAVES = 6;\n    \n    for(int i = 0; i < OCTAVES; i++) {\n        value += amplitude * perlinNoise(p * frequency);\n        frequency *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\n// Fonction de texture marbre\nfloat marbleTexture(vec3 p) {\n    float marble = p.x + p.y + p.z;\n    marble += fbm(p * 3.0) * 2.0;\n    marble = sin(marble * 3.14159) * 0.5 + 0.5;\n    return marble;\n}\n\n\n// Shading and lighting\n//   p : Point\n//   n : Normal at point\n// eye : Eye direction\n\nvec3 ShadePhong(vec3 p, vec3 n, Ray eye) {\n    // Texture de marbre\n    float marblePattern = marbleTexture(p * 0.8); // Ajuster l'échelle avec le facteur 0.5\n    \n    // Couleurs de base pour le marbre\n    vec3 marbleColor1 = vec3(0.9, 0.9, 0.9); // Blanc\n    vec3 marbleColor2 = vec3(0.2, 0.2, 0.3); // Gris foncé\n    vec3 baseColor = mix(marbleColor2, marbleColor1, marblePattern);\n\n    // Point light\n    const vec3 lp = vec3(5., 10., 25.);\n    vec3 l = normalize(lp - p);\n    \n    // Ambient\n    float occlusion = AmbientOcclusion(p, n, 2.0);\n    vec3 ambient = 0.25 * baseColor * occlusion;\n    \n    // Shadow\n    float shadow = Shadow(p, n, l);\n    \n    // Diffuse\n    vec3 diffuse = 0.35 * baseColor * clamp(dot(n, l), 0., 1.);\n    \n    // Specular\n    vec3 viewDir = normalize(eye.d);\n    vec3 h = normalize(l + viewDir);\n    vec3 specular = 0.15 * pow(clamp(dot(n, h), 0., 1.), 35.) * vec3(1.);\n    \n    // Final color\n    return ambient + shadow * (diffuse + specular);\n}\n\n/*\n\n\n// Modified ShadePhong function to handle reflections\n\n\nvec3 ShadePhong(vec3 p, vec3 n, Ray eye, float metallic, int depth) {\n    // Base color calculation (non-reflective part)\n    vec3 ambientColor = vec3(0.7, 0.7, 0.8);\n    float ambientStrength = 0.25;\n    float occlusion = AmbientOcclusion(p, n, 2.0);\n    \n    const vec3 lp = vec3(5., 10., 25.);\n    vec3 l = normalize(lp - p);\n    vec3 ambient = .25 + .25 * background(Ray(p, n)) * occlusion;\n    float shadow = Shadow(p, n, l);\n    vec3 diffuse = .35 * clamp(dot(n, l), 0., 1.) * vec3(1., 1., 1.);\n    vec3 viewDir = normalize(eye.d);\n    vec3 h = normalize(l + viewDir);\n    vec3 specular = .15 * pow(clamp(dot(n, h), 0., 1.), 35.) * vec3(1., 1., 1.);\n    vec3 baseColor = ambient + shadow * (diffuse + specular);\n    \n    // Calculate reflection if metallic and depth allows\n    vec3 reflectionColor = vec3(0.0);\n    if(metallic > 0.0 && depth > 0) {\n        vec3 reflectionDir = reflect(eye.d, n);\n        Ray reflectionRay = Ray(p + n * Epsilon, reflectionDir);\n        \n        float reflectT;\n        int reflectS, reflectC;\n        bool reflectHit = SphereTrace(reflectionRay, 100., reflectT, reflectS, reflectC);\n        \n        if(reflectHit) {\n            vec3 reflectP = Point(reflectionRay, reflectT);\n            vec3 reflectN = ObjectNormal(reflectP);\n            reflectionColor = ShadePhong(reflectP, reflectN, reflectionRay, 0.0, depth - 1);\n        } else {\n            reflectionColor = background(reflectionRay);\n        }\n    }\n    \n    // Mix between base color and reflection based on metallic value\n    return mix(baseColor, reflectionColor, metallic);\n}\n\n*/\n\n\n\n// Shading according to the number of steps in sphere tracing\n// n : Number of steps\nvec3 ShadeSteps(int n,int m)\n{\n  float t=float(n)/(float(m));\n  return.5+mix(vec3(.05,.05,.5),vec3(.65,.39,.65),t);\n}\n\n\n\n\n\nvoid mainImage(out vec4 color, in vec2 pxy) {\n    vec2 pixel = (-iResolution.xy + 2.0 * pxy) / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    Ray ray = CreateRay(m, pixel);\n    float t = 0.0;\n    int s = 0;\n    int c;\n    bool hit = SphereTrace(ray, 100., t, s, c);\n    \n    vec3 rgb = background(ray);\n    \n    if(hit) {\n        vec3 p = Point(ray, t);\n        vec3 n = ObjectNormal(p);\n        \n        // Ajout des deux sources de lumière\n        vec3 lightPosition1 = vec3(-8, -6, -5);\n        vec3 lightDirection1 = normalize(lightPosition1 - p);\n        float lightIntensity1 = 0.6;\n        \n        vec3 lightPosition2 = vec3(1, 1, 1);\n        vec3 lightDirection2 = normalize(lightPosition2 - p);\n        float lightIntensity2 = 0.7;\n        \n        rgb = lightIntensity1 * ShadePhong(p, n, ray);\n        rgb += lightIntensity2 * ShadePhong(p, n, ray);\n    }\n    \n    color = vec4(rgb, 1.0);\n}\n\n/*\n\n// Modified mainImage to handle glossy material \n\nvoid mainImage(out vec4 color, in vec2 pxy) {\n    vec2 pixel = (-iResolution.xy+2.*pxy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    Ray ray = CreateRay(m, pixel);\n    \n    float t;\n    int s, c;\n    bool hit = SphereTrace(ray, 100., t, s, c);\n    vec3 rgb = background(ray);\n    \n    if(hit) {\n        vec3 p = Point(ray, t);\n        vec3 n = ObjectNormal(p);\n        Val val = object(p);\n        rgb = ShadePhong(p, n, ray, val.metallic, 1); // 1 is the reflection depth (niveau de rélection)\n    }\n    \n    color = vec4(rgb, 1.);\n}\n\n*/\n","name":"Image","description":"","type":"image"}]}