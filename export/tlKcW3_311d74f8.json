{"ver":"0.1","info":{"id":"tlKcW3","date":"1611962600","viewed":148,"name":"Polar Stars","username":"BradyInstead","description":"Polar stars, with generated perlin noise","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["stars","polar","coordinates"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BLUR .8\n\nvec3 nearPixel(vec2 fragCoord, vec2 pos)\n{\n\treturn texture(iChannel0, (fragCoord+pos)/iResolution.xy).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get color + AA\n    vec3 col = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    \n    // Uncomment for AA\n    col = mix(col, nearPixel(fragCoord, vec2(0., 1.)), BLUR);\n    col = mix(col, nearPixel(fragCoord, vec2(1., 0.)), BLUR);\n    col = mix(col, nearPixel(fragCoord, vec2(0., -1.)), BLUR);\n    col = mix(col, nearPixel(fragCoord, vec2(-1., 0.)), BLUR);\n    col = mix(col, nearPixel(fragCoord, vec2(-1., 1.)), BLUR);\n    col = mix(col, nearPixel(fragCoord, vec2(1., -1.)), BLUR);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159\n\n//  https://github.com/BrianSharpe/Wombat/blob/master/Perlin3D.glsl\nfloat perlin( vec3 P )\n{\n    // establish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n    vec3 Pf_min1 = Pf - 1.0;\n\n    // clamp the domain\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    // calculate the hash\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n    vec3 lowz_mod = vec3( 1.0 / ( SOMELARGEFLOATS + Pi.zzz * ZINC ) );\n    vec3 highz_mod = vec3( 1.0 / ( SOMELARGEFLOATS + Pi_inc1.zzz * ZINC ) );\n    vec4 hashx0 = fract( Pt * lowz_mod.xxxx );\n    vec4 hashx1 = fract( Pt * highz_mod.xxxx );\n    vec4 hashy0 = fract( Pt * lowz_mod.yyyy );\n    vec4 hashy1 = fract( Pt * highz_mod.yyyy );\n    vec4 hashz0 = fract( Pt * lowz_mod.zzzz );\n    vec4 hashz1 = fract( Pt * highz_mod.zzzz );\n\n    // calculate the gradients\n    vec4 grad_x0 = hashx0 - 0.49999;\n    vec4 grad_y0 = hashy0 - 0.49999;\n    vec4 grad_z0 = hashz0 - 0.49999;\n    vec4 grad_x1 = hashx1 - 0.49999;\n    vec4 grad_y1 = hashy1 - 0.49999;\n    vec4 grad_z1 = hashz1 - 0.49999;\n    vec4 grad_results_0 = inversesqrt( grad_x0 * grad_x0 + grad_y0 * grad_y0 + grad_z0 * grad_z0 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x0 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y0 + Pf.zzzz * grad_z0 );\n    vec4 grad_results_1 = inversesqrt( grad_x1 * grad_x1 + grad_y1 * grad_y1 + grad_z1 * grad_z1 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x1 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y1 + Pf_min1.zzzz * grad_z1 );\n\n    // Classic Perlin Interpolation\n    vec3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);\n    vec4 res0 = mix( grad_results_0, grad_results_1, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    float final = dot( res0, blend2.zxzx * blend2.wwyy );\n    return ( final * 1.1547005383792515290182975610039 );  // scale things to a strict -1.0->1.0 range  *= 1.0/sqrt(0.75)\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 pos = ( fragCoord -.5*iResolution.xy ) / iResolution.y;\n    \n    vec2 spos = pos*5.;\n    pos += vec2(perlin(vec3(spos.x, spos.y, iTime*.5)), perlin(vec3(spos.x, spos.y, iTime+5.))) / (4. + length(spos)*.1) * .2;\n    \n    // length\n    float l = pow(length(pos)*20., .3);\n    \n    // angle\n    float a = atan(pos.y, pos.x);\n    \n    // color\n    vec3 seed = vec3(l - iTime*.3, a, 0.);\n    seed.xy *= 40.;\n    float n = perlin(seed);\n    n = smoothstep(.35, .4, n);\n    vec3 col = vec3(n);\n    \n    // shadow\n    col *= pow(l*.8, 4.);\n    col *= 3.;\n\n    // motion blur\n    vec4 Color0 = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    col = mix(col, Color0.rgb, .8);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}