{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"\n// If you want to puke, just uncomment these lines... ^^\n#define ANIMATE_TUNNEL\n#define ROTATE_BARS\n#define TRANSLATE_BARS\n\n// Define this to feel the power of the turd\n//#define TURD_MODE\n\n// Change this for more or less reflection\n#define FRESNEL 0.05\n\n\nconst float PI = 8.0;//3.14159265358979;\n\nfloat repeat( float a, float s )\n{\n\treturn mod( a - 0.5*s, s ) + 0.5*s;\n}\n\nfloat smin( float a, float b, float k )\n{\n\treturn log( max( 0.001, exp( a*k ) + exp( b*k ) ) ) / k;\n\treturn log( max( 0.001, exp( (-10.0+a)*k ) + exp( (-10.0+b)*k ) ) ) / k + 10.0;\n}\n\nfloat smin2( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\n\nfloat noise( in vec3 x )\n{\n   vec3 p = floor(x);\n   vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n// Assuming n1=1 (air) we get:\n//\tF0 = ((n2 - n1) / (n2 + n1))Â²\n//\t=> n2 = (1 + sqrt(F0)) / (1 - sqrt(F0))\n//\nvec3\tFresnel_IORFromF0( vec3 _F0 )\n{\n\tvec3\tSqrtF0 = sqrt( _F0 );\n\treturn (1.0 + SqrtF0) / (1.00001 - SqrtF0);\n}\n\n// Full accurate Fresnel computation (from Walter's paper Â§5.1 => http://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf)\n// For dielectrics only but who cares!?\nvec3\tFresnel( vec3 _IOR, float _CosTheta, float _FresnelStrength )\n{\n\tfloat\tc = mix( 1.0, _CosTheta, _FresnelStrength );\n\tvec3\tg_squared = max( vec3(0.0), _IOR*_IOR - 1.0 + c*c );\n// \tif ( g_squared < 0.0 )\n// \t\treturn 1.0;\t// Total internal reflection\n\n\tvec3\tg = sqrt( g_squared );\n\n\tvec3\ta = (g - c) / (g + c);\n\t\t\ta *= a;\n\tvec3\tb = (c * (g+c) - 1.0) / (c * (g-c) + 1.0);\n\t\t\tb = 1.0 + b*b;\n\n\treturn 0.5 * a * b;\n}\n\nfloat smoothinterp( float x0, float x1, float t )\n{\n\treturn mix( x0, x1, smoothstep( 0.0, 1.0, t ) );\n}\n\nvec2 tunnelCenter( float z )\n{\n#ifdef ANIMATE_TUNNEL\n\treturn vec2(\t0.2 * (sin( 0.5919 * z + 4.0 * iTime ) + sin( 1.2591 * z )*cos( 0.915 * z )),\n\t\t\t\t\t0.2 * (sin( 1.8 * z + 4.0 * iTime ) + sin( 0.1378 * z )) );\n#else\n\treturn vec2( 0.0, 0.0 );\n#endif\n}\n\nconst float barGap = 1.0;\n\nvoid barCenterAxis( float z, out vec3 barCenter, out vec3 barAxis, out float barOffset )\n{\t\n\tvec2\tc = tunnelCenter( z ); \t// Tunnel center\n\t\n\t// Retrieve bar index & compute rotation/offset\n\tfloat\tbarIndex = floor( z / barGap );\n\tfloat\tzcenter = (0.5+barIndex) * barGap;\n\tfloat\tangle = 2.0 * PI * 0.156 * (0.2+barIndex);// + iTime;\n\t\n\tangle = 0.798 * barIndex;\t// Fixed bars\n#ifdef ROTATE_BARS\n\tangle += iTime * (0.5 + 1.0 * sin( 1234.567 * barIndex ));\n#endif\n\n\tbarAxis = vec3( cos( angle ), sin( angle ), 0.2 * sin( zcenter ) );\n\n#ifdef TRANSLATE_BARS\n\tbarOffset = 0.0 + 0.5 * sin( 17.21191 * barIndex + iTime * (0.5 + 1.0 * sin( 8976.5431 * barIndex )) );\n#else\n\tbarOffset = 0.0 + 0.5 * sin( 17.21191 * barIndex );\n#endif\n\n\tbarCenter = vec3( c + barOffset * vec2( -barAxis.y, barAxis.x ), zcenter );\n}\n\nvec3 safePosition( float z, float rand )\n{\n\tvec3\tbarCenter0, barAxis0; float barOffset0;\n\tbarCenterAxis( z - 0.5 * barGap, barCenter0, barAxis0, barOffset0 );\n\tvec2\ttunnelCenter0 = tunnelCenter( barCenter0.z );\n\n\tvec3\tbarCenter1, barAxis1; float barOffset1;\n\tbarCenterAxis( z + 0.5 * barGap, barCenter1, barAxis1, barOffset1 );\n\tvec2\ttunnelCenter1 = tunnelCenter( barCenter1.z );\n\t\n\tfloat\tz0 = barCenter0.z;\n\tfloat\tz1 = barCenter1.z;\n\tfloat\tt = (z - z0) / (z1 - z0); // Interpolant\n\t\n\t// Compute the 2 valid positions for each bar\n\tfloat\toff0 = mix( 0.5*(1.0+barOffset0), 0.5*(-1.0+barOffset0),\n\t\t\t\t\t\tstep( 0.0, sign( sin( 37.85961 * (z0 + rand) ) ) ) );\t// Choose between left or right of the bar...\n\tvec2\tsafePos0 = tunnelCenter0 + off0 * vec2( -barAxis0.y, barAxis0.x );\n\n\tfloat\toff1 = mix( 0.5*(1.0+barOffset1), 0.5*(-1.0+barOffset1),\n\t\t\t\t\t\tstep( 0.0, sign( sin( 37.85961 * (z1 + rand) ) ) ) );\n\tvec2\tsafePos1 = tunnelCenter1 + off1 * vec2( -barAxis1.y, barAxis1.x );\n\t\n\treturn vec3(\tsmoothinterp( safePos0.x, safePos1.x, t ),\n\t\t\t\t\tsmoothinterp( safePos0.y, safePos1.y, t ),\n\t\t\t\t\tz );\n}\n\nfloat bisou( vec3 p )\n{\n\tvec3\tc, axis; float offset;\n\tbarCenterAxis( p.z, c, axis, offset );\n\t\n\tvec3\ttoP = p-c;\n\tvec3\tplaneP = toP - dot( toP, axis ) * axis;\n\t\n\treturn length( planeP ) - 0.1\n//\t\t- 0.05 * noise(37.0569 * p )\n\t\t;\n}\n\nfloat map( vec3 p )\n{\n\tvec2\tc = tunnelCenter( p.z );\n\tfloat\td_tunnel = 1.0 - length( p.xy - c );\n\tfloat\td_bar = bisou( p );\n\n\treturn smin2( d_tunnel, d_bar, 0.7 )\n#ifdef TURD_MODE\n\t\t- 0.025 * noise( 67.0569 * p )\n#endif\n\t;\n\t\n\treturn min( d_tunnel, d_bar );\n\treturn smin( d_tunnel, d_bar, -4.0 );\n}\n\nvec3 normal( vec3 p, const float eps, out float cheapAO )\n{\n\tvec2 e = vec2( eps, 0.0 );\n\tfloat c = map( p );\n\tvec3\tn = vec3(\n\t\tmap( p + e.xyy ) - map( p - e.xyy ),\n\t\tmap( p + e.yxy ) - map( p - e.yxy ),\n\t\tmap( p + e.yyx ) - map( p - e.yyx )\n\t\t);\n\tcheapAO = length( n );\n\treturn n / cheapAO;\n}\n\nvec3 reflection( vec3 p, vec3 v, vec3 n )\n{\n\tv = reflect( v, n );\n//\tp += (0.01 / dot( v, n )) * v;\n\tp += 0.01 * n;\n\n\tfloat\tt = 0.0;\n\tfor ( int i=0; i < 64; i++ )\n\t{\n\t\tfloat\td = map( p );\n\t\tif ( d < 0.005 ) break;\n\n\t\tt += d;\n\t\tp += d * v;\n\t}\n\n\treturn p;\n}\n\nfloat AO( vec3 p, vec3 n )\n{\n\tconst float step = 0.01;\n\tp += 0.1 * n;\n\tfloat AO = 1.0;\n\tfor ( int i=0; i < 16; i++ )\n\t{\n\t\tfloat\td = max( 0.0, map( p ) );\n\t\tp += step * n;\n\t\t\n\t\tAO *= 1.0 - exp( -20.0 * d * (2.0+float(i)) );\n\t}\n\treturn AO;\n}\n\nfloat\tShadow( vec3 p, vec3 l, float distance2Light )\n{\n\tconst float\tk = 10.0;\n\n\tfloat S = 1.0;\n\tfloat t = 0.05;\n\tfor ( int i=0; i < 64; i++ )\n\t{\n\t\tfloat\th = map( p + t * l );\n\t\tif ( h < 0.0001 )\n\t\t\treturn 0.0;\n\n\t\tS = min( S, k*h / t );\n\t\tt += h;\n\t\tif ( t > distance2Light )\n\t\t\tbreak;\n\t}\n\treturn S;\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2\tuv = fragCoord.xy / iResolution.xy;\n\t\n\tfloat\tz = 1.0 * iTime;\n\n\tvec3\tp = safePosition( z, 0.0 );\n\n\tvec3\ttarget = p + vec3(\n\t\tsin( 1.2 * iTime ),\n\t\tsin( 1.0 + 0.7891 * iTime ),\n\t\t5.0 + 2.0 * sin( 1.2 * iTime )\n\t\t);\n\t\n\tvec3\tat = normalize( target - p );\n\tvec3\tright = normalize( cross( at, vec3( 0, 1, 0 ) ) );\n\tvec3\tup = cross( right, at );\n\n\tfloat\tTan = 0.6;\n\tvec3\tv = normalize( vec3( iResolution.x / iResolution.y * Tan * (2.0 * uv.x - 1.0), Tan * (2.0 * uv.y - 1.0), 1.0 ) );\n\t\t\tv = v.x * right + v.y * up + v.z * at;\n\n\t// Compute light position\n\tfloat\tlightTime = 0.25 * iTime;\n\tfloat\tz_light = z + 4.0 + 3.0 * sin( 3.156 * lightTime ) * sin( 0.15891 * lightTime );\n\tvec3\tl = safePosition( z_light, 187.65 );\n\n\t// March!\n\tvec3\tprevPos2Light = l - p;\n\tfloat\tprevDist2Light = length( prevPos2Light );\n\t\t\tprevPos2Light /= max( 1e-4, prevDist2Light );\n\n\tfloat\tscatt = 0.0;\n\tvec3\tp_orig = p;\n\tfor ( int i=0; i < 64; i++ )\n\t{\n\t\tfloat\td = map( p );\n\t\tif ( d < 0.005 ) break;\n\t\tp += d * v;\n\n\t\tvec3\tpos2Light = l - p;\n\t\tfloat\tdist2Light = length( pos2Light );\n\t\t\t\tpos2Light /= max( 1e-4, dist2Light );\n\t\tscatt += d / pow( 0.5 * (prevDist2Light + dist2Light), 2.0 );\n\t\tprevPos2Light = pos2Light;\n\t\tprevDist2Light = dist2Light;\n\t}\n\n\tconst float\t\tLightIntensity = 0.5;\n\tconst vec3\tC0 = 1.0 * vec3( 0.2, 0.2, 0.2 );\n\tconst vec3\tC1 = vec3( 1.0, 1.0, 1.0 );\n\n\tscatt = pow( max( 0.0, 0.2 * (scatt - 0.25) ), 2.0 );\n\n\t// Compute normal and Fresnel\n\tfloat\tAO;\n\tvec3\tn = normal( p, 0.0001, AO );\n\tvec3\tF0 = FRESNEL * vec3( 0.5, 0.8, 1.0 );\n\tvec3\tFr = clamp( vec3( 0.0 ), vec3( 1.0 ), Fresnel( Fresnel_IORFromF0( F0 ), dot( -v, n ), 1.0 ) );\n\n\t// Compute direct lighting\n\tvec3\tLight = l - p;\n\tfloat\tdLight = length( Light );\n\t\t\tLight *= 1.0 / max( 0.001, dLight );\n\tfloat\tshadow = Shadow( p, Light, dLight );\n\tvec3\tcolorT = (LightIntensity / (dLight*dLight)) * mix( C0, shadow * C1, 0.5 + 0.5 * dot( n, Light ));\n\n\t// Compute reflection\n\tvec3\tp_refl = reflection( p, v, n );\n\tvec3\tn_refl = normal( p_refl, 0.0001, AO );\n\n\t\t\tLight = l - p_refl;\n\t\t\tdLight = max( 0.05, length( Light ) );\n\t\t\tLight *= 1.0 / dLight;\n\tvec3\tcolorR = (LightIntensity / (dLight*dLight)) * mix( AO*C0, C1, 0.5 + 0.5 * dot( n_refl, Light ));\n\t\n\tvec3\tcolor = mix( colorT, colorR, Fr );\n\n\tcolor += scatt * vec3( 1.0, 0.5, 0.3 );\n\n\t// Apply fog\n\tfloat\tt = length( p - p_orig );\n\tfloat\tfog = exp( -0.05 * t );\n\tcolor = mix( vec3( 1.0, 0.9, 0.8 ), color, fog );\n\n\tcolor = pow( color, vec3(1.0/2.2) );\n\t\n\tfragColor = vec4( color, 1.0 );\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdlXzN","date":"1398525246","viewed":657,"name":"Toune Aile","username":"Patapom","description":"\"Bisou tunnel with bars\" a.k.a. \"what it feels like when you're a turd rushing to the sewers\"...","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["tunnel"],"hasliked":0,"parentid":"","parentname":""}}