{"ver":"0.1","info":{"id":"43XfD7","date":"1728455949","viewed":27,"name":"Transformed Box - Closest 3D","username":"natevm","description":"Brute force test to compute the closest point in object space to a transformed box. \n\nThis is currently just a reference using voronoi regions, and is super expensive at the moment...\n","likes":3,"published":1,"flags":0,"usePreview":1,"tags":["3d","sdf","box","closest"],"hasliked":0,"parentid":"M32yzm","parentname":"Transformed Box Test- closest 3D"},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright © 2024 Nate Morrical\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nconst vec3 box_rad = .5*vec3(0.5,1.,1.);\nmat3 tfm = mat3(1.0);\n\n// Closest point on a 3D box. For closest points on other primitives, check\n//\n//    https://www.shadertoy.com/playlist/wXsSzB\n\n// Inner product between a and b given metric tensor m. \n// Acts like a dot product, but in a non-euclidean space.\nfloat inner(vec3 a, vec3 b, mat3 g) {\n    // equivalent to doing dot(m * a, m * b);\n    return dot(a, g * b);\n}\n\n// Given point p, return point q on (or in) Rect r, closest to p\n// (not sure if this works for parallelograms yet...)\nvec3 closestPointToTransformedRect(vec3 p, mat3 G, vec3 a, vec3 b, vec3 c)\n{\n    vec3 ab = b - a; // vector across rect\n    vec3 ac = c - a; // vector down rect\n    vec3 d = p - a;\n    \n    // Start result at top-left corner of rect; make steps from there\n    vec3 q = a;\n    \n    // Clamp p’ (projection of p to plane of r) to rectangle in the across direction\n    float dist = inner(d, ab, G);\n    float maxdist = inner(ab, ab, G);\n    if (dist >= maxdist)\n        q += ab;\n    else if (dist > 0.0f)\n        q += (dist / maxdist) * ab;\n    // Clamp p’ (projection of p to plane of r) to rectangle in the down direction\n    dist = inner(d, ac, G);\n    maxdist = inner(ac, ac, G);\n    if (dist >= maxdist)\n        q += ac;\n    else if (dist > 0.0f)\n        q += (dist / maxdist) * ac;\n    return q;\n}\n\nstruct DebugData {\n    vec3 pt1;\n    \n    vec3 seg1;\n    vec3 seg2;\n    vec3 seg3;\n    vec3 seg4;\n};\n\n// Expensive, just meant to show the ground truth\n// G := the metric tensor, G = transpose(objToWorld) * objToWorld \nvec3 closestPointToTransformedBox(vec3 qpo, mat3 G, mat3 GInv, vec3 lo, vec3 hi, out DebugData dbg) \n{\n    \n    \n    // Attempting the 8 vertex zones in object space\n    vec3 tLo = (lo - qpo);\n    vec3 tHi = (hi - qpo);\n    \n    // Computes projection of ray to the faces of the box. \n    // The resulting signs indicate if a face is visible or not.\n    vec3 dinv = vec3(1.0 / GInv[0][0], 1.0 / GInv[1][1], 1.0 / GInv[2][2]); \n    vec3 tLoG = tLo * dinv;\n    vec3 tHiG = tHi * dinv;\n    \n    \n    \n    \n    // Compute coordinate differences\n    vec3 delta = tHi - tLo;\n    \n    // Compute dot products for tLo\n    vec3 tLoDG = vec3(dot(tLo, G[0]), dot(tLo, G[1]), dot(tLo, G[2]));\n    \n    // Tracks changes how dot products change along the box edges\n    vec3 deltaGX = delta * G[0];\n    vec3 deltaGY = delta * G[1];\n    vec3 deltaGZ = delta * G[2];\n    \n    \n    \n    \n    \n    \n    // diving by dot2 here simplifies later edge projections.\n    // /= inner(x,x,G) / = inner(y,y,G) / = inner(z,z,G)\n    vec3 ggx = G[0] / G[0][0]; //inner(x,x,G);\n    vec3 ggy = G[1] / G[1][1]; //inner(y,y,G);\n    vec3 ggz = G[2] / G[2][2];\n        \n    // dot products between corners and metric tensor bases.\n    vec3 cdg[8];\n    \n    // Compute dot products for all corners\n    for (int N = 0; N < 8; ++N) {\n        bool bx = bool((N >> 0) & 1);\n        bool by = bool((N >> 1) & 1);\n        bool bz = bool((N >> 2) & 1);\n\n        // Start with tLo dot products\n        vec3 cdg_n = tLoDG;\n\n        // Add contributions based on bits\n        if (bx) cdg_n += vec3(deltaGX.x, deltaGY.x, deltaGZ.x);\n        if (by) cdg_n += vec3(deltaGX.y, deltaGY.y, deltaGZ.y);\n        if (bz) cdg_n += vec3(deltaGX.z, deltaGY.z, deltaGZ.z);\n\n        // Store results\n        cdg[N] = cdg_n;\n    }\n    \n    \n    // Edge zones want these tests. Theoretically they would also be usable for the face tests....\n    // These tests come from dot products between edges and cross products \n    // between local coordinate bases and inverse metric tensor bases. \n    float c0_xgy = (tLo.z * GInv[1].y - tLo.y * GInv[1].z);\n    float c0_xgz = (tLo.y * GInv[2].z - tLo.z * GInv[2].y);\n    float c2_xgz = (tLo.z * GInv[2].y - tHi.y * GInv[2].z);\n    float c2_xgy = (tLo.z * GInv[1].y - tHi.y * GInv[1].z);\n    float c4_xgz = (tLo.y * GInv[2].z - tHi.z * GInv[2].y);\n    float c4_xgy = (tLo.y * GInv[1].z - tHi.z * GInv[1].y);\n    float c6_xgy = (tHi.y * GInv[1].z - tHi.z * GInv[1].y);\n    float c6_xgz = (tHi.z * GInv[2].y - tHi.y * GInv[2].z);\n\n    float c0_ygz = (tLo.x * GInv[2].z - tLo.z * GInv[2].x);\n    float c0_ygx = (tLo.z * GInv[0].x - tLo.x * GInv[0].z);\n    float c1_ygx = (tLo.z * GInv[0].x - tHi.x * GInv[0].z);\n    float c1_ygz = (tLo.z * GInv[2].x - tHi.x * GInv[2].z);\n    float c4_ygx = (tLo.x * GInv[0].z - tHi.z * GInv[0].x);\n    float c4_ygz = (tLo.x * GInv[2].z - tHi.z * GInv[2].x);\n    float c5_ygz = (tHi.z * GInv[2].x - tHi.x * GInv[2].z);\n    float c5_ygx = (tHi.x * GInv[0].z - tHi.z * GInv[0].x);\n\n    float c0_zgx = (tLo.y * GInv[0].x - tLo.x * GInv[0].y);\n    float c0_zgy = (tLo.x * GInv[1].y - tLo.y * GInv[1].x);\n    float c1_zgy = (tLo.y * GInv[1].x - tHi.x * GInv[1].y);\n    float c1_zgx = (tLo.y * GInv[0].x - tHi.x * GInv[0].y);\n    float c2_zgy = (tLo.x * GInv[1].y - tHi.y * GInv[1].x);\n    float c2_zgx = (tLo.x * GInv[0].y - tHi.y * GInv[0].x);\n    float c3_zgx = (tHi.x * GInv[0].y - tHi.y * GInv[0].x);\n    float c3_zgy = (tHi.y * GInv[1].x - tHi.x * GInv[1].y);\n    \n    \n    vec4 xuvlohi, yuvlohi, zuvlohi;\n        \n    // Hunting for common terms...\n\n    // Compute components using symmetric properties\n    float z_xlo = (G[0][1] * tLoDG.y - G[1][1] * tLoDG.x);\n    float y_xlo = (G[0][2] * tLoDG.z - G[2][2] * tLoDG.x);\n    float z_ylo = (G[0][1] * tLoDG.x - G[0][0] * tLoDG.y);\n    //float x_ylo = (G[1][2] * tLoDG.z - G[2][2] * tLoDG.y);\n    float y_zlo = (G[0][2] * tLoDG.x - G[0][0] * tLoDG.z);\n    //float x_zlo = (G[1][2] * tLoDG.y - G[1][1] * tLoDG.z);\n\n    //float x_yhi = (G[1][2] * (tLoDG.z + deltaGZ.x) - G[2][2] * (tLoDG.y + deltaGY.x));\n    //float x_zhi = (G[1][2] * (tLoDG.y + deltaGY.x) - G[1][1] * (tLoDG.z + deltaGZ.x));\n    float y_xhi = (G[0][2] * (tLoDG.z + deltaGZ.y) - G[2][2] * (tLoDG.x + deltaGX.y));\n    float y_zhi = (G[0][2] * (tLoDG.x + deltaGX.y) - G[0][0] * (tLoDG.z + deltaGZ.y));\n    float z_xhi = (G[0][1] * (tLoDG.y + deltaGY.z) - G[1][1] * (tLoDG.x + deltaGX.z));\n    float z_yhi = (G[0][1] * (tLoDG.x + deltaGX.z) - G[0][0] * (tLoDG.y + deltaGY.z));\n\n    // Used for the faces. Feels somewhat like a matrix inversion...\n    float XYDet = G[0][0] * G[1][1] - G[0][1] * G[0][1];\n    //float YZDet = G[1][1] * G[2][2] - G[1][2] * G[1][2];\n    float XZDet = G[0][0] * G[2][2] - G[0][2] * G[0][2];\n    //xuvlohi = (vec4(x_ylo, x_zlo, x_yhi, x_zhi) / YZDet) + vec4(tLo.yz, tLo.yz);\n    yuvlohi = (vec4(y_xlo, y_zlo, y_xhi, y_zhi) / XZDet) + vec4(tLo.xz, tLo.xz);\n    zuvlohi = (vec4(z_xlo, z_ylo, z_xhi, z_yhi) / XYDet) + vec4(tLo.xy, tLo.xy);\n\n    // Zone tests\n    \n    // There are 8 vertex zones\n    bool vertexA, vertexB, vertexC, vertexD;\n    bool vertexE, vertexF, vertexG, vertexH;\n    vertexA = all(bvec3(+cdg[0].x >= 0.0, +cdg[0].y >= 0.0, +cdg[0].z >= 0.0));\n    vertexB = all(bvec3(-cdg[1].x >= 0.0, +cdg[1].y >= 0.0, +cdg[1].z >= 0.0));\n    vertexC = all(bvec3(+cdg[2].x >= 0.0, -cdg[2].y >= 0.0, +cdg[2].z >= 0.0));\n    vertexD = all(bvec3(-cdg[3].x >= 0.0, -cdg[3].y >= 0.0, +cdg[3].z >= 0.0));\n    vertexE = all(bvec3(+cdg[4].x >= 0.0, +cdg[4].y >= 0.0, -cdg[4].z >= 0.0));\n    vertexF = all(bvec3(-cdg[5].x >= 0.0, +cdg[5].y >= 0.0, -cdg[5].z >= 0.0));\n    vertexG = all(bvec3(+cdg[6].x >= 0.0, -cdg[6].y >= 0.0, -cdg[6].z >= 0.0));\n    vertexH = all(bvec3(-cdg[7].x >= 0.0, -cdg[7].y >= 0.0, -cdg[7].z >= 0.0));\n        \n    // There are 12 edge zones\n    // These consist of two tests: between two vertex zones and above two face zones.\n    bool edgeA, edgeB, edgeC, edgeD; // edges along X\n    bool edgeI, edgeJ, edgeK, edgeL; // edges along Y\n    bool edgeE, edgeF, edgeG, edgeH; // edges along Z\n    edgeA = all(bvec4(-cdg[0].x >= 0.0, +cdg[1].x >= 0.0, c0_xgy >= 0.0, c0_xgz >= 0.0));\n    edgeB = all(bvec4(-cdg[2].x >= 0.0, +cdg[3].x >= 0.0, c2_xgz >= 0.0, c2_xgy >= 0.0));\n    edgeC = all(bvec4(-cdg[4].x >= 0.0, +cdg[5].x >= 0.0, c4_xgz >= 0.0, c4_xgy >= 0.0));\n    edgeD = all(bvec4(-cdg[6].x >= 0.0, +cdg[7].x >= 0.0, c6_xgy >= 0.0, c6_xgz >= 0.0));\n    \n    edgeE = all(bvec4(-cdg[0].y >= 0.0, +cdg[2].y >= 0.0, c0_ygz >= 0.0, c0_ygx >= 0.0));\n    edgeF = all(bvec4(-cdg[1].y >= 0.0, +cdg[3].y >= 0.0, c1_ygx >= 0.0, c1_ygz >= 0.0));\n    edgeG = all(bvec4(-cdg[4].y >= 0.0, +cdg[6].y >= 0.0, c4_ygx >= 0.0, c4_ygz >= 0.0));\n    edgeH = all(bvec4(-cdg[5].y >= 0.0, +cdg[7].y >= 0.0, c5_ygz >= 0.0, c5_ygx >= 0.0));\n    \n    edgeI = all(bvec4(-cdg[0].z >= 0.0, +cdg[4].z >= 0.0, c0_zgx >= 0.0, c0_zgy >= 0.0));\n    edgeJ = all(bvec4(-cdg[1].z >= 0.0, +cdg[5].z >= 0.0, c1_zgy >= 0.0, c1_zgx >= 0.0));\n    edgeK = all(bvec4(-cdg[2].z >= 0.0, +cdg[6].z >= 0.0, c2_zgy >= 0.0, c2_zgx >= 0.0));\n    edgeL = all(bvec4(-cdg[3].z >= 0.0, +cdg[7].z >= 0.0, c3_zgx >= 0.0, c3_zgy >= 0.0));\n    \n    // There are 6 face zones\n    bool faceA, faceB; // X faces along Y and Z (YZ edges)\n    bool faceC, faceD; // Y faces along X and Z (XZ edges)\n    bool faceE, faceF; // Z faces along X and Y (XY edges)\n    \n    // edgeE (lololo to lohilo), edgeF (hilolo to hihilo), edgeG (lolohi to lohihi), edgeH (hilohi to hihihi); // edges along Y\n    // edgeI (lololo to lolohi), edgeJ (hilolo to hilohi), edgeK (lohilo to lohihi), edgeL (hihilo to hihihi); // edges going up Z\n    \n    // edgeE edgeG and edgeI edgeK -> (c0_ygz >= 0.0, c0_ygx >= 0.0),  (c4_ygx >= 0.0, c4_ygz >= 0.0), (c0_zgx >= 0.0, c0_zgy >= 0.0), (c2_zgy >= 0.0, c2_zgx >= 0.0)\n    //faceA = tLoG.x > 0.0 && all(greaterThan(xuvlohi.xy, tLo.yz)) && all(lessThan(xuvlohi.xy, tHi.yz)); \n    faceA = (tLoG.x > 0.0) && (c0_ygx <= 0.0) && (c4_ygx <= 0.0) && (c0_zgx <= 0.0) && (c2_zgx <= 0.0);\n    \n    // edgeF edgeH and edgeJ edgeL -> (c1_ygx >= 0.0, c1_ygz >= 0.0), (c5_ygz >= 0.0, c5_ygx >= 0.0), (c1_zgy >= 0.0, c1_zgx >= 0.0), (c3_zgx >= 0.0, c3_zgy >= 0.0)\n    //faceB = tHiG.x < 0.0 && all(greaterThan(xuvlohi.zw, tLo.yz)) && all(lessThan(xuvlohi.zw, tHi.yz)); \n    faceB = (tHiG.x < 0.0) && (c1_ygx <= 0.0) && (c5_ygx <= 0.0) && (c1_zgx <= 0.0) && (c3_zgx <= 0.0);\n    \n    faceC = tLoG.y > 0.0 && all(greaterThan(yuvlohi.xy, tLo.xz)) && all(lessThan(yuvlohi.xy, tHi.xz));\n    faceD = tHiG.y < 0.0 && all(greaterThan(yuvlohi.zw, tLo.xz)) && all(lessThan(yuvlohi.zw, tHi.xz));\n    \n    faceE = tLoG.z > 0.0 && all(greaterThan(zuvlohi.xy, tLo.xy)) && all(lessThan(zuvlohi.xy, tHi.xy));\n    faceF = tHiG.z < 0.0 && all(greaterThan(zuvlohi.zw, tLo.xy)) && all(lessThan(zuvlohi.zw, tHi.xy));   \n    \n    // Handle vertex zones.\n    if (vertexA) return qpo + mix(tLo, tHi, vec3(0.,0.,0.));\n    if (vertexB) return qpo + mix(tLo, tHi, vec3(1.,0.,0.));\n    if (vertexC) return qpo + mix(tLo, tHi, vec3(0.,1.,0.));\n    if (vertexD) return qpo + mix(tLo, tHi, vec3(1.,1.,0.));   \n    if (vertexE) return qpo + mix(tLo, tHi, vec3(0.,0.,1.));\n    if (vertexF) return qpo + mix(tLo, tHi, vec3(1.,0.,1.));\n    if (vertexG) return qpo + mix(tLo, tHi, vec3(0.,1.,1.));\n    if (vertexH) return qpo + mix(tLo, tHi, vec3(1.,1.,1.));\n    \n    // Handle edge zones\n    if (edgeA) return qpo + mix(tLo, tHi, vec3(0.,0.,0.)) - vec3(dot(G[0] / G[0][0], mix(tLo, tHi, vec3(0.,0.,0.))), 0.0, 0.0);\n    if (edgeB) return qpo + mix(tLo, tHi, vec3(0.,1.,0.)) - vec3(dot(G[0] / G[0][0], mix(tLo, tHi, vec3(0.,1.,0.))), 0.0, 0.0);\n    if (edgeC) return qpo + mix(tLo, tHi, vec3(0.,0.,1.)) - vec3(dot(G[0] / G[0][0], mix(tLo, tHi, vec3(0.,0.,1.))), 0.0, 0.0);\n    if (edgeD) return qpo + mix(tLo, tHi, vec3(0.,1.,1.)) - vec3(dot(G[0] / G[0][0], mix(tLo, tHi, vec3(0.,1.,1.))), 0.0, 0.0);\n\n    if (edgeE) return qpo + mix(tLo, tHi, vec3(0.,0.,0.)) - vec3(0.0, dot(G[1] / G[1][1], mix(tLo, tHi, vec3(0.,0.,0.))), 0.0);\n    if (edgeF) return qpo + mix(tLo, tHi, vec3(1.,0.,0.)) - vec3(0.0, dot(G[1] / G[1][1], mix(tLo, tHi, vec3(1.,0.,0.))), 0.0);\n    if (edgeG) return qpo + mix(tLo, tHi, vec3(0.,0.,1.)) - vec3(0.0, dot(G[1] / G[1][1], mix(tLo, tHi, vec3(0.,0.,1.))), 0.0);\n    if (edgeH) return qpo + mix(tLo, tHi, vec3(1.,0.,1.)) - vec3(0.0, dot(G[1] / G[1][1], mix(tLo, tHi, vec3(1.,0.,1.))), 0.0);\n\n    if (edgeI) return qpo + mix(tLo, tHi, vec3(0.,0.,0.)) - vec3(0.0, 0.0, dot(G[2] / G[2][2], mix(tLo, tHi, vec3(0.,0.,0.))));\n    if (edgeJ) return qpo + mix(tLo, tHi, vec3(1.,0.,0.)) - vec3(0.0, 0.0, dot(G[2] / G[2][2], mix(tLo, tHi, vec3(1.,0.,0.))));\n    if (edgeK) return qpo + mix(tLo, tHi, vec3(0.,1.,0.)) - vec3(0.0, 0.0, dot(G[2] / G[2][2], mix(tLo, tHi, vec3(0.,1.,0.))));\n    if (edgeL) return qpo + mix(tLo, tHi, vec3(1.,1.,0.)) - vec3(0.0, 0.0, dot(G[2] / G[2][2], mix(tLo, tHi, vec3(1.,1.,0.))));\n    \n    // Handle face zones\n    if (faceA) return qpo + tLoG.x * GInv[0]; //vec3(tLo.x, xuvlohi.x, xuvlohi.y);\n    if (faceB) return qpo + tHiG.x * GInv[0];// vec3(tHi.x, xuvlohi.z, xuvlohi.w);\n    if (faceC) return qpo + vec3(yuvlohi.x, tLo.y, yuvlohi.y);\n    if (faceD) return qpo + vec3(yuvlohi.z, tHi.y, yuvlohi.w);\n    if (faceE) return qpo + vec3(zuvlohi.x, zuvlohi.y, tLo.z);\n    if (faceF) return qpo + vec3(zuvlohi.z, zuvlohi.w, tHi.z);\n    \n    // If we're inside all face regions, the closest point is itself.\n    return qpo;\n}\n\n// Returns the closest point o, a 3D box\n//   p is the point we are at\n//   b is the box radius (3 half side lengths)\n//   The box is axis aligned and centered at the origin. For a box rotated \n//   by M,you need to transform p and the returned point by inverse(M).\nvec3 closestPointToBox( vec3 p, vec3 b )\n{\n    vec3   d = abs(p) - b;\n    float  m = min(0.0,max(d.x,max(d.y,d.z)));\n    return p - vec3(d.x>=m?d.x:0.0,\n                    d.y>=m?d.y:0.0,\n                    d.z>=m?d.z:0.0)*sign(p);\n}\n\n// Alternative implementation\nvec3 closestPointToBox2( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    vec3 s = sign(p);\n\n    // interior\n    vec3 q; float ma;\n                 { q=p; q.x=s.x*b.x; ma=d.x; }\n    if( d.y>ma ) { q=p; q.y=s.y*b.y; ma=d.y; }\n    if( d.z>ma ) { q=p; q.z=s.z*b.z; ma=d.z; }\n    if( ma<0.0 ) return q;\n\n    // exterior\n    return p - s*max(d,0.0);\n}\n\n//------------------------------------------------------------\n\nfloat dot2(vec3 v) { return dot(v, v); }\n\n// https://iquilezles.org/articles/distfunctions\nfloat udQuad( in vec3 p, in vec3 v1, in vec3 v2, in vec3 v3, in vec3 v4)\n{\n    #if 0\n    // handle ill formed quads\n    if( dot( cross( v2-v1, v4-v1 ), cross( v4-v3, v2-v3 )) < 0.0 )\n    {\n        vec3 tmp = v3;\n        v3 = v4;\n        v4 = tmp;\n    }\n    #endif\n\n    \n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v43 = v4 - v3; vec3 p3 = p - v3;\n    vec3 v14 = v1 - v4; vec3 p4 = p - v4;\n    vec3 nor = cross( v21, v14 );\n\n    return sqrt( (sign(dot(cross(v21,nor),p1)) + \n                  sign(dot(cross(v32,nor),p2)) + \n                  sign(dot(cross(v43,nor),p3)) + \n                  sign(dot(cross(v14,nor),p4))<3.0) \n                  ?\n                  min( min( dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                            dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                       min( dot2(v43*clamp(dot(v43,p3)/dot2(v43),0.0,1.0)-p3),\n                            dot2(v14*clamp(dot(v14,p4)/dot2(v14),0.0,1.0)-p4) ))\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor) );\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// Brute force distance to a transformed box.\nfloat udBox( vec3 p, mat3 tfm, vec3 lo, vec3 hi) {\n    float dist = 1e38f;\n    \n    // corners of the box\n    vec3 c0 = tfm * vec3(lo.x, lo.y, lo.z);\n    vec3 c1 = tfm * vec3(hi.x, lo.y, lo.z);\n    vec3 c2 = tfm * vec3(lo.x, hi.y, lo.z);\n    vec3 c3 = tfm * vec3(hi.x, hi.y, lo.z);\n    vec3 c4 = tfm * vec3(lo.x, lo.y, hi.z);\n    vec3 c5 = tfm * vec3(hi.x, lo.y, hi.z);\n    vec3 c6 = tfm * vec3(lo.x, hi.y, hi.z);\n    vec3 c7 = tfm * vec3(hi.x, hi.y, hi.z);\n    \n    dist = min(dist, udQuad( p, c0, c2, c6, c4));\n    dist = min(dist, udQuad( p, c1, c3, c7, c5));\n\n    dist = min(dist, udQuad( p, c0, c1, c5, c4));\n    dist = min(dist, udQuad( p, c2, c3, c7, c6));\n\n    dist = min(dist, udQuad( p, c0, c1, c3, c2));\n    dist = min(dist, udQuad( p, c4, c5, c7, c6));\n\n    return dist;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, vec3 cen, float rad )\n{\n    return length(p-cen)-rad;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// brute force frame which supports non-rigid transformations.\n// tfm is a transformation bringing lo and hi to the space containing \n// \"p\"\nfloat sdBoxFrame( vec3 p, mat3 tfm, vec3 lo, vec3 hi, float e )\n{\n    float d = 1e38f;\n    \n    // X\n    d = min(d, sdCapsule( p, tfm * vec3(lo.x, lo.y, lo.z), tfm * vec3(hi.x, lo.y, lo.z), e));\n    d = min(d, sdCapsule( p, tfm * vec3(lo.x, hi.y, lo.z), tfm * vec3(hi.x, hi.y, lo.z), e));\n    d = min(d, sdCapsule( p, tfm * vec3(lo.x, lo.y, hi.z), tfm * vec3(hi.x, lo.y, hi.z), e));\n    d = min(d, sdCapsule( p, tfm * vec3(lo.x, hi.y, hi.z), tfm * vec3(hi.x, hi.y, hi.z), e));\n    \n    // Y\n    d = min(d, sdCapsule( p, tfm * vec3(lo.x, lo.y, lo.z), tfm * vec3(lo.x, hi.y, lo.z), e));\n    d = min(d, sdCapsule( p, tfm * vec3(hi.x, lo.y, lo.z), tfm * vec3(hi.x, hi.y, lo.z), e));\n    d = min(d, sdCapsule( p, tfm * vec3(lo.x, lo.y, hi.z), tfm * vec3(lo.x, hi.y, hi.z), e));\n    d = min(d, sdCapsule( p, tfm * vec3(hi.x, lo.y, hi.z), tfm * vec3(hi.x, hi.y, hi.z), e));\n    \n    // Z\n    d = min(d, sdCapsule( p, tfm * vec3(lo.x, lo.y, lo.z), tfm * vec3(lo.x, lo.y, hi.z), e));\n    d = min(d, sdCapsule( p, tfm * vec3(hi.x, lo.y, lo.z), tfm * vec3(hi.x, lo.y, hi.z), e));\n    d = min(d, sdCapsule( p, tfm * vec3(lo.x, hi.y, lo.z), tfm * vec3(lo.x, hi.y, hi.z), e));\n    d = min(d, sdCapsule( p, tfm * vec3(hi.x, hi.y, lo.z), tfm * vec3(hi.x, hi.y, hi.z), e));\n    \n    return d;\n}\n\n//------------------------------------------------------------\n\n\nvec2 map( in vec3 pos, bool showSurface, in vec3 samplePoint )\n{\n\n    // compute closest point to gPoint on the surace of the box\n    //vec3 closestPoint = closestPointToBox(samplePoint, box_rad );\n    // vec3 qpo, mat3 G, mat3 GInv, vec3 lo, vec3 hi\n    mat3 G = transpose(tfm) * tfm;\n    mat3 GInv = inverse(G);\n    DebugData dbg;\n    vec3 closestPoint = tfm * closestPointToTransformedBox(inverse(tfm) * samplePoint, G, GInv, -box_rad, box_rad, dbg);\n    \n    // point\n    vec2 res = vec2( sdSphere( pos, samplePoint, 0.06 ), 1.0 );\n    \n    // closest point\n    {\n    float d = sdSphere( pos, closestPoint, 0.06 );\n    if( d<res.x ) res = vec2( d, 4.0 );\n    }\n    \n    // box (semi-transparent)    \n    if( showSurface )\n    {\n    //float d = sdBox( pos, box_rad );\n    float d = udBox( pos, tfm, -box_rad, box_rad);    \n    if( d<res.x ) res =  vec2( d, 5.0 );\n    }\n\n    // segment\n    {\n    float d = sdCapsule( pos, samplePoint, closestPoint, 0.015 );\n    if( d<res.x ) res =  vec2( d, 4.0 );\n    }\n    \n    // debug\n    if (false) {\n    \n    {\n    float d = sdSphere( pos, dbg.pt1, 0.06 );\n    if( d<res.x ) res = vec2( d, 2.0 );\n    }\n    \n    {\n    float d = sdCapsule( pos, dbg.seg1, dbg.seg2, 0.02 );\n    if( d<res.x ) res =  vec2( d, 0.0 );\n    }\n    \n    {\n    float d = sdCapsule( pos, dbg.seg3, dbg.seg4, 0.02 );\n    if( d<res.x ) res =  vec2( d, 0.0 );\n    }\n   \n    }\n\n    // box edges\n    {\n    float d = sdBoxFrame( pos, tfm, -box_rad, +box_rad, 0.01 );\n    if( d<res.x ) res =  vec2( d, 5.0 );\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in bool showSurface, in vec3 samplePoint )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 1e-6;//0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps, showSurface, samplePoint ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps, showSurface, samplePoint ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps, showSurface, samplePoint ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps, showSurface, samplePoint ).x );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftShadow( vec3 ro, vec3 rd, bool showSurface, in vec3 samplePoint )\n{\n    float res = 1.0;\n    const float tmax = 2.0;\n    float t = 0.001;\n    for( int i=0; i<64; i++ )\n    {\n     \tfloat h = map(ro + t*rd, showSurface, samplePoint).x;\n        res = min( res, 64.0*h/t );\n    \tt += clamp(h, 0.01,0.5);\n        if( res<-1.0 || t>tmax ) break;\n        \n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep, in [-1,1]\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord)*AA + ivec2(m,n);\n        // time sample\n        float td = 0.5+0.5*sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1);\n        float time = iTime - 0.5*(1.0/60.0)*(td+float(m*AA+n))/float(AA*AA-1);\n        #else    \n        // pixel coordinates\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord);\n        // time sample\n        float time = iTime;\n        #endif\n\n        // animate camera\n        float an = 0.25*time + 6.283185*iMouse.x/iResolution.x;\n        vec3 ro = vec3( 2.4*cos(an), 0.7, 2.4*sin(an) );\n        vec3 ta = vec3( 0.0, -0.15, 0.0 );\n\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.2,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n\n        // animate point\n        vec3 samplePoint = -sin(time*0.8*vec3(1.0,1.1,1.2)+vec3(4.0,2.0,1.0));\n\n        // animate transformation\n        tfm[1][0] = .5 * sin(time);\n        tfm[2][0] = .5 * sin(time*1.3);\n        tfm[2][1] = .5 * sin(time*1.7);\n\n        // make box transparent\n      //bool showSurface = ((samp.x+samp.y)&1)==0;     // 50% opaque\n        bool showSurface = ((samp.x&1)+(samp.y&1))!=0; // 75% opaque\n\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raycast\n        const float tmax = 5.0;\n        float t = 0.0;\n        float m = -1.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            vec2 hm = map(pos,showSurface, samplePoint);\n            m = hm.y;\n            if( hm.x<0.0001 || t>tmax ) break;\n            t += hm.x;\n        }\n    \n        // shade background\n        vec3 col = vec3(0.05)*(1.0-0.2*length(p));\n        \n        // shade objects\n        if( t<tmax )\n        {\n            // geometry\n            vec3  pos = ro + t*rd;\n            vec3  nor = calcNormal(pos,showSurface, samplePoint);\n\n            // color\n            vec3  mate = 0.55 + 0.45*cos( m + vec3(0.0,1.0,1.5) );\n            // show distance isolines\n            if( abs(m-5.0)<0.5 )\n            {\n                float dref = udBox( samplePoint, tfm, -box_rad, box_rad );\n                float dsam = length(pos-samplePoint);\n                mate += smoothstep(0.8,0.9,sin((dsam-dref)*80.0))*exp2(-12.0*(dsam-dref)*(dsam-dref));\n            }\n                        \n            // lighting\t\n            col = vec3(0.0);\n            {\n              // key light\n              vec3  lig = normalize(vec3(0.3,0.7,0.2));\n              float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n              if( dif>0.001 ) dif *= calcSoftShadow(pos+nor*0.001,lig,showSurface, samplePoint);\n              col += mate*vec3(1.0,0.9,0.8)*dif;\n            }\n            {\n              // dome light\n              float dif = 0.5 + 0.5*nor.y;\n              col += mate*vec3(0.2,0.3,0.4)*dif;\n            }\n        }\n\n        // gamma        \n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"","name":"Common","description":"","type":"common"}]}