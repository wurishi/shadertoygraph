{"ver":"0.1","info":{"id":"3ddGDB","date":"1569242485","viewed":136,"name":"Case study : Slik","username":"MonsieurSoleil","description":"I was looking for something else....","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["glow","kifs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\t\tDO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE\n                   Version 2, December 2004\n\nCopyright (C) 2004 Sam Hocevar <sam@hocevar.net>\n\nEveryone is permitted to copy and distribute verbatim or modified\ncopies of this license document, and changing it is allowed as long\nas the name is changed.\n\n           DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE\n  TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n 0. You just DO WHAT THE FUCK YOU WANT TO.\n*/\n\n#define NUM_LOOP 100\n#define MIN_MAT 0.01\n#define PI 3.14159265\n\nmat2 rot (float a)\n{\n  return\n  mat2(cos(a),\n  sin(a),\n  -sin(a), cos(a));\n}\n\n\n// Found here : http://mercury.sexy/hg_sdf/\nvec2 pModPolar(vec2 p, float repetitions, out float c) {\n\tfloat angle = (2.0*PI)/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tc = floor(a/angle);\n    \n\ta = mod(a,angle) - angle/2.;\n\t\n\tp = vec2(cos(a), sin(a))*r;\n\t\t\n\treturn p;\n}\n\nfloat sdSphere(vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\nvec3 rep(vec3 p, vec3 s)\n{\n \treturn (fract(p/s + 0.5) -0.5) *s;   \n}\n\nvec2 rep(vec2 p, vec2 s)\n{\n \treturn (fract(p/s + 0.5) -0.5) *s;   \n}\n\nfloat rep(float p, float s)\n{\n \treturn (fract(p/s + 0.5) -0.5) *s;   \n}\n\n// Nusan Code.\nvec3 kifs(vec3 p, float t)\n{\n\tvec2 s = vec2(5.0, 6.5);\n\tfor(int i = 0; i < 15; ++i)\n\t{\n\t\tp.xy *= rot(t);\n\t\tp.xy = abs(p.xy) - s;\n\t\ts *= vec2(0.01, 0.01);\n\t}\n\n\treturn p;\n}\n\nvec3 kifs02(vec3 p, float t)\n{\n\tvec2 s = vec2(2.0, 4.5);\n\tfor(int i = 0; i < 15; ++i)\n\t{\n\t\tp.yz *= rot(t);\n\t\tp.yz = abs(p.xy) - s;\n\t\ts *= vec2(0.05, 0.05);\n\t}\n\n\treturn p;\n}\n\n\nvec2 map(vec3 p)\n{\n    vec2 result = vec2(sdSphere(p, 0.0001), 0.001);\n    \n    p.z -= sin(p.x * 0.05) * 55.0 * cos(0.1*0.001);\n    p.x -= sin(p.y * 0.02) * 15.0 * cos(0.0*0.005);\n    p.y *= sin(p.z * 0.01) * 2.0 * (iTime+450.0)*0.002;\n    p.x *= sin(p.y * 0.005) * 2.0 * cos(iTime*0.005);\n    \n    p = kifs(p, 3.0 * cos(0.0 * 0.005));\n    p = kifs02(p, 6.0);\n    vec3 p2 = p;\n    vec3 p3 = p + vec3(0.0, 0.0, 0.0);\n    \n    //Not Used\n    float c = 1.0;\n    \n    p2.xz = pModPolar(p.xz, 256.0, c);\n    p2.y = rep(p2.y, 1.0);\n    p2 -= vec3(10,0,0);\n    \n    \n    for(int i = 0; i < 2; ++i)\n    {\n        p2.x += float(i)*5.0;\n        result.x = min(result.x, sdSphere(p2,0.0001));\n    }\n    \n    return result;\n}\n\n// Nusan / Leon denise.\nvec3 look (vec3 eye, vec3 target, vec2 anchor) {\n    vec3 forward = normalize(target-eye);\n    vec3 right = normalize(cross(forward, vec3(0,1,0)));\n    vec3 up = normalize(cross(right, forward));\n    return normalize(forward + right * anchor.x + up * anchor.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1.0);\n    \n    vec3 col = vec3(0.0);\n    \n    vec3 pos = vec3(cos(1.5) * 225.0, 500.0, sin(1.5) * 225.0);\n    vec3 at = normalize(vec3(0.0, 0.0, 0.0));\n    vec3 dir = look(pos, at, uv);\n    \n    vec3 p = pos;\n    float glow = 0.0;\n    float dist = 0.0; vec2 mat = vec2(0.0);\n    for(int i = 0; i < NUM_LOOP; ++i)\n    {\n        mat = map(p);\n        \n        // Glow found with flopine shaders\n        if(mat.x < 0.5)\n        \tglow += 0.01/0.1+(mat.x*mat.x);\n        \n        if(mat.x <= MIN_MAT)\n        {\n         \tdist = 1.0 - (float(i) / float(NUM_LOOP));\n            break;\n        }\n        \n        p += mat.x * dir * 0.35;\n    }\n   \n    // damn I love this color :D.\n    col += mix(vec3(0.9, 0.5, 0.0) * 1.6 , vec3(0.0, 0.4, 1.0) * 1.2, glow * 0.07) * glow * 0.10;\n\t\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}