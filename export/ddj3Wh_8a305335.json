{"ver":"0.1","info":{"id":"ddj3Wh","date":"1667570670","viewed":104,"name":"Sin approximation (Chebyshev)","username":"Envy24","description":"https://en.wikipedia.org/wiki/Chebyshev_polynomials\nOther: https://www.shadertoy.com/view/NtVBWG","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["approximation","interpolation","polynomial","chebychev"],"hasliked":0,"parentid":"NsyBW1","parentname":"Chebyshev Approximation"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define UNIT                      (  8.0 / R.y  )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define PI                          3.1415926535897932\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat draw_func(vec2 NDC, float f, float dfdx)\n{\n    float df   = NDC.y - f;\n    return SMAA(abs(df) / sqrt(1.0 + dfdx * dfdx));\n}\n\n/* Chebyshev polynomials of first kind by lookup table. *\nfloat T(int k, float x)\n{\n    switch (k)\n    {\n    case 0: return 1.;\n    case 1: return x;\n    case 2: return 2.*x*x-1.;\n    case 3: return (4.*x*x-3.)*x;\n    case 4: return (8.*x*x-8.)*x*x+1.;\n    case 5: return ((16.*x*x-20.)*x*x+5.)*x;\n    case 6: return ((32.*x*x-48.)*x*x+18.)*x*x-1.;\n    case 7: return (((64.*x*x-112.)*x*x+56.)*x*x-7.)*x;\n    case 8: return (((128.*x*x-256.)*x*x+160.)*x*x-32.)*x*x-1.;\n    }\n}\n/* Chebyshev polynomials of first kind by reccurent formula. */\nfloat T(int k, float x)\n{\n    float T_p = x, T_pp = 1.;\n    \n    if (k == 0) { return T_pp; }\n    else if (k == 1) { return T_p; }\n    \n    float T = 2.*x*T_p - T_pp;\n    for (int i = 3; i <= k; ++i)\n    {\n        T_pp = T_p;\n        T_p = T;\n        T = 2.*x*T_p - T_pp;\n    }\n    \n    return T;\n}\n/* Chebyshev polynomials of second kind by reccurent formula (for derivative). */\nfloat U(int k, float x)\n{\n    float U_p = 2.*x, U_pp = 1.;\n    \n    if (k == 0) { return U_pp; }\n    else if (k == 1) { return U_p; }\n    \n    float U = 2.*x*U_p - U_pp;\n    for (int i = 3; i <= k; ++i)\n    {\n        U_pp = U_p;\n        U_p = U;\n        U = 2.*x*U_p - U_pp;\n    }\n    \n    return U;\n}\n\n/* Function that you want to approximate. */\n#define func(x)  ( sin(x) )\n#define deriv(x) ( cos(x) )\nconst int order = clamp(12,    1, 30); /* Order of Chebyshev polynomial */\nconst float n = float(order - 1);     /* Degree of Chebyshev polynomial */\nfloat X[order], Y[order],             /* xi=Chebyshev nodes, yi=f(xi) */\n      C[order];                       /* Coefficients of Chebyshev approxamation polynomial */\n\nvoid calculate_coefs(\n    inout float X[order],\n    inout float Y[order],\n    inout float C[order],\n    float a,\n    float b)\n{\n    for (float i = 0.; i <= n; i += 1.)\n    {\n        // Calculate root of Chebyshev polynomial.\n        X[int(i)] = (a+b)*0.5 + (b-a)*0.5*cos((2.*i+1.)*PI/(2.*n+2.));\n        \n        // Evaluate function at root.\n        Y[int(i)] = func(X[int(i)]);\n    }\n    \n    // Calculate coefficients.\n    for (float i = 0.; i <= n; i += 1.)\n    {\n        float sum = 0.0;\n           \n        for (float j = 0.; j <= n; j += 1.)\n        {\n            sum += Y[int(j)] * cos((2.*j+1.)*i*PI/(2.*n+2.));\n        }\n        \n        C[int(i)] = (2./(n + 1.))*sum;\n    }\n}\n\n/* Evaluate Chebyshev approxamation polynomial. */\nfloat evalT(float t, float a, float b, int n, float c[order])\n{\n    float v = c[0]*0.5;\n    \n    for (int k = 1; k <= n; ++k)\n    {\n        v += c[k] * T(k, (2.*t-a-b)/(b-a));\n    }\n    \n    return v;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = \n        LMB_IS_HOLD ?\n            2.5*(TO_CENTERED_NDC(SC-(iMouse.xy-R.xy*0.5))) :\n            2.5*(TO_CENTERED_NDC(SC));\n\n     float scale = 1.0;\n\n    vec3 color = vec3(1.);\n         color.rb -= draw_func(NDC, scale*func(NDC.x), scale*deriv(NDC.x));\n         color -= x_axis(NDC); color -= y_axis(NDC);\n\n    float a = -PI, b = PI;\n    \n    // Can be precalculated.\n    calculate_coefs(X, Y, C, a, b);\n    \n    /* Point samples. */\n    float N = 20., dt = (b-a)/ (N-1.);\n    for (float i=0.; i < N; i+=1.)\n    {\n        float t = a + i * dt,\n              f = scale*evalT(t, a, b, int(n), C);\n        color = mix(color, vec3(1, 0, 0), SMAA(diskSDF_L2(NDC, vec2(t, f), 0.03)));\n    }\n    /* Approximation curve. */\n    float dx = 0.1, error_scale = 1e6,\n          // Approximation.\n          f  = scale * evalT(NDC.x, a, b, int(n), C),\n          fn = scale * evalT(NDC.x+dx, a, b, int(n), C),\n          // Error.\n          s = ((scale * sin(NDC.x)) - f) * error_scale,\n          sn = ((scale * sin(NDC.x+dx)) - fn) * error_scale;\n          \n          //f += s; fn += sn; // show approximation distortion.\n          \n    color.rg -= draw_func(NDC, f, (fn-f)/dx);\n    color = mix( color, vec3(1,0,1), draw_func(NDC, s, (sn-s)/dx) );\n    /* */\n\n    color -= vertical_line(NDC, -PI) * 0.5; color -= vertical_line(NDC, PI) * 0.5;\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0));\n}","name":"Common","description":"","type":"common"}]}