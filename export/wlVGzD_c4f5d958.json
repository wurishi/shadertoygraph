{"ver":"0.1","info":{"id":"wlVGzD","date":"1578450847","viewed":63,"name":"3d ray-intersection intersection","username":"16807","description":"Distance field to the CSG intersection of two spheres. The code provides functions to calculate the distance to any shape formed from constructive solid geometry, and works in both 2d and 3d. Click the screen to rotate.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","intersection","csg","analytic","minimal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define IN(T) in T\n#define INOUT(T) inout T\n#define OUT(T) out T\n#define CONST(T) const T\n#define VAR(T) T\n#define FUNC(T) T\n\n#define BIG 1e10\n#define PI 3.1415926\n\nFUNC(bool) try_distances_along_line_intersecting_negation(\n    IN(bool) is_intersection1, IN(float) entrance1, IN(float) exit1, \n    IN(bool) is_intersection2, IN(float) entrance2, IN(float) exit2,\n    OUT(float) entrance,\n    OUT(float) exit\n) {\n    if (!is_intersection1)\n    {\n      return false;\n    }\n    entrance = is_intersection2 || entrance1 < entrance2 ? entrance1 : max(exit2,     entrance1);\n    exit     = is_intersection2 || exit1     < exit2     ? exit1     : max(entrance2, exit1    );\n    return !is_intersection2 || entrance1 < entrance2 || exit2 < exit1;\n}\n\nFUNC(bool) try_distances_along_line_intersecting_union(\n    IN(bool) is_intersection1, IN(float) entrance1, IN(float) exit1, \n    IN(bool) is_intersection2, IN(float) entrance2, IN(float) exit2,\n    OUT(float) entrance,\n    OUT(float) exit\n) {\n    entrance = !is_intersection1 ? entrance2 : !is_intersection2 ? entrance1 : min(entrance1, entrance2);\n    exit     = !is_intersection1 ? exit2     : !is_intersection2 ? exit1     : max(exit1,     exit2    );\n    return is_intersection1 || is_intersection2;\n}\n\nFUNC(bool) try_distances_along_line_intersecting_intersection(\n    IN(bool) is_intersection1, IN(float) entrance1, IN(float) exit1, \n    IN(bool) is_intersection2, IN(float) entrance2, IN(float) exit2,\n    OUT(float) entrance,\n    OUT(float) exit\n) {\n    entrance = is_intersection1 && is_intersection2 ? max(entrance1, entrance2) : 0.f;\n    exit     = is_intersection1 && is_intersection2 ? min(exit1,     exit2    ) : 0.f;\n    return is_intersection1 && is_intersection2 && entrance < exit;\n}\n\n\n\nFUNC(bool) try_distances_along_3d_line_intersecting_sphere(IN(vec3) A0, IN(vec3) A, IN(vec3) B0, IN(float) r, OUT(float) entrance, OUT(float) exit){\n    float xz = dot(B0-A0, A);\n    float z  = length(A0+A*xz - B0);\n    float y2  = r*r-z*z;\n    float dxr = sqrt(max(y2, 1e-10));\n    entrance = xz - dxr;\n    exit     = xz + dxr;\n    return y2 > 0.;\n}\n\n\nmat4 get_rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4  projection_matrix_inverse = (mat4(0.5,0,0,0,0,0.3,0,0,0,0,0,-50,0,0,-1,50));\n    mat4  view_matrix_inverse = (get_rotation_matrix(vec3(0,1,0), iMouse.x * -0.01 + 0.1*iTime) * mat4(0.707, 0, 0.707, 0, 0.235, 0.942, -0.235, 0, -0.666, 0.333, 0.666, 0, -4, 2, 4, 1));\n    float reference_distance = 0.5f;//6.367e6;\n    \n    vec2  screenspace    = fragCoord/iResolution.xy;\n    vec2  clipspace      = 2.0 * screenspace - 1.0;\n    vec3  view_direction = normalize(view_matrix_inverse * projection_matrix_inverse * vec4(clipspace, 1, 1)).xyz;\n    vec3  view_origin    = view_matrix_inverse[3].xyz * reference_distance;\n    \n    //float intersect = sphIntersect(cameraPosition, ray, vec4(0.0, 0.0, 0.0, 1.0));\n    float a_in, a_out; bool a_hits = try_distances_along_3d_line_intersecting_sphere(view_origin, view_direction, vec3(0.5,0.5,0), 0.6f, a_in, a_out);\n    float b_in, b_out; bool b_hits = try_distances_along_3d_line_intersecting_sphere(view_origin, view_direction, vec3(0.5,-0.5,0)*cos(iTime), 1.0f, b_in, b_out);\n    float c_in, c_out; bool c_hits = try_distances_along_line_intersecting_intersection(a_hits,a_in,a_out, b_hits,b_in,b_out, c_in,c_out);\n    vec3  color = vec3(0);\n    if (c_hits)\n    {\n        color = vec3(c_in/3.f);\n    }\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}