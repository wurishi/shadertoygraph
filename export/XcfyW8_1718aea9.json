{"ver":"0.1","info":{"id":"XcfyW8","date":"1721044329","viewed":12,"name":"Viral Replication (Projet POGL)","username":"Oscartichaud","description":"click on the screen to add cells","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["vrf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float cell_state = texture(iChannel0, fragCoord/(iResolution.xy * scale)).r;\n    \n    if (cell_state > (q - 0.5))\n    {\n        fragColor = white;\n    }\n    else if (cell_state > 1.5)\n    {\n        float val = cell_state / q;\n        fragColor = mix(white, black, val);\n    }\n    else if (cell_state > 0.5)\n    {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n    else\n    {\n        fragColor = black;\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Random function generator from https://www.shadertoy.com/view/Nsf3Ws\n//////////////////////////////////////////////////////////////////////\nuint seed = 0u;\nvoid hash(){\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n}\nvoid initRandomGenerator(vec2 fragCoord){\n    seed = uint(fragCoord.y*iResolution.x + fragCoord.x)+uint(iFrame)*uint(iResolution.x)*uint(iResolution.y);\n}\n\nfloat random(){\n    hash();\n    return float(seed)/4294967295.0;\n}\n/////////////////////////////////////////////////////////////////////\n\n// Function to generate a float with a Gaussian distribution centered at 1\nfloat generateGaussian(float u1, float u2) {\n    // Box-Muller method to generate two Gaussian numbers\n    float radius = sqrt(-2.0 * log(u1));\n    float theta = 2.0 * 3.141592653589793 * u2;\n    float z0 = radius * cos(theta);\n    float z1 = radius * sin(theta);\n\n    // Adjust to center at 1\n    float result = 0.5 * z0 + 1.0;\n\n    return result;\n}\n\n// Function to generate the degeneration factor of the cell (between 0.0 and 2.0)\nfloat get_random_degeneration()\n{\n    float u1 = random();\n    float u2 = random();\n    float x = generateGaussian(u1, u2);\n    x = clamp(x, 0.0, 2.0);\n    return x;\n}\n\nfloat sample_tex(vec2 uv, float i, float j)\n{\n    vec2 delta_ij = vec2(i,j) / iResolution.xy;\n    float val = texture(iChannel0, uv + delta_ij).r;\n    if (val > 0.0)\n    {\n        return val;\n    }\n    return 0.0;\n}\n\nvec2 count_neighbours(vec2 uv)\n{\n    vec2 count = vec2(0.0, 0.0);\n    for (int i=-1; i <= 1; i += 1)\n    {\n        for (int j=-1; j <= 1; j += 1)\n        {\n            if ((i != 0) || (j != 0))\n            {\n                float val = sample_tex(uv, float(i), float(j));\n                if (val > (q - 0.5)) // Healthy neighbour cell\n                {\n                    count = count + vec2(1.0, 0.0);\n                }\n                else if ((val > 0.5) && (val < 1.5)) // Dying neighbour cell\n                {\n                    count = count + vec2(0.0, 1.0);\n                }\n            }\n        }\n    }\n    return count;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initRandomGenerator(fragCoord);\n    \n    vec2 size = iResolution.xy;\n    vec2 uv = fragCoord / size;\n    \n    if (iFrame == 0)\n    {\n        fragColor = dead;\n    }\n    else\n    {\n        vec4 val = texture(iChannel0, uv);\n        \n        int frame = iFrame % gen_nb_frames;\n        if (frame == 0)\n        {\n            float cell = val.r;\n            \n            if (cell > (q - 0.5)) // Current cell is healthy\n            {\n                if (random() < base_rate) // Small chance that the cell becomes initially infected\n                {\n                    // Starts the degeneration\n                    fragColor = id(cell - get_random_degeneration());\n                }\n                else\n                {\n                    // Count the number of dying cells in the neighbours\n                    int nb_dying_neighbours = int(count_neighbours(uv)[1]);\n                    // The probability that at least one dying neighbours will infect the current cell\n                    float prob = 1.0 - pow((1.0 - active_rate), float(nb_dying_neighbours));\n                    if (random() < prob) // The current cell becomes infected\n                    {\n                        // Starts the degeneration\n                        fragColor = id(cell - get_random_degeneration());\n                    }\n                    else // The current cell stays healthy\n                    {\n                        fragColor = healthy;\n                    }\n                }\n            }\n            else if ((cell < (q - 0.5)) && (cell > 0.5)) // Current cell is infected\n            {\n                // Continue the degeneration\n                fragColor = id(cell - get_random_degeneration());\n            }\n            else // Current cell is dead\n            {\n                // Count the number of living cells in the neighbours\n                int nb_neighbours = int(count_neighbours(uv)[0]);\n                // The probability that at least one of these neighbouring cells will replicate on the current cell\n                float prob = 1.0 - pow((1.0 - cell_div_rate), float(nb_neighbours));\n                if (random() < prob)\n                {\n                    // Replication of a neighbouring cell\n                    fragColor = healthy;\n                }\n                else\n                {\n                    // Nothing changes, the cell is still dead\n                    fragColor = dead;\n                }\n            }\n        }\n        else\n        {\n            fragColor = val;\n        }\n    }\n    \n    if (iMouse.z > 0.0 && distance(iMouse.xy, fragCoord * scale) < brush_radius)\n    {\n        // Create healthy cells with the mouse click\n        fragColor = healthy;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Global variables and utils\n\nfloat scale = 1.0;\nint gen_nb_frames = 1;\n\n#define healthy vec4(q, q, q, 1.0)\n#define dead vec4(0.0, 0.0, 0.0, 1.0)\n#define id(val) vec4(val, val, val, 1.0)\n\n#define brush_radius 40.0\n\n#define white vec4(1.0, 1.0, 1.0, 1.0)\n#define black vec4(0.0, 0.0, 0.0, 1.0)\n\n// Viral Replication variables\n\n#define q 7.0\n\n#define base_rate 0.000002\n\n#define active_rate 0.6\n\n#define cell_div_rate 0.1","name":"Common","description":"","type":"common"}]}