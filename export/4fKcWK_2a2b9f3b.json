{"ver":"0.1","info":{"id":"4fKcWK","date":"1732393414","viewed":115,"name":"purple star","username":"nayk","description":"originals  https://www.shadertoy.com/view/lfycz3 and Star nest","likes":3,"published":3,"flags":1,"usePreview":0,"tags":["fractal","stars","universe"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define iterations 13\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam;\n            p.xy*=mat2(cos(iTime*0.01),sin(iTime*0.01),-sin(iTime*0.01), cos(iTime*0.01));// the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.2-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.02,1.);\t\n}\nfloat drawLine(vec2 start,vec2 end,vec2 uv,float t_b,float t_e)\n{\n    vec2 direction = normalize(end-start);\n    vec2 uv_to_start = uv-start;\n    float projection = clamp(dot(uv_to_start,direction),0.0,length(end-start));\n    vec2 close = start+projection*direction;\n    float dist = length(uv-close);\n    float thick = t_b + (projection/length(start-end))*(t_e-t_b);\n    return smoothstep(thick,thick-0.03,dist);\n}\nvec2 hash2( float n ){return fract(sin(vec2(n,n+1.0))*vec2(432.14159,528.14159));}\n\nconst vec2 randConst = vec2(432.14159, 528.14159);\nconst float randMultiplier = 3.14159;\nfloat rand(const vec2 co) {\n    return fract(sin(co.x * randConst.x + co.y * randConst.y) * randMultiplier);}\n\nfloat custom_smoothstep(float edge0, float edge1, float x) {\n    float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    return t * t * (3.0 - 2.0 * t);}\n\nfloat noise(in vec2 x){\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    vec2 n = p + vec2(2.5, -2.5);\n    float a = mix(rand(n), rand(n + vec2(1.0, 0.0)), f.x);\n    float b = mix(rand(n + vec2(0.0, 1.0)), rand(n + vec2(1.0, 1.0)), f.x);\n    return mix(a, b, f.y);}\n\nvec2 turbulence(vec2 p, float t, float scale){\n    float sum = 0.1;\n    float freq = scale;\n    float smoothness;\n    vec2 noise_coord;\n    for (int i = 0; i < 5; i++){\n        smoothness = custom_smoothstep(0.0, 10.0, float(i));\n        noise_coord = vec2(p + t * 0.25) + vec2(cos(float(i) * 0.5), sin(float(i) * 0.5)) * smoothness;\n        sum += abs(noise(noise_coord)) / freq;\n        freq *= 0.25;}\n    return vec2(sum, sum) * 0.1;}\n\nmat2 mtx = mat2( 0.87,  0.5, -0.5,  0.87 );\n\nfloat fbm( vec2 p ){\n    float f = 0.05;\n    f += 0.950000*noise( p ); p = mtx*p*3.0;\n    f += 0.200000*noise( p ); p = mtx*p*2.0;\n    f += 0.100000*noise( p ); p = mtx*p*2.0;\n    f += 0.050000*noise( p ); p = mtx*p*2.0;\n    f += 0.025000*noise( p ); p = mtx*p*1.0;\n    f += 0.005000*noise( p );\n    p = mtx*p*2.0;\n    f += 0.004*noise( p );\n    p = mtx*p*2.0;\n    f += 0.002*noise( p );\n    return f/0.95000;}\n\nfloat pattern(in vec2 p, in float t, in vec2 uv, out vec2 q, out vec2 r, out vec2 g) {\n    float s = dot(uv + 0.5, uv + 0.5);\n    float iMelty = 50.0, iFlowing = 10.0;\n    float l = custom_smoothstep(0.0, iMelty, sin(t * iFlowing));\n    q = mix(vec2(fbm(p + vec2(t * 1. + sin(t), t * 0.2 + cos(t))),\n                 fbm(p + vec2(t * 0.5 + sin(t + 0.5), t * 0.5 + cos(t + 1.5)))),\n            vec2(fbm(p), fbm(p + vec2(10.5, 1.5))),\n            l);\n    r = mix(vec2(fbm(p + 3.14159 * q + vec2(t * 0.25 + sin(t * 0.25), t * 0.25 + cos(t * 0.50)) + vec2(1.5, 10.5)),\n                 fbm(p + 2.0 * q + vec2(t * 0.5 + sin(t * 0.3), t * 0.4 + cos(t * 0.9)) + vec2(8.5, 4.8))),\n            vec2(fbm(p + 5.0 * q + vec2(t) + vec2(33.66, 66.33)), fbm(p + 4. * q + vec2(t) + vec2(8.5, 2.5))),\n            l);\n    g = mix(vec2(fbm(p + 2.0 * r + vec2(t * 0.5 + sin(t * 0.5), t * 0.5 + cos(t * 0.75)) + vec2(2.5, 5)),\n                 fbm(p + 1.5 * r + vec2(t * 0.75 + sin(t * 0.25), t * 0.5 + cos(t * 0.5)) + vec2(5, 2.5))),\n            vec2(fbm(p + 2.5 * r + vec2(t * 5.0) + vec2(2, 5)), fbm(p + 2. * r + vec2(t * 11.0) + vec2(5, 2.5))),\n            l);\n    vec2 v = turbulence(p * 0.1, t * 0.1, 20.);\n    vec2 m = vec2(fbm(p * 0.5 + vec2(t * 0.9, t * 0.9) + v * 0.5),\n                  fbm(p * 0.5 + vec2(t * 0.9, t * 0.9) + v * 0.5));\n    return mix(fbm(p + 2.5 * g + vec2(-t * 0.75 + sin(t * 0.5), -t * 0.5 + cos(t * 0.25)) + v * 2.5 + m * 0.25),\n               fbm(p + 5.0 * g + vec2(-t * 5.0) + v * 2.5),\n               l);}\n\nvec3 clamp_dots(vec3 color, float lower, float upper){\n    if(color.x < lower){\n        color.x = 0.0;\n    }\n    if(color.y < lower){\n        color.y = 0.0;\n    }\n    if(color.z < lower){\n        color.z = 0.0;\n    }\n    float avg = (color.x+color.y+color.z)/3.0;\n    return vec3(avg,avg,avg);\n}\n\n//Kinda took this portion from https://www.shadertoy.com/view/4ls3zj by public_int_i\nfloat height(in vec2 uv,in sampler2D tex,in float iTime ) {\n    return texture(tex,uv+vec2(iTime,iTime)*0.1).x;\n}\n\nconst vec2 NE = vec2(0.01,0.0);\nvec3 normal(in vec2 uv,in sampler2D tex,in float iTime) {\n    return normalize(vec3(height(uv+NE.xy,tex,iTime)-height(uv-NE.xy,tex,iTime),\n                          0.0,\n                          height(uv+NE.yx,tex,iTime)-height(uv-NE.yx,tex,iTime)));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tfloat iSmoke2 = 0.01;\n    float iSpeed2= 0.25;\n   \n    vec2 n1q, r1, g2;\n    float noise = pattern(fragCoord * vec2(iSmoke2), iTime * iSpeed2, uv, n1q, r1, g2);\n    vec3 col = mix(vec3(0.2, 0.4, 0.2), vec3(0.0, 0.25, 0.5), custom_smoothstep(0.1, 1.0, noise));\n    col = mix(col, vec3(0.4, 0.2, 0.2), dot(n1q, n1q) * 1.5);\n    col = mix(col, vec3(0.2, 0.4, 0.0), 0.25 * g2.y * g2.y);\n    col = mix(col, vec3(0.4, 0.2, 0.2), custom_smoothstep(0.2, 0.5, 1.0 * r1.g * r1.g));\n    col = mix(col, vec3(0.2, 0.4, 0.6), 0.5 * g2.x);\n    float timeScale2 = .25;\n    float xDrift2 = sin(uv.x * 3.14159 + iTime * timeScale2);\n    float yDrift2 = cos(uv.y * 3.14159 + iTime * timeScale2);\n    vec3 drift2 = vec3(xDrift2, yDrift2, -xDrift2 - yDrift2) * .1;\n    col += drift2;\n    col = mix(col, vec3(1), custom_smoothstep(0., 1., noise) * custom_smoothstep(0., 10., noise));\n    col *= noise * 2.;\n\tvec3 dir=vec3(uv*zoom,5.1);\nuv*=2.6;\n    float s = 0.0, v = 0.0;\n    vec2 uv2 = (-iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n\tfloat t = iTime*0.005;\n\tuv.x += sin(t) * .3;\n\tfloat si = sin(t*1.5); // ...Squiffy rotfloat iSmoke = 0.01;\n    float iSpeed = 0.25;\n    \n   \n\tvec3 col23 = vec3(0.0);\n\tvec3 init = vec3(0.25, 0.25 + sin(t* 0.001) * .1, t * 0.0008);\n\tfor (int r = 0; r < 100; r++) \n\t{\n\t\tvec3 p = init + s * vec3(uv, 0.143);\n\t\tp.z = mod(p.z, 2.0);\n\t\tfor (int i=0; i < 10; i++)\tp = abs(p * 2.04) / dot(p, p) - 0.75;\n\t\tv += length(p * p) * smoothstep(0.0, 0.5, 0.9 - s) * .002;\n\t\t// Get a purple and cyan effect by biasing the RGB in different ways...\n\t\tcol23 +=  vec3(v * 0.8, 1.1 - s * 0.5, .7 + v * 0.5) * v * 0.013;\n\t\ts += .01;\n\t}\n\n vec2 uv3 = fragCoord / iResolution.xy+0.5;\n    uv3*=2.1;\n    \n    \n    \n    \n    float ratio = iResolution.x/iResolution.y+.75;\n\n       \n        \n    float padding = 0.5;\n    float move_speed =1.2;\n    \n    \n    vec2 amp = vec2(0.02,0.02);\n    float frequency = 1.0;\n    vec2 scale = vec2(1.0,1.0);\n    \n    float compensate = (ratio+padding)/move_speed;\n    float delay = 3.0;\n    vec2 ball_position ;\n   \n    \n    \n    vec2 background_distortion_uv = uv3;\n    background_distortion_uv.x+= smoothstep(0.9,0.6,length(uv3 - ball_position))*amp.x*cos(frequency*iTime+uv3.y*scale.x);\n    background_distortion_uv.y+= smoothstep(0.9,0.6,length(uv3 - ball_position))*amp.y*sin(frequency*iTime+uv3.x*scale.y);\n    background_distortion_uv*=0.12;\n    vec3 background = texture(iChannel1,background_distortion_uv).xyz*0.2;\n    float t3 = iTime * 1.5;\n    vec3 color = background;\n\n    const int num = 100;\n\n    float spawn_radius = 0.35+0.13*cos(iTime);\n    float spawn_radius_rand = 0.02;\n    \n    float node_differ_radius = 0.05;\n    float differ_rand = 0.03;\n\n    float volt_thickness = 0.02;\n    float volt_thickness_rand = 0.01;\n\n    float amplitude = 1.0;\n    float amplitude_rand = 7.0;\n    float oscillation_speed = 1.5;\n    float oscillation_rand = 0.5;\n    float speed2 = 0.01;\n\n    float angular_speed = 0.09;\n    float loop_amount = 2.0;\n    float loop_length = 1.0;\n\n    vec3 purple = vec3(0.5, 0.5, 1.0) *5.1;\n    \n    vec3 lines = vec3(0.0,0.0,0.0);\n    const int max_nodes = 10;\n    float nodes_removal = 18.0;\n    \n    int seed_offset = 0;\n    for (int i = 0; i < num; i++) {\n        float seed = float(i+seed_offset) * 22008.2918;\n\n        float time_offset = fract(sin(seed) * 89007.2357) * loop_length;\n        float loop = (t + time_offset) / loop_length;\n\n        seed_offset = int(mod(loop, loop_amount));\n\n        int nodes = int(\n            float(max_nodes) -\n            fract(sin(seed) * 1227.2212) * nodes_removal\n        );\n\n        float angular_speed_i = (fract(sin(seed) * 3452.5881) - 0.5) * 2.0 * angular_speed;\n        float angle = angular_speed * t + fract(cos(seed) * 9231.124392843) * 6.2831;\n\n        float dist_to_center = spawn_radius + spawn_radius_rand * fract(sin(seed) * 6248.8572);\n        vec2 start = vec2(cos(angle), sin(angle)) * dist_to_center;\n        vec2 position = start+ball_position;\n\n        float volt_thickness_i = volt_thickness + fract(sin(seed) * 3789.01241) * volt_thickness_rand;\n        float thickness_fall_off = volt_thickness_i/float(nodes);\n        for (int j = 0; j < nodes; j++) {\n            float node_seed = float(num + j + (i * max_nodes)+seed_offset) * 3242.96291079;\n            float differ = node_differ_radius + fract(sin(node_seed) * 7452.3967) * differ_rand;\n\n            float osc_speed = oscillation_speed + fract(sin(node_seed) * 3412.4823) * oscillation_rand;\n            float amp = amplitude + fract(sin(node_seed) * 2241.6469) * amplitude_rand;\n            float age = sin(t * osc_speed);\n            vec2 move_dir = vec2(cos(fract(cos(node_seed) * 12569.01435207) * 6.2831), \n                                 sin(fract(cos(node_seed) * 12569.01435207) * 6.2831));\n\n            vec2 new_position = position +\n                                vec2(cos(fract(cos(node_seed) * 43758.5453123) * 6.2831),\n                                     sin(fract(cos(node_seed) * 43758.5453123) * 6.2831)) * differ +\n                                move_dir * speed * age * amp;\n\n            float intensity = 15.0;\n            vec3 node_color = vec3(0.3, 0.25, 5.3) * intensity*pow(length(uv-ball_position),2.0);\n\n            float lifetime_ratio = mod((t + time_offset), loop_length) / loop_length;\n            float t_b = volt_thickness_i- (float(j) * thickness_fall_off);\n            float t_e = volt_thickness_i- (float(j+1) * thickness_fall_off);\n            \n            float t_n = volt_thickness_i- (float(j+2) * thickness_fall_off);\n            lines += drawLine(\n                        position,\n                        new_position,\n                        uv,\n                        t_b,\n                        t_e\n                    ) * (1.0 - lifetime_ratio) * node_color*2.0;\n        \n            position = new_position+normalize(new_position-position)*t_n;\n\n            if (j > nodes) {\n                break;\n            }\n        }\n    }\n    float outside_purple_distance = length(uv-ball_position);\n    //outer\n    float intensity = smoothstep(1.0, 0.4, outside_purple_distance);\n    color += vec3(0.15, 0.0, 0.2)*1.0*intensity;\n    //inner\n    vec3 norm = normal(uv3-ball_position*0.5,iChannel0,iTime);\n    vec3 lightDir = normalize(vec3(10.0,15.0,5.0));\n    intensity = smoothstep(0.5, 0.2, outside_purple_distance);\n    color += vec3(0.4, 0.1, 0.6) *1.5* intensity;\n    vec3 dark_spots =(color*max(0.0,dot(lightDir,norm))*smoothstep(0.5, 0.32, outside_purple_distance))*length(uv3-ball_position);\n    norm = normal(uv3*1.0-ball_position,iChannel0,iTime);\n    vec3 spots = (color*max(0.0,dot(lightDir,norm))*smoothstep(0.5, 0.4, outside_purple_distance))*length(uv3-ball_position);\n    float spots_clamp = 0.12;\n    spots = clamp_dots(spots,spots_clamp,1.0);\n    float spot_seed = uv.x*uv.y*9224.128456104*iTime;\n    color = color + (spots*4.0*fract(sin(spot_seed)*234.948271)) - dark_spots*0.8;\n    \n    //white\n    intensity = smoothstep(0.3, 0.01, outside_purple_distance);\n    color += vec3(1.0,1.0,1.0)*1.2*intensity;\n    float e_bound = 1.0;\n\n   vec4 fragColor2 = vec4(color+lines, 1.0);\n\n\tvec3 from=vec3(1.,.5,0.5);\n\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\n    fragColor+=vec4(col*col23,1.);\n    fragColor+=fragColor2;\n}\n","name":"Image","description":"","type":"image"}]}