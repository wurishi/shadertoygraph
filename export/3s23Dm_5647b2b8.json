{"ver":"0.1","info":{"id":"3s23Dm","date":"1549287231","viewed":121,"name":"MCG: Phong shading","username":"tale3d","description":"In this lecture we discuss vectors. ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["teachingmaterial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Mathematics for Computer Graphics (CATA programme, 1st year)\n//Supplement material for the lecture \"Vectors\"\n\n//In this scene we have just one light source.\n//Belowe we set up the values for its ambient, diffuse and specular properties.\nvec3 ambient = vec3(0.05, 0.15, 0.2); //La\nvec3 diffuse = vec3(0.2, 0.6, 0.8); //Ld\nvec3 specular = vec3(1.0, 1.0, 1.0); //Ls\n\n\n//The main idea of this example: for pixels on the viewport we \"reconstruct\" \n// the sphere by setting the normal, light direction and so on to apply with Phong shading\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //////////////////////////////////////////////////////\n    //Starting the common section\n    //The lines above are the same for most of the examples. \n    //Basically it is a mapping between pixel coordinates and world coordinates.\n    //We discuss coordinates systems soon. \n    //\n    //taking pixel coordinates in the uv space, range [0,1]\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //map pixel coordinates to [-1,1]\n    vec2 c = 2.0 * uv - 1.0;\n    //adjust coordinates given an aspect ratio\n    float aspect_ratio = iResolution.x/iResolution.y;\n    c.x *= aspect_ratio;\n    \n    //The background colour is white by default\n    vec3 colour = vec3(1.0, 1.0, 1.0);\n    \n    //Setting up the light direction L\n    //Using trigonometric functions of time variable to make the light dynamic\n    //Note that sin^2(t) + cos^2(t) = 1, therefore |L| = 1, so the vector is defined as a unit vector\n    //No need to normalize it then. \n    vec3 lightDir = vec3(0.0, abs(cos(iTime)), abs(sin(iTime)));\n   \n    //Recall that we apply this function (shader) for every pixel in our viewport.\n\n    //The pixels which are not on the sphere will be skipped. \n    //Now we can check that? In the geometry we know that a sphere projects to a circle\n    //A circle is a set of points equidistant from its centre\n    //Therefore the criteria is to check the distance between the coordinates of the pixel\n    //   and the centre. \n    //For simplicity reasons the centre point is the origin (0,0,0) and the radius is 1\n\n    //The next line simply tells us \"If the distance between c and (0) is less than 1\"\n    //That means we are going to set background colour for all the points which \n    //   do not satisfy this criteria\n    float dist_squared = c.x*c.x+c.y*c.y;\n    if (dist_squared < 1.0)\n    {\n        //Now we start shading part. First, we need to find the normal. \n        // It might seem tricky, as in some way we reconstruct \n        // the normal of the point from its projection.\n        \n        //But we know that the normal for the sphere \n        // in the given point is the same vector from the centre to the point \n        // and the length of this vector is 1.\n        //The xy coordinates of the normal are the same as the pixel coordinates,\n        // so we only need to find z, knowing that x*x+y*y+z*z=1\n        float nz = sqrt(1.0 - dist_squared);\n        \n        vec3 n = vec3(c.x, c.y, nz);\n        \n        //how about viewer? this vector is constant for all the pixels and points towards us\n\t\tvec3 v = vec3(0.0,0.0,-1.0);\n        \n        //one more vector we need to define is a reflection\n        //we are using unit vectors for n and l, so the equation becomes simple as\n        //r = l - 2(n.l)n\n        vec3 r = lightDir - n*2.0*dot(lightDir, n);\n        float rd = sqrt(r.x*r.x+r.y*r.y+r.z*r.z);\n        if (rd != 0.0) r /= rd;\n            \n        //ambient component is simple as colour times coefficient\n        float ka = 1.0;\n\t\tvec3 ia = ambient*ka;\n        \n        //diffuse component, we use dot product between light source and normal\n        float kd = 1.0;\n        vec3 id = diffuse*kd*dot(lightDir, n);\n        \n        //specular component, we use power of the dot product between viewer and reflection\n        float ks = 0.2;\n        float shininess = 64.0;\n//        float ref = clamp(pow(dot(r, v), shininess), -1.0, 1.0);\n\n\t\t//pow function does not work on older machines, so if you see wrong picture, comment the line above and uncomment below\n        float rdotv = dot(r, v);\n        float ref = rdotv*rdotv*rdotv*rdotv;\n        ref = ref*ref*ref*ref;\n\n        vec3 is = specular*ks*ref;\n        \n        //the final colour is a sum of three components\n        colour = ia+id+is;\n    }\n    //assign colour to the pixel\n\tfragColor = vec4(colour, 1.0);\n}\n\n\n\n","name":"Image","description":"","type":"image"}]}