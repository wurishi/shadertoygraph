{"ver":"0.1","info":{"id":"lXlSDX","date":"1710102432","viewed":146,"name":"Dykstra's Projection Algorithm","username":"chronos","description":"Computes the projection of a point to the intersection of convex sets.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","intersection","convex","projection","iterative","algorithm","dykstra"],"hasliked":0,"parentid":"lXsSWX","parentname":"SDF Interior Distance (wrong)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n\n    Dykstra's Projection Algorithm by chronos\n    \n    See: https://en.wikipedia.org/wiki/Dykstra%27s_projection_algorithm\n    \n    ---------------------------------------------------------\n    \n    Forked from \"SDF Interior Diststance\" by iq\n        https://www.shadertoy.com/view/lXsSWX\n    \n    ---------------------------------------------------------\n\n\n    Edit: Found another shader that has implemented this already:\n        https://www.shadertoy.com/view/MdVfWV by TinyTexel\n*/\n\n\n// Note that this is not \"Dijkstra's algorithm\" by Edsger W. Dijkstra, but is named after Richard L. Dykstra.\n\n\n\n// Math based on https://www.shadertoy.com/view/slGyWt\n// Visualization by https://www.shadertoy.com/view/M3fXDf\n\n\nfloat sdSegment( in vec2 p, vec2 a, vec2 b)\n{\n    p-=a; b-=a;\n    float h = clamp(dot(p,b)/dot(b,b), 0.0, 1.0);\n    return length(p-h*b);\n}\n\nvec3 sdgCircle( in vec2 p, in vec2 c, in float r ) \n{\n    p -= c;\n    float l = length(p);\n    return vec3( l-r, p/l );\n}\n\nvec2 projdisc(vec2 p, vec2 c, float r)\n{\n    if(length(p-c) < r) return p;\n    \n    return normalize(p-c) * r + c;\n}\n\nfloat cro( vec2 a, vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n//---------------------------------------------------------------------\n\nvec3 sdf1( in vec2 p ) { return sdgCircle(p,vec2(-0.25, -0.25),0.65); }\nvec3 sdf2( in vec2 p ) { return sdgCircle(p,vec2( 0.25,  0.25),0.65); }\n\nvec2 proj1(vec2 p) { return projdisc(p, vec2(-0.25, -0.25), 0.65); }\nvec2 proj2(vec2 p) { return projdisc(p, vec2( 0.25,  0.25), 0.65); }\n\n\n\n/*\n\n    This is the one you are looking for :)\n\n*/\nvec2 DykstrasProjectionAlgorithm(vec2 r)\n{\n    vec2 x = r;\n    vec2 p = vec2(0), q = vec2(0);\n    \n    const int kMaxSteps = 10;\n    for( int i = 0; i<kMaxSteps; i++ )\n    {\n        vec2 y = proj1(x + p);\n        \n        p = x + p - y;\n        \n        x = proj2(y + q);\n    \n        q = y + q - x;\n        \n    }\n    \n    return x;\n}\n\n\n\n// based on this: https://www.shadertoy.com/view/slGyWt\nfloat opSubtract( in vec2 p )\n{\n    vec2 op = p;\n\n    vec3  a = sdf1(p);\n    vec3  b = sdf2(p);\n    float d = min( a.x, b.x );\n    \n    if( d>0.0 ) return d;\n    \n    for( int i=0; i<32; i++ )\n    {\n        p -= 0.5*(a.x*a.yz + b.x*b.yz);\n        a = sdf1(p);\n        b = sdf2(p);\n        if( max(abs(a.x),abs(b.x))<0.001 ) break;\n    }\n\n    float no = cro(a.yz,b.yz);\n    float s = min( cro(op-p,a.yz)*no,\n                  -cro(op-p,b.yz)*no);\n    \n    return (s<0.0) ? d : -length(p-op);\n}\n\nfloat map( in vec2 p )\n{\n    return opSubtract(p);\n}\n\nvec2 gradient(vec2 p)\n{\n    const float eps = 0.001;\n    return normalize(vec2(\n        (map(p+vec2(1,0)*eps)-map(p+vec2(-1,0)*eps)),\n        (map(p+vec2(0,1)*eps)-map(p+vec2( 0,-1)*eps))\n    ));\n}\n\nconst float PI = 3.14150265;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mo = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    float ps = 2.0/iResolution.y;\n    \n    if( length(iMouse.xy)<10.0 )\n        mo = sin(iTime+vec2(0.0,PI/2.0))*(0.5-0.5*cos(iTime*0.2));\n    \n    float d = map(uv);\n    vec2  g = gradient(uv);\n    \n    vec3 col = 0.5*(0.5+0.5*vec3(g,1.0-g.x-g.y));\n    col *= 1.0-0.75*smoothstep(0.8-25.*ps,0.8+25.*ps,cos(50.0*d));\n    \n    col = mix(col, vec3(1.0,1.0,1.0), smoothstep(ps, -ps, abs(sdf1(uv).x)-0.01));\n    col = mix(col, vec3(1.0,1.0,1.0), smoothstep(ps, -ps, abs(sdf2(uv).x)-0.01));\n     \n    vec2 p = mo;\n    \n    vec2 q = DykstrasProjectionAlgorithm(p); // <-------------- Used here! :)\n    \n    col=mix(col, vec3(1.0,1.0,1.0), .5*smoothstep(ps, -ps, sdSegment(uv,p,q)-0.005));\n    col=mix(col, vec3(1,0,0), 0.75*smoothstep(ps, -ps, length(q-uv)-0.025));\n    col=mix(col, vec3(0.0,0.0,0.0), smoothstep(ps, -ps, abs(length(q-uv)-0.025)-0.005));\n    \n    col=mix(col, vec3(0,0,1), 0.5*smoothstep(ps, -ps, length(p-uv)-0.025));\n    col=mix(col, vec3(0.0,0.0,0.0), smoothstep(ps, -ps, abs(length(p-uv)-0.025)-0.005));\n    \n    fragColor = vec4( pow(col,vec3(1.0/2.2)) ,1.0);\n}","name":"Image","description":"","type":"image"}]}