{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"//  CC BY-NC-SA 4.0\n\n#define PI 3.14159265359\n\n// A new type of algorithm for computing the distance to a cubic bezier curve\n// insight:\n// use complex numbers, then\n// the quintic is the real part of the factored quintic\n// (a*x^3 + b*x^2 + c*x + d)*(3*a*x^2 + 2*b*x + c) = 0\n// This is zero if a*x^3 + b*x^2 + c*x + d = 0\n// or 3*a*x^2 + 2*b*x + c = 0 (which corresponds to cusps)\n// a*x^3 + b*x^2 + c*x + d = 0 always has 3 solutions and\n// if the point in on the bezier, then one of the solutions\n// for the curve parameter x is real.\n// NOTE: the algorithm for determining the side is a bit unstable at cusps.\n\n// iteratively improve the result using the newton method\n// use 0 for the pure form of the approximation (and be surprised by how good it is!)\n#define ITERATIONS 2\n\n// implement all sorts of complex functions to compose the final analytic function,\n// which is by it's very nature a conformal map. Meaning it will be a good approximation.\n// complex exponential\nvec2 cexp(vec2 c) {\n    return exp(c.x)*vec2(cos(c.y), sin(c.y));\n}\n// complex logarithm\nvec2 cln(vec2 c) {\n    float r = length(c);\n    return vec2(log(r), atan(c.y, c.x));\n}\n// complex multiplication\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n// complex conjugation\nvec2 conj(vec2 c) { return vec2(c.x, -c.y); }\n// complex division\nvec2 cdiv(vec2 a, vec2 b) {\n    return cmul(a, conj(b)) / dot(b, b);\n}\n// complex sqrt\nvec2 csqrt(vec2 a) {\n    float r = length(a);\n    if ((a.y + a.x) - a.x == 0.0) {\n        return a.x >= 0.0 ? vec2(sqrt(r), 0.0) : vec2(0.0, sqrt(r));\n    }\n    vec2 h = a / r + vec2(1.0, 0.0);\n    return h * sqrt(r / dot(h, h));\n}\n// complex cuberoot\nvec2 ccbrt(vec2 a) {\n    return cexp(cln(a)/3.0);\n}\n\nvoid cubic_roots(vec2 a, vec2 b, vec2 c, vec2 d, out vec2 x0, out vec2 x1, out vec2 x2) {\n    // Cardano's formula for complex coefficients\n    // TODO handle a=0 correctly\n    vec2 ac = cmul(a, c);\n    vec2 bb = cmul(b, b);\n    vec2 aa = cmul(a, a);\n    vec2 d0 = bb - 3.0 * ac;\n    vec2 d1 = 2.0 * cmul(b, bb) - 9.0 * cmul(ac, b) + 27.0 * cmul(aa, d);\n    vec2 s = csqrt(cmul(d1, d1) - 4.0 * cmul(cmul(d0, d0), d0));\n    vec2 opta = d1 - s;\n    vec2 optb = d1 + s;\n    vec2 opt = dot(opta,opta) < dot(optb,optb) ? optb : opta;\n    vec2 cb = ccbrt(opt * 0.5);\n    x0 = cdiv(b + cb + cdiv(d0, cb), -3.0 * a);\n    vec2 root = vec2(-0.5, 0.866025403784439);\n    cb = cmul(cb, root);\n    x1 = cdiv(b + cb + cdiv(d0, cb), -3.0 * a);\n    cb = cmul(cb, root);\n    x2 = cdiv(b + cb + cdiv(d0, cb), -3.0 * a);\n}\nvec2 cubic(vec2 a, vec2 b, vec2 c, vec2 d, vec2 x) {\n    return cmul(cmul(cmul(a, x) + b, x) + c, x) + d;\n}\nvec2 quadratic(vec2 a, vec2 b, vec2 c, vec2 x) {\n    return cmul(cmul(a, x) + b, x) + c;\n}\nvec2 selectx(vec2 x0, vec2 x1) {\n    return abs(x0.y) < abs(x1.y) ? x0 : x1;\n}\nfloat newton_quintic(float a, float b, float c, float d, float e, float f, float x0) {\n    float v = ((((a * x0 + b) * x0 + c) * x0 + d) * x0 + e) * x0 + f;\n    float dv = (((5.0 * a * x0 + 4.0 * b) * x0 + 3.0 * c) * x0 + 2.0 * d) * x0 + e;\n    float ddv = ((20.0 * a * x0 + 12.0 * b) * x0 + 6.0 * c) * x0 + 2.0 * d;\n    float p = dv / ddv;\n    float q = v / ddv * 2.0;\n    float dx = p - sqrt(max(p * p - q, 0.0)) * sign(p);\n    return x0 - dx;\n    //float vdv = v / dv;\n    //return x0 - vdv * (1.0 + ddv * vdv / dv);\n}\nfloat newton_bezier(float a, float b, float c, float d, float e, float f, float x0) {\n    x0 = clamp(x0, 0.0, 1.0);\n    for (int i = 0; i < ITERATIONS; i++) {\n        x0 = clamp(newton_quintic(a, b, c, d, e, f, x0), 0.0, 1.0);\n    }\n    return x0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.x * 2.0;\n    vec2 mouse = (iMouse.xy - iResolution.xy*0.5)/iResolution.x * 2.0;\n    // cubic bezier params from https://www.shadertoy.com/view/4sKyzW\n\tfloat t0 = mod(iTime*2.+1.5,24.*PI);\n    float scale = 2.0;\n\tvec2 p0 = scale * vec2(-cos(t0 * 1./2.) * .2,sin(t0 * 1./3.) * .25);\n\tvec2 p1 = scale * vec2(-cos(t0 * 2./3.) * .2,sin(t0 * 1./4.) * .1);\n\tvec2 p2 = scale * vec2(cos(t0 * 1./4.) * .1,-sin(t0 * 2./3.) * .2);\n\tvec2 p3 = scale * vec2(cos(t0 * 1./3.) * .25,-sin(t0 * 1./2.) * .1);\n    if (iMouse.z > 0.0) {\n        p1 = mouse;\n    }\n\n    // test cubic roots\n    vec2 a = p3 - p0 + 3.0 * (p1 - p2);\n    vec2 b = 3.0 * p0 - 6.0 * p1 + 3.0 * p2;\n    vec2 c = -3.0 * p0 + 3.0 * p1;\n    vec2 d = p0 - uv;\n    float qa = 3.0 * dot(a, a), qb = 5.0 * dot(a, b), qc = 2.0 * dot(b, b) + 4.0 * dot(a, c), qd = 3.0 * dot(c, b) + 3.0 * dot(a, d), qe = 2.0 * dot(b, d) + dot(c, c), qf = dot(c, d);\n    vec2 x0, x1, x2;\n    cubic_roots(a, b, c, d, x0, x1, x2);\n    // limit to range 0-1\n    vec2 x = vec2(0.0, length(p0 - uv));\n    x0.x = newton_bezier(qa, qb, qc, qd, qe, qf, x0.x);\n    x0.y = length(cubic(a, b, c, d, vec2(x0.x, 0.0)));\n    x = selectx(x, x0);\n    x1.x = newton_bezier(qa, qb, qc, qd, qe, qf, x1.x);\n    x1.y = length(cubic(a, b, c, d, vec2(x1.x, 0.0)));\n    x = selectx(x, x1);\n    x2.x = newton_bezier(qa, qb, qc, qd, qe, qf, x2.x);\n    x2.y = length(cubic(a, b, c, d, vec2(x2.x, 0.0)));\n    x = selectx(x, x2);\n    float dp3 = length(p3 - uv);\n    if (x.y > dp3) {\n        x.x = 1.0;\n        x.y = dp3;\n    }\n    float t = x.x;\n    vec2 pos = cubic(a, b, c, d, vec2(t, 0.0));\n    vec2 tangent = quadratic(3.0 * a, 2.0 * b, c, vec2(t, 0.0));\n    float dist = length(pos);\n    // TODO improve stability of sign! The cancellaton of signs makes it unstable at cusps.\n    float sgn0 = sign(cmul(conj(tangent), pos).y);\n    // flip sign if the pos is in a self intersection loop\n    vec2 p = -inverse(mat2(a, b)) * c;\n    float q = p.y*p.y - p.x;\n    float sgn = sgn0 * ((q > 0.0) && (q-p.y+1.0 > 0.0) ? sign(t*t - p.y * t + q) : 1.0);\n    float d0 = abs(dist);\n    \n\t//iq's sd color scheme\n\tvec3 col = vec3(1.0) - sgn*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-8.0 * abs(d0)*0.5);\n\tcol *= 0.8 + 0.2*cos(480.0*0.5*d0);\n\tcol = mix(col, vec3(1.0), 1.0-smoothstep(0.0,0.005,abs(d0)*0.5));\n    fragColor = vec4(col, 1.0);\n    \n    fragColor += vec4(vec3(0.0,0.0,1.0) * max(0.0, 3.0 - length(p0 - uv) / 0.01), 1.0);\n    fragColor += vec4(vec3(0.0,1.0,0.0) * max(0.0, 3.0 - length(p1 - uv) / 0.01), 1.0);\n    fragColor += vec4(vec3(1.0,0.0,0.0) * max(0.0, 3.0 - length(p2 - uv) / 0.01), 1.0);\n    fragColor += vec4(vec3(0.0,0.0,1.0) * max(0.0, 3.0 - length(p3 - uv) / 0.01), 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lcyBz3","date":"1734294350","viewed":136,"name":"Cubic Bezier SDF Approximation","username":"weasel","description":"This is an approximation of the sdf of a cubic bezier curve using conformal maps (here: complex analytic functions). This is the one to rule them all.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sdf","bezier","distance","cubic"],"hasliked":0,"parentid":"","parentname":""}}