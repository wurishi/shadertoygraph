{"ver":"0.1","info":{"id":"DsVSzG","date":"1681342464","viewed":236,"name":"Samurai Gunn 2 Radial Explosion","username":"Teknopants","description":"Prototyping an explosion effect for our upgraded explosions in Samurai Gunn 2\nhttps://store.steampowered.com/app/1397790/Samurai_Gunn_2/","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["explosion","videogame","stylized","samuraigunn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float explosionTime = .416; // 25 frames at 60fps\nconst float outerRingNoiseIntensity = .05;\n\nfloat easeOutExpo(float n)\n{\n    return n == 1.0 ? 1.0 : 1.0 - pow(2.0, -10.0 * n);\n}\n\nfloat easeInOutExpo(float x)\n{\n    return x == 0.0\n      ? 0.0\n      : x == 1.0\n      ? 1.0\n      : x < 0.5 ? pow(2.0, 20.0 * x - 10.0) / 2.0\n      : (2.0 - pow(2.0, -20.0 * x + 10.0)) / 2.0;\n}\n\nfloat stepped(float n, float c)\n{\n    return floor(n / c) * c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // some wackiness to get this to appear centered\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = vec2(fragCoord.x / iResolution.x * aspect - (iResolution.x * .00045 ), fragCoord.y / iResolution.y);\n    \n    // Time\n    float time = mod(iTime, explosionTime);\n    float explosionLerp = time / explosionTime;\n    float explosionLerpInverted = 1.0 - explosionLerp;\n\n    // Animation Timings\n    float outerRingPosition = easeOutExpo(explosionLerp);\n    float innerRingPosition = easeInOutExpo(explosionLerp);\n\n    // Outer Ring\n    float outerRingNoise = texture(iChannel0, vec2(uv.x * .1 + outerRingPosition, uv.y * .1)).r;\n    outerRingPosition += (outerRingNoiseIntensity / 2.0) - (outerRingNoise * outerRingNoiseIntensity);\n    outerRingPosition -= outerRingNoise * pow(explosionLerp, 3.0) * outerRingNoiseIntensity * 10.0;\n    \n    // Inner Ring\n    // TODO: there is a visible seam at 9 o' clock\n    float angleFromCenter = atan(uv.y - 0.5, uv.x - 0.5);\n    float insideRingTexture = texture(iChannel0, vec2(\n        angleFromCenter / 7.0 + iTime * .2 + outerRingPosition * .1,\n        iTime * .013)\n    ).r;\n    \n    innerRingPosition -= insideRingTexture * insideRingTexture * explosionLerpInverted * 8.0 * (.9 - outerRingPosition);\n\n    // Inner texture\n    float distanceFromCenter = (distance(vec2(0.5, 0.5), uv.xy) * 2.0);\n    float insideGradient = (distanceFromCenter - innerRingPosition) / outerRingPosition;\n    insideGradient *= insideRingTexture;\n    insideGradient += explosionLerpInverted * .3;\n    insideGradient += insideGradient*insideGradient*insideGradient / 1.5;\n    insideGradient += .1;\n    insideGradient = stepped(insideGradient, 0.1);\n\n    // ALPHA\n    float isInsideRing = 1.0 - sign((distanceFromCenter - innerRingPosition) * (distanceFromCenter - outerRingPosition));\n    isInsideRing *= sign(insideGradient);\n    vec3 alphaMap = vec3(isInsideRing, isInsideRing, isInsideRing);\n    \n    // COLOR\n    // Should just use gradient map for converting grayscale to desired color\n    vec3 colorMap = vec3(insideGradient * (2.0 + insideGradient), insideGradient * (1.0 + insideGradient), insideGradient);\n\n    // Shifting BG color\n    vec3 bgColor = vec3(sin(iTime) * .5, sin(iTime + 1.2) * .5, cos(iTime) * .5);\n    \n    vec3 color = bgColor;\n    \n    // cus no alpha just using an if. Would set alpha to isInsideRing\n    if (isInsideRing > 0.0)\n    {\n        color = alphaMap * colorMap;\n    }\n    \n    fragColor = vec4(color, isInsideRing);\n}","name":"Image","description":"","type":"image"}]}