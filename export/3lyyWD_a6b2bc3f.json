{"ver":"0.1","info":{"id":"3lyyWD","date":"1610987354","viewed":92,"name":"Basic 2d texture transforms","username":"cottayson","description":"How to load and transform 2d texture.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","texture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14\n\n// Just move image by mouse\nvec2 transformIdentity(vec2 uv, vec2 dr) {\n    float x = uv.x - dr.x;\n    float y = uv.y - dr.y;\n    return vec2(x, y);\n}\n\n// Repeat image in x coordinate space\nvec2 transform1D(vec2 uv, float phi) {\n    float x = sin(2.0 * PI * (uv.x - phi));\n    float y = uv.y;\n    return vec2(x, y);\n}\n\n// Repeat image in (x, y) space\nvec2 transform2D(vec2 uv, vec2 dr) {\n    float x = uv.x - dr.x;\n    float y = uv.y - dr.y;\n    float outX = sin(8.0 * PI * x);\n    float outY = sin(0.5 * PI * y);\n    return vec2(outX, outY);\n}\n\n// Flip image with respect to the vertical axis in center of screen\nvec2 transform1DMirrorX(vec2 uv, vec2 dr) {\n    float x = abs(uv.x - 0.5);\n    float y = uv.y;\n    return vec2(x, y);\n}\n\n// Flip image with respect to the vertical axis, that position controlled by iMouse.x\nvec2 transform1DMirrorMouseX(vec2 uv, vec2 dr) {\n    float x = abs(uv.x - dr.x);\n    float y = uv.y;\n    return vec2(x, y);\n}\n\n// Flip image with respect to the horizontal axis\nvec2 transform1DMirrorY(vec2 uv, vec2 dr) {\n    float x = uv.x;\n    float y = abs(uv.y - 0.5);\n    return vec2(x, y);\n}\n\n// Rotate image relative to the (0, 0) point\nvec2 rotateImage(vec2 uv, vec2 dr) {\n    //vec2 rot = uv * mat2(cos(dr), -sin(dr), sin(dr), cos(dr));\n    float aspectRatio = iResolution.y / iResolution.x;\n    float phi = dr.y;\n    uv.y *= aspectRatio;\n    float outX = uv.x * cos(phi) + uv.y * sin(phi);\n    float outY = uv.x * sin(phi) - uv.y * cos(phi);\n    return vec2(outX, outY);\n}\n\n// Rotate image relative to the center\nvec2 rotateImageRelativeToCenter(vec2 uv, vec2 dr) {\n    float aspectRatio = iResolution.y / iResolution.x;\n    vec2 center = vec2(0.5, 0.5);\n    uv -= center;\n    float phi = dr.y;\n    uv.y *= aspectRatio;\n    float outX = uv.x * cos(phi) + uv.y * sin(phi);\n    float outY = uv.x * sin(phi) - uv.y * cos(phi);\n    return vec2(outX, outY);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // vec4 colorWithAplha = texture(iChannel0, transform1D(uv, iMouse.x / iResolution.x));\n    vec4 colorWithAplha = texture(iChannel0, rotateImageRelativeToCenter(uv, iMouse.xy / iResolution.xy));\n    vec3 col = colorWithAplha.xyz;\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}