{"ver":"0.1","info":{"id":"Mt2fRw","date":"1515137975","viewed":567,"name":"Frosted ornament","username":"saidwho12","description":"I didn't get to finish the top part as I started getting performance issues for what i was aiming for and I don't think adding the top part would add too much to this shape and so I just will leave it as is but might redo this later when i know more.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["julia","christmas","red","swirls","set","xmas","frosted","ornament"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITERATIONS 128\n\n#define RAY_T_MAX 1.e30\n#define RAY_T_MIN .01\n#define SPEED .5\n#define TIME iTime*SPEED\n#define PI 3.1415927\n#define EPSILON .006\n#define GAMMA 2.2\n\n#define MOUSE (iMouse.xy/iResolution.xy)*2.-1.\n#define MODE 1\n\n#if (MODE == 0)\n\t#define C MOUSE\n#elif (MODE == 1)\n    #define CR -.181\n    #define CI .667\n\t#define C vec2(CR, CI)\n#endif\n\n// Polynomial smooth minimum by iq\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n  return mix(a, b, h) - k*h*(1.0-h);\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nint julia (vec2 uv, vec2 c, float n, int maxIter)\n{   \n    int i = 0;\n    float a = uv.x, b = uv.y;\n    while(i<maxIter && a*a+b*b<4.)\n    {   \n        float tmpa = pow((a*a+b*b),(n/2.))*cos(n*atan(b, a)) + c.x;\n        b = pow((a*a+b*b),(n/2.))*sin(n*atan(b, a)) + c.y;\n        a = tmpa;\n        i++;\n    }\n    return i;\n}\n\nstruct camera\n{\n\tvec3 center, forward, up, right;\n    float w, h, fov, aspect;\n};\n\nvoid initCamera(inout camera cam, in vec3 center, in vec3 forward, in vec3 up, in float fov, in float aspect) \n{\n\tcam.center = center;\n    cam.forward = forward;\n    cam.up = up;\n    cam.right = cross(cam.forward, cam.up);\n    cam.fov = fov;\n    cam.aspect = aspect;\n    cam.w = tan(cam.fov);\n    cam.h = cam.w * cam.aspect;\n}\n\nstruct material\n{\n    vec3 ambiant, diffuse, specular;\n    float shininess;\n};\n  \nstruct light\n{\n\tvec3 center;\n    float power;\t\n};\n\nvec3 blinn_phong (vec3 L, vec3 N, vec3 V, light l, float dist, material m)\n{\n\tvec3 ambiant = m.ambiant;\n    vec3 diffuse = m.diffuse*dot(L, N);\n    vec3 H = normalize(L + V);\n    float specAngle = max(dot(N, H), 0.);\n    vec3 specular = m.specular*pow(specAngle, m.shininess);\n    float power = l.power/dist;\n    return ambiant*power + diffuse*power + specular*power;\n    \n}\n\nstruct sphere\n{\n\tvec3 center;\n    float radius;\n};\n\nfloat sphereSDF(vec3 p, sphere s)\n{\n\treturn distance(p, s.center)-s.radius;\n}\n    \nstruct cylinder\n{\n    vec3 base;\n   \tfloat height;\n};\n\nfloat cylinderSDF(vec3 p, float h)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat opScaleCylinder(vec3 p, float s, cylinder c)\n{\n    return cylinderSDF(p/s, c.height)*s;\n}\n\nfloat opU(float d0, float d1)\n{\n\treturn min(d0, d1);\n}\n\nstruct point\n{\n    material m;\n\tfloat r;\n};\n\npoint sceneSDF(vec3 p, bool mcalc)\n{\n    sphere s = sphere(vec3(0,-.25,0), 1.5);\n    cylinder c = cylinder(vec3(0,s.radius,0)+s.center, .2);\n\n    float scl = .4;\n    float amp = .015;\n    vec2 offset = vec2(.4, -.1);\n    float j = float(julia(scl*s.center.xy-(scl*p.xy)+offset, C, 2., 64))/float(64);\n    //j = 0.;\n    float d0 = 0.;\n    vec3 cyPoint = p-c.base;\n    float cyScale = 1.5;\n    cyPoint.y -= c.height;\n\t\n    //d0 = mix(0., 1., cyPoint.y);  \n    \n    material m;\n    if (mcalc)\n    {\n        material m0 = material(vec3(.3,0,0), vec3(.7,0,0), vec3(1,.5,.5), 15.);\n        material m1 = material(vec3(.4), vec3(.7), vec3(1.), 5.);\n        material m2 = material(vec3(.05, .05,.09), vec3(.39,.36,.5), vec3(0.9, 0.9, .97), .7);\n        m.ambiant = mix( mix(m0.ambiant, m1.ambiant, d0), m2.ambiant, j );\n        m.diffuse = mix( mix(m0.diffuse, m1.diffuse, d0), m2.diffuse, j);\n        m.specular = mix( mix(m0.specular, m1.specular, d0), m2.specular, j);\n        m.shininess = mix( mix(m0.shininess, m1.shininess, d0), m2.shininess, j);\n    }\n \t\n    float d1 = smin(sphereSDF(p, s), cyScale*cylinderSDF(cyPoint/cyScale, c.height) - d0*.2, .2);\n    float d2 = amp*j;\n    float d = d1 - d2;\n    return point(m, d);\n}\n\nvec3 estimateNormal(vec3 p)\n{\n\treturn normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z), false).r - sceneSDF(vec3(p.x - EPSILON, p.y, p.z), false).r,\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z), false).r - sceneSDF(vec3(p.x, p.y - EPSILON, p.z), false).r,\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON), false).r - sceneSDF(vec3(p.x, p.y, p.z - EPSILON), false).r\n    ));\n}\n\nfloat trace(vec3 p, vec3 d)\n{\n\tfloat t = RAY_T_MIN;\n    int i = 0;\n    while(t<RAY_T_MAX && i<MAX_ITERATIONS)\n    {\n    \tfloat r = sceneSDF(p + d*t, false).r;\n        if (r<RAY_T_MIN)\n        {\n            break;\n        }\n        t += r;\n        i++;\n    }\n    if (i==MAX_ITERATIONS || t>RAY_T_MAX)\n    {\n       \treturn RAY_T_MAX;\n    }\n    return t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv*2.-1.;\n    camera cam;\n\tinitCamera(cam, vec3(0,0,4.), vec3(0,0,-1), vec3(0,1,0), PI/4., iResolution.y/iResolution.x);\n    \n    vec3 lightPos = vec3(inverse(rotateY(sin(TIME))) * vec4(vec3(0,1.5,cam.center.z), 1.));\n    light l = light(lightPos, 2.2);\n    \n    // d => ray direction, P => point of intersection\n    vec3 d = normalize(cam.forward + p.x * cam.w * cam.right + p.y * cam.h * cam.up);\n    float t = trace(cam.center, d);\n    \n    vec3 col = vec3(0);\n    if (t < RAY_T_MAX)\n    {\n    \tvec3 P = cam.center + (d*t);\n    \tvec3 L = l.center - P;\n    \tfloat dist = length(L);\n    \tL = normalize(L);\n    \tvec3 N = estimateNormal(P);\n        \n    \t//vec3 col = vec3(1./t);\n    \t//vec3 col = texture(iChannel0, uv).xyz;\n    \t//col+=vec3(N/2. + .5);\n    \tcol = blinn_phong(L, N, -d, l, dist, sceneSDF(P, true).m);\n    \tcol *= pow(col,vec3(1./GAMMA));\n    }\n    \n    \n    fragColor = vec4(col, 1.);\n    //fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"}]}