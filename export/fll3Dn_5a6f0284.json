{"ver":"0.1","info":{"id":"fll3Dn","date":"1622643912","viewed":144,"name":"Wiggly Shapes!","username":"Joytis","description":"We're gonna try making some cool wiggly shapes!","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["procedural","sdf","sandbox","shapes","exercise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// SDF Sandbox (Wiggy Shapes) by Clark Chambers\n// =====================================================================\n// In my limited visual effects experience, most often improvment comes from an intuition of the tools \n// we have at our disposal. One of the most useful of these tools, I've found, are volumes. And my personal\n// favorite way to define volumes is using, of course, signed distance fields! Here's a few advantages I've\n// found to this particular (and fairly common) way of defining volumes!\n// - Procedural Shapes. Many shapes can be defined as distance functions, allowing for procedural shapes with low geometry count!\n// - Fast. Defining a distance field is often a relatively low instruction count.\n// - Composable. SDFs can be blended, lerped, and animated with sets of simple, reusable functions\n// - Quick animation iteration. Shaders compile fast, and iterating on procedural animations is very quick. \n\n// This shader was designed to help a user build some fundemental intuition of what signed distance fields are,\n// how to manipulate them, and what all they can even do! Down in the mainSceneFunction (line 489), there is a bunch\n// of pre-written code. What is currently uncommented will draw a simple circle on a tiled background. Uncommenting \n// out lines will change this behaviour! Feel free to play around with these functions as much as your heart desires\n// and make some awesome procedural shapes with procedural animations!\n\n// Try to make a fun, procedural shape that evokes some kind of emotion or experience. A big portion\n// of visual effect design is conveying an experience; building an internal mapping of mathematical motion \n// to human experience can yield some awesome procedural visual effects!\n\n// When playing around with the mainScene below, try screwing aroundwith:\n// - The order of the lines of code, especially animations! Most operations are NOT commutative :)\n//    - (Passing \"sin(time)\" instead of \"time\" on some of those is very fun)\n// - The arguments in the functions! These will often have drastic changes in visuals.\n// - Colors! \n\n#define PI 3.1415962\n\n//\tClassic Perlin 2D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec2 P){\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n    vec4 i = permute(permute(ix) + iy);\n    vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n    vec4 gy = abs(gx) - 0.5;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n    vec2 g00 = vec2(gx.x,gy.x);\n    vec2 g10 = vec2(gx.y,gy.y);\n    vec2 g01 = vec2(gx.z,gy.z);\n    vec2 g11 = vec2(gx.w,gy.w);\n    vec4 norm = 1.79284291400159 - 0.85373472095314 * vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n    vec2 fade_xy = fade(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n}\n\nvec3 hueToRgb(float H)\n{\n    float r = abs(H * 6. - 3.) - 1.;\n    float g = 2. - abs(H * 6. - 2.);\n    float v = 2. - abs(H * 6. - 4.);\n    return clamp(vec3(r,g,v), 0.0, 1.0);\n}\n\nfloat posterize(float value, float steps)\n{\n    return floor(value / (1.0 / steps)) * (1.0 / steps);\n}\n\n\n// GLSL Voronoi noise: https://docs.unity3d.com/Packages/com.unity.shadergraph@6.9/manual/Voronoi-Node.html\nvec2 unity_voronoi_noise_randomVector(vec2 UV, float offset)\n{\n    mat2x2 m = mat2x2(15.27, 47.63, 99.41, 89.98);\n    UV = fract(sin(m * UV) * 46839.32);\n    return vec2(sin(UV.y*+offset)*0.5+0.5, cos(UV.x*offset)*0.5+0.5);\n}\n\nfloat Unity_Voronoi_float(vec2 UV, float offset, float density)\n{\n    vec2 g = floor(UV * density);\n    vec2 f = fract(UV * density);\n    float t = 8.0;\n    vec3 res = vec3(8.0, 0.0, 0.0);\n\n    for(int y=-1; y<=1; y++)\n    {\n        for(int x=-1; x<=1; x++)\n        {\n            vec2 lattice = vec2(x,y);\n            vec2 offset = unity_voronoi_noise_randomVector(lattice + g, offset);\n            float d = distance(lattice + offset, f);\n            if(d < res.x)\n            {\n                res = vec3(d, offset.x, offset.y);\n            }\n        }\n    }\n\n    return res.x;\n}\n\nfloat atan2(in float y, in float x)\n{\n    bool s = (abs(x) > abs(y));\n    return mix(PI/2.0 - atan(x,y), atan(y,x), s);\n}\n\nvec2 polarCoordinates(vec2 UV, float RadialScale, float LengthScale)\n{\n    vec2 delta = UV;\n    float radius = length(delta) * 2.0 * RadialScale;\n    float angle = atan2(delta.x, delta.y) * 1.0/6.28 * LengthScale;\n    return vec2(radius, angle);\n}\n\n\n\n/////////////////////////////////////////////////\n// SAMPLERS\n/////////////////////////////////////////////////\nfloat fill(float sdf, float target)\n{\n    return smoothstep(0.00001, 0.0, sdf - target);\n}\n\nfloat stroke(float sdf, float width, float target)\n{\n    return fill(sdf - width, target) - fill(sdf + width, target);\n}\n\nfloat makeOnionRing(float sdf, in float r )\n{\n    return abs(sdf) - r;\n}\n\nfloat makeInfiniteOnionRings(float sdf, in float interval, in float r)\n{\n    sdf = mod(sdf, interval) - (interval / 2.0);\n    return abs(sdf) - r;\n}\n\n\n/////////////////////////////////////////////////\n// OTHER UTILITIES\n/////////////////////////////////////////////////\nvec2 flowerize(vec2 uv, float petals)\n{\n    vec2 polaruv = polarCoordinates(uv, 0.5, 1.0);\n    polaruv.y = mod(polaruv.y, (1.0 / petals)) * petals * 2.0 - 1.0;\n    return polaruv;\n}\n\nvec2 tileSomeUvs(vec2 uv, vec2 tiling)\n{\n    uv = uv * tiling;\n    uv = mod(uv, vec2(2.0)) - 1.0;\n    return uv;\n}\n\nvec2 scaleUvs(vec2 uv, float scale)\n{\n    return uv * scale;\n}\n\nvec2 createInitialUVs(in vec2 fragCoord)\n{\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * 2.0;\n    uv.x *= aspect;\n    return uv;\n}\n\n\n/////////////////////////////////////////////////\n// MERGING\n/////////////////////////////////////////////////\n\nfloat addShape(float sdf1, float sdf2)\n{\n    return min(sdf1, sdf2);\n}\n\nfloat intersectShape(float sdf1, float sdf2)\n{\n    return max(sdf1, sdf2);\n}\n\nfloat cutOutShape(float base, float subtraction)\n{\n    return intersectShape(base, -subtraction);\n}\n\nfloat blendShape(float sdf1, float sdf2, float k)\n{\n    float res = exp(-k*sdf1) + exp(-k*sdf2);\n    return -log(max(0.0,res)) / k;\n}\n\nfloat invertShape(float sdf1, float sdf2)\n{\n    float filledFlip = fill(sdf2, 0.0);\n    return mix(sdf1, -sdf1, filledFlip);\n}\n\n\nfloat simpleMorph(float sdf1, float sdf2, float period)\n{\n    float morphTime = (sin(2.0 * PI * iTime / period) + 1.0) / 2.0;\n    return mix(sdf1, sdf2, morphTime);\n}\n\n/////////////////////////////////////////////////\n// DISTANCE FUNCTIONS - https://iquilezles.org/articles/distfunctions2d\n/////////////////////////////////////////////////\nfloat circle(in vec2 uv, in float radius)\n{\n    return length(uv) - radius;\n}\n\nfloat box(in vec2 uv, in vec2 dimensions)\n{\n    vec2 distance = abs(uv) - dimensions;\n    return length(max(distance, 0.0)) + min(max(distance.x, distance.y), 0.0);\n}\n\nfloat line( in vec2 uv, in vec2 pointA, in vec2 pointB )\n{\n    vec2 pa = uv - pointA;\n    vec2 ba = pointB - pointA;\n    float h = clamp(dot(pa, ba) / dot(ba,ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat equilateralTriangle( in vec2 uv )\n{\n    uv = uv * 1.4;\n    const float k = sqrt(3.0);\n    uv.x = abs(uv.x) - 1.0;\n    uv.y = uv.y + 1.0 / k;\n    if(uv.x + k * uv.y > 0.0) \n    {\n        uv = vec2(uv.x - k * uv.y, -k * uv.x - uv.y) / 2.0;\n    }\n    uv.x -= clamp(uv.x, -2.0, 0.0);\n    return -length(uv) * sign(uv.y);\n}\n\nfloat star5(in vec2 uv, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    uv.x = abs(uv.x);\n    uv -= 2.0*max(dot(k1,uv),0.0)*k1;\n    uv -= 2.0*max(dot(k2,uv),0.0)*k2;\n    uv.x = abs(uv.x);\n    uv.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(uv,ba)/dot(ba,ba), 0.0, r );\n    return length(uv-ba*h) * sign(uv.y*ba.x-uv.x*ba.y);\n}\n\nfloat moon(vec2 uv, float d, float ra, float rb )\n{\n    uv.y = abs(uv.y);\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(uv.x*b-uv.y*a) > d*d*max(b-uv.y,0.0) )\n          return length(uv-vec2(a,b));\n    return max( (length(uv          )-ra),\n               -(length(uv-vec2(d,0))-rb));\n}\n\nfloat dot2(in vec2 v) { return dot(v,v); }\nfloat heart(in vec2 uv)\n{\n    uv.y += 0.5;\n    uv.x = abs(uv.x);\n\n    if( uv.y+uv.x>1.0 )\n        return sqrt(dot2(uv-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(uv-vec2(0.00,1.00)),\n                    dot2(uv-0.5*max(uv.x+uv.y,0.0)))) * sign(uv.x-uv.y);\n}\n\nfloat shapeCross(in vec2 uv, in vec2 b, float r) \n{\n    uv = abs(uv); uv = (uv.y>uv.x) ? uv.yx : uv.xy;\n    vec2  q = uv - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-uv.x,-k);\n    return sign(k)*length(max(w,0.0)) + r;\n}\n\nfloat roundedX(in vec2 p, in float w, in float r)\n{\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\nfloat screenSplit(in vec2 uv, in vec2 direction)\n{\n    direction = clamp(direction, vec2(-1.0), vec2(1.0));\n    float directionMag = length(direction);\n    return ((uv.x * direction.x) + (uv.y * direction.y)) / directionMag;\n}\n\n\n/////////////////////////////////////////////////\n// ANIMATIONS\n/////////////////////////////////////////////////\n\nvec2 rotateUV(in vec2 uv, float rotation, vec2 mid)\n{\n    return vec2(\n      cos(rotation) * (uv.x - mid.x) + sin(rotation) * (uv.y - mid.y) + mid.x,\n      cos(rotation) * (uv.y - mid.y) - sin(rotation) * (uv.x - mid.x) + mid.y\n    );\n}\nvec2 rotateOverTime(in vec2 uv, float degreesPerSecond, float time)\n{\n    return rotateUV(uv, radians(degreesPerSecond * time), vec2(0.0));\n}\n\nvec2 twirlOverTime(vec2 UV, float strengthOverTime, float time)\n{\n    float strength = strengthOverTime * time;\n    vec2 delta = UV;\n    float angle = strength * length(delta);\n    float x = cos(angle) * delta.x - sin(angle) * delta.y;\n    float y = sin(angle) * delta.x + cos(angle) * delta.y;\n    return vec2(x, y);\n}\n\nvec2 moveLinearOverTime(vec2 uv, vec2 distanceOverTime, float time)\n{\n    vec2 moveDistance = distanceOverTime * time;\n    return uv + moveDistance;\n}\n\nvec2 moveInCircleOverTime(vec2 uv, vec2 radius, float time)\n{\n    float x = radius.x * cos(time);\n    float y = radius.y * sin(time);\n    return uv + vec2(x, y);\n}\n\nvec2 noiseBlobOverTime(vec2 uv, vec2 direction, float intensity)\n{\n    vec2 noiseuv = uv + (direction * iTime);\n    return uv + ((cnoise(noiseuv) - 0.5) * intensity);\n}\n\nvec2 glassyDistortionOverTime(vec2 uv, float speed, float size, float intensity)\n{\n    float voronoi = Unity_Voronoi_float(uv, iTime * speed, size);\n    return  uv + ((voronoi - 0.5) * intensity);\n}\n\nvec2 verticalWaveOverTime(vec2 uv, float strength, float waviness, float speed)\n{\n    float wave = sin(2.0 * PI * (uv.y + (iTime * speed)) * waviness);\n    uv.x += wave * strength;\n    return uv;\n}\n\nvec2 hotizontalWaveOverTime(vec2 uv, float strength, float waviness, float speed)\n{\n    float wave = sin(2.0 * PI * (uv.x + (iTime * speed)) * waviness);\n    uv.y += wave * strength;\n    return uv;\n}\n\nfloat addAMovingCircle(float sdf, vec2 uv)\n{\n    // Distort the UVs so we can make a circle\n    uv = moveInCircleOverTime(uv, vec2(0.5, 0.5), iTime); // This will move around in a circle!\n    float addedCircle = circle(uv, 0.2);\n    return blendShape(sdf, addedCircle, 32.0);\n}\n\nfloat subtractAMovingBar(float sdf, vec2 uv)\n{\n    uv.y = mod(uv.y - iTime / 2.0, 1.5);\n    float barSdf = line(uv, vec2(-2.0, 0.1), vec2(2.0, 0.1)) - 0.05;\n    return cutOutShape(sdf, barSdf);\n}\n\nfloat specklyGloopify(float sdf, vec2 uv)\n{\n    // Distort the UVs so we can make a circle\n    uv -= iTime / 10.0;\n    float speckleOffset = 5.0 + iTime / 3.0;\n    float voronoiSdf = pow(Unity_Voronoi_float(uv, speckleOffset, 3.0) + 0.3, 1.0);\n    return blendShape(sdf, voronoiSdf, 4.0);\n}\n\n/////////////////////////////////////////////////\n// COLORS\n/////////////////////////////////////////////////\nvec4 hyperRainbow(float sdf)\n{\n    float hue = mod(abs(posterize(sdf, 10.0)), 1.0);\n    return vec4(hueToRgb(hue), 1.0);\n}\n\nvec3 fullscreenRainbow(vec2 fragCoord)\n{\n    vec2 uv = createInitialUVs(fragCoord) + 3.7;\n    float hue = mod((uv.x + (0.2 * uv.y)) / 1.2, 1.0);\n    return hueToRgb(hue);\n}\n\nvec4 singleTone(float sdf, vec3 color1)\n{\n    return vec4(fill(sdf, 0.0) * color1, 1.0);\n}\n\nvec4 twoTone(float sdf, vec3 color1, vec3 color2)\n{\n    float sdfArea = fill(sdf, 0.0);\n    return mix(vec4(vec3(0.0), 1.0), vec4(mix(color1, color2, -sdf), 1.0), sdfArea);\n}\n\nvec4 fourTone(float sdf, vec3 color1, vec3 color2, vec3 color3, vec3 color4)\n{\n    float sdfArea = fill(sdf, 0.0);\n    return mix(vec4(mix(color3, color4, sdf), 1.0), vec4(mix(color1, color2, -sdf), 1.0), sdfArea);\n}\n\nvec4 sdfDebugStriations(float sdf, vec4 brightColor, vec4 subduedColor)\n{\n    float repeating = step(0.05, mod(sdf, 0.1));\n    vec4 color1 = brightColor * sdf;\n    color1.a = 1.0;\n    vec4 color2 = subduedColor * sdf;\n    color2.a = 1.0;\n    return mix(color1, color2, repeating);\n}\n\nvec4 sdfDebug(float sdf)\n{\n    vec4 striations = sdf > 0.0 ?\n        sdfDebugStriations(sdf, vec4(0.7608, 0.3412, 0.0, 1.0), vec4(0.6275, 0.3686, 0.0039, 1.0)) :\n        sdfDebugStriations(abs(sdf), vec4(0.0, 0.549, 1.0, 1.0), vec4(0.0, 0.4431, 0.5922, 1.0));\n\n    float strokeValue = stroke(sdf, 0.01, 0.0);\n    \n    return mix(striations, vec4(1.0),  strokeValue);\n}\n\nvec4 testChamberVibes(float sdf, vec2 fragCoord)\n{\n    vec2 uv = createInitialUVs(fragCoord);\n    uv = tileSomeUvs(uv, vec2(20.0, 20.0));\n\n    float floorSdf = min(abs(uv.x), abs(uv.y));\n    float floorFill = fill(floorSdf, 0.07);\n    vec4 floorFillValue = mix(vec4(0.5, 0.5, 0.6, 1.0), vec4(0.4, 0.4, 0.5, 1.0), floorFill);\n\n    float strokeValue = stroke(sdf, 0.01, 0.0);\n    float sdfFill = fill(sdf, 0.0);\n    vec4 sdfFillValue = sdfFill * vec4(0.7608, 0.3412, 0.0, 1.0);\n\n    vec4 combinedFill = mix(floorFillValue, sdfFillValue, sdfFill);\n    \n    return mix(combinedFill, vec4(vec3(0.1), 1.0),  strokeValue);\n}\n\nvec4 starrySpaceyVibes(float sdf, vec2 fragCoord)\n{\n    vec2 originalUvs = createInitialUVs(fragCoord);\n    vec2 uv = originalUvs + iTime / 100.0;\n    uv = uv * vec2(3.0, 3.0);\n\n    float spaceSdf = Unity_Voronoi_float(uv, 3.0, 3.0);\n    float spaceFill = fill(spaceSdf, 0.07);\n    vec4 floorFillValue = mix(vec4(0.0, 0.0, 0.0, 1.0), vec4(0.9, 0.9, 0.9, 1.0), spaceFill);\n\n    float strokeValue = stroke(sdf, 0.006, 0.0);\n    float sdfFill = fill(sdf, 0.0);\n    float posterizeSdf = posterize(sdf, 6.0);\n    vec4 sdfFillValue = sdfFill * twoTone(posterizeSdf, vec3(0.2, 0.2, 0.23), vec3(0.6, 0.6, 0.67));\n\n    vec4 combinedFill = mix(floorFillValue, sdfFillValue, sdfFill);\n    \n    return mix(combinedFill, vec4(vec3(0.1), 1.0),  strokeValue);\n}\n\n/////////////////////////////////////////////////\n// MAIN SCENE\n/////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = createInitialUVs(fragCoord);\n\n    // THIS IS WHERE THE IMPORTANT STUFF STARTS <3\n    ////////////////////////////////////////////////////////\n    // DO DISTORTIONS HERE\n    ////////////////////////////////////////////////////////\n    float time = iTime;\n\n    // We can change our coordinate space here if we'd like!\n    // Uncomment any number of these functions to make weird stuff happen!\n    //========================================================\n    // uv = scaleUvs(uv, 2.0); // This will make your shapes bigger or smaller!\n    // uv = flowerize(uv, 5.0);\n    // uv = rotateOverTime(uv, 33.0, time); // This will rotate the screen!\n    // uv = tileSomeUvs(uv, vec2(3.0, 3.0)); // This will tile your shapes!\n\n    ////////////////////////////////////////////////////////\n    // DO ANIMATIONS HERE\n    ////////////////////////////////////////////////////////\n    // You can warp the UV space to animate shapes! Uncomment these functions to see what happens!\n    // They're cumulative!!\n    //========================================================\n    // uv = rotateOverTime(uv, 33.0, time); // This will rotate constantly!\n    // uv = rotateOverTime(uv, 33.0, time); // This will rotate back and fourth!\n    // uv = moveLinearOverTime(uv, vec2(0.5, 0.5), sin(time)); // This will move back and fourth!\n    // uv = moveInCircleOverTime(uv, vec2(0.5, 0.5), time); // This will move around in a circle!\n    // uv = twirlOverTime(uv, 1.0, sin(time)); // This will twirl the shape forever!\n    // uv = noiseBlobOverTime(uv, vec2(1.0, 0.0), 0.1); // Wiggle the shape around with noise!\n    // uv = glassyDistortionOverTime(uv, 2.0, 2.0, 0.1); // Distort the shape with voronoi noise!  \n    // uv = verticalWaveOverTime(uv, 0.3, 1.0, 0.5); // Wave the shape around vertically!\n    // uv = hotizontalWaveOverTime(uv, 0.3, 1.0, 0.5); // Wave the shape aroud horizontally!\n\n    ////////////////////////////////////////////////////////\n    // DO SHAPES HERE\n    ////////////////////////////////////////////////////////\n    // You can use these digned distance functions to define shape volumes!\n    //      To use, just uncomment and see what happens :)\n    // Choose your favorite and roll with it!\n    //========================================================\n    float sdf;\n    // output to screen\n    sdf = circle(uv, 0.6);\n    // sdf = screenSplit(uv, vec2(0.0, 1.0));\n    // sdf = box(uv, vec2(0.5, 0.5));\n    // sdf = line(uv, vec2(-0.7, -0.7), vec2(0.7, 0.7));\n    // sdf = equilateralTriangle(uv);\n    // sdf = star5(uv, 0.8, 0.4);\n    // sdf = moon(uv, 0.3, 0.8, 0.6);\n    // sdf = heart(uv);\n    // sdf = shapeCross(uv, vec2(1.0, 0.3), 0.2);\n    // sdf = roundedX(uv, 1.0, 0.15);\n\n    // You can distort your signed distance fields to make funky shapes!\n    //  These functions will make your shapes do weird stuff. Uncomment them to try it out!\n    //========================================================\n    // sdf = makeOnionRing(sdf, 0.02);\n    // sdf = makeInfiniteOnionRings(sdf, 0.3, 0.03);\n\n    // You can BLEND multiple distance fields together! Try uncommenting some of these out \n    //  for an example, but feel free to build your own!\n    //========================================================\n    // sdf = cutOutShape(sdf, star5(uv, 0.8, 0.4)); // This will cut a star out of your shape using the same coordiate space!;\n    // sdf = cutOutShape(sdf, star5(createInitialUVs(fragCoord), 0.8, 0.4)); // This will cut a star out of your shape using a DIFFERENT coordiate space!;\n    // sdf = addShape(sdf, equilateralTriangle(uv)); // This will add a triangle to our shape!\n    // sdf = addShape(sdf, star5(uv, 0.8, 0.5)); // This will add a star to our shape!\n    // sdf = intersectShape(sdf, equilateralTriangle(uv)); // This will turn our shape into the intersect of a triangle and our shape!\n    // sdf = intersectShape(sdf, heart(uv)); // This will turn our shape into the intersect of a heart and our shape!\n    // sdf = blendShape(sdf, box(uv, vec2(1.0, 0.1)), 32.0); // This will SMOOTHLY blend our shape with a box!\n    // sdf = blendShape(sdf, equilateralTriangle(uv), 32.0); // This will SMOOTHLY blend our shape with a triangle!\n    // sdf = invertShape(sdf, equilateralTriangle(uv)); // Flips the shape whenever the second sdf is < 0\n\n    // You can animate your field as well!! These will animated by blending between other fields\n    //========================================================\n    // sdf = simpleMorph(sdf, box(uv, vec2(0.5, 0.5)), 2.0); // This will morph your shape into a box and back!\n    // sdf = simpleMorph(sdf, moon(uv, 0.3, 0.8, 0.6), 2.0); // This will morph your shape into a moon and back!\n    // sdf = simpleMorph(sdf, heart(uv), 1.0); // This will morph your shape into a heart and back (sdf..)\n\n    // These are spicy little examples of animating the blends and cutouts!\n    //========================================================\n    // sdf = addAMovingCircle(sdf, uv);\n    // sdf = subtractAMovingBar(sdf, uv);\n    // sdf = specklyGloopify(sdf, uv);\n\n    ////////////////////////////////////////////////////////\n    // DO COLORS HERE\n    ////////////////////////////////////////////////////////\n    vec3 white = vec3(1.0);\n    vec3 black = vec3(0.0);\n    vec3 red = vec3(0.9, 0.1, 0.0);\n    vec3 green = vec3(0.0, 0.9, 0.1);\n    vec3 blue = vec3(0.1, 0.0, 0.9);\n    vec3 magenta = vec3(0.9, 0.1, 1.0);\n    vec3 yellow = vec3(0.9, 1.0, 0.1);\n    vec3 cyan = vec3(0.1, 0.9, 1.0);\n    vec3 sdfRainbow = hueToRgb(-sdf);\n    vec3 screenRainbow = fullscreenRainbow(fragCoord); // This makes a screen space rainbow!\n\n    // fragColor = sdfDebug(sdf); // This is just for my SDF debugging :) Use it if you think it looks cool!\n    // fragColor = singleTone(sdf, green); //  Make a single color using the sdf!\n    // fragColor = singleTone(sdf, screenRainbow); //  Turn the sdf into a fullscreen rainbow!\n    // fragColor = twoTone(sdf, blue, magenta); // Use the field to blend between two colors! feel free to change these :)\n    // fragColor = fourTone(sdf, blue, magenta, blue, yellow); // Use the field to blend between four colors! feel free to change these :)\n    fragColor = testChamberVibes(sdf, fragCoord);\n    // fragColor = hyperRainbow(sdf); // Make a super rainbow from your sdf!\n    // fragColor = starrySpaceyVibes(sdf, fragCoord);\n}","name":"Image","description":"","type":"image"}]}