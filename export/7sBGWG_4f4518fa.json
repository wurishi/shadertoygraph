{"ver":"0.1","info":{"id":"7sBGWG","date":"1617875516","viewed":46,"name":"quatre-tests","username":"quatreb","description":"quatre's tests in raymarching","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","kgig"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat dist_field(in vec3 p) {\n\n    vec4 center = vec4(vec3(0.), 1.5);\n    float angle = mod(iTime * 100., 360.) * DEG_TO_RAD;\n    \n    vec3 sphere = vec3(0., 1., .5) * rotateY(angle);\n    vec3 cube = vec3(0., 1., .5) * rotateY(angle);\n    vec3 plane = vec3(0., 1.5, 0.);\n    \n    float c = sphereSDF(p, center);\n    float pln = planeSDF(p, plane, 10.);\n    float base = unionSDF(pln, c);\n    \n    float sph = sphereSDF(p, vec4(sphere, 2.6));\n    float cb = cubeSDF(p, vec4(cube, 2.));\n    \n    return unionSDF(base, differenceSDF(cb, sph));\n}\n\nfloat rayMarch(in vec3 ro, in vec3 rd, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 pos = ro + depth * rd;\n\n        float dist = dist_field(pos);\n        \n        if (dist < EPSILON) return depth;\n        depth += dist;\n        if (depth >= end) return end;\n    }\n    return end;\n}\n\nfloat Kd = .7, Ks = .33, Ka = .26;\n\nvec3 shading(in vec3 pos, in vec3 n, vec3 ro, vec3 rd) {\n\n    vec3 backColor = vec3(.66) * Ka;\n\n    vec3 diff;\n    {\n        vec3 difPos = vec3(-3., 1., -4.);\n        vec3 difColor = vec3(.66, .44, .66);\n        \n        float cTetta = dot(n, -rd) / length(n) / length(-rd);\n        float cPhi = dot(n, difPos) / length (n) / length(difPos);\n\n        diff = difColor * Kd * cTetta * cPhi;\n    }\n    \n    vec3 spec;\n    {\n        float p = 200.;//1. * mod(iTime * .1, 201.);\n        vec3 specPos = vec3(3., 2., -4.);\n        vec3 specColor = vec3(.11, .88, .66) * 2.;\n        \n        vec3 s_rf = reflect(specPos, n);\n\n        //float cTetta  = dot(n, -rd) / length(n) / length(-rd);\n        //float cPhi = dot(n, s_rf) / length(n) / length(specPos);\n        float cAlpha = dot(s_rf, rd) / length(s_rf) / length(rd);\n\n        spec = specColor * Ks * pow(cAlpha, p);\n    }\n    \n    \n    return backColor + diff + spec;\n\n    //vec3 back_color = vec3(.33, .33, .33);\n\n    //vec3 diffuse_pos = vec3(-5., -4., -2.);\n    //vec3 diffuse_color = vec3(.8, .1, .8);\n\n    //float c_tetta = dot(n, pos) / length(n) / length(pos);\n    //float c_phi = dot(n, diffuse_pos) / length(n) / length(diffuse_pos);\n    \n    //return back_color * Ka + diffuse_color * Kd * c_tetta * c_phi;\n}\n\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3( GRAD_STEP, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, GRAD_STEP, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, GRAD_STEP );\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist_field( pos + dx ) - dist_field( pos - dx ),\n\t\t\tdist_field( pos + dy ) - dist_field( pos - dy ),\n\t\t\tdist_field( pos + dz ) - dist_field( pos - dz )\t\t\t\n\t\t)\n\t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - vec2(1.0);\n\tuv.x *= iResolution.x / iResolution.y;\n    \n    vec3 rayOrigin = vec3(0., .5, -4.5);\n    vec3 rayDirection = normalize(vec3(uv, 1.0));\n    \n    mat3 camRotate = rotationXY( ( iMouse.xy - iResolution.xy * 0.5 ).yx * vec2( 0.01, -0.01 ) );\n    \n    if (iMouse.xy == vec2(0.)) \n    {\n        float deg = 20.;\n        rayOrigin *= rotateX(deg * DEG_TO_RAD);\n        rayDirection *= rotateX(deg * DEG_TO_RAD);\n    }\n    else\n    {\n        rayOrigin *= camRotate;\n        rayDirection *= camRotate;\n    }\n    \n    float dist = rayMarch(rayOrigin, rayDirection, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0., 0., 0., 0.);\n        return;\n    }\n    \n    vec3 pos = rayOrigin + dist * rayDirection;\n    vec3 n = normalize(gradient(pos));\n    vec3 col = shading(pos, n, rayOrigin, rayDirection);\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_MARCHING_STEPS 300\n#define MIN_DIST 0.0\n#define MAX_DIST 200.0\n#define EPSILON 0.00001\n#define GRAD_STEP 0.02\n\n#define intersectSDF(x, y) max(x, y)\n#define unionSDF(x, y) min(x, y)\n#define differenceSDF(x, y) max(x, -y)\n\nfloat planeSDF(in vec3 p, vec3 n, float h) {\n    return dot(p, n) + h;\n}\n\nfloat sphereSDF(in vec3 p, vec4 sph) {\n    return length(p - sph.xyz) - sph.w;\n}\n\nfloat cubeSDF(in vec3 p, vec4 c) {\n    vec3 q = abs(p - c.xyz) - c.w;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nmat3 rotateX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return mat3(\n        1, 0, 0,\n        0, c, -s,\n        0, s, c\n    );\n}\n\nmat3 rotateY(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return mat3(\n        c, 0, s,\n        0, 1, 0,\n       -s, 0, c\n    );\n}\n\nmat3 rotateZ(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return mat3(\n        c, -s, 0,\n        s,  c, 0,\n        0,  0, 1\n    );\n}\n\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}","name":"Common","description":"","type":"common"}]}