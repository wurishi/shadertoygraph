{"ver":"0.1","info":{"id":"fsjcWW","date":"1643569939","viewed":344,"name":"Planet Unknown","username":"omegasbk","description":"Just had some weekend fun.","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["sdf","planet"],"hasliked":0,"parentid":"7dVXDR","parentname":"Cookbook - SDF Sphere"},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 30.01.2022.\n// Made by Darko Supe (omegasbk)\n\n#define MAX_STEPS 100\n\n#define MAX_DIST 100.\n#define MIN_DIST 0.0002\n\n#define PI 3.14159265359\n\nint shape = 0;\n\nconst vec3 planetCenter = vec3(vec3(0.));\nconst float planetRadius = 0.9;\nconst vec3 lightColor = vec3(0.9, 0.9, 1.0);\nconst float lightIntensity = 1.5;\n\nvec3 rotate(in vec3 p, in float angle)\n{\n    mat3 m = mat3(\n        cos(angle),  sin(angle), 0.,  \n        -sin(angle), cos(angle), 0.,  \n        0.,                  0., 1.  \n    ); \n    \n    return p * m;\n}\n\nvec2 getSphereCoords(in vec3 normal)\n{\n    vec2 coords = vec2((atan(normal.x, normal.z) / PI) / 2.,\n                       (asin(normal.y) / PI + 0.5));  \n                \n    return coords;  \n}\n\nfloat getDepth(in vec3 normal)\n{                              \n    vec2 depthCoords = getSphereCoords(normal);\n    return texture(iChannel0, fract(depthCoords  * 2.)).r / 100.\n    + texture(iChannel0, fract(depthCoords  * 70.)).r / 1000.\n    + texture(iChannel1, fract(depthCoords  * 10.)).r / 500.;   \n}\n\nfloat noise(vec2 uv)\n{\n    return fract(sin(uv.x * 113. + uv.y * 412.) * 6339.);\n}\n\nvec3 noiseSmooth(vec2 uv)\n{\n    vec2 index = floor(uv);\n    \n    vec2 pq = fract(uv);\n    pq = smoothstep(0., 1., pq);\n     \n    float topLeft = noise(index);\n    float topRight = noise(index + vec2(1, 0.));\n    float top = mix(topLeft, topRight, pq.x);\n    \n    float bottomLeft = noise(index + vec2(0, 1));\n    float bottomRight = noise(index + vec2(1, 1));\n    float bottom = mix(bottomLeft, bottomRight, pq.x);\n    \n    return vec3(mix(top, bottom, pq.y));\n}\n\nfloat sdfPlanet(vec3 c, float r, vec3 p)\n{\n    return distance(p, c) - r - getDepth(normalize(p - c));\n}\n\nfloat sdfAtmosphere(vec3 c, float r, vec3 p)\n{    \n    return distance(p, c) - r;\n}\n\nfloat getDist(vec3 p)\n{\n    float dist = 0.;\n    \n    if (shape == 0)\n    {\n        p = rotate(p.zyx, iTime / 40.);\n        dist = sdfPlanet(planetCenter, planetRadius, p);\n    }\n    else if (shape == 1)\n        dist = sdfAtmosphere(vec3(0.), planetRadius + 0.011, p);\n    else if (shape == 2)\n        dist = sdfAtmosphere(vec3(0.), planetRadius + 0.08, p);\n\n    return dist;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd)\n{\n    float dist = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 itPos = ro + rd * dist;\n        float itDist = getDist(itPos);\n        \n        dist += itDist;\n        \n        if (dist > MAX_DIST || dist < MIN_DIST)  \n            break;\n    }    \n    \n    return dist;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(0.01, 0.);    \n    return normalize(vec3(getDist(p + e.xyy), getDist(p + e.yxy), getDist(p + e.yyx)));    \n}\n\nvec3 getLight(in vec3 p, in vec3 rd, float ambiant, float diff, float shininess)\n{    \n\tvec3 normal = getNormal(p);\n    const vec3 lightPos = planetCenter + vec3(10., 4., 20.);\n    \n    vec3 lightDir = normalize(p - lightPos);   \n    \n    float cosa = pow(0.5+0.5*dot(normal, -lightDir), 3.0);\n    float cosr = max(dot(-rd, reflect(lightDir, normal)), 0.0);\n    \n    vec3 diffuse = vec3(diff * cosa);\n    vec3 phong = vec3(0.5 * pow(cosr, shininess));\n    \n    return lightColor * (vec3(ambiant) + diffuse + phong) * lightIntensity;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float focalDist = 1.5;\n    vec3 ro = vec3(0.65, 0.6, -1.3);\n    vec3 rd = vec3(uv.x, uv.y, focalDist);  \n    rd = rotate(rd, 0.3);\n    \n    vec3 col = texture(iChannel2, uv * 1.1).rgb * max(0., -uv.y - 0.25) * 1.6;\n    col += vec3(step(0.9995, noise(uv / 10.))) * (uv.y + 0.5);\n    float dist = 0.;\n        \n    shape = 2; // Glow\n    dist = rayMarch(ro, rd);\n    if (dist < MAX_DIST)\n    {\n        vec3 pHit = ro + rd * dist;\n        vec3 n = getNormal(pHit);\n        col += vec3(0., 0.68, 1.) * smoothstep(0.35, 0.8, -dot(rd, n));\n    }   \n    \n    shape = 0; // Planet\n    dist = rayMarch(ro, rd);\n    if (dist < MAX_DIST)\n    {\n        vec3 pHit = ro + rd * dist;\n        \n        float altitude = distance(pHit, planetCenter) - planetRadius;\n        col = vec3(0.2, 0.5, 0.2);\n\n        vec2 planetCoord = getSphereCoords(normalize(rotate(pHit.zyx, iTime / 40.) - planetCenter));\n        col += texture(iChannel0, planetCoord * 8.).r * texture(iChannel1, planetCoord * 12.).rbg * 1.5;\n\n        if (altitude < 0.0042)\n            col += smoothstep(-.01, 0.01, altitude) * vec3(0.5, 0.4, 0.3);\n            \n        if (altitude < 0.004) // Sea\n        {\n            col = vec3(0.2, 0.5, 0.8);\n            pHit = normalize(pHit - planetCenter) * planetRadius;\n            col *= vec3(getLight(pHit, rd, 0.2, 0.5, 1.));\n        }\n        else\n        {\n            col *= vec3(getLight(pHit, rd, 0.2, 0.6, 0.4)) / 1.4;\n        }\n                   \n        col = mix(col, vec3(0.9, 0.9, 1.), 0.14);\n    }   \n    \n    shape = 1; // Clouds\n    dist = rayMarch(ro, rd);\n    if (dist < MAX_DIST)\n    {\n        vec3 pHit = ro + rd * dist;\n        \n        vec2 cloudCoord = getSphereCoords(normalize(pHit - planetCenter));\n    \n        cloudCoord += iTime / 200.;\n         \n        vec3 clouds = vec3(0.05);\n        clouds += noiseSmooth(cloudCoord  * 16.) * 0.5;\n        clouds += noiseSmooth(cloudCoord * 32.) * 0.25;\n        clouds += noiseSmooth(cloudCoord * 64.) * 0.125;\n        clouds = smoothstep(0.0, 0.85, clouds);\n        \n        col = mix(col, clouds / 1.04, smoothstep(0.5, 1., clouds)) * 1.1;\n        col *= vec3(getLight(pHit, rd, 0.25, 0.1, 3.8)) / 2.2;\n    }   \n    \n    \n    vec2 sunPos = uv - vec2(0.7, 0.3);\n    col += (1. - smoothstep(0.001, 0.76, length(sunPos))) * vec3(0.9, 0.9, 1.) \n        * clamp(texture(iChannel0, vec2(iTime / 50., 0.)).r, 0.2, 0.5);\n    col += (1. - smoothstep(0.001, 0.2, length(sunPos))) * vec3(1.3, 1., 1.);\n\n\n    vec3 rays = \n    \n    vec3(step(0.998, abs(dot(normalize(sunPos), vec2(0., 1.)))))\n    + vec3(step(0.9992, abs(dot(normalize(sunPos), normalize(vec2(0.5, 0.5))))))\n    + vec3(step(0.9997, abs(dot(normalize(sunPos), normalize(vec2(0.2, 0.0))))))\n    - (smoothstep(0., 0.46, length(sunPos)));\n    rays = clamp(rays * texture(iChannel0, vec2(iTime / 50., 0.)).r, 0., 1.);\n    \n    col += rays / 13.;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}