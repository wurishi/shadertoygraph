{"ver":"0.1","info":{"id":"ftlXz8","date":"1625142789","viewed":124,"name":"glsl-line-rast","username":"kusma","description":"A GLSL line rasterizer\n\nHandles diamond exit-rule rasterization apart for at the end-points.\n\nVisualizes hierarchical rasterization details.\n\nTODO:\n- Z / W interpolation\n- Correct end-point according to diamond-exit\n- More modes","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["rasterizer","line"],"hasliked":0,"parentid":"7tXGDr","parentname":"glsl-tri-rast"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int scale = 4;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, (fragCoord.xy / iResolution.xy) / float(scale));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"int scale = 4;\nconst bool rect = false;\n\n// #define DEBUG_HIZ\n// #define DEBUG_BBOX\n\nconst int SUBPIXEL_BITS = 4;\n\nconst float lineWidth = 1.0;\n\nint round_to_subpixel(float v)\n{\n    return int(floor(v * float(1 << SUBPIXEL_BITS) + 0.5));\n}\n\nstruct primitive {\n    vec2 bmin, bmax; // bounding box\n    \n    ivec3 e[4]; // edge functions\n\n    // z, w, and barycentric interpolants\n    vec3 fz, fw, ft;\n};\n\nvoid calc_bbox(vec4 verts[2], out vec2 bmin, out vec2 bmax)\n{\n    bmin = iResolution.xy;\n    bmax = vec2(0);\n    for (int i = 0; i < 2; ++i) {\n        bmin = min(bmin, verts[i].xy);\n        bmax = max(bmax, verts[i].xy);\n    }\n}\n\n/* Clips the line to the frustum.\n * We do this because external rasterization is a bit\n * involved for lines, but clipping them is trivial.\n *\n * This is still a bit naive, and can probably be optimized\n * a bunch (calculate min/max t once, instead of clipping\n * over and over again?).\n */\nbool clip_line(inout vec4 verts[2], inout vec4 attrs[2])\n{\n    vec4 planes[6];\n    planes[0] = vec4(-1.0, 0.0, 0.0, 1.0);\n    planes[1] = vec4( 1.0, 0.0, 0.0, 1.0);\n    planes[2] = vec4(0.0, -1.0, 0.0, 1.0);\n    planes[3] = vec4(0.0,  1.0, 0.0, 1.0);\n    planes[4] = vec4(0.0, 0.0, -1.0, 1.0);\n    planes[5] = vec4(0.0, 0.0,  1.0, 1.0);\n\n    for (int i = 0; i < 6; ++i) {\n        vec2 dist = vec2(dot(verts[0], planes[i]), dot(verts[1], planes[i]));\n        \n        bvec2 inside = greaterThan(dist, vec2(0.0));\n\n        /* trivial case; neither vertices are inside */\n        if (!any(inside))\n           return false;\n\n        /* trivial case; both vertices are inside */\n        if (all(inside))\n           continue;\n\n        /* clipping lines don't produce new vertices, so\n         * we can just overwrite. */\n        float t = dist.x / (dist.x - dist.y);\n        if (!inside.x) {\n           verts[0] = mix(verts[0], verts[1], t);\n           attrs[0] = mix(attrs[0], attrs[1], t);\n        } else {\n           verts[1] = mix(verts[0], verts[1], t);\n           attrs[1] = mix(attrs[0], attrs[1], t);\n        }\n    }\n\n    return true;\n}\n\nbool setup_line(vec4 verts[2], float lineWidth, out primitive result)\n{\n    vec2 d = verts[1].xy - verts[0].xy;\n\tfloat length_squared = dot(d, d);\n    if (length_squared == 0.0)\n        return false;\n\n    calc_bbox(verts, result.bmin, result.bmax);\n\n\n    ivec2 tmp = ivec2(round_to_subpixel(+d.y),\n                      round_to_subpixel(-d.x));\n    int dist = (tmp.x * round_to_subpixel(-verts[1].x)) +\n               (tmp.y * round_to_subpixel(-verts[1].y));\n\n    // store as twice SUBPIXEL_BITS fractional part to avoid rounding\n    ivec3 e0 = ivec3(tmp << SUBPIXEL_BITS, dist);\n    ivec3 e[4];\n    e[0] = e0;\n    e[1] = ivec3(-e0.xy, -e0.z);\n\n    if (rect) {\n        // adjust line-functions for line-width\n        vec2 t = normalize(d).yx * vec2(1, -1);\n        t *= lineWidth * 0.5;\n        int dist1 = (tmp.x * round_to_subpixel(-t.x)) +\n                    (tmp.y * round_to_subpixel(-t.y));\n        e[0].z -= dist1;\n        e[1].z -= dist1;\n\n        // start / end line-functions\n        ivec2 tmp2 = -e0.yx * ivec2(1,-1);\n        tmp2 >>= 4; // uggh, seems we overflow without this, not sure why...\n        int dist2 = (tmp2.x * round_to_subpixel(-verts[0].x)) +\n                    (tmp2.y * round_to_subpixel(-verts[0].y));\n        ivec2 tmp3 = -tmp2;\n        int dist3 = (tmp3.x * round_to_subpixel(-verts[1].x)) +\n                    (tmp3.y * round_to_subpixel(-verts[1].y));\n        e[2] = ivec3(tmp2 << SUBPIXEL_BITS, dist2);\n        e[3] = ivec3(tmp3 << SUBPIXEL_BITS, dist3);\n\n        // adjust bbox for line-width\n        vec2 tb = abs(t);\n        result.bmin -= tb;\n        result.bmax += tb;\n    } else {\n        int width = round_to_subpixel(lineWidth);\n        int halfWidth = round_to_subpixel(lineWidth * 0.5);\n\n        const bool replicate_attrs = true;\n        ivec2 major_range;\n        if (abs(tmp.y) > abs(tmp.x)) {\n            ivec2 offset = (e0.y * ivec2(halfWidth, width)) >> SUBPIXEL_BITS;\n            offset.y -= offset.x;\n            if (tmp.y <= 0)\n                offset = -offset;\n\n            e[0].z += offset.x;\n            e[1].z += offset.y + 1;\n\n            major_range = ivec2(round_to_subpixel(verts[0].x),\n                                round_to_subpixel(verts[1].x));\n\n            e[2] = ivec3( (1 << SUBPIXEL_BITS), 0, 0);\n            e[3] = ivec3(-(1 << SUBPIXEL_BITS), 0, 0);\n\n            if (replicate_attrs) {\n                // use \"ideal\" line attribute interpolation\n                d.x = dot(d, d) / d.x;\n                d.y = 0.0;\n            }\n\n            result.bmin.y -= lineWidth * 0.5;\n            result.bmax.y += lineWidth * 0.5;\n        } else {\n            // y-major\n            ivec2 offset = (e0.x * ivec2(halfWidth, width)) >> SUBPIXEL_BITS;\n            offset.y -= offset.x;\n            if (tmp.x <= 0)\n                offset = -offset;\n\n            e[0].z += offset.x;\n            e[1].z += offset.y + 1;\n\n            major_range = ivec2(round_to_subpixel(verts[0].y),\n                                round_to_subpixel(verts[1].y));\n\n            e[2] = ivec3(0,  (1 << SUBPIXEL_BITS), 0);\n            e[3] = ivec3(0, -(1 << SUBPIXEL_BITS), 0);\n\n            if (replicate_attrs) {\n                // use \"ideal\" line attribute interpolation\n                d.y = dot(d, d) / d.y;\n                d.x = 0.0;\n            }\n\n            result.bmin.x -= lineWidth * 0.5;\n            result.bmax.x += lineWidth * 0.5;\n        }\n\n        e[2].z = -min(major_range.x, major_range.y);\n        e[3].z = +max(major_range.x, major_range.y);\n    }\n\n    result.e[0] = e[0];\n    result.e[1] = e[1];\n    result.e[2] = e[2];\n    result.e[3] = e[3];\n\n    result.ft = vec3(d, dot(-d, verts[0].xy)) / length_squared;\n    \n    // TODO: setup these:\n    result.fz = vec3(0.0);\n    result.fw = vec3(0.0);\n\n    return true;\n}\n\nint eval_edge(ivec3 e, ivec2 pos)\n{\n    return e.x * pos.x + e.y * pos.y + e.z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if 1\n    float th1 = iTime * 0.05, th2 = iTime * 0.05 + 3.1415926;\n    vec4 verts[2] = vec4[2](\n        vec4(sin(th1), cos(th1), 0.0, 1.0),\n        vec4(sin(th2), cos(th2), 0.0, 1.0)\n    );\n#else\n    /* this tests the clipped case, which is currently broken */\n    vec4 verts[2] = vec4[2](\n        vec4(-0.75, -0.75, 0.0, 1.0),\n        vec4( 0.00,  0.75, 1.0, 1.0)\n    );\n    verts[1].w = 0.5 + 1.75 * sin(3.25 + 0.25 * iTime);\n#endif\n\n    vec4 attrs[2] = vec4[2](\n        vec4(0.0, 1.0, 0.0, 0.0),\n        vec4(1.0, 0.0, 0.0, 0.0)\n    );\n\n    if (!clip_line(verts, attrs)) {\n        fragColor = vec4(0.5, 0.5, 0.0, 1.0);\n        return;\n    }\n\n\n    // *** per vertex\n\n    vec2 size = iResolution.xy / float(scale);\n\n    // viewport map\n    for (int i = 0; i < 2; ++i) {\n        float w_rcp = 1.0 / verts[i].w;\n        vec3 tmp = verts[i].xyz * w_rcp;\n        verts[i].xy = size * 0.5 + tmp.xy * size * 0.5;\n        verts[i].z = tmp.z;\n        verts[i].w = w_rcp;\n    }\n\n    // *** per primitive\n\n    primitive prim;\n    if (!setup_line(verts, lineWidth, prim)) {\n        fragColor = vec4(0.5, 0.0, 0.0, 1.0);\n        return;\n    }\n\n\n    /* this really belongs elsewhere, but it's cleaner to color here */\n    if (any(lessThan(fragCoord.xy, floor(prim.bmin.xy))) ||\n        any(greaterThan(fragCoord.xy, ceil(prim.bmax.xy)))) {\n#ifdef DEBUG_BBOX\n        fragColor = vec4(0.0, 0.5, 0.5, 1.0);\n#endif\n        return;\n    }\n\n    // *** per tile\n\n    /* just proof-of-concept: conservative\n     * block-rasterizing, for hierarchial\n     * rasterization (and could be repurposed\n     * for normal conservative rasterization)\n     */\n    ivec4 de, ne;\n    for (int i = 0; i < 4; ++i) {\n        de[i] = max(prim.e[i].x, 0) + max(prim.e[i].y, 0);\n        ne[i] = prim.e[i].x + prim.e[i].y - de[i];\n    }\n\n#ifdef DEBUG_HIZ\n    fragColor = vec4(1.0);\n#endif\n    for (int i = 6; i > 0; i--) {\n        ivec2 hpos = ivec2(fragCoord.xy) & ~((1 << i) - 1);\n        ivec4 d;\n        for (int j = 0; j < 4; ++j)\n            d[j] = eval_edge(prim.e[j], hpos);\n\n        bool fully_outside = any(lessThan(d + (de << i), ivec4(0)));\n        if (fully_outside) {\n#ifdef DEBUG_HIZ\n            fragColor[i % 3] *= 0.875 / float(1 + i / 3);\n#endif\n            return;\n        }\n\n        bool fully_inside = all(greaterThan(d + (ne << i), ivec4(0)));\n        if (fully_inside) {\n#ifdef DEBUG_HIZ\n            fragColor[i % 3] *= 0.875 / float(1 + i / 3);\n#endif\n            break;\n        }\n    }\n\n    // *** per pixel\n\n    ivec2 pos = ivec2(fragCoord.xy);\n\tint d0 = eval_edge(prim.e[0], pos);\n\tint d1 = eval_edge(prim.e[1], pos);\n\tint d2 = eval_edge(prim.e[2], pos);\n\tint d3 = eval_edge(prim.e[3], pos);\n\n    if (min(min(d0, d1), min(d2, d3)) > 0) {\n        float t = dot(prim.ft, vec3(pos, 1));\n#if 1\n        // float z = dot(prim.fz, vec3(pos, 1));\n        float z = mix(verts[0].z, verts[1].z, t);\n\n        if (z < 0.0 || z > 1.0) {\n            fragColor = vec4(0.0, 0.0, 0.5, 1.0);\n            return;\n        }\n#endif\n#if 0\n        float w = 1.0 / dot(prim.fw, vec3(pos, 1));\n        i *= w;\n#endif\n        // interpolate a single vec4 varying\n        vec4 var = mix(attrs[0], attrs[1], t);\n\n        // vec4 tmp = vec4(textureLod(iChannel0, var.xy, 0.0).xyz, 1.0);\n        vec4 tmp = var;\n#if 0\n        tmp.xyz = mix(tmp.xyz, vec3(0.5), 1.0 / (1.0 + z));\n#endif\n\n#ifdef DEBUG_HIZ\n    fragColor *= tmp;\n#else\n    fragColor = tmp;\n#endif\n\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}