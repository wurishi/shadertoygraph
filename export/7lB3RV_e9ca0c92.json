{"ver":"0.1","info":{"id":"7lB3RV","date":"1624260531","viewed":56,"name":"Shapey Thangs Just Stewin","username":"Makeavoy","description":"More weird shape things","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"ft23zG","parentname":"Metal Goo"},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Most foundational code built from the Art of Code tutorials https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nvec2 smin(float a,float b, float smoothing){\nfloat slope=clamp(.5+.5*(b-a)/smoothing,0.,1.);\n//float ease=slope*(1.-slope); //good boolean intersect\n//return slope*a+(1.-slope)*b-ease*.5;\nreturn vec2(mix(b,a,slope) - smoothing*slope*(1.-slope),slope);\n}\n\nmat2 rot(float a){\n    float s=sin(a);float c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z){\n//l.x+=6.*sin(p.z*14.2);\n    //z=sin(p.y)*4.; warpy\n    vec3 f = normalize(l-p),\nr=normalize(cross(vec3(0,1,0),f)),\nu=cross(f,r),\nc=f*z,\ni=c+uv.x*r + uv.y*u,\nd=normalize(i);\nreturn d;\n}\n\nfloat sdPill(vec3 p,vec3 a, vec3 b, float r){\n    //float v=floor(sin(p.x*4.)*2.)*(1.+cos(iTime));//floor(sin(p.x*2.)*4.)*2;\n    vec3 offset=vec3(0,0,0);//+vec3(round(1.*abs(cos(iTime+p.x*2.))),0,0);\n    a+=offset;\n    b+=offset;\n    vec3 ab=b-a;\n    vec3 ap=p-a;\n    float t = dot(ab,ap) /dot(ab,ab); //length(ab) works too but doestn connect\n    t=clamp(t,0.,1.);\n    vec3 c = a+ t*ab;\n    return length(p-c) -r;\n}\n\nfloat sdSphere(vec3 p,vec3 a, float r){\nreturn length(p-a) - r;\n}\n\nfloat sdTorus(vec3 p,vec2 r){\n    float i=length(p.xy)-r.x;\n    return length(vec2(i,p.z)) - r.y;\n}\n\nfloat sdBox(vec3 p, vec3 a){\n    return length(max(abs(p)-a,0.)) -.2;\n}\n\nfloat sdOctahedron( vec3 p, float s){\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nvec2 getDist(vec3 p){\n    \n    vec3 a=vec3(4.,cos(iTime)*.5,2);//vec3(cos((p.y+iTime)*20.)/8.,sin(p.y*3.+iTime*3.)*2.+1.,6); //vec3(0,1,4);//\n    vec3 b=vec3(3.,cos(iTime*2.),-4.);\n    vec3 c=vec3(-3,0,2);\n\n    float sphere=sdSphere(p,a,1.)*.5;//sdPill(p,a,b,1.);\n    vec3 turn=(p+b);\n    mat2 rotVal= rot(iTime);\n    turn.xz*=rotVal;\n    float box=sdBox(turn,vec3(1,1,1));\n    turn=(p+c);\n    turn.xy*=rotVal;\n    float octa=sdOctahedron(turn,1.);\n    float bulbs=(smoothstep(.03,0.0,cos(sin(2.*(p.z+iTime*2.))+p.x*4.)*.02)*1.);\n    float planeDist=p.y+.92;\n    //float d=smin(sphereD,torusD,.5);\n    \n    float blend=clamp(0.,sin(iTime),1.);\n    vec2 mix1=smin(sphere,octa,blend);\n    vec2 mix2=smin(box,mix1.x,blend);\n    vec2 mix3=smin(planeDist,mix2.x,blend);\n       \n    vec2 mix4=smin(bulbs,mix3.x,.5*blend+.5);\n    //float d=d2.x;\n    //float last=mix4.y>.5?4.:(mix3.y>.5?3.:(mix2.y>.5?2.:(mix1.y>.5?1.:0.)));\n    float last=mix4.y>(.2+sin(iTime*4.)*0.1)?4.:\n    (mix3.y>.9?2.+(mix3.y):\n    (mix2.y>.9?1.+(mix2.y):\n    (mix1.y>.001?1.:0.) ));\n    return vec2(mix4.x,last); //mix1.y+mix2.y+mix3.y+mix4.y\n}\n\nvec4 rayMarch(vec3 ro, vec3 rd){\n    int i=0;\n    float dO=0.;\n    float glowDist = 1e9;\n    for(i=0;i<MAX_STEPS;i++){\n        vec3 p = ro +rd*dO;\n        float dS =getDist(p).x;\n        glowDist = min(glowDist, dS);\n        dO+=dS;\n        if(dO>MAX_DIST || dS<SURF_DIST)break;\n    }\n    /*if (getDist(ro +rd*dO).x < SURF_DIST){\n        float col = (1.0 - float(i)/float(MAX_STEPS));\n        return vec4(col, 0.0, 0.0,dO);\n    }else{\n        float v=max((0.05 - glowDist)*20.0, 0.0);\n        return vec4(v,v,v,dO);\n    }*/\n    \n    return vec4(1,1,1,dO);\n}\n\nvec4 getNormal(vec3 p){\n    vec2 distOut=getDist(p);\n    float dist=distOut.x;\n    vec2 e=vec2(0.01,0);\n    vec3 n = dist - vec3(getDist(p-e.xyy).x,getDist(p-e.yxy).x,getDist(p-e.yyx).x);\n    return vec4(normalize(n),distOut.y);\n}\n\n//https://gist.github.com/patriciogonzalezvivo/20263fe85d52705e4530\nvec3 getTriPlanarBlend(vec3 _wNorm){\n\t// in wNorm is the world-space normal of the fragment\n\tvec3 blending = abs( _wNorm );\n\tblending = normalize(max(blending, 0.00001)); // Force weights to sum to 1.0\n\tfloat b = (blending.x + blending.y + blending.z);\n\tblending /= vec3(b, b, b);\n\treturn blending;\n}\n\nvec3 getLight(vec3 p){\n    vec3 lightPos=vec3(cos(-iTime*2.)*3.,5,sin(iTime)); // 0 5 6 \n    vec3 l =normalize(lightPos-p);\n    vec4 nOut = getNormal(p);\n    vec3 n=nOut.rgb;\n    float diff=clamp(dot(l,n),0.,1.);\n    vec4 distOut=rayMarch(p+n*SURF_DIST*2.,l);\n    float dist=distOut.w;\n    if(dist<length(lightPos -p)) diff*=0.6;\n    \n    float normalRepeat=.2;\n    float normalScale=2.; \n    vec3 blending = getTriPlanarBlend(n);\n\tvec3 xaxis = texture( iChannel1, p.yz * normalRepeat).rgb;\n\tvec3 yaxis = texture( iChannel1, p.xz * normalRepeat).rgb;\n\tvec3 zaxis = texture( iChannel1, p.xy * normalRepeat).rgb;\n\tvec3 normalTex = xaxis * blending.x + yaxis * blending.y + zaxis * blending.z;\n\n    normalTex=mix(vec3(.6,.8,.8),normalTex,.2); //vec3(.6,.8,.8)\n    \n    //vec4 t=texture(iChannel1,n.xy);\n    //vec3(.99,.6,4.)\n    float r=sin(p.x*1.5)*.5 +1.;\n    float b=1.-r;\n    \n    float val=mod(nOut.w,1.);\n    vec3 c=vec3(.4,.3,.9); //octa\n    if(nOut.w==1.){ //sphere\n        c=vec3(0,1.,0);\n    }else if(nOut.w==2.){ //cube\n        c=vec3(.9,.1,.2);\n    }else if(nOut.w==3.){ //plane\n        c=vec3(.8,.7,1);\n    }else if(nOut.w==4.){ //wiggle\n        c=vec3(r,0,b); \n    }\n    \n    vec3 colOut=mix(normalTex,c,.7);\n    return mix(vec3(.2,.2,.2),colOut,diff);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    //camera\n    vec3 ro=vec3(-1.+cos(iTime)*.5,6,sin(iTime)*.5-3.);\n\n    //vec3 rd=normalize(vec3(uv.x,uv.y-.4,1.));\n    vec3 rd=getRayDir(uv,ro,vec3(0,1,0),1.1);\n    \n    float dist=rayMarch(ro,rd).w;\n    \n    vec3 point = ro +rd*dist;\n    vec3 diffuse= getLight(point);\n\n    // Output to screen\n    fragColor = vec4(diffuse,1.0);\n}","name":"Image","description":"","type":"image"}]}