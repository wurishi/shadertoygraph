{"ver":"0.1","info":{"id":"XsdcRM","date":"1518229017","viewed":312,"name":"volumetric_1","username":"balkhan","description":"Sphere intersection","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raymarching","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FUDGE .25\n#define INVERT_COLOR\n\nvec3\tcam(vec2 u);\nvoid\tscene(vec3 p);\nfloat\tmylength(vec2 p);\nfloat\tmylength(vec3 p);\nvoid rotate(inout vec2 v, float angle);\n\nfloat\ttnear, tfar, step_dist;\nvec3\th;\nvec3 _ColorOne = vec3(.5, .82, .7);\nvec3 _ColorTwo = vec3(.15, .72, .7);\n\nstruct Ray\n{\n\tvec3\to;\n\tvec3\td;\n};\n\nbool\tIntersect_Sphere(Ray r, float radius, out float tnear,\nout float tfar)\n{\n    bool hit;\n    vec3\tp = r.o;\n\tfloat\tb = dot(p, r.d);\n\tfloat\tc = dot(p, p) - radius * radius;\n\t\t\tc = b * b - c;\n\tif (c < 0.0f)\n\t\t\treturn (hit = false);\n\tc = sqrt(c);\n\ttnear = -b - c > 0. ? -b - c : -b + c;\n    tfar = -b - c < 0. ? -b - c : -b + c;\n    hit = true;\n\t// check for hit\n\tif ((tnear > tfar))\n\t\thit = false;\n\telse\n\t\thit = true;\n\treturn hit;\n}\n\n// taken from : https://www.shadertoy.com/view/4lscW8\nvec3 cameraLookAt(vec3 target, vec3 camPos, vec3 up, vec2 uv, float camNear)\n{\n    vec3 axisZ = normalize(target - camPos);\n    vec3 axisX = cross(axisZ, up);\n    vec3 axisY = cross(axisX, axisZ);\n    return normalize(axisX * uv.x + axisY * uv.y + camNear * axisZ); \n}\n\n/*\n**\tLeon's mod polar from : https://www.shadertoy.com/view/XsByWd\n*/\n\n#define\tPI\t\t\t3.14159\n#define TAU\t\t\tPI*2.\n\nvec2 modA (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an*.5;\n    a = mod(a, an)-an*.5;\n    return vec2(cos(a),sin(a))*length(p);\n}\n\n/*\n**\tend mod polar\n*/\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n    h = vec3(0.);\n\tvec2 R = iResolution.xy, u = (f.xy-R.xy*.5) / R.yy;\n    o = vec4(0.);\n    vec3\tpos = vec3(.0,.0,3.);\n    vec3\tcm = cameraLookAt(vec3(.0,.0,.0), pos, vec3(.0,1.,.0), u, 1.);\n    vec2\tdist = vec2(0.);\n    vec3\tp;\n    float\tii = 0.;\n    Ray eyeray;\n    eyeray.o = pos;\n    eyeray.d = cm;\n    bool hit = Intersect_Sphere(eyeray, 1.5, tnear, tfar );\n    vec3\tpnear = eyeray.o + tnear * eyeray.d;\n\tvec3\tpfar  = eyeray.o + tfar  * eyeray.d;\n    eyeray.d = normalize(pfar-pnear);\n\teyeray.o += tnear * eyeray.d;\n\tif (tnear < 0.)\n\t\ttnear = 0.;\n    \n    vec3 lpos = vec3(0.0, -0.0, -1.250);\n\n    if (hit == true)\n    {\n\t    for (float i = 0.; i < 400.; i++)\n\t    {\n\t        p = dist.y * eyeray.d + eyeray.o;\n\t    \tdist.x = step_dist + .5/abs(tnear-tfar);\n            scene(p);\n\t        dist.y += dist.x * FUDGE;\n\t    }\n    }\n\n    o.w = 1.;\n\to.xyz = vec3(.25, .25, .5+.25*floor(sin(u.x*50.)*cos(u.y*50.) ) ); \n    if (true == hit)\n    {\n    \tvec3 normal = (normalize(pnear ));\n        o.xyz -= vec3(.1, .025, .51)*pow( abs(dot(normal, lpos ) ), 10.);\n    }\n    \n    o.xyz += h;\n}\n\nvoid\tscene(vec3 ap)\n{\n    ap.z += 3.-iTime*5.;\n    ap.yx += sin(iTime*.25)*2.*vec2(sin(iTime), cos(iTime));\n    float\tdensity = \n\t\t-\n\t\t(\n\t\t\t-length( (length(ap.xy)-.75)-2.)*1.125+\n            .25*length(texture(iChannel0, (ap*.125)+vec3(-iTime*.05,.0,.0)  ).xyz)\n            +\n            .5*length(texture(iChannel0, (ap*.0625)+vec3(-iTime*.05,.0,.0)  ).xyz)\n            +\n            .75*length(texture(iChannel0, (ap*.03)+vec3(-iTime*.05,.0,.0)  ).xyz)\n\t\t)\n        ;\n    float\td = min(abs(density)*.6-.125, 1.0);\n    step_dist = d;\n    // Can't remember where I took the base formula\n    float\tT = .125;\n    {\n        float\tbrightness = exp(-.3*d+1.);\n\t\th.xyz +=\n\t\t\t\t(1./400. )*(1./max(.0001,density*density+.00051/max(.0001, d*d+.0001) ) )\n                *\n\t\t\t\tvec3(mix(1.-_ColorOne.xyz, _ColorTwo.xyz, clamp(density, -1., 1.)) )\n\t\t\t\t*\n\t\t\t\tT\n\t\t\t\t*\n\t\t\t\tbrightness;\n    }\n}\n\nvec3\tcam(vec2 u)\n{\n    vec3\tret;\n    \n    vec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n    ret = normalize(forw * 1. + right * u.x + up * u.y);\n    return ret;\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret;\n\n    ret = max( abs(p.x)+.5*abs(p.y), abs(p.y)+.5*abs(p.x) );\n    \n    return ret;\n}\n\nfloat\tmylength(vec3 p)\n{\n\tfloat\tret;\n\n    ret = max( abs(p.x)+.5*abs(p.y), abs(p.y)+.5*abs(p.x) );\n    ret = max( ret, abs(p.z)+.5*abs(p.x) );\n    return ret;\n}\n","name":"Image","description":"","type":"image"}]}