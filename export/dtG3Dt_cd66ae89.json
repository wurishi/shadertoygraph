{"ver":"0.1","info":{"id":"dtG3Dt","date":"1684942285","viewed":126,"name":"ray tracing - one weekend - test","username":"timknip","description":"ray tracing","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","ray","metal","trace","lambertian","dielectric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if(PATH_TRACE == 1)\n        fragColor = sqrt(fragColor / fragColor.w); // cheap sRGB\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MATERIAL_LAMBERTIAN 0\n#define MATERIAL_METAL 1\n#define MATERIAL_DIELECTRIC 2\n#define DIFFUSE_LIGHT 3\n#define PATH_TRACE 0\n\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\nstruct Ray {\n\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Metal {\n    float roughness;\n};\n\nstruct Dielectric {\n      float ref_idx;\n};\n\nstruct Material {\n    int type;\n    vec3 albedo;\n    Metal metal;\n    Dielectric dielectric;\n};\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n    int material;\n};\n\n\nstruct Hit {\n    float t;\n    vec3 pt;\n    vec3 normal;\n    Sphere sphere;\n    int idx;\n};\n\nMaterial materials[] = Material[](\n    Material(MATERIAL_METAL, vec3(0.9,0.9,0.9), Metal(0.05), Dielectric(1.5)),\n    Material(MATERIAL_DIELECTRIC, vec3(0.9,0.9,0.9), Metal(0.5), Dielectric(1.5)),\n    Material(MATERIAL_DIELECTRIC, vec3(0.90, 0.76, 0.46), Metal(0.5), Dielectric(1.5)),\n    Material(MATERIAL_LAMBERTIAN, vec3(0.65, 0.77, 0.05), Metal(0.1), Dielectric(1.5)),\n    Material(MATERIAL_METAL, vec3(0.9, 0.3, 0.9), Metal(0.01), Dielectric(1.5)),\n    Material(DIFFUSE_LIGHT, vec3(0.0, 0.0, 0.0), Metal(0.01), Dielectric(1.5))\n);\n\nSphere objects[] = Sphere[](\n    Sphere(vec3(0.0, -10004.0, -20.0), 10000.0, 0),\n    Sphere(vec3(0.0, 0.0, -20.0), 4.0, 1),\n    Sphere(vec3(5.0, -2.0, -15.0), 2.0, 2),\n    Sphere(vec3(4.0, -1.0, -25.0), 3.0, 3),\n    Sphere(vec3(-3.5, -1.0, -15.0), 3.0, 4),\n    Sphere(vec3(0.0, 20.0, -30.0), 3.0, 5)\n);\n\nfloat atan2(in float y, in float x)\n{\n    bool s = (abs(x) > abs(y));\n    return mix(PI/2.0 - atan(x,y), atan(y,x), s);\n}\n\nvoid get_sphere_uv(in vec3 p, out float u, out float v) \n{\n    float theta = acos(-p.y);\n    float phi = atan2(-p.z, p.x) + PI;\n    u = phi / (TWO_PI);\n    v = theta / PI;\n}\n/*\nconst Light lights[] = Light[](\n    Light(vec3(0.0, 20.0, -30.0), 3.0, vec3(1.0))\n);\n*/\nbool intersectSphere (in Ray ray, in Sphere sphere, inout float t) {\n    vec3 L = sphere.center - ray.origin;\n    float tca = dot(L, ray.direction);\n    float d2 = dot(L, L) - (tca * tca);\n    float radius2 = sphere.radius * sphere.radius;\n    \n    if (d2 > radius2) {\n        return false;\n    }\n    \n    float thc = sqrt(radius2 - d2);\n    float t0 = tca - thc;\n    float t1 = tca + thc;\n    \n    if (t0 > t1) {\n        float tmp = t0;\n        t0 = t1;\n        t1 = tmp;\n    }\n    \n    if (t0 < 0.0) {\n        t0 = t1;\n        if (t0 < 0.0) {\n            return false;\n        }\n    }\n    \n    t = t0;\n    \n    return true;\n}\n\nbool hit_test(in Ray ray, out Hit hit) {\n    \n    float min_t = 1000000.0;\n    float t;\n    bool has_hit = false;\n    \n    for (int i = 0; i < 6; i++) {\n       if (intersectSphere(ray, objects[i], t)) {\n           if (t < min_t) {\n               min_t = t;\n               hit.t = t;\n               hit.sphere = objects[i];\n               hit.idx = i;\n               has_hit = true;\n           }\n       }\n    }\n \n    if(has_hit) {\n        hit.pt = ray.origin + ray.direction * hit.t;\n        hit.normal = normalize(hit.pt - hit.sphere.center);\n    }\n    \n    return has_hit;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_RAY_DEPTH 5\n#define FOV 50.0\n#define SAMPLES_PER_PIXEL 4.0\n#define EPSILON 1.0e-2\n\n// ---------------------------------------------\n// Hash & Random - From iq\n// ---------------------------------------------\nint   seed = 1;\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand() { return float(rand())/32767.0; }\nvec2 frand2() { return vec2(frand(), frand()); }\nvec3 frand3() { return vec3(frand(), frand(), frand()); }\nvoid  srand( ivec2 p, int frame )\n{\n    int n = frame;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589; // by Hugo Elias\n    n += p.y;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    n += p.x;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    seed = n;\n}\nvec3 hash3(vec3 p) {\n    uvec3 x = uvec3(floatBitsToUint(p));\n    const uint k = 1103515245U; \n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat random() { return frand(); }\n\nvec3 random_unit_vec() {\n    float a = random() * TWO_PI;\n    float z = 1.0 - (random() * 2.0);\n    float r = sqrt(1.0 - z * z);\n    return vec3(r * cos(a), r * sin(a), z);\n}\n\nvec3 random_in_unit_sphere() {\n    float z = random() * 2.0 - 1.0;\n    float t = random() * TWO_PI;\n    float r = sqrt(max(0.0, 1.0 - z * z));\n    float x = r * cos(t);\n    float y = r * sin(t);\n    vec3 res = vec3(x, y, z);\n    res *= pow(random(), 1.0 / 3.0);\n    return res;\n}\n\nvec3 random_in_hemisphere(in vec3 normal) {\n    vec3 in_unit_sphere = random_in_unit_sphere();\n    if (dot(in_unit_sphere, normal) > 0.0) // In the same hemisphere as the normal\n        return in_unit_sphere;\n    else\n        return -in_unit_sphere;\n}\n\n\nfloat schlick(float cosine, float ref_idx) {\n    float r0 = (1.0 - ref_idx) / (1.0 + ref_idx);\n    r0 = r0 * r0;\n    return r0 + (1.0 - r0) * pow((1.0 - cosine), 5.0);\n}\n\nbool _refract(in vec3 v, in vec3 n, in float ni_over_nt, out vec3 refracted) {\n\n  vec3 uv = normalize(v);\n  float dt = dot(uv, n);\n  float discriminant = 1.0 - ni_over_nt * ni_over_nt * (1.0 - dt * dt);\n\n  if (discriminant > 0.0) {\n    refracted = ni_over_nt * (uv - n * dt) - n * sqrt(discriminant);\n    return true;\n  } else {\n    return false;\n  }\n}\n\nbool scatter_lambertian(in Ray in_ray, in Hit rec, in Material mat, out vec3 attenuation, out Ray scattered_ray) {\n  vec3 new_dir = rec.pt + rec.normal + random_in_unit_sphere();\n  scattered_ray = Ray(rec.pt + rec.normal * EPSILON, normalize(new_dir - rec.pt));\n  attenuation = mat.albedo;\n  float u;\n  float v;\n  get_sphere_uv(rec.normal, u, v);\n  \n  attenuation = texture(iChannel2, vec2(u,v)).xyz * dot(rec.normal, normalize(vec3(1.0, 1.0, 1.0)));\n  return true;\n}\n\nbool scatter_metal(in Ray in_ray, in Hit rec, in Material mat, out vec3 attenuation, out Ray scattered_ray) {\n  vec3 new_dir = reflect(in_ray.direction, rec.normal);\n  new_dir = normalize(new_dir + mat.metal.roughness * random_in_unit_sphere());\n  scattered_ray = Ray(rec.pt + rec.normal * EPSILON, normalize(new_dir));\n  attenuation = mat.albedo;\n  return dot(scattered_ray.direction, rec.normal) > 0.0;\n}\n\nbool scatter_dielectric(in Ray in_ray, in Hit hit, in Material mat, out vec3 attenuation, out Ray scattered_ray) {\n    vec3 outward_normal;\n    vec3 reflected = reflect(in_ray.direction, hit.normal);\n    float ni_over_nt;\n    attenuation = mat.albedo;// vec3(1.0, 1.0, 1.0);\n    vec3 refracted;\n    float reflect_prob;\n    float cosine;\n    float ref_idx = mat.dielectric.ref_idx;\n    float bias = 1.0e-3;\n    \n    if (dot(in_ray.direction, hit.normal) > 0.0)\n    {\n        outward_normal = -hit.normal;\n        ni_over_nt = ref_idx;\n        cosine = ref_idx * dot(in_ray.direction, hit.normal) / length(in_ray.direction);\n    }\n    else\n    {\n        outward_normal = hit.normal;\n        ni_over_nt = 1.0 / ref_idx;\n        cosine = -dot(in_ray.direction, hit.normal) / length(in_ray.direction);\n    }\n\n    if (_refract(in_ray.direction, outward_normal, ni_over_nt, refracted))\n        reflect_prob = schlick(cosine, ref_idx);\n    else\n        reflect_prob = 1.0;\n\n    if (random() < reflect_prob) {\n        scattered_ray = Ray(hit.pt+outward_normal*bias, reflected); \n    } else {\n        scattered_ray = Ray(hit.pt-outward_normal*bias, refracted);\n    }\n    return true;\n}\n/*\nbool shadow_test(in Ray ray, in Hit hit) {\n\n    Material mat = materials[hit.sphere.material];\n    vec3 color = vec3(1.0);\n    vec3 transmission = vec3(1.0);\n    vec3 lightDirection = normalize(objects[5].center - hit.pt);\n    \n    Ray shadow_ray = Ray(hit.pt + hit.normal * EPSILON, lightDirection);\n    Hit hit2;\n    \n    float t;\n    \n    for (int j = 0; j < 5; j++) {\n        if (j != hit.idx) {\n            if(intersectSphere(shadow_ray, objects[j], t)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n*/\n\n\n\nvec3 trace( in Ray ray ) {\n\n    vec3 color = vec3(1.0);\n    vec3 emitted = vec3(0.0);\n    \n    for (int ray_hop = 0; ray_hop < MAX_RAY_DEPTH; ray_hop++)\n    {\n        Hit hit;\n        \n        if(hit_test(ray, hit)) {\n            \n            Material mat = materials[hit.sphere.material];\n            \n            Ray scattered_ray;\n            vec3 attenuation;\n            \n            \n            if(mat.type == MATERIAL_LAMBERTIAN) {\n                scatter_lambertian(ray, hit, mat, attenuation, scattered_ray);\n                ray = scattered_ray; \n            } else if (mat.type == MATERIAL_METAL) {\n                scatter_metal(ray, hit, mat, attenuation, scattered_ray);\n                ray = scattered_ray;\n            } else if (mat.type == MATERIAL_DIELECTRIC) {\n                scatter_dielectric(ray, hit, mat, attenuation, scattered_ray);\n                ray = scattered_ray;\n            } else if (mat.type == DIFFUSE_LIGHT) {\n                emitted += vec3(1.0, 1.0, 1.0);\n                break;\n            }\n            \n        \n            color *= attenuation;\n\n        } else {\n            color *= texture(iChannel3, ray.direction).xyz;//vec3(1.0, 1.0, 0.7);\n            break;\n        }\n        \n    }\n    \n    return emitted + color;\n}\n/*\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n*/\n// vec2 uv = fragCoord/iResolution.xy;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float scale = tan((FOV * 0.5)*(PI / 180.0));\n    float aspect = iResolution.x / iResolution.y;\n    \n    if (PATH_TRACE == 0) {\n        objects[4].center.x = -5.0 + cos(iTime*0.6) * 1.0;\n        objects[4].center.z = -15.0 + sin(iTime*0.6) * 2.0;\n        objects[3].center.z = -15.0 + cos(iTime*0.6) * 15.0;\n        objects[2].center.x = 3.0 + sin(iTime) * 8.0;\n        objects[2].center.z = -16.0 + cos(iTime) * 8.0;\n        objects[1].center.x = cos(iTime) * 3.0;\n        objects[1].center.z = -20.0+cos(iTime);\n    }\n    \n    Ray ray;\n    ray.origin = vec3(0.0, 0.0, 0.0);\n    \n    \n    vec3 color = vec3(0.0);\n    \n    //float rotX = 0.0;//(iMouse.x / iResolution.x) * 2.0 * 3.14;\n\n    //mat4 m = rotationMatrix(vec3(0.0, 1.0, 0.0), rotX);\n    \n    for (int i = 0; i < int(SAMPLES_PER_PIXEL); i++) {\n        float x = (2.0 * ((uv.x * (iResolution.x+random())) + 0.5) / iResolution.x - 1.0) * aspect * scale;\n        float y = (1.0 - 2.0 * ((uv.y * (iResolution.y+random())) + 0.5) / iResolution.y) * scale;\n    \n        ray.direction = normalize(vec3(x, -y, -1.0));\n        \n        //ray.direction = (vec4(ray.direction, 1.0) * m).xyz;\n        \n        color += trace(ray);\n    }\n    \n    \n    color *= 1.0 / SAMPLES_PER_PIXEL;\n    fragColor = vec4(color,1.0);\n    //if(PATH_TRACE == 1)\n    //    fragColor += texelFetch(iChannel1, ivec2(fragCoord), 0);\n}","name":"Buffer A","description":"","type":"buffer"}]}