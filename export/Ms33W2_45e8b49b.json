{"ver":"0.1","info":{"id":"Ms33W2","date":"1452177245","viewed":1001,"name":"Fern feedback","username":"knighty","description":"Adapted from [url=http://webglplayground.net/share/lsystem-tree-fractal?gallery=1&fullscreen=0&width=800&height=600&header=1]Felix Woitzel original shader[/url].\nUse the mouse to move it.","likes":33,"published":1,"flags":32,"usePreview":0,"tags":["2d","ifs","fern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Composition\nvec2 p1 = vec2(0.5,0.025);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pixel = fragCoord.xy / iResolution.xy;\n    \n    vec2 shadow_uv = clamp( p1 +(pixel-p1)*vec2(.75,3.) - vec2((pixel.y-p1.y), 0.) ,  0., 1.);\n  \n\tfragColor = vec4(texture(iChannel1, shadow_uv).x);\n\tfragColor *= texture(iChannel0, pixel);\n\tfragColor.a = 1.;\n    \n\t//fragColor = texture( iChannel0, pixel);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float mx;// = mix(iMouse.x / iResolution.x, 0.3*sin(iTime)+0.5, float(iMouse.z<0. || (iMouse.x==0. && iMouse.y==0.)));//0.3*sin(iTime)+0.5;//\nfloat my;// = mix(iMouse.y / iResolution.y, 0.9, float(iMouse.z<0. || (iMouse.x==0. && iMouse.y==0.)));\nfloat thikness;// = (2.-my)/0.025;//(2. - iMouse.y / iResolution.y) / 0.025;\nfloat w1;// = (0.5 - mx) * 0.15;//(0.5 - iMouse.x / iResolution.x) * 0.15;\nfloat w2;// = 0.9;\n\nfloat sin1;// = sin(w1);\nfloat cos1;// = cos(w1); \nfloat scale1;// = 1.23; \n\nfloat sin2;// = sin(w1 - w2);\nfloat cos2;// = cos(w1 - w2); \nfloat scale2;// = 2.5; \n\nfloat sin3;// = sin(w1 + w2);\nfloat cos3;// = cos(w1 + w2);\n\nfloat x1;// = 0.5;\nfloat y1;// = 0.035;\nfloat d1;// = thikness;\nfloat x2;// = 0.5 + (mx - 0.5) * 0.25;//0.5 + (iMouse.x / iResolution.x - 0.5) * 0.25;\nfloat y2;// = 0.07 + my * 0.14;//0.07 + iMouse.y / iResolution.y * 0.14;\nfloat d2;// = thikness * scale1;\n\nfloat line_segment(vec2 domain, vec2 p1, float d1, vec2 p2, float d2){\n  float h = 1./(p2.x-p1.x); // helper registers\n  float h1 = (p2.y-p1.y)*h;\n  float h2 = 1./h1;\n  float xs = (-p1.y+h1*p1.x+h2*domain.x+domain.y)/(h2+h1);// coordinates of the point on the line between p1 and p2,\n  float ys = -h2*(xs-domain.x)+domain.y;\t\t\t\t\t// ^ orthogonally to the given point in the domain\n  float d = length(domain-vec2(xs,ys));\t\t// the orthogonal distance from the domain point to the line (unlimited) \n  float s = 0.; // distance from domain point to p1 relative to p2\n  if(p2.x == p1.x){\t// division by zero fix\n    d = abs(domain.x - p1.x);\n    s = (p1.y-ys)/(p1.y-p2.y);\n  }else{\n    s = (xs-p1.x)*h;\t\t\t\t\t\t \n  }\n  d = clamp(d*(d1*(1.-s)+d2*s),0., 1.);\t// adjusting the line thickness using a linear interpolation with s\n  float m1 = 0.; if(s > 0.) m1 = 1.; \t\t// masking out the segment between p1 and p2\n  float m2 = 0.; if(s < 1.) m2 = 1.;\n  float result = clamp( m1*m2-d, 0., 1.); // return result as 1-distance in the range [0..1]\n  result = clamp(1.-length(domain-vec2(p1.x,p1.y))*d1-m1, result, 1.);\t// round corners if you will (half circles)\n  result = clamp(1.-length(domain-vec2(p2.x,p2.y))*d2-m2, result, 1.);\n \t \n  return result;\n}\n\nvec2 complex_mul(vec2 factorA, vec2 factorB){\n  return vec2( factorA.x*factorB.x - factorA.y*factorB.y, factorA.x*factorB.y + factorA.y*factorB.x);\n}\n\nfloat square_mask(vec2 domain){\n  return (domain.x <= 1. && domain.x >= 0. && domain.y <= 1. && domain.y >= 0.) ? 1. : 0.; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // Initialize global variables\n    mx = mix(iMouse.x / iResolution.x, 0.3*sin(iTime)+0.5, float(iMouse.z<0. || (iMouse.x==0. && iMouse.y==0.)));//0.3*sin(iTime)+0.5;//\n\tmy = mix(iMouse.y / iResolution.y, 0.9, float(iMouse.z<0. || (iMouse.x==0. && iMouse.y==0.)));\n\tthikness = (2.-my)/0.025;//(2. - iMouse.y / iResolution.y) / 0.025;\n\tw1 = (0.5 - mx) * 0.15;//(0.5 - iMouse.x / iResolution.x) * 0.15;\n\tw2 = 0.9;\n\n    sin1 = sin(w1);\n    cos1 = cos(w1); \n    scale1 = 1.23; \n\n    sin2 = sin(w1 - w2);\n    cos2 = cos(w1 - w2); \n\tscale2 = 2.5; \n\n\tsin3 = sin(w1 + w2);\n\tcos3 = cos(w1 + w2);\n\n\tx1 = 0.5;\n\ty1 = 0.035;\n\td1 = thikness;\n\tx2 = 0.5 + (mx - 0.5) * 0.25;//0.5 + (iMouse.x / iResolution.x - 0.5) * 0.25;\n\ty2 = 0.07 + my * 0.14;//0.07 + iMouse.y / iResolution.y * 0.14;\n\td2 = thikness * scale1;\n  //----------------------------\n  fragColor = vec4(1.);\n  vec2 pixel = fragCoord.xy / iResolution.xy;\n  vec3 color_increment =vec3(0.004,0.008,0.001);\n\n  vec2 pos1 = vec2(x1,y1);\n  vec2 pos2 = vec2(x2,y2);\n  vec2 c = vec2(0.5);\n\n  fragColor.xyz = vec3(1.-line_segment(pixel, pos1, d1, pos2, d2));\n  if( iFrame==0 ) return;\n\n  // complex multiplication to rotate\n  vec2 uv_stem_feedback = complex_mul((pixel-pos2),vec2(cos1,sin1)*vec2(scale1)) + pos1;\n  vec3 stem_feedback = texture( iChannel0, uv_stem_feedback).xyz + color_increment;\n  vec3 stem_feedback_mask = vec3(square_mask(uv_stem_feedback));\n  stem_feedback *= stem_feedback_mask;\n  stem_feedback += vec3(1.)-stem_feedback_mask;\n\t\n  vec2 uv_left_arm_feedback = complex_mul((pixel-pos2),vec2(cos2,sin2)*vec2(scale2)) + pos1;\n  vec3 left_arm_feedback = texture( iChannel0, uv_left_arm_feedback).xyz + color_increment;\n  vec3 left_arm_feedback_mask = vec3(square_mask(uv_left_arm_feedback));\n  left_arm_feedback *= left_arm_feedback_mask;\n  left_arm_feedback += vec3(1.)-left_arm_feedback_mask;\n\t\n  vec2 uv_right_arm_feedback = complex_mul((pixel-pos2),vec2(cos3,sin3)*vec2(scale2)) + pos1;\n  vec3 right_arm_feedback = texture( iChannel0, uv_right_arm_feedback).xyz + color_increment;\n  vec3 right_arm_feedback_mask = vec3(square_mask(uv_right_arm_feedback));\n  right_arm_feedback *= right_arm_feedback_mask;\n  right_arm_feedback += vec3(1.)-right_arm_feedback_mask;\n\t\n  fragColor.xyz = min( fragColor.xyz, min(stem_feedback, min(left_arm_feedback, right_arm_feedback)));\n\n  fragColor.xyz = mix( fragColor.xyz, texture(iChannel0, pixel).xyz, vec3(0.25)); // sort of a motion blur\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Horizontal blur\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixel = fragCoord.xy / iResolution.xy;\n    float h = 1./iResolution.x;\n\tvec4 sum = vec4(0.0);\n\tsum += texture(iChannel0, pixel + vec2(- 4.0*h, 0.) ) * 0.05;\n\tsum += texture(iChannel0, pixel + vec2(- 3.0*h, 0.) ) * 0.09;\n\tsum += texture(iChannel0, pixel + vec2(- 2.0*h, 0.) ) * 0.12;\n\tsum += texture(iChannel0, pixel + vec2(- 1.0*h, 0.) ) * 0.15;\n\tsum += texture(iChannel0, pixel + vec2(+ 0.0*h, 0.) ) * 0.16;\n\tsum += texture(iChannel0, pixel + vec2(+ 1.0*h, 0.) ) * 0.15;\n\tsum += texture(iChannel0, pixel + vec2(+ 2.0*h, 0.) ) * 0.12;\n\tsum += texture(iChannel0, pixel + vec2(+ 3.0*h, 0.) ) * 0.09;\n\tsum += texture(iChannel0, pixel + vec2(+ 4.0*h, 0.) ) * 0.05;\n    fragColor.xyz = sum.xyz/0.98; // normalize\n\tfragColor.a = 1.;\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//vertical blur\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixel = fragCoord.xy / iResolution.xy;\n    float h = 1./iResolution.y;\n\tvec4 sum = vec4(0.0);\n\tsum += texture(iChannel0, pixel + vec2(0., - 4.0*h) ) * 0.05;\n\tsum += texture(iChannel0, pixel + vec2(0., - 3.0*h) ) * 0.09;\n\tsum += texture(iChannel0, pixel + vec2(0., - 2.0*h) ) * 0.12;\n\tsum += texture(iChannel0, pixel + vec2(0., - 1.0*h) ) * 0.15;\n\tsum += texture(iChannel0, pixel + vec2(0., + 0.0*h) ) * 0.16;\n\tsum += texture(iChannel0, pixel + vec2(0., + 1.0*h) ) * 0.15;\n\tsum += texture(iChannel0, pixel + vec2(0., + 2.0*h) ) * 0.12;\n\tsum += texture(iChannel0, pixel + vec2(0., + 3.0*h) ) * 0.09;\n\tsum += texture(iChannel0, pixel + vec2(0., + 4.0*h) ) * 0.05;\n    fragColor.xyz = sum.xyz/0.98; // normalize\n\tfragColor.a = 1.;\n}","name":"Buf C","description":"","type":"buffer"}]}