{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"music","id":"XdfGzn","filepath":"/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// **************************************************************************\n// CONFIG OPTIONS\n\n// Had to default to lowest quality since the shader doesn't compile\n// on Windows Chrome (most likely due to the heavy nesting in\n// spheresdf - thinking up ways to optimize that).  But for mac and\n// linux users on chrome, feel free to comment in MEDIUM_QUALITY or\n// HIGH_QUALITY to see some diffuse spill on the box walls and some\n// subtle reflections.\n\n//#define HIGH_QUALITY\n#define MEDIUM_QUALITY\n//#define LOW_QUALITY\n\n#ifdef HIGH_QUALITY\n#define BOXWALL_DIFFUSE 1\n#define BOXWALL_REFLECTIONS 1\n#define DISTMARCH_STEPS 100\n#endif \n\n#ifdef MEDIUM_QUALITY\n#define BOXWALL_DIFFUSE 1\n#define BOXWALL_REFLECTIONS 0\n#define DISTMARCH_STEPS 80\n#endif \n\n#ifdef LOW_QUALITY\n#define BOXWALL_DIFFUSE 0\n#define BOXWALL_REFLECTIONS 0\n#define DISTMARCH_STEPS 80\n#endif \n\n#define HEAT_PLUMES_ONLY 0\n// set to 1 in order to isolate the cooler of the 4 effects\n\n#define CELLBOX_SIZE 1.5  \n// play with this to make the spheres bigger or smaller\n\n#define NUM_CELLBOXES 16. \n// play with this to increase the 3d grid size - make sure it is a\n// multiple of 2\n\n#define BOXWALL_EXTENT 1.2 * NUM_CELLBOXES * CELLBOX_SIZE \n// play with this to increase the wall boundaries onto which the\n// diffuse and specular shaders fall\n\n#define NUM_AUDIO_SAMPLES 3\n// You can have the sampling of the audio be more  granular by\n// increasing this number.  Be warned that Windows may not be able to\n// handle values greater than 3.\n\n// *******************************************************************\n// CONSTANTS\n\n#define PI 3.14159\n#define TWO_PI 6.28318\n#define PI_OVER_TWO 1.570796\n\n#define EPSILON 0.001\n#define BIG_FLOAT 1000000.\n\n#define NOISE_DIMENSION 256.\n\n// *******************************************************************\n// GLOBALS\n\n// - - - - - - - - - - - - -\n// Time properties\n\nfloat g_time = 0.;\nfloat g_beatRate = 140.;\n\n// - - - - - - - - - - - - -\n// Camera properties\n\nvec3 g_camOrigin = vec3(0., 0., 0.);\nvec3 g_camPointAt = vec3( 0.0, -1.0, 0.0 );\nvec3 g_camUpDir = vec3( 0.0, 1.0, 0.0 );\n\nvec2 g_camRotationRates = vec2(0.);\n\n// - - - - - - - - - - - - -\n// Audio properties\n\nfloat g_audioFreqs[ NUM_AUDIO_SAMPLES ];\n\n// - - - - - - - - - - - - - \n// Signal properties\n\nvec3 g_plumeOrigin = vec3(0.);\nvec3 g_heatWaveDir = vec3(.1, .8, .3);\n\n// *******************************************************************\n// UTILITIES\n\n// Assumes the bounds represent a space centered around the origin, so\n// if the bounds (2, 2, 2) are provided, then this returns true if p\n// is within a box of 2x2x2 centered at the origin.\n\nbool inbounds( vec3 p, \n               vec3 bounds )\n{\n    return (all(lessThanEqual(p, .5 * bounds)) &&\n            all(greaterThanEqual(p, -.5 * bounds)));\n}\n\n// Rotate the input point around the y-axis by the angle given as a\n// cos(angle) and sin(angle) argument.  There are many times where  I\n// want to reuse the same angle on different points, so why do the\n// heavy trig twice. Range of outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\n\nvec3 rotateAroundYAxis( vec3 point, float cosangle, float sinangle )\n{\n    return vec3(point.x * cosangle  + point.z * sinangle,\n                point.y,\n                point.x * -sinangle + point.z * cosangle);\n}\n\n// Rotate the input point around the x-axis by the angle given as a\n// cos(angle) and sin(angle) argument.  There are many times where  I\n// want to reuse the same angle on different points, so why do the\n// heavy trig twice. Range of outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\n\nvec3 rotateAroundXAxis( vec3 point, float cosangle, float sinangle )\n{\n    return vec3(point.x,\n                point.y * cosangle - point.z * sinangle,\n                point.y * sinangle + point.z * cosangle);\n}\n\n// Returns a smoothed vec3 noise sample based on input n.  Noise\n// samples are within the range ([0., 0., 0.] -> [1., 1., 1.])\n\nvec3 noise1v( float n )\n{   \n    \n    vec2 coords = vec2(mod(n,NOISE_DIMENSION)/NOISE_DIMENSION, \n                       floor(n/NOISE_DIMENSION)/NOISE_DIMENSION);\n    \n    return texture(iChannel0, coords).rgb;\n} \n\n// Lerps between the discrete audio samples gathered during\n// animateGlobals.  The parameter t is within the range [0, 1]\n\nfloat audioAttenuate(float t)\n{    \n    float lookup = t * 0.95 * float(NUM_AUDIO_SAMPLES-1);\n\n    float signal = 0.;\n    for (int i = 0; i < NUM_AUDIO_SAMPLES-1; i += 1) {\n        if ( int(lookup) == i )\n        {\n            signal = mix(g_audioFreqs[i], \n                         g_audioFreqs[i+1], \n                         fract(lookup));\n        }\n    }\n   \n    return signal;\n}\n\n// *******************************************************************\n// DISTANCE FUNCTIONS\n\n// Returns a vec3 that represents the termination of the distance\n// field  marching.\n\n//  x := the distance to the nearest object\n//  y := the material id of the nearest object (0 if non found)\n//  z := the heat of the nearest object (if applicable)\n\nvec3 spheredf( vec3 p, \n               vec3 cellcoords )\n{\n\n\n    // This default result has no material or heat, but does return a\n    // default distance of half a cell size.  The is the \"skipping\"\n    // distance since it will most likely jump to the next cell.  We\n    // could optimize this \"skip\" \"distance\" by actually doing the\n    // math to find the minimum amount that jumps to the next cell,\n    // but this in practice gets the job done.\n    vec3 result = vec3(.5 * CELLBOX_SIZE, 0., 0.);\n\n    // Don't process the current cell if we're not in the box bound.\n    // We use this check since we use distance lookups to find the\n    // outer edge of the box of spheres with a 1 cell buffer, so the\n    // \"outer\" cells can have \"over extended\" distance samples even\n    // though those buffer cells do not contain any spheres.\n    if ( inbounds( p, vec3( NUM_CELLBOXES * CELLBOX_SIZE ) ) ) \n    {\n\n        float signal = 0.;\n\n#if !HEAT_PLUMES_ONLY\n        int selector = int(mod(g_time/10.,5.));\n#endif \n\n#if !HEAT_PLUMES_ONLY\n        // I like the heat plumes so I give them a little extra time\n        // when cycling.\n        if (selector == 0 || selector == 1)  // heat plumes\n        {\n#endif\n\n            float t = -g_beatRate * .04125 * g_time;    \n            float basst = .5 + .5 * smoothstep(.6, \n                                               .98, \n                                               g_audioFreqs[0]);\n            t = mod(t + .5 * length(cellcoords + g_plumeOrigin), 15.);\n            signal = basst * (smoothstep(0., 3., t) - \n                              smoothstep(3., 5., t));\n\n#if !HEAT_PLUMES_ONLY\n        }\n#endif\n\n#if !HEAT_PLUMES_ONLY\n\n        float audiot = smoothstep(NUM_CELLBOXES/2., \n                                  -NUM_CELLBOXES/2.,\n                                  cellcoords.y);\n        audiot = audioAttenuate(1. - audiot);\n\n        if (selector == 2) // audio vertical heat waves\n        {\n\n            signal = audiot * (.5 * sin(g_beatRate * 0.03125 * g_time + \n                dot(g_heatWaveDir, cellcoords) ) + .5);        \n\n        }\n        if (selector == 3) // audio heat pulses\n        {            \n\n            audiot = .1 + .9 * audiot;\n            signal = audiot * pow(.5 * sin(-g_beatRate * 0.03925 * g_time + \n                .3 * length(cellcoords + \n                    vec3(0., NUM_CELLBOXES/3., 0.))) + .5, 2.);\n        }\n        if (selector == 4) // audio eminating heat boxes\n        {\n\n            audiot = .1 + .9 * audiot;\n            signal =  audiot * (.5 * sin(-g_beatRate * 0.03925 * g_time + \n                .8 * max(abs(cellcoords.x), \n                     max(abs(cellcoords.y), \n                         abs(cellcoords.z)))) + .5);\n        }\n#endif\n\n        float heat = 10000. * signal; \n        // Don't consider this a valid cell if it isn't hot enough.  \n        if (heat > 100.) {\n\n            // Bloat the radius based on the radius scale signal.\n            // There is always a little bit of sphere if there is\n            // enough heat.\n            float radius = .8 * (.9 * signal + .1) * \n                            .5 * CELLBOX_SIZE;\n\n            // Push the sphere away from the origin based on the\n            // displacement signal\n            vec3 sphereCenter = cellcoords * CELLBOX_SIZE - \n                            vec3(CELLBOX_SIZE * .5);\n            vec3 towardsCenter = -normalize(sphereCenter);                \n            sphereCenter -= (2. * signal - 1.) * \n                            (.5 * CELLBOX_SIZE - radius) * \n                            towardsCenter;\n            \n\n            result = vec3(length( p - sphereCenter ) - radius, \n                          1., \n                          heat);\n        }\n    }\n    \n    return result;\n}\n\n\n// Returns a vec3 that represents the termination of the distance\n// field  marching.\n\n//  x := the distance to the nearest object\n//  y := the material id of the nearest object (0 if non found)\n//  z := the heat of the nearest object (if applicable)\n\nvec3 spheresdf( vec3 p, \n                vec3 rdir ) \n{\n    float dist = 10.;\n\n    vec3 cellCoords = ceil(p / CELLBOX_SIZE);\n    vec4 nextCellOffset = vec4(sign(rdir), 0.);\n            \n    // Look into this cell to check distance to that sphere and then\n    // check the distance to the spheres for the next cells to see if\n    // they are closer, we can guess the \"next\" cells by just looking\n    // at the sign of the ray dir (so we don't check all 27 possible\n    // cells - 9x9x9 grid).  This limits it down just to checking 8\n    // possible cells.\n\n    // XXX: we could limit this to 4 cell checks if we trace the \n    // ray through the 8 potential cells and only test the cells \n    // through which the ray passes.\n\n    // 1. current cell\n    vec3 result = spheredf( p, cellCoords );\n\n    // 2. neighbor in the x direction of the ray\n    vec3 neighborResult = spheredf(p, cellCoords + nextCellOffset.xww);    \n    // DEBRANCHED - equivalent to\n    // if (neighborResult.x < result.x) { result = neighborResult; }\n    result = mix(result, neighborResult, \n                 step(neighborResult.x, result.x));\n\n    // 3. neighbor in the y direction of the ray\n    neighborResult = spheredf(p, cellCoords + nextCellOffset.wyw);\n    result = mix(result, neighborResult, \n                 step(neighborResult.x, result.x));\n\n    // 4. neighbor in the z direction of the ray\n    neighborResult = spheredf(p, cellCoords + nextCellOffset.wwz);\n    result = mix(result, neighborResult, \n                 step(neighborResult.x, result.x));\n    \n    // 5. neighbor in the x-y direction of the ray\n    neighborResult = spheredf(p, cellCoords + nextCellOffset.xyw);\n    result = mix(result, neighborResult, \n                 step(neighborResult.x, result.x));\n\n    // 6. neighbor in the y-z direction of the ray\n    neighborResult = spheredf(p, cellCoords + nextCellOffset.wyz);\n    result = mix(result, neighborResult, \n                 step(neighborResult.x, result.x));\n\n    // 7. neighbor in the x-z direction of the ray\n    neighborResult = spheredf(p, cellCoords + nextCellOffset.xwz);\n    result = mix(result, neighborResult, \n                 step(neighborResult.x, result.x));\n        \n    // 8. neighbor in the x-y-z direction of the ray\n    neighborResult = spheredf(p, cellCoords + nextCellOffset.xyz);    \n    result = mix(result, neighborResult, \n                 step(neighborResult.x, result.x));\n\n    return result;\n}\n\nfloat boxdf( vec3 p, vec3 bounds )\n{\n    vec3 boxd = abs(p) - .5 * bounds;\n    return length(max(boxd, 0.));\n}\n\nfloat boxinteriortrace( vec3 origin, \n                        vec3 rayDir, \n                        float halfCellSize )\n{\n    \n    vec3 pn = -sign(rayDir);\n    vec3 ddn = rayDir * pn;\n    vec3 po = halfCellSize * -pn;\n    vec3 t = -(pn * (origin - po))/ddn;\n    float dist = min(t.x, min(t.y, t.z));    \n\n    return dist;\n}\n\n// Returns a vec3 that represents the termination of the distance\n// field  marching.\n\n//  x := the distance to the nearest object\n//  y := the material id of the nearest object (0 if non found)\n//  z := the heat of the nearest object (if applicable)\nvec3 scenedf( vec3 p, \n              vec3 rdir )\n{\n    vec3 result = vec3(1., 10., 0.);\n\n    if (inbounds( p, vec3((NUM_CELLBOXES + 2.) * CELLBOX_SIZE ))) {\n       vec3 dfresult = spheresdf( p, rdir );\n       result = dfresult;\n    } else {\n       result = vec3(boxdf( p, vec3(NUM_CELLBOXES * CELLBOX_SIZE)), \n                     -1., \n                     0.);\n    }\n\n    float boxdist = boxinteriortrace(p, rdir, BOXWALL_EXTENT);\n\n    // DEBRANCHED\n    // equivalent to if (boxdist < dist) {\n    result = mix(result, \n                 vec3(boxdist, 2., 0.), \n                 step(boxdist, result.x));\n\n    return result;\n}\n\n// *******************************************************************\n// DISTANCE MARCHING\n\n// Returns a vec3 that represents the termination of the distance\n// field  marching.\n\n//  x := the distance to the nearest object\n//  y := the material id of the nearest object (0 if non found)\n//  z := the heat of the nearest object (if applicable)\nvec3 distmarch( vec3 ro, vec3 rd, float maxd )\n{\n    \n    float dist = 6.;\n    float t = 0.;\n    float material = 0.;\n    float heat = 0.;\n    for (int i=0; i < DISTMARCH_STEPS; i++) \n    {\n        if (( abs(dist) < EPSILON || t > maxd) && material >= 0. ) \n            continue;\n\n        t += dist;\n        vec3 dfresult = scenedf( ro + t * rd, rd );\n        dist = dfresult.x;\n        material = dfresult.y;\n        heat = dfresult.z;\n    }\n\n    if( t > maxd ) material = -1.0; \n    return vec3( t, material, heat );\n}\n\n// *******************************************************************\n// SHADE FUNCTIONS\n\nvec3 calcWallNormal( vec3 p,\n                     vec3 rdir )\n{\n    vec3 epsilon = vec3( EPSILON, 0.0, 0.0 );\n    vec3 n = vec3(\n        boxinteriortrace(p + epsilon.xyy, rdir, BOXWALL_EXTENT) - \n            boxinteriortrace(p - epsilon.xyy, rdir, BOXWALL_EXTENT),\n        boxinteriortrace(p + epsilon.yxy, rdir, BOXWALL_EXTENT) - \n            boxinteriortrace(p - epsilon.yxy, rdir, BOXWALL_EXTENT),\n        boxinteriortrace(p + epsilon.yyx, rdir, BOXWALL_EXTENT) - \n            boxinteriortrace(p - epsilon.yyx, rdir, BOXWALL_EXTENT) );\n    return normalize( n );\n}\n\n// Eye-balled values trying to represent black body temperature\n// variation.   Expecting temperature to be in the range 0 to 10000.\nvec3 sphereColor(float T)\n{\n    vec3 whiteHotColor = vec3(.88, .98, .97);\n    vec3 hotColor  = vec3(.95, .78, .23); \n    vec3 coolColor = vec3(0.43, .01, .003);\n    vec3 noheatColor = vec3(.0);\n    return mix(mix(noheatColor, coolColor,\n                   smoothstep(200., 1000., T)),\n               mix(hotColor, whiteHotColor, \n                    smoothstep(8000., 10000., T)),\n                smoothstep(1000., 8000., T));\n\n}\n\n// Return a vec3 representing the color contribution of the shaded\n// wall.\nvec3 shadeWall( vec3 p, \n                vec3 n,\n                vec3 rdir )\n{\n\n    float kd = .3;\n    float ks = .9;\n\n    vec3 diffcol = vec3(0.0);\n    vec3 speccol = vec3(0.0);\n    vec3 ambcol = vec3(0.018, 0.013, 0.013);\n\n    // DIFFUSE\n\n    // jittered samples of the 8 corners of the heat box to get a\n    // diffuse response.  Consider a box of dimension 2x2x2 centered\n    // at the origin.  In the corner  around the normalized\n    // coordinates (-.75, -.75, -.75), I jitter within  the range\n    // [(-1, -1., -1.), (-.5, -.5, -.5)].  This is a hack that  gives\n    // us bias coverage towards the outside of the heatbox, but since\n    // we distance attenuate, one can argue the outer portions of the\n    // box are more important in a hackish importance sampled scheme.\n\n    // Here's a cross section of one side of the heat box.  The small\n    // dots  in each corner represent the area in which the jittering\n    // can happen and the x represents an example spot in which there\n    // could be a color  lookup to drive the diffuse response on the\n    // wall.\n\n    // * --------------- *\n    // | x  .   |   .x . |\n    // | .  .   |   .  . |\n    // |        |        |\n    // |-----------------|\n    // |        |        |\n    // | . x.   |   .  . |\n    // | .  .   |   .x . |\n    // * --------------- *\n    \n#if BOXWALL_DIFFUSE\n    \n    vec3 lightp = vec3(0.);\n    float halfBoxSize = .5 * NUM_CELLBOXES * CELLBOX_SIZE;\n    for (float x = 0.; x < 2.; x++ ) {\n        lightp.x = (-.75 + (1.5 * x)) * halfBoxSize;\n    for (float y = 0.; y < 2.; y++ ) {\n        lightp.y = (-.75 + (1.5 * y)) * halfBoxSize;\n    for (float z = 0.; z < 2.; z++ ) {\n        lightp.z = (-.75 + (1.5 * z)) * halfBoxSize;\n\n        float noiseseed = x + 2. * y + 4. * z + 10. * g_time;\n        vec3 noiseoffset = halfBoxSize * (noise1v( noiseseed ) - .5);\n\n        vec3 ldir = (lightp + noiseoffset) - p;\n        vec3 nldir = normalize(ldir);\n        \n        vec3 cellCoords = ceil(lightp / CELLBOX_SIZE);\n        vec3 dfresult = spheredf( lightp, cellCoords );\n                \n        if (dfresult.y < 1.5)\n        {\n            float lenldir = length(ldir);\n            float diffuse = clamp( dot( n, nldir ), 0., 1.);\n            // attenuate falloff by a distance metric.\n            float distatten = max(0., 1. - (lenldir/80.));\n            // have the light falloff by a square factor\n            distatten *= distatten;\n            diffcol += diffuse * distatten * sphereColor(dfresult.z);\n        }\n\n    } } }\n\n    diffcol /= 8.;\n    diffcol *= 5. * vec3(0.4, .4, .5);\n    \n#endif\n\n    // SPECULAR\n\n    // Reflect the scene but have it fall off dramatically to give\n    // a kind of deep onyx look.\n\n#if BOXWALL_REFLECTIONS\n    vec3 reflmarch = distmarch( p, rdir, 21. );\n\n    if (reflmarch.y > 0.5 && reflmarch.y < 1.5) \n    {\n        float distatten = max(0., 1. - reflmarch.x/30.);\n        distatten *= distatten;\n        speccol = distatten * sphereColor(reflmarch.z);\n    }\n#endif\n    return ambcol + kd * diffcol + ks * speccol;\n}\n\n// *******************************************************************\n// ANIMATE GLOBALS\n\nvoid animateGlobals()\n{\n\n\tg_camRotationRates = vec2(0.001125 * g_beatRate, \n                               -0.00125 * g_beatRate);\n    \n\tg_time = iChannelTime[1];\n    \n    // remap the mouse click ([-1, 1], [-1/ar, 1/ar])\n    vec2 click = iMouse.xy / iResolution.xx;    \n    click = 2.0 * click - 1.0;   \n    \n    // camera position\n    g_camOrigin = vec3(0., 0.0 , 23.);\n    \n    float rotateXAngle    = .49 * PI * \n            sin(g_camRotationRates.x * g_time - .88 * PI * click.y);\n    float cosRotateXAngle = cos(rotateXAngle);\n    float sinRotateXAngle = sin(rotateXAngle);\n    \n    float rotateYAngle    = g_camRotationRates.y * g_time + \n            TWO_PI * click.x;\n    float cosRotateYAngle = cos(rotateYAngle);\n    float sinRotateYAngle = sin(rotateYAngle);\n\n    // Rotate the camera around the origin\n    g_camOrigin = rotateAroundXAxis(g_camOrigin, \n                                    cosRotateXAngle, \n                                    sinRotateXAngle);\n    g_camOrigin = rotateAroundYAxis(g_camOrigin, \n                                    cosRotateYAngle, \n                                    sinRotateYAngle);\n\n    g_camPointAt   = vec3(0., 0., 0.);\n        \n    // For each audio sample, sample the audio channel along the\n    // x-axis (increasing frequency with each sample).\n    for (int i = 0; i < NUM_AUDIO_SAMPLES; i += 1) {\n        float offsets = float(i) * (0.95/float(NUM_AUDIO_SAMPLES));\n        g_audioFreqs[i] = smoothstep(0.4, .7, \n                             texture( iChannel1, \n                             vec2(0.0 + offsets, 0.0)).r);\n    }\n\n#if !HEAT_PLUMES_ONLY\n    // slightly modify the direction of the wave based on noise to add \n    // effect for the vertical heat wave event.\n    g_heatWaveDir = vec3(0., 1., 0.);\n    g_heatWaveDir += .3 * vec3(cos(.8 * g_time), 0., sin(.8 * g_time));\n                         \n#endif\n\n    // calculate the plume origin that changes over time to add\n    // interesting detail.\n    float cosElev = cos(g_time * .2);\n    float sinElev = sin(g_time * .2);\n\n    float cosAzim = cos(g_time * .5);\n    float sinAzim = sin(g_time * .5);\n    \n    g_plumeOrigin = NUM_CELLBOXES/2. * \n                       vec3(cosAzim * cosElev,\n                            sinElev,\n                            sinAzim * cosElev);\n}\n\n// *******************************************************************\n// MAIN\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    \n    // ----------------------------------\n    // Animate globals\n\n    animateGlobals();\n\n    // ----------------------------------\n    // Setup Camera\n\n    // Shift p so it's in the range -1 to 1 in the x-axis and\n    // 1./aspectRatio to 1./aspectRatio in the y-axis (a reminder\n    // aspectRatio := width / height of screen)\n\n    // I could simplify this to:\n    // vec2 p = fragCoord.xy / iResolution.xx; <- but that's a bit\n    // obtuse to read.\n    \n    vec2 p = fragCoord.xy / iResolution.xy;      \n    float aspectRatio = iResolution.x / iResolution.y;\n    p = 2.0 * p - 1.0;\n    p.y *= 1./aspectRatio;\n    \n    // calculate the rdirection that represents mapping the  image\n    // plane towards the scene\n    vec3 cameraZDir = normalize( g_camPointAt - g_camOrigin );\n    vec3 cameraXDir = normalize( cross(cameraZDir, g_camUpDir) );\n\n    // no need to normalize since we know cameraXDir and cameraZDir\n    // are orthogonal\n    vec3 cameraYDir = cross(cameraXDir, cameraZDir);\n    \n    // Make the constant in front of cameraZDir (camFocalLengthScalar)\n    // bigger to tighten focus, smaller to widen focus.\n    vec2 uv = p*0.5+0.5;\n    float vignet = pow(10.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y),0.4);\n\n    // Add a bit of fisheye distortion based on vignet signal\n    float camFocalLengthScalar = .9 * mix(0.8, 1., vignet);\n    vec3 rdir = normalize( p.x*cameraXDir + p.y*cameraYDir + \n                           camFocalLengthScalar * cameraZDir );    \n        \n    // ----------------------------------\n    // Scene Marching\n\n    vec3 scenemarch = distmarch( g_camOrigin, rdir, 100. );\n\n    vec4 scenecol = vec4( vec3(0.01, 0.01, 0.016), 1.);\n    \n    if (scenemarch.y > 0.5 && scenemarch.y < 1.5) \n    {\n        scenecol.rgb = sphereColor(scenemarch.z);\n    }\n    \n    else if (scenemarch.y > 1.5 && scenemarch.y < 2.5)\n    {\n        vec3 wp = g_camOrigin + scenemarch.x * rdir;\n        vec3 wn = calcWallNormal( wp, rdir );\n        vec3 wrefldir = normalize(reflect(wp - g_camOrigin, wn));\n\n        scenecol.rgb += shadeWall(wp, wn, wrefldir);\n        \n    }\n    \n    // ----------------------------------\n    // Grading\n\n    // fall off exponentially into the distance (as if there is a spot\n    // light on the point of interest).\n    scenecol *= exp( -0.0002*scenemarch.x*scenemarch.x );\n\n    // gamma correct\n    scenecol.rgb = pow(scenecol.rgb, vec3(0.45));\n\n    fragColor.rgb = scenecol.rgb;\n    fragColor.a = 1.;\n    \n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdSGWR","date":"1385576809","viewed":1169,"name":"Audio HeatBox","username":"mplanck","description":"Heat waves passing through a grid of spheres.  Lazily synced to music.  Accelerated with nearest neighbor box tricks.  Fiddle with the quality constants to see more features.","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["3d","heat","accelerationstructures","distancemarching"],"hasliked":0,"parentid":"","parentname":""}}