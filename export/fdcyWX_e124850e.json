{"ver":"0.1","info":{"id":"fdcyWX","date":"1654143967","viewed":111,"name":"Power series","username":"ChunderFPV","description":"Updated July 14, 2023\nThe power function series (exponent curves) showing points flowing between the convergences.  Click for function plot.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["math","graph","function","plot","power","exponent","loopless"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define H(a) (cos(vec3(0,1,2)-((a)*6.3))*.5+.5)  // hue\n#define L(x,w) smoothstep(w*min(fwidth(x), 1.), 0., abs(x))  // line\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    float t = iTime/2.,\n          aa = 2., // anti-aliasing (1 = off)\n          s = 6.,  // scale\n          ss = .2, // snap strength\n          e, v, ec, eg, ed, me, pc, p, pg, fp;\n    vec2 R = iResolution.xy,\n         m = (iMouse.xy-.5*R)/R.y*s,\n         rm = round(m/ss)*ss, // rounded mouse\n         ao, u, g, po;\n    vec3 c = vec3(0);\n    \n    if (rm.x == round(m.x)) m.x = rm.x; // snap to x\n    if (rm.y == round(m.y)) m.y = rm.y; // snap to y\n    me = (iMouse.z > 0.) ? // exponent from mouse or time\n        log(abs(m.y))/log(abs(m.x)):\n        tan(t);\n    \n    for (int k = 0; k < int(aa*aa); k++) // aa loop\n    {\n        ao = vec2(k%2, k/2)/aa; // aa offset\n        u = (U-.5*R+ao)/R.y*s;  // coords\n        e = log(abs(u.y))/log(abs(u.x)); // exponent from xy\n        v = max(abs(e), 1./abs(e)); // new coords with reciprocals\n        ec = max(0., 1.-abs(fract(v+.5)-.5)/fwidth(v)/1.5); // exponent curves\n        eg = 1.-abs(sin(v*3.14)); // glow\n        ed = min(1., 1./abs(v));  // darken\n        c += (ec*.8+eg*.5)*ed*H(ed)*1.5; // blend & add color\n    }\n    c /= aa*aa; // post-aa brightness fix\n    c *= sign(e)*.3+.8; // mod brightness with polarity\n    \n    g = max(vec2(0), 1.-abs(fract(u+.5)-.5)/fwidth(u)/2.); // xy grid\n    c *= max(0., 1.-max(g.x, g.y)*.3); // dark grid lines\n    c += min(g.x, g.y); // grid points\n    \n    e = abs(e);\n    e = (e < 1.) ? 1./round(1./e): round(e); // round n or 1/n\n    e = sqrt(e);\n    po = vec2(pow(abs(me), 1./e), pow(abs(me), e*sign(me))); // point offsets\n    pc = length(abs(u)-po); // point coords\n    p = max(0., 1.-pc/length(fwidth(u))/2.); // points\n    pg = max(0., 1.-pc/.5); // point glow\n    c += H(p+.5)*p*2.; // color & add points\n    c += H(pg)*pg*.3;  // glow\n    \n    if (iMouse.z > 0.) // click\n        fp = u.y-pow(u.x*sign(m.x), me)*sign(m.y), // func plot\n        c *= 1.-L(fp, 5.), // dark line\n        c.r += L(fp, 2.5),\n        c += 1.-step(length(fwidth(u))*3.5, max(abs(u.x-m.x), abs(u.y-m.y))); // point at xy\n    \n    C = vec4(c+c*c, 1);\n}\n\n/* original version\n#define SCALE 6.0\n#define S(v,r)  smoothstep (3.0/R.y, 0.0, length(v)-r)\n#define PT(u,r) smoothstep(0.0, r, r-length(u));\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    vec4 m = iMouse; m = vec4((m.xy-0.5*R)/R.y*SCALE, m.z, m.w);\n    vec2 uv = (U-0.5*R)/R.y*SCALE;\n    float px = length(fwidth(uv)*0.7); // pixel size\n    \n    // graph series\n    float ex = log(abs(uv.y))/log(abs(uv.x)); // exponent\n    float grad = min(abs(ex), abs(1.0/ex)); // gradient\n    float rex = (abs(ex) < 1.0) ? 1.0/round(1.0/ex): round(ex); // round ex to 1/n, n\n    float y = pow(abs(uv.x), rex);     // f(x)=y\n    float x = pow(abs(uv.y), 1.0/rex); // f(y)=x\n    // plotting along both x and y for smoother curves\n    float curves = max( S(y-abs(uv.y), px), S(x-abs(uv.x), px) );\n    vec3 rgb = abs(vec3(0.0, 0.7, 1.0)+sign(ex)/3.0);\n    vec3 c = vec3(grad*curves*rgb);\n    \n    // graph from mouse xy\n    float t = iTime;\n    float n = (cos(t) > 0.0) ? sin(t): 1.0/sin(t);\n    float mex = (m.z > 0.0) ? log(abs(m.y))/log(abs(m.x)): n; // mouse exponent\n    y = pow(abs(uv.x), mex)*sign(m.y);\n    if (m.z > 0.0 && sign(uv.x) == sign(m.x)) // click\n        c.r += S(y-(uv.y), px*2.0);\n    \n    // xy grid\n    float glw = 1.0; // line width\n    float gpw = 2.0; // point width\n    vec2 xyg = abs(fract(uv+0.5)-0.5)/px; // xy grid\n    c = mix(c, vec3(0), 1.0-min(min(xyg.x/glw, xyg.y/glw), 1.0)); // lines\n    c = mix(c, vec3(0.75), 1.0-min(max(xyg.x/gpw, xyg.y/gpw), 1.0)); // points\n    \n    // point flow\n    rex = sqrt(abs(rex));\n    float flow = PT(abs(uv)-vec2(pow(abs(mex), 1.0/rex), pow(abs(mex), rex*sign(mex))), px*5.0);\n    c += vec3(1.0, 0.6, 0.0)*flow;\n    \n    O = vec4(c*1.5, 1.0);\n}\n*/","name":"Image","description":"","type":"image"}]}