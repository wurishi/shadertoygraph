{"ver":"0.1","info":{"id":"XlBSDz","date":"1442683241","viewed":307,"name":"World's Simplest 1D Raymarch","username":"davepl","description":"An extremely basic introduction to RayMarching that esimates only if you're on the left or right side of the screen and colors it.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["simple","raymarch","tutorial","helloworld"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Simplest possible 1-Dimensional RayMarch demo - color half the screen\n//\n// Your function is called for every pixel on the screen (-1 .. +1).  While it would be trivial to \n// just compare to 0.0 and know if you're on the right or left, we're going to raymarch to that \n// as an exercise to demonstrate ray marching.\n//\n// The general process:\n//   - Figure out which direction your candidate pixel is (left or right of center based on \n//       whether its greater or less than zero, since zero is the center X coordinate)\n//   - Normalize that so it's -just- a direction - no magnitude - either +1 or -1\n//   - Figure out how much we have to multiply that direction by, left or right, to get to the center\n//\n// This last step, figuring out the distance to the center, is done by:\n//   - Estimate the distance to the center (which we can do perfectly accurately in this example\n//       but that normally you may not be able to without estimation)\n//   - Multiply our direction by that amount, then see how far we are\n//   - Halve that amount and add it to where we're at\n//   - Repeat 64 times to \"home in\" on the amount we need to get to the center\n//\n// The amount of the scalar that we have to multiply the direction of our pixel to get it to \n// the center is our 'result', and we use the result to color the screen\n//\n// To take it one more step and do it in 2D, see my simple Circle raymarch\n\nfloat distanceFromTarget(float p)\n{\n    return 0.0 - p;\n}\n\nfloat trace(float target, float direction)\n{\n    float amount = 0.0;\n    for (int i = 0; i < 64; i++)\n    {\n        float p = target + direction * amount;\n        float distance = distanceFromTarget(p);\n        amount = amount + distance / 2.0;\n    }\n    return amount;\n}\n          \n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float middle = iResolution.x / 2.0;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\t// Scale pixel coords to 0..1 range instead\n    uv = uv * 2.0 - 1.0;\t\t\t\t\t\t// Now to the -1 to +1 range\n    uv.x *= iResolution.x / iResolution.y;\t\t// Correct for aspect ratio; rescale texcoords horizontally based on it\n    \n\tfloat direction = uv.x < middle ? -1.0 : 1.0;\n    float t     = trace(uv.x, direction);\t\t\t\n    \n\tfragColor   = vec4(t,t,t,1);\n}\n","name":"","description":"","type":"image"}]}