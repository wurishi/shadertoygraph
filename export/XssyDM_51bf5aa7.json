{"ver":"0.1","info":{"id":"XssyDM","date":"1488809876","viewed":1043,"name":"SmallPlanet","username":"kuvkar","description":"Small planet with atmosphere, clouds, shores etc. Look around with mouse. Sunset effect at around 30 seconds.","likes":33,"published":1,"flags":0,"usePreview":0,"tags":["clouds","water","planet","shadows","stars","atmoshpere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n\tSmall planet with atmosphere, clouds, shores, water etc.\n\t---------------------------------------------------------\n\t\t\n    Most of the stuff is pretty basic raytracing/marching, there might be couple of things worth mentioning:\n\n\tI tried a couple of ways to texture a planet. I first tried cube mapping but that caused\n    really ugly seams. I ended up texturing the sphere by mapping the texture onto the planet spherically,\n    and then countering the distortion at the poles by changing uv coordinates from polar to rectangular.\n\tNeeds 2 texture lookups, as both poles need to be countered for distortion. \n\n\tBetter explanation of the process is here: https://www.youtube.com/watch?v=Xxg7pOIDAqQ\n\n\tAtmospheric scattering is not physically accurate at all, but looks good enough and is really fast.\n\t\n\tThere are smaller waves around the shores. They are barely visible now in the windowed mode, I started \n    with camera much closer, and ended up with the shore waves barely being visible. Oh well, at least\n    they can be seen in fullscreen.\n\t\n\tThe nebula is a warped texture that is mapped cylinderically around.\n\n*/\n\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\nvec3 lightDir = normalize(vec3(0.0, 1.0, -1.0));\nconst float SHELL = 0.25;\nconst float OUTER_SHELL = SHELL + 0.1;\nconst float H = (OUTER_SHELL - SHELL)*.7;\nconst float WATERLEVEL = SHELL+H*0.2;\n#define PI 3.14159265358\n#define PI2 (PI*0.5)\n\n#define DO_CLOUDS\n#define SHADOWS\n\n\nvec2 polar2Rect(in vec2 uv)\n{\n    vec2 _uv = uv;\n    uv.x = cos(_uv.x)*_uv.y;\n    uv.y = sin(_uv.x)*_uv.y;\n    return uv;\n}\n\n// maps a texture to a sphere\nvec4 textureSpherical(in sampler2D tex, in vec3 rp, float scale)\n{\n    float lrp = length(rp);\n    vec2 uv1 = vec2(atan(rp.y, rp.x), acos(rp.z/lrp));\n    vec2 uv2 = uv1; uv2.y = PI-uv1.y;\n    float f=uv1.y;\n\n    uv1=polar2Rect(uv1)*scale;\n    uv2=polar2Rect(uv2)*scale;\n    \n    vec4 c1 = texture(tex, uv1);\n    vec4 c2 = texture(tex, uv2);\n    return mix(c1, c2, smoothstep(PI2-0.01, PI2+0.01, f));\n}\n\nmat3 g_planetRot;\n\nvec3 planetRotatedVec(in vec3 p)\n{\n    return p*g_planetRot;\n}\n\nfloat map(in vec3 rp)\n{\n    float h = textureSpherical(iChannel0, planetRotatedVec(rp), .6).r;\n    h = smoothstep(0.1, 1.0, h);\n    h*=H*.5;\n    return  length(rp) - (SHELL+h);\n}\n\n\nvec3 grad(in vec3 rp)\n{\n    vec2 off = vec2(0.0005, 0.0);\n    vec3 g = vec3(map(rp + off.xyy) - map(rp - off.xyy),\n                  map(rp + off.yxy) - map(rp - off.yxy),\n                  map(rp + off.yyx) - map(rp - off.yyx));\n    return normalize(g);\n}\n\nvec3 traceSphere(in vec3 ro, in vec3 rd, float r, out float t1, out float t2)\n{\n    t1=t2=-1.0;\n    vec3 X = ro + rd * (dot(normalize(-ro), rd)) * length(ro);\n    float disc = r*r-pow(length(X), 2.0);\n    if (disc < 0.0) return vec3(1000000.0);\n    disc=sqrt(disc);\n    vec3 p=X-disc*rd;\n    t1=length(p-ro);t2=t1+disc*2.;\n    return p;\n}\n\nfloat getClouds(in vec3 hitp, float T)\n{\n    hitp *= rotx(-T);\n    vec3 hitp3 = hitp*rotz(T*.7);\n    vec3 hitp2 = hitp*roty(T);\n    \n    if(dot(hitp, hitp) > 10000.) return 0.;\n    float S = 1.;\n    float c = textureSpherical(iChannel0, hitp, .2*S).r*.75;\n    c += textureSpherical(iChannel0, hitp3, .7*S).r*.5*.5;\n    c += textureSpherical(iChannel0, hitp2, 1.4*S).r*.5*.5*.5;\n    c += textureSpherical(iChannel0, hitp, 2.4*S).r*.5*.5*.5*.5;\n    c += textureSpherical(iChannel0, hitp3, 4.4*S).r*.5*.5*.5*.5*.5;\n    return smoothstep(.55, .95, c);\n    \n}\n\nfloat traceClouds(in vec3 ro, in vec3 rd, float depth)\n{\n    float T = iTime*.02;\n    float t1=0.; float t2=0.;\n    if(t1<0.0) return 0.0;\n    vec3 hitp = traceSphere(ro, rd, OUTER_SHELL,t1,t2);\n    vec3 hitp2 = ro+rd*t2;\n    float c = getClouds(hitp, T);\n    if (depth > length(hitp2-ro))\n    {\n        float c2=getClouds(ro+rd*t2,T);\n        c=mix(c, c2, c2);\n    }\n    return c;\n}\n\nvec2 g_uv;\nvec3 g_viewDir;\n#define CLOUDS 0\n#define GROUND 1\n#define WATER 2\n\nvec4 waterTexture(in vec3 rp)\n{\n    rp=planetRotatedVec(rp);\n    float T = iTime*.01;\n    float S=2.0;\n    rp *= rotx(T);\n    float c1=textureSpherical(iChannel1, rp, S).x;\n    rp *= rotx(1.+T);\n    float c2=textureSpherical(iChannel1, rp, S).x;\n    rp *= rotx(2.+T);\n    float c3=textureSpherical(iChannel1, rp, S).x;\n    float B = iTime*2.;\n    float col = mix(c3, mix(c1, c2, 0.5+0.5*(sin(PI*0.5+B)*0.5+0.5)), 0.5+0.5*(sin(B)*0.5+0.5));\n    return vec4(col);\n    \n}\n\nvec3 gradWater(in vec3 rp)\n{\n    vec3 w=normalize(rp);\n    vec3 u=normalize(cross(vec3(0.0, 1.0, 0.0), w));\n    vec3 v=(cross( u,w));\n    \n    float s=.0009;\n    float h1 = waterTexture(rp).x;\n    float h2 = waterTexture(rp+u*s).x;\n    float h3 = waterTexture(rp+v*s).x;\n    \n    float bumpiness=.2;\n    vec3 v1 = normalize(vec3(bumpiness, h1-h2, 0.0));\n    vec3 v2 = normalize(vec3(0.0, bumpiness , h1-h3 ));\n    vec3 g = normalize(cross(v1,v2));\n    mat3 m; m[0]=v;m[1] = u;m[2]=w;\n    return m*g;\n}\n\n// Background nebula\nvec4 texSpace(in sampler2D tex, in vec3 dir)\n{\n    vec2 uv = vec2(atan(dir.x, dir.z), dir.y);\n    uv.x=abs(uv.x);\n\tuv*=.4;\n    vec4 col = texture(tex, uv);\n    uv+=col.rg*.05;\n    col = texture(tex, uv);\n    uv+=col.rg*.1;\n    col = texture(tex, uv);\n    \n    col*=smoothstep(0.1, 1.0, col.r);\n    vec4 col1=vec4(0.2, 0.2, .7, 0.0);\n    vec4 col2=vec4(0.2, 0.9, 0.5, 0.0);\n    vec4 cl=col*vec4(0.0, 0.5, 1.0, 0.0);\n    cl=mix(cl, col1, smoothstep(0.0, 0.4, col.r));\n    cl=mix(cl, col2, smoothstep(0.1, 0.6, col.r));\n    col=cl;\n    \n    col*=smoothstep(0.4, 0., abs(dir.y));\n    col*=smoothstep(1., .5, abs(uv.x));\n    col*= clamp((.6-abs(dir.y))-0.1*sin(2.0*atan(dir.x, dir.z)), 0.0, 1.0);\n    return col;\n}\n\nvec4 bgCol(in vec3 rd)\n{\n    vec4 col=texSpace(iChannel0, rd);\n    col+=smoothstep(0.93, 1.0, textureSpherical(iChannel2, rd, 1.0).g)*texture(iChannel1, vec2(.01*iTime+atan(rd.z, rd.x), rd.y)).r;\n    return col*.2;\n}\n\nfloat doShadows(in vec3 rp)\n{\n    float s = 1.0;\n    rp+=lightDir*.01;\n    \n    for (int i = 0; i < 4; ++i)\n    {\n    \tfloat dist=map(rp);\n        rp+=max(dist, 0.001)*lightDir;\n        s=min(s,dist);\n    }\n    return mix(1.0, clamp(s/0.01, 0.0, 1.0), 0.8);\n}\n\nvoid trace(in vec3 rp, in vec3 rd, inout vec4 color)\n{\n    vec4 top =   vec4(.3, .1, .2, .0)*.1;\n    vec4 bottom= vec4(.1, .0, .2, .0)*.1;\n    \n    color = mix(top, bottom, clamp(rd.y+0.5, 0.0, 1.0));\n    \n    color+=bgCol(rd);\n    bool hit = false;\n    vec3 ro = rp;\n    int hitId = CLOUDS;\n    float t1Clouds=0.0;float t2Clouds=0.0;\n    vec3 hitp = traceSphere(ro, rd, OUTER_SHELL,t1Clouds,t2Clouds);\n    \n    float dist = 99.;\n    \n    for (int i = 0; i < 20; ++i)\n    {\n        dist = map(rp);\n        rp += max(0.008, dist) * rd;\n\n        if (dist < 0.0)\n        {\n            hitId = GROUND;\n            break;\n        }\n\n        if (length(ro - rp) > 5.0) break;\n    }\n\n    \n    if (hitId==GROUND)\n    {\n        for (int i = 0; i < 8; ++i)\n        {\n            rp += rd*dist*.4;\n            dist = map(rp);\n        }\n    }\n\n    float depth = length(ro-rp);\n    float t1=0.0;float t2=0.0;\n\tvec3 waterLevelRp = traceSphere(ro, rd, WATERLEVEL+0.00*(sin(iTime*.25)*.5+.5),t1,t2);\n    float wdepth = length(ro-waterLevelRp);\n\t\n    if (wdepth < depth)\n    {\n        hitId=WATER;\n    }\n    \n    float waterLevel = map(waterLevelRp);\n    vec3 gGround = grad(rp);\n    vec3 gWaterSurface = normalize(waterLevelRp);\n    \n    float dGround = clamp(dot(gGround, lightDir), 0.05, 1.0);\n    float dWater = clamp(dot(gWaterSurface, lightDir), 0.05, 1.0);\n    float dGlobal = clamp(dot(normalize(rp), lightDir), 0.05, 1.0);\n    vec3 wg = gradWater(waterLevelRp);\n    dGlobal=(0.9+dGlobal)/(1.9);\n    \n    vec3 H = normalize(-rd+lightDir);\n    float dSpec = clamp(dot(H, wg), 0.0, 1.0);\n    dSpec = pow(dSpec, 56.0)*.7;\n    dSpec*=smoothstep(0.1, 0.2, dGlobal);\n    dGround*=dGlobal;\n    dWater*=dGlobal;\n    \n    if (hitId==GROUND)\n    {\n        vec4 cl = vec4(1.);\n        color=mix(cl, vec4(0.3, 0.5, 0.0, 0.5)*textureSpherical(iChannel2, rp, 16.0), 1.-smoothstep(0., 0.02, length(rp-waterLevelRp)));\n        color*=dGround;\n    }    \n\t\n    ////////\n    // Foam\n    ////////\n    if (hitId==WATER)\n    {\n        \n        float s = smoothstep(.007, .0, waterLevel);\n        vec4 c1 = vec4(0., 0.13,  0.3, 0.0);\n        vec4 c2 = vec4(0., 0.4, 0.6, 0.0);\n        \n        vec4 cl = mix(c1, c2, s);\n\t\tconst int stps = 4;\t\n        const float STP=2.;\n        const float phase=STP/float(stps);\n        float foam = 0.0;\n        const float b=STP/4.;\n        for (int i = 0; i < stps; ++i)\n        {\n            float T=iTime*.2+float(i)*phase;\n            vec3 _rp = waterLevelRp*3.;\n\t\t\tfloat p = mod(T, STP); \n            _rp-=p*gGround*.05;\n            \n            float f = textureSpherical(iChannel3, _rp, 3.0).r;\n\t\t\tf*=smoothstep(0.0, b, p);\n            f*=smoothstep(STP, STP-b, p);\n            foam = max(foam, f);\n        }\n       \tfoam = smoothstep(0.6, .9, foam);\n        foam*=s;\n        foam/=.4;\n        \n        float dFinal = mix(dWater, dGround, dGround);\n        cl += foam;\n        color = cl * dFinal;\n\t    color += vec4(dSpec);\n    }\n\t\n    \n    if (hitId==0 )\n    {\n        // Sun\n        float sund=clamp(dot(rd, lightDir), 0.0, 1.0);\n        float sunocc=clamp(dot(g_viewDir, lightDir), 0.0, 1.0);\n        sunocc=smoothstep(1.002, 0.99, sunocc);\n        float sun=(pow(sund, 40.))*sunocc;\n        sun=max(sun, smoothstep(0.99, 0.995, sund));\n        vec4 suncol=vec4(sun);\n        // cheap atmospeheric scattering effect. \n        //\n        // red scattering, direct light transport from sun to eye\n        vec4 mie=vec4(1.0, 0.2, 0., 1.0)*(t2Clouds-t1Clouds)*pow(sund, 15.)*3.;\n        \n        // blue, how much light gets reflected from ground to eye from sun\n        float rlscatter=clamp(dot(lightDir, reflect(rd,normalize(hitp))),0.2, 1.);\n        vec4 rayleigh=rlscatter*(t2Clouds-t1Clouds)*vec4(.4, .6, 1., 1.0);\n        // \n        vec4 atmos=mix(mie,rayleigh,1.-mie.a);\n        color+=atmos;                 \n        color+=suncol;                \n    }\n    \n    if(hitId!=0)\n    {\n\t    color*=doShadows(hitId==GROUND?rp:waterLevelRp);\n    }\n    \n    if(t1Clouds>=.0)\n    {\n#ifdef SHADOWS\n        vec3 nrp = normalize(rp);\n        float shad=traceClouds(nrp*10., -nrp, wdepth);\n    \n        if (hitId != CLOUDS)\n        {\n            color = mix(color, vec4(0.), shad*.7);\n        }\n#endif\n#ifdef DO_CLOUDS\n        float clouds = traceClouds(ro, rd, wdepth);\n        \n        // fading the clouds a little at the silhouettes\n        clouds*= mix(1.0, smoothstep(0.1, 0.4, abs(dot(rd, normalize(hitp)))), 0.9);\n        // dark side of the planet\n        float darkness=smoothstep(-0.4, 0.5,dot(normalize(hitp), lightDir));\n        color = mix(color, vec4(clouds*darkness), clouds);\n#endif\n    }\n\n    \n}\n\n\nmat3 lookat(vec3 from, vec3 to)\n{\n    vec3 f = normalize(to - from);\n    vec3 _tmpr = normalize(cross(f, vec3(0.0, 1.0, 0.0)));\n    vec3 u = normalize(cross(_tmpr, f));\n    vec3 r = normalize(cross(u, f));\n    return mat3(r, u, f);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n\tvec2 uv = ((fragCoord.xy / iResolution.xy)-vec2(.5))*vec2(1.0, iResolution.y/iResolution.x);\n    g_uv = uv;\n    g_planetRot=roty(iTime*.008)*rotz(iTime*.02);\n\n    vec2 im = 16.0 * ((iMouse.xy / iResolution.xy) - vec2(0.5));\n    vec3 rp = vec3(0.0, 0.0, -.8);\n    if(iMouse.z<=0.0) \n    {\t\n        float T=PI*(4.0/3.0)-iTime*.1+6.;\n        im.x=(0.5+0.5*cos(T))*3.;\n    \tim.y=sin(T)*8.;\n    }\n    rp = roty(-im.x) * rp;\n    rp.y = -im.y*.25;\n    \n    vec3 rd = normalize(vec3(uv, 1.0));\n    rd = lookat(rp, vec3(0.0)) * rd;\n    g_viewDir=lookat(rp, vec3(.0))*vec3(0.0, 0.0, 1.0);\n    trace(rp, rd, fragColor);\n    \n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0 / 2.2));\n\n}","name":"Image","description":"","type":"image"}]}