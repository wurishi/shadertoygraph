{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"video","id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define nrows 100.\n#define ncols 100.\n\nbool MIX_COLOR = true;\n\nfloat luminosity(vec4 col)\n{\n    return 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;\n}\n\nvec2 getTileSize()\n{\n    float tw = iResolution.x / nrows;\n    float th = iResolution.y / ncols;\n    \n    th *= (iResolution.x / iResolution.y);\n    \n    return vec2(tw, th);\n}\n\n// Returns tile coordinates between [0, 0] and [nrows-1, ncols-1]\nvec2 getCoord(vec2 coord)\n{\n    vec2 ts = getTileSize();\n    \n    int row = int(floor(coord.x / ts.x));\n    int col = int(floor(coord.y / ts.y));\n    \n    return vec2(row, col);\n}\n\nfloat sampleTile(vec2 coord)\n{\n    vec2 ts = getTileSize();\n    \n    float dx = ts.x / 4.;\n    float dy = ts.y / 4.;\n    \n    float startx = (coord.x * ts.x) + 0.5 * dx;\n    float starty = (coord.y * ts.y) + 0.5 * dy;\n    \n    float sum = 0.;\n    \n    for(int i = 0; i < 4; i++)\n    {\n        float x = startx + float(i) * dx;\n        \n        for(int j = 0; j < 4; j++)\n        {\n            float y = starty + float(j) * dy;\n            \n            vec2 coord = vec2(x, y) / iResolution.xy;\n            \n            vec4 col = texture(iChannel0, coord);\n            \n            float l = luminosity(col);\n            \n            sum += l;\n        }\n    }\n    \n    return sum / 16.;\n}\n\n\nvec4 makeLum(float f)\n{\n    return vec4(vec3(f), 1.);\n}\n\nvec4 grid(vec2 coord)\n{\n    vec2 tileCoord = getCoord(coord);\n    \n    if (mod(tileCoord.x, 2.) == mod(tileCoord.y, 2.))\n    {\n        return vec4(1);\n    }\n    \n    else\n    {\n        return vec4(vec3(0), 1);\n    }\n}\n\nvec4 tileCircle(vec2 tileCoord, vec2 windowCoord, float lum)\n{\n    // First, get center of circle for this tile\n    vec2 tileSize = getTileSize();\n    \n    vec2 tileStart = tileCoord * tileSize;\n    \n    vec2 circleCenter = tileStart + 0.5 * tileSize;\n    \n    //float circleRadius = length(tileSize) * (iResolution.y / iResolution.x) * 0.5;\n    float circleRadius = length(tileSize) * 0.5;\n    \n    circleRadius *= lum;\n    \n    float d = length(windowCoord - circleCenter);\n    \n    if (d < circleRadius)\n    {\n        return vec4(vec3(1), 1.0);\n    }\n    else\n    {\n        return vec4(0);\n    }\n}\n\nvec4 comicShader(vec2 coord)\n{\n    vec2 uv = coord / iResolution.xy;\n    \n    // Get tile coord\n    vec2 tileCoord = getCoord(coord);\n        \n    // Sample colors from tile\n    float lum = sampleTile(tileCoord);\n    \n    return tileCircle(tileCoord, coord, lum);\n}\n\nvec4 normalShader(vec2 uv)\n{\n    return texture(iChannel0, uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord.xy;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 col = comicShader(coord);\n    \n    if (MIX_COLOR)\n    {\n        col = col * normalShader(uv);\n    }\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lsBXzV","date":"1413787597","viewed":741,"name":"Comic print","username":"toothmang","description":"Tile the input into a series of circles, and use a luminosity average in each tile to determine the radius of each circle. Optional mix with the normal color as a sort of image filter. Also, we need more video sources than Britney Spears. ","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["2d","imageprocessing","subsampling"],"hasliked":0,"parentid":"","parentname":""}}