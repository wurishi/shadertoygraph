{"ver":"0.1","info":{"id":"7lBcDD","date":"1649693759","viewed":63,"name":"Ray Marching Smooth Balls","username":"BeepBoop","description":"Use ray marching to smooth balls and plane.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DISTANCE 100.0\n#define SURF_DISTANCE 0.001\n#define SMOOTH 0.75\n\nfloat smoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sphereSDF(vec3 pos, vec3 sphere, float radius){\n    return length(pos-sphere)-radius;\n}\n\nfloat spheres(vec3 ray_origin){\n    float sphere = sphereSDF(ray_origin, vec3(0,1.0+(cos(iTime)),5), 0.5);\n    float sphere2 = sphereSDF(ray_origin, vec3(1.5,1.0+(sin(iTime)),5), 0.5);\n    float sphere3 = sphereSDF(ray_origin, vec3(-1.5,1.0+(sin(iTime)),5), 0.5);\n    float smooth1 = smoothUnion(sphere,sphere2,SMOOTH);\n    float smooth2 = smoothUnion(sphere,sphere3,SMOOTH);\n    float smooth3 = smoothUnion(sphere2,sphere3,SMOOTH);\n    float min1 = smoothUnion(smooth1,smooth2,SMOOTH);\n    float min2 = smoothUnion(min1,smooth3,SMOOTH);\n    return min2;\n}\n\nfloat sceneSDF(vec3 ray_origin){\n    float plane_distance = ray_origin.y;\n    //float sphere = sphereSDF(ray_origin, vec3(0,1.0+(sin(iTime)),5), 1.0);\n    //return min(plane_distance,sphere);\n    float sphere = spheres(ray_origin);\n    return smoothUnion(plane_distance, sphere, SMOOTH);\n}\n\nfloat getDistance(vec3 ray_origin, vec3 ray_direction){\n    float distance_from_origin = 0.0;\n  \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ray_origin + ray_direction*distance_from_origin;\n        float distance_to_scene = sceneSDF(p);\n        distance_from_origin += distance_to_scene;\n        \n        if(distance_from_origin>MAX_DISTANCE || distance_to_scene<SURF_DISTANCE){\n            break;\n        }\n    }\n    \n    return distance_from_origin;\n}\n\nvec3 getNormal(vec3 pos)\n{\n    float distance = sceneSDF(pos);\n    vec2 e = vec2(0.01,0);\n    vec3 n = distance - vec3(\n        sceneSDF(pos-e.xyy),\n        sceneSDF(pos-e.yxy),\n        sceneSDF(pos-e.yyx)\n    );\n    return normalize(n);\n}\n\nfloat getLightLevel(vec3 pos)\n{\n    vec3 light_pos = vec3(0,5,0);\n    //light_pos.xz += vec2(sin(iTime)*4.0,cos(iTime)*4.0);\n    \n    vec3 to_light = normalize(light_pos-pos);\n    vec3 surface_normal = getNormal(pos);\n    \n    return dot(to_light, surface_normal);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-(0.5*iResolution.xy))/iResolution.xy;\n    \n    // Camera\n    vec3 camera_origin = vec3(0,1,-2);\n    vec3 camera_direction = normalize(vec3(uv.x,uv.y,1));\n    \n    float distance = getDistance(camera_origin,camera_direction);\n    \n    vec3 distant_point = camera_origin + camera_direction*distance;\n    \n    float light_level = getLightLevel(distant_point);\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    if(distant_point.y <= 0.3){\n        col = vec3(0.8,0,0.0) * light_level;\n    }else{\n        col = vec3(0.0,0.0,0.8) * light_level;\n    }\n    \n    //col = vec3(distance/8.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}