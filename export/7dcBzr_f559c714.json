{"ver":"0.1","info":{"id":"7dcBzr","date":"1655920340","viewed":182,"name":"Black Hole Raycaster","username":"joteakus","description":"It's kind of slow because it is only a fixed-step raymarcher, but it looks awesome because the rays are affected by gravity! The ring over the top is actually the top of the real ring that is behind the black hole but appears bent from gravity.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["ray","light","space","raymarcher","blackhole","physics","gravity","raycaster","bending"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//begin variable definitions\nvec2 uv; //2D uv space\nvec3 col; //RGB\nvec3 ray; //ray angle\nvec3 p; //ray end position\nvec3 camera = vec3(0.,0.8,-10.); //camera position\nvec3 bhp = vec3(0.,0.,0.); //black hole position\nvec3 temp;\nvec3 ringcol = vec3(1., 0.91764705882, 0.78823529411);\nfloat oradius; //distance to center of black hole\nfloat bhradius = 1.; //radius of event horizon\nfloat bhm = 0.025; //mass of black hole\nfloat G = 1.;  //big G\nfloat F; //force on ray\nfloat raylen; //length of ray\nfloat brightness; //brightness of band of disk\nfloat smallstepnum = 5.; //detail of ring checks (higher is slower but more precise)\nfloat d; //distance modifier for disk coloring\nconst float dtr = 3.14159265359/180.; //conversion of degrees to radians (dg*dtr=radians)\nbool hit;\nint hittype; //ring or event horizon (1/2)\n//end variable definitions\n//begin rotation functions\nvec3 xr(vec3 inp, float dir){\n\n    ray.x = inp.x;\n    ray.y = (inp.y*cos(dir))-(inp.z*sin(dir));\n    ray.z = (inp.y*sin(dir))+(inp.z*cos(dir));\n    return ray;\n\n}\n\nvec3 yr(vec3 inp, float dir){\n\n    ray.x = (inp.x*cos(dir))-(inp.z*sin(dir));\n    ray.y = inp.y;\n    ray.z = (inp.x*sin(dir))+(inp.z*cos(dir));\n    return ray;\n\n}\n\nvec3 zr(vec3 inp, float dir){\n\n    ray.x = (inp.x*cos(dir))-(inp.y*sin(dir));\n    ray.y = (inp.x*sin(dir))+(inp.y*cos(dir));\n    ray.z = inp.z;\n    return ray;\n\n}\n//end rotation functions\n//apply rotation fcuntions:\nvec3 transformUV(vec2 screenp, float fl, vec3 dir){\n\n    temp = zr(normalize(vec3(screenp, fl)), dir.z*dtr);\n    temp = xr(temp, dir.x*dtr);\n    temp = yr(temp, dir.y*dtr);\n    return temp;\n    \n\n}\n//steps ray forwards\nvoid moveray(float steps){\n    \n    //moves along the ray direction vector n units\n    p += ray*steps;\n    raylen += steps;\n\n}\n//begin ray\nvoid shootray(vec3 rv, vec3 or){\n\n    //initalize\n    ray = rv;\n    p = or;\n    raylen = 0.;\n    hit = false;\n    \n    //step ray untill collision or overshot\n    while(raylen < 20. && hit == false){\n    \n    hittype = 1; //intializes to event horizon, but collision with ring changes it\n    \n        oradius = distance(p, bhp);\n        if(bhradius < oradius){ //outside event horizon\n            \n            for(float i = 0.; i < smallstepnum; i++){ //move forward to check for ring\n            \n                if(distance(p.xz, bhp.xz)-bhradius < 3. && abs(bhp.y - p.y) < 0.01){ //ring collision, 0.02 is thickness, 3. is radius \n                \n                hit = true;\n                hittype = 2;\n                break;\n                \n                }\n            moveray(0.1/smallstepnum);\n            \n            }\n            \n            moveray(-0.1);\n            \n            if(hit == false){\n            \n                F = G*(bhm/(oradius*oradius)); //force = big G times mass divided by radius squared\n                ray += F*(bhp-p);\n                ray = normalize(ray); //makes ray usable again\n                moveray(0.1);\n            \n            }\n            \n        }else{\n        \n            hit = true; //for if past event hoizon\n            \n        }\n    \n    }\n    \n    if(hit == true && hittype == 2){\n    \n        //coloring mumbo jumbo\n        col = ringcol;\n        \n        d = dtr*1.*(distance(bhp, p)-bhradius);\n        \n        brightness = 0.1+(0.2*sin(d*500.))+(0.4*sin(d*250.))+(0.6*sin(d*125.))+(0.8*sin(d*62.5));\n        \n        brightness /= 1.6955;\n        \n        brightness = 0.25+max(0.,brightness);\n        \n        col *= brightness;\n        \n        col = col*(0.5+0.5*((3.-(distance(bhp, p)-bhradius))/3.));\n        \n        \n        \n    }else{\n    \n        col = vec3(0.);\n        \n    }\n\n}\n//end ray\n//main function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //setup uv for a raycaster\n    uv = fragCoord/iResolution.xy-0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    camera = vec3(0., 2.*sin(iTime*0.5), -10.+2.*cos(iTime*0.25));\n    \n    //shoot a ray from rotated uv space with focal length of 1.2, from camera\n    shootray(transformUV(uv, 1.2, vec3(7., 0., 20.)), camera);\n    \n    fragColor = vec4(col,1.0);\n    \n}","name":"Image","description":"","type":"image"}]}