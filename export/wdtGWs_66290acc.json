{"ver":"0.1","info":{"id":"wdtGWs","date":"1569603491","viewed":102,"name":"My first fractal","username":"Radiant","description":"biba","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define raymarch_iterations 24\n#define fractal_depth 16\n#define PI 3.14159265\n\n#define epsilon 0.001\n\nfloat far_clip = 50.0;\nvec3 v_main_color = vec3(1.0, 0.1, 0.1);\nvec3 v_sky_color = vec3(0.6, 0.8, 0.8);\n\n// fractal parameters\nfloat fractal_radius = 0.1;\nfloat fractal_scale = 1.55;\nvec3 fractal_offset = vec3(-0.1,-2.1,-0.3);\nmat3 m;\n\nfloat getAngle(vec3 v1, vec3 v2)\n{\n\treturn atan(length(cross(v1, v2)), dot(v1, v2));\n}\n\nfloat primitiveDist(vec3 pos)\n{\n    float x = abs(pos.x);\n    float y = abs(pos.y);\n    float z = abs(pos.z);\n\treturn max(max(x, y), z);   // cubes\n//\treturn x + y + z;\t\t\t// octaedrs (don't work)\n//\treturn length(pos.xyz);     // spheres\n}\n\nvec2 getDistance(vec3 v_pos)\n{\n\tfloat f_trap = far_clip;\n    float f_total_scale = 1.0;\n    \n    for (int i = 0; i < fractal_depth; i++)\n    {\n\t\tv_pos.xyz = abs(v_pos.xyz);\n        v_pos *= fractal_scale;\n        f_total_scale *= fractal_scale;\n        v_pos += fractal_offset;\n        v_pos *= m;\n        \n        float f_curr_dist = primitiveDist(v_pos) * f_total_scale;\n        f_trap = min(f_trap, f_curr_dist);\n    }\n    \n    float l = primitiveDist(v_pos) / f_total_scale;\n    \n    float f_dist = l - fractal_radius;\n    \n    return vec2(f_dist, f_trap);\n}\n\nvec3 getNormal(vec3 v_pos)\n{\n    float f_delta = 0.0001;\n\tvec3 v_offset1 = vec3( f_delta, -f_delta, -f_delta); \n\tvec3 v_offset2 = vec3(-f_delta, -f_delta,  f_delta); \n\tvec3 v_offset3 = vec3(-f_delta,  f_delta, -f_delta); \n\tvec3 v_offset4 = vec3( f_delta,  f_delta,  f_delta); \n    \n    float f1 = getDistance(v_pos + v_offset1).x;\n    float f2 = getDistance(v_pos + v_offset2).x;\n    float f3 = getDistance(v_pos + v_offset3).x;\n    float f4 = getDistance(v_pos + v_offset4).x;\n    \n    vec3 v_normal = v_offset1 * f1 +  v_offset2 * f2 +  v_offset3 * f3 +  v_offset4 * f4; \n    \n    return vec3(v_normal);\n}\n\nvec4 raycast(vec3 v_ray_origin, vec3 v_ray_direction)\n{\n\tfloat f_closest = far_clip;\n    vec2 d = vec2(0.0);\n    float t = 0.01;\n    \n    for (int i = 0; i < raymarch_iterations; i++)\n    {\n\t\td = getDistance(v_ray_origin + v_ray_direction * t);\n        f_closest = min(f_closest, d.x);\n        \n        if (abs(d.x) < epsilon)\n        {\n\t\t\tbreak;\n        }\n        \n        t += d.x;\n        \n        if (t > far_clip)\n        {\n\t\t\tt = far_clip;\n            break;\n        }\n    }\n    \n    return vec4(t, d.x, d.y, f_closest);\n}\n\nvec3 traceRay(vec3 v_ray_origin, vec3 v_ray_direction, vec3 v_light)\n{\n\tvec4 v_hit = raycast(v_ray_origin, v_ray_direction);  \n    vec3 v_hit_point = v_ray_origin + v_ray_direction * v_hit.x;\n    \n\tvec3 n = getNormal(v_hit_point);\n    \n    float f_angle = getAngle(n, v_light - v_hit_point);\n    vec4 v_light_hit = raycast(v_light, normalize(v_hit_point - v_light));\n    \n    vec3 v_hit_pos = v_ray_origin + v_ray_direction * v_hit.x;\n    vec3 v_color = v_sky_color;\n    \n    if (v_hit.w < fractal_radius * 0.4)\n    {\n        v_color = v_main_color;\n\t\tv_color *= (1.0 - clamp(f_angle / PI, 0.0, 0.7));\n        \n        if (abs(v_light_hit.x - length(v_light - v_hit_point)) > 0.1)\n        {\n\t\t\tv_color *= 0.5;\n        }\n    }\n    \n    return vec3(v_color);\n}\n\nmat3 calculateMatrix(float param)\n{\n\tfloat a = sin(param + 2.0); // yaw\n\tfloat b = sin(param + 4.0); // pitch\n\tfloat c = sin(param);       // roll\n        \n    vec3 v1 = vec3(cos(a)*cos(b), cos(a)*sin(b)*sin(c)-sin(a)*cos(c), cos(a)*sin(b)*cos(c)+sin(a)*sin(c));    \n    vec3 v2 = vec3(sin(a)*cos(b), sin(a)*sin(b)*sin(c)+cos(a)*cos(c), sin(a)*sin(b)*cos(c)-cos(a)*sin(c));\n    vec3 v3 = vec3(-sin(b), cos(b)*sin(c), cos(b)*cos(c));\n    mat3 r = mat3 (v1, v2, v3);\n    \n    return r;\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 v_window = uv * 2.0 - 1.0;\n    v_window.x *= iResolution.x / iResolution.y;\n    \n    // Camera parameters\n    float f_angle = iTime / PI * 2.0 + 1.0;\n    float f_camera_distance = 5.0;\n    vec3 v_camera_position = vec3(sin(f_angle), 0.5, cos(f_angle)) * f_camera_distance;\n\tvec3 v_camera_target = vec3(0.0, 0.0, 0.0);\n    \n    float zoom = 1.0;\n    vec3 v_forward = normalize(v_camera_target - v_camera_position);    \n    vec3 v_right = normalize(cross(vec3(0.0, 1.0, 0.0), v_forward));    \n    vec3 v_up = normalize(cross(v_forward, v_right));\n                             \n    vec3 v_dir = normalize(v_window.x * v_right + v_window.y * v_up + v_forward * zoom);                         \n    \n    // Light Parameters\n    vec3 v_light_pos = vec3(2.1, 2.2, 1.5) * 10.0;\n    \n    m = calculateMatrix(iTime);\n    \n    vec3 result = traceRay(v_camera_position, v_dir, v_light_pos);                         \n                                \n    fragColor = vec4(result,1.0);\n}","name":"Image","description":"","type":"image"}]}