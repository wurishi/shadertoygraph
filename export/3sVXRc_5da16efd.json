{"ver":"0.1","info":{"id":"3sVXRc","date":"1575922546","viewed":494,"name":"Snow globe","username":"vegardno","description":"My first attempt at a more complex scene. Please point out my mistakes :-)","likes":16,"published":1,"flags":96,"usePreview":1,"tags":["christmas","refraction","snowflake","snow","musicbox","snowglobe","snowglobe","locomotive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4lSGzR","filepath":"https://soundcloud.com/vegard_no/silent-night","previewfilepath":"https://soundcloud.com/vegard_no/silent-night","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * https://twitter.com/vegard_no\n *\n * My first attempt at a more complex scene.\n *\n * Not really optimized.\n * Antialiasing would be nice but I don't know how to do it yet.\n *\n * References:\n *  - http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n *  - https://iquilezles.org/\n *\n * Tabs:\n *  - Common: locomotive SDF\n *  - Buffer A: ray marching\n *  - Buffer B: blur\n *  - Image: combine\n *\n * Performance:\n *  - GTX 1070:    1920x1080 => 144 fps\n *  - Intel HD 520: 640x360  => ~12 fps\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\tvec4 col0 = texture(iChannel0, uv);\n    vec4 col1 = texture(iChannel1, uv);\n\n    // use depth information to control blur\n    vec3 col = mix(col0.rgb, col1.rgb, col0.w);\n    \n    // vignette\n    // https://www.shadertoy.com/view/Xd2GR3\n    col *= pow( 16.0*uv.x*(1.0-uv.x)*uv.y*(1.0-uv.y), 0.15 );\n    \n\tfragColor = vec4(pow(col, vec3(1. / gamma)), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Debug toggles\nconst float rotation_speed = 1.;\nconst bool use_locomotive = true;\nconst bool use_2d_snow = false;\nconst bool use_interior_3d_snow = true;\nconst bool use_exterior_3d_snow = true;\nconst bool use_snowflakes = true;\n\n// straight down\nconst vec3 light_dir = normalize(vec3(.2, .4, .2));\nconst float checkerboard_size = 4.;\n\nconst vec3 snow_color = pow(vec3(1., 1., 1.14), vec3(gamma));\n\nconst float snow_min_light = .0;\nconst vec3 snow_color_shadow = pow(1.3 * vec3(11., 48., 77.) / vec3(255.), vec3(gamma));\nconst vec3 snow_color_light = pow(1.1 * mix(vec3(175., 203., 227.),\n                                        vec3(240., 245., 249.), .5) / vec3(255.), vec3(gamma));\n\n// Materials\n#define MAT_SNOW 0\n#define MAT_METAL 1\n#define MAT_METAL_SNOW 2\n#define MAT_SNOWFLAKE 3\n#define MAT_STAND 4\n\n// Scenes\n#define SCENE_INTERIOR 0\n#define SCENE_EXTERIOR 1\n#define SCENE_SNOWFLAKES 2\n\nmat4 rotate(float a, vec3 v)\n{\n    float c = cos(a);\n    vec3 ci = (1. - c) * v;\n    vec3 s = sin(a) * v;\n\n    return mat4(\n        ci.x * v.x + c, ci.x * v.y + s.z, ci.x * v.z - s.y, 0,\n        ci.y * v.x - s.z, ci.y * v.y + c, ci.y * v.z + s.x, 0,\n        ci.z * v.x + s.y, ci.z * v.y - s.x, ci.z * v.z + c, 0,\n        0, 0, 0, 1\n\t);\n}\n\nmat4 translate(vec3 v)\n{\n    return mat4(\n        1, 0, 0, 0,\n        0, 1, 0, 0,\n        0, 0, 1, 0,\n        v.x, v.y, v.z, 1\n    );\n}\n\n// signed distance to a n-star polygon with external angle en\nfloat sdStar(in vec2 p, in float r, in int n, in float m) // m=[2,n]\n{\n    // these 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) and simplify, for regular polygon,\n\n    // reduce to first sector\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    // line sdf\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\n// https://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand(vec3 co){\n  return fract(sin(dot(co ,vec3(12.9898,78.233, 45.8132))) * 43758.5453);\n}\n\nfloat sdSky(vec2 p)\n{\n    vec2 q = floor((p + 10.) / 20.);\n    p = mod(p + 10., 20.) - 10.;\n    p += 15. * (vec2(rand(vec2(q.x + 0., q.y)),\n                    rand(vec2(q.x + 1., q.y))) - vec2(.5, .5));\n\n\n    // size distribution of stars in the sky\n    //  - small near the horizon, big straight up\n    //  - random factor (exponential distribution)\n    float size = .5 + 2. * pow(smoothstep(-1.4, 2.3, q.y) * rand(vec2(q.x + 2., q.y)), 4.);\n    \n\treturn sdStar( p, size, 5, 3. ) - .18;\n}\n\n\nfloat sdSnow(vec2 p)\n{\n    vec2 q = floor((p + 10.) / 20.);\n    p = mod(p + 10., 20.) - 10.;\n\n    float x = rand(vec2(q.x + 10., q.y)) - .5;\n    float y = rand(vec2(q.x + 11., q.y)) - .5;\n\n    float f = 1. + 5. * rand(vec2(q.x + 3., q.y));\n \tfloat t = f * iTime;\n\tx = mix(x, .5 * sin(t), .5);\n    \n    p += 16. * vec2(x, y);\n\n    //float size = 1. + .5 * pow(rand(vec2(q.x + 1., q.y)), 4.);\n    float size = .6;\n\n\treturn length(p) - size;\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// From iq -- see https://www.shadertoy.com/view/wsGSD3\nfloat sdSnowflake( in vec2 p )\n{\n    const vec2 k = vec2(0.5,-0.86602540378);\n    p = p.yx;\n    p = abs(p);\n    p -= 2.0*min(dot(k,p),0.0)*k;\n    p = abs(p);\n\tfloat   d = sdLine( p, vec2(.00, 0), vec2(.75, 0) );\n    d = min(d,  sdLine( p, vec2(.50, 0), vec2(.50, 0) + .10));\n    d = min(d,  sdLine( p, vec2(.25, 0), vec2(.25, 0) + .15));\n    return d - .02;\n}\n\n// Also from iq: 3d extrusion of 2d SDF\nfloat sdSnowflake(in vec3 p)\n{\n    const float h = .002;\n    float d = sdSnowflake(20. * p.xy) / 20.;\n    vec2 w = vec2( d, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\n// 3d version of above\nfloat sdSnow(vec3 p, float size, bool snowflakes)\n{\n    const float period = 1.4;\n    \n    vec3 q = floor((p + .5 * period) / period);\n    p = mod(p + .5 * period, period) - .5 * period;\n\n    float x = rand(q + vec3(10.)) - .5;\n    float y = rand(q + vec3(11.)) - .5;\n    float z = rand(q + vec3(12.)) - .5;\n\n    float f = 1. + 5. * rand(q + vec3(13.));\n \tfloat t = f * iTime;\n\tx = mix(x, .5 * sin(t), .5);\n    z = mix(z, .5 * cos(t), .5);\n    \n    p += .4 * vec3(x, y, z);\n\n    //float size = 1. + .5 * pow(rand(vec2(q.x + 1., q.y)), 4.);\n    //float size = .04;\n\n    if (snowflakes) {\n        p = (rotate(radians(180.) * iTime, vec3(0, 0, 1)) * vec4(p, 1)).xyz;\n        \n        float rot = radians(360.) * rand(q + vec3(14.));\n        p = (rotate(rot, vec3(1, 0, 0)) * vec4(p, 1)).xyz;\n\n    \treturn sdSnowflake(p);\n    }\n\n\treturn length(p) - size;\n}\n\nvec3 background(in vec3 dir)\n{\n    const float scale = 130.;\n\n    vec2 uv = vec2(atan(dir.z, dir.x) / radians(90.), dir.y);\n    float d = sdSky(scale * uv * vec2(1, .8));\n\n#if 0\n    // TODO: resolution-independent anti-aliasing\n    return vec3(0, 0, 1) * (.4 - .6 * uv.y)\n        + vec3(1, 1, .5) * smoothstep(0., -.2, d);\n#endif\n    \n    const vec3 dark = pow(.5 * vec3(11., 48., 77.) / vec3(255.), vec3(gamma));\n    const vec3 light = pow(vec3(106., 176., 226.) / vec3(255.), vec3(gamma));\n    const vec3 star_dark = pow(vec3(1, 1, .4), vec3(gamma));\n    const vec3 star_light = pow(vec3(1, 1, 1), vec3(gamma));\n    \n    float t = .3 - .8 * uv.y;\n    vec3 sky = mix(dark, light, clamp(t, 0., 1.));\n\n    vec3 stars = mix(star_dark, star_light, smoothstep(-.7, 1.5, t));\n    \n    return mix(sky, stars, smoothstep(0., -.2, d));\n}\n\n// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n// intersect ray with sphere to find\n//  - the distance to the sphere\n//  - and the point of intersection on the sphere\n// http://viclw17.github.io/2018/07/16/raytracing-ray-sphere-intersection/\nint intersect_ray_sphere(vec3 origin, vec3 direction, vec3 center, float radius, out float near, out float far)\n{\n    vec3 oc = origin - center;\n    float a = dot(direction, direction);\n    float b = 2. * dot(oc, direction);\n    float c = dot(oc, oc) - radius * radius;\n    float disc = b * b - 4. * a * c;\n    if (disc < 0.) {\n        // no intersection?\n        return 0;\n    }\n\n    near = (-b - sqrt(disc)) / (2. * a);\n    far = (-b + sqrt(disc)) / (2. * a);\n    return 1;\n}\n\n// https://www.gamedev.net/forums/topic/497459-distance-from-point-to-plane-along-a-vector/\nvoid intersect_ray_plane(vec3 origin, vec3 direction, vec3 plane_normal, float plane_offset, out float near)\n{\n    float t = -(dot(plane_normal, origin) + plane_offset) / dot(plane_normal, direction);\n    near = t * length(direction);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat globeInteriorSDF(in vec3 p, inout int material)\n{\n    float d;\n\n    {\n    \tvec3 q = 3. * p + vec3(0., 4.5, 0.);\n    \td = smin(smin(length(q - vec3(-4., -2., -1.)) - 6.05,\n                      length(q - vec3( 3., -3.,  5.)) - 7.13, 3.),\n                      length(q - vec3( 1., -3.5, -4.)) - 8.22, 3.) / 3.;\n    }\n\n    if (use_locomotive) {\n        const float scale = 20.;\n        p.x = -p.x;\n        vec3 q = scale * p - vec3(7., -2., 0);\n\n        float d_loc = sdTracks(q) / scale;\n        d_loc = min(d_loc, sdLocomotive(q, .5 * iTime) / scale - .007);\n        if (d_loc < d) {\n            d = d_loc;\n            material = MAT_METAL_SNOW;\n        }\n    }\n    \n    if (use_interior_3d_snow) {\n        const float snow_size = .03;\n\n        float d_snow = sdSnow(p - vec3( 0., -.5 * iTime + 0.,  0), snow_size, false);\n        p = (rotate(radians(45.), vec3(0, 1, 0)) * vec4(p, 1)).xyz;\n        d_snow = min(d_snow, sdSnow(p - vec3(43., -.5 * iTime + 2., 13.), snow_size, false));\n        if (d_snow < d) {\n            d = d_snow;\n            material = MAT_SNOWFLAKE;\n        }\n    }\n\n    return d;\n}\n\nvec3 globeInteriorMat(in vec3 p, in vec3 normal, in int material)\n{\n    switch (material) {\n\tcase MAT_SNOW:\n        // blue snow\n        return mix(snow_color_shadow, snow_color_light, max(snow_min_light, dot(light_dir, normal)));\n\tcase MAT_METAL:\n        {\n        \t// handle\n        \tvec3 col = texture(iChannel0, normalize(normal)).rrr;\n        \treturn pow(vec3(.15), vec3(gamma)) + col * max(snow_min_light, dot(light_dir, normal));\n        }\n\tcase MAT_METAL_SNOW:\n        // locomotive\n        vec3 col = texture(iChannel0, normalize(normal)).rrr;\n        return mix(pow(vec3(.15), vec3(gamma)) + col * max(snow_min_light, dot(light_dir, normal)),\n                   snow_color_light,\n                   smoothstep(.5, .6, dot(vec3(0, 1, 0), normal)));\n    case MAT_SNOWFLAKE:\n        // pure white snow\n        return vec3(1);\n\tcase MAT_STAND:\n        const vec3 dark = pow(vec3(.2, 0, 0), vec3(gamma));\n        const vec3 light = pow(vec3(.7, 0, 0), vec3(gamma));\n        return mix(dark, light, max(0., dot(light_dir, normal)));\n    }\n\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat exteriorSDF(in vec3 p, inout int material)\n{\n    float d = 1e10;\n    \n    // stand for the globe\n    if (true) {\n    \tconst float h = 1.;\n    \tconst float r = 2.2;\n    \tconst float r0 = r + 1.;\n    \tconst float r1 = r + .8;\n\n        d = sdCone(p - vec3(0, -3., 0), h, r0, r1) - .2;\n        material = MAT_STAND;\n    }\n    \n    // musix box handle\n    if (true) {\n        /*\n        float sdCapsule( vec3 p, vec3 a, vec3 b, float r );\n        float sdHorizontalCapsule( vec3 p, float h, float r );\n        float sdVerticalCapsule( vec3 p, float h, float r );\n        float sdCappedXCylinder( vec3 p, vec2 h );\n        float sdCappedYCylinder( vec3 p, vec2 h );\n        float sdCappedZCylinder( vec3 p, vec2 h );\n\t\t*/\n\n        const float r = .08;\n        float t = 5. * iTime;\n        vec3 h = .4 * vec3(sin(t), cos(t), 0);\n\n        float d_handle =       sdZCapsule(p - vec3(0., -2.5, 3.0), .6, r);        \n        d_handle = min(d_handle, sdCapsule(p, vec3(0., -2.5, 3.6), vec3(0., -2.5, 3.6) + h, r));\n        d_handle = min(d_handle, sdCapsule(p, vec3(0., -2.5, 3.6) + h, vec3(0., -2.5, 3.6 + .4) + h.xyz, r));\n        \n        if (d_handle < d) {\n            d = d_handle;\n            material = MAT_METAL;\n        }\n    }\n\n    // ground\n    if (true) {\n        const float r = 75.;\n    \tconst float spread = 4.5;\n        const float k = 130.;\n\n        p.y += -3.;\n        \n        float d_ground = 1e10;\n    \td_ground = smin(d_ground, length(p + vec3(0, r, 0) + spread * vec3( 17.,  0,  20.)) - r + 12., k);\n    \td_ground = smin(d_ground, length(p + vec3(0, r, 0) + spread * vec3( 21.,  0, -19.)) - r +  1., k);\n    \td_ground = smin(d_ground, length(p + vec3(0, r, 0) + spread * vec3(-18.,  0,  15.)) - r +  1., k);\n    \td_ground = smin(d_ground, length(p + vec3(0, r, 0) + spread * vec3(-15.,  0, -16.)) - r + 20., k);\n        \n        // one central sphere touching/intersecting slightly with the foot of the snow globe\n        d_ground = smin(d_ground, length(p + vec3(0, 12., 0)) - 12. + 10., 10.);\n        \n        if (d_ground < d) {\n            d = d_ground;\n            material = MAT_SNOW;\n        }\n    }\n    \n    // snow on top of globe\n    if (true) {\n        const float yoff = 2.6;\n        \n        float d_cap = opSmoothSubtraction(\n            smin(length(p + vec3(-.2, yoff + .8, .0)) - 4.5,\n                 length(p + vec3( .1, yoff + .9, .1)) - 4.5,\n                 .05),\n            length(p + vec3(0, yoff, 0)) - 4.5,\n            2.) - .15;\n\n        if (d_cap < d) {\n        \td = d_cap;\n        \tmaterial = MAT_SNOW;\n    \t}\n    }\n    \n    return d;\n}\n\nfloat fallingSnowSDF(in vec3 p, inout int material)\n{\n    const float snow_scale = 4.;\n    const float snow_size = .02;\n    float d = sdSnow((p - vec3(0, - 2. * iTime, 0)) / snow_scale, snow_size, use_snowflakes);\n\n    // avoid aliasing \"gaps\" between groups of snowflaks\n    // (comment out to see the difference)\n    p = (rotate(45., normalize(vec3(0, 1, 0))) * vec4(p, 1.)).xyz;\n\n    d = min(d, sdSnow((p - vec3(29.1, 3. - 2. * iTime, 173.114)) / snow_scale, snow_size, use_snowflakes));\n    d *= snow_scale;\n\n    material = MAT_SNOWFLAKE;\n    return d;\n}\n\nfloat sceneSDF(const int scene, in vec3 p, out int material)\n{\n    // default\n    material = MAT_SNOW;\n    \n    switch (scene) {\n    case SCENE_INTERIOR:\n        return globeInteriorSDF(p, material);\n    case SCENE_EXTERIOR:\n        return exteriorSDF(p, material);\n\tcase SCENE_SNOWFLAKES:\n        return fallingSnowSDF(p, material);\n    }\n}\n\n#define FIND_CLOSEST_MATERIAL 0\n\n// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nfloat castRay(const int scene, vec3 eye, vec3 dir, float start, float end, float epsilon, int max_marching_steps, out int material) {\n#if FIND_CLOSEST_MATERIAL\n    float min_d = 1e10;\n    int min_material = 0;\n#endif\n    \n    float depth = start;\n    for (int i = 0; i < max_marching_steps; i++) {\n        float d = sceneSDF(scene, eye + depth * dir, material);\n#if FIND_CLOSEST_MATERIAL\n        if (d < min_d) {\n            min_d = d;\n            min_material = material;\n        }\n#endif\n\n        if (d < epsilon)\n\t\t\treturn depth;\n\n        depth += d;\n        if (depth >= end)\n            break;\n    }\n\n#if FIND_CLOSEST_MATERIAL\n    // If we ran out of steps -OR- we didn't hit anything,\n    // pretend we hit whatever was closest in the ray segment\n    // that we did trace.\n    material = min_material;\n#endif\n    return end;\n}\n\n// https://iquilezles.org/articles/normalsSDF\n#if 0\nvec3 estimateNormal( const int scene, const float epsilon, in vec3 p )\n{\n    int m;\n    vec2 h = vec2(epsilon, 0);\n    return normalize( vec3(sceneSDF(scene, p+h.xyy, m) - sceneSDF(scene, p-h.xyy, m),\n                           sceneSDF(scene, p+h.yxy, m) - sceneSDF(scene, p-h.yxy, m),\n                           sceneSDF(scene, p+h.yyx, m) - sceneSDF(scene, p-h.yyx, m) ) );\n}\n#else\nvec3 estimateNormal( const int scene, const float h, in vec3 p )\n{\n    int m;\n    \n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sceneSDF( scene, p + k.xyy*h, m ) + \n                      k.yyx*sceneSDF( scene, p + k.yyx*h, m ) + \n                      k.yxy*sceneSDF( scene, p + k.yxy*h, m ) + \n                      k.xxx*sceneSDF( scene, p + k.xxx*h, m ) );\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord + .5 * iResolution.xy) / iResolution.y;\n    \n    mat4 mvp = mat4(1.);\n\n    float t = rotation_speed * iTime;\n    mvp *= rotate(radians(-60.) + radians(5.) * t, vec3(0, 1, 0));\n    mvp *= rotate(radians(-5.) + radians(10.) * sin(radians(180.) + radians(10.) * t), vec3(1, 0, 0));\n    \n#if 1\n\tvec3 dir = normalize((mvp * vec4(rayDirection(80.0, iResolution.xy, fragCoord), 1.)).xyz);\n    vec3 eye = (mvp * vec4(0., 1., 15., 1.)).xyz;\n#else\n    vec3 dir = rayDirection(80.0, iResolution.xy, fragCoord);\n\tvec3 eye = vec3(0., 1.5, 15.);\n#endif\n\n    vec3 sphere_pos = vec3(0., .5, 0.);\n\n    vec3 color;\n    float depth = 1e10;\n    \n    float near, far;\n\n    int material;\n    float exterior_dist = castRay(SCENE_EXTERIOR, eye, dir, 1., 100., .02, 200, material);\n    if (intersect_ray_sphere(eye, dir, sphere_pos, 4., near, far) == 1 && near < exterior_dist) {\n        depth = near;\n        \n\t    vec3 hit_pos = eye + dir * near;\n\t\tvec3 normal = normalize(hit_pos - sphere_pos);\n        \n        // Refraction\n        float ratio = 1.5;\n        \n        vec3 eye = hit_pos + dir * .001;\n\t\tvec3 dir = refract(dir, normal, 1. / ratio);\n        \n        intersect_ray_sphere(eye, dir, sphere_pos, 4., near, far);\n        \n        // Snow inside globe\n        float dist = castRay(SCENE_INTERIOR, eye, dir, 0., 10., .0001, 200, material);\n        if (dist <= 0.) {\n            // We hit the snow that hugs the sphere\n            //color = mix(snow_color_shadow, snow_color_light, max(snow_min_light, dot(light_dir, normal)));\n            vec3 hit_pos = eye + dir * dist;\n            normal = normalize(hit_pos - sphere_pos);\n\n            color = globeInteriorMat(hit_pos, normal, material);\n        } else if (dist < 100. - .001 && dist < far) {\n            // We hit snow inside the sphere\n            vec3 hit_pos = eye + dir * dist;\n\t\t\tvec3 normal = estimateNormal(0, 0.001, hit_pos);\n\n            color = globeInteriorMat(hit_pos, normal, material);\n        } else {\n            // We hit the other side of the sphere\n\t\t\thit_pos = eye + dir * far;\n        \tnormal = normalize(hit_pos - sphere_pos);\n\n        \teye = hit_pos;\n        \tdir = refract(dir, -normal, ratio);\n            \n            // exterior ground + globe stand\n            // TODO: merge with below\n\n            float exterior_dist = castRay(SCENE_EXTERIOR, eye, dir, 1., 100., .1, 120, material);\n            vec3 hit_pos = eye + dir * exterior_dist;\n            vec3 normal = estimateNormal(1, .1, hit_pos);\n            if (exterior_dist < 100. - .001) {\n                depth += exterior_dist;\n                color = globeInteriorMat(hit_pos, normal, material);\n            } else {\n                color = background(dir);\n            }\n        }\n    } else {\n        // exterior ground + globe stand\n        // TODO: merge with above\n\t\t\n        vec3 hit_pos = eye + dir * exterior_dist;\n        vec3 normal = estimateNormal(1, .1, hit_pos);\n        \n        // fudge the normal?\n        //normal = normalize(vec3(normal.x, .19 * normal.y, normal.z));\n\n        if (exterior_dist < 100. - .001) {\n            depth = exterior_dist;\n            color = globeInteriorMat(hit_pos, normal, material);\n        } else {\n            color = background(dir);\n        }\n    }\n\n    if (use_2d_snow) {\n\t\tfloat snow_d = min(sdSnow(80. * uv + vec2(0., 12.*iTime)),\n\t                       sdSnow(110. * uv + vec2(0., 10.*iTime) - vec2(100., 300.)));\n\t    color += vec3(1, 1, 1) * smoothstep(0., -.2, snow_d);\n    }\n\n    if (use_exterior_3d_snow) {\n    \tint material;\n\t    float dist = castRay(SCENE_SNOWFLAKES, eye, dir, 1., 100., .001, 50, material);\n        if (dist < depth) {\n            // Not antialiasing per se, but it does attenuate aliasing\n            // problems for very distant snowflakes\n\t\t\tcolor += vec3(1, 1, 1) * smoothstep(100., 0., dist);\n            \n            if (dist < 100. - .001)\n            \tdepth = dist;\n        }\n    }\n    \n\tfragColor = vec4(color, smoothstep(0., 100., depth));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Blur\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float A = 1.;\n\tconst int N = 2;\n\n    vec4 col = vec4(0);\n    for (int yoff = -N; yoff <= N; ++yoff) {\n        for (int xoff = -N; xoff <= N; ++xoff) {\n            vec2 off = vec2(xoff, yoff);\n            vec2 uv = (fragCoord + A * off) / iResolution.xy;\n            col += texture(iChannel0, uv) / (.5 + 1. * length(off / vec2(N, N)));\n        }\n    }\n\n    fragColor = vec4(col.rgb / 30., 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float gamma = 2.2;\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nvec3 sdBoxNormal (vec3 p, vec3 b)\n{\n    // XXX: did I flip all the signs?\n    if (abs(p.x) > abs(p.y)) {\n        if (abs(p.x) > abs(p.z)) {\n            return vec3(sign(p.x), 0, 0);\n        } else {\n            return vec3(0, 0, sign(p.z));\n        }\n    } else {\n        if (abs(p.y) > abs(p.z)) {\n            return vec3(0, sign(p.y), 0);\n        } else {\n            return vec3(0, 0, sign(p.z));\n        }\n    }\n}\n\nfloat sdInfiniteXBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d.yz, 0.0))\n         + min(max(d.y, d.z), 0.0);\n}\n\nfloat sphereSDF(vec3 samplePoint) {\n    return length(samplePoint) - 1.0;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdHorizontalCapsule( vec3 p, float h, float r )\n{\n    p.x -= clamp( p.x, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat sdZCapsule( vec3 p, float h, float r )\n{\n    p.z -= clamp( p.z, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat sdCappedXCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.yz), p.x)) - h;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCappedYCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCappedZCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xy), p.z)) - h;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nconst float sleeper_period = 8.;\nconst vec3 sleeper_size = vec3(2., .5, 8.);\nconst float rail_height = .5;\n\nconst float driving_wheel_radius = 7.;\n\nvec3 zabs(vec3 p)\n{\n    p.z = abs(p.z);\n    return p;\n}\n\nfloat sdTracks(vec3 p)\n{\n    float sleepers =\n        sdBox(vec3(mod(p.x, sleeper_period), p.y + 2.5, p.z) - vec3(.5 * sleeper_period, 0, 0), sleeper_size);\n\n    float rails = \n        sdInfiniteXBox(zabs(p) - vec3(0., -1.5, 6.), vec3(3., rail_height, 1.));\n\n    return min(sleepers, rails);\n}\n\nfloat sdLocomotive(vec3 p, float iTime)\n{\n    vec3 p2 = zabs(p);\n\n    float y = -2. + rail_height + sleeper_size.y + floor(driving_wheel_radius);\n\n    float frame = sdBox(p - vec3(-8., 16., 0), vec3(34., 1., 12.));\n    float frame_front = sdBox(p - vec3(27., 14., 0), vec3(1., 3., 12.));\n    float frame_back = sdBox(p - vec3(-42., 14., 0), vec3(1., 3., 12.));\n    frame = min(frame, min(frame_front, frame_back));\n\n    float buffers_front = min(sdCappedXCylinder(p2 - vec3(29., 14., 7.), vec2(1., 1.)),\n        sdCappedXCylinder(p2 - vec3(30.5, 14., 7.), vec2(2. - .3, .25)) - .3);\n    float buffers_back = min(sdCappedXCylinder(p2 - vec3(-44., 14., 7.), vec2(1., 1.)),\n        sdCappedXCylinder(p2 - vec3(-45.5, 14., 7.), vec2(2. - .3, .25)) - .3);\n    float buffers = min(buffers_front, buffers_back);\n\n    float wheelbox = sdBox(p - vec3(-8., 11., 0), vec3(29., 5., 4.5));\n    float boiler = sdCappedXCylinder(p - vec3(0., 25., 0), vec2(8., 24.));\n    float smoke_box_door = sdCappedXCylinder(p - vec3(23., 25., 0), vec2(7. - 1., 1.)) - 1.;\n    float pipe = sdCappedYCylinder(p - vec3(20., 30., 0), vec2(1., 11.)) - 1.;\n    float bell = sdCappedYCylinder(p - vec3(2., 30., 0), vec2(4. - 3., 4.)) - 3.;\n    float house_exterior = sdBox(p - vec3(-30., 28., 0), vec3(8., 13., 10.));\n    float house_interior = sdBox(p - vec3(-31., 28., 0), vec3(8., 12., 9.));\n    float front_window = sdBox(p - vec3(-26., 35., 0), vec3(8. - 2., 3. - 2., 8. - 2.)) - 2.;\n    float side_window = sdBox(p - vec3(-30., 34., 0), vec3(6., 5., 12.));\n    float windows = min(front_window, side_window);\n    float house = max(house_exterior, -min(house_interior, windows));\n    float roof = sdBox(p - vec3(-30., 40.5, 0), vec3(12., .5, 10.));\n    float body = min(min(min(min(frame, buffers), wheelbox),\n        min(min(min(boiler, smoke_box_door), pipe), bell)), min(house, roof));\n\n    // TODO: we can do better than max(sdCappedZCylinder..., -sdCappedZCylinder)\n    // with a new primitive that does most of the calculations only once\n    float wheel0 = max(sdCappedZCylinder(p2 - vec3( 10., y, 6.0), vec2(driving_wheel_radius,         .5)),\n                      -sdCappedZCylinder(p2 - vec3( 10., y, 6.2), vec2(driving_wheel_radius - 2.05, 1.0)));\n    float wheel1 = max(sdCappedZCylinder(p2 - vec3(-10., y, 6.0), vec2(driving_wheel_radius,         .5)),\n                      -sdCappedZCylinder(p2 - vec3(-10., y, 6.2), vec2(driving_wheel_radius - 2.05, 1.0)));\n    float wheel2 = max(sdCappedZCylinder(p2 - vec3(-30., y, 6.0), vec2(driving_wheel_radius,         .5)),\n                      -sdCappedZCylinder(p2 - vec3(-30., y, 6.2), vec2(driving_wheel_radius - 2.05, 1.0)));\n    float wheels = min(wheel0, min(wheel1, wheel2)) - .1;\n\n    //float a = -675. * iTime * (radians(180.) / 180.);\n    float a = -2. * radians(360.) * iTime;\n    vec3 rod_pos = vec3(-30, y, 8.) - 4. * vec3(cos(a), sin(a), 0.);\n    vec3 cylinder_pos = vec3(18., y, 10.);\n    float rod = sdHorizontalCapsule(p2 - rod_pos, 40., 1.);\n    float cylinder = sdCappedXCylinder(p2 - cylinder_pos, vec2(2., 5.)) - 1.;\n    float piston_rod = sdCapsule(p2, rod_pos + vec3(20., 0., 2.), cylinder_pos + vec3(-2. - 4. * cos(a + radians(30.)), 0., 0.), 1.);\n\n    wheels = min(wheels, min(rod, min(cylinder, piston_rod)));\n\n    return min(body, wheels);\n}","name":"Common","description":"","type":"common"}]}