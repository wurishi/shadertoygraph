{"ver":"0.1","info":{"id":"mtKyRK","date":"1700623621","viewed":35,"name":"Raymarching but better","username":"RayWorld","description":"I'm using structs, are you happy now?","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITERATIONS 200\n#define MIN_DIST 0.01\n#define PI 3.141592\n\n#define shadows\n\n#define rot2(a) mat2(cos(a),-sin(a),sin(a),cos(a)) // V.xy *= rot2(a.z)\n\n\n// axis-angle to matrix\n// from: https://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToMatrix/index.htm\nmat3x3 SO3ToM3x3 (vec3 v) {\n    float angle = mod(length(v) + PI, 2.0 * PI) - PI;\n    if (angle == 0.0) {\n        return mat3x3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n    }\n    vec3 dir = v/angle;\n    float c = cos(angle);\n    float s = sin(angle);\n    float t = 1.0 - c;\n    \n    mat3x3 I = mat3x3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n    mat3x3 S = mat3x3(dir.x * dir.x, dir.x * dir.y, dir.x * dir.z, dir.x * dir.y, dir.y * dir.y, dir.y * dir.z, dir.x * dir.z,dir.y * dir.z, dir.z * dir.z);\n    mat3x3 A = mat3x3(0.0, -dir.z, dir.y, dir.z, 0.0, -dir.x, -dir.y, dir.x, 0.0);\n    \n    return c * I + t * S + s * A;\n}\n\nstruct ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct material {\n    vec3 color;\n    vec3 shadowColor;\n    bool isSky;\n};\n\nstruct plane {\n    vec3 normal;\n    float offset;\n    int materialID;\n};\n\nfloat planeSDF(vec3 pos, plane p) {\n    return dot(pos + p.normal * p.offset, p.normal);\n}\n\nstruct sphere {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nfloat sphereSDF(vec3 pos, sphere s) {\n    return length(pos - s.center) - s.radius;\n}\n\nstruct box {\n    vec3 center;\n    vec3 size;\n    mat3 orientation; // only use the output of SO3ToM3x3\n    int materialID;\n};\n\nfloat boxSDF(vec3 pos, box b) {\n    vec3 offset = abs((pos - b.center) * b.orientation) - b.size;\n    float unsignedDist = length(max(offset,0.));\n    float signedDist = max(max(min(offset.x, 0.),min(offset.y, 0.)),min(offset.z, 0.));\n    return signedDist + unsignedDist;\n}\n\n\nstruct distanceInfo {\n    float dist;\n    int materialID;\n};\n\nmaterial[] materials = material[](\n    material(vec3(0.0), vec3(0.0), true),\n    material(vec3(0.5,0.9,0.5), vec3(0.2,0.5,0.2), false),\n    material(vec3(0.0,0.0,1.0), vec3(1.0,0.0,0.0), false)\n);\n\n#define hasPlane\n#define hasSphere\n#define hasBox\n\ndistanceInfo getDistance(vec3 pos) {\n    float minDist = 10000000.0;\n    int closestMatID = 0;\n    #ifdef hasSphere\n    // number of spheres\n    int NOSpheres = 2;\n    sphere[] spheres = sphere[2](\n        sphere(vec3(0.0,0.0,0.0), -30.0, 0),\n        sphere(vec3(10.0,5.0,0.0),3.0, 2)\n    );\n    for (int i = 0; i < NOSpheres; i++) {\n       float currentDist = sphereSDF(pos, spheres[i]);\n       if (minDist > currentDist) {\n           minDist = currentDist;\n           closestMatID = spheres[i].materialID;\n       }\n    }\n    #endif\n    #ifdef hasPlane\n    // number of planes\n    int NOPlanes = 1;\n    plane[] planes = plane[1](\n        plane(vec3(0.0,1.0,0.0), 0.0, 1)\n    );\n    for (int i = 0; i < NOPlanes; i++) {\n       float currentDist = planeSDF(pos, planes[i]);\n       if (minDist > currentDist) {\n           minDist = currentDist;\n           closestMatID = planes[i].materialID;\n       }\n    }\n    #endif\n    #ifdef hasBox\n    int NOBoxes = 1;\n    box[] boxes = box[1](\n    box(vec3(-5.0,2.0,0.0),vec3(1.0),SO3ToM3x3(iTime / 7.0 * normalize(vec3(1.0,2.0,0.0))), 2)\n    );    \n    for (int i = 0; i < NOBoxes; i++) {\n       float currentDist = boxSDF(pos, boxes[i]);\n       if (minDist > currentDist) {\n           minDist = currentDist;\n           closestMatID = boxes[i].materialID;\n       }\n    }\n    #endif\n    return distanceInfo(minDist, closestMatID);\n}\n\nvec3 getNormal(vec3 p) {\n\tfloat d = getDistance(p).dist;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        getDistance(p-e.xyy).dist,\n        getDistance(p-e.yxy).dist,\n        getDistance(p-e.yyx).dist);\n    \n    return normalize(n);\n}\n\nvec3 march(ray r) {\n    float dist = 0.0;\n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n        float sDist = getDistance(r.origin + dist * r.direction).dist;\n        if (sDist <= MIN_DIST) {\n            break;\n        }\n        dist += sDist;\n    }\n    return r.origin + dist * r.direction;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 col = vec3(uv,0.0);\n    vec3 sunDir = normalize(vec3(cos(PI * iTime / 10.0), 0.5, sin(PI * iTime / 10.0)));\n    vec3 cameraPosition = vec3(0.0, 5.0, 0.0);\n    vec2 rotations = vec2(PI / 2.0, 0.1);\n    float theta = rotations.x;\n    float phi = rotations.y;\n    vec3 dir = normalize(vec3(uv, 2.0));\n    dir.zy *= rot2(phi);\n    dir.zx *= rot2(theta);\n    vec3 end = march(ray(cameraPosition, dir));\n    int m = getDistance(end).materialID;\n    if (materials[m].isSky) {\n        if (dir.y < 0.0) {\n            col = vec3(0.0, 1.0, 0.0);\n        } else if (dot(dir, sunDir) > 0.99) {\n            col = vec3(1.0, 1.0, 0.0);\n        } else {\n            col = vec3(0.3, 0.3, 1.0);            \n        }\n    } else {\n       #ifdef shadows\n       vec3 norm = getNormal(end);\n       vec3 towardsSun = march(ray(end + norm * 0.05,sunDir));\n\n       int mTowardsSun = getDistance(towardsSun).materialID;\n       if (materials[mTowardsSun].isSky) {\n          col = mix(materials[m].shadowColor, materials[m].color, clamp(dot(norm,sunDir),0.0,1.0));\n       } else {\n           col = materials[m].shadowColor;\n       }\n       #endif\n       #ifndef shadows\n       col = materials[m].color;\n       #endif\n    }\n    // Output to screen\n    fragColor = vec4(col,0.0);\n}","name":"Image","description":"","type":"image"}]}