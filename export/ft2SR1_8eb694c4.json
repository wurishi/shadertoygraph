{"ver":"0.1","info":{"id":"ft2SR1","date":"1627083987","viewed":158,"name":"3D printed puzzle ball","username":"Observer","description":"3D puzzle I made using Blender and 3D-printed using my Ender 3 Pro","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["csg","puzzle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Camera\nCamera getCamera() {\n    Camera camera;\n    \n    bool down = dot(iMouse.xy, iMouse.zw) > 0.01;\n    float ta = iTime * 0.2;\n    \n    float dst = 35.0;\n    vec2 mo = iMouse.xy / iResolution.xy;\n    camera.from = down \n        ? vec3(\n            cos(mo.x * PI2) * sin(mo.y * PI * 0.2),\n        \tsin(mo.x * PI2) * sin(mo.y * PI * 0.2),\n        \tcos(mo.y * PI * 0.3)) * dst\n       \t: vec3(sin(ta), cos(ta), 0.44) * dst;\n    camera.up = vec3(0.0, 0.0, 1.0);\n    camera.at = vec3(0.0, 0.0, down ? mo.y * PZ * 0.5 : 0.0);\n    camera.aper =  20. * 3.141 / 180.0; // 1.0 / dst;\n    camera.look = camera.at - camera.from;\n    float dmin = length(camera.look);\n    float hsize = camera.aper * dmin, vsize = hsize;\n    if (hsize * iResolution.x / iResolution.y > vsize)\n        hsize = vsize * iResolution.x / iResolution.y;\n    else\n        vsize = hsize * iResolution.y / iResolution.x;\n    camera.hor = normalize(cross(camera.look, camera.up)) * hsize;\n    camera.ver = normalize(cross(camera.hor, camera.look)) * vsize;\n\n    return camera;\n}\n\nRay getCameraRay( in Camera camera, in vec2 uv ) {\n    Ray ray;\n    ray.ro = camera.from;\n    ray.rd = normalize(camera.look + uv.x * camera.hor + uv.y * camera.ver);\n    return ray;\n}\n\n\n// CSG operations\n\n// 'union' is a reserved word\nvec2 combine( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 intersect( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x>d2.x) ? d1 : d2;\n}\n\nvec2 subtract( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x>-d2.x) ? d1 : vec2(-d2.x, d2.y);\n}\n\nvec2 castRay( in Ray ray, vec2 glim, out vec3 rpos )\n{\n    float t = glim.x;\n    float ix = -1.;\n\n    int i=0;\n    rpos = vec3(0);\n    for( ; i<80; i++ )\n    {\n\t    float precis = 0.001*t;\n\t    vec2 res = map(ray.ro + ray.rd*t, rpos);\n\t    ix = res.y;\n        if( res.x<precis || t>glim.y ) break;\n        t += res.x;\n    }\n\n    if( t>glim.y ) ix = -1.;\n    return vec2( t, ix );\n}\n\n\nvec3 calcNormal( in int index, in vec3 pos, in float t )\n{\n    vec2 e = vec2(1.0,-1.0)*0.05;\n    vec3 rpos;\n    return normalize( e.xyy*mapPart(index, pos + e.xyy, rpos) + \n\t\t\t\t\t  e.yyx*mapPart(index, pos + e.yyx, rpos) + \n\t\t\t\t\t  e.yxy*mapPart(index, pos + e.yxy, rpos) + \n\t\t\t\t\t  e.xxx*mapPart(index, pos + e.xxx, rpos) );\n}\n\nvec3 render( in Ray ray, out vec3 pos)\n{ \n    float time = min(mod(iTime / speed, 32.0), 29.999);\n \n    vec2 glim = animate(ray, time);\n\n    vec3 col = vec3(0.0);\n    float alpha = 0.0;\n    \n    vec3 rpos;\n    vec2 res = castRay(ray, glim, rpos);\n    float t = res.x;\n\n    int index = int(res.y);\n    if( index >= 0 )\n    {\n        pos = ray.ro + t*ray.rd;\n        bool refl = pos.z < PZ;\n        vec3 nor = calcNormal(index, pos, t);\n        \n        float i = mod(res.y / 13.5, 1.);\n\n#ifdef LAYERS        \n        vec3 p2 = rpos * itrot[index] + p0[index] - PZ;\n        nor.z += abs(sin(p2.z * 15.0) * 2.0);\n        nor = normalize(nor);\n        i = p2.z / 5.0;\n#endif        \n        \n#ifdef COLORFUL        \n        col = vec3(\n            clamp(abs(i * 6.0 - 3.0) - 1.0, 0.0, 1.0),\n            clamp(2.0f - abs(i * 6.0f - 2.0f), 0.0, 1.0),\n            clamp(2.0f - abs(i * 6.0f - 4.0f), 0.0, 1.0)\n        );\n#else        \n\t\tcol = vec3(1.0, 0.4, 0.1);\n#endif        \n\n        alpha = 1.0;\n\n        // lighting        \n\t\tvec3 lig = normalize( vec3(0.5, 1.5, refl ? -1.0 : 1.0) );\n        vec3 mir = reflect( ray.rd, nor );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float spec = pow(clamp( dot( mir, lig ), 0.0, 1.0 ), 30.);\n\n        float lin = (dif + 0.5) * (0.4 + 0.6 * min(1.0, abs(pos.z - PZ) * 0.2));\n\t\tcol = col*lin + spec;\n        \n        if (refl)\n        {\n            col = mix(col, vec3(.4), 0.7);\n        }        \n    }\n    else\n    {\n        col = vec3(0.4);\n    }\n\n\treturn clamp(col, 0.0, 1.0);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), 0.0, cos(cr));\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    frame = iFrame;\n\n    Camera camera = getCamera();\n    vec2 uv = fragCoord.xy * 2.0 / iResolution.xy - 1.0;\n    \n    Ray ray = getCameraRay(camera, uv);\n    vec3 pos;\n    vec3 color = render(ray, pos);\n    \n\n    fragColor = vec4(color , 0.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// 3D puzzle I made using Blender and 3D-printed using my Ender 3 Pro\n//\n// Although the parts have a complex shape, they are the result of a simple set\n// of CSG operations (union, intersect and difference). The puzzle is inspired by the\n// wooden 'Pillar 5' puzzle, but most of the bars are extended so they fill up all space when\n// combined, forming a solid cube of 20x20x20. \n// The cube is then intersected by sphere to yield the final form.\n// The puzzle I printed was intersected by a sphere of radius 6.65 (arbitrarily chosen).\n// Try different values for RADIUS (14.0 for a die, 18.0 for cube)\n\n// Turn on LAYERS to display the 3D-printing layers (finer texture in reality)\n//#define LAYERS\n\n// Turn on for a more colorful color scheme\n//#define COLORFUL\n\nconst float A90 = acos(0.);\nconst float A45 = A90 * 0.5;\nconst float A135 = A90 * 1.5;\nconst float A180 = A90 * 2.0;\nconst float A225 = A90 * 2.5;\nconst float PI = A90 * 4.0;\nconst float PI2 = A90 * 8.0;\n\nconst float C45 = cos(A45);         // Cos(45°) = Sin(45°)\nconst float W = sqrt(2.);           // Half width of a bar\nconst float W2 = W * 2.0;           // Full width of a bar\nconst vec3 SIZE = vec3(W, W, 10.);  // Half size of a bar\n\nconst float RADIUS = 6.65;          // Radius of the sphere\nconst float DV = 0.1;\nconst float SRADIUS = RADIUS * RADIUS;\n\nconst float PZ = -RADIUS * 2.0;     // Z-coordinate of the plate on which the parts are laying\n\nconst float FAR = 300.0;\n\n\n// Helpers for mirror and 90° rotation\nconst vec3 Q = vec3(-1, 0, 1);\n\n#define MIRX(a) (a * Q.xzz)\n#define MIRY(a) (a * Q.zxz)\n#define MIRZ(a) (a * Q.zzx)\n#define MIRXY(a) (a * Q.xxz)\n\n#define ROTX90(a) (a).xzy * Q.zxz\n#define ROTY90(a) (a).zyx * Q.xzz\n#define ROTZ90(a) (a).yxz * Q.xzz\n#define ROTXY90(a) (a).zxy * Q.xxz\n// Note: ROTXY90 = ROTX90( ROTY90(a) )\n\nstruct Ray{\n    vec3 ro;\n    vec3 rd;\n};\n\nstruct Camera{\n    vec3 from;\n    vec3 at;\n    vec3 up;\n    float aper;\n\n    vec3 look;\n    vec3 hor;\n    vec3 ver;\n};\n\n// Starting position of the part when laying on the plate\n// (ending position will be (0, 0, 0))\nconst vec3[15] p0 = vec3[15] (\nvec3(0.0, 14.0, PZ-W), \nvec3(6.5, -16.5, PZ+2.0), \nvec3(-7.0, 11.0, PZ), \nvec3(-7.0, 10.0, PZ), \nvec3(7.0, 11.0, PZ), \nvec3(7.0, 10.0, PZ), \nvec3(-6.5, 0.0, PZ-W2), \nvec3(6.5, 0.0, PZ-W2), \nvec3(-6.5, -11.5, PZ+W), \nvec3(6.5, -4.0, PZ-W), \nvec3(-6.5, -4.0, PZ-W), \nvec3(6.5, -14.0, PZ), \nvec3(0.0, 8.5, PZ), \nvec3(-7.0, -15.5, PZ-W),\nvec3(-7.5, -16.5, PZ)\n);\n\n// Intermediate position before shifting into place\n// (ending position will be (0, 0, 0))\nconst vec4[15] p1 = vec4[15] (\nvec4(0.0, 0.0, 0.0, 0.0), \nvec4(0.0, 0.0, 8.0, 0.0), \nvec4(8.0, -8.0, 0.0, 0.0), \nvec4(-8.0, -8.0, 0.0, 0.0), \nvec4(8.0, 8.0, 0.0, 0.0), \nvec4(-8.0, 8.0, 0.0, 0.0), \nvec4(0.0, 6.0, 12.0, 0.0), \nvec4(0.0, -6.0, 12.0, 0.0), \nvec4(0.0, 20.0, 0.0, 0.0), \nvec4(0.0, 2.0, 2.0, 1.0), \nvec4(0.0, -2.0, 2.0, -1.0), \nvec4(0.0, -8.0, 8.0, 0.0),\nvec4(0.0, 8.0, 8.0, 0.0), \nvec4(0.0, 20.0, 0.0, 0.0),\nvec4(20.0, 0.0, 0.0, 0.0) \n);\n\n// Starting orientation of the part when laying down\n// (ending orientation will be (0, 0, 0))\nconst vec3[15] rot = vec3[15] (\nvec3(A180, -A45, -A90), \nvec3(A90, 0.0, 0.0), \nvec3(-A90, 0.0, A90), \nvec3(-A90, 0.0, A90), \nvec3(A90, 0.0, A90), \nvec3(-A90, A180, -A90), \nvec3(A135, 0.0, 0.0), \nvec3(-A135, 0.0, A180), \nvec3(0.0, A45, A90), \nvec3(0.0, -A45, -A90), \nvec3(0.0, A45, A90), \nvec3(A225, 0.0, A180),\nvec3(A135, 0.0, 0.0), \nvec3(0.0, A45, -A90),\nvec3(A45, 0.0, A180)\n);\n\nconst float speed = 1.5;\n\nint frame;\nvec3[15] ipos;    // animated position per part\nmat3[15] irot;    // animated orientation per part\n\n#ifdef LAYERS\nmat3[15] itrot;   // inverse matrix of starting orientation\n#endif\n\n// Distance functions ---------------------------------------------------------\n\nfloat sdBox(in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// Box rotated 45° over the Z-axis\nfloat sdBar45(in vec3 p, in vec3 b )\n{\n    vec3 d = abs(vec3((p.x - p.y) * C45, (p.x + p.y) * C45, p.z)) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat applyDents(in vec3 p, in float dentX, in float dentY )\n{\n    float g = 2.0 - step(abs(p.z), dentX * 2.) * mod(p.z + 14.0, 4.);\n    float f = -(p.x + abs(g)) * C45;\n    float h = 2.0 - step(abs(p.z), dentY * 2.) * mod(p.z + 12.0, 4.);\n    f = max(f, -(p.y + abs(h)) * C45 );\n    return f;\n}\n\n// Box rotated 45° over the Z-axis with 'dents'\n// dentX: nr. dents in X-dir (0, 1 or 3)\n// dentY: nr. dents in Y-dir (0 or 2)\nfloat sdDentedBar45(in vec3 p, in float dentX, in float dentY )\n{\n    vec3 d = abs(vec3((p.x - p.y) * C45, (p.x + p.y) * C45, p.z)) - SIZE;\n    float f = min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n    \n    f = max(f, applyDents(p, dentX, dentY));\n    return f;\n}\n\n// Distance functions of the puzzle parts ----------------------------------------\n\nfloat mapPart0(in vec3 pos)\n{\n    vec3 p1 =  vec3(-pos.z - 4.0, -pos.x, pos.y);\n   \n    float res1 = sdBox( pos - vec3(0.0, 0.0, -7.0), vec3(2.0, 10.0, 3.0) );\n    res1 = max( res1, -sdBar45( vec3(abs(pos.x), abs(pos.y), pos.z) - vec3(2., 2., -1.), SIZE ) );\n\n    float res = sdDentedBar45( p1, 3., 0. );\n    return min( res, res1 );\n}\n\nfloat mapPart1(in vec3 pos)\n{\n    float res = sdBox( vec3(abs(pos.x), pos.y, pos.z) - vec3(7.0, 0.0, -6.0), vec3(3.0, 2.0, 4.0) );\n    res = min( res, sdBar45 ( ROTY90(pos) - vec3(2.0, 0.0, 0.), SIZE ) );\n    res = min( res, sdBar45 ( vec3(abs(pos.x), pos.y, pos.z) - vec3(4., 0.0, -6.), vec3(W, W, 4.) ) );\n    \n    vec3 pbar = ROTY90( pos - vec3(0.0, 0.0, -2.0));\n    return max( res, applyDents (pbar, 3., 0.));\n}\n\nfloat mapPart5(in vec3 pos)\n{\n    float res1 = sdBox( pos - vec3(-5.0, 5.0, 6.0), vec3(5.0, 5.0, 4.0) );\n    res1 = max(res1, pos.y * C45 - pos.z * C45);    \n    vec3 pbar = vec3(-pos.x - 2.0, pos.y - 2.0, pos.z);\n    float res = sdBar45( pbar, SIZE );\n    res = min( res, res1 );\n    return max(res, applyDents (pbar, 3., 2.));\n}\n\nfloat mapPart2(in vec3 pos)\n{\n    return mapPart5(MIRXY(pos));\n}\n\nfloat mapPart3(in vec3 pos)\n{\n    return mapPart5(MIRY(pos));\n}\n\nfloat mapPart4(in vec3 pos)\n{\n    return mapPart5(MIRX(pos));\n}\n\nfloat mapPart6(in vec3 pos)\n{\n    float res = sdBox( pos - vec3(0, 6, -5), vec3(10, 4, 5) );\n    res = max( res, -sdBox( pos - vec3(0.0, 6.0, -7.1), vec3(2.0, 4.2, 3.1) ) );\n    res = max( res, -sdBar45 ( ROTX90(pos) - vec3(0.0, 4.0, 6.), SIZE ) );\n    res = min( res, sdBar45 ( ROTY90(pos) - vec3(2.0, 4.0, 0.), SIZE ) );\n    res = max( res, -(pos.y - pos.z) * C45 + 2.8 ); \n    \n    vec3 pbar = ROTY90( pos - vec3(0.0, 4.0, -2.0));\n    return max( res, applyDents (pbar, 3., 2.));\n}\n\nfloat mapPart7(in vec3 pos)\n{\n    return mapPart6(MIRY(pos));\n}\n\nfloat mapPart8(in vec3 pos)\n{\n    return sdDentedBar45 ( ROTXY90( pos ), 3., 0. );\n}\n\nfloat mapPart9(in vec3 pos)\n{\n    float res = sdBar45 ( ROTX90(pos) - vec3(4, 0, 0), SIZE );\n    vec3 rpos = ROTY90(pos);\n    res = min( res, sdBar45 ( vec3(rpos.x, abs(rpos.y), rpos.z) - vec3(0.0, 2.0, 7.0), vec3(W, W, 3.) ) );\n    vec3 pbar = ROTY90( ROTZ90(pos) - vec3(0.0, 4.0, 0.0));\n    return max( res, applyDents (pbar, 3., 2.));\n}\n\nfloat mapPart10(in vec3 pos)\n{\n    return mapPart9(MIRX(pos));\n}\n\nfloat mapPart12(in vec3 pos)\n{\n    float res = sdBox ( pos - vec3(0., 6., 5.), vec3(10., 4., 5.) );\n    res = max(res, -pos.y * C45 + pos.z * C45);\n    res = max(res, -pos.y * C45 - pos.z * C45 + 2.8);\n    vec3 pbar = ROTY90(pos * Q.zzx - vec3(0, -10, -2));\n    res = max( res, applyDents (pbar, 3., 0.));\n    res = min( res, sdBar45( ROTY90(pos - vec3( 0, 4, 2)), SIZE ));\n    res = max( res, -sdBar45( ROTX90(pos - vec3( 0, 1, 4)), SIZE ));\n    return max( res, -sdBar45( vec3(abs(pos.x), pos.y, pos.z) - vec3( 2, 2, 0), SIZE ));\n}\n\nfloat mapPart11(in vec3 pos)\n{\n    return mapPart12( MIRY(pos));\n}\n\nfloat mapPart13(in vec3 pos)\n{\n    float res = sdBar45 ( ROTX90(pos - vec3(0, 0, 4)) , SIZE );\n    return max( res, -sdBar45 ( ROTY90(pos - vec3(0, 0, 2)) , SIZE ));\n}\n\nfloat mapPart14(in vec3 pos)\n{\n    return sdBar45 ( ROTY90(pos - vec3(0, 0, 2)) , SIZE );\n}\n\nfloat mapPlate(in vec3 pos)\n{\n    return sdBox( pos - vec3(0., 0., PZ - 1.), vec3(25., 25., 2.0) );\n}\n\nvec2 animate(in Ray ray, float time)\n{\n    float rds = dot(ray.rd, ray.rd);\n    float ros = dot(ray.ro, ray.ro);\n    vec2 glim = vec2(FAR, 0.0);\n\n    int index2 = (int(time) / 2) % 15;  // 0..14, 0..14 (2 times)\n    float f1 = mod(time, 1.0);   // 0..1, 0..1, ... (30 times)\n    float ease = smoothstep(0.0, 1.0, f1);\n    \n    vec3 spreading = vec3(vec2(max(1.0, RADIUS / 6.65)), 1.0);\n\n    for (int index = min(frame, 0); index < 15; index++)\n    {\n        vec3 p0 = p0[index] * spreading;\n        vec4 pp = p1[index];\n        vec3 p1 = pp.xyz;\n        vec3 rot = rot[index];\n\n        vec3 p = vec3(0);\n        vec3 r = vec3(0);\n\n        if (index2 == index)\n        {\n            if (pp.w == 0.0)\n            {\n                switch (int(time) % 2)\n                {\n                    case 0:\n                        p = mix(p0, p1, ease);\n                        r = vec3(rot * (1.0 - f1));\n                        break;\n                    case 1:\n                        p = mix(p1, vec3(0), ease);\n                        break;\n                }\n            }\n            else  // An extra animation step\n            {\n                vec3 p2 = p1;\n                p1 = p1 + vec3(8.0, 0.0, 0.0) * pp.w;\n                time *= 1.5;\n                f1 = mod(time, 1.0);\n                ease = smoothstep(0.0, 1.0, f1);\n                switch (int(time) % 3)\n                {\n                    case 0:\n                        p = mix(p0, p1, ease);\n                        r = vec3(rot * (1.0 - f1));\n                        break;\n                    case 1:\n                        p = mix(p1, p2, ease);\n                        break;\n                    case 2:\n                        p = mix(p2, vec3(0), ease);\n                        break;\n                }\n            }\n        }\n        else if (index2 < index)\n        {\n            r = rot;\n            p = p0;\n        }\n        ipos[index] = p;\n        \n        // Calculate rotation matrix\n        float sa = sin(r.z), ca = cos(r.z);\n        float sb = sin(r.y), cb = cos(r.y);\n        float sc = sin(r.x), cc = cos(r.x);\n        irot[index]= mat3(\n            ca*cb, sa*cb, -sb, \n            ca*sb*sc - sa*cc, sa*sb*sc+ca*cc, cb*sc,\n            ca*sb*cc + sa*sc, sa*sb*cc-ca*sc, cb*cc);\n            \n#ifdef LAYERS            \n        // Calculate inverse rotation matrix\n        sa = sin(rot.z), ca = cos(rot.z);\n        sb = sin(rot.y), cb = cos(rot.y);\n        sc = sin(rot.x), cc = cos(rot.x);\n        itrot[index]= inverse(mat3(\n            ca*cb, sa*cb, -sb, \n            ca*sb*sc - sa*cc, sa*sb*sc+ca*cc, cb*sc,\n            ca*sb*cc + sa*sc, sa*sb*cc-ca*sc, cb*cc)); \n#endif            \n        \n        \n        // Calculate sphere limits\n        float a = rds;\n        for (int j = 0; j < 2; j++)\n        {\n            vec3 p1 = j == 0 ? p : vec3(p.x, p.y, 2. * PZ - p.z);\n            float b = 2.0 * dot(ray.rd, ray.ro - p1);\n            float c = dot(p1, p1) + ros - 2.0 * dot(p1, ray.ro) - SRADIUS;        \n            float disc = b * b - 4.0 * a * c;\n            if (disc >= 0.0) \n            {\n                disc = sqrt(disc);\n                glim.x = min(glim.x, (-b - disc) / 2. / a);\n                glim.y = max(glim.y, (-b + disc) / 2. / a);\n            }\n        }\n        \n    }\n    return glim;\n}\n\nfloat mapPart(in int index, in vec3 pos, out vec3 tpos)\n{\n    tpos = (vec3(pos.x, pos.y, abs(pos.z - PZ) + PZ) - ipos[index]) * irot[index];\n    float dist = length(tpos) - RADIUS;\n    if (dist <= DV)\n    {\n        float d2;\n        switch(index)\n        {\n            case 0:  d2 = mapPart0  (tpos); break;\n            case 1:  d2 = mapPart1  (tpos); break;\n            case 2:  d2 = mapPart2  (tpos); break;\n            case 3:  d2 = mapPart3  (tpos); break;\n            case 4:  d2 = mapPart4  (tpos); break;\n            case 5:  d2 = mapPart5  (tpos); break;\n            case 6:  d2 = mapPart6  (tpos); break;\n            case 7:  d2 = mapPart7  (tpos); break;\n            case 8:  d2 = mapPart8  (tpos); break;\n            case 9:  d2 = mapPart9  (tpos); break;\n            case 10: d2 = mapPart10 (tpos); break;\n            case 11: d2 = mapPart11 (tpos); break;\n            case 12: d2 = mapPart12 (tpos); break;\n            case 13: d2 = mapPart13 (tpos); break;\n            case 14: d2 = mapPart14 (tpos); break;\n        }\n        dist = max( dist, d2 );\n    }\n    return dist;\n}\n\nvec2 map(in vec3 pos, out vec3 upos)\n{\n    upos = vec3(0);\n    int ix = -1;\n    float res = FAR;\n    for (int index = min(frame, 0); index < 15; index++)\n    {\n        vec3 tpos;\n        float dist = mapPart(index, pos, tpos);\n\n        if (dist < res) \n        { \n            upos = tpos; \n            ix = index; \n            res = dist;\n        }\n    }\n    return vec2( res, float(ix) );\n}\n\n","name":"Common","description":"","type":"common"}]}