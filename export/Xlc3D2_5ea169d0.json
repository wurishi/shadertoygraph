{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"musicstream","id":"Xsj3z1","filepath":"https://soundcloud.com/zongo-1/09-hitori-bocchi-1b?in=zongo-1/sets/serial-experiments-lain-bootleg","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"\nfloat rnd(vec2 p)\n{\n    float f = fract(sin(dot(p, vec2(12.1234, 72.8392) )*45123.2));\n return f;   \n}\n\nfloat rnd(float w)\n{\n    float f = fract(sin(w)*1000.);\n return f;   \n}\n\nfloat regShape(vec2 p, int N)\n{\n float f;\n    \n    \nfloat a=atan(p.x,p.y)+.2;\nfloat b=6.28319/float(N);\nf=smoothstep(.5,.51, cos(floor(.5+a/b)*b-a)*length(p.xy));\n    \n    \n    return f;\n}\nvec3 circle(vec2 p, float size, float decay, vec3 color,vec3 color2, float dist, vec2 mouse)\n{\n \t \n    \n    //l is used for making rings.I get the length and pass it through a sinwave\n    //but I also use a pow function. pow function + sin function , from 0 and up, = a pulse, at least\n    //if you return the max of that and 0.0.\n    \n    float l = length(p + mouse*(dist*4.))+size/2.;\n    \n    //l2 is used in the rings as well...somehow...\n    float l2 = length(p + mouse*(dist*4.))+size/3.;\n    \n    ///these are circles, big, rings, and  tiny respectively\n    float c = max(00.01-pow(length(p + mouse*dist), size*1.4), 0.0)*50.;\n    float c1 = max(0.001-pow(l-0.3, 1./40.)+sin(l*30.), 0.0)*3.;\n    float c2 =  max(0.04/pow(length(p-mouse*dist/2. + 0.09)*1., 1.), 0.0)/20.;\n    float s = max(00.01-pow(regShape(p*5. + mouse*dist*5. + 0.9, 6) , 1.), 0.0)*5.;\n    \n   \tcolor = 0.5+0.5*sin(color);\n    color = cos(vec3(0.44, .24, .2)*8. + dist*4.)*0.5+.5;\n \tvec3 f = c*color ;\n    f += c1*color;\n    \n    f += c2*color;  \n    f +=  s*color;\n    return f-0.01;\n}\n\nfloat sun(vec2 p, vec2 mouse)\n{\n float f;\n    \n    vec2 sunp = p+mouse;\n    float sun = 1.0-length(sunp)*8.;\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy-0.5;\n    //uv=uv*2.-1.0;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec2 mm = iMouse.xy/iResolution.xy - 0.5;\n    mm.x *= iResolution.x/iResolution.y;\n    \n    if(iMouse.z<1.0)\n    {\n     mm = vec2(sin(iTime/6.)/1., cos(iTime/8.)/2. )/2.;   \n        \n    }\n    vec3 circColor = vec3(0.9, 0.2, 0.1);\n    vec3 circColor2 = vec3(0.3, 0.1, 0.9);\n    \n    //now to make the sky not black\n    vec3 color = mix(vec3(0.3, 0.2, 0.02)/0.9, vec3(0.2, 0.5, 0.8), uv.y)*3.-0.52*sin(iTime);\n    \n    //this calls the function which adds three circle types every time through the loop based on parameters I\n    //got by trying things out. rnd i*2000. and rnd i*20 are just to help randomize things more\n    for(float i=0.;i<10.;i++){\n        color += circle(uv, pow(rnd(i*2000.)*1.8, 2.)+1.41, 0.0, circColor+i , circColor2+i, rnd(i*20.)*3.+0.2-.5, mm);\n    }\n    //get angle and length of the sun (uv - mouse)\n        float a = atan(uv.y-mm.y, uv.x-mm.x);\n    \tfloat l = max(1.0-length(uv-mm)-0.84, 0.0);\n    \n    float bright = 0.1;//+0.1/abs(sin(iTime/3.))/3.;//add brightness based on how the sun moves so that it is brightest\n    //when it is lined up with the center\n    \n    //add the sun with the frill things\n    color += max(0.1/pow(length(uv-mm)*5., 5.), 0.0)*abs(sin(a*5.+cos(a*9.)))/20.;\n    color += max(0.1/pow(length(uv-mm)*10., 1./20.), .0)+abs(sin(a*3.+cos(a*9.)))/8.*(abs(sin(a*9.)))/1.;\n    //add another sun in the middle (to make it brighter)  with the20color I want, and bright as the numerator.\n    color += (max(bright/pow(length(uv-mm)*4., 1./2.), 0.0)*4.)*vec3(0.2, 0.21, 0.3)*4.;\n       // * (0.5+.5*sin(vec3(0.4, 0.2, 0.1) + vec3(a*2., 00., a*3.)+1.3));\n    \t\n    //multiply by the exponetial e^x ? of 1.0-length which kind of masks the brightness more so that\n    //there is a sharper roll of of the light decay from the sun. \n        color*= exp(1.0-length(uv-mm))/5.;\n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":true},"info":{"id":"Xlc3D2","date":"1471571936","viewed":5577,"name":"Circle & Polygon Lens Flare ","username":"Yusef28","description":"Inspired by Mu6ks and Nimitz's awesome lens flares and pics online I tried and came out with this. Feedback welcome.\nInteresting is the function for making polygons which can make any regular polygon. I left a link in a comment above that function.","likes":117,"published":1,"flags":64,"usePreview":0,"tags":["sun","lens","lighting","light","flare","lensflare"],"hasliked":0,"parentid":"","parentname":""}}