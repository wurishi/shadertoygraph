{"ver":"0.1","info":{"id":"cs3Gz2","date":"1677535148","viewed":168,"name":"Cloth IBL shading","username":"uTaras","description":"The image based lighting for cloth shading. Based on this article.\nhttps://google.github.io/filament/Filament.md.html#materialsystem/clothmodel\nAlso, some expirements with textures on artstation:\nhttps://www.artstation.com/artwork/obOznm\n","likes":3,"published":1,"flags":32,"usePreview":1,"tags":["ibl","pbr","cloth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = float(3.14159);\nconst float GOLDEN_R = float(1.61803);\n\nconst vec3 BASECOLOR  = vec3( 0.25, 0.25, 0.25);\nconst vec3 SHINECOLOR = vec3( 0.55, 0.55, 0.55);\nconst vec3 LIGHTCOLOR = vec3( 1.00, 1.00, 1.00);\nconst vec3 SSSCOLOR   = vec3( 1.00, 1.00, 1.00);\nconst vec3 LIGHTDIR   = vec3(-0.50, 1.00, 0.05);\n#define SSS\n\nstruct AppState\n{\n    float\tmenuId;\n    float   roughness;\n    float   focus;\n    vec2    focusObjRot;\n    vec2    objRot;\n};\n\nvec4 LoadValue(int x, int y)\n{\n    return texelFetch(iChannel0, ivec2(x, y), 0);\n}\n\nvoid LoadState(out AppState s)\n{\n    vec4 data;\n\n    data = LoadValue(0, 0);\n    s.menuId    = data.x;\n    s.roughness = data.y;\n    s.focus     = data.z;\n    \n    data = LoadValue(1, 0);\n    s.focusObjRot  \t= data.xy;  \n   \n    s.objRot    \t= data.zw;\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvec3 saturate(vec3 x)\n{\n    return clamp(x, vec3(0.), vec3(1.));\n}\n\nfloat Smooth(float x)\n{\n\treturn smoothstep(0., 1., saturate(x));   \n}\n\nfloat Circle(vec2 p, float r)\n{\n    return (length(p / r) - 1.) * r;\n}\n\nvoid Rotate(inout vec2 p, float a) \n{\n    p = cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\n\nfloat Capsule(vec2 p, float r, float c) \n{\n\treturn mix(length(p.x) - r, length(vec2(p.x, abs(p.y) - c)) - r, step(c, abs(p.y)));\n}\n\nfloat TextSDF(vec2 p, float glyph)\n{\n    p = abs(p.x - .5) > .5 || abs(p.y - .5) > .5 ? vec2(0.) : p;\n    return 2. * (texture(iChannel3, p / 16. + fract(vec2(glyph, 15. - floor(glyph / 16.)) / 16.)).w - 127. / 255.);\n}\n\nvec3 FresnelTerm(vec3 specularColor, float vdoth)\n{\n\tvec3 fresnel = specularColor + (1. - specularColor) * pow((1. - vdoth), 5.);\n\treturn fresnel;\n}\n\nfloat RoundBox(vec3 p, vec3 b, float r)\n{\n\treturn length(max(abs(p) - b, 0.0)) - r;\n} \n\nfloat Sphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\n\nfloat UnionRound(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat Displace(float scale, float ampl, vec3 p)\n{\n    p *= ampl;\n\treturn scale * sin(p.x) * sin(p.y) * sin(p.z);\n}\n\nfloat Scene(vec3 p, mat3 localToWorld)\n{  \n    p = p * localToWorld;\n    \n    float ret = Sphere(p, 1.2);\n    //ret = RoundBox(p, vec3(1.0, 1.0, 0.3), 0.1);\n    ret += Displace(0.05, 7.0, p);\n    \n\treturn ret;\n}\n\nfloat CastRay(in vec3 ro, in vec3 rd, mat3 localToWorld)\n{\n    const float maxd = 5.0;\n    \n\tfloat h = 0.5;\n    float t = 0.0;\n   \n    for (int i = 0; i < 50; ++i)\n    {\n        if (h < 0.001 || t > maxd) \n        {\n            break;\n        }\n        \n\t    h = Scene(ro + rd * t, localToWorld);\n        t += h;\n    }\n\n    if (t > maxd)\n    {\n        t = -1.0;\n    }\n\t\n    return t;\n}\n\nvec3 SceneNormal(in vec3 pos, mat3 localToWorld)\n{\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\n\tvec3 nor = vec3(\n\t    Scene(pos + eps.xyy, localToWorld) - Scene(pos - eps.xyy, localToWorld),\n\t    Scene(pos + eps.yxy, localToWorld) - Scene(pos - eps.yxy, localToWorld),\n\t    Scene(pos + eps.yyx, localToWorld) - Scene(pos - eps.yyx, localToWorld));\n\treturn normalize(nor);\n}\n\n// Shading\n// Whole shading process i've desighned in this shader https://www.shadertoy.com/view/mdBSWK\n\n\n//Sperical harmonics https://www.shadertoy.com/view/MdfSDH\nvoid SH_AddLightDirectional( inout vec3 sh[9], in vec3 col, in vec3 v )\n{\n    //#define NO  1.0        // for perfect overal brigthness match\n    #define NO (16.0/17.0) // for normalizing to maximum = 1.0;\n    sh[0] += col * (NO*PI*1.000) * (0.50*sqrt( 1.0/PI));\n    sh[1] += col * (NO*PI*0.667) * (0.50*sqrt( 3.0/PI)) * v.x;\n    sh[2] += col * (NO*PI*0.667) * (0.50*sqrt( 3.0/PI)) * v.y;\n    sh[3] += col * (NO*PI*0.667) * (0.50*sqrt( 3.0/PI)) * v.z;\n    sh[4] += col * (NO*PI*0.250) * (0.50*sqrt(15.0/PI)) * v.x*v.z;\n    sh[5] += col * (NO*PI*0.250) * (0.50*sqrt(15.0/PI)) * v.z*v.y;\n    sh[6] += col * (NO*PI*0.250) * (0.50*sqrt(15.0/PI)) * v.y*v.x;\n    sh[7] += col * (NO*PI*0.250) * (0.25*sqrt( 5.0/PI)) * (3.0*v.z*v.z-1.0);\n    sh[8] += col * (NO*PI*0.250) * (0.25*sqrt(15.0/PI)) * (v.x*v.x-v.y*v.y);\n}\n\nvec3 SH_Evalulate( in vec3 v, in vec3 sh[9] )\n{\n    return sh[0] * (0.50*sqrt( 1.0/PI)) +\n           sh[1] * (0.50*sqrt( 3.0/PI)) * v.x +\n           sh[2] * (0.50*sqrt( 3.0/PI)) * v.y +\n           sh[3] * (0.50*sqrt( 3.0/PI)) * v.z +\n           sh[4] * (0.50*sqrt(15.0/PI)) * v.x*v.z +\n           sh[5] * (0.50*sqrt(15.0/PI)) * v.z*v.y +\n           sh[6] * (0.50*sqrt(15.0/PI)) * v.y*v.x +\n           sh[7] * (0.25*sqrt( 5.0/PI)) * (3.0*v.z*v.z-1.0) +\n           sh[8] * (0.25*sqrt(15.0/PI)) * (v.x*v.x-v.y*v.y);\n}\n\nvec3 DiffuseLighting(vec3 normal){\n    vec3 sh[9];sh[0]=vec3(0.);sh[1]=vec3(0.);sh[2]=vec3(0.);sh[3]=vec3(0.);sh[4]=vec3(0.);sh[5]=vec3(0.);sh[6]=vec3(0.);sh[7]=vec3(0.);sh[8]=vec3(0.);\n    //vec3 lightDir = LIGHTDIR;\n    vec3 v;\n    vec3 col;\n    vec3 rld = normalize(vec3(1.,0.,0.)),\n         lld = normalize(vec3(-1.,0.,0.)),\n         lbd = normalize(vec3(0.,0.,-1.)),\n         ldd = normalize(vec3(0.,-1.,0.)),\n         ltd = normalize(vec3(0.,1.,0.));\n    //SH_AddLightDirectional(sh, ((SUNCOLOR)), normalize(lightDir));\n    SH_AddLightDirectional(sh, textureLod(iChannel1, rld,4.).rgb, rld);\n    SH_AddLightDirectional(sh, textureLod(iChannel1, lld,4.).rgb, lld);\n    SH_AddLightDirectional(sh, textureLod(iChannel1, lbd,4.).rgb, lbd);\n    SH_AddLightDirectional(sh, textureLod(iChannel1, ldd,4.).rgb, ldd);\n    SH_AddLightDirectional(sh, textureLod(iChannel1, ltd,4.).rgb, ltd);\n    return SH_Evalulate( normal, sh);\n}\n\n// PBR implementation https://learnopengl.com/PBR/Theory\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness){\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nfloat RadicalInverse_VdC(uint bits) {\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\nvec2 Hammersley(uint i, uint N){\n    return vec2(float(i)/float(N), RadicalInverse_VdC(i));\n}\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness){\n    float a = roughness*roughness;\n\t\n    float phi = 2.0 * PI * Xi.x;\n    float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\t\n    vec3 H = vec3(cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta);\n\t\n    vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n    vec3 tangent   = normalize(cross(up, N));\n    vec3 bitangent = cross(N, tangent);\n\t\n    vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n    return normalize(sampleVec);\n}\n\n// Cloth PBR \n// https://google.github.io/filament/Filament.md.html#materialsystem/clothmodel\nfloat AshikhminD(float roughness, float ndoth){\n\tfloat r2    = roughness * roughness;\n\tfloat cos2h = ndoth * ndoth;\n\tfloat sin2h = 1. - cos2h;\n\tfloat sin4h = sin2h * sin2h;\n\n\treturn (sin4h + 4. * exp(-cos2h / (sin2h * r2))) / max((PI * (1. + 4. * r2) * sin4h),0.1);\n}\n\nfloat AshikhminV(float ndotv, float ndotl){\n\treturn 1. / (4. * (ndotl + ndotv - ndotl * ndotv));\n}\n\n//LUT https://github.com/google/filament/blob/main/libs/ibl/src/CubemapIBL.cpp\nfloat DFV_Charlie(float NoV, float roughness) {\n    float r = 0.0;\n    vec3 V = vec3(sqrt(1. - NoV * NoV), 0., NoV);\n    vec3 N = vec3(0.0, 0.0, 1.0);\n    float VdotH = dot(V,N);\n    const uint numSamples = 12u;\n    for (uint i = 0u; i < numSamples; i++) {\n        vec2 Xi = Hammersley(i, numSamples);\n        vec3 H  = ImportanceSampleGGX(Xi, N, roughness);\n        vec3 L = 2. * dot(V, H) * H - V;\n        float VdotH = saturate(dot(V, H));\n        float NdotL = saturate(L.z);\n        float NdotH = saturate(H.z);\n        if (NdotL > 0.) {\n            float d = AshikhminD(roughness, NdotH);\n            float v = AshikhminV(VdotH, NdotL);\n            r += v * d * NdotL * VdotH; // VoH comes from the Jacobian, 1/(4*VoH)\n        }\n    }\n    // uniform sampling, the PDF is 1/2pi, 4 comes from the Jacobian\n    return r * (4.0f * 2.0f * PI / float(numSamples));\n}\n\n//Cloth Lighting\n\nvec3 ClothDiffuse(vec3 bc, vec3 sss, vec3 lc, vec3 n, float occ, float ndotl){\n    sss = min(sss + ndotl, 1.);\n    bc *= occ;\n    vec3 irradiance = DiffuseLighting(n);\n    vec3 diffuse = ndotl*lc+irradiance; \n    #ifdef SSS\n    bc *= clamp((ndotl+.5)/1.25,0.,1.);\n    diffuse *= bc*sss;\n    #else\n    diffuse *= bc;\n    #endif\n    \n    return diffuse;\n}\nvec3 ClothSpecular(vec3 diff, vec3 refl, vec3 f0, float rough, float vdotn, float hdotn, float ldotn){\n    float prough = pow(1.-rough,.5);\n    vec3 f = fresnelSchlickRoughness(vdotn,f0,rough);\n    float ch = DFV_Charlie(vdotn, prough);\n    float maxLod = log2(float(textureSize(iChannel0,0).x));\n    float lod = maxLod*prough*(2.-prough);\n    vec3 reflectionColor = textureLod(iChannel1, refl,lod).rgb;\n    vec3 specularIbl = reflectionColor * f0 * f * ch;\n    float d = saturate(AshikhminD(1.-rough,hdotn));\n    float v = saturate(AshikhminV(vdotn,ldotn));\n    vec3 specularL = d*v*ldotn*f0*PI;\n    return specularIbl+specularL;\n}\n//\n\nvoid DrawScene(inout vec3 color, vec2 p, in AppState s, vec2 fragCoord)\n{\n    vec3 lightPos \t   = vec3(-0.3, 0.5, 1.);\n    vec3 lightColor    = vec3(1.0);\n    vec3 lightDir      = normalize(LIGHTDIR);\n    \n\tvec3 baseColor     = pow(BASECOLOR,vec3(2.2))*1.5;\n    vec3 sssColor      = vec3(1.0);\n    vec3 f0            = pow(SHINECOLOR,vec3(2.2))*1.5;\n    float roughness    = saturate(s.roughness);\n    \n    p -= vec2(0., 10.);\n    p *= .011;\n    \n    float yaw = 2.7 - s.objRot.x;\n    mat3 rotZ = mat3(\n        vec3(cos(yaw), 0.0, -sin(yaw)),\n\t\tvec3(0.0, 1.0, 0.0),        \n        vec3(sin(yaw), 0.0, cos(yaw))\n       );\n    \n    float phi = -0.1 + s.objRot.y;\n    mat3 rotY = mat3(\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, cos(phi), sin(phi)),\n        vec3(0.0, -sin(phi), cos(phi))\n       );\n    \n    mat3 localToWorld = rotY * rotZ;  \n    \n    lightDir = localToWorld * lightDir;\n    \n\tvec3 rayOrigin \t= vec3(0.0, .3, -3.5);\n    vec3 rayDir \t= normalize(vec3(p.x, p.y, 2.0));    \n\tfloat t = CastRay(rayOrigin, rayDir, localToWorld);\n    if (t > 0.0)\n    {\n        vec3 pos = rayOrigin + t * rayDir;\n        vec3 normal = SceneNormal(pos, localToWorld);\n        vec3 viewDir = -rayDir;\n        vec3 refl = reflect(rayDir, normal);\n        \n        vec3 localNormal = normal*localToWorld;\n        vec3 localViewDir = -rayDir*localToWorld;\n\n        vec3 halfVec = normalize(viewDir + lightDir);\n        float vdoth = saturate(dot(viewDir, halfVec));\n        float ndoth\t= saturate(dot(normal, halfVec));\n        float ndotv = saturate(dot(normal, viewDir));\n        float ndotl = saturate(dot(normal, lightDir));\n        \n        vec3 diffuse = ClothDiffuse(baseColor, sssColor, lightColor, normal, 1., ndotl);\n        vec3 specular = ClothSpecular(diffuse, refl, f0, roughness, ndotv, ndoth, ndotl);\n        color = diffuse+specular;\n        \n        color = pow(color, vec3(1. / 2.2));\n    }\n    else\n    {\n        // shadow\n        float planeT = -(rayOrigin.y + 1.2) / rayDir.y;\n        if (planeT > 0.0)\n        {\n            vec3 p = rayOrigin + planeT * rayDir;\n            \n            float radius = .7;\n            color *= 0.7 + 0.3 * smoothstep(0.0, 1.0, saturate(length(p + vec3(0.0, 1.0, -0.5)) - radius));\n        }\t\t\n    }\n}\n\nvoid MenuText(inout vec3 color, vec2 p, in AppState s)\n{\n    p -= vec2(-160, 62);\n    \n    vec2 scale = vec2(4., 8.);\n    vec2 t = floor(p / scale);   \n    \n    uint v = 0u;\n\tv = t.y == 2. ? (t.x < 4. ? 1768452929u : (t.x < 8. ? 1768777835u : (t.x < 12. ? 5653614u : 0u))) : v;\n\tv = t.y == 1. ? (t.x < 4. ? 1918986307u : (t.x < 8. ? 1147496812u : (t.x < 12. ? 1752383839u : (t.x < 16. ? 1835559785u : 5664361u)))) : v;\n\tv = t.y == 0. ? (t.x < 4. ? 1918986307u : (t.x < 8. ? 1147496812u : (t.x < 12. ? 86u : 0u))) : v;\n\tv = t.x >= 0. && t.x < 20. ? v : 0u;\n    \n\tfloat c = float((v >> uint(8. * t.x)) & 255u);\n    \n    vec3 textColor = vec3(.3);\n    if (t.y == 2. - s.menuId)\n    {\n        textColor = vec3(0.74, 0.5, 0.12);\n\t}\n\n    p = (p - t * scale) / scale;\n    p.x = (p.x - .5) * .5 + .5;\n    float sdf = TextSDF(p, c);\n    if (c != 0.)\n    {\n    \tcolor = mix(textColor, color, smoothstep(-.05, +.05, sdf));\n    }\n}\n\nvoid SliderText(inout vec3 color, vec2 p, in AppState s)\n{\n    p -= vec2(67, 76);\n    \n    vec2 scale = vec2(4., 8.);\n    vec2 t = floor(p / scale);   \n    \n    uint v = 0u;\n\tv = t.y == 0. ? (t.x < 4. ? 1735749458u : (t.x < 8. ? 1936027240u : 14963u)) : v;\n\tv = t.x >= 0. && t.x < 12. ? v : 0u;\n    \n\tfloat c = float((v >> uint(8. * t.x)) & 255u);\n    \n    vec3 textColor = vec3(.3);\n\n    p = (p - t * scale) / scale;\n    p.x = (p.x - .5) * .5 + .5;\n    float sdf = TextSDF(p, c);\n    if (c != 0.)\n    {\n    \tcolor = mix(textColor, color, smoothstep(-.05, +.05, sdf));\n    } \n}\n\n\nvoid DrawSlider(inout vec3 color, vec2 p, in AppState s)\n{\n    p -= vec2(110, 94.5);\n    \n    p.y += 15.;\n    float c1 = Capsule(p.yx - vec2(0., 20.), 1., 20.);\n    c1 = min(c1, Circle(p - vec2(40. * s.roughness, 0.), 2.5));\n\n\tcolor = mix(color, vec3(0.3), Smooth(-c1 * 2.));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;    \n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1. + 2. * q;\n\tp.x *= iResolution.x / iResolution.y;    \n    p *= 100.;\n    \n    AppState s;\n    LoadState(s);  \n\n    vec3 color = vec3(0.19,0.2,0.2);\n    \n    DrawScene(color, p, s, fragCoord);\n    \n    SliderText(color, p, s);\n\n    DrawSlider(color, p, s);\n\n\tfragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// control loop\n\nconst float FOCUS_SLIDER = 1.;\nconst float FOCUS_OBJ    = 2.;\n\nstruct AppState\n{\n    float   menuId;\n    float   roughness;\n    float   focus;\n    vec2    focusObjRot;\n    vec2    objRot;\n};\n\nvec4 LoadValue(int x, int y)\n{\n    return texelFetch(iChannel0, ivec2(x, y), 0);\n}\n\nvoid LoadState(out AppState s)\n{\n    vec4 data;\n\n    data = LoadValue(0, 0);\n    s.menuId    = data.x;\n    s.roughness = data.y;\n    s.focus     = data.z;\n    \n    data = LoadValue(1, 0);\n    s.focusObjRot   = data.xy;\n    s.objRot        = data.zw;\n}\n\nvoid StoreValue(vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord)\n{\n    fragCoord = floor(fragCoord);\n    fragColor = (fragCoord.x == re.x && fragCoord.y == re.y) ? va : fragColor;\n}\n\nvec4 SaveState(in AppState s, in vec2 fragCoord)\n{\n    if (iFrame <= 0)\n    {\n        s.menuId      = 0.0;\n        s.roughness   = 0.5;\n        s.focus       = 0.0;\n        s.focusObjRot = vec2(0.0);\n        s.objRot      = vec2(0.0);\n    }\n    \n    vec4 ret = vec4(0.);\n    StoreValue(vec2(0., 0.), vec4(s.menuId, s.roughness, s.focus, 0.0), ret, fragCoord);\n    StoreValue(vec2(1., 0.), vec4(s.focusObjRot, s.objRot), ret, fragCoord);\n    return ret;\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (fragCoord.x >= 8. || fragCoord.y >= 8.) \n    {\n        discard;    \n    }\n\n    AppState s;\n    LoadState(s);\n    \n    vec4 q = iMouse / iResolution.xyxy;\n    vec4 m = -1. + 2. * q;\n    m.xz *= iResolution.x / iResolution.y;    \n    m *= 100.;    \n\n    vec4 sliderM = m - vec2(110, 94.5).xyxy;\n    if (sliderM.z >= -4. && sliderM.z < 44. && sliderM.w >= -20. && sliderM.w < -10.)\n    {\n        s.focus = FOCUS_SLIDER;\n    } \n    else if (m.w > -100. && m.w < 40. && abs(m.z + 20.) < 70.)\n    {\n        if (s.focus != FOCUS_OBJ)\n        {\n            s.focusObjRot = s.objRot; \n        }\n        s.focus = FOCUS_OBJ;\n    }\n    else\n    {\n        s.focus = 0.;\n        vec2 mp = (m.xy - vec2(-160, -1));\n        float menuId = mp.x < 40. || (mp.x < 60. && (mp.y > 18. && mp.y < 24.)) ? 10. - floor(mp.y / 8.) : -1.;\n        if (menuId >= 0. && menuId <= 2.)\n        {\n            s.menuId = menuId;\n        }\n    }\n\n    if (s.focus == FOCUS_SLIDER)\n    {\n        s.roughness = saturate(sliderM.x / 40.);    \n    } \n    if (s.focus == FOCUS_OBJ)\n    {\n        s.objRot = s.focusObjRot + .04 * (m.xy - m.zw);\n    }\n    \n    fragColor = SaveState(s, fragCoord);\n}","name":"Buffer A","description":"","type":"buffer"}]}