{"ver":"0.1","info":{"id":"cl2XDc","date":"1676711040","viewed":98,"name":"Ray Tracer - Ported","username":"MN8R","description":"this is my ray tracer i wrote in glsl\nuse wasd to move and mouse + drag to look","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["raytracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat getData(int memoryIndex) {\n    return texelFetch(iChannel0, ivec2(memoryIndex, 0), 0).r;\n}\n\nvec3 getPixelColor(vec2 pxl) {\n  vec3 sky = rgb(0, 0, 0); // 155, 219, 232\n\n  float aspect = iResolution.x / iResolution.y;\n  float x = (pxl.x - 0.5);\n  float y = (pxl.y - 0.5) / aspect;\n\n  float FOV = PI / 2.0;\n  vec3 cam = vec3(getData(0), getData(1), getData(2) + 3.0);\n  \n  // Look Direction\n  // vec2 mouse = iMouse.xy / iResolution.xy;\n  // float ha = TWO_PI * (mouse.x - 0.5);\n  // float va = PI * (mouse.y - 0.5);\n  float ha = getData(3);\n  float va = getData(4);\n\n  // Map x, y to yaw, pitch\n  Direction d = fishEye(ha, va, x, y, FOV);\n\n  // Calculate ray\n  float r = 0.0, g = 0.0, b = 0.0;\n  float absorb = 1.0, light = 1.0;\n  float raylength = 0.0;\n  Ray ray = Ray(cam, d);\n  for (int i=0; i<10; i++) {\n    RayTrace tc = traceRay(ray, i, raylength);\n    if (tc.B == 0.0) {\n      r = lerp(r, sky.x, light);\n      g = lerp(g, sky.y, light);\n      b = lerp(b, sky.z, light);\n      break;\n    }\n\n    // How much color is absorbed\n    absorb = (1.0 - tc.reflect);\n    float amt = absorb * light;\n    r = lerp(r, tc.r, amt);\n    g = lerp(g, tc.g, amt);\n    b = lerp(b, tc.b, amt);\n    \n    // Absorb remaining light\n    absorb = tc.reflect;\n    light *= tc.reflect;\n    if (light < 0.01) break;\n    raylength += length(tc.next.pos - ray.pos);\n    ray = tc.next;\n  }\n\n  // Pixel color\n  vec3 c = vec3(r, g, b);\n  return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Ray trace the pixel\n    vec3 col = getPixelColor(uv);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define PI 3.14159265358\n#define TWO_PI PI * 2.0\n#define HALF_PI PI * 0.5\n\n  ///////////////////////\n // SHADER FUNCTIONS ///\n///////////////////////\n\nint modulo(int num, int divisor) {\n    return (num - divisor * (num / divisor));\n}\n\nfloat fmod(float x, float y) {\n    return x - y * floor(x / y);\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat lerp(float a, float b, float v) {\n  return a * (1.0 - v) + b * v;\n}\n\nfloat dist(float a, float b, float c, float d) {\n  float e = c - a;\n  float f = d - b;\n  return sqrt(e * e + f * f);\n}\n\nbool xor(bool a, bool b) {\n  return (a && !b) || (!a && b);\n}\n\nvec3 rgb(int r, int g, int b) {\n  return vec3(\n    float(r) / 255.0,\n    float(g) / 255.0,\n    float(b) / 255.0\n  );\n}\n\nvec3 lerpCol(float r0, float g0, float b0, float r1, float g1, float b1, float v) {\n  return vec3(\n    lerp(r0, r1, v),\n    lerp(g0, g1, v),\n    lerp(b0, b1, v)\n  );\n}\n\nvec3 lerpCol(vec3 c0, vec3 c1, float v) {\n  return lerpCol(c0.x, c0.y, c0.z, c1.x, c1.y, c1.z, v);\n}\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return (dot(d, vec4(52.0)) + 1.0) / 2.0;\n}\n\nfloat noise2(float a, float b) {\n  return (noise(vec2(a, b)) + 1.0) / 2.0;\n}\n\nfloat noise(float a) {\n  return noise(vec2(a, 0.0));\n}\n\nvec3 rayTo(vec3 a, vec3 b) {\n  return normalize(b - a);\n}\n\nvec3 reflectionRays(vec3 a, vec3 b) {\n  return a - 2.0 * dot(a, b) * b;\n}\n\n\n\n\n  //////////////////\n // SHADER MATH ///\n//////////////////\n\nvec3 intersectingRayFloor(vec3 initialPosition, float verticalAngle, float horizontalAngle) {\n    verticalAngle += PI/2.0;\n    float t = initialPosition.z / cos(verticalAngle);\n    float d = initialPosition.z * tan(verticalAngle);\n    float x = cos(horizontalAngle) * d + initialPosition.x;\n    float y = sin(horizontalAngle) * d + initialPosition.y;\n    vec3 pt = vec3( x, y, t );\n    return pt;\n}\n\nvec2 getAngles(float x, float y, float n) {\n  // Calculate horizontal angle\n  float horizontalAngle = atan(x / n);\n\n  // Calculate vertical angle\n  float verticalAngle = atan(y / n);\n\n  // Pack the angles into a single float value\n  return vec2((horizontalAngle + 1.0) / 2.0, verticalAngle / PI);\n}\n\nfloat atan2(float a, float b) {\n    float angle = asin(a) > 0.0 ? acos(b) : -acos(b);\n    return angle;\n}\n\nfloat atan2approx(float y, float x)\n{\n    //http://pubs.opengroup.org/onlinepubs/009695399/functions/atan2.html\n    //Volkan SALMA\n\n    float ONEQTR_PI = PI / 4.0;\n\tfloat THRQTR_PI = 3.0 * PI / 4.0;\n\tfloat r, angle;\n\tfloat abs_y = abs(y) + 0.000000001;      // kludge to prevent 0/0 condition\n\tif ( x < 0.0 ) {\n\t\tr = (x + abs_y) / (abs_y - x);\n\t\tangle = THRQTR_PI;\n\t} else {\n\t\tr = (x - abs_y) / (x + abs_y);\n\t\tangle = ONEQTR_PI;\n\t}\n\tangle += (0.1963 * r * r - 0.9817) * r;\n\tif ( y < 0.0 )\n\t\treturn( -angle );     // negate if in quad III or IV\n\telse\n\t\treturn( angle );\n}\n\n// Variables:\n// camera pos\n// camera angle\n// near dist\n// x, y on plane\n// Process:\n// - create vector from camera to plane at x, y\n// - get angle of vector\n// - return the x, y, z position of vector\n//   and the angle\n\nvec3 rotateVector(vec3 v, float pitch, float yaw) {\n  mat3 rotX = mat3(\n    vec3(1.0, 0.0, 0.0),\n    vec3(0.0, cos(pitch), -sin(pitch)),\n    vec3(0.0, sin(pitch), cos(pitch))\n  );\n\n  mat3 rotY = mat3(\n    vec3(cos(yaw), 0.0, sin(yaw)),\n    vec3(0.0, 1.0, 0.0),\n    vec3(-sin(yaw), 0.0, cos(yaw))\n  );\n\n  return rotY * (rotX * v);\n}\n\nvec3 rotateVector2(vec3 vector, float radians, int axis) {\n    vec3 result;\n    if (axis == 0) {\n        result.x = vector.x;\n        result.y = vector.y * cos(radians) - vector.z * sin(radians);\n        result.z = vector.y * sin(radians) + vector.z * cos(radians);\n    } else if (axis == 1) {\n        result.x = vector.x * cos(radians) + vector.z * sin(radians);\n        result.y = vector.y;\n        result.z = -vector.x * sin(radians) + vector.z * cos(radians);\n    } else {\n        result = vector;\n    }\n    return result;\n}\n\nvec3 rotateVector3(vec3 vector, float pitchRadians, float yawRadians) {\n    vec3 result;\n    result.x = vector.x * cos(yawRadians) + vector.z * sin(yawRadians);\n    result.y = vector.y * cos(pitchRadians) - vector.z * sin(pitchRadians);\n    result.z = vector.x * sin(yawRadians) - vector.y * sin(pitchRadians) * cos(yawRadians) + vector.z * cos(pitchRadians) * cos(yawRadians);\n    return result;\n}\n\nvec3 anglesToVec3(float horizontalAngle, float verticalAngle) {\n  vec3 direction;\n  float cosVA = cos(verticalAngle);\n  direction.x = cosVA * cos(horizontalAngle);\n  direction.y = cosVA * sin(horizontalAngle);\n  direction.z = sin(verticalAngle);\n  return direction;\n}\n\nvec2 vec3ToAngles(vec3 vector) {\n  vec2 angles;\n  angles.x = atan2approx(vector.y, vector.x);\n  angles.y = asin(vector.z);\n  return angles;\n}\n\nfloat angleBetween(vec3 v1, vec3 v2) {\n  float dotProduct = dot(v1, v2);\n  return acos(dotProduct);\n}\n\nvec2 angleToSquareEdge(float angle) {\n  const float size = 1.0;\n\n  // Calculate the x and y coordinates of the point on the unit circle at the given angle\n  float x = cos(angle);\n  float y = sin(angle);\n\n  // Calculate the absolute values of x and y to simplify the calculations\n  float abs_x = abs(x);\n  float abs_y = abs(y);\n  float edge_distance;\n  \n  // Determine which edge of the square the point is closest to based on the angle\n  if (abs_x > abs_y) {\n    // Point is closest to left or right edge\n    edge_distance = size / (2.0 * abs_x);\n  } else {\n    // Point is closest to top or bottom edge\n    edge_distance = size / (2.0 * abs_y);\n  }\n\n  // Multiply the x and y coordinates by the edge distance to get the final x and y distances to the square edge\n  float x_distance = x * edge_distance;\n  float y_distance = y * edge_distance;\n\n  return vec2(x_distance, y_distance);\n}\n\nvec2 squareToCircle(float x, float y) {\n  // Calculate the angle (theta) of the point (x, y) relative to the center of the circle\n  float theta = atan(x / y);\n  vec2 d = angleToSquareEdge(theta);\n  float r = 0.5;\n  float x0 = cos(theta) * r;\n  float y0 = sin(theta) * r;\n  float x1 = x * d.x / x0;\n  float y1 = y * d.y / y0;\n  \n  return vec2(x1, y1);\n}\n\nstruct Direction {\n  vec3 ray;\n  float ha;\n  float va;\n};\n\nDirection fishEye(float ha, float va, float x, float y, float FOV) {\n\n  float HFOV = FOV;\n  float VFOV = FOV;\n\n  // Z Rotation Matrix\n  float sin0 = sin(-ha);\n  float cos0 = cos(-ha);\n  mat3 matrixRotateZ = mat3(\n    vec3(cos0, -sin0, 0.0),\n    vec3(sin0, cos0, 0.0),\n    vec3(0.0, 0.0, 1.0)\n  );\n  \n  // Y Rotation Matrix\n  sin0 = sin(va);\n  cos0 = cos(va);\n  mat3 matrixRotateY = mat3(\n    vec3(cos0, 0.0, sin0),\n    vec3(0.0, 1.0, 0.0),\n    vec3(-sin0, 0.0, cos0)\n  );\n\n  // Convert to vector\n  // vec2 dir = squareToCircle(x, y);\n  // vec2 dir = vec2(x, y);\n  // vec3 ray = anglesToVec3(dir.x * HFOV, dir.y * VFOV);\n  \n  const float near = 0.7;\n  vec3 ray = normalize(vec3(near, x * HFOV, y * VFOV));\n\n  // Rotate vectors\n  ray = matrixRotateY * ray;\n  ray = matrixRotateZ * ray;\n    \n  // Convert to angles\n  vec2 rot = vec3ToAngles(ray);\n\n  return Direction(ray, rot.x, rot.y);\n}\n\nDirection getDirection(vec3 ray) {\n  // Convert to angles\n  vec2 rot = vec3ToAngles(ray);\n  return Direction(ray, rot.x, rot.y);\n}\n\n\n\n\n  ////////////////////////\n // SHADER COLLISIONS ///\n////////////////////////\n\nstruct Result {\n  bool exist;\n  float a;\n  float b;\n};\n\n//float dot(float f, vec3 v) {\n//    return f * v.x + f * v.y + f * v.z;\n//}\n\nResult intersectRaySphere(vec3 rayOrigin, vec3 rayDirection, vec3 sphereCenter, float sphereRadius) {\n  // Calculate the vector from the ray origin to the sphere center\n  vec3 centerToRay = rayOrigin - sphereCenter;\n\n  // Calculate the coefficients of the quadratic equation\n  float a = dot(rayDirection, rayDirection);\n  float b = 2.0 * dot(centerToRay, rayDirection);\n  float c = dot(centerToRay, centerToRay) - sphereRadius * sphereRadius;\n\n  // Calculate the discriminant\n  float discriminant = b * b - 4.0 * a * c + 0.000000001;\n\n  if (discriminant < 0.0) {\n    // No intersection\n    return Result(false, 0.0, 0.0);\n  } else {\n    // Two intersections\n    float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n    if (t1 < 0.0) return Result(false, 0.0, 0.0);\n    return Result(true, t1, 0.0);\n  }\n}\n\n\nfloat calculateBrightness(vec3 intersectPoint, vec3 sphereCenter, vec3 pointLight) {\n  // Calculate the normal vector at the intersection point\n  vec3 normal = intersectPoint - sphereCenter;\n  \n  // Normalize the normal vector\n  float normalLength = length(normal);\n  vec3 normalizedNormal = normalize(normal);\n\n  // Calculate the vector from the intersection point to the point light\n  vec3 toLight = pointLight - intersectPoint;\n\n  // Calculate the cosine of the angle between the normal vector and the vector to the point light\n  float cosTheta = dot(normalizedNormal, normalize(toLight));\n\n  // Calculate the brightness using the cosine of the angle\n  float brightness = pow(max(cosTheta, 0.0), 1.5);\n\n  return brightness;\n}\n\n\n\n\n  ////////////////////\n // RAY COLLISION ///\n////////////////////\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n    float reflect;\n};\n\nstruct Light {\n    vec3 pos;\n    float r, g, b;\n    float strength;\n    float radius;\n};\n\nstruct Ray {\n    vec3 pos;\n    Direction dir;\n};\n\nstruct RayTrace {\n    float r, g, b;\n    float V, B;\n    float reflect;\n    Ray next;\n};\n\nstruct Collision {\n    Result result;\n    Sphere sphereHit;\n};\n\nconst int SPHERES = 7;\n\nstruct Spheres {\n    Sphere spheres[SPHERES];\n};\n\nCollision collideSphere(vec3 rayOrigin, vec3 rayDirection) {\n    // Spheres\n    float t = iDate.w * 60.0;\n    Result results[SPHERES];\n    Sphere spheres[SPHERES];\n    spheres[0] = Sphere(vec3(10.0, 0.0, 2.0), 2.0, 0.25);\n    spheres[1] = Sphere(vec3(10.0, 0.0, 5.0), 1.5, 0.5);\n    spheres[2] = Sphere(vec3(10.0, 0.0, 7.3), 1.0, 0.75);\n    spheres[3] = Sphere(vec3(8.0, 6.0, 3.0), 3.0, 1.0);\n    spheres[4] = Sphere(vec3(14.0, 4.0, 1.5), 1.5, 0.0);\n    spheres[5] = Sphere(vec3(40.0, 40.0, 50.0), 50.0, 0.8);\n    spheres[6] = Sphere(vec3(cos(t*0.01)*4.0+22.0, sin(t*0.01)*4.0-4.0, 2.0), 2.0, 1.0);\n\n    for (int i=0; i<SPHERES; i++) {\n        // Check for intersect with sphere\n        vec3 sphereCenter = spheres[i].center;\n        float sphereRadius = spheres[i].radius;\n        results[i] = intersectRaySphere(rayOrigin, rayDirection, sphereCenter, sphereRadius);\n    }\n\n    // Find closest result\n    float closestDist = 10000000.0;\n    Sphere sphereHit;\n    Result res = Result(false, 0.0, 0.0);\n    for (int i=0; i<SPHERES; i++) {\n        if (!results[i].exist) continue;\n        if (results[i].a < closestDist) {\n            closestDist = results[i].a;\n            sphereHit = spheres[i];\n            res = results[i];\n        }\n    }\n\n    return Collision(res, sphereHit);\n}\n\nCollision checkCollideSphere(vec3 rayOrigin, vec3 rayDirection, float len) {\n    // Spheres\n    float t = iDate.w * 16.0;\n    const int SPHERES = 7;\n    Sphere spheres[SPHERES];\n    spheres[0] = Sphere(vec3(10.0, 0.0, 2.0), 2.0, 0.25);\n    spheres[1] = Sphere(vec3(10.0, 0.0, 5.0), 1.5, 0.5);\n    spheres[2] = Sphere(vec3(10.0, 0.0, 7.3), 1.0, 0.75);\n    spheres[3] = Sphere(vec3(8.0, 6.0, 3.0), 3.0, 1.0);\n    spheres[4] = Sphere(vec3(14.0, 4.0, 1.5), 1.5, 0.0);\n    spheres[5] = Sphere(vec3(40.0, 40.0, 50.0), 50.0, 0.8);\n    spheres[6] = Sphere(vec3(cos(t*0.01)*4.0+22.0, sin(t*0.01)*4.0-4.0, 2.0), 2.0, 1.0);\n\n    float closestDist = 10000000.0;\n    float farthestDist = 0.0;\n    Result result = Result(false, 0.0, 0.0);\n    Sphere sphere;\n    for (int i=0; i<SPHERES; i++) {\n        // Check for intersect with sphere\n        Sphere s = spheres[i];\n        vec3 sphereCenter = s.center;\n        float sphereRadius = s.radius;\n        Result r = intersectRaySphere(rayOrigin, rayDirection, sphereCenter, sphereRadius);\n        if (r.exist && r.a < len) {\n            // Sphere has intersected with ray\n            return Collision(r, s);\n        }\n    }\n\n    return Collision(result, sphere);\n}\n\nCollision calculateLight(vec3 intersectPoint, vec3 surfaceNormal, vec3 lightPos) {\n    vec3 rayToLight = lightPos - intersectPoint;\n    vec3 lightNormal = normalize(rayToLight);\n    float d = length(rayToLight);\n    \n    // Shadows\n    return checkCollideSphere(intersectPoint, lightNormal, d);\n}\n\nfloat calculateShadowIntensity(vec3 intersectPoint, vec3 lightNormal, float distToLight, float lightRadius) {\n    // penumbra shadow mapping - contact hardening shadows\n    \n    // Spheres\n    float t = iDate.w * 60.0;\n    const int SPHERES = 7;\n    Sphere spheres[SPHERES];\n    spheres[0] = Sphere(vec3(10.0, 0.0, 2.0), 2.0, 0.25);\n    spheres[1] = Sphere(vec3(10.0, 0.0, 5.0), 1.5, 0.5);\n    spheres[2] = Sphere(vec3(10.0, 0.0, 7.3), 1.0, 0.75);\n    spheres[3] = Sphere(vec3(8.0, 6.0, 3.0), 3.0, 1.0);\n    spheres[4] = Sphere(vec3(14.0, 4.0, 1.5), 1.5, 0.0);\n    spheres[5] = Sphere(vec3(40.0, 40.0, 50.0), 50.0, 0.8);\n    spheres[6] = Sphere(vec3(cos(t*0.01)*4.0+22.0, sin(t*0.01)*4.0-4.0, 2.0), 2.0, 1.0);\n\n    // Check for intersect with spheres\n    float shadow = 0.0;\n    for (int i=0; i<SPHERES; i++) {\n        Sphere sphere = spheres[i];\n        Result result = intersectRaySphere(intersectPoint, lightNormal, sphere.center, sphere.radius);\n        // Sphere has intersected with ray\n        if (result.exist && result.a < distToLight) {\n            // Calculate shadow\n            // Calculate edge angle\n            vec3 rayToSphere = sphere.center - intersectPoint;\n            float distToSphere = length(rayToSphere);\n            float edgeAngle = distToSphere < sphere.radius ?\n                0.0 : asin(sphere.radius / distToSphere);\n\n            // Calculate angle between intersect to light pos and sphere pos\n            float angle = angleBetween(normalize(rayToSphere), lightNormal);\n\n            // The intensity is how close the angle is to the edge angle\n            float blend = min((result.a / distToLight) * 50.0 / lightRadius, 10.0);\n            float shade = 1.0 - pow(angle / edgeAngle, blend + 1.0); // * (result.a + 10.0) / (distToLight + 10.0);\n            shadow = max(shadow, shade);\n        }\n    }\n\n    return 1.0 - shadow; \n}\n\nfloat calculateRayLightIntensity(vec3 intersectPoint, vec3 surfaceNormal, Light light, float luminance) {\n    // Collision c = calculateLight(intersectPoint, surfaceNormal, light.pos);\n\n    // Calculate light ray\n    vec3 rayToLight = light.pos - intersectPoint;\n    vec3 lightNormal = normalize(rayToLight);\n    float distToLight = length(light.pos - intersectPoint);\n\n    // Shadow is determined by distance from edge and distance to light\n    float intensity = calculateShadowIntensity(intersectPoint, lightNormal, distToLight, light.radius);\n\n    // float bright = 1.0;\n    float bright = max(0.0, dot(lightNormal, surfaceNormal));\n    bright = bright * bright;\n\n    // Shiny spot in the middle\n    const float power = 10.0;\n    float brightSpot = pow(bright, power) * 0.8;\n    bright += brightSpot;\n\n    // Adjust brightness from distance and light strength\n    bright *= 1.0 / (pow(distToLight, 2.0) / (luminance * light.strength) + 1.0);\n    \n    // Return intensity\n    return bright * intensity;\n}\n\n\n\n\n  ////////////////////\n // RAYTRACE MATH ///\n////////////////////\n\nRayTrace traceRay(Ray d, int iter, float raylength) {\n  // Pixel Calculation\n  float r = 1.0, g = 1.0, b = 1.0;\n  float V = 1.0, B = 1.0;\n\n  vec3 r_origin = d.pos;\n  vec3 r_direction = d.dir.ray;\n  \n  float reflection = 0.0;\n  Ray nextRay;\n\n  // Sphere Collision\n  Collision collision = collideSphere(r_origin, r_direction);\n  Result res = collision.result;\n  Sphere sphereHit = collision.sphereHit;\n\n  // Point light\n  float t = iDate.w * 60.0;\n  const int LIGHTS = 5;\n  Light lights[LIGHTS];\n  const float sp = 0.002;\n  const float ns = 0.1;\n  const float luminance = 100.0;\n  const float dst = 50.0;\n  const float radius = 0.5;\n  lights[0] = Light(vec3(dst*noise(t*sp-10.0), dst*noise(t*sp-20.0), 30.0*noise(t*sp-30.0)+20.0), 1.0, 0.0, 0.0, 1.0, radius);\n  lights[1] = Light(vec3(dst*noise(t*sp+10.0), dst*noise(t*sp+20.0), 30.0*noise(t*sp+30.0)+20.0), 0.0, 1.0, 0.0, 1.0, radius);\n  lights[2] = Light(vec3(dst*noise(t*sp+40.0), dst*noise(t*sp+50.0), 30.0*noise(t*sp+60.0)+20.0), 0.0, 0.0, 1.0, 1.0, radius);\n  lights[3] = Light(vec3(-10.0, 0.0, 10.0), 1.0, 1.0, 1.0, 2.0, radius);\n  // lights[4] = Light(vec3(camera.x, camera.y, camera.z), 1.0, 1.0, 1.0, 1.0, 0.5);\n  // lights[4] = Light(vec3(-1000.0, -1000.0, 1000.0), 1.0, 1.0, 1.0, 100000.0, 0.1);\n\n  // If collision exists calculate sphere lighting\n  // otherwise calculate floor lighting\n  if (res.exist) {\n    float R1 = 1.0, G1 = 1.0, B1 = 1.0;\n    float R2 = 1.0, G2 = 1.0, B2 = 1.0;\n    B = 1.0 / pow(res.a, 0.2) + 0.1;\n    vec3 intersectPoint = r_origin + r_direction * res.a;\n    reflection = sphereHit.reflect;\n\n    // If partially reflective reflect light\n    if (reflection > 0.0 && iter < 10) {\n      vec3 intersectNormal = rayTo(sphereHit.center, intersectPoint);\n      vec3 reflectDir = reflectionRays(r_direction, intersectNormal);\n      nextRay = Ray(intersectPoint, getDirection(reflectDir));\n    }\n\n    // If partially non-reflective absorb light\n    if (reflection < 1.0) {\n\n      // Calculate light\n      vec3 surfaceNormal = normalize(intersectPoint - sphereHit.center);\n      R1 = 0.0; G1 = 0.0; B1 = 0.0;\n      for (int i=0; i<LIGHTS; i++) {\n        Light light = lights[i];\n        if (light.pos.z < 0.0) continue;\n        \n        float intensity = calculateRayLightIntensity(intersectPoint, surfaceNormal, light, luminance);\n\n        R1 += (intensity * light.r);\n        G1 += (intensity * light.g);\n        B1 += (intensity * light.b);\n      }\n\n      // Ambient light\n      V = 1.0 * 0.7 + 0.1;\n    }\n\n    // Calculate RGB\n    r *= R1 * R2;\n    g *= G1 * G2;\n    b *= B1 * B2;\n    \n  } else {\n\n    // Calculate floor / ceil intercept\n    // If issues know that va is being change in here\n    vec3 pt = intersectingRayFloor(d.pos, d.dir.va, d.dir.ha);\n    float tx = fmod(pt.x, 3.0);\n    float ty = fmod(pt.y, 3.0);\n\n    // Calculate texture\n    if (pt.z > 0.0) {\n      V = xor((tx > 1.5), (ty > 1.5)) ? 0.4 : 0.7;\n\n      // Calculate normals\n      vec3 intersectPoint = vec3(pt.x, pt.y, 0.0);\n      vec3 surfaceNormal = vec3(0.0, 0.0, 1.0);\n      vec3 reflectDir = reflectionRays(r_direction, surfaceNormal);\n\n      // Calculate light\n      r = 0.0; g = 0.0; b = 0.0;\n      for (int i=0; i<LIGHTS; i++) {\n        Light light = lights[i];\n        if (light.pos.z < 0.0) continue;\n        \n        float intensity = calculateRayLightIntensity(intersectPoint, surfaceNormal, light, luminance);\n\n        r += (intensity * light.r);\n        g += (intensity * light.g);\n        b += (intensity * light.b);\n      }\n\n      r *= V; g *= V; b *= V;\n\n      // Reflective floor\n      reflection = 0.1;\n      nextRay = Ray(intersectPoint, getDirection(reflectDir));\n    } else {\n      V = 1.0;\n      B = 0.0;\n    }\n  }\n\n  return RayTrace(r, g, b, V, B, reflection, nextRay);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_LEFT  = 65; // 37;\nconst int KEY_UP    = 87; // 38;\nconst int KEY_RIGHT = 68; // 39;\nconst int KEY_DOWN  = 83; // 40;\nconst int KEY_SPACE  = 32;\nconst int KEY_SHIFT  = 16;\n\nconst float speed = 20.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float newValue = 0.0;\n    float oldValue;\n    float velocity = iTimeDelta * speed;\n    \n    // Look Direction\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    float ha = TWO_PI * (mouse.x - 0.5);\n    float va = PI * (mouse.y - 0.5);\n    float totalHA = texelFetch(iChannel0, ivec2(3, 0), 0).r;\n    float totalVA = texelFetch(iChannel0, ivec2(4, 0), 0).r;\n    \n    // Keys being pressed\n    float keyRightPressed = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).r;\n    float keyLeftPressed = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).r;\n    float keyDownPressed = texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).r;\n    float keyUpPressed = texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).r;\n    \n    int memoryIndex = int(fragCoord.x);\n    switch(memoryIndex) {\n        case 0: // Memory space 1\n            oldValue = texelFetch(iChannel0, ivec2(0, 0), 0).r;\n            newValue = oldValue + cos(-totalHA) * velocity * (keyUpPressed - keyDownPressed)\n                                - sin(totalHA) * velocity * (keyRightPressed - keyLeftPressed);\n        \tbreak;\n        case 1: // Memory space 2\n        \toldValue = texelFetch(iChannel0, ivec2(1, 0), 0).r;\n            newValue = oldValue - sin(-totalHA) * velocity * (keyUpPressed - keyDownPressed)\n                                + cos(totalHA) * velocity * (keyRightPressed - keyLeftPressed);\n        \tbreak;\n        case 2: // Memory space 3\n            float keySpacePressed = texelFetch(iChannel1, ivec2(KEY_SPACE, 0), 0).r;\n            float keyShiftPressed = texelFetch(iChannel1, ivec2(KEY_SHIFT, 0), 0).r;\n            oldValue = texelFetch(iChannel0, ivec2(2, 0), 0).r;\n            newValue = oldValue + velocity * (keySpacePressed - keyShiftPressed);\n            break;\n        case 3:\n            newValue = totalHA;\n            float pHA = texelFetch(iChannel0, ivec2(5, 0), 0).r;\n            if (abs(ha - pHA) < 0.2) newValue += ha - pHA;\n            break;\n        case 4:\n            newValue = totalVA;\n            float pVA = texelFetch(iChannel0, ivec2(6, 0), 0).r;\n            if (abs(va - pVA) < 0.2) newValue = max(min(newValue + va - pVA, HALF_PI), -HALF_PI);\n            break;\n        case 5: newValue = ha; break;\n        case 6: newValue = va; break;\n    }\n    \n    fragColor = vec4(newValue, 0.0, 0.0, 1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"}]}