{"ver":"0.1","info":{"id":"WdjXDK","date":"1554967550","viewed":188,"name":"Deadmau5","username":"echofriendly","description":"Shader based off the Branch shader from the front page on 4/11","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["branch","deadmau5"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Based on dez by Branch https://www.shadertoy.com/view/XssXRH\n\nstruct polygon{\n\tvec2 A, B, C;\n};\nfloat roundBox(vec2 coord, vec2 pos, vec2 b ){\n  return length(max(abs(coord-pos)-b,0.0));\n}\nmat2 rotate(float Angle)  //rotation matrix i knicked from another branch shader\n{\n    mat2 rotation = mat2(\n        vec2( cos(Angle),  sin(Angle)),\n        vec2(-sin(Angle),  cos(Angle))\n    );\n\treturn rotation;\n}\nfloat box(vec2 coord, vec2 pos, vec2 size){\n\tif((coord.x<(pos.x+size.x)) &&\n\t   (coord.x>(pos.x-size.x)) &&\n\t   (coord.y<(pos.y+size.y)) && \n\t   (coord.y>(pos.y-size.y)) ) \n\t\treturn 1.0;\n\treturn 0.0;\n}\nfloat sun(vec2 coord, vec2 pos, float size){\n\tif(length(coord-pos)<size)\n\t\treturn 1.0;\n\treturn 0.0;\n}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat _sign(vec2 p1, vec2 p2, vec2 p3){\n  return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n}\nint PIT(vec2 pt, vec2 v1, vec2 v2, vec2 v3){\n\tint b1, b2, b3;\n\n\tif(_sign(pt, v1, v2) < 0.0) b1=1;\n\tif(_sign(pt, v2, v3) < 0.0) b2=1;\n\tif(_sign(pt, v3, v1) < 0.0) b3=1;\n\tif((b1 == b2) && (b2 == b3))\n\t\treturn 1;\n\treturn 0;\n}\n\nint PIT(vec2 pt, polygon X){\n\tint b1, b2, b3;\n\n\tif(_sign(pt, X.A, X.B) < 0.0) b1=1;\n\tif(_sign(pt, X.B, X.C) < 0.0) b2=1;\n\tif(_sign(pt, X.C, X.A) < 0.0) b3=1;\n\tif((b1 == b2) && (b2 == b3))\n\t\treturn 1;\n\treturn 0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat leftEyebrow=floor(mod(iTime*0.8,2.0))*0.1;\n\tfloat rightEyebrow=floor(mod(iTime*0.3,2.0))*0.1;\n\tfloat leftBlink=min(max(0.24*sin(iTime),0.006),0.1)-0.15;\n\tfloat rightBlink=min(max(0.24*sin(iTime),0.006),0.1)-0.15;\n\tfloat mouth=iTime*10.0;\n\tvec4 result;\n\tvec4 finalresult=vec4(1.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat aspectCorrection = (iResolution.x/iResolution.y);\n\tvec2 coordinate_entered = 3.0 * uv - 1.5;\n\tfor(float rgbare=0.0; rgbare<2.0; rgbare++){\n\tvec2 coord = vec2(aspectCorrection,1.0) *coordinate_entered;\n\tcoord.x*=1.0+rgbare*0.009;\n\tcoord*=1.0+rand(coord+iTime)/(pow(iTime,7.0)*3.0)-length(coord)*10.0/(pow(iTime*1.1,24.0));\n\tcoord*=1.0+0.1*sin(iTime*0.1);\n\tresult=vec4(vec3(200.0/255.0, 10.0/255.0, 65.0/255.0),1.0);\n\tif(mod(coord.x+coord.y,0.2)>0.1){\n\t\tif(sun(coord,vec2(0.0),0.7)==1.0)\n\t\t   result.xyz=vec3(1.0,262.0/512.0, 74.0/255.0);\n\t}\n\tif(mod(coord.x+coord.y+iTime*0.1,0.2)<0.1){\n\t\tfor(float j=-6.0; j<6.0; j++)\n\t\tfor(float i=-5.0; i<6.0; i++){\n\t\t\tvec2 posi=vec2(i/2.0,j/2.0);\n\t\t\tvec2 size=vec2(0.22);\n\t\t\tif(box(coord,posi,size)==1.0 && mod(i+j,2.0)==0.0)\n\t\t   \t\tresult.xyz-=vec3(0.4,0.5,0.3);\n\t\t}\n\t}\n\t\n\tfor(float i=0.0; i<3.141*2.0; i+=3.141*0.2){\n\t\tfloat timeSlice=iTime*0.8;\n\t\tvec2 A=vec2(0.0,0.0);\n\t\tvec2 B=vec2(cos(timeSlice+i), sin(timeSlice+i));\n\t\tvec2 C=vec2(cos(timeSlice+i-3.141*0.1), sin(timeSlice+i-3.141*0.1));\n\t\tif(mod(coord.x+coord.y,0.2)>0.1)\n\t\tif(PIT(coord, A, B, C)==1)\n\t\t\tresult.xyz=vec3(1.0,222.0/512.0, 64.0/255.0);\n\t}\n\tcoord*=rotate(floor(mod(iTime*.3,2.0))*.2-.1);  // rotate function call\n\tif(roundBox(coord, vec2(0.0,0.0), vec2(0.07, 0.07) )<0.5)  // FACE OUTLINE POSITION\n\t\tresult.xyz=vec3(0.0, 0.0, 0.0);  // FACE OUTLINE COLOR\n\t\t\n\tif(roundBox(coord, vec2(0.75,0.75), vec2(0.07, 0.07) )<0.5)  // Right Ear Outline\n\t\tresult.xyz=vec3(0.0, 0.0, 0.0);  // right EAR OUTLINE COLOR\n\t\t\n\tif(roundBox(coord, vec2(-0.75,0.75), vec2(0.07, 0.07) )<0.5)  // left Ear Outline\n\t\tresult.xyz=vec3(0.0, 0.0, 0.0);  // left EAR OUTLINE COLOR\n\t\n\tif(roundBox(coord, vec2(0.0,0.0), vec2(0.045, 0.045) )<0.5 ) // FACE POSITION\n\t //  roundBox(coord, vec2(0.0,-0.4),vec2(0.6,   0.2)   )>0.1) // Mouth Outline Position\n\t\tresult.xyz=vec3(1.0, 0.0, 0.0);   // FACE COLOR\n\t\n\tif(roundBox(coord, vec2(0.75,0.75), vec2(0.045, 0.045) )<0.5) // right ear POSITION\n\t\tresult.xyz=vec3(1.0, 0.0, 0.0);   // right ear COLOR\n\n\tif(roundBox(coord, vec2(-0.75,0.75), vec2(0.045, 0.045) )<0.5) // Left ear POSITION\n\t\tresult.xyz=vec3(1.0, 0.0, 0.0);   // Left ear COLOR\n\t\n\tif(mod(coord.x+coord.y,0.04)<0.02)                // Right Eye Cross Hatch\n\tif(roundBox(coord, vec2(0.25,0.1), vec2(0.05, rightBlink) )<0.2) // Right EYE POSITION\n\t\tresult.xyz=vec3(0.97, 0.97, 0.97);                 // RIGHT EYE COLOR\n\t\n\tif(mod(coord.x+coord.y,0.04)<0.02)            // Left Eye Cross Hatch\n\tif(roundBox(coord, vec2(-0.25,0.1), vec2(0.05, leftBlink) )<0.2)  // LEFT EYE POSITION\n\t\tresult.xyz=vec3(0.97, 0.97, 0.97);                 // LEFT EYE COLOR\n\t\n\tif(roundBox(coord, vec2(0.0,-0.3), vec2(0.07, 0.07) )<0.0) // Mouth Position 0.0 means off\n\t\tresult.xyz=vec3(0.97, 0.97, 0.97);               // MOUTH COLOR\n        \n   \tif(mod(-coord.y,0.0)>0.12)                       // INNER MOUTH VOID\n    if(roundBox(coord, vec2(0.0,0.0), vec2(0.05, 0.02) )<0.5) // INNER MOUTH\n\t\tresult.xyz=vec3(0.97, 0.97, 0.97);   // INNER MOUTH COLOR\n\t\n\t//for(float i=-0.4; i<0.5; i+=0.1)                           // Teeth Left Right Extend \n\t//if(roundBox(coord, vec2(i,-0.25), vec2(0.003, 0.14+sin(mouth+i)*0.02) )<0.005) // Teeth Position\n\t//\tresult.xyz=vec3(0.0, 0.4, 0.0);                            // Teeth Color\n\t\t\n\tif(roundBox(coord, vec2(0.25,0.28+rightEyebrow), vec2(0.16, 0.001) )<0.008) // right eyebrow position size\n\t\tresult.xyz-=vec3(0.7, 0.7, 0.7);                 // right eyebrow color\n\t\n\tif(roundBox(coord, vec2(-0.25,0.28+leftEyebrow), vec2(0.16, 0.001) )<0.008) // left eyebrow position size\n\t\tresult.xyz-=vec3(0.7, 0.7, 0.7);                     // left eyebrow color\n\tresult.xyz=result.xyz-vec3(min(max(-0.3+length(coord)*0.45,0.0),1.0))+vec3(0.06*rand(vec2(coord.x+coord.y,iTime*coord.y*coord.x))); //Background Gradient controls\n\t\n\tif(rgbare==0.0)\n\t\tfinalresult.r=result.r;\n\tif(rgbare==1.0)\n\t\tfinalresult.gb=result.gb;\n\t}\n\tif(mod(fragCoord.y,2.0)<1.0)   /////////////////////////\n\tfinalresult.xyz=finalresult.xyz/1.3;\n\tfragColor = finalresult;\n}","name":"Image","description":"","type":"image"}]}