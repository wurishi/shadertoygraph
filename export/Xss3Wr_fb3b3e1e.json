{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/*by mu6k, Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n just playing around with distance functions...\n\n 04/05/2013:\n - published\n\n muuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuusk!*/\n\nvec2 rotate(vec2 v, float angle)\n{\n\tvec2 vo = v; float cosa = cos(angle); float sina = sin(angle);\n\tv.x = cosa*vo.x - sina*vo.y;\n\tv.y = sina*vo.x + cosa*vo.y;\n\treturn v;\n}\n\nvec2 rotate_z(vec2 v, float angle)\n{\n\tvec2 vo = v; float cosa = cos(angle); float sina = sin(angle);\n\tv.x = cosa*vo.x - sina*vo.y;\n\tv.y = sina*vo.x + cosa*vo.y;\n\treturn v;\n}\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tvec3 vo = v; float cosa = cos(angle); float sina = sin(angle);\n\tv.x = cosa*vo.x - sina*vo.y;\n\tv.y = sina*vo.x + cosa*vo.y;\n\treturn v;\n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tvec3 vo = v; float cosa = cos(angle); float sina = sin(angle);\n\tv.x = cosa*vo.x - sina*vo.z;\n\tv.z = sina*vo.x + cosa*vo.z;\n\treturn v;\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tvec3 vo = v; float cosa = cos(angle); float sina = sin(angle);\n\tv.y = cosa*vo.y - sina*vo.z;\n\tv.z = sina*vo.y + cosa*vo.z;\n\treturn v;\n}\n\t\n\t\nfloat hash(float x)\n{\n\treturn fract(sin(x*.0127863)*17143.321); //decent hash for noise generation\n}\n\nfloat hash(vec2 x)\n{\n\treturn fract(cos(dot(x.xy,vec2(2.31,53.21))*124.123)*412.0); \n}\n\nvec3 cc(vec3 color, float factor,float factor2) // color modifier\n{\n\tfloat w = color.x+color.y+color.z;\n\treturn mix(color,vec3(w)*factor,w*factor2);\n}\n\n\nfloat dist(vec3 p) //distance function\n{\n\tfloat d = 200.0; //initial value for the distance\n\t\n\tfor (int i=0; i<4; i++) // 4 layers of arbitrary rotated, repeating domain...\n\t{\n\t\tvec3 rp = p;\n\t\n\t\trp = rotate_x(rp,float(i)*120.04); //randomly rotate around the x axis\n\t\trp = rotate_y(rp,float(i)*320.125); //randomly rotate around the y axis\n\t\trp = mod(rp-vec3(2.5),5.0)-2.5; //repeat the domain over and over again\n\t\t\t\n\t\tvec3 cv0 = rp; //cv0 -- transformed space\n\t\t\t\n\t\tfloat c0 = max(max(abs(cv0.x)-0.7,abs(cv0.y)-0.7),abs(cv0.z)-0.7); //cube\n\t\tfloat c1 = length(cv0)-1.0; //sphere\n\t\tc0 = mix(c0,c1,cos(iTime*0.6+float(i)*3.14159*0.5+(p.x+p.y+p.z)*0.1)*0.5+0.5);\n\t\t//mix\n\t\t\n\t\td = mix(d,c0,smoothstep(-0.25,0.25,d-c0)); //blend with the rest\n\t}\n\t\n\treturn d;\n}\n\nfloat dist_spheres(vec3 p) //distance function, spheres only\n{\n\tfloat d = 200.0; //initial value for the distance\n\t\n\tfor (int i=0; i<4; i++) // 4 layers of arbitrary rotated, repeating domain...\n\t{\n\t\tvec3 rp = p;\n\t\n\t\trp = rotate_x(rp,float(i)*120.04); //randomly rotate around the x axis\n\t\trp = rotate_y(rp,float(i)*320.125); //randomly rotate around the y axis\n\t\trp = mod(rp-vec3(2.5),5.0)-2.5; //repeat the domain over and over again\n\t\t\t\n\t\tvec3 cv0 = rp; //cv0 -- transformed space\n\t\t\t\n\t\tfloat c1 = length(cv0)-1.0; //sphere\n\t\t\n\t\td = mix(d,c1,smoothstep(-2.25,2.25,d-c1)); //blend with the rest\n\t}\n\t\n\treturn d;\n}\n\nvec3 colorfunc(vec3 p) //coloring function... based on the distance function\n{\n\tvec3 color=vec3(1.0,1.0,1.0); //this is the initial color\n\t//each object contributes to this by multiplying it's own color\n\t//the further away from the origin, the less contribution\n\t//so this way, fused objects will modify each others color\n\t\n\tfor (int i=0; i<4; i++)\n\t{\n\t\tvec3 rp = p;\n\t\n\t\trp = rotate_x(rp,float(i)*120.04);\n\t\trp = rotate_y(rp,float(i)*320.125);\n\t\tvec3 rpmd = mod(rp-vec3(2.5),5.0)-2.5;\n\t\tvec3 cs = rp-rpmd;\n\t\trp=rpmd;\n\t\t\t\n\t\tvec3 cv0 = rp;\n\t\t\t\n\t\tfloat c0 = max(max(abs(cv0.x)-0.7,abs(cv0.y)-0.7),abs(cv0.z)-0.7);\n\t\tfloat c1 = length(cv0)-1.0;\n\t\tc0 = mix(c0,c1,cos(iTime*0.6+float(i)*3.14159*0.5+(p.x+p.y+p.z)*0.1)*0.5+0.5);\n\t\t\n\t\tif (c0<0.5) //this is where the coloring magic happens\n\t\t{\n\t\t\tfloat h = cs.x*42.12+cs.y*132.321+cs.z*1232.412; //hash\n\t\t\tvec3 nc = max(vec3(sin(h*8.42)*.5+.5,sin(h*6.42)*.5+.5,sin(h*12.42)*.5+.5),vec3(.0,.0,.0));\n\t\t\t//nc hold a new random color\n\t\t\tcolor*=mix(vec3(1.0,1.0,1.0),nc,1.0-c0*2.0); //mix\n\t\t}\n\t}\n\t\n\treturn color*2.0;\n}\n\nvec3 normal(vec3 p,float e) //returns the normal, uses the distance function\n{\n\tfloat d=dist(p);\n\treturn normalize(vec3(dist(p+vec3(e,0,0))-d,dist(p+vec3(0,e,0))-d,dist(p+vec3(0,0,e))-d));\n}\n\nvec3 normal_spheres(vec3 p,float e) //returns the normal, uses the spheres only distance function\n{\n\tfloat d=dist_spheres(p);\n\treturn normalize(vec3(dist_spheres(p+vec3(e,0,0))-d,\n\t\t\t\t\t\t  dist_spheres(p+vec3(0,e,0))-d,\n\t\t\t\t\t\t  dist_spheres(p+vec3(0,0,e))-d));\n}\n\nfloat ambient_occlusion(vec3 p,float e) //a way of computing ambient occlusion... not used\n{\n\tvec3 n = normal(p,0.01);\n\tfloat ao = 1.0;\n\tfloat t = e;\n\n\tfor(int i=1; i<10; i++)\n\t{\n\t\tfloat t = e/float(i);\n\t\tfloat d = dist(p+n*t);\n\t\tfloat delta = t-d;\n\t\tao-=delta*0.1;\n\t\tif (delta<0.01)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ao;\n}\n\nvec3 light_dir = normalize(vec3(-1.0,-1.0,1.0)); //direction of the light\n\nfloat shadow(vec3 p) // a way of computing shadows... not used\n{\n\tfloat s = 0.0;\n\tfor (int i=0; i<50; i++)\n\t{\n\t\tfloat d = dist(p);\n\t\tp+=-light_dir*(0.01+d*0.5);\n\t\n\t\tfloat ss = d; if (ss<0.0) ss = 0.0; if (ss>1.0) ss = 1.0;\n\t\tss*=0.01;\n\t\ts+=ss;\n\t\tif (ss<0.0)\n\t\t{\n\t\t\ts=0.0;\n\t\t\tbreak;\n\t\t}\n\t\tif (p.y>10.0)\n\t\t{\n\t\t\ts+=float(99-i)*0.01; break;\n\t\t}\n\t}\n\treturn pow(s,4.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy - 0.5;\n\tvec3 p = vec3(sin(iTime*0.1)*2.0,sin(iTime*0.21)*2.0,iTime);\n\tvec3 d = vec3(uv,1.0); \n\n\tfloat t = iTime;\n\n\t\n\td = normalize(d);\n\n\t//try to find a position which doesn't collide with any of the objects\n\t//uses a spheres only version of the distance function for smoother results...\n\t//far from perfect, needs information from previous frame to make it good\n\tfloat q = dist_spheres(p);\n\tq = 1.0-q; q = max(.0,q); q = min(q,1.0);\n\tvec3 n = normal_spheres(p,1.0); n.z=0.0; n=normalize(n);\n\tp=p+n*q;\n\t\n\tq = dist_spheres(p);\n\tq = 0.3-q; q = max(.0,q); q = min(q,1.0);\n\tn = normal_spheres(p,1.0); n.z=0.0; n=normalize(n);\n\tp=p+n*q;\n\t\t\n\t//p = rotate_x(p,m.y*1.2);\n\td = rotate_x(d,-m.y*2.2-n.y*0.1);\n\t//p = rotate_y(p,m.x*3.14159*2.0);\n\td = rotate_y(d,-m.x*3.14159*2.0-n.x*0.1);\n\t\n\tfloat light_source = max(.0,pow(-dot(light_dir,d)*.5+.5,10.0));\n\tvec3 background = vec3(.6) + vec3(light_source);\n\tvec3 color = background; //first compute background\n\t//then do the raymarch and overwrite the color if something is hit\n\t\n\tfor (int i=0; i<50; i++) //raymarching\n\t{\n\t\tfloat t = dist(p);\n\t\tp += t*d*(0.85+hash(p.xy+uv.xy)*0.3); //noise is used to kill color banding\n\n\t\tif (t<0.01) //collision with something\n\t\t{\n\t\t\tvec3 n = normal(p,0.01);\n\n\t\t\tfloat ao = dist(p+n)*.5+.5; ao = pow(ao,0.5); //simple way of\n\t\t\t//calculating ambient occlusion\n\t\t\t\n\t\t\tfloat diffuse = max(.0,-dot(light_dir,normal(p,0.01)))*0.4;\n\t\t\tfloat specular = pow(max(.0,-dot(light_dir,reflect(d,n))),80.0);\n\t\t\t//phong lighting model\n\t\t\t\n\t\t\tfloat ambient = 0.2*ao;\n\t\n\t\t\tfloat sh=1.0;\n\t\t\tcolor = colorfunc(p)*(diffuse*sh+ambient)+vec3(specular)*ao*2.0; //mix everything\n\t\t\tcolor = mix(color,background,float(i)/50.0); //iteration glow\n\t\t\tbreak;\n\t\t}\n\t}\n\tcolor *= vec3(0.95,0.6,0.3)*1.5; //more pink, less blue\n\tcolor = cc(color,0.5,0.5); //desaturate + color contrast\n\tfragColor = vec4(color,1.0); //done!\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xss3Wr","date":"1367693935","viewed":813,"name":"Candy","username":"mu6k","description":"99% sugar cubes and sugar spheres with artificial coloring... mmmmmm delicious... use the mouse too look around","likes":28,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","distance"],"hasliked":0,"parentid":"","parentname":""}}