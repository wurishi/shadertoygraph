{"ver":"0.1","info":{"id":"Wlj3Ry","date":"1560043456","viewed":432,"name":"isoline reaction-diffusion","username":"j2rgb","description":"A reaction-diffusion sim driven by the animated isolines of a 2D SDF. You can find various parameters in the Common tab, but they are quite tricky to tweak -- very resolution dependent. Let it run for a long enough time to see the full pattern emerge.","likes":21,"published":1,"flags":32,"usePreview":0,"tags":["2d","simulation","diffusion","reactiondiffusion","reaction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Justin Shrake - @j2rgb/2019\n// Created in https://github.com/jshrake/grimoire\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// - Buffer A animates the isolines of a 2D SDF by time. In this case, a flower of life pattern.\n// - Buffer B/C/D are duplicates and perform the reaction-diffusion sim.\n// - The trick is at the end of Buffer D. We mix Buffer A with the reaction-diffusion results.\n// - You can find various parameters in the common tab. These are quite tricky to tweak!\n// - Likely broken if you try to fullscreen. The parameters are somehwat sensitive to resolution.\n//   For me, it looks best when you have a window sized such that you see a yellow or white square\n//   in the top-right corner of shadertoy. I need to fix this...\n// - Let it run for a long enough time to see the full pattern emerge.\n\n// Resources:\n// - http://www.karlsims.com/rd.html\n// - http://mrob.com/pub/comp/xmorphia/\n\n// Uncomment the below line to show the contents of Buffer A\n//#define SHOW_A\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord / iResolution.xy;\n  float val = texture(iChannel0, uv).r;\n  fragColor.rgb = vec3(smoothstep(0.4, 0.55, val));\n  #ifdef SHOW_A\n  fragColor = texture(iChannel1, uv);\n  #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by Justin Shrake - @j2rgb/2019\n// Created in https://github.com/jshrake/grimoire\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst float PI = 3.14159265359;\n\nfloat sdf_circle(vec2 uv, float r) { return length(uv) - r; }\n\nfloat map(vec2 uv) {\n  // 2D flower of life pattern\n  float radius = 0.5;\n  float off = radius;\n  float fctx = 0.87;\n  float fcty = 0.5;\n  float c = sdf_circle(vec2(uv.x, uv.y), radius);\n  float cw = sdf_circle(vec2(uv.x, uv.y + off), radius);\n  float ce = sdf_circle(vec2(uv.x, uv.y - off), radius);\n  float cne = sdf_circle(vec2(uv.x + fctx * off, uv.y + fcty * off), radius);\n  float cnw = sdf_circle(vec2(uv.x + fctx * off, uv.y - fcty * off), radius);\n  float cse = sdf_circle(vec2(uv.x - fctx * off, uv.y + fcty * off), radius);\n  float csw = sdf_circle(vec2(uv.x - fctx * off, uv.y - fcty * off), radius);\n  float width = 0.001;\n  c = abs(c) - width;\n  cw = abs(cw) - width;\n  ce = abs(ce) - width;\n  cne = abs(cne) - width;\n  cnw = abs(cnw) - width;\n  cse = abs(cse) - width;\n  csw = abs(csw) - width;\n  float d = min(min(min(min(min(min(c, cw), ce), cne), cnw), cse), csw);\n  return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n  float d = map(uv);\n  float a = 0.5 + 0.5*cos(STRIPES * PI * d - STRIPES_TIMESCALE * iTime);\n  fragColor.rgb = vec3(smoothstep(0.5, 1.0, a));\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Created by Justin Shrake - @j2rgb/2019\n// Created in https://github.com/jshrake/grimoire\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord / iResolution.xy;\n  vec2 pixel_offset = 1.0 / iResolution.xy;\n  if (iFrame < FRAME_WAIT) {\n    fragColor.rg = vec2(1.0, 0.0);\n    fragColor.g += texture(iChannel1, uv).g;\n  } else {\n    fragColor.rg = reaction_diffusion(iChannel0, uv, pixel_offset);\n  }\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Buffer A \n// The number of isolines and the rate at which they animate\nconst float STRIPES = 32.0;\nconst float STRIPES_TIMESCALE = 1.0;\n\n// Buffer B-D: \n// The amount of frames to wait before starting to the reaction-diffusion sim\nconst int FRAME_WAIT = 5;\n\n// Buffer D\n// The amount to mix the isoline animation from Buffer A into the reaction-diffusion sim\nconst float ANIMATION_MIX = 0.004;\n\n// Reaction-diffusion knobs. Tweak to taste!\nconst vec2 D = vec2(1.0, 0.5);\nconst float F = 0.0800;\nconst float K = 0.0600;\nconst float DT = 1.0;\n\n// Based on http://www.karlsims.com/rd.html\nvec2 reaction_diffusion(sampler2D tex, vec2 uv, vec2 pixel_offset) {\n\n  // laplacian: 3x3 convolution\n  vec2 tl = texture(tex, uv + pixel_offset * vec2(-1.0, 1.0)).xy;\n  vec2 tm = texture(tex, uv + pixel_offset * vec2(0.0, 1.0)).xy;\n  vec2 tr = texture(tex, uv + pixel_offset * vec2(1.0, 1.0)).xy;\n  vec2 ml = texture(tex, uv + pixel_offset * vec2(-1.0, 0.0)).xy;\n  vec2 mm = texture(tex, uv + pixel_offset * vec2(0.0, 0.0)).xy;\n  vec2 mr = texture(tex, uv + pixel_offset * vec2(1.0, 0.0)).xy;\n  vec2 bl = texture(tex, uv + pixel_offset * vec2(-1.0, -1.0)).xy;\n  vec2 bm = texture(tex, uv + pixel_offset * vec2(0.0, -1.0)).xy;\n  vec2 br = texture(tex, uv + pixel_offset * vec2(1.0, -1.0)).xy;\n  mm = clamp(mm, vec2(0.0), vec2(1.0));\n  vec2 laplacian =\n      0.05 * (tl + tr + bl + br) + 0.2 * (tm + ml + mr + bm) + -1.0 * mm;\n\n  float A = mm.x;\n  float B = mm.y;\n  float DA = D.x;\n  float DB = D.y;\n  float reaction = A * B * B;\n  float a = A + (DA * laplacian.x - reaction + F * (1.0 - A)) * DT;\n  float b = B + (DB * laplacian.y + reaction - (K +F) * B) * DT;\n  return vec2(a,b);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Created by Justin Shrake - @j2rgb/2019\n// Created in https://github.com/jshrake/grimoire\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord / iResolution.xy;\n  vec2 pixel_offset = 1.0 / iResolution.xy;\n  if (iFrame < FRAME_WAIT) {\n    fragColor.rg = vec2(1.0, 0.0);\n    fragColor.g += texture(iChannel1, uv).g;\n  } else {\n    fragColor.rg = reaction_diffusion(iChannel0, uv, pixel_offset);\n  }\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Created by Justin Shrake - @j2rgb/2019\n// Created in https://github.com/jshrake/grimoire\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord / iResolution.xy;\n  vec2 pixel_offset = 1.0 / iResolution.xy;\n  if (iFrame < FRAME_WAIT) {\n    fragColor.rg = vec2(1.0, 0.0);\n    fragColor.g += texture(iChannel1, uv).g;\n  } else {\n    fragColor.rg = reaction_diffusion(iChannel0, uv, pixel_offset);\n  }\n  // Here is the trick\n  fragColor.g = mix(fragColor.g, texture(iChannel1, uv).g, ANIMATION_MIX);\n}","name":"Buffer D","description":"","type":"buffer"}]}