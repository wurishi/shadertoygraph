{"ver":"0.1","info":{"id":"Mt33RM","date":"1520173494","viewed":251,"name":"sdf Tunnel","username":"XDargu","description":"Tunnel test","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["sdftunnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \n   I wanted to make some basic material blending capable of blending materials using only \n   the material ID, without the actual colour. This is my clumsy first attempt. \n   Currently it can't blend more than two materials, and it's probably much more expensive\n   than it shoud be. Artifacts are evident when it tries to blend three or more colours.\n   \n   The way it works is having two material IDs and a blend amount between them. The first id\n   is always the dominant material of the surface, using the blend amount to mix between the\n   materials. In the render function we can get the material info of the current surface and\n   set the colour using the material ID. This is done for both materials, and then both colours\n   are mixed in order to produce the final value.\n\n Sources:\n - http://mercury.sexy/hg_sdf/\n - https://iquilezles.org/articles/distfunctions\n\n*/\n#define BLEND_SIZE 0.2\n#define PI 3.14159\n\n#define CAMSPEED 2.0\n\n//#define VIEW_BLEND\n//#define VIEW_SECOND_COL\n\nfloat getGrey(vec3 p){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n   \n    const float eps = 0.001;\n    float ref = getGrey(tex3D(tex,  p , nor));                 \n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x-eps, p.y, p.z), nor))-ref,\n                      getGrey(tex3D(tex, vec3(p.x, p.y-eps, p.z), nor))-ref,\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z-eps), nor))-ref )/eps;\n             \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n// SDF result struct\nstruct SDFRes\n{\n    float d; // distance\n    float m; // material\n    float m2; // secondary material\n    float b; // blend amount: 0=m, 1=m2\n};\n    \nfloat saturate(float v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\nfloat getBlend(float d1, float d2)\n{\n    float diff = -abs(d1 - d2);\n    float blend = diff / BLEND_SIZE;\n    blend = saturate((blend + 1.0) * 0.5);\n    return blend;\n}\n\n// Domain modifiers\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Operations\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat add(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\nfloat substract(float d1, float d2)\n{\n    return max(d1, -d2);\n}\n\nSDFRes addSDF(in SDFRes f1, SDFRes f2 )\n{\n    if (f1.d < f2.d)\n    \treturn f1;\n    return f2;\n}\n\nSDFRes substractSDF(SDFRes f1, SDFRes f2 )\n{\n    float t = substract(f1.d, f2.d);\n    return SDFRes(t, (t < f2.d) ? f1.m : f2.m, 0.0, 0.0);\n}\n\nSDFRes blendSDF(SDFRes f1, SDFRes f2, float k)\n{\n    // Branching a lot :( Needs more work\n    \n   \tSDFRes closest  = f1;\n    SDFRes furthest = f2;\n\t\n\tfloat diff = float(f1.d > f2.d);\n    \n\tclosest.d =  mix(f1.d, f2.d,   diff);\n\tclosest.m =  mix(f1.m, f2.m,   diff);\n\tclosest.m2 = mix(f1.m2, f2.m2, diff);\n\tclosest.b =  mix(f1.b, f2.b,   diff);\n\t\n\tfurthest.d =  mix(f2.d, f1.d,   diff);\n\tfurthest.m =  mix(f2.m, f1.m,   diff);\n\tfurthest.m2 = mix(f2.m2, f1.m2, diff);\n\tfurthest.b =  mix(f2.b, f1.b,   diff);\n    \n\t// Dominant materials\n\tfloat mf1 = mix(closest.m2, closest.m, float(closest.b < 0.5));\n\tfloat mf2 = mix(furthest.m2, furthest.m, float(furthest.b < 0.5));\n    \n    // New distance\n    float t  = smin(f1.d, f2.d, k);\n    \n    // New blend\n    float bnew = getBlend(f1.d, f2.d);\n    float b = max(closest.b, bnew);\n    float bhigher = float(b > bnew);\n\n\tfloat m  = mix(mf1, closest.m,  bhigher);\n\tfloat m2 = mix(mf2, closest.m2, bhigher);\n    \n    return SDFRes(t, m, m2, b);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdSphere(in vec3 p, in float size )\n{\n    return length(p) - size;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdFloor( vec3 p, vec2 b )\n{\n  \tvec2 d = abs(p.xy) - b;\n    float t = p.y - b.y;\n    \n    //float h = 0.7 + 0.12 * (sin(p.x*8.3 - 1.));\n    float h = 0.7 + (sin(p.z) + 1.0) * 0.06;\n    float tiles = max(\n        \tpow(abs(sin(p.x*17.0 + 0.2)) * h, 18.0),\n        \tpow(abs(sin(p.z*17.0 + 0.2)) * h, 18.0)\n        );    \n    t -= 0.05 - tiles;\n    \n\treturn t;\n}\n\nfloat sdPlane( vec3 p )\n{\n    return p.y;\n}\n\nvec3 path(in float t)\n{\n    vec3 ret = vec3(0.0);\n    ret.x -= sin(t*0.5) * 0.8;\n    //ret.y -= sin(t*0.5) * 0.0;\n    return ret;\n}\n\nfloat sdTunnel( vec3 p )\n{   \n    p.y += sin(54.0*cos(p.x))*0.05;\n    //p.x -= sin(p.z) * sign(p.x) * 0.03;\n    \n    float t = 1.0 - length(p.xy);\n    \n  \treturn t;\n}\n\nSDFRes map(in vec3 pos )\n{   \n    pos -= path(pos.z);\n    SDFRes plane = SDFRes( sdTunnel(  pos - vec3(0.0, 0.0, 0.0) ), 0.5, 0.0 ,0.0);\n    \n    vec3 p = pos - vec3(0.0, 0.44, 3.0);\n    pMod1(p.z, 1.0);\n    \n    plane = addSDF( plane,\n                  SDFRes( udRoundBox(p, vec3(1.0, 0.05, 0.1), 0.01 ), 5.0, 0.0, 0.0)\n                  );\n    \n    p = pos - vec3(0.0, -0.2, 3.0);\n    pMod1(p.z, 1.5);\n    \n    plane = substractSDF( plane,\n                  SDFRes( sdBox(p, vec3(1.6, 0.5, 0.65) ), 0.5, 0.0, 0.0)\n                  );\n    \n    plane = blendSDF( plane,\n                  SDFRes( sdFloor(pos - vec3(0.0, -1.0, 0.0), vec2(1.0, 0.2) ), 2.0, 0.0, 0.0)\n                     , 16.0\n                  );\n    \n    /*plane = addSDF( plane,\n                  SDFRes( sdFloor(pos - vec3(0.0, -1.0, 0.0), vec2(1.0, 0.2) ), 2.0, 0.0, 0.0)\n                  );*/\n    \n    return plane;\n}\n\nvec3 getNormal(in vec3 pos )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).d - map(pos-eps.xyy).d,\n\t    map(pos+eps.yxy).d - map(pos-eps.yxy).d,\n\t    map(pos+eps.yyx).d - map(pos-eps.yyx).d );\n\treturn normalize(nor);\n}\n\nSDFRes castRay(in vec3 ro, in vec3 rd, in float tmin)\n{    \n    float tmax = 30.0;    \n    \n    SDFRes p;\n    p.d = tmin;\n    p.m = 0.0;\n    p.m2 = 0.0;\n    p.b = 0.0;\n    \n\tfloat precis = 0.00000001;\n    \n    for (int i=0; i<50; i++)\n    {\n        SDFRes s = map( ro + rd * p.d );\n        if (s.d < precis || s.d > tmax)\n        {\n            break;\n        }\n        \n        p.m = s.m;\n        p.m2 = s.m2;\n        p.b = s.b;\n        p.d += s.d;\n    }\n    \n    if (p.d > tmax)\n        p.m = -1.0;\n    \n    return p;\n}\n\n\nfloat shadows(in vec3 ro, in vec3 rd, in float tmin)\n{\n    //return 1.0;\n    const float tmax = 0.95;\n    float res = 1.0;\n    float k = 20.0;\n    \n    float t = tmin;\n    for( int i=0; i<50; i++)\n    {\n        SDFRes h = map(ro + rd*t);\n        if( h.d<0.0001 )\n            return 0.0;\n        if (t > tmax)\n            return res*1.0;\n        \n        res = min( res, k*h.d/t );\n        t += h.d;\n    }\n    return res;\n}\n\nfloat occlusion(in vec3 ro, in vec3 rd)\n{\n    float occ = 0.0;\n    float sca = 1.4;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  rd * hr + ro;\n        float dd = map( aopos ).d;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvoid getMaterialData(in float m, in vec3 pos, inout vec3 nor, inout vec3 col, inout float spow )\n{\n    col = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n    spow = 256.0;\n    \n    if ( m < 100.0 )\n        spow = 2.0;\n    \n    if( m<5.5 && m >= 4.5 )\n    {\n        col = tex3D(iChannel2, pos, nor);\n        spow = 256.0;\n    }\n    \n    if( m<1.5 && m != 0.0 )\n    {\n        vec3 opos = pos;\n        \n        pos.x -= path(pos.z).x;\n        pos.z *= 0.1;\n        pos *= 10.0;\n        float f = mod( floor(2.0*pos.z) + floor(2.0*pos.x), 2.0);\n        col = 0.4 + 0.1*f*vec3(1.0);\n        spow = 32.0 + 240.0 * (1.0 - f);\n        spow = 1.0;\n        \n        if (pos.y > 0.0)\n        {            \n            if (abs(pos.x) > 9.5)\n            {\n                col = vec3(1.0);\n                nor = doBumpMap( iChannel1, opos.xyz, nor, 0.01);\n                //col.x *= smoothstep(0.0, 0.3, abs(pos.y - 1.5) * 1.0);\n            }\n            else if (abs(pos.x) > 8.0)\n            {\n                col = vec3(0.0, 1.0, 1.0);\n                col = tex3D(iChannel2, opos, nor);\n                nor = doBumpMap( iChannel2, opos, nor, 0.01);\n                spow = 256.0;\n            }\n            else if (abs(pos.x) > 6.2)\n            {\n                col = vec3(1.0, 0.0, 0.0);\n                col = tex3D(iChannel1, pos, nor);\n                //col = vec3(1.0, 0.7, 0.0) * 1.0;\n                spow = 256.0;\n            }\n            else {\n                nor = doBumpMap( iChannel1, opos.xyz, nor, 0.01);\n                col = tex3D(iChannel2, opos, nor) * 0.5;\n                spow = 256.0;\n            }\n            /*else if (abs(pos.x) > 4.0)\n            {\n                col = vec3(0.0, 1.0, 0.0);\n                \n            }\n            else\n            {\n                col = vec3(0.0, 0.0, 1.0);\n            }*/\n        }\n        else\n        {\n          if (abs(pos.x) > 8.9)\n            {\n                col = vec3(1.0);\n                //col = vec3(getGrey(tex3D(iChannel0, opos, nor)));\n                nor = doBumpMap( iChannel1, opos, nor, 0.01);\n                \n            }\n            else if (abs(pos.x) > 7.2)\n            {\n                col = vec3(1.0, 0.0, 0.0);\n                col = tex3D(iChannel2, opos, nor);\n                nor = doBumpMap( iChannel2, opos, nor, 0.01);\n                spow = 256.0;\n            }\n            else\n            {\n                col = vec3(0.4, 0.2 , 0.0);\n                spow = 256.0;\n            }\n        }\n    }\n    \n    if( m < 2.5 && m > 1.5 )\n    {\n        nor = doBumpMap( iChannel1, pos, nor, 0.01);\n        \n        pos -= path(pos.z);\n        pos.z *= 0.5;\n        pos *= 2.0;\n        col = texture(iChannel0, pos.xz).xyz;\n        vec3 col2 = texture(iChannel1, pos.xz).xyz * vec3(0.6, 0.6, 0.5);\n        col = mix(col2, col, abs(cos(pos.x*1.0)));\n        spow = 100.0;\n        //spow = pow(((col.x + col.y + col.z) / 3.0), 2.0) * 256.0;\n        col = tex3D(iChannel3, pos, nor);\n        //col = vec3(1.0, 1.0, 1.0) * 0.9;\n    }\n    \n    // 200, 245, 240\n}\n\nvec3 getFinalColour(in vec3 pos, in float m, in float m2, in float b, inout vec3 nor, inout float spow)\n{\n    vec3 col;\n    \n    getMaterialData(m, pos, nor, col, spow);\n    vec3 col2;\n    float spow2;\n    vec3 nor2;\n    getMaterialData(m2, pos, nor2, col2, spow2);\n\n    #ifdef VIEW_SECOND_COL\n    col = col2;\n    #endif\n\n    col = mix(col, col2, b);\n    spow = mix(spow, spow2, b);\n    nor = mix(nor, nor2, floor(b));\n\n    #ifdef VIEW_BLEND\n    col = mix(vec3(col), vec3(0.0, 1.0, 0.0), b*2.0);\n    #endif\n    \n    return col;\n}\n\nvec3 getColour(in vec3 ro, in vec3 rd, in float tmin)\n{\n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;  \n    vec3 dlig = normalize( vec3(0.6, 0.5, 0.7) );\n    \n    SDFRes ray = castRay(ro, rd, tmin);\n    float t = ray.d;\n    float m = ray.m;\n    float m2 = ray.m2;\n    float b = ray.b;\n    float spow = 128.0;\n\n    if( m >-0.5 )\n    {\n        vec3 pos = ro + rd * t;\n        vec3 nor = getNormal(pos);\n        vec3 ref = reflect( rd, nor );\n\n        col = getFinalColour(pos, m, m2, b, nor, spow);\n        \n        // repeat the point light\n        float ld = 10.0;\n        float lp = round(pos.z / ld) * ld;        \n        // Light in front of you\n        lp = iTime*CAMSPEED + 3.0 + sin(iTime) * 2.0;\n        vec3 lightPos = vec3( 0.0, 0.0, lp );\n        lightPos -= path(lightPos.z + PI*2.0);\n        vec3 lig = normalize(lightPos - pos);\n\n        // point light\n        float ldist = length(lightPos - pos);\n        float kc = 1.0;\n        float kq = 0.9;\n\n        // light attenuation\n        float att = 1.0 / ( kc + pow(kq*ldist, 4.0));\n        float dif = att * dot(nor, lig) * 3.0;\n\n        \n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),spow);\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n\n        float shadow = shadows(pos, lig, 0.1);\n        float occ = occlusion(pos, nor);\n\n        dif *= shadow;\n        dom *= shadows(pos, nor, 0.01);        \n\n        vec3 lin = vec3(0.0);\n        lin += dif*occ; // I shouldn't use the occlusion here, but I like the result\n        lin += spe*dif*occ;\n        //lin += fre*0.03*occ;\n        //lin += amb*0.02*occ;\n        //lin += dom*0.1*occ;\n        //lin = vec3(occ);\n        \n        //col = vec3(spe);\n\n        col = col * lin;\n    }\n    \n    //col /= ray.d;\n    \n    return vec3(col);\n}\n\n\nvec3 render(in vec3 ro, in vec3 rd )\n{\n    return getColour(ro, rd, 0.1);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 p = -1.0 + 2.0*uv;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n    float time = 15.0 + iTime;\n    \n    // camera\t\n\tvec3 ro = vec3( 0.0, 0.0, iTime*CAMSPEED );\n    ro -= path(ro.z + PI*2.0);\n\tvec3 ta = ro + vec3(0.0, 0.0, 1.0);\n    ta -= path(ro.z)*0.3;\n    \n    \n    mat3 camera = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = camera * normalize( vec3(p.xy, 2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) ); // gamma\n\n    fragColor=vec4( col, 1.0 );\n    \n}","name":"Image","description":"","type":"image"}]}