{"ver":"0.1","info":{"id":"tt2XDt","date":"1569868807","viewed":1514,"name":"The Opera Game","username":"Poita_","description":"Ray-marched SDF for geometry, shadows, reflections with some volumetric mist and procedural sky. The game is Paul Morphy's famous Opera Game.","likes":56,"published":1,"flags":0,"usePreview":1,"tags":["procedural","sdf","volumetric","fog","chess","opera"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The Opera Game, by Peter Alexander.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// The game is Paul Morphy's famous Opera Game.\n//\n// https://en.wikipedia.org/wiki/Opera_Game\n\n\n///////////////////\n// Feature flags //\n///////////////////\n\n// If performance isn't good enough then you can disable some of these.\n// MSAAx4 has the largest perf cost.\n#define RENDER_SKY true\n#define RENDER_MIST true\n#define RENDER_REFLECTIONS true\n#define RENDER_SHADOWS true\n#define MSAAx4 false\n\n////////////\n// Timing //\n////////////\n\nconst float INTRO_TIME = 5.0;\nconst float TIME_PER_POSITION = 2.0;\nconst float OUTRO_TIME = 7.0;\nconst float INTERMISSION = 1.5;\nconst int TOTAL_POSITIONS = 34;\nconst float TOTAL_TIME = INTRO_TIME + TIME_PER_POSITION * float(TOTAL_POSITIONS) + OUTRO_TIME + INTERMISSION;\n    \nfloat loopTime() {\n    return mod(iTime, TOTAL_TIME);\n}\n\nfloat introTime() {\n    return min(1.0, loopTime() / INTRO_TIME);\n}\n\nfloat moveTime() {\n\treturn max(0.0, loopTime() - INTRO_TIME);\n}\n\nfloat outroTime() {\n    return clamp(1.0 - (loopTime() - (TOTAL_TIME - INTERMISSION - OUTRO_TIME)) / OUTRO_TIME, 0.0, 1.0);\n}\n\nfloat timeOfMove(float m) {\n    return INTRO_TIME + m * TIME_PER_POSITION;\n}\n\n///////////\n// Noise //\n///////////\n\n// Adapted from https://www.shadertoy.com/view/4ts3z2\nfloat tri(float x) {\n    return abs(fract(x) - 0.5);\n}\n\nvec3 tri3(vec3 p) {\n   return abs(fract(p.zzy + abs(fract(p.yxx) - 0.5)) - 0.5);   \n}\n                                 \nfloat triNoise3D(in vec3 p, float spd) {\n    float z = 1.4;\n\tfloat rz = 0.0;\n    vec3 bp = p;\n\tfor (float i = 0.0; i <= 3.0; i++) {\n        vec3 dg = tri3(bp * 2.0);\n        p += (dg + iTime * .3 * spd);\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;    \n        rz += tri(p.z + tri(p.x + tri(p.y))) / z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\n////////////////////\n// SDF primitives //\n////////////////////\n\nfloat sphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat sphere2(vec2 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat ellipse(vec3 p, vec3 r) {\n    float k0 = length(p / r);\n    float k1 = length(p / (r * r));\n    return k0 * (k0 - 1.0) / k1;\n}\n\nfloat ellipse2(vec2 p, vec2 r) {\n    float k0 = length(p / r);\n    float k1 = length(p / (r * r));\n    return k0 * (k0 - 1.0) / k1;\n}\n\nfloat box3(vec3 p, vec3 r) {\n    vec3 d = abs(p) - r;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat box2(vec2 p, vec2 r) {\n    vec2 d = abs(p) - r;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat roundCone(vec3 p, float r1, float r2, float h) {\n    vec2 q = vec2(length(p.xz), p.y);\n    float b = (r1 - r2) / h;\n    float a = sqrt(1.0 - b * b);\n    float k = dot(q, vec2(-b, a));\n    if(k < 0.0)\n        return length(q) - r1;\n    if(k > a * h)\n        return length(q - vec2(0.0, h)) - r2;\n    return dot(q, vec2(a, b)) - r1;\n}\n\nvec2 boxIntersect(vec3 ro, vec3 rd, vec3 rad)  {\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n\t\n    if(tN > tF || tF < 0.0)\n        return vec2(-1.0); // no intersection\n    return vec2(tN, tF);\n}\n\nfloat blend(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\n//////////////////////\n// SDF chess pieces //\n//////////////////////\n\nfloat pawn(vec3 p) {\n    vec2 p2 = vec2(length(p.xz), p.y);\n    float dt = sphere2(vec2(0, 1) - p2, 1.0);\n    float dn = ellipse2(vec2(0, -0.15) - p2, vec2(1.0, 0.3));\n    float dw0 = ellipse2(vec2(0, 0) - p2, vec2(0.5, 0.8));\n    float dw1 = ellipse2(vec2(0, -2.3) - p2, vec2(0.9, 0.3));\n    float dw2 = ellipse2(vec2(0, -2.1) - p2, vec2(1.4, 0.3));\n    float db0 = ellipse2(vec2(0, -2.3) - p2, vec2(1.2, 0.6));\n    float db1 = ellipse2(vec2(0, -3.3) - p2, vec2(2.0, 0.6));\n    float db2 = ellipse2(vec2(0, -3.8) - p2, vec2(2.1, 0.5));\n    float r = blend(dt, dn, 0.3);\n    r = min(r, blend(dw0, dw1, 3.0));\n    r = min(r, dw2);\n    r = min(r, blend(blend(db0, db1, 1.2), db2, 0.3));\n    return r;\n}\n\nfloat base(vec3 p, float rad) {\n    vec2 p2 = vec2(length(p.xz), p.y);\n    float dn = ellipse2(vec2(0, -1.0) - p2, vec2(1.3 * rad, 1.0));\n    float db0 = ellipse2(vec2(0, -2.3) - p2, vec2(1.6 * rad, 0.6));\n    float db1 = ellipse2(vec2(0, -3.3) - p2, vec2(2.5 * rad, 0.6));\n    float db2 = ellipse2(vec2(0, -3.8) - p2, vec2(2.6 * rad, 0.5));\n    float dw = ellipse2(vec2(0, -2.1) - p2, vec2(1.8 * rad, 0.3));\n    float r = blend(blend(db0, db1, 1.0), db2, 0.3);\n    r = min(r, dw);\n    return r;\n}\n\nfloat base1(vec3 p) {\n    return base(p, 1.0);\n}\n\nfloat base2(vec3 p) {\n    float r = base(p, 1.2);\n    vec2 p2 = vec2(length(p.xz), p.y);\n    float dn = ellipse2(vec2(0, -1.4) - p2, vec2(1.15, 2.7));\n    float dc = ellipse2(vec2(0, 2.0) - p2, vec2(1.6, 0.3));\n    float dc1 = ellipse2(vec2(0, 2.2) - p2, vec2(1.5, 0.2));\n    float dc2 = ellipse2(vec2(0, 2.8) - p2, vec2(1.2, 0.2));\n    float ds = ellipse2(vec2(0, 5.9) - p2, vec2(1.9, 2.8));\n    float dcut = box2(vec2(0, 7.2) - p2, vec2(3.0, 2.5));\n    r = blend(r, dn, 1.8);\n    r = blend(r, dc, 1.8);\n    r = min(r, dc1);\n    r = blend(r, dc2, 0.55);\n    r = blend(r, ds, 1.1);\n    return max(r, -dcut);\n}\n\nfloat rook(vec3 p, float base) {\n    vec2 p2 = vec2(length(p.xz), p.y);\n    float dn = ellipse2(vec2(0, -1.0) - p2, vec2(1.2, 1.3));\n    float dc = ellipse2(vec2(0, 0.5) - p2, vec2(1.7, 0.2));\n    float r = blend(base, dn, 1.0);\n    r = blend(r, dc, 1.4);\n    r = min(r, box2(vec2(1.4, 1.1) - p2, vec2(0.2, 0.6)));\n    vec3 b3 = p;\n    const float ang = 3.141593 * 2.0 / 3.0;\n    const mat2 rot = mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n    for (int i = 0; i < 3; ++i) {\n        r = max(r, -box3(vec3(0, 1.4, 0) - b3, vec3(2.0, 0.6, 0.2)));\n        b3.xz = rot * b3.xz;\n    }\n    return r;\n}\n\nfloat knight(vec3 p, float base) {\n    p.x = abs(p.x);\n    float ds1 = sphere(vec3(0.0, 2.0, 0.0) - p, 4.0);\n    float ds2 = ellipse(vec3(0.0, 2.0, 0.0) - p, vec3(2.0, 5.0, 1.8));\n    float dn = roundCone(vec3(-0.3, 1.0, 0.5) - p, 0.8, 2.2, 2.2);\n    float dncut = ellipse(vec3(2.2, 0.0, 0.0) - p, vec3(1.5, 2.5, 5.0));\n    const float a = 1.3;\n    const mat3 rot = mat3(1, 0, 0, 0, cos(a), -sin(a), 0, sin(a), cos(a));\n    float dh = roundCone(rot * (vec3(0.0, 2.5, 0.5) - p), 1.2, 0.6, 1.9);\n    float de = ellipse(vec3(0.5, 3.5, 0.5) - p, vec3(0.4, 0.5, 0.35));\n    float dhcut1 = 0.5 - p.x;\n    float dhcut2 = sphere(vec3(2.1, 2.8, -1.9) - p, 2.0);\n    float dhs = ellipse(vec3(0.0, 2.2, 0.0) - p, vec3(2.0, 1.3, 2.3));\n    float r2 = max(dn, -dncut);\n    float h = dh;\n    h = max(h, -dhcut1);\n    h = max(h, -dhcut2);\n    h = max(h, dhs);\n    h = min(h, max(de, -dhcut1));\n    r2 = blend(r2, h, 0.7);\n    return min(base, max(max(r2, ds1), ds2));\n}\n\nfloat bishop(vec3 p, float base) {\n    vec2 p2 = vec2(length(p.xz), p.y);\n    float dn = ellipse2(vec2(0, -1.4) - p2, vec2(1.0, 1.6));\n    float dc = ellipse2(vec2(0, 0.7) - p2, vec2(1.6, 0.3));\n    float dc1 = ellipse2(vec2(0, 0.9) - p2, vec2(1.5, 0.2));\n    float dc2 = ellipse2(vec2(0, 1.5) - p2, vec2(1.2, 0.2));\n    float dh = ellipse2(vec2(0, 2.6) - p2, vec2(1.3, 1.5));\n    float dt = ellipse2(vec2(0, 4.2) - p2, vec2(0.4, 0.4));\n    const float ang = -0.4;\n    const mat2 rot = mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n    vec3 c3 = vec3(0.8, 3.7, 0.0) - p;\n    c3.xy = rot * c3.xy;\n    float cut = box3(c3, vec3(0.2, 1.0, 2.0));\n    float r = blend(base, dn, 0.9);\n    r = blend(r, dc, 1.5);\n    r = min(r, dc1);\n    r = blend(r, dc2, 0.55);\n    r = min(r, dh);\n    r = min(r, dt);\n    return max(r, -cut);\n}\n\nfloat king(vec3 p, float base) {\n    vec2 p2 = vec2(length(p.xz), p.y);\n    float dh = ellipse2(vec2(0, 4.6) - p2, vec2(1.8, 0.4));\n    float dt1 = box3(vec3(0, 5.2, 0) - p, vec3(0.3, 1.5, 0.25)); \n    float dt2 = box3(vec3(0, 5.8, 0) - p, vec3(1.0, 0.3, 0.25));    \n    float r = min(base, dh);\n    r = min(r, dt1);\n    return min(r, dt2);\n}\n\nfloat queen(vec3 p, float base) {\n    vec2 p2 = vec2(length(p.xz), p.y);\n    float dh = ellipse2(vec2(0, 4.0) - p2, vec2(1.3, 1.5));\n    float dhcut = box2(vec2(0, 2.0) - p2, vec2(3.0, 2.0));\n    float dt = ellipse2(vec2(0, 5.6) - p2, vec2(0.5, 0.5));\n    vec3 pc = vec3(abs(p.x), p.y, abs(p.z));\n    if (pc.x > pc.z)\n        pc = pc.zyx;\n    float dccut = sphere(vec3(1.0, 4.7, 2.2) - pc, 1.1);\n    float r = min(base, max(dh, -dhcut));\n    return max(min(r, dt), -dccut);\n}\n\n// State of the board throughout the game.\n// Each square is 4 bits (13 possibilities: 6 white, 6 black, or empty)\n// Each row is an int (32 bits)\n// Each board is 8 ints.\n// Total 34 positions.\nint board(int m, int r) {\n    if (r == 0) {\n        if (m < 3) return 591750194;\n        if (m < 9) return 541418546;\n        if (m < 11) return 541393970;\n        if (m < 15) return 537199666;\n        if (m < 17) return 537199618;\n        if (m < 23) return 537198594;\n        if (m < 25) return 536880384;\n        if (m < 27) return 536872192;\n        if (m < 33) return 9472;\n        return 1280;\n    }\n    if (r == 1) {\n        if (m < 1) return 286331153;\n        if (m < 5) return 286265617;\n        return 286261521;\n    }\n    if (r == 2) {\n     \tif (m < 3) return 0;\n        if (m < 8) return 3145728;\n        if (m < 9) return 10485760;\n        if (m < 13) return 6291456;\n        if (m < 15) return 96;\n        if (m < 19) return 864;\n        if (m < 31) return 96;\n        return 0;\n    }\n    if (r == 3) {\n        if (m < 1) return 0;\n        if (m < 5) return 65536;\n        if (m < 6) return 69632;\n        if (m < 7) return 167841792;\n        if (m < 8) return 167837696;\n        if (m < 11) return 65536;\n        if (m < 21) return 66560;\n        return 65536;\n    }\n    if (r == 4) {\n        if (m < 2) return 0;\n        if (m < 7) return 458752;\n        if (m < 10) return 65536;\n        if (m < 17) return 458752;\n        if (m < 18) return 67567616;\n        if (m < 19) return 67567728;\n        if (m < 20) return 67567664;\n        if (m < 21) return 67567728;\n        if (m < 29) return 67567680;\n        return 67567616;\n    }\n    if (r == 5) {\n        if (m < 4) return 0;\n        if (m < 10) return 28672;\n        if (m < 12) return 0;\n        if (m < 16) return 9437184;\n        if (m < 20) return 9438976;\n        if (m < 28) return 9437184;\n        if (m < 30) return 10223616;\n        return 786432;\n    }\n    if (r == 6) {\n        if (m < 2) return 2004318071;\n        if (m < 4) return 2003859319;\n        if (m < 14) return 2003830647;\n        if (m < 16) return 2004617079;\n        if (m < 18) return 2004615287;\n        if (m < 22) return 2004615175;\n        if (m < 25) return 2004652039;\n        if (m < 26) return 2004623367;\n        if (m < 28) return 2004647943;\n        if (m < 29) return 2003861511;\n        if (m < 30) return 2003845127;\n        if (m < 32) return 2003865607;\n        return 2003828743;\n    }\n    if (m < 6) return -1985230184;\n    if (m < 12) return -1985232744;\n    if (m < 14) return -2136227688;\n    if (m < 22) return -2136276840;\n    if (m < 24) return -2136276984;\n    if (m < 26) return -2136244224;\n    if (m < 31) return -2136276992;\n    if (m < 32) return -2136276896;\n    if (m < 33) return -2136276848;\n    return -2136268656;\n}\n\n// Materials.\nconst float BOARD_MAT = 0.0;\nconst float WHITE_MAT = 1.0;\nconst float BLACK_MAT = 2.0;\n\n// Cache of board position.\n// Set at the start of mainImage.\nint[8] board_cache;\n\n// SDF evaluation of the board.\n// Returns (distance, material).\nvec2 sdf(vec3 p) {\n    // A hack: for efficiency, we only evaluate piece distance for the piece\n    // in the current square. If there is no piece in the current square then\n    // we return INF distance as a lower-bound distance to pieces in adjacent squares\n    // without needing to evaluate them.\n    const float INF = 1.0;\n\n    float r = min(INF, p.y + 4.0);\n    vec2 res = vec2(r, BOARD_MAT);\n\n    // Discretize coordinates onto board.\n    vec2 ip = p.xz / 8.0 + 4.0;\n    int ix = int(ip.x) & 7;\n    int iy = int(ip.y) & 7;\n    int piece = (board_cache[7 - iy] >> (ix * 4)) & 0xF;\n    if (piece == 0)\n        return vec2(min(res.x, INF), res.y);\n    \n    vec2 pp2 = mod(p.xz, 8.0) - 4.0;\n    vec3 pp3 = vec3(pp2.x, p.y, pp2.y);\n    float is_white = piece < 7 ? 1.0 : 0.0;\n    piece = (piece - 1) % 6;\n    pp3.z *= (is_white * 2.0 - 1.0); // black knight are flipped on z-axis\n    \n    float d_piece;\n    if (piece == 0)\n        d_piece = pawn(pp3);\n    else if (piece == 1)\n        d_piece = rook(pp3, base1(pp3));\n    else if (piece == 2)\n        d_piece = knight(pp3, base1(pp3));\n    else if (piece == 3)\n        d_piece = bishop(pp3, base1(pp3));\n    else if (piece == 4)\n        d_piece = king(pp3, base2(pp3));\n    else\n        d_piece = queen(pp3, base2(pp3));\n\n    float bound = max(abs(p.x) - 32.0, abs(p.z) - 32.0);\n    r = max(bound, d_piece);\n\n    if (r < res.x)\n        res = vec2(r, BLACK_MAT - is_white);\n    \n    return res;\n}\n\nvec3 norm(vec3 p) {\n    // Tetrahedron technique\n    vec3 n = vec3(0.0);\n    for(int i = min(0, iFrame); i < 4; i++) {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdf(p+0.0005*e).x;\n    }\n    return normalize(n);\n}\n\n/////////////\n// Shading //\n/////////////\n\nconst vec3 SKY = vec3(0.16,0.20,0.28) * 0.1;\nconst vec3 LIGHT = vec3(1.64, 1.27, 0.99);\nconst vec3 LIGHT_DIR = normalize(vec3(1.2, -1, 2));\nconst vec3 INDIRECT = LIGHT * 0.1;\nconst vec3 INDIRECT_DIR = normalize(-LIGHT_DIR * vec3(-1.0, 0.0, -1.0));\n\n// Ray march for shadows.\nfloat shadowray(vec3 pos) {\n    if (!RENDER_SHADOWS)\n        return 1.0;\n\n    float res = 1.0;\n    float t = 0.2;\n    for (int i = 0; i < 50; i++) {\n\t\tfloat h = sdf(pos + -LIGHT_DIR * t).x;\n        res = min(res, 16.0 * h / t);\n        t += clamp(h, 0.05, 0.4);\n        if (res < 0.05)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 shade(vec3 albedo, vec3 n, vec3 pos, vec3 dir, float ks, bool shadows) {\n    float shadow = shadows ? shadowray(pos) : 1.0;\n    float light_diffuse = clamp(dot(n, -LIGHT_DIR), 0.0, 1.0);\n    vec3 light_half = normalize(-LIGHT_DIR - dir);\n    float sky = sqrt(clamp(0.5 + 0.5 * n.y, 0.0, 1.0));\n    vec3 ref = reflect(dir, n);\n    float frenel = clamp(1.0 + dot(n, dir), 0.0, 1.0);\n    float indirect = clamp(dot(n, INDIRECT_DIR), 0.0, 1.0);\n    \n    vec3 light = vec3(0.0);\n    light += light_diffuse * LIGHT * shadow;\n    light += sky * SKY;\n    light += indirect * INDIRECT;\n    vec3 col = light * albedo;\n    col += ks * smoothstep(0.0, 0.5, ref.y) * (0.04 + 0.96 * pow(frenel, 4.0)) * SKY;\n\tcol += shadow * ks * pow(clamp(dot(n, light_half), 0.0, 1.0), 8.0) * light_diffuse * (0.04 + 0.96 * pow(clamp(1.0 + dot(light_half, dir), 0.0, 1.0), 3.0)) * LIGHT * 5.0;\n\treturn col;\n}\n\n/////////////////\n// Mist effect //\n/////////////////\n\nfloat fogDensity(vec3 p) {\n    const vec3 fdir = normalize(vec3(10,0,-7));\n    float f = clamp(1.0 - 0.5 * abs(p.y - -4.0), 0.0, 1.0);\n    f *= max(0.0, 1.0 - length(max(vec2(0.0), abs(p.xz) - 28.0)) / 7.0);\n    p += 4.0 * fdir * iTime;\n    float d = triNoise3D(p * 0.007, 0.2) * f;\n    return d * d;\n}\n\nfloat integrateFog(vec3 a, vec3 b) {\n    if (!RENDER_MIST)\n        return 0.0;\n    vec3 d = normalize(b - a);\n    float l = length(b - a);\n \tvec2 trange = boxIntersect(a - vec3(0.0, -3.0, 0.0), d, vec3(36.0, 1.0, 36.0));\n\tif (trange.x < 0.0)\n        return 0.0;\n    trange = min(trange, vec2(l));\n    const float MIN_DIS = 0.2;\n    const float MAX_DIS = 2.0;\n    const float MIN_SAMPLES = 3.0;\n    float tdiff = trange.y - trange.x;\n    float samples = max(MIN_SAMPLES, tdiff / MAX_DIS);\n    float dis = clamp(tdiff / samples, MIN_DIS, MAX_DIS);\n    samples = ceil(tdiff / dis);\n    dis = tdiff / (samples + 1.0);\n    float visibility = 1.0;\n    for (float t = trange.x + 0.5; t < trange.y; t += dis) {\n        float density = fogDensity(a + t * d);\n        visibility *= pow(3.0, -1.0 * density * dis);\n    }\n\treturn 1.0 - visibility;\n}\n\n//////////////////\n// Ray marching //\n//////////////////\n\n// Ray march for reflections.\n// Somewhat more simplified than castray for perf.\nvec3 castray2(vec3 pos, vec3 dir) {\n    if (!RENDER_REFLECTIONS)\n        return SKY;\n    float tmax = (7.0 - pos.y) / dir.y;\n    int i = 0;\n\tfor (float t = 0.1; t < tmax && i < 50; ++i) {\n        vec3 p = pos + t * dir;\n\t\tvec2 res = sdf(pos + t * dir);\n        float d = res.x;\n        float mat = res.y;\n\t\tif (d < 0.001) {\n            vec3 albedo = mat == BLACK_MAT ? vec3(0.02, 0.02, 0.01) : vec3(0.3, 0.22, 0.08);\n            return shade(albedo, norm(p), p, dir, 1.0, false);\n\t\t}\n\t\tt += d;\n\t}\n    return SKY;\n}\n\n// Shading for the board.\nvec3 floorColor(vec2 p, vec3 ray) {\n    // checkerboard color\n    float xr = p.x / 16.0;\n    float yr = p.y / 16.0;\n \tint x = fract(xr) < 0.5 ? 0 : 1;\n    int y = fract(yr) < 0.5 ? 0 : 1;\n    int w = x ^ y;\n    vec3 albedo = (w & 1) == 0 ? vec3(0.2) : vec3(0.04);\n    \n    const vec3 normal = vec3(0, 1, 0);\n    \n    // reflection\n    vec3 rpos = vec3(p.x, -4.0, p.y);\n    vec3 rdir = reflect(ray, normal);\n    vec3 rcolor = castray2(rpos, rdir);\n    \n    // shading\n    albedo = mix(albedo, rcolor, 0.2);\n    vec3 color = shade(albedo, normal, rpos, ray, 0.1, true);\n    \n    return color;\n}\n\n// Main ray march from eye.\nvec3 castray(vec3 pos, vec3 dir) {\n    vec3 c = vec3(0.0);\n    vec2 trange = boxIntersect(pos - vec3(0, 1.4, 0), dir, vec3(36.0, 5.5, 36.0));\n    vec3 p = pos;\n    float mat = -1.0;\n    if (trange.y > 0.0) {\n        int i = 0;\n        float t = trange.x;\n        for (; t < trange.y && i < 150; ++i) {   \n            p = pos + t * dir;\n            vec2 res = sdf(p);\n            float d = res.x;\n            if (d < 0.05) {\n                if (max(abs(p.x), abs(p.z)) > 32.0)\n                    break;\n                mat = res.y;\n                if (mat == BOARD_MAT) {\n                    c = floorColor(p.xz, dir);\n                    break;\n                }\n                vec3 albedo = mat == BLACK_MAT ? vec3(0.02, 0.02, 0.01) : vec3(0.3, 0.22, 0.08);\n                albedo += vec3(.1,.1,.05) * (mat == BLACK_MAT ? 0.5 : 2.2) * (0.2 * sin(15.0 * p.x + 25.0 * sin(2.0 * p.z)));\n                c = shade(albedo, norm(p), p, dir, 1.0, true);\n                break;\n            }\n            t += d;\n        }\n        t = min(t, trange.y);\n        p = pos + t * dir;\n    }\n    if (RENDER_SKY && mat < 0.0) {\n        // Sky\n        const vec3 C1 = vec3(0.12, 0.08, 0.08);\n        const vec3 C2 = vec3(0.04, 0.03, 0.06) * 2.0;\n        float y = dir.y + 0.2 * triNoise3D(dir * 2.0, 1.0);\n        c = mix(C1, C2, smoothstep(-0.35, 0.0, y));\n        float disp = triNoise3D(dir * 0.9, 0.08);\n        c += vec3(1.0) * (pow(disp, 5.0) * 3.47);\n        \n        // Fade to black\n        float h = dot(dir - 0.08 * triNoise3D(dir * 0.3, 0.0), vec3(0.02, 1.0, -0.01));\n        float hstart = -0.2;\n        float hend = -0.5;\n        c = mix(c, vec3(0.0), smoothstep(hstart, hend, h));\n    }\n    \n    // Mist\n    float fog = integrateFog(pos, p);\n    const vec3 FOG_COLOR = vec3(1.5, 1.1, 0.9);\n    return mix(c, FOG_COLOR, clamp(fog, 0.0, 1.0));\n}\n\n////////////\n// Camera //\n////////////\n\nvec2 normScreenSpace(vec2 fragCoord) {\n    return (fragCoord / iResolution.xy - 0.5) * (iResolution.xy / iResolution.x);\n}\n\nmat3 setCamera(vec3 ro, vec3 ta, float cr) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 look(vec2 fragCoord) {\n\tvec2 uv = normScreenSpace(fragCoord);\n    vec3 rd = normalize(vec3(uv, 1.5));\n    float a = loopTime() * 0.3;\n    vec3 ro = vec3(120.0 * -sin(a * 0.5), 45.0 + 10.0 * sin(a - 0.4), 120.0 * cos(a * 0.5));\n    vec3 target = vec3(0, 3, 0);\n  \tmat3 m = setCamera(ro, target, 0.0);\n    vec3 c = castray(ro, m * rd);\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Warp time by position to get a disintegrate move effect.\n    float t = moveTime() / TIME_PER_POSITION + 0.8 * triNoise3D(vec3(3.0 * normScreenSpace(fragCoord), 0.0), 0.0);\n    int move = min(33, int(t));\n    \n    // Precache board layout.\n    for (int i = 0; i < 8; ++i)\n        board_cache[i] = board(move, i);\n\n    // MSAA\n\tint AA = MSAAx4 ? 4 : 1;\n    vec3 c = vec3(0.0);\n    vec2 delta = MSAAx4 ? vec2(0.3, 0.4) : vec2(0.0);\n    for (int i = min(0, iFrame); i < AA; ++i) {\n    \tc += look(fragCoord + delta);\n        delta = vec2(delta.y, -delta.x);\n    }\n    c /= float(AA);\n    \n    float fade = min(1.0, 3.0 * min(introTime(), outroTime()));\n    \n    c *= vec3(0.95, 0.8, 1.1); // color grade   \n    c *= fade;\n    c = pow(c, vec3(0.4545)); // gamma\n    \n\tfragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]}