{"ver":"0.1","info":{"id":"3d3fDs","date":"1606225301","viewed":382,"name":"Fake 3D cube","username":"PelicanPolice","description":"I normally use draw_thing() functions, so I wondered if it would be possible to create some in GLSL. \n\nIt was interesting to learn how to actually make the maths functions I take for granted in game engines. ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","3d","game","cube","fake","draw","shapes","mesh","maker","studio"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/// Code is free to use for any purpose, commercial or otherwise. \n///Just comment if you used it! And if you use it on shadertoy, do include the link to this project on yours :)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Set canvas colour\n    vec3 pixelColour = colRed;\n    \n    // ------------------------ Draw the background (basically loads of random skewed lines).\n    \n    float offset = 0.48;\n    \n    // BLUE STRIPE\n    // Meta for stripe\n    float width = iResolution.x*0.31;\n    float posX  = mod(iResolution.x*(0.6+offset)- iTime*400.0,iResolution.x*2.0)-iResolution.x*0.5;\n\n    // Line coordinates\n    vec2 p1 = vec2(posX,iResolution.y*1.5); // Top\n    vec2 p2 = vec2(posX-iResolution.x*0.1,0.0-iResolution.y*0.5); // Bottom\n\n    // Draw line\n    pixelColour = drawLine(pixelColour,fragCoord,p1,p2,width,colTurqoise,1.0);\n\n    \n    // SAND STRIPE\n    // Meta for stripe\n    width = iResolution.x*0.31;\n    posX  = mod(iResolution.x*(1.2+offset)- iTime*400.0,iResolution.x*2.0)-iResolution.x*0.5;\n\n    // Line coordinates\n    p1 = vec2(posX,iResolution.y*1.5); // Top\n    p2 = vec2(posX-iResolution.x*0.1,0.0-iResolution.y*0.5); // Bottom\n\n    // Draw line\n    pixelColour = drawLine(pixelColour,fragCoord,p1,p2,width,colSand,1.0);\n    \n    // ------------------------ Draw the cube\n    \n    // Draw the cube\n    vec2 cubePos = vec2(iResolution.x*0.5,iResolution.y*0.5);\n    pixelColour = drawFakeCube(pixelColour,fragCoord,cubePos,iTime*60.0,iResolution.x*0.11,iResolution.x*0.009,colWhite,1.0);\n    \n    // Add alpha to final pixel value\n\tfragColor = vec4(pixelColour,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Conversions\nfloat deg2rad(float d) {\n    // Converts degrees to radians (pi = 3.14159265358979)\n\treturn d*0.01745329251; // radians = degrees*(pi/180);\n}\nfloat rad2deg(float r) {\n \t// Converts radians to degrees (pi = 3.14159265358979)\n    return r*57.2957795131; //degrees = radians*(180/pi);\n}\n\n// Returns whether a point is in a triangle \n// Code from https://blackpawn.com/texts/pointinpoly/#:~:text=A%20common%20way%20to%20check,triangle%2C%20otherwise%20it%20is%20not.\nbool pointInTriangle(vec2 A, vec2 B, vec2 C, vec2 P) {\n\n    // Compute vectors        \n    vec2 v0 = C - A;\n    vec2 v1 = B - A;\n    vec2 v2 = P - A;\n\n    // Compute dot products\n    float dot00 = dot(v0, v0);\n    float dot01 = dot(v0, v1);\n    float dot02 = dot(v0, v2);\n    float dot11 = dot(v1, v1);\n    float dot12 = dot(v1, v2);\n\n    // Compute barycentric coordinates\n    float invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);\n    float u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    float v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n    // Check if point is in triangle\n    return (u >= 0.0) && (v >= 0.0) && (u + v < 1.0);\n    }\n\n// Game maker function (look it up if confused! They have good documentation).\nvec2 lendir(float len, float dir) {\n    \n    // Convert to degrees from radians\n    float dirR = deg2rad(dir);\n    \n    // Return vector\n    return vec2(cos(dirR)*len,sin(dirR)*len);\n}\n\n// Returns the angle (in degrees) of two points.\nfloat pointDirection(vec2 p1, vec2 p2) {\n    \n    // Move p1 to 0,0\n    vec2 p0 = p2-p1;\n    \n    // Convert to a clockwise angle\n    return rad2deg(atan(p0.y,p0.x));\n}\n\n// Returns the distance between two 2D positions\nfloat pointDistance(vec2 p1, vec2 p2) {\n     return sqrt(pow(abs(p2.x-p1.x),2.0)+pow(abs(p2.y-p1.y),2.0));\n}\n\n// Drawing\nvec3 drawCircle(vec3 pixelColour, vec2 pixelPos, vec2 circlePos, float circleRadius, vec3 circleColour, float alpha) {\n\n    // If this pixel is within the radius of the circle\n    if (pointDistance(pixelPos,circlePos) < circleRadius) {\n        \n        // Draw cicle\n        pixelColour = mix(pixelColour, circleColour, alpha);\n    }\n    \n    // Return the new pixel colour\n   \treturn pixelColour;\n}\nvec3 drawTriangle(vec3 pixelColour, vec2 pixelPos, vec2 p1, vec2 p2, vec2 p3, vec3 triangleColour, float alpha) {\n\n    // If this pixel is within the radius of the circle\n    if (pointInTriangle(p1,p2,p3,pixelPos)) {\n        \n        // Draw cicle\n        pixelColour = mix(pixelColour, triangleColour, alpha);\n    }\n    \n    // Return the new pixel colour\n   \treturn pixelColour;\n}\nvec3 drawLine(vec3 pixelColour, vec2 pixelPos, vec2 p1, vec2 p2, float width, vec3 lineColour, float alpha) {\n\t\n    // Calculate a rectangle to make up the line\n    float dir = pointDirection(p1,p2);\n    vec2 r1 = p1+lendir(width,dir-90.0);\n    vec2 r2 = p2+lendir(width,dir-90.0);\n    vec2 r3 = p2+lendir(width,dir+90.0);\n    vec2 r4 = p1+lendir(width,dir+90.0);\n    \n    // Draw rectangle\n    pixelColour = drawTriangle(pixelColour,pixelPos,r1,r2,r3,lineColour,alpha);\n    pixelColour = drawTriangle(pixelColour,pixelPos,r1,r3,r4,lineColour,alpha);\n    \n    return pixelColour;\n}\nvec3 drawFakeCube(vec3 pixelColour, vec2 pixelPos, vec2 pos, float dir, float size, float width, vec3 colour, float alpha) {\n\n// Cube meta\n    float cubeSize = size;\n    float zDir = dir;\n    float yDir = 0.0;\n    float xDir = 0.5;\n        \n    // The 2D position on screen to draw the cube\n    vec2 cubePos = pos;\n    \n    // All points of the cube, in 2D space\n    vec2 cube[8]; // contains local coordinates of: top face[x,y x,y x,y x,y]    bottom face[x,y x,y x,y x,y]\n    \n    // Calculate cube corners\n    for (float i = 0.0; i < 4.0; i++) {\n        // These will be the two faces, but right now they're in the middle\n        cube[int(i)]   = lendir(cubeSize,zDir+90.0*i);\n        cube[int(i)+4] = lendir(cubeSize,zDir+90.0*i);\n        \n        // Skew all y coordinates to simulate fake 3D\n        cube[int(i)].y *= xDir;\n        cube[int(i)+4].y *= xDir;\n        \n        // Apply z depth to top and bottom faces\n        cube[int(i)] += lendir(cubeSize*0.65,90.0); // Move top face up\n        cube[int(i)+4] -= lendir(cubeSize*0.65,90.0); // Move bottom face down\n    }\n    \n    // As lots of faces will overlap and look bad with alpha, we can apply alpha afterwards.\n    vec3 newPixelColour = pixelColour;\n    \n    // Draw the cube\n    for (float i = 0.0; i < 4.0; i++) {\n     \n        // Draw the 8 corners of the cube (gives them a round finish)\n        newPixelColour = drawCircle(newPixelColour,pixelPos,cubePos+cube[int(i)],width,colour,1.0); // top\n        newPixelColour = drawCircle(newPixelColour,pixelPos,cubePos+cube[int(i)+4],width,colour,1.0); // bottom\n        \n        // Draw the lines between the top face and bottom face\n        newPixelColour = drawLine(newPixelColour,pixelPos,cubePos+cube[int(i)],cubePos+cube[int(i)+4],width,colour,1.0);\n        newPixelColour = drawLine(newPixelColour,pixelPos,cubePos+cube[int(i)],cubePos+cube[int(i)+4],width,colour,1.0);\n        \n        // Complete the top and bottom face\n        newPixelColour = drawLine(newPixelColour,pixelPos,cubePos+cube[int(mod(i,4.0))],cubePos+cube[int(mod(i+1.0,4.0))],width,colour,1.0);\n        newPixelColour = drawLine(newPixelColour,pixelPos,cubePos+cube[int(mod(i,4.0)+4.0)],cubePos+cube[int(mod(i+1.0,4.0)+4.0)],width,colour,1.0);\n       \n    }\n    \n    // Apply final alpha\n    pixelColour = mix(pixelColour,newPixelColour,alpha);\n    \n    \n    return pixelColour;\n}\n\n// Colours\nvec3 colWhite    = vec3(1.0,1.0,1.0);\nvec3 colBlack    = vec3(0.0,0.0,0.0);\nvec3 colRed      = vec3(0.77,0.35,0.42); // 197,90,106\nvec3 colTurqoise = vec3(0.20,0.93,0.78); // 51,236,199\nvec3 colSand     = vec3(0.93,0.82,0.59); // 236,210,151\n","name":"Common","description":"","type":"common"}]}