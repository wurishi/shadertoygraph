{"ver":"0.1","info":{"id":"XtjyW3","date":"1510353813","viewed":397,"name":"Catmull-Rom Interpolated + Gamma","username":"Tynach","description":"Minimal example for performing Catmull-Rom interpolation of a texture. Wikipedia seems to say this is a type of cubic interpolation, hence the function name. Uses gamma correction.\n\n2018-10-11: Can now choose the trc for interpolation. Default is linear.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["bicubic","sampling","gamma","cubic","interpolation","catmullrom","catmull","rom","gammacorrect","interpolated"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Parameters for gamma correction standards (aka 'transfer characteristics')\nstruct transfer {\n\tfloat power;\n\tfloat off;\n\tfloat slope;\n\tfloat cutoffToLinear;\n\tfloat cutoffToGamma;\n};\n\n\n// Parameters for a linear gamma curve (no correction applied)\nconst transfer gam10 = transfer(1.0, 0.0, 1.0, 0.0, 0.0);\n\n// Parameters for the sRGB gamma curve\nconst transfer gamSrgb = transfer(2.4, 0.055, 12.92, 0.04045, 0.0031308);\n\n// Gamma for the CIE L*a*b* Lightness scale\nconst transfer gamLab = transfer(3.0, 0.16, 243.89/27.0, 0.08, 216.0/24389.0);\n\n\n// Convert a gamma-corrected color value into a linear color value\nvec4 toLinear(vec4 color, transfer trc)\n{\n\tbvec4 cutoff = lessThan(color, vec4(trc.cutoffToLinear));\n\tbvec4 negCutoff = lessThanEqual(color, vec4(-1.0*trc.cutoffToLinear));\n\tvec4 higher = pow((color + trc.off)/(1.0 + trc.off), vec4(trc.power));\n\tvec4 lower = color/trc.slope;\n\tvec4 neg = -1.0*pow((color - trc.off)/(-1.0 - trc.off), vec4(trc.power));\n\n\tcolor = mix(higher, lower, cutoff);\n\tcolor = mix(color, neg, negCutoff);\n\n\treturn color;\n}\n\n// Convert a linear color value into a gamma-corrected color value\nvec4 toGamma(vec4 color, transfer trc)\n{\n\tbvec4 cutoff = lessThan(color, vec4(trc.cutoffToGamma));\n\tbvec4 negCutoff = lessThanEqual(color, vec4(-1.0*trc.cutoffToGamma));\n\tvec4 higher = (1.0 + trc.off)*pow(color, vec4(1.0/trc.power)) - trc.off;\n\tvec4 lower = color*trc.slope;\n\tvec4 neg = (-1.0 - trc.off)*pow(-1.0*color, vec4(1.0/trc.power)) + trc.off;\n\n\tcolor = mix(higher, lower, cutoff);\n\tcolor = mix(color, neg, negCutoff);\n\n\treturn color;\n}\n\n// Sample the linear light value of a texture\nvec4 texGamma(sampler2D tex, ivec2 texCoord, transfer from, transfer to)\n{\n\treturn toGamma(toLinear(texelFetch(tex, texCoord, 0), from), to);\n}\n\n// Centripetal Catmull-Rom Interpolation\nvec4 cubic(vec4 color0, vec4 color1, vec4 color2, vec4 color3, float interp)\n{\n\tvec4 A0 = mix(color0, color1, interp+1.0);\n\tvec4 A1 = mix(color1, color2, interp);\n\tvec4 A2 = mix(color2, color3, interp-1.0);\n\n\tvec4 B0 = mix(A0, A1, 0.5*interp + 0.5);\n\tvec4 B1 = mix(A1, A2, 0.5*interp);\n\n\treturn mix(B0, B1, interp);\n}\n\n#define sample(offset)\\\n\ttexGamma(iChannel0, (position + offset) % ivec2(texRes), disp, intrp)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Use sRGB gamma for the display, and linear light for interpolation\n\ttransfer disp = gamSrgb;\n\ttransfer intrp = gam10;\n\n\t// Sample coordinates are offset by 0.5 pixels so they give decent\n\t// results when not sampling with nearest neighbor\n\tvec2 texRes = vec2(textureSize(iChannel0, 0));\n\tvec2 texCoord = mod(fragCoord*texRes.x/iResolution.x - 0.5, texRes);\n\n\tivec2 position = ivec2(texCoord);\n\tvec2 fraction = fract(texCoord);\n\n\t// Sample 16 pixels in a 4x4 grid\n\tvec4 color0 = sample(ivec2(-1, -1));\n\tvec4 color1 = sample(ivec2(0, -1));\n\tvec4 color2 = sample(ivec2(1, -1));\n\tvec4 color3 = sample(ivec2(2, -1));\n\n\tvec4 color4 = sample(ivec2(-1, 0));\n\tvec4 color5 = sample(ivec2(0, 0));\n\tvec4 color6 = sample(ivec2(1, 0));\n\tvec4 color7 = sample(ivec2(2, 0));\n\n\tvec4 color8 = sample(ivec2(-1, 1));\n\tvec4 color9 = sample(ivec2(0, 1));\n\tvec4 colorA = sample(ivec2(1, 1));\n\tvec4 colorB = sample(ivec2(2, 1));\n\n\tvec4 colorC = sample(ivec2(-1, 2));\n\tvec4 colorD = sample(ivec2(0, 2));\n\tvec4 colorE = sample(ivec2(1, 2));\n\tvec4 colorF = sample(ivec2(2, 2));\n\n\t// Cubic (or Catmull-Rom) interpolate each row of pixels\n\tvec4 row0 = cubic(color0, color1, color2, color3, fraction.x);\n\tvec4 row1 = cubic(color4, color5, color6, color7, fraction.x);\n\tvec4 row2 = cubic(color8, color9, colorA, colorB, fraction.x);\n\tvec4 row3 = cubic(colorC, colorD, colorE, colorF, fraction.x);\n\n\t// Cubic (or Catmull-Rom) interpolate the final colors of the above rows\n\tfragColor = toGamma(toLinear(cubic(row0, row1, row2, row3, fraction.y), intrp), disp);\n}","name":"Image","description":"","type":"image"}]}