{"ver":"0.1","info":{"id":"4sGczm","date":"1521565636","viewed":523,"name":"dancing lights","username":"arpin","description":"Old school frequency visualization plus 3 lights reacting to low, mid, and high frequencies. Background reacts to beat and adds some glow around peaks.","likes":9,"published":1,"flags":64,"usePreview":0,"tags":["music","visualizer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"ld2XWD","filepath":"https://soundcloud.com/swagesound/clockwork","previewfilepath":"https://soundcloud.com/swagesound/clockwork","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//------------------------------------------------------------------------\n// HSL color space\n// Mimics the implementation in THREE.js 0.90.0\n//------------------------------------------------------------------------\nfloat hue2rgb(float p, float q, float t) {\n    if ( t < 0. ) t += 1.;\n    if ( t > 1. ) t -= 1.;\n    if ( t < 1. / 6. ) return p + ( q - p ) * 6. * t;\n    if ( t < 1. / 2. ) return q;\n    if ( t < 2. / 3. ) return p + ( q - p ) * 6. * ( 2. / 3. - t );\n    return p;\n}\nvec3 hsl2rgb(vec3 hsl) {\n    // h,s,l ranges are in 0.0 - 1.0\n    float h = mod(hsl.x, 1.);\n    float s = clamp(hsl.y, 0., 1.);\n    float l = clamp(hsl.z, 0., 1.);\n    if (s == 0.) \n        return vec3(l);\n    else {\n        float p, q;\n        if (l <= 0.5) {\n            p = l * ( 1. + s );\n        }\n        else {\n            p = l + s - ( l * s );\n        }\n        q = ( 2. * l ) - p;\n        return vec3(\n        \thue2rgb(q, p, h + 1. / 3.),\n            hue2rgb(q, p, h),\n            hue2rgb(q, p, h - 1. / 3.)\n        );\n    }\n}\n\n\nfloat rand2(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n// +-----------------+------------------+\n// | Frequency Range | Frequency Values |\n// +-----------------+------------------+\n// | Sub-bass        | 20 to 60 Hz      |\n// | Bass            | 60 to 250 Hz     |\n// | Low midrange    | 250 to 500 Hz    | \n// | Midrange        | 500 Hz to 2 kHz  |\n// | Upper midrange  | 2 to 4 kHz       | \n// | Presence        | 4 to 6 kHz       |\n// | Brilliance      | 6 to 20 kHz      |\n// +-----------------+------------------+\n// https://www.teachmeaudio.com/mixing/techniques/audio-spectrum\n#define SA_MIN \t\t\t0.\n#define SA_MAX \t\t\t11000.\n#define SA_SUB_BASS \t20./(SA_MAX-SA_MIN)\n#define SA_BASS \t\t60./(SA_MAX-SA_MIN)\n#define SA_LOW_MID \t\t250./(SA_MAX-SA_MIN)\n#define SA_MID \t\t\t500./(SA_MAX-SA_MIN)\n#define SA_HI_MID \t\t2000./(SA_MAX-SA_MIN)\n#define SA_PRESENCE \t4000./(SA_MAX-SA_MIN)\n#define SA_BRILLIANCE\t6000./(SA_MAX-SA_MIN)\n\n\n// How accurately to sample spectrum\n#define SAMPLECOUNT 200\n\nfloat sampleRange(float start, float end) {\n    float stepsize = (end - start) / float(SAMPLECOUNT);\n\tfloat intensity = 0.;\n    for(int i = 0; i < SAMPLECOUNT; i += 1) {\n\t\tintensity += texture(iChannel0, vec2(start + float(i)*stepsize, 0.0)).r;\n\t}\n\tintensity /= float(SAMPLECOUNT);\n    return intensity;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    float beat = sampleRange(SA_SUB_BASS, SA_LOW_MID);\n    float low = sampleRange(0., SA_LOW_MID);\n    float mid = sampleRange(SA_LOW_MID, SA_PRESENCE);\n    float hi = sampleRange(SA_PRESENCE, 1.);\n\n    float t = iTime;\n    float tcolor = iTime * .05;\n\n    vec3 col = vec3(0.,0.,0.);\n    \n    float range = 0.9;\n    float saturation = 0.9;\n    float lightness = 0.6;\n    float max_neg_light = -.0; // if set to less than zero, shadows everything else than lights\n    float attenuation = 1.6;\n\n    float dist1 = pow(clamp(\n    \t1.-distance(\n            vec2(0.5+0.3*sin(t),0.5+0.3*cos(t)),\n            uv.xy\n        )/range,\n        max_neg_light,1.\n    ), attenuation);\n    col += hsl2rgb(vec3(sin(tcolor), saturation, mid*lightness))*dist1;\n\n    float dist2 = pow(clamp(\n    \t1.-distance(\n            vec2(0.5+0.2*sin(-t*0.5),0.5+0.2*cos(-t*0.5)) + vec2(0.2*sin(t),0.2*cos(t*1.5)),\n            uv.xy\n        )/range,\n        max_neg_light,1.\n    ), attenuation);\n    col += hsl2rgb(vec3(0.33+sin(tcolor), saturation, low*lightness))*dist2;\n\n    float dist3 = pow(clamp(\n    \t1.-distance(\n            vec2(0.5+0.5*sin(t*0.25), 0.5+0.4*sin(t)),\n            uv.xy\n        )/range,\n        max_neg_light,1.\n    ), attenuation);\n    col += hsl2rgb(vec3(0.66+sin(tcolor), saturation, hi*lightness))*dist3;\n\n    \n    float loudness = texture(iChannel0, vec2(uv.x, 0.0)).r;\n    \n    // add some ambient light with glow around peaks\n    float a2 = abs(.5-uv.y);\n    col += .15*hsl2rgb(vec3(sin(tcolor)+.15, .2, .65*beat*(.5+loudness*.5)*a2));\n    \n    // frequency visualization\n    float intensity_edge = .1;\n    float intensity_bar = .9;\n    float height = .4;\n    float top = loudness*height+.5;\n    float bottom = -loudness*height+.5;\n    float a = min(abs(top - uv.y), abs(bottom - uv.y))/(loudness*height); // fade out\n\n    if (top > uv.y && bottom < uv.y) {\n        vec3 barcolor = hsl2rgb(vec3(\n            sin(tcolor*1.2)+0.66 - loudness*.6,\n            1.,\n            .3+loudness*.3 // add a little bit of punch to peaks\n        ));\n\n        // visualize as bars\n        vec3 bars = barcolor * intensity_bar*a*loudness;\n\n        // visualize as bar edge only\n        float edge_alpha = smoothstep(0.0, .12, a); \n        vec3 edges = barcolor * intensity_edge*(1.-edge_alpha);\n        \n        float transition = smoothstep(0.7, .9, sin(iTime*.1));\n        col += mix(bars, edges, transition); // rotate between two visualization types\n    }\n    \n    // Add some noise to remove color banding\n    float n = rand2(uv*2.+iTime*.001);\n    col += vec3((.4+n*.2)*.01);\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}