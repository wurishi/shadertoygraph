{"ver":"0.1","info":{"id":"MffcD7","date":"1721547170","viewed":25,"name":"scarecrow/grassland","username":"prosumer","description":"hw","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["hw"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// scene copied from Nathan https://www.shadertoy.com/view/fdlGWX\n// ref: https://www.shadertoy.com/view/DdlfR\n\n\nconst int MAX_MARCHING_STEPS = 255;\nconst int MAX_SHADOW_STEPS = 255;\n\nconst float PRECISION = 1e-4;\nconst float MAX_DIST = 100.0;\n\nfloat sdSphere(vec3 p, float r )\n{\n  return length(p) - r;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nstruct Material {\n  vec3 ambientColor; // k_a * i_a\n  vec3 diffuseColor; // k_d * i_d\n  vec3 specularColor; // k_s * i_s\n  float alpha; // shininess\n};\n\nstruct Surface {\n  int id; // id of object\n  float sd; // signed distance\n  Material mat;\n};\n\nMaterial sphere1() {\n  vec3 aCol = 0.5 * vec3(0.7, 0.5, 0);\n  vec3 dCol = 0.6 * vec3(0.7, 0.7, 0);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 4.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial sphere2() {\n  vec3 aCol = 0.4 * vec3(0.9, 0.8, 0.4);\n  vec3 dCol = 0.5 * vec3(0.3, 0.7, 0.2);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 8.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial body() {\n  vec3 aCol = 0.4 * vec3(0.9, 0.5, 0.1);\n  vec3 dCol = 0.5 * vec3(0.3, 0.7, 0.2);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 8.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\n\nMaterial checkerboard(vec3 p) {\n  vec3 aCol = vec3(0.7, 0.6, 0.1);\n  vec3 dCol = vec3(0.3);\n  vec3 sCol = vec3(0);\n  float a = 1.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial grass() {\n  vec3 aCol = 0.4 * vec3(0.3, 0.6, 0.1);\n  vec3 dCol = 0.5 * vec3(0.3, 0.7, 0.2);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 8.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nSurface opUnion(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\n#define hatPos vec3(0.4, 1.5, 0)\n\nSurface scene(vec3 p) {\n#ifdef scarecrow\n  Surface sFloor = Surface(1, p.y + 1., checkerboard(p));\n  Surface sSphere2 = Surface(3, sdSphere(p - hatPos - vec3(0, .3, 0), .5), sphere2());\n  Surface sCylinder = Surface(4, sdRoundedCylinder(p- hatPos, .6, .2, .05), sphere2());\n  Surface sSphere3 = Surface(5, sdSphere(p - hatPos + vec3(0, .4, 0), .4), body());\n  Surface sCapsule = Surface(6, sdCapsule(p - hatPos + vec3(0, 1.5, 0), vec3(0., 1., 0), vec3(0, -1., 0.), .1), body());\n  Surface sCapsule2 = Surface(6, sdCapsule(p - hatPos + vec3(0, 1.3, 0), vec3(1., 0., 0), vec3(-1., 0., 0.), .1), body());\n    Surface co = opUnion(sFloor, sGrass); // closest object\n  co = opUnion(co, sSphere3);\n  co = opUnion(co, sCapsule);\n  co = opUnion(co, sCapsule2);\n  co = opUnion(co, sCylinder);\n  p.y += 1.;\n  Surface sGrass = Surface(7, Map(p, iTime), grass());\n  Surface co = opUnion(co, sSphere2);\n#endif\n#ifndef scarecrow\n  Surface sFloor = Surface(1, p.y + 1., checkerboard(p));\n  Surface sSphere2 = Surface(3, sdSphere(p - hatPos - vec3(0, .3, 0), .5), sphere2());\n  p.y += 1.;\n  Surface sGrass = Surface(7, Map(p, iTime), grass());\n  Surface co = opUnion(sGrass, sFloor);\n#endif\n  return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = 0.0;\n  Surface co;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = scene(p);\n    depth += abs(co.sd);\n    if (abs(co.sd) < PRECISION || depth > MAX_DIST) break;\n  }\n\n  co.sd = depth;\n\n  return co;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n      e.xyy * scene(p + e.xyy).sd +\n      e.yyx * scene(p + e.yyx).sd +\n      e.yxy * scene(p + e.yxy).sd +\n      e.xxx * scene(p + e.xxx).sd);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n    vec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n    vec3 cu = normalize(cross(cd, cr)); // camera up\n\n    return mat3(-cr, cu, -cd);\n}\n\nvec3 phong(vec3 lightDir, float lightIntensity, vec3 normal, vec3 rd, Surface co) {\n  // background\n  vec3 bgColor = vec3(0.835, 1.0, 1.0);\n  //bgColor = vec3(0.5);\n  if (co.sd > MAX_DIST) return bgColor;\n  \n  // ambient\n  vec3 ambient = co.mat.ambientColor;\n\n  // diffuse\n  float dotLN = clamp(dot(-lightDir, normal), 0., 1.);\n  vec3 diffuse = co.mat.diffuseColor * dotLN;\n\n  // specular\n  float dotRV = clamp(dot(reflect(lightDir, normal), -rd), 0., 1.);\n  vec3 specular = co.mat.specularColor * pow(dotRV, co.mat.alpha);\n\n  vec3 col = lightIntensity * (ambient + diffuse + specular);\n  \n  // fog\n  col = mix(col, bgColor, 1.0 - exp(-0.0002 * co.sd * co.sd * co.sd));\n  return col;\n\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float tmax) {\n  float res = 1.0;\n  float t = mint;\n\n  for(int i = 0; i < MAX_SHADOW_STEPS; i++) {\n    float h = scene(ro + rd * t).sd;\n      res = min(res, 8.0*h/t);\n      t += clamp(h, 0.02, 0.10);\n      if(h < 0.001 || t > tmax) break;\n  }\n\n  return clamp( res, 0.0, 1.0 );\n  //return step(tmax - 0., t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 col = vec3(0);\n\n  vec3 lp = vec3(0); // lookat point (aka camera target)\n  vec3 ro = vec3(5.*cos(iTime), 1., 7.);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd); // closest object\n  \n  vec3 p = ro + rd * co.sd; // point on surface found by ray marching\n  vec3 normal = calcNormal(p); // surface normal\n\n  // light\n  vec3 lightPosition = 4. * vec3(6.+cos(iTime), 7., -5.+sin(iTime));\n  vec3 lightDirection = normalize(p - lightPosition);\n  float lightIntensity = 0.9;\n      \n  // phone light model\n  col = phong(lightDirection, lightIntensity, normal, rd, co); \n      \n  // soft shaddow from iq\n  if (co.id == 1 && co.sd < .2 * MAX_DIST) {\n    float softShadow = clamp(softShadow(p, -lightDirection, 100.*PRECISION, length(p-lightPosition)), 0.2, 1.0);\n    col *= softShadow;\n  }\n\n  // reflection;\n  /*\n  if (co.id == 2 || co.id == 3) {\n    vec3 reflRD = reflect(rd, normal);\n    vec3 reflRO = p + 1.1 * PRECISION * normal; // move origin a little bit away\n    Surface reflCO = rayMarch(reflRO, reflRD);\n    vec3 reflP = reflRO + reflRD * reflCO.sd;\n    vec3 reflNormal = calcNormal(reflP);\n    reflCO.sd += co.sd;\n    vec3 reflCol = phong(lightDirection, lightIntensity, reflNormal, reflRD, reflCO);\n    col = mix(col, reflCol, 0.2);\n  }\n*/\n\n/*  // refraction\n  if (co.id == 3) {\n    const float ETA = 1.33; // glass 1.69, water 1.33ï¼Œ1.0 air\n    vec3 refrRD1 = refract(rd, normal, 1./ETA);\n    vec3 refrRO1 = p - 2.1 * PRECISION * normal; // move origin into the sphere\n    Surface refrCO1 = rayMarch(refrRO1, refrRD1);\n    vec3 refrP1 = refrRO1 + refrRD1 * refrCO1.sd;\n    vec3 refrN1 = calcNormal(refrP1);\n    \n    vec3 refrRD2 = refract(refrRD1, -refrN1, ETA);\n    vec3 refrRO2 = refrP1 + 2.1 * PRECISION * refrN1; // move origin outside the sphere\n    Surface refrCO2 = rayMarch(refrRO2, refrRD2);\n    vec3 refrP2 = refrRO2 + refrRD2 * refrCO2.sd;\n    vec3 refrN2 = calcNormal(refrP2);\n    refrCO2.sd += refrCO1.sd + co.sd;\n    vec3 refrCol = phong(lightDirection, lightIntensity, refrN2, refrRD2, refrCO2);\n    col = mix(col, refrCol, 0.2);\n  }\n*/\n  col = pow(col, vec3(1.0/2.2)); // Gamma correction\n  fragColor = vec4(col, 1.0); // Output to screen\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926535\n\nfloat opSubtract(float d1, float d2);\nfloat sdEllipse( vec2 p, vec2 ab );\n\nfloat sdGrassBlade2d(vec2 p, float slant, float base_width)\n{   \n    //Warning: this sdf by design violently breaks down for blades approaching vertical\n    slant = max(0.5, slant);\n\n    float s = sin(PI-slant), c = cos(PI-slant);\n    \n    //Factor scaling verical axes of the ellipses\n    //to make y coord of the intersection always equal to 1.0\n    float vert_fac = 1.0/s;\n\n    //Initial, larger ellipse \n    //It is placed at the lower right cornet, with horizontal axis = 1.0\n    float dist = sdEllipse(p - vec2(1.0, 0.0), vec2(1.0, vert_fac));\n    \n    //Computing minor axis of the smaller ellipse such that it intersects\n    //the larger one at the given angle (slant), but keeping width of the\n    //base fixed\n    float C = 1.0 - base_width;\n    \n    float r = (1.0 + C*C + 2.0*C*c)/(2.0 + 2.0*C*c);\n    \n    //Constructing the smaller ellipse\n    vec2 axes = vec2(r, r*vert_fac);\n    \n    vec2 offset = (1.0 - r) * vec2(c, vert_fac * s);\n    vec2 center = vec2(1.0, 0.0) + offset;\n    \n    //Carving out the smaller ellipse\n    dist = opSubtract(dist, sdEllipse(p - center, axes));\n    \n    //Removing everything below the y=0.0 plane\n    dist = opSubtract(dist, p.y);\n    \n    //Removing everything above the tip using\n    //sdf of a plane that is touched by the tip at a right angle\n    vec2 org = vec2(1.0, 0.0);\n    vec2 dir = normalize(vec2(-1.0, c));\n    \n    dist = opSubtract(dist, dot(p-org, dir));\n    \n    return dist;\n}\n\nfloat opSubtract(float d1, float d2) \n{ \n    return max(d1,-d2);\n}\n\n//Ellipse SDF by Inigo Quilez: https://www.shadertoy.com/view/4lsXDN\nfloat sdEllipse( vec2 p, vec2 ab )\n{\n    // symmetry\n\tp = abs( p );\n\n    // find root with Newton solver\n    vec2 q = ab*(p-ab);\n\tfloat w = (q.x<q.y)? 1.570796327 : 0.0;\n    for( int i=0; i<5; i++ )\n    {\n        vec2 cs = vec2(cos(w),sin(w));\n        vec2 u = ab*vec2( cs.x,cs.y);\n        vec2 v = ab*vec2(-cs.y,cs.x);\n        w = w + dot(p-u,v)/(dot(p-u,u)+dot(v,v));\n    }\n    \n    // compute final point and distance\n    float d = length(p-ab*vec2(cos(w),sin(w)));\n    \n    // return signed distance\n    return (dot(p/ab,p/ab)>1.0) ? d : -d;\n}\n// hash function credit: https://www.shadertoy.com/view/4djSRW\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nmat2 rotate2d(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, -s,s, c);\n}\n\nvec2 opRepeat(vec2 p, vec2 period, out vec2 outId)\n{\n    outId = floor((p+0.5*period)/period);\n    return mod(p+0.5*period, period) - 0.5*period;\n}\n\nfloat sdGrassBlade(vec3 p, float thickness, float t)\n{   \n    float base_width = 0.07;\n    float slant = 0.25*(PI - 1.0)*sin(0.5 * t) + 0.25*(PI + 1.0);\n    \n    float dist2d = max(0.0, sdGrassBlade2d(p.xy, slant, base_width));\n    \n    return sqrt(dist2d*dist2d + p.z*p.z) - thickness;\n}\n\nfloat Map(vec3 p, float t)\n{\n    vec2 grassId;\n    float repeatPeriod = 0.25;\n    p.xz = opRepeat(p.xz, vec2(repeatPeriod), grassId);\n    \n    float dist = 1e30;\n    \n    for (int dy = -1; dy <= 0; ++dy)\n    {\n        for (int dx = -1; dx <= 1; ++dx)\n        {\n            vec3 neighborP = p - vec3(dx, 0, dy) * repeatPeriod;\n            vec2 neighborId = grassId + vec2(dx, dy);\n            \n            vec4 rand = hash42(neighborId);\n            neighborP.xz *= rotate2d(rand.z*6.28);\n            neighborP.xz += (rand.xy - 0.5) * repeatPeriod;\n            \n            dist = min(dist, sdGrassBlade(neighborP/sqrt(rand.w), 0.002, t));\n        }\n    }\n\n    return dist;\n}\n\n","name":"Common","description":"","type":"common"}]}