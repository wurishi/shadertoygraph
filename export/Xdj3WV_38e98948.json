{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":3,"type":"texture","id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//#define ORBIT_CAM\n\n#define ITERATIONS 96\n#define SHADOW_ITERATIONS 8\n\n#ifdef ORBIT_CAM\nconst float aperture=0.0001,focalDistance=1000.0;\n#else\nconst float aperture=0.025,focalDistance=10.0;\n#endif\n\n\nconst float streetWidth = 30.0;\nconst float blockWidth = 200.0;\nconst float totalBlock = blockWidth + streetWidth;\nconst float halfStreetWidth = streetWidth*0.5;\nconst float maxBlockHeight = 600.00;\n\n#define sat(x) clamp(x,0.0, 1.0)\n\nfloat CircleOfConfusion(float t){//calculates the radius of the circle of confusion at length t\n//\treturn 0.01;\n//\treturn max(0.01,abs(focalDistance-t)*1.0*aperture);\n\treturn clamp(abs(focalDistance-t)*1.0*aperture, 0.01, halfStreetWidth);\n}\nfloat linstep(float a, float b, float t){\n\tfloat v=(t-a)/(b-a);\n\treturn clamp(v,0.,1.);\n}\nfloat rand(vec2 co){// implementation found at: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\nfloat smoothstep2( float min1, float max1, float min2, float max2, float p )\n{\n\treturn smoothstep(min1, max1, p) * (1.0 - smoothstep(min2, max2, p));\n}\nfloat softstep( float min1, float p )\n{\n\treturn smoothstep(min1, min1+0.01, p);\n}\nfloat softstep2( float min1, float min2, float p )\n{\n\treturn softstep(min1, p) * (1.0 - softstep(min2, p));\n}\n\n\n\nfloat BlockDe( vec3 pos, float blockId, inout vec4 m )\n{\n\tif( blockId < 0.33 )\n\t\treturn 99999.9;\n\tfloat h = blockId;\n\t\n\th = maxBlockHeight*0.01 + h*maxBlockHeight*0.99;\n\th *= 0.5;\n\t\n\tfloat wScale = fract(blockId+0.5);\n\t\n\tfloat w = blockWidth*0.5;\n\tfloat xz = w*0.6 + w*0.4*wScale;\n\t\n\tpos.xz -= totalBlock*0.5;\n\t\n\tfloat bulk = sdBox( pos - vec3(0,h,0), vec3(xz,h,xz) );\n\tfloat de = bulk;\n\t\n\tfloat bounds = sdBox( pos - vec3(0,h+1.0,0), vec3(xz+2.0,h+2.0,xz+2.0) );\n\t\n\tfloat bands;\n\t{\n\t\tvec3 p = pos;\n\t\tfloat addHeight = 10.0;\n\t\tp.y += 2.0;\n\t\tfloat r = addHeight + addHeight + 20.0 * (fract(1.3-blockId*7.0));\n\t\tp.y = mod(p.y,r);//-0.5*r;\n\t\txz = xz+1.0*wScale;\n\t\tbands = sdBox(p, vec3(xz, addHeight, xz));\n\t\tbands = max(bands,bounds);\n\t\tde = smin( de, bands, 10.0 );\n\t}\n\t\n\tfloat base;\n\t{\n\t\tfloat baseW = w*0.9 + w*0.1*wScale;\n\t\tfloat baseH = 0.1;//0.5 + 4.0 * (1.0-blockId);\n\t\tbase = sdBox( pos - vec3(0,baseH,0), vec3(baseW,baseH,baseW) );\n\t\tde = min(de,base);\n\t}\n\t\n\t//m.x += 1.0;\n\t/*\n\tm.x += clamp(1.0-smoothstep(0.0,de,bulk), 0.0, 1.0);\n\tm.y += clamp(1.0-smoothstep(0.0,de,bands), 0.0, 1.0);\n\tm.z += clamp(1.0-smoothstep(0.0,de,base), 0.0, 1.0);*/\n\t\n\t//if( base -de < 0.001 ) m.x += 1.0;\n\t//if( bands-de < 0.001 ) m.y += 1.0;\n\t//if( base -de < 0.001 ) m.z += 1.0;\n\t\n\tfloat alpha = clamp((bulk-bands)*100.0,0.0,1.0);\n\tm = mix( vec4(1,0,0,0), vec4(0,1,0,0), alpha );\n\talpha = clamp((base-bulk+2.0)*10000.0,0.0,1.0);\n\tm = mix( vec4(0,0,1,0), m, alpha );\n\t\n\t\n\t/*\n\tfloat dentHeight = 10.0;\n\tfloat dentDepth = 10.0 + 20.0 * (fract(blockId+0.7));\n\tpos.y -= dentHeight+2.0;\n\tfloat r = dentHeight + 1.0 + 20.0 * (fract(1.3-blockId*7.0));\n\tpos.y = mod(pos.y,r);//-0.5*r;\n\t\n\txz+=halfStreetWidth;\n\tfloat carve = sdBox(pos, vec3(xz,dentHeight,xz));\n\n\tcarve = 999999.0;\n*/\n\t//addLower = 999999.0;\n\t//addLower = min(addLower,bulk);\n\t//carveLower = min(carveLower,bulk);\n\t//addLower = 999999.9;\n\t\n\t//return smin( bulk, add, 1.0 );\n\treturn de;\n}\nfloat BlockId( vec2 pos )\n{\n\t//return 1.0;\n\treturn rand(floor(pos/totalBlock));\n}\n//close to the surface of a building\nfloat DeN( vec3 pos )\n{\n\tfloat blockId1 = BlockId(pos.xz);\n\tpos.x = mod(pos.x,totalBlock);\n\tpos.z = mod(pos.z,totalBlock);\n\tvec4 m = vec4(0);\n\treturn BlockDe(pos, blockId1, m);\n}\n//within city volume\nfloat DeWithin( vec3 pos, vec3 rd, out float maxStep, inout vec4 m )\n{\n\tfloat startBlockX = floor((pos.x)/totalBlock);\n\tfloat startBlockZ = floor((pos.z)/totalBlock);\n\tfloat xDir = rd.x > 0.0 ? 1.0 : -1.0;\n\tfloat zDir = rd.z > 0.0 ? 1.0 : -1.0;\n\tvec3 p1N = normalize(vec3(-1,0,0));\n\tvec3 p2N = normalize(vec3(0,0,-1));\n\tfloat p1Offs = rd.x > 0.0 ? (startBlockX+1.0)*totalBlock : (startBlockX)*totalBlock;\n\tfloat p2Offs = rd.z > 0.0 ? (startBlockZ+1.0)*totalBlock : (startBlockZ)*totalBlock;\n\tfloat e1 = -(dot(p1N,pos) + p1Offs) / (dot(p1N, rd));\n\tfloat e2 = -(dot(p2N,pos) + p2Offs) / (dot(p2N, rd));\n\tmaxStep = min(e1,e2);\n\t\n\tfloat blockId1 = BlockId(pos.xz);\n\tpos.x = mod(pos.x,totalBlock);\n\tpos.z = mod(pos.z,totalBlock);\n\treturn BlockDe(pos, blockId1, m);\n}\n//above city volume\nfloat DeAbove( vec3 pos, vec3 rd, out float maxStep, inout vec4 m )\n{\n\tfloat de;\n\tif( pos.y > maxBlockHeight+0.1 )\n\t{//if ray is above buildings, continue until you're at roof height\n\t\tde = (pos.y-maxBlockHeight) / (abs(rd.y));\n\t\tde = max(de, 0.1);\n\t}\n\telse\n\t{\n\t\treturn DeWithin(pos, rd, maxStep, m);\n\t\t//return DeN(pos);\n\t}\n\treturn maxStep=de;\n}\n\nvec3 N0=vec3(0.0001);\nvec3 N1=vec3(0.0001);\nvec3 N2=vec3(0.0001);\nvec3 N3=vec3(0.0001);\n\nvec4 hit0=vec4(0);\nvec4 hit1=vec4(0);\nvec4 hit2=vec4(0);\nvec4 hit3=vec4(0);\n\nvoid onHit(float de, vec3 p, float rCoC, inout float coverage, vec4 c, inout vec4 material)\n{\n\tvec2 v=vec2(0.5*rCoC,0.0);\n\tvec3 N=normalize(vec3(-DeN(p-v.xyy)+DeN(p+v.xyy),-DeN(p-v.yxy)+DeN(p+v.yxy),-DeN(p-v.yyx)+DeN(p+v.yyx)));\n\t\n\tfloat alpha=(1.0-coverage)*linstep(-rCoC,rCoC,-de);\n\t\n\tmaterial += c*alpha;\n\t//float lit = 1.0 * (dot(N,L)*0.5+0.5);\n\t//float lit = 1.0;\n\t\n\t//col += (N*0.5+0.5) * alpha;\n\t\n//\tcol += lit * vec3(0.5,.5,1.0) * (sin(p.y*0.5)*0.25+0.75) * alpha;\n//\tavgN += N*alpha;\n\tcoverage += alpha;\n\t\n\thit0 = alpha > hit0.w ? vec4(p,alpha) : hit0;\n\thit1 = alpha > hit1.w ? vec4(p,alpha) : hit1;\n\thit2 = alpha > hit2.w ? vec4(p,alpha) : hit2;\n\thit3 = alpha > hit3.w ? vec4(p,alpha) : hit3;\n\t\n\tN0 += N * alpha * c.x;\n\tN1 += N * alpha * c.y;\n\tN2 += N * alpha * c.z;\n\tN3 += N * alpha * c.w;\n}\n\nvec2 GetUv(vec3 N0, vec3 hit0)\n{\n\tN0 = abs(N0);\n\treturn N0.x > N0.y\n\t\t? (N0.z > N0.x ? hit0.xy : hit0.zy)\n\t\t: (N0.z > N0.y ? hit0.xy : hit0.xz);\n}\n\nfloat noise( in vec2 x )\n{\n\treturn sin(1.5*x.x)*sin(1.5*x.y);\n}\n\nfloat fbm4( vec2 p )\n{\n\tconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nfloat fbm6( vec2 p )\n{\n\tconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.015625*(0.5+0.5*noise( p ));\n    return f/0.96875;\n}\n\n\nvec3 DoLighting( vec3 pos, vec3 V, vec3 N, vec3 color, vec2 fragCoord )\n{\n\tfloat specular = 0.0;\n\tfloat diffuse = 0.0;\n\t\n\tvec3 ambientL = normalize(vec3(-1,2,1));\n\tvec3 ambientH = normalize(ambientL + V);\n\t\n\tvec3 L = ambientL;\n\tfloat shadow = 0.0;\n\tfloat t = 1.0;\n\t//pos += N*1.0;\n\tpos += V*1.0;\n\tfor(int i=1;i<SHADOW_ITERATIONS;i++){//march loop\n\t\t\n\t\tvec3 p = pos+L*t;\n\t\tfloat rCoC=CircleOfConfusion(t);\n\t\t\n\t\tfloat maxStep = 9999999.0;\n\t\tvec4 c = vec4(0);\n\t\tfloat de=DeWithin( p, L, maxStep, c );// +0.25*rCoC;\n\t\t\n\t\trCoC = (100.0 - 100.0/(t*0.02));\n\t\tif(de<rCoC){\n\t\t\tshadow += (1.0-sat(de/rCoC))*sat(45.0/t);\n\t\t}\n\t\t\n\t\t//de = de + 1.0*fract(de);// + t;//de;// * 2.0 + 5.0;\n\t\t//de = 15.0 + 15.0*rand(fragCoord.xy*vec2(i));\n\t\t//de = 15.0 + 15.0*fract(abs(pos.z*de+V.x));\n\t\tde = max( de * 2.0, 10.0 );\n\t\tde = min(de,maxStep);\n\t\tde += 1.0*rand(fragCoord.xy*vec2(i));\n\t\tt += de;\n\t}\n\tshadow = 1.0-sat(shadow)*0.55;\n\t\n\tdiffuse += (dot(N,ambientL)*0.5+0.5) * shadow;\n\tspecular += sat(dot(N,ambientL))* pow(sat(dot(N,ambientH)), 10.0) * shadow;\n\t\n\t//return vec3(shadow);\n\t\n\tfloat specMask = sat(1.0-dot(vec3(1./3.), color));\n\treturn diffuse * color + specular * specMask;\n}\n\nvec3 RoadTexture(vec3 pos)\n{\n\tfloat f = abs(sin(pos.x*10.0))*abs(sin(pos.z*12.0));\n\tvec3 road = mix(vec3(0.10,0.12,0.13), vec3(0.13,0.1,0.08), f);\n\t\n\tvec2 xz = abs(mod(pos.xz, totalBlock)-totalBlock*0.5)-blockWidth*0.5;\n\txz /= halfStreetWidth;\n\t\n\tconst float lineWidth = 0.1;\n\tconst float lnpcnt = 0.5*lineWidth/halfStreetWidth;\n\tvec3 paint = vec3(0.5,0.5,0.4);\n\tfloat lane;\n\t\n\troad = mix(road, paint, softstep(1.0-lnpcnt*5.0,xz.x) );\n\tlane = 3.0/halfStreetWidth;\n\troad = mix(road, paint, softstep2(1.0-lane-lnpcnt, 1.0-lane+lnpcnt, xz.x) );\n\tlane = 6.0/halfStreetWidth;\n\troad = mix(road, paint, softstep2(1.0-lane-lnpcnt, 1.0-lane+lnpcnt, xz.x) );\n\tlane = 9.0/halfStreetWidth;\n\troad = mix(road, paint, softstep2(1.0-lane-lnpcnt, 1.0-lane+lnpcnt, xz.x) );\n\tlane = 12.0/halfStreetWidth;\n\troad = mix(road, paint, softstep2(1.0-lane-lnpcnt*5.0, 1.0-lane+lnpcnt*5.0, xz.x) );\n\t\n\troad = mix(road, paint, softstep(1.0-lnpcnt*5.0,xz.y) );\n\tlane = 3.0/halfStreetWidth;\n\troad = mix(road, paint, softstep2(1.0-lane-lnpcnt, 1.0-lane+lnpcnt, xz.y) );\n\tlane = 6.0/halfStreetWidth;\n\troad = mix(road, paint, softstep2(1.0-lane-lnpcnt, 1.0-lane+lnpcnt, xz.y) );\n\tlane = 9.0/halfStreetWidth;\n\troad = mix(road, paint, softstep2(1.0-lane-lnpcnt, 1.0-lane+lnpcnt, xz.y) );\n\tlane = 12.0/halfStreetWidth;\n\troad = mix(road, paint, softstep2(1.0-lane-lnpcnt*5.0, 1.0-lane+lnpcnt*5.0, xz.y) );\n\treturn road;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime;\n#ifdef ORBIT_CAM\n\tvec3 ro = vec3(sin(time*0.5)*1000.0, 1000, cos(time*0.5)*1000.0);\n\tvec3 ta = vec3(0, (sin(time)*0.5+0.5)*200.0, 0);\n#else\n\tvec3 ro = vec3(pow(sin(time*0.5),3.0)*5.0+6.0, 1.4, time*100.0);\n\tvec3 ta = ro + vec3(sin(time*0.8)*3.0,(sin(time)*0.5+0.5)*2.0,10);\n#endif\n\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 1.0*cw );\n\t\n\tfloat distToGround = - (dot(vec3(0,1,0),ro) + 0.0) / (dot(vec3(0,1,0), rd));\n\tdistToGround = distToGround < 0.0 ? 999999.0 : distToGround;\n\t\n\tfloat coverage = 0.0;\n\tvec4 material = vec4(0.001, 0, 0, 0);\n\tvec3 col = vec3(0);\n\tvec4 c;\n\tfloat lastT = 0.0;\n\tfloat t=0.0;//distance traveled\n\t//float didHit = 0.0;\n\tfor(int i=0;i<ITERATIONS;i++){//march loop\n\t\tif( t >= distToGround || coverage > 0.99 ) continue;\n\t\t\n\t\tvec3 pos = ro+rd*t;\n\t\tfloat rCoC=CircleOfConfusion(t);\n\t\t\n\t\tfloat maxStep = 999999.0;\n\t\tc = vec4(0);\n\t\tfloat de=DeAbove( pos, rd, maxStep, c ) +0.25*rCoC;\n\t\t//float de=DeN( pos ) +0.25*rCoC;\n\t\t\n\t\tif(de<rCoC){\n\t\t\tonHit(de, pos, rCoC, coverage, c, material);\n\t\t}\n\t\t\n\t\tde=abs(de)*(0.5+0.5*rand(fragCoord.xy*vec2(i)));\n\t\tde = min(de, maxStep+halfStreetWidth);\n\t\t\n\t\tlastT = t;\n\t\tt += de;\n\t}\n\t\n\tt = min(t,abs(distToGround));\n\tvec3 pos = ro + rd*t;\n\t\n\tfloat bgAlpha = 1.0-coverage;\n\t\n//\t\tcol += vec3(0.5,.5,1.0) * (sin(pos.y*0.5)*0.25+0.75) * bgAlpha;\n\t\n\t//vec3 N = normalize(avgN);\n\tN0 = normalize(N0);\t\n\tN1 = normalize(N1);\t\n\tN2 = normalize(N2);\t\n\tN3 = normalize(N3);\n\t\n\tvec3 _mtl0 = vec3(0.34, 0.40, 0.24);\n\tvec3 _mtl1 = vec3(0.38, 0.54, 0.51);\n\tvec3 _mtl2 = vec3(0.38, 0.40, 0.61);\n\tvec3 _mtl3 = vec3(0.03, 0.42, 0.64);\n\t/*vec3 mtl0 = vec3(1, 0, 0);\n\tvec3 mtl1 = vec3(0, 1, 0);\n\tvec3 mtl2 = vec3(0, 0, 1);\n\tvec3 mtl3 = vec3(0, 0, 0);*/\n\t\n\tfloat id = BlockId(pos.xz);\n\t\n\tvec3 mtl0 = mix(_mtl0, _mtl1, fract(id*2.0));\n\t     mtl0 = mix( mtl0, _mtl3, fract(id*2.0+1.0));\n\tvec3 mtl1 = mix(_mtl1, _mtl2, fract(id*4.0+0.4));\n\t     mtl1 = mix( mtl1, _mtl0, fract(id*1.0+0.3));\n\tvec3 mtl2 = mix(_mtl2, _mtl3, fract(id*2.0+0.7));\n\t     mtl2 = mix( mtl2,  mtl1, fract(id*0.1+0.7));\n\tvec3 mtl3 = mix(_mtl3, _mtl0, fract(id*8.0+0.6));\n\t     mtl3 = mix( mtl3, _mtl1, fract(id*0.5+0.6));\n\t\n\tif( pos.y < 0.01 )\n\t{\n\t\tmtl3 = RoadTexture(pos) * bgAlpha;\n\t\tmaterial = vec4(0,0,0,1);\n\t\tN3 = vec3(0,1,0);\n\t\tcoverage = 1.0;\n\t}\n//\telse if( rd.y > 0.0 && t > 1000.0 )\n//\telse if( rd.y > 0.0 && pos.y >= maxBlockHeight-1.1 )\n\telse if( pos.y >= maxBlockHeight-10.1 )\n\t{\n\t\tvec3 sky = mix( vec3(.17, .13, .3), vec3(.1, .13, .47), rd.y );\n\t\tcol += sky * bgAlpha;\n\t}\n\telse\n\t{\n\t\tvec3 pos = ro+rd*t;\n\t\tfloat rCoC=CircleOfConfusion(t);\n\t\tonHit(0.0, pos, rCoC, coverage, c, material);\n\t}\n\t\n\thit0.xyz = pos;\n\thit1.xyz = pos;\n\thit2.xyz = pos;\n\thit3.xyz = pos;\n\t\n\t//vec3 u = cross(N0, vec3(0,0,1));\n\t//vec3 v = cross(N0, u);\n\t//vec2 uv0 = vec2( dot(hit0.xyz,u), dot(hit0.xyz,v) );\n\t\t\t\n\tvec2 uv0 = GetUv(N0, hit0.xyz);\n\tvec2 uv1 = GetUv(N1, hit1.xyz);\n\tvec2 uv2 = GetUv(N2, hit2.xyz);\n\tvec2 uv3 = GetUv(N3, hit3.xyz);\n\t//mtl0 = vec3( fract(uv0*0.1), 0 );\n\t//mtl0 = v*0.5+0.5;\n\t//mtl0 = fract(hit0.xyz*0.1);\n//\tmtl0 = texture(iChannel0, uv0*0.1).rgb;\n//\tmtl1 = texture(iChannel1, uv1*0.1).rgb;\n//\tmtl2 = texture(iChannel2, uv2*0.1).rgb;\n//\tmtl3 = texture(iChannel3, uv3*0.1).rgb;\n\t\n\t//uv0.x *= fbm4(uv0.xy*0.01);\n\tmtl0 *= (fbm4(uv0*0.041)*0.25+0.75) * vec3(1);\n\tmtl1 *= (fbm4(uv1*0.031)*0.25+0.75) * vec3(1);\n\tmtl2 *= (fbm4(uv2*0.011)*0.25+0.75) * vec3(1);\n\tmtl3 *= (fbm4(uv3*0.021)*0.25+0.75) * vec3(1);\n\t\n\tmaterial /= dot(vec4(1),material);\n\tmaterial *= coverage;\n\t\n\tvec3 V = -normalize(pos - ro);\n\t\n\tcol.rgb += DoLighting( pos, V, N0, mtl0, fragCoord ) * material.x;\n\tcol.rgb += DoLighting( pos, V, N1, mtl1, fragCoord ) * material.y;\n\tcol.rgb += DoLighting( pos, V, N2, mtl2, fragCoord ) * material.z;\n\tcol.rgb += DoLighting( pos, V, N3, mtl3 , fragCoord) * material.w;\n\n\t//col = col * (dot(N,L)*0.5+0.5);\n//\tcol = mix( col, vec3(1,0,0), coverage>0.0?0.0:1.0 );\n\tfragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xdj3WV","date":"1393660233","viewed":1440,"name":"future city","username":"Hodgman","description":"Learning how to ray-march against a city grid for the #cyberpunkjam.\n\nThanks IQ, Eiffie and the rest of the community for the learning material.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["cyberpunk"],"hasliked":0,"parentid":"","parentname":""}}