{"ver":"0.1","info":{"id":"NlKBWt","date":"1665456998","viewed":100,"name":"10.10.2022:Decryption","username":"g___r___e___g","description":"Requires Hacking II or the Cryptography CyberMod.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fragtober"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU 6.2832\n\n// blackle noise\n#define FK(k) floatBitsToUint(cos(k)) ^ floatBitsToUint(k)\nfloat hash(vec2 p) {\n  uint x = FK(p.x), y = FK(p.y);\n  return float((x-y*y)*(y+x*x)-x)/4.28e9;\n}\n\nvec2 rotate(vec2 p, float a) {\n  float s = sin(a), c = cos(a);\n  return mat2(c, -s, s, c) * p;\n}\n\nfloat stepLinear(float s, float e, float t) {\n  return clamp((t-s)/(e-s), 0., 1.);\n}\n\nfloat stepReverse(float t) {\n  return stepLinear(0., 0.5, t) - stepLinear(0.5, 1., t);\n}\n\nfloat easeInOutExpo(float t, float e) {\n    if (t == 0.0 || t == 1.0) {\n        return t;\n    }\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * pow(e, 10.0 * (t - 1.0));\n    } else {\n        return 0.5 * (-pow(e, -10.0 * (t - 1.0)) + 2.0);\n    }\n}\n\nfloat sdTabbedDisc(vec2 p, float r) {\n  float sf = 1. / min(iResolution.x, iResolution.y);\n  float a = (atan(p.y, p.x) + TAU * .5) / TAU;\n  a *= 3.;\n  float b = 3. * fract(a);\n  float rOuter = 0.15 * r;\n  float blend = 0.13;\n  float transition = \n      smoothstep(1. - blend, 1. + blend, b)\n    * smoothstep(2. + blend, 2. - blend, b);\n  r += rOuter * transition;\n\n  float d = length(p) - r;\n  d = abs(d);\n  float r2 = 0.0075 / .3 * r;\n  d = smoothstep(r2 + sf, r2 - sf, d);\n\n  return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float sf = 1. / min(iResolution.x, iResolution.y);\n  vec2 uv = sf * (fragCoord - .5 * iResolution.xy);\n  vec3 color = vec3(0);\n\n  float t = iTime * 0.1;\n  vec3 blue = vec3(.2,.3, .9);\n\n  float r = 0.4;\n  for (float i = 1.; i < 5.; i++) {\n    float dir = 2. * step(.5, hash(vec2(i, floor(fract(t) * 6.)))) - 1.;\n    float spinH = hash(vec2(i, floor(t)));\n    float spinStep = hash(vec2(i, spinH)) * 0.75;\n    float spinT = fract(t * 1.);\n    spinT = stepLinear(spinStep, spinStep + .25, spinT);\n    float spin = TAU * 2./3. * easeInOutExpo(spinT, 1. + 4. * spinH);\n    vec2 p = rotate(uv, i * TAU/18. + TAU * t * dir + spin);\n    float d = sdTabbedDisc(p, r);\n    color = mix(color, blue, d);\n    float zoomT = fract(iTime * 0.25);\n    zoomT = stepReverse(zoomT);\n    zoomT = stepLinear(0.25, 0.9, zoomT);\n    zoomT = easeInOutExpo(zoomT, 2.);\n    r *= 0.45 + 0.3 * zoomT;\n    blue = mix(blue, vec3(.3, .7, .8), 0.4 * ((1. - zoomT) * 0.7 + 0.3));\n  }\n\n  fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}