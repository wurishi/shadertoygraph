{"ver":"0.1","info":{"id":"XlcSzM","date":"1481092343","viewed":8546,"name":"Matroshka!","username":"BigWIngs","description":"Put fullscreen and see if you can find the easter egg ;) Please see comment block for details. ","likes":149,"published":1,"flags":64,"usePreview":0,"tags":["raymarching","russian","matroshka","doll"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Md2GWR","filepath":"https://soundcloud.com/officialskorge/skorge-tetris-theme","previewfilepath":"https://soundcloud.com/officialskorge/skorge-tetris-theme","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Matroshka! - 2016 Martijn Steinrucken - BigWings\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// This effect matches the music. In order for it to be in sync, its best to restart\n// the effect as soon as the music loads.\n//\n// Use the mouse to look around. Watch at least 30 seconds to see the whole effect!\n// \n// I tried to create a painted look. To make the flowers and leaves move use the PSYCO define.\n// A video of the effect can be found here:\n// https://www.youtube.com/watch?v=0kbZzVolycw\n\n// Because dolls are different sizes and they are leaning when they walk, \n// it can happen that we overstep into the next cell, causing gaps in the doll.\n// This is why, in the marching loop, I make sure to always start a new cell at the cell boundary.\n// Another way to fix this is to make the step size 0.6 x the doll distance but that obviously \n// makes the ray marching slower. I'm not sure which solution is faster because im at a steady\n// 60fps for both solutions on my machine. \n// Some better performance metrics would really help!\n//\n// I sunk way too much time into this, time to move on to something else! I hope you like it!\n//\n// SONG: Skorge - Tetris Theme\n// https://soundcloud.com/officialskorge/skorge-tetris-theme\n\n// Use these to change the effect\n\n\n//#define PSYCO\n//#define TEXTUREMODE\n#define INVERTMOUSE 1.\n#define MAX_STEPS 150\n#define MIN_DISTANCE 0.1\n#define MAX_DISTANCE 100.\n#define RAY_PRECISION 0.002\n\n#define S(x,y,z) smoothstep(x,y,z)\n#define B(x,y,z,w) S(x-z, x+z, w)*S(y+z, y-z, w)\n#define sat(x) clamp(x,0.,1.)\n#define SIN(x) (sin(x)*.5+.5)\n#define COS(x) (cos(x)*.5+.5)\n\nfloat X2(float x) { return x*x; }\n\nvec3 mainCol = vec3(1.0, .2, .1);\t\t// the main color\nvec3 lastCol = vec3(.1,.3, .1);\t\t\t// the last main color\nvec3 secCol = vec3(.8, .6, .1);\t\t\t// the secondary color\nvec3 lineCol = vec3(1.1);\t\t\t\t// the line color\n\nvec3 grid = vec3(5., 10., 5.);\t\t\t// grid of marching dolls\nvec4 stones = vec4(.2, .3, .5, 2.);\t\t// controls size and shape of stones\n\nfloat SOLO;\t\t\t\t\t\t\t\t// wether we are in solo mode or not\t\n\nconst vec3 light = vec3(1., 1., 1.)*.577; \nconst vec3 lf=vec3(1., 0., 0.);\nconst vec3 up=vec3(0., 1., 0.);\nconst vec3 fw=vec3(0., 0., 1.);\nconst float pi2 = 1.570796326794896619;\nconst float pi = 3.141592653589793238;\nconst float twopi = 6.283185307179586;\n\nvec2 mouse;\nvec3 bg; // global background color\n\nfloat time;\n\nfloat remap01(float a, float b, float t) {return (t-a)/(b-a);}\nfloat L2(vec3 p) {return dot(p, p);}\nfloat L2(vec2 p) {return dot(p, p);}\n\nfloat N1( float x ) { return fract(sin(x)*5346.1764); }\nfloat N2(vec2 p)\n{\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat N2(float x, float y) { return N2(vec2(x, y)); }\n\nvec3 N31(float p)\t\t\n{\t\n   vec3 p3 = fract(vec3(p) * vec3(443.897, 441.423, 437.195));\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 N21(float p)\n{\n\tvec2 p2 = fract(vec2(p) * vec2(443.897, 441.423));\n\tp2 += dot(p2, p2.yx + 19.19);\n    return fract((p2.xx+p2.yx)*p2.yy);\n\n}\n\nfloat Noise(vec2 uv) {\n    // noise function I came up with\n    // ... doesn't look exactly the same as what i've seen elswhere\n    // .. seems to work though :)\n    vec2 id = floor(uv);\n    vec2 m = fract(uv);\n    m = 3.*m*m - 2.*m*m*m;\n    \n    float top = mix(N2(id.x, id.y), N2(id.x+1., id.y), m.x);\n    float bot = mix(N2(id.x, id.y+1.), N2(id.x+1., id.y+1.), m.x);\n    \n    return mix(top, bot, m.y);\n}\n\nfloat NoiseTex(vec2 uv, float seed, float octaves) {\n    float v=0.;\n    uv += N21(seed);\n    \n    for(float i=1.; i<=11.; i++) {\n    \tv += Noise(uv)/i;\n        uv *= 2.;\n        \n        if(i>octaves) break;\n    }\n    \n    return v*.5;\n}\n\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n};\n\nstruct camera {\n    vec3 p;\t\t\t// the position of the camera\n    vec3 forward;\t// the camera forward vector\n    vec3 left;\t\t// the camera left vector\n    vec3 up;\t\t// the camera up vector\n\t\n    vec3 center;\t// the center of the screen, in world coords\n    vec3 i;\t\t\t// where the current ray intersects the screen, in world coords\n    ray ray;\t\t// the current ray: from cam pos, through current uv projected on screen\n    vec3 lookAt;\t// the lookat point\n    float zoom;\t\t// the zoom factor\n};\ncamera cam;\n\n\nvoid CameraSetup(vec2 uv, vec3 position, vec3 lookAt, float zoom) {\n    cam.p = position;\n    cam.lookAt = lookAt;\n    cam.forward = normalize(cam.lookAt-cam.p);\n    cam.left = cross(up, cam.forward);\n    cam.up = cross(cam.forward, cam.left);\n    cam.zoom = zoom;\n    cam.center = cam.p+cam.forward*cam.zoom;\n    cam.i = cam.center+cam.left*uv.x+cam.up*uv.y;\n    cam.ray.o = cam.p;\t\t\t\t\t\t// ray origin = camera position\n    cam.ray.d = normalize(cam.i-cam.p);\t// ray direction is the vector from the cam pos through the point on the imaginary screen\n}\n\n\n// DE functions from IQ\n// https://www.shadertoy.com/view/Xds3zN\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, vec3 pos, float s ) { return length(p-pos)-s; }\n\nfloat sSph( vec3 p, vec3 scale, float s )\n{\n    return (length(p/scale)-s)*min(scale.x, min(scale.y, scale.z));\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nmat3 RotY(float angle) {\n\tfloat s = sin(angle);\n    float c = cos(angle);\n    \n    return mat3(c, 0., s,  0., 1., 0.,  -s, 0., c);\n}\n\n\nmat3 RotZ(float angle) {\n\tfloat s = sin(angle);\n    float c = cos(angle);    \n    \n    return mat3(c, -s, 0.,  s, c, 0.,  0., 0., 1.);\n}\n\nstruct de {\n    // data type used to pass the various bits of information used to shade a de object\n\tfloat d;\t// distance to the object\n   \tvec4 p;\t\t// local coordinate pos (xyz)\n    float m; \t// material\n    vec2 uv;\t// uv coordinates\n    vec3 id;\n    \n    float t; // transition between inside and outside\n    float open; \t// how far open the split matroshkas are\n    float inside;\t// wether its the inside matroshka. This whole struct is a mess... oww well\n    float seed;\t// seed used to generate random values\n    \n    \n    // shading parameters\n    vec3 pos;\t\t// the world-space coordinate of the fragment\n    vec3 nor;\t\t// the world-space normal of the fragment\n    vec3 rd;\t\t// the world-space view dir of the fragment\n    float fresnel;\t\n};\n    \nstruct rc {\n    // data type used to handle a repeated coordinate\n\tvec3 id;\t// holds the floor'ed coordinate of each cell. Used to identify the cell.\n    vec3 h;\t\t// half of the size of the cell\n    vec3 p;\t\t// the repeated coordinate\n};\n    \nrc Repeat(vec3 pos, vec3 size) {\n\trc o;\n    o.h = size*.5;\t\t\t\t\t\n    o.id = floor(pos/size);\t\t\t// used to give a unique id to each cell\n    o.p = mod(pos, size)-o.h;\n    return o;\n}\n\n\nvec2 PolarCoords(vec2 uv) {\n\t// carthesian coords in polar coords out\n    return vec2(atan(uv.x, uv.y), length(uv));\n}\n\nvec2 SpiralCoords(vec2 st, float turns) {\n\t// polar coords in... spiral coords out. Spiral coordinates are neat!\n    st.x = st.x/twopi +.5;\n    st.y *= turns;\n    float s = st.y+st.x;\n    float l = (floor(s)-st.x);\n    float d = fract(s);\n    return vec2(l, d);\n}\n\n\nfloat circ(vec2 uv, float x, float y, float aspect, float radius, float edge) {\n\tvec2 p = uv-vec2(x, y);\n    p.x *= aspect;\n    \n    edge *= .02;\n    radius *= radius;\t\t\t\t\t\t\t\t// comparing to r^2 to avoid sqrt\n    return S(radius+edge, radius-edge, dot(p, p));\t// not sure if thats actually faster\n}\n\nfloat circ(inout vec4 base, vec2 uv, float x, float y, float aspect, float radius, float edge, vec3 col) {\n    float alpha = circ(uv, x, y, aspect, radius, edge);\n    base = mix(base, vec4(col, 1.), alpha);\n    return alpha;\n}\n\nfloat square(vec2 uv, vec4 rect, float blur) {\n\t// returns 1 when uv is inside the square, 0 otherwise\n    return B(rect.x, rect.z, blur, uv.x) * B(rect.y, rect.w, blur, uv.y);\n}\n\nvec2 within(vec2 uv, vec4 rect) {\n\t// converts a uv from a global coordinate to a rect coordinate\n    return (uv.xy-rect.xy)/(rect.zw-rect.xy);\n}\n\nfloat TowerMask(vec2 uv, float blur) {\n    uv.x = abs(uv.x-.5);\n    \n    float y = uv.y * 2.5;\n    \n    float c = exp(-y*y)*pow(sat(y), .6)*.8;\n    c = S(c, c-blur, uv.x);\n    \n    float width = mix(.15, .35, S(-.3, -.6, uv.y));\n    float tower = width+uv.y*uv.y*.05;\n    \n    tower = S(tower+.01+blur, tower, uv.x);\n    tower *= S(0.5, 0.2, uv.y);\n    \n    c = max(c, tower);\n    return c;\n}\n\nfloat Kremlin(vec2 uv) {\n    float c = TowerMask(within(uv, vec4(0.35, 0.7,.63,1.1)), .1);\n    c += TowerMask(within(uv, vec4(0.15, 0.5,.43,.8)), .1);\n    c += TowerMask(within(uv, vec4(0.65, 0.5,.83,.8)), .1);\n    c += TowerMask(within(uv, vec4(0.525, 0.3,.72,.8)), .1);\n    c += TowerMask(within(uv, vec4(0.025, 0.25,.22,.6)), .1);\n    c += TowerMask(within(uv, vec4(0.8, 0.25,.95,.5)), .15);\n    c = sat(c);\n    c *= S(.0, .4, uv.y);\n    return c;\n}\n\nvec3 background(vec3 r, vec2 uv, float starBurst) {\n    float u = dot(r, up)*.5+.5;\n    vec3 upCol = vec3(1., .4, .1);\n    vec3 col;\n    \n    float t = iTime*4.;\t\t\t\n    \n    if(SOLO>.5){\t\t\t\t\t\t\t\t\t\t// splitting shells\t\n        float colFade = S(.0, .1, fract(time));\n        upCol = mix(lastCol, mainCol, colFade)*2.5;\t\t// make the background match the doll color\n    \tcol = mix(upCol*.05, upCol, u);\n        \n    \tvec2 st = PolarCoords(uv);\n        \n        starBurst *= sat(sin(st.x*3.+t)) + sat(sin(st.x*4.+t*.7654));\t// add starburst \n        col += starBurst*.5*B(.3, .7, .2, u);\n        \n        col *= col;\n    } else {\t\t\t\t\t\t\t\t\t\t\t// marching bg\n        float x = atan(r.x, r.z);\t\t\t\t\t\t// from -pi to pi\t\n\t\tfloat y = pi*0.5-acos(r.y);  \t\t\t\t\t// from -1/2pi to 1/2pi\t\t\n        \n        col = upCol*u*2.;\n        float a = sin(r.x);\n    \n        float beam = sat(sin(10.*x+a*y*5.+t));\t\t\t// add light beams\n        beam *= sat(sin(7.*x+a*y*3.5-t));\n        float beam2 = sat(sin(42.*x+a*y*21.-t));\n        beam2 *= sat(sin(34.*x+a*y*17.+t));\n        beam += beam2;\n        col *= 1.+beam*.1;\n        \n        col += dot(r, fw);\t\t\t\t\t\t\t\t// light gradient from front\n        \n        vec4 r = vec4(-.3, .0, .3, .4);\t\t\t\t\t// add kremlin!\n        if(x>r.x && x<r.z && y>r.y && y<r.w) {\n            col *= 1.-Kremlin(within(vec2(x, y), r))*.3;\n        }\n    }\n    return col;\n}\n\nvec4 Eyes(vec2 uv, float seed) {\n    \n    if(uv.x<.5) {\t\t\t\t\t\t\t\t// add seductive wink ;)\n    \tfloat a = pow(SIN(time*2.), 700.)*4.;\n    \tuv.y = (uv.y-.5)*(1.+a) + .5;\n    }\n    \n    vec3 n = N31(seed+675.75864);\n    vec3 green = vec3(.2, .6, .1);\n    vec3 blue = vec3(.3, .3, .9);\n    vec3 eyeCol = mix(green, blue, n.x)*(.7+n.y);\n    vec4 eyes = vec4(0.);\n    float ar = 2.3;\n    float blur = .5;\n    float size = .2;\n    \n    vec2 lp = vec2(.35, .5);\n    vec2 rp = vec2(.65, .5);\n    \n    vec2 glint = vec2(.05);\n    vec2 pupil = SOLO*(mouse-.5)*vec2(-.3, .3); \t\t// make her looking at you (SOLO mode only)\n    \n    float eyeMask = circ( eyes, uv, lp.x, lp.y, ar, size, blur, eyeCol);\n\teyeMask += circ( eyes, uv, rp.x, rp.y, ar, size, blur, eyeCol);\n    \n    circ(eyes, uv, lp.x+pupil.x, lp.y-pupil.y, ar, size*.6, blur, vec3(.1)); //pupil\n    circ(eyes, uv, lp.x-glint.x, lp.y+glint.y, ar, size*.5, blur*.5, vec3(1.)); //glint\n    \n    circ(eyes, uv, rp.x+pupil.x, rp.y-pupil.y, ar, size*.6, blur, vec3(.1)); //pupil\n    circ(eyes, uv, rp.x-glint.x, rp.y+glint.y, ar, size*.5, blur*.5, vec3(1.)); //glint\n    \n    eyes.a = eyeMask;\n    \n    vec2 uv2 = vec2(.5-abs(uv.x-.5), uv.y);\n    \n    float eyeLine = circ(uv2, lp.x-.02, lp.y+.05, ar*.8, size*1.05, blur);\n    eyeLine -= circ(uv2, lp.x-.02, lp.y-.03, ar*.8, size*1.05, blur);\n    eyeLine = sat(eyeLine);\n    eyes = mix(eyes, vec4(0.,0.,0.,1.), eyeLine);\n   \n    vec2 lash = vec2(lp.x-.15, lp.y+.27);\n    float eyeLash = circ(uv2, lash.x, lash.y, ar, size, blur);\n    eyeLash -= circ(uv2, lash.x+.005, lash.y+.05, ar, size, blur);\n    eyeLash = sat(eyeLash);\n    eyes = mix(eyes, vec4(0.,0.,0.,1.), eyeLash);\n    \n    lash += vec2(.1, .1);\n    ar =3.;\n    eyeLash = circ(uv2, lash.x, lash.y, ar, size, blur);\n    eyeLash -= circ(uv2, lash.x+.005, lash.y+.05, ar, size, blur);\n    eyeLash = sat(eyeLash);\n    eyes = mix(eyes, vec4(0.,0.,0.,1.), eyeLash);\n    \n    return eyes;\n}\n\nvec4 Mouth(vec2 uv, float seed) {\n\t\n    float smile = .3;//sin(iTime)*.5;;\n    \n    vec4 lipUpCol = vec4(1., .1, .1, 1.);\n    vec4 insideCol =  vec4(1., 1., 1., 1.);\n    \n    uv.y -= .5;\n    uv.x = abs(uv.x*2.-1.);\t// mirror in the middle\n    \n    uv *= 1.5;\n    \n    float upMid = .5-pow((uv.x-.25)*2., 2.);\n    float upSide = pow(1.-uv.x, .5)*.25;\n    float upper = smax(upMid, upSide, .2);\n    \n    float lowMid = uv.x*uv.x-.5;\n    float lowSide = sqrt(1.-uv.x)/-5.;\n    \n    float lower = smin(lowMid, lowSide, .2);\n    \n    float curve = uv.x*uv.x*smile;\n    \n    vec4 col = lipUpCol*B(lower+curve, upper+curve,.05, uv.y);\n    col = mix(col, insideCol, circ(uv, 0., curve, .2, .1, .1));\n    \n    return col;\n}\n\nvec4 Hair(vec2 uv, float seed) {\n    vec3 n = N31(seed - 845.32);\n    vec3 hair1Col = vec3(.4, .25, .15);\n    vec3 blond = vec3(1.8, 1.7, .2);\n    vec3 brunette = vec3(.8, .5, .3);\n    \n    vec3 hair2Col = mix(blond, brunette, n.x);\n    hair1Col = hair2Col *.5;\n    \n\tvec4 col = vec4(0.);\n    \n    if(n.y>.5) {\t\t\t\t\t\t\t\t\t\t\t// hair style 1\n        circ(col, uv, .8, .55, 3.5, .6, .5, hair1Col);\n        circ(col, uv, .8, .6, 3.5, .54, .5, hair2Col);\n\n        circ(col, uv, .55, .6, 3.5, .6, .5, hair1Col);\n        circ(col, uv, .55, .63, 3.5, .54, .5, hair2Col);\n\n        circ(col, uv, .4, .6, 3.5, .6, .5, hair1Col);\n        circ(col, uv, .41, .63, 3.3, .54, .5, hair2Col);\n\n        circ(col, uv, .25, .5, 3.5, .6, .5, hair1Col);\n        circ(col, uv, .26, .53, 3.3, .54, .5, hair2Col);\n    } else {\t\t\t\t\t\t\t\t\t\t\t\t// hair style 2\n        uv.x = abs(uv.x-.5);\n        float spread = n.y*2.*.09;\n        float d = length((uv-vec2(.2+spread, .9))*vec2(3., 1.));\n\n        col.rgb = hair1Col*(1.+sin(d*20.)*.5*n.z);\n        col.a=S(.9, .85, d);\n    }\n    \n    return col;\n}\n\nvec4 Face(vec2 uv, float seed) {\n    vec3 scarfCol = vec3(1., .9, .5);\n    vec3 faceCol = vec3(1., 1., .8);\n    vec3 lineCol = vec3(.1);\n   \n    vec4 col = vec4(0.);\n    \n    vec2 st = PolarCoords(uv-.5);\n    scarfCol += sin(st.x*5.)*.1;\n    circ(col, uv, .5, .5, 1.4, .5, .5, scarfCol); // scarf\n    float face = circ(col, uv, .5, .45, 1.3, .4, .04, faceCol);\t// face\n\n    vec2 uv2 = uv;\n    uv2.x = abs(uv.x-.5)+.5;\n\n    circ(col, uv2, .65, .27, 1.3, .06, .3, vec3(1., .7, .7)); //rouge\n    circ(col, uv2, .52, .29, 2., .02, .005, vec3(.1));\t\t// nostrils\n\n    vec4 eyeArea = vec4(.2, .31, .8, .55);\n    if(square(uv, eyeArea, .01)>0.) {\n        vec4 eyes = Eyes(within(uv, eyeArea), seed);\n        col = mix(col, eyes, eyes.a);\n    }\n\n    float eyeBrows = circ(uv2, .6, eyeArea.w-.03, .7, .06, .01); \n    eyeBrows -= circ(uv2, .6, eyeArea.w-.05, .7, .06, .01); \n    eyeBrows = sat(eyeBrows);\n    col = mix(col, vec4(lineCol, 1.), eyeBrows);\n\n    vec4 hairArea = vec4(.1, .6, .9, .9);\n    vec4 hair = Hair(within(uv, hairArea), seed); \n    hair.rgb *= .5;\n    col = mix(col, hair, hair.a*face);\n    \n    vec4 mouthArea = vec4(.35, .05, .65, .25);\n    float mouthMask = square(uv, mouthArea, .01);\n    if(mouthMask>0.) {\n    \tvec4 mouth = Mouth(within(uv, mouthArea), seed);\n    \tcol = mix(col, mouth, mouth.a);\n    }\n    \n    return col;\n}\n\nvec4 Scarf(vec2 uv, float seed) {\n    vec4 lCol = vec4(lineCol, 1.);\n    vec4 scarfCol = vec4(secCol, 1.);\n    \n    float lineThickness = .01;    \n    float x = uv.x*twopi;\n\tfloat scarfY = .25+COS(x)*-.15;\n    float scarfMask = S(scarfY, scarfY+.01, uv.y);\n    \n    scarfY -= lineThickness;\n    float lineMask = S(scarfY, scarfY+.01, uv.y);\n    vec4 col = mix(lCol*lineMask, scarfCol, scarfMask);\n    \n    float y;\n    \n    if(uv.y>scarfY && uv.y<scarfY+.2) {\t\t// scarf band\n        y = scarfY+.1;\n    \tcol = mix(col, lCol, B(y, .01+y, .005, uv.y));\n   \t\tx *= 10.;\n        \n        y = scarfY+.05+sin(x)*.04;\n        col = mix(col, lCol, B(y, .01+y, .01, uv.y));\n\n\t\tfloat d = length(vec2(fract(x/pi), (uv.y-scarfY)*10.)-vec2(.5, .6-sin(x)*.1));\n        col = mix(col, vec4(1.), S(.2, .14, d));\n    }\n    \n    vec2 mirrorUV = abs(uv-vec2(.5, -0.03));\n    vec2 st = PolarCoords(mirrorUV*vec2(2.2, 1.) - vec2(.32, .5));\n    vec2 sc;\n    if(st.y<.21) {\t\t\t\t\t\t// add spiral decoration on the side of the head...\n        st.y *= 2.2;\n        st.x += .4;\n    \tsc = SpiralCoords(st, 5.);\n    \tcol = mix(col, lCol, B(.3, .5, .05, sc.y)*S(1.15, 1., sc.x));\n    }\n    \n    st = PolarCoords(mirrorUV*vec2(2.2, 1.) - vec2(.532, .385));\n    if(st.y<.11) {\t\t\t\t\t\t// quite cumbersome.. there must be an easier way...\n        st.y *= 3.;\n        st.x += 3.4;\n        sc = SpiralCoords(st, 5.);\n    \tcol = mix(col, lCol, B(.3, .5, .05, sc.y)*S(1.2, 1.05, sc.x));\n    }\n    uv.x -= .5;\n    \n    vec2 tiePos = vec2(0., .3);\n    vec2 uv2 = uv - tiePos;\n    st = vec2(atan(uv2.x*3., uv2.y-.05), length(uv2));\n    \n    y = COS(st.x*4.+pi);\n    y = min(y, COS(st.x*4.+pi+.5));\n    \n    \n    float creases = mix(SIN(st.x*16.+pi), 1., sat(st.y*7.));\n    creases = S(.9, .1, creases);\n    y*=.2;\n    \n    col = mix(col, lCol, S(.02+y, .01+y, st.y));\n    col = mix(col, vec4(scarfCol.rgb, 1.), S(.005+y, .0+y, st.y));\n    col = mix(col, lCol, creases);\n    \n    circ(col, uv, tiePos.x, tiePos.y, 4., .1, .05, lineCol.rgb);\n    circ(col, uv, tiePos.x, tiePos.y, 4., .085, .05, scarfCol.rgb); \n    \n    return col;\n}\n\nfloat PointFlower(vec2 st, float numPoints, float base, float pointiness) {\n\tst.y *= 4.;\n    float x = st.x*numPoints;\n    float y = pointiness*(abs(cos(x))+(.25-abs(cos(x+pi2)))*2.)/(2.+abs(cos(x*2.+pi2))*8.)-base;\n    return st.y+y;\n}\n\nvec4 Flower(vec2 uv, vec4 pf, vec4 baseCol, vec4 lineCol) {\n    vec2 st = PolarCoords(uv-.5);\n    \n    #ifdef PSYCO\n    st.x += sin(st.y*10.)*sin(iTime);\n    #else\n    st.x += sin(st.y*10.)*.2;\n    #endif\n    \n    float dist = PointFlower(st, pf.x, pf.y, pf.z);//3., .4, .4);\n    float alpha = S(.5, .4, dist);\n    \n    baseCol.rgb *= S(.0, .15, st.y);\n    vec4 col = baseCol*alpha;\n    \n    float edge = S(.2, .5, dist)*alpha;\n    col = mix(col, lineCol, edge);\t\t\t// dark painted edge\n   \n    float highlight = SIN(st.x*pf.w);\n    highlight *= B(.0, .3, .1, dist);\n    highlight *= SIN(st.x);\n    col = mix(col, vec4(1.), highlight);\t\t\t// highlight\n        \n    col = mix(col, vec4(1.), S(.06, .05, st.y));  \n    \n    return col;\n}\n\nvec4 Leaf(vec2 uv, float stemHeight, float sweep ) {\n    // uv is in 0-1 range\n    \n    uv.y += sweep*uv.x*uv.x;\n    vec2 uv2 = (uv-vec2(.22, .5)) * vec2(4., 3.); \n    \n    float side = sign(uv2.y);\n    float ay = abs(uv2.y);\n    \n    float start = sqrt(uv2.x);\n    float end = 1.-pow(uv2.x/3., 2.);\n    float y = smin(start, end, 0.4);\n    \n    float offs = pow(abs(ay-mix(.75, -.0, uv2.x))*4., 2.);\n    float veins = sin(uv2.x*30.-offs+side);\n    \n    y *= 1.+veins*.07;\n    \n    float s = S(y+.04, y, ay);\n    vec4 leafCol = vec4(.2, .5, .1, s);\n    \n    s *= 1.+veins*.2*B(.3, 2.4, .3, uv2.x)*S(.02, .3, ay);\n    s *= mix(.2, 1., ay);\n    \n    leafCol.rgb = (leafCol.rgb+S(-.2, .2, uv2.y)*.35)*s;\n    \n    s = S(.0, .23, uv.x);\n    float h = mix(stemHeight, .5, s);\n    float t = mix(.02, .01, s);\n    t *= S(.5, .15, uv.x);\n    t *= S(.15, .4, uv.x);\n    float stemMask = B(h-t, h+t, .01, uv.y);\n    stemMask *= S(.95, .23, uv.x);\n    leafCol = mix(leafCol, vec4(.2,.5,.1,1.), stemMask);\n    \n    return leafCol;\n}\n\nvec4 RoseTex(vec2 uv, vec3 n) {\n    vec4 flowerCol = vec4(n*n, 1.);\t\t\t\t\t\t// flower col is just a more saturated version of main col\n  \tvec4 lCol = vec4(lineCol, 1.);\n    \n    vec2 uv2 = uv;\n    \n    if(uv.x>.5) {\t\t\t\t\t\t\t\t\t\t// mirror and flip half of the texture\n    \tuv.x = uv.x-.5;\n        uv.y = 1.-uv.y;\n    }\n    \n    float y = sin(uv.x*twopi)*.1;\t\t\t\t\t\t// add a wavy vine down the middle\n    float vine = B(.495+y, .505+y, .01, uv.y);\n    \n    vec2 p1 = uv-vec2(.27, .4);\t\t\t\t\t\t\t// add spiral shaped vines\n    vec2 st = PolarCoords(p1);\n    vec2 sc = SpiralCoords(st, 5.);\n    vine += B(.48, .52, .02, sc.y)*S(.7, .4, sc.x);\n    \n    vec4 col = vec4(.1, .5, .1, 1.)*vine;\t\t\t\t// add vine\n    \n    vec2 lc = uv*4.-vec2(1.5, 1.7);\n    \n    float sweep = .2;\n    #ifdef PSYCO\n    sweep = sin(iTime*.5)*.5;\n    #endif\n    \n    vec4 leaf = Leaf(lc, .5, sweep);\n    \n    col = mix(col, leaf, leaf.a);\n    lc.x +=2.;\n    lc.y = 1.-lc.y-.4;\n    leaf = Leaf(lc, .5, sweep);\n    col = mix(col, leaf, leaf.a);\n    \n    vec2 fc = sc;\n    fc.x = fract(fc.x*10.);\n    fc.x = (fc.x-.5)*.5+.5;\n    vec4 smallFlower = Flower(fc, vec4(2.5, .4, .3, 5.), flowerCol, lCol);\n    smallFlower.a *= B(.1, .4, .01, sc.x);\n    col = mix(col, smallFlower, smallFlower.a);\n    \n    vec4 rect = vec4(0., .3, .5, .9);\n    vec4 flower = Flower(within(uv, rect), vec4(3., .4, .4, 30.), flowerCol, lCol);\n    col = mix(col, flower, flower.a);\n    \n    return col;\n}\n\nvec3 MatroshkaTex(de o) {\n    vec3 n = N31(o.seed);\n    vec3 col = mainCol;\n\t\n    lineCol *= max(.1, S(.8, .9, n.x));\n\n    vec4 faceArea = vec4(.35, .65, .65, .95);\n    \n    if(o.uv.y>faceArea.y-.2) {\n        vec2 scarfUv = within(o.uv, vec4(0., faceArea.y-.2, 1., 1.));\n        vec4 scarf = Scarf(scarfUv, o.seed);\n        col = mix(col, scarf.rgb, scarf.a);\n    }\n    \n    if(o.uv.y<faceArea.y) {\n    \tvec4 body = RoseTex(fract(o.uv+vec2(.4,.2)), n);\n    \tcol = mix(col, body.rgb, body.a);\n    }\n    \n    float faceMask = square(o.uv, faceArea, .001);\n    if(faceMask>0.) {\n\t\tvec4 face = Face(within(o.uv, faceArea), o.seed);\n        col = mix(col, face.rgb, face.a);\n    }\n    \n    return col;\n\n}\n\nfloat MatroshkaDist(vec3 p) {\t    \n    float head = sSph(p-vec3(0., 2.4, 0.), vec3(.9,  .8, .9), .7);\n    float body = sSph(p-vec3(0., 1., 0.), vec3(.95, 1.48, .95), .9);\n\n    float d = smin(head, body, .4);\t\t// merge head and body\n    d = smax(d, -p.y, .05);\t\t\t\t// flatten bottom\n    \n    float y = remap01(0., 2.96, p.y);\n    d += sin(y*100.)*.001;\n    d += B(.3985, .40, .003, y)*.001;\t// groove where the top and bottom half meet\n    \n    return d;\n}\n\nvec2 MatroshkaTop(vec3 p) {\t\t\t\t\t\t\t\t\t\t\t\t\t// returns distance to top half of doll (x) as well as inside or outside (y)\n\tfloat d = MatroshkaDist(p);\t\t\t\t\t\t\t\t\t\t\t\t// get normal (closed) doll dist first\n    float outside = d;\t\t\t\t\t\t\t\t\t\t\t\t\t\t// save outside doll dist\n    d = smax(d, -sdSphere(p, vec3(0., 0.6, 0.), 1.), .05);\t\t\t\t\t// take away bottom half of doll\n    d = smax(d, -sSph(p-vec3(0., 1., 0.), vec3(.7, 1.4, .7), .95), 0.02);\t// hollow out top half\n    float t = S(-.005, -.01, outside-d);\t\t\t\t\t\t\t\t\t// calculate wether outside or inside of doll (used for shading)\n    return vec2(d, t);\n}\n\nvec2 MatroshkaBottom(vec3 p) {\t\t\t\t\t\t\t\t\t\t\t\t// returns distance to bottom half of doll (x) as well as inside or outside (y)\n    float d = MatroshkaDist(p);\t\t\t\t\t\t\t\t\t\t\t\t// get normal (closed) doll dist first\n    float outside = d;\t\t\t\t\t\t\t\t\t\t\t\t\t\t// save outside doll dist\n    d = smax(d, -sdSphere(p, vec3(0., 3.0, 0.), 2.), .03);\t\t\t\t\t// take away top half\n    d = min(d, sdCappedCylinder(p-vec3(0.,1.,0.), vec2(.8, .25)));\t\t\t// add extra ridge\n    d = smax(d, -sSph(p-vec3(0., 1.15, 0.), vec3(.7, 1., .7), 1.1), 0.02);\t// hollow out bottom part\n    float t = S(.005, .01, d-outside);\t\t\t\t\t\t\t\t\t\t// calculate wether outside or inside of doll (used for shading)\n    return vec2(d, t);\n}\n\n\nvec2 GetStoneTiles(vec3 p) {\n    return vec2(p.x+sin(p.z*stones.x), p.z+sin(p.x*stones.y)*stones.z)*stones.w;\n}\n\nfloat Ground(vec3 p) {\n    float d = p.y;\n    vec2 tiles = GetStoneTiles(p);;\n    vec2 id = floor(tiles);\n    float bump = N2(id.x, id.y);\n\n    vec2 tUv = tiles*pi;\n    float tileMask = abs( sin(tUv.x)*sin(tUv.y) );\t// make a mask that fades to 0 on the edges\n    tileMask = 1.-pow(1.-tileMask, 8.);\n    d -= tileMask*.1*bump;\n \n    vec3 n = N31(id.x+id.y*165.32);\t\t\t\t// add surface detail\n    float detail = sin(n.x*p.x*15.)*sin(n.y*p.z*15.)*.05;\n    detail += sin(n.z*p.x*p.z*5.)*.005;\n    d += detail;\t\t\t\t\t\n   \n    return d;\n}\n\nvec3 SplitMatroshkaDist(vec3 p, float open, float size) {\n\t// returns distance and id to splitting matroshkas\n    // x = distance, y = material, z = transition\n    \n    float dBaby = MatroshkaDist(p*size)/size;\n    vec2 bottom = MatroshkaBottom(p+vec3(0., open, 0.));\n    vec2 top = MatroshkaTop(p-vec3(0., open, 0.));\n\n    float dShell = min(bottom.x, top.x);\n    \n    vec3 m = vec3(0.);\n    if(dBaby < dShell)\n        m = vec3(dBaby, 0., 0.);\n    else if(bottom.x<top.x)\n        m = vec3(bottom.x, 1., bottom.y);\n    else\n        m = vec3(top.x, -1., top.y);\n        \n    return m;\n}\n\n\nde castRay( ray r ) {\n    float dO=MIN_DISTANCE;\t\t\t\t\t\t\t// the distance from the camera\n    float dS=MAX_DISTANCE;\t\t\t\t\t\t\t// the distance from the surface\n    float t;\t\t\t\t\t\t\t\t\t\t// used to keep track of time\n    vec3 p=vec3(0.);\t\t\t\t\t\t\t\t// local position (after repeat, resize etc)\n\t\n    de o;\n    o.m = -1.;\n    \n    if(SOLO<.5) {\t\t\t\t\t\t\t\t\t// we are in marching mode (as in marching matroshkas, not ray marching ;))\n        // Dolls ...\n        t = iTime*.96;\t\t\t\t\t\t// try to match to the beat of the music\n        \n        rc q;\t\t\t\t\t\t\t\t\t\t// holds the repeated coordinate\n        float pt = t*pi;\t\t\t\t\t\t\t// 'polar' time\n        float s = sin(pt*5.);\n        float shuffle = s*.1 + t;\t\t\t\t\t// used to move dolls forward\n        float headBounce = s*.05 + 1.05;\t\t\t// used to scale height periodically\n        s = sin(pt*2.5);\n        mat3 leftRight = RotY(s*.2) * RotZ(s*.1);\t// used to make the doll lean left and right\n        \n        for( int i=0; i<MAX_STEPS; i++ )\n        {\n            p = r.o + r.d * dO;\t\t\t\t\t\t// Ray march\n            vec3 P=p;\n            p.z -= shuffle;\t\t\t\t\t\t\t// move forward\n            q = Repeat(p, grid);    \t\t\t\t// make a grid of them\n            p.xz = q.p.xz;\t\t\t\t\t\t\t// keep only ground layer\n            p.y *= headBounce;\t\t\t\t\t\t// make them bounce up and down\n            p *= leftRight; \t\t\t\t\t\t// make them sway left-right\n            float si = fract((q.id.x+q.id.z+5.)/5.);// make them different sizes\n            s = .8 + si;\t\t\t\t\t\t\t// .8 < s < 1.8\n            p*=s;\t\t\t\t\t\t\t\t\t\n            \n            dS = MatroshkaDist(p)/s;\t\t\t\t// calculate distance to doll\n            \n            vec3 rC = ((2.*step(0., r.d)-1.)*q.h-q.p)/r.d;\t// ray to cell boundary\n            float dC = min(min(rC.x, rC.y), rC.z)+.01;\t\t// distance to cell just past boundary\n            dS = min(dS, dC);\t\t\t\t\t\t\t\t// if cell boundary is closer than just set to the beginning of the next cell\n            \n            dO += dS;\t\t\t\t\t\t\t\t// add the distance from the surface to the distance from the camera\n            if( dS<RAY_PRECISION || \t\t\t\t// if we hit, \n               dO>MAX_DISTANCE  ||\t \t\t\t\t// or we are past far clipping..\t\n               (r.d.y>0. && p.y>6.5) ||\t\t\t\t// or if we are looking up and the ray is already above all of them..\n               (p.y<.0 && r.d.y<=0.)) \t\t\t\t// or if we are looking down and the ray is already below the ground\n               break;\t\t\t\t\t\t\t\t// break out of the loop \n        }\n\t\t\n        if(dS<=RAY_PRECISION) {\t\t\t\t\t\t\t// if we got really close to the surface, we count it as a hit\n            o.m=2.;\t\t\t\t\t\t\t\t\t// set material id so we know later on how to shade this\n            o.d=dO;\t\t\t\t\t\t\t\t\t// set distance from the camera\n            o.p.xyz=p;\t\t\t\t\t\t\t\t\t// save local coordinate (coordinate inside of the grid cell)\n            o.p.w = s;\n            o.seed = q.id.z + floor((q.id.x+q.id.z+5.)/10.)*100.;\n        } else if(r.d.y<0. && o.m<0.) {\t\t\t\t// only consider ground if we are looking down and nothing was hit yet\n            // Ground ...\n            dO = -((r.o.y-.08)/r.d.y);\t\t\t\t// fast forward by doing a ray-plane intersection first\n            \n            for( int i=0; i<MAX_STEPS; i++ )\n            {\n                p.xyz = r.o + r.d * dO;\t\t\t\t// ray march\n                dS = Ground( p.xyz );\t\t\t\t// get distance to ground\n                dO += dS;\t\t\t\t\t\t\t// add distance from the surface to the distance from the camera\n                if( dS<RAY_PRECISION || \t\t\t// if we hit \n                   dO>MAX_DISTANCE ) \t\t\t\t// or if we are past far clipping\n                    break;\t\t\t\t\t\t\t// break out of the loop\n            }\n\n            if(dS<=RAY_PRECISION) {\t\t\t\t\t// if we got really close to the surface, we count it as a hit\n                o.m=1.;\n                o.d=dO;\n                \n                p.z -= shuffle;\t\t\t\t\t\t\t// move forward\n                q = Repeat(p, grid);    \t\t\t\t// make a grid of them\n                p.xz = q.p.xz;\t\t\t\t\t\t\t// keep only ground layer\n                p.y *= headBounce;\t\t\t\t\t\t// make them bounce up and down\n                p *= leftRight; \t\t\t\t\t\t// make them sway left-right\n                s = .8+fract((q.id.x+q.id.z+5.)/5.); \t// make them different sizes\n            \tp*=s;\n                o.p.xyz=p;\n            }\n        }\n    } else {\t\t\t\t\t\t\t\t\t\t// we are in solo mode\n    \tt = fract(time);\n        float open = (1.-X2(1.-t))*3.5;\t\t\t\t// how far the two shells are apart as a function of time\n        float size = mix(1.2, 1., t);\t\t\t\t// grow as it matures\n        vec3 m;\n        \n        for( int i=0; i<MAX_STEPS; i++ ) {\n       \t\tp = r.o + r.d * dO;\t\t\t\t\t\t// Ray march\n            m = SplitMatroshkaDist(p, open, size);\n            if( m.x<RAY_PRECISION || dO>MAX_DISTANCE ) break;\n            dO += m.x;\n        }\n        \n         if(m.x<=RAY_PRECISION) {\t\t\t\t\t\t// if we got really close to the surface, we count it as a hit\n             o.d=dO;\n             o.m=2.;\n             o.t = m.z;\n             \n             if(m.y==0.) {   \t\t\t\t\t\t// inside matroshka\t\n            \to.seed = floor(time+1.);\n            \to.p.xyz=p*size;\n                o.p.w = size;\n                o.open = open;\n                o.inside = 1.;\n             } else {\t\t\t\t\t\t\t\t// outside matroshka\n             \to.seed = floor(time);\n                o.p.xyz = p+vec3(0., m.y*open, 0.);\n                o.open = open;\n                o.p.w = 1.;\n                o.inside = 0.;\n             }\n         }      \n    }\n    \n    return o;\n}\n\nfloat SplitMatroshkaAO( de o, float dist ) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + dist*float(i)/5.0;\n        vec3 aopos =  o.nor * hr + o.pos;\n        float dd = SplitMatroshkaDist( aopos, o.open, o.p.w ).x/o.p.w;\n        occ += -(dd-hr)*sca;\n        sca *= 0.35;\n    }\n    return sat( 1.0 - 3.0*occ );    \n}\n\nvec3 MatroshkaNormal( vec3 p )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    MatroshkaDist(p+eps.xyy) - MatroshkaDist(p-eps.xyy),\n\t    MatroshkaDist(p+eps.yxy) - MatroshkaDist(p-eps.yxy),\n\t    MatroshkaDist(p+eps.yyx) - MatroshkaDist(p-eps.yyx) );\n\treturn normalize(nor);\n}\n\nfloat GroundAO( de o, float dist ) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + dist*float(i)/5.0;\n        vec3 aopos =  o.nor * hr + o.pos;\n        float dd = Ground( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.35;\n    }\n    return sat( 1.0 - 3.0*occ );    \n}\n\nvec3 GroundNormal( vec3 p )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    Ground(p+eps.xyy) - Ground(p-eps.xyy),\n\t    Ground(p+eps.yxy) - Ground(p-eps.yxy),\n\t    Ground(p+eps.yyx) - Ground(p-eps.yyx) );\n\treturn normalize(nor);\n}\n\n\n\nvec3 GroundMat(de o) {\n    vec2 p = o.pos.xz*3.;\n    vec2 noise = vec2( NoiseTex(p, 0., 5.), NoiseTex(p, 12., 5.));\n    vec3 col = vec3(1., .8, .8)*.5;\n\n    o.nor = GroundNormal(o.pos);\t\t\t\t\t// get normal\n\to.nor.xz += (noise-.5)*2.;\t\t\t\t\t\t// cheap, fake, normal perturb\n    o.nor = normalize(o.nor);\t\t\t\t\t\t// renormalize\n    \n    vec2 id = floor(GetStoneTiles(o.pos));\n    \n    col *= 1.+( N2(id) -.5)*.3;\t\t\t\t\t\t// vary color of stones\n    col *= GroundAO( o, 1. );\t\t\t\t\t\t// get ao in the cracks between stones\n    \n    // add fake shadows\n    o.p.z+=.1;\t\t\t\t\t\t\t\t\t\t// offset a little bit to account for the fact that light is coming from the fort\n    float dropShadow = S(.8, .4, length(o.p));\t\t// simple drop shadow right below the doll\n    o.p.z+=.6; o.p.x*=1.5;\t\t\t\t\t\t\t// second shadow is behind the doll and a bit elongated\t\n    float shadow = S(1.7, .5, length(o.p))*.75;\n    shadow = max(shadow, dropShadow);\t\t\t\t\n    col *= mix(1., .2, shadow);\t\t\t\t\t\t// add in both shadows\n    \n    vec3 r = reflect(o.rd, o.nor);\t\t\t\t\t// calculate reflect view vector\n    float spec = sat(dot(r, light));\n    spec = pow(spec, 2.);\n    col += spec*.1*(1.-shadow);\t\t\t\t\t// add specular, make sure its attenuated by the shadow and vary the reflection by stone\n    \n    return col;\n}\n\nvec3 MatroshkaMat(de o, vec2 uv) {\n\n    vec3 col = vec3(1.);\n    \n    o.uv = vec2(.5-atan(o.p.x, o.p.z)/twopi, remap01(0., 2.96, o.p.y));\n        \n    o.nor = MatroshkaNormal(o.p.xyz);\n    o.fresnel = 1.-dot(o.nor, -o.rd);\n    \n    mainCol = N31(o.seed);\t\t\t\t\t\t\t// generate main col\n    secCol = fract(mainCol*23476.76);\n    \n    col *= MatroshkaTex(o);\n\n    float dif = dot(light, o.nor);\n    col *= max(.4, mix(1., dif, .5));\t\t\t\t// ehh.. too much screwing around with things.. \n    col *= 1.+o.fresnel*.2;\n\n    vec3 r = reflect(o.rd, o.nor);\t\t\t\t\t// calculate reflected view ray\n    float spec = sat(dot(r, light));\t\t\t\t// calculate specular reflection\n    \n    float occ = 1.-S(.25, .0, o.pos.y);\t\t\t\t// fake occlusion when we get close to the ground\n    \n    vec3 ref = background(r, uv, 0.);\t\t\t\t// sample background in the direction of the reflection\n    ref *= X2(o.fresnel)*.5;\t\t\t\t\t\t// make sure reflection is strongest at grazing angles\n    ref += pow(spec, 8.)*.6;\t\t\t\t\t\t// add specular highlight\n   \n    float groove =  1.-B(.3985, .40, .003, o.uv.y);\t// groove where the top and bottom half meet\n       \n    if(SOLO>.5) {\n        float fakeAo = B(1.2-o.open, 1.2+o.open, .2, o.pos.y);\t// calc fake letterbox ao\n        \n        if(o.inside>.5) { \t\t\t\t\t\t\t\t\t\t// if this is the inside doll\n        \tcol *= fakeAo;\t\t\t\t\t\t\t\t\t\t// .. doll has a darker head when covered by shell\n        \tref *= X2(fakeAo);\t\t\t\t\t\t\t\t\t// .. also no bg ref when covered\n         \tcol += ref*groove;\t\t\t\t\t\t\t\t\t// add ref, but not where the center groove is\n        } else {\n            if( o.t>0. )  {\n            \tvec3 interior = vec3(1., 1., .8);  \n        \t\tinterior *= SplitMatroshkaAO(o, .5); \n            \tinterior *= mix(fakeAo, 1., o.open/3.5);\n            \tcol = mix(col, interior, o.t);\t\t\t\t\t// the inside has a different color\n            } else\n                col += ref*groove;\n            col = mix(col, bg, S(1.05, 3.15, o.open));\t// then fade it out..\n        }        \t\n    } else {\n        ref *= mix(occ, 1., SOLO);\t\t\t\t\t\t// only occlude close to ground when in marching mode\n        col += ref*groove;\t\t\t\t\t\t\t\t// add reflection to final color, no ref where groove is\n        col *= sat(occ+.7);\t\t\t\t\t\t\t// darken where it contacts the ground\n    }\n    \n   \n    return col;\n}\n\nvec4 render( ray camRay, vec2 uv ) {\n    // outputs a color\n    \n    vec3 col = vec3(0.);\n    de o = castRay(camRay);\n   \n    if(o.m>0.) {        \n        o.pos = camRay.o + o.d*camRay.d;\n    \to.rd = camRay.d;\n        \n        if( o.m==1. )\n            col = GroundMat(o);\n        else\n            col = MatroshkaMat(o, uv);\n    }\n    \n    col = mix(col, background(o.rd, uv, 0.), S(.0, 100., o.d));\n    \n    return vec4( col, o.m );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 UV = (fragCoord.xy / iResolution.xy)-.5;\n    vec2 uv = UV;\n   \tuv.y *= iResolution.y/iResolution.x;\n    vec2 m = iMouse.xy/iResolution.xy;\n    if(m.x==0. && m.y==0.) m=vec2(.55, .45);\t// hack to get a decent starting cam. Anyone have a better solution for this?\n    mouse = m;\n  \n    vec3 col;\n    \n    float t = iTime;\n    time = iTime*.4;\n    \n    #ifdef TEXTUREMODE\n    \tuv = fragCoord.xy / iResolution.xy;\n    \t//col = RoseTex(uv+.5).rgb;\n    \tcol = vec3(Kremlin(uv));\n    \t//col = vec3(NoiseTex(uv, floor(t), 6.));\n    #else\n    \n    float turn = (.5+m.x)*twopi;\n\n    vec3 camPos;\n    float camDist=8.;\n    \n    float mt = fract(t/269.)*269.;\n    \n    SOLO = B(-1., 28.3, 0.01, mt);\n    SOLO += B(41.5, 54.8, 0.01, mt);\n    SOLO += B(81., 107., 0.01, mt);\n    SOLO += B(134., 161., 0.01, mt);\n    SOLO += B(227., 240., 0.01, mt);\n  \n    if(SOLO>.5) {\n        camPos = vec3(0., 1.5, 0.);\n        mainCol = N31(floor(time+1.));\n        lastCol = N31(floor(time));\n    } else {\n        camPos = vec3(0., 3.5, 0.);\n        turn += t*.1;\n    }\n\n    float camY = INVERTMOUSE*camDist*cos((m.y)*pi);\n    \n    vec3 pos = vec3(0., camY, camDist)*RotY(turn);\n   \t\n    CameraSetup(uv, camPos+pos, camPos, 1.);\n    \n    bg = background(cam.ray.d, uv, 1.);\n\n    vec4 info = render(cam.ray, uv);\n  \n    if(info.w==-1.) {\n        col = bg; \n    } else \n        col = info.rgb;\n    \n    #endif\n    \n    UV *= 1.1;\n    col *= 1.-dot(UV, UV);\t\t// add vignette\n    \n    fragColor = vec4(col, .1);\n}","name":"Image","description":"","type":"image"}]}