{"ver":"0.1","info":{"id":"lX3SWr","date":"1718961409","viewed":81,"name":"Just Sun","username":"fxslava","description":"Perlin noise based","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["sun","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3  SphereCoord = vec3(0., 0., 3.5);\nconst float SunRadiuse = 0.75f;\nconst float SunGalo = 0.2f;\n\nvoid ApplyWorldTransform(inout vec3 pos)\n{\n    float a = -0.15f * iTime;\n    mat2 rotY = mat2(cos(a), -sin(a), sin(a), cos(a));\n    pos.xz = pos.xz * rotY;\n}\n\nvec3 CalcGalo(vec3 coord, vec3 eyeRay, float Radius)\n{\n    vec3 nEyeRay   = normalize(eyeRay);\n    vec3 coordER   = dot(coord, nEyeRay) * nEyeRay;\n    vec3 radiusVec = coordER - coord;\n    float r  = length(radiusVec);\n    float GaloRadius = Radius + SunGalo;\n    \n    if (r < GaloRadius) {\n    \n       float h2 = sqrt(GaloRadius * GaloRadius - r * r);\n       vec3 pos1 = coordER - nEyeRay * h2 - coord;\n       vec3 pos2 = coordER + nEyeRay * h2 - coord;\n       \n       if (r < Radius) {\n          pos2 = coordER - nEyeRay * sqrt(Radius * Radius - r * r) - coord;\n       }\n       \n       const int Steps = 100;\n       float d = (1.0f / float(Steps));\n       float w = length(pos1 - pos2) * d;\n    \n       vec3 fireColor = vec3(0,0,0);\n       \n       for (int i = 0; i < Steps; ++i) {\n          float t = float(i) * d;\n          \n          vec3 pos = (pos2 - pos1) * t + pos1;\n          \n          float l = length(pos) - Radius;\n          \n          if (l > 0.) {\n             vec3 normal = normalize(pos);\n             ApplyWorldTransform(normal);\n             fireColor += texture(iChannel1, -normal).rgb * w * exp(5. * l) * exp(-25. * l) * 4.;\n          }\n       }\n       \n       return fireColor;\n    }\n    \n    return vec3(0,0,0);\n}\n\nfloat SphereHit(vec3 coord, vec3 eyeRay, float Radius, out vec3 normal)\n{\n    vec3 nEyeRay = normalize(eyeRay);\n    vec3 coordER = dot(coord, nEyeRay) * nEyeRay;\n    vec3 radiusVec = coordER - coord;\n    float r = length(radiusVec);\n    float h2 = (r < Radius) ? sqrt(Radius *  Radius - r * r) : 0.0;\n    vec3 hitp = coordER - nEyeRay * h2;\n    normal = -(hitp - coord) / Radius;\n    \n    return 1.0f - clamp((r - Radius) / 0.005f, 0., 1.);\n}\n\nvec3 CalcSun(vec3 coord, vec3 eyeRay, float Radius)\n{\n    vec3 normal;\n    float hit = SphereHit(coord, eyeRay, Radius, normal);// * dot(eyeRay, normal);\n    \n    ApplyWorldTransform(normal);\n    \n    return GetFireColor(normal, iTime) * hit;\n}\n\nvec3 eyeRayCalculate(vec2 fragCoord, out vec2 uv)\n{\n    float diagonal = length(iResolution);\n    vec2  screen_center = iResolution.xy * 0.5 / diagonal;\n   \tuv = fragCoord.xy / diagonal;\n    \n    return vec3(uv - screen_center, 1.0f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    float diagonal = length(iResolution);\n    vec2 screen_center = iResolution.xy * 0.5 / diagonal;\n   \tvec2 uv = fragCoord.xy / diagonal;\n    vec3 eye = vec3(uv - screen_center, 1.0f);\n    \n\tfragColor = vec4(CalcSun(SphereCoord, eye, SunRadiuse) * 0.7 + CalcGalo(SphereCoord, eye, SunRadiuse), 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float hash(int n)\n{\n    n = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return float( n & ivec3(0x0fffffff)) / float(0x0fffffff);\n}\n\nfloat hash2( ivec2 z )\n{\n    int n = z.x + z.y * 11111;\n    return hash(n);\n}\n\nfloat hash3(ivec3 p)\n{                    \n    int n = p.x*3 + p.y*113 + p.z*311;\n    return hash(n);\n}\n\nvec3 hash3to3(vec3 p3)\n{\n   p3 = fract(p3 * vec3(.1031f, .1030f, .0973f));\n   p3 += dot(p3, p3.yxz + 33.33f);\n   return normalize(fract((p3.xxy + p3.yxx) * p3.zyx) * 2.0f - 1.0f);\n}\n\nvec3 hash3to3(ivec3 p3)\n{\n   return hash3to3(vec3(p3));\n}\n\nvec3 noise(in vec3 x)\n{\n    ivec3 i = ivec3(floor(x));\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash3to3(i + ivec3(0,0,0)), \n                        hash3to3(i + ivec3(1,0,0)),f.x),\n                   mix( hash3to3(i + ivec3(0,1,0)), \n                        hash3to3(i + ivec3(1,1,0)),f.x),f.y),\n               mix(mix( hash3to3(i + ivec3(0,0,1)), \n                        hash3to3(i + ivec3(1,0,1)),f.x),\n                   mix( hash3to3(i + ivec3(0,1,1)), \n                        hash3to3(i + ivec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec3 perlin(vec3 x) {\n   \n   const mat3 m = mat3( 0.00,  0.80,  0.60,\n                       -0.80,  0.36, -0.48,\n                       -0.60, -0.48,  0.64 );\n                    \n   vec3 q = 8.0 * x;\n   vec3 f;\n   f  = 0.5000 * noise(q); q = m * q * 2.01;\n   f += 0.2500 * noise(q); q = m * q * 2.02;\n   f += 0.1250 * noise(q); q = m * q * 2.03;\n   f += 0.0625 * noise(q); q = m * q * 2.01; \n   \n   return f;\n}\n\n\n// Fire\nvec3 sunColor(float t) {\n   vec3 color0 = vec3(209., 64., 9.);\n   vec3 color1 = vec3(252., 150., 1.);\n   vec3 color2 = vec3(255., 204., 51.);\n   vec3 color3 = vec3(255., 228., 132.);\n   vec3 color4 = vec3(255., 255., 255.);\n   \n   if (t < 0.25) {\n      return mix(color0, color1, t/.25) * (1. / 255.);\n   } else\n   if (t < 0.50) {\n      return mix(color1, color2, (t-.25) / 0.25) * (1. / 255.);\n   } else\n   if (t < 0.75) {\n      return mix(color2, color3, (t-.5) / 0.25) * (1. / 255.);\n   }\n   \n   return mix(color3, color4, (t - 0.75) / 0.25) * (1. / 255.);\n}\n\nvec3 flowNoise(in vec3 x, in float t)\n{\n   vec3 f = vec3(0,0,0);\n   float n = 0.0f;\n   \n   const int Steps = 5;\n   \n   for (int i = 0; i < Steps; ++i) {\n      float ft = fract(float(i) * (1.0f / float(Steps)) + t);\n      \n      vec3 flow = perlin(x * 0.7);\n      float flowSpeed = length(flow);\n      \n      float w = abs(1.0f - ft) * ft * flowSpeed;\n      \n      f += perlin(x * 4.0 + vec3(-flow.y, flow.x, flow.z) * ft * 0.5f + vec3(0, 0, float(i) * 0.05f)) * w;\n      n += w;\n   }\n   \n   return f / n;\n}\n\nvec3 GetFireColor(vec3 normal, float iTime) {\n   vec3 f = flowNoise(normal * 0.8 + vec3(0, 0, .01 * iTime), iTime) * 0.5 + 0.5;\n   float l = length(f);\n   return sunColor(pow(l, 4.) * 0.7);\n}\n    \n    ","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    vec3 col = GetFireColor(rayDir, iTime);\n    \n    float intensity = length(col);\n    \n    fragColor = vec4(normalize(col) * pow(intensity, 7.) * 0.1, 1.0);\n}","name":"Cube A","description":"","type":"cubemap"}]}