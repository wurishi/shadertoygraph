{"ver":"0.1","info":{"id":"XXffD7","date":"1728454729","viewed":15,"name":"drop-shadow for ellipse","username":"yvenliu","description":"drop-shaodw for ellipse","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["shadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Reference: http://stereopsis.com/shadowrect/\n\n\n// blend two color by alpha\nvec4 blend(vec4 src, vec4 append) {\n  \treturn vec4(src.rgb * (1.0 - append.a) + append.rgb * append.a,\n              1.0 - (1.0 - src.a) * (1.0 - append.a));\n}\n\n// approximation to the gaussian integral [x, infty)\nfloat gi(float x) {\n\tfloat i6 = 1.0 / 6.0;\n\tfloat i4 = 1.0 / 4.0;\n\tfloat i3 = 1.0 / 3.0;\n\n    if (x > 1.5) return 0.0;\n    if (x < -1.5) return 1.0;\n\n    float x2 = x * x;\n    float x3 = x2 * x;\n    \n    if (x >  0.5) return .5625  - ( x3 * i6 - 3. * x2 * i4 + 1.125 * x);\n    if (x > -0.5) return 0.5    - (0.75 * x - x3 * i3);\n    return 0.4375 + (-x3 * i6 - 3. * x2 * i4 - 1.125 * x);\n}\n\n\n// 计算点与椭圆的交点\nvec2 intersectionWithEllipse(vec2 point, vec2 ellipseRadii) {\n    float a = ellipseRadii.x;\n    float b = ellipseRadii.y;\n\n    // 计算 A, B, C\n    float A = (point.x * point.x) / (a * a) + (point.y * point.y) / (b * b);\n    float B = 0.0; // 线性项系数\n    float C = -1.0; // 常数项\n\n    // 计算判别式\n    float discriminant = B * B - 4.0 * A * C;\n\n    if (discriminant < 0.0) {\n        return vec2(0.0); // 没有交点，返回零向量\n    }\n\n    // 计算 t 的两个解\n    float t1 = (-B + sqrt(discriminant)) / (2.0 * A);\n    float t2 = (-B - sqrt(discriminant)) / (2.0 * A);\n\n    // 计算交点\n    vec2 intersection1 = t1 * point;\n    vec2 intersection2 = t2 * point;\n\n    \n    // return vec4(intersection1, intersection2);\n    return vec2(distance(point, intersection2), distance(point, intersection1));\n}\n\n\nfloat radialShadow(vec2 border, float pos, float sigma) {\n    //float pos1 = ((border.x - pos) / sigma) * 1.5;\n    //float pos2 = ((pos - border.y) / sigma) * 1.5;\n    \n    float pos1 = (border.x / sigma) * 1.5;\n    float pos2 = (-border.y / sigma) * 1.5;\n    \n  \treturn 1.0 - abs(gi(pos1) - gi(pos2));\n}\n\n\nfloat circleShadow(vec4 circle, vec2 point, float sigma) {\n   float kk =  sqrt(circle.z * circle.z + circle.w * circle.w);\n   float d = sqrt(point.x * point.x + point.y * point.y);\n   vec2 border = intersectionWithEllipse(point, circle.zw);\n   return radialShadow(border, d, sigma);\n}\n\nvec4 drawCircleShadow(vec2 pos, vec4 circle, vec4 color, float sigma) {\n    vec4 result = color;\n    \n    float shadowMask = circleShadow(circle, pos - circle.xy, sigma);\n    \n    result.a *= shadowMask;\n    \n\treturn result;\n}\n\n\n// check a point in a rect\nfloat insideCircle(vec2 v, vec4 circle) {\n  float deltaX = abs(v.x - circle.x);\n  float deltaY = abs(v.y - circle.y);\n  float dd = pow(deltaX, 2.0) / pow(circle.z, 2.0) + pow(deltaY, 2.0) / pow(circle.w, 2.0);\n  return step(dd, 1.0);\n}\n\n// draw circle\nvec4 drawCircle(vec2 pos, vec4 circle, vec4 color) {\n    vec4 result = color;\n    \n    result.a *= insideCircle(pos, circle);\n    return result;\n}\n\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    float co = 160.;\n    // 控制模糊程度\n    float sigma = co * iMouse.x / iResolution.x;\n    sigma += step(iMouse.x, 0.0) * co;\n    \n    float z = sigma * iMouse.y / iResolution.y;\n    \n    vec4 result = vec4(1.0);\n    \n    // vec3 rectColor = hsv2rgb(vec3(fract(iTime * 0.1), 0.8, 0.8));\n    \n    vec3 rectColor = vec3(0.0);\n    \n    vec4 color = vec4(rectColor,1.0);\n    vec4 circle = vec4(iResolution.xy / 2.0, vec2(260.,200.));\n    \n    vec4 shadowCircle = vec4(circle.xy, circle.zw);\n    vec4 shadowColor = vec4(rectColor, sin(iTime) * 0.2 + 0.8);\n    \n  \tresult = blend(result, drawCircleShadow(fragCoord, shadowCircle, shadowColor, sigma));\n  \tresult = blend(result, drawCircle(fragCoord, circle, color));\n    \n    //result = drawCircle(fragCoord, circle, color);\n    \n    \n    fragColor = result;\n}","name":"Image","description":"","type":"image"}]}