{"ver":"0.1","info":{"id":"wsBXWw","date":"1553980356","viewed":402,"name":"Glowycorn","username":"OliverSchaff","description":"Inspired by tdhooper's https://www.shadertoy.com/view/WdB3Dw.","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["3d","transparent"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Raymarching code is the MINIMIZED version of https://www.shadertoy.com/view/Xl2XWt\n\nconst float MAX_TRACE_DISTANCE = 4.5;\nconst float INTERSECTION_PRECISION = 0.001; \nconst int NUM_OF_TRACE_STEPS = 130;\nconst float SCALE_DIST = 0.16;\n\nconst float PI = 3.14159265359;\n\n// Spectrum colour palette\n// IQ https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdSub( float d0, float d1 ) {\n    return max( d0, -d1 );\n}\n\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\nvec3 carToPol(vec3 p) {\n    float r = length(p);\n    float the = acos(p.z/r);\n    float phi = atan(p.y,p.x);\n    return vec3(r,the,phi);\n}\n\nvec2 map( vec3 pos ){\n    \n    vec3 pol = carToPol(pos);\n    float d1 = opOnion(sdSphere( pos, 1.0 ), 0.0001);\n    float wave = -0.1 -  0.9*sin(5.*(pol.y+0.2*iTime))*sin(1.0*pol.z);\n    float d2 = d1 + wave;\n    float d = sdSub(d1,d2);\n\n\tvec2 res = vec2(d, 1.0);\n    return res;\n    \n}\n\nvec3 selfColor(vec3 pos) {\n    vec3 pol = carToPol(pos);\n    return spectrum(1.0*pol.z/PI/2.0+0.5*pol.y/PI);\n}\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd , inout vec3 col){\n\n    float h =  MAX_TRACE_DISTANCE;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if(t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        \n        vec3 pos = ro + rd * t;\n        col += selfColor(pos) * exp(-5.0*h)*0.01 ;\n        \n        t += max(abs(h)*SCALE_DIST, INTERSECTION_PRECISION);\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\n    vec3 ro = vec3( 3.0*cos(0.2*iTime), 0.0, 3.0*sin(0.2*iTime));\n    vec3 ta = vec3( 0. , 0. , 0. );\n    \n\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, sin(0.3*iTime) );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    // rotate camera\n\tmat3 rot = rotationXY( ( iMouse.xy - iResolution.xy * 0.5 ).yx * vec2( 0.01, -0.01 ) );\n\trd = rot * rd;\n\tro = rot * ro;\n\n    vec3 accCol = vec3(0);\n    \n    vec2 res = calcIntersection( ro , rd, accCol);\n\n\tvec3 color = accCol;\n\tfragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}