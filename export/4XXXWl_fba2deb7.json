{"ver":"0.1","info":{"id":"4XXXWl","date":"1712365425","viewed":85,"name":"gravity raycasting","username":"badatcode123","description":"testing\ntried raymarching before but that wasn't very accurate for gravity so I decided to just move the ray 0.1 steps, it's incredibly slow though","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["blackhole"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texelFetch(iChannel0,ivec2(fragCoord),0).rgb;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define max_len 255.0\n#define epsilon 0.01\n#define steps 0.1\n\nstruct rayinfo\n{\n   vec3 origin;\n   vec3 dir;\n   vec3 color;\n};\nvoid sphere_sdf(vec3 ro,vec3 ce,float rad,vec3 objcol,inout vec3 col,inout float minlen)\n{\n  float dist = distance(ro,ce)-rad;\n  if (dist < minlen)\n  {\n     minlen = min(dist,steps);\n     col = objcol;\n  }\n}\nvoid ring_sdf(vec3 ro,vec3 p,vec3 n,float r,float inr,vec3 objcol,out vec3 col,inout float minlen)\n{ //https://www.shadertoy.com/view/tsdfW8 but modified\n    p = ro-p;\n    if (length(p)<r+steps)\n    {\n      vec3 d = dot(p, n) * n;\n      vec3 o = p - d;\n      o -= normalize( o ) * min( length( o ), r );\n      float sdf = max(-(length(p)-inr),length( d + o ));\n      sdf += fract(dot(sin(iTime)*ro,cross(p,n)))*0.0;\n      if (sdf < minlen)\n      {\n         minlen = min(sdf,steps);\n         col = objcol;\n      }\n    }\n    else\n    {\n      minlen = min(steps,minlen);\n    }\n}\nfloat get_sdfs(in vec3 ro,out vec3 col)\n//https://www.shadertoy.com/view/tsdfW8\n{\n   float minlen = pow(10.0,10.0);\n   ring_sdf(ro,vec3(0),vec3(0,1,0),50.0,20.0,vec3(100000.0/pow(length(ro),4.0)),col,minlen);\n   sphere_sdf(ro,vec3(0),0.0,vec3(0),col,minlen);\n   sphere_sdf(ro,vec3(-40,20,0),10.0,vec3(0.8),col,minlen);\n   return minlen;\n}\n\nvec3 NewDir(in vec3 eyevec, in vec3 raypos)\n{\n    // from https://www.shadertoy.com/view/lstSRS\n    vec3 origin = vec3(0);\n    float Dist = distance(raypos, origin);\n    float warpFactor = 1.0 / ((Dist*Dist) + 0.000001);\n    vec3 singularityVector = normalize(origin - raypos);    \n    float warpAmount = 1.0;\n    return normalize(eyevec + singularityVector * warpFactor * warpAmount );\n}\nvoid shoot_ray(in vec3 ro, in vec3 rd, out vec3 col)\n{\n   rayinfo ray = rayinfo(ro,rd,vec3(1));\n   bool hit = false;\n   float sdf;\n   float raylen;\n   for(raylen = 0.0; !(raylen > max_len || hit); raylen += sdf)\n   {\n     ray.dir = NewDir(ray.dir,ray.origin);\n     sdf = get_sdfs(ray.origin,col);\n     ray.origin += sdf*ray.dir;\n     hit = sdf <= epsilon;\n   }\n   if (!hit){\n     col = texture(iChannel1,ray.dir).rgb;\n   }\n   col = pow(col,vec3(1.0/2.2));\n}\n\nvec3 pix_col(in vec2 coord, in float focalen)\n{\n   vec3 raydir = normalize(vec3(coord,focalen));\n   vec3 col;\n   shoot_ray(vec3(0,4.5,-150),raydir,col);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 60){\n      vec2 coord = (fragCoord-(0.5*iResolution.xy))/(iResolution.yy/1.0);\n      vec3 col = pix_col(coord,1.1);\n      fragColor = vec4(col,1.0);\n    }\n    else{\n      vec3 col = texelFetch(iChannel0,ivec2(fragCoord),0).rgb;\n      fragColor = vec4(col,1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}