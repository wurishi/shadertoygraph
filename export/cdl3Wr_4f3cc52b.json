{"ver":"0.1","info":{"id":"cdl3Wr","date":"1665979959","viewed":75,"name":"Metaballs 234sz","username":"csgradle","description":"metaballs :)","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["metaball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 1000.\n#define MIN_HIT 0.01\n\n\nvec3 colors[7] = vec3[7](\n    vec3(7., 141., 112.),\n    vec3(38., 206., 170.),\n    vec3(152., 232., 193.),\n    vec3(255., 255., 255.),\n    vec3(123., 173., 226.),\n    vec3(80., 73., 204.),\n    vec3(61., 26., 120.)\n);\nvec3 getColor(float t) {\n    return colors[int(floor(clamp(t*3., 0.0, 7.0)))] / 255.;\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0.1, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\nvec3 rotation(vec3 point, vec3 axis, float angle){ // https://www.shadertoy.com/view/Wtl3zN\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    mat4 rot= mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,0.0,0.0,1.0);\n    return (rot*vec4(point,1.)).xyz;\n}\n\nfloat getDist(vec3 p) {\n    float dist = MAX_DIST; \n    // dist = min(dist,  p.y- (-0.5));\n    \n    vec3 b1 = vec3(cos(iTime), sin(iTime), 0);\n    float db1 = length(b1-p)-0.5;\n    vec3 b2 = vec3(cos(iTime*1.5), sin(iTime*1.5), 0);\n    float db2 = length(b2-p)-0.5;\n    \n    float db3 = sdTorus(\n        rotation(vec3(cos(iTime*0.3), sin(iTime*0.3), 0.)-p, vec3(1.0, 0., 0.), iTime), \n        vec2(1.0, 0.2));\n    \n    \n    float da = smin(db1, db2, 0.6);\n    float db = smin(da, db3, 0.6);\n    \n    dist = min(dist, db);\n    return dist;\n}\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0.);\n    float d = getDist(p);\n    vec3 n = d-vec3(getDist(p-e.xyy), getDist(p-e.yxy), getDist(p-e.yyx));\n    return normalize(n);\n}\nfloat rayMarch(vec3 ro, vec3 rd) {\n\n    float rayDist = 0.;\n    for(int step = 0; step < MAX_STEPS; step++) {\n        vec3 pos = ro + rd*rayDist;\n        float distanceHit = getDist(pos);\n        rayDist += distanceHit;\n        if(distanceHit < MIN_HIT || rayDist > MAX_DIST) break;   \n    }\n    return rayDist;\n}\nfloat getLight(vec3 p, vec3 sun) {\n    \n    vec3 n = getNormal(p);\n    float lighting = dot(n, normalize(sun-p));\n    lighting = clamp(lighting, 0., 1.);\n    \n    float d = rayMarch(p+n*MIN_HIT*1.7, normalize(sun-p));\n    if(d < length(sun- p)) {\n        lighting = lighting * 0.5;\n    }\n    return lighting;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =  ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n    \n    vec3 col = vec3(100., 100., 100);\n    \n    vec3 rayOrigin = vec3(0.,0.,-4.);\n    vec3 rayDir = normalize( \n                   rotation( \n                       vec3( uv.x, uv.y, 1.),\n                       vec3(0., 1., 0.),\n                       0.\n                       ) );\n    vec3 sun = vec3(20., 15., -20.);\n    \n    \n    float d = rayMarch(rayOrigin, rayDir);\n    vec3 p = rayOrigin+rayDir*d;\n    float l = getLight(p, sun);\n    col = vec3(getColor(l));\n    if (d > MAX_DIST/2.0 - 5.0) {\n        col = vec3(1.);\n    }\n    \n    \n    fragColor = vec4(col,1.);\n} \n\n\n\n","name":"Image","description":"","type":"image"}]}