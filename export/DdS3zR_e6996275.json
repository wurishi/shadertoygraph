{"ver":"0.1","info":{"id":"DdS3zR","date":"1667251055","viewed":133,"name":"Digital Ocean","username":"Oneleven","description":"This was supposed to be another feedback study, but I needed something to put on foreground.\nWell, now it's also a raymarch study too!","likes":9,"published":1,"flags":96,"usePreview":0,"tags":["noise","terrain","raymarch","stars","feedback"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"ltSXD1","filepath":"https://soundcloud.com/snowfxmusic/3-morning-prayer?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","previewfilepath":"https://soundcloud.com/snowfxmusic/3-morning-prayer?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define T iTime\n#define pix 2.0/iResolution.y\n\n//Terrain Noise\n#define FREQUENCY 0.2\n#define OCTAVES 3.0\n#define AMPLITUDE 1.5\n#define GAIN 0.5\n#define LACUNARITY 2.0\n\n//Raymarch\n#define EPSILON 1e-4\n#define MAX_STEPS 64\n#define MAX_DIST 50.0\n\n//FabriceNeyret2 + IQ hash\n//https://www.shadertoy.com/view/fsKBzw\nfloat hash( vec2 f ) {   \n    uvec2 x = uvec2( floatBitsToUint(f.x), floatBitsToUint(f.y) ),\n          q = 1103515245U * ( x>>1U ^ x.yx    );\n    return float( 1103515245U * (q.x ^ q.y>>3U) ) / float(0xffffffffU);\n}\n\nfloat vNoise(vec2 uv)\n{\n    vec2 index = floor(uv);\n    uv = fract(uv);\n    uv = smoothstep(0., 1., uv);\n    \n    float x1 = mix(hash(index), hash(index + vec2(1., 0.)), uv.x);\n    float x2 = mix(hash(index + vec2(0., 1.)), hash(index + vec2(1)), uv.x);\n    return mix(x1, x2, uv.y);\n}\n\n\nfloat fbm(vec2 uv) \n{\n    float frequency = FREQUENCY; \n    float amplitude = AMPLITUDE;\n    float value = 0.;\n    for (float i = 0.; i < OCTAVES; i++)\n    {\n        value += vNoise(uv * frequency + floor(cos(i*3.141592)) * T * 0.4) * amplitude;\n        amplitude *= GAIN;\n        frequency *= LACUNARITY;\n    }\n    return value;\n}\n\nvec3 normal(vec3 p)\n{\n    float eps = 0.001;\n    return normalize(vec3(fbm(vec2(p.x - eps, p.z)) - fbm(vec2(p.x + eps, p.z)),\n                          2. * eps,\n                          fbm(vec2(p.x, p.z - eps)) - fbm(vec2(p.x, p.z + eps))));\n}\n\nfloat bisection(vec3 start, vec3 rayDir, float near_, float far_){\n    float midpoint = (far_ + near_) * 0.5;\n    //Sample point\n    vec3 p = vec3(0);\n    float near = near_;\n    float far = far_;\n    float height = 0.0;\n    //Difference between sample point and terrain heights\n    float diff = 0.0;\n    \n    for(int i = 0; i < 8; i++){\n        p = start + rayDir * midpoint;\n        height = fbm(vec2(p.x, p.z));\n        diff = p.y - height;\n        \n        if(abs(diff) < EPSILON){\n        \tbreak;\n        }else{\n            \n            if(diff < EPSILON){\n                //Point is below terrain\n                //Search first half\n                far = midpoint;\n            }else{\n                //Point is above terrain\n                //Search second half\n                near = midpoint;\n            }\n            midpoint = (far + near) * 0.5;\n        }\n    }\n    return midpoint;\n}\n\nfloat getIntersection(vec3 start, vec3 rayDir, float maxDist){\n\t//Distance between sample points. Set according to previous sample\n    float stepSize = 0.0;\n    //Height of the terrain\n    float height = 0.0;\n    //Length of the ray\n    float dist = 0.0;\n    //Difference between sample point and terrain heights\n    float diff = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++){\n        //Sample point\n        vec3 p = start + rayDir * dist;\n        \n        //The height of the terrain at the xz coordinates of the sample point\n        height = fbm(vec2(p.x, p.z));\n        diff = abs(p.y - height);\n        //If sample point is close enough to the terrain, return distance\n        if(diff < EPSILON){\n            return dist;\n        }\n        //If height of sample point is less than the height of the terrain,\n        //the ray has hit the terrain. Use bisection to find the 0 crossing\n        if(p.y < height){\n        \tdist = bisection(start, rayDir, dist - stepSize, dist);\n            return dist;\n        }\n        \n        //Static step size misses features and leads to banding. \n        //Set the step size to a fraction of the distance above the terrain.\n        //Could also have a small step size which increases with distance, giving \n        //detailed results close to the camera and reaching far. However, \n        //this approach is used in many shaders and seems to give best results\n        stepSize = diff * 0.5;\n        \n        //Increment ray\n        dist += stepSize;\n        \n        if(dist > MAX_DIST){\n        \treturn MAX_DIST;\n        }\n    }\n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.x;\n    \n    //camera tutorial by BigWIngs (ArtOfCode)\n    //https://www.youtube.com/watch?v=PBxuVlp7nuM&t=130s\n    vec3 ro = vec3(0., 7., 0.);\n    vec3 lp = vec3(0., 5., 50.);\n    \n    vec3 f = normalize(lp - ro);\n    vec3 r = normalize(cross(vec3(0., 1., 0.), f));\n    vec3 u = cross(f, r);\n    vec3 rd = f + r * uv.x + u * uv.y;\n    \n    float dist = getIntersection(ro, rd, MAX_DIST);\n    vec3 pp = ro + rd * dist;\n    vec3 n = normal(pp);\n    \n    vec3 colFront = texture(iChannel0, fract(mix(n.xy, pp.xz * 0.035 + 20., 0.97) + vec2(sin(T) * 0.1, T * 0.1))).rgb;\n    vec3 colBack = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    vec3 col = mix(colFront, colBack, smoothstep(MAX_DIST - 0.5, MAX_DIST, dist));\n\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.141592\n#define BORDER 2\n\n//\"Hash without Sine\" by Dave_Hoskins\n//https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//\"Color temperature (sRGB)\" by BeRo\n//https://www.shadertoy.com/view/4sc3D7\nvec3 colorTemperatureToRGB(const in float temperature){  \n     mat3 m = (temperature <= 6500.0) ? mat3(vec3(0.0, -2902.1955373783176, -8257.7997278925690),\n\t                                         vec3(0.0, 1669.5803561666639, 2575.2827530017594),\n\t                                         vec3(1.0, 1.3302673723350029, 1.8993753891711275)) : \n\t \t\t\t\t\t\t\t\t    mat3(vec3(1745.0425298314172, 1216.6168361476490, -8257.7997278925690),\n   \t                                         vec3(-2666.3474220535695, -2173.1012343082230, 2575.2827530017594),\n\t                                         vec3(0.55995389139931482, 0.70381203140554553, 1.8993753891711275)); \n  return mix(clamp(vec3(m[0] / (vec3(clamp(temperature, 1000.0, 40000.0)) + m[1]) + m[2]), vec3(0.0), vec3(1.0)), vec3(1.0), smoothstep(1000.0, 0.0, temperature));\n}\n\n//\"GLOW TUTORIAL\" by alro\n//https://www.shadertoy.com/view/3s3GDn\nfloat glow (float radius, float size, vec2 uv)\n{\n    return clamp(pow(radius/length(uv), size), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0)\n        {\n            fragColor = vec4(vec3(0.0), 1.0);\n            return;\n        }\n\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y - vec2(0.45, -0.15);\n    \n    float t=iTime*0.20;\n    uv*=mat2(cos(t), sin(t), cos(t+PI*0.5), sin(t+PI*0.5));\n    uv*=15.0;\n    \n    vec2 index = floor(uv);\n    uv = fract(uv);\n    \n    vec3 star = vec3(0.0);\n    for (int x = -BORDER; x<=BORDER; x++)    \n    {\n        for (int y = -BORDER; y<=BORDER; y++)\n        {\n                vec2 offset = hash22(index+vec2(x,y));\n                float h = hash12(index+vec2(x,y));\n                vec3 color = colorTemperatureToRGB(mix(1000.0, 14000.0, h));\n                star += glow(mix(0.011, 0.02, h), mix(1.4, 4.0, h), uv - vec2(0.5) - vec2(x,y) - offset * 1.0) * color;\n        }\n    }\n    \n    vec3 col = texture(iChannel0, fragCoord.xy/iResolution.xy).rgb*0.985 + clamp(vec3(star), 0.0, 1.0);\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}