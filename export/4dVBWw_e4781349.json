{"ver":"0.1","info":{"id":"4dVBWw","date":"1529074128","viewed":150,"name":"a rotating sphere","username":"elgecko","description":"this is my first shader, so feel free to give me comment to inprove it :)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float interp(float a, float b, float p)\n{\n    return mix(a, b, p*p*(3.-2.*p));\n}\n\nfloat rand(vec3 pos)\n{\n    /*float a = (sin(1456.549*pos.x)*1135.987+sin(1943.412*pos.y)*1547.997+sin(1759.331*pos.z)*1737.973)*68.657;\n    return (a-floor(a));*/\n    \n    /*if(mod(max(max(abs(pos.x),abs(pos.y)),abs(pos.z)),2.)<1.)\n    \treturn 1.;\n    return 0.;*/\n    \n    return floor(abs(sin(pos.x)+sin(pos.y)+sin(pos.z)));\n    return floor(abs(pos.x)*abs(pos.y)*abs(pos.z)/length(pos)/length(pos));\n    return floor(mod(dot(pos,pos.yzx),2.));\n    return floor(mod(pos.x+pos.y+pos.z,2.));\n    return 1.-floor(mod(pos.x*pos.y*pos.z,2.));\n}\n\nfloat noise3d(vec3 pos)\n{\n    vec3 e = vec3(floor(pos.x),floor(pos.y),floor(pos.z));\n    vec3 a = pos - e;\n    float xyz = rand(e + vec3(0.,0.,0.));\n    float Xyz = rand(e + vec3(1.,0.,0.));\n    float xYz = rand(e + vec3(0.,1.,0.));\n    float XYz = rand(e + vec3(1.,1.,0.));\n    float xyZ = rand(e + vec3(0.,0.,1.));\n    float XyZ = rand(e + vec3(1.,0.,1.));\n    float xYZ = rand(e + vec3(0.,1.,1.));\n    float XYZ = rand(e + vec3(1.,1.,1.));\n    return interp(interp(interp(xyz,Xyz,a.x),interp(xYz,XYz,a.x),a.y),interp(interp(xyZ,XyZ,a.x),interp(xYZ,XYZ,a.x),a.y),a.z);\n}\n\n/*\nsv is the input vector\nrv is the axis of rotation\nangle is the angle of rotation\n*/\nvec3 rotation( in vec3 sv, in vec3 rv, in float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n\tvec3 sv2;\n    sv2.x = (rv.x*rv.x*(1.0-c)+c)*sv.x + (rv.x*rv.y*(1.0-c)-rv.z*s)*sv.y + (rv.x*rv.z*(1.0-c)+rv.y*s)*sv.z;\n    sv2.y = (rv.x*rv.y*(1.0-c)+rv.z*s)*sv.x + (rv.y*rv.y*(1.0-c)+c)*sv.y + (rv.y*rv.z*(1.0-c)-rv.x*s)*sv.z;\n    sv2.z = (rv.x*rv.z*(1.0-c)-rv.y*s)*sv.x + (rv.y*rv.z*(1.0-c)+rv.x*s)*sv.y + (rv.z*rv.z*(1.0-c)+c)*sv.z;\n    return sv2;\n}\n\nvec4 pokeball(in vec3 sv)\n{\n    vec4 fragColor;\n    if(sv.z>=0.991)\n      \tfragColor = vec4(1.0,1.0,1.0,0.0);\n    else if(sv.z>=0.99)\n       \tfragColor = vec4(0.0,0.0,0.0,0.0);\n    else if(sv.z>=0.97)\n       \tfragColor = vec4(1.0,1.0,1.0,0.0);\n    else if(sv.z>=0.95||abs(sv.y)<=0.05)\n       \tfragColor = vec4(0.0,0.0,0.0,0.0);\n    else if(sv.y>=0.0)\n        fragColor = vec4(1.0,0.0,0.0,0.0);\n    else\n        fragColor = vec4(1.0,1.0,1.0,0.0);\n    return fragColor;\n}\n\nvec4 chromaticSphere(in vec3 sv)\n{\n    vec4 fragColor = vec4(sv/2.+.5,0.);\n    return fragColor;\n}\n\nvec4 shader(in vec3 sv)\n{\n    vec4 fragColor = texture(iChannel0, sv);\n    return fragColor;\n}\n\n//not finised yet\nvec4 noise(in vec3 sv)\n{\n    float freq = iTime;\n    vec4 fragColor = vec4(vec3(.5*noise3d(sv*freq)+.5*.5*noise3d(sv*freq*2.)+.5*.5*.5*noise3d(sv*freq*2.*2.)+.5*.5*.5*.5*noise3d(sv*freq*2.*2.*2.)),0.0);\n    return fragColor;\n}\n\n//used to test rotation()\nvec4 shaderTest(in vec3 sv)\n{\n    vec4 fragColor = vec4(0.0,0.0,0.0,0.0);\n    if (mod(sv.x, 0.2)<=0.1)\n        fragColor.x = 1.0;\n    if (mod(sv.y, 0.2)<=0.1)\n        fragColor.y = 1.0;\n    if (mod(sv.z, 0.2)<=0.1)\n        fragColor.z = 1.0;\n    return fragColor;\n}\n\n//project v on target\nfloat orthProj(in vec3 v, in vec3 target)\n{\n    vec3 w = target/length(target);\n    float a = v.x*w.x+v.y*w.y+v.z*w.z;\n    return a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rot = vec3(0,10,0); //rotation axis\n    vec3 light = vec3(sin(iTime),1,1); //origine of light\n    float speed = iTime*2.; //rotation speed\n    float sphereRadius = 150.0; //radius of the sphere\n    vec2 sphereCenter; //center of the sphere\n    if (iMouse.xy == vec2(0.0,0.0))\n        sphereCenter = iResolution.xy/2.0;\n    else\n    \tsphereCenter = iMouse.xy;\n    \n    rot = rot/length(rot);\n    vec2 fragSphere = fragCoord.xy-sphereCenter.xy;\n    if (length(fragSphere)>sphereRadius)\n    {\n\t    // Normalized pixel coordinates (from 0 to 1)\n\t    vec2 uv = fragCoord/iResolution.xy;\n\t\n\t    // Time varying pixel color\n\t    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\t\n\t    // Output to screen\n\t    fragColor = vec4(0.0,0.0,0.0,0.0);\n    }\n    else\n    {\n        vec2 uv = fragSphere.xy/sphereRadius;\n        vec3 sv = vec3(uv,0);\n        sv.z = sqrt(1.0 - sv.x*sv.x - sv.y*sv.y);\n        vec3 svf = rotation(sv, rot, speed);\n        fragColor = mix(pokeball(svf),vec4(1.0,1.0,1.0,0.0),0./*pow(max(0.0,orthProj(sv,light)),4.0)*/); //change the function to get an other sphere\n    }\n}\n/*chromaticSphere pokeball shaderTest noise*/","name":"Image","description":"","type":"image"}]}