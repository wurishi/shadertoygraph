{"ver":"0.1","info":{"id":"ltG3Rc","date":"1475804261","viewed":252,"name":"Liquid Gold","username":"efairbanks","description":"Morphy gold thing.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","lighting","morph","plaid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MARCH_STEPS 50.0\n#define MARCH_EPSILON 0.04\n#define SHADOW_STEPS 50.0\n#define SHADOW_EPSILON 0.005\n#define GRADIENT_STEP 0.02\n#define AA\n//#define RENDER_DISTANCE\n\n#define M_PI 3.1415926535897932384626433832795\n\nfloat sphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// --- //\n\n// field of view of camera\n#define FOV 0.15\nfloat CAMERA_DISTANCE = 40.;\n// generate combined distance field\nfloat map(vec3 p)\n{\n\tfloat d;\n    \n    vec3 q = p;\n    q = q - vec3(0.,-1.,0.);\n    q.x = q.x + 0.6*cos((iTime*2.+q.y)*2.*M_PI/3.);\n    q.z = q.z + 0.4*cos((iTime*3.+q.y)*2.*M_PI/3.);\n    d = sphere(q, 2.);\n \t\n    // ground plane\n    float planeWidth = 5.;\n    float e = -p.y+2.+MARCH_EPSILON;\n    e = max(e, -(planeWidth - abs(p.z)));\n    e = max(e, -(planeWidth - abs(p.x)));\n\n    d = min(d, e);\n        \n\treturn d;\n}\n\n// raymarching procedure with lots of output info\nvoid march(vec3 origin, vec3 direction, out vec3 rayHead, out bool hit, out float dist, out float steps)\n{\n    float distanceTraveled = 0.;\n    hit = true;\n    for(float step=0.; step<MARCH_STEPS; step++)\n    {\n        //rayHead = origin + (direction*distanceTraveled);\n        rayHead = origin + (direction*distanceTraveled)*.5;\n        dist = map(rayHead);\n        steps = step;\n        if(dist<MARCH_EPSILON||step>=MARCH_STEPS) return;\n        distanceTraveled += dist;\n    }\n    hit = false;\n}\n\n// get origin and direction of ray to be cast for camera/screen xy (pixel) coordinate\nvoid cameraRay(vec2 scanLines, vec3 cameraPosition, vec3 target, float fov, out vec3 pos, out vec3 dir)\n{\n\tvec3 forward = normalize(target-cameraPosition);\n    vec3 up = vec3(0.,1.,0.);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(forward,right));\n    \n    right = right*scanLines.x*fov;\n    up = up*scanLines.y*fov;\n    \n    pos = cameraPosition;\n    dir = (right+up+forward);\n}\n\n// get surface normal of point on distance field for shading\nvec3 gradient( vec3 pos )\n{\n\tconst vec3 dx = vec3( GRADIENT_STEP, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, GRADIENT_STEP, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, GRADIENT_STEP );\n\treturn normalize(vec3(\n\t\tmap( pos + dx ) - map( pos - dx ),\n\t\tmap( pos + dy ) - map( pos - dy ),\n\t\tmap( pos + dz ) - map( pos - dz )\n\t));\n}\n\n// calculate diffuse lighting for point on distance field given surface normal\nfloat diffuse(vec3 normal, vec3 lightPosition)\n{\n\treturn max(dot(normal,normalize(lightPosition)),0.);\n}\n\n// calculate diffuse lighting for point on distance field\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<int(SHADOW_STEPS); i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<SHADOW_EPSILON || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// calculate combined lighting for point on distance field\nfloat shadePoint(vec3 position, vec3 normal, vec3 lightPosition)\n{\n    float diffuseLight = diffuse(normal, lightPosition);\n\t// speculative light - it might be specular, but we're not really sure\n    float specularLight = pow(diffuseLight,50.);\n\tfloat shadow = softshadow(position, lightPosition, 0.02, 2.25);\n    float ambient = 0.1;\n    return (diffuseLight*0.4+specularLight*2.9)*shadow+ambient;\n}\n\n// generate background color\nvec3 background(vec2 uv)\n{\n    return vec3(0.,0.,0.);\n\t//return vec3(0.5,0.5,0.5)*uv.y;\n}\n\nvec4 getPixel(vec2 fragCoord)\n{\n    // scale coordinates to -1 -> +1, adjusted for screen aspect ratio\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv*2.-1.;\n    uv.x = uv.x*iResolution.x/iResolution.y;\n    \n    // get mouse coords\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    // get ray representing camera scanline position and direction\n    float cameraRotationSpeed = 0.2;\n    vec3 cameraPosition = normalize(vec3(sin(iTime*cameraRotationSpeed),\n                                         -.15,\n                                         cos(iTime*cameraRotationSpeed)));\n    if(iMouse.z>0.)\n        cameraPosition = normalize(vec3(\tsin(mouse.x*2.*M_PI),\n                                        \t-((1.-mouse.y)*2.)-0.001,\n                                        \tcos(mouse.x*2.*M_PI)));\n    cameraPosition *= CAMERA_DISTANCE;\n    vec3 cameraOrigin;\n    vec3 cameraDirection;\n    cameraRay(uv, cameraPosition, vec3(0.,0.,0.), FOV, cameraOrigin, cameraDirection);\n    \n    // calculate distance, hit point, etc of distance field via raymarching\n    vec3 rayHead;\n    bool hit;\n    float dist;\n    float steps;\n    march(cameraOrigin, cameraDirection, rayHead, hit, dist, steps);\n    \n    // calculate normal for point on distance field\n    vec3 normal = gradient(rayHead);\n    \n    // calculate light for point\n    vec3 rotLightPos = vec3(sin(iTime),-1.5,cos(iTime));\n    float light = 0.;\n    light += shadePoint(rayHead, normal, rotLightPos)*2.;\n\n   \tvec3 lightPos;\n    lightPos = vec3(1.,-0.5,1.);\n    light += shadePoint(rayHead, normal, lightPos)*0.6;\n    lightPos = vec3(-1.,-0.5,1.);\n    light += shadePoint(rayHead, normal, lightPos)*0.6;\n    lightPos = vec3(1.,-0.5,-1.);\n    light += shadePoint(rayHead, normal, lightPos)*0.6;\n    lightPos = vec3(-1.,-0.5,-1.);\n    light += shadePoint(rayHead, normal, lightPos)*0.6;\n    \n    \n    light /= 2.;\n    \n    // specify color of entire distance field\n    vec3 fieldColor = vec3(1.,0.8,0.5);\n    if(rayHead.y-2. > -0.001) {\n        float checkerMask = (mod(rayHead.x,1.)>0.5?1.:0.) + (mod(rayHead.z,1.)>0.5?1.:0.)/2.;\n        fieldColor = vec3(0.9,0.9,1.)*(checkerMask*0.7+0.3);\n    }\n    // final steps and background\n    vec3 color = fieldColor*light;\n    if(!hit) color = background(uv);\n    \n    // distance map\n    #ifdef RENDER_DISTANCE\n    color = vec3(steps/MARCH_STEPS);\n    #endif\n    \n    float vignette = 1.;\n    vignette *= pow(1.-abs(uv.x/2.), 0.9);\n    vignette *= pow(1.-abs(uv.y), 1.);\n    color *= vignette;\n    \n    // set fragment shader color\n    return vec4(color,1.);\n}\n\n// compose image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aaX = fragCoord;\n    aaX.x += 0.5;\n    vec2 aaY = fragCoord;\n    aaY.y += 0.5;\n\tvec4 color = getPixel(fragCoord);\n    #ifdef AA\n    color += getPixel(aaX);\n    color += getPixel(aaY);\n    color /= 3.;\n    #endif\n    fragColor = color;\n}\n\n","name":"Image","description":"","type":"image"}]}