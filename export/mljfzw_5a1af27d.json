{"ver":"0.1","info":{"id":"mljfzw","date":"1693902285","viewed":50,"name":"brutish force","username":"graygoose","description":"much artifact to fix, but mmm shiny\n\nguessing either bounce off max dist is a problem.","likes":2,"published":1,"flags":32,"usePreview":1,"tags":["tracer","buggy","broken","slow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 Q) {\n    vec4 color = texture(iChannel0, Q / iResolution.xy);\n    fragColor = vec4(color.xyz, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Utils\nvec3 rotateX(vec3 p, float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\nvec3 rotateY(vec3 p, float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return vec3(c*p.x - s*p.z, p.y, s*p.x + c*p.z);\n}\n\nvec3 rotateZ(vec3 p, float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nfloat sphereSDF(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\nfloat capsuleSDF(vec3 p, vec3 a, vec3 b, float radius) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - radius;\n}\n\nfloat cylinderSDF(vec3 p, vec3 a, vec3 b, float radius) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - radius;\n}\n\nfloat triangleSDF(vec3 p, vec3 a, vec3 b, vec3 c) {\n    vec3 ba = b - a;\n    vec3 ca = c - a;\n    vec3 pa = p - a;\n\n    vec3 nor = cross(ba, ca);\n\n    float d = abs(dot(nor, pa));\n    float l = length(nor);\n    float h = d / l;\n\n    float b1 = dot(cross(pa, ca), nor) < 0.0 ? 0.0 : 1.0;\n    float b2 = dot(cross(pa, ba), nor) < 0.0 ? 0.0 : 1.0;\n    float b3 = 1.0 - b1 - b2;\n\n    vec3 closest = b1 * a + b2 * b + b3 * c;\n\n    return length(p - closest);\n}\n\nfloat planeSDF(vec3 p, vec3 normal, float d) {\n    return dot(p, normal) + d;\n}\n\nfloat boxSDF(vec3 p, vec3 size) {\n    vec3 d = abs(p) - size;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat boxSDF(vec3 p, vec3 center, vec3 size) {\n    vec3 d = abs(p - center) - size;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat torusSDF(vec3 p, vec3 center, float r1, float r2) {\n    vec2 q = vec2(length(p.xz - center.xz) - r1, p.y);\n    return length(q) - r2;\n}\n\n#define PI 3.14159\n#define phi 1.618\nconst vec3 icosahedron[12] = vec3[](\n    vec3(-1.0,  phi, 0.0),\n    vec3( 1.0,  phi, 0.0),\n    vec3(-1.0, -phi, 0.0),\n    vec3( 1.0, -phi, 0.0),\n    \n    vec3(0.0, -1.0,  phi),\n    vec3(0.0,  1.0,  phi),\n    vec3(0.0, -1.0, -phi),\n    vec3(0.0,  1.0, -phi),\n    \n    vec3( phi, 0.0, -1.0),\n    vec3( phi, 0.0,  1.0),\n    vec3(-phi, 0.0, -1.0),\n    vec3(-phi, 0.0,  1.0)\n);\n\nfloat icosahedronSDF(vec3 p,float scale){\n    const float INF=1e10;\n    float d=INF;\n    vec3 scaledIcoVert,scaledIcoEdge;\n    \n    for(int i=0;i<12;i++){\n        scaledIcoVert=2.*scale*icosahedron[i];// Scaling factor for vertices\n        \n        // Vertices\n   \n        d=min(d,sphereSDF(p,scaledIcoVert,1.));\n        \n        for(int j=i+1;j<12;j+=4){\n            scaledIcoEdge=2.*scale*icosahedron[j];// Scaling factor for edges\n            \n            // Edges\n            d=min(d,cylinderSDF(p,scaledIcoVert,scaledIcoEdge,.1));\n        }\n        \n        // Faces\n        //if(i%2==0){\n        //    d=min(d,triangleSDF(p,scaledIcoVert,2.*scale*icosahedron[i+1],2.*scale*icosahedron[(i+2)%12]));\n        //}\n    }\n    \n    return d;\n}\n\nconst vec3 DIFFUSE_COLOR = vec3(1.,1.,1.);\nconst vec3 SPECULAR_COLOR = vec3(1.0, 1.0, 1.0);\n\nconst vec3 lightColor = vec3(1.0, 1.0, 1.0);\nconst vec3 lightPos = vec3(00.0, 190.0, -50.0);\nconst float lightIntensity = 1.0;\n\n//#define SCENE_ROTATE\nfloat sceneSDF(vec3 p) {\n#ifdef SCENE_ROTATE\n    if (iMouse.z < 0.0) {\n        p = rotateX(p, iTime*0.001);\n        p = rotateY(p, iTime*0.001);\n        p = rotateZ(p, iTime*0.001);\n    }\n    else {\n        p = rotateX(p, -iMouse.y*0.01);\n        p = rotateY(p, iMouse.x*0.01);\n        p = rotateZ(p, -iMouse.y*0.01);\n    }\n#endif \n\n    // Build scene here.\n    float d = icosahedronSDF(p, 1.0);\n\n    return d;\n}\n\n#define SURFACE_DISTANCE 0.00001\nvec3 estimateNormal(vec3 p, float d) {\n    vec3 n = vec3(\n        d - sceneSDF(vec3(p.x + SURFACE_DISTANCE, p.y, p.z)),\n        d - sceneSDF(vec3(p.x, p.y + SURFACE_DISTANCE, p.z)),\n        d - sceneSDF(vec3(p.x, p.y, p.z + SURFACE_DISTANCE))\n    );\n    return -normalize(n);\n}\n\n#define MAX_STEPS 64\n#define MAX_DISTANCE 15.0\n#define MAX_BOUNCES 3\n#define SHADOW_DISTANCE 1.0\n#define ATTENUATE_FACTOR .9\nvec3 traceRay(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    vec3 accumulatedColor = vec3(0.0);\n    vec3 attenuation = vec3(1.0);\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 pos = ro + t * rd;\n        float dist = sceneSDF(pos);\n        \n        if (dist < SURFACE_DISTANCE) {\n            for (int bounces = 0; bounces < MAX_BOUNCES; bounces++) {\n                vec3 normal = estimateNormal(pos, dist);\n                \n                float shadowFactor = 1.0;\n                vec3 toLight = normalize(lightPos - pos);\n                vec3 shadowRayOrigin = pos + SHADOW_DISTANCE * toLight;\n                float shadowT = 0.0;\n                \n                for (int j = 0; j < 2; j++) {\n                    vec3 shadowPos = shadowRayOrigin + shadowT * toLight;\n                    float shadowDist = sceneSDF(shadowPos);\n                    if (shadowDist < SHADOW_DISTANCE) {\n                        shadowFactor = 0.0;\n                        break;\n                    }\n                    shadowT += shadowDist;\n                    if (shadowT > MAX_DISTANCE) break;\n                }\n                \n                float diffuse = max(dot(-normal, toLight), 0.0);\n                float specular = pow(max(dot(reflect(toLight, -normal), -rd), 0.0), 16.0);\n                \n                vec3 localColor = shadowFactor * vec3(diffuse * lightIntensity) * DIFFUSE_COLOR * lightColor + \n                                  shadowFactor * specular * SPECULAR_COLOR * lightColor;\n                \n                accumulatedColor += attenuation * localColor;\n                \n                ro = pos + SURFACE_DISTANCE * normal;\n                rd = reflect(rd, normal);\n                \n                attenuation *= ATTENUATE_FACTOR;\n                \n                t = 0.0;\n                for (int j = 0; j < MAX_STEPS; j++) {\n                    pos = ro + t * rd;\n                    dist = sceneSDF(pos);\n                    if (dist < SURFACE_DISTANCE) {\n                        break;\n                    }\n                    t += dist;\n                    if (t > MAX_DISTANCE) break;\n                }\n            }\n            return accumulatedColor;\n        }\n        \n        t += dist;\n        if (t > MAX_DISTANCE) break;\n    }\n    \n    return accumulatedColor;\n}\n\nconst vec3 camOrigin = vec3(1.5, 0., -5.0);\n\nvoid mainImage(out vec4 fragColor, in vec2 Q) {\n    \n    vec4 oldColor = texture(iChannel0, Q / iResolution.xy);\n    fragColor = oldColor;\n    \n    if (iTime < 60. || iMouse.z > 0.){\n        vec2 uv = (Q - 0.5 * iResolution.xy) / iResolution.y;\n\n        vec2 seed = Q / iResolution.xy + vec2(iTime);\n        vec3 randomVec = vec3(\n            fract(sin(dot(seed, vec2(12.9898, 78.233)))*43758.5453),\n            fract(sin(dot(seed, vec2(63.7264, 12.182)))*15275.1234),\n            fract(sin(dot(seed, vec2(99.132, 41.253)))*11325.1337)\n        );\n\n        vec3 rayDir = normalize(vec3(uv, 1.0) + randomVec * 0.001); \n\n\n        fragColor = vec4(mix(oldColor.xyz, traceRay(camOrigin, rayDir), 0.005), 1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}