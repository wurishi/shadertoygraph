{"ver":"0.1","info":{"id":"wlccDf","date":"1610110233","viewed":81,"name":"My First Basic Ray Marcher","username":"CrazySheep05","description":"My first ray marcher based off this tutorial:\nhttps://www.youtube.com/watch?v=PGtv-dBi2wE\n\nI have added light attenuation, an emissive material and reflections, although they are slightly buggy.\n\nEdit: The reflections have been fixed.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int firstOctave = 3;\nconst int octaves = 8;\nconst float persistence = 0.6;\n\n//Not able to use bit operator like <<, so use alternative noise function from YoYo\n//\n//https://www.shadertoy.com/view/Mls3RS\n//\n//And it is a better realization I think\nfloat noise(int x,int y)\n{   \n    float fx = float(x);\n    float fy = float(y);\n    \n    return 2.0 * fract(sin(dot(vec2(fx, fy) ,vec2(12.9898,78.233))) * 43758.5453) - 1.0;\n}\n\nfloat smoothNoise(int x,int y)\n{\n    return noise(x,y)/4.0+(noise(x+1,y)+noise(x-1,y)+noise(x,y+1)+noise(x,y-1))/8.0+(noise(x+1,y+1)+noise(x+1,y-1)+noise(x-1,y+1)+noise(x-1,y-1))/16.0;\n}\n\nfloat COSInterpolation(float x,float y,float n)\n{\n    float r = n*3.1415926;\n    float f = (1.0-cos(r))*0.5;\n    return x*(1.0-f)+y*f;\n    \n}\n\nfloat InterpolationNoise(float x, float y)\n{\n    int ix = int(x);\n    int iy = int(y);\n    float fracx = x-float(int(x));\n    float fracy = y-float(int(y));\n    \n    float v1 = smoothNoise(ix,iy);\n    float v2 = smoothNoise(ix+1,iy);\n    float v3 = smoothNoise(ix,iy+1);\n    float v4 = smoothNoise(ix+1,iy+1);\n    \n   \tfloat i1 = COSInterpolation(v1,v2,fracx);\n    float i2 = COSInterpolation(v3,v4,fracx);\n    \n    return COSInterpolation(i1,i2,fracy);\n    \n}\n\nfloat PerlinNoise2D(float x,float y)\n{\n    float sum = 0.0;\n    float frequency =0.0;\n    float amplitude = 0.0;\n    for(int i=firstOctave;i<octaves + firstOctave;i++)\n    {\n        frequency = pow(2.0,float(i));\n        amplitude = pow(persistence,float(i));\n        sum = sum + InterpolationNoise(x*frequency,y*frequency)*amplitude;\n    }\n    \n    return sum;\n}\n\n\n//Shader designed based of this tutorial: https://www.youtube.com/watch?v=PGtv-dBi2wE\n//Tutorial project: https://www.shadertoy.com/view/XlGBW3\n\n#define MAXDIS 100.\n#define MAXSTEP 100\n#define SURFDIS 0.001\n#define LIGHTINTENSITY 5.\n#define LIGHTCOL vec3(1,.0,.5)\n\nfloat PerlinNoise3D(float x, float y, float z)\n {\n     float xy = PerlinNoise2D(x, y);\n     float xz = PerlinNoise2D(x, z);\n     float yz = PerlinNoise2D(y, z);\n     float yx = PerlinNoise2D(y, x);\n     float zx = PerlinNoise2D(z, x);\n     float zy = PerlinNoise2D(z, y);\n \n     return (xy + xz + yz + yx + zx + zy) / 6.;\n }\n\nfloat GetDis(vec3 p)\n{\n\tvec4 s = vec4(0, 1.05, 6, 1);\n    \n    float sd =  abs(length(p-s.xyz)-s.w)-.1;\n    float pd = p.y-1.;\n    \n    float d = max(sd, pd);\n    pd = p.y;\n    d=min(d,pd);\n    //d = min(d,cd);\n    //d=cd;\n    \n\ts = vec4(3, 1.05, 6, 1);\n    \n    sd =  abs(length(p-s.xyz)-s.w)-.1;\n    \n    d = min(d,sd);\n    \n\ts = vec4(1.5, 4, 7, 1);\n    \n    sd =  abs(length(p-s.xyz)-s.w)-.1;\n    \n    d = min(d,sd);\n    \n    d = PerlinNoise3D(p.x,p.y,p.z)*10.;\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    float d=.0;\n    \n    for(int i = 0; i<MAXSTEP; i++)\n    {\n        vec3 p = ro+rd*d;\n        float ds = GetDis(p);\n        d+=ds;\n        if(ds<SURFDIS || d>MAXDIS)\n        {\n            break;\n        }\n    }\n    \n    return(d);\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDis(p);\n    vec2 e = vec2(.01,0);\n    \n    vec3 n = d-vec3(\n    GetDis(p-e.xyy),\n    GetDis(p-e.yxy),\n    GetDis(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 TestMarch(vec3 ro, vec3 rd)\n{\n    float d=.0;\n    \n    for(int i = 0; i<MAXSTEP; i++)\n    {\n        vec3 p = ro+rd*d;\n        float ds = GetDis(p);\n        d+=ds;\n        if(ds<SURFDIS || d>MAXDIS)\n        {\n            break;\n        }\n    }\n    vec3 p = ro + rd * d;\n    p = p;\n    return(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n    vec3 ro = vec3(0, 5.+1.0*cos(iTime), -1);\n    vec3 rd = normalize(vec3(uv.x, uv.y-0.3, 0.7));\n    \n    vec3 p = TestMarch(ro, rd);\n    \n    //vec3 diff=GetLight(p);\n    \n    //vec3 n = GetNormal(p);\n    //vec3 pd = reflect(rd,n);\n    \n    //diff = max(GetLight(TestMarch(p+n*SURFDIS*2.,pd)),diff);\n    /*float ref = 0.2;\n    diff *= 1.-ref;\n    diff += ref;//*GetLight(TestMarch(p+n*SURFDIS*2.,pd));\n    \n    vec3 col = diff;*/\n    \n    fragColor = vec4(1.,1.,1.,1.0) * 1./(length(p)/5.);\n}","name":"Image","description":"","type":"image"}]}