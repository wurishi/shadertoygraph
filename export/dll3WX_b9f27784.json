{"ver":"0.1","info":{"id":"dll3WX","date":"1672598849","viewed":127,"name":"Brick pattern with asym Blocks","username":"kastorp","description":"mixing Shane asymmetric blocks with brick pattern.\na realistic wall should have random spots of those.\nclick mouse to show grid ","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["wall","bricks","asymmetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Brick pattern with asymmetric Blocks\" by Kastorp\n// see https://www.shadertoy.com/view/Ws3GRs for Asymmetric blocks \n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nbool BRICK(vec2 c, float t) {\n    return length(c)-t>=3. \n    && length(c -vec2(6,2))-t>=3.\n    && length(c -vec2(-7,-4))-t>=2.;    \n}\n\nfloat r(vec2 x) { \n    if(BRICK(x,0.) && mod(x.x,2.)!=mod(x.y,2.)) return 0.; //regular bricks have fixed height\n    return mix(hash12(x+floor(iTime)), hash12(x+floor(iTime+1.)),fract(iTime))*.8-.4;\n}\n\n#define line(x) smoothstep(max(28./iResolution.y,.02),0., abs(x))\nvoid mainImage( out vec4 O, in vec2 I )\n{\n   \n    vec2 uv = 14.*(I-.5*iResolution.xy)/iResolution.y;\n\n    vec2 c=floor(uv+.5),lc=fract(uv+.5)-.5,d=vec2(1,0);\n    bool odd = mod(c.x,2.)!=mod(c.y,2.), \n         brick =BRICK(c,1.), //true if regular brick \n         brick_d = !brick && BRICK(c+vec2(0,-1),1.) && odd, // brick upper neighbour\n         brick_u = !brick && BRICK(c+vec2(0,1),1.) && !odd; // brick lower neighbour\n         \n    vec3 brickC=vec3(.3,0,0), oddC=vec3(1,0,0),evenC=vec3(0,1,0),bordC=vec3(.2);\n    if(iMouse.z<=0.) { oddC=evenC=vec3(1.3);bordC=vec3(0);};\n    \n    if(odd){lc=lc.yx;d=d.yx;} // odd cells are crossed by horizontal line, even cells by a vertical line\n    float dx =lc.x - r(c), // position of the crossing line\n          dl= lc.y - r(c-d), // intersection of the left (or bottom) line\n          dr= lc.y - r(c+d); // intersection of the right (or top) line\n\n    //id= integer position of the top-right angle cell\n    vec2 id=vec2(        \n        max(step(dx,0.)*step(dl,0.),step(dx,0.)*step(0.,dl)),\n        max(step(0.,dx)*step(dr,0.),step(dx,0.)*step(dl,0.))\n        );        \n    id =  + c  - (odd?id.yx:id.xy);     \n    if(brick ) {id.x+=step(fract(id.y/2.),0.); id.x+= step(fract(id.x/2.),0.);}\n\n    vec3 col = .1*sin(id.x*1.57) +.05*cos(id.y*3.14)+\n       (odd? oddC :evenC)*  //debug brick color\n           (.2 + .8* line(dx)* //crossing line\n               (odd||!(brick || brick_u ) ?1. :step(min(dr,dl),0.)) //if regular brick and even, just half line\n             )\n       +  vec3(1) * step(0.,dx)*line(dr) //right (or top) line\n       +  vec3(1) * (odd && (brick || brick_d)? 0.: step( dx,0.)*line(dl)) //left (or bottom) line \n       +  brickC *(brick?1.:0.) //cell type\n       +  bordC *(brick_u ||brick_d?1.:0.) //debug brick neighbour cells\n      ;\n    O = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}