{"ver":"0.1","info":{"id":"tdVfDz","date":"1606952148","viewed":180,"name":"Moorish Rose","username":"athibaul","description":"My favorite chainmail pattern: [url=https://www.mailleartisans.org/weaves/weavedisplay.php?key=1078]Moorish Rose[/url].","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["sdf","weaving","chainmail"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ##############\n//  MOORISH ROSE\n// ##############\n\n// My favorite chainmail pattern:\n// https://www.mailleartisans.org/weaves/weavedisplay.php?key=1078\n\n// Created through domain repetition in a simple raymarcher \n// with basic image-based shading.\n\n\n// Anti-aliasing: set to 2. if your GPU is powerful\n#define AA 1.\n\n#define R(th) mat2(cos(th),sin(th),-sin(th),cos(th))\n\nfloat dTorus(vec3 p, float r_large, float r_small)\n{\n    float h = length(p.xy) - r_large;\n    float d = sqrt(h*h + p.z*p.z) - r_small;\n    return d;\n}\n\nfloat torusGrid(vec3 p, float r_small, float r_large, float angle, vec2 sep)\n{\n    p += vec3(0,sep.y/2.,0);\n    vec3 q = p - vec3(round(p.xy/sep)*sep,0) - vec3(0,sep.y/2.,0);\n    q.yz *= R(angle);\n    float d = dTorus(q, r_large, r_small);\n    q = p - vec3(round(p.xy/sep)*sep,0) - vec3(0,-sep.y/2.,0);\n    q.yz *= R(angle);\n    d = min(d, dTorus(q, r_large, r_small));\n    return d;\n}\n\nfloat map(vec3 p)\n{\n    // Warp space\n    #if 1\n    p.x += 0.5*cos(0.2*p.y);\n    p.y += 0.3*cos(0.3*p.x);\n    p.z += 0.3*sin(0.3*p.y+0.2*p.x);\n    #endif\n    \n    // Weave\n    float d = 1e5;\n    for(float i=0.;i<6.;i++)\n    {\n        vec3 q = p;\n        q.xy *= R(2.*3.14159*i/6.);\n        float angle = 0.55;\n        float rt3 = sqrt(3.);\n        vec2 sep = vec2(1,rt3);\n        float r1 = 0.47, r2 = 0.04, shift=0.3;\n        d = min(d, torusGrid(q-vec3(shift,0,0), r2, r1, angle, sep));\n        d = min(d, torusGrid(q-vec3(shift,0,0)-vec3(0.5,rt3/2.,0), r2, r1, angle, sep));\n    }\n    //d = min(d, torusGrid(p-vec3(sep/2.,0), 0.07, 0.4, -angle, sep));\n    \n    // Plane below\n    #if 1\n    vec3 p2 = 12.3*p;\n    p2.yz *= R(0.7);\n    p2.xz *= R(-0.7);\n    vec2 q = p2.xy-round(p2.xy);\n    float bump = dot(q,q) * 0.005;\n    d = min(d, p.z+0.3+bump);\n    #endif\n    \n    return d;\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = 0.001 * vec2(1,-1);\n    return normalize(\n        e.xxx*map(p+e.xxx)\n       +e.xyy*map(p+e.xyy)\n       +e.yxy*map(p+e.yxy)\n       +e.yyx*map(p+e.yyx));\n}\n\nfloat raymarch(vec3 ro, vec3 rd)\n{\n    float d, t=0.;\n    for(int i=0;i<256;i++)\n    {\n        d = map(ro+t*rd);\n        if(d<0.001 || t>100.) break;\n        t += d;\n    }\n    return t;\n}\n\nfloat calcAO(vec3 p, vec3 n)\n{\n    float occl = 0.;\n    for(float t=0.02; t<5.; t*=2.)\n    {\n        float d = map(p+n*t);\n        occl = max(occl, 1.-d/t);\n        if(occl > 0.99) break;\n    }\n    return max(1.-occl,0.) * (0.5+0.5*n.z);\n}\n\nvec3 shade(vec3 ro, vec3 rd)\n{\n    float t = raymarch(ro, rd);\n    if(t < 100.)\n    {\n        vec3 p = ro+t*rd;\n        vec3 n = normal(p);\n        /*\n        vec3 surfCol = 0.5+0.5*sin(5.*p);\n        vec3 dif = surfCol * (0.5+0.5*n.z);\n        return dif;\n\t\t*/\n        vec3 rrd = reflect(rd, n);\n        vec3 refl = 0.5+0.5*rrd;\n        //float lod = max(log2(t), 0.);\n        float lod = 4.;\n        vec3 reflCol = pow(textureLod(iChannel0, rrd.xzy, lod).rgb, vec3(2.2));\n        reflCol *= mix(0.5, 1.0, step(0., -rrd.x+rrd.y));\n        vec3 fre0 = vec3(0.8);\n        vec3 fre = fre0 + (1.-fre0) * pow(clamp(1.+dot(rd,n),0.,1.),5.);\n        float ao = calcAO(p,n);\n        vec3 col = reflCol * ao * fre;\n        \n        float fog = 1.-exp(-0.002*t);\n        vec3 fogColor = vec3(0.7,0.8,0.9);\n        col = mix(col, fogColor, fog);\n        \n        return col;\n    }\n    else\n    {\n        return textureLod(iChannel0, rd.xzy, 0.).rgb;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float th = sin(iTime*0.1)+0.3+0.05*cos(0.5*iTime);\n    vec3 center = vec3(iTime*0.3,0,0);\n    vec3 ro = center + 0.3*vec3(4.*cos(th),4.*sin(th),5.5+0.5*cos(0.2*iTime)+0.1*cos(iTime));\n    vec3 camFwd = normalize(0.1*vec3(0,1,1)*sin(iTime*0.3)+ center -ro);\n    vec3 camRight = normalize(cross(camFwd, vec3(0,0,1)));\n    vec3 camUp = cross(camRight, camFwd);\n    \n    vec3 col = vec3(0);\n    for(float i=0.;i<AA;i++)\n    {\n        for(float j=0.; j<AA; j++)\n        {\n            vec2 uv = ((fragCoord+vec2(i,j)/AA)*2.-iResolution.xy)/iResolution.y;\n            vec3 rd = normalize(camFwd + 0.5*(camRight*uv.x + camUp*uv.y));\n            col += shade(ro,rd);\n        }\n    }\n    col /= AA*AA;\n    \n    col *= 1.5;\n    // ACES tone mapping\n    // https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n    // Used in https://www.shadertoy.com/view/ts3Bz7\n    col = (col*(2.51*col+0.03))/(col*(2.43*col+0.59)+0.14);\n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}