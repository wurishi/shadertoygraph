{"ver":"0.1","info":{"id":"4tlcWf","date":"1506701706","viewed":218,"name":"A simple ray tracer","username":"Lazzux","description":"FIN: Skrolliin raytracer esimerkki. Tämä on riisuttu versio, alkuperäinen täällä: https://www.shadertoy.com/view/Xtfyz\nENG: A very simple ray tracer I made. This is the basic version. Cooler version can be found here: https://www.shadertoy.com/view/Xtfyzr","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Settings\nconst vec3 cameraPos = vec3(0, 0, 30);\nconst int maxReflections = 10;\n\n// Update this if you remove or add spheres in the code\nconst int sphereCount = 3;\n\nvoid sphere(vec3 spherePos, float sphereSize, vec3 rayDirection, vec3 rayOrigin, out float t, out vec3 sphereNormal)\n{\n    float radius2 = sphereSize * sphereSize;\n    vec3 rayToSphere = spherePos - rayOrigin;\n    \n    // Closest point on ray to the sphere center\n    float tca = dot(rayToSphere, rayDirection);\n    \n    // Distance squared from the closest point on ray to the sphere center\n    float d2 = dot(rayToSphere, rayToSphere) - tca * tca; \n    \n    // Ray misses the sphere\n    if (d2 > radius2) {\n        // Return clearly incorrect values\n        t = -1.0;\n        sphereNormal = vec3(0,0,0);\n        return;\n    }\n    \n    // Distance from the first intersection point to the closest point on ray to the sphere center\n    float thc = sqrt(radius2 - d2); \n    \n    // Find the first (closer to the ray origin) intersection point of a sphere\n    t = tca - thc;\n    \n    if(t < 0.0)\n    {\n        // The intersection point is behind the ray. \n        // Use the next (further away from ray origin) intersection point\n        t = tca + thc;\n    }\n    \n    // Calculate normal of the sphere by calculating a vector from the sphere center to the intersection point on the ray\n    sphereNormal = normalize( rayOrigin + (t * rayDirection) - spherePos );\n}\n\nvoid cast_ray_to_scene(\n    vec3 spheres[sphereCount],\n    vec3 sphereColors[sphereCount],\n    float sphereSizes[sphereCount],\n    vec3 ray,\n    vec3 rayOrigin,\n    out vec3 rayColor)\n{\n    // Default ray color tint (white for the background)\n    rayColor = vec3(1, 1, 1);\n    \n    // Loop until too many reflections or until we have used up all the usable distance from the ray\n    for(int currentReflection = 0;currentReflection < maxReflections + 1;currentReflection++)\n    {\n        vec3 foundColor = vec3(1, 1, 1);\n        vec3 reflectionNormal = vec3(0,0,-1);\n        float lowestT, t;\n        \n        // Use a very high default value\n        lowestT = 999999.9;\n        \n        // Go through all the spheres\n        for(int i = 0; i < sphereCount; i++)\n        {\n            vec3 sphereNormal;\n            float t;\n\n            // Calculate t and normal of the sphere\n            sphere(spheres[i], sphereSizes[i], ray, rayOrigin, t, sphereNormal);\n\n            // If the ray did hit something and it wasn't behind the ray and it was closer than the result before\n            if(t > 0.001 && t < lowestT)\n            {\n                // Set the new closest depth value\n                lowestT = t;\n\n                // Use the given normal as the normal for the fragment\n                reflectionNormal = sphereNormal;\n\n                // Use the color of the sphere as current sphere color\n                foundColor = sphereColors[i];\n            }\n        }\n        \n        // Accumulate the color from the many reflections\n        rayColor = foundColor * rayColor;\n        \n        // Check if the ray did not hit anything (which means an end of life for a ray)\n        if(lowestT > 999999.0 || currentReflection == maxReflections)\n        {            \n            vec3 texel = texture(iChannel0, ray).rgb;\n                        \n            // Combine lighting\n            rayColor = texel * rayColor;\n            \n            break;\n        }\n        \n        // Calculate new ray origin\n        rayOrigin += ray * lowestT;\n                \n        // Get a new ray by reflecting the current one from the hit object\n        ray = reflect(ray, reflectionNormal);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Calculate some values for the rotations and other animation\n    float cosTime = cos(iTime);\n    float sinTime = sin(iTime);\n    float cosTime2 = cos(iTime*0.23);\n    float sinTime2 = sin(iTime*0.23);\n    float sinTime3 = sin(iTime*1.23);\n    \n    // Rotation matrix, rotations animated by time\n    mat3 rot = mat3( vec3(1, 0, 0), vec3(0, cosTime2, -sinTime2), vec3(0, sinTime2, cosTime2) ) \n        * mat3( vec3(cosTime, 0, sinTime), vec3(0, 1, 0), vec3(-sinTime, 0, cosTime) ) \n        * mat3( vec3(cosTime2, -sinTime2, 0), vec3(sinTime2, cosTime2, 0), vec3(0, 0, 1) );\n        \n    // Define sphere positions, use some variance based on time\n    vec3 spheres[sphereCount];\n    spheres[0] = vec3(-7.0, -7.0, sinTime);\n    spheres[1] = vec3(7.0, -7.0, sinTime2);\n    spheres[2] = vec3(0, 7.0 * (sinTime3 + 5.0) * 0.25, sinTime3);\n    \n    // Define sphere colors\n    vec3 sphereColors[sphereCount];\n    sphereColors[0] = vec3(1.0, 0.5, 0.5);\n    sphereColors[1] = vec3(0.5, 1.0, 0.5);\n    sphereColors[2] = vec3(0.5, 0.5, 1.0);\n    \n    // Define sphere sizes\n    float sphereSizes[sphereCount];\n    sphereSizes[0] = 5.5;\n    sphereSizes[1] = 4.5;\n    sphereSizes[2] = 7.5;\n    \n    // Rotate and move spheres\n    for(int i = 0; i < sphereCount; i++)\n    {\n        spheres[i] = rot * spheres[i] + cameraPos;\n    }\n    \n    vec3 rayColor;\n    vec3 finalColor;\n    \n    vec2 halfRes = iResolution.xy * 0.5;\n    vec2 invRes = 1.0 / iResolution.xy;\n    float aspectRatio = iResolution.y / iResolution.x;\n    \n    // Basically convert the fragCoord.xy to a better suited value for the ray origin\n    vec2 uv = ((fragCoord.xy - halfRes) * invRes) * vec2(1.0, aspectRatio);\n\n    // Create the ray direction\n    vec3 ray = normalize(vec3(uv, 0.50));\n\n    // Set the ray origin (based on position on the screen)\n    vec3 rayOrigin = vec3(uv, 0);\n\n    // Cast the ray\n    cast_ray_to_scene(spheres,sphereColors,sphereSizes,ray,rayOrigin,rayColor);\n    \n    // Output the final color\n    fragColor = vec4(rayColor , 1.0);\n    \n}\n","name":"Image","description":"","type":"image"}]}