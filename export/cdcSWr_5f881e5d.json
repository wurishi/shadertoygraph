{"ver":"0.1","info":{"id":"cdcSWr","date":"1679630924","viewed":119,"name":"Fishy business ","username":"ianertson","description":"What's in the suitcase?\n--\nSpent a long time on procedural textures for these fishes, and originally wanted the camera to be under the water.\nBut couldn't figure out a good way to render from under the water.\nSo now you can barely see the textures :(","likes":6,"published":1,"flags":48,"usePreview":1,"tags":["raytracing","raymarching","ray","raymarch","water","fish"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define ID_GROUND 1\n#define ID_BOX 2\n#define ID_SUITCASE 3\n#define ID_FISH 4\n#define ID_FISH_EYE 5\n#define ID_WATER 6\n\n#define WATER_DEPTH 6.\n\n\n\n//#define DEBUG_TEXTURE fishScaleTexture\n\nfloat scalePattern(in vec2 uv, in float tile, in float thick) {\n    vec2 uvShade = uv;\n    vec2 iidShade = floor(uvShade*tile);\n    vec2 uuvShade = uvShade;\n    uuvShade.x += (iidShade.y)/tile/2.;\n    vec2 lvShade = fract(uuvShade*tile);\n    float xx = smoothstep(0.0, 1.0, lvShade.x/1.5);\n     return max(line2D(lvShade, vec2(xx, 1), vec2(0.5, 0.), thick), \n                    line2D(lvShade, vec2(0.5-xx, 0.0), vec2(1., 1.), thick));\n}\n\n//#define DEBUG_TEXTURE sandTexture\n\nvec3 sandTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    float w = wnoise(uv*12., 5, 1.0);\n    vec3 hf1 = snoise(uv, 0.000089123, 0.05, 140.0, 6);\n    vec3 lf1 = snoise(uv + (vec2(cos(w*3.), sin(w*3.))*0.06), 2.29328921, 0.1, 6.0, 6);\n    vec3 grain = abs(normalize(cross(hf1*2.0-1.0, lf1*2.0-1.0)));\n    \n    vec3 c1 = rgb(200, 163, 111);\n    vec3 c2 = rgb(246, 205, 151);\n    vec3 c3 = rgb(225, 206, 191);\n    vec3 c4 = rgb(170, 123, 69);\n    \n    vec3 col1 = mix4(c1, c2*w, c3, c4, hf1);\n    vec3 col2 = mix4Alt(c1, c2, c3, c4, hf1.yxz);\n    vec3 col3 = mix4(c1, c2, c3, c4, grain);\n    \n    col = mix(col1, col2, lf1.y);\n    col = mix(col, col3, w*w*0.7);\n    col = mix(col, clamp((col+(col*w))/1.3, 0.0, 1.0), smoothstep(0.4, 0.7, lf1.z));\n    \n    m.spec = grain.x*grain.y*grain.z;\n    m.z = clamp(lf1.x-(0.5 - (0.5-w)), 0.0, 1.0);\n    \n    return col;\n}\n\nvec3 suitcaseTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    vec3 c1 = rgb(52, 52, 54);\n    vec3 c2 = rgb(39, 29, 28);\n    vec3 c3 = rgb(72, 52, 47);\n    vec3 c4 = rgb(94, 85, 70);\n    \n    vec3 hf1 = snoise(uv, 0.038281245, 0.0, 125.0, 6);\n    vec3 hf2 = snoise(uv, 5.505838434, 0.3, 96.0, 6);\n    \n    vec3 col1 = mix4(c1, c2, c3, c4, hf1);\n    col = col1/1.4;\n    \n    float tile = 64.0;\n    float itile = max(0.0, 0.33-(1.0/tile));\n    vec2 id = floor(uv*tile);\n    vec2 lv = fract(uv*tile);\n    vec2 alv = abs(lv*2.0-1.0);\n    \n    float lines = max(smoothstep(0.48-itile, 0.5, alv.x-0.5),\n                  smoothstep(0.48-itile, 0.5, alv.y-0.5));\n    \n    float pat = lines * smoothstep(0.4, 0.7, hf2.x)*hf1.z;\n    col = mix(col, col*col, pat);\n    \n    vec2 vid = vec2(0.0);\n    float w = voronoi(uv*tile, 2.293125, vid);\n    \n    col = mix(col, col+(col*col*2.), w);\n    col = col*col;\n    \n    m.spec = clamp(0.5*((w*w*w*0.7)-pat),0.0, 0.6);\n    return clamp(col, 0.0, 1.0);\n}\n\nvec3 eyeTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(1.);\n    \n    float pupilR = 0.5;\n    float pupilF = pupilR*0.2;\n    float pupil = 1.0-smoothstep(pupilR-pupilF, pupilR+pupilF, distance(abs(uv*2.0-1.0), vec2(0.5, 0.7)));\n    \n    col = mix(col, vec3(0), pupil);\n    \n    \n        \n    float irisR = 0.7;\n    float irisF = irisR*0.001;\n    float iris = 1.0-smoothstep(irisR-irisF, irisR+irisF, distance(abs(uv*2.0-1.0), vec2(0.5, 0.7)));\n    iris = max(0.0, iris-pupil);\n    \n    col = mix(col, vec3(0, 1, 0), iris);\n    m.lum = 0.3;\n    \n    return col;\n}\n\nvec3 fishScaleTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    // scale\n    vec3 sc1 = rgb(185, 191, 141);\n    vec3 sc2 = rgb(186, 222, 212);\n    vec3 sc3 = rgb(220, 231, 214);\n    vec3 sc4 = rgb(175, 187, 178);\n    \n    // sep\n    vec3 sep1 = rgb(173, 86, 27);\n    vec3 sep2 = rgb(121, 72, 36);\n    vec3 sep3 = rgb(141, 110, 93);\n    vec3 sep4 = rgb(134, 48, 0);\n\n    // top dark\n    vec3 d1 = rgb(113, 89, 55);\n    vec3 d2 = rgb(161, 185, 121);\n    vec3 d3 = rgb(162, 134, 91);\n    vec3 d4 = rgb(193, 188, 138);\n    \n    vec3 hf1 = snoise(uv, 0.00823215, 0.3, 100.0, 6);\n    vec3 hf2 = snoiseWarp(uv, 3.9828124, 1.5, 64.0, 6, 0.45);\n    vec3 lf1 = snoiseWarp(uv, 6.69488335, 0.5, 8.0, 6, 0.3);\n    vec3 grain1 = abs(normalize(cross(hf1*2.0-1.0, hf2*2.0-1.0)));\n    vec3 grain2 = abs(normalize(reflect(grain1*2.0-1.0, lf1*2.0-1.0)));\n    vec3 lf2 = snoise(uv, 8.89394982, 0.2, 16.0, 6);\n    \n    vec3 scaleCol1 = mix4Alt(sc1, sc2, sc3, sc4, hf1);\n    col += scaleCol1;\n    \n    vec3 sepCol1 = mix4(sep1, sep2, sep3, sep4, smoothstep(0.4, 0.6, hf2));\n    \n    float tile = 12.0;\n    float itile = max(0.0, 0.2-(1.0/tile));\n    vec2 iid = floor(uv*tile);\n    vec2 uuv = uv;\n    uuv.x += (iid.y)/tile/2.;\n    vec2 id = floor(uuv*tile);\n    vec2 lv = fract(uuv*tile);\n    vec2 lv2 = fract((uuv+vec2(0.01, 0.01))*(tile));\n    vec2 alv = abs(lv*2.0-1.0);\n    \n    float sep = smoothstep(0.48-itile, 0.5, alv.x-0.5) +\n                smoothstep(0.48-itile, 0.5, alv.y-0.5);\n                \n\n    float thick = 0.08;\n    \n    thick = mix(thick, thick*0.5, smoothstep(0.4, 0.7, lf1.y));\n\n    vec2 patUv = uv + (lf1.xz*2.0-1.0)*0.05;\n    float scaleSep = scalePattern(patUv, tile, thick);\n    float scaleShade = scalePattern(patUv + vec2(0.007, 0.007), tile, thick);\n    float scaleLight = scalePattern(patUv - vec2(0.006, 0.006), tile, thick);\n\n\n    id = floor((uv)*(tile));\n    vec2 slv = fract(uv*tile);\n    slv = slv*slv*(3.0-2.0*slv);\n    float seed = 5.5982387;\n    vec3 idr = mix(\n        mix(hash23(id, seed), hash23(id+vec2(1., 0), seed), slv.x),\n        mix(hash23(id+vec2(0, 1), seed), hash23(id+vec2(1, 1), seed), slv.x),\n        slv.y\n    );\n    \n    vec3 scaleCol2 = mix4(sc1, sc2, sc3, sc4, idr);\n    col = mix(col, scaleCol2, smoothstep(0.4, 0.5, lf1.x));\n    \n    col = mix(col, idr, smoothstep(0.4, 0.7, lf1.z)*0.3);\n    \n    \n    col = mix(col, sepCol1, scaleSep);\n    col = mix(col, col*0.5, scaleShade);\n    col = mix(col, col+col, scaleLight*0.33);\n    \n    float grain = grain1.x;\n    \n    col += grain1.y*lf1.x*lf1.y*lf1.z;\n    col = mix(col, col*col, grain);\n    \n    vec3 darkCol = mix4(d1, d2, d3, d4, smoothstep(0.4, 0.7, lf2));\n    float darkReg = (idr.x+(grain2.x*0.5))*(0.5+smoothstep(0.4, 0.7, lf1.x)*0.5);\n    col = mix(col, darkCol, darkReg);\n    \n    m.z = clamp((0.5+scaleLight)-(scaleShade+(scaleSep*0.2)),0.0, 1.0);\n    m.spec = clamp(((scaleLight+idr.y)-(scaleShade*2.))+darkReg, 0.1, 1.0);\n\n    return col;\n}\n\nfloat getWaterArea(in vec3 p) {\n    float r = 6.3;\n    float f = r*0.59;\n    return 1.0-smoothstep(r-f, r+f, length(p.xz));\n}\n\nvec3 knoise(in vec3 p, in float phase) {\n    float x1 = exp(sin(p.z+phase)-1.);\n    float y1 = exp(sin(p.x+phase)-1.);\n    float z1 = exp(sin(p.y+phase)-1.);\n    \n    float x2 = exp(cos(p.x+(x1*3.14))-1.);\n    float y2 = exp(cos(p.y+(y1*3.14))-1.);\n    float z2 = exp(cos(p.z+(z1*3.14))-1.);\n    \n    vec3 a = vec3(x1, y1, z1);\n    vec3 b = vec3(x2, y2, z2) * 2.0 - 1.0;\n    \n    return clamp(cross(a, b), -1., 1.);\n}\n\nvec3 knoise(in vec3 p, in float phase, in float freq, const in int octaves) {\n    vec3 n = vec3(0.0);\n    float div = 0.0;\n    float amp = 1.0;\n    \n    for (int i = ZERO; i < octaves; i++) {\n        n += amp * knoise(p*freq, phase); div += amp; amp /= 2.0; freq *= 2.0;\n        float a = (float(i)/float(octaves))*1.6;\n        p.yz *= rot(cos(a*n.x)+(n.x*0.6*n.z));\n        p.xz *= rot(sin(a*n.y)+(n.x*0.6*n.z));\n        phase += phase*amp*length(n)*0.2;\n    }\n    \n    return n/div;\n}\n\nfloat enoise(in vec2 p) {\n    float v = 0.0;\n    p *= 3.;\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    vec2 slv = lv*lv*(3.0-2.0*lv);\n    vec2 alv = abs(lv*2.0-1.0);\n    \n    #define R11(x) fract(34.423812*cos(6.2839291*fract(x*10.398281312)))\n    #define R2(id) (fract(R11((id).x) * dot(id, vec2(44.293172, 35.598287312)) + R11((id).y)))\n    \n    float r = mix(\n        mix(R2(id), R2(id+vec2(1, 0)), slv.x),\n        mix(R2(id+vec2(0, 1)), R2(id+vec2(1, 1)), slv.x),\n        slv.y\n    );\n    #undef R2\n    #undef R11\n    \n    return r;\n}\n\n//#define DEBUG_TEXTURE testTexture\nvec3 testTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    col += enoise(uv*4.);\n    return col;\n}\n\n\n\nfloat waterSDF(in vec3 p) {\n    float area = getWaterArea(p);\n   \n     if (area <= 0.0009) return FAR;\n    \n     vec3 waterSize = vec3(10, WATER_DEPTH/2., 10);\n     float d = boxSDF(p - vec3(0, -WATER_DEPTH, 0), waterSize);\n     float inside = boxSDF(p - vec3(0, -WATER_DEPTH*1.2, 0), waterSize*0.999);\n     \n     if (-p.y > 1.5) {\n         vec3 p = p;\n         float time = T*0.2;\n         vec2 shift = vec2(cos(time), sin(time));\n         float h = 0.0;\n         \n         float h1 = enoise((p.xz*0.3)+shift);\n         float h2 = enoise((p.zx*0.7)-shift);\n         \n         h = h1 + (h2/2.);\n         h = (h * 2.0 - 1.0)*0.09;\n        \n    \n         d -= h;\n     }\n     \n     return max(d, -inside);\n}\n\nfloat groundSDF(in vec3 p) {\n    float h = 0.0;\n    \n    float waterArea = getWaterArea(p);\n    \n    h -= waterArea*WATER_DEPTH;\n\n    return p.y - h;\n}\n\nfloat suitecaseSDF(in vec3 p, in float scale) {\n    float dist = FAR;\n    vec3 size = vec3(0.3, 0.2, 0.03) * scale;\n    float base = boxSDF(p - vec3(0, size.y, 0), size)-0.02;\n    \n    float r1 = 0.09;\n    float r2 = 0.02;\n    p.x = abs(p.x);\n    r1 += smoothstep(0.0, 1.0, p.x/1.4);\n    r2 -= smoothstep(0.0, 1.0, p.x/1.9);\n    float handle = length(vec2(length(p.xy-vec2(0, size.y*2.))-r1,p.z))-r2;\n    \n    dist = smin(base, handle, 0.01);\n    \n    return dist;\n}\n\nfloat fishSDF(in vec3 p, inout int skip, inout int id, inout Object o) {\n    if (skip == ID_FISH || skip == ID_FISH_EYE) return FAR;\n    float dist = FAR;\n    id = ID_FISH;\n    float r = 0.1009;\n    float len = 0.3133;\n\n  //  p.z += len/2.;\n \n    vec3 bodyDir = vec3(0, 0, 1);\n    bodyDir = mix(bodyDir, vec3(1.5, 0, 1), sin(T*3.)*smoothstep(0.07, 0.9, -p.z+(len/1.6)));\n    bodyDir = normalize(bodyDir);\n    float base = lineSDF(vec3(p.x*2., p.y, p.z) - vec3(0.0, 0.0, 0.0), bodyDir*(-len/2.), bodyDir*(len/2.), r);\n    base += smoothstep(0.0, 1.9, max(0.0, (len/2.)-p.z));\n    base += smoothstep(0.0, 1.0, max(0.0, p.z))*smoothstep(0.2, 0.7, max(0.0, p.y+0.7));\n    \n    base/= 2.1;\n    \n    dist = base;\n    \n    float backfinR = 0.07;\n    float backfinThick = 0.005;\n    //backfinR += smoothstep(0.0, 1.2, 1.2*clamp(abs(p.y)-0.001, 0.0, 0.1));\n    float k = -smoothstep(0.0, 1.0, abs(p.y)*1.7);\n    vec3 backfinDir = vec3(1, 0, 0);\n    backfinDir = mix(backfinDir, normalize(vec3(1.0, 0.0, 1.5)), sin(T*3.)*smoothstep(0.0, 0.6, max(0.0, -p.z+0.004)));\n    backfinDir = normalize(backfinDir);\n    float backfin = cylSDF(p - vec3(0, 0, (-(len-(backfinR+0.002)))+k), vec3(0, 0, 0), backfinDir*backfinThick, backfinR);\n    backfin -= 0.001;\n    backfin /= 1.7;\n    \n    float topfinR = 0.062;\n    topfinR += smoothstep(0.0, 1.0, clamp(abs(p.z), 0.0, 0.25));\n    topfinR -= smoothstep(0.09, 1.0, dot(p, vec3(0, 1, 1)));\n    topfinR -= smoothstep(0.0, 1.0, max(0.0, p.y-0.1));\n    float topfin = cylSDF(p - vec3(0, backfinR, 0), vec3(0, 0, 0), vec3(0.005, 0.0, 0.0), topfinR);\n    \n    float botfinR = 0.05;\n    botfinR += smoothstep(0.0, 1.0, clamp(abs(p.z), 0.0, 0.19));\n\n    botfinR -= smoothstep(0.0, 1.0, max(0.0, -p.y-0.06));\n    botfinR -= smoothstep(0.0, 1.5, max(0.0, (p.z+0.2)))*smoothstep(0.0, 0.6, max(0.0, -p.z*2.));\n    float botfin = cylSDF(p - vec3(0.0, -(r-0.02),(-len/12.)-0.011), vec3(0, 0, 0), vec3(0.01, 0.0, 0.0), botfinR);\n    \n    float eyeR = 0.012;\n    float eyeHole = sphereSDF(vec3(abs(p.x), p.y, p.z) - vec3(abs(((r/2.)-(eyeR*2.))-0.012), r/9., len/2.), eyeR);\n    dist = smax(dist, -eyeHole, 0.005);\n    float eyeBallR = eyeR*0.4;\n    vec3 eyeBallPos = vec3(abs(((r/2.)-(eyeBallR*2.))-0.024), r/9., len/2.);\n    float eyeBall = sphereSDF(vec3(abs(p.x), p.y, p.z) - eyeBallPos, eyeBallR);\n\n    float mouthHoleR = 0.016;\n    float mouthHole = sphereSDF(p - vec3(0, -len/10., (len/2.)+0.009), mouthHoleR);\n    dist = smax(dist, -mouthHole, 0.005);\n    \n    float lipR1 = 0.009;\n    float lipR2 = 0.0009;\n    vec3 lipP = p - vec3(0, (-len/10.)+0.009, (len/2.)+(mouthHoleR/1.9));\n    float lipTop = length(vec2(length(lipP.xz)-lipR1,lipP.y))-lipR2;\n    \n    \n    float botOpen = 0.5+sin(T*3.)*0.5;\n    \n    vec3 lipBotP = p - vec3(0, (-len/10.)+mix(0.0, -0.006, botOpen), (len/2.)+(mouthHoleR/6.));\n    float lipBot = length(vec2(length(lipBotP.xz)-lipR1,lipBotP.y))-lipR2;\n    \n    dist = smin(dist, lipTop, 0.006);\n    dist = smin(dist, lipBot, 0.006);\n\n    dist = smin(dist, botfin, 0.012);\n    dist = smin(dist, topfin, 0.007);\n    dist = smin(dist, backfin, 0.009);\n    \n    \n    Object oEye = Object(o.p+eyeBallPos, o.q);\n    \n    SAMPLE(eyeBall, oEye, ID_FISH_EYE);\n\n    \n    \n    return dist/1.2;\n}\n\nvoid insertFish(in vec3 p, in float uid, inout int skip, inout int id, inout float dist, inout Object o) {\n    if (p.y > -0.1 || skip == ID_FISH) return;\n    float r = fract(34.423812*cos(6.2839291*fract(uid*10.398281312)));\n    float r2 = fract(77.423812*sin(6.2839291*fract(r*10.194221312)));\n    float r3 = fract(84.332779*sin(6.99392935*fract((r+uid)*12.194221312)));\n    \n    float time = T*mix(1.0, 0.5, r*r2);\n    \n    vec3 fishDir = vec3(sin(time+uid+r3), 0, cos(time+uid+r3));\n    fishDir = mix(fishDir, vec3(sin(time+r), radians(mix(-(10.+(r3*6.)), (10.+(r3*6.)), 0.5+sin((time+(r*3.+r2)))*0.5)), cos(time+r)), r*r2);\n    fishDir.xz*=rot(r3*6.28*r);\n    vec3 fishPos = vec3(0, (-WATER_DEPTH)+0.5, 0)+vec3(1.5, 0, 1.5);\n    fishPos += normalize(fishDir)*vec3(1, 2, 1)*mix(1.0, 0.5, r3);\n    fishPos.xz += vec2(r, r2)*2.0-1.0;\n    vec3 fishRot = vec3(-fishDir.y*TAU, atan(fishDir.z, fishDir.x)-radians(180.), 0.0);\n    int fishId = 0;\n    Object oFish = Object(fishPos, fishRot);\n    float fish = fishSDF(pointRot(p - oFish.p, oFish.q), skip, fishId, oFish);\n    SAMPLE(fish, oFish, fishId);\n}\n\nfloat sdf(inout Data data, in vec3 p) {\n    int skip = data.skip;\n    int id = ID_NONE;\n    float dist = FAR;\n    Object o = NEW_OBJECT;\n    \n    float ground = groundSDF(p);\n    SAMPLE(ground, o, ID_GROUND);\n    \n    float water = waterSDF(p);\n    SAMPLE(water, o, ID_WATER);\n\n    float suitcase = suitecaseSDF(pointRot(p - vec3(1.5, -WATER_DEPTH, 1.5), vec3(radians(90.), 0, 0)), 1.0);\n    SAMPLE(suitcase, o, ID_SUITCASE);\n\n    \n    insertFish(p, 0.021825, skip, id, dist, o);\n    insertFish(p, 12.328154, skip, id, dist, o);\n    insertFish(p, 21.982831, skip, id, dist, o);\n\n    data.id = id;\n    data.o = o;\n    return dist;\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, n);\n    vec3 col = sandTexture(uv, p, data.m);\n    data.n = makeNormal(data.n, data.m.z, 0.6, 0.33);\n    return col;\n}\n\nvec3 getAlbedoWater(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, n);\n    vec3 col = vec3(0.1, 0.2, 0.9);\n    data.m.ior = 1.33;\n    data.m.rough = 0.003;\n    data.m.metallic = 0.0;\n    data.m.spec = 0.1;\n    return col;\n}\n\nvec3 getAlbedoFish(inout Data data) {\n    vec3 p = pointRot(data.p - data.o.p, data.o.q);\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, pointRot(n, data.o.q));\n    uv *= 6.;\n    vec3 col = fishScaleTexture(uv, p, data.m);\n    data.n = makeNormal(data.n, data.m.z, 0.39, 0.33);\n    return col;\n}\n\nvec3 getAlbedoFishEye(inout Data data) {\n    vec3 p = pointRot(data.p - data.o.p, data.o.q);\n    vec3 n = data.n;\n    vec2 uv = sphereUv(pointRot(n, data.o.q));\n    vec3 col = eyeTexture(uv, p, data.m);\n    return col;\n}\n\nvec3 getAlbedoSuitcase(inout Data data) {\n    vec3 p = pointRot(data.p - data.o.p, data.o.q);\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, pointRot(n, data.o.q));\n    vec3 col = suitcaseTexture(uv, p, data.m);\n    data.n = makeNormal(data.n, data.m.z, 0.39, 0.33);\n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_GROUND: return getAlbedoGround(data); break;\n        case ID_WATER: return getAlbedoWater(data); break;\n        case ID_FISH: return getAlbedoFish(data); break;\n        case ID_FISH_EYE: return getAlbedoFishEye(data); break;\n        case ID_SUITCASE: return getAlbedoSuitcase(data); break;\n    }\n    \n    return vec3(0.77);\n}\n\nvec3 getSky(in vec3 rd) {\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    vec3 col = pow(COLOR_SKY, vec3(1.0 + dotup));\n    return col;\n}\n\nvec3 render(inout Data data, in vec3 ro, in vec3 rd, inout float depth) {\n    vec3 col = vec3(0.0);\n    depth = 1.0;\n    \n    Light lights[NUM_LIGHTS];\n    lights[0] = LIGHT_SUN;\n    const bool withSky = true;\n    float dist = FAR;\n    for (int i = ZERO; i < 2; i++) {\n        if (raycast(data, lights, withSky, col, ro, rd)) {\n            if (i <= 0) {dist = data.d;}\n            if (data.m.rough < 0.993) {\n                Data data2 = NEW_DATA;\n                data2.sig = data.sig;\n                data2.skip = data.skip;\n\n                vec3 reflectionCol = vec3(0.0);\n                vec3 dir = reflect(rd, data.n);\n                float metallic = data.m.metallic;\n                float rough = data.m.rough;\n                vec3 diffuse = col;\n\n                float NdotV = dot(data.n, dir);\n                vec3 f0 = mix(vec3(0.04), diffuse, metallic);\n                vec3 F = fresnelSchlickRoughness(NdotV, f0, rough*rough);\n                \n                if (length(F) > 0.09 && (1.0 - NdotV > 0.09)) {\n                    raycast(data2, lights, withSky, reflectionCol, data.p+((data.n*NEAR*2.)*data.sig), dir);\n                \n                    col += reflectionCol * F;\n                }\n            }\n            if (data.m.ior > 0.0002) {\n                float ior = data.m.ior;\n                Data enter = NEW_DATA;\n                enter.sig = -data.sig;\n                vec3 enterDir = refract(rd, data.n, 1.0/ior);\n                enter.ro = data.p;\n                enter.rd = enterDir;\n                if (!raycast(enter, lights, false, col, data.p+((data.n*NEAR*16.)*enter.sig), enterDir)) break;\n\n                Data leave = NEW_DATA;\n                leave.skip = data.id;\n                vec3 leaveDir = refract(enterDir, enter.n*enter.sig, 1.0/ior);\n                if (length(leaveDir) <= 0.00001) {\n                     leaveDir = reflect(enterDir, enter.n*enter.sig);\n                     leave.skip = -1;\n                     leave.sig = data.sig;\n                }\n                \n                data = NEW_DATA;\n                data.sig = leave.sig;\n                data.ro = enter.p;\n                data.rd = leaveDir;\n                data.skip = leave.skip;\n                ro = enter.p;\n                rd = leaveDir;\n            } else {\n                break;\n            }\n        } else {\n            break;\n        }\n        \n    //    data.steps -= 5;\n    }\n    \n    depth = dist / FAR;\n    col += depth*depth;\n    return col;\n}\n\nRay getRay(inout Data data, in vec2 uv, in vec4 m) {\n    vec3 ro = vec3(0, 0, -0.3);\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n    \n    \n    vec3 toggleWalk = texelFetch(iChannel0, ivec2(2, 0), 0).xyz;\n    if (toggleWalk.x > 0.001) {\n        vec3 walk = texelFetch(iChannel0, ivec2(0, 0), 0).xyz;\n        vec3 fly = texelFetch(iChannel0, ivec2(1, 0), 0).xyz;\n        ro += walk;\n        ro.y += fly.y;\n        \n        float pitch  = m.y*TAU;\n        float yaw = m.x*TAU;\n        vec3 camdir = normalize(vec3(\n            sin(yaw),\n            tan(pitch),\n            cos(yaw)\n        ));\n        data.q = camdir;\n        rd.yz *= rot(pitch);\n        rd.xz *= rot(yaw);\n        data.ro = ro;\n        data.rd = rd;\n        return Ray(ro, rd);\n    }\n\n\n    ro.y -= 1.1;\n    ro.x -= 0.5;\n    float zoom = mix(1.4, 2.3, 0.5+sin(T*0.5)*0.5);\n    vec3 lookp = vec3(0.3, -WATER_DEPTH/2.5, 0.3);\n\n    lookp += vec3(mix(-0.1, 0.1, 0.5+cos(T)*0.5), 0, mix(-0.1, 0.1, 0.5+sin(T)*0.5));\n    rd = look(uv, lookp, ro, zoom);\n    \n    data.ro = ro;\n    data.rd = rd;\n    \n    return Ray(ro, rd);\n}\n\nvec4 blit(in vec2 fc) {\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y, iMouse.zw);\n    \n    Data data = NEW_DATA;\n    Ray ray = getRay(data, uv, m);\n    vec3 ro = ray.ro;\n    vec3 rd = ray.rd;\n    float depth = 1.0;\n    \n    \n    #ifdef DEBUG_TEXTURE\n    Material ma = NEW_MATERIAL;\n    col += DEBUG_TEXTURE(fc.xy/R.xy, ro+rd, ma);\n    #else\n    col += render(data, ro, rd, depth);\n    col = aces(col);\n    col = pow(col, vec3(1.0 / 2.2));\n    #endif\n    \n    return vec4(col, depth);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    O = blit(fc);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// <common>\n#define R (iResolution.xy)\n#ifndef HW_PERFORMANCE\n#define iTime (0.0)\n#define iFrame (0)\nuniform sampler2D iChannel3;\n#define iResolution vec2(0.0)\n#define iMouse vec4(0.0)\n#endif\n#define T (iTime)\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n#define SAMPLE(var, OBJ, id_) if (id_ != skip && var < dist) { id = id_; dist = var; o = OBJ; }\n\n// Ray marcher constants\n\n#define NEAR 0.003\n#define FAR 50.0\n#define STEPS 76\n#define SHADOW_STEPS 33\n#define FAR_LOD 1.0\n#define NORMAL_RANGE 0.001\n#define AMBIENT 0.05\n#define NUM_LIGHTS 1\n#define ID_NONE -1\n\n// Colors\n\n#define COLOR_SKY vec3(0.29, 0.61, 0.9)\n#define COLOR_SUN vec3(0.97, 0.81, 0.79)\n\n// Render constants\n\n#define SPECULAR_AMPLITUDE 64.0\n#define SHADOW_NDOTL_EPSILON 0.000003\n\n// Default sun light\n\n#define LIGHT_SUN Light(vec3(1, 2, 2.), vec3(0.0), COLOR_SUN, 2.5, LIGHT_AMBIENT)\n\nstruct Object {\n    vec3 p;\n    vec3 q;\n};\n\n#define NEW_OBJECT Object(vec3(0.0), vec3(0.0))\n\nstruct Material { float rough; float spec; float metallic; float lum; float z; float ior; };\n#define NEW_MATERIAL Material(1.0, 1.0, 0.0, 0.0, 0.0, 0.0)\n\nstruct Data {\n    vec3 q;\n    vec3 ro;\n    vec3 rd;\n    vec3 p;\n    vec3 n;\n    float d;\n    int skip;\n    int id;\n    float sig;\n    Material m;\n    Object o;\n};\n#define NEW_DATA Data(vec3(0.0), vec3(0.0),vec3(0.0), vec3(0.0), vec3(0.0), FAR, ID_NONE, ID_NONE, 1., NEW_MATERIAL, NEW_OBJECT)\n\nstruct Ray {\n    vec3 ro;\n    vec3 rd;\n};\n\n#ifndef HW_PERFORMANCE\nfloat sdf(inout Data data, in vec3 p) { return FAR; }\nvec3 getAlbedo(inout Data data) { return vec3(0.0); }\nvec3 getSky(in vec3 rd) { return vec3(0.0); }\n#else\nfloat sdf(inout Data data, in vec3 p);\nvec3 getAlbedo(inout Data data);\nvec3 getSky(in vec3 rd);\n#endif\n\nvec3 makeNormal(in vec3 wn, in float z, in float mx, in float s) {\n    if (abs(z) <= 0.000000001) return wn;\n    vec2 dx = vec2(dFdx(z), 0.0);\n    vec2 dy = vec2(0.0, dFdy(z));\n    float bumpScale = s;\n    vec3 cp = cross(vec3(dx, bumpScale), vec3(dy, bumpScale));\n    if (length(cp) <= 0.0003) return wn;\n    cp = normalize(cp);   \n    vec3 next = normalize(mix(wn, normalize(wn+cp), mx));\n    if (length(next) <= 0.0003) return wn;\n    return next;\n}\n\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\n// Utilities\n\nvec3 mix4(vec3 c1, vec3 c2, vec3 c3, vec3 c4, vec3 m) {\n    return mix(mix(mix(c1, c2, m.x), c3, m.y), c4, m.z);\n}\n\nvec3 mix4Alt(vec3 c1, vec3 c2, vec3 c3, vec3 c4, vec3 m) {\n    vec3 m2 = m;\n    m2.xz *= rot(6.28*m.z+m.y);\n    m2 = abs(m2);\n    return clamp(((c1 * m.x) + (c2 * m.y) + (c3 * m.z) + (c4 * m2.x))/4., 0.0, 1.0);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return smin(a, b, -k);\n}\n\nvec3 smin(vec3 a, vec3 b, float k) {\n    vec3 h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nvec3 smax(vec3 a, vec3 b, float k) {\n    return smin(a, b, -k);\n}\n\nfloat sabs(in float v, in float k) {\n    return smax(-v, v, k);\n}\n\nfloat line2D(in vec2 p, in vec2 a, in vec2 b, float t) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return clamp(1.0-length(pa - ba * h)/t, 0.0, 1.0);\n}\n\nvec3 look(vec2 uv, vec3 point, vec3 ro, in float zoom) {\n    vec3 camForward = normalize(point - ro);\n    vec3 camRight = -normalize(cross(camForward, vec3(0, 1, 0)));\n    vec3 camUp = -normalize(cross(camRight, camForward));\n    vec3 screenCenter = ro + camForward * zoom;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\n\nvec3 pointRot(in vec3 p, in vec3 r) {\n    \n    p.xz *= rot(r.y);\n    p.yz *= rot(r.x);\n    return p;\n}\n\n// UV functions\n\nvec2 boxUv(in vec3 p, in vec3 n) {\n    return mix(mix(p.xy, p.yz, round(adot(n, vec3(1, 0, 0)))), p.xz, round(adot(n, vec3(0, 1, 0))));\n}\n\nvec2 sphereUv(in vec3 p) {\n    float u = acos(p.y);\n    float v = atan(p.x, p.z);\n    u = 0.5 - u / M_PI;\n    v = 0.5 + v / M_PI;\n    return vec2(u, v);\n}\n\n// Distance functions\n\nfloat sphereSDF(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat lineSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    return length(pa - ba * (clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0))) - r;\n}\n\nfloat cylSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    vec3 c = a + t * ab;\n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    return e + i;\n}\n\nfloat torusSDF(in vec3 p, in float r1, float r2) {\n    p = p.yzx;\n    float ll = length(p.yz)-r1;\n    return length(vec2(ll,p.x))-r2;\n}\n\n// Noise functions\n\nuint hash21u(in vec2 ip, in float seed) {\n    uvec2 p = uvec2(floatBitsToUint(ip.x), floatBitsToUint(ip.y));\n    uint s = floatBitsToUint(seed);\n    s ^= ~s >> 3U;\n    p ^= (p << 17U);\n    s ^= (~p.x);\n    s ^= (~p.y);\n    p ^= (p >> 11U);\n    p ^= (p << 5U);\n    p ^= (s << 3U);\n    return ((p.x + p.y) ^ (p.x * s + p.y))*293U;\n}\n\nfloat hash21(in vec2 ip, in float seed) { return float(hash21u(ip, seed)) / float(0xFFFFFFFFU); }\n\nvec3 hash23(in vec2 ip, in float seed) {\n    uint n = hash21u(ip, seed);\n    n ^= (n >> 13U);\n    return vec3(float((n >> 16U) & 0xFFU), float((n >> 8U) & 0xFFU), float(n & 0xFFU)) / float(0xFFU);\n}\n\n#define NOISE(p, seed, lod) (textureLod(iChannel3, (p + (seed*1.9287827185))/256.0, lod).rgb)\n\nvec3 snoise(in vec2 p, in float seed, in float lod) {\n    p += 0.99288124;\n    vec2 id = floor(p);\n    vec2 lv = fract(p); lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(NOISE(id, seed, lod), NOISE(id + vec2(1, 0), seed, lod), lv.x),\n        mix(NOISE(id + vec2(0, 1), seed, lod), NOISE(id + vec2(1, 1), seed, lod), lv.x),\n        lv.y\n    );\n}\n\nvec3 snoise(in vec2 p, in float seed, in float lod, in float freq, const in int octaves) {\n    p += 0.99288124;\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    for (int i = ZERO; i < octaves; i++) {\n        n += amp * snoise(p*freq, seed, lod); div += amp; amp /= 2.0; lod /= 2.0; freq *= 2.0;\n    }\n    return n / div;\n}\n\nvec3 snoiseWarp(in vec2 p, in float seed, in float lod, in float freq, const in int octaves, in float warp) {\n    p += 0.99288124;\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    for (int i = ZERO; i < octaves; i++) {\n        n += amp * snoise(p*freq, seed, lod); div += amp; amp /= 2.0; lod /= 2.0; freq *= 2.0;\n        p += (n.xy*n.z)*warp;\n    }\n    return n / div;\n}\n\nfloat wnoise(in vec2 uv, in int iter, float dim) {\n    vec2 k = uv*2.0-1.0;\n    vec2 r = vec2(0.0);\n    float f = 1.0;\n    for (int i = 0; i < iter; i++) {\n        r += sin( k*f +(float(i)/float(iter))*2.5) / f;\n        k = k * mat2(8.0, 6.28, -8.0, 6.28)*.1 + r*.29;     \n        r += sin( k*f +(float(i)/float(iter))*2.5) / f;\n        k = k * mat2(8.0, 6.28, -8.0, 6.28)*.1 + r*.29;\n    }\n    float n = 1.0-dFdx(length(r)*dim);\n    return clamp(exp(n-1.5)*n, 0.0, 1.0);\n}\n\nfloat voronoi(in vec2 p, in float seed, out vec2 id){\n    vec2 Pi = floor(p);\n    vec2 Pf = fract(p);\n    \n    float dmin = 1e20;\n    vec2 res = vec2(0.0);\n    float r = 1.0;\n    \n    for(int j=-1; j<=1; j++){\n        for(int i=-1; i<=1; i++){\n            vec2 lattice = vec2(float(i),float(j));\n            vec2 offset = vec2(hash21(Pi+lattice, 0.9231234), hash21(Pi+lattice, 78.38381));\n            vec2 diff = lattice + offset - Pf;\n            \n            float dist = dot(diff,diff);\n            r = min(r, dist/0.56);\n            if(r<dmin){\n                id = offset;\n                dmin = r;\n                res = lattice + offset;\n            }\n        }\n    }\n\n    return clamp(sqrt(dmin), 0.0, 1.0);\n}\n\n// Shading & Colors\n\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\n\nvec3 aces(vec3 x) {return x*(2.51*x + .03) / (x*(2.43*x + .59) + .14); }\n\nvec3 fresnelSchlickRoughness(float NdotV, vec3 F0, float rough) {\n  return F0 + (max(vec3(1.0 - rough), F0) - F0) * pow(max(1.0 - NdotV, 0.0), 5.0);\n}\n\n// Marching\n\nbool march(inout Data data, in vec3 ro, in vec3 rd) {\n    float d = 0.0;\n  //  data.ro = ro;\n  //  data.rd = rd;\n    float sig = data.sig;\n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sig*sdf(data, p);\n        d += next;\n        if ((next) <= (NEAR * (1.0 + (d / FAR_LOD)))) break;\n        if ((d) >= FAR) return false;\n    }\n    \n    Data tmp = NEW_DATA;\n    vec3 p = ro+rd*d;\n    vec2 e = vec2(NORMAL_RANGE, 0.0);\n    vec3 n = normalize(sdf(tmp, p) - vec3(\n        sdf(tmp, p - e.xyy),\n        sdf(tmp, p - e.yxy),\n        sdf(tmp, p - e.yyx)\n    ));\n    \n    data.d = d;\n    data.p = p;\n    data.n = n;\n    \n    return true;\n}\n\nfloat getShadow(in vec3 ro, in vec3 rd, in vec3 n, in float far, in int skip) {\n    float NdotL = cdot(n, rd);\n    if (NdotL <= SHADOW_NDOTL_EPSILON) return 1.0;\n    \n    Data data = NEW_DATA;\n    data.skip = skip;\n    data.ro = ro;\n    data.rd = rd;\n    float d = 0.0;\n    float r = 1.0;\n    for (int i = ZERO; i < SHADOW_STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        r = min(r, next/0.44);\n        d += next*0.13;\n        if (abs(next) <= (NEAR * (1.0 + (d / FAR_LOD)))) break;\n        if (abs(d) >= FAR) break;\n    }\n    \n    return clamp(r + 0.77*(d / (1.0 + d)), AMBIENT, 1.0);\n}\n\n// Lighting\n\nstruct Light { vec3 p; vec3 d; vec3 c; float s; int type; };\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n\nvec3 getLightDir(in Light light, in vec3 p) {\n    return light.type == LIGHT_AMBIENT ? normalize(light.p) :\n           light.type == LIGHT_POINT ? normalize(light.p - p) :\n           normalize(light.d);\n}\n\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(AMBIENT, dot(n, L));\n    \n    switch (light.type) {\n        case LIGHT_AMBIENT: return light.c * light.s * NdotL; break;\n        case LIGHT_POINT: return light.c * NdotL * (\n            pow(light.s, 2.0) / max(0.0001, pow(distance(light.p, p), 2.0))\n        ); break;\n        case LIGHT_DIR: return light.c * light.s * NdotL * smoothstep(0.8, 1.0, dot(\n            normalize(light.p - p),\n            L\n        )); break;\n    }\n    \n    return vec3(0.0);\n}\n\nvec3 forEachLight(in Light light, in Data data, in vec3 ro, in vec3 rd, in vec3 diffuse) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 L = getLightDir(light, p);\n    vec3 ref = reflect(L, n);\n    float VdotR = cdot(rd, ref);\n    float spec = data.m.spec * pow(VdotR, SPECULAR_AMPLITUDE);\n    vec3 att = getLightAtt(light, p, n);\n    float shadow = getShadow(p + (n*NEAR*2.0), L, n, light.type == LIGHT_AMBIENT ? FAR :\n        distance(light.p, p), data.id);\n        \n    att = max(att, data.m.lum*diffuse);\n    shadow += data.m.lum;\n    return (diffuse + spec) * att * shadow; \n}\n\nbool raycast(inout Data data, in Light lights[NUM_LIGHTS],\n    in bool with_sky, inout vec3 col, in vec3 ro, in vec3 rd) {\n    if (!march(data, ro, rd)) {\n        if (with_sky) {\n            col += getSky(rd);\n        }\n        return false;\n    }\n    vec3 albedo = getAlbedo(data);\n    vec3 diffuse = albedo / M_PI;\n    for (int i = ZERO; i < NUM_LIGHTS; i++) {\n        Light light = lights[i];\n        col += forEachLight(light, data, ro, rd, diffuse);\n    }\n    return true;\n}\n// </common>\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\n// taken from https://www.shadertoy.com/view/ldGGzV\nfloat sdf(inout Data data,in vec3 p) { return FAR;}\nvec3 getSky(in vec3 rd) { return vec3(0.); }\nvec3 getAlbedo(inout Data data) { return vec3(0.); }\n#define MOVE_SPEED 10.\n#define PI 3.14159\n\nconst float KEY_W = 87.5 / 256.0;\nconst float KEY_A = 65.5 / 256.0;\nconst float KEY_S = 83.5 / 256.0;\nconst float KEY_D = 68.5 / 256.0;\nconst float KEY_SHIFT = 16.0;\nconst float KEY_SPACE = 32.0;\nconst float KEY_V = 86.0;\n\n\nbool isEnabled() {\n    return texelFetch(iChannel1, ivec2(2, 0), 0).x > 0.001;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = texture(iChannel1, vec2(0.)).xyz;\n    if(iFrame <= 1) pos = vec3(0., 2.0, 10.);\n    \n    switch (int(fragCoord.x)) {\n        case 0: {\n            if (isEnabled()) {\n                float mx = iMouse.xy == vec2(0.) ? 0. : ((iMouse.x / iResolution.x) * 2. - 1.) * 360.;\n                float speed = MOVE_SPEED * iTimeDelta;\n\n                float forwardBackward =\n                texture(iChannel0, vec2(KEY_W, 0.)).r -\n                texture(iChannel0, vec2(KEY_S, 0.)).r;\n\n                float leftRight =\n                texture(iChannel0, vec2(KEY_A, 0.)).r -\n                texture(iChannel0, vec2(KEY_D, 0.)).r;\n\n                float s = sin(radians(mx));\n                float c = cos(radians(mx));\n\n                pos.x += speed * (forwardBackward * s - leftRight * c);\n                pos.z += speed * (forwardBackward * c + leftRight * s);\n            }\n        }; break;\n        case 1: {\n            if (isEnabled()) {\n                pos = texelFetch(iChannel1, ivec2(1, 0), 0).xyz;\n                float space = texelFetch(iChannel0, ivec2(KEY_SPACE, 0), 0).r;\n                float shift = texelFetch(iChannel0, ivec2(KEY_SHIFT, 0), 0).r;\n\n                pos.y += space * 0.2;\n                pos.y -= shift * 0.2;\n            }\n        }; break;\n        \n        case 2: {\n            pos = texelFetch(iChannel1, ivec2(2, 0), 0).xyz;\n            float v = texelFetch(iChannel0, ivec2(KEY_V, 0), 0).r;\n            \n            float timeDiff = iTime - pos.y;\n            \n             if (timeDiff > 0.07) {\n                bool prev = pos.x > 0.0001;\n                bool toggle = v > 0.0001;\n\n                bool next = prev;\n\n\n                if (toggle) {\n                    next = !prev;\n                }\n                pos.y = iTime;\n                pos.x = next ? 1.0 : 0.0;\n            }\n        \n        }; break;\n    }\n    \n    \n    fragColor = vec4(pos, 0.);\n}","name":"Buffer D","description":"","type":"buffer"}]}