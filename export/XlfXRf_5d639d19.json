{"ver":"0.1","info":{"id":"XlfXRf","date":"1438372813","viewed":531,"name":"Cool guys...","username":"Xender","description":"Cool guys don't look at explosions...\n...because of hazard of being hit by small metal parts in the eyes, baby.\n\n// Really just a bunch of \"stolen\" content glued together, see comments in source for credits.\n// Just a baby's first 2 hours compo shader.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["explosions","warsztat"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// From https://www.shadertoy.com/view/llXXD4\n\nfloat warsztat(vec2 uv1)\n{\n\tvec2 uv = (((((uv1 * 2.0) - 1.0) * 1.1818) + 1.0) * 0.5);\n\tif (uv.x > 0.09090909090909091 && uv.x < 0.6363636363636364 && uv.y > 0.4090909090909091 && uv.y < 0.5454545454545454) return 1.0;\n\tif (uv.x > 0.5454545454545454 && uv.x < 0.7727272727272727 && uv.y > 0.5454545454545454 && uv.y < 0.7727272727272727) return 1.0;\n\tif (uv.x > 0.4090909090909091 && uv.x < 0.5454545454545454 && uv.y > 0.09090909090909091 && uv.y < 0.4090909090909091) return 1.0;\n\tif (uv.x > 0.3181818181818182 && uv.x < 0.45454545454545453 && uv.y > 0.0 && uv.y < 0.09090909090909091) return 1.0;\n\tif (uv.x > 0.4090909090909091 && uv.x < 0.5454545454545454 && uv.y > 0.5454545454545454 && uv.y < 0.6363636363636364) return 1.0;\n\tif (uv.x > 0.7727272727272727 && uv.x < 0.9090909090909091 && uv.y > 0.9090909090909091 && uv.y < 1.0) return 1.0;\n\tif (uv.x > 0.0 && uv.x < 0.09090909090909091 && uv.y > 0.3181818181818182 && uv.y < 0.45454545454545453) return 1.0;\n\tif (uv.x > 0.9090909090909091 && uv.x < 1.0 && uv.y > 0.7727272727272727 && uv.y < 0.9090909090909091) return 1.0;\n\tif (uv.x > 0.3181818181818182 && uv.x < 0.4090909090909091 && uv.y > 0.3181818181818182 && uv.y < 0.4090909090909091) return 1.0;\n\tif (uv.x > 0.6363636363636364 && uv.x < 0.7272727272727273 && uv.y > 0.7727272727272727 && uv.y < 0.8636363636363636) return 1.0;\n\tif (uv.x > 0.7727272727272727 && uv.x < 0.8636363636363636 && uv.y > 0.6363636363636364 && uv.y < 0.7272727272727273) return 1.0;\n\tif (uv.x > 0.45454545454545453 && uv.x < 0.5454545454545454 && uv.y > 0.6363636363636364 && uv.y < 0.6818181818181818) return 1.0;\n\tif (uv.x > 0.6363636363636364 && uv.x < 0.7272727272727273 && uv.y > 0.5 && uv.y < 0.5454545454545454) return 1.0;\n\tif (uv.x > 0.6818181818181818 && uv.x < 0.7727272727272727 && uv.y > 0.8636363636363636 && uv.y < 0.9090909090909091) return 1.0;\n\tif (uv.x > 0.8636363636363636 && uv.x < 0.9545454545454546 && uv.y > 0.7272727272727273 && uv.y < 0.7727272727272727) return 1.0;\n\tif (uv.x > 0.0 && uv.x < 0.045454545454545456 && uv.y > 0.2727272727272727 && uv.y < 0.3181818181818182) return 1.0;\n\tif (uv.x > 0.045454545454545456 && uv.x < 0.09090909090909091 && uv.y > 0.45454545454545453 && uv.y < 0.5) return 1.0;\n\tif (uv.x > 0.09090909090909091 && uv.x < 0.13636363636363635 && uv.y > 0.36363636363636365 && uv.y < 0.4090909090909091) return 1.0;\n\tif (uv.x > 0.2727272727272727 && uv.x < 0.3181818181818182 && uv.y > 0.0 && uv.y < 0.045454545454545456) return 1.0;\n\tif (uv.x > 0.2727272727272727 && uv.x < 0.3181818181818182 && uv.y > 0.36363636363636365 && uv.y < 0.4090909090909091) return 1.0;\n\tif (uv.x > 0.36363636363636365 && uv.x < 0.4090909090909091 && uv.y > 0.09090909090909091 && uv.y < 0.13636363636363635) return 1.0;\n\tif (uv.x > 0.36363636363636365 && uv.x < 0.4090909090909091 && uv.y > 0.2727272727272727 && uv.y < 0.3181818181818182) return 1.0;\n\tif (uv.x > 0.36363636363636365 && uv.x < 0.4090909090909091 && uv.y > 0.5454545454545454 && uv.y < 0.5909090909090909) return 1.0;\n\tif (uv.x > 0.45454545454545453 && uv.x < 0.5 && uv.y > 0.045454545454545456 && uv.y < 0.09090909090909091) return 1.0;\n\tif (uv.x > 0.5 && uv.x < 0.5454545454545454 && uv.y > 0.6818181818181818 && uv.y < 0.7272727272727273) return 1.0;\n\tif (uv.x > 0.5454545454545454 && uv.x < 0.5909090909090909 && uv.y > 0.36363636363636365 && uv.y < 0.4090909090909091) return 1.0;\n\tif (uv.x > 0.5909090909090909 && uv.x < 0.6363636363636364 && uv.y > 0.7727272727272727 && uv.y < 0.8181818181818182) return 1.0;\n\tif (uv.x > 0.6363636363636364 && uv.x < 0.6818181818181818 && uv.y > 0.45454545454545453 && uv.y < 0.5) return 1.0;\n\tif (uv.x > 0.7272727272727273 && uv.x < 0.7727272727272727 && uv.y > 0.9090909090909091 && uv.y < 0.9545454545454546) return 1.0;\n\tif (uv.x > 0.7727272727272727 && uv.x < 0.8181818181818182 && uv.y > 0.5909090909090909 && uv.y < 0.6363636363636364) return 1.0;\n\tif (uv.x > 0.8636363636363636 && uv.x < 0.9090909090909091 && uv.y > 0.6818181818181818 && uv.y < 0.7272727272727273) return 1.0;\n\tif (uv.x > 0.8636363636363636 && uv.x < 0.9090909090909091 && uv.y > 0.8636363636363636 && uv.y < 0.9090909090909091) return 1.0;\n\tif (uv.x > 0.9090909090909091 && uv.x < 0.9545454545454546 && uv.y > 0.9090909090909091 && uv.y < 0.9545454545454546) return 1.0;   \n\treturn 0.0;\n}\n\nvec3 sample_back(vec2 uv1, float start, float speed, float scale, vec2 mov)\n{ \n   vec2 uv = ((uv1) * 2.0) - 1.0;\n   float rot = start + iTime * speed;\n   mat2 m = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n   uv = m * uv;\n   uv = uv + mov;\n   uv = uv * scale;\n   uv = (uv + 1.0) * 0.5;\n   return texture(iChannel0, uv).rrr;\n}\n\nvec3 draw_warsztat(vec3 base, vec2 uv, float col,float alpha)\n{\n\tfloat v = 0.0;\n\tif (warsztat(uv) > 0.99) v = alpha;\n\treturn mix(base, vec3(col), v);\n}\n\n\n// From https://www.shadertoy.com/view/lsf3RH\n\nfloat snoise(vec3 uv, float res)\n{\n\tconst vec3 s = vec3(1e0, 1e2, 1e3);\n\t\n\tuv *= res;\n\t\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n\t\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\n\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\n\tvec4 r = fract(sin(v*1e-1)*1e3);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-1)*1e3);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\treturn mix(r0, r1, f.z)*2.-1.;\n}\n\nvec3 explosion(vec2 p)\n{\n\t// vec2 p = -.5 + fragCoord.xy / iResolution.xy;\n\t// p.x *= iResolution.x/iResolution.y;\n\t\n\tfloat color = 3.0 - (3.*length(2.*p));\n\t\n\tvec3 coord = vec3(atan(p.x,p.y)/6.2832+.5, length(p)*.4, .5);\n\t\n\tfor(int i = 1; i <= 7; i++)\n\t{\n\t\tfloat power = pow(2.0, float(i));\n\t\tcolor += (1.5 / power) * snoise(coord + vec3(0.,-iTime*.05, iTime*.01), power*16.);\n\t}\n\t// return vec4( color, pow(max(color,0.),2.)*0.4, pow(max(color,0.),3.)*0.15 , 1.0);\n\treturn vec3( color, pow(max(color,0.),2.)*0.4, pow(max(color,0.),3.)*0.15);\n}\n\n\n\n// From https://www.shadertoy.com/view/MdlGWX\n//Credit: http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 blackout_noise(vec2 uv)\n{\n\t//Fragment position, only used as random seed\n\t// vec2 uv = fragCoord.xy / iResolution.xy; \n\t\n\t//Flicker frequency\n\tfloat flicker = 10.0;\n\t\t\n\t//Play with power to change noise frequency\n\tfloat freq = sin(pow(mod(iTime, flicker)+flicker, 1.9));\n\t\n\t//Play with this to change raster dot size (x axis only, y is calculated with aspect ratio)\n\tfloat pieces = float(1000);\n\t\n\t//Calculations to maintain square pixels\n\tfloat ratio_x = 1.0 / pieces;\n\tfloat ratio_y = ratio_x * iResolution.x / iResolution.y;\n\tfloat half_way_x = abs(freq * ratio_x);\n\tfloat half_way_y = abs(freq * ratio_y);\n\t\t\n\t//Comment this out to see how raster dots are simulated (noise overlay)\n\t// col *= vec3(rand(uv+mod(iTime, freq)), rand(uv+mod(iTime+.1, freq)), rand(uv));\n\t\t\n\t//Use this for greyscale noise, comment out the line above (noise overlay)\n\treturn vec3(rand(uv+mod(iTime, freq)), rand(uv+mod(iTime, freq)), rand(uv+mod(iTime, freq)));\n}\n\n\n// helpers\n\nfloat sawtooth(float t, float period)\n{\n\treturn mod(t, period) / period;\n}\n\n\n// Main\n\n#define WHOLE_ANIM_TIME 7.0\n// #define MAIN_ANIM_TIME 5.0\n\n#define WRENCH_ANIM_START 1.0\n#define WRENCH_ANIM_END   5.0\n\n#define EXPL_ANIM_START 0.0\n#define EXPL_ANIM_END   5.0\n\n#define BLACKOUT_ANIM_START 5.0\n#define BLACKOUT_ANIM_END   7.0\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = 2.0 * (fragCoord.xy / iResolution.xy) - 1.0;\n\tuv *= vec2(iResolution.x / iResolution.y, -1.0);\n\n\tvec3 col = vec3(0);\n\n\n\tfloat time = mod(iTime, WHOLE_ANIM_TIME);\n\n\tif ( time > EXPL_ANIM_START && time < EXPL_ANIM_END ) {\n\t\tfloat expl_t = (time - EXPL_ANIM_START) / (EXPL_ANIM_END - EXPL_ANIM_START);\n\n\t\tvec2 explosion_uv = log(expl_t) * uv * 0.5;\n\t\t// vec2 explosion_uv = -exp(-expl_t) * uv * 5.0;\n\t\t// vec2 explosion_uv = (1.0-expl_t) * uv * 5.0;\n\t\tcol += explosion(explosion_uv);\n\t}\n\n\tif ( time > WRENCH_ANIM_START && time < WRENCH_ANIM_END ) {\n\t\tfloat wrench_t = (time - WRENCH_ANIM_START) / (WRENCH_ANIM_END - WRENCH_ANIM_START);\n\n\t\tvec2 warsztat_uv = uv;\n\t\t// warsztat_uv *= (sin(iTime*2.2+0.3)*0.1)+1.0;\n\t\twarsztat_uv = (1.0-wrench_t) * uv * 100.0; // (sin(iTime*2.2+0.3)*0.1)+1.0;\n\n\t\t// uv += 1.0;\n\t\t// uv *= 0.5;\n\n\t\t// You spin me right round, baby, right round...\n\t\tfloat rot_angle = wrench_t * 4.0;\n\t\twarsztat_uv *= mat2(sin(rot_angle), cos(rot_angle), cos(rot_angle), -sin(rot_angle));\n\t\t\n\t\twarsztat_uv += 1.0;\n\t\twarsztat_uv *= 0.5;\n\t\t\n\t\tfloat uvm = 1.0 / 26.0;\n\t\t\n\t\tcol = draw_warsztat(col, warsztat_uv + vec2(-uvm*0.0, -uvm * 2.0), 0.0, 0.5);\n\t\tcol = draw_warsztat(col, warsztat_uv - vec2(uvm, 0.0), 160.0/255.0, 1.0);\n\t\tcol = draw_warsztat(col, warsztat_uv - vec2(-uvm, 0.0), 160.0/255.0, 1.0);\n\t\tcol = draw_warsztat(col, warsztat_uv - vec2(0.0, uvm), 160.0/255.0, 1.0);\n\t\tcol = draw_warsztat(col, warsztat_uv - vec2(0.0, -uvm), 160.0/255.0, 1.0);\n\t\tcol = draw_warsztat(col, warsztat_uv, 80.0/255.0, 1.0);\n\t}\n\n\tif ( time > BLACKOUT_ANIM_START && time < BLACKOUT_ANIM_END ) {\n\t\tcol = blackout_noise(uv);\n\t}\n\n\tfragColor = vec4(vec3(col), 1.0);\n}\n","name":"","description":"","type":"image"}]}