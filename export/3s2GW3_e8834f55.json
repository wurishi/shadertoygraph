{"ver":"0.1","info":{"id":"3s2GW3","date":"1550141697","viewed":388,"name":"drain vortex","username":"skaplun","description":"Original - https://twitter.com/etiennejcb/status/1091677551523713026\nNoise and SDF functions by @iq","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","sdf","animation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA (10./iResolution.y)\n#define MAX_MARCHING_STEPS 255\n#define MIN_DIST 0.\n#define MAX_DIST 100.0\n#define EPSILON .0001\n#define rMat(x) mat2(cos(x), -sin(x), sin(x), cos(x))\n#define cart2pol(U)  vec2( length(U), atan((U).y,(U).x) )\n\nfloat noise( in vec3 x ){\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, uv/256., -100.0 ).xy;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h ){\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n    float cone = sdRoundCone(samplePoint + vec3(0., 3., 0.), .125, 1.5, 3.);\n    float plane = samplePoint.y + .25;\n    return opSmoothSubtraction(cone, plane, 2.);\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n            return depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 twist(in vec3 p, float twistAmount){\n    float t = (length(p.xz) + p.y) * twistAmount;\n    p.xz *= rMat(-t);\n    return p;\n}\n\nvec4 image(in vec2 fragCoord, in vec2 resolution){\n\tvec3 eye = vec3(0., 2.5, 7.5);\n    vec3 viewDir = rayDirection(60., resolution, fragCoord);\n    vec3 worldDir = viewMatrix(eye, vec3(0., 0., 2.5), vec3(0., 1., 0.)) * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist < MAX_DIST - EPSILON) {\n        vec3 p = (eye + dist * worldDir);\n        \n        p.xz *= rMat(iTime * .5);\n        p = twist(p, .25);\n\n        vec2 pol = cart2pol(p.xz);\n        float clr = noise(vec3(vec2((pol.x + iTime) * 2., pol.y * 25.), iTime * .05));\n        return vec4(vec3(smoothstep(.3 + AA, .3, clr)), 1.);\n    }else{\n        return vec4(vec3(0.), 1.);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tfloat subSample = 1.;\n    \n    if (subSample < 2.){\n        fragColor = image(fragCoord, iResolution.xy);\n\t}else{\n        vec2 subResolution = iResolution.xy * subSample;\n\n        float samples = subSample * subSample;\n        float sampleWeight = 1. / samples;\n\n        for ( float i = 0.; i < subSample ; i ++ ){\n            for ( float j = 0.; j < subSample ; j ++ ){\n                vec2 newCoord = fragCoord * subSample + vec2(i,j);\n                fragColor += image(newCoord, subResolution) * sampleWeight;\n            }\n        }\n    }\n}","name":"Image","description":"","type":"image"}]}