{"ver":"0.1","info":{"id":"wlV3Wz","date":"1578721005","viewed":60,"name":"Noise and RayMarching","username":"Harekelas","description":"Practicing with noise and ray marching","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 1000.\n#define SURF_DIST 0.01\n\nfloat N21(vec2 p)\n{\n    return fract(sin(p.x * 1920. + p.y * 8848.) * 10248.);    \n}\n\nfloat N22(vec2 p){\n\tvec3 a = fract(p.xyx * vec3(156.25,5432.1,2247.58));\n    a += dot(a, a + 78.54);\n    return fract(vec2 (a.x * a.y, a.y*a.z)).x;\n}\n\nfloat SmoothNoise(vec2 uv){\n    vec2 lv = smoothstep(0.,1.,fract(uv));\n    vec2 id = floor(uv);\n    \n    float bl = N21(id);\n    float br = N21(id + vec2(1,0));\n    float b = mix(bl,br,lv.x);\n    \n    float tl = N21(id + vec2(0,1));\n    float tr = N21(id + vec2(1,1));\n    float t = mix(tl,tr,lv.x);\n    \n    return mix(b,t,lv.y);\n}\n\nfloat SmoothNoise2(vec2 uv, float s){\n    \n    float c = SmoothNoise(uv * 2. * s);     \n    c += SmoothNoise(uv * 4. * s) * 0.5;\n\tc += SmoothNoise(uv * 8. * s) * 0.25;\n    c += SmoothNoise(uv * 16. * s) * 0.125;\n    c += SmoothNoise(uv * 32. * s) * 0.0625;    \n    c += SmoothNoise(uv * 64. * s) * 0.03125;    \n\n    return c / 1.96875;\n}\n\nfloat GetDist(vec3 p){\n    \n    float Sin = sin(iTime) * 0.5 + 0.5;\n    float Cos = cos(iTime) * 0.5 + 0.5;\n    \n \tvec4 s = vec4(0,1,10.,1.);\n    //vec4 s = vec4(0,1,6.,1.);\n    \n    float sphereDist = length(p - s.xyz) - s.w;\n    \n    vec2 tuv = p.xz / vec2(100,100);\n    \n    //float terrainDist = sin(p.x) + sin(p.z) + p.y * 2. + 5.;\n    //float terrainDist = p.y;\n    float terrainDist = p.y + SmoothNoise2(tuv, 0.2) * SmoothNoise2(tuv, 0.5) * 150.;\n    \n    float d= min(sphereDist, terrainDist);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, out bool isMax){\n\tfloat dO = 0.;\n    isMax= false;\n    \n    for(int i = 0; i < MAX_STEPS; i++){\n    \tvec3 p = ro + rd * dO;\n        float ds = GetDist(p);\n        dO += ds;\n        if(dO > MAX_DIST ){\n        \tisMax = true;\n            break;\n        }\n        else if(ds < SURF_DIST){\n            break;\n        }\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p){\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01,0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p, vec3 n){\n    vec3 lightDir = vec3(2,-1,1.);\n    vec3 lightPos = vec3(-2,6,0);\n    vec3 l = normalize(-lightDir);\n    //vec3 l = normalize(lightPos - p);\n    \n    float dif = dot(n,l);\n\treturn dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec3 col = vec3(0);\n    vec2 cuv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    //noise scrolling\n    //uv += iTime * 0.1;\n\t//float c = SmoothNoise2(uv,4.);\n    //float c = N22(uv);   \n\t//col = vec3(c);\n    \n    vec3 ro = vec3 (0,2.,iTime * 100.);\n    vec3 rd = normalize(vec3(cuv.x,cuv.y,1.));\n    bool isMax;\n    float d = RayMarch(ro, rd, isMax);\n    vec3 p = ro + rd * d;\n    if(isMax)\n    {        \n        //skybox\n    \tcol = vec3(0.4*(1.-uv.y * .5),.8*(1.-uv.y * .5),1. * (uv.y * 0.5 + 0.5));\n    }\n    else {\n        \n\t\tvec3 n = GetNormal(p);\n    \tfloat dif = GetLight(p,n);\n        \n    \tcol = vec3(1.-n.y * .6,.6 * n.y + .4,.25 * n.y) * (dif * 0.7 + 0.3);\n    }\n    \n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}