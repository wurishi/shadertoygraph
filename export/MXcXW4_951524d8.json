{"ver":"0.1","info":{"id":"MXcXW4","date":"1719016237","viewed":79,"name":"Fork whirling i unfrended 574","username":"unfrended","description":"yup - mandelbox (more or less)","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["fractal","raymarch"],"hasliked":0,"parentid":"MXtXz8","parentname":"whirling inferno"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Gaussian blur effect\n    vec2 texel = 1.0 / iResolution.xy;\n    vec4 total_color = vec4(0.0);\n\n    // Gaussian kernel from common tab\n    float[] gk1s = float[](\n        0.003765, 0.015019, 0.023792, 0.015019, 0.003765,\n        0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n        0.023792, 0.094907, 0.150342, 0.094907, 0.023792,\n        0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n        0.003765, 0.015019, 0.023792, 0.015019, 0.003765\n    );\n\n    // Apply Gaussian blur to the texture from channel 0\n    for (int i = 0; i < 5; i++) {\n        float fi = float(i) - 2.0;\n        for (int j = 0; j < 5; j++) {\n            float fj = float(j) - 2.0;\n            vec4 color = texture(iChannel0, uv + vec2(texel.x * fi, texel.y * fj));\n            total_color += color * gk1s[i * 5 + j];\n        }\n    }\n\n    // Calculate the time for the 133 BPM rhythm\n    float beatPeriod = 0.4511278195; // Seconds per beat for 133 BPM\n    float t = mod(iTime, beatPeriod) / beatPeriod; // Normalized time within the beat\n\n    // Generate dynamic colors based on the rhythm\n    vec3 psychedelicColor = vec3(\n        sin(total_color.r * 10.0 + t * 2.0 * PI) * 0.5 + 0.5,\n        sin(total_color.g * 10.0 + t * 2.0 * PI + 2.0) * 0.5 + 0.5,\n        sin(total_color.b * 10.0 + t * 2.0 * PI + 4.0) * 0.5 + 0.5\n    );\n\n    // Output the final color\n    fragColor = vec4(psychedelicColor, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\n//gaussian_kernel_one_stdev\nfloat[] gk1s = float[] (\n        0.003765,0.015019,0.023792,0.015019,0.003765,\n        0.015019,0.059912,0.094907,0.059912,0.015019,\n        0.023792,0.094907,0.150342,0.094907,0.023792,\n        0.015019,0.059912,0.094907,0.059912,0.015019,\n        0.003765,0.015019,0.023792,0.015019,0.003765 );","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float num_iter, objid, glow = 0.0, glow2 = 0.0, mmaxDist = 100.0;\nvec3 ifs_color, ro, light_dir;\n\nmat2 rot(float an) {\n    return mat2(cos(an), -sin(an), sin(an), cos(an));\n}\n\n// Distance estimation function with minimal changes\nfloat de(vec3 p) {\n    vec3 origP = p;\n    ifs_color = vec3(0.0);\n\n    float nn = 2.0;\n    p = mod(p + nn, 2.0 * nn) - nn;\n\n    vec4 q0 = vec4(p, 0.6), q = q0;\n    float i = 0.0;\n\n    // Adding a slight time-based modulation to the fractal iterations\n    for (; i < 7.0; i++) {\n        q.xyz = clamp(q.xyz, -1.0 - 0.05, 1.0 + 0.05) * 2.15 - 1.35 * q.xyz;\n        q.xz *= rot(i * i + iTime * 0.1); // Slightly slower rotation\n        \n        // Minor adjustment to the fractal detail for evolving effect\n        q = q * 0.59 / clamp(max(dot(q.yz, q.yz), max(dot(q.xz, q.xz), dot(q.xy, q.xy))), 0.1, 1.3) + q0;\n    }\n\n    return length(q.xyz) / q.w;\n}\n\n// Ray marching function with minimal changes\nfloat march(vec3 ro, vec3 rd, float mx) {\n    float t = 0.0, eps = 1e-4, distfac = 50.0, hitThreshold = eps;\n    for (int i = 0; i < 200; i++) {\n        vec3 pos = ro + rd * t;\n        float d = de(pos);\n\n        if ((d < hitThreshold && t > 15.0) || t >= mx) break;\n        t += d;\n        hitThreshold = eps * (1.0 + t * t * distfac);\n        float zz = pos.y - light_dir.y;\n        zz *= zz;\n\n        glow += exp(-max((-exp(-zz)) - d, 0.0));\n        glow2 += exp(-d * d) * exp(-t * t / 20.0);\n    }\n    return t;\n}\n\n// Rendering function with subtle dynamic color changes\nvec3 render(vec3 ro, vec3 rd) {\n    light_dir = ro;\n    light_dir.y += 8.0 * sin(iTime * 0.1); // Slightly slower light motion\n\n    float t = march(ro, rd, mmaxDist);\n    vec3 pos = ro + rd * t;\n    vec3 glowSource = light_dir;\n    float glowStr = exp(-length(pos.y - glowSource.y) / 4.0);\n    glow *= glowStr;\n\n    // Minor color changes over time for a subtle evolving effect\n    vec3 dynamicColor = vec3(\n        sin(pos.x * 0.1 + iTime * 0.05) * 0.5 + 0.5,\n        sin(pos.y * 0.1 + iTime * 0.05 + 2.0) * 0.5 + 0.5,\n        sin(pos.z * 0.1 + iTime * 0.05 + 4.0) * 0.5 + 0.5\n    );\n\n    return 1e-2 * pow(glow2, 2.0) * dynamicColor\n           + 1e-9 * pow(glow, 5.0) * dynamicColor;\n}\n\n// Main function for rendering the frame with slight camera adjustments\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y * 0.7;\n\n    vec3 rd = normalize(vec3(p, 1.6));\n\n    // Minimal change to camera position to add subtle dynamism\n    ro = vec3(\n        0.2 + 0.1 * sin(iTime * 0.05), // Very slight horizontal oscillation\n        -0.8 + 0.1 * cos(iTime * 0.05), // Very slight vertical oscillation\n        iTime / 4.0 // Slow forward movement\n    );\n\n    // Apply rotation to the ray direction\n    rd.xz *= rot(0.2);\n    rd.yz *= rot(-0.5);\n\n    // Render the scene and apply a final color transformation\n    vec3 col = clamp(render(ro, rd), 1e-4, 1e6);\n    col = 1.0 - exp(-sqrt(col));\n\n    // Output the final color\n    fragColor = vec4(col, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}