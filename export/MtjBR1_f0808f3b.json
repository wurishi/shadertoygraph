{"ver":"0.1","info":{"id":"MtjBR1","date":"1514651384","viewed":323,"name":"JRS_ParticleTest3","username":"jrs300","description":"Trying out an a approach for rendering particles","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["particles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//Global Variables\n\n//Spawning\n\nint numOfParticles = 100;\n\nfloat gSeed = 213.456;\n\n//Velocity \n\nvec2 vMin = vec2(0.2,-0.25);\nvec2 vMax = vec2(2.0,0.25);\n\nfloat vScaleMin = 0.1;\nfloat vScaleMax = 1.0;\n\n//Life\n    \nfloat lifeMin = 0.8;\nfloat lifeMax = 1.5;\n\n//StartSpread\n\nfloat stSpread = 0.1;\n\n\n//SimTime\n//Creates a looping segment of time to syncronize particle behaviours\n\nfloat sTime()\n{\n//SDur = Sim Duration\n\tfloat sDur = lifeMax;\n\treturn sDur*fract(iTime/sDur);\n}\n\n\n//generates a random value from a seed \n\nfloat rand(float seed)\n{    \n    return fract((seed*7.14376197)+fract(seed*2.5447876)+gSeed);\n}\n\n\n//Linear interpolators for float, vec2 and vec3\n\nvec3 lerpV3(vec3 a, vec3 b, float alpha)\n{\n\treturn (a + alpha*(b-a));\n}\n\nvec2 lerpV2(vec2 a, vec2 b, float alpha)\n{\n\treturn (a + alpha*(b-a));\n}\n\nfloat lerpF(float a, float b, float alpha)\n{\n\treturn (a + alpha*(b-a));\n}\n\n\n// non-uniform interpolation\n// allows x and y values to be altered independantly\nvec2 nui(vec2 a, vec2 b, float alphaA, float alphaB)\n{\n    float x = (a.x + alphaA*(b.x-a.x));\n    float y = (a.y + alphaB*(b.y-a.y));\n    return vec2(x,y);\n}\n\n\n//PARTICLE\n// calculate particle location and render as a radial gradient\n// velocity x time/life plus start location = location\n\nfloat particle(vec2 uv, float seed)\n{\n  \n\t// Random values for velocity\n    float vRandA = fract(rand(seed)*32.456);\n    float vRandB = fract(vRandA+fract(rand(seed))*12.678);\n    float vRandC = fract(vRandB+fract(rand(seed))*24.395);\n    \n    //Rand Value for start time spread\n    float stRand = fract(rand(seed)*121.124);\n    \n\t//Random Value for life  \n    float lRand = fract(rand(seed)*91.124);  \n    \n    //time\n    float t = lifeMax*fract((sTime()/lifeMax)+lerpF(stSpread,0.0,stRand));\n    //float t = sTime;\n    \n    float life= lerpF(lifeMin,lifeMax,lRand);\n\n\t//set particle location\n    vec2 loc = vec2(0.0,0.0);     \n    vec2 sLoc = vec2(0.2,0.5);\n        \n\n\t//Set velocity to an intial random value\n\t//Randomly scales down the velocity to create bunching closer to the emitter\n    vec2 v = nui(vMin,vMax,vRandA,vRandB);\n    v = v*lerpF(vScaleMin,vScaleMax,vRandC); \n    v = v*life;\n                      \n\t//Makes y veclocity proportional to x velocity with some variance   \n    v.y= v.y*((v.x/2.0)+0.5);\n                      \n\t//Generates location based on velcocity and current time    \n    loc = v*fract(clamp(t/life,0.0,1.0))+sLoc; \n                      \n\t//Generates radial gradient to represenet particle                           \n    float p = length(uv-loc)/0.01;    \n    p = 1.0-p;\n    p = clamp(p,0.0,1.0);\n    \n\t//Fades out particle over it's life                    \n    float fade = fract(t/life);    \n    fade = 1.0-fade;    \n    p = p*fade;\n    \n\t//inactivity mask = im\n\t//mask that hides particles that have completed their life \n    float im = step(t/life,1.0); \n    p = p*im;\n        \n    return p;\n}\n\n\n\n\nfloat emitter(vec2 uv)\n{\n\n\tfloat p = 0.0;\n    \n\tfloat lp = 0.0;\n    \n\tfloat vi = 1.0;\n    \n\tvec2 v = vec2(6.0,2.0);\n \n    float seed = 1.0;\n    \n    // for each loop render another particle with a unique seed\n\t// lp = last particle\n\t// p = current particle\n    for (int i = 0; i < 100; ++i) \n    {         \n        vi = vi-0.1;\n        seed = vi*1277.1423557;\n//        v.y = 1.17;\n        lp = particle(uv,seed); \n        p = p+lp;\n    }\n    \n    p = clamp(p,0.0,1.0);\n\treturn p;\n}\n         \n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 pixel = vec3(1.0,1.0,1.0);\n\n    vec2 v = vec2(2.1,0.1);\n    \n    float p = 1.0;\n    \n    p = emitter(uv);\n    \n   \tpixel.x = p;\n    \n   \tpixel.y = p;     \n    \n    pixel.z = p;\n    \n\tfragColor = vec4(pixel,1.0);\n}","name":"Image","description":"","type":"image"}]}