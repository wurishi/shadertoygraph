{"ver":"0.1","info":{"id":"Wd2fWR","date":"1710886540","viewed":184,"name":"Isometric Alphabet","username":"jbsiraudin","description":"Animation of 2d isometric alphabet.\n\nAround 3s compilation on my laptop, it's slow :(\n\nAny suggestion is welcome!","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["2d","isometric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Jean-Baptiste Siraudin @2024\n// Isometric alphabet in 2D drawing\n// A few artifacts on corners I have to look into\n// Plenty of messy/tweaky stuff that could be simplified/improved\n\n// Various code pieces come from iq's 2D sdf library, aka the Bible:\n// https://iquilezles.org/articles/distfunctions2d\n\n#define pW 1./iResolution.y\n#define sW 1./iResolution.x\n#define fill(sdf) smoothstep(4.*pW, 0., sdf)\n#define stroke(sdf, e) smoothstep(4.*pW, 0., abs(sdf)-e)\n\nconst float A = 0.59;\nconst float an = atan(1.);\nconst vec2 ap = vec2(1, A);\nconst vec2 am = vec2(1, -A);\nconst float PI = 3.14159265359;\n// vector controlling the \"luminosity\" of each side of cuboids\nconst vec3 light = vec3(1.0, 0.5, 0.05);\n\n// By IQ : https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb(in vec3 c)\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n// ----------------------------\n// ---------SDF SHAPES---------\n// ----------------------------\n\n// CIRCLE - POLAR COORDINATES\n// Centered on the middle of the screen\n// radius (coord of the point), r (desired radius of the circle)\nfloat _circle(in float radius, in float r)\n{\n    return radius-r;\n}\n\n// ROUND DOTS ON A CIRCLE - POLAR COORDINATES\n// From the work of F.Neyret: https://www.shadertoy.com/view/XsVBz3\n// p (polar coord of the point), n (number of dots), r (radius of the circle), e (radius of a dot)\nfloat _dots(in vec2 p, in float n, in float r, in float e)\n{\n    float u = r * ( fract( p.y*n*0.5/PI ) - .5 ) / (n*0.5/PI);// local coordinates in\n    float v = p.x - r;                               // cells along the circle\n    return length(vec2(u,v))-e;\n}\n\n// sd to a 2D oriented box (point A, point B, width) \n// https://www.shadertoy.com/view/stcfzn\nfloat orientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = p-(a+b)*0.5;\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l*0.5,th);\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\n// sd to a 2D parallelogram (width, height, skew)\n// https://www.shadertoy.com/view/7dlGRf\nfloat parallelogram( in vec2 p, float wi, float he, float sk )\n{\n    vec2  e  = vec2(sk,he);\n    float e2 = sk*sk + he*he;\n\n    p = (p.y<0.0)?-p:p;\n    // horizontal edge\n    vec2  w = p - e; w.x -= clamp(w.x,-wi,wi);\n    vec2  d = vec2(dot(w,w), -w.y);\n    // vertical edge\n    float s = p.x*e.y - p.y*e.x;\n    p = (s<0.0)?-p:p;\n    vec2  v = p - vec2(wi,0); v -= e*clamp(dot(v,e)/e2,-1.0,1.0);\n    d = min( d, vec2(dot(v,v), wi*he-abs(s)));\n    return sqrt(d.x)*sign(-d.y);\n}\n\n// 2d drawing of a cuboid\n// width -> left side of cuboid, depth -> right side of cuboid, height is height\nvoid drawCuboid(inout vec3 c, vec2 p, vec3 color, float width, float height, float depth)\n{   \n    float wTop = width*sin(an);\n    float w = width*0.5;\n    float d = depth*0.5;\n    float h = height*0.5;\n    vec2 p_top = vec2(p.x, p.y/A) + wTop*vec2(cos(an), -sin(an));\n    vec2 p_left = vec2(p.y, p.x) + vec2(-A*w+h, w);\n    vec2 p_right = vec2(p.y, p.x) + vec2(-A*d+h, -d);\n    \n    float top = fill(orientedBox(p_top, vec2(0.), vec2(depth), wTop));\n    float left = fill(parallelogram(p_left, h, w, -A*w));\n    float right = fill(parallelogram(p_right, h, d, A*d));\n    \n    float a = clamp(top + right + left, 0.0, 1.0);\n\n    vec3 result = mix(vec3(0), vec3(light.x*color), top);\n    result = mix(result, vec3(light.y*color), right);\n    result = mix(result, vec3(light.z*color), left);\n    \n    c = mix(c, result, a);\n}\n\n\nvoid drawS(inout vec3 c, in vec2 p, in vec3 color, in float s, in float h)\n{\n    vec2 p_ = p - vec2(0, h) + s*am;\n\n    drawCuboid(c, p_ - s*vec2(9.0, 1.0*A) + 4.*pW*ap, color, 4.*s, h, s);\n    drawCuboid(c, p_ - s*vec2(4.5, 2.5*A) + 3.*pW*ap, color, s, h, 1.5*s);\n    drawCuboid(c, p_ - s*vec2(6.5, -1.5*A) + 2.*pW*ap, color, 4.*s, h, s);\n    drawCuboid(c, p_ - s*vec2(5.0, -3.0*A) + pW*ap, color, s, h, 1.5*s);\n    drawCuboid(c, p_ - s*4.*am, color, 4.*s, h, s);\n}\n\nvoid drawH(inout vec3 c, in vec2 p, in vec3 color, in float s, in float h)\n{\n    vec2 p_ = p - vec2(0, h);\n    \n    drawCuboid(c, p_, color, s, h, 6.*s);\n    drawCuboid(c, p_ - s*vec2(4.5, 0.5*A) + pW*am, color, 2.*s, h, s);\n    drawCuboid(c, p_ - s*3.*am + 2.*pW*am, color, s, h, 6.*s);\n}\n\nvoid drawA(inout vec3 c, in vec2 p, in vec3 color, in float s, in float h)\n{\n    vec2 p_ = p - vec2(0, h);\n    \n    drawCuboid(c, p_, color, s, h, 6.*s);\n    drawCuboid(c, p_ - s*vec2(7., 3.*A) + pW*am, color, 2.*s, h, s);\n    drawCuboid(c, p_ - s*vec2(4.5, 0.5*A) + pW*am, color, 2.*s, h, s);\n    drawCuboid(c, p_ - s*3.*am + 2.*pW*am, color, s, h, 6.*s);\n}\n\nvoid drawD(inout vec3 c, in vec2 p, in vec3 color, in float s, in float h)\n{  \n    vec2 p_ = p - vec2(0, h) + s*am;\n\n    drawCuboid(c, p_ - s*vec2(9.0, 1.0*A) + 2.*pW*ap, color, 4.*s, h, s);\n    drawCuboid(c, p_ - s*vec2(2.3, -0.3*A) + pW*ap, color, s, h, 4.*s);\n    drawCuboid(c, p_ - s*vec2(5.0, -3.0*A) + pW*ap, color, s, h, 4.*s);\n    drawCuboid(c, p_ - s*4.*am, color, 4.*s, h, s);\n}\n\nvoid drawE(inout vec3 c, in vec2 p, in vec3 color, in float s, in float h)\n{\n\tvec2 p_ = p - vec2(0, h) + s*am;\n\n    drawCuboid(c, p_ - s*vec2(9.0, A) + 2.*pW*ap, color, 4.*s, h, s);\n    drawCuboid(c, p_ - s*vec2(2.0, 0) + pW*ap, color, s, h, 4.*s);\n    drawCuboid(c, p_ - s*vec2(5.5, -0.5*A) + pW*am, color, 2.*s, h, s);\n    drawCuboid(c, p_ - s*4.*am, color, 4.*s, h, s);\n}\n\nvoid drawR(inout vec3 c, in vec2 p, in vec3 color, in float s, in float h)\n{\n    vec2 p_ = p - vec2(0, h);\n    \n    drawCuboid(c, p_, color, s, h, 6.0*s);\n    drawCuboid(c, p_ - s*vec2(6.5, 3.5*A) + pW*am, color, 1.5*s, h, s);\n    drawCuboid(c, p_ - s*vec2(5.0, 0) + 2.*pW*am, color, s, h, 3.5*s);\n    drawCuboid(c, p_ - s*vec2(5.5, -0.5*A) + 2.*pW*vec2(1, 0), color, 3.*s, h, s);\n    drawCuboid(c, p_ - s*3.*am + 1.*pW*am, color, s, h, 2.5*s);\n}\n\nvoid drawT(inout vec3 c, in vec2 p, in vec3 color, in float s, in float h)\n{\n    vec2 p_ = p - vec2(0, h) + s*am;\n\n    drawCuboid(c, p_ - s*vec2(9.0, A) + pW*ap, color, 4.*s, h, s);\n    drawCuboid(c, p_ - s*2.5*am, color, s, h, 5.*s);  \n}\n\nvoid drawO(inout vec3 c, in vec2 p, in vec3 color, in float s, in float h)\n{\n    vec2 p_ = p - vec2(0, h) + s*am;\n\n    drawCuboid(c, p_ - s*vec2(9.0, 1.0*A) + 2.*pW*ap, color, 4.*s, h, s);\n    drawCuboid(c, p_ - s*vec2(2., 0) + pW*ap, color, s, h, 4.*s);\n    drawCuboid(c, p_ - s*vec2(5.0, -3.0*A) + pW*ap, color, s, h, 4.*s);\n    drawCuboid(c, p_ - s*4.*am, color, 4.*s, h, s);\n}\n\nvoid drawY(inout vec3 c, in vec2 p, in vec3 color, in float s, in float h)\n{\n    vec2 p_ = p - vec2(0, h) + s*am;\n\n    drawCuboid(c, p_ - s*vec2(4.5, 2.5*A) + 2.*pW*ap, color, s, h, 2.5*s);\n    drawCuboid(c, p_ - s*vec2(7.5, -0.5*A) + 2.*pW*ap, color, s, h, 2.5*s);   \n    drawCuboid(c, p_ - s*vec2(6.5, -1.5*A) + pW*ap, color, 4.*s, h, s);\n    drawCuboid(c, p_ - s*2.5*am, color, s, h, 2.5*s);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    // Polar coordinates\n    float angle = atan(p.y,p.x);\n    float radius = length(p);\n    \n    // scale\n    float s = 0.02;\n    // time\n    float t = -5.*iTime;\n    // spacing\n    float sp = 6.;\n    \n    vec3 col = vec3(0);\n    vec2 p_ = p + 3.*s*ap;\n    \n    float h = 2.*s*(1.0+0.35*cos(5.*PI*(p.x-A*p.y)+t));\n    drawCuboid(col, p_ - 5.*s*sp*am + 6.*s*ap - vec2(0, h), vec3(1.0, 1.0, 0.0), 56.*s, h, s);\n    \n    // basic optim to avoid drawing in void areas, could be better targeted\n    if (radius < 0.8) {\n        drawS(col, p_ + 4.*s*sp*am, vec3(1.0, 0.5, 0.0), s, s*(1.0 + sin(t)));\n        drawH(col, p_ + 3.*s*sp*am, vec3(1.0, 0.0, 0.0), s, s*(1.0+sin(t+0.2*PI)));\n        drawA(col, p_ + 2.*s*sp*am, vec3(1.0, 0.0, 0.5), s, s*(1.0+sin(t+0.4*PI)));\n        drawD(col, p_ + 1.*s*sp*am, vec3(0.5, 0.0, 1.0), s, s*(1.0+sin(t+0.6*PI)));\n        drawE(col, p_, vec3(0.0, 0.0, 1.0), s, s*(1.0+sin(t+0.8*PI)));\n        drawR(col, p_ - 1.*s*sp*am, vec3(0.0, 0.5, 1.0), s, s*(1.0+sin(t+1.0*PI)));\n        drawT(col, p_ - 2.*s*sp*am, vec3(0.0, 1.0, 0.5), s, s*(1.0+sin(t+1.2*PI)));\n        drawO(col, p_ - 3.*s*sp*am, vec3(0.0, 1.0, 0.0), s, s*(1.0+sin(t+1.4*PI)));\n        drawY(col, p_ - 4.*s*sp*am, vec3(0.5, 1.0, 0.0), s, s*(1.0+sin(t+1.6*PI)));\n    }\n    \n    float a = stroke(_circle(radius, 0.8), 4.*sW);\n    a += fill(_dots(vec2(radius, angle + iTime/4.), 100., 0.9, sW*1.));\n   \n    vec3 hue = hsv2rgb(vec3(fract(-iTime/4.)+(angle/(2.*PI)), radius*2., 1.0));\n    col = mix(col, hue, a);\n    \n\tfragColor = vec4(sqrt(col), 1.0);\n}","name":"Image","description":"","type":"image"}]}