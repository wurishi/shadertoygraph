{"ver":"0.1","info":{"id":"Ntl3Wf","date":"1623012772","viewed":153,"name":"2d texture volumetric","username":"wangkepfe","description":"emulate tex3d using tex2d","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["sampler"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 bilinearSampleZSlice(vec2 uv)\n{\n    uv = uv * 512.0 / iResolution.xy;\n    return texture(iChannel0, uv);\n}\n\nvec4 trilinearClamp(in vec3 uvz)\n{\n    // clamp\n    float lo = 0.5 / 64.0;\n    float hi = 63.5 / 64.0;\n    uvz.x = clamp(uvz.x, lo, hi);\n    uvz.y = clamp(uvz.y, lo, hi);\n    uvz.z = clamp(uvz.z, lo, hi);\n\n    // tile uv\n    vec2 uv = uvz.xy / 8.0;\n    \n    // z slice\n    float zScaled = uvz.z * 64.0 - 0.5;\n    int z1 = int(floor(zScaled));\n    int z2 = z1 + 1;\n\n    // find tile and offset\n    vec2 tile1 = vec2(z1 % 8, z1 / 8);\n    vec2 tile2 = vec2(z2 % 8, z2 / 8);\n    \n    vec2 offset1 = tile1 / 8.0;\n    vec2 offset2 = tile2 / 8.0;\n    \n    // uv for sampling\n    vec2 uv1 = offset1 + uv;\n    vec2 uv2 = offset2 + uv;\n    \n    // bilinear sampling\n    vec4 v1 = bilinearSampleZSlice(uv1);\n    vec4 v2 = bilinearSampleZSlice(uv2);\n    \n    // distance to v1\n    float f = fract(zScaled);\n    \n    // linear interp\n    vec4 res = mix(v1, v2, f);\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec4 col;\n    \n    if (uv.x <= 0.5 && uv.y <= 0.5)\n    {\n        uv *= 2.0;\n        col = bilinearSampleZSlice(uv);\n    }\n    else if (uv.x <= 0.5 && uv.y > 0.5)\n    {\n        uv.y -= 0.5;\n        uv *= 2.0;\n        col = trilinearClamp(vec3(uv.x, cos(iTime) / 2.0 + 0.5, uv.y));\n    }\n    else if (uv.x > 0.5 && uv.y <= 0.5)\n    {\n        uv.x -= 0.5;\n        uv *= 2.0;\n        col = trilinearClamp(vec3(uv, cos(iTime) / 2.0 + 0.5));\n    }\n    else\n    {\n        uv -= 0.5;\n        uv *= 2.0;\n        col = trilinearClamp(vec3(cos(iTime) / 2.0 + 0.5, uv.x, uv.y));\n    }\n    \n    //uv = fragCoord / iResolution.xy;\n    //col = trilinearClamp(vec3(uv, cos(iTime) / 2.0 + 0.5));\n\n    fragColor = vec4(col); \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float plasma(vec2 uv, float t)\n{\n    float v1 = sin(uv.x*5.0 + t*0.03);\n    float v2 = sin(5.0*(uv.x*sin(t * 0.02) + uv.y*cos(t * 0.33)) + t);\n    float cx = uv.x + sin(t * 0.01)*5.0;\n    float cy = uv.y + sin(t * 0.053)*5.0;\n    float v3 = sin(sqrt(100.0*(cx*cx + cy*cy)) + t * 0.01);\n    float vf = v1 + v2 + v3; \n    return cos(vf*2.0) * 0.5 + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.x>512.0 || fragCoord.y>512.0)\n        return;\n\n    int tileX = int(fragCoord.x) / 64;\n    int tileY = int(fragCoord.y) / 64;\n    int tileN = tileX + tileY*8;\n\n    float tileUVX = float(int(fragCoord.x) % 64);\n    float tileUVY = float(int(fragCoord.y) % 64);\n    vec2 uv = vec2(tileUVX, tileUVY) / 64.;\n    float res = plasma(uv, iTime * 0.2 + float(tileN) / 16.0);\n\n    float check2 = fract(uv.x*1.5) > 0.5 ? 0.0 : 1.0;\n    check2 += fract(uv.y) > 0.5 ? 0.0 : 1.0;\n    check2 = check2==1.0?1.0:0.0; \n    float border = 1.0;\n    float check = ((tileUVX < border || tileUVY < border ) ? 1.0 : 0.0);\n    check += ((tileUVX > 63.0-border || tileUVY > 63.0-border) ? 1.0 : 0.0);\n\n    // G = plasma volume, R & B are patterns that mark the borders (useful for debugging)\n    fragColor = vec4(check, res, check2, 1.0); \n}","name":"Buffer A","description":"","type":"buffer"}]}