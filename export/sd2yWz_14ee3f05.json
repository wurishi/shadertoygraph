{"ver":"0.1","info":{"id":"sd2yWz","date":"1643397375","viewed":195,"name":"Cloud Computing: Fibonacci","username":"stegu","description":"By running this shader, you are participating in a global effort to make GPUs do useless things for fun.\n\nShout-out to @dr2 who did https://www.shadertoy.com/view/tsccWB. I had the same idea, although I implemented it very differently.","likes":28,"published":1,"flags":0,"usePreview":0,"tags":["distancefield","silly","flownoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This is a classic \"surface shader\", a pure 2-D function.\n// You won't find a single trace (hah) of raymarching here,\n// However, there's a ton of noise weighing it down somewhat.\n// Also, I should have partitioned the numbers better into\n// regions of interest instead of evaluating every character\n// at every fragment. The speed of modern GPUs makes me lazy...\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Fit [0,1] in u across viewport width, accept whatever for v\n    vec2 uv = fragCoord/iResolution.x;\n\n    float speed = 0.5; // Number of increments per second\n    float pause = 1.0*speed; // Brief pause at the end\n    float outro = 2.0*speed; // Swipe out\n    float intro = 2.0*speed; // Swipe in\n    float maxcount = 34.0;\n    float repeat = maxcount + pause + outro + intro;\n    float time = mod(iTime*speed, repeat);\n    \n    // Tweak: \"intro\" is actually last, just before the animation repeats\n    float count = clamp(time, 0.0, maxcount)\n        - maxcount*step(repeat-intro, time);\n\n    // \"Swipe\" transition effect for the repeat loop\n    float swipeout = smoothstep(0.0, 0.5, clamp(time-maxcount-pause, 0.0, outro)/outro);\n    float swipein = smoothstep(0.0, 0.5, clamp(time-maxcount-pause-outro, 0.0, intro)/intro);\n    // zap +1 to -1 at the change from swipe-out to swipe-in\n    float shazam = 2.0*step(maxcount+outro+pause, time);\n    uv = uv - vec2(swipeout+swipein-shazam, 0.0);\n\n    // Make room for 7 digits (2^21 ~ 2e6 is max exact integer in a float)\n    float numchars = 7.0;\n    // Add 1/2 char width margin to either side\n    vec2 p = uv*(numchars+1.0)*7.0 - vec2(4.0, 4.0);\n\n    // A slow moving, large size noise for a global bobbing motion\n    vec2 bob;\n    // We discard the noise value here, and use only the gradient\n    psrdnoise(p*0.1 + vec2(iTime*0.2, 0.0), vec2(0.0), iTime, bob);\n    p = p + 0.07*bob; // This is Swedish \"lagom mycket\", says Bob.\n\n    float i, j;\n    i = mod(floor(count), 100.0);  // Current Fibonacci-index\n    j = mod(floor(count)+1.0, 100.0); // Next index, for the morph targets\n\n    // Cross-fade for a while, then display a single number for a while\n    float fadetime = 0.4; // Fade for this fraction of the time\n    float fade = (clamp(fract(count),\n        0.5-0.5*fadetime, 0.5+0.5*fadetime) - 0.5)/fadetime + 0.5;\n\n    // Position the counter digits (Display handles 0-99, up to F47 fits\n    // in a uint, but our computation of Fn with floats maxes out at F31)\n    int i10 = int(floor(i/10.0));\n    int i1 = int(floor(mod(i, 10.0)));\n    int j10 = int(floor(j/10.0));\n    int j1 = int(floor(mod(j, 10.0)));\n\n    float push1 = mix(step(10.0, i), step(10.0, j), fade);\n    vec2 pos10 = vec2(7.0, 14.0);\n    vec2 pos1 = vec2(7.0+7.0*push1, 14.0);\n\n    float fade10 = (j == 10.0) ? fade : 1.0; // Special case: 9 to 10\n    float dFh, d10; // Fh for \"Fibonacci header\"\n    dFh = mix(number(i1, p-pos1), number(j1, p-pos1), fade);\n    if((i >= 9.0)) {\n        if(i == 9.0) i10 = 1; // hack: do not fade out the previously hidden \"0\"\n        d10 = mix(number(i10, p-pos10), number(j10, p-pos10), fade);\n        d10 = (d10+0.1) / (fade10*0.99 + 0.01) - 0.1; // Pop in the \"new\" digit\n        dFh = min(dFh, d10);\n    }\n\n    float Fi = fibonacci(i); // Current number\n    float Fj = fibonacci(j); // Next number, the morph target\n    \n    // Position the Fibonacci numner digits\n    float idigits = floor(log(max(Fi,1.0))/log(10.0))+1.0; // Dodge -Inf for 0\n    float jdigits = floor(log(max(Fj,1.0))/log(10.0))+1.0;\n    float numdigits = max(idigits, jdigits); // Always = jdigits when counting up\n    // dFi is the blended distance field for the Fibonacci number.\n    float dFi = 1e10;\n    float dFidigit, dFjdigit;\n    int Fidigit, Fjdigit;\n    float ddigit;\n    vec2 currentpoint = vec2((7.0-numdigits)*7.0, 0.0); // Starting point for the display of Fi\n    float msd = floor(pow(10.0, numdigits)+0.5); // Power-of-10 weight for leftmost digit\n    for(float loop = 0.0; loop < numdigits; loop++) {\n        Fidigit = int(floor(mod(Fi, msd)*10.0/msd)+0.5); // Mask out one base-10 digit\n        Fjdigit = int(floor(mod(Fj, msd)*10.0/msd)+0.5); // Mask out one base-10 digit\n        // hack: do not fade out a previously hidden leading \"0\"\n        if((loop == 0.0) && (Fi != 0.0) && (Fidigit == 0)) dFidigit = 5.0;\n        else dFidigit = number(Fidigit, p - currentpoint);\n        dFjdigit = number(Fjdigit, p - currentpoint);\n        ddigit = mix(dFidigit, dFjdigit, fade);\n        dFi = min(dFi, ddigit);\n        msd *= 0.1;\n        currentpoint += vec2(7.0, 0.0);\n    }\n\n    // Fluffy!\n    vec2 g, gsum;\n    float n = psrdnoise(p*0.5, vec2(0.0), iTime*0.5, gsum);\n    n += 0.5*psrdnoise(p-0.12*gsum, vec2(0.0), iTime*1.0, g);\n    gsum += g;\n    n += 0.25*psrdnoise(p*2.0-0.12*gsum, vec2(0.0), iTime*2.0, g);\n    gsum += g;\n    n += 0.125*psrdnoise(p*4.0-0.12*gsum, vec2(0.0), iTime*4.0, g);\n    gsum += g;\n    n += 0.0625*psrdnoise(p*8.0-0.12*gsum, vec2(0.0), iTime*8.0, g);\n\n    // Hide some ugliness by growing the clouds slightly during transitions\n    float bloat = clamp(fract(count), 0.1, 0.9)*1.25-0.125;\n    bloat = abs(bloat-0.5);\n    bloat = smoothstep(0.0, 0.5, bloat); // for smooth motion\n\n    dFh += 0.2*bloat;\n    // Add the \"F\", and make it grow and shrink less as it doesn't morph\n    dFh = min(dFh, nixieF(p-vec2(0.0, 14.0))+0.1*bloat);\n    // The second line of numbers should pulsate as well, though\n    dFi += 0.2*bloat;\n\n    // Add fluffy noise to the entire distance field\n    float dn = min(dFh, dFi) + 0.25*n;\n\n    float cloudmask = 1.0-aasmoothstep(1.1, 1.3, dn*dn);\n    // Modulate the color with the *same* noise as the outline\n    vec3 cloudcolor = mix(vec3(1.0), vec3(0.8-0.2*n), dn*dn*dn);\n    // A slight gradient for the blue sky in the background\n    vec3 skycolor = mix(vec3(0.4,0.7,1.0), vec3(0.1,0.3,1.0), uv.y);\n    vec3 mixcolor = mix(skycolor, cloudcolor, cloudmask);\n    fragColor = vec4(mixcolor,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// psrdnoise (c) Stefan Gustavson and Ian McEwan,\n// ver. 2021-12-02, published under the MIT license:\n// https://github.com/stegu/psrdnoise/\nfloat psrdnoise(vec2 x, vec2 period, float alpha, out vec2 gradient)\n{\n\tvec2 uv = vec2(x.x+x.y*0.5, x.y);\n\tvec2 i0 = floor(uv), f0 = fract(uv);\n\tfloat cmp = step(f0.y, f0.x);\n\tvec2 o1 = vec2(cmp, 1.0-cmp);\n\tvec2 i1 = i0 + o1, i2 = i0 + 1.0;\n\tvec2 v0 = vec2(i0.x - i0.y*0.5, i0.y);\n\tvec2 v1 = vec2(v0.x + o1.x - o1.y*0.5, v0.y + o1.y);\n\tvec2 v2 = vec2(v0.x + 0.5, v0.y + 1.0);\n\tvec2 x0 = x - v0, x1 = x - v1, x2 = x - v2;\n\tvec3 iu, iv, xw, yw;\n\tif(any(greaterThan(period, vec2(0.0)))) {\n\t\txw = vec3(v0.x, v1.x, v2.x);\n\t\tyw = vec3(v0.y, v1.y, v2.y);\n\t\tif(period.x > 0.0)\n\t\t\txw = mod(vec3(v0.x, v1.x, v2.x), period.x);\n\t\tif(period.y > 0.0)\n\t\t\tyw = mod(vec3(v0.y, v1.y, v2.y), period.y);\n\t\tiu = floor(xw + 0.5*yw + 0.5); iv = floor(yw + 0.5);\n\t} else {\n\t\tiu = vec3(i0.x, i1.x, i2.x); iv = vec3(i0.y, i1.y, i2.y);\n\t}\n\tvec3 hash = mod(iu, 289.0);\n\thash = mod((hash*51.0 + 2.0)*hash + iv, 289.0);\n\thash = mod((hash*34.0 + 10.0)*hash, 289.0);\n\tvec3 psi = hash*0.07482 + alpha;\n\tvec3 gx = cos(psi); vec3 gy = sin(psi);\n\tvec2 g0 = vec2(gx.x, gy.x);\n\tvec2 g1 = vec2(gx.y, gy.y);\n\tvec2 g2 = vec2(gx.z, gy.z);\n\tvec3 w = 0.8 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2));\n\tw = max(w, 0.0); vec3 w2 = w*w; vec3 w4 = w2*w2;\n\tvec3 gdotx = vec3(dot(g0, x0), dot(g1, x1), dot(g2, x2));\n\tfloat n = dot(w4, gdotx);\n\tvec3 w3 = w2*w; vec3 dw = -8.0*w3*gdotx;\n\tvec2 dn0 = w4.x*g0 + dw.x*x0;\n\tvec2 dn1 = w4.y*g1 + dw.y*x1;\n\tvec2 dn2 = w4.z*g2 + dw.z*x2;\n\tgradient = 10.9*(dn0 + dn1 + dn2);\n\treturn 10.9*n;\n}\n\n// Compute Fibonacci number n without a loop\n// (using Binet's formula without the correction term, rounding instead)\n// (and adjusting for a few rounding errors at the limit of the \"float\" range)\nfloat fibonacci(float n) {\n    if(n >= 30.0) {\n        if(n == 30.0) return 832040.0; // This has a rounding error in 32-bit\n        if(n == 32.0) return 2178309.0; // This, too\n        if(n == 33.0) return 3524578.0; // And this\n        if(n == 34.0) return 5702887.0; // And this\n    }\n    // F(35) is not representable exactly as a float\n    // (odd number, LSB truncated when >2^23)\n    // All other cases are handled by this \"approximation\" (it's exact\n    // after rounding, and barring numerical problems it works for all n)\n    return floor(pow((sqrt(5.0)+1.0)/2.0, n)/sqrt(5.0)+0.5);\n}\n\n// Compute the shortest distance from p\n// to a line segment from p1 to p2.\nfloat lined(vec2 p1, vec2 p2, vec2 p) {\n    vec2 p1p2 = p2 - p1;\n    vec2 v = normalize(p1p2);\n    vec2 s = p - p1;\n    float t = dot(v, s);\n    if (t<0.0) return length(s);\n    if (t>length(p1p2)) return length(p - p2);\n    return length(s - t*v);\n}\n\n// Compute the shortest distance from p to a circle\n// with center at c and radius r. (Extremely simple.)\nfloat circled(vec2 c, float r, vec2 p) {\n    return abs(length(p - c) - r);\n}\n\n// Compute the shortest distance from p to a\n// circular arc with center c from p1 to p2.\n// p1, p2 are in the +angle direction (ccw),\n// to resolve the major/minor arc ambiguity, so\n// specifying p1, p2 in the wrong order will\n// yield the complement to the arc you wanted.\n// If p1 = p2, the entire circle is drawn, but\n// you don't want to use this function to draw\n// a circle. Use the simple circled() instead.\n// If p1 and p2 have different distances to c,\n// the end of the arc will not look right. If\n// this is inconvenient, uncomment the 3rd line.\nfloat arcd(vec2 c, vec2 p1, vec2 p2, vec2 p) {\n\n    vec2 v1 = p1 - c;\n    vec2 v2 = p2 - c;\n    // Optional: make sure p1, p2 are both on the circle\n    // v2 = normalize(v2)*length(v1);\n    vec2 v = p - c;\n\n    vec2 w = vec2(dot(v, -vec2(-v1.y, v1.x)), dot(v, vec2(-v2.y, v2.x)));\n\n    if(dot(v1, vec2(-v2.y, v2.x)) >= 0.0) { // Arc angle <= pi\n        if(all(lessThan(vec2(0.0), w))) {\n            return min(length(p1-p), length(p2-p)); // nearest end\n        } else {\n            return abs(length(v) - length(v1)); // dist to arc\n        }\n    } else { // Arc angle > pi\n        if(any(lessThan(vec2(0.0), w))) {\n            return min(length(p1-p), length(p2-p));\n        } else {\n            return abs(length(v) - length(v1));\n        }\n    }\n}\n\n// A convenient anti-aliased step() using auto derivatives\nfloat aastep(float threshold, float value) {\n    float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n}\n\n// A smoothstep() that blends to an aastep() under minification\nfloat aasmoothstep(float t1, float t2, float v) {\n\tfloat aw = 0.7 * length(vec2(dFdx(v), dFdy(v)));\n\tfloat sw = max(0.5*(t2-t1), aw);\n\tfloat st = 0.5*(t1+t2);\n\treturn smoothstep(st-sw, st+sw, v);\n}\n\n// Distance field of a hexagonal (simplex) grid\n// The return vector contains the distances to the\n// three closest points, sorted by magnitude.\nvec3 hexgrid(vec2 p) {\n\n    const float stretch = 1.0/0.8660; // No use for tiling here,\n    const float squash = 0.8660;  // use unmodified simplex grid\n\t\n    //  v.y = v.y + 0.0001; // needed w/ stretched grid (rounding errors)\n    p.y = p.y * stretch;\n    // Transform to grid space (axis-aligned, modified \"simplex\" grid)\n    vec2 uv = vec2(p.x + p.y*0.5, p.y);\n    // Determine which simplex we're in, with i0 being the \"base\"\n    vec2 i0 = floor(uv);\n    vec2 f0 = fract(uv);\n    // o1 is the offset in simplex space to the second corner\n    float cmp = step(f0.y, f0.x);\n    vec2 o1 = vec2(cmp, 1.0-cmp);\n    // Enumerate the remaining simplex corners\n    vec2 i1 = i0 + o1;\n    vec2 i2 = i0 + vec2(1.0, 1.0);\n    // Transform corners back to texture space\n    vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n    vec2 p1 = vec2(p0.x + o1.x - o1.y * 0.5, p0.y + o1.y);\n    vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n    vec3 d = vec3(length(p-p0), length(p-p1), length(p-p2));\n    // Only three values - bubble sort is just fine.\n    d.yz = (d.y < d.z) ? d.yz : d.zy;\n    d.xy = (d.x < d.y) ? d.xy : d.yx;\n    d.yz = (d.y < d.z) ? d.yz : d.zy;\n    return d;\n}\n\n// The digits. Simple functions, only a lot of them.\n\n// These glyphs and their implementation as distance fields\n// are the original work of me (stefan.gustavson@gmail.com),\n// and the code below is released under the MIT license:\n// https://opensource.org/licenses/MIT\n// (If that is inconvenient for you, let me know. I'm reasonable.)\n//\n// Experts say mortals should not attempt to design character shapes.\n// \"It's just ten simple digits\", I thought, \"How hard can it be?\"\n// A week later, after countless little tweaks to proportions and\n// curvature, and with a notepad full of sketches and pen-and-paper\n// math, some of it horribly wrong because it was decades since I\n// solved this kind of equations by hand, I know the answer:\n// It can be *really* hard. But also loads of fun!\n//\nfloat nixie0(vec2 p) {\n    // Special hack instead of pasting together arcs and lines\n    float d = lined(vec2(2.0), vec2(2.0, 6.0), p);\n    return abs(d - 2.0);\n}\n\nfloat nixie1(vec2 p) {\n    float d1 = lined(vec2(2.0, 0.0), vec2(2.0, 8.0), p);\n    float d2 = lined(vec2(2.0, 8.0), vec2(1.0, 6.0), p);\n    return min(d1, d2);\n}\n\nfloat nixie1alt(vec2 p) { // Straight line\n    return lined(vec2(2.0, 0.0), vec2(2.0, 8.0), p);\n}\n\nfloat nixie2(vec2 p) {\n    const float x = 3.2368345;\n    const float y = 4.4283002;\n    float d1 = lined(vec2(4.25, 0.0), vec2(-0.25, 0.0), p);\n    float d2 = arcd(vec2(10.657842, -5.001899),\n                    vec2(x, y), vec2(-0.25, 0.0), p);\n    float d3 = arcd(vec2(2.0, 6.0), vec2(x, y), vec2(0.0, 6.0), p);\n    return min(min(d1, d2), d3);\n}\n\nfloat nixie2alt(vec2 p) { // Straight neck\n    float d1 = lined(vec2(4.0, 0.0), vec2(0.0), p);\n    float d2 = lined(vec2(0.0), vec2(3.6, 4.8), p);\n    float d3 = arcd(vec2(2.0, 6.0), vec2(3.6, 4.8), vec2(0.0, 6.0), p);\n    return min(min(d1, d2), d3);\n}\n\nfloat nixie3(vec2 p) {\n    // Two round parts\n    // float d1 = arcd(vec2(2.0, 2.1), vec2(-0.1, 2.1), vec2(2.0, 4.2), p);\n    // float d2 = arcd(vec2(2.0, 6.1), vec2(2.0, 4.2), vec2(0.1, 6.1), p);\n    // Angled top, more like classic Nixie tube digits\n    float d1 = arcd(vec2(2.0, 2.25), vec2(-0.25, 2.25), vec2(2.0, 4.5), p);\n    float d2 = lined(vec2(2.0, 4.5), vec2(4.0, 7.75), p);\n    float d3 = lined(vec2(4.0, 7.75), vec2(0.0, 7.75), p);\n    return min(min(d1, d2), d3);\n}\n\nfloat nixie3alt(vec2 p) { // Same size loops\n    float d1 = arcd(vec2(2.0), vec2(0.0, 2.0), vec2(2.0, 4.0), p);\n    float d2 = arcd(vec2(2.0, 6.0), vec2(2.0, 4.0), vec2(0.0, 6.0), p);\n    return min(d1, d2);\n}\n\n\nfloat nixie4(vec2 p) { // Pointy top\n    // This digit is 5.0 units wide, most others are 4.0 or 4.5\n    float d1 = lined(vec2(4.0, 0.0), vec2(4.0, 8.0), p);\n    float d2 = lined(vec2(4.0, 8.0), vec2(0.0, 2.0), p);\n    float d3 = lined(vec2(0.0, 2.0), vec2(5.0, 2.0), p); // 1.0 wider than all others\n    return min(min(d1, d2), d3);\n}\n\n\nfloat nixie4alt(vec2 p) {\n    // This digit is 4.0 units wide, but looks cropped\n    float d1 = lined(vec2(4.0, 0.0), vec2(4.0, 8.0), p);\n    float d2 = lined(vec2(4.0, 8.0), vec2(0.0, 2.0), p);\n    float d3 = lined(vec2(0.0, 2.0), vec2(4.0, 2.0), p);\n    return min(min(d1, d2), d3);\n}\n\nfloat nixie5(vec2 p) {\n    float d1 = lined(vec2(4.0, 7.75), vec2(0.5, 7.75), p);\n    float d2 = lined(vec2(0.5, 7.75), vec2(0.0, 4.5), p);\n    float d3 = lined(vec2(0.0, 4.5), vec2(2.0, 4.5), p);\n    float d4 = arcd(vec2(2.0, 2.25), vec2(-0.25, 2.25), vec2(2.0, 4.5), p);\n    return min(min(d1, d2), min(d3, d4));\n}\n\nfloat nixie5alt(vec2 p) {\n    float d1 = lined(vec2(4.0, 8.0), vec2(0.0, 8.0), p);\n    float d2 = lined(vec2(0.0, 8.0), vec2(0.0, 5.0), p);\n    float d3 = lined(vec2(0.0, 5.0), vec2(2.0, 5.0), p);\n    float d4 = arcd(vec2(2.0, 3.0), vec2(4.0, 3.0), vec2(2.0, 5.0), p);\n    float d5 = lined(vec2(4.0, 3.0), vec2(4.0, 2.0), p);\n    float d6 = arcd(vec2(2.0), vec2(0.0, 2.0), vec2(4.0, 2.0), p);\n    return min(min(min(d1, d2), min(d3, d4)), min(d5, d6));\n}\n\nfloat nixie6(vec2 p) {\n    float d1 = arcd(vec2(84.0/13.0, 2.25), vec2(3.0, 8.0), vec2(-0.25, 2.25), p);\n    float d2 = circled(vec2(2.0, 2.25), 2.25, p);\n    return min(d1, d2);\n}\n\nfloat nixie6alt(vec2 p) { // Straight neck\n    float d1 = lined(vec2(0.4, 3.2), vec2(3.0, 8.0), p);\n    float d2 = circled(vec2(2.0), 2.0, p);\n    return min(d1, d2);\n}\n\nfloat nixie7(vec2 p) {\n    float d1 = lined(vec2(0.0, 7.75), vec2(0.25*sqrt(2259.0)-8.0, 7.75), p);\n    float d2 = arcd(vec2(-8.0, 12.0), vec2(2.5, 5.0), vec2(0.25*sqrt(2259.0)-8.0, 7.75), p);\n    float d3 = arcd(vec2(10.0, 0.0), vec2(2.5, 5.0), vec2(10.0-2.5*sqrt(13.0), 0.0), p);\n    return min(min(d1, d2), d3);\n}\n\nfloat nixie7alt(vec2 p) { // Straight neck\n    float d1 = lined(vec2(0.0, 8.0), vec2(4.0, 8.0), p);\n    float d2 = lined(vec2(4.0, 8.0), vec2(1.0, 0.0), p);\n    return min(d1, d2);\n}\n\nfloat nixie8(vec2 p) {\n    float d1 = circled(vec2(2.0, 2.2), 2.2, p);\n    float d2 = circled(vec2(2.0, 6.2), 1.8, p);\n    return min(d1, d2);\n}\n\nfloat nixie8alt(vec2 p) { // Same size loops\n    float d1 = circled(vec2(2.0), 2.0, p);\n    float d2 = circled(vec2(2.0, 6.0), 2.0, p);\n    return min(d1, d2);\n}\n\nfloat nixie9(vec2 p) {\n    float d1 = arcd(vec2(-32.0/13.0, 5.75), vec2(1.0, 0.0), vec2(4.25, 5.75), p);\n    float d2 = circled(vec2(2.0, 5.75), 2.25, p);\n    return min(d1, d2);\n}\n\nfloat nixie9alt(vec2 p) { // Straight neck\n    float d1 = lined(vec2(3.6, 4.8), vec2(1.0, 0.0), p);\n    float d2 = circled(vec2(2.0, 6.0), 2.0, p);\n    return min(d1, d2);\n}\n\nfloat nixieminus(vec2 p) {\n    return lined(vec2(0.5, 4.0), vec2(3.5, 4.0), p);\n}\n\nfloat nixieequals(vec2 p) {\n    float d1 = lined(vec2(0.5, 3.0), vec2(3.5, 3.0), p);\n    float d2 = lined(vec2(0.5, 5.0), vec2(3.5, 5.0), p);\n    return min(d1, d2);\n}\n\nfloat nixieplus(vec2 p) {\n    float d1 = lined(vec2(0.0, 4.0), vec2(4.0, 4.0), p);\n    float d2 = lined(vec2(2.0, 2.0), vec2(2.0, 6.0), p);\n    return min(d1, d2);\n}\n\nfloat nixiedot(vec2 p) {\n    // circled with r=0 yields a point, but with more work\n    return length(p - vec2(2.0, 0.0));\n}\n\nfloat nixiecolon(vec2 p) {\n    float d1 = length(p - vec2(2.0));\n    float d2 = length(p - vec2(2.0, 5.0));\n    return min(d1, d2);\n}\n\nfloat nixieF(vec2 p) {\n    float d1 = lined(vec2(0.0, 8.0), vec2(4.0, 8.0), p);\n    float d2 = lined(vec2(0.0, 8.0), vec2(0.0, 0.0), p);\n    float d3 = lined(vec2(0.0, 4.0), vec2(3.0, 4.0), p);\n    return min(min(d1, d2), d3);\n}\n// End of MIT-licensed code\n\n\nfloat number(int n, vec2 p) {\n    switch(n) {\n        case 0: return nixie0(p);\n        case 1: return nixie1(p);\n        case 2: return nixie2(p);\n        case 3: return nixie3(p);\n        case 4: return nixie4(p);\n        case 5: return nixie5(p);\n        case 6: return nixie6(p);\n        case 7: return nixie7(p);\n        case 8: return nixie8(p);\n        case 9: return nixie9(p);\n        default: return 1e10;\n    }\n}\n","name":"Common","description":"","type":"common"}]}