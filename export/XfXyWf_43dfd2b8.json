{"ver":"0.1","info":{"id":"XfXyWf","date":"1721656252","viewed":61,"name":"fractal 1 - CableNest 1b","username":"Elsio","description":"https://www.shadertoy.com/view/DlffD4\nCable Nest é uma deformação de cabos. e a lógica da deformação eu estou revisitando aqui.\n\nA grande dificuldade está em ajustar  os valores de s e ss para que o plano seja dividido adequadamente \n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["tag"],"hasliked":0,"parentid":"4flcWB","parentname":"fractal 1 - CableNest 1a"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot(a) mat2(cos(a + vec4(0, 11, 33, 0)))\n#define normal(p) normalize(map(p)-vec3(map(p - e.xyy), map(p - e.yxy), map(p - e.yyx)))\n#define far 100.\n#define eps .01\n#define t iTime\n\nfloat blur = 0.;\n\nfloat slength(vec3 p){\n    float k = 8.;\n    p = pow(abs(p), vec3(k));\n    return pow(p.x + p.y + p.z, 1./k);;\n}\n\n\n\nvec3 cor;\n\nvec3[] cr = vec3[](\n    vec3(0),\n    vec3(1),\n    vec3(1, .6, 0),\n    vec3(0, .0, .1)\n);\n\n\nfloat cableNest(vec3 p, float d){\n    \n    float ss, s, dd;\n                 \n    // related\n    // https://www.shadertoy.com/view/DlffD4 mysterious rotation\n    // https://www.shadertoy.com/view/ctSfRV Corrente\n    \n    //p.xz *= rot(cos(t * 1.));    \n    p.xy *= rot(cos(t * 1.) * .1);    \n\n    //p.xz *= rot(1.9);\n    //p.xz *= rot(1.2);\n    \n    p.xz *= rot(mix(0.2, 2.9, cos(4. * t) * .5 + .5));\n    \n    ss = .95;\n    s  = 1. ;\n    \n    int i;\n    while(i++ < 4){\n        //p.xz *= ss * rot(cos(t*1.2) * 3.14 / 4.);\n        p.xz *= ss * rot(cos(t * 2.2) * (cos(t * 80.) * .01 + .42) + .785);\n        p.xz = abs(p.xz) - 3.5 * s;\n        \n        s /= ss;\n               \n        dd = s * (slength(p) - 1.);\n        \n        if(dd < d){\n            d = dd;\n            cor = cr[i];\n        }\n    }\n    \n    return d * .8;\n}\n\n\nfloat map(vec3 p){\n    float d = length(p) - .4;\n    cor = cr[0];\n    \n    return cableNest(p, d) * .8;\n}\n\nvoid mainImage(out vec4 o, vec2 u) {\n    vec2 r = iResolution.xy, e = vec2(eps, 0);\n    u = (u - r / 2.) / r.y;\n         \n    vec3 N, L,\n         p = vec3(0, 12, -22.), \n         D = normalize(vec3(u, 1));\n    \n    D.zy *= rot(.5);    \n    \n    o -= o;\n    float dif, i, d, s = eps;\n    while(i++ < 100. && s >= eps && d < far) \n        s = map(p),\n        p += s * D,\n        d += s;\n    \n    \n    if(d < far){\n        L = normalize(vec3(0, 5, -10)),\n        N = normal(p),\n        dif = max(dot(N, L), 0.),\n        cor *= (.48 * dif + .3) * 1.,\n        cor += .2 * pow(dif, 30.),\n        o.rgb = pow(cor, vec3(.45));\n        \n        o = mix(o, vec4(.5,0,0,0), blur);\n    }\n    \n    else\n        o += .25;\n        \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define iTime ( iTime + fract(1e4*sin(dot(gl_FragCoord.xy,vec2(137,-13))))* iTimeDelta )\n","name":"Common","description":"","type":"common"}]}