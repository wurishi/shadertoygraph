{"ver":"0.1","info":{"id":"wdjXWd","date":"1555579438","viewed":330,"name":"world_space_ao","username":"skaplun","description":"Experimenting on AO. Still not satisfied with result. \nOn the plus side - I have 60fps even with 512 samples per pixel on my MacBook Pro ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["voxel","ambientocclusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"uint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nvec3 hash3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 random_in_unit_sphere(inout float seed) {\n    vec3 h = hash3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 1./3.);\n\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\n\nbool nextVoxel(in Box box, in Ray cameraRay, out HitRecord rec){\n\tfor(int i=0; i<20; i++){\n        if(rect_inside_sphere(box)){\n            box_hit(box, cameraRay, rec);\n\t\t\treturn true;\n        }else{\n            box_hit(box, cameraRay, rec);\n            box.origin += rec.nrm[1] * VOXEL_SIZE;\n        }\n    }\n    return false;\n}\n\n//I know that that next func is quite ugly. Need to be refactored.\n#define YZ 0\n#define XZ 1\n#define XY 2\nfloat closestNeighbor(vec3 p, vec3 voxelCntr, vec3 norm){\n\tint plane = abs(norm.x) > 0.? 0: abs(norm.y) > 0. ? 1 : 2;\n    float minDist = MAX_FLOAT;\n    switch(plane){\n    \tcase XY:\n        {\n            Box neighbour = Box(voxelCntr + vec3(-VOXEL_SIZE, 0., 0.), VOXEL_SIZE * .5);\n            if(rect_inside_sphere(neighbour)){\n                minDist = min(minDist,\n                              distance(neighbour.origin.x + VOXEL_SIZE * .5, p.x));\n            }\n            neighbour = Box(voxelCntr + vec3(VOXEL_SIZE, 0., 0.), VOXEL_SIZE * .5);\n            if(rect_inside_sphere(neighbour)){\n                minDist = min(minDist,\n                              distance(neighbour.origin.x - VOXEL_SIZE * .5, p.x));\n            }\n            neighbour = Box(voxelCntr + vec3(0., -VOXEL_SIZE, 0.), VOXEL_SIZE * .5);\n            if(rect_inside_sphere(neighbour)){\n                minDist = min(minDist,\n                              distance(neighbour.origin.y + VOXEL_SIZE * .5, p.y));\n            }\n            neighbour = Box(voxelCntr + vec3(0., VOXEL_SIZE, 0.), VOXEL_SIZE * .5);\n            if(rect_inside_sphere(neighbour)){\n                minDist = min(minDist,\n                              distance(neighbour.origin.y - VOXEL_SIZE * .5, p.y));\n            }\n        \treturn minDist/(VOXEL_SIZE*.5);\n        }\n        case XZ:\n        {\n        \tBox neighbour = Box(voxelCntr + vec3(-VOXEL_SIZE, 0., 0.), VOXEL_SIZE * .5);\n            if(rect_inside_sphere(neighbour)){\n                minDist = min(minDist,\n                              distance(neighbour.origin.x + VOXEL_SIZE * .5, p.x));\n            }\n            neighbour = Box(voxelCntr + vec3(VOXEL_SIZE, 0., 0.), VOXEL_SIZE * .5);\n            if(rect_inside_sphere(neighbour)){\n                minDist = min(minDist,\n                              distance(neighbour.origin.x - VOXEL_SIZE * .5, p.x));\n            }\n        \tneighbour = Box(voxelCntr + vec3(0., 0., -VOXEL_SIZE), VOXEL_SIZE * .5);\n            if(rect_inside_sphere(neighbour)){\n                minDist = min(minDist,\n                              distance(neighbour.origin.z + VOXEL_SIZE * .5, p.z));\n            }\n            neighbour = Box(voxelCntr + vec3(0., 0., VOXEL_SIZE), VOXEL_SIZE * .5);\n            if(rect_inside_sphere(neighbour)){\n                minDist = min(minDist,\n                              distance(neighbour.origin.z - VOXEL_SIZE * .5, p.z));\n            }\n        \treturn minDist/(VOXEL_SIZE*.5);\n        }\n        case YZ:\n        {\n        \tBox neighbour = Box(voxelCntr + vec3(0., -VOXEL_SIZE, 0.), VOXEL_SIZE * .5);\n            if(rect_inside_sphere(neighbour)){\n                minDist = min(minDist,\n                              distance(neighbour.origin.y + VOXEL_SIZE * .5, p.y));\n            }\n            neighbour = Box(voxelCntr + vec3(0., VOXEL_SIZE, 0.), VOXEL_SIZE * .5);\n            if(rect_inside_sphere(neighbour)){\n                minDist = min(minDist,\n                              distance(neighbour.origin.y - VOXEL_SIZE * .5, p.y));\n            }\n            neighbour = Box(voxelCntr + vec3(0., 0., -VOXEL_SIZE), VOXEL_SIZE * .5);\n            if(rect_inside_sphere(neighbour)){\n                minDist = min(minDist,\n                              distance(neighbour.origin.z + VOXEL_SIZE * .5, p.z));\n            }\n            neighbour = Box(voxelCntr + vec3(0., 0., VOXEL_SIZE), VOXEL_SIZE * .5);\n            if(rect_inside_sphere(neighbour)){\n                minDist = min(minDist,\n                              distance(neighbour.origin.z - VOXEL_SIZE * .5, p.z));\n            }\n            return minDist/(VOXEL_SIZE*.5);\n        }\n        default:\n        \treturn 1.;\n    }\n}\n\nfloat ao(vec3 p, vec3 n, vec3 on) {\n    vec3 originalVoxelCenter;\n    {\n    \tvec3 s = p + n * .00001;\n    \toriginalVoxelCenter = s - mod(s, VOXEL_SIZE) + (VOXEL_SIZE * .5);\n    }\n    float samplingDist = VOXEL_SIZE;\n    vec3 samplePoint, curVoxelCenter;\n    for (int i=0; i<4; i++){\n    \tsamplePoint = p + samplingDist * n;\n        curVoxelCenter = samplePoint - mod(samplePoint, VOXEL_SIZE) + (VOXEL_SIZE * .5);\n    \tif(curVoxelCenter == originalVoxelCenter)\n            break;\n        samplingDist *= .5;\n    }\n    if(originalVoxelCenter != curVoxelCenter){\n    \tsamplePoint = p + samplingDist * on;\n        //return step(.25, closestNeighbor(samplePoint, originalVoxelCenter, on));\n    }\n    return clamp(0., 1., closestNeighbor(samplePoint, originalVoxelCenter, on));\n}\n\nconst vec3[5] colors = vec3[5](\n    vec3(23., 63., 95.)/255.,\n    vec3(32., 99., 155.)/255.,\n    vec3(60., 174., 163.)/255.,\n    vec3(246., 213., 92.)/255.,\n    vec3(273., 85., 59.)/255.);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    VOXEL_SIZE = .25;\n    vec2 p = (2. * fragCoord - iResolution.xy)/iResolution.y;\n    Ray cameraRay = getCameraRay(p, (iResolution.x - iMouse.x) * .01);\n    vec4 color = vec4(.0474);\n    \n    float dist;\n    HitRecord rec;\n    if(sphere_intersect(cameraRay, Sphere(SCENE_CENTER, OUTER_SPHERE_RAD), rec)){\n        vec3 voxelCntr = rec.ptnt[0] - mod(rec.ptnt[0], VOXEL_SIZE) + (VOXEL_SIZE * .5);\n        Box outerBox = Box(voxelCntr, VOXEL_SIZE * .5);\n        if(nextVoxel(outerBox, cameraRay, rec)){\n        \tvec3 p = rec.ptnt[0];\n            vec3 norm = rec.nrm[0];\n\t\t\t\n            float ao_val = 0.0;\n            for (int i = 0; i < 512; ++i) {\n                float g_seed = (p.x * .1) + (p.y * .01) + (p.z * .001) * float(i + 1);\n                vec3 n = normalize(norm + random_in_unit_sphere(g_seed));\n                ao_val += ao(p, n, norm);\n            }\n\t\t\t//vec3 c = mix(colors[3], colors[4], smoothstep(-.75, .75, p.x));\n            //color = vec4(c * (ao_val/512.), 1.0);\n            color = vec4(vec3(ao_val/512.), 1.0);\n        }\n    }\n    fragColor = pow(color,vec4(1./2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define OUTER_SPHERE_RAD 1.\n#define CAMERA_RAD (OUTER_SPHERE_RAD * 2.)\n#define SCENE_CENTER vec3(0.)\n#define MAX_FLOAT 1e5\n\nfloat VOXEL_SIZE = .05;\n    \nstruct Ray{\n    vec3 origin, direction, axisSign, invdir;\n};\n    \nstruct Sphere{\n\tvec3 origin;\n    float rad;\n};\n\nstruct Box{ vec3 origin; float size; };\n    \nstruct HitRecord{\n\tvec2 dist;\n\tvec3 ptnt[2];\n    vec3 nrm[2];\n};\n\nRay getCameraRay(in vec2 p, float ang){\n    vec3 cameraPos = vec3(CAMERA_RAD * sin(ang), 1., CAMERA_RAD * cos(ang));\n    vec3 fo = normalize(SCENE_CENTER - cameraPos);\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n    float fov = .5;\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\n\n    return Ray(cameraPos, rayDir, sign(rayDir), 1./rayDir);\n}\n\nvec3 hash(vec3 p){\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise(in vec3 p){\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nfloat remappedNoise(in vec3 p){\n\treturn .3 + .2 * noise(p)/.6;\n}\n\nbool solveQuadratic(const in float a, const in float b, const in float c, out float x0, out float x1) { \n    float discr = b * b - 4. * a * c; \n    if (discr < 0.) return false; \n    else if (discr == 0.)\n        x0 = x1 = - .5 * b / a;\n    else { \n        float q = (b > 0.) ? \n            -.5 * (b + sqrt(discr)) : \n            -.5 * (b - sqrt(discr)); \n        x0 = q / a; \n        x1 = c / q; \n    } \n \n    return true; \n}    \n\nbool sphere_intersect(const in Ray ray, const in Sphere sphere, out HitRecord hr){ \n    vec3 L = ray.origin - sphere.origin;\n    float a = dot(ray.direction, ray.direction); \n    float b = 2. * dot(ray.direction, L);\n    float c = dot(L, L) - sphere.rad*sphere.rad;\n    if (!solveQuadratic(a, b, c, hr.dist.x, hr.dist.y)) return false; \n\n    if(hr.dist.x > hr.dist.y)\n        hr.dist = hr.dist.yx;\n    \n    bool res = hr.dist.x > 0. && hr.dist.y > 0.;\n    if(res){\n    \thr.ptnt = vec3[2](ray.origin + ray.direction * hr.dist.x,\n                          ray.origin + ray.direction * hr.dist.y);\n        hr.nrm = vec3[2](normalize(hr.ptnt[0] - sphere.origin),\n                         normalize(hr.ptnt[1] - sphere.origin));\n    }\n    return res;\n}\n\nvec3 box_normal_at(const in Box box, const in vec3 point) {\n    vec3 normal;\n    vec3 localPoint = point - box.origin;\n    float mindist = MAX_FLOAT;\n    float dist = abs(box.size - abs(localPoint.x));\n    if (dist < mindist) {\n        mindist = dist;\n        normal = vec3(1., 0., 0.);\n        normal *= sign(localPoint.x);\n    }\n    \n    dist = abs(box.size - abs(localPoint.y));\n    if (dist < mindist) {\n        mindist = dist;\n        normal = vec3(0, 1., 0);\n        normal *= sign(localPoint.y);\n    }\n    dist = abs(box.size - abs(localPoint.z));\n    if (dist < mindist) { \n        mindist = dist; \n        normal = vec3(0, 0, 1.);\n        normal *= sign(localPoint.z);\n    } \n    return normal;\n}\n\n#define MIN x\n#define MAX y\nbool box_hit(const in Box inbox, const in Ray inray, inout HitRecord rec){\n    vec2 tx, ty, tz;\n    vec3 maxbounds = inbox.origin + vec3(inbox.size);\n    vec3 minbounds = inbox.origin + vec3(-inbox.size);\n    tx = ((inray.direction.x >= 0.?vec2(minbounds.x, maxbounds.x):vec2(maxbounds.x, minbounds.x)) - inray.origin.x) / inray.direction.x;\n\tty = ((inray.direction.y >= 0.?vec2(minbounds.y, maxbounds.y):vec2(maxbounds.y, minbounds.y)) - inray.origin.y) / inray.direction.y;\n    if ((tx.MIN > ty.MAX) || (ty.MIN > tx.MAX))\n        return false;\n    tx = vec2(max(tx.MIN, ty.MIN), min(tx.MAX, ty.MAX));\n\ttz = ((inray.direction.z >= 0.?vec2(minbounds.z, maxbounds.z):vec2(maxbounds.z, minbounds.z)) - inray.origin.z) / inray.direction.z;\n    if ((tx.MIN > tz.MAX) || (tz.MIN > tx.MAX))\n        return false;\n    tx = vec2(max(tx.MIN, tz.MIN), min(tx.MAX, tz.MAX));\n    \n    if(tx.MIN >= 0.){\n    \trec.dist.x = tx.MIN;\n        rec.ptnt[0] = inray.origin + inray.direction * rec.dist.x;\n        rec.nrm[0] = box_normal_at(inbox, rec.ptnt[0]);\n        \n        rec.dist.y = tx.MAX;\n        rec.ptnt[1] = inray.origin + inray.direction * rec.dist.y;\n        rec.nrm[1] = box_normal_at(inbox, rec.ptnt[1]);\n        \n        return true;\n    }\n        \n    return false;\n}\n\nbool rect_inside_sphere(Box box){\n\tfloat diag = sqrt(pow(box.size, 2.) + sqrt(pow(box.size, 2.) * 2.));\n    return length(box.origin)  + diag * .5 <= OUTER_SPHERE_RAD;\n}","name":"Common","description":"","type":"common"}]}