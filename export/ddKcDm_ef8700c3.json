{"ver":"0.1","info":{"id":"ddKcDm","date":"1698594661","viewed":47,"name":"ProjetInfGraph p2004255/p1707625","username":"p2005244","description":"Projet Informatique graphique Synthèse","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["image"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//PRIMITIVES\nstruct Sphere{\n    vec3 c;// Center\n    float r;// Radius\n    int i;// Texture Id\n};\n\nstruct Plane{\n    vec3 n;// Normal\n    vec3 p;// Point\n    int i;// Texture Id\n};\n\nstruct Ellipsoid {\n    vec3 c; // Center\n    vec3 r; // Semi-axes lengths (x, y, z)\n    int i; // Texture Id\n};\n\nstruct Torus {\n    vec3 c; // Center\n    float R; // Grand rayon\n    float r; // Petit rayon\n    int i;   // Texture Id\n};\n\nstruct Cylinder {\n    vec3 c; // Center\n    vec3 top; // Top\n    float r;  // Radius\n    int i;// Texture Id\n};\n\nstruct Capsule {\n    vec3 c; // Center\n    vec3 top; // Top\n    float r;  // Radius\n    int i;// Texture Id\n};\n\nstruct Disk {\n    vec3 c; // Center\n    vec3 n; // Normal\n    float r;  // Radius\n    int i;// Texture Id\n};\n\nstruct Box {\n    vec3 min; // Coin inférieur de la boîte\n    vec3 max; // Coin supérieur de la boîte\n    int i;    // Texture Id\n};\n\nstruct Hit{\n    float t;// Intersection depth\n    vec3 n;// Normal\n    int i;// Texture Id\n};\n\nstruct Ray{\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\nstruct Material{\n    vec3 d;// Diffuse\n    vec3 a;//Ambient\n    vec3 s;//Speculaire\n    vec3 r;//reflectivity\n};\n\nfloat Checkers(in vec2 p){\n    // Filter kernel\n    vec2 w = fwidth(p)+.001;\n    // Box box filter\n    vec2 i=2.*(abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;\n    // xor pattern\n    return.5-.5*i.x*i.y;\n}\n\n// Compute point on ray\nvec3 Point(Ray ray,float t){\n    return ray.o+t*ray.d;\n}\n\n\n//TEXTURES\n// Fonction pour la texture uniforme\nvec3 TextureUniforme(vec3 couleur){\n    return couleur;\n}\n\nint Damier(float x, float y, float z, float tailleCote){\n    x /= tailleCote;\n    y /= tailleCote;\n    z /= tailleCote;\n    \n    return (int(x) + int(y) + int(z)) % 2;\n}\n\nfloat Axial ( float x , float y , float z ) {\n    float r = sqrt ( x * x + y *y );\n    return 0.5 + 0.5 * cos (3.1415927 * r ) ;\n}\n\nMaterial Texture(vec3 p, int i){\n\n    // Texture rouge pour l'index 1\n    if (i == 1)\n    {\n        return Material(TextureUniforme(vec3(1., 0., 0.)), vec3(1., 0., 0.), vec3(1., 1., 1.), vec3(1.5, .0, 0.0)); // Texture rouge pour l'index 1\n    }\n    else if (i == 0) // Texture de damier pour l'index 0\n    {\n        // compute checkboard\n        float f = Checkers(.5 * p.xy);\n        vec3 col = vec3(.4, .5, .7) + f * vec3(.1);\n        return Material(col, vec3(.2, .2, .2), vec3(1., 1., 1.), vec3(0.0)); // Texture de damier pour l'index 0\n    }\n    else if (i == 2) {\n        int checker = Damier(p.x, p.y, p.z, 0.25);\n        vec3 col = vec3(1.0); // Couleur blanche pour le damier\n        col *= float(checker); // Multiplier par 0 ou 1 en fonction de la valeur du damier\n        return Material(col,vec3(.2, .2, .2), vec3(.5, .5, .5), vec3(0));\n    }\n    else if (i == 3) {\n  \n        float distanceAxiale = Axial(p.x, p.y, p.z);\n        float stripes = step(0.7, mod(distanceAxiale * 7.0, 1.25));\n        vec3 concentricColor = vec3(stripes);\n\n        return Material(concentricColor, vec3(0.), vec3(0.2), vec3(.0));\n    }\n    else if (i == 4) //texture damier alternant des cases diffuses et spéculaires\n    {\n        float checkerValue = Checkers(p.xy / 0.1);\n        if(checkerValue > 0.5) {\n            return Material(vec3(1.0, 1.0, 1.0), vec3(0.2, 0.2, 0.2), vec3(0.0, 0.0, .0), vec3(0.0, 0.0, 0.0)); // Diffuse\n        } else {\n            return Material(vec3(0.0, 0.0, .0), vec3(0.2, 0.2, 0.2), vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0)); // Spéculaire\n        }\n    }\n    return Material(vec3(0), vec3(0), vec3(0), vec3(0.));\n}\n\n//INTERSECTIONS\n\n// Sphere intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectSphere(Ray ray,Sphere sph,out Hit x){\n    vec3 oc=ray.o-sph.c;\n    float b=dot(oc,ray.d);\n    float c=dot(oc,oc)-sph.r*sph.r;\n    float d=b*b-c;\n    if(d>0.)\n    {\n        float t=-b-sqrt(d);\n        if(t>0.)\n        {\n            vec3 p=Point(ray,t);\n            x=Hit(t,normalize(p-sph.c),sph.i);\n            \n            return true;\n        }\n    }\n    return false;\n    \n}\n\nbool IntersectEllipsoid(Ray ray, Ellipsoid ell, out Hit x, mat3 trans){\n    vec3 oc = (ray.o - ell.c) ;\n    vec3 oc_scaled = vec3(oc.x / ell.r.x, oc.y / ell.r.y, oc.z / ell.r.z)  ;\n    vec3 dir_scaled = vec3(ray.d.x / ell.r.x, ray.d.y / ell.r.y, ray.d.z / ell.r.z) ;\n\n    float a = dot(dir_scaled, dir_scaled) ; \n    float b = 2.0 * dot(oc_scaled, dir_scaled);\n    float c = dot(oc_scaled, oc_scaled) - ell.r.y;\n\n    float discriminant = b * b - 4.0 * a * c;\n\n    if (discriminant > 0.0)\n    {\n        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n\n        float t = min(t1, t2); \n\n        if (t > 0.0)\n        {\n            vec3 p = Point(ray, t);\n            vec3 normal = normalize(p-ell.c) ;\n\n            x = Hit(t, normal, ell.i);\n            return true;\n        }\n    }\n\n    return false;\n}\n\nbool IntersectDisk(Ray ray,Disk d ,out Hit x){\n    float t=-dot(ray.o-d.c,d.n)/dot(ray.d,d.n);\n    if(t>0.)\n    {\n        vec3 p=Point(ray,t);\n        if(distance(p, d.c) <= d.r){\n            x=Hit(t,d.n,d.i);\n            return true;\n        }\n        return false;\n    }\n    return false;\n}\n\nbool intersectCylinder(Ray ray, Cylinder cylinder, out Hit hit){\n    \n    vec3 oc = ray.o - cylinder.c;\n    vec2 dxy = ray.d.xy;\n\n    float a=ray.d.x*ray.d.x+ray.d.y*ray.d.y;\n    float b=2.*(oc.x*ray.d.x+oc.y*ray.d.y);\n    float c=oc.x*oc.x+oc.y*oc.y-cylinder.r*cylinder.r;\n    \n    float discriminant = b * b - 4.0 * a * c;\n\n    if (discriminant > 0.0) {\n\n        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n        \n        float t = min(t1,t2);\n        \n        float x = ray.o.x + t * ray.d.x;\n\n        if(t>0.)\n        {\n            vec3 p=Point(ray,t);\n            if(p.z>cylinder.c.z && p.z<cylinder.top.z) {\n\n                vec3 u=cylinder.top-cylinder.c;\n                vec3 q=cylinder.c+(dot(u,p-cylinder.c)/dot(u,u))*u;\n                vec3 n=normalize(p-q);\n\n                hit.t = t;\n                hit.n = n;\n                hit.i = cylinder.i;\n\n                return true;\n            }\n        }\n        if (ray.d.z > 0.0) {\n\n            Disk disk = Disk(cylinder.c, vec3(0., 0., -1), cylinder.r, cylinder.i);\n\n            if(IntersectDisk(ray, disk, hit)){\n                return true;\n            }\n        }\n        else {\n\n            Disk disk = Disk(cylinder.top, vec3(0., 0., 1), cylinder.r, cylinder.i);\n\n            if(IntersectDisk(ray, disk, hit)){\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool intersectCapsule(Ray ray, Capsule caps, out Hit hit){\n    \n    Cylinder cyl = Cylinder(caps.c, caps.top, caps.r ,caps.i);\n    Sphere sph1 = Sphere(caps.c,caps.r, caps.i); \n    Sphere sph2 = Sphere(caps.top,caps.r, caps.i);\n    \n    hit=Hit(1000.,vec3(0),-1);\n    Hit current;\n    bool ret=false;\n    \n    if(intersectCylinder(ray,cyl,current)&&current.t<hit.t){\n        hit=current;\n        ret=true;\n    }\n\n    if(IntersectSphere(ray,sph1,current)&&current.t<hit.t){\n        hit=current;\n        ret=true;\n    }\n    \n    if(IntersectSphere(ray,sph2,current)&&current.t<hit.t){\n        hit=current;\n        ret=true;\n    }\n    \n    return ret;\n\n}\n\n// Fonction pour calculer l'intersection entre un rayon et un tore\nbool IntersectTorus(Ray ray, Torus torus, out Hit hit){\n    // Paramètres du tore\n    float Ra2 = torus.R * torus.R;\n    float ra2 = torus.r * torus.r;\n\n    vec3 oc = ray.o;\n    vec3 dir = ray.d;\n\n    float m = dot(oc, oc);\n    float n = dot(oc, dir);\n    \n    {\n        float h = n * n - m + (torus.R + torus.r) * (torus.R + torus.r);\n        if (h < 0.0)\n            return false;\n    }\n\n    float k = (m - ra2 - Ra2) / 2.0;\n    float k3 = n;\n    float k2 = n * n + Ra2 * dir.z * dir.z + k;\n    float k1 = k * n + Ra2 * oc.z * dir.z;\n    float k0 = k * k + Ra2 * oc.z * oc.z - Ra2 * ra2;\n\n    float po = 1.0;\n\n    if (abs(k3 * (k3 * k3 - k2) + k1) < 0.01)\n    {\n        po = -1.0;\n        float tmp = k1;\n        k1 = k3;\n        k3 = tmp;\n        k0 = 1.0 / k0;\n        k1 = k1 * k0;\n        k2 = k2 * k0;\n        k3 = k3 * k0;\n    }\n\n    float c2 = 2.0 * k2 - 3.0 * k3 * k3;\n    float c1 = k3 * (k3 * k3 - k2) + k1;\n    float c0 = k3 * (k3 * (-3.0 * k3 * k3 + 4.0 * k2) - 8.0 * k1) + 4.0 * k0;\n\n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n\n    float Q = c2 * c2 + c0;\n    float R = 3.0 * c0 * c2 - c2 * c2 * c2 - c1 * c1;\n\n    float h = R * R - Q * Q * Q;\n    float z = 0.0;\n    if (h < 0.0)\n    {\n        float sQ = sqrt(Q);\n        z = 2.0 * sQ * cos(acos(R / (sQ * Q)) / 3.0);\n    }\n    else\n    {\n        float sQ = pow(sqrt(h) + abs(R), 1.0 / 3.0);\n        z = sign(R) * abs(sQ + Q / sQ);\n    }\n    z = c2 - z;\n\n    float d1 = z - 3.0 * c2;\n    float d2 = z * z - 3.0 * c0;\n    if (abs(d1) < 1.0e-4)\n    {\n        if (d2 < 0.0)\n            return false;\n        d2 = sqrt(d2);\n    }\n    else\n    {\n        if (d1 < 0.0)\n            return false;\n        d1 = sqrt(d1 / 2.0);\n        d2 = c1 / d1;\n    }\n\n    float result = 1e20;\n\n    h = d1 * d1 - z + d2;\n    if (h > 0.0)\n    {\n        h = sqrt(h);\n        float t1 = -d1 - h - k3;\n        t1 = (po < 0.0) ? 2.0 / t1 : t1;\n        float t2 = -d1 + h - k3;\n        t2 = (po < 0.0) ? 2.0 / t2 : t2;\n        if (t1 > 0.0)\n            result = t1;\n        if (t2 > 0.0)\n            result = min(result, t2);\n    }\n\n    h = d1 * d1 - z - d2;\n    if (h > 0.0)\n    {\n        h = sqrt(h);\n        float t1 = d1 - h - k3;\n        t1 = (po < 0.0) ? 2.0 / t1 : t1;\n        float t2 = d1 + h - k3;\n        t2 = (po < 0.0) ? 2.0 / t2 : t2;\n        if (t1 > 0.0)\n            result = min(result, t1);\n        if (t2 > 0.0)\n            result = min(result, t2);\n    }\n\n    if (result < 0.0)\n        return false;\n\n    hit.t = result;\n    vec3 pos = ray.o + result * ray.d;\n    hit.n = normalize(pos * (dot(pos, pos) - torus.r * torus.r - torus.R * torus.R * vec3(1.0, 1.0, -1.0)));\n    hit.i = torus.i; // texture ID\n    return true;\n}\n\n\nbool IntersectBox(Ray ray, Box box, out Hit hit) {\n    vec3 tMin = (box.min - ray.o) / ray.d;\n    vec3 tMax = (box.max - ray.o) / ray.d;\n\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n\n    if (tNear > tFar || tFar < 0.0) {\n        hit = Hit(0.0, vec3(0.0), -1);\n        return false;\n    }\n\n    vec3 pNear = Point(ray, tNear);\n    vec3 pFar = Point(ray, tFar);\n\n    vec3 normal;\n\n    if (tNear > 0.0) {\n        vec3 p = Point(ray, tNear);\n        vec3 normal = normalize(p - (box.min + box.max) * 0.5);\n\n        hit = Hit(tNear, normal, box.i);\n        return true;\n    } else {\n        hit = Hit(0.0, vec3(0.0), -1);\n        return false;\n    }\n}\n\n// Plane intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectPlane(Ray ray,Plane pl,out Hit x){\n    float t=-dot(ray.o-pl.p,pl.n)/dot(ray.d,pl.n);\n    if(t>0.)\n    {\n        \n        x=Hit(t,vec3(0,0,1),pl.i);\n        return true;\n    }\n    return false;\n}\n\n//TRANSFORMATIONS\n\nSphere translation( Sphere sph, vec3 vec)\n{\n    Sphere ret = Sphere(sph.c+vec, sph.r, sph.i);\n    \n    return  ret;\n}\n\nEllipsoid translation( Ellipsoid ell, vec3 vec)\n{\n    Ellipsoid ret = Ellipsoid(ell.c+vec, ell.r ,ell.i);\n    \n    return  ret;\n}\n\nCylinder translation( Cylinder cyl, vec3 vec)\n{\n    Cylinder ret = Cylinder(cyl.c+vec, cyl.top+vec, cyl.r, cyl.i);\n    \n    return  ret;\n}\n\nCapsule translation( Capsule caps, vec3 vec)\n{\n    Capsule ret = Capsule(caps.c+vec, caps.top+vec, caps.r, caps.i);\n    \n    return  ret;\n}\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 identity(){\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\n// Scene intersection\n// ray : The ray\n//   x : Returned intersection information\nbool Intersect(Ray ray,out Hit x){\n    const Sphere sph1=Sphere(vec3(-4.,2.,4.),1.,0);\n    const Plane pl=Plane(vec3(0.,0.,1.),vec3(0.,0.,0.),0);\n    const Ellipsoid ell = Ellipsoid(vec3(4, 1.5, 1.5), vec3(1.5, 1.0, 0.8), 1);\n    const Cylinder cylinder = Cylinder(vec3(-2.0, 0.0, 3.5), vec3(-2.0, 0.0, 5.), 1.0  ,2);\n    const Capsule caps = Capsule(vec3(.0, -2.5, 2), vec3(.0, -2.5, 3.5), 1.0 , 1);\n    const Box box = Box(vec3(4.0, 1.5, 4.5), vec3(2.0, 0.5, 2.5), 0);\n    const Torus torus = Torus(vec3(2.0, 1.0, 2.0), 2.0, 0.7, 1);\n\n    x=Hit(1000.,vec3(0),-1);\n    Hit current;\n    bool ret=false;\n    \n   if(IntersectSphere(ray,sph1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n     /*if(IntersectSphere(ray,sph2,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    if(IntersectSphere(ray,trans,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }*/\n    \n    if (IntersectEllipsoid(ray, ell, current, rotateY(iTime)) && current.t < x.t)\n    {\n        x = current;\n        ret = true;\n    }\n\n\n    if(intersectCylinder(ray,cylinder,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n\n    \n    if (IntersectTorus(ray, torus, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    \n    if(intersectCapsule(ray,caps,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    if (IntersectBox(ray, box, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n\n    if(IntersectPlane(ray,pl,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n\n\n    \n    return ret;\n}\n\nvec3 Background(vec3 rd){\n    return mix(vec3(.8,.8,.9),vec3(.7,.7,.8),rd.z);\n}\n\n// Camera rotation matrix\n// ro : Camera origin\n// ta : Target point\nmat3 setCamera(in vec3 ro,in vec3 ta){\n    vec3 cw=normalize(ta-ro);\n    vec3 cp=vec3(0,0,1);\n    vec3 cu=-normalize(cross(cw,cp));\n    vec3 cv=-normalize(cross(cu,cw));\n    return mat3(cu,cv,cw);\n}\n\n// Apply color model\n// m : Material\n// n : normal\nvec3 Color(Material m,vec3 n, vec3 p, vec3 dir){\n    vec3 ambient = m.a;\n    vec3 diffuse = m.d;\n    vec3 specular = m.s;\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n    Hit temp;\n\n    vec3 norm = normalize(n);\n\n    if(!Intersect(Ray(p + norm * 0.01, lightDir), temp)) {\n\n        float diff = clamp(dot(norm, lightDir), 0., 1.);\n        vec3 reflectDir = -lightDir - 2.0 * dot(-lightDir, norm) * norm;\n        float spec = max(dot(reflectDir, dir), 0.0);\n\n\n        vec3 ambientColor = ambient;\n        vec3 diffuseColor = diff * diffuse;\n        vec3 specularColor = spec * specular;\n\n        return ambientColor + diffuseColor + specularColor;\n\n    } else {\n\n        return vec3(.2, .2, .2);\n\n    }\n\n}\n\n\n// Hemisphere direction\nvec3 Hemisphere(int seed,vec3 n){\n    float a=fract(sin(176.19*float(seed)));// Uniform randoms\n    float b=fract(sin(164.19*float(seed)));\n\n    float u=2.*3.1415*a;// Random angle\n    float v=acos(2.*b-1.);// Arcosine distribution to compensate for poles\n\n    vec3 d=vec3(cos(u)*cos(v),sin(u)*cos(v),sin(v));// Direction\n    if(dot(d,n)<0.){d=-d;}// Hemishpere\n\n    return d;\n}\n\n// Ambient occlusion\n// p : Point\n// n : Normal\n// N : Number of samples\nfloat AmbientOcclusion(vec3 p,vec3 n,int N){\n    if(N == 0) {\n        return 1.0;\n    }\n\n    float ao = 0.0;\n\n    for(int i = 0; i < N; i++) {\n        vec3 d = Hemisphere(i, n);\n\n        Ray shadowRay;\n        shadowRay.o = p + 0.01 * n;\n        shadowRay.d = d;\n        \n        Hit hit;\n        bool idx = Intersect(shadowRay, hit);\n\n        if(idx && hit.t < 1000.) {\n            ao += 1.0;\n        }\n    }\n\n    ao = 1.0 - ao / float(N);\n\n    return ao;\n}\n\n// Rendering\n// Rendering\nvec3 Shade(Ray ray){\n\n    vec3 color = vec3(0.0);\n\n    int maxi = 5;\n    for(int i = 0; i <= maxi; i++) {\n        \n        Hit x;\n        bool idx = Intersect(ray, x);\n\n        if(idx) {\n\n            vec3 p = Point(ray, x.t);\n            Material m = Texture(p, x.i);\n\n            vec3 baseColor = Color(m, x.n, p, normalize(ray.o - p));\n\n            float ambientOcclusion = AmbientOcclusion(p, x.n, 10);\n\n            baseColor *= ambientOcclusion;\n\n            if(i < maxi && m.r.xyz != vec3(0.0)) {\n                vec3 reflectDir = normalize(ray.d - 2.0 * dot(ray.d, normalize(x.n)) * normalize(x.n));\n\n                ray.o = p + 0.01 * reflectDir; \n                ray.d = reflectDir;\n\n                color += baseColor * m.r;\n            } else {\n                color += baseColor;\n                break;\n            }\n        }\n        else{\n            color += Background(ray.d);\n            break;\n        }\n    }\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\n    // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n    vec2 uv = (-iResolution.xy+2.*fragCoord.xy)/iResolution.y;\n    \n    // Mouse control\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    \n    // Ray origin\n    vec3 ro=12.*normalize(vec3(sin(2.*3.14*mouse.x),cos(2.*3.14*mouse.x),1.4*(mouse.y-.1)));\n    vec3 ta=vec3(0.,0.,1.5);\n    mat3 ca=setCamera(ro,ta);\n    \n    // Ray\n    vec3 rd=ca*normalize(vec3(uv.xy*tan(radians(22.5)),1.));\n    \n    // Render\n    vec3 col=Shade(Ray(ro,rd));\n    \n    fragColor=vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}