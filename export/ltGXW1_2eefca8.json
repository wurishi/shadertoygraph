{"ver":"0.1","info":{"id":"ltGXW1","date":"1484130264","viewed":202,"name":"CPT raytraced box shadow","username":"zproxy","description":"https://www.shadertoy.com/view/XtGXDh","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["shadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BMIN vec3(1.0)\n#define BMAX vec3(2.0,5.0,2.0)\n#define GROUND vec4(0.0,1.0,0.0,-1.0)\n\nbool collidePlane(vec3 P,vec3 V,vec4 plane, out float t) {    \n    float NPd=dot(plane.xyz,P)+plane.w;\n    float NV=dot(plane.xyz,V);\n    t=-NPd/NV;\n    return (NPd>0.0 && NV<0.0); //P not below/on or V not parallel/away\n}\n\nbool collideBox(vec3 P,vec3 V,vec3 bMin,vec3 bMax, out float t) {\n\t//from gamedev.net/topic/682750-problem-with-raybox-intersection-in-glsl/#entry5313405\n\t//from gamedev.net/resources/_/technical/math-and-physics/intersection-math-algorithms-learn-to-derive-r3033\n\t//from tavianator.com/fast-branchless-raybounding-box-intersections-part-2-nans\n\n\tvec3 invRay=1.0/V;\n\tvec3 tmin = (bMin - P) * invRay;\n\tvec3 tmax = (bMax - P) * invRay;\n\tvec3 tnear = min(tmin, tmax);\n\tvec3 tfar = max(tmin, tmax);\n\tfloat enter = max(tnear.x, max(tnear.y, tnear.z)); //max(tnear.x, 0.0)\n\tfloat exit = min(tfar.x, min(tfar.y, tfar.z));\n\tt=enter;\n\treturn exit > max(enter, 0.0); //exit>0.0 && enter<exit\n}\n\nvec3 boxNormal(vec3 bMin,vec3 bMax, vec3 colPt) {\n\t//checks the colPt against a plane for each face\n\t\n\tvec3 pMin=abs(colPt-bMin);\n\tvec3 pMax=abs(colPt-bMax);\n \n\tfloat eps=0.00001;\n\n  \tif(pMax.x<eps) {return vec3(1.0,0.0,0.0);} \n  \telse if(pMin.x<eps) {return vec3(-1.0,0.0,0.0);}\n  \telse if(pMax.y<eps) {return vec3(0.0,1.0,0.0);} \n  \telse if(pMin.y<eps) {return vec3(0.0,-1.0,0.0);}\n  \telse if(pMax.z<eps) {return vec3(0.0,0.0,1.0);} \n  \telse if(pMin.z<eps) {return vec3(0.0,0.0,-1.0);} \n  \telse {return vec3(0.0);}\n    \n    //alternative\n\t//vec3 n=vec3(0.0);\n\t//n-=vec3(pMin.x<eps?1.0:0.0,pMin.y<eps?1.0:0.0,pMin.z<eps?1.0:0.0);\n\t//n+=vec3(pMax.x<eps?1.0:0.0,pMax.y<eps?1.0:0.0,pMax.z<eps?1.0:0.0);\n\t//return normalize(n);\n\n}\n/*\nvec3 boxNormal(vec3 bMin,vec3 bMax, vec3 colPt) {\n\t//from blog.johnnovak.net/2016/10/22/the-nim-raytracer-project-part-4-calculating-box-normals\n\t//vec3 c = (bMin + bMax) * 0.5;\n\tvec3 p = colPt; //- c;\n\tvec3 d = (bMin - bMax) * 0.5;\n\tfloat bias = 1.0;//00001;\n\tvec3 q=p/abs(d)* bias;\n\t//q=floor(q);\n\treturn normalize(q);\n}*/\n\nvec3 calcPtLightCol(vec3 pos, vec3 nor, vec3 lightPos,vec3 lightAtten,\n\t\t\t\t\tvec3 lightCol,vec3 mtrlCol,float shininess,\n\t\t\t\t\tfloat strength) {\n\tvec3 lightDir=lightPos.xyz-pos;\n\tfloat lightDist=length(lightDir);\n\tlightDir=lightDir/lightDist;\n\n\t//\n\tfloat a = 1.0/(lightAtten.x+lightAtten.y*lightDist+lightAtten.z*lightDist*lightDist);\n\n\tvec3 reflectVec=reflect(-lightDir,nor);\n\tfloat NdotL = max(0.0,dot(nor,lightDir));\n\tfloat spec=0.0;\n\n\tif(NdotL > 0.0) {\n\t\tfloat NdotR = max(0.0, dot(nor, reflectVec));\n\t\tspec = pow(NdotR, shininess*128.0) * strength*a;\n\t}\n\n\tfloat diffuse=NdotL*a;\n\treturn lightCol*(mtrlCol*diffuse+spec);\n}\n\nfloat calcFlare(vec3 ro,vec3 rd,vec3 lightPos,float size) {\n\tvec3 viewLightDir=normalize(lightPos-ro);\n\tfloat viewLightDist=length(lightPos-ro);\n\tfloat q = dot(rd,viewLightDir)*0.5+0.5;\n\tfloat o = (1.0/viewLightDist)*size;\n\treturn clamp(pow(q,900.0/o)*1.0,0.0,2.0);\n}\n\nbool collideScene(vec3 ro,vec3 rd,out vec3 colPt, out vec3 nor) {\n\tfloat t=9999999.0,t2;\n\tbool hit=false;\n\n\tvec3 bMin=BMIN;\n\tvec3 bMax=BMAX;\n\tvec4 plane=GROUND;\n    \n\tif(collidePlane(ro,rd,plane,t2) && t2 < t) {\n\t\tt=t2;\n\t\tcolPt=ro+rd*t;\n\t\tnor=plane.xyz;\n\t\thit=true;\n\t} \n\t\n\tif(collideBox(ro,rd,bMin,bMax, t2) && t2 < t) {\n\t\tt=t2;\n\t\tcolPt=ro+rd*t;\n\t\tnor=boxNormal(bMin,bMax,colPt);\n\t\thit=true;\n\t}\n\t\n\treturn hit;\n}\n\nbool collideSceneP(vec3 ro,vec3 rd,out float t) {\n\tt=9999999.0;\n\tfloat t2;\n\tbool hit=false;\n\n\tvec3 bMin=BMIN;\n\tvec3 bMax=BMAX;\n\tvec4 plane=GROUND;\n\t\n\tif(collidePlane(ro,rd,plane,t2) && t2 < t) {\n\t\tt=t2;\n\t\thit=true;\n\t} \n\t\n\tif(collideBox(ro,rd,bMin,bMax, t2) && t2 < t) {\n\t\tt=t2;\n\t\thit=true;\n\t}\n\t\n\treturn hit;\n}\n\nvec3 checkerCol(vec3 texc, vec3 color0, vec3 color1) {\n    float q=clamp(mod(dot(floor(texc),vec3(1.0)),2.0),0.0,1.0);\n    return color1*q+color0*(1.0-q);\n}\n// https://www.shadertoy.com/view/XtGXDh\nvec3 render(vec3 ro, vec3 rd) {\n\tvec3 lightCol=vec3(2.0,1.9,0.8);\n\tvec3 lightAtten=vec3(0.6,0.01,0.001);\n\tvec3 lightPos=vec3(\n        cos(-iTime*0.6)*33.0 - 19.,\n        9.0 + sin(-iTime*0.6)*8.,\n        sin(-iTime*0.6)*33.0 - 19.\n    );\n\n\tvec3 col=vec3(0.0);\n\tvec3 pt,nor;\n\tbool hasHit=false;\n\t\n\tif(collideScene(ro,rd, pt,nor)) {\n\t\tvec3 matCol=checkerCol(pt*0.5,vec3(0.5),vec3(0.8));\n\t\tfloat tt,shd=1.0;\n        shd=(collideSceneP(lightPos,normalize(pt-lightPos),tt) && tt<length(pt-lightPos)-0.0001)?0.01:1.0;\n        vec3 light=calcPtLightCol(pt,nor,lightPos,lightAtten,lightCol,matCol,1.0,0.2);\n        vec3 amb=clamp(light,0.0,0.05)*matCol;\n\t\tcol+=light*shd+amb;\n\t\thasHit=true;\n\t}\n\n\n\tif(!hasHit || length(ro-lightPos)<length(ro-pt)) {\n\t\tcol=mix(col,lightCol*1.5,calcFlare(ro,rd,lightPos,0.15));\n\t}\n\t\n\treturn vec3(clamp(col,0.0,1.0));\n}\n\nvec3 calcPrimaryRay(vec2 screen,float fovy,float aspect) {\n\tfloat d=1.0/tan(fovy/2.0);\n\tvec3 v=vec3(screen.x*aspect,screen.y,-d);\n\tv=normalize(v);\n\treturn v;\n}\n\nmat3 orbitViewRot(float yaw,float pitch) {\n\tvec2 s=vec2(sin(pitch),sin(yaw));\n\tvec2 c=vec2(cos(pitch),cos(yaw));\n\treturn mat3(c.y,0.0,-s.y, s.y*s.x,c.x,c.y*s.x, s.y*c.x,-s.x,c.y*c.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat fovy=0.7854;\n\tfloat aspect=iResolution.x/iResolution.y;\n\tvec2 uv = fragCoord / iResolution.xy;\n\tvec2 scr = uv*2.0-1.0;\n\tvec2 ms = iMouse.xy / iResolution.xy;\n\tvec2 ms2=(ms.x==0.0 && ms.y==0.0)?vec2(0.5,0.5):ms;\n\n\tfloat pitch=(ms2.y-0.5)*5.0-0.7;\n\tfloat yaw=(ms2.x-0.5)*5.0;\n\n\tmat3 viewRot=orbitViewRot(yaw,pitch);\n\n\tvec3 ro=viewRot*vec3(0.0,2.0,25.0);\n\tvec3 rd=normalize(viewRot*calcPrimaryRay(scr,fovy,aspect));\n\n\tvec3 col=render(ro,rd);\n\n\tif(length((uv-ms)*vec2(aspect,1.0)) < 0.01) {\n\t\tcol=mix(col,vec3(1.0),0.2);\n\t}\n\n\tfragColor=vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}