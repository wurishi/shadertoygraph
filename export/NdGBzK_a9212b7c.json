{"ver":"0.1","info":{"id":"NdGBzK","date":"1658528500","viewed":165,"name":"Volumetric. Cube","username":"thepinkpanzer","description":"Transparent cube with volumetric color\nclick and drag to rotate\n","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["cube","transparent"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\n#define REFRACTIVEINDEX 1.6\n#define SPHERESCALE 2.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float theta = (iMouse.x - iResolution.x / 2.) / iResolution.y * PI;\n    float phi   = (iMouse.y - iResolution.y / 2.) / iResolution.y * PI;\n\n    // CAMERA\n    vec3 iCameraFwd     = vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi));\n    vec3 iCameraUp      = vec3(-sin(theta)*sin(phi),cos(phi),-cos(theta)*sin(phi));\n    vec3 iCameraRight   = normalize(cross(iCameraUp, iCameraFwd));\n    \n    vec3 iCameraPosition      = -5.*iCameraFwd;\n    \n    float m = 2.0;\n    \n    vec3 iViewDirection = iCameraFwd + ((fragCoord.x - iResolution.x/2.0) * iCameraRight + (fragCoord.y - iResolution.y/2.0) * iCameraUp) / iResolution.x * m;\n    iViewDirection      = normalize(iViewDirection);\n    \n    // SORTING FACES\n    float distXP =  (1.-iCameraPosition.x)/iViewDirection.x;\n    float distYP =  (1.-iCameraPosition.y)/iViewDirection.y;\n    float distZP =  (1.-iCameraPosition.z)/iViewDirection.z;\n    \n    float distXM = (-1.-iCameraPosition.x)/iViewDirection.x;\n    float distYM = (-1.-iCameraPosition.y)/iViewDirection.y;\n    float distZM = (-1.-iCameraPosition.z)/iViewDirection.z;\n    \n    vec3 faceList[6] = vec3[6]( vec3(1,0,0), vec3(0,1,0), vec3(0,0,1),\n                                vec3(-1,0,0),vec3(0,-1,0),vec3(0,0,-1));\n\n    float distList[6] = float[6]( distXP, distYP, distZP,\n                                  distXM, distYM, distZM);\n    \n    for (int n = 0; n < 5; n++)\n    {\n        for (int i = 0; i < 5; i++)\n        {\n            if (distList[i] > distList[i+1])\n            {\n                vec3 c        = faceList[i];\n                faceList[i]   = faceList[i+1];\n                faceList[i+1] = c;\n                \n                float r       = distList[i];\n                distList[i]   = distList[i+1];\n                distList[i+1] = r;\n            }\n        }\n    }\n    \n    vec3 position = iCameraPosition;\n    vec3 direction = iViewDirection;\n    \n    fragColor = vec4(1);\n    vec3 normal = vec3(0);\n    bool hitSphere = false;\n    \n    // IF IT HITS THE CUBE, DO STUFF\n    if (length(faceList[0]+faceList[1]+faceList[2]) >= sqrt(3.))\n    {\n        bool escaped = false;\n        while (!escaped)\n        {\n            position += direction * distList[2];\n            normal = faceList[2];\n\n            // SPECULAR REFLECTION OFF THE CUBE\n            float R0 = (1.-REFRACTIVEINDEX)/(1.+REFRACTIVEINDEX);\n            R0 *= R0;\n            float d = -dot(normal, direction);\n            fragColor += 1.4*Color(direction + 2.*normal*d)*(R0 + (1.-R0)*pow(abs(1.-d), 5.));\n\n            // REFRACTION ON THE SURFACE OF THE CUBE\n            vec3 flattened = normalize(direction - dot(normal, direction)*normal);\n            float snell = (1./REFRACTIVEINDEX)*(length(cross(direction, normal)));\n            direction = snell*flattened - sqrt(1.-snell*snell)*normal;\n\n            // RE-SORTING CUBE FACES FOR EXIT\n            float distXP =  (1.-position.x)/direction.x;\n            float distYP =  (1.-position.y)/direction.y;\n            float distZP =  (1.-position.z)/direction.z;\n\n            float distXM = (-1.-position.x)/direction.x;\n            float distYM = (-1.-position.y)/direction.y;\n            float distZM = (-1.-position.z)/direction.z;\n\n            vec3 faceList[6] = vec3[6]( vec3(1,0,0), vec3(0,1,0), vec3(0,0,1),\n                                       vec3(-1,0,0),vec3(0,-1,0),vec3(0,0,-1));\n\n            float distList[6] = float[6]( distXP, distYP, distZP,\n                                          distXM, distYM, distZM);\n\n            for (int n = 0; n < 5; n++)\n            {\n                for (int i = 0; i < 5; i++)\n                {\n                    if (distList[i] > distList[i+1])\n                    {\n                        vec3 c        = faceList[i];\n                        faceList[i]   = faceList[i+1];\n                        faceList[i+1] = c;\n\n                        float r       = distList[i];\n                        distList[i]   = distList[i+1];\n                        distList[i+1] = r;\n                    }\n                }\n            }\n\n            // RAYMARCHING THROUGH 3D TEXTURE\n            for (int n = 0; n < NJUMPS; n++)\n            {\n                vec3 newPos = position + direction * distList[3] * float(n + 1)/float(NJUMPS + 1);\n                fragColor *= exp(-texture(iChannel0, newPos*0.5 + 0.5) * distList[3] * 1./float(NJUMPS + 1) * OPACITY);\n            }\n\n            // REFRACTION AGAIN\n            position += direction * distList[3];\n            normal = faceList[3];\n            flattened = normalize(direction - dot(normal, direction)*normal);\n            snell = (REFRACTIVEINDEX)*(length(cross(direction, normal)));\n\n            // IF NO INTERNAL REFLECTION, THE RAY EXITS. ELSE, IT REFLECTS ONCE\n            if (snell < 1.)\n            {\n                direction = snell*flattened + sqrt(1.-snell*snell)*normal;\n                escaped = true;\n            }\n            else\n            {\n                // REFLECTION\n                direction -= 2.*normal*dot(normal, direction);\n            }\n        }\n    }\n    \n    // IF IT HASN'T HIT ANY <OPAQUE> SPHERES, WE PAINT ON THE RIGHT BACKGROUND COLOR\n    fragColor *= Color(direction);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define SPHERECOLOR vec4(1, 0.8, 0.2, 0)\n#define NJUMPS 256\n#define OPACITY 1.4\n\nvec4 Color(vec3 direction)\n{\n    return vec4(exp(2.*(dot(direction, normalize(vec3(0.2,0.2,1))) - 1.)));\n}\n\nvec4 SphereColor(vec3 direction, vec3 normal)\n{\n    return tanh(0.3*SPHERECOLOR*vec4(clamp(dot(normal, normalize(vec3(0.2,0.2,1))),0.,1.) + 2.*exp(4.*(dot(direction, normalize(vec3(0.2,0.2,1))) - 1.))));\n}\n\nfloat MinDistFromPoint(vec3 position, vec3 direction, vec3 point)\n{\n    return length(cross(direction, point-position));\n}","name":"Common","description":"","type":"common"}]}