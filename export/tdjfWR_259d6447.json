{"ver":"0.1","info":{"id":"tdjfWR","date":"1589859076","viewed":146,"name":"Displacement on sphere","username":"kp1197","description":"This is just me getting my toes wet again after not doing this for several years.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["basicbeginner"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MARCHES = 100;\nconst float EPS = 0.001;\nconst vec2 EPS_VEC = vec2(EPS,0.);\nconst vec3 LIGHT_DIR = vec3(-0.1,0.5,-0.5);\n\n\nfloat dot2(vec2 a, vec2 b) {\n\treturn (a.x * b.x + a.y * b.y);\n}\n\nfloat dot3(vec3 a, vec3 b) {\n\treturn (a.x * b.x) + (a.y * b.y) + (a.z * b.z);\n}\n\nvec3 sphereCenter(float time) {\n    return vec3(0.,cos(0.5*time),5.) + vec3(sin(time),0.,2.*cos(0.5*time));\n}\n\nfloat harmonics(float time) {\n\treturn floor(4.*mod(time,5.));\n}\n\nfloat time2(float p) {\n    return 0.8 * sin(p);\n}\n\nfloat time() {\n    return 0.5 * iTime + time2(iTime + time2(iTime+ time2(iTime)));\n}\n\n\n\nfloat displacement(vec3 pos, float t) {\n    vec3 SPHERE_CENTER = sphereCenter(t);\n    vec3 relPos = pos - SPHERE_CENTER;\n    float theta = atan(relPos.y, relPos.x);\n    float phi = atan(dot2(relPos.xy, relPos.xy), relPos.z);\n    \n    float harmonics_1 = harmonics(floor(t));\n    float harmonics_2 = harmonics(floor(t)+1.);\n    \n    float displacement1 = sin(harmonics_1*theta) * sin(harmonics_1*phi);\n    float displacement2 = sin(harmonics_2*theta) * sin(harmonics_2*phi);\n    \n    \n    float alpha = fract(t);\n    return mix(displacement1, displacement2, alpha);// smoothstep(displacement1, displacement2, fract(iTime));\n}\n\n\n\nfloat _dist(vec3 pos, float t) {\n    vec3 SPHERE_CENTER = sphereCenter(t);\n    vec3 relPos = pos - SPHERE_CENTER;\n    float disp1 = displacement(pos, t);\n\treturn length(relPos) - 0.5 + 0.2* (disp1);\n}\n\nfloat dist(vec3 pos) {\n\t//pos = mod(pos, 50.);\n    float t = time();\n    return _dist(pos, t);\n}\n\n\n\n\nvec3 normal(vec3 pos) {\n    \n    float dx = dist(pos + EPS_VEC.xyy) - dist(pos - EPS_VEC.xyy);\n    float dy = dist(pos + EPS_VEC.yxy) - dist(pos - EPS_VEC.yxy);\n    float dz = dist(pos + EPS_VEC.yyx) - dist(pos - EPS_VEC.yyx);\n    return normalize(vec3(dx,dy,dz));\n}\n\n\nvec3 shade(vec3 pos, vec3 dir, float t) {\n    //return vec3(length(normal(pos)));\n    //return length(normal(pos));\n\t//return vec3(dot3(normal(pos), LIGHT_DIR));\n    vec3 normal_vec = normal(pos);\n    float shade = dot3(normal_vec, LIGHT_DIR);\n    vec3 dir_to_sphere_center = normalize(pos - sphereCenter(t));\n    float mat_blend = dot3(normal_vec, dir_to_sphere_center);\n    return shade * vec3(sin(mat_blend)*cos(mat_blend), sin(mat_blend), cos(mat_blend));\n    //return vec3(shade, shade, 1.-fract(iTime));\n}\n\nvec3 march(vec3 pos, vec3 dir) {\n    float t = time();\n    float d = 0.;\n    float step_frac = .9;\n    int max_marches = MARCHES;\n    for(int i = 0; i < MARCHES; i++) {\n        d = dist(pos);\n        if (d < EPS) {\n            return shade(pos,dir,t);\n        }\n        step_frac = max(0.2,min(1.,d));\n    \tpos.xyz += dir * d * step_frac;\n    }\n    return vec3(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xx - vec2(0.5, 0.5*iResolution.y/iResolution.x);\n\t\n    vec3 pos = vec3(uv.xy, 1.0);\n    vec3 dir = normalize(pos);\n    \n    vec3 col = march(pos, dir);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}