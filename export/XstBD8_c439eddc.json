{"ver":"0.1","info":{"id":"XstBD8","date":"1524909504","viewed":144,"name":"Mandelbrot attachment positions","username":"akhgary","description":"this is the zoomed version of https://www.shadertoy.com/view/Ms3fD8\n\nI wanted to make sure that radius i calculated was correct. so i made a zoomed version of it. \n\nmodify \"zoom\" to your desired value.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["mandelbrot","line","circle","distance","complex","draw","pattern","generalized","modular","times","timestable","timestables"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ===========================================\n// mandelbrot set attachment positions\n//\n// coordinates of attachment positions of mandelbrot set \n// this only holds for N>=2 assuming N is integer\n//\n// there are always N-1 attachments from primary shape to secondary shapes.\n// for example there is 1 attachment from cardioid to the left circle when N=2.\n//\n// coordinates of this attachments can be calculated in this way. \n//\n// let \n//\t\tradian = -k*pi/(N-1);   k = 1,3,5,7 ...      \n//\t\tradius = (7+N)/(10+N);\n// then \n// \t\tx = radius*cos(radian)\n// \t\ty = radius*sin(radian)\n//\n// note that k always cycles through N. \n// that means k and mod(k, N) gives same coordinates.\n//\n// ============================================\n// all of this was achieved by experiment. i dont have mathematical proof.\n// ============================================\n\nconst float pi = 3.14159265359;\nconst float epsilon = 1e-5;\n\nconst float zoom = 4.0;\nconst float thickness = 3.0/zoom;\n\n// mandelbrot set properties\nconst int iterations = 100;\nconst float bailout = 100.0;\n\n// times table properties\nconst int modular = 200;\n\n// shared properties\nconst float minPower = 2.0; // minimum power of Z.\nconst float maxPower = 10.0; // maximum power of Z.\nconst float duration = 50.0; // transition cycle duration in seconds.\n\n\nvec2 uvmap(vec2 uv) {\n    return (2.0*uv-iResolution.xy)/iResolution.y;\n}\n\nvec3 pickColor(float n) {\n    return 0.6+0.6*cos(6.3*n+vec3(0,23,21));\n}\n\nfloat smoothout(float dist){\n    return smoothstep(thickness/iResolution.y,0.0,dist);\n}\n\nfloat smoothfloor(float x) {\n    return x - sin(2.0*pi*x)/(2.0*pi);\n}\n\nfloat clock(){\n    float rad = acos(cos(2.0*pi*iTime/duration));\n    return (maxPower-minPower)*rad/pi + minPower;\n}\n\nfloat circle(vec2 uv, vec2 C, float r, bool fill)\n{\n    vec2 p = uv-C;\n    float fx = length(p)-r;\n    float dist = fill? fx:abs(fx);\n    return smoothout(dist);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p - a, ba = b - a; \n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    float dist = length(pa - ba * h);\n    return smoothout(dist);\n}\n\nvec2 function(vec2 z, float n) {\n    float r = pow(dot(z, z), n/2.0);\n    float th = n*atan(z.y,z.x+epsilon);\n    return r*vec2(cos(th), sin(th));\n}\n\nvec2 dfunction(vec2 z, vec2 dz, float n){\n    // f(f(z))' = f'(f(z))*f'(z)\n\tvec2 df = n*function(z, n - 1.0);\n\treturn vec2(df.x*dz.x-df.y*dz.y, df.x*dz.y + df.y*dz.x) + vec2(1,0);\n}\n\nfloat mandelbrotDistance(float r, float dr) {\n    float dist = r*log(r)/dr;\n    return clamp(pow(dist,0.25),0.0,1.0);\n}\n\nvec3 mandelbrot(vec2 uv, float n) {\n    vec3 set = vec3(0);\n    vec2 c = uv;\n    vec2 z = c;\n    vec2 dz = vec2(1, 0);\n    \n    for(int i = 0; i < iterations && dot(z, z) <= bailout; i++) {\n\t    dz = dfunction(z,dz,n);\n\t    z = function(z,n) + c;\n    }\n    \n    float dist = mandelbrotDistance(length(z), length(dz));\n    \n    if(dot(z, z) > bailout) set = dist+pickColor(n/5.0)/2.0;\n    \n    return clamp(set*0.8,0.0,1.0);\n}\n\nvec3 timesTable(vec2 uv, float times)\n{\n    vec3 col = vec3(0);\n    float len = 2.0*pi/float(modular);\n    float r = (7.0+times)/(10.0+times); // radius of the circle\n    float phase = -pi/(times-1.0);\n    \n    col+=circle(uv,vec2(0),r,false);\n    \n    for(int i = 0; i < modular; i++) {\n        float n = float(i);\n        \n        vec2 c = vec2(cos(n*len+phase),sin(n*len+phase))*r;\n        vec2 p = vec2(cos(n*len*times+phase),sin(n*len*times+phase))*r;\n        \n        col+= circle(uv,c,0.005,true);\n        col+= line(uv,c,p)*pickColor(n/float(modular)/3.+iTime/10.0);\n    }\n    return clamp(col*0.5,0.0,1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t\n    float N = smoothfloor(clock());\n    float radian = -pi/(N-1.0);\n    float radius = (7.0+N)/(10.0+N);\n    vec2 position = vec2(cos(radian),sin(radian))*radius; // attachment position\n    \n    vec2 uv = uvmap(fragCoord.xy)/zoom+position;\n    \n    vec3 color = mandelbrot(uv,N)\n               + timesTable(uv,N);\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}