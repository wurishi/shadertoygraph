{"ver":"0.1","info":{"id":"dlS3R1","date":"1672842626","viewed":220,"name":"fractal aisle","username":"kinakomoti","description":"aisle made by fractal","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159264\n\nfloat hash21(vec2 p){\n    return fract(sin(dot(p,vec2(120.03,230.0))) * 1020302.0);\n}\n\nvec2 hash22(vec2 p ){\n    vec2 s = vec2(dot(p,vec2(102.43,390.23)),dot(p,vec2(329.02,285.2)));\n    return fract(sin(s) * 21032.0);\n}\n\nfloat hash31(vec3 p ){\n    return fract(sin(dot(p,vec3(320.32,219.3,129.34))) * 21032.0);\n}\n\nvec3 hash33(vec3 p){\n    vec3 s = vec3(dot(p,vec3(102.43,390.23, 295.02)),dot(p,vec3(329.02,165.3,285.2)),dot(p,vec3(203.53,329.02,285.2)));\n    return fract(sin(s) * 23021.0);\n}\n\nfloat repeat(float p,float a){\n    return mod(p,a) - a/2.0; \n}\n\nvec2 rotate(vec2 p,float theta){\n    float c = cos(theta), s = sin(theta);\n    return vec2(p.x * c + p.y * -s, s * p.x + p.y * c);\n}\n\nvec2 pmod(vec2 p,float r){\n    float a = atan(p.x,p.y) + PI / r;\n    float n = PI * 2.0 /r;\n    a = floor(a/n) * n;\n    \n    return rotate(p,-a);\n}\n\nfloat sd_sphere(vec3 p){\n    return length(p) - 0.5;\n}\n\nfloat repeat_sphere(vec3 p){\n    p = mod(p,3.0) - 1.5;\n    return sd_sphere(p);\n}\n\nfloat sd_chain(vec3 p,float le,float r1,float r2){\n    vec3 q = vec3(p.x,max(abs(p.y)-le,0.0),p.z);\n    return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\n#define ITERATIONS 5\nfloat dMengerDistance(vec3 p, vec3 offset,float scale){\n    vec4 z = vec4(p, 1.0);\n    for (int i = 0; i < ITERATIONS; i++) {\n        z = abs(z);\n        if (z.x < z.y) z.xy = z.yx;\n        if (z.x < z.z) z.xz = z.zx;\n        if (z.y < z.z) z.yz = z.zy;\n        z *= scale;\n        z.xyz -= offset * (scale - 1.0);\n        if (z.z < -0.5 * offset.z * (scale - 1.0))\n            z.z += offset.z * (scale - 1.0);\n    }\n    return (length(max(abs(z.xyz) - vec3(1.0, 1.0, 1.0), 0.0))) / z.w;\n}\n\nfloat map(vec3 p){\n    vec3 pos1 = p;\n    pos1.z = repeat(pos1.z,3.0);\n    pos1.x = repeat(pos1.x,3.0);\n    pos1.y = repeat(pos1.y,1.0);\n\n    pos1.xz = pmod(pos1.xz,8.0);\n    float d = dMengerDistance(pos1,vec3(1,pow(sin(iTime),2.0)* 0.5 + 0.5,pow(cos(0.5 * iTime) + 0.5,2.0)),3.0);\n\n    vec3 pos2 = p;\n    pos2.z = mod(pos2.z,5.0) - 2.5;\n    pos2.xy = pmod(pos2.xy,8.0);\n    float d1 = dMengerDistance(pos2,vec3(1.3,0.3 + sin(iTime),2.0),3.0);\n\n    float scale_1 = 1.0;\n    vec3 pos3 = p;\n    pos3.z = repeat(pos3.z,2.0);\n    pos3.xy = pmod(pos2.xy,10.0);\n    pos3 *= scale_1;\n    float d2 = dMengerDistance(pos3,vec3(1.0,1.0,1.0),3.0) / scale_1;\n\n    float offset = iTime * 3.0;\n    float offset1 = 1.5;\n    float offset2 = 0.5;\n    float scale = 5.0;\n\n    vec3 c_pos = p;\n    c_pos.y += 0.0 + offset;\n    c_pos.z += offset1;\n    c_pos.y = repeat(c_pos.y,offset2);\n    c_pos.x = repeat(c_pos.x,2.0);\n    c_pos.z = repeat(c_pos.z,3.0);\n    float c1 = sd_chain(c_pos * scale,0.5,0.4,0.1) / scale;\n\n    vec3 c_pos1 = p;\n    c_pos1.y += offset2/2.0 + offset;\n    c_pos1.z += offset1;\n    c_pos1.y = repeat(c_pos1.y,offset2);\n    c_pos1.x = repeat(c_pos1.x,2.0);\n    c_pos1.z = repeat(c_pos1.z,3.0);\n    c_pos1.xz = rotate(c_pos1.xz,PI /2.0);\n    float c2 = sd_chain(c_pos1 * scale,0.5,0.4,0.1) / scale;\n\n    vec3 c_pos2 = p;\n    c_pos2.xy = rotate(c_pos2.xy,PI / 2.0);\n    c_pos2.y += 0.0 + offset;\n    c_pos2.z += offset1;\n    c_pos2.y = repeat(c_pos2.y,offset2);\n    c_pos2.x = repeat(c_pos2.x,2.0);\n    c_pos2.z = repeat(c_pos2.z,3.0);\n    float c3 = sd_chain(c_pos2 * scale,0.5,0.4,0.1) / scale;\n\n    vec3 c_pos3 = p;\n    c_pos3.xy = rotate(c_pos3.xy,PI / 2.0);\n    c_pos3.y += offset2/2.0 + offset;\n    c_pos3.z += offset1;\n    c_pos3.y = repeat(c_pos3.y,offset2);\n    c_pos3.x = repeat(c_pos3.x,2.0);\n    c_pos3.z = repeat(c_pos3.z,3.0);\n    c_pos3.xz = rotate(c_pos3.xz,PI /2.0);\n    float c4 = sd_chain(c_pos3 * scale,0.5,0.4,0.1) / scale;\n\n\n\n    float dist = min(c1,c2);\n    dist = min(dist,d);\n    dist = min(dist,d2);\n    //dist = min(dist,d1);\n    dist = min(dist,c3);\n    dist = min(dist,c4);\n\n    \n    return dist;\n}\n\nvec3 get_normal(vec3 p){\n    vec3 ipsiron = vec3(0.001,0,0);\n    float d = map(p);\n    vec3 n = d - vec3(\n        map(p - ipsiron.xyy),\n        map(p - ipsiron.yxy),\n        map(p - ipsiron.yyx)\n    );\n\n    return normalize(n);\n}\n\nfloat soft_shadow(vec3 ro,vec3 rd,float mint,float maxt,float k){\n    float res = 1.0;\n    for(float t = mint; t < maxt;){\n        float h = map(ro + t * rd);\n        if(h < 0.001){\n            return 0.;\n        }\n\n        res = min(res, k*h / t);\n        t += h;\n    }\n    return res;\n}\n\nfloat voronoi3d(vec3 p,inout float d1,inout float d2){\n    vec3 sr_i = floor(p);\n    vec3 sr_f = fract(p);\n\n    d1 = 2.0;\n    d2 = 2.0;\n    for(int i = -1; i <= 1; i++){\n        for(int j = -1; j <= 1; j++){\n            for(int k = -1; k <= 1; k++){\n                vec3 cell_idx = vec3(i,j,k);\n                vec3 cell_offset = cell_idx + hash33(cell_idx + sr_i);\n                vec3 point_dist = abs(sr_f - cell_offset);\n                float dist = max(max(point_dist.x,point_dist.y),point_dist.z);\n\n                if(dist < d1){\n                    d2 = d1;\n                    d1 = dist;\n                }\n                else if(dist < d2){\n                    d2 = dist;\n                }\n            }\n        }\n    }\n\n    return d1;\n}\n\nvec3 texture(vec3 pos){\n    float d1,d2,d3,d4;\n    vec3 offset = vec3(1) + vec3(0,iTime*2.0,0);\n    vec3 scale = vec3(1);\n    voronoi3d(pos,d1,d2);\n    voronoi3d(pos * scale+offset ,d3,d4);\n\n    float clack_1 = d2 - d1;\n    float clack_2 = d4 - d3;\n\n    float line_width = 0.01;\n\n    vec3 circuit_color = vec3(0.3,0.4,0.5) * 2.0;\n    vec3 line_color = vec3(0.6);\n\n    vec3 col = vec3(0);\n    \n    //col = (clack_1 < line_width) ?  line_color : col;\n    col = (clack_2 < line_width&&clack_1 < 0.01) ?  circuit_color : col;\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n\n    float time = iTime * 1.0;\n    vec3 ro = vec3(0,2.0,-3.0 + time);\n    vec3 rd = normalize(vec3(uv,1.0));\n    rd.xy = rotate(rd.xy,time * 0.1);\n    rd.xz = rotate(rd.xz,time * 0.4);\n\n    float i = 0.0;\n    float d = 0.0;\n    float dist = 0.0;\n    vec3 pos;\n    \n    vec3 l_pos = ro + vec3(0,0,-2);\n    float l_dist = 100.0;\n\n    //Raymarching\n    for(; i < 100.0; i++){\n        pos = ro + d * rd;\n        l_dist = min(length(l_pos - pos),l_dist); \n        dist = map(pos) * 0.8;\n        if(dist < 0.001) break;\n\n        d += dist;\n    }\n\n    vec3 col = vec3(0);\n\n    vec3 light_col = vec3(1.0) * 0.5;\n    vec3 d_col = vec3(0.3,0.4,0.9);\n    if(dist < 0.001){\n        //Lighting \n        vec3 normal = get_normal(pos);\n        vec3 view = normalize(ro - pos);\n        vec3 l_dir = normalize(l_pos - pos);\n        float AO = 3.0/i;\n\n        float r = length(l_pos - pos);\n        float shadow =  100.0 * soft_shadow(pos,l_dir,0.001,r,1.0);\n\n        vec3 diffuse = dot(normal,l_dir) * d_col * light_col * shadow + d_col * 0.5;\n\n        vec3 h = normalize(view+l_dir);\n        vec3 specular = pow(dot(h,normal),10.0) * light_col;\n\n\n        vec3 emission = vec3(0.2) * abs(pow(sin(pos.y + iTime),10.0));\n        col = vec3(AO) * (diffuse + specular);\n        col += texture(pos * 1.0);\n    }\n    col += 0.01 * light_col / l_dist;\n\n    //test\n    fragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"}]}