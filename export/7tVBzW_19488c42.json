{"ver":"0.1","info":{"id":"7tVBzW","date":"1664194149","viewed":83,"name":"Strange hypno-cave #2","username":"ppk","description":"My second shader, homework in MIPT. Moving a mouse will move the light spot. Addded textures + corrected some things (thx FabriceNeyret2)","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["stareatthescreen1","herewegoagain","nowwithtextures"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITERS   90\n#define MAX_DIST    10.0\nconst vec3 eye = vec3(0., 0., 5.);\nconst float eps = 0.001;\nconst float PI = 3.1415926531;\nconst float sqrt3 = 1.7320508076;\n\nfloat dsphere ( in vec3 p, in vec3 c, in float radius)\n{\n    return length ( p - c) - radius;\n}\n\nmat3 rotateY(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nfloat doctahedron(vec3 p, float s) {    \n    const float c = sqrt3;\n    return (dot(abs(rotateY(-iTime) * p), vec3(1.0)) - s) / c;\n}\n\nfloat sdf(vec3 p, float c) {\n    return doctahedron( p, c);\n}\n\nvec3 traceLight ( vec3 from, vec3 dir, vec3 light, out bool hit )\n{\n    vec3     p         = from;\n    float    totalDist = 0.0;\n    \n    hit = false;\n    \n    for (int steps = 0; steps < MAX_ITERS; steps++ )\n    {\n        float    dist = dsphere ( p, light, 1.2 );\n        \n        if ( dist < eps )\n        {\n            hit = true;\n            break;\n        }\n        \n        totalDist += dist;\n        \n        if ( totalDist > MAX_DIST )\n            break;\n            \n        p += dist * dir;\n    }\n    \n    return p;\n}\n\nvec3 trace ( vec3 from, vec3 dir, float m, out bool hit )\n{\n    vec3     p         = from;\n    float    totalDist = 0.0;\n    \n    hit = false;\n    \n    for (int steps = 0; steps < MAX_ITERS; steps++ )\n    {\n        float    dist = doctahedron ( p, m );\n        \n        if ( dist < eps )\n        {\n            hit = true;\n            break;\n        }\n        \n        totalDist += dist;\n        \n        if ( totalDist > MAX_DIST )\n            break;\n            \n        p += dist * dir;\n    }\n    \n    return p;\n}\n\nvec3 generateNormal ( vec3 z, float d, float m )\n{\n    float e   = max (d * 0.5, eps );\n    float dx1 = sdf(z + vec3(e, 0, 0), m);\n    float dx2 = sdf(z - vec3(e, 0, 0), m);\n    float dy1 = sdf(z + vec3(0, e, 0), m);\n    float dy2 = sdf(z - vec3(0, e, 0), m);\n    float dz1 = sdf(z + vec3(0, 0, e), m);\n    float dz2 = sdf(z - vec3(0, 0, e), m);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\n\nfloat spiral(vec2 uv){\n    return (fract(6.0*((length(uv)*0.5)-(atan(uv.x,uv.y))/(PI))));\n}\n\nvec3 getTriplanarWeights ( in vec3 n ) {\n    vec3 w = abs ( n );\n    w *= w;\n    return w / ( w.x + w.y + w.z );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    bool lighthit;\n    bool hit;\n    vec3 mouse;\n    mouse = vec3(iMouse.xy/iResolution.xy - 0.5, iMouse.z - 0.5);\n    if(iMouse.xy == vec2(0)) {\n        mouse = vec3(0.05 * cos(iTime), 0.05 * sin(iTime), -0.5);\n    }\n    vec3 light = vec3(8.0 * mouse.x, 4.5 * mouse.y, 2);\n    vec2 uv = 9. * (fragCoord - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n    vec3 dir = normalize(vec3(uv, 0)-eye);\n    vec3 spot = traceLight(eye, dir, light, lighthit);\n    float m = 0.5*cos(iTime) + 0.5;\n    vec3 p = trace(eye, dir, m, hit);\n    vec4 col = vec4(0);\n\n    if (lighthit)\n        if (hit) {\n            vec3 l = normalize (light - p);\n            vec3 n = generateNormal(p, 0.001, m);\n            float nl = max(0.0, dot(n, l));\n            float v = mod(floor(iTime/(2. * PI) + 0.5), 5.);\n            if (v < 3.) \n                col[int(v)] = nl;\n            else if (v >= 3. && v < 4.) \n                col = vec4(nl, nl, 0., 1.);\n            else if (v >= 4.) \n                col = vec4(nl, 0., nl, 1.);\n            vec3  tx = getTriplanarWeights ( n );\n            vec3  q = normalize(abs(rotateY(-iTime) * p));\n            vec4  cx = texture ( iChannel2, q.yz );\n            vec4  cy = texture ( iChannel2, q.zx );\n            vec4  cz = texture ( iChannel2, q.xy );\n\n            col = col * (tx.x * cx + tx.y + cy + tx.z * cz);\n        }\n        else {\n            col = 0.5 * texture(iChannel0, fragCoord/iResolution.xy);\n            float sdf = spiral(uv);\n            float f = fract(2.*iTime);\n            col += texture(iChannel1, fragCoord/iResolution.xy) * (smoothstep(f-0.1, f, sdf) - smoothstep(f, f + 0.1, sdf));\n        }\n    else\n        col = vec4(0);\n\n    // Output to screen\n    fragColor = vec4(col);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float PI = 3.1415926531;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.5*sin(iTime) + 0.5,0.5*sin(iTime + PI/3.) + 0.5,0.5*sin(iTime + 2. * PI / 3.) + 0.5,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}