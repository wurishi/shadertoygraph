{"ver":"0.1","info":{"id":"dtf3zB","date":"1671939271","viewed":91,"name":"a bit of ray tracing","username":"Verlio_H","description":"w, a, s, d, shift, and space for movement\narrows + q and e for rotation\nadaptation of my ray marcher into a ray tracer\nmade using information gathered from various sources, such as ray tracing in a weekend and ray marching for dummies","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = textureLod(iChannel0, fragCoord.xy / iResolution.xy, 0.0);\n    fragColor = pow(fragColor, vec4(1./2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"precision highp float;\n\n#define EMISSIVE 1\n#define REFLECTIVE 2\n#define REFRACT 4\n\nstruct object {\n    int type;\n    vec3 pos;\n    float r;\n    vec3 albedo;\n    int properties;\n    float fuzz;\n};\n\n#define NUM_OBJ 6\n\nconst object[NUM_OBJ] tbl = object[](\n    object(0, vec3(0), 0., vec3(0.77, 0.87, 1), 0, 0.),\n    object(2, vec3(0, 0, 2), .5, vec3(0.7, 0.3, 0.3), 0, 0.),\n    object(2, vec3(-1, 0, 2), .5, vec3(0.9), REFRACT, 1.3),\n    object(2, vec3(-1, 0, 2), .499, vec3(0.1, 0.3, 0.6), 0, 0.),\n    object(2, vec3(1, 0, 2), .5, vec3(0.8), REFLECTIVE, 0.01),\n    object(1, vec3(0, -0.5, 0), 0., vec3(0.1, 0.8, 0.4), 0, 0.)\n);\n\n\n#define MAX_ITER 128\n#define MAX_DIST 100.\n#define SURF_DIST .005\n#define MAX_REFLECT 250\n#define PI 3.1415926535897932384626433832795\n#define APERTURE 0.0\n#define FOCUS 2.\n\nvec2 seed;\nint inside;\n\nfloat random () {\n    seed += vec2(iTime);\n    float a = 12.9898;\n    float b = 78.233;\n    float c = 43758.5453;\n    float dt= dot(seed.xy ,vec2(a,b));\n    float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\n\nvec3 random_in_unit_sphere() {\n    vec3 result;\n    result.x = random()*2.-1.;\n    result.y = random()*2.-1.;\n    result.z = random()*2.-1.;\n    while (length(result) > 1.) {\n        result.x = random()*2.-1.;\n        result.y = random()*2.-1.;\n        result.z = random()*2.-1.;\n    }\n    return result;\n}\n\nvec2 random_in_unit_disk() {\n    vec2 result;\n    result.x = random()*2.-1.;\n    result.y = random()*2.-1.;\n    while (length(result) > 1.) {\n        result.x = random()*2.-1.;\n        result.y = random()*2.-1.;\n    }\n    return result;\n}\n\n\n\nfloat RayTrace(vec3 ro, vec3 rd, out int o) {\n    float dist = 100000.;\n    float dist2;\n    for(int i = 0; i < NUM_OBJ; ++i) {\n        object thing = tbl[i];\n        if (thing.type == 1) {\n            if (thing.pos.y < ro.y && rd.y < 0.) {\n                float mfactor = abs(ro.y - thing.pos.y)/rd.y;\n                dist2 = length(rd*mfactor);\n                if (dist2 < dist && dist2 > 0.) {\n                    o = i;\n                    dist = dist2;\n                }\n            }\n        } else if (thing.type == 2) {\n            vec3 oc = ro - thing.pos;\n            float hb = dot(oc, rd);\n            float c = length(oc)*length(oc) - thing.r*thing.r;\n            float discriminant = hb*hb - c;\n            if (discriminant > 0.) {\n                dist2 = (-hb - sqrt(discriminant));\n                if ((dist2 < dist && dist2 > 0.) && (inside == 0 || ((thing.properties & REFRACT) == 0))) {\n                    o = i;\n                    dist = dist2;\n                } else if (inside == 1) {\n                    dist2 = (-hb + sqrt(discriminant));\n                    if (dist2 < dist && dist2 > 0.) {\n                        o = i;\n                        dist = dist2;\n                    }\n                }\n            }\n        } else {\n            if (dist > 10000.) {\n                dist = 10000.;\n                o = 0;\n            }\n        }\n    }\n    return dist;\n}\n\nvec3 GetNormal(vec3 p, int o) {\n    object thing = tbl[o];\n    if (thing.type == 1) {\n        return vec3(0, 1, 0);\n    } else if (thing.type == 2) {\n        vec3 norm = normalize(p - thing.pos);\n        if (thing.r < 0.) {\n            return -norm;\n        }\n        return norm;\n    }\n}\n\n\nfloat reflectance(float cosine, float ref_idx) {\n    float r0 = (1.-ref_idx) / (1.+ref_idx);\n    r0 = r0*r0;\n    return r0 + (1.-r0)*pow((1. - cosine),5.);\n}\n        \n        \nvec3 GetLight(vec3 p, int o, vec3 dir) {\n    int refCnt = 0;\n    vec3 colMlt = vec3(1.);\n    while (refCnt < MAX_REFLECT) {\n        object obj = tbl[o];\n        if (obj.type == 0) {\n            return obj.albedo*colMlt;\n        } else if ((obj.properties & EMISSIVE) != 0) {\n            return obj.albedo*colMlt;\n        }\n        ++refCnt;\n        vec3 norm = GetNormal(p, o);\n        if ((obj.properties & REFLECTIVE) != 0) {\n            p += norm * 0.00001;\n            norm = normalize(reflect(dir, norm) + random_in_unit_sphere() * obj.fuzz);\n        } else if ((obj.properties & REFRACT) != 0) {\n            float ratio;\n            if (inside == 0) {\n                inside = 1;\n                ratio = 1./obj.fuzz;\n            } else {\n                inside = 0;\n                norm *= -1.;\n                ratio = obj.fuzz;\n            }\n            float cos_theta = min(dot(-dir, norm), 1.0);\n            float sin_theta = sqrt(1.0 - cos_theta*cos_theta);\n            if (ratio*sin_theta > 1. || reflectance(cos_theta, ratio) > random()) {\n                p += norm * 0.00001;\n                norm = reflect(dir, norm);\n                if (inside == 1) inside = 0;\n                else inside = 1;\n            } else {\n                norm = refract(dir, norm, ratio);\n            }\n        } else {\n            p += norm * 0.00001;\n            norm = normalize(norm + normalize(random_in_unit_sphere()));\n        }\n        colMlt *= obj.albedo;\n        dir = norm;\n        p += norm * RayTrace(p, norm, o);\n        \n    }\n    return vec3(0);\n}\n\nvec3 rotate(vec3 v, vec4 q) {\n    vec3 temp = cross(q.xyz, v) + q.w * v;\n    return v + 2.0*cross(q.xyz, temp);\n}\n\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        inside = 0;\n        vec3 col = vec3(0);\n        vec3 prevFrame = textureLod(iChannel0, fragCoord.xy / iResolution.xy, 0.0).rgb;\n        seed = fragCoord.xy / iResolution.xy * iTime;\n        fragCoord.x += random()-.5;\n        fragCoord.y += random()-.5;\n        vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n        vec3 ro = textureLod(iChannel1, vec2(0.5)/iResolution.xy, 0.0).xyz;\n        vec3 camrot = textureLod(iChannel3, vec2(0.5)/iResolution.xy, 0.0).xyz;\n       // camrot = vec3(0., 0., 0.);\n        \n        vec3 offset = vec3(APERTURE*random_in_unit_disk(), 0.);\n        offset.yz *= rot(camrot.y);\n        offset.xz *= rot(camrot.x);\n        offset.xy *= rot(camrot.z);\n        vec3 dpos = vec3(uv.xy*FOCUS+ro.xy, FOCUS+ro.z);\n        ro += offset;\n        vec3 rd = normalize(dpos - ro);\n        rd.yz *= rot(camrot.y);\n        rd.xz *= rot(camrot.x);\n        rd.xy *= rot(camrot.z);\n        int o;\n    \n        float d = RayTrace(ro, rd, o);\n        vec3 p = ro + rd * d;\n        \n        col = tbl[o].albedo;\n        col = GetLight(p, o, rd);\n        float time = max(textureLod(iChannel1, vec2(0.5)/iResolution.xy, 0.0).w, textureLod(iChannel3, vec2(0.5)/iResolution.xy, 0.0).w);\n        float mixture = clamp(1./(float(iFrame)-time), 0.01, 1.);\n        col = mix(prevFrame, col, mixture);\n    fragColor = vec4(col, 1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float ReadKeyInternal( int key, bool toggle )\n{\n\treturn textureLod( iChannel2, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ), 0.0 ).x;\n}\n\nfloat ReadKey( int key )\n{\n\treturn ReadKeyInternal(key,false);\n}\n\nfloat ReadKeyToggle( int key )\n{\n\treturn ReadKeyInternal(key,true);\n}\n\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.xy == vec2(0.5)) {\n        fragColor = textureLod(iChannel1, fragCoord.xy/iResolution.xy, 0.0 );\n        vec3 camrot = textureLod(iChannel3, vec2(0.5)/iResolution.xy, 0.0).xyz;\n        vec3 move;\n        move.z = (ReadKey(87)-ReadKey(83)) * iTimeDelta;\n        move.x = (ReadKey(68)-ReadKey(65)) * iTimeDelta;\n        move.y = (ReadKey(32)-ReadKey(16)) * iTimeDelta;\n        move.yz *= rot(camrot.y);\n        move.xz *= rot(camrot.x);\n        move.xy *= rot(camrot.z);\n        if (move != vec3(0.)) {\n            fragColor.w = float(iFrame)-1.;\n        }\n        fragColor += vec4(move, 0);\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"float ReadKeyInternal( int key, bool toggle )\n{\n\treturn textureLod( iChannel2, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ), 0.0 ).x;\n}\n\nfloat ReadKey( int key )\n{\n\treturn ReadKeyInternal(key,false);\n}\n\nfloat ReadKeyToggle( int key )\n{\n\treturn ReadKeyInternal(key,true);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.xy == vec2(0.5)) {\n        fragColor = textureLod(iChannel3, fragCoord.xy/iResolution.xy, 0.0 );\n        vec3 move;\n        move.z = (ReadKey(81)-ReadKey(69)) * iTimeDelta;\n        move.x = (ReadKey(37)-ReadKey(39)) * iTimeDelta;\n        move.y = (ReadKey(40)-ReadKey(38)) * iTimeDelta;\n        if (move.xyz != vec3(0)) {\n            fragColor.w = float(iFrame)-1.;\n        }\n        fragColor += vec4(move, 0);\n    }\n}","name":"Buffer C","description":"","type":"buffer"}]}