{"ver":"0.1","info":{"id":"4tlfDn","date":"1511632969","viewed":983,"name":"Reusable Voxel Engine","username":"mhnewman","description":"Simple to reuse, fast voxel engine. Create your scene by filling in setCamera(), voxelHit(), and voxelColor().\n\nResponds to mouse.","likes":58,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","grid","voxel","marching","reusable"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Simple to reuse, fast voxel engine.\n// Create your scene by filling in setCamera(), voxelHit(), and voxelColor().\n// The engine uses a Z-up right-handed coordinate system.\n// The following constants may also be set.\nconst vec3 backgroundColor = vec3(0.6, 0.7, 0.8);\nconst vec3 lightDir = vec3(-0.36, -0.48, 0.8);\nconst float shadow = 0.7;\nconst int maxIter = 100;\n\n#define CAST_SHADOW\n\n// Set Camera will position and aim the camera.\n//   eye := The location of the camera.\n//   center := The location at which the camera is looking.\n//   Return value := Camera focal length. (i.e. zoom)\nfloat setCamera(out vec3 eye, out vec3 center) {\n    \n    // Fill in this function.\n    vec2 m = vec2(0.1 * iTime, 0.7);\n    if (iMouse.z > 0.0)\n        m = iMouse.xy / iResolution.xy;\n    m *= 6.283185 * vec2(1.0, 0.25);    \n    float dist = 20.0;\n    center = vec3(0.5);\n    eye = center + vec3(dist * sin(m.x) * sin(m.y), dist * cos(m.x) * sin(m.y), dist * cos(m.y));\n    return 3.0;\n\n}\n\n// Voxel Hit returns true if the voxel at pos should be filled.\nbool voxelHit(vec3 pos) {\n    \n    // Fill in this function.\n    vec3 hash = fract(pos * vec3(5.3983, 5.4427, 6.9371));\n    hash += dot(hash, hash.yzx + 19.19);\n    return length(pos) + 2.0 * fract((hash.x + hash.y) * hash.z) < 6.0 + 0.5 * sin(3.0 * iTime);\n\n}\n\n// Voxel Color returns the color at pos with normal vector norm.\nvec3 voxelColor(vec3 pos, vec3 norm) {\n    \n    // Fill in this function.\n    return mix(vec3(0.3, 0.5, 0.8), vec3(1.0, 0.4, 0.0), 0.5 * (length(floor(pos)) - 4.0));\n\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Fill in the functions above.\n// The engine below does not need to be modified.\n////////////////////////////////////////////////////////////////////////////////\n\nfloat castRay(vec3 eye, vec3 ray, out float dist, out vec3 norm) {\n    vec3 pos = floor(eye);\n    vec3 ri = 1.0 / ray;\n    vec3 rs = sign(ray);\n    vec3 ris = ri * rs;\n    vec3 dis = (pos - eye + 0.5 + rs * 0.5) * ri;\n    \n    vec3 dim = vec3(0.0);\n    for (int i = 0; i < maxIter; ++i) {\n        if (voxelHit(pos)) {\n            dist = dot(dis - ris, dim);\n            norm = -dim * rs;\n            return 1.0;\n        }\n    \n        dim = step(dis, dis.yzx);\n\t\tdim *= (1.0 - dim.zxy);\n        \n        dis += dim * ris;\n        pos += dim * rs;\n    }\n\n\treturn 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 eye, center;\n    float zoom = setCamera(eye, center);\n    \n    vec3 forward = normalize(center - eye);\n    vec3 right = normalize(cross(forward, vec3(0.0, 0.0, 1.0)));\n    vec3 up = cross(right, forward);\n    vec2 xy = 2.0 * fragCoord - iResolution.xy;\n    vec3 ray = normalize(xy.x * right + xy.y * up + zoom * forward * iResolution.y);\n    \n    float dist;\n    vec3 norm;\n    float hit = castRay(eye, ray, dist, norm);\n    vec3 pos = eye + dist * ray;\n\n    vec3 color = voxelColor(pos - 0.001 * norm, norm);\n    float shade = dot(norm, lightDir);\n    \n#ifdef CAST_SHADOW\n    float illuminated = 1.0 - castRay(pos + 0.001 * norm, lightDir, dist, norm);\n    float light = (1.0 + shadow * (illuminated * max(shade, 0.0) - 1.0)) * (1.0 - max(-shade, 0.0));\n#else\n    float light = (1.0 + shadow * (max(shade, 0.0) - 1.0)) * (1.0 - max(-shade, 0.0));    \n#endif\n    \n    fragColor = vec4(mix(backgroundColor, light * color, hit), 1.0);\n}","name":"Image","description":"","type":"image"}]}