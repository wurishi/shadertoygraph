{"ver":"0.1","info":{"id":"4XXcR4","date":"1725886309","viewed":34,"name":"Rectangle Truchet Variant","username":"chronos","description":"Saw the rectangle tree truchet pattern by snoopetheduck.\nClick to show rectangle subdivision tree.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["tree","truchet","rectangle","subdivision","weave","reproduction"],"hasliked":0,"parentid":"M3lczH","parentname":"Rectangle Truchet Reproduction"},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n    \"Variant of \"RectSubdivide Multiscale Truchet\" by SnoopethDuckDuck\" by chronos\n    ----------------------------------------------------------------------------------\n    \n    Tried to code this pattern myself after learning from the original shader.\n    It's not as good as Snoopeth's, but close enough for me! ¯\\_(ツ)_/¯\n    \n    See SnoopethDuckDuck's original shader here: https://www.shadertoy.com/view/XfSBWV\n    \n    ----------------------------------------------------------------------------------\n*/\n\n#define TRANSPARENT_DISCS 0\n#define ALLOW_MIDDLE_DISCS 1\n#define POLAR_COORDINATES 0\n#define TUNNEL_COORDINATES 0\n#define CAST_SHADOW 1\n\nconst float gridsize = 10.;\nconst int num_iterations = 3;\nfloat zoom = 2.;\n    \n    \nvec2 split_wh(vec2 uv, vec2 wh, vec2 p)\n{\n    wh.x = uv.x < p.x ? p.x : wh.x - p.x;\n    wh.y = uv.y < p.y ? p.y : wh.y - p.y;\n    return wh;\n}\n\nvec2 split_uv(vec2 uv, vec2 p)\n{\n    uv.x = uv.x < p.x ? uv.x : uv.x - p.x;\n    uv.y = uv.y < p.y ? uv.y : uv.y - p.y;\n    return uv;\n}\n\nvec2 split_id(vec2 uv, vec2 p)\n{\n    uv.x = uv.x < p.x ? 0. : 1.;\n    uv.y = uv.y < p.y ? 0. : 1.;\n    return uv;\n}\n\nvec3 id_to_color(vec2 ids)\n{\n    return pow(texelFetch(iChannel0, ivec2(ids)%1024, 0).rgb, vec3(2.));\n}\n\nint ids_to_id(vec2 ids, int iter)\n{\n    ivec2 IDs = ivec2(ids);\n    int id = (IDs.y << iter) + IDs.x;\n    return id;\n}\n\nivec4 permutation(int id)\n{\n    ivec4 perm = ivec4(0,1,2,3);\n    \n    ivec4[24] all_permutations = ivec4[](\n        perm.xyzw,\n        perm.xywz,\n        perm.xzyw,\n        perm.xzwy,\n        perm.xwyz,\n        perm.xwzy,\n\n        perm.yxzw,\n        perm.yxwz,\n        perm.yzxw,\n        perm.yzwx,\n        perm.ywxz,\n        perm.ywzx,\n\n        perm.zyxw,\n        perm.zywx,\n        perm.zxyw,\n        perm.zxwy,\n        perm.zwyx,\n        perm.zwxy,\n\n        perm.wyzx,\n        perm.wyxz,\n        perm.wzyx,\n        perm.wzxy,\n        perm.wxyz,\n        perm.wxzy\n    );\n    \n    return all_permutations[id%24];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    zoom = zoom * (max(cos(iTime*.5), 0.)+1.);\n    \n    uv *= zoom;\n    \n    float t = -iTime*.05;\n    \n    #if POLAR_COORDINATES\n        #if TUNNEL_COORDINATES\n        \n        uv = vec2(3./(length(uv)), 6.*fract(t*.5 + .5*(1.+atan(uv.y, uv.x)/3.14159265)));\n        float ps = //(uv.y < 5.99 && uv.y > 0.01) || uv.x > 6. ? length(fwidth(uv))/2. : \n        exp(2.*min(uv.x/2., 5.)) / iResolution.y;\n        uv.x += iTime*.5;\n        #else\n        \n        uv = vec2(log(length(uv))*.75, 6.*fract(t*.5 + .5*(1.+atan(uv.y, uv.x)/3.14159265)));\n        float ps = max(uv.x, 1.)/iResolution.y;//length(fwidth(uv))/2.;\n        #endif\n    \n    \n    #else\n    float ps = zoom / iResolution.y;\n    uv = (uv + 1.) / 2.;\n    uv += vec2(cos(t), sin(t))*10.;\n    #endif\n    \n    vec2 UV = uv;\n    \n    vec3 color = vec3(0);\n\n    vec2 p   = vec2(0);\n    vec2 ids = floor(uv+1024.);\n    \n    uv = fract(uv+1024.);\n    \n\n    vec2 wh = vec2(1);\n    for(int i = 0; i < num_iterations; i++)\n    {\n        p   = ((1./gridsize) + (1.-2./gridsize) * texelFetch(iChannel0, ivec2(ids)%1024, 0).rg) * wh;\n        \n        p = round(gridsize * p) / gridsize;\n                \n        ids = ids * 2. + split_id(uv, p);\n        wh  = split_wh(uv, wh, p);\n        uv  = split_uv(uv, p);\n  \n        if(min(wh.x, wh.y) <= 2./gridsize) break;\n    }\n\n    color += \n        smoothstep(0.25-gridsize*ps, 0.25+gridsize*ps, fract(gridsize * (wh.x < wh.y? uv.y : uv.x))) * \n        smoothstep(0.75+gridsize*ps, 0.75-gridsize*ps, fract(gridsize * (wh.x < wh.y? uv.y : uv.x)));\n\n    vec2[4] positions = vec2[]( vec2(0), vec2(1,0)*wh, vec2(0,1)*wh, wh );\n\n    float r = min(wh.x, wh.y);\n    int id = ids_to_id(ids, num_iterations);\n    \n    // This allows some of the rectangles to put their discs on the middle of the short edges,\n    // instead of the coners\n    #if ALLOW_MIDDLE_DISCS\n    \n        if(id % 3 == 0)\n        {\n            r/=2.;\n            if(wh.x < wh.y)\n            {\n                positions[0] = vec2(r, 0);\n                positions[1] = vec2(r, 0);\n                positions[2] = vec2(r, wh.y);\n                positions[3] = vec2(r, wh.y);\n            }\n            else\n            {\n                positions[0] = vec2(0, r);\n                positions[1] = vec2(wh.x, r);\n                positions[2] = vec2(0, r);\n                positions[3] = vec2(wh.x, r);\n            }\n        }   \n    \n    #endif\n\n    \n    \n    ivec4 perm = permutation(id);\n    \n    for(int i = 0; i < 4; i++)\n    {\n        vec2 pos = positions[perm[i]];\n        \n        float d = length(uv - pos) - r;\n        \n        //float trim = .125/gridsize; // trims half the black edge\n        //float trim = .25/gridsize;  // trims the entire black edge\n        float trim = .175/gridsize;   // trims the majority of the black edge\n        \n        float pattern = \n            smoothstep(0.25-gridsize*ps, 0.25+gridsize*ps, fract(gridsize * d)) * \n            smoothstep(0.75+gridsize*ps, 0.75-gridsize*ps, fract(gridsize * d));\n        \n        \n        #if TRANSPARENT_DISCS\n        // Cast shadow from white lines\n        color *= \n            mix(1.-\n                smoothstep(0.1 -gridsize*ps, 0.25+gridsize*ps, fract(gridsize * d)) * \n                smoothstep(0.9+gridsize*ps, 0.75-gridsize*ps, fract(gridsize * d)),\n            1.,\n            smoothstep(0., trim, d+trim))\n            ;\n            \n        color = mix(color, vec3(1), pattern * smoothstep(ps, -ps, d + trim)); // only draw white lines\n        \n        #else\n        \n            #if CAST_SHADOW && !POLAR_COORDINATES\n                color *= smoothstep(0., trim, d+trim); // disc shadow\n            #endif\n        color = mix(color, vec3(pattern), smoothstep(ps, -ps, d + trim)); // draw pattern on disc\n        #endif\n    }\n\n    if(iMouse.z > 0.)\n    {\n        color += smoothstep(0.95, 1., fract(gridsize * UV).x);\n        color += smoothstep(0.95, 1., fract(gridsize * UV).y);\n\n        color = mix(color, vec3(1), smoothstep(wh.x-0.005-ps, wh.x-0.005, uv.x));\n        color = mix(color, vec3(1), smoothstep(wh.y-0.005-ps, wh.y-0.005, uv.y));\n        \n        color = mix(color, vec3(1), smoothstep(0.005+ps, 0.005, uv.x));\n        color = mix(color, vec3(1), smoothstep(0.005+ps, 0.005, uv.y));\n        \n        color = color*.8 +.2;\n        color *= id_to_color(ids);\n    }\n    \n    #if POLAR_COORDINATES && !TUNNEL_COORDINATES\n    \n    color *= UV.x+1.;\n    \n    #endif\n    \n    color = pow(color, vec3(1./2.2));\n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}