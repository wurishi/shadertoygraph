{"ver":"0.1","info":{"id":"dlfyDM","date":"1690877754","viewed":56,"name":"2D Cubic Bézier Triangle","username":"Reynolds","description":"Nicely behaved (injective) 2D Bézier triangles have the property that every point is within its boundary curves. We can recursively split it in half along the longest side.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["bezier","inverse","subdivision","patch"],"hasliked":0,"parentid":"7ltBzj","parentname":"2D Cubic Bézier patch"},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ZERO min(0,iFrame)\n#define maxIterations 24\n\n//From Trisomie21\n//But instead of his cancellation fix i'm using a newton iteration\nint solve_cubic(vec3 coeffs, inout vec3 r){\n\n\tfloat a = coeffs[2];\n\tfloat b = coeffs[1];\n\tfloat c = coeffs[0];\n\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0) { // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = sign(u)*pow(abs(u),1.0/3.0);\n\t\tv = sign(v)*pow(abs(v),1.0/3.0);\n\t\tr[0] = offset + u + v;\t\n\n\t\t//Single newton iteration to account for cancellation\n\t\tfloat f = ((r[0] + a) * r[0] + b) * r[0] + c;\n\t\tfloat f1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\t\tr[0] -= f / f1;\n\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t//Single newton iteration to account for cancellation\n\t//(once for every root)\n\tr[0] = offset + u * (m + m);\n    r[1] = offset - u * (n + m);\n    r[2] = offset + u * (n - m);\n\n\tvec3 f = ((r + a) * r + b) * r + c;\n\tvec3 f1 = (3. * r + 2. * a) * r + b;\n\n\tr -= f / f1;\n\n\treturn 3;\n}\n\n//From Trisomie21\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n\n\t// normal form: x^2 + px + q = 0\n\tfloat p = coeffs[1] / 2.;\n\tfloat q = coeffs[0];\n\n\tfloat D = p * p - q;\n\n\tif (D < 0.){\n\t\treturn 0;\n\t}\n\telse{\n\t\troots[0] = -sqrt(D) - p;\n\t\troots[1] = sqrt(D) - p;\n\n\t\treturn 2;\n\t}\n}\n\n//From Trisomie21\nint cubic_bezier_int_test(vec2 p0, vec2 p1, vec2 p2, vec2 p3, vec2 uv){\n\n\tfloat cu = (-p0.y + 3. * p1.y - 3. * p2.y + p3.y);\n\tfloat qu = (3. * p0.y - 6. * p1.y + 3. * p2.y);\n\tfloat li = (-3. * p0.y + 3. * p1.y);\n\tfloat co = p0.y - uv.y;\n\n\tvec3 roots = vec3(1e38);\n\tint n_roots;\n    \n    int n_ints=0;\n        \n    if(uv.x<min(min(p0.x,p1.x),min(p2.x,p3.x))){\n\t\tif(uv.y>=min(p0.y,p3.y) && uv.y<=max(p0.y,p3.y)){\n\t\t\tn_ints=1;\n\t\t}\n\t}\n    else{\n    \n        if(abs(cu) < .00001){\n            n_roots = solve_quadric(vec2(co/qu,li/qu),roots.xy);\n        }\n        else{\n            n_roots = solve_cubic(vec3(co/cu,li/cu,qu/cu),roots);\n        }\n\n        for(int i=ZERO;i<n_roots;i++){\n            if(roots[i] >= 0.0 && roots[i] <= 1.){\n                float x_pos = -p0.x + 3. * p1.x - 3. * p2.x + p3.x;\n                x_pos = x_pos * roots[i] + 3. * p0.x - 6. * p1.x + 3. * p2.x;\n                x_pos = x_pos * roots[i] + -3. * p0.x + 3. * p1.x;\n                x_pos = x_pos * roots[i] + p0.x;\n\n                if(x_pos > uv.x){\n                    n_ints++;\n                }\n            }\n        }\n    }\n\n\treturn n_ints;\n}\n\nvec2 bez2(vec2 A, vec2 B, vec2 C, float t)\n{\n    return  mix(mix(A, B, t), \n                mix(B, C, t), t);\n}\n\nvec2 bez3(vec2 A, vec2 B, vec2 C, vec2 D, float t)\n{\n    return mix(\n            mix(mix(A, B, t), mix(B, C, t), t),\n            mix(mix(B, C, t), mix(C, D, t), t), t);\n}\n\nvec2 thirdCp(vec2 A, vec2 B, vec2 C, vec2 D, float t)\n{\n    return mix(mix(A, B, t), mix(B, C, t), t);\n}\n\nvec2 fifthCp(vec2 A, vec2 B, vec2 C, vec2 D, float t)\n{\n    return mix(mix(B, C, t), mix(C, D, t), t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y*1.5 - vec2(0.9, 0.25);\n    \n    //perturb base control points randomly\n    vec2 B300 = vec2(0.1, 0.1) + 0.05*vec2(cos(iTime), sin(iTime));\n    vec2 B210 = vec2(0.3, 0.1) + 0.05*vec2(sin(iTime*2.0), cos(iTime*2.0));\n    vec2 B120 = vec2(0.7, 0.1) + 0.05*vec2(cos(iTime*2.0), sin(iTime*2.0 + 3.14));\n    vec2 B030 = vec2(0.9, 0.1) + 0.05*vec2(sin(iTime), cos(iTime));\n    \n    vec2 B201 = vec2(0.2, 0.3) + 0.05*vec2(cos(iTime), sin(iTime));\n    vec2 B111 = vec2(0.5, 0.3) + 0.05*vec2(0.0, sin(iTime*3.0));\n    vec2 B021 = vec2(0.8, 0.3) + 0.05*vec2(cos(iTime), sin(iTime));\n   \n    vec2 B102 = vec2(0.35, 0.6) + 0.1*vec2(cos(iTime), sin(iTime));\n    vec2 B012 = vec2(0.65, 0.6) + 0.1*vec2(sin(iTime), cos(iTime));\n    \n    vec2 B003 = vec2(0.5, 0.9) + + 0.05*vec2(sin(iTime + 3.14), cos(iTime + 3.14));\n  \n    vec2 b300 = B300;\n    vec2 b210 = B210;\n    vec2 b120 = B120;\n    vec2 b030 = B030;\n    \n    vec2 b201 = B201;\n    vec2 b111 = B111;\n    vec2 b021 = B021;\n    \n    vec2 b102 = B102;\n    vec2 b012 = B012;\n    \n    vec2 b003 = B003;\n  \n    //switch for colour interpolation to texture mode\n    int mode = 0;\n    float changeTime = 2.*float(maxIterations);\n    if(mod(iTime, changeTime) > changeTime * 0.50)\n        mode = 1;\n    \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    //new control point positions\n    vec2 B300_n;\n    vec2 B210_n;\n    vec2 B120_n;\n    vec2 B030_n;\n    \n    vec2 B201_n;\n    vec2 B111_n;\n    vec2 B021_n;\n    \n    vec2 B102_n;\n    vec2 B012_n;\n    \n    vec2 B003_n;\n    \n    vec3 U = vec3(1, 0, 0);\n    vec3 V = vec3(0, 1, 0);\n    vec3 W = vec3(0, 0, 1);\n\n    int s0 = cubic_bezier_int_test(B300, B210, B120, B030, uv);\n        s0 += cubic_bezier_int_test(B030, B021, B012, B003, uv);\n        s0 += cubic_bezier_int_test(B003, B102, B201, B300, uv);\n\n    int iterations = maxIterations;\n    iterations = max(1, int(iTime) % maxIterations);\n\n    if(s0 % 2 == 1) { //first test whether uv is bound by 3 main boundary curves\n        col = vec3(1.0);\n        for(int i = 0; i < iterations; ++i) {\n            //vec2 bu0 = B300;\n            vec2 bu1 = mix(B102, B012, 0.5);\n            vec2 bu2 = bez2(B201, B111, B021, 0.5);\n            vec2 bu3 = bez3(B300, B210, B120, B030, 0.5);\n\n            col = vec3(1.0);\n\n            //split bottom curve \n            //left\n            vec2 B210_l = 0.5*(B300 + B210);\n            vec2 B120_l = 0.25 * B300 + 0.5 * B210 + 0.25 * B120;\n            //right\n            vec2 B210_r = 0.25 * B210 + 0.5 * B120 + 0.25 * B030;\n            vec2 B120_r = 0.5*(B120 + B030);\n\n\n            //we only need to check one of the halves!\n            int s_l = cubic_bezier_int_test(B300, B210_l, B120_l, bu3, uv);\n                s_l += cubic_bezier_int_test(bu3, bu2, bu1, B003, uv);\n                s_l += cubic_bezier_int_test(B003, B102, B201, B300, uv);\n\n            if(s_l % 2 == 1) {\n                //left \n                col = vec3(1.0, 0.0, 0.0);\n                \n                //rotate the triangle such that longest side becomes the one that will be split in the next iteration!\n                B300_n = B003;\n                B210_n = B102;\n                B120_n = B201;\n                B030_n = B300;\n                \n                B201_n = bu1; \n                B111_n = 0.5*(B111 + B201);\n                B021_n = B210_l;\n                \n                B102_n = bu2;\n                B012_n = B120_l;\n                \n                B003_n = bu3;\n                \n                //subdivide param\n                vec3 U2 = U;\n                vec3 V2 = 0.5 * (U + V);\n                vec3 W2 = W;\n                \n                //switcheroo\n                U = W2;\n                V = U2;\n                W = V2;\n            }\n            else {\n                //right bottom\n                col = vec3(0.0, 0.0, 1.0);\n\n                //rotate the triangle such that longest side becomes the one that will be split in the next iteration!\n                B300_n = B030;\n                B210_n = B021;\n                B120_n = B012;\n                B030_n = B003;\n                \n                B201_n = B120_r;\n                B111_n = 0.5*(B111 + B021);\n                B021_n = bu1;\n                \n                B102_n = B210_r;\n                B012_n = bu2;\n                \n                B003_n = bu3;\n\n                //subdivide param\n                vec3 U2 = 0.5*(U + V);\n                vec3 V2 = V;\n                vec3 W2 = W;\n                \n                //switcheroo                \n                U = V2;\n                V = W2;\n                W = U2;\n            }\n\n            B300 = B300_n;\n            B210 = B210_n;\n            B120 = B120_n;\n            B030 = B030_n;\n\n            B201 = B201_n; \n            B111 = B111_n;\n            B021 = B021_n;\n\n            B102 = B102_n;\n            B012 = B012_n;\n\n            B003 = B003_n;\n        }\n    }\n    \n    vec3 uvw;\n    uvw.x = U.x + V.x + W.x;\n    uvw.y = U.y + V.y + W.y;\n    uvw.z = U.z + V.z + W.z;\n    float s = uvw.x + uvw.y + uvw.z;\n    \n    vec3 tcol = 1.0/3.0*(vec3(1, 0, 0) * uvw[0] + vec3(0, 1, 0) * uvw[1] + vec3(0, 0, 1) * uvw[2]);\n    vec2 tuv = 1.0/3.0*(vec2(0, 0) * uvw[0] + vec2(1, 0) * uvw[1] + vec2(0.5, 1.) * uvw[2]);\n       \n    col = tcol;\n\n    //show control points\n    if(length(uv - b300) < 0.01) col = vec3(0.0);\n    if(length(uv - b210) < 0.01) col = vec3(0.0);\n    if(length(uv - b120) < 0.01) col = vec3(0.0);\n    if(length(uv - b030) < 0.01) col = vec3(0.0);\n    \n    if(length(uv - b201) < 0.01) col = vec3(0.0);\n    if(length(uv - b111) < 0.01) col = vec3(0.0);\n    if(length(uv - b021) < 0.01) col = vec3(0.0);\n\n    if(length(uv - b102) < 0.01) col = vec3(0.0);\n    if(length(uv - b012) < 0.01) col = vec3(0.0);\n    \n    if(length(uv - b003) < 0.01) col = vec3(0.0);\n    \n    //vec3 cg = vec3(0.45);\n    vec3 cg = vec3(1.0 - col);\n    bool showCps = false;\n    if(showCps) {\n        if(length(uv - B300) < 0.01) col = cg;\n        if(length(uv - B210) < 0.01) col = cg;\n        if(length(uv - B120) < 0.01) col = cg;\n        if(length(uv - B030) < 0.01) col = cg;\n    \n        if(length(uv - B201) < 0.01) col = cg;\n        if(length(uv - B111) < 0.01) col = cg;\n        if(length(uv - B021) < 0.01) col = cg;\n\n        if(length(uv - B102) < 0.01) col = cg;\n        if(length(uv - B012) < 0.01) col = cg;\n    \n        if(length(uv - B003) < 0.01) col = cg;\n    }\n    if(mode == 1)\n        col = textureLod(iChannel0, tuv, 0.).xyz  ;  \n        \n    \n        \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}