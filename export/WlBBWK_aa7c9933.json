{"ver":"0.1","info":{"id":"WlBBWK","date":"1600240198","viewed":92,"name":"cogito02","username":"hibit","description":"my artwork for klab2020","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Distance Function\n\n//thinking\n#define M_PI 3.1415926\n\n#define MAT_BODY 0.0\n#define MAT_FACE 1.0\n#define MAT_HAND 2.0\n#define MAT_BROW 1.0\n\n#define SUN smoothstep(-0.5, 0.5, sunDir.y)\n#define MOON smoothstep(-0.2, -0.5, sunDir.y)\n\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nfloat noise(vec2 x) {\n    vec2 i = floor(x), f = fract(x);\n\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 p) {\n\tconst mat2 m2 = mat2(0.8, -0.6, 0.6, 0.8);\n    \n    float f = 0.5000 * noise(p); p = m2 * p * 2.02;\n    f += 0.2500 * noise(p); p = m2 * p * 2.03;\n    f += 0.1250 * noise(p); p = m2 * p * 2.01;\n    f += 0.0625 * noise(p);\n    return f;\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{ \n    return (-d1.x>d2.x) ? vec2(-d1.x, d1.y): d2;\n}\n\nvec2 opSU( vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return vec2(mix( d2.x, d1.x, h ) - k*h*(1.0-h), d1.y); }\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\nvec2 thinkingFace(vec3 p)\n{\n    vec2 face = vec2(sdSphere(p, 1.0), MAT_BODY);\n    \n    vec3 q = p;\n    q.x = abs(q.x);\n    q.xz *= rot(-.3);\n    q.yz *= rot(-0.25 + 0.05 * step(0.0, p.x));\n    q.y *= 0.8;q.z *= 2.0;q.z -= 2.0;\n    vec2 eye =  vec2(sdSphere(q, .11) * 0.5, MAT_FACE);\n    \n    q = p;\n    q.x = abs(q.x);\n    q.xz *= rot(-.35);\n    q.yz *= rot(-0.62 + 0.26 * step(0.0, p.x) + pow(abs(q.x), 1.7) * 0.5);\n    q.z -= 1.0;\n    vec2 brow = vec2(sdCapsule(q, vec3(0.2, 0.0, 0.0), vec3(-.2, 0.0, 0.0), .05) * 0.5, MAT_BROW);\n\n    q = p;\n    q.yz *= rot(0.2 + pow(abs(p.x), 1.8));\n    q.xy *= rot(-0.25);\n    q.z -= 1.0;\n    vec2 mouth = vec2(sdCapsule(q, vec3(0.2, 0.0, 0.0), vec3(-.2, 0.0, 0.0), .045), MAT_BROW);\n    \n    p -= vec3(-.25, -.73, 1.0);\n    p.xy *= rot(0.2);\n    q = p;\n    q = (q * vec3(1.2, 1.0, 2.0));\n    q -= vec3(0.0, 0.01, 0.0);\n    vec2 hand = vec2(sdSphere(q, .3) * 0.5, MAT_HAND);\n    \n    q = p;\n    \n    vec2 finger1 = vec2(sdCapsule(q - vec3(0.3, 0.2, 0.02), vec3(0.2, 0.0, 0.0), vec3(-.2, 0.0, 0.0), .07), MAT_HAND);\n    vec2 finger2 = vec2(sdCapsule(q * vec3(1.2, 1.0, .8) - vec3(0.2, 0.06, 0.02), vec3(0.1, 0.0, 0.0), vec3(-.1, 0.0, 0.0), .08), MAT_HAND);\n    vec2 finger3 = vec2(sdCapsule(q * vec3(1.2, 1.0, .8) - vec3(0.15, -0.08, 0.015), vec3(0.1, 0.0, 0.0), vec3(-.1, 0.0, 0.0), .08), MAT_HAND);\n    vec2 finger4 = vec2(sdCapsule(q * vec3(1.2, 1.0, .9) - vec3(0.1, -0.2, -0.01), vec3(0.1, 0.0, 0.0), vec3(-.1, 0.0, 0.0), .08), MAT_HAND);\n    \n    p -= vec3(-0.1, 0.3, 0.0);\n    q = p;\n    q.x -= q.y * 0.7;\n\n    vec2 finger5 = vec2(sdCapsule(p, vec3(0.0, -0.2, 0.0) - q, vec3(0.0, 0.2, 0.0), .1 - p.y * 0.15), MAT_HAND);\n    vec2 finger = opU(finger1, opU(finger5, opSU(finger2, opSU(finger3, finger4, 0.035), 0.035)));\n    \n    hand = opSU(hand, finger, 0.02);\n    \n    vec2 d = opU(eye, face);\n    d = opU(brow, d);\n    d = opS(mouth, d);\n    d = opU(hand, d);\n    return d;\n}\n//\n\nvec3 trans(vec3 p){\n    return mod(p, 5.0) - 2.0;\n}\n\nfloat sphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat map(vec3 p) {\n\tfloat s = sphere(p, 0.5);\n    float pl = p.y + 0.25;\n    float d = min(s, pl);\n    return d;\n}\n\nvec4 qmul(vec4 a, vec4 b) {\n    return vec4(\n        a.x * b.x - a.y * b.y - a.z * b.z - a.w * b.w,\n        a.x * b.y + a.y * b.x - a.z * b.w + a.w * b.z,\n        a.x * b.z + a.y * b.w + a.z * b.x - a.w * b.y,\n        a.x * b.w - a.y * b.z + a.z * b.y + a.w * b.x\n    );\n}\n\n#define ITERATIONS 32\nvec2 deMandelbulb(vec3 p, float power) {\n    vec3 z = p;\n    float dr = 2.0;\n    float r;\n    float cnt;\n    for (int i = 0; i < ITERATIONS; i++) {\n        r = length(z);\n        if (r > 10.0) break;\n        float theta = acos(z.y / r);\n        float phi = atan(z.z, z.x);\n        dr = pow(r, power - 1.0) * power * dr + 1.0;\n\n        float zr = pow(r, power);\n        theta = theta * power;\n        phi = phi * power;\n\n        z = zr * vec3(sin(theta) * cos(phi), cos(theta), sin(theta) * sin(phi));\n        z += p;\n        cnt = float(i);\n    }\n    return vec2(1.0 * log(r) * r / dr, cnt);\n}\n\nvec2 dep(vec3 p) {\n    return deMandelbulb(trans(p), 1.5+iTime/10.0);\n}\n\nvec2 de(vec3 p){\n    return deMandelbulb(p, 1.5+iTime/10.0);\n}\n\nvec3 CreateRay(vec2 p, vec3 cameraPos, vec3 cameraTarget, float fov) {\n    vec3 forward = normalize(cameraTarget - cameraPos);\n    vec3 side = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = normalize(cross(forward, side));\n    return normalize(forward * fov + side * p.x + up * p.y);\n}\n\nvec3 spectrum(float s){\n    s = mod(s,3.0);\n    vec3 ans;\n    if(s == 0.0){\n        ans = vec3(1.0,1.0,0.4);\n    }\n    if(s == 1.0){\n        ans = vec3(0.3,0.3,0.3);\n    }\n    if(s == 2.0){\n        ans = vec3(1.0,0.5,0.2);\n    }\n    return ans;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    //カメラの位置\n    vec3 cameraPos;\n    cameraPos = vec3(3.0,3.0,3.0);\n    if(iTime > 10.0){\n        cameraPos = vec3(3.0,3.0,iTime-7.0);\n    }\n    if(iTime > 21.0){\n        cameraPos = vec3(0.0,0.0,-5.0); \n    }\n    \n    // カメラの注視点\n    vec3 cameraTarget = vec3(0.0);\n    if(iTime > 21.0){\n        cameraPos = vec3(0.0,0.0,5.0);\n    }\n    \n    // シェーディングピクセルのカメラからシーンへのレイ\n    vec3 ray = CreateRay(p, cameraPos, cameraTarget, 2.5);\n\n\t// レイマーチング\n    float t = 0.01;\n    vec3 col = vec3(0.0);\n    for(int i=0; i<256; i++) {\n    \tvec3 pos = cameraPos + ray * t;\n        vec2 d = dep(pos);\n        if(iTime > 21.0) d = de(pos);\n        if(iTime > 40.0){\n            float dt = iTime - 40.0;\n            dt = dt*dt/40.0;\n            float rate1 = 1.0;\n            float rate2 = dt*dt/16.0;\n            d = rate1*de(pos) + rate2*thinkingFace(pos);\n        }\n        if(iTime > 45.0){\n            d = thinkingFace(pos);\n        } \n        if (d.x < 0.001) {\n            // マテリアル毎に色を決定\n            vec3 c;\n            c = spectrum(d.y);\n        \tcol = vec3(1.0 - float(i) / 70.) * c;\n            break;\n        }\n        t += d.x;\n    } \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}