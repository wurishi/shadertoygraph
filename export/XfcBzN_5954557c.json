{"ver":"0.1","info":{"id":"XfcBzN","date":"1732753721","viewed":184,"name":"pink jellyfish","username":"aoakenfo","description":"jellyfish","likes":15,"published":3,"flags":0,"usePreview":0,"tags":["jellyfish"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define MAX_RAYMARCHING_COUNT 200\n#define PRECISION 0.001\n#define FAR 30.\n#define mouse (iMouse.xy / iResolution.xy)\n#define time (iTime + 4.4)\n\n// Global variables\nvec3 ro, rd;\n\n// Main data structure\nstruct Hit {\n    float d;            // Distance\n    vec2 uv;           // UV coordinates\n    vec3 col;          // Color\n    float ref;         // Reflection\n    float spe;         // Specular\n    float rough;       // Roughness\n    float lightD;      // Light distance\n    vec3 lightCol;     // Light color\n    float lightStrength;// Light intensity\n    float sss;         // Subsurface scattering\n    float diffuseTex;  // Diffuse texture\n};\n\n//------------------------ Utility Functions ------------------------\n\n// Tri-Planar blending function\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n) {\n    n = max(n*n, 0.001);\n    n /= (n.x + n.y + n.z);\n    return (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n//------------------------ Noise Functions ------------------------\n\nconst mat2 m = mat2(1.6, 1.2, -1.2, 1.6);\n\nvec3 hash(vec3 p) {\n    p = vec3(\n        dot(p, vec3(127.1, 311.7, 74.7)),\n        dot(p, vec3(269.5, 183.3, 246.1)),\n        dot(p, vec3(113.5, 271.9, 124.6))\n    );\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat hash(float n) { \n    return fract(sin(n)*753.5453123); \n}\n\nfloat noise(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    vec3 u = f*f*(3.0-2.0*f);\n\n    return mix(\n        mix(\n            mix(dot(hash(i + vec3(0,0,0)), f - vec3(0,0,0)),\n                dot(hash(i + vec3(1,0,0)), f - vec3(1,0,0)), u.x),\n            mix(dot(hash(i + vec3(0,1,0)), f - vec3(0,1,0)),\n                dot(hash(i + vec3(1,1,0)), f - vec3(1,1,0)), u.x),\n            u.y),\n        mix(\n            mix(dot(hash(i + vec3(0,0,1)), f - vec3(0,0,1)),\n                dot(hash(i + vec3(1,0,1)), f - vec3(1,0,1)), u.x),\n            mix(dot(hash(i + vec3(0,1,1)), f - vec3(0,1,1)),\n                dot(hash(i + vec3(1,1,1)), f - vec3(1,1,1)), u.x),\n            u.y),\n        u.z\n    );\n}\n\n//------------------------ SDF Primitives ------------------------\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    return length(pa - ba*h) - r;\n}\n\n//------------------------ SDF Primitives ------------------------\n\nfloat sdPlane(vec3 p, vec4 n) {\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\n}\n\n//------------------------ SDF Operations ------------------------\n\nfloat opUnion(float d1, float d2) { \n    return min(d1, d2); \n}\n\nfloat opSubtraction(float d1, float d2) { \n    return max(-d1, d2); \n}\n\nfloat opIntersection(float d1, float d2) { \n    return max(d1, d2); \n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5*(d2+d1)/k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k*h*(1.0-h); \n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k*h*(1.0-h); \n}\n\n//------------------------ Hit Operations ------------------------\n\nHit mixHit(Hit h1, Hit h2, float dres) {\n    float factor = (dres - h1.d)/(h2.d - h1.d);\n    return Hit(\n        dres,                                           // distance\n        mix(h1.uv, h2.uv, factor),                     // UV\n        mix(h1.col, h2.col, factor),                   // color\n        mix(h1.ref, h2.ref, factor),                   // reflection\n        mix(h1.spe, h2.spe, factor),                   // specular\n        mix(h1.rough, h2.rough, factor),               // roughness\n        mix(h1.lightD, h2.lightD, factor),             // light distance\n        mix(h1.lightCol, h2.lightCol, factor),         // light color\n        mix(h1.lightStrength, h2.lightStrength, factor),// light strength\n        mix(h1.sss, h2.sss, factor),                   // subsurface scattering\n        mix(h1.diffuseTex, h2.diffuseTex, factor)      // diffuse texture\n    );\n}\n\nHit opUnion(Hit h1, Hit h2) {\n    float dres = opUnion(h1.d, h2.d);\n    return mixHit(h1, h2, dres);\n}\n\nHit opSubtraction(Hit h1, Hit h2) {\n    float dres = opSubtraction(h1.d, h2.d);\n    return mixHit(h1, h2, dres);\n}\n\nHit opSmoothUnion(Hit h1, Hit h2, float k) {\n    float dres = opSmoothUnion(h1.d, h2.d, k);\n    return mixHit(h1, h2, dres);\n}\n//------------------------ Space Manipulation ------------------------\n\nfloat volumeLight(vec3 p, vec3 lightPosition) {\n    float result = 0.0;\n    float steps = 8.0;\n    for(float i = 0.0; i < steps; i++) {\n        vec3 pos = p + normalize(lightPosition - p) * (i / steps);\n        result += noise(pos * 2.0 + time) * (1.0 - i / steps);\n    }\n    return result / steps;\n}\n\nvec3 caustics(vec3 p) {\n    float t = iTime * 0.5;\n    float n = noise(p * 2.0 + t);\n    n += 0.5 * noise(p * 4.0 - t);\n    n += 0.25 * noise(p * 8.0 + t);\n    \n    // Return a color instead of just the noise value\n    return vec3(0.1, 0.2, 0.3) * n;\n}\n\nvec3 circleClone(vec3 p, float num, out float id) {\n    vec3 pp = p;\n    float angleArea = PI * 2.0 / num;\n    float originangle = atan(pp.x, pp.z);\n    float angle = mod(originangle, angleArea) - angleArea * 0.5;\n    id = floor(originangle / angleArea);\n    \n    // Add movement\n    float shake = cos(pp.y * 2.0 + time * 2.0 + id) * 0.2;\n    pp.xz += normalize(pp.xz) * shake * smoothstep(-0.3, -1.0, pp.y);\n    float len = length(pp.xz);\n    \n    return vec3(cos(angle) * len, p.y, sin(angle) * len);\n}\n\n// Tentacle parameter structure\nstruct TentacleParams {\n    float radius;\n    float length;\n    vec3 basePos;\n    vec3 tipOffset;\n    float waveSpeed;\n    float waveAmp;\n};\n\n// Helper function for tentacle wave motion\nvec3 applyTentacleWave(vec3 pos, float id, float t) {\n    pos.x += sin(pos.y * 2.0 + t) * 0.1;\n    pos.z += cos(pos.y * 2.0 + t + id) * 0.1;\n    return pos;\n}\n\n// Calculate tentacle radius with variations\nfloat calculateTentacleRadius(float baseRadius, float id, vec3 pos, float t) {\n    float radius = baseRadius + sin(id) * 0.008;\n    radius *= 1.0 + 0.2 * sin(t * 3.0 + id);\n    radius *= 1.0 + 0.1 * sin(pos.y * 4.0 + t);\n    return radius;\n}\n\nfloat primaryTentacles(vec3 p, float radius, float id) {\n    \n    // Base parameters\n    float baseRadius = 0.15;      // slightly thicker\n    float baseLength = -4.1;\n    vec3 basePos = vec3(radius - 0.25, 0.0, 0.0);\n    \n    // Get tentacle position\n    vec3 modPos = circleClone(p, 5.0, id);\n    \n    // Smooth wave motion\n    float wave = smoothstep(-1.0, 1.0, sin(modPos.y * 2.0 + time));\n    modPos.x += wave * 0.1;\n    modPos.z += wave * cos(id) * 0.1;\n    \n    // Calculate radius with smooth variations\n    float tentacleRadius = baseRadius;\n    tentacleRadius *= 1.0 + 0.1 * smoothstep(-1.0, 1.0, sin(time * 2.0 + id));\n    tentacleRadius *= smoothstep(-baseLength, 0.0, modPos.y) * 0.8 + 0.2; // taper\n    \n    float d = sdCapsule(\n        modPos,\n        basePos,\n        basePos + vec3(0.0, baseLength, 0.0),\n        tentacleRadius\n    );\n    \n    // Soften the distance field\n    return d ; // Scale down the distance field for softer blending\n}\nfloat secondaryTentacles(vec3 p, float radius, float id) {\n    vec3 modPos = circleClone(p, 100.0, id);  // id gets set here\n    float tentacleLength = -1.5 + sin(id * 2.0 + time) * 1.0;\n\n    TentacleParams params = TentacleParams(\n        0.01,                   // base radius\n        tentacleLength,         // more dramatic length variation\n        vec3(radius - 0.25, 0.0, 0.0),  // base position\n        vec3(0.0, 0.0, 0.0),   // tip offset\n        1.5,                    // wave speed\n        0.3                     // wave amplitude\n    );\n    \n    float tentaclesRadius = calculateTentacleRadius(params.radius, id, modPos, time);\n    \n    return 0.5 * sdCapsule(\n        modPos,\n        params.basePos,\n        params.basePos + vec3(0.0, params.length, 0.0),\n        tentaclesRadius\n    );\n}\n\n// Inner tentacles\nfloat innerTentacles(vec3 p, out float id) {\n    vec3 pic = circleClone(p, 13.0, id);  // id gets set here\n    float thickness = 0.1 * smoothstep(-2.2, -1.0, pic.y);\n    \n    return 0.5 * sdCapsule(\n        pic,\n        vec3(0.55, 0.0, 0.0),\n        vec3(0.55, -6.0, 0.0),\n        thickness\n    );\n}\n\n// Main tentacle system function that combines all tentacle types\nfloat tentacleSystem(vec3 p, float radius, float mainDist) {\n    float id1, id2, id3;  // separate ids for each tentacle type\n    float d = mainDist;\n    \n    // Add primary tentacles\n    float primaryDist = primaryTentacles(p, radius, id1);\n    d = opSmoothUnion(d, primaryDist, 0.43);\n    \n    // Add secondary tentacles\n    float secondaryDist = secondaryTentacles(p, radius, id2);\n    d = opSmoothUnion(d, secondaryDist, 0.1);\n    \n    // Add inner tentacles\n    float innerDist = innerTentacles(p, id3);\n    d = opSmoothUnion(d, innerDist, 0.2);\n    \n    return d;\n}\n\n// Then in your jellyfish function, replace the tentacle section with:\nHit jellyfish(vec3 p) {\n    vec3 backupPos = p;\n    float shake = sin(p.y * 2.0 + time * 3.6) * 0.2;\n    p.xz += normalize(p.xz) * shake;\n\n    float radius = 1.9;  // increased from 1.5\n    \n    // Main Hat (adjust scales accordingly)\n    vec3 noiseScale = vec3(8.0, 0.2, 8.0);\n    noiseScale.xz -= smoothstep(0.2, -radius, p.y) * 3.0;\n    float noiseAmp = 0.9 \n        * smoothstep(0.6, -radius * 0.3, p.y) \n        * smoothstep(-0.9, 0.3, shake);\n    float n = noise(normalize(p) + time * 0.5);\n    float d = length(p * vec3(1.0, 1.4, 1.0)) - radius;\n    d = max(d, -sdBox(p + vec3(0.0, 2.0, 0.0), vec3(100.0, 0.5, 100.0)));\n    d += n * noiseAmp;\n    d *= 0.17;\n    \n    // Add all tentacles\n    d = tentacleSystem(p, radius, d);\n    \n    // Different Material Info\n    float originD = d;\n    float factor = smoothstep(-radius*0.7, radius*0.8, backupPos.y);\n    \n    vec3 col0 = mix(vec3(0.37, 0.73, 0.88), vec3(0.117, 0.145, 0.317), factor);\n    vec3 col1 = mix(vec3(0.89, 0.31, 0.145), vec3(0.8, 0.31, 0.5), \n                    smoothstep(-1.0, 0.0, backupPos.y));\n    vec3 col = mix(col0, col1, factor);\n    \n    return Hit(d, vec2(0.0), col, 0.7, 1.0, 0.0, d, vec3(1.0), 1.0, 0.4, 1.0);\n}\n\nHit map2(vec3 p) {\n    Hit jellyfishHit = jellyfish(p);\n    \n    return jellyfishHit;\n}\n//------------------------ Normal Calculation ------------------------\n\nvec3 calcuNormal(in vec3 p) {  \n    vec2 e = vec2(-1., 1.) * 0.001;   \n    return normalize(\n        e.yxx * map2(p + e.yxx).d + \n        e.xxy * map2(p + e.xxy).d + \n        e.xyx * map2(p + e.xyx).d + \n        e.yyy * map2(p + e.yyy).d\n    );   \n}\n\n//------------------------ Lighting & Shadows ------------------------\n\nfloat calcSoftshadow(in vec3 ro, in vec3 rd, float mint, float tmax) {\n    float res = 1.0;\n    float t = mint;\n    \n    for(int i = 0; i < 16; i++) {\n        float h = map2(ro + rd*t).d;\n        res = min(res, 5.0*h/t);\n        t += clamp(h, 0.02, 0.2);\n        if(h < 0.001 || t > tmax) break;\n    }\n    \n    return clamp(res, 0.2, 1.0);\n}\n//------------------------ Ambient Occlusion ------------------------\n\nfloat calcAO(in vec3 pos, in vec3 nor) {\n    float occ = 0.0;\n    float sca = 1.0;\n    \n    for(int i = 0; i < 5; i++) {\n        float hr = 0.01 + 0.12 * float(i)/4.0;\n        vec3 aopos = nor * hr + pos;\n        float dd = map2(aopos).d;\n        occ += -(dd-hr) * sca;\n        sca *= 0.95;\n    }\n    \n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);    \n}\n\n//------------------------ Thickness Calculation ------------------------\n\nfloat calcThickness(in vec3 pos, in vec3 nor) {\n    float occ = 0.0;\n    float sca = 1.0;\n    \n    for(int i = 0; i < 5; i++) {\n        float hr = 0.01 + 0.12 * float(i)/4.0;\n        vec3 aopos = nor * hr + pos;\n        float dd = -map2(aopos).d;\n        occ += -(dd-hr) * sca;\n        sca *= 0.95;\n    }\n    \n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);    \n}\n\n//------------------------ Main Shading Function ------------------------\n\nvec4 shading(vec3 sp, Hit hitdata, vec3 bgCol, float t) {\n    // Initialize color\n    vec3 col = vec3(0.0);\n    \n    // Light setup\n    vec3 lightPos = vec3(0.0, 0.25, 0.0);\n    vec3 lightColor = vec3(0.98, 0.76, 0.58) * (7.0 + sin(time * 3.6) * 4.0);\n    vec3 sundir = lightPos - sp;\n    float distToLight = length(sundir);\n    vec3 lightDir = normalize(sundir);\n    \n    // Surface properties\n    vec3 normal = normalize(calcuNormal(sp));\n    float shadow = calcSoftshadow(sp, lightDir, 0.02, FAR);\n    float occlusion = calcAO(sp, normal);\n    float thickness = calcThickness(sp - normal * 0.01, lightDir);\n    float fresnel = 0.0 + 1.0 * pow(1.0 - max(dot(-rd, normal), 0.0), 2.0);\n\n    // Lighting calculations\n    vec3 halfVector = normalize(lightPos - rd);\n    float ambient = clamp(0.3 + 0.7 * normal.y, 0.0, 1.0);\n    float diffuse = max(dot(lightDir, normal), 0.0);\n    float specular = pow(clamp(dot(normal, halfVector), 0.0, 1.0), 12.0);\n    float backLight = clamp(dot(normal, normalize(vec3(lightPos.x, -lightPos.y, lightPos.z))), 0.0, 1.0);\n\n    // Surface color calculation\n    float sampleCol = tex3D(iChannel0, sp, normal).g;\n    vec3 skinColor = vec3(0.4, 0.35, 0.2);\n    col = mix(hitdata.col, skinColor, sampleCol + hitdata.diffuseTex);\n    \n    // Lighting composition\n    vec3 lighting = lightColor * diffuse * shadow;\n    lighting += hitdata.spe * specular * lightColor * shadow;\n    lighting += 0.3 * ambient * vec3(1.0);\n    lighting += 0.3 * backLight * vec3(1.0);\n    col *= lighting * occlusion;\n    // Subsurface scattering\n    float sss = (1.0 - thickness) * hitdata.sss / (0.0001 + pow(distToLight, 2.0));\n    col = mix(col, lightColor * hitdata.col, sss);\n\n    // Head area limitation\n    float limitHead = smoothstep(-0.5, 0.0, sp.y);\n\n    // Reflections\n    vec3 reflection = reflect(rd, normal);\n    col += texture(iChannel1, reflection).xyz * hitdata.ref * fresnel * limitHead;\n\n    // Outline glow effect\n    vec3 outlineCol = vec3(1.5, 1.1, 1.0) * 2.0;\n    col += pow(fresnel, 5.0) * limitHead * outlineCol;\n    \n    // Add volume lighting\n    float volLight = volumeLight(sp, lightPos);\n    col += volLight * vec3(0.2, 0.3, 0.4) * 0.3;\n\n    // Add caustics\n    vec3 causticsColor = caustics(sp);\n    col = col + (causticsColor * limitHead * 0.2);\n    \n    return vec4(col, hitdata.lightStrength);\n}\n\n//------------------------ Ray Marching Render ------------------------\n\nvec4 render(vec3 ro, vec3 rd) {\n    Hit hitdata;\n    float t = 0.0;\n    vec4 col = vec4(0.0);\n    vec3 bgCol = vec3(0.05);\n    float fresnel = 1.0;\n    \n    for (int i = 0; i < MAX_RAYMARCHING_COUNT; i++) {\n        vec3 p = ro + rd * t;\n        hitdata = map2(p);\n        \n        float prec = PRECISION * (1.0 + t * 0.1);\n        \n        if (hitdata.d < prec) {\n            vec4 shadingCol = shading(p, hitdata, bgCol, t);\n            col = mix(col, shadingCol, fresnel);\n            break;\n        }\n        \n        t += max(hitdata.d * 0.5, prec); // Slower stepping\n        if(t > FAR) break;\n    }\n    \n    return col;\n}\n\n//------------------------ Camera Setup ------------------------\n\nmat3 setCamera(vec3 ro, vec3 lookAt, vec3 cp) {\n    vec3 cw = normalize(lookAt - ro);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    float dist = 15.0;\n    \n    float theta = time * 0.3;\n    float phi = sin(time * 0.2) * 0.5 + 0.25;\n    \n    ro = vec3(\n        dist * sin(theta) * cos(phi),\n        dist * sin(phi),\n        dist * cos(theta) * cos(phi)\n    );\n    \n    vec3 lookAt = vec3(0.0, -1.0, 0.0);\n    vec3 camup = vec3(0.0, 1.0, 0.0);\n    \n    mat3 viewMat = setCamera(ro, lookAt, camup);\n    rd = viewMat * normalize(vec3(p, 2.0));\n    \n    vec4 col = render(ro, rd);\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}