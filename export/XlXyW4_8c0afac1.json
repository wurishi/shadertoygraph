{"ver":"0.1","info":{"id":"XlXyW4","date":"1504735893","viewed":155,"name":"MusicCube","username":"flerovium","description":"Some shader experiments - tried some stuff I was very excited about! I'm kinda new to this stuff.\nDidn't bother to optimize it really :D\n\nMusic: Foria - Break Away, provided by NoCopyrightSounds!","likes":1,"published":1,"flags":96,"usePreview":0,"tags":["visualization","music","audio","shader","dynamic","react"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 getImagePixel(sampler2D img, vec2 pos, vec2 resolution) {\n\treturn texture(img, pos / resolution);\n}\n\nvec4 getImagePixelBlurred(sampler2D img, vec2 pos, vec2 resolution, int radius) {\n    float scale = 0.0;\n    vec4  color = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    for (int wY = -radius; wY < radius; wY++) {\n        for (int wX = -radius; wX < radius; wX++) {\n            vec2  wPos = pos + vec2(wX, wY);\n            float dist = distance(pos, wPos) / float(radius);\n            \n            if (dist <= float(radius)) {\n        \t\tfloat factor = 1.0 - sqrt(dist);\n                \n                color += getImagePixel(img, wPos, resolution) * factor;\n                scale += factor;\n            }\n    \t}\n    }\n    \n    return color / scale;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 halfRes = iResolution.xy * 0.5;\n    \n    if (distance(fragCoord, halfRes) >= halfRes.y* 0.95) {\n        fragColor = vec4(1.0);\n    } else {\n    \tfragColor = getImagePixelBlurred(iChannel0, fragCoord, iResolution.xy, 2);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XssXWX","filepath":"https://soundcloud.com/nocopyrightsounds/foria-break-away-ncs-release","previewfilepath":"https://soundcloud.com/nocopyrightsounds/foria-break-away-ncs-release","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// rect has following layout:\n// a -- b\n// |    |\n// c -- d\nstruct rect2_t {\n\tvec2 a;\n    vec2 b;\n    vec2 c;\n    vec2 d;\n};\nstruct rect3_t {\n\tvec3 a;\n    vec3 b;\n    vec3 c;\n    vec3 d;\n    vec2 rot;\n};\n\nbool vec2eq(vec2 a, vec2 b) {\n    float sigma = 0.03;\n    \n    float aX1 = a.x - sigma;\n    float aX2 = a.x + sigma;\n    float aY1 = a.y - sigma;\n    float aY2 = a.y + sigma;\n    \n    return b.x >= aX1 && b.x <= aX2 &&\n           b.y >= aY1 && b.y <= aY2;\n}\n\nbool intersectsLine(vec2 lineDot1, vec2 lineDot2, vec2 testDot) {\n    vec2 v1 = lineDot2 - lineDot1;\n    vec2 v2 = testDot  - lineDot1;\n    \n    vec2 v1n = normalize(v1);\n    vec2 v2n = normalize(v2);\n    vec2 vtest = lineDot1;\n    \n    float tMax = length(v1);\n    \n    if (length(v2) > tMax || length(v2) < 0.0) return false;\n    \n    return vec2eq(v1n, v2n);\n}\n\nvec3 rotateVec3(vec3 a, vec2 rot) {\n    vec3 ret;\n    vec3 ret2;\n    \n    // x-Rotation\n    ret.y = a.y * cos(rot.x) - a.z * sin(rot.x);\n    ret.z = a.y * sin(rot.x) + a.z * cos(rot.x);\n    \n    // y-Rotation\n    ret2.y = ret.y;\n    ret2.z = ret.z * cos(rot.y) - a.x * sin(rot.y);\n    ret2.x = ret.z * sin(rot.y) + a.x * cos(rot.y);\n    \n    return ret2;\n}\n\nbool isRectPoint(rect3_t rect, vec2 fragCoord) {\n    rect2_t rect2;\n    \n    vec2 aspect  = iResolution.yy * 0.5; // fix aspect ratio\n    vec2 halfRes = iResolution.xy * 0.5;\n    \n    vec3 _a = rotateVec3(rect.a, rect.rot);\n    vec3 _b = rotateVec3(rect.b, rect.rot);\n    vec3 _c = rotateVec3(rect.c, rect.rot);\n    vec3 _d = rotateVec3(rect.d, rect.rot);\n    \n    rect2.a = (_a.xy / (1.0 + _a.z)) * aspect + halfRes;\n    rect2.b = (_b.xy / (1.0 + _b.z)) * aspect + halfRes;\n    rect2.c = (_c.xy / (1.0 + _c.z)) * aspect + halfRes;\n    rect2.d = (_d.xy / (1.0 + _d.z)) * aspect + halfRes;\n    \n    return intersectsLine(rect2.a, rect2.b, fragCoord) ||\n           intersectsLine(rect2.a, rect2.c, fragCoord) ||\n           intersectsLine(rect2.c, rect2.d, fragCoord) ||\n           intersectsLine(rect2.b, rect2.d, fragCoord);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    rect3_t r1, r2, r3, r4;\n    vec2 center = iResolution.xy * 0.5;\n    \n    float impulsePoint1 = 1.0 / 512.0;\n    float impulsePoint2 = 2.0 / 512.0;\n    \n    float impulse1 =   0.5 * texture(iChannel0, vec2(impulsePoint1, 0.0)).r;\n                     + 0.5 * texture(iChannel0, vec2(impulsePoint1, 1.0)).r;\n    \n    float impulse2 =   0.5 * texture(iChannel0, vec2(impulsePoint2, 0.0)).r;\n                     + 0.5 * texture(iChannel0, vec2(impulsePoint2, 1.0)).r;\n    \n    float speed1 = (iTime * 0.15) + cos(impulse2*impulse2) * iTime * 0.025;\n    float speed2 = (iTime * 0.09) + cos(impulse2*impulse2) * iTime * 0.025;\n    \n    vec2 rot = vec2(cos(speed1*0.5), sin(speed2*0.5));\n    \n    float size = 0.25 + sin(impulse1*impulse1)*0.55;\n    \n    vec3 disp = vec3(sin(iTime*0.2)*0.15);\n    \n    // Front Face\n    r1.a = vec3(-size,  size, -size) + disp;\n    r1.b = vec3( size,  size, -size) + disp;\n    r1.c = vec3(-size, -size, -size) + disp;\n    r1.d = vec3( size, -size, -size) + disp;\n    r1.rot = rot;\n    \n    // Back Face\n    r2.a = vec3(-size,  size, size) + disp;\n    r2.b = vec3( size,  size, size) + disp;\n    r2.c = vec3(-size, -size, size) + disp;\n    r2.d = vec3( size, -size, size) + disp;\n    r2.rot = rot;\n    \n    // Left Face\n    r3.a = vec3(-size,  size, -size) + disp;\n    r3.b = vec3(-size,  size,  size) + disp;\n    r3.c = vec3(-size, -size, -size) + disp;\n    r3.d = vec3(-size, -size,  size) + disp;\n    r3.rot = rot;\n    \n    // Right Face\n    r4.a = vec3( size,  size, -size) + disp;\n    r4.b = vec3( size,  size,  size) + disp;\n    r4.c = vec3( size, -size, -size) + disp;\n    r4.d = vec3( size, -size,  size) + disp;\n    r4.rot = rot;\n    \n    if (isRectPoint(r1, fragCoord) || \n        isRectPoint(r2, fragCoord) ||\n        isRectPoint(r3, fragCoord) ||\n        isRectPoint(r4, fragCoord)) \n    {\n        fragColor = vec4(1.0);\n        return;\n    }\n    \n    fragColor = vec4(0.0);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec4 getImagePixel(sampler2D img, vec2 pos, vec2 resolution) {\n\treturn texture(img, pos / resolution);\n}\n\nvec4 getImagePixelBlurred(sampler2D img, vec2 pos, vec2 resolution, int radius) {\n    float scale = 0.0;\n    vec4  color = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    for (int wY = -radius; wY < radius; wY++) {\n        for (int wX = -radius; wX < radius; wX++) {\n            vec2  wPos = pos + vec2(wX, wY);\n            float dist = distance(pos, wPos) / float(radius);\n            \n            if (dist <= float(radius)) {\n        \t\tfloat factor = 1.0 - sqrt(dist);\n                \n                color += getImagePixel(img, wPos, resolution) * factor;\n                scale += factor;\n            }\n    \t}\n    }\n    \n    return color / scale;\n}\n\nvec4 makeBackground(vec2 uv) {\n    float yTrans = sin(uv.y * 3.1415 * 0.5);\n    \n    float bgBegin = 0.80;\n    float bgEnd   = 1.00;\n    float bgDiff  = bgEnd - bgBegin;\n    float bgFinal = bgBegin + yTrans * bgDiff;\n    \n    return vec4(bgFinal, bgFinal, bgFinal, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv   = fragCoord.xy / iResolution.xy;\n    vec4 epic = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    vec4 cube = getImagePixelBlurred(iChannel0, fragCoord, iResolution.xy, 2);\n    \n    fragColor = mix(makeBackground(uv), epic*1.8*cube, cube.w);\n}","name":"Buf B","description":"","type":"buffer"}]}