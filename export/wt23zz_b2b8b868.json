{"ver":"0.1","info":{"id":"wt23zz","date":"1558360518","viewed":1008,"name":"Perlin Noise Explained","username":"DanielMz25","description":"Shader of perlin noise and auxiliary scripts to explain how perlin noise works.\nIt's not original perlin noise algorithm. It uses array of diagonal gradient vectors instead of random and cosinus interpolation.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["perlinnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec2 gradients[4] = vec2[4](\n    vec2(1.0,1.0),vec2(1.0,-1.0),\n    vec2(-1.0,-1.0),vec2(-1.0,1.0));\n\nconst float pi = 3.141592653589793238462643383279502884157169399375105820974944592307816406286208998628034825342117067982148086513282;\n\nconst vec3 rainbowColors[6] = vec3[6](\n    vec3(1.0,0.0,0.0),vec3(1.0,0.5,0.0),vec3(1.0,1.0,0.0),\n    vec3(0.0,0.75,0.0),vec3(0.0,0.75,1.0),vec3(0.5,0.0,1.0));\n    \nfloat hash(vec2 v)\n{\n    float h = v.x * 1.0071 + v.y * 0.9873;\n    h = fract((h+0.00103)*v.x*0.927) + fract((h+0.0010421)*v.y*1.0219);\n    h = fract(h*2184.72427142 + 1.732);\n    h = fract(h * 21982.623632 + 4.637235);\n    return h;\n}\n\nfloat sFac(float f)\n{\n    return 0.5-cos(clamp(f,0.0, 1.0)*pi)*0.5;\n}\n\nfloat aastep(float x, float y, float px)\n{\n\treturn clamp(y-x,0.0,1.0/px)*px;\n}\n\nfloat grid(vec2 uv, vec2 size)\n{\n\tvec2 uv0 = floor(uv);\n    \n    return aastep(uv.x - uv0.x, size.x, 40.0)\n         + aastep(1.0 + uv0.x - uv.x, size.x, 40.0)\n         + aastep(uv.y - uv0.y, size.y, 40.0)\n         + aastep(1.0 + uv0.y - uv.y, size.y, 40.0);\n}\n\nfloat vector(vec2 v0, vec2 v, vec2 uv, float dotSize, float lineWidth)\n{\n    lineWidth *= 0.7;\n    v *= 0.45;\n    \n    vec2 v1 = uv - v0;\n    float v1Len = length(v1);\n    \n    float dotVal = aastep(v1Len, dotSize, 40.0);\n    \n    vec2 vDot = vec2(dot(v1,v) , dot(vec2(-v.y,v.x),v1));\n    \n    float vecVal = aastep(vDot.x,0.0,40.0)*aastep(abs(vDot.y), lineWidth, sqrt(2.0)*40.0)*aastep(v1Len, length(v), 40.0);\n        \n    return max(dotVal, vecVal);\n}\n\nfloat gradient(vec2 v0, vec2 v, vec2 uv)\n{\n    vec2 v1 = v0 - uv;   \n    return dot(v1,v);\n}\n\nfloat pNoiseTransition(vec2 uv)\n{\n    //calculate positions of quad corners\n    vec2 v0 = floor(uv);\n    vec2 v2 = v0 + 1.0;\n    vec2 v1 = vec2(v2.x, v0.y);\n    vec2 v3 = vec2(v0.x, v2.y);\n    \n    //calculate colors of gradient for four vectors\n\tfloat g0 = gradient(v0, gradients[int(hash(v0)*4.0)], uv);\n\tfloat g1 = gradient(v1, gradients[int(hash(v1)*4.0)], uv);\n    float g2 = gradient(v2, gradients[int(hash(v2)*4.0)], uv);\n    float g3 = gradient(v3, gradients[int(hash(v3)*4.0)], uv);\n    \n    //calculate x and y distance to interpolate between four gradients\n    vec2 fac = uv-v0;\n\n    //calculate transition between gradients view and noise view.\n    float transition = (clamp(sin(iTime)*0.5+0.5,0.3,0.7)-0.3)/0.4;\n    \n    //use transition to calculate final mix curve.\n    //(stretch fac relative to 0.5, from normal - 1.0 scale, for noise, to 32.0 for gradients view)\n    fac = (fac-0.5)*pow(32.0,transition)+0.5;\n    \n    //use clamped cosine interpolation to get smoothed step for gradient\n    //and smooth transition for noise view\n    fac = vec2(sFac(fac.x),sFac(fac.y));\n    \n    //Use fac.x to mix gradients in x\n    float g01 = mix(g0,g1,fac.x);\n    float g23 = mix(g3,g2,fac.x);\n    \n    //Use fac.y to mix gradients in y (already mixed in x)\n    float g = mix(g01,g23,fac.y);\n    \n    //Move result from <-0.5,0.5> range to <0.0,1.0>\n    return g*0.5+0.5;\n}\n\nfloat pNoise(vec2 uv)\n{\n    vec2 v0 = floor(uv);\n    vec2 v2 = v0 + 1.0;\n    vec2 v1 = vec2(v2.x, v0.y);\n    vec2 v3 = vec2(v0.x, v2.y);\n    \n\tfloat g0 = gradient(v0, gradients[int(hash(v0)*4.0)], uv);\n\tfloat g1 = gradient(v1, gradients[int(hash(v1)*4.0)], uv);\n    float g2 = gradient(v2, gradients[int(hash(v2)*4.0)], uv);\n    float g3 = gradient(v3, gradients[int(hash(v3)*4.0)], uv);\n    \n    vec2 fac = uv-v0;\n    fac = vec2(sFac(fac.x),sFac(fac.y));\n    \n    float g01 = mix(g0,g1,fac.x);\n    float g23 = mix(g3,g2,fac.x);\n    \n    float g = mix(g01,g23,fac.y);\n    \n    return g*0.5+0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/50.0 + 2.0*iTime*0.1;\n\n    //grid and vectors alpha (1.0 - transparency)\n    float transition = (clamp(sin(iTime*0.5)*0.25+0.5,0.3,0.7)-0.3)/0.4;\n    \n    //draw grid\n    float gridRet = grid(uv,vec2(0.025,0.025))*transition;\n    \n    //draw gradient vectors (red ones)\n    vec2 v0 = floor(uv+0.5);\n    float vecRet = vector(v0 , gradients[int(hash(v0)*4.0)], uv, 0.06, 0.03)*transition;\n    \n    \n    //draw perlin noise with [gradient - noise] transition\n    float gradRet = pNoiseTransition(uv);\n    \n\t//calculate alpha for noise\n    float NoGrad = clamp(1.0 - gridRet - vecRet, 0.0 ,1.0);\n    \n    fragColor = vec4(vec3(gradRet)*NoGrad,1.0) + vec4(0.0,(gridRet)*(1.0-vecRet),0.0,1.0) + vec4(vecRet,0.0,0.0,1.0);\n}","name":"Image","description":"","type":"image"}]}