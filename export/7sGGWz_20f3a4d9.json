{"ver":"0.1","info":{"id":"7sGGWz","date":"1631323963","viewed":200,"name":"Gooey Lava Lamp","username":"itslinaaaa","description":"A gooey honey lava lamp, try clicking on different positions to change the gooeyness and the lighting","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["lava","gooey"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\nfloat sphereSDF ( vec3 position, vec3 center, float radius ) {\n    float distance = length(center - position) - radius;\n    return distance;\n}\n\nfloat planeSDF ( vec3 position, vec3 start, vec3 direction ) {\n    float distance = dot(position - start, direction );\n    return distance;\n}\n\n\nfloat smin(float k, float a, float b) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    float y = mix(a, b, h) - k*h*(1.0-h);\n    return y;\n}\n\n\nfloat SDF ( vec3 position ) {\n    // Add all of the walls\n    float ground = planeSDF(position, vec3(0, -10, 0), vec3(0, 1, 0));\n    float roof = planeSDF(position, vec3(0, 10, 0), vec3(0, -1, 0));\n    float left = planeSDF(position, vec3(-20, 0, 0), vec3(1, 0, 0));\n    float right = planeSDF(position, vec3(28, 0, 0), vec3(-1, 0, 0));\n    float back = planeSDF(position, vec3(0, 0, 50), vec3(0, 0, -1));\n    \n    // Add the spheres\n    float t = iTime / 5.0;\n    float s1 = sphereSDF(position, vec3(0, 0, 30) + vec3(5, 20, 3) * sin(t), 3.0);\n    float s2 = sphereSDF(position, vec3(-4, 0, 30) + vec3(0, 20, 0) * sin(3.2 * t), 2.0);\n    float s3 = sphereSDF(position, vec3(2, 0, 32) + vec3(5, 20, 0) * sin(2.16 * t), 1.0);\n    float s4 = sphereSDF(position, vec3(1, 0, 34) + vec3(0, 20, 2) * sin(2.86 * t), 2.1);\n    float s5 = sphereSDF(position, vec3(2, 0, 30) + vec3(0, 20, 0) * sin(3.46 * t), 2.3);\n    \n    // Blend everything together to make goo\n    float blend = iMouse.y == 0.0 ? 10.0 : iMouse.y/50.0;\n    float nearest = \n        // Blend the walls\n        smin( blend, ground,\n        smin( blend, roof,\n        smin( blend, left,\n        smin( blend, right,\n        smin( blend, back,\n        \n        // Blend the spheres\n        smin( blend, s1,\n        smin( blend, s2,\n        smin( blend, s3,\n        smin( blend, s4,\n        s5\n    )))))))));\n    return nearest;\n}\n\n\nvec3 getNormal ( vec3 p ) {\n    #define eps 0.0001\n    float dx = SDF(p + vec3(eps, 0, 0)) - SDF(p - vec3(eps, 0, 0));\n    float dy = SDF(p + vec3(0, eps, 0)) - SDF(p - vec3(0, eps, 0));\n    float dz = SDF(p + vec3(0, 0, eps)) - SDF(p - vec3(0, 0, eps));\n    vec3 approxGrad = vec3(dx, dy, dz);\n    vec3 normal = normalize(approxGrad);\n    return normal;\n}\n\n\n\nfloat raymarch ( vec3 start, vec3 direction ) {\n    // Take a number of steps in the right direction\n    #define maxSteps 100\n    float converged = 0.0001;\n    float distance = 0.0;\n    vec3 current = start;\n    for(int i=0; i < maxSteps;i++){;\n        // Find the minimum distance and move by that amount\n        float surfaceDistance = SDF(current);\n        if ( surfaceDistance < converged ) return distance;\n        \n        // Take a step by the given amount\n        distance += surfaceDistance;\n        current += surfaceDistance * direction;\n    }\n    return distance;\n}\n\n\nvec3 lighting ( vec3 surface ) {\n    // Define the lighting parameters\n    vec3 light = vec3(0, 5, 18) + 15.0 * vec3(cos(iTime), 0, sin(iTime));\n    float strength = iMouse.x == 0.0 ? 0.6 : iMouse.x / iResolution.x;\n    vec3 specular = vec3(0.96, 0.74, 0.08);\n    vec3 diffuse = vec3(0.62, 0.46, 0.12);\n    \n    // Calculate the sphere's brightness\n    vec3 lightDelta = light - surface;\n    vec3 N = getNormal(surface);\n    vec3 L = normalize(lightDelta);\n    float lightDistance = raymarch(surface + 0.2 * N, L);\n    float brightness = strength * dot(N, L);\n    \n    // Add a Shadow color\n    float straightLightDistance = length(lightDelta);\n    bool occluded = straightLightDistance < 300.0\n        && straightLightDistance + 0.3 > lightDistance;\n    vec3 shadow = occluded\n        ? 0.5 * vec3(1, 1, 1)\n        : vec3(1, 1, 1);\n    \n    // Calculate the color\n    if ( brightness < 0.0 ) return diffuse;\n    vec3 color = brightness * specular * shadow + diffuse ;\n    return color;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Get the UV coordinates\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Get the normalized coordinates and the ray position\n    vec3 camera = vec3(0.0, 0.0, -1.0-0.15*sin(iTime));\n    vec3 start = vec3(uv, 0.0);\n    vec3 direction = start - camera;\n\n    // Get the distance to the nearest object\n    float distance = raymarch(start, direction);\n    if ( distance > 100.0 ) {\n        fragColor = vec4(0, 0, 0, 0);\n        return;\n    }\n    \n    // Find the surface point and the corresponding normal \n    vec3 surface = start + distance * direction;\n    vec3 color = lighting(surface);\n    fragColor = vec4(color, 0.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}