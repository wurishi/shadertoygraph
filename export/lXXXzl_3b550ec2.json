{"ver":"0.1","info":{"id":"lXXXzl","date":"1710171555","viewed":140,"name":"Boids Simulation","username":"rclovis","description":"Simple boids algorism","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["2d","simulation","birds","boids"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define nbrBoids 150\nconst float pi = 3.14159;\n\nmat2 rotate(float t) \n{\n    float s = sin(t);\n    float c = cos(t);\n\treturn mat2(c, s, -s, c);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 floatToColor(float value) {\n    // Map the float value to the hue range [0.0, 1.0]\n    float hue = value;\n\n    // Convert HSV to RGB\n    vec3 rgbColor = hsv2rgb(vec3(hue, 1.0, 1.0));\n\n    return rgbColor;\n}\n\nfloat drawTriangle (vec2 uv, vec2 pos, float angle)\n{\n    vec2 p = uv;\n    vec2 p0 = vec2(0., 0.04) * rotate(angle) + pos;\n    vec2 p1 = vec2(-0.025, -0.04) * rotate(angle) + pos;\n    vec2 p2 = vec2(0.025, -0.04) * rotate(angle) + pos;\n    \n    vec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn 1. - step(0., -sqrt(d.x)*sign(d.y));\n}\n\nvec3 drawBoids (vec2 uv)\n{\n    vec3 col = vec3(0.);\n    for (int i = 0;i < nbrBoids;i++) {\n        vec4 info = texture(iChannel0, vec2(float(i) + .5f, .5f)/iResolution.xy);\n        col += drawTriangle(uv, info.xy, info.z) * floatToColor(1.-info.w / float(nbrBoids));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 col = drawBoids(uv);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define nbrBoids 150\n#define localGroup 0.4\n#define speed 0.01\n\nconst float pi = 3.14159;\n\nvec2 hash(float n)\n{\n    return fract(sin(vec2(n,n*5.))*40.f);\n}\n\nvoid init(out vec4 fragColor, in vec2 fragCoord )\n{\n    float id = floor(fragCoord.x);\n    vec2 pos = (hash(id) * iResolution.xy * 2.0 - iResolution.xy) / iResolution.y;\n    float angle = fract(sin(id)) * 2. * pi;\n    fragColor = vec4(pos, angle, 0.);\n}\n\n\nvec4 getBoids(int id)\n{\n    return texture(iChannel0, vec2(float(id) + .5f, .5f)/iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.y > 0.5 || fragCoord.x > float(nbrBoids) )\n        discard;\n    vec4 boidInfo = texture(iChannel0, fragCoord/iResolution.xy);\n    if (iFrame < 2)\n        init(fragColor, fragCoord);\n    else {\n        vec2 separation = vec2(0.);\n        vec2 alignment = vec2(0.);\n        vec2 cohesion = vec2(0.);\n        float nbrNeighbor = 0.;\n        \n        for (int i = 0;i < nbrBoids;i++) {\n            vec4 info = getBoids(i);\n            if (length(info.xy - boidInfo.xy) > localGroup ||\n                floor(fragCoord.x) == float(i))\n                continue;\n            nbrNeighbor += 1.;\n            //separation\n            separation += normalize(info.xy - boidInfo.xy);\n            //\n            \n            //alignment\n            alignment += normalize(vec2(cos(info.z), sin(info.z)));\n            //\n            \n            //cohesion\n            cohesion += info.xy;\n            //\n        }\n        float newAngle = boidInfo.z;\n        vec2 newPos = boidInfo.xy;\n\n        if (nbrNeighbor != 0.) {\n            separation = -normalize(separation / nbrNeighbor);\n            alignment = normalize(alignment / nbrNeighbor);\n            cohesion = normalize(cohesion / nbrNeighbor - boidInfo.xy);\n            vec2 turnDirection = (cohesion + separation + alignment) / 3.; \n            float turnAngle = atan(turnDirection.y, turnDirection.x);\n            turnAngle = mod(turnAngle + pi, 2.0 * pi) - pi;\n            newAngle = turnAngle;\n        }\n\n        newPos = boidInfo.xy + vec2(sin(newAngle), cos(newAngle)) * speed;\n        vec2 ratio = iResolution.xy / iResolution.y;\n        newPos = mod(newPos + ratio, ratio * 2.0) - ratio;\n        fragColor = vec4(newPos, newAngle, nbrNeighbor);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}