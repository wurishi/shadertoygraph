{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define OCTAVES  8\n#define HIGH_QUALITY (1)\n#define DARK_FORCE (0)\n\n#if HIGH_QUALITY\n#define MAX_STEPS  128\n#else\n#define MAX_STEPS  64\n#endif\n#define THRESHOLD .00001\n\n\nconst float fogDensity = .15;\n\n\nfloat rand(in vec2 co){\n   return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand2(in vec2 co){\n   return fract(cos(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand3(in vec3 co){\n   return fract(sin(dot(co.xyz ,vec3(12.9898,78.233,213.576))) * 43758.5453);\n}\n\nfloat valueNoiseSimple3D(in vec3 vl) {\n    const vec2 helper = vec2(0., 1.);\n    vec3 grid = floor(vl);\n    vec3 interp = smoothstep(vec3(0.), vec3(1.), fract(vl));\n    \n    float interpY0 = mix(mix(rand3(grid),\n                         \t rand3(grid + helper.yxx),\n                         \t interp.x),\n                        mix(rand3(grid + helper.xyx),\n                         \trand3(grid + helper.yyx),\n                         \tinterp.x),\n                        interp.y);\n    \n    \n    float interpY1 = mix(mix(rand3(grid + helper.xxy),\n                         \t rand3(grid + helper.yxy),\n                         \tinterp.x),\n                        mix(rand3(grid + helper.xyy),\n                         \trand3(grid + helper.yyy),\n                         \tinterp.x),\n                        interp.y);\n    \n    return -1. + 2.*mix(interpY0, interpY1, interp.z);\n}\n\nfloat fractalNoise(in vec3 vl) {\n    const float persistance = 2.;\n    const float persistanceA = 2.;\n    float amplitude = .5;\n    float rez = 0.0;\n    float rez2 = 0.0;\n    vec3 p = vl;\n    \n    for (int i = 0; i < OCTAVES / 2; i++) {\n        rez += amplitude * valueNoiseSimple3D(p);\n        amplitude /= persistanceA;\n        p *= persistance;\n    }\n    \n    float h = smoothstep(0., 1., vl.y*.5 + .5 );\n    if (h > 0.01) { // small optimization, since Hermit polynom has low front at the start\n        // God is in the details\n        for (int i = OCTAVES / 2; i < OCTAVES; i++) {\n            rez2 += amplitude * valueNoiseSimple3D(p);\n            amplitude /= persistanceA;\n            p *= persistance;\n        }\n        rez += mix(0., rez2, h);\n    }\n    \n    return rez;\n}\n\nvec2 helix(vec3 p, float r, float width) {\n    return vec2(r*cos(p.z/ width), r*sin(p.z/ width));\n}\n\nfloat scene(in vec3 a) {\n   \n   float zVal = fractalNoise(a.xyz);\n\n   return -length(a.xy - helix(a, .25, 1.5)) + 1.\n#if HIGH_QUALITY\n       + zVal * 1.5;\n#else\n       + zVal * 1.1;\n#endif\n\n}\n\nvec3 snormal(in vec3 a) {\n   const vec2 e = vec2(.0001, 0.);\n   float w = scene(a);\n\n   return normalize(vec3(\n       scene(a+e.xyy) - w,\n       scene(a+e.yxy) - w,\n       scene(a+e.yyx) - w ));\n\n}\n\nfloat trace(in vec3 O, in vec3 D, out float hill) {\n    float L = 0.;\n    float d = 0.;\n    \n#if DARK_FORCE\n    L = 2.5;\n#endif\n\n    float L_prev = 0.;\n\n    for (int i = 0; i < MAX_STEPS; ++i) {\n#if HIGH_QUALITY\n       d = scene(O + D*L) * .25;\n#else\n       d = scene(O + D*L) * .45;\n#endif\n        \n\n        L_prev = L;\n        L += d;\n        if (abs(d) < THRESHOLD * L)\n            break;\n    }\n    \n    hill = d;\n    return L;\n}\n\nfloat occluded(in vec3 p, in float len, in vec3 dir) {\n    return max(0., len - scene(p + len * dir));\n}\n\nfloat occlusion(in vec3 p, in vec3 normal) {\n    vec3 rotZccw = vec3(-normal.y, normal.x, normal.z);\n    vec3 rotZcw = vec3(normal.y, -normal.x, normal.z);\n    \n    vec3 rotXccw = vec3(normal.x, normal.z, -normal.y);\n    vec3 rotXcw = vec3(normal.x, -normal.z, normal.y);\n    \n    vec3 rotYccw = vec3(normal.z, normal.y, -normal.x);\n    vec3 rotYcw = vec3(-normal.z, normal.y, normal.x);\n    \n    float rez = 0.;\n    const float dst = .15;\n\n   \trez+= occluded(p, dst, normal);\n    \n    rez+= occluded(p, dst, rotXccw);\n    rez+= occluded(p, dst, rotXcw);\n\n    rez+= occluded(p, dst, rotYccw);\n    rez+= occluded(p, dst, rotYcw);\n\n    rez+= occluded(p, dst, rotZccw);\n    rez+= occluded(p, dst, rotZcw);\n\n    return (1. - min(rez, 1.));\n}\n\nvec3 enlight(in vec3 p, in vec3 normal, in vec3 eye, in vec3 lightPos) {\n    \n    float normDir = .5 * dot(normal, vec3(0., 1., 0.));\n    float down = .5 - normDir;\n    float up = normDir + .5;\n    \n    vec3 dir = lightPos - p;\n    vec3 eyeDir = eye - p;\n    vec3 I = normalize(dir);\n\n    float mxB = valueNoiseSimple3D( (p.zxy - sin(p.z) * 0.1)*20. + valueNoiseSimple3D(\n        \t\t\t\t\t\t\t\t\t\t\t\t\tp * 55. +\n        \t\t\t\t\t\t\t\t\t\t\t\t\tvalueNoiseSimple3D(\n                                                                p*500. +\n                                                                valueNoiseSimple3D(\n                                                                    p*1000.)\n                                                            )\n    \t\t\t\t\t\t\t\t\t\t\t\t\t));\n    \n    /*\n    float mxB = valueNoiseSimple3D( p.zxy*20. + valueNoiseSimple3D(\n        \t\t\t\t\t\t\t\t\t\t\t\t\tp * 55. +\n        \t\t\t\t\t\t\t\t\t\t\t\t\tvalueNoiseSimple3D(\n                                                                p*500. +\n                                                                valueNoiseSimple3D(p*1000.)\n                                                            )\n    \t\t\t\t\t\t\t\t\t\t\t\t\t));\n    */\n    mxB = abs(mxB);\n    \n    vec3 grass = mix(vec3(0.258823529, 0.317647059, 0.062745098),\n                     vec3(0.835294118, 0.898039216, 0.611764706),\n                     mxB\n    );\n    \n    vec3 cave = vec3(0.850980392,\n                     0.592156863,\n                     0.294117647\n    );\n    \n    vec3 cave2 = vec3(0.505882353,\n                      0.31372549,\n                      0.156862745\n                     );\n    \n    float val1 = (p.x + p.y* 3. + p.z) * 100. +\n                                  2. * valueNoiseSimple3D(p * 80.);\n    float val2 = 1.5 * valueNoiseSimple3D(p * 160.);\n    float val3 = .75 * valueNoiseSimple3D(p * 320.);\n    \n   \n    vec3 ceilClr = mix(cave2, cave, abs(sin(val1 + val2 + val3)));\n    vec3 color = mix(vec3(.0), ceilClr, abs(down));\n    color = mix(cave, color, .5 + abs(normDir));\n    color = mix(color, grass, abs(up));\n    \n    vec3 ambient = color;\n    vec3 diffuse = max(dot(normal, I), 0.) * color.rgb;\n\n    return clamp(diffuse * 0.75 + ambient * occlusion(p, normal), 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 centered_uv = uv * 2. - 1.;\n    centered_uv.x *= iResolution.x / iResolution.y;\n\n    float timeOffset = iTime / 2.;\n    \n    vec3 O = vec3(0., -0.2, 1. - timeOffset);\n    O.xy += helix(O, .25, 1.5);\n    \n    vec3 D = normalize(vec3(centered_uv, -3.0));\n\n    float hill;\n    float path = trace(O, D, hill);\n    vec3 coord = O + path * D;\n    \n    vec3 resColor;\n    vec3 skyBlueColor = vec3(0.529411765, 0.807843137, 0.980392157);\n    vec3 bgColor = mix(vec3(1.), skyBlueColor, clamp(centered_uv.y, 0., 1.));\n\n    vec3 lightPos = vec3(0., 0., 1. - timeOffset);\n    lightPos.xy += O.xy;\n    vec3 normal = snormal(coord);\n\n    resColor = enlight(coord, normal, O, lightPos);\n    resColor = mix(resColor, bgColor, min(hill, 1.));\n\n    // Calc some fog\n    float fogFactor = exp(-pow(abs(fogDensity * (coord.z - .75 + timeOffset)), 6.0));\n    fogFactor = clamp(fogFactor, 0.0, 1.0);\n\n    resColor = mix(bgColor, resColor, fogFactor);\n\n\tfragColor = vec4(resColor,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MtsGDf","date":"1427155670","viewed":973,"name":"TrollsCave","username":"FatumR","description":"My experiments with 3D noise, water should be added.","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","fractal","noise","cave"],"hasliked":0,"parentid":"","parentname":""}}