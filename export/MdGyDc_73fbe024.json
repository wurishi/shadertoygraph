{"ver":"0.1","info":{"id":"MdGyDc","date":"1523540634","viewed":430,"name":"dancing balls v1","username":"indominator","description":"this is a shader of moving balls. comments in portuguese because of how lazy i am :/\n\nmade during class because it was boring","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["sphere","ball","points"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//pontos estaticos na tela para as bolas se mexherem atraves\n//converter a vec3\nconst vec2 \n    pos1 = vec2(0.,0.),pos2 = vec2(1.,1.), \n    pos3 = vec2(0.2,0.2), \n    pos4 = vec2(0.54,0.73),pos5 = vec2(0.23,0.4);\n\n\n//array de corres\nconst vec3 \n    cor1 = vec3(0.,0.,1.),cor2 = vec3(1.,1.,1.), \n    cor3 = vec3(0.,0.,1.), \n    cor4 = vec3(1.,1.,1.),cor5 = vec3(0.,0.,1.);\n\n//origem da luz \nconst vec3 light_origin = vec3(0.2,0.3,1.);\nconst vec3 light_color = vec3(1.,1.,1.);\n\n//posicao pontos\n//converter a vec3\nvec2 \n    p1,p2,\n    p3,\n    p4,p5;\n\n//tamanho dos circulos\nfloat s1 = 10.,s2 = 10.,s3 = 10.,s4 = 10.,s5 = 10.;\n\n\n\n//////////// POSICAO PONTOS\nvec2 lerp_pos(  float t){ \n    //REFAZRE POS PONTOS\n    vec2 p1,p2;\nint p = int(mod((t - mod(t,1.)),5.));\n    switch (p){\n     case 0:\n        p1 = pos1;\n                p2 = pos2;\n        break;\n             case 1:\n        p1 = pos2;\n                p2 = pos3;\n\n        break;\n             case 2:\n        p1 = pos3;\n                p2 = pos4;\n\n        break;\n             case 3:\n        p1 = pos4;\n                p2 = pos5;\n\n        break;\n             case 4:\n        p1 = pos5;\n                p2 = pos1;\n\n        break;\n    }\n    return p1*mod(t,1.) + p2*(1. - mod(t,1.));\n\n}\n\nvoid set_pontos(){\n    //t set\n    \n    p1 = lerp_pos(0.3 + iTime);\n    p2 = lerp_pos(0.4 + iTime);\n    p3 = lerp_pos(0.5 + iTime);\n    p4 = lerp_pos(0.6 + iTime);\n    p5 = lerp_pos(0.7 + iTime);\n}\n\n///////////////\n//CORES E LUYZ\n///////////\nvec3 sphere_color(float size, vec2 ponto, vec2 center,vec3 cor){\n    \n    \n    if(size - length(center - ponto) <0.)return vec3(0.,0.,0.);\n    \n    //get z for lightning\n    float z =sqrt( pow(size,2.) - pow(ponto.x - center.x,2.) - pow(center.y - ponto.y,2.));\n    vec3 normal = normalize(vec3(ponto - center,z));\n    \n    float cosTheta = clamp( dot( normal,   light_origin   - vec3(center/iResolution.xy,0.) ), 0.3,1.0);\n    \n    //cor mais luz\n    cor = cor*cosTheta \n        // a luz forte\n        + light_color.rgb * pow( length( light_origin - vec3(center/iResolution.xy,0.) - normal )/2., 8.0);\n    \n    return cor;\n}\nvec4 cores(vec2 ponto,  vec2 iRes){\n    vec3 cor = vec3(0.,0.,0.);\n    cor += sphere_color(s1,ponto,p1*iRes,cor1);\n    cor +=sphere_color(s2,ponto,p2*iRes,cor2);\n    cor +=sphere_color(s3,ponto,p3*iRes,cor3);\n    cor +=sphere_color(s4,ponto,p4*iRes,cor4);\n    cor +=sphere_color(s5,ponto,p5*iRes,cor5);\n    return vec4(cor.xyz,1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    set_pontos();\n    \n    fragColor = cores(fragCoord,iResolution.xy);\n}\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}