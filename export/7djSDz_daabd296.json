{"ver":"0.1","info":{"id":"7djSDz","date":"1620064757","viewed":174,"name":"Cornell Cake","username":"space928","description":"Cornell cake.\nFor Thomas' Birthday\n\nForked from: https://www.shadertoy.com/view/4ssGzS","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fake","lighting","shadows","antialias","box","ao","cornell"],"hasliked":0,"parentid":"4ssGzS","parentname":"The Cornell Box"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The Cornell Box - @h3r3\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Reproducing the famous Cornell Box through Raymarching, fake soft-shadows,\n// fake indirect lighting, ambient occlusion and antialiasing.\n// Reference data: http://www.graphics.cornell.edu/online/box/\n// Reference image: http://www.graphics.cornell.edu/online/box/box.jpg\n//Modified by Thomas M.\n\n// --- Adapt from GLSL Sandbox\n#define time iTime\n\n// Set ANTIALIAS_ALWAYS to false if the animation is too slow\n#define ANTIALIAS_ALWAYS true\n#define ANTIALIAS_SAMPLES 4\n#define ANIMATE_CAMERA\n\n#define PI 3.14159265359\n#define EXPOSURE 34.\n#define GAMMA 2.1\n#define SOFT_SHADOWS_FACTOR 4.\n#define MAX_RAYMARCH_ITER 128\n#define MAX_RAYMARCH_ITER_SHADOWS 16\n#define MIN_RAYMARCH_DELTA 0.0015\n#define GRADIENT_DELTA 0.0002\n#define OBJ_FLOOR\t\t1.\n#define OBJ_CEILING\t\t2.\n#define OBJ_BACKWALL\t3.\n#define OBJ_LEFTWALL\t4.\n#define OBJ_RIGHTWALL\t5.\n#define OBJ_LIGHT\t\t6.\n#define OBJ_SHORTBLOCK\t7.\n#define OBJ_TALLBLOCK\t8.\n#define OBJ_CAKE_BASE   9.\n#define OBJ_CAKE_ICING  10.\n#define OBJ_CAKE_CANDLE 11.\n#define OBJ_CAKE_FLAME  12.\n\n// RGB wavelengths: 650nm, 510nm, 475nm\nconst vec3 lightColor = vec3(16.86, 8.76 +2., 3.2 + .5);\nconst vec3 lightDiffuseColor = vec3(.78);\nconst vec3 leftWallColor = vec3(.611, .0555, .062);\nconst vec3 rightWallColor = vec3(.117, .4125, .115);\nconst vec3 whiteWallColor = vec3(.7295, .7355, .729);\nconst vec3 cakeBaseColor = vec3(.05, .04, .02);\nconst vec3 cakeIcingColor = vec3(1.5, 1.5, 1.9);\nconst vec3 cakeCandleColor = vec3(0.1, 0.2, 1.3);\nconst vec3 cakeCandleFlameColor = vec3(0.3, .15, 0.05)*0.1;\nconst vec3 cameraTarget = vec3(556, 548.8, 559.2) * .5;\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdSphere(vec3 p, float r, vec3 scale)\n{\n    return length(p*scale)-r;\n}\n\nfloat distort(float sdf, vec3 p, vec3 x, float period)\n{\n    vec3 dist = sin(p*period)*x;\n    float d = dist.x+dist.y+dist.z;\n    return sdf+d;\n}\n\nvec3 distortV(vec3 p, vec3 x, vec3 period, float phase)\n{\n    vec3 dist = sin(p*period+phase);\n    float d = dist.x+dist.y+dist.z;\n    return p+d*x;\n}\n\nvec3 rotateX(in vec3 p, float a) {\n\tfloat c = cos(a); float s = sin(a);\n\treturn vec3(p.x, c * p.y - s * p.z, s * p.y + c * p.z);\n}\n\nvec3 rotateY(vec3 p, float a) {\n\tfloat c = cos(a); float s = sin(a);\n\treturn vec3(c * p.x + s * p.z, p.y, -s * p.x + c * p.z);\n}\n\nvec3 rotateZ(vec3 p, float a) {\n\tfloat c = cos(a); float s = sin(a);\n\treturn vec3(c * p.x - s * p.y, s * p.x + c * p.y, p.z);\n}\n\nvec2 mapBlocks(vec3 p, vec3 ray_dir) { //  ray_dir may be used for some optimizations\n\tvec2 res = vec2(OBJ_SHORTBLOCK, sdBox(rotateY(p + vec3(-250, -82.5, -169.5), 0.29718), vec3(83.66749, 83.522452, 82.5)));\n\t//vec2 obj1 = vec2(OBJ_TALLBLOCK, sdBox(rotateY(p + vec3(-368.5, -165, -351.5), -0.30072115), vec3(87.02012, 165, 83.6675)));\n\t//if (obj1.y < res.y) res = obj1;\n\treturn res;\n}\n\nvec2 map(vec3 p, vec3 ray_dir) { //  ray_dir may be used for some optimizations\n\tvec2 res = vec2(OBJ_FLOOR, p.y);\n\tvec2 obj1 = vec2(OBJ_CEILING, 548.8 - p.y);\n\tif (obj1.y < res.y) res = obj1;\n\tvec2 obj2 = vec2(OBJ_BACKWALL, 559.2 - p.z);\n\tif (obj2.y < res.y) res = obj2;\n\tvec2 obj3 = vec2(OBJ_LEFTWALL, 556. - p.x);\n\tif (obj3.y < res.y) res = obj3;\n\tvec2 obj4 = vec2(OBJ_RIGHTWALL, p.x);\n\tif (obj4.y < res.y) res = obj4;\n\tvec2 obj5 = vec2(OBJ_LIGHT, sdBox(p + vec3(-278, -548.8, -292+150), vec3(65, 0.05, 65)));\n\tif (obj5.y < res.y) res = obj5;\n\tvec2 obj6 = mapBlocks(p, ray_dir);\n\tif (obj6.y < res.y) res = obj6;\n    \n    vec2 cakeBase = vec2(OBJ_CAKE_BASE, sdRoundedCylinder(p + vec3(-250, -180., -169.5), 30., 10., 20.));\n    if(cakeBase.y < res.y) res = cakeBase;\n    \n    vec2 cakeIcing = vec2(OBJ_CAKE_ICING, \n            sdRoundedCylinder(distortV(p, vec3(0.0,p.y<190.?2.:0.,0.0), vec3(0.3,0.0,0.3), 0.) + vec3(-250, -195., -169.5), 31., 10., 11.));\n            //distort(sdRoundedCylinder(p + vec3(-250, -180., -169.5), 32., 10., 22.),\n            //   p, vec3(.2,0.2,0.2), 0.3));\n    if(cakeIcing.y < res.y) res = cakeIcing;\n  \n    vec2 cakeCandle = vec2(OBJ_CAKE_CANDLE, \n            sdRoundedCylinder(distortV(p, vec3(0.1, 0., 0.1), vec3(1.5,1.5,1.5), 0.) + vec3(-250, -225., -169.5), 1.5, 2., 15.));\n    if(cakeCandle.y < res.y) res = cakeCandle;\n    \n    vec2 cakeCandleFlame = vec2(OBJ_CAKE_FLAME, \n            sdSphere(distortV(p, vec3(0.1, 0.3, 0.1), vec3(1.8,1.0,1.8), iTime*20.) + vec3(-250, -250., -169.5), 2., vec3(1.,.3,1.)));\n    if(cakeCandleFlame.y < res.y) res = cakeCandleFlame;\n    \n\treturn res;\n}\n\nvec2 map(vec3 p) {\n    return map(p, vec3(0,0,0));\n}\n\nvec3 gradientNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(GRADIENT_DELTA, 0, 0)).y - map(p - vec3(GRADIENT_DELTA, 0, 0)).y,\n        map(p + vec3(0, GRADIENT_DELTA, 0)).y - map(p - vec3(0, GRADIENT_DELTA, 0)).y,\n        map(p + vec3(0, 0, GRADIENT_DELTA)).y - map(p - vec3(0, 0, GRADIENT_DELTA)).y));\n}\n\nfloat raymarch(vec3 ray_start, vec3 ray_dir, out float dist, out vec3 p, out int iterations) {\n    dist = 0.0;\n    float minStep = 0.1;\n\tvec2 mapRes;\n    for (int i = 1; i <= MAX_RAYMARCH_ITER; i++) {\n        p = ray_start + ray_dir * dist;\n        mapRes = map(p, ray_dir);\n        if (mapRes.y < MIN_RAYMARCH_DELTA) {\n           iterations = i;\n           return mapRes.x;\n        }\n        dist += max(mapRes.y, minStep);\n    }\n    return -1.;\n}\n\nbool raymarch_to_light(vec3 ray_start, vec3 ray_dir, float maxDist, float maxY, out float dist, out vec3 p, out int iterations, out float light_intensity) {\n    dist = 0.; \n    float minStep = 1.0;\n    light_intensity = 1.0;\n\tfloat mapDist;\n    for (int i = 1; i <= MAX_RAYMARCH_ITER_SHADOWS; i++) {\n        p = ray_start + ray_dir * dist;\n        mapDist = mapBlocks(p, ray_dir).y;\n        if (mapDist < MIN_RAYMARCH_DELTA) {\n            iterations = i;\n            return true;\n        }\n\t\tlight_intensity = min(light_intensity, SOFT_SHADOWS_FACTOR * mapDist / dist);\n\t\tdist += max(mapDist, minStep);\n        if (dist >= maxDist || p.y > maxY) { break; }\n    }\n    return false;\n}\n\nvec3 interpolateNormals(vec3 v0, vec3 v1, float x) {\n\tx = smoothstep(0., 1., x);\n\treturn normalize(vec3(mix(v0.x, v1.x, x),\n\t\tmix(v0.y, v1.y, x),\n\t\tmix(v0.z, v1.z, x)));\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n) {\n    float step = 20.;\n    float ao = 0.;\n    float dist;\n    for (int i = 1; i <= 3; i++) {\n        dist = step * float(i);\n\t\tao += max(0., (dist - map(p + n * dist).y) / dist);  \n    }\n    return 1. - ao * 0.12;\n}\n\nvec3 render(vec3 ray_start, vec3 ray_dir) {\n\tfloat dist; vec3 p; int iterations;\n\tfloat objectID = raymarch(ray_start, ray_dir, dist, p, iterations);\n\t\n\tvec3 color = vec3(0);\n\tif (p.z >= 0.) {\n\t\tif (objectID == OBJ_FLOOR) color = whiteWallColor;\n\t\telse if (objectID == OBJ_CEILING) color = whiteWallColor;\n\t\telse if (objectID == OBJ_BACKWALL) color = whiteWallColor;\n\t\telse if (objectID == OBJ_LEFTWALL) color = leftWallColor;\n\t\telse if (objectID == OBJ_RIGHTWALL) color = rightWallColor;\n\t\telse if (objectID == OBJ_LIGHT) color = lightDiffuseColor;\n\t\telse if (objectID == OBJ_SHORTBLOCK) color = whiteWallColor;\n\t\telse if (objectID == OBJ_TALLBLOCK) color = whiteWallColor;\n        else if (objectID == OBJ_CAKE_BASE) color = cakeBaseColor;\n        else if (objectID == OBJ_CAKE_ICING) color = cakeIcingColor;\n        else if (objectID == OBJ_CAKE_CANDLE) color = cakeCandleColor;\n\t\telse if (objectID == OBJ_CAKE_FLAME) color = cakeCandleFlameColor;\n        \n\t\tif (objectID == OBJ_LIGHT || objectID == OBJ_CAKE_FLAME) {\n\t\t\tcolor *= lightColor;\n\t\t} else {\n\t\t\tfloat lightSize = 25.;\n\t\t\tvec3 lightPos = vec3(278, 548.8 -50., 292 - 250);\n\t\t\tif (objectID == OBJ_CEILING) { lightPos.y -= 550.; }\n\t\t\t\n\t\t\tlightPos.x = max(lightPos.x - lightSize, min(lightPos.x + lightSize, p.x));\n\t\t\tlightPos.y = max(lightPos.y - lightSize, min(lightPos.y + lightSize, p.y));\n\t\t\tvec3 n = gradientNormal(p);\n\t\t\t\n\t\t\tvec3 l = normalize(lightPos - p);\n\t\t\tfloat lightDistance = length(lightPos - p);\n\t\t\tfloat atten = ((1. / lightDistance) * .5) + ((1. / (lightDistance * lightDistance)) * .5);\n\t\t\t\n\t\t\tvec3 lightPos_shadows = lightPos + vec3(0, 140, -50);\n\t\t\tvec3 l_shadows = normalize(lightPos_shadows - p);\n\t\t\tfloat dist; vec3 op; int iterations; float l_intensity;\n\t\t\tbool res = raymarch_to_light(p + n * .11, l_shadows, lightDistance, 400., dist, op, iterations, l_intensity);\n\t\t\t\n\t\t\tif (res && objectID != OBJ_CEILING) l_intensity = 0.;\n\t\t\tl_intensity = max(l_intensity,.25);\n\t\t\tvec3 c1 = color * max(0., dot(n, l)) * lightColor * l_intensity * atten;\n\t\t\t\n\t\t\t// Indirect lighting\n\t\t\tvec3 c2_lightColor = lightColor * rightWallColor * .08;\n\t\t\tfloat c2_lightDistance = p.x + 0.00001;\n\t\t\tfloat c2_atten = 1. / c2_lightDistance;\n\t\t\tvec3 c2_lightDir0 = vec3(-1,0,0);\n\t\t\tvec3 c2_lightDir1 = normalize(vec3(-300., 548.8/2.,559.2/2.) - p);\n\t\t\tfloat c2_perc = min(p.x * .01, 1.);\n\t\t\tvec3 c2_lightDirection = interpolateNormals(c2_lightDir0, c2_lightDir1, c2_perc);\n\t\t\tvec3 c2 = color * max(0., dot(n, c2_lightDirection)) * c2_lightColor * c2_atten;\n\t\t\t\n\t\t\tvec3 c3_lightColor = lightColor * leftWallColor * .08;\n\t\t\tfloat c3_lightDistance = 556. - p.x + 0.1;\n\t\t\tfloat c3_atten = 1. / c3_lightDistance;\n\t\t\tvec3 c3_lightDir0 = vec3(1,0,0);\n\t\t\tvec3 c3_lightDir1 = normalize(vec3(556. + 300., 548.8/2.,559.2/2.) - p);\n\t\t\tfloat c3_perc = min((556. - p.x) * .01, 1.);\n\t\t\tvec3 c3_lightDirection = interpolateNormals(c3_lightDir0, c3_lightDir1, c3_perc);\n\t\t\tvec3 c3 = color * max(0., dot(n, c3_lightDirection)) * c3_lightColor * c3_atten;\n\t\t\t\n\t\t\tcolor = color * .0006 + c1;\n\t\t\tcolor += c2 + c3; // Fake indirect lighting\n\t\t\t\n\t\t\t// Ambient occlusion\n\t\t\tfloat ao = ambientOcclusion(p, n);\n\t\t\tcolor *= ao;\n\t\t}\n\t}\n\treturn color;\n}\n\nvec3 rotateCamera(vec3 ray_start, vec3 ray_dir) {\n\tray_dir.x = -ray_dir.x; // Flip the x coordinate to match the scene data\n\tvec3 target = normalize(cameraTarget - ray_start);\n\tfloat angY = atan(target.z, target.x);\n\tray_dir = rotateY(ray_dir, PI/2. - angY);\n\tfloat angX = atan(target.y, target.z);\n\tray_dir = rotateX(ray_dir, - angX);\n\t#ifdef ANIMATE_CAMERA\n\t\tfloat angZ = smoothstep(0., 1., (time - 5.) * .1) * sin(time * 1.1 + .77) * .05;\n\t\tray_dir = rotateZ(ray_dir, angZ);\n\t#endif\n\treturn ray_dir;\n}\n\nvec3 moveCamera(vec3 ray_start) {\n\tray_start += vec3(278, 273, -400);\n\t#ifdef ANIMATE_CAMERA\n\t\tvec3 ray_start_a = ray_start\n\t\t\t+ vec3(cos(time * 0.8) * 140., cos(time * 0.9) * 140., (cos(time * .3) + 1.) * 190.);\n\t\treturn mix(ray_start, ray_start_a, smoothstep(0., 1., (time - 5.) * .1));\n\t#else\n\t\treturn ray_start;\n\t#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 resolution = iResolution.xy;\n    vec2 mouse = min(iMouse.xy / iResolution.xy, vec2(1));\n\n    \n\tvec3 ray_start = vec3(0, 0, -1.4);\n\tvec3 color = vec3(0);\n\tif (ANTIALIAS_ALWAYS || time < 5.) {\n\t\t// ANTIALIAS\n\t\tfloat d_ang = 2.*PI / float(ANTIALIAS_SAMPLES);\n\t\tfloat ang = d_ang * .333;\n\t\tfloat r = .4;\n\t\tfor (int i = 0; i < ANTIALIAS_SAMPLES; i++) {\n\t\t\tvec2 position = vec2((fragCoord.x + cos(ang)*r - resolution.x *.5) / resolution.y, (fragCoord.y + sin(ang)*r - resolution.y *.5) / resolution.y);\n\t\t\tvec3 ray_s = moveCamera(ray_start);\n\t\t\tvec3 ray_dir = rotateCamera(ray_s,normalize(vec3(position, 0) - ray_start));\n\t\t\tcolor += render(ray_s, ray_dir);\n\t\t\tang += d_ang;\n\t\t}\n\t\tcolor /= float(ANTIALIAS_SAMPLES);\n\t} else {\n\t\t// NO ANTIALIAS\n\t\tvec2 position = vec2((fragCoord.x - resolution.x *.5) / resolution.y, (fragCoord.y - resolution.y *.5) / resolution.y);\n\t\tvec3 ray_s = moveCamera(ray_start);\n\t\tvec3 ray_dir = rotateCamera(ray_s, normalize(vec3(position, 0) - ray_start));\n\t\tcolor += render(ray_s, ray_dir);\n\t}\n\t\n\tcolor *= EXPOSURE;\n\tcolor = pow(color, vec3(1. / GAMMA));\n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}