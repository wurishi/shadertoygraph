{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n-A variation of Otavio Good's Topologica https://www.shadertoy.com/view/4djXzz\n*/\n\nconst float line_strength = .005;\n\n//#define PROCEDURAL\n\n#ifdef PROCEDURAL\n\n// various noise functions\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(cos(f*3.333)*100003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\n\nconst vec2 zeroOne = vec2(0.0, 1.0);\n\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x), mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x), mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\n#else\n\n// texture noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\n\tvec2 rg1 = texture( iChannel0, (uv+ vec2(0.5,0.5))/256.0, -100.0 ).yx;\n\tvec2 rg2 = texture( iChannel0, (uv+ vec2(1.5,0.5))/256.0, -100.0 ).yx;\n\tvec2 rg3 = texture( iChannel0, (uv+ vec2(0.5,1.5))/256.0, -100.0 ).yx;\n\tvec2 rg4 = texture( iChannel0, (uv+ vec2(1.5,1.5))/256.0, -100.0 ).yx;\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\n\t\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n#endif\n\nfloat Density(vec3 p)\n{\n    float final = noise(p*0.57115);\n    float other = noise(p*2.07137);\t\n    final -= 0.5;\n    final = 0.1/(abs(final*other*other));\n    return final*line_strength;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;// - 0.5;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0); // vuv\n\n\t// Camera lookat.\n\tvec3 camLookat=vec3(0,0.0,0);\t// vrp\n\n\tfloat mx= iTime * 0.002;\n\tfloat my=sin(iTime * 0.006)*0.2+0.2;//*PI/2.01;\n\tvec3 camPos=vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(200.2); \t// prp\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);//vpn\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\t// u\n\tvec3 upNorm=cross(camVec, sideNorm);//v\n\tvec3 worldFacing=(camPos + camVec);//vcv\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;//scrCoord\n\tvec3 relVec = normalize(worldPix - camPos);//scp\n\n\t// --------------------------------------------------------------------------------\n\tfloat t = -5.0;\n\tfloat inc;\n\tfloat maxDepth = 70.0;\n \tfloat density = 0.;\n    \n    float temp;\n    \n\t// ray marching time\n    for (int i = 0; i < 15; i++)\t// This is the count of how many times the ray actually marches.\n    {\n        if ((t > maxDepth)) break;\n    \n        temp = Density(camPos + relVec * t);\n        inc = 1.9 + temp*.05;\t\n        density += temp * inc;\n \n        t += inc;\n    }\n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this.\n\tvec3 finalColor = vec3(0.6,0.09,0.01)* density * .075;\n     \n  \tfragColor = vec4(pow(finalColor,vec3(.5)), 1.);\n    \n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Ms2XzD","date":"1409970328","viewed":682,"name":"Variations of Topologica","username":"73v3","description":"an amble into amber","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["noise","glow","contour"],"hasliked":0,"parentid":"","parentname":""}}