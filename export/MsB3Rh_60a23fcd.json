{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// necessary declarations to use picker\nstruct Rect\n{\n\tfloat x, y, w, h;\n};\nvoid colPicker( float alpha, Rect r, vec2 uv, out vec4 thisPixelCol, out vec3 selectedCol );\n\n\n// your code starts here\n\nvec3 pickerCol;\n\nfloat hillsH( vec2 pp )\n{\n\tpp.y += abs(\n\t\t.4 * sin(2.3*pp.x+pp.y) +\n\t\t.2 * sin(5.5*pp.x+pp.y) +\n\t\t0.1*sin(13.7*pp.x)+\n\t\t0.06*sin(23.*pp.x));\n\treturn pp.y;\n}\n\nfloat bgInten( in vec2 pp )\n{\n\tfloat col = 1.;\n\tfloat thisLayer, h, alpha;\n\t\n\t// bg to fg\n\tthisLayer = .85;\n\th = hillsH( pp + vec2(.04*iTime,8.0));\n\talpha = smoothstep(1.,0.,(h-10.)/0.2);\n\tcol = (1.-alpha)*col + alpha*thisLayer;\n\t\n\tthisLayer = .5;\n\th = hillsH( pp + vec2(.1*iTime-20.,8.3));\n\talpha = smoothstep(1.,0.,(h-10.)/0.05);\n\tcol = (1.-alpha)*col + alpha*thisLayer;\n\t\n\tthisLayer = .2;\n\th = hillsH( pp + vec2(.25*iTime-10.,8.7));\n\talpha = smoothstep(1.,0.,(h-10.)/0.3);\n\tcol = (1.-alpha)*col + alpha*thisLayer;\n\t\n\treturn col;\n}\n\nvec3 backgroundColour( vec2 uv )\n{\n\tvec3 baseCol;\n\t\n\t// has a colour been picked?\n\tif( pickerCol.x > -1. )\n\t\tbaseCol = pickerCol; // yes, use it\n\telse\n\t\tbaseCol = vec3(1.,.166,0.767); // no, use default\n\t\n\tfloat vignette = 1.-length(uv-vec2(0.5,0.7));\n\tvignette *= vignette;\n\tvignette = smoothstep(0.1,1.,vignette);\n\treturn vignette * baseCol * bgInten(uv*4.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\t// do the colour picker\n\tRect pickerRect = Rect( .75, .0, .25, .25 );\n\tvec4 thisPixelCol;\n\tcolPicker( 1.0, pickerRect, uv, thisPixelCol, pickerCol );\n\t\n\t// do shader stuff. here i call a function to get the bg colour\n\tfragColor.a = 1.0;\n\tfragColor.xyz = backgroundColour(uv);\n\t\n\t\n\t// finally, alpha blend in the colour picker control to make it visible\t\n\tfragColor = (1.-thisPixelCol.a) * fragColor + thisPixelCol.a * thisPixelCol;\n}\n\n\n// the rest of the code is the picker implementation\n\nbool inRect( Rect r, vec2 uv );\nvec3 hsv2rgb(vec3 c);\nfloat drawNumber( float num, vec2 pos, vec2 pixel_coords );\n\nvec3 spectrum( Rect r, vec2 uv )\n{\n\tfloat h = (uv.x-r.x)/r.w;\n\tfloat s = clamp(  1.-2.*(uv.y-r.h/2.-r.y)/r.h  ,0.,1.);\n\tfloat v = clamp(2.*(uv.y-r.y)/r.h, 0., 1.) ;\n\treturn hsv2rgb( vec3(h,s,v) );\n}\n\nvoid colPicker( float alpha, Rect r, vec2 uv, out vec4 thisPixelCol, out vec3 selectedCol )\n{\n\t// see if the mouse is in the spectrum, if so return the colour\n\tvec2 mxy = iMouse.xy / iResolution.xy;\n\n\tif( inRect( r, mxy ) )\n\t{\n\t\tselectedCol = spectrum(r,mxy);\n\t}\n\telse\n\t{\n\t\t// this means nothing selected\n\t\tselectedCol = vec3(-1.);\n\t}\n\t\n\t// see if the current pixl is inside the colour picker, if so return the spectrum\n\tif( inRect( r, uv ) )\n\t{\n\t\tthisPixelCol = vec4( spectrum(r,uv), alpha );\n\t\t\n\t\t// write the values of the selected colour\n\t\tfloat dig = 0.;\n\t\tfloat numberWidth = 26.;\n\t\tfloat totalWidth = 3.0 * numberWidth;\n\t\tfloat startX = r.x + r.w/2. - .5*totalWidth/iResolution.x;\n\t\tdig = drawNumber( selectedCol.r, vec2(startX,r.y), vec2(uv.x,uv.y) );\n\t\tif( dig > 0. )\n\t\t\tthisPixelCol.rgb = vec3(1.,0.,0.); // white digits\n\t\tdig = drawNumber( selectedCol.g, vec2(startX+numberWidth/iResolution.x,r.y), uv );\n\t\tif( dig > 0. )\n\t\t\tthisPixelCol.rgb = vec3(0.,1.,0.); // white digits\n\t\tdig = drawNumber( selectedCol.b, vec2(startX+2.*numberWidth/iResolution.x,r.y), uv );\n\t\tif( dig > 0. )\n\t\t\tthisPixelCol.rgb = vec3(0.,0.,1.); // white digits\n\t}\n\telse\n\t{\n\t\tthisPixelCol = vec4( 0. );\n\t}\n}\n\nbool inRect( Rect r, vec2 uv )\n{\n\treturn\n\t\tuv.x >= r.x && uv.x <= r.x + r.w &&\n\t\tuv.y >= r.y && uv.y <= r.y + r.h;\n}\n\n\n//http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\n// digits based on the nice ascii shader by movAX13h\n\nfloat drawDig( vec2 pos, vec2 pixel_coords, float bitfield )\n{\n\t// offset relative to \n\tvec2 ic = pixel_coords - pos ;\n\tic = floor(ic*iResolution.xy);\n\t// test if overlap letter\n\tif( clamp(ic.x, 0., 2.) == ic.x && clamp(ic.y, 0., 4.) == ic.y )\n\t{\n\t\t// compute 1d bitindex from 2d pos\n\t\tfloat bitIndex = ic.y*3.+ic.x;\n\t\t// isolate the bit\n\t\treturn floor( mod( bitfield / exp2( floor(bitIndex) ), 2. ) );\n\t}\n\treturn 0.;\n}\n// decimal point\nfloat drawDecPt( vec2 center, vec2 pixel_coords )\n{\n\treturn drawDig( center, pixel_coords, 1. );\n}\n// minus sign\nfloat drawMinus( vec2 center, vec2 pixel_coords )\n{\n\treturn drawDig( center, pixel_coords, 448. );\n}\n// digits 0 to 9\nfloat drawDigit( float dig, vec2 pos, vec2 pixel_coords )\n{\n\tif( dig == 1. )\n\t\treturn drawDig( pos, pixel_coords, 18724. );\n\tif( dig == 2. )\n\t\treturn drawDig( pos, pixel_coords, 31183. );\n\tif( dig == 3. )\n\t\treturn drawDig( pos, pixel_coords, 31207. );\n\tif( dig == 4. )\n\t\treturn drawDig( pos, pixel_coords, 23524. );\n\tif( dig == 5. )\n\t\treturn drawDig( pos, pixel_coords, 29671. );\n\tif( dig == 6. )\n\t\treturn drawDig( pos, pixel_coords, 29679. );\n\tif( dig == 7. )\n\t\treturn drawDig( pos, pixel_coords, 31012. );\n\tif( dig == 8. )\n\t\treturn drawDig( pos, pixel_coords, 31727. );\n\tif( dig == 9. )\n\t\treturn drawDig( pos, pixel_coords, 31719. );\n\t// 0\n\treturn drawDig( pos, pixel_coords, 31599. );\n}\n\n// height is 6px\n// digit width is 4px\n// dec pt width is 2px\n// minus sign width is 4px\n// max num width is 30px (minus, 3 nums, dec pt, 3 nums)\n// for colour picker, num is x.xxx, max width is 18px\nfloat drawNumber( float num, vec2 pos, vec2 pixel_coords )\n{\n\tfloat result = 0.;\n\tbool on = false;\n\tfloat d;\n\t\n\t// minus sign\n\tif( num < 0. )\n\t{\n\t\tresult += drawMinus( pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t\tnum = -num;\n\t}\n\t// hundreds\n\td = floor(mod(num/100.,10.));\n\tif( on || d > 0. )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t\ton = true;\n\t}\n\t// tens\n\td = floor(mod(num/10.,10.));\n\tif( on || d > 0. )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t\ton = true;\n\t}\n\t// ones\n\td = floor(mod(num,10.));\n\tresult += drawDigit( d, pos, pixel_coords );\n\tpos.x += 4. / iResolution.x;\n\t// dec pt\n\tresult += drawDecPt( pos, pixel_coords );\n\tpos.x += 2. / iResolution.x;\n\t// tenths\n\td = floor(mod(num/.1,10.));\n\tif( true )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t}\n\t// hundredths\n\td = floor(.5+mod(num/.01,10.));\n\tif( d > 0. )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t}\n\t// thousandths\n\td = floor(.5+mod(num/.001,10.));\n\tif( d > 0. )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t}\n\t\n\treturn clamp(result,0.,1.);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsB3Rh","date":"1383479616","viewed":469,"name":"ColourPicker","username":"huwb","description":"Simple colour picker","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["color","colour","picker"],"hasliked":0,"parentid":"","parentname":""}}